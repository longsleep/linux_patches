From foo@baz Mon Apr 27 14:44:31 PDT 2009
Date: Mon, 27 Apr 2009 14:44:31 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Staging: comedi: remove comedi-specific wrappers

From: Greg Kroah-Hartman <gregkh@suse.de>

There are a number of comedi "wrappers" for some RT functions that are
about to go away.  This patch removes all of the wrapper calls within
the comedi drivers and core in order to prepare for removing the RT
comedi code.

Cc: Ian Abbott <abbotti@mev.co.uk>
Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/comedi/comedi_fops.c                       |   37 -
 drivers/staging/comedi/drivers.c                           |    8 
 drivers/staging/comedi/drivers/addi-data/addi_amcc_s5933.h |   10 
 drivers/staging/comedi/drivers/addi-data/addi_common.c     |   14 
 drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h   |   10 
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c  |    2 
 drivers/staging/comedi/drivers/adl_pci9111.c               |   15 
 drivers/staging/comedi/drivers/adl_pci9118.c               |   66 +--
 drivers/staging/comedi/drivers/adq12b.c                    |    6 
 drivers/staging/comedi/drivers/adv_pci1710.c               |   54 +-
 drivers/staging/comedi/drivers/adv_pci1723.c               |   12 
 drivers/staging/comedi/drivers/adv_pci_dio.c               |   18 
 drivers/staging/comedi/drivers/aio_aio12_8.c               |    2 
 drivers/staging/comedi/drivers/amplc_dio200.c              |   20 -
 drivers/staging/comedi/drivers/amplc_pc236.c               |   16 
 drivers/staging/comedi/drivers/amplc_pci224.c              |   36 -
 drivers/staging/comedi/drivers/amplc_pci230.c              |   86 ++--
 drivers/staging/comedi/drivers/cb_das16_cs.c               |   14 
 drivers/staging/comedi/drivers/cb_pcidas.c                 |  106 ++---
 drivers/staging/comedi/drivers/cb_pcidas64.c               |  122 +++---
 drivers/staging/comedi/drivers/cb_pcimdas.c                |    4 
 drivers/staging/comedi/drivers/comedi_fc.c                 |    2 
 drivers/staging/comedi/drivers/comedi_parport.c            |    6 
 drivers/staging/comedi/drivers/comedi_rt_timer.c           |    4 
 drivers/staging/comedi/drivers/contec_pci_dio.c            |    6 
 drivers/staging/comedi/drivers/daqboard2000.c              |   48 +-
 drivers/staging/comedi/drivers/das08.c                     |    4 
 drivers/staging/comedi/drivers/das16.c                     |   21 -
 drivers/staging/comedi/drivers/das16m1.c                   |   10 
 drivers/staging/comedi/drivers/das1800.c                   |   20 -
 drivers/staging/comedi/drivers/das6402.c                   |    4 
 drivers/staging/comedi/drivers/das800.c                    |   48 +-
 drivers/staging/comedi/drivers/dmm32at.c                   |    5 
 drivers/staging/comedi/drivers/dt2801.c                    |    4 
 drivers/staging/comedi/drivers/dt2811.c                    |    8 
 drivers/staging/comedi/drivers/dt2814.c                    |   10 
 drivers/staging/comedi/drivers/dt2815.c                    |    6 
 drivers/staging/comedi/drivers/dt282x.c                    |   15 
 drivers/staging/comedi/drivers/dt3000.c                    |    8 
 drivers/staging/comedi/drivers/fl512.c                     |    2 
 drivers/staging/comedi/drivers/gsc_hpdi.c                  |   26 -
 drivers/staging/comedi/drivers/icp_multi.c                 |   12 
 drivers/staging/comedi/drivers/icp_multi.h                 |   12 
 drivers/staging/comedi/drivers/jr3_pci.c                   |   12 
 drivers/staging/comedi/drivers/me4000.c                    |    2 
 drivers/staging/comedi/drivers/mite.c                      |   28 -
 drivers/staging/comedi/drivers/mite.h                      |    2 
 drivers/staging/comedi/drivers/mpc624.c                    |   66 +--
 drivers/staging/comedi/drivers/ni_6527.c                   |    6 
 drivers/staging/comedi/drivers/ni_65xx.c                   |   10 
 drivers/staging/comedi/drivers/ni_660x.c                   |   40 --
 drivers/staging/comedi/drivers/ni_670x.c                   |    2 
 drivers/staging/comedi/drivers/ni_at_a2150.c               |   18 
 drivers/staging/comedi/drivers/ni_atmio.c                  |   14 
 drivers/staging/comedi/drivers/ni_atmio16d.c               |    7 
 drivers/staging/comedi/drivers/ni_daq_700.c                |    2 
 drivers/staging/comedi/drivers/ni_daq_dio24.c              |    2 
 drivers/staging/comedi/drivers/ni_labpc.c                  |   72 +--
 drivers/staging/comedi/drivers/ni_mio_common.c             |  255 ++++++-------
 drivers/staging/comedi/drivers/ni_mio_cs.c                 |   12 
 drivers/staging/comedi/drivers/ni_pcidio.c                 |   21 -
 drivers/staging/comedi/drivers/ni_pcimio.c                 |   27 -
 drivers/staging/comedi/drivers/ni_stc.h                    |   14 
 drivers/staging/comedi/drivers/ni_tio.c                    |    4 
 drivers/staging/comedi/drivers/ni_tio_internal.h           |    8 
 drivers/staging/comedi/drivers/ni_tiocmd.c                 |   36 -
 drivers/staging/comedi/drivers/pcl711.c                    |    8 
 drivers/staging/comedi/drivers/pcl724.c                    |   11 
 drivers/staging/comedi/drivers/pcl726.c                    |   10 
 drivers/staging/comedi/drivers/pcl812.c                    |   81 ++--
 drivers/staging/comedi/drivers/pcl816.c                    |   96 ++--
 drivers/staging/comedi/drivers/pcl818.c                    |  108 ++---
 drivers/staging/comedi/drivers/pcmmio.c                    |   34 -
 drivers/staging/comedi/drivers/pcmuio.c                    |   34 -
 drivers/staging/comedi/drivers/plx9080.h                   |    8 
 drivers/staging/comedi/drivers/rtd520.c                    |   22 -
 drivers/staging/comedi/drivers/rti800.c                    |   13 
 drivers/staging/comedi/drivers/s526.c                      |    4 
 drivers/staging/comedi/drivers/s626.c                      |   14 
 drivers/staging/comedi/drivers/s626.h                      |    2 
 drivers/staging/comedi/drivers/serial2002.c                |    2 
 drivers/staging/comedi/drivers/skel.c                      |    4 
 drivers/staging/comedi/drivers/unioxx5.c                   |    2 
 drivers/staging/comedi/kcomedilib/data.c                   |    4 
 drivers/staging/comedi/kcomedilib/kcomedilib_main.c        |   24 -
 drivers/staging/comedi/range.c                             |    7 
 86 files changed, 1026 insertions(+), 1061 deletions(-)

--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -728,7 +728,7 @@ static int check_insn_config_length(stru
 	/* by default we allow the insn since we don't have checks for
 	 * all possible cases yet */
 	default:
-		rt_printk("comedi: no check for data length of config insn id "
+		printk("comedi: no check for data length of config insn id "
 			  "%i is implemented.\n"
 			  " Add a check to %s in %s.\n"
 			  " Assuming n=%i is correct.\n", data[0], __func__,
@@ -1219,12 +1219,12 @@ static int do_lock_ioctl(struct comedi_d
 		return -EINVAL;
 	s = dev->subdevices + arg;
 
-	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	spin_lock_irqsave(&s->spin_lock, flags);
 	if (s->busy || s->lock)
 		ret = -EBUSY;
 	else
 		s->lock = file;
-	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
 
 	if (ret < 0)
 		return ret;
@@ -1984,8 +1984,7 @@ module_exit(comedi_cleanup);
 
 void comedi_error(const struct comedi_device *dev, const char *s)
 {
-	rt_printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name,
-		  s);
+	printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name, s);
 }
 
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -2054,10 +2053,10 @@ void comedi_set_subdevice_runflags(struc
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	spin_lock_irqsave(&s->spin_lock, flags);
 	s->runflags &= ~mask;
 	s->runflags |= (bits & mask);
-	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
 unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
@@ -2065,9 +2064,9 @@ unsigned comedi_get_subdevice_runflags(s
 	unsigned long flags;
 	unsigned runflags;
 
-	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	spin_lock_irqsave(&s->spin_lock, flags);
 	runflags = s->runflags;
-	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
 	return runflags;
 }
 
@@ -2125,14 +2124,14 @@ int comedi_alloc_board_minor(struct devi
 		return -ENOMEM;
 	}
 	comedi_device_init(info->device);
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	if (i == COMEDI_NUM_BOARD_MINORS) {
 		comedi_device_cleanup(info->device);
 		kfree(info->device);
@@ -2184,10 +2183,10 @@ void comedi_free_board_minor(unsigned mi
 	struct comedi_device_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	info = comedi_file_info_table[minor];
 	comedi_file_info_table[minor] = NULL;
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 
 	if (info) {
 		struct comedi_device *dev = info->device;
@@ -2218,14 +2217,14 @@ int comedi_alloc_subdevice_minor(struct 
 	info->device = dev;
 	info->read_subdevice = s;
 	info->write_subdevice = s;
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	for (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {
 		if (comedi_file_info_table[i] == NULL) {
 			comedi_file_info_table[i] = info;
 			break;
 		}
 	}
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
 		printk(KERN_ERR "comedi: error: ran out of minor numbers for board device files.\n");
@@ -2283,10 +2282,10 @@ void comedi_free_subdevice_minor(struct 
 	BUG_ON(s->minor >= COMEDI_NUM_MINORS);
 	BUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);
 
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	info = comedi_file_info_table[s->minor];
 	comedi_file_info_table[s->minor] = NULL;
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 
 	if (s->class_dev) {
 		device_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));
@@ -2301,9 +2300,9 @@ struct comedi_device_file_info *comedi_g
 	struct comedi_device_file_info *info;
 
 	BUG_ON(minor >= COMEDI_NUM_MINORS);
-	comedi_spin_lock_irqsave(&comedi_file_info_table_lock, flags);
+	spin_lock_irqsave(&comedi_file_info_table_lock, flags);
 	info = comedi_file_info_table[minor];
-	comedi_spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
+	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	return info;
 }
 
--- a/drivers/staging/comedi/drivers/addi-data/addi_amcc_s5933.h
+++ b/drivers/staging/comedi/drivers/addi-data/addi_amcc_s5933.h
@@ -343,7 +343,7 @@ int i_find_free_pci_card_by_position(uns
 				*card = amcc;
 				return 0;	/* ok, card is found */
 			} else {
-				rt_printk(" - \nCard on requested position is used b:s %d:%d!\n",
+				printk(" - \nCard on requested position is used b:s %d:%d!\n",
 					  pci_bus, pci_slot);
 				return 2;	/* card exist but is used */
 			}
@@ -447,7 +447,7 @@ struct pcilst_struct *ptr_select_and_all
 		/* use autodetection */
 		card = ptr_find_free_pci_card_by_device(vendor_id, device_id);
 		if (card == NULL) {
-			rt_printk(" - Unused card not found in system!\n");
+			printk(" - Unused card not found in system!\n");
 			return NULL;
 		}
 	} else {
@@ -455,18 +455,18 @@ struct pcilst_struct *ptr_select_and_all
 							 pci_bus, pci_slot,
 							 &card)) {
 		case 1:
-			rt_printk(" - Card not found on requested position b:s %d:%d!\n",
+			printk(" - Card not found on requested position b:s %d:%d!\n",
 				  pci_bus, pci_slot);
 			return NULL;
 		case 2:
-			rt_printk(" - Card on requested position is used b:s %d:%d!\n",
+			printk(" - Card on requested position is used b:s %d:%d!\n",
 				  pci_bus, pci_slot);
 			return NULL;
 		}
 	}
 
 	if (pci_card_alloc(card, i_Master) != 0) {
-		rt_printk(" - Can't allocate card!\n");
+		printk(" - Can't allocate card!\n");
 		return NULL;
 
 	}
--- a/drivers/staging/comedi/drivers/addi-data/addi_common.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_common.c
@@ -2583,7 +2583,7 @@ static int i_ADDI_Attach(struct comedi_d
 		v_pci_card_list_init(this_board->i_VendorId, 1);	/* 1 for displaying the list.. */
 		pci_list_builded = 1;
 	}
-	/* rt_printk("comedi%d: addi_common: board=%s",dev->minor,this_board->pc_DriverName); */
+	/* printk("comedi%d: addi_common: board=%s",dev->minor,this_board->pc_DriverName); */
 
 	if ((this_board->i_Dma) && (it->options[2] == 0)) {
 		i_Dma = 1;
@@ -2648,16 +2648,16 @@ static int i_ADDI_Attach(struct comedi_d
 	/* ## */
 
 	if (irq > 0) {
-		if (comedi_request_irq(irq, v_ADDI_Interrupt, IRQF_SHARED,
+		if (request_irq(irq, v_ADDI_Interrupt, IRQF_SHARED,
 				c_Identifier, dev) < 0) {
 			printk(", unable to allocate IRQ %u, DISABLING IT",
 				irq);
 			irq = 0;	/* Can't use IRQ */
 		} else {
-			rt_printk("\nirq=%u", irq);
+			printk("\nirq=%u", irq);
 		}
 	} else {
-		rt_printk(", IRQ disabled");
+		printk(", IRQ disabled");
 	}
 
 	printk("\nOption %d %d %d\n", it->options[0], it->options[1],
@@ -2719,7 +2719,7 @@ static int i_ADDI_Attach(struct comedi_d
 				}
 			}
 			if (!devpriv->ul_DmaBufferVirtual[0]) {
-				rt_printk
+				printk
 					(", Can't allocate DMA buffer, DMA disabled!");
 				devpriv->us_UseDma = ADDI_DISABLE;
 			}
@@ -2730,7 +2730,7 @@ static int i_ADDI_Attach(struct comedi_d
 		}
 
 		if ((devpriv->us_UseDma == ADDI_ENABLE)) {
-			rt_printk("\nDMA ENABLED\n");
+			printk("\nDMA ENABLED\n");
 		} else {
 			printk("\nDMA DISABLED\n");
 		}
@@ -2937,7 +2937,7 @@ static int i_ADDI_Detach(struct comedi_d
 		}
 
 		if (dev->irq) {
-			comedi_free_irq(dev->irq, dev);
+			free_irq(dev->irq, dev);
 		}
 
 		if ((devpriv->ps_BoardInfo->pc_EepromChip == NULL)
--- a/drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h
+++ b/drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h
@@ -335,7 +335,7 @@ int i_find_free_pci_card_by_position(uns
 				*card = amcc;
 				return 0;	/*  ok, card is found */
 			} else {
-				rt_printk
+				printk
 				    (" - \nCard on requested position is used b:s %d:%d!\n",
 				     pci_bus, pci_slot);
 				return 2;	/*  card exist but is used */
@@ -425,7 +425,7 @@ struct pcilst_struct *ptr_select_and_all
 	if ((pci_bus < 1) & (pci_slot < 1)) {	/*  use autodetection */
 		card = ptr_find_free_pci_card_by_device(vendor_id, device_id);
 		if (card == NULL) {
-			rt_printk(" - Unused card not found in system!\n");
+			printk(" - Unused card not found in system!\n");
 			return NULL;
 		}
 	} else {
@@ -433,12 +433,12 @@ struct pcilst_struct *ptr_select_and_all
 							 pci_bus, pci_slot,
 							 &card)) {
 		case 1:
-			rt_printk
+			printk
 			    (" - Card not found on requested position b:s %d:%d!\n",
 			     pci_bus, pci_slot);
 			return NULL;
 		case 2:
-			rt_printk
+			printk
 			    (" - Card on requested position is used b:s %d:%d!\n",
 			     pci_bus, pci_slot);
 			return NULL;
@@ -446,7 +446,7 @@ struct pcilst_struct *ptr_select_and_all
 	}
 
 	if (i_pci_card_alloc(card) != 0) {
-		rt_printk(" - Can't allocate card!\n");
+		printk(" - Can't allocate card!\n");
 		return NULL;
 	}
 
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
@@ -2637,7 +2637,7 @@ int i_APCI3120_InsnWriteAnalogOutput(str
 	}
 
 /*
- * out put n values at the given channel. rt_printk("\nwaiting for
+ * out put n values at the given channel. printk("\nwaiting for
  * DA_READY BIT");
  */
 	do			/* Waiting of DA_READY BIT */
--- a/drivers/staging/comedi/drivers/adl_pci9111.c
+++ b/drivers/staging/comedi/drivers/adl_pci9111.c
@@ -420,7 +420,7 @@ static void pci9111_timer_set(struct com
 		PCI9111_8254_READ_LOAD_LSB_MSB |
 		PCI9111_8254_MODE_2 | PCI9111_8254_BINARY_COUNTER);
 
-	comedi_udelay(1);
+	udelay(1);
 
 	pci9111_8254_counter_2_set(dev_private->timer_divisor_2);
 	pci9111_8254_counter_1_set(dev_private->timer_divisor_1);
@@ -901,7 +901,7 @@ static irqreturn_t pci9111_interrupt(int
 
 	async = subdevice->async;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 
 	/*  Check if we are source of interrupt */
 	intcsr = inb(dev_private->lcr_io_base +
@@ -919,7 +919,7 @@ static irqreturn_t pci9111_interrupt(int
 						PLX9050_LINTI2_STATUS))))) {
 		/*  Not the source of the interrupt. */
 		/*  (N.B. not using PLX9050_SOFTWARE_INTERRUPT) */
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		return IRQ_NONE;
 	}
 
@@ -928,7 +928,7 @@ static irqreturn_t pci9111_interrupt(int
 		/*  Interrupt comes from fifo_half-full signal */
 
 		if (pci9111_is_fifo_full()) {
-			comedi_spin_unlock_irqrestore(&dev->spinlock,
+			spin_unlock_irqrestore(&dev->spinlock,
 				irq_flags);
 			comedi_error(dev, PCI9111_DRIVER_NAME " fifo overflow");
 			pci9111_interrupt_clear();
@@ -1028,7 +1028,7 @@ static irqreturn_t pci9111_interrupt(int
 
 	pci9111_interrupt_clear();
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	comedi_event(dev, subdevice);
 
@@ -1298,8 +1298,7 @@ static int pci9111_attach(struct comedi_
 
 	dev->irq = 0;
 	if (pci_device->irq > 0) {
-		if (comedi_request_irq(pci_device->irq,
-				pci9111_interrupt,
+		if (request_irq(pci_device->irq, pci9111_interrupt,
 				IRQF_SHARED, PCI9111_DRIVER_NAME, dev) != 0) {
 			printk("comedi%d: unable to allocate irq  %u\n",
 				dev->minor, pci_device->irq);
@@ -1379,7 +1378,7 @@ static int pci9111_detach(struct comedi_
 	/*  Release previously allocated irq */
 
 	if (dev->irq != 0) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 
 	if (dev_private != 0 && dev_private->pci_device != 0) {
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -80,7 +80,7 @@ Configuration options:
 
 #undef DPRINTK
 #ifdef PCI9118_EXTDEBUG
-#define DPRINTK(fmt, args...) rt_printk(fmt, ## args)
+#define DPRINTK(fmt, args...) printk(fmt, ## args)
 #else
 #define DPRINTK(fmt, args...)
 #endif
@@ -345,12 +345,12 @@ static int pci9118_insn_read_ai(struct c
 
 	for (n = 0; n < insn->n; n++) {
 		outw(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
-		comedi_udelay(2);
+		udelay(2);
 		timeout = 100;
 		while (timeout--) {
 			if (inl(dev->iobase + PCI9118_ADSTAT) & AdStatus_ADrdy)
 				goto conv_finish;
-			comedi_udelay(1);
+			udelay(1);
 		}
 
 		comedi_error(dev, "A/D insn timeout");
@@ -569,7 +569,7 @@ static void interrupt_pci9118_ai_onesamp
 #ifdef PCI9118_PARANOIDCHECK
 	if (devpriv->ai16bits == 0) {
 		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	/*  data dropout! */
-			rt_printk
+			printk
 				("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
 				sampl & 0x000f,
 				devpriv->chanlist[s->async->cur_chan]);
@@ -950,11 +950,11 @@ static int pci9118_ai_cmdtest(struct com
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-/* rt_printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->scan_begin_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-/* rt_printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
 			cmd->scan_begin_arg = this_board->ai_ns_min;
 		if (tmp != cmd->scan_begin_arg)
@@ -966,7 +966,7 @@ static int pci9118_ai_cmdtest(struct com
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->convert_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-/* rt_printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -980,7 +980,7 @@ static int pci9118_ai_cmdtest(struct com
 					cmd->scan_begin_arg =
 						this_board->ai_ns_min *
 						(cmd->scan_end_arg + 2);
-/* rt_printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			} else {
@@ -989,7 +989,7 @@ static int pci9118_ai_cmdtest(struct com
 					cmd->scan_begin_arg =
 						cmd->convert_arg *
 						cmd->chanlist_len;
-/* rt_printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			}
@@ -1033,7 +1033,7 @@ static int Compute_and_setup_dma(struct 
 		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
 			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
-			rt_printk
+			printk
 				("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
 				dev->minor, dmalen0,
 				devpriv->ai_n_realscanlen << 1);
@@ -1044,7 +1044,7 @@ static int Compute_and_setup_dma(struct 
 			if (devpriv->useeoshandle)
 				dmalen0 += 2;
 			if (dmalen0 < 4) {
-				rt_printk
+				printk
 					("comedi%d: ERR: DMA0 buf len bug? (%d<4)\n",
 					dev->minor, dmalen0);
 				dmalen0 = 4;
@@ -1055,7 +1055,7 @@ static int Compute_and_setup_dma(struct 
 		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
 			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
-			rt_printk
+			printk
 				("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
 				dev->minor, dmalen1,
 				devpriv->ai_n_realscanlen << 1);
@@ -1066,7 +1066,7 @@ static int Compute_and_setup_dma(struct 
 			if (devpriv->useeoshandle)
 				dmalen1 -= 2;
 			if (dmalen1 < 4) {
-				rt_printk
+				printk
 					("comedi%d: ERR: DMA1 buf len bug? (%d<4)\n",
 					dev->minor, dmalen1);
 				dmalen1 = 4;
@@ -1464,7 +1464,7 @@ static int pci9118_ai_cmd(struct comedi_
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
-	comedi_udelay(1);
+	udelay(1);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 	inl(dev->iobase + PCI9118_ADSTAT);	/*  flush A/D and INT status register */
 	inl(dev->iobase + PCI9118_INTSRC);
@@ -1497,7 +1497,7 @@ static int check_channel_list(struct com
 		return 0;
 	}
 	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
-		rt_printk
+		printk
 			("comedi%d: range/channel list is too long for actual configuration (%d>%d)!",
 			dev->minor, n_chan,
 			s->len_chanlist - frontadd - backadd);
@@ -1641,7 +1641,7 @@ static int setup_channel_list(struct com
 #endif
 #endif
 	outl(0, dev->iobase + PCI9118_SCANMOD);	/*  close scan queue */
-/* comedi_udelay(100);                               important delay, or first sample will be cripled */
+/* udelay(100);                               important delay, or first sample will be cripled */
 
 	DPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");
 	return 1;		/*  we can serve this with scan logic */
@@ -1716,7 +1716,7 @@ static void start_pacer(struct comedi_de
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
 /* outl(0x30, dev->iobase + PCI9118_CNTCTRL); */
-	comedi_udelay(1);
+	udelay(1);
 
 	if ((mode == 1) || (mode == 2) || (mode == 4)) {
 		outl(divisor2 & 0xff, dev->iobase + PCI9118_CNT2);
@@ -1817,7 +1817,7 @@ static int pci9118_reset(struct comedi_d
 	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);	/*  reset A/D outs to 0V */
 	outl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);
 	outl(0, dev->iobase + PCI9118_DO);	/*  reset digi outs to L */
-	comedi_udelay(10);
+	udelay(10);
 	inl(dev->iobase + PCI9118_AD_DATA);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 	outl(0, dev->iobase + PCI9118_INTSRC);	/*  remove INT requests */
@@ -1848,7 +1848,7 @@ static int pci9118_attach(struct comedi_
 	unsigned char pci_bus, pci_slot, pci_func;
 	u16 u16w;
 
-	rt_printk("comedi%d: adl_pci9118: board=%s", dev->minor,
+	printk("comedi%d: adl_pci9118: board=%s", dev->minor,
 		this_board->name);
 
 	opt_bus = it->options[0];
@@ -1861,7 +1861,7 @@ static int pci9118_attach(struct comedi_
 
 	ret = alloc_private(dev, sizeof(struct pci9118_private));
 	if (ret < 0) {
-		rt_printk(" - Allocation failed!\n");
+		printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
 
@@ -1890,10 +1890,10 @@ static int pci9118_attach(struct comedi_
 
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
-			rt_printk(" - Card at b:s %d:%d %s\n",
+			printk(" - Card at b:s %d:%d %s\n",
 				opt_bus, opt_slot, errstr);
 		} else {
-			rt_printk(" - Card %s\n", errstr);
+			printk(" - Card %s\n", errstr);
 		}
 		return -EIO;
 	}
@@ -1909,7 +1909,7 @@ static int pci9118_attach(struct comedi_
 	iobase_a = pci_resource_start(pcidev, 0);
 	iobase_9 = pci_resource_start(pcidev, 2);
 
-	rt_printk(", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus, pci_slot,
+	printk(", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus, pci_slot,
 		pci_func, iobase_9, iobase_a);
 
 	dev->iobase = iobase_9;
@@ -1923,16 +1923,16 @@ static int pci9118_attach(struct comedi_
 	if (it->options[3] & 2)
 		irq = 0;	/*  user don't want use IRQ */
 	if (irq > 0) {
-		if (comedi_request_irq(irq, interrupt_pci9118, IRQF_SHARED,
+		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
 				"ADLink PCI-9118", dev)) {
-			rt_printk(", unable to allocate IRQ %d, DISABLING IT",
+			printk(", unable to allocate IRQ %d, DISABLING IT",
 				irq);
 			irq = 0;	/* Can't use IRQ */
 		} else {
-			rt_printk(", irq=%u", irq);
+			printk(", irq=%u", irq);
 		}
 	} else {
-		rt_printk(", IRQ disabled");
+		printk(", IRQ disabled");
 	}
 
 	dev->irq = irq;
@@ -1958,7 +1958,7 @@ static int pci9118_attach(struct comedi_
 			}
 		}
 		if (!devpriv->dmabuf_virt[0]) {
-			rt_printk(", Can't allocate DMA buffer, DMA disabled!");
+			printk(", Can't allocate DMA buffer, DMA disabled!");
 			master = 0;
 		}
 
@@ -1969,9 +1969,9 @@ static int pci9118_attach(struct comedi_
 
 	devpriv->master = master;
 	if (devpriv->master)
-		rt_printk(", bus master");
+		printk(", bus master");
 	else
-		rt_printk(", no bus master");
+		printk(", no bus master");
 
 	devpriv->usemux = 0;
 	if (it->options[2] > 0) {
@@ -1982,7 +1982,7 @@ static int pci9118_attach(struct comedi_
 			if (devpriv->usemux > 128) {
 				devpriv->usemux = 128;	/*  max 128 channels with softare S&H! */
 			}
-		rt_printk(", ext. mux %d channels", devpriv->usemux);
+		printk(", ext. mux %d channels", devpriv->usemux);
 	}
 
 	devpriv->softsshdelay = it->options[4];
@@ -1995,7 +1995,7 @@ static int pci9118_attach(struct comedi_
 		devpriv->softsshhold = 0x80;
 	}
 
-	rt_printk(".\n");
+	printk(".\n");
 
 	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
 	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	/*  Enable parity check for parity error */
@@ -2081,7 +2081,7 @@ static int pci9118_detach(struct comedi_
 		if (devpriv->valid)
 			pci9118_reset(dev);
 		if (dev->irq)
-			comedi_free_irq(dev->irq, dev);
+			free_irq(dev->irq, dev);
 		if (devpriv->pcidev) {
 			if (dev->iobase) {
 				comedi_pci_disable(devpriv->pcidev);
--- a/drivers/staging/comedi/drivers/adq12b.c
+++ b/drivers/staging/comedi/drivers/adq12b.c
@@ -325,7 +325,7 @@ static int adq12b_ai_rinsn(struct comedi
         channel = CR_CHAN(insn->chanspec);
         if (channel != devpriv->last_channel || range != devpriv->last_range) {
           outb((range << 4) | channel, dev->iobase + ADQ12B_CTREG);
-          comedi_udelay(50);   /* wait for the mux to settle */
+          udelay(50);   /* wait for the mux to settle */
         }
 
         /* trigger conversion */
@@ -337,7 +337,7 @@ static int adq12b_ai_rinsn(struct comedi
           /* wait for end of convertion */
 	  i = 0;
           do {
-/* comedi_udelay(1); */
+/* udelay(1); */
 	    status = inb(dev->iobase + ADQ12B_STINR);
             status = status & ADQ12B_EOC;
           } while (status == 0 && ++i < TIMEOUT);
@@ -347,7 +347,7 @@ static int adq12b_ai_rinsn(struct comedi
           hi = inb(dev->iobase + ADQ12B_ADHIG);
           lo = inb(dev->iobase + ADQ12B_ADLOW);
 
-          /* rt_printk("debug: chan=%d range=%d status=%d hi=%d lo=%d\n", channel, range, status,  hi, lo); */
+          /* printk("debug: chan=%d range=%d status=%d hi=%d lo=%d\n", channel, range, status,  hi, lo); */
           data[n] = (hi << 8) | lo;
 
         }
--- a/drivers/staging/comedi/drivers/adv_pci1710.c
+++ b/drivers/staging/comedi/drivers/adv_pci1710.c
@@ -58,7 +58,7 @@ Configuration options:
 
 #undef DPRINTK
 #ifdef PCI171X_EXTDEBUG
-#define DPRINTK(fmt, args...) rt_printk(fmt, ## args)
+#define DPRINTK(fmt, args...) printk(fmt, ## args)
 #else
 #define DPRINTK(fmt, args...)
 #endif
@@ -348,7 +348,7 @@ static int pci171x_insn_read_ai(struct c
 		outw(0, dev->iobase + PCI171x_SOFTTRG);	/* start conversion */
 		DPRINTK("adv_pci1710 B n=%d ST=%4x\n", n,
 			inw(dev->iobase + PCI171x_STATUS));
-		/* comedi_udelay(1); */
+		/* udelay(1); */
 		DPRINTK("adv_pci1710 C n=%d ST=%4x\n", n,
 			inw(dev->iobase + PCI171x_STATUS));
 		timeout = 100;
@@ -588,14 +588,14 @@ static void interrupt_pci1710_every_samp
 	DPRINTK("adv_pci1710 EDBG: BGN: interrupt_pci1710_every_sample(...)\n");
 	m = inw(dev->iobase + PCI171x_STATUS);
 	if (m & Status_FE) {
-		rt_printk("comedi%d: A/D FIFO empty (%4x)\n", dev->minor, m);
+		printk("comedi%d: A/D FIFO empty (%4x)\n", dev->minor, m);
 		pci171x_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
 		return;
 	}
 	if (m & Status_FF) {
-		rt_printk
+		printk
 			("comedi%d: A/D FIFO Full status (Fatal Error!) (%4x)\n",
 			dev->minor, m);
 		pci171x_ai_cancel(dev, s);
@@ -614,7 +614,7 @@ static void interrupt_pci1710_every_samp
 		if (this_board->cardtype != TYPE_PCI1713)
 			if ((sampl & 0xf000) !=
 				devpriv->act_chanlist[s->async->cur_chan]) {
-				rt_printk
+				printk
 					("comedi: A/D data dropout: received data from channel %d, expected %d!\n",
 					(sampl & 0xf000) >> 12,
 					(devpriv->act_chanlist[s->async->
@@ -676,7 +676,7 @@ static int move_block_from_fifo(struct c
 		sampl = inw(dev->iobase + PCI171x_AD_DATA);
 		if (this_board->cardtype != TYPE_PCI1713)
 			if ((sampl & 0xf000) != devpriv->act_chanlist[j]) {
-				rt_printk
+				printk
 					("comedi%d: A/D  FIFO data dropout: received data from channel %d, expected %d! (%d/%d/%d/%d/%d/%4x)\n",
 					dev->minor, (sampl & 0xf000) >> 12,
 					(devpriv->
@@ -716,7 +716,7 @@ static void interrupt_pci1710_half_fifo(
 	DPRINTK("adv_pci1710 EDBG: BGN: interrupt_pci1710_half_fifo(...)\n");
 	m = inw(dev->iobase + PCI171x_STATUS);
 	if (!(m & Status_FH)) {
-		rt_printk("comedi%d: A/D FIFO not half full! (%4x)\n",
+		printk("comedi%d: A/D FIFO not half full! (%4x)\n",
 			dev->minor, m);
 		pci171x_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
@@ -724,7 +724,7 @@ static void interrupt_pci1710_half_fifo(
 		return;
 	}
 	if (m & Status_FF) {
-		rt_printk
+		printk
 			("comedi%d: A/D FIFO Full status (Fatal Error!) (%4x)\n",
 			dev->minor, m);
 		pci171x_ai_cancel(dev, s);
@@ -888,13 +888,13 @@ static int pci171x_ai_docmd_and_mode(int
 */
 static void pci171x_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
-	rt_printk("adv_pci1710 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
+	printk("adv_pci1710 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
 		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
-	rt_printk("adv_pci1710 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
+	printk("adv_pci1710 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
 		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
-	rt_printk("adv_pci1710 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
+	printk("adv_pci1710 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
 		cmd->scan_end_src);
-	rt_printk("adv_pci1710 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n",
+	printk("adv_pci1710 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n",
 		e, cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 #endif
@@ -1122,7 +1122,7 @@ static int check_channel_list(struct com
 	if (n_chan > 1) {
 		chansegment[0] = chanlist[0];	/*  first channel is everytime ok */
 		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {	/*  build part of chanlist */
-			/*  rt_printk("%d. %d %d\n",i,CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i])); */
+			/*  printk("%d. %d %d\n",i,CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i])); */
 			if (chanlist[0] == chanlist[i])
 				break;	/*  we detect loop, this must by finish */
 			if (CR_CHAN(chanlist[i]) & 1)	/*  odd channel cann't by differencial */
@@ -1136,7 +1136,7 @@ static int check_channel_list(struct com
 			if (CR_AREF(chansegment[i - 1]) == AREF_DIFF)
 				nowmustbechan = (nowmustbechan + 1) % s->n_chan;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
-				rt_printk
+				printk
 					("channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					i, CR_CHAN(chanlist[i]), nowmustbechan,
 					CR_CHAN(chanlist[0]));
@@ -1146,9 +1146,9 @@ static int check_channel_list(struct com
 		}
 
 		for (i = 0, segpos = 0; i < n_chan; i++) {	/*  check whole chanlist */
-			/* rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i])); */
+			/* printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
-				rt_printk
+				printk
 					("bad channel, reference or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
 					i, CR_CHAN(chansegment[i]),
 					CR_RANGE(chansegment[i]),
@@ -1331,14 +1331,14 @@ static int pci1710_attach(struct comedi_
 	int i;
 	int board_index;
 
-	rt_printk("comedi%d: adv_pci1710: ", dev->minor);
+	printk("comedi%d: adv_pci1710: ", dev->minor);
 
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
 
 	ret = alloc_private(dev, sizeof(struct pci1710_private));
 	if (ret < 0) {
-		rt_printk(" - Allocation failed!\n");
+		printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
 
@@ -1386,10 +1386,10 @@ static int pci1710_attach(struct comedi_
 
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
-			rt_printk(" - Card at b:s %d:%d %s\n",
+			printk(" - Card at b:s %d:%d %s\n",
 				opt_bus, opt_slot, errstr);
 		} else {
-			rt_printk(" - Card %s\n", errstr);
+			printk(" - Card %s\n", errstr);
 		}
 		return -EIO;
 	}
@@ -1400,7 +1400,7 @@ static int pci1710_attach(struct comedi_
 	irq = pcidev->irq;
 	iobase = pci_resource_start(pcidev, 2);
 
-	rt_printk(", b:s:f=%d:%d:%d, io=0x%4lx", pci_bus, pci_slot, pci_func,
+	printk(", b:s:f=%d:%d:%d, io=0x%4lx", pci_bus, pci_slot, pci_func,
 		iobase);
 
 	dev->iobase = iobase;
@@ -1422,7 +1422,7 @@ static int pci1710_attach(struct comedi_
 
 	ret = alloc_subdevices(dev, n_subdevices);
 	if (ret < 0) {
-		rt_printk(" - Allocation failed!\n");
+		printk(" - Allocation failed!\n");
 		return ret;
 	}
 
@@ -1430,18 +1430,18 @@ static int pci1710_attach(struct comedi_
 
 	if (this_board->have_irq) {
 		if (irq) {
-			if (comedi_request_irq(irq, interrupt_service_pci1710,
+			if (request_irq(irq, interrupt_service_pci1710,
 					IRQF_SHARED, "Advantech PCI-1710",
 					dev)) {
-				rt_printk
+				printk
 					(", unable to allocate IRQ %d, DISABLING IT",
 					irq);
 				irq = 0;	/* Can't use IRQ */
 			} else {
-				rt_printk(", irq=%u", irq);
+				printk(", irq=%u", irq);
 			}
 		} else {
-			rt_printk(", IRQ disabled");
+			printk(", IRQ disabled");
 		}
 	} else {
 		irq = 0;
@@ -1551,7 +1551,7 @@ static int pci1710_detach(struct comedi_
 		if (devpriv->valid)
 			pci1710_reset(dev);
 		if (dev->irq)
-			comedi_free_irq(dev->irq, dev);
+			free_irq(dev->irq, dev);
 		if (devpriv->pcidev) {
 			if (dev->iobase) {
 				comedi_pci_disable(devpriv->pcidev);
--- a/drivers/staging/comedi/drivers/adv_pci1723.c
+++ b/drivers/staging/comedi/drivers/adv_pci1723.c
@@ -304,7 +304,7 @@ static int pci1723_attach(struct comedi_
 	int opt_bus, opt_slot;
 	const char *errstr;
 
-	rt_printk("comedi%d: adv_pci1723: board=%s", dev->minor,
+	printk("comedi%d: adv_pci1723: board=%s", dev->minor,
 		this_board->name);
 
 	opt_bus = it->options[0];
@@ -312,7 +312,7 @@ static int pci1723_attach(struct comedi_
 
 	ret = alloc_private(dev, sizeof(struct pci1723_private));
 	if (ret < 0) {
-		rt_printk(" - Allocation failed!\n");
+		printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
 
@@ -342,10 +342,10 @@ static int pci1723_attach(struct comedi_
 
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
-			rt_printk(" - Card at b:s %d:%d %s\n",
+			printk(" - Card at b:s %d:%d %s\n",
 				opt_bus, opt_slot, errstr);
 		} else {
-			rt_printk(" - Card %s\n", errstr);
+			printk(" - Card %s\n", errstr);
 		}
 		return -EIO;
 	}
@@ -355,7 +355,7 @@ static int pci1723_attach(struct comedi_
 	pci_func = PCI_FUNC(pcidev->devfn);
 	iobase = pci_resource_start(pcidev, 2);
 
-	rt_printk(", b:s:f=%d:%d:%d, io=0x%4x", pci_bus, pci_slot, pci_func,
+	printk(", b:s:f=%d:%d:%d, io=0x%4x", pci_bus, pci_slot, pci_func,
 		iobase);
 
 	dev->iobase = iobase;
@@ -372,7 +372,7 @@ static int pci1723_attach(struct comedi_
 
 	ret = alloc_subdevices(dev, n_subdevices);
 	if (ret < 0) {
-		rt_printk(" - Allocation failed!\n");
+		printk(" - Allocation failed!\n");
 		return ret;
 	}
 
--- a/drivers/staging/comedi/drivers/adv_pci_dio.c
+++ b/drivers/staging/comedi/drivers/adv_pci_dio.c
@@ -40,7 +40,7 @@ Configuration options:
 
 #undef DPRINTK
 #ifdef PCI_DIO_EXTDEBUG
-#define DPRINTK(fmt, args...) rt_printk(fmt, ## args)
+#define DPRINTK(fmt, args...) printk(fmt, ## args)
 #else
 #define DPRINTK(fmt, args...)
 #endif
@@ -451,7 +451,7 @@ static int pci1760_unchecked_mbxrequest(
 				ok = 1;
 				break;
 			}
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (ok)
 			return 0;
@@ -896,11 +896,11 @@ static int pci_dio_attach(struct comedi_
 	unsigned long iobase;
 	struct pci_dev *pcidev;
 
-	rt_printk("comedi%d: adv_pci_dio: ", dev->minor);
+	printk("comedi%d: adv_pci_dio: ", dev->minor);
 
 	ret = alloc_private(dev, sizeof(struct pci_dio_private));
 	if (ret < 0) {
-		rt_printk(", Error: Cann't allocate private memory!\n");
+		printk(", Error: Cann't allocate private memory!\n");
 		return -ENOMEM;
 	}
 
@@ -932,18 +932,18 @@ static int pci_dio_attach(struct comedi_
 	}
 
 	if (!dev->board_ptr) {
-		rt_printk
+		printk
 			(", Error: Requested type of the card was not found!\n");
 		return -EIO;
 	}
 
 	if (comedi_pci_enable(pcidev, driver_pci_dio.driver_name)) {
-		rt_printk
+		printk
 			(", Error: Can't enable PCI device and request regions!\n");
 		return -EIO;
 	}
 	iobase = pci_resource_start(pcidev, this_board->main_pci_region);
-	rt_printk(", b:s:f=%d:%d:%d, io=0x%4lx",
+	printk(", b:s:f=%d:%d:%d, io=0x%4lx",
 		pcidev->bus->number, PCI_SLOT(pcidev->devfn),
 		PCI_FUNC(pcidev->devfn), iobase);
 
@@ -968,11 +968,11 @@ static int pci_dio_attach(struct comedi_
 
 	ret = alloc_subdevices(dev, n_subdevices);
 	if (ret < 0) {
-		rt_printk(", Error: Cann't allocate subdevice memory!\n");
+		printk(", Error: Cann't allocate subdevice memory!\n");
 		return ret;
 	}
 
-	rt_printk(".\n");
+	printk(".\n");
 
 	subdev = 0;
 
--- a/drivers/staging/comedi/drivers/aio_aio12_8.c
+++ b/drivers/staging/comedi/drivers/aio_aio12_8.c
@@ -110,7 +110,7 @@ static int aio_aio12_8_ai_read(struct co
 			!(inb(dev->iobase + AIO12_8_STATUS) & STATUS_ADC_EOC)) {
 			timeout--;
 			printk("timeout %d\n", timeout);
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (timeout == 0) {
 			comedi_error(dev, "ADC timeout");
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -655,12 +655,12 @@ dio200_inttrig_start_intr(struct comedi_
 
 	subpriv = s->private;
 
-	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	s->async->inttrig = 0;
 	if (subpriv->active) {
 		event = dio200_start_intr(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
@@ -684,7 +684,7 @@ static int dio200_handle_read_intr(struc
 
 	triggered = 0;
 
-	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	oldevents = s->async->events;
 	if (subpriv->has_int_sce) {
 		/*
@@ -773,7 +773,7 @@ static int dio200_handle_read_intr(struc
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	if (oldevents != s->async->events) {
 		comedi_event(dev, s);
@@ -790,11 +790,11 @@ static int dio200_subdev_intr_cancel(str
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	if (subpriv->active) {
 		dio200_stop_intr(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 0;
 }
@@ -916,7 +916,7 @@ static int dio200_subdev_intr_cmd(struct
 	unsigned long flags;
 	int event = 0;
 
-	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	subpriv->active = 1;
 
 	/* Set up end of acquisition. */
@@ -942,7 +942,7 @@ static int dio200_subdev_intr_cmd(struct
 		event = dio200_start_intr(dev, s);
 		break;
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
@@ -1398,7 +1398,7 @@ static int dio200_attach(struct comedi_d
 	if (irq) {
 		unsigned long flags = share_irq ? IRQF_SHARED : 0;
 
-		if (comedi_request_irq(irq, dio200_interrupt, flags,
+		if (request_irq(irq, dio200_interrupt, flags,
 				DIO200_DRIVER_NAME, dev) >= 0) {
 			dev->irq = irq;
 		} else {
@@ -1444,7 +1444,7 @@ static int dio200_detach(struct comedi_d
 		DIO200_DRIVER_NAME);
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->subdevices) {
 		layout = thislayout;
--- a/drivers/staging/comedi/drivers/amplc_pc236.c
+++ b/drivers/staging/comedi/drivers/amplc_pc236.c
@@ -372,7 +372,7 @@ static int pc236_attach(struct comedi_de
 	if (irq) {
 		unsigned long flags = share_irq ? IRQF_SHARED : 0;
 
-		if (comedi_request_irq(irq, pc236_interrupt, flags,
+		if (request_irq(irq, pc236_interrupt, flags,
 				PC236_DRIVER_NAME, dev) >= 0) {
 			dev->irq = irq;
 			s->type = COMEDI_SUBD_DI;
@@ -421,7 +421,7 @@ static int pc236_detach(struct comedi_de
 		pc236_intr_disable(dev);
 	}
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->subdevices) {
 		subdev_8255_cleanup(dev, dev->subdevices + 0);
 	}
@@ -471,13 +471,13 @@ static void pc236_intr_disable(struct co
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->enable_irq = 0;
 #ifdef CONFIG_COMEDI_PCI
 	if (devpriv->lcr_iobase)
 		outl(PCI236_INTR_DISABLE, devpriv->lcr_iobase + PLX9052_INTCSR);
 #endif
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 /*
@@ -489,13 +489,13 @@ static void pc236_intr_enable(struct com
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->enable_irq = 1;
 #ifdef CONFIG_COMEDI_PCI
 	if (devpriv->lcr_iobase)
 		outl(PCI236_INTR_ENABLE, devpriv->lcr_iobase + PLX9052_INTCSR);
 #endif
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 /*
@@ -510,7 +510,7 @@ static int pc236_intr_check(struct comed
 	int retval = 0;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	if (devpriv->enable_irq) {
 		retval = 1;
 #ifdef CONFIG_COMEDI_PCI
@@ -527,7 +527,7 @@ static int pc236_intr_check(struct comed
 		}
 #endif
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return retval;
 }
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -542,7 +542,7 @@ static void pci224_ao_stop(struct comedi
 		return;
 	}
 
-	comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	/* Kill the interrupts. */
 	devpriv->intsce = 0;
 	outb(0, devpriv->iobase1 + PCI224_INT_SCE);
@@ -558,10 +558,10 @@ static void pci224_ao_stop(struct comedi
 	 * routine.
 	 */
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+	spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 	/* Reconfigure DAC for insn_write usage. */
 	outw(0, dev->iobase + PCI224_DACCEN);	/* Disable channels. */
 	devpriv->daccon = COMBINE(devpriv->daccon,
@@ -587,14 +587,14 @@ static void pci224_ao_start(struct comed
 		comedi_event(dev, s);
 	} else {
 		/* Enable interrupts. */
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		if (cmd->stop_src == TRIG_EXT) {
 			devpriv->intsce = PCI224_INTR_EXT | PCI224_INTR_DAC;
 		} else {
 			devpriv->intsce = PCI224_INTR_DAC;
 		}
 		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 	}
 }
 
@@ -655,7 +655,7 @@ static void pci224_ao_handle_fifo(struct
 			/* Nothing left to put in the FIFO. */
 			pci224_ao_stop(dev, s);
 			s->async->events |= COMEDI_CB_OVERFLOW;
-			rt_printk(KERN_ERR "comedi%d: "
+			printk(KERN_ERR "comedi%d: "
 				"AO buffer underrun\n", dev->minor);
 		}
 	}
@@ -1155,16 +1155,16 @@ static int pci224_ao_cmd(struct comedi_d
 	 */
 	switch (cmd->start_src) {
 	case TRIG_INT:
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		s->async->inttrig = &pci224_ao_inttrig_start;
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 		break;
 	case TRIG_EXT:
 		/* Enable external interrupt trigger to start acquisition. */
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		devpriv->intsce |= PCI224_INTR_EXT;
 		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 		break;
 	}
 
@@ -1227,14 +1227,14 @@ static irqreturn_t pci224_interrupt(int 
 	intstat = inb(devpriv->iobase1 + PCI224_INT_SCE) & 0x3F;
 	if (intstat) {
 		retval = 1;
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		valid_intstat = devpriv->intsce & intstat;
 		/* Temporarily disable interrupt sources. */
 		curenab = devpriv->intsce & ~intstat;
 		outb(curenab, devpriv->iobase1 + PCI224_INT_SCE);
 		devpriv->intr_running = 1;
 		devpriv->intr_cpuid = THISCPU;
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 		if (valid_intstat != 0) {
 			cmd = &s->async->cmd;
 			if (valid_intstat & PCI224_INTR_EXT) {
@@ -1250,13 +1250,13 @@ static irqreturn_t pci224_interrupt(int 
 			}
 		}
 		/* Reenable interrupt sources. */
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		if (curenab != devpriv->intsce) {
 			outb(devpriv->intsce,
 				devpriv->iobase1 + PCI224_INT_SCE);
 		}
 		devpriv->intr_running = 0;
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 	}
 	return IRQ_RETVAL(retval);
 }
@@ -1478,8 +1478,8 @@ static int pci224_attach(struct comedi_d
 	dev->board_name = thisboard->name;
 
 	if (irq) {
-		ret = comedi_request_irq(irq, pci224_interrupt, IRQF_SHARED,
-			DRIVER_NAME, dev);
+		ret = request_irq(irq, pci224_interrupt, IRQF_SHARED,
+				  DRIVER_NAME, dev);
 		if (ret < 0) {
 			printk(KERN_ERR "comedi%d: error! "
 				"unable to allocate irq %u\n", dev->minor, irq);
@@ -1515,7 +1515,7 @@ static int pci224_detach(struct comedi_d
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->subdevices) {
 		struct comedi_subdevice *s;
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -876,8 +876,8 @@ static int pci230_attach(struct comedi_d
 		dev->iobase + PCI230_ADCCON);
 
 	/* Register the interrupt handler. */
-	irq_hdl = comedi_request_irq(devpriv->pci_dev->irq, pci230_interrupt,
-		IRQF_SHARED, "amplc_pci230", dev);
+	irq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,
+			      IRQF_SHARED, "amplc_pci230", dev);
 	if (irq_hdl < 0) {
 		printk("comedi%d: unable to register irq, "
 			"commands will not be available %d\n", dev->minor,
@@ -970,7 +970,7 @@ static int pci230_detach(struct comedi_d
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (devpriv) {
 		if (devpriv->pci_dev) {
@@ -995,7 +995,7 @@ static int get_resources(struct comedi_d
 
 	ok = 1;
 	claimed = 0;
-	comedi_spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
 		&& (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
@@ -1016,7 +1016,7 @@ static int get_resources(struct comedi_d
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 	return ok;
 }
 
@@ -1033,7 +1033,7 @@ static void put_resources(struct comedi_
 	unsigned int b;
 	unsigned long irqflags;
 
-	comedi_spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
 		&& (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
@@ -1043,7 +1043,7 @@ static void put_resources(struct comedi_
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
 static inline void put_one_resource(struct comedi_device *dev, unsigned int resource,
@@ -1145,12 +1145,12 @@ static int pci230_ai_rinsn(struct comedi
 			status = inw(dev->iobase + PCI230_ADCCON);
 			if (!(status & PCI230_ADC_FIFO_EMPTY))
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (i == TIMEOUT) {
-			/* rt_printk() should be used instead of printk()
+			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
-			rt_printk("timeout\n");
+			printk("timeout\n");
 			return -ETIMEDOUT;
 		}
 
@@ -1426,12 +1426,12 @@ static int pci230_ao_inttrig_scan_begin(
 	if (trig_num != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
 	if (test_bit(AO_CMD_STARTED, &devpriv->state)) {
 		/* Perform scan. */
 		if (devpriv->hwver < 2) {
 			/* Not using DAC FIFO. */
-			comedi_spin_unlock_irqrestore(&devpriv->
+			spin_unlock_irqrestore(&devpriv->
 				ao_stop_spinlock, irqflags);
 			pci230_handle_ao_nofifo(dev, s);
 			comedi_event(dev, s);
@@ -1439,12 +1439,12 @@ static int pci230_ao_inttrig_scan_begin(
 			/* Using DAC FIFO. */
 			/* Read DACSWTRIG register to trigger conversion. */
 			inw(dev->iobase + PCI230P2_DACSWTRIG);
-			comedi_spin_unlock_irqrestore(&devpriv->
+			spin_unlock_irqrestore(&devpriv->
 				ao_stop_spinlock, irqflags);
 		}
 		/* Delay.  Should driver be responsible for this? */
 		/* XXX TODO: See if DAC busy bit can be used. */
-		comedi_udelay(8);
+		udelay(8);
 	}
 
 	return 1;
@@ -1508,13 +1508,13 @@ static void pci230_ao_start(struct comed
 			if (devpriv->hwver < 2) {
 				/* Not using DAC FIFO. */
 				/* Enable CT1 timer interrupt. */
-				comedi_spin_lock_irqsave(&devpriv->isr_spinlock,
+				spin_lock_irqsave(&devpriv->isr_spinlock,
 					irqflags);
 				devpriv->int_en |= PCI230_INT_ZCLK_CT1;
 				devpriv->ier |= PCI230_INT_ZCLK_CT1;
 				outb(devpriv->ier,
 					devpriv->iobase1 + PCI230_INT_SCE);
-				comedi_spin_unlock_irqrestore(&devpriv->
+				spin_unlock_irqrestore(&devpriv->
 					isr_spinlock, irqflags);
 			}
 			/* Set CT1 gate high to start counting. */
@@ -1527,12 +1527,12 @@ static void pci230_ao_start(struct comed
 		}
 		if (devpriv->hwver >= 2) {
 			/* Using DAC FIFO.  Enable DAC FIFO interrupt. */
-			comedi_spin_lock_irqsave(&devpriv->isr_spinlock,
+			spin_lock_irqsave(&devpriv->isr_spinlock,
 				irqflags);
 			devpriv->int_en |= PCI230P2_INT_DAC;
 			devpriv->ier |= PCI230P2_INT_DAC;
 			outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
-			comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock,
+			spin_unlock_irqrestore(&devpriv->isr_spinlock,
 				irqflags);
 		}
 	}
@@ -2088,7 +2088,7 @@ static int pci230_ai_inttrig_convert(str
 	if (trig_num != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
 	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
 		unsigned int delayus;
 
@@ -2112,11 +2112,11 @@ static int pci230_ai_inttrig_convert(str
 			/* single-ended or PCI230+/260+ */
 			delayus = 4;
 		}
-		comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
+		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
 			irqflags);
-		comedi_udelay(delayus);
+		udelay(delayus);
 	} else {
-		comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
+		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
 			irqflags);
 	}
 
@@ -2132,7 +2132,7 @@ static int pci230_ai_inttrig_scan_begin(
 	if (trig_num != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
 	if (test_bit(AI_CMD_STARTED, &devpriv->state)) {
 		/* Trigger scan by waggling CT0 gate source. */
 		zgat = GAT_CONFIG(0, GAT_GND);
@@ -2140,7 +2140,7 @@ static int pci230_ai_inttrig_scan_begin(
 		zgat = GAT_CONFIG(0, GAT_VCC);
 		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 
 	return 1;
 }
@@ -2160,11 +2160,11 @@ static void pci230_ai_start(struct comed
 		comedi_event(dev, s);
 	} else {
 		/* Enable ADC FIFO trigger level interrupt. */
-		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 		devpriv->int_en |= PCI230_INT_ADC;
 		devpriv->ier |= PCI230_INT_ADC;
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
-		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 		/* Update conversion trigger source which is currently set
 		 * to CT2 output, which is currently stuck high. */
@@ -2426,7 +2426,7 @@ static int pci230_ai_cmd(struct comedi_d
 	 * FIFO reset (above) and the second FIFO reset (below). Setting the
 	 * channel gains and scan list _before_ the first FIFO reset also
 	 * helps, though only slightly. */
-	comedi_udelay(25);
+	udelay(25);
 
 	/* Reset FIFO again. */
 	outw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);
@@ -2575,7 +2575,7 @@ static irqreturn_t pci230_interrupt(int 
 		return IRQ_NONE;
 	}
 
-	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	valid_status_int = devpriv->int_en & status_int;
 	/* Disable triggered interrupts.
 	 * (Only those interrupts that need re-enabling, are, later in the
@@ -2584,7 +2584,7 @@ static irqreturn_t pci230_interrupt(int 
 	outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	devpriv->intr_running = 1;
 	devpriv->intr_cpuid = THISCPU;
-	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	/*
 	 * Check the source of interrupt and handle it.
@@ -2613,13 +2613,13 @@ static irqreturn_t pci230_interrupt(int 
 	}
 
 	/* Reenable interrupts. */
-	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	}
 	devpriv->intr_running = 0;
-	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	return IRQ_HANDLED;
 }
@@ -2870,9 +2870,9 @@ static void pci230_ao_stop(struct comedi
 	int started;
 	struct comedi_cmd *cmd;
 
-	comedi_spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);
 	started = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);
-	comedi_spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);
 	if (!started) {
 		return;
 	}
@@ -2893,17 +2893,17 @@ static void pci230_ao_stop(struct comedi
 	}
 	/* Disable interrupt and wait for interrupt routine to finish running
 	 * unless we are called from the interrupt routine. */
-	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	devpriv->int_en &= ~intsrc;
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
-		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	}
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	if (devpriv->hwver >= 2) {
 		/* Using DAC FIFO.  Reset FIFO, clear underrun error,
@@ -2930,9 +2930,9 @@ static void pci230_ai_stop(struct comedi
 	struct comedi_cmd *cmd;
 	int started;
 
-	comedi_spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);
 	started = test_and_clear_bit(AI_CMD_STARTED, &devpriv->state);
-	comedi_spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 	if (!started) {
 		return;
 	}
@@ -2947,19 +2947,19 @@ static void pci230_ai_stop(struct comedi
 		pci230_cancel_ct(dev, 0);
 	}
 
-	comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+	spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	/* Disable ADC interrupt and wait for interrupt routine to finish
 	 * running unless we are called from the interrupt routine. */
 	devpriv->int_en &= ~PCI230_INT_ADC;
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
-		comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
-		comedi_spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 	}
 	if (devpriv->ier != devpriv->int_en) {
 		devpriv->ier = devpriv->int_en;
 		outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
+	spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 
 	/* Reset FIFO, disable FIFO and set start conversion source to none.
 	 * Keep se/diff and bip/uni settings */
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -554,7 +554,7 @@ unsigned int comedi_buf_munge(struct com
 
 		block_size = num_bytes - count;
 		if (block_size < 0) {
-			rt_printk("%s: %s: bug! block_size is negative\n",
+			printk("%s: %s: bug! block_size is negative\n",
 				__FILE__, __func__);
 			break;
 		}
@@ -633,8 +633,7 @@ unsigned comedi_buf_write_free(struct co
 {
 	if ((int)(async->buf_write_count + nbytes -
 			async->buf_write_alloc_count) > 0) {
-		rt_printk
-			("comedi: attempted to write-free more bytes than have been write-allocated.\n");
+		printk("comedi: attempted to write-free more bytes than have been write-allocated.\n");
 		nbytes = async->buf_write_alloc_count - async->buf_write_count;
 	}
 	async->buf_write_count += nbytes;
@@ -667,8 +666,7 @@ unsigned comedi_buf_read_free(struct com
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
 			async->buf_read_alloc_count) > 0) {
-		rt_printk
-			("comedi: attempted to read-free more bytes than have been read-allocated.\n");
+		printk("comedi: attempted to read-free more bytes than have been read-allocated.\n");
 		nbytes = async->buf_read_alloc_count - async->buf_read_count;
 	}
 	async->buf_read_count += nbytes;
--- a/drivers/staging/comedi/drivers/cb_das16_cs.c
+++ b/drivers/staging/comedi/drivers/cb_das16_cs.c
@@ -187,8 +187,8 @@ static int das16cs_attach(struct comedi_
 	}
 	printk("\n");
 
-	ret = comedi_request_irq(link->irq.AssignedIRQ, das16cs_interrupt,
-		IRQF_SHARED, "cb_das16_cs", dev);
+	ret = request_irq(link->irq.AssignedIRQ, das16cs_interrupt,
+			  IRQF_SHARED, "cb_das16_cs", dev);
 	if (ret < 0) {
 		return ret;
 	}
@@ -270,7 +270,7 @@ static int das16cs_detach(struct comedi_
 	printk("comedi%d: das16cs: remove\n", dev->minor);
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 
 	return 0;
@@ -503,7 +503,7 @@ static int das16cs_ao_winsn(struct comed
 		d = data[i];
 
 		outw(devpriv->status1, dev->iobase + 4);
-		comedi_udelay(1);
+		udelay(1);
 
 		status1 = devpriv->status1 & ~0xf;
 		if (chan)
@@ -513,17 +513,17 @@ static int das16cs_ao_winsn(struct comed
 
 /* 		printk("0x%04x\n",status1);*/
 		outw(status1, dev->iobase + 4);
-		comedi_udelay(1);
+		udelay(1);
 
 		for (bit = 15; bit >= 0; bit--) {
 			int b = (d >> bit) & 0x1;
 			b <<= 1;
 /*			printk("0x%04x\n",status1 | b | 0x0000);*/
 			outw(status1 | b | 0x0000, dev->iobase + 4);
-			comedi_udelay(1);
+			udelay(1);
 /*			printk("0x%04x\n",status1 | b | 0x0004);*/
 			outw(status1 | b | 0x0004, dev->iobase + 4);
-			comedi_udelay(1);
+			udelay(1);
 		}
 /*		make high both DAC0CS and DAC1CS to load
 		new data and update analog output*/
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -98,7 +98,7 @@ TODO:
 /* #define PCIDAS64_DEBUG         enable debugging code */
 
 #ifdef PCIDAS64_DEBUG
-#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args)
+#define DEBUG_PRINT(format, args...)  printk(format , ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif
@@ -1535,7 +1535,7 @@ static void init_stc_registers(struct co
 	uint16_t bits;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/*  bit should be set for 6025, although docs say boards with <= 16 chans should be cleared XXX */
 	if (1)
@@ -1556,7 +1556,7 @@ static void init_stc_registers(struct co
 	writew(0, priv(dev)->main_iobase + DAQ_SYNC_REG);
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set fifos to maximum size */
 	priv(dev)->fifo_size_bits |= DAC_FIFO_BITS;
@@ -1794,7 +1794,7 @@ static int attach(struct comedi_device *
 	init_plx9080(dev);
 	init_stc_registers(dev);
 	/*  get irq */
-	if (comedi_request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			"cb_pcidas64", dev)) {
 		printk(" unable to allocate irq %u\n", pcidev->irq);
 		return -EINVAL;
@@ -1825,7 +1825,7 @@ static int detach(struct comedi_device *
 	printk("comedi%d: cb_pcidas: remove\n", dev->minor);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (priv(dev)) {
 		if (priv(dev)->hw_dev) {
 			if (priv(dev)->plx9080_iobase) {
@@ -1895,14 +1895,14 @@ static int ai_rinsn(struct comedi_device
 	/*  4020 generates dac done interrupts even though they are disabled */
 	disable_ai_pacing(dev);
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	if (insn->chanspec & CR_ALT_FILTER)
 		priv(dev)->adc_control1_bits |= ADC_DITHER_BIT;
 	else
 		priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
 	writew(priv(dev)->adc_control1_bits,
 		priv(dev)->main_iobase + ADC_CONTROL1_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (board(dev)->layout != LAYOUT_4020) {
 		/*  use internal queue */
@@ -1995,12 +1995,12 @@ static int ai_rinsn(struct comedi_device
 				if (pipe_full_bits(bits))
 					break;
 			}
-			comedi_udelay(1);
+			udelay(1);
 		}
 		DEBUG_PRINT(" looped %i times waiting for data\n", i);
 		if (i == timeout) {
 			comedi_error(dev, " analog input read insn timed out");
-			rt_printk(" status 0x%x\n", bits);
+			printk(" status 0x%x\n", bits);
 			return -ETIME;
 		}
 		if (board(dev)->layout == LAYOUT_4020)
@@ -2357,11 +2357,11 @@ static void disable_ai_pacing(struct com
 
 	disable_ai_interrupts(dev);
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->adc_control1_bits &= ~ADC_SW_GATE_BIT;
 	writew(priv(dev)->adc_control1_bits,
 		priv(dev)->main_iobase + ADC_CONTROL1_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* disable pacing, triggering, etc */
 	writew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,
@@ -2372,14 +2372,14 @@ static void disable_ai_interrupts(struct
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->intr_enable_bits &=
 		~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
 		~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
 		~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
 	writew(priv(dev)->intr_enable_bits,
 		priv(dev)->main_iobase + INTR_ENABLE_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 }
@@ -2397,12 +2397,12 @@ static void enable_ai_interrupts(struct 
 		if (board(dev)->layout != LAYOUT_4020)
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
 	}
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->intr_enable_bits |= bits;
 	writew(priv(dev)->intr_enable_bits,
 		priv(dev)->main_iobase + INTR_ENABLE_REG);
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,
@@ -2488,7 +2488,7 @@ static inline void dma_start_sync(struct
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	if (channel)
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
 			PLX_CLEAR_DMA_INTR_BIT,
@@ -2497,7 +2497,7 @@ static inline void dma_start_sync(struct
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
 			PLX_CLEAR_DMA_INTR_BIT,
 			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)
@@ -2701,7 +2701,7 @@ static int ai_cmd(struct comedi_device *
 
 	enable_ai_interrupts(dev, cmd);
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/* set mode, allow conversions through software gate */
 	priv(dev)->adc_control1_bits |= ADC_SW_GATE_BIT;
 	priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
@@ -2728,7 +2728,7 @@ static int ai_cmd(struct comedi_device *
 	writew(priv(dev)->adc_control1_bits,
 		priv(dev)->main_iobase + ADC_CONTROL1_REG);
 	DEBUG_PRINT("control1 bits 0x%x\n", priv(dev)->adc_control1_bits);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear adc buffer */
 	writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
@@ -2762,7 +2762,7 @@ static int ai_cmd(struct comedi_device *
 		writew(bits, priv(dev)->main_iobase + DAQ_ATRIG_LOW_4020_REG);
 	}
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/* enable pacing, triggering, etc */
 	bits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;
@@ -2782,7 +2782,7 @@ static int ai_cmd(struct comedi_device *
 
 	priv(dev)->ai_cmd_running = 1;
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  start aquisition */
 	if (cmd->start_src == TRIG_NOW) {
@@ -2842,7 +2842,7 @@ static void pio_drain_ai_fifo_16(struct 
 		}
 
 		if (num_samples < 0) {
-			rt_printk(" cb_pcidas64: bug! num_samples < 0\n");
+			printk(" cb_pcidas64: bug! num_samples < 0\n");
 			break;
 		}
 
@@ -2964,7 +2964,7 @@ void handle_ai_interrupt(struct comedi_d
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 	/*  spin lock makes sure noone else changes plx dma control reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
@@ -2976,7 +2976,7 @@ void handle_ai_interrupt(struct comedi_d
 		}
 		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (status & ADC_DONE_BIT)
 		DEBUG_PRINT("adc done interrupt\n");
@@ -2987,12 +2987,12 @@ void handle_ai_interrupt(struct comedi_d
 			(status & ADC_INTR_PENDING_BIT) &&
 			(board(dev)->layout != LAYOUT_4020))) {
 		DEBUG_PRINT("pio fifo drain\n");
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		if (priv(dev)->ai_cmd_running) {
-			comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+			spin_unlock_irqrestore(&dev->spinlock, flags);
 			pio_drain_ai_fifo(dev);
 		} else
-			comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+			spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/*  if we are have all the data, then quit */
 	if ((cmd->stop_src == TRIG_COUNT && priv(dev)->ai_count <= 0) ||
@@ -3087,7 +3087,7 @@ static void handle_ao_interrupt(struct c
 	cmd = &async->cmd;
 
 	/*  spin lock makes sure noone else changes plx dma control reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		if ((dma0_status & PLX_DMA_EN_BIT)
@@ -3097,7 +3097,7 @@ static void handle_ao_interrupt(struct c
 		else
 			writeb(PLX_CLEAR_DMA_INTR_BIT,
 				priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT) {
 			load_ao_dma(dev, cmd);
@@ -3107,7 +3107,7 @@ static void handle_ao_interrupt(struct c
 		}
 		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
 	} else
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if ((status & DAC_DONE_BIT)) {
 		async->events |= COMEDI_CB_EOA;
@@ -3164,24 +3164,24 @@ void abort_dma(struct comedi_device *dev
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	if (priv(dev)->ai_cmd_running == 0) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
 	priv(dev)->ai_cmd_running = 0;
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	disable_ai_pacing(dev);
 
@@ -3722,12 +3722,12 @@ static void ad8402_write(struct comedi_d
 	static const int bitstream_length = 10;
 	unsigned int bit, register_bits;
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
-	static const int ad8402_comedi_udelay = 1;
+	static const int ad8402_udelay = 1;
 
 	priv(dev)->ad8402_state[channel] = value;
 
 	register_bits = SELECT_8402_64XX_BIT;
-	comedi_udelay(ad8402_comedi_udelay);
+	udelay(ad8402_udelay);
 	writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
@@ -3735,14 +3735,14 @@ static void ad8402_write(struct comedi_d
 			register_bits |= SERIAL_DATA_IN_BIT;
 		else
 			register_bits &= ~SERIAL_DATA_IN_BIT;
-		comedi_udelay(ad8402_comedi_udelay);
+		udelay(ad8402_udelay);
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
-		comedi_udelay(ad8402_comedi_udelay);
+		udelay(ad8402_udelay);
 		writew(register_bits | SERIAL_CLOCK_BIT,
 			priv(dev)->main_iobase + CALIBRATION_REG);
 	}
 
-	comedi_udelay(ad8402_comedi_udelay);
+	udelay(ad8402_udelay);
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
 }
 
@@ -3784,32 +3784,32 @@ static uint16_t read_eeprom(struct comed
 		priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
 	uint16_t value;
 	static const int value_length = 16;
-	static const int eeprom_comedi_udelay = 1;
+	static const int eeprom_udelay = 1;
 
-	comedi_udelay(eeprom_comedi_udelay);
+	udelay(eeprom_udelay);
 	priv(dev)->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;
 	/*  make sure we don't send anything to the i2c bus on 4020 */
 	priv(dev)->plx_control_bits |= CTL_USERO;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
 	/*  activate serial eeprom */
-	comedi_udelay(eeprom_comedi_udelay);
+	udelay(eeprom_udelay);
 	priv(dev)->plx_control_bits |= CTL_EE_CS;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
 
 	/*  write read command and desired memory address */
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		/*  set bit to be written */
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		if (bitstream & bit)
 			priv(dev)->plx_control_bits |= CTL_EE_W;
 		else
 			priv(dev)->plx_control_bits &= ~CTL_EE_W;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		/*  clock in bit */
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits |= CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 	}
@@ -3817,19 +3817,19 @@ static uint16_t read_eeprom(struct comed
 	value = 0;
 	for (bit = 1 << (value_length - 1); bit; bit >>= 1) {
 		/*  clock out bit */
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits |= CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(eeprom_comedi_udelay);
+		udelay(eeprom_udelay);
 		if (readl(plx_control_addr) & CTL_EE_R)
 			value |= bit;
 	}
 
 	/*  deactivate eeprom serial input */
-	comedi_udelay(eeprom_comedi_udelay);
+	udelay(eeprom_udelay);
 	priv(dev)->plx_control_bits &= ~CTL_EE_CS;
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
 
@@ -4018,17 +4018,17 @@ static int caldac_8800_write(struct come
 		register_bits = 0;
 		if (bitstream & bit)
 			register_bits |= SERIAL_DATA_IN_BIT;
-		comedi_udelay(caldac_8800_udelay);
+		udelay(caldac_8800_udelay);
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 		register_bits |= SERIAL_CLOCK_BIT;
-		comedi_udelay(caldac_8800_udelay);
+		udelay(caldac_8800_udelay);
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 	}
-	comedi_udelay(caldac_8800_udelay);
+	udelay(caldac_8800_udelay);
 	writew(SELECT_8800_BIT, priv(dev)->main_iobase + CALIBRATION_REG);
-	comedi_udelay(caldac_8800_udelay);
+	udelay(caldac_8800_udelay);
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
-	comedi_udelay(caldac_8800_udelay);
+	udelay(caldac_8800_udelay);
 	return 0;
 }
 
@@ -4094,8 +4094,8 @@ static int caldac_i2c_write(struct comed
 }
 
 /* Their i2c requires a huge delay on setting clock or data high for some reason */
-static const int i2c_high_comedi_udelay = 1000;
-static const int i2c_low_comedi_udelay = 10;
+static const int i2c_high_udelay = 1000;
+static const int i2c_low_udelay = 10;
 
 /* set i2c data line high or low */
 static void i2c_set_sda(struct comedi_device *dev, int state)
@@ -4107,12 +4107,12 @@ static void i2c_set_sda(struct comedi_de
 		/*  set data line high */
 		priv(dev)->plx_control_bits &= ~data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(i2c_high_comedi_udelay);
+		udelay(i2c_high_udelay);
 	} else			/*  set data line low */
 	{
 		priv(dev)->plx_control_bits |= data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(i2c_low_comedi_udelay);
+		udelay(i2c_low_udelay);
 	}
 }
 
@@ -4126,12 +4126,12 @@ static void i2c_set_scl(struct comedi_de
 		/*  set clock line high */
 		priv(dev)->plx_control_bits &= ~clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(i2c_high_comedi_udelay);
+		udelay(i2c_high_udelay);
 	} else			/*  set clock line low */
 	{
 		priv(dev)->plx_control_bits |= clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
-		comedi_udelay(i2c_low_comedi_udelay);
+		udelay(i2c_low_udelay);
 	}
 }
 
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -588,7 +588,7 @@ static int cb_pcidas_attach(struct comed
 		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	/*  get irq */
-	if (comedi_request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
+	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
 			IRQF_SHARED, "cb_pcidas", dev)) {
 		printk(" unable to allocate irq %d\n", devpriv->pci_dev->irq);
 		return -EINVAL;
@@ -727,14 +727,14 @@ static int cb_pcidas_detach(struct comed
 			outl(INTCSR_INBOX_INTR_STATUS,
 				devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
-			rt_printk("detaching, incsr is 0x%x\n",
+			printk("detaching, incsr is 0x%x\n",
 				inl(devpriv->s5933_config +
 					AMCC_OP_REG_INTCSR));
 #endif
 		}
 	}
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 	if (devpriv && devpriv->pci_dev) {
@@ -843,13 +843,13 @@ static int cb_pcidas_ao_nofifo_winsn(str
 
 	/*  set channel and range */
 	channel = CR_CHAN(insn->chanspec);
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
 		~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);
 	devpriv->ao_control_bits |=
 		DACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  remember value for readback */
 	devpriv->ao_value[channel] = data[0];
@@ -871,7 +871,7 @@ static int cb_pcidas_ao_fifo_winsn(struc
 
 	/*  set channel and range */
 	channel = CR_CHAN(insn->chanspec);
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
 		~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &
 		~DAC_PACER_MASK;
@@ -879,7 +879,7 @@ static int cb_pcidas_ao_fifo_winsn(struc
 		DACEN | DAC_RANGE(channel,
 		CR_RANGE(insn->chanspec)) | DAC_CHAN_EN(channel) | DAC_START;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  remember value for readback */
 	devpriv->ao_value[channel] = data[0];
@@ -940,13 +940,13 @@ static int dac08_write(struct comedi_dev
 
 	outw(cal_enable_bits(dev) | (value & 0xff),
 		devpriv->control_status + CALIBRATION_REG);
-	comedi_udelay(1);
+	udelay(1);
 	outw(cal_enable_bits(dev) | SELECT_DAC08_BIT | (value & 0xff),
 		devpriv->control_status + CALIBRATION_REG);
-	comedi_udelay(1);
+	udelay(1);
 	outw(cal_enable_bits(dev) | (value & 0xff),
 		devpriv->control_status + CALIBRATION_REG);
-	comedi_udelay(1);
+	udelay(1);
 
 	return 1;
 }
@@ -1193,7 +1193,7 @@ static int cb_pcidas_ai_cmd(struct comed
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
 
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: sent 0x%x to adcmux control\n", bits);
+	printk("comedi: sent 0x%x to adcmux control\n", bits);
 #endif
 
 	/*  load counters */
@@ -1209,7 +1209,7 @@ static int cb_pcidas_ai_cmd(struct comed
 		devpriv->count = cmd->chanlist_len * cmd->stop_arg;
 	}
 	/*  enable interrupts */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= INTE;
 	devpriv->adc_fifo_bits &= ~INT_MASK;
 	if (cmd->flags & TRIG_WAKE_EOS) {
@@ -1221,12 +1221,12 @@ static int cb_pcidas_ai_cmd(struct comed
 		devpriv->adc_fifo_bits |= INT_FHF;	/* interrupt fifo half full */
 	}
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
+	printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
 #endif
 	/*  enable (and clear) interrupts */
 	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
 		devpriv->control_status + INT_ADCFIFO);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set start trigger and burst mode */
 	bits = 0;
@@ -1242,7 +1242,7 @@ static int cb_pcidas_ai_cmd(struct comed
 		bits |= BURSTE;
 	outw(bits, devpriv->control_status + TRIG_CONTSTAT);
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: sent 0x%x to trig control\n", bits);
+	printk("comedi: sent 0x%x to trig control\n", bits);
 #endif
 
 	return 0;
@@ -1369,7 +1369,7 @@ static int cb_pcidas_ao_cmd(struct comed
 	unsigned long flags;
 
 	/*  set channel limits, gain */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		/*  enable channel */
 		devpriv->ao_control_bits |=
@@ -1381,7 +1381,7 @@ static int cb_pcidas_ao_cmd(struct comed
 
 	/*  disable analog out before settings pacer source and count values */
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear fifo */
 	outw(0, devpriv->ao_registers + DACFIFOCLR);
@@ -1403,7 +1403,7 @@ static int cb_pcidas_ao_cmd(struct comed
 		devpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;
 	}
 	/*  set pacer source */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		devpriv->ao_control_bits |= DAC_PACER_INT;
@@ -1412,12 +1412,12 @@ static int cb_pcidas_ao_cmd(struct comed
 		devpriv->ao_control_bits |= DAC_PACER_EXT_RISE;
 		break;
 	default:
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		comedi_error(dev, "error setting dac pacer source");
 		return -1;
 		break;
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	async->inttrig = cb_pcidas_ao_inttrig;
 
@@ -1451,10 +1451,10 @@ static int cb_pcidas_ao_inttrig(struct c
 	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);
 
 	/*  enable dac half-full and empty interrupts */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
+	printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
 #endif
 	/*  enable and clear interrupts */
 	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
@@ -1464,10 +1464,10 @@ static int cb_pcidas_ao_inttrig(struct c
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: sent 0x%x to dac control\n",
+	printk("comedi: sent 0x%x to dac control\n",
 		devpriv->ao_control_bits);
 #endif
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	async->inttrig = NULL;
 
@@ -1494,8 +1494,8 @@ static irqreturn_t cb_pcidas_interrupt(i
 
 	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("intcsr 0x%x\n", s5933_status);
-	rt_printk("mbef 0x%x\n", inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
+	printk("intcsr 0x%x\n", s5933_status);
+	printk("mbef 0x%x\n", inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
 #endif
 
 	if ((INTCSR_INTR_ASSERTED & s5933_status) == 0)
@@ -1537,10 +1537,10 @@ static irqreturn_t cb_pcidas_interrupt(i
 			cb_pcidas_cancel(dev, s);
 		}
 		/*  clear half-full interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		/*  else if fifo not empty */
 	} else if (status & (ADNEI | EOBI)) {
 		for (i = 0; i < timeout; i++) {
@@ -1556,27 +1556,27 @@ static irqreturn_t cb_pcidas_interrupt(i
 			}
 		}
 		/*  clear not-empty interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & EOAI) {
 		comedi_error(dev,
 			"bug! encountered end of aquisition interrupt?");
 		/*  clear EOA interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/* check for fifo overflow */
 	if (status & LADFUL) {
 		comedi_error(dev, "fifo overflow");
 		/*  clear overflow interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | LADFUL,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		cb_pcidas_cancel(dev, s);
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
@@ -1599,10 +1599,10 @@ static void handle_ao_interrupt(struct c
 
 	if (status & DAEMI) {
 		/*  clear dac empty interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAEMI,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
 			if (cmd->stop_src == TRIG_NONE ||
 				(cmd->stop_src == TRIG_COUNT
@@ -1633,10 +1633,10 @@ static void handle_ao_interrupt(struct c
 		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
 			num_points);
 		/*  clear half-full interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAHFI,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 
 	comedi_event(dev, s);
@@ -1647,11 +1647,11 @@ static int cb_pcidas_cancel(struct comed
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  disable interrupts */
 	devpriv->adc_fifo_bits &= ~INTE & ~EOAIE;
 	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  disable start trigger source and burst mode */
 	outw(0, devpriv->control_status + TRIG_CONTSTAT);
@@ -1667,7 +1667,7 @@ static int cb_pcidas_ao_cancel(struct co
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  disable interrupts */
 	devpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;
 	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
@@ -1675,7 +1675,7 @@ static int cb_pcidas_ao_cancel(struct co
 	/*  disable output */
 	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
 }
@@ -1705,7 +1705,7 @@ static void write_calibration_bitstream(
 			register_bits |= SERIAL_DATA_IN_BIT;
 		else
 			register_bits &= ~SERIAL_DATA_IN_BIT;
-		comedi_udelay(write_delay);
+		udelay(write_delay);
 		outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 	}
 }
@@ -1716,7 +1716,7 @@ static int caldac_8800_write(struct come
 	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
 	unsigned int bitstream = ((address & 0x7) << 8) | value;
-	static const int caldac_8800_comedi_udelay = 1;
+	static const int caldac_8800_udelay = 1;
 
 	if (address >= num_caldac_channels) {
 		comedi_error(dev, "illegal caldac channel");
@@ -1731,10 +1731,10 @@ static int caldac_8800_write(struct come
 	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
 		bitstream_length);
 
-	comedi_udelay(caldac_8800_comedi_udelay);
+	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
 		devpriv->control_status + CALIBRATION_REG);
-	comedi_udelay(caldac_8800_comedi_udelay);
+	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
 
 	return 1;
@@ -1745,16 +1745,16 @@ static int trimpot_7376_write(struct com
 	static const int bitstream_length = 7;
 	unsigned int bitstream = value & 0x7f;
 	unsigned int register_bits;
-	static const int ad7376_comedi_udelay = 1;
+	static const int ad7376_udelay = 1;
 
 	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
-	comedi_udelay(ad7376_comedi_udelay);
+	udelay(ad7376_udelay);
 	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
 		bitstream_length);
 
-	comedi_udelay(ad7376_comedi_udelay);
+	udelay(ad7376_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
 
 	return 0;
@@ -1769,16 +1769,16 @@ static int trimpot_8402_write(struct com
 	static const int bitstream_length = 10;
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
 	unsigned int register_bits;
-	static const int ad8402_comedi_udelay = 1;
+	static const int ad8402_udelay = 1;
 
 	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
-	comedi_udelay(ad8402_comedi_udelay);
+	udelay(ad8402_udelay);
 	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
 		bitstream_length);
 
-	comedi_udelay(ad8402_comedi_udelay);
+	udelay(ad8402_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
 
 	return 0;
@@ -1794,7 +1794,7 @@ static int wait_for_nvram_ready(unsigned
 					AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
 			== 0)
 			return 0;
-		comedi_udelay(1);
+		udelay(1);
 	}
 	return -1;
 }
--- a/drivers/staging/comedi/drivers/cb_pcimdas.c
+++ b/drivers/staging/comedi/drivers/cb_pcimdas.c
@@ -282,7 +282,7 @@ static int cb_pcimdas_attach(struct come
 
 /* Dont support IRQ yet */
 /*  get irq */
-/* if(comedi_request_irq(devpriv->pci_dev->irq, cb_pcimdas_interrupt, IRQF_SHARED, "cb_pcimdas", dev )) */
+/* if(request_irq(devpriv->pci_dev->irq, cb_pcimdas_interrupt, IRQF_SHARED, "cb_pcimdas", dev )) */
 /* { */
 /* printk(" unable to allocate irq %u\n", devpriv->pci_dev->irq); */
 /* return -EINVAL; */
@@ -355,7 +355,7 @@ static int cb_pcimdas_detach(struct come
 #endif
 	printk("comedi%d: cb_pcimdas: remove\n", dev->minor);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (devpriv) {
 		if (devpriv->pci_dev) {
 			if (devpriv->BADR0) {
--- a/drivers/staging/comedi/drivers/comedi_fc.c
+++ b/drivers/staging/comedi/drivers/comedi_fc.c
@@ -53,7 +53,7 @@ unsigned int cfc_write_array_to_buffer(s
 
 	retval = comedi_buf_write_alloc(async, num_bytes);
 	if (retval != num_bytes) {
-		rt_printk("comedi: buffer overrun\n");
+		printk("comedi: buffer overrun\n");
 		async->events |= COMEDI_CB_OVERFLOW;
 		return 0;
 	}
--- a/drivers/staging/comedi/drivers/comedi_parport.c
+++ b/drivers/staging/comedi/drivers/comedi_parport.c
@@ -310,8 +310,8 @@ static int parport_attach(struct comedi_
 	irq = it->options[1];
 	if (irq) {
 		printk(" irq=%u", irq);
-		ret = comedi_request_irq(irq, parport_interrupt, 0,
-			"comedi_parport", dev);
+		ret = request_irq(irq, parport_interrupt, 0, "comedi_parport",
+				  dev);
 		if (ret < 0) {
 			printk(" irq not available\n");
 			return -EINVAL;
@@ -385,7 +385,7 @@ static int parport_detach(struct comedi_
 		release_region(dev->iobase, PARPORT_SIZE);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/comedi_rt_timer.c
+++ b/drivers/staging/comedi/drivers/comedi_rt_timer.c
@@ -204,7 +204,7 @@ inline static int check_scan_timing(stru
 	timing_error = now - (devpriv->start + scan * devpriv->scan_period);
 	if (timing_error > devpriv->scan_period) {
 		comedi_error(dev, "timing error");
-		rt_printk("scan started %i ns late\n", timing_error * 838);
+		printk("scan started %i ns late\n", timing_error * 838);
 		return -1;
 	}
 
@@ -222,7 +222,7 @@ inline static int check_conversion_timin
 		now - (scan_start + conversion * devpriv->convert_period);
 	if (timing_error > devpriv->convert_period) {
 		comedi_error(dev, "timing error");
-		rt_printk("conversion started %i ns late\n",
+		printk("conversion started %i ns late\n",
 			timing_error * 838);
 		return -1;
 	}
--- a/drivers/staging/comedi/drivers/contec_pci_dio.c
+++ b/drivers/staging/comedi/drivers/contec_pci_dio.c
@@ -205,7 +205,7 @@ static int contec_do_insn_bits(struct co
 	if (data[0]) {
 		s->state &= ~data[0];
 		s->state |= data[0] & data[1];
-		rt_printk("  out: %d on %lx\n", s->state,
+		printk("  out: %d on %lx\n", s->state,
 			dev->iobase + thisboard->out_offs);
 		outw(s->state, dev->iobase + thisboard->out_offs);
 	}
@@ -216,8 +216,8 @@ static int contec_di_insn_bits(struct co
 	struct comedi_insn *insn, unsigned int *data)
 {
 
-	rt_printk("contec_di_insn_bits called\n");
-	rt_printk(" data: %d %d\n", data[0], data[1]);
+	printk("contec_di_insn_bits called\n");
+	printk(" data: %d %d\n", data[0], data[1]);
 
 	if (insn->n != 2)
 		return -EINVAL;
--- a/drivers/staging/comedi/drivers/daqboard2000.c
+++ b/drivers/staging/comedi/drivers/daqboard2000.c
@@ -342,9 +342,9 @@ static void writeAcqScanListEntry(struct
 {
 	struct daqboard2000_hw *fpga = devpriv->daq;
 
-/* comedi_udelay(4); */
+/* udelay(4); */
 	fpga->acqScanListFIFO = entry & 0x00ff;
-/* comedi_udelay(4); */
+/* udelay(4); */
 	fpga->acqScanListFIFO = (entry >> 8) & 0x00ff;
 }
 
@@ -425,14 +425,14 @@ static int daqboard2000_ai_insn_read(str
 			if (fpga->acqControl & DAQBOARD2000_AcqConfigPipeFull) {
 				break;
 			}
-			/* comedi_udelay(2); */
+			/* udelay(2); */
 		}
 		fpga->acqControl = DAQBOARD2000_AdcPacerEnable;
 		for (timeout = 0; timeout < 20; timeout++) {
 			if (fpga->acqControl & DAQBOARD2000_AcqLogicScanning) {
 				break;
 			}
-			/* comedi_udelay(2); */
+			/* udelay(2); */
 		}
 		for (timeout = 0; timeout < 20; timeout++) {
 			if (fpga->
@@ -440,7 +440,7 @@ static int daqboard2000_ai_insn_read(str
 				DAQBOARD2000_AcqResultsFIFOHasValidData) {
 				break;
 			}
-			/* comedi_udelay(2); */
+			/* udelay(2); */
 		}
 		data[i] = fpga->acqResultsFIFO;
 		fpga->acqControl = DAQBOARD2000_AdcPacerDisable;
@@ -476,18 +476,18 @@ static int daqboard2000_ao_insn_write(st
 		 * OK, since it works OK without enabling the DAC's, let's keep
 		 * it as simple as possible...
 		 */
-		/* fpga->dacControl = (chan + 2) * 0x0010 | 0x0001; comedi_udelay(1000); */
+		/* fpga->dacControl = (chan + 2) * 0x0010 | 0x0001; udelay(1000); */
 		fpga->dacSetting[chan] = data[i];
 		for (timeout = 0; timeout < 20; timeout++) {
 			if ((fpga->dacControl & ((chan + 1) * 0x0010)) == 0) {
 				break;
 			}
-			/* comedi_udelay(2); */
+			/* udelay(2); */
 		}
 		devpriv->ao_readback[chan] = data[i];
 		/*
 		 * Since we never enabled the DAC's, we don't need to disable it...
-		 * fpga->dacControl = (chan + 2) * 0x0010 | 0x0000; comedi_udelay(1000);
+		 * fpga->dacControl = (chan + 2) * 0x0010 | 0x0000; udelay(1000);
 		 */
 	}
 
@@ -498,29 +498,29 @@ static void daqboard2000_resetLocalBus(s
 {
 	printk("daqboard2000_resetLocalBus\n");
 	writel(DAQBOARD2000_SECRLocalBusHi, devpriv->plx + 0x6c);
-	comedi_udelay(10000);
+	udelay(10000);
 	writel(DAQBOARD2000_SECRLocalBusLo, devpriv->plx + 0x6c);
-	comedi_udelay(10000);
+	udelay(10000);
 }
 
 static void daqboard2000_reloadPLX(struct comedi_device *dev)
 {
 	printk("daqboard2000_reloadPLX\n");
 	writel(DAQBOARD2000_SECRReloadLo, devpriv->plx + 0x6c);
-	comedi_udelay(10000);
+	udelay(10000);
 	writel(DAQBOARD2000_SECRReloadHi, devpriv->plx + 0x6c);
-	comedi_udelay(10000);
+	udelay(10000);
 	writel(DAQBOARD2000_SECRReloadLo, devpriv->plx + 0x6c);
-	comedi_udelay(10000);
+	udelay(10000);
 }
 
 static void daqboard2000_pulseProgPin(struct comedi_device *dev)
 {
 	printk("daqboard2000_pulseProgPin 1\n");
 	writel(DAQBOARD2000_SECRProgPinHi, devpriv->plx + 0x6c);
-	comedi_udelay(10000);
+	udelay(10000);
 	writel(DAQBOARD2000_SECRProgPinLo, devpriv->plx + 0x6c);
-	comedi_udelay(10000);	/* Not in the original code, but I like symmetry... */
+	udelay(10000);	/* Not in the original code, but I like symmetry... */
 }
 
 static int daqboard2000_pollCPLD(struct comedi_device *dev, int mask)
@@ -536,9 +536,9 @@ static int daqboard2000_pollCPLD(struct 
 			result = 1;
 			break;
 		}
-		comedi_udelay(100);
+		udelay(100);
 	}
-	comedi_udelay(5);
+	udelay(5);
 	return result;
 }
 
@@ -546,7 +546,7 @@ static int daqboard2000_writeCPLD(struct
 {
 	int result = 0;
 
-	comedi_udelay(10);
+	udelay(10);
 	writew(data, devpriv->daq + 0x1000);
 	if ((readw(devpriv->daq + 0x1000) & DAQBOARD2000_CPLD_INIT) ==
 		DAQBOARD2000_CPLD_INIT) {
@@ -623,17 +623,17 @@ static void daqboard2000_adcDisarm(struc
 	struct daqboard2000_hw *fpga = devpriv->daq;
 
 	/* Disable hardware triggers */
-	comedi_udelay(2);
+	udelay(2);
 	fpga->trigControl = DAQBOARD2000_TrigAnalog | DAQBOARD2000_TrigDisable;
-	comedi_udelay(2);
+	udelay(2);
 	fpga->trigControl = DAQBOARD2000_TrigTTL | DAQBOARD2000_TrigDisable;
 
 	/* Stop the scan list FIFO from loading the configuration pipe */
-	comedi_udelay(2);
+	udelay(2);
 	fpga->acqControl = DAQBOARD2000_SeqStopScanList;
 
 	/* Stop the pacer clock */
-	comedi_udelay(2);
+	udelay(2);
 	fpga->acqControl = DAQBOARD2000_AdcPacerDisable;
 
 	/* Stop the input dma (abort channel 1) */
@@ -651,7 +651,7 @@ static void daqboard2000_activateReferen
 		if ((fpga->dacControl & DAQBOARD2000_RefBusy) == 0) {
 			break;
 		}
-		comedi_udelay(2);
+		udelay(2);
 	}
 /*  printk("DAQBOARD2000_PosRefDacSelect %d\n", timeout);*/
 
@@ -661,7 +661,7 @@ static void daqboard2000_activateReferen
 		if ((fpga->dacControl & DAQBOARD2000_RefBusy) == 0) {
 			break;
 		}
-		comedi_udelay(2);
+		udelay(2);
 	}
 /*  printk("DAQBOARD2000_NegRefDacSelect %d\n", timeout);*/
 }
--- a/drivers/staging/comedi/drivers/das08.c
+++ b/drivers/staging/comedi/drivers/das08.c
@@ -545,7 +545,7 @@ static int das08_ai_rinsn(struct comedi_
 		/* clear over-range bits for 16-bit boards */
 		if (thisboard->ai_nbits == 16)
 			if (inb(dev->iobase + DAS08_MSB) & 0x80)
-				rt_printk("das08: over-range\n");
+				printk("das08: over-range\n");
 
 		/* trigger conversion */
 		outb_p(0, dev->iobase + DAS08_TRIG_12BIT);
@@ -555,7 +555,7 @@ static int das08_ai_rinsn(struct comedi_
 				break;
 		}
 		if (i == TIMEOUT) {
-			rt_printk("das08: timeout\n");
+			printk("das08: timeout\n");
 			return -ETIME;
 		}
 		msb = inb(dev->iobase + DAS08_MSB);
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -90,7 +90,7 @@ Computer boards manuals also available f
 /* #define DEBUG */
 
 #ifdef DEBUG
-#define DEBUG_PRINT(format, args...) rt_printk("das16: " format, ## args)
+#define DEBUG_PRINT(format, args...) printk("das16: " format, ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif
@@ -998,7 +998,7 @@ static int das16_cancel(struct comedi_de
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/* disable interrupts, dma and pacer clocked conversions */
 	devpriv->control_state &= ~DAS16_INTE & ~PACING_MASK & ~DMA_ENABLE;
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
@@ -1016,7 +1016,7 @@ static int das16_cancel(struct comedi_de
 		outb(0, dev->iobase + DAS1600_BURST);
 	}
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
 }
@@ -1062,7 +1062,7 @@ static int das16_ai_rinsn(struct comedi_
 				break;
 		}
 		if (i == DAS16_TIMEOUT) {
-			rt_printk("das16: timeout\n");
+			printk("das16: timeout\n");
 			return -ETIME;
 		}
 		msb = inb(dev->iobase + DAS16_AI_MSB);
@@ -1180,7 +1180,7 @@ static int disable_dma_on_even(struct co
 		enable_dma(devpriv->dma_chan);
 		for (j = 0; j < enable_timeout; ++j) {
 			int new_residue;
-			comedi_udelay(2);
+			udelay(2);
 			new_residue = get_dma_residue(devpriv->dma_chan);
 			if (new_residue != residue)
 				break;
@@ -1217,9 +1217,9 @@ static void das16_interrupt(struct comed
 		return;
 	}
 
-	comedi_spin_lock_irqsave(&dev->spinlock, spin_flags);
+	spin_lock_irqsave(&dev->spinlock, spin_flags);
 	if ((devpriv->control_state & DMA_ENABLE) == 0) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, spin_flags);
+		spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 		DEBUG_PRINT("interrupt while dma disabled?\n");
 		return;
 	}
@@ -1263,7 +1263,7 @@ static void das16_interrupt(struct comed
 	}
 	release_dma_lock(dma_flags);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, spin_flags);
+	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
 	cfc_write_array_to_buffer(s,
 		devpriv->dma_buffer[buffer_index], num_bytes);
@@ -1449,8 +1449,7 @@ static int das16_attach(struct comedi_de
 
 	/* now for the irq */
 	if (irq > 1 && irq < 8) {
-		ret = comedi_request_irq(irq, das16_dma_interrupt, 0,
-					 "das16", dev);
+		ret = request_irq(irq, das16_dma_interrupt, 0, "das16", dev);
 
 		if (ret < 0)
 			return ret;
@@ -1658,7 +1657,7 @@ static int das16_detach(struct comedi_de
 	}
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (dev->iobase) {
 		if (thisboard->size < 0x400) {
--- a/drivers/staging/comedi/drivers/das16m1.c
+++ b/drivers/staging/comedi/drivers/das16m1.c
@@ -466,10 +466,10 @@ static int das16m1_poll(struct comedi_de
 	unsigned int status;
 
 	/*  prevent race with interrupt handler */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	status = inb(dev->iobase + DAS16M1_CS);
 	das16m1_handler(dev, status);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
@@ -669,8 +669,8 @@ static int das16m1_attach(struct comedi_
 	irq = it->options[1];
 	/*  make sure it is valid */
 	if (das16m1_irq_bits(irq) >= 0) {
-		ret = comedi_request_irq(irq, das16m1_interrupt, 0,
-			driver_das16m1.driver_name, dev);
+		ret = request_irq(irq, das16m1_interrupt, 0,
+				  driver_das16m1.driver_name, dev);
 		if (ret < 0) {
 			printk(", irq unavailable\n");
 			return ret;
@@ -753,7 +753,7 @@ static int das16m1_detach(struct comedi_
 		subdev_8255_cleanup(dev, dev->subdevices + 3);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (dev->iobase) {
 		release_region(dev->iobase, DAS16M1_SIZE);
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -651,7 +651,7 @@ static int das1800_attach(struct comedi_
 
 	/* grab our IRQ */
 	if (irq) {
-		if (comedi_request_irq(irq, das1800_interrupt, 0,
+		if (request_irq(irq, das1800_interrupt, 0,
 				driver_das1800.driver_name, dev)) {
 			printk(" unable to allocate irq %u\n", irq);
 			return -EINVAL;
@@ -771,7 +771,7 @@ static int das1800_detach(struct comedi_
 	if (dev->iobase)
 		release_region(dev->iobase, DAS1800_SIZE);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->private) {
 		if (devpriv->iobase2)
 			release_region(devpriv->iobase2, DAS1800_SIZE);
@@ -872,9 +872,9 @@ static int das1800_ai_poll(struct comedi
 	unsigned long flags;
 
 	/*  prevent race with interrupt handler */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	das1800_ai_handler(dev);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
@@ -1471,7 +1471,7 @@ static void program_chanlist(struct come
 
 	n = cmd.chanlist_len;
 	/*  spinlock protects indirect addressing */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*set QRAM address start */
 	/* make channel / gain list */
@@ -1483,7 +1483,7 @@ static void program_chanlist(struct come
 		outw(chan_range, dev->iobase + DAS1800_QRAM);
 	}
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return;
 }
@@ -1582,7 +1582,7 @@ static int das1800_ai_rinsn(struct comed
 	/* mask of unipolar/bipolar bit from range */
 	range = CR_RANGE(insn->chanspec) & 0x3;
 	chan_range = chan | (range << 8);
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
 	outb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);	/* set QRAM address start */
 	outw(chan_range, dev->iobase + DAS1800_QRAM);
@@ -1606,7 +1606,7 @@ static int das1800_ai_rinsn(struct comed
 			dpnt += 1 << (thisboard->resolution - 1);
 		data[n] = dpnt;
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return n;
 }
@@ -1627,7 +1627,7 @@ static int das1800_ao_winsn(struct comed
 	if (chan == update_chan)
 		devpriv->ao_update_bits = output;
 	/*  write to channel */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(DAC(chan), dev->iobase + DAS1800_SELECT);	/* select dac channel for baseAddress + 0x0 */
 	outw(output, dev->iobase + DAS1800_DAC);
 	/*  now we need to write to 'update' channel to update all dac channels */
@@ -1635,7 +1635,7 @@ static int das1800_ao_winsn(struct comed
 		outb(DAC(update_chan), dev->iobase + DAS1800_SELECT);	/* select 'update' channel for baseAddress + 0x0 */
 		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return 1;
 }
--- a/drivers/staging/comedi/drivers/das6402.c
+++ b/drivers/staging/comedi/drivers/das6402.c
@@ -292,7 +292,7 @@ static int board_init(struct comedi_devi
 static int das6402_detach(struct comedi_device *dev)
 {
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, DAS6402_SIZE);
 
@@ -324,7 +324,7 @@ static int das6402_attach(struct comedi_
 
 	irq = it->options[0];
 	printk(" ( irq = %u )", irq);
-	ret = comedi_request_irq(irq, intr_handler, 0, "das6402", dev);
+	ret = request_irq(irq, intr_handler, 0, "das6402", dev);
 	if (ret < 0) {
 		printk("irq conflict\n");
 		return ret;
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -279,10 +279,10 @@ static int das800_probe(struct comedi_de
 	int board;
 
 	/*  'comedi spin lock irqsave' disables even rt interrupts, we use them to protect indirect addressing */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(ID, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be ID register */
 	id_bits = inb(dev->iobase + DAS800_ID) & 0x3;	/* get id bits */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	board = thisboard - das800_boards;
 
@@ -370,12 +370,12 @@ static irqreturn_t das800_interrupt(int 
 	async = s->async;
 
 	/*  if hardware conversions are not enabled, then quit */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
 	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
 	/* don't release spinlock yet since we want to make sure noone else disables hardware conversions */
 	if (status == 0) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		return IRQ_HANDLED;
 	}
 
@@ -415,7 +415,7 @@ static irqreturn_t das800_interrupt(int 
 		fifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;
 	}
 	if (fifo_overflow) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		comedi_error(dev, "DAS800 FIFO overflow");
 		das800_cancel(dev, dev->subdevices + 0);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
@@ -429,10 +429,10 @@ static irqreturn_t das800_interrupt(int 
 		outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 		outb(CONTROL1_INTE | devpriv->do_bits,
 			dev->iobase + DAS800_CONTROL1);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		/* otherwise, stop taking data */
 	} else {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		disable_das800(dev);	/* diable hardware triggered conversions */
 		async->events |= COMEDI_CB_EOA;
 	}
@@ -484,7 +484,7 @@ static int das800_attach(struct comedi_d
 		return -EINVAL;
 	}
 	if (irq) {
-		if (comedi_request_irq(irq, das800_interrupt, 0, "das800", dev)) {
+		if (request_irq(irq, das800_interrupt, 0, "das800", dev)) {
 			printk("unable to allocate irq %u\n", irq);
 			return -EINVAL;
 		}
@@ -531,10 +531,10 @@ static int das800_attach(struct comedi_d
 	disable_das800(dev);
 
 	/* initialize digital out channels */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return 0;
 };
@@ -547,7 +547,7 @@ static int das800_detach(struct comedi_d
 	if (dev->iobase)
 		release_region(dev->iobase, DAS800_SIZE);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	return 0;
 };
 
@@ -563,7 +563,7 @@ static int das800_cancel(struct comedi_d
 static void enable_das800(struct comedi_device *dev)
 {
 	unsigned long irq_flags;
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	/*  enable fifo-half full interrupts for cio-das802/16 */
 	if (thisboard->resolution == 16)
 		outb(CIO_ENHF, dev->iobase + DAS800_GAIN);
@@ -571,17 +571,17 @@ static void enable_das800(struct comedi_
 	outb(CONV_HCEN, dev->iobase + DAS800_CONV_CONTROL);	/* enable hardware triggering */
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 	outb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);	/* enable card's interrupt */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
 /* disable_das800 stops hardware triggered conversions */
 static void disable_das800(struct comedi_device *dev)
 {
 	unsigned long irq_flags;
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
 	outb(0x0, dev->iobase + DAS800_CONV_CONTROL);	/* disable hardware triggering of conversions */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
 static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -729,10 +729,10 @@ static int das800_ai_do_cmd(struct comed
 	endChan = (startChan + async->cmd.chanlist_len - 1) % 8;
 	scan = (endChan << 3) | startChan;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(SCAN_LIMITS, dev->iobase + DAS800_GAIN);	/* select base address + 2 to be scan limits register */
 	outb(scan, dev->iobase + DAS800_SCAN_LIMITS);	/* set scan limits */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain */
 	gain = CR_RANGE(async->cmd.chanlist[0]);
@@ -779,10 +779,10 @@ static int das800_ai_do_cmd(struct comed
 		break;
 	}
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
 	outb(conv_bits, dev->iobase + DAS800_CONV_CONTROL);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 	async->events = 0;
 	enable_das800(dev);
 	return 0;
@@ -803,10 +803,10 @@ static int das800_ai_rinsn(struct comedi
 	/* set multiplexer */
 	chan = CR_CHAN(insn->chanspec);
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 	outb(chan | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	/* set gain / range */
 	range = CR_RANGE(insn->chanspec);
@@ -815,7 +815,7 @@ static int das800_ai_rinsn(struct comedi
 	range &= 0xf;
 	outb(range, dev->iobase + DAS800_GAIN);
 
-	comedi_udelay(5);
+	udelay(5);
 
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
@@ -868,10 +868,10 @@ static int das800_do_wbits(struct comedi
 	wbits |= data[0] & data[1];
 	devpriv->do_bits = wbits << 4;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 	outb(devpriv->do_bits | CONTROL1_INTE, dev->iobase + DAS800_CONTROL1);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	data[1] = wbits;
 
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -380,8 +380,7 @@ static int dmm32at_attach(struct comedi_
 
 	/* board is there, register interrupt */
 	if (irq) {
-		ret = comedi_request_irq(irq, dmm32at_isr, 0, thisboard->name,
-			dev);
+		ret = request_irq(irq, dmm32at_isr, 0, thisboard->name, dev);
 		if (ret < 0) {
 			printk("irq conflict\n");
 			return ret;
@@ -485,7 +484,7 @@ static int dmm32at_detach(struct comedi_
 {
 	printk("comedi%d: dmm32at: remove\n", dev->minor);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, DMM32AT_MEMSIZE);
 
--- a/drivers/staging/comedi/drivers/dt2801.c
+++ b/drivers/staging/comedi/drivers/dt2801.c
@@ -384,7 +384,7 @@ static int dt2801_reset(struct comedi_de
 	outb_p(DT_C_STOP, dev->iobase + DT2801_CMD);
 
 	/* dt2801_wait_for_ready(dev); */
-	comedi_udelay(100);
+	udelay(100);
 	timeout = 10000;
 	do {
 		stat = inb_p(dev->iobase + DT2801_STATUS);
@@ -402,7 +402,7 @@ static int dt2801_reset(struct comedi_de
 	outb_p(DT_C_RESET, dev->iobase + DT2801_CMD);
 	/* dt2801_writecmd(dev,DT_C_RESET); */
 
-	comedi_udelay(100);
+	udelay(100);
 	timeout = 10000;
 	do {
 		stat = inb_p(dev->iobase + DT2801_STATUS);
--- a/drivers/staging/comedi/drivers/dt2811.c
+++ b/drivers/staging/comedi/drivers/dt2811.c
@@ -335,7 +335,7 @@ static int dt2811_attach(struct comedi_d
 
 #if 0
 	outb(0, dev->iobase + DT2811_ADCSR);
-	comedi_udelay(100);
+	udelay(100);
 	i = inb(dev->iobase + DT2811_ADDATLO);
 	i = inb(dev->iobase + DT2811_ADDATHI);
 #endif
@@ -351,7 +351,7 @@ static int dt2811_attach(struct comedi_d
 			dev->iobase + DT2811_ADCSR);
 		outb(0, dev->iobase + DT2811_ADGCR);
 
-		comedi_udelay(100);
+		udelay(100);
 
 		irq = probe_irq_off(irqs);
 		restore_flags(flags);
@@ -366,7 +366,7 @@ static int dt2811_attach(struct comedi_d
 			i = inb(dev->iobase + DT2811_ADDATLO);
 			i = inb(dev->iobase + DT2811_ADDATHI);
 			printk("(irq = %d)\n", irq);
-			ret = comedi_request_irq(irq, dt2811_interrupt, 0,
+			ret = request_irq(irq, dt2811_interrupt, 0,
 				driver_name, dev);
 			if (ret < 0)
 				return -EIO;
@@ -489,7 +489,7 @@ static int dt2811_detach(struct comedi_d
 	printk("comedi%d: dt2811: remove\n", dev->minor);
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->iobase) {
 		release_region(dev->iobase, DT2811_SIZE);
--- a/drivers/staging/comedi/drivers/dt2814.c
+++ b/drivers/staging/comedi/drivers/dt2814.c
@@ -97,7 +97,7 @@ static int dt2814_ai_insn_read(struct co
 		for (i = 0; i < DT2814_TIMEOUT; i++) {
 			status = inb(dev->iobase + DT2814_CSR);
 			printk("dt2814: status: %02x\n", status);
-			comedi_udelay(10);
+			udelay(10);
 			if (status & DT2814_FINISH)
 				break;
 		}
@@ -262,7 +262,7 @@ static int dt2814_attach(struct comedi_d
 	dev->board_name = "dt2814";
 
 	outb(0, dev->iobase + DT2814_CSR);
-	comedi_udelay(100);
+	udelay(100);
 	if (inb(dev->iobase + DT2814_CSR) & DT2814_ERR) {
 		printk("reset error (fatal)\n");
 		return -EIO;
@@ -279,7 +279,7 @@ static int dt2814_attach(struct comedi_d
 
 		outb(0, dev->iobase + DT2814_CSR);
 
-		comedi_udelay(100);
+		udelay(100);
 
 		irq = probe_irq_off(irqs);
 		restore_flags(flags);
@@ -293,7 +293,7 @@ static int dt2814_attach(struct comedi_d
 #endif
 	dev->irq = 0;
 	if (irq > 0) {
-		if (comedi_request_irq(irq, dt2814_interrupt, 0, "dt2814", dev)) {
+		if (request_irq(irq, dt2814_interrupt, 0, "dt2814", dev)) {
 			printk("(irq %d unavailable)\n", irq);
 		} else {
 			printk("( irq = %d )\n", irq);
@@ -337,7 +337,7 @@ static int dt2814_detach(struct comedi_d
 	printk("comedi%d: dt2814: remove\n", dev->minor);
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->iobase) {
 		release_region(dev->iobase, DT2814_SIZE);
--- a/drivers/staging/comedi/drivers/dt2815.c
+++ b/drivers/staging/comedi/drivers/dt2815.c
@@ -135,7 +135,7 @@ static int dt2815_ao_insn(struct comedi_
 
 		status = dt2815_wait_for_status(dev, 0x00);
 		if (status != 0) {
-			rt_printk
+			printk
 				("dt2815: failed to write low byte on %d reason %x\n",
 				chan, status);
 			return -EBUSY;
@@ -145,7 +145,7 @@ static int dt2815_ao_insn(struct comedi_
 
 		status = dt2815_wait_for_status(dev, 0x10);
 		if (status != 0x10) {
-			rt_printk
+			printk
 				("dt2815: failed to write high byte on %d reason %x\n",
 				chan, status);
 			return -EBUSY;
@@ -226,7 +226,7 @@ static int dt2815_attach(struct comedi_d
 		/* This is incredibly slow (approx 20 ms) */
 		unsigned int status;
 
-		comedi_udelay(1000);
+		udelay(1000);
 		status = inb(dev->iobase + DT2815_STATUS);
 		if (status == 4) {
 			unsigned int program;
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -389,7 +389,7 @@ struct dt282x_private {
 		int _i;					\
 		for (_i=0;_i<DT2821_TIMEOUT;_i++){	\
 			if (a){_i=0;break;}		\
-			comedi_udelay(5);			\
+			udelay(5);			\
 		}					\
 		if (_i){b}				\
 	}while (0)
@@ -463,7 +463,7 @@ static void dt282x_ao_dma_interrupt(stru
 
 	size = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);
 	if (size == 0) {
-		rt_printk("dt282x: AO underrun\n");
+		printk("dt282x: AO underrun\n");
 		dt282x_ao_cancel(dev, s);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return;
@@ -1080,7 +1080,7 @@ static int dt282x_ao_inttrig(struct come
 	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,
 		devpriv->dma_maxsize);
 	if (size == 0) {
-		rt_printk("dt282x: AO underrun\n");
+		printk("dt282x: AO underrun\n");
 		return -EPIPE;
 	}
 	prep_ao_dma(dev, 0, size);
@@ -1088,7 +1088,7 @@ static int dt282x_ao_inttrig(struct come
 	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
 		devpriv->dma_maxsize);
 	if (size == 0) {
-		rt_printk("dt282x: AO underrun\n");
+		printk("dt282x: AO underrun\n");
 		return -EPIPE;
 	}
 	prep_ao_dma(dev, 1, size);
@@ -1298,7 +1298,7 @@ static int dt282x_attach(struct comedi_d
 
 		/* trigger interrupt */
 
-		comedi_udelay(100);
+		udelay(100);
 
 		irq = probe_irq_off(irqs);
 		restore_flags(flags);
@@ -1309,8 +1309,7 @@ static int dt282x_attach(struct comedi_d
 #endif
 	if (irq > 0) {
 		printk(" ( irq = %d )", irq);
-		ret = comedi_request_irq(irq, dt282x_interrupt, 0, "dt282x",
-			dev);
+		ret = request_irq(irq, dt282x_interrupt, 0, "dt282x", dev);
 		if (ret < 0) {
 			printk(" failed to get irq\n");
 			return -EIO;
@@ -1403,7 +1402,7 @@ static int dt282x_attach(struct comedi_d
 static void free_resources(struct comedi_device *dev)
 {
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->iobase)
 		release_region(dev->iobase, DT2821_SIZE);
--- a/drivers/staging/comedi/drivers/dt3000.c
+++ b/drivers/staging/comedi/drivers/dt3000.c
@@ -307,7 +307,7 @@ static int dt3k_send_cmd(struct comedi_d
 		status = readw(devpriv->io_addr + DPR_Command_Mbx);
 		if ((status & DT3000_COMPLETION_MASK) != DT3000_NOTPROCESSED)
 			break;
-		comedi_udelay(1);
+		udelay(1);
 	}
 	if ((status & DT3000_COMPLETION_MASK) == DT3000_NOERROR) {
 		return 0;
@@ -825,8 +825,8 @@ static int dt3000_attach(struct comedi_d
 
 	dev->board_name = this_board->name;
 
-	if (comedi_request_irq(devpriv->pci_dev->irq, dt3k_interrupt,
-			IRQF_SHARED, "dt3000", dev)) {
+	if (request_irq(devpriv->pci_dev->irq, dt3k_interrupt, IRQF_SHARED,
+			"dt3000", dev)) {
 		printk(" unable to allocate IRQ %u\n", devpriv->pci_dev->irq);
 		return -EINVAL;
 	}
@@ -895,7 +895,7 @@ static int dt3000_attach(struct comedi_d
 static int dt3000_detach(struct comedi_device *dev)
 {
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (devpriv) {
 		if (devpriv->pci_dev) {
--- a/drivers/staging/comedi/drivers/fl512.c
+++ b/drivers/staging/comedi/drivers/fl512.c
@@ -78,7 +78,7 @@ static int fl512_ai_insn(struct comedi_d
 		outb(chan, iobase + 2);	/* select chan */
 		outb(0, iobase + 3);	/* start conversion */
 		/* XXX should test "done" flag instead of delay */
-		comedi_udelay(30);	/* sleep 30 usec */
+		udelay(30);	/* sleep 30 usec */
 		lo_byte = inb(iobase + 2);	/* low 8 byte */
 		hi_byte = inb(iobase + 3) & 0xf;	/* high 4 bit and mask */
 		data[n] = lo_byte + (hi_byte << 8);
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -66,7 +66,7 @@ static int dio_config_block_size(struct 
 /* #define HPDI_DEBUG      enable debugging code */
 
 #ifdef HPDI_DEBUG
-#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args)
+#define DEBUG_PRINT(format, args...)  printk(format , ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif
@@ -109,7 +109,7 @@ enum hpdi_registers {
 int command_channel_valid(unsigned int channel)
 {
 	if (channel == 0 || channel > 6) {
-		rt_printk("gsc_hpdi: bug! invalid cable command channel\n");
+		printk("gsc_hpdi: bug! invalid cable command channel\n");
 		return 0;
 	}
 	return 1;
@@ -465,7 +465,7 @@ static int init_hpdi(struct comedi_devic
 	uint32_t plx_intcsr_bits;
 
 	writel(BOARD_RESET_BIT, priv(dev)->hpdi_iobase + BOARD_CONTROL_REG);
-	comedi_udelay(10);
+	udelay(10);
 
 	writel(almost_empty_bits(32) | almost_full_bits(32),
 		priv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);
@@ -622,7 +622,7 @@ static int hpdi_attach(struct comedi_dev
 	init_plx9080(dev);
 
 	/*  get irq */
-	if (comedi_request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			driver_hpdi.driver_name, dev)) {
 		printk(" unable to allocate irq %u\n", pcidev->irq);
 		return -EINVAL;
@@ -667,7 +667,7 @@ static int hpdi_detach(struct comedi_dev
 	printk("comedi%d: gsc_hpdi: remove\n", dev->minor);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (priv(dev)) {
 		if (priv(dev)->hw_dev) {
 			if (priv(dev)->plx9080_iobase) {
@@ -862,11 +862,11 @@ static int di_cmd(struct comedi_device *
 	writel(bits, priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 
 	/*  spinlock for plx dma control/status reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  enable dma transfer */
 	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
 		priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (cmd->stop_src == TRIG_COUNT)
 		priv(dev)->dio_count = cmd->stop_arg;
@@ -971,7 +971,7 @@ static irqreturn_t handle_interrupt(int 
 			priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
 	/*  spin lock makes sure noone else changes plx dma control reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
@@ -983,10 +983,10 @@ static irqreturn_t handle_interrupt(int 
 		}
 		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  spin lock makes sure noone else changes plx dma control reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A)	/*  XXX */
 	{			/*  dma chan 1 interrupt */
@@ -996,7 +996,7 @@ static irqreturn_t handle_interrupt(int 
 
 		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear possible plx9080 interrupt sources */
 	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
@@ -1036,11 +1036,11 @@ void abort_dma(struct comedi_device *dev
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
--- a/drivers/staging/comedi/drivers/icp_multi.c
+++ b/drivers/staging/comedi/drivers/icp_multi.c
@@ -282,7 +282,7 @@ static int icp_multi_insn_read_ai(struct
 			readw(devpriv->io_addr + ICP_MULTI_ADC_CSR));
 #endif
 
-		comedi_udelay(1);
+		udelay(1);
 
 #ifdef ICP_MULTI_EXTDEBUG
 		printk("icp multi C n=%d ST=%4x\n", n,
@@ -304,7 +304,7 @@ static int icp_multi_insn_read_ai(struct
 						ICP_MULTI_ADC_CSR));
 #endif
 
-			comedi_udelay(1);
+			udelay(1);
 		}
 
 		/*  If we reach here, a timeout has occurred */
@@ -411,7 +411,7 @@ static int icp_multi_insn_write_ao(struc
 						ICP_MULTI_DAC_CSR));
 #endif
 
-			comedi_udelay(1);
+			udelay(1);
 		}
 
 		/*  If we reach here, a timeout has occurred */
@@ -842,7 +842,7 @@ static int icp_multi_reset(struct comedi
 				devpriv->io_addr + ICP_MULTI_DAC_CSR);
 
 			/*  Delay to allow DAC time to recover */
-			comedi_udelay(1);
+			udelay(1);
 		}
 	/*  Digital outputs to 0 */
 	writew(0, devpriv->io_addr + ICP_MULTI_DO);
@@ -954,7 +954,7 @@ static int icp_multi_attach(struct comed
 
 	if (this_board->have_irq) {
 		if (irq) {
-			if (comedi_request_irq(irq, interrupt_service_icp_multi,
+			if (request_irq(irq, interrupt_service_icp_multi,
 					IRQF_SHARED, "Inova Icp Multi", dev)) {
 				printk(", unable to allocate IRQ %u, DISABLING IT", irq);
 				irq = 0;	/* Can't use IRQ */
@@ -1072,7 +1072,7 @@ static int icp_multi_detach(struct comed
 			icp_multi_reset(dev);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (dev->private && devpriv->io_addr)
 		iounmap(devpriv->io_addr);
--- a/drivers/staging/comedi/drivers/icp_multi.h
+++ b/drivers/staging/comedi/drivers/icp_multi.h
@@ -168,14 +168,14 @@ static int pci_card_alloc(struct pcilst_
 	int i;
 
 	if (!inova) {
-		rt_printk(" - BUG!! inova is NULL!\n");
+		printk(" - BUG!! inova is NULL!\n");
 		return -1;
 	}
 
 	if (inova->used)
 		return 1;
 	if (comedi_pci_enable(inova->pcidev, "icp_multi")) {
-		rt_printk(" - Can't enable PCI device and request regions!\n");
+		printk(" - Can't enable PCI device and request regions!\n");
 		return -1;
 	}
 	/* Resources will be accurate now. */
@@ -248,19 +248,19 @@ static struct pcilst_struct *select_and_
 
 		card = find_free_pci_card_by_device(vendor_id, device_id);
 		if (card == NULL) {
-			rt_printk(" - Unused card not found in system!\n");
+			printk(" - Unused card not found in system!\n");
 			return NULL;
 		}
 	} else {
 		switch (find_free_pci_card_by_position(vendor_id, device_id,
 				pci_bus, pci_slot, &card)) {
 		case 1:
-			rt_printk
+			printk
 				(" - Card not found on requested position b:s %d:%d!\n",
 				pci_bus, pci_slot);
 			return NULL;
 		case 2:
-			rt_printk
+			printk
 				(" - Card on requested position is used b:s %d:%d!\n",
 				pci_bus, pci_slot);
 			return NULL;
@@ -270,7 +270,7 @@ static struct pcilst_struct *select_and_
 	err = pci_card_alloc(card);
 	if (err != 0) {
 		if (err > 0)
-			rt_printk(" - Can't allocate card!\n");
+			printk(" - Can't allocate card!\n");
 		/* else: error already printed. */
 		return NULL;
 	}
--- a/drivers/staging/comedi/drivers/jr3_pci.c
+++ b/drivers/staging/comedi/drivers/jr3_pci.c
@@ -185,10 +185,10 @@ static void set_transforms(volatile stru
 
 		set_u16(&channel->transforms[num].link[i].link_type,
 			transf.link[i].link_type);
-		comedi_udelay(1);
+		udelay(1);
 		set_s16(&channel->transforms[num].link[i].link_amount,
 			transf.link[i].link_amount);
-		comedi_udelay(1);
+		udelay(1);
 		if (transf.link[i].link_type == end_x_form) {
 			break;
 		}
@@ -496,12 +496,12 @@ static int jr3_download_firmware(struct 
 								channel[i].
 								program_low
 								[addr], data1);
-							comedi_udelay(1);
+							udelay(1);
 							set_u16(&p->iobase->
 								channel[i].
 								program_high
 								[addr], data2);
-							comedi_udelay(1);
+							udelay(1);
 
 						}
 					}
@@ -734,7 +734,7 @@ static void jr3_pci_poll_dev(unsigned lo
 	int delay;
 	int i;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	delay = 1000;
 	now = jiffies;
 	/*  Poll all channels that are ready to be polled */
@@ -757,7 +757,7 @@ static void jr3_pci_poll_dev(unsigned lo
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	devpriv->timer.expires = jiffies + msecs_to_jiffies(delay);
 	add_timer(&devpriv->timer);
--- a/drivers/staging/comedi/drivers/me4000.c
+++ b/drivers/staging/comedi/drivers/me4000.c
@@ -283,7 +283,7 @@ static int me4000_attach(struct comedi_d
 		s->insn_read = me4000_ai_insn_read;
 
 		if (info->irq > 0) {
-			if (comedi_request_irq(info->irq, me4000_ai_isr,
+			if (request_irq(info->irq, me4000_ai_isr,
 					IRQF_SHARED, "ME-4000", dev)) {
 				printk("comedi%d: me4000: me4000_attach(): Unable to allocate irq\n", dev->minor);
 			} else {
--- a/drivers/staging/comedi/drivers/mite.c
+++ b/drivers/staging/comedi/drivers/mite.c
@@ -258,7 +258,7 @@ struct mite_channel *mite_request_channe
 	struct mite_channel *channel = NULL;
 
 	/*  spin lock so mite_release_channel can be called safely from interrupts */
-	comedi_spin_lock_irqsave(&mite->lock, flags);
+	spin_lock_irqsave(&mite->lock, flags);
 	for (i = min_channel; i <= max_channel; ++i) {
 		if (mite->channel_allocated[i] == 0) {
 			mite->channel_allocated[i] = 1;
@@ -267,7 +267,7 @@ struct mite_channel *mite_request_channe
 			break;
 		}
 	}
-	comedi_spin_unlock_irqrestore(&mite->lock, flags);
+	spin_unlock_irqrestore(&mite->lock, flags);
 	return channel;
 }
 
@@ -277,7 +277,7 @@ void mite_release_channel(struct mite_ch
 	unsigned long flags;
 
 	/*  spin lock to prevent races with mite_request_channel */
-	comedi_spin_lock_irqsave(&mite->lock, flags);
+	spin_lock_irqsave(&mite->lock, flags);
 	if (mite->channel_allocated[mite_chan->channel]) {
 		mite_dma_disarm(mite_chan);
 		mite_dma_reset(mite_chan);
@@ -292,7 +292,7 @@ MITE_CHCR reg isn't changed while dma is
 		mite_chan->ring = NULL;
 		mmiowb();
 	}
-	comedi_spin_unlock_irqrestore(&mite->lock, flags);
+	spin_unlock_irqrestore(&mite->lock, flags);
 }
 
 void mite_dma_arm(struct mite_channel *mite_chan)
@@ -307,11 +307,11 @@ void mite_dma_arm(struct mite_channel *m
 	smp_mb();
 	/* arm */
 	chor = CHOR_START;
-	comedi_spin_lock_irqsave(&mite->lock, flags);
+	spin_lock_irqsave(&mite->lock, flags);
 	mite_chan->done = 0;
 	writel(chor, mite->mite_io_addr + MITE_CHOR(mite_chan->channel));
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&mite->lock, flags);
+	spin_unlock_irqrestore(&mite->lock, flags);
 /*       mite_dma_tcr(mite, channel); */
 }
 
@@ -413,7 +413,7 @@ void mite_prep_dma(struct mite_channel *
 		mcr |= CR_PSIZE32;
 		break;
 	default:
-		rt_printk
+		printk
 			("mite: bug! invalid mem bit width for dma transfer\n");
 		break;
 	}
@@ -433,7 +433,7 @@ void mite_prep_dma(struct mite_channel *
 		dcr |= CR_PSIZE32;
 		break;
 	default:
-		rt_printk
+		printk
 			("mite: bug! invalid dev bit width for dma transfer\n");
 		break;
 	}
@@ -539,7 +539,7 @@ int mite_sync_input_dma(struct mite_chan
 	nbytes = mite_bytes_written_to_memory_lb(mite_chan);
 	if ((int)(mite_bytes_written_to_memory_ub(mite_chan) -
 			old_alloc_count) > 0) {
-		rt_printk("mite: DMA overwrite of free area\n");
+		printk("mite: DMA overwrite of free area\n");
 		async->events |= COMEDI_CB_OVERFLOW;
 		return -1;
 	}
@@ -581,7 +581,7 @@ int mite_sync_output_dma(struct mite_cha
 		(int)(nbytes_ub - stop_count) > 0)
 		nbytes_ub = stop_count;
 	if ((int)(nbytes_ub - old_alloc_count) > 0) {
-		rt_printk("mite: DMA underrun\n");
+		printk("mite: DMA underrun\n");
 		async->events |= COMEDI_CB_OVERFLOW;
 		return -1;
 	}
@@ -602,7 +602,7 @@ unsigned mite_get_status(struct mite_cha
 	unsigned status;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&mite->lock, flags);
+	spin_lock_irqsave(&mite->lock, flags);
 	status = readl(mite->mite_io_addr + MITE_CHSR(mite_chan->channel));
 	if (status & CHSR_DONE) {
 		mite_chan->done = 1;
@@ -610,7 +610,7 @@ unsigned mite_get_status(struct mite_cha
 			mite->mite_io_addr + MITE_CHOR(mite_chan->channel));
 	}
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&mite->lock, flags);
+	spin_unlock_irqrestore(&mite->lock, flags);
 	return status;
 }
 
@@ -621,9 +621,9 @@ int mite_done(struct mite_channel *mite_
 	int done;
 
 	mite_get_status(mite_chan);
-	comedi_spin_lock_irqsave(&mite->lock, flags);
+	spin_lock_irqsave(&mite->lock, flags);
 	done = mite_chan->done;
-	comedi_spin_unlock_irqrestore(&mite->lock, flags);
+	spin_unlock_irqrestore(&mite->lock, flags);
 	return done;
 }
 
--- a/drivers/staging/comedi/drivers/mite.h
+++ b/drivers/staging/comedi/drivers/mite.h
@@ -405,7 +405,7 @@ static inline int CR_RL(unsigned int ret
 		value++;
 	}
 	if (value > 0x7)
-		rt_printk("comedi: bug! retry_limit too large\n");
+		printk("comedi: bug! retry_limit too large\n");
 	return (value & 0x7) << 21;
 }
 
--- a/drivers/staging/comedi/drivers/mpc624.c
+++ b/drivers/staging/comedi/drivers/mpc624.c
@@ -166,9 +166,9 @@ static int mpc624_attach(struct comedi_d
 	unsigned long iobase;
 
 	iobase = it->options[0];
-	rt_printk("comedi%d: mpc624 [0x%04lx, ", dev->minor, iobase);
+	printk("comedi%d: mpc624 [0x%04lx, ", dev->minor, iobase);
 	if (request_region(iobase, MPC624_SIZE, "mpc624") == NULL) {
-		rt_printk("I/O port(s) in use\n");
+		printk("I/O port(s) in use\n");
 		return -EIO;
 	}
 
@@ -182,46 +182,46 @@ static int mpc624_attach(struct comedi_d
 	switch (it->options[1]) {
 	case 0:
 		devpriv->ulConvertionRate = MPC624_SPEED_3_52_kHz;
-		rt_printk("3.52 kHz, ");
+		printk("3.52 kHz, ");
 		break;
 	case 1:
 		devpriv->ulConvertionRate = MPC624_SPEED_1_76_kHz;
-		rt_printk("1.76 kHz, ");
+		printk("1.76 kHz, ");
 		break;
 	case 2:
 		devpriv->ulConvertionRate = MPC624_SPEED_880_Hz;
-		rt_printk("880 Hz, ");
+		printk("880 Hz, ");
 		break;
 	case 3:
 		devpriv->ulConvertionRate = MPC624_SPEED_440_Hz;
-		rt_printk("440 Hz, ");
+		printk("440 Hz, ");
 		break;
 	case 4:
 		devpriv->ulConvertionRate = MPC624_SPEED_220_Hz;
-		rt_printk("220 Hz, ");
+		printk("220 Hz, ");
 		break;
 	case 5:
 		devpriv->ulConvertionRate = MPC624_SPEED_110_Hz;
-		rt_printk("110 Hz, ");
+		printk("110 Hz, ");
 		break;
 	case 6:
 		devpriv->ulConvertionRate = MPC624_SPEED_55_Hz;
-		rt_printk("55 Hz, ");
+		printk("55 Hz, ");
 		break;
 	case 7:
 		devpriv->ulConvertionRate = MPC624_SPEED_27_5_Hz;
-		rt_printk("27.5 Hz, ");
+		printk("27.5 Hz, ");
 		break;
 	case 8:
 		devpriv->ulConvertionRate = MPC624_SPEED_13_75_Hz;
-		rt_printk("13.75 Hz, ");
+		printk("13.75 Hz, ");
 		break;
 	case 9:
 		devpriv->ulConvertionRate = MPC624_SPEED_6_875_Hz;
-		rt_printk("6.875 Hz, ");
+		printk("6.875 Hz, ");
 		break;
 	default:
-		rt_printk
+		printk
 			("illegal convertion rate setting! Valid numbers are 0..9. Using 9 => 6.875 Hz, ");
 		devpriv->ulConvertionRate = MPC624_SPEED_3_52_kHz;
 	}
@@ -237,29 +237,29 @@ static int mpc624_attach(struct comedi_d
 	switch (it->options[1]) {
 	default:
 		s->maxdata = 0x3FFFFFFF;
-		rt_printk("30 bit, ");
+		printk("30 bit, ");
 	}
 
 	switch (it->options[1]) {
 	case 0:
 		s->range_table = &range_mpc624_bipolar1;
-		rt_printk("1.01V]: ");
+		printk("1.01V]: ");
 		break;
 	default:
 		s->range_table = &range_mpc624_bipolar10;
-		rt_printk("10.1V]: ");
+		printk("10.1V]: ");
 	}
 	s->len_chanlist = 1;
 	s->insn_read = mpc624_ai_rinsn;
 
-	rt_printk("attached\n");
+	printk("attached\n");
 
 	return 1;
 }
 
 static int mpc624_detach(struct comedi_device *dev)
 {
-	rt_printk("comedi%d: mpc624: remove\n", dev->minor);
+	printk("comedi%d: mpc624: remove\n", dev->minor);
 
 	if (dev->iobase)
 		release_region(dev->iobase, MPC624_SIZE);
@@ -279,48 +279,48 @@ static int mpc624_ai_rinsn(struct comedi
 
 	/*  WARNING: We always write 0 to GNSWA bit, so the channel range is +-/10.1Vdc */
 	outb(insn->chanspec, dev->iobase + MPC624_GNMUXCH);
-/* rt_printk("Channel %d: \n", insn->chanspec); */
+/* printk("Channel %d: \n", insn->chanspec); */
 	if (!insn->n) {
-		rt_printk("MPC624: Warning, no data to aquire\n");
+		printk("MPC624: Warning, no data to aquire\n");
 		return 0;
 	}
 
 	for (n = 0; n < insn->n; n++) {
 		/*  Trigger the convertion */
 		outb(MPC624_ADSCK, dev->iobase + MPC624_ADC);
-		comedi_udelay(1);
+		udelay(1);
 		outb(MPC624_ADCS | MPC624_ADSCK, dev->iobase + MPC624_ADC);
-		comedi_udelay(1);
+		udelay(1);
 		outb(0, dev->iobase + MPC624_ADC);
-		comedi_udelay(1);
+		udelay(1);
 
 		/*  Wait for the convertion to end */
 		for (i = 0; i < TIMEOUT; i++) {
 			ucPort = inb(dev->iobase + MPC624_ADC);
 			if (ucPort & MPC624_ADBUSY)
-				comedi_udelay(1000);
+				udelay(1000);
 			else
 				break;
 		}
 		if (i == TIMEOUT) {
-			rt_printk("MPC624: timeout (%dms)\n", TIMEOUT);
+			printk("MPC624: timeout (%dms)\n", TIMEOUT);
 			data[n] = 0;
 			return -ETIMEDOUT;
 		}
 		/*  Start reading data */
 		data_in = 0;
 		data_out = devpriv->ulConvertionRate;
-		comedi_udelay(1);
+		udelay(1);
 		for (i = 0; i < 32; i++) {
 			/*  Set the clock low */
 			outb(0, dev->iobase + MPC624_ADC);
-			comedi_udelay(1);
+			udelay(1);
 
 			if (data_out & (1 << 31))	/*  the next bit is a 1 */
 			{
 				/*  Set the ADSDI line (send to MPC624) */
 				outb(MPC624_ADSDI, dev->iobase + MPC624_ADC);
-				comedi_udelay(1);
+				udelay(1);
 				/*  Set the clock high */
 				outb(MPC624_ADSCK | MPC624_ADSDI,
 					dev->iobase + MPC624_ADC);
@@ -328,17 +328,17 @@ static int mpc624_ai_rinsn(struct comedi
 			{
 				/*  Set the ADSDI line (send to MPC624) */
 				outb(0, dev->iobase + MPC624_ADC);
-				comedi_udelay(1);
+				udelay(1);
 				/*  Set the clock high */
 				outb(MPC624_ADSCK, dev->iobase + MPC624_ADC);
 			}
 			/*  Read ADSDO on high clock (receive from MPC624) */
-			comedi_udelay(1);
+			udelay(1);
 			data_in <<= 1;
 			data_in |=
 				(inb(dev->iobase +
 					MPC624_ADC) & MPC624_ADSDO) >> 4;
-			comedi_udelay(1);
+			udelay(1);
 
 			data_out <<= 1;
 		}
@@ -357,10 +357,10 @@ static int mpc624_ai_rinsn(struct comedi
 		/*    00: sub-LSB */
 
 		if (data_in & MPC624_EOC_BIT)
-			rt_printk("MPC624: EOC bit is set (data_in=%lu)!",
+			printk("MPC624: EOC bit is set (data_in=%lu)!",
 				data_in);
 		if (data_in & MPC624_DMY_BIT)
-			rt_printk("MPC624: DMY bit is set (data_in=%lu)!",
+			printk("MPC624: DMY bit is set (data_in=%lu)!",
 				data_in);
 		if (data_in & MPC624_SGN_BIT)	/*  check the sign bit */
 		{		/*  The voltage is positive */
--- a/drivers/staging/comedi/drivers/ni_6527.c
+++ b/drivers/staging/comedi/drivers/ni_6527.c
@@ -432,8 +432,8 @@ static int ni6527_attach(struct comedi_d
 		devpriv->mite->daq_io_addr + Clear_Register);
 	writeb(0x00, devpriv->mite->daq_io_addr + Master_Interrupt_Control);
 
-	ret = comedi_request_irq(mite_irq(devpriv->mite), ni6527_interrupt,
-		IRQF_SHARED, "ni6527", dev);
+	ret = request_irq(mite_irq(devpriv->mite), ni6527_interrupt,
+			  IRQF_SHARED, "ni6527", dev);
 	if (ret < 0) {
 		printk(" irq not available");
 	} else
@@ -452,7 +452,7 @@ static int ni6527_detach(struct comedi_d
 	}
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 
 	if (devpriv && devpriv->mite) {
--- a/drivers/staging/comedi/drivers/ni_65xx.c
+++ b/drivers/staging/comedi/drivers/ni_65xx.c
@@ -437,12 +437,12 @@ static int ni_65xx_dio_insn_bits(struct 
 			writeb(bits,
 				private(dev)->mite->daq_io_addr +
 				Port_Data(port));
-/* rt_printk("wrote 0x%x to port %i\n", bits, port); */
+/* printk("wrote 0x%x to port %i\n", bits, port); */
 		}
 		port_read_bits =
 			readb(private(dev)->mite->daq_io_addr +
 			Port_Data(port));
-/* rt_printk("read 0x%x from port %i\n", port_read_bits, port); */
+/* printk("read 0x%x from port %i\n", port_read_bits, port); */
 		if (bitshift > 0) {
 			port_read_bits <<= bitshift;
 		} else {
@@ -742,8 +742,8 @@ static int ni_65xx_attach(struct comedi_
 	/* Set filter interval to 0  (32bit reg) */
 	writeb(0x00000000, private(dev)->mite->daq_io_addr + Filter_Interval);
 
-	ret = comedi_request_irq(dev->irq, ni_65xx_interrupt, IRQF_SHARED,
-		"ni_65xx", dev);
+	ret = request_irq(dev->irq, ni_65xx_interrupt, IRQF_SHARED,
+			  "ni_65xx", dev);
 	if (ret < 0) {
 		dev->irq = 0;
 		printk(" irq not available");
@@ -764,7 +764,7 @@ static int ni_65xx_detach(struct comedi_
 	}
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 
 	if (private(dev)) {
--- a/drivers/staging/comedi/drivers/ni_660x.c
+++ b/drivers/staging/comedi/drivers/ni_660x.c
@@ -695,7 +695,7 @@ static enum NI_660x_Register ni_gpct_to_
 		ni_660x_register = G3InterruptEnable;
 		break;
 	default:
-		rt_printk("%s: unhandled register 0x%x in switch.\n",
+		printk("%s: unhandled register 0x%x in switch.\n",
 			__func__, reg);
 		BUG();
 		return 0;
@@ -719,7 +719,7 @@ static inline void ni_660x_write_registe
 		writel(bits, write_address);
 		break;
 	default:
-		rt_printk("%s: %s: bug! unhandled case (reg=0x%x) in switch.\n",
+		printk("%s: %s: bug! unhandled case (reg=0x%x) in switch.\n",
 			__FILE__, __func__, reg);
 		BUG();
 		break;
@@ -741,7 +741,7 @@ static inline unsigned ni_660x_read_regi
 		return readl(read_address);
 		break;
 	default:
-		rt_printk("%s: %s: bug! unhandled case (reg=0x%x) in switch.\n",
+		printk("%s: %s: bug! unhandled case (reg=0x%x) in switch.\n",
 			__FILE__, __func__, reg);
 		BUG();
 		break;
@@ -777,7 +777,7 @@ static inline void ni_660x_set_dma_chann
 	unsigned mite_channel, struct ni_gpct *counter)
 {
 	unsigned long flags;
-	comedi_spin_lock_irqsave(&private(dev)->soft_reg_copy_lock, flags);
+	spin_lock_irqsave(&private(dev)->soft_reg_copy_lock, flags);
 	private(dev)->dma_configuration_soft_copies[counter->chip_index] &=
 		~dma_select_mask(mite_channel);
 	private(dev)->dma_configuration_soft_copies[counter->chip_index] |=
@@ -788,14 +788,14 @@ static inline void ni_660x_set_dma_chann
 			chip_index] | dma_reset_bit(mite_channel),
 		DMAConfigRegister);
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&private(dev)->soft_reg_copy_lock, flags);
+	spin_unlock_irqrestore(&private(dev)->soft_reg_copy_lock, flags);
 }
 
 static inline void ni_660x_unset_dma_channel(struct comedi_device *dev,
 	unsigned mite_channel, struct ni_gpct *counter)
 {
 	unsigned long flags;
-	comedi_spin_lock_irqsave(&private(dev)->soft_reg_copy_lock, flags);
+	spin_lock_irqsave(&private(dev)->soft_reg_copy_lock, flags);
 	private(dev)->dma_configuration_soft_copies[counter->chip_index] &=
 		~dma_select_mask(mite_channel);
 	private(dev)->dma_configuration_soft_copies[counter->chip_index] |=
@@ -804,7 +804,7 @@ static inline void ni_660x_unset_dma_cha
 		private(dev)->dma_configuration_soft_copies[counter->
 			chip_index], DMAConfigRegister);
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&private(dev)->soft_reg_copy_lock, flags);
+	spin_unlock_irqrestore(&private(dev)->soft_reg_copy_lock, flags);
 }
 
 static int ni_660x_request_mite_channel(struct comedi_device *dev,
@@ -813,13 +813,13 @@ static int ni_660x_request_mite_channel(
 	unsigned long flags;
 	struct mite_channel *mite_chan;
 
-	comedi_spin_lock_irqsave(&private(dev)->mite_channel_lock, flags);
+	spin_lock_irqsave(&private(dev)->mite_channel_lock, flags);
 	BUG_ON(counter->mite_chan);
 	mite_chan =
 		mite_request_channel(private(dev)->mite, mite_ring(private(dev),
 			counter));
 	if (mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&private(dev)->mite_channel_lock,
+		spin_unlock_irqrestore(&private(dev)->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for counter.");
@@ -828,7 +828,7 @@ static int ni_660x_request_mite_channel(
 	mite_chan->dir = direction;
 	ni_tio_set_mite_channel(counter, mite_chan);
 	ni_660x_set_dma_channel(dev, mite_chan->channel, counter);
-	comedi_spin_unlock_irqrestore(&private(dev)->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&private(dev)->mite_channel_lock, flags);
 	return 0;
 }
 
@@ -836,7 +836,7 @@ void ni_660x_release_mite_channel(struct
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&private(dev)->mite_channel_lock, flags);
+	spin_lock_irqsave(&private(dev)->mite_channel_lock, flags);
 	if (counter->mite_chan) {
 		struct mite_channel *mite_chan = counter->mite_chan;
 
@@ -844,7 +844,7 @@ void ni_660x_release_mite_channel(struct
 		ni_tio_set_mite_channel(counter, NULL);
 		mite_release_channel(mite_chan);
 	}
-	comedi_spin_unlock_irqrestore(&private(dev)->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&private(dev)->mite_channel_lock, flags);
 }
 
 static int ni_660x_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -921,13 +921,13 @@ static irqreturn_t ni_660x_interrupt(int
 	if (dev->attached == 0)
 		return IRQ_NONE;
 	/* lock to avoid race with comedi_poll */
-	comedi_spin_lock_irqsave(&private(dev)->interrupt_lock, flags);
+	spin_lock_irqsave(&private(dev)->interrupt_lock, flags);
 	smp_mb();
 	for (i = 0; i < ni_660x_num_counters(dev); ++i) {
 		s = dev->subdevices + NI_660X_GPCT_SUBDEV(i);
 		ni_660x_handle_gpct_interrupt(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&private(dev)->interrupt_lock, flags);
+	spin_unlock_irqrestore(&private(dev)->interrupt_lock, flags);
 	return IRQ_HANDLED;
 }
 
@@ -936,9 +936,9 @@ static int ni_660x_input_poll(struct com
 {
 	unsigned long flags;
 	/* lock to avoid race with comedi_poll */
-	comedi_spin_lock_irqsave(&private(dev)->interrupt_lock, flags);
+	spin_lock_irqsave(&private(dev)->interrupt_lock, flags);
 	mite_sync_input_dma(subdev_to_counter(s)->mite_chan, s->async);
-	comedi_spin_unlock_irqrestore(&private(dev)->interrupt_lock, flags);
+	spin_unlock_irqrestore(&private(dev)->interrupt_lock, flags);
 	return comedi_buf_read_n_available(s->async);
 }
 
@@ -1107,10 +1107,8 @@ static int ni_660x_attach(struct comedi_
 	for (i = 0; i < board(dev)->n_chips; ++i) {
 		set_tio_counterswap(dev, i);
 	}
-	ret = comedi_request_irq(mite_irq(private(dev)->mite),
-				 ni_660x_interrupt, IRQF_SHARED, "ni_660x",
-				 dev);
-
+	ret = request_irq(mite_irq(private(dev)->mite), ni_660x_interrupt,
+			  IRQF_SHARED, "ni_660x", dev);
 	if (ret < 0) {
 		printk(" irq not available\n");
 		return ret;
@@ -1131,7 +1129,7 @@ static int ni_660x_detach(struct comedi_
 
 	/* Free irq */
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (dev->private) {
 		if (private(dev)->counter_dev)
--- a/drivers/staging/comedi/drivers/ni_670x.c
+++ b/drivers/staging/comedi/drivers/ni_670x.c
@@ -217,7 +217,7 @@ static int ni_670x_detach(struct comedi_
 		mite_unsetup(devpriv->mite);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -201,9 +201,9 @@ COMEDI_INITCLEANUP(driver_a2150);
 
 static void ni_dump_regs(struct comedi_device *dev)
 {
-	rt_printk("config bits 0x%x\n", devpriv->config_bits);
-	rt_printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
-	rt_printk("status bits 0x%x\n", inw(dev->iobase + STATUS_REG));
+	printk("config bits 0x%x\n", devpriv->config_bits);
+	printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
+	printk("status bits 0x%x\n", inw(dev->iobase + STATUS_REG));
 }
 
 #endif
@@ -370,7 +370,7 @@ static int a2150_attach(struct comedi_de
 			printk(" invalid irq line %u\n", irq);
 			return -EINVAL;
 		}
-		if (comedi_request_irq(irq, a2150_interrupt, 0,
+		if (request_irq(irq, a2150_interrupt, 0,
 				driver_a2150.driver_name, dev)) {
 			printk("unable to allocate irq %u\n", irq);
 			return -EINVAL;
@@ -437,7 +437,7 @@ static int a2150_attach(struct comedi_de
 	for (i = 0; i < timeout; i++) {
 		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
 			break;
-		comedi_udelay(1000);
+		udelay(1000);
 	}
 	if (i == timeout) {
 		printk(" timed out waiting for offset calibration to complete\n");
@@ -461,7 +461,7 @@ static int a2150_detach(struct comedi_de
 	}
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (devpriv) {
 		if (devpriv->dma)
 			free_dma(devpriv->dma);
@@ -764,7 +764,7 @@ static int a2150_ai_rinsn(struct comedi_
 		for (i = 0; i < timeout; i++) {
 			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (i == timeout) {
 			comedi_error(dev, "timeout");
@@ -778,7 +778,7 @@ static int a2150_ai_rinsn(struct comedi_
 		for (i = 0; i < timeout; i++) {
 			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (i == timeout) {
 			comedi_error(dev, "timeout");
@@ -789,7 +789,7 @@ static int a2150_ai_rinsn(struct comedi_
 #endif
 		data[n] = inw(dev->iobase + FIFO_DATA_REG);
 #ifdef A2150_DEBUG
-		rt_printk(" data is %i\n", data[n]);
+		printk(" data is %i\n", data[n]);
 #endif
 		data[n] ^= 0x8000;
 	}
--- a/drivers/staging/comedi/drivers/ni_atmio16d.c
+++ b/drivers/staging/comedi/drivers/ni_atmio16d.c
@@ -579,7 +579,7 @@ static int atmio16d_ai_insn_read(struct 
 		}
 		/* end waiting, now check if it timed out */
 		if (t == ATMIO16D_TIMEOUT) {
-			rt_printk("atmio16d: timeout\n");
+			printk("atmio16d: timeout\n");
 
 			return -ETIME;
 		}
@@ -743,8 +743,7 @@ static int atmio16d_attach(struct comedi
 	irq = it->options[1];
 	if (irq) {
 
-		ret = comedi_request_irq(irq, atmio16d_interrupt,
-					  0, "atmio16d", dev);
+		ret = request_irq(irq, atmio16d_interrupt, 0, "atmio16d", dev);
 		if (ret < 0) {
 			printk("failed to allocate irq %u\n", irq);
 			return ret;
@@ -856,7 +855,7 @@ static int atmio16d_detach(struct comedi
 		subdev_8255_cleanup(dev, dev->subdevices + 3);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	reset_atmio16d(dev);
 
--- a/drivers/staging/comedi/drivers/ni_atmio.c
+++ b/drivers/staging/comedi/drivers/ni_atmio.c
@@ -301,14 +301,14 @@ static void ni_atmio_win_out(struct come
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	if ((addr) < 8) {
 		ni_writew(data, addr * 2);
 	} else {
 		ni_writew(addr, Window_Address);
 		ni_writew(data, Window_Data);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
 static uint16_t ni_atmio_win_in(struct comedi_device *dev, int addr)
@@ -316,14 +316,14 @@ static uint16_t ni_atmio_win_in(struct c
 	unsigned long flags;
 	uint16_t ret;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	if (addr < 8) {
 		ret = ni_readw(addr * 2);
 	} else {
 		ni_writew(addr, Window_Address);
 		ret = ni_readw(Window_Data);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 
 	return ret;
 }
@@ -362,7 +362,7 @@ static int ni_atmio_detach(struct comedi
 	if (dev->iobase)
 		release_region(dev->iobase, NI_SIZE);
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (devpriv->isapnp_dev)
 		pnp_device_detach(devpriv->isapnp_dev);
@@ -478,8 +478,8 @@ static int ni_atmio_attach(struct comedi
 			return -EINVAL;
 		}
 		printk(" ( irq = %u )", irq);
-		ret = comedi_request_irq(irq, ni_E_interrupt,
-					  NI_E_IRQ_FLAGS, "ni_atmio", dev);
+		ret = request_irq(irq, ni_E_interrupt, NI_E_IRQ_FLAGS,
+				  "ni_atmio", dev);
 
 		if (ret < 0) {
 			printk(" irq not available\n");
--- a/drivers/staging/comedi/drivers/ni_daq_700.c
+++ b/drivers/staging/comedi/drivers/ni_daq_700.c
@@ -425,7 +425,7 @@ static int dio700_detach(struct comedi_d
 	if (thisboard->bustype != pcmcia_bustype && dev->iobase)
 		release_region(dev->iobase, DIO700_SIZE);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	return 0;
 };
--- a/drivers/staging/comedi/drivers/ni_daq_dio24.c
+++ b/drivers/staging/comedi/drivers/ni_daq_dio24.c
@@ -182,7 +182,7 @@ static int dio24_detach(struct comedi_de
 	if (thisboard->bustype != pcmcia_bustype && dev->iobase)
 		release_region(dev->iobase, DIO24_SIZE);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	return 0;
 };
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -516,7 +516,7 @@ int labpc_common_attach(struct comedi_de
 		isr_flags = 0;
 		if (thisboard->bustype == pci_bustype)
 			isr_flags |= IRQF_SHARED;
-		if (comedi_request_irq(irq, labpc_interrupt, isr_flags,
+		if (request_irq(irq, labpc_interrupt, isr_flags,
 				driver_labpc.driver_name, dev)) {
 			printk("unable to allocate irq %u\n", irq);
 			return -EINVAL;
@@ -737,7 +737,7 @@ int labpc_common_detach(struct comedi_de
 	if (devpriv->dma_chan)
 		free_dma(devpriv->dma_chan);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (thisboard->bustype == isa_bustype && dev->iobase)
 		release_region(dev->iobase, LABPC_SIZE);
 #ifdef CONFIG_COMEDI_PCI
@@ -759,10 +759,10 @@ static int labpc_cancel(struct comedi_de
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
@@ -788,7 +788,7 @@ static enum scan_mode labpc_ai_scan_mode
 	if (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))
 		return MODE_MULT_CHAN_DOWN;
 
-	rt_printk("ni_labpc: bug! this should never happen\n");
+	printk("ni_labpc: bug! this should never happen\n");
 
 	return 0;
 }
@@ -844,7 +844,7 @@ static int labpc_ai_chanlist_invalid(con
 			}
 			break;
 		default:
-			rt_printk("ni_labpc: bug! in chanlist check\n");
+			printk("ni_labpc: bug! in chanlist check\n");
 			return 1;
 			break;
 		}
@@ -1082,10 +1082,10 @@ static int labpc_ai_cmd(struct comedi_de
 	aref = CR_AREF(cmd->chanlist[0]);
 
 	/*  make sure board is disabled before setting up aquisition */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
@@ -1174,7 +1174,7 @@ static int labpc_ai_cmd(struct comedi_de
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
 		/* need a brief delay before enabling scan, or scan list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command1_bits,
 			dev->iobase + COMMAND1_REG);
 	}
@@ -1275,7 +1275,7 @@ static int labpc_ai_cmd(struct comedi_de
 
 	/*  command2 reg */
 	/*  use 2 cascaded counters for pacing */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits |= CASCADE_BIT;
 	switch (cmd->start_src) {
 	case TRIG_EXT:
@@ -1303,7 +1303,7 @@ static int labpc_ai_cmd(struct comedi_de
 		return -1;
 	}
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
 }
@@ -1510,10 +1510,10 @@ static int labpc_ai_rinsn(struct comedi_
 	unsigned long flags;
 
 	/*  disable timed conversions */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  disable interrupt generation and dma */
 	devpriv->command3_bits = 0;
@@ -1571,7 +1571,7 @@ static int labpc_ai_rinsn(struct comedi_
 			if (devpriv->read_byte(dev->iobase +
 					STATUS1_REG) & DATA_AVAIL_BIT)
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (i == timeout) {
 			comedi_error(dev, "timeout");
@@ -1598,10 +1598,10 @@ static int labpc_ao_winsn(struct comedi_
 	/*  turn off pacing of analog output channel */
 	/* note: hardware bug in daqcard-1200 means pacing cannot
 	 * be independently enabled/disabled for its the two channels */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~DAC_PACED_BIT(channel);
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set range */
 	if (thisboard->register_layout == labpc_1200_layout) {
@@ -1809,12 +1809,12 @@ static void labpc_serial_out(struct come
 			devpriv->command5_bits |= SDATA_BIT;
 		else
 			devpriv->command5_bits &= ~SDATA_BIT;
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
 		/*  set clock to load bit */
 		devpriv->command5_bits |= SCLOCK_BIT;
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
 	}
@@ -1830,16 +1830,16 @@ static unsigned int labpc_serial_in(stru
 	for (i = 1; i <= value_width; i++) {
 		/*  set serial clock */
 		devpriv->command5_bits |= SCLOCK_BIT;
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
 		/*  clear clock bit */
 		devpriv->command5_bits &= ~SCLOCK_BIT;
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
 		/*  read bits most significant bit first */
-		comedi_udelay(1);
+		udelay(1);
 		devpriv->status2_bits =
 			devpriv->read_byte(dev->iobase + STATUS2_REG);
 		if (devpriv->status2_bits & EEPROM_OUT_BIT) {
@@ -1858,10 +1858,10 @@ static unsigned int labpc_eeprom_read(st
 
 	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  send read instruction */
@@ -1873,7 +1873,7 @@ static unsigned int labpc_eeprom_read(st
 
 	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	return value;
@@ -1904,21 +1904,21 @@ static unsigned int labpc_eeprom_write(s
 
 	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  send write_enable instruction */
 	labpc_serial_out(dev, write_enable_instruction, write_length);
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  send write instruction */
 	devpriv->command5_bits |= EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	labpc_serial_out(dev, write_instruction, write_length);
 	/*  send 8 bit address to write to */
@@ -1926,12 +1926,12 @@ static unsigned int labpc_eeprom_write(s
 	/*  write value */
 	labpc_serial_out(dev, value, write_length);
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	return 0;
@@ -1945,10 +1945,10 @@ static unsigned int labpc_eeprom_read_st
 
 	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	devpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  send read status instruction */
@@ -1958,7 +1958,7 @@ static unsigned int labpc_eeprom_read_st
 
 	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	return value;
@@ -1975,7 +1975,7 @@ static void write_caldac(struct comedi_d
 	/*  clear caldac load bit and make sure we don't write to eeprom */
 	devpriv->command5_bits &=
 		~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
 	/*  write 4 bit channel */
@@ -1985,10 +1985,10 @@ static void write_caldac(struct comedi_d
 
 	/*  set and clear caldac bit to load caldac value */
 	devpriv->command5_bits |= CALDAC_LOAD_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	devpriv->command5_bits &= ~CALDAC_LOAD_BIT;
-	comedi_udelay(1);
+	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 }
 
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -365,7 +365,7 @@ static inline void ni_set_bitfield(struc
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
+	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
 	switch (reg) {
 	case Interrupt_A_Enable_Register:
 		devpriv->int_a_enable_reg &= ~bit_mask;
@@ -396,13 +396,13 @@ static inline void ni_set_bitfield(struc
 		ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
 		break;
 	default:
-		rt_printk("Warning %s() called with invalid register\n",
+		printk("Warning %s() called with invalid register\n",
 			__func__);
-		rt_printk("reg is %d\n", reg);
+		printk("reg is %d\n", reg);
 		break;
 	}
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
+	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
 
 #ifdef PCIDMA
@@ -460,7 +460,7 @@ static inline void ni_set_cdo_dma_channe
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
+	spin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);
 	devpriv->cdio_dma_select_reg &= ~CDO_DMA_Select_Mask;
 	if (mite_channel >= 0) {
 		/*XXX just guessing ni_stc_dma_channel_select_bitfield() returns the right bits,
@@ -472,19 +472,19 @@ static inline void ni_set_cdo_dma_channe
 	}
 	ni_writeb(devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
+	spin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);
 }
 
 static int ni_request_ai_mite_channel(struct comedi_device *dev)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->ai_mite_chan);
 	devpriv->ai_mite_chan =
 		mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
 	if (devpriv->ai_mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for analog input.");
@@ -492,7 +492,7 @@ static int ni_request_ai_mite_channel(st
 	}
 	devpriv->ai_mite_chan->dir = COMEDI_INPUT;
 	ni_set_ai_dma_channel(dev, devpriv->ai_mite_chan->channel);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
 
@@ -500,12 +500,12 @@ static int ni_request_ao_mite_channel(st
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->ao_mite_chan);
 	devpriv->ao_mite_chan =
 		mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
 	if (devpriv->ao_mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for analog outut.");
@@ -513,7 +513,7 @@ static int ni_request_ao_mite_channel(st
 	}
 	devpriv->ao_mite_chan->dir = COMEDI_OUTPUT;
 	ni_set_ao_dma_channel(dev, devpriv->ao_mite_chan->channel);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
 
@@ -524,13 +524,13 @@ static int ni_request_gpct_mite_channel(
 	struct mite_channel *mite_chan;
 
 	BUG_ON(gpct_index >= NUM_GPCT);
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->counter_dev->counters[gpct_index].mite_chan);
 	mite_chan =
 		mite_request_channel(devpriv->mite,
 		devpriv->gpct_mite_ring[gpct_index]);
 	if (mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for counter.");
@@ -540,7 +540,7 @@ static int ni_request_gpct_mite_channel(
 	ni_tio_set_mite_channel(&devpriv->counter_dev->counters[gpct_index],
 		mite_chan);
 	ni_set_gpct_dma_channel(dev, gpct_index, mite_chan->channel);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
 
@@ -551,12 +551,12 @@ static int ni_request_cdo_mite_channel(s
 #ifdef PCIDMA
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->cdo_mite_chan);
 	devpriv->cdo_mite_chan =
 		mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
 	if (devpriv->cdo_mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
 			flags);
 		comedi_error(dev,
 			"failed to reserve mite dma channel for correlated digital outut.");
@@ -564,7 +564,7 @@ static int ni_request_cdo_mite_channel(s
 	}
 	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
 	ni_set_cdo_dma_channel(dev, devpriv->cdo_mite_chan->channel);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 	return 0;
 }
@@ -574,13 +574,13 @@ static void ni_release_ai_mite_channel(s
 #ifdef PCIDMA
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan) {
 		ni_set_ai_dma_channel(dev, -1);
 		mite_release_channel(devpriv->ai_mite_chan);
 		devpriv->ai_mite_chan = NULL;
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 }
 
@@ -589,13 +589,13 @@ static void ni_release_ao_mite_channel(s
 #ifdef PCIDMA
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
 		ni_set_ao_dma_channel(dev, -1);
 		mite_release_channel(devpriv->ao_mite_chan);
 		devpriv->ao_mite_chan = NULL;
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 }
 
@@ -605,7 +605,7 @@ void ni_release_gpct_mite_channel(struct
 	unsigned long flags;
 
 	BUG_ON(gpct_index >= NUM_GPCT);
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->counter_dev->counters[gpct_index].mite_chan) {
 		struct mite_channel *mite_chan =
 			devpriv->counter_dev->counters[gpct_index].mite_chan;
@@ -615,7 +615,7 @@ void ni_release_gpct_mite_channel(struct
 			counters[gpct_index], NULL);
 		mite_release_channel(mite_chan);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 }
 
@@ -624,13 +624,13 @@ static void ni_release_cdo_mite_channel(
 #ifdef PCIDMA
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		ni_set_cdo_dma_channel(dev, -1);
 		mite_release_channel(devpriv->cdo_mite_chan);
 		devpriv->cdo_mite_chan = NULL;
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif /*  PCIDMA */
 }
 
@@ -712,20 +712,20 @@ static inline void ni_ao_win_outw(struct
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	ni_writew(addr, AO_Window_Address_611x);
 	ni_writew(data, AO_Window_Data_611x);
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
 static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data, int addr)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	ni_writew(addr, AO_Window_Address_611x);
 	ni_writel(data, AO_Window_Data_611x);
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
 static inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)
@@ -733,10 +733,10 @@ static inline unsigned short ni_ao_win_i
 	unsigned long flags;
 	unsigned short data;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	ni_writew(addr, AO_Window_Address_611x);
 	data = ni_readw(AO_Window_Data_611x);
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 	return data;
 }
 
@@ -779,15 +779,14 @@ static irqreturn_t ni_E_interrupt(int ir
 	smp_mb();		/*  make sure dev->attached is checked before handler does anything else. */
 
 	/*  lock to avoid race with comedi_poll */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	a_status = devpriv->stc_readw(dev, AI_Status_1_Register);
 	b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
 #ifdef PCIDMA
 	if (mite) {
 		unsigned long flags_too;
 
-		comedi_spin_lock_irqsave(&devpriv->mite_channel_lock,
-			flags_too);
+		spin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);
 		if (devpriv->ai_mite_chan) {
 			ai_mite_status = mite_get_status(devpriv->ai_mite_chan);
 			if (ai_mite_status & CHSR_LINKC)
@@ -804,8 +803,7 @@ static irqreturn_t ni_E_interrupt(int ir
 					MITE_CHOR(devpriv->ao_mite_chan->
 						channel));
 		}
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags_too);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
 	}
 #endif
 	ack_a_interrupt(dev, a_status);
@@ -818,7 +816,7 @@ static irqreturn_t ni_E_interrupt(int ir
 	handle_gpct_interrupt(dev, 1);
 	handle_cdio_interrupt(dev);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
 }
 
@@ -828,10 +826,10 @@ static void ni_sync_ai_dma(struct comedi
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan)
 		mite_sync_input_dma(devpriv->ai_mite_chan, s->async);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
 static void mite_handle_b_linkc(struct mite_struct *mite, struct comedi_device * dev)
@@ -839,11 +837,11 @@ static void mite_handle_b_linkc(struct m
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
 		mite_sync_output_dma(devpriv->ao_mite_chan, s->async);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
 static int ni_ao_wait_for_dma_load(struct comedi_device *dev)
@@ -858,7 +856,7 @@ static int ni_ao_wait_for_dma_load(struc
 			break;
 		/* if we poll too often, the pci bus activity seems
 		   to slow the dma transfer down */
-		comedi_udelay(10);
+		udelay(10);
 	}
 	if (i == timeout) {
 		comedi_error(dev, "timed out waiting for dma load");
@@ -879,7 +877,7 @@ static void ni_handle_eos(struct comedi_
 			ni_sync_ai_dma(dev);
 			if ((s->async->events & COMEDI_CB_EOS))
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 #else
 		ni_handle_fifo_dregs(dev);
@@ -976,7 +974,7 @@ static void handle_a_interrupt(struct co
 		return;
 
 #ifdef DEBUG_INTERRUPT
-	rt_printk
+	printk
 		("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
 		status, ai_mite_status);
 	ni_mio_print_status_a(status);
@@ -989,7 +987,7 @@ static void handle_a_interrupt(struct co
 	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
 			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
-		rt_printk
+		printk
 			("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
 			ai_mite_status);
 		/* mite_print_chsr(ai_mite_status); */
@@ -1002,7 +1000,7 @@ static void handle_a_interrupt(struct co
 	if (status & (AI_Overrun_St | AI_Overflow_St | AI_SC_TC_Error_St |
 			AI_SC_TC_St | AI_START1_St)) {
 		if (status == 0xffff) {
-			rt_printk
+			printk
 				("ni_mio_common: a_status=0xffff.  Card removed?\n");
 			/* we probably aren't even running a command now,
 			 * so it's a good idea to be careful. */
@@ -1015,7 +1013,7 @@ static void handle_a_interrupt(struct co
 		}
 		if (status & (AI_Overrun_St | AI_Overflow_St |
 				AI_SC_TC_Error_St)) {
-			rt_printk("ni_mio_common: ai error a_status=%04x\n",
+			printk("ni_mio_common: ai error a_status=%04x\n",
 				status);
 			ni_mio_print_status_a(status);
 
@@ -1031,7 +1029,7 @@ static void handle_a_interrupt(struct co
 		}
 		if (status & AI_SC_TC_St) {
 #ifdef DEBUG_INTERRUPT
-			rt_printk("ni_mio_common: SC_TC interrupt\n");
+			printk("ni_mio_common: SC_TC interrupt\n");
 #endif
 			if (!devpriv->ai_continuous) {
 				shutdown_ai_command(dev);
@@ -1063,7 +1061,7 @@ static void handle_a_interrupt(struct co
 #ifdef DEBUG_INTERRUPT
 	status = devpriv->stc_readw(dev, AI_Status_1_Register);
 	if (status & Interrupt_A_St) {
-		rt_printk
+		printk
 			("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",
 			status);
 	}
@@ -1104,7 +1102,7 @@ static void handle_b_interrupt(struct co
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	/* unsigned short ack=0; */
 #ifdef DEBUG_INTERRUPT
-	rt_printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
+	printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
 		b_status, ao_mite_status);
 	ni_mio_print_status_b(b_status);
 #endif
@@ -1118,7 +1116,7 @@ static void handle_b_interrupt(struct co
 	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
 			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
 			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
-		rt_printk
+		printk
 			("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
 			ao_mite_status);
 		/* mite_print_chsr(ao_mite_status); */
@@ -1129,7 +1127,7 @@ static void handle_b_interrupt(struct co
 	if (b_status == 0xffff)
 		return;
 	if (b_status & AO_Overrun_St) {
-		rt_printk
+		printk
 			("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
 			b_status, devpriv->stc_readw(dev,
 				AO_Status_2_Register));
@@ -1146,7 +1144,7 @@ static void handle_b_interrupt(struct co
 
 		ret = ni_ao_fifo_half_empty(dev, s);
 		if (!ret) {
-			rt_printk("ni_mio_common: AO buffer underrun\n");
+			printk("ni_mio_common: AO buffer underrun\n");
 			ni_set_bits(dev, Interrupt_B_Enable_Register,
 				AO_FIFO_Interrupt_Enable |
 				AO_Error_Interrupt_Enable, 0);
@@ -1170,13 +1168,13 @@ static void ni_mio_print_status_a(int st
 {
 	int i;
 
-	rt_printk("A status:");
+	printk("A status:");
 	for (i = 15; i >= 0; i--) {
 		if (status & (1 << i)) {
-			rt_printk(" %s", status_a_strings[i]);
+			printk(" %s", status_a_strings[i]);
 		}
 	}
-	rt_printk("\n");
+	printk("\n");
 }
 #endif
 
@@ -1192,13 +1190,13 @@ static void ni_mio_print_status_b(int st
 {
 	int i;
 
-	rt_printk("B status:");
+	printk("B status:");
 	for (i = 15; i >= 0; i--) {
 		if (status & (1 << i)) {
-			rt_printk(" %s", status_b_strings[i]);
+			printk(" %s", status_b_strings[i]);
 		}
 	}
-	rt_printk("\n");
+	printk("\n");
 }
 #endif
 
@@ -1383,7 +1381,7 @@ static int ni_ai_drain_dma(struct comedi
 	unsigned long flags;
 	int retval = 0;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ai_mite_chan) {
 		for (i = 0; i < timeout; i++) {
 			if ((devpriv->stc_readw(dev,
@@ -1392,19 +1390,19 @@ static int ni_ai_drain_dma(struct comedi
 				&& mite_bytes_in_transit(devpriv->
 					ai_mite_chan) == 0)
 				break;
-			comedi_udelay(5);
+			udelay(5);
 		}
 		if (i == timeout) {
-			rt_printk
+			printk
 				("ni_mio_common: wait for dma drain timed out\n");
-			rt_printk
+			printk
 				("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
 				mite_bytes_in_transit(devpriv->ai_mite_chan),
 				devpriv->stc_readw(dev, AI_Status_1_Register));
 			retval = -1;
 		}
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 
 	ni_sync_ai_dma(dev);
 
@@ -1548,15 +1546,14 @@ static int ni_ai_setup_MITE_dma(struct c
 	retval = ni_request_ai_mite_channel(dev);
 	if (retval)
 		return retval;
-/* rt_printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel); */
+/* printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel); */
 
 	/* write alloc the entire buffer */
 	comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
-	if (devpriv->ai_mite_chan == NULL)
-	{
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	if (devpriv->ai_mite_chan == NULL) {
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		return -EIO;
 	}
 
@@ -1574,7 +1571,7 @@ static int ni_ai_setup_MITE_dma(struct c
 	};
 	/*start the MITE */
 	mite_dma_arm(devpriv->ai_mite_chan);
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 
 	return 0;
 }
@@ -1592,7 +1589,7 @@ static int ni_ao_setup_MITE_dma(struct c
 	/* read alloc the entire buffer */
 	comedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->ao_mite_chan) {
 		if (boardtype.reg_type & (ni_reg_611x | ni_reg_6713)) {
 			mite_prep_dma(devpriv->ao_mite_chan, 32, 32);
@@ -1604,7 +1601,7 @@ static int ni_ao_setup_MITE_dma(struct c
 		mite_dma_arm(devpriv->ao_mite_chan);
 	} else
 		retval = -EIO;
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 
 	return retval;
 }
@@ -1705,7 +1702,7 @@ static int ni_ai_poll(struct comedi_devi
 
 	/*  lock to avoid race with interrupt handler */
 	if (in_interrupt() == 0)
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 #ifndef PCIDMA
 	ni_handle_fifo_dregs(dev);
 #else
@@ -1713,7 +1710,7 @@ static int ni_ai_poll(struct comedi_devi
 #endif
 	count = s->async->buf_write_count - s->async->buf_read_count;
 	if (in_interrupt() == 0)
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return count;
 }
@@ -1736,7 +1733,7 @@ static int ni_ai_insn_read(struct comedi
 		for (n = 0; n < num_adc_stages_611x; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
 				AI_Command_1_Register);
-			comedi_udelay(1);
+			udelay(1);
 		}
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
@@ -1758,7 +1755,7 @@ static int ni_ai_insn_read(struct comedi
 				}
 			}
 			if (i == NI_TIMEOUT) {
-				rt_printk
+				printk
 					("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
 				return -ETIME;
 			}
@@ -1780,7 +1777,7 @@ static int ni_ai_insn_read(struct comedi
 				}
 			}
 			if (i == NI_TIMEOUT) {
-				rt_printk
+				printk
 					("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
 				return -ETIME;
 			}
@@ -1797,7 +1794,7 @@ static int ni_ai_insn_read(struct comedi
 					break;
 			}
 			if (i == NI_TIMEOUT) {
-				rt_printk
+				printk
 					("ni_mio_common: timeout in ni_ai_insn_read\n");
 				return -ETIME;
 			}
@@ -1825,9 +1822,9 @@ void ni_prime_channelgain_list(struct co
 			devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
 			return;
 		}
-		comedi_udelay(1);
+		udelay(1);
 	}
-	rt_printk("ni_mio_common: timeout loading channel/gain list\n");
+	printk("ni_mio_common: timeout loading channel/gain list\n");
 }
 
 static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
@@ -2844,7 +2841,7 @@ static int ni_m_series_ao_config_chanlis
 				M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		default:
-			rt_printk("%s: bug! unhandled ao reference voltage\n",
+			printk("%s: bug! unhandled ao reference voltage\n",
 				__func__);
 			break;
 		}
@@ -2856,7 +2853,7 @@ static int ni_m_series_ao_config_chanlis
 			conf |= MSeries_AO_DAC_Offset_5V_Bits;
 			break;
 		default:
-			rt_printk("%s: bug! unhandled ao offset voltage\n",
+			printk("%s: bug! unhandled ao offset voltage\n",
 				__func__);
 			break;
 		}
@@ -3033,7 +3030,7 @@ static int ni_ao_inttrig(struct comedi_d
 	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	/* wait for DACs to be loaded */
 	for (i = 0; i < timeout; i++) {
-		comedi_udelay(1);
+		udelay(1);
 		if ((devpriv->stc_readw(dev,
 					Joint_Status_2_Register) &
 				AO_TMRDACWRs_In_Progress_St) == 0)
@@ -3440,7 +3437,7 @@ static int ni_dio_insn_config(struct com
 	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
-	rt_printk("ni_dio_insn_config() chan=%d io=%d\n",
+	printk("ni_dio_insn_config() chan=%d io=%d\n",
 		CR_CHAN(insn->chanspec), data[0]);
 #endif
 	switch (data[0]) {
@@ -3472,7 +3469,7 @@ static int ni_dio_insn_bits(struct comed
 	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
-	rt_printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
+	printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
 #endif
 	if (insn->n != 2)
 		return -EINVAL;
@@ -3499,7 +3496,7 @@ static int ni_m_series_dio_insn_config(s
 	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
-	rt_printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
+	printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
 		CR_CHAN(insn->chanspec), data[0]);
 #endif
 	switch (data[0]) {
@@ -3529,7 +3526,7 @@ static int ni_m_series_dio_insn_bits(str
 	struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
-	rt_printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
+	printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
 		data[1]);
 #endif
 	if (insn->n != 2)
@@ -3706,7 +3703,7 @@ static int ni_cdo_inttrig(struct comedi_
 	comedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);
 
 #ifdef PCIDMA
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		mite_prep_dma(devpriv->cdo_mite_chan, 32, 32);
 		mite_dma_arm(devpriv->cdo_mite_chan);
@@ -3714,7 +3711,7 @@ static int ni_cdo_inttrig(struct comedi_
 		comedi_error(dev, "BUG: no cdo mite channel?");
 		retval = -EIO;
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	if (retval < 0)
 		return retval;
 #endif
@@ -3726,7 +3723,7 @@ static int ni_cdo_inttrig(struct comedi_
 	for (i = 0; i < timeout; ++i) {
 		if (ni_readl(M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)
 			break;
-		comedi_udelay(10);
+		udelay(10);
 	}
 	if (i == timeout) {
 		comedi_error(dev, "dma failed to fill cdo fifo!");
@@ -3765,7 +3762,7 @@ static void handle_cdio_interrupt(struct
 		return;
 	}
 #ifdef PCIDMA
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		unsigned cdo_mite_status =
 			mite_get_status(devpriv->cdo_mite_chan);
@@ -3776,17 +3773,17 @@ static void handle_cdio_interrupt(struct
 		}
 		mite_sync_output_dma(devpriv->cdo_mite_chan, s->async);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 #endif
 
 	cdio_status = ni_readl(M_Offset_CDIO_Status);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
-/* rt_printk("cdio error: statux=0x%x\n", cdio_status); */
+/* printk("cdio error: statux=0x%x\n", cdio_status); */
 		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	/*  XXX just guessing this is needed and does something useful */
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
-/* rt_printk("cdio fifo empty\n"); */
+/* printk("cdio fifo empty\n"); */
 		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
 			M_Offset_CDIO_Command);
 /* s->async->events |= COMEDI_CB_EOA; */
@@ -3807,7 +3804,7 @@ static int ni_serial_insn_config(struct 
 	case INSN_CONFIG_SERIAL_CLOCK:
 
 #ifdef DEBUG_DIO
-		rt_printk("SPI serial clock Config cd\n", data[1]);
+		printk("SPI serial clock Config cd\n", data[1]);
 #endif
 		devpriv->serial_hw_mode = 1;
 		devpriv->dio_control |= DIO_HW_Serial_Enable;
@@ -3873,7 +3870,7 @@ static int ni_serial_insn_config(struct 
 			err = ni_serial_sw_readwrite8(dev, s, byte_out,
 				&byte_in);
 		} else {
-			rt_printk("ni_serial_insn_config: serial disabled!\n");
+			printk("ni_serial_insn_config: serial disabled!\n");
 			return -EINVAL;
 		}
 		if (err < 0)
@@ -3895,7 +3892,7 @@ static int ni_serial_hw_readwrite8(struc
 	int err = 0, count = 20;
 
 #ifdef DEBUG_DIO
-	rt_printk("ni_serial_hw_readwrite8: outputting 0x%x\n", data_out);
+	printk("ni_serial_hw_readwrite8: outputting 0x%x\n", data_out);
 #endif
 
 	devpriv->dio_output &= ~DIO_Serial_Data_Mask;
@@ -3918,9 +3915,9 @@ static int ni_serial_hw_readwrite8(struc
 				Joint_Status_1_Register)) &
 		DIO_Serial_IO_In_Progress_St) {
 		/* Delay one bit per loop */
-		comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+		udelay((devpriv->serial_interval_ns + 999) / 1000);
 		if (--count < 0) {
-			rt_printk
+			printk
 				("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");
 			err = -ETIME;
 			goto Error;
@@ -3929,12 +3926,12 @@ static int ni_serial_hw_readwrite8(struc
 
 	/* Delay for last bit. This delay is absolutely necessary, because
 	   DIO_Serial_IO_In_Progress_St goes high one bit too early. */
-	comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
 	if (data_in != NULL) {
 		*data_in = devpriv->stc_readw(dev, DIO_Serial_Input_Register);
 #ifdef DEBUG_DIO
-		rt_printk("ni_serial_hw_readwrite8: inputted 0x%x\n", *data_in);
+		printk("ni_serial_hw_readwrite8: inputted 0x%x\n", *data_in);
 #endif
 	}
 
@@ -3950,11 +3947,11 @@ static int ni_serial_sw_readwrite8(struc
 	unsigned char mask, input = 0;
 
 #ifdef DEBUG_DIO
-	rt_printk("ni_serial_sw_readwrite8: outputting 0x%x\n", data_out);
+	printk("ni_serial_sw_readwrite8: outputting 0x%x\n", data_out);
 #endif
 
 	/* Wait for one bit before transfer */
-	comedi_udelay((devpriv->serial_interval_ns + 999) / 1000);
+	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
 	for (mask = 0x80; mask; mask >>= 1) {
 		/* Output current bit; note that we cannot touch s->state
@@ -3973,23 +3970,23 @@ static int ni_serial_sw_readwrite8(struc
 		devpriv->stc_writew(dev, devpriv->dio_control,
 			DIO_Control_Register);
 
-		comedi_udelay((devpriv->serial_interval_ns + 999) / 2000);
+		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		devpriv->dio_control &= ~DIO_Software_Serial_Control;
 		devpriv->stc_writew(dev, devpriv->dio_control,
 			DIO_Control_Register);
 
-		comedi_udelay((devpriv->serial_interval_ns + 999) / 2000);
+		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		/* Input current bit */
 		if (devpriv->stc_readw(dev,
 				DIO_Parallel_Input_Register) & DIO_SDIN) {
-/*			rt_printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
+/*			printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
 			input |= mask;
 		}
 	}
 #ifdef DEBUG_DIO
-	rt_printk("ni_serial_sw_readwrite8: inputted 0x%x\n", input);
+	printk("ni_serial_sw_readwrite8: inputted 0x%x\n", input);
 #endif
 	if (data_in)
 		*data_in = input;
@@ -4103,7 +4100,7 @@ static unsigned ni_gpct_to_stc_register(
 		stc_register = Interrupt_B_Enable_Register;
 		break;
 	default:
-		rt_printk("%s: unhandled register 0x%x in switch.\n",
+		printk("%s: unhandled register 0x%x in switch.\n",
 			__func__, reg);
 		BUG();
 		return 0;
@@ -4928,12 +4925,12 @@ static void ni_write_caldac(struct comed
 
 	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
 		ni_writeb(((bit & bitstring) ? 0x02 : 0), Serial_Command);
-		comedi_udelay(1);
+		udelay(1);
 		ni_writeb(1 | ((bit & bitstring) ? 0x02 : 0), Serial_Command);
-		comedi_udelay(1);
+		udelay(1);
 	}
 	ni_writeb(loadbit, Serial_Command);
-	comedi_udelay(1);
+	udelay(1);
 	ni_writeb(0, Serial_Command);
 }
 
@@ -5229,7 +5226,7 @@ static unsigned ni_old_get_pfi_routing(s
 		return NI_PFI_OUTPUT_G_GATE0;
 		break;
 	default:
-		rt_printk("%s: bug, unhandled case in switch.\n", __func__);
+		printk("%s: bug, unhandled case in switch.\n", __func__);
 		break;
 	}
 	return 0;
@@ -5323,7 +5320,7 @@ static void ni_rtsi_init(struct comedi_d
 	/*  Set clock mode to internal */
 	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
 	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0) {
-		rt_printk("ni_set_master_clock failed, bug?");
+		printk("ni_set_master_clock failed, bug?");
 	}
 	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
@@ -5395,7 +5392,7 @@ static int ni_mseries_get_pll_parameters
 		}
 	}
 	if (best_period_picosec == 0) {
-		rt_printk("%s: bug, failed to find pll parameters\n",
+		printk("%s: bug, failed to find pll parameters\n",
 			__func__);
 		return -EIO;
 	}
@@ -5430,7 +5427,7 @@ static int ni_mseries_set_pll_master_clo
 		period_ns = 100;
 	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
-		rt_printk
+		printk
 			("%s: you must specify an input clock frequency between %i and %i nanosec "
 			"for the phased-lock loop.\n", __func__,
 			min_period_ns, max_period_ns);
@@ -5491,9 +5488,9 @@ static int ni_mseries_set_pll_master_clo
 		MSeries_PLL_Divisor_Bits(freq_divider) |
 		MSeries_PLL_Multiplier_Bits(freq_multiplier);
 
-	/* rt_printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
+	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
 	 * freq_divider, freq_multiplier, pll_control_bits); */
-	/* rt_printk("clock_ns=%d\n", devpriv->clock_ns); */
+	/* printk("clock_ns=%d\n", devpriv->clock_ns); */
 	ni_writew(pll_control_bits, M_Offset_PLL_Control);
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
@@ -5504,7 +5501,7 @@ static int ni_mseries_set_pll_master_clo
 		udelay(1);
 	}
 	if (i == timeout) {
-		rt_printk
+		printk
 			("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
 			__func__, source, period_ns);
 		return -ETIMEDOUT;
@@ -5541,7 +5538,7 @@ static int ni_set_master_clock(struct co
 					devpriv->rtsi_trig_direction_reg,
 					RTSI_Trig_Direction_Register);
 				if (period_ns == 0) {
-					rt_printk
+					printk
 						("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
 						__func__);
 					return -EINVAL;
@@ -5564,7 +5561,7 @@ static int ni_valid_rtsi_output_source(s
 			if (source == NI_RTSI_OUTPUT_RTSI_OSC)
 				return 1;
 			else {
-				rt_printk
+				printk
 					("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
 					__func__, chan,
 					old_RTSI_clock_channel);
@@ -5629,7 +5626,7 @@ static unsigned ni_get_rtsi_routing(stru
 	} else {
 		if (chan == old_RTSI_clock_channel)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
-		rt_printk("%s: bug! should never get here?\n", __func__);
+		printk("%s: bug! should never get here?\n", __func__);
 		return 0;
 	}
 }
@@ -5724,7 +5721,7 @@ static int cs5529_wait_for_idle(struct c
 	}
 /* printk("looped %i times waiting for idle\n", i); */
 	if (i == timeout) {
-		rt_printk("%s: %s: timeout\n", __FILE__, __func__);
+		printk("%s: %s: timeout\n", __FILE__, __func__);
 		return -ETIME;
 	}
 	return 0;
@@ -5743,7 +5740,7 @@ static void cs5529_command(struct comedi
 	for (i = 0; i < timeout; i++) {
 		if ((ni_ao_win_inw(dev, CAL_ADC_Status_67xx) & CSS_ADC_BUSY))
 			break;
-		comedi_udelay(1);
+		udelay(1);
 	}
 /* printk("looped %i times writing command to cs5529\n", i); */
 	if (i == timeout) {
@@ -5797,12 +5794,12 @@ static int cs5529_do_conversion(struct c
 	}
 	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
 	if (status & CSS_OSC_DETECT) {
-		rt_printk
+		printk
 			("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
 		return -EIO;
 	}
 	if (status & CSS_OVERRANGE) {
-		rt_printk
+		printk
 			("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
 	}
 	if (data) {
@@ -5859,11 +5856,11 @@ static int init_cs5529(struct comedi_dev
 		comedi_error(dev, "timeout or signal in init_cs5529()\n");
 #endif
 #ifdef NI_CS5529_DEBUG
-	rt_printk("config: 0x%x\n", cs5529_config_read(dev,
+	printk("config: 0x%x\n", cs5529_config_read(dev,
 		CSCMD_CONFIG_REGISTER));
-	rt_printk("gain: 0x%x\n", cs5529_config_read(dev,
+	printk("gain: 0x%x\n", cs5529_config_read(dev,
 		CSCMD_GAIN_REGISTER));
-	rt_printk("offset: 0x%x\n", cs5529_config_read(dev,
+	printk("offset: 0x%x\n", cs5529_config_read(dev,
 		CSCMD_OFFSET_REGISTER));
 #endif
 	return 0;
--- a/drivers/staging/comedi/drivers/ni_mio_cs.c
+++ b/drivers/staging/comedi/drivers/ni_mio_cs.c
@@ -200,14 +200,14 @@ static void mio_cs_win_out(struct comedi
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	if (addr < 8) {
 		ni_writew(data, addr * 2);
 	} else {
 		ni_writew(addr, Window_Address);
 		ni_writew(data, Window_Data);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
 static uint16_t mio_cs_win_in(struct comedi_device *dev, int addr)
@@ -215,14 +215,14 @@ static uint16_t mio_cs_win_in(struct com
 	unsigned long flags;
 	uint16_t ret;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	if (addr < 8) {
 		ret = ni_readw(addr * 2);
 	} else {
 		ni_writew(addr, Window_Address);
 		ret = ni_readw(Window_Data);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 
 	return ret;
 }
@@ -249,7 +249,7 @@ static int mio_cs_detach(struct comedi_d
 	/* PCMCIA layer frees the IO region */
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 
 	return 0;
@@ -446,7 +446,7 @@ static int mio_cs_attach(struct comedi_d
 	printk(" %s", boardtype.name);
 	dev->board_name = boardtype.name;
 
-	ret = comedi_request_irq(irq, ni_E_interrupt, NI_E_IRQ_FLAGS,
+	ret = request_irq(irq, ni_E_interrupt, NI_E_IRQ_FLAGS,
 				 "ni_mio_cs", dev);
 	if (ret < 0) {
 		printk(" irq not available\n");
--- a/drivers/staging/comedi/drivers/ni_pcidio.c
+++ b/drivers/staging/comedi/drivers/ni_pcidio.c
@@ -422,14 +422,13 @@ static int ni_pcidio_request_di_mite_cha
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->di_mite_chan);
 	devpriv->di_mite_chan =
 		mite_request_channel_in_range(devpriv->mite,
 		devpriv->di_mite_ring, 1, 2);
 	if (devpriv->di_mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev, "failed to reserve mite dma channel.");
 		return -EBUSY;
 	}
@@ -437,7 +436,7 @@ static int ni_pcidio_request_di_mite_cha
 		secondary_DMAChannel_bits(devpriv->di_mite_chan->channel),
 		devpriv->mite->daq_io_addr + DMA_Line_Control_Group1);
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
 }
 
@@ -445,7 +444,7 @@ static void ni_pcidio_release_di_mite_ch
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->di_mite_chan) {
 		mite_dma_disarm(devpriv->di_mite_chan);
 		mite_dma_reset(devpriv->di_mite_chan);
@@ -456,7 +455,7 @@ static void ni_pcidio_release_di_mite_ch
 			devpriv->mite->daq_io_addr + DMA_Line_Control_Group1);
 		mmiowb();
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
 static int nidio96_8255_cb(int dir, int port, int data, unsigned long iobase)
@@ -514,7 +513,7 @@ static irqreturn_t nidio_interrupt(int i
 	/* printk("buf[0]=%08x\n",*(unsigned int *)async->prealloc_buf); */
 	/* printk("buf[4096]=%08x\n",*(unsigned int *)(async->prealloc_buf+4096)); */
 
-	comedi_spin_lock_irqsave(&devpriv->mite_channel_lock, irq_flags);
+	spin_lock_irqsave(&devpriv->mite_channel_lock, irq_flags);
 	if (devpriv->di_mite_chan)
 		m_status = mite_get_status(devpriv->di_mite_chan);
 #ifdef MITE_DEBUG
@@ -537,7 +536,7 @@ static irqreturn_t nidio_interrupt(int i
 			disable_irq(dev->irq);
 		}
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, irq_flags);
+	spin_unlock_irqrestore(&devpriv->mite_channel_lock, irq_flags);
 
 	while (status & DataLeft) {
 		work++;
@@ -1235,8 +1234,8 @@ static int nidio_attach(struct comedi_de
 			devpriv->mite->daq_io_addr +
 			Master_DMA_And_Interrupt_Control);
 
-		ret = comedi_request_irq(irq, nidio_interrupt, IRQF_SHARED,
-			"ni_pcidio", dev);
+		ret = request_irq(irq, nidio_interrupt, IRQF_SHARED,
+				  "ni_pcidio", dev);
 		if (ret < 0) {
 			printk(" irq not available");
 		}
@@ -1259,7 +1258,7 @@ static int nidio_detach(struct comedi_de
 	}
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (devpriv) {
 		if (devpriv->di_mite_ring) {
--- a/drivers/staging/comedi/drivers/ni_pcimio.c
+++ b/drivers/staging/comedi/drivers/ni_pcimio.c
@@ -101,7 +101,7 @@ Bugs:
 
 	need to slow down DAC loading.  I don't trust NI's claim that
 	two writes to the PCI bus slows IO enough.  I would prefer to
-	use comedi_udelay().  Timing specs: (clock)
+	use udelay().  Timing specs: (clock)
 		AD8522		30ns
 		DAC8043		120ns
 		DAC8800		60ns
@@ -1246,10 +1246,10 @@ static void e_series_win_out(struct come
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	ni_writew(reg, Window_Address);
 	ni_writew(data, Window_Data);
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
 static uint16_t e_series_win_in(struct comedi_device *dev, int reg)
@@ -1257,10 +1257,10 @@ static uint16_t e_series_win_in(struct c
 	unsigned long flags;
 	uint16_t ret;
 
-	comedi_spin_lock_irqsave(&devpriv->window_lock, flags);
+	spin_lock_irqsave(&devpriv->window_lock, flags);
 	ni_writew(reg, Window_Address);
 	ret = ni_readw(Window_Data);
-	comedi_spin_unlock_irqrestore(&devpriv->window_lock, flags);
+	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 
 	return ret;
 }
@@ -1349,7 +1349,7 @@ static void m_series_stc_writew(struct c
 		offset = M_Offset_AO_FIFO_Clear;
 		break;
 	case DIO_Control_Register:
-		rt_printk
+		printk
 			("%s: FIXME: register 0x%x does not map cleanly on to m-series boards.\n",
 			__func__, reg);
 		return;
@@ -1411,7 +1411,7 @@ static void m_series_stc_writew(struct c
 		/* FIXME: DIO_Output_Register (16 bit reg) is replaced by M_Offset_Static_Digital_Output (32 bit)
 		   and M_Offset_SCXI_Serial_Data_Out (8 bit) */
 	default:
-		rt_printk("%s: bug! unhandled register=0x%x in switch.\n",
+		printk("%s: bug! unhandled register=0x%x in switch.\n",
 			__func__, reg);
 		BUG();
 		return;
@@ -1446,7 +1446,7 @@ static uint16_t m_series_stc_readw(struc
 		offset = M_Offset_G01_Status;
 		break;
 	default:
-		rt_printk("%s: bug! unhandled register=0x%x in switch.\n",
+		printk("%s: bug! unhandled register=0x%x in switch.\n",
 			__func__, reg);
 		BUG();
 		return 0;
@@ -1487,7 +1487,7 @@ static void m_series_stc_writel(struct c
 		offset = M_Offset_G1_Load_B;
 		break;
 	default:
-		rt_printk("%s: bug! unhandled register=0x%x in switch.\n",
+		printk("%s: bug! unhandled register=0x%x in switch.\n",
 			__func__, reg);
 		BUG();
 		return;
@@ -1513,7 +1513,7 @@ static uint32_t m_series_stc_readl(struc
 		offset = M_Offset_G1_Save;
 		break;
 	default:
-		rt_printk("%s: bug! unhandled register=0x%x in switch.\n",
+		printk("%s: bug! unhandled register=0x%x in switch.\n",
 			__func__, reg);
 		BUG();
 		return 0;
@@ -1602,7 +1602,7 @@ static int pcimio_detach(struct comedi_d
 {
 	mio_common_detach(dev);
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->private) {
 		mite_free_ring(devpriv->ai_mite_ring);
@@ -1679,9 +1679,8 @@ static int pcimio_attach(struct comedi_d
 		printk(" unknown irq (bad)\n");
 	} else {
 		printk(" ( irq = %u )", dev->irq);
-		ret = comedi_request_irq(dev->irq, ni_E_interrupt,
-					 NI_E_IRQ_FLAGS, DRV_NAME,
-					 dev);
+		ret = request_irq(dev->irq, ni_E_interrupt, NI_E_IRQ_FLAGS,
+				  DRV_NAME, dev);
 		if (ret < 0) {
 			printk(" irq not available\n");
 			dev->irq = 0;
--- a/drivers/staging/comedi/drivers/ni_stc.h
+++ b/drivers/staging/comedi/drivers/ni_stc.h
@@ -339,7 +339,7 @@ static inline unsigned RTSI_Output_Bit(u
 		max_channel = 6;
 	}
 	if (channel > max_channel) {
-		rt_printk("%s: bug, invalid RTSI_channel=%i\n", __func__,
+		printk("%s: bug, invalid RTSI_channel=%i\n", __func__,
 			channel);
 		return 0;
 	}
@@ -1085,7 +1085,7 @@ static inline int M_Offset_Static_AI_Con
 		0x263,
 	};
 	if (((unsigned)i) >= ARRAY_SIZE(offset)) {
-		rt_printk("%s: invalid channel=%i\n", __func__, i);
+		printk("%s: invalid channel=%i\n", __func__, i);
 		return offset[0];
 	}
 	return offset[i];
@@ -1099,7 +1099,7 @@ static inline int M_Offset_AO_Reference_
 		0x267
 	};
 	if (((unsigned)channel) >= ARRAY_SIZE(offset)) {
-		rt_printk("%s: invalid channel=%i\n", __func__, channel);
+		printk("%s: invalid channel=%i\n", __func__, channel);
 		return offset[0];
 	}
 	return offset[channel];
@@ -1107,7 +1107,7 @@ static inline int M_Offset_AO_Reference_
 static inline unsigned M_Offset_PFI_Output_Select(unsigned n)
 {
 	if (n < 1 || n > NUM_PFI_OUTPUT_SELECT_REGS) {
-		rt_printk("%s: invalid pfi output select register=%i\n",
+		printk("%s: invalid pfi output select register=%i\n",
 			__func__, n);
 		return M_Offset_PFI_Output_Select_1;
 	}
@@ -1162,7 +1162,7 @@ static inline unsigned MSeries_PLL_In_So
 	RTSI_channel)
 {
 	if (RTSI_channel > 7) {
-		rt_printk("%s: bug, invalid RTSI_channel=%i\n", __func__,
+		printk("%s: bug, invalid RTSI_channel=%i\n", __func__,
 			RTSI_channel);
 		return 0;
 	}
@@ -1183,7 +1183,7 @@ static inline unsigned MSeries_PLL_Divis
 {
 	static const unsigned max_divisor = 0x10;
 	if (divisor < 1 || divisor > max_divisor) {
-		rt_printk("%s: bug, invalid divisor=%i\n", __func__,
+		printk("%s: bug, invalid divisor=%i\n", __func__,
 			divisor);
 		return 0;
 	}
@@ -1193,7 +1193,7 @@ static inline unsigned MSeries_PLL_Multi
 {
 	static const unsigned max_multiplier = 0x100;
 	if (multiplier < 1 || multiplier > max_multiplier) {
-		rt_printk("%s: bug, invalid multiplier=%i\n", __func__,
+		printk("%s: bug, invalid multiplier=%i\n", __func__,
 			multiplier);
 		return 0;
 	}
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -669,7 +669,7 @@ static unsigned ni_m_series_source_selec
 		}
 		if (i <= ni_m_series_max_pfi_channel)
 			break;
-		rt_printk("invalid clock source 0x%lx\n",
+		printk("invalid clock source 0x%lx\n",
 			(unsigned long)clock_source);
 		BUG();
 		ni_m_series_clock = 0;
@@ -1273,7 +1273,7 @@ static int ni_tio_set_other_src(struct n
 		counter_dev->regs[abz_reg] &= ~mask;
 		counter_dev->regs[abz_reg] |= (source << shift) & mask;
 		write_register(counter, counter_dev->regs[abz_reg], abz_reg);
-/* rt_printk("%s %x %d %d\n", __func__, counter_dev->regs[abz_reg], index, source); */
+/* printk("%s %x %d %d\n", __func__, counter_dev->regs[abz_reg], index, source); */
 		return 0;
 	}
 	return -EINVAL;
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -107,12 +107,12 @@ static int ni_tio_input_inttrig(struct c
 	if (trignum != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan)
 		mite_dma_arm(counter->mite_chan);
 	else
 		retval = -EIO;
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 	if (retval < 0)
 		return retval;
 	retval = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
@@ -171,7 +171,7 @@ static int ni_tio_input_cmd(struct ni_gp
 
 static int ni_tio_output_cmd(struct ni_gpct *counter, struct comedi_async *async)
 {
-	rt_printk("ni_tio: output commands not yet implemented.\n");
+	printk("ni_tio: output commands not yet implemented.\n");
 	return -ENOTSUPP;
 
 	counter->mite_chan->dir = COMEDI_OUTPUT;
@@ -213,9 +213,9 @@ int ni_tio_cmd(struct ni_gpct *counter, 
 	int retval = 0;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan == NULL) {
-		rt_printk
+		printk
 			("ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
 		retval = -EIO;
 	} else {
@@ -228,7 +228,7 @@ int ni_tio_cmd(struct ni_gpct *counter, 
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 	return retval;
 }
 
@@ -342,11 +342,11 @@ int ni_tio_cancel(struct ni_gpct *counte
 	unsigned long flags;
 
 	ni_tio_arm(counter, 0, 0);
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan) {
 		mite_dma_disarm(counter->mite_chan);
 	}
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 	ni_tio_configure_dma(counter, 0, 0);
 
 	ni_tio_set_bits(counter,
@@ -369,7 +369,7 @@ static int should_ack_gate(struct ni_gpc
 		return 1;
 		break;
 	case ni_gpct_variant_e_series:
-		comedi_spin_lock_irqsave(&counter->lock, flags);
+		spin_lock_irqsave(&counter->lock, flags);
 		{
 			if (counter->mite_chan == NULL ||
 				counter->mite_chan->dir != COMEDI_INPUT ||
@@ -377,7 +377,7 @@ static int should_ack_gate(struct ni_gpc
 				retval = 1;
 			}
 		}
-		comedi_spin_unlock_irqrestore(&counter->lock, flags);
+		spin_unlock_irqrestore(&counter->lock, flags);
 		break;
 	}
 	return retval;
@@ -439,7 +439,7 @@ void ni_tio_acknowledge_and_confirm(stru
 				NITIO_Gxx_Joint_Status2_Reg(counter->
 					counter_index)) &
 			Gi_Permanent_Stale_Bit(counter->counter_index)) {
-			rt_printk("%s: Gi_Permanent_Stale_Data detected.\n",
+			printk("%s: Gi_Permanent_Stale_Data detected.\n",
 				__FUNCTION__);
 			if (perm_stale_data)
 				*perm_stale_data = 1;
@@ -458,7 +458,7 @@ void ni_tio_handle_interrupt(struct ni_g
 	ni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,
 		&perm_stale_data, NULL);
 	if (gate_error) {
-		rt_printk("%s: Gi_Gate_Error detected.\n", __FUNCTION__);
+		printk("%s: Gi_Gate_Error detected.\n", __FUNCTION__);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (perm_stale_data) {
@@ -470,16 +470,16 @@ void ni_tio_handle_interrupt(struct ni_g
 		if (read_register(counter,
 				NITIO_Gi_DMA_Status_Reg(counter->
 					counter_index)) & Gi_DRQ_Error_Bit) {
-			rt_printk("%s: Gi_DRQ_Error detected.\n", __FUNCTION__);
+			printk("%s: Gi_DRQ_Error detected.\n", __FUNCTION__);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 		break;
 	case ni_gpct_variant_e_series:
 		break;
 	}
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&counter->lock, flags);
+		spin_unlock_irqrestore(&counter->lock, flags);
 		return;
 	}
 	gpct_mite_status = mite_get_status(counter->mite_chan);
@@ -489,7 +489,7 @@ void ni_tio_handle_interrupt(struct ni_g
 			MITE_CHOR(counter->mite_chan->channel));
 	}
 	mite_sync_input_dma(counter->mite_chan, s->async);
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 }
 
 void ni_tio_set_mite_channel(struct ni_gpct *counter,
@@ -497,9 +497,9 @@ void ni_tio_set_mite_channel(struct ni_g
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	counter->mite_chan = mite_chan;
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 }
 
 static int __init ni_tiocmd_init_module(void)
--- a/drivers/staging/comedi/drivers/ni_tio_internal.h
+++ b/drivers/staging/comedi/drivers/ni_tio_internal.h
@@ -728,14 +728,14 @@ static inline void ni_tio_set_bits_trans
 	unsigned long flags;
 
 	BUG_ON(register_index >= NITIO_Num_Registers);
-	comedi_spin_lock_irqsave(&counter_dev->regs_lock, flags);
+	spin_lock_irqsave(&counter_dev->regs_lock, flags);
 	counter_dev->regs[register_index] &= ~bit_mask;
 	counter_dev->regs[register_index] |= (bit_values & bit_mask);
 	write_register(counter,
 		counter_dev->regs[register_index] | transient_bit_values,
 		register_index);
 	mmiowb();
-	comedi_spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
+	spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
 }
 
 /* ni_tio_set_bits( ) is for safely writing to registers whose bits may be
@@ -761,9 +761,9 @@ static inline unsigned ni_tio_get_soft_c
 	unsigned value;
 
 	BUG_ON(register_index >= NITIO_Num_Registers);
-	comedi_spin_lock_irqsave(&counter_dev->regs_lock, flags);
+	spin_lock_irqsave(&counter_dev->regs_lock, flags);
 	value = counter_dev->regs[register_index];
-	comedi_spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
+	spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
 	return value;
 }
 
--- a/drivers/staging/comedi/drivers/pcl711.c
+++ b/drivers/staging/comedi/drivers/pcl711.c
@@ -269,9 +269,9 @@ static int pcl711_ai_insn(struct comedi_
 			hi = inb(dev->iobase + PCL711_AD_HI);
 			if (!(hi & PCL711_DRDY))
 				goto ok;
-			comedi_udelay(1);
+			udelay(1);
 		}
-		rt_printk("comedi%d: pcl711: A/D timeout\n", dev->minor);
+		printk("comedi%d: pcl711: A/D timeout\n", dev->minor);
 		return -ETIME;
 
 	      ok:
@@ -503,7 +503,7 @@ static int pcl711_detach(struct comedi_d
 	printk("comedi%d: pcl711: remove\n", dev->minor);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (dev->iobase)
 		release_region(dev->iobase, PCL711_SIZE);
@@ -541,7 +541,7 @@ static int pcl711_attach(struct comedi_d
 		return -EINVAL;
 	}
 	if (irq) {
-		if (comedi_request_irq(irq, pcl711_interrupt, 0, "pcl711", dev)) {
+		if (request_irq(irq, pcl711_interrupt, 0, "pcl711", dev)) {
 			printk("unable to allocate irq %u\n", irq);
 			return -EINVAL;
 		} else {
--- a/drivers/staging/comedi/drivers/pcl724.c
+++ b/drivers/staging/comedi/drivers/pcl724.c
@@ -155,19 +155,18 @@ static int pcl724_attach(struct comedi_d
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
-				rt_printk
+				printk
 					(", IRQ %u is out of allowed range, DISABLING IT",
 					irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (comedi_request_irq(irq, interrupt_pcl724, 0,
-						"pcl724", dev)) {
-					rt_printk
+				if (request_irq(irq, interrupt_pcl724, 0, "pcl724", dev)) {
+					printk
 						(", unable to allocate IRQ %u, DISABLING IT",
 						irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
-					rt_printk(", irq=%u", irq);
+					printk(", irq=%u", irq);
 				}
 			}
 		}
@@ -213,7 +212,7 @@ static int pcl724_detach(struct comedi_d
 
 #ifdef PCL724_IRQ
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 #endif
 
--- a/drivers/staging/comedi/drivers/pcl726.c
+++ b/drivers/staging/comedi/drivers/pcl726.c
@@ -280,19 +280,19 @@ static int pcl726_attach(struct comedi_d
 		devpriv->first_chan = 2;
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & boardtypes[board].IRQbits) == 0) {
-				rt_printk
+				printk
 					(", IRQ %d is out of allowed range, DISABLING IT",
 					irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (comedi_request_irq(irq, interrupt_pcl818, 0,
+				if (request_irq(irq, interrupt_pcl818, 0,
 						"pcl726", dev)) {
-					rt_printk
+					printk
 						(", unable to allocate IRQ %d, DISABLING IT",
 						irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
-					rt_printk(", irq=%d", irq);
+					printk(", irq=%d", irq);
 				}
 			}
 		}
@@ -368,7 +368,7 @@ static int pcl726_detach(struct comedi_d
 
 #ifdef ACL6126_IRQ
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 #endif
 
--- a/drivers/staging/comedi/drivers/pcl812.c
+++ b/drivers/staging/comedi/drivers/pcl812.c
@@ -447,15 +447,15 @@ static int pcl812_ai_insn_read(struct co
 	setup_range_channel(dev, s, insn->chanspec, 1);	/*  select channel and renge */
 	for (n = 0; n < insn->n; n++) {
 		outb(255, dev->iobase + PCL812_SOFTTRIG);	/* start conversion */
-		comedi_udelay(5);
+		udelay(5);
 		timeout = 50;	/* wait max 50us, it must finish under 33us */
 		while (timeout--) {
 			hi = inb(dev->iobase + PCL812_AD_HI);
 			if (!(hi & PCL812_DRDY))
 				goto conv_finish;
-			comedi_udelay(1);
+			udelay(1);
 		}
-		rt_printk
+		printk
 			("comedi%d: pcl812: (%s at 0x%lx) A/D insn read timeout\n",
 			dev->minor, dev->board_name, dev->iobase);
 		outb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);
@@ -481,14 +481,14 @@ static int acl8216_ai_insn_read(struct c
 	setup_range_channel(dev, s, insn->chanspec, 1);	/*  select channel and renge */
 	for (n = 0; n < insn->n; n++) {
 		outb(255, dev->iobase + PCL812_SOFTTRIG);	/* start conversion */
-		comedi_udelay(5);
+		udelay(5);
 		timeout = 50;	/* wait max 50us, it must finish under 33us */
 		while (timeout--) {
 			if (!(inb(dev->iobase + ACL8216_STATUS) & ACL8216_DRDY))
 				goto conv_finish;
-			comedi_udelay(1);
+			udelay(1);
 		}
-		rt_printk
+		printk
 			("comedi%d: pcl812: (%s at 0x%lx) A/D insn read timeout\n",
 			dev->minor, dev->board_name, dev->iobase);
 		outb(0, dev->iobase + PCL812_MODE);
@@ -581,13 +581,13 @@ static int pcl812_do_insn_bits(struct co
 */
 static void pcl812_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
-	rt_printk("pcl812 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
+	printk("pcl812 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
 		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
-	rt_printk("pcl812 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
+	printk("pcl812 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
 		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
-	rt_printk("pcl812 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
+	printk("pcl812 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
 		cmd->scan_end_src);
-	rt_printk("pcl812 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
+	printk("pcl812 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
 		cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 #endif
@@ -602,7 +602,7 @@ static int pcl812_ai_cmdtest(struct come
 	int tmp, divisor1, divisor2;
 
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...)\n");
+	printk("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...)\n");
 	pcl812_cmdtest_out(-1, cmd);
 #endif
 	/* step 1: make sure trigger sources are trivially valid */
@@ -639,7 +639,7 @@ static int pcl812_ai_cmdtest(struct come
 	if (err) {
 #ifdef PCL812_EXTDEBUG
 		pcl812_cmdtest_out(1, cmd);
-		rt_printk
+		printk
 			("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=1\n",
 			err);
 #endif
@@ -681,7 +681,7 @@ static int pcl812_ai_cmdtest(struct come
 	if (err) {
 #ifdef PCL812_EXTDEBUG
 		pcl812_cmdtest_out(2, cmd);
-		rt_printk
+		printk
 			("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=2\n",
 			err);
 #endif
@@ -739,7 +739,7 @@ static int pcl812_ai_cmdtest(struct come
 	if (err) {
 #ifdef PCL812_EXTDEBUG
 		pcl812_cmdtest_out(3, cmd);
-		rt_printk
+		printk
 			("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=3\n",
 			err);
 #endif
@@ -761,7 +761,7 @@ static int pcl812_ai_cmdtest(struct come
 
 	if (err) {
 #ifdef PCL812_EXTDEBUG
-		rt_printk
+		printk
 			("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=4\n",
 			err);
 #endif
@@ -780,7 +780,7 @@ static int pcl812_ai_cmd(struct comedi_d
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: BGN: pcl812_ai_cmd(...)\n");
+	printk("pcl812 EDBG: BGN: pcl812_ai_cmd(...)\n");
 #endif
 
 	if (cmd->start_src != TRIG_NOW)
@@ -892,7 +892,7 @@ static int pcl812_ai_cmd(struct comedi_d
 		release_dma_lock(dma_flags);
 		enable_dma(devpriv->dma);
 #ifdef PCL812_EXTDEBUG
-		rt_printk
+		printk
 			("pcl812 EDBG:   DMA %d PTR 0x%0x/0x%0x LEN %u/%u EOS %d\n",
 			devpriv->dma, devpriv->hwdmaptr[0],
 			devpriv->hwdmaptr[1], devpriv->dmabytestomove[0],
@@ -913,7 +913,7 @@ static int pcl812_ai_cmd(struct comedi_d
 	}
 
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: END: pcl812_ai_cmd(...)\n");
+	printk("pcl812 EDBG: END: pcl812_ai_cmd(...)\n");
 #endif
 
 	return 0;
@@ -939,7 +939,7 @@ static irqreturn_t interrupt_pcl812_ai_i
 				err = 0;
 				break;
 			}
-			comedi_udelay(1);
+			udelay(1);
 		}
 	} else {
 		mask = 0x0fff;
@@ -948,12 +948,12 @@ static irqreturn_t interrupt_pcl812_ai_i
 				err = 0;
 				break;
 			}
-			comedi_udelay(1);
+			udelay(1);
 		}
 	}
 
 	if (err) {
-		rt_printk
+		printk
 			("comedi%d: pcl812: (%s at 0x%lx) A/D cmd IRQ without DRDY!\n",
 			dev->minor, dev->board_name, dev->iobase);
 		pcl812_ai_cancel(dev, s);
@@ -1019,7 +1019,7 @@ static irqreturn_t interrupt_pcl812_ai_d
 	short *ptr;
 
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: BGN: interrupt_pcl812_ai_dma(...)\n");
+	printk("pcl812 EDBG: BGN: interrupt_pcl812_ai_dma(...)\n");
 #endif
 	ptr = (short *) devpriv->dmabuf[devpriv->next_dma_buf];
 	len = (devpriv->dmabytestomove[devpriv->next_dma_buf] >> 1) -
@@ -1053,7 +1053,7 @@ static irqreturn_t interrupt_pcl812_ai_d
 	transfer_from_dma_buf(dev, s, ptr, bufptr, len);
 
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: END: interrupt_pcl812_ai_dma(...)\n");
+	printk("pcl812 EDBG: END: interrupt_pcl812_ai_dma(...)\n");
 #endif
 	return IRQ_HANDLED;
 }
@@ -1087,7 +1087,7 @@ static int pcl812_ai_poll(struct comedi_
 	if (!devpriv->ai_dma)
 		return 0;	/*  poll is valid only for DMA transfer */
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	for (i = 0; i < 10; i++) {
 		top1 = get_dma_residue(devpriv->ai_dma);	/*  where is now DMA */
@@ -1097,7 +1097,7 @@ static int pcl812_ai_poll(struct comedi_
 	}
 
 	if (top1 != top2) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
 
@@ -1105,7 +1105,7 @@ static int pcl812_ai_poll(struct comedi_
 	top1 >>= 1;		/*  sample position */
 	top2 = top1 - devpriv->ai_poll_ptr;
 	if (top2 < 1) {		/*  no new samples */
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
 
@@ -1115,7 +1115,7 @@ static int pcl812_ai_poll(struct comedi_
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
@@ -1152,7 +1152,7 @@ static void setup_range_channel(struct c
 	outb(gain_reg, dev->iobase + PCL812_GAIN);	/* select gain */
 
 	if (wait) {
-		comedi_udelay(devpriv->max_812_ai_mode0_rangewait);	/*  XXX this depends on selected range and can be very long for some high gain ranges! */
+		udelay(devpriv->max_812_ai_mode0_rangewait);	/*  XXX this depends on selected range and can be very long for some high gain ranges! */
 	}
 }
 
@@ -1163,12 +1163,12 @@ static void start_pacer(struct comedi_de
 	unsigned int divisor2)
 {
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: BGN: start_pacer(%d,%u,%u)\n", mode, divisor1,
+	printk("pcl812 EDBG: BGN: start_pacer(%d,%u,%u)\n", mode, divisor1,
 		divisor2);
 #endif
 	outb(0xb4, dev->iobase + PCL812_CTRCTL);
 	outb(0x74, dev->iobase + PCL812_CTRCTL);
-	comedi_udelay(1);
+	udelay(1);
 
 	if (mode == 1) {
 		outb(divisor2 & 0xff, dev->iobase + PCL812_CTR2);
@@ -1177,7 +1177,7 @@ static void start_pacer(struct comedi_de
 		outb((divisor1 >> 8) & 0xff, dev->iobase + PCL812_CTR1);
 	}
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: END: start_pacer(...)\n");
+	printk("pcl812 EDBG: END: start_pacer(...)\n");
 #endif
 }
 
@@ -1196,7 +1196,7 @@ static void free_resources(struct comedi
 			free_dma(devpriv->dma);
 	}
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, this_board->io_range);
 }
@@ -1207,7 +1207,7 @@ static void free_resources(struct comedi
 static int pcl812_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: BGN: pcl812_ai_cancel(...)\n");
+	printk("pcl812 EDBG: BGN: pcl812_ai_cancel(...)\n");
 #endif
 	if (devpriv->ai_dma)
 		disable_dma(devpriv->dma);
@@ -1216,7 +1216,7 @@ static int pcl812_ai_cancel(struct comed
 	start_pacer(dev, -1, 0, 0);	/*  stop 8254 */
 	outb(0, dev->iobase + PCL812_CLRINT);	/* clear INT request */
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: END: pcl812_ai_cancel(...)\n");
+	printk("pcl812 EDBG: END: pcl812_ai_cancel(...)\n");
 #endif
 	return 0;
 }
@@ -1227,7 +1227,7 @@ static int pcl812_ai_cancel(struct comed
 static void pcl812_reset(struct comedi_device *dev)
 {
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: BGN: pcl812_reset(...)\n");
+	printk("pcl812 EDBG: BGN: pcl812_reset(...)\n");
 #endif
 	outb(0, dev->iobase + PCL812_MUX);
 	outb(0 + devpriv->range_correction, dev->iobase + PCL812_GAIN);
@@ -1254,12 +1254,12 @@ static void pcl812_reset(struct comedi_d
 	case boardPCL813:
 	case boardISO813:
 	case boardACL8113:
-		comedi_udelay(5);
+		udelay(5);
 		break;
 	}
-	comedi_udelay(5);
+	udelay(5);
 #ifdef PCL812_EXTDEBUG
-	rt_printk("pcl812 EDBG: END: pcl812_reset(...)\n");
+	printk("pcl812 EDBG: END: pcl812_reset(...)\n");
 #endif
 }
 
@@ -1302,8 +1302,7 @@ static int pcl812_attach(struct comedi_d
 				printk(", IRQ %u is out of allowed range, DISABLING IT", irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (comedi_request_irq(irq, interrupt_pcl812, 0,
-						"pcl812", dev)) {
+				if (request_irq(irq, interrupt_pcl812, 0, "pcl812", dev)) {
 					printk(", unable to allocate IRQ %u, DISABLING IT", irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
@@ -1600,7 +1599,7 @@ static int pcl812_detach(struct comedi_d
 {
 
 #ifdef PCL812_EXTDEBUG
-	rt_printk("comedi%d: pcl812: remove\n", dev->minor);
+	printk("comedi%d: pcl812: remove\n", dev->minor);
 #endif
 	free_resources(dev);
 	return 0;
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -263,7 +263,7 @@ static int pcl816_ai_insn_read(struct co
 				outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT (conversion end) flag */
 				break;
 			}
-			comedi_udelay(1);
+			udelay(1);
 		}
 		/*  Return timeout error */
 		if (!timeout) {
@@ -293,7 +293,7 @@ static irqreturn_t interrupt_pcl816_ai_m
 		if (!(inb(dev->iobase + PCL816_STATUS) &
 				PCL816_STATUS_DRDY_MASK))
 			break;
-		comedi_udelay(1);
+		udelay(1);
 	}
 	if (!timeout) {		/*  timeout, bail error */
 		outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
@@ -449,13 +449,13 @@ static irqreturn_t interrupt_pcl816(int 
 */
 static void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
-	rt_printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
+	printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
 		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
-	rt_printk("pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
+	printk("pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
 		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
-	rt_printk("pcl816 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
+	printk("pcl816 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
 		cmd->scan_end_src);
-	rt_printk("pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
+	printk("pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
 		cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 
@@ -468,7 +468,7 @@ static int pcl816_ai_cmdtest(struct come
 	int err = 0;
 	int tmp, divisor1, divisor2;
 
-	DEBUG(rt_printk("pcl816 pcl812_ai_cmdtest\n");
+	DEBUG(printk("pcl816 pcl812_ai_cmdtest\n");
 		pcl816_cmdtest_out(-1, cmd););
 
 	/* step 1: make sure trigger sources are trivially valid */
@@ -636,7 +636,7 @@ static int pcl816_ai_cmd(struct comedi_d
 	if (!check_and_setup_channel_list(dev, s, cmd->chanlist,
 			cmd->chanlist_len))
 		return -EINVAL;
-	comedi_udelay(1);
+	udelay(1);
 
 	devpriv->ai_act_scan = 0;
 	s->async->cur_chan = 0;
@@ -710,7 +710,7 @@ static int pcl816_ai_poll(struct comedi_
 	if (!devpriv->dma)
 		return 0;	/*  poll is valid only for DMA transfer */
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	for (i = 0; i < 20; i++) {
 		top1 = get_dma_residue(devpriv->dma);	/*  where is now DMA */
@@ -719,7 +719,7 @@ static int pcl816_ai_poll(struct comedi_
 			break;
 	}
 	if (top1 != top2) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
 
@@ -727,7 +727,7 @@ static int pcl816_ai_poll(struct comedi_
 	top1 >>= 1;		/*  sample position */
 	top2 = top1 - devpriv->ai_poll_ptr;
 	if (top2 < 1) {		/*  no new samples */
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
 
@@ -736,7 +736,7 @@ static int pcl816_ai_poll(struct comedi_
 		devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
@@ -747,7 +747,7 @@ static int pcl816_ai_poll(struct comedi_
 */
 static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-/* DEBUG(rt_printk("pcl816_ai_cancel()\n");) */
+/* DEBUG(printk("pcl816_ai_cancel()\n");) */
 
 	if (devpriv->irq_blocked > 0) {
 		switch (devpriv->int816_mode) {
@@ -763,7 +763,7 @@ static int pcl816_ai_cancel(struct comed
 		case INT_TYPE_AI1_INT:
 		case INT_TYPE_AI3_INT:
 			outb(inb(dev->iobase + PCL816_CONTROL) & 0x73, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
-			comedi_udelay(1);
+			udelay(1);
 			outb(0, dev->iobase + PCL816_CONTROL);	/* Stop A/D */
 			outb(0xb0, dev->iobase + PCL816_CTRCTL);	/* Stop pacer */
 			outb(0x70, dev->iobase + PCL816_CTRCTL);
@@ -781,7 +781,7 @@ static int pcl816_ai_cancel(struct comed
 		}
 	}
 
-	DEBUG(rt_printk("comedi: pcl816_ai_cancel() successful\n");
+	DEBUG(printk("comedi: pcl816_ai_cancel() successful\n");
 		)
 		return 0;
 }
@@ -793,17 +793,17 @@ static int pcl816_ai_cancel(struct comed
 static int pcl816_check(unsigned long iobase)
 {
 	outb(0x00, iobase + PCL816_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL816_MUX) != 0x00)
 		return 1;	/* there isn't card */
 	outb(0x55, iobase + PCL816_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL816_MUX) != 0x55)
 		return 1;	/* there isn't card */
 	outb(0x00, iobase + PCL816_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0x18, iobase + PCL816_CONTROL);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL816_CONTROL) != 0x18)
 		return 1;	/* there isn't card */
 	return 0;		/*  ok, card exist */
@@ -817,10 +817,10 @@ static void pcl816_reset(struct comedi_d
 {
 /* outb (0, dev->iobase + PCL818_DA_LO);         DAC=0V */
 /* outb (0, dev->iobase + PCL818_DA_HI); */
-/* comedi_udelay (1); */
+/* udelay (1); */
 /* outb (0, dev->iobase + PCL818_DO_HI);        DO=$0000 */
 /* outb (0, dev->iobase + PCL818_DO_LO); */
-/* comedi_udelay (1); */
+/* udelay (1); */
 	outb(0, dev->iobase + PCL816_CONTROL);
 	outb(0, dev->iobase + PCL816_MUX);
 	outb(0, dev->iobase + PCL816_CLRINT);
@@ -841,10 +841,10 @@ start_pacer(struct comedi_device *dev, i
 	outb(0x32, dev->iobase + PCL816_CTRCTL);
 	outb(0xff, dev->iobase + PCL816_CTR0);
 	outb(0x00, dev->iobase + PCL816_CTR0);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0xb4, dev->iobase + PCL816_CTRCTL);	/*  set counter 2 as mode 3 */
 	outb(0x74, dev->iobase + PCL816_CTRCTL);	/*  set counter 1 as mode 3 */
-	comedi_udelay(1);
+	udelay(1);
 
 	if (mode == 1) {
 		DPRINTK("mode %d, divisor1 %d, divisor2 %d\n", mode, divisor1,
@@ -881,7 +881,7 @@ check_and_setup_channel_list(struct come
 		chansegment[0] = chanlist[0];	/*  first channel is everytime ok */
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
 			/*  build part of chanlist */
-			DEBUG(rt_printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
+			DEBUG(printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
 					CR_RANGE(chanlist[i]));
 				)
 				if (chanlist[0] == chanlist[i])
@@ -890,7 +890,7 @@ check_and_setup_channel_list(struct come
 				(CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
 				/*  channel list isn't continous :-( */
-				rt_printk
+				printk
 					("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					dev->minor, i, CR_CHAN(chanlist[i]),
 					nowmustbechan, CR_CHAN(chanlist[0]));
@@ -900,14 +900,14 @@ check_and_setup_channel_list(struct come
 		}
 
 		for (i = 0, segpos = 0; i < chanlen; i++) {	/*  check whole chanlist */
-			DEBUG(rt_printk("%d %d=%d %d\n",
+			DEBUG(printk("%d %d=%d %d\n",
 					CR_CHAN(chansegment[i % seglen]),
 					CR_RANGE(chansegment[i % seglen]),
 					CR_CHAN(chanlist[i]),
 					CR_RANGE(chanlist[i]));
 				)
 				if (chanlist[i] != chansegment[i % seglen]) {
-				rt_printk
+				printk
 					("comedi%d: pcl816: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
 					dev->minor, i, CR_CHAN(chansegment[i]),
 					CR_RANGE(chansegment[i]),
@@ -931,7 +931,7 @@ check_and_setup_channel_list(struct come
 		outb(CR_RANGE(chanlist[0]), dev->iobase + PCL816_RANGE);	/* select gain */
 	}
 
-	comedi_udelay(1);
+	udelay(1);
 
 	outb(devpriv->ai_act_chanlist[0] | (devpriv->ai_act_chanlist[seglen - 1] << 4), dev->iobase + PCL816_MUX);	/* select channel interval to scan */
 
@@ -981,7 +981,7 @@ static int set_rtc_irq_bit(unsigned char
 */
 static void free_resources(struct comedi_device *dev)
 {
-	/* rt_printk("free_resource()\n"); */
+	/* printk("free_resource()\n"); */
 	if (dev->private) {
 		pcl816_ai_cancel(dev, devpriv->sub_ai);
 		pcl816_reset(dev);
@@ -993,7 +993,7 @@ static void free_resources(struct comedi
 			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
 #ifdef unused
 		if (devpriv->rtc_irq)
-			comedi_free_irq(devpriv->rtc_irq, dev);
+			free_irq(devpriv->rtc_irq, dev);
 		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
 			if (devpriv->rtc_iobase)
 				release_region(devpriv->rtc_iobase,
@@ -1006,7 +1006,7 @@ static void free_resources(struct comedi
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, this_board->io_range);
-	/* rt_printk("free_resource() end\n"); */
+	/* printk("free_resource() end\n"); */
 }
 
 /*
@@ -1030,14 +1030,14 @@ static int pcl816_attach(struct comedi_d
 		this_board->name, iobase);
 
 	if (!request_region(iobase, this_board->io_range, "pcl816")) {
-		rt_printk("I/O port conflict\n");
+		printk("I/O port conflict\n");
 		return -EIO;
 	}
 
 	dev->iobase = iobase;
 
 	if (pcl816_check(iobase)) {
-		rt_printk(", I cann't detect board. FAIL!\n");
+		printk(", I cann't detect board. FAIL!\n");
 		return -EIO;
 	}
 
@@ -1054,19 +1054,18 @@ static int pcl816_attach(struct comedi_d
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
-				rt_printk
+				printk
 					(", IRQ %u is out of allowed range, DISABLING IT",
 					irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (comedi_request_irq(irq, interrupt_pcl816, 0,
-						"pcl816", dev)) {
-					rt_printk
+				if (request_irq(irq, interrupt_pcl816, 0, "pcl816", dev)) {
+					printk
 						(", unable to allocate IRQ %u, DISABLING IT",
 						irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
-					rt_printk(", irq=%u", irq);
+					printk(", irq=%u", irq);
 				}
 			}
 		}
@@ -1095,12 +1094,11 @@ static int pcl816_attach(struct comedi_d
 		devpriv->rtc_iosize = RTC_IO_EXTENT;
 		RTC_lock++;
 #ifdef UNTESTED_CODE
-		if (!comedi_request_irq(RTC_IRQ,
-				interrupt_pcl816_ai_mode13_dma_rtc, 0,
+		if (!request_irq(RTC_IRQ, interrupt_pcl816_ai_mode13_dma_rtc, 0,
 				"pcl816 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
-			rt_printk(", dma_irq=%u", devpriv->rtc_irq);
+			printk(", dma_irq=%u", devpriv->rtc_irq);
 		} else {
 			RTC_lock--;
 			if (RTC_lock == 0) {
@@ -1131,34 +1129,34 @@ static int pcl816_attach(struct comedi_d
 			goto no_dma;	/* DMA disabled */
 
 		if (((1 << dma) & this_board->DMAbits) == 0) {
-			rt_printk(", DMA is out of allowed range, FAIL!\n");
+			printk(", DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
 		ret = request_dma(dma, "pcl816");
 		if (ret) {
-			rt_printk(", unable to allocate DMA %u, FAIL!\n", dma);
+			printk(", unable to allocate DMA %u, FAIL!\n", dma);
 			return -EBUSY;	/* DMA isn't free */
 		}
 
 		devpriv->dma = dma;
-		rt_printk(", dma=%u", dma);
+		printk(", dma=%u", dma);
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
 
 		if (!devpriv->dmabuf[0]) {
-			rt_printk(", unable to allocate DMA buffer, FAIL!\n");
+			printk(", unable to allocate DMA buffer, FAIL!\n");
 			/* maybe experiment with try_to_free_pages() will help .... */
 			return -EBUSY;	/* no buffer :-( */
 		}
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		/* rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
+		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 
 		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
-				rt_printk
+				printk
 					(", unable to allocate DMA buffer, FAIL!\n");
 				return -EBUSY;
 			}
@@ -1232,7 +1230,7 @@ case COMEDI_SUBD_DO:
 
 	pcl816_reset(dev);
 
-	rt_printk("\n");
+	printk("\n");
 
 	return 0;
 }
@@ -1243,7 +1241,7 @@ case COMEDI_SUBD_DO:
  */
 static int pcl816_detach(struct comedi_device *dev)
 {
-	DEBUG(rt_printk("comedi%d: pcl816: remove\n", dev->minor);
+	DEBUG(printk("comedi%d: pcl816: remove\n", dev->minor);
 		)
 		free_resources(dev);
 #ifdef unused
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -418,7 +418,7 @@ static int pcl818_ai_insn_read(struct co
 		while (timeout--) {
 			if (inb(dev->iobase + PCL818_STATUS) & 0x10)
 				goto conv_finish;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		comedi_error(dev, "A/D insn timeout");
 		/* clear INT (conversion end) flag */
@@ -524,7 +524,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 	while (timeout--) {
 		if (inb(dev->iobase + PCL818_STATUS) & 0x10)
 			goto conv_finish;
-		comedi_udelay(1);
+		udelay(1);
 	}
 	outb(0, dev->iobase + PCL818_STATUS);	/* clear INT request */
 	comedi_error(dev, "A/D mode1/3 IRQ without DRDY!");
@@ -539,7 +539,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-		rt_printk
+		printk
 			("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
 			(low & 0xf),
 			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
@@ -549,7 +549,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 		return IRQ_HANDLED;
 	}
 	if (s->async->cur_chan == 0) {
-		/*  rt_printk("E"); */
+		/*  printk("E"); */
 		devpriv->ai_act_scan--;
 	}
 
@@ -591,7 +591,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 		release_dma_lock(flags);
 		enable_dma(devpriv->dma);
 	}
-	rt_printk("comedi: A/D mode1/3 IRQ \n");
+	printk("comedi: A/D mode1/3 IRQ \n");
 
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
@@ -602,7 +602,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 
 	for (i = 0; i < len; i++) {
 		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-			rt_printk
+			printk
 				("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
 				(ptr[bufptr] & 0xf),
 				devpriv->act_chanlist[devpriv->
@@ -681,19 +681,19 @@ static irqreturn_t interrupt_pcl818_ai_m
 
 		if (dmabuf[i] != MAGIC_DMA_WORD) {	/*  DMA overflow! */
 			comedi_error(dev, "A/D mode1/3 DMA buffer overflow!");
-			/* rt_printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv->dmasamplsize); */
+			/* printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv->dmasamplsize); */
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			return IRQ_HANDLED;
 		}
-		/* rt_printk("r %ld ",ofs_dats); */
+		/* printk("r %ld ",ofs_dats); */
 
 		bufptr = devpriv->last_top_dma;
 
 		for (i = 0; i < ofs_dats; i++) {
 			if ((dmabuf[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-				rt_printk
+				printk
 					("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
 					(dmabuf[bufptr] & 0xf),
 					devpriv->act_chanlist[devpriv->
@@ -775,7 +775,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 	for (i = 0; i < len; i++) {
 		lo = inb(dev->iobase + PCL818_FI_DATALO);
 		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
-			rt_printk
+			printk
 				("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
 				(lo & 0xf),
 				devpriv->act_chanlist[devpriv->
@@ -818,7 +818,7 @@ static irqreturn_t interrupt_pcl818(int 
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
-	/* rt_printk("I\n"); */
+	/* printk("I\n"); */
 
 	if (devpriv->irq_blocked && devpriv->irq_was_now_closed) {
 		if ((devpriv->neverending_ai || (!devpriv->neverending_ai &&
@@ -882,7 +882,7 @@ static void pcl818_ai_mode13dma_int(int 
 	unsigned int flags;
 	unsigned int bytes;
 
-	rt_printk("mode13dma_int, mode: %d\n", mode);
+	printk("mode13dma_int, mode: %d\n", mode);
 	disable_dma(devpriv->dma);	/*  disable dma */
 	bytes = devpriv->hwdmasize[0];
 	if (!devpriv->neverending_ai) {
@@ -965,7 +965,7 @@ static int pcl818_ai_cmd_mode(int mode, 
 	int divisor1, divisor2;
 	unsigned int seglen;
 
-	rt_printk("pcl818_ai_cmd_mode()\n");
+	printk("pcl818_ai_cmd_mode()\n");
 	if ((!dev->irq) && (!devpriv->dma_rtc)) {
 		comedi_error(dev, "IRQ not defined!");
 		return -EINVAL;
@@ -983,7 +983,7 @@ static int pcl818_ai_cmd_mode(int mode, 
 	setup_channel_list(dev, s, devpriv->ai_chanlist,
 		devpriv->ai_n_chan, seglen);
 
-	comedi_udelay(1);
+	udelay(1);
 
 	devpriv->ai_act_scan = devpriv->ai_scans;
 	devpriv->ai_act_chan = 0;
@@ -1030,7 +1030,7 @@ static int pcl818_ai_cmd_mode(int mode, 
 	case 0:
 		if (!devpriv->usefifo) {
 			/* IRQ */
-			/* rt_printk("IRQ\n"); */
+			/* printk("IRQ\n"); */
 			if (mode == 1) {
 				devpriv->ai_mode = INT_TYPE_AI1_INT;
 				/* Pacer+IRQ */
@@ -1065,7 +1065,7 @@ static int pcl818_ai_cmd_mode(int mode, 
 		break;
 	}
 #endif
-	rt_printk("pcl818_ai_cmd_mode() end\n");
+	printk("pcl818_ai_cmd_mode() end\n");
 	return 0;
 }
 
@@ -1155,7 +1155,7 @@ static void start_pacer(struct comedi_de
 {
 	outb(0xb4, dev->iobase + PCL818_CTRCTL);
 	outb(0x74, dev->iobase + PCL818_CTRCTL);
-	comedi_udelay(1);
+	udelay(1);
 
 	if (mode == 1) {
 		outb(divisor2 & 0xff, dev->iobase + PCL818_CTR2);
@@ -1188,7 +1188,7 @@ static int check_channel_list(struct com
 		/*  build part of chanlist */
 		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {
 
-			/* rt_printk("%d. %d * %d\n",i,
+			/* printk("%d. %d * %d\n",i,
 			 * CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i]));*/
 
 			/* we detect loop, this must by finish */
@@ -1198,7 +1198,7 @@ static int check_channel_list(struct com
 			nowmustbechan =
 				(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
-				rt_printk
+				printk
 					("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					dev->minor, i, CR_CHAN(chanlist[i]),
 					nowmustbechan, CR_CHAN(chanlist[0]));
@@ -1210,9 +1210,9 @@ static int check_channel_list(struct com
 
 		/*  check whole chanlist */
 		for (i = 0, segpos = 0; i < n_chan; i++) {
-			/* rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
+			/* printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
-				rt_printk
+				printk
 					("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
 					dev->minor, i, CR_CHAN(chansegment[i]),
 					CR_RANGE(chansegment[i]),
@@ -1226,7 +1226,7 @@ static int check_channel_list(struct com
 	} else {
 		seglen = 1;
 	}
-	rt_printk("check_channel_list: seglen %d\n", seglen);
+	printk("check_channel_list: seglen %d\n", seglen);
 	return seglen;
 }
 
@@ -1244,7 +1244,7 @@ static void setup_channel_list(struct co
 		outb(CR_RANGE(chanlist[i]), dev->iobase + PCL818_RANGE);	/* select gain */
 	}
 
-	comedi_udelay(1);
+	udelay(1);
 
 	/* select channel interval to scan */
 	outb(devpriv->act_chanlist[0] | (devpriv->act_chanlist[seglen -
@@ -1417,7 +1417,7 @@ static int ai_cmd(struct comedi_device *
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
 
-	rt_printk("pcl818_ai_cmd()\n");
+	printk("pcl818_ai_cmd()\n");
 	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_flags = cmd->flags;
@@ -1436,7 +1436,7 @@ static int ai_cmd(struct comedi_device *
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 */
 			devpriv->ai_timer1 = cmd->convert_arg;
 			retval = pcl818_ai_cmd_mode(1, dev, s);
-			rt_printk("pcl818_ai_cmd() end\n");
+			printk("pcl818_ai_cmd() end\n");
 			return retval;
 		}
 		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
@@ -1454,7 +1454,7 @@ static int ai_cmd(struct comedi_device *
 static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (devpriv->irq_blocked > 0) {
-		rt_printk("pcl818_ai_cancel()\n");
+		printk("pcl818_ai_cancel()\n");
 		devpriv->irq_was_now_closed = 1;
 
 		switch (devpriv->ai_mode) {
@@ -1482,7 +1482,7 @@ static int pcl818_ai_cancel(struct comed
 		case INT_TYPE_AO3_INT:
 #endif
 			outb(inb(dev->iobase + PCL818_CONTROL) & 0x73, dev->iobase + PCL818_CONTROL);	/* Stop A/D */
-			comedi_udelay(1);
+			udelay(1);
 			start_pacer(dev, -1, 0, 0);
 			outb(0, dev->iobase + PCL818_AD_LO);
 			inb(dev->iobase + PCL818_AD_LO);
@@ -1504,7 +1504,7 @@ static int pcl818_ai_cancel(struct comed
 	}
 
       end:
-	rt_printk("pcl818_ai_cancel() end\n");
+	printk("pcl818_ai_cancel() end\n");
 	return 0;
 }
 
@@ -1515,17 +1515,17 @@ static int pcl818_ai_cancel(struct comed
 static int pcl818_check(unsigned long iobase)
 {
 	outb(0x00, iobase + PCL818_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL818_MUX) != 0x00)
 		return 1;	/* there isn't card */
 	outb(0x55, iobase + PCL818_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL818_MUX) != 0x55)
 		return 1;	/* there isn't card */
 	outb(0x00, iobase + PCL818_MUX);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0x18, iobase + PCL818_CONTROL);
-	comedi_udelay(1);
+	udelay(1);
 	if (inb(iobase + PCL818_CONTROL) != 0x18)
 		return 1;	/* there isn't card */
 	return 0;		/*  ok, card exist */
@@ -1544,10 +1544,10 @@ static void pcl818_reset(struct comedi_d
 	}
 	outb(0, dev->iobase + PCL818_DA_LO);	/*  DAC=0V */
 	outb(0, dev->iobase + PCL818_DA_HI);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0, dev->iobase + PCL818_DO_HI);	/*  DO=$0000 */
 	outb(0, dev->iobase + PCL818_DO_LO);
-	comedi_udelay(1);
+	udelay(1);
 	outb(0, dev->iobase + PCL818_CONTROL);
 	outb(0, dev->iobase + PCL818_CNTENABLE);
 	outb(0, dev->iobase + PCL818_MUX);
@@ -1658,7 +1658,7 @@ static int rtc_setfreq_irq(int freq)
 */
 static void free_resources(struct comedi_device *dev)
 {
-	/* rt_printk("free_resource()\n"); */
+	/* printk("free_resource()\n"); */
 	if (dev->private) {
 		pcl818_ai_cancel(dev, devpriv->sub_ai);
 		pcl818_reset(dev);
@@ -1670,7 +1670,7 @@ static void free_resources(struct comedi
 			free_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);
 #ifdef unused
 		if (devpriv->rtc_irq)
-			comedi_free_irq(devpriv->rtc_irq, dev);
+			free_irq(devpriv->rtc_irq, dev);
 		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
 			if (devpriv->rtc_iobase)
 				release_region(devpriv->rtc_iobase,
@@ -1685,7 +1685,7 @@ static void free_resources(struct comedi
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, devpriv->io_range);
-	/* rt_printk("free_resource() end\n"); */
+	/* printk("free_resource() end\n"); */
 }
 
 /*
@@ -1717,14 +1717,14 @@ static int pcl818_attach(struct comedi_d
 		devpriv->usefifo = 1;
 	}
 	if (!request_region(iobase, devpriv->io_range, "pcl818")) {
-		rt_printk("I/O port conflict\n");
+		printk("I/O port conflict\n");
 		return -EIO;
 	}
 
 	dev->iobase = iobase;
 
 	if (pcl818_check(iobase)) {
-		rt_printk(", I can't detect board. FAIL!\n");
+		printk(", I can't detect board. FAIL!\n");
 		return -EIO;
 	}
 
@@ -1736,19 +1736,18 @@ static int pcl818_attach(struct comedi_d
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
-				rt_printk
+				printk
 					(", IRQ %u is out of allowed range, DISABLING IT",
 					irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (comedi_request_irq(irq, interrupt_pcl818, 0,
-						"pcl818", dev)) {
-					rt_printk
+				if (request_irq(irq, interrupt_pcl818, 0, "pcl818", dev)) {
+					printk
 						(", unable to allocate IRQ %u, DISABLING IT",
 						irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
-					rt_printk(", irq=%u", irq);
+					printk(", irq=%u", irq);
 				}
 			}
 		}
@@ -1776,12 +1775,11 @@ static int pcl818_attach(struct comedi_d
 		devpriv->rtc_iobase = RTC_PORT(0);
 		devpriv->rtc_iosize = RTC_IO_EXTENT;
 		RTC_lock++;
-		if (!comedi_request_irq(RTC_IRQ,
-				interrupt_pcl818_ai_mode13_dma_rtc, 0,
+		if (!request_irq(RTC_IRQ, interrupt_pcl818_ai_mode13_dma_rtc, 0,
 				"pcl818 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
-			rt_printk(", dma_irq=%u", devpriv->rtc_irq);
+			printk(", dma_irq=%u", devpriv->rtc_irq);
 		} else {
 			RTC_lock--;
 			if (RTC_lock == 0) {
@@ -1806,31 +1804,31 @@ static int pcl818_attach(struct comedi_d
 		if (dma < 1)
 			goto no_dma;	/* DMA disabled */
 		if (((1 << dma) & this_board->DMAbits) == 0) {
-			rt_printk(", DMA is out of allowed range, FAIL!\n");
+			printk(", DMA is out of allowed range, FAIL!\n");
 			return -EINVAL;	/* Bad DMA */
 		}
 		ret = request_dma(dma, "pcl818");
 		if (ret) {
-			rt_printk(", unable to allocate DMA %u, FAIL!\n", dma);
+			printk(", unable to allocate DMA %u, FAIL!\n", dma);
 			return -EBUSY;	/* DMA isn't free */
 		}
 		devpriv->dma = dma;
-		rt_printk(", dma=%u", dma);
+		printk(", dma=%u", dma);
 		pages = 2;	/* we need 16KB */
 		devpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);
 		if (!devpriv->dmabuf[0]) {
-			rt_printk(", unable to allocate DMA buffer, FAIL!\n");
+			printk(", unable to allocate DMA buffer, FAIL!\n");
 			/* maybe experiment with try_to_free_pages() will help .... */
 			return -EBUSY;	/* no buffer :-( */
 		}
 		devpriv->dmapages[0] = pages;
 		devpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);
 		devpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;
-		/* rt_printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
+		/* printk("%d %d %ld, ",devpriv->dmapages[0],devpriv->hwdmasize[0],PAGE_SIZE); */
 		if (devpriv->dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
-				rt_printk
+				printk
 					(", unable to allocate DMA buffer, FAIL!\n");
 				return -EBUSY;
 			}
@@ -1989,7 +1987,7 @@ static int pcl818_attach(struct comedi_d
 
 	pcl818_reset(dev);
 
-	rt_printk("\n");
+	printk("\n");
 
 	return 0;
 }
@@ -2000,7 +1998,7 @@ static int pcl818_attach(struct comedi_d
  */
 static int pcl818_detach(struct comedi_device *dev)
 {
-	/*   rt_printk("comedi%d: pcl818: remove\n", dev->minor); */
+	/*   printk("comedi%d: pcl818: remove\n", dev->minor); */
 	free_resources(dev);
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -364,7 +364,7 @@ static int pcmmio_attach(struct comedi_d
 			dev->iobase + 16 + asic * ASIC_IOSIZE;
 		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
 						   this function when we
-						   comedi_request_irqs */
+						   request_irqs */
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
@@ -489,12 +489,12 @@ static int pcmmio_attach(struct comedi_d
 
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
-			&& comedi_request_irq(irq[asic], interrupt_pcmmio,
+			&& request_irq(irq[asic], interrupt_pcmmio,
 				IRQF_SHARED, thisboard->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
-				comedi_free_irq(irq[i], dev);
+				free_irq(irq[i], dev);
 				devpriv->asics[i].irq = irq[i] = 0;
 			}
 			irq[asic] = 0;
@@ -536,7 +536,7 @@ static int pcmmio_detach(struct comedi_d
 
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv && devpriv->asics[i].irq)
-			comedi_free_irq(devpriv->asics[i].irq, dev);
+			free_irq(devpriv->asics[i].irq, dev);
 	}
 
 	if (devpriv && devpriv->sprivs)
@@ -778,8 +778,7 @@ static irqreturn_t interrupt_pcmmio(int 
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			comedi_spin_lock_irqsave(&devpriv->asics[asic].spinlock,
-				flags);
+			spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
@@ -811,8 +810,7 @@ static irqreturn_t interrupt_pcmmio(int 
 				++got1;
 			}
 
-			comedi_spin_unlock_irqrestore(&devpriv->asics[asic].
-				spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->asics[asic].  spinlock, flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
@@ -825,9 +823,7 @@ static irqreturn_t interrupt_pcmmio(int 
 						unsigned long flags;
 						unsigned oldevents;
 
-						comedi_spin_lock_irqsave
-							(&subpriv->dio.intr.
-							spinlock, flags);
+						spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 
 						oldevents = s->async->events;
 
@@ -896,9 +892,7 @@ static irqreturn_t interrupt_pcmmio(int 
 							}
 						}
 
-						comedi_spin_unlock_irqrestore
-							(&subpriv->dio.intr.
-							spinlock, flags);
+						spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
 						if (oldevents !=
 							s->async->events) {
@@ -1001,10 +995,10 @@ static int pcmmio_cancel(struct comedi_d
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 	if (subpriv->dio.intr.active)
 		pcmmio_stop_intr(dev, s);
-	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
 	return 0;
 }
@@ -1022,12 +1016,12 @@ pcmmio_inttrig_start_intr(struct comedi_
 	if (trignum != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 	s->async->inttrig = 0;
 	if (subpriv->dio.intr.active) {
 		event = pcmmio_start_intr(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
@@ -1045,7 +1039,7 @@ static int pcmmio_cmd(struct comedi_devi
 	unsigned long flags;
 	int event = 0;
 
-	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 	subpriv->dio.intr.active = 1;
 
 	/* Set up end of acquisition. */
@@ -1071,7 +1065,7 @@ static int pcmmio_cmd(struct comedi_devi
 		event = pcmmio_start_intr(dev, s);
 		break;
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -322,7 +322,7 @@ static int pcmuio_attach(struct comedi_d
 		devpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;
 		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
 						   this function when we
-						   comedi_request_irqs */
+						   request_irqs */
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
@@ -413,12 +413,12 @@ static int pcmuio_attach(struct comedi_d
 
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
-			&& comedi_request_irq(irq[asic], interrupt_pcmuio,
+			&& request_irq(irq[asic], interrupt_pcmuio,
 				IRQF_SHARED, thisboard->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
-				comedi_free_irq(irq[i], dev);
+				free_irq(irq[i], dev);
 				devpriv->asics[i].irq = irq[i] = 0;
 			}
 			irq[asic] = 0;
@@ -460,7 +460,7 @@ static int pcmuio_detach(struct comedi_d
 
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv->asics[i].irq)
-			comedi_free_irq(devpriv->asics[i].irq, dev);
+			free_irq(devpriv->asics[i].irq, dev);
 	}
 
 	if (devpriv && devpriv->sprivs)
@@ -701,8 +701,7 @@ static irqreturn_t interrupt_pcmuio(int 
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			comedi_spin_lock_irqsave(&devpriv->asics[asic].spinlock,
-				flags);
+			spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
@@ -734,8 +733,7 @@ static irqreturn_t interrupt_pcmuio(int 
 				++got1;
 			}
 
-			comedi_spin_unlock_irqrestore(&devpriv->asics[asic].
-				spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock, flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
@@ -748,9 +746,7 @@ static irqreturn_t interrupt_pcmuio(int 
 						unsigned long flags;
 						unsigned oldevents;
 
-						comedi_spin_lock_irqsave
-							(&subpriv->intr.
-							spinlock, flags);
+						spin_lock_irqsave (&subpriv->intr.spinlock, flags);
 
 						oldevents = s->async->events;
 
@@ -816,9 +812,7 @@ static irqreturn_t interrupt_pcmuio(int 
 							}
 						}
 
-						comedi_spin_unlock_irqrestore
-							(&subpriv->intr.
-							spinlock, flags);
+						spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
 						if (oldevents !=
 							s->async->events) {
@@ -911,10 +905,10 @@ static int pcmuio_cancel(struct comedi_d
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
 	if (subpriv->intr.active)
 		pcmuio_stop_intr(dev, s);
-	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
 	return 0;
 }
@@ -932,12 +926,12 @@ pcmuio_inttrig_start_intr(struct comedi_
 	if (trignum != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
 	s->async->inttrig = 0;
 	if (subpriv->intr.active) {
 		event = pcmuio_start_intr(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
@@ -955,7 +949,7 @@ static int pcmuio_cmd(struct comedi_devi
 	unsigned long flags;
 	int event = 0;
 
-	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
 	subpriv->intr.active = 1;
 
 	/* Set up end of acquisition. */
@@ -981,7 +975,7 @@ static int pcmuio_cmd(struct comedi_devi
 		event = pcmuio_start_intr(dev, s);
 		break;
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
--- a/drivers/staging/comedi/drivers/plx9080.h
+++ b/drivers/staging/comedi/drivers/plx9080.h
@@ -399,11 +399,11 @@ static inline int plx9080_abort_dma(void
 
 	/*  wait to make sure done bit is zero */
 	for (i = 0; (dma_status & PLX_DMA_DONE_BIT) && i < timeout; i++) {
-		comedi_udelay(1);
+		udelay(1);
 		dma_status = readb(dma_cs_addr);
 	}
 	if (i == timeout) {
-		rt_printk
+		printk
 			("plx9080: cancel() timed out waiting for dma %i done clear\n",
 			channel);
 		return -ETIMEDOUT;
@@ -413,11 +413,11 @@ static inline int plx9080_abort_dma(void
 	/*  wait for dma done bit */
 	dma_status = readb(dma_cs_addr);
 	for (i = 0; (dma_status & PLX_DMA_DONE_BIT) == 0 && i < timeout; i++) {
-		comedi_udelay(1);
+		udelay(1);
 		dma_status = readb(dma_cs_addr);
 	}
 	if (i == timeout) {
-		rt_printk
+		printk
 			("plx9080: cancel() timed out waiting for dma %i done set\n",
 			channel);
 		return -ETIMEDOUT;
--- a/drivers/staging/comedi/drivers/rtd520.c
+++ b/drivers/staging/comedi/drivers/rtd520.c
@@ -135,7 +135,7 @@ Configuration options:
 #define RTD_DMA_TIMEOUT	33000	/* 1 msec */
 #else
 /* by delaying, power and electrical noise are reduced somewhat */
-#define WAIT_QUIETLY	comedi_udelay (1)
+#define WAIT_QUIETLY	udelay (1)
 #define RTD_ADC_TIMEOUT	2000	/* in usec */
 #define RTD_DAC_TIMEOUT	2000	/* in usec */
 #define RTD_DMA_TIMEOUT	1000	/* in usec */
@@ -900,7 +900,7 @@ static int rtd_attach(struct comedi_devi
 	/* initialize board, per RTD spec */
 	/* also, initialize shadow registers */
 	RtdResetBoard(dev);
-	comedi_udelay(100);	/* needed? */
+	udelay(100);	/* needed? */
 	RtdPlxInterruptWrite(dev, 0);
 	RtdInterruptMask(dev, 0);	/* and sets shadow */
 	RtdInterruptClearMask(dev, ~0);	/* and sets shadow */
@@ -919,7 +919,7 @@ static int rtd_attach(struct comedi_devi
 	/* TODO: set user out source ??? */
 
 	/* check if our interrupt is available and get it */
-	ret = comedi_request_irq(devpriv->pci_dev->irq, rtd_interrupt,
+	ret = request_irq(devpriv->pci_dev->irq, rtd_interrupt,
 				 IRQF_SHARED, DRV_NAME, dev);
 
 	if (ret < 0) {
@@ -1032,7 +1032,7 @@ static int rtd_attach(struct comedi_devi
 		/* disable interrupt controller */
 		RtdPlxInterruptWrite(dev, RtdPlxInterruptRead(dev)
 			& ~(ICS_PLIE | ICS_DMA0_E | ICS_DMA1_E));
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 
 	/* release all regions that were allocated */
@@ -1111,7 +1111,7 @@ static int rtd_detach(struct comedi_devi
 			/* disable interrupt controller */
 			RtdPlxInterruptWrite(dev, RtdPlxInterruptRead(dev)
 				& ~(ICS_PLIE | ICS_DMA0_E | ICS_DMA1_E));
-			comedi_free_irq(dev->irq, dev);
+			free_irq(dev->irq, dev);
 		}
 
 		/* release all regions that were allocated */
@@ -1224,7 +1224,7 @@ static int rtd520_probe_fifo_depth(struc
 		unsigned fifo_status;
 		/* trigger conversion */
 		RtdAdcStart(dev);
-		comedi_udelay(1);
+		udelay(1);
 		fifo_status = RtdFifoStatus(dev);
 		if ((fifo_status & FS_ADC_HEMPTY) == 0) {
 			fifo_size = 2 * i;
@@ -1233,13 +1233,13 @@ static int rtd520_probe_fifo_depth(struc
 	}
 	if (i == limit)
 	{
-		rt_printk("\ncomedi: %s: failed to probe fifo size.\n", DRV_NAME);
+		printk("\ncomedi: %s: failed to probe fifo size.\n", DRV_NAME);
 		return -EIO;
 	}
 	RtdAdcClearFifo(dev);
 	if (fifo_size != 0x400 && fifo_size != 0x2000)
 	{
-		rt_printk("\ncomedi: %s: unexpected fifo size of %i, expected 1024 or 8192.\n",
+		printk("\ncomedi: %s: unexpected fifo size of %i, expected 1024 or 8192.\n",
 			DRV_NAME, fifo_size);
 		return -EIO;
 	}
@@ -1386,7 +1386,7 @@ void abort_dma(struct comedi_device *dev
 		+ ((channel == 0) ? LCFG_DMACSR0 : LCFG_DMACSR1);
 
 	/*  spinlock for plx dma control/status reg */
-	/* comedi_spin_lock_irqsave( &dev->spinlock, flags ); */
+	/* spin_lock_irqsave( &dev->spinlock, flags ); */
 
 	/*  abort dma transfer if necessary */
 	status = readb(dma_cs_addr);
@@ -1409,7 +1409,7 @@ void abort_dma(struct comedi_device *dev
 
 	/* disable channel (required) */
 	writeb(0, dma_cs_addr);
-	comedi_udelay(1);	/* needed?? */
+	udelay(1);	/* needed?? */
 	/* set abort bit for channel */
 	writeb(PLX_DMA_ABORT_BIT, dma_cs_addr);
 
@@ -1427,7 +1427,7 @@ void abort_dma(struct comedi_device *dev
 	}
 
       abortDmaExit:
-	/* comedi_spin_unlock_irqrestore( &dev->spinlock, flags ); */
+	/* spin_unlock_irqrestore( &dev->spinlock, flags ); */
 }
 
 /*
--- a/drivers/staging/comedi/drivers/rti800.c
+++ b/drivers/staging/comedi/drivers/rti800.c
@@ -200,7 +200,7 @@ static int rti800_ai_insn_read(struct co
 		 * gets set, and you will have an error. */
 		if (insn->n > 0) {
 			BUG_ON(gain >= ARRAY_SIZE(gaindelay));
-			comedi_udelay(gaindelay[gain]);
+			udelay(gaindelay[gain]);
 		}
 	}
 
@@ -209,16 +209,16 @@ static int rti800_ai_insn_read(struct co
 		for (t = RTI800_TIMEOUT; t; t--) {
 			status = inb(dev->iobase + RTI800_CSR);
 			if (status & RTI800_OVERRUN) {
-				rt_printk("rti800: a/d overrun\n");
+				printk("rti800: a/d overrun\n");
 				outb(0, dev->iobase + RTI800_CLRFLAGS);
 				return -EIO;
 			}
 			if (status & RTI800_DONE)
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (t == 0) {
-			rt_printk("rti800: timeout\n");
+			printk("rti800: timeout\n");
 			return -ETIME;
 		}
 		data[i] = inb(dev->iobase + RTI800_ADCLO);
@@ -338,8 +338,7 @@ static int rti800_attach(struct comedi_d
 	irq = it->options[1];
 	if (irq) {
 		printk("( irq = %u )", irq);
-		ret = comedi_request_irq(irq, rti800_interrupt, 0,
-					 "rti800", dev);
+		ret = request_irq(irq, rti800_interrupt, 0, "rti800", dev);
 		if (ret < 0) {
 			printk(" Failed to allocate IRQ\n");
 			return ret;
@@ -455,7 +454,7 @@ static int rti800_detach(struct comedi_d
 		release_region(dev->iobase, RTI800_SIZE);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -850,9 +850,9 @@ static int s526_ai_rinsn(struct comedi_d
 			}
 		}
 		if (i == TIMEOUT) {
-			/* rt_printk() should be used instead of printk()
+			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
-			rt_printk("s526: ADC(0x%04x) timeout\n",
+			printk("s526: ADC(0x%04x) timeout\n",
 				inw(ADDR_REG(REG_ISR)));
 			return -ETIMEDOUT;
 		}
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -596,8 +596,8 @@ static int s626_attach(struct comedi_dev
 	if (dev->irq == 0) {
 		printk(" unknown irq (bad)\n");
 	} else {
-		ret = comedi_request_irq(dev->irq, s626_irq_handler,
-					 IRQF_SHARED, "s626", dev);
+		ret = request_irq(dev->irq, s626_irq_handler, IRQF_SHARED,
+				  "s626", dev);
 
 		if (ret < 0) {
 			printk(" irq not available\n");
@@ -987,7 +987,7 @@ static irqreturn_t s626_irq_handler(int 
 	if (dev->attached == 0)
 		return IRQ_NONE;
 	/*  lock to avoid race with comedi_poll */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	/* save interrupt enable register state */
 	irqstatus = readl(devpriv->base_addr + P_IER);
@@ -1264,7 +1264,7 @@ static irqreturn_t s626_irq_handler(int 
 
 	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 	return IRQ_HANDLED;
 }
 
@@ -1291,7 +1291,7 @@ static int s626_detach(struct comedi_dev
 		}
 
 		if (dev->irq)
-			comedi_free_irq(dev->irq, dev);
+			free_irq(dev->irq, dev);
 
 		if (devpriv->base_addr)
 			iounmap(devpriv->base_addr);
@@ -1574,7 +1574,7 @@ static int s626_ai_insn_read(struct come
 	for (n = 0; n < insn->n; n++) {
 
 		/*  Delay 10 microseconds for analog input settling. */
-		comedi_udelay(10);
+		udelay(10);
 
 		/*  Start ADC by pulsing GPIO1 low. */
 		GpioImage = RR7146(P_GPIO);
@@ -1606,7 +1606,7 @@ static int s626_ai_insn_read(struct come
 		 * data value is sometimes set to the previous
 		 * conversion's data value.
 		 */
-		comedi_udelay(4);
+		udelay(4);
 	}
 
 	/* Start a dummy conversion to cause the data from the
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -63,7 +63,7 @@
 */
 
 #ifdef _DEBUG_
-#define DEBUG(...);        rt_printk(__VA_ARGS__);
+#define DEBUG(...);        printk(__VA_ARGS__);
 #else
 #define DEBUG(...)
 #endif
--- a/drivers/staging/comedi/drivers/serial2002.c
+++ b/drivers/staging/comedi/drivers/serial2002.c
@@ -223,7 +223,7 @@ static int tty_read(struct file *f, int 
 					result = ch;
 					break;
 				}
-				comedi_udelay(100);
+				udelay(100);
 			}
 		}
 		set_fs(oldfs);
--- a/drivers/staging/comedi/drivers/skel.c
+++ b/drivers/staging/comedi/drivers/skel.c
@@ -331,9 +331,9 @@ static int skel_ai_rinsn(struct comedi_d
 				break;
 		}
 		if (i == TIMEOUT) {
-			/* rt_printk() should be used instead of printk()
+			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
-			rt_printk("timeout\n");
+			printk("timeout\n");
 			return -ETIMEDOUT;
 		}
 
--- a/drivers/staging/comedi/drivers/unioxx5.c
+++ b/drivers/staging/comedi/drivers/unioxx5.c
@@ -311,7 +311,7 @@ static int __unioxx5_subdev_init(struct 
 			usp->usp_module_type[i] = inb(subdev_iobase + 6);
 
 		printk(" [%d] 0x%02x |", i, usp->usp_module_type[i]);
-		comedi_udelay(1);
+		udelay(1);
 	}
 
 	printk("\n");
--- a/drivers/staging/comedi/kcomedilib/data.c
+++ b/drivers/staging/comedi/kcomedilib/data.c
@@ -23,7 +23,7 @@
 
 #include "../comedi.h"
 #include "../comedilib.h"
-#include "../comedidev.h"	/* for comedi_udelay() */
+#include "../comedidev.h"
 
 #include <linux/string.h>
 
@@ -83,7 +83,7 @@ int comedi_data_read_delayed(void *dev, 
 	if (retval < 0)
 		return retval;
 
-	comedi_udelay((nano_sec + 999) / 1000);
+	udelay((nano_sec + 999) / 1000);
 
 	return comedi_data_read(dev, subdev, chan, range, aref, data);
 }
--- a/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
+++ b/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
@@ -105,7 +105,7 @@ int comedi_loglevel(int newlevel)
 
 void comedi_perror(const char *message)
 {
-	rt_printk("%s: unknown error\n", message);
+	printk("%s: unknown error\n", message);
 }
 
 char *comedi_strerror(int err)
@@ -208,7 +208,7 @@ int comedi_do_insn(void *d, struct comed
 				ret = -EINVAL;
 				break;
 			}
-			comedi_udelay(insn->data[0]);
+			udelay(insn->data[0]);
 			ret = 1;
 			break;
 		case INSN_INTTRIG:
@@ -217,19 +217,19 @@ int comedi_do_insn(void *d, struct comed
 				break;
 			}
 			if (insn->subdev >= dev->n_subdevices) {
-				rt_printk("%d not usable subdevice\n",
+				printk("%d not usable subdevice\n",
 					insn->subdev);
 				ret = -EINVAL;
 				break;
 			}
 			s = dev->subdevices + insn->subdev;
 			if (!s->async) {
-				rt_printk("no async\n");
+				printk("no async\n");
 				ret = -EINVAL;
 				break;
 			}
 			if (!s->async->inttrig) {
-				rt_printk("no inttrig\n");
+				printk("no inttrig\n");
 				ret = -EAGAIN;
 				break;
 			}
@@ -249,7 +249,7 @@ int comedi_do_insn(void *d, struct comed
 		s = dev->subdevices + insn->subdev;
 
 		if (s->type == COMEDI_SUBD_UNUSED) {
-			rt_printk("%d not useable subdevice\n", insn->subdev);
+			printk("%d not useable subdevice\n", insn->subdev);
 			ret = -EIO;
 			goto error;
 		}
@@ -258,7 +258,7 @@ int comedi_do_insn(void *d, struct comed
 
 		ret = check_chanlist(s, 1, &insn->chanspec);
 		if (ret < 0) {
-			rt_printk("bad chanspec\n");
+			printk("bad chanspec\n");
 			ret = -EINVAL;
 			goto error;
 		}
@@ -295,7 +295,7 @@ int comedi_do_insn(void *d, struct comed
 #if 0
 	/* XXX do we want this? -- abbotti #if'ed it out for now. */
 	if (ret != insn->n) {
-		rt_printk("BUG: result of insn != insn.n\n");
+		printk("BUG: result of insn != insn.n\n");
 		ret = -EINVAL;
 		goto error;
 	}
@@ -336,7 +336,7 @@ int comedi_lock(void *d, unsigned int su
 
 	s = dev->subdevices + subdevice;
 
-	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	spin_lock_irqsave(&s->spin_lock, flags);
 
 	if (s->busy) {
 		ret = -EBUSY;
@@ -348,7 +348,7 @@ int comedi_lock(void *d, unsigned int su
 		}
 	}
 
-	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
 
 	return ret;
 }
@@ -382,7 +382,7 @@ int comedi_unlock(void *d, unsigned int 
 
 	async = s->async;
 
-	comedi_spin_lock_irqsave(&s->spin_lock, flags);
+	spin_lock_irqsave(&s->spin_lock, flags);
 
 	if (s->busy) {
 		ret = -EBUSY;
@@ -400,7 +400,7 @@ int comedi_unlock(void *d, unsigned int 
 		ret = 0;
 	}
 
-	comedi_spin_unlock_irqrestore(&s->spin_lock, flags);
+	spin_unlock_irqrestore(&s->spin_lock, flags);
 
 	return ret;
 }
--- a/drivers/staging/comedi/range.c
+++ b/drivers/staging/comedi/range.c
@@ -130,8 +130,7 @@ int check_chanlist(struct comedi_subdevi
 			if (CR_CHAN(chanlist[i]) >= s->n_chan ||
 				CR_RANGE(chanlist[i]) >= s->range_table->length
 				|| aref_invalid(s, chanlist[i])) {
-				rt_printk
-					("bad chanlist[%d]=0x%08x n_chan=%d range length=%d\n",
+				printk("bad chanlist[%d]=0x%08x n_chan=%d range length=%d\n",
 					i, chanlist[i], s->n_chan,
 					s->range_table->length);
 #if 0
@@ -147,13 +146,13 @@ int check_chanlist(struct comedi_subdevi
 				CR_RANGE(chanlist[i]) >=
 				s->range_table_list[chan]->length
 				|| aref_invalid(s, chanlist[i])) {
-				rt_printk("bad chanlist[%d]=0x%08x\n", i,
+				printk("bad chanlist[%d]=0x%08x\n", i,
 					chanlist[i]);
 				return -EINVAL;
 			}
 		}
 	} else {
-		rt_printk("comedi: (bug) no range type list!\n");
+		printk("comedi: (bug) no range type list!\n");
 		return -EINVAL;
 	}
 	return 0;
