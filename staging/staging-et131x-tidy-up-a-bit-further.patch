From alan@linux.intel.com  Mon Oct 26 14:56:43 2009
From: Alan Cox <alan@linux.intel.com>
Date: Tue, 06 Oct 2009 15:49:29 +0100
Subject: Staging: et131x: tidy up a bit further
To: greg@kroah.com
Message-ID: <20091006144926.8604.11514.stgit@localhost.localdomain>


Clean up the minor uglies left from the previous work

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/et131x/et1310_tx.c      |   67 +++++++-------------------------
 drivers/staging/et131x/et131x_adapter.h |    6 --
 2 files changed, 16 insertions(+), 57 deletions(-)

--- a/drivers/staging/et131x/et1310_tx.c
+++ b/drivers/staging/et131x/et1310_tx.c
@@ -94,7 +94,6 @@
 #include "et1310_tx.h"
 
 
-static void et131x_update_tcb_list(struct et131x_adapter *etdev);
 static inline void et131x_free_send_packet(struct et131x_adapter *etdev,
 					   struct tcb *tcb);
 static int et131x_send_packet(struct sk_buff *skb,
@@ -230,15 +229,10 @@ void ConfigTxDmaRegs(struct et131x_adapt
 	/* Initialise the transmit DMA engine */
 	writel(NUM_DESC_PER_RING_TX - 1, &txdma->pr_num_des.value);
 
-	/* Load the completion writeback physical address
-	 *
-	 * NOTE: pci_alloc_consistent(), used above to alloc DMA regions,
-	 * ALWAYS returns SAC (32-bit) addresses. If DAC (64-bit) addresses
-	 * are ever returned, make sure the high part is retrieved here before
-	 * storing the adjusted address.
-	 */
-	writel(0, &txdma->dma_wb_base_hi);
-	writel(etdev->tx_ring.pTxStatusPa, &txdma->dma_wb_base_lo);
+	/* Load the completion writeback physical address */
+	writel((u32)((u64)etdev->tx_ring.pTxStatusPa >> 32),
+						&txdma->dma_wb_base_hi);
+	writel((u32)etdev->tx_ring.pTxStatusPa, &txdma->dma_wb_base_lo);
 
 	memset(etdev->tx_ring.pTxStatusVa, 0, sizeof(TX_STATUS_BLOCK_t));
 
@@ -279,7 +273,7 @@ void et131x_tx_dma_enable(struct et131x_
 void et131x_init_send(struct et131x_adapter *adapter)
 {
 	struct tcb *tcb;
-	u32 count;
+	u32 ct;
 	struct tx_ring *tx_ring;
 
 	/* Setup some convenience pointers */
@@ -289,23 +283,22 @@ void et131x_init_send(struct et131x_adap
 	tx_ring->TCBReadyQueueHead = tcb;
 
 	/* Go through and set up each TCB */
-	for (count = 0; count < NUM_TCB; count++) {
+	for (ct = 0; ct < NUM_TCB; ct++) {
 		memset(tcb, 0, sizeof(struct tcb));
 
 		/* Set the link pointer in HW TCB to the next TCB in the
 		 * chain.  If this is the last TCB in the chain, also set the
 		 * tail pointer.
 		 */
-		if (count < NUM_TCB - 1) {
+		if (ct < NUM_TCB - 1)
 			tcb->Next = tcb + 1;
-		} else {
+		else {
 			tx_ring->TCBReadyQueueTail = tcb;
 			tcb->Next = NULL;
 		}
 
 		tcb++;
 	}
-
 	/* Curr send queue should now be empty */
 	tx_ring->CurrSendHead = NULL;
 	tx_ring->CurrSendTail = NULL;
@@ -332,7 +325,7 @@ int et131x_send_packets(struct sk_buff *
 	 */
 
 	/* TCB is not available */
-	if (MP_TCB_RESOURCES_NOT_AVAILABLE(etdev)) {
+	if (etdev->tx_ring.nBusySend >= NUM_TCB) {
 		/* NOTE: If there's an error on send, no need to queue the
 		 * packet under Linux; if we just send an error up to the
 		 * netif layer, it will resend the skb to us.
@@ -342,26 +335,15 @@ int et131x_send_packets(struct sk_buff *
 		/* We need to see if the link is up; if it's not, make the
 		 * netif layer think we're good and drop the packet
 		 */
-		/*
-		 * if( MP_SHOULD_FAIL_SEND( etdev ) ||
-		 *  etdev->DriverNoPhyAccess )
-		 */
-		if (MP_SHOULD_FAIL_SEND(etdev) || !netif_carrier_ok(netdev)) {
+		if ((etdev->Flags & fMP_ADAPTER_FAIL_SEND_MASK) ||
+					!netif_carrier_ok(netdev)) {
 			dev_kfree_skb_any(skb);
 			skb = NULL;
 
 			etdev->net_stats.tx_dropped++;
 		} else {
 			status = et131x_send_packet(skb, etdev);
-
-			if (status == -ENOMEM) {
-
-				/* NOTE: If there's an error on send, no need
-				 * to queue the packet under Linux; if we just
-				 * send an error up to the netif layer, it
-				 * will resend the skb to us.
-				 */
-			} else if (status != 0) {
+			if (status != 0 && status != -ENOMEM) {
 				/* On any other error, make netif think we're
 				 * OK and drop the packet
 				 */
@@ -386,7 +368,7 @@ int et131x_send_packets(struct sk_buff *
 static int et131x_send_packet(struct sk_buff *skb,
 			      struct et131x_adapter *etdev)
 {
-	int status = 0;
+	int status;
 	struct tcb *tcb = NULL;
 	u16 *shbufva;
 	unsigned long flags;
@@ -429,8 +411,7 @@ static int et131x_send_packet(struct sk_
 	tcb->Next = NULL;
 
 	/* Call the NIC specific send handler. */
-	if (status == 0)
-		status = nic_send_packet(etdev, tcb);
+	status = nic_send_packet(etdev, tcb);
 
 	if (status != 0) {
 		spin_lock_irqsave(&etdev->TCBReadyQLock, flags);
@@ -725,12 +706,11 @@ inline void et131x_free_send_packet(stru
 
 	etdev->Stats.opackets++;
 
-	if (etdev->tx_ring.TCBReadyQueueTail) {
+	if (etdev->tx_ring.TCBReadyQueueTail)
 		etdev->tx_ring.TCBReadyQueueTail->Next = tcb;
-	} else {
+	else
 		/* Apparently ready Q is empty. */
 		etdev->tx_ring.TCBReadyQueueHead = tcb;
-	}
 
 	etdev->tx_ring.TCBReadyQueueTail = tcb;
 
@@ -747,7 +727,6 @@ inline void et131x_free_send_packet(stru
 void et131x_free_busy_send_packets(struct et131x_adapter *etdev)
 {
 	struct tcb *tcb;
-	struct list_head *entry;
 	unsigned long flags;
 	u32 freed = 0;
 
@@ -794,20 +773,6 @@ void et131x_free_busy_send_packets(struc
  */
 void et131x_handle_send_interrupt(struct et131x_adapter *etdev)
 {
-	/* Mark as completed any packets which have been sent by the device. */
-	et131x_update_tcb_list(etdev);
-}
-
-/**
- * et131x_update_tcb_list - Helper routine for Send Interrupt handler
- * @etdev: pointer to our adapter
- *
- * Re-claims the send resources and completes sends.  Can also be called as
- * part of the NIC send routine when the "ServiceComplete" indication has
- * wrapped.
- */
-static void et131x_update_tcb_list(struct et131x_adapter *etdev)
-{
 	unsigned long flags;
 	u32 serviced;
 	struct tcb * tcb;
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -100,12 +100,6 @@
 #define LO_MARK_PERCENT_FOR_PSR     15
 #define LO_MARK_PERCENT_FOR_RX      15
 
-/* Macros specific to the private adapter structure */
-#define MP_TCB_RESOURCES_AVAILABLE(_M) ((_M)->tx_ring.nBusySend < NUM_TCB)
-#define MP_TCB_RESOURCES_NOT_AVAILABLE(_M) ((_M)->tx_ring.nBusySend >= NUM_TCB)
-
-#define MP_SHOULD_FAIL_SEND(_M)   ((_M)->Flags & fMP_ADAPTER_FAIL_SEND_MASK)
-
 /* Counters for error rate monitoring */
 typedef struct _MP_ERR_COUNTERS {
 	u32 PktCountTxPackets;
