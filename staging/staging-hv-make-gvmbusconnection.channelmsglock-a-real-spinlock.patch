From foo@baz Wed Jul 15 14:56:45 PDT 2009
Date: Wed, 15 Jul 2009 14:56:45 -0700
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Staging: hv: make gVmbusConnection.ChannelMsgLock a real spinlock

From: Greg Kroah-Hartman <gregkh@suse.de>

Don't use the wrapper functions for this lock, make it a real
lock so that we know what is going on.

I don't think we really want to be doing a irqsave for this code, but I
left it alone to preserve the original codepath.  It should be reviewed
later.

Cc: Hank Janssen <hjanssen@microsoft.com>
Cc: Haiyang Zhang <haiyangz@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/hv/Channel.c      |   27 +++++++++++++++------------
 drivers/staging/hv/ChannelMgmt.c  |   20 ++++++++++++--------
 drivers/staging/hv/Connection.c   |   10 ++++------
 drivers/staging/hv/VmbusPrivate.h |    2 +-
 4 files changed, 32 insertions(+), 27 deletions(-)

--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -214,6 +214,7 @@ VmbusChannelOpen(
 	VMBUS_CHANNEL_OPEN_CHANNEL* openMsg;
 	VMBUS_CHANNEL_MSGINFO* openInfo;
 	void *in, *out;
+	unsigned long flags;
 
 	DPRINT_ENTER(VMBUS);
 
@@ -280,9 +281,9 @@ VmbusChannelOpen(
 		memcpy(openMsg->UserData, UserData, UserDataLen);
 	}
 
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 	INSERT_TAIL_LIST(&gVmbusConnection.ChannelMsgList, &openInfo->MsgListEntry);
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_DBG(VMBUS, "Sending channel open msg...");
 
@@ -306,9 +307,9 @@ VmbusChannelOpen(
 	}
 
 Cleanup:
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 	REMOVE_ENTRY_LIST(&openInfo->MsgListEntry);
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	WaitEventClose(openInfo->WaitEvent);
 	kfree(openInfo);
@@ -531,6 +532,7 @@ VmbusChannelEstablishGpadl(
 	LIST_ENTRY* anchor;
 	LIST_ENTRY* curr;
 	u32 nextGpadlHandle;
+	unsigned long flags;
 
 	DPRINT_ENTER(VMBUS);
 
@@ -549,9 +551,9 @@ VmbusChannelEstablishGpadl(
 
 	DumpGpadlHeader(gpadlMsg);
 
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 	INSERT_TAIL_LIST(&gVmbusConnection.ChannelMsgList, &msgInfo->MsgListEntry);
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_DBG(VMBUS, "buffer %p, size %d msg cnt %d", Kbuffer, Size, msgCount);
 
@@ -592,9 +594,9 @@ VmbusChannelEstablishGpadl(
 	*GpadlHandle = gpadlMsg->Gpadl;
 
 Cleanup:
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 	REMOVE_ENTRY_LIST(&msgInfo->MsgListEntry);
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	WaitEventClose(msgInfo->WaitEvent);
 	kfree(msgInfo);
@@ -624,6 +626,7 @@ VmbusChannelTeardownGpadl(
 	int ret=0;
 	VMBUS_CHANNEL_GPADL_TEARDOWN *msg;
 	VMBUS_CHANNEL_MSGINFO* info;
+	unsigned long flags;
 
 	DPRINT_ENTER(VMBUS);
 
@@ -640,9 +643,9 @@ VmbusChannelTeardownGpadl(
     msg->ChildRelId  = Channel->OfferMsg.ChildRelId;
     msg->Gpadl       = GpadlHandle;
 
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 	INSERT_TAIL_LIST(&gVmbusConnection.ChannelMsgList, &info->MsgListEntry);
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	ret = VmbusPostMessage(msg, sizeof(VMBUS_CHANNEL_GPADL_TEARDOWN));
 	if (ret != 0)
@@ -653,9 +656,9 @@ VmbusChannelTeardownGpadl(
 	WaitEventWait(info->WaitEvent);
 
 	// Received a torndown response
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 	REMOVE_ENTRY_LIST(&info->MsgListEntry);
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	WaitEventClose(info->WaitEvent);
 	kfree(info);
--- a/drivers/staging/hv/ChannelMgmt.c
+++ b/drivers/staging/hv/ChannelMgmt.c
@@ -472,13 +472,14 @@ VmbusChannelOnOpenResult(
 	VMBUS_CHANNEL_MSGINFO* msgInfo;
 	VMBUS_CHANNEL_MESSAGE_HEADER* requestHeader;
 	VMBUS_CHANNEL_OPEN_CHANNEL* openMsg;
+	unsigned long flags;
 
 	DPRINT_ENTER(VMBUS);
 
 	DPRINT_DBG(VMBUS, "vmbus open result - %d", result->Status);
 
 	// Find the open msg, copy the result and signal/unblock the wait event
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
 	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelMsgList)
 	{
@@ -497,7 +498,7 @@ VmbusChannelOnOpenResult(
 			}
 		}
 	}
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_EXIT(VMBUS);
 }
@@ -525,13 +526,14 @@ VmbusChannelOnGpadlCreated(
 	VMBUS_CHANNEL_MSGINFO *msgInfo;
 	VMBUS_CHANNEL_MESSAGE_HEADER *requestHeader;
 	VMBUS_CHANNEL_GPADL_HEADER *gpadlHeader;
+	unsigned long flags;
 
 	DPRINT_ENTER(VMBUS);
 
 	DPRINT_DBG(VMBUS, "vmbus gpadl created result - %d", gpadlCreated->CreationStatus);
 
 	// Find the establish msg, copy the result and signal/unblock the wait event
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
 	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelMsgList)
 	{
@@ -551,7 +553,7 @@ VmbusChannelOnGpadlCreated(
 			}
 		}
 	}
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_EXIT(VMBUS);
 }
@@ -579,11 +581,12 @@ VmbusChannelOnGpadlTorndown(
 	VMBUS_CHANNEL_MSGINFO* msgInfo;
 	VMBUS_CHANNEL_MESSAGE_HEADER *requestHeader;
 	VMBUS_CHANNEL_GPADL_TEARDOWN *gpadlTeardown;
+	unsigned long flags;
 
 	DPRINT_ENTER(VMBUS);
 
 	// Find the open msg, copy the result and signal/unblock the wait event
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
 	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelMsgList)
 	{
@@ -602,7 +605,7 @@ VmbusChannelOnGpadlTorndown(
 			}
 		}
 	}
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_EXIT(VMBUS);
 }
@@ -630,10 +633,11 @@ VmbusChannelOnVersionResponse(
 	VMBUS_CHANNEL_MESSAGE_HEADER *requestHeader;
 	VMBUS_CHANNEL_INITIATE_CONTACT *initiate;
 	VMBUS_CHANNEL_VERSION_RESPONSE *versionResponse  = (VMBUS_CHANNEL_VERSION_RESPONSE*)hdr;
+	unsigned long flags;
 
 	DPRINT_ENTER(VMBUS);
 
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
 	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelMsgList)
 	{
@@ -647,7 +651,7 @@ VmbusChannelOnVersionResponse(
 			WaitEventSet(msgInfo->WaitEvent);
 		}
 	}
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_EXIT(VMBUS);
 }
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -53,6 +53,7 @@ VmbusConnect(
 	int ret=0;
 	VMBUS_CHANNEL_MSGINFO *msgInfo=NULL;
 	VMBUS_CHANNEL_INITIATE_CONTACT *msg;
+	unsigned long flags;
 
 	DPRINT_ENTER(VMBUS);
 
@@ -65,7 +66,7 @@ VmbusConnect(
 	gVmbusConnection.WorkQueue = WorkQueueCreate("vmbusQ");
 
 	INITIALIZE_LIST_HEAD(&gVmbusConnection.ChannelMsgList);
-	gVmbusConnection.ChannelMsgLock = SpinlockCreate();
+	spin_lock_init(&gVmbusConnection.channelmsg_lock);
 
 	INITIALIZE_LIST_HEAD(&gVmbusConnection.ChannelList);
 	gVmbusConnection.ChannelLock = SpinlockCreate();
@@ -107,9 +108,9 @@ VmbusConnect(
 
 	// Add to list before we send the request since we may receive the response
 	// before returning from this routine
-	SpinlockAcquire(gVmbusConnection.ChannelMsgLock);
+	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 	INSERT_TAIL_LIST(&gVmbusConnection.ChannelMsgList, &msgInfo->MsgListEntry);
-	SpinlockRelease(gVmbusConnection.ChannelMsgLock);
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_DBG(VMBUS, "Vmbus connection -  interrupt pfn %llx, monitor1 pfn %llx,, monitor2 pfn %llx",
 		msg->InterruptPage, msg->MonitorPage1, msg->MonitorPage2);
@@ -156,7 +157,6 @@ Cleanup:
 
 	WorkQueueClose(gVmbusConnection.WorkQueue);
 	SpinlockClose(gVmbusConnection.ChannelLock);
-	SpinlockClose(gVmbusConnection.ChannelMsgLock);
 
 	if (gVmbusConnection.InterruptPage)
 	{
@@ -222,8 +222,6 @@ VmbusDisconnect(
 
 	// TODO: iterate thru the msg list and free up
 
-	SpinlockClose(gVmbusConnection.ChannelMsgLock);
-
 	WorkQueueClose(gVmbusConnection.WorkQueue);
 
 	gVmbusConnection.ConnectState = Disconnected;
--- a/drivers/staging/hv/VmbusPrivate.h
+++ b/drivers/staging/hv/VmbusPrivate.h
@@ -80,7 +80,7 @@ typedef struct _VMBUS_CONNECTION {
 	// 2 pages - 1st page for parent->child notification and 2nd is child->parent notification
 	void *								MonitorPages;
 	LIST_ENTRY							ChannelMsgList;
-	HANDLE								ChannelMsgLock;
+	spinlock_t channelmsg_lock;
 
 	// List of channels
 	LIST_ENTRY							ChannelList;
