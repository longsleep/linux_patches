From mithlesh@linsyssoft.com  Tue Jun  2 12:27:13 2009
From: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date: Mon, 25 May 2009 19:06:16 +0530 (IST)
Subject: Staging: wlan-ng: Lindent cleanups
To: Greg Kroah-Hartman <gregkh@suse.de>
Message-ID: <alpine.LFD.2.00.0905251905350.29624@localhost.localdomain>


Lindent script cleanups in wlan-ng driver in the staging tree.
This is a item in the TODO list.

Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/wlan-ng/hfa384x.h      |  374 ++++++--------
 drivers/staging/wlan-ng/hfa384x_usb.c  |  322 +++++-------
 drivers/staging/wlan-ng/p80211conv.c   |   21 
 drivers/staging/wlan-ng/p80211conv.h   |    4 
 drivers/staging/wlan-ng/p80211hdr.h    |    3 
 drivers/staging/wlan-ng/p80211meta.h   |    1 
 drivers/staging/wlan-ng/p80211mgmt.h   |   42 -
 drivers/staging/wlan-ng/p80211msg.h    |    1 
 drivers/staging/wlan-ng/p80211netdev.c |   84 +--
 drivers/staging/wlan-ng/p80211netdev.h |   44 -
 drivers/staging/wlan-ng/p80211req.c    |   20 
 drivers/staging/wlan-ng/p80211req.h    |    2 
 drivers/staging/wlan-ng/p80211types.h  |    7 
 drivers/staging/wlan-ng/p80211wep.c    |  197 ++++---
 drivers/staging/wlan-ng/p80211wext.c   |  143 ++---
 drivers/staging/wlan-ng/prism2fw.c     |  864 ++++++++++++++++-----------------
 drivers/staging/wlan-ng/prism2mgmt.c   |  117 ++--
 drivers/staging/wlan-ng/prism2mgmt.h   |   50 -
 drivers/staging/wlan-ng/prism2mib.c    |  158 ++----
 drivers/staging/wlan-ng/prism2sta.c    |  268 ++++------
 drivers/staging/wlan-ng/prism2usb.c    |    5 
 21 files changed, 1324 insertions(+), 1403 deletions(-)

--- a/drivers/staging/wlan-ng/hfa384x.h
+++ b/drivers/staging/wlan-ng/hfa384x.h
@@ -63,9 +63,9 @@
 /*--- Mins & Maxs -----------------------------------*/
 #define		HFA384x_PORTID_MAX		((u16)7)
 #define		HFA384x_NUMPORTS_MAX		((u16)(HFA384x_PORTID_MAX+1))
-#define		HFA384x_PDR_LEN_MAX		((u16)512) /* in bytes, from EK */
-#define		HFA384x_PDA_RECS_MAX		((u16)200) /* a guess */
-#define		HFA384x_PDA_LEN_MAX		((u16)1024) /* in bytes, from EK */
+#define		HFA384x_PDR_LEN_MAX		((u16)512)	/* in bytes, from EK */
+#define		HFA384x_PDA_RECS_MAX		((u16)200)	/* a guess */
+#define		HFA384x_PDA_LEN_MAX		((u16)1024)	/* in bytes, from EK */
 #define		HFA384x_SCANRESULT_MAX		((u16)31)
 #define		HFA384x_HSCANRESULT_MAX		((u16)31)
 #define		HFA384x_CHINFORESULT_MAX	((u16)16)
@@ -630,7 +630,7 @@ typedef struct hfa384x_ScanResultSub {
 typedef struct hfa384x_ScanResult {
 	u16 rsvd;
 	u16 scanreason;
-	 hfa384x_ScanResultSub_t result[HFA384x_SCANRESULT_MAX];
+	hfa384x_ScanResultSub_t result[HFA384x_SCANRESULT_MAX];
 } __attribute__ ((packed)) hfa384x_ScanResult_t;
 
 /*--  Inquiry Frame, Diagnose: ChInfo Results & Subfields--*/
@@ -646,7 +646,7 @@ typedef struct hfa384x_ChInfoResultSub {
 
 typedef struct hfa384x_ChInfoResult {
 	u16 scanchannels;
-	 hfa384x_ChInfoResultSub_t result[HFA384x_CHINFORESULT_MAX];
+	hfa384x_ChInfoResultSub_t result[HFA384x_CHINFORESULT_MAX];
 } __attribute__ ((packed)) hfa384x_ChInfoResult_t;
 
 /*--  Inquiry Frame, Diagnose: Host Scan Results & Subfields--*/
@@ -666,7 +666,7 @@ typedef struct hfa384x_HScanResultSub {
 typedef struct hfa384x_HScanResult {
 	u16 nresult;
 	u16 rsvd;
-	 hfa384x_HScanResultSub_t result[HFA384x_HSCANRESULT_MAX];
+	hfa384x_HScanResultSub_t result[HFA384x_HSCANRESULT_MAX];
 } __attribute__ ((packed)) hfa384x_HScanResult_t;
 
 /*--  Unsolicited Frame, MAC Mgmt: LinkStatus --*/
@@ -887,241 +887,205 @@ typedef union hfa384x_usbin {
 PD record structures.
 --------------------------------------------------------------------*/
 
-typedef struct hfa384x_pdr_pcb_partnum
-{
-	u8	num[8];
+typedef struct hfa384x_pdr_pcb_partnum {
+	u8 num[8];
 } __attribute__ ((packed)) hfa384x_pdr_pcb_partnum_t;
 
-typedef struct hfa384x_pdr_pcb_tracenum
-{
-	u8	num[8];
+typedef struct hfa384x_pdr_pcb_tracenum {
+	u8 num[8];
 } __attribute__ ((packed)) hfa384x_pdr_pcb_tracenum_t;
 
-typedef struct hfa384x_pdr_nic_serial
-{
-	u8	num[12];
+typedef struct hfa384x_pdr_nic_serial {
+	u8 num[12];
 } __attribute__ ((packed)) hfa384x_pdr_nic_serial_t;
 
-typedef struct hfa384x_pdr_mkk_measurements
-{
-	double	carrier_freq;
-	double	occupied_band;
-	double	power_density;
-	double	tx_spur_f1;
-	double	tx_spur_f2;
-	double	tx_spur_f3;
-	double	tx_spur_f4;
-	double	tx_spur_l1;
-	double	tx_spur_l2;
-	double	tx_spur_l3;
-	double	tx_spur_l4;
-	double	rx_spur_f1;
-	double	rx_spur_f2;
-	double	rx_spur_l1;
-	double	rx_spur_l2;
+typedef struct hfa384x_pdr_mkk_measurements {
+	double carrier_freq;
+	double occupied_band;
+	double power_density;
+	double tx_spur_f1;
+	double tx_spur_f2;
+	double tx_spur_f3;
+	double tx_spur_f4;
+	double tx_spur_l1;
+	double tx_spur_l2;
+	double tx_spur_l3;
+	double tx_spur_l4;
+	double rx_spur_f1;
+	double rx_spur_f2;
+	double rx_spur_l1;
+	double rx_spur_l2;
 } __attribute__ ((packed)) hfa384x_pdr_mkk_measurements_t;
 
-typedef struct hfa384x_pdr_nic_ramsize
-{
-	u8	size[12]; /* units of KB */
+typedef struct hfa384x_pdr_nic_ramsize {
+	u8 size[12];		/* units of KB */
 } __attribute__ ((packed)) hfa384x_pdr_nic_ramsize_t;
 
-typedef struct hfa384x_pdr_mfisuprange
-{
-	u16	id;
-	u16	variant;
-	u16	bottom;
-	u16	top;
+typedef struct hfa384x_pdr_mfisuprange {
+	u16 id;
+	u16 variant;
+	u16 bottom;
+	u16 top;
 } __attribute__ ((packed)) hfa384x_pdr_mfisuprange_t;
 
-typedef struct hfa384x_pdr_cfisuprange
-{
-	u16	id;
-	u16	variant;
-	u16	bottom;
-	u16	top;
+typedef struct hfa384x_pdr_cfisuprange {
+	u16 id;
+	u16 variant;
+	u16 bottom;
+	u16 top;
 } __attribute__ ((packed)) hfa384x_pdr_cfisuprange_t;
 
-typedef struct hfa384x_pdr_nicid
-{
-	u16	id;
-	u16	variant;
-	u16	major;
-	u16	minor;
+typedef struct hfa384x_pdr_nicid {
+	u16 id;
+	u16 variant;
+	u16 major;
+	u16 minor;
 } __attribute__ ((packed)) hfa384x_pdr_nicid_t;
 
-
-typedef struct hfa384x_pdr_refdac_measurements
-{
-	u16	value[0];
+typedef struct hfa384x_pdr_refdac_measurements {
+	u16 value[0];
 } __attribute__ ((packed)) hfa384x_pdr_refdac_measurements_t;
 
-typedef struct hfa384x_pdr_vgdac_measurements
-{
-	u16	value[0];
+typedef struct hfa384x_pdr_vgdac_measurements {
+	u16 value[0];
 } __attribute__ ((packed)) hfa384x_pdr_vgdac_measurements_t;
 
-typedef struct hfa384x_pdr_level_comp_measurements
-{
-	u16	value[0];
+typedef struct hfa384x_pdr_level_comp_measurements {
+	u16 value[0];
 } __attribute__ ((packed)) hfa384x_pdr_level_compc_measurements_t;
 
-typedef struct hfa384x_pdr_mac_address
-{
-	u8	addr[6];
+typedef struct hfa384x_pdr_mac_address {
+	u8 addr[6];
 } __attribute__ ((packed)) hfa384x_pdr_mac_address_t;
 
-typedef struct hfa384x_pdr_mkk_callname
-{
-	u8	callname[8];
+typedef struct hfa384x_pdr_mkk_callname {
+	u8 callname[8];
 } __attribute__ ((packed)) hfa384x_pdr_mkk_callname_t;
 
-typedef struct hfa384x_pdr_regdomain
-{
-	u16	numdomains;
-	u16	domain[5];
+typedef struct hfa384x_pdr_regdomain {
+	u16 numdomains;
+	u16 domain[5];
 } __attribute__ ((packed)) hfa384x_pdr_regdomain_t;
 
-typedef struct hfa384x_pdr_allowed_channel
-{
-	u16	ch_bitmap;
+typedef struct hfa384x_pdr_allowed_channel {
+	u16 ch_bitmap;
 } __attribute__ ((packed)) hfa384x_pdr_allowed_channel_t;
 
-typedef struct hfa384x_pdr_default_channel
-{
-	u16	channel;
+typedef struct hfa384x_pdr_default_channel {
+	u16 channel;
 } __attribute__ ((packed)) hfa384x_pdr_default_channel_t;
 
-typedef struct hfa384x_pdr_privacy_option
-{
-	u16	available;
+typedef struct hfa384x_pdr_privacy_option {
+	u16 available;
 } __attribute__ ((packed)) hfa384x_pdr_privacy_option_t;
 
-typedef struct hfa384x_pdr_temptype
-{
-	u16	type;
+typedef struct hfa384x_pdr_temptype {
+	u16 type;
 } __attribute__ ((packed)) hfa384x_pdr_temptype_t;
 
-typedef struct hfa384x_pdr_refdac_setup
-{
-	u16	ch_value[14];
+typedef struct hfa384x_pdr_refdac_setup {
+	u16 ch_value[14];
 } __attribute__ ((packed)) hfa384x_pdr_refdac_setup_t;
 
-typedef struct hfa384x_pdr_vgdac_setup
-{
-	u16	ch_value[14];
+typedef struct hfa384x_pdr_vgdac_setup {
+	u16 ch_value[14];
 } __attribute__ ((packed)) hfa384x_pdr_vgdac_setup_t;
 
-typedef struct hfa384x_pdr_level_comp_setup
-{
-	u16	ch_value[14];
+typedef struct hfa384x_pdr_level_comp_setup {
+	u16 ch_value[14];
 } __attribute__ ((packed)) hfa384x_pdr_level_comp_setup_t;
 
-typedef struct hfa384x_pdr_trimdac_setup
-{
-	u16	trimidac;
-	u16	trimqdac;
+typedef struct hfa384x_pdr_trimdac_setup {
+	u16 trimidac;
+	u16 trimqdac;
 } __attribute__ ((packed)) hfa384x_pdr_trimdac_setup_t;
 
-typedef struct hfa384x_pdr_ifr_setting
-{
-	u16	value[3];
+typedef struct hfa384x_pdr_ifr_setting {
+	u16 value[3];
 } __attribute__ ((packed)) hfa384x_pdr_ifr_setting_t;
 
-typedef struct hfa384x_pdr_rfr_setting
-{
-	u16	value[3];
+typedef struct hfa384x_pdr_rfr_setting {
+	u16 value[3];
 } __attribute__ ((packed)) hfa384x_pdr_rfr_setting_t;
 
-typedef struct hfa384x_pdr_hfa3861_baseline
-{
-	u16	value[50];
+typedef struct hfa384x_pdr_hfa3861_baseline {
+	u16 value[50];
 } __attribute__ ((packed)) hfa384x_pdr_hfa3861_baseline_t;
 
-typedef struct hfa384x_pdr_hfa3861_shadow
-{
-	u32	value[32];
+typedef struct hfa384x_pdr_hfa3861_shadow {
+	u32 value[32];
 } __attribute__ ((packed)) hfa384x_pdr_hfa3861_shadow_t;
 
-typedef struct hfa384x_pdr_hfa3861_ifrf
-{
-	u32	value[20];
+typedef struct hfa384x_pdr_hfa3861_ifrf {
+	u32 value[20];
 } __attribute__ ((packed)) hfa384x_pdr_hfa3861_ifrf_t;
 
-typedef struct hfa384x_pdr_hfa3861_chcalsp
-{
-	u16	value[14];
+typedef struct hfa384x_pdr_hfa3861_chcalsp {
+	u16 value[14];
 } __attribute__ ((packed)) hfa384x_pdr_hfa3861_chcalsp_t;
 
-typedef struct hfa384x_pdr_hfa3861_chcali
-{
-	u16	value[17];
+typedef struct hfa384x_pdr_hfa3861_chcali {
+	u16 value[17];
 } __attribute__ ((packed)) hfa384x_pdr_hfa3861_chcali_t;
 
-typedef struct hfa384x_pdr_hfa3861_nic_config
-{
-	u16	config_bitmap;
+typedef struct hfa384x_pdr_hfa3861_nic_config {
+	u16 config_bitmap;
 } __attribute__ ((packed)) hfa384x_pdr_nic_config_t;
 
-typedef struct hfa384x_pdr_hfo_delay
-{
-	u8   hfo_delay;
+typedef struct hfa384x_pdr_hfo_delay {
+	u8 hfo_delay;
 } __attribute__ ((packed)) hfa384x_hfo_delay_t;
 
-typedef struct hfa384x_pdr_hfa3861_manf_testsp
-{
-	u16	value[30];
+typedef struct hfa384x_pdr_hfa3861_manf_testsp {
+	u16 value[30];
 } __attribute__ ((packed)) hfa384x_pdr_hfa3861_manf_testsp_t;
 
-typedef struct hfa384x_pdr_hfa3861_manf_testi
-{
-	u16	value[30];
+typedef struct hfa384x_pdr_hfa3861_manf_testi {
+	u16 value[30];
 } __attribute__ ((packed)) hfa384x_pdr_hfa3861_manf_testi_t;
 
-typedef struct hfa384x_end_of_pda
-{
-	u16	crc;
+typedef struct hfa384x_end_of_pda {
+	u16 crc;
 } __attribute__ ((packed)) hfa384x_pdr_end_of_pda_t;
 
-typedef struct hfa384x_pdrec
-{
-	u16	len; /* in words */
-	u16	code;
+typedef struct hfa384x_pdrec {
+	u16 len;		/* in words */
+	u16 code;
 	union pdr {
-	hfa384x_pdr_pcb_partnum_t	pcb_partnum;
-	hfa384x_pdr_pcb_tracenum_t	pcb_tracenum;
-	hfa384x_pdr_nic_serial_t	nic_serial;
-	hfa384x_pdr_mkk_measurements_t	mkk_measurements;
-	hfa384x_pdr_nic_ramsize_t	nic_ramsize;
-	hfa384x_pdr_mfisuprange_t	mfisuprange;
-	hfa384x_pdr_cfisuprange_t	cfisuprange;
-	hfa384x_pdr_nicid_t		nicid;
-	hfa384x_pdr_refdac_measurements_t	refdac_measurements;
-	hfa384x_pdr_vgdac_measurements_t	vgdac_measurements;
-	hfa384x_pdr_level_compc_measurements_t	level_compc_measurements;
-	hfa384x_pdr_mac_address_t	mac_address;
-	hfa384x_pdr_mkk_callname_t	mkk_callname;
-	hfa384x_pdr_regdomain_t		regdomain;
-	hfa384x_pdr_allowed_channel_t	allowed_channel;
-	hfa384x_pdr_default_channel_t	default_channel;
-	hfa384x_pdr_privacy_option_t	privacy_option;
-	hfa384x_pdr_temptype_t		temptype;
-	hfa384x_pdr_refdac_setup_t	refdac_setup;
-	hfa384x_pdr_vgdac_setup_t	vgdac_setup;
-	hfa384x_pdr_level_comp_setup_t	level_comp_setup;
-	hfa384x_pdr_trimdac_setup_t	trimdac_setup;
-	hfa384x_pdr_ifr_setting_t	ifr_setting;
-	hfa384x_pdr_rfr_setting_t	rfr_setting;
-	hfa384x_pdr_hfa3861_baseline_t	hfa3861_baseline;
-	hfa384x_pdr_hfa3861_shadow_t	hfa3861_shadow;
-	hfa384x_pdr_hfa3861_ifrf_t	hfa3861_ifrf;
-	hfa384x_pdr_hfa3861_chcalsp_t	hfa3861_chcalsp;
-	hfa384x_pdr_hfa3861_chcali_t	hfa3861_chcali;
-	hfa384x_pdr_nic_config_t	nic_config;
-	hfa384x_hfo_delay_t             hfo_delay;
-	hfa384x_pdr_hfa3861_manf_testsp_t	hfa3861_manf_testsp;
-	hfa384x_pdr_hfa3861_manf_testi_t	hfa3861_manf_testi;
-	hfa384x_pdr_end_of_pda_t	end_of_pda;
+		hfa384x_pdr_pcb_partnum_t pcb_partnum;
+		hfa384x_pdr_pcb_tracenum_t pcb_tracenum;
+		hfa384x_pdr_nic_serial_t nic_serial;
+		hfa384x_pdr_mkk_measurements_t mkk_measurements;
+		hfa384x_pdr_nic_ramsize_t nic_ramsize;
+		hfa384x_pdr_mfisuprange_t mfisuprange;
+		hfa384x_pdr_cfisuprange_t cfisuprange;
+		hfa384x_pdr_nicid_t nicid;
+		hfa384x_pdr_refdac_measurements_t refdac_measurements;
+		hfa384x_pdr_vgdac_measurements_t vgdac_measurements;
+		hfa384x_pdr_level_compc_measurements_t level_compc_measurements;
+		hfa384x_pdr_mac_address_t mac_address;
+		hfa384x_pdr_mkk_callname_t mkk_callname;
+		hfa384x_pdr_regdomain_t regdomain;
+		hfa384x_pdr_allowed_channel_t allowed_channel;
+		hfa384x_pdr_default_channel_t default_channel;
+		hfa384x_pdr_privacy_option_t privacy_option;
+		hfa384x_pdr_temptype_t temptype;
+		hfa384x_pdr_refdac_setup_t refdac_setup;
+		hfa384x_pdr_vgdac_setup_t vgdac_setup;
+		hfa384x_pdr_level_comp_setup_t level_comp_setup;
+		hfa384x_pdr_trimdac_setup_t trimdac_setup;
+		hfa384x_pdr_ifr_setting_t ifr_setting;
+		hfa384x_pdr_rfr_setting_t rfr_setting;
+		hfa384x_pdr_hfa3861_baseline_t hfa3861_baseline;
+		hfa384x_pdr_hfa3861_shadow_t hfa3861_shadow;
+		hfa384x_pdr_hfa3861_ifrf_t hfa3861_ifrf;
+		hfa384x_pdr_hfa3861_chcalsp_t hfa3861_chcalsp;
+		hfa384x_pdr_hfa3861_chcali_t hfa3861_chcali;
+		hfa384x_pdr_nic_config_t nic_config;
+		hfa384x_hfo_delay_t hfo_delay;
+		hfa384x_pdr_hfa3861_manf_testsp_t hfa3861_manf_testsp;
+		hfa384x_pdr_hfa3861_manf_testi_t hfa3861_manf_testi;
+		hfa384x_pdr_end_of_pda_t end_of_pda;
 
 	} data;
 } __attribute__ ((packed)) hfa384x_pdrec_t;
@@ -1169,7 +1133,7 @@ struct hfa384x;
 
 typedef void (*ctlx_cmdcb_t) (struct hfa384x *, const struct hfa384x_usbctlx *);
 
-typedef void (*ctlx_usercb_t) (struct hfa384x *hw,
+typedef void (*ctlx_usercb_t) (struct hfa384x * hw,
 			       void *ctlxresult, void *usercb_data);
 
 typedef struct hfa384x_usbctlx {
@@ -1356,25 +1320,25 @@ typedef struct hfa384x {
 
 } hfa384x_t;
 
-void hfa384x_create(hfa384x_t *hw, struct usb_device *usb);
-void hfa384x_destroy(hfa384x_t *hw);
+void hfa384x_create(hfa384x_t * hw, struct usb_device *usb);
+void hfa384x_destroy(hfa384x_t * hw);
 
 int
-hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis);
-int hfa384x_drvr_commtallies(hfa384x_t *hw);
-int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport);
-int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport);
-int hfa384x_drvr_flashdl_enable(hfa384x_t *hw);
-int hfa384x_drvr_flashdl_disable(hfa384x_t *hw);
-int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len);
-int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len);
-int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr);
-int hfa384x_drvr_ramdl_disable(hfa384x_t *hw);
-int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len);
-int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len);
-int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len);
+hfa384x_corereset(hfa384x_t * hw, int holdtime, int settletime, int genesis);
+int hfa384x_drvr_commtallies(hfa384x_t * hw);
+int hfa384x_drvr_disable(hfa384x_t * hw, u16 macport);
+int hfa384x_drvr_enable(hfa384x_t * hw, u16 macport);
+int hfa384x_drvr_flashdl_enable(hfa384x_t * hw);
+int hfa384x_drvr_flashdl_disable(hfa384x_t * hw);
+int hfa384x_drvr_flashdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len);
+int hfa384x_drvr_getconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len);
+int hfa384x_drvr_ramdl_enable(hfa384x_t * hw, u32 exeaddr);
+int hfa384x_drvr_ramdl_disable(hfa384x_t * hw);
+int hfa384x_drvr_ramdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len);
+int hfa384x_drvr_readpda(hfa384x_t * hw, void *buf, unsigned int len);
+int hfa384x_drvr_setconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len);
 
-static inline int hfa384x_drvr_getconfig16(hfa384x_t *hw, u16 rid, void *val)
+static inline int hfa384x_drvr_getconfig16(hfa384x_t * hw, u16 rid, void *val)
 {
 	int result = 0;
 	result = hfa384x_drvr_getconfig(hw, rid, val, sizeof(u16));
@@ -1383,44 +1347,44 @@ static inline int hfa384x_drvr_getconfig
 	return result;
 }
 
-static inline int hfa384x_drvr_setconfig16(hfa384x_t *hw, u16 rid, u16 val)
+static inline int hfa384x_drvr_setconfig16(hfa384x_t * hw, u16 rid, u16 val)
 {
 	u16 value = cpu_to_le16(val);
 	return hfa384x_drvr_setconfig(hw, rid, &value, sizeof(value));
 }
 
 int
-hfa384x_drvr_getconfig_async(hfa384x_t *hw,
+hfa384x_drvr_getconfig_async(hfa384x_t * hw,
 			     u16 rid, ctlx_usercb_t usercb, void *usercb_data);
 
 int
-hfa384x_drvr_setconfig_async(hfa384x_t *hw,
+hfa384x_drvr_setconfig_async(hfa384x_t * hw,
 			     u16 rid,
 			     void *buf,
 			     u16 len, ctlx_usercb_t usercb, void *usercb_data);
 
 static inline int
-hfa384x_drvr_setconfig16_async(hfa384x_t *hw, u16 rid, u16 val)
+hfa384x_drvr_setconfig16_async(hfa384x_t * hw, u16 rid, u16 val)
 {
 	u16 value = cpu_to_le16(val);
 	return hfa384x_drvr_setconfig_async(hw, rid, &value, sizeof(value),
 					    NULL, NULL);
 }
 
-int hfa384x_drvr_start(hfa384x_t *hw);
-int hfa384x_drvr_stop(hfa384x_t *hw);
+int hfa384x_drvr_start(hfa384x_t * hw);
+int hfa384x_drvr_stop(hfa384x_t * hw);
 int
-hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
-		     p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep);
-void hfa384x_tx_timeout(wlandevice_t *wlandev);
-
-int hfa384x_cmd_initialize(hfa384x_t *hw);
-int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport);
-int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport);
-int hfa384x_cmd_allocate(hfa384x_t *hw, u16 len);
-int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable);
+hfa384x_drvr_txframe(hfa384x_t * hw, struct sk_buff *skb,
+		     p80211_hdr_t * p80211_hdr, p80211_metawep_t * p80211_wep);
+void hfa384x_tx_timeout(wlandevice_t * wlandev);
+
+int hfa384x_cmd_initialize(hfa384x_t * hw);
+int hfa384x_cmd_enable(hfa384x_t * hw, u16 macport);
+int hfa384x_cmd_disable(hfa384x_t * hw, u16 macport);
+int hfa384x_cmd_allocate(hfa384x_t * hw, u16 len);
+int hfa384x_cmd_monitor(hfa384x_t * hw, u16 enable);
 int
-hfa384x_cmd_download(hfa384x_t *hw,
+hfa384x_cmd_download(hfa384x_t * hw,
 		     u16 mode, u16 lowaddr, u16 highaddr, u16 codelen);
 
 #endif /* __KERNEL__ */
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -110,7 +110,6 @@
 * --------------------------------------------------------------------
 */
 
-
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -161,13 +160,13 @@ static void dbprint_urb(struct urb *urb)
 #endif
 
 static void
-hfa384x_int_rxmonitor(wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm);
+hfa384x_int_rxmonitor(wlandevice_t * wlandev, hfa384x_usb_rxfrm_t * rxfrm);
 
 static void hfa384x_usb_defer(struct work_struct *data);
 
-static int submit_rx_urb(hfa384x_t *hw, gfp_t flags);
+static int submit_rx_urb(hfa384x_t * hw, gfp_t flags);
 
-static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
+static int submit_tx_urb(hfa384x_t * hw, struct urb *tx_urb, gfp_t flags);
 
 /*---------------------------------------------------*/
 /* Callbacks */
@@ -176,22 +175,22 @@ static void hfa384x_ctlxout_callback(str
 static void hfa384x_usbin_callback(struct urb *urb);
 
 static void
-hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+hfa384x_usbin_txcompl(wlandevice_t * wlandev, hfa384x_usbin_t * usbin);
 
-static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
+static void hfa384x_usbin_rx(wlandevice_t * wlandev, struct sk_buff *skb);
 
-static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+static void hfa384x_usbin_info(wlandevice_t * wlandev, hfa384x_usbin_t * usbin);
 
 static void
-hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
+hfa384x_usbout_tx(wlandevice_t * wlandev, hfa384x_usbout_t * usbout);
 
-static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
+static void hfa384x_usbin_ctlx(hfa384x_t * hw, hfa384x_usbin_t * usbin,
 			       int urb_status);
 
 /*---------------------------------------------------*/
 /* Functions to support the prism2 usb command queue */
 
-static void hfa384x_usbctlxq_run(hfa384x_t *hw);
+static void hfa384x_usbctlxq_run(hfa384x_t * hw);
 
 static void hfa384x_usbctlx_reqtimerfn(unsigned long data);
 
@@ -203,9 +202,9 @@ static void hfa384x_usbctlx_completion_t
 
 static void hfa384x_usbctlx_reaper_task(unsigned long data);
 
-static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static int hfa384x_usbctlx_submit(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
 
-static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static void unlocked_usbctlx_complete(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
 
 struct usbctlx_completor {
 	int (*complete) (struct usbctlx_completor *);
@@ -213,35 +212,35 @@ struct usbctlx_completor {
 typedef struct usbctlx_completor usbctlx_completor_t;
 
 static int
-hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
-			      hfa384x_usbctlx_t *ctlx,
-			      usbctlx_completor_t *completor);
+hfa384x_usbctlx_complete_sync(hfa384x_t * hw,
+			      hfa384x_usbctlx_t * ctlx,
+			      usbctlx_completor_t * completor);
 
 static int
-unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+unlocked_usbctlx_cancel_async(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
 
-static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_status(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx);
 
-static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_rrid(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx);
 
 static int
-usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
-		   hfa384x_cmdresult_t *result);
+usbctlx_get_status(const hfa384x_usb_cmdresp_t * cmdresp,
+		   hfa384x_cmdresult_t * result);
 
 static void
-usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
-		       hfa384x_rridresult_t *result);
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t * rridresp,
+		       hfa384x_rridresult_t * result);
 
 /*---------------------------------------------------*/
 /* Low level req/resp CTLX formatters and submitters */
 static int
-hfa384x_docmd(hfa384x_t *hw,
+hfa384x_docmd(hfa384x_t * hw,
 	      CMD_MODE mode,
-	      hfa384x_metacmd_t *cmd,
+	      hfa384x_metacmd_t * cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dorrid(hfa384x_t *hw,
+hfa384x_dorrid(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -249,7 +248,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowrid(hfa384x_t *hw,
+hfa384x_dowrid(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -257,7 +256,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dormem(hfa384x_t *hw,
+hfa384x_dormem(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -266,7 +265,7 @@ hfa384x_dormem(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowmem(hfa384x_t *hw,
+hfa384x_dowmem(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -291,7 +290,7 @@ static inline const char *ctlxstr(CTLX_S
 	return ctlx_str[s];
 };
 
-static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t *hw)
+static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t * hw)
 {
 	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
 }
@@ -303,21 +302,19 @@ void dbprint_urb(struct urb *urb)
 	pr_debug("urb->status=0x%08x\n", urb->status);
 	pr_debug("urb->transfer_flags=0x%08x\n", urb->transfer_flags);
 	pr_debug("urb->transfer_buffer=0x%08x\n",
-	       (unsigned int)urb->transfer_buffer);
+		 (unsigned int)urb->transfer_buffer);
 	pr_debug("urb->transfer_buffer_length=0x%08x\n",
-	       urb->transfer_buffer_length);
+		 urb->transfer_buffer_length);
 	pr_debug("urb->actual_length=0x%08x\n", urb->actual_length);
 	pr_debug("urb->bandwidth=0x%08x\n", urb->bandwidth);
 	pr_debug("urb->setup_packet(ctl)=0x%08x\n",
-	       (unsigned int)urb->setup_packet);
-	pr_debug("urb->start_frame(iso/irq)=0x%08x\n",
-	       urb->start_frame);
+		 (unsigned int)urb->setup_packet);
+	pr_debug("urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
 	pr_debug("urb->interval(irq)=0x%08x\n", urb->interval);
 	pr_debug("urb->error_count(iso)=0x%08x\n", urb->error_count);
 	pr_debug("urb->timeout=0x%08x\n", urb->timeout);
 	pr_debug("urb->context=0x%08x\n", (unsigned int)urb->context);
-	pr_debug("urb->complete=0x%08x\n",
-	       (unsigned int)urb->complete);
+	pr_debug("urb->complete=0x%08x\n", (unsigned int)urb->complete);
 }
 #endif
 
@@ -337,7 +334,7 @@ void dbprint_urb(struct urb *urb)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
+static int submit_rx_urb(hfa384x_t * hw, gfp_t memflags)
 {
 	struct sk_buff *skb;
 	int result;
@@ -398,7 +395,7 @@ done:
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
+static int submit_tx_urb(hfa384x_t * hw, struct urb *tx_urb, gfp_t memflags)
 {
 	struct net_device *netdev = hw->wlandev->netdev;
 	int result;
@@ -535,7 +532,7 @@ static void hfa384x_usb_defer(struct wor
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
+void hfa384x_create(hfa384x_t * hw, struct usb_device *usb)
 {
 	memset(hw, 0, sizeof(hfa384x_t));
 	hw->usb = usb;
@@ -611,7 +608,7 @@ void hfa384x_create(hfa384x_t *hw, struc
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void hfa384x_destroy(hfa384x_t *hw)
+void hfa384x_destroy(hfa384x_t * hw)
 {
 	struct sk_buff *skb;
 
@@ -633,7 +630,7 @@ static hfa384x_usbctlx_t *usbctlx_alloc(
 {
 	hfa384x_usbctlx_t *ctlx;
 
-	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+	ctlx = kmalloc(sizeof(*ctlx), in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
 	if (ctlx != NULL) {
 		memset(ctlx, 0, sizeof(*ctlx));
 		init_completion(&ctlx->done);
@@ -643,8 +640,8 @@ static hfa384x_usbctlx_t *usbctlx_alloc(
 }
 
 static int
-usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
-		   hfa384x_cmdresult_t *result)
+usbctlx_get_status(const hfa384x_usb_cmdresp_t * cmdresp,
+		   hfa384x_cmdresult_t * result)
 {
 	result->status = le16_to_cpu(cmdresp->status);
 	result->resp0 = le16_to_cpu(cmdresp->resp0);
@@ -652,15 +649,15 @@ usbctlx_get_status(const hfa384x_usb_cmd
 	result->resp2 = le16_to_cpu(cmdresp->resp2);
 
 	pr_debug("cmdresult:status=0x%04x "
-	       "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
-	       result->status, result->resp0, result->resp1, result->resp2);
+		 "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
+		 result->status, result->resp0, result->resp1, result->resp2);
 
 	return result->status & HFA384x_STATUS_RESULT;
 }
 
 static void
-usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
-		       hfa384x_rridresult_t *result)
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t * rridresp,
+		       hfa384x_rridresult_t * result)
 {
 	result->rid = le16_to_cpu(rridresp->rid);
 	result->riddata = rridresp->data;
@@ -681,7 +678,7 @@ struct usbctlx_cmd_completor {
 };
 typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
 
-static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
+static int usbctlx_cmd_completor_fn(usbctlx_completor_t * head)
 {
 	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t *) head;
 	return usbctlx_get_status(complete->cmdresp, complete->result);
@@ -715,7 +712,7 @@ struct usbctlx_rrid_completor {
 };
 typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
 
-static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
+static int usbctlx_rrid_completor_fn(usbctlx_completor_t * head)
 {
 	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t *) head;
 	hfa384x_rridresult_t rridresult;
@@ -736,7 +733,7 @@ static int usbctlx_rrid_completor_fn(usb
 }
 
 static inline usbctlx_completor_t *init_rrid_completor(usbctlx_rrid_completor_t
-						       *completor,
+						       * completor,
 						       const
 						       hfa384x_usb_rridresp_t *
 						       rridresp, void *riddata,
@@ -776,7 +773,7 @@ struct usbctlx_rmem_completor {
 };
 typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
 
-static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
+static int usbctlx_rmem_completor_fn(usbctlx_completor_t * head)
 {
 	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t *) head;
 
@@ -786,9 +783,9 @@ static int usbctlx_rmem_completor_fn(usb
 }
 
 static inline usbctlx_completor_t *init_rmem_completor(usbctlx_rmem_completor_t
-						       *completor,
+						       * completor,
 						       hfa384x_usb_rmemresp_t
-                                                       *rmemresp, void *data,
+						       * rmemresp, void *data,
 						       unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
@@ -819,7 +816,7 @@ static inline usbctlx_completor_t *init_
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_status(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx)
 {
 	if (ctlx->usercb != NULL) {
 		hfa384x_cmdresult_t cmdresult;
@@ -856,15 +853,14 @@ static void hfa384x_cb_status(hfa384x_t 
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_rrid(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx)
 {
 	if (ctlx->usercb != NULL) {
 		hfa384x_rridresult_t rridresult;
 
 		if (ctlx->state != CTLX_COMPLETE) {
 			memset(&rridresult, 0, sizeof(rridresult));
-			rridresult.rid =
-			    le16_to_cpu(ctlx->outbuf.rridreq.rid);
+			rridresult.rid = le16_to_cpu(ctlx->outbuf.rridreq.rid);
 		} else {
 			usbctlx_get_rridresult(&ctlx->inbuf.rridresp,
 					       &rridresult);
@@ -874,21 +870,21 @@ static void hfa384x_cb_rrid(hfa384x_t *h
 	}
 }
 
-static inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+static inline int hfa384x_docmd_wait(hfa384x_t * hw, hfa384x_metacmd_t * cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
 
 static inline int
-hfa384x_docmd_async(hfa384x_t *hw,
-		    hfa384x_metacmd_t *cmd,
+hfa384x_docmd_async(hfa384x_t * hw,
+		    hfa384x_metacmd_t * cmd,
 		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+hfa384x_dorrid_wait(hfa384x_t * hw, u16 rid, void *riddata,
 		    unsigned int riddatalen)
 {
 	return hfa384x_dorrid(hw, DOWAIT,
@@ -896,7 +892,7 @@ hfa384x_dorrid_wait(hfa384x_t *hw, u16 r
 }
 
 static inline int
-hfa384x_dorrid_async(hfa384x_t *hw,
+hfa384x_dorrid_async(hfa384x_t * hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -907,7 +903,7 @@ hfa384x_dorrid_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+hfa384x_dowrid_wait(hfa384x_t * hw, u16 rid, void *riddata,
 		    unsigned int riddatalen)
 {
 	return hfa384x_dowrid(hw, DOWAIT,
@@ -915,7 +911,7 @@ hfa384x_dowrid_wait(hfa384x_t *hw, u16 r
 }
 
 static inline int
-hfa384x_dowrid_async(hfa384x_t *hw,
+hfa384x_dowrid_async(hfa384x_t * hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -926,7 +922,7 @@ hfa384x_dowrid_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dormem_wait(hfa384x_t *hw,
+hfa384x_dormem_wait(hfa384x_t * hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dormem(hw, DOWAIT,
@@ -934,7 +930,7 @@ hfa384x_dormem_wait(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dormem_async(hfa384x_t *hw,
+hfa384x_dormem_async(hfa384x_t * hw,
 		     u16 page, u16 offset, void *data, unsigned int len,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -945,7 +941,7 @@ hfa384x_dormem_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowmem_wait(hfa384x_t *hw,
+hfa384x_dowmem_wait(hfa384x_t * hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dowmem(hw, DOWAIT,
@@ -953,7 +949,7 @@ hfa384x_dowmem_wait(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowmem_async(hfa384x_t *hw,
+hfa384x_dowmem_async(hfa384x_t * hw,
 		     u16 page,
 		     u16 offset,
 		     void *data,
@@ -985,7 +981,7 @@ hfa384x_dowmem_async(hfa384x_t *hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_initialize(hfa384x_t *hw)
+int hfa384x_cmd_initialize(hfa384x_t * hw)
 {
 	int result = 0;
 	int i;
@@ -999,10 +995,10 @@ int hfa384x_cmd_initialize(hfa384x_t *hw
 	result = hfa384x_docmd_wait(hw, &cmd);
 
 	pr_debug("cmdresp.init: "
-	       "status=0x%04x, resp0=0x%04x, "
-	       "resp1=0x%04x, resp2=0x%04x\n",
-	       cmd.result.status,
-	       cmd.result.resp0, cmd.result.resp1, cmd.result.resp2);
+		 "status=0x%04x, resp0=0x%04x, "
+		 "resp1=0x%04x, resp2=0x%04x\n",
+		 cmd.result.status,
+		 cmd.result.resp0, cmd.result.resp1, cmd.result.resp2);
 	if (result == 0) {
 		for (i = 0; i < HFA384x_NUMPORTS_MAX; i++)
 			hw->port_enabled[i] = 0;
@@ -1033,7 +1029,7 @@ int hfa384x_cmd_initialize(hfa384x_t *hw
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
+int hfa384x_cmd_disable(hfa384x_t * hw, u16 macport)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1069,7 +1065,7 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
+int hfa384x_cmd_enable(hfa384x_t * hw, u16 macport)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1114,7 +1110,7 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u1
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
+int hfa384x_cmd_monitor(hfa384x_t * hw, u16 enable)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1168,15 +1164,14 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
+int hfa384x_cmd_download(hfa384x_t * hw, u16 mode, u16 lowaddr,
 			 u16 highaddr, u16 codelen)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
 
-	pr_debug(
-	       "mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
-	       mode, lowaddr, highaddr, codelen);
+	pr_debug("mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
+		 mode, lowaddr, highaddr, codelen);
 
 	cmd.cmd = (HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |
 		   HFA384x_CMD_PROGMODE_SET(mode));
@@ -1213,7 +1208,7 @@ int hfa384x_cmd_download(hfa384x_t *hw, 
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
+int hfa384x_corereset(hfa384x_t * hw, int holdtime, int settletime, int genesis)
 {
 	int result = 0;
 
@@ -1250,9 +1245,9 @@ int hfa384x_corereset(hfa384x_t *hw, int
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
-					 hfa384x_usbctlx_t *ctlx,
-					 usbctlx_completor_t *completor)
+static int hfa384x_usbctlx_complete_sync(hfa384x_t * hw,
+					 hfa384x_usbctlx_t * ctlx,
+					 usbctlx_completor_t * completor)
 {
 	unsigned long flags;
 	int result;
@@ -1366,9 +1361,9 @@ cleanup:
 *	process
 ----------------------------------------------------------------*/
 static int
-hfa384x_docmd(hfa384x_t *hw,
+hfa384x_docmd(hfa384x_t * hw,
 	      CMD_MODE mode,
-	      hfa384x_metacmd_t *cmd,
+	      hfa384x_metacmd_t * cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;
@@ -1390,8 +1385,8 @@ hfa384x_docmd(hfa384x_t *hw,
 	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
 
 	pr_debug("cmdreq: cmd=0x%04x "
-	       "parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
-	       cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
+		 "parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
+		 cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1455,7 +1450,7 @@ done:
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dorrid(hfa384x_t *hw,
+hfa384x_dorrid(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -1536,7 +1531,7 @@ done:
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowrid(hfa384x_t *hw,
+hfa384x_dowrid(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -1555,9 +1550,8 @@ hfa384x_dowrid(hfa384x_t *hw,
 	/* Initialize the command */
 	ctlx->outbuf.wridreq.type = cpu_to_le16(HFA384x_USB_WRIDREQ);
 	ctlx->outbuf.wridreq.frmlen = cpu_to_le16((sizeof
-						       (ctlx->outbuf.wridreq.
-							rid) + riddatalen +
-						       1) / 2);
+						   (ctlx->outbuf.wridreq.rid) +
+						   riddatalen + 1) / 2);
 	ctlx->outbuf.wridreq.rid = cpu_to_le16(rid);
 	memcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);
 
@@ -1624,7 +1618,7 @@ done:
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dormem(hfa384x_t *hw,
+hfa384x_dormem(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -1645,20 +1639,18 @@ hfa384x_dormem(hfa384x_t *hw,
 	ctlx->outbuf.rmemreq.type = cpu_to_le16(HFA384x_USB_RMEMREQ);
 	ctlx->outbuf.rmemreq.frmlen =
 	    cpu_to_le16(sizeof(ctlx->outbuf.rmemreq.offset) +
-			    sizeof(ctlx->outbuf.rmemreq.page) + len);
+			sizeof(ctlx->outbuf.rmemreq.page) + len);
 	ctlx->outbuf.rmemreq.offset = cpu_to_le16(offset);
 	ctlx->outbuf.rmemreq.page = cpu_to_le16(page);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
 
-	pr_debug(
-	       "type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
-	       ctlx->outbuf.rmemreq.type,
-	       ctlx->outbuf.rmemreq.frmlen,
-	       ctlx->outbuf.rmemreq.offset, ctlx->outbuf.rmemreq.page);
+	pr_debug("type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
+		 ctlx->outbuf.rmemreq.type,
+		 ctlx->outbuf.rmemreq.frmlen,
+		 ctlx->outbuf.rmemreq.offset, ctlx->outbuf.rmemreq.page);
 
-	pr_debug("pktsize=%zd\n",
-	       ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
+	pr_debug("pktsize=%zd\n", ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1717,7 +1709,7 @@ done:
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowmem(hfa384x_t *hw,
+hfa384x_dowmem(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -1728,8 +1720,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 	int result;
 	hfa384x_usbctlx_t *ctlx;
 
-	pr_debug("page=0x%04x offset=0x%04x len=%d\n",
-	       page, offset, len);
+	pr_debug("page=0x%04x offset=0x%04x len=%d\n", page, offset, len);
 
 	ctlx = usbctlx_alloc();
 	if (ctlx == NULL) {
@@ -1741,7 +1732,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 	ctlx->outbuf.wmemreq.type = cpu_to_le16(HFA384x_USB_WMEMREQ);
 	ctlx->outbuf.wmemreq.frmlen =
 	    cpu_to_le16(sizeof(ctlx->outbuf.wmemreq.offset) +
-			    sizeof(ctlx->outbuf.wmemreq.page) + len);
+			sizeof(ctlx->outbuf.wmemreq.page) + len);
 	ctlx->outbuf.wmemreq.offset = cpu_to_le16(offset);
 	ctlx->outbuf.wmemreq.page = cpu_to_le16(page);
 	memcpy(ctlx->outbuf.wmemreq.data, data, len);
@@ -1792,7 +1783,7 @@ done:
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_commtallies(hfa384x_t *hw)
+int hfa384x_drvr_commtallies(hfa384x_t * hw)
 {
 	hfa384x_metacmd_t cmd;
 
@@ -1828,7 +1819,7 @@ int hfa384x_drvr_commtallies(hfa384x_t *
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
+int hfa384x_drvr_disable(hfa384x_t * hw, u16 macport)
 {
 	int result = 0;
 
@@ -1866,7 +1857,7 @@ int hfa384x_drvr_disable(hfa384x_t *hw, 
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
+int hfa384x_drvr_enable(hfa384x_t * hw, u16 macport)
 {
 	int result = 0;
 
@@ -1903,7 +1894,7 @@ int hfa384x_drvr_enable(hfa384x_t *hw, u
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
+int hfa384x_drvr_flashdl_enable(hfa384x_t * hw)
 {
 	int result = 0;
 	int i;
@@ -1961,7 +1952,7 @@ int hfa384x_drvr_flashdl_enable(hfa384x_
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
+int hfa384x_drvr_flashdl_disable(hfa384x_t * hw)
 {
 	/* Check that we're already in the download state */
 	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
@@ -2006,7 +1997,7 @@ int hfa384x_drvr_flashdl_disable(hfa384x
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_flashdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
 	u32 dlbufaddr;
@@ -2035,9 +2026,8 @@ int hfa384x_drvr_flashdl_write(hfa384x_t
 	/* NOTE: dlbuffer RID stores the address in AUX format */
 	dlbufaddr =
 	    HFA384x_ADDR_AUX_MKFLAT(hw->bufinfo.page, hw->bufinfo.offset);
-	pr_debug(
-	       "dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
-	       hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
+	pr_debug("dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
+		 hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
 #if 0
 	printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
@@ -2153,7 +2143,7 @@ exit_proc:
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
+int hfa384x_drvr_getconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len)
 {
 	int result;
 
@@ -2190,7 +2180,7 @@ int hfa384x_drvr_getconfig(hfa384x_t *hw
  *       Any
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_getconfig_async(hfa384x_t *hw,
+hfa384x_drvr_getconfig_async(hfa384x_t * hw,
 			     u16 rid, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dorrid_async(hw, rid, NULL, 0,
@@ -2221,7 +2211,7 @@ hfa384x_drvr_getconfig_async(hfa384x_t *
  *       process
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_setconfig_async(hfa384x_t *hw,
+hfa384x_drvr_setconfig_async(hfa384x_t * hw,
 			     u16 rid,
 			     void *buf,
 			     u16 len, ctlx_usercb_t usercb, void *usercb_data)
@@ -2248,7 +2238,7 @@ hfa384x_drvr_setconfig_async(hfa384x_t *
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
+int hfa384x_drvr_ramdl_disable(hfa384x_t * hw)
 {
 	/* Check that we're already in the download state */
 	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
@@ -2288,7 +2278,7 @@ int hfa384x_drvr_ramdl_disable(hfa384x_t
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
+int hfa384x_drvr_ramdl_enable(hfa384x_t * hw, u32 exeaddr)
 {
 	int result = 0;
 	u16 lowaddr;
@@ -2323,9 +2313,8 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t 
 		/* Set the download state */
 		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
 	} else {
-		pr_debug(
-		       "cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
-		       lowaddr, hiaddr, result);
+		pr_debug("cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
+			 lowaddr, hiaddr, result);
 	}
 
 	return result;
@@ -2357,7 +2346,7 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t 
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_ramdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
 	int nwrites;
@@ -2436,7 +2425,7 @@ int hfa384x_drvr_ramdl_write(hfa384x_t *
 * Call context:
 *	process or non-card interrupt.
 ----------------------------------------------------------------*/
-int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
+int hfa384x_drvr_readpda(hfa384x_t * hw, void *buf, unsigned int len)
 {
 	int result = 0;
 	u16 *pda = buf;
@@ -2542,7 +2531,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, 
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
+int hfa384x_drvr_setconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len)
 {
 	return hfa384x_dowrid_wait(hw, rid, buf, len);
 }
@@ -2567,7 +2556,7 @@ int hfa384x_drvr_setconfig(hfa384x_t *hw
 *	process
 ----------------------------------------------------------------*/
 
-int hfa384x_drvr_start(hfa384x_t *hw)
+int hfa384x_drvr_start(hfa384x_t * hw)
 {
 	int result, result1, result2;
 	u16 status;
@@ -2629,11 +2618,10 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
-			pr_debug(
-			       "First cmd_initialize() failed (result %d),\n",
-			       result1);
-			pr_debug(
-			       "but second attempt succeeded. All should be ok\n");
+			pr_debug("First cmd_initialize() failed (result %d),\n",
+				 result1);
+			pr_debug
+			    ("but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
 		printk(KERN_WARNING
@@ -2669,7 +2657,7 @@ done:
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_stop(hfa384x_t *hw)
+int hfa384x_drvr_stop(hfa384x_t * hw)
 {
 	int result = 0;
 	int i;
@@ -2720,9 +2708,9 @@ int hfa384x_drvr_stop(hfa384x_t *hw)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
-			 p80211_hdr_t *p80211_hdr,
-			 p80211_metawep_t *p80211_wep)
+int hfa384x_drvr_txframe(hfa384x_t * hw, struct sk_buff *skb,
+			 p80211_hdr_t * p80211_hdr,
+			 p80211_metawep_t * p80211_wep)
 {
 	int usbpktlen = sizeof(hfa384x_tx_frame_t);
 	int result;
@@ -2813,7 +2801,7 @@ exit:
 	return result;
 }
 
-void hfa384x_tx_timeout(wlandevice_t *wlandev)
+void hfa384x_tx_timeout(wlandevice_t * wlandev)
 {
 	hfa384x_t *hw = wlandev->priv;
 	unsigned long flags;
@@ -2962,8 +2950,8 @@ static void hfa384x_usbctlx_completion_t
 * Call context:
 *	Either process or interrupt, but presumably interrupt
 ----------------------------------------------------------------*/
-static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
-					 hfa384x_usbctlx_t *ctlx)
+static int unlocked_usbctlx_cancel_async(hfa384x_t * hw,
+					 hfa384x_usbctlx_t * ctlx)
 {
 	int ret;
 
@@ -3012,7 +3000,7 @@ static int unlocked_usbctlx_cancel_async
 * Call context:
 *	Either, assume interrupt
 ----------------------------------------------------------------*/
-static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+static void unlocked_usbctlx_complete(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx)
 {
 	/* Timers have been stopped, and ctlx should be in
 	 * a terminal state. Retire it from the "active"
@@ -3029,8 +3017,7 @@ static void unlocked_usbctlx_complete(hf
 
 	default:
 		printk(KERN_ERR "CTLX[%d] not in a terminating state(%s)\n",
-		       le16_to_cpu(ctlx->outbuf.type),
-		       ctlxstr(ctlx->state));
+		       le16_to_cpu(ctlx->outbuf.type), ctlxstr(ctlx->state));
 		break;
 	}			/* switch */
 }
@@ -3051,7 +3038,7 @@ static void unlocked_usbctlx_complete(hf
 * Call context:
 *	any
 ----------------------------------------------------------------*/
-static void hfa384x_usbctlxq_run(hfa384x_t *hw)
+static void hfa384x_usbctlxq_run(hfa384x_t * hw)
 {
 	unsigned long flags;
 
@@ -3225,14 +3212,13 @@ static void hfa384x_usbin_callback(struc
 
 	case -ENOENT:
 	case -ECONNRESET:
-		pr_debug("status=%d, urb explicitly unlinked.\n",
-		       urb->status);
+		pr_debug("status=%d, urb explicitly unlinked.\n", urb->status);
 		action = ABORT;
 		break;
 
 	default:
 		pr_debug("urb status=%d, transfer flags=0x%x\n",
-		       urb->status, urb->transfer_flags);
+			 urb->status, urb->transfer_flags);
 		++(wlandev->linux_stats.rx_errors);
 		action = RESUBMIT;
 		break;
@@ -3292,18 +3278,17 @@ static void hfa384x_usbin_callback(struc
 
 	case HFA384x_USB_BUFAVAIL:
 		pr_debug("Received BUFAVAIL packet, frmlen=%d\n",
-		       usbin->bufavail.frmlen);
+			 usbin->bufavail.frmlen);
 		break;
 
 	case HFA384x_USB_ERROR:
 		pr_debug("Received USB_ERROR packet, errortype=%d\n",
-		       usbin->usberror.errortype);
+			 usbin->usberror.errortype);
 		break;
 
 	default:
-		pr_debug(
-		       "Unrecognized USBIN packet, type=%x, status=%d\n",
-		       usbin->type, urb_status);
+		pr_debug("Unrecognized USBIN packet, type=%x, status=%d\n",
+			 usbin->type, urb_status);
 		break;
 	}			/* switch */
 
@@ -3333,7 +3318,7 @@ exit:
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
+static void hfa384x_usbin_ctlx(hfa384x_t * hw, hfa384x_usbin_t * usbin,
 			       int urb_status)
 {
 	hfa384x_usbctlx_t *ctlx;
@@ -3399,8 +3384,8 @@ retry:
 			 * our request has been acknowledged. Odd,
 			 * but our OUT URB is still alive...
 			 */
-			pr_debug(
-			       "Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
+			pr_debug
+			    ("Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
 			ctlx->state = CTLX_RESP_COMPLETE;
 			break;
 
@@ -3454,8 +3439,8 @@ unlock:
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
-				  hfa384x_usbin_t *usbin)
+static void hfa384x_usbin_txcompl(wlandevice_t * wlandev,
+				  hfa384x_usbin_t * usbin)
 {
 	u16 status;
 
@@ -3485,7 +3470,7 @@ static void hfa384x_usbin_txcompl(wlande
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
+static void hfa384x_usbin_rx(wlandevice_t * wlandev, struct sk_buff *skb)
 {
 	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) skb->data;
 	hfa384x_t *hw = wlandev->priv;
@@ -3552,8 +3537,7 @@ static void hfa384x_usbin_rx(wlandevice_
 			hfa384x_int_rxmonitor(wlandev, &usbin->rxfrm);
 			dev_kfree_skb(skb);
 		} else {
-			pr_debug(
-			       "Received monitor frame: FCSerr set\n");
+			pr_debug("Received monitor frame: FCSerr set\n");
 		}
 		break;
 
@@ -3589,8 +3573,8 @@ done:
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
-				  hfa384x_usb_rxfrm_t *rxfrm)
+static void hfa384x_int_rxmonitor(wlandevice_t * wlandev,
+				  hfa384x_usb_rxfrm_t * rxfrm)
 {
 	hfa384x_rx_frame_t *rxdesc = &(rxfrm->desc);
 	unsigned int hdrlen = 0;
@@ -3615,7 +3599,7 @@ static void hfa384x_int_rxmonitor(wlande
 	    (sizeof(p80211_caphdr_t) +
 	     WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN)) {
 		pr_debug("overlen frm: len=%zd\n",
-		       skblen - sizeof(p80211_caphdr_t));
+			 skblen - sizeof(p80211_caphdr_t));
 	}
 
 	if ((skb = dev_alloc_skb(skblen)) == NULL) {
@@ -4071,7 +4055,7 @@ static void hfa384x_usb_throttlefn(unsig
 * Call context:
 *	process or interrupt
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+static int hfa384x_usbctlx_submit(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx)
 {
 	unsigned long flags;
 	int ret;
@@ -4112,7 +4096,7 @@ static int hfa384x_usbctlx_submit(hfa384
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
+static void hfa384x_usbout_tx(wlandevice_t * wlandev, hfa384x_usbout_t * usbout)
 {
 	prism2sta_ev_alloc(wlandev);
 }
@@ -4171,15 +4155,13 @@ static int hfa384x_isgood_pdrcode(u16 pd
 	default:
 		if (pdrcode < 0x1000) {
 			/* code is OK, but we don't know exactly what it is */
-			pr_debug(
-			       "Encountered unknown PDR#=0x%04x, "
-			       "assuming it's ok.\n", pdrcode);
+			pr_debug("Encountered unknown PDR#=0x%04x, "
+				 "assuming it's ok.\n", pdrcode);
 			return 1;
 		} else {
 			/* bad code */
-			pr_debug(
-			       "Encountered unknown PDR#=0x%04x, "
-			       "(>=0x1000), assuming it's bad.\n", pdrcode);
+			pr_debug("Encountered unknown PDR#=0x%04x, "
+				 "(>=0x1000), assuming it's bad.\n", pdrcode);
 			return 0;
 		}
 		break;
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -102,9 +102,9 @@ static u8 oui_8021h[] = { 0x00, 0x00, 0x
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
-			struct sk_buff *skb, p80211_hdr_t *p80211_hdr,
-			p80211_metawep_t *p80211_wep)
+int skb_ether_to_p80211(wlandevice_t * wlandev, u32 ethconv,
+			struct sk_buff *skb, p80211_hdr_t * p80211_hdr,
+			p80211_metawep_t * p80211_wep)
 {
 
 	u16 fc;
@@ -209,8 +209,8 @@ int skb_ether_to_p80211(wlandevice_t *wl
 
 		if ((foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
 				       skb->len,
-				       (wlandev->
-					hostwep & HOSTWEP_DEFAULTKEY_MASK),
+				       (wlandev->hostwep &
+					HOSTWEP_DEFAULTKEY_MASK),
 				       p80211_wep->iv, p80211_wep->icv))) {
 			printk(KERN_WARNING
 			       "Host en-WEP failed, dropping frame (%d).\n",
@@ -230,8 +230,8 @@ int skb_ether_to_p80211(wlandevice_t *wl
 }
 
 /* jkriegl: from orinoco, modified */
-static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
-			       p80211_rxmeta_t *rxmeta)
+static void orinoco_spy_gather(wlandevice_t * wlandev, char *mac,
+			       p80211_rxmeta_t * rxmeta)
 {
 	int i;
 
@@ -272,7 +272,7 @@ static void orinoco_spy_gather(wlandevic
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
+int skb_p80211_to_ether(wlandevice_t * wlandev, u32 ethconv,
 			struct sk_buff *skb)
 {
 	netdevice_t *netdev = wlandev->netdev;
@@ -329,9 +329,8 @@ int skb_p80211_to_ether(wlandevice_t *wl
 				       skb->data + payload_offset +
 				       payload_length - 4))) {
 			/* de-wep failed, drop skb. */
-			pr_debug(
-			       "Host de-WEP failed, dropping frame (%d).\n",
-			       foo);
+			pr_debug("Host de-WEP failed, dropping frame (%d).\n",
+				 foo);
 			wlandev->rx.decrypt_err++;
 			return 2;
 		}
--- a/drivers/staging/wlan-ng/p80211conv.h
+++ b/drivers/staging/wlan-ng/p80211conv.h
@@ -153,8 +153,8 @@ struct wlandevice;
 int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 			struct sk_buff *skb);
 int skb_ether_to_p80211(struct wlandevice *wlandev, u32 ethconv,
-			struct sk_buff *skb, p80211_hdr_t *p80211_hdr,
-			p80211_metawep_t *p80211_wep);
+			struct sk_buff *skb, p80211_hdr_t * p80211_hdr,
+			p80211_metawep_t * p80211_wep);
 
 int p80211_stt_findproto(u16 proto);
 
--- a/drivers/staging/wlan-ng/p80211hdr.h
+++ b/drivers/staging/wlan-ng/p80211hdr.h
@@ -68,8 +68,6 @@
 /*================================================================*/
 /* Project Includes */
 
-
-
 /*================================================================*/
 /* Constants */
 
@@ -188,7 +186,6 @@ typedef union p80211_hdr {
 	p80211_hdr_a4_t a4;
 } __attribute__ ((packed)) p80211_hdr_t;
 
-
 /* Frame and header length macros */
 
 #define WLAN_CTL_FRAMELEN(fstype) (\
--- a/drivers/staging/wlan-ng/p80211meta.h
+++ b/drivers/staging/wlan-ng/p80211meta.h
@@ -60,7 +60,6 @@
 /*================================================================*/
 /* Project Includes */
 
-
 /*================================================================*/
 /* Types */
 
--- a/drivers/staging/wlan-ng/p80211mgmt.h
+++ b/drivers/staging/wlan-ng/p80211mgmt.h
@@ -103,12 +103,10 @@
 /*================================================================*/
 /* Project Includes */
 
-
 #ifndef  _P80211HDR_H
 #include "p80211hdr.h"
 #endif
 
-
 /*================================================================*/
 /* Constants */
 
@@ -504,25 +502,25 @@ typedef struct wlan_fr_deauthen {
 
 } wlan_fr_deauthen_t;
 
-void wlan_mgmt_encode_beacon(wlan_fr_beacon_t *f);
-void wlan_mgmt_decode_beacon(wlan_fr_beacon_t *f);
-void wlan_mgmt_encode_disassoc(wlan_fr_disassoc_t *f);
-void wlan_mgmt_decode_disassoc(wlan_fr_disassoc_t *f);
-void wlan_mgmt_encode_assocreq(wlan_fr_assocreq_t *f);
-void wlan_mgmt_decode_assocreq(wlan_fr_assocreq_t *f);
-void wlan_mgmt_encode_assocresp(wlan_fr_assocresp_t *f);
-void wlan_mgmt_decode_assocresp(wlan_fr_assocresp_t *f);
-void wlan_mgmt_encode_reassocreq(wlan_fr_reassocreq_t *f);
-void wlan_mgmt_decode_reassocreq(wlan_fr_reassocreq_t *f);
-void wlan_mgmt_encode_reassocresp(wlan_fr_reassocresp_t *f);
-void wlan_mgmt_decode_reassocresp(wlan_fr_reassocresp_t *f);
-void wlan_mgmt_encode_probereq(wlan_fr_probereq_t *f);
-void wlan_mgmt_decode_probereq(wlan_fr_probereq_t *f);
-void wlan_mgmt_encode_proberesp(wlan_fr_proberesp_t *f);
-void wlan_mgmt_decode_proberesp(wlan_fr_proberesp_t *f);
-void wlan_mgmt_encode_authen(wlan_fr_authen_t *f);
-void wlan_mgmt_decode_authen(wlan_fr_authen_t *f);
-void wlan_mgmt_encode_deauthen(wlan_fr_deauthen_t *f);
-void wlan_mgmt_decode_deauthen(wlan_fr_deauthen_t *f);
+void wlan_mgmt_encode_beacon(wlan_fr_beacon_t * f);
+void wlan_mgmt_decode_beacon(wlan_fr_beacon_t * f);
+void wlan_mgmt_encode_disassoc(wlan_fr_disassoc_t * f);
+void wlan_mgmt_decode_disassoc(wlan_fr_disassoc_t * f);
+void wlan_mgmt_encode_assocreq(wlan_fr_assocreq_t * f);
+void wlan_mgmt_decode_assocreq(wlan_fr_assocreq_t * f);
+void wlan_mgmt_encode_assocresp(wlan_fr_assocresp_t * f);
+void wlan_mgmt_decode_assocresp(wlan_fr_assocresp_t * f);
+void wlan_mgmt_encode_reassocreq(wlan_fr_reassocreq_t * f);
+void wlan_mgmt_decode_reassocreq(wlan_fr_reassocreq_t * f);
+void wlan_mgmt_encode_reassocresp(wlan_fr_reassocresp_t * f);
+void wlan_mgmt_decode_reassocresp(wlan_fr_reassocresp_t * f);
+void wlan_mgmt_encode_probereq(wlan_fr_probereq_t * f);
+void wlan_mgmt_decode_probereq(wlan_fr_probereq_t * f);
+void wlan_mgmt_encode_proberesp(wlan_fr_proberesp_t * f);
+void wlan_mgmt_decode_proberesp(wlan_fr_proberesp_t * f);
+void wlan_mgmt_encode_authen(wlan_fr_authen_t * f);
+void wlan_mgmt_decode_authen(wlan_fr_authen_t * f);
+void wlan_mgmt_encode_deauthen(wlan_fr_deauthen_t * f);
+void wlan_mgmt_decode_deauthen(wlan_fr_deauthen_t * f);
 
 #endif /* _P80211MGMT_H */
--- a/drivers/staging/wlan-ng/p80211msg.h
+++ b/drivers/staging/wlan-ng/p80211msg.h
@@ -51,7 +51,6 @@
 /*================================================================*/
 /* Project Includes */
 
-
 #define WLAN_DEVNAMELEN_MAX	16
 
 /*--------------------------------------------------------------------*/
--- a/drivers/staging/wlan-ng/p80211netdev.c
+++ b/drivers/staging/wlan-ng/p80211netdev.c
@@ -94,18 +94,18 @@
 static void p80211netdev_rx_bh(unsigned long arg);
 
 /* netdevice method functions */
-static int p80211knetdev_init(netdevice_t *netdev);
-static struct net_device_stats *p80211knetdev_get_stats(netdevice_t *netdev);
-static int p80211knetdev_open(netdevice_t *netdev);
-static int p80211knetdev_stop(netdevice_t *netdev);
+static int p80211knetdev_init(netdevice_t * netdev);
+static struct net_device_stats *p80211knetdev_get_stats(netdevice_t * netdev);
+static int p80211knetdev_open(netdevice_t * netdev);
+static int p80211knetdev_stop(netdevice_t * netdev);
 static int p80211knetdev_hard_start_xmit(struct sk_buff *skb,
-					 netdevice_t *netdev);
-static void p80211knetdev_set_multicast_list(netdevice_t *dev);
-static int p80211knetdev_do_ioctl(netdevice_t *dev, struct ifreq *ifr,
+					 netdevice_t * netdev);
+static void p80211knetdev_set_multicast_list(netdevice_t * dev);
+static int p80211knetdev_do_ioctl(netdevice_t * dev, struct ifreq *ifr,
 				  int cmd);
-static int p80211knetdev_set_mac_address(netdevice_t *dev, void *addr);
-static void p80211knetdev_tx_timeout(netdevice_t *netdev);
-static int p80211_rx_typedrop(wlandevice_t *wlandev, u16 fc);
+static int p80211knetdev_set_mac_address(netdevice_t * dev, void *addr);
+static void p80211knetdev_tx_timeout(netdevice_t * netdev);
+static int p80211_rx_typedrop(wlandevice_t * wlandev, u16 fc);
 
 int wlan_watchdog = 5000;
 module_param(wlan_watchdog, int, 0644);
@@ -127,7 +127,7 @@ MODULE_PARM_DESC(wlan_wext_write, "enabl
 * Returns:
 *	nothing
 ----------------------------------------------------------------*/
-static int p80211knetdev_init(netdevice_t *netdev)
+static int p80211knetdev_init(netdevice_t * netdev)
 {
 	/* Called in response to register_netdev */
 	/* This is usually the probe function, but the probe has */
@@ -150,7 +150,7 @@ static int p80211knetdev_init(netdevice_
 * Returns:
 *	the address of the statistics structure
 ----------------------------------------------------------------*/
-static struct net_device_stats *p80211knetdev_get_stats(netdevice_t *netdev)
+static struct net_device_stats *p80211knetdev_get_stats(netdevice_t * netdev)
 {
 	wlandevice_t *wlandev = netdev->ml_priv;
 
@@ -174,7 +174,7 @@ static struct net_device_stats *p80211kn
 * Returns:
 *	zero on success, non-zero otherwise
 ----------------------------------------------------------------*/
-static int p80211knetdev_open(netdevice_t *netdev)
+static int p80211knetdev_open(netdevice_t * netdev)
 {
 	int result = 0;		/* success */
 	wlandevice_t *wlandev = netdev->ml_priv;
@@ -209,7 +209,7 @@ static int p80211knetdev_open(netdevice_
 * Returns:
 *	zero on success, non-zero otherwise
 ----------------------------------------------------------------*/
-static int p80211knetdev_stop(netdevice_t *netdev)
+static int p80211knetdev_stop(netdevice_t * netdev)
 {
 	int result = 0;
 	wlandevice_t *wlandev = netdev->ml_priv;
@@ -236,7 +236,7 @@ static int p80211knetdev_stop(netdevice_
 * Side effects:
 *
 ----------------------------------------------------------------*/
-void p80211netdev_rx(wlandevice_t *wlandev, struct sk_buff *skb)
+void p80211netdev_rx(wlandevice_t * wlandev, struct sk_buff *skb)
 {
 	/* Enqueue for post-irq processing */
 	skb_queue_tail(&wlandev->nsd_rxq, skb);
@@ -345,7 +345,7 @@ static void p80211netdev_rx_bh(unsigned 
 *	zero on success, non-zero on failure.
 ----------------------------------------------------------------*/
 static int p80211knetdev_hard_start_xmit(struct sk_buff *skb,
-					 netdevice_t *netdev)
+					 netdevice_t * netdev)
 {
 	int result = 0;
 	int txresult = -1;
@@ -409,7 +409,7 @@ static int p80211knetdev_hard_start_xmit
 		     &p80211_wep) != 0) {
 			/* convert failed */
 			pr_debug("ether_to_80211(%d) failed.\n",
-			       wlandev->ethconv);
+				 wlandev->ethconv);
 			result = 1;
 			goto failed;
 		}
@@ -472,7 +472,7 @@ failed:
 * Returns:
 *	nothing
 ----------------------------------------------------------------*/
-static void p80211knetdev_set_multicast_list(netdevice_t *dev)
+static void p80211knetdev_set_multicast_list(netdevice_t * dev)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
 
@@ -485,7 +485,7 @@ static void p80211knetdev_set_multicast_
 
 #ifdef SIOCETHTOOL
 
-static int p80211netdev_ethtool(wlandevice_t *wlandev, void __user *useraddr)
+static int p80211netdev_ethtool(wlandevice_t * wlandev, void __user * useraddr)
 {
 	u32 ethcmd;
 	struct ethtool_drvinfo info;
@@ -557,7 +557,7 @@ static int p80211netdev_ethtool(wlandevi
 *	Process thread (ioctl caller).  TODO: SMP support may require
 *	locks.
 ----------------------------------------------------------------*/
-static int p80211knetdev_do_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd)
+static int p80211knetdev_do_ioctl(netdevice_t * dev, struct ifreq *ifr, int cmd)
 {
 	int result = 0;
 	p80211ioctl_req_t *req = (p80211ioctl_req_t *) ifr;
@@ -634,7 +634,7 @@ bail:
 *
 * by: Collin R. Mulliner <collin@mulliner.org>
 ----------------------------------------------------------------*/
-static int p80211knetdev_set_mac_address(netdevice_t *dev, void *addr)
+static int p80211knetdev_set_mac_address(netdevice_t * dev, void *addr)
 {
 	struct sockaddr *new_addr = addr;
 	p80211msg_dot11req_mibset_t dot11req;
@@ -649,7 +649,7 @@ static int p80211knetdev_set_mac_address
 
 	/* Set up some convenience pointers. */
 	mibattr = &dot11req.mibattribute;
-	macaddr = (p80211item_pstr6_t *)&mibattr->data;
+	macaddr = (p80211item_pstr6_t *) & mibattr->data;
 	resultcode = &dot11req.resultcode;
 
 	/* Set up a dot11req_mibset */
@@ -677,7 +677,7 @@ static int p80211knetdev_set_mac_address
 	resultcode->data = 0;
 
 	/* now fire the request */
-	result = p80211req_dorequest(dev->ml_priv, (u8 *)&dot11req);
+	result = p80211req_dorequest(dev->ml_priv, (u8 *) & dot11req);
 
 	/* If the request wasn't successful, report an error and don't
 	 * change the netdev address
@@ -694,7 +694,7 @@ static int p80211knetdev_set_mac_address
 	return result;
 }
 
-static int wlan_change_mtu(netdevice_t *dev, int new_mtu)
+static int wlan_change_mtu(netdevice_t * dev, int new_mtu)
 {
 	/* 2312 is max 802.11 payload, 20 is overhead, (ether + llc +snap)
 	   and another 8 for wep. */
@@ -707,17 +707,17 @@ static int wlan_change_mtu(netdevice_t *
 }
 
 static const struct net_device_ops p80211_netdev_ops = {
-	.ndo_init		= p80211knetdev_init,
-	.ndo_open		= p80211knetdev_open,
-	.ndo_stop		= p80211knetdev_stop,
-	.ndo_get_stats		= p80211knetdev_get_stats,
-	.ndo_start_xmit		= p80211knetdev_hard_start_xmit,
-	.ndo_set_multicast_list	= p80211knetdev_set_multicast_list,
-	.ndo_do_ioctl		= p80211knetdev_do_ioctl,
-	.ndo_set_mac_address	= p80211knetdev_set_mac_address,
-	.ndo_tx_timeout		= p80211knetdev_tx_timeout,
-	.ndo_change_mtu		= wlan_change_mtu,
-	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_init = p80211knetdev_init,
+	.ndo_open = p80211knetdev_open,
+	.ndo_stop = p80211knetdev_stop,
+	.ndo_get_stats = p80211knetdev_get_stats,
+	.ndo_start_xmit = p80211knetdev_hard_start_xmit,
+	.ndo_set_multicast_list = p80211knetdev_set_multicast_list,
+	.ndo_do_ioctl = p80211knetdev_do_ioctl,
+	.ndo_set_mac_address = p80211knetdev_set_mac_address,
+	.ndo_tx_timeout = p80211knetdev_tx_timeout,
+	.ndo_change_mtu = wlan_change_mtu,
+	.ndo_validate_addr = eth_validate_addr,
 };
 
 /*----------------------------------------------------------------
@@ -742,7 +742,7 @@ static const struct net_device_ops p8021
 *	compiled drivers, this function will be called in the
 *	context of the kernel startup code.
 ----------------------------------------------------------------*/
-int wlan_setup(wlandevice_t *wlandev)
+int wlan_setup(wlandevice_t * wlandev)
 {
 	int result = 0;
 	netdevice_t *dev;
@@ -800,7 +800,7 @@ int wlan_setup(wlandevice_t *wlandev)
 *	compiled drivers, this function will be called in the
 *	context of the kernel startup code.
 ----------------------------------------------------------------*/
-int wlan_unsetup(wlandevice_t *wlandev)
+int wlan_unsetup(wlandevice_t * wlandev)
 {
 	int result = 0;
 
@@ -836,7 +836,7 @@ int wlan_unsetup(wlandevice_t *wlandev)
 * Call Context:
 *	Can be either interrupt or not.
 ----------------------------------------------------------------*/
-int register_wlandev(wlandevice_t *wlandev)
+int register_wlandev(wlandevice_t * wlandev)
 {
 	int i = 0;
 
@@ -864,7 +864,7 @@ int register_wlandev(wlandevice_t *wland
 * Call Context:
 *	Can be either interrupt or not.
 ----------------------------------------------------------------*/
-int unregister_wlandev(wlandevice_t *wlandev)
+int unregister_wlandev(wlandevice_t * wlandev)
 {
 	struct sk_buff *skb;
 
@@ -907,7 +907,7 @@ int unregister_wlandev(wlandevice_t *wla
 * Call context:
 *	Usually interrupt.
 ----------------------------------------------------------------*/
-void p80211netdev_hwremoved(wlandevice_t *wlandev)
+void p80211netdev_hwremoved(wlandevice_t * wlandev)
 {
 	wlandev->hwremoved = 1;
 	if (wlandev->state == WLAN_DEVICE_OPEN)
@@ -937,7 +937,7 @@ void p80211netdev_hwremoved(wlandevice_t
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static int p80211_rx_typedrop(wlandevice_t *wlandev, u16 fc)
+static int p80211_rx_typedrop(wlandevice_t * wlandev, u16 fc)
 {
 	u16 ftype;
 	u16 fstype;
@@ -1095,7 +1095,7 @@ static int p80211_rx_typedrop(wlandevice
 	return drop;
 }
 
-static void p80211knetdev_tx_timeout(netdevice_t *netdev)
+static void p80211knetdev_tx_timeout(netdevice_t * netdev)
 {
 	wlandevice_t *wlandev = netdev->ml_priv;
 
--- a/drivers/staging/wlan-ng/p80211netdev.h
+++ b/drivers/staging/wlan-ng/p80211netdev.h
@@ -182,16 +182,16 @@ typedef struct wlandevice {
 	unsigned int ethconv;
 
 	/* device methods (init by MSD, used by p80211 */
-	int (*open) (struct wlandevice *wlandev);
-	int (*close) (struct wlandevice *wlandev);
-	void (*reset) (struct wlandevice *wlandev);
-	int (*txframe) (struct wlandevice *wlandev, struct sk_buff *skb,
-			p80211_hdr_t *p80211_hdr,
-			p80211_metawep_t *p80211_wep);
-	int (*mlmerequest) (struct wlandevice *wlandev, p80211msg_t *msg);
-	int (*set_multicast_list) (struct wlandevice *wlandev,
-				   netdevice_t *dev);
-	void (*tx_timeout) (struct wlandevice *wlandev);
+	int (*open) (struct wlandevice * wlandev);
+	int (*close) (struct wlandevice * wlandev);
+	void (*reset) (struct wlandevice * wlandev);
+	int (*txframe) (struct wlandevice * wlandev, struct sk_buff * skb,
+			p80211_hdr_t * p80211_hdr,
+			p80211_metawep_t * p80211_wep);
+	int (*mlmerequest) (struct wlandevice * wlandev, p80211msg_t * msg);
+	int (*set_multicast_list) (struct wlandevice * wlandev,
+				   netdevice_t * dev);
+	void (*tx_timeout) (struct wlandevice * wlandev);
 
 	/* 802.11 State */
 	u8 bssid[WLAN_BSSID_LEN];
@@ -230,16 +230,16 @@ typedef struct wlandevice {
 } wlandevice_t;
 
 /* WEP stuff */
-int wep_change_key(wlandevice_t *wlandev, int keynum, u8 *key, int keylen);
-int wep_decrypt(wlandevice_t *wlandev, u8 *buf, u32 len, int key_override,
-		u8 *iv, u8 *icv);
-int wep_encrypt(wlandevice_t *wlandev, u8 *buf, u8 *dst, u32 len, int keynum,
-		u8 *iv, u8 *icv);
-
-int wlan_setup(wlandevice_t *wlandev);
-int wlan_unsetup(wlandevice_t *wlandev);
-int register_wlandev(wlandevice_t *wlandev);
-int unregister_wlandev(wlandevice_t *wlandev);
-void p80211netdev_rx(wlandevice_t *wlandev, struct sk_buff *skb);
-void p80211netdev_hwremoved(wlandevice_t *wlandev);
+int wep_change_key(wlandevice_t * wlandev, int keynum, u8 * key, int keylen);
+int wep_decrypt(wlandevice_t * wlandev, u8 * buf, u32 len, int key_override,
+		u8 * iv, u8 * icv);
+int wep_encrypt(wlandevice_t * wlandev, u8 * buf, u8 * dst, u32 len, int keynum,
+		u8 * iv, u8 * icv);
+
+int wlan_setup(wlandevice_t * wlandev);
+int wlan_unsetup(wlandevice_t * wlandev);
+int register_wlandev(wlandevice_t * wlandev);
+int unregister_wlandev(wlandevice_t * wlandev);
+void p80211netdev_rx(wlandevice_t * wlandev, struct sk_buff *skb);
+void p80211netdev_hwremoved(wlandevice_t * wlandev);
 #endif
--- a/drivers/staging/wlan-ng/p80211req.c
+++ b/drivers/staging/wlan-ng/p80211req.c
@@ -73,9 +73,9 @@
 #include "p80211metastruct.h"
 #include "p80211req.h"
 
-static void p80211req_handlemsg(wlandevice_t *wlandev, p80211msg_t *msg);
-static int p80211req_mibset_mibget(wlandevice_t *wlandev,
-				   p80211msg_dot11req_mibget_t *mib_msg,
+static void p80211req_handlemsg(wlandevice_t * wlandev, p80211msg_t * msg);
+static int p80211req_mibset_mibget(wlandevice_t * wlandev,
+				   p80211msg_dot11req_mibget_t * mib_msg,
 				   int isget);
 
 /*----------------------------------------------------------------
@@ -94,7 +94,7 @@ static int p80211req_mibset_mibget(wland
 *	Potentially blocks the caller, so it's a good idea to
 *	not call this function from an interrupt context.
 ----------------------------------------------------------------*/
-int p80211req_dorequest(wlandevice_t *wlandev, u8 *msgbuf)
+int p80211req_dorequest(wlandevice_t * wlandev, u8 * msgbuf)
 {
 	int result = 0;
 	p80211msg_t *msg = (p80211msg_t *) msgbuf;
@@ -129,7 +129,7 @@ int p80211req_dorequest(wlandevice_t *wl
 		wlandev->mlmerequest(wlandev, msg);
 
 	clear_bit(1, &(wlandev->request_pending));
-	return result; /* if result==0, msg->status still may contain an err */
+	return result;		/* if result==0, msg->status still may contain an err */
 }
 
 /*----------------------------------------------------------------
@@ -150,7 +150,7 @@ int p80211req_dorequest(wlandevice_t *wl
 * Call context:
 *	Process thread
 ----------------------------------------------------------------*/
-static void p80211req_handlemsg(wlandevice_t *wlandev, p80211msg_t *msg)
+static void p80211req_handlemsg(wlandevice_t * wlandev, p80211msg_t * msg)
 {
 	switch (msg->msgcode) {
 
@@ -180,8 +180,8 @@ static void p80211req_handlemsg(wlandevi
 	return;
 }
 
-static int p80211req_mibset_mibget(wlandevice_t *wlandev,
-				   p80211msg_dot11req_mibget_t *mib_msg,
+static int p80211req_mibset_mibget(wlandevice_t * wlandev,
+				   p80211msg_dot11req_mibget_t * mib_msg,
 				   int isget)
 {
 	p80211itemd_t *mibitem = (p80211itemd_t *) mib_msg->mibattribute.data;
@@ -243,8 +243,8 @@ static int p80211req_mibset_mibget(wland
 			u32 *data = (u32 *) mibitem->data;
 
 			if (isget) {
-				if (wlandev->
-				    hostwep & HOSTWEP_EXCLUDEUNENCRYPTED)
+				if (wlandev->hostwep &
+				    HOSTWEP_EXCLUDEUNENCRYPTED)
 					*data = P80211ENUM_truth_true;
 				else
 					*data = P80211ENUM_truth_false;
--- a/drivers/staging/wlan-ng/p80211req.h
+++ b/drivers/staging/wlan-ng/p80211req.h
@@ -48,6 +48,6 @@
 #ifndef _LINUX_P80211REQ_H
 #define _LINUX_P80211REQ_H
 
-int p80211req_dorequest(wlandevice_t *wlandev, u8 *msgbuf);
+int p80211req_dorequest(wlandevice_t * wlandev, u8 * msgbuf);
 
 #endif
--- a/drivers/staging/wlan-ng/p80211types.h
+++ b/drivers/staging/wlan-ng/p80211types.h
@@ -61,7 +61,6 @@
 /* Project Includes */
 /*================================================================*/
 
-
 /*----------------------------------------------------------------*/
 /* The following constants are indexes into the Mib Category List */
 /* and the Message Category List */
@@ -345,11 +344,11 @@ struct catlistitem;
 /*  metadata items.  Some components may choose to use more, */
 /*  less or different metadata items. */
 
-typedef void (*p80211_totext_t) (struct catlistitem *, u32 did, u8 *itembuf,
+typedef void (*p80211_totext_t) (struct catlistitem *, u32 did, u8 * itembuf,
 				 char *textbuf);
-typedef void (*p80211_fromtext_t) (struct catlistitem *, u32 did, u8 *itembuf,
+typedef void (*p80211_fromtext_t) (struct catlistitem *, u32 did, u8 * itembuf,
 				   char *textbuf);
-typedef u32(*p80211_valid_t) (struct catlistitem *, u32 did, u8 *itembuf);
+typedef u32(*p80211_valid_t) (struct catlistitem *, u32 did, u8 * itembuf);
 
 /*----------------------------------------------------------------*/
 /* Enumeration Lists */
--- a/drivers/staging/wlan-ng/p80211wep.c
+++ b/drivers/staging/wlan-ng/p80211wep.c
@@ -48,8 +48,6 @@
 /*================================================================*/
 /* System Includes */
 
-
-
 #include <linux/netdevice.h>
 #include <linux/wireless.h>
 #include <linux/slab.h>
@@ -76,58 +74,58 @@
 /* Local Static Definitions */
 
 static const u32 wep_crc32_table[256] = {
-        0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
-        0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
-        0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
-        0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
-        0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
-        0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
-        0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
-        0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
-        0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
-        0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
-        0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
-        0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
-        0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
-        0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
-        0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
-        0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
-        0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
-        0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
-        0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
-        0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
-        0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
-        0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
-        0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
-        0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
-        0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
-        0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
-        0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
-        0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
-        0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
-        0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
-        0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
-        0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
-        0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
-        0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
-        0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
-        0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
-        0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
-        0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
-        0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
-        0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
-        0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
-        0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
-        0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
-        0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
-        0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
-        0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
-        0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
-        0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
-        0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
-        0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
-        0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
-        0x2d02ef8dL
+	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+	0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+	0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+	0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+	0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+	0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+	0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+	0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+	0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+	0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+	0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+	0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+	0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+	0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+	0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+	0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+	0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+	0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+	0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+	0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+	0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+	0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+	0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+	0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+	0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+	0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+	0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+	0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+	0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+	0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+	0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+	0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+	0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+	0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+	0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+	0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+	0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+	0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+	0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+	0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+	0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+	0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+	0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+	0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+	0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+	0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+	0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+	0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+	0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+	0x2d02ef8dL
 };
 
 /*================================================================*/
@@ -138,17 +136,24 @@ static const u32 wep_crc32_table[256] = 
 
 /* keylen in bytes! */
 
-int wep_change_key(wlandevice_t *wlandev, int keynum, u8* key, int keylen)
+int wep_change_key(wlandevice_t * wlandev, int keynum, u8 * key, int keylen)
 {
-	if (keylen < 0)  return -1;
-	if (keylen >= MAX_KEYLEN) return -1;
-	if (key == NULL) return -1;
-	if (keynum < 0)  return -1;
-	if (keynum >= NUM_WEPKEYS) return -1;
-
+	if (keylen < 0)
+		return -1;
+	if (keylen >= MAX_KEYLEN)
+		return -1;
+	if (key == NULL)
+		return -1;
+	if (keynum < 0)
+		return -1;
+	if (keynum >= NUM_WEPKEYS)
+		return -1;
 
 #ifdef WEP_DEBUG
-	printk(KERN_DEBUG "WEP key %d len %d = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", keynum, keylen, key[0], key[1], key[2], key[3], key[4], key[5], key[6], key[7]);
+	printk(KERN_DEBUG
+	       "WEP key %d len %d = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+	       keynum, keylen, key[0], key[1], key[2], key[3], key[4], key[5],
+	       key[6], key[7]);
 #endif
 
 	wlandev->wep_keylens[keynum] = keylen;
@@ -161,14 +166,16 @@ int wep_change_key(wlandevice_t *wlandev
   4-byte IV at start of buffer, 4-byte ICV at end of buffer.
   if successful, buf start is payload begin, length -= 8;
  */
-int wep_decrypt(wlandevice_t *wlandev, u8 *buf, u32 len, int key_override, u8 *iv, u8 *icv)
+int wep_decrypt(wlandevice_t * wlandev, u8 * buf, u32 len, int key_override,
+		u8 * iv, u8 * icv)
 {
 	u32 i, j, k, crc, keylen;
 	u8 s[256], key[64], c_crc[4];
 	u8 keyidx;
 
 	/* Needs to be at least 8 bytes of payload */
-	if (len <= 0) return -1;
+	if (len <= 0)
+		return -1;
 
 	/* initialize the first bytes of the key from the IV */
 	key[0] = iv[0];
@@ -179,19 +186,24 @@ int wep_decrypt(wlandevice_t *wlandev, u
 	if (key_override >= 0)
 		keyidx = key_override;
 
-	if (keyidx >= NUM_WEPKEYS) return -2;
+	if (keyidx >= NUM_WEPKEYS)
+		return -2;
 
 	keylen = wlandev->wep_keylens[keyidx];
 
-	if (keylen == 0) return -3;
+	if (keylen == 0)
+		return -3;
 
 	/* copy the rest of the key over from the designated key */
-	memcpy(key+3, wlandev->wep_keys[keyidx], keylen);
+	memcpy(key + 3, wlandev->wep_keys[keyidx], keylen);
 
-	keylen+=3;  /* add in IV bytes */
+	keylen += 3;		/* add in IV bytes */
 
 #ifdef WEP_DEBUG
-	printk(KERN_DEBUG "D %d: %02x %02x %02x (%d %d) %02x:%02x:%02x:%02x:%02x\n", len, key[0], key[1], key[2], keyidx, keylen, key[3], key[4], key[5], key[6], key[7]);
+	printk(KERN_DEBUG
+	       "D %d: %02x %02x %02x (%d %d) %02x:%02x:%02x:%02x:%02x\n", len,
+	       key[0], key[1], key[2], keyidx, keylen, key[3], key[4], key[5],
+	       key[6], key[7]);
 #endif
 
 	/* set up the RC4 state */
@@ -200,16 +212,16 @@ int wep_decrypt(wlandevice_t *wlandev, u
 	j = 0;
 	for (i = 0; i < 256; i++) {
 		j = (j + s[i] + key[i % keylen]) & 0xff;
-		swap(i,j);
+		swap(i, j);
 	}
 
 	/* Apply the RC4 to the data, update the CRC32 */
 	crc = ~0;
 	i = j = 0;
 	for (k = 0; k < len; k++) {
-		i = (i+1) & 0xff;
-		j = (j+s[i]) & 0xff;
-		swap(i,j);
+		i = (i + 1) & 0xff;
+		j = (j + s[i]) & 0xff;
+		swap(i, j);
 		buf[k] ^= s[(s[i] + s[j]) & 0xff];
 		crc = wep_crc32_table[(crc ^ buf[k]) & 0xff] ^ (crc >> 8);
 	}
@@ -223,28 +235,32 @@ int wep_decrypt(wlandevice_t *wlandev, u
 
 	for (k = 0; k < 4; k++) {
 		i = (i + 1) & 0xff;
-		j = (j+s[i]) & 0xff;
-		swap(i,j);
+		j = (j + s[i]) & 0xff;
+		swap(i, j);
 		if ((c_crc[k] ^ s[(s[i] + s[j]) & 0xff]) != icv[k])
-			return -(4 | (k << 4)) ; /* ICV mismatch */
+			return -(4 | (k << 4));	/* ICV mismatch */
 	}
 
 	return 0;
 }
 
 /* encrypts in-place. */
-int wep_encrypt(wlandevice_t *wlandev, u8 *buf, u8 *dst, u32 len, int keynum, u8 *iv, u8 *icv)
+int wep_encrypt(wlandevice_t * wlandev, u8 * buf, u8 * dst, u32 len, int keynum,
+		u8 * iv, u8 * icv)
 {
 	u32 i, j, k, crc, keylen;
 	u8 s[256], key[64];
 
 	/* no point in WEPping an empty frame */
-	if (len <= 0) return -1;
+	if (len <= 0)
+		return -1;
 
 	/* we need to have a real key.. */
-	if (keynum >= NUM_WEPKEYS) return -2;
+	if (keynum >= NUM_WEPKEYS)
+		return -2;
 	keylen = wlandev->wep_keylens[keynum];
-	if (keylen <= 0) return -3;
+	if (keylen <= 0)
+		return -3;
 
 	/* use a random IV.  And skip known weak ones. */
 	get_random_bytes(iv, 3);
@@ -258,12 +274,15 @@ int wep_encrypt(wlandevice_t *wlandev, u
 	key[2] = iv[2];
 
 	/* copy the rest of the key over from the designated key */
-	memcpy(key+3, wlandev->wep_keys[keynum], keylen);
+	memcpy(key + 3, wlandev->wep_keys[keynum], keylen);
 
-	keylen+=3;  /* add in IV bytes */
+	keylen += 3;		/* add in IV bytes */
 
 #ifdef WEP_DEBUG
-	printk(KERN_DEBUG "E %d (%d/%d %d) %02x %02x %02x %02x:%02x:%02x:%02x:%02x\n", len,  iv[3], keynum, keylen, key[0], key[1], key[2], key[3], key[4], key[5], key[6], key[7]);
+	printk(KERN_DEBUG
+	       "E %d (%d/%d %d) %02x %02x %02x %02x:%02x:%02x:%02x:%02x\n", len,
+	       iv[3], keynum, keylen, key[0], key[1], key[2], key[3], key[4],
+	       key[5], key[6], key[7]);
 #endif
 
 	/* set up the RC4 state */
@@ -272,7 +291,7 @@ int wep_encrypt(wlandevice_t *wlandev, u
 	j = 0;
 	for (i = 0; i < 256; i++) {
 		j = (j + s[i] + key[i % keylen]) & 0xff;
-		swap(i,j);
+		swap(i, j);
 	}
 
 	/* Update CRC32 then apply RC4 to the data */
@@ -280,9 +299,9 @@ int wep_encrypt(wlandevice_t *wlandev, u
 	i = j = 0;
 	for (k = 0; k < len; k++) {
 		crc = wep_crc32_table[(crc ^ buf[k]) & 0xff] ^ (crc >> 8);
-		i = (i+1) & 0xff;
-		j = (j+s[i]) & 0xff;
-		swap(i,j);
+		i = (i + 1) & 0xff;
+		j = (j + s[i]) & 0xff;
+		swap(i, j);
 		dst[k] = buf[k] ^ s[(s[i] + s[j]) & 0xff];
 	}
 	crc = ~crc;
@@ -295,8 +314,8 @@ int wep_encrypt(wlandevice_t *wlandev, u
 
 	for (k = 0; k < 4; k++) {
 		i = (i + 1) & 0xff;
-		j = (j+s[i]) & 0xff;
-		swap(i,j);
+		j = (j + s[i]) & 0xff;
+		swap(i, j);
 		icv[k] ^= s[(s[i] + s[j]) & 0xff];
 	}
 
--- a/drivers/staging/wlan-ng/p80211wext.c
+++ b/drivers/staging/wlan-ng/p80211wext.c
@@ -37,8 +37,6 @@
 /*================================================================*/
 /* System Includes */
 
-
-
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/types.h>
@@ -68,10 +66,10 @@
 #include "p80211ioctl.h"
 #include "p80211req.h"
 
-static int p80211wext_giwrate(netdevice_t *dev,
+static int p80211wext_giwrate(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      struct iw_param *rrq, char *extra);
-static int p80211wext_giwessid(netdevice_t *dev,
+static int p80211wext_giwessid(netdevice_t * dev,
 			       struct iw_request_info *info,
 			       struct iw_point *data, char *essid);
 
@@ -132,7 +130,7 @@ static int qual_as_percent(int snr)
 	return 100;
 }
 
-static int p80211wext_dorequest(wlandevice_t *wlandev, u32 did, u32 data)
+static int p80211wext_dorequest(wlandevice_t * wlandev, u32 did, u32 data)
 {
 	p80211msg_dot11req_mibset_t msg;
 	p80211item_uint32_t mibitem;
@@ -142,12 +140,12 @@ static int p80211wext_dorequest(wlandevi
 	mibitem.did = did;
 	mibitem.data = data;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	return result;
 }
 
-static int p80211wext_autojoin(wlandevice_t *wlandev)
+static int p80211wext_autojoin(wlandevice_t * wlandev)
 {
 	p80211msg_lnxreq_autojoin_t msg;
 	struct iw_point data;
@@ -179,7 +177,7 @@ static int p80211wext_autojoin(wlandevic
 	memcpy(msg.ssid.data.data, ssid, data.length);
 	msg.ssid.data.len = data.length;
 
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -216,7 +214,7 @@ struct iw_statistics *p80211wext_get_wir
 	if (wlandev->mlmerequest == NULL)
 		return NULL;
 
-	retval = wlandev->mlmerequest(wlandev, (p80211msg_t *)&quality);
+	retval = wlandev->mlmerequest(wlandev, (p80211msg_t *) & quality);
 
 	wstats->qual.qual = qual_as_percent(quality.link.data);	/* overall link quality */
 	wstats->qual.level = quality.level.data;	/* instant signal level */
@@ -234,7 +232,7 @@ struct iw_statistics *p80211wext_get_wir
 	return wstats;
 }
 
-static int p80211wext_giwname(netdevice_t *dev,
+static int p80211wext_giwname(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      char *name, char *extra)
 {
@@ -263,7 +261,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_giwfreq(netdevice_t *dev,
+static int p80211wext_giwfreq(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      struct iw_freq *freq, char *extra)
 {
@@ -276,7 +274,7 @@ static int p80211wext_giwfreq(netdevice_
 	msg.msgcode = DIDmsg_dot11req_mibget;
 	mibitem.did = DIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentChannel;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -298,7 +296,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_siwfreq(netdevice_t *dev,
+static int p80211wext_siwfreq(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      struct iw_freq *freq, char *extra)
 {
@@ -323,7 +321,7 @@ static int p80211wext_siwfreq(netdevice_
 		mibitem.data = p80211_mhz_to_channel(freq->m);
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -334,9 +332,9 @@ exit:
 	return err;
 }
 
-static int p80211wext_giwmode(netdevice_t *dev,
+static int p80211wext_giwmode(netdevice_t * dev,
 			      struct iw_request_info *info,
-			      __u32 *mode, char *extra)
+			      __u32 * mode, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
 
@@ -358,9 +356,9 @@ static int p80211wext_giwmode(netdevice_
 	return 0;
 }
 
-static int p80211wext_siwmode(netdevice_t *dev,
+static int p80211wext_siwmode(netdevice_t * dev,
 			      struct iw_request_info *info,
-			      __u32 *mode, char *extra)
+			      __u32 * mode, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
 	p80211item_uint32_t mibitem;
@@ -404,7 +402,7 @@ static int p80211wext_siwmode(netdevice_
 	mibitem.did = DIDmib_p2_p2Static_p2CnfPortType;
 	mibitem.data = (*mode == IW_MODE_ADHOC) ? 0 : 1;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result)
 		err = -EFAULT;
@@ -413,7 +411,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_giwrange(netdevice_t *dev,
+static int p80211wext_giwrange(netdevice_t * dev,
 			       struct iw_request_info *info,
 			       struct iw_point *data, char *extra)
 {
@@ -482,7 +480,7 @@ static int p80211wext_giwrange(netdevice
 	return 0;
 }
 
-static int p80211wext_giwap(netdevice_t *dev,
+static int p80211wext_giwap(netdevice_t * dev,
 			    struct iw_request_info *info,
 			    struct sockaddr *ap_addr, char *extra)
 {
@@ -495,7 +493,7 @@ static int p80211wext_giwap(netdevice_t 
 	return 0;
 }
 
-static int p80211wext_giwencode(netdevice_t *dev,
+static int p80211wext_giwencode(netdevice_t * dev,
 				struct iw_request_info *info,
 				struct iw_point *erq, char *key)
 {
@@ -536,7 +534,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_siwencode(netdevice_t *dev,
+static int p80211wext_siwencode(netdevice_t * dev,
 				struct iw_request_info *info,
 				struct iw_point *erq, char *key)
 {
@@ -626,7 +624,7 @@ static int p80211wext_siwencode(netdevic
 
 			msg.msgcode = DIDmsg_dot11req_mibset;
 			memcpy(&msg.mibattribute.data, &pstr, sizeof(pstr));
-			result = p80211req_dorequest(wlandev, (u8 *)&msg);
+			result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 			if (result) {
 				err = -EFAULT;
@@ -683,7 +681,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_giwessid(netdevice_t *dev,
+static int p80211wext_giwessid(netdevice_t * dev,
 			       struct iw_request_info *info,
 			       struct iw_point *data, char *essid)
 {
@@ -706,7 +704,7 @@ static int p80211wext_giwessid(netdevice
 	return 0;
 }
 
-static int p80211wext_siwessid(netdevice_t *dev,
+static int p80211wext_siwessid(netdevice_t * dev,
 			       struct iw_request_info *info,
 			       struct iw_point *data, char *essid)
 {
@@ -742,7 +740,7 @@ static int p80211wext_siwessid(netdevice
 	msg.ssid.data.len = length;
 
 	pr_debug("autojoin_ssid for %s \n", essid);
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 	pr_debug("autojoin_ssid %d\n", result);
 
 	if (result) {
@@ -754,7 +752,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_siwcommit(netdevice_t *dev,
+static int p80211wext_siwcommit(netdevice_t * dev,
 				struct iw_request_info *info,
 				struct iw_point *data, char *essid)
 {
@@ -773,7 +771,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_giwrate(netdevice_t *dev,
+static int p80211wext_giwrate(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      struct iw_param *rrq, char *extra)
 {
@@ -786,7 +784,7 @@ static int p80211wext_giwrate(netdevice_
 	msg.msgcode = DIDmsg_dot11req_mibget;
 	mibitem.did = DIDmib_p2_p2MAC_p2CurrentTxRate;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -824,7 +822,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_giwrts(netdevice_t *dev,
+static int p80211wext_giwrts(netdevice_t * dev,
 			     struct iw_request_info *info,
 			     struct iw_param *rts, char *extra)
 {
@@ -837,7 +835,7 @@ static int p80211wext_giwrts(netdevice_t
 	msg.msgcode = DIDmsg_dot11req_mibget;
 	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11RTSThreshold;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -854,7 +852,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_siwrts(netdevice_t *dev,
+static int p80211wext_siwrts(netdevice_t * dev,
 			     struct iw_request_info *info,
 			     struct iw_param *rts, char *extra)
 {
@@ -877,7 +875,7 @@ static int p80211wext_siwrts(netdevice_t
 		mibitem.data = rts->value;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -888,7 +886,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_giwfrag(netdevice_t *dev,
+static int p80211wext_giwfrag(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      struct iw_param *frag, char *extra)
 {
@@ -902,7 +900,7 @@ static int p80211wext_giwfrag(netdevice_
 	mibitem.did =
 	    DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -919,7 +917,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_siwfrag(netdevice_t *dev,
+static int p80211wext_siwfrag(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      struct iw_param *frag, char *extra)
 {
@@ -944,7 +942,7 @@ static int p80211wext_siwfrag(netdevice_
 		mibitem.data = frag->value;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -963,7 +961,7 @@ exit:
 #define IW_RETRY_SHORT IW_RETRY_MIN
 #endif
 
-static int p80211wext_giwretry(netdevice_t *dev,
+static int p80211wext_giwretry(netdevice_t * dev,
 			       struct iw_request_info *info,
 			       struct iw_param *rrq, char *extra)
 {
@@ -978,7 +976,7 @@ static int p80211wext_giwretry(netdevice
 	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -992,7 +990,7 @@ static int p80211wext_giwretry(netdevice
 	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -1007,7 +1005,7 @@ static int p80211wext_giwretry(netdevice
 	    DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -1040,7 +1038,7 @@ exit:
 
 }
 
-static int p80211wext_siwretry(netdevice_t *dev,
+static int p80211wext_siwretry(netdevice_t * dev,
 			       struct iw_request_info *info,
 			       struct iw_param *rrq, char *extra)
 {
@@ -1068,7 +1066,7 @@ static int p80211wext_siwretry(netdevice
 		mibitem.data = rrq->value /= 1024;
 
 		memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-		result = p80211req_dorequest(wlandev, (u8 *)&msg);
+		result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 		if (result) {
 			err = -EFAULT;
@@ -1082,7 +1080,7 @@ static int p80211wext_siwretry(netdevice
 
 			memcpy(&msg.mibattribute.data, &mibitem,
 			       sizeof(mibitem));
-			result = p80211req_dorequest(wlandev, (u8 *)&msg);
+			result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 			if (result) {
 				err = -EFAULT;
@@ -1097,7 +1095,7 @@ static int p80211wext_siwretry(netdevice
 
 			memcpy(&msg.mibattribute.data, &mibitem,
 			       sizeof(mibitem));
-			result = p80211req_dorequest(wlandev, (u8 *)&msg);
+			result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 			if (result) {
 				err = -EFAULT;
@@ -1111,7 +1109,7 @@ exit:
 
 }
 
-static int p80211wext_siwtxpow(netdevice_t *dev,
+static int p80211wext_siwtxpow(netdevice_t * dev,
 			       struct iw_request_info *info,
 			       struct iw_param *rrq, char *extra)
 {
@@ -1134,7 +1132,7 @@ static int p80211wext_siwtxpow(netdevice
 	else
 		mibitem.data = rrq->value;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -1145,7 +1143,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_giwtxpow(netdevice_t *dev,
+static int p80211wext_giwtxpow(netdevice_t * dev,
 			       struct iw_request_info *info,
 			       struct iw_param *rrq, char *extra)
 {
@@ -1160,7 +1158,7 @@ static int p80211wext_giwtxpow(netdevice
 	    DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -1180,7 +1178,7 @@ exit:
 	return err;
 }
 
-static int p80211wext_siwspy(netdevice_t *dev,
+static int p80211wext_siwspy(netdevice_t * dev,
 			     struct iw_request_info *info,
 			     struct iw_point *srq, char *extra)
 {
@@ -1215,7 +1213,7 @@ static int p80211wext_siwspy(netdevice_t
 }
 
 /* jkriegl: from orinoco, modified */
-static int p80211wext_giwspy(netdevice_t *dev,
+static int p80211wext_giwspy(netdevice_t * dev,
 			     struct iw_request_info *info,
 			     struct iw_point *srq, char *extra)
 {
@@ -1275,7 +1273,7 @@ static int prism2_result2err(int prism2_
 	return err;
 }
 
-static int p80211wext_siwscan(netdevice_t *dev,
+static int p80211wext_siwscan(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      struct iw_point *srq, char *extra)
 {
@@ -1308,7 +1306,7 @@ static int p80211wext_siwscan(netdevice_
 	msg.maxchanneltime.data = 250;
 	msg.minchanneltime.data = 200;
 
-	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *) & msg);
 	if (result)
 		err = prism2_result2err(msg.resultcode.data);
 
@@ -1322,7 +1320,7 @@ exit:
  */
 static char *wext_translate_bss(struct iw_request_info *info, char *current_ev,
 				char *end_buf,
-				p80211msg_dot11req_scan_results_t *bss)
+				p80211msg_dot11req_scan_results_t * bss)
 {
 	struct iw_event iwe;	/* Temporary buffer */
 
@@ -1406,7 +1404,7 @@ static char *wext_translate_bss(struct i
 	return current_ev;
 }
 
-static int p80211wext_giwscan(netdevice_t *dev,
+static int p80211wext_giwscan(netdevice_t * dev,
 			      struct iw_request_info *info,
 			      struct iw_point *srq, char *extra)
 {
@@ -1427,7 +1425,7 @@ static int p80211wext_giwscan(netdevice_
 		msg.msgcode = DIDmsg_dot11req_scan_results;
 		msg.bssindex.data = i;
 
-		result = p80211req_dorequest(wlandev, (u8 *)&msg);
+		result = p80211req_dorequest(wlandev, (u8 *) & msg);
 		if ((result != 0) ||
 		    (msg.resultcode.data != P80211ENUM_resultcode_success)) {
 			break;
@@ -1466,7 +1464,7 @@ static int p80211wext_set_encodeext(stru
 	int idx = encoding->flags & IW_ENCODE_INDEX;
 
 	pr_debug("set_encode_ext flags[%d] alg[%d] keylen[%d]\n",
-	       ext->ext_flags, (int)ext->alg, (int)ext->key_len);
+		 ext->ext_flags, (int)ext->alg, (int)ext->key_len);
 
 	if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
 		/* set default key ? I'm not sure if this the the correct thing to do here */
@@ -1502,7 +1500,7 @@ static int p80211wext_set_encodeext(stru
 		memcpy(wlandev->wep_keys[idx], ext->key, ext->key_len);
 
 		memset(&msg, 0, sizeof(msg));
-		pstr = (p80211item_pstr32_t *)&msg.mibattribute.data;
+		pstr = (p80211item_pstr32_t *) & msg.mibattribute.data;
 		memcpy(pstr->data.data, ext->key, ext->key_len);
 		pstr->data.len = ext->key_len;
 		switch (idx) {
@@ -1526,7 +1524,7 @@ static int p80211wext_set_encodeext(stru
 			break;
 		}
 		msg.msgcode = DIDmsg_dot11req_mibset;
-		result = p80211req_dorequest(wlandev, (u8 *)&msg);
+		result = p80211req_dorequest(wlandev, (u8 *) & msg);
 		pr_debug("result (%d)\n", result);
 	}
 	return result;
@@ -1546,12 +1544,11 @@ static int p80211wext_get_encodeext(stru
 	int idx;
 
 	pr_debug("get_encode_ext flags[%d] alg[%d] keylen[%d]\n",
-	       ext->ext_flags, (int)ext->alg, (int)ext->key_len);
+		 ext->ext_flags, (int)ext->alg, (int)ext->key_len);
 
 	max_len = encoding->length - sizeof(*ext);
 	if (max_len <= 0) {
-		pr_debug("get_encodeext max_len [%d] invalid\n",
-		       max_len);
+		pr_debug("get_encodeext max_len [%d] invalid\n", max_len);
 		result = -EINVAL;
 		goto exit;
 	}
@@ -1561,8 +1558,8 @@ static int p80211wext_get_encodeext(stru
 
 	if (idx) {
 		if (idx < 1 || idx > NUM_WEPKEYS) {
-			pr_debug(
-			       "get_encode_ext invalid key index [%d]\n", idx);
+			pr_debug("get_encode_ext invalid key index [%d]\n",
+				 idx);
 			result = -EINVAL;
 			goto exit;
 		}
@@ -1593,8 +1590,7 @@ static int p80211_wext_set_iwauth(struct
 	struct iw_param *param = &wrqu->param;
 	int result = 0;
 
-	pr_debug("set_iwauth flags[%d]\n",
-	       (int)param->flags & IW_AUTH_INDEX);
+	pr_debug("set_iwauth flags[%d]\n", (int)param->flags & IW_AUTH_INDEX);
 
 	switch (param->flags & IW_AUTH_INDEX) {
 	case IW_AUTH_DROP_UNENCRYPTED:
@@ -1635,8 +1631,7 @@ static int p80211_wext_set_iwauth(struct
 			wlandev->hostwep |= HOSTWEP_SHAREDKEY;
 		} else {
 			/* don't know what to do know  */
-			pr_debug("unknown AUTH_ALG (%d)\n",
-			       param->value);
+			pr_debug("unknown AUTH_ALG (%d)\n", param->value);
 			result = -EINVAL;
 		}
 		break;
@@ -1657,8 +1652,7 @@ static int p80211_wext_get_iwauth(struct
 	struct iw_param *param = &wrqu->param;
 	int result = 0;
 
-	pr_debug("get_iwauth flags[%d]\n",
-	       (int)param->flags & IW_AUTH_INDEX);
+	pr_debug("get_iwauth flags[%d]\n", (int)param->flags & IW_AUTH_INDEX);
 
 	switch (param->flags & IW_AUTH_INDEX) {
 	case IW_AUTH_DROP_UNENCRYPTED:
@@ -1673,9 +1667,8 @@ static int p80211_wext_get_iwauth(struct
 
 	case IW_AUTH_80211_AUTH_ALG:
 		param->value =
-		    wlandev->
-		    hostwep & HOSTWEP_SHAREDKEY ? IW_AUTH_ALG_SHARED_KEY :
-		    IW_AUTH_ALG_OPEN_SYSTEM;
+		    wlandev->hostwep & HOSTWEP_SHAREDKEY ?
+		    IW_AUTH_ALG_SHARED_KEY : IW_AUTH_ALG_OPEN_SYSTEM;
 		break;
 
 	default:
@@ -1755,7 +1748,7 @@ struct iw_handler_def p80211wext_handler
 	.get_wireless_stats = p80211wext_get_wireless_stats
 };
 
-int p80211wext_event_associated(wlandevice_t *wlandev, int assoc)
+int p80211wext_event_associated(wlandevice_t * wlandev, int assoc)
 {
 	union iwreq_data data;
 
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -50,7 +50,6 @@
 #include <linux/sort.h>
 #include <linux/firmware.h>
 
-
 /*================================================================*/
 /* Local Constants */
 
@@ -125,89 +124,80 @@
 		    : "cc");						      \
 	 __v; }))
 
-
-
 /*================================================================*/
 /* Local Types */
 
-typedef struct s3datarec
-{
-	u32	len;
-	u32	addr;
-	u8	checksum;
-	u8	*data;
+typedef struct s3datarec {
+	u32 len;
+	u32 addr;
+	u8 checksum;
+	u8 *data;
 } s3datarec_t;
 
-typedef struct s3plugrec
-{
-	u32	itemcode;
-	u32	addr;
-	u32	len;
+typedef struct s3plugrec {
+	u32 itemcode;
+	u32 addr;
+	u32 len;
 } s3plugrec_t;
 
-typedef struct s3crcrec
-{
-	u32		addr;
-	u32		len;
-	unsigned int	dowrite;
+typedef struct s3crcrec {
+	u32 addr;
+	u32 len;
+	unsigned int dowrite;
 } s3crcrec_t;
 
-typedef struct s3inforec
-{
-	u16	len;
-	u16	type;
+typedef struct s3inforec {
+	u16 len;
+	u16 type;
 	union {
-		hfa384x_compident_t	version;
-		hfa384x_caplevel_t	compat;
-		u16			buildseq;
-		hfa384x_compident_t	platform;
-	}	info;
+		hfa384x_compident_t version;
+		hfa384x_caplevel_t compat;
+		u16 buildseq;
+		hfa384x_compident_t platform;
+	} info;
 } s3inforec_t;
 
-typedef struct pda
-{
-	u8		buf[HFA384x_PDA_LEN_MAX];
-	hfa384x_pdrec_t	*rec[HFA384x_PDA_RECS_MAX];
-	unsigned int	nrec;
+typedef struct pda {
+	u8 buf[HFA384x_PDA_LEN_MAX];
+	hfa384x_pdrec_t *rec[HFA384x_PDA_RECS_MAX];
+	unsigned int nrec;
 } pda_t;
 
-typedef struct imgchunk
-{
-	u32	addr;	/* start address */
-	u32	len;	/* in bytes */
-	u16	crc;	/* CRC value (if it falls at a chunk boundary) */
-	u8	*data;
+typedef struct imgchunk {
+	u32 addr;		/* start address */
+	u32 len;		/* in bytes */
+	u16 crc;		/* CRC value (if it falls at a chunk boundary) */
+	u8 *data;
 } imgchunk_t;
 
 /*================================================================*/
 /* Local Static Definitions */
 
-
 /*----------------------------------------------------------------*/
 /* s-record image processing */
 
 /* Data records */
-unsigned int	ns3data = 0;
-s3datarec_t	s3data[S3DATA_MAX];
+unsigned int ns3data = 0;
+s3datarec_t s3data[S3DATA_MAX];
 
 /* Plug records */
-unsigned int	ns3plug = 0;
-s3plugrec_t	s3plug[S3PLUG_MAX];
+unsigned int ns3plug = 0;
+s3plugrec_t s3plug[S3PLUG_MAX];
 
 /* CRC records */
-unsigned int	ns3crc = 0;
-s3crcrec_t	s3crc[S3CRC_MAX];
+unsigned int ns3crc = 0;
+s3crcrec_t s3crc[S3CRC_MAX];
 
 /* Info records */
-unsigned int	ns3info = 0;
-s3inforec_t	s3info[S3INFO_MAX];
+unsigned int ns3info = 0;
+s3inforec_t s3info[S3INFO_MAX];
 
 /* S7 record (there _better_ be only one) */
-u32		startaddr;
+u32 startaddr;
 
 /* Load image chunks */
-unsigned int	nfchunks;
-imgchunk_t	fchunk[CHUNKS_MAX];
+unsigned int nfchunks;
+imgchunk_t fchunk[CHUNKS_MAX];
 
 /* Note that for the following pdrec_t arrays, the len and code */
 /*   fields are stored in HOST byte order. The mkpdrlist() function */
@@ -215,36 +205,35 @@ imgchunk_t	fchunk[CHUNKS_MAX];
 /*----------------------------------------------------------------*/
 /* PDA, built from [card|newfile]+[addfile1+addfile2...] */
 
-pda_t		pda;
+pda_t pda;
 hfa384x_compident_t nicid;
-hfa384x_caplevel_t  rfid;
-hfa384x_caplevel_t  macid;
-hfa384x_caplevel_t  priid;
-
+hfa384x_caplevel_t rfid;
+hfa384x_caplevel_t macid;
+hfa384x_caplevel_t priid;
 
 /*================================================================*/
 /* Local Function Declarations */
 
-int	prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev);
-int	read_srecfile(char *rfptr, int rfsize);
-int	mkimage(imgchunk_t *clist, unsigned int *ccnt);
-int	read_cardpda(pda_t *pda, wlandevice_t *wlandev);
-int	mkpdrlist( pda_t *pda);
-int	s3datarec_compare(const void *p1, const void *p2);
-int	plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
-		s3plugrec_t* s3plug, unsigned int ns3plug, pda_t *pda);
-int	crcimage( imgchunk_t *fchunk, unsigned int nfchunks,
-		s3crcrec_t *s3crc, unsigned int ns3crc);
-int	writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk, unsigned int nfchunks);
-void	free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks);
-void	free_srecs(void);
+int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t * wlandev);
+int read_srecfile(char *rfptr, int rfsize);
+int mkimage(imgchunk_t * clist, unsigned int *ccnt);
+int read_cardpda(pda_t * pda, wlandevice_t * wlandev);
+int mkpdrlist(pda_t * pda);
+int s3datarec_compare(const void *p1, const void *p2);
+int plugimage(imgchunk_t * fchunk, unsigned int nfchunks,
+	      s3plugrec_t * s3plug, unsigned int ns3plug, pda_t * pda);
+int crcimage(imgchunk_t * fchunk, unsigned int nfchunks,
+	     s3crcrec_t * s3crc, unsigned int ns3crc);
+int writeimage(wlandevice_t * wlandev, imgchunk_t * fchunk,
+	       unsigned int nfchunks);
+void free_chunks(imgchunk_t * fchunk, unsigned int *nfchunks);
+void free_srecs(void);
 
-int     validate_identity(void);
+int validate_identity(void);
 
 /*================================================================*/
 /* Function Definitions */
 
-
 /*----------------------------------------------------------------
 * prism2_fwtry
 *
@@ -258,13 +247,13 @@ int     validate_identity(void);
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
+int prism2_fwtry(struct usb_device *udev, wlandevice_t * wlandev)
 {
 	const struct firmware *fw_entry = NULL;
 
-	printk(KERN_INFO "prism2_usb: Checking for firmware %s\n", PRISM2_USB_FWFILE);
-	if(request_firmware(&fw_entry, PRISM2_USB_FWFILE, &udev->dev) != 0)
-	{
+	printk(KERN_INFO "prism2_usb: Checking for firmware %s\n",
+	       PRISM2_USB_FWFILE);
+	if (request_firmware(&fw_entry, PRISM2_USB_FWFILE, &udev->dev) != 0) {
 		printk(KERN_INFO
 		       "prism2_usb: Firmware not available, but not essential\n");
 		printk(KERN_INFO
@@ -272,14 +261,14 @@ int prism2_fwtry(struct usb_device *udev
 		return 1;
 	}
 
-	printk(KERN_INFO "prism2_usb: %s will be processed, size %d\n", PRISM2_USB_FWFILE, fw_entry->size);
+	printk(KERN_INFO "prism2_usb: %s will be processed, size %d\n",
+	       PRISM2_USB_FWFILE, fw_entry->size);
 	prism2_fwapply((char *)fw_entry->data, fw_entry->size, wlandev);
 
 	release_firmware(fw_entry);
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * prism2_fwapply
 *
@@ -294,12 +283,12 @@ int prism2_fwtry(struct usb_device *udev
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
+int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t * wlandev)
 {
-	signed int	result = 0;
+	signed int result = 0;
 	p80211msg_dot11req_mibget_t getmsg;
 	p80211itemd_t *item;
-	u32        *data;
+	u32 *data;
 
 	/* Initialize the data structures */
 	ns3data = 0;
@@ -313,20 +302,19 @@ int prism2_fwapply(char *rfptr, int rfsi
 	startaddr = 0;
 
 	nfchunks = 0;
-	memset( fchunk, 0, sizeof(fchunk));
-	memset( &nicid, 0, sizeof(nicid));
-	memset( &rfid, 0, sizeof(rfid));
-	memset( &macid, 0, sizeof(macid));
-	memset( &priid, 0, sizeof(priid));
+	memset(fchunk, 0, sizeof(fchunk));
+	memset(&nicid, 0, sizeof(nicid));
+	memset(&rfid, 0, sizeof(rfid));
+	memset(&macid, 0, sizeof(macid));
+	memset(&priid, 0, sizeof(priid));
 
 	/* clear the pda and add an initial END record */
 	memset(&pda, 0, sizeof(pda));
-	pda.rec[0] = (hfa384x_pdrec_t*)pda.buf;
-	pda.rec[0]->len = cpu_to_le16(2);  	/* len in words */  			/* len in words */
+	pda.rec[0] = (hfa384x_pdrec_t *) pda.buf;
+	pda.rec[0]->len = cpu_to_le16(2);	/* len in words *//* len in words */
 	pda.rec[0]->code = cpu_to_le16(HFA384x_PDR_END_OF_PDA);
 	pda.nrec = 1;
 
-
 	/*-----------------------------------------------------*/
 	/* Put card into fwload state */
 	prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
@@ -334,7 +322,7 @@ int prism2_fwapply(char *rfptr, int rfsi
 	/* Build the PDA we're going to use. */
 	if (read_cardpda(&pda, wlandev)) {
 		printk(KERN_ERR "load_cardpda failed, exiting.\n");
-		return(1);
+		return (1);
 	}
 
 	/* read the card's PRI-SUP */
@@ -352,7 +340,7 @@ int prism2_fwapply(char *rfptr, int rfsi
 	item->did = DIDmib_p2_p2NIC_p2PRISupRange;
 	item->status = P80211ENUM_msgitem_status_no_value;
 
-	data = (u32*) item->data;
+	data = (u32 *) item->data;
 
 	/* DIDmsg_dot11req_mibget */
 	prism2mgmt_mibset_mibget(wlandev, &getmsg);
@@ -367,53 +355,48 @@ int prism2_fwapply(char *rfptr, int rfsi
 	priid.bottom = *data++;
 	priid.top = *data++;
 
-
 	/* Read the S3 file */
 	result = read_srecfile(rfptr, rfsize);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to read the data exiting.\n");
-		return(1);
+		return (1);
 	}
 	/* Sort the S3 data records */
-	sort( s3data,
-		ns3data,
-		sizeof(s3datarec_t),
-		s3datarec_compare, NULL);
+	sort(s3data, ns3data, sizeof(s3datarec_t), s3datarec_compare, NULL);
 
 	result = validate_identity();
 
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Incompatible firmware image.\n");
-		return(1);
+		return (1);
 	}
 
 	if (startaddr == 0x00000000) {
 		printk(KERN_ERR "Can't RAM download a Flash image!\n");
-		return(1);
+		return (1);
 	}
 
 	/* Make the image chunks */
 	result = mkimage(fchunk, &nfchunks);
 
 	/* Do any plugging */
-	result = plugimage(fchunk, nfchunks, s3plug, ns3plug,
-						&pda);
-	if ( result ) {
+	result = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);
+	if (result) {
 		printk(KERN_ERR "Failed to plug data.\n");
-		return(1);
+		return (1);
 	}
 
 	/* Insert any CRCs */
-	if (crcimage(fchunk, nfchunks, s3crc, ns3crc) ) {
+	if (crcimage(fchunk, nfchunks, s3crc, ns3crc)) {
 		printk(KERN_ERR "Failed to insert all CRCs\n");
-		return(1);
+		return (1);
 	}
 
 	/* Write the image */
 	result = writeimage(wlandev, fchunk, nfchunks);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to ramwrite image data.\n");
-		return(1);
+		return (1);
 	}
 
 	/* clear any allocated memory */
@@ -425,7 +408,6 @@ int prism2_fwapply(char *rfptr, int rfsi
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * crcimage
 *
@@ -443,59 +425,60 @@ int prism2_fwapply(char *rfptr, int rfsi
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int crcimage(imgchunk_t *fchunk, unsigned int nfchunks, s3crcrec_t *s3crc,
+int crcimage(imgchunk_t * fchunk, unsigned int nfchunks, s3crcrec_t * s3crc,
 	     unsigned int ns3crc)
 {
-	int	result = 0;
-	int	i;
-	int	c;
-	u32	crcstart;
-	u32	crcend;
-	u32	cstart = 0;
-	u32	cend;
-	u8	*dest;
-	u32	chunkoff;
+	int result = 0;
+	int i;
+	int c;
+	u32 crcstart;
+	u32 crcend;
+	u32 cstart = 0;
+	u32 cend;
+	u8 *dest;
+	u32 chunkoff;
 
-	for ( i = 0; i < ns3crc; i++ ) {
-		if ( !s3crc[i].dowrite ) continue;
+	for (i = 0; i < ns3crc; i++) {
+		if (!s3crc[i].dowrite)
+			continue;
 		crcstart = s3crc[i].addr;
-		crcend =   s3crc[i].addr + s3crc[i].len;
+		crcend = s3crc[i].addr + s3crc[i].len;
 		/* Find chunk */
-		for ( c = 0; c < nfchunks; c++) {
+		for (c = 0; c < nfchunks; c++) {
 			cstart = fchunk[c].addr;
-			cend =	 fchunk[c].addr + fchunk[c].len;
+			cend = fchunk[c].addr + fchunk[c].len;
 			/*  the line below does an address & len match search */
 			/*  unfortunately, I've found that the len fields of */
 			/*  some crc records don't match with the length of */
 			/*  the actual data, so we're not checking right */
 			/*  now */
-			/* if ( crcstart-2 >= cstart && crcend <= cend ) break;*/
+			/* if ( crcstart-2 >= cstart && crcend <= cend ) break; */
 
 			/* note the -2 below, it's to make sure the chunk has */
 			/*   space for the CRC value */
-			if ( crcstart-2 >= cstart && crcstart < cend ) break;
+			if (crcstart - 2 >= cstart && crcstart < cend)
+				break;
 		}
-		if ( c >= nfchunks ) {
+		if (c >= nfchunks) {
 			printk(KERN_ERR
-				"Failed to find chunk for "
-				"crcrec[%d], addr=0x%06x len=%d , "
-				"aborting crc.\n",
-				i, s3crc[i].addr, s3crc[i].len);
+			       "Failed to find chunk for "
+			       "crcrec[%d], addr=0x%06x len=%d , "
+			       "aborting crc.\n",
+			       i, s3crc[i].addr, s3crc[i].len);
 			return 1;
 		}
 
 		/* Insert crc */
-		pr_debug("Adding crc @ 0x%06x\n", s3crc[i].addr-2);
+		pr_debug("Adding crc @ 0x%06x\n", s3crc[i].addr - 2);
 		chunkoff = crcstart - cstart - 2;
 		dest = fchunk[c].data + chunkoff;
-		*dest =     0xde;
-		*(dest+1) = 0xc0;
+		*dest = 0xde;
+		*(dest + 1) = 0xc0;
 
 	}
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * free_chunks
 *
@@ -507,20 +490,19 @@ int crcimage(imgchunk_t *fchunk, unsigne
 * Returns:
 *	nothing
 ----------------------------------------------------------------*/
-void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
+void free_chunks(imgchunk_t * fchunk, unsigned int *nfchunks)
 {
 	int i;
-	for ( i = 0; i < *nfchunks; i++) {
-		if ( fchunk[i].data != NULL ) {
+	for (i = 0; i < *nfchunks; i++) {
+		if (fchunk[i].data != NULL) {
 			kfree(fchunk[i].data);
 		}
 	}
 	*nfchunks = 0;
-	memset( fchunk, 0, sizeof(fchunk));
+	memset(fchunk, 0, sizeof(fchunk));
 
 }
 
-
 /*----------------------------------------------------------------
 * free_srecs
 *
@@ -535,7 +517,7 @@ void free_chunks(imgchunk_t *fchunk, uns
 void free_srecs(void)
 {
 	int i;
-	for ( i = 0; i < ns3data; i++) {
+	for (i = 0; i < ns3data; i++) {
 		kfree(s3data[i].data);
 	}
 	ns3data = 0;
@@ -549,7 +531,6 @@ void free_srecs(void)
 	startaddr = 0;
 }
 
-
 /*----------------------------------------------------------------
 * mkimage
 *
@@ -564,25 +545,25 @@ void free_srecs(void)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkimage(imgchunk_t *clist, unsigned int *ccnt)
+int mkimage(imgchunk_t * clist, unsigned int *ccnt)
 {
-	int		result = 0;
-	int		i;
-	int		j;
-	int		currchunk = 0;
-	u32		nextaddr = 0;
-	u32		s3start;
-	u32		s3end;
-	u32		cstart = 0;
-	u32		cend;
-	u32		coffset;
+	int result = 0;
+	int i;
+	int j;
+	int currchunk = 0;
+	u32 nextaddr = 0;
+	u32 s3start;
+	u32 s3end;
+	u32 cstart = 0;
+	u32 cend;
+	u32 coffset;
 
 	/* There may already be data in the chunklist */
 	*ccnt = 0;
 
 	/* Establish the location and size of each chunk */
-	for ( i = 0; i < ns3data; i++) {
-		if ( s3data[i].addr == nextaddr ) {
+	for (i = 0; i < ns3data; i++) {
+		if (s3data[i].addr == nextaddr) {
 			/* existing chunk, grow it */
 			clist[currchunk].len += s3data[i].len;
 			nextaddr += s3data[i].len;
@@ -595,9 +576,9 @@ int mkimage(imgchunk_t *clist, unsigned 
 			nextaddr = s3data[i].addr + s3data[i].len;
 			/* Expand the chunk if there is a CRC record at */
 			/* their beginning bound */
-			for ( j = 0; j < ns3crc; j++) {
-				if ( s3crc[j].dowrite &&
-				     s3crc[j].addr == clist[currchunk].addr ) {
+			for (j = 0; j < ns3crc; j++) {
+				if (s3crc[j].dowrite &&
+				    s3crc[j].addr == clist[currchunk].addr) {
 					clist[currchunk].addr -= 2;
 					clist[currchunk].len += 2;
 				}
@@ -609,41 +590,41 @@ int mkimage(imgchunk_t *clist, unsigned 
 	/*  if this proves false, we'll need to add code to coalesce. */
 
 	/* Allocate buffer space for chunks */
-	for ( i = 0; i < *ccnt; i++) {
+	for (i = 0; i < *ccnt; i++) {
 		clist[i].data = kmalloc(clist[i].len, GFP_KERNEL);
-		if  ( clist[i].data == NULL ) {
-			printk(KERN_ERR "failed to allocate image space, exitting.\n");
-			return(1);
+		if (clist[i].data == NULL) {
+			printk(KERN_ERR
+			       "failed to allocate image space, exitting.\n");
+			return (1);
 		}
 		memset(clist[i].data, 0, clist[i].len);
 	}
 
-
 	/* Display chunks */
-	for ( i = 0; i < *ccnt;  i++) {
+	for (i = 0; i < *ccnt; i++) {
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
-			i, clist[i].addr, clist[i].len);
+			 i, clist[i].addr, clist[i].len);
 	}
 
 	/* Copy srec data to chunks */
-	for ( i = 0; i < ns3data; i++) {
+	for (i = 0; i < ns3data; i++) {
 		s3start = s3data[i].addr;
-		s3end   = s3start + s3data[i].len - 1;
-		for ( j = 0; j < *ccnt; j++) {
+		s3end = s3start + s3data[i].len - 1;
+		for (j = 0; j < *ccnt; j++) {
 			cstart = clist[j].addr;
 			cend = cstart + clist[j].len - 1;
-			if ( s3start >= cstart && s3end <= cend ) {
+			if (s3start >= cstart && s3end <= cend) {
 				break;
 			}
 		}
-		if ( ((unsigned int)j) >= (*ccnt) ) {
+		if (((unsigned int)j) >= (*ccnt)) {
 			printk(KERN_ERR
-				"s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
-				s3start, s3data[i].len);
-			return(1);
+			       "s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
+			       s3start, s3data[i].len);
+			return (1);
 		}
 		coffset = s3start - cstart;
-		memcpy( clist[j].data + coffset, s3data[i].data, s3data[i].len);
+		memcpy(clist[j].data + coffset, s3data[i].data, s3data[i].len);
 	}
 
 	return result;
@@ -663,21 +644,19 @@ int mkimage(imgchunk_t *clist, unsigned 
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkpdrlist( pda_t *pda)
+int mkpdrlist(pda_t * pda)
 {
-	int	result = 0;
-	u16	*pda16 = (u16*)pda->buf;
-	int	curroff;	/* in 'words' */
+	int result = 0;
+	u16 *pda16 = (u16 *) pda->buf;
+	int curroff;		/* in 'words' */
 
 	pda->nrec = 0;
 	curroff = 0;
-	while ( curroff < (HFA384x_PDA_LEN_MAX / 2) &&
-		le16_to_cpu(pda16[curroff + 1]) !=
-		HFA384x_PDR_END_OF_PDA ) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t*)&(pda16[curroff]);
+	while (curroff < (HFA384x_PDA_LEN_MAX / 2) &&
+	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) & (pda16[curroff]);
 
-		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
-				HFA384x_PDR_NICID) {
+		if (le16_to_cpu(pda->rec[pda->nrec]->code) == HFA384x_PDR_NICID) {
 			memcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,
 			       sizeof(nicid));
 			nicid.id = le16_to_cpu(nicid.id);
@@ -686,7 +665,7 @@ int mkpdrlist( pda_t *pda)
 			nicid.minor = le16_to_cpu(nicid.minor);
 		}
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
-				HFA384x_PDR_MFISUPRANGE) {
+		    HFA384x_PDR_MFISUPRANGE) {
 			memcpy(&rfid, &pda->rec[pda->nrec]->data.mfisuprange,
 			       sizeof(rfid));
 			rfid.id = le16_to_cpu(rfid.id);
@@ -695,7 +674,7 @@ int mkpdrlist( pda_t *pda)
 			rfid.top = le16_to_cpu(rfid.top);
 		}
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
-				HFA384x_PDR_CFISUPRANGE) {
+		    HFA384x_PDR_CFISUPRANGE) {
 			memcpy(&macid, &pda->rec[pda->nrec]->data.cfisuprange,
 			       sizeof(macid));
 			macid.id = le16_to_cpu(macid.id);
@@ -708,21 +687,19 @@ int mkpdrlist( pda_t *pda)
 		curroff += le16_to_cpu(pda16[curroff]) + 1;
 
 	}
-	if ( curroff >= (HFA384x_PDA_LEN_MAX / 2) ) {
+	if (curroff >= (HFA384x_PDA_LEN_MAX / 2)) {
 		printk(KERN_ERR
-			"no end record found or invalid lengths in "
-			"PDR data, exiting. %x %d\n", curroff, pda->nrec);
-		return(1);
+		       "no end record found or invalid lengths in "
+		       "PDR data, exiting. %x %d\n", curroff, pda->nrec);
+		return (1);
 	}
-	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA ) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t*)&(pda16[curroff]);
+	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA) {
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) & (pda16[curroff]);
 		(pda->nrec)++;
 	}
 	return result;
 }
 
-
-
 /*----------------------------------------------------------------
 * plugimage
 *
@@ -740,39 +717,39 @@ int mkpdrlist( pda_t *pda)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
-		s3plugrec_t* s3plug, unsigned int ns3plug, pda_t *pda)
+int plugimage(imgchunk_t * fchunk, unsigned int nfchunks,
+	      s3plugrec_t * s3plug, unsigned int ns3plug, pda_t * pda)
 {
-	int	result = 0;
-	int	i;	/* plug index */
-	int	j;	/* index of PDR or -1 if fname plug */
-	int	c;	/* chunk index */
-	u32	pstart;
-	u32	pend;
-	u32	cstart = 0;
-	u32	cend;
-	u32	chunkoff;
-	u8	*dest;
+	int result = 0;
+	int i;			/* plug index */
+	int j;			/* index of PDR or -1 if fname plug */
+	int c;			/* chunk index */
+	u32 pstart;
+	u32 pend;
+	u32 cstart = 0;
+	u32 cend;
+	u32 chunkoff;
+	u8 *dest;
 
 	/* for each plug record */
-	for ( i = 0; i < ns3plug; i++) {
+	for (i = 0; i < ns3plug; i++) {
 		pstart = s3plug[i].addr;
-		pend = 	 s3plug[i].addr + s3plug[i].len;
+		pend = s3plug[i].addr + s3plug[i].len;
 		/* find the matching PDR (or filename) */
-		if ( s3plug[i].itemcode != 0xffffffffUL ) { /* not filename */
-			for ( j = 0; j < pda->nrec; j++) {
-				if ( s3plug[i].itemcode ==
-				     le16_to_cpu(pda->rec[j]->code) ) break;
+		if (s3plug[i].itemcode != 0xffffffffUL) {	/* not filename */
+			for (j = 0; j < pda->nrec; j++) {
+				if (s3plug[i].itemcode ==
+				    le16_to_cpu(pda->rec[j]->code))
+					break;
 			}
 		} else {
 			j = -1;
 		}
-		if ( j >= pda->nrec && j != -1 ) { /*  if no matching PDR, fail */
+		if (j >= pda->nrec && j != -1) {	/*  if no matching PDR, fail */
 			printk(KERN_WARNING
-				"warning: Failed to find PDR for "
-				"plugrec 0x%04x.\n",
-				s3plug[i].itemcode);
-			continue; /* and move on to the next PDR */
+			       "warning: Failed to find PDR for "
+			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
+			continue;	/* and move on to the next PDR */
 #if 0
 			/* MSM: They swear that unless it's the MAC address,
 			 * the serial number, or the TX calibration records,
@@ -787,27 +764,26 @@ int plugimage( imgchunk_t *fchunk, unsig
 		}
 
 		/* Validate plug len against PDR len */
-		if ( j != -1 &&
-		     s3plug[i].len < le16_to_cpu(pda->rec[j]->len) ) {
+		if (j != -1 && s3plug[i].len < le16_to_cpu(pda->rec[j]->len)) {
 			printk(KERN_ERR
-				"error: Plug vs. PDR len mismatch for "
-				"plugrec 0x%04x, abort plugging.\n",
-				s3plug[i].itemcode);
+			       "error: Plug vs. PDR len mismatch for "
+			       "plugrec 0x%04x, abort plugging.\n",
+			       s3plug[i].itemcode);
 			result = 1;
 			continue;
 		}
 
 		/* Validate plug address against chunk data and identify chunk */
-		for ( c = 0; c < nfchunks; c++) {
+		for (c = 0; c < nfchunks; c++) {
 			cstart = fchunk[c].addr;
-			cend =	 fchunk[c].addr + fchunk[c].len;
-			if ( pstart >= cstart && pend <= cend ) break;
+			cend = fchunk[c].addr + fchunk[c].len;
+			if (pstart >= cstart && pend <= cend)
+				break;
 		}
-		if ( c >= nfchunks ) {
+		if (c >= nfchunks) {
 			printk(KERN_ERR
-				"error: Failed to find image chunk for "
-				"plugrec 0x%04x.\n",
-				s3plug[i].itemcode);
+			       "error: Failed to find image chunk for "
+			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
 			result = 1;
 			continue;
 		}
@@ -816,22 +792,21 @@ int plugimage( imgchunk_t *fchunk, unsig
 		chunkoff = pstart - cstart;
 		dest = fchunk[c].data + chunkoff;
 		pr_debug("Plugging item 0x%04x @ 0x%06x, len=%d, "
-			      "cnum=%d coff=0x%06x\n",
-			      s3plug[i].itemcode, pstart, s3plug[i].len,
-			      c, chunkoff);
+			 "cnum=%d coff=0x%06x\n",
+			 s3plug[i].itemcode, pstart, s3plug[i].len,
+			 c, chunkoff);
 
-		if ( j == -1 ) { /* plug the filename */
+		if (j == -1) {	/* plug the filename */
 			memset(dest, 0, s3plug[i].len);
 			strncpy(dest, PRISM2_USB_FWFILE, s3plug[i].len - 1);
-		} else { /* plug a PDR */
-			memcpy( dest, &(pda->rec[j]->data), s3plug[i].len);
+		} else {	/* plug a PDR */
+			memcpy(dest, &(pda->rec[j]->data), s3plug[i].len);
 		}
 	}
 	return result;
 
 }
 
-
 /*----------------------------------------------------------------
 * read_cardpda
 *
@@ -850,10 +825,10 @@ int plugimage( imgchunk_t *fchunk, unsig
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
+int read_cardpda(pda_t * pda, wlandevice_t * wlandev)
 {
-	int				result = 0;
-	p80211msg_p2req_readpda_t	msg;
+	int result = 0;
+	p80211msg_p2req_readpda_t msg;
 
 	/* set up the msg */
 	msg.msgcode = DIDmsg_p2req_readpda;
@@ -866,10 +841,10 @@ int read_cardpda(pda_t *pda, wlandevice_
 	msg.resultcode.len = sizeof(u32);
 	msg.resultcode.status = P80211ENUM_msgitem_status_no_value;
 
-	if ( prism2mgmt_readpda(wlandev, &msg) != 0 ) {
+	if (prism2mgmt_readpda(wlandev, &msg) != 0) {
 		/* prism2mgmt_readpda prints an errno if appropriate */
 		result = -1;
-	} else if ( msg.resultcode.data == P80211ENUM_resultcode_success ) {
+	} else if (msg.resultcode.data == P80211ENUM_resultcode_success) {
 		memcpy(pda->buf, msg.pda.data, HFA384x_PDA_LEN_MAX);
 		result = mkpdrlist(pda);
 	} else {
@@ -880,7 +855,6 @@ int read_cardpda(pda_t *pda, wlandevice_
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * copy_line
 *
@@ -909,7 +883,6 @@ int copyline(char *from, char *to, char 
 	return (c < SREC_LINE_MAX - 1) ? c + 1 : c;
 }
 
-
 /*----------------------------------------------------------------
 * read_srecfile
 *
@@ -964,131 +937,159 @@ int copyline(char *from, char *to, char 
 ----------------------------------------------------------------*/
 int read_srecfile(char *rfptr, int rfsize)
 {
-	int		result = 0;
-	char		buf[SREC_LINE_MAX];
-	char		tmpbuf[30];
-	s3datarec_t	tmprec;
-	int		i, c;
-	int		line = 0;
-	u16		*tmpinfo;
-	char		*endptr = rfptr + rfsize;
-
+	int result = 0;
+	char buf[SREC_LINE_MAX];
+	char tmpbuf[30];
+	s3datarec_t tmprec;
+	int i, c;
+	int line = 0;
+	u16 *tmpinfo;
+	char *endptr = rfptr + rfsize;
 
 	pr_debug("Reading S-record file ...\n");
 
-	while ( (c = copyline(rfptr, buf, endptr)) >= 12 ) {
+	while ((c = copyline(rfptr, buf, endptr)) >= 12) {
 		rfptr = rfptr + c;
 		line++;
-		if ( buf[0] != 'S' ) {
+		if (buf[0] != 'S') {
 			printk(KERN_ERR "%d warning: No initial \'S\'\n", line);
 			return 1;
 		}
-		if ( buf[1] == '7' ) {	/* S7 record, start address */
+		if (buf[1] == '7') {	/* S7 record, start address */
 			buf[12] = '\0';
-			startaddr = simple_strtoul(buf+4, NULL, 16);
+			startaddr = simple_strtoul(buf + 4, NULL, 16);
 			pr_debug("  S7 start addr, line=%d "
-				      " addr=0x%08x\n",
-				      line,
-				      startaddr);
+				 " addr=0x%08x\n", line, startaddr);
 			continue;
-		} else if ( buf[1] == '3') {
+		} else if (buf[1] == '3') {
 			/* Ok, it's an S3, parse and put it in the right array */
 			/* Record Length field (we only want datalen) */
-			memcpy(tmpbuf, buf+S3LEN_TXTOFFSET, S3LEN_TXTLEN);
+			memcpy(tmpbuf, buf + S3LEN_TXTOFFSET, S3LEN_TXTLEN);
 			tmpbuf[S3LEN_TXTLEN] = '\0';
-			tmprec.len = simple_strtoul( tmpbuf, NULL, 16) - 4 - 1; /* 4=addr, 1=cksum */
+			tmprec.len = simple_strtoul(tmpbuf, NULL, 16) - 4 - 1;	/* 4=addr, 1=cksum */
 			/* Address field */
-			memcpy(tmpbuf, buf+S3ADDR_TXTOFFSET, S3ADDR_TXTLEN);
+			memcpy(tmpbuf, buf + S3ADDR_TXTOFFSET, S3ADDR_TXTLEN);
 			tmpbuf[S3ADDR_TXTLEN] = '\0';
-			tmprec.addr = simple_strtoul( tmpbuf, NULL, 16);
+			tmprec.addr = simple_strtoul(tmpbuf, NULL, 16);
 			/* Checksum field */
-			tmprec.checksum = simple_strtoul( buf+strlen(buf)-2, NULL, 16);
+			tmprec.checksum =
+			    simple_strtoul(buf + strlen(buf) - 2, NULL, 16);
 
-			switch(  tmprec.addr )
-			{
+			switch (tmprec.addr) {
 			case S3ADDR_PLUG:
-				memcpy(tmpbuf, buf+S3PLUG_ITEMCODE_TXTOFFSET, S3PLUG_ITEMCODE_TXTLEN);
+				memcpy(tmpbuf, buf + S3PLUG_ITEMCODE_TXTOFFSET,
+				       S3PLUG_ITEMCODE_TXTLEN);
 				tmpbuf[S3PLUG_ITEMCODE_TXTLEN] = '\0';
-				s3plug[ns3plug].itemcode = simple_strtoul(tmpbuf,NULL,16);
-				s3plug[ns3plug].itemcode = bswap_32(s3plug[ns3plug].itemcode);
+				s3plug[ns3plug].itemcode =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3plug[ns3plug].itemcode =
+				    bswap_32(s3plug[ns3plug].itemcode);
 
-				memcpy(tmpbuf, buf+S3PLUG_ADDR_TXTOFFSET, S3PLUG_ADDR_TXTLEN);
+				memcpy(tmpbuf, buf + S3PLUG_ADDR_TXTOFFSET,
+				       S3PLUG_ADDR_TXTLEN);
 				tmpbuf[S3PLUG_ADDR_TXTLEN] = '\0';
-				s3plug[ns3plug].addr = simple_strtoul(tmpbuf,NULL,16);
-				s3plug[ns3plug].addr = bswap_32(s3plug[ns3plug].addr);
+				s3plug[ns3plug].addr =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3plug[ns3plug].addr =
+				    bswap_32(s3plug[ns3plug].addr);
 
-				memcpy(tmpbuf, buf+S3PLUG_LEN_TXTOFFSET, S3PLUG_LEN_TXTLEN);
+				memcpy(tmpbuf, buf + S3PLUG_LEN_TXTOFFSET,
+				       S3PLUG_LEN_TXTLEN);
 				tmpbuf[S3PLUG_LEN_TXTLEN] = '\0';
-				s3plug[ns3plug].len = simple_strtoul(tmpbuf,NULL,16);
-				s3plug[ns3plug].len = bswap_32(s3plug[ns3plug].len);
+				s3plug[ns3plug].len =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3plug[ns3plug].len =
+				    bswap_32(s3plug[ns3plug].len);
 
 				pr_debug("  S3 plugrec, line=%d "
-					      "itemcode=0x%04x addr=0x%08x len=%d\n",
-					      line,
-					      s3plug[ns3plug].itemcode,
-					      s3plug[ns3plug].addr,
-					      s3plug[ns3plug].len);
+					 "itemcode=0x%04x addr=0x%08x len=%d\n",
+					 line,
+					 s3plug[ns3plug].itemcode,
+					 s3plug[ns3plug].addr,
+					 s3plug[ns3plug].len);
 
 				ns3plug++;
-				if ( ns3plug == S3PLUG_MAX ) {
-					printk(KERN_ERR "S3 plugrec limit reached - aborting\n");
+				if (ns3plug == S3PLUG_MAX) {
+					printk(KERN_ERR
+					       "S3 plugrec limit reached - aborting\n");
 					return 1;
 				}
 				break;
 			case S3ADDR_CRC:
-				memcpy(tmpbuf, buf+S3CRC_ADDR_TXTOFFSET, S3CRC_ADDR_TXTLEN);
+				memcpy(tmpbuf, buf + S3CRC_ADDR_TXTOFFSET,
+				       S3CRC_ADDR_TXTLEN);
 				tmpbuf[S3CRC_ADDR_TXTLEN] = '\0';
-				s3crc[ns3crc].addr = simple_strtoul(tmpbuf,NULL,16);
-				s3crc[ns3crc].addr = bswap_32(s3crc[ns3crc].addr);
+				s3crc[ns3crc].addr =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3crc[ns3crc].addr =
+				    bswap_32(s3crc[ns3crc].addr);
 
-				memcpy(tmpbuf, buf+S3CRC_LEN_TXTOFFSET, S3CRC_LEN_TXTLEN);
+				memcpy(tmpbuf, buf + S3CRC_LEN_TXTOFFSET,
+				       S3CRC_LEN_TXTLEN);
 				tmpbuf[S3CRC_LEN_TXTLEN] = '\0';
-				s3crc[ns3crc].len = simple_strtoul(tmpbuf,NULL,16);
+				s3crc[ns3crc].len =
+				    simple_strtoul(tmpbuf, NULL, 16);
 				s3crc[ns3crc].len = bswap_32(s3crc[ns3crc].len);
 
-				memcpy(tmpbuf, buf+S3CRC_DOWRITE_TXTOFFSET, S3CRC_DOWRITE_TXTLEN);
+				memcpy(tmpbuf, buf + S3CRC_DOWRITE_TXTOFFSET,
+				       S3CRC_DOWRITE_TXTLEN);
 				tmpbuf[S3CRC_DOWRITE_TXTLEN] = '\0';
-				s3crc[ns3crc].dowrite = simple_strtoul(tmpbuf,NULL,16);
-				s3crc[ns3crc].dowrite = bswap_32(s3crc[ns3crc].dowrite);
+				s3crc[ns3crc].dowrite =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3crc[ns3crc].dowrite =
+				    bswap_32(s3crc[ns3crc].dowrite);
 
 				pr_debug("  S3 crcrec, line=%d "
-					      "addr=0x%08x len=%d write=0x%08x\n",
-					      line,
-					      s3crc[ns3crc].addr,
-					      s3crc[ns3crc].len,
-					      s3crc[ns3crc].dowrite);
+					 "addr=0x%08x len=%d write=0x%08x\n",
+					 line,
+					 s3crc[ns3crc].addr,
+					 s3crc[ns3crc].len,
+					 s3crc[ns3crc].dowrite);
 				ns3crc++;
-				if ( ns3crc == S3CRC_MAX ) {
-					printk(KERN_ERR "S3 crcrec limit reached - aborting\n");
+				if (ns3crc == S3CRC_MAX) {
+					printk(KERN_ERR
+					       "S3 crcrec limit reached - aborting\n");
 					return 1;
 				}
 				break;
 			case S3ADDR_INFO:
-				memcpy(tmpbuf, buf+S3INFO_LEN_TXTOFFSET, S3INFO_LEN_TXTLEN);
+				memcpy(tmpbuf, buf + S3INFO_LEN_TXTOFFSET,
+				       S3INFO_LEN_TXTLEN);
 				tmpbuf[S3INFO_LEN_TXTLEN] = '\0';
-				s3info[ns3info].len = simple_strtoul(tmpbuf,NULL,16);
-				s3info[ns3info].len = bswap_16(s3info[ns3info].len);
+				s3info[ns3info].len =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3info[ns3info].len =
+				    bswap_16(s3info[ns3info].len);
 
-				memcpy(tmpbuf, buf+S3INFO_TYPE_TXTOFFSET, S3INFO_TYPE_TXTLEN);
+				memcpy(tmpbuf, buf + S3INFO_TYPE_TXTOFFSET,
+				       S3INFO_TYPE_TXTLEN);
 				tmpbuf[S3INFO_TYPE_TXTLEN] = '\0';
-				s3info[ns3info].type = simple_strtoul(tmpbuf,NULL,16);
-				s3info[ns3info].type = bswap_16(s3info[ns3info].type);
+				s3info[ns3info].type =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3info[ns3info].type =
+				    bswap_16(s3info[ns3info].type);
 
 				pr_debug("  S3 inforec, line=%d "
-					      "len=0x%04x type=0x%04x\n",
-					      line,
-					      s3info[ns3info].len,
-					      s3info[ns3info].type);
-				if ( ((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info) ) {
-					printk(KERN_ERR " S3 inforec length too long - aborting\n");
+					 "len=0x%04x type=0x%04x\n",
+					 line,
+					 s3info[ns3info].len,
+					 s3info[ns3info].type);
+				if (((s3info[ns3info].len - 1) * sizeof(u16)) >
+				    sizeof(s3info[ns3info].info)) {
+					printk(KERN_ERR
+					       " S3 inforec length too long - aborting\n");
 					return 1;
 				}
 
-				tmpinfo = (u16*)&(s3info[ns3info].info.version);
+				tmpinfo =
+				    (u16 *) & (s3info[ns3info].info.version);
 				for (i = 0; i < s3info[ns3info].len - 1; i++) {
-					memcpy( tmpbuf, buf+S3INFO_DATA_TXTOFFSET+(i*4), 4);
+					memcpy(tmpbuf,
+					       buf + S3INFO_DATA_TXTOFFSET +
+					       (i * 4), 4);
 					tmpbuf[4] = '\0';
-					tmpinfo[i] = simple_strtoul(tmpbuf,NULL,16);
+					tmpinfo[i] =
+					    simple_strtoul(tmpbuf, NULL, 16);
 					tmpinfo[i] = bswap_16(tmpinfo[i]);
 				}
 				pr_debug("            info=");
@@ -1098,8 +1099,9 @@ int read_srecfile(char *rfptr, int rfsiz
 				pr_debug("\n");
 
 				ns3info++;
-				if ( ns3info == S3INFO_MAX ) {
-					printk(KERN_ERR "S3 inforec limit reached - aborting\n");
+				if (ns3info == S3INFO_MAX) {
+					printk(KERN_ERR
+					       "S3 inforec limit reached - aborting\n");
 					return 1;
 				}
 				break;
@@ -1107,27 +1109,33 @@ int read_srecfile(char *rfptr, int rfsiz
 				s3data[ns3data].addr = tmprec.addr;
 				s3data[ns3data].len = tmprec.len;
 				s3data[ns3data].checksum = tmprec.checksum;
-				s3data[ns3data].data = kmalloc(tmprec.len, GFP_KERNEL);
-				for ( i = 0; i < tmprec.len; i++) {
-					memcpy(tmpbuf, buf+S3DATA_TXTOFFSET+(i*2), 2);
+				s3data[ns3data].data =
+				    kmalloc(tmprec.len, GFP_KERNEL);
+				for (i = 0; i < tmprec.len; i++) {
+					memcpy(tmpbuf,
+					       buf + S3DATA_TXTOFFSET + (i * 2),
+					       2);
 					tmpbuf[2] = '\0';
-					s3data[ns3data].data[i] = simple_strtoul(tmpbuf, NULL, 16);
+					s3data[ns3data].data[i] =
+					    simple_strtoul(tmpbuf, NULL, 16);
 				}
 				ns3data++;
-				if ( ns3data == S3DATA_MAX ) {
-					printk(KERN_ERR "S3 datarec limit reached - aborting\n");
+				if (ns3data == S3DATA_MAX) {
+					printk(KERN_ERR
+					       "S3 datarec limit reached - aborting\n");
 					return 1;
 				}
 				break;
 			}
 		} else {
-			printk(KERN_WARNING "%d warning: Unknown S-record detected.\n", line);
+			printk(KERN_WARNING
+			       "%d warning: Unknown S-record detected.\n",
+			       line);
 		}
 	}
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * s3datarec_compare
 *
@@ -1143,14 +1151,15 @@ int read_srecfile(char *rfptr, int rfsiz
 ----------------------------------------------------------------*/
 int s3datarec_compare(const void *p1, const void *p2)
 {
-	const s3datarec_t	*s1 = p1;
-	const s3datarec_t	*s2 = p2;
-	if ( s1->addr == s2->addr ) return 0;
-	if ( s1->addr < s2->addr ) return -1;
+	const s3datarec_t *s1 = p1;
+	const s3datarec_t *s2 = p2;
+	if (s1->addr == s2->addr)
+		return 0;
+	if (s1->addr < s2->addr)
+		return -1;
 	return 1;
 }
 
-
 /*----------------------------------------------------------------
 * writeimage
 *
@@ -1166,113 +1175,114 @@ int s3datarec_compare(const void *p1, co
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk, unsigned int nfchunks)
+int writeimage(wlandevice_t * wlandev, imgchunk_t * fchunk,
+	       unsigned int nfchunks)
 {
-	int					result = 0;
-	p80211msg_p2req_ramdl_state_t		rstatemsg;
-	p80211msg_p2req_ramdl_write_t		rwritemsg;
-	p80211msg_t				*msgp;
-	u32					resultcode;
-	int					i;
-	int					j;
-	unsigned int				nwrites;
-	u32					curroff;
-	u32					currlen;
-	u32					currdaddr;
+	int result = 0;
+	p80211msg_p2req_ramdl_state_t rstatemsg;
+	p80211msg_p2req_ramdl_write_t rwritemsg;
+	p80211msg_t *msgp;
+	u32 resultcode;
+	int i;
+	int j;
+	unsigned int nwrites;
+	u32 curroff;
+	u32 currlen;
+	u32 currdaddr;
 
 	/* Initialize the messages */
 	memset(&rstatemsg, 0, sizeof(rstatemsg));
 	strcpy(rstatemsg.devname, wlandev->name);
-	rstatemsg.msgcode =		DIDmsg_p2req_ramdl_state;
-	rstatemsg.msglen =		sizeof(rstatemsg);
-	rstatemsg.enable.did =		DIDmsg_p2req_ramdl_state_enable;
-	rstatemsg.exeaddr.did =		DIDmsg_p2req_ramdl_state_exeaddr;
-	rstatemsg.resultcode.did =	DIDmsg_p2req_ramdl_state_resultcode;
-	rstatemsg.enable.status =	P80211ENUM_msgitem_status_data_ok;
-	rstatemsg.exeaddr.status =	P80211ENUM_msgitem_status_data_ok;
-	rstatemsg.resultcode.status =	P80211ENUM_msgitem_status_no_value;
-	rstatemsg.enable.len =		sizeof(u32);
-	rstatemsg.exeaddr.len =		sizeof(u32);
-	rstatemsg.resultcode.len =	sizeof(u32);
+	rstatemsg.msgcode = DIDmsg_p2req_ramdl_state;
+	rstatemsg.msglen = sizeof(rstatemsg);
+	rstatemsg.enable.did = DIDmsg_p2req_ramdl_state_enable;
+	rstatemsg.exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;
+	rstatemsg.resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;
+	rstatemsg.enable.status = P80211ENUM_msgitem_status_data_ok;
+	rstatemsg.exeaddr.status = P80211ENUM_msgitem_status_data_ok;
+	rstatemsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
+	rstatemsg.enable.len = sizeof(u32);
+	rstatemsg.exeaddr.len = sizeof(u32);
+	rstatemsg.resultcode.len = sizeof(u32);
 
 	memset(&rwritemsg, 0, sizeof(rwritemsg));
 	strcpy(rwritemsg.devname, wlandev->name);
-	rwritemsg.msgcode =		DIDmsg_p2req_ramdl_write;
-	rwritemsg.msglen =		sizeof(rwritemsg);
-	rwritemsg.addr.did =		DIDmsg_p2req_ramdl_write_addr;
-	rwritemsg.len.did =		DIDmsg_p2req_ramdl_write_len;
-	rwritemsg.data.did =		DIDmsg_p2req_ramdl_write_data;
-	rwritemsg.resultcode.did =	DIDmsg_p2req_ramdl_write_resultcode;
-	rwritemsg.addr.status =		P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.len.status =		P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.data.status =		P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.resultcode.status =	P80211ENUM_msgitem_status_no_value;
-	rwritemsg.addr.len =		sizeof(u32);
-	rwritemsg.len.len =		sizeof(u32);
-	rwritemsg.data.len =		WRITESIZE_MAX;
-	rwritemsg.resultcode.len =	sizeof(u32);
+	rwritemsg.msgcode = DIDmsg_p2req_ramdl_write;
+	rwritemsg.msglen = sizeof(rwritemsg);
+	rwritemsg.addr.did = DIDmsg_p2req_ramdl_write_addr;
+	rwritemsg.len.did = DIDmsg_p2req_ramdl_write_len;
+	rwritemsg.data.did = DIDmsg_p2req_ramdl_write_data;
+	rwritemsg.resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;
+	rwritemsg.addr.status = P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.len.status = P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.data.status = P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
+	rwritemsg.addr.len = sizeof(u32);
+	rwritemsg.len.len = sizeof(u32);
+	rwritemsg.data.len = WRITESIZE_MAX;
+	rwritemsg.resultcode.len = sizeof(u32);
 
 	/* Send xxx_state(enable) */
 	pr_debug("Sending dl_state(enable) message.\n");
 	rstatemsg.enable.data = P80211ENUM_truth_true;
 	rstatemsg.exeaddr.data = startaddr;
 
-	msgp = (p80211msg_t*)&rstatemsg;
+	msgp = (p80211msg_t *) & rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR
-			"writeimage state enable failed w/ result=%d, "
-			"aborting download\n", result);
+		       "writeimage state enable failed w/ result=%d, "
+		       "aborting download\n", result);
 		return result;
 	}
 	resultcode = rstatemsg.resultcode.data;
-	if ( resultcode != P80211ENUM_resultcode_success ) {
+	if (resultcode != P80211ENUM_resultcode_success) {
 		printk(KERN_ERR
-			"writeimage()->xxxdl_state msg indicates failure, "
-			"w/ resultcode=%d, aborting download.\n",
-			resultcode);
+		       "writeimage()->xxxdl_state msg indicates failure, "
+		       "w/ resultcode=%d, aborting download.\n", resultcode);
 		return 1;
 	}
 
 	/* Now, loop through the data chunks and send WRITESIZE_MAX data */
-	for ( i = 0; i < nfchunks; i++) {
+	for (i = 0; i < nfchunks; i++) {
 		nwrites = fchunk[i].len / WRITESIZE_MAX;
 		nwrites += (fchunk[i].len % WRITESIZE_MAX) ? 1 : 0;
 		curroff = 0;
-		for ( j = 0; j < nwrites; j++) {
+		for (j = 0; j < nwrites; j++) {
 			currlen =
-			  (fchunk[i].len - (WRITESIZE_MAX * j)) > WRITESIZE_MAX ?
-			  WRITESIZE_MAX :
-			  (fchunk[i].len - (WRITESIZE_MAX * j));
+			    (fchunk[i].len - (WRITESIZE_MAX * j)) >
+			    WRITESIZE_MAX ? WRITESIZE_MAX : (fchunk[i].len -
+							     (WRITESIZE_MAX *
+							      j));
 			curroff = j * WRITESIZE_MAX;
 			currdaddr = fchunk[i].addr + curroff;
 			/* Setup the message */
 			rwritemsg.addr.data = currdaddr;
 			rwritemsg.len.data = currlen;
 			memcpy(rwritemsg.data.data,
-				fchunk[i].data + curroff,
-				currlen);
+			       fchunk[i].data + curroff, currlen);
 
 			/* Send flashdl_write(pda) */
-			pr_debug("Sending xxxdl_write message addr=%06x len=%d.\n",
-				      currdaddr, currlen);
+			pr_debug
+			    ("Sending xxxdl_write message addr=%06x len=%d.\n",
+			     currdaddr, currlen);
 
-			msgp = (p80211msg_t*)&rwritemsg;
+			msgp = (p80211msg_t *) & rwritemsg;
 			result = prism2mgmt_ramdl_write(wlandev, msgp);
 
 			/* Check the results */
-			if ( result ) {
+			if (result) {
 				printk(KERN_ERR
-					"writeimage chunk write failed w/ result=%d, "
-					"aborting download\n", result);
+				       "writeimage chunk write failed w/ result=%d, "
+				       "aborting download\n", result);
 				return result;
 			}
 			resultcode = rstatemsg.resultcode.data;
-			if ( resultcode != P80211ENUM_resultcode_success ) {
+			if (resultcode != P80211ENUM_resultcode_success) {
 				printk(KERN_ERR
-					"writeimage()->xxxdl_write msg indicates failure, "
-					"w/ resultcode=%d, aborting download.\n",
-					resultcode);
+				       "writeimage()->xxxdl_write msg indicates failure, "
+				       "w/ resultcode=%d, aborting download.\n",
+				       resultcode);
 				return 1;
 			}
 
@@ -1284,69 +1294,54 @@ int writeimage(wlandevice_t *wlandev, im
 	rstatemsg.enable.data = P80211ENUM_truth_false;
 	rstatemsg.exeaddr.data = 0;
 
-	msgp = (p80211msg_t*)&rstatemsg;
+	msgp = (p80211msg_t *) & rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR
-			"writeimage state disable failed w/ result=%d, "
-			"aborting download\n", result);
+		       "writeimage state disable failed w/ result=%d, "
+		       "aborting download\n", result);
 		return result;
 	}
 	resultcode = rstatemsg.resultcode.data;
-	if ( resultcode != P80211ENUM_resultcode_success ) {
+	if (resultcode != P80211ENUM_resultcode_success) {
 		printk(KERN_ERR
-			"writeimage()->xxxdl_state msg indicates failure, "
-			"w/ resultcode=%d, aborting download.\n",
-			resultcode);
+		       "writeimage()->xxxdl_state msg indicates failure, "
+		       "w/ resultcode=%d, aborting download.\n", resultcode);
 		return 1;
 	}
 	return result;
 }
 
-
-
 int validate_identity(void)
 {
 	int i;
 	int result = 1;
 
 	pr_debug("NIC ID: %#x v%d.%d.%d\n",
-	       nicid.id,
-	       nicid.major,
-	       nicid.minor,
-	       nicid.variant);
+		 nicid.id, nicid.major, nicid.minor, nicid.variant);
 	pr_debug("MFI ID: %#x v%d %d->%d\n",
-	       rfid.id,
-	       rfid.variant,
-	       rfid.bottom,
-	       rfid.top);
+		 rfid.id, rfid.variant, rfid.bottom, rfid.top);
 	pr_debug("CFI ID: %#x v%d %d->%d\n",
-	       macid.id,
-	       macid.variant,
-	       macid.bottom,
-	       macid.top);
+		 macid.id, macid.variant, macid.bottom, macid.top);
 	pr_debug("PRI ID: %#x v%d %d->%d\n",
-	       priid.id,
-	       priid.variant,
-	       priid.bottom,
-	       priid.top);
+		 priid.id, priid.variant, priid.bottom, priid.top);
 
-	for (i = 0 ; i < ns3info ; i ++) {
+	for (i = 0; i < ns3info; i++) {
 		switch (s3info[i].type) {
 		case 1:
 			pr_debug("Version:  ID %#x %d.%d.%d\n",
-			       s3info[i].info.version.id,
-			       s3info[i].info.version.major,
-				       s3info[i].info.version.minor,
-			       s3info[i].info.version.variant);
+				 s3info[i].info.version.id,
+				 s3info[i].info.version.major,
+				 s3info[i].info.version.minor,
+				 s3info[i].info.version.variant);
 			break;
 		case 2:
 			pr_debug("Compat: Role %#x Id %#x v%d %d->%d\n",
-			       s3info[i].info.compat.role,
-			       s3info[i].info.compat.id,
-			       s3info[i].info.compat.variant,
-			       s3info[i].info.compat.bottom,
-			       s3info[i].info.compat.top);
+				 s3info[i].info.compat.role,
+				 s3info[i].info.compat.id,
+				 s3info[i].info.compat.variant,
+				 s3info[i].info.compat.bottom,
+				 s3info[i].info.compat.top);
 
 			/* MAC compat range */
 			if ((s3info[i].info.compat.role == 1) &&
@@ -1360,8 +1355,9 @@ int validate_identity(void)
 			/* PRI compat range */
 			if ((s3info[i].info.compat.role == 1) &&
 			    (s3info[i].info.compat.id == 3)) {
-				if ((s3info[i].info.compat.bottom > priid.top) ||
-				    (s3info[i].info.compat.top < priid.bottom)){
+				if ((s3info[i].info.compat.bottom > priid.top)
+				    || (s3info[i].info.compat.top <
+					priid.bottom)) {
 					result = 3;
 				}
 			}
@@ -1373,15 +1369,15 @@ int validate_identity(void)
 
 			break;
 		case 3:
-				pr_debug("Seq: %#x\n", s3info[i].info.buildseq);
+			pr_debug("Seq: %#x\n", s3info[i].info.buildseq);
 
-				break;
+			break;
 		case 4:
 			pr_debug("Platform:  ID %#x %d.%d.%d\n",
-			       s3info[i].info.version.id,
-			       s3info[i].info.version.major,
-			       s3info[i].info.version.minor,
-			       s3info[i].info.version.variant);
+				 s3info[i].info.version.id,
+				 s3info[i].info.version.major,
+				 s3info[i].info.version.minor,
+				 s3info[i].info.version.variant);
 
 			if (nicid.id != s3info[i].info.version.id)
 				continue;
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -117,7 +117,7 @@
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_scan(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -362,7 +362,7 @@ exit:
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_scan_results(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	p80211msg_dot11req_scan_results_t *req;
@@ -389,7 +389,7 @@ int prism2mgmt_scan_results(wlandevice_t
 
 	if (req->bssindex.data >= count) {
 		pr_debug("requested index (%d) out of range (%d)\n",
-		       req->bssindex.data, count);
+			 req->bssindex.data, count);
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 		goto exit;
@@ -511,7 +511,7 @@ exit:
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_start(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -544,7 +544,7 @@ int prism2mgmt_start(wlandevice_t *wland
 	/*** STATION ***/
 	/* Set the REQUIRED config items */
 	/* SSID */
-	pstr = (p80211pstrd_t *)&(msg->ssid.data);
+	pstr = (p80211pstrd_t *) & (msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
 					bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
@@ -688,7 +688,7 @@ done:
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_readpda(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_readpda_t *msg = msgp;
@@ -754,7 +754,7 @@ int prism2mgmt_readpda(wlandevice_t *wla
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_ramdl_state(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_ramdl_state_t *msg = msgp;
@@ -810,7 +810,7 @@ int prism2mgmt_ramdl_state(wlandevice_t 
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_ramdl_write(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_ramdl_write_t *msg = msgp;
@@ -872,7 +872,7 @@ int prism2mgmt_ramdl_write(wlandevice_t 
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_flashdl_state(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -943,7 +943,7 @@ int prism2mgmt_flashdl_state(wlandevice_
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_flashdl_write(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_flashdl_write_t *msg = msgp;
@@ -1004,7 +1004,7 @@ int prism2mgmt_flashdl_write(wlandevice_
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_autojoin(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	int result = 0;
@@ -1037,7 +1037,7 @@ int prism2mgmt_autojoin(wlandevice_t *wl
 
 	/* Set the ssid */
 	memset(bytebuf, 0, 256);
-	pstr = (p80211pstrd_t *)&(msg->ssid.data);
+	pstr = (p80211pstrd_t *) & (msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
 					bytebuf,
@@ -1075,7 +1075,7 @@ int prism2mgmt_autojoin(wlandevice_t *wl
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_wlansniff(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	p80211msg_lnxreq_wlansniff_t *msg = msgp;
@@ -1096,17 +1096,16 @@ int prism2mgmt_wlansniff(wlandevice_t *w
 		/* Disable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
 		if (result) {
-			pr_debug(
-			       "failed to disable monitor mode, result=%d\n",
-			       result);
+			pr_debug("failed to disable monitor mode, result=%d\n",
+				 result);
 			goto failed;
 		}
 		/* Disable port 0 */
 		result = hfa384x_drvr_disable(hw, 0);
 		if (result) {
-			pr_debug(
-			       "failed to disable port 0 after sniffing, result=%d\n",
-			       result);
+			pr_debug
+			    ("failed to disable port 0 after sniffing, result=%d\n",
+			     result);
 			goto failed;
 		}
 		/* Clear the driver state */
@@ -1117,9 +1116,9 @@ int prism2mgmt_wlansniff(wlandevice_t *w
 						  HFA384x_RID_CNFWEPFLAGS,
 						  hw->presniff_wepflags);
 		if (result) {
-			pr_debug(
-			       "failed to restore wepflags=0x%04x, result=%d\n",
-			       hw->presniff_wepflags, result);
+			pr_debug
+			    ("failed to restore wepflags=0x%04x, result=%d\n",
+			     hw->presniff_wepflags, result);
 			goto failed;
 		}
 
@@ -1130,18 +1129,18 @@ int prism2mgmt_wlansniff(wlandevice_t *w
 							  HFA384x_RID_CNFPORTTYPE,
 							  word);
 			if (result) {
-				pr_debug(
-				       "failed to restore porttype, result=%d\n",
-				       result);
+				pr_debug
+				    ("failed to restore porttype, result=%d\n",
+				     result);
 				goto failed;
 			}
 
 			/* Enable the port */
 			result = hfa384x_drvr_enable(hw, 0);
 			if (result) {
-				pr_debug(
-				       "failed to enable port to presniff setting, result=%d\n",
-				       result);
+				pr_debug
+				    ("failed to enable port to presniff setting, result=%d\n",
+				     result);
 				goto failed;
 			}
 		} else {
@@ -1161,40 +1160,42 @@ int prism2mgmt_wlansniff(wlandevice_t *w
 				/* Save macport 0 state */
 				result = hfa384x_drvr_getconfig16(hw,
 								  HFA384x_RID_CNFPORTTYPE,
-								  &(hw->
-								    presniff_port_type));
+								  &
+								  (hw->
+								   presniff_port_type));
 				if (result) {
-					pr_debug(
-					       "failed to read porttype, result=%d\n",
-					       result);
+					pr_debug
+					    ("failed to read porttype, result=%d\n",
+					     result);
 					goto failed;
 				}
 				/* Save the wepflags state */
 				result = hfa384x_drvr_getconfig16(hw,
 								  HFA384x_RID_CNFWEPFLAGS,
-								  &(hw->
-								    presniff_wepflags));
+								  &
+								  (hw->
+								   presniff_wepflags));
 				if (result) {
-					pr_debug(
-					       "failed to read wepflags, result=%d\n",
-					       result);
+					pr_debug
+					    ("failed to read wepflags, result=%d\n",
+					     result);
 					goto failed;
 				}
 				hfa384x_drvr_stop(hw);
 				result = hfa384x_drvr_start(hw);
 				if (result) {
-					pr_debug(
-					       "failed to restart the card for sniffing, result=%d\n",
-					       result);
+					pr_debug
+					    ("failed to restart the card for sniffing, result=%d\n",
+					     result);
 					goto failed;
 				}
 			} else {
 				/* Disable the port */
 				result = hfa384x_drvr_disable(hw, 0);
 				if (result) {
-					pr_debug(
-					       "failed to enable port for sniffing, result=%d\n",
-					       result);
+					pr_debug
+					    ("failed to enable port for sniffing, result=%d\n",
+					     result);
 					goto failed;
 				}
 			}
@@ -1210,9 +1211,8 @@ int prism2mgmt_wlansniff(wlandevice_t *w
 		hw->sniff_channel = word;
 
 		if (result) {
-			pr_debug(
-			       "failed to set channel %d, result=%d\n",
-			       word, result);
+			pr_debug("failed to set channel %d, result=%d\n",
+				 word, result);
 			goto failed;
 		}
 
@@ -1224,9 +1224,9 @@ int prism2mgmt_wlansniff(wlandevice_t *w
 							  HFA384x_RID_CNFPORTTYPE,
 							  word);
 			if (result) {
-				pr_debug(
-				       "failed to set porttype %d, result=%d\n",
-				       word, result);
+				pr_debug
+				    ("failed to set porttype %d, result=%d\n",
+				     word, result);
 				goto failed;
 			}
 			if ((msg->keepwepflags.status ==
@@ -1243,9 +1243,9 @@ int prism2mgmt_wlansniff(wlandevice_t *w
 			}
 
 			if (result) {
-				pr_debug(
-				       "failed to set wepflags=0x%04x, result=%d\n",
-				       word, result);
+				pr_debug
+				    ("failed to set wepflags=0x%04x, result=%d\n",
+				     word, result);
 				goto failed;
 			}
 		}
@@ -1269,17 +1269,16 @@ int prism2mgmt_wlansniff(wlandevice_t *w
 		/* Enable the port */
 		result = hfa384x_drvr_enable(hw, 0);
 		if (result) {
-			pr_debug(
-			       "failed to enable port for sniffing, result=%d\n",
-			       result);
+			pr_debug
+			    ("failed to enable port for sniffing, result=%d\n",
+			     result);
 			goto failed;
 		}
 		/* Enable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_ENABLE);
 		if (result) {
-			pr_debug(
-			       "failed to enable monitor mode, result=%d\n",
-			       result);
+			pr_debug("failed to enable monitor mode, result=%d\n",
+				 result);
 			goto failed;
 		}
 
--- a/drivers/staging/wlan-ng/prism2mgmt.h
+++ b/drivers/staging/wlan-ng/prism2mgmt.h
@@ -63,43 +63,43 @@
 extern int prism2_reset_holdtime;
 extern int prism2_reset_settletime;
 
-u32 prism2sta_ifstate(wlandevice_t *wlandev, u32 ifstate);
+u32 prism2sta_ifstate(wlandevice_t * wlandev, u32 ifstate);
 
-void prism2sta_ev_info(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
-void prism2sta_ev_txexc(wlandevice_t *wlandev, u16 status);
-void prism2sta_ev_tx(wlandevice_t *wlandev, u16 status);
-void prism2sta_ev_rx(wlandevice_t *wlandev, struct sk_buff *skb);
-void prism2sta_ev_alloc(wlandevice_t *wlandev);
-
-int prism2mgmt_mibset_mibget(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_start(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp);
-int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp);
+void prism2sta_ev_info(wlandevice_t * wlandev, hfa384x_InfFrame_t * inf);
+void prism2sta_ev_txexc(wlandevice_t * wlandev, u16 status);
+void prism2sta_ev_tx(wlandevice_t * wlandev, u16 status);
+void prism2sta_ev_rx(wlandevice_t * wlandev, struct sk_buff *skb);
+void prism2sta_ev_alloc(wlandevice_t * wlandev);
+
+int prism2mgmt_mibset_mibget(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_scan(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_scan_results(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_start(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_wlansniff(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_readpda(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_ramdl_state(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_ramdl_write(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_flashdl_state(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_flashdl_write(wlandevice_t * wlandev, void *msgp);
+int prism2mgmt_autojoin(wlandevice_t * wlandev, void *msgp);
 
 /*---------------------------------------------------------------
 * conversion functions going between wlan message data types and
 * Prism2 data types
 ---------------------------------------------------------------*/
 /* byte area conversion functions*/
-void prism2mgmt_pstr2bytearea(u8 *bytearea, p80211pstrd_t *pstr);
-void prism2mgmt_bytearea2pstr(u8 *bytearea, p80211pstrd_t *pstr, int len);
+void prism2mgmt_pstr2bytearea(u8 * bytearea, p80211pstrd_t * pstr);
+void prism2mgmt_bytearea2pstr(u8 * bytearea, p80211pstrd_t * pstr, int len);
 
 /* byte string conversion functions*/
-void prism2mgmt_pstr2bytestr(hfa384x_bytestr_t *bytestr, p80211pstrd_t *pstr);
-void prism2mgmt_bytestr2pstr(hfa384x_bytestr_t *bytestr, p80211pstrd_t *pstr);
+void prism2mgmt_pstr2bytestr(hfa384x_bytestr_t * bytestr, p80211pstrd_t * pstr);
+void prism2mgmt_bytestr2pstr(hfa384x_bytestr_t * bytestr, p80211pstrd_t * pstr);
 
 /* functions to convert Group Addresses */
-void prism2mgmt_get_grpaddr(u32 did, p80211pstrd_t *pstr, hfa384x_t *priv);
+void prism2mgmt_get_grpaddr(u32 did, p80211pstrd_t * pstr, hfa384x_t * priv);
 int prism2mgmt_set_grpaddr(u32 did,
-			   u8 *prism2buf, p80211pstrd_t *pstr,
-			   hfa384x_t *priv);
+			   u8 * prism2buf, p80211pstrd_t * pstr,
+			   hfa384x_t * priv);
 int prism2mgmt_get_grpaddr_index(u32 did);
 
 void prism2sta_processing_defer(struct work_struct *data);
--- a/drivers/staging/wlan-ng/prism2mib.c
+++ b/drivers/staging/wlan-ng/prism2mib.c
@@ -86,65 +86,65 @@ typedef struct mibrec {
 	u16 parm1;
 	u16 parm2;
 	u16 parm3;
-	int (*func) (struct mibrec *mib,
+	int (*func) (struct mibrec * mib,
 		     int isget,
-		     wlandevice_t *wlandev,
-		     hfa384x_t *hw,
-		     p80211msg_dot11req_mibset_t *msg, void *data);
+		     wlandevice_t * wlandev,
+		     hfa384x_t * hw,
+		     p80211msg_dot11req_mibset_t * msg, void *data);
 } mibrec_t;
 
-static int prism2mib_bytearea2pstr(mibrec_t *mib,
+static int prism2mib_bytearea2pstr(mibrec_t * mib,
 				   int isget,
-				   wlandevice_t *wlandev,
-				   hfa384x_t *hw,
-				   p80211msg_dot11req_mibset_t *msg,
+				   wlandevice_t * wlandev,
+				   hfa384x_t * hw,
+				   p80211msg_dot11req_mibset_t * msg,
 				   void *data);
 
-static int prism2mib_uint32(mibrec_t *mib,
+static int prism2mib_uint32(mibrec_t * mib,
 			    int isget,
-			    wlandevice_t *wlandev,
-			    hfa384x_t *hw,
-			    p80211msg_dot11req_mibset_t *msg, void *data);
+			    wlandevice_t * wlandev,
+			    hfa384x_t * hw,
+			    p80211msg_dot11req_mibset_t * msg, void *data);
 
-static int prism2mib_flag(mibrec_t *mib,
+static int prism2mib_flag(mibrec_t * mib,
 			  int isget,
-			  wlandevice_t *wlandev,
-			  hfa384x_t *hw,
-			  p80211msg_dot11req_mibset_t *msg, void *data);
+			  wlandevice_t * wlandev,
+			  hfa384x_t * hw,
+			  p80211msg_dot11req_mibset_t * msg, void *data);
 
-static int prism2mib_wepdefaultkey(mibrec_t *mib,
+static int prism2mib_wepdefaultkey(mibrec_t * mib,
 				   int isget,
-				   wlandevice_t *wlandev,
-				   hfa384x_t *hw,
-				   p80211msg_dot11req_mibset_t *msg,
+				   wlandevice_t * wlandev,
+				   hfa384x_t * hw,
+				   p80211msg_dot11req_mibset_t * msg,
 				   void *data);
 
-static int prism2mib_privacyinvoked(mibrec_t *mib,
+static int prism2mib_privacyinvoked(mibrec_t * mib,
 				    int isget,
-				    wlandevice_t *wlandev,
-				    hfa384x_t *hw,
-				    p80211msg_dot11req_mibset_t *msg,
+				    wlandevice_t * wlandev,
+				    hfa384x_t * hw,
+				    p80211msg_dot11req_mibset_t * msg,
 				    void *data);
 
-static int prism2mib_excludeunencrypted(mibrec_t *mib,
+static int prism2mib_excludeunencrypted(mibrec_t * mib,
 					int isget,
-					wlandevice_t *wlandev,
-					hfa384x_t *hw,
-					p80211msg_dot11req_mibset_t *msg,
+					wlandevice_t * wlandev,
+					hfa384x_t * hw,
+					p80211msg_dot11req_mibset_t * msg,
 					void *data);
 
-static int prism2mib_fragmentationthreshold(mibrec_t *mib,
+static int prism2mib_fragmentationthreshold(mibrec_t * mib,
 					    int isget,
-					    wlandevice_t *wlandev,
-					    hfa384x_t *hw,
-					    p80211msg_dot11req_mibset_t *msg,
+					    wlandevice_t * wlandev,
+					    hfa384x_t * hw,
+					    p80211msg_dot11req_mibset_t * msg,
 					    void *data);
 
-static int prism2mib_priv(mibrec_t *mib,
+static int prism2mib_priv(mibrec_t * mib,
 			  int isget,
-			  wlandevice_t *wlandev,
-			  hfa384x_t *hw,
-			  p80211msg_dot11req_mibset_t *msg, void *data);
+			  wlandevice_t * wlandev,
+			  hfa384x_t * hw,
+			  p80211msg_dot11req_mibset_t * msg, void *data);
 
 static mibrec_t mibtab[] = {
 
@@ -258,7 +258,7 @@ static mibrec_t mibtab[] = {
 *	interrupt
 ----------------------------------------------------------------*/
 
-int prism2mgmt_mibset_mibget(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_mibset_mibget(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	int result, isget;
@@ -330,8 +330,7 @@ int prism2mgmt_mibset_mibget(wlandevice_
 
 	if (msg->resultcode.data == P80211ENUM_resultcode_success) {
 		if (result != 0) {
-			pr_debug("get/set failure, result=%d\n",
-			       result);
+			pr_debug("get/set failure, result=%d\n", result);
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 		} else {
@@ -373,11 +372,11 @@ done:
 *
 ----------------------------------------------------------------*/
 
-static int prism2mib_bytearea2pstr(mibrec_t *mib,
+static int prism2mib_bytearea2pstr(mibrec_t * mib,
 				   int isget,
-				   wlandevice_t *wlandev,
-				   hfa384x_t *hw,
-				   p80211msg_dot11req_mibset_t *msg,
+				   wlandevice_t * wlandev,
+				   hfa384x_t * hw,
+				   p80211msg_dot11req_mibset_t * msg,
 				   void *data)
 {
 	int result;
@@ -423,11 +422,11 @@ static int prism2mib_bytearea2pstr(mibre
 *
 ----------------------------------------------------------------*/
 
-static int prism2mib_uint32(mibrec_t *mib,
+static int prism2mib_uint32(mibrec_t * mib,
 			    int isget,
-			    wlandevice_t *wlandev,
-			    hfa384x_t *hw,
-			    p80211msg_dot11req_mibset_t *msg, void *data)
+			    wlandevice_t * wlandev,
+			    hfa384x_t * hw,
+			    p80211msg_dot11req_mibset_t * msg, void *data)
 {
 	int result;
 	u32 *uint32 = (u32 *) data;
@@ -470,11 +469,11 @@ static int prism2mib_uint32(mibrec_t *mi
 *
 ----------------------------------------------------------------*/
 
-static int prism2mib_flag(mibrec_t *mib,
+static int prism2mib_flag(mibrec_t * mib,
 			  int isget,
-			  wlandevice_t *wlandev,
-			  hfa384x_t *hw,
-			  p80211msg_dot11req_mibset_t *msg, void *data)
+			  wlandevice_t * wlandev,
+			  hfa384x_t * hw,
+			  p80211msg_dot11req_mibset_t * msg, void *data)
 {
 	int result;
 	u32 *uint32 = (u32 *) data;
@@ -527,11 +526,11 @@ static int prism2mib_flag(mibrec_t *mib,
 *
 ----------------------------------------------------------------*/
 
-static int prism2mib_wepdefaultkey(mibrec_t *mib,
+static int prism2mib_wepdefaultkey(mibrec_t * mib,
 				   int isget,
-				   wlandevice_t *wlandev,
-				   hfa384x_t *hw,
-				   p80211msg_dot11req_mibset_t *msg,
+				   wlandevice_t * wlandev,
+				   hfa384x_t * hw,
+				   p80211msg_dot11req_mibset_t * msg,
 				   void *data)
 {
 	int result;
@@ -577,11 +576,11 @@ static int prism2mib_wepdefaultkey(mibre
 *
 ----------------------------------------------------------------*/
 
-static int prism2mib_privacyinvoked(mibrec_t *mib,
+static int prism2mib_privacyinvoked(mibrec_t * mib,
 				    int isget,
-				    wlandevice_t *wlandev,
-				    hfa384x_t *hw,
-				    p80211msg_dot11req_mibset_t *msg,
+				    wlandevice_t * wlandev,
+				    hfa384x_t * hw,
+				    p80211msg_dot11req_mibset_t * msg,
 				    void *data)
 {
 	int result;
@@ -623,11 +622,11 @@ static int prism2mib_privacyinvoked(mibr
 *
 ----------------------------------------------------------------*/
 
-static int prism2mib_excludeunencrypted(mibrec_t *mib,
+static int prism2mib_excludeunencrypted(mibrec_t * mib,
 					int isget,
-					wlandevice_t *wlandev,
-					hfa384x_t *hw,
-					p80211msg_dot11req_mibset_t *msg,
+					wlandevice_t * wlandev,
+					hfa384x_t * hw,
+					p80211msg_dot11req_mibset_t * msg,
 					void *data)
 {
 	int result;
@@ -662,11 +661,11 @@ static int prism2mib_excludeunencrypted(
 *
 ----------------------------------------------------------------*/
 
-static int prism2mib_fragmentationthreshold(mibrec_t *mib,
+static int prism2mib_fragmentationthreshold(mibrec_t * mib,
 					    int isget,
-					    wlandevice_t *wlandev,
-					    hfa384x_t *hw,
-					    p80211msg_dot11req_mibset_t *msg,
+					    wlandevice_t * wlandev,
+					    hfa384x_t * hw,
+					    p80211msg_dot11req_mibset_t * msg,
 					    void *data)
 {
 	int result;
@@ -711,11 +710,11 @@ static int prism2mib_fragmentationthresh
 *
 ----------------------------------------------------------------*/
 
-static int prism2mib_priv(mibrec_t *mib,
+static int prism2mib_priv(mibrec_t * mib,
 			  int isget,
-			  wlandevice_t *wlandev,
-			  hfa384x_t *hw,
-			  p80211msg_dot11req_mibset_t *msg, void *data)
+			  wlandevice_t * wlandev,
+			  hfa384x_t * hw,
+			  p80211msg_dot11req_mibset_t * msg, void *data)
 {
 	p80211pstrd_t *pstr = (p80211pstrd_t *) data;
 
@@ -727,7 +726,7 @@ static int prism2mib_priv(mibrec_t *mib,
 			if (isget) {
 				hfa384x_drvr_getconfig(hw,
 						       HFA384x_RID_CNFWPADATA,
-						       (u8 *)&wpa,
+						       (u8 *) & wpa,
 						       sizeof(wpa));
 				pstr->len = le16_to_cpu(wpa.datalen);
 				memcpy(pstr->data, wpa.data, pstr->len);
@@ -738,7 +737,7 @@ static int prism2mib_priv(mibrec_t *mib,
 				result =
 				    hfa384x_drvr_setconfig(hw,
 							   HFA384x_RID_CNFWPADATA,
-							   (u8 *)&wpa,
+							   (u8 *) & wpa,
 							   sizeof(wpa));
 			}
 			break;
@@ -765,7 +764,7 @@ static int prism2mib_priv(mibrec_t *mib,
 *
 ----------------------------------------------------------------*/
 
-void prism2mgmt_pstr2bytestr(hfa384x_bytestr_t *bytestr, p80211pstrd_t *pstr)
+void prism2mgmt_pstr2bytestr(hfa384x_bytestr_t * bytestr, p80211pstrd_t * pstr)
 {
 	bytestr->len = cpu_to_le16((u16) (pstr->len));
 	memcpy(bytestr->data, pstr->data, pstr->len);
@@ -786,7 +785,7 @@ void prism2mgmt_pstr2bytestr(hfa384x_byt
 *
 ----------------------------------------------------------------*/
 
-void prism2mgmt_pstr2bytearea(u8 *bytearea, p80211pstrd_t *pstr)
+void prism2mgmt_pstr2bytearea(u8 * bytearea, p80211pstrd_t * pstr)
 {
 	memcpy(bytearea, pstr->data, pstr->len);
 }
@@ -806,7 +805,7 @@ void prism2mgmt_pstr2bytearea(u8 *bytear
 *
 ----------------------------------------------------------------*/
 
-void prism2mgmt_bytestr2pstr(hfa384x_bytestr_t *bytestr, p80211pstrd_t *pstr)
+void prism2mgmt_bytestr2pstr(hfa384x_bytestr_t * bytestr, p80211pstrd_t * pstr)
 {
 	pstr->len = (u8) (le16_to_cpu((u16) (bytestr->len)));
 	memcpy(pstr->data, bytestr->data, pstr->len);
@@ -827,13 +826,8 @@ void prism2mgmt_bytestr2pstr(hfa384x_byt
 *
 ----------------------------------------------------------------*/
 
-void prism2mgmt_bytearea2pstr(u8 *bytearea, p80211pstrd_t *pstr, int len)
+void prism2mgmt_bytearea2pstr(u8 * bytearea, p80211pstrd_t * pstr, int len)
 {
 	pstr->len = (u8) len;
 	memcpy(pstr->data, bytearea, len);
 }
-
-
-
-
-
--- a/drivers/staging/wlan-ng/prism2sta.c
+++ b/drivers/staging/wlan-ng/prism2sta.c
@@ -127,37 +127,37 @@ MODULE_PARM_DESC(prism2_reset_settletime
 
 MODULE_LICENSE("Dual MPL/GPL");
 
-static int prism2sta_open(wlandevice_t *wlandev);
-static int prism2sta_close(wlandevice_t *wlandev);
-static void prism2sta_reset(wlandevice_t *wlandev);
-static int prism2sta_txframe(wlandevice_t *wlandev, struct sk_buff *skb,
-			     p80211_hdr_t *p80211_hdr,
-			     p80211_metawep_t *p80211_wep);
-static int prism2sta_mlmerequest(wlandevice_t *wlandev, p80211msg_t *msg);
-static int prism2sta_getcardinfo(wlandevice_t *wlandev);
-static int prism2sta_globalsetup(wlandevice_t *wlandev);
-static int prism2sta_setmulticast(wlandevice_t *wlandev, netdevice_t *dev);
-
-static void prism2sta_inf_handover(wlandevice_t *wlandev,
-				   hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_tallies(wlandevice_t *wlandev,
-				  hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_hostscanresults(wlandevice_t *wlandev,
-					  hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_scanresults(wlandevice_t *wlandev,
-				      hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_chinforesults(wlandevice_t *wlandev,
-					hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_linkstatus(wlandevice_t *wlandev,
-				     hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_assocstatus(wlandevice_t *wlandev,
-				      hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_authreq(wlandevice_t *wlandev,
-				  hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_authreq_defer(wlandevice_t *wlandev,
-					hfa384x_InfFrame_t *inf);
-static void prism2sta_inf_psusercnt(wlandevice_t *wlandev,
-				    hfa384x_InfFrame_t *inf);
+static int prism2sta_open(wlandevice_t * wlandev);
+static int prism2sta_close(wlandevice_t * wlandev);
+static void prism2sta_reset(wlandevice_t * wlandev);
+static int prism2sta_txframe(wlandevice_t * wlandev, struct sk_buff *skb,
+			     p80211_hdr_t * p80211_hdr,
+			     p80211_metawep_t * p80211_wep);
+static int prism2sta_mlmerequest(wlandevice_t * wlandev, p80211msg_t * msg);
+static int prism2sta_getcardinfo(wlandevice_t * wlandev);
+static int prism2sta_globalsetup(wlandevice_t * wlandev);
+static int prism2sta_setmulticast(wlandevice_t * wlandev, netdevice_t * dev);
+
+static void prism2sta_inf_handover(wlandevice_t * wlandev,
+				   hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_tallies(wlandevice_t * wlandev,
+				  hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_hostscanresults(wlandevice_t * wlandev,
+					  hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_scanresults(wlandevice_t * wlandev,
+				      hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_chinforesults(wlandevice_t * wlandev,
+					hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_linkstatus(wlandevice_t * wlandev,
+				     hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_assocstatus(wlandevice_t * wlandev,
+				      hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_authreq(wlandevice_t * wlandev,
+				  hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_authreq_defer(wlandevice_t * wlandev,
+					hfa384x_InfFrame_t * inf);
+static void prism2sta_inf_psusercnt(wlandevice_t * wlandev,
+				    hfa384x_InfFrame_t * inf);
 
 /*----------------------------------------------------------------
 * prism2sta_open
@@ -180,7 +180,7 @@ static void prism2sta_inf_psusercnt(wlan
 * Call context:
 *	process thread
 ----------------------------------------------------------------*/
-static int prism2sta_open(wlandevice_t *wlandev)
+static int prism2sta_open(wlandevice_t * wlandev)
 {
 	/* We don't currently have to do anything else.
 	 * The setup of the MAC should be subsequently completed via
@@ -214,7 +214,7 @@ static int prism2sta_open(wlandevice_t *
 * Call context:
 *	process thread
 ----------------------------------------------------------------*/
-static int prism2sta_close(wlandevice_t *wlandev)
+static int prism2sta_close(wlandevice_t * wlandev)
 {
 	/* We don't currently have to do anything else.
 	 * Higher layers know we're not ready from dev->start==0 and
@@ -242,7 +242,7 @@ static int prism2sta_close(wlandevice_t 
 * Call context:
 *	process thread
 ----------------------------------------------------------------*/
-static void prism2sta_reset(wlandevice_t *wlandev)
+static void prism2sta_reset(wlandevice_t * wlandev)
 {
 	return;
 }
@@ -268,9 +268,9 @@ static void prism2sta_reset(wlandevice_t
 * Call context:
 *	process thread
 ----------------------------------------------------------------*/
-static int prism2sta_txframe(wlandevice_t *wlandev, struct sk_buff *skb,
-			     p80211_hdr_t *p80211_hdr,
-			     p80211_metawep_t *p80211_wep)
+static int prism2sta_txframe(wlandevice_t * wlandev, struct sk_buff *skb,
+			     p80211_hdr_t * p80211_hdr,
+			     p80211_metawep_t * p80211_wep)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 	int result;
@@ -310,7 +310,7 @@ static int prism2sta_txframe(wlandevice_
 * Call context:
 *	process thread
 ----------------------------------------------------------------*/
-static int prism2sta_mlmerequest(wlandevice_t *wlandev, p80211msg_t *msg)
+static int prism2sta_mlmerequest(wlandevice_t * wlandev, p80211msg_t * msg)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 
@@ -401,12 +401,9 @@ static int prism2sta_mlmerequest(wlandev
 			qualmsg->noise.status =
 			    P80211ENUM_msgitem_status_data_ok;
 
-			qualmsg->link.data =
-			    le16_to_cpu(hw->qual.CQ_currBSS);
-			qualmsg->level.data =
-			    le16_to_cpu(hw->qual.ASL_currBSS);
-			qualmsg->noise.data =
-			    le16_to_cpu(hw->qual.ANL_currFC);
+			qualmsg->link.data = le16_to_cpu(hw->qual.CQ_currBSS);
+			qualmsg->level.data = le16_to_cpu(hw->qual.ASL_currBSS);
+			qualmsg->noise.data = le16_to_cpu(hw->qual.ANL_currFC);
 
 			break;
 		}
@@ -440,7 +437,7 @@ static int prism2sta_mlmerequest(wlandev
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-u32 prism2sta_ifstate(wlandevice_t *wlandev, u32 ifstate)
+u32 prism2sta_ifstate(wlandevice_t * wlandev, u32 ifstate)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 	u32 result;
@@ -448,7 +445,7 @@ u32 prism2sta_ifstate(wlandevice_t *wlan
 	result = P80211ENUM_resultcode_implementation_failure;
 
 	pr_debug("Current MSD state(%d), requesting(%d)\n",
-	       wlandev->msdstate, ifstate);
+		 wlandev->msdstate, ifstate);
 	switch (ifstate) {
 	case P80211ENUM_ifstate_fwload:
 		switch (wlandev->msdstate) {
@@ -610,7 +607,7 @@ u32 prism2sta_ifstate(wlandevice_t *wlan
 * Call context:
 *	Either.
 ----------------------------------------------------------------*/
-static int prism2sta_getcardinfo(wlandevice_t *wlandev)
+static int prism2sta_getcardinfo(wlandevice_t * wlandev)
 {
 	int result = 0;
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
@@ -811,10 +808,8 @@ static int prism2sta_getcardinfo(wlandev
 	   fields in byte order */
 	hw->cap_act_pri_cfi.role = le16_to_cpu(hw->cap_act_pri_cfi.role);
 	hw->cap_act_pri_cfi.id = le16_to_cpu(hw->cap_act_pri_cfi.id);
-	hw->cap_act_pri_cfi.variant =
-	    le16_to_cpu(hw->cap_act_pri_cfi.variant);
-	hw->cap_act_pri_cfi.bottom =
-	    le16_to_cpu(hw->cap_act_pri_cfi.bottom);
+	hw->cap_act_pri_cfi.variant = le16_to_cpu(hw->cap_act_pri_cfi.variant);
+	hw->cap_act_pri_cfi.bottom = le16_to_cpu(hw->cap_act_pri_cfi.bottom);
 	hw->cap_act_pri_cfi.top = le16_to_cpu(hw->cap_act_pri_cfi.top);
 
 	printk(KERN_INFO
@@ -836,10 +831,8 @@ static int prism2sta_getcardinfo(wlandev
 	   fields in byte order */
 	hw->cap_act_sta_cfi.role = le16_to_cpu(hw->cap_act_sta_cfi.role);
 	hw->cap_act_sta_cfi.id = le16_to_cpu(hw->cap_act_sta_cfi.id);
-	hw->cap_act_sta_cfi.variant =
-	    le16_to_cpu(hw->cap_act_sta_cfi.variant);
-	hw->cap_act_sta_cfi.bottom =
-	    le16_to_cpu(hw->cap_act_sta_cfi.bottom);
+	hw->cap_act_sta_cfi.variant = le16_to_cpu(hw->cap_act_sta_cfi.variant);
+	hw->cap_act_sta_cfi.bottom = le16_to_cpu(hw->cap_act_sta_cfi.bottom);
 	hw->cap_act_sta_cfi.top = le16_to_cpu(hw->cap_act_sta_cfi.top);
 
 	printk(KERN_INFO
@@ -861,10 +854,8 @@ static int prism2sta_getcardinfo(wlandev
 	   fields in byte order */
 	hw->cap_act_sta_mfi.role = le16_to_cpu(hw->cap_act_sta_mfi.role);
 	hw->cap_act_sta_mfi.id = le16_to_cpu(hw->cap_act_sta_mfi.id);
-	hw->cap_act_sta_mfi.variant =
-	    le16_to_cpu(hw->cap_act_sta_mfi.variant);
-	hw->cap_act_sta_mfi.bottom =
-	    le16_to_cpu(hw->cap_act_sta_mfi.bottom);
+	hw->cap_act_sta_mfi.variant = le16_to_cpu(hw->cap_act_sta_mfi.variant);
+	hw->cap_act_sta_mfi.bottom = le16_to_cpu(hw->cap_act_sta_mfi.bottom);
 	hw->cap_act_sta_mfi.top = le16_to_cpu(hw->cap_act_sta_mfi.top);
 
 	printk(KERN_INFO
@@ -940,7 +931,7 @@ done:
 * Call context:
 *	process thread
 ----------------------------------------------------------------*/
-static int prism2sta_globalsetup(wlandevice_t *wlandev)
+static int prism2sta_globalsetup(wlandevice_t * wlandev)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 
@@ -949,7 +940,7 @@ static int prism2sta_globalsetup(wlandev
 					WLAN_DATA_MAXLEN);
 }
 
-static int prism2sta_setmulticast(wlandevice_t *wlandev, netdevice_t *dev)
+static int prism2sta_setmulticast(wlandevice_t * wlandev, netdevice_t * dev)
 {
 	int result = 0;
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
@@ -990,8 +981,8 @@ exit:
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void prism2sta_inf_handover(wlandevice_t *wlandev,
-				   hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_handover(wlandevice_t * wlandev,
+				   hfa384x_InfFrame_t * inf)
 {
 	pr_debug("received infoframe:HANDOVER (unhandled)\n");
 	return;
@@ -1014,8 +1005,8 @@ static void prism2sta_inf_handover(wland
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void prism2sta_inf_tallies(wlandevice_t *wlandev,
-				  hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_tallies(wlandevice_t * wlandev,
+				  hfa384x_InfFrame_t * inf)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 	u16 *src16;
@@ -1031,13 +1022,13 @@ static void prism2sta_inf_tallies(wlande
 
 	cnt = sizeof(hfa384x_CommTallies32_t) / sizeof(u32);
 	if (inf->framelen > 22) {
-		dst = (u32 *)&hw->tallies;
-		src32 = (u32 *)&inf->info.commtallies32;
+		dst = (u32 *) & hw->tallies;
+		src32 = (u32 *) & inf->info.commtallies32;
 		for (i = 0; i < cnt; i++, dst++, src32++)
 			*dst += le32_to_cpu(*src32);
 	} else {
-		dst = (u32 *)&hw->tallies;
-		src16 = (u16 *)&inf->info.commtallies16;
+		dst = (u32 *) & hw->tallies;
+		src16 = (u16 *) & inf->info.commtallies16;
 		for (i = 0; i < cnt; i++, dst++, src16++)
 			*dst += le16_to_cpu(*src16);
 	}
@@ -1062,8 +1053,8 @@ static void prism2sta_inf_tallies(wlande
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void prism2sta_inf_scanresults(wlandevice_t *wlandev,
-				      hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_scanresults(wlandevice_t * wlandev,
+				      hfa384x_InfFrame_t * inf)
 {
 
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
@@ -1080,14 +1071,14 @@ static void prism2sta_inf_scanresults(wl
 
 	/* Print em */
 	pr_debug("rx scanresults, reason=%d, nbss=%d:\n",
-	       inf->info.scanresult.scanreason, nbss);
+		 inf->info.scanresult.scanreason, nbss);
 	for (i = 0; i < nbss; i++) {
 		pr_debug("chid=%d anl=%d sl=%d bcnint=%d\n",
-		       sr->result[i].chid,
-		       sr->result[i].anl,
-		       sr->result[i].sl, sr->result[i].bcnint);
+			 sr->result[i].chid,
+			 sr->result[i].anl,
+			 sr->result[i].sl, sr->result[i].bcnint);
 		pr_debug("  capinfo=0x%04x proberesp_rate=%d\n",
-		       sr->result[i].capinfo, sr->result[i].proberesp_rate);
+			 sr->result[i].capinfo, sr->result[i].proberesp_rate);
 	}
 	/* issue a join request */
 	joinreq.channel = sr->result[0].chid;
@@ -1120,8 +1111,8 @@ static void prism2sta_inf_scanresults(wl
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void prism2sta_inf_hostscanresults(wlandevice_t *wlandev,
-					  hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_hostscanresults(wlandevice_t * wlandev,
+					  hfa384x_InfFrame_t * inf)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 	int nbss;
@@ -1162,8 +1153,8 @@ static void prism2sta_inf_hostscanresult
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void prism2sta_inf_chinforesults(wlandevice_t *wlandev,
-					hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_chinforesults(wlandevice_t * wlandev,
+					hfa384x_InfFrame_t * inf)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 	unsigned int i, n;
@@ -1174,29 +1165,26 @@ static void prism2sta_inf_chinforesults(
 	for (i = 0, n = 0; i < HFA384x_CHINFORESULT_MAX; i++) {
 		if (hw->channel_info.results.scanchannels & (1 << i)) {
 			int channel =
-			    le16_to_cpu(inf->info.chinforesult.result[n].
-					    chid) - 1;
+			    le16_to_cpu(inf->info.chinforesult.result[n].chid) -
+			    1;
 			hfa384x_ChInfoResultSub_t *chinforesult =
 			    &hw->channel_info.results.result[channel];
 			chinforesult->chid = channel;
 			chinforesult->anl =
-			    le16_to_cpu(inf->info.chinforesult.result[n].
-					    anl);
+			    le16_to_cpu(inf->info.chinforesult.result[n].anl);
 			chinforesult->pnl =
-			    le16_to_cpu(inf->info.chinforesult.result[n].
-					    pnl);
+			    le16_to_cpu(inf->info.chinforesult.result[n].pnl);
 			chinforesult->active =
 			    le16_to_cpu(inf->info.chinforesult.result[n].
-					    active);
-			pr_debug(
-			       "chinfo: channel %d, %s level (avg/peak)=%d/%d dB, pcf %d\n",
-			       channel + 1,
-			       chinforesult->
-			       active & HFA384x_CHINFORESULT_BSSACTIVE ?
-			       "signal" : "noise", chinforesult->anl,
-			       chinforesult->pnl,
-			       chinforesult->
-			       active & HFA384x_CHINFORESULT_PCFACTIVE ? 1 : 0);
+					active);
+			pr_debug
+			    ("chinfo: channel %d, %s level (avg/peak)=%d/%d dB, pcf %d\n",
+			     channel + 1,
+			     chinforesult->
+			     active & HFA384x_CHINFORESULT_BSSACTIVE ? "signal"
+			     : "noise", chinforesult->anl, chinforesult->pnl,
+			     chinforesult->
+			     active & HFA384x_CHINFORESULT_PCFACTIVE ? 1 : 0);
 			n++;
 		}
 	}
@@ -1276,9 +1264,9 @@ void prism2sta_processing_defer(struct w
 							wlandev->bssid,
 							WLAN_BSSID_LEN);
 			if (result) {
-				pr_debug(
-				       "getconfig(0x%02x) failed, result = %d\n",
-				       HFA384x_RID_CURRENTBSSID, result);
+				pr_debug
+				    ("getconfig(0x%02x) failed, result = %d\n",
+				     HFA384x_RID_CURRENTBSSID, result);
 				goto failed;
 			}
 
@@ -1286,23 +1274,23 @@ void prism2sta_processing_defer(struct w
 							HFA384x_RID_CURRENTSSID,
 							&ssid, sizeof(ssid));
 			if (result) {
-				pr_debug(
-				       "getconfig(0x%02x) failed, result = %d\n",
-				       HFA384x_RID_CURRENTSSID, result);
+				pr_debug
+				    ("getconfig(0x%02x) failed, result = %d\n",
+				     HFA384x_RID_CURRENTSSID, result);
 				goto failed;
 			}
-			prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *)&ssid,
-						(p80211pstrd_t *)&wlandev->
-						ssid);
+			prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *) & ssid,
+						(p80211pstrd_t *) &
+						wlandev->ssid);
 
 			/* Collect the port status */
 			result = hfa384x_drvr_getconfig16(hw,
 							  HFA384x_RID_PORTSTATUS,
 							  &portstatus);
 			if (result) {
-				pr_debug(
-				       "getconfig(0x%02x) failed, result = %d\n",
-				       HFA384x_RID_PORTSTATUS, result);
+				pr_debug
+				    ("getconfig(0x%02x) failed, result = %d\n",
+				     HFA384x_RID_PORTSTATUS, result);
 				goto failed;
 			}
 			wlandev->macmode =
@@ -1366,9 +1354,8 @@ void prism2sta_processing_defer(struct w
 						HFA384x_RID_CURRENTBSSID,
 						wlandev->bssid, WLAN_BSSID_LEN);
 		if (result) {
-			pr_debug(
-			       "getconfig(0x%02x) failed, result = %d\n",
-			       HFA384x_RID_CURRENTBSSID, result);
+			pr_debug("getconfig(0x%02x) failed, result = %d\n",
+				 HFA384x_RID_CURRENTBSSID, result);
 			goto failed;
 		}
 
@@ -1376,13 +1363,12 @@ void prism2sta_processing_defer(struct w
 						HFA384x_RID_CURRENTSSID,
 						&ssid, sizeof(ssid));
 		if (result) {
-			pr_debug(
-			       "getconfig(0x%02x) failed, result = %d\n",
-			       HFA384x_RID_CURRENTSSID, result);
+			pr_debug("getconfig(0x%02x) failed, result = %d\n",
+				 HFA384x_RID_CURRENTSSID, result);
 			goto failed;
 		}
-		prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *)&ssid,
-					(p80211pstrd_t *)&wlandev->ssid);
+		prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *) & ssid,
+					(p80211pstrd_t *) & wlandev->ssid);
 
 		hw->link_status = HFA384x_LINK_CONNECTED;
 		netif_carrier_on(wlandev->netdev);
@@ -1482,8 +1468,8 @@ failed:
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void prism2sta_inf_linkstatus(wlandevice_t *wlandev,
-				     hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_linkstatus(wlandevice_t * wlandev,
+				     hfa384x_InfFrame_t * inf)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 
@@ -1512,8 +1498,8 @@ static void prism2sta_inf_linkstatus(wla
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void prism2sta_inf_assocstatus(wlandevice_t *wlandev,
-				      hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_assocstatus(wlandevice_t * wlandev,
+				      hfa384x_InfFrame_t * inf)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 	hfa384x_AssocStatus_t rec;
@@ -1574,8 +1560,8 @@ static void prism2sta_inf_assocstatus(wl
 *	interrupt
 *
 ----------------------------------------------------------------*/
-static void prism2sta_inf_authreq(wlandevice_t *wlandev,
-				  hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_authreq(wlandevice_t * wlandev,
+				  hfa384x_InfFrame_t * inf)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 	struct sk_buff *skb;
@@ -1589,8 +1575,8 @@ static void prism2sta_inf_authreq(wlande
 	}
 }
 
-static void prism2sta_inf_authreq_defer(wlandevice_t *wlandev,
-					hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_authreq_defer(wlandevice_t * wlandev,
+					hfa384x_InfFrame_t * inf)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 	hfa384x_authenticateStation_data_t rec;
@@ -1763,8 +1749,8 @@ static void prism2sta_inf_authreq_defer(
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void prism2sta_inf_psusercnt(wlandevice_t *wlandev,
-				    hfa384x_InfFrame_t *inf)
+static void prism2sta_inf_psusercnt(wlandevice_t * wlandev,
+				    hfa384x_InfFrame_t * inf)
 {
 	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
 
@@ -1790,7 +1776,7 @@ static void prism2sta_inf_psusercnt(wlan
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-void prism2sta_ev_info(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+void prism2sta_ev_info(wlandevice_t * wlandev, hfa384x_InfFrame_t * inf)
 {
 	inf->infotype = le16_to_cpu(inf->infotype);
 	/* Dispatch */
@@ -1858,7 +1844,7 @@ void prism2sta_ev_info(wlandevice_t *wla
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-void prism2sta_ev_txexc(wlandevice_t *wlandev, u16 status)
+void prism2sta_ev_txexc(wlandevice_t * wlandev, u16 status)
 {
 	pr_debug("TxExc status=0x%x.\n", status);
 
@@ -1881,7 +1867,7 @@ void prism2sta_ev_txexc(wlandevice_t *wl
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-void prism2sta_ev_tx(wlandevice_t *wlandev, u16 status)
+void prism2sta_ev_tx(wlandevice_t * wlandev, u16 status)
 {
 	pr_debug("Tx Complete, status=0x%04x\n", status);
 	/* update linux network stats */
@@ -1905,7 +1891,7 @@ void prism2sta_ev_tx(wlandevice_t *wland
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-void prism2sta_ev_rx(wlandevice_t *wlandev, struct sk_buff *skb)
+void prism2sta_ev_rx(wlandevice_t * wlandev, struct sk_buff *skb)
 {
 	p80211netdev_rx(wlandev, skb);
 	return;
@@ -1927,7 +1913,7 @@ void prism2sta_ev_rx(wlandevice_t *wland
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-void prism2sta_ev_alloc(wlandevice_t *wlandev)
+void prism2sta_ev_alloc(wlandevice_t * wlandev)
 {
 	netif_wake_queue(wlandev->netdev);
 	return;
@@ -2020,9 +2006,9 @@ void prism2sta_commsqual_defer(struct wo
 		}
 
 		pr_debug("commsqual %d %d %d\n",
-		       le16_to_cpu(hw->qual.CQ_currBSS),
-		       le16_to_cpu(hw->qual.ASL_currBSS),
-		       le16_to_cpu(hw->qual.ANL_currFC));
+			 le16_to_cpu(hw->qual.CQ_currBSS),
+			 le16_to_cpu(hw->qual.ASL_currBSS),
+			 le16_to_cpu(hw->qual.ANL_currFC));
 	}
 
 	/* Lastly, we need to make sure the BSSID didn't change on us */
@@ -2030,9 +2016,8 @@ void prism2sta_commsqual_defer(struct wo
 					HFA384x_RID_CURRENTBSSID,
 					wlandev->bssid, WLAN_BSSID_LEN);
 	if (result) {
-		pr_debug(
-		       "getconfig(0x%02x) failed, result = %d\n",
-		       HFA384x_RID_CURRENTBSSID, result);
+		pr_debug("getconfig(0x%02x) failed, result = %d\n",
+			 HFA384x_RID_CURRENTBSSID, result);
 		goto done;
 	}
 
@@ -2040,13 +2025,12 @@ void prism2sta_commsqual_defer(struct wo
 					HFA384x_RID_CURRENTSSID,
 					&ssid, sizeof(ssid));
 	if (result) {
-		pr_debug(
-		       "getconfig(0x%02x) failed, result = %d\n",
-		       HFA384x_RID_CURRENTSSID, result);
+		pr_debug("getconfig(0x%02x) failed, result = %d\n",
+			 HFA384x_RID_CURRENTSSID, result);
 		goto done;
 	}
-	prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *)&ssid,
-				(p80211pstrd_t *)&wlandev->ssid);
+	prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *) & ssid,
+				(p80211pstrd_t *) & wlandev->ssid);
 
 	/* Reschedule timer */
 	mod_timer(&hw->commsqual_timer, jiffies + HZ);
--- a/drivers/staging/wlan-ng/prism2usb.c
+++ b/drivers/staging/wlan-ng/prism2usb.c
@@ -24,9 +24,8 @@ static struct usb_device_id usb_prism_tb
 	 (0x066b, 0x2213, "Linksys WUSB12v1.1 11Mbps WLAN USB Adapter")},
 	{PRISM_USB_DEVICE
 	 (0x067c, 0x1022, "Siemens SpeedStream 1022 11Mbps WLAN USB Adapter")},
-	{PRISM_USB_DEVICE
-	 (0x049f, 0x0033,
-	  "Compaq/Intel W100 PRO/Wireless 11Mbps multiport WLAN Adapter")},
+	{PRISM_USB_DEVICE(0x049f, 0x0033,
+			  "Compaq/Intel W100 PRO/Wireless 11Mbps multiport WLAN Adapter")},
 	{PRISM_USB_DEVICE
 	 (0x0411, 0x0016, "Melco WLI-USB-S11 11Mbps WLAN Adapter")},
 	{PRISM_USB_DEVICE
