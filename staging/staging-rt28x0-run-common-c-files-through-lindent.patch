From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Subject: Staging: rt28x0: run common/*.c files through Lindent

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2860/common/action.c       |  604 +-
 drivers/staging/rt2860/common/ba_action.c    | 1462 ++----
 drivers/staging/rt2860/common/cmm_aes.c      | 1115 ++--
 drivers/staging/rt2860/common/cmm_asic.c     | 2447 +++++-----
 drivers/staging/rt2860/common/cmm_cfg.c      |  218 
 drivers/staging/rt2860/common/cmm_data.c     | 1848 +++-----
 drivers/staging/rt2860/common/cmm_data_pci.c |  709 +--
 drivers/staging/rt2860/common/cmm_data_usb.c |  769 +--
 drivers/staging/rt2860/common/cmm_info.c     | 1054 ++--
 drivers/staging/rt2860/common/cmm_mac_pci.c  | 1657 +++----
 drivers/staging/rt2860/common/cmm_mac_usb.c  |  701 +--
 drivers/staging/rt2860/common/cmm_sanity.c   | 1596 +++---
 drivers/staging/rt2860/common/cmm_sync.c     |  730 +--
 drivers/staging/rt2860/common/cmm_tkip.c     |  625 +-
 drivers/staging/rt2860/common/cmm_wep.c      |  188 
 drivers/staging/rt2860/common/cmm_wpa.c      | 2938 ++++++------
 drivers/staging/rt2860/common/crypt_hmac.c   |  231 -
 drivers/staging/rt2860/common/crypt_md5.c    |  367 -
 drivers/staging/rt2860/common/crypt_sha2.c   |  265 -
 drivers/staging/rt2860/common/dfs.c          |   12 
 drivers/staging/rt2860/common/ee_efuse.c     |  236 -
 drivers/staging/rt2860/common/ee_prom.c      |   91 
 drivers/staging/rt2860/common/eeprom.c       |   56 
 drivers/staging/rt2860/common/mlme.c         | 6175 +++++++++++++--------------
 drivers/staging/rt2860/common/rt_channel.c   | 2583 ++++++-----
 drivers/staging/rt2860/common/rt_rf.c        |   86 
 drivers/staging/rt2860/common/rtmp_init.c    | 2423 +++++-----
 drivers/staging/rt2860/common/rtmp_mcu.c     |  180 
 drivers/staging/rt2860/common/rtmp_timer.c   |  119 
 drivers/staging/rt2860/common/spectrum.c     | 1589 +++---
 30 files changed, 16319 insertions(+), 16755 deletions(-)

--- a/drivers/staging/rt2860/common/action.c
+++ b/drivers/staging/rt2860/common/action.c
@@ -39,10 +39,7 @@
 #include "../rt_config.h"
 #include "action.h"
 
-
-static VOID ReservedAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem);
+static VOID ReservedAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
 /*
     ==========================================================================
@@ -61,75 +58,89 @@ static VOID ReservedAction(
         MT2_CLS3ERR              cls3err_action
     ==========================================================================
  */
-VOID ActionStateMachineInit(
-    IN	PRTMP_ADAPTER	pAd,
-    IN  STATE_MACHINE *S,
-    OUT STATE_MACHINE_FUNC Trans[])
-{
-	StateMachineInit(S, (STATE_MACHINE_FUNC *)Trans, MAX_ACT_STATE, MAX_ACT_MSG, (STATE_MACHINE_FUNC)Drop, ACT_IDLE, ACT_MACHINE_BASE);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_SPECTRUM_CATE, (STATE_MACHINE_FUNC)PeerSpectrumAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_QOS_CATE, (STATE_MACHINE_FUNC)PeerQOSAction);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_DLS_CATE, (STATE_MACHINE_FUNC)ReservedAction);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_BA_CATE, (STATE_MACHINE_FUNC)PeerBAAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_HT_CATE, (STATE_MACHINE_FUNC)PeerHTAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_ADD_BA_CATE, (STATE_MACHINE_FUNC)MlmeADDBAAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_ORI_DELBA_CATE, (STATE_MACHINE_FUNC)MlmeDELBAAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_REC_DELBA_CATE, (STATE_MACHINE_FUNC)MlmeDELBAAction);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_PUBLIC_CATE, (STATE_MACHINE_FUNC)PeerPublicAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_RM_CATE, (STATE_MACHINE_FUNC)PeerRMAction);
-
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_QOS_CATE, (STATE_MACHINE_FUNC)MlmeQOSAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_DLS_CATE, (STATE_MACHINE_FUNC)MlmeDLSAction);
-	StateMachineSetAction(S, ACT_IDLE, MT2_ACT_INVALID, (STATE_MACHINE_FUNC)MlmeInvalidAction);
+VOID ActionStateMachineInit(IN PRTMP_ADAPTER pAd,
+			    IN STATE_MACHINE * S,
+			    OUT STATE_MACHINE_FUNC Trans[])
+{
+	StateMachineInit(S, (STATE_MACHINE_FUNC *) Trans, MAX_ACT_STATE,
+			 MAX_ACT_MSG, (STATE_MACHINE_FUNC) Drop, ACT_IDLE,
+			 ACT_MACHINE_BASE);
+
+	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_SPECTRUM_CATE,
+			      (STATE_MACHINE_FUNC) PeerSpectrumAction);
+	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_QOS_CATE,
+			      (STATE_MACHINE_FUNC) PeerQOSAction);
+
+	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_DLS_CATE,
+			      (STATE_MACHINE_FUNC) ReservedAction);
+
+	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_BA_CATE,
+			      (STATE_MACHINE_FUNC) PeerBAAction);
+	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_HT_CATE,
+			      (STATE_MACHINE_FUNC) PeerHTAction);
+	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_ADD_BA_CATE,
+			      (STATE_MACHINE_FUNC) MlmeADDBAAction);
+	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_ORI_DELBA_CATE,
+			      (STATE_MACHINE_FUNC) MlmeDELBAAction);
+	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_REC_DELBA_CATE,
+			      (STATE_MACHINE_FUNC) MlmeDELBAAction);
+
+	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_PUBLIC_CATE,
+			      (STATE_MACHINE_FUNC) PeerPublicAction);
+	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_RM_CATE,
+			      (STATE_MACHINE_FUNC) PeerRMAction);
+
+	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_QOS_CATE,
+			      (STATE_MACHINE_FUNC) MlmeQOSAction);
+	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_DLS_CATE,
+			      (STATE_MACHINE_FUNC) MlmeDLSAction);
+	StateMachineSetAction(S, ACT_IDLE, MT2_ACT_INVALID,
+			      (STATE_MACHINE_FUNC) MlmeInvalidAction);
 }
 
-VOID MlmeADDBAAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
-
+VOID MlmeADDBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	MLME_ADDBA_REQ_STRUCT *pInfo;
-	UCHAR           Addr[6];
-	PUCHAR         pOutBuffer = NULL;
-	NDIS_STATUS     NStatus;
-	ULONG		Idx;
-	FRAME_ADDBA_REQ  Frame;
-	ULONG		FrameLen;
-	BA_ORI_ENTRY			*pBAEntry = NULL;
+	UCHAR Addr[6];
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+	ULONG Idx;
+	FRAME_ADDBA_REQ Frame;
+	ULONG FrameLen;
+	BA_ORI_ENTRY *pBAEntry = NULL;
 
-	pInfo = (MLME_ADDBA_REQ_STRUCT *)Elem->Msg;
+	pInfo = (MLME_ADDBA_REQ_STRUCT *) Elem->Msg;
 	NdisZeroMemory(&Frame, sizeof(FRAME_ADDBA_REQ));
 
-	if(MlmeAddBAReqSanity(pAd, Elem->Msg, Elem->MsgLen, Addr))
-	{
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-		if(NStatus != NDIS_STATUS_SUCCESS)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,("BA - MlmeADDBAAction() allocate memory failed \n"));
+	if (MlmeAddBAReqSanity(pAd, Elem->Msg, Elem->MsgLen, Addr)) {
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+		if (NStatus != NDIS_STATUS_SUCCESS) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BA - MlmeADDBAAction() allocate memory failed \n"));
 			return;
 		}
 		// 1. find entry
-		Idx = pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
-		if (Idx == 0)
-		{
+		Idx =
+		    pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
+		if (Idx == 0) {
 			MlmeFreeMemory(pAd, pOutBuffer);
-			DBGPRINT(RT_DEBUG_ERROR,("BA - MlmeADDBAAction() can't find BAOriEntry \n"));
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("BA - MlmeADDBAAction() can't find BAOriEntry \n"));
 			return;
-		}
-		else
-		{
-			pBAEntry =&pAd->BATable.BAOriEntry[Idx];
+		} else {
+			pBAEntry = &pAd->BATable.BAOriEntry[Idx];
 		}
 
 		{
 			if (ADHOC_ON(pAd))
-				ActHeaderInit(pAd, &Frame.Hdr, pInfo->pAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+				ActHeaderInit(pAd, &Frame.Hdr, pInfo->pAddr,
+					      pAd->CurrentAddress,
+					      pAd->CommonCfg.Bssid);
 			else
-				ActHeaderInit(pAd, &Frame.Hdr, pAd->CommonCfg.Bssid, pAd->CurrentAddress, pInfo->pAddr);
+				ActHeaderInit(pAd, &Frame.Hdr,
+					      pAd->CommonCfg.Bssid,
+					      pAd->CurrentAddress,
+					      pInfo->pAddr);
 		}
 
 		Frame.Category = CATEGORY_BA;
@@ -141,22 +152,29 @@ VOID MlmeADDBAAction(
 		Frame.Token = pInfo->Token;
 		Frame.TimeOutValue = pInfo->TimeOutValue;
 		Frame.BaStartSeq.field.FragNum = 0;
-		Frame.BaStartSeq.field.StartSeq = pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID];
+		Frame.BaStartSeq.field.StartSeq =
+		    pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID];
 
-		*(USHORT *)(&Frame.BaParm) = cpu2le16(*(USHORT *)(&Frame.BaParm));
+		*(USHORT *) (&Frame.BaParm) =
+		    cpu2le16(*(USHORT *) (&Frame.BaParm));
 		Frame.TimeOutValue = cpu2le16(Frame.TimeOutValue);
 		Frame.BaStartSeq.word = cpu2le16(Frame.BaStartSeq.word);
 
-		MakeOutgoingFrame(pOutBuffer,		   &FrameLen,
-		              sizeof(FRAME_ADDBA_REQ), &Frame,
-		              END_OF_ARGS);
+		MakeOutgoingFrame(pOutBuffer, &FrameLen,
+				  sizeof(FRAME_ADDBA_REQ), &Frame, END_OF_ARGS);
 
-		MiniportMMRequest(pAd, (MGMT_USE_QUEUE_FLAG | MapUserPriorityToAccessCategory[pInfo->TID]), pOutBuffer, FrameLen);
+		MiniportMMRequest(pAd,
+				  (MGMT_USE_QUEUE_FLAG |
+				   MapUserPriorityToAccessCategory[pInfo->TID]),
+				  pOutBuffer, FrameLen);
 
 		MlmeFreeMemory(pAd, pOutBuffer);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("BA - Send ADDBA request. StartSeq = %x,  FrameLen = %ld. BufSize = %d\n", Frame.BaStartSeq.field.StartSeq, FrameLen, Frame.BaParm.BufSize));
-    }
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("BA - Send ADDBA request. StartSeq = %x,  FrameLen = %ld. BufSize = %d\n",
+			  Frame.BaStartSeq.field.StartSeq, FrameLen,
+			  Frame.BaParm.BufSize));
+	}
 }
 
 /*
@@ -170,282 +188,271 @@ VOID MlmeADDBAAction(
 
     ==========================================================================
  */
-VOID MlmeDELBAAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeDELBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	MLME_DELBA_REQ_STRUCT *pInfo;
-	PUCHAR         pOutBuffer = NULL;
-	PUCHAR		   pOutBuffer2 = NULL;
-	NDIS_STATUS     NStatus;
-	ULONG		Idx;
-	FRAME_DELBA_REQ  Frame;
-	ULONG		FrameLen;
-	FRAME_BAR	FrameBar;
+	PUCHAR pOutBuffer = NULL;
+	PUCHAR pOutBuffer2 = NULL;
+	NDIS_STATUS NStatus;
+	ULONG Idx;
+	FRAME_DELBA_REQ Frame;
+	ULONG FrameLen;
+	FRAME_BAR FrameBar;
 
-	pInfo = (MLME_DELBA_REQ_STRUCT *)Elem->Msg;
+	pInfo = (MLME_DELBA_REQ_STRUCT *) Elem->Msg;
 	// must send back DELBA
 	NdisZeroMemory(&Frame, sizeof(FRAME_DELBA_REQ));
-	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeDELBAAction(), Initiator(%d) \n", pInfo->Initiator));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("==> MlmeDELBAAction(), Initiator(%d) \n", pInfo->Initiator));
 
-	if(MlmeDelBAReqSanity(pAd, Elem->Msg, Elem->MsgLen))
-	{
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-		if(NStatus != NDIS_STATUS_SUCCESS)
-		{
-			DBGPRINT(RT_DEBUG_ERROR,("BA - MlmeDELBAAction() allocate memory failed 1. \n"));
+	if (MlmeDelBAReqSanity(pAd, Elem->Msg, Elem->MsgLen)) {
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+		if (NStatus != NDIS_STATUS_SUCCESS) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("BA - MlmeDELBAAction() allocate memory failed 1. \n"));
 			return;
 		}
 
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);  //Get an unused nonpaged memory
-		if(NStatus != NDIS_STATUS_SUCCESS)
-		{
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);	//Get an unused nonpaged memory
+		if (NStatus != NDIS_STATUS_SUCCESS) {
 			MlmeFreeMemory(pAd, pOutBuffer);
-			DBGPRINT(RT_DEBUG_ERROR, ("BA - MlmeDELBAAction() allocate memory failed 2. \n"));
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("BA - MlmeDELBAAction() allocate memory failed 2. \n"));
 			return;
 		}
-
 		// SEND BAR (Send BAR to refresh peer reordering buffer.)
-		Idx = pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
-
-		BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->CurrentAddress);
+		Idx =
+		    pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
 
-		FrameBar.StartingSeq.field.FragNum = 0; // make sure sequence not clear in DEL funciton.
-		FrameBar.StartingSeq.field.StartSeq = pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID]; // make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.TID = pInfo->TID; // make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.ACKPolicy = IMMED_BA; // make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.Compressed = 1; // make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.MTID = 0; // make sure sequence not clear in DEL funciton.
+		BarHeaderInit(pAd, &FrameBar,
+			      pAd->MacTab.Content[pInfo->Wcid].Addr,
+			      pAd->CurrentAddress);
+
+		FrameBar.StartingSeq.field.FragNum = 0;	// make sure sequence not clear in DEL funciton.
+		FrameBar.StartingSeq.field.StartSeq = pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID];	// make sure sequence not clear in DEL funciton.
+		FrameBar.BarControl.TID = pInfo->TID;	// make sure sequence not clear in DEL funciton.
+		FrameBar.BarControl.ACKPolicy = IMMED_BA;	// make sure sequence not clear in DEL funciton.
+		FrameBar.BarControl.Compressed = 1;	// make sure sequence not clear in DEL funciton.
+		FrameBar.BarControl.MTID = 0;	// make sure sequence not clear in DEL funciton.
 
-		MakeOutgoingFrame(pOutBuffer2,				&FrameLen,
-					  sizeof(FRAME_BAR),	  &FrameBar,
-					  END_OF_ARGS);
+		MakeOutgoingFrame(pOutBuffer2, &FrameLen,
+				  sizeof(FRAME_BAR), &FrameBar, END_OF_ARGS);
 		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer2, FrameLen);
 		MlmeFreeMemory(pAd, pOutBuffer2);
-		DBGPRINT(RT_DEBUG_TRACE,("BA - MlmeDELBAAction() . Send BAR to refresh peer reordering buffer \n"));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("BA - MlmeDELBAAction() . Send BAR to refresh peer reordering buffer \n"));
 
 		// SEND DELBA FRAME
 		FrameLen = 0;
 
 		{
 			if (ADHOC_ON(pAd))
-				ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+				ActHeaderInit(pAd, &Frame.Hdr,
+					      pAd->MacTab.Content[pInfo->Wcid].
+					      Addr, pAd->CurrentAddress,
+					      pAd->CommonCfg.Bssid);
 			else
-				ActHeaderInit(pAd, &Frame.Hdr,  pAd->CommonCfg.Bssid, pAd->CurrentAddress, pAd->MacTab.Content[pInfo->Wcid].Addr);
+				ActHeaderInit(pAd, &Frame.Hdr,
+					      pAd->CommonCfg.Bssid,
+					      pAd->CurrentAddress,
+					      pAd->MacTab.Content[pInfo->Wcid].
+					      Addr);
 		}
 
 		Frame.Category = CATEGORY_BA;
 		Frame.Action = DELBA;
 		Frame.DelbaParm.Initiator = pInfo->Initiator;
 		Frame.DelbaParm.TID = pInfo->TID;
-		Frame.ReasonCode = 39; // Time Out
-		*(USHORT *)(&Frame.DelbaParm) = cpu2le16(*(USHORT *)(&Frame.DelbaParm));
+		Frame.ReasonCode = 39;	// Time Out
+		*(USHORT *) (&Frame.DelbaParm) =
+		    cpu2le16(*(USHORT *) (&Frame.DelbaParm));
 		Frame.ReasonCode = cpu2le16(Frame.ReasonCode);
 
-		MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-		              sizeof(FRAME_DELBA_REQ),    &Frame,
-		              END_OF_ARGS);
+		MakeOutgoingFrame(pOutBuffer, &FrameLen,
+				  sizeof(FRAME_DELBA_REQ), &Frame, END_OF_ARGS);
 		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 		MlmeFreeMemory(pAd, pOutBuffer);
-		DBGPRINT(RT_DEBUG_TRACE, ("BA - MlmeDELBAAction() . 3 DELBA sent. Initiator(%d)\n", pInfo->Initiator));
-    	}
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("BA - MlmeDELBAAction() . 3 DELBA sent. Initiator(%d)\n",
+			  pInfo->Initiator));
+	}
 }
 
-VOID MlmeQOSAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeQOSAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 }
 
-VOID MlmeDLSAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeDLSAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 }
 
-VOID MlmeInvalidAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeInvalidAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	//PUCHAR		   pOutBuffer = NULL;
+	//PUCHAR                   pOutBuffer = NULL;
 	//Return the receiving frame except the MSB of category filed set to 1.  7.3.1.11
 }
 
-VOID PeerQOSAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerQOSAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 }
 
-VOID PeerBAAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR	Action = Elem->Msg[LENGTH_802_11+1];
+	UCHAR Action = Elem->Msg[LENGTH_802_11 + 1];
 
-	switch(Action)
-	{
-		case ADDBA_REQ:
-			PeerAddBAReqAction(pAd,Elem);
-			break;
-		case ADDBA_RESP:
-			PeerAddBARspAction(pAd,Elem);
-			break;
-		case DELBA:
-			PeerDelBAAction(pAd,Elem);
-			break;
+	switch (Action) {
+	case ADDBA_REQ:
+		PeerAddBAReqAction(pAd, Elem);
+		break;
+	case ADDBA_RESP:
+		PeerAddBARspAction(pAd, Elem);
+		break;
+	case DELBA:
+		PeerDelBAAction(pAd, Elem);
+		break;
 	}
 }
 
-VOID PeerPublicAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerPublicAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
 		return;
 }
 
-
-static VOID ReservedAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+static VOID ReservedAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	UCHAR Category;
 
-	if (Elem->MsgLen <= LENGTH_802_11)
-	{
+	if (Elem->MsgLen <= LENGTH_802_11) {
 		return;
 	}
 
 	Category = Elem->Msg[LENGTH_802_11];
-	DBGPRINT(RT_DEBUG_TRACE,("Rcv reserved category(%d) Action Frame\n", Category));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Rcv reserved category(%d) Action Frame\n", Category));
 	hex_dump("Reserved Action Frame", &Elem->Msg[0], Elem->MsgLen);
 }
 
-VOID PeerRMAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
-
+VOID PeerRMAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	return;
 }
 
-static VOID respond_ht_information_exchange_action(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
-{
-	PUCHAR			pOutBuffer = NULL;
-	NDIS_STATUS		NStatus;
-	ULONG			FrameLen;
-	FRAME_HT_INFO	HTINFOframe, *pFrame;
-	UCHAR   		*pAddr;
-
+static VOID respond_ht_information_exchange_action(IN PRTMP_ADAPTER pAd,
+						   IN MLME_QUEUE_ELEM * Elem)
+{
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+	ULONG FrameLen;
+	FRAME_HT_INFO HTINFOframe, *pFrame;
+	UCHAR *pAddr;
 
 	// 2. Always send back ADDBA Response
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	 //Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
 
-	if (NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("ACTION - respond_ht_information_exchange_action() allocate memory failed \n"));
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ACTION - respond_ht_information_exchange_action() allocate memory failed \n"));
 		return;
 	}
-
 	// get RA
-	pFrame = (FRAME_HT_INFO *) &Elem->Msg[0];
+	pFrame = (FRAME_HT_INFO *) & Elem->Msg[0];
 	pAddr = pFrame->Hdr.Addr2;
 
 	NdisZeroMemory(&HTINFOframe, sizeof(FRAME_HT_INFO));
 	// 2-1. Prepare ADDBA Response frame.
 	{
 		if (ADHOC_ON(pAd))
-			ActHeaderInit(pAd, &HTINFOframe.Hdr, pAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+			ActHeaderInit(pAd, &HTINFOframe.Hdr, pAddr,
+				      pAd->CurrentAddress,
+				      pAd->CommonCfg.Bssid);
 		else
-			ActHeaderInit(pAd, &HTINFOframe.Hdr, pAd->CommonCfg.Bssid, pAd->CurrentAddress, pAddr);
+			ActHeaderInit(pAd, &HTINFOframe.Hdr,
+				      pAd->CommonCfg.Bssid, pAd->CurrentAddress,
+				      pAddr);
 	}
 
 	HTINFOframe.Category = CATEGORY_HT;
 	HTINFOframe.Action = HT_INFO_EXCHANGE;
 	HTINFOframe.HT_Info.Request = 0;
-	HTINFOframe.HT_Info.Forty_MHz_Intolerant = pAd->CommonCfg.HtCapability.HtCapInfo.Forty_Mhz_Intolerant;
-	HTINFOframe.HT_Info.STA_Channel_Width	 = pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth;
+	HTINFOframe.HT_Info.Forty_MHz_Intolerant =
+	    pAd->CommonCfg.HtCapability.HtCapInfo.Forty_Mhz_Intolerant;
+	HTINFOframe.HT_Info.STA_Channel_Width =
+	    pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth;
 
-	MakeOutgoingFrame(pOutBuffer,					&FrameLen,
-					  sizeof(FRAME_HT_INFO),	&HTINFOframe,
-					  END_OF_ARGS);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen,
+			  sizeof(FRAME_HT_INFO), &HTINFOframe, END_OF_ARGS);
 
 	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
 }
 
-VOID PeerHTAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerHTAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR	Action = Elem->Msg[LENGTH_802_11+1];
+	UCHAR Action = Elem->Msg[LENGTH_802_11 + 1];
 
 	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
 		return;
 
-	switch(Action)
-	{
-		case NOTIFY_BW_ACTION:
-			DBGPRINT(RT_DEBUG_TRACE,("ACTION - HT Notify Channel bandwidth action----> \n"));
-
-			if(pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
-			{
-				// Note, this is to patch DIR-1353 AP. When the AP set to Wep, it will use legacy mode. But AP still keeps
-				// sending BW_Notify Action frame, and cause us to linkup and linkdown.
-				// In legacy mode, don't need to parse HT action frame.
-				DBGPRINT(RT_DEBUG_TRACE,("ACTION -Ignore HT Notify Channel BW when link as legacy mode. BW = %d---> \n",
-								Elem->Msg[LENGTH_802_11+2] ));
-				break;
-			}
-
-			if (Elem->Msg[LENGTH_802_11+2] == 0)	// 7.4.8.2. if value is 1, keep the same as supported channel bandwidth.
-				pAd->MacTab.Content[Elem->Wcid].HTPhyMode.field.BW = 0;
-
+	switch (Action) {
+	case NOTIFY_BW_ACTION:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ACTION - HT Notify Channel bandwidth action----> \n"));
+
+		if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) {
+			// Note, this is to patch DIR-1353 AP. When the AP set to Wep, it will use legacy mode. But AP still keeps
+			// sending BW_Notify Action frame, and cause us to linkup and linkdown.
+			// In legacy mode, don't need to parse HT action frame.
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("ACTION -Ignore HT Notify Channel BW when link as legacy mode. BW = %d---> \n",
+				  Elem->Msg[LENGTH_802_11 + 2]));
 			break;
-		case SMPS_ACTION:
-			// 7.3.1.25
- 			DBGPRINT(RT_DEBUG_TRACE,("ACTION - SMPS action----> \n"));
-			if (((Elem->Msg[LENGTH_802_11+2]&0x1) == 0))
-			{
-				pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_ENABLE;
-			}
-			else if (((Elem->Msg[LENGTH_802_11+2]&0x2) == 0))
-			{
-				pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_STATIC;
-			}
-			else
-			{
-				pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_DYNAMIC;
-			}
+		}
 
-			DBGPRINT(RT_DEBUG_TRACE,("Aid(%d) MIMO PS = %d\n", Elem->Wcid, pAd->MacTab.Content[Elem->Wcid].MmpsMode));
-			// rt2860c : add something for smps change.
-			break;
+		if (Elem->Msg[LENGTH_802_11 + 2] == 0)	// 7.4.8.2. if value is 1, keep the same as supported channel bandwidth.
+			pAd->MacTab.Content[Elem->Wcid].HTPhyMode.field.BW = 0;
 
-		case SETPCO_ACTION:
-			break;
-		case MIMO_CHA_MEASURE_ACTION:
-			break;
-		case HT_INFO_EXCHANGE:
-			{
-				HT_INFORMATION_OCTET	*pHT_info;
+		break;
+	case SMPS_ACTION:
+		// 7.3.1.25
+		DBGPRINT(RT_DEBUG_TRACE, ("ACTION - SMPS action----> \n"));
+		if (((Elem->Msg[LENGTH_802_11 + 2] & 0x1) == 0)) {
+			pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_ENABLE;
+		} else if (((Elem->Msg[LENGTH_802_11 + 2] & 0x2) == 0)) {
+			pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_STATIC;
+		} else {
+			pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_DYNAMIC;
+		}
+
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Aid(%d) MIMO PS = %d\n", Elem->Wcid,
+			  pAd->MacTab.Content[Elem->Wcid].MmpsMode));
+		// rt2860c : add something for smps change.
+		break;
+
+	case SETPCO_ACTION:
+		break;
+	case MIMO_CHA_MEASURE_ACTION:
+		break;
+	case HT_INFO_EXCHANGE:
+		{
+			HT_INFORMATION_OCTET *pHT_info;
 
-				pHT_info = (HT_INFORMATION_OCTET *) &Elem->Msg[LENGTH_802_11+2];
-    				// 7.4.8.10
-    				DBGPRINT(RT_DEBUG_TRACE,("ACTION - HT Information Exchange action----> \n"));
-    				if (pHT_info->Request)
-    				{
-    					respond_ht_information_exchange_action(pAd, Elem);
-    				}
+			pHT_info =
+			    (HT_INFORMATION_OCTET *) & Elem->Msg[LENGTH_802_11 +
+								 2];
+			// 7.4.8.10
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("ACTION - HT Information Exchange action----> \n"));
+			if (pHT_info->Request) {
+				respond_ht_information_exchange_action(pAd,
+								       Elem);
 			}
-    			break;
+		}
+		break;
 	}
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -460,80 +467,79 @@ VOID PeerHTAction(
 				FALSE , then continue indicaterx at this moment.
 	==========================================================================
  */
-VOID ORIBATimerTimeout(
-	IN	PRTMP_ADAPTER	pAd)
+VOID ORIBATimerTimeout(IN PRTMP_ADAPTER pAd)
 {
-	MAC_TABLE_ENTRY	*pEntry;
-	INT			i, total;
-	UCHAR			TID;
+	MAC_TABLE_ENTRY *pEntry;
+	INT i, total;
+	UCHAR TID;
 
 	total = pAd->MacTab.Size * NUM_OF_TID;
 
-	for (i = 1; ((i <MAX_LEN_OF_BA_ORI_TABLE) && (total > 0)) ; i++)
-	{
-		if  (pAd->BATable.BAOriEntry[i].ORI_BA_Status == Originator_Done)
-		{
-			pEntry = &pAd->MacTab.Content[pAd->BATable.BAOriEntry[i].Wcid];
+	for (i = 1; ((i < MAX_LEN_OF_BA_ORI_TABLE) && (total > 0)); i++) {
+		if (pAd->BATable.BAOriEntry[i].ORI_BA_Status == Originator_Done) {
+			pEntry =
+			    &pAd->MacTab.Content[pAd->BATable.BAOriEntry[i].
+						 Wcid];
 			TID = pAd->BATable.BAOriEntry[i].TID;
 
-			ASSERT(pAd->BATable.BAOriEntry[i].Wcid < MAX_LEN_OF_MAC_TABLE);
+			ASSERT(pAd->BATable.BAOriEntry[i].Wcid <
+			       MAX_LEN_OF_MAC_TABLE);
 		}
-		total --;
+		total--;
 	}
 }
 
+VOID SendRefreshBAR(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry)
+{
+	FRAME_BAR FrameBar;
+	ULONG FrameLen;
+	NDIS_STATUS NStatus;
+	PUCHAR pOutBuffer = NULL;
+	USHORT Sequence;
+	UCHAR i, TID;
+	USHORT idx;
+	BA_ORI_ENTRY *pBAEntry;
 
-VOID SendRefreshBAR(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	MAC_TABLE_ENTRY	*pEntry)
-{
-	FRAME_BAR		FrameBar;
-	ULONG			FrameLen;
-	NDIS_STATUS 	NStatus;
-	PUCHAR			pOutBuffer = NULL;
-	USHORT			Sequence;
-	UCHAR			i, TID;
-	USHORT			idx;
-	BA_ORI_ENTRY	*pBAEntry;
-
-	for (i = 0; i <NUM_OF_TID; i++)
-	{
+	for (i = 0; i < NUM_OF_TID; i++) {
 		idx = pEntry->BAOriWcidArray[i];
-		if (idx == 0)
-		{
+		if (idx == 0) {
 			continue;
 		}
 		pBAEntry = &pAd->BATable.BAOriEntry[idx];
 
-		if  (pBAEntry->ORI_BA_Status == Originator_Done)
-		{
+		if (pBAEntry->ORI_BA_Status == Originator_Done) {
 			TID = pBAEntry->TID;
 
 			ASSERT(pBAEntry->Wcid < MAX_LEN_OF_MAC_TABLE);
 
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-			if(NStatus != NDIS_STATUS_SUCCESS)
-			{
-				DBGPRINT(RT_DEBUG_ERROR,("BA - MlmeADDBAAction() allocate memory failed \n"));
+			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+			if (NStatus != NDIS_STATUS_SUCCESS) {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("BA - MlmeADDBAAction() allocate memory failed \n"));
 				return;
 			}
 
 			Sequence = pEntry->TxSeq[TID];
 
-			BarHeaderInit(pAd, &FrameBar, pEntry->Addr, pAd->CurrentAddress);
+			BarHeaderInit(pAd, &FrameBar, pEntry->Addr,
+				      pAd->CurrentAddress);
 
-			FrameBar.StartingSeq.field.FragNum = 0; // make sure sequence not clear in DEL function.
-			FrameBar.StartingSeq.field.StartSeq = Sequence; // make sure sequence not clear in DEL funciton.
-			FrameBar.BarControl.TID = TID; // make sure sequence not clear in DEL funciton.
-
-			MakeOutgoingFrame(pOutBuffer,				&FrameLen,
-							  sizeof(FRAME_BAR),	  &FrameBar,
-							  END_OF_ARGS);
+			FrameBar.StartingSeq.field.FragNum = 0;	// make sure sequence not clear in DEL function.
+			FrameBar.StartingSeq.field.StartSeq = Sequence;	// make sure sequence not clear in DEL funciton.
+			FrameBar.BarControl.TID = TID;	// make sure sequence not clear in DEL funciton.
+
+			MakeOutgoingFrame(pOutBuffer, &FrameLen,
+					  sizeof(FRAME_BAR), &FrameBar,
+					  END_OF_ARGS);
 			//if (!(CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET)))
 			if (1)	// Now we always send BAR.
 			{
 				//MiniportMMRequestUnlock(pAd, 0, pOutBuffer, FrameLen);
-				MiniportMMRequest(pAd, (MGMT_USE_QUEUE_FLAG | MapUserPriorityToAccessCategory[TID]), pOutBuffer, FrameLen);
+				MiniportMMRequest(pAd,
+						  (MGMT_USE_QUEUE_FLAG |
+						   MapUserPriorityToAccessCategory
+						   [TID]), pOutBuffer,
+						  FrameLen);
 
 			}
 			MlmeFreeMemory(pAd, pOutBuffer);
@@ -541,43 +547,36 @@ VOID SendRefreshBAR(
 	}
 }
 
-VOID ActHeaderInit(
-    IN	PRTMP_ADAPTER	pAd,
-    IN OUT PHEADER_802_11 pHdr80211,
-    IN PUCHAR Addr1,
-    IN PUCHAR Addr2,
-    IN PUCHAR Addr3)
-{
-    NdisZeroMemory(pHdr80211, sizeof(HEADER_802_11));
-    pHdr80211->FC.Type = BTYPE_MGMT;
-    pHdr80211->FC.SubType = SUBTYPE_ACTION;
+VOID ActHeaderInit(IN PRTMP_ADAPTER pAd,
+		   IN OUT PHEADER_802_11 pHdr80211,
+		   IN PUCHAR Addr1, IN PUCHAR Addr2, IN PUCHAR Addr3)
+{
+	NdisZeroMemory(pHdr80211, sizeof(HEADER_802_11));
+	pHdr80211->FC.Type = BTYPE_MGMT;
+	pHdr80211->FC.SubType = SUBTYPE_ACTION;
 
-    COPY_MAC_ADDR(pHdr80211->Addr1, Addr1);
+	COPY_MAC_ADDR(pHdr80211->Addr1, Addr1);
 	COPY_MAC_ADDR(pHdr80211->Addr2, Addr2);
-    COPY_MAC_ADDR(pHdr80211->Addr3, Addr3);
+	COPY_MAC_ADDR(pHdr80211->Addr3, Addr3);
 }
 
-VOID BarHeaderInit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN OUT PFRAME_BAR pCntlBar,
-	IN PUCHAR pDA,
-	IN PUCHAR pSA)
+VOID BarHeaderInit(IN PRTMP_ADAPTER pAd,
+		   IN OUT PFRAME_BAR pCntlBar, IN PUCHAR pDA, IN PUCHAR pSA)
 {
 	NdisZeroMemory(pCntlBar, sizeof(FRAME_BAR));
 	pCntlBar->FC.Type = BTYPE_CNTL;
 	pCntlBar->FC.SubType = SUBTYPE_BLOCK_ACK_REQ;
-   	pCntlBar->BarControl.MTID = 0;
+	pCntlBar->BarControl.MTID = 0;
 	pCntlBar->BarControl.Compressed = 1;
 	pCntlBar->BarControl.ACKPolicy = 0;
 
-
-	pCntlBar->Duration = 16 + RTMPCalcDuration(pAd, RATE_1, sizeof(FRAME_BA));
+	pCntlBar->Duration =
+	    16 + RTMPCalcDuration(pAd, RATE_1, sizeof(FRAME_BA));
 
 	COPY_MAC_ADDR(pCntlBar->Addr1, pDA);
 	COPY_MAC_ADDR(pCntlBar->Addr2, pSA);
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -592,19 +591,14 @@ VOID BarHeaderInit(
 	Return	: None.
 	==========================================================================
  */
-VOID InsertActField(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN UINT8 Category,
-	IN UINT8 ActCode)
+VOID InsertActField(IN PRTMP_ADAPTER pAd,
+		    OUT PUCHAR pFrameBuf,
+		    OUT PULONG pFrameLen, IN UINT8 Category, IN UINT8 ActCode)
 {
 	ULONG TempLen;
 
-	MakeOutgoingFrame(	pFrameBuf,		&TempLen,
-						1,				&Category,
-						1,				&ActCode,
-						END_OF_ARGS);
+	MakeOutgoingFrame(pFrameBuf, &TempLen,
+			  1, &Category, 1, &ActCode, END_OF_ARGS);
 
 	*pFrameLen = *pFrameLen + TempLen;
 
--- a/drivers/staging/rt2860/common/ba_action.c
+++ b/drivers/staging/rt2860/common/ba_action.c
@@ -27,9 +27,7 @@
 
 #include "../rt_config.h"
 
-
-
-#define BA_ORI_INIT_SEQ		(pEntry->TxSeq[TID]) //1			// inital sequence number of BA session
+#define BA_ORI_INIT_SEQ		(pEntry->TxSeq[TID])	//1                        // inital sequence number of BA session
 
 #define ORI_SESSION_MAX_RETRY	8
 #define ORI_BA_SESSION_TIMEOUT	(2000)	// ms
@@ -40,29 +38,22 @@
 
 #define RESET_RCV_SEQ		(0xFFFF)
 
-static void ba_mpdu_blk_free(PRTMP_ADAPTER pAd, struct reordering_mpdu *mpdu_blk);
+static void ba_mpdu_blk_free(PRTMP_ADAPTER pAd,
+			     struct reordering_mpdu *mpdu_blk);
 
+BA_ORI_ENTRY *BATableAllocOriEntry(IN PRTMP_ADAPTER pAd, OUT USHORT * Idx);
 
-BA_ORI_ENTRY *BATableAllocOriEntry(
-								  IN  PRTMP_ADAPTER   pAd,
-								  OUT USHORT          *Idx);
-
-BA_REC_ENTRY *BATableAllocRecEntry(
-								  IN  PRTMP_ADAPTER   pAd,
-								  OUT USHORT          *Idx);
-
-VOID BAOriSessionSetupTimeout(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3);
-
-VOID BARecSessionIdleTimeout(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3);
+BA_REC_ENTRY *BATableAllocRecEntry(IN PRTMP_ADAPTER pAd, OUT USHORT * Idx);
 
+VOID BAOriSessionSetupTimeout(IN PVOID SystemSpecific1,
+			      IN PVOID FunctionContext,
+			      IN PVOID SystemSpecific2,
+			      IN PVOID SystemSpecific3);
+
+VOID BARecSessionIdleTimeout(IN PVOID SystemSpecific1,
+			     IN PVOID FunctionContext,
+			     IN PVOID SystemSpecific2,
+			     IN PVOID SystemSpecific3);
 
 BUILD_TIMER_FUNCTION(BAOriSessionSetupTimeout);
 BUILD_TIMER_FUNCTION(BARecSessionIdleTimeout);
@@ -70,91 +61,78 @@ BUILD_TIMER_FUNCTION(BARecSessionIdleTim
 #define ANNOUNCE_REORDERING_PACKET(_pAd, _mpdu_blk)	\
 			Announce_Reordering_Packet(_pAd, _mpdu_blk);
 
-VOID BA_MaxWinSizeReasign(
-	IN PRTMP_ADAPTER	pAd,
-	IN MAC_TABLE_ENTRY  *pEntryPeer,
-	OUT UCHAR			*pWinSize)
+VOID BA_MaxWinSizeReasign(IN PRTMP_ADAPTER pAd,
+			  IN MAC_TABLE_ENTRY * pEntryPeer, OUT UCHAR * pWinSize)
 {
 	UCHAR MaxSize;
 
-
-	if (pAd->MACVersion >= RALINK_2883_VERSION) // 3*3
+	if (pAd->MACVersion >= RALINK_2883_VERSION)	// 3*3
 	{
-		if (pAd->MACVersion >= RALINK_3070_VERSION)
-		{
-			if (pEntryPeer->WepStatus != Ndis802_11EncryptionDisabled)
-				MaxSize = 7; // for non-open mode
+		if (pAd->MACVersion >= RALINK_3070_VERSION) {
+			if (pEntryPeer->WepStatus !=
+			    Ndis802_11EncryptionDisabled)
+				MaxSize = 7;	// for non-open mode
 			else
 				MaxSize = 13;
-		}
-		else
+		} else
 			MaxSize = 31;
-	}
-	else if (pAd->MACVersion >= RALINK_2880E_VERSION) // 2880 e
+	} else if (pAd->MACVersion >= RALINK_2880E_VERSION)	// 2880 e
 	{
 		if (pEntryPeer->WepStatus != Ndis802_11EncryptionDisabled)
-			MaxSize = 7; // for non-open mode
+			MaxSize = 7;	// for non-open mode
 		else
 			MaxSize = 13;
-	}
-	else
+	} else
 		MaxSize = 7;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("ba> Win Size = %d, Max Size = %d\n",
-			*pWinSize, MaxSize));
+				  *pWinSize, MaxSize));
 
-	if ((*pWinSize) > MaxSize)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("ba> reassign max win size from %d to %d\n",
-				*pWinSize, MaxSize));
+	if ((*pWinSize) > MaxSize) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ba> reassign max win size from %d to %d\n",
+			  *pWinSize, MaxSize));
 
 		*pWinSize = MaxSize;
 	}
 }
 
-void Announce_Reordering_Packet(IN PRTMP_ADAPTER			pAd,
-								IN struct reordering_mpdu	*mpdu)
+void Announce_Reordering_Packet(IN PRTMP_ADAPTER pAd,
+				IN struct reordering_mpdu *mpdu)
 {
-	PNDIS_PACKET    pPacket;
+	PNDIS_PACKET pPacket;
 
 	pPacket = mpdu->pPacket;
 
-	if (mpdu->bAMSDU)
-	{
+	if (mpdu->bAMSDU) {
 		ASSERT(0);
 		BA_Reorder_AMSDU_Annnounce(pAd, pPacket);
-	}
-	else
-	{
+	} else {
 		//
 		// pass this 802.3 packet to upper layer or forward this packet to WM directly
 		//
 
-		ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pPacket, RTMP_GET_PACKET_IF(pPacket));
+		ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pPacket,
+						 RTMP_GET_PACKET_IF(pPacket));
 	}
 }
 
 /*
  * Insert a reordering mpdu into sorted linked list by sequence no.
  */
-BOOLEAN ba_reordering_mpdu_insertsorted(struct reordering_list *list, struct reordering_mpdu *mpdu)
+BOOLEAN ba_reordering_mpdu_insertsorted(struct reordering_list *list,
+					struct reordering_mpdu *mpdu)
 {
 
 	struct reordering_mpdu **ppScan = &list->next;
 
-	while (*ppScan != NULL)
-	{
-		if (SEQ_SMALLER((*ppScan)->Sequence, mpdu->Sequence, MAXSEQ))
-		{
+	while (*ppScan != NULL) {
+		if (SEQ_SMALLER((*ppScan)->Sequence, mpdu->Sequence, MAXSEQ)) {
 			ppScan = &(*ppScan)->next;
-		}
-		else if ((*ppScan)->Sequence == mpdu->Sequence)
-		{
+		} else if ((*ppScan)->Sequence == mpdu->Sequence) {
 			/* give up this duplicated frame */
-			return(FALSE);
-		}
-		else
-		{
+			return (FALSE);
+		} else {
 			/* find position */
 			break;
 		}
@@ -166,11 +144,11 @@ BOOLEAN ba_reordering_mpdu_insertsorted(
 	return TRUE;
 }
 
-
 /*
  * caller lock critical section if necessary
  */
-static inline void ba_enqueue(struct reordering_list *list, struct reordering_mpdu *mpdu_blk)
+static inline void ba_enqueue(struct reordering_list *list,
+			      struct reordering_mpdu *mpdu_blk)
 {
 	list->qlen++;
 	mpdu_blk->next = list->next;
@@ -180,47 +158,46 @@ static inline void ba_enqueue(struct reo
 /*
  * caller lock critical section if necessary
  */
-static inline struct reordering_mpdu * ba_dequeue(struct reordering_list *list)
+static inline struct reordering_mpdu *ba_dequeue(struct reordering_list *list)
 {
 	struct reordering_mpdu *mpdu_blk = NULL;
 
 	ASSERT(list);
 
-		if (list->qlen)
-		{
-			list->qlen--;
-			mpdu_blk = list->next;
-			if (mpdu_blk)
-			{
-				list->next = mpdu_blk->next;
-				mpdu_blk->next = NULL;
-			}
+	if (list->qlen) {
+		list->qlen--;
+		mpdu_blk = list->next;
+		if (mpdu_blk) {
+			list->next = mpdu_blk->next;
+			mpdu_blk->next = NULL;
 		}
+	}
 	return mpdu_blk;
 }
 
-
-static inline struct reordering_mpdu  *ba_reordering_mpdu_dequeue(struct reordering_list *list)
+static inline struct reordering_mpdu *ba_reordering_mpdu_dequeue(struct
+								 reordering_list
+								 *list)
 {
-	return(ba_dequeue(list));
+	return (ba_dequeue(list));
 }
 
-
-static inline struct reordering_mpdu  *ba_reordering_mpdu_probe(struct reordering_list *list)
-	{
+static inline struct reordering_mpdu *ba_reordering_mpdu_probe(struct
+							       reordering_list
+							       *list)
+{
 	ASSERT(list);
 
-		return(list->next);
-	}
-
+	return (list->next);
+}
 
 /*
  * free all resource for reordering mechanism
  */
 void ba_reordering_resource_release(PRTMP_ADAPTER pAd)
 {
-	BA_TABLE        *Tab;
-	PBA_REC_ENTRY   pBAEntry;
+	BA_TABLE *Tab;
+	PBA_REC_ENTRY pBAEntry;
 	struct reordering_mpdu *mpdu_blk;
 	int i;
 
@@ -228,15 +205,14 @@ void ba_reordering_resource_release(PRTM
 
 	/* I.  release all pending reordering packet */
 	NdisAcquireSpinLock(&pAd->BATabLock);
-	for (i = 0; i < MAX_LEN_OF_BA_REC_TABLE; i++)
-	{
+	for (i = 0; i < MAX_LEN_OF_BA_REC_TABLE; i++) {
 		pBAEntry = &Tab->BARecEntry[i];
-		if (pBAEntry->REC_BA_Status != Recipient_NONE)
-		{
-			while ((mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list)))
-			{
+		if (pBAEntry->REC_BA_Status != Recipient_NONE) {
+			while ((mpdu_blk =
+				ba_reordering_mpdu_dequeue(&pBAEntry->list))) {
 				ASSERT(mpdu_blk->pPacket);
-				RELEASE_NDIS_PACKET(pAd, mpdu_blk->pPacket, NDIS_STATUS_FAILURE);
+				RELEASE_NDIS_PACKET(pAd, mpdu_blk->pPacket,
+						    NDIS_STATUS_FAILURE);
 				ba_mpdu_blk_free(pAd, mpdu_blk);
 			}
 		}
@@ -250,15 +226,13 @@ void ba_reordering_resource_release(PRTM
 	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
 }
 
-
-
 /*
  * Allocate all resource for reordering mechanism
  */
 BOOLEAN ba_reordering_resource_init(PRTMP_ADAPTER pAd, int num)
 {
-	int     i;
-	PUCHAR  mem;
+	int i;
+	PUCHAR mem;
 	struct reordering_mpdu *mpdu_blk;
 	struct reordering_list *freelist;
 
@@ -270,24 +244,26 @@ BOOLEAN ba_reordering_resource_init(PRTM
 	freelist->next = NULL;
 	freelist->qlen = 0;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("Allocate %d memory for BA reordering\n", (UINT32)(num*sizeof(struct reordering_mpdu))));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Allocate %d memory for BA reordering\n",
+		  (UINT32) (num * sizeof(struct reordering_mpdu))));
 
 	/* allocate number of mpdu_blk memory */
-	os_alloc_mem(pAd, (PUCHAR *)&mem, (num*sizeof(struct reordering_mpdu)));
+	os_alloc_mem(pAd, (PUCHAR *) & mem,
+		     (num * sizeof(struct reordering_mpdu)));
 
 	pAd->mpdu_blk_pool.mem = mem;
 
-	if (mem == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("Can't Allocate Memory for BA Reordering\n"));
-		return(FALSE);
+	if (mem == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("Can't Allocate Memory for BA Reordering\n"));
+		return (FALSE);
 	}
 
 	/* build mpdu_blk free list */
-	for (i=0; i<num; i++)
-	{
+	for (i = 0; i < num; i++) {
 		/* get mpdu_blk */
-		mpdu_blk = (struct reordering_mpdu *) mem;
+		mpdu_blk = (struct reordering_mpdu *)mem;
 		/* initial mpdu_blk */
 		NdisZeroMemory(mpdu_blk, sizeof(struct reordering_mpdu));
 		/* next mpdu_blk */
@@ -296,7 +272,7 @@ BOOLEAN ba_reordering_resource_init(PRTM
 		ba_enqueue(freelist, mpdu_blk);
 	}
 
-	return(TRUE);
+	return (TRUE);
 }
 
 //static int blk_count=0; // sample take off, no use
@@ -307,9 +283,8 @@ static struct reordering_mpdu *ba_mpdu_b
 
 	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
 	mpdu_blk = ba_dequeue(&pAd->mpdu_blk_pool.freelist);
-	if (mpdu_blk)
-	{
-//		blk_count++;
+	if (mpdu_blk) {
+//              blk_count++;
 		/* reset mpdu_blk */
 		NdisZeroMemory(mpdu_blk, sizeof(struct reordering_mpdu));
 	}
@@ -317,43 +292,40 @@ static struct reordering_mpdu *ba_mpdu_b
 	return mpdu_blk;
 }
 
-static void ba_mpdu_blk_free(PRTMP_ADAPTER pAd, struct reordering_mpdu *mpdu_blk)
+static void ba_mpdu_blk_free(PRTMP_ADAPTER pAd,
+			     struct reordering_mpdu *mpdu_blk)
 {
 	ASSERT(mpdu_blk);
 
 	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
-//	blk_count--;
+//      blk_count--;
 	ba_enqueue(&pAd->mpdu_blk_pool.freelist, mpdu_blk);
 	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
 }
 
-
-static USHORT ba_indicate_reordering_mpdus_in_order(
-												   IN PRTMP_ADAPTER    pAd,
-												   IN PBA_REC_ENTRY    pBAEntry,
-												   IN USHORT           StartSeq)
+static USHORT ba_indicate_reordering_mpdus_in_order(IN PRTMP_ADAPTER pAd,
+						    IN PBA_REC_ENTRY pBAEntry,
+						    IN USHORT StartSeq)
 {
 	struct reordering_mpdu *mpdu_blk;
-	USHORT  LastIndSeq = RESET_RCV_SEQ;
+	USHORT LastIndSeq = RESET_RCV_SEQ;
 
 	NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
 
-	while ((mpdu_blk = ba_reordering_mpdu_probe(&pBAEntry->list)))
-		{
-			/* find in-order frame */
-		if (!SEQ_STEPONE(mpdu_blk->Sequence, StartSeq, MAXSEQ))
-			{
-				break;
-			}
-			/* dequeue in-order frame from reodering list */
-			mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list);
-			/* pass this frame up */
+	while ((mpdu_blk = ba_reordering_mpdu_probe(&pBAEntry->list))) {
+		/* find in-order frame */
+		if (!SEQ_STEPONE(mpdu_blk->Sequence, StartSeq, MAXSEQ)) {
+			break;
+		}
+		/* dequeue in-order frame from reodering list */
+		mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list);
+		/* pass this frame up */
 		ANNOUNCE_REORDERING_PACKET(pAd, mpdu_blk);
 		/* move to next sequence */
-			StartSeq = mpdu_blk->Sequence;
+		StartSeq = mpdu_blk->Sequence;
 		LastIndSeq = StartSeq;
 		/* free mpdu_blk */
-			ba_mpdu_blk_free(pAd, mpdu_blk);
+		ba_mpdu_blk_free(pAd, mpdu_blk);
 	}
 
 	NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
@@ -362,51 +334,44 @@ static USHORT ba_indicate_reordering_mpd
 	return LastIndSeq;
 }
 
-static void ba_indicate_reordering_mpdus_le_seq(
-											   IN PRTMP_ADAPTER    pAd,
-											   IN PBA_REC_ENTRY    pBAEntry,
-											   IN USHORT           Sequence)
+static void ba_indicate_reordering_mpdus_le_seq(IN PRTMP_ADAPTER pAd,
+						IN PBA_REC_ENTRY pBAEntry,
+						IN USHORT Sequence)
 {
 	struct reordering_mpdu *mpdu_blk;
 
 	NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
-	while ((mpdu_blk = ba_reordering_mpdu_probe(&pBAEntry->list)))
-		{
-			/* find in-order frame */
-		if ((mpdu_blk->Sequence == Sequence) || SEQ_SMALLER(mpdu_blk->Sequence, Sequence, MAXSEQ))
-		{
+	while ((mpdu_blk = ba_reordering_mpdu_probe(&pBAEntry->list))) {
+		/* find in-order frame */
+		if ((mpdu_blk->Sequence == Sequence)
+		    || SEQ_SMALLER(mpdu_blk->Sequence, Sequence, MAXSEQ)) {
 			/* dequeue in-order frame from reodering list */
 			mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list);
 			/* pass this frame up */
 			ANNOUNCE_REORDERING_PACKET(pAd, mpdu_blk);
 			/* free mpdu_blk */
 			ba_mpdu_blk_free(pAd, mpdu_blk);
+		} else {
+			break;
 		}
-		else
-			{
-				break;
-			}
 	}
 	NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
 }
 
-
-static void ba_refresh_reordering_mpdus(
-									   IN PRTMP_ADAPTER    pAd,
-									   PBA_REC_ENTRY       pBAEntry)
+static void ba_refresh_reordering_mpdus(IN PRTMP_ADAPTER pAd,
+					PBA_REC_ENTRY pBAEntry)
 {
 	struct reordering_mpdu *mpdu_blk;
 
 	NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
 
-			/* dequeue in-order frame from reodering list */
-	while ((mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list)))
-	{
-			/* pass this frame up */
+	/* dequeue in-order frame from reodering list */
+	while ((mpdu_blk = ba_reordering_mpdu_dequeue(&pBAEntry->list))) {
+		/* pass this frame up */
 		ANNOUNCE_REORDERING_PACKET(pAd, mpdu_blk);
 
 		pBAEntry->LastIndSeq = mpdu_blk->Sequence;
-			ba_mpdu_blk_free(pAd, mpdu_blk);
+		ba_mpdu_blk_free(pAd, mpdu_blk);
 
 		/* update last indicated sequence */
 	}
@@ -415,109 +380,106 @@ static void ba_refresh_reordering_mpdus(
 	NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
 }
 
-
 //static
-void ba_flush_reordering_timeout_mpdus(
-									IN PRTMP_ADAPTER    pAd,
-									IN PBA_REC_ENTRY    pBAEntry,
-									IN ULONG            Now32)
-
+void ba_flush_reordering_timeout_mpdus(IN PRTMP_ADAPTER pAd,
+				       IN PBA_REC_ENTRY pBAEntry,
+				       IN ULONG Now32)
 {
 	USHORT Sequence;
 
-//	if ((RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+REORDERING_PACKET_TIMEOUT)) &&
-//		 (pBAEntry->list.qlen > ((pBAEntry->BAWinSize*7)/8))) //||
-//		(RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(10*REORDERING_PACKET_TIMEOUT))) &&
-//		 (pBAEntry->list.qlen > (pBAEntry->BAWinSize/8)))
-	if (RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(MAX_REORDERING_PACKET_TIMEOUT/6)))
-		 &&(pBAEntry->list.qlen > 1)
-		)
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("timeout[%d] (%08lx-%08lx = %d > %d): %x, flush all!\n ", pBAEntry->list.qlen, Now32, (pBAEntry->LastIndSeqAtTimer),
-			   (int)((long) Now32 - (long)(pBAEntry->LastIndSeqAtTimer)), MAX_REORDERING_PACKET_TIMEOUT,
-			   pBAEntry->LastIndSeq));
+//      if ((RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+REORDERING_PACKET_TIMEOUT)) &&
+//               (pBAEntry->list.qlen > ((pBAEntry->BAWinSize*7)/8))) //||
+//              (RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(10*REORDERING_PACKET_TIMEOUT))) &&
+//               (pBAEntry->list.qlen > (pBAEntry->BAWinSize/8)))
+	if (RTMP_TIME_AFTER
+	    ((unsigned long)Now32,
+	     (unsigned long)(pBAEntry->LastIndSeqAtTimer +
+			     (MAX_REORDERING_PACKET_TIMEOUT / 6)))
+	    && (pBAEntry->list.qlen > 1)
+	    ) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("timeout[%d] (%08lx-%08lx = %d > %d): %x, flush all!\n ",
+			  pBAEntry->list.qlen, Now32,
+			  (pBAEntry->LastIndSeqAtTimer),
+			  (int)((long)Now32 -
+				(long)(pBAEntry->LastIndSeqAtTimer)),
+			  MAX_REORDERING_PACKET_TIMEOUT, pBAEntry->LastIndSeq));
 		ba_refresh_reordering_mpdus(pAd, pBAEntry);
 		pBAEntry->LastIndSeqAtTimer = Now32;
-	}
-	else
-	if (RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(REORDERING_PACKET_TIMEOUT)))
+	} else
+	    if (RTMP_TIME_AFTER
+		((unsigned long)Now32,
+		 (unsigned long)(pBAEntry->LastIndSeqAtTimer +
+				 (REORDERING_PACKET_TIMEOUT)))
 		&& (pBAEntry->list.qlen > 0)
-	   )
-		{
-    		//
+	    ) {
+		//
 		// force LastIndSeq to shift to LastIndSeq+1
-    		//
-    		Sequence = (pBAEntry->LastIndSeq+1) & MAXSEQ;
-    		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, Sequence);
-    		pBAEntry->LastIndSeqAtTimer = Now32;
+		//
+		Sequence = (pBAEntry->LastIndSeq + 1) & MAXSEQ;
+		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, Sequence);
+		pBAEntry->LastIndSeqAtTimer = Now32;
+		pBAEntry->LastIndSeq = Sequence;
+		//
+		// indicate in-order mpdus
+		//
+		Sequence =
+		    ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry,
+							  Sequence);
+		if (Sequence != RESET_RCV_SEQ) {
 			pBAEntry->LastIndSeq = Sequence;
-    		//
-    		// indicate in-order mpdus
-    		//
-    		Sequence = ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry, Sequence);
-    		if (Sequence != RESET_RCV_SEQ)
-    		{
-    			pBAEntry->LastIndSeq = Sequence;
-    		}
+		}
 
-		DBGPRINT(RT_DEBUG_OFF, ("%x, flush one!\n", pBAEntry->LastIndSeq));
+		DBGPRINT(RT_DEBUG_OFF,
+			 ("%x, flush one!\n", pBAEntry->LastIndSeq));
 
 	}
 }
 
-
 /*
  * generate ADDBA request to
  * set up BA agreement
  */
-VOID BAOriSessionSetUp(
-					  IN PRTMP_ADAPTER    pAd,
-					  IN MAC_TABLE_ENTRY  *pEntry,
-					  IN UCHAR            TID,
-					  IN USHORT           TimeOut,
-					  IN ULONG            DelayTime,
-					  IN BOOLEAN          isForced)
-
-{
-	//MLME_ADDBA_REQ_STRUCT	AddbaReq;
-	BA_ORI_ENTRY            *pBAEntry = NULL;
-	USHORT                  Idx;
-	BOOLEAN                 Cancelled;
+VOID BAOriSessionSetUp(IN PRTMP_ADAPTER pAd,
+		       IN MAC_TABLE_ENTRY * pEntry,
+		       IN UCHAR TID,
+		       IN USHORT TimeOut,
+		       IN ULONG DelayTime, IN BOOLEAN isForced)
+{
+	//MLME_ADDBA_REQ_STRUCT AddbaReq;
+	BA_ORI_ENTRY *pBAEntry = NULL;
+	USHORT Idx;
+	BOOLEAN Cancelled;
 
-	if ((pAd->CommonCfg.BACapability.field.AutoBA != TRUE)  &&  (isForced == FALSE))
+	if ((pAd->CommonCfg.BACapability.field.AutoBA != TRUE)
+	    && (isForced == FALSE))
 		return;
 
 	// if this entry is limited to use legacy tx mode, it doesn't generate BA.
 	if (RTMPStaFixedTxMode(pAd, pEntry) != FIXED_TXMODE_HT)
 		return;
 
-	if ((pEntry->BADeclineBitmap & (1<<TID)) && (isForced == FALSE))
-	{
+	if ((pEntry->BADeclineBitmap & (1 << TID)) && (isForced == FALSE)) {
 		// try again after 3 secs
 		DelayTime = 3000;
-//		DBGPRINT(RT_DEBUG_TRACE, ("DeCline BA from Peer\n"));
-//		return;
+//              DBGPRINT(RT_DEBUG_TRACE, ("DeCline BA from Peer\n"));
+//              return;
 	}
 
-
 	Idx = pEntry->BAOriWcidArray[TID];
-	if (Idx == 0)
-	{
+	if (Idx == 0) {
 		// allocate a BA session
 		pBAEntry = BATableAllocOriEntry(pAd, &Idx);
-		if (pBAEntry == NULL)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,("ADDBA - MlmeADDBAAction() allocate BA session failed \n"));
+		if (pBAEntry == NULL) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("ADDBA - MlmeADDBAAction() allocate BA session failed \n"));
 			return;
 		}
-	}
-	else
-	{
-		pBAEntry =&pAd->BATable.BAOriEntry[Idx];
+	} else {
+		pBAEntry = &pAd->BATable.BAOriEntry[Idx];
 	}
 
-	if (pBAEntry->ORI_BA_Status >= Originator_WaitRes)
-	{
+	if (pBAEntry->ORI_BA_Status >= Originator_WaitRes) {
 		return;
 	}
 
@@ -533,129 +495,125 @@ VOID BAOriSessionSetUp(
 	pBAEntry->TimeOutValue = TimeOut;
 	pBAEntry->pAdapter = pAd;
 
-	if (!(pEntry->TXBAbitmap & (1<<TID)))
-	{
-		RTMPInitTimer(pAd, &pBAEntry->ORIBATimer, GET_TIMER_FUNCTION(BAOriSessionSetupTimeout), pBAEntry, FALSE);
-	}
-	else
+	if (!(pEntry->TXBAbitmap & (1 << TID))) {
+		RTMPInitTimer(pAd, &pBAEntry->ORIBATimer,
+			      GET_TIMER_FUNCTION(BAOriSessionSetupTimeout),
+			      pBAEntry, FALSE);
+	} else
 		RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
 
 	// set timer to send ADDBA request
 	RTMPSetTimer(&pBAEntry->ORIBATimer, DelayTime);
 }
 
-VOID BAOriSessionAdd(
-			IN PRTMP_ADAPTER    pAd,
-					IN MAC_TABLE_ENTRY  *pEntry,
-			IN PFRAME_ADDBA_RSP pFrame)
-{
-	BA_ORI_ENTRY  *pBAEntry = NULL;
-	BOOLEAN       Cancelled;
-	UCHAR         TID;
-	USHORT        Idx;
-	PUCHAR          pOutBuffer2 = NULL;
-	NDIS_STATUS     NStatus;
-	ULONG           FrameLen;
-	FRAME_BAR       FrameBar;
+VOID BAOriSessionAdd(IN PRTMP_ADAPTER pAd,
+		     IN MAC_TABLE_ENTRY * pEntry, IN PFRAME_ADDBA_RSP pFrame)
+{
+	BA_ORI_ENTRY *pBAEntry = NULL;
+	BOOLEAN Cancelled;
+	UCHAR TID;
+	USHORT Idx;
+	PUCHAR pOutBuffer2 = NULL;
+	NDIS_STATUS NStatus;
+	ULONG FrameLen;
+	FRAME_BAR FrameBar;
 
 	TID = pFrame->BaParm.TID;
 	Idx = pEntry->BAOriWcidArray[TID];
-	pBAEntry =&pAd->BATable.BAOriEntry[Idx];
+	pBAEntry = &pAd->BATable.BAOriEntry[Idx];
 
 	// Start fill in parameters.
-	if ((Idx !=0) && (pBAEntry->TID == TID) && (pBAEntry->ORI_BA_Status == Originator_WaitRes))
-	{
-		pBAEntry->BAWinSize = min(pBAEntry->BAWinSize, ((UCHAR)pFrame->BaParm.BufSize));
+	if ((Idx != 0) && (pBAEntry->TID == TID)
+	    && (pBAEntry->ORI_BA_Status == Originator_WaitRes)) {
+		pBAEntry->BAWinSize =
+		    min(pBAEntry->BAWinSize, ((UCHAR) pFrame->BaParm.BufSize));
 		BA_MaxWinSizeReasign(pAd, pEntry, &pBAEntry->BAWinSize);
 
 		pBAEntry->TimeOutValue = pFrame->TimeOutValue;
 		pBAEntry->ORI_BA_Status = Originator_Done;
-		pAd->BATable.numDoneOriginator ++;
+		pAd->BATable.numDoneOriginator++;
 
 		// reset sequence number
 		pBAEntry->Sequence = BA_ORI_INIT_SEQ;
 		// Set Bitmap flag.
-		pEntry->TXBAbitmap |= (1<<TID);
-				RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
+		pEntry->TXBAbitmap |= (1 << TID);
+		RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
 
 		pBAEntry->ORIBATimer.TimerValue = 0;	//pFrame->TimeOutValue;
 
-		DBGPRINT(RT_DEBUG_TRACE,("%s : TXBAbitmap = %x, BAWinSize = %d, TimeOut = %ld\n", __func__, pEntry->TXBAbitmap,
-								 pBAEntry->BAWinSize, pBAEntry->ORIBATimer.TimerValue));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s : TXBAbitmap = %x, BAWinSize = %d, TimeOut = %ld\n",
+			  __func__, pEntry->TXBAbitmap, pBAEntry->BAWinSize,
+			  pBAEntry->ORIBATimer.TimerValue));
 
 		// SEND BAR ;
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);  //Get an unused nonpaged memory
-		if (NStatus != NDIS_STATUS_SUCCESS)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,("BA - BAOriSessionAdd() allocate memory failed \n"));
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);	//Get an unused nonpaged memory
+		if (NStatus != NDIS_STATUS_SUCCESS) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BA - BAOriSessionAdd() allocate memory failed \n"));
 			return;
 		}
 
-		BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pBAEntry->Wcid].Addr, pAd->CurrentAddress);
+		BarHeaderInit(pAd, &FrameBar,
+			      pAd->MacTab.Content[pBAEntry->Wcid].Addr,
+			      pAd->CurrentAddress);
 
 		FrameBar.StartingSeq.field.FragNum = 0;	// make sure sequence not clear in DEL function.
-		FrameBar.StartingSeq.field.StartSeq = pBAEntry->Sequence; // make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.TID = pBAEntry->TID; // make sure sequence not clear in DEL funciton.
-		MakeOutgoingFrame(pOutBuffer2,              &FrameLen,
-						  sizeof(FRAME_BAR),      &FrameBar,
-					  END_OF_ARGS);
+		FrameBar.StartingSeq.field.StartSeq = pBAEntry->Sequence;	// make sure sequence not clear in DEL funciton.
+		FrameBar.BarControl.TID = pBAEntry->TID;	// make sure sequence not clear in DEL funciton.
+		MakeOutgoingFrame(pOutBuffer2, &FrameLen,
+				  sizeof(FRAME_BAR), &FrameBar, END_OF_ARGS);
 		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer2, FrameLen);
 		MlmeFreeMemory(pAd, pOutBuffer2);
 
-
 		if (pBAEntry->ORIBATimer.TimerValue)
-			RTMPSetTimer(&pBAEntry->ORIBATimer, pBAEntry->ORIBATimer.TimerValue); // in mSec
+			RTMPSetTimer(&pBAEntry->ORIBATimer, pBAEntry->ORIBATimer.TimerValue);	// in mSec
 	}
 }
 
-BOOLEAN BARecSessionAdd(
-					   IN PRTMP_ADAPTER    pAd,
-					   IN MAC_TABLE_ENTRY  *pEntry,
-					   IN PFRAME_ADDBA_REQ pFrame)
+BOOLEAN BARecSessionAdd(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN PFRAME_ADDBA_REQ pFrame)
 {
-	BA_REC_ENTRY            *pBAEntry = NULL;
-	BOOLEAN                 Status = TRUE;
-	BOOLEAN                 Cancelled;
-	USHORT                  Idx;
-	UCHAR                   TID;
-	UCHAR                   BAWinSize;
+	BA_REC_ENTRY *pBAEntry = NULL;
+	BOOLEAN Status = TRUE;
+	BOOLEAN Cancelled;
+	USHORT Idx;
+	UCHAR TID;
+	UCHAR BAWinSize;
 	//UINT32                  Value;
 	//UINT                    offset;
 
-
 	ASSERT(pEntry);
 
 	// find TID
 	TID = pFrame->BaParm.TID;
 
-	BAWinSize = min(((UCHAR)pFrame->BaParm.BufSize), (UCHAR)pAd->CommonCfg.BACapability.field.RxBAWinLimit);
+	BAWinSize =
+	    min(((UCHAR) pFrame->BaParm.BufSize),
+		(UCHAR) pAd->CommonCfg.BACapability.field.RxBAWinLimit);
 
 	// Intel patch
-	if (BAWinSize == 0)
-	{
+	if (BAWinSize == 0) {
 		BAWinSize = 64;
 	}
 
 	Idx = pEntry->BARecWcidArray[TID];
 
-
-	if (Idx == 0)
-	{
+	if (Idx == 0) {
 		pBAEntry = BATableAllocRecEntry(pAd, &Idx);
-	}
-	else
-	{
+	} else {
 		pBAEntry = &pAd->BATable.BARecEntry[Idx];
 		// flush all pending reordering mpdus
 		ba_refresh_reordering_mpdus(pAd, pBAEntry);
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("%s(%ld): Idx = %d, BAWinSize(req %d) = %d\n", __func__, pAd->BATable.numAsRecipient, Idx,
-							 pFrame->BaParm.BufSize, BAWinSize));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("%s(%ld): Idx = %d, BAWinSize(req %d) = %d\n", __func__,
+		  pAd->BATable.numAsRecipient, Idx, pFrame->BaParm.BufSize,
+		  BAWinSize));
 
 	// Start fill in parameters.
-	if (pBAEntry != NULL)
-	{
+	if (pBAEntry != NULL) {
 		ASSERT(pBAEntry->list.qlen == 0);
 
 		pBAEntry->REC_BA_Status = Recipient_HandleRes;
@@ -665,64 +623,60 @@ BOOLEAN BARecSessionAdd(
 		pBAEntry->TimeOutValue = pFrame->TimeOutValue;
 		pBAEntry->REC_BA_Status = Recipient_Accept;
 		// initial sequence number
-		pBAEntry->LastIndSeq = RESET_RCV_SEQ; //pFrame->BaStartSeq.field.StartSeq;
+		pBAEntry->LastIndSeq = RESET_RCV_SEQ;	//pFrame->BaStartSeq.field.StartSeq;
 
-		DBGPRINT(RT_DEBUG_OFF, ("Start Seq = %08x\n",  pFrame->BaStartSeq.field.StartSeq));
+		DBGPRINT(RT_DEBUG_OFF,
+			 ("Start Seq = %08x\n",
+			  pFrame->BaStartSeq.field.StartSeq));
 
-		if (pEntry->RXBAbitmap & (1<<TID))
-		{
+		if (pEntry->RXBAbitmap & (1 << TID)) {
 			RTMPCancelTimer(&pBAEntry->RECBATimer, &Cancelled);
-		}
-		else
-		{
-			RTMPInitTimer(pAd, &pBAEntry->RECBATimer, GET_TIMER_FUNCTION(BARecSessionIdleTimeout), pBAEntry, TRUE);
+		} else {
+			RTMPInitTimer(pAd, &pBAEntry->RECBATimer,
+				      GET_TIMER_FUNCTION
+				      (BARecSessionIdleTimeout), pBAEntry,
+				      TRUE);
 		}
 
 		// Set Bitmap flag.
-		pEntry->RXBAbitmap |= (1<<TID);
+		pEntry->RXBAbitmap |= (1 << TID);
 		pEntry->BARecWcidArray[TID] = Idx;
 
-		pEntry->BADeclineBitmap &= ~(1<<TID);
+		pEntry->BADeclineBitmap &= ~(1 << TID);
 
 		// Set BA session mask in WCID table.
 		RTMP_ADD_BA_SESSION_TO_ASIC(pAd, pEntry->Aid, TID);
 
-		DBGPRINT(RT_DEBUG_TRACE,("MACEntry[%d]RXBAbitmap = 0x%x. BARecWcidArray=%d\n",
-				pEntry->Aid, pEntry->RXBAbitmap, pEntry->BARecWcidArray[TID]));
-	}
-	else
-	{
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MACEntry[%d]RXBAbitmap = 0x%x. BARecWcidArray=%d\n",
+			  pEntry->Aid, pEntry->RXBAbitmap,
+			  pEntry->BARecWcidArray[TID]));
+	} else {
 		Status = FALSE;
-		DBGPRINT(RT_DEBUG_TRACE,("Can't Accept ADDBA for %02x:%02x:%02x:%02x:%02x:%02x TID = %d\n",
-				PRINT_MAC(pEntry->Addr), TID));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Can't Accept ADDBA for %02x:%02x:%02x:%02x:%02x:%02x TID = %d\n",
+			  PRINT_MAC(pEntry->Addr), TID));
 	}
-	return(Status);
+	return (Status);
 }
 
-
-BA_REC_ENTRY *BATableAllocRecEntry(
-								  IN  PRTMP_ADAPTER   pAd,
-								  OUT USHORT          *Idx)
+BA_REC_ENTRY *BATableAllocRecEntry(IN PRTMP_ADAPTER pAd, OUT USHORT * Idx)
 {
-	int             i;
-	BA_REC_ENTRY    *pBAEntry = NULL;
-
+	int i;
+	BA_REC_ENTRY *pBAEntry = NULL;
 
 	NdisAcquireSpinLock(&pAd->BATabLock);
 
-	if (pAd->BATable.numAsRecipient >= MAX_BARECI_SESSION)
-	{
+	if (pAd->BATable.numAsRecipient >= MAX_BARECI_SESSION) {
 		DBGPRINT(RT_DEBUG_OFF, ("BA Recipeint Session (%ld) > %d\n",
-							pAd->BATable.numAsRecipient, MAX_BARECI_SESSION));
+					pAd->BATable.numAsRecipient,
+					MAX_BARECI_SESSION));
 		goto done;
 	}
-
 	// reserve idx 0 to identify BAWcidArray[TID] as empty
-	for (i=1; i < MAX_LEN_OF_BA_REC_TABLE; i++)
-	{
-		pBAEntry =&pAd->BATable.BARecEntry[i];
-		if ((pBAEntry->REC_BA_Status == Recipient_NONE))
-		{
+	for (i = 1; i < MAX_LEN_OF_BA_REC_TABLE; i++) {
+		pBAEntry = &pAd->BATable.BARecEntry[i];
+		if ((pBAEntry->REC_BA_Status == Recipient_NONE)) {
 			// get one
 			pAd->BATable.numAsRecipient++;
 			pBAEntry->REC_BA_Status = Recipient_USED;
@@ -736,26 +690,20 @@ done:
 	return pBAEntry;
 }
 
-BA_ORI_ENTRY *BATableAllocOriEntry(
-								  IN  PRTMP_ADAPTER   pAd,
-								  OUT USHORT          *Idx)
+BA_ORI_ENTRY *BATableAllocOriEntry(IN PRTMP_ADAPTER pAd, OUT USHORT * Idx)
 {
-	int             i;
-	BA_ORI_ENTRY    *pBAEntry = NULL;
+	int i;
+	BA_ORI_ENTRY *pBAEntry = NULL;
 
 	NdisAcquireSpinLock(&pAd->BATabLock);
 
-	if (pAd->BATable.numAsOriginator >= (MAX_LEN_OF_BA_ORI_TABLE))
-	{
+	if (pAd->BATable.numAsOriginator >= (MAX_LEN_OF_BA_ORI_TABLE)) {
 		goto done;
 	}
-
 	// reserve idx 0 to identify BAWcidArray[TID] as empty
-	for (i=1; i<MAX_LEN_OF_BA_ORI_TABLE; i++)
-	{
-		pBAEntry =&pAd->BATable.BAOriEntry[i];
-		if ((pBAEntry->ORI_BA_Status == Originator_NONE))
-		{
+	for (i = 1; i < MAX_LEN_OF_BA_ORI_TABLE; i++) {
+		pBAEntry = &pAd->BATable.BAOriEntry[i];
+		if ((pBAEntry->ORI_BA_Status == Originator_NONE)) {
 			// get one
 			pAd->BATable.numAsOriginator++;
 			pBAEntry->ORI_BA_Status = Originator_USED;
@@ -770,32 +718,27 @@ done:
 	return pBAEntry;
 }
 
-
-VOID BATableFreeOriEntry(
-						IN  PRTMP_ADAPTER   pAd,
-						IN  ULONG           Idx)
+VOID BATableFreeOriEntry(IN PRTMP_ADAPTER pAd, IN ULONG Idx)
 {
-	BA_ORI_ENTRY    *pBAEntry = NULL;
+	BA_ORI_ENTRY *pBAEntry = NULL;
 	MAC_TABLE_ENTRY *pEntry;
 
-
 	if ((Idx == 0) || (Idx >= MAX_LEN_OF_BA_ORI_TABLE))
 		return;
 
-	pBAEntry =&pAd->BATable.BAOriEntry[Idx];
+	pBAEntry = &pAd->BATable.BAOriEntry[Idx];
 
-	if (pBAEntry->ORI_BA_Status != Originator_NONE)
-	{
+	if (pBAEntry->ORI_BA_Status != Originator_NONE) {
 		pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
 		pEntry->BAOriWcidArray[pBAEntry->TID] = 0;
 
-
 		NdisAcquireSpinLock(&pAd->BATabLock);
-		if (pBAEntry->ORI_BA_Status == Originator_Done)
-		{
+		if (pBAEntry->ORI_BA_Status == Originator_Done) {
 			pAd->BATable.numDoneOriginator -= 1;
-		 	pEntry->TXBAbitmap &= (~(1<<(pBAEntry->TID) ));
-			DBGPRINT(RT_DEBUG_TRACE, ("BATableFreeOriEntry numAsOriginator= %ld\n", pAd->BATable.numAsRecipient));
+			pEntry->TXBAbitmap &= (~(1 << (pBAEntry->TID)));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BATableFreeOriEntry numAsOriginator= %ld\n",
+				  pAd->BATable.numAsRecipient));
 			// Erase Bitmap flag.
 		}
 
@@ -809,22 +752,17 @@ VOID BATableFreeOriEntry(
 	}
 }
 
-
-VOID BATableFreeRecEntry(
-						IN  PRTMP_ADAPTER   pAd,
-						IN  ULONG           Idx)
+VOID BATableFreeRecEntry(IN PRTMP_ADAPTER pAd, IN ULONG Idx)
 {
-	BA_REC_ENTRY    *pBAEntry = NULL;
+	BA_REC_ENTRY *pBAEntry = NULL;
 	MAC_TABLE_ENTRY *pEntry;
 
-
 	if ((Idx == 0) || (Idx >= MAX_LEN_OF_BA_REC_TABLE))
 		return;
 
-	pBAEntry =&pAd->BATable.BARecEntry[Idx];
+	pBAEntry = &pAd->BATable.BARecEntry[Idx];
 
-	if (pBAEntry->REC_BA_Status != Recipient_NONE)
-	{
+	if (pBAEntry->REC_BA_Status != Recipient_NONE) {
 		pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
 		pEntry->BARecWcidArray[pBAEntry->TID] = 0;
 
@@ -839,111 +777,105 @@ VOID BATableFreeRecEntry(
 	}
 }
 
+VOID BAOriSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
+			  IN UCHAR Wcid,
+			  IN UCHAR TID,
+			  IN BOOLEAN bPassive, IN BOOLEAN bForceSend)
+{
+	ULONG Idx = 0;
+	BA_ORI_ENTRY *pBAEntry;
+	BOOLEAN Cancelled;
 
-VOID BAOriSessionTearDown(
-						 IN OUT  PRTMP_ADAPTER   pAd,
-						 IN      UCHAR           Wcid,
-						 IN      UCHAR           TID,
-						 IN      BOOLEAN         bPassive,
-						 IN      BOOLEAN         bForceSend)
-{
-	ULONG           Idx = 0;
-	BA_ORI_ENTRY    *pBAEntry;
-	BOOLEAN         Cancelled;
-
-	if (Wcid >= MAX_LEN_OF_MAC_TABLE)
-	{
+	if (Wcid >= MAX_LEN_OF_MAC_TABLE) {
 		return;
 	}
-
 	//
 	// Locate corresponding BA Originator Entry in BA Table with the (pAddr,TID).
 	//
 	Idx = pAd->MacTab.Content[Wcid].BAOriWcidArray[TID];
-	if ((Idx == 0) || (Idx >= MAX_LEN_OF_BA_ORI_TABLE))
-	{
-		if (bForceSend == TRUE)
-		{
+	if ((Idx == 0) || (Idx >= MAX_LEN_OF_BA_ORI_TABLE)) {
+		if (bForceSend == TRUE) {
 			// force send specified TID DelBA
-			MLME_DELBA_REQ_STRUCT   DelbaReq;
-			MLME_QUEUE_ELEM *Elem = (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM), MEM_ALLOC_FLAG);
-			if (Elem != NULL)
-			{
-			NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
-			NdisZeroMemory(Elem, sizeof(MLME_QUEUE_ELEM));
-
-			COPY_MAC_ADDR(DelbaReq.Addr, pAd->MacTab.Content[Wcid].Addr);
-			DelbaReq.Wcid = Wcid;
-			DelbaReq.TID = TID;
-			DelbaReq.Initiator = ORIGINATOR;
-			Elem->MsgLen  = sizeof(DelbaReq);
-			NdisMoveMemory(Elem->Msg, &DelbaReq, sizeof(DelbaReq));
-			MlmeDELBAAction(pAd, Elem);
-			kfree(Elem);
-			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_ERROR, ("%s(bForceSend):alloc memory failed!\n", __func__));
+			MLME_DELBA_REQ_STRUCT DelbaReq;
+			MLME_QUEUE_ELEM *Elem =
+			    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
+							MEM_ALLOC_FLAG);
+			if (Elem != NULL) {
+				NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
+				NdisZeroMemory(Elem, sizeof(MLME_QUEUE_ELEM));
+
+				COPY_MAC_ADDR(DelbaReq.Addr,
+					      pAd->MacTab.Content[Wcid].Addr);
+				DelbaReq.Wcid = Wcid;
+				DelbaReq.TID = TID;
+				DelbaReq.Initiator = ORIGINATOR;
+				Elem->MsgLen = sizeof(DelbaReq);
+				NdisMoveMemory(Elem->Msg, &DelbaReq,
+					       sizeof(DelbaReq));
+				MlmeDELBAAction(pAd, Elem);
+				kfree(Elem);
+			} else {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("%s(bForceSend):alloc memory failed!\n",
+					  __func__));
 			}
 		}
 
 		return;
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("%s===>Wcid=%d.TID=%d \n", __func__, Wcid, TID));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("%s===>Wcid=%d.TID=%d \n", __func__, Wcid, TID));
 
 	pBAEntry = &pAd->BATable.BAOriEntry[Idx];
-	DBGPRINT(RT_DEBUG_TRACE,("\t===>Idx = %ld, Wcid=%d.TID=%d, ORI_BA_Status = %d \n", Idx, Wcid, TID, pBAEntry->ORI_BA_Status));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("\t===>Idx = %ld, Wcid=%d.TID=%d, ORI_BA_Status = %d \n", Idx,
+		  Wcid, TID, pBAEntry->ORI_BA_Status));
 	//
 	// Prepare DelBA action frame and send to the peer.
 	//
-	if ((bPassive == FALSE) && (TID == pBAEntry->TID) && (pBAEntry->ORI_BA_Status == Originator_Done))
-	{
-		MLME_DELBA_REQ_STRUCT   DelbaReq;
-		MLME_QUEUE_ELEM *Elem = (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM), MEM_ALLOC_FLAG);
-		if (Elem != NULL)
-		{
-		NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
-		NdisZeroMemory(Elem, sizeof(MLME_QUEUE_ELEM));
+	if ((bPassive == FALSE) && (TID == pBAEntry->TID)
+	    && (pBAEntry->ORI_BA_Status == Originator_Done)) {
+		MLME_DELBA_REQ_STRUCT DelbaReq;
+		MLME_QUEUE_ELEM *Elem =
+		    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
+						MEM_ALLOC_FLAG);
+		if (Elem != NULL) {
+			NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
+			NdisZeroMemory(Elem, sizeof(MLME_QUEUE_ELEM));
 
-		COPY_MAC_ADDR(DelbaReq.Addr, pAd->MacTab.Content[Wcid].Addr);
-		DelbaReq.Wcid = Wcid;
-		DelbaReq.TID = pBAEntry->TID;
-		DelbaReq.Initiator = ORIGINATOR;
-		Elem->MsgLen  = sizeof(DelbaReq);
-		NdisMoveMemory(Elem->Msg, &DelbaReq, sizeof(DelbaReq));
-		MlmeDELBAAction(pAd, Elem);
-		kfree(Elem);
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("%s():alloc memory failed!\n", __func__));
+			COPY_MAC_ADDR(DelbaReq.Addr,
+				      pAd->MacTab.Content[Wcid].Addr);
+			DelbaReq.Wcid = Wcid;
+			DelbaReq.TID = pBAEntry->TID;
+			DelbaReq.Initiator = ORIGINATOR;
+			Elem->MsgLen = sizeof(DelbaReq);
+			NdisMoveMemory(Elem->Msg, &DelbaReq, sizeof(DelbaReq));
+			MlmeDELBAAction(pAd, Elem);
+			kfree(Elem);
+		} else {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s():alloc memory failed!\n", __func__));
 			return;
 		}
 	}
 	RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
 	BATableFreeOriEntry(pAd, Idx);
 
-	if (bPassive)
-	{
+	if (bPassive) {
 		//BAOriSessionSetUp(pAd, &pAd->MacTab.Content[Wcid], TID, 0, 10000, TRUE);
 	}
 }
 
-VOID BARecSessionTearDown(
-						 IN OUT  PRTMP_ADAPTER   pAd,
-						 IN      UCHAR           Wcid,
-						 IN      UCHAR           TID,
-						 IN      BOOLEAN         bPassive)
+VOID BARecSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
+			  IN UCHAR Wcid, IN UCHAR TID, IN BOOLEAN bPassive)
 {
-	ULONG           Idx = 0;
-	BA_REC_ENTRY    *pBAEntry;
+	ULONG Idx = 0;
+	BA_REC_ENTRY *pBAEntry;
 
-	if (Wcid >= MAX_LEN_OF_MAC_TABLE)
-	{
+	if (Wcid >= MAX_LEN_OF_MAC_TABLE) {
 		return;
 	}
-
 	//
 	//  Locate corresponding BA Originator Entry in BA Table with the (pAddr,TID).
 	//
@@ -951,18 +883,20 @@ VOID BARecSessionTearDown(
 	if (Idx == 0)
 		return;
 
-	DBGPRINT(RT_DEBUG_TRACE,("%s===>Wcid=%d.TID=%d \n", __func__, Wcid, TID));
-
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("%s===>Wcid=%d.TID=%d \n", __func__, Wcid, TID));
 
 	pBAEntry = &pAd->BATable.BARecEntry[Idx];
-	DBGPRINT(RT_DEBUG_TRACE,("\t===>Idx = %ld, Wcid=%d.TID=%d, REC_BA_Status = %d \n", Idx, Wcid, TID, pBAEntry->REC_BA_Status));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("\t===>Idx = %ld, Wcid=%d.TID=%d, REC_BA_Status = %d \n", Idx,
+		  Wcid, TID, pBAEntry->REC_BA_Status));
 	//
 	// Prepare DelBA action frame and send to the peer.
 	//
-	if ((TID == pBAEntry->TID) && (pBAEntry->REC_BA_Status == Recipient_Accept))
-	{
-		MLME_DELBA_REQ_STRUCT   DelbaReq;
-		BOOLEAN 				Cancelled;
+	if ((TID == pBAEntry->TID)
+	    && (pBAEntry->REC_BA_Status == Recipient_Accept)) {
+		MLME_DELBA_REQ_STRUCT DelbaReq;
+		BOOLEAN Cancelled;
 		//ULONG   offset;
 		//UINT32  VALUE;
 
@@ -971,31 +905,32 @@ VOID BARecSessionTearDown(
 		//
 		// 1. Send DELBA Action Frame
 		//
-		if (bPassive == FALSE)
-		{
-			MLME_QUEUE_ELEM *Elem = (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM), MEM_ALLOC_FLAG);
-			if (Elem != NULL)
-			{
-			NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
-			NdisZeroMemory(Elem, sizeof(MLME_QUEUE_ELEM));
-
-			COPY_MAC_ADDR(DelbaReq.Addr, pAd->MacTab.Content[Wcid].Addr);
-			DelbaReq.Wcid = Wcid;
-			DelbaReq.TID = TID;
-			DelbaReq.Initiator = RECIPIENT;
-			Elem->MsgLen  = sizeof(DelbaReq);
-			NdisMoveMemory(Elem->Msg, &DelbaReq, sizeof(DelbaReq));
-			MlmeDELBAAction(pAd, Elem);
-			kfree(Elem);
-			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_ERROR, ("%s():alloc memory failed!\n", __func__));
+		if (bPassive == FALSE) {
+			MLME_QUEUE_ELEM *Elem =
+			    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
+							MEM_ALLOC_FLAG);
+			if (Elem != NULL) {
+				NdisZeroMemory(&DelbaReq, sizeof(DelbaReq));
+				NdisZeroMemory(Elem, sizeof(MLME_QUEUE_ELEM));
+
+				COPY_MAC_ADDR(DelbaReq.Addr,
+					      pAd->MacTab.Content[Wcid].Addr);
+				DelbaReq.Wcid = Wcid;
+				DelbaReq.TID = TID;
+				DelbaReq.Initiator = RECIPIENT;
+				Elem->MsgLen = sizeof(DelbaReq);
+				NdisMoveMemory(Elem->Msg, &DelbaReq,
+					       sizeof(DelbaReq));
+				MlmeDELBAAction(pAd, Elem);
+				kfree(Elem);
+			} else {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("%s():alloc memory failed!\n",
+					  __func__));
 				return;
 			}
 		}
 
-
 		//
 		// 2. Free resource of BA session
 		//
@@ -1008,7 +943,8 @@ VOID BARecSessionTearDown(
 		pBAEntry->LastIndSeq = RESET_RCV_SEQ;
 		pBAEntry->BAWinSize = 0;
 		// Erase Bitmap flag at software mactable
-		pAd->MacTab.Content[Wcid].RXBAbitmap &= (~(1<<(pBAEntry->TID)));
+		pAd->MacTab.Content[Wcid].RXBAbitmap &=
+		    (~(1 << (pBAEntry->TID)));
 		pAd->MacTab.Content[Wcid].BARecWcidArray[TID] = 0;
 
 		RTMP_DEL_BA_SESSION_FROM_ASIC(pAd, Wcid, TID);
@@ -1020,20 +956,16 @@ VOID BARecSessionTearDown(
 	BATableFreeRecEntry(pAd, Idx);
 }
 
-VOID BASessionTearDownALL(
-						 IN OUT  PRTMP_ADAPTER pAd,
-						 IN      UCHAR Wcid)
+VOID BASessionTearDownALL(IN OUT PRTMP_ADAPTER pAd, IN UCHAR Wcid)
 {
 	int i;
 
-	for (i=0; i<NUM_OF_TID; i++)
-	{
+	for (i = 0; i < NUM_OF_TID; i++) {
 		BAOriSessionTearDown(pAd, Wcid, i, FALSE, FALSE);
 		BARecSessionTearDown(pAd, Wcid, i, FALSE);
 	}
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1048,15 +980,14 @@ VOID BASessionTearDownALL(
 				FALSE , then continue indicaterx at this moment.
 	==========================================================================
  */
-VOID BAOriSessionSetupTimeout(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3)
+VOID BAOriSessionSetupTimeout(IN PVOID SystemSpecific1,
+			      IN PVOID FunctionContext,
+			      IN PVOID SystemSpecific2,
+			      IN PVOID SystemSpecific3)
 {
-	BA_ORI_ENTRY    *pBAEntry = (BA_ORI_ENTRY *)FunctionContext;
+	BA_ORI_ENTRY *pBAEntry = (BA_ORI_ENTRY *) FunctionContext;
 	MAC_TABLE_ENTRY *pEntry;
-	PRTMP_ADAPTER   pAd;
+	PRTMP_ADAPTER pAd;
 
 	if (pBAEntry == NULL)
 		return;
@@ -1064,34 +995,35 @@ VOID BAOriSessionSetupTimeout(
 	pAd = pBAEntry->pAdapter;
 
 	{
-	// Do nothing if monitor mode is on
-	if (MONITOR_ON(pAd))
-		return;
+		// Do nothing if monitor mode is on
+		if (MONITOR_ON(pAd))
+			return;
 	}
 
-
 	pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
 
-	if ((pBAEntry->ORI_BA_Status == Originator_WaitRes) && (pBAEntry->Token < ORI_SESSION_MAX_RETRY))
-	{
-		MLME_ADDBA_REQ_STRUCT    AddbaReq;
+	if ((pBAEntry->ORI_BA_Status == Originator_WaitRes)
+	    && (pBAEntry->Token < ORI_SESSION_MAX_RETRY)) {
+		MLME_ADDBA_REQ_STRUCT AddbaReq;
 
 		NdisZeroMemory(&AddbaReq, sizeof(AddbaReq));
 		COPY_MAC_ADDR(AddbaReq.pAddr, pEntry->Addr);
-		AddbaReq.Wcid = (UCHAR)(pEntry->Aid);
+		AddbaReq.Wcid = (UCHAR) (pEntry->Aid);
 		AddbaReq.TID = pBAEntry->TID;
-		AddbaReq.BaBufSize = pAd->CommonCfg.BACapability.field.RxBAWinLimit;
+		AddbaReq.BaBufSize =
+		    pAd->CommonCfg.BACapability.field.RxBAWinLimit;
 		AddbaReq.TimeOutValue = 0;
 		AddbaReq.Token = pBAEntry->Token;
-		MlmeEnqueue(pAd, ACTION_STATE_MACHINE, MT2_MLME_ADD_BA_CATE, sizeof(MLME_ADDBA_REQ_STRUCT), (PVOID)&AddbaReq);
+		MlmeEnqueue(pAd, ACTION_STATE_MACHINE, MT2_MLME_ADD_BA_CATE,
+			    sizeof(MLME_ADDBA_REQ_STRUCT), (PVOID) & AddbaReq);
 		RTMP_MLME_HANDLER(pAd);
-		DBGPRINT(RT_DEBUG_TRACE,("BA Ori Session Timeout(%d) : Send ADD BA again\n", pBAEntry->Token));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("BA Ori Session Timeout(%d) : Send ADD BA again\n",
+			  pBAEntry->Token));
 
 		pBAEntry->Token++;
 		RTMPSetTimer(&pBAEntry->ORIBATimer, ORI_BA_SESSION_TIMEOUT);
-	}
-	else
-	{
+	} else {
 		BATableFreeOriEntry(pAd, pEntry->BAOriWcidArray[pBAEntry->TID]);
 	}
 }
@@ -1110,54 +1042,51 @@ VOID BAOriSessionSetupTimeout(
 				FALSE , then continue indicaterx at this moment.
 	==========================================================================
  */
-VOID BARecSessionIdleTimeout(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3)
+VOID BARecSessionIdleTimeout(IN PVOID SystemSpecific1,
+			     IN PVOID FunctionContext,
+			     IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
 
-	BA_REC_ENTRY    *pBAEntry = (BA_REC_ENTRY *)FunctionContext;
-	PRTMP_ADAPTER   pAd;
-	ULONG           Now32;
+	BA_REC_ENTRY *pBAEntry = (BA_REC_ENTRY *) FunctionContext;
+	PRTMP_ADAPTER pAd;
+	ULONG Now32;
 
 	if (pBAEntry == NULL)
 		return;
 
-	if ((pBAEntry->REC_BA_Status == Recipient_Accept))
-	{
+	if ((pBAEntry->REC_BA_Status == Recipient_Accept)) {
 		NdisGetSystemUpTime(&Now32);
 
-		if (RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer + REC_BA_SESSION_IDLE_TIMEOUT)))
-		{
+		if (RTMP_TIME_AFTER
+		    ((unsigned long)Now32,
+		     (unsigned long)(pBAEntry->LastIndSeqAtTimer +
+				     REC_BA_SESSION_IDLE_TIMEOUT))) {
 			pAd = pBAEntry->pAdapter;
 			// flush all pending reordering mpdus
 			ba_refresh_reordering_mpdus(pAd, pBAEntry);
-			DBGPRINT(RT_DEBUG_OFF, ("%ld: REC BA session Timeout\n", Now32));
+			DBGPRINT(RT_DEBUG_OFF,
+				 ("%ld: REC BA session Timeout\n", Now32));
 		}
 	}
 }
 
-
-VOID PeerAddBAReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
-
+VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	//	7.4.4.1
-	//ULONG	Idx;
-	UCHAR   Status = 1;
-	UCHAR   pAddr[6];
+	//      7.4.4.1
+	//ULONG Idx;
+	UCHAR Status = 1;
+	UCHAR pAddr[6];
 	FRAME_ADDBA_RSP ADDframe;
-	PUCHAR         pOutBuffer = NULL;
-	NDIS_STATUS     NStatus;
-	PFRAME_ADDBA_REQ  pAddreqFrame = NULL;
-	//UCHAR		BufSize;
-	ULONG       FrameLen;
-	PULONG      ptemp;
-	PMAC_TABLE_ENTRY	pMacEntry;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+	PFRAME_ADDBA_REQ pAddreqFrame = NULL;
+	//UCHAR         BufSize;
+	ULONG FrameLen;
+	PULONG ptemp;
+	PMAC_TABLE_ENTRY pMacEntry;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("%s ==> (Wcid = %d)\n", __func__, Elem->Wcid));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("%s ==> (Wcid = %d)\n", __func__, Elem->Wcid));
 
 	//hex_dump("AddBAReq", Elem->Msg, Elem->MsgLen);
 
@@ -1166,37 +1095,37 @@ VOID PeerAddBAReqAction(
 		return;
 
 	pMacEntry = &pAd->MacTab.Content[Elem->Wcid];
-	DBGPRINT(RT_DEBUG_TRACE,("BA - PeerAddBAReqAction----> \n"));
-	ptemp = (PULONG)Elem->Msg;
+	DBGPRINT(RT_DEBUG_TRACE, ("BA - PeerAddBAReqAction----> \n"));
+	ptemp = (PULONG) Elem->Msg;
 	//DBGPRINT_RAW(RT_DEBUG_EMU, ("%08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x\n", *(ptemp), *(ptemp+1), *(ptemp+2), *(ptemp+3), *(ptemp+4), *(ptemp+5), *(ptemp+6), *(ptemp+7), *(ptemp+8)));
 
-	if (PeerAddBAReqActionSanity(pAd, Elem->Msg, Elem->MsgLen, pAddr))
-	{
+	if (PeerAddBAReqActionSanity(pAd, Elem->Msg, Elem->MsgLen, pAddr)) {
 
-		if ((pAd->CommonCfg.bBADecline == FALSE) && IS_HT_STA(pMacEntry))
-		{
-			pAddreqFrame = (PFRAME_ADDBA_REQ)(&Elem->Msg[0]);
-			DBGPRINT(RT_DEBUG_OFF, ("Rcv Wcid(%d) AddBAReq\n", Elem->Wcid));
-			if (BARecSessionAdd(pAd, &pAd->MacTab.Content[Elem->Wcid], pAddreqFrame))
+		if ((pAd->CommonCfg.bBADecline == FALSE)
+		    && IS_HT_STA(pMacEntry)) {
+			pAddreqFrame = (PFRAME_ADDBA_REQ) (&Elem->Msg[0]);
+			DBGPRINT(RT_DEBUG_OFF,
+				 ("Rcv Wcid(%d) AddBAReq\n", Elem->Wcid));
+			if (BARecSessionAdd
+			    (pAd, &pAd->MacTab.Content[Elem->Wcid],
+			     pAddreqFrame))
 				Status = 0;
 			else
-				Status = 38; // more parameters have invalid values
-		}
-		else
-		{
-			Status = 37; // the request has been declined.
+				Status = 38;	// more parameters have invalid values
+		} else {
+			Status = 37;	// the request has been declined.
 		}
 	}
 
 	if (pAd->MacTab.Content[Elem->Wcid].ValidAsCLI)
 		ASSERT(pAd->MacTab.Content[Elem->Wcid].Sst == SST_ASSOC);
 
-	pAddreqFrame = (PFRAME_ADDBA_REQ)(&Elem->Msg[0]);
+	pAddreqFrame = (PFRAME_ADDBA_REQ) (&Elem->Msg[0]);
 	// 2. Always send back ADDBA Response
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	 //Get an unused nonpaged memory
-	if (NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("ACTION - PeerBAAction() allocate memory failed \n"));
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ACTION - PeerBAAction() allocate memory failed \n"));
 		return;
 	}
 
@@ -1205,9 +1134,12 @@ VOID PeerAddBAReqAction(
 	// 2-1. Prepare ADDBA Response frame.
 	{
 		if (ADHOC_ON(pAd))
-			ActHeaderInit(pAd, &ADDframe.Hdr, pAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+			ActHeaderInit(pAd, &ADDframe.Hdr, pAddr,
+				      pAd->CurrentAddress,
+				      pAd->CommonCfg.Bssid);
 		else
-			ActHeaderInit(pAd, &ADDframe.Hdr, pAd->CommonCfg.Bssid, pAd->CurrentAddress, pAddr);
+			ActHeaderInit(pAd, &ADDframe.Hdr, pAd->CommonCfg.Bssid,
+				      pAd->CurrentAddress, pAddr);
 	}
 
 	ADDframe.Category = CATEGORY_BA;
@@ -1218,37 +1150,35 @@ VOID PeerAddBAReqAction(
 	ADDframe.BaParm.BAPolicy = IMMED_BA;
 	ADDframe.BaParm.AMSDUSupported = 0;
 	ADDframe.BaParm.TID = pAddreqFrame->BaParm.TID;
-	ADDframe.BaParm.BufSize = min(((UCHAR)pAddreqFrame->BaParm.BufSize), (UCHAR)pAd->CommonCfg.BACapability.field.RxBAWinLimit);
-	if (ADDframe.BaParm.BufSize == 0)
-	{
+	ADDframe.BaParm.BufSize =
+	    min(((UCHAR) pAddreqFrame->BaParm.BufSize),
+		(UCHAR) pAd->CommonCfg.BACapability.field.RxBAWinLimit);
+	if (ADDframe.BaParm.BufSize == 0) {
 		ADDframe.BaParm.BufSize = 64;
 	}
-	ADDframe.TimeOutValue = 0; //pAddreqFrame->TimeOutValue;
+	ADDframe.TimeOutValue = 0;	//pAddreqFrame->TimeOutValue;
 
-	*(USHORT *)(&ADDframe.BaParm) = cpu2le16(*(USHORT *)(&ADDframe.BaParm));
+	*(USHORT *) (&ADDframe.BaParm) =
+	    cpu2le16(*(USHORT *) (&ADDframe.BaParm));
 	ADDframe.StatusCode = cpu2le16(ADDframe.StatusCode);
 	ADDframe.TimeOutValue = cpu2le16(ADDframe.TimeOutValue);
 
-	MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-					  sizeof(FRAME_ADDBA_RSP),  &ADDframe,
-			  END_OF_ARGS);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen,
+			  sizeof(FRAME_ADDBA_RSP), &ADDframe, END_OF_ARGS);
 	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("%s(%d): TID(%d), BufSize(%d) <== \n", __func__, Elem->Wcid, ADDframe.BaParm.TID,
-							  ADDframe.BaParm.BufSize));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("%s(%d): TID(%d), BufSize(%d) <== \n", __func__, Elem->Wcid,
+		  ADDframe.BaParm.TID, ADDframe.BaParm.BufSize));
 }
 
-
-VOID PeerAddBARspAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
-
+VOID PeerAddBARspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	//UCHAR		Idx, i;
-	//PUCHAR		   pOutBuffer = NULL;
-	PFRAME_ADDBA_RSP    pFrame = NULL;
-	//PBA_ORI_ENTRY		pBAEntry;
+	//UCHAR         Idx, i;
+	//PUCHAR                   pOutBuffer = NULL;
+	PFRAME_ADDBA_RSP pFrame = NULL;
+	//PBA_ORI_ENTRY         pBAEntry;
 
 	//ADDBA Response from unknown peer, ignore this.
 	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
@@ -1258,120 +1188,119 @@ VOID PeerAddBARspAction(
 
 	//hex_dump("PeerAddBARspAction()", Elem->Msg, Elem->MsgLen);
 
-	if (PeerAddBARspActionSanity(pAd, Elem->Msg, Elem->MsgLen))
-	{
-		pFrame = (PFRAME_ADDBA_RSP)(&Elem->Msg[0]);
+	if (PeerAddBARspActionSanity(pAd, Elem->Msg, Elem->MsgLen)) {
+		pFrame = (PFRAME_ADDBA_RSP) (&Elem->Msg[0]);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("\t\t StatusCode = %d\n", pFrame->StatusCode));
-		switch (pFrame->StatusCode)
-		{
-			case 0:
-				// I want a BAsession with this peer as an originator.
-				BAOriSessionAdd(pAd, &pAd->MacTab.Content[Elem->Wcid], pFrame);
-				break;
-			default:
-				// check status == USED ???
-				BAOriSessionTearDown(pAd, Elem->Wcid, pFrame->BaParm.TID, TRUE, FALSE);
-				break;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("\t\t StatusCode = %d\n", pFrame->StatusCode));
+		switch (pFrame->StatusCode) {
+		case 0:
+			// I want a BAsession with this peer as an originator.
+			BAOriSessionAdd(pAd, &pAd->MacTab.Content[Elem->Wcid],
+					pFrame);
+			break;
+		default:
+			// check status == USED ???
+			BAOriSessionTearDown(pAd, Elem->Wcid,
+					     pFrame->BaParm.TID, TRUE, FALSE);
+			break;
 		}
 		// Rcv Decline StatusCode
 		if ((pFrame->StatusCode == 37)
-            || ((pAd->OpMode == OPMODE_STA) && STA_TGN_WIFI_ON(pAd) && (pFrame->StatusCode != 0))
-            )
-		{
-			pAd->MacTab.Content[Elem->Wcid].BADeclineBitmap |= 1<<pFrame->BaParm.TID;
+		    || ((pAd->OpMode == OPMODE_STA) && STA_TGN_WIFI_ON(pAd)
+			&& (pFrame->StatusCode != 0))
+		    ) {
+			pAd->MacTab.Content[Elem->Wcid].BADeclineBitmap |=
+			    1 << pFrame->BaParm.TID;
 		}
 	}
 }
 
-VOID PeerDelBAAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
-
+VOID PeerDelBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	//UCHAR				Idx;
-	//PUCHAR				pOutBuffer = NULL;
-	PFRAME_DELBA_REQ    pDelFrame = NULL;
+	//UCHAR                         Idx;
+	//PUCHAR                                pOutBuffer = NULL;
+	PFRAME_DELBA_REQ pDelFrame = NULL;
 
-	DBGPRINT(RT_DEBUG_TRACE,("%s ==>\n", __func__));
+	DBGPRINT(RT_DEBUG_TRACE, ("%s ==>\n", __func__));
 	//DELBA Request from unknown peer, ignore this.
-	if (PeerDelBAActionSanity(pAd, Elem->Wcid, Elem->Msg, Elem->MsgLen))
-	{
-		pDelFrame = (PFRAME_DELBA_REQ)(&Elem->Msg[0]);
-		if (pDelFrame->DelbaParm.Initiator == ORIGINATOR)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,("BA - PeerDelBAAction----> ORIGINATOR\n"));
-			BARecSessionTearDown(pAd, Elem->Wcid, pDelFrame->DelbaParm.TID, TRUE);
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_TRACE,("BA - PeerDelBAAction----> RECIPIENT, Reason = %d\n",  pDelFrame->ReasonCode));
+	if (PeerDelBAActionSanity(pAd, Elem->Wcid, Elem->Msg, Elem->MsgLen)) {
+		pDelFrame = (PFRAME_DELBA_REQ) (&Elem->Msg[0]);
+		if (pDelFrame->DelbaParm.Initiator == ORIGINATOR) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BA - PeerDelBAAction----> ORIGINATOR\n"));
+			BARecSessionTearDown(pAd, Elem->Wcid,
+					     pDelFrame->DelbaParm.TID, TRUE);
+		} else {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BA - PeerDelBAAction----> RECIPIENT, Reason = %d\n",
+				  pDelFrame->ReasonCode));
 			//hex_dump("DelBA Frame", pDelFrame, Elem->MsgLen);
-			BAOriSessionTearDown(pAd, Elem->Wcid, pDelFrame->DelbaParm.TID, TRUE, FALSE);
+			BAOriSessionTearDown(pAd, Elem->Wcid,
+					     pDelFrame->DelbaParm.TID, TRUE,
+					     FALSE);
 		}
 	}
 }
 
-
-BOOLEAN CntlEnqueueForRecv(
-						  IN PRTMP_ADAPTER		pAd,
-						  IN ULONG				Wcid,
-						  IN ULONG				MsgLen,
-						  IN PFRAME_BA_REQ		pMsg)
+BOOLEAN CntlEnqueueForRecv(IN PRTMP_ADAPTER pAd,
+			   IN ULONG Wcid,
+			   IN ULONG MsgLen, IN PFRAME_BA_REQ pMsg)
 {
-	PFRAME_BA_REQ   pFrame = pMsg;
-	//PRTMP_REORDERBUF	pBuffer;
-	//PRTMP_REORDERBUF	pDmaBuf;
+	PFRAME_BA_REQ pFrame = pMsg;
+	//PRTMP_REORDERBUF      pBuffer;
+	//PRTMP_REORDERBUF      pDmaBuf;
 	PBA_REC_ENTRY pBAEntry;
-	//BOOLEAN 	Result;
-	ULONG   Idx;
-	//UCHAR	NumRxPkt;
-	UCHAR	TID;//, i;
+	//BOOLEAN       Result;
+	ULONG Idx;
+	//UCHAR NumRxPkt;
+	UCHAR TID;		//, i;
 
-	TID = (UCHAR)pFrame->BARControl.TID;
+	TID = (UCHAR) pFrame->BARControl.TID;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("%s(): BAR-Wcid(%ld), Tid (%d)\n", __func__, Wcid, TID));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("%s(): BAR-Wcid(%ld), Tid (%d)\n", __func__, Wcid, TID));
 	//hex_dump("BAR", (PCHAR) pFrame, MsgLen);
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return FALSE;
 
 	// First check the size, it MUST not exceed the mlme queue size
-	if (MsgLen > MGMT_DMA_BUFFER_SIZE)
-	{
+	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
 		DBGPRINT_ERR(("CntlEnqueueForRecv: frame too large, size = %ld \n", MsgLen));
 		return FALSE;
-	}
-	else if (MsgLen != sizeof(FRAME_BA_REQ))
-	{
+	} else if (MsgLen != sizeof(FRAME_BA_REQ)) {
 		DBGPRINT_ERR(("CntlEnqueueForRecv: BlockAck Request frame length size = %ld incorrect\n", MsgLen));
 		return FALSE;
-	}
-	else if (MsgLen != sizeof(FRAME_BA_REQ))
-	{
+	} else if (MsgLen != sizeof(FRAME_BA_REQ)) {
 		DBGPRINT_ERR(("CntlEnqueueForRecv: BlockAck Request frame length size = %ld incorrect\n", MsgLen));
 		return FALSE;
 	}
 
-	if ((Wcid < MAX_LEN_OF_MAC_TABLE) && (TID < 8))
-		{
+	if ((Wcid < MAX_LEN_OF_MAC_TABLE) && (TID < 8)) {
 		// if this receiving packet is from SA that is in our OriEntry. Since WCID <9 has direct mapping. no need search.
 		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
 		pBAEntry = &pAd->BATable.BARecEntry[Idx];
-		}
-		else
-		{
+	} else {
 		return FALSE;
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE, ("BAR(%ld) : Tid (%d) - %04x:%04x\n", Wcid, TID, pFrame->BAStartingSeq.field.StartSeq, pBAEntry->LastIndSeq ));
-
-	if (SEQ_SMALLER(pBAEntry->LastIndSeq, pFrame->BAStartingSeq.field.StartSeq, MAXSEQ))
-	{
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("BAR(%ld) : Tid (%d) - %04x:%04x\n", Wcid, TID,
+		  pFrame->BAStartingSeq.field.StartSeq, pBAEntry->LastIndSeq));
+
+	if (SEQ_SMALLER
+	    (pBAEntry->LastIndSeq, pFrame->BAStartingSeq.field.StartSeq,
+	     MAXSEQ)) {
 		//DBGPRINT(RT_DEBUG_TRACE, ("BAR Seq = %x, LastIndSeq = %x\n", pFrame->BAStartingSeq.field.StartSeq, pBAEntry->LastIndSeq));
-		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, pFrame->BAStartingSeq.field.StartSeq);
-		pBAEntry->LastIndSeq = (pFrame->BAStartingSeq.field.StartSeq == 0) ? MAXSEQ :(pFrame->BAStartingSeq.field.StartSeq -1);
+		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry,
+						    pFrame->BAStartingSeq.field.
+						    StartSeq);
+		pBAEntry->LastIndSeq =
+		    (pFrame->BAStartingSeq.field.StartSeq ==
+		     0) ? MAXSEQ : (pFrame->BAStartingSeq.field.StartSeq - 1);
 	}
 	//ba_refresh_reordering_mpdus(pAd, pBAEntry);
 	return TRUE;
@@ -1380,101 +1309,91 @@ BOOLEAN CntlEnqueueForRecv(
 /*
 Description : Send PSMP Action frame If PSMP mode switches.
 */
-VOID SendPSMPAction(
-				   IN PRTMP_ADAPTER		pAd,
-				   IN UCHAR				Wcid,
-				   IN UCHAR				Psmp)
+VOID SendPSMPAction(IN PRTMP_ADAPTER pAd, IN UCHAR Wcid, IN UCHAR Psmp)
 {
-	PUCHAR          pOutBuffer = NULL;
-	NDIS_STATUS     NStatus;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
 	//ULONG           Idx;
-	FRAME_PSMP_ACTION   Frame;
-	ULONG           FrameLen;
+	FRAME_PSMP_ACTION Frame;
+	ULONG FrameLen;
 
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	 //Get an unused nonpaged memory
-	if (NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("BA - MlmeADDBAAction() allocate memory failed \n"));
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("BA - MlmeADDBAAction() allocate memory failed \n"));
 		return;
 	}
 
-	ActHeaderInit(pAd, &Frame.Hdr, pAd->CommonCfg.Bssid, pAd->CurrentAddress, pAd->MacTab.Content[Wcid].Addr);
+	ActHeaderInit(pAd, &Frame.Hdr, pAd->CommonCfg.Bssid,
+		      pAd->CurrentAddress, pAd->MacTab.Content[Wcid].Addr);
 
 	Frame.Category = CATEGORY_HT;
 	Frame.Action = SMPS_ACTION;
-	switch (Psmp)
-	{
-		case MMPS_ENABLE:
+	switch (Psmp) {
+	case MMPS_ENABLE:
 #ifdef RT30xx
-			if (IS_RT30xx(pAd)
-				&&(pAd->Antenna.field.RxPath>1||pAd->Antenna.field.TxPath>1))
-			{
-				RTMP_ASIC_MMPS_DISABLE(pAd);
-			}
+		if (IS_RT30xx(pAd)
+		    && (pAd->Antenna.field.RxPath > 1
+			|| pAd->Antenna.field.TxPath > 1)) {
+			RTMP_ASIC_MMPS_DISABLE(pAd);
+		}
 #endif // RT30xx //
-			Frame.Psmp = 0;
-			break;
-		case MMPS_DYNAMIC:
-			Frame.Psmp = 3;
-			break;
-		case MMPS_STATIC:
+		Frame.Psmp = 0;
+		break;
+	case MMPS_DYNAMIC:
+		Frame.Psmp = 3;
+		break;
+	case MMPS_STATIC:
 #ifdef RT30xx
-			if (IS_RT30xx(pAd)
-				&&(pAd->Antenna.field.RxPath>1||pAd->Antenna.field.TxPath>1))
-			{
-				RTMP_ASIC_MMPS_ENABLE(pAd);
-			}
+		if (IS_RT30xx(pAd)
+		    && (pAd->Antenna.field.RxPath > 1
+			|| pAd->Antenna.field.TxPath > 1)) {
+			RTMP_ASIC_MMPS_ENABLE(pAd);
+		}
 #endif // RT30xx //
-			Frame.Psmp = 1;
-			break;
+		Frame.Psmp = 1;
+		break;
 	}
-	MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-					  sizeof(FRAME_PSMP_ACTION),      &Frame,
-					  END_OF_ARGS);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen,
+			  sizeof(FRAME_PSMP_ACTION), &Frame, END_OF_ARGS);
 	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
-	DBGPRINT(RT_DEBUG_ERROR,("HT - SendPSMPAction( %d )  \n", Frame.Psmp));
+	DBGPRINT(RT_DEBUG_ERROR, ("HT - SendPSMPAction( %d )  \n", Frame.Psmp));
 }
 
-
 #define RADIO_MEASUREMENT_REQUEST_ACTION	0
 
-typedef struct PACKED
-{
-	UCHAR	RegulatoryClass;
-	UCHAR	ChannelNumber;
-	USHORT	RandomInterval;
-	USHORT	MeasurementDuration;
-	UCHAR	MeasurementMode;
-	UCHAR   BSSID[MAC_ADDR_LEN];
-	UCHAR	ReportingCondition;
-	UCHAR	Threshold;
-	UCHAR   SSIDIE[2];			// 2 byte
+typedef struct PACKED {
+	UCHAR RegulatoryClass;
+	UCHAR ChannelNumber;
+	USHORT RandomInterval;
+	USHORT MeasurementDuration;
+	UCHAR MeasurementMode;
+	UCHAR BSSID[MAC_ADDR_LEN];
+	UCHAR ReportingCondition;
+	UCHAR Threshold;
+	UCHAR SSIDIE[2];	// 2 byte
 } BEACON_REQUEST;
 
-typedef struct PACKED
-{
-	UCHAR	ID;
-	UCHAR	Length;
-	UCHAR	Token;
-	UCHAR	RequestMode;
-	UCHAR	Type;
+typedef struct PACKED {
+	UCHAR ID;
+	UCHAR Length;
+	UCHAR Token;
+	UCHAR RequestMode;
+	UCHAR Type;
 } MEASUREMENT_REQ;
 
-
-
-
-void convert_reordering_packet_to_preAMSDU_or_802_3_packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN  UCHAR			FromWhichBSSID)
+void convert_reordering_packet_to_preAMSDU_or_802_3_packet(IN PRTMP_ADAPTER pAd,
+							   IN RX_BLK * pRxBlk,
+							   IN UCHAR
+							   FromWhichBSSID)
 {
-	PNDIS_PACKET	pRxPkt;
-	UCHAR			Header802_3[LENGTH_802_3];
+	PNDIS_PACKET pRxPkt;
+	UCHAR Header802_3[LENGTH_802_3];
 
 	// 1. get 802.3 Header
 	// 2. remove LLC
-	// 		a. pointer pRxBlk->pData to payload
+	//              a. pointer pRxBlk->pData to payload
 	//      b. modify pRxBlk->DataSize
 
 	RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(pRxBlk, Header802_3);
@@ -1490,17 +1409,16 @@ void convert_reordering_packet_to_preAMS
 	//
 	// copy 802.3 header, if necessary
 	//
-	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU))
-	{
+	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)) {
 		{
 #ifdef LINUX
-		NdisMoveMemory(skb_push(pRxPkt, LENGTH_802_3), Header802_3, LENGTH_802_3);
+			NdisMoveMemory(skb_push(pRxPkt, LENGTH_802_3),
+				       Header802_3, LENGTH_802_3);
 #endif
-	}
+		}
 	}
 }
 
-
 #define INDICATE_LEGACY_OR_AMSDU(_pAd, _pRxBlk, _fromWhichBSSID)		\
 	do																	\
 	{																	\
@@ -1518,21 +1436,16 @@ void convert_reordering_packet_to_preAMS
     	}																\
 	} while (0);
 
-
-
-static VOID ba_enqueue_reordering_packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PBA_REC_ENTRY	pBAEntry,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
+static VOID ba_enqueue_reordering_packet(IN PRTMP_ADAPTER pAd,
+					 IN PBA_REC_ENTRY pBAEntry,
+					 IN RX_BLK * pRxBlk,
+					 IN UCHAR FromWhichBSSID)
 {
 	struct reordering_mpdu *mpdu_blk;
-	UINT16	Sequence = (UINT16) pRxBlk->pHeader->Sequence;
+	UINT16 Sequence = (UINT16) pRxBlk->pHeader->Sequence;
 
 	mpdu_blk = ba_mpdu_blk_alloc(pAd);
-	if ((mpdu_blk != NULL) &&
-		(!RX_BLK_TEST_FLAG(pRxBlk, fRX_EAP)))
-	{
+	if ((mpdu_blk != NULL) && (!RX_BLK_TEST_FLAG(pRxBlk, fRX_EAP))) {
 		// Write RxD buffer address & allocated buffer length
 		NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
 
@@ -1540,11 +1453,13 @@ static VOID ba_enqueue_reordering_packet
 
 		mpdu_blk->bAMSDU = RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU);
 
-		convert_reordering_packet_to_preAMSDU_or_802_3_packet(pAd, pRxBlk, FromWhichBSSID);
+		convert_reordering_packet_to_preAMSDU_or_802_3_packet(pAd,
+								      pRxBlk,
+								      FromWhichBSSID);
 
 		STATS_INC_RX_PACKETS(pAd, FromWhichBSSID);
 
-        //
+		//
 		// it is necessary for reordering packet to record
 		// which BSS it come from
 		//
@@ -1552,21 +1467,22 @@ static VOID ba_enqueue_reordering_packet
 
 		mpdu_blk->pPacket = pRxBlk->pRxPacket;
 
-		if (ba_reordering_mpdu_insertsorted(&pBAEntry->list, mpdu_blk) == FALSE)
-		{
+		if (ba_reordering_mpdu_insertsorted(&pBAEntry->list, mpdu_blk)
+		    == FALSE) {
 			// had been already within reordering list
 			// don't indicate
-			RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_SUCCESS);
+			RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+					    NDIS_STATUS_SUCCESS);
 			ba_mpdu_blk_free(pAd, mpdu_blk);
 		}
 
-		ASSERT((0<= pBAEntry->list.qlen)  && (pBAEntry->list.qlen <= pBAEntry->BAWinSize));
+		ASSERT((0 <= pBAEntry->list.qlen)
+		       && (pBAEntry->list.qlen <= pBAEntry->BAWinSize));
 		NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_ERROR,  ("!!! (%d) Can't allocate reordering mpdu blk\n",
-								   pBAEntry->list.qlen));
+	} else {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("!!! (%d) Can't allocate reordering mpdu blk\n",
+			  pBAEntry->list.qlen));
 
 		/*
 		 * flush all pending reordering mpdus
@@ -1581,7 +1497,6 @@ static VOID ba_enqueue_reordering_packet
 	}
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1600,43 +1515,38 @@ static VOID ba_enqueue_reordering_packet
 	==========================================================================
  */
 
-VOID Indicate_AMPDU_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
-{
-	USHORT				Idx;
-	PBA_REC_ENTRY		pBAEntry = NULL;
-	UINT16				Sequence = pRxBlk->pHeader->Sequence;
-	ULONG				Now32;
-	UCHAR				Wcid = pRxBlk->pRxWI->WirelessCliID;
-	UCHAR				TID = pRxBlk->pRxWI->TID;
-
+VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
+			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
+{
+	USHORT Idx;
+	PBA_REC_ENTRY pBAEntry = NULL;
+	UINT16 Sequence = pRxBlk->pHeader->Sequence;
+	ULONG Now32;
+	UCHAR Wcid = pRxBlk->pRxWI->WirelessCliID;
+	UCHAR TID = pRxBlk->pRxWI->TID;
 
-	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU) &&  (pRxBlk->DataSize > MAX_RX_PKT_LEN))
-	{
+	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)
+	    && (pRxBlk->DataSize > MAX_RX_PKT_LEN)) {
 		// release packet
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+				    NDIS_STATUS_FAILURE);
 		return;
 	}
 
-	if (Wcid < MAX_LEN_OF_MAC_TABLE)
-	{
+	if (Wcid < MAX_LEN_OF_MAC_TABLE) {
 		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
-		if (Idx == 0)
-		{
+		if (Idx == 0) {
 			/* Rec BA Session had been torn down */
 			INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
 			return;
 		}
 		pBAEntry = &pAd->BATable.BARecEntry[Idx];
-	}
-	else
-	{
+	} else {
 		// impossible !!!
 		ASSERT(0);
 		// release packet
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+				    NDIS_STATUS_FAILURE);
 		return;
 	}
 
@@ -1647,16 +1557,15 @@ VOID Indicate_AMPDU_Packet(
 
 	pBAEntry->rcvSeq = Sequence;
 
-
 	ba_flush_reordering_timeout_mpdus(pAd, pBAEntry, Now32);
 	pBAEntry->LastIndSeqAtTimer = Now32;
 
 	//
 	// Reset Last Indicate Sequence
 	//
-	if (pBAEntry->LastIndSeq == RESET_RCV_SEQ)
-	{
-		ASSERT((pBAEntry->list.qlen == 0) && (pBAEntry->list.next == NULL));
+	if (pBAEntry->LastIndSeq == RESET_RCV_SEQ) {
+		ASSERT((pBAEntry->list.qlen == 0)
+		       && (pBAEntry->list.next == NULL));
 
 		// reset rcv sequence of BA session
 		pBAEntry->LastIndSeq = Sequence;
@@ -1665,19 +1574,18 @@ VOID Indicate_AMPDU_Packet(
 		return;
 	}
 
-
 	//
 	// I. Check if in order.
 	//
-	if (SEQ_STEPONE(Sequence, pBAEntry->LastIndSeq, MAXSEQ))
-	{
-		USHORT  LastIndSeq;
+	if (SEQ_STEPONE(Sequence, pBAEntry->LastIndSeq, MAXSEQ)) {
+		USHORT LastIndSeq;
 
 		pBAEntry->LastIndSeq = Sequence;
 		INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
- 		LastIndSeq = ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry, pBAEntry->LastIndSeq);
-		if (LastIndSeq != RESET_RCV_SEQ)
-		{
+		LastIndSeq =
+		    ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry,
+							  pBAEntry->LastIndSeq);
+		if (LastIndSeq != RESET_RCV_SEQ) {
 			pBAEntry->LastIndSeq = LastIndSeq;
 		}
 		pBAEntry->LastIndSeqAtTimer = Now32;
@@ -1685,54 +1593,56 @@ VOID Indicate_AMPDU_Packet(
 	//
 	// II. Drop Duplicated Packet
 	//
-	else if (Sequence == pBAEntry->LastIndSeq)
-	{
+	else if (Sequence == pBAEntry->LastIndSeq) {
 
 		// drop and release packet
 		pBAEntry->nDropPacket++;
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+				    NDIS_STATUS_FAILURE);
 	}
 	//
 	// III. Drop Old Received Packet
 	//
-	else if (SEQ_SMALLER(Sequence, pBAEntry->LastIndSeq, MAXSEQ))
-	{
+	else if (SEQ_SMALLER(Sequence, pBAEntry->LastIndSeq, MAXSEQ)) {
 
 		// drop and release packet
 		pBAEntry->nDropPacket++;
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+				    NDIS_STATUS_FAILURE);
 	}
 	//
 	// IV. Receive Sequence within Window Size
 	//
-	else if (SEQ_SMALLER(Sequence, (((pBAEntry->LastIndSeq+pBAEntry->BAWinSize+1)) & MAXSEQ), MAXSEQ))
-	{
-		ba_enqueue_reordering_packet(pAd, pBAEntry, pRxBlk, FromWhichBSSID);
+	else if (SEQ_SMALLER
+		 (Sequence,
+		  (((pBAEntry->LastIndSeq + pBAEntry->BAWinSize + 1)) & MAXSEQ),
+		  MAXSEQ)) {
+		ba_enqueue_reordering_packet(pAd, pBAEntry, pRxBlk,
+					     FromWhichBSSID);
 	}
 	//
 	// V. Receive seq surpasses Win(lastseq + nMSDU). So refresh all reorder buffer
 	//
-	else
-	{
+	else {
 		LONG WinStartSeq, TmpSeq;
 
-
-		TmpSeq = Sequence - (pBAEntry->BAWinSize) -1;
-		if (TmpSeq < 0)
-		{
-			TmpSeq = (MAXSEQ+1) + TmpSeq;
+		TmpSeq = Sequence - (pBAEntry->BAWinSize) - 1;
+		if (TmpSeq < 0) {
+			TmpSeq = (MAXSEQ + 1) + TmpSeq;
 		}
-		WinStartSeq = (TmpSeq+1) & MAXSEQ;
+		WinStartSeq = (TmpSeq + 1) & MAXSEQ;
 		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, WinStartSeq);
-		pBAEntry->LastIndSeq = WinStartSeq; //TmpSeq;
+		pBAEntry->LastIndSeq = WinStartSeq;	//TmpSeq;
 
 		pBAEntry->LastIndSeqAtTimer = Now32;
 
-		ba_enqueue_reordering_packet(pAd, pBAEntry, pRxBlk, FromWhichBSSID);
+		ba_enqueue_reordering_packet(pAd, pBAEntry, pRxBlk,
+					     FromWhichBSSID);
 
-		TmpSeq = ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry, pBAEntry->LastIndSeq);
-		if (TmpSeq != RESET_RCV_SEQ)
-		{
+		TmpSeq =
+		    ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry,
+							  pBAEntry->LastIndSeq);
+		if (TmpSeq != RESET_RCV_SEQ) {
 			pBAEntry->LastIndSeq = TmpSeq;
 		}
 	}
--- a/drivers/staging/rt2860/common/cmm_aes.c
+++ b/drivers/staging/rt2860/common/cmm_aes.c
@@ -37,21 +37,17 @@
 
 #include	"../rt_config.h"
 
-
-typedef	struct
-{
-    UINT32 erk[64];     /* encryption round keys */
-    UINT32 drk[64];     /* decryption round keys */
-    int nr;             /* number of rounds */
-}
-aes_context;
+typedef struct {
+	UINT32 erk[64];		/* encryption round keys */
+	UINT32 drk[64];		/* decryption round keys */
+	int nr;			/* number of rounds */
+} aes_context;
 
 /*****************************/
 /******** SBOX Table *********/
 /*****************************/
 
-UCHAR SboxTable[256] =
-{
+UCHAR SboxTable[256] = {
 	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
 	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
 	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
@@ -86,46 +82,34 @@ UCHAR SboxTable[256] =
 	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
 };
 
-VOID xor_32(
-	IN  PUCHAR  a,
-	IN  PUCHAR  b,
-	OUT PUCHAR  out)
+VOID xor_32(IN PUCHAR a, IN PUCHAR b, OUT PUCHAR out)
 {
 	INT i;
 
-	for (i=0;i<4; i++)
-	{
+	for (i = 0; i < 4; i++) {
 		out[i] = a[i] ^ b[i];
 	}
 }
 
-VOID xor_128(
-	IN  PUCHAR  a,
-	IN  PUCHAR  b,
-	OUT PUCHAR  out)
+VOID xor_128(IN PUCHAR a, IN PUCHAR b, OUT PUCHAR out)
 {
 	INT i;
 
-	for (i=0;i<16; i++)
-	{
+	for (i = 0; i < 16; i++) {
 		out[i] = a[i] ^ b[i];
 	}
 }
 
-UCHAR RTMPCkipSbox(
-	IN  UCHAR   a)
+UCHAR RTMPCkipSbox(IN UCHAR a)
 {
 	return SboxTable[(int)a];
 }
 
-VOID next_key(
-	IN  PUCHAR  key,
-	IN  INT     round)
+VOID next_key(IN PUCHAR key, IN INT round)
 {
-	UCHAR       rcon;
-	UCHAR       sbox_key[4];
-	UCHAR       rcon_table[12] =
-	{
+	UCHAR rcon;
+	UCHAR sbox_key[4];
+	UCHAR rcon_table[12] = {
 		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
 		0x1b, 0x36, 0x36, 0x36
 	};
@@ -145,14 +129,11 @@ VOID next_key(
 	xor_32(&key[12], &key[8], &key[12]);
 }
 
-VOID byte_sub(
-	IN  PUCHAR  in,
-	OUT PUCHAR  out)
+VOID byte_sub(IN PUCHAR in, OUT PUCHAR out)
 {
 	INT i;
 
-	for (i=0; i< 16; i++)
-	{
+	for (i = 0; i < 16; i++) {
 		out[i] = RTMPCkipSbox(in[i]);
 	}
 }
@@ -165,26 +146,23 @@ VOID byte_sub(
 void bitwise_xor(unsigned char *ina, unsigned char *inb, unsigned char *out)
 {
 	int i;
-	for (i=0; i<16; i++)
-	{
+	for (i = 0; i < 16; i++) {
 		out[i] = ina[i] ^ inb[i];
 	}
 }
 
-VOID shift_row(
-	IN  PUCHAR  in,
-	OUT PUCHAR  out)
+VOID shift_row(IN PUCHAR in, OUT PUCHAR out)
 {
-	out[0] =  in[0];
-	out[1] =  in[5];
-	out[2] =  in[10];
-	out[3] =  in[15];
-	out[4] =  in[4];
-	out[5] =  in[9];
-	out[6] =  in[14];
-	out[7] =  in[3];
-	out[8] =  in[8];
-	out[9] =  in[13];
+	out[0] = in[0];
+	out[1] = in[5];
+	out[2] = in[10];
+	out[3] = in[15];
+	out[4] = in[4];
+	out[5] = in[9];
+	out[6] = in[14];
+	out[7] = in[3];
+	out[8] = in[8];
+	out[9] = in[13];
 	out[10] = in[2];
 	out[11] = in[7];
 	out[12] = in[12];
@@ -193,34 +171,31 @@ VOID shift_row(
 	out[15] = in[11];
 }
 
-VOID mix_column(
-	IN  PUCHAR  in,
-	OUT PUCHAR  out)
+VOID mix_column(IN PUCHAR in, OUT PUCHAR out)
 {
-	INT         i;
-	UCHAR       add1b[4];
-	UCHAR       add1bf7[4];
-	UCHAR       rotl[4];
-	UCHAR       swap_halfs[4];
-	UCHAR       andf7[4];
-	UCHAR       rotr[4];
-	UCHAR       temp[4];
-	UCHAR       tempb[4];
-
-	for (i=0 ; i<4; i++)
-	{
-		if ((in[i] & 0x80)== 0x80)
+	INT i;
+	UCHAR add1b[4];
+	UCHAR add1bf7[4];
+	UCHAR rotl[4];
+	UCHAR swap_halfs[4];
+	UCHAR andf7[4];
+	UCHAR rotr[4];
+	UCHAR temp[4];
+	UCHAR tempb[4];
+
+	for (i = 0; i < 4; i++) {
+		if ((in[i] & 0x80) == 0x80)
 			add1b[i] = 0x1b;
 		else
 			add1b[i] = 0x00;
 	}
 
-	swap_halfs[0] = in[2];    /* Swap halfs */
+	swap_halfs[0] = in[2];	/* Swap halfs */
 	swap_halfs[1] = in[3];
 	swap_halfs[2] = in[0];
 	swap_halfs[3] = in[1];
 
-	rotl[0] = in[3];        /* Rotate left 8 bits */
+	rotl[0] = in[3];	/* Rotate left 8 bits */
 	rotl[1] = in[0];
 	rotl[2] = in[1];
 	rotl[3] = in[2];
@@ -230,11 +205,9 @@ VOID mix_column(
 	andf7[2] = in[2] & 0x7f;
 	andf7[3] = in[3] & 0x7f;
 
-	for (i = 3; i>0; i--)    /* logical shift left 1 bit */
-	{
+	for (i = 3; i > 0; i--) {	/* logical shift left 1 bit */
 		andf7[i] = andf7[i] << 1;
-		if ((andf7[i-1] & 0x80) == 0x80)
-		{
+		if ((andf7[i - 1] & 0x80) == 0x80) {
 			andf7[i] = (andf7[i] | 0x01);
 		}
 	}
@@ -245,40 +218,37 @@ VOID mix_column(
 
 	xor_32(in, add1bf7, rotr);
 
-	temp[0] = rotr[0];         /* Rotate right 8 bits */
+	temp[0] = rotr[0];	/* Rotate right 8 bits */
 	rotr[0] = rotr[1];
 	rotr[1] = rotr[2];
 	rotr[2] = rotr[3];
 	rotr[3] = temp[0];
 
 	xor_32(add1bf7, rotr, temp);
-	xor_32(swap_halfs, rotl,tempb);
+	xor_32(swap_halfs, rotl, tempb);
 	xor_32(temp, tempb, out);
 }
 
-
 /************************************************/
 /* construct_mic_header1()                      */
 /* Builds the first MIC header block from       */
 /* header fields.                               */
 /************************************************/
 
-void construct_mic_header1(
-	unsigned char *mic_header1,
-	int header_length,
-	unsigned char *mpdu)
+void construct_mic_header1(unsigned char *mic_header1,
+			   int header_length, unsigned char *mpdu)
 {
 	mic_header1[0] = (unsigned char)((header_length - 2) / 256);
 	mic_header1[1] = (unsigned char)((header_length - 2) % 256);
-	mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
-	mic_header1[3] = mpdu[1] & 0xc7;    /* Mute retry, more data and pwr mgt bits */
-	mic_header1[4] = mpdu[4];       /* A1 */
+	mic_header1[2] = mpdu[0] & 0xcf;	/* Mute CF poll & CF ack bits */
+	mic_header1[3] = mpdu[1] & 0xc7;	/* Mute retry, more data and pwr mgt bits */
+	mic_header1[4] = mpdu[4];	/* A1 */
 	mic_header1[5] = mpdu[5];
 	mic_header1[6] = mpdu[6];
 	mic_header1[7] = mpdu[7];
 	mic_header1[8] = mpdu[8];
 	mic_header1[9] = mpdu[9];
-	mic_header1[10] = mpdu[10];     /* A2 */
+	mic_header1[10] = mpdu[10];	/* A2 */
 	mic_header1[11] = mpdu[11];
 	mic_header1[12] = mpdu[12];
 	mic_header1[13] = mpdu[13];
@@ -292,17 +262,15 @@ void construct_mic_header1(
 /* header fields.                               */
 /************************************************/
 
-void construct_mic_header2(
-	unsigned char *mic_header2,
-	unsigned char *mpdu,
-	int a4_exists,
-	int qc_exists)
+void construct_mic_header2(unsigned char *mic_header2,
+			   unsigned char *mpdu, int a4_exists, int qc_exists)
 {
 	int i;
 
-	for (i = 0; i<16; i++) mic_header2[i]=0x00;
+	for (i = 0; i < 16; i++)
+		mic_header2[i] = 0x00;
 
-	mic_header2[0] = mpdu[16];    /* A3 */
+	mic_header2[0] = mpdu[16];	/* A3 */
 	mic_header2[1] = mpdu[17];
 	mic_header2[2] = mpdu[18];
 	mic_header2[3] = mpdu[19];
@@ -310,66 +278,62 @@ void construct_mic_header2(
 	mic_header2[5] = mpdu[21];
 
 	// In Sequence Control field, mute sequence numer bits (12-bit)
-	mic_header2[6] = mpdu[22] & 0x0f;   /* SC */
-	mic_header2[7] = 0x00; /* mpdu[23]; */
+	mic_header2[6] = mpdu[22] & 0x0f;	/* SC */
+	mic_header2[7] = 0x00;	/* mpdu[23]; */
 
-	if ((!qc_exists) & a4_exists)
-	{
-		for (i=0;i<6;i++) mic_header2[8+i] = mpdu[24+i];   /* A4 */
+	if ((!qc_exists) & a4_exists) {
+		for (i = 0; i < 6; i++)
+			mic_header2[8 + i] = mpdu[24 + i];	/* A4 */
 
 	}
 
-	if (qc_exists && (!a4_exists))
-	{
-		mic_header2[8] = mpdu[24] & 0x0f; /* mute bits 15 - 4 */
+	if (qc_exists && (!a4_exists)) {
+		mic_header2[8] = mpdu[24] & 0x0f;	/* mute bits 15 - 4 */
 		mic_header2[9] = mpdu[25] & 0x00;
 	}
 
-	if (qc_exists && a4_exists)
-	{
-		for (i=0;i<6;i++) mic_header2[8+i] = mpdu[24+i];   /* A4 */
+	if (qc_exists && a4_exists) {
+		for (i = 0; i < 6; i++)
+			mic_header2[8 + i] = mpdu[24 + i];	/* A4 */
 
 		mic_header2[14] = mpdu[30] & 0x0f;
 		mic_header2[15] = mpdu[31] & 0x00;
 	}
 }
 
-
 /************************************************/
 /* construct_mic_iv()                           */
 /* Builds the MIC IV from header fields and PN  */
 /************************************************/
 
-void construct_mic_iv(
-	unsigned char *mic_iv,
-	int qc_exists,
-	int a4_exists,
-	unsigned char *mpdu,
-	unsigned int payload_length,
-	unsigned char *pn_vector)
+void construct_mic_iv(unsigned char *mic_iv,
+		      int qc_exists,
+		      int a4_exists,
+		      unsigned char *mpdu,
+		      unsigned int payload_length, unsigned char *pn_vector)
 {
 	int i;
 
 	mic_iv[0] = 0x59;
 	if (qc_exists && a4_exists)
-		mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
+		mic_iv[1] = mpdu[30] & 0x0f;	/* QoS_TC           */
 	if (qc_exists && !a4_exists)
-		mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
+		mic_iv[1] = mpdu[24] & 0x0f;	/* mute bits 7-4    */
 	if (!qc_exists)
 		mic_iv[1] = 0x00;
 	for (i = 2; i < 8; i++)
-		mic_iv[i] = mpdu[i + 8];                    /* mic_iv[2:7] = A2[0:5] = mpdu[10:15] */
+		mic_iv[i] = mpdu[i + 8];	/* mic_iv[2:7] = A2[0:5] = mpdu[10:15] */
 #ifdef CONSISTENT_PN_ORDER
-		for (i = 8; i < 14; i++)
-			mic_iv[i] = pn_vector[i - 8];           /* mic_iv[8:13] = PN[0:5] */
+	for (i = 8; i < 14; i++)
+		mic_iv[i] = pn_vector[i - 8];	/* mic_iv[8:13] = PN[0:5] */
 #else
-		for (i = 8; i < 14; i++)
-			mic_iv[i] = pn_vector[13 - i];          /* mic_iv[8:13] = PN[5:0] */
+	for (i = 8; i < 14; i++)
+		mic_iv[i] = pn_vector[13 - i];	/* mic_iv[8:13] = PN[5:0] */
 #endif
 	i = (payload_length / 256);
 	i = (payload_length % 256);
-	mic_iv[14] = (unsigned char) (payload_length / 256);
-	mic_iv[15] = (unsigned char) (payload_length % 256);
+	mic_iv[14] = (unsigned char)(payload_length / 256);
+	mic_iv[15] = (unsigned char)(payload_length % 256);
 
 }
 
@@ -378,7 +342,8 @@ void construct_mic_iv(
 /* Performs a 128 bit AES encrypt with  */
 /* 128 bit data.                        */
 /****************************************/
-void aes128k128d(unsigned char *key, unsigned char *data, unsigned char *ciphertext)
+void aes128k128d(unsigned char *key, unsigned char *data,
+		 unsigned char *ciphertext)
 {
 	int round;
 	int i;
@@ -386,23 +351,19 @@ void aes128k128d(unsigned char *key, uns
 	unsigned char intermediateb[16];
 	unsigned char round_key[16];
 
-	for(i=0; i<16; i++) round_key[i] = key[i];
+	for (i = 0; i < 16; i++)
+		round_key[i] = key[i];
 
-	for (round = 0; round < 11; round++)
-	{
-		if (round == 0)
-		{
+	for (round = 0; round < 11; round++) {
+		if (round == 0) {
 			xor_128(round_key, data, ciphertext);
 			next_key(round_key, round);
-		}
-		else if (round == 10)
-		{
+		} else if (round == 10) {
 			byte_sub(ciphertext, intermediatea);
 			shift_row(intermediatea, intermediateb);
 			xor_128(intermediateb, round_key, ciphertext);
-		}
-		else    /* 1 - 9 */
-		{
+		} else {	/* 1 - 9 */
+
 			byte_sub(ciphertext, intermediatea);
 			shift_row(intermediatea, intermediateb);
 			mix_column(&intermediateb[0], &intermediatea[0]);
@@ -416,75 +377,72 @@ void aes128k128d(unsigned char *key, uns
 
 }
 
-void construct_ctr_preload(
-	unsigned char *ctr_preload,
-	int a4_exists,
-	int qc_exists,
-	unsigned char *mpdu,
-	unsigned char *pn_vector,
-	int c)
+void construct_ctr_preload(unsigned char *ctr_preload,
+			   int a4_exists,
+			   int qc_exists,
+			   unsigned char *mpdu, unsigned char *pn_vector, int c)
 {
 
 	int i = 0;
-	for (i=0; i<16; i++) ctr_preload[i] = 0x00;
+	for (i = 0; i < 16; i++)
+		ctr_preload[i] = 0x00;
 	i = 0;
 
-	ctr_preload[0] = 0x01;                                  /* flag */
-	if (qc_exists && a4_exists) ctr_preload[1] = mpdu[30] & 0x0f;   /* QoC_Control  */
-	if (qc_exists && !a4_exists) ctr_preload[1] = mpdu[24] & 0x0f;
+	ctr_preload[0] = 0x01;	/* flag */
+	if (qc_exists && a4_exists)
+		ctr_preload[1] = mpdu[30] & 0x0f;	/* QoC_Control  */
+	if (qc_exists && !a4_exists)
+		ctr_preload[1] = mpdu[24] & 0x0f;
 
 	for (i = 2; i < 8; i++)
-		ctr_preload[i] = mpdu[i + 8];                       /* ctr_preload[2:7] = A2[0:5] = mpdu[10:15] */
+		ctr_preload[i] = mpdu[i + 8];	/* ctr_preload[2:7] = A2[0:5] = mpdu[10:15] */
 #ifdef CONSISTENT_PN_ORDER
-	  for (i = 8; i < 14; i++)
-			ctr_preload[i] =    pn_vector[i - 8];           /* ctr_preload[8:13] = PN[0:5] */
+	for (i = 8; i < 14; i++)
+		ctr_preload[i] = pn_vector[i - 8];	/* ctr_preload[8:13] = PN[0:5] */
 #else
-	  for (i = 8; i < 14; i++)
-			ctr_preload[i] =    pn_vector[13 - i];          /* ctr_preload[8:13] = PN[5:0] */
+	for (i = 8; i < 14; i++)
+		ctr_preload[i] = pn_vector[13 - i];	/* ctr_preload[8:13] = PN[5:0] */
 #endif
-	ctr_preload[14] =  (unsigned char) (c / 256); // Ctr
-	ctr_preload[15] =  (unsigned char) (c % 256);
+	ctr_preload[14] = (unsigned char)(c / 256);	// Ctr
+	ctr_preload[15] = (unsigned char)(c % 256);
 
 }
 
-BOOLEAN RTMPSoftDecryptAES(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR	pData,
-	IN ULONG	DataByteCnt,
-	IN PCIPHER_KEY	pWpaKey)
-{
-	UCHAR			KeyID;
-	UINT			HeaderLen;
-	UCHAR			PN[6];
-	UINT			payload_len;
-	UINT			num_blocks;
-	UINT			payload_remainder;
-	USHORT			fc;
-	UCHAR			fc0;
-	UCHAR			fc1;
-	UINT			frame_type;
-	UINT			frame_subtype;
-	UINT			from_ds;
-	UINT			to_ds;
-	INT				a4_exists;
-	INT				qc_exists;
-	UCHAR			aes_out[16];
-	int			payload_index;
-	UINT			i;
-	UCHAR			ctr_preload[16];
-	UCHAR			chain_buffer[16];
-	UCHAR			padded_buffer[16];
-	UCHAR			mic_iv[16];
-	UCHAR			mic_header1[16];
-	UCHAR			mic_header2[16];
-	UCHAR			MIC[8];
-	UCHAR			TrailMIC[8];
-
+BOOLEAN RTMPSoftDecryptAES(IN PRTMP_ADAPTER pAd,
+			   IN PUCHAR pData,
+			   IN ULONG DataByteCnt, IN PCIPHER_KEY pWpaKey)
+{
+	UCHAR KeyID;
+	UINT HeaderLen;
+	UCHAR PN[6];
+	UINT payload_len;
+	UINT num_blocks;
+	UINT payload_remainder;
+	USHORT fc;
+	UCHAR fc0;
+	UCHAR fc1;
+	UINT frame_type;
+	UINT frame_subtype;
+	UINT from_ds;
+	UINT to_ds;
+	INT a4_exists;
+	INT qc_exists;
+	UCHAR aes_out[16];
+	int payload_index;
+	UINT i;
+	UCHAR ctr_preload[16];
+	UCHAR chain_buffer[16];
+	UCHAR padded_buffer[16];
+	UCHAR mic_iv[16];
+	UCHAR mic_header1[16];
+	UCHAR mic_header2[16];
+	UCHAR MIC[8];
+	UCHAR TrailMIC[8];
 
 	fc0 = *pData;
 	fc1 = *(pData + 1);
 
-	fc = *((PUSHORT)pData);
+	fc = *((PUSHORT) pData);
 
 	frame_type = ((fc0 >> 2) & 0x03);
 	frame_subtype = ((fc0 >> 4) & 0x0f);
@@ -493,49 +451,42 @@ BOOLEAN RTMPSoftDecryptAES(
 	to_ds = (fc1 & 0x1);
 
 	a4_exists = (from_ds & to_ds);
-	qc_exists = ((frame_subtype == 0x08) ||    /* Assumed QoS subtypes */
-				  (frame_subtype == 0x09) ||   /* Likely to change.    */
-				  (frame_subtype == 0x0a) ||
-				  (frame_subtype == 0x0b)
-				 );
+	qc_exists = ((frame_subtype == 0x08) ||	/* Assumed QoS subtypes */
+		     (frame_subtype == 0x09) ||	/* Likely to change.    */
+		     (frame_subtype == 0x0a) || (frame_subtype == 0x0b)
+	    );
 
 	HeaderLen = 24;
 	if (a4_exists)
 		HeaderLen += 6;
 
-	KeyID = *((PUCHAR)(pData+ HeaderLen + 3));
+	KeyID = *((PUCHAR) (pData + HeaderLen + 3));
 	KeyID = KeyID >> 6;
 
-	if (pWpaKey[KeyID].KeyLen == 0)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("RTMPSoftDecryptAES failed!(KeyID[%d] Length can not be 0)\n", KeyID));
+	if (pWpaKey[KeyID].KeyLen == 0) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTMPSoftDecryptAES failed!(KeyID[%d] Length can not be 0)\n",
+			  KeyID));
 		return FALSE;
 	}
 
-	PN[0] = *(pData+ HeaderLen);
-	PN[1] = *(pData+ HeaderLen + 1);
-	PN[2] = *(pData+ HeaderLen + 4);
-	PN[3] = *(pData+ HeaderLen + 5);
-	PN[4] = *(pData+ HeaderLen + 6);
-	PN[5] = *(pData+ HeaderLen + 7);
+	PN[0] = *(pData + HeaderLen);
+	PN[1] = *(pData + HeaderLen + 1);
+	PN[2] = *(pData + HeaderLen + 4);
+	PN[3] = *(pData + HeaderLen + 5);
+	PN[4] = *(pData + HeaderLen + 6);
+	PN[5] = *(pData + HeaderLen + 7);
 
 	payload_len = DataByteCnt - HeaderLen - 8 - 8;	// 8 bytes for CCMP header , 8 bytes for MIC
 	payload_remainder = (payload_len) % 16;
 	num_blocks = (payload_len) / 16;
 
-
-
 	// Find start of payload
-	payload_index = HeaderLen + 8; //IV+EIV
+	payload_index = HeaderLen + 8;	//IV+EIV
 
-	for (i=0; i< num_blocks; i++)
-	{
+	for (i = 0; i < num_blocks; i++) {
 		construct_ctr_preload(ctr_preload,
-								a4_exists,
-								qc_exists,
-								pData,
-								PN,
-								i+1 );
+				      a4_exists, qc_exists, pData, PN, i + 1);
 
 		aes128k128d(pWpaKey[KeyID].Key, ctr_preload, aes_out);
 
@@ -548,34 +499,26 @@ BOOLEAN RTMPSoftDecryptAES(
 	// If there is a short final block, then pad it
 	// encrypt it and copy the unpadded part back
 	//
-	if (payload_remainder > 0)
-	{
+	if (payload_remainder > 0) {
 		construct_ctr_preload(ctr_preload,
-								a4_exists,
-								qc_exists,
-								pData,
-								PN,
-								num_blocks + 1);
+				      a4_exists,
+				      qc_exists, pData, PN, num_blocks + 1);
 
 		NdisZeroMemory(padded_buffer, 16);
-		NdisMoveMemory(padded_buffer, pData + payload_index, payload_remainder);
+		NdisMoveMemory(padded_buffer, pData + payload_index,
+			       payload_remainder);
 
 		aes128k128d(pWpaKey[KeyID].Key, ctr_preload, aes_out);
 
 		bitwise_xor(aes_out, padded_buffer, chain_buffer);
-		NdisMoveMemory(pData + payload_index - 8, chain_buffer, payload_remainder);
+		NdisMoveMemory(pData + payload_index - 8, chain_buffer,
+			       payload_remainder);
 		payload_index += payload_remainder;
 	}
-
 	//
 	// Descrypt the MIC
 	//
-	construct_ctr_preload(ctr_preload,
-							a4_exists,
-							qc_exists,
-							pData,
-							PN,
-							0);
+	construct_ctr_preload(ctr_preload, a4_exists, qc_exists, pData, PN, 0);
 	NdisZeroMemory(padded_buffer, 16);
 	NdisMoveMemory(padded_buffer, pData + payload_index, 8);
 
@@ -585,7 +528,6 @@ BOOLEAN RTMPSoftDecryptAES(
 
 	NdisMoveMemory(TrailMIC, chain_buffer, 8);
 
-
 	//
 	// Calculate MIC
 	//
@@ -597,24 +539,11 @@ BOOLEAN RTMPSoftDecryptAES(
 	// Because the CCMP header has been removed
 	payload_index = HeaderLen;
 
-	construct_mic_iv(
-					mic_iv,
-					qc_exists,
-					a4_exists,
-					pData,
-					payload_len,
-					PN);
-
-	construct_mic_header1(
-						mic_header1,
-						HeaderLen,
-						pData);
-
-	construct_mic_header2(
-						mic_header2,
-						pData,
-						a4_exists,
-						qc_exists);
+	construct_mic_iv(mic_iv, qc_exists, a4_exists, pData, payload_len, PN);
+
+	construct_mic_header1(mic_header1, HeaderLen, pData);
+
+	construct_mic_header2(mic_header2, pData, a4_exists, qc_exists);
 
 	aes128k128d(pWpaKey[KeyID].Key, mic_iv, aes_out);
 	bitwise_xor(aes_out, mic_header1, chain_buffer);
@@ -623,34 +552,31 @@ BOOLEAN RTMPSoftDecryptAES(
 	aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
 
 	// iterate through each 16 byte payload block
-	for (i = 0; i < num_blocks; i++)
-	{
+	for (i = 0; i < num_blocks; i++) {
 		bitwise_xor(aes_out, pData + payload_index, chain_buffer);
 		payload_index += 16;
 		aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
 	}
 
 	// Add on the final payload block if it needs padding
-	if (payload_remainder > 0)
-	{
+	if (payload_remainder > 0) {
 		NdisZeroMemory(padded_buffer, 16);
-		NdisMoveMemory(padded_buffer, pData + payload_index, payload_remainder);
+		NdisMoveMemory(padded_buffer, pData + payload_index,
+			       payload_remainder);
 
 		bitwise_xor(aes_out, padded_buffer, chain_buffer);
 		aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
 	}
-
 	// aes_out contains padded mic, discard most significant
 	// 8 bytes to generate 64 bit MIC
-	for (i = 0 ; i < 8; i++) MIC[i] = aes_out[i];
+	for (i = 0; i < 8; i++)
+		MIC[i] = aes_out[i];
 
-	if (!NdisEqualMemory(MIC, TrailMIC, 8))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptAES, MIC Error !\n"));	 //MIC error.
+	if (!NdisEqualMemory(MIC, TrailMIC, 8)) {
+		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptAES, MIC Error !\n"));	//MIC error.
 		return FALSE;
 	}
 
-
 	return TRUE;
 }
 
@@ -664,40 +590,39 @@ BOOLEAN RTMPSoftDecryptAES(
 #endif
 
 /* forward S-box */
-static uint32 FSb[256] =
-{
-	0x63, 0x7C,	0x77, 0x7B,	0xF2, 0x6B,	0x6F, 0xC5,
-	0x30, 0x01,	0x67, 0x2B,	0xFE, 0xD7,	0xAB, 0x76,
-	0xCA, 0x82,	0xC9, 0x7D,	0xFA, 0x59,	0x47, 0xF0,
-	0xAD, 0xD4,	0xA2, 0xAF,	0x9C, 0xA4,	0x72, 0xC0,
-	0xB7, 0xFD,	0x93, 0x26,	0x36, 0x3F,	0xF7, 0xCC,
-	0x34, 0xA5,	0xE5, 0xF1,	0x71, 0xD8,	0x31, 0x15,
-	0x04, 0xC7,	0x23, 0xC3,	0x18, 0x96,	0x05, 0x9A,
-	0x07, 0x12,	0x80, 0xE2,	0xEB, 0x27,	0xB2, 0x75,
-	0x09, 0x83,	0x2C, 0x1A,	0x1B, 0x6E,	0x5A, 0xA0,
-	0x52, 0x3B,	0xD6, 0xB3,	0x29, 0xE3,	0x2F, 0x84,
-	0x53, 0xD1,	0x00, 0xED,	0x20, 0xFC,	0xB1, 0x5B,
-	0x6A, 0xCB,	0xBE, 0x39,	0x4A, 0x4C,	0x58, 0xCF,
-	0xD0, 0xEF,	0xAA, 0xFB,	0x43, 0x4D,	0x33, 0x85,
-	0x45, 0xF9,	0x02, 0x7F,	0x50, 0x3C,	0x9F, 0xA8,
-	0x51, 0xA3,	0x40, 0x8F,	0x92, 0x9D,	0x38, 0xF5,
-	0xBC, 0xB6,	0xDA, 0x21,	0x10, 0xFF,	0xF3, 0xD2,
-	0xCD, 0x0C,	0x13, 0xEC,	0x5F, 0x97,	0x44, 0x17,
-	0xC4, 0xA7,	0x7E, 0x3D,	0x64, 0x5D,	0x19, 0x73,
-	0x60, 0x81,	0x4F, 0xDC,	0x22, 0x2A,	0x90, 0x88,
-	0x46, 0xEE,	0xB8, 0x14,	0xDE, 0x5E,	0x0B, 0xDB,
-	0xE0, 0x32,	0x3A, 0x0A,	0x49, 0x06,	0x24, 0x5C,
-	0xC2, 0xD3,	0xAC, 0x62,	0x91, 0x95,	0xE4, 0x79,
-	0xE7, 0xC8,	0x37, 0x6D,	0x8D, 0xD5,	0x4E, 0xA9,
-	0x6C, 0x56,	0xF4, 0xEA,	0x65, 0x7A,	0xAE, 0x08,
-	0xBA, 0x78,	0x25, 0x2E,	0x1C, 0xA6,	0xB4, 0xC6,
-	0xE8, 0xDD,	0x74, 0x1F,	0x4B, 0xBD,	0x8B, 0x8A,
-	0x70, 0x3E,	0xB5, 0x66,	0x48, 0x03,	0xF6, 0x0E,
-	0x61, 0x35,	0x57, 0xB9,	0x86, 0xC1,	0x1D, 0x9E,
-	0xE1, 0xF8,	0x98, 0x11,	0x69, 0xD9,	0x8E, 0x94,
-	0x9B, 0x1E,	0x87, 0xE9,	0xCE, 0x55,	0x28, 0xDF,
-	0x8C, 0xA1,	0x89, 0x0D,	0xBF, 0xE6,	0x42, 0x68,
-	0x41, 0x99,	0x2D, 0x0F,	0xB0, 0x54,	0xBB, 0x16
+static uint32 FSb[256] = {
+	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
+	0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
+	0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
+	0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
+	0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
+	0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
+	0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
+	0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
+	0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
+	0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
+	0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
+	0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
+	0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
+	0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
+	0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
+	0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
+	0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
 };
 
 /* forward table */
@@ -770,58 +695,61 @@ static uint32 FSb[256] =
 
 #define	V(a,b,c,d) 0x##a##b##c##d
 static uint32 FT0[256] = { FT };
+
 #undef V
 
 #define	V(a,b,c,d) 0x##d##a##b##c
 static uint32 FT1[256] = { FT };
+
 #undef V
 
 #define	V(a,b,c,d) 0x##c##d##a##b
 static uint32 FT2[256] = { FT };
+
 #undef V
 
 #define	V(a,b,c,d) 0x##b##c##d##a
 static uint32 FT3[256] = { FT };
+
 #undef V
 
 #undef FT
 
 /* reverse S-box */
 
-static uint32 RSb[256] =
-{
-	0x52, 0x09,	0x6A, 0xD5,	0x30, 0x36,	0xA5, 0x38,
-	0xBF, 0x40,	0xA3, 0x9E,	0x81, 0xF3,	0xD7, 0xFB,
-	0x7C, 0xE3,	0x39, 0x82,	0x9B, 0x2F,	0xFF, 0x87,
-	0x34, 0x8E,	0x43, 0x44,	0xC4, 0xDE,	0xE9, 0xCB,
-	0x54, 0x7B,	0x94, 0x32,	0xA6, 0xC2,	0x23, 0x3D,
-	0xEE, 0x4C,	0x95, 0x0B,	0x42, 0xFA,	0xC3, 0x4E,
-	0x08, 0x2E,	0xA1, 0x66,	0x28, 0xD9,	0x24, 0xB2,
-	0x76, 0x5B,	0xA2, 0x49,	0x6D, 0x8B,	0xD1, 0x25,
-	0x72, 0xF8,	0xF6, 0x64,	0x86, 0x68,	0x98, 0x16,
-	0xD4, 0xA4,	0x5C, 0xCC,	0x5D, 0x65,	0xB6, 0x92,
-	0x6C, 0x70,	0x48, 0x50,	0xFD, 0xED,	0xB9, 0xDA,
-	0x5E, 0x15,	0x46, 0x57,	0xA7, 0x8D,	0x9D, 0x84,
-	0x90, 0xD8,	0xAB, 0x00,	0x8C, 0xBC,	0xD3, 0x0A,
-	0xF7, 0xE4,	0x58, 0x05,	0xB8, 0xB3,	0x45, 0x06,
-	0xD0, 0x2C,	0x1E, 0x8F,	0xCA, 0x3F,	0x0F, 0x02,
-	0xC1, 0xAF,	0xBD, 0x03,	0x01, 0x13,	0x8A, 0x6B,
-	0x3A, 0x91,	0x11, 0x41,	0x4F, 0x67,	0xDC, 0xEA,
-	0x97, 0xF2,	0xCF, 0xCE,	0xF0, 0xB4,	0xE6, 0x73,
-	0x96, 0xAC,	0x74, 0x22,	0xE7, 0xAD,	0x35, 0x85,
-	0xE2, 0xF9,	0x37, 0xE8,	0x1C, 0x75,	0xDF, 0x6E,
-	0x47, 0xF1,	0x1A, 0x71,	0x1D, 0x29,	0xC5, 0x89,
-	0x6F, 0xB7,	0x62, 0x0E,	0xAA, 0x18,	0xBE, 0x1B,
-	0xFC, 0x56,	0x3E, 0x4B,	0xC6, 0xD2,	0x79, 0x20,
-	0x9A, 0xDB,	0xC0, 0xFE,	0x78, 0xCD,	0x5A, 0xF4,
-	0x1F, 0xDD,	0xA8, 0x33,	0x88, 0x07,	0xC7, 0x31,
-	0xB1, 0x12,	0x10, 0x59,	0x27, 0x80,	0xEC, 0x5F,
-	0x60, 0x51,	0x7F, 0xA9,	0x19, 0xB5,	0x4A, 0x0D,
-	0x2D, 0xE5,	0x7A, 0x9F,	0x93, 0xC9,	0x9C, 0xEF,
-	0xA0, 0xE0,	0x3B, 0x4D,	0xAE, 0x2A,	0xF5, 0xB0,
-	0xC8, 0xEB,	0xBB, 0x3C,	0x83, 0x53,	0x99, 0x61,
-	0x17, 0x2B,	0x04, 0x7E,	0xBA, 0x77,	0xD6, 0x26,
-	0xE1, 0x69,	0x14, 0x63,	0x55, 0x21,	0x0C, 0x7D
+static uint32 RSb[256] = {
+	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
+	0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
+	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
+	0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
+	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
+	0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
+	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
+	0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
+	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
+	0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
+	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
+	0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
+	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
+	0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
+	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
+	0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
+	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
+	0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
+	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
+	0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
+	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
+	0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
+	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
+	0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
+	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
+	0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
+	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
+	0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
+	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
+	0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
+	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
+	0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
 };
 
 /* reverse table */
@@ -895,29 +823,32 @@ static uint32 RSb[256] =
 
 #define	V(a,b,c,d) 0x##a##b##c##d
 static uint32 RT0[256] = { RT };
+
 #undef V
 
 #define	V(a,b,c,d) 0x##d##a##b##c
 static uint32 RT1[256] = { RT };
+
 #undef V
 
 #define	V(a,b,c,d) 0x##c##d##a##b
 static uint32 RT2[256] = { RT };
+
 #undef V
 
 #define	V(a,b,c,d) 0x##b##c##d##a
 static uint32 RT3[256] = { RT };
+
 #undef V
 
 #undef RT
 
 /* round constants */
 
-static uint32 RCON[10] =
-{
-	0x01000000,	0x02000000,	0x04000000,	0x08000000,
-	0x10000000,	0x20000000,	0x40000000,	0x80000000,
-	0x1B000000,	0x36000000
+static uint32 RCON[10] = {
+	0x01000000, 0x02000000, 0x04000000, 0x08000000,
+	0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	0x1B000000, 0x36000000
 };
 
 /* key schedule	tables */
@@ -947,60 +878,61 @@ static uint32 KT3[256];
 	(b)[(i)	+ 3] = (uint8) ( (n)	   );		\
 }
 
-
-int	rt_aes_set_key( aes_context *ctx, uint8 *key, int nbits )
+int rt_aes_set_key(aes_context * ctx, uint8 * key, int nbits)
 {
-	int	i;
-	uint32 *RK,	*SK;
+	int i;
+	uint32 *RK, *SK;
 
-	switch(	nbits )
-	{
-		case 128: ctx->nr =	10;	break;
-		case 192: ctx->nr =	12;	break;
-		case 256: ctx->nr =	14;	break;
-		default	: return( 1	);
+	switch (nbits) {
+	case 128:
+		ctx->nr = 10;
+		break;
+	case 192:
+		ctx->nr = 12;
+		break;
+	case 256:
+		ctx->nr = 14;
+		break;
+	default:
+		return (1);
 	}
 
 	RK = (uint32 *) ctx->erk;
 
-	for( i = 0;	i <	(nbits >> 5); i++ )
-	{
-		GET_UINT32(	RK[i], key,	i *	4 );
+	for (i = 0; i < (nbits >> 5); i++) {
+		GET_UINT32(RK[i], key, i * 4);
 	}
 
-	/* setup encryption	round keys */
+	/* setup encryption     round keys */
 
-	switch(	nbits )
-	{
+	switch (nbits) {
 	case 128:
 
-		for( i = 0;	i <	10;	i++, RK	+= 4 )
-		{
-			RK[4]  = RK[0] ^ RCON[i] ^
-						( FSb[ (uint8) ( RK[3] >> 16 ) ] <<	24 ) ^
-						( FSb[ (uint8) ( RK[3] >>  8 ) ] <<	16 ) ^
-						( FSb[ (uint8) ( RK[3]		 ) ] <<	 8 ) ^
-						( FSb[ (uint8) ( RK[3] >> 24 ) ]	   );
-
-			RK[5]  = RK[1] ^ RK[4];
-			RK[6]  = RK[2] ^ RK[5];
-			RK[7]  = RK[3] ^ RK[6];
+		for (i = 0; i < 10; i++, RK += 4) {
+			RK[4] = RK[0] ^ RCON[i] ^
+			    (FSb[(uint8) (RK[3] >> 16)] << 24) ^
+			    (FSb[(uint8) (RK[3] >> 8)] << 16) ^
+			    (FSb[(uint8) (RK[3])] << 8) ^
+			    (FSb[(uint8) (RK[3] >> 24)]);
+
+			RK[5] = RK[1] ^ RK[4];
+			RK[6] = RK[2] ^ RK[5];
+			RK[7] = RK[3] ^ RK[6];
 		}
 		break;
 
 	case 192:
 
-		for( i = 0;	i <	8; i++,	RK += 6	)
-		{
-			RK[6]  = RK[0] ^ RCON[i] ^
-						( FSb[ (uint8) ( RK[5] >> 16 ) ] <<	24 ) ^
-						( FSb[ (uint8) ( RK[5] >>  8 ) ] <<	16 ) ^
-						( FSb[ (uint8) ( RK[5]		 ) ] <<	 8 ) ^
-						( FSb[ (uint8) ( RK[5] >> 24 ) ]	   );
-
-			RK[7]  = RK[1] ^ RK[6];
-			RK[8]  = RK[2] ^ RK[7];
-			RK[9]  = RK[3] ^ RK[8];
+		for (i = 0; i < 8; i++, RK += 6) {
+			RK[6] = RK[0] ^ RCON[i] ^
+			    (FSb[(uint8) (RK[5] >> 16)] << 24) ^
+			    (FSb[(uint8) (RK[5] >> 8)] << 16) ^
+			    (FSb[(uint8) (RK[5])] << 8) ^
+			    (FSb[(uint8) (RK[5] >> 24)]);
+
+			RK[7] = RK[1] ^ RK[6];
+			RK[8] = RK[2] ^ RK[7];
+			RK[9] = RK[3] ^ RK[8];
 			RK[10] = RK[4] ^ RK[9];
 			RK[11] = RK[5] ^ RK[10];
 		}
@@ -1008,23 +940,22 @@ int	rt_aes_set_key( aes_context *ctx, ui
 
 	case 256:
 
-		for( i = 0;	i <	7; i++,	RK += 8	)
-		{
-			RK[8]  = RK[0] ^ RCON[i] ^
-						( FSb[ (uint8) ( RK[7] >> 16 ) ] <<	24 ) ^
-						( FSb[ (uint8) ( RK[7] >>  8 ) ] <<	16 ) ^
-						( FSb[ (uint8) ( RK[7]		 ) ] <<	 8 ) ^
-						( FSb[ (uint8) ( RK[7] >> 24 ) ]	   );
+		for (i = 0; i < 7; i++, RK += 8) {
+			RK[8] = RK[0] ^ RCON[i] ^
+			    (FSb[(uint8) (RK[7] >> 16)] << 24) ^
+			    (FSb[(uint8) (RK[7] >> 8)] << 16) ^
+			    (FSb[(uint8) (RK[7])] << 8) ^
+			    (FSb[(uint8) (RK[7] >> 24)]);
 
-			RK[9]  = RK[1] ^ RK[8];
+			RK[9] = RK[1] ^ RK[8];
 			RK[10] = RK[2] ^ RK[9];
 			RK[11] = RK[3] ^ RK[10];
 
 			RK[12] = RK[4] ^
-						( FSb[ (uint8) ( RK[11]	>> 24 )	] << 24	) ^
-						( FSb[ (uint8) ( RK[11]	>> 16 )	] << 16	) ^
-						( FSb[ (uint8) ( RK[11]	>>	8 )	] <<  8	) ^
-						( FSb[ (uint8) ( RK[11]		  )	]		);
+			    (FSb[(uint8) (RK[11] >> 24)] << 24) ^
+			    (FSb[(uint8) (RK[11] >> 16)] << 16) ^
+			    (FSb[(uint8) (RK[11] >> 8)] << 8) ^
+			    (FSb[(uint8) (RK[11])]);
 
 			RK[13] = RK[5] ^ RK[12];
 			RK[14] = RK[6] ^ RK[13];
@@ -1033,74 +964,75 @@ int	rt_aes_set_key( aes_context *ctx, ui
 		break;
 	}
 
-	/* setup decryption	round keys */
+	/* setup decryption     round keys */
 
-	if(	KT_init	)
-	{
-		for( i = 0;	i <	256; i++ )
-		{
-			KT0[i] = RT0[ FSb[i] ];
-			KT1[i] = RT1[ FSb[i] ];
-			KT2[i] = RT2[ FSb[i] ];
-			KT3[i] = RT3[ FSb[i] ];
+	if (KT_init) {
+		for (i = 0; i < 256; i++) {
+			KT0[i] = RT0[FSb[i]];
+			KT1[i] = RT1[FSb[i]];
+			KT2[i] = RT2[FSb[i]];
+			KT3[i] = RT3[FSb[i]];
 		}
 
-		KT_init	= 0;
+		KT_init = 0;
 	}
 
 	SK = (uint32 *) ctx->drk;
 
-	*SK++ =	*RK++;
-	*SK++ =	*RK++;
-	*SK++ =	*RK++;
-	*SK++ =	*RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
 
-	for( i = 1;	i <	ctx->nr; i++ )
-	{
+	for (i = 1; i < ctx->nr; i++) {
 		RK -= 8;
 
-		*SK++ =	KT0[ (uint8) ( *RK >> 24 ) ] ^
-				KT1[ (uint8) ( *RK >> 16 ) ] ^
-				KT2[ (uint8) ( *RK >>  8 ) ] ^
-				KT3[ (uint8) ( *RK		 ) ]; RK++;
-
-		*SK++ =	KT0[ (uint8) ( *RK >> 24 ) ] ^
-				KT1[ (uint8) ( *RK >> 16 ) ] ^
-				KT2[ (uint8) ( *RK >>  8 ) ] ^
-				KT3[ (uint8) ( *RK		 ) ]; RK++;
-
-		*SK++ =	KT0[ (uint8) ( *RK >> 24 ) ] ^
-				KT1[ (uint8) ( *RK >> 16 ) ] ^
-				KT2[ (uint8) ( *RK >>  8 ) ] ^
-				KT3[ (uint8) ( *RK		 ) ]; RK++;
-
-		*SK++ =	KT0[ (uint8) ( *RK >> 24 ) ] ^
-				KT1[ (uint8) ( *RK >> 16 ) ] ^
-				KT2[ (uint8) ( *RK >>  8 ) ] ^
-				KT3[ (uint8) ( *RK		 ) ]; RK++;
+		*SK++ = KT0[(uint8) (*RK >> 24)] ^
+		    KT1[(uint8) (*RK >> 16)] ^
+		    KT2[(uint8) (*RK >> 8)] ^ KT3[(uint8) (*RK)];
+		RK++;
+
+		*SK++ = KT0[(uint8) (*RK >> 24)] ^
+		    KT1[(uint8) (*RK >> 16)] ^
+		    KT2[(uint8) (*RK >> 8)] ^ KT3[(uint8) (*RK)];
+		RK++;
+
+		*SK++ = KT0[(uint8) (*RK >> 24)] ^
+		    KT1[(uint8) (*RK >> 16)] ^
+		    KT2[(uint8) (*RK >> 8)] ^ KT3[(uint8) (*RK)];
+		RK++;
+
+		*SK++ = KT0[(uint8) (*RK >> 24)] ^
+		    KT1[(uint8) (*RK >> 16)] ^
+		    KT2[(uint8) (*RK >> 8)] ^ KT3[(uint8) (*RK)];
+		RK++;
 	}
 
 	RK -= 8;
 
-	*SK++ =	*RK++;
-	*SK++ =	*RK++;
-	*SK++ =	*RK++;
-	*SK++ =	*RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
 
-	return(	0 );
+	return (0);
 }
 
 /* AES 128-bit block encryption	routine	*/
 
-void rt_aes_encrypt(aes_context *ctx, uint8 input[16],	uint8 output[16] )
+void rt_aes_encrypt(aes_context * ctx, uint8 input[16], uint8 output[16])
 {
-	uint32 *RK,	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3;
+	uint32 *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
 
 	RK = (uint32 *) ctx->erk;
-	GET_UINT32(	X0,	input,	0 ); X0	^= RK[0];
-	GET_UINT32(	X1,	input,	4 ); X1	^= RK[1];
-	GET_UINT32(	X2,	input,	8 ); X2	^= RK[2];
-	GET_UINT32(	X3,	input, 12 ); X3	^= RK[3];
+	GET_UINT32(X0, input, 0);
+	X0 ^= RK[0];
+	GET_UINT32(X1, input, 4);
+	X1 ^= RK[1];
+	GET_UINT32(X2, input, 8);
+	X2 ^= RK[2];
+	GET_UINT32(X3, input, 12);
+	X3 ^= RK[3];
 
 #define	AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)		\
 {												\
@@ -1127,70 +1059,68 @@ void rt_aes_encrypt(aes_context *ctx, ui
 				 FT3[ (uint8) (	Y2		 ) ];	\
 }
 
-	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 1 */
-	AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 2 */
-	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 3 */
-	AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 4 */
-	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 5 */
-	AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 6 */
-	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 7 */
-	AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 8 */
-	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 9 */
-
-	if(	ctx->nr	> 10 )
-	{
-		AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );	/* round 10	*/
-		AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );	/* round 11	*/
-	}
-
-	if(	ctx->nr	> 12 )
-	{
-		AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );	/* round 12	*/
-		AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );	/* round 13	*/
+	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 1 */
+	AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 2 */
+	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 3 */
+	AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 4 */
+	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 5 */
+	AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 6 */
+	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 7 */
+	AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 8 */
+	AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 9 */
+
+	if (ctx->nr > 10) {
+		AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 10     */
+		AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 11     */
+	}
+
+	if (ctx->nr > 12) {
+		AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 12     */
+		AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 13     */
 	}
 
-	/* last	round */
+	/* last round */
 
 	RK += 4;
 
-	X0 = RK[0] ^ ( FSb[	(uint8)	( Y0 >>	24 ) ] << 24 ) ^
-				 ( FSb[	(uint8)	( Y1 >>	16 ) ] << 16 ) ^
-				 ( FSb[	(uint8)	( Y2 >>	 8 ) ] <<  8 ) ^
-				 ( FSb[	(uint8)	( Y3	   ) ]		 );
-
-	X1 = RK[1] ^ ( FSb[	(uint8)	( Y1 >>	24 ) ] << 24 ) ^
-				 ( FSb[	(uint8)	( Y2 >>	16 ) ] << 16 ) ^
-				 ( FSb[	(uint8)	( Y3 >>	 8 ) ] <<  8 ) ^
-				 ( FSb[	(uint8)	( Y0	   ) ]		 );
-
-	X2 = RK[2] ^ ( FSb[	(uint8)	( Y2 >>	24 ) ] << 24 ) ^
-				 ( FSb[	(uint8)	( Y3 >>	16 ) ] << 16 ) ^
-				 ( FSb[	(uint8)	( Y0 >>	 8 ) ] <<  8 ) ^
-				 ( FSb[	(uint8)	( Y1	   ) ]		 );
-
-	X3 = RK[3] ^ ( FSb[	(uint8)	( Y3 >>	24 ) ] << 24 ) ^
-				 ( FSb[	(uint8)	( Y0 >>	16 ) ] << 16 ) ^
-				 ( FSb[	(uint8)	( Y1 >>	 8 ) ] <<  8 ) ^
-				 ( FSb[	(uint8)	( Y2	   ) ]		 );
-
-	PUT_UINT32(	X0,	output,	 0 );
-	PUT_UINT32(	X1,	output,	 4 );
-	PUT_UINT32(	X2,	output,	 8 );
-	PUT_UINT32(	X3,	output,	12 );
+	X0 = RK[0] ^ (FSb[(uint8) (Y0 >> 24)] << 24) ^
+	    (FSb[(uint8) (Y1 >> 16)] << 16) ^
+	    (FSb[(uint8) (Y2 >> 8)] << 8) ^ (FSb[(uint8) (Y3)]);
+
+	X1 = RK[1] ^ (FSb[(uint8) (Y1 >> 24)] << 24) ^
+	    (FSb[(uint8) (Y2 >> 16)] << 16) ^
+	    (FSb[(uint8) (Y3 >> 8)] << 8) ^ (FSb[(uint8) (Y0)]);
+
+	X2 = RK[2] ^ (FSb[(uint8) (Y2 >> 24)] << 24) ^
+	    (FSb[(uint8) (Y3 >> 16)] << 16) ^
+	    (FSb[(uint8) (Y0 >> 8)] << 8) ^ (FSb[(uint8) (Y1)]);
+
+	X3 = RK[3] ^ (FSb[(uint8) (Y3 >> 24)] << 24) ^
+	    (FSb[(uint8) (Y0 >> 16)] << 16) ^
+	    (FSb[(uint8) (Y1 >> 8)] << 8) ^ (FSb[(uint8) (Y2)]);
+
+	PUT_UINT32(X0, output, 0);
+	PUT_UINT32(X1, output, 4);
+	PUT_UINT32(X2, output, 8);
+	PUT_UINT32(X3, output, 12);
 }
 
 /* AES 128-bit block decryption	routine	*/
 
-void rt_aes_decrypt( aes_context *ctx,	uint8 input[16], uint8 output[16] )
+void rt_aes_decrypt(aes_context * ctx, uint8 input[16], uint8 output[16])
 {
-	uint32 *RK,	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3;
+	uint32 *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
 
 	RK = (uint32 *) ctx->drk;
 
-	GET_UINT32(	X0,	input,	0 ); X0	^= RK[0];
-	GET_UINT32(	X1,	input,	4 ); X1	^= RK[1];
-	GET_UINT32(	X2,	input,	8 ); X2	^= RK[2];
-	GET_UINT32(	X3,	input, 12 ); X3	^= RK[3];
+	GET_UINT32(X0, input, 0);
+	X0 ^= RK[0];
+	GET_UINT32(X1, input, 4);
+	X1 ^= RK[1];
+	GET_UINT32(X2, input, 8);
+	X2 ^= RK[2];
+	GET_UINT32(X3, input, 12);
+	X3 ^= RK[3];
 
 #define	AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)		\
 {												\
@@ -1217,56 +1147,50 @@ void rt_aes_decrypt( aes_context *ctx,	u
 				 RT3[ (uint8) (	Y0		 ) ];	\
 }
 
-	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 1 */
-	AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 2 */
-	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 3 */
-	AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 4 */
-	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 5 */
-	AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 6 */
-	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 7 */
-	AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 8 */
-	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 9 */
-
-	if(	ctx->nr	> 10 )
-	{
-		AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );	/* round 10	*/
-		AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );	/* round 11	*/
-	}
-
-	if(	ctx->nr	> 12 )
-	{
-		AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );	/* round 12	*/
-		AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );	/* round 13	*/
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 1 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 2 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 3 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 4 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 5 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 6 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 7 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 8 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 9 */
+
+	if (ctx->nr > 10) {
+		AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 10     */
+		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 11     */
+	}
+
+	if (ctx->nr > 12) {
+		AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);	/* round 12     */
+		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);	/* round 13     */
 	}
 
-	/* last	round */
+	/* last round */
 
 	RK += 4;
 
-	X0 = RK[0] ^ ( RSb[	(uint8)	( Y0 >>	24 ) ] << 24 ) ^
-				 ( RSb[	(uint8)	( Y3 >>	16 ) ] << 16 ) ^
-				 ( RSb[	(uint8)	( Y2 >>	 8 ) ] <<  8 ) ^
-				 ( RSb[	(uint8)	( Y1	   ) ]		 );
-
-	X1 = RK[1] ^ ( RSb[	(uint8)	( Y1 >>	24 ) ] << 24 ) ^
-				 ( RSb[	(uint8)	( Y0 >>	16 ) ] << 16 ) ^
-				 ( RSb[	(uint8)	( Y3 >>	 8 ) ] <<  8 ) ^
-				 ( RSb[	(uint8)	( Y2	   ) ]		 );
-
-	X2 = RK[2] ^ ( RSb[	(uint8)	( Y2 >>	24 ) ] << 24 ) ^
-				 ( RSb[	(uint8)	( Y1 >>	16 ) ] << 16 ) ^
-				 ( RSb[	(uint8)	( Y0 >>	 8 ) ] <<  8 ) ^
-				 ( RSb[	(uint8)	( Y3	   ) ]		 );
-
-	X3 = RK[3] ^ ( RSb[	(uint8)	( Y3 >>	24 ) ] << 24 ) ^
-				 ( RSb[	(uint8)	( Y2 >>	16 ) ] << 16 ) ^
-				 ( RSb[	(uint8)	( Y1 >>	 8 ) ] <<  8 ) ^
-				 ( RSb[	(uint8)	( Y0	   ) ]		 );
-
-	PUT_UINT32(	X0,	output,	 0 );
-	PUT_UINT32(	X1,	output,	 4 );
-	PUT_UINT32(	X2,	output,	 8 );
-	PUT_UINT32(	X3,	output,	12 );
+	X0 = RK[0] ^ (RSb[(uint8) (Y0 >> 24)] << 24) ^
+	    (RSb[(uint8) (Y3 >> 16)] << 16) ^
+	    (RSb[(uint8) (Y2 >> 8)] << 8) ^ (RSb[(uint8) (Y1)]);
+
+	X1 = RK[1] ^ (RSb[(uint8) (Y1 >> 24)] << 24) ^
+	    (RSb[(uint8) (Y0 >> 16)] << 16) ^
+	    (RSb[(uint8) (Y3 >> 8)] << 8) ^ (RSb[(uint8) (Y2)]);
+
+	X2 = RK[2] ^ (RSb[(uint8) (Y2 >> 24)] << 24) ^
+	    (RSb[(uint8) (Y1 >> 16)] << 16) ^
+	    (RSb[(uint8) (Y0 >> 8)] << 8) ^ (RSb[(uint8) (Y3)]);
+
+	X3 = RK[3] ^ (RSb[(uint8) (Y3 >> 24)] << 24) ^
+	    (RSb[(uint8) (Y2 >> 16)] << 16) ^
+	    (RSb[(uint8) (Y1 >> 8)] << 8) ^ (RSb[(uint8) (Y0)]);
+
+	PUT_UINT32(X0, output, 0);
+	PUT_UINT32(X1, output, 4);
+	PUT_UINT32(X2, output, 8);
+	PUT_UINT32(X3, output, 12);
 }
 
 /*
@@ -1278,57 +1202,51 @@ void rt_aes_decrypt( aes_context *ctx,	u
     Return:
     ==========================================================================
 */
-VOID AES_GTK_KEY_WRAP(
-    IN UCHAR    *key,
-    IN UCHAR    *plaintext,
-    IN UINT32    p_len,
-    OUT UCHAR   *ciphertext)
-{
-    UCHAR       A[8], BIN[16], BOUT[16];
-    UCHAR       R[512];
-    INT         num_blocks = p_len/8;   // unit:64bits
-    INT         i, j;
-    aes_context aesctx;
-    UCHAR       xor;
-
-    rt_aes_set_key(&aesctx, key, 128);
-
-    // Init IA
-    for (i = 0; i < 8; i++)
-        A[i] = 0xa6;
-
-    //Input plaintext
-    for (i = 0; i < num_blocks; i++)
-    {
-        for (j = 0 ; j < 8; j++)
-            R[8 * (i + 1) + j] = plaintext[8 * i + j];
-    }
-
-    // Key Mix
-    for (j = 0; j < 6; j++)
-    {
-        for(i = 1; i <= num_blocks; i++)
-        {
-            //phase 1
-            NdisMoveMemory(BIN, A, 8);
-            NdisMoveMemory(&BIN[8], &R[8 * i], 8);
-            rt_aes_encrypt(&aesctx, BIN, BOUT);
-
-            NdisMoveMemory(A, &BOUT[0], 8);
-            xor = num_blocks * j + i;
-            A[7] = BOUT[7] ^ xor;
-            NdisMoveMemory(&R[8 * i], &BOUT[8], 8);
-        }
-    }
-
-    // Output ciphertext
-    NdisMoveMemory(ciphertext, A, 8);
-
-    for (i = 1; i <= num_blocks; i++)
-    {
-        for (j = 0 ; j < 8; j++)
-            ciphertext[8 * i + j] = R[8 * i + j];
-    }
+VOID AES_GTK_KEY_WRAP(IN UCHAR * key,
+		      IN UCHAR * plaintext,
+		      IN UINT32 p_len, OUT UCHAR * ciphertext)
+{
+	UCHAR A[8], BIN[16], BOUT[16];
+	UCHAR R[512];
+	INT num_blocks = p_len / 8;	// unit:64bits
+	INT i, j;
+	aes_context aesctx;
+	UCHAR xor;
+
+	rt_aes_set_key(&aesctx, key, 128);
+
+	// Init IA
+	for (i = 0; i < 8; i++)
+		A[i] = 0xa6;
+
+	//Input plaintext
+	for (i = 0; i < num_blocks; i++) {
+		for (j = 0; j < 8; j++)
+			R[8 * (i + 1) + j] = plaintext[8 * i + j];
+	}
+
+	// Key Mix
+	for (j = 0; j < 6; j++) {
+		for (i = 1; i <= num_blocks; i++) {
+			//phase 1
+			NdisMoveMemory(BIN, A, 8);
+			NdisMoveMemory(&BIN[8], &R[8 * i], 8);
+			rt_aes_encrypt(&aesctx, BIN, BOUT);
+
+			NdisMoveMemory(A, &BOUT[0], 8);
+			xor = num_blocks * j + i;
+			A[7] = BOUT[7] ^ xor;
+			NdisMoveMemory(&R[8 * i], &BOUT[8], 8);
+		}
+	}
+
+	// Output ciphertext
+	NdisMoveMemory(ciphertext, A, 8);
+
+	for (i = 1; i <= num_blocks; i++) {
+		for (j = 0; j < 8; j++)
+			ciphertext[8 * i + j] = R[8 * i + j];
+	}
 }
 
 /*
@@ -1346,59 +1264,50 @@ VOID AES_GTK_KEY_WRAP(
 
 	========================================================================
 */
-VOID	AES_GTK_KEY_UNWRAP(
-	IN	UCHAR	*key,
-	OUT	UCHAR	*plaintext,
-	IN	UINT32   c_len,
-	IN	UCHAR	*ciphertext)
-
-{
-	UCHAR       A[8], BIN[16], BOUT[16];
-	UCHAR       xor;
-	INT         i, j;
+VOID AES_GTK_KEY_UNWRAP(IN UCHAR * key,
+			OUT UCHAR * plaintext,
+			IN UINT32 c_len, IN UCHAR * ciphertext)
+{
+	UCHAR A[8], BIN[16], BOUT[16];
+	UCHAR xor;
+	INT i, j;
 	aes_context aesctx;
-	UCHAR       *R;
-	INT         num_blocks = c_len/8;	// unit:64bits
+	UCHAR *R;
+	INT num_blocks = c_len / 8;	// unit:64bits
 
+	os_alloc_mem(NULL, (PUCHAR *) & R, 512);
 
-	os_alloc_mem(NULL, (PUCHAR *)&R, 512);
-
-	if (R == NULL)
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("!!!AES_GTK_KEY_UNWRAP: no memory!!!\n"));
-        return;
-    } /* End of if */
-
+	if (R == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("!!!AES_GTK_KEY_UNWRAP: no memory!!!\n"));
+		return;
+	}
+	/* End of if */
 	// Initialize
 	NdisMoveMemory(A, ciphertext, 8);
 	//Input plaintext
-	for(i = 0; i < (c_len-8); i++)
-	{
-		R[ i] = ciphertext[i + 8];
+	for (i = 0; i < (c_len - 8); i++) {
+		R[i] = ciphertext[i + 8];
 	}
 
 	rt_aes_set_key(&aesctx, key, 128);
 
-	for(j = 5; j >= 0; j--)
-	{
-		for(i = (num_blocks-1); i > 0; i--)
-		{
-			xor = (num_blocks -1 )* j + i;
+	for (j = 5; j >= 0; j--) {
+		for (i = (num_blocks - 1); i > 0; i--) {
+			xor = (num_blocks - 1) * j + i;
 			NdisMoveMemory(BIN, A, 8);
 			BIN[7] = A[7] ^ xor;
-			NdisMoveMemory(&BIN[8], &R[(i-1)*8], 8);
+			NdisMoveMemory(&BIN[8], &R[(i - 1) * 8], 8);
 			rt_aes_decrypt(&aesctx, BIN, BOUT);
 			NdisMoveMemory(A, &BOUT[0], 8);
-			NdisMoveMemory(&R[(i-1)*8], &BOUT[8], 8);
+			NdisMoveMemory(&R[(i - 1) * 8], &BOUT[8], 8);
 		}
 	}
 
 	// OUTPUT
-	for(i = 0; i < c_len; i++)
-	{
+	for (i = 0; i < c_len; i++) {
 		plaintext[i] = R[i];
 	}
 
-
 	os_free_mem(NULL, R);
 }
--- a/drivers/staging/rt2860/common/cmm_asic.c
+++ b/drivers/staging/rt2860/common/cmm_asic.c
@@ -37,124 +37,195 @@
 
 #include "../rt_config.h"
 
-
 // Reset the RFIC setting to new series
 RTMP_RF_REGS RF2850RegTable[] = {
-//		ch	 R1		 R2		 R3(TX0~4=0) R4
-		{1,  0x98402ecc, 0x984c0786, 0x9816b455, 0x9800510b},
-		{2,  0x98402ecc, 0x984c0786, 0x98168a55, 0x9800519f},
-		{3,  0x98402ecc, 0x984c078a, 0x98168a55, 0x9800518b},
-		{4,  0x98402ecc, 0x984c078a, 0x98168a55, 0x9800519f},
-		{5,  0x98402ecc, 0x984c078e, 0x98168a55, 0x9800518b},
-		{6,  0x98402ecc, 0x984c078e, 0x98168a55, 0x9800519f},
-		{7,  0x98402ecc, 0x984c0792, 0x98168a55, 0x9800518b},
-		{8,  0x98402ecc, 0x984c0792, 0x98168a55, 0x9800519f},
-		{9,  0x98402ecc, 0x984c0796, 0x98168a55, 0x9800518b},
-		{10, 0x98402ecc, 0x984c0796, 0x98168a55, 0x9800519f},
-		{11, 0x98402ecc, 0x984c079a, 0x98168a55, 0x9800518b},
-		{12, 0x98402ecc, 0x984c079a, 0x98168a55, 0x9800519f},
-		{13, 0x98402ecc, 0x984c079e, 0x98168a55, 0x9800518b},
-		{14, 0x98402ecc, 0x984c07a2, 0x98168a55, 0x98005193},
-
-		// 802.11 UNI / HyperLan 2
-		{36, 0x98402ecc, 0x984c099a, 0x98158a55, 0x980ed1a3},
-		{38, 0x98402ecc, 0x984c099e, 0x98158a55, 0x980ed193},
-		{40, 0x98402ec8, 0x984c0682, 0x98158a55, 0x980ed183},
-		{44, 0x98402ec8, 0x984c0682, 0x98158a55, 0x980ed1a3},
-		{46, 0x98402ec8, 0x984c0686, 0x98158a55, 0x980ed18b},
-		{48, 0x98402ec8, 0x984c0686, 0x98158a55, 0x980ed19b},
-		{52, 0x98402ec8, 0x984c068a, 0x98158a55, 0x980ed193},
-		{54, 0x98402ec8, 0x984c068a, 0x98158a55, 0x980ed1a3},
-		{56, 0x98402ec8, 0x984c068e, 0x98158a55, 0x980ed18b},
-		{60, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed183},
-		{62, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed193},
-		{64, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed1a3}, // Plugfest#4, Day4, change RFR3 left4th 9->5.
-
-		// 802.11 HyperLan 2
-		{100, 0x98402ec8, 0x984c06b2, 0x98178a55, 0x980ed783},
-
-		// 2008.04.30 modified
-		// The system team has AN to improve the EVM value
-		// for channel 102 to 108 for the RT2850/RT2750 dual band solution.
-		{102, 0x98402ec8, 0x985c06b2, 0x98578a55, 0x980ed793},
-		{104, 0x98402ec8, 0x985c06b2, 0x98578a55, 0x980ed1a3},
-		{108, 0x98402ecc, 0x985c0a32, 0x98578a55, 0x980ed193},
-
-		{110, 0x98402ecc, 0x984c0a36, 0x98178a55, 0x980ed183},
-		{112, 0x98402ecc, 0x984c0a36, 0x98178a55, 0x980ed19b},
-		{116, 0x98402ecc, 0x984c0a3a, 0x98178a55, 0x980ed1a3},
-		{118, 0x98402ecc, 0x984c0a3e, 0x98178a55, 0x980ed193},
-		{120, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed183},
-		{124, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed193},
-		{126, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed15b}, // 0x980ed1bb->0x980ed15b required by Rory 20070927
-		{128, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed1a3},
-		{132, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed18b},
-		{134, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed193},
-		{136, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed19b},
-		{140, 0x98402ec4, 0x984c038a, 0x98178a55, 0x980ed183},
-
-		// 802.11 UNII
-		{149, 0x98402ec4, 0x984c038a, 0x98178a55, 0x980ed1a7},
-		{151, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed187},
-		{153, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed18f},
-		{157, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed19f},
-		{159, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed1a7},
-		{161, 0x98402ec4, 0x984c0392, 0x98178a55, 0x980ed187},
-		{165, 0x98402ec4, 0x984c0392, 0x98178a55, 0x980ed197},
-		{167, 0x98402ec4, 0x984c03d2, 0x98179855, 0x9815531f},
-		{169, 0x98402ec4, 0x984c03d2, 0x98179855, 0x98155327},
-		{171, 0x98402ec4, 0x984c03d6, 0x98179855, 0x98155307},
-		{173, 0x98402ec4, 0x984c03d6, 0x98179855, 0x9815530f},
-
-		// Japan
-		{184, 0x95002ccc, 0x9500491e, 0x9509be55, 0x950c0a0b},
-		{188, 0x95002ccc, 0x95004922, 0x9509be55, 0x950c0a13},
-		{192, 0x95002ccc, 0x95004926, 0x9509be55, 0x950c0a1b},
-		{196, 0x95002ccc, 0x9500492a, 0x9509be55, 0x950c0a23},
-		{208, 0x95002ccc, 0x9500493a, 0x9509be55, 0x950c0a13},
-		{212, 0x95002ccc, 0x9500493e, 0x9509be55, 0x950c0a1b},
-		{216, 0x95002ccc, 0x95004982, 0x9509be55, 0x950c0a23},
+//              ch       R1              R2              R3(TX0~4=0) R4
+	{1, 0x98402ecc, 0x984c0786, 0x9816b455, 0x9800510b}
+	,
+	{2, 0x98402ecc, 0x984c0786, 0x98168a55, 0x9800519f}
+	,
+	{3, 0x98402ecc, 0x984c078a, 0x98168a55, 0x9800518b}
+	,
+	{4, 0x98402ecc, 0x984c078a, 0x98168a55, 0x9800519f}
+	,
+	{5, 0x98402ecc, 0x984c078e, 0x98168a55, 0x9800518b}
+	,
+	{6, 0x98402ecc, 0x984c078e, 0x98168a55, 0x9800519f}
+	,
+	{7, 0x98402ecc, 0x984c0792, 0x98168a55, 0x9800518b}
+	,
+	{8, 0x98402ecc, 0x984c0792, 0x98168a55, 0x9800519f}
+	,
+	{9, 0x98402ecc, 0x984c0796, 0x98168a55, 0x9800518b}
+	,
+	{10, 0x98402ecc, 0x984c0796, 0x98168a55, 0x9800519f}
+	,
+	{11, 0x98402ecc, 0x984c079a, 0x98168a55, 0x9800518b}
+	,
+	{12, 0x98402ecc, 0x984c079a, 0x98168a55, 0x9800519f}
+	,
+	{13, 0x98402ecc, 0x984c079e, 0x98168a55, 0x9800518b}
+	,
+	{14, 0x98402ecc, 0x984c07a2, 0x98168a55, 0x98005193}
+	,
+
+	// 802.11 UNI / HyperLan 2
+	{36, 0x98402ecc, 0x984c099a, 0x98158a55, 0x980ed1a3}
+	,
+	{38, 0x98402ecc, 0x984c099e, 0x98158a55, 0x980ed193}
+	,
+	{40, 0x98402ec8, 0x984c0682, 0x98158a55, 0x980ed183}
+	,
+	{44, 0x98402ec8, 0x984c0682, 0x98158a55, 0x980ed1a3}
+	,
+	{46, 0x98402ec8, 0x984c0686, 0x98158a55, 0x980ed18b}
+	,
+	{48, 0x98402ec8, 0x984c0686, 0x98158a55, 0x980ed19b}
+	,
+	{52, 0x98402ec8, 0x984c068a, 0x98158a55, 0x980ed193}
+	,
+	{54, 0x98402ec8, 0x984c068a, 0x98158a55, 0x980ed1a3}
+	,
+	{56, 0x98402ec8, 0x984c068e, 0x98158a55, 0x980ed18b}
+	,
+	{60, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed183}
+	,
+	{62, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed193}
+	,
+	{64, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed1a3}
+	,			// Plugfest#4, Day4, change RFR3 left4th 9->5.
+
+	// 802.11 HyperLan 2
+	{100, 0x98402ec8, 0x984c06b2, 0x98178a55, 0x980ed783}
+	,
+
+	// 2008.04.30 modified
+	// The system team has AN to improve the EVM value
+	// for channel 102 to 108 for the RT2850/RT2750 dual band solution.
+	{102, 0x98402ec8, 0x985c06b2, 0x98578a55, 0x980ed793}
+	,
+	{104, 0x98402ec8, 0x985c06b2, 0x98578a55, 0x980ed1a3}
+	,
+	{108, 0x98402ecc, 0x985c0a32, 0x98578a55, 0x980ed193}
+	,
+
+	{110, 0x98402ecc, 0x984c0a36, 0x98178a55, 0x980ed183}
+	,
+	{112, 0x98402ecc, 0x984c0a36, 0x98178a55, 0x980ed19b}
+	,
+	{116, 0x98402ecc, 0x984c0a3a, 0x98178a55, 0x980ed1a3}
+	,
+	{118, 0x98402ecc, 0x984c0a3e, 0x98178a55, 0x980ed193}
+	,
+	{120, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed183}
+	,
+	{124, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed193}
+	,
+	{126, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed15b}
+	,			// 0x980ed1bb->0x980ed15b required by Rory 20070927
+	{128, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed1a3}
+	,
+	{132, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed18b}
+	,
+	{134, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed193}
+	,
+	{136, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed19b}
+	,
+	{140, 0x98402ec4, 0x984c038a, 0x98178a55, 0x980ed183}
+	,
+
+	// 802.11 UNII
+	{149, 0x98402ec4, 0x984c038a, 0x98178a55, 0x980ed1a7}
+	,
+	{151, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed187}
+	,
+	{153, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed18f}
+	,
+	{157, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed19f}
+	,
+	{159, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed1a7}
+	,
+	{161, 0x98402ec4, 0x984c0392, 0x98178a55, 0x980ed187}
+	,
+	{165, 0x98402ec4, 0x984c0392, 0x98178a55, 0x980ed197}
+	,
+	{167, 0x98402ec4, 0x984c03d2, 0x98179855, 0x9815531f}
+	,
+	{169, 0x98402ec4, 0x984c03d2, 0x98179855, 0x98155327}
+	,
+	{171, 0x98402ec4, 0x984c03d6, 0x98179855, 0x98155307}
+	,
+	{173, 0x98402ec4, 0x984c03d6, 0x98179855, 0x9815530f}
+	,
+
+	// Japan
+	{184, 0x95002ccc, 0x9500491e, 0x9509be55, 0x950c0a0b}
+	,
+	{188, 0x95002ccc, 0x95004922, 0x9509be55, 0x950c0a13}
+	,
+	{192, 0x95002ccc, 0x95004926, 0x9509be55, 0x950c0a1b}
+	,
+	{196, 0x95002ccc, 0x9500492a, 0x9509be55, 0x950c0a23}
+	,
+	{208, 0x95002ccc, 0x9500493a, 0x9509be55, 0x950c0a13}
+	,
+	{212, 0x95002ccc, 0x9500493e, 0x9509be55, 0x950c0a1b}
+	,
+	{216, 0x95002ccc, 0x95004982, 0x9509be55, 0x950c0a23}
+	,
 
-		// still lack of MMAC(Japan) ch 34,38,42,46
+	// still lack of MMAC(Japan) ch 34,38,42,46
 };
-UCHAR	NUM_OF_2850_CHNL = (sizeof(RF2850RegTable) / sizeof(RTMP_RF_REGS));
 
-FREQUENCY_ITEM FreqItems3020[] =
-{
+UCHAR NUM_OF_2850_CHNL = (sizeof(RF2850RegTable) / sizeof(RTMP_RF_REGS));
+
+FREQUENCY_ITEM FreqItems3020[] = {
 	/**************************************************/
 	// ISM : 2.4 to 2.483 GHz                         //
 	/**************************************************/
 	// 11g
 	/**************************************************/
 	//-CH---N-------R---K-----------
-	{1,    241,  2,  2},
-	{2,    241,	 2,  7},
-	{3,    242,	 2,  2},
-	{4,    242,	 2,  7},
-	{5,    243,	 2,  2},
-	{6,    243,	 2,  7},
-	{7,    244,	 2,  2},
-	{8,    244,	 2,  7},
-	{9,    245,	 2,  2},
-	{10,   245,	 2,  7},
-	{11,   246,	 2,  2},
-	{12,   246,	 2,  7},
-	{13,   247,	 2,  2},
-	{14,   248,	 2,  4},
+	{1, 241, 2, 2}
+	,
+	{2, 241, 2, 7}
+	,
+	{3, 242, 2, 2}
+	,
+	{4, 242, 2, 7}
+	,
+	{5, 243, 2, 2}
+	,
+	{6, 243, 2, 7}
+	,
+	{7, 244, 2, 2}
+	,
+	{8, 244, 2, 7}
+	,
+	{9, 245, 2, 2}
+	,
+	{10, 245, 2, 7}
+	,
+	{11, 246, 2, 2}
+	,
+	{12, 246, 2, 7}
+	,
+	{13, 247, 2, 2}
+	,
+	{14, 248, 2, 4}
+	,
 };
-UCHAR	NUM_OF_3020_CHNL = (sizeof(FreqItems3020) / sizeof(FREQUENCY_ITEM));
 
+UCHAR NUM_OF_3020_CHNL = (sizeof(FreqItems3020) / sizeof(FREQUENCY_ITEM));
 
-VOID AsicUpdateAutoFallBackTable(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pRateTable)
-{
-	UCHAR					i;
-	HT_FBK_CFG0_STRUC		HtCfg0;
-	HT_FBK_CFG1_STRUC		HtCfg1;
-	LG_FBK_CFG0_STRUC		LgCfg0;
-	LG_FBK_CFG1_STRUC		LgCfg1;
-	PRTMP_TX_RATE_SWITCH	pCurrTxRate, pNextTxRate;
+VOID AsicUpdateAutoFallBackTable(IN PRTMP_ADAPTER pAd, IN PUCHAR pRateTable)
+{
+	UCHAR i;
+	HT_FBK_CFG0_STRUC HtCfg0;
+	HT_FBK_CFG1_STRUC HtCfg1;
+	LG_FBK_CFG0_STRUC LgCfg0;
+	LG_FBK_CFG1_STRUC LgCfg1;
+	PRTMP_TX_RATE_SWITCH pCurrTxRate, pNextTxRate;
 
 	// set to initial value
 	HtCfg0.word = 0x65432100;
@@ -162,106 +233,162 @@ VOID AsicUpdateAutoFallBackTable(
 	LgCfg0.word = 0xedcba988;
 	LgCfg1.word = 0x00002100;
 
-	pNextTxRate = (PRTMP_TX_RATE_SWITCH)pRateTable+1;
-	for (i = 1; i < *((PUCHAR) pRateTable); i++)
-	{
-		pCurrTxRate = (PRTMP_TX_RATE_SWITCH)pRateTable+1+i;
-		switch (pCurrTxRate->Mode)
-		{
-			case 0:		//CCK
-				break;
-			case 1:		//OFDM
-				{
-					switch(pCurrTxRate->CurrMCS)
-					{
-						case 0:
-							LgCfg0.field.OFDMMCS0FBK = (pNextTxRate->Mode == MODE_OFDM) ? (pNextTxRate->CurrMCS+8): pNextTxRate->CurrMCS;
-							break;
-						case 1:
-							LgCfg0.field.OFDMMCS1FBK = (pNextTxRate->Mode == MODE_OFDM) ? (pNextTxRate->CurrMCS+8): pNextTxRate->CurrMCS;
-							break;
-						case 2:
-							LgCfg0.field.OFDMMCS2FBK = (pNextTxRate->Mode == MODE_OFDM) ? (pNextTxRate->CurrMCS+8): pNextTxRate->CurrMCS;
-							break;
-						case 3:
-							LgCfg0.field.OFDMMCS3FBK = (pNextTxRate->Mode == MODE_OFDM) ? (pNextTxRate->CurrMCS+8): pNextTxRate->CurrMCS;
-							break;
-						case 4:
-							LgCfg0.field.OFDMMCS4FBK = (pNextTxRate->Mode == MODE_OFDM) ? (pNextTxRate->CurrMCS+8): pNextTxRate->CurrMCS;
-							break;
-						case 5:
-							LgCfg0.field.OFDMMCS5FBK = (pNextTxRate->Mode == MODE_OFDM) ? (pNextTxRate->CurrMCS+8): pNextTxRate->CurrMCS;
-							break;
-						case 6:
-							LgCfg0.field.OFDMMCS6FBK = (pNextTxRate->Mode == MODE_OFDM) ? (pNextTxRate->CurrMCS+8): pNextTxRate->CurrMCS;
-							break;
-						case 7:
-							LgCfg0.field.OFDMMCS7FBK = (pNextTxRate->Mode == MODE_OFDM) ? (pNextTxRate->CurrMCS+8): pNextTxRate->CurrMCS;
-							break;
-					}
+	pNextTxRate = (PRTMP_TX_RATE_SWITCH) pRateTable + 1;
+	for (i = 1; i < *((PUCHAR) pRateTable); i++) {
+		pCurrTxRate = (PRTMP_TX_RATE_SWITCH) pRateTable + 1 + i;
+		switch (pCurrTxRate->Mode) {
+		case 0:	//CCK
+			break;
+		case 1:	//OFDM
+			{
+				switch (pCurrTxRate->CurrMCS) {
+				case 0:
+					LgCfg0.field.OFDMMCS0FBK =
+					    (pNextTxRate->Mode ==
+					     MODE_OFDM) ? (pNextTxRate->
+							   CurrMCS +
+							   8) : pNextTxRate->
+					    CurrMCS;
+					break;
+				case 1:
+					LgCfg0.field.OFDMMCS1FBK =
+					    (pNextTxRate->Mode ==
+					     MODE_OFDM) ? (pNextTxRate->
+							   CurrMCS +
+							   8) : pNextTxRate->
+					    CurrMCS;
+					break;
+				case 2:
+					LgCfg0.field.OFDMMCS2FBK =
+					    (pNextTxRate->Mode ==
+					     MODE_OFDM) ? (pNextTxRate->
+							   CurrMCS +
+							   8) : pNextTxRate->
+					    CurrMCS;
+					break;
+				case 3:
+					LgCfg0.field.OFDMMCS3FBK =
+					    (pNextTxRate->Mode ==
+					     MODE_OFDM) ? (pNextTxRate->
+							   CurrMCS +
+							   8) : pNextTxRate->
+					    CurrMCS;
+					break;
+				case 4:
+					LgCfg0.field.OFDMMCS4FBK =
+					    (pNextTxRate->Mode ==
+					     MODE_OFDM) ? (pNextTxRate->
+							   CurrMCS +
+							   8) : pNextTxRate->
+					    CurrMCS;
+					break;
+				case 5:
+					LgCfg0.field.OFDMMCS5FBK =
+					    (pNextTxRate->Mode ==
+					     MODE_OFDM) ? (pNextTxRate->
+							   CurrMCS +
+							   8) : pNextTxRate->
+					    CurrMCS;
+					break;
+				case 6:
+					LgCfg0.field.OFDMMCS6FBK =
+					    (pNextTxRate->Mode ==
+					     MODE_OFDM) ? (pNextTxRate->
+							   CurrMCS +
+							   8) : pNextTxRate->
+					    CurrMCS;
+					break;
+				case 7:
+					LgCfg0.field.OFDMMCS7FBK =
+					    (pNextTxRate->Mode ==
+					     MODE_OFDM) ? (pNextTxRate->
+							   CurrMCS +
+							   8) : pNextTxRate->
+					    CurrMCS;
+					break;
 				}
-				break;
-			case 2:		//HT-MIX
-			case 3:		//HT-GF
-				{
-					if ((pNextTxRate->Mode >= MODE_HTMIX) && (pCurrTxRate->CurrMCS != pNextTxRate->CurrMCS))
-					{
-						switch(pCurrTxRate->CurrMCS)
-						{
-							case 0:
-								HtCfg0.field.HTMCS0FBK = pNextTxRate->CurrMCS;
-								break;
-							case 1:
-								HtCfg0.field.HTMCS1FBK = pNextTxRate->CurrMCS;
-								break;
-							case 2:
-								HtCfg0.field.HTMCS2FBK = pNextTxRate->CurrMCS;
-								break;
-							case 3:
-								HtCfg0.field.HTMCS3FBK = pNextTxRate->CurrMCS;
-								break;
-							case 4:
-								HtCfg0.field.HTMCS4FBK = pNextTxRate->CurrMCS;
-								break;
-							case 5:
-								HtCfg0.field.HTMCS5FBK = pNextTxRate->CurrMCS;
-								break;
-							case 6:
-								HtCfg0.field.HTMCS6FBK = pNextTxRate->CurrMCS;
-								break;
-							case 7:
-								HtCfg0.field.HTMCS7FBK = pNextTxRate->CurrMCS;
-								break;
-							case 8:
-								HtCfg1.field.HTMCS8FBK = pNextTxRate->CurrMCS;
-								break;
-							case 9:
-								HtCfg1.field.HTMCS9FBK = pNextTxRate->CurrMCS;
-								break;
-							case 10:
-								HtCfg1.field.HTMCS10FBK = pNextTxRate->CurrMCS;
-								break;
-							case 11:
-								HtCfg1.field.HTMCS11FBK = pNextTxRate->CurrMCS;
-								break;
-							case 12:
-								HtCfg1.field.HTMCS12FBK = pNextTxRate->CurrMCS;
-								break;
-							case 13:
-								HtCfg1.field.HTMCS13FBK = pNextTxRate->CurrMCS;
-								break;
-							case 14:
-								HtCfg1.field.HTMCS14FBK = pNextTxRate->CurrMCS;
-								break;
-							case 15:
-								HtCfg1.field.HTMCS15FBK = pNextTxRate->CurrMCS;
-								break;
-							default:
-								DBGPRINT(RT_DEBUG_ERROR, ("AsicUpdateAutoFallBackTable: not support CurrMCS=%d\n", pCurrTxRate->CurrMCS));
-						}
+			}
+			break;
+		case 2:	//HT-MIX
+		case 3:	//HT-GF
+			{
+				if ((pNextTxRate->Mode >= MODE_HTMIX)
+				    && (pCurrTxRate->CurrMCS !=
+					pNextTxRate->CurrMCS)) {
+					switch (pCurrTxRate->CurrMCS) {
+					case 0:
+						HtCfg0.field.HTMCS0FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 1:
+						HtCfg0.field.HTMCS1FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 2:
+						HtCfg0.field.HTMCS2FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 3:
+						HtCfg0.field.HTMCS3FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 4:
+						HtCfg0.field.HTMCS4FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 5:
+						HtCfg0.field.HTMCS5FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 6:
+						HtCfg0.field.HTMCS6FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 7:
+						HtCfg0.field.HTMCS7FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 8:
+						HtCfg1.field.HTMCS8FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 9:
+						HtCfg1.field.HTMCS9FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 10:
+						HtCfg1.field.HTMCS10FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 11:
+						HtCfg1.field.HTMCS11FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 12:
+						HtCfg1.field.HTMCS12FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 13:
+						HtCfg1.field.HTMCS13FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 14:
+						HtCfg1.field.HTMCS14FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					case 15:
+						HtCfg1.field.HTMCS15FBK =
+						    pNextTxRate->CurrMCS;
+						break;
+					default:
+						DBGPRINT(RT_DEBUG_ERROR,
+							 ("AsicUpdateAutoFallBackTable: not support CurrMCS=%d\n",
+							  pCurrTxRate->
+							  CurrMCS));
 					}
 				}
-				break;
+			}
+			break;
 		}
 
 		pNextTxRate = pCurrTxRate;
@@ -290,49 +417,39 @@ VOID AsicUpdateAutoFallBackTable(
 			we should choose not to use GF. But still set correct ASIC registers.
 	========================================================================
 */
-VOID	AsicUpdateProtect(
-	IN		PRTMP_ADAPTER	pAd,
-	IN		USHORT			OperationMode,
-	IN		UCHAR			SetMask,
-	IN		BOOLEAN			bDisableBGProtect,
-	IN		BOOLEAN			bNonGFExist)
+VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
+		       IN USHORT OperationMode,
+		       IN UCHAR SetMask,
+		       IN BOOLEAN bDisableBGProtect, IN BOOLEAN bNonGFExist)
 {
-	PROT_CFG_STRUC	ProtCfg, ProtCfg4;
+	PROT_CFG_STRUC ProtCfg, ProtCfg4;
 	UINT32 Protect[6];
-	USHORT			offset;
-	UCHAR			i;
+	USHORT offset;
+	UCHAR i;
 	UINT32 MacReg = 0;
 
-
-	if (!(pAd->CommonCfg.bHTProtect) && (OperationMode != 8))
-	{
+	if (!(pAd->CommonCfg.bHTProtect) && (OperationMode != 8)) {
 		return;
 	}
 
-	if (pAd->BATable.numDoneOriginator)
-	{
+	if (pAd->BATable.numDoneOriginator) {
 		//
 		// enable the RTS/CTS to avoid channel collision
 		//
 		SetMask = ALLN_SETPROTECT;
 		OperationMode = 8;
 	}
-
 	// Config ASIC RTS threshold register
 	RTMP_IO_READ32(pAd, TX_RTS_CFG, &MacReg);
 	MacReg &= 0xFF0000FF;
 	// If the user want disable RtsThreshold and enable Amsdu/Ralink-Aggregation, set the RtsThreshold as 4096
-        if ((
-			(pAd->CommonCfg.BACapability.field.AmsduEnable) ||
-			(pAd->CommonCfg.bAggregationCapable == TRUE))
-            && pAd->CommonCfg.RtsThreshold == MAX_RTS_THRESHOLD)
-        {
-			MacReg |= (0x1000 << 8);
-        }
-        else
-        {
-			MacReg |= (pAd->CommonCfg.RtsThreshold << 8);
-        }
+	if (((pAd->CommonCfg.BACapability.field.AmsduEnable) ||
+	     (pAd->CommonCfg.bAggregationCapable == TRUE))
+	    && pAd->CommonCfg.RtsThreshold == MAX_RTS_THRESHOLD) {
+		MacReg |= (0x1000 << 8);
+	} else {
+		MacReg |= (pAd->CommonCfg.RtsThreshold << 8);
+	}
 
 	RTMP_IO_WRITE32(pAd, TX_RTS_CFG, MacReg);
 
@@ -355,165 +472,155 @@ VOID	AsicUpdateProtect(
 	ProtCfg.field.ProtectRate |= pAd->CommonCfg.RtsRate;
 
 	// Handle legacy(B/G) protection
-	if (bDisableBGProtect)
-	{
+	if (bDisableBGProtect) {
 		//ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;
 		ProtCfg.field.ProtectCtrl = 0;
 		Protect[0] = ProtCfg.word;
 		Protect[1] = ProtCfg.word;
-		pAd->FlgCtsEnabled = 0; /* CTS-self is not used */
-	}
-	else
-	{
+		pAd->FlgCtsEnabled = 0;	/* CTS-self is not used */
+	} else {
 		//ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;
-		ProtCfg.field.ProtectCtrl = 0;			// CCK do not need to be protected
+		ProtCfg.field.ProtectCtrl = 0;	// CCK do not need to be protected
 		Protect[0] = ProtCfg.word;
 		ProtCfg.field.ProtectCtrl = ASIC_CTS;	// OFDM needs using CCK to protect
 		Protect[1] = ProtCfg.word;
-		pAd->FlgCtsEnabled = 1; /* CTS-self is used */
+		pAd->FlgCtsEnabled = 1;	/* CTS-self is used */
 	}
 
 	// Decide HT frame protection.
-	if ((SetMask & ALLN_SETPROTECT) != 0)
-	{
-		switch(OperationMode)
-		{
-			case 0x0:
-				// NO PROTECT
-				// 1.All STAs in the BSS are 20/40 MHz HT
-				// 2. in ai 20/40MHz BSS
-				// 3. all STAs are 20MHz in a 20MHz BSS
-				// Pure HT. no protection.
-
-				// MM20_PROT_CFG
-				//	Reserved (31:27)
-				//	PROT_TXOP(25:20) -- 010111
-				//	PROT_NAV(19:18)  -- 01 (Short NAV protection)
-				//  PROT_CTRL(17:16) -- 00 (None)
-				//	PROT_RATE(15:0)  -- 0x4004 (OFDM 24M)
-				Protect[2] = 0x01744004;
-
-				// MM40_PROT_CFG
-				//	Reserved (31:27)
-				//	PROT_TXOP(25:20) -- 111111
-				//	PROT_NAV(19:18)  -- 01 (Short NAV protection)
-				//  PROT_CTRL(17:16) -- 00 (None)
-				//	PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M)
-				Protect[3] = 0x03f44084;
-
-				// CF20_PROT_CFG
-				//	Reserved (31:27)
-				//	PROT_TXOP(25:20) -- 010111
-				//	PROT_NAV(19:18)  -- 01 (Short NAV protection)
-				//  PROT_CTRL(17:16) -- 00 (None)
-				//	PROT_RATE(15:0)  -- 0x4004 (OFDM 24M)
-				Protect[4] = 0x01744004;
-
-				// CF40_PROT_CFG
-				//	Reserved (31:27)
-				//	PROT_TXOP(25:20) -- 111111
-				//	PROT_NAV(19:18)  -- 01 (Short NAV protection)
-				//  PROT_CTRL(17:16) -- 00 (None)
-				//	PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M)
-				Protect[5] = 0x03f44084;
-
-				if (bNonGFExist)
-				{
-					// PROT_NAV(19:18)  -- 01 (Short NAV protectiion)
-					// PROT_CTRL(17:16) -- 01 (RTS/CTS)
-					Protect[4] = 0x01754004;
-					Protect[5] = 0x03f54084;
-				}
-				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
-				break;
+	if ((SetMask & ALLN_SETPROTECT) != 0) {
+		switch (OperationMode) {
+		case 0x0:
+			// NO PROTECT
+			// 1.All STAs in the BSS are 20/40 MHz HT
+			// 2. in ai 20/40MHz BSS
+			// 3. all STAs are 20MHz in a 20MHz BSS
+			// Pure HT. no protection.
+
+			// MM20_PROT_CFG
+			//      Reserved (31:27)
+			//      PROT_TXOP(25:20) -- 010111
+			//      PROT_NAV(19:18)  -- 01 (Short NAV protection)
+			//  PROT_CTRL(17:16) -- 00 (None)
+			//      PROT_RATE(15:0)  -- 0x4004 (OFDM 24M)
+			Protect[2] = 0x01744004;
+
+			// MM40_PROT_CFG
+			//      Reserved (31:27)
+			//      PROT_TXOP(25:20) -- 111111
+			//      PROT_NAV(19:18)  -- 01 (Short NAV protection)
+			//  PROT_CTRL(17:16) -- 00 (None)
+			//      PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M)
+			Protect[3] = 0x03f44084;
+
+			// CF20_PROT_CFG
+			//      Reserved (31:27)
+			//      PROT_TXOP(25:20) -- 010111
+			//      PROT_NAV(19:18)  -- 01 (Short NAV protection)
+			//  PROT_CTRL(17:16) -- 00 (None)
+			//      PROT_RATE(15:0)  -- 0x4004 (OFDM 24M)
+			Protect[4] = 0x01744004;
+
+			// CF40_PROT_CFG
+			//      Reserved (31:27)
+			//      PROT_TXOP(25:20) -- 111111
+			//      PROT_NAV(19:18)  -- 01 (Short NAV protection)
+			//  PROT_CTRL(17:16) -- 00 (None)
+			//      PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M)
+			Protect[5] = 0x03f44084;
+
+			if (bNonGFExist) {
+				// PROT_NAV(19:18)  -- 01 (Short NAV protectiion)
+				// PROT_CTRL(17:16) -- 01 (RTS/CTS)
+				Protect[4] = 0x01754004;
+				Protect[5] = 0x03f54084;
+			}
+			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
+			break;
 
-			case 1:
-				// This is "HT non-member protection mode."
-				// If there may be non-HT STAs my BSS
-				ProtCfg.word = 0x01744004;	// PROT_CTRL(17:16) : 0 (None)
-				ProtCfg4.word = 0x03f44084; // duplicaet legacy 24M. BW set 1.
-				if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
-				{
-					ProtCfg.word = 0x01740003;	//ERP use Protection bit is set, use protection rate at Clause 18..
-					ProtCfg4.word = 0x03f40003; // Don't duplicate RTS/CTS in CCK mode. 0x03f40083;
-				}
-				//Assign Protection method for 20&40 MHz packets
+		case 1:
+			// This is "HT non-member protection mode."
+			// If there may be non-HT STAs my BSS
+			ProtCfg.word = 0x01744004;	// PROT_CTRL(17:16) : 0 (None)
+			ProtCfg4.word = 0x03f44084;	// duplicaet legacy 24M. BW set 1.
+			if (OPSTATUS_TEST_FLAG
+			    (pAd, fOP_STATUS_BG_PROTECTION_INUSED)) {
+				ProtCfg.word = 0x01740003;	//ERP use Protection bit is set, use protection rate at Clause 18..
+				ProtCfg4.word = 0x03f40003;	// Don't duplicate RTS/CTS in CCK mode. 0x03f40083;
+			}
+			//Assign Protection method for 20&40 MHz packets
+			ProtCfg.field.ProtectCtrl = ASIC_RTS;
+			ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
+			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
+			ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
+			Protect[2] = ProtCfg.word;
+			Protect[3] = ProtCfg4.word;
+			Protect[4] = ProtCfg.word;
+			Protect[5] = ProtCfg4.word;
+			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
+			break;
+
+		case 2:
+			// If only HT STAs are in BSS. at least one is 20MHz. Only protect 40MHz packets
+			ProtCfg.word = 0x01744004;	// PROT_CTRL(17:16) : 0 (None)
+			ProtCfg4.word = 0x03f44084;	// duplicaet legacy 24M. BW set 1.
+
+			//Assign Protection method for 40MHz packets
+			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
+			ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
+			Protect[2] = ProtCfg.word;
+			Protect[3] = ProtCfg4.word;
+			if (bNonGFExist) {
 				ProtCfg.field.ProtectCtrl = ASIC_RTS;
 				ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
-				ProtCfg4.field.ProtectCtrl = ASIC_RTS;
-				ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
-				Protect[2] = ProtCfg.word;
-				Protect[3] = ProtCfg4.word;
-				Protect[4] = ProtCfg.word;
-				Protect[5] = ProtCfg4.word;
-				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
-				break;
-
-			case 2:
-				// If only HT STAs are in BSS. at least one is 20MHz. Only protect 40MHz packets
-				ProtCfg.word = 0x01744004;  // PROT_CTRL(17:16) : 0 (None)
-				ProtCfg4.word = 0x03f44084; // duplicaet legacy 24M. BW set 1.
-
-				//Assign Protection method for 40MHz packets
-				ProtCfg4.field.ProtectCtrl = ASIC_RTS;
-				ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
-				Protect[2] = ProtCfg.word;
-				Protect[3] = ProtCfg4.word;
-				if (bNonGFExist)
-				{
-					ProtCfg.field.ProtectCtrl = ASIC_RTS;
-					ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
-				}
-				Protect[4] = ProtCfg.word;
-				Protect[5] = ProtCfg4.word;
+			}
+			Protect[4] = ProtCfg.word;
+			Protect[5] = ProtCfg4.word;
 
-				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
-				break;
+			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
+			break;
 
-			case 3:
-				// HT mixed mode.	 PROTECT ALL!
-				// Assign Rate
-				ProtCfg.word = 0x01744004;	//duplicaet legacy 24M. BW set 1.
-				ProtCfg4.word = 0x03f44084;
-				// both 20MHz and 40MHz are protected. Whether use RTS or CTS-to-self depends on the
-				if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
-				{
-					ProtCfg.word = 0x01740003;	//ERP use Protection bit is set, use protection rate at Clause 18..
-					ProtCfg4.word = 0x03f40003; // Don't duplicate RTS/CTS in CCK mode. 0x03f40083
-				}
-				//Assign Protection method for 20&40 MHz packets
-				ProtCfg.field.ProtectCtrl = ASIC_RTS;
-				ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
-				ProtCfg4.field.ProtectCtrl = ASIC_RTS;
-				ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
-				Protect[2] = ProtCfg.word;
-				Protect[3] = ProtCfg4.word;
-				Protect[4] = ProtCfg.word;
-				Protect[5] = ProtCfg4.word;
-				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
-				break;
+		case 3:
+			// HT mixed mode.        PROTECT ALL!
+			// Assign Rate
+			ProtCfg.word = 0x01744004;	//duplicaet legacy 24M. BW set 1.
+			ProtCfg4.word = 0x03f44084;
+			// both 20MHz and 40MHz are protected. Whether use RTS or CTS-to-self depends on the
+			if (OPSTATUS_TEST_FLAG
+			    (pAd, fOP_STATUS_BG_PROTECTION_INUSED)) {
+				ProtCfg.word = 0x01740003;	//ERP use Protection bit is set, use protection rate at Clause 18..
+				ProtCfg4.word = 0x03f40003;	// Don't duplicate RTS/CTS in CCK mode. 0x03f40083
+			}
+			//Assign Protection method for 20&40 MHz packets
+			ProtCfg.field.ProtectCtrl = ASIC_RTS;
+			ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
+			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
+			ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
+			Protect[2] = ProtCfg.word;
+			Protect[3] = ProtCfg4.word;
+			Protect[4] = ProtCfg.word;
+			Protect[5] = ProtCfg4.word;
+			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
+			break;
 
-			case 8:
-				// Special on for Atheros problem n chip.
-				Protect[2] = 0x01754004;
-				Protect[3] = 0x03f54084;
-				Protect[4] = 0x01754004;
-				Protect[5] = 0x03f54084;
-				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
-				break;
+		case 8:
+			// Special on for Atheros problem n chip.
+			Protect[2] = 0x01754004;
+			Protect[3] = 0x03f54084;
+			Protect[4] = 0x01754004;
+			Protect[5] = 0x03f54084;
+			pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
+			break;
 		}
 	}
 
 	offset = CCK_PROT_CFG;
-	for (i = 0;i < 6;i++)
-	{
-			if ((SetMask & (1<< i)))
-		{
-		RTMP_IO_WRITE32(pAd, offset + i*4, Protect[i]);
+	for (i = 0; i < 6; i++) {
+		if ((SetMask & (1 << i))) {
+			RTMP_IO_WRITE32(pAd, offset + i * 4, Protect[i]);
+		}
 	}
 }
-}
-
 
 /*
 	==========================================================================
@@ -524,54 +631,51 @@ VOID	AsicUpdateProtect(
 
 	==========================================================================
  */
-VOID AsicSwitchChannel(
-					  IN PRTMP_ADAPTER pAd,
-	IN	UCHAR			Channel,
-	IN	BOOLEAN			bScan)
-{
-	ULONG			R2 = 0, R3 = DEFAULT_RF_TX_POWER, R4 = 0;
-	CHAR    TxPwer = 0, TxPwer2 = DEFAULT_RF_TX_POWER; //Bbp94 = BBPR94_DEFAULT, TxPwer2 = DEFAULT_RF_TX_POWER;
-	UCHAR	index;
-	UINT32	Value = 0; //BbpReg, Value;
+VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
+{
+	ULONG R2 = 0, R3 = DEFAULT_RF_TX_POWER, R4 = 0;
+	CHAR TxPwer = 0, TxPwer2 = DEFAULT_RF_TX_POWER;	//Bbp94 = BBPR94_DEFAULT, TxPwer2 = DEFAULT_RF_TX_POWER;
+	UCHAR index;
+	UINT32 Value = 0;	//BbpReg, Value;
 	RTMP_RF_REGS *RFRegTable;
-	UCHAR	RFValue;
+	UCHAR RFValue;
 
 	RFValue = 0;
 	// Search Tx power value
 	// We can't use ChannelList to search channel, since some central channl's txpowr doesn't list
 	// in ChannelList, so use TxPower array instead.
 	//
-	for (index = 0; index < MAX_NUM_OF_CHANNELS; index++)
-	{
-		if (Channel == pAd->TxPower[index].Channel)
-		{
+	for (index = 0; index < MAX_NUM_OF_CHANNELS; index++) {
+		if (Channel == pAd->TxPower[index].Channel) {
 			TxPwer = pAd->TxPower[index].Power;
 			TxPwer2 = pAd->TxPower[index].Power2;
 			break;
 		}
 	}
 
-	if (index == MAX_NUM_OF_CHANNELS)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("AsicSwitchChannel: Can't find the Channel#%d \n", Channel));
+	if (index == MAX_NUM_OF_CHANNELS) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("AsicSwitchChannel: Can't find the Channel#%d \n",
+			  Channel));
 	}
-
 #ifdef RT30xx
 	// The RF programming sequence is difference between 3xxx and 2xxx
-	if ((IS_RT3070(pAd) || IS_RT3090(pAd)||IS_RT3390(pAd)) && ((pAd->RfIcType == RFIC_3020) || (pAd->RfIcType == RFIC_2020) ||
-		(pAd->RfIcType == RFIC_3021) || (pAd->RfIcType == RFIC_3022)))
-	{
+	if ((IS_RT3070(pAd) || IS_RT3090(pAd) || IS_RT3390(pAd))
+	    && ((pAd->RfIcType == RFIC_3020) || (pAd->RfIcType == RFIC_2020)
+		|| (pAd->RfIcType == RFIC_3021)
+		|| (pAd->RfIcType == RFIC_3022))) {
 		/* modify by WY for Read RF Reg. error */
 
-		for (index = 0; index < NUM_OF_3020_CHNL; index++)
-		{
-			if (Channel == FreqItems3020[index].Channel)
-			{
+		for (index = 0; index < NUM_OF_3020_CHNL; index++) {
+			if (Channel == FreqItems3020[index].Channel) {
 				// Programming channel parameters
-				RT30xxWriteRFRegister(pAd, RF_R02, FreqItems3020[index].N);
-				RT30xxWriteRFRegister(pAd, RF_R03, FreqItems3020[index].K);
+				RT30xxWriteRFRegister(pAd, RF_R02,
+						      FreqItems3020[index].N);
+				RT30xxWriteRFRegister(pAd, RF_R03,
+						      FreqItems3020[index].K);
 				RT30xxReadRFRegister(pAd, RF_R06, &RFValue);
-				RFValue = (RFValue & 0xFC) | FreqItems3020[index].R;
+				RFValue =
+				    (RFValue & 0xFC) | FreqItems3020[index].R;
 				RT30xxWriteRFRegister(pAd, RF_R06, RFValue);
 
 				// Set Tx0 Power
@@ -587,7 +691,7 @@ VOID AsicSwitchChannel(
 				// Tx/Rx Stream setting
 				RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
 				//if (IS_RT3090(pAd))
-				//	RFValue |= 0x01; // Enable RF block.
+				//      RFValue |= 0x01; // Enable RF block.
 				RFValue &= 0x03;	//clear bit[7~2]
 				if (pAd->Antenna.field.TxPath == 1)
 					RFValue |= 0xA0;
@@ -605,13 +709,11 @@ VOID AsicSwitchChannel(
 				RT30xxWriteRFRegister(pAd, RF_R23, RFValue);
 
 				// Set BW
-				if (!bScan && (pAd->CommonCfg.BBPCurrentBW == BW_40))
-			{
+				if (!bScan
+				    && (pAd->CommonCfg.BBPCurrentBW == BW_40)) {
 					RFValue = pAd->Mlme.CaliBW40RfR24;
 					//DISABLE_11N_CHECK(pAd);
-				}
-				else
-			{
+				} else {
 					RFValue = pAd->Mlme.CaliBW20RfR24;
 				}
 				RT30xxWriteRFRegister(pAd, RF_R24, RFValue);
@@ -625,166 +727,186 @@ VOID AsicSwitchChannel(
 				// latch channel for future usage.
 				pAd->LatchRfRegs.Channel = Channel;
 
-		DBGPRINT(RT_DEBUG_TRACE, ("SwitchChannel#%d(RF=%d, Pwr0=%d, Pwr1=%d, %dT), N=0x%02X, K=0x%02X, R=0x%02X\n",
-			Channel,
-			pAd->RfIcType,
-			TxPwer,
-			TxPwer2,
-			pAd->Antenna.field.TxPath,
-			FreqItems3020[index].N,
-			FreqItems3020[index].K,
-			FreqItems3020[index].R));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("SwitchChannel#%d(RF=%d, Pwr0=%d, Pwr1=%d, %dT), N=0x%02X, K=0x%02X, R=0x%02X\n",
+					  Channel, pAd->RfIcType, TxPwer,
+					  TxPwer2, pAd->Antenna.field.TxPath,
+					  FreqItems3020[index].N,
+					  FreqItems3020[index].K,
+					  FreqItems3020[index].R));
 
 				break;
 			}
 		}
-	}
-	else
+	} else
 #endif // RT30xx //
 	{
 		RFRegTable = RF2850RegTable;
-		switch (pAd->RfIcType)
-		{
-			case RFIC_2820:
-			case RFIC_2850:
-			case RFIC_2720:
-			case RFIC_2750:
-
-				for (index = 0; index < NUM_OF_2850_CHNL; index++)
-				{
-					if (Channel == RFRegTable[index].Channel)
-					{
-						R2 = RFRegTable[index].R2;
-						if (pAd->Antenna.field.TxPath == 1)
-						{
-							R2 |= 0x4000;	// If TXpath is 1, bit 14 = 1;
-						}
+		switch (pAd->RfIcType) {
+		case RFIC_2820:
+		case RFIC_2850:
+		case RFIC_2720:
+		case RFIC_2750:
 
-						if (pAd->Antenna.field.RxPath == 2)
-						{
-							R2 |= 0x40;	// write 1 to off Rxpath.
-						}
-						else if (pAd->Antenna.field.RxPath == 1)
-						{
-							R2 |= 0x20040;	// write 1 to off RxPath
-						}
+			for (index = 0; index < NUM_OF_2850_CHNL; index++) {
+				if (Channel == RFRegTable[index].Channel) {
+					R2 = RFRegTable[index].R2;
+					if (pAd->Antenna.field.TxPath == 1) {
+						R2 |= 0x4000;	// If TXpath is 1, bit 14 = 1;
+					}
 
-						if (Channel > 14)
-						{
-							// initialize R3, R4
-							R3 = (RFRegTable[index].R3 & 0xffffc1ff);
-							R4 = (RFRegTable[index].R4 & (~0x001f87c0)) | (pAd->RfFreqOffset << 15);
-
-							// 5G band power range: 0xF9~0X0F, TX0 Reg3 bit9/TX1 Reg4 bit6="0" means the TX power reduce 7dB
-							// R3
-							if ((TxPwer >= -7) && (TxPwer < 0))
-							{
-								TxPwer = (7+TxPwer);
-								TxPwer = (TxPwer > 0xF) ? (0xF) : (TxPwer);
-								R3 |= (TxPwer << 10);
-								DBGPRINT(RT_DEBUG_ERROR, ("AsicSwitchChannel: TxPwer=%d \n", TxPwer));
-							}
-							else
-							{
-								TxPwer = (TxPwer > 0xF) ? (0xF) : (TxPwer);
-								R3 |= (TxPwer << 10) | (1 << 9);
-							}
-
-							// R4
-							if ((TxPwer2 >= -7) && (TxPwer2 < 0))
-							{
-								TxPwer2 = (7+TxPwer2);
-								TxPwer2 = (TxPwer2 > 0xF) ? (0xF) : (TxPwer2);
-								R4 |= (TxPwer2 << 7);
-								DBGPRINT(RT_DEBUG_ERROR, ("AsicSwitchChannel: TxPwer2=%d \n", TxPwer2));
-							}
-							else
-							{
-								TxPwer2 = (TxPwer2 > 0xF) ? (0xF) : (TxPwer2);
-								R4 |= (TxPwer2 << 7) | (1 << 6);
-							}
-						}
-						else
-						{
-							R3 = (RFRegTable[index].R3 & 0xffffc1ff) | (TxPwer << 9); // set TX power0
-						R4 = (RFRegTable[index].R4 & (~0x001f87c0)) | (pAd->RfFreqOffset << 15) | (TxPwer2 <<6);// Set freq Offset & TxPwr1
-						}
+					if (pAd->Antenna.field.RxPath == 2) {
+						R2 |= 0x40;	// write 1 to off Rxpath.
+					} else if (pAd->Antenna.field.RxPath ==
+						   1) {
+						R2 |= 0x20040;	// write 1 to off RxPath
+					}
 
-						// Based on BBP current mode before changing RF channel.
-						if (!bScan && (pAd->CommonCfg.BBPCurrentBW == BW_40))
-						{
-							R4 |=0x200000;
+					if (Channel > 14) {
+						// initialize R3, R4
+						R3 = (RFRegTable[index].
+						      R3 & 0xffffc1ff);
+						R4 = (RFRegTable[index].
+						      R4 & (~0x001f87c0)) |
+						    (pAd->RfFreqOffset << 15);
+
+						// 5G band power range: 0xF9~0X0F, TX0 Reg3 bit9/TX1 Reg4 bit6="0" means the TX power reduce 7dB
+						// R3
+						if ((TxPwer >= -7)
+						    && (TxPwer < 0)) {
+							TxPwer = (7 + TxPwer);
+							TxPwer =
+							    (TxPwer >
+							     0xF) ? (0xF)
+							    : (TxPwer);
+							R3 |= (TxPwer << 10);
+							DBGPRINT(RT_DEBUG_ERROR,
+								 ("AsicSwitchChannel: TxPwer=%d \n",
+								  TxPwer));
+						} else {
+							TxPwer =
+							    (TxPwer >
+							     0xF) ? (0xF)
+							    : (TxPwer);
+							R3 |=
+							    (TxPwer << 10) | (1
+									      <<
+									      9);
 						}
 
-						// Update variables
-						pAd->LatchRfRegs.Channel = Channel;
-						pAd->LatchRfRegs.R1 = RFRegTable[index].R1;
-						pAd->LatchRfRegs.R2 = R2;
-						pAd->LatchRfRegs.R3 = R3;
-						pAd->LatchRfRegs.R4 = R4;
-
-						// Set RF value 1's set R3[bit2] = [0]
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
-						RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
-
-						RTMPusecDelay(200);
-
-						// Set RF value 2's set R3[bit2] = [1]
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
-						RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 | 0x04));
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
-
-						RTMPusecDelay(200);
-
-						// Set RF value 3's set R3[bit2] = [0]
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
-						RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
-						RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+						// R4
+						if ((TxPwer2 >= -7)
+						    && (TxPwer2 < 0)) {
+							TxPwer2 = (7 + TxPwer2);
+							TxPwer2 =
+							    (TxPwer2 >
+							     0xF) ? (0xF)
+							    : (TxPwer2);
+							R4 |= (TxPwer2 << 7);
+							DBGPRINT(RT_DEBUG_ERROR,
+								 ("AsicSwitchChannel: TxPwer2=%d \n",
+								  TxPwer2));
+						} else {
+							TxPwer2 =
+							    (TxPwer2 >
+							     0xF) ? (0xF)
+							    : (TxPwer2);
+							R4 |=
+							    (TxPwer2 << 7) | (1
+									      <<
+									      6);
+						}
+					} else {
+						R3 = (RFRegTable[index].R3 & 0xffffc1ff) | (TxPwer << 9);	// set TX power0
+						R4 = (RFRegTable[index].R4 & (~0x001f87c0)) | (pAd->RfFreqOffset << 15) | (TxPwer2 << 6);	// Set freq Offset & TxPwr1
+					}
 
-						break;
+					// Based on BBP current mode before changing RF channel.
+					if (!bScan
+					    && (pAd->CommonCfg.BBPCurrentBW ==
+						BW_40)) {
+						R4 |= 0x200000;
 					}
+					// Update variables
+					pAd->LatchRfRegs.Channel = Channel;
+					pAd->LatchRfRegs.R1 =
+					    RFRegTable[index].R1;
+					pAd->LatchRfRegs.R2 = R2;
+					pAd->LatchRfRegs.R3 = R3;
+					pAd->LatchRfRegs.R4 = R4;
+
+					// Set RF value 1's set R3[bit2] = [0]
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R1);
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R2);
+					RTMP_RF_IO_WRITE32(pAd,
+							   (pAd->LatchRfRegs.
+							    R3 & (~0x04)));
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R4);
+
+					RTMPusecDelay(200);
+
+					// Set RF value 2's set R3[bit2] = [1]
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R1);
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R2);
+					RTMP_RF_IO_WRITE32(pAd,
+							   (pAd->LatchRfRegs.
+							    R3 | 0x04));
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R4);
+
+					RTMPusecDelay(200);
+
+					// Set RF value 3's set R3[bit2] = [0]
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R1);
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R2);
+					RTMP_RF_IO_WRITE32(pAd,
+							   (pAd->LatchRfRegs.
+							    R3 & (~0x04)));
+					RTMP_RF_IO_WRITE32(pAd,
+							   pAd->LatchRfRegs.R4);
+
+					break;
 				}
-				break;
+			}
+			break;
 
-			default:
-				break;
+		default:
+			break;
 		}
 
-		DBGPRINT(RT_DEBUG_TRACE, ("SwitchChannel#%d(RF=%d, Pwr0=%lu, Pwr1=%lu, %dT) to , R1=0x%08lx, R2=0x%08lx, R3=0x%08lx, R4=0x%08lx\n",
-							  Channel,
-							  pAd->RfIcType,
-							  (R3 & 0x00003e00) >> 9,
-							  (R4 & 0x000007c0) >> 6,
-							  pAd->Antenna.field.TxPath,
-							  pAd->LatchRfRegs.R1,
-							  pAd->LatchRfRegs.R2,
-							  pAd->LatchRfRegs.R3,
-							  pAd->LatchRfRegs.R4));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("SwitchChannel#%d(RF=%d, Pwr0=%lu, Pwr1=%lu, %dT) to , R1=0x%08lx, R2=0x%08lx, R3=0x%08lx, R4=0x%08lx\n",
+			  Channel, pAd->RfIcType, (R3 & 0x00003e00) >> 9,
+			  (R4 & 0x000007c0) >> 6, pAd->Antenna.field.TxPath,
+			  pAd->LatchRfRegs.R1, pAd->LatchRfRegs.R2,
+			  pAd->LatchRfRegs.R3, pAd->LatchRfRegs.R4));
 	}
 
 	// Change BBP setting during siwtch from a->g, g->a
-	if (Channel <= 14)
-	{
-		ULONG	TxPinCfg = 0x00050F0A;//Gary 2007/08/09 0x050A0A
+	if (Channel <= 14) {
+		ULONG TxPinCfg = 0x00050F0A;	//Gary 2007/08/09 0x050A0A
 
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R62, (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R63, (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R64, (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);//(0x44 - GET_LNA_GAIN(pAd)));	// According the Rory's suggestion to solve the middle range issue.
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R62,
+					     (0x37 - GET_LNA_GAIN(pAd)));
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R63,
+					     (0x37 - GET_LNA_GAIN(pAd)));
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R64,
+					     (0x37 - GET_LNA_GAIN(pAd)));
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);	//(0x44 - GET_LNA_GAIN(pAd)));    // According the Rory's suggestion to solve the middle range issue.
 		//RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x62);
 
 		// Rx High power VGA offset for LNA select
-		if (pAd->NicConfig2.field.ExternalLNAForG)
-		{
+		if (pAd->NicConfig2.field.ExternalLNAForG) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x62);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x46);
-		}
-		else
-		{
+		} else {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x84);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x50);
 		}
@@ -796,58 +918,54 @@ VOID AsicSwitchChannel(
 		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
 
 		// Turn off unused PA or LNA when only 1T or 1R
-		if (pAd->Antenna.field.TxPath == 1)
-		{
+		if (pAd->Antenna.field.TxPath == 1) {
 			TxPinCfg &= 0xFFFFFFF3;
 		}
-		if (pAd->Antenna.field.RxPath == 1)
-		{
+		if (pAd->Antenna.field.RxPath == 1) {
 			TxPinCfg &= 0xFFFFF3FF;
 		}
 
-
 		RTMP_IO_WRITE32(pAd, TX_PIN_CFG, TxPinCfg);
 
 #if defined(RT3090) || defined(RT3390)
 		// PCIe PHY Transmit attenuation adjustment
 		if (IS_RT3090A(pAd) || IS_RT3390(pAd)) {
-			TX_ATTENUATION_CTRL_STRUC
-				TxAttenuationCtrl = { .word = 0 };
+			TX_ATTENUATION_CTRL_STRUC TxAttenuationCtrl = {
+			.word = 0};
 
-			RTMP_IO_READ32(pAd, PCIE_PHY_TX_ATTENUATION_CTRL, &TxAttenuationCtrl.word);
+			RTMP_IO_READ32(pAd, PCIE_PHY_TX_ATTENUATION_CTRL,
+				       &TxAttenuationCtrl.word);
 
-			if (Channel == 14) // Channel #14
+			if (Channel == 14)	// Channel #14
 			{
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 1; // Enable PCIe PHY Tx attenuation
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 4; // 9/16 full drive level
-			}
-			else // Channel #1~#13
+				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 1;	// Enable PCIe PHY Tx attenuation
+				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 4;	// 9/16 full drive level
+			} else	// Channel #1~#13
 			{
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 0; // Disable PCIe PHY Tx attenuation
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 0; // n/a
+				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 0;	// Disable PCIe PHY Tx attenuation
+				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 0;	// n/a
 			}
 
-			RTMP_IO_WRITE32(pAd, PCIE_PHY_TX_ATTENUATION_CTRL, TxAttenuationCtrl.word);
+			RTMP_IO_WRITE32(pAd, PCIE_PHY_TX_ATTENUATION_CTRL,
+					TxAttenuationCtrl.word);
 		}
 #endif
-	}
-	else
-	{
-		ULONG	TxPinCfg = 0x00050F05;//Gary 2007/8/9 0x050505
+	} else {
+		ULONG TxPinCfg = 0x00050F05;	//Gary 2007/8/9 0x050505
 
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R62, (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R63, (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R64, (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);//(0x44 - GET_LNA_GAIN(pAd)));   // According the Rory's suggestion to solve the middle range issue.
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0xF2);
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R62,
+					     (0x37 - GET_LNA_GAIN(pAd)));
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R63,
+					     (0x37 - GET_LNA_GAIN(pAd)));
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R64,
+					     (0x37 - GET_LNA_GAIN(pAd)));
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);	//(0x44 - GET_LNA_GAIN(pAd)));   // According the Rory's suggestion to solve the middle range issue.
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0xF2);
 
 		// Rx High power VGA offset for LNA select
-		if (pAd->NicConfig2.field.ExternalLNAForA)
-		{
+		if (pAd->NicConfig2.field.ExternalLNAForA) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x46);
-		}
-		else
-		{
+		} else {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x50);
 		}
 
@@ -858,16 +976,13 @@ VOID AsicSwitchChannel(
 		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
 
 		// Turn off unused PA or LNA when only 1T or 1R
-		if (pAd->Antenna.field.TxPath == 1)
-		{
+		if (pAd->Antenna.field.TxPath == 1) {
 			TxPinCfg &= 0xFFFFFFF3;
 		}
-		if (pAd->Antenna.field.RxPath == 1)
-		{
+		if (pAd->Antenna.field.RxPath == 1) {
 			TxPinCfg &= 0xFFFFF3FF;
 		}
 
-
 		RTMP_IO_WRITE32(pAd, TX_PIN_CFG, TxPinCfg);
 
 	}
@@ -887,10 +1002,9 @@ VOID AsicSwitchChannel(
 	RTMPusecDelay(1000);
 }
 
-VOID AsicResetBBPAgent(
-IN PRTMP_ADAPTER pAd)
+VOID AsicResetBBPAgent(IN PRTMP_ADAPTER pAd)
 {
-	BBP_CSR_CFG_STRUC	BbpCsr;
+	BBP_CSR_CFG_STRUC BbpCsr;
 	DBGPRINT(RT_DEBUG_ERROR, ("Reset BBP Agent busy bit.!! \n"));
 	// Still need to find why BBP agent keeps busy, but in fact, hardware still function ok. Now clear busy first.
 	RTMP_IO_READ32(pAd, H2M_BBP_AGENT, &BbpCsr.word);
@@ -911,17 +1025,13 @@ IN PRTMP_ADAPTER pAd)
 
 	==========================================================================
  */
-VOID AsicLockChannel(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR Channel)
+VOID AsicLockChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
 {
 }
 
-VOID AsicRfTuningExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+VOID AsicRfTuningExec(IN PVOID SystemSpecific1,
+		      IN PVOID FunctionContext,
+		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
 }
 
@@ -942,65 +1052,53 @@ VOID AsicRfTuningExec(
 		it should be called AFTER MlmeDynamicTxRatSwitching()
 	==========================================================================
  */
-VOID AsicAdjustTxPower(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicAdjustTxPower(IN PRTMP_ADAPTER pAd)
 {
-	INT			i, j;
-	CHAR		DeltaPwr = 0;
-	BOOLEAN		bAutoTxAgc = FALSE;
-	UCHAR		TssiRef, *pTssiMinusBoundary, *pTssiPlusBoundary, TxAgcStep;
-	UCHAR		BbpR1 = 0, BbpR49 = 0, idx;
-	PCHAR		pTxAgcCompensate;
-	ULONG		TxPwr[5];
-	CHAR		Value;
-	CHAR		Rssi = -127;
-
-
+	INT i, j;
+	CHAR DeltaPwr = 0;
+	BOOLEAN bAutoTxAgc = FALSE;
+	UCHAR TssiRef, *pTssiMinusBoundary, *pTssiPlusBoundary, TxAgcStep;
+	UCHAR BbpR1 = 0, BbpR49 = 0, idx;
+	PCHAR pTxAgcCompensate;
+	ULONG TxPwr[5];
+	CHAR Value;
+	CHAR Rssi = -127;
 
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE) ||
 #ifdef RTMP_MAC_PCI
-		(pAd->bPCIclkOff == TRUE) ||
+	    (pAd->bPCIclkOff == TRUE) ||
 #endif // RTMP_MAC_PCI //
-		RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF) ||
-		RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+	    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF) ||
+	    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
 		return;
 
-		Rssi = RTMPMaxRssi(pAd,
-						   pAd->StaCfg.RssiSample.AvgRssi0,
-						   pAd->StaCfg.RssiSample.AvgRssi1,
-						   pAd->StaCfg.RssiSample.AvgRssi2);
+	Rssi = RTMPMaxRssi(pAd,
+			   pAd->StaCfg.RssiSample.AvgRssi0,
+			   pAd->StaCfg.RssiSample.AvgRssi1,
+			   pAd->StaCfg.RssiSample.AvgRssi2);
 
-	if (pAd->CommonCfg.BBPCurrentBW == BW_40)
-	{
-		if (pAd->CommonCfg.CentralChannel > 14)
-		{
+	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
+		if (pAd->CommonCfg.CentralChannel > 14) {
 			TxPwr[0] = pAd->Tx40MPwrCfgABand[0];
 			TxPwr[1] = pAd->Tx40MPwrCfgABand[1];
 			TxPwr[2] = pAd->Tx40MPwrCfgABand[2];
 			TxPwr[3] = pAd->Tx40MPwrCfgABand[3];
 			TxPwr[4] = pAd->Tx40MPwrCfgABand[4];
-		}
-		else
-		{
+		} else {
 			TxPwr[0] = pAd->Tx40MPwrCfgGBand[0];
 			TxPwr[1] = pAd->Tx40MPwrCfgGBand[1];
 			TxPwr[2] = pAd->Tx40MPwrCfgGBand[2];
 			TxPwr[3] = pAd->Tx40MPwrCfgGBand[3];
 			TxPwr[4] = pAd->Tx40MPwrCfgGBand[4];
 		}
-	}
-	else
-	{
-		if (pAd->CommonCfg.Channel > 14)
-		{
+	} else {
+		if (pAd->CommonCfg.Channel > 14) {
 			TxPwr[0] = pAd->Tx20MPwrCfgABand[0];
 			TxPwr[1] = pAd->Tx20MPwrCfgABand[1];
 			TxPwr[2] = pAd->Tx20MPwrCfgABand[2];
 			TxPwr[3] = pAd->Tx20MPwrCfgABand[3];
 			TxPwr[4] = pAd->Tx20MPwrCfgABand[4];
-		}
-		else
-		{
+		} else {
 			TxPwr[0] = pAd->Tx20MPwrCfgGBand[0];
 			TxPwr[1] = pAd->Tx20MPwrCfgGBand[1];
 			TxPwr[2] = pAd->Tx20MPwrCfgGBand[2];
@@ -1010,31 +1108,26 @@ VOID AsicAdjustTxPower(
 	}
 
 	// TX power compensation for temperature variation based on TSSI. try every 4 second
-	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0)
-	{
-		if (pAd->CommonCfg.Channel <= 14)
-		{
+	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0) {
+		if (pAd->CommonCfg.Channel <= 14) {
 			/* bg channel */
-			bAutoTxAgc         = pAd->bAutoTxAgcG;
-			TssiRef            = pAd->TssiRefG;
+			bAutoTxAgc = pAd->bAutoTxAgcG;
+			TssiRef = pAd->TssiRefG;
 			pTssiMinusBoundary = &pAd->TssiMinusBoundaryG[0];
-			pTssiPlusBoundary  = &pAd->TssiPlusBoundaryG[0];
-			TxAgcStep          = pAd->TxAgcStepG;
-			pTxAgcCompensate   = &pAd->TxAgcCompensateG;
-		}
-		else
-		{
+			pTssiPlusBoundary = &pAd->TssiPlusBoundaryG[0];
+			TxAgcStep = pAd->TxAgcStepG;
+			pTxAgcCompensate = &pAd->TxAgcCompensateG;
+		} else {
 			/* a channel */
-			bAutoTxAgc         = pAd->bAutoTxAgcA;
-			TssiRef            = pAd->TssiRefA;
+			bAutoTxAgc = pAd->bAutoTxAgcA;
+			TssiRef = pAd->TssiRefA;
 			pTssiMinusBoundary = &pAd->TssiMinusBoundaryA[0];
-			pTssiPlusBoundary  = &pAd->TssiPlusBoundaryA[0];
-			TxAgcStep          = pAd->TxAgcStepA;
-			pTxAgcCompensate   = &pAd->TxAgcCompensateA;
+			pTssiPlusBoundary = &pAd->TssiPlusBoundaryA[0];
+			TxAgcStep = pAd->TxAgcStepA;
+			pTxAgcCompensate = &pAd->TxAgcCompensateA;
 		}
 
-		if (bAutoTxAgc)
-		{
+		if (bAutoTxAgc) {
 			/* BbpR1 is unsigned char */
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R49, &BbpR49);
 
@@ -1051,59 +1144,50 @@ VOID AsicAdjustTxPower(
 			/* if value is between p1 ~ o1 or o1 ~ s1, no need to adjust tx power */
 			/* if value is 0xa5, tx power will be -= TxAgcStep*(2-1) */
 
-			if (BbpR49 > pTssiMinusBoundary[1])
-			{
+			if (BbpR49 > pTssiMinusBoundary[1]) {
 				// Reading is larger than the reference value
 				// check for how large we need to decrease the Tx power
-				for (idx = 1; idx < 5; idx++)
-				{
-					if (BbpR49 <= pTssiMinusBoundary[idx])  // Found the range
+				for (idx = 1; idx < 5; idx++) {
+					if (BbpR49 <= pTssiMinusBoundary[idx])	// Found the range
 						break;
 				}
 				// The index is the step we should decrease, idx = 0 means there is nothing to compensate
-//				if (R3 > (ULONG) (TxAgcStep * (idx-1)))
-					*pTxAgcCompensate = -(TxAgcStep * (idx-1));
-//				else
-//					*pTxAgcCompensate = -((UCHAR)R3);
+//                              if (R3 > (ULONG) (TxAgcStep * (idx-1)))
+				*pTxAgcCompensate = -(TxAgcStep * (idx - 1));
+//                              else
+//                                      *pTxAgcCompensate = -((UCHAR)R3);
 
 				DeltaPwr += (*pTxAgcCompensate);
-				DBGPRINT(RT_DEBUG_TRACE, ("-- Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = -%d\n",
-					BbpR49, TssiRef, TxAgcStep, idx-1));
-			}
-			else if (BbpR49 < pTssiPlusBoundary[1])
-			{
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("-- Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = -%d\n",
+					  BbpR49, TssiRef, TxAgcStep, idx - 1));
+			} else if (BbpR49 < pTssiPlusBoundary[1]) {
 				// Reading is smaller than the reference value
 				// check for how large we need to increase the Tx power
-				for (idx = 1; idx < 5; idx++)
-				{
-					if (BbpR49 >= pTssiPlusBoundary[idx])   // Found the range
+				for (idx = 1; idx < 5; idx++) {
+					if (BbpR49 >= pTssiPlusBoundary[idx])	// Found the range
 						break;
 				}
 				// The index is the step we should increase, idx = 0 means there is nothing to compensate
-				*pTxAgcCompensate = TxAgcStep * (idx-1);
+				*pTxAgcCompensate = TxAgcStep * (idx - 1);
 				DeltaPwr += (*pTxAgcCompensate);
-				DBGPRINT(RT_DEBUG_TRACE, ("++ Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = +%d\n",
-					BbpR49, TssiRef, TxAgcStep, idx-1));
-			}
-			else
-			{
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("++ Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = +%d\n",
+					  BbpR49, TssiRef, TxAgcStep, idx - 1));
+			} else {
 				*pTxAgcCompensate = 0;
-				DBGPRINT(RT_DEBUG_TRACE, ("   Tx Power, BBP R49=%x, TssiRef=%x, TxAgcStep=%x, step = +%d\n",
-					BbpR49, TssiRef, TxAgcStep, 0));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("   Tx Power, BBP R49=%x, TssiRef=%x, TxAgcStep=%x, step = +%d\n",
+					  BbpR49, TssiRef, TxAgcStep, 0));
 			}
 		}
-	}
-	else
-	{
-		if (pAd->CommonCfg.Channel <= 14)
-		{
-			bAutoTxAgc         = pAd->bAutoTxAgcG;
-			pTxAgcCompensate   = &pAd->TxAgcCompensateG;
-		}
-		else
-		{
-			bAutoTxAgc         = pAd->bAutoTxAgcA;
-			pTxAgcCompensate   = &pAd->TxAgcCompensateA;
+	} else {
+		if (pAd->CommonCfg.Channel <= 14) {
+			bAutoTxAgc = pAd->bAutoTxAgcG;
+			pTxAgcCompensate = &pAd->TxAgcCompensateG;
+		} else {
+			bAutoTxAgc = pAd->bAutoTxAgcA;
+			pTxAgcCompensate = &pAd->TxAgcCompensateA;
 		}
 
 		if (bAutoTxAgc)
@@ -1113,46 +1197,35 @@ VOID AsicAdjustTxPower(
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &BbpR1);
 	BbpR1 &= 0xFC;
 
-
 	/* calculate delta power based on the percentage specified from UI */
 	// E2PROM setting is calibrated for maximum TX power (i.e. 100%)
 	// We lower TX power here according to the percentage specified from UI
-	if (pAd->CommonCfg.TxPowerPercentage == 0xffffffff)       // AUTO TX POWER control
+	if (pAd->CommonCfg.TxPowerPercentage == 0xffffffff)	// AUTO TX POWER control
 	{
 		{
 			// to patch high power issue with some APs, like Belkin N1.
-			if (Rssi > -35)
-			{
-				BbpR1 |= 0x02;		// DeltaPwr -= 12;
-			}
-			else if (Rssi > -40)
-			{
-				BbpR1 |= 0x01;		// DeltaPwr -= 6;
-			}
-			else
-		;
+			if (Rssi > -35) {
+				BbpR1 |= 0x02;	// DeltaPwr -= 12;
+			} else if (Rssi > -40) {
+				BbpR1 |= 0x01;	// DeltaPwr -= 6;
+			} else;
 		}
-	}
-	else if (pAd->CommonCfg.TxPowerPercentage > 90)  // 91 ~ 100% & AUTO, treat as 100% in terms of mW
+	} else if (pAd->CommonCfg.TxPowerPercentage > 90)	// 91 ~ 100% & AUTO, treat as 100% in terms of mW
 		;
-	else if (pAd->CommonCfg.TxPowerPercentage > 60)  // 61 ~ 90%, treat as 75% in terms of mW		// DeltaPwr -= 1;
+	else if (pAd->CommonCfg.TxPowerPercentage > 60)	// 61 ~ 90%, treat as 75% in terms of mW               // DeltaPwr -= 1;
 	{
 		DeltaPwr -= 1;
-	}
-	else if (pAd->CommonCfg.TxPowerPercentage > 30)  // 31 ~ 60%, treat as 50% in terms of mW		// DeltaPwr -= 3;
+	} else if (pAd->CommonCfg.TxPowerPercentage > 30)	// 31 ~ 60%, treat as 50% in terms of mW               // DeltaPwr -= 3;
 	{
 		DeltaPwr -= 3;
-	}
-	else if (pAd->CommonCfg.TxPowerPercentage > 15)  // 16 ~ 30%, treat as 25% in terms of mW		// DeltaPwr -= 6;
+	} else if (pAd->CommonCfg.TxPowerPercentage > 15)	// 16 ~ 30%, treat as 25% in terms of mW               // DeltaPwr -= 6;
 	{
 		BbpR1 |= 0x01;
-	}
-	else if (pAd->CommonCfg.TxPowerPercentage > 9)   // 10 ~ 15%, treat as 12.5% in terms of mW		// DeltaPwr -= 9;
+	} else if (pAd->CommonCfg.TxPowerPercentage > 9)	// 10 ~ 15%, treat as 12.5% in terms of mW             // DeltaPwr -= 9;
 	{
 		BbpR1 |= 0x01;
 		DeltaPwr -= 3;
-	}
-	else                                           // 0 ~ 9 %, treat as MIN(~3%) in terms of mW		// DeltaPwr -= 12;
+	} else			// 0 ~ 9 %, treat as MIN(~3%) in terms of mW             // DeltaPwr -= 12;
 	{
 		BbpR1 |= 0x02;
 	}
@@ -1160,45 +1233,38 @@ VOID AsicAdjustTxPower(
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, BbpR1);
 
 	/* reset different new tx power for different TX rate */
-	for(i=0; i<5; i++)
-	{
-		if (TxPwr[i] != 0xffffffff)
-		{
-			for (j=0; j<8; j++)
-			{
-				Value = (CHAR)((TxPwr[i] >> j*4) & 0x0F); /* 0 ~ 15 */
-
-				if ((Value + DeltaPwr) < 0)
-				{
-					Value = 0; /* min */
-				}
-				else if ((Value + DeltaPwr) > 0xF)
-				{
-					Value = 0xF; /* max */
-				}
-				else
-				{
-					Value += DeltaPwr; /* temperature compensation */
+	for (i = 0; i < 5; i++) {
+		if (TxPwr[i] != 0xffffffff) {
+			for (j = 0; j < 8; j++) {
+				Value = (CHAR) ((TxPwr[i] >> j * 4) & 0x0F);	/* 0 ~ 15 */
+
+				if ((Value + DeltaPwr) < 0) {
+					Value = 0;	/* min */
+				} else if ((Value + DeltaPwr) > 0xF) {
+					Value = 0xF;	/* max */
+				} else {
+					Value += DeltaPwr;	/* temperature compensation */
 				}
 
 				/* fill new value to CSR offset */
-				TxPwr[i] = (TxPwr[i] & ~(0x0000000F << j*4)) | (Value << j*4);
+				TxPwr[i] =
+				    (TxPwr[i] & ~(0x0000000F << j * 4)) | (Value
+									   << j
+									   * 4);
 			}
 
 			/* write tx power value to CSR */
-			/* TX_PWR_CFG_0 (8 tx rate) for	TX power for OFDM 12M/18M
-											TX power for OFDM 6M/9M
-											TX power for CCK5.5M/11M
-											TX power for CCK1M/2M */
+			/* TX_PWR_CFG_0 (8 tx rate) for TX power for OFDM 12M/18M
+			   TX power for OFDM 6M/9M
+			   TX power for CCK5.5M/11M
+			   TX power for CCK1M/2M */
 			/* TX_PWR_CFG_1 ~ TX_PWR_CFG_4 */
-			RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + i*4, TxPwr[i]);
+			RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + i * 4, TxPwr[i]);
 		}
 	}
 
-
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1211,9 +1277,8 @@ VOID AsicAdjustTxPower(
 
 	==========================================================================
  */
-VOID AsicSleepThenAutoWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT TbttNumToNextWakeUp)
+VOID AsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
+			     IN USHORT TbttNumToNextWakeUp)
 {
 	RTMP_STA_SLEEP_THEN_AUTO_WAKEUP(pAd, TbttNumToNextWakeUp);
 }
@@ -1226,8 +1291,7 @@ VOID AsicSleepThenAutoWakeup(
 		in INFRA BSS, we should use AsicSleepThenAutoWakeup() instead.
 	==========================================================================
  */
-VOID AsicForceSleep(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicForceSleep(IN PRTMP_ADAPTER pAd)
 {
 
 }
@@ -1242,15 +1306,12 @@ VOID AsicForceSleep(
 	IRQL = DISPATCH_LEVEL
 	==========================================================================
  */
-VOID AsicForceWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN BOOLEAN    bFromTx)
+VOID AsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 {
-    DBGPRINT(RT_DEBUG_INFO, ("--> AsicForceWakeup \n"));
-    RTMP_STA_FORCE_WAKEUP(pAd, bFromTx);
+	DBGPRINT(RT_DEBUG_INFO, ("--> AsicForceWakeup \n"));
+	RTMP_STA_FORCE_WAKEUP(pAd, bFromTx);
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1260,36 +1321,33 @@ VOID AsicForceWakeup(
 
 	==========================================================================
  */
-VOID AsicSetBssid(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pBssid)
-{
-	ULONG		  Addr4;
-	DBGPRINT(RT_DEBUG_TRACE, ("==============> AsicSetBssid %x:%x:%x:%x:%x:%x\n",
-		pBssid[0],pBssid[1],pBssid[2],pBssid[3], pBssid[4],pBssid[5]));
-
-	Addr4 = (ULONG)(pBssid[0])		 |
-			(ULONG)(pBssid[1] << 8)  |
-			(ULONG)(pBssid[2] << 16) |
-			(ULONG)(pBssid[3] << 24);
+VOID AsicSetBssid(IN PRTMP_ADAPTER pAd, IN PUCHAR pBssid)
+{
+	ULONG Addr4;
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("==============> AsicSetBssid %x:%x:%x:%x:%x:%x\n", pBssid[0],
+		  pBssid[1], pBssid[2], pBssid[3], pBssid[4], pBssid[5]));
+
+	Addr4 = (ULONG) (pBssid[0]) |
+	    (ULONG) (pBssid[1] << 8) |
+	    (ULONG) (pBssid[2] << 16) | (ULONG) (pBssid[3] << 24);
 	RTMP_IO_WRITE32(pAd, MAC_BSSID_DW0, Addr4);
 
 	Addr4 = 0;
 	// always one BSSID in STA mode
-	Addr4 = (ULONG)(pBssid[4]) | (ULONG)(pBssid[5] << 8);
+	Addr4 = (ULONG) (pBssid[4]) | (ULONG) (pBssid[5] << 8);
 
 	RTMP_IO_WRITE32(pAd, MAC_BSSID_DW1, Addr4);
 }
 
-VOID AsicSetMcastWC(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicSetMcastWC(IN PRTMP_ADAPTER pAd)
 {
 	MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[MCAST_WCID];
-	USHORT		offset;
+	USHORT offset;
 
-	pEntry->Sst        = SST_ASSOC;
-	pEntry->Aid        = MCAST_WCID;	// Softap supports 1 BSSID and use WCID=0 as multicast Wcid index
-	pEntry->PsMode     = PWR_ACTIVE;
+	pEntry->Sst = SST_ASSOC;
+	pEntry->Aid = MCAST_WCID;	// Softap supports 1 BSSID and use WCID=0 as multicast Wcid index
+	pEntry->PsMode = PWR_ACTIVE;
 	pEntry->CurrTxRate = pAd->CommonCfg.MlmeRate;
 	offset = MAC_WCID_BASE + BSS0Mcast_WCID * HW_WCID_ENTRY_SIZE;
 }
@@ -1302,14 +1360,12 @@ VOID AsicSetMcastWC(
 
 	==========================================================================
  */
-VOID AsicDelWcidTab(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR	Wcid)
+VOID AsicDelWcidTab(IN PRTMP_ADAPTER pAd, IN UCHAR Wcid)
 {
-	ULONG		  Addr0 = 0x0, Addr1 = 0x0;
-	ULONG		offset;
+	ULONG Addr0 = 0x0, Addr1 = 0x0;
+	ULONG offset;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("AsicDelWcidTab==>Wcid = 0x%x\n",Wcid));
+	DBGPRINT(RT_DEBUG_TRACE, ("AsicDelWcidTab==>Wcid = 0x%x\n", Wcid));
 	offset = MAC_WCID_BASE + Wcid * HW_WCID_ENTRY_SIZE;
 	RTMP_IO_WRITE32(pAd, offset, Addr0);
 	offset += 4;
@@ -1324,19 +1380,18 @@ VOID AsicDelWcidTab(
 
 	==========================================================================
  */
-VOID AsicEnableRDG(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicEnableRDG(IN PRTMP_ADAPTER pAd)
 {
-	TX_LINK_CFG_STRUC	TxLinkCfg;
-	UINT32				Data = 0;
+	TX_LINK_CFG_STRUC TxLinkCfg;
+	UINT32 Data = 0;
 
 	RTMP_IO_READ32(pAd, TX_LINK_CFG, &TxLinkCfg.word);
 	TxLinkCfg.field.TxRDGEn = 1;
 	RTMP_IO_WRITE32(pAd, TX_LINK_CFG, TxLinkCfg.word);
 
 	RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-	Data  &= 0xFFFFFF00;
-	Data  |= 0x80;
+	Data &= 0xFFFFFF00;
+	Data |= 0x80;
 	RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
 
 	//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
@@ -1350,12 +1405,10 @@ VOID AsicEnableRDG(
 
 	==========================================================================
  */
-VOID AsicDisableRDG(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicDisableRDG(IN PRTMP_ADAPTER pAd)
 {
-	TX_LINK_CFG_STRUC	TxLinkCfg;
-	UINT32				Data = 0;
-
+	TX_LINK_CFG_STRUC TxLinkCfg;
+	UINT32 Data = 0;
 
 	RTMP_IO_READ32(pAd, TX_LINK_CFG, &TxLinkCfg.word);
 	TxLinkCfg.field.TxRDGEn = 0;
@@ -1363,19 +1416,18 @@ VOID AsicDisableRDG(
 
 	RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
 
-	Data  &= 0xFFFFFF00;
+	Data &= 0xFFFFFF00;
 	//Data  |= 0x20;
 #ifndef WIFI_TEST
 	//if ( pAd->CommonCfg.bEnableTxBurst )
-	//	Data |= 0x60; // for performance issue not set the TXOP to 0
+	//      Data |= 0x60; // for performance issue not set the TXOP to 0
 #endif
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_DYNAMIC_BE_TXOP_ACTIVE)
-		&& (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
-	)
-	{
+	    && (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
+	    ) {
 		// For CWC test, change txop from 0x30 to 0x20 in TxBurst mode
 		if (pAd->CommonCfg.bEnableTxBurst)
-		Data |= 0x20;
+			Data |= 0x20;
 	}
 	RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
 }
@@ -1389,16 +1441,15 @@ VOID AsicDisableRDG(
 
 	==========================================================================
  */
-VOID AsicDisableSync(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicDisableSync(IN PRTMP_ADAPTER pAd)
 {
 	BCN_TIME_CFG_STRUC csr;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--->Disable TSF synchronization\n"));
 
 	// 2003-12-20 disable TSF and TBTT while NIC in power-saving have side effect
-	//			  that NIC will never wakes up because TSF stops and no more
-	//			  TBTT interrupts
+	//                        that NIC will never wakes up because TSF stops and no more
+	//                        TBTT interrupts
 	pAd->TbttTickCount = 0;
 	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
 	csr.field.bBeaconGen = 0;
@@ -1417,20 +1468,19 @@ VOID AsicDisableSync(
 
 	==========================================================================
  */
-VOID AsicEnableBssSync(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicEnableBssSync(IN PRTMP_ADAPTER pAd)
 {
 	BCN_TIME_CFG_STRUC csr;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--->AsicEnableBssSync(INFRA mode)\n"));
 
 	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-//	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, 0x00000000);
+//      RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, 0x00000000);
 	{
-		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
+		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4;	// ASIC register in units of 1/16 TU
 		csr.field.bTsfTicking = 1;
-		csr.field.TsfSyncMode = 1; // sync TSF in INFRASTRUCTURE mode
-		csr.field.bBeaconGen  = 0; // do NOT generate BEACON
+		csr.field.TsfSyncMode = 1;	// sync TSF in INFRASTRUCTURE mode
+		csr.field.bBeaconGen = 0;	// do NOT generate BEACON
 		csr.field.bTBTTEnable = 1;
 	}
 	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
@@ -1448,14 +1498,15 @@ VOID AsicEnableBssSync(
 
 	==========================================================================
  */
-VOID AsicEnableIbssSync(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicEnableIbssSync(IN PRTMP_ADAPTER pAd)
 {
 	BCN_TIME_CFG_STRUC csr9;
-	PUCHAR			ptr;
+	PUCHAR ptr;
 	UINT i;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("--->AsicEnableIbssSync(ADHOC mode. MPDUtotalByteCount = %d)\n", pAd->BeaconTxWI.MPDUtotalByteCount));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("--->AsicEnableIbssSync(ADHOC mode. MPDUtotalByteCount = %d)\n",
+		  pAd->BeaconTxWI.MPDUtotalByteCount));
 
 	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr9.word);
 	csr9.field.bBeaconGen = 0;
@@ -1465,27 +1516,30 @@ VOID AsicEnableIbssSync(
 
 #ifdef RTMP_MAC_PCI
 	// move BEACON TXD and frame content to on-chip memory
-	ptr = (PUCHAR)&pAd->BeaconTxWI;
-	for (i=0; i<TXWI_SIZE; i+=4)  // 16-byte TXWI field
+	ptr = (PUCHAR) & pAd->BeaconTxWI;
+	for (i = 0; i < TXWI_SIZE; i += 4)	// 16-byte TXWI field
 	{
-		UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
+		UINT32 longptr =
+		    *ptr + (*(ptr + 1) << 8) + (*(ptr + 2) << 16) +
+		    (*(ptr + 3) << 24);
 		RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + i, longptr);
 		ptr += 4;
 	}
 
 	// start right after the 16-byte TXWI field
 	ptr = pAd->BeaconBuf;
-	for (i=0; i< pAd->BeaconTxWI.MPDUtotalByteCount; i+=4)
-	{
-		UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
+	for (i = 0; i < pAd->BeaconTxWI.MPDUtotalByteCount; i += 4) {
+		UINT32 longptr =
+		    *ptr + (*(ptr + 1) << 8) + (*(ptr + 2) << 16) +
+		    (*(ptr + 3) << 24);
 		RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr);
-		ptr +=4;
+		ptr += 4;
 	}
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
 	// move BEACON TXD and frame content to on-chip memory
-	ptr = (PUCHAR)&pAd->BeaconTxWI;
-	for (i=0; i<TXWI_SIZE; i+=2)  // 16-byte TXWI field
+	ptr = (PUCHAR) & pAd->BeaconTxWI;
+	for (i = 0; i < TXWI_SIZE; i += 2)	// 16-byte TXWI field
 	{
 		//UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
 		//RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + i, longptr);
@@ -1495,12 +1549,11 @@ VOID AsicEnableIbssSync(
 
 	// start right after the 16-byte TXWI field
 	ptr = pAd->BeaconBuf;
-	for (i=0; i< pAd->BeaconTxWI.MPDUtotalByteCount; i+=2)
-	{
+	for (i = 0; i < pAd->BeaconTxWI.MPDUtotalByteCount; i += 2) {
 		//UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
 		//RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr);
 		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, ptr, 2);
-		ptr +=2;
+		ptr += 2;
 	}
 #endif // RTMP_MAC_USB //
 
@@ -1511,9 +1564,9 @@ VOID AsicEnableIbssSync(
 	//RTMP_IO_WRITE32(pAd, TBTT_SYNC_CFG, 0x00001010);
 
 	// start sending BEACON
-	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
+	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4;	// ASIC register in units of 1/16 TU
 	csr9.field.bTsfTicking = 1;
-	csr9.field.TsfSyncMode = 2; // sync TSF in IBSS mode
+	csr9.field.TsfSyncMode = 2;	// sync TSF in IBSS mode
 	csr9.field.bTBTTEnable = 1;
 	csr9.field.bBeaconGen = 1;
 	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr9.word);
@@ -1528,45 +1581,42 @@ VOID AsicEnableIbssSync(
 
 	==========================================================================
  */
-VOID AsicSetEdcaParm(
-	IN PRTMP_ADAPTER pAd,
-	IN PEDCA_PARM	 pEdcaParm)
+VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 {
-	EDCA_AC_CFG_STRUC   Ac0Cfg, Ac1Cfg, Ac2Cfg, Ac3Cfg;
+	EDCA_AC_CFG_STRUC Ac0Cfg, Ac1Cfg, Ac2Cfg, Ac3Cfg;
 	AC_TXOP_CSR0_STRUC csr0;
 	AC_TXOP_CSR1_STRUC csr1;
-	AIFSN_CSR_STRUC    AifsnCsr;
-	CWMIN_CSR_STRUC    CwminCsr;
-	CWMAX_CSR_STRUC    CwmaxCsr;
+	AIFSN_CSR_STRUC AifsnCsr;
+	CWMIN_CSR_STRUC CwminCsr;
+	CWMAX_CSR_STRUC CwmaxCsr;
 	int i;
 
 	Ac0Cfg.word = 0;
 	Ac1Cfg.word = 0;
 	Ac2Cfg.word = 0;
 	Ac3Cfg.word = 0;
-	if ((pEdcaParm == NULL) || (pEdcaParm->bValid == FALSE))
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("AsicSetEdcaParm\n"));
+	if ((pEdcaParm == NULL) || (pEdcaParm->bValid == FALSE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("AsicSetEdcaParm\n"));
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WMM_INUSED);
-		for (i=0; i<MAX_LEN_OF_MAC_TABLE; i++)
-		{
-			if (pAd->MacTab.Content[i].ValidAsCLI || pAd->MacTab.Content[i].ValidAsApCli)
-				CLIENT_STATUS_CLEAR_FLAG(&pAd->MacTab.Content[i], fCLIENT_STATUS_WMM_CAPABLE);
+		for (i = 0; i < MAX_LEN_OF_MAC_TABLE; i++) {
+			if (pAd->MacTab.Content[i].ValidAsCLI
+			    || pAd->MacTab.Content[i].ValidAsApCli)
+				CLIENT_STATUS_CLEAR_FLAG(&pAd->MacTab.
+							 Content[i],
+							 fCLIENT_STATUS_WMM_CAPABLE);
 		}
 
 		//========================================================
 		//      MAC Register has a copy .
 		//========================================================
 //#ifndef WIFI_TEST
-		if( pAd->CommonCfg.bEnableTxBurst )
-		{
+		if (pAd->CommonCfg.bEnableTxBurst) {
 			// For CWC test, change txop from 0x30 to 0x20 in TxBurst mode
-			Ac0Cfg.field.AcTxop = 0x20; // Suggest by John for TxBurst in HT Mode
-		}
-		else
+			Ac0Cfg.field.AcTxop = 0x20;	// Suggest by John for TxBurst in HT Mode
+		} else
 			Ac0Cfg.field.AcTxop = 0;	// QID_AC_BE
 //#else
-//		Ac0Cfg.field.AcTxop = 0;	// QID_AC_BE
+//              Ac0Cfg.field.AcTxop = 0;        // QID_AC_BE
 //#endif
 		Ac0Cfg.field.Cwmin = CW_MIN_IN_BITS;
 		Ac0Cfg.field.Cwmax = CW_MAX_IN_BITS;
@@ -1579,13 +1629,10 @@ VOID AsicSetEdcaParm(
 		Ac1Cfg.field.Aifsn = 2;
 		RTMP_IO_WRITE32(pAd, EDCA_AC1_CFG, Ac1Cfg.word);
 
-		if (pAd->CommonCfg.PhyMode == PHY_11B)
-		{
+		if (pAd->CommonCfg.PhyMode == PHY_11B) {
 			Ac2Cfg.field.AcTxop = 192;	// AC_VI: 192*32us ~= 6ms
 			Ac3Cfg.field.AcTxop = 96;	// AC_VO: 96*32us  ~= 3ms
-		}
-		else
-		{
+		} else {
 			Ac2Cfg.field.AcTxop = 96;	// AC_VI: 96*32us ~= 3ms
 			Ac3Cfg.field.AcTxop = 48;	// AC_VO: 48*32us ~= 1.5ms
 		}
@@ -1601,18 +1648,15 @@ VOID AsicSetEdcaParm(
 		//========================================================
 		//      DMA Register has a copy too.
 		//========================================================
-		csr0.field.Ac0Txop = 0;		// QID_AC_BE
-		csr0.field.Ac1Txop = 0;		// QID_AC_BK
+		csr0.field.Ac0Txop = 0;	// QID_AC_BE
+		csr0.field.Ac1Txop = 0;	// QID_AC_BK
 		RTMP_IO_WRITE32(pAd, WMM_TXOP0_CFG, csr0.word);
-		if (pAd->CommonCfg.PhyMode == PHY_11B)
-		{
-			csr1.field.Ac2Txop = 192;		// AC_VI: 192*32us ~= 6ms
-			csr1.field.Ac3Txop = 96;		// AC_VO: 96*32us  ~= 3ms
-		}
-		else
-		{
-			csr1.field.Ac2Txop = 96;		// AC_VI: 96*32us ~= 3ms
-			csr1.field.Ac3Txop = 48;		// AC_VO: 48*32us ~= 1.5ms
+		if (pAd->CommonCfg.PhyMode == PHY_11B) {
+			csr1.field.Ac2Txop = 192;	// AC_VI: 192*32us ~= 6ms
+			csr1.field.Ac3Txop = 96;	// AC_VO: 96*32us  ~= 3ms
+		} else {
+			csr1.field.Ac2Txop = 96;	// AC_VI: 96*32us ~= 3ms
+			csr1.field.Ac3Txop = 48;	// AC_VO: 48*32us ~= 1.5ms
 		}
 		RTMP_IO_WRITE32(pAd, WMM_TXOP1_CFG, csr1.word);
 
@@ -1633,9 +1677,7 @@ VOID AsicSetEdcaParm(
 		RTMP_IO_WRITE32(pAd, WMM_AIFSN_CFG, 0x00002222);
 
 		NdisZeroMemory(&pAd->CommonCfg.APEdcaParm, sizeof(EDCA_PARM));
-	}
-	else
-	{
+	} else {
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_WMM_INUSED);
 		//========================================================
 		//      MAC Register has a copy.
@@ -1646,26 +1688,23 @@ VOID AsicSetEdcaParm(
 		//
 		//pEdcaParm->Txop[QID_AC_VI] = pEdcaParm->Txop[QID_AC_VI] * 7 / 10; // rt2860c need this
 
-		Ac0Cfg.field.AcTxop =  pEdcaParm->Txop[QID_AC_BE];
-		Ac0Cfg.field.Cwmin= pEdcaParm->Cwmin[QID_AC_BE];
+		Ac0Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_BE];
+		Ac0Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_BE];
 		Ac0Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_BE];
-		Ac0Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BE]; //+1;
+		Ac0Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BE];	//+1;
 
-		Ac1Cfg.field.AcTxop =  pEdcaParm->Txop[QID_AC_BK];
-		Ac1Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_BK]; //+2;
+		Ac1Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_BK];
+		Ac1Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_BK];	//+2;
 		Ac1Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_BK];
-		Ac1Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BK]; //+1;
+		Ac1Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BK];	//+1;
 
 		Ac2Cfg.field.AcTxop = (pEdcaParm->Txop[QID_AC_VI] * 6) / 10;
-		if(pAd->Antenna.field.TxPath == 1)
-		{
+		if (pAd->Antenna.field.TxPath == 1) {
 			Ac2Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_VI] + 1;
 			Ac2Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_VI] + 1;
-		}
-		else
-		{
-		Ac2Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_VI];
-		Ac2Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_VI];
+		} else {
+			Ac2Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_VI];
+			Ac2Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_VI];
 		}
 		Ac2Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_VI] + 1;
 #ifdef RTMP_MAC_USB
@@ -1675,20 +1714,19 @@ VOID AsicSetEdcaParm(
 		{
 			// Tuning for Wi-Fi WMM S06
 			if (pAd->CommonCfg.bWiFiTest &&
-				pEdcaParm->Aifsn[QID_AC_VI] == 10)
+			    pEdcaParm->Aifsn[QID_AC_VI] == 10)
 				Ac2Cfg.field.Aifsn -= 1;
 
 			// Tuning for TGn Wi-Fi 5.2.32
 			// STA TestBed changes in this item: conexant legacy sta ==> broadcom 11n sta
 			if (STA_TGN_WIFI_ON(pAd) &&
-				pEdcaParm->Aifsn[QID_AC_VI] == 10)
-			{
+			    pEdcaParm->Aifsn[QID_AC_VI] == 10) {
 				Ac0Cfg.field.Aifsn = 3;
 				Ac2Cfg.field.AcTxop = 5;
 			}
 #ifdef RT30xx
-			if (pAd->RfIcType == RFIC_3020 || pAd->RfIcType == RFIC_2020)
-			{
+			if (pAd->RfIcType == RFIC_3020
+			    || pAd->RfIcType == RFIC_2020) {
 				// Tuning for WiFi WMM S3-T07: connexant legacy sta ==> broadcom 11n sta.
 				Ac2Cfg.field.Aifsn = 5;
 			}
@@ -1701,16 +1739,19 @@ VOID AsicSetEdcaParm(
 		Ac3Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_VO];
 
 //#ifdef WIFI_TEST
-		if (pAd->CommonCfg.bWiFiTest)
-		{
-			if (Ac3Cfg.field.AcTxop == 102)
-			{
-			Ac0Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_BE] ? pEdcaParm->Txop[QID_AC_BE] : 10;
-				Ac0Cfg.field.Aifsn  = pEdcaParm->Aifsn[QID_AC_BE]-1; /* AIFSN must >= 1 */
-			Ac1Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_BK];
-				Ac1Cfg.field.Aifsn  = pEdcaParm->Aifsn[QID_AC_BK];
-			Ac2Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_VI];
-			} /* End of if */
+		if (pAd->CommonCfg.bWiFiTest) {
+			if (Ac3Cfg.field.AcTxop == 102) {
+				Ac0Cfg.field.AcTxop =
+				    pEdcaParm->Txop[QID_AC_BE] ? pEdcaParm->
+				    Txop[QID_AC_BE] : 10;
+				Ac0Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BE] - 1;	/* AIFSN must >= 1 */
+				Ac1Cfg.field.AcTxop =
+				    pEdcaParm->Txop[QID_AC_BK];
+				Ac1Cfg.field.Aifsn =
+				    pEdcaParm->Aifsn[QID_AC_BK];
+				Ac2Cfg.field.AcTxop =
+				    pEdcaParm->Txop[QID_AC_VI];
+			}	/* End of if */
 		}
 //#endif // WIFI_TEST //
 
@@ -1719,7 +1760,6 @@ VOID AsicSetEdcaParm(
 		RTMP_IO_WRITE32(pAd, EDCA_AC2_CFG, Ac2Cfg.word);
 		RTMP_IO_WRITE32(pAd, EDCA_AC3_CFG, Ac3Cfg.word);
 
-
 		//========================================================
 		//      DMA Register has a copy too.
 		//========================================================
@@ -1735,7 +1775,7 @@ VOID AsicSetEdcaParm(
 		CwminCsr.field.Cwmin0 = pEdcaParm->Cwmin[QID_AC_BE];
 		CwminCsr.field.Cwmin1 = pEdcaParm->Cwmin[QID_AC_BK];
 		CwminCsr.field.Cwmin2 = pEdcaParm->Cwmin[QID_AC_VI];
-			CwminCsr.field.Cwmin3 = pEdcaParm->Cwmin[QID_AC_VO] - 1; //for TGn wifi test
+		CwminCsr.field.Cwmin3 = pEdcaParm->Cwmin[QID_AC_VO] - 1;	//for TGn wifi test
 		RTMP_IO_WRITE32(pAd, WMM_CWMIN_CFG, CwminCsr.word);
 
 		CwmaxCsr.word = 0;
@@ -1746,69 +1786,68 @@ VOID AsicSetEdcaParm(
 		RTMP_IO_WRITE32(pAd, WMM_CWMAX_CFG, CwmaxCsr.word);
 
 		AifsnCsr.word = 0;
-		AifsnCsr.field.Aifsn0 = Ac0Cfg.field.Aifsn; //pEdcaParm->Aifsn[QID_AC_BE];
-		AifsnCsr.field.Aifsn1 = Ac1Cfg.field.Aifsn; //pEdcaParm->Aifsn[QID_AC_BK];
-		AifsnCsr.field.Aifsn2 = Ac2Cfg.field.Aifsn; //pEdcaParm->Aifsn[QID_AC_VI];
+		AifsnCsr.field.Aifsn0 = Ac0Cfg.field.Aifsn;	//pEdcaParm->Aifsn[QID_AC_BE];
+		AifsnCsr.field.Aifsn1 = Ac1Cfg.field.Aifsn;	//pEdcaParm->Aifsn[QID_AC_BK];
+		AifsnCsr.field.Aifsn2 = Ac2Cfg.field.Aifsn;	//pEdcaParm->Aifsn[QID_AC_VI];
 
 		{
 			// Tuning for Wi-Fi WMM S06
 			if (pAd->CommonCfg.bWiFiTest &&
-				pEdcaParm->Aifsn[QID_AC_VI] == 10)
+			    pEdcaParm->Aifsn[QID_AC_VI] == 10)
 				AifsnCsr.field.Aifsn2 = Ac2Cfg.field.Aifsn - 4;
 
 			// Tuning for TGn Wi-Fi 5.2.32
 			// STA TestBed changes in this item: connexant legacy sta ==> broadcom 11n sta
 			if (STA_TGN_WIFI_ON(pAd) &&
-				pEdcaParm->Aifsn[QID_AC_VI] == 10)
-			{
+			    pEdcaParm->Aifsn[QID_AC_VI] == 10) {
 				AifsnCsr.field.Aifsn0 = 3;
 				AifsnCsr.field.Aifsn2 = 7;
 			}
 
 			if (INFRA_ON(pAd))
-				CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[BSSID_WCID], fCLIENT_STATUS_WMM_CAPABLE);
+				CLIENT_STATUS_SET_FLAG(&pAd->MacTab.
+						       Content[BSSID_WCID],
+						       fCLIENT_STATUS_WMM_CAPABLE);
 		}
 
 		{
-			AifsnCsr.field.Aifsn3 = Ac3Cfg.field.Aifsn - 1; //pEdcaParm->Aifsn[QID_AC_VO]; //for TGn wifi test
+			AifsnCsr.field.Aifsn3 = Ac3Cfg.field.Aifsn - 1;	//pEdcaParm->Aifsn[QID_AC_VO]; //for TGn wifi test
 #ifdef RT30xx
 			// TODO: Shiang, this modification also suitable for RT3052/RT3050 ???
-			if (pAd->RfIcType == RFIC_3020 || pAd->RfIcType == RFIC_2020)
-			{
-					AifsnCsr.field.Aifsn2 = 0x2; //pEdcaParm->Aifsn[QID_AC_VI]; //for WiFi WMM S4-T04.
+			if (pAd->RfIcType == RFIC_3020
+			    || pAd->RfIcType == RFIC_2020) {
+				AifsnCsr.field.Aifsn2 = 0x2;	//pEdcaParm->Aifsn[QID_AC_VI]; //for WiFi WMM S4-T04.
 			}
 #endif // RT30xx //
 		}
 		RTMP_IO_WRITE32(pAd, WMM_AIFSN_CFG, AifsnCsr.word);
 
-		NdisMoveMemory(&pAd->CommonCfg.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
-		if (!ADHOC_ON(pAd))
-		{
-			DBGPRINT(RT_DEBUG_TRACE,("EDCA [#%d]: AIFSN CWmin CWmax  TXOP(us)  ACM\n", pEdcaParm->EdcaUpdateCount));
-			DBGPRINT(RT_DEBUG_TRACE,("     AC_BE      %2d     %2d     %2d      %4d     %d\n",
-									 pEdcaParm->Aifsn[0],
-									 pEdcaParm->Cwmin[0],
-									 pEdcaParm->Cwmax[0],
-									 pEdcaParm->Txop[0]<<5,
-									 pEdcaParm->bACM[0]));
-			DBGPRINT(RT_DEBUG_TRACE,("     AC_BK      %2d     %2d     %2d      %4d     %d\n",
-									 pEdcaParm->Aifsn[1],
-									 pEdcaParm->Cwmin[1],
-									 pEdcaParm->Cwmax[1],
-									 pEdcaParm->Txop[1]<<5,
-									 pEdcaParm->bACM[1]));
-			DBGPRINT(RT_DEBUG_TRACE,("     AC_VI      %2d     %2d     %2d      %4d     %d\n",
-									 pEdcaParm->Aifsn[2],
-									 pEdcaParm->Cwmin[2],
-									 pEdcaParm->Cwmax[2],
-									 pEdcaParm->Txop[2]<<5,
-									 pEdcaParm->bACM[2]));
-			DBGPRINT(RT_DEBUG_TRACE,("     AC_VO      %2d     %2d     %2d      %4d     %d\n",
-									 pEdcaParm->Aifsn[3],
-									 pEdcaParm->Cwmin[3],
-									 pEdcaParm->Cwmax[3],
-									 pEdcaParm->Txop[3]<<5,
-									 pEdcaParm->bACM[3]));
+		NdisMoveMemory(&pAd->CommonCfg.APEdcaParm, pEdcaParm,
+			       sizeof(EDCA_PARM));
+		if (!ADHOC_ON(pAd)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("EDCA [#%d]: AIFSN CWmin CWmax  TXOP(us)  ACM\n",
+				  pEdcaParm->EdcaUpdateCount));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("     AC_BE      %2d     %2d     %2d      %4d     %d\n",
+				  pEdcaParm->Aifsn[0], pEdcaParm->Cwmin[0],
+				  pEdcaParm->Cwmax[0], pEdcaParm->Txop[0] << 5,
+				  pEdcaParm->bACM[0]));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("     AC_BK      %2d     %2d     %2d      %4d     %d\n",
+				  pEdcaParm->Aifsn[1], pEdcaParm->Cwmin[1],
+				  pEdcaParm->Cwmax[1], pEdcaParm->Txop[1] << 5,
+				  pEdcaParm->bACM[1]));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("     AC_VI      %2d     %2d     %2d      %4d     %d\n",
+				  pEdcaParm->Aifsn[2], pEdcaParm->Cwmin[2],
+				  pEdcaParm->Cwmax[2], pEdcaParm->Txop[2] << 5,
+				  pEdcaParm->bACM[2]));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("     AC_VO      %2d     %2d     %2d      %4d     %d\n",
+				  pEdcaParm->Aifsn[3], pEdcaParm->Cwmin[3],
+				  pEdcaParm->Cwmax[3], pEdcaParm->Txop[3] << 5,
+				  pEdcaParm->bACM[3]));
 		}
 	}
 
@@ -1823,19 +1862,19 @@ VOID AsicSetEdcaParm(
 
 	==========================================================================
  */
-VOID	AsicSetSlotTime(
-	IN PRTMP_ADAPTER pAd,
-	IN BOOLEAN bUseShortSlotTime)
+VOID AsicSetSlotTime(IN PRTMP_ADAPTER pAd, IN BOOLEAN bUseShortSlotTime)
 {
-	ULONG	SlotTime;
-	UINT32	RegValue = 0;
+	ULONG SlotTime;
+	UINT32 RegValue = 0;
 
 	if (pAd->CommonCfg.Channel > 14)
 		bUseShortSlotTime = TRUE;
 
-	if (bUseShortSlotTime && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED))
+	if (bUseShortSlotTime
+	    && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED))
 		return;
-	else if ((!bUseShortSlotTime) && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED)))
+	else if ((!bUseShortSlotTime)
+		 && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED)))
 		return;
 
 	if (bUseShortSlotTime)
@@ -1843,19 +1882,19 @@ VOID	AsicSetSlotTime(
 	else
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
 
-	SlotTime = (bUseShortSlotTime)? 9 : 20;
+	SlotTime = (bUseShortSlotTime) ? 9 : 20;
 
 	{
 		// force using short SLOT time for FAE to demo performance when TxBurst is ON
-		if (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)))
-			|| ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE) && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE))
-			)
-		{
+		if (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
+		     && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)))
+		    || ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)
+			&& (pAd->CommonCfg.BACapability.field.Policy ==
+			    BA_NOTUSE))
+		    ) {
 			// In this case, we will think it is doing Wi-Fi test
 			// And we will not set to short slot when bEnableTxBurst is TRUE.
-		}
-		else if (pAd->CommonCfg.bEnableTxBurst)
-		{
+		} else if (pAd->CommonCfg.bEnableTxBurst) {
 			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
 			SlotTime = 9;
 		}
@@ -1867,8 +1906,7 @@ VOID	AsicSetSlotTime(
 	// ToDo: Should consider capability with 11B
 	//
 	{
-		if (pAd->StaCfg.BssType == BSS_ADHOC)
-		{
+		if (pAd->StaCfg.BssType == BSS_ADHOC) {
 			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
 			SlotTime = 20;
 		}
@@ -1892,92 +1930,97 @@ VOID	AsicSetSlotTime(
     Return:
 	========================================================================
 */
-VOID AsicAddSharedKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 BssIndex,
-	IN UCHAR		 KeyIdx,
-	IN UCHAR		 CipherAlg,
-	IN PUCHAR		 pKey,
-	IN PUCHAR		 pTxMic,
-	IN PUCHAR		 pRxMic)
+VOID AsicAddSharedKeyEntry(IN PRTMP_ADAPTER pAd,
+			   IN UCHAR BssIndex,
+			   IN UCHAR KeyIdx,
+			   IN UCHAR CipherAlg,
+			   IN PUCHAR pKey, IN PUCHAR pTxMic, IN PUCHAR pRxMic)
 {
-	ULONG offset; //, csr0;
+	ULONG offset;		//, csr0;
 	SHAREDKEY_MODE_STRUC csr1;
 #ifdef RTMP_MAC_PCI
-	INT   i;
+	INT i;
 #endif // RTMP_MAC_PCI //
 
-	DBGPRINT(RT_DEBUG_TRACE, ("AsicAddSharedKeyEntry BssIndex=%d, KeyIdx=%d\n", BssIndex,KeyIdx));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AsicAddSharedKeyEntry BssIndex=%d, KeyIdx=%d\n", BssIndex,
+		  KeyIdx));
 //============================================================================================
 
-	DBGPRINT(RT_DEBUG_TRACE,("AsicAddSharedKeyEntry: %s key #%d\n", CipherName[CipherAlg], BssIndex*4 + KeyIdx));
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("		Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-		pKey[0],pKey[1],pKey[2],pKey[3],pKey[4],pKey[5],pKey[6],pKey[7],pKey[8],pKey[9],pKey[10],pKey[11],pKey[12],pKey[13],pKey[14],pKey[15]));
-	if (pRxMic)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("		Rx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-			pRxMic[0],pRxMic[1],pRxMic[2],pRxMic[3],pRxMic[4],pRxMic[5],pRxMic[6],pRxMic[7]));
-	}
-	if (pTxMic)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("		Tx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-			pTxMic[0],pTxMic[1],pTxMic[2],pTxMic[3],pTxMic[4],pTxMic[5],pTxMic[6],pTxMic[7]));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AsicAddSharedKeyEntry: %s key #%d\n", CipherName[CipherAlg],
+		  BssIndex * 4 + KeyIdx));
+	DBGPRINT_RAW(RT_DEBUG_TRACE,
+		     ("		Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+		      pKey[0], pKey[1], pKey[2], pKey[3], pKey[4],
+		      pKey[5], pKey[6], pKey[7], pKey[8], pKey[9],
+		      pKey[10], pKey[11], pKey[12], pKey[13], pKey[14],
+		      pKey[15]));
+	if (pRxMic) {
+		DBGPRINT_RAW(RT_DEBUG_TRACE,
+			     ("		Rx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+			      pRxMic[0], pRxMic[1], pRxMic[2], pRxMic[3],
+			      pRxMic[4], pRxMic[5], pRxMic[6], pRxMic[7]));
+	}
+	if (pTxMic) {
+		DBGPRINT_RAW(RT_DEBUG_TRACE,
+			     ("		Tx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+			      pTxMic[0], pTxMic[1], pTxMic[2], pTxMic[3],
+			      pTxMic[4], pTxMic[5], pTxMic[6], pTxMic[7]));
 	}
 //============================================================================================
 	//
 	// fill key material - key + TX MIC + RX MIC
 	//
 #ifdef RTMP_MAC_PCI
-	offset = SHARED_KEY_TABLE_BASE + (4*BssIndex + KeyIdx)*HW_KEY_ENTRY_SIZE;
-	for (i=0; i<MAX_LEN_OF_SHARE_KEY; i++)
-	{
+	offset =
+	    SHARED_KEY_TABLE_BASE + (4 * BssIndex + KeyIdx) * HW_KEY_ENTRY_SIZE;
+	for (i = 0; i < MAX_LEN_OF_SHARE_KEY; i++) {
 		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
 	}
 
 	offset += MAX_LEN_OF_SHARE_KEY;
-	if (pTxMic)
-	{
-		for (i=0; i<8; i++)
-		{
+	if (pTxMic) {
+		for (i = 0; i < 8; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pTxMic[i]);
 		}
 	}
 
 	offset += 8;
-	if (pRxMic)
-	{
-		for (i=0; i<8; i++)
-		{
+	if (pRxMic) {
+		for (i = 0; i < 8; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
 		}
 	}
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
-{
-	offset = SHARED_KEY_TABLE_BASE + (4*BssIndex + KeyIdx)*HW_KEY_ENTRY_SIZE;
-	RTUSBMultiWrite(pAd, offset, pKey, MAX_LEN_OF_SHARE_KEY);
-
-	offset += MAX_LEN_OF_SHARE_KEY;
-	if (pTxMic)
 	{
-		RTUSBMultiWrite(pAd, offset, pTxMic, 8);
-	}
+		offset =
+		    SHARED_KEY_TABLE_BASE + (4 * BssIndex +
+					     KeyIdx) * HW_KEY_ENTRY_SIZE;
+		RTUSBMultiWrite(pAd, offset, pKey, MAX_LEN_OF_SHARE_KEY);
+
+		offset += MAX_LEN_OF_SHARE_KEY;
+		if (pTxMic) {
+			RTUSBMultiWrite(pAd, offset, pTxMic, 8);
+		}
 
-	offset += 8;
-	if (pRxMic)
-	{
-		RTUSBMultiWrite(pAd, offset, pRxMic, 8);
+		offset += 8;
+		if (pRxMic) {
+			RTUSBMultiWrite(pAd, offset, pRxMic, 8);
+		}
 	}
-}
 #endif // RTMP_MAC_USB //
 
 	//
 	// Update cipher algorithm. WSTA always use BSS0
 	//
-	RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE+4*(BssIndex/2), &csr1.word);
-	DBGPRINT(RT_DEBUG_TRACE,("Read: SHARED_KEY_MODE_BASE at this Bss[%d] KeyIdx[%d]= 0x%x \n", BssIndex,KeyIdx, csr1.word));
-	if ((BssIndex%2) == 0)
-	{
+	RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
+		       &csr1.word);
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Read: SHARED_KEY_MODE_BASE at this Bss[%d] KeyIdx[%d]= 0x%x \n",
+		  BssIndex, KeyIdx, csr1.word));
+	if ((BssIndex % 2) == 0) {
 		if (KeyIdx == 0)
 			csr1.field.Bss0Key0CipherAlg = CipherAlg;
 		else if (KeyIdx == 1)
@@ -1986,9 +2029,7 @@ VOID AsicAddSharedKeyEntry(
 			csr1.field.Bss0Key2CipherAlg = CipherAlg;
 		else
 			csr1.field.Bss0Key3CipherAlg = CipherAlg;
-	}
-	else
-	{
+	} else {
 		if (KeyIdx == 0)
 			csr1.field.Bss1Key0CipherAlg = CipherAlg;
 		else if (KeyIdx == 1)
@@ -1998,25 +2039,27 @@ VOID AsicAddSharedKeyEntry(
 		else
 			csr1.field.Bss1Key3CipherAlg = CipherAlg;
 	}
-	DBGPRINT(RT_DEBUG_TRACE,("Write: SHARED_KEY_MODE_BASE at this Bss[%d] = 0x%x \n", BssIndex, csr1.word));
-	RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE+4*(BssIndex/2), csr1.word);
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Write: SHARED_KEY_MODE_BASE at this Bss[%d] = 0x%x \n",
+		  BssIndex, csr1.word));
+	RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
+			csr1.word);
 
 }
 
-//	IRQL = DISPATCH_LEVEL
-VOID AsicRemoveSharedKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 BssIndex,
-	IN UCHAR		 KeyIdx)
+//      IRQL = DISPATCH_LEVEL
+VOID AsicRemoveSharedKeyEntry(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR BssIndex, IN UCHAR KeyIdx)
 {
 	//ULONG SecCsr0;
 	SHAREDKEY_MODE_STRUC csr1;
 
-	DBGPRINT(RT_DEBUG_TRACE,("AsicRemoveSharedKeyEntry: #%d \n", BssIndex*4 + KeyIdx));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AsicRemoveSharedKeyEntry: #%d \n", BssIndex * 4 + KeyIdx));
 
-	RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE+4*(BssIndex/2), &csr1.word);
-	if ((BssIndex%2) == 0)
-	{
+	RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
+		       &csr1.word);
+	if ((BssIndex % 2) == 0) {
 		if (KeyIdx == 0)
 			csr1.field.Bss0Key0CipherAlg = 0;
 		else if (KeyIdx == 1)
@@ -2025,9 +2068,7 @@ VOID AsicRemoveSharedKeyEntry(
 			csr1.field.Bss0Key2CipherAlg = 0;
 		else
 			csr1.field.Bss0Key3CipherAlg = 0;
-	}
-	else
-	{
+	} else {
 		if (KeyIdx == 0)
 			csr1.field.Bss1Key0CipherAlg = 0;
 		else if (KeyIdx == 1)
@@ -2037,39 +2078,38 @@ VOID AsicRemoveSharedKeyEntry(
 		else
 			csr1.field.Bss1Key3CipherAlg = 0;
 	}
-	DBGPRINT(RT_DEBUG_TRACE,("Write: SHARED_KEY_MODE_BASE at this Bss[%d] = 0x%x \n", BssIndex, csr1.word));
-	RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE+4*(BssIndex/2), csr1.word);
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Write: SHARED_KEY_MODE_BASE at this Bss[%d] = 0x%x \n",
+		  BssIndex, csr1.word));
+	RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
+			csr1.word);
 	ASSERT(BssIndex < 4);
 	ASSERT(KeyIdx < 4);
 
 }
 
-
-VOID AsicUpdateWCIDAttribute(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT		WCID,
-	IN UCHAR		BssIndex,
-	IN UCHAR        CipherAlg,
-	IN BOOLEAN		bUsePairewiseKeyTable)
+VOID AsicUpdateWCIDAttribute(IN PRTMP_ADAPTER pAd,
+			     IN USHORT WCID,
+			     IN UCHAR BssIndex,
+			     IN UCHAR CipherAlg,
+			     IN BOOLEAN bUsePairewiseKeyTable)
 {
-	ULONG   WCIDAttri = 0, offset;
+	ULONG WCIDAttri = 0, offset;
 
 	//
 	// Update WCID attribute.
 	// Only TxKey could update WCID attribute.
 	//
 	offset = MAC_WCID_ATTRIBUTE_BASE + (WCID * HW_WCID_ATTRI_SIZE);
-	WCIDAttri = (BssIndex << 4) | (CipherAlg << 1) | (bUsePairewiseKeyTable);
+	WCIDAttri =
+	    (BssIndex << 4) | (CipherAlg << 1) | (bUsePairewiseKeyTable);
 	RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
 }
 
-VOID AsicUpdateWCIDIVEIV(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT		WCID,
-	IN ULONG        uIV,
-	IN ULONG        uEIV)
+VOID AsicUpdateWCIDIVEIV(IN PRTMP_ADAPTER pAd,
+			 IN USHORT WCID, IN ULONG uIV, IN ULONG uEIV)
 {
-	ULONG	offset;
+	ULONG offset;
 
 	offset = MAC_IVEIV_TABLE_BASE + (WCID * HW_IVEIV_ENTRY_SIZE);
 
@@ -2077,22 +2117,19 @@ VOID AsicUpdateWCIDIVEIV(
 	RTMP_IO_WRITE32(pAd, offset + 4, uEIV);
 }
 
-VOID AsicUpdateRxWCIDTable(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT		WCID,
-	IN PUCHAR        pAddr)
+VOID AsicUpdateRxWCIDTable(IN PRTMP_ADAPTER pAd,
+			   IN USHORT WCID, IN PUCHAR pAddr)
 {
 	ULONG offset;
 	ULONG Addr;
 
 	offset = MAC_WCID_BASE + (WCID * HW_WCID_ENTRY_SIZE);
-	Addr = pAddr[0] + (pAddr[1] << 8) +(pAddr[2] << 16) +(pAddr[3] << 24);
+	Addr = pAddr[0] + (pAddr[1] << 8) + (pAddr[2] << 16) + (pAddr[3] << 24);
 	RTMP_IO_WRITE32(pAd, offset, Addr);
 	Addr = pAddr[4] + (pAddr[5] << 8);
 	RTMP_IO_WRITE32(pAd, offset + 4, Addr);
 }
 
-
 /*
     ========================================================================
 
@@ -2126,30 +2163,28 @@ VOID AsicUpdateRxWCIDTable(
 	For AP mode bTxKey must be always set to TRUE.
     ========================================================================
 */
-VOID AsicAddKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT		WCID,
-	IN UCHAR		BssIndex,
-	IN UCHAR		KeyIdx,
-	IN PCIPHER_KEY	pCipherKey,
-	IN BOOLEAN		bUsePairewiseKeyTable,
-	IN BOOLEAN		bTxKey)
-{
-	ULONG	offset;
-//	ULONG   WCIDAttri = 0;
-	UCHAR	IV4 = 0;
-	PUCHAR		pKey = pCipherKey->Key;
-//	ULONG		KeyLen = pCipherKey->KeyLen;
-	PUCHAR		pTxMic = pCipherKey->TxMic;
-	PUCHAR		pRxMic = pCipherKey->RxMic;
-	PUCHAR		pTxtsc = pCipherKey->TxTsc;
-	UCHAR		CipherAlg = pCipherKey->CipherAlg;
+VOID AsicAddKeyEntry(IN PRTMP_ADAPTER pAd,
+		     IN USHORT WCID,
+		     IN UCHAR BssIndex,
+		     IN UCHAR KeyIdx,
+		     IN PCIPHER_KEY pCipherKey,
+		     IN BOOLEAN bUsePairewiseKeyTable, IN BOOLEAN bTxKey)
+{
+	ULONG offset;
+//      ULONG   WCIDAttri = 0;
+	UCHAR IV4 = 0;
+	PUCHAR pKey = pCipherKey->Key;
+//      ULONG           KeyLen = pCipherKey->KeyLen;
+	PUCHAR pTxMic = pCipherKey->TxMic;
+	PUCHAR pRxMic = pCipherKey->RxMic;
+	PUCHAR pTxtsc = pCipherKey->TxTsc;
+	UCHAR CipherAlg = pCipherKey->CipherAlg;
 	SHAREDKEY_MODE_STRUC csr1;
 #ifdef RTMP_MAC_PCI
-	UCHAR		i;
+	UCHAR i;
 #endif // RTMP_MAC_PCI //
 
-//	ASSERT(KeyLen <= MAX_LEN_OF_PEER_KEY);
+//      ASSERT(KeyLen <= MAX_LEN_OF_PEER_KEY);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> AsicAddKeyEntry\n"));
 	//
@@ -2158,15 +2193,16 @@ VOID AsicAddKeyEntry(
 	if (bUsePairewiseKeyTable)
 		offset = PAIRWISE_KEY_TABLE_BASE + (WCID * HW_KEY_ENTRY_SIZE);
 	else
-		offset = SHARED_KEY_TABLE_BASE + (4 * BssIndex + KeyIdx) * HW_KEY_ENTRY_SIZE;
+		offset =
+		    SHARED_KEY_TABLE_BASE + (4 * BssIndex +
+					     KeyIdx) * HW_KEY_ENTRY_SIZE;
 
 	//
 	// 2.) Set Key to Asic
 	//
 	//for (i = 0; i < KeyLen; i++)
 #ifdef RTMP_MAC_PCI
-	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i++)
-	{
+	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i++) {
 		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
 	}
 	offset += MAX_LEN_OF_PEER_KEY;
@@ -2174,19 +2210,15 @@ VOID AsicAddKeyEntry(
 	//
 	// 3.) Set MIC key if available
 	//
-	if (pTxMic)
-	{
-		for (i = 0; i < 8; i++)
-		{
+	if (pTxMic) {
+		for (i = 0; i < 8; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pTxMic[i]);
 		}
 	}
 	offset += LEN_TKIP_TXMICK;
 
-	if (pRxMic)
-	{
-		for (i = 0; i < 8; i++)
-		{
+	if (pRxMic) {
+		for (i = 0; i < 8; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
 		}
 	}
@@ -2198,14 +2230,12 @@ VOID AsicAddKeyEntry(
 	//
 	// 3.) Set MIC key if available
 	//
-	if (pTxMic)
-	{
+	if (pTxMic) {
 		RTUSBMultiWrite(pAd, offset, pTxMic, 8);
 	}
 	offset += LEN_TKIP_TXMICK;
 
-	if (pRxMic)
-	{
+	if (pRxMic) {
 		RTUSBMultiWrite(pAd, offset, pRxMic, 8);
 	}
 #endif // RTMP_MAC_USB //
@@ -2214,8 +2244,7 @@ VOID AsicAddKeyEntry(
 	// 4.) Modify IV/EIV if needs
 	//     This will force Asic to use this key ID by setting IV.
 	//
-	if (bTxKey)
-	{
+	if (bTxKey) {
 #ifdef RTMP_MAC_PCI
 		offset = MAC_IVEIV_TABLE_BASE + (WCID * HW_IVEIV_ENTRY_SIZE);
 		//
@@ -2226,8 +2255,10 @@ VOID AsicAddKeyEntry(
 		RTMP_IO_WRITE8(pAd, offset + 2, pTxtsc[0]);
 
 		IV4 = (KeyIdx << 6);
-		if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC) ||(CipherAlg == CIPHER_AES))
-			IV4 |= 0x20;  // turn on extension bit means EIV existence
+		if ((CipherAlg == CIPHER_TKIP)
+		    || (CipherAlg == CIPHER_TKIP_NO_MIC)
+		    || (CipherAlg == CIPHER_AES))
+			IV4 |= 0x20;	// turn on extension bit means EIV existence
 
 		RTMP_IO_WRITE8(pAd, offset + 3, IV4);
 
@@ -2235,8 +2266,7 @@ VOID AsicAddKeyEntry(
 		// Write EIV
 		//
 		offset += 4;
-		for (i = 0; i < 4; i++)
-		{
+		for (i = 0; i < 4; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pTxtsc[i + 2]);
 		}
 #endif // RTMP_MAC_PCI //
@@ -2247,30 +2277,34 @@ VOID AsicAddKeyEntry(
 		// Write IV
 		//
 		IV4 = (KeyIdx << 6);
-		if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC) ||(CipherAlg == CIPHER_AES))
-			IV4 |= 0x20;  // turn on extension bit means EIV existence
-
-		tmpVal = pTxtsc[1] + (((pTxtsc[1] | 0x20) & 0x7f) << 8) + (pTxtsc[0] << 16) + (IV4 << 24);
+		if ((CipherAlg == CIPHER_TKIP)
+		    || (CipherAlg == CIPHER_TKIP_NO_MIC)
+		    || (CipherAlg == CIPHER_AES))
+			IV4 |= 0x20;	// turn on extension bit means EIV existence
+
+		tmpVal =
+		    pTxtsc[1] + (((pTxtsc[1] | 0x20) & 0x7f) << 8) +
+		    (pTxtsc[0] << 16) + (IV4 << 24);
 		RTMP_IO_WRITE32(pAd, offset, tmpVal);
 
 		//
 		// Write EIV
 		//
 		offset += 4;
-		RTMP_IO_WRITE32(pAd, offset, *(PUINT32)&pCipherKey->TxTsc[2]);
+		RTMP_IO_WRITE32(pAd, offset, *(PUINT32) & pCipherKey->TxTsc[2]);
 #endif // RTMP_MAC_USB //
 
-		AsicUpdateWCIDAttribute(pAd, WCID, BssIndex, CipherAlg, bUsePairewiseKeyTable);
+		AsicUpdateWCIDAttribute(pAd, WCID, BssIndex, CipherAlg,
+					bUsePairewiseKeyTable);
 	}
 
-	if (!bUsePairewiseKeyTable)
-	{
+	if (!bUsePairewiseKeyTable) {
 		//
 		// Only update the shared key security mode
 		//
-		RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2), &csr1.word);
-		if ((BssIndex % 2) == 0)
-		{
+		RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
+			       &csr1.word);
+		if ((BssIndex % 2) == 0) {
 			if (KeyIdx == 0)
 				csr1.field.Bss0Key0CipherAlg = CipherAlg;
 			else if (KeyIdx == 1)
@@ -2279,9 +2313,7 @@ VOID AsicAddKeyEntry(
 				csr1.field.Bss0Key2CipherAlg = CipherAlg;
 			else
 				csr1.field.Bss0Key3CipherAlg = CipherAlg;
-		}
-		else
-		{
+		} else {
 			if (KeyIdx == 0)
 				csr1.field.Bss1Key0CipherAlg = CipherAlg;
 			else if (KeyIdx == 1)
@@ -2291,13 +2323,13 @@ VOID AsicAddKeyEntry(
 			else
 				csr1.field.Bss1Key3CipherAlg = CipherAlg;
 		}
-		RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2), csr1.word);
+		RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
+				csr1.word);
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<== AsicAddKeyEntry\n"));
 }
 
-
 /*
 	========================================================================
 	Description:
@@ -2307,34 +2339,30 @@ VOID AsicAddKeyEntry(
     Return:
 	========================================================================
 */
-VOID AsicAddPairwiseKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR        pAddr,
-	IN UCHAR		WCID,
-	IN CIPHER_KEY		 *pCipherKey)
+VOID AsicAddPairwiseKeyEntry(IN PRTMP_ADAPTER pAd,
+			     IN PUCHAR pAddr,
+			     IN UCHAR WCID, IN CIPHER_KEY * pCipherKey)
 {
 	INT i;
-	ULONG		offset;
-	PUCHAR		 pKey = pCipherKey->Key;
-	PUCHAR		 pTxMic = pCipherKey->TxMic;
-	PUCHAR		 pRxMic = pCipherKey->RxMic;
+	ULONG offset;
+	PUCHAR pKey = pCipherKey->Key;
+	PUCHAR pTxMic = pCipherKey->TxMic;
+	PUCHAR pRxMic = pCipherKey->RxMic;
 #ifdef DBG
-	UCHAR		CipherAlg = pCipherKey->CipherAlg;
+	UCHAR CipherAlg = pCipherKey->CipherAlg;
 #endif // DBG //
 
 	// EKEY
 	offset = PAIRWISE_KEY_TABLE_BASE + (WCID * HW_KEY_ENTRY_SIZE);
 #ifdef RTMP_MAC_PCI
-	for (i=0; i<MAX_LEN_OF_PEER_KEY; i++)
-	{
+	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i++) {
 		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
 	}
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
 	RTUSBMultiWrite(pAd, offset, &pCipherKey->Key[0], MAX_LEN_OF_PEER_KEY);
 #endif // RTMP_MAC_USB //
-	for (i=0; i<MAX_LEN_OF_PEER_KEY; i+=4)
-	{
+	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i += 4) {
 		UINT32 Value;
 		RTMP_IO_READ32(pAd, offset + i, &Value);
 	}
@@ -2342,12 +2370,10 @@ VOID AsicAddPairwiseKeyEntry(
 	offset += MAX_LEN_OF_PEER_KEY;
 
 	//  MIC KEY
-	if (pTxMic)
-	{
+	if (pTxMic) {
 #ifdef RTMP_MAC_PCI
-		for (i=0; i<8; i++)
-		{
-			RTMP_IO_WRITE8(pAd, offset+i, pTxMic[i]);
+		for (i = 0; i < 8; i++) {
+			RTMP_IO_WRITE8(pAd, offset + i, pTxMic[i]);
 		}
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
@@ -2355,12 +2381,10 @@ VOID AsicAddPairwiseKeyEntry(
 #endif // RTMP_MAC_USB //
 	}
 	offset += 8;
-	if (pRxMic)
-	{
+	if (pRxMic) {
 #ifdef RTMP_MAC_PCI
-		for (i=0; i<8; i++)
-		{
-			RTMP_IO_WRITE8(pAd, offset+i, pRxMic[i]);
+		for (i = 0; i < 8; i++) {
+			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
 		}
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
@@ -2368,20 +2392,28 @@ VOID AsicAddPairwiseKeyEntry(
 #endif // RTMP_MAC_USB //
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("AsicAddPairwiseKeyEntry: WCID #%d Alg=%s\n",WCID, CipherName[CipherAlg]));
-	DBGPRINT(RT_DEBUG_TRACE,("	Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-		pKey[0],pKey[1],pKey[2],pKey[3],pKey[4],pKey[5],pKey[6],pKey[7],pKey[8],pKey[9],pKey[10],pKey[11],pKey[12],pKey[13],pKey[14],pKey[15]));
-	if (pRxMic)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("	Rx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-			pRxMic[0],pRxMic[1],pRxMic[2],pRxMic[3],pRxMic[4],pRxMic[5],pRxMic[6],pRxMic[7]));
-	}
-	if (pTxMic)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("	Tx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
-			pTxMic[0],pTxMic[1],pTxMic[2],pTxMic[3],pTxMic[4],pTxMic[5],pTxMic[6],pTxMic[7]));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AsicAddPairwiseKeyEntry: WCID #%d Alg=%s\n", WCID,
+		  CipherName[CipherAlg]));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("	Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+		  pKey[0], pKey[1], pKey[2], pKey[3], pKey[4], pKey[5],
+		  pKey[6], pKey[7], pKey[8], pKey[9], pKey[10], pKey[11],
+		  pKey[12], pKey[13], pKey[14], pKey[15]));
+	if (pRxMic) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("	Rx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+			  pRxMic[0], pRxMic[1], pRxMic[2], pRxMic[3],
+			  pRxMic[4], pRxMic[5], pRxMic[6], pRxMic[7]));
+	}
+	if (pTxMic) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("	Tx MIC Key = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+			  pTxMic[0], pTxMic[1], pTxMic[2], pTxMic[3],
+			  pTxMic[4], pTxMic[5], pTxMic[6], pTxMic[7]));
 	}
 }
+
 /*
 	========================================================================
 	Description:
@@ -2390,26 +2422,21 @@ VOID AsicAddPairwiseKeyEntry(
     Return:
 	========================================================================
 */
-VOID AsicRemovePairwiseKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 BssIdx,
-	IN UCHAR		 Wcid)
+VOID AsicRemovePairwiseKeyEntry(IN PRTMP_ADAPTER pAd,
+				IN UCHAR BssIdx, IN UCHAR Wcid)
 {
-	ULONG		WCIDAttri;
-	USHORT		offset;
+	ULONG WCIDAttri;
+	USHORT offset;
 
 	// re-set the entry's WCID attribute as OPEN-NONE.
 	offset = MAC_WCID_ATTRIBUTE_BASE + (Wcid * HW_WCID_ATTRI_SIZE);
-	WCIDAttri = (BssIdx<<4) | PAIRWISEKEYTABLE;
+	WCIDAttri = (BssIdx << 4) | PAIRWISEKEYTABLE;
 	RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
 }
 
-BOOLEAN AsicSendCommandToMcu(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 Command,
-	IN UCHAR		 Token,
-	IN UCHAR		 Arg0,
-	IN UCHAR		 Arg1)
+BOOLEAN AsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
+			     IN UCHAR Command,
+			     IN UCHAR Token, IN UCHAR Arg0, IN UCHAR Arg1)
 {
 
 	if (pAd->chipOps.sendCommandToMcu)
@@ -2418,10 +2445,7 @@ BOOLEAN AsicSendCommandToMcu(
 	return TRUE;
 }
 
-
-VOID AsicSetRxAnt(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			Ant)
+VOID AsicSetRxAnt(IN PRTMP_ADAPTER pAd, IN UCHAR Ant)
 {
 #ifdef RT30xx
 	/* RT3572 ATE need not to do this. */
@@ -2429,132 +2453,113 @@ VOID AsicSetRxAnt(
 #endif // RT30xx //
 }
 
-
-VOID AsicTurnOffRFClk(
-	IN PRTMP_ADAPTER pAd,
-	IN	UCHAR		Channel)
+VOID AsicTurnOffRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
 {
-	if (pAd->chipOps.AsicRfTurnOff)
-	{
+	if (pAd->chipOps.AsicRfTurnOff) {
 		pAd->chipOps.AsicRfTurnOff(pAd);
-	}
-	else
-	{
+	} else {
 		// RF R2 bit 18 = 0
-		UINT32			R1 = 0, R2 = 0, R3 = 0;
-		UCHAR			index;
-		RTMP_RF_REGS	*RFRegTable;
+		UINT32 R1 = 0, R2 = 0, R3 = 0;
+		UCHAR index;
+		RTMP_RF_REGS *RFRegTable;
 
 		RFRegTable = RF2850RegTable;
 
-		switch (pAd->RfIcType)
-		{
-			case RFIC_2820:
-			case RFIC_2850:
-			case RFIC_2720:
-			case RFIC_2750:
-
-				for (index = 0; index < NUM_OF_2850_CHNL; index++)
-				{
-					if (Channel == RFRegTable[index].Channel)
-					{
-						R1 = RFRegTable[index].R1 & 0xffffdfff;
-						R2 = RFRegTable[index].R2 & 0xfffbffff;
-						R3 = RFRegTable[index].R3 & 0xfff3ffff;
-
-						RTMP_RF_IO_WRITE32(pAd, R1);
-						RTMP_RF_IO_WRITE32(pAd, R2);
-
-						// Program R1b13 to 1, R3/b18,19 to 0, R2b18 to 0.
-						// Set RF R2 bit18=0, R3 bit[18:19]=0
-						//if (pAd->StaCfg.bRadio == FALSE)
-						if (1)
-						{
-							RTMP_RF_IO_WRITE32(pAd, R3);
+		switch (pAd->RfIcType) {
+		case RFIC_2820:
+		case RFIC_2850:
+		case RFIC_2720:
+		case RFIC_2750:
 
-							DBGPRINT(RT_DEBUG_TRACE, ("AsicTurnOffRFClk#%d(RF=%d, ) , R2=0x%08x,  R3 = 0x%08x \n",
-								Channel, pAd->RfIcType, R2, R3));
-						}
-						else
-							DBGPRINT(RT_DEBUG_TRACE, ("AsicTurnOffRFClk#%d(RF=%d, ) , R2=0x%08x \n",
-								Channel, pAd->RfIcType, R2));
-						break;
-					}
+			for (index = 0; index < NUM_OF_2850_CHNL; index++) {
+				if (Channel == RFRegTable[index].Channel) {
+					R1 = RFRegTable[index].R1 & 0xffffdfff;
+					R2 = RFRegTable[index].R2 & 0xfffbffff;
+					R3 = RFRegTable[index].R3 & 0xfff3ffff;
+
+					RTMP_RF_IO_WRITE32(pAd, R1);
+					RTMP_RF_IO_WRITE32(pAd, R2);
+
+					// Program R1b13 to 1, R3/b18,19 to 0, R2b18 to 0.
+					// Set RF R2 bit18=0, R3 bit[18:19]=0
+					//if (pAd->StaCfg.bRadio == FALSE)
+					if (1) {
+						RTMP_RF_IO_WRITE32(pAd, R3);
+
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("AsicTurnOffRFClk#%d(RF=%d, ) , R2=0x%08x,  R3 = 0x%08x \n",
+							  Channel,
+							  pAd->RfIcType, R2,
+							  R3));
+					} else
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("AsicTurnOffRFClk#%d(RF=%d, ) , R2=0x%08x \n",
+							  Channel,
+							  pAd->RfIcType, R2));
+					break;
 				}
-				break;
+			}
+			break;
 
-			default:
-				break;
+		default:
+			break;
 		}
 	}
 }
 
-
-VOID AsicTurnOnRFClk(
-	IN PRTMP_ADAPTER pAd,
-	IN	UCHAR			Channel)
+VOID AsicTurnOnRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
 {
 	// RF R2 bit 18 = 0
-	UINT32			R1 = 0, R2 = 0, R3 = 0;
-	UCHAR			index;
-	RTMP_RF_REGS	*RFRegTable;
+	UINT32 R1 = 0, R2 = 0, R3 = 0;
+	UCHAR index;
+	RTMP_RF_REGS *RFRegTable;
 
 #ifdef PCIE_PS_SUPPORT
 	// The RF programming sequence is difference between 3xxx and 2xxx
-	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)))
-	{
+	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
 		return;
 	}
 #endif // PCIE_PS_SUPPORT //
 
 	RFRegTable = RF2850RegTable;
 
-	switch (pAd->RfIcType)
-	{
-		case RFIC_2820:
-		case RFIC_2850:
-		case RFIC_2720:
-		case RFIC_2750:
-
-			for (index = 0; index < NUM_OF_2850_CHNL; index++)
-			{
-				if (Channel == RFRegTable[index].Channel)
-				{
-					R3 = pAd->LatchRfRegs.R3;
-					R3 &= 0xfff3ffff;
-					R3 |= 0x00080000;
-					RTMP_RF_IO_WRITE32(pAd, R3);
-
-					R1 = RFRegTable[index].R1;
-					RTMP_RF_IO_WRITE32(pAd, R1);
-
-					R2 = RFRegTable[index].R2;
-					if (pAd->Antenna.field.TxPath == 1)
-					{
-						R2 |= 0x4000;	// If TXpath is 1, bit 14 = 1;
-					}
-
-					if (pAd->Antenna.field.RxPath == 2)
-					{
-						R2 |= 0x40;	// write 1 to off Rxpath.
-					}
-					else if (pAd->Antenna.field.RxPath == 1)
-					{
-						R2 |= 0x20040;	// write 1 to off RxPath
-					}
-					RTMP_RF_IO_WRITE32(pAd, R2);
+	switch (pAd->RfIcType) {
+	case RFIC_2820:
+	case RFIC_2850:
+	case RFIC_2720:
+	case RFIC_2750:
+
+		for (index = 0; index < NUM_OF_2850_CHNL; index++) {
+			if (Channel == RFRegTable[index].Channel) {
+				R3 = pAd->LatchRfRegs.R3;
+				R3 &= 0xfff3ffff;
+				R3 |= 0x00080000;
+				RTMP_RF_IO_WRITE32(pAd, R3);
+
+				R1 = RFRegTable[index].R1;
+				RTMP_RF_IO_WRITE32(pAd, R1);
+
+				R2 = RFRegTable[index].R2;
+				if (pAd->Antenna.field.TxPath == 1) {
+					R2 |= 0x4000;	// If TXpath is 1, bit 14 = 1;
+				}
 
-					break;
+				if (pAd->Antenna.field.RxPath == 2) {
+					R2 |= 0x40;	// write 1 to off Rxpath.
+				} else if (pAd->Antenna.field.RxPath == 1) {
+					R2 |= 0x20040;	// write 1 to off RxPath
 				}
+				RTMP_RF_IO_WRITE32(pAd, R2);
+
+				break;
 			}
-			break;
+		}
+		break;
 
-		default:
-			break;
+	default:
+		break;
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE, ("AsicTurnOnRFClk#%d(RF=%d, ) , R2=0x%08x\n",
-		Channel,
-		pAd->RfIcType,
-		R2));
+				  Channel, pAd->RfIcType, R2));
 }
--- a/drivers/staging/rt2860/common/cmm_cfg.c
+++ b/drivers/staging/rt2860/common/cmm_cfg.c
@@ -35,50 +35,41 @@
     ---------    ----------    ----------------------------------------------
 */
 
-
-
 #include "../rt_config.h"
 
-
-char* GetPhyMode(
-	int Mode)
+char *GetPhyMode(int Mode)
 {
-	switch(Mode)
-	{
-		case MODE_CCK:
-			return "CCK";
-
-		case MODE_OFDM:
-			return "OFDM";
-		case MODE_HTMIX:
-			return "HTMIX";
-
-		case MODE_HTGREENFIELD:
-			return "GREEN";
-		default:
-			return "N/A";
+	switch (Mode) {
+	case MODE_CCK:
+		return "CCK";
+
+	case MODE_OFDM:
+		return "OFDM";
+	case MODE_HTMIX:
+		return "HTMIX";
+
+	case MODE_HTGREENFIELD:
+		return "GREEN";
+	default:
+		return "N/A";
 	}
 }
 
-
-char* GetBW(
-	int BW)
+char *GetBW(int BW)
 {
-	switch(BW)
-	{
-		case BW_10:
-			return "10M";
-
-		case BW_20:
-			return "20M";
-		case BW_40:
-			return "40M";
-		default:
-			return "N/A";
+	switch (BW) {
+	case BW_10:
+		return "10M";
+
+	case BW_20:
+		return "20M";
+	case BW_40:
+		return "40M";
+	default:
+		return "N/A";
 	}
 }
 
-
 /*
     ==========================================================================
     Description:
@@ -89,46 +80,37 @@ char* GetBW(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
 */
-INT RT_CfgSetCountryRegion(
-	IN PRTMP_ADAPTER	pAd,
-	IN PSTRING			arg,
-	IN INT				band)
+INT RT_CfgSetCountryRegion(IN PRTMP_ADAPTER pAd, IN PSTRING arg, IN INT band)
 {
 	LONG region, regionMax;
 	UCHAR *pCountryRegion;
 
 	region = simple_strtol(arg, 0, 10);
 
-	if (band == BAND_24G)
-	{
+	if (band == BAND_24G) {
 		pCountryRegion = &pAd->CommonCfg.CountryRegion;
 		regionMax = REGION_MAXIMUM_BG_BAND;
-	}
-	else
-	{
+	} else {
 		pCountryRegion = &pAd->CommonCfg.CountryRegionForABand;
 		regionMax = REGION_MAXIMUM_A_BAND;
 	}
 
 	// TODO: Is it neccesay for following check???
 	// Country can be set only when EEPROM not programmed
-	if (*pCountryRegion & 0x80)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("CfgSetCountryRegion():CountryRegion in eeprom was programmed\n"));
+	if (*pCountryRegion & 0x80) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("CfgSetCountryRegion():CountryRegion in eeprom was programmed\n"));
 		return FALSE;
 	}
 
-	if((region >= 0) && (region <= REGION_MAXIMUM_BG_BAND))
-	{
-		*pCountryRegion= (UCHAR) region;
-	}
-	else if ((region == REGION_31_BG_BAND) && (band == BAND_24G))
-	{
+	if ((region >= 0) && (region <= REGION_MAXIMUM_BG_BAND)) {
 		*pCountryRegion = (UCHAR) region;
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("CfgSetCountryRegion():region(%ld) out of range!\n", region));
+	} else if ((region == REGION_31_BG_BAND) && (band == BAND_24G)) {
+		*pCountryRegion = (UCHAR) region;
+	} else {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("CfgSetCountryRegion():region(%ld) out of range!\n",
+			  region));
 		return FALSE;
 	}
 
@@ -136,7 +118,6 @@ INT RT_CfgSetCountryRegion(
 
 }
 
-
 /*
     ==========================================================================
     Description:
@@ -145,18 +126,15 @@ INT RT_CfgSetCountryRegion(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
 */
-INT RT_CfgSetWirelessMode(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg)
+INT RT_CfgSetWirelessMode(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 {
-	INT		MaxPhyMode = PHY_11G;
-	LONG	WirelessMode;
+	INT MaxPhyMode = PHY_11G;
+	LONG WirelessMode;
 
 	MaxPhyMode = PHY_11N_5G;
 
 	WirelessMode = simple_strtol(arg, 0, 10);
-	if (WirelessMode <= MaxPhyMode)
-	{
+	if (WirelessMode <= MaxPhyMode) {
 		pAd->CommonCfg.PhyMode = WirelessMode;
 		return TRUE;
 	}
@@ -165,10 +143,7 @@ INT RT_CfgSetWirelessMode(
 
 }
 
-
-INT RT_CfgSetShortSlot(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg)
+INT RT_CfgSetShortSlot(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 {
 	LONG ShortSlot;
 
@@ -179,12 +154,11 @@ INT RT_CfgSetShortSlot(
 	else if (ShortSlot == 0)
 		pAd->CommonCfg.bUseShortSlotTime = FALSE;
 	else
-		return FALSE;  //Invalid argument
+		return FALSE;	//Invalid argument
 
 	return TRUE;
 }
 
-
 /*
     ==========================================================================
     Description:
@@ -193,54 +167,53 @@ INT RT_CfgSetShortSlot(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
 */
-INT	RT_CfgSetWepKey(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			keyString,
-	IN	CIPHER_KEY		*pSharedKey,
-	IN	INT				keyIdx)
-{
-	INT				KeyLen;
-	INT				i;
-	UCHAR			CipherAlg = CIPHER_NONE;
-	BOOLEAN			bKeyIsHex = FALSE;
+INT RT_CfgSetWepKey(IN PRTMP_ADAPTER pAd,
+		    IN PSTRING keyString,
+		    IN CIPHER_KEY * pSharedKey, IN INT keyIdx)
+{
+	INT KeyLen;
+	INT i;
+	UCHAR CipherAlg = CIPHER_NONE;
+	BOOLEAN bKeyIsHex = FALSE;
 
 	// TODO: Shall we do memset for the original key info??
 	memset(pSharedKey, 0, sizeof(CIPHER_KEY));
 	KeyLen = strlen(keyString);
-	switch (KeyLen)
-	{
-		case 5: //wep 40 Ascii type
-		case 13: //wep 104 Ascii type
-			bKeyIsHex = FALSE;
-			pSharedKey->KeyLen = KeyLen;
-			NdisMoveMemory(pSharedKey->Key, keyString, KeyLen);
-			break;
-
-		case 10: //wep 40 Hex type
-		case 26: //wep 104 Hex type
-			for(i=0; i < KeyLen; i++)
-			{
-				if( !isxdigit(*(keyString+i)) )
-					return FALSE;  //Not Hex value;
-			}
-			bKeyIsHex = TRUE;
-			pSharedKey->KeyLen = KeyLen/2 ;
-			AtoH(keyString, pSharedKey->Key, pSharedKey->KeyLen);
-			break;
-
-		default: //Invalid argument
-			DBGPRINT(RT_DEBUG_TRACE, ("RT_CfgSetWepKey(keyIdx=%d):Invalid argument (arg=%s)\n", keyIdx, keyString));
-			return FALSE;
+	switch (KeyLen) {
+	case 5:		//wep 40 Ascii type
+	case 13:		//wep 104 Ascii type
+		bKeyIsHex = FALSE;
+		pSharedKey->KeyLen = KeyLen;
+		NdisMoveMemory(pSharedKey->Key, keyString, KeyLen);
+		break;
+
+	case 10:		//wep 40 Hex type
+	case 26:		//wep 104 Hex type
+		for (i = 0; i < KeyLen; i++) {
+			if (!isxdigit(*(keyString + i)))
+				return FALSE;	//Not Hex value;
+		}
+		bKeyIsHex = TRUE;
+		pSharedKey->KeyLen = KeyLen / 2;
+		AtoH(keyString, pSharedKey->Key, pSharedKey->KeyLen);
+		break;
+
+	default:		//Invalid argument
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RT_CfgSetWepKey(keyIdx=%d):Invalid argument (arg=%s)\n",
+			  keyIdx, keyString));
+		return FALSE;
 	}
 
 	pSharedKey->CipherAlg = ((KeyLen % 5) ? CIPHER_WEP128 : CIPHER_WEP64);
-	DBGPRINT(RT_DEBUG_TRACE, ("RT_CfgSetWepKey:(KeyIdx=%d,type=%s, Alg=%s)\n",
-						keyIdx, (bKeyIsHex == FALSE ? "Ascii" : "Hex"), CipherName[CipherAlg]));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RT_CfgSetWepKey:(KeyIdx=%d,type=%s, Alg=%s)\n", keyIdx,
+		  (bKeyIsHex == FALSE ? "Ascii" : "Hex"),
+		  CipherName[CipherAlg]));
 
 	return TRUE;
 }
 
-
 /*
     ==========================================================================
     Description:
@@ -257,33 +230,28 @@ INT	RT_CfgSetWepKey(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
 */
-INT RT_CfgSetWPAPSKKey(
-	IN RTMP_ADAPTER	*pAd,
-	IN PSTRING		keyString,
-	IN UCHAR		*pHashStr,
-	IN INT			hashStrLen,
-	OUT PUCHAR		pPMKBuf)
+INT RT_CfgSetWPAPSKKey(IN RTMP_ADAPTER * pAd,
+		       IN PSTRING keyString,
+		       IN UCHAR * pHashStr,
+		       IN INT hashStrLen, OUT PUCHAR pPMKBuf)
 {
 	int keyLen;
 	UCHAR keyMaterial[40];
 
 	keyLen = strlen(keyString);
-	if ((keyLen < 8) || (keyLen > 64))
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("WPAPSK Key length(%d) error, required 8 ~ 64 characters!(keyStr=%s)\n",
-									keyLen, keyString));
+	if ((keyLen < 8) || (keyLen > 64)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("WPAPSK Key length(%d) error, required 8 ~ 64 characters!(keyStr=%s)\n",
+			  keyLen, keyString));
 		return FALSE;
 	}
 
 	memset(pPMKBuf, 0, 32);
-	if (keyLen == 64)
-	{
-	    AtoH(keyString, pPMKBuf, 32);
-	}
-	else
-	{
-	    PasswordHash(keyString, pHashStr, hashStrLen, keyMaterial);
-	    NdisMoveMemory(pPMKBuf, keyMaterial, 32);
+	if (keyLen == 64) {
+		AtoH(keyString, pPMKBuf, 32);
+	} else {
+		PasswordHash(keyString, pHashStr, hashStrLen, keyMaterial);
+		NdisMoveMemory(pPMKBuf, keyMaterial, 32);
 	}
 
 	return TRUE;
--- a/drivers/staging/rt2860/common/cmm_data.c
+++ b/drivers/staging/rt2860/common/cmm_data.c
@@ -25,52 +25,60 @@
  *************************************************************************
 */
 
-
 #include "../rt_config.h"
 
+UCHAR SNAP_802_1H[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+UCHAR SNAP_BRIDGE_TUNNEL[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
 
-UCHAR	SNAP_802_1H[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
-UCHAR	SNAP_BRIDGE_TUNNEL[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8};
 // Add Cisco Aironet SNAP heade for CCX2 support
-UCHAR	SNAP_AIRONET[] = {0xaa, 0xaa, 0x03, 0x00, 0x40, 0x96, 0x00, 0x00};
-UCHAR	CKIP_LLC_SNAP[] = {0xaa, 0xaa, 0x03, 0x00, 0x40, 0x96, 0x00, 0x02};
-UCHAR	EAPOL_LLC_SNAP[]= {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e};
-UCHAR	EAPOL[] = {0x88, 0x8e};
-UCHAR   TPID[] = {0x81, 0x00}; /* VLAN related */
-
-UCHAR	IPX[] = {0x81, 0x37};
-UCHAR	APPLE_TALK[] = {0x80, 0xf3};
-UCHAR	RateIdToPlcpSignal[12] = {
-	 0, /* RATE_1 */	1, /* RATE_2 */ 	2, /* RATE_5_5 */	3, /* RATE_11 */	// see BBP spec
-	11, /* RATE_6 */   15, /* RATE_9 */    10, /* RATE_12 */   14, /* RATE_18 */	// see IEEE802.11a-1999 p.14
-	 9, /* RATE_24 */  13, /* RATE_36 */	8, /* RATE_48 */   12  /* RATE_54 */ }; // see IEEE802.11a-1999 p.14
-
-UCHAR	 OfdmSignalToRateId[16] = {
-	RATE_54,  RATE_54,	RATE_54,  RATE_54,	// OFDM PLCP Signal = 0,  1,  2,  3 respectively
-	RATE_54,  RATE_54,	RATE_54,  RATE_54,	// OFDM PLCP Signal = 4,  5,  6,  7 respectively
-	RATE_48,  RATE_24,	RATE_12,  RATE_6,	// OFDM PLCP Signal = 8,  9,  10, 11 respectively
-	RATE_54,  RATE_36,	RATE_18,  RATE_9,	// OFDM PLCP Signal = 12, 13, 14, 15 respectively
+UCHAR SNAP_AIRONET[] = { 0xaa, 0xaa, 0x03, 0x00, 0x40, 0x96, 0x00, 0x00 };
+UCHAR CKIP_LLC_SNAP[] = { 0xaa, 0xaa, 0x03, 0x00, 0x40, 0x96, 0x00, 0x02 };
+UCHAR EAPOL_LLC_SNAP[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e };
+UCHAR EAPOL[] = { 0x88, 0x8e };
+UCHAR TPID[] = { 0x81, 0x00 };	/* VLAN related */
+
+UCHAR IPX[] = { 0x81, 0x37 };
+UCHAR APPLE_TALK[] = { 0x80, 0xf3 };
+
+UCHAR RateIdToPlcpSignal[12] = {
+	0, /* RATE_1 */ 1, /* RATE_2 */ 2, /* RATE_5_5 */ 3,	/* RATE_11 */// see BBP spec
+	11, /* RATE_6 */ 15, /* RATE_9 */ 10, /* RATE_12 */ 14,	/* RATE_18 */// see IEEE802.11a-1999 p.14
+	9, /* RATE_24 */ 13, /* RATE_36 */ 8, /* RATE_48 */ 12 /* RATE_54 */
+};				// see IEEE802.11a-1999 p.14
+
+UCHAR OfdmSignalToRateId[16] = {
+	RATE_54, RATE_54, RATE_54, RATE_54,	// OFDM PLCP Signal = 0,  1,  2,  3 respectively
+	RATE_54, RATE_54, RATE_54, RATE_54,	// OFDM PLCP Signal = 4,  5,  6,  7 respectively
+	RATE_48, RATE_24, RATE_12, RATE_6,	// OFDM PLCP Signal = 8,  9,  10, 11 respectively
+	RATE_54, RATE_36, RATE_18, RATE_9,	// OFDM PLCP Signal = 12, 13, 14, 15 respectively
 };
 
-UCHAR	 OfdmRateToRxwiMCS[12] = {
-	0,  0,	0,  0,
-	0,  1,	2,  3,	// OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3
-	4,  5,	6,  7,	// OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7
+UCHAR OfdmRateToRxwiMCS[12] = {
+	0, 0, 0, 0,
+	0, 1, 2, 3,		// OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3
+	4, 5, 6, 7,		// OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7
 };
-UCHAR	 RxwiMCSToOfdmRate[12] = {
-	RATE_6,  RATE_9,	RATE_12,  RATE_18,
-	RATE_24,  RATE_36,	RATE_48,  RATE_54,	// OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3
-	4,  5,	6,  7,	// OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7
+
+UCHAR RxwiMCSToOfdmRate[12] = {
+	RATE_6, RATE_9, RATE_12, RATE_18,
+	RATE_24, RATE_36, RATE_48, RATE_54,	// OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3
+	4, 5, 6, 7,		// OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7
 };
 
-char*   MCSToMbps[] = {"1Mbps","2Mbps","5.5Mbps","11Mbps","06Mbps","09Mbps","12Mbps","18Mbps","24Mbps","36Mbps","48Mbps","54Mbps","MM-0","MM-1","MM-2","MM-3","MM-4","MM-5","MM-6","MM-7","MM-8","MM-9","MM-10","MM-11","MM-12","MM-13","MM-14","MM-15","MM-32","ee1","ee2","ee3"};
+char *MCSToMbps[] =
+    { "1Mbps", "2Mbps", "5.5Mbps", "11Mbps", "06Mbps", "09Mbps", "12Mbps",
+"18Mbps", "24Mbps", "36Mbps", "48Mbps", "54Mbps", "MM-0", "MM-1", "MM-2", "MM-3",
+"MM-4", "MM-5", "MM-6", "MM-7", "MM-8", "MM-9", "MM-10", "MM-11", "MM-12", "MM-13",
+"MM-14", "MM-15", "MM-32", "ee1", "ee2", "ee3" };
 
-UCHAR default_cwmin[]={CW_MIN_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1, CW_MIN_IN_BITS-2};
+UCHAR default_cwmin[] =
+    { CW_MIN_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS - 1, CW_MIN_IN_BITS - 2 };
 //UCHAR default_cwmax[]={CW_MAX_IN_BITS, CW_MAX_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1};
-UCHAR default_sta_aifsn[]={3,7,2,2};
-
-UCHAR MapUserPriorityToAccessCategory[8] = {QID_AC_BE, QID_AC_BK, QID_AC_BK, QID_AC_BE, QID_AC_VI, QID_AC_VI, QID_AC_VO, QID_AC_VO};
+UCHAR default_sta_aifsn[] = { 3, 7, 2, 2 };
 
+UCHAR MapUserPriorityToAccessCategory[8] =
+    { QID_AC_BE, QID_AC_BK, QID_AC_BK, QID_AC_BE, QID_AC_VI, QID_AC_VI,
+QID_AC_VO, QID_AC_VO };
 
 /*
 	========================================================================
@@ -96,120 +104,112 @@ UCHAR MapUserPriorityToAccessCategory[8]
 
 	========================================================================
 */
-NDIS_STATUS MiniportMMRequest(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			QueIdx,
-	IN	PUCHAR			pData,
-	IN	UINT			Length)
-{
-	PNDIS_PACKET	pPacket;
-	NDIS_STATUS  	Status = NDIS_STATUS_SUCCESS;
-	ULONG	 		FreeNum;
-	UCHAR			rtmpHwHdr[TXINFO_SIZE + TXWI_SIZE]; //RTMP_HW_HDR_LEN];
+NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR QueIdx, IN PUCHAR pData, IN UINT Length)
+{
+	PNDIS_PACKET pPacket;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+	ULONG FreeNum;
+	UCHAR rtmpHwHdr[TXINFO_SIZE + TXWI_SIZE];	//RTMP_HW_HDR_LEN];
 #ifdef RTMP_MAC_PCI
-	unsigned long	IrqFlags = 0;
-	UCHAR			IrqState;
+	unsigned long IrqFlags = 0;
+	UCHAR IrqState;
 #endif // RTMP_MAC_PCI //
-	BOOLEAN			bUseDataQ = FALSE;
-	int			retryCnt = 0;
+	BOOLEAN bUseDataQ = FALSE;
+	int retryCnt = 0;
 
 	ASSERT(Length <= MGMT_DMA_BUFFER_SIZE);
 
-	if ((QueIdx & MGMT_USE_QUEUE_FLAG) == MGMT_USE_QUEUE_FLAG)
-	{
+	if ((QueIdx & MGMT_USE_QUEUE_FLAG) == MGMT_USE_QUEUE_FLAG) {
 		bUseDataQ = TRUE;
 		QueIdx &= (~MGMT_USE_QUEUE_FLAG);
 	}
-
 #ifdef RTMP_MAC_PCI
 	// 2860C use Tx Ring
 	IrqState = pAd->irq_disabled;
-	if (pAd->MACVersion == 0x28600100)
-	{
-		QueIdx = (bUseDataQ ==TRUE ? QueIdx : 3);
+	if (pAd->MACVersion == 0x28600100) {
+		QueIdx = (bUseDataQ == TRUE ? QueIdx : 3);
 		bUseDataQ = TRUE;
 	}
 	if (bUseDataQ && (!IrqState))
 		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
 #endif // RTMP_MAC_PCI //
 
-	do
-	{
+	do {
 		// Reset is in progress, stop immediately
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
-			 RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST)||
-			 !RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP))
-		{
+		    RTMP_TEST_FLAG(pAd,
+				   fRTMP_ADAPTER_HALT_IN_PROGRESS |
+				   fRTMP_ADAPTER_NIC_NOT_EXIST)
+		    || !RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)) {
 			Status = NDIS_STATUS_FAILURE;
 			break;
 		}
-
 		// Check Free priority queue
 		// Since we use PBF Queue2 for management frame.  Its corresponding DMA ring should be using TxRing.
 #ifdef RTMP_MAC_PCI
-		if (bUseDataQ)
-		{
+		if (bUseDataQ) {
 			retryCnt = MAX_DATAMM_RETRY;
 			// free Tx(QueIdx) resources
 			RTMPFreeTXDUponTxDmaDone(pAd, QueIdx);
 			FreeNum = GET_TXRING_FREENO(pAd, QueIdx);
-		}
-		else
+		} else
 #endif // RTMP_MAC_PCI //
 		{
 			FreeNum = GET_MGMTRING_FREENO(pAd);
 		}
 
-		if ((FreeNum > 0))
-		{
+		if ((FreeNum > 0)) {
 			// We need to reserve space for rtmp hardware header. i.e., TxWI for RT2860 and TxInfo+TxWI for RT2870
 			NdisZeroMemory(&rtmpHwHdr, (TXINFO_SIZE + TXWI_SIZE));
-			Status = RTMPAllocateNdisPacket(pAd, &pPacket, (PUCHAR)&rtmpHwHdr, (TXINFO_SIZE + TXWI_SIZE), pData, Length);
-			if (Status != NDIS_STATUS_SUCCESS)
-			{
-				DBGPRINT(RT_DEBUG_WARN, ("MiniportMMRequest (error:: can't allocate NDIS PACKET)\n"));
+			Status =
+			    RTMPAllocateNdisPacket(pAd, &pPacket,
+						   (PUCHAR) & rtmpHwHdr,
+						   (TXINFO_SIZE + TXWI_SIZE),
+						   pData, Length);
+			if (Status != NDIS_STATUS_SUCCESS) {
+				DBGPRINT(RT_DEBUG_WARN,
+					 ("MiniportMMRequest (error:: can't allocate NDIS PACKET)\n"));
 				break;
 			}
-
 			//pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
 			//pAd->CommonCfg.MlmeRate = RATE_2;
 
-
 #ifdef RTMP_MAC_PCI
-			if (bUseDataQ)
-			{
-				Status = MlmeDataHardTransmit(pAd, QueIdx, pPacket);
+			if (bUseDataQ) {
+				Status =
+				    MlmeDataHardTransmit(pAd, QueIdx, pPacket);
 				retryCnt--;
-			}
-			else
+			} else
 #endif // RTMP_MAC_PCI //
-			Status = MlmeHardTransmit(pAd, QueIdx, pPacket);
+				Status = MlmeHardTransmit(pAd, QueIdx, pPacket);
 			if (Status == NDIS_STATUS_SUCCESS)
 				retryCnt = 0;
 			else
 				RTMPFreeNdisPacket(pAd, pPacket);
-		}
-		else
-		{
+		} else {
 			pAd->RalinkCounters.MgmtRingFullCount++;
 #ifdef RTMP_MAC_PCI
-			if (bUseDataQ)
-			{
+			if (bUseDataQ) {
 				retryCnt--;
-				DBGPRINT(RT_DEBUG_TRACE, ("retryCnt %d\n", retryCnt));
-				if (retryCnt == 0)
-				{
-					DBGPRINT(RT_DEBUG_ERROR, ("Qidx(%d), not enough space in DataRing, MgmtRingFullCount=%ld!\n",
-											QueIdx, pAd->RalinkCounters.MgmtRingFullCount));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("retryCnt %d\n", retryCnt));
+				if (retryCnt == 0) {
+					DBGPRINT(RT_DEBUG_ERROR,
+						 ("Qidx(%d), not enough space in DataRing, MgmtRingFullCount=%ld!\n",
+						  QueIdx,
+						  pAd->RalinkCounters.
+						  MgmtRingFullCount));
 				}
 			}
 #endif // RTMP_MAC_PCI //
-			DBGPRINT(RT_DEBUG_ERROR, ("Qidx(%d), not enough space in MgmtRing, MgmtRingFullCount=%ld!\n",
-										QueIdx, pAd->RalinkCounters.MgmtRingFullCount));
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Qidx(%d), not enough space in MgmtRing, MgmtRingFullCount=%ld!\n",
+				  QueIdx,
+				  pAd->RalinkCounters.MgmtRingFullCount));
 		}
 	} while (retryCnt > 0);
 
-
 #ifdef RTMP_MAC_PCI
 	if (bUseDataQ && (!IrqState))
 		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
@@ -218,9 +218,6 @@ NDIS_STATUS MiniportMMRequest(
 	return Status;
 }
 
-
-
-
 /*
 	========================================================================
 
@@ -245,19 +242,16 @@ NDIS_STATUS MiniportMMRequest(
 
 	========================================================================
 */
-NDIS_STATUS MlmeHardTransmit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			QueIdx,
-	IN	PNDIS_PACKET	pPacket)
-{
-	PACKET_INFO 	PacketInfo;
-	PUCHAR			pSrcBufVA;
-	UINT			SrcBufLen;
-	PHEADER_802_11	pHeader_802_11;
+NDIS_STATUS MlmeHardTransmit(IN PRTMP_ADAPTER pAd,
+			     IN UCHAR QueIdx, IN PNDIS_PACKET pPacket)
+{
+	PACKET_INFO PacketInfo;
+	PUCHAR pSrcBufVA;
+	UINT SrcBufLen;
+	PHEADER_802_11 pHeader_802_11;
 
 	if ((pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)
-		)
-	{
+	    ) {
 		return NDIS_STATUS_FAILURE;
 	}
 
@@ -267,77 +261,66 @@ NDIS_STATUS MlmeHardTransmit(
 
 	pHeader_802_11 = (PHEADER_802_11) (pSrcBufVA + TXINFO_SIZE + TXWI_SIZE);
 
-
 #ifdef RTMP_MAC_PCI
-	if ( pAd->MACVersion == 0x28600100 )
-		return MlmeHardTransmitTxRing(pAd,QueIdx,pPacket);
+	if (pAd->MACVersion == 0x28600100)
+		return MlmeHardTransmitTxRing(pAd, QueIdx, pPacket);
 	else
 #endif // RTMP_MAC_PCI //
-		return MlmeHardTransmitMgmtRing(pAd,QueIdx,pPacket);
+		return MlmeHardTransmitMgmtRing(pAd, QueIdx, pPacket);
 
 }
 
-
-NDIS_STATUS MlmeHardTransmitMgmtRing(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR	QueIdx,
-	IN	PNDIS_PACKET	pPacket)
+NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
+				     IN UCHAR QueIdx, IN PNDIS_PACKET pPacket)
 {
-	PACKET_INFO 	PacketInfo;
-	PUCHAR			pSrcBufVA;
-	UINT			SrcBufLen;
-	PHEADER_802_11	pHeader_802_11;
-	BOOLEAN 		bAckRequired, bInsertTimestamp;
-	UCHAR			MlmeRate;
-	PTXWI_STRUC 	pFirstTxWI;
-	MAC_TABLE_ENTRY	*pMacEntry = NULL;
-	UCHAR			PID;
+	PACKET_INFO PacketInfo;
+	PUCHAR pSrcBufVA;
+	UINT SrcBufLen;
+	PHEADER_802_11 pHeader_802_11;
+	BOOLEAN bAckRequired, bInsertTimestamp;
+	UCHAR MlmeRate;
+	PTXWI_STRUC pFirstTxWI;
+	MAC_TABLE_ENTRY *pMacEntry = NULL;
+	UCHAR PID;
 
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
 	// Make sure MGMT ring resource won't be used by other threads
 	RTMP_SEM_LOCK(&pAd->MgmtRingLock);
-	if (pSrcBufVA == NULL)
-	{
+	if (pSrcBufVA == NULL) {
 		// The buffer shouldn't be NULL
 		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 		return NDIS_STATUS_FAILURE;
 	}
 
 	{
-	// outgoing frame always wakeup PHY to prevent frame lost
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-		AsicForceWakeup(pAd, TRUE);
+		// outgoing frame always wakeup PHY to prevent frame lost
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+			AsicForceWakeup(pAd, TRUE);
 	}
 
-	pFirstTxWI = (PTXWI_STRUC)(pSrcBufVA +  TXINFO_SIZE);
-	pHeader_802_11 = (PHEADER_802_11) (pSrcBufVA + TXINFO_SIZE + TXWI_SIZE); //TXWI_SIZE);
+	pFirstTxWI = (PTXWI_STRUC) (pSrcBufVA + TXINFO_SIZE);
+	pHeader_802_11 = (PHEADER_802_11) (pSrcBufVA + TXINFO_SIZE + TXWI_SIZE);	//TXWI_SIZE);
 
-	if (pHeader_802_11->Addr1[0] & 0x01)
-	{
+	if (pHeader_802_11->Addr1[0] & 0x01) {
 		MlmeRate = pAd->CommonCfg.BasicMlmeRate;
-	}
-	else
-	{
+	} else {
 		MlmeRate = pAd->CommonCfg.MlmeRate;
 	}
 
 	// Verify Mlme rate for a / g bands.
-	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6)) // 11A band
+	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6))	// 11A band
 		MlmeRate = RATE_6;
 
 	if ((pHeader_802_11->FC.Type == BTYPE_DATA) &&
-		(pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL))
-	{
+	    (pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL)) {
 		pMacEntry = MacTableLookup(pAd, pHeader_802_11->Addr1);
 	}
 
 	{
 		// Fixed W52 with Activity scan issue in ABG_MIXED and ABGN_MIXED mode.
 		if (pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED
-			|| pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED
-		)
-		{
+		    || pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) {
 			if (pAd->LatchRfRegs.Channel > 14)
 				pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
 			else
@@ -350,82 +333,76 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	// Snice it's been set to 0 while on MgtMacHeaderInit
 	// By the way this will cause frame to be send on PWR_SAVE failed.
 	//
-	pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE; // (pAd->StaCfg.Psm == PWR_SAVE);
+	pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE;	// (pAd->StaCfg.Psm == PWR_SAVE);
 
 	//
 	// In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame
-    // Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD
-//	if ((pHeader_802_11->FC.Type != BTYPE_DATA) && (pHeader_802_11->FC.Type != BTYPE_CNTL))
+	// Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD
+//      if ((pHeader_802_11->FC.Type != BTYPE_DATA) && (pHeader_802_11->FC.Type != BTYPE_CNTL))
 	{
 		if ((pHeader_802_11->FC.SubType == SUBTYPE_ACTION) ||
-			((pHeader_802_11->FC.Type == BTYPE_DATA) &&
-			((pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL) ||
-			(pHeader_802_11->FC.SubType == SUBTYPE_NULL_FUNC))))
-		{
+		    ((pHeader_802_11->FC.Type == BTYPE_DATA) &&
+		     ((pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL) ||
+		      (pHeader_802_11->FC.SubType == SUBTYPE_NULL_FUNC)))) {
 			if (pAd->StaCfg.Psm == PWR_SAVE)
-			pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
-		else
-				pHeader_802_11->FC.PwrMgmt = pAd->CommonCfg.bAPSDForcePowerSave;
-	}
+				pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
+			else
+				pHeader_802_11->FC.PwrMgmt =
+				    pAd->CommonCfg.bAPSDForcePowerSave;
+		}
 	}
 
-
-
-
-
 	bInsertTimestamp = FALSE;
-	if (pHeader_802_11->FC.Type == BTYPE_CNTL) // must be PS-POLL
+	if (pHeader_802_11->FC.Type == BTYPE_CNTL)	// must be PS-POLL
 	{
 		//Set PM bit in ps-poll, to fix WLK 1.2  PowerSaveMode_ext failure issue.
-		if ((pAd->OpMode == OPMODE_STA) && (pHeader_802_11->FC.SubType == SUBTYPE_PS_POLL))
-		{
+		if ((pAd->OpMode == OPMODE_STA)
+		    && (pHeader_802_11->FC.SubType == SUBTYPE_PS_POLL)) {
 			pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
 		}
 		bAckRequired = FALSE;
-	}
-	else // BTYPE_MGMT or BTYPE_DATA(must be NULL frame)
+	} else			// BTYPE_MGMT or BTYPE_DATA(must be NULL frame)
 	{
 		//pAd->Sequence++;
 		//pHeader_802_11->Sequence = pAd->Sequence;
 
-		if (pHeader_802_11->Addr1[0] & 0x01) // MULTICAST, BROADCAST
+		if (pHeader_802_11->Addr1[0] & 0x01)	// MULTICAST, BROADCAST
 		{
 			bAckRequired = FALSE;
 			pHeader_802_11->Duration = 0;
-		}
-		else
-		{
+		} else {
 			bAckRequired = TRUE;
-			pHeader_802_11->Duration = RTMPCalcDuration(pAd, MlmeRate, 14);
-			if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP) && (pHeader_802_11->FC.Type == BTYPE_MGMT))
-			{
+			pHeader_802_11->Duration =
+			    RTMPCalcDuration(pAd, MlmeRate, 14);
+			if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP)
+			    && (pHeader_802_11->FC.Type == BTYPE_MGMT)) {
 				bInsertTimestamp = TRUE;
-				bAckRequired = FALSE; // Disable ACK to prevent retry 0x1f for Probe Response
-			}
-			else if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_REQ) && (pHeader_802_11->FC.Type == BTYPE_MGMT))
-			{
-				bAckRequired = FALSE; // Disable ACK to prevent retry 0x1f for Probe Request
+				bAckRequired = FALSE;	// Disable ACK to prevent retry 0x1f for Probe Response
+			} else
+			    if ((pHeader_802_11->FC.SubType ==
+				 SUBTYPE_PROBE_REQ)
+				&& (pHeader_802_11->FC.Type == BTYPE_MGMT)) {
+				bAckRequired = FALSE;	// Disable ACK to prevent retry 0x1f for Probe Request
 			}
 		}
 	}
 
 	pHeader_802_11->Sequence = pAd->Sequence++;
-	if (pAd->Sequence >0xfff)
+	if (pAd->Sequence > 0xfff)
 		pAd->Sequence = 0;
 
 	// Before radar detection done, mgmt frame can not be sent but probe req
 	// Because we need to use probe req to trigger driver to send probe req in passive scan
 	if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ)
-		&& (pAd->CommonCfg.bIEEE80211H == 1)
-		&& (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("MlmeHardTransmit --> radar detect not in normal mode !!!\n"));
-//		if (!IrqState)
+	    && (pAd->CommonCfg.bIEEE80211H == 1)
+	    && (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("MlmeHardTransmit --> radar detect not in normal mode !!!\n"));
+//              if (!IrqState)
 		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 		return (NDIS_STATUS_FAILURE);
 	}
 
-
 	//
 	// fill scatter-and-gather buffer list into TXD. Internally created NDIS PACKET
 	// should always has only one physical buffer, and the whole frame size equals
@@ -435,38 +412,37 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	// Initialize TX Descriptor
 	// For inter-frame gap, the number is for this frame and next frame
 	// For MLME rate, we will fix as 2Mb to match other vendor's implement
-//	pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
+//      pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
 
 // management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not.
 	PID = PID_MGMT;
 
-
-	if (pMacEntry == NULL)
-	{
-		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE, bInsertTimestamp, FALSE, bAckRequired, FALSE,
-		0, RESERVED_WCID, (SrcBufLen - TXINFO_SIZE - TXWI_SIZE), PID, 0,  (UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS, IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
-	}
-	else
-	{
+	if (pMacEntry == NULL) {
+		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE, bInsertTimestamp,
+			      FALSE, bAckRequired, FALSE, 0, RESERVED_WCID,
+			      (SrcBufLen - TXINFO_SIZE - TXWI_SIZE), PID, 0,
+			      (UCHAR) pAd->CommonCfg.MlmeTransmit.field.MCS,
+			      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
+	} else {
 		/* dont use low rate to send QoS Null data frame */
 		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE,
-					bInsertTimestamp, FALSE, bAckRequired, FALSE,
-					0, pMacEntry->Aid, (SrcBufLen - TXINFO_SIZE - TXWI_SIZE),
-					pMacEntry->MaxHTPhyMode.field.MCS, 0,
-					(UCHAR)pMacEntry->MaxHTPhyMode.field.MCS,
-					IFS_BACKOFF, FALSE, &pMacEntry->MaxHTPhyMode);
+			      bInsertTimestamp, FALSE, bAckRequired, FALSE,
+			      0, pMacEntry->Aid,
+			      (SrcBufLen - TXINFO_SIZE - TXWI_SIZE),
+			      pMacEntry->MaxHTPhyMode.field.MCS, 0,
+			      (UCHAR) pMacEntry->MaxHTPhyMode.field.MCS,
+			      IFS_BACKOFF, FALSE, &pMacEntry->MaxHTPhyMode);
 	}
 
 	// Now do hardware-depened kick out.
 	HAL_KickOutMgmtTx(pAd, QueIdx, pPacket, pSrcBufVA, SrcBufLen);
 
 	// Make sure to release MGMT ring resource
-//	if (!IrqState)
+//      if (!IrqState)
 	RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 	return NDIS_STATUS_SUCCESS;
 }
 
-
 /********************************************************************************
 
 	New DeQueue Procedures.
@@ -530,79 +506,68 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 								(2).Normal
 	========================================================================
 */
-static UCHAR TxPktClassification(
-	IN RTMP_ADAPTER *pAd,
-	IN PNDIS_PACKET  pPacket)
-{
-	UCHAR			TxFrameType = TX_UNKOWN_FRAME;
-	UCHAR			Wcid;
-	MAC_TABLE_ENTRY	*pMacEntry = NULL;
-	BOOLEAN			bHTRate = FALSE;
+static UCHAR TxPktClassification(IN RTMP_ADAPTER * pAd, IN PNDIS_PACKET pPacket)
+{
+	UCHAR TxFrameType = TX_UNKOWN_FRAME;
+	UCHAR Wcid;
+	MAC_TABLE_ENTRY *pMacEntry = NULL;
+	BOOLEAN bHTRate = FALSE;
 
 	Wcid = RTMP_GET_PACKET_WCID(pPacket);
-	if (Wcid == MCAST_WCID)
-	{	// Handle for RA is Broadcast/Multicast Address.
+	if (Wcid == MCAST_WCID) {	// Handle for RA is Broadcast/Multicast Address.
 		return TX_MCAST_FRAME;
 	}
-
 	// Handle for unicast packets
 	pMacEntry = &pAd->MacTab.Content[Wcid];
-	if (RTMP_GET_PACKET_LOWRATE(pPacket))
-	{	// It's a specific packet need to force low rate, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame
+	if (RTMP_GET_PACKET_LOWRATE(pPacket)) {	// It's a specific packet need to force low rate, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame
 		TxFrameType = TX_LEGACY_FRAME;
-	}
-	else if (IS_HT_RATE(pMacEntry))
-	{	// it's a 11n capable packet
+	} else if (IS_HT_RATE(pMacEntry)) {	// it's a 11n capable packet
 
 		// Depends on HTPhyMode to check if the peer support the HTRate transmission.
-		// 	Currently didn't support A-MSDU embedded in A-MPDU
+		//      Currently didn't support A-MSDU embedded in A-MPDU
 		bHTRate = TRUE;
-		if (RTMP_GET_PACKET_MOREDATA(pPacket) || (pMacEntry->PsMode == PWR_SAVE))
+		if (RTMP_GET_PACKET_MOREDATA(pPacket)
+		    || (pMacEntry->PsMode == PWR_SAVE))
 			TxFrameType = TX_LEGACY_FRAME;
-		else if((pMacEntry->TXBAbitmap & (1<<(RTMP_GET_PACKET_UP(pPacket)))) != 0)
+		else if ((pMacEntry->
+			  TXBAbitmap & (1 << (RTMP_GET_PACKET_UP(pPacket)))) !=
+			 0)
 			return TX_AMPDU_FRAME;
-		else if(CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_AMSDU_INUSED))
+		else if (CLIENT_STATUS_TEST_FLAG
+			 (pMacEntry, fCLIENT_STATUS_AMSDU_INUSED))
 			return TX_AMSDU_FRAME;
 		else
 			TxFrameType = TX_LEGACY_FRAME;
-	}
-	else
-	{	// it's a legacy b/g packet.
-		if ((CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE) && pAd->CommonCfg.bAggregationCapable) &&
-			(RTMP_GET_PACKET_TXRATE(pPacket) >= RATE_6) &&
-			(!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE))))
-		{	// if peer support Ralink Aggregation, we use it.
+	} else {		// it's a legacy b/g packet.
+		if ((CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE) && pAd->CommonCfg.bAggregationCapable) && (RTMP_GET_PACKET_TXRATE(pPacket) >= RATE_6) && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE)))) {	// if peer support Ralink Aggregation, we use it.
 			TxFrameType = TX_RALINK_FRAME;
-		}
-		else
-		{
+		} else {
 			TxFrameType = TX_LEGACY_FRAME;
 		}
 	}
 
 	// Currently, our fragment only support when a unicast packet send as NOT-ARALINK, NOT-AMSDU and NOT-AMPDU.
-	if ((RTMP_GET_PACKET_FRAGMENTS(pPacket) > 1) && (TxFrameType == TX_LEGACY_FRAME))
+	if ((RTMP_GET_PACKET_FRAGMENTS(pPacket) > 1)
+	    && (TxFrameType == TX_LEGACY_FRAME))
 		TxFrameType = TX_FRAG_FRAME;
 
 	return TxFrameType;
 }
 
-
-BOOLEAN RTMP_FillTxBlkInfo(
-	IN RTMP_ADAPTER *pAd,
-	IN TX_BLK *pTxBlk)
-{
-	PACKET_INFO			PacketInfo;
-	PNDIS_PACKET		pPacket;
-	PMAC_TABLE_ENTRY	pMacEntry = NULL;
+BOOLEAN RTMP_FillTxBlkInfo(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
+{
+	PACKET_INFO PacketInfo;
+	PNDIS_PACKET pPacket;
+	PMAC_TABLE_ENTRY pMacEntry = NULL;
 
 	pPacket = pTxBlk->pPacket;
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pTxBlk->pSrcBufHeader, &pTxBlk->SrcBufLen);
+	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pTxBlk->pSrcBufHeader,
+			     &pTxBlk->SrcBufLen);
 
-	pTxBlk->Wcid	 	 		= RTMP_GET_PACKET_WCID(pPacket);
-	pTxBlk->apidx		 		= RTMP_GET_PACKET_IF(pPacket);
-	pTxBlk->UserPriority 		= RTMP_GET_PACKET_UP(pPacket);
-	pTxBlk->FrameGap = IFS_HTTXOP;		// ASIC determine Frame Gap
+	pTxBlk->Wcid = RTMP_GET_PACKET_WCID(pPacket);
+	pTxBlk->apidx = RTMP_GET_PACKET_IF(pPacket);
+	pTxBlk->UserPriority = RTMP_GET_PACKET_UP(pPacket);
+	pTxBlk->FrameGap = IFS_HTTXOP;	// ASIC determine Frame Gap
 
 	if (RTMP_GET_PACKET_CLEAR_EAP_FRAME(pTxBlk->pPacket))
 		TX_BLK_SET_FLAG(pTxBlk, fTX_bClearEAPFrame);
@@ -612,32 +577,27 @@ BOOLEAN RTMP_FillTxBlkInfo(
 	// Default to clear this flag
 	TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bForceNonQoS);
 
-
-	if (pTxBlk->Wcid == MCAST_WCID)
-	{
+	if (pTxBlk->Wcid == MCAST_WCID) {
 		pTxBlk->pMacEntry = NULL;
 		{
-				pTxBlk->pTransmit = &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
+			pTxBlk->pTransmit =
+			    &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
 		}
 
 		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);	// AckRequired = FALSE, when broadcast packet in Adhoc mode.
 		//TX_BLK_SET_FLAG(pTxBlk, fTX_bForceLowRate);
 		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAllowFrag);
 		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bWMM);
-		if (RTMP_GET_PACKET_MOREDATA(pPacket))
-		{
+		if (RTMP_GET_PACKET_MOREDATA(pPacket)) {
 			TX_BLK_SET_FLAG(pTxBlk, fTX_bMoreData);
 		}
 
-	}
-	else
-	{
+	} else {
 		pTxBlk->pMacEntry = &pAd->MacTab.Content[pTxBlk->Wcid];
 		pTxBlk->pTransmit = &pTxBlk->pMacEntry->HTPhyMode;
 
 		pMacEntry = pTxBlk->pMacEntry;
 
-
 		// For all unicast packets, need Ack unless the Ack Policy is not set as NORMAL_ACK.
 		if (pAd->CommonCfg.AckPolicy[pTxBlk->QueIdx] != NORMAL_ACK)
 			TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);
@@ -645,56 +605,54 @@ BOOLEAN RTMP_FillTxBlkInfo(
 			TX_BLK_SET_FLAG(pTxBlk, fTX_bAckRequired);
 
 		if ((pAd->OpMode == OPMODE_STA) &&
-			(ADHOC_ON(pAd)) &&
-			(RX_FILTER_TEST_FLAG(pAd, fRX_FILTER_ACCEPT_PROMISCUOUS)))
-		{
-			if(pAd->CommonCfg.PSPXlink)
+		    (ADHOC_ON(pAd)) &&
+		    (RX_FILTER_TEST_FLAG(pAd, fRX_FILTER_ACCEPT_PROMISCUOUS))) {
+			if (pAd->CommonCfg.PSPXlink)
 				TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);
 		}
 
 		{
-		{
-
-			// If support WMM, enable it.
-			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) &&
-				CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE))
-				TX_BLK_SET_FLAG(pTxBlk, fTX_bWMM);
+			{
 
-//				if (pAd->StaCfg.bAutoTxRateSwitch)
-//					TX_BLK_SET_FLAG(pTxBlk, fTX_AutoRateSwitch);
+				// If support WMM, enable it.
+				if (OPSTATUS_TEST_FLAG
+				    (pAd, fOP_STATUS_WMM_INUSED)
+				    && CLIENT_STATUS_TEST_FLAG(pMacEntry,
+							       fCLIENT_STATUS_WMM_CAPABLE))
+					TX_BLK_SET_FLAG(pTxBlk, fTX_bWMM);
+
+//                              if (pAd->StaCfg.bAutoTxRateSwitch)
+//                                      TX_BLK_SET_FLAG(pTxBlk, fTX_AutoRateSwitch);
 			}
 		}
 
-		if (pTxBlk->TxFrameType == TX_LEGACY_FRAME)
-		{
-			if ( (RTMP_GET_PACKET_LOWRATE(pPacket)) ||
-                ((pAd->OpMode == OPMODE_AP) && (pMacEntry->MaxHTPhyMode.field.MODE == MODE_CCK) && (pMacEntry->MaxHTPhyMode.field.MCS == RATE_1)))
-			{	// Specific packet, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame, need force low rate.
-				pTxBlk->pTransmit = &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
+		if (pTxBlk->TxFrameType == TX_LEGACY_FRAME) {
+			if ((RTMP_GET_PACKET_LOWRATE(pPacket)) || ((pAd->OpMode == OPMODE_AP) && (pMacEntry->MaxHTPhyMode.field.MODE == MODE_CCK) && (pMacEntry->MaxHTPhyMode.field.MCS == RATE_1))) {	// Specific packet, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame, need force low rate.
+				pTxBlk->pTransmit =
+				    &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
 
 				// Modify the WMM bit for ICV issue. If we have a packet with EOSP field need to set as 1, how to handle it???
 				if (IS_HT_STA(pTxBlk->pMacEntry) &&
-					(CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_RALINK_CHIPSET)) &&
-					((pAd->CommonCfg.bRdg == TRUE) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_RDG_CAPABLE)))
+				    (CLIENT_STATUS_TEST_FLAG
+				     (pMacEntry, fCLIENT_STATUS_RALINK_CHIPSET))
+				    && ((pAd->CommonCfg.bRdg == TRUE)
+					&& CLIENT_STATUS_TEST_FLAG(pMacEntry,
+								   fCLIENT_STATUS_RDG_CAPABLE)))
 				{
 					TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bWMM);
-					TX_BLK_SET_FLAG(pTxBlk, fTX_bForceNonQoS);
+					TX_BLK_SET_FLAG(pTxBlk,
+							fTX_bForceNonQoS);
 				}
 			}
 
-			if ( (IS_HT_RATE(pMacEntry) == FALSE) &&
-				(CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE)))
-			{	// Currently piggy-back only support when peer is operate in b/g mode.
+			if ((IS_HT_RATE(pMacEntry) == FALSE) && (CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE))) {	// Currently piggy-back only support when peer is operate in b/g mode.
 				TX_BLK_SET_FLAG(pTxBlk, fTX_bPiggyBack);
 			}
 
-			if (RTMP_GET_PACKET_MOREDATA(pPacket))
-			{
+			if (RTMP_GET_PACKET_MOREDATA(pPacket)) {
 				TX_BLK_SET_FLAG(pTxBlk, fTX_bMoreData);
 			}
-		}
-		else if (pTxBlk->TxFrameType == TX_FRAG_FRAME)
-		{
+		} else if (pTxBlk->TxFrameType == TX_FRAG_FRAME) {
 			TX_BLK_SET_FLAG(pTxBlk, fTX_bAllowFrag);
 		}
 
@@ -704,11 +662,8 @@ BOOLEAN RTMP_FillTxBlkInfo(
 	return TRUE;
 }
 
-
-BOOLEAN CanDoAggregateTransmit(
-	IN RTMP_ADAPTER *pAd,
-	IN NDIS_PACKET *pPacket,
-	IN TX_BLK		*pTxBlk)
+BOOLEAN CanDoAggregateTransmit(IN RTMP_ADAPTER * pAd,
+			       IN NDIS_PACKET * pPacket, IN TX_BLK * pTxBlk)
 {
 
 	//DBGPRINT(RT_DEBUG_TRACE, ("Check if can do aggregation! TxFrameType=%d!\n", pTxBlk->TxFrameType));
@@ -717,30 +672,24 @@ BOOLEAN CanDoAggregateTransmit(
 		return FALSE;
 
 	if (RTMP_GET_PACKET_DHCP(pPacket) ||
-		RTMP_GET_PACKET_EAPOL(pPacket) ||
-		RTMP_GET_PACKET_WAI(pPacket))
+	    RTMP_GET_PACKET_EAPOL(pPacket) || RTMP_GET_PACKET_WAI(pPacket))
 		return FALSE;
 
-	if ((pTxBlk->TxFrameType == TX_AMSDU_FRAME) &&
-		((pTxBlk->TotalFrameLen + GET_OS_PKT_LEN(pPacket))> (RX_BUFFER_AGGRESIZE - 100)))
-	{	// For AMSDU, allow the packets with total length < max-amsdu size
+	if ((pTxBlk->TxFrameType == TX_AMSDU_FRAME) && ((pTxBlk->TotalFrameLen + GET_OS_PKT_LEN(pPacket)) > (RX_BUFFER_AGGRESIZE - 100))) {	// For AMSDU, allow the packets with total length < max-amsdu size
 		return FALSE;
 	}
 
-	if ((pTxBlk->TxFrameType == TX_RALINK_FRAME) &&
-		(pTxBlk->TxPacketList.Number == 2))
-	{	// For RALINK-Aggregation, allow two frames in one batch.
+	if ((pTxBlk->TxFrameType == TX_RALINK_FRAME) && (pTxBlk->TxPacketList.Number == 2)) {	// For RALINK-Aggregation, allow two frames in one batch.
 		return FALSE;
 	}
 
-	if ((INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA)) // must be unicast to AP
+	if ((INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA))	// must be unicast to AP
 		return TRUE;
 	else
 		return FALSE;
 
 }
 
-
 /*
 	========================================================================
 
@@ -763,51 +712,41 @@ BOOLEAN CanDoAggregateTransmit(
 
 	========================================================================
 */
-VOID RTMPDeQueuePacket(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  BOOLEAN         bIntContext,
-	IN  UCHAR			QIdx, /* BulkOutPipeId */
-	IN  UCHAR           Max_Tx_Packets)
-{
-	PQUEUE_ENTRY    pEntry = NULL;
-	PNDIS_PACKET 	pPacket;
-	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
-	UCHAR           Count=0;
-	PQUEUE_HEADER   pQueue;
-	ULONG           FreeNumber[NUM_OF_TX_RING];
-	UCHAR			QueIdx, sQIdx, eQIdx;
-	unsigned long	IrqFlags = 0;
-	BOOLEAN			hasTxDesc = FALSE;
-	TX_BLK			TxBlk;
-	TX_BLK			*pTxBlk;
-
-
+VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QIdx,	/* BulkOutPipeId */
+		       IN UCHAR Max_Tx_Packets)
+{
+	PQUEUE_ENTRY pEntry = NULL;
+	PNDIS_PACKET pPacket;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+	UCHAR Count = 0;
+	PQUEUE_HEADER pQueue;
+	ULONG FreeNumber[NUM_OF_TX_RING];
+	UCHAR QueIdx, sQIdx, eQIdx;
+	unsigned long IrqFlags = 0;
+	BOOLEAN hasTxDesc = FALSE;
+	TX_BLK TxBlk;
+	TX_BLK *pTxBlk;
 
-	if (QIdx == NUM_OF_TX_RING)
-	{
+	if (QIdx == NUM_OF_TX_RING) {
 		sQIdx = 0;
 		eQIdx = 3;	// 4 ACs, start from 0.
-	}
-	else
-	{
+	} else {
 		sQIdx = eQIdx = QIdx;
 	}
 
-	for (QueIdx=sQIdx; QueIdx <= eQIdx; QueIdx++)
-	{
-		Count=0;
+	for (QueIdx = sQIdx; QueIdx <= eQIdx; QueIdx++) {
+		Count = 0;
 
 		RTMP_START_DEQUEUE(pAd, QueIdx, IrqFlags);
 
-
-		while (1)
-		{
-			if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS |
-										fRTMP_ADAPTER_RADIO_OFF |
-										fRTMP_ADAPTER_RESET_IN_PROGRESS |
-										fRTMP_ADAPTER_HALT_IN_PROGRESS |
-										fRTMP_ADAPTER_NIC_NOT_EXIST))))
-			{
+		while (1) {
+			if ((RTMP_TEST_FLAG
+			     (pAd,
+			      (fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS |
+			       fRTMP_ADAPTER_RADIO_OFF |
+			       fRTMP_ADAPTER_RESET_IN_PROGRESS |
+			       fRTMP_ADAPTER_HALT_IN_PROGRESS |
+			       fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
 				RTMP_STOP_DEQUEUE(pAd, QueIdx, IrqFlags);
 				return;
 			}
@@ -816,47 +755,47 @@ VOID RTMPDeQueuePacket(
 				break;
 
 			DEQUEUE_LOCK(&pAd->irq_lock, bIntContext, IrqFlags);
-			if (&pAd->TxSwQueue[QueIdx] == NULL)
-			{
-				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+			if (&pAd->TxSwQueue[QueIdx] == NULL) {
+				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext,
+					       IrqFlags);
 				break;
 			}
-
 #ifdef RTMP_MAC_PCI
 			FreeNumber[QueIdx] = GET_TXRING_FREENO(pAd, QueIdx);
 
-
-			if (FreeNumber[QueIdx] <= 5)
-			{
+			if (FreeNumber[QueIdx] <= 5) {
 				// free Tx(QueIdx) resources
 				RTMPFreeTXDUponTxDmaDone(pAd, QueIdx);
-				FreeNumber[QueIdx] = GET_TXRING_FREENO(pAd, QueIdx);
+				FreeNumber[QueIdx] =
+				    GET_TXRING_FREENO(pAd, QueIdx);
 			}
 #endif // RTMP_MAC_PCI //
 
 			// probe the Queue Head
 			pQueue = &pAd->TxSwQueue[QueIdx];
-			if ((pEntry = pQueue->Head) == NULL)
-			{
-				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+			if ((pEntry = pQueue->Head) == NULL) {
+				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext,
+					       IrqFlags);
 				break;
 			}
 
 			pTxBlk = &TxBlk;
-			NdisZeroMemory((PUCHAR)pTxBlk, sizeof(TX_BLK));
-			//InitializeQueueHeader(&pTxBlk->TxPacketList);		// Didn't need it because we already memzero it.
+			NdisZeroMemory((PUCHAR) pTxBlk, sizeof(TX_BLK));
+			//InitializeQueueHeader(&pTxBlk->TxPacketList);         // Didn't need it because we already memzero it.
 			pTxBlk->QueIdx = QueIdx;
 
 			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
 
-
 			// Early check to make sure we have enoguh Tx Resource.
-			hasTxDesc = RTMP_HAS_ENOUGH_FREE_DESC(pAd, pTxBlk, FreeNumber[QueIdx], pPacket);
-			if (!hasTxDesc)
-			{
+			hasTxDesc =
+			    RTMP_HAS_ENOUGH_FREE_DESC(pAd, pTxBlk,
+						      FreeNumber[QueIdx],
+						      pPacket);
+			if (!hasTxDesc) {
 				pAd->PrivateInfo.TxRingFullCnt++;
 
-				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext,
+					       IrqFlags);
 
 				break;
 			}
@@ -867,27 +806,41 @@ VOID RTMPDeQueuePacket(
 			pTxBlk->TotalFragNum += RTMP_GET_PACKET_FRAGMENTS(pPacket);	// The real fragment number maybe vary
 			pTxBlk->TotalFrameLen += GET_OS_PKT_LEN(pPacket);
 			pTxBlk->pPacket = pPacket;
-			InsertTailQueue(&pTxBlk->TxPacketList, PACKET_TO_QUEUE_ENTRY(pPacket));
+			InsertTailQueue(&pTxBlk->TxPacketList,
+					PACKET_TO_QUEUE_ENTRY(pPacket));
 
-			if (pTxBlk->TxFrameType == TX_RALINK_FRAME || pTxBlk->TxFrameType == TX_AMSDU_FRAME)
-			{
+			if (pTxBlk->TxFrameType == TX_RALINK_FRAME
+			    || pTxBlk->TxFrameType == TX_AMSDU_FRAME) {
 				// Enhance SW Aggregation Mechanism
-				if (NEED_QUEUE_BACK_FOR_AGG(pAd, QueIdx, FreeNumber[QueIdx], pTxBlk->TxFrameType))
-				{
-					InsertHeadQueue(pQueue, PACKET_TO_QUEUE_ENTRY(pPacket));
-					DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+				if (NEED_QUEUE_BACK_FOR_AGG
+				    (pAd, QueIdx, FreeNumber[QueIdx],
+				     pTxBlk->TxFrameType)) {
+					InsertHeadQueue(pQueue,
+							PACKET_TO_QUEUE_ENTRY
+							(pPacket));
+					DEQUEUE_UNLOCK(&pAd->irq_lock,
+						       bIntContext, IrqFlags);
 					break;
 				}
 
-				do{
-					if((pEntry = pQueue->Head) == NULL)
+				do {
+					if ((pEntry = pQueue->Head) == NULL)
 						break;
 
 					// For TX_AMSDU_FRAME/TX_RALINK_FRAME, Need to check if next pakcet can do aggregation.
 					pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
-					FreeNumber[QueIdx] = GET_TXRING_FREENO(pAd, QueIdx);
-					hasTxDesc = RTMP_HAS_ENOUGH_FREE_DESC(pAd, pTxBlk, FreeNumber[QueIdx], pPacket);
-					if ((hasTxDesc == FALSE) || (CanDoAggregateTransmit(pAd, pPacket, pTxBlk) == FALSE))
+					FreeNumber[QueIdx] =
+					    GET_TXRING_FREENO(pAd, QueIdx);
+					hasTxDesc =
+					    RTMP_HAS_ENOUGH_FREE_DESC(pAd,
+								      pTxBlk,
+								      FreeNumber
+								      [QueIdx],
+								      pPacket);
+					if ((hasTxDesc == FALSE)
+					    ||
+					    (CanDoAggregateTransmit
+					     (pAd, pPacket, pTxBlk) == FALSE))
 						break;
 
 					//Remove the packet from the TxSwQueue and insert into pTxBlk
@@ -896,14 +849,16 @@ VOID RTMPDeQueuePacket(
 					pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
 					pTxBlk->TotalFrameNum++;
 					pTxBlk->TotalFragNum += RTMP_GET_PACKET_FRAGMENTS(pPacket);	// The real fragment number maybe vary
-					pTxBlk->TotalFrameLen += GET_OS_PKT_LEN(pPacket);
-					InsertTailQueue(&pTxBlk->TxPacketList, PACKET_TO_QUEUE_ENTRY(pPacket));
-				}while(1);
+					pTxBlk->TotalFrameLen +=
+					    GET_OS_PKT_LEN(pPacket);
+					InsertTailQueue(&pTxBlk->TxPacketList,
+							PACKET_TO_QUEUE_ENTRY
+							(pPacket));
+				} while (1);
 
 				if (pTxBlk->TxPacketList.Number == 1)
 					pTxBlk->TxFrameType = TX_LEGACY_FRAME;
 			}
-
 #ifdef RTMP_MAC_USB
 			DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
 #endif // RTMP_MAC_USB //
@@ -916,7 +871,7 @@ VOID RTMPDeQueuePacket(
 			DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
 			// static rate also need NICUpdateFifoStaCounters() function.
 			//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
-				NICUpdateFifoStaCounters(pAd);
+			NICUpdateFifoStaCounters(pAd);
 #endif // RTMP_MAC_PCI //
 
 		}
@@ -931,7 +886,6 @@ VOID RTMPDeQueuePacket(
 
 }
 
-
 /*
 	========================================================================
 
@@ -954,40 +908,37 @@ VOID RTMPDeQueuePacket(
 
 	========================================================================
 */
-USHORT	RTMPCalcDuration(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Rate,
-	IN	ULONG			Size)
+USHORT RTMPCalcDuration(IN PRTMP_ADAPTER pAd, IN UCHAR Rate, IN ULONG Size)
 {
-	ULONG	Duration = 0;
+	ULONG Duration = 0;
 
-	if (Rate < RATE_FIRST_OFDM_RATE) // CCK
+	if (Rate < RATE_FIRST_OFDM_RATE)	// CCK
 	{
-		if ((Rate > RATE_1) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED))
+		if ((Rate > RATE_1)
+		    && OPSTATUS_TEST_FLAG(pAd,
+					  fOP_STATUS_SHORT_PREAMBLE_INUSED))
 			Duration = 96;	// 72+24 preamble+plcp
 		else
-			Duration = 192; // 144+48 preamble+plcp
+			Duration = 192;	// 144+48 preamble+plcp
 
-		Duration += (USHORT)((Size << 4) / RateIdTo500Kbps[Rate]);
+		Duration += (USHORT) ((Size << 4) / RateIdTo500Kbps[Rate]);
 		if ((Size << 4) % RateIdTo500Kbps[Rate])
-			Duration ++;
-	}
-	else if (Rate <= RATE_LAST_OFDM_RATE)// OFDM rates
+			Duration++;
+	} else if (Rate <= RATE_LAST_OFDM_RATE)	// OFDM rates
 	{
-		Duration = 20 + 6;		// 16+4 preamble+plcp + Signal Extension
-		Duration += 4 * (USHORT)((11 + Size * 4) / RateIdTo500Kbps[Rate]);
+		Duration = 20 + 6;	// 16+4 preamble+plcp + Signal Extension
+		Duration +=
+		    4 * (USHORT) ((11 + Size * 4) / RateIdTo500Kbps[Rate]);
 		if ((11 + Size * 4) % RateIdTo500Kbps[Rate])
 			Duration += 4;
-	}
-	else	//mimo rate
+	} else			//mimo rate
 	{
-		Duration = 20 + 6;		// 16+4 preamble+plcp + Signal Extension
+		Duration = 20 + 6;	// 16+4 preamble+plcp + Signal Extension
 	}
 
-	return (USHORT)Duration;
+	return (USHORT) Duration;
 }
 
-
 /*
 	========================================================================
 
@@ -1017,28 +968,19 @@ USHORT	RTMPCalcDuration(
 
 	========================================================================
 */
-VOID RTMPWriteTxWI(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PTXWI_STRUC 	pOutTxWI,
-	IN	BOOLEAN			FRAG,
-	IN	BOOLEAN			CFACK,
-	IN	BOOLEAN			InsTimestamp,
-	IN	BOOLEAN 		AMPDU,
-	IN	BOOLEAN 		Ack,
-	IN	BOOLEAN 		NSeq,		// HW new a sequence.
-	IN	UCHAR			BASize,
-	IN	UCHAR			WCID,
-	IN	ULONG			Length,
-	IN	UCHAR 			PID,
-	IN	UCHAR			TID,
-	IN	UCHAR			TxRate,
-	IN	UCHAR			Txopmode,
-	IN	BOOLEAN			CfAck,
-	IN	HTTRANSMIT_SETTING	*pTransmit)
-{
-	PMAC_TABLE_ENTRY	pMac = NULL;
-	TXWI_STRUC 		TxWI;
-	PTXWI_STRUC 	pTxWI;
+VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pOutTxWI, IN BOOLEAN FRAG, IN BOOLEAN CFACK, IN BOOLEAN InsTimestamp, IN BOOLEAN AMPDU, IN BOOLEAN Ack, IN BOOLEAN NSeq,	// HW new a sequence.
+		   IN UCHAR BASize,
+		   IN UCHAR WCID,
+		   IN ULONG Length,
+		   IN UCHAR PID,
+		   IN UCHAR TID,
+		   IN UCHAR TxRate,
+		   IN UCHAR Txopmode,
+		   IN BOOLEAN CfAck, IN HTTRANSMIT_SETTING * pTransmit)
+{
+	PMAC_TABLE_ENTRY pMac = NULL;
+	TXWI_STRUC TxWI;
+	PTXWI_STRUC pTxWI;
 
 	if (WCID < MAX_LEN_OF_MAC_TABLE)
 		pMac = &pAd->MacTab.Content[WCID];
@@ -1051,26 +993,23 @@ VOID RTMPWriteTxWI(
 	NdisZeroMemory(&TxWI, TXWI_SIZE);
 	pTxWI = &TxWI;
 
-	pTxWI->FRAG= FRAG;
+	pTxWI->FRAG = FRAG;
 
 	pTxWI->CFACK = CFACK;
-	pTxWI->TS= InsTimestamp;
+	pTxWI->TS = InsTimestamp;
 	pTxWI->AMPDU = AMPDU;
 	pTxWI->ACK = Ack;
-	pTxWI->txop= Txopmode;
+	pTxWI->txop = Txopmode;
 
 	pTxWI->NSEQ = NSeq;
 	// John tune the performace with Intel Client in 20 MHz performance
 	BASize = pAd->CommonCfg.TxBASize;
-	if (pAd->MACVersion == 0x28720200)
-	{
-		if( BASize >13 )
-			BASize =13;
-	}
-	else
-	{
-	if( BASize >7 )
-		BASize =7;
+	if (pAd->MACVersion == 0x28720200) {
+		if (BASize > 13)
+			BASize = 13;
+	} else {
+		if (BASize > 7)
+			BASize = 7;
 	}
 	pTxWI->BAWinSize = BASize;
 	pTxWI->ShortGI = pTransmit->field.ShortGI;
@@ -1081,38 +1020,34 @@ VOID RTMPWriteTxWI(
 	pTxWI->PacketId = PID;
 
 	// If CCK or OFDM, BW must be 20
-	pTxWI->BW = (pTransmit->field.MODE <= MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
+	pTxWI->BW =
+	    (pTransmit->field.MODE <=
+	     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
 
 	pTxWI->MCS = pTransmit->field.MCS;
 	pTxWI->PHYMODE = pTransmit->field.MODE;
 	pTxWI->CFACK = CfAck;
 
-	if (pMac)
-	{
-		if (pAd->CommonCfg.bMIMOPSEnable)
-		{
-			if ((pMac->MmpsMode == MMPS_DYNAMIC) && (pTransmit->field.MCS > 7))
-			{
+	if (pMac) {
+		if (pAd->CommonCfg.bMIMOPSEnable) {
+			if ((pMac->MmpsMode == MMPS_DYNAMIC)
+			    && (pTransmit->field.MCS > 7)) {
 				// Dynamic MIMO Power Save Mode
 				pTxWI->MIMOps = 1;
-			}
-			else if (pMac->MmpsMode == MMPS_STATIC)
-			{
+			} else if (pMac->MmpsMode == MMPS_STATIC) {
 				// Static MIMO Power Save Mode
-				if (pTransmit->field.MODE >= MODE_HTMIX && pTransmit->field.MCS > 7)
-				{
+				if (pTransmit->field.MODE >= MODE_HTMIX
+				    && pTransmit->field.MCS > 7) {
 					pTxWI->MCS = 7;
 					pTxWI->MIMOps = 0;
 				}
 			}
 		}
 		//pTxWI->MIMOps = (pMac->PsMode == PWR_MMPS)? 1:0;
-		if (pMac->bIAmBadAtheros && (pMac->WepStatus != Ndis802_11WEPDisabled))
-		{
+		if (pMac->bIAmBadAtheros
+		    && (pMac->WepStatus != Ndis802_11WEPDisabled)) {
 			pTxWI->MpduDensity = 7;
-		}
-		else
-		{
+		} else {
 			pTxWI->MpduDensity = pMac->MpduDensity;
 		}
 	}
@@ -1121,22 +1056,18 @@ VOID RTMPWriteTxWI(
 	NdisMoveMemory(pOutTxWI, &TxWI, sizeof(TXWI_STRUC));
 }
 
-
-VOID RTMPWriteTxWI_Data(
-	IN	PRTMP_ADAPTER		pAd,
-	IN	OUT PTXWI_STRUC		pTxWI,
-	IN	TX_BLK				*pTxBlk)
-{
-	HTTRANSMIT_SETTING	*pTransmit;
-	PMAC_TABLE_ENTRY	pMacEntry;
-	UCHAR				BASize;
+VOID RTMPWriteTxWI_Data(IN PRTMP_ADAPTER pAd,
+			IN OUT PTXWI_STRUC pTxWI, IN TX_BLK * pTxBlk)
+{
+	HTTRANSMIT_SETTING *pTransmit;
+	PMAC_TABLE_ENTRY pMacEntry;
+	UCHAR BASize;
 
 	ASSERT(pTxWI);
 
 	pTransmit = pTxBlk->pTransmit;
 	pMacEntry = pTxBlk->pMacEntry;
 
-
 	//
 	// Always use Long preamble before verifiation short preamble functionality works well.
 	// Todo: remove the following line if short preamble functionality works
@@ -1144,26 +1075,28 @@ VOID RTMPWriteTxWI_Data(
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
 	NdisZeroMemory(pTxWI, TXWI_SIZE);
 
-	pTxWI->FRAG		= TX_BLK_TEST_FLAG(pTxBlk, fTX_bAllowFrag);
-	pTxWI->ACK		= TX_BLK_TEST_FLAG(pTxBlk, fTX_bAckRequired);
-	pTxWI->txop		= pTxBlk->FrameGap;
+	pTxWI->FRAG = TX_BLK_TEST_FLAG(pTxBlk, fTX_bAllowFrag);
+	pTxWI->ACK = TX_BLK_TEST_FLAG(pTxBlk, fTX_bAckRequired);
+	pTxWI->txop = pTxBlk->FrameGap;
 
-		pTxWI->WirelessCliID		= pTxBlk->Wcid;
+	pTxWI->WirelessCliID = pTxBlk->Wcid;
 
-	pTxWI->MPDUtotalByteCount	= pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
-	pTxWI->CFACK				= TX_BLK_TEST_FLAG(pTxBlk, fTX_bPiggyBack);
+	pTxWI->MPDUtotalByteCount = pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
+	pTxWI->CFACK = TX_BLK_TEST_FLAG(pTxBlk, fTX_bPiggyBack);
 
 	// If CCK or OFDM, BW must be 20
-	pTxWI->BW = (pTransmit->field.MODE <= MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
-	pTxWI->AMPDU	= ((pTxBlk->TxFrameType == TX_AMPDU_FRAME) ? TRUE : FALSE);
+	pTxWI->BW =
+	    (pTransmit->field.MODE <=
+	     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
+	pTxWI->AMPDU = ((pTxBlk->TxFrameType == TX_AMPDU_FRAME) ? TRUE : FALSE);
 
 	// John tune the performace with Intel Client in 20 MHz performance
 	BASize = pAd->CommonCfg.TxBASize;
-	if((pTxBlk->TxFrameType == TX_AMPDU_FRAME) && (pMacEntry))
-	{
-		UCHAR		RABAOriIdx = 0;	//The RA's BA Originator table index.
+	if ((pTxBlk->TxFrameType == TX_AMPDU_FRAME) && (pMacEntry)) {
+		UCHAR RABAOriIdx = 0;	//The RA's BA Originator table index.
 
-		RABAOriIdx = pTxBlk->pMacEntry->BAOriWcidArray[pTxBlk->UserPriority];
+		RABAOriIdx =
+		    pTxBlk->pMacEntry->BAOriWcidArray[pTxBlk->UserPriority];
 		BASize = pAd->BATable.BAOriEntry[RABAOriIdx].BAWinSize;
 	}
 
@@ -1175,46 +1108,37 @@ VOID RTMPWriteTxWI_Data(
 	pTxWI->MCS = pTransmit->field.MCS;
 	pTxWI->PHYMODE = pTransmit->field.MODE;
 
-	if (pMacEntry)
-	{
-		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC) && (pTransmit->field.MCS > 7))
-		{
+	if (pMacEntry) {
+		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC)
+		    && (pTransmit->field.MCS > 7)) {
 			// Dynamic MIMO Power Save Mode
 			pTxWI->MIMOps = 1;
-		}
-		else if (pMacEntry->MmpsMode == MMPS_STATIC)
-		{
+		} else if (pMacEntry->MmpsMode == MMPS_STATIC) {
 			// Static MIMO Power Save Mode
-			if (pTransmit->field.MODE >= MODE_HTMIX && pTransmit->field.MCS > 7)
-			{
+			if (pTransmit->field.MODE >= MODE_HTMIX
+			    && pTransmit->field.MCS > 7) {
 				pTxWI->MCS = 7;
 				pTxWI->MIMOps = 0;
 			}
 		}
 
-		if (pMacEntry->bIAmBadAtheros && (pMacEntry->WepStatus != Ndis802_11WEPDisabled))
-		{
+		if (pMacEntry->bIAmBadAtheros
+		    && (pMacEntry->WepStatus != Ndis802_11WEPDisabled)) {
 			pTxWI->MpduDensity = 7;
-		}
-		else
-		{
+		} else {
 			pTxWI->MpduDensity = pMacEntry->MpduDensity;
 		}
 	}
 
-
 	// for rate adapation
 	pTxWI->PacketId = pTxWI->MCS;
 }
 
-
-VOID RTMPWriteTxWI_Cache(
-	IN	PRTMP_ADAPTER		pAd,
-	IN	OUT PTXWI_STRUC		pTxWI,
-	IN	TX_BLK				*pTxBlk)
+VOID RTMPWriteTxWI_Cache(IN PRTMP_ADAPTER pAd,
+			 IN OUT PTXWI_STRUC pTxWI, IN TX_BLK * pTxBlk)
 {
-	PHTTRANSMIT_SETTING	/*pTxHTPhyMode,*/ pTransmit;
-	PMAC_TABLE_ENTRY	pMacEntry;
+	PHTTRANSMIT_SETTING /*pTxHTPhyMode, */ pTransmit;
+	PMAC_TABLE_ENTRY pMacEntry;
 
 	//
 	// update TXWI
@@ -1225,12 +1149,13 @@ VOID RTMPWriteTxWI_Cache(
 	//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
 	//if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pMacEntry))
 	//if (TX_BLK_TEST_FLAG(pTxBlk, fTX_AutoRateSwitch))
-	if (pMacEntry->bAutoTxRateSwitch)
-	{
+	if (pMacEntry->bAutoTxRateSwitch) {
 		pTxWI->txop = IFS_HTTXOP;
 
 		// If CCK or OFDM, BW must be 20
-		pTxWI->BW = (pTransmit->field.MODE <= MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
+		pTxWI->BW =
+		    (pTransmit->field.MODE <=
+		     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
 		pTxWI->ShortGI = pTransmit->field.ShortGI;
 		pTxWI->STBC = pTransmit->field.STBC;
 
@@ -1241,43 +1166,36 @@ VOID RTMPWriteTxWI_Cache(
 		pTxWI->PacketId = pTransmit->field.MCS;
 	}
 
-	pTxWI->AMPDU = ((pMacEntry->NoBADataCountDown == 0) ? TRUE: FALSE);
+	pTxWI->AMPDU = ((pMacEntry->NoBADataCountDown == 0) ? TRUE : FALSE);
 	pTxWI->MIMOps = 0;
 
-	if (pAd->CommonCfg.bMIMOPSEnable)
-	{
+	if (pAd->CommonCfg.bMIMOPSEnable) {
 		// MIMO Power Save Mode
-		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC) && (pTransmit->field.MCS > 7))
-		{
+		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC)
+		    && (pTransmit->field.MCS > 7)) {
 			// Dynamic MIMO Power Save Mode
 			pTxWI->MIMOps = 1;
-		}
-		else if (pMacEntry->MmpsMode == MMPS_STATIC)
-		{
+		} else if (pMacEntry->MmpsMode == MMPS_STATIC) {
 			// Static MIMO Power Save Mode
-			if ((pTransmit->field.MODE >= MODE_HTMIX) && (pTransmit->field.MCS > 7))
-			{
+			if ((pTransmit->field.MODE >= MODE_HTMIX)
+			    && (pTransmit->field.MCS > 7)) {
 				pTxWI->MCS = 7;
 				pTxWI->MIMOps = 0;
 			}
 		}
 	}
 
-
 	pTxWI->MPDUtotalByteCount = pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
 
 }
 
-
 // should be called only when -
 // 1. MEADIA_CONNECTED
 // 2. AGGREGATION_IN_USED
 // 3. Fragmentation not in used
 // 4. either no previous frame (pPrevAddr1=NULL) .OR. previoud frame is aggregatible
-BOOLEAN TxFrameIsAggregatible(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pPrevAddr1,
-	IN	PUCHAR			p8023hdr)
+BOOLEAN TxFrameIsAggregatible(IN PRTMP_ADAPTER pAd,
+			      IN PUCHAR pPrevAddr1, IN PUCHAR p8023hdr)
 {
 
 	// can't aggregate EAPOL (802.1x) frame
@@ -1288,15 +1206,14 @@ BOOLEAN TxFrameIsAggregatible(
 	if (p8023hdr[0] & 0x01)
 		return FALSE;
 
-	if (INFRA_ON(pAd)) // must be unicast to AP
+	if (INFRA_ON(pAd))	// must be unicast to AP
 		return TRUE;
-	else if ((pPrevAddr1 == NULL) || MAC_ADDR_EQUAL(pPrevAddr1, p8023hdr)) // unicast to same STA
+	else if ((pPrevAddr1 == NULL) || MAC_ADDR_EQUAL(pPrevAddr1, p8023hdr))	// unicast to same STA
 		return TRUE;
 	else
 		return FALSE;
 }
 
-
 /*
 	========================================================================
 
@@ -1313,23 +1230,18 @@ BOOLEAN TxFrameIsAggregatible(
 
 	========================================================================
 */
-BOOLEAN PeerIsAggreOn(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	ULONG		   TxRate,
-	IN	PMAC_TABLE_ENTRY pMacEntry)
+BOOLEAN PeerIsAggreOn(IN PRTMP_ADAPTER pAd,
+		      IN ULONG TxRate, IN PMAC_TABLE_ENTRY pMacEntry)
 {
-	ULONG	AFlags = (fCLIENT_STATUS_AMSDU_INUSED | fCLIENT_STATUS_AGGREGATION_CAPABLE);
+	ULONG AFlags =
+	    (fCLIENT_STATUS_AMSDU_INUSED | fCLIENT_STATUS_AGGREGATION_CAPABLE);
 
-	if (pMacEntry != NULL && CLIENT_STATUS_TEST_FLAG(pMacEntry, AFlags))
-	{
-		if (pMacEntry->HTPhyMode.field.MODE >= MODE_HTMIX)
-		{
+	if (pMacEntry != NULL && CLIENT_STATUS_TEST_FLAG(pMacEntry, AFlags)) {
+		if (pMacEntry->HTPhyMode.field.MODE >= MODE_HTMIX) {
 			return TRUE;
 		}
-
 #ifdef AGGREGATION_SUPPORT
-		if (TxRate >= RATE_6 && pAd->CommonCfg.bAggregationCapable && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE))))
-		{	// legacy  Ralink Aggregation support
+		if (TxRate >= RATE_6 && pAd->CommonCfg.bAggregationCapable && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE)))) {	// legacy  Ralink Aggregation support
 			return TRUE;
 		}
 #endif // AGGREGATION_SUPPORT //
@@ -1339,7 +1251,6 @@ BOOLEAN PeerIsAggreOn(
 
 }
 
-
 /*
 	========================================================================
 
@@ -1358,49 +1269,38 @@ BOOLEAN PeerIsAggreOn(
 
 	========================================================================
 */
-PQUEUE_HEADER	RTMPCheckTxSwQueue(
-	IN	PRTMP_ADAPTER	pAd,
-	OUT PUCHAR			pQueIdx)
+PQUEUE_HEADER RTMPCheckTxSwQueue(IN PRTMP_ADAPTER pAd, OUT PUCHAR pQueIdx)
 {
 
-	ULONG	Number;
+	ULONG Number;
 	// 2004-11-15 to be removed. test aggregation only
-//	if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)) && (*pNumber < 2))
-//		 return NULL;
+//      if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)) && (*pNumber < 2))
+//               return NULL;
 
 	Number = pAd->TxSwQueue[QID_AC_BK].Number
-			 + pAd->TxSwQueue[QID_AC_BE].Number
-			 + pAd->TxSwQueue[QID_AC_VI].Number
-			 + pAd->TxSwQueue[QID_AC_VO].Number;
+	    + pAd->TxSwQueue[QID_AC_BE].Number
+	    + pAd->TxSwQueue[QID_AC_VI].Number
+	    + pAd->TxSwQueue[QID_AC_VO].Number;
 
-	if (pAd->TxSwQueue[QID_AC_VO].Head != NULL)
-	{
+	if (pAd->TxSwQueue[QID_AC_VO].Head != NULL) {
 		*pQueIdx = QID_AC_VO;
 		return (&pAd->TxSwQueue[QID_AC_VO]);
-	}
-	else if (pAd->TxSwQueue[QID_AC_VI].Head != NULL)
-	{
+	} else if (pAd->TxSwQueue[QID_AC_VI].Head != NULL) {
 		*pQueIdx = QID_AC_VI;
 		return (&pAd->TxSwQueue[QID_AC_VI]);
-	}
-	else if (pAd->TxSwQueue[QID_AC_BE].Head != NULL)
-	{
+	} else if (pAd->TxSwQueue[QID_AC_BE].Head != NULL) {
 		*pQueIdx = QID_AC_BE;
 		return (&pAd->TxSwQueue[QID_AC_BE]);
-	}
-	else if (pAd->TxSwQueue[QID_AC_BK].Head != NULL)
-	{
+	} else if (pAd->TxSwQueue[QID_AC_BK].Head != NULL) {
 		*pQueIdx = QID_AC_BK;
 		return (&pAd->TxSwQueue[QID_AC_BK]);
 	}
-
 	// No packet pending in Tx Sw queue
 	*pQueIdx = QID_AC_BK;
 
 	return (NULL);
 }
 
-
 /*
 	========================================================================
 
@@ -1417,27 +1317,25 @@ PQUEUE_HEADER	RTMPCheckTxSwQueue(
 
 	========================================================================
 */
-VOID	RTMPSuspendMsduTransmission(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPSuspendMsduTransmission(IN PRTMP_ADAPTER pAd)
 {
-	DBGPRINT(RT_DEBUG_TRACE,("SCANNING, suspend MSDU transmission ...\n"));
-
+	DBGPRINT(RT_DEBUG_TRACE, ("SCANNING, suspend MSDU transmission ...\n"));
 
 	//
 	// Before BSS_SCAN_IN_PROGRESS, we need to keep Current R66 value and
 	// use Lowbound as R66 value on ScanNextChannel(...)
 	//
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66, &pAd->BbpTuning.R66CurrentValue);
+	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66,
+				    &pAd->BbpTuning.R66CurrentValue);
 
 	// set BBP_R66 to 0x30/0x40 when scanning (AsicSwitchChannel will set R66 according to channel when scanning)
 	//RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, (0x26 + GET_LNA_GAIN(pAd)));
 	RTMPSetAGCInitValue(pAd, BW_20);
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-	//RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x000f0000);		// abort all TX rings
+	//RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x000f0000);                // abort all TX rings
 }
 
-
 /*
 	========================================================================
 
@@ -1456,70 +1354,61 @@ VOID	RTMPSuspendMsduTransmission(
 
 	========================================================================
 */
-VOID RTMPResumeMsduTransmission(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPResumeMsduTransmission(IN PRTMP_ADAPTER pAd)
 {
-//    UCHAR			IrqState;
-
-	DBGPRINT(RT_DEBUG_TRACE,("SCAN done, resume MSDU transmission ...\n"));
+//    UCHAR                     IrqState;
 
+	DBGPRINT(RT_DEBUG_TRACE, ("SCAN done, resume MSDU transmission ...\n"));
 
 	// After finish BSS_SCAN_IN_PROGRESS, we need to restore Current R66 value
 	// R66 should not be 0
-	if (pAd->BbpTuning.R66CurrentValue == 0)
-	{
+	if (pAd->BbpTuning.R66CurrentValue == 0) {
 		pAd->BbpTuning.R66CurrentValue = 0x38;
 		DBGPRINT_ERR(("RTMPResumeMsduTransmission, R66CurrentValue=0...\n"));
 	}
 
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, pAd->BbpTuning.R66CurrentValue);
+	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66,
+				     pAd->BbpTuning.R66CurrentValue);
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
 // sample, for IRQ LOCK to SEM LOCK
 //    IrqState = pAd->irq_disabled;
-//	if (IrqState)
-//		RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS);
+//      if (IrqState)
+//              RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS);
 //    else
 	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
 }
 
+UINT deaggregate_AMSDU_announce(IN PRTMP_ADAPTER pAd,
+				PNDIS_PACKET pPacket,
+				IN PUCHAR pData, IN ULONG DataSize)
+{
+	USHORT PayloadSize;
+	USHORT SubFrameSize;
+	PHEADER_802_3 pAMSDUsubheader;
+	UINT nMSDU;
+	UCHAR Header802_3[14];
 
-UINT deaggregate_AMSDU_announce(
-	IN	PRTMP_ADAPTER	pAd,
-	PNDIS_PACKET		pPacket,
-	IN	PUCHAR			pData,
-	IN	ULONG			DataSize)
-{
-	USHORT 			PayloadSize;
-	USHORT 			SubFrameSize;
-	PHEADER_802_3 	pAMSDUsubheader;
-	UINT			nMSDU;
-    UCHAR			Header802_3[14];
-
-	PUCHAR			pPayload, pDA, pSA, pRemovedLLCSNAP;
-	PNDIS_PACKET	pClonePacket;
-
-
+	PUCHAR pPayload, pDA, pSA, pRemovedLLCSNAP;
+	PNDIS_PACKET pClonePacket;
 
 	nMSDU = 0;
 
-	while (DataSize > LENGTH_802_3)
-	{
+	while (DataSize > LENGTH_802_3) {
 
 		nMSDU++;
 
 		//hex_dump("subheader", pData, 64);
-		pAMSDUsubheader = (PHEADER_802_3)pData;
+		pAMSDUsubheader = (PHEADER_802_3) pData;
 		//pData += LENGTH_802_3;
-		PayloadSize = pAMSDUsubheader->Octet[1] + (pAMSDUsubheader->Octet[0]<<8);
+		PayloadSize =
+		    pAMSDUsubheader->Octet[1] +
+		    (pAMSDUsubheader->Octet[0] << 8);
 		SubFrameSize = PayloadSize + LENGTH_802_3;
 
-
-		if ((DataSize < SubFrameSize) || (PayloadSize > 1518 ))
-		{
+		if ((DataSize < SubFrameSize) || (PayloadSize > 1518)) {
 			break;
 		}
-
 		//DBGPRINT(RT_DEBUG_TRACE,("%d subframe: Size = %d\n",  nMSDU, PayloadSize));
 
 		pPayload = pData + LENGTH_802_3;
@@ -1527,55 +1416,58 @@ UINT deaggregate_AMSDU_announce(
 		pSA = pData + MAC_ADDR_LEN;
 
 		// convert to 802.3 header
-        CONVERT_TO_802_3(Header802_3, pDA, pSA, pPayload, PayloadSize, pRemovedLLCSNAP);
+		CONVERT_TO_802_3(Header802_3, pDA, pSA, pPayload, PayloadSize,
+				 pRemovedLLCSNAP);
 
-		if ((Header802_3[12] == 0x88) && (Header802_3[13] == 0x8E) )
-		{
+		if ((Header802_3[12] == 0x88) && (Header802_3[13] == 0x8E)) {
 			/* avoid local heap overflow, use dyanamic allocation */
-		   MLME_QUEUE_ELEM *Elem = (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM), MEM_ALLOC_FLAG);
-			if (Elem != NULL)
-			{
-		   memmove(Elem->Msg+(LENGTH_802_11 + LENGTH_802_1_H), pPayload, PayloadSize);
-		   Elem->MsgLen = LENGTH_802_11 + LENGTH_802_1_H + PayloadSize;
+			MLME_QUEUE_ELEM *Elem =
+			    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
+							MEM_ALLOC_FLAG);
+			if (Elem != NULL) {
+				memmove(Elem->Msg +
+					(LENGTH_802_11 + LENGTH_802_1_H),
+					pPayload, PayloadSize);
+				Elem->MsgLen =
+				    LENGTH_802_11 + LENGTH_802_1_H +
+				    PayloadSize;
 				//WpaEAPOLKeyAction(pAd, Elem);
-				REPORT_MGMT_FRAME_TO_MLME(pAd, BSSID_WCID, Elem->Msg, Elem->MsgLen, 0, 0, 0, 0);
-		   kfree(Elem);
-		}
+				REPORT_MGMT_FRAME_TO_MLME(pAd, BSSID_WCID,
+							  Elem->Msg,
+							  Elem->MsgLen, 0, 0, 0,
+							  0);
+				kfree(Elem);
+			}
 		}
 
 		{
-	        	if (pRemovedLLCSNAP)
-	        	{
-	    			pPayload -= LENGTH_802_3;
-	    			PayloadSize += LENGTH_802_3;
-	    			NdisMoveMemory(pPayload, &Header802_3[0], LENGTH_802_3);
-	        	}
+			if (pRemovedLLCSNAP) {
+				pPayload -= LENGTH_802_3;
+				PayloadSize += LENGTH_802_3;
+				NdisMoveMemory(pPayload, &Header802_3[0],
+					       LENGTH_802_3);
+			}
 		}
 
 		pClonePacket = ClonePacket(pAd, pPacket, pPayload, PayloadSize);
-		if (pClonePacket)
-		{
-			ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pClonePacket, RTMP_GET_PACKET_IF(pPacket));
+		if (pClonePacket) {
+			ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pClonePacket,
+							 RTMP_GET_PACKET_IF
+							 (pPacket));
 		}
 
-
 		// A-MSDU has padding to multiple of 4 including subframe header.
 		// align SubFrameSize up to multiple of 4
-		SubFrameSize = (SubFrameSize+3)&(~0x3);
+		SubFrameSize = (SubFrameSize + 3) & (~0x3);
 
-
-		if (SubFrameSize > 1528 || SubFrameSize < 32)
-		{
+		if (SubFrameSize > 1528 || SubFrameSize < 32) {
 			break;
 		}
 
-		if (DataSize > SubFrameSize)
-		{
+		if (DataSize > SubFrameSize) {
 			pData += SubFrameSize;
 			DataSize -= SubFrameSize;
-		}
-		else
-		{
+		} else {
 			// end of A-MSDU
 			DataSize = 0;
 		}
@@ -1587,14 +1479,11 @@ UINT deaggregate_AMSDU_announce(
 	return nMSDU;
 }
 
-
-UINT BA_Reorder_AMSDU_Annnounce(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket)
-{
-	PUCHAR			pData;
-	USHORT			DataSize;
-	UINT			nMSDU = 0;
+UINT BA_Reorder_AMSDU_Annnounce(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
+{
+	PUCHAR pData;
+	USHORT DataSize;
+	UINT nMSDU = 0;
 
 	pData = (PUCHAR) GET_OS_PKT_DATAPTR(pPacket);
 	DataSize = (USHORT) GET_OS_PKT_LEN(pPacket);
@@ -1604,7 +1493,6 @@ UINT BA_Reorder_AMSDU_Annnounce(
 	return nMSDU;
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1613,9 +1501,7 @@ UINT BA_Reorder_AMSDU_Annnounce(
 		pEntry - pointer to the MAC entry; NULL is not found
 	==========================================================================
 */
-MAC_TABLE_ENTRY *MacTableLookup(
-	IN PRTMP_ADAPTER pAd,
-	PUCHAR pAddr)
+MAC_TABLE_ENTRY *MacTableLookup(IN PRTMP_ADAPTER pAd, PUCHAR pAddr)
 {
 	ULONG HashIdx;
 	MAC_TABLE_ENTRY *pEntry = NULL;
@@ -1623,30 +1509,27 @@ MAC_TABLE_ENTRY *MacTableLookup(
 	HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
 	pEntry = pAd->MacTab.Hash[HashIdx];
 
-	while (pEntry && (pEntry->ValidAsCLI || pEntry->ValidAsWDS || pEntry->ValidAsApCli || pEntry->ValidAsMesh))
-	{
-		if (MAC_ADDR_EQUAL(pEntry->Addr, pAddr))
-		{
+	while (pEntry
+	       && (pEntry->ValidAsCLI || pEntry->ValidAsWDS
+		   || pEntry->ValidAsApCli || pEntry->ValidAsMesh)) {
+		if (MAC_ADDR_EQUAL(pEntry->Addr, pAddr)) {
 			break;
-		}
-		else
+		} else
 			pEntry = pEntry->pNext;
 	}
 
 	return pEntry;
 }
 
-MAC_TABLE_ENTRY *MacTableInsertEntry(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR			pAddr,
-	IN	UCHAR			apidx,
-	IN BOOLEAN	CleanAll)
+MAC_TABLE_ENTRY *MacTableInsertEntry(IN PRTMP_ADAPTER pAd,
+				     IN PUCHAR pAddr,
+				     IN UCHAR apidx, IN BOOLEAN CleanAll)
 {
 	UCHAR HashIdx;
 	int i, FirstWcid;
 	MAC_TABLE_ENTRY *pEntry = NULL, *pCurrEntry;
-//	USHORT	offset;
-//	ULONG	addr;
+//      USHORT  offset;
+//      ULONG   addr;
 
 	// if FULL, return
 	if (pAd->MacTab.Size >= MAX_LEN_OF_MAC_TABLE)
@@ -1659,18 +1542,16 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(
 
 	// allocate one MAC entry
 	NdisAcquireSpinLock(&pAd->MacTabLock);
-	for (i = FirstWcid; i< MAX_LEN_OF_MAC_TABLE; i++)   // skip entry#0 so that "entry index == AID" for fast lookup
+	for (i = FirstWcid; i < MAX_LEN_OF_MAC_TABLE; i++)	// skip entry#0 so that "entry index == AID" for fast lookup
 	{
 		// pick up the first available vacancy
 		if ((pAd->MacTab.Content[i].ValidAsCLI == FALSE) &&
-			(pAd->MacTab.Content[i].ValidAsWDS == FALSE) &&
-			(pAd->MacTab.Content[i].ValidAsApCli== FALSE) &&
-			(pAd->MacTab.Content[i].ValidAsMesh == FALSE)
-			)
-		{
+		    (pAd->MacTab.Content[i].ValidAsWDS == FALSE) &&
+		    (pAd->MacTab.Content[i].ValidAsApCli == FALSE) &&
+		    (pAd->MacTab.Content[i].ValidAsMesh == FALSE)
+		    ) {
 			pEntry = &pAd->MacTab.Content[i];
-			if (CleanAll == TRUE)
-			{
+			if (CleanAll == TRUE) {
 				pEntry->MaxSupportedRate = RATE_11;
 				pEntry->CurrTxRate = RATE_11;
 				NdisZeroMemory(pEntry, sizeof(MAC_TABLE_ENTRY));
@@ -1690,27 +1571,37 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(
 			pEntry->bIAmBadAtheros = FALSE;
 			pEntry->pAd = pAd;
 			pEntry->CMTimerRunning = FALSE;
-			pEntry->EnqueueEapolStartTimerRunning = EAPOL_START_DISABLE;
+			pEntry->EnqueueEapolStartTimerRunning =
+			    EAPOL_START_DISABLE;
 			pEntry->RSNIE_Len = 0;
-			NdisZeroMemory(pEntry->R_Counter, sizeof(pEntry->R_Counter));
+			NdisZeroMemory(pEntry->R_Counter,
+				       sizeof(pEntry->R_Counter));
 			pEntry->ReTryCounter = PEER_MSG1_RETRY_TIMER_CTR;
 
 			if (pEntry->ValidAsMesh)
-				pEntry->apidx = (apidx - MIN_NET_DEVICE_FOR_MESH);
+				pEntry->apidx =
+				    (apidx - MIN_NET_DEVICE_FOR_MESH);
 			else if (pEntry->ValidAsApCli)
-				pEntry->apidx = (apidx - MIN_NET_DEVICE_FOR_APCLI);
+				pEntry->apidx =
+				    (apidx - MIN_NET_DEVICE_FOR_APCLI);
 			else if (pEntry->ValidAsWDS)
-				pEntry->apidx = (apidx - MIN_NET_DEVICE_FOR_WDS);
+				pEntry->apidx =
+				    (apidx - MIN_NET_DEVICE_FOR_WDS);
 			else
 				pEntry->apidx = apidx;
 
 			{
 				{
 					pEntry->AuthMode = pAd->StaCfg.AuthMode;
-					pEntry->WepStatus = pAd->StaCfg.WepStatus;
-					pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
+					pEntry->WepStatus =
+					    pAd->StaCfg.WepStatus;
+					pEntry->PrivacyFilter =
+					    Ndis802_11PrivFilterAcceptAll;
 #ifdef RTMP_MAC_PCI
-					AsicRemovePairwiseKeyEntry(pAd, pEntry->apidx, (UCHAR)i);
+					AsicRemovePairwiseKeyEntry(pAd,
+								   pEntry->
+								   apidx,
+								   (UCHAR) i);
 #endif // RTMP_MAC_PCI //
 				}
 			}
@@ -1724,7 +1615,7 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(
 			COPY_MAC_ADDR(pEntry->Addr, pAddr);
 			pEntry->Sst = SST_NOT_AUTH;
 			pEntry->AuthState = AS_NOT_AUTH;
-			pEntry->Aid = (USHORT)i;  //0;
+			pEntry->Aid = (USHORT) i;	//0;
 			pEntry->CapabilityInfo = 0;
 			pEntry->PsMode = PWR_ACTIVE;
 			pEntry->PsQIdleCount = 0;
@@ -1733,28 +1624,23 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(
 			pEntry->ContinueTxFailCnt = 0;
 			InitializeQueueHeader(&pEntry->PsQueue);
 
-
-			pAd->MacTab.Size ++;
+			pAd->MacTab.Size++;
 			// Add this entry into ASIC RX WCID search table
 			RTMP_STA_ENTRY_ADD(pAd, pEntry);
 
-
-
-			DBGPRINT(RT_DEBUG_TRACE, ("MacTableInsertEntry - allocate entry #%d, Total= %d\n",i, pAd->MacTab.Size));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MacTableInsertEntry - allocate entry #%d, Total= %d\n",
+				  i, pAd->MacTab.Size));
 			break;
 		}
 	}
 
 	// add this MAC entry into HASH table
-	if (pEntry)
-	{
+	if (pEntry) {
 		HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
-		if (pAd->MacTab.Hash[HashIdx] == NULL)
-		{
+		if (pAd->MacTab.Hash[HashIdx] == NULL) {
 			pAd->MacTab.Hash[HashIdx] = pEntry;
-		}
-		else
-		{
+		} else {
 			pCurrEntry = pAd->MacTab.Hash[HashIdx];
 			while (pCurrEntry->pNext != NULL)
 				pCurrEntry = pCurrEntry->pNext;
@@ -1772,16 +1658,14 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(
 		Delete a specified client from MAC table
 	==========================================================================
  */
-BOOLEAN MacTableDeleteEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT wcid,
-	IN PUCHAR pAddr)
+BOOLEAN MacTableDeleteEntry(IN PRTMP_ADAPTER pAd,
+			    IN USHORT wcid, IN PUCHAR pAddr)
 {
 	USHORT HashIdx;
 	MAC_TABLE_ENTRY *pEntry, *pPrevEntry, *pProbeEntry;
 	BOOLEAN Cancelled;
-	//USHORT	offset;	// unused variable
-	//UCHAR	j;			// unused variable
+	//USHORT        offset; // unused variable
+	//UCHAR j;                      // unused variable
 
 	if (wcid >= MAX_LEN_OF_MAC_TABLE)
 		return FALSE;
@@ -1792,11 +1676,10 @@ BOOLEAN MacTableDeleteEntry(
 	//pEntry = pAd->MacTab.Hash[HashIdx];
 	pEntry = &pAd->MacTab.Content[wcid];
 
-	if (pEntry && (pEntry->ValidAsCLI || pEntry->ValidAsApCli || pEntry->ValidAsWDS || pEntry->ValidAsMesh
-		))
-	{
-		if (MAC_ADDR_EQUAL(pEntry->Addr, pAddr))
-		{
+	if (pEntry
+	    && (pEntry->ValidAsCLI || pEntry->ValidAsApCli || pEntry->ValidAsWDS
+		|| pEntry->ValidAsMesh)) {
+		if (MAC_ADDR_EQUAL(pEntry->Addr, pAddr)) {
 
 			// Delete this entry from ASIC on-chip WCID Table
 			RTMP_STA_ENTRY_MAC_RESET(pAd, wcid);
@@ -1809,17 +1692,14 @@ BOOLEAN MacTableDeleteEntry(
 			ASSERT(pProbeEntry);
 
 			// update Hash list
-			do
-			{
-				if (pProbeEntry == pEntry)
-				{
-					if (pPrevEntry == NULL)
-					{
-						pAd->MacTab.Hash[HashIdx] = pEntry->pNext;
-					}
-					else
-					{
-						pPrevEntry->pNext = pEntry->pNext;
+			do {
+				if (pProbeEntry == pEntry) {
+					if (pPrevEntry == NULL) {
+						pAd->MacTab.Hash[HashIdx] =
+						    pEntry->pNext;
+					} else {
+						pPrevEntry->pNext =
+						    pEntry->pNext;
 					}
 					break;
 				}
@@ -1833,38 +1713,39 @@ BOOLEAN MacTableDeleteEntry(
 
 			RTMP_STA_ENTRY_KEY_DEL(pAd, BSS0, wcid);
 
-
-		if (pEntry->EnqueueEapolStartTimerRunning != EAPOL_START_DISABLE)
-		{
-			RTMPCancelTimer(&pEntry->EnqueueStartForPSKTimer, &Cancelled);
-			pEntry->EnqueueEapolStartTimerRunning = EAPOL_START_DISABLE;
-		}
-
-
-   			NdisZeroMemory(pEntry, sizeof(MAC_TABLE_ENTRY));
-			pAd->MacTab.Size --;
-			DBGPRINT(RT_DEBUG_TRACE, ("MacTableDeleteEntry1 - Total= %d\n", pAd->MacTab.Size));
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_OFF, ("\n%s: Impossible Wcid = %d !!!!!\n", __func__, wcid));
+			if (pEntry->EnqueueEapolStartTimerRunning !=
+			    EAPOL_START_DISABLE) {
+				RTMPCancelTimer(&pEntry->
+						EnqueueStartForPSKTimer,
+						&Cancelled);
+				pEntry->EnqueueEapolStartTimerRunning =
+				    EAPOL_START_DISABLE;
+			}
+
+			NdisZeroMemory(pEntry, sizeof(MAC_TABLE_ENTRY));
+			pAd->MacTab.Size--;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MacTableDeleteEntry1 - Total= %d\n",
+				  pAd->MacTab.Size));
+		} else {
+			DBGPRINT(RT_DEBUG_OFF,
+				 ("\n%s: Impossible Wcid = %d !!!!!\n",
+				  __func__, wcid));
 		}
 	}
 
 	NdisReleaseSpinLock(&pAd->MacTabLock);
 
 	//Reset operating mode when no Sta.
-	if (pAd->MacTab.Size == 0)
-	{
+	if (pAd->MacTab.Size == 0) {
 		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 0;
 		//AsicUpdateProtect(pAd, 0 /*pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode*/, (ALLN_SETPROTECT), TRUE, 0 /*pAd->MacTab.fAnyStationNonGF*/);
-		RTMP_UPDATE_PROTECT(pAd);  // edit by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet
+		RTMP_UPDATE_PROTECT(pAd);	// edit by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet
 	}
 
 	return TRUE;
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1872,23 +1753,18 @@ BOOLEAN MacTableDeleteEntry(
 		the power-saving queues are freed here.
 	==========================================================================
  */
-VOID MacTableReset(
-	IN  PRTMP_ADAPTER  pAd)
+VOID MacTableReset(IN PRTMP_ADAPTER pAd)
 {
-	int         i;
+	int i;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("MacTableReset\n"));
 	//NdisAcquireSpinLock(&pAd->MacTabLock);
 
-
-	for (i=1; i<MAX_LEN_OF_MAC_TABLE; i++)
-	{
+	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
 #ifdef RTMP_MAC_PCI
 		RTMP_STA_ENTRY_MAC_RESET(pAd, i);
 #endif // RTMP_MAC_PCI //
-		if (pAd->MacTab.Content[i].ValidAsCLI == TRUE)
-	   {
-
+		if (pAd->MacTab.Content[i].ValidAsCLI == TRUE) {
 
 			// free resources of BA
 			BASessionTearDownALL(pAd, i);
@@ -1915,22 +1791,19 @@ VOID MacTableReset(
 
 	==========================================================================
 */
-VOID AssocParmFill(
-	IN PRTMP_ADAPTER pAd,
-	IN OUT MLME_ASSOC_REQ_STRUCT *AssocReq,
-	IN PUCHAR                     pAddr,
-	IN USHORT                     CapabilityInfo,
-	IN ULONG                      Timeout,
-	IN USHORT                     ListenIntv)
+VOID AssocParmFill(IN PRTMP_ADAPTER pAd,
+		   IN OUT MLME_ASSOC_REQ_STRUCT * AssocReq,
+		   IN PUCHAR pAddr,
+		   IN USHORT CapabilityInfo,
+		   IN ULONG Timeout, IN USHORT ListenIntv)
 {
 	COPY_MAC_ADDR(AssocReq->Addr, pAddr);
 	// Add mask to support 802.11b mode only
-	AssocReq->CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO; // not cf-pollable, not cf-poll-request
+	AssocReq->CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;	// not cf-pollable, not cf-poll-request
 	AssocReq->Timeout = Timeout;
 	AssocReq->ListenIntv = ListenIntv;
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1939,17 +1812,14 @@ VOID AssocParmFill(
 
 	==========================================================================
 */
-VOID DisassocParmFill(
-	IN PRTMP_ADAPTER pAd,
-	IN OUT MLME_DISASSOC_REQ_STRUCT *DisassocReq,
-	IN PUCHAR pAddr,
-	IN USHORT Reason)
+VOID DisassocParmFill(IN PRTMP_ADAPTER pAd,
+		      IN OUT MLME_DISASSOC_REQ_STRUCT * DisassocReq,
+		      IN PUCHAR pAddr, IN USHORT Reason)
 {
 	COPY_MAC_ADDR(DisassocReq->Addr, pAddr);
 	DisassocReq->Reason = Reason;
 }
 
-
 /*
 	========================================================================
 
@@ -1984,22 +1854,21 @@ VOID DisassocParmFill(
 	========================================================================
 */
 
-BOOLEAN RTMPCheckDHCPFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket)
-{
-	PACKET_INFO 	PacketInfo;
-	ULONG			NumberOfBytesRead = 0;
-	ULONG			CurrentOffset = 0;
-	PVOID			pVirtualAddress = NULL;
-	UINT			NdisBufferLength;
-	PUCHAR			pSrc;
-	USHORT			Protocol;
-	UCHAR			ByteOffset36 = 0;
-	UCHAR			ByteOffset38 = 0;
-	BOOLEAN 		ReadFirstParm = TRUE;
+BOOLEAN RTMPCheckDHCPFrame(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
+{
+	PACKET_INFO PacketInfo;
+	ULONG NumberOfBytesRead = 0;
+	ULONG CurrentOffset = 0;
+	PVOID pVirtualAddress = NULL;
+	UINT NdisBufferLength;
+	PUCHAR pSrc;
+	USHORT Protocol;
+	UCHAR ByteOffset36 = 0;
+	UCHAR ByteOffset38 = 0;
+	BOOLEAN ReadFirstParm = TRUE;
 
-	RTMP_QueryPacketInfo(pPacket, &PacketInfo, (PUCHAR *)&pVirtualAddress, &NdisBufferLength);
+	RTMP_QueryPacketInfo(pPacket, &PacketInfo, (PUCHAR *) & pVirtualAddress,
+			     &NdisBufferLength);
 
 	NumberOfBytesRead += NdisBufferLength;
 	pSrc = (PUCHAR) pVirtualAddress;
@@ -2008,18 +1877,17 @@ BOOLEAN RTMPCheckDHCPFrame(
 	//
 	// Check DHCP & BOOTP protocol
 	//
-	while (NumberOfBytesRead <= PacketInfo.TotalPacketLength)
-	{
-		if ((NumberOfBytesRead >= 35) && (ReadFirstParm == TRUE))
-		{
-			CurrentOffset = 35 - (NumberOfBytesRead - NdisBufferLength);
+	while (NumberOfBytesRead <= PacketInfo.TotalPacketLength) {
+		if ((NumberOfBytesRead >= 35) && (ReadFirstParm == TRUE)) {
+			CurrentOffset =
+			    35 - (NumberOfBytesRead - NdisBufferLength);
 			ByteOffset36 = *(pSrc + CurrentOffset);
 			ReadFirstParm = FALSE;
 		}
 
-		if (NumberOfBytesRead >= 37)
-		{
-			CurrentOffset = 37 - (NumberOfBytesRead - NdisBufferLength);
+		if (NumberOfBytesRead >= 37) {
+			CurrentOffset =
+			    37 - (NumberOfBytesRead - NdisBufferLength);
 			ByteOffset38 = *(pSrc + CurrentOffset);
 			//End of Read
 			break;
@@ -2028,32 +1896,27 @@ BOOLEAN RTMPCheckDHCPFrame(
 	}
 
 	// Check for DHCP & BOOTP protocol
-	if ((ByteOffset36 != 0x44) || (ByteOffset38 != 0x43))
-		{
+	if ((ByteOffset36 != 0x44) || (ByteOffset38 != 0x43)) {
 		//
 		// 2054 (hex 0806) for ARP datagrams
 		// if this packet is not ARP datagrams, then do nothing
 		// ARP datagrams will also be duplicate at 1mb broadcast frames
 		//
-		if (Protocol != 0x0806 )
+		if (Protocol != 0x0806)
 			return FALSE;
-		}
+	}
 
 	return TRUE;
 }
 
-
-BOOLEAN RTMPCheckEtherType(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket)
-{
-	USHORT	TypeLen;
-	UCHAR	Byte0, Byte1;
-	PUCHAR	pSrcBuf;
-	UINT32	pktLen;
-	UINT16 	srcPort, dstPort;
-	BOOLEAN	status = TRUE;
-
+BOOLEAN RTMPCheckEtherType(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
+{
+	USHORT TypeLen;
+	UCHAR Byte0, Byte1;
+	PUCHAR pSrcBuf;
+	UINT32 pktLen;
+	UINT16 srcPort, dstPort;
+	BOOLEAN status = TRUE;
 
 	pSrcBuf = GET_OS_PKT_DATAPTR(pPacket);
 	pktLen = GET_OS_PKT_LEN(pPacket);
@@ -2067,30 +1930,26 @@ BOOLEAN RTMPCheckEtherType(
 
 	pSrcBuf += LENGTH_802_3;	// Skip the Ethernet Header.
 
-	if (TypeLen <= 1500)
-	{	// 802.3, 802.3 LLC
+	if (TypeLen <= 1500) {	// 802.3, 802.3 LLC
 		/*
-			DestMAC(6) + SrcMAC(6) + Lenght(2) +
-			DSAP(1) + SSAP(1) + Control(1) +
-			if the DSAP = 0xAA, SSAP=0xAA, Contorl = 0x03, it has a 5-bytes SNAP header.
-				=> + SNAP (5, OriginationID(3) + etherType(2))
-		*/
-		if (pSrcBuf[0] == 0xAA && pSrcBuf[1] == 0xAA && pSrcBuf[2] == 0x03)
-		{
-			Sniff2BytesFromNdisBuffer((PNDIS_BUFFER)pSrcBuf, 6, &Byte0, &Byte1);
+		   DestMAC(6) + SrcMAC(6) + Lenght(2) +
+		   DSAP(1) + SSAP(1) + Control(1) +
+		   if the DSAP = 0xAA, SSAP=0xAA, Contorl = 0x03, it has a 5-bytes SNAP header.
+		   => + SNAP (5, OriginationID(3) + etherType(2))
+		 */
+		if (pSrcBuf[0] == 0xAA && pSrcBuf[1] == 0xAA
+		    && pSrcBuf[2] == 0x03) {
+			Sniff2BytesFromNdisBuffer((PNDIS_BUFFER) pSrcBuf, 6,
+						  &Byte0, &Byte1);
 			RTMP_SET_PACKET_LLCSNAP(pPacket, 1);
-			TypeLen = (USHORT)((Byte0 << 8) + Byte1);
-			pSrcBuf += 8; // Skip this LLC/SNAP header
-		}
-		else
-		{
+			TypeLen = (USHORT) ((Byte0 << 8) + Byte1);
+			pSrcBuf += 8;	// Skip this LLC/SNAP header
+		} else {
 			//It just has 3-byte LLC header, maybe a legacy ether type frame. we didn't handle it.
 		}
 	}
-
 	// If it's a VLAN packet, get the real Type/Length field.
-	if (TypeLen == 0x8100)
-	{
+	if (TypeLen == 0x8100) {
 		/* 0x8100 means VLAN packets */
 
 		/* Dest. MAC Address (6-bytes) +
@@ -2103,141 +1962,141 @@ BOOLEAN RTMPCheckEtherType(
 		   Frame Check Sequence (4-bytes) */
 
 		RTMP_SET_PACKET_VLAN(pPacket, 1);
-		Sniff2BytesFromNdisBuffer((PNDIS_BUFFER)pSrcBuf, 2, &Byte0, &Byte1);
-		TypeLen = (USHORT)((Byte0 << 8) + Byte1);
+		Sniff2BytesFromNdisBuffer((PNDIS_BUFFER) pSrcBuf, 2, &Byte0,
+					  &Byte1);
+		TypeLen = (USHORT) ((Byte0 << 8) + Byte1);
+
+		pSrcBuf += 4;	// Skip the VLAN Header.
+	}
+
+	switch (TypeLen) {
+	case 0x0800:
+		{
+			ASSERT((pktLen > 34));
+			if (*(pSrcBuf + 9) == 0x11) {	// udp packet
+				ASSERT((pktLen > 34));	// 14 for ethernet header, 20 for IP header
+
+				pSrcBuf += 20;	// Skip the IP header
+				srcPort =
+				    OS_NTOHS(get_unaligned
+					     ((PUINT16) (pSrcBuf)));
+				dstPort =
+				    OS_NTOHS(get_unaligned
+					     ((PUINT16) (pSrcBuf + 2)));
 
-		pSrcBuf += 4; // Skip the VLAN Header.
-	}
-
-	switch (TypeLen)
-	{
-		case 0x0800:
-			{
-				ASSERT((pktLen > 34));
-				if (*(pSrcBuf + 9) == 0x11)
-				{	// udp packet
-					ASSERT((pktLen > 34));	// 14 for ethernet header, 20 for IP header
-
-					pSrcBuf += 20;	// Skip the IP header
-					srcPort = OS_NTOHS(get_unaligned((PUINT16)(pSrcBuf)));
-					dstPort = OS_NTOHS(get_unaligned((PUINT16)(pSrcBuf+2)));
-
-					if ((srcPort==0x44 && dstPort==0x43) || (srcPort==0x43 && dstPort==0x44))
-					{	//It's a BOOTP/DHCP packet
-						RTMP_SET_PACKET_DHCP(pPacket, 1);
-					}
+				if ((srcPort == 0x44 && dstPort == 0x43) || (srcPort == 0x43 && dstPort == 0x44)) {	//It's a BOOTP/DHCP packet
+					RTMP_SET_PACKET_DHCP(pPacket, 1);
 				}
 			}
-			break;
-		case 0x0806:
-			{
-				//ARP Packet.
-				RTMP_SET_PACKET_DHCP(pPacket, 1);
-			}
-			break;
-		case 0x888e:
-			{
-				// EAPOL Packet.
-				RTMP_SET_PACKET_EAPOL(pPacket, 1);
-			}
-			break;
-		default:
-			status = FALSE;
-			break;
+		}
+		break;
+	case 0x0806:
+		{
+			//ARP Packet.
+			RTMP_SET_PACKET_DHCP(pPacket, 1);
+		}
+		break;
+	case 0x888e:
+		{
+			// EAPOL Packet.
+			RTMP_SET_PACKET_EAPOL(pPacket, 1);
+		}
+		break;
+	default:
+		status = FALSE;
+		break;
 	}
 
 	return status;
 
 }
 
-
-
-VOID Update_Rssi_Sample(
-	IN PRTMP_ADAPTER	pAd,
-	IN RSSI_SAMPLE		*pRssi,
-	IN PRXWI_STRUC		pRxWI)
-		{
-	CHAR	rssi0 = pRxWI->RSSI0;
-	CHAR	rssi1 = pRxWI->RSSI1;
-	CHAR	rssi2 = pRxWI->RSSI2;
-
-	if (rssi0 != 0)
-	{
-		pRssi->LastRssi0	= ConvertToRssi(pAd, (CHAR)rssi0, RSSI_0);
-		pRssi->AvgRssi0X8	= (pRssi->AvgRssi0X8 - pRssi->AvgRssi0) + pRssi->LastRssi0;
-		pRssi->AvgRssi0	= pRssi->AvgRssi0X8 >> 3;
-	}
-
-	if (rssi1 != 0)
-	{
-		pRssi->LastRssi1	= ConvertToRssi(pAd, (CHAR)rssi1, RSSI_1);
-		pRssi->AvgRssi1X8	= (pRssi->AvgRssi1X8 - pRssi->AvgRssi1) + pRssi->LastRssi1;
-		pRssi->AvgRssi1	= pRssi->AvgRssi1X8 >> 3;
-	}
-
-	if (rssi2 != 0)
-	{
-		pRssi->LastRssi2	= ConvertToRssi(pAd, (CHAR)rssi2, RSSI_2);
-		pRssi->AvgRssi2X8  = (pRssi->AvgRssi2X8 - pRssi->AvgRssi2) + pRssi->LastRssi2;
+VOID Update_Rssi_Sample(IN PRTMP_ADAPTER pAd,
+			IN RSSI_SAMPLE * pRssi, IN PRXWI_STRUC pRxWI)
+{
+	CHAR rssi0 = pRxWI->RSSI0;
+	CHAR rssi1 = pRxWI->RSSI1;
+	CHAR rssi2 = pRxWI->RSSI2;
+
+	if (rssi0 != 0) {
+		pRssi->LastRssi0 = ConvertToRssi(pAd, (CHAR) rssi0, RSSI_0);
+		pRssi->AvgRssi0X8 =
+		    (pRssi->AvgRssi0X8 - pRssi->AvgRssi0) + pRssi->LastRssi0;
+		pRssi->AvgRssi0 = pRssi->AvgRssi0X8 >> 3;
+	}
+
+	if (rssi1 != 0) {
+		pRssi->LastRssi1 = ConvertToRssi(pAd, (CHAR) rssi1, RSSI_1);
+		pRssi->AvgRssi1X8 =
+		    (pRssi->AvgRssi1X8 - pRssi->AvgRssi1) + pRssi->LastRssi1;
+		pRssi->AvgRssi1 = pRssi->AvgRssi1X8 >> 3;
+	}
+
+	if (rssi2 != 0) {
+		pRssi->LastRssi2 = ConvertToRssi(pAd, (CHAR) rssi2, RSSI_2);
+		pRssi->AvgRssi2X8 =
+		    (pRssi->AvgRssi2X8 - pRssi->AvgRssi2) + pRssi->LastRssi2;
 		pRssi->AvgRssi2 = pRssi->AvgRssi2X8 >> 3;
 	}
 }
 
-
-
 // Normal legacy Rx packet indication
-VOID Indicate_Legacy_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
+VOID Indicate_Legacy_Packet(IN PRTMP_ADAPTER pAd,
+			    IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
-	PNDIS_PACKET	pRxPacket = pRxBlk->pRxPacket;
-	UCHAR			Header802_3[LENGTH_802_3];
+	PNDIS_PACKET pRxPacket = pRxBlk->pRxPacket;
+	UCHAR Header802_3[LENGTH_802_3];
 
 	// 1. get 802.3 Header
 	// 2. remove LLC
-	// 		a. pointer pRxBlk->pData to payload
+	//              a. pointer pRxBlk->pData to payload
 	//      b. modify pRxBlk->DataSize
 	RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(pRxBlk, Header802_3);
 
-	if (pRxBlk->DataSize > MAX_RX_PKT_LEN)
-	{
+	if (pRxBlk->DataSize > MAX_RX_PKT_LEN) {
 
 		// release packet
 		RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
 		return;
 	}
 
-
 	STATS_INC_RX_PACKETS(pAd, FromWhichBSSID);
 
 #ifdef RTMP_MAC_USB
-	if (pAd->CommonCfg.bDisableReordering == 0)
-	{
-		PBA_REC_ENTRY		pBAEntry;
-		ULONG				Now32;
-		UCHAR				Wcid = pRxBlk->pRxWI->WirelessCliID;
-		UCHAR				TID = pRxBlk->pRxWI->TID;
-		USHORT				Idx;
+	if (pAd->CommonCfg.bDisableReordering == 0) {
+		PBA_REC_ENTRY pBAEntry;
+		ULONG Now32;
+		UCHAR Wcid = pRxBlk->pRxWI->WirelessCliID;
+		UCHAR TID = pRxBlk->pRxWI->TID;
+		USHORT Idx;
 
 #define REORDERING_PACKET_TIMEOUT		((100 * OS_HZ)/1000)	// system ticks -- 100 ms
 
-		if (Wcid < MAX_LEN_OF_MAC_TABLE)
-		{
+		if (Wcid < MAX_LEN_OF_MAC_TABLE) {
 			Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
-			if (Idx != 0)
-			{
+			if (Idx != 0) {
 				pBAEntry = &pAd->BATable.BARecEntry[Idx];
 				// update last rx time
 				NdisGetSystemUpTime(&Now32);
 				if ((pBAEntry->list.qlen > 0) &&
-					 RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(REORDERING_PACKET_TIMEOUT)))
-	   				)
-				{
-					DBGPRINT(RT_DEBUG_OFF, ("Indicate_Legacy_Packet():flush reordering_timeout_mpdus! RxWI->Flags=%d, pRxWI.TID=%d, RxD->AMPDU=%d!\n",
-												pRxBlk->Flags, pRxBlk->pRxWI->TID, pRxBlk->RxD.AMPDU));
-					hex_dump("Dump the legacy Packet:", GET_OS_PKT_DATAPTR(pRxBlk->pRxPacket), 64);
-					ba_flush_reordering_timeout_mpdus(pAd, pBAEntry, Now32);
+				    RTMP_TIME_AFTER((unsigned long)Now32,
+						    (unsigned long)(pBAEntry->
+								    LastIndSeqAtTimer
+								    +
+								    (REORDERING_PACKET_TIMEOUT)))
+				    ) {
+					DBGPRINT(RT_DEBUG_OFF,
+						 ("Indicate_Legacy_Packet():flush reordering_timeout_mpdus! RxWI->Flags=%d, pRxWI.TID=%d, RxD->AMPDU=%d!\n",
+						  pRxBlk->Flags,
+						  pRxBlk->pRxWI->TID,
+						  pRxBlk->RxD.AMPDU));
+					hex_dump("Dump the legacy Packet:",
+						 GET_OS_PKT_DATAPTR(pRxBlk->
+								    pRxPacket),
+						 64);
+					ba_flush_reordering_timeout_mpdus(pAd,
+									  pBAEntry,
+									  Now32);
 				}
 			}
 		}
@@ -2252,58 +2111,43 @@ VOID Indicate_Legacy_Packet(
 	ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pRxPacket, FromWhichBSSID);
 }
 
-
 // Normal, AMPDU or AMSDU
-VOID CmmRxnonRalinkFrameIndicate(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
+VOID CmmRxnonRalinkFrameIndicate(IN PRTMP_ADAPTER pAd,
+				 IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
-	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU) && (pAd->CommonCfg.bDisableReordering == 0))
-	{
+	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU)
+	    && (pAd->CommonCfg.bDisableReordering == 0)) {
 		Indicate_AMPDU_Packet(pAd, pRxBlk, FromWhichBSSID);
-	}
-	else
-	{
-		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU))
-		{
+	} else {
+		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)) {
 			// handle A-MSDU
 			Indicate_AMSDU_Packet(pAd, pRxBlk, FromWhichBSSID);
-		}
-		else
-		{
+		} else {
 			Indicate_Legacy_Packet(pAd, pRxBlk, FromWhichBSSID);
 		}
 	}
 }
 
+VOID CmmRxRalinkFrameIndicate(IN PRTMP_ADAPTER pAd,
+			      IN MAC_TABLE_ENTRY * pEntry,
+			      IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
+{
+	UCHAR Header802_3[LENGTH_802_3];
+	UINT16 Msdu2Size;
+	UINT16 Payload1Size, Payload2Size;
+	PUCHAR pData2;
+	PNDIS_PACKET pPacket2 = NULL;
 
-VOID CmmRxRalinkFrameIndicate(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	MAC_TABLE_ENTRY	*pEntry,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
-{
-	UCHAR			Header802_3[LENGTH_802_3];
-	UINT16			Msdu2Size;
-	UINT16 			Payload1Size, Payload2Size;
-	PUCHAR 			pData2;
-	PNDIS_PACKET	pPacket2 = NULL;
-
-
+	Msdu2Size = *(pRxBlk->pData) + (*(pRxBlk->pData + 1) << 8);
 
-	Msdu2Size = *(pRxBlk->pData) + (*(pRxBlk->pData+1) << 8);
-
-	if ((Msdu2Size <= 1536) && (Msdu2Size < pRxBlk->DataSize))
-	{
+	if ((Msdu2Size <= 1536) && (Msdu2Size < pRxBlk->DataSize)) {
 		/* skip two byte MSDU2 len */
 		pRxBlk->pData += 2;
 		pRxBlk->DataSize -= 2;
-	}
-	else
-	{
+	} else {
 		// release packet
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+				    NDIS_STATUS_FAILURE);
 		return;
 	}
 
@@ -2313,34 +2157,34 @@ VOID CmmRxRalinkFrameIndicate(
 	ASSERT(pRxBlk->pRxPacket);
 
 	// Ralink Aggregation frame
-	pAd->RalinkCounters.OneSecRxAggregationCount ++;
+	pAd->RalinkCounters.OneSecRxAggregationCount++;
 	Payload1Size = pRxBlk->DataSize - Msdu2Size;
 	Payload2Size = Msdu2Size - LENGTH_802_3;
 
 	pData2 = pRxBlk->pData + Payload1Size + LENGTH_802_3;
 
-	pPacket2 = duplicate_pkt(pAd, (pData2-LENGTH_802_3), LENGTH_802_3, pData2, Payload2Size, FromWhichBSSID);
+	pPacket2 =
+	    duplicate_pkt(pAd, (pData2 - LENGTH_802_3), LENGTH_802_3, pData2,
+			  Payload2Size, FromWhichBSSID);
 
-	if (!pPacket2)
-	{
+	if (!pPacket2) {
 		// release packet
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+				    NDIS_STATUS_FAILURE);
 		return;
 	}
-
 	// update payload size of 1st packet
 	pRxBlk->DataSize = Payload1Size;
 	wlan_802_11_to_802_3_packet(pAd, pRxBlk, Header802_3, FromWhichBSSID);
 
-	ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pRxBlk->pRxPacket, FromWhichBSSID);
+	ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pRxBlk->pRxPacket,
+					 FromWhichBSSID);
 
-	if (pPacket2)
-	{
+	if (pPacket2) {
 		ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pPacket2, FromWhichBSSID);
 	}
 }
 
-
 #define RESET_FRAGFRAME(_fragFrame) \
 	{								\
 		_fragFrame.RxSize = 0;		\
@@ -2349,81 +2193,76 @@ VOID CmmRxRalinkFrameIndicate(
 		_fragFrame.Flags = 0;		\
 	}
 
-
-PNDIS_PACKET RTMPDeFragmentDataFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk)
-{
-	PHEADER_802_11	pHeader = pRxBlk->pHeader;
-	PNDIS_PACKET	pRxPacket = pRxBlk->pRxPacket;
-	UCHAR			*pData = pRxBlk->pData;
-	USHORT			DataSize = pRxBlk->DataSize;
-	PNDIS_PACKET	pRetPacket = NULL;
-	UCHAR			*pFragBuffer = NULL;
-	BOOLEAN 		bReassDone = FALSE;
-	UCHAR			HeaderRoom = 0;
-
+PNDIS_PACKET RTMPDeFragmentDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
+{
+	PHEADER_802_11 pHeader = pRxBlk->pHeader;
+	PNDIS_PACKET pRxPacket = pRxBlk->pRxPacket;
+	UCHAR *pData = pRxBlk->pData;
+	USHORT DataSize = pRxBlk->DataSize;
+	PNDIS_PACKET pRetPacket = NULL;
+	UCHAR *pFragBuffer = NULL;
+	BOOLEAN bReassDone = FALSE;
+	UCHAR HeaderRoom = 0;
 
 	ASSERT(pHeader);
 
-	HeaderRoom = pData - (UCHAR *)pHeader;
+	HeaderRoom = pData - (UCHAR *) pHeader;
 
 	// Re-assemble the fragmented packets
-	if (pHeader->Frag == 0)		// Frag. Number is 0 : First frag or only one pkt
+	if (pHeader->Frag == 0)	// Frag. Number is 0 : First frag or only one pkt
 	{
 		// the first pkt of fragment, record it.
-		if (pHeader->FC.MoreFrag)
-		{
+		if (pHeader->FC.MoreFrag) {
 			ASSERT(pAd->FragFrame.pFragPacket);
-			pFragBuffer = GET_OS_PKT_DATAPTR(pAd->FragFrame.pFragPacket);
-			pAd->FragFrame.RxSize   = DataSize + HeaderRoom;
-			NdisMoveMemory(pFragBuffer,	 pHeader, pAd->FragFrame.RxSize);
+			pFragBuffer =
+			    GET_OS_PKT_DATAPTR(pAd->FragFrame.pFragPacket);
+			pAd->FragFrame.RxSize = DataSize + HeaderRoom;
+			NdisMoveMemory(pFragBuffer, pHeader,
+				       pAd->FragFrame.RxSize);
 			pAd->FragFrame.Sequence = pHeader->Sequence;
-			pAd->FragFrame.LastFrag = pHeader->Frag;	   // Should be 0
+			pAd->FragFrame.LastFrag = pHeader->Frag;	// Should be 0
 			ASSERT(pAd->FragFrame.LastFrag == 0);
 			goto done;	// end of processing this frame
 		}
-	}
-	else	//Middle & End of fragment
+	} else			//Middle & End of fragment
 	{
 		if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||
-			(pHeader->Frag != (pAd->FragFrame.LastFrag + 1)))
-		{
+		    (pHeader->Frag != (pAd->FragFrame.LastFrag + 1))) {
 			// Fragment is not the same sequence or out of fragment number order
 			// Reset Fragment control blk
 			RESET_FRAGFRAME(pAd->FragFrame);
-			DBGPRINT(RT_DEBUG_ERROR, ("Fragment is not the same sequence or out of fragment number order.\n"));
-			goto done; // give up this frame
-		}
-		else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE)
-		{
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Fragment is not the same sequence or out of fragment number order.\n"));
+			goto done;	// give up this frame
+		} else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE) {
 			// Fragment frame is too large, it exeeds the maximum frame size.
 			// Reset Fragment control blk
 			RESET_FRAGFRAME(pAd->FragFrame);
-			DBGPRINT(RT_DEBUG_ERROR, ("Fragment frame is too large, it exeeds the maximum frame size.\n"));
-			goto done; // give up this frame
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Fragment frame is too large, it exeeds the maximum frame size.\n"));
+			goto done;	// give up this frame
 		}
-
-        //
+		//
 		// Broadcom AP(BCM94704AGR) will send out LLC in fragment's packet, LLC only can accpet at first fragment.
 		// In this case, we will dropt it.
 		//
-		if (NdisEqualMemory(pData, SNAP_802_1H, sizeof(SNAP_802_1H)))
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("Find another LLC at Middle or End fragment(SN=%d, Frag=%d)\n", pHeader->Sequence, pHeader->Frag));
-			goto done; // give up this frame
+		if (NdisEqualMemory(pData, SNAP_802_1H, sizeof(SNAP_802_1H))) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Find another LLC at Middle or End fragment(SN=%d, Frag=%d)\n",
+				  pHeader->Sequence, pHeader->Frag));
+			goto done;	// give up this frame
 		}
 
 		pFragBuffer = GET_OS_PKT_DATAPTR(pAd->FragFrame.pFragPacket);
 
 		// concatenate this fragment into the re-assembly buffer
-		NdisMoveMemory((pFragBuffer + pAd->FragFrame.RxSize), pData, DataSize);
-		pAd->FragFrame.RxSize  += DataSize;
-		pAd->FragFrame.LastFrag = pHeader->Frag;	   // Update fragment number
+		NdisMoveMemory((pFragBuffer + pAd->FragFrame.RxSize), pData,
+			       DataSize);
+		pAd->FragFrame.RxSize += DataSize;
+		pAd->FragFrame.LastFrag = pHeader->Frag;	// Update fragment number
 
 		// Last fragment
-		if (pHeader->FC.MoreFrag == FALSE)
-		{
+		if (pHeader->FC.MoreFrag == FALSE) {
 			bReassDone = TRUE;
 		}
 	}
@@ -2434,24 +2273,22 @@ done:
 
 	// return defragmented packet if packet is reassembled completely
 	// otherwise return NULL
-	if (bReassDone)
-	{
+	if (bReassDone) {
 		PNDIS_PACKET pNewFragPacket;
 
 		// allocate a new packet buffer for fragment
-		pNewFragPacket = RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
-		if (pNewFragPacket)
-		{
+		pNewFragPacket =
+		    RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
+		if (pNewFragPacket) {
 			// update RxBlk
 			pRetPacket = pAd->FragFrame.pFragPacket;
 			pAd->FragFrame.pFragPacket = pNewFragPacket;
-			pRxBlk->pHeader = (PHEADER_802_11) GET_OS_PKT_DATAPTR(pRetPacket);
-			pRxBlk->pData = (UCHAR *)pRxBlk->pHeader + HeaderRoom;
+			pRxBlk->pHeader =
+			    (PHEADER_802_11) GET_OS_PKT_DATAPTR(pRetPacket);
+			pRxBlk->pData = (UCHAR *) pRxBlk->pHeader + HeaderRoom;
 			pRxBlk->DataSize = pAd->FragFrame.RxSize - HeaderRoom;
 			pRxBlk->pRxPacket = pRetPacket;
-		}
-		else
-		{
+		} else {
 			RESET_FRAGFRAME(pAd->FragFrame);
 		}
 	}
@@ -2459,23 +2296,20 @@ done:
 	return pRetPacket;
 }
 
-
-VOID Indicate_AMSDU_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
+VOID Indicate_AMSDU_Packet(IN PRTMP_ADAPTER pAd,
+			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
-	UINT			nMSDU;
+	UINT nMSDU;
 
 	update_os_packet_info(pAd, pRxBlk, FromWhichBSSID);
 	RTMP_SET_PACKET_IF(pRxBlk->pRxPacket, FromWhichBSSID);
-	nMSDU = deaggregate_AMSDU_announce(pAd, pRxBlk->pRxPacket, pRxBlk->pData, pRxBlk->DataSize);
+	nMSDU =
+	    deaggregate_AMSDU_announce(pAd, pRxBlk->pRxPacket, pRxBlk->pData,
+				       pRxBlk->DataSize);
 }
 
-VOID Indicate_EAPOL_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
+VOID Indicate_EAPOL_Packet(IN PRTMP_ADAPTER pAd,
+			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
 	MAC_TABLE_ENTRY *pEntry = NULL;
 
@@ -2485,22 +2319,21 @@ VOID Indicate_EAPOL_Packet(
 		return;
 	}
 
-	if (pEntry == NULL)
-	{
-		DBGPRINT(RT_DEBUG_WARN, ("Indicate_EAPOL_Packet: drop and release the invalid packet.\n"));
+	if (pEntry == NULL) {
+		DBGPRINT(RT_DEBUG_WARN,
+			 ("Indicate_EAPOL_Packet: drop and release the invalid packet.\n"));
 		// release packet
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+				    NDIS_STATUS_FAILURE);
 		return;
 	}
 }
 
 #define BCN_TBTT_OFFSET		64	//defer 64 us
-VOID ReSyncBeaconTime(
-	IN  PRTMP_ADAPTER   pAd)
+VOID ReSyncBeaconTime(IN PRTMP_ADAPTER pAd)
 {
 
-	UINT32  Offset;
-
+	UINT32 Offset;
 
 	Offset = (pAd->TbttTickCount) % (BCN_TBTT_OFFSET);
 
@@ -2510,23 +2343,18 @@ VOID ReSyncBeaconTime(
 	// The updated BeaconInterval Value will affect Beacon Interval after two TBTT
 	// beacasue the original BeaconInterval had been loaded into next TBTT_TIMER
 	//
-	if (Offset == (BCN_TBTT_OFFSET-2))
-	{
+	if (Offset == (BCN_TBTT_OFFSET - 2)) {
 		BCN_TIME_CFG_STRUC csr;
 		RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-		csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod << 4) - 1 ;	// ASIC register in units of 1/16 TU = 64us
+		csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod << 4) - 1;	// ASIC register in units of 1/16 TU = 64us
 		RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
-	}
-	else
-	{
-		if (Offset == (BCN_TBTT_OFFSET-1))
-		{
+	} else {
+		if (Offset == (BCN_TBTT_OFFSET - 1)) {
 			BCN_TIME_CFG_STRUC csr;
 
 			RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-			csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod) << 4; // ASIC register in units of 1/16 TU
+			csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod) << 4;	// ASIC register in units of 1/16 TU
 			RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
 		}
 	}
 }
-
--- a/drivers/staging/rt2860/common/cmm_data_pci.c
+++ b/drivers/staging/rt2860/common/cmm_data_pci.c
@@ -32,20 +32,17 @@
 */
 #include	"../rt_config.h"
 
-
-USHORT RtmpPCI_WriteTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber)
+USHORT RtmpPCI_WriteTxResource(IN PRTMP_ADAPTER pAd,
+			       IN TX_BLK * pTxBlk,
+			       IN BOOLEAN bIsLast, OUT USHORT * FreeNumber)
 {
 
-	UCHAR			*pDMAHeaderBufVA;
-	USHORT			TxIdx, RetTxIdx;
-	PTXD_STRUC		pTxD;
-	UINT32			BufBasePaLow;
-	PRTMP_TX_RING	pTxRing;
-	USHORT			hwHeaderLen;
+	UCHAR *pDMAHeaderBufVA;
+	USHORT TxIdx, RetTxIdx;
+	PTXD_STRUC pTxD;
+	UINT32 BufBasePaLow;
+	PRTMP_TX_RING pTxRing;
+	USHORT hwHeaderLen;
 
 	//
 	// get Tx Ring Resource
@@ -53,20 +50,21 @@ USHORT RtmpPCI_WriteTxResource(
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
 	pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
-	BufBasePaLow = RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
+	BufBasePaLow =
+	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 
 	// copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
-	if (pTxBlk->TxFrameType == TX_AMSDU_FRAME)
-	{
+	if (pTxBlk->TxFrameType == TX_AMSDU_FRAME) {
 		//hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD;
-		hwHeaderLen = pTxBlk->MpduHeaderLen - LENGTH_AMSDU_SUBFRAMEHEAD + pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
-	}
-	else
-	{
+		hwHeaderLen =
+		    pTxBlk->MpduHeaderLen - LENGTH_AMSDU_SUBFRAMEHEAD +
+		    pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
+	} else {
 		//hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
 		hwHeaderLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 	}
-	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf, TXINFO_SIZE + TXWI_SIZE + hwHeaderLen);
+	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf,
+		       TXINFO_SIZE + TXWI_SIZE + hwHeaderLen);
 
 	pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
 	pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
@@ -79,7 +77,7 @@ USHORT RtmpPCI_WriteTxResource(
 	NdisZeroMemory(pTxD, TXD_SIZE);
 
 	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen; // include padding
+	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;	// include padding
 	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);
 	pTxD->SDLen1 = pTxBlk->SrcBufLen;
 	pTxD->LastSec0 = 0;
@@ -99,20 +97,18 @@ USHORT RtmpPCI_WriteTxResource(
 	return RetTxIdx;
 }
 
-
-USHORT RtmpPCI_WriteSingleTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber)
+USHORT RtmpPCI_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
+				     IN TX_BLK * pTxBlk,
+				     IN BOOLEAN bIsLast,
+				     OUT USHORT * FreeNumber)
 {
 
-	UCHAR			*pDMAHeaderBufVA;
-	USHORT			TxIdx, RetTxIdx;
-	PTXD_STRUC		pTxD;
-	UINT32			BufBasePaLow;
-	PRTMP_TX_RING	pTxRing;
-	USHORT			hwHeaderLen;
+	UCHAR *pDMAHeaderBufVA;
+	USHORT TxIdx, RetTxIdx;
+	PTXD_STRUC pTxD;
+	UINT32 BufBasePaLow;
+	PRTMP_TX_RING pTxRing;
+	USHORT hwHeaderLen;
 
 	//
 	// get Tx Ring Resource
@@ -120,13 +116,15 @@ USHORT RtmpPCI_WriteSingleTxResource(
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
 	pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
-	BufBasePaLow = RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
+	BufBasePaLow =
+	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 
 	// copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
 	//hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
 	hwHeaderLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
-	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf, TXINFO_SIZE + TXWI_SIZE + hwHeaderLen);
+	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf,
+		       TXINFO_SIZE + TXWI_SIZE + hwHeaderLen);
 
 	pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
 	pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
@@ -138,7 +136,7 @@ USHORT RtmpPCI_WriteSingleTxResource(
 	NdisZeroMemory(pTxD, TXD_SIZE);
 
 	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen; // include padding
+	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;	// include padding
 	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);;
 	pTxD->SDLen1 = pTxBlk->SrcBufLen;
 	pTxD->LastSec0 = 0;
@@ -158,21 +156,18 @@ USHORT RtmpPCI_WriteSingleTxResource(
 	return RetTxIdx;
 }
 
-
-USHORT RtmpPCI_WriteMultiTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			frameNum,
-	OUT	USHORT			*FreeNumber)
+USHORT RtmpPCI_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
+				    IN TX_BLK * pTxBlk,
+				    IN UCHAR frameNum, OUT USHORT * FreeNumber)
 {
 	BOOLEAN bIsLast;
-	UCHAR			*pDMAHeaderBufVA;
-	USHORT			TxIdx, RetTxIdx;
-	PTXD_STRUC		pTxD;
-	UINT32			BufBasePaLow;
-	PRTMP_TX_RING	pTxRing;
-	USHORT			hwHdrLen;
-	UINT32			firstDMALen;
+	UCHAR *pDMAHeaderBufVA;
+	USHORT TxIdx, RetTxIdx;
+	PTXD_STRUC pTxD;
+	UINT32 BufBasePaLow;
+	PRTMP_TX_RING pTxRing;
+	USHORT hwHdrLen;
+	UINT32 firstDMALen;
 
 	bIsLast = ((frameNum == (pTxBlk->TotalFrameNum - 1)) ? 1 : 0);
 
@@ -182,25 +177,28 @@ USHORT RtmpPCI_WriteMultiTxResource(
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
 	pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
-	BufBasePaLow = RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
+	BufBasePaLow =
+	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 
-	if (frameNum == 0)
-	{
+	if (frameNum == 0) {
 		// copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
 		if (pTxBlk->TxFrameType == TX_AMSDU_FRAME)
 			//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD;
-			hwHdrLen = pTxBlk->MpduHeaderLen - LENGTH_AMSDU_SUBFRAMEHEAD + pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
+			hwHdrLen =
+			    pTxBlk->MpduHeaderLen - LENGTH_AMSDU_SUBFRAMEHEAD +
+			    pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
 		else if (pTxBlk->TxFrameType == TX_RALINK_FRAME)
 			//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD, 4)+LENGTH_ARALINK_HEADER_FIELD;
-			hwHdrLen = pTxBlk->MpduHeaderLen - LENGTH_ARALINK_HEADER_FIELD + pTxBlk->HdrPadLen + LENGTH_ARALINK_HEADER_FIELD;
+			hwHdrLen =
+			    pTxBlk->MpduHeaderLen -
+			    LENGTH_ARALINK_HEADER_FIELD + pTxBlk->HdrPadLen +
+			    LENGTH_ARALINK_HEADER_FIELD;
 		else
 			//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
 			hwHdrLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
 		firstDMALen = TXINFO_SIZE + TXWI_SIZE + hwHdrLen;
-	}
-	else
-	{
+	} else {
 		firstDMALen = pTxBlk->MpduHeaderLen;
 	}
 
@@ -216,7 +214,7 @@ USHORT RtmpPCI_WriteMultiTxResource(
 	NdisZeroMemory(pTxD, TXD_SIZE);
 
 	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = firstDMALen; // include padding
+	pTxD->SDLen0 = firstDMALen;	// include padding
 	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);;
 	pTxD->SDLen1 = pTxBlk->SrcBufLen;
 	pTxD->LastSec0 = 0;
@@ -224,7 +222,6 @@ USHORT RtmpPCI_WriteMultiTxResource(
 
 	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
 
-
 	RetTxIdx = TxIdx;
 	//
 	// Update Tx index
@@ -238,16 +235,13 @@ USHORT RtmpPCI_WriteMultiTxResource(
 
 }
 
-
-VOID RtmpPCI_FinalWriteTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	USHORT			totalMPDUSize,
-	IN	USHORT			FirstTxIdx)
+VOID RtmpPCI_FinalWriteTxResource(IN PRTMP_ADAPTER pAd,
+				  IN TX_BLK * pTxBlk,
+				  IN USHORT totalMPDUSize, IN USHORT FirstTxIdx)
 {
 
-	PTXWI_STRUC		pTxWI;
-	PRTMP_TX_RING	pTxRing;
+	PTXWI_STRUC pTxWI;
+	PRTMP_TX_RING pTxRing;
 
 	//
 	// get Tx Ring Resource
@@ -258,14 +252,11 @@ VOID RtmpPCI_FinalWriteTxResource(
 
 }
 
-
-VOID RtmpPCIDataLastTxIdx(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			QueIdx,
-	IN	USHORT			LastTxIdx)
+VOID RtmpPCIDataLastTxIdx(IN PRTMP_ADAPTER pAd,
+			  IN UCHAR QueIdx, IN USHORT LastTxIdx)
 {
-	PTXD_STRUC		pTxD;
-	PRTMP_TX_RING	pTxRing;
+	PTXD_STRUC pTxD;
+	PRTMP_TX_RING pTxRing;
 
 	//
 	// get Tx Ring Resource
@@ -279,23 +270,19 @@ VOID RtmpPCIDataLastTxIdx(
 
 	pTxD->LastSec1 = 1;
 
-
 }
 
-
-USHORT	RtmpPCI_WriteFragTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			fragNum,
-	OUT	USHORT			*FreeNumber)
+USHORT RtmpPCI_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
+				   IN TX_BLK * pTxBlk,
+				   IN UCHAR fragNum, OUT USHORT * FreeNumber)
 {
-	UCHAR			*pDMAHeaderBufVA;
-	USHORT			TxIdx, RetTxIdx;
-	PTXD_STRUC		pTxD;
-	UINT32			BufBasePaLow;
-	PRTMP_TX_RING	pTxRing;
-	USHORT			hwHeaderLen;
-	UINT32			firstDMALen;
+	UCHAR *pDMAHeaderBufVA;
+	USHORT TxIdx, RetTxIdx;
+	PTXD_STRUC pTxD;
+	UINT32 BufBasePaLow;
+	PRTMP_TX_RING pTxRing;
+	USHORT hwHeaderLen;
+	UINT32 firstDMALen;
 
 	//
 	// Get Tx Ring Resource
@@ -303,7 +290,8 @@ USHORT	RtmpPCI_WriteFragTxResource(
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
 	pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
-	BufBasePaLow = RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
+	BufBasePaLow =
+	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 
 	//
 	// Copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
@@ -314,21 +302,19 @@ USHORT	RtmpPCI_WriteFragTxResource(
 	firstDMALen = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;
 	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf, firstDMALen);
 
-
 	//
 	// Build Tx Descriptor
 	//
 	pTxD = (PTXD_STRUC) pTxRing->Cell[TxIdx].AllocVa;
 	NdisZeroMemory(pTxD, TXD_SIZE);
 
-	if (fragNum == pTxBlk->TotalFragNum)
-	{
+	if (fragNum == pTxBlk->TotalFragNum) {
 		pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
 		pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
 	}
 
 	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = firstDMALen; // include padding
+	pTxD->SDLen0 = firstDMALen;	// include padding
 	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);
 	pTxD->SDLen1 = pTxBlk->SrcBufLen;
 	pTxD->LastSec0 = 0;
@@ -336,7 +322,6 @@ USHORT	RtmpPCI_WriteFragTxResource(
 
 	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
 
-
 	RetTxIdx = TxIdx;
 	pTxBlk->Priv += pTxBlk->SrcBufLen;
 
@@ -352,22 +337,19 @@ USHORT	RtmpPCI_WriteFragTxResource(
 
 }
 
-
 /*
 	Must be run in Interrupt context
 	This function handle PCI specific TxDesc and cpu index update and kick the packet out.
  */
-int RtmpPCIMgmtKickOut(
-	IN RTMP_ADAPTER		*pAd,
-	IN UCHAR			QueIdx,
-	IN PNDIS_PACKET		pPacket,
-	IN PUCHAR			pSrcBufVA,
-	IN UINT				SrcBufLen)
+int RtmpPCIMgmtKickOut(IN RTMP_ADAPTER * pAd,
+		       IN UCHAR QueIdx,
+		       IN PNDIS_PACKET pPacket,
+		       IN PUCHAR pSrcBufVA, IN UINT SrcBufLen)
 {
-	PTXD_STRUC		pTxD;
-	ULONG			SwIdx = pAd->MgmtRing.TxCpuIdx;
+	PTXD_STRUC pTxD;
+	ULONG SwIdx = pAd->MgmtRing.TxCpuIdx;
 
-	pTxD  = (PTXD_STRUC) pAd->MgmtRing.Cell[SwIdx].AllocVa;
+	pTxD = (PTXD_STRUC) pAd->MgmtRing.Cell[SwIdx].AllocVa;
 
 	pAd->MgmtRing.Cell[SwIdx].pNdisPacket = pPacket;
 	pAd->MgmtRing.Cell[SwIdx].pNextNdisPacket = NULL;
@@ -377,10 +359,10 @@ int RtmpPCIMgmtKickOut(
 	pTxD->LastSec1 = 1;
 	pTxD->DMADONE = 0;
 	pTxD->SDLen1 = 0;
-	pTxD->SDPtr0 = PCI_MAP_SINGLE(pAd, pSrcBufVA, SrcBufLen, 0, PCI_DMA_TODEVICE);
+	pTxD->SDPtr0 =
+	    PCI_MAP_SINGLE(pAd, pSrcBufVA, SrcBufLen, 0, PCI_DMA_TODEVICE);
 	pTxD->SDLen0 = SrcBufLen;
 
-
 //==================================================================
 /*	DBGPRINT_RAW(RT_DEBUG_TRACE, ("MLMEHardTransmit\n"));
 	for (i = 0; i < (TXWI_SIZE+24); i++)
@@ -401,12 +383,11 @@ int RtmpPCIMgmtKickOut(
 	// Increase TX_CTX_IDX, but write to register later.
 	INC_RING_INDEX(pAd->MgmtRing.TxCpuIdx, MGMT_RING_SIZE);
 
-	RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX,  pAd->MgmtRing.TxCpuIdx);
+	RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
 
 	return 0;
 }
 
-
 /*
 	========================================================================
 
@@ -424,18 +405,15 @@ int RtmpPCIMgmtKickOut(
 
 	========================================================================
 */
-NDIS_STATUS RTMPCheckRxError(
-	IN	PRTMP_ADAPTER		pAd,
-	IN	PHEADER_802_11		pHeader,
-	IN	PRXWI_STRUC		pRxWI,
-	IN  PRT28XX_RXD_STRUC	pRxD)
+NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
+			     IN PHEADER_802_11 pHeader,
+			     IN PRXWI_STRUC pRxWI, IN PRT28XX_RXD_STRUC pRxD)
 {
 	PCIPHER_KEY pWpaKey;
 	INT dBm;
 
 	// Phy errors & CRC errors
-	if (/*(pRxD->PhyErr) ||*/ (pRxD->Crc))
-	{
+	if ( /*(pRxD->PhyErr) || */ (pRxD->Crc)) {
 		// Check RSSI for Noise Hist statistic collection.
 		dBm = (INT) (pRxWI->RSSI0) - pAd->BbpRssiToDbmDelta;
 		if (dBm <= -87)
@@ -455,157 +433,166 @@ NDIS_STATUS RTMPCheckRxError(
 		else if (dBm > -57)
 			pAd->StaCfg.RPIDensity[7] += 1;
 
-		return(NDIS_STATUS_FAILURE);
+		return (NDIS_STATUS_FAILURE);
 	}
-
 	// Add Rx size to channel load counter, we should ignore error counts
 	pAd->StaCfg.CLBusyBytes += (pRxD->SDL0 + 14);
 
 	// Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics
-	if (pHeader != NULL)
-	{
-		if (pHeader->FC.ToDs)
-		{
-			return(NDIS_STATUS_FAILURE);
+	if (pHeader != NULL) {
+		if (pHeader->FC.ToDs) {
+			return (NDIS_STATUS_FAILURE);
 		}
 	}
-
 	// Drop not U2M frames, cant's drop here because we will drop beacon in this case
 	// I am kind of doubting the U2M bit operation
 	// if (pRxD->U2M == 0)
-	//	return(NDIS_STATUS_FAILURE);
+	//      return(NDIS_STATUS_FAILURE);
 
 	// drop decyption fail frame
-	if (pRxD->CipherErr)
-	{
-		if (pRxD->CipherErr == 2)
-			{DBGPRINT_RAW(RT_DEBUG_TRACE,("pRxD ERROR: ICV ok but MICErr "));}
-		else if (pRxD->CipherErr == 1)
-			{DBGPRINT_RAW(RT_DEBUG_TRACE,("pRxD ERROR: ICV Err "));}
-		else if (pRxD->CipherErr == 3)
-			DBGPRINT_RAW(RT_DEBUG_TRACE,("pRxD ERROR: Key not valid "));
-
-        if (((pRxD->CipherErr & 1) == 1) && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
-            RTMPSendWirelessEvent(pAd, IW_ICV_ERROR_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
-
-		DBGPRINT_RAW(RT_DEBUG_TRACE,(" %d (len=%d, Mcast=%d, MyBss=%d, Wcid=%d, KeyId=%d)\n",
-			pRxD->CipherErr,
-			pRxD->SDL0,
-			pRxD->Mcast | pRxD->Bcast,
-			pRxD->MyBss,
-			pRxWI->WirelessCliID,
-//			CipherName[pRxD->CipherAlg],
-			pRxWI->KeyIndex));
+	if (pRxD->CipherErr) {
+		if (pRxD->CipherErr == 2) {
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("pRxD ERROR: ICV ok but MICErr "));
+		} else if (pRxD->CipherErr == 1) {
+			DBGPRINT_RAW(RT_DEBUG_TRACE, ("pRxD ERROR: ICV Err "));
+		} else if (pRxD->CipherErr == 3)
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("pRxD ERROR: Key not valid "));
+
+		if (((pRxD->CipherErr & 1) == 1)
+		    && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
+			RTMPSendWirelessEvent(pAd, IW_ICV_ERROR_EVENT_FLAG,
+					      pAd->MacTab.Content[BSSID_WCID].
+					      Addr, BSS0, 0);
+
+		DBGPRINT_RAW(RT_DEBUG_TRACE,
+			     (" %d (len=%d, Mcast=%d, MyBss=%d, Wcid=%d, KeyId=%d)\n",
+			      pRxD->CipherErr, pRxD->SDL0,
+			      pRxD->Mcast | pRxD->Bcast, pRxD->MyBss,
+			      pRxWI->WirelessCliID,
+//                      CipherName[pRxD->CipherAlg],
+			      pRxWI->KeyIndex));
 
 		//
 		// MIC Error
 		//
-		if (pRxD->CipherErr == 2)
-		{
+		if (pRxD->CipherErr == 2) {
 			pWpaKey = &pAd->SharedKey[BSS0][pRxWI->KeyIndex];
-            if (pAd->StaCfg.WpaSupplicantUP)
-                WpaSendMicFailureToWpaSupplicant(pAd,
-                                   (pWpaKey->Type == PAIRWISEKEY) ? TRUE:FALSE);
-            else
-			    RTMPReportMicError(pAd, pWpaKey);
-
-            if (((pRxD->CipherErr & 2) == 2) && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
-                RTMPSendWirelessEvent(pAd, IW_MIC_ERROR_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+			if (pAd->StaCfg.WpaSupplicantUP)
+				WpaSendMicFailureToWpaSupplicant(pAd,
+								 (pWpaKey->
+								  Type ==
+								  PAIRWISEKEY) ?
+								 TRUE : FALSE);
+			else
+				RTMPReportMicError(pAd, pWpaKey);
+
+			if (((pRxD->CipherErr & 2) == 2)
+			    && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
+				RTMPSendWirelessEvent(pAd,
+						      IW_MIC_ERROR_EVENT_FLAG,
+						      pAd->MacTab.
+						      Content[BSSID_WCID].Addr,
+						      BSS0, 0);
 
-			DBGPRINT_RAW(RT_DEBUG_ERROR,("Rx MIC Value error\n"));
+			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Rx MIC Value error\n"));
 		}
 
 		if (pHeader == NULL)
-			return(NDIS_STATUS_SUCCESS);
+			return (NDIS_STATUS_SUCCESS);
 		/*if ((pRxD->CipherAlg == CIPHER_AES) &&
-			(pHeader->Sequence == pAd->FragFrame.Sequence))
-		{
-			//
-			// Acceptable since the First FragFrame no CipherErr problem.
-			//
-			return(NDIS_STATUS_SUCCESS);
-		}*/
+		   (pHeader->Sequence == pAd->FragFrame.Sequence))
+		   {
+		   //
+		   // Acceptable since the First FragFrame no CipherErr problem.
+		   //
+		   return(NDIS_STATUS_SUCCESS);
+		   } */
 
-		return(NDIS_STATUS_FAILURE);
+		return (NDIS_STATUS_FAILURE);
 	}
 
-	return(NDIS_STATUS_SUCCESS);
+	return (NDIS_STATUS_SUCCESS);
 }
 
-
-BOOLEAN  RTMPFreeTXDUponTxDmaDone(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			QueIdx)
+BOOLEAN RTMPFreeTXDUponTxDmaDone(IN PRTMP_ADAPTER pAd, IN UCHAR QueIdx)
 {
 	PRTMP_TX_RING pTxRing;
-	PTXD_STRUC	  pTxD;
-	PNDIS_PACKET  pPacket;
-	UCHAR	FREE = 0;
-	TXD_STRUC	TxD, *pOriTxD;
-	//ULONG		IrqFlags;
-	BOOLEAN			bReschedule = FALSE;
-
+	PTXD_STRUC pTxD;
+	PNDIS_PACKET pPacket;
+	UCHAR FREE = 0;
+	TXD_STRUC TxD, *pOriTxD;
+	//ULONG         IrqFlags;
+	BOOLEAN bReschedule = FALSE;
 
 	ASSERT(QueIdx < NUM_OF_TX_RING);
 	pTxRing = &pAd->TxRing[QueIdx];
 
-	RTMP_IO_READ32(pAd, TX_DTX_IDX0 + QueIdx * RINGREG_DIFF, &pTxRing->TxDmaIdx);
-	while (pTxRing->TxSwFreeIdx != pTxRing->TxDmaIdx)
-	{
-//		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+	RTMP_IO_READ32(pAd, TX_DTX_IDX0 + QueIdx * RINGREG_DIFF,
+		       &pTxRing->TxDmaIdx);
+	while (pTxRing->TxSwFreeIdx != pTxRing->TxDmaIdx) {
+//              RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
 
 		// static rate also need NICUpdateFifoStaCounters() function.
 		//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
-			NICUpdateFifoStaCounters(pAd);
+		NICUpdateFifoStaCounters(pAd);
 
 		/* Note : If (pAd->ate.bQATxStart == TRUE), we will never reach here. */
 		FREE++;
-                pTxD = (PTXD_STRUC) (pTxRing->Cell[pTxRing->TxSwFreeIdx].AllocVa);
+		pTxD =
+		    (PTXD_STRUC) (pTxRing->Cell[pTxRing->TxSwFreeIdx].AllocVa);
 		pOriTxD = pTxD;
-                NdisMoveMemory(&TxD, pTxD, sizeof(TXD_STRUC));
+		NdisMoveMemory(&TxD, pTxD, sizeof(TXD_STRUC));
 		pTxD = &TxD;
 
 		pTxD->DMADONE = 0;
 
-
 		{
-			pPacket = pTxRing->Cell[pTxRing->TxSwFreeIdx].pNdisPacket;
-			if (pPacket)
-			{
-					PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1, pTxD->SDLen1, PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
+			pPacket =
+			    pTxRing->Cell[pTxRing->TxSwFreeIdx].pNdisPacket;
+			if (pPacket) {
+				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
+						 pTxD->SDLen1,
+						 PCI_DMA_TODEVICE);
+				RELEASE_NDIS_PACKET(pAd, pPacket,
+						    NDIS_STATUS_SUCCESS);
 			}
 			//Always assign pNdisPacket as NULL after clear
 			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNdisPacket = NULL;
 
-			pPacket = pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket;
+			pPacket =
+			    pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket;
 
 			ASSERT(pPacket == NULL);
-			if (pPacket)
-			{
-					PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1, pTxD->SDLen1, PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
+			if (pPacket) {
+				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
+						 pTxD->SDLen1,
+						 PCI_DMA_TODEVICE);
+				RELEASE_NDIS_PACKET(pAd, pPacket,
+						    NDIS_STATUS_SUCCESS);
 			}
 			//Always assign pNextNdisPacket as NULL after clear
-			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket = NULL;
+			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket =
+			    NULL;
 		}
 
-		pAd->RalinkCounters.TransmittedByteCount +=  (pTxD->SDLen1 + pTxD->SDLen0);
-		pAd->RalinkCounters.OneSecDmaDoneCount[QueIdx] ++;
+		pAd->RalinkCounters.TransmittedByteCount +=
+		    (pTxD->SDLen1 + pTxD->SDLen0);
+		pAd->RalinkCounters.OneSecDmaDoneCount[QueIdx]++;
 		INC_RING_INDEX(pTxRing->TxSwFreeIdx, TX_RING_SIZE);
 		/* get tx_tdx_idx again */
-		RTMP_IO_READ32(pAd, TX_DTX_IDX0 + QueIdx * RINGREG_DIFF ,  &pTxRing->TxDmaIdx);
-        NdisMoveMemory(pOriTxD, pTxD, sizeof(TXD_STRUC));
+		RTMP_IO_READ32(pAd, TX_DTX_IDX0 + QueIdx * RINGREG_DIFF,
+			       &pTxRing->TxDmaIdx);
+		NdisMoveMemory(pOriTxD, pTxD, sizeof(TXD_STRUC));
 
 //         RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
 	}
 
-
-	return  bReschedule;
+	return bReschedule;
 
 }
 
-
 /*
 	========================================================================
 
@@ -622,13 +609,12 @@ BOOLEAN  RTMPFreeTXDUponTxDmaDone(
 
 	========================================================================
 */
-BOOLEAN	RTMPHandleTxRingDmaDoneInterrupt(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	INT_SOURCE_CSR_STRUC TxRingBitmap)
+BOOLEAN RTMPHandleTxRingDmaDoneInterrupt(IN PRTMP_ADAPTER pAd,
+					 IN INT_SOURCE_CSR_STRUC TxRingBitmap)
 {
-//	UCHAR			Count = 0;
-    unsigned long	IrqFlags;
-	BOOLEAN			bReschedule = FALSE;
+//      UCHAR                   Count = 0;
+	unsigned long IrqFlags;
+	BOOLEAN bReschedule = FALSE;
 
 	// Make sure Tx ring resource won't be used by other threads
 	//NdisAcquireSpinLock(&pAd->TxRingLock);
@@ -654,10 +640,9 @@ BOOLEAN	RTMPHandleTxRingDmaDoneInterrupt
 	// Dequeue outgoing frames from TxSwQueue[] and process it
 	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
 
-	return  bReschedule;
+	return bReschedule;
 }
 
-
 /*
 	========================================================================
 
@@ -676,37 +661,37 @@ BOOLEAN	RTMPHandleTxRingDmaDoneInterrupt
 
 	========================================================================
 */
-VOID	RTMPHandleMgmtRingDmaDoneInterrupt(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPHandleMgmtRingDmaDoneInterrupt(IN PRTMP_ADAPTER pAd)
 {
-	PTXD_STRUC	 pTxD;
+	PTXD_STRUC pTxD;
 	PNDIS_PACKET pPacket;
-//	int		 i;
-	UCHAR	FREE = 0;
+//      int              i;
+	UCHAR FREE = 0;
 	PRTMP_MGMT_RING pMgmtRing = &pAd->MgmtRing;
 
 	NdisAcquireSpinLock(&pAd->MgmtRingLock);
 
 	RTMP_IO_READ32(pAd, TX_MGMTDTX_IDX, &pMgmtRing->TxDmaIdx);
-	while (pMgmtRing->TxSwFreeIdx!= pMgmtRing->TxDmaIdx)
-	{
+	while (pMgmtRing->TxSwFreeIdx != pMgmtRing->TxDmaIdx) {
 		FREE++;
-		pTxD = (PTXD_STRUC) (pMgmtRing->Cell[pAd->MgmtRing.TxSwFreeIdx].AllocVa);
+		pTxD =
+		    (PTXD_STRUC) (pMgmtRing->Cell[pAd->MgmtRing.TxSwFreeIdx].
+				  AllocVa);
 		pTxD->DMADONE = 0;
 		pPacket = pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNdisPacket;
 
-
-		if (pPacket)
-		{
-			PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0, pTxD->SDLen0, PCI_DMA_TODEVICE);
+		if (pPacket) {
+			PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0, pTxD->SDLen0,
+					 PCI_DMA_TODEVICE);
 			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
 		}
 		pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNdisPacket = NULL;
 
-		pPacket = pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNextNdisPacket;
-		if (pPacket)
-		{
-			PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1, pTxD->SDLen1, PCI_DMA_TODEVICE);
+		pPacket =
+		    pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNextNdisPacket;
+		if (pPacket) {
+			PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1, pTxD->SDLen1,
+					 PCI_DMA_TODEVICE);
 			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
 		}
 		pMgmtRing->Cell[pMgmtRing->TxSwFreeIdx].pNextNdisPacket = NULL;
@@ -717,7 +702,6 @@ VOID	RTMPHandleMgmtRingDmaDoneInterrupt(
 
 }
 
-
 /*
 	========================================================================
 
@@ -729,17 +713,14 @@ VOID	RTMPHandleMgmtRingDmaDoneInterrupt(
 
 	========================================================================
 */
-VOID	RTMPHandleTBTTInterrupt(
-	IN PRTMP_ADAPTER pAd)
+VOID RTMPHandleTBTTInterrupt(IN PRTMP_ADAPTER pAd)
 {
 	{
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-		{
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
 		}
 	}
 }
 
-
 /*
 	========================================================================
 
@@ -751,33 +732,29 @@ VOID	RTMPHandleTBTTInterrupt(
 
 	========================================================================
 */
-VOID	RTMPHandlePreTBTTInterrupt(
-	IN PRTMP_ADAPTER pAd)
+VOID RTMPHandlePreTBTTInterrupt(IN PRTMP_ADAPTER pAd)
 {
 	{
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("RTMPHandlePreTBTTInterrupt...\n"));
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("RTMPHandlePreTBTTInterrupt...\n"));
 		}
 	}
 
-
 }
 
-VOID	RTMPHandleRxCoherentInterrupt(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPHandleRxCoherentInterrupt(IN PRTMP_ADAPTER pAd)
 {
-	WPDMA_GLO_CFG_STRUC	GloCfg;
+	WPDMA_GLO_CFG_STRUC GloCfg;
 
-	if (pAd == NULL)
-	{
+	if (pAd == NULL) {
 		DBGPRINT(RT_DEBUG_TRACE, ("====> pAd is NULL, return.\n"));
 		return;
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPHandleRxCoherentInterrupt \n"));
 
-	RTMP_IO_READ32(pAd, WPDMA_GLO_CFG , &GloCfg.word);
+	RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
 
 	GloCfg.field.EnTXWriteBackDDONE = 0;
 	GloCfg.field.EnableRxDMA = 0;
@@ -796,39 +773,38 @@ VOID	RTMPHandleRxCoherentInterrupt(
 	DBGPRINT(RT_DEBUG_TRACE, ("<== RTMPHandleRxCoherentInterrupt \n"));
 }
 
-PNDIS_PACKET GetPacketFromRxRing(
-	IN		PRTMP_ADAPTER	pAd,
-	OUT		PRT28XX_RXD_STRUC	pSaveRxD,
-	OUT		BOOLEAN			*pbReschedule,
-	IN OUT	UINT32			*pRxPending)
+PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
+				 OUT PRT28XX_RXD_STRUC pSaveRxD,
+				 OUT BOOLEAN * pbReschedule,
+				 IN OUT UINT32 * pRxPending)
 {
-	PRXD_STRUC				pRxD;
-	PNDIS_PACKET			pRxPacket = NULL;
-	PNDIS_PACKET			pNewPacket;
-	PVOID					AllocVa;
-	NDIS_PHYSICAL_ADDRESS	AllocPa;
-	BOOLEAN					bReschedule = FALSE;
-	RTMP_DMACB				*pRxCell;
+	PRXD_STRUC pRxD;
+	PNDIS_PACKET pRxPacket = NULL;
+	PNDIS_PACKET pNewPacket;
+	PVOID AllocVa;
+	NDIS_PHYSICAL_ADDRESS AllocPa;
+	BOOLEAN bReschedule = FALSE;
+	RTMP_DMACB *pRxCell;
 
 	RTMP_SEM_LOCK(&pAd->RxRingLock);
 
-	if (*pRxPending == 0)
-	{
+	if (*pRxPending == 0) {
 		// Get how may packets had been received
-		RTMP_IO_READ32(pAd, RX_DRX_IDX , &pAd->RxRing.RxDmaIdx);
+		RTMP_IO_READ32(pAd, RX_DRX_IDX, &pAd->RxRing.RxDmaIdx);
 
-		if (pAd->RxRing.RxSwReadIdx == pAd->RxRing.RxDmaIdx)
-		{
+		if (pAd->RxRing.RxSwReadIdx == pAd->RxRing.RxDmaIdx) {
 			// no more rx packets
 			bReschedule = FALSE;
 			goto done;
 		}
-
 		// get rx pending count
 		if (pAd->RxRing.RxDmaIdx > pAd->RxRing.RxSwReadIdx)
-			*pRxPending = pAd->RxRing.RxDmaIdx - pAd->RxRing.RxSwReadIdx;
+			*pRxPending =
+			    pAd->RxRing.RxDmaIdx - pAd->RxRing.RxSwReadIdx;
 		else
-			*pRxPending	= pAd->RxRing.RxDmaIdx + RX_RING_SIZE - pAd->RxRing.RxSwReadIdx;
+			*pRxPending =
+			    pAd->RxRing.RxDmaIdx + RX_RING_SIZE -
+			    pAd->RxRing.RxSwReadIdx;
 
 	}
 
@@ -837,36 +813,33 @@ PNDIS_PACKET GetPacketFromRxRing(
 	// Point to Rx indexed rx ring descriptor
 	pRxD = (PRXD_STRUC) pRxCell->AllocVa;
 
-	if (pRxD->DDONE == 0)
-	{
+	if (pRxD->DDONE == 0) {
 		*pRxPending = 0;
 		// DMAIndx had done but DDONE bit not ready
 		bReschedule = TRUE;
 		goto done;
 	}
 
-
 	// return rx descriptor
 	NdisMoveMemory(pSaveRxD, pRxD, RXD_SIZE);
 
-	pNewPacket = RTMP_AllocateRxPacketBuffer(pAd, RX_BUFFER_AGGRESIZE, FALSE, &AllocVa, &AllocPa);
+	pNewPacket =
+	    RTMP_AllocateRxPacketBuffer(pAd, RX_BUFFER_AGGRESIZE, FALSE,
+					&AllocVa, &AllocPa);
 
-	if (pNewPacket)
-	{
+	if (pNewPacket) {
 		// unmap the rx buffer
 		PCI_UNMAP_SINGLE(pAd, pRxCell->DmaBuf.AllocPa,
-					 pRxCell->DmaBuf.AllocSize, PCI_DMA_FROMDEVICE);
+				 pRxCell->DmaBuf.AllocSize, PCI_DMA_FROMDEVICE);
 		pRxPacket = pRxCell->pNdisPacket;
 
-		pRxCell->DmaBuf.AllocSize	= RX_BUFFER_AGGRESIZE;
-		pRxCell->pNdisPacket		= (PNDIS_PACKET) pNewPacket;
-		pRxCell->DmaBuf.AllocVa	= AllocVa;
-		pRxCell->DmaBuf.AllocPa	= AllocPa;
+		pRxCell->DmaBuf.AllocSize = RX_BUFFER_AGGRESIZE;
+		pRxCell->pNdisPacket = (PNDIS_PACKET) pNewPacket;
+		pRxCell->DmaBuf.AllocVa = AllocVa;
+		pRxCell->DmaBuf.AllocPa = AllocPa;
 		/* update SDP0 to new buffer of rx packet */
 		pRxD->SDP0 = AllocPa;
-	}
-	else
-	{
+	} else {
 		//DBGPRINT(RT_DEBUG_TRACE,("No Rx Buffer\n"));
 		pRxPacket = NULL;
 		bReschedule = TRUE;
@@ -880,7 +853,9 @@ PNDIS_PACKET GetPacketFromRxRing(
 	// update rx descriptor and kick rx
 	INC_RING_INDEX(pAd->RxRing.RxSwReadIdx, RX_RING_SIZE);
 
-	pAd->RxRing.RxCpuIdx = (pAd->RxRing.RxSwReadIdx == 0) ? (RX_RING_SIZE-1) : (pAd->RxRing.RxSwReadIdx-1);
+	pAd->RxRing.RxCpuIdx =
+	    (pAd->RxRing.RxSwReadIdx ==
+	     0) ? (RX_RING_SIZE - 1) : (pAd->RxRing.RxSwReadIdx - 1);
 	RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
 
 done:
@@ -889,55 +864,46 @@ done:
 	return pRxPacket;
 }
 
-
-NDIS_STATUS MlmeHardTransmitTxRing(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR	QueIdx,
-	IN	PNDIS_PACKET	pPacket)
+NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
+				   IN UCHAR QueIdx, IN PNDIS_PACKET pPacket)
 {
-	PACKET_INFO	PacketInfo;
-	PUCHAR			pSrcBufVA;
-	UINT			SrcBufLen;
-	PTXD_STRUC		pTxD;
-	PHEADER_802_11	pHeader_802_11;
-	BOOLEAN			bAckRequired, bInsertTimestamp;
-	ULONG			SrcBufPA;
-	//UCHAR			TxBufIdx;
-	UCHAR			MlmeRate;
-	ULONG			SwIdx = pAd->TxRing[QueIdx].TxCpuIdx;
-	PTXWI_STRUC	pFirstTxWI;
-	//ULONG	i;
-	//HTTRANSMIT_SETTING	MlmeTransmit;   //Rate for this MGMT frame.
-	ULONG	 FreeNum;
-	MAC_TABLE_ENTRY	*pMacEntry = NULL;
-
+	PACKET_INFO PacketInfo;
+	PUCHAR pSrcBufVA;
+	UINT SrcBufLen;
+	PTXD_STRUC pTxD;
+	PHEADER_802_11 pHeader_802_11;
+	BOOLEAN bAckRequired, bInsertTimestamp;
+	ULONG SrcBufPA;
+	//UCHAR                 TxBufIdx;
+	UCHAR MlmeRate;
+	ULONG SwIdx = pAd->TxRing[QueIdx].TxCpuIdx;
+	PTXWI_STRUC pFirstTxWI;
+	//ULONG i;
+	//HTTRANSMIT_SETTING    MlmeTransmit;   //Rate for this MGMT frame.
+	ULONG FreeNum;
+	MAC_TABLE_ENTRY *pMacEntry = NULL;
 
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
-
-	if (pSrcBufVA == NULL)
-	{
+	if (pSrcBufVA == NULL) {
 		// The buffer shouldn't be NULL
 		return NDIS_STATUS_FAILURE;
 	}
-
 	// Make sure MGMT ring resource won't be used by other threads
 	//NdisAcquireSpinLock(&pAd->TxRingLock);
 
 	FreeNum = GET_TXRING_FREENO(pAd, QueIdx);
 
-	if (FreeNum == 0)
-	{
+	if (FreeNum == 0) {
 		//NdisReleaseSpinLock(&pAd->TxRingLock);
 		return NDIS_STATUS_FAILURE;
 	}
 
 	SwIdx = pAd->TxRing[QueIdx].TxCpuIdx;
 
-	pTxD  = (PTXD_STRUC) pAd->TxRing[QueIdx].Cell[SwIdx].AllocVa;
+	pTxD = (PTXD_STRUC) pAd->TxRing[QueIdx].Cell[SwIdx].AllocVa;
 
-	if (pAd->TxRing[QueIdx].Cell[SwIdx].pNdisPacket)
-	{
+	if (pAd->TxRing[QueIdx].Cell[SwIdx].pNdisPacket) {
 		DBGPRINT(RT_DEBUG_OFF, ("MlmeHardTransmit Error\n"));
 		//NdisReleaseSpinLock(&pAd->TxRingLock);
 		return NDIS_STATUS_FAILURE;
@@ -949,26 +915,21 @@ NDIS_STATUS MlmeHardTransmitTxRing(
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 			AsicForceWakeup(pAd, TRUE);
 	}
-	pFirstTxWI	=(PTXWI_STRUC)pSrcBufVA;
+	pFirstTxWI = (PTXWI_STRUC) pSrcBufVA;
 
 	pHeader_802_11 = (PHEADER_802_11) (pSrcBufVA + TXWI_SIZE);
-	if (pHeader_802_11->Addr1[0] & 0x01)
-	{
+	if (pHeader_802_11->Addr1[0] & 0x01) {
 		MlmeRate = pAd->CommonCfg.BasicMlmeRate;
-	}
-	else
-	{
+	} else {
 		MlmeRate = pAd->CommonCfg.MlmeRate;
 	}
 
 	if ((pHeader_802_11->FC.Type == BTYPE_DATA) &&
-		(pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL))
-	{
+	    (pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL)) {
 		pMacEntry = MacTableLookup(pAd, pHeader_802_11->Addr1);
 	}
-
 	// Verify Mlme rate for a / g bands.
-	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6)) // 11A band
+	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6))	// 11A band
 		MlmeRate = RATE_6;
 
 	//
@@ -978,37 +939,33 @@ NDIS_STATUS MlmeHardTransmitTxRing(
 	//
 	//
 	// In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame
-    // Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD
-	if (pHeader_802_11->FC.Type != BTYPE_DATA)
-    {
-	if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_REQ) || !(pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable))
-	{
-		pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE;
-	}
-	else
-	{
-		pHeader_802_11->FC.PwrMgmt = pAd->CommonCfg.bAPSDForcePowerSave;
+	// Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD
+	if (pHeader_802_11->FC.Type != BTYPE_DATA) {
+		if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_REQ)
+		    || !(pAd->CommonCfg.bAPSDCapable
+			 && pAd->CommonCfg.APEdcaParm.bAPSDCapable)) {
+			pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE;
+		} else {
+			pHeader_802_11->FC.PwrMgmt =
+			    pAd->CommonCfg.bAPSDForcePowerSave;
+		}
 	}
-    }
 
 	bInsertTimestamp = FALSE;
-	if (pHeader_802_11->FC.Type == BTYPE_CNTL) // must be PS-POLL
+	if (pHeader_802_11->FC.Type == BTYPE_CNTL)	// must be PS-POLL
 	{
 		bAckRequired = FALSE;
-	}
-	else // BTYPE_MGMT or BTYPE_DATA(must be NULL frame)
+	} else			// BTYPE_MGMT or BTYPE_DATA(must be NULL frame)
 	{
-		if (pHeader_802_11->Addr1[0] & 0x01) // MULTICAST, BROADCAST
+		if (pHeader_802_11->Addr1[0] & 0x01)	// MULTICAST, BROADCAST
 		{
 			bAckRequired = FALSE;
 			pHeader_802_11->Duration = 0;
-		}
-		else
-		{
+		} else {
 			bAckRequired = TRUE;
-			pHeader_802_11->Duration = RTMPCalcDuration(pAd, MlmeRate, 14);
-			if (pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP)
-			{
+			pHeader_802_11->Duration =
+			    RTMPCalcDuration(pAd, MlmeRate, 14);
+			if (pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP) {
 				bInsertTimestamp = TRUE;
 			}
 		}
@@ -1019,14 +976,13 @@ NDIS_STATUS MlmeHardTransmitTxRing(
 	// Before radar detection done, mgmt frame can not be sent but probe req
 	// Because we need to use probe req to trigger driver to send probe req in passive scan
 	if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ)
-		&& (pAd->CommonCfg.bIEEE80211H == 1)
-		&& (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("MlmeHardTransmit --> radar detect not in normal mode !!!\n"));
+	    && (pAd->CommonCfg.bIEEE80211H == 1)
+	    && (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("MlmeHardTransmit --> radar detect not in normal mode !!!\n"));
 		//NdisReleaseSpinLock(&pAd->TxRingLock);
 		return (NDIS_STATUS_FAILURE);
 	}
-
 	//
 	// fill scatter-and-gather buffer list into TXD. Internally created NDIS PACKET
 	// should always has only one ohysical buffer, and the whole frame size equals
@@ -1036,30 +992,30 @@ NDIS_STATUS MlmeHardTransmitTxRing(
 	// Initialize TX Descriptor
 	// For inter-frame gap, the number is for this frame and next frame
 	// For MLME rate, we will fix as 2Mb to match other vendor's implement
-//	pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
+//      pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
 
 // management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not.
 	// Only beacon use Nseq=TRUE. So here we use Nseq=FALSE.
-	if (pMacEntry == NULL)
-	{
-	RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE, bInsertTimestamp, FALSE, bAckRequired, FALSE,
-		0, RESERVED_WCID, (SrcBufLen - TXWI_SIZE), PID_MGMT, 0,  (UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS, IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
-	}
-	else
-	{
+	if (pMacEntry == NULL) {
+		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE, bInsertTimestamp,
+			      FALSE, bAckRequired, FALSE, 0, RESERVED_WCID,
+			      (SrcBufLen - TXWI_SIZE), PID_MGMT, 0,
+			      (UCHAR) pAd->CommonCfg.MlmeTransmit.field.MCS,
+			      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
+	} else {
 		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE,
-					bInsertTimestamp, FALSE, bAckRequired, FALSE,
-					0, pMacEntry->Aid, (SrcBufLen - TXWI_SIZE),
-					pMacEntry->MaxHTPhyMode.field.MCS, 0,
-					(UCHAR)pMacEntry->MaxHTPhyMode.field.MCS,
-					IFS_BACKOFF, FALSE, &pMacEntry->MaxHTPhyMode);
+			      bInsertTimestamp, FALSE, bAckRequired, FALSE,
+			      0, pMacEntry->Aid, (SrcBufLen - TXWI_SIZE),
+			      pMacEntry->MaxHTPhyMode.field.MCS, 0,
+			      (UCHAR) pMacEntry->MaxHTPhyMode.field.MCS,
+			      IFS_BACKOFF, FALSE, &pMacEntry->MaxHTPhyMode);
 	}
 
 	pAd->TxRing[QueIdx].Cell[SwIdx].pNdisPacket = pPacket;
 	pAd->TxRing[QueIdx].Cell[SwIdx].pNextNdisPacket = NULL;
-//	pFirstTxWI->MPDUtotalByteCount = SrcBufLen - TXWI_SIZE;
-	SrcBufPA = PCI_MAP_SINGLE(pAd, pSrcBufVA, SrcBufLen, 0, PCI_DMA_TODEVICE);
-
+//      pFirstTxWI->MPDUtotalByteCount = SrcBufLen - TXWI_SIZE;
+	SrcBufPA =
+	    PCI_MAP_SINGLE(pAd, pSrcBufVA, SrcBufLen, 0, PCI_DMA_TODEVICE);
 
 	RTMPWriteTxDescriptor(pAd, pTxD, TRUE, FIFO_EDCA);
 	pTxD->LastSec0 = 1;
@@ -1069,37 +1025,32 @@ NDIS_STATUS MlmeHardTransmitTxRing(
 	pTxD->SDPtr0 = SrcBufPA;
 	pTxD->DMADONE = 0;
 
-
 	pAd->RalinkCounters.KickTxCount++;
 	pAd->RalinkCounters.OneSecTxDoneCount++;
 
 	// Increase TX_CTX_IDX, but write to register later.
 	INC_RING_INDEX(pAd->TxRing[QueIdx].TxCpuIdx, TX_RING_SIZE);
 
-	RTMP_IO_WRITE32(pAd, TX_CTX_IDX0 + QueIdx*0x10,  pAd->TxRing[QueIdx].TxCpuIdx);
+	RTMP_IO_WRITE32(pAd, TX_CTX_IDX0 + QueIdx * 0x10,
+			pAd->TxRing[QueIdx].TxCpuIdx);
 
 	// Make sure to release MGMT ring resource
-//	NdisReleaseSpinLock(&pAd->TxRingLock);
+//      NdisReleaseSpinLock(&pAd->TxRingLock);
 
 	return NDIS_STATUS_SUCCESS;
 }
 
-
-NDIS_STATUS MlmeDataHardTransmit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR	QueIdx,
-	IN	PNDIS_PACKET	pPacket)
+NDIS_STATUS MlmeDataHardTransmit(IN PRTMP_ADAPTER pAd,
+				 IN UCHAR QueIdx, IN PNDIS_PACKET pPacket)
 {
 	if ((pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)
-		)
-	{
+	    ) {
 		return NDIS_STATUS_FAILURE;
 	}
 
-	return MlmeHardTransmitTxRing(pAd,QueIdx,pPacket);
+	return MlmeHardTransmitTxRing(pAd, QueIdx, pPacket);
 }
 
-
 /*
 	========================================================================
 
@@ -1127,11 +1078,9 @@ NDIS_STATUS MlmeDataHardTransmit(
 
 	========================================================================
 */
-VOID RTMPWriteTxDescriptor(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PTXD_STRUC		pTxD,
-	IN	BOOLEAN			bWIV,
-	IN	UCHAR			QueueSEL)
+VOID RTMPWriteTxDescriptor(IN PRTMP_ADAPTER pAd,
+			   IN PTXD_STRUC pTxD,
+			   IN BOOLEAN bWIV, IN UCHAR QueueSEL)
 {
 	//
 	// Always use Long preamble before verifiation short preamble functionality works well.
@@ -1139,8 +1088,8 @@ VOID RTMPWriteTxDescriptor(
 	//
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
 
-	pTxD->WIV	= (bWIV) ? 1: 0;
-	pTxD->QSEL= (QueueSEL);
+	pTxD->WIV = (bWIV) ? 1 : 0;
+	pTxD->QSEL = (QueueSEL);
 	//RT2860c??  fixed using EDCA queue for test...  We doubt Queue1 has problem.  2006-09-26 Jan
 	//pTxD->QSEL= FIFO_EDCA;
 	pTxD->DMADONE = 0;
--- a/drivers/staging/rt2860/common/cmm_data_usb.c
+++ b/drivers/staging/rt2860/common/cmm_data_usb.c
@@ -33,52 +33,44 @@
 
 #ifdef RTMP_MAC_USB
 
-
 #include	"../rt_config.h"
 
-
 /*
 	We can do copy the frame into pTxContext when match following conditions.
 		=>
 		=>
 		=>
 */
-static inline NDIS_STATUS RtmpUSBCanDoWrite(
-	IN RTMP_ADAPTER		*pAd,
-	IN UCHAR			QueIdx,
-	IN HT_TX_CONTEXT	*pHTTXContext)
-{
-	NDIS_STATUS	canWrite = NDIS_STATUS_RESOURCES;
-
-	if (((pHTTXContext->CurWritePosition) < pHTTXContext->NextBulkOutPosition) && (pHTTXContext->CurWritePosition + LOCAL_TXBUF_SIZE) > pHTTXContext->NextBulkOutPosition)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("RtmpUSBCanDoWrite c1!\n"));
-		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
-	}
-	else if ((pHTTXContext->CurWritePosition == 8) && (pHTTXContext->NextBulkOutPosition < LOCAL_TXBUF_SIZE))
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("RtmpUSBCanDoWrite c2!\n"));
-		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
-	}
-	else if (pHTTXContext->bCurWriting == TRUE)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("RtmpUSBCanDoWrite c3!\n"));
-	}
-	else
-	{
+static inline NDIS_STATUS RtmpUSBCanDoWrite(IN RTMP_ADAPTER * pAd,
+					    IN UCHAR QueIdx,
+					    IN HT_TX_CONTEXT * pHTTXContext)
+{
+	NDIS_STATUS canWrite = NDIS_STATUS_RESOURCES;
+
+	if (((pHTTXContext->CurWritePosition) <
+	     pHTTXContext->NextBulkOutPosition)
+	    && (pHTTXContext->CurWritePosition + LOCAL_TXBUF_SIZE) >
+	    pHTTXContext->NextBulkOutPosition) {
+		DBGPRINT(RT_DEBUG_ERROR, ("RtmpUSBCanDoWrite c1!\n"));
+		RTUSB_SET_BULK_FLAG(pAd,
+				    (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
+	} else if ((pHTTXContext->CurWritePosition == 8)
+		   && (pHTTXContext->NextBulkOutPosition < LOCAL_TXBUF_SIZE)) {
+		DBGPRINT(RT_DEBUG_ERROR, ("RtmpUSBCanDoWrite c2!\n"));
+		RTUSB_SET_BULK_FLAG(pAd,
+				    (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
+	} else if (pHTTXContext->bCurWriting == TRUE) {
+		DBGPRINT(RT_DEBUG_ERROR, ("RtmpUSBCanDoWrite c3!\n"));
+	} else {
 		canWrite = NDIS_STATUS_SUCCESS;
 	}
 
-
 	return canWrite;
 }
 
-
-USHORT RtmpUSB_WriteSubTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber)
+USHORT RtmpUSB_WriteSubTxResource(IN PRTMP_ADAPTER pAd,
+				  IN TX_BLK * pTxBlk,
+				  IN BOOLEAN bIsLast, OUT USHORT * FreeNumber)
 {
 
 	// Dummy function. Should be removed in the future.
@@ -86,83 +78,80 @@ USHORT RtmpUSB_WriteSubTxResource(
 
 }
 
-USHORT	RtmpUSB_WriteFragTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			fragNum,
-	OUT	USHORT			*FreeNumber)
-{
-	HT_TX_CONTEXT	*pHTTXContext;
-	USHORT			hwHdrLen;	// The hwHdrLen consist of 802.11 header length plus the header padding length.
-	UINT32			fillOffset;
-	TXINFO_STRUC	*pTxInfo;
-	TXWI_STRUC		*pTxWI;
-	PUCHAR			pWirelessPacket = NULL;
-	UCHAR			QueIdx;
-	NDIS_STATUS		Status;
-	unsigned long	IrqFlags;
-	UINT32			USBDMApktLen = 0, DMAHdrLen, padding;
-	BOOLEAN			TxQLastRound = FALSE;
+USHORT RtmpUSB_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
+				   IN TX_BLK * pTxBlk,
+				   IN UCHAR fragNum, OUT USHORT * FreeNumber)
+{
+	HT_TX_CONTEXT *pHTTXContext;
+	USHORT hwHdrLen;	// The hwHdrLen consist of 802.11 header length plus the header padding length.
+	UINT32 fillOffset;
+	TXINFO_STRUC *pTxInfo;
+	TXWI_STRUC *pTxWI;
+	PUCHAR pWirelessPacket = NULL;
+	UCHAR QueIdx;
+	NDIS_STATUS Status;
+	unsigned long IrqFlags;
+	UINT32 USBDMApktLen = 0, DMAHdrLen, padding;
+	BOOLEAN TxQLastRound = FALSE;
 
 	//
 	// get Tx Ring Resource & Dma Buffer address
 	//
 	QueIdx = pTxBlk->QueIdx;
-	pHTTXContext  = &pAd->TxContext[QueIdx];
+	pHTTXContext = &pAd->TxContext[QueIdx];
 
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-	pHTTXContext  = &pAd->TxContext[QueIdx];
+	pHTTXContext = &pAd->TxContext[QueIdx];
 	fillOffset = pHTTXContext->CurWritePosition;
 
-	if(fragNum == 0)
-	{
+	if (fragNum == 0) {
 		// Check if we have enough space for this bulk-out batch.
 		Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
-		if (Status == NDIS_STATUS_SUCCESS)
-		{
+		if (Status == NDIS_STATUS_SUCCESS) {
 			pHTTXContext->bCurWriting = TRUE;
 
 			// Reserve space for 8 bytes padding.
-			if ((pHTTXContext->ENextBulkOutPosition == pHTTXContext->CurWritePosition))
-			{
+			if ((pHTTXContext->ENextBulkOutPosition ==
+			     pHTTXContext->CurWritePosition)) {
 				pHTTXContext->ENextBulkOutPosition += 8;
 				pHTTXContext->CurWritePosition += 8;
 				fillOffset += 8;
 			}
 			pTxBlk->Priv = 0;
-			pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
-		}
-		else
-		{
-			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
-			return(Status);
+			pHTTXContext->CurWriteRealPos =
+			    pHTTXContext->CurWritePosition;
+		} else {
+			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx],
+					IrqFlags);
+
+			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
+					    NDIS_STATUS_FAILURE);
+			return (Status);
 		}
-	}
-	else
-	{
+	} else {
 		// For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer.
-		Status = ((pHTTXContext->bCurWriting == TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
-		if (Status == NDIS_STATUS_SUCCESS)
-		{
+		Status =
+		    ((pHTTXContext->bCurWriting ==
+		      TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
+		if (Status == NDIS_STATUS_SUCCESS) {
 			fillOffset += pTxBlk->Priv;
-		}
-		else
-		{
-			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+		} else {
+			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx],
+					IrqFlags);
 
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
-			return(Status);
+			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
+					    NDIS_STATUS_FAILURE);
+			return (Status);
 		}
 	}
 
-	NdisZeroMemory((PUCHAR)(&pTxBlk->HeaderBuf[0]), TXINFO_SIZE);
-	pTxInfo = (PTXINFO_STRUC)(&pTxBlk->HeaderBuf[0]);
-	pTxWI= (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]);
+	NdisZeroMemory((PUCHAR) (&pTxBlk->HeaderBuf[0]), TXINFO_SIZE);
+	pTxInfo = (PTXINFO_STRUC) (&pTxBlk->HeaderBuf[0]);
+	pTxWI = (PTXWI_STRUC) (&pTxBlk->HeaderBuf[TXINFO_SIZE]);
 
-	pWirelessPacket = &pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset];
+	pWirelessPacket =
+	    &pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset];
 
 	// copy TXWI + WLAN Header + LLC into DMA Header Buffer
 	//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
@@ -177,23 +166,22 @@ USHORT	RtmpUSB_WriteFragTxResource(
 	pTxBlk->Priv += (TXINFO_SIZE + USBDMApktLen);
 
 	// For TxInfo, the length of USBDMApktLen = TXWI_SIZE + 802.11 header + payload
-	RTMPWriteTxInfo(pAd, pTxInfo, (USHORT)(USBDMApktLen), FALSE, FIFO_EDCA, FALSE /*NextValid*/,  FALSE);
+	RTMPWriteTxInfo(pAd, pTxInfo, (USHORT) (USBDMApktLen), FALSE, FIFO_EDCA,
+			FALSE /*NextValid */ , FALSE);
 
-	if (fragNum == pTxBlk->TotalFragNum)
-	{
+	if (fragNum == pTxBlk->TotalFragNum) {
 		pTxInfo->USBDMATxburst = 0;
-		if ((pHTTXContext->CurWritePosition + pTxBlk->Priv + 3906)> MAX_TXBULK_LIMIT)
-		{
+		if ((pHTTXContext->CurWritePosition + pTxBlk->Priv + 3906) >
+		    MAX_TXBULK_LIMIT) {
 			pTxInfo->SwUseLastRound = 1;
 			TxQLastRound = TRUE;
 		}
-	}
-	else
-	{
+	} else {
 		pTxInfo->USBDMATxburst = 1;
 	}
 
-	NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf, TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
+	NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
+		       TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 	pWirelessPacket += (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 	pHTTXContext->CurWriteRealPos += (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 
@@ -201,12 +189,11 @@ USHORT	RtmpUSB_WriteFragTxResource(
 
 	NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData, pTxBlk->SrcBufLen);
 
-	//	Zero the last padding.
+	//      Zero the last padding.
 	pWirelessPacket += pTxBlk->SrcBufLen;
 	NdisZeroMemory(pWirelessPacket, padding + 8);
 
-	if (fragNum == pTxBlk->TotalFragNum)
-	{
+	if (fragNum == pTxBlk->TotalFragNum) {
 		RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
 		// Update the pHTTXContext->CurWritePosition. 3906 used to prevent the NextBulkOut is a A-RALINK/A-MSDU Frame.
@@ -215,9 +202,8 @@ USHORT	RtmpUSB_WriteFragTxResource(
 			pHTTXContext->CurWritePosition = 8;
 		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
 
-
 		// Finally, set bCurWriting as FALSE
-	pHTTXContext->bCurWriting = FALSE;
+		pHTTXContext->bCurWriting = FALSE;
 
 		RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
@@ -225,64 +211,59 @@ USHORT	RtmpUSB_WriteFragTxResource(
 		RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
 	}
 
-
-	return(Status);
+	return (Status);
 
 }
 
-
-USHORT RtmpUSB_WriteSingleTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber)
-{
-	HT_TX_CONTEXT	*pHTTXContext;
-	USHORT			hwHdrLen;
-	UINT32			fillOffset;
-	TXINFO_STRUC	*pTxInfo;
-	TXWI_STRUC		*pTxWI;
-	PUCHAR			pWirelessPacket;
-	UCHAR			QueIdx;
-	unsigned long	IrqFlags;
-	NDIS_STATUS		Status;
-	UINT32			USBDMApktLen = 0, DMAHdrLen, padding;
-	BOOLEAN			bTxQLastRound = FALSE;
+USHORT RtmpUSB_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
+				     IN TX_BLK * pTxBlk,
+				     IN BOOLEAN bIsLast,
+				     OUT USHORT * FreeNumber)
+{
+	HT_TX_CONTEXT *pHTTXContext;
+	USHORT hwHdrLen;
+	UINT32 fillOffset;
+	TXINFO_STRUC *pTxInfo;
+	TXWI_STRUC *pTxWI;
+	PUCHAR pWirelessPacket;
+	UCHAR QueIdx;
+	unsigned long IrqFlags;
+	NDIS_STATUS Status;
+	UINT32 USBDMApktLen = 0, DMAHdrLen, padding;
+	BOOLEAN bTxQLastRound = FALSE;
 
 	// For USB, didn't need PCI_MAP_SINGLE()
 	//SrcBufPA = PCI_MAP_SINGLE(pAd, (char *) pTxBlk->pSrcBufData, pTxBlk->SrcBufLen, PCI_DMA_TODEVICE);
 
-
 	//
 	// get Tx Ring Resource & Dma Buffer address
 	//
 	QueIdx = pTxBlk->QueIdx;
 
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-	pHTTXContext  = &pAd->TxContext[QueIdx];
+	pHTTXContext = &pAd->TxContext[QueIdx];
 	fillOffset = pHTTXContext->CurWritePosition;
 
-
-
 	// Check ring full.
 	Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
-	if(Status == NDIS_STATUS_SUCCESS)
-	{
+	if (Status == NDIS_STATUS_SUCCESS) {
 		pHTTXContext->bCurWriting = TRUE;
 
-		pTxInfo = (PTXINFO_STRUC)(&pTxBlk->HeaderBuf[0]);
-		pTxWI= (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]);
+		pTxInfo = (PTXINFO_STRUC) (&pTxBlk->HeaderBuf[0]);
+		pTxWI = (PTXWI_STRUC) (&pTxBlk->HeaderBuf[TXINFO_SIZE]);
 
 		// Reserve space for 8 bytes padding.
-		if ((pHTTXContext->ENextBulkOutPosition == pHTTXContext->CurWritePosition))
-		{
+		if ((pHTTXContext->ENextBulkOutPosition ==
+		     pHTTXContext->CurWritePosition)) {
 			pHTTXContext->ENextBulkOutPosition += 8;
 			pHTTXContext->CurWritePosition += 8;
 			fillOffset += 8;
 		}
 		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
 
-		pWirelessPacket = &pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset];
+		pWirelessPacket =
+		    &pHTTXContext->TransferBuffer->field.
+		    WirelessPacket[fillOffset];
 
 		// copy TXWI + WLAN Header + LLC into DMA Header Buffer
 		//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
@@ -297,30 +278,34 @@ USHORT RtmpUSB_WriteSingleTxResource(
 		pTxBlk->Priv = (TXINFO_SIZE + USBDMApktLen);
 
 		// For TxInfo, the length of USBDMApktLen = TXWI_SIZE + 802.11 header + payload
-		RTMPWriteTxInfo(pAd, pTxInfo, (USHORT)(USBDMApktLen), FALSE, FIFO_EDCA, FALSE /*NextValid*/,  FALSE);
+		RTMPWriteTxInfo(pAd, pTxInfo, (USHORT) (USBDMApktLen), FALSE,
+				FIFO_EDCA, FALSE /*NextValid */ , FALSE);
 
-		if ((pHTTXContext->CurWritePosition + 3906 + pTxBlk->Priv) > MAX_TXBULK_LIMIT)
-		{
+		if ((pHTTXContext->CurWritePosition + 3906 + pTxBlk->Priv) >
+		    MAX_TXBULK_LIMIT) {
 			pTxInfo->SwUseLastRound = 1;
 			bTxQLastRound = TRUE;
 		}
-		NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf, TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
+		NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
+			       TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 		pWirelessPacket += (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 
 		// We unlock it here to prevent the first 8 bytes maybe over-writed issue.
-		//	1. First we got CurWritePosition but the first 8 bytes still not write to the pTxcontext.
-		//	2. An interrupt break our routine and handle bulk-out complete.
-		//	3. In the bulk-out compllete, it need to do another bulk-out,
-		//			if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition,
-		//			but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE.
-		//	4. Interrupt complete.
+		//      1. First we got CurWritePosition but the first 8 bytes still not write to the pTxcontext.
+		//      2. An interrupt break our routine and handle bulk-out complete.
+		//      3. In the bulk-out compllete, it need to do another bulk-out,
+		//                      if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition,
+		//                      but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE.
+		//      4. Interrupt complete.
 		//  5. Our interrupted routine go back and fill the first 8 bytes to pTxContext.
-		//	6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition.
-		//		and the packet will wrong.
-		pHTTXContext->CurWriteRealPos += (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
+		//      6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition.
+		//              and the packet will wrong.
+		pHTTXContext->CurWriteRealPos +=
+		    (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 		RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-		NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData, pTxBlk->SrcBufLen);
+		NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData,
+			       pTxBlk->SrcBufLen);
 		pWirelessPacket += pTxBlk->SrcBufLen;
 		NdisZeroMemory(pWirelessPacket, padding + 8);
 
@@ -331,135 +316,144 @@ USHORT RtmpUSB_WriteSingleTxResource(
 			pHTTXContext->CurWritePosition = 8;
 		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
 
-	pHTTXContext->bCurWriting = FALSE;
+		pHTTXContext->bCurWriting = FALSE;
 	}
 
-
 	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-
 	// succeed and release the skb buffer
 	RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
 
-	return(Status);
+	return (Status);
 
 }
 
-
-USHORT RtmpUSB_WriteMultiTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			frameNum,
-	OUT	USHORT			*FreeNumber)
-{
-	HT_TX_CONTEXT	*pHTTXContext;
-	USHORT			hwHdrLen;	// The hwHdrLen consist of 802.11 header length plus the header padding length.
-	UINT32			fillOffset;
-	TXINFO_STRUC	*pTxInfo;
-	TXWI_STRUC		*pTxWI;
-	PUCHAR			pWirelessPacket = NULL;
-	UCHAR			QueIdx;
-	NDIS_STATUS		Status;
-	unsigned long	IrqFlags;
-	//UINT32			USBDMApktLen = 0, DMAHdrLen, padding;
+USHORT RtmpUSB_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
+				    IN TX_BLK * pTxBlk,
+				    IN UCHAR frameNum, OUT USHORT * FreeNumber)
+{
+	HT_TX_CONTEXT *pHTTXContext;
+	USHORT hwHdrLen;	// The hwHdrLen consist of 802.11 header length plus the header padding length.
+	UINT32 fillOffset;
+	TXINFO_STRUC *pTxInfo;
+	TXWI_STRUC *pTxWI;
+	PUCHAR pWirelessPacket = NULL;
+	UCHAR QueIdx;
+	NDIS_STATUS Status;
+	unsigned long IrqFlags;
+	//UINT32                        USBDMApktLen = 0, DMAHdrLen, padding;
 
 	//
 	// get Tx Ring Resource & Dma Buffer address
 	//
 	QueIdx = pTxBlk->QueIdx;
-	pHTTXContext  = &pAd->TxContext[QueIdx];
+	pHTTXContext = &pAd->TxContext[QueIdx];
 
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-	if(frameNum == 0)
-	{
+	if (frameNum == 0) {
 		// Check if we have enough space for this bulk-out batch.
 		Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
-		if (Status == NDIS_STATUS_SUCCESS)
-		{
+		if (Status == NDIS_STATUS_SUCCESS) {
 			pHTTXContext->bCurWriting = TRUE;
 
-			pTxInfo = (PTXINFO_STRUC)(&pTxBlk->HeaderBuf[0]);
-			pTxWI= (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]);
-
+			pTxInfo = (PTXINFO_STRUC) (&pTxBlk->HeaderBuf[0]);
+			pTxWI = (PTXWI_STRUC) (&pTxBlk->HeaderBuf[TXINFO_SIZE]);
 
 			// Reserve space for 8 bytes padding.
-			if ((pHTTXContext->ENextBulkOutPosition == pHTTXContext->CurWritePosition))
-			{
+			if ((pHTTXContext->ENextBulkOutPosition ==
+			     pHTTXContext->CurWritePosition)) {
 
 				pHTTXContext->CurWritePosition += 8;
 				pHTTXContext->ENextBulkOutPosition += 8;
 			}
 			fillOffset = pHTTXContext->CurWritePosition;
-			pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
+			pHTTXContext->CurWriteRealPos =
+			    pHTTXContext->CurWritePosition;
 
-			pWirelessPacket = &pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset];
+			pWirelessPacket =
+			    &pHTTXContext->TransferBuffer->field.
+			    WirelessPacket[fillOffset];
 
 			//
 			// Copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
 			//
 			if (pTxBlk->TxFrameType == TX_AMSDU_FRAME)
 				//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD;
-				hwHdrLen = pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD + pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
+				hwHdrLen =
+				    pTxBlk->MpduHeaderLen -
+				    LENGTH_AMSDU_SUBFRAMEHEAD +
+				    pTxBlk->HdrPadLen +
+				    LENGTH_AMSDU_SUBFRAMEHEAD;
 			else if (pTxBlk->TxFrameType == TX_RALINK_FRAME)
 				//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD, 4)+LENGTH_ARALINK_HEADER_FIELD;
-				hwHdrLen = pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD + pTxBlk->HdrPadLen + LENGTH_ARALINK_HEADER_FIELD;
+				hwHdrLen =
+				    pTxBlk->MpduHeaderLen -
+				    LENGTH_ARALINK_HEADER_FIELD +
+				    pTxBlk->HdrPadLen +
+				    LENGTH_ARALINK_HEADER_FIELD;
 			else
 				//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
-				hwHdrLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
+				hwHdrLen =
+				    pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
 			// Update the pTxBlk->Priv.
 			pTxBlk->Priv = TXINFO_SIZE + TXWI_SIZE + hwHdrLen;
 
-			//	pTxInfo->USBDMApktLen now just a temp value and will to correct latter.
-			RTMPWriteTxInfo(pAd, pTxInfo, (USHORT)(pTxBlk->Priv), FALSE, FIFO_EDCA, FALSE /*NextValid*/,  FALSE);
+			//      pTxInfo->USBDMApktLen now just a temp value and will to correct latter.
+			RTMPWriteTxInfo(pAd, pTxInfo, (USHORT) (pTxBlk->Priv),
+					FALSE, FIFO_EDCA, FALSE /*NextValid */ ,
+					FALSE);
 
 			// Copy it.
-			NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf, pTxBlk->Priv);
+			NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
+				       pTxBlk->Priv);
 			pHTTXContext->CurWriteRealPos += pTxBlk->Priv;
 			pWirelessPacket += pTxBlk->Priv;
 		}
-	}
-	else
-	{	// For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer.
+	} else {		// For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer.
 
-		Status = ((pHTTXContext->bCurWriting == TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
-		if (Status == NDIS_STATUS_SUCCESS)
-		{
-			fillOffset =  (pHTTXContext->CurWritePosition + pTxBlk->Priv);
-			pWirelessPacket = &pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset];
+		Status =
+		    ((pHTTXContext->bCurWriting ==
+		      TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
+		if (Status == NDIS_STATUS_SUCCESS) {
+			fillOffset =
+			    (pHTTXContext->CurWritePosition + pTxBlk->Priv);
+			pWirelessPacket =
+			    &pHTTXContext->TransferBuffer->field.
+			    WirelessPacket[fillOffset];
 
 			//hwHdrLen = pTxBlk->MpduHeaderLen;
-			NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf, pTxBlk->MpduHeaderLen);
+			NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
+				       pTxBlk->MpduHeaderLen);
 			pWirelessPacket += (pTxBlk->MpduHeaderLen);
 			pTxBlk->Priv += pTxBlk->MpduHeaderLen;
-		}
-		else
-		{	// It should not happened now unless we are going to shutdown.
-			DBGPRINT(RT_DEBUG_ERROR, ("WriteMultiTxResource():bCurWriting is FALSE when handle sub-sequent frames.\n"));
+		} else {	// It should not happened now unless we are going to shutdown.
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("WriteMultiTxResource():bCurWriting is FALSE when handle sub-sequent frames.\n"));
 			Status = NDIS_STATUS_FAILURE;
 		}
 	}
 
-
 	// We unlock it here to prevent the first 8 bytes maybe over-write issue.
-	//	1. First we got CurWritePosition but the first 8 bytes still not write to the pTxContext.
-	//	2. An interrupt break our routine and handle bulk-out complete.
-	//	3. In the bulk-out compllete, it need to do another bulk-out,
-	//			if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition,
-	//			but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE.
-	//	4. Interrupt complete.
+	//      1. First we got CurWritePosition but the first 8 bytes still not write to the pTxContext.
+	//      2. An interrupt break our routine and handle bulk-out complete.
+	//      3. In the bulk-out compllete, it need to do another bulk-out,
+	//                      if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition,
+	//                      but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE.
+	//      4. Interrupt complete.
 	//  5. Our interrupted routine go back and fill the first 8 bytes to pTxContext.
-	//	6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition.
-	//		and the packet will wrong.
+	//      6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition.
+	//              and the packet will wrong.
 	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-	if (Status != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("WriteMultiTxResource: CWPos = %ld, NBOutPos = %ld.\n", pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition));
+	if (Status != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("WriteMultiTxResource: CWPos = %ld, NBOutPos = %ld.\n",
+			  pHTTXContext->CurWritePosition,
+			  pHTTXContext->NextBulkOutPosition));
 		goto done;
 	}
-
 	// Copy the frame content into DMA buffer and update the pTxBlk->Priv
 	NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData, pTxBlk->SrcBufLen);
 	pWirelessPacket += pTxBlk->SrcBufLen;
@@ -469,45 +463,46 @@ done:
 	// Release the skb buffer here
 	RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
 
-	return(Status);
+	return (Status);
 
 }
 
-
-VOID RtmpUSB_FinalWriteTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	USHORT			totalMPDUSize,
-	IN	USHORT			TxIdx)
-{
-	UCHAR			QueIdx;
-	HT_TX_CONTEXT	*pHTTXContext;
-	UINT32			fillOffset;
-	TXINFO_STRUC	*pTxInfo;
-	TXWI_STRUC		*pTxWI;
-	UINT32			USBDMApktLen, padding;
-	unsigned long	IrqFlags;
-	PUCHAR			pWirelessPacket;
+VOID RtmpUSB_FinalWriteTxResource(IN PRTMP_ADAPTER pAd,
+				  IN TX_BLK * pTxBlk,
+				  IN USHORT totalMPDUSize, IN USHORT TxIdx)
+{
+	UCHAR QueIdx;
+	HT_TX_CONTEXT *pHTTXContext;
+	UINT32 fillOffset;
+	TXINFO_STRUC *pTxInfo;
+	TXWI_STRUC *pTxWI;
+	UINT32 USBDMApktLen, padding;
+	unsigned long IrqFlags;
+	PUCHAR pWirelessPacket;
 
 	QueIdx = pTxBlk->QueIdx;
-	pHTTXContext  = &pAd->TxContext[QueIdx];
+	pHTTXContext = &pAd->TxContext[QueIdx];
 
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-	if (pHTTXContext->bCurWriting == TRUE)
-	{
+	if (pHTTXContext->bCurWriting == TRUE) {
 		fillOffset = pHTTXContext->CurWritePosition;
-		if (((pHTTXContext->ENextBulkOutPosition == pHTTXContext->CurWritePosition) || ((pHTTXContext->ENextBulkOutPosition-8) == pHTTXContext->CurWritePosition))
-			&& (pHTTXContext->bCopySavePad == TRUE))
-			pWirelessPacket = (PUCHAR)(&pHTTXContext->SavedPad[0]);
+		if (((pHTTXContext->ENextBulkOutPosition ==
+		      pHTTXContext->CurWritePosition)
+		     || ((pHTTXContext->ENextBulkOutPosition - 8) ==
+			 pHTTXContext->CurWritePosition))
+		    && (pHTTXContext->bCopySavePad == TRUE))
+			pWirelessPacket = (PUCHAR) (&pHTTXContext->SavedPad[0]);
 		else
-			pWirelessPacket = (PUCHAR)(&pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset]);
+			pWirelessPacket =
+			    (PUCHAR) (&pHTTXContext->TransferBuffer->field.
+				      WirelessPacket[fillOffset]);
 
 		//
 		// Update TxInfo->USBDMApktLen ,
-		//		the length = TXWI_SIZE + 802.11_hdr + 802.11_hdr_pad + payload_of_all_batch_frames + Bulk-Out-padding
+		//              the length = TXWI_SIZE + 802.11_hdr + 802.11_hdr_pad + payload_of_all_batch_frames + Bulk-Out-padding
 		//
-		pTxInfo = (PTXINFO_STRUC)(pWirelessPacket);
+		pTxInfo = (PTXINFO_STRUC) (pWirelessPacket);
 
 		// Calculate the bulk-out padding
 		USBDMApktLen = pTxBlk->Priv - TXINFO_SIZE;
@@ -518,51 +513,46 @@ VOID RtmpUSB_FinalWriteTxResource(
 
 		//
 		// Update TXWI->MPDUtotalByteCount ,
-		//		the length = 802.11 header + payload_of_all_batch_frames
-		pTxWI= (PTXWI_STRUC)(pWirelessPacket + TXINFO_SIZE);
+		//              the length = 802.11 header + payload_of_all_batch_frames
+		pTxWI = (PTXWI_STRUC) (pWirelessPacket + TXINFO_SIZE);
 		pTxWI->MPDUtotalByteCount = totalMPDUSize;
 
 		//
 		// Update the pHTTXContext->CurWritePosition
 		//
 		pHTTXContext->CurWritePosition += (TXINFO_SIZE + USBDMApktLen);
-		if ((pHTTXContext->CurWritePosition + 3906)> MAX_TXBULK_LIMIT)
-		{	// Add 3906 for prevent the NextBulkOut packet size is a A-RALINK/A-MSDU Frame.
+		if ((pHTTXContext->CurWritePosition + 3906) > MAX_TXBULK_LIMIT) {	// Add 3906 for prevent the NextBulkOut packet size is a A-RALINK/A-MSDU Frame.
 			pHTTXContext->CurWritePosition = 8;
 			pTxInfo->SwUseLastRound = 1;
 		}
 		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
 
-
 		//
-		//	Zero the last padding.
+		//      Zero the last padding.
 		//
-		pWirelessPacket = (&pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset + pTxBlk->Priv]);
+		pWirelessPacket =
+		    (&pHTTXContext->TransferBuffer->field.
+		     WirelessPacket[fillOffset + pTxBlk->Priv]);
 		NdisZeroMemory(pWirelessPacket, padding + 8);
 
 		// Finally, set bCurWriting as FALSE
 		pHTTXContext->bCurWriting = FALSE;
 
-	}
-	else
-	{	// It should not happened now unless we are going to shutdown.
-		DBGPRINT(RT_DEBUG_ERROR, ("FinalWriteTxResource():bCurWriting is FALSE when handle last frames.\n"));
+	} else {		// It should not happened now unless we are going to shutdown.
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("FinalWriteTxResource():bCurWriting is FALSE when handle last frames.\n"));
 	}
 
 	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
 }
 
-
-VOID RtmpUSBDataLastTxIdx(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			QueIdx,
-	IN	USHORT			TxIdx)
+VOID RtmpUSBDataLastTxIdx(IN PRTMP_ADAPTER pAd,
+			  IN UCHAR QueIdx, IN USHORT TxIdx)
 {
 	// DO nothing for USB.
 }
 
-
 /*
 	When can do bulk-out:
 		1. TxSwFreeIdx < TX_RING_SIZE;
@@ -571,45 +561,41 @@ VOID RtmpUSBDataLastTxIdx(
 			Check if the CurWriting flag is FALSE, if it's FALSE, we can do kick out.
 
 */
-VOID RtmpUSBDataKickOut(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			QueIdx)
+VOID RtmpUSBDataKickOut(IN PRTMP_ADAPTER pAd,
+			IN TX_BLK * pTxBlk, IN UCHAR QueIdx)
 {
 	RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << QueIdx));
 	RTUSBKickBulkOut(pAd);
 
 }
 
-
 /*
 	Must be run in Interrupt context
 	This function handle RT2870 specific TxDesc and cpu index update and kick the packet out.
  */
-int RtmpUSBMgmtKickOut(
-	IN RTMP_ADAPTER		*pAd,
-	IN UCHAR			QueIdx,
-	IN PNDIS_PACKET		pPacket,
-	IN PUCHAR			pSrcBufVA,
-	IN UINT				SrcBufLen)
-{
-	PTXINFO_STRUC	pTxInfo;
-	ULONG			BulkOutSize;
-	UCHAR			padLen;
-	PUCHAR			pDest;
-	ULONG			SwIdx = pAd->MgmtRing.TxCpuIdx;
-	PTX_CONTEXT		pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[SwIdx].AllocVa;
-	unsigned long	IrqFlags;
+int RtmpUSBMgmtKickOut(IN RTMP_ADAPTER * pAd,
+		       IN UCHAR QueIdx,
+		       IN PNDIS_PACKET pPacket,
+		       IN PUCHAR pSrcBufVA, IN UINT SrcBufLen)
+{
+	PTXINFO_STRUC pTxInfo;
+	ULONG BulkOutSize;
+	UCHAR padLen;
+	PUCHAR pDest;
+	ULONG SwIdx = pAd->MgmtRing.TxCpuIdx;
+	PTX_CONTEXT pMLMEContext =
+	    (PTX_CONTEXT) pAd->MgmtRing.Cell[SwIdx].AllocVa;
+	unsigned long IrqFlags;
 
-
-	pTxInfo = (PTXINFO_STRUC)(pSrcBufVA);
+	pTxInfo = (PTXINFO_STRUC) (pSrcBufVA);
 
 	// Build our URB for USBD
 	BulkOutSize = SrcBufLen;
 	BulkOutSize = (BulkOutSize + 3) & (~3);
-	RTMPWriteTxInfo(pAd, pTxInfo, (USHORT)(BulkOutSize - TXINFO_SIZE), TRUE, EpToQueue[MGMTPIPEIDX], FALSE,  FALSE);
+	RTMPWriteTxInfo(pAd, pTxInfo, (USHORT) (BulkOutSize - TXINFO_SIZE),
+			TRUE, EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
 
-	BulkOutSize += 4; // Always add 4 extra bytes at every packet.
+	BulkOutSize += 4;	// Always add 4 extra bytes at every packet.
 
 	// If BulkOutSize is multiple of BulkOutMaxPacketSize, add extra 4 bytes again.
 	if ((BulkOutSize % pAd->BulkOutMaxPacketSize) == 0)
@@ -619,21 +605,21 @@ int RtmpUSBMgmtKickOut(
 	ASSERT((padLen <= RTMP_PKT_TAIL_PADDING));
 
 	// Now memzero all extra padding bytes.
-	pDest = (PUCHAR)(pSrcBufVA + SrcBufLen);
+	pDest = (PUCHAR) (pSrcBufVA + SrcBufLen);
 	skb_put(GET_OS_PKT_TYPE(pPacket), padLen);
 	NdisZeroMemory(pDest, padLen);
 
 	RTMP_IRQ_LOCK(&pAd->MLMEBulkOutLock, IrqFlags);
 
 	pAd->MgmtRing.Cell[pAd->MgmtRing.TxCpuIdx].pNdisPacket = pPacket;
-	pMLMEContext->TransferBuffer = (PTX_BUFFER)(GET_OS_PKT_DATAPTR(pPacket));
+	pMLMEContext->TransferBuffer =
+	    (PTX_BUFFER) (GET_OS_PKT_DATAPTR(pPacket));
 
 	// Length in TxInfo should be 8 less than bulkout size.
 	pMLMEContext->BulkOutSize = BulkOutSize;
 	pMLMEContext->InUse = TRUE;
 	pMLMEContext->bWaitingBulkOut = TRUE;
 
-
 	//for debug
 	//hex_dump("RtmpUSBMgmtKickOut", &pMLMEContext->TransferBuffer->field.WirelessPacket[0], (pMLMEContext->BulkOutSize > 16 ? 16 : pMLMEContext->BulkOutSize));
 
@@ -641,7 +627,7 @@ int RtmpUSBMgmtKickOut(
 	//pAd->RalinkCounters.OneSecTxDoneCount++;
 
 	//if (pAd->MgmtRing.TxSwFreeIdx == MGMT_RING_SIZE)
-	//	needKickOut = TRUE;
+	//      needKickOut = TRUE;
 
 	// Decrease the TxSwFreeIdx and Increase the TX_CTX_IDX
 	pAd->MgmtRing.TxSwFreeIdx--;
@@ -656,40 +642,46 @@ int RtmpUSBMgmtKickOut(
 	return 0;
 }
 
-
-VOID RtmpUSBNullFrameKickOut(
-	IN RTMP_ADAPTER *pAd,
-	IN UCHAR		QueIdx,
-	IN UCHAR		*pNullFrame,
-	IN UINT32		frameLen)
-{
-	if (pAd->NullContext.InUse == FALSE)
-	{
-		PTX_CONTEXT		pNullContext;
-		PTXINFO_STRUC	pTxInfo;
-		PTXWI_STRUC		pTxWI;
-		PUCHAR			pWirelessPkt;
+VOID RtmpUSBNullFrameKickOut(IN RTMP_ADAPTER * pAd,
+			     IN UCHAR QueIdx,
+			     IN UCHAR * pNullFrame, IN UINT32 frameLen)
+{
+	if (pAd->NullContext.InUse == FALSE) {
+		PTX_CONTEXT pNullContext;
+		PTXINFO_STRUC pTxInfo;
+		PTXWI_STRUC pTxWI;
+		PUCHAR pWirelessPkt;
 
 		pNullContext = &(pAd->NullContext);
 
 		// Set the in use bit
 		pNullContext->InUse = TRUE;
-		pWirelessPkt = (PUCHAR)&pNullContext->TransferBuffer->field.WirelessPacket[0];
+		pWirelessPkt =
+		    (PUCHAR) & pNullContext->TransferBuffer->field.
+		    WirelessPacket[0];
 
 		RTMPZeroMemory(&pWirelessPkt[0], 100);
-		pTxInfo = (PTXINFO_STRUC)&pWirelessPkt[0];
-		RTMPWriteTxInfo(pAd, pTxInfo, (USHORT)(sizeof(HEADER_802_11)+TXWI_SIZE), TRUE, EpToQueue[MGMTPIPEIDX], FALSE,  FALSE);
+		pTxInfo = (PTXINFO_STRUC) & pWirelessPkt[0];
+		RTMPWriteTxInfo(pAd, pTxInfo,
+				(USHORT) (sizeof(HEADER_802_11) + TXWI_SIZE),
+				TRUE, EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
 		pTxInfo->QSEL = FIFO_EDCA;
-		pTxWI = (PTXWI_STRUC)&pWirelessPkt[TXINFO_SIZE];
-		RTMPWriteTxWI(pAd, pTxWI,  FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 0, BSSID_WCID, (sizeof(HEADER_802_11)),
-			0, 0, (UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS, IFS_HTTXOP, FALSE, &pAd->CommonCfg.MlmeTransmit);
-
-		RTMPMoveMemory(&pWirelessPkt[TXWI_SIZE+TXINFO_SIZE], &pAd->NullFrame, sizeof(HEADER_802_11));
-		pAd->NullContext.BulkOutSize =  TXINFO_SIZE + TXWI_SIZE + sizeof(pAd->NullFrame) + 4;
+		pTxWI = (PTXWI_STRUC) & pWirelessPkt[TXINFO_SIZE];
+		RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, FALSE, FALSE, TRUE,
+			      FALSE, 0, BSSID_WCID, (sizeof(HEADER_802_11)), 0,
+			      0, (UCHAR) pAd->CommonCfg.MlmeTransmit.field.MCS,
+			      IFS_HTTXOP, FALSE, &pAd->CommonCfg.MlmeTransmit);
+
+		RTMPMoveMemory(&pWirelessPkt[TXWI_SIZE + TXINFO_SIZE],
+			       &pAd->NullFrame, sizeof(HEADER_802_11));
+		pAd->NullContext.BulkOutSize =
+		    TXINFO_SIZE + TXWI_SIZE + sizeof(pAd->NullFrame) + 4;
 
 		// Fill out frame length information for global Bulk out arbitor
 		//pNullContext->BulkOutSize = TransferBufferLength;
-		DBGPRINT(RT_DEBUG_TRACE, ("SYNC - send NULL Frame @%d Mbps...\n", RateIdToMbps[pAd->CommonCfg.TxRate]));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("SYNC - send NULL Frame @%d Mbps...\n",
+			  RateIdToMbps[pAd->CommonCfg.TxRate]));
 		RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
 
 		// Kick bulk out
@@ -698,7 +690,6 @@ VOID RtmpUSBNullFrameKickOut(
 
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -716,79 +707,83 @@ Return Value:
 Note:
 ========================================================================
 */
-PNDIS_PACKET GetPacketFromRxRing(
-	IN		PRTMP_ADAPTER		pAd,
-	OUT		PRT28XX_RXD_STRUC	pSaveRxD,
-	OUT		BOOLEAN				*pbReschedule,
-	IN OUT	UINT32				*pRxPending)
-{
-	PRX_CONTEXT		pRxContext;
-	PNDIS_PACKET	pSkb;
-	PUCHAR			pData;
-	ULONG			ThisFrameLen;
-	ULONG			RxBufferLength;
-	PRXWI_STRUC		pRxWI;
+PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
+				 OUT PRT28XX_RXD_STRUC pSaveRxD,
+				 OUT BOOLEAN * pbReschedule,
+				 IN OUT UINT32 * pRxPending)
+{
+	PRX_CONTEXT pRxContext;
+	PNDIS_PACKET pSkb;
+	PUCHAR pData;
+	ULONG ThisFrameLen;
+	ULONG RxBufferLength;
+	PRXWI_STRUC pRxWI;
 
 	pRxContext = &pAd->RxContext[pAd->NextRxBulkInReadIndex];
 	if ((pRxContext->Readable == FALSE) || (pRxContext->InUse == TRUE))
 		return NULL;
 
 	RxBufferLength = pRxContext->BulkInOffset - pAd->ReadPosition;
-	if (RxBufferLength < (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXWI_STRUC) + sizeof(RXINFO_STRUC)))
-	{
+	if (RxBufferLength <
+	    (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXWI_STRUC) +
+	     sizeof(RXINFO_STRUC))) {
 		goto label_null;
 	}
 
-	pData = &pRxContext->TransferBuffer[pAd->ReadPosition]; /* 4KB */
+	pData = &pRxContext->TransferBuffer[pAd->ReadPosition];	/* 4KB */
 	// The RXDMA field is 4 bytes, now just use the first 2 bytes. The Length including the (RXWI + MSDU + Padding)
-	ThisFrameLen = *pData + (*(pData+1)<<8);
-    if (ThisFrameLen == 0)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("BIRIdx(%d): RXDMALen is zero.[%ld], BulkInBufLen = %ld)\n",
-								pAd->NextRxBulkInReadIndex, ThisFrameLen, pRxContext->BulkInOffset));
+	ThisFrameLen = *pData + (*(pData + 1) << 8);
+	if (ThisFrameLen == 0) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("BIRIdx(%d): RXDMALen is zero.[%ld], BulkInBufLen = %ld)\n",
+			  pAd->NextRxBulkInReadIndex, ThisFrameLen,
+			  pRxContext->BulkInOffset));
 		goto label_null;
 	}
-	if ((ThisFrameLen&0x3) != 0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("BIRIdx(%d): RXDMALen not multiple of 4.[%ld], BulkInBufLen = %ld)\n",
-								pAd->NextRxBulkInReadIndex, ThisFrameLen, pRxContext->BulkInOffset));
+	if ((ThisFrameLen & 0x3) != 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("BIRIdx(%d): RXDMALen not multiple of 4.[%ld], BulkInBufLen = %ld)\n",
+			  pAd->NextRxBulkInReadIndex, ThisFrameLen,
+			  pRxContext->BulkInOffset));
 		goto label_null;
 	}
 
-	if ((ThisFrameLen + 8)> RxBufferLength)	// 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXINFO_STRUC))
+	if ((ThisFrameLen + 8) > RxBufferLength)	// 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXINFO_STRUC))
 	{
-		DBGPRINT(RT_DEBUG_TRACE,("BIRIdx(%d):FrameLen(0x%lx) outranges. BulkInLen=0x%lx, remaining RxBufLen=0x%lx, ReadPos=0x%lx\n",
-						pAd->NextRxBulkInReadIndex, ThisFrameLen, pRxContext->BulkInOffset, RxBufferLength, pAd->ReadPosition));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("BIRIdx(%d):FrameLen(0x%lx) outranges. BulkInLen=0x%lx, remaining RxBufLen=0x%lx, ReadPos=0x%lx\n",
+			  pAd->NextRxBulkInReadIndex, ThisFrameLen,
+			  pRxContext->BulkInOffset, RxBufferLength,
+			  pAd->ReadPosition));
 
 		// error frame. finish this loop
 		goto label_null;
 	}
-
 	// skip USB frame length field
 	pData += RT2870_RXDMALEN_FIELD_SIZE;
-	pRxWI = (PRXWI_STRUC)pData;
-	if (pRxWI->MPDUtotalByteCount > ThisFrameLen)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s():pRxWIMPDUtotalByteCount(%d) large than RxDMALen(%ld)\n",
-									__FUNCTION__, pRxWI->MPDUtotalByteCount, ThisFrameLen));
+	pRxWI = (PRXWI_STRUC) pData;
+	if (pRxWI->MPDUtotalByteCount > ThisFrameLen) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s():pRxWIMPDUtotalByteCount(%d) large than RxDMALen(%ld)\n",
+			  __FUNCTION__, pRxWI->MPDUtotalByteCount,
+			  ThisFrameLen));
 		goto label_null;
 	}
-
 	// allocate a rx packet
 	pSkb = dev_alloc_skb(ThisFrameLen);
-	if (pSkb == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("%s():Cannot Allocate sk buffer for this Bulk-In buffer!\n", __FUNCTION__));
+	if (pSkb == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s():Cannot Allocate sk buffer for this Bulk-In buffer!\n",
+			  __FUNCTION__));
 		goto label_null;
 	}
-
 	// copy the rx packet
 	memcpy(skb_put(pSkb, ThisFrameLen), pData, ThisFrameLen);
 	RTPKT_TO_OSPKT(pSkb)->dev = get_netdev_from_bssid(pAd, BSS0);
 	RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pSkb), PKTSRC_NDIS);
 
 	// copy RxD
-	*pSaveRxD = *(PRXINFO_STRUC)(pData + ThisFrameLen);
+	*pSaveRxD = *(PRXINFO_STRUC) (pData + ThisFrameLen);
 
 	// update next packet read position.
 	pAd->ReadPosition += (ThisFrameLen + RT2870_RXDMALEN_FIELD_SIZE + RXINFO_SIZE);	// 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXINFO_STRUC))
@@ -800,7 +795,6 @@ label_null:
 	return NULL;
 }
 
-
 /*
 	========================================================================
 
@@ -818,23 +812,20 @@ label_null:
 
 	========================================================================
 */
-NDIS_STATUS	RTMPCheckRxError(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PHEADER_802_11	pHeader,
-	IN	PRXWI_STRUC	pRxWI,
-	IN	PRT28XX_RXD_STRUC	pRxINFO)
+NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
+			     IN PHEADER_802_11 pHeader,
+			     IN PRXWI_STRUC pRxWI, IN PRT28XX_RXD_STRUC pRxINFO)
 {
 	PCIPHER_KEY pWpaKey;
-	INT	dBm;
+	INT dBm;
 
 	if (pAd->bPromiscuous == TRUE)
-		return(NDIS_STATUS_SUCCESS);
-	if(pRxINFO == NULL)
-		return(NDIS_STATUS_FAILURE);
+		return (NDIS_STATUS_SUCCESS);
+	if (pRxINFO == NULL)
+		return (NDIS_STATUS_FAILURE);
 
 	// Phy errors & CRC errors
-	if (pRxINFO->Crc)
-	{
+	if (pRxINFO->Crc) {
 		// Check RSSI for Noise Hist statistic collection.
 		dBm = (INT) (pRxWI->RSSI0) - pAd->BbpRssiToDbmDelta;
 		if (dBm <= -87)
@@ -854,77 +845,73 @@ NDIS_STATUS	RTMPCheckRxError(
 		else if (dBm > -57)
 			pAd->StaCfg.RPIDensity[7] += 1;
 
-		return(NDIS_STATUS_FAILURE);
+		return (NDIS_STATUS_FAILURE);
 	}
-
 	// Add Rx size to channel load counter, we should ignore error counts
-	pAd->StaCfg.CLBusyBytes += (pRxWI->MPDUtotalByteCount+ 14);
+	pAd->StaCfg.CLBusyBytes += (pRxWI->MPDUtotalByteCount + 14);
 
 	// Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics
-	if (pHeader->FC.ToDs)
-	{
+	if (pHeader->FC.ToDs) {
 		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Err;FC.ToDs\n"));
 		return NDIS_STATUS_FAILURE;
 	}
-
 	// Paul 04-03 for OFDM Rx length issue
-	if (pRxWI->MPDUtotalByteCount > MAX_AGGREGATION_SIZE)
-	{
+	if (pRxWI->MPDUtotalByteCount > MAX_AGGREGATION_SIZE) {
 		DBGPRINT_RAW(RT_DEBUG_ERROR, ("received packet too long\n"));
 		return NDIS_STATUS_FAILURE;
 	}
-
 	// Drop not U2M frames, cant's drop here because we will drop beacon in this case
 	// I am kind of doubting the U2M bit operation
 	// if (pRxD->U2M == 0)
-	//	return(NDIS_STATUS_FAILURE);
+	//      return(NDIS_STATUS_FAILURE);
 
 	// drop decyption fail frame
-	if (pRxINFO->Decrypted && pRxINFO->CipherErr)
-	{
-
-		if (((pRxINFO->CipherErr & 1) == 1) && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
-            RTMPSendWirelessEvent(pAd, IW_ICV_ERROR_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+	if (pRxINFO->Decrypted && pRxINFO->CipherErr) {
 
-		if (((pRxINFO->CipherErr & 2) == 2) && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
-                RTMPSendWirelessEvent(pAd, IW_MIC_ERROR_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+		if (((pRxINFO->CipherErr & 1) == 1)
+		    && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
+			RTMPSendWirelessEvent(pAd, IW_ICV_ERROR_EVENT_FLAG,
+					      pAd->MacTab.Content[BSSID_WCID].
+					      Addr, BSS0, 0);
+
+		if (((pRxINFO->CipherErr & 2) == 2)
+		    && pAd->CommonCfg.bWirelessEvent && INFRA_ON(pAd))
+			RTMPSendWirelessEvent(pAd, IW_MIC_ERROR_EVENT_FLAG,
+					      pAd->MacTab.Content[BSSID_WCID].
+					      Addr, BSS0, 0);
 		//
 		// MIC Error
 		//
-		if ((pRxINFO->CipherErr == 2) && pRxINFO->MyBss)
-		{
+		if ((pRxINFO->CipherErr == 2) && pRxINFO->MyBss) {
 			pWpaKey = &pAd->SharedKey[BSS0][pRxWI->KeyIndex];
 			RTMPReportMicError(pAd, pWpaKey);
-			DBGPRINT_RAW(RT_DEBUG_ERROR,("Rx MIC Value error\n"));
+			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Rx MIC Value error\n"));
 		}
 
 		if (pRxINFO->Decrypted &&
-			(pAd->SharedKey[BSS0][pRxWI->KeyIndex].CipherAlg == CIPHER_AES) &&
-			(pHeader->Sequence == pAd->FragFrame.Sequence))
-		{
+		    (pAd->SharedKey[BSS0][pRxWI->KeyIndex].CipherAlg ==
+		     CIPHER_AES)
+		    && (pHeader->Sequence == pAd->FragFrame.Sequence)) {
 			//
 			// Acceptable since the First FragFrame no CipherErr problem.
 			//
-			return(NDIS_STATUS_SUCCESS);
+			return (NDIS_STATUS_SUCCESS);
 		}
 
-		return(NDIS_STATUS_FAILURE);
+		return (NDIS_STATUS_FAILURE);
 	}
 
-	return(NDIS_STATUS_SUCCESS);
+	return (NDIS_STATUS_SUCCESS);
 }
 
-VOID RtmpUsbStaAsicForceWakeupTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+VOID RtmpUsbStaAsicForceWakeupTimeout(IN PVOID SystemSpecific1,
+				      IN PVOID FunctionContext,
+				      IN PVOID SystemSpecific2,
+				      IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
-
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
-	if (pAd && pAd->Mlme.AutoWakeupTimerRunning)
-	{
+	if (pAd && pAd->Mlme.AutoWakeupTimerRunning) {
 		AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
 
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
@@ -932,11 +919,9 @@ VOID RtmpUsbStaAsicForceWakeupTimeout(
 	}
 }
 
-VOID RT28xxUsbStaAsicForceWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN BOOLEAN       bFromTx)
+VOID RT28xxUsbStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 {
-	BOOLEAN	Canceled;
+	BOOLEAN Canceled;
 
 	if (pAd->Mlme.AutoWakeupTimerRunning)
 		RTMPCancelTimer(&pAd->Mlme.AutoWakeupTimer, &Canceled);
@@ -946,12 +931,10 @@ VOID RT28xxUsbStaAsicForceWakeup(
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
 }
 
-VOID RT28xxUsbStaAsicSleepThenAutoWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT TbttNumToNextWakeUp)
+VOID RT28xxUsbStaAsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
+					 IN USHORT TbttNumToNextWakeUp)
 {
 
-
 	// we have decided to SLEEP, so at least do it for a BEACON period.
 	if (TbttNumToNextWakeUp == 0)
 		TbttNumToNextWakeUp = 1;
@@ -959,7 +942,7 @@ VOID RT28xxUsbStaAsicSleepThenAutoWakeup
 	RTMPSetTimer(&pAd->Mlme.AutoWakeupTimer, AUTO_WAKEUP_TIMEOUT);
 	pAd->Mlme.AutoWakeupTimerRunning = TRUE;
 
-	AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);   // send POWER-SAVE command to MCU. Timeout 40us.
+	AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);	// send POWER-SAVE command to MCU. Timeout 40us.
 
 	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
 
--- a/drivers/staging/rt2860/common/cmm_info.c
+++ b/drivers/staging/rt2860/common/cmm_info.c
@@ -47,153 +47,174 @@
 
 	========================================================================
 */
-VOID    RTMPSetDesiredRates(
-    IN  PRTMP_ADAPTER   pAdapter,
-    IN  LONG            Rates)
-{
-    NDIS_802_11_RATES aryRates;
-
-    memset(&aryRates, 0x00, sizeof(NDIS_802_11_RATES));
-    switch (pAdapter->CommonCfg.PhyMode)
-    {
-        case PHY_11A: // A only
-            switch (Rates)
-            {
-                case 6000000: //6M
-                    aryRates[0] = 0x0c; // 6M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_0;
-                    break;
-                case 9000000: //9M
-                    aryRates[0] = 0x12; // 9M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_1;
-                    break;
-                case 12000000: //12M
-                    aryRates[0] = 0x18; // 12M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_2;
-                    break;
-                case 18000000: //18M
-                    aryRates[0] = 0x24; // 18M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_3;
-                    break;
-                case 24000000: //24M
-                    aryRates[0] = 0x30; // 24M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_4;
-                    break;
-                case 36000000: //36M
-                    aryRates[0] = 0x48; // 36M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_5;
-                    break;
-                case 48000000: //48M
-                    aryRates[0] = 0x60; // 48M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_6;
-                    break;
-                case 54000000: //54M
-                    aryRates[0] = 0x6c; // 54M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_7;
-                    break;
-                case -1: //Auto
-                default:
-                    aryRates[0] = 0x6c; // 54Mbps
-                    aryRates[1] = 0x60; // 48Mbps
-                    aryRates[2] = 0x48; // 36Mbps
-                    aryRates[3] = 0x30; // 24Mbps
-                    aryRates[4] = 0x24; // 18M
-                    aryRates[5] = 0x18; // 12M
-                    aryRates[6] = 0x12; // 9M
-                    aryRates[7] = 0x0c; // 6M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
-                    break;
-            }
-            break;
-        case PHY_11BG_MIXED: // B/G Mixed
-        case PHY_11B: // B only
-        case PHY_11ABG_MIXED: // A/B/G Mixed
-        default:
-            switch (Rates)
-            {
-                case 1000000: //1M
-                    aryRates[0] = 0x02;
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_0;
-                    break;
-                case 2000000: //2M
-                    aryRates[0] = 0x04;
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_1;
-                    break;
-                case 5000000: //5.5M
-                    aryRates[0] = 0x0b; // 5.5M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_2;
-                    break;
-                case 11000000: //11M
-                    aryRates[0] = 0x16; // 11M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_3;
-                    break;
-                case 6000000: //6M
-                    aryRates[0] = 0x0c; // 6M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_0;
-                    break;
-                case 9000000: //9M
-                    aryRates[0] = 0x12; // 9M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_1;
-                    break;
-                case 12000000: //12M
-                    aryRates[0] = 0x18; // 12M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_2;
-                    break;
-                case 18000000: //18M
-                    aryRates[0] = 0x24; // 18M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_3;
-                    break;
-                case 24000000: //24M
-                    aryRates[0] = 0x30; // 24M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_4;
-                    break;
-                case 36000000: //36M
-                    aryRates[0] = 0x48; // 36M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_5;
-                    break;
-                case 48000000: //48M
-                    aryRates[0] = 0x60; // 48M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_6;
-                    break;
-                case 54000000: //54M
-                    aryRates[0] = 0x6c; // 54M
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_7;
-                    break;
-                case -1: //Auto
-                default:
-                    if (pAdapter->CommonCfg.PhyMode == PHY_11B)
-                    { //B Only
-                        aryRates[0] = 0x16; // 11Mbps
-                        aryRates[1] = 0x0b; // 5.5Mbps
-                        aryRates[2] = 0x04; // 2Mbps
-                        aryRates[3] = 0x02; // 1Mbps
-                    }
-                    else
-                    { //(B/G) Mixed or (A/B/G) Mixed
-                        aryRates[0] = 0x6c; // 54Mbps
-                        aryRates[1] = 0x60; // 48Mbps
-                        aryRates[2] = 0x48; // 36Mbps
-                        aryRates[3] = 0x30; // 24Mbps
-                        aryRates[4] = 0x16; // 11Mbps
-                        aryRates[5] = 0x0b; // 5.5Mbps
-                        aryRates[6] = 0x04; // 2Mbps
-                        aryRates[7] = 0x02; // 1Mbps
-                    }
-                    pAdapter->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
-                    break;
-            }
-            break;
-    }
-
-    NdisZeroMemory(pAdapter->CommonCfg.DesireRate, MAX_LEN_OF_SUPPORTED_RATES);
-    NdisMoveMemory(pAdapter->CommonCfg.DesireRate, &aryRates, sizeof(NDIS_802_11_RATES));
-    DBGPRINT(RT_DEBUG_TRACE, (" RTMPSetDesiredRates (%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x)\n",
-        pAdapter->CommonCfg.DesireRate[0],pAdapter->CommonCfg.DesireRate[1],
-        pAdapter->CommonCfg.DesireRate[2],pAdapter->CommonCfg.DesireRate[3],
-        pAdapter->CommonCfg.DesireRate[4],pAdapter->CommonCfg.DesireRate[5],
-        pAdapter->CommonCfg.DesireRate[6],pAdapter->CommonCfg.DesireRate[7] ));
-    // Changing DesiredRate may affect the MAX TX rate we used to TX frames out
-    MlmeUpdateTxRates(pAdapter, FALSE, 0);
+VOID RTMPSetDesiredRates(IN PRTMP_ADAPTER pAdapter, IN LONG Rates)
+{
+	NDIS_802_11_RATES aryRates;
+
+	memset(&aryRates, 0x00, sizeof(NDIS_802_11_RATES));
+	switch (pAdapter->CommonCfg.PhyMode) {
+	case PHY_11A:		// A only
+		switch (Rates) {
+		case 6000000:	//6M
+			aryRates[0] = 0x0c;	// 6M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_0;
+			break;
+		case 9000000:	//9M
+			aryRates[0] = 0x12;	// 9M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_1;
+			break;
+		case 12000000:	//12M
+			aryRates[0] = 0x18;	// 12M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_2;
+			break;
+		case 18000000:	//18M
+			aryRates[0] = 0x24;	// 18M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_3;
+			break;
+		case 24000000:	//24M
+			aryRates[0] = 0x30;	// 24M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_4;
+			break;
+		case 36000000:	//36M
+			aryRates[0] = 0x48;	// 36M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_5;
+			break;
+		case 48000000:	//48M
+			aryRates[0] = 0x60;	// 48M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_6;
+			break;
+		case 54000000:	//54M
+			aryRates[0] = 0x6c;	// 54M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_7;
+			break;
+		case -1:	//Auto
+		default:
+			aryRates[0] = 0x6c;	// 54Mbps
+			aryRates[1] = 0x60;	// 48Mbps
+			aryRates[2] = 0x48;	// 36Mbps
+			aryRates[3] = 0x30;	// 24Mbps
+			aryRates[4] = 0x24;	// 18M
+			aryRates[5] = 0x18;	// 12M
+			aryRates[6] = 0x12;	// 9M
+			aryRates[7] = 0x0c;	// 6M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_AUTO;
+			break;
+		}
+		break;
+	case PHY_11BG_MIXED:	// B/G Mixed
+	case PHY_11B:		// B only
+	case PHY_11ABG_MIXED:	// A/B/G Mixed
+	default:
+		switch (Rates) {
+		case 1000000:	//1M
+			aryRates[0] = 0x02;
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_0;
+			break;
+		case 2000000:	//2M
+			aryRates[0] = 0x04;
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_1;
+			break;
+		case 5000000:	//5.5M
+			aryRates[0] = 0x0b;	// 5.5M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_2;
+			break;
+		case 11000000:	//11M
+			aryRates[0] = 0x16;	// 11M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_3;
+			break;
+		case 6000000:	//6M
+			aryRates[0] = 0x0c;	// 6M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_0;
+			break;
+		case 9000000:	//9M
+			aryRates[0] = 0x12;	// 9M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_1;
+			break;
+		case 12000000:	//12M
+			aryRates[0] = 0x18;	// 12M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_2;
+			break;
+		case 18000000:	//18M
+			aryRates[0] = 0x24;	// 18M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_3;
+			break;
+		case 24000000:	//24M
+			aryRates[0] = 0x30;	// 24M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_4;
+			break;
+		case 36000000:	//36M
+			aryRates[0] = 0x48;	// 36M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_5;
+			break;
+		case 48000000:	//48M
+			aryRates[0] = 0x60;	// 48M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_6;
+			break;
+		case 54000000:	//54M
+			aryRates[0] = 0x6c;	// 54M
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_7;
+			break;
+		case -1:	//Auto
+		default:
+			if (pAdapter->CommonCfg.PhyMode == PHY_11B) {	//B Only
+				aryRates[0] = 0x16;	// 11Mbps
+				aryRates[1] = 0x0b;	// 5.5Mbps
+				aryRates[2] = 0x04;	// 2Mbps
+				aryRates[3] = 0x02;	// 1Mbps
+			} else {	//(B/G) Mixed or (A/B/G) Mixed
+				aryRates[0] = 0x6c;	// 54Mbps
+				aryRates[1] = 0x60;	// 48Mbps
+				aryRates[2] = 0x48;	// 36Mbps
+				aryRates[3] = 0x30;	// 24Mbps
+				aryRates[4] = 0x16;	// 11Mbps
+				aryRates[5] = 0x0b;	// 5.5Mbps
+				aryRates[6] = 0x04;	// 2Mbps
+				aryRates[7] = 0x02;	// 1Mbps
+			}
+			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
+			    MCS_AUTO;
+			break;
+		}
+		break;
+	}
+
+	NdisZeroMemory(pAdapter->CommonCfg.DesireRate,
+		       MAX_LEN_OF_SUPPORTED_RATES);
+	NdisMoveMemory(pAdapter->CommonCfg.DesireRate, &aryRates,
+		       sizeof(NDIS_802_11_RATES));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 (" RTMPSetDesiredRates (%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x)\n",
+		  pAdapter->CommonCfg.DesireRate[0],
+		  pAdapter->CommonCfg.DesireRate[1],
+		  pAdapter->CommonCfg.DesireRate[2],
+		  pAdapter->CommonCfg.DesireRate[3],
+		  pAdapter->CommonCfg.DesireRate[4],
+		  pAdapter->CommonCfg.DesireRate[5],
+		  pAdapter->CommonCfg.DesireRate[6],
+		  pAdapter->CommonCfg.DesireRate[7]));
+	// Changing DesiredRate may affect the MAX TX rate we used to TX frames out
+	MlmeUpdateTxRates(pAdapter, FALSE, 0);
 }
 
 /*
@@ -214,13 +235,14 @@ VOID    RTMPSetDesiredRates(
 
 	========================================================================
 */
-VOID	RTMPWPARemoveAllKeys(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPWPARemoveAllKeys(IN PRTMP_ADAPTER pAd)
 {
 
-	UCHAR 	i;
+	UCHAR i;
 
-	DBGPRINT(RT_DEBUG_TRACE,("RTMPWPARemoveAllKeys(AuthMode=%d, WepStatus=%d)\n", pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPWPARemoveAllKeys(AuthMode=%d, WepStatus=%d)\n",
+		  pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus));
 	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 	// For WEP/CKIP, there is no need to remove it, since WinXP won't set it again after
 	// Link up. And it will be replaced if user changed it.
@@ -236,9 +258,10 @@ VOID	RTMPWPARemoveAllKeys(
 	AsicRemovePairwiseKeyEntry(pAd, BSS0, BSSID_WCID);
 
 	// set all shared key mode as no-security.
-	for (i = 0; i < SHARE_KEY_NUM; i++)
-    {
-		DBGPRINT(RT_DEBUG_TRACE,("remove %s key #%d\n", CipherName[pAd->SharedKey[BSS0][i].CipherAlg], i));
+	for (i = 0; i < SHARE_KEY_NUM; i++) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("remove %s key #%d\n",
+			  CipherName[pAd->SharedKey[BSS0][i].CipherAlg], i));
 		NdisZeroMemory(&pAd->SharedKey[BSS0][i], sizeof(CIPHER_KEY));
 
 		AsicRemoveSharedKeyEntry(pAd, BSS0, i);
@@ -246,7 +269,6 @@ VOID	RTMPWPARemoveAllKeys(
 	RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 }
 
-
 /*
 	========================================================================
 
@@ -285,120 +307,119 @@ VOID	RTMPWPARemoveAllKeys(
 
 	========================================================================
 */
-VOID	RTMPSetPhyMode(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	ULONG phymode)
+VOID RTMPSetPhyMode(IN PRTMP_ADAPTER pAd, IN ULONG phymode)
 {
 	INT i;
 	// the selected phymode must be supported by the RF IC encoded in E2PROM
 
 	// if no change, do nothing
 	/* bug fix
-	if (pAd->CommonCfg.PhyMode == phymode)
-		return;
-    */
-	pAd->CommonCfg.PhyMode = (UCHAR)phymode;
-
-	DBGPRINT(RT_DEBUG_TRACE,("RTMPSetPhyMode : PhyMode=%d, channel=%d \n", pAd->CommonCfg.PhyMode, pAd->CommonCfg.Channel));
+	   if (pAd->CommonCfg.PhyMode == phymode)
+	   return;
+	 */
+	pAd->CommonCfg.PhyMode = (UCHAR) phymode;
+
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPSetPhyMode : PhyMode=%d, channel=%d \n",
+		  pAd->CommonCfg.PhyMode, pAd->CommonCfg.Channel));
 
 	BuildChannelList(pAd);
 
 	// sanity check user setting
-	for (i = 0; i < pAd->ChannelListNum; i++)
-	{
+	for (i = 0; i < pAd->ChannelListNum; i++) {
 		if (pAd->CommonCfg.Channel == pAd->ChannelList[i].Channel)
 			break;
 	}
 
-	if (i == pAd->ChannelListNum)
-	{
+	if (i == pAd->ChannelListNum) {
 		pAd->CommonCfg.Channel = FirstChannel(pAd);
-		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSetPhyMode: channel is out of range, use first channel=%d \n", pAd->CommonCfg.Channel));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTMPSetPhyMode: channel is out of range, use first channel=%d \n",
+			  pAd->CommonCfg.Channel));
 	}
 
 	NdisZeroMemory(pAd->CommonCfg.SupRate, MAX_LEN_OF_SUPPORTED_RATES);
 	NdisZeroMemory(pAd->CommonCfg.ExtRate, MAX_LEN_OF_SUPPORTED_RATES);
 	NdisZeroMemory(pAd->CommonCfg.DesireRate, MAX_LEN_OF_SUPPORTED_RATES);
 	switch (phymode) {
-		case PHY_11B:
-			pAd->CommonCfg.SupRate[0]  = 0x82;	  // 1 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[1]  = 0x84;	  // 2 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[2]  = 0x8B;	  // 5.5 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[3]  = 0x96;	  // 11 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRateLen  = 4;
-			pAd->CommonCfg.ExtRateLen  = 0;
-			pAd->CommonCfg.DesireRate[0]  = 2;	   // 1 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[1]  = 4;	   // 2 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[2]  = 11;    // 5.5 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[3]  = 22;    // 11 mbps, in units of 0.5 Mbps
-			//pAd->CommonCfg.HTPhyMode.field.MODE = MODE_CCK; // This MODE is only FYI. not use
-			break;
-
-		case PHY_11G:
-		case PHY_11BG_MIXED:
-		case PHY_11ABG_MIXED:
-		case PHY_11N_2_4G:
-		case PHY_11ABGN_MIXED:
-		case PHY_11BGN_MIXED:
-		case PHY_11GN_MIXED:
-			pAd->CommonCfg.SupRate[0]  = 0x82;	  // 1 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[1]  = 0x84;	  // 2 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[2]  = 0x8B;	  // 5.5 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[3]  = 0x96;	  // 11 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[4]  = 0x12;	  // 9 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRate[5]  = 0x24;	  // 18 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRate[6]  = 0x48;	  // 36 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRate[7]  = 0x6c;	  // 54 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRateLen  = 8;
-			pAd->CommonCfg.ExtRate[0]  = 0x0C;	  // 6 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.ExtRate[1]  = 0x18;	  // 12 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.ExtRate[2]  = 0x30;	  // 24 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.ExtRate[3]  = 0x60;	  // 48 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.ExtRateLen  = 4;
-			pAd->CommonCfg.DesireRate[0]  = 2;	   // 1 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[1]  = 4;	   // 2 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[2]  = 11;    // 5.5 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[3]  = 22;    // 11 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[4]  = 12;    // 6 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[5]  = 18;    // 9 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[6]  = 24;    // 12 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[7]  = 36;    // 18 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[8]  = 48;    // 24 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[9]  = 72;    // 36 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[10] = 96;    // 48 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[11] = 108;   // 54 mbps, in units of 0.5 Mbps
-			break;
-
-		case PHY_11A:
-		case PHY_11AN_MIXED:
-		case PHY_11AGN_MIXED:
-		case PHY_11N_5G:
-			pAd->CommonCfg.SupRate[0]  = 0x8C;	  // 6 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[1]  = 0x12;	  // 9 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRate[2]  = 0x98;	  // 12 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[3]  = 0x24;	  // 18 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRate[4]  = 0xb0;	  // 24 mbps, in units of 0.5 Mbps, basic rate
-			pAd->CommonCfg.SupRate[5]  = 0x48;	  // 36 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRate[6]  = 0x60;	  // 48 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRate[7]  = 0x6c;	  // 54 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.SupRateLen  = 8;
-			pAd->CommonCfg.ExtRateLen  = 0;
-			pAd->CommonCfg.DesireRate[0]  = 12;    // 6 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[1]  = 18;    // 9 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[2]  = 24;    // 12 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[3]  = 36;    // 18 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[4]  = 48;    // 24 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[5]  = 72;    // 36 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[6]  = 96;    // 48 mbps, in units of 0.5 Mbps
-			pAd->CommonCfg.DesireRate[7]  = 108;   // 54 mbps, in units of 0.5 Mbps
-			//pAd->CommonCfg.HTPhyMode.field.MODE = MODE_OFDM; // This MODE is only FYI. not use
-			break;
+	case PHY_11B:
+		pAd->CommonCfg.SupRate[0] = 0x82;	// 1 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[1] = 0x84;	// 2 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[2] = 0x8B;	// 5.5 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[3] = 0x96;	// 11 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRateLen = 4;
+		pAd->CommonCfg.ExtRateLen = 0;
+		pAd->CommonCfg.DesireRate[0] = 2;	// 1 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[1] = 4;	// 2 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[2] = 11;	// 5.5 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[3] = 22;	// 11 mbps, in units of 0.5 Mbps
+		//pAd->CommonCfg.HTPhyMode.field.MODE = MODE_CCK; // This MODE is only FYI. not use
+		break;
+
+	case PHY_11G:
+	case PHY_11BG_MIXED:
+	case PHY_11ABG_MIXED:
+	case PHY_11N_2_4G:
+	case PHY_11ABGN_MIXED:
+	case PHY_11BGN_MIXED:
+	case PHY_11GN_MIXED:
+		pAd->CommonCfg.SupRate[0] = 0x82;	// 1 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[1] = 0x84;	// 2 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[2] = 0x8B;	// 5.5 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[3] = 0x96;	// 11 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[4] = 0x12;	// 9 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[5] = 0x24;	// 18 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[6] = 0x48;	// 36 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[7] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRateLen = 8;
+		pAd->CommonCfg.ExtRate[0] = 0x0C;	// 6 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.ExtRate[1] = 0x18;	// 12 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.ExtRate[2] = 0x30;	// 24 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.ExtRate[3] = 0x60;	// 48 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.ExtRateLen = 4;
+		pAd->CommonCfg.DesireRate[0] = 2;	// 1 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[1] = 4;	// 2 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[2] = 11;	// 5.5 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[3] = 22;	// 11 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[4] = 12;	// 6 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[5] = 18;	// 9 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[6] = 24;	// 12 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[7] = 36;	// 18 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[8] = 48;	// 24 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[9] = 72;	// 36 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[10] = 96;	// 48 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[11] = 108;	// 54 mbps, in units of 0.5 Mbps
+		break;
+
+	case PHY_11A:
+	case PHY_11AN_MIXED:
+	case PHY_11AGN_MIXED:
+	case PHY_11N_5G:
+		pAd->CommonCfg.SupRate[0] = 0x8C;	// 6 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[1] = 0x12;	// 9 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[2] = 0x98;	// 12 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[3] = 0x24;	// 18 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[4] = 0xb0;	// 24 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[5] = 0x48;	// 36 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[6] = 0x60;	// 48 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[7] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRateLen = 8;
+		pAd->CommonCfg.ExtRateLen = 0;
+		pAd->CommonCfg.DesireRate[0] = 12;	// 6 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[1] = 18;	// 9 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[2] = 24;	// 12 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[3] = 36;	// 18 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[4] = 48;	// 24 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[5] = 72;	// 36 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[6] = 96;	// 48 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[7] = 108;	// 54 mbps, in units of 0.5 Mbps
+		//pAd->CommonCfg.HTPhyMode.field.MODE = MODE_OFDM; // This MODE is only FYI. not use
+		break;
 
-		default:
-			break;
+	default:
+		break;
 	}
 
-
 	pAd->CommonCfg.BandState = UNKNOWN_BAND;
 }
 
@@ -414,34 +435,33 @@ VOID	RTMPSetPhyMode(
 
 	========================================================================
 */
-VOID	RTMPSetHT(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	OID_SET_HT_PHYMODE *pHTPhyMode)
-{
-	//ULONG	*pmcs;
-	UINT32	Value = 0;
-	UCHAR	BBPValue = 0;
-	UCHAR	BBP3Value = 0;
-	UCHAR	RxStream = pAd->CommonCfg.RxStream;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPSetHT : HT_mode(%d), ExtOffset(%d), MCS(%d), BW(%d), STBC(%d), SHORTGI(%d)\n",
-										pHTPhyMode->HtMode, pHTPhyMode->ExtOffset,
-										pHTPhyMode->MCS, pHTPhyMode->BW,
-										pHTPhyMode->STBC, pHTPhyMode->SHORTGI));
+VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
+{
+	//ULONG *pmcs;
+	UINT32 Value = 0;
+	UCHAR BBPValue = 0;
+	UCHAR BBP3Value = 0;
+	UCHAR RxStream = pAd->CommonCfg.RxStream;
+
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPSetHT : HT_mode(%d), ExtOffset(%d), MCS(%d), BW(%d), STBC(%d), SHORTGI(%d)\n",
+		  pHTPhyMode->HtMode, pHTPhyMode->ExtOffset, pHTPhyMode->MCS,
+		  pHTPhyMode->BW, pHTPhyMode->STBC, pHTPhyMode->SHORTGI));
 
 	// Don't zero supportedHyPhy structure.
-	RTMPZeroMemory(&pAd->CommonCfg.HtCapability, sizeof(pAd->CommonCfg.HtCapability));
-	RTMPZeroMemory(&pAd->CommonCfg.AddHTInfo, sizeof(pAd->CommonCfg.AddHTInfo));
-	RTMPZeroMemory(&pAd->CommonCfg.NewExtChanOffset, sizeof(pAd->CommonCfg.NewExtChanOffset));
-	RTMPZeroMemory(&pAd->CommonCfg.DesiredHtPhy, sizeof(pAd->CommonCfg.DesiredHtPhy));
+	RTMPZeroMemory(&pAd->CommonCfg.HtCapability,
+		       sizeof(pAd->CommonCfg.HtCapability));
+	RTMPZeroMemory(&pAd->CommonCfg.AddHTInfo,
+		       sizeof(pAd->CommonCfg.AddHTInfo));
+	RTMPZeroMemory(&pAd->CommonCfg.NewExtChanOffset,
+		       sizeof(pAd->CommonCfg.NewExtChanOffset));
+	RTMPZeroMemory(&pAd->CommonCfg.DesiredHtPhy,
+		       sizeof(pAd->CommonCfg.DesiredHtPhy));
 
-   	if (pAd->CommonCfg.bRdg)
-	{
+	if (pAd->CommonCfg.bRdg) {
 		pAd->CommonCfg.HtCapability.ExtHtCapInfo.PlusHTC = 1;
 		pAd->CommonCfg.HtCapability.ExtHtCapInfo.RDGSupport = 1;
-	}
-	else
-	{
+	} else {
 		pAd->CommonCfg.HtCapability.ExtHtCapInfo.PlusHTC = 0;
 		pAd->CommonCfg.HtCapability.ExtHtCapInfo.RDGSupport = 0;
 	}
@@ -449,89 +469,92 @@ VOID	RTMPSetHT(
 	pAd->CommonCfg.HtCapability.HtCapParm.MaxRAmpduFactor = 3;
 	pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor = 3;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPSetHT : RxBAWinLimit = %d\n", pAd->CommonCfg.BACapability.field.RxBAWinLimit));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPSetHT : RxBAWinLimit = %d\n",
+		  pAd->CommonCfg.BACapability.field.RxBAWinLimit));
 
 	// Mimo power save, A-MSDU size,
-	pAd->CommonCfg.DesiredHtPhy.AmsduEnable = (USHORT)pAd->CommonCfg.BACapability.field.AmsduEnable;
-	pAd->CommonCfg.DesiredHtPhy.AmsduSize = (UCHAR)pAd->CommonCfg.BACapability.field.AmsduSize;
-	pAd->CommonCfg.DesiredHtPhy.MimoPs = (UCHAR)pAd->CommonCfg.BACapability.field.MMPSmode;
-	pAd->CommonCfg.DesiredHtPhy.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
-
-	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
-	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs = (USHORT)pAd->CommonCfg.BACapability.field.MMPSmode;
-	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
-
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPSetHT : AMsduSize = %d, MimoPs = %d, MpduDensity = %d, MaxRAmpduFactor = %d\n",
-													pAd->CommonCfg.DesiredHtPhy.AmsduSize,
-													pAd->CommonCfg.DesiredHtPhy.MimoPs,
-													pAd->CommonCfg.DesiredHtPhy.MpduDensity,
-													pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor));
+	pAd->CommonCfg.DesiredHtPhy.AmsduEnable =
+	    (USHORT) pAd->CommonCfg.BACapability.field.AmsduEnable;
+	pAd->CommonCfg.DesiredHtPhy.AmsduSize =
+	    (UCHAR) pAd->CommonCfg.BACapability.field.AmsduSize;
+	pAd->CommonCfg.DesiredHtPhy.MimoPs =
+	    (UCHAR) pAd->CommonCfg.BACapability.field.MMPSmode;
+	pAd->CommonCfg.DesiredHtPhy.MpduDensity =
+	    (UCHAR) pAd->CommonCfg.BACapability.field.MpduDensity;
+
+	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize =
+	    (USHORT) pAd->CommonCfg.BACapability.field.AmsduSize;
+	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs =
+	    (USHORT) pAd->CommonCfg.BACapability.field.MMPSmode;
+	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity =
+	    (UCHAR) pAd->CommonCfg.BACapability.field.MpduDensity;
+
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPSetHT : AMsduSize = %d, MimoPs = %d, MpduDensity = %d, MaxRAmpduFactor = %d\n",
+		  pAd->CommonCfg.DesiredHtPhy.AmsduSize,
+		  pAd->CommonCfg.DesiredHtPhy.MimoPs,
+		  pAd->CommonCfg.DesiredHtPhy.MpduDensity,
+		  pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor));
 
-	if(pHTPhyMode->HtMode == HTMODE_GF)
-	{
+	if (pHTPhyMode->HtMode == HTMODE_GF) {
 		pAd->CommonCfg.HtCapability.HtCapInfo.GF = 1;
 		pAd->CommonCfg.DesiredHtPhy.GF = 1;
-	}
-	else
+	} else
 		pAd->CommonCfg.DesiredHtPhy.GF = 0;
 
 	// Decide Rx MCSSet
-	switch (RxStream)
-	{
-		case 1:
-			pAd->CommonCfg.HtCapability.MCSSet[0] =  0xff;
-			pAd->CommonCfg.HtCapability.MCSSet[1] =  0x00;
-			break;
-
-		case 2:
-			pAd->CommonCfg.HtCapability.MCSSet[0] =  0xff;
-			pAd->CommonCfg.HtCapability.MCSSet[1] =  0xff;
-			break;
-
-		case 3: // 3*3
-			pAd->CommonCfg.HtCapability.MCSSet[0] =  0xff;
-			pAd->CommonCfg.HtCapability.MCSSet[1] =  0xff;
-			pAd->CommonCfg.HtCapability.MCSSet[2] =  0xff;
-			break;
+	switch (RxStream) {
+	case 1:
+		pAd->CommonCfg.HtCapability.MCSSet[0] = 0xff;
+		pAd->CommonCfg.HtCapability.MCSSet[1] = 0x00;
+		break;
+
+	case 2:
+		pAd->CommonCfg.HtCapability.MCSSet[0] = 0xff;
+		pAd->CommonCfg.HtCapability.MCSSet[1] = 0xff;
+		break;
+
+	case 3:		// 3*3
+		pAd->CommonCfg.HtCapability.MCSSet[0] = 0xff;
+		pAd->CommonCfg.HtCapability.MCSSet[1] = 0xff;
+		pAd->CommonCfg.HtCapability.MCSSet[2] = 0xff;
+		break;
 	}
 
-	if (pAd->CommonCfg.bForty_Mhz_Intolerant && (pAd->CommonCfg.Channel <= 14) && (pHTPhyMode->BW == BW_40) )
-	{
+	if (pAd->CommonCfg.bForty_Mhz_Intolerant
+	    && (pAd->CommonCfg.Channel <= 14) && (pHTPhyMode->BW == BW_40)) {
 		pHTPhyMode->BW = BW_20;
 		pAd->CommonCfg.HtCapability.HtCapInfo.Forty_Mhz_Intolerant = 1;
 	}
 
-	if(pHTPhyMode->BW == BW_40)
-	{
-		pAd->CommonCfg.HtCapability.MCSSet[4] = 0x1; // MCS 32
+	if (pHTPhyMode->BW == BW_40) {
+		pAd->CommonCfg.HtCapability.MCSSet[4] = 0x1;	// MCS 32
 		pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth = 1;
 		if (pAd->CommonCfg.Channel <= 14)
 			pAd->CommonCfg.HtCapability.HtCapInfo.CCKmodein40 = 1;
 
 		pAd->CommonCfg.DesiredHtPhy.ChannelWidth = 1;
 		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 1;
-		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = (pHTPhyMode->ExtOffset == EXTCHA_BELOW)? (EXTCHA_BELOW): EXTCHA_ABOVE;
+		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset =
+		    (pHTPhyMode->ExtOffset ==
+		     EXTCHA_BELOW) ? (EXTCHA_BELOW) : EXTCHA_ABOVE;
 		// Set Regsiter for extension channel position.
 		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Value);
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBP3Value);
-		if ((pHTPhyMode->ExtOffset == EXTCHA_BELOW))
-		{
+		if ((pHTPhyMode->ExtOffset == EXTCHA_BELOW)) {
 			Value |= 0x1;
 			BBP3Value |= (0x20);
 			RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
-		}
-		else if ((pHTPhyMode->ExtOffset == EXTCHA_ABOVE))
-		{
+		} else if ((pHTPhyMode->ExtOffset == EXTCHA_ABOVE)) {
 			Value &= 0xfe;
 			BBP3Value &= (~0x20);
 			RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
 		}
-
 		// Turn on BBP 40MHz mode now only as AP .
 		// Sta can turn on BBP 40MHz after connection with 40MHz AP. Sta only broadcast 40MHz capability before connection.
 		if ((pAd->OpMode == OPMODE_AP) || INFRA_ON(pAd) || ADHOC_ON(pAd)
-			)
-		{
+		    ) {
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 			BBPValue &= (~0x18);
 			BBPValue |= 0x10;
@@ -540,9 +563,7 @@ VOID	RTMPSetHT(
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBP3Value);
 			pAd->CommonCfg.BBPCurrentBW = BW_40;
 		}
-	}
-	else
-	{
+	} else {
 		pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth = 0;
 		pAd->CommonCfg.DesiredHtPhy.ChannelWidth = 0;
 		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
@@ -557,28 +578,22 @@ VOID	RTMPSetHT(
 		}
 	}
 
-	if(pHTPhyMode->STBC == STBC_USE)
-	{
+	if (pHTPhyMode->STBC == STBC_USE) {
 		pAd->CommonCfg.HtCapability.HtCapInfo.TxSTBC = 1;
 		pAd->CommonCfg.DesiredHtPhy.TxSTBC = 1;
 		pAd->CommonCfg.HtCapability.HtCapInfo.RxSTBC = 1;
 		pAd->CommonCfg.DesiredHtPhy.RxSTBC = 1;
-	}
-	else
-	{
+	} else {
 		pAd->CommonCfg.DesiredHtPhy.TxSTBC = 0;
 		pAd->CommonCfg.DesiredHtPhy.RxSTBC = 0;
 	}
 
-	if(pHTPhyMode->SHORTGI == GI_400)
-	{
+	if (pHTPhyMode->SHORTGI == GI_400) {
 		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor20 = 1;
 		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor40 = 1;
 		pAd->CommonCfg.DesiredHtPhy.ShortGIfor20 = 1;
 		pAd->CommonCfg.DesiredHtPhy.ShortGIfor40 = 1;
-	}
-	else
-	{
+	} else {
 		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor20 = 0;
 		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor40 = 0;
 		pAd->CommonCfg.DesiredHtPhy.ShortGIfor20 = 0;
@@ -586,13 +601,12 @@ VOID	RTMPSetHT(
 	}
 
 	// We support link adaptation for unsolicit MCS feedback, set to 2.
-	pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback = MCSFBK_NONE; //MCSFBK_UNSOLICIT;
+	pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback = MCSFBK_NONE;	//MCSFBK_UNSOLICIT;
 	pAd->CommonCfg.AddHTInfo.ControlChan = pAd->CommonCfg.Channel;
 	// 1, the extension channel above the control channel.
 
 	// EDCA parameters used for AP's own transmission
-	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE)
-	{
+	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE) {
 		pAd->CommonCfg.APEdcaParm.bValid = TRUE;
 		pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
 		pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
@@ -609,16 +623,16 @@ VOID	RTMPSetHT(
 		pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
 		pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
 
-		pAd->CommonCfg.APEdcaParm.Txop[0]  = 0;
-		pAd->CommonCfg.APEdcaParm.Txop[1]  = 0;
-		pAd->CommonCfg.APEdcaParm.Txop[2]  = 94;
-		pAd->CommonCfg.APEdcaParm.Txop[3]  = 47;
+		pAd->CommonCfg.APEdcaParm.Txop[0] = 0;
+		pAd->CommonCfg.APEdcaParm.Txop[1] = 0;
+		pAd->CommonCfg.APEdcaParm.Txop[2] = 94;
+		pAd->CommonCfg.APEdcaParm.Txop[3] = 47;
 	}
 	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
 
-		{
-	RTMPSetIndividualHT(pAd, 0);
-		}
+	{
+		RTMPSetIndividualHT(pAd, 0);
+	}
 
 }
 
@@ -634,112 +648,103 @@ VOID	RTMPSetHT(
 
 	========================================================================
 */
-VOID	RTMPSetIndividualHT(
-	IN	PRTMP_ADAPTER		pAd,
-	IN	UCHAR				apidx)
-{
-	PRT_HT_PHY_INFO		pDesired_ht_phy = NULL;
-	UCHAR	TxStream = pAd->CommonCfg.TxStream;
-	UCHAR	DesiredMcs	= MCS_AUTO;
+VOID RTMPSetIndividualHT(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
+{
+	PRT_HT_PHY_INFO pDesired_ht_phy = NULL;
+	UCHAR TxStream = pAd->CommonCfg.TxStream;
+	UCHAR DesiredMcs = MCS_AUTO;
 
-	do
-	{
+	do {
 		{
 			pDesired_ht_phy = &pAd->StaCfg.DesiredHtPhyInfo;
-			DesiredMcs = pAd->StaCfg.DesiredTransmitSetting.field.MCS;
+			DesiredMcs =
+			    pAd->StaCfg.DesiredTransmitSetting.field.MCS;
 			//pAd->StaCfg.bAutoTxRateSwitch = (DesiredMcs == MCS_AUTO) ? TRUE : FALSE;
-				break;
+			break;
 		}
 	} while (FALSE);
 
-	if (pDesired_ht_phy == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSetIndividualHT: invalid apidx(%d)\n", apidx));
+	if (pDesired_ht_phy == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTMPSetIndividualHT: invalid apidx(%d)\n", apidx));
 		return;
 	}
 	RTMPZeroMemory(pDesired_ht_phy, sizeof(RT_HT_PHY_INFO));
 
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPSetIndividualHT : Desired MCS = %d\n", DesiredMcs));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPSetIndividualHT : Desired MCS = %d\n", DesiredMcs));
 	// Check the validity of MCS
-	if ((TxStream == 1) && ((DesiredMcs >= MCS_8) && (DesiredMcs <= MCS_15)))
-	{
-		DBGPRINT(RT_DEBUG_WARN, ("RTMPSetIndividualHT: MCS(%d) is invalid in 1S, reset it as MCS_7\n", DesiredMcs));
+	if ((TxStream == 1)
+	    && ((DesiredMcs >= MCS_8) && (DesiredMcs <= MCS_15))) {
+		DBGPRINT(RT_DEBUG_WARN,
+			 ("RTMPSetIndividualHT: MCS(%d) is invalid in 1S, reset it as MCS_7\n",
+			  DesiredMcs));
 		DesiredMcs = MCS_7;
 	}
 
-	if ((pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BW_20) && (DesiredMcs == MCS_32))
-	{
-		DBGPRINT(RT_DEBUG_WARN, ("RTMPSetIndividualHT: MCS_32 is only supported in 40-MHz, reset it as MCS_0\n"));
+	if ((pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BW_20)
+	    && (DesiredMcs == MCS_32)) {
+		DBGPRINT(RT_DEBUG_WARN,
+			 ("RTMPSetIndividualHT: MCS_32 is only supported in 40-MHz, reset it as MCS_0\n"));
 		DesiredMcs = MCS_0;
 	}
 
 	pDesired_ht_phy->bHtEnable = TRUE;
 
 	// Decide desired Tx MCS
-	switch (TxStream)
-	{
-		case 1:
-			if (DesiredMcs == MCS_AUTO)
-			{
-				pDesired_ht_phy->MCSSet[0]= 0xff;
-				pDesired_ht_phy->MCSSet[1]= 0x00;
-			}
-			else if (DesiredMcs <= MCS_7)
-			{
-				pDesired_ht_phy->MCSSet[0]= 1<<DesiredMcs;
-				pDesired_ht_phy->MCSSet[1]= 0x00;
-			}
-			break;
+	switch (TxStream) {
+	case 1:
+		if (DesiredMcs == MCS_AUTO) {
+			pDesired_ht_phy->MCSSet[0] = 0xff;
+			pDesired_ht_phy->MCSSet[1] = 0x00;
+		} else if (DesiredMcs <= MCS_7) {
+			pDesired_ht_phy->MCSSet[0] = 1 << DesiredMcs;
+			pDesired_ht_phy->MCSSet[1] = 0x00;
+		}
+		break;
 
-		case 2:
-			if (DesiredMcs == MCS_AUTO)
-			{
-				pDesired_ht_phy->MCSSet[0]= 0xff;
-				pDesired_ht_phy->MCSSet[1]= 0xff;
-			}
-			else if (DesiredMcs <= MCS_15)
-			{
-				ULONG mode;
-
-				mode = DesiredMcs / 8;
-				if (mode < 2)
-					pDesired_ht_phy->MCSSet[mode] = (1 << (DesiredMcs - mode * 8));
-			}
-			break;
+	case 2:
+		if (DesiredMcs == MCS_AUTO) {
+			pDesired_ht_phy->MCSSet[0] = 0xff;
+			pDesired_ht_phy->MCSSet[1] = 0xff;
+		} else if (DesiredMcs <= MCS_15) {
+			ULONG mode;
+
+			mode = DesiredMcs / 8;
+			if (mode < 2)
+				pDesired_ht_phy->MCSSet[mode] =
+				    (1 << (DesiredMcs - mode * 8));
+		}
+		break;
 
-		case 3: // 3*3
-			if (DesiredMcs == MCS_AUTO)
-			{
-				/* MCS0 ~ MCS23, 3 bytes */
-				pDesired_ht_phy->MCSSet[0]= 0xff;
-				pDesired_ht_phy->MCSSet[1]= 0xff;
-				pDesired_ht_phy->MCSSet[2]= 0xff;
-			}
-			else if (DesiredMcs <= MCS_23)
-			{
-				ULONG mode;
-
-				mode = DesiredMcs / 8;
-				if (mode < 3)
-					pDesired_ht_phy->MCSSet[mode] = (1 << (DesiredMcs - mode * 8));
-			}
-			break;
+	case 3:		// 3*3
+		if (DesiredMcs == MCS_AUTO) {
+			/* MCS0 ~ MCS23, 3 bytes */
+			pDesired_ht_phy->MCSSet[0] = 0xff;
+			pDesired_ht_phy->MCSSet[1] = 0xff;
+			pDesired_ht_phy->MCSSet[2] = 0xff;
+		} else if (DesiredMcs <= MCS_23) {
+			ULONG mode;
+
+			mode = DesiredMcs / 8;
+			if (mode < 3)
+				pDesired_ht_phy->MCSSet[mode] =
+				    (1 << (DesiredMcs - mode * 8));
+		}
+		break;
 	}
 
-	if(pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BW_40)
-	{
+	if (pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BW_40) {
 		if (DesiredMcs == MCS_AUTO || DesiredMcs == MCS_32)
 			pDesired_ht_phy->MCSSet[4] = 0x1;
 	}
-
 	// update HT Rate setting
-    if (pAd->OpMode == OPMODE_STA)
-        MlmeUpdateHtTxRates(pAd, BSS0);
-    else
-	    MlmeUpdateHtTxRates(pAd, apidx);
+	if (pAd->OpMode == OPMODE_STA)
+		MlmeUpdateHtTxRates(pAd, BSS0);
+	else
+		MlmeUpdateHtTxRates(pAd, apidx);
 }
 
-
 /*
 	========================================================================
 	Routine Description:
@@ -748,36 +753,34 @@ VOID	RTMPSetIndividualHT(
 	Arguments:
 		Send all HT IE in beacon/probe rsp/assoc rsp/action frame.
 
-
 	========================================================================
 */
-VOID	RTMPUpdateHTIE(
-	IN	RT_HT_CAPABILITY	*pRtHt,
-	IN		UCHAR				*pMcsSet,
-	OUT		HT_CAPABILITY_IE *pHtCapability,
-	OUT		ADD_HT_INFO_IE		*pAddHtInfo)
+VOID RTMPUpdateHTIE(IN RT_HT_CAPABILITY * pRtHt,
+		    IN UCHAR * pMcsSet,
+		    OUT HT_CAPABILITY_IE * pHtCapability,
+		    OUT ADD_HT_INFO_IE * pAddHtInfo)
 {
 	RTMPZeroMemory(pHtCapability, sizeof(HT_CAPABILITY_IE));
 	RTMPZeroMemory(pAddHtInfo, sizeof(ADD_HT_INFO_IE));
 
-		pHtCapability->HtCapInfo.ChannelWidth = pRtHt->ChannelWidth;
-		pHtCapability->HtCapInfo.MimoPs = pRtHt->MimoPs;
-		pHtCapability->HtCapInfo.GF = pRtHt->GF;
-		pHtCapability->HtCapInfo.ShortGIfor20 = pRtHt->ShortGIfor20;
-		pHtCapability->HtCapInfo.ShortGIfor40 = pRtHt->ShortGIfor40;
-		pHtCapability->HtCapInfo.TxSTBC = pRtHt->TxSTBC;
-		pHtCapability->HtCapInfo.RxSTBC = pRtHt->RxSTBC;
-		pHtCapability->HtCapInfo.AMsduSize = pRtHt->AmsduSize;
-		pHtCapability->HtCapParm.MaxRAmpduFactor = pRtHt->MaxRAmpduFactor;
-		pHtCapability->HtCapParm.MpduDensity = pRtHt->MpduDensity;
-
-		pAddHtInfo->AddHtInfo.ExtChanOffset = pRtHt->ExtChanOffset ;
-		pAddHtInfo->AddHtInfo.RecomWidth = pRtHt->RecomWidth;
-		pAddHtInfo->AddHtInfo2.OperaionMode = pRtHt->OperaionMode;
-		pAddHtInfo->AddHtInfo2.NonGfPresent = pRtHt->NonGfPresent;
-		RTMPMoveMemory(pAddHtInfo->MCSSet, /*pRtHt->MCSSet*/pMcsSet, 4); // rt2860 only support MCS max=32, no need to copy all 16 uchar.
+	pHtCapability->HtCapInfo.ChannelWidth = pRtHt->ChannelWidth;
+	pHtCapability->HtCapInfo.MimoPs = pRtHt->MimoPs;
+	pHtCapability->HtCapInfo.GF = pRtHt->GF;
+	pHtCapability->HtCapInfo.ShortGIfor20 = pRtHt->ShortGIfor20;
+	pHtCapability->HtCapInfo.ShortGIfor40 = pRtHt->ShortGIfor40;
+	pHtCapability->HtCapInfo.TxSTBC = pRtHt->TxSTBC;
+	pHtCapability->HtCapInfo.RxSTBC = pRtHt->RxSTBC;
+	pHtCapability->HtCapInfo.AMsduSize = pRtHt->AmsduSize;
+	pHtCapability->HtCapParm.MaxRAmpduFactor = pRtHt->MaxRAmpduFactor;
+	pHtCapability->HtCapParm.MpduDensity = pRtHt->MpduDensity;
+
+	pAddHtInfo->AddHtInfo.ExtChanOffset = pRtHt->ExtChanOffset;
+	pAddHtInfo->AddHtInfo.RecomWidth = pRtHt->RecomWidth;
+	pAddHtInfo->AddHtInfo2.OperaionMode = pRtHt->OperaionMode;
+	pAddHtInfo->AddHtInfo2.NonGfPresent = pRtHt->NonGfPresent;
+	RTMPMoveMemory(pAddHtInfo->MCSSet, /*pRtHt->MCSSet */ pMcsSet, 4);	// rt2860 only support MCS max=32, no need to copy all 16 uchar.
 
-        DBGPRINT(RT_DEBUG_TRACE,("RTMPUpdateHTIE <== \n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("RTMPUpdateHTIE <== \n"));
 }
 
 /*
@@ -787,29 +790,27 @@ VOID	RTMPUpdateHTIE(
     Return:
 	========================================================================
 */
-VOID	RTMPAddWcidAttributeEntry(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			BssIdx,
-	IN 	UCHAR		 	KeyIdx,
-	IN 	UCHAR		 	CipherAlg,
-	IN 	MAC_TABLE_ENTRY *pEntry)
-{
-	UINT32		WCIDAttri = 0;
-	USHORT		offset;
-	UCHAR		IVEIV = 0;
-	USHORT		Wcid = 0;
+VOID RTMPAddWcidAttributeEntry(IN PRTMP_ADAPTER pAd,
+			       IN UCHAR BssIdx,
+			       IN UCHAR KeyIdx,
+			       IN UCHAR CipherAlg, IN MAC_TABLE_ENTRY * pEntry)
+{
+	UINT32 WCIDAttri = 0;
+	USHORT offset;
+	UCHAR IVEIV = 0;
+	USHORT Wcid = 0;
 
 	{
 		{
-			if (BssIdx > BSS0)
-			{
-				DBGPRINT(RT_DEBUG_ERROR, ("RTMPAddWcidAttributeEntry: The BSS-index(%d) is out of range for Infra link. \n", BssIdx));
+			if (BssIdx > BSS0) {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("RTMPAddWcidAttributeEntry: The BSS-index(%d) is out of range for Infra link. \n",
+					  BssIdx));
 				return;
 			}
-
-			// 1.	In ADHOC mode, the AID is wcid number. And NO mesh link exists.
-			// 2.	In Infra mode, the AID:1 MUST be wcid of infra STA.
-			//					   the AID:2~ assign to mesh link entry.
+			// 1.   In ADHOC mode, the AID is wcid number. And NO mesh link exists.
+			// 2.   In Infra mode, the AID:1 MUST be wcid of infra STA.
+			//                                         the AID:2~ assign to mesh link entry.
 			if (pEntry)
 				Wcid = pEntry->Aid;
 			else
@@ -822,39 +823,38 @@ VOID	RTMPAddWcidAttributeEntry(
 
 	{
 		if (pEntry && pEntry->ValidAsMesh)
-			WCIDAttri = (CipherAlg<<1) | PAIRWISEKEYTABLE;
+			WCIDAttri = (CipherAlg << 1) | PAIRWISEKEYTABLE;
 		else
-			WCIDAttri = (CipherAlg<<1) | SHAREDKEYTABLE;
+			WCIDAttri = (CipherAlg << 1) | SHAREDKEYTABLE;
 	}
 
 	RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
 
-
 	// Update IV/EIV table
 	offset = MAC_IVEIV_TABLE_BASE + (Wcid * HW_IVEIV_ENTRY_SIZE);
 
 	// WPA mode
-	if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC) || (CipherAlg == CIPHER_AES))
-	{
+	if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC)
+	    || (CipherAlg == CIPHER_AES)) {
 		// Eiv bit on. keyid always is 0 for pairwise key
-		IVEIV = (KeyIdx <<6) | 0x20;
-	}
-	else
-	{
+		IVEIV = (KeyIdx << 6) | 0x20;
+	} else {
 		// WEP KeyIdx is default tx key.
 		IVEIV = (KeyIdx << 6);
 	}
 
 	// For key index and ext IV bit, so only need to update the position(offset+3).
 #ifdef RTMP_MAC_PCI
-	RTMP_IO_WRITE8(pAd, offset+3, IVEIV);
+	RTMP_IO_WRITE8(pAd, offset + 3, IVEIV);
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
-	RTUSBMultiWrite_OneByte(pAd, offset+3, &IVEIV);
+	RTUSBMultiWrite_OneByte(pAd, offset + 3, &IVEIV);
 #endif // RTMP_MAC_USB //
 
-	DBGPRINT(RT_DEBUG_TRACE,("RTMPAddWcidAttributeEntry: WCID #%d, KeyIndex #%d, Alg=%s\n",Wcid, KeyIdx, CipherName[CipherAlg]));
-	DBGPRINT(RT_DEBUG_TRACE,("	WCIDAttri = 0x%x \n",  WCIDAttri));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPAddWcidAttributeEntry: WCID #%d, KeyIndex #%d, Alg=%s\n",
+		  Wcid, KeyIdx, CipherName[CipherAlg]));
+	DBGPRINT(RT_DEBUG_TRACE, ("	WCIDAttri = 0x%x \n", WCIDAttri));
 
 }
 
@@ -874,84 +874,82 @@ Arguments:
 */
 PSTRING GetEncryptType(CHAR enc)
 {
-    if(enc == Ndis802_11WEPDisabled)
-        return "NONE";
-    if(enc == Ndis802_11WEPEnabled)
-    	return "WEP";
-    if(enc == Ndis802_11Encryption2Enabled)
-    	return "TKIP";
-    if(enc == Ndis802_11Encryption3Enabled)
-    	return "AES";
-	if(enc == Ndis802_11Encryption4Enabled)
-    	return "TKIPAES";
-    else
-    	return "UNKNOW";
+	if (enc == Ndis802_11WEPDisabled)
+		return "NONE";
+	if (enc == Ndis802_11WEPEnabled)
+		return "WEP";
+	if (enc == Ndis802_11Encryption2Enabled)
+		return "TKIP";
+	if (enc == Ndis802_11Encryption3Enabled)
+		return "AES";
+	if (enc == Ndis802_11Encryption4Enabled)
+		return "TKIPAES";
+	else
+		return "UNKNOW";
 }
 
 PSTRING GetAuthMode(CHAR auth)
 {
-    if(auth == Ndis802_11AuthModeOpen)
-    	return "OPEN";
-    if(auth == Ndis802_11AuthModeShared)
-    	return "SHARED";
-	if(auth == Ndis802_11AuthModeAutoSwitch)
-    	return "AUTOWEP";
-    if(auth == Ndis802_11AuthModeWPA)
-    	return "WPA";
-    if(auth == Ndis802_11AuthModeWPAPSK)
-    	return "WPAPSK";
-    if(auth == Ndis802_11AuthModeWPANone)
-    	return "WPANONE";
-    if(auth == Ndis802_11AuthModeWPA2)
-    	return "WPA2";
-    if(auth == Ndis802_11AuthModeWPA2PSK)
-    	return "WPA2PSK";
-	if(auth == Ndis802_11AuthModeWPA1WPA2)
-    	return "WPA1WPA2";
-	if(auth == Ndis802_11AuthModeWPA1PSKWPA2PSK)
-    	return "WPA1PSKWPA2PSK";
+	if (auth == Ndis802_11AuthModeOpen)
+		return "OPEN";
+	if (auth == Ndis802_11AuthModeShared)
+		return "SHARED";
+	if (auth == Ndis802_11AuthModeAutoSwitch)
+		return "AUTOWEP";
+	if (auth == Ndis802_11AuthModeWPA)
+		return "WPA";
+	if (auth == Ndis802_11AuthModeWPAPSK)
+		return "WPAPSK";
+	if (auth == Ndis802_11AuthModeWPANone)
+		return "WPANONE";
+	if (auth == Ndis802_11AuthModeWPA2)
+		return "WPA2";
+	if (auth == Ndis802_11AuthModeWPA2PSK)
+		return "WPA2PSK";
+	if (auth == Ndis802_11AuthModeWPA1WPA2)
+		return "WPA1WPA2";
+	if (auth == Ndis802_11AuthModeWPA1PSKWPA2PSK)
+		return "WPA1PSKWPA2PSK";
 
-    	return "UNKNOW";
+	return "UNKNOW";
 }
 
-INT	SetCommonHT(
-	IN	PRTMP_ADAPTER	pAd)
+INT SetCommonHT(IN PRTMP_ADAPTER pAd)
 {
-	OID_SET_HT_PHYMODE		SetHT;
+	OID_SET_HT_PHYMODE SetHT;
 
 	if (pAd->CommonCfg.PhyMode < PHY_11ABGN_MIXED)
 		return FALSE;
 
 	SetHT.PhyMode = pAd->CommonCfg.PhyMode;
-	SetHT.TransmitNo = ((UCHAR)pAd->Antenna.field.TxPath);
-	SetHT.HtMode = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.HTMODE;
-	SetHT.ExtOffset = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
+	SetHT.TransmitNo = ((UCHAR) pAd->Antenna.field.TxPath);
+	SetHT.HtMode = (UCHAR) pAd->CommonCfg.RegTransmitSetting.field.HTMODE;
+	SetHT.ExtOffset =
+	    (UCHAR) pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
 	SetHT.MCS = MCS_AUTO;
-	SetHT.BW = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.BW;
-	SetHT.STBC = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.STBC;
-	SetHT.SHORTGI = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.ShortGI;
+	SetHT.BW = (UCHAR) pAd->CommonCfg.RegTransmitSetting.field.BW;
+	SetHT.STBC = (UCHAR) pAd->CommonCfg.RegTransmitSetting.field.STBC;
+	SetHT.SHORTGI = (UCHAR) pAd->CommonCfg.RegTransmitSetting.field.ShortGI;
 
 	RTMPSetHT(pAd, &SetHT);
 
 	return TRUE;
 }
 
-PSTRING RTMPGetRalinkEncryModeStr(
-    IN  USHORT encryMode)
+PSTRING RTMPGetRalinkEncryModeStr(IN USHORT encryMode)
 {
-	switch(encryMode)
-	{
-		case Ndis802_11WEPDisabled:
-			return "NONE";
-		case Ndis802_11WEPEnabled:
-			return "WEP";
-		case Ndis802_11Encryption2Enabled:
-			return "TKIP";
-		case Ndis802_11Encryption3Enabled:
-			return "AES";
-        case Ndis802_11Encryption4Enabled:
-			return "TKIPAES";
-		default:
-			return "UNKNOW";
+	switch (encryMode) {
+	case Ndis802_11WEPDisabled:
+		return "NONE";
+	case Ndis802_11WEPEnabled:
+		return "WEP";
+	case Ndis802_11Encryption2Enabled:
+		return "TKIP";
+	case Ndis802_11Encryption3Enabled:
+		return "AES";
+	case Ndis802_11Encryption4Enabled:
+		return "TKIPAES";
+	default:
+		return "UNKNOW";
 	}
 }
--- a/drivers/staging/rt2860/common/cmm_mac_pci.c
+++ b/drivers/staging/rt2860/common/cmm_mac_pci.c
@@ -25,11 +25,9 @@
  *************************************************************************
 */
 
-
 #ifdef RTMP_MAC_PCI
 #include	"../rt_config.h"
 
-
 /*
 	========================================================================
 
@@ -50,115 +48,125 @@
 
 	========================================================================
 */
-NDIS_STATUS	RTMPAllocTxRxRingMemory(
-	IN	PRTMP_ADAPTER	pAd)
+NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 {
-	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
-	ULONG			RingBasePaHigh;
-	ULONG			RingBasePaLow;
-	PVOID			RingBaseVa;
-	INT				index, num;
-	PTXD_STRUC		pTxD;
-	PRXD_STRUC		pRxD;
-	ULONG			ErrorValue = 0;
-	PRTMP_TX_RING	pTxRing;
-	PRTMP_DMABUF	pDmaBuf;
-	PNDIS_PACKET	pPacket;
-//	PRTMP_REORDERBUF	pReorderBuf;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+	ULONG RingBasePaHigh;
+	ULONG RingBasePaLow;
+	PVOID RingBaseVa;
+	INT index, num;
+	PTXD_STRUC pTxD;
+	PRXD_STRUC pRxD;
+	ULONG ErrorValue = 0;
+	PRTMP_TX_RING pTxRing;
+	PRTMP_DMABUF pDmaBuf;
+	PNDIS_PACKET pPacket;
+//      PRTMP_REORDERBUF        pReorderBuf;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPAllocTxRxRingMemory\n"));
-	do
-	{
+	do {
 		//
 		// Allocate all ring descriptors, include TxD, RxD, MgmtD.
 		// Although each size is different, to prevent cacheline and alignment
 		// issue, I intentional set them all to 64 bytes.
 		//
-		for (num=0; num<NUM_OF_TX_RING; num++)
-		{
-			ULONG  BufBasePaHigh;
-			ULONG  BufBasePaLow;
-			PVOID  BufBaseVa;
+		for (num = 0; num < NUM_OF_TX_RING; num++) {
+			ULONG BufBasePaHigh;
+			ULONG BufBasePaLow;
+			PVOID BufBaseVa;
 
 			//
 			// Allocate Tx ring descriptor's memory (5 TX rings = 4 ACs + 1 HCCA)
 			//
-			pAd->TxDescRing[num].AllocSize = TX_RING_SIZE * TXD_SIZE;
-			RTMP_AllocateTxDescMemory(
-				pAd,
-				num,
-				pAd->TxDescRing[num].AllocSize,
-				FALSE,
-				&pAd->TxDescRing[num].AllocVa,
-				&pAd->TxDescRing[num].AllocPa);
+			pAd->TxDescRing[num].AllocSize =
+			    TX_RING_SIZE * TXD_SIZE;
+			RTMP_AllocateTxDescMemory(pAd, num,
+						  pAd->TxDescRing[num].
+						  AllocSize, FALSE,
+						  &pAd->TxDescRing[num].AllocVa,
+						  &pAd->TxDescRing[num].
+						  AllocPa);
 
-			if (pAd->TxDescRing[num].AllocVa == NULL)
-			{
+			if (pAd->TxDescRing[num].AllocVa == NULL) {
 				ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
 				DBGPRINT_ERR(("Failed to allocate a big buffer\n"));
 				Status = NDIS_STATUS_RESOURCES;
 				break;
 			}
-
 			// Zero init this memory block
-			NdisZeroMemory(pAd->TxDescRing[num].AllocVa, pAd->TxDescRing[num].AllocSize);
+			NdisZeroMemory(pAd->TxDescRing[num].AllocVa,
+				       pAd->TxDescRing[num].AllocSize);
 
 			// Save PA & VA for further operation
-			RingBasePaHigh = RTMP_GetPhysicalAddressHigh(pAd->TxDescRing[num].AllocPa);
-			RingBasePaLow  = RTMP_GetPhysicalAddressLow (pAd->TxDescRing[num].AllocPa);
-			RingBaseVa     = pAd->TxDescRing[num].AllocVa;
+			RingBasePaHigh =
+			    RTMP_GetPhysicalAddressHigh(pAd->TxDescRing[num].
+							AllocPa);
+			RingBasePaLow =
+			    RTMP_GetPhysicalAddressLow(pAd->TxDescRing[num].
+						       AllocPa);
+			RingBaseVa = pAd->TxDescRing[num].AllocVa;
 
 			//
 			// Allocate all 1st TXBuf's memory for this TxRing
 			//
-			pAd->TxBufSpace[num].AllocSize = TX_RING_SIZE * TX_DMA_1ST_BUFFER_SIZE;
-			RTMP_AllocateFirstTxBuffer(
-				pAd,
-				num,
-				pAd->TxBufSpace[num].AllocSize,
-				FALSE,
-				&pAd->TxBufSpace[num].AllocVa,
-				&pAd->TxBufSpace[num].AllocPa);
+			pAd->TxBufSpace[num].AllocSize =
+			    TX_RING_SIZE * TX_DMA_1ST_BUFFER_SIZE;
+			RTMP_AllocateFirstTxBuffer(pAd, num,
+						   pAd->TxBufSpace[num].
+						   AllocSize, FALSE,
+						   &pAd->TxBufSpace[num].
+						   AllocVa,
+						   &pAd->TxBufSpace[num].
+						   AllocPa);
 
-			if (pAd->TxBufSpace[num].AllocVa == NULL)
-			{
+			if (pAd->TxBufSpace[num].AllocVa == NULL) {
 				ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
 				DBGPRINT_ERR(("Failed to allocate a big buffer\n"));
 				Status = NDIS_STATUS_RESOURCES;
 				break;
 			}
-
 			// Zero init this memory block
-			NdisZeroMemory(pAd->TxBufSpace[num].AllocVa, pAd->TxBufSpace[num].AllocSize);
+			NdisZeroMemory(pAd->TxBufSpace[num].AllocVa,
+				       pAd->TxBufSpace[num].AllocSize);
 
 			// Save PA & VA for further operation
-			BufBasePaHigh = RTMP_GetPhysicalAddressHigh(pAd->TxBufSpace[num].AllocPa);
-			BufBasePaLow  = RTMP_GetPhysicalAddressLow (pAd->TxBufSpace[num].AllocPa);
-			BufBaseVa     = pAd->TxBufSpace[num].AllocVa;
+			BufBasePaHigh =
+			    RTMP_GetPhysicalAddressHigh(pAd->TxBufSpace[num].
+							AllocPa);
+			BufBasePaLow =
+			    RTMP_GetPhysicalAddressLow(pAd->TxBufSpace[num].
+						       AllocPa);
+			BufBaseVa = pAd->TxBufSpace[num].AllocVa;
 
 			//
 			// Initialize Tx Ring Descriptor and associated buffer memory
 			//
 			pTxRing = &pAd->TxRing[num];
-			for (index = 0; index < TX_RING_SIZE; index++)
-			{
+			for (index = 0; index < TX_RING_SIZE; index++) {
 				pTxRing->Cell[index].pNdisPacket = NULL;
 				pTxRing->Cell[index].pNextNdisPacket = NULL;
 				// Init Tx Ring Size, Va, Pa variables
 				pTxRing->Cell[index].AllocSize = TXD_SIZE;
 				pTxRing->Cell[index].AllocVa = RingBaseVa;
-				RTMP_SetPhysicalAddressHigh(pTxRing->Cell[index].AllocPa, RingBasePaHigh);
-				RTMP_SetPhysicalAddressLow (pTxRing->Cell[index].AllocPa, RingBasePaLow);
+				RTMP_SetPhysicalAddressHigh(pTxRing->
+							    Cell[index].AllocPa,
+							    RingBasePaHigh);
+				RTMP_SetPhysicalAddressLow(pTxRing->Cell[index].
+							   AllocPa,
+							   RingBasePaLow);
 
 				// Setup Tx Buffer size & address. only 802.11 header will store in this space
 				pDmaBuf = &pTxRing->Cell[index].DmaBuf;
 				pDmaBuf->AllocSize = TX_DMA_1ST_BUFFER_SIZE;
 				pDmaBuf->AllocVa = BufBaseVa;
-				RTMP_SetPhysicalAddressHigh(pDmaBuf->AllocPa, BufBasePaHigh);
-				RTMP_SetPhysicalAddressLow(pDmaBuf->AllocPa, BufBasePaLow);
+				RTMP_SetPhysicalAddressHigh(pDmaBuf->AllocPa,
+							    BufBasePaHigh);
+				RTMP_SetPhysicalAddressLow(pDmaBuf->AllocPa,
+							   BufBasePaLow);
 
 				// link the pre-allocated TxBuf to TXD
-				pTxD = (PTXD_STRUC) pTxRing->Cell[index].AllocVa;
+				pTxD =
+				    (PTXD_STRUC) pTxRing->Cell[index].AllocVa;
 				pTxD->SDPtr0 = BufBasePaLow;
 				// advance to next ring descriptor address
 				pTxD->DMADONE = 1;
@@ -167,9 +175,12 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 
 				// advance to next TxBuf address
 				BufBasePaLow += TX_DMA_1ST_BUFFER_SIZE;
-				BufBaseVa = (PUCHAR) BufBaseVa + TX_DMA_1ST_BUFFER_SIZE;
+				BufBaseVa =
+				    (PUCHAR) BufBaseVa + TX_DMA_1ST_BUFFER_SIZE;
 			}
-			DBGPRINT(RT_DEBUG_TRACE, ("TxRing[%d]: total %d entry allocated\n", num, index));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("TxRing[%d]: total %d entry allocated\n", num,
+				  index));
 		}
 		if (Status == NDIS_STATUS_RESOURCES)
 			break;
@@ -178,41 +189,42 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 		// Allocate MGMT ring descriptor's memory except Tx ring which allocated eariler
 		//
 		pAd->MgmtDescRing.AllocSize = MGMT_RING_SIZE * TXD_SIZE;
-		RTMP_AllocateMgmtDescMemory(
-			pAd,
-			pAd->MgmtDescRing.AllocSize,
-			FALSE,
-			&pAd->MgmtDescRing.AllocVa,
-			&pAd->MgmtDescRing.AllocPa);
+		RTMP_AllocateMgmtDescMemory(pAd,
+					    pAd->MgmtDescRing.AllocSize,
+					    FALSE,
+					    &pAd->MgmtDescRing.AllocVa,
+					    &pAd->MgmtDescRing.AllocPa);
 
-		if (pAd->MgmtDescRing.AllocVa == NULL)
-		{
+		if (pAd->MgmtDescRing.AllocVa == NULL) {
 			ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
 			DBGPRINT_ERR(("Failed to allocate a big buffer\n"));
 			Status = NDIS_STATUS_RESOURCES;
 			break;
 		}
-
 		// Zero init this memory block
-		NdisZeroMemory(pAd->MgmtDescRing.AllocVa, pAd->MgmtDescRing.AllocSize);
+		NdisZeroMemory(pAd->MgmtDescRing.AllocVa,
+			       pAd->MgmtDescRing.AllocSize);
 
 		// Save PA & VA for further operation
-		RingBasePaHigh = RTMP_GetPhysicalAddressHigh(pAd->MgmtDescRing.AllocPa);
-		RingBasePaLow  = RTMP_GetPhysicalAddressLow (pAd->MgmtDescRing.AllocPa);
-		RingBaseVa     = pAd->MgmtDescRing.AllocVa;
+		RingBasePaHigh =
+		    RTMP_GetPhysicalAddressHigh(pAd->MgmtDescRing.AllocPa);
+		RingBasePaLow =
+		    RTMP_GetPhysicalAddressLow(pAd->MgmtDescRing.AllocPa);
+		RingBaseVa = pAd->MgmtDescRing.AllocVa;
 
 		//
 		// Initialize MGMT Ring and associated buffer memory
 		//
-		for (index = 0; index < MGMT_RING_SIZE; index++)
-		{
+		for (index = 0; index < MGMT_RING_SIZE; index++) {
 			pAd->MgmtRing.Cell[index].pNdisPacket = NULL;
 			pAd->MgmtRing.Cell[index].pNextNdisPacket = NULL;
 			// Init MGMT Ring Size, Va, Pa variables
 			pAd->MgmtRing.Cell[index].AllocSize = TXD_SIZE;
 			pAd->MgmtRing.Cell[index].AllocVa = RingBaseVa;
-			RTMP_SetPhysicalAddressHigh(pAd->MgmtRing.Cell[index].AllocPa, RingBasePaHigh);
-			RTMP_SetPhysicalAddressLow (pAd->MgmtRing.Cell[index].AllocPa, RingBasePaLow);
+			RTMP_SetPhysicalAddressHigh(pAd->MgmtRing.Cell[index].
+						    AllocPa, RingBasePaHigh);
+			RTMP_SetPhysicalAddressLow(pAd->MgmtRing.Cell[index].
+						   AllocPa, RingBasePaLow);
 
 			// Offset to next ring descriptor address
 			RingBasePaLow += TXD_SIZE;
@@ -224,49 +236,51 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 
 			// no pre-allocated buffer required in MgmtRing for scatter-gather case
 		}
-		DBGPRINT(RT_DEBUG_TRACE, ("MGMT Ring: total %d entry allocated\n", index));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MGMT Ring: total %d entry allocated\n", index));
 
 		//
 		// Allocate RX ring descriptor's memory except Tx ring which allocated eariler
 		//
 		pAd->RxDescRing.AllocSize = RX_RING_SIZE * RXD_SIZE;
-		RTMP_AllocateRxDescMemory(
-			pAd,
-			pAd->RxDescRing.AllocSize,
-			FALSE,
-			&pAd->RxDescRing.AllocVa,
-			&pAd->RxDescRing.AllocPa);
+		RTMP_AllocateRxDescMemory(pAd,
+					  pAd->RxDescRing.AllocSize,
+					  FALSE,
+					  &pAd->RxDescRing.AllocVa,
+					  &pAd->RxDescRing.AllocPa);
 
-		if (pAd->RxDescRing.AllocVa == NULL)
-		{
+		if (pAd->RxDescRing.AllocVa == NULL) {
 			ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
 			DBGPRINT_ERR(("Failed to allocate a big buffer\n"));
 			Status = NDIS_STATUS_RESOURCES;
 			break;
 		}
-
 		// Zero init this memory block
-		NdisZeroMemory(pAd->RxDescRing.AllocVa, pAd->RxDescRing.AllocSize);
-
+		NdisZeroMemory(pAd->RxDescRing.AllocVa,
+			       pAd->RxDescRing.AllocSize);
 
 		DBGPRINT(RT_DEBUG_OFF,
-					("RX DESC %p  size = %ld\n", pAd->RxDescRing.AllocVa, pAd->RxDescRing.AllocSize));
+			 ("RX DESC %p  size = %ld\n", pAd->RxDescRing.AllocVa,
+			  pAd->RxDescRing.AllocSize));
 
 		// Save PA & VA for further operation
-		RingBasePaHigh = RTMP_GetPhysicalAddressHigh(pAd->RxDescRing.AllocPa);
-		RingBasePaLow  = RTMP_GetPhysicalAddressLow (pAd->RxDescRing.AllocPa);
-		RingBaseVa     = pAd->RxDescRing.AllocVa;
+		RingBasePaHigh =
+		    RTMP_GetPhysicalAddressHigh(pAd->RxDescRing.AllocPa);
+		RingBasePaLow =
+		    RTMP_GetPhysicalAddressLow(pAd->RxDescRing.AllocPa);
+		RingBaseVa = pAd->RxDescRing.AllocVa;
 
 		//
 		// Initialize Rx Ring and associated buffer memory
 		//
-		for (index = 0; index < RX_RING_SIZE; index++)
-		{
+		for (index = 0; index < RX_RING_SIZE; index++) {
 			// Init RX Ring Size, Va, Pa variables
 			pAd->RxRing.Cell[index].AllocSize = RXD_SIZE;
 			pAd->RxRing.Cell[index].AllocVa = RingBaseVa;
-			RTMP_SetPhysicalAddressHigh(pAd->RxRing.Cell[index].AllocPa, RingBasePaHigh);
-			RTMP_SetPhysicalAddressLow (pAd->RxRing.Cell[index].AllocPa, RingBasePaLow);
+			RTMP_SetPhysicalAddressHigh(pAd->RxRing.Cell[index].
+						    AllocPa, RingBasePaHigh);
+			RTMP_SetPhysicalAddressLow(pAd->RxRing.Cell[index].
+						   AllocPa, RingBasePaLow);
 
 			//NdisZeroMemory(RingBaseVa, RXD_SIZE);
 
@@ -277,61 +291,57 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 			// Setup Rx associated Buffer size & allocate share memory
 			pDmaBuf = &pAd->RxRing.Cell[index].DmaBuf;
 			pDmaBuf->AllocSize = RX_BUFFER_AGGRESIZE;
-			pPacket = RTMP_AllocateRxPacketBuffer(
-				pAd,
-				pDmaBuf->AllocSize,
-				FALSE,
-				&pDmaBuf->AllocVa,
-				&pDmaBuf->AllocPa);
+			pPacket = RTMP_AllocateRxPacketBuffer(pAd,
+							      pDmaBuf->
+							      AllocSize, FALSE,
+							      &pDmaBuf->AllocVa,
+							      &pDmaBuf->
+							      AllocPa);
 
 			/* keep allocated rx packet */
 			pAd->RxRing.Cell[index].pNdisPacket = pPacket;
 
 			// Error handling
-			if (pDmaBuf->AllocVa == NULL)
-			{
+			if (pDmaBuf->AllocVa == NULL) {
 				ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
 				DBGPRINT_ERR(("Failed to allocate RxRing's 1st buffer\n"));
 				Status = NDIS_STATUS_RESOURCES;
 				break;
 			}
-
 			// Zero init this memory block
 			NdisZeroMemory(pDmaBuf->AllocVa, pDmaBuf->AllocSize);
 
 			// Write RxD buffer address & allocated buffer length
 			pRxD = (PRXD_STRUC) pAd->RxRing.Cell[index].AllocVa;
-			pRxD->SDP0 = RTMP_GetPhysicalAddressLow(pDmaBuf->AllocPa);
+			pRxD->SDP0 =
+			    RTMP_GetPhysicalAddressLow(pDmaBuf->AllocPa);
 			pRxD->DDONE = 0;
 
 		}
 
-		DBGPRINT(RT_DEBUG_TRACE, ("Rx Ring: total %d entry allocated\n", index));
-
-	}	while (FALSE);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Rx Ring: total %d entry allocated\n", index));
 
+	} while (FALSE);
 
 	NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
-	pAd->FragFrame.pFragPacket =  RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
+	pAd->FragFrame.pFragPacket =
+	    RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
 
-	if (pAd->FragFrame.pFragPacket == NULL)
-	{
+	if (pAd->FragFrame.pFragPacket == NULL) {
 		Status = NDIS_STATUS_RESOURCES;
 	}
 
-	if (Status != NDIS_STATUS_SUCCESS)
-	{
+	if (Status != NDIS_STATUS_SUCCESS) {
 		// Log error inforamtion
-		NdisWriteErrorLogEntry(
-			pAd->AdapterHandle,
-			NDIS_ERROR_CODE_OUT_OF_RESOURCES,
-			1,
-			ErrorValue);
+		NdisWriteErrorLogEntry(pAd->AdapterHandle,
+				       NDIS_ERROR_CODE_OUT_OF_RESOURCES,
+				       1, ErrorValue);
 	}
-
 	// Following code segment get from original func:NICInitTxRxRingAndBacklogQueue(), now should integrate it to here.
 	{
-		DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitTxRxRingAndBacklogQueue\n"));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("--> NICInitTxRxRingAndBacklogQueue\n"));
 
 /*
 		// Disable DMA.
@@ -342,8 +352,7 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 */
 
 		// Initialize all transmit related software queues
-		for(index = 0; index < NUM_OF_TX_RING; index++)
-		{
+		for (index = 0; index < NUM_OF_TX_RING; index++) {
 			InitializeQueueHeader(&pAd->TxSwQueue[index]);
 			// Init TX rings index pointer
 			pAd->TxRing[index].TxSwFreeIdx = 0;
@@ -356,23 +365,21 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 		pAd->RxRing.RxCpuIdx = RX_RING_SIZE - 1;
 		//RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RX_CRX_IDX0);
 
-
 		// init MGMT ring index pointer
 		pAd->MgmtRing.TxSwFreeIdx = 0;
 		pAd->MgmtRing.TxCpuIdx = 0;
 
 		pAd->PrivateInfo.TxRingFullCnt = 0;
 
-		DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitTxRxRingAndBacklogQueue\n"));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("<-- NICInitTxRxRingAndBacklogQueue\n"));
 	}
 
-	DBGPRINT_S(Status, ("<-- RTMPAllocTxRxRingMemory, Status=%x\n", Status));
+	DBGPRINT_S(Status,
+		   ("<-- RTMPAllocTxRxRingMemory, Status=%x\n", Status));
 	return Status;
 }
 
-
-
-
 /*
 	========================================================================
 
@@ -393,156 +400,160 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 
 	========================================================================
 */
-VOID	RTMPRingCleanUp(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			RingType)
+VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType)
 {
-	PTXD_STRUC		pTxD;
-	PRXD_STRUC		pRxD;
-	PQUEUE_ENTRY	pEntry;
-	PNDIS_PACKET	pPacket;
-	int				i;
-	PRTMP_TX_RING	pTxRing;
-	unsigned long	IrqFlags;
-	//UINT32			RxSwReadIdx;
-
-
-	DBGPRINT(RT_DEBUG_TRACE,("RTMPRingCleanUp(RingIdx=%d, Pending-NDIS=%ld)\n", RingType, pAd->RalinkCounters.PendingNdisPacketCount));
-	switch (RingType)
-	{
-		case QID_AC_BK:
-		case QID_AC_BE:
-		case QID_AC_VI:
-		case QID_AC_VO:
-
-			pTxRing = &pAd->TxRing[RingType];
-
-			RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-			// We have to clean all descriptors in case some error happened with reset
-			for (i=0; i<TX_RING_SIZE; i++) // We have to scan all TX ring
-			{
-				pTxD  = (PTXD_STRUC) pTxRing->Cell[i].AllocVa;
-
-				pPacket = (PNDIS_PACKET) pTxRing->Cell[i].pNdisPacket;
-				// release scatter-and-gather NDIS_PACKET
-				if (pPacket)
-				{
-					RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-					pTxRing->Cell[i].pNdisPacket = NULL;
-				}
+	PTXD_STRUC pTxD;
+	PRXD_STRUC pRxD;
+	PQUEUE_ENTRY pEntry;
+	PNDIS_PACKET pPacket;
+	int i;
+	PRTMP_TX_RING pTxRing;
+	unsigned long IrqFlags;
+	//UINT32                        RxSwReadIdx;
 
-				pPacket = (PNDIS_PACKET) pTxRing->Cell[i].pNextNdisPacket;
-				// release scatter-and-gather NDIS_PACKET
-				if (pPacket)
-				{
-					RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-					pTxRing->Cell[i].pNextNdisPacket = NULL;
-				}
-			}
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPRingCleanUp(RingIdx=%d, Pending-NDIS=%ld)\n", RingType,
+		  pAd->RalinkCounters.PendingNdisPacketCount));
+	switch (RingType) {
+	case QID_AC_BK:
+	case QID_AC_BE:
+	case QID_AC_VI:
+	case QID_AC_VO:
 
-			RTMP_IO_READ32(pAd, TX_DTX_IDX0 + RingType * 0x10, &pTxRing->TxDmaIdx);
-			pTxRing->TxSwFreeIdx = pTxRing->TxDmaIdx;
-			pTxRing->TxCpuIdx = pTxRing->TxDmaIdx;
-			RTMP_IO_WRITE32(pAd, TX_CTX_IDX0 + RingType * 0x10, pTxRing->TxCpuIdx);
+		pTxRing = &pAd->TxRing[RingType];
 
-			RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+		// We have to clean all descriptors in case some error happened with reset
+		for (i = 0; i < TX_RING_SIZE; i++)	// We have to scan all TX ring
+		{
+			pTxD = (PTXD_STRUC) pTxRing->Cell[i].AllocVa;
 
-			RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-			while (pAd->TxSwQueue[RingType].Head != NULL)
-			{
-				pEntry = RemoveHeadQueue(&pAd->TxSwQueue[RingType]);
-				pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
-				RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-				DBGPRINT(RT_DEBUG_TRACE,("Release 1 NDIS packet from s/w backlog queue\n"));
+			pPacket = (PNDIS_PACKET) pTxRing->Cell[i].pNdisPacket;
+			// release scatter-and-gather NDIS_PACKET
+			if (pPacket) {
+				RELEASE_NDIS_PACKET(pAd, pPacket,
+						    NDIS_STATUS_FAILURE);
+				pTxRing->Cell[i].pNdisPacket = NULL;
+			}
+
+			pPacket =
+			    (PNDIS_PACKET) pTxRing->Cell[i].pNextNdisPacket;
+			// release scatter-and-gather NDIS_PACKET
+			if (pPacket) {
+				RELEASE_NDIS_PACKET(pAd, pPacket,
+						    NDIS_STATUS_FAILURE);
+				pTxRing->Cell[i].pNextNdisPacket = NULL;
 			}
-			RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-			break;
-
-		case QID_MGMT:
-			// We have to clean all descriptors in case some error happened with reset
-			NdisAcquireSpinLock(&pAd->MgmtRingLock);
-
-			for (i=0; i<MGMT_RING_SIZE; i++)
-			{
-				pTxD  = (PTXD_STRUC) pAd->MgmtRing.Cell[i].AllocVa;
+		}
 
-				pPacket = (PNDIS_PACKET) pAd->MgmtRing.Cell[i].pNdisPacket;
-				// rlease scatter-and-gather NDIS_PACKET
-				if (pPacket)
-				{
-					PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0, pTxD->SDLen0, PCI_DMA_TODEVICE);
-					RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-				}
-				pAd->MgmtRing.Cell[i].pNdisPacket = NULL;
+		RTMP_IO_READ32(pAd, TX_DTX_IDX0 + RingType * 0x10,
+			       &pTxRing->TxDmaIdx);
+		pTxRing->TxSwFreeIdx = pTxRing->TxDmaIdx;
+		pTxRing->TxCpuIdx = pTxRing->TxDmaIdx;
+		RTMP_IO_WRITE32(pAd, TX_CTX_IDX0 + RingType * 0x10,
+				pTxRing->TxCpuIdx);
 
-				pPacket = (PNDIS_PACKET) pAd->MgmtRing.Cell[i].pNextNdisPacket;
-				// release scatter-and-gather NDIS_PACKET
-				if (pPacket)
-				{
-					PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1, pTxD->SDLen1, PCI_DMA_TODEVICE);
-					RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-			}
-				pAd->MgmtRing.Cell[i].pNextNdisPacket = NULL;
+		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
 
-			}
+		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+		while (pAd->TxSwQueue[RingType].Head != NULL) {
+			pEntry = RemoveHeadQueue(&pAd->TxSwQueue[RingType]);
+			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
+			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Release 1 NDIS packet from s/w backlog queue\n"));
+		}
+		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+		break;
 
-			RTMP_IO_READ32(pAd, TX_MGMTDTX_IDX, &pAd->MgmtRing.TxDmaIdx);
-			pAd->MgmtRing.TxSwFreeIdx = pAd->MgmtRing.TxDmaIdx;
-			pAd->MgmtRing.TxCpuIdx = pAd->MgmtRing.TxDmaIdx;
-			RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
+	case QID_MGMT:
+		// We have to clean all descriptors in case some error happened with reset
+		NdisAcquireSpinLock(&pAd->MgmtRingLock);
+
+		for (i = 0; i < MGMT_RING_SIZE; i++) {
+			pTxD = (PTXD_STRUC) pAd->MgmtRing.Cell[i].AllocVa;
+
+			pPacket =
+			    (PNDIS_PACKET) pAd->MgmtRing.Cell[i].pNdisPacket;
+			// rlease scatter-and-gather NDIS_PACKET
+			if (pPacket) {
+				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0,
+						 pTxD->SDLen0,
+						 PCI_DMA_TODEVICE);
+				RELEASE_NDIS_PACKET(pAd, pPacket,
+						    NDIS_STATUS_FAILURE);
+			}
+			pAd->MgmtRing.Cell[i].pNdisPacket = NULL;
+
+			pPacket =
+			    (PNDIS_PACKET) pAd->MgmtRing.Cell[i].
+			    pNextNdisPacket;
+			// release scatter-and-gather NDIS_PACKET
+			if (pPacket) {
+				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
+						 pTxD->SDLen1,
+						 PCI_DMA_TODEVICE);
+				RELEASE_NDIS_PACKET(pAd, pPacket,
+						    NDIS_STATUS_FAILURE);
+			}
+			pAd->MgmtRing.Cell[i].pNextNdisPacket = NULL;
 
-			NdisReleaseSpinLock(&pAd->MgmtRingLock);
-			pAd->RalinkCounters.MgmtRingFullCount = 0;
-			break;
+		}
 
-		case QID_RX:
-			// We have to clean all descriptors in case some error happened with reset
-			NdisAcquireSpinLock(&pAd->RxRingLock);
+		RTMP_IO_READ32(pAd, TX_MGMTDTX_IDX, &pAd->MgmtRing.TxDmaIdx);
+		pAd->MgmtRing.TxSwFreeIdx = pAd->MgmtRing.TxDmaIdx;
+		pAd->MgmtRing.TxCpuIdx = pAd->MgmtRing.TxDmaIdx;
+		RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
+
+		NdisReleaseSpinLock(&pAd->MgmtRingLock);
+		pAd->RalinkCounters.MgmtRingFullCount = 0;
+		break;
+
+	case QID_RX:
+		// We have to clean all descriptors in case some error happened with reset
+		NdisAcquireSpinLock(&pAd->RxRingLock);
 
-			for (i=0; i<RX_RING_SIZE; i++)
-			{
-				pRxD  = (PRXD_STRUC) pAd->RxRing.Cell[i].AllocVa;
-                pRxD->DDONE = 0 ;
-			}
+		for (i = 0; i < RX_RING_SIZE; i++) {
+			pRxD = (PRXD_STRUC) pAd->RxRing.Cell[i].AllocVa;
+			pRxD->DDONE = 0;
+		}
 
-			RTMP_IO_READ32(pAd, RX_DRX_IDX, &pAd->RxRing.RxDmaIdx);
-			pAd->RxRing.RxSwReadIdx = pAd->RxRing.RxDmaIdx;
-			pAd->RxRing.RxCpuIdx = ((pAd->RxRing.RxDmaIdx == 0) ? (RX_RING_SIZE-1) : (pAd->RxRing.RxDmaIdx-1));
-			RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
+		RTMP_IO_READ32(pAd, RX_DRX_IDX, &pAd->RxRing.RxDmaIdx);
+		pAd->RxRing.RxSwReadIdx = pAd->RxRing.RxDmaIdx;
+		pAd->RxRing.RxCpuIdx =
+		    ((pAd->RxRing.RxDmaIdx ==
+		      0) ? (RX_RING_SIZE - 1) : (pAd->RxRing.RxDmaIdx - 1));
+		RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
 
-			NdisReleaseSpinLock(&pAd->RxRingLock);
-			break;
+		NdisReleaseSpinLock(&pAd->RxRingLock);
+		break;
 
-		default:
-			break;
+	default:
+		break;
 	}
 }
 
-
-VOID RTMPFreeTxRxRingMemory(
-    IN  PRTMP_ADAPTER   pAd)
+VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 {
-	int index, num , j;
+	int index, num, j;
 	PRTMP_TX_RING pTxRing;
-	PTXD_STRUC	  pTxD;
-	PNDIS_PACKET  pPacket;
-	unsigned int  IrqFlags;
+	PTXD_STRUC pTxD;
+	PNDIS_PACKET pPacket;
+	unsigned int IrqFlags;
 
 	//POS_COOKIE pObj =(POS_COOKIE) pAd->OS_Cookie;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPFreeTxRxRingMemory\n"));
 
 	// Free TxSwQueue Packet
-	for (index=0; index <NUM_OF_TX_RING; index++)
-	{
+	for (index = 0; index < NUM_OF_TX_RING; index++) {
 		PQUEUE_ENTRY pEntry;
 		PNDIS_PACKET pPacket;
-		PQUEUE_HEADER   pQueue;
+		PQUEUE_HEADER pQueue;
 
 		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
 		pQueue = &pAd->TxSwQueue[index];
-		while (pQueue->Head)
-		{
+		while (pQueue->Head) {
 			pEntry = RemoveHeadQueue(pQueue);
 			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
 			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
@@ -551,80 +562,92 @@ VOID RTMPFreeTxRxRingMemory(
 	}
 
 	// Free Tx Ring Packet
-	for (index=0;index< NUM_OF_TX_RING;index++)
-	{
+	for (index = 0; index < NUM_OF_TX_RING; index++) {
 		pTxRing = &pAd->TxRing[index];
 
-		for (j=0; j< TX_RING_SIZE; j++)
-		{
+		for (j = 0; j < TX_RING_SIZE; j++) {
 			pTxD = (PTXD_STRUC) (pTxRing->Cell[j].AllocVa);
 			pPacket = pTxRing->Cell[j].pNdisPacket;
 
-			if (pPacket)
-			{
-				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0, pTxD->SDLen0, PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
+			if (pPacket) {
+				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0,
+						 pTxD->SDLen0,
+						 PCI_DMA_TODEVICE);
+				RELEASE_NDIS_PACKET(pAd, pPacket,
+						    NDIS_STATUS_SUCCESS);
 			}
 			//Always assign pNdisPacket as NULL after clear
 			pTxRing->Cell[j].pNdisPacket = NULL;
 
 			pPacket = pTxRing->Cell[j].pNextNdisPacket;
 
-			if (pPacket)
-			{
-				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1, pTxD->SDLen1, PCI_DMA_TODEVICE);
-				RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
+			if (pPacket) {
+				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
+						 pTxD->SDLen1,
+						 PCI_DMA_TODEVICE);
+				RELEASE_NDIS_PACKET(pAd, pPacket,
+						    NDIS_STATUS_SUCCESS);
 			}
 			//Always assign pNextNdisPacket as NULL after clear
-			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket = NULL;
+			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket =
+			    NULL;
 
 		}
 	}
 
-	for (index = RX_RING_SIZE - 1 ; index >= 0; index--)
-	{
-		if ((pAd->RxRing.Cell[index].DmaBuf.AllocVa) && (pAd->RxRing.Cell[index].pNdisPacket))
-		{
-			PCI_UNMAP_SINGLE(pAd, pAd->RxRing.Cell[index].DmaBuf.AllocPa, pAd->RxRing.Cell[index].DmaBuf.AllocSize, PCI_DMA_FROMDEVICE);
-			RELEASE_NDIS_PACKET(pAd, pAd->RxRing.Cell[index].pNdisPacket, NDIS_STATUS_SUCCESS);
+	for (index = RX_RING_SIZE - 1; index >= 0; index--) {
+		if ((pAd->RxRing.Cell[index].DmaBuf.AllocVa)
+		    && (pAd->RxRing.Cell[index].pNdisPacket)) {
+			PCI_UNMAP_SINGLE(pAd,
+					 pAd->RxRing.Cell[index].DmaBuf.AllocPa,
+					 pAd->RxRing.Cell[index].DmaBuf.
+					 AllocSize, PCI_DMA_FROMDEVICE);
+			RELEASE_NDIS_PACKET(pAd,
+					    pAd->RxRing.Cell[index].pNdisPacket,
+					    NDIS_STATUS_SUCCESS);
 		}
 	}
 	NdisZeroMemory(pAd->RxRing.Cell, RX_RING_SIZE * sizeof(RTMP_DMACB));
 
-	if (pAd->RxDescRing.AllocVa)
-    {
-		RTMP_FreeDescMemory(pAd, pAd->RxDescRing.AllocSize, pAd->RxDescRing.AllocVa, pAd->RxDescRing.AllocPa);
-    }
-    NdisZeroMemory(&pAd->RxDescRing, sizeof(RTMP_DMABUF));
-
-	if (pAd->MgmtDescRing.AllocVa)
-	{
-		RTMP_FreeDescMemory(pAd, pAd->MgmtDescRing.AllocSize, pAd->MgmtDescRing.AllocVa, pAd->MgmtDescRing.AllocPa);
+	if (pAd->RxDescRing.AllocVa) {
+		RTMP_FreeDescMemory(pAd, pAd->RxDescRing.AllocSize,
+				    pAd->RxDescRing.AllocVa,
+				    pAd->RxDescRing.AllocPa);
+	}
+	NdisZeroMemory(&pAd->RxDescRing, sizeof(RTMP_DMABUF));
+
+	if (pAd->MgmtDescRing.AllocVa) {
+		RTMP_FreeDescMemory(pAd, pAd->MgmtDescRing.AllocSize,
+				    pAd->MgmtDescRing.AllocVa,
+				    pAd->MgmtDescRing.AllocPa);
 	}
 	NdisZeroMemory(&pAd->MgmtDescRing, sizeof(RTMP_DMABUF));
 
-	for (num = 0; num < NUM_OF_TX_RING; num++)
-	{
-	if (pAd->TxBufSpace[num].AllocVa)
-		{
-			RTMP_FreeFirstTxBuffer(pAd, pAd->TxBufSpace[num].AllocSize, FALSE, pAd->TxBufSpace[num].AllocVa, pAd->TxBufSpace[num].AllocPa);
-	    }
-	    NdisZeroMemory(&pAd->TxBufSpace[num], sizeof(RTMP_DMABUF));
-
-	if (pAd->TxDescRing[num].AllocVa)
-		{
-			RTMP_FreeDescMemory(pAd, pAd->TxDescRing[num].AllocSize, pAd->TxDescRing[num].AllocVa, pAd->TxDescRing[num].AllocPa);
-	    }
-	    NdisZeroMemory(&pAd->TxDescRing[num], sizeof(RTMP_DMABUF));
+	for (num = 0; num < NUM_OF_TX_RING; num++) {
+		if (pAd->TxBufSpace[num].AllocVa) {
+			RTMP_FreeFirstTxBuffer(pAd,
+					       pAd->TxBufSpace[num].AllocSize,
+					       FALSE,
+					       pAd->TxBufSpace[num].AllocVa,
+					       pAd->TxBufSpace[num].AllocPa);
+		}
+		NdisZeroMemory(&pAd->TxBufSpace[num], sizeof(RTMP_DMABUF));
+
+		if (pAd->TxDescRing[num].AllocVa) {
+			RTMP_FreeDescMemory(pAd, pAd->TxDescRing[num].AllocSize,
+					    pAd->TxDescRing[num].AllocVa,
+					    pAd->TxDescRing[num].AllocPa);
+		}
+		NdisZeroMemory(&pAd->TxDescRing[num], sizeof(RTMP_DMABUF));
 	}
 
 	if (pAd->FragFrame.pFragPacket)
-		RELEASE_NDIS_PACKET(pAd, pAd->FragFrame.pFragPacket, NDIS_STATUS_SUCCESS);
+		RELEASE_NDIS_PACKET(pAd, pAd->FragFrame.pFragPacket,
+				    NDIS_STATUS_SUCCESS);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- RTMPFreeTxRxRingMemory\n"));
 }
 
-
 /***************************************************************************
   *
   *	register related procedures.
@@ -644,19 +667,16 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID RT28XXDMADisable(
-	IN RTMP_ADAPTER			*pAd)
+VOID RT28XXDMADisable(IN RTMP_ADAPTER * pAd)
 {
-	WPDMA_GLO_CFG_STRUC     GloCfg;
-
+	WPDMA_GLO_CFG_STRUC GloCfg;
 
 	RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
 	GloCfg.word &= 0xff0;
-	GloCfg.field.EnTXWriteBackDDONE =1;
+	GloCfg.field.EnTXWriteBackDDONE = 1;
 	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -671,23 +691,22 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID RT28XXDMAEnable(
-	IN RTMP_ADAPTER			*pAd)
+VOID RT28XXDMAEnable(IN RTMP_ADAPTER * pAd)
 {
-	WPDMA_GLO_CFG_STRUC	GloCfg;
+	WPDMA_GLO_CFG_STRUC GloCfg;
 	int i = 0;
 
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x4);
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)  && (GloCfg.field.RxDMABusy == 0))
+		if ((GloCfg.field.TxDMABusy == 0)
+		    && (GloCfg.field.RxDMABusy == 0))
 			break;
 
 		DBGPRINT(RT_DEBUG_TRACE, ("==>  DMABusy\n"));
 		RTMPusecDelay(1000);
 		i++;
-	}while ( i <200);
+	} while (i < 200);
 
 	RTMPusecDelay(50);
 
@@ -696,69 +715,63 @@ VOID RT28XXDMAEnable(
 	GloCfg.field.EnableRxDMA = 1;
 	GloCfg.field.EnableTxDMA = 1;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("<== WRITE DMA offset 0x208 = 0x%x\n", GloCfg.word));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<== WRITE DMA offset 0x208 = 0x%x\n", GloCfg.word));
 	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
 
 }
 
-
-BOOLEAN AsicCheckCommanOk(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 Command)
+BOOLEAN AsicCheckCommanOk(IN PRTMP_ADAPTER pAd, IN UCHAR Command)
 {
-	UINT32	CmdStatus = 0, CID = 0, i;
-	UINT32	ThisCIDMask = 0;
+	UINT32 CmdStatus = 0, CID = 0, i;
+	UINT32 ThisCIDMask = 0;
 
 	i = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, H2M_MAILBOX_CID, &CID);
 		// Find where the command is. Because this is randomly specified by firmware.
-		if ((CID & CID0MASK) == Command)
-		{
+		if ((CID & CID0MASK) == Command) {
 			ThisCIDMask = CID0MASK;
 			break;
-		}
-		else if ((((CID & CID1MASK)>>8) & 0xff) == Command)
-		{
+		} else if ((((CID & CID1MASK) >> 8) & 0xff) == Command) {
 			ThisCIDMask = CID1MASK;
 			break;
-		}
-		else if ((((CID & CID2MASK)>>16) & 0xff) == Command)
-		{
+		} else if ((((CID & CID2MASK) >> 16) & 0xff) == Command) {
 			ThisCIDMask = CID2MASK;
 			break;
-		}
-		else if ((((CID & CID3MASK)>>24) & 0xff) == Command)
-		{
+		} else if ((((CID & CID3MASK) >> 24) & 0xff) == Command) {
 			ThisCIDMask = CID3MASK;
 			break;
 		}
 
 		RTMPusecDelay(100);
 		i++;
-	}while (i < 200);
+	} while (i < 200);
 
 	// Get CommandStatus Value
 	RTMP_IO_READ32(pAd, H2M_MAILBOX_STATUS, &CmdStatus);
 
 	// This command's status is at the same position as command. So AND command position's bitmask to read status.
-	if (i < 200)
-	{
+	if (i < 200) {
 		// If Status is 1, the comamnd is success.
-		if (((CmdStatus & ThisCIDMask) == 0x1) || ((CmdStatus & ThisCIDMask) == 0x100)
-			|| ((CmdStatus & ThisCIDMask) == 0x10000) || ((CmdStatus & ThisCIDMask) == 0x1000000))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("--> AsicCheckCommanOk CID = 0x%x, CmdStatus= 0x%x \n", CID, CmdStatus));
+		if (((CmdStatus & ThisCIDMask) == 0x1)
+		    || ((CmdStatus & ThisCIDMask) == 0x100)
+		    || ((CmdStatus & ThisCIDMask) == 0x10000)
+		    || ((CmdStatus & ThisCIDMask) == 0x1000000)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("--> AsicCheckCommanOk CID = 0x%x, CmdStatus= 0x%x \n",
+				  CID, CmdStatus));
 			RTMP_IO_WRITE32(pAd, H2M_MAILBOX_STATUS, 0xffffffff);
 			RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CID, 0xffffffff);
 			return TRUE;
 		}
-		DBGPRINT(RT_DEBUG_TRACE, ("--> AsicCheckCommanFail1 CID = 0x%x, CmdStatus= 0x%x \n", CID, CmdStatus));
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("--> AsicCheckCommanFail2 Timeout Command = %d, CmdStatus= 0x%x \n", Command, CmdStatus));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("--> AsicCheckCommanFail1 CID = 0x%x, CmdStatus= 0x%x \n",
+			  CID, CmdStatus));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("--> AsicCheckCommanFail2 Timeout Command = %d, CmdStatus= 0x%x \n",
+			  Command, CmdStatus));
 	}
 	// Clear Command and Status.
 	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_STATUS, 0xffffffff);
@@ -767,7 +780,6 @@ BOOLEAN AsicCheckCommanOk(
 	return FALSE;
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -782,58 +794,58 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID RT28xx_UpdateBeaconToAsic(
-	IN RTMP_ADAPTER		*pAd,
-	IN INT				apidx,
-	IN ULONG			FrameLen,
-	IN ULONG			UpdatePos)
+VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
+			       IN INT apidx,
+			       IN ULONG FrameLen, IN ULONG UpdatePos)
 {
-	ULONG				CapInfoPos = 0;
-	UCHAR			*ptr, *ptr_update, *ptr_capinfo;
-	UINT			i;
-	BOOLEAN			bBcnReq = FALSE;
-	UCHAR			bcn_idx = 0;
-
+	ULONG CapInfoPos = 0;
+	UCHAR *ptr, *ptr_update, *ptr_capinfo;
+	UINT i;
+	BOOLEAN bBcnReq = FALSE;
+	UCHAR bcn_idx = 0;
 
 	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s() : No valid Interface be found.\n", __func__));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s() : No valid Interface be found.\n", __func__));
 		return;
 	}
 
 	//if ((pAd->WdsTab.Mode == WDS_BRIDGE_MODE)
-	//	|| ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL)
-	//		|| !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP))
-	//	)
-	if (bBcnReq == FALSE)
-	{
+	//      || ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL)
+	//              || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP))
+	//      )
+	if (bBcnReq == FALSE) {
 		/* when the ra interface is down, do not send its beacon frame */
 		/* clear all zero */
-		for(i=0; i<TXWI_SIZE; i+=4)
-			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i, 0x00);
-	}
-	else
-	{
-		ptr = (PUCHAR)&pAd->BeaconTxWI;
-		for (i=0; i<TXWI_SIZE; i+=4)  // 16-byte TXWI field
-		{
-			UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
-			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i, longptr);
+		for (i = 0; i < TXWI_SIZE; i += 4)
+			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i,
+					0x00);
+	} else {
+		ptr = (PUCHAR) & pAd->BeaconTxWI;
+		for (i = 0; i < TXWI_SIZE; i += 4)	// 16-byte TXWI field
+		{
+			UINT32 longptr =
+			    *ptr + (*(ptr + 1) << 8) + (*(ptr + 2) << 16) +
+			    (*(ptr + 3) << 24);
+			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i,
+					longptr);
 			ptr += 4;
 		}
 
 		// Update CapabilityInfo in Beacon
-		for (i = CapInfoPos; i < (CapInfoPos+2); i++)
-		{
-			RTMP_IO_WRITE8(pAd, pAd->BeaconOffset[bcn_idx] + TXWI_SIZE + i, *ptr_capinfo);
-			ptr_capinfo ++;
+		for (i = CapInfoPos; i < (CapInfoPos + 2); i++) {
+			RTMP_IO_WRITE8(pAd,
+				       pAd->BeaconOffset[bcn_idx] + TXWI_SIZE +
+				       i, *ptr_capinfo);
+			ptr_capinfo++;
 		}
 
-		if (FrameLen > UpdatePos)
-		{
-			for (i= UpdatePos; i< (FrameLen); i++)
-			{
-				RTMP_IO_WRITE8(pAd, pAd->BeaconOffset[bcn_idx] + TXWI_SIZE + i, *ptr_update);
-				ptr_update ++;
+		if (FrameLen > UpdatePos) {
+			for (i = UpdatePos; i < (FrameLen); i++) {
+				RTMP_IO_WRITE8(pAd,
+					       pAd->BeaconOffset[bcn_idx] +
+					       TXWI_SIZE + i, *ptr_update);
+				ptr_update++;
 			}
 		}
 
@@ -841,119 +853,115 @@ VOID RT28xx_UpdateBeaconToAsic(
 
 }
 
-
-VOID RT28xxPciStaAsicForceWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN BOOLEAN       bFromTx)
+VOID RT28xxPciStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 {
-    AUTO_WAKEUP_STRUC	AutoWakeupCfg;
+	AUTO_WAKEUP_STRUC AutoWakeupCfg;
 
-    if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-        return;
+	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+		return;
 
-    if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WAKEUP_NOW))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("waking up now!\n"));
-        return;
-    }
-
-    OPSTATUS_SET_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
-
-    RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_GO_TO_SLEEP_NOW);
-
-    if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-		&&pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-    {
-        // Support PCIe Advance Power Save
-	if (bFromTx == TRUE
-			&&(pAd->Mlme.bPsPollTimerRunning == TRUE))
-	{
-            pAd->Mlme.bPsPollTimerRunning = FALSE;
-		RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
-		RTMPusecDelay(3000);
-            DBGPRINT(RT_DEBUG_TRACE, ("=======AsicForceWakeup===bFromTx\n"));
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WAKEUP_NOW)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("waking up now!\n"));
+		return;
 	}
 
+	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
+
+	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_GO_TO_SLEEP_NOW);
+
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
+	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
+		// Support PCIe Advance Power Save
+		if (bFromTx == TRUE && (pAd->Mlme.bPsPollTimerRunning == TRUE)) {
+			pAd->Mlme.bPsPollTimerRunning = FALSE;
+			RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
+			RTMPusecDelay(3000);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("=======AsicForceWakeup===bFromTx\n"));
+		}
+
 		AutoWakeupCfg.word = 0;
 		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
 
-        if (RT28xxPciAsicRadioOn(pAd, DOT11POWERSAVE))
-        {
+		if (RT28xxPciAsicRadioOn(pAd, DOT11POWERSAVE)) {
 #ifdef PCIE_PS_SUPPORT
 			// add by johnli, RF power sequence setup, load RF normal operation-mode setup
-			if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd))
-			{
+			if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+			    && IS_VERSION_AFTER_F(pAd)) {
 				RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
 
 				if (pChipOps->AsicReverseRfFromSleepMode)
-					pChipOps->AsicReverseRfFromSleepMode(pAd);
-			}
-			else
+					pChipOps->
+					    AsicReverseRfFromSleepMode(pAd);
+			} else
 #endif // PCIE_PS_SUPPORT //
 			{
-			// end johnli
+				// end johnli
 				// In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again.
-				if (INFRA_ON(pAd) && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
-					&& (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
-				{
+				if (INFRA_ON(pAd)
+				    && (pAd->CommonCfg.CentralChannel !=
+					pAd->CommonCfg.Channel)
+				    && (pAd->MlmeAux.HtCapability.HtCapInfo.
+					ChannelWidth == BW_40)) {
 					// Must using 40MHz.
-					AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
-					AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-				}
-				else
-				{
+					AsicSwitchChannel(pAd,
+							  pAd->CommonCfg.
+							  CentralChannel,
+							  FALSE);
+					AsicLockChannel(pAd,
+							pAd->CommonCfg.
+							CentralChannel);
+				} else {
 					// Must using 20MHz.
-					AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-					AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+					AsicSwitchChannel(pAd,
+							  pAd->CommonCfg.
+							  Channel, FALSE);
+					AsicLockChannel(pAd,
+							pAd->CommonCfg.Channel);
 				}
 			}
-        }
+		}
 #ifdef PCIE_PS_SUPPORT
 		// 3090 MCU Wakeup command needs more time to be stable.
 		// Before stable, don't issue other MCU command to prevent from firmware error.
-		if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
-			&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-			&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-			{
-			DBGPRINT(RT_DEBUG_TRACE, ("<==RT28xxPciStaAsicForceWakeup::Release the MCU Lock(3090)\n"));
+		if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+		     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
+		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+		    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("<==RT28xxPciStaAsicForceWakeup::Release the MCU Lock(3090)\n"));
 			RTMP_SEM_LOCK(&pAd->McuCmdLock);
 			pAd->brt30xxBanMcuCmd = FALSE;
 			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-			}
+		}
 #endif // PCIE_PS_SUPPORT //
-    }
-    else
-    {
-        // PCI, 2860-PCIe
-         DBGPRINT(RT_DEBUG_TRACE, ("<==RT28xxPciStaAsicForceWakeup::Original PCI Power Saving\n"));
-        AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
-        AutoWakeupCfg.word = 0;
-	    RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-    }
-
-    OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-    OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
-    DBGPRINT(RT_DEBUG_TRACE, ("<=======RT28xxPciStaAsicForceWakeup\n"));
-}
+	} else {
+		// PCI, 2860-PCIe
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("<==RT28xxPciStaAsicForceWakeup::Original PCI Power Saving\n"));
+		AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
+		AutoWakeupCfg.word = 0;
+		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
+	}
 
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
+	DBGPRINT(RT_DEBUG_TRACE, ("<=======RT28xxPciStaAsicForceWakeup\n"));
+}
 
-VOID RT28xxPciStaAsicSleepThenAutoWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT TbttNumToNextWakeUp)
+VOID RT28xxPciStaAsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
+					 IN USHORT TbttNumToNextWakeUp)
 {
 	BOOLEAN brc;
 
-	if (pAd->StaCfg.bRadio == FALSE)
-	{
+	if (pAd->StaCfg.bRadio == FALSE) {
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
 		return;
 	}
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-		&&pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-	{
-		ULONG	Now = 0;
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WAKEUP_NOW))
-		{
+	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
+		ULONG Now = 0;
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WAKEUP_NOW)) {
 			DBGPRINT(RT_DEBUG_TRACE, ("waking up now!\n"));
 			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
 			return;
@@ -962,24 +970,31 @@ VOID RT28xxPciStaAsicSleepThenAutoWakeup
 		NdisGetSystemUpTime(&Now);
 		// If last send NULL fram time is too close to this receiving beacon (within 8ms), don't go to sleep for this DTM.
 		// Because Some AP can't queuing outgoing frames immediately.
-		if (((pAd->Mlme.LastSendNULLpsmTime + 8) >= Now) && (pAd->Mlme.LastSendNULLpsmTime <= Now))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("Now = %lu, LastSendNULLpsmTime=%lu :  RxCountSinceLastNULL = %lu. \n", Now, pAd->Mlme.LastSendNULLpsmTime, pAd->RalinkCounters.RxCountSinceLastNULL));
+		if (((pAd->Mlme.LastSendNULLpsmTime + 8) >= Now)
+		    && (pAd->Mlme.LastSendNULLpsmTime <= Now)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Now = %lu, LastSendNULLpsmTime=%lu :  RxCountSinceLastNULL = %lu. \n",
+				  Now, pAd->Mlme.LastSendNULLpsmTime,
+				  pAd->RalinkCounters.RxCountSinceLastNULL));
 			return;
-		}
-		else if ((pAd->RalinkCounters.RxCountSinceLastNULL > 0) && ((pAd->Mlme.LastSendNULLpsmTime + pAd->CommonCfg.BeaconPeriod) >= Now))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("Now = %lu, LastSendNULLpsmTime=%lu: RxCountSinceLastNULL = %lu > 0 \n", Now, pAd->Mlme.LastSendNULLpsmTime,  pAd->RalinkCounters.RxCountSinceLastNULL));
+		} else if ((pAd->RalinkCounters.RxCountSinceLastNULL > 0)
+			   &&
+			   ((pAd->Mlme.LastSendNULLpsmTime +
+			     pAd->CommonCfg.BeaconPeriod) >= Now)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Now = %lu, LastSendNULLpsmTime=%lu: RxCountSinceLastNULL = %lu > 0 \n",
+				  Now, pAd->Mlme.LastSendNULLpsmTime,
+				  pAd->RalinkCounters.RxCountSinceLastNULL));
 			return;
 		}
 
-		brc = RT28xxPciAsicRadioOff(pAd, DOT11POWERSAVE, TbttNumToNextWakeUp);
-		if (brc==TRUE)
+		brc =
+		    RT28xxPciAsicRadioOff(pAd, DOT11POWERSAVE,
+					  TbttNumToNextWakeUp);
+		if (brc == TRUE)
 			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
-	}
-	else
-	{
-		AUTO_WAKEUP_STRUC	AutoWakeupCfg;
+	} else {
+		AUTO_WAKEUP_STRUC AutoWakeupCfg;
 		// we have decided to SLEEP, so at least do it for a BEACON period.
 		if (TbttNumToNextWakeUp == 0)
 			TbttNumToNextWakeUp = 1;
@@ -992,87 +1007,83 @@ VOID RT28xxPciStaAsicSleepThenAutoWakeup
 		AutoWakeupCfg.field.EnableAutoWakeup = 1;
 		AutoWakeupCfg.field.AutoLeadTime = 5;
 		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-		AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x00);   // send POWER-SAVE command to MCU. Timeout 40us.
+		AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x00);	// send POWER-SAVE command to MCU. Timeout 40us.
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
-		DBGPRINT(RT_DEBUG_TRACE, ("<-- %s, TbttNumToNextWakeUp=%d \n", __func__, TbttNumToNextWakeUp));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("<-- %s, TbttNumToNextWakeUp=%d \n", __func__,
+			  TbttNumToNextWakeUp));
 	}
 
 }
 
-VOID PsPollWakeExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+VOID PsPollWakeExec(IN PVOID SystemSpecific1,
+		    IN PVOID FunctionContext,
+		    IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 	unsigned long flags;
 
-    DBGPRINT(RT_DEBUG_TRACE,("-->PsPollWakeExec \n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("-->PsPollWakeExec \n"));
 	RTMP_INT_LOCK(&pAd->irq_lock, flags);
-    if (pAd->Mlme.bPsPollTimerRunning)
-    {
-	    RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
-    }
-    pAd->Mlme.bPsPollTimerRunning = FALSE;
+	if (pAd->Mlme.bPsPollTimerRunning) {
+		RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
+	}
+	pAd->Mlme.bPsPollTimerRunning = FALSE;
 	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 #ifdef PCIE_PS_SUPPORT
 	// For rt30xx power solution 3, Use software timer to wake up in psm. So call
 	// AsicForceWakeup here instead of handling twakeup interrupt.
-	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd))
-	&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("<--PsPollWakeExec::3090 calls AsicForceWakeup(pAd, DOT11POWERSAVE) in advance \n"));
+	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+	     && IS_VERSION_AFTER_F(pAd))
+	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("<--PsPollWakeExec::3090 calls AsicForceWakeup(pAd, DOT11POWERSAVE) in advance \n"));
 		AsicForceWakeup(pAd, DOT11POWERSAVE);
 	}
 #endif // PCIE_PS_SUPPORT //
 }
 
-VOID  RadioOnExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+VOID RadioOnExec(IN PVOID SystemSpecific1,
+		 IN PVOID FunctionContext,
+		 IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
-	WPDMA_GLO_CFG_STRUC	DmaCfg;
-	BOOLEAN				Cancelled;
+	WPDMA_GLO_CFG_STRUC DmaCfg;
+	BOOLEAN Cancelled;
 
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("-->RadioOnExec() return on fOP_STATUS_DOZE == TRUE; \n"));
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("-->RadioOnExec() return on fOP_STATUS_DOZE == TRUE; \n"));
 //KH Debug: Add the compile flag "RT2860 and condition
 #ifdef RTMP_PCI_SUPPORT
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-			&&pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-		RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
+		    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
+			RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
 #endif // RTMP_PCI_SUPPORT //
 		return;
 	}
 
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("-->RadioOnExec() return on SCAN_IN_PROGRESS; \n"));
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("-->RadioOnExec() return on SCAN_IN_PROGRESS; \n"));
 #ifdef RTMP_PCI_SUPPORT
-if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-	&&pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-		RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
+		    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
+			RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
 #endif // RTMP_PCI_SUPPORT //
 		return;
 	}
 //KH Debug: need to check. I add the compile flag "CONFIG_STA_SUPPORT" to enclose the following codes.
 #ifdef RTMP_PCI_SUPPORT
-if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-	&&pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-	{
-	pAd->Mlme.bPsPollTimerRunning = FALSE;
-	RTMPCancelTimer(&pAd->Mlme.PsPollTimer,	&Cancelled);
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
+	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
+		pAd->Mlme.bPsPollTimerRunning = FALSE;
+		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
 	}
 #endif // RTMP_PCI_SUPPORT //
-	if (pAd->StaCfg.bRadio == TRUE)
-	{
+	if (pAd->StaCfg.bRadio == TRUE) {
 		pAd->bPCIclkOff = FALSE;
 		RTMPRingCleanUp(pAd, QID_AC_BK);
 		RTMPRingCleanUp(pAd, QID_AC_BE);
@@ -1096,15 +1107,15 @@ if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_P
 		RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, DmaCfg.word);
 
 		// In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again.
-		if (INFRA_ON(pAd) && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
-			&& (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
-		{
+		if (INFRA_ON(pAd)
+		    && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
+		    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth ==
+			BW_40)) {
 			// Must using 40MHz.
-			AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
+			AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel,
+					  FALSE);
 			AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-		}
-		else
-		{
+		} else {
 			// Must using 20MHz.
 			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
 			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
@@ -1117,14 +1128,14 @@ if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_P
 #ifdef PCIE_PS_SUPPORT
 // 3090 MCU Wakeup command needs more time to be stable.
 // Before stable, don't issue other MCU command to prevent from firmware error.
-if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)
-	&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-	{
-	RTMP_SEM_LOCK(&pAd->McuCmdLock);
-	pAd->brt30xxBanMcuCmd = FALSE;
-	RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-	}
+		if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+		    && IS_VERSION_AFTER_F(pAd)
+		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+		    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
+			RTMP_SEM_LOCK(&pAd->McuCmdLock);
+			pAd->brt30xxBanMcuCmd = FALSE;
+			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
+		}
 #endif // PCIE_PS_SUPPORT //
 
 		// Clear Radio off flag
@@ -1133,13 +1144,11 @@ if ((IS_RT3090(pAd) || IS_RT3572(pAd) ||
 		// Set LED
 		RTMPSetLED(pAd, LED_RADIO_ON);
 
-        if (pAd->StaCfg.Psm == PWR_ACTIVE)
-        {
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
-        }
-	}
-	else
-	{
+		if (pAd->StaCfg.Psm == PWR_ACTIVE) {
+			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3,
+						     pAd->StaCfg.BBPR3);
+		}
+	} else {
 		RT28xxPciAsicRadioOff(pAd, GUIRADIO_OFF, 0);
 	}
 }
@@ -1155,23 +1164,19 @@ if ((IS_RT3090(pAd) || IS_RT3572(pAd) ||
 
 	==========================================================================
  */
-BOOLEAN RT28xxPciAsicRadioOn(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR     Level)
+BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 {
-    //WPDMA_GLO_CFG_STRUC	DmaCfg;
-	BOOLEAN				Cancelled;
-    //UINT32			    MACValue;
+	//WPDMA_GLO_CFG_STRUC       DmaCfg;
+	BOOLEAN Cancelled;
+	//UINT32                        MACValue;
 
-	if (pAd->OpMode == OPMODE_AP && Level==DOT11POWERSAVE)
+	if (pAd->OpMode == OPMODE_AP && Level == DOT11POWERSAVE)
 		return FALSE;
 
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-	{
-		if (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-	{
-	    pAd->Mlme.bPsPollTimerRunning = FALSE;
-		RTMPCancelTimer(&pAd->Mlme.PsPollTimer,	&Cancelled);
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
+		if (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
+			pAd->Mlme.bPsPollTimerRunning = FALSE;
+			RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
 		}
 		if ((pAd->StaCfg.PSControl.field.EnableNewPS == TRUE &&
 		     (Level == GUIRADIO_OFF || Level == GUI_IDLE_POWER_SAVE)) ||
@@ -1179,86 +1184,96 @@ BOOLEAN RT28xxPciAsicRadioOn(
 			// Some chips don't need to delay 6ms, so copy RTMPPCIePowerLinkCtrlRestore
 			// return condition here.
 			/*
-			if (((pAd->MACVersion&0xffff0000) != 0x28600000)
-				&& ((pAd->DeviceID == NIC2860_PCIe_DEVICE_ID)
-				||(pAd->DeviceID == NIC2790_PCIe_DEVICE_ID)))
-			*/
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("RT28xxPciAsicRadioOn ()\n"));
-			// 1. Set PCI Link Control in Configuration Space.
-			RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
-			RTMPusecDelay(6000);
+			   if (((pAd->MACVersion&0xffff0000) != 0x28600000)
+			   && ((pAd->DeviceID == NIC2860_PCIe_DEVICE_ID)
+			   ||(pAd->DeviceID == NIC2790_PCIe_DEVICE_ID)))
+			 */
+			{
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("RT28xxPciAsicRadioOn ()\n"));
+				// 1. Set PCI Link Control in Configuration Space.
+				RTMPPCIeLinkCtrlValueRestore(pAd,
+							     RESTORE_WAKEUP);
+				RTMPusecDelay(6000);
+			}
 		}
 	}
-	}
-
 #ifdef PCIE_PS_SUPPORT
-if (!(((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)
-	&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))))
+	if (!
+	    (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+	      && IS_VERSION_AFTER_F(pAd)
+	      && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+	      && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))))
 #endif // PCIE_PS_SUPPORT //
 	{
-    pAd->bPCIclkOff = FALSE;
-		DBGPRINT(RT_DEBUG_TRACE, ("PSM :309xbPCIclkOff == %d\n", pAd->bPCIclkOff));
+		pAd->bPCIclkOff = FALSE;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("PSM :309xbPCIclkOff == %d\n", pAd->bPCIclkOff));
 	}
 	// 2. Send wake up command.
 	AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00, 0x02);
-    pAd->bPCIclkOff = FALSE;
+	pAd->bPCIclkOff = FALSE;
 	// 2-1. wait command ok.
 	AsicCheckCommanOk(pAd, PowerWakeCID);
 	RTMP_ASIC_INTERRUPT_ENABLE(pAd);
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
-	if (Level == GUI_IDLE_POWER_SAVE)
-	{
+	if (Level == GUI_IDLE_POWER_SAVE) {
 #ifdef  PCIE_PS_SUPPORT
 
-			// add by johnli, RF power sequence setup, load RF normal operation-mode setup
-			if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)))
-			{
-				RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
-
-				if (pChipOps->AsicReverseRfFromSleepMode)
-					pChipOps->AsicReverseRfFromSleepMode(pAd);
-				// 3090 MCU Wakeup command needs more time to be stable.
-				// Before stable, don't issue other MCU command to prevent from firmware error.
-				if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)
-					&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-					&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-					{
-						RTMP_SEM_LOCK(&pAd->McuCmdLock);
-						pAd->brt30xxBanMcuCmd = FALSE;
-						RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-					}
+		// add by johnli, RF power sequence setup, load RF normal operation-mode setup
+		if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
+			RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+
+			if (pChipOps->AsicReverseRfFromSleepMode)
+				pChipOps->AsicReverseRfFromSleepMode(pAd);
+			// 3090 MCU Wakeup command needs more time to be stable.
+			// Before stable, don't issue other MCU command to prevent from firmware error.
+			if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+			    && IS_VERSION_AFTER_F(pAd)
+			    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode ==
+				3)
+			    && (pAd->StaCfg.PSControl.field.EnableNewPS ==
+				TRUE)) {
+				RTMP_SEM_LOCK(&pAd->McuCmdLock);
+				pAd->brt30xxBanMcuCmd = FALSE;
+				RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
 			}
-			else
+		} else
 			// end johnli
 #endif // PCIE_PS_SUPPORT //
-			{
+		{
 			// In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again.
-				{
-				if (INFRA_ON(pAd) && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
-					&& (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
-				{
+			{
+				if (INFRA_ON(pAd)
+				    && (pAd->CommonCfg.CentralChannel !=
+					pAd->CommonCfg.Channel)
+				    && (pAd->MlmeAux.HtCapability.HtCapInfo.
+					ChannelWidth == BW_40)) {
 					// Must using 40MHz.
-					AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
-					AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
-				}
-				else
-				{
+					AsicSwitchChannel(pAd,
+							  pAd->CommonCfg.
+							  CentralChannel,
+							  FALSE);
+					AsicLockChannel(pAd,
+							pAd->CommonCfg.
+							CentralChannel);
+				} else {
 					// Must using 20MHz.
-					AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-					AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-				}
+					AsicSwitchChannel(pAd,
+							  pAd->CommonCfg.
+							  Channel, FALSE);
+					AsicLockChannel(pAd,
+							pAd->CommonCfg.Channel);
 				}
-
 			}
+
+		}
 	}
-        return TRUE;
+	return TRUE;
 
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1271,126 +1286,123 @@ if (!(((IS_RT3090(pAd) || IS_RT3572(pAd)
 
 	==========================================================================
  */
-BOOLEAN RT28xxPciAsicRadioOff(
-	IN PRTMP_ADAPTER    pAd,
-	IN UCHAR            Level,
-	IN USHORT           TbttNumToNextWakeUp)
+BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR Level, IN USHORT TbttNumToNextWakeUp)
 {
-	WPDMA_GLO_CFG_STRUC	DmaCfg;
-	UCHAR		i, tempBBP_R3 = 0;
-	BOOLEAN		brc = FALSE, Cancelled;
-    UINT32		TbTTTime = 0;
-	UINT32		PsPollTime = 0/*, MACValue*/;
-    ULONG		BeaconPeriodTime;
-    UINT32		RxDmaIdx, RxCpuIdx;
-	DBGPRINT(RT_DEBUG_TRACE, ("AsicRadioOff ===> Lv= %d, TxCpuIdx = %d, TxDmaIdx = %d. RxCpuIdx = %d, RxDmaIdx = %d.\n", Level,pAd->TxRing[0].TxCpuIdx, pAd->TxRing[0].TxDmaIdx, pAd->RxRing.RxCpuIdx, pAd->RxRing.RxDmaIdx));
+	WPDMA_GLO_CFG_STRUC DmaCfg;
+	UCHAR i, tempBBP_R3 = 0;
+	BOOLEAN brc = FALSE, Cancelled;
+	UINT32 TbTTTime = 0;
+	UINT32 PsPollTime = 0 /*, MACValue */ ;
+	ULONG BeaconPeriodTime;
+	UINT32 RxDmaIdx, RxCpuIdx;
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AsicRadioOff ===> Lv= %d, TxCpuIdx = %d, TxDmaIdx = %d. RxCpuIdx = %d, RxDmaIdx = %d.\n",
+		  Level, pAd->TxRing[0].TxCpuIdx, pAd->TxRing[0].TxDmaIdx,
+		  pAd->RxRing.RxCpuIdx, pAd->RxRing.RxDmaIdx));
 
-	if (pAd->OpMode == OPMODE_AP && Level==DOT11POWERSAVE)
+	if (pAd->OpMode == OPMODE_AP && Level == DOT11POWERSAVE)
 		return FALSE;
 
-    // Check Rx DMA busy status, if more than half is occupied, give up this radio off.
-	RTMP_IO_READ32(pAd, RX_DRX_IDX , &RxDmaIdx);
-	RTMP_IO_READ32(pAd, RX_CRX_IDX , &RxCpuIdx);
-	if ((RxDmaIdx > RxCpuIdx) && ((RxDmaIdx - RxCpuIdx) > RX_RING_SIZE/3))
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("AsicRadioOff ===> return1. RxDmaIdx = %d ,  RxCpuIdx = %d. \n", RxDmaIdx, RxCpuIdx));
+	// Check Rx DMA busy status, if more than half is occupied, give up this radio off.
+	RTMP_IO_READ32(pAd, RX_DRX_IDX, &RxDmaIdx);
+	RTMP_IO_READ32(pAd, RX_CRX_IDX, &RxCpuIdx);
+	if ((RxDmaIdx > RxCpuIdx) && ((RxDmaIdx - RxCpuIdx) > RX_RING_SIZE / 3)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("AsicRadioOff ===> return1. RxDmaIdx = %d ,  RxCpuIdx = %d. \n",
+			  RxDmaIdx, RxCpuIdx));
 		return FALSE;
-	}
-	else if ((RxCpuIdx >= RxDmaIdx) && ((RxCpuIdx - RxDmaIdx) < RX_RING_SIZE/3))
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("AsicRadioOff ===> return2.  RxCpuIdx = %d. RxDmaIdx = %d ,  \n", RxCpuIdx, RxDmaIdx));
+	} else if ((RxCpuIdx >= RxDmaIdx)
+		   && ((RxCpuIdx - RxDmaIdx) < RX_RING_SIZE / 3)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("AsicRadioOff ===> return2.  RxCpuIdx = %d. RxDmaIdx = %d ,  \n",
+			  RxCpuIdx, RxDmaIdx));
 		return FALSE;
 	}
-
-    // Once go into this function, disable tx because don't want too many packets in queue to prevent HW stops.
+	// Once go into this function, disable tx because don't want too many packets in queue to prevent HW stops.
 	//pAd->bPCIclkOffDisableTx = TRUE;
 	RTMP_SET_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-		&& pAd->OpMode == OPMODE_STA
-		&&pAd->StaCfg.PSControl.field.EnableNewPS == TRUE
-		)
-	{
-	    RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer,	&Cancelled);
-	    RTMPCancelTimer(&pAd->Mlme.PsPollTimer,	&Cancelled);
+	    && pAd->OpMode == OPMODE_STA
+	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
+		RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
 
-	    if (Level == DOT11POWERSAVE)
-		{
+		if (Level == DOT11POWERSAVE) {
 			RTMP_IO_READ32(pAd, TBTT_TIMER, &TbTTTime);
 			TbTTTime &= 0x1ffff;
 			// 00. check if need to do sleep in this DTIM period.   If next beacon will arrive within 30ms , ...doesn't necessarily sleep.
 			// TbTTTime uint = 64us, LEAD_TIME unit = 1024us, PsPollTime unit = 1ms
-	        if  (((64*TbTTTime) <((LEAD_TIME*1024) + 40000)) && (TbttNumToNextWakeUp == 0))
-			{
-				DBGPRINT(RT_DEBUG_TRACE, ("TbTTTime = 0x%x , give up this sleep. \n", TbTTTime));
-	            OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-	            //pAd->bPCIclkOffDisableTx = FALSE;
-	            RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
+			if (((64 * TbTTTime) < ((LEAD_TIME * 1024) + 40000))
+			    && (TbttNumToNextWakeUp == 0)) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("TbTTTime = 0x%x , give up this sleep. \n",
+					  TbTTTime));
+				OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
+				//pAd->bPCIclkOffDisableTx = FALSE;
+				RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
 				return FALSE;
-			}
-			else
-			{
-				PsPollTime = (64*TbTTTime- LEAD_TIME*1024)/1000;
+			} else {
+				PsPollTime =
+				    (64 * TbTTTime - LEAD_TIME * 1024) / 1000;
 #ifdef PCIE_PS_SUPPORT
-				if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)
-				&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-				&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-				{
-							PsPollTime -= 5;
-				}
-				else
+				if ((IS_RT3090(pAd) || IS_RT3572(pAd)
+				     || IS_RT3390(pAd))
+				    && IS_VERSION_AFTER_F(pAd)
+				    && (pAd->StaCfg.PSControl.field.
+					rt30xxPowerMode == 3)
+				    && (pAd->StaCfg.PSControl.field.
+					EnableNewPS == TRUE)) {
+					PsPollTime -= 5;
+				} else
 #endif // PCIE_PS_SUPPORT //
-				PsPollTime -= 3;
+					PsPollTime -= 3;
 
-	            BeaconPeriodTime = pAd->CommonCfg.BeaconPeriod*102/100;
+				BeaconPeriodTime =
+				    pAd->CommonCfg.BeaconPeriod * 102 / 100;
 				if (TbttNumToNextWakeUp > 0)
-					PsPollTime += ((TbttNumToNextWakeUp -1) * BeaconPeriodTime);
-
-	            pAd->Mlme.bPsPollTimerRunning = TRUE;
-				RTMPSetTimer(&pAd->Mlme.PsPollTimer, PsPollTime);
+					PsPollTime +=
+					    ((TbttNumToNextWakeUp -
+					      1) * BeaconPeriodTime);
+
+				pAd->Mlme.bPsPollTimerRunning = TRUE;
+				RTMPSetTimer(&pAd->Mlme.PsPollTimer,
+					     PsPollTime);
 			}
 		}
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("RT28xxPciAsicRadioOff::Level!=DOT11POWERSAVE \n"));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RT28xxPciAsicRadioOff::Level!=DOT11POWERSAVE \n"));
 	}
 
 	pAd->bPCIclkOffDisableTx = FALSE;
 
-    RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
+	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
 
-    // Set to 1R.
-	if (pAd->Antenna.field.RxPath > 1 && pAd->OpMode == OPMODE_STA)
-	{
-	tempBBP_R3 = (pAd->StaCfg.BBPR3 & 0xE7);
+	// Set to 1R.
+	if (pAd->Antenna.field.RxPath > 1 && pAd->OpMode == OPMODE_STA) {
+		tempBBP_R3 = (pAd->StaCfg.BBPR3 & 0xE7);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, tempBBP_R3);
 	}
-
 	// In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again.
-	if ((INFRA_ON(pAd) || pAd->OpMode == OPMODE_AP) && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
-		&& (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
-	{
+	if ((INFRA_ON(pAd) || pAd->OpMode == OPMODE_AP)
+	    && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
+	    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)) {
 		// Must using 40MHz.
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.CentralChannel);
-	}
-	else
-	{
+	} else {
 		// Must using 20MHz.
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.Channel);
 	}
 
-	if (Level != RTMP_HALT)
-	{
+	if (Level != RTMP_HALT) {
 		// Change Interrupt bitmask.
-    // When PCI clock is off, don't want to service interrupt.
-	RTMP_IO_WRITE32(pAd, INT_MASK_CSR, AutoWakeupInt);
-	}
-	else
-	{
+		// When PCI clock is off, don't want to service interrupt.
+		RTMP_IO_WRITE32(pAd, INT_MASK_CSR, AutoWakeupInt);
+	} else {
 		RTMP_ASIC_INTERRUPT_DISABLE(pAd);
 	}
 
-
 	RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
 	//  2. Send Sleep command
 	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_STATUS, 0xffffffff);
@@ -1403,62 +1415,58 @@ BOOLEAN RT28xxPciAsicRadioOff(
 
 	//  3. After 0x30 command is ok, send radio off command. lowbyte = 0 for power safe.
 	// If 0x30 command is not ok this time, we can ignore 0x35 command. It will make sure not cause firmware'r problem.
-	if ((Level == DOT11POWERSAVE) && (brc == TRUE))
-	{
+	if ((Level == DOT11POWERSAVE) && (brc == TRUE)) {
 		AsicSendCommandToMcu(pAd, 0x35, PowerRadioOffCID, 0, 0x00);	// lowbyte = 0 means to do power safe, NOT turn off radio.
 		//  3-1. Wait command success
 		AsicCheckCommanOk(pAd, PowerRadioOffCID);
-	}
-	else if (brc == TRUE)
-	{
+	} else if (brc == TRUE) {
 		AsicSendCommandToMcu(pAd, 0x35, PowerRadioOffCID, 1, 0x00);	// lowbyte = 0 means to do power safe, NOT turn off radio.
 		//  3-1. Wait command success
 		AsicCheckCommanOk(pAd, PowerRadioOffCID);
 	}
-
 	// 1. Wait DMA not busy
 	i = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &DmaCfg.word);
-		if ((DmaCfg.field.RxDMABusy == 0) && (DmaCfg.field.TxDMABusy == 0))
+		if ((DmaCfg.field.RxDMABusy == 0)
+		    && (DmaCfg.field.TxDMABusy == 0))
 			break;
 		RTMPusecDelay(20);
 		i++;
-	}while(i < 50);
+	} while (i < 50);
 
 	/*
-	if (i >= 50)
-	{
-		pAd->CheckDmaBusyCount++;
-		DBGPRINT(RT_DEBUG_TRACE, ("DMA Rx keeps busy.  return on AsicRadioOff () CheckDmaBusyCount = %d \n", pAd->CheckDmaBusyCount));
-	}
-	else
-	{
-		pAd->CheckDmaBusyCount = 0;
-	}
-	*/
+	   if (i >= 50)
+	   {
+	   pAd->CheckDmaBusyCount++;
+	   DBGPRINT(RT_DEBUG_TRACE, ("DMA Rx keeps busy.  return on AsicRadioOff () CheckDmaBusyCount = %d \n", pAd->CheckDmaBusyCount));
+	   }
+	   else
+	   {
+	   pAd->CheckDmaBusyCount = 0;
+	   }
+	 */
 //KH Debug:My original codes have the follwoing codes, but currecnt codes do not have it.
 // Disable for stability. If PCIE Link Control is modified for advance power save, re-covery this code segment.
-RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0x1280);
+	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0x1280);
 //OPSTATUS_SET_FLAG(pAd, fOP_STATUS_CLKSELECT_40MHZ);
 
 #ifdef PCIE_PS_SUPPORT
-if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)
-	&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-	&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-	{
-	DBGPRINT(RT_DEBUG_TRACE, ("RT28xxPciAsicRadioOff::3090 return to skip the following TbttNumToNextWakeUp setting for 279x\n"));
-	pAd->bPCIclkOff = TRUE;
-	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
-	// For this case, doesn't need to below actions, so return here.
-	return brc;
+	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+	    && IS_VERSION_AFTER_F(pAd)
+	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RT28xxPciAsicRadioOff::3090 return to skip the following TbttNumToNextWakeUp setting for 279x\n"));
+		pAd->bPCIclkOff = TRUE;
+		RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
+		// For this case, doesn't need to below actions, so return here.
+		return brc;
 	}
 #endif // PCIE_PS_SUPPORT //
 
-	if (Level == DOT11POWERSAVE)
-	{
-		AUTO_WAKEUP_STRUC	AutoWakeupCfg;
+	if (Level == DOT11POWERSAVE) {
+		AUTO_WAKEUP_STRUC AutoWakeupCfg;
 		//RTMPSetTimer(&pAd->Mlme.PsPollTimer, 90);
 
 		// we have decided to SLEEP, so at least do it for a BEACON period.
@@ -1474,105 +1482,97 @@ if ((IS_RT3090(pAd) || IS_RT3572(pAd) ||
 		AutoWakeupCfg.field.AutoLeadTime = LEAD_TIME;
 		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
 	}
-
 	//  4-1. If it's to disable our device. Need to restore PCI Configuration Space to its original value.
-	if (Level == RTMP_HALT && pAd->OpMode == OPMODE_STA)
-	{
+	if (Level == RTMP_HALT && pAd->OpMode == OPMODE_STA) {
 		if ((brc == TRUE) && (i < 50))
 			RTMPPCIeLinkCtrlSetting(pAd, 1);
 	}
 	//  4. Set PCI configuration Space Link Comtrol fields.  Only Radio Off needs to call this function
-	else if (pAd->OpMode == OPMODE_STA)
-	{
+	else if (pAd->OpMode == OPMODE_STA) {
 		if ((brc == TRUE) && (i < 50))
 			RTMPPCIeLinkCtrlSetting(pAd, 3);
 	}
-
 	//pAd->bPCIclkOffDisableTx = FALSE;
 	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
 	return TRUE;
 }
 
-
-
-
-VOID RT28xxPciMlmeRadioOn(
-	IN PRTMP_ADAPTER pAd)
+VOID RT28xxPciMlmeRadioOn(IN PRTMP_ADAPTER pAd)
 {
-    if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
 		return;
 
-    DBGPRINT(RT_DEBUG_TRACE,("%s===>\n", __func__));
+	DBGPRINT(RT_DEBUG_TRACE, ("%s===>\n", __func__));
 
-     if ((pAd->OpMode == OPMODE_AP) ||
-        ((pAd->OpMode == OPMODE_STA)
-        && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-        ||pAd->StaCfg.PSControl.field.EnableNewPS == FALSE
-        )))
-    {
-			RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
+	if ((pAd->OpMode == OPMODE_AP) || ((pAd->OpMode == OPMODE_STA)
+					   &&
+					   (!OPSTATUS_TEST_FLAG
+					    (pAd, fOP_STATUS_PCIE_DEVICE)
+					    || pAd->StaCfg.PSControl.field.
+					    EnableNewPS == FALSE))) {
+		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
 		//NICResetFromError(pAd);
 
-	RTMPRingCleanUp(pAd, QID_AC_BK);
-	RTMPRingCleanUp(pAd, QID_AC_BE);
-	RTMPRingCleanUp(pAd, QID_AC_VI);
-	RTMPRingCleanUp(pAd, QID_AC_VO);
-	RTMPRingCleanUp(pAd, QID_MGMT);
-	RTMPRingCleanUp(pAd, QID_RX);
+		RTMPRingCleanUp(pAd, QID_AC_BK);
+		RTMPRingCleanUp(pAd, QID_AC_BE);
+		RTMPRingCleanUp(pAd, QID_AC_VI);
+		RTMPRingCleanUp(pAd, QID_AC_VO);
+		RTMPRingCleanUp(pAd, QID_MGMT);
+		RTMPRingCleanUp(pAd, QID_RX);
 
-	// Enable Tx/Rx
-	RTMPEnableRxTx(pAd);
+		// Enable Tx/Rx
+		RTMPEnableRxTx(pAd);
 
-	// Clear Radio off flag
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
+		// Clear Radio off flag
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
-	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
 
-	    // Set LED
-	    RTMPSetLED(pAd, LED_RADIO_ON);
-    }
-
-    if ((pAd->OpMode == OPMODE_STA) &&
-        (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-        &&(pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-    {
-        BOOLEAN		Cancelled;
-
-	RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
-
-        pAd->Mlme.bPsPollTimerRunning = FALSE;
-	RTMPCancelTimer(&pAd->Mlme.PsPollTimer,	&Cancelled);
-	RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer,	&Cancelled);
-	RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 40);
-    }
-}
+		// Set LED
+		RTMPSetLED(pAd, LED_RADIO_ON);
+	}
 
+	if ((pAd->OpMode == OPMODE_STA) &&
+	    (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
+	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
+		BOOLEAN Cancelled;
 
-VOID RT28xxPciMlmeRadioOFF(
-	IN PRTMP_ADAPTER pAd)
+		RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
+
+		pAd->Mlme.bPsPollTimerRunning = FALSE;
+		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer, &Cancelled);
+		RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 40);
+	}
+}
+
+VOID RT28xxPciMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 {
-	BOOLEAN brc=TRUE;
+	BOOLEAN brc = TRUE;
 
-    if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
-	return;
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+		return;
 
 	// Link down first if any association exists
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
-	{
-		if (INFRA_ON(pAd) || ADHOC_ON(pAd))
-		{
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
+		if (INFRA_ON(pAd) || ADHOC_ON(pAd)) {
 			MLME_DISASSOC_REQ_STRUCT DisReq;
-			MLME_QUEUE_ELEM *pMsgElem = (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM), MEM_ALLOC_FLAG);
-
-			if (pMsgElem)
-			{
-				COPY_MAC_ADDR(&DisReq.Addr, pAd->CommonCfg.Bssid);
-				DisReq.Reason =  REASON_DISASSOC_STA_LEAVING;
+			MLME_QUEUE_ELEM *pMsgElem =
+			    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
+							MEM_ALLOC_FLAG);
+
+			if (pMsgElem) {
+				COPY_MAC_ADDR(&DisReq.Addr,
+					      pAd->CommonCfg.Bssid);
+				DisReq.Reason = REASON_DISASSOC_STA_LEAVING;
 
 				pMsgElem->Machine = ASSOC_STATE_MACHINE;
 				pMsgElem->MsgType = MT2_MLME_DISASSOC_REQ;
-				pMsgElem->MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
-				NdisMoveMemory(pMsgElem->Msg, &DisReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
+				pMsgElem->MsgLen =
+				    sizeof(MLME_DISASSOC_REQ_STRUCT);
+				NdisMoveMemory(pMsgElem->Msg, &DisReq,
+					       sizeof
+					       (MLME_DISASSOC_REQ_STRUCT));
 
 				MlmeDisassocReqAction(pAd, pMsgElem);
 				kfree(pMsgElem);
@@ -1582,57 +1582,58 @@ VOID RT28xxPciMlmeRadioOFF(
 		}
 	}
 
-    DBGPRINT(RT_DEBUG_TRACE,("%s===>\n", __func__));
+	DBGPRINT(RT_DEBUG_TRACE, ("%s===>\n", __func__));
 
 	// Set Radio off flag
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
-    {
-	BOOLEAN		Cancelled;
-	if (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-		{
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
 	{
-			RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
-			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-	}
+		BOOLEAN Cancelled;
+		if (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
+			if (RTMP_TEST_FLAG
+			    (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
+				RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,
+						&Cancelled);
+				RTMP_CLEAR_FLAG(pAd,
+						fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+			}
 			// If during power safe mode.
-			if (pAd->StaCfg.bRadio == TRUE)
-			{
-				DBGPRINT(RT_DEBUG_TRACE,("-->MlmeRadioOff() return on bRadio == TRUE; \n"));
+			if (pAd->StaCfg.bRadio == TRUE) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("-->MlmeRadioOff() return on bRadio == TRUE; \n"));
 				return;
 			}
 			// Always radio on since the NIC needs to set the MCU command (LED_RADIO_OFF).
 			if (IDLE_ON(pAd) &&
-				(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)))
+			    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)))
 			{
 				RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
 			}
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-        {
-            BOOLEAN Cancelled;
-            pAd->Mlme.bPsPollTimerRunning = FALSE;
-            RTMPCancelTimer(&pAd->Mlme.PsPollTimer,	&Cancelled);
-	        RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer,	&Cancelled);
-        }
-		}
-
-        // Link down first if any association exists
-        if (INFRA_ON(pAd) || ADHOC_ON(pAd))
-            LinkDown(pAd, FALSE);
-        RTMPusecDelay(10000);
-        //==========================================
-        // Clean up old bss table
-        BssTableInit(&pAd->ScanTab);
-
-	/*
-        if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-        {
-            RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
-            return;
-        }
-	*/
-    }
+			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
+				BOOLEAN Cancelled;
+				pAd->Mlme.bPsPollTimerRunning = FALSE;
+				RTMPCancelTimer(&pAd->Mlme.PsPollTimer,
+						&Cancelled);
+				RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer,
+						&Cancelled);
+			}
+		}
+		// Link down first if any association exists
+		if (INFRA_ON(pAd) || ADHOC_ON(pAd))
+			LinkDown(pAd, FALSE);
+		RTMPusecDelay(10000);
+		//==========================================
+		// Clean up old bss table
+		BssTableInit(&pAd->ScanTab);
+
+		/*
+		   if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
+		   {
+		   RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
+		   return;
+		   }
+		 */
+	}
 
 	// Set LED.Move to here for fixing LED bug. This flag must be called after LinkDown
 	RTMPSetLED(pAd, LED_RADIO_OFF);
@@ -1640,21 +1641,19 @@ VOID RT28xxPciMlmeRadioOFF(
 //KH Debug:All PCIe devices need to use timer to execute radio off function, or the PCIe&&EnableNewPS needs.
 //KH Ans:It is right, because only when the PCIe and EnableNewPs is true, we need to delay the RadioOffTimer
 //to avoid the deadlock with PCIe Power saving function.
-if (pAd->OpMode == OPMODE_STA&&
-	OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)&&
-	pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-	{
-	RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
-	}
-else
-{
-		brc=RT28xxPciAsicRadioOff(pAd, GUIRADIO_OFF, 0);
+	if (pAd->OpMode == OPMODE_STA &&
+	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE) &&
+	    pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
+		RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
+	} else {
+		brc = RT28xxPciAsicRadioOff(pAd, GUIRADIO_OFF, 0);
 
-	if (brc==FALSE)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("%s call RT28xxPciAsicRadioOff fail !!\n", __func__));
+		if (brc == FALSE) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s call RT28xxPciAsicRadioOff fail !!\n",
+				  __func__));
+		}
 	}
-}
 /*
 */
 }
--- a/drivers/staging/rt2860/common/cmm_mac_usb.c
+++ b/drivers/staging/rt2860/common/cmm_mac_usb.c
@@ -27,10 +27,8 @@
 
 #ifdef RTMP_MAC_USB
 
-
 #include	"../rt_config.h"
 
-
 /*
 ========================================================================
 Routine Description:
@@ -50,50 +48,46 @@ Note:
 	NDIS packet descriptor.
 ========================================================================
 */
-NDIS_STATUS	NICInitRecv(
-	IN	PRTMP_ADAPTER	pAd)
+NDIS_STATUS NICInitRecv(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR				i;
-	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
-	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
-
+	UCHAR i;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitRecv\n"));
 	pObj = pObj;
 
 	//InterlockedExchange(&pAd->PendingRx, 0);
 	pAd->PendingRx = 0;
-	pAd->NextRxBulkInReadIndex	= 0;	// Next Rx Read index
-	pAd->NextRxBulkInIndex		= 0 ; //RX_RING_SIZE -1; // Rx Bulk pointer
-	pAd->NextRxBulkInPosition	= 0;
+	pAd->NextRxBulkInReadIndex = 0;	// Next Rx Read index
+	pAd->NextRxBulkInIndex = 0;	//RX_RING_SIZE -1; // Rx Bulk pointer
+	pAd->NextRxBulkInPosition = 0;
 
-	for (i = 0; i < (RX_RING_SIZE); i++)
-	{
-		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+	for (i = 0; i < (RX_RING_SIZE); i++) {
+		PRX_CONTEXT pRxContext = &(pAd->RxContext[i]);
 
 		//Allocate URB
 		pRxContext->pUrb = RTUSB_ALLOC_URB(0);
-		if (pRxContext->pUrb == NULL)
-		{
+		if (pRxContext->pUrb == NULL) {
 			Status = NDIS_STATUS_RESOURCES;
 			goto out1;
 		}
-
 		// Allocate transfer buffer
-		pRxContext->TransferBuffer = RTUSB_URB_ALLOC_BUFFER(pObj->pUsb_Dev, MAX_RXBULK_SIZE, &pRxContext->data_dma);
-		if (pRxContext->TransferBuffer == NULL)
-		{
+		pRxContext->TransferBuffer =
+		    RTUSB_URB_ALLOC_BUFFER(pObj->pUsb_Dev, MAX_RXBULK_SIZE,
+					   &pRxContext->data_dma);
+		if (pRxContext->TransferBuffer == NULL) {
 			Status = NDIS_STATUS_RESOURCES;
 			goto out1;
 		}
 
 		NdisZeroMemory(pRxContext->TransferBuffer, MAX_RXBULK_SIZE);
 
-		pRxContext->pAd	= pAd;
+		pRxContext->pAd = pAd;
 		pRxContext->pIrp = NULL;
-		pRxContext->InUse		= FALSE;
-		pRxContext->IRPPending	= FALSE;
-		pRxContext->Readable	= FALSE;
+		pRxContext->InUse = FALSE;
+		pRxContext->IRPPending = FALSE;
+		pRxContext->Readable = FALSE;
 		//pRxContext->ReorderInUse = FALSE;
 		pRxContext->bRxHandling = FALSE;
 		pRxContext->BulkInOffset = 0;
@@ -103,19 +97,17 @@ NDIS_STATUS	NICInitRecv(
 	return Status;
 
 out1:
-	for (i = 0; i < (RX_RING_SIZE); i++)
-	{
-		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+	for (i = 0; i < (RX_RING_SIZE); i++) {
+		PRX_CONTEXT pRxContext = &(pAd->RxContext[i]);
 
-		if (NULL != pRxContext->TransferBuffer)
-		{
+		if (NULL != pRxContext->TransferBuffer) {
 			RTUSB_URB_FREE_BUFFER(pObj->pUsb_Dev, MAX_RXBULK_SIZE,
-								pRxContext->TransferBuffer, pRxContext->data_dma);
+					      pRxContext->TransferBuffer,
+					      pRxContext->data_dma);
 			pRxContext->TransferBuffer = NULL;
 		}
 
-		if (NULL != pRxContext->pUrb)
-		{
+		if (NULL != pRxContext->pUrb) {
 			RTUSB_UNLINK_URB(pRxContext->pUrb);
 			RTUSB_FREE_URB(pRxContext->pUrb);
 			pRxContext->pUrb = NULL;
@@ -125,7 +117,6 @@ out1:
 	return Status;
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -141,8 +132,7 @@ Return Value:
 Note:
 ========================================================================
 */
-NDIS_STATUS	NICInitTransmit(
-	IN	PRTMP_ADAPTER	pAd)
+NDIS_STATUS NICInitTransmit(IN PRTMP_ADAPTER pAd)
 {
 #define LM_USB_ALLOC(pObj, Context, TB_Type, BufferSize, Status, msg1, err1, msg2, err2)	\
 	Context->pUrb = RTUSB_ALLOC_URB(0);		\
@@ -169,60 +159,59 @@ NDIS_STATUS	NICInitTransmit(
 								Context->data_dma);			\
 		Context->TransferBuffer = NULL; }
 
-	UCHAR			i, acidx;
-	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
-	PTX_CONTEXT		pNullContext   = &(pAd->NullContext);
-	PTX_CONTEXT		pPsPollContext = &(pAd->PsPollContext);
-	PTX_CONTEXT		pRTSContext    = &(pAd->RTSContext);
-	PTX_CONTEXT		pMLMEContext = NULL;
-//	PHT_TX_CONTEXT	pHTTXContext = NULL;
-	POS_COOKIE		pObj = (POS_COOKIE) pAd->OS_Cookie;
-	PVOID			RingBaseVa;
-//	RTMP_TX_RING	*pTxRing;
-	RTMP_MGMT_RING  *pMgmtRing;
+	UCHAR i, acidx;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+	PTX_CONTEXT pNullContext = &(pAd->NullContext);
+	PTX_CONTEXT pPsPollContext = &(pAd->PsPollContext);
+	PTX_CONTEXT pRTSContext = &(pAd->RTSContext);
+	PTX_CONTEXT pMLMEContext = NULL;
+//      PHT_TX_CONTEXT  pHTTXContext = NULL;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+	PVOID RingBaseVa;
+//      RTMP_TX_RING    *pTxRing;
+	RTMP_MGMT_RING *pMgmtRing;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitTransmit\n"));
 	pObj = pObj;
 
 	// Init 4 set of Tx parameters
-	for(acidx = 0; acidx < NUM_OF_TX_RING; acidx++)
-	{
+	for (acidx = 0; acidx < NUM_OF_TX_RING; acidx++) {
 		// Initialize all Transmit releated queues
 		InitializeQueueHeader(&pAd->TxSwQueue[acidx]);
 
 		// Next Local tx ring pointer waiting for buck out
 		pAd->NextBulkOutIndex[acidx] = acidx;
-		pAd->BulkOutPending[acidx] = FALSE; // Buck Out control flag
+		pAd->BulkOutPending[acidx] = FALSE;	// Buck Out control flag
 		//pAd->DataBulkDoneIdx[acidx] = 0;
 	}
 
-	//pAd->NextMLMEIndex	= 0;
-	//pAd->PushMgmtIndex	= 0;
-	//pAd->PopMgmtIndex	= 0;
+	//pAd->NextMLMEIndex    = 0;
+	//pAd->PushMgmtIndex    = 0;
+	//pAd->PopMgmtIndex     = 0;
 	//InterlockedExchange(&pAd->MgmtQueueSize, 0);
 	//InterlockedExchange(&pAd->TxCount, 0);
 
-	//pAd->PrioRingFirstIndex	= 0;
-	//pAd->PrioRingTxCnt		= 0;
+	//pAd->PrioRingFirstIndex       = 0;
+	//pAd->PrioRingTxCnt            = 0;
 
-	do
-	{
+	do {
 		//
 		// TX_RING_SIZE, 4 ACs
 		//
-		for(acidx=0; acidx<4; acidx++)
-		{
-			PHT_TX_CONTEXT	pHTTXContext = &(pAd->TxContext[acidx]);
+		for (acidx = 0; acidx < 4; acidx++) {
+			PHT_TX_CONTEXT pHTTXContext = &(pAd->TxContext[acidx]);
 
 			NdisZeroMemory(pHTTXContext, sizeof(HT_TX_CONTEXT));
 			//Allocate URB
-			LM_USB_ALLOC(pObj, pHTTXContext, PHTTX_BUFFER, sizeof(HTTX_BUFFER), Status,
-							("<-- ERROR in Alloc TX TxContext[%d] urb!! \n", acidx),
-							done,
-							("<-- ERROR in Alloc TX TxContext[%d] HTTX_BUFFER !! \n", acidx),
-							out1);
+			LM_USB_ALLOC(pObj, pHTTXContext, PHTTX_BUFFER,
+				     sizeof(HTTX_BUFFER), Status,
+				     ("<-- ERROR in Alloc TX TxContext[%d] urb!! \n",
+				      acidx), done,
+				     ("<-- ERROR in Alloc TX TxContext[%d] HTTX_BUFFER !! \n",
+				      acidx), out1);
 
-			NdisZeroMemory(pHTTXContext->TransferBuffer->Aggregation, 4);
+			NdisZeroMemory(pHTTXContext->TransferBuffer->
+				       Aggregation, 4);
 			pHTTXContext->pAd = pAd;
 			pHTTXContext->pIrp = NULL;
 			pHTTXContext->IRPPending = FALSE;
@@ -237,27 +226,27 @@ NDIS_STATUS	NICInitTransmit(
 			pAd->BulkOutPending[acidx] = FALSE;
 		}
 
-
 		//
 		// MGMT_RING_SIZE
 		//
 
 		// Allocate MGMT ring descriptor's memory
-		pAd->MgmtDescRing.AllocSize = MGMT_RING_SIZE * sizeof(TX_CONTEXT);
-		os_alloc_mem(pAd, (PUCHAR *)(&pAd->MgmtDescRing.AllocVa), pAd->MgmtDescRing.AllocSize);
-		if (pAd->MgmtDescRing.AllocVa == NULL)
-		{
+		pAd->MgmtDescRing.AllocSize =
+		    MGMT_RING_SIZE * sizeof(TX_CONTEXT);
+		os_alloc_mem(pAd, (PUCHAR *) (&pAd->MgmtDescRing.AllocVa),
+			     pAd->MgmtDescRing.AllocSize);
+		if (pAd->MgmtDescRing.AllocVa == NULL) {
 			DBGPRINT_ERR(("Failed to allocate a big buffer for MgmtDescRing!\n"));
 			Status = NDIS_STATUS_RESOURCES;
 			goto out1;
 		}
-		NdisZeroMemory(pAd->MgmtDescRing.AllocVa, pAd->MgmtDescRing.AllocSize);
-		RingBaseVa     = pAd->MgmtDescRing.AllocVa;
+		NdisZeroMemory(pAd->MgmtDescRing.AllocVa,
+			       pAd->MgmtDescRing.AllocSize);
+		RingBaseVa = pAd->MgmtDescRing.AllocVa;
 
 		// Initialize MGMT Ring and associated buffer memory
 		pMgmtRing = &pAd->MgmtRing;
-		for (i = 0; i < MGMT_RING_SIZE; i++)
-		{
+		for (i = 0; i < MGMT_RING_SIZE; i++) {
 			// link the pre-allocated Mgmt buffer to MgmtRing.Cell
 			pMgmtRing->Cell[i].AllocSize = sizeof(TX_CONTEXT);
 			pMgmtRing->Cell[i].AllocVa = RingBaseVa;
@@ -265,11 +254,13 @@ NDIS_STATUS	NICInitTransmit(
 			pMgmtRing->Cell[i].pNextNdisPacket = NULL;
 
 			//Allocate URB for MLMEContext
-			pMLMEContext = (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
+			pMLMEContext =
+			    (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
 			pMLMEContext->pUrb = RTUSB_ALLOC_URB(0);
-			if (pMLMEContext->pUrb == NULL)
-			{
-				DBGPRINT(RT_DEBUG_ERROR, ("<-- ERROR in Alloc TX MLMEContext[%d] urb!! \n", i));
+			if (pMLMEContext->pUrb == NULL) {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("<-- ERROR in Alloc TX MLMEContext[%d] urb!! \n",
+					  i));
 				Status = NDIS_STATUS_RESOURCES;
 				goto out2;
 			}
@@ -285,7 +276,8 @@ NDIS_STATUS	NICInitTransmit(
 			// Offset to next ring descriptor address
 			RingBaseVa = (PUCHAR) RingBaseVa + sizeof(TX_CONTEXT);
 		}
-		DBGPRINT(RT_DEBUG_TRACE, ("MGMT Ring: total %d entry allocated\n", i));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MGMT Ring: total %d entry allocated\n", i));
 
 		//pAd->MgmtRing.TxSwFreeIdx = (MGMT_RING_SIZE - 1);
 		pAd->MgmtRing.TxSwFreeIdx = MGMT_RING_SIZE;
@@ -295,19 +287,19 @@ NDIS_STATUS	NICInitTransmit(
 		//
 		// BEACON_RING_SIZE
 		//
-		for(i=0; i<BEACON_RING_SIZE; i++) // 2
+		for (i = 0; i < BEACON_RING_SIZE; i++)	// 2
 		{
-			PTX_CONTEXT	pBeaconContext = &(pAd->BeaconContext[i]);
-
+			PTX_CONTEXT pBeaconContext = &(pAd->BeaconContext[i]);
 
 			NdisZeroMemory(pBeaconContext, sizeof(TX_CONTEXT));
 
 			//Allocate URB
-			LM_USB_ALLOC(pObj, pBeaconContext, PTX_BUFFER, sizeof(TX_BUFFER), Status,
-							("<-- ERROR in Alloc TX BeaconContext[%d] urb!! \n", i),
-							out2,
-							("<-- ERROR in Alloc TX BeaconContext[%d] TX_BUFFER !! \n", i),
-							out3);
+			LM_USB_ALLOC(pObj, pBeaconContext, PTX_BUFFER,
+				     sizeof(TX_BUFFER), Status,
+				     ("<-- ERROR in Alloc TX BeaconContext[%d] urb!! \n",
+				      i), out2,
+				     ("<-- ERROR in Alloc TX BeaconContext[%d] TX_BUFFER !! \n",
+				      i), out3);
 
 			pBeaconContext->pAd = pAd;
 			pBeaconContext->pIrp = NULL;
@@ -321,11 +313,12 @@ NDIS_STATUS	NICInitTransmit(
 		NdisZeroMemory(pNullContext, sizeof(TX_CONTEXT));
 
 		//Allocate URB
-		LM_USB_ALLOC(pObj, pNullContext, PTX_BUFFER, sizeof(TX_BUFFER), Status,
-						("<-- ERROR in Alloc TX NullContext urb!! \n"),
-						out3,
-						("<-- ERROR in Alloc TX NullContext TX_BUFFER !! \n"),
-						out4);
+		LM_USB_ALLOC(pObj, pNullContext, PTX_BUFFER, sizeof(TX_BUFFER),
+			     Status,
+			     ("<-- ERROR in Alloc TX NullContext urb!! \n"),
+			     out3,
+			     ("<-- ERROR in Alloc TX NullContext TX_BUFFER !! \n"),
+			     out4);
 
 		pNullContext->pAd = pAd;
 		pNullContext->pIrp = NULL;
@@ -338,11 +331,12 @@ NDIS_STATUS	NICInitTransmit(
 		NdisZeroMemory(pRTSContext, sizeof(TX_CONTEXT));
 
 		//Allocate URB
-		LM_USB_ALLOC(pObj, pRTSContext, PTX_BUFFER, sizeof(TX_BUFFER), Status,
-						("<-- ERROR in Alloc TX RTSContext urb!! \n"),
-						out4,
-						("<-- ERROR in Alloc TX RTSContext TX_BUFFER !! \n"),
-						out5);
+		LM_USB_ALLOC(pObj, pRTSContext, PTX_BUFFER, sizeof(TX_BUFFER),
+			     Status,
+			     ("<-- ERROR in Alloc TX RTSContext urb!! \n"),
+			     out4,
+			     ("<-- ERROR in Alloc TX RTSContext TX_BUFFER !! \n"),
+			     out5);
 
 		pRTSContext->pAd = pAd;
 		pRTSContext->pIrp = NULL;
@@ -354,11 +348,12 @@ NDIS_STATUS	NICInitTransmit(
 		//
 		//NdisZeroMemory(pPsPollContext, sizeof(TX_CONTEXT));
 		//Allocate URB
-		LM_USB_ALLOC(pObj, pPsPollContext, PTX_BUFFER, sizeof(TX_BUFFER), Status,
-						("<-- ERROR in Alloc TX PsPollContext urb!! \n"),
-						out5,
-						("<-- ERROR in Alloc TX PsPollContext TX_BUFFER !! \n"),
-						out6);
+		LM_USB_ALLOC(pObj, pPsPollContext, PTX_BUFFER,
+			     sizeof(TX_BUFFER), Status,
+			     ("<-- ERROR in Alloc TX PsPollContext urb!! \n"),
+			     out5,
+			     ("<-- ERROR in Alloc TX PsPollContext TX_BUFFER !! \n"),
+			     out6);
 
 		pPsPollContext->pAd = pAd;
 		pPsPollContext->pIrp = NULL;
@@ -367,8 +362,7 @@ NDIS_STATUS	NICInitTransmit(
 		pPsPollContext->bAggregatible = FALSE;
 		pPsPollContext->LastOne = TRUE;
 
-	}   while (FALSE);
-
+	} while (FALSE);
 
 done:
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitTransmit(Status=%d)\n", Status));
@@ -386,30 +380,28 @@ out4:
 	LM_URB_FREE(pObj, pNullContext, sizeof(TX_BUFFER));
 
 out3:
-	for(i=0; i<BEACON_RING_SIZE; i++)
-	{
-		PTX_CONTEXT	pBeaconContext = &(pAd->BeaconContext[i]);
+	for (i = 0; i < BEACON_RING_SIZE; i++) {
+		PTX_CONTEXT pBeaconContext = &(pAd->BeaconContext[i]);
 		if (pBeaconContext)
 			LM_URB_FREE(pObj, pBeaconContext, sizeof(TX_BUFFER));
 	}
 
 out2:
-	if (pAd->MgmtDescRing.AllocVa)
-	{
+	if (pAd->MgmtDescRing.AllocVa) {
 		pMgmtRing = &pAd->MgmtRing;
-		for(i=0; i<MGMT_RING_SIZE; i++)
-		{
-			pMLMEContext = (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
+		for (i = 0; i < MGMT_RING_SIZE; i++) {
+			pMLMEContext =
+			    (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
 			if (pMLMEContext)
-				LM_URB_FREE(pObj, pMLMEContext, sizeof(TX_BUFFER));
+				LM_URB_FREE(pObj, pMLMEContext,
+					    sizeof(TX_BUFFER));
 		}
 		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
 		pAd->MgmtDescRing.AllocVa = NULL;
 	}
 
 out1:
-	for (acidx = 0; acidx < 4; acidx++)
-	{
+	for (acidx = 0; acidx < 4; acidx++) {
 		PHT_TX_CONTEXT pTxContext = &(pAd->TxContext[acidx]);
 		if (pTxContext)
 			LM_URB_FREE(pObj, pTxContext, sizeof(HTTX_BUFFER));
@@ -420,7 +412,6 @@ out1:
 	return Status;
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -437,26 +428,21 @@ Return Value:
 Note:
 ========================================================================
 */
-NDIS_STATUS	RTMPAllocTxRxRingMemory(
-	IN	PRTMP_ADAPTER	pAd)
+NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 {
-//	COUNTER_802_11	pCounter = &pAd->WlanCounters;
-	NDIS_STATUS		Status;
-	INT				num;
-
+//      COUNTER_802_11  pCounter = &pAd->WlanCounters;
+	NDIS_STATUS Status;
+	INT num;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPAllocTxRxRingMemory\n"));
 
-
-	do
-	{
+	do {
 		// Init the CmdQ and CmdQLock
 		NdisAllocateSpinLock(&pAd->CmdQLock);
 		NdisAcquireSpinLock(&pAd->CmdQLock);
 		RTUSBInitializeCmdQ(&pAd->CmdQ);
 		NdisReleaseSpinLock(&pAd->CmdQLock);
 
-
 		NdisAllocateSpinLock(&pAd->MLMEBulkOutLock);
 		//NdisAllocateSpinLock(&pAd->MLMEWaitQueueLock);
 		NdisAllocateSpinLock(&pAd->BulkOutLock[0]);
@@ -467,26 +453,24 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 		NdisAllocateSpinLock(&pAd->BulkOutLock[5]);
 		NdisAllocateSpinLock(&pAd->BulkInLock);
 
-		for (num = 0; num < NUM_OF_TX_RING; num++)
-		{
+		for (num = 0; num < NUM_OF_TX_RING; num++) {
 			NdisAllocateSpinLock(&pAd->TxContextQueueLock[num]);
 		}
 
+//              NdisAllocateSpinLock(&pAd->MemLock);    // Not used in RT28XX
 
-//		NdisAllocateSpinLock(&pAd->MemLock);	// Not used in RT28XX
-
-//		NdisAllocateSpinLock(&pAd->MacTabLock); // init it in UserCfgInit()
-//		NdisAllocateSpinLock(&pAd->BATabLock); // init it in BATableInit()
+//              NdisAllocateSpinLock(&pAd->MacTabLock); // init it in UserCfgInit()
+//              NdisAllocateSpinLock(&pAd->BATabLock); // init it in BATableInit()
 
-//		for(num=0; num<MAX_LEN_OF_BA_REC_TABLE; num++)
-//		{
-//			NdisAllocateSpinLock(&pAd->BATable.BARecEntry[num].RxReRingLock);
-//		}
+//              for(num=0; num<MAX_LEN_OF_BA_REC_TABLE; num++)
+//              {
+//                      NdisAllocateSpinLock(&pAd->BATable.BARecEntry[num].RxReRingLock);
+//              }
 
 		//
 		// Init Mac Table
 		//
-//		MacTableInitialize(pAd);
+//              MacTableInitialize(pAd);
 
 		//
 		// Init send data structures and related parameters
@@ -507,18 +491,18 @@ NDIS_STATUS	RTMPAllocTxRxRingMemory(
 	} while (FALSE);
 
 	NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
-	pAd->FragFrame.pFragPacket =  RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
+	pAd->FragFrame.pFragPacket =
+	    RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
 
-	if (pAd->FragFrame.pFragPacket == NULL)
-	{
+	if (pAd->FragFrame.pFragPacket == NULL) {
 		Status = NDIS_STATUS_RESOURCES;
 	}
 
-	DBGPRINT_S(Status, ("<-- RTMPAllocTxRxRingMemory, Status=%x\n", Status));
+	DBGPRINT_S(Status,
+		   ("<-- RTMPAllocTxRxRingMemory, Status=%x\n", Status));
 	return Status;
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -535,8 +519,7 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID	RTMPFreeTxRxRingMemory(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 {
 #define LM_URB_FREE(pObj, Context, BufferSize)				\
 	if (NULL != Context->pUrb) {							\
@@ -549,23 +532,21 @@ VOID	RTMPFreeTxRxRingMemory(
 								Context->data_dma);			\
 		Context->TransferBuffer = NULL; }
 
-
-	UINT                i, acidx;
-	PTX_CONTEXT			pNullContext   = &pAd->NullContext;
-	PTX_CONTEXT			pPsPollContext = &pAd->PsPollContext;
-	PTX_CONTEXT			pRTSContext    = &pAd->RTSContext;
-//	PHT_TX_CONTEXT		pHTTXContext;
-	//PRTMP_REORDERBUF	pReorderBuf;
-	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
-//	RTMP_TX_RING		*pTxRing;
+	UINT i, acidx;
+	PTX_CONTEXT pNullContext = &pAd->NullContext;
+	PTX_CONTEXT pPsPollContext = &pAd->PsPollContext;
+	PTX_CONTEXT pRTSContext = &pAd->RTSContext;
+//      PHT_TX_CONTEXT          pHTTXContext;
+	//PRTMP_REORDERBUF      pReorderBuf;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+//      RTMP_TX_RING            *pTxRing;
 
 	DBGPRINT(RT_DEBUG_ERROR, ("---> RTMPFreeTxRxRingMemory\n"));
 	pObj = pObj;
 
 	// Free all resources for the RECEIVE buffer queue.
-	for(i=0; i<(RX_RING_SIZE); i++)
-	{
-		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+	for (i = 0; i < (RX_RING_SIZE); i++) {
+		PRX_CONTEXT pRxContext = &(pAd->RxContext[i]);
 		if (pRxContext)
 			LM_URB_FREE(pObj, pRxContext, MAX_RXBULK_SIZE);
 	}
@@ -579,32 +560,27 @@ VOID	RTMPFreeTxRxRingMemory(
 	// Free RTS frame resource
 	LM_URB_FREE(pObj, pRTSContext, sizeof(TX_BUFFER));
 
-
 	// Free beacon frame resource
-	for(i=0; i<BEACON_RING_SIZE; i++)
-	{
-		PTX_CONTEXT	pBeaconContext = &(pAd->BeaconContext[i]);
+	for (i = 0; i < BEACON_RING_SIZE; i++) {
+		PTX_CONTEXT pBeaconContext = &(pAd->BeaconContext[i]);
 		if (pBeaconContext)
 			LM_URB_FREE(pObj, pBeaconContext, sizeof(TX_BUFFER));
 	}
 
-
 	// Free mgmt frame resource
-	for(i = 0; i < MGMT_RING_SIZE; i++)
-	{
-		PTX_CONTEXT pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[i].AllocVa;
+	for (i = 0; i < MGMT_RING_SIZE; i++) {
+		PTX_CONTEXT pMLMEContext =
+		    (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
 		//LM_URB_FREE(pObj, pMLMEContext, sizeof(TX_BUFFER));
-		if (NULL != pAd->MgmtRing.Cell[i].pNdisPacket)
-		{
-			RTMPFreeNdisPacket(pAd, pAd->MgmtRing.Cell[i].pNdisPacket);
+		if (NULL != pAd->MgmtRing.Cell[i].pNdisPacket) {
+			RTMPFreeNdisPacket(pAd,
+					   pAd->MgmtRing.Cell[i].pNdisPacket);
 			pAd->MgmtRing.Cell[i].pNdisPacket = NULL;
 			pMLMEContext->TransferBuffer = NULL;
 		}
 
-		if (pMLMEContext)
-		{
-			if (NULL != pMLMEContext->pUrb)
-			{
+		if (pMLMEContext) {
+			if (NULL != pMLMEContext->pUrb) {
 				RTUSB_UNLINK_URB(pMLMEContext->pUrb);
 				RTUSB_FREE_URB(pMLMEContext->pUrb);
 				pMLMEContext->pUrb = NULL;
@@ -614,20 +590,18 @@ VOID	RTMPFreeTxRxRingMemory(
 	if (pAd->MgmtDescRing.AllocVa)
 		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
 
-
 	// Free Tx frame resource
-	for (acidx = 0; acidx < 4; acidx++)
-		{
+	for (acidx = 0; acidx < 4; acidx++) {
 		PHT_TX_CONTEXT pHTTXContext = &(pAd->TxContext[acidx]);
-			if (pHTTXContext)
-				LM_URB_FREE(pObj, pHTTXContext, sizeof(HTTX_BUFFER));
-		}
+		if (pHTTXContext)
+			LM_URB_FREE(pObj, pHTTXContext, sizeof(HTTX_BUFFER));
+	}
 
 	if (pAd->FragFrame.pFragPacket)
-		RELEASE_NDIS_PACKET(pAd, pAd->FragFrame.pFragPacket, NDIS_STATUS_SUCCESS);
+		RELEASE_NDIS_PACKET(pAd, pAd->FragFrame.pFragPacket,
+				    NDIS_STATUS_SUCCESS);
 
-	for(i=0; i<6; i++)
-	{
+	for (i = 0; i < 6; i++) {
 		NdisFreeSpinLock(&pAd->BulkOutLock[i]);
 	}
 
@@ -638,17 +612,16 @@ VOID	RTMPFreeTxRxRingMemory(
 	// Clear all pending bulk-out request flags.
 	RTUSB_CLEAR_BULK_FLAG(pAd, 0xffffffff);
 
-//	NdisFreeSpinLock(&pAd->MacTabLock);
+//      NdisFreeSpinLock(&pAd->MacTabLock);
 
-//	for(i=0; i<MAX_LEN_OF_BA_REC_TABLE; i++)
-//	{
-//		NdisFreeSpinLock(&pAd->BATable.BARecEntry[i].RxReRingLock);
-//	}
+//      for(i=0; i<MAX_LEN_OF_BA_REC_TABLE; i++)
+//      {
+//              NdisFreeSpinLock(&pAd->BATable.BARecEntry[i].RxReRingLock);
+//      }
 
 	DBGPRINT(RT_DEBUG_ERROR, ("<--- RTMPFreeTxRxRingMemory\n"));
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -663,20 +636,17 @@ Return Value:
 Note:
 ========================================================================
 */
-NDIS_STATUS	RTUSBWriteHWMACAddress(
-	IN	PRTMP_ADAPTER		pAd)
+NDIS_STATUS RTUSBWriteHWMACAddress(IN PRTMP_ADAPTER pAd)
 {
-	MAC_DW0_STRUC	StaMacReg0;
-	MAC_DW1_STRUC	StaMacReg1;
-	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
-	LARGE_INTEGER	NOW;
-
+	MAC_DW0_STRUC StaMacReg0;
+	MAC_DW1_STRUC StaMacReg1;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+	LARGE_INTEGER NOW;
 
 	// initialize the random number generator
 	RTMP_GetCurrentSystemTime(&NOW);
 
-	if (pAd->bLocalAdminMAC != TRUE)
-	{
+	if (pAd->bLocalAdminMAC != TRUE) {
 		pAd->CurrentAddress[0] = pAd->PermanentAddress[0];
 		pAd->CurrentAddress[1] = pAd->PermanentAddress[1];
 		pAd->CurrentAddress[2] = pAd->PermanentAddress[2];
@@ -692,16 +662,17 @@ NDIS_STATUS	RTUSBWriteHWMACAddress(
 	StaMacReg1.field.Byte4 = pAd->CurrentAddress[4];
 	StaMacReg1.field.Byte5 = pAd->CurrentAddress[5];
 	StaMacReg1.field.U2MeMask = 0xff;
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
-			pAd->CurrentAddress[0], pAd->CurrentAddress[1], pAd->CurrentAddress[2],
-			pAd->CurrentAddress[3], pAd->CurrentAddress[4], pAd->CurrentAddress[5]));
+	DBGPRINT_RAW(RT_DEBUG_TRACE,
+		     ("Local MAC = %02x:%02x:%02x:%02x:%02x:%02x\n",
+		      pAd->CurrentAddress[0], pAd->CurrentAddress[1],
+		      pAd->CurrentAddress[2], pAd->CurrentAddress[3],
+		      pAd->CurrentAddress[4], pAd->CurrentAddress[5]));
 
 	RTUSBWriteMACRegister(pAd, MAC_ADDR_DW0, StaMacReg0.word);
 	RTUSBWriteMACRegister(pAd, MAC_ADDR_DW1, StaMacReg1.word);
 	return Status;
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -716,13 +687,11 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID RT28XXDMADisable(
-	IN RTMP_ADAPTER			*pAd)
+VOID RT28XXDMADisable(IN RTMP_ADAPTER * pAd)
 {
 	// no use
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -737,42 +706,40 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID RT28XXDMAEnable(
-	IN RTMP_ADAPTER			*pAd)
+VOID RT28XXDMAEnable(IN RTMP_ADAPTER * pAd)
 {
-	WPDMA_GLO_CFG_STRUC	GloCfg;
-	USB_DMA_CFG_STRUC	UsbCfg;
-	int					i = 0;
-
+	WPDMA_GLO_CFG_STRUC GloCfg;
+	USB_DMA_CFG_STRUC UsbCfg;
+	int i = 0;
 
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x4);
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)  && (GloCfg.field.RxDMABusy == 0))
+		if ((GloCfg.field.TxDMABusy == 0)
+		    && (GloCfg.field.RxDMABusy == 0))
 			break;
 
 		DBGPRINT(RT_DEBUG_TRACE, ("==>  DMABusy\n"));
 		RTMPusecDelay(1000);
 		i++;
-	}while ( i <200);
-
+	} while (i < 200);
 
 	RTMPusecDelay(50);
 	GloCfg.field.EnTXWriteBackDDONE = 1;
 	GloCfg.field.EnableRxDMA = 1;
 	GloCfg.field.EnableTxDMA = 1;
-	DBGPRINT(RT_DEBUG_TRACE, ("<== WRITE DMA offset 0x208 = 0x%x\n", GloCfg.word));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<== WRITE DMA offset 0x208 = 0x%x\n", GloCfg.word));
 	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
 
 	UsbCfg.word = 0;
 	UsbCfg.field.phyclear = 0;
 	/* usb version is 1.1,do not use bulk in aggregation */
 	if (pAd->BulkInMaxPacketSize == 512)
-			UsbCfg.field.RxBulkAggEn = 1;
+		UsbCfg.field.RxBulkAggEn = 1;
 	/* for last packet, PBF might use more than limited, so minus 2 to prevent from error */
-	UsbCfg.field.RxBulkAggLmt = (MAX_RXBULK_SIZE /1024)-3;
-	UsbCfg.field.RxBulkAggTOut = 0x80; /* 2006-10-18 */
+	UsbCfg.field.RxBulkAggLmt = (MAX_RXBULK_SIZE / 1024) - 3;
+	UsbCfg.field.RxBulkAggTOut = 0x80;	/* 2006-10-18 */
 	UsbCfg.field.RxBulkEn = 1;
 	UsbCfg.field.TxBulkEn = 1;
 
@@ -800,101 +767,96 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID RT28xx_UpdateBeaconToAsic(
-	IN RTMP_ADAPTER		*pAd,
-	IN INT				apidx,
-	IN ULONG			FrameLen,
-	IN ULONG			UpdatePos)
+VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
+			       IN INT apidx,
+			       IN ULONG FrameLen, IN ULONG UpdatePos)
 {
-	PUCHAR		pBeaconFrame = NULL;
-	UCHAR			*ptr;
-	UINT			i, padding;
-	BEACON_SYNC_STRUCT	*pBeaconSync = pAd->CommonCfg.pBeaconSync;
-	UINT32			longValue;
-//	USHORT			shortValue;
-	BOOLEAN			bBcnReq = FALSE;
-	UCHAR			bcn_idx = 0;
-
+	PUCHAR pBeaconFrame = NULL;
+	UCHAR *ptr;
+	UINT i, padding;
+	BEACON_SYNC_STRUCT *pBeaconSync = pAd->CommonCfg.pBeaconSync;
+	UINT32 longValue;
+//      USHORT                  shortValue;
+	BOOLEAN bBcnReq = FALSE;
+	UCHAR bcn_idx = 0;
 
-	if (pBeaconFrame == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("pBeaconFrame is NULL!\n"));
+	if (pBeaconFrame == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR, ("pBeaconFrame is NULL!\n"));
 		return;
 	}
 
-	if (pBeaconSync == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("pBeaconSync is NULL!\n"));
+	if (pBeaconSync == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR, ("pBeaconSync is NULL!\n"));
 		return;
 	}
-
 	//if ((pAd->WdsTab.Mode == WDS_BRIDGE_MODE) ||
-	//	((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL) || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP))
-	//	)
-	if (bBcnReq == FALSE)
-	{
+	//      ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL) || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP))
+	//      )
+	if (bBcnReq == FALSE) {
 		/* when the ra interface is down, do not send its beacon frame */
 		/* clear all zero */
-		for(i=0; i<TXWI_SIZE; i+=4) {
-			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i, 0x00);
+		for (i = 0; i < TXWI_SIZE; i += 4) {
+			RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i,
+					0x00);
 		}
-		pBeaconSync->BeaconBitMap &= (~(BEACON_BITMAP_MASK & (1 << bcn_idx)));
+		pBeaconSync->BeaconBitMap &=
+		    (~(BEACON_BITMAP_MASK & (1 << bcn_idx)));
 		NdisZeroMemory(pBeaconSync->BeaconTxWI[bcn_idx], TXWI_SIZE);
-	}
-	else
-	{
-		ptr = (PUCHAR)&pAd->BeaconTxWI;
-		if (NdisEqualMemory(pBeaconSync->BeaconTxWI[bcn_idx], &pAd->BeaconTxWI, TXWI_SIZE) == FALSE)
-		{	// If BeaconTxWI changed, we need to rewrite the TxWI for the Beacon frames.
-			pBeaconSync->BeaconBitMap &= (~(BEACON_BITMAP_MASK & (1 << bcn_idx)));
-			NdisMoveMemory(pBeaconSync->BeaconTxWI[bcn_idx], &pAd->BeaconTxWI, TXWI_SIZE);
+	} else {
+		ptr = (PUCHAR) & pAd->BeaconTxWI;
+		if (NdisEqualMemory(pBeaconSync->BeaconTxWI[bcn_idx], &pAd->BeaconTxWI, TXWI_SIZE) == FALSE) {	// If BeaconTxWI changed, we need to rewrite the TxWI for the Beacon frames.
+			pBeaconSync->BeaconBitMap &=
+			    (~(BEACON_BITMAP_MASK & (1 << bcn_idx)));
+			NdisMoveMemory(pBeaconSync->BeaconTxWI[bcn_idx],
+				       &pAd->BeaconTxWI, TXWI_SIZE);
 		}
 
-		if ((pBeaconSync->BeaconBitMap & (1 << bcn_idx)) != (1 << bcn_idx))
-		{
-			for (i=0; i<TXWI_SIZE; i+=4)  // 16-byte TXWI field
+		if ((pBeaconSync->BeaconBitMap & (1 << bcn_idx)) !=
+		    (1 << bcn_idx)) {
+			for (i = 0; i < TXWI_SIZE; i += 4)	// 16-byte TXWI field
 			{
-				longValue =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
-				RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[bcn_idx] + i, longValue);
+				longValue =
+				    *ptr + (*(ptr + 1) << 8) +
+				    (*(ptr + 2) << 16) + (*(ptr + 3) << 24);
+				RTMP_IO_WRITE32(pAd,
+						pAd->BeaconOffset[bcn_idx] + i,
+						longValue);
 				ptr += 4;
 			}
 		}
 
 		ptr = pBeaconSync->BeaconBuf[bcn_idx];
 		padding = (FrameLen & 0x01);
-		NdisZeroMemory((PUCHAR)(pBeaconFrame + FrameLen), padding);
+		NdisZeroMemory((PUCHAR) (pBeaconFrame + FrameLen), padding);
 		FrameLen += padding;
-		for (i = 0 ; i < FrameLen /*HW_BEACON_OFFSET*/; i += 2)
-		{
-			if (NdisEqualMemory(ptr, pBeaconFrame, 2) == FALSE)
-			{
+		for (i = 0; i < FrameLen /*HW_BEACON_OFFSET */ ; i += 2) {
+			if (NdisEqualMemory(ptr, pBeaconFrame, 2) == FALSE) {
 				NdisMoveMemory(ptr, pBeaconFrame, 2);
 				//shortValue = *ptr + (*(ptr+1)<<8);
 				//RTMP_IO_WRITE8(pAd, pAd->BeaconOffset[bcn_idx] + TXWI_SIZE + i, shortValue);
-				RTUSBMultiWrite(pAd, pAd->BeaconOffset[bcn_idx] + TXWI_SIZE + i, ptr, 2);
+				RTUSBMultiWrite(pAd,
+						pAd->BeaconOffset[bcn_idx] +
+						TXWI_SIZE + i, ptr, 2);
 			}
-			ptr +=2;
+			ptr += 2;
 			pBeaconFrame += 2;
 		}
 
 		pBeaconSync->BeaconBitMap |= (1 << bcn_idx);
 
 		// For AP interface, set the DtimBitOn so that we can send Bcast/Mcast frame out after this beacon frame.
-}
+	}
 
 }
 
-
-VOID RTUSBBssBeaconStop(
-	IN RTMP_ADAPTER *pAd)
+VOID RTUSBBssBeaconStop(IN RTMP_ADAPTER * pAd)
 {
-	BEACON_SYNC_STRUCT	*pBeaconSync;
+	BEACON_SYNC_STRUCT *pBeaconSync;
 	int i, offset;
-	BOOLEAN	Cancelled = TRUE;
+	BOOLEAN Cancelled = TRUE;
 
 	pBeaconSync = pAd->CommonCfg.pBeaconSync;
-	if (pBeaconSync && pBeaconSync->EnableBeacon)
-	{
+	if (pBeaconSync && pBeaconSync->EnableBeacon) {
 		INT NumOfBcn;
 
 		{
@@ -903,13 +865,15 @@ VOID RTUSBBssBeaconStop(
 
 		RTMPCancelTimer(&pAd->CommonCfg.BeaconUpdateTimer, &Cancelled);
 
-		for(i=0; i<NumOfBcn; i++)
-		{
-			NdisZeroMemory(pBeaconSync->BeaconBuf[i], HW_BEACON_OFFSET);
+		for (i = 0; i < NumOfBcn; i++) {
+			NdisZeroMemory(pBeaconSync->BeaconBuf[i],
+				       HW_BEACON_OFFSET);
 			NdisZeroMemory(pBeaconSync->BeaconTxWI[i], TXWI_SIZE);
 
-			for (offset=0; offset<HW_BEACON_OFFSET; offset+=4)
-				RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[i] + offset, 0x00);
+			for (offset = 0; offset < HW_BEACON_OFFSET; offset += 4)
+				RTMP_IO_WRITE32(pAd,
+						pAd->BeaconOffset[i] + offset,
+						0x00);
 
 			pBeaconSync->CapabilityInfoLocationInBeacon[i] = 0;
 			pBeaconSync->TimIELocationInBeacon[i] = 0;
@@ -919,64 +883,66 @@ VOID RTUSBBssBeaconStop(
 	}
 }
 
-
-VOID RTUSBBssBeaconStart(
-	IN RTMP_ADAPTER *pAd)
+VOID RTUSBBssBeaconStart(IN RTMP_ADAPTER * pAd)
 {
 	int apidx;
-	BEACON_SYNC_STRUCT	*pBeaconSync;
-//	LARGE_INTEGER	tsfTime, deltaTime;
+	BEACON_SYNC_STRUCT *pBeaconSync;
+//      LARGE_INTEGER   tsfTime, deltaTime;
 
 	pBeaconSync = pAd->CommonCfg.pBeaconSync;
-	if (pBeaconSync && pBeaconSync->EnableBeacon)
-	{
+	if (pBeaconSync && pBeaconSync->EnableBeacon) {
 		INT NumOfBcn;
 
 		{
 			NumOfBcn = MAX_MESH_NUM;
 		}
 
-		for(apidx=0; apidx<NumOfBcn; apidx++)
-		{
+		for (apidx = 0; apidx < NumOfBcn; apidx++) {
 			UCHAR CapabilityInfoLocationInBeacon = 0;
 			UCHAR TimIELocationInBeacon = 0;
 
-
-			NdisZeroMemory(pBeaconSync->BeaconBuf[apidx], HW_BEACON_OFFSET);
-			pBeaconSync->CapabilityInfoLocationInBeacon[apidx] = CapabilityInfoLocationInBeacon;
-			pBeaconSync->TimIELocationInBeacon[apidx] = TimIELocationInBeacon;
-			NdisZeroMemory(pBeaconSync->BeaconTxWI[apidx], TXWI_SIZE);
+			NdisZeroMemory(pBeaconSync->BeaconBuf[apidx],
+				       HW_BEACON_OFFSET);
+			pBeaconSync->CapabilityInfoLocationInBeacon[apidx] =
+			    CapabilityInfoLocationInBeacon;
+			pBeaconSync->TimIELocationInBeacon[apidx] =
+			    TimIELocationInBeacon;
+			NdisZeroMemory(pBeaconSync->BeaconTxWI[apidx],
+				       TXWI_SIZE);
 		}
 		pBeaconSync->BeaconBitMap = 0;
 		pBeaconSync->DtimBitOn = 0;
 		pAd->CommonCfg.BeaconUpdateTimer.Repeat = TRUE;
 
 		pAd->CommonCfg.BeaconAdjust = 0;
-		pAd->CommonCfg.BeaconFactor = 0xffffffff / (pAd->CommonCfg.BeaconPeriod << 10);
-		pAd->CommonCfg.BeaconRemain = (0xffffffff % (pAd->CommonCfg.BeaconPeriod << 10)) + 1;
-		DBGPRINT(RT_DEBUG_TRACE, ("RTUSBBssBeaconStart:BeaconFactor=%d, BeaconRemain=%d!\n",
-									pAd->CommonCfg.BeaconFactor, pAd->CommonCfg.BeaconRemain));
-		RTMPSetTimer(&pAd->CommonCfg.BeaconUpdateTimer, 10 /*pAd->CommonCfg.BeaconPeriod*/);
+		pAd->CommonCfg.BeaconFactor =
+		    0xffffffff / (pAd->CommonCfg.BeaconPeriod << 10);
+		pAd->CommonCfg.BeaconRemain =
+		    (0xffffffff % (pAd->CommonCfg.BeaconPeriod << 10)) + 1;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTUSBBssBeaconStart:BeaconFactor=%d, BeaconRemain=%d!\n",
+			  pAd->CommonCfg.BeaconFactor,
+			  pAd->CommonCfg.BeaconRemain));
+		RTMPSetTimer(&pAd->CommonCfg.BeaconUpdateTimer,
+			     10 /*pAd->CommonCfg.BeaconPeriod */ );
 
 	}
 }
 
-
-VOID RTUSBBssBeaconInit(
-	IN RTMP_ADAPTER *pAd)
+VOID RTUSBBssBeaconInit(IN RTMP_ADAPTER * pAd)
 {
-	BEACON_SYNC_STRUCT	*pBeaconSync;
+	BEACON_SYNC_STRUCT *pBeaconSync;
 	int i;
 
-	os_alloc_mem(pAd, (PUCHAR *)(&pAd->CommonCfg.pBeaconSync), sizeof(BEACON_SYNC_STRUCT));
+	os_alloc_mem(pAd, (PUCHAR *) (&pAd->CommonCfg.pBeaconSync),
+		     sizeof(BEACON_SYNC_STRUCT));
 	//NdisAllocMemory(pAd->CommonCfg.pBeaconSync, sizeof(BEACON_SYNC_STRUCT), MEM_ALLOC_FLAG);
-	if (pAd->CommonCfg.pBeaconSync)
-	{
+	if (pAd->CommonCfg.pBeaconSync) {
 		pBeaconSync = pAd->CommonCfg.pBeaconSync;
 		NdisZeroMemory(pBeaconSync, sizeof(BEACON_SYNC_STRUCT));
-		for(i=0; i < HW_BEACON_MAX_COUNT; i++)
-		{
-			NdisZeroMemory(pBeaconSync->BeaconBuf[i], HW_BEACON_OFFSET);
+		for (i = 0; i < HW_BEACON_MAX_COUNT; i++) {
+			NdisZeroMemory(pBeaconSync->BeaconBuf[i],
+				       HW_BEACON_OFFSET);
 			pBeaconSync->CapabilityInfoLocationInBeacon[i] = 0;
 			pBeaconSync->TimIELocationInBeacon[i] = 0;
 			NdisZeroMemory(pBeaconSync->BeaconTxWI[i], TXWI_SIZE);
@@ -988,24 +954,21 @@ VOID RTUSBBssBeaconInit(
 	}
 }
 
-
-VOID RTUSBBssBeaconExit(
-	IN RTMP_ADAPTER *pAd)
+VOID RTUSBBssBeaconExit(IN RTMP_ADAPTER * pAd)
 {
-	BEACON_SYNC_STRUCT	*pBeaconSync;
-	BOOLEAN	Cancelled = TRUE;
+	BEACON_SYNC_STRUCT *pBeaconSync;
+	BOOLEAN Cancelled = TRUE;
 	int i;
 
-	if (pAd->CommonCfg.pBeaconSync)
-	{
+	if (pAd->CommonCfg.pBeaconSync) {
 		pBeaconSync = pAd->CommonCfg.pBeaconSync;
 		pBeaconSync->EnableBeacon = FALSE;
 		RTMPCancelTimer(&pAd->CommonCfg.BeaconUpdateTimer, &Cancelled);
 		pBeaconSync->BeaconBitMap = 0;
 
-		for(i=0; i<HW_BEACON_MAX_COUNT; i++)
-		{
-			NdisZeroMemory(pBeaconSync->BeaconBuf[i], HW_BEACON_OFFSET);
+		for (i = 0; i < HW_BEACON_MAX_COUNT; i++) {
+			NdisZeroMemory(pBeaconSync->BeaconBuf[i],
+				       HW_BEACON_OFFSET);
 			pBeaconSync->CapabilityInfoLocationInBeacon[i] = 0;
 			pBeaconSync->TimIELocationInBeacon[i] = 0;
 			NdisZeroMemory(pBeaconSync->BeaconTxWI[i], TXWI_SIZE);
@@ -1016,7 +979,6 @@ VOID RTUSBBssBeaconExit(
 	}
 }
 
-
 /*
     ========================================================================
     Routine Description:
@@ -1035,61 +997,52 @@ VOID RTUSBBssBeaconExit(
 
     ========================================================================
 */
-VOID BeaconUpdateExec(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3)
+VOID BeaconUpdateExec(IN PVOID SystemSpecific1,
+		      IN PVOID FunctionContext,
+		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER)FunctionContext;
-	LARGE_INTEGER	tsfTime_a;//, tsfTime_b, deltaTime_exp, deltaTime_ab;
-	UINT32			delta, delta2MS, period2US, remain, remain_low, remain_high;
-//	BOOLEAN			positive;
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) FunctionContext;
+	LARGE_INTEGER tsfTime_a;	//, tsfTime_b, deltaTime_exp, deltaTime_ab;
+	UINT32 delta, delta2MS, period2US, remain, remain_low, remain_high;
+//      BOOLEAN                 positive;
 
-	if (pAd->CommonCfg.IsUpdateBeacon==TRUE)
-	{
+	if (pAd->CommonCfg.IsUpdateBeacon == TRUE) {
 		ReSyncBeaconTime(pAd);
 
-
 	}
 
 	RTMP_IO_READ32(pAd, TSF_TIMER_DW0, &tsfTime_a.u.LowPart);
 	RTMP_IO_READ32(pAd, TSF_TIMER_DW1, &tsfTime_a.u.HighPart);
 
-
 	//positive=getDeltaTime(tsfTime_a, expectedTime, &deltaTime_exp);
 	period2US = (pAd->CommonCfg.BeaconPeriod << 10);
 	remain_high = pAd->CommonCfg.BeaconRemain * tsfTime_a.u.HighPart;
 	remain_low = tsfTime_a.u.LowPart % (pAd->CommonCfg.BeaconPeriod << 10);
-	remain = (remain_high + remain_low)%(pAd->CommonCfg.BeaconPeriod << 10);
+	remain =
+	    (remain_high + remain_low) % (pAd->CommonCfg.BeaconPeriod << 10);
 	delta = (pAd->CommonCfg.BeaconPeriod << 10) - remain;
 
-	delta2MS = (delta>>10);
-	if (delta2MS > 150)
-	{
+	delta2MS = (delta >> 10);
+	if (delta2MS > 150) {
 		pAd->CommonCfg.BeaconUpdateTimer.TimerValue = 100;
-		pAd->CommonCfg.IsUpdateBeacon=FALSE;
-	}
-	else
-	{
+		pAd->CommonCfg.IsUpdateBeacon = FALSE;
+	} else {
 		pAd->CommonCfg.BeaconUpdateTimer.TimerValue = delta2MS + 10;
-		pAd->CommonCfg.IsUpdateBeacon=TRUE;
+		pAd->CommonCfg.IsUpdateBeacon = TRUE;
 	}
 
 }
 
-
 /********************************************************************
   *
   *	2870 Radio on/off Related functions.
   *
   ********************************************************************/
-VOID RT28xxUsbMlmeRadioOn(
-	IN PRTMP_ADAPTER pAd)
+VOID RT28xxUsbMlmeRadioOn(IN PRTMP_ADAPTER pAd)
 {
 	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
 
-    DBGPRINT(RT_DEBUG_TRACE,("RT28xxUsbMlmeRadioOn()\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("RT28xxUsbMlmeRadioOn()\n"));
 
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
 		return;
@@ -1109,20 +1062,18 @@ VOID RT28xxUsbMlmeRadioOn(
 	// Clear Radio off flag
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
-		RTUSBBulkReceive(pAd);
+	RTUSBBulkReceive(pAd);
 
 	// Set LED
 	RTMPSetLED(pAd, LED_RADIO_ON);
 }
 
-
-VOID RT28xxUsbMlmeRadioOFF(
-	IN PRTMP_ADAPTER pAd)
+VOID RT28xxUsbMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 {
-	WPDMA_GLO_CFG_STRUC	GloCfg;
-	UINT32	Value, i;
+	WPDMA_GLO_CFG_STRUC GloCfg;
+	UINT32 Value, i;
 
-	DBGPRINT(RT_DEBUG_TRACE,("RT28xxUsbMlmeRadioOFF()\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("RT28xxUsbMlmeRadioOFF()\n"));
 
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
 		return;
@@ -1132,22 +1083,25 @@ VOID RT28xxUsbMlmeRadioOFF(
 	RTMPZeroMemory(pAd->StaCfg.SavedPMK, (PMKID_NO * sizeof(BSSID_INFO)));
 
 	// Link down first if any association exists
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
-	{
-		if (INFRA_ON(pAd) || ADHOC_ON(pAd))
-		{
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
+		if (INFRA_ON(pAd) || ADHOC_ON(pAd)) {
 			MLME_DISASSOC_REQ_STRUCT DisReq;
-			MLME_QUEUE_ELEM *pMsgElem = (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM), MEM_ALLOC_FLAG);
-
-			if (pMsgElem)
-			{
-				COPY_MAC_ADDR(&DisReq.Addr, pAd->CommonCfg.Bssid);
-				DisReq.Reason =  REASON_DISASSOC_STA_LEAVING;
+			MLME_QUEUE_ELEM *pMsgElem =
+			    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
+							MEM_ALLOC_FLAG);
+
+			if (pMsgElem) {
+				COPY_MAC_ADDR(&DisReq.Addr,
+					      pAd->CommonCfg.Bssid);
+				DisReq.Reason = REASON_DISASSOC_STA_LEAVING;
 
 				pMsgElem->Machine = ASSOC_STATE_MACHINE;
 				pMsgElem->MsgType = MT2_MLME_DISASSOC_REQ;
-				pMsgElem->MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
-				NdisMoveMemory(pMsgElem->Msg, &DisReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
+				pMsgElem->MsgLen =
+				    sizeof(MLME_DISASSOC_REQ_STRUCT);
+				NdisMoveMemory(pMsgElem->Msg, &DisReq,
+					       sizeof
+					       (MLME_DISASSOC_REQ_STRUCT));
 
 				MlmeDisassocReqAction(pAd, pMsgElem);
 				kfree(pMsgElem);
@@ -1156,7 +1110,6 @@ VOID RT28xxUsbMlmeRadioOFF(
 			}
 		}
 	}
-
 	// Set Radio off flag
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
@@ -1174,34 +1127,30 @@ VOID RT28xxUsbMlmeRadioOFF(
 	// Set LED
 	RTMPSetLED(pAd, LED_RADIO_OFF);
 
-
-	if (pAd->CommonCfg.BBPCurrentBW == BW_40)
-	{
+	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
 		// Must using 40MHz.
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.CentralChannel);
-	}
-	else
-	{
+	} else {
 		// Must using 20MHz.
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.Channel);
 	}
 
 	// Disable Tx/Rx DMA
-	RTUSBReadMACRegister(pAd, WPDMA_GLO_CFG, &GloCfg.word);	   // disable DMA
+	RTUSBReadMACRegister(pAd, WPDMA_GLO_CFG, &GloCfg.word);	// disable DMA
 	GloCfg.field.EnableTxDMA = 0;
 	GloCfg.field.EnableRxDMA = 0;
-	RTUSBWriteMACRegister(pAd, WPDMA_GLO_CFG, GloCfg.word);	   // abort all TX rings
+	RTUSBWriteMACRegister(pAd, WPDMA_GLO_CFG, GloCfg.word);	// abort all TX rings
 
 	// Waiting for DMA idle
 	i = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0) && (GloCfg.field.RxDMABusy == 0))
+		if ((GloCfg.field.TxDMABusy == 0)
+		    && (GloCfg.field.RxDMABusy == 0))
 			break;
 
 		RTMPusecDelay(1000);
-	}while (i++ < 100);
+	} while (i++ < 100);
 
 	// Disable MAC Tx/Rx
 	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
--- a/drivers/staging/rt2860/common/cmm_sanity.c
+++ b/drivers/staging/rt2860/common/cmm_sanity.c
@@ -36,17 +36,16 @@
 */
 #include "../rt_config.h"
 
+extern UCHAR CISCO_OUI[];
 
-extern UCHAR	CISCO_OUI[];
-
-extern UCHAR	WPA_OUI[];
-extern UCHAR	RSN_OUI[];
-extern UCHAR	WME_INFO_ELEM[];
-extern UCHAR	WME_PARM_ELEM[];
-extern UCHAR	Ccx2QosInfo[];
-extern UCHAR	RALINK_OUI[];
-extern UCHAR	BROADCOM_OUI[];
-extern UCHAR    WPS_OUI[];
+extern UCHAR WPA_OUI[];
+extern UCHAR RSN_OUI[];
+extern UCHAR WME_INFO_ELEM[];
+extern UCHAR WME_PARM_ELEM[];
+extern UCHAR Ccx2QosInfo[];
+extern UCHAR RALINK_OUI[];
+extern UCHAR BROADCOM_OUI[];
+extern UCHAR WPS_OUI[];
 
 /*
     ==========================================================================
@@ -59,35 +58,32 @@ extern UCHAR    WPS_OUI[];
 
     ==========================================================================
  */
-BOOLEAN MlmeAddBAReqSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pAddr2)
+BOOLEAN MlmeAddBAReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg, IN ULONG MsgLen, OUT PUCHAR pAddr2)
 {
-    PMLME_ADDBA_REQ_STRUCT   pInfo;
+	PMLME_ADDBA_REQ_STRUCT pInfo;
+
+	pInfo = (MLME_ADDBA_REQ_STRUCT *) Msg;
+
+	if ((MsgLen != sizeof(MLME_ADDBA_REQ_STRUCT))) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeAddBAReqSanity fail - message lenght not correct.\n"));
+		return FALSE;
+	}
 
-    pInfo = (MLME_ADDBA_REQ_STRUCT *)Msg;
+	if ((pInfo->Wcid >= MAX_LEN_OF_MAC_TABLE)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeAddBAReqSanity fail - The peer Mac is not associated yet.\n"));
+		return FALSE;
+	}
 
-    if ((MsgLen != sizeof(MLME_ADDBA_REQ_STRUCT)))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("MlmeAddBAReqSanity fail - message lenght not correct.\n"));
-        return FALSE;
-    }
-
-    if ((pInfo->Wcid >= MAX_LEN_OF_MAC_TABLE))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("MlmeAddBAReqSanity fail - The peer Mac is not associated yet.\n"));
-        return FALSE;
-    }
-
-    if ((pInfo->pAddr[0]&0x01) == 0x01)
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("MlmeAddBAReqSanity fail - broadcast address not support BA\n"));
-        return FALSE;
-    }
+	if ((pInfo->pAddr[0] & 0x01) == 0x01) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeAddBAReqSanity fail - broadcast address not support BA\n"));
+		return FALSE;
+	}
 
-    return TRUE;
+	return TRUE;
 }
 
 /*
@@ -101,131 +97,133 @@ BOOLEAN MlmeAddBAReqSanity(
 
     ==========================================================================
  */
-BOOLEAN MlmeDelBAReqSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen)
+BOOLEAN MlmeDelBAReqSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULONG MsgLen)
 {
 	MLME_DELBA_REQ_STRUCT *pInfo;
-	pInfo = (MLME_DELBA_REQ_STRUCT *)Msg;
+	pInfo = (MLME_DELBA_REQ_STRUCT *) Msg;
+
+	if ((MsgLen != sizeof(MLME_DELBA_REQ_STRUCT))) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("MlmeDelBAReqSanity fail - message lenght not correct.\n"));
+		return FALSE;
+	}
+
+	if ((pInfo->Wcid >= MAX_LEN_OF_MAC_TABLE)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("MlmeDelBAReqSanity fail - The peer Mac is not associated yet.\n"));
+		return FALSE;
+	}
+
+	if ((pInfo->TID & 0xf0)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("MlmeDelBAReqSanity fail - The peer TID is incorrect.\n"));
+		return FALSE;
+	}
 
-    if ((MsgLen != sizeof(MLME_DELBA_REQ_STRUCT)))
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("MlmeDelBAReqSanity fail - message lenght not correct.\n"));
-        return FALSE;
-    }
-
-    if ((pInfo->Wcid >= MAX_LEN_OF_MAC_TABLE))
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("MlmeDelBAReqSanity fail - The peer Mac is not associated yet.\n"));
-        return FALSE;
-    }
-
-    if ((pInfo->TID & 0xf0))
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("MlmeDelBAReqSanity fail - The peer TID is incorrect.\n"));
-        return FALSE;
-    }
-
-	if (NdisEqualMemory(pAd->MacTab.Content[pInfo->Wcid].Addr, pInfo->Addr, MAC_ADDR_LEN) == 0)
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("MlmeDelBAReqSanity fail - the peer addr dosen't exist.\n"));
-        return FALSE;
-    }
+	if (NdisEqualMemory
+	    (pAd->MacTab.Content[pInfo->Wcid].Addr, pInfo->Addr,
+	     MAC_ADDR_LEN) == 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("MlmeDelBAReqSanity fail - the peer addr dosen't exist.\n"));
+		return FALSE;
+	}
 
-    return TRUE;
+	return TRUE;
 }
 
-BOOLEAN PeerAddBAReqActionSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *pMsg,
-    IN ULONG MsgLen,
-	OUT PUCHAR pAddr2)
+BOOLEAN PeerAddBAReqActionSanity(IN PRTMP_ADAPTER pAd,
+				 IN VOID * pMsg,
+				 IN ULONG MsgLen, OUT PUCHAR pAddr2)
 {
-	PFRAME_802_11 pFrame = (PFRAME_802_11)pMsg;
+	PFRAME_802_11 pFrame = (PFRAME_802_11) pMsg;
 	PFRAME_ADDBA_REQ pAddFrame;
-	pAddFrame = (PFRAME_ADDBA_REQ)(pMsg);
-	if (MsgLen < (sizeof(FRAME_ADDBA_REQ)))
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("PeerAddBAReqActionSanity: ADDBA Request frame length size = %ld incorrect\n", MsgLen));
+	pAddFrame = (PFRAME_ADDBA_REQ) (pMsg);
+	if (MsgLen < (sizeof(FRAME_ADDBA_REQ))) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("PeerAddBAReqActionSanity: ADDBA Request frame length size = %ld incorrect\n",
+			  MsgLen));
 		return FALSE;
 	}
 	// we support immediate BA.
-	*(USHORT *)(&pAddFrame->BaParm) = cpu2le16(*(USHORT *)(&pAddFrame->BaParm));
+	*(USHORT *) (&pAddFrame->BaParm) =
+	    cpu2le16(*(USHORT *) (&pAddFrame->BaParm));
 	pAddFrame->TimeOutValue = cpu2le16(pAddFrame->TimeOutValue);
 	pAddFrame->BaStartSeq.word = cpu2le16(pAddFrame->BaStartSeq.word);
 
-	if (pAddFrame->BaParm.BAPolicy != IMMED_BA)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("PeerAddBAReqActionSanity: ADDBA Request Ba Policy[%d] not support\n", pAddFrame->BaParm.BAPolicy));
-		DBGPRINT(RT_DEBUG_ERROR,("ADDBA Request. tid=%x, Bufsize=%x, AMSDUSupported=%x \n", pAddFrame->BaParm.TID, pAddFrame->BaParm.BufSize, pAddFrame->BaParm.AMSDUSupported));
+	if (pAddFrame->BaParm.BAPolicy != IMMED_BA) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("PeerAddBAReqActionSanity: ADDBA Request Ba Policy[%d] not support\n",
+			  pAddFrame->BaParm.BAPolicy));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("ADDBA Request. tid=%x, Bufsize=%x, AMSDUSupported=%x \n",
+			  pAddFrame->BaParm.TID, pAddFrame->BaParm.BufSize,
+			  pAddFrame->BaParm.AMSDUSupported));
 		return FALSE;
 	}
-
 	// we support immediate BA.
-	if (pAddFrame->BaParm.TID &0xfff0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("PeerAddBAReqActionSanity: ADDBA Request incorrect TID = %d\n", pAddFrame->BaParm.TID));
+	if (pAddFrame->BaParm.TID & 0xfff0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("PeerAddBAReqActionSanity: ADDBA Request incorrect TID = %d\n",
+			  pAddFrame->BaParm.TID));
 		return FALSE;
 	}
 	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
 	return TRUE;
 }
 
-BOOLEAN PeerAddBARspActionSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *pMsg,
-    IN ULONG MsgLen)
+BOOLEAN PeerAddBARspActionSanity(IN PRTMP_ADAPTER pAd,
+				 IN VOID * pMsg, IN ULONG MsgLen)
 {
 	PFRAME_ADDBA_RSP pAddFrame;
 
-	pAddFrame = (PFRAME_ADDBA_RSP)(pMsg);
-	if (MsgLen < (sizeof(FRAME_ADDBA_RSP)))
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("PeerAddBARspActionSanity: ADDBA Response frame length size = %ld incorrect\n", MsgLen));
+	pAddFrame = (PFRAME_ADDBA_RSP) (pMsg);
+	if (MsgLen < (sizeof(FRAME_ADDBA_RSP))) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("PeerAddBARspActionSanity: ADDBA Response frame length size = %ld incorrect\n",
+			  MsgLen));
 		return FALSE;
 	}
 	// we support immediate BA.
-	*(USHORT *)(&pAddFrame->BaParm) = cpu2le16(*(USHORT *)(&pAddFrame->BaParm));
+	*(USHORT *) (&pAddFrame->BaParm) =
+	    cpu2le16(*(USHORT *) (&pAddFrame->BaParm));
 	pAddFrame->StatusCode = cpu2le16(pAddFrame->StatusCode);
 	pAddFrame->TimeOutValue = cpu2le16(pAddFrame->TimeOutValue);
 
-	if (pAddFrame->BaParm.BAPolicy != IMMED_BA)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("PeerAddBAReqActionSanity: ADDBA Response Ba Policy[%d] not support\n", pAddFrame->BaParm.BAPolicy));
+	if (pAddFrame->BaParm.BAPolicy != IMMED_BA) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("PeerAddBAReqActionSanity: ADDBA Response Ba Policy[%d] not support\n",
+			  pAddFrame->BaParm.BAPolicy));
 		return FALSE;
 	}
-
 	// we support immediate BA.
-	if (pAddFrame->BaParm.TID &0xfff0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("PeerAddBARspActionSanity: ADDBA Response incorrect TID = %d\n", pAddFrame->BaParm.TID));
+	if (pAddFrame->BaParm.TID & 0xfff0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("PeerAddBARspActionSanity: ADDBA Response incorrect TID = %d\n",
+			  pAddFrame->BaParm.TID));
 		return FALSE;
 	}
 	return TRUE;
 
 }
 
-BOOLEAN PeerDelBAActionSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN UCHAR Wcid,
-    IN VOID *pMsg,
-    IN ULONG MsgLen )
+BOOLEAN PeerDelBAActionSanity(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR Wcid, IN VOID * pMsg, IN ULONG MsgLen)
 {
 	//PFRAME_802_11 pFrame = (PFRAME_802_11)pMsg;
-	PFRAME_DELBA_REQ  pDelFrame;
+	PFRAME_DELBA_REQ pDelFrame;
 	if (MsgLen != (sizeof(FRAME_DELBA_REQ)))
 		return FALSE;
 
 	if (Wcid >= MAX_LEN_OF_MAC_TABLE)
 		return FALSE;
 
-	pDelFrame = (PFRAME_DELBA_REQ)(pMsg);
+	pDelFrame = (PFRAME_DELBA_REQ) (pMsg);
 
-	*(USHORT *)(&pDelFrame->DelbaParm) = cpu2le16(*(USHORT *)(&pDelFrame->DelbaParm));
+	*(USHORT *) (&pDelFrame->DelbaParm) =
+	    cpu2le16(*(USHORT *) (&pDelFrame->DelbaParm));
 	pDelFrame->ReasonCode = cpu2le16(pDelFrame->ReasonCode);
 
-	if (pDelFrame->DelbaParm.TID &0xfff0)
+	if (pDelFrame->DelbaParm.TID & 0xfff0)
 		return FALSE;
 
 	return TRUE;
@@ -242,493 +240,469 @@ BOOLEAN PeerDelBAActionSanity(
 
     ==========================================================================
  */
-BOOLEAN PeerBeaconAndProbeRspSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    IN UCHAR  MsgChannel,
-    OUT PUCHAR pAddr2,
-    OUT PUCHAR pBssid,
-    OUT CHAR Ssid[],
-    OUT UCHAR *pSsidLen,
-    OUT UCHAR *pBssType,
-    OUT USHORT *pBeaconPeriod,
-    OUT UCHAR *pChannel,
-    OUT UCHAR *pNewChannel,
-    OUT LARGE_INTEGER *pTimestamp,
-    OUT CF_PARM *pCfParm,
-    OUT USHORT *pAtimWin,
-    OUT USHORT *pCapabilityInfo,
-    OUT UCHAR *pErp,
-    OUT UCHAR *pDtimCount,
-    OUT UCHAR *pDtimPeriod,
-    OUT UCHAR *pBcastFlag,
-    OUT UCHAR *pMessageToMe,
-    OUT UCHAR SupRate[],
-    OUT UCHAR *pSupRateLen,
-    OUT UCHAR ExtRate[],
-    OUT UCHAR *pExtRateLen,
-    OUT	UCHAR *pCkipFlag,
-    OUT	UCHAR *pAironetCellPowerLimit,
-    OUT PEDCA_PARM       pEdcaParm,
-    OUT PQBSS_LOAD_PARM  pQbssLoad,
-    OUT PQOS_CAPABILITY_PARM pQosCapability,
-    OUT ULONG *pRalinkIe,
-    OUT UCHAR		 *pHtCapabilityLen,
-    OUT UCHAR		 *pPreNHtCapabilityLen,
-    OUT HT_CAPABILITY_IE *pHtCapability,
-	OUT UCHAR		 *AddHtInfoLen,
-	OUT ADD_HT_INFO_IE *AddHtInfo,
-	OUT UCHAR *NewExtChannelOffset,		// Ht extension channel offset(above or below)
-    OUT USHORT *LengthVIE,
-    OUT	PNDIS_802_11_VARIABLE_IEs pVIE)
+BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULONG MsgLen, IN UCHAR MsgChannel, OUT PUCHAR pAddr2, OUT PUCHAR pBssid, OUT CHAR Ssid[], OUT UCHAR * pSsidLen, OUT UCHAR * pBssType, OUT USHORT * pBeaconPeriod, OUT UCHAR * pChannel, OUT UCHAR * pNewChannel, OUT LARGE_INTEGER * pTimestamp, OUT CF_PARM * pCfParm, OUT USHORT * pAtimWin, OUT USHORT * pCapabilityInfo, OUT UCHAR * pErp, OUT UCHAR * pDtimCount, OUT UCHAR * pDtimPeriod, OUT UCHAR * pBcastFlag, OUT UCHAR * pMessageToMe, OUT UCHAR SupRate[], OUT UCHAR * pSupRateLen, OUT UCHAR ExtRate[], OUT UCHAR * pExtRateLen, OUT UCHAR * pCkipFlag, OUT UCHAR * pAironetCellPowerLimit, OUT PEDCA_PARM pEdcaParm, OUT PQBSS_LOAD_PARM pQbssLoad, OUT PQOS_CAPABILITY_PARM pQosCapability, OUT ULONG * pRalinkIe, OUT UCHAR * pHtCapabilityLen, OUT UCHAR * pPreNHtCapabilityLen, OUT HT_CAPABILITY_IE * pHtCapability, OUT UCHAR * AddHtInfoLen, OUT ADD_HT_INFO_IE * AddHtInfo, OUT UCHAR * NewExtChannelOffset,	// Ht extension channel offset(above or below)
+				    OUT USHORT * LengthVIE,
+				    OUT PNDIS_802_11_VARIABLE_IEs pVIE)
 {
-    UCHAR				*Ptr;
-	UCHAR				TimLen;
-    PFRAME_802_11		pFrame;
-    PEID_STRUCT         pEid;
-    UCHAR				SubType;
-    UCHAR				Sanity;
-    //UCHAR				ECWMin, ECWMax;
-    //MAC_CSR9_STRUC		Csr9;
-    ULONG				Length = 0;
+	UCHAR *Ptr;
+	UCHAR TimLen;
+	PFRAME_802_11 pFrame;
+	PEID_STRUCT pEid;
+	UCHAR SubType;
+	UCHAR Sanity;
+	//UCHAR                             ECWMin, ECWMax;
+	//MAC_CSR9_STRUC            Csr9;
+	ULONG Length = 0;
 
 	// For some 11a AP which didn't have DS_IE, we use two conditions to decide the channel
-	//	1. If the AP is 11n enabled, then check the control channel.
-	//	2. If the AP didn't have any info about channel, use the channel we received this frame as the channel. (May inaccuracy!!)
-	UCHAR			CtrlChannel = 0;
-
-    // Add for 3 necessary EID field check
-    Sanity = 0;
-
-    *pAtimWin = 0;
-    *pErp = 0;
-    *pDtimCount = 0;
-    *pDtimPeriod = 0;
-    *pBcastFlag = 0;
-    *pMessageToMe = 0;
-    *pExtRateLen = 0;
-    *pCkipFlag = 0;			        // Default of CkipFlag is 0
-    *pAironetCellPowerLimit = 0xFF;  // Default of AironetCellPowerLimit is 0xFF
-    *LengthVIE = 0;					// Set the length of VIE to init value 0
-    *pHtCapabilityLen = 0;					// Set the length of VIE to init value 0
+	//      1. If the AP is 11n enabled, then check the control channel.
+	//      2. If the AP didn't have any info about channel, use the channel we received this frame as the channel. (May inaccuracy!!)
+	UCHAR CtrlChannel = 0;
+
+	// Add for 3 necessary EID field check
+	Sanity = 0;
+
+	*pAtimWin = 0;
+	*pErp = 0;
+	*pDtimCount = 0;
+	*pDtimPeriod = 0;
+	*pBcastFlag = 0;
+	*pMessageToMe = 0;
+	*pExtRateLen = 0;
+	*pCkipFlag = 0;		// Default of CkipFlag is 0
+	*pAironetCellPowerLimit = 0xFF;	// Default of AironetCellPowerLimit is 0xFF
+	*LengthVIE = 0;		// Set the length of VIE to init value 0
+	*pHtCapabilityLen = 0;	// Set the length of VIE to init value 0
 	if (pAd->OpMode == OPMODE_STA)
-		*pPreNHtCapabilityLen = 0;					// Set the length of VIE to init value 0
-    *AddHtInfoLen = 0;					// Set the length of VIE to init value 0
-    *pRalinkIe = 0;
-    *pNewChannel = 0;
-    *NewExtChannelOffset = 0xff;	//Default 0xff means no such IE
-    pCfParm->bValid = FALSE;        // default: no IE_CF found
-    pQbssLoad->bValid = FALSE;      // default: no IE_QBSS_LOAD found
-    pEdcaParm->bValid = FALSE;      // default: no IE_EDCA_PARAMETER found
-    pQosCapability->bValid = FALSE; // default: no IE_QOS_CAPABILITY found
-
-    pFrame = (PFRAME_802_11)Msg;
-
-    // get subtype from header
-    SubType = (UCHAR)pFrame->Hdr.FC.SubType;
-
-    // get Addr2 and BSSID from header
-    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-    COPY_MAC_ADDR(pBssid, pFrame->Hdr.Addr3);
+		*pPreNHtCapabilityLen = 0;	// Set the length of VIE to init value 0
+	*AddHtInfoLen = 0;	// Set the length of VIE to init value 0
+	*pRalinkIe = 0;
+	*pNewChannel = 0;
+	*NewExtChannelOffset = 0xff;	//Default 0xff means no such IE
+	pCfParm->bValid = FALSE;	// default: no IE_CF found
+	pQbssLoad->bValid = FALSE;	// default: no IE_QBSS_LOAD found
+	pEdcaParm->bValid = FALSE;	// default: no IE_EDCA_PARAMETER found
+	pQosCapability->bValid = FALSE;	// default: no IE_QOS_CAPABILITY found
 
-    Ptr = pFrame->Octet;
-    Length += LENGTH_802_11;
+	pFrame = (PFRAME_802_11) Msg;
 
-    // get timestamp from payload and advance the pointer
-    NdisMoveMemory(pTimestamp, Ptr, TIMESTAMP_LEN);
+	// get subtype from header
+	SubType = (UCHAR) pFrame->Hdr.FC.SubType;
+
+	// get Addr2 and BSSID from header
+	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+	COPY_MAC_ADDR(pBssid, pFrame->Hdr.Addr3);
+
+	Ptr = pFrame->Octet;
+	Length += LENGTH_802_11;
+
+	// get timestamp from payload and advance the pointer
+	NdisMoveMemory(pTimestamp, Ptr, TIMESTAMP_LEN);
 
 	pTimestamp->u.LowPart = cpu2le32(pTimestamp->u.LowPart);
 	pTimestamp->u.HighPart = cpu2le32(pTimestamp->u.HighPart);
 
-    Ptr += TIMESTAMP_LEN;
-    Length += TIMESTAMP_LEN;
+	Ptr += TIMESTAMP_LEN;
+	Length += TIMESTAMP_LEN;
+
+	// get beacon interval from payload and advance the pointer
+	NdisMoveMemory(pBeaconPeriod, Ptr, 2);
+	Ptr += 2;
+	Length += 2;
+
+	// get capability info from payload and advance the pointer
+	NdisMoveMemory(pCapabilityInfo, Ptr, 2);
+	Ptr += 2;
+	Length += 2;
 
-    // get beacon interval from payload and advance the pointer
-    NdisMoveMemory(pBeaconPeriod, Ptr, 2);
-    Ptr += 2;
-    Length += 2;
-
-    // get capability info from payload and advance the pointer
-    NdisMoveMemory(pCapabilityInfo, Ptr, 2);
-    Ptr += 2;
-    Length += 2;
-
-    if (CAP_IS_ESS_ON(*pCapabilityInfo))
-        *pBssType = BSS_INFRA;
-    else
-        *pBssType = BSS_ADHOC;
-
-    pEid = (PEID_STRUCT) Ptr;
-
-    // get variable fields from payload and advance the pointer
-    while ((Length + 2 + pEid->Len) <= MsgLen)
-    {
-        //
-        // Secure copy VIE to VarIE[MAX_VIE_LEN] didn't overflow.
-        //
-        if ((*LengthVIE + pEid->Len + 2) >= MAX_VIE_LEN)
-        {
-            DBGPRINT(RT_DEBUG_WARN, ("PeerBeaconAndProbeRspSanity - Variable IEs out of resource [len(=%d) > MAX_VIE_LEN(=%d)]\n",
-                    (*LengthVIE + pEid->Len + 2), MAX_VIE_LEN));
-            break;
-        }
-
-        switch(pEid->Eid)
-        {
-            case IE_SSID:
-                // Already has one SSID EID in this beacon, ignore the second one
-                if (Sanity & 0x1)
-                    break;
-                if(pEid->Len <= MAX_LEN_OF_SSID)
-                {
-                    NdisMoveMemory(Ssid, pEid->Octet, pEid->Len);
-                    *pSsidLen = pEid->Len;
-                    Sanity |= 0x1;
-                }
-                else
-                {
-                    DBGPRINT(RT_DEBUG_TRACE, ("PeerBeaconAndProbeRspSanity - wrong IE_SSID (len=%d)\n",pEid->Len));
-                    return FALSE;
-                }
-                break;
-
-            case IE_SUPP_RATES:
-                if(pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES)
-                {
-                    Sanity |= 0x2;
-                    NdisMoveMemory(SupRate, pEid->Octet, pEid->Len);
-                    *pSupRateLen = pEid->Len;
-
-                    // TODO: 2004-09-14 not a good design here, cause it exclude extra rates
-                    // from ScanTab. We should report as is. And filter out unsupported
-                    // rates in MlmeAux.
-                    // Check against the supported rates
-                    // RTMPCheckRates(pAd, SupRate, pSupRateLen);
-                }
-                else
-                {
-                    DBGPRINT(RT_DEBUG_TRACE, ("PeerBeaconAndProbeRspSanity - wrong IE_SUPP_RATES (len=%d)\n",pEid->Len));
-                    return FALSE;
-                }
-                break;
+	if (CAP_IS_ESS_ON(*pCapabilityInfo))
+		*pBssType = BSS_INFRA;
+	else
+		*pBssType = BSS_ADHOC;
 
-            case IE_HT_CAP:
-			if (pEid->Len >= SIZE_HT_CAP_IE)  //Note: allow extension.!!
+	pEid = (PEID_STRUCT) Ptr;
+
+	// get variable fields from payload and advance the pointer
+	while ((Length + 2 + pEid->Len) <= MsgLen) {
+		//
+		// Secure copy VIE to VarIE[MAX_VIE_LEN] didn't overflow.
+		//
+		if ((*LengthVIE + pEid->Len + 2) >= MAX_VIE_LEN) {
+			DBGPRINT(RT_DEBUG_WARN,
+				 ("PeerBeaconAndProbeRspSanity - Variable IEs out of resource [len(=%d) > MAX_VIE_LEN(=%d)]\n",
+				  (*LengthVIE + pEid->Len + 2), MAX_VIE_LEN));
+			break;
+		}
+
+		switch (pEid->Eid) {
+		case IE_SSID:
+			// Already has one SSID EID in this beacon, ignore the second one
+			if (Sanity & 0x1)
+				break;
+			if (pEid->Len <= MAX_LEN_OF_SSID) {
+				NdisMoveMemory(Ssid, pEid->Octet, pEid->Len);
+				*pSsidLen = pEid->Len;
+				Sanity |= 0x1;
+			} else {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("PeerBeaconAndProbeRspSanity - wrong IE_SSID (len=%d)\n",
+					  pEid->Len));
+				return FALSE;
+			}
+			break;
+
+		case IE_SUPP_RATES:
+			if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES) {
+				Sanity |= 0x2;
+				NdisMoveMemory(SupRate, pEid->Octet, pEid->Len);
+				*pSupRateLen = pEid->Len;
+
+				// TODO: 2004-09-14 not a good design here, cause it exclude extra rates
+				// from ScanTab. We should report as is. And filter out unsupported
+				// rates in MlmeAux.
+				// Check against the supported rates
+				// RTMPCheckRates(pAd, SupRate, pSupRateLen);
+			} else {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("PeerBeaconAndProbeRspSanity - wrong IE_SUPP_RATES (len=%d)\n",
+					  pEid->Len));
+				return FALSE;
+			}
+			break;
+
+		case IE_HT_CAP:
+			if (pEid->Len >= SIZE_HT_CAP_IE)	//Note: allow extension.!!
 			{
-				NdisMoveMemory(pHtCapability, pEid->Octet, sizeof(HT_CAPABILITY_IE));
+				NdisMoveMemory(pHtCapability, pEid->Octet,
+					       sizeof(HT_CAPABILITY_IE));
 				*pHtCapabilityLen = SIZE_HT_CAP_IE;	// Nnow we only support 26 bytes.
 
-				*(USHORT *)(&pHtCapability->HtCapInfo) = cpu2le16(*(USHORT *)(&pHtCapability->HtCapInfo));
-				*(USHORT *)(&pHtCapability->ExtHtCapInfo) = cpu2le16(*(USHORT *)(&pHtCapability->ExtHtCapInfo));
+				*(USHORT *) (&pHtCapability->HtCapInfo) =
+				    cpu2le16(*(USHORT *)
+					     (&pHtCapability->HtCapInfo));
+				*(USHORT *) (&pHtCapability->ExtHtCapInfo) =
+				    cpu2le16(*(USHORT *)
+					     (&pHtCapability->ExtHtCapInfo));
 
 				{
 					*pPreNHtCapabilityLen = 0;	// Nnow we only support 26 bytes.
 
 					Ptr = (PUCHAR) pVIE;
-					NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid, pEid->Len + 2);
+					NdisMoveMemory(Ptr + *LengthVIE,
+						       &pEid->Eid,
+						       pEid->Len + 2);
 					*LengthVIE += (pEid->Len + 2);
 				}
-			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_WARN, ("PeerBeaconAndProbeRspSanity - wrong IE_HT_CAP. pEid->Len = %d\n", pEid->Len));
+			} else {
+				DBGPRINT(RT_DEBUG_WARN,
+					 ("PeerBeaconAndProbeRspSanity - wrong IE_HT_CAP. pEid->Len = %d\n",
+					  pEid->Len));
 			}
 
-		break;
-            case IE_ADD_HT:
-			if (pEid->Len >= sizeof(ADD_HT_INFO_IE))
-			{
+			break;
+		case IE_ADD_HT:
+			if (pEid->Len >= sizeof(ADD_HT_INFO_IE)) {
 				// This IE allows extension, but we can ignore extra bytes beyond our knowledge , so only
 				// copy first sizeof(ADD_HT_INFO_IE)
-				NdisMoveMemory(AddHtInfo, pEid->Octet, sizeof(ADD_HT_INFO_IE));
+				NdisMoveMemory(AddHtInfo, pEid->Octet,
+					       sizeof(ADD_HT_INFO_IE));
 				*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;
 
 				CtrlChannel = AddHtInfo->ControlChan;
 
-				*(USHORT *)(&AddHtInfo->AddHtInfo2) = cpu2le16(*(USHORT *)(&AddHtInfo->AddHtInfo2));
-				*(USHORT *)(&AddHtInfo->AddHtInfo3) = cpu2le16(*(USHORT *)(&AddHtInfo->AddHtInfo3));
+				*(USHORT *) (&AddHtInfo->AddHtInfo2) =
+				    cpu2le16(*(USHORT *)
+					     (&AddHtInfo->AddHtInfo2));
+				*(USHORT *) (&AddHtInfo->AddHtInfo3) =
+				    cpu2le16(*(USHORT *)
+					     (&AddHtInfo->AddHtInfo3));
 
 				{
-			                Ptr = (PUCHAR) pVIE;
-			                NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid, pEid->Len + 2);
-			                *LengthVIE += (pEid->Len + 2);
+					Ptr = (PUCHAR) pVIE;
+					NdisMoveMemory(Ptr + *LengthVIE,
+						       &pEid->Eid,
+						       pEid->Len + 2);
+					*LengthVIE += (pEid->Len + 2);
 				}
-			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_WARN, ("PeerBeaconAndProbeRspSanity - wrong IE_ADD_HT. \n"));
+			} else {
+				DBGPRINT(RT_DEBUG_WARN,
+					 ("PeerBeaconAndProbeRspSanity - wrong IE_ADD_HT. \n"));
 			}
 
-		break;
-            case IE_SECONDARY_CH_OFFSET:
-			if (pEid->Len == 1)
-			{
+			break;
+		case IE_SECONDARY_CH_OFFSET:
+			if (pEid->Len == 1) {
 				*NewExtChannelOffset = pEid->Octet[0];
-			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_WARN, ("PeerBeaconAndProbeRspSanity - wrong IE_SECONDARY_CH_OFFSET. \n"));
+			} else {
+				DBGPRINT(RT_DEBUG_WARN,
+					 ("PeerBeaconAndProbeRspSanity - wrong IE_SECONDARY_CH_OFFSET. \n"));
 			}
 
-		break;
-            case IE_FH_PARM:
-                DBGPRINT(RT_DEBUG_TRACE, ("PeerBeaconAndProbeRspSanity(IE_FH_PARM) \n"));
-                break;
-
-            case IE_DS_PARM:
-                if(pEid->Len == 1)
-                {
-                    *pChannel = *pEid->Octet;
-
-					{
-						if (ChannelSanity(pAd, *pChannel) == 0)
-						{
+			break;
+		case IE_FH_PARM:
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("PeerBeaconAndProbeRspSanity(IE_FH_PARM) \n"));
+			break;
+
+		case IE_DS_PARM:
+			if (pEid->Len == 1) {
+				*pChannel = *pEid->Octet;
 
-							return FALSE;
-						}
-					}
-
-                    Sanity |= 0x4;
-                }
-                else
-                {
-                    DBGPRINT(RT_DEBUG_TRACE, ("PeerBeaconAndProbeRspSanity - wrong IE_DS_PARM (len=%d)\n",pEid->Len));
-                    return FALSE;
-                }
-                break;
-
-            case IE_CF_PARM:
-                if(pEid->Len == 6)
-                {
-                    pCfParm->bValid = TRUE;
-                    pCfParm->CfpCount = pEid->Octet[0];
-                    pCfParm->CfpPeriod = pEid->Octet[1];
-                    pCfParm->CfpMaxDuration = pEid->Octet[2] + 256 * pEid->Octet[3];
-                    pCfParm->CfpDurRemaining = pEid->Octet[4] + 256 * pEid->Octet[5];
-                }
-                else
-                {
-                    DBGPRINT(RT_DEBUG_TRACE, ("PeerBeaconAndProbeRspSanity - wrong IE_CF_PARM\n"));
-                    return FALSE;
-                }
-                break;
-
-            case IE_IBSS_PARM:
-                if(pEid->Len == 2)
-                {
-                    NdisMoveMemory(pAtimWin, pEid->Octet, pEid->Len);
-                }
-                else
-                {
-                    DBGPRINT(RT_DEBUG_TRACE, ("PeerBeaconAndProbeRspSanity - wrong IE_IBSS_PARM\n"));
-                    return FALSE;
-                }
-                break;
-
-            case IE_TIM:
-                if(INFRA_ON(pAd) && SubType == SUBTYPE_BEACON)
-                {
-                    GetTimBit((PCHAR)pEid, pAd->StaActive.Aid, &TimLen, pBcastFlag, pDtimCount, pDtimPeriod, pMessageToMe);
-                }
-                break;
-            case IE_CHANNEL_SWITCH_ANNOUNCEMENT:
-                if(pEid->Len == 3)
-                {
-                	*pNewChannel = pEid->Octet[1];	//extract new channel number
-                }
-                break;
-
-            // New for WPA
-            // CCX v2 has the same IE, we need to parse that too
-            // Wifi WMM use the same IE vale, need to parse that too
-            // case IE_WPA:
-            case IE_VENDOR_SPECIFIC:
-                // Check Broadcom/Atheros 802.11n OUI version, for HT Capability IE.
-                // This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
-                /*if (NdisEqualMemory(pEid->Octet, BROADCOM_OUI, 3) && (pEid->Len >= 4))
-                {
-			if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 30))
-			{
 				{
-					NdisMoveMemory(pHtCapability, &pEid->Octet[4], sizeof(HT_CAPABILITY_IE));
-					*pHtCapabilityLen = SIZE_HT_CAP_IE;	// Nnow we only support 26 bytes.
+					if (ChannelSanity(pAd, *pChannel) == 0) {
+
+						return FALSE;
+					}
 				}
+
+				Sanity |= 0x4;
+			} else {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("PeerBeaconAndProbeRspSanity - wrong IE_DS_PARM (len=%d)\n",
+					  pEid->Len));
+				return FALSE;
 			}
-			if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 26))
-			{
-				{
-					NdisMoveMemory(AddHtInfo, &pEid->Octet[4], sizeof(ADD_HT_INFO_IE));
-					*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;	// Nnow we only support 26 bytes.
+			break;
+
+		case IE_CF_PARM:
+			if (pEid->Len == 6) {
+				pCfParm->bValid = TRUE;
+				pCfParm->CfpCount = pEid->Octet[0];
+				pCfParm->CfpPeriod = pEid->Octet[1];
+				pCfParm->CfpMaxDuration =
+				    pEid->Octet[2] + 256 * pEid->Octet[3];
+				pCfParm->CfpDurRemaining =
+				    pEid->Octet[4] + 256 * pEid->Octet[5];
+			} else {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("PeerBeaconAndProbeRspSanity - wrong IE_CF_PARM\n"));
+				return FALSE;
+			}
+			break;
+
+		case IE_IBSS_PARM:
+			if (pEid->Len == 2) {
+				NdisMoveMemory(pAtimWin, pEid->Octet,
+					       pEid->Len);
+			} else {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("PeerBeaconAndProbeRspSanity - wrong IE_IBSS_PARM\n"));
+				return FALSE;
+			}
+			break;
+
+		case IE_TIM:
+			if (INFRA_ON(pAd) && SubType == SUBTYPE_BEACON) {
+				GetTimBit((PCHAR) pEid, pAd->StaActive.Aid,
+					  &TimLen, pBcastFlag, pDtimCount,
+					  pDtimPeriod, pMessageToMe);
+			}
+			break;
+		case IE_CHANNEL_SWITCH_ANNOUNCEMENT:
+			if (pEid->Len == 3) {
+				*pNewChannel = pEid->Octet[1];	//extract new channel number
+			}
+			break;
+
+			// New for WPA
+			// CCX v2 has the same IE, we need to parse that too
+			// Wifi WMM use the same IE vale, need to parse that too
+			// case IE_WPA:
+		case IE_VENDOR_SPECIFIC:
+			// Check Broadcom/Atheros 802.11n OUI version, for HT Capability IE.
+			// This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
+			/*if (NdisEqualMemory(pEid->Octet, BROADCOM_OUI, 3) && (pEid->Len >= 4))
+			   {
+			   if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 30))
+			   {
+			   {
+			   NdisMoveMemory(pHtCapability, &pEid->Octet[4], sizeof(HT_CAPABILITY_IE));
+			   *pHtCapabilityLen = SIZE_HT_CAP_IE;  // Nnow we only support 26 bytes.
+			   }
+			   }
+			   if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 26))
+			   {
+			   {
+			   NdisMoveMemory(AddHtInfo, &pEid->Octet[4], sizeof(ADD_HT_INFO_IE));
+			   *AddHtInfoLen = SIZE_ADD_HT_INFO_IE; // Nnow we only support 26 bytes.
+			   }
+			   }
+			   }
+			 */
+			// Check the OUI version, filter out non-standard usage
+			if (NdisEqualMemory(pEid->Octet, RALINK_OUI, 3)
+			    && (pEid->Len == 7)) {
+				//*pRalinkIe = pEid->Octet[3];
+				if (pEid->Octet[3] != 0)
+					*pRalinkIe = pEid->Octet[3];
+				else
+					*pRalinkIe = 0xf0000000;	// Set to non-zero value (can't set bit0-2) to represent this is Ralink Chip. So at linkup, we will set ralinkchip flag.
+			}
+			// This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
+
+			// Other vendors had production before IE_HT_CAP value is assigned. To backward support those old-firmware AP,
+			// Check broadcom-defiend pre-802.11nD1.0 OUI for HT related IE, including HT Capatilities IE and HT Information IE
+			else if ((*pHtCapabilityLen == 0)
+				 && NdisEqualMemory(pEid->Octet, PRE_N_HT_OUI,
+						    3) && (pEid->Len >= 4)
+				 && (pAd->OpMode == OPMODE_STA)) {
+				if ((pEid->Octet[3] == OUI_PREN_HT_CAP)
+				    && (pEid->Len >= 30)
+				    && (*pHtCapabilityLen == 0)) {
+					NdisMoveMemory(pHtCapability,
+						       &pEid->Octet[4],
+						       sizeof
+						       (HT_CAPABILITY_IE));
+					*pPreNHtCapabilityLen = SIZE_HT_CAP_IE;
+				}
+
+				if ((pEid->Octet[3] == OUI_PREN_ADD_HT)
+				    && (pEid->Len >= 26)) {
+					NdisMoveMemory(AddHtInfo,
+						       &pEid->Octet[4],
+						       sizeof(ADD_HT_INFO_IE));
+					*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;
+				}
+			} else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4)) {
+				// Copy to pVIE which will report to microsoft bssid list.
+				Ptr = (PUCHAR) pVIE;
+				NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid,
+					       pEid->Len + 2);
+				*LengthVIE += (pEid->Len + 2);
+			} else
+			    if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6)
+				&& (pEid->Len == 24)) {
+				PUCHAR ptr;
+				int i;
+
+				// parsing EDCA parameters
+				pEdcaParm->bValid = TRUE;
+				pEdcaParm->bQAck = FALSE;	// pEid->Octet[0] & 0x10;
+				pEdcaParm->bQueueRequest = FALSE;	// pEid->Octet[0] & 0x20;
+				pEdcaParm->bTxopRequest = FALSE;	// pEid->Octet[0] & 0x40;
+				pEdcaParm->EdcaUpdateCount =
+				    pEid->Octet[6] & 0x0f;
+				pEdcaParm->bAPSDCapable =
+				    (pEid->Octet[6] & 0x80) ? 1 : 0;
+				ptr = &pEid->Octet[8];
+				for (i = 0; i < 4; i++) {
+					UCHAR aci = (*ptr & 0x60) >> 5;	// b5~6 is AC INDEX
+					pEdcaParm->bACM[aci] = (((*ptr) & 0x10) == 0x10);	// b5 is ACM
+					pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;	// b0~3 is AIFSN
+					pEdcaParm->Cwmin[aci] = *(ptr + 1) & 0x0f;	// b0~4 is Cwmin
+					pEdcaParm->Cwmax[aci] = *(ptr + 1) >> 4;	// b5~8 is Cwmax
+					pEdcaParm->Txop[aci] = *(ptr + 2) + 256 * (*(ptr + 3));	// in unit of 32-us
+					ptr += 4;	// point to next AC
 				}
+			} else
+			    if (NdisEqualMemory(pEid->Octet, WME_INFO_ELEM, 6)
+				&& (pEid->Len == 7)) {
+				// parsing EDCA parameters
+				pEdcaParm->bValid = TRUE;
+				pEdcaParm->bQAck = FALSE;	// pEid->Octet[0] & 0x10;
+				pEdcaParm->bQueueRequest = FALSE;	// pEid->Octet[0] & 0x20;
+				pEdcaParm->bTxopRequest = FALSE;	// pEid->Octet[0] & 0x40;
+				pEdcaParm->EdcaUpdateCount =
+				    pEid->Octet[6] & 0x0f;
+				pEdcaParm->bAPSDCapable =
+				    (pEid->Octet[6] & 0x80) ? 1 : 0;
+
+				// use default EDCA parameter
+				pEdcaParm->bACM[QID_AC_BE] = 0;
+				pEdcaParm->Aifsn[QID_AC_BE] = 3;
+				pEdcaParm->Cwmin[QID_AC_BE] = CW_MIN_IN_BITS;
+				pEdcaParm->Cwmax[QID_AC_BE] = CW_MAX_IN_BITS;
+				pEdcaParm->Txop[QID_AC_BE] = 0;
+
+				pEdcaParm->bACM[QID_AC_BK] = 0;
+				pEdcaParm->Aifsn[QID_AC_BK] = 7;
+				pEdcaParm->Cwmin[QID_AC_BK] = CW_MIN_IN_BITS;
+				pEdcaParm->Cwmax[QID_AC_BK] = CW_MAX_IN_BITS;
+				pEdcaParm->Txop[QID_AC_BK] = 0;
+
+				pEdcaParm->bACM[QID_AC_VI] = 0;
+				pEdcaParm->Aifsn[QID_AC_VI] = 2;
+				pEdcaParm->Cwmin[QID_AC_VI] =
+				    CW_MIN_IN_BITS - 1;
+				pEdcaParm->Cwmax[QID_AC_VI] = CW_MAX_IN_BITS;
+				pEdcaParm->Txop[QID_AC_VI] = 96;	// AC_VI: 96*32us ~= 3ms
+
+				pEdcaParm->bACM[QID_AC_VO] = 0;
+				pEdcaParm->Aifsn[QID_AC_VO] = 2;
+				pEdcaParm->Cwmin[QID_AC_VO] =
+				    CW_MIN_IN_BITS - 2;
+				pEdcaParm->Cwmax[QID_AC_VO] =
+				    CW_MAX_IN_BITS - 1;
+				pEdcaParm->Txop[QID_AC_VO] = 48;	// AC_VO: 48*32us ~= 1.5ms
 			}
-                }
-				*/
-                // Check the OUI version, filter out non-standard usage
-                if (NdisEqualMemory(pEid->Octet, RALINK_OUI, 3) && (pEid->Len == 7))
-                {
-                    //*pRalinkIe = pEid->Octet[3];
-                    if (pEid->Octet[3] != 0)
-        				*pRalinkIe = pEid->Octet[3];
-        			else
-        				*pRalinkIe = 0xf0000000; // Set to non-zero value (can't set bit0-2) to represent this is Ralink Chip. So at linkup, we will set ralinkchip flag.
-                }
-		// This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
-
-                // Other vendors had production before IE_HT_CAP value is assigned. To backward support those old-firmware AP,
-                // Check broadcom-defiend pre-802.11nD1.0 OUI for HT related IE, including HT Capatilities IE and HT Information IE
-                else if ((*pHtCapabilityLen == 0) && NdisEqualMemory(pEid->Octet, PRE_N_HT_OUI, 3) && (pEid->Len >= 4) && (pAd->OpMode == OPMODE_STA))
-                {
-                    if ((pEid->Octet[3] == OUI_PREN_HT_CAP) && (pEid->Len >= 30) && (*pHtCapabilityLen == 0))
-                    {
-                        NdisMoveMemory(pHtCapability, &pEid->Octet[4], sizeof(HT_CAPABILITY_IE));
-                        *pPreNHtCapabilityLen = SIZE_HT_CAP_IE;
-                    }
-
-                    if ((pEid->Octet[3] == OUI_PREN_ADD_HT) && (pEid->Len >= 26))
-                    {
-                        NdisMoveMemory(AddHtInfo, &pEid->Octet[4], sizeof(ADD_HT_INFO_IE));
-                        *AddHtInfoLen = SIZE_ADD_HT_INFO_IE;
-                    }
-                }
-                else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))
-                {
-                    // Copy to pVIE which will report to microsoft bssid list.
-                    Ptr = (PUCHAR) pVIE;
-                    NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid, pEid->Len + 2);
-                    *LengthVIE += (pEid->Len + 2);
-                }
-                else if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6) && (pEid->Len == 24))
-                {
-                    PUCHAR ptr;
-                    int i;
-
-                    // parsing EDCA parameters
-                    pEdcaParm->bValid          = TRUE;
-                    pEdcaParm->bQAck           = FALSE; // pEid->Octet[0] & 0x10;
-                    pEdcaParm->bQueueRequest   = FALSE; // pEid->Octet[0] & 0x20;
-                    pEdcaParm->bTxopRequest    = FALSE; // pEid->Octet[0] & 0x40;
-                    pEdcaParm->EdcaUpdateCount = pEid->Octet[6] & 0x0f;
-                    pEdcaParm->bAPSDCapable    = (pEid->Octet[6] & 0x80) ? 1 : 0;
-                    ptr = &pEid->Octet[8];
-                    for (i=0; i<4; i++)
-                    {
-                        UCHAR aci = (*ptr & 0x60) >> 5; // b5~6 is AC INDEX
-                        pEdcaParm->bACM[aci]  = (((*ptr) & 0x10) == 0x10);   // b5 is ACM
-                        pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;               // b0~3 is AIFSN
-                        pEdcaParm->Cwmin[aci] = *(ptr+1) & 0x0f;             // b0~4 is Cwmin
-                        pEdcaParm->Cwmax[aci] = *(ptr+1) >> 4;               // b5~8 is Cwmax
-                        pEdcaParm->Txop[aci]  = *(ptr+2) + 256 * (*(ptr+3)); // in unit of 32-us
-                        ptr += 4; // point to next AC
-                    }
-                }
-                else if (NdisEqualMemory(pEid->Octet, WME_INFO_ELEM, 6) && (pEid->Len == 7))
-                {
-                    // parsing EDCA parameters
-                    pEdcaParm->bValid          = TRUE;
-                    pEdcaParm->bQAck           = FALSE; // pEid->Octet[0] & 0x10;
-                    pEdcaParm->bQueueRequest   = FALSE; // pEid->Octet[0] & 0x20;
-                    pEdcaParm->bTxopRequest    = FALSE; // pEid->Octet[0] & 0x40;
-                    pEdcaParm->EdcaUpdateCount = pEid->Octet[6] & 0x0f;
-                    pEdcaParm->bAPSDCapable    = (pEid->Octet[6] & 0x80) ? 1 : 0;
-
-                    // use default EDCA parameter
-                    pEdcaParm->bACM[QID_AC_BE]  = 0;
-                    pEdcaParm->Aifsn[QID_AC_BE] = 3;
-                    pEdcaParm->Cwmin[QID_AC_BE] = CW_MIN_IN_BITS;
-                    pEdcaParm->Cwmax[QID_AC_BE] = CW_MAX_IN_BITS;
-                    pEdcaParm->Txop[QID_AC_BE]  = 0;
-
-                    pEdcaParm->bACM[QID_AC_BK]  = 0;
-                    pEdcaParm->Aifsn[QID_AC_BK] = 7;
-                    pEdcaParm->Cwmin[QID_AC_BK] = CW_MIN_IN_BITS;
-                    pEdcaParm->Cwmax[QID_AC_BK] = CW_MAX_IN_BITS;
-                    pEdcaParm->Txop[QID_AC_BK]  = 0;
-
-                    pEdcaParm->bACM[QID_AC_VI]  = 0;
-                    pEdcaParm->Aifsn[QID_AC_VI] = 2;
-                    pEdcaParm->Cwmin[QID_AC_VI] = CW_MIN_IN_BITS-1;
-                    pEdcaParm->Cwmax[QID_AC_VI] = CW_MAX_IN_BITS;
-                    pEdcaParm->Txop[QID_AC_VI]  = 96;   // AC_VI: 96*32us ~= 3ms
-
-                    pEdcaParm->bACM[QID_AC_VO]  = 0;
-                    pEdcaParm->Aifsn[QID_AC_VO] = 2;
-                    pEdcaParm->Cwmin[QID_AC_VO] = CW_MIN_IN_BITS-2;
-                    pEdcaParm->Cwmax[QID_AC_VO] = CW_MAX_IN_BITS-1;
-                    pEdcaParm->Txop[QID_AC_VO]  = 48;   // AC_VO: 48*32us ~= 1.5ms
-                }
-
-
-                break;
-
-            case IE_EXT_SUPP_RATES:
-                if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES)
-                {
-                    NdisMoveMemory(ExtRate, pEid->Octet, pEid->Len);
-                    *pExtRateLen = pEid->Len;
-
-                    // TODO: 2004-09-14 not a good design here, cause it exclude extra rates
-                    // from ScanTab. We should report as is. And filter out unsupported
-                    // rates in MlmeAux.
-                    // Check against the supported rates
-                    // RTMPCheckRates(pAd, ExtRate, pExtRateLen);
-                }
-                break;
-
-            case IE_ERP:
-                if (pEid->Len == 1)
-                {
-                    *pErp = (UCHAR)pEid->Octet[0];
-                }
-                break;
-
-            case IE_AIRONET_CKIP:
-                // 0. Check Aironet IE length, it must be larger or equal to 28
-                // Cisco AP350 used length as 28
-                // Cisco AP12XX used length as 30
-                if (pEid->Len < (CKIP_NEGOTIATION_LENGTH - 2))
-                    break;
-
-                // 1. Copy CKIP flag byte to buffer for process
-                *pCkipFlag = *(pEid->Octet + 8);
-                break;
-
-            case IE_AP_TX_POWER:
-                // AP Control of Client Transmit Power
-                //0. Check Aironet IE length, it must be 6
-                if (pEid->Len != 0x06)
-                    break;
-
-                // Get cell power limit in dBm
-                if (NdisEqualMemory(pEid->Octet, CISCO_OUI, 3) == 1)
-                    *pAironetCellPowerLimit = *(pEid->Octet + 4);
-                break;
-
-            // WPA2 & 802.11i RSN
-            case IE_RSN:
-                // There is no OUI for version anymore, check the group cipher OUI before copying
-                if (RTMPEqualMemory(pEid->Octet + 2, RSN_OUI, 3))
-                {
-                    // Copy to pVIE which will report to microsoft bssid list.
-                    Ptr = (PUCHAR) pVIE;
-                    NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid, pEid->Len + 2);
-                    *LengthVIE += (pEid->Len + 2);
-                }
-                break;
-
-            default:
-                break;
-        }
-
-        Length = Length + 2 + pEid->Len;  // Eid[1] + Len[1]+ content[Len]
-        pEid = (PEID_STRUCT)((UCHAR*)pEid + 2 + pEid->Len);
-    }
 
-    // For some 11a AP. it did not have the channel EID, patch here
+			break;
+
+		case IE_EXT_SUPP_RATES:
+			if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES) {
+				NdisMoveMemory(ExtRate, pEid->Octet, pEid->Len);
+				*pExtRateLen = pEid->Len;
+
+				// TODO: 2004-09-14 not a good design here, cause it exclude extra rates
+				// from ScanTab. We should report as is. And filter out unsupported
+				// rates in MlmeAux.
+				// Check against the supported rates
+				// RTMPCheckRates(pAd, ExtRate, pExtRateLen);
+			}
+			break;
+
+		case IE_ERP:
+			if (pEid->Len == 1) {
+				*pErp = (UCHAR) pEid->Octet[0];
+			}
+			break;
+
+		case IE_AIRONET_CKIP:
+			// 0. Check Aironet IE length, it must be larger or equal to 28
+			// Cisco AP350 used length as 28
+			// Cisco AP12XX used length as 30
+			if (pEid->Len < (CKIP_NEGOTIATION_LENGTH - 2))
+				break;
+
+			// 1. Copy CKIP flag byte to buffer for process
+			*pCkipFlag = *(pEid->Octet + 8);
+			break;
+
+		case IE_AP_TX_POWER:
+			// AP Control of Client Transmit Power
+			//0. Check Aironet IE length, it must be 6
+			if (pEid->Len != 0x06)
+				break;
+
+			// Get cell power limit in dBm
+			if (NdisEqualMemory(pEid->Octet, CISCO_OUI, 3) == 1)
+				*pAironetCellPowerLimit = *(pEid->Octet + 4);
+			break;
+
+			// WPA2 & 802.11i RSN
+		case IE_RSN:
+			// There is no OUI for version anymore, check the group cipher OUI before copying
+			if (RTMPEqualMemory(pEid->Octet + 2, RSN_OUI, 3)) {
+				// Copy to pVIE which will report to microsoft bssid list.
+				Ptr = (PUCHAR) pVIE;
+				NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid,
+					       pEid->Len + 2);
+				*LengthVIE += (pEid->Len + 2);
+			}
+			break;
+
+		default:
+			break;
+		}
+
+		Length = Length + 2 + pEid->Len;	// Eid[1] + Len[1]+ content[Len]
+		pEid = (PEID_STRUCT) ((UCHAR *) pEid + 2 + pEid->Len);
+	}
+
+	// For some 11a AP. it did not have the channel EID, patch here
 	{
 		UCHAR LatchRfChannel = MsgChannel;
-		if ((pAd->LatchRfRegs.Channel > 14) && ((Sanity & 0x4) == 0))
-		{
+		if ((pAd->LatchRfRegs.Channel > 14) && ((Sanity & 0x4) == 0)) {
 			if (CtrlChannel != 0)
 				*pChannel = CtrlChannel;
 			else
@@ -737,13 +711,12 @@ BOOLEAN PeerBeaconAndProbeRspSanity(
 		}
 	}
 
-	if (Sanity != 0x7)
-	{
-		DBGPRINT(RT_DEBUG_LOUD, ("PeerBeaconAndProbeRspSanity - missing field, Sanity=0x%02x\n", Sanity));
+	if (Sanity != 0x7) {
+		DBGPRINT(RT_DEBUG_LOUD,
+			 ("PeerBeaconAndProbeRspSanity - missing field, Sanity=0x%02x\n",
+			  Sanity));
 		return FALSE;
-	}
-	else
-	{
+	} else {
 		return TRUE;
 	}
 
@@ -757,49 +730,42 @@ BOOLEAN PeerBeaconAndProbeRspSanity(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
  */
-BOOLEAN MlmeScanReqSanity(
-	IN PRTMP_ADAPTER pAd,
-	IN VOID *Msg,
-	IN ULONG MsgLen,
-	OUT UCHAR *pBssType,
-	OUT CHAR Ssid[],
-	OUT UCHAR *pSsidLen,
-	OUT UCHAR *pScanType)
+BOOLEAN MlmeScanReqSanity(IN PRTMP_ADAPTER pAd,
+			  IN VOID * Msg,
+			  IN ULONG MsgLen,
+			  OUT UCHAR * pBssType,
+			  OUT CHAR Ssid[],
+			  OUT UCHAR * pSsidLen, OUT UCHAR * pScanType)
 {
 	MLME_SCAN_REQ_STRUCT *Info;
 
-	Info = (MLME_SCAN_REQ_STRUCT *)(Msg);
+	Info = (MLME_SCAN_REQ_STRUCT *) (Msg);
 	*pBssType = Info->BssType;
 	*pSsidLen = Info->SsidLen;
 	NdisMoveMemory(Ssid, Info->Ssid, *pSsidLen);
 	*pScanType = Info->ScanType;
 
-	if ((*pBssType == BSS_INFRA || *pBssType == BSS_ADHOC || *pBssType == BSS_ANY)
-		&& (*pScanType == SCAN_ACTIVE || *pScanType == SCAN_PASSIVE
-		))
-	{
+	if ((*pBssType == BSS_INFRA || *pBssType == BSS_ADHOC
+	     || *pBssType == BSS_ANY)
+	    && (*pScanType == SCAN_ACTIVE || *pScanType == SCAN_PASSIVE)) {
 		return TRUE;
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("MlmeScanReqSanity fail - wrong BssType or ScanType\n"));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeScanReqSanity fail - wrong BssType or ScanType\n"));
 		return FALSE;
 	}
 }
 
 // IRQL = DISPATCH_LEVEL
-UCHAR ChannelSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN UCHAR channel)
+UCHAR ChannelSanity(IN PRTMP_ADAPTER pAd, IN UCHAR channel)
 {
-    int i;
+	int i;
 
-    for (i = 0; i < pAd->ChannelListNum; i ++)
-    {
-        if (channel == pAd->ChannelList[i].Channel)
-            return 1;
-    }
-    return 0;
+	for (i = 0; i < pAd->ChannelListNum; i++) {
+		if (channel == pAd->ChannelList[i].Channel)
+			return 1;
+	}
+	return 0;
 }
 
 /*
@@ -813,19 +779,17 @@ UCHAR ChannelSanity(
 
     ==========================================================================
  */
-BOOLEAN PeerDeauthSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pAddr2,
-    OUT USHORT *pReason)
+BOOLEAN PeerDeauthSanity(IN PRTMP_ADAPTER pAd,
+			 IN VOID * Msg,
+			 IN ULONG MsgLen,
+			 OUT PUCHAR pAddr2, OUT USHORT * pReason)
 {
-    PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
+	PFRAME_802_11 pFrame = (PFRAME_802_11) Msg;
 
-    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-    NdisMoveMemory(pReason, &pFrame->Octet[0], 2);
+	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+	NdisMoveMemory(pReason, &pFrame->Octet[0], 2);
 
-    return TRUE;
+	return TRUE;
 }
 
 /*
@@ -839,57 +803,46 @@ BOOLEAN PeerDeauthSanity(
 
     ==========================================================================
  */
-BOOLEAN PeerAuthSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pAddr,
-    OUT USHORT *pAlg,
-    OUT USHORT *pSeq,
-    OUT USHORT *pStatus,
-    CHAR *pChlgText)
+BOOLEAN PeerAuthSanity(IN PRTMP_ADAPTER pAd,
+		       IN VOID * Msg,
+		       IN ULONG MsgLen,
+		       OUT PUCHAR pAddr,
+		       OUT USHORT * pAlg,
+		       OUT USHORT * pSeq,
+		       OUT USHORT * pStatus, CHAR * pChlgText)
 {
-    PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
+	PFRAME_802_11 pFrame = (PFRAME_802_11) Msg;
 
-    COPY_MAC_ADDR(pAddr,   pFrame->Hdr.Addr2);
-    NdisMoveMemory(pAlg,    &pFrame->Octet[0], 2);
-    NdisMoveMemory(pSeq,    &pFrame->Octet[2], 2);
-    NdisMoveMemory(pStatus, &pFrame->Octet[4], 2);
-
-    if (*pAlg == AUTH_MODE_OPEN)
-    {
-        if (*pSeq == 1 || *pSeq == 2)
-        {
-            return TRUE;
-        }
-        else
-        {
-            DBGPRINT(RT_DEBUG_TRACE, ("PeerAuthSanity fail - wrong Seg#\n"));
-            return FALSE;
-        }
-    }
-    else if (*pAlg == AUTH_MODE_KEY)
-    {
-        if (*pSeq == 1 || *pSeq == 4)
-        {
-            return TRUE;
-        }
-        else if (*pSeq == 2 || *pSeq == 3)
-        {
-            NdisMoveMemory(pChlgText, &pFrame->Octet[8], CIPHER_TEXT_LEN);
-            return TRUE;
-        }
-        else
-        {
-            DBGPRINT(RT_DEBUG_TRACE, ("PeerAuthSanity fail - wrong Seg#\n"));
-            return FALSE;
-        }
-    }
-    else
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("PeerAuthSanity fail - wrong algorithm\n"));
-        return FALSE;
-    }
+	COPY_MAC_ADDR(pAddr, pFrame->Hdr.Addr2);
+	NdisMoveMemory(pAlg, &pFrame->Octet[0], 2);
+	NdisMoveMemory(pSeq, &pFrame->Octet[2], 2);
+	NdisMoveMemory(pStatus, &pFrame->Octet[4], 2);
+
+	if (*pAlg == AUTH_MODE_OPEN) {
+		if (*pSeq == 1 || *pSeq == 2) {
+			return TRUE;
+		} else {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("PeerAuthSanity fail - wrong Seg#\n"));
+			return FALSE;
+		}
+	} else if (*pAlg == AUTH_MODE_KEY) {
+		if (*pSeq == 1 || *pSeq == 4) {
+			return TRUE;
+		} else if (*pSeq == 2 || *pSeq == 3) {
+			NdisMoveMemory(pChlgText, &pFrame->Octet[8],
+				       CIPHER_TEXT_LEN);
+			return TRUE;
+		} else {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("PeerAuthSanity fail - wrong Seg#\n"));
+			return FALSE;
+		}
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("PeerAuthSanity fail - wrong algorithm\n"));
+		return FALSE;
+	}
 }
 
 /*
@@ -900,32 +853,27 @@ BOOLEAN PeerAuthSanity(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
  */
-BOOLEAN MlmeAuthReqSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pAddr,
-    OUT ULONG *pTimeout,
-    OUT USHORT *pAlg)
+BOOLEAN MlmeAuthReqSanity(IN PRTMP_ADAPTER pAd,
+			  IN VOID * Msg,
+			  IN ULONG MsgLen,
+			  OUT PUCHAR pAddr,
+			  OUT ULONG * pTimeout, OUT USHORT * pAlg)
 {
-    MLME_AUTH_REQ_STRUCT *pInfo;
+	MLME_AUTH_REQ_STRUCT *pInfo;
+
+	pInfo = (MLME_AUTH_REQ_STRUCT *) Msg;
+	COPY_MAC_ADDR(pAddr, pInfo->Addr);
+	*pTimeout = pInfo->Timeout;
+	*pAlg = pInfo->Alg;
 
-    pInfo  = (MLME_AUTH_REQ_STRUCT *)Msg;
-    COPY_MAC_ADDR(pAddr, pInfo->Addr);
-    *pTimeout = pInfo->Timeout;
-    *pAlg = pInfo->Alg;
-
-    if (((*pAlg == AUTH_MODE_KEY) ||(*pAlg == AUTH_MODE_OPEN)
-     	) &&
-        ((*pAddr & 0x01) == 0))
-    {
-        return TRUE;
-    }
-    else
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("MlmeAuthReqSanity fail - wrong algorithm\n"));
-        return FALSE;
-    }
+	if (((*pAlg == AUTH_MODE_KEY) || (*pAlg == AUTH_MODE_OPEN)
+	    ) && ((*pAddr & 0x01) == 0)) {
+		return TRUE;
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeAuthReqSanity fail - wrong algorithm\n"));
+		return FALSE;
+	}
 }
 
 /*
@@ -939,24 +887,22 @@ BOOLEAN MlmeAuthReqSanity(
 
     ==========================================================================
  */
-BOOLEAN MlmeAssocReqSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pApAddr,
-    OUT USHORT *pCapabilityInfo,
-    OUT ULONG *pTimeout,
-    OUT USHORT *pListenIntv)
+BOOLEAN MlmeAssocReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg,
+			   IN ULONG MsgLen,
+			   OUT PUCHAR pApAddr,
+			   OUT USHORT * pCapabilityInfo,
+			   OUT ULONG * pTimeout, OUT USHORT * pListenIntv)
 {
-    MLME_ASSOC_REQ_STRUCT *pInfo;
+	MLME_ASSOC_REQ_STRUCT *pInfo;
 
-    pInfo = (MLME_ASSOC_REQ_STRUCT *)Msg;
-    *pTimeout = pInfo->Timeout;                             // timeout
-    COPY_MAC_ADDR(pApAddr, pInfo->Addr);                   // AP address
-    *pCapabilityInfo = pInfo->CapabilityInfo;               // capability info
-    *pListenIntv = pInfo->ListenIntv;
+	pInfo = (MLME_ASSOC_REQ_STRUCT *) Msg;
+	*pTimeout = pInfo->Timeout;	// timeout
+	COPY_MAC_ADDR(pApAddr, pInfo->Addr);	// AP address
+	*pCapabilityInfo = pInfo->CapabilityInfo;	// capability info
+	*pListenIntv = pInfo->ListenIntv;
 
-    return TRUE;
+	return TRUE;
 }
 
 /*
@@ -970,19 +916,17 @@ BOOLEAN MlmeAssocReqSanity(
 
     ==========================================================================
  */
-BOOLEAN PeerDisassocSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pAddr2,
-    OUT USHORT *pReason)
+BOOLEAN PeerDisassocSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg,
+			   IN ULONG MsgLen,
+			   OUT PUCHAR pAddr2, OUT USHORT * pReason)
 {
-    PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
+	PFRAME_802_11 pFrame = (PFRAME_802_11) Msg;
 
-    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-    NdisMoveMemory(pReason, &pFrame->Octet[0], 2);
+	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+	NdisMoveMemory(pReason, &pFrame->Octet[0], 2);
 
-    return TRUE;
+	return TRUE;
 }
 
 /*
@@ -1002,28 +946,23 @@ BOOLEAN PeerDisassocSanity(
 
 	========================================================================
 */
-NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(
-    IN PBSS_ENTRY pBss)
+NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(IN PBSS_ENTRY pBss)
 {
-	NDIS_802_11_NETWORK_TYPE	NetWorkType;
-	UCHAR						rate, i;
+	NDIS_802_11_NETWORK_TYPE NetWorkType;
+	UCHAR rate, i;
 
 	NetWorkType = Ndis802_11DS;
 
-	if (pBss->Channel <= 14)
-	{
+	if (pBss->Channel <= 14) {
 		//
 		// First check support Rate.
 		//
-		for (i = 0; i < pBss->SupRateLen; i++)
-		{
-			rate = pBss->SupRate[i] & 0x7f; // Mask out basic rate set bit
-			if ((rate == 2) || (rate == 4) || (rate == 11) || (rate == 22))
-			{
+		for (i = 0; i < pBss->SupRateLen; i++) {
+			rate = pBss->SupRate[i] & 0x7f;	// Mask out basic rate set bit
+			if ((rate == 2) || (rate == 4) || (rate == 11)
+			    || (rate == 22)) {
 				continue;
-			}
-			else
-			{
+			} else {
 				//
 				// Otherwise (even rate > 108) means Ndis802_11OFDM24
 				//
@@ -1035,17 +974,13 @@ NDIS_802_11_NETWORK_TYPE NetworkTypeInUs
 		//
 		// Second check Extend Rate.
 		//
-		if (NetWorkType != Ndis802_11OFDM24)
-		{
-			for (i = 0; i < pBss->ExtRateLen; i++)
-			{
-				rate = pBss->SupRate[i] & 0x7f; // Mask out basic rate set bit
-				if ((rate == 2) || (rate == 4) || (rate == 11) || (rate == 22))
-				{
+		if (NetWorkType != Ndis802_11OFDM24) {
+			for (i = 0; i < pBss->ExtRateLen; i++) {
+				rate = pBss->SupRate[i] & 0x7f;	// Mask out basic rate set bit
+				if ((rate == 2) || (rate == 4) || (rate == 11)
+				    || (rate == 22)) {
 					continue;
-				}
-				else
-				{
+				} else {
 					//
 					// Otherwise (even rate > 108) means Ndis802_11OFDM24
 					//
@@ -1054,19 +989,16 @@ NDIS_802_11_NETWORK_TYPE NetworkTypeInUs
 				}
 			}
 		}
-	}
-	else
-	{
+	} else {
 		NetWorkType = Ndis802_11OFDM5;
 	}
 
-    if (pBss->HtCapabilityLen != 0)
-    {
-        if (NetWorkType == Ndis802_11OFDM5)
-            NetWorkType = Ndis802_11OFDM5_N;
-        else
-            NetWorkType = Ndis802_11OFDM24_N;
-    }
+	if (pBss->HtCapabilityLen != 0) {
+		if (NetWorkType == Ndis802_11OFDM5)
+			NetWorkType = Ndis802_11OFDM5_N;
+		else
+			NetWorkType = Ndis802_11OFDM24_N;
+	}
 
 	return NetWorkType;
 }
@@ -1080,170 +1012,177 @@ NDIS_802_11_NETWORK_TYPE NetworkTypeInUs
         FALSE otherwise
     ==========================================================================
  */
-BOOLEAN PeerWpaMessageSanity(
-    IN	PRTMP_ADAPTER		pAd,
-    IN	PEAPOL_PACKET		pMsg,
-    IN	ULONG				MsgLen,
-    IN	UCHAR				MsgType,
-    IN	MAC_TABLE_ENTRY		*pEntry)
+BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
+			     IN PEAPOL_PACKET pMsg,
+			     IN ULONG MsgLen,
+			     IN UCHAR MsgType, IN MAC_TABLE_ENTRY * pEntry)
 {
-	UCHAR			mic[LEN_KEY_DESC_MIC], digest[80], KEYDATA[MAX_LEN_OF_RSNIE];
-	BOOLEAN			bReplayDiff = FALSE;
-	BOOLEAN			bWPA2 = FALSE;
-	KEY_INFO		EapolKeyInfo;
-	UCHAR			GroupKeyIndex = 0;
-
+	UCHAR mic[LEN_KEY_DESC_MIC], digest[80], KEYDATA[MAX_LEN_OF_RSNIE];
+	BOOLEAN bReplayDiff = FALSE;
+	BOOLEAN bWPA2 = FALSE;
+	KEY_INFO EapolKeyInfo;
+	UCHAR GroupKeyIndex = 0;
 
 	NdisZeroMemory(mic, sizeof(mic));
 	NdisZeroMemory(digest, sizeof(digest));
 	NdisZeroMemory(KEYDATA, sizeof(KEYDATA));
-	NdisZeroMemory((PUCHAR)&EapolKeyInfo, sizeof(EapolKeyInfo));
+	NdisZeroMemory((PUCHAR) & EapolKeyInfo, sizeof(EapolKeyInfo));
 
-	NdisMoveMemory((PUCHAR)&EapolKeyInfo, (PUCHAR)&pMsg->KeyDesc.KeyInfo, sizeof(KEY_INFO));
+	NdisMoveMemory((PUCHAR) & EapolKeyInfo,
+		       (PUCHAR) & pMsg->KeyDesc.KeyInfo, sizeof(KEY_INFO));
 
-	*((USHORT *)&EapolKeyInfo) = cpu2le16(*((USHORT *)&EapolKeyInfo));
+	*((USHORT *) & EapolKeyInfo) = cpu2le16(*((USHORT *) & EapolKeyInfo));
 
 	// Choose WPA2 or not
-	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
+	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2)
+	    || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
 		bWPA2 = TRUE;
 
 	// 0. Check MsgType
-	if ((MsgType > EAPOL_GROUP_MSG_2) || (MsgType < EAPOL_PAIR_MSG_1))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("The message type is invalid(%d)! \n", MsgType));
+	if ((MsgType > EAPOL_GROUP_MSG_2) || (MsgType < EAPOL_PAIR_MSG_1)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("The message type is invalid(%d)! \n", MsgType));
 		return FALSE;
 	}
-
 	// 1. Replay counter check
 	if (MsgType == EAPOL_PAIR_MSG_1 || MsgType == EAPOL_PAIR_MSG_3 || MsgType == EAPOL_GROUP_MSG_1)	// For supplicant
-    {
-	// First validate replay counter, only accept message with larger replay counter.
+	{
+		// First validate replay counter, only accept message with larger replay counter.
 		// Let equal pass, some AP start with all zero replay counter
-		UCHAR	ZeroReplay[LEN_KEY_DESC_REPLAY];
+		UCHAR ZeroReplay[LEN_KEY_DESC_REPLAY];
 
-        NdisZeroMemory(ZeroReplay, LEN_KEY_DESC_REPLAY);
-		if ((RTMPCompareMemory(pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter, LEN_KEY_DESC_REPLAY) != 1) &&
-			(RTMPCompareMemory(pMsg->KeyDesc.ReplayCounter, ZeroReplay, LEN_KEY_DESC_REPLAY) != 0))
-	{
+		NdisZeroMemory(ZeroReplay, LEN_KEY_DESC_REPLAY);
+		if ((RTMPCompareMemory
+		     (pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter,
+		      LEN_KEY_DESC_REPLAY) != 1)
+		    &&
+		    (RTMPCompareMemory
+		     (pMsg->KeyDesc.ReplayCounter, ZeroReplay,
+		      LEN_KEY_DESC_REPLAY) != 0)) {
 			bReplayDiff = TRUE;
-	}
-	}
-	else if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_4 || MsgType == EAPOL_GROUP_MSG_2)	// For authenticator
+		}
+	} else if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_4 || MsgType == EAPOL_GROUP_MSG_2)	// For authenticator
 	{
 		// check Replay Counter coresponds to MSG from authenticator, otherwise discard
-	if (!NdisEqualMemory(pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter, LEN_KEY_DESC_REPLAY))
-	{
+		if (!NdisEqualMemory
+		    (pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter,
+		     LEN_KEY_DESC_REPLAY)) {
 			bReplayDiff = TRUE;
+		}
 	}
-	}
-
 	// Replay Counter different condition
-	if (bReplayDiff)
-	{
+	if (bReplayDiff) {
 		// send wireless event - for replay counter different
 		if (pAd->CommonCfg.bWirelessEvent)
-			RTMPSendWirelessEvent(pAd, IW_REPLAY_COUNTER_DIFF_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0);
-
-		if (MsgType < EAPOL_GROUP_MSG_1)
-		{
-		DBGPRINT(RT_DEBUG_ERROR, ("Replay Counter Different in pairwise msg %d of 4-way handshake!\n", MsgType));
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("Replay Counter Different in group msg %d of 2-way handshake!\n", (MsgType - EAPOL_PAIR_MSG_4)));
+			RTMPSendWirelessEvent(pAd,
+					      IW_REPLAY_COUNTER_DIFF_EVENT_FLAG,
+					      pEntry->Addr, pEntry->apidx, 0);
+
+		if (MsgType < EAPOL_GROUP_MSG_1) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Replay Counter Different in pairwise msg %d of 4-way handshake!\n",
+				  MsgType));
+		} else {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Replay Counter Different in group msg %d of 2-way handshake!\n",
+				  (MsgType - EAPOL_PAIR_MSG_4)));
 		}
 
-		hex_dump("Receive replay counter ", pMsg->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
-		hex_dump("Current replay counter ", pEntry->R_Counter, LEN_KEY_DESC_REPLAY);
-        return FALSE;
+		hex_dump("Receive replay counter ", pMsg->KeyDesc.ReplayCounter,
+			 LEN_KEY_DESC_REPLAY);
+		hex_dump("Current replay counter ", pEntry->R_Counter,
+			 LEN_KEY_DESC_REPLAY);
+		return FALSE;
 	}
-
 	// 2. Verify MIC except Pairwise Msg1
-	if (MsgType != EAPOL_PAIR_MSG_1)
-	{
-		UCHAR			rcvd_mic[LEN_KEY_DESC_MIC];
+	if (MsgType != EAPOL_PAIR_MSG_1) {
+		UCHAR rcvd_mic[LEN_KEY_DESC_MIC];
 
 		// Record the received MIC for check later
-		NdisMoveMemory(rcvd_mic, pMsg->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
+		NdisMoveMemory(rcvd_mic, pMsg->KeyDesc.KeyMic,
+			       LEN_KEY_DESC_MIC);
 		NdisZeroMemory(pMsg->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
 
-        if (EapolKeyInfo.KeyDescVer == DESC_TYPE_TKIP)	// TKIP
-        {
-            HMAC_MD5(pEntry->PTK, LEN_EAP_MICK, (PUCHAR)pMsg, MsgLen, mic, MD5_DIGEST_SIZE);
-        }
-        else if (EapolKeyInfo.KeyDescVer == DESC_TYPE_AES)	// AES
-        {
-            HMAC_SHA1(pEntry->PTK, LEN_EAP_MICK, (PUCHAR)pMsg, MsgLen, digest, SHA1_DIGEST_SIZE);
-            NdisMoveMemory(mic, digest, LEN_KEY_DESC_MIC);
-        }
+		if (EapolKeyInfo.KeyDescVer == DESC_TYPE_TKIP)	// TKIP
+		{
+			HMAC_MD5(pEntry->PTK, LEN_EAP_MICK, (PUCHAR) pMsg,
+				 MsgLen, mic, MD5_DIGEST_SIZE);
+		} else if (EapolKeyInfo.KeyDescVer == DESC_TYPE_AES)	// AES
+		{
+			HMAC_SHA1(pEntry->PTK, LEN_EAP_MICK, (PUCHAR) pMsg,
+				  MsgLen, digest, SHA1_DIGEST_SIZE);
+			NdisMoveMemory(mic, digest, LEN_KEY_DESC_MIC);
+		}
 
-        if (!NdisEqualMemory(rcvd_mic, mic, LEN_KEY_DESC_MIC))
-        {
+		if (!NdisEqualMemory(rcvd_mic, mic, LEN_KEY_DESC_MIC)) {
 			// send wireless event - for MIC different
 			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_MIC_DIFF_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0);
-
-			if (MsgType < EAPOL_GROUP_MSG_1)
-			{
-		DBGPRINT(RT_DEBUG_ERROR, ("MIC Different in pairwise msg %d of 4-way handshake!\n", MsgType));
-			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_ERROR, ("MIC Different in group msg %d of 2-way handshake!\n", (MsgType - EAPOL_PAIR_MSG_4)));
+				RTMPSendWirelessEvent(pAd,
+						      IW_MIC_DIFF_EVENT_FLAG,
+						      pEntry->Addr,
+						      pEntry->apidx, 0);
+
+			if (MsgType < EAPOL_GROUP_MSG_1) {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("MIC Different in pairwise msg %d of 4-way handshake!\n",
+					  MsgType));
+			} else {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("MIC Different in group msg %d of 2-way handshake!\n",
+					  (MsgType - EAPOL_PAIR_MSG_4)));
 			}
 
 			hex_dump("Received MIC", rcvd_mic, LEN_KEY_DESC_MIC);
 			hex_dump("Desired  MIC", mic, LEN_KEY_DESC_MIC);
 
 			return FALSE;
-        }
+		}
 	}
-
 	// 1. Decrypt the Key Data field if GTK is included.
 	// 2. Extract the context of the Key Data field if it exist.
 	// The field in pairwise_msg_2_WPA1(WPA2) & pairwise_msg_3_WPA1 is clear.
 	// The field in group_msg_1_WPA1(WPA2) & pairwise_msg_3_WPA2 is encrypted.
-	if (CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyDataLen) > 0)
-	{
+	if (CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyDataLen) > 0) {
 		// Decrypt this field
-		if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2) || (MsgType == EAPOL_GROUP_MSG_1))
-		{
-			if(
-				(EapolKeyInfo.KeyDescVer == DESC_TYPE_AES))
-			{
+		if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2)
+		    || (MsgType == EAPOL_GROUP_MSG_1)) {
+			if ((EapolKeyInfo.KeyDescVer == DESC_TYPE_AES)) {
 				// AES
 				AES_GTK_KEY_UNWRAP(&pEntry->PTK[16], KEYDATA,
-									CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyDataLen),
-									pMsg->KeyDesc.KeyData);
-			}
-			else
-			{
-				INT	i;
-				UCHAR   Key[32];
+						   CONV_ARRARY_TO_UINT16(pMsg->
+									 KeyDesc.
+									 KeyDataLen),
+						   pMsg->KeyDesc.KeyData);
+			} else {
+				INT i;
+				UCHAR Key[32];
 				// Decrypt TKIP GTK
 				// Construct 32 bytes RC4 Key
 				NdisMoveMemory(Key, pMsg->KeyDesc.KeyIv, 16);
 				NdisMoveMemory(&Key[16], &pEntry->PTK[16], 16);
-				ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, Key, 32);
+				ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, Key,
+					     32);
 				//discard first 256 bytes
-				for(i = 0; i < 256; i++)
-					ARCFOUR_BYTE(&pAd->PrivateInfo.WEPCONTEXT);
+				for (i = 0; i < 256; i++)
+					ARCFOUR_BYTE(&pAd->PrivateInfo.
+						     WEPCONTEXT);
 				// Decrypt GTK. Becareful, there is no ICV to check the result is correct or not
-				ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, KEYDATA,
-								pMsg->KeyDesc.KeyData,
-								CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyDataLen));
+				ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT,
+						KEYDATA, pMsg->KeyDesc.KeyData,
+						CONV_ARRARY_TO_UINT16(pMsg->
+								      KeyDesc.
+								      KeyDataLen));
 			}
 
 			if (!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1))
 				GroupKeyIndex = EapolKeyInfo.KeyIndex;
 
-		}
-		else if ((MsgType == EAPOL_PAIR_MSG_2) || (MsgType == EAPOL_PAIR_MSG_3 && !bWPA2))
-		{
-			NdisMoveMemory(KEYDATA, pMsg->KeyDesc.KeyData, CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyDataLen));
-		}
-		else
-		{
+		} else if ((MsgType == EAPOL_PAIR_MSG_2)
+			   || (MsgType == EAPOL_PAIR_MSG_3 && !bWPA2)) {
+			NdisMoveMemory(KEYDATA, pMsg->KeyDesc.KeyData,
+				       CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.
+							     KeyDataLen));
+		} else {
 
 			return TRUE;
 		}
@@ -1253,9 +1192,10 @@ BOOLEAN PeerWpaMessageSanity(
 		// 2. verify KDE format for pairwise_msg_3_WPA2, group_msg_1_WPA2
 		// 3. update shared key for pairwise_msg_3_WPA2, group_msg_1_WPA1(WPA2)
 		if (!RTMPParseEapolKeyData(pAd, KEYDATA,
-								  CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyDataLen),
-								  GroupKeyIndex, MsgType, bWPA2, pEntry))
-		{
+					   CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.
+								 KeyDataLen),
+					   GroupKeyIndex, MsgType, bWPA2,
+					   pEntry)) {
 			return FALSE;
 		}
 	}
--- a/drivers/staging/rt2860/common/cmm_sync.c
+++ b/drivers/staging/rt2860/common/cmm_sync.c
@@ -37,46 +37,61 @@
 #include "../rt_config.h"
 
 // 2.4 Ghz channel plan index in the TxPower arrays.
-#define	BG_BAND_REGION_0_START	0			// 1,2,3,4,5,6,7,8,9,10,11
+#define	BG_BAND_REGION_0_START	0	// 1,2,3,4,5,6,7,8,9,10,11
 #define	BG_BAND_REGION_0_SIZE	11
-#define	BG_BAND_REGION_1_START	0			// 1,2,3,4,5,6,7,8,9,10,11,12,13
+#define	BG_BAND_REGION_1_START	0	// 1,2,3,4,5,6,7,8,9,10,11,12,13
 #define	BG_BAND_REGION_1_SIZE	13
-#define	BG_BAND_REGION_2_START	9			// 10,11
+#define	BG_BAND_REGION_2_START	9	// 10,11
 #define	BG_BAND_REGION_2_SIZE	2
-#define	BG_BAND_REGION_3_START	9			// 10,11,12,13
+#define	BG_BAND_REGION_3_START	9	// 10,11,12,13
 #define	BG_BAND_REGION_3_SIZE	4
-#define	BG_BAND_REGION_4_START	13			// 14
+#define	BG_BAND_REGION_4_START	13	// 14
 #define	BG_BAND_REGION_4_SIZE	1
-#define	BG_BAND_REGION_5_START	0			// 1,2,3,4,5,6,7,8,9,10,11,12,13,14
+#define	BG_BAND_REGION_5_START	0	// 1,2,3,4,5,6,7,8,9,10,11,12,13,14
 #define	BG_BAND_REGION_5_SIZE	14
-#define	BG_BAND_REGION_6_START	2			// 3,4,5,6,7,8,9
+#define	BG_BAND_REGION_6_START	2	// 3,4,5,6,7,8,9
 #define	BG_BAND_REGION_6_SIZE	7
-#define	BG_BAND_REGION_7_START	4			// 5,6,7,8,9,10,11,12,13
+#define	BG_BAND_REGION_7_START	4	// 5,6,7,8,9,10,11,12,13
 #define	BG_BAND_REGION_7_SIZE	9
-#define	BG_BAND_REGION_31_START	0			// 1,2,3,4,5,6,7,8,9,10,11,12,13,14
+#define	BG_BAND_REGION_31_START	0	// 1,2,3,4,5,6,7,8,9,10,11,12,13,14
 #define	BG_BAND_REGION_31_SIZE	14
 
 // 5 Ghz channel plan index in the TxPower arrays.
-UCHAR A_BAND_REGION_0_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165};
-UCHAR A_BAND_REGION_1_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140};
-UCHAR A_BAND_REGION_2_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64};
-UCHAR A_BAND_REGION_3_CHANNEL_LIST[]={52, 56, 60, 64, 149, 153, 157, 161};
-UCHAR A_BAND_REGION_4_CHANNEL_LIST[]={149, 153, 157, 161, 165};
-UCHAR A_BAND_REGION_5_CHANNEL_LIST[]={149, 153, 157, 161};
-UCHAR A_BAND_REGION_6_CHANNEL_LIST[]={36, 40, 44, 48};
-UCHAR A_BAND_REGION_7_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165, 169, 173};
-UCHAR A_BAND_REGION_8_CHANNEL_LIST[]={52, 56, 60, 64};
-UCHAR A_BAND_REGION_9_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 132, 136, 140, 149, 153, 157, 161, 165};
-UCHAR A_BAND_REGION_10_CHANNEL_LIST[]={36, 40, 44, 48, 149, 153, 157, 161, 165};
-UCHAR A_BAND_REGION_11_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 149, 153, 157, 161};
-UCHAR A_BAND_REGION_12_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140};
-UCHAR A_BAND_REGION_13_CHANNEL_LIST[]={52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161};
-UCHAR A_BAND_REGION_14_CHANNEL_LIST[]={36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 136, 140, 149, 153, 157, 161, 165};
-UCHAR A_BAND_REGION_15_CHANNEL_LIST[]={149, 153, 157, 161, 165, 169, 173};
-
+UCHAR A_BAND_REGION_0_CHANNEL_LIST[] =
+    { 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165 };
+UCHAR A_BAND_REGION_1_CHANNEL_LIST[] =
+    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128,
+132, 136, 140 };
+UCHAR A_BAND_REGION_2_CHANNEL_LIST[] = { 36, 40, 44, 48, 52, 56, 60, 64 };
+UCHAR A_BAND_REGION_3_CHANNEL_LIST[] = { 52, 56, 60, 64, 149, 153, 157, 161 };
+UCHAR A_BAND_REGION_4_CHANNEL_LIST[] = { 149, 153, 157, 161, 165 };
+UCHAR A_BAND_REGION_5_CHANNEL_LIST[] = { 149, 153, 157, 161 };
+UCHAR A_BAND_REGION_6_CHANNEL_LIST[] = { 36, 40, 44, 48 };
+UCHAR A_BAND_REGION_7_CHANNEL_LIST[] =
+    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128,
+132, 136, 140, 149, 153, 157, 161, 165, 169, 173 };
+UCHAR A_BAND_REGION_8_CHANNEL_LIST[] = { 52, 56, 60, 64 };
+UCHAR A_BAND_REGION_9_CHANNEL_LIST[] =
+    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 132, 136, 140,
+149, 153, 157, 161, 165 };
+UCHAR A_BAND_REGION_10_CHANNEL_LIST[] =
+    { 36, 40, 44, 48, 149, 153, 157, 161, 165 };
+UCHAR A_BAND_REGION_11_CHANNEL_LIST[] =
+    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 149, 153,
+157, 161 };
+UCHAR A_BAND_REGION_12_CHANNEL_LIST[] =
+    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128,
+132, 136, 140 };
+UCHAR A_BAND_REGION_13_CHANNEL_LIST[] =
+    { 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140,
+149, 153, 157, 161 };
+UCHAR A_BAND_REGION_14_CHANNEL_LIST[] =
+    { 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 136, 140, 149,
+153, 157, 161, 165 };
+UCHAR A_BAND_REGION_15_CHANNEL_LIST[] = { 149, 153, 157, 161, 165, 169, 173 };
 
 //BaSizeArray follows the 802.11n definition as MaxRxFactor.  2^(13+factor) bytes. When factor =0, it's about Ba buffer size =8.
-UCHAR BaSizeArray[4] = {8,16,32,64};
+UCHAR BaSizeArray[4] = { 8, 16, 32, 64 };
 
 /*
 	==========================================================================
@@ -90,170 +105,243 @@ UCHAR BaSizeArray[4] = {8,16,32,64};
 
 	==========================================================================
  */
-VOID BuildChannelList(
-	IN PRTMP_ADAPTER pAd)
+VOID BuildChannelList(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR i, j, index=0, num=0;
-	PUCHAR	pChannelList = NULL;
+	UCHAR i, j, index = 0, num = 0;
+	PUCHAR pChannelList = NULL;
 
-	NdisZeroMemory(pAd->ChannelList, MAX_NUM_OF_CHANNELS * sizeof(CHANNEL_TX_POWER));
+	NdisZeroMemory(pAd->ChannelList,
+		       MAX_NUM_OF_CHANNELS * sizeof(CHANNEL_TX_POWER));
 
 	// if not 11a-only mode, channel list starts from 2.4Ghz band
 	if ((pAd->CommonCfg.PhyMode != PHY_11A)
-		&& (pAd->CommonCfg.PhyMode != PHY_11AN_MIXED) && (pAd->CommonCfg.PhyMode != PHY_11N_5G)
-	)
-	{
-		switch (pAd->CommonCfg.CountryRegion  & 0x7f)
-		{
-			case REGION_0_BG_BAND:	// 1 -11
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_0_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_0_SIZE);
-				index += BG_BAND_REGION_0_SIZE;
-				break;
-			case REGION_1_BG_BAND:	// 1 - 13
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_1_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_1_SIZE);
-				index += BG_BAND_REGION_1_SIZE;
-				break;
-			case REGION_2_BG_BAND:	// 10 - 11
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_2_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_2_SIZE);
-				index += BG_BAND_REGION_2_SIZE;
-				break;
-			case REGION_3_BG_BAND:	// 10 - 13
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_3_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_3_SIZE);
-				index += BG_BAND_REGION_3_SIZE;
-				break;
-			case REGION_4_BG_BAND:	// 14
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_4_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_4_SIZE);
-				index += BG_BAND_REGION_4_SIZE;
-				break;
-			case REGION_5_BG_BAND:	// 1 - 14
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_5_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_5_SIZE);
-				index += BG_BAND_REGION_5_SIZE;
-				break;
-			case REGION_6_BG_BAND:	// 3 - 9
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_6_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_6_SIZE);
-				index += BG_BAND_REGION_6_SIZE;
-				break;
-			case REGION_7_BG_BAND:  // 5 - 13
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_7_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_7_SIZE);
-				index += BG_BAND_REGION_7_SIZE;
-				break;
-			case REGION_31_BG_BAND:	// 1 - 14
-				NdisMoveMemory(&pAd->ChannelList[index], &pAd->TxPower[BG_BAND_REGION_31_START], sizeof(CHANNEL_TX_POWER) * BG_BAND_REGION_31_SIZE);
-				index += BG_BAND_REGION_31_SIZE;
-				break;
-			default:            // Error. should never happen
-				break;
+	    && (pAd->CommonCfg.PhyMode != PHY_11AN_MIXED)
+	    && (pAd->CommonCfg.PhyMode != PHY_11N_5G)
+	    ) {
+		switch (pAd->CommonCfg.CountryRegion & 0x7f) {
+		case REGION_0_BG_BAND:	// 1 -11
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_0_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_0_SIZE);
+			index += BG_BAND_REGION_0_SIZE;
+			break;
+		case REGION_1_BG_BAND:	// 1 - 13
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_1_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_1_SIZE);
+			index += BG_BAND_REGION_1_SIZE;
+			break;
+		case REGION_2_BG_BAND:	// 10 - 11
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_2_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_2_SIZE);
+			index += BG_BAND_REGION_2_SIZE;
+			break;
+		case REGION_3_BG_BAND:	// 10 - 13
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_3_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_3_SIZE);
+			index += BG_BAND_REGION_3_SIZE;
+			break;
+		case REGION_4_BG_BAND:	// 14
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_4_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_4_SIZE);
+			index += BG_BAND_REGION_4_SIZE;
+			break;
+		case REGION_5_BG_BAND:	// 1 - 14
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_5_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_5_SIZE);
+			index += BG_BAND_REGION_5_SIZE;
+			break;
+		case REGION_6_BG_BAND:	// 3 - 9
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_6_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_6_SIZE);
+			index += BG_BAND_REGION_6_SIZE;
+			break;
+		case REGION_7_BG_BAND:	// 5 - 13
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_7_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_7_SIZE);
+			index += BG_BAND_REGION_7_SIZE;
+			break;
+		case REGION_31_BG_BAND:	// 1 - 14
+			NdisMoveMemory(&pAd->ChannelList[index],
+				       &pAd->TxPower[BG_BAND_REGION_31_START],
+				       sizeof(CHANNEL_TX_POWER) *
+				       BG_BAND_REGION_31_SIZE);
+			index += BG_BAND_REGION_31_SIZE;
+			break;
+		default:	// Error. should never happen
+			break;
 		}
-		for (i=0; i<index; i++)
+		for (i = 0; i < index; i++)
 			pAd->ChannelList[i].MaxTxPwr = 20;
 	}
 
-	if ((pAd->CommonCfg.PhyMode == PHY_11A) || (pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED)
-		|| (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) || (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED)
-		|| (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED) || (pAd->CommonCfg.PhyMode == PHY_11N_5G)
-	)
-	{
-		switch (pAd->CommonCfg.CountryRegionForABand & 0x7f)
-		{
-			case REGION_0_A_BAND:
-				num = sizeof(A_BAND_REGION_0_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_0_CHANNEL_LIST;
-				break;
-			case REGION_1_A_BAND:
-				num = sizeof(A_BAND_REGION_1_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_1_CHANNEL_LIST;
-				break;
-			case REGION_2_A_BAND:
-				num = sizeof(A_BAND_REGION_2_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_2_CHANNEL_LIST;
-				break;
-			case REGION_3_A_BAND:
-				num = sizeof(A_BAND_REGION_3_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_3_CHANNEL_LIST;
-				break;
-			case REGION_4_A_BAND:
-				num = sizeof(A_BAND_REGION_4_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_4_CHANNEL_LIST;
-				break;
-			case REGION_5_A_BAND:
-				num = sizeof(A_BAND_REGION_5_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_5_CHANNEL_LIST;
-				break;
-			case REGION_6_A_BAND:
-				num = sizeof(A_BAND_REGION_6_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_6_CHANNEL_LIST;
-				break;
-			case REGION_7_A_BAND:
-				num = sizeof(A_BAND_REGION_7_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_7_CHANNEL_LIST;
-				break;
-			case REGION_8_A_BAND:
-				num = sizeof(A_BAND_REGION_8_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_8_CHANNEL_LIST;
-				break;
-			case REGION_9_A_BAND:
-				num = sizeof(A_BAND_REGION_9_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_9_CHANNEL_LIST;
-				break;
-
-			case REGION_10_A_BAND:
-				num = sizeof(A_BAND_REGION_10_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_10_CHANNEL_LIST;
-				break;
-
-			case REGION_11_A_BAND:
-				num = sizeof(A_BAND_REGION_11_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_11_CHANNEL_LIST;
-				break;
-			case REGION_12_A_BAND:
-				num = sizeof(A_BAND_REGION_12_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_12_CHANNEL_LIST;
-				break;
-			case REGION_13_A_BAND:
-				num = sizeof(A_BAND_REGION_13_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_13_CHANNEL_LIST;
-				break;
-			case REGION_14_A_BAND:
-				num = sizeof(A_BAND_REGION_14_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_14_CHANNEL_LIST;
-				break;
-			case REGION_15_A_BAND:
-				num = sizeof(A_BAND_REGION_15_CHANNEL_LIST)/sizeof(UCHAR);
-				pChannelList = A_BAND_REGION_15_CHANNEL_LIST;
-				break;
-			default:            // Error. should never happen
-				DBGPRINT(RT_DEBUG_WARN,("countryregion=%d not support", pAd->CommonCfg.CountryRegionForABand));
-				break;
+	if ((pAd->CommonCfg.PhyMode == PHY_11A)
+	    || (pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED)
+	    || (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED)
+	    || (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED)
+	    || (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED)
+	    || (pAd->CommonCfg.PhyMode == PHY_11N_5G)
+	    ) {
+		switch (pAd->CommonCfg.CountryRegionForABand & 0x7f) {
+		case REGION_0_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_0_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_0_CHANNEL_LIST;
+			break;
+		case REGION_1_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_1_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_1_CHANNEL_LIST;
+			break;
+		case REGION_2_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_2_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_2_CHANNEL_LIST;
+			break;
+		case REGION_3_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_3_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_3_CHANNEL_LIST;
+			break;
+		case REGION_4_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_4_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_4_CHANNEL_LIST;
+			break;
+		case REGION_5_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_5_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_5_CHANNEL_LIST;
+			break;
+		case REGION_6_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_6_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_6_CHANNEL_LIST;
+			break;
+		case REGION_7_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_7_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_7_CHANNEL_LIST;
+			break;
+		case REGION_8_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_8_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_8_CHANNEL_LIST;
+			break;
+		case REGION_9_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_9_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_9_CHANNEL_LIST;
+			break;
+
+		case REGION_10_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_10_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_10_CHANNEL_LIST;
+			break;
+
+		case REGION_11_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_11_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_11_CHANNEL_LIST;
+			break;
+		case REGION_12_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_12_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_12_CHANNEL_LIST;
+			break;
+		case REGION_13_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_13_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_13_CHANNEL_LIST;
+			break;
+		case REGION_14_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_14_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_14_CHANNEL_LIST;
+			break;
+		case REGION_15_A_BAND:
+			num =
+			    sizeof(A_BAND_REGION_15_CHANNEL_LIST) /
+			    sizeof(UCHAR);
+			pChannelList = A_BAND_REGION_15_CHANNEL_LIST;
+			break;
+		default:	// Error. should never happen
+			DBGPRINT(RT_DEBUG_WARN,
+				 ("countryregion=%d not support",
+				  pAd->CommonCfg.CountryRegionForABand));
+			break;
 		}
 
-		if (num != 0)
-		{
-			UCHAR RadarCh[15]={52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140};
-			for (i=0; i<num; i++)
-			{
-				for (j=0; j<MAX_NUM_OF_CHANNELS; j++)
-				{
-					if (pChannelList[i] == pAd->TxPower[j].Channel)
-						NdisMoveMemory(&pAd->ChannelList[index+i], &pAd->TxPower[j], sizeof(CHANNEL_TX_POWER));
-					}
-				for (j=0; j<15; j++)
-				{
+		if (num != 0) {
+			UCHAR RadarCh[15] =
+			    { 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124,
+		    128, 132, 136, 140 };
+			for (i = 0; i < num; i++) {
+				for (j = 0; j < MAX_NUM_OF_CHANNELS; j++) {
+					if (pChannelList[i] ==
+					    pAd->TxPower[j].Channel)
+						NdisMoveMemory(&pAd->
+							       ChannelList[index
+									   + i],
+							       &pAd->TxPower[j],
+							       sizeof
+							       (CHANNEL_TX_POWER));
+				}
+				for (j = 0; j < 15; j++) {
 					if (pChannelList[i] == RadarCh[j])
-						pAd->ChannelList[index+i].DfsReq = TRUE;
+						pAd->ChannelList[index +
+								 i].DfsReq =
+						    TRUE;
 				}
-				pAd->ChannelList[index+i].MaxTxPwr = 20;
+				pAd->ChannelList[index + i].MaxTxPwr = 20;
 			}
 			index += num;
 		}
 	}
 
 	pAd->ChannelListNum = index;
-	DBGPRINT(RT_DEBUG_TRACE,("country code=%d/%d, RFIC=%d, PHY mode=%d, support %d channels\n",
-		pAd->CommonCfg.CountryRegion, pAd->CommonCfg.CountryRegionForABand, pAd->RfIcType, pAd->CommonCfg.PhyMode, pAd->ChannelListNum));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("country code=%d/%d, RFIC=%d, PHY mode=%d, support %d channels\n",
+		  pAd->CommonCfg.CountryRegion,
+		  pAd->CommonCfg.CountryRegionForABand, pAd->RfIcType,
+		  pAd->CommonCfg.PhyMode, pAd->ChannelListNum));
 #ifdef DBG
-	for (i=0;i<pAd->ChannelListNum;i++)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE,("BuildChannel # %d :: Pwr0 = %d, Pwr1 =%d, \n ", pAd->ChannelList[i].Channel, pAd->ChannelList[i].Power, pAd->ChannelList[i].Power2));
+	for (i = 0; i < pAd->ChannelListNum; i++) {
+		DBGPRINT_RAW(RT_DEBUG_TRACE,
+			     ("BuildChannel # %d :: Pwr0 = %d, Pwr1 =%d, \n ",
+			      pAd->ChannelList[i].Channel,
+			      pAd->ChannelList[i].Power,
+			      pAd->ChannelList[i].Power2));
 	}
 #endif
 }
@@ -271,8 +359,7 @@ VOID BuildChannelList(
 
 	==========================================================================
  */
-UCHAR FirstChannel(
-	IN PRTMP_ADAPTER pAd)
+UCHAR FirstChannel(IN PRTMP_ADAPTER pAd)
 {
 	return pAd->ChannelList[0].Channel;
 }
@@ -288,19 +375,16 @@ UCHAR FirstChannel(
 		return 0 if no more next channel
 	==========================================================================
  */
-UCHAR NextChannel(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR channel)
+UCHAR NextChannel(IN PRTMP_ADAPTER pAd, IN UCHAR channel)
 {
 	int i;
 	UCHAR next_channel = 0;
 
 	for (i = 0; i < (pAd->ChannelListNum - 1); i++)
-		if (channel == pAd->ChannelList[i].Channel)
-		{
-			next_channel = pAd->ChannelList[i+1].Channel;
+		if (channel == pAd->ChannelList[i].Channel) {
+			next_channel = pAd->ChannelList[i + 1].Channel;
 			break;
-	}
+		}
 	return next_channel;
 }
 
@@ -324,16 +408,15 @@ UCHAR NextChannel(
 		the minimum value or next lower value.
 	==========================================================================
  */
-VOID ChangeToCellPowerLimit(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR         AironetCellPowerLimit)
+VOID ChangeToCellPowerLimit(IN PRTMP_ADAPTER pAd,
+			    IN UCHAR AironetCellPowerLimit)
 {
 	//valud 0xFF means that hasn't found power limit information
 	//from the AP's Beacon/Probe response.
 	if (AironetCellPowerLimit == 0xFF)
 		return;
 
-	if (AironetCellPowerLimit < 6) //Used Lowest Power Percentage.
+	if (AironetCellPowerLimit < 6)	//Used Lowest Power Percentage.
 		pAd->CommonCfg.TxPowerPercentage = 6;
 	else if (AironetCellPowerLimit < 9)
 		pAd->CommonCfg.TxPowerPercentage = 10;
@@ -344,45 +427,40 @@ VOID ChangeToCellPowerLimit(
 	else if (AironetCellPowerLimit < 15)
 		pAd->CommonCfg.TxPowerPercentage = 75;
 	else
-		pAd->CommonCfg.TxPowerPercentage = 100; //else used maximum
+		pAd->CommonCfg.TxPowerPercentage = 100;	//else used maximum
 
 	if (pAd->CommonCfg.TxPowerPercentage > pAd->CommonCfg.TxPowerDefault)
-		pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;
+		pAd->CommonCfg.TxPowerPercentage =
+		    pAd->CommonCfg.TxPowerDefault;
 
 }
 
-CHAR	ConvertToRssi(
-	IN PRTMP_ADAPTER pAd,
-	IN	CHAR			Rssi,
-	IN  UCHAR   RssiNumber)
+CHAR ConvertToRssi(IN PRTMP_ADAPTER pAd, IN CHAR Rssi, IN UCHAR RssiNumber)
 {
-	UCHAR	RssiOffset, LNAGain;
+	UCHAR RssiOffset, LNAGain;
 
 	// Rssi equals to zero should be an invalid value
 	if (Rssi == 0)
 		return -99;
 
 	LNAGain = GET_LNA_GAIN(pAd);
-    if (pAd->LatchRfRegs.Channel > 14)
-    {
-        if (RssiNumber == 0)
+	if (pAd->LatchRfRegs.Channel > 14) {
+		if (RssiNumber == 0)
 			RssiOffset = pAd->ARssiOffset0;
 		else if (RssiNumber == 1)
 			RssiOffset = pAd->ARssiOffset1;
 		else
 			RssiOffset = pAd->ARssiOffset2;
-    }
-    else
-    {
-        if (RssiNumber == 0)
+	} else {
+		if (RssiNumber == 0)
 			RssiOffset = pAd->BGRssiOffset0;
 		else if (RssiNumber == 1)
 			RssiOffset = pAd->BGRssiOffset1;
 		else
 			RssiOffset = pAd->BGRssiOffset2;
-    }
+	}
 
-    return (-12 - RssiOffset - LNAGain - Rssi);
+	return (-12 - RssiOffset - LNAGain - Rssi);
 }
 
 /*
@@ -391,44 +469,44 @@ CHAR	ConvertToRssi(
 		Scan next channel
 	==========================================================================
  */
-VOID ScanNextChannel(
-	IN PRTMP_ADAPTER pAd)
+VOID ScanNextChannel(IN PRTMP_ADAPTER pAd)
 {
-	HEADER_802_11   Hdr80211;
-	PUCHAR          pOutBuffer = NULL;
-	NDIS_STATUS     NStatus;
-	ULONG           FrameLen = 0;
-	UCHAR           SsidLen = 0, ScanType = pAd->MlmeAux.ScanType, BBPValue = 0;
-	USHORT          Status;
-	PHEADER_802_11  pHdr80211;
-	UINT			ScanTimeIn5gChannel = SHORT_CHANNEL_TIME;
+	HEADER_802_11 Hdr80211;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+	ULONG FrameLen = 0;
+	UCHAR SsidLen = 0, ScanType = pAd->MlmeAux.ScanType, BBPValue = 0;
+	USHORT Status;
+	PHEADER_802_11 pHdr80211;
+	UINT ScanTimeIn5gChannel = SHORT_CHANNEL_TIME;
 
 	{
-	if (MONITOR_ON(pAd))
-		return;
+		if (MONITOR_ON(pAd))
+			return;
 	}
 
-
-	if (pAd->MlmeAux.Channel == 0)
-	{
+	if (pAd->MlmeAux.Channel == 0) {
 		if ((pAd->CommonCfg.BBPCurrentBW == BW_40)
-			&& (INFRA_ON(pAd)
-				|| (pAd->OpMode == OPMODE_AP))
-			)
-		{
-			AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
+		    && (INFRA_ON(pAd)
+			|| (pAd->OpMode == OPMODE_AP))
+		    ) {
+			AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel,
+					  FALSE);
 			AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 			BBPValue &= (~0x18);
 			BBPValue |= 0x10;
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-			DBGPRINT(RT_DEBUG_TRACE, ("SYNC - End of SCAN, restore to 40MHz channel %d, Total BSS[%02d]\n",pAd->CommonCfg.CentralChannel, pAd->ScanTab.BssNr));
-		}
-		else
-		{
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("SYNC - End of SCAN, restore to 40MHz channel %d, Total BSS[%02d]\n",
+				  pAd->CommonCfg.CentralChannel,
+				  pAd->ScanTab.BssNr));
+		} else {
 			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
 			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-			DBGPRINT(RT_DEBUG_TRACE, ("SYNC - End of SCAN, restore to channel %d, Total BSS[%02d]\n",pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("SYNC - End of SCAN, restore to channel %d, Total BSS[%02d]\n",
+				  pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
 		}
 
 		{
@@ -437,20 +515,29 @@ VOID ScanNextChannel(
 			// Send an NULL data with turned PSM bit on to current associated AP before SCAN progress.
 			// Now, we need to send an NULL data with turned PSM bit off to AP, when scan progress done
 			//
-			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) && (INFRA_ON(pAd)))
-			{
-				NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);
-				if (NStatus	== NDIS_STATUS_SUCCESS)
-				{
+			if (OPSTATUS_TEST_FLAG
+			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
+			    && (INFRA_ON(pAd))) {
+				NStatus =
+				    MlmeAllocateMemory(pAd,
+						       (PVOID) & pOutBuffer);
+				if (NStatus == NDIS_STATUS_SUCCESS) {
 					pHdr80211 = (PHEADER_802_11) pOutBuffer;
-					MgtMacHeaderInit(pAd, pHdr80211, SUBTYPE_NULL_FUNC, 1, pAd->CommonCfg.Bssid, pAd->CommonCfg.Bssid);
+					MgtMacHeaderInit(pAd, pHdr80211,
+							 SUBTYPE_NULL_FUNC, 1,
+							 pAd->CommonCfg.Bssid,
+							 pAd->CommonCfg.Bssid);
 					pHdr80211->Duration = 0;
 					pHdr80211->FC.Type = BTYPE_DATA;
-					pHdr80211->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
+					pHdr80211->FC.PwrMgmt =
+					    (pAd->StaCfg.Psm == PWR_SAVE);
 
 					// Send using priority queue
-					MiniportMMRequest(pAd, 0, pOutBuffer, sizeof(HEADER_802_11));
-					DBGPRINT(RT_DEBUG_TRACE, ("MlmeScanReqAction -- Send PSM Data frame\n"));
+					MiniportMMRequest(pAd, 0, pOutBuffer,
+							  sizeof
+							  (HEADER_802_11));
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("MlmeScanReqAction -- Send PSM Data frame\n"));
 					MlmeFreeMemory(pAd, pOutBuffer);
 					RTMPusecDelay(5000);
 				}
@@ -458,25 +545,24 @@ VOID ScanNextChannel(
 
 			pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 			Status = MLME_SUCCESS;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF,
+				    2, &Status);
 		}
 
-
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
 	}
 #ifdef RTMP_MAC_USB
-	else if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) && (pAd->OpMode == OPMODE_STA))
-	{
+	else if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)
+		 && (pAd->OpMode == OPMODE_STA)) {
 		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 		MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_FAIL_NO_RESOURCE);
 	}
 #endif // RTMP_MAC_USB //
-	else
-	{
+	else {
 		{
-		// BBP and RF are not accessible in PS mode, we has to wake them up first
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-			AsicForceWakeup(pAd, TRUE);
+			// BBP and RF are not accessible in PS mode, we has to wake them up first
+			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+				AsicForceWakeup(pAd, TRUE);
 
 			// leave PSM during scanning. otherwise we may lost ProbeRsp & BEACON
 			if (pAd->StaCfg.Psm == PWR_SAVE)
@@ -487,10 +573,11 @@ VOID ScanNextChannel(
 		AsicLockChannel(pAd, pAd->MlmeAux.Channel);
 
 		{
-			if (pAd->MlmeAux.Channel > 14)
-			{
-				if ((pAd->CommonCfg.bIEEE80211H == 1) && RadarChannelCheck(pAd, pAd->MlmeAux.Channel))
-				{
+			if (pAd->MlmeAux.Channel > 14) {
+				if ((pAd->CommonCfg.bIEEE80211H == 1)
+				    && RadarChannelCheck(pAd,
+							 pAd->MlmeAux.
+							 Channel)) {
 					ScanType = SCAN_PASSIVE;
 					ScanTimeIn5gChannel = MIN_CHANNEL_TIME;
 				}
@@ -498,103 +585,108 @@ VOID ScanNextChannel(
 		}
 
 		//Global country domain(ch1-11:active scan, ch12-14 passive scan)
-		if ((pAd->MlmeAux.Channel <= 14) && (pAd->MlmeAux.Channel >= 12) && ((pAd->CommonCfg.CountryRegion & 0x7f) == REGION_31_BG_BAND))
-		{
+		if ((pAd->MlmeAux.Channel <= 14) && (pAd->MlmeAux.Channel >= 12)
+		    && ((pAd->CommonCfg.CountryRegion & 0x7f) ==
+			REGION_31_BG_BAND)) {
 			ScanType = SCAN_PASSIVE;
 		}
-
 		// We need to shorten active scan time in order for WZC connect issue
 		// Chnage the channel scan time for CISCO stuff based on its IAPP announcement
 		if (ScanType == FAST_SCAN_ACTIVE)
-			RTMPSetTimer(&pAd->MlmeAux.ScanTimer, FAST_ACTIVE_SCAN_TIME);
-		else // must be SCAN_PASSIVE or SCAN_ACTIVE
+			RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
+				     FAST_ACTIVE_SCAN_TIME);
+		else		// must be SCAN_PASSIVE or SCAN_ACTIVE
 		{
 			if ((pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED)
-				|| (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) || (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED)
-			)
-			{
+			    || (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED)
+			    || (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED)
+			    ) {
 				if (pAd->MlmeAux.Channel > 14)
-					RTMPSetTimer(&pAd->MlmeAux.ScanTimer, ScanTimeIn5gChannel);
+					RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
+						     ScanTimeIn5gChannel);
 				else
-				RTMPSetTimer(&pAd->MlmeAux.ScanTimer, MIN_CHANNEL_TIME);
-			}
-			else
-				RTMPSetTimer(&pAd->MlmeAux.ScanTimer, MAX_CHANNEL_TIME);
+					RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
+						     MIN_CHANNEL_TIME);
+			} else
+				RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
+					     MAX_CHANNEL_TIME);
 		}
 
 		if ((ScanType == SCAN_ACTIVE)
-			|| (ScanType == FAST_SCAN_ACTIVE)
-			)
-		{
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-			if (NStatus != NDIS_STATUS_SUCCESS)
-			{
-				DBGPRINT(RT_DEBUG_TRACE, ("SYNC - ScanNextChannel() allocate memory fail\n"));
+		    || (ScanType == FAST_SCAN_ACTIVE)
+		    ) {
+			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+			if (NStatus != NDIS_STATUS_SUCCESS) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("SYNC - ScanNextChannel() allocate memory fail\n"));
 
 				{
-					pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+					pAd->Mlme.SyncMachine.CurrState =
+					    SYNC_IDLE;
 					Status = MLME_FAIL_NO_RESOURCE;
-					MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
+					MlmeEnqueue(pAd,
+						    MLME_CNTL_STATE_MACHINE,
+						    MT2_SCAN_CONF, 2, &Status);
 				}
 
 				return;
 			}
-
 			// There is no need to send broadcast probe request if active scan is in effect.
-			if ((ScanType == SCAN_ACTIVE) || (ScanType == FAST_SCAN_ACTIVE)
-				)
+			if ((ScanType == SCAN_ACTIVE)
+			    || (ScanType == FAST_SCAN_ACTIVE)
+			    )
 				SsidLen = pAd->MlmeAux.SsidLen;
 			else
 				SsidLen = 0;
 
-			MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0, BROADCAST_ADDR, BROADCAST_ADDR);
-			MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-							  sizeof(HEADER_802_11),    &Hdr80211,
-							  1,                        &SsidIe,
-							  1,                        &SsidLen,
-							  SsidLen,			        pAd->MlmeAux.Ssid,
-							  1,                        &SupRateIe,
-							  1,                        &pAd->CommonCfg.SupRateLen,
-							  pAd->CommonCfg.SupRateLen,  pAd->CommonCfg.SupRate,
-							  END_OF_ARGS);
+			MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0,
+					 BROADCAST_ADDR, BROADCAST_ADDR);
+			MakeOutgoingFrame(pOutBuffer, &FrameLen,
+					  sizeof(HEADER_802_11), &Hdr80211, 1,
+					  &SsidIe, 1, &SsidLen, SsidLen,
+					  pAd->MlmeAux.Ssid, 1, &SupRateIe, 1,
+					  &pAd->CommonCfg.SupRateLen,
+					  pAd->CommonCfg.SupRateLen,
+					  pAd->CommonCfg.SupRate, END_OF_ARGS);
 
-			if (pAd->CommonCfg.ExtRateLen)
-			{
+			if (pAd->CommonCfg.ExtRateLen) {
 				ULONG Tmp;
-				MakeOutgoingFrame(pOutBuffer + FrameLen,            &Tmp,
-								  1,                                &ExtRateIe,
-								  1,                                &pAd->CommonCfg.ExtRateLen,
-								  pAd->CommonCfg.ExtRateLen,          pAd->CommonCfg.ExtRate,
-								  END_OF_ARGS);
+				MakeOutgoingFrame(pOutBuffer + FrameLen, &Tmp,
+						  1, &ExtRateIe,
+						  1, &pAd->CommonCfg.ExtRateLen,
+						  pAd->CommonCfg.ExtRateLen,
+						  pAd->CommonCfg.ExtRate,
+						  END_OF_ARGS);
 				FrameLen += Tmp;
 			}
 
-			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-			{
-				ULONG	Tmp;
-				UCHAR	HtLen;
-				UCHAR	BROADCOM[4] = {0x0, 0x90, 0x4c, 0x33};
-
-				if (pAd->bBroadComHT == TRUE)
-				{
-					HtLen = pAd->MlmeAux.HtCapabilityLen + 4;
+			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) {
+				ULONG Tmp;
+				UCHAR HtLen;
+				UCHAR BROADCOM[4] = { 0x0, 0x90, 0x4c, 0x33 };
 
-					MakeOutgoingFrame(pOutBuffer + FrameLen,          &Tmp,
-									1,                                &WpaIe,
-									1,                                &HtLen,
-									4,                                &BROADCOM[0],
-									pAd->MlmeAux.HtCapabilityLen,     &pAd->MlmeAux.HtCapability,
-									END_OF_ARGS);
-				}
-				else
-				{
+				if (pAd->bBroadComHT == TRUE) {
+					HtLen =
+					    pAd->MlmeAux.HtCapabilityLen + 4;
+
+					MakeOutgoingFrame(pOutBuffer + FrameLen,
+							  &Tmp, 1, &WpaIe, 1,
+							  &HtLen, 4,
+							  &BROADCOM[0],
+							  pAd->MlmeAux.
+							  HtCapabilityLen,
+							  &pAd->MlmeAux.
+							  HtCapability,
+							  END_OF_ARGS);
+				} else {
 					HtLen = pAd->MlmeAux.HtCapabilityLen;
 
-					MakeOutgoingFrame(pOutBuffer + FrameLen,          &Tmp,
-									1,                                &HtCapIe,
-									1,                                &HtLen,
-									HtLen,                            &pAd->CommonCfg.HtCapability,
-									END_OF_ARGS);
+					MakeOutgoingFrame(pOutBuffer + FrameLen,
+							  &Tmp, 1, &HtCapIe, 1,
+							  &HtLen, HtLen,
+							  &pAd->CommonCfg.
+							  HtCapability,
+							  END_OF_ARGS);
 				}
 				FrameLen += Tmp;
 			}
@@ -602,20 +694,16 @@ VOID ScanNextChannel(
 			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 			MlmeFreeMemory(pAd, pOutBuffer);
 		}
-
 		// For SCAN_CISCO_PASSIVE, do nothing and silently wait for beacon or other probe reponse
 
 		pAd->Mlme.SyncMachine.CurrState = SCAN_LISTEN;
 	}
 }
 
-VOID MgtProbReqMacHeaderInit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN OUT PHEADER_802_11 pHdr80211,
-	IN UCHAR SubType,
-	IN UCHAR ToDs,
-	IN PUCHAR pDA,
-	IN PUCHAR pBssid)
+VOID MgtProbReqMacHeaderInit(IN PRTMP_ADAPTER pAd,
+			     IN OUT PHEADER_802_11 pHdr80211,
+			     IN UCHAR SubType,
+			     IN UCHAR ToDs, IN PUCHAR pDA, IN PUCHAR pBssid)
 {
 	NdisZeroMemory(pHdr80211, sizeof(HEADER_802_11));
 
@@ -628,5 +716,3 @@ VOID MgtProbReqMacHeaderInit(
 	COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
 	COPY_MAC_ADDR(pHdr80211->Addr3, pBssid);
 }
-
-
--- a/drivers/staging/rt2860/common/cmm_tkip.c
+++ b/drivers/staging/rt2860/common/cmm_tkip.c
@@ -42,109 +42,101 @@
 	( ((A) << (n)) | ( ((A)>>(32-(n))) & ( (1UL << (n)) - 1 ) ) )
 #define ROR32( A, n ) ROL32( (A), 32-(n) )
 
-UINT Tkip_Sbox_Lower[256] =
-{
-	0xA5,0x84,0x99,0x8D,0x0D,0xBD,0xB1,0x54,
-	0x50,0x03,0xA9,0x7D,0x19,0x62,0xE6,0x9A,
-	0x45,0x9D,0x40,0x87,0x15,0xEB,0xC9,0x0B,
-	0xEC,0x67,0xFD,0xEA,0xBF,0xF7,0x96,0x5B,
-	0xC2,0x1C,0xAE,0x6A,0x5A,0x41,0x02,0x4F,
-	0x5C,0xF4,0x34,0x08,0x93,0x73,0x53,0x3F,
-	0x0C,0x52,0x65,0x5E,0x28,0xA1,0x0F,0xB5,
-	0x09,0x36,0x9B,0x3D,0x26,0x69,0xCD,0x9F,
-	0x1B,0x9E,0x74,0x2E,0x2D,0xB2,0xEE,0xFB,
-	0xF6,0x4D,0x61,0xCE,0x7B,0x3E,0x71,0x97,
-	0xF5,0x68,0x00,0x2C,0x60,0x1F,0xC8,0xED,
-	0xBE,0x46,0xD9,0x4B,0xDE,0xD4,0xE8,0x4A,
-	0x6B,0x2A,0xE5,0x16,0xC5,0xD7,0x55,0x94,
-	0xCF,0x10,0x06,0x81,0xF0,0x44,0xBA,0xE3,
-	0xF3,0xFE,0xC0,0x8A,0xAD,0xBC,0x48,0x04,
-	0xDF,0xC1,0x75,0x63,0x30,0x1A,0x0E,0x6D,
-	0x4C,0x14,0x35,0x2F,0xE1,0xA2,0xCC,0x39,
-	0x57,0xF2,0x82,0x47,0xAC,0xE7,0x2B,0x95,
-	0xA0,0x98,0xD1,0x7F,0x66,0x7E,0xAB,0x83,
-	0xCA,0x29,0xD3,0x3C,0x79,0xE2,0x1D,0x76,
-	0x3B,0x56,0x4E,0x1E,0xDB,0x0A,0x6C,0xE4,
-	0x5D,0x6E,0xEF,0xA6,0xA8,0xA4,0x37,0x8B,
-	0x32,0x43,0x59,0xB7,0x8C,0x64,0xD2,0xE0,
-	0xB4,0xFA,0x07,0x25,0xAF,0x8E,0xE9,0x18,
-	0xD5,0x88,0x6F,0x72,0x24,0xF1,0xC7,0x51,
-	0x23,0x7C,0x9C,0x21,0xDD,0xDC,0x86,0x85,
-	0x90,0x42,0xC4,0xAA,0xD8,0x05,0x01,0x12,
-	0xA3,0x5F,0xF9,0xD0,0x91,0x58,0x27,0xB9,
-	0x38,0x13,0xB3,0x33,0xBB,0x70,0x89,0xA7,
-	0xB6,0x22,0x92,0x20,0x49,0xFF,0x78,0x7A,
-	0x8F,0xF8,0x80,0x17,0xDA,0x31,0xC6,0xB8,
-	0xC3,0xB0,0x77,0x11,0xCB,0xFC,0xD6,0x3A
+UINT Tkip_Sbox_Lower[256] = {
+	0xA5, 0x84, 0x99, 0x8D, 0x0D, 0xBD, 0xB1, 0x54,
+	0x50, 0x03, 0xA9, 0x7D, 0x19, 0x62, 0xE6, 0x9A,
+	0x45, 0x9D, 0x40, 0x87, 0x15, 0xEB, 0xC9, 0x0B,
+	0xEC, 0x67, 0xFD, 0xEA, 0xBF, 0xF7, 0x96, 0x5B,
+	0xC2, 0x1C, 0xAE, 0x6A, 0x5A, 0x41, 0x02, 0x4F,
+	0x5C, 0xF4, 0x34, 0x08, 0x93, 0x73, 0x53, 0x3F,
+	0x0C, 0x52, 0x65, 0x5E, 0x28, 0xA1, 0x0F, 0xB5,
+	0x09, 0x36, 0x9B, 0x3D, 0x26, 0x69, 0xCD, 0x9F,
+	0x1B, 0x9E, 0x74, 0x2E, 0x2D, 0xB2, 0xEE, 0xFB,
+	0xF6, 0x4D, 0x61, 0xCE, 0x7B, 0x3E, 0x71, 0x97,
+	0xF5, 0x68, 0x00, 0x2C, 0x60, 0x1F, 0xC8, 0xED,
+	0xBE, 0x46, 0xD9, 0x4B, 0xDE, 0xD4, 0xE8, 0x4A,
+	0x6B, 0x2A, 0xE5, 0x16, 0xC5, 0xD7, 0x55, 0x94,
+	0xCF, 0x10, 0x06, 0x81, 0xF0, 0x44, 0xBA, 0xE3,
+	0xF3, 0xFE, 0xC0, 0x8A, 0xAD, 0xBC, 0x48, 0x04,
+	0xDF, 0xC1, 0x75, 0x63, 0x30, 0x1A, 0x0E, 0x6D,
+	0x4C, 0x14, 0x35, 0x2F, 0xE1, 0xA2, 0xCC, 0x39,
+	0x57, 0xF2, 0x82, 0x47, 0xAC, 0xE7, 0x2B, 0x95,
+	0xA0, 0x98, 0xD1, 0x7F, 0x66, 0x7E, 0xAB, 0x83,
+	0xCA, 0x29, 0xD3, 0x3C, 0x79, 0xE2, 0x1D, 0x76,
+	0x3B, 0x56, 0x4E, 0x1E, 0xDB, 0x0A, 0x6C, 0xE4,
+	0x5D, 0x6E, 0xEF, 0xA6, 0xA8, 0xA4, 0x37, 0x8B,
+	0x32, 0x43, 0x59, 0xB7, 0x8C, 0x64, 0xD2, 0xE0,
+	0xB4, 0xFA, 0x07, 0x25, 0xAF, 0x8E, 0xE9, 0x18,
+	0xD5, 0x88, 0x6F, 0x72, 0x24, 0xF1, 0xC7, 0x51,
+	0x23, 0x7C, 0x9C, 0x21, 0xDD, 0xDC, 0x86, 0x85,
+	0x90, 0x42, 0xC4, 0xAA, 0xD8, 0x05, 0x01, 0x12,
+	0xA3, 0x5F, 0xF9, 0xD0, 0x91, 0x58, 0x27, 0xB9,
+	0x38, 0x13, 0xB3, 0x33, 0xBB, 0x70, 0x89, 0xA7,
+	0xB6, 0x22, 0x92, 0x20, 0x49, 0xFF, 0x78, 0x7A,
+	0x8F, 0xF8, 0x80, 0x17, 0xDA, 0x31, 0xC6, 0xB8,
+	0xC3, 0xB0, 0x77, 0x11, 0xCB, 0xFC, 0xD6, 0x3A
 };
 
-UINT Tkip_Sbox_Upper[256] =
-{
-	0xC6,0xF8,0xEE,0xF6,0xFF,0xD6,0xDE,0x91,
-	0x60,0x02,0xCE,0x56,0xE7,0xB5,0x4D,0xEC,
-	0x8F,0x1F,0x89,0xFA,0xEF,0xB2,0x8E,0xFB,
-	0x41,0xB3,0x5F,0x45,0x23,0x53,0xE4,0x9B,
-	0x75,0xE1,0x3D,0x4C,0x6C,0x7E,0xF5,0x83,
-	0x68,0x51,0xD1,0xF9,0xE2,0xAB,0x62,0x2A,
-	0x08,0x95,0x46,0x9D,0x30,0x37,0x0A,0x2F,
-	0x0E,0x24,0x1B,0xDF,0xCD,0x4E,0x7F,0xEA,
-	0x12,0x1D,0x58,0x34,0x36,0xDC,0xB4,0x5B,
-	0xA4,0x76,0xB7,0x7D,0x52,0xDD,0x5E,0x13,
-	0xA6,0xB9,0x00,0xC1,0x40,0xE3,0x79,0xB6,
-	0xD4,0x8D,0x67,0x72,0x94,0x98,0xB0,0x85,
-	0xBB,0xC5,0x4F,0xED,0x86,0x9A,0x66,0x11,
-	0x8A,0xE9,0x04,0xFE,0xA0,0x78,0x25,0x4B,
-	0xA2,0x5D,0x80,0x05,0x3F,0x21,0x70,0xF1,
-	0x63,0x77,0xAF,0x42,0x20,0xE5,0xFD,0xBF,
-	0x81,0x18,0x26,0xC3,0xBE,0x35,0x88,0x2E,
-	0x93,0x55,0xFC,0x7A,0xC8,0xBA,0x32,0xE6,
-	0xC0,0x19,0x9E,0xA3,0x44,0x54,0x3B,0x0B,
-	0x8C,0xC7,0x6B,0x28,0xA7,0xBC,0x16,0xAD,
-	0xDB,0x64,0x74,0x14,0x92,0x0C,0x48,0xB8,
-	0x9F,0xBD,0x43,0xC4,0x39,0x31,0xD3,0xF2,
-	0xD5,0x8B,0x6E,0xDA,0x01,0xB1,0x9C,0x49,
-	0xD8,0xAC,0xF3,0xCF,0xCA,0xF4,0x47,0x10,
-	0x6F,0xF0,0x4A,0x5C,0x38,0x57,0x73,0x97,
-	0xCB,0xA1,0xE8,0x3E,0x96,0x61,0x0D,0x0F,
-	0xE0,0x7C,0x71,0xCC,0x90,0x06,0xF7,0x1C,
-	0xC2,0x6A,0xAE,0x69,0x17,0x99,0x3A,0x27,
-	0xD9,0xEB,0x2B,0x22,0xD2,0xA9,0x07,0x33,
-	0x2D,0x3C,0x15,0xC9,0x87,0xAA,0x50,0xA5,
-	0x03,0x59,0x09,0x1A,0x65,0xD7,0x84,0xD0,
-	0x82,0x29,0x5A,0x1E,0x7B,0xA8,0x6D,0x2C
+UINT Tkip_Sbox_Upper[256] = {
+	0xC6, 0xF8, 0xEE, 0xF6, 0xFF, 0xD6, 0xDE, 0x91,
+	0x60, 0x02, 0xCE, 0x56, 0xE7, 0xB5, 0x4D, 0xEC,
+	0x8F, 0x1F, 0x89, 0xFA, 0xEF, 0xB2, 0x8E, 0xFB,
+	0x41, 0xB3, 0x5F, 0x45, 0x23, 0x53, 0xE4, 0x9B,
+	0x75, 0xE1, 0x3D, 0x4C, 0x6C, 0x7E, 0xF5, 0x83,
+	0x68, 0x51, 0xD1, 0xF9, 0xE2, 0xAB, 0x62, 0x2A,
+	0x08, 0x95, 0x46, 0x9D, 0x30, 0x37, 0x0A, 0x2F,
+	0x0E, 0x24, 0x1B, 0xDF, 0xCD, 0x4E, 0x7F, 0xEA,
+	0x12, 0x1D, 0x58, 0x34, 0x36, 0xDC, 0xB4, 0x5B,
+	0xA4, 0x76, 0xB7, 0x7D, 0x52, 0xDD, 0x5E, 0x13,
+	0xA6, 0xB9, 0x00, 0xC1, 0x40, 0xE3, 0x79, 0xB6,
+	0xD4, 0x8D, 0x67, 0x72, 0x94, 0x98, 0xB0, 0x85,
+	0xBB, 0xC5, 0x4F, 0xED, 0x86, 0x9A, 0x66, 0x11,
+	0x8A, 0xE9, 0x04, 0xFE, 0xA0, 0x78, 0x25, 0x4B,
+	0xA2, 0x5D, 0x80, 0x05, 0x3F, 0x21, 0x70, 0xF1,
+	0x63, 0x77, 0xAF, 0x42, 0x20, 0xE5, 0xFD, 0xBF,
+	0x81, 0x18, 0x26, 0xC3, 0xBE, 0x35, 0x88, 0x2E,
+	0x93, 0x55, 0xFC, 0x7A, 0xC8, 0xBA, 0x32, 0xE6,
+	0xC0, 0x19, 0x9E, 0xA3, 0x44, 0x54, 0x3B, 0x0B,
+	0x8C, 0xC7, 0x6B, 0x28, 0xA7, 0xBC, 0x16, 0xAD,
+	0xDB, 0x64, 0x74, 0x14, 0x92, 0x0C, 0x48, 0xB8,
+	0x9F, 0xBD, 0x43, 0xC4, 0x39, 0x31, 0xD3, 0xF2,
+	0xD5, 0x8B, 0x6E, 0xDA, 0x01, 0xB1, 0x9C, 0x49,
+	0xD8, 0xAC, 0xF3, 0xCF, 0xCA, 0xF4, 0x47, 0x10,
+	0x6F, 0xF0, 0x4A, 0x5C, 0x38, 0x57, 0x73, 0x97,
+	0xCB, 0xA1, 0xE8, 0x3E, 0x96, 0x61, 0x0D, 0x0F,
+	0xE0, 0x7C, 0x71, 0xCC, 0x90, 0x06, 0xF7, 0x1C,
+	0xC2, 0x6A, 0xAE, 0x69, 0x17, 0x99, 0x3A, 0x27,
+	0xD9, 0xEB, 0x2B, 0x22, 0xD2, 0xA9, 0x07, 0x33,
+	0x2D, 0x3C, 0x15, 0xC9, 0x87, 0xAA, 0x50, 0xA5,
+	0x03, 0x59, 0x09, 0x1A, 0x65, 0xD7, 0x84, 0xD0,
+	0x82, 0x29, 0x5A, 0x1E, 0x7B, 0xA8, 0x6D, 0x2C
 };
 
 //
 // Expanded IV for TKIP function.
 //
-typedef	struct	PACKED _IV_CONTROL_
-{
-	union PACKED
-	{
-		struct PACKED
-		{
-			UCHAR		rc0;
-			UCHAR		rc1;
-			UCHAR		rc2;
-
-			union PACKED
-			{
-				struct PACKED
-				{
-					UCHAR	Rsvd:5;
-					UCHAR	ExtIV:1;
-					UCHAR	KeyID:2;
-				}	field;
-				UCHAR		Byte;
-			}	CONTROL;
-		}	field;
-
-		ULONG	word;
-	}	IV16;
+typedef struct PACKED _IV_CONTROL_ {
+	union PACKED {
+		struct PACKED {
+			UCHAR rc0;
+			UCHAR rc1;
+			UCHAR rc2;
+
+			union PACKED {
+				struct PACKED {
+					UCHAR Rsvd:5;
+					UCHAR ExtIV:1;
+					UCHAR KeyID:2;
+				} field;
+				UCHAR Byte;
+			} CONTROL;
+		} field;
 
-	ULONG	IV32;
-}	TKIP_IV, *PTKIP_IV;
+		ULONG word;
+	} IV16;
 
+	ULONG IV32;
+} TKIP_IV, *PTKIP_IV;
 
 /*
 	========================================================================
@@ -162,14 +154,12 @@ typedef	struct	PACKED _IV_CONTROL_
 
 	========================================================================
 */
-ULONG	RTMPTkipGetUInt32(
-	IN	PUCHAR	pMICKey)
+ULONG RTMPTkipGetUInt32(IN PUCHAR pMICKey)
 {
-	ULONG	res = 0;
-	INT		i;
+	ULONG res = 0;
+	INT i;
 
-	for (i = 0; i < 4; i++)
-	{
+	for (i = 0; i < 4; i++) {
 		res |= (*pMICKey++) << (8 * i);
 	}
 
@@ -195,14 +185,11 @@ ULONG	RTMPTkipGetUInt32(
 
 	========================================================================
 */
-VOID	RTMPTkipPutUInt32(
-	IN OUT	PUCHAR		pDst,
-	IN		ULONG		val)
+VOID RTMPTkipPutUInt32(IN OUT PUCHAR pDst, IN ULONG val)
 {
 	INT i;
 
-	for(i = 0; i < 4; i++)
-	{
+	for (i = 0; i < 4; i++) {
 		*pDst++ = (UCHAR) (val & 0xff);
 		val >>= 8;
 	}
@@ -227,9 +214,7 @@ VOID	RTMPTkipPutUInt32(
 
 	========================================================================
 */
-VOID RTMPTkipSetMICKey(
-	IN	PTKIP_KEY_INFO	pTkip,
-	IN	PUCHAR			pMICKey)
+VOID RTMPTkipSetMICKey(IN PTKIP_KEY_INFO pTkip, IN PUCHAR pMICKey)
 {
 	// Set the key
 	pTkip->K0 = RTMPTkipGetUInt32(pMICKey);
@@ -260,24 +245,23 @@ VOID RTMPTkipSetMICKey(
 
 	========================================================================
 */
-VOID	RTMPTkipAppendByte(
-	IN	PTKIP_KEY_INFO	pTkip,
-	IN	UCHAR			uChar)
+VOID RTMPTkipAppendByte(IN PTKIP_KEY_INFO pTkip, IN UCHAR uChar)
 {
 	// Append the byte to our word-sized buffer
-	pTkip->M |= (uChar << (8* pTkip->nBytesInM));
+	pTkip->M |= (uChar << (8 * pTkip->nBytesInM));
 	pTkip->nBytesInM++;
 	// Process the word if it is full.
-	if( pTkip->nBytesInM >= 4 )
-	{
+	if (pTkip->nBytesInM >= 4) {
 		pTkip->L ^= pTkip->M;
-		pTkip->R ^= ROL32( pTkip->L, 17 );
+		pTkip->R ^= ROL32(pTkip->L, 17);
 		pTkip->L += pTkip->R;
-		pTkip->R ^= ((pTkip->L & 0xff00ff00) >> 8) | ((pTkip->L & 0x00ff00ff) << 8);
+		pTkip->R ^=
+		    ((pTkip->L & 0xff00ff00) >> 8) | ((pTkip->
+						       L & 0x00ff00ff) << 8);
 		pTkip->L += pTkip->R;
-		pTkip->R ^= ROL32( pTkip->L, 3 );
+		pTkip->R ^= ROL32(pTkip->L, 3);
 		pTkip->L += pTkip->R;
-		pTkip->R ^= ROR32( pTkip->L, 2 );
+		pTkip->R ^= ROR32(pTkip->L, 2);
 		pTkip->L += pTkip->R;
 		// Clear the buffer
 		pTkip->M = 0;
@@ -305,14 +289,10 @@ VOID	RTMPTkipAppendByte(
 
 	========================================================================
 */
-VOID	RTMPTkipAppend(
-	IN	PTKIP_KEY_INFO	pTkip,
-	IN	PUCHAR			pSrc,
-	IN	UINT			nBytes)
+VOID RTMPTkipAppend(IN PTKIP_KEY_INFO pTkip, IN PUCHAR pSrc, IN UINT nBytes)
 {
 	// This is simple
-	while(nBytes > 0)
-	{
+	while (nBytes > 0) {
 		RTMPTkipAppendByte(pTkip, *pSrc++);
 		nBytes--;
 	}
@@ -336,19 +316,17 @@ VOID	RTMPTkipAppend(
 		the MIC Value is store in pAd->PrivateInfo.MIC
 	========================================================================
 */
-VOID	RTMPTkipGetMIC(
-	IN	PTKIP_KEY_INFO	pTkip)
+VOID RTMPTkipGetMIC(IN PTKIP_KEY_INFO pTkip)
 {
 	// Append the minimum padding
-	RTMPTkipAppendByte(pTkip, 0x5a );
-	RTMPTkipAppendByte(pTkip, 0 );
-	RTMPTkipAppendByte(pTkip, 0 );
-	RTMPTkipAppendByte(pTkip, 0 );
-	RTMPTkipAppendByte(pTkip, 0 );
+	RTMPTkipAppendByte(pTkip, 0x5a);
+	RTMPTkipAppendByte(pTkip, 0);
+	RTMPTkipAppendByte(pTkip, 0);
+	RTMPTkipAppendByte(pTkip, 0);
+	RTMPTkipAppendByte(pTkip, 0);
 	// and then zeroes until the length is a multiple of 4
-	while( pTkip->nBytesInM != 0 )
-	{
-		RTMPTkipAppendByte(pTkip, 0 );
+	while (pTkip->nBytesInM != 0) {
+		RTMPTkipAppendByte(pTkip, 0);
 	}
 	// The appendByte function has already computed the result.
 	RTMPTkipPutUInt32(pTkip->MIC, pTkip->L);
@@ -377,27 +355,24 @@ VOID	RTMPTkipGetMIC(
 
 	========================================================================
 */
-VOID	RTMPInitTkipEngine(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pKey,
-	IN	UCHAR			KeyId,
-	IN	PUCHAR			pTA,
-	IN	PUCHAR			pMICKey,
-	IN	PUCHAR			pTSC,
-	OUT	PULONG			pIV16,
-	OUT	PULONG			pIV32)
+VOID RTMPInitTkipEngine(IN PRTMP_ADAPTER pAd,
+			IN PUCHAR pKey,
+			IN UCHAR KeyId,
+			IN PUCHAR pTA,
+			IN PUCHAR pMICKey,
+			IN PUCHAR pTSC, OUT PULONG pIV16, OUT PULONG pIV32)
 {
-	TKIP_IV	tkipIv;
+	TKIP_IV tkipIv;
 
 	// Prepare 8 bytes TKIP encapsulation for MPDU
 	NdisZeroMemory(&tkipIv, sizeof(TKIP_IV));
 	tkipIv.IV16.field.rc0 = *(pTSC + 1);
 	tkipIv.IV16.field.rc1 = (tkipIv.IV16.field.rc0 | 0x20) & 0x7f;
 	tkipIv.IV16.field.rc2 = *pTSC;
-	tkipIv.IV16.field.CONTROL.field.ExtIV = 1;  // 0: non-extended IV, 1: an extended IV
+	tkipIv.IV16.field.CONTROL.field.ExtIV = 1;	// 0: non-extended IV, 1: an extended IV
 	tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
-//	tkipIv.IV32 = *(PULONG)(pTSC + 2);
-	NdisMoveMemory(&tkipIv.IV32, (pTSC + 2), 4);   // Copy IV
+//      tkipIv.IV32 = *(PULONG)(pTSC + 2);
+	NdisMoveMemory(&tkipIv.IV32, (pTSC + 2), 4);	// Copy IV
 
 	*pIV16 = tkipIv.IV16.word;
 	*pIV32 = tkipIv.IV32;
@@ -424,13 +399,10 @@ VOID	RTMPInitTkipEngine(
 
 	========================================================================
 */
-VOID	RTMPInitMICEngine(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pKey,
-	IN	PUCHAR			pDA,
-	IN	PUCHAR			pSA,
-	IN  UCHAR           UserPriority,
-	IN	PUCHAR			pMICKey)
+VOID RTMPInitMICEngine(IN PRTMP_ADAPTER pAd,
+		       IN PUCHAR pKey,
+		       IN PUCHAR pDA,
+		       IN PUCHAR pSA, IN UCHAR UserPriority, IN PUCHAR pMICKey)
 {
 	ULONG Priority = UserPriority;
 
@@ -441,7 +413,7 @@ VOID	RTMPInitMICEngine(
 	// SA
 	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSA, MAC_ADDR_LEN);
 	// Priority + 3 bytes of 0
-	RTMPTkipAppend(&pAd->PrivateInfo.Tx, (PUCHAR)&Priority, 4);
+	RTMPTkipAppend(&pAd->PrivateInfo.Tx, (PUCHAR) & Priority, 4);
 }
 
 /*
@@ -468,17 +440,15 @@ VOID	RTMPInitMICEngine(
 
 	========================================================================
 */
-BOOLEAN	RTMPTkipCompareMICValue(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pSrc,
-	IN	PUCHAR			pDA,
-	IN	PUCHAR			pSA,
-	IN	PUCHAR			pMICKey,
-	IN	UCHAR			UserPriority,
-	IN	UINT			Len)
+BOOLEAN RTMPTkipCompareMICValue(IN PRTMP_ADAPTER pAd,
+				IN PUCHAR pSrc,
+				IN PUCHAR pDA,
+				IN PUCHAR pSA,
+				IN PUCHAR pMICKey,
+				IN UCHAR UserPriority, IN UINT Len)
 {
-	UCHAR	OldMic[8];
-	ULONG	Priority = UserPriority;
+	UCHAR OldMic[8];
+	ULONG Priority = UserPriority;
 
 	// Init MIC value calculation
 	RTMPTkipSetMICKey(&pAd->PrivateInfo.Rx, pMICKey);
@@ -487,7 +457,7 @@ BOOLEAN	RTMPTkipCompareMICValue(
 	// SA
 	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pSA, MAC_ADDR_LEN);
 	// Priority + 3 bytes of 0
-	RTMPTkipAppend(&pAd->PrivateInfo.Rx, (PUCHAR)&Priority, 4);
+	RTMPTkipAppend(&pAd->PrivateInfo.Rx, (PUCHAR) & Priority, 4);
 
 	// Calculate MIC value from plain text data
 	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pSrc, Len);
@@ -500,10 +470,8 @@ BOOLEAN	RTMPTkipCompareMICValue(
 
 	// Move MIC value from MSDU, this steps should move to data path.
 	// Since the MIC value might cross MPDUs.
-	if(!NdisEqualMemory(pAd->PrivateInfo.Rx.MIC, OldMic, 8))
-	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("RTMPTkipCompareMICValue(): TKIP MIC Error !\n"));  //MIC error.
-
+	if (!NdisEqualMemory(pAd->PrivateInfo.Rx.MIC, OldMic, 8)) {
+		DBGPRINT_RAW(RT_DEBUG_ERROR, ("RTMPTkipCompareMICValue(): TKIP MIC Error !\n"));	//MIC error.
 
 		return (FALSE);
 	}
@@ -532,19 +500,17 @@ BOOLEAN	RTMPTkipCompareMICValue(
 
 	========================================================================
 */
-VOID	RTMPCalculateMICValue(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	PUCHAR			pEncap,
-	IN	PCIPHER_KEY		pKey,
-	IN	UCHAR			apidx)
-{
-	PACKET_INFO		PacketInfo;
-	PUCHAR			pSrcBufVA;
-	UINT			SrcBufLen;
-	PUCHAR			pSrc;
-    UCHAR           UserPriority;
-	UCHAR			vlan_offset = 0;
+VOID RTMPCalculateMICValue(IN PRTMP_ADAPTER pAd,
+			   IN PNDIS_PACKET pPacket,
+			   IN PUCHAR pEncap,
+			   IN PCIPHER_KEY pKey, IN UCHAR apidx)
+{
+	PACKET_INFO PacketInfo;
+	PUCHAR pSrcBufVA;
+	UINT SrcBufLen;
+	PUCHAR pSrc;
+	UCHAR UserPriority;
+	UCHAR vlan_offset = 0;
 
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
@@ -556,41 +522,33 @@ VOID	RTMPCalculateMICValue(
 		vlan_offset = 4;
 
 	{
-		RTMPInitMICEngine(
-			pAd,
-			pKey->Key,
-			pSrc,
-			pSrc + 6,
-			UserPriority,
-			pKey->TxMic);
+		RTMPInitMICEngine(pAd,
+				  pKey->Key,
+				  pSrc, pSrc + 6, UserPriority, pKey->TxMic);
 	}
 
-
-	if (pEncap != NULL)
-	{
+	if (pEncap != NULL) {
 		// LLC encapsulation
 		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pEncap, 6);
 		// Protocol Type
-		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc + 12 + vlan_offset, 2);
+		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc + 12 + vlan_offset,
+			       2);
 	}
 	SrcBufLen -= (14 + vlan_offset);
 	pSrc += (14 + vlan_offset);
-	do
-	{
-		if (SrcBufLen > 0)
-		{
+	do {
+		if (SrcBufLen > 0) {
 			RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc, SrcBufLen);
 		}
 
-		break;	// No need handle next packet
+		break;		// No need handle next packet
 
-	}	while (TRUE);		// End of copying payload
+	} while (TRUE);		// End of copying payload
 
 	// Compute the final MIC Value
 	RTMPTkipGetMIC(&pAd->PrivateInfo.Tx);
 }
 
-
 /************************************************************/
 /* tkip_sbox()																*/
 /* Returns a 16 bit value from a 64K entry table. The Table */
@@ -607,7 +565,8 @@ UINT tkip_sbox(UINT index)
 	index_high = ((index >> 8) % 256);
 
 	left = Tkip_Sbox_Lower[index_low] + (Tkip_Sbox_Upper[index_low] * 256);
-	right = Tkip_Sbox_Upper[index_high] + (Tkip_Sbox_Lower[index_high] * 256);
+	right =
+	    Tkip_Sbox_Upper[index_high] + (Tkip_Sbox_Lower[index_high] * 256);
 
 	return (left ^ right);
 }
@@ -616,25 +575,18 @@ UINT rotr1(UINT a)
 {
 	unsigned int b;
 
-	if ((a & 0x01) == 0x01)
-	{
+	if ((a & 0x01) == 0x01) {
 		b = (a >> 1) | 0x8000;
-	}
-	else
-	{
+	} else {
 		b = (a >> 1) & 0x7fff;
 	}
 	b = b % 65536;
 	return b;
 }
 
-VOID RTMPTkipMixKey(
-	UCHAR *key,
-	UCHAR *ta,
-	ULONG pnl, /* Least significant 16 bits of PN */
-	ULONG pnh, /* Most significant 32 bits of PN */
-	UCHAR *rc4key,
-	UINT *p1k)
+VOID RTMPTkipMixKey(UCHAR * key, UCHAR * ta, ULONG pnl,	/* Least significant 16 bits of PN */
+		    ULONG pnh,	/* Most significant 32 bits of PN */
+		    UCHAR * rc4key, UINT * p1k)
 {
 
 	UINT tsc0;
@@ -651,26 +603,40 @@ VOID RTMPTkipMixKey(
 	INT i;
 	INT j;
 
-	tsc0 = (unsigned int)((pnh >> 16) % 65536); /* msb */
+	tsc0 = (unsigned int)((pnh >> 16) % 65536);	/* msb */
 	tsc1 = (unsigned int)(pnh % 65536);
-	tsc2 = (unsigned int)(pnl % 65536); /* lsb */
+	tsc2 = (unsigned int)(pnl % 65536);	/* lsb */
 
 	/* Phase 1, step 1 */
 	p1k[0] = tsc1;
 	p1k[1] = tsc0;
-	p1k[2] = (UINT)(ta[0] + (ta[1]*256));
-	p1k[3] = (UINT)(ta[2] + (ta[3]*256));
-	p1k[4] = (UINT)(ta[4] + (ta[5]*256));
+	p1k[2] = (UINT) (ta[0] + (ta[1] * 256));
+	p1k[3] = (UINT) (ta[2] + (ta[3] * 256));
+	p1k[4] = (UINT) (ta[4] + (ta[5] * 256));
 
 	/* Phase 1, step 2 */
-	for (i=0; i<8; i++)
-	{
-		j = 2*(i & 1);
-		p1k[0] = (p1k[0] + tkip_sbox( (p1k[4] ^ ((256*key[1+j]) + key[j])) % 65536 )) % 65536;
-		p1k[1] = (p1k[1] + tkip_sbox( (p1k[0] ^ ((256*key[5+j]) + key[4+j])) % 65536 )) % 65536;
-		p1k[2] = (p1k[2] + tkip_sbox( (p1k[1] ^ ((256*key[9+j]) + key[8+j])) % 65536 )) % 65536;
-		p1k[3] = (p1k[3] + tkip_sbox( (p1k[2] ^ ((256*key[13+j]) + key[12+j])) % 65536 )) % 65536;
-		p1k[4] = (p1k[4] + tkip_sbox( (p1k[3] ^ (((256*key[1+j]) + key[j]))) % 65536 )) % 65536;
+	for (i = 0; i < 8; i++) {
+		j = 2 * (i & 1);
+		p1k[0] =
+		    (p1k[0] +
+		     tkip_sbox((p1k[4] ^ ((256 * key[1 + j]) + key[j])) %
+			       65536)) % 65536;
+		p1k[1] =
+		    (p1k[1] +
+		     tkip_sbox((p1k[0] ^ ((256 * key[5 + j]) + key[4 + j])) %
+			       65536)) % 65536;
+		p1k[2] =
+		    (p1k[2] +
+		     tkip_sbox((p1k[1] ^ ((256 * key[9 + j]) + key[8 + j])) %
+			       65536)) % 65536;
+		p1k[3] =
+		    (p1k[3] +
+		     tkip_sbox((p1k[2] ^ ((256 * key[13 + j]) + key[12 + j])) %
+			       65536)) % 65536;
+		p1k[4] =
+		    (p1k[4] +
+		     tkip_sbox((p1k[3] ^ (((256 * key[1 + j]) + key[j]))) %
+			       65536)) % 65536;
 		p1k[4] = (p1k[4] + i) % 65536;
 	}
 
@@ -683,31 +649,31 @@ VOID RTMPTkipMixKey(
 	ppk5 = (p1k[4] + tsc2) % 65536;
 
 	/* Phase2, Step 2 */
-	ppk0 = ppk0 + tkip_sbox( (ppk5 ^ ((256*key[1]) + key[0])) % 65536);
-	ppk1 = ppk1 + tkip_sbox( (ppk0 ^ ((256*key[3]) + key[2])) % 65536);
-	ppk2 = ppk2 + tkip_sbox( (ppk1 ^ ((256*key[5]) + key[4])) % 65536);
-	ppk3 = ppk3 + tkip_sbox( (ppk2 ^ ((256*key[7]) + key[6])) % 65536);
-	ppk4 = ppk4 + tkip_sbox( (ppk3 ^ ((256*key[9]) + key[8])) % 65536);
-	ppk5 = ppk5 + tkip_sbox( (ppk4 ^ ((256*key[11]) + key[10])) % 65536);
+	ppk0 = ppk0 + tkip_sbox((ppk5 ^ ((256 * key[1]) + key[0])) % 65536);
+	ppk1 = ppk1 + tkip_sbox((ppk0 ^ ((256 * key[3]) + key[2])) % 65536);
+	ppk2 = ppk2 + tkip_sbox((ppk1 ^ ((256 * key[5]) + key[4])) % 65536);
+	ppk3 = ppk3 + tkip_sbox((ppk2 ^ ((256 * key[7]) + key[6])) % 65536);
+	ppk4 = ppk4 + tkip_sbox((ppk3 ^ ((256 * key[9]) + key[8])) % 65536);
+	ppk5 = ppk5 + tkip_sbox((ppk4 ^ ((256 * key[11]) + key[10])) % 65536);
 
-	ppk0 = ppk0 + rotr1(ppk5 ^ ((256*key[13]) + key[12]));
-	ppk1 = ppk1 + rotr1(ppk0 ^ ((256*key[15]) + key[14]));
+	ppk0 = ppk0 + rotr1(ppk5 ^ ((256 * key[13]) + key[12]));
+	ppk1 = ppk1 + rotr1(ppk0 ^ ((256 * key[15]) + key[14]));
 	ppk2 = ppk2 + rotr1(ppk1);
 	ppk3 = ppk3 + rotr1(ppk2);
 	ppk4 = ppk4 + rotr1(ppk3);
 	ppk5 = ppk5 + rotr1(ppk4);
 
 	/* Phase 2, Step 3 */
-    /* Phase 2, Step 3 */
+	/* Phase 2, Step 3 */
 
-	tsc0 = (unsigned int)((pnh >> 16) % 65536); /* msb */
+	tsc0 = (unsigned int)((pnh >> 16) % 65536);	/* msb */
 	tsc1 = (unsigned int)(pnh % 65536);
-	tsc2 = (unsigned int)(pnl % 65536); /* lsb */
+	tsc2 = (unsigned int)(pnl % 65536);	/* lsb */
 
 	rc4key[0] = (tsc2 >> 8) % 256;
 	rc4key[1] = (((tsc2 >> 8) % 256) | 0x20) & 0x7f;
 	rc4key[2] = tsc2 % 256;
-	rc4key[3] = ((ppk5 ^ ((256*key[1]) + key[0])) >> 1) % 256;
+	rc4key[3] = ((ppk5 ^ ((256 * key[1]) + key[0])) >> 1) % 256;
 
 	rc4key[4] = ppk0 % 256;
 	rc4key[5] = (ppk0 >> 8) % 256;
@@ -728,155 +694,140 @@ VOID RTMPTkipMixKey(
 	rc4key[15] = (ppk5 >> 8) % 256;
 }
 
-
 //
 // TRUE: Success!
 // FALSE: Decrypt Error!
 //
-BOOLEAN RTMPSoftDecryptTKIP(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR	pData,
-	IN ULONG	DataByteCnt,
-	IN UCHAR    UserPriority,
-	IN PCIPHER_KEY	pWpaKey)
-{
-	UCHAR			KeyID;
-	UINT			HeaderLen;
-    UCHAR			fc0;
-	UCHAR			fc1;
-	USHORT			fc;
-	UINT			frame_type;
-	UINT			frame_subtype;
-    UINT			from_ds;
-    UINT			to_ds;
-	INT				a4_exists;
-	INT				qc_exists;
-	USHORT			duration;
-	USHORT			seq_control;
-	USHORT			qos_control;
-	UCHAR			TA[MAC_ADDR_LEN];
-	UCHAR			DA[MAC_ADDR_LEN];
-	UCHAR			SA[MAC_ADDR_LEN];
-	UCHAR			RC4Key[16];
-	UINT			p1k[5]; //for mix_key;
-	ULONG			pnl;/* Least significant 16 bits of PN */
-	ULONG			pnh;/* Most significant 32 bits of PN */
-	UINT			num_blocks;
-	UINT			payload_remainder;
-	ARCFOURCONTEXT	ArcFourContext;
-	UINT			crc32 = 0;
-	UINT			trailfcs = 0;
-	UCHAR			MIC[8];
-	UCHAR			TrailMIC[8];
-
+BOOLEAN RTMPSoftDecryptTKIP(IN PRTMP_ADAPTER pAd,
+			    IN PUCHAR pData,
+			    IN ULONG DataByteCnt,
+			    IN UCHAR UserPriority, IN PCIPHER_KEY pWpaKey)
+{
+	UCHAR KeyID;
+	UINT HeaderLen;
+	UCHAR fc0;
+	UCHAR fc1;
+	USHORT fc;
+	UINT frame_type;
+	UINT frame_subtype;
+	UINT from_ds;
+	UINT to_ds;
+	INT a4_exists;
+	INT qc_exists;
+	USHORT duration;
+	USHORT seq_control;
+	USHORT qos_control;
+	UCHAR TA[MAC_ADDR_LEN];
+	UCHAR DA[MAC_ADDR_LEN];
+	UCHAR SA[MAC_ADDR_LEN];
+	UCHAR RC4Key[16];
+	UINT p1k[5];		//for mix_key;
+	ULONG pnl;		/* Least significant 16 bits of PN */
+	ULONG pnh;		/* Most significant 32 bits of PN */
+	UINT num_blocks;
+	UINT payload_remainder;
+	ARCFOURCONTEXT ArcFourContext;
+	UINT crc32 = 0;
+	UINT trailfcs = 0;
+	UCHAR MIC[8];
+	UCHAR TrailMIC[8];
 
 	fc0 = *pData;
 	fc1 = *(pData + 1);
 
-	fc = *((PUSHORT)pData);
+	fc = *((PUSHORT) pData);
 
 	frame_type = ((fc0 >> 2) & 0x03);
 	frame_subtype = ((fc0 >> 4) & 0x0f);
 
-    from_ds = (fc1 & 0x2) >> 1;
-    to_ds = (fc1 & 0x1);
+	from_ds = (fc1 & 0x2) >> 1;
+	to_ds = (fc1 & 0x1);
 
-    a4_exists = (from_ds & to_ds);
-    qc_exists = ((frame_subtype == 0x08) ||    /* Assumed QoS subtypes */
-                  (frame_subtype == 0x09) ||   /* Likely to change.    */
-                  (frame_subtype == 0x0a) ||
-                  (frame_subtype == 0x0b)
-                 );
+	a4_exists = (from_ds & to_ds);
+	qc_exists = ((frame_subtype == 0x08) ||	/* Assumed QoS subtypes */
+		     (frame_subtype == 0x09) ||	/* Likely to change.    */
+		     (frame_subtype == 0x0a) || (frame_subtype == 0x0b)
+	    );
 
 	HeaderLen = 24;
 	if (a4_exists)
 		HeaderLen += 6;
 
-	KeyID = *((PUCHAR)(pData+ HeaderLen + 3));
+	KeyID = *((PUCHAR) (pData + HeaderLen + 3));
 	KeyID = KeyID >> 6;
 
-	if (pWpaKey[KeyID].KeyLen == 0)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("RTMPSoftDecryptTKIP failed!(KeyID[%d] Length can not be 0)\n", KeyID));
+	if (pWpaKey[KeyID].KeyLen == 0) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTMPSoftDecryptTKIP failed!(KeyID[%d] Length can not be 0)\n",
+			  KeyID));
 		return FALSE;
 	}
 
-	duration = *((PUSHORT)(pData+2));
+	duration = *((PUSHORT) (pData + 2));
 
-	seq_control = *((PUSHORT)(pData+22));
+	seq_control = *((PUSHORT) (pData + 22));
 
-	if (qc_exists)
-	{
-		if (a4_exists)
-		{
-			qos_control = *((PUSHORT)(pData+30));
-		}
-		else
-		{
-			qos_control = *((PUSHORT)(pData+24));
+	if (qc_exists) {
+		if (a4_exists) {
+			qos_control = *((PUSHORT) (pData + 30));
+		} else {
+			qos_control = *((PUSHORT) (pData + 24));
 		}
 	}
 
-	if (to_ds == 0 && from_ds == 1)
-	{
-		NdisMoveMemory(DA, pData+4, MAC_ADDR_LEN);
-		NdisMoveMemory(SA, pData+16, MAC_ADDR_LEN);
-		NdisMoveMemory(TA, pData+10, MAC_ADDR_LEN);  //BSSID
-	}
-	else if (to_ds == 0 && from_ds == 0 )
-	{
-		NdisMoveMemory(TA, pData+10, MAC_ADDR_LEN);
-		NdisMoveMemory(DA, pData+4, MAC_ADDR_LEN);
-		NdisMoveMemory(SA, pData+10, MAC_ADDR_LEN);
-	}
-	else if (to_ds == 1 && from_ds == 0)
-	{
-		NdisMoveMemory(SA, pData+10, MAC_ADDR_LEN);
-		NdisMoveMemory(TA, pData+10, MAC_ADDR_LEN);
-		NdisMoveMemory(DA, pData+16, MAC_ADDR_LEN);
-	}
-	else if (to_ds == 1 && from_ds == 1)
-	{
-		NdisMoveMemory(TA, pData+10, MAC_ADDR_LEN);
-		NdisMoveMemory(DA, pData+16, MAC_ADDR_LEN);
-		NdisMoveMemory(SA, pData+22, MAC_ADDR_LEN);
+	if (to_ds == 0 && from_ds == 1) {
+		NdisMoveMemory(DA, pData + 4, MAC_ADDR_LEN);
+		NdisMoveMemory(SA, pData + 16, MAC_ADDR_LEN);
+		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);	//BSSID
+	} else if (to_ds == 0 && from_ds == 0) {
+		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);
+		NdisMoveMemory(DA, pData + 4, MAC_ADDR_LEN);
+		NdisMoveMemory(SA, pData + 10, MAC_ADDR_LEN);
+	} else if (to_ds == 1 && from_ds == 0) {
+		NdisMoveMemory(SA, pData + 10, MAC_ADDR_LEN);
+		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);
+		NdisMoveMemory(DA, pData + 16, MAC_ADDR_LEN);
+	} else if (to_ds == 1 && from_ds == 1) {
+		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);
+		NdisMoveMemory(DA, pData + 16, MAC_ADDR_LEN);
+		NdisMoveMemory(SA, pData + 22, MAC_ADDR_LEN);
 	}
 
 	num_blocks = (DataByteCnt - 16) / 16;
 	payload_remainder = (DataByteCnt - 16) % 16;
 
 	pnl = (*(pData + HeaderLen)) * 256 + *(pData + HeaderLen + 2);
-	pnh = *((PULONG)(pData + HeaderLen + 4));
+	pnh = *((PULONG) (pData + HeaderLen + 4));
 	pnh = cpu2le32(pnh);
 	RTMPTkipMixKey(pWpaKey[KeyID].Key, TA, pnl, pnh, RC4Key, p1k);
 
 	ARCFOUR_INIT(&ArcFourContext, RC4Key, 16);
 
-	ARCFOUR_DECRYPT(&ArcFourContext, pData + HeaderLen, pData + HeaderLen + 8, DataByteCnt - HeaderLen - 8);
+	ARCFOUR_DECRYPT(&ArcFourContext, pData + HeaderLen,
+			pData + HeaderLen + 8, DataByteCnt - HeaderLen - 8);
 	NdisMoveMemory(&trailfcs, pData + DataByteCnt - 8 - 4, 4);
-	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pData + HeaderLen, DataByteCnt - HeaderLen - 8 - 4);  //Skip IV+EIV 8 bytes & Skip last 4 bytes(FCS).
-	crc32 ^= 0xffffffff;             /* complement */
+	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pData + HeaderLen, DataByteCnt - HeaderLen - 8 - 4);	//Skip IV+EIV 8 bytes & Skip last 4 bytes(FCS).
+	crc32 ^= 0xffffffff;	/* complement */
 
-    if(crc32 != cpu2le32(trailfcs))
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("RTMPSoftDecryptTKIP, WEP Data ICV Error !\n"));	 //ICV error.
+	if (crc32 != cpu2le32(trailfcs)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("RTMPSoftDecryptTKIP, WEP Data ICV Error !\n"));	//ICV error.
 
 		return (FALSE);
 	}
 
 	NdisMoveMemory(TrailMIC, pData + DataByteCnt - 8 - 8 - 4, 8);
-	RTMPInitMICEngine(pAd, pWpaKey[KeyID].Key, DA, SA, UserPriority, pWpaKey[KeyID].RxMic);
-	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pData + HeaderLen, DataByteCnt - HeaderLen - 8 - 12);
+	RTMPInitMICEngine(pAd, pWpaKey[KeyID].Key, DA, SA, UserPriority,
+			  pWpaKey[KeyID].RxMic);
+	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pData + HeaderLen,
+		       DataByteCnt - HeaderLen - 8 - 12);
 	RTMPTkipGetMIC(&pAd->PrivateInfo.Tx);
 	NdisMoveMemory(MIC, pAd->PrivateInfo.Tx.MIC, 8);
 
-	if (!NdisEqualMemory(MIC, TrailMIC, 8))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptTKIP, WEP Data MIC Error !\n"));	 //MIC error.
-		//RTMPReportMicError(pAd, &pWpaKey[KeyID]);	// marked by AlbertY @ 20060630
+	if (!NdisEqualMemory(MIC, TrailMIC, 8)) {
+		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptTKIP, WEP Data MIC Error !\n"));	//MIC error.
+		//RTMPReportMicError(pAd, &pWpaKey[KeyID]);     // marked by AlbertY @ 20060630
 		return (FALSE);
 	}
-
 	//DBGPRINT(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP Decript done!!\n");
 	return TRUE;
 }
--- a/drivers/staging/rt2860/common/cmm_wep.c
+++ b/drivers/staging/rt2860/common/cmm_wep.c
@@ -37,8 +37,7 @@
 
 #include	"../rt_config.h"
 
-UINT FCSTAB_32[256] =
-{
+UINT FCSTAB_32[256] = {
 	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
 	0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
 	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
@@ -136,33 +135,31 @@ UCHAR   WEPKEY[] = {
 
 	========================================================================
 */
-VOID	RTMPInitWepEngine(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pKey,
-	IN	UCHAR			KeyId,
-	IN	UCHAR			KeyLen,
-	IN OUT	PUCHAR		pDest)
+VOID RTMPInitWepEngine(IN PRTMP_ADAPTER pAd,
+		       IN PUCHAR pKey,
+		       IN UCHAR KeyId, IN UCHAR KeyLen, IN OUT PUCHAR pDest)
 {
 	UINT i;
-	UCHAR   WEPKEY[] = {
+	UCHAR WEPKEY[] = {
 		//IV
 		0x00, 0x11, 0x22,
 		//WEP KEY
-		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC
+		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
+		    0xAA, 0xBB, 0xCC
 	};
 
-	pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;   //Init crc32.
+	pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;	//Init crc32.
 
-    {
+	{
 		NdisMoveMemory(WEPKEY + 3, pKey, KeyLen);
 
-        for(i = 0; i < 3; i++)
-			WEPKEY[i] = RandomByte(pAd);   //Call mlme RandomByte() function.
-		ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, WEPKEY, KeyLen + 3);  //INIT SBOX, KEYLEN+3(IV)
-
-		NdisMoveMemory(pDest, WEPKEY, 3);  //Append Init Vector
-    }
-	*(pDest+3) = (KeyId << 6);       //Append KEYID
+		for (i = 0; i < 3; i++)
+			WEPKEY[i] = RandomByte(pAd);	//Call mlme RandomByte() function.
+		ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, WEPKEY, KeyLen + 3);	//INIT SBOX, KEYLEN+3(IV)
+
+		NdisMoveMemory(pDest, WEPKEY, 3);	//Append Init Vector
+	}
+	*(pDest + 3) = (KeyId << 6);	//Append KEYID
 
 }
 
@@ -187,17 +184,14 @@ VOID	RTMPInitWepEngine(
 
 	========================================================================
 */
-VOID	RTMPEncryptData(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pSrc,
-	IN	PUCHAR			pDest,
-	IN	UINT			Len)
+VOID RTMPEncryptData(IN PRTMP_ADAPTER pAd,
+		     IN PUCHAR pSrc, IN PUCHAR pDest, IN UINT Len)
 {
-	pAd->PrivateInfo.FCSCRC32 = RTMP_CALC_FCS32(pAd->PrivateInfo.FCSCRC32, pSrc, Len);
+	pAd->PrivateInfo.FCSCRC32 =
+	    RTMP_CALC_FCS32(pAd->PrivateInfo.FCSCRC32, pSrc, Len);
 	ARCFOUR_ENCRYPT(&pAd->PrivateInfo.WEPCONTEXT, pDest, pSrc, Len);
 }
 
-
 /*
 	========================================================================
 
@@ -217,40 +211,41 @@ VOID	RTMPEncryptData(
 
 	========================================================================
 */
-BOOLEAN	RTMPSoftDecryptWEP(
-	IN PRTMP_ADAPTER	pAd,
-	IN PUCHAR			pData,
-	IN ULONG			DataByteCnt,
-	IN PCIPHER_KEY		pGroupKey)
-{
-	UINT	trailfcs;
-	UINT    crc32;
-	UCHAR	KeyIdx;
-	UCHAR   WEPKEY[] = {
+BOOLEAN RTMPSoftDecryptWEP(IN PRTMP_ADAPTER pAd,
+			   IN PUCHAR pData,
+			   IN ULONG DataByteCnt, IN PCIPHER_KEY pGroupKey)
+{
+	UINT trailfcs;
+	UINT crc32;
+	UCHAR KeyIdx;
+	UCHAR WEPKEY[] = {
 		//IV
 		0x00, 0x11, 0x22,
 		//WEP KEY
-		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC
+		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
+		    0xAA, 0xBB, 0xCC
 	};
-	UCHAR	*pPayload = (UCHAR *)pData + LENGTH_802_11;
-	ULONG	payload_len = DataByteCnt - LENGTH_802_11;
+	UCHAR *pPayload = (UCHAR *) pData + LENGTH_802_11;
+	ULONG payload_len = DataByteCnt - LENGTH_802_11;
 
-	NdisMoveMemory(WEPKEY, pPayload, 3);    //Get WEP IV
+	NdisMoveMemory(WEPKEY, pPayload, 3);	//Get WEP IV
 
 	KeyIdx = (*(pPayload + 3) & 0xc0) >> 6;
 	if (pGroupKey[KeyIdx].KeyLen == 0)
 		return (FALSE);
 
-	NdisMoveMemory(WEPKEY + 3, pGroupKey[KeyIdx].Key, pGroupKey[KeyIdx].KeyLen);
-	ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, WEPKEY, pGroupKey[KeyIdx].KeyLen + 3);
-	ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, pPayload, pPayload + 4, payload_len - 4);
+	NdisMoveMemory(WEPKEY + 3, pGroupKey[KeyIdx].Key,
+		       pGroupKey[KeyIdx].KeyLen);
+	ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, WEPKEY,
+		     pGroupKey[KeyIdx].KeyLen + 3);
+	ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, pPayload, pPayload + 4,
+			payload_len - 4);
 	NdisMoveMemory(&trailfcs, pPayload + payload_len - 8, 4);
-	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pPayload, payload_len - 8);  //Skip last 4 bytes(FCS).
-	crc32 ^= 0xffffffff;             /* complement */
+	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pPayload, payload_len - 8);	//Skip last 4 bytes(FCS).
+	crc32 ^= 0xffffffff;	/* complement */
 
-    if(crc32 != cpu2le32(trailfcs))
-    {
-		DBGPRINT(RT_DEBUG_TRACE, ("! WEP Data CRC Error !\n"));	 //CRC error.
+	if (crc32 != cpu2le32(trailfcs)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("! WEP Data CRC Error !\n"));	//CRC error.
 		return (FALSE);
 	}
 	return (TRUE);
@@ -276,26 +271,22 @@ BOOLEAN	RTMPSoftDecryptWEP(
 
 	========================================================================
 */
-VOID	ARCFOUR_INIT(
-	IN	PARCFOURCONTEXT	Ctx,
-	IN	PUCHAR			pKey,
-	IN	UINT			KeyLen)
+VOID ARCFOUR_INIT(IN PARCFOURCONTEXT Ctx, IN PUCHAR pKey, IN UINT KeyLen)
 {
-	UCHAR	t, u;
-	UINT	keyindex;
-	UINT	stateindex;
-	PUCHAR	state;
-	UINT	counter;
+	UCHAR t, u;
+	UINT keyindex;
+	UINT stateindex;
+	PUCHAR state;
+	UINT counter;
 
 	state = Ctx->STATE;
 	Ctx->X = 0;
 	Ctx->Y = 0;
 	for (counter = 0; counter < 256; counter++)
-		state[counter] = (UCHAR)counter;
+		state[counter] = (UCHAR) counter;
 	keyindex = 0;
 	stateindex = 0;
-	for (counter = 0; counter < 256; counter++)
-	{
+	for (counter = 0; counter < 256; counter++) {
 		t = state[counter];
 		stateindex = (stateindex + pKey[keyindex] + t) & 0xff;
 		u = state[stateindex];
@@ -322,25 +313,24 @@ VOID	ARCFOUR_INIT(
 
 	========================================================================
 */
-UCHAR	ARCFOUR_BYTE(
-	IN	PARCFOURCONTEXT		Ctx)
+UCHAR ARCFOUR_BYTE(IN PARCFOURCONTEXT Ctx)
 {
-  UINT x;
-  UINT y;
-  UCHAR sx, sy;
-  PUCHAR state;
-
-  state = Ctx->STATE;
-  x = (Ctx->X + 1) & 0xff;
-  sx = state[x];
-  y = (sx + Ctx->Y) & 0xff;
-  sy = state[y];
-  Ctx->X = x;
-  Ctx->Y = y;
-  state[y] = sx;
-  state[x] = sy;
+	UINT x;
+	UINT y;
+	UCHAR sx, sy;
+	PUCHAR state;
+
+	state = Ctx->STATE;
+	x = (Ctx->X + 1) & 0xff;
+	sx = state[x];
+	y = (sx + Ctx->Y) & 0xff;
+	sy = state[y];
+	Ctx->X = x;
+	Ctx->Y = y;
+	state[y] = sx;
+	state[x] = sy;
 
-  return(state[(sx + sy) & 0xff]);
+	return (state[(sx + sy) & 0xff]);
 
 }
 
@@ -363,11 +353,8 @@ UCHAR	ARCFOUR_BYTE(
 
 	========================================================================
 */
-VOID	ARCFOUR_DECRYPT(
-	IN	PARCFOURCONTEXT	Ctx,
-	IN	PUCHAR			pDest,
-	IN	PUCHAR			pSrc,
-	IN	UINT			Len)
+VOID ARCFOUR_DECRYPT(IN PARCFOURCONTEXT Ctx,
+		     IN PUCHAR pDest, IN PUCHAR pSrc, IN UINT Len)
 {
 	UINT i;
 
@@ -396,11 +383,8 @@ VOID	ARCFOUR_DECRYPT(
 
 	========================================================================
 */
-VOID	ARCFOUR_ENCRYPT(
-	IN	PARCFOURCONTEXT	Ctx,
-	IN	PUCHAR			pDest,
-	IN	PUCHAR			pSrc,
-	IN	UINT			Len)
+VOID ARCFOUR_ENCRYPT(IN PARCFOURCONTEXT Ctx,
+		     IN PUCHAR pDest, IN PUCHAR pSrc, IN UINT Len)
 {
 	UINT i;
 
@@ -420,26 +404,21 @@ VOID	ARCFOUR_ENCRYPT(
 		pSrc        Pointer to the Source data
 		Len         Indicate the length of the Source dta
 
-
 	========================================================================
 */
 
-VOID	WPAARCFOUR_ENCRYPT(
-	IN	PARCFOURCONTEXT	Ctx,
-	IN	PUCHAR			pDest,
-	IN	PUCHAR			pSrc,
-	IN	UINT			Len)
+VOID WPAARCFOUR_ENCRYPT(IN PARCFOURCONTEXT Ctx,
+			IN PUCHAR pDest, IN PUCHAR pSrc, IN UINT Len)
 {
 	UINT i;
-        //discard first 256 bytes
+	//discard first 256 bytes
 	for (i = 0; i < 256; i++)
-            ARCFOUR_BYTE(Ctx);
+		ARCFOUR_BYTE(Ctx);
 
 	for (i = 0; i < Len; i++)
 		pDest[i] = pSrc[i] ^ ARCFOUR_BYTE(Ctx);
 }
 
-
 /*
 	========================================================================
 
@@ -460,18 +439,14 @@ VOID	WPAARCFOUR_ENCRYPT(
 
 	========================================================================
 */
-UINT	RTMP_CALC_FCS32(
-	IN	UINT	Fcs,
-	IN	PUCHAR	Cp,
-	IN	INT		Len)
+UINT RTMP_CALC_FCS32(IN UINT Fcs, IN PUCHAR Cp, IN INT Len)
 {
 	while (Len--)
-	   Fcs = (((Fcs) >> 8) ^ FCSTAB_32[((Fcs) ^ (*Cp++)) & 0xff]);
+		Fcs = (((Fcs) >> 8) ^ FCSTAB_32[((Fcs) ^ (*Cp++)) & 0xff]);
 
 	return (Fcs);
 }
 
-
 /*
 	========================================================================
 
@@ -488,12 +463,11 @@ UINT	RTMP_CALC_FCS32(
 
 	========================================================================
 */
-VOID	RTMPSetICV(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR	pDest)
+VOID RTMPSetICV(IN PRTMP_ADAPTER pAd, IN PUCHAR pDest)
 {
-	pAd->PrivateInfo.FCSCRC32 ^= 0xffffffff;             /* complement */
+	pAd->PrivateInfo.FCSCRC32 ^= 0xffffffff;	/* complement */
 	pAd->PrivateInfo.FCSCRC32 = cpu2le32(pAd->PrivateInfo.FCSCRC32);
 
-	ARCFOUR_ENCRYPT(&pAd->PrivateInfo.WEPCONTEXT, pDest, (PUCHAR) &pAd->PrivateInfo.FCSCRC32, 4);
+	ARCFOUR_ENCRYPT(&pAd->PrivateInfo.WEPCONTEXT, pDest,
+			(PUCHAR) & pAd->PrivateInfo.FCSCRC32, 4);
 }
--- a/drivers/staging/rt2860/common/cmm_wpa.c
+++ b/drivers/staging/rt2860/common/cmm_wpa.c
@@ -37,59 +37,47 @@
 */
 #include "../rt_config.h"
 // WPA OUI
-UCHAR		OUI_WPA_NONE_AKM[4]		= {0x00, 0x50, 0xF2, 0x00};
-UCHAR       OUI_WPA_VERSION[4]      = {0x00, 0x50, 0xF2, 0x01};
-UCHAR       OUI_WPA_WEP40[4]      = {0x00, 0x50, 0xF2, 0x01};
-UCHAR       OUI_WPA_TKIP[4]     = {0x00, 0x50, 0xF2, 0x02};
-UCHAR       OUI_WPA_CCMP[4]     = {0x00, 0x50, 0xF2, 0x04};
-UCHAR       OUI_WPA_WEP104[4]      = {0x00, 0x50, 0xF2, 0x05};
-UCHAR       OUI_WPA_8021X_AKM[4]	= {0x00, 0x50, 0xF2, 0x01};
-UCHAR       OUI_WPA_PSK_AKM[4]      = {0x00, 0x50, 0xF2, 0x02};
+UCHAR OUI_WPA_NONE_AKM[4] = { 0x00, 0x50, 0xF2, 0x00 };
+UCHAR OUI_WPA_VERSION[4] = { 0x00, 0x50, 0xF2, 0x01 };
+UCHAR OUI_WPA_WEP40[4] = { 0x00, 0x50, 0xF2, 0x01 };
+UCHAR OUI_WPA_TKIP[4] = { 0x00, 0x50, 0xF2, 0x02 };
+UCHAR OUI_WPA_CCMP[4] = { 0x00, 0x50, 0xF2, 0x04 };
+UCHAR OUI_WPA_WEP104[4] = { 0x00, 0x50, 0xF2, 0x05 };
+UCHAR OUI_WPA_8021X_AKM[4] = { 0x00, 0x50, 0xF2, 0x01 };
+UCHAR OUI_WPA_PSK_AKM[4] = { 0x00, 0x50, 0xF2, 0x02 };
+
 // WPA2 OUI
-UCHAR       OUI_WPA2_WEP40[4]   = {0x00, 0x0F, 0xAC, 0x01};
-UCHAR       OUI_WPA2_TKIP[4]        = {0x00, 0x0F, 0xAC, 0x02};
-UCHAR       OUI_WPA2_CCMP[4]        = {0x00, 0x0F, 0xAC, 0x04};
-UCHAR       OUI_WPA2_8021X_AKM[4]   = {0x00, 0x0F, 0xAC, 0x01};
-UCHAR       OUI_WPA2_PSK_AKM[4]   	= {0x00, 0x0F, 0xAC, 0x02};
-UCHAR       OUI_WPA2_WEP104[4]   = {0x00, 0x0F, 0xAC, 0x05};
+UCHAR OUI_WPA2_WEP40[4] = { 0x00, 0x0F, 0xAC, 0x01 };
+UCHAR OUI_WPA2_TKIP[4] = { 0x00, 0x0F, 0xAC, 0x02 };
+UCHAR OUI_WPA2_CCMP[4] = { 0x00, 0x0F, 0xAC, 0x04 };
+UCHAR OUI_WPA2_8021X_AKM[4] = { 0x00, 0x0F, 0xAC, 0x01 };
+UCHAR OUI_WPA2_PSK_AKM[4] = { 0x00, 0x0F, 0xAC, 0x02 };
+UCHAR OUI_WPA2_WEP104[4] = { 0x00, 0x0F, 0xAC, 0x05 };
+
+static VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
+				  IN UCHAR GroupKeyWepStatus,
+				  IN UCHAR keyDescVer,
+				  IN UCHAR MsgType,
+				  IN UCHAR DefaultKeyIdx,
+				  IN UCHAR * GTK,
+				  IN UCHAR * RSNIE,
+				  IN UCHAR RSNIE_LEN, OUT PEAPOL_PACKET pMsg);
+
+static VOID CalculateMIC(IN UCHAR KeyDescVer,
+			 IN UCHAR * PTK, OUT PEAPOL_PACKET pMsg);
+
+static VOID WpaEAPPacketAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+static VOID WpaEAPOLASFAlertAction(IN PRTMP_ADAPTER pAd,
+				   IN MLME_QUEUE_ELEM * Elem);
 
+static VOID WpaEAPOLLogoffAction(IN PRTMP_ADAPTER pAd,
+				 IN MLME_QUEUE_ELEM * Elem);
 
+static VOID WpaEAPOLStartAction(IN PRTMP_ADAPTER pAd,
+				IN MLME_QUEUE_ELEM * Elem);
 
-static VOID	ConstructEapolKeyData(
-	IN	PMAC_TABLE_ENTRY	pEntry,
-	IN	UCHAR			GroupKeyWepStatus,
-	IN	UCHAR			keyDescVer,
-	IN	UCHAR			MsgType,
-	IN	UCHAR			DefaultKeyIdx,
-	IN	UCHAR			*GTK,
-	IN	UCHAR			*RSNIE,
-	IN	UCHAR			RSNIE_LEN,
-	OUT PEAPOL_PACKET   pMsg);
-
-static VOID	CalculateMIC(
-	IN	UCHAR			KeyDescVer,
-	IN	UCHAR			*PTK,
-	OUT PEAPOL_PACKET   pMsg);
-
-static VOID WpaEAPPacketAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-static VOID WpaEAPOLASFAlertAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-static VOID WpaEAPOLLogoffAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-static VOID WpaEAPOLStartAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem);
-
-static VOID WpaEAPOLKeyAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem);
+static VOID WpaEAPOLKeyAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
 /*
     ==========================================================================
@@ -99,18 +87,23 @@ static VOID WpaEAPOLKeyAction(
         S - pointer to the association state machine
     ==========================================================================
  */
-VOID WpaStateMachineInit(
-    IN  PRTMP_ADAPTER   pAd,
-    IN  STATE_MACHINE *S,
-    OUT STATE_MACHINE_FUNC Trans[])
-{
-    StateMachineInit(S, (STATE_MACHINE_FUNC *)Trans, MAX_WPA_PTK_STATE, MAX_WPA_MSG, (STATE_MACHINE_FUNC)Drop, WPA_PTK, WPA_MACHINE_BASE);
-
-    StateMachineSetAction(S, WPA_PTK, MT2_EAPPacket, (STATE_MACHINE_FUNC)WpaEAPPacketAction);
-    StateMachineSetAction(S, WPA_PTK, MT2_EAPOLStart, (STATE_MACHINE_FUNC)WpaEAPOLStartAction);
-    StateMachineSetAction(S, WPA_PTK, MT2_EAPOLLogoff, (STATE_MACHINE_FUNC)WpaEAPOLLogoffAction);
-    StateMachineSetAction(S, WPA_PTK, MT2_EAPOLKey, (STATE_MACHINE_FUNC)WpaEAPOLKeyAction);
-    StateMachineSetAction(S, WPA_PTK, MT2_EAPOLASFAlert, (STATE_MACHINE_FUNC)WpaEAPOLASFAlertAction);
+VOID WpaStateMachineInit(IN PRTMP_ADAPTER pAd,
+			 IN STATE_MACHINE * S, OUT STATE_MACHINE_FUNC Trans[])
+{
+	StateMachineInit(S, (STATE_MACHINE_FUNC *) Trans, MAX_WPA_PTK_STATE,
+			 MAX_WPA_MSG, (STATE_MACHINE_FUNC) Drop, WPA_PTK,
+			 WPA_MACHINE_BASE);
+
+	StateMachineSetAction(S, WPA_PTK, MT2_EAPPacket,
+			      (STATE_MACHINE_FUNC) WpaEAPPacketAction);
+	StateMachineSetAction(S, WPA_PTK, MT2_EAPOLStart,
+			      (STATE_MACHINE_FUNC) WpaEAPOLStartAction);
+	StateMachineSetAction(S, WPA_PTK, MT2_EAPOLLogoff,
+			      (STATE_MACHINE_FUNC) WpaEAPOLLogoffAction);
+	StateMachineSetAction(S, WPA_PTK, MT2_EAPOLKey,
+			      (STATE_MACHINE_FUNC) WpaEAPOLKeyAction);
+	StateMachineSetAction(S, WPA_PTK, MT2_EAPOLASFAlert,
+			      (STATE_MACHINE_FUNC) WpaEAPOLASFAlertAction);
 }
 
 /*
@@ -122,21 +115,15 @@ VOID WpaStateMachineInit(
     Return:
     ==========================================================================
 */
-VOID WpaEAPPacketAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID WpaEAPPacketAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 }
 
-VOID WpaEAPOLASFAlertAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID WpaEAPOLASFAlertAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 }
 
-VOID WpaEAPOLLogoffAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID WpaEAPOLLogoffAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 }
 
@@ -147,42 +134,44 @@ VOID WpaEAPOLLogoffAction(
     Return:
     ==========================================================================
 */
-VOID WpaEAPOLStartAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem)
-{
-    MAC_TABLE_ENTRY     *pEntry;
-    PHEADER_802_11      pHeader;
-
-    DBGPRINT(RT_DEBUG_TRACE, ("WpaEAPOLStartAction ===> \n"));
-
-    pHeader = (PHEADER_802_11)Elem->Msg;
-
-    //For normaol PSK, we enqueue an EAPOL-Start command to trigger the process.
-    if (Elem->MsgLen == 6)
-        pEntry = MacTableLookup(pAd, Elem->Msg);
-    else
-    {
-        pEntry = MacTableLookup(pAd, pHeader->Addr2);
-    }
-
-    if (pEntry)
-    {
-		DBGPRINT(RT_DEBUG_TRACE, (" PortSecured(%d), WpaState(%d), AuthMode(%d), PMKID_CacheIdx(%d) \n", pEntry->PortSecured, pEntry->WpaState, pEntry->AuthMode, pEntry->PMKID_CacheIdx));
-
-        if ((pEntry->PortSecured == WPA_802_1X_PORT_NOT_SECURED)
-			&& (pEntry->WpaState < AS_PTKSTART)
-            && ((pEntry->AuthMode == Ndis802_11AuthModeWPAPSK) || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK) || ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) && (pEntry->PMKID_CacheIdx != ENTRY_NOT_FOUND))))
-        {
-            pEntry->PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
-            pEntry->WpaState = AS_INITPSK;
-            pEntry->PortSecured = WPA_802_1X_PORT_NOT_SECURED;
-            NdisZeroMemory(pEntry->R_Counter, sizeof(pEntry->R_Counter));
-            pEntry->ReTryCounter = PEER_MSG1_RETRY_TIMER_CTR;
-
-            WPAStart4WayHS(pAd, pEntry, PEER_MSG1_RETRY_EXEC_INTV);
-        }
-    }
+VOID WpaEAPOLStartAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
+{
+	MAC_TABLE_ENTRY *pEntry;
+	PHEADER_802_11 pHeader;
+
+	DBGPRINT(RT_DEBUG_TRACE, ("WpaEAPOLStartAction ===> \n"));
+
+	pHeader = (PHEADER_802_11) Elem->Msg;
+
+	//For normaol PSK, we enqueue an EAPOL-Start command to trigger the process.
+	if (Elem->MsgLen == 6)
+		pEntry = MacTableLookup(pAd, Elem->Msg);
+	else {
+		pEntry = MacTableLookup(pAd, pHeader->Addr2);
+	}
+
+	if (pEntry) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 (" PortSecured(%d), WpaState(%d), AuthMode(%d), PMKID_CacheIdx(%d) \n",
+			  pEntry->PortSecured, pEntry->WpaState,
+			  pEntry->AuthMode, pEntry->PMKID_CacheIdx));
+
+		if ((pEntry->PortSecured == WPA_802_1X_PORT_NOT_SECURED)
+		    && (pEntry->WpaState < AS_PTKSTART)
+		    && ((pEntry->AuthMode == Ndis802_11AuthModeWPAPSK)
+			|| (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)
+			|| ((pEntry->AuthMode == Ndis802_11AuthModeWPA2)
+			    && (pEntry->PMKID_CacheIdx != ENTRY_NOT_FOUND)))) {
+			pEntry->PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
+			pEntry->WpaState = AS_INITPSK;
+			pEntry->PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+			NdisZeroMemory(pEntry->R_Counter,
+				       sizeof(pEntry->R_Counter));
+			pEntry->ReTryCounter = PEER_MSG1_RETRY_TIMER_CTR;
+
+			WPAStart4WayHS(pAd, pEntry, PEER_MSG1_RETRY_EXEC_INTV);
+		}
+	}
 }
 
 /*
@@ -198,138 +187,154 @@ VOID WpaEAPOLStartAction(
     Return:
     ==========================================================================
 */
-VOID WpaEAPOLKeyAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem)
+VOID WpaEAPOLKeyAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-    MAC_TABLE_ENTRY     *pEntry;
-    PHEADER_802_11      pHeader;
-    PEAPOL_PACKET       pEapol_packet;
-	KEY_INFO			peerKeyInfo;
+	MAC_TABLE_ENTRY *pEntry;
+	PHEADER_802_11 pHeader;
+	PEAPOL_PACKET pEapol_packet;
+	KEY_INFO peerKeyInfo;
 
-    DBGPRINT(RT_DEBUG_TRACE, ("WpaEAPOLKeyAction ===>\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("WpaEAPOLKeyAction ===>\n"));
 
-    pHeader = (PHEADER_802_11)Elem->Msg;
-    pEapol_packet = (PEAPOL_PACKET)&Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+	pHeader = (PHEADER_802_11) Elem->Msg;
+	pEapol_packet =
+	    (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 
-	NdisZeroMemory((PUCHAR)&peerKeyInfo, sizeof(peerKeyInfo));
-	NdisMoveMemory((PUCHAR)&peerKeyInfo, (PUCHAR)&pEapol_packet->KeyDesc.KeyInfo, sizeof(KEY_INFO));
+	NdisZeroMemory((PUCHAR) & peerKeyInfo, sizeof(peerKeyInfo));
+	NdisMoveMemory((PUCHAR) & peerKeyInfo,
+		       (PUCHAR) & pEapol_packet->KeyDesc.KeyInfo,
+		       sizeof(KEY_INFO));
 
-	hex_dump("Received Eapol frame", (unsigned char *)pEapol_packet, (Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H));
+	hex_dump("Received Eapol frame", (unsigned char *)pEapol_packet,
+		 (Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H));
 
-	*((USHORT *)&peerKeyInfo) = cpu2le16(*((USHORT *)&peerKeyInfo));
+	*((USHORT *) & peerKeyInfo) = cpu2le16(*((USHORT *) & peerKeyInfo));
 
-    do
-    {
-        pEntry = MacTableLookup(pAd, pHeader->Addr2);
+	do {
+		pEntry = MacTableLookup(pAd, pHeader->Addr2);
 
-		if (!pEntry || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
-            break;
+		if (!pEntry
+		    || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
+			break;
 
 		if (pEntry->AuthMode < Ndis802_11AuthModeWPA)
-				break;
-
-		DBGPRINT(RT_DEBUG_TRACE, ("Receive EAPoL-Key frame from STA %02X-%02X-%02X-%02X-%02X-%02X\n", PRINT_MAC(pEntry->Addr)));
-
-        if (((pEapol_packet->ProVer != EAPOL_VER) && (pEapol_packet->ProVer != EAPOL_VER2)) ||
-			((pEapol_packet->KeyDesc.Type != WPA1_KEY_DESC) && (pEapol_packet->KeyDesc.Type != WPA2_KEY_DESC)))
-        {
-            DBGPRINT(RT_DEBUG_ERROR, ("Key descripter does not match with WPA rule\n"));
-            break;
-        }
+			break;
 
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Receive EAPoL-Key frame from STA %02X-%02X-%02X-%02X-%02X-%02X\n",
+			  PRINT_MAC(pEntry->Addr)));
+
+		if (((pEapol_packet->ProVer != EAPOL_VER)
+		     && (pEapol_packet->ProVer != EAPOL_VER2))
+		    || ((pEapol_packet->KeyDesc.Type != WPA1_KEY_DESC)
+			&& (pEapol_packet->KeyDesc.Type != WPA2_KEY_DESC))) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Key descripter does not match with WPA rule\n"));
+			break;
+		}
 		// The value 1 shall be used for all EAPOL-Key frames to and from a STA when
 		// neither the group nor pairwise ciphers are CCMP for Key Descriptor 1.
-		if ((pEntry->WepStatus == Ndis802_11Encryption2Enabled) && (peerKeyInfo.KeyDescVer != DESC_TYPE_TKIP))
-        {
-	        DBGPRINT(RT_DEBUG_ERROR, ("Key descripter version not match(TKIP) \n"));
-	    break;
-	}
+		if ((pEntry->WepStatus == Ndis802_11Encryption2Enabled)
+		    && (peerKeyInfo.KeyDescVer != DESC_TYPE_TKIP)) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Key descripter version not match(TKIP) \n"));
+			break;
+		}
 		// The value 2 shall be used for all EAPOL-Key frames to and from a STA when
 		// either the pairwise or the group cipher is AES-CCMP for Key Descriptor 2.
-	else if ((pEntry->WepStatus == Ndis802_11Encryption3Enabled) && (peerKeyInfo.KeyDescVer != DESC_TYPE_AES))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("Key descripter version not match(AES) \n"));
-		break;
-	}
-
+		else if ((pEntry->WepStatus == Ndis802_11Encryption3Enabled)
+			 && (peerKeyInfo.KeyDescVer != DESC_TYPE_AES)) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Key descripter version not match(AES) \n"));
+			break;
+		}
 		// Check if this STA is in class 3 state and the WPA state is started
-        if ((pEntry->Sst == SST_ASSOC) && (pEntry->WpaState >= AS_INITPSK))
-        {
+		if ((pEntry->Sst == SST_ASSOC)
+		    && (pEntry->WpaState >= AS_INITPSK)) {
 			// Check the Key Ack (bit 7) of the Key Information to determine the Authenticator
 			// or not.
 			// An EAPOL-Key frame that is sent by the Supplicant in response to an EAPOL-
 			// Key frame from the Authenticator must not have the Ack bit set.
-			if (peerKeyInfo.KeyAck == 1)
-			{
+			if (peerKeyInfo.KeyAck == 1) {
 				// The frame is snet by Authenticator.
 				// So the Supplicant side shall handle this.
 
-				if ((peerKeyInfo.Secure == 0) && (peerKeyInfo.Request == 0) &&
-					(peerKeyInfo.Error == 0) && (peerKeyInfo.KeyType == PAIRWISEKEY))
-				{
+				if ((peerKeyInfo.Secure == 0)
+				    && (peerKeyInfo.Request == 0)
+				    && (peerKeyInfo.Error == 0)
+				    && (peerKeyInfo.KeyType == PAIRWISEKEY)) {
 					// Process 1. the message 1 of 4-way HS in WPA or WPA2
-					//			  EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1)
-					//		   2. the message 3 of 4-way HS in WPA
-					//			  EAPOL-Key(0,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3)
+					//                        EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1)
+					//                 2. the message 3 of 4-way HS in WPA
+					//                        EAPOL-Key(0,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3)
 					if (peerKeyInfo.KeyMic == 0)
-			PeerPairMsg1Action(pAd, pEntry, Elem);
-	                else
-	                PeerPairMsg3Action(pAd, pEntry, Elem);
-				}
-				else if ((peerKeyInfo.Secure == 1) &&
-						 (peerKeyInfo.KeyMic == 1) &&
-						 (peerKeyInfo.Request == 0) &&
-						 (peerKeyInfo.Error == 0))
-				{
+						PeerPairMsg1Action(pAd, pEntry,
+								   Elem);
+					else
+						PeerPairMsg3Action(pAd, pEntry,
+								   Elem);
+				} else if ((peerKeyInfo.Secure == 1)
+					   && (peerKeyInfo.KeyMic == 1)
+					   && (peerKeyInfo.Request == 0)
+					   && (peerKeyInfo.Error == 0)) {
 					// Process 1. the message 3 of 4-way HS in WPA2
-					//			  EAPOL-Key(1,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3)
-					//		   2. the message 1 of group KS in WPA or WPA2
-					//			  EAPOL-Key(1,1,1,0,G,0,Key RSC,0, MIC,GTK[N])
+					//                        EAPOL-Key(1,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3)
+					//                 2. the message 1 of group KS in WPA or WPA2
+					//                        EAPOL-Key(1,1,1,0,G,0,Key RSC,0, MIC,GTK[N])
 					if (peerKeyInfo.KeyType == PAIRWISEKEY)
-						PeerPairMsg3Action(pAd, pEntry, Elem);
+						PeerPairMsg3Action(pAd, pEntry,
+								   Elem);
 					else
-						PeerGroupMsg1Action(pAd, pEntry, Elem);
+						PeerGroupMsg1Action(pAd, pEntry,
+								    Elem);
 				}
-			}
-			else
-			{
+			} else {
 				// The frame is snet by Supplicant.
 				// So the Authenticator side shall handle this.
 				if ((peerKeyInfo.Request == 0) &&
-						 (peerKeyInfo.Error == 0) &&
-						 (peerKeyInfo.KeyMic == 1))
-				{
-					if (peerKeyInfo.Secure == 0 && peerKeyInfo.KeyType == PAIRWISEKEY)
-					{
+				    (peerKeyInfo.Error == 0) &&
+				    (peerKeyInfo.KeyMic == 1)) {
+					if (peerKeyInfo.Secure == 0
+					    && peerKeyInfo.KeyType ==
+					    PAIRWISEKEY) {
 						// EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,Data)
 						// Process 1. message 2 of 4-way HS in WPA or WPA2
-						//		   2. message 4 of 4-way HS in WPA
-						if (CONV_ARRARY_TO_UINT16(pEapol_packet->KeyDesc.KeyDataLen) == 0)
-						{
-							PeerPairMsg4Action(pAd, pEntry, Elem);
-			}
-						else
-						{
-							PeerPairMsg2Action(pAd, pEntry, Elem);
+						//                 2. message 4 of 4-way HS in WPA
+						if (CONV_ARRARY_TO_UINT16
+						    (pEapol_packet->KeyDesc.
+						     KeyDataLen) == 0) {
+							PeerPairMsg4Action(pAd,
+									   pEntry,
+									   Elem);
+						} else {
+							PeerPairMsg2Action(pAd,
+									   pEntry,
+									   Elem);
 						}
-					}
-					else if (peerKeyInfo.Secure == 1 && peerKeyInfo.KeyType == PAIRWISEKEY)
-					{
+					} else if (peerKeyInfo.Secure == 1
+						   && peerKeyInfo.KeyType ==
+						   PAIRWISEKEY) {
 						// EAPOL-Key(1,1,0,0,P,0,0,0,MIC,0)
 						// Process message 4 of 4-way HS in WPA2
-						PeerPairMsg4Action(pAd, pEntry, Elem);
-					}
-					else if (peerKeyInfo.Secure == 1 && peerKeyInfo.KeyType == GROUPKEY)
-					{
+						PeerPairMsg4Action(pAd, pEntry,
+								   Elem);
+					} else if (peerKeyInfo.Secure == 1
+						   && peerKeyInfo.KeyType ==
+						   GROUPKEY) {
 						// EAPOL-Key(1,1,0,0,G,0,0,0,MIC,0)
 						// Process message 2 of Group key HS in WPA or WPA2
-						PeerGroupMsg2Action(pAd, pEntry, &Elem->Msg[LENGTH_802_11], (Elem->MsgLen - LENGTH_802_11));
+						PeerGroupMsg2Action(pAd, pEntry,
+								    &Elem->
+								    Msg
+								    [LENGTH_802_11],
+								    (Elem->
+								     MsgLen -
+								     LENGTH_802_11));
 					}
 				}
 			}
-        }
-    }while(FALSE);
+		}
+	} while (FALSE);
 }
 
 /*
@@ -352,66 +357,71 @@ VOID WpaEAPOLKeyAction(
 
 	========================================================================
 */
-VOID    RTMPToWirelessSta(
-    IN  PRTMP_ADAPTER		pAd,
-    IN  PMAC_TABLE_ENTRY	pEntry,
-    IN  PUCHAR			pHeader802_3,
-    IN  UINT			HdrLen,
-    IN  PUCHAR			pData,
-    IN  UINT			DataLen,
-    IN	BOOLEAN				bClearFrame)
+VOID RTMPToWirelessSta(IN PRTMP_ADAPTER pAd,
+		       IN PMAC_TABLE_ENTRY pEntry,
+		       IN PUCHAR pHeader802_3,
+		       IN UINT HdrLen,
+		       IN PUCHAR pData, IN UINT DataLen, IN BOOLEAN bClearFrame)
 {
-    PNDIS_PACKET    pPacket;
-    NDIS_STATUS     Status;
+	PNDIS_PACKET pPacket;
+	NDIS_STATUS Status;
 
 	if ((!pEntry) || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
 		return;
 
-    do {
+	do {
 		// build a NDIS packet
-		Status = RTMPAllocateNdisPacket(pAd, &pPacket, pHeader802_3, HdrLen, pData, DataLen);
+		Status =
+		    RTMPAllocateNdisPacket(pAd, &pPacket, pHeader802_3, HdrLen,
+					   pData, DataLen);
 		if (Status != NDIS_STATUS_SUCCESS)
-		break;
-
+			break;
 
-			if (bClearFrame)
-				RTMP_SET_PACKET_CLEAR_EAP_FRAME(pPacket, 1);
-			else
-				RTMP_SET_PACKET_CLEAR_EAP_FRAME(pPacket, 0);
+		if (bClearFrame)
+			RTMP_SET_PACKET_CLEAR_EAP_FRAME(pPacket, 1);
+		else
+			RTMP_SET_PACKET_CLEAR_EAP_FRAME(pPacket, 0);
 		{
 			RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
 
 			RTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket, MAIN_MBSSID);	// set a default value
-			if(pEntry->apidx != 0)
-			RTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket, pEntry->apidx);
+			if (pEntry->apidx != 0)
+				RTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket,
+								  pEntry->
+								  apidx);
 
-		RTMP_SET_PACKET_WCID(pPacket, (UCHAR)pEntry->Aid);
+			RTMP_SET_PACKET_WCID(pPacket, (UCHAR) pEntry->Aid);
 			RTMP_SET_PACKET_MOREDATA(pPacket, FALSE);
 		}
 
 		{
-		    // send out the packet
-	        Status = STASendPacket(pAd, pPacket);
-	    if (Status == NDIS_STATUS_SUCCESS)
-			{
-				UCHAR   Index;
+			// send out the packet
+			Status = STASendPacket(pAd, pPacket);
+			if (Status == NDIS_STATUS_SUCCESS) {
+				UCHAR Index;
 
 				// Dequeue one frame from TxSwQueue0..3 queue and process it
 				// There are three place calling dequeue for TX ring.
 				// 1. Here, right after queueing the frame.
 				// 2. At the end of TxRingTxDone service routine.
 				// 3. Upon NDIS call RTMPSendPackets
-				if((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) &&
-					(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)))
-				{
-					for(Index = 0; Index < 5; Index ++)
-						if(pAd->TxSwQueue[Index].Number > 0)
-							RTMPDeQueuePacket(pAd, FALSE, Index, MAX_TX_PROCESS);
+				if ((!RTMP_TEST_FLAG
+				     (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+				    &&
+				    (!RTMP_TEST_FLAG
+				     (pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS))) {
+					for (Index = 0; Index < 5; Index++)
+						if (pAd->TxSwQueue[Index].
+						    Number > 0)
+							RTMPDeQueuePacket(pAd,
+									  FALSE,
+									  Index,
+									  MAX_TX_PROCESS);
 				}
 			}
 		}
 
-    } while (FALSE);
+	} while (FALSE);
 }
 
 /*
@@ -423,74 +433,69 @@ VOID    RTMPToWirelessSta(
 
     ==========================================================================
 */
-VOID WPAStart4WayHS(
-    IN PRTMP_ADAPTER    pAd,
-    IN MAC_TABLE_ENTRY  *pEntry,
-    IN ULONG			TimeInterval)
-{
-    UCHAR           Header802_3[14];
-    EAPOL_PACKET	EAPOLPKT;
-	PUINT8			pBssid = NULL;
-	UCHAR			group_cipher = Ndis802_11WEPDisabled;
-
-    DBGPRINT(RT_DEBUG_TRACE, ("===> WPAStart4WayHS\n"));
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS | fRTMP_ADAPTER_HALT_IN_PROGRESS))
+VOID WPAStart4WayHS(IN PRTMP_ADAPTER pAd,
+		    IN MAC_TABLE_ENTRY * pEntry, IN ULONG TimeInterval)
+{
+	UCHAR Header802_3[14];
+	EAPOL_PACKET EAPOLPKT;
+	PUINT8 pBssid = NULL;
+	UCHAR group_cipher = Ndis802_11WEPDisabled;
+
+	DBGPRINT(RT_DEBUG_TRACE, ("===> WPAStart4WayHS\n"));
+
+	if (RTMP_TEST_FLAG
+	    (pAd,
+	     fRTMP_ADAPTER_RESET_IN_PROGRESS | fRTMP_ADAPTER_HALT_IN_PROGRESS))
 	{
-		DBGPRINT(RT_DEBUG_ERROR, ("[ERROR]WPAStart4WayHS : The interface is closed...\n"));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("[ERROR]WPAStart4WayHS : The interface is closed...\n"));
 		return;
 	}
 
-
-	if (pBssid == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("[ERROR]WPAStart4WayHS : No corresponding Authenticator.\n"));
+	if (pBssid == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("[ERROR]WPAStart4WayHS : No corresponding Authenticator.\n"));
 		return;
-    }
-
+	}
 	// Check the status
-    if ((pEntry->WpaState > AS_PTKSTART) || (pEntry->WpaState < AS_INITPMK))
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("[ERROR]WPAStart4WayHS : Not expect calling\n"));
-        return;
-    }
-
+	if ((pEntry->WpaState > AS_PTKSTART) || (pEntry->WpaState < AS_INITPMK)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("[ERROR]WPAStart4WayHS : Not expect calling\n"));
+		return;
+	}
 
 	// Increment replay counter by 1
 	ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
 
 	// Randomly generate ANonce
-	GenRandom(pAd, (UCHAR *)pBssid, pEntry->ANonce);
+	GenRandom(pAd, (UCHAR *) pBssid, pEntry->ANonce);
 
 	// Construct EAPoL message - Pairwise Msg 1
 	// EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1)
 	NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
-	ConstructEapolMsg(pEntry,
-					  group_cipher,
-					  EAPOL_PAIR_MSG_1,
-					  0,					// Default key index
-					  pEntry->ANonce,
-					  NULL,					// TxRSC
-					  NULL,					// GTK
-					  NULL,					// RSNIE
-					  0,					// RSNIE length
-					  &EAPOLPKT);
-
+	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_1, 0,	// Default key index
+			  pEntry->ANonce, NULL,	// TxRSC
+			  NULL,	// GTK
+			  NULL,	// RSNIE
+			  0,	// RSNIE length
+			  &EAPOLPKT);
 
 	// Make outgoing frame
-    MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
-    RTMPToWirelessSta(pAd, pEntry, Header802_3,
-					  LENGTH_802_3, (PUCHAR)&EAPOLPKT,
-					  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4,
-					  (pEntry->PortSecured == WPA_802_1X_PORT_SECURED) ? FALSE : TRUE);
+	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
+	RTMPToWirelessSta(pAd, pEntry, Header802_3,
+			  LENGTH_802_3, (PUCHAR) & EAPOLPKT,
+			  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4,
+			  (pEntry->PortSecured ==
+			   WPA_802_1X_PORT_SECURED) ? FALSE : TRUE);
 
 	// Trigger Retry Timer
-    RTMPModTimer(&pEntry->RetryTimer, TimeInterval);
+	RTMPModTimer(&pEntry->RetryTimer, TimeInterval);
 
 	// Update State
-    pEntry->WpaState = AS_PTKSTART;
+	pEntry->WpaState = AS_PTKSTART;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== WPAStart4WayHS: send Msg1 of 4-way \n"));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<=== WPAStart4WayHS: send Msg1 of 4-way \n"));
 
 }
 
@@ -511,29 +516,29 @@ VOID WPAStart4WayHS(
 
 	========================================================================
 */
-VOID PeerPairMsg1Action(
-	IN PRTMP_ADAPTER    pAd,
-    IN MAC_TABLE_ENTRY  *pEntry,
-    IN MLME_QUEUE_ELEM  *Elem)
-{
-	UCHAR				PTK[80];
-	UCHAR               Header802_3[14];
-	PEAPOL_PACKET		pMsg1;
-	UINT			MsgLen;
-	EAPOL_PACKET		EAPOLPKT;
-	PUINT8				pCurrentAddr = NULL;
-	PUINT8				pmk_ptr = NULL;
-	UCHAR				group_cipher = Ndis802_11WEPDisabled;
-	PUINT8				rsnie_ptr = NULL;
-	UCHAR				rsnie_len = 0;
+VOID PeerPairMsg1Action(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem)
+{
+	UCHAR PTK[80];
+	UCHAR Header802_3[14];
+	PEAPOL_PACKET pMsg1;
+	UINT MsgLen;
+	EAPOL_PACKET EAPOLPKT;
+	PUINT8 pCurrentAddr = NULL;
+	PUINT8 pmk_ptr = NULL;
+	UCHAR group_cipher = Ndis802_11WEPDisabled;
+	PUINT8 rsnie_ptr = NULL;
+	UCHAR rsnie_len = 0;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg1Action \n"));
 
 	if ((!pEntry) || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
 		return;
 
-    if (Elem->MsgLen < (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H + sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
-        return;
+	if (Elem->MsgLen <
+	    (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H +
+	     sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
+		return;
 
 	{
 		pCurrentAddr = pAd->CurrentAddress;
@@ -544,32 +549,32 @@ VOID PeerPairMsg1Action(
 	}
 
 	// Store the received frame
-	pMsg1 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+	pMsg1 = (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
 	// Sanity Check peer Pairwise message 1 - Replay Counter
-	if (PeerWpaMessageSanity(pAd, pMsg1, MsgLen, EAPOL_PAIR_MSG_1, pEntry) == FALSE)
+	if (PeerWpaMessageSanity(pAd, pMsg1, MsgLen, EAPOL_PAIR_MSG_1, pEntry)
+	    == FALSE)
 		return;
 
 	// Store Replay counter, it will use to verify message 3 and construct message 2
-	NdisMoveMemory(pEntry->R_Counter, pMsg1->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+	NdisMoveMemory(pEntry->R_Counter, pMsg1->KeyDesc.ReplayCounter,
+		       LEN_KEY_DESC_REPLAY);
 
 	// Store ANonce
-	NdisMoveMemory(pEntry->ANonce, pMsg1->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE);
+	NdisMoveMemory(pEntry->ANonce, pMsg1->KeyDesc.KeyNonce,
+		       LEN_KEY_DESC_NONCE);
 
 	// Generate random SNonce
-	GenRandom(pAd, (UCHAR *)pCurrentAddr, pEntry->SNonce);
+	GenRandom(pAd, (UCHAR *) pCurrentAddr, pEntry->SNonce);
 
 	{
-	    // Calculate PTK(ANonce, SNonce)
-	    WpaDerivePTK(pAd,
-				pmk_ptr,
-				pEntry->ANonce,
-					pEntry->Addr,
-					pEntry->SNonce,
-					pCurrentAddr,
-				    PTK,
-				    LEN_PTK);
+		// Calculate PTK(ANonce, SNonce)
+		WpaDerivePTK(pAd,
+			     pmk_ptr,
+			     pEntry->ANonce,
+			     pEntry->Addr,
+			     pEntry->SNonce, pCurrentAddr, PTK, LEN_PTK);
 
 		// Save key to PTK entry
 		NdisMoveMemory(pEntry->PTK, PTK, LEN_PTK);
@@ -581,28 +586,22 @@ VOID PeerPairMsg1Action(
 	// Construct EAPoL message - Pairwise Msg 2
 	//  EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,DataKD_M2)
 	NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
-	ConstructEapolMsg(pEntry,
-					  group_cipher,
-					  EAPOL_PAIR_MSG_2,
-					  0,				// DefaultKeyIdx
-					  pEntry->SNonce,
-					  NULL,				// TxRsc
-					  NULL,				// GTK
-					  (UCHAR *)rsnie_ptr,
-					  rsnie_len,
-					  &EAPOLPKT);
+	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_2, 0,	// DefaultKeyIdx
+			  pEntry->SNonce, NULL,	// TxRsc
+			  NULL,	// GTK
+			  (UCHAR *) rsnie_ptr, rsnie_len, &EAPOLPKT);
 
 	// Make outgoing frame
 	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
 
 	RTMPToWirelessSta(pAd, pEntry,
-					  Header802_3, sizeof(Header802_3), (PUCHAR)&EAPOLPKT,
-					  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4, TRUE);
+			  Header802_3, sizeof(Header802_3), (PUCHAR) & EAPOLPKT,
+			  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4, TRUE);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== PeerPairMsg1Action: send Msg2 of 4-way \n"));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<=== PeerPairMsg1Action: send Msg2 of 4-way \n"));
 }
 
-
 /*
     ==========================================================================
     Description:
@@ -610,76 +609,70 @@ VOID PeerPairMsg1Action(
     Return:
     ==========================================================================
 */
-VOID PeerPairMsg2Action(
-    IN PRTMP_ADAPTER    pAd,
-    IN MAC_TABLE_ENTRY  *pEntry,
-    IN MLME_QUEUE_ELEM  *Elem)
-{
-	UCHAR				PTK[80];
-    BOOLEAN             Cancelled;
-    PHEADER_802_11      pHeader;
-	EAPOL_PACKET        EAPOLPKT;
-	PEAPOL_PACKET       pMsg2;
-	UINT			MsgLen;
-    UCHAR               Header802_3[LENGTH_802_3];
-	UCHAR				TxTsc[6];
-	PUINT8				pBssid = NULL;
-	PUINT8				pmk_ptr = NULL;
-	PUINT8				gtk_ptr = NULL;
-	UCHAR				default_key = 0;
-	UCHAR				group_cipher = Ndis802_11WEPDisabled;
-	PUINT8				rsnie_ptr = NULL;
-	UCHAR				rsnie_len = 0;
-
-    DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg2Action \n"));
-
-    if ((!pEntry) || (!pEntry->ValidAsCLI))
-        return;
-
-    if (Elem->MsgLen < (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H + sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
-        return;
-
-    // check Entry in valid State
-    if (pEntry->WpaState < AS_PTKSTART)
-        return;
+VOID PeerPairMsg2Action(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem)
+{
+	UCHAR PTK[80];
+	BOOLEAN Cancelled;
+	PHEADER_802_11 pHeader;
+	EAPOL_PACKET EAPOLPKT;
+	PEAPOL_PACKET pMsg2;
+	UINT MsgLen;
+	UCHAR Header802_3[LENGTH_802_3];
+	UCHAR TxTsc[6];
+	PUINT8 pBssid = NULL;
+	PUINT8 pmk_ptr = NULL;
+	PUINT8 gtk_ptr = NULL;
+	UCHAR default_key = 0;
+	UCHAR group_cipher = Ndis802_11WEPDisabled;
+	PUINT8 rsnie_ptr = NULL;
+	UCHAR rsnie_len = 0;
+
+	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg2Action \n"));
 
+	if ((!pEntry) || (!pEntry->ValidAsCLI))
+		return;
 
+	if (Elem->MsgLen <
+	    (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H +
+	     sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
+		return;
 
-    // pointer to 802.11 header
-	pHeader = (PHEADER_802_11)Elem->Msg;
+	// check Entry in valid State
+	if (pEntry->WpaState < AS_PTKSTART)
+		return;
+
+	// pointer to 802.11 header
+	pHeader = (PHEADER_802_11) Elem->Msg;
 
 	// skip 802.11_header(24-byte) and LLC_header(8)
-	pMsg2 = (PEAPOL_PACKET)&Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+	pMsg2 = (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
 	// Store SNonce
-	NdisMoveMemory(pEntry->SNonce, pMsg2->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE);
+	NdisMoveMemory(pEntry->SNonce, pMsg2->KeyDesc.KeyNonce,
+		       LEN_KEY_DESC_NONCE);
 
 	{
 		// Derive PTK
-		WpaDerivePTK(pAd,
-					(UCHAR *)pmk_ptr,
-					pEntry->ANonce,			// ANONCE
-					(UCHAR *)pBssid,
-					pEntry->SNonce,			// SNONCE
-					pEntry->Addr,
-					PTK,
-					LEN_PTK);
+		WpaDerivePTK(pAd, (UCHAR *) pmk_ptr, pEntry->ANonce,	// ANONCE
+			     (UCHAR *) pBssid, pEntry->SNonce,	// SNONCE
+			     pEntry->Addr, PTK, LEN_PTK);
 
-	NdisMoveMemory(pEntry->PTK, PTK, LEN_PTK);
+		NdisMoveMemory(pEntry->PTK, PTK, LEN_PTK);
 	}
 
 	// Sanity Check peer Pairwise message 2 - Replay Counter, MIC, RSNIE
-	if (PeerWpaMessageSanity(pAd, pMsg2, MsgLen, EAPOL_PAIR_MSG_2, pEntry) == FALSE)
+	if (PeerWpaMessageSanity(pAd, pMsg2, MsgLen, EAPOL_PAIR_MSG_2, pEntry)
+	    == FALSE)
 		return;
 
-    do
-    {
-        // delete retry timer
+	do {
+		// delete retry timer
 		RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
 
 		// Change state
-        pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
+		pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
 
 		// Increment replay counter by 1
 		ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
@@ -687,31 +680,31 @@ VOID PeerPairMsg2Action(
 		// Construct EAPoL message - Pairwise Msg 3
 		NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
 		ConstructEapolMsg(pEntry,
-						  group_cipher,
-						  EAPOL_PAIR_MSG_3,
-						  default_key,
-						  pEntry->ANonce,
-						  TxTsc,
-						  (UCHAR *)gtk_ptr,
-						  (UCHAR *)rsnie_ptr,
-						  rsnie_len,
-						  &EAPOLPKT);
-
-        // Make outgoing frame
-        MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
-        RTMPToWirelessSta(pAd, pEntry, Header802_3, LENGTH_802_3,
-						  (PUCHAR)&EAPOLPKT,
-						  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4,
-						  (pEntry->PortSecured == WPA_802_1X_PORT_SECURED) ? FALSE : TRUE);
+				  group_cipher,
+				  EAPOL_PAIR_MSG_3,
+				  default_key,
+				  pEntry->ANonce,
+				  TxTsc,
+				  (UCHAR *) gtk_ptr,
+				  (UCHAR *) rsnie_ptr, rsnie_len, &EAPOLPKT);
 
-        pEntry->ReTryCounter = PEER_MSG3_RETRY_TIMER_CTR;
+		// Make outgoing frame
+		MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
+		RTMPToWirelessSta(pAd, pEntry, Header802_3, LENGTH_802_3,
+				  (PUCHAR) & EAPOLPKT,
+				  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4,
+				  (pEntry->PortSecured ==
+				   WPA_802_1X_PORT_SECURED) ? FALSE : TRUE);
+
+		pEntry->ReTryCounter = PEER_MSG3_RETRY_TIMER_CTR;
 		RTMPSetTimer(&pEntry->RetryTimer, PEER_MSG3_RETRY_EXEC_INTV);
 
 		// Update State
-        pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
-    }while(FALSE);
+		pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
+	} while (FALSE);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== PeerPairMsg2Action: send Msg3 of 4-way \n"));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<=== PeerPairMsg2Action: send Msg3 of 4-way \n"));
 }
 
 /*
@@ -731,25 +724,25 @@ VOID PeerPairMsg2Action(
 
 	========================================================================
 */
-VOID PeerPairMsg3Action(
-    IN PRTMP_ADAPTER    pAd,
-    IN MAC_TABLE_ENTRY  *pEntry,
-    IN MLME_QUEUE_ELEM  *Elem)
-{
-	PHEADER_802_11		pHeader;
-	UCHAR               Header802_3[14];
-	EAPOL_PACKET		EAPOLPKT;
-	PEAPOL_PACKET		pMsg3;
-	UINT			MsgLen;
-	PUINT8				pCurrentAddr = NULL;
-	UCHAR				group_cipher = Ndis802_11WEPDisabled;
+VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem)
+{
+	PHEADER_802_11 pHeader;
+	UCHAR Header802_3[14];
+	EAPOL_PACKET EAPOLPKT;
+	PEAPOL_PACKET pMsg3;
+	UINT MsgLen;
+	PUINT8 pCurrentAddr = NULL;
+	UCHAR group_cipher = Ndis802_11WEPDisabled;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg3Action \n"));
 
 	if ((!pEntry) || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
 		return;
 
-    if (Elem->MsgLen < (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H + sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
+	if (Elem->MsgLen <
+	    (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H +
+	     sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
 		return;
 
 	{
@@ -759,35 +752,32 @@ VOID PeerPairMsg3Action(
 	}
 
 	// Record 802.11 header & the received EAPOL packet Msg3
-	pHeader	= (PHEADER_802_11) Elem->Msg;
-	pMsg3 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+	pHeader = (PHEADER_802_11) Elem->Msg;
+	pMsg3 = (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
 	// Sanity Check peer Pairwise message 3 - Replay Counter, MIC, RSNIE
-	if (PeerWpaMessageSanity(pAd, pMsg3, MsgLen, EAPOL_PAIR_MSG_3, pEntry) == FALSE)
+	if (PeerWpaMessageSanity(pAd, pMsg3, MsgLen, EAPOL_PAIR_MSG_3, pEntry)
+	    == FALSE)
 		return;
 
 	// Save Replay counter, it will use construct message 4
-	NdisMoveMemory(pEntry->R_Counter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+	NdisMoveMemory(pEntry->R_Counter, pMsg3->KeyDesc.ReplayCounter,
+		       LEN_KEY_DESC_REPLAY);
 
 	// Double check ANonce
-	if (!NdisEqualMemory(pEntry->ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE))
-	{
+	if (!NdisEqualMemory
+	    (pEntry->ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE)) {
 		return;
 	}
-
 	// Construct EAPoL message - Pairwise Msg 4
 	NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
-	ConstructEapolMsg(pEntry,
-					  group_cipher,
-					  EAPOL_PAIR_MSG_4,
-					  0,					// group key index not used in message 4
-					  NULL,					// Nonce not used in message 4
-					  NULL,					// TxRSC not used in message 4
-					  NULL,					// GTK not used in message 4
-					  NULL,					// RSN IE not used in message 4
-					  0,
-					  &EAPOLPKT);
+	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_4, 0,	// group key index not used in message 4
+			  NULL,	// Nonce not used in message 4
+			  NULL,	// TxRSC not used in message 4
+			  NULL,	// GTK not used in message 4
+			  NULL,	// RSN IE not used in message 4
+			  0, &EAPOLPKT);
 
 	// Update WpaState
 	pEntry->WpaState = AS_PTKINITDONE;
@@ -803,9 +793,13 @@ VOID PeerPairMsg3Action(
 		// Prepare pair-wise key information into shared key table
 		NdisZeroMemory(pSharedKey, sizeof(CIPHER_KEY));
 		pSharedKey->KeyLen = LEN_TKIP_EK;
-	    NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32], LEN_TKIP_EK);
-		NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.PTK[48], LEN_TKIP_RXMICK);
-		NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.PTK[48+LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
+		NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32],
+			       LEN_TKIP_EK);
+		NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.PTK[48],
+			       LEN_TKIP_RXMICK);
+		NdisMoveMemory(pSharedKey->TxMic,
+			       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK],
+			       LEN_TKIP_TXMICK);
 
 		// Decide its ChiperAlg
 		if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
@@ -817,56 +811,56 @@ VOID PeerPairMsg3Action(
 
 		// Update these related information to MAC_TABLE_ENTRY
 		pEntry = &pAd->MacTab.Content[BSSID_WCID];
-		NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32], LEN_TKIP_EK);
-		NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pAd->StaCfg.PTK[48], LEN_TKIP_RXMICK);
-		NdisMoveMemory(pEntry->PairwiseKey.TxMic, &pAd->StaCfg.PTK[48+LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
+		NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32],
+			       LEN_TKIP_EK);
+		NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pAd->StaCfg.PTK[48],
+			       LEN_TKIP_RXMICK);
+		NdisMoveMemory(pEntry->PairwiseKey.TxMic,
+			       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK],
+			       LEN_TKIP_TXMICK);
 		pEntry->PairwiseKey.CipherAlg = pSharedKey->CipherAlg;
 
 		// Update pairwise key information to ASIC Shared Key Table
 		AsicAddSharedKeyEntry(pAd,
-							  BSS0,
-							  0,
-							  pSharedKey->CipherAlg,
-							  pSharedKey->Key,
-							  pSharedKey->TxMic,
-							  pSharedKey->RxMic);
+				      BSS0,
+				      0,
+				      pSharedKey->CipherAlg,
+				      pSharedKey->Key,
+				      pSharedKey->TxMic, pSharedKey->RxMic);
 
 		// Update ASIC WCID attribute table and IVEIV table
 		RTMPAddWcidAttributeEntry(pAd,
-								  BSS0,
-								  0,
-								  pSharedKey->CipherAlg,
-								  pEntry);
+					  BSS0,
+					  0, pSharedKey->CipherAlg, pEntry);
 
 	}
 
 	// open 802.1x port control and privacy filter
 	if (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK ||
-		pEntry->AuthMode == Ndis802_11AuthModeWPA2)
-	{
+	    pEntry->AuthMode == Ndis802_11AuthModeWPA2) {
 		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
 		pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
 
 		STA_PORT_SECURED(pAd);
-	    // Indicate Connected for GUI
-	    pAd->IndicateMediaState = NdisMediaStateConnected;
-		DBGPRINT(RT_DEBUG_TRACE, ("PeerPairMsg3Action: AuthMode(%s) PairwiseCipher(%s) GroupCipher(%s) \n",
-									GetAuthMode(pEntry->AuthMode),
-									GetEncryptType(pEntry->WepStatus),
-									GetEncryptType(group_cipher)));
-	}
-	else
-	{
+		// Indicate Connected for GUI
+		pAd->IndicateMediaState = NdisMediaStateConnected;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("PeerPairMsg3Action: AuthMode(%s) PairwiseCipher(%s) GroupCipher(%s) \n",
+			  GetAuthMode(pEntry->AuthMode),
+			  GetEncryptType(pEntry->WepStatus),
+			  GetEncryptType(group_cipher)));
+	} else {
 	}
 
 	// Init 802.3 header and send out
 	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
 	RTMPToWirelessSta(pAd, pEntry,
-					  Header802_3, sizeof(Header802_3),
-					  (PUCHAR)&EAPOLPKT,
-					  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4, TRUE);
+			  Header802_3, sizeof(Header802_3),
+			  (PUCHAR) & EAPOLPKT,
+			  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4, TRUE);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== PeerPairMsg3Action: send Msg4 of 4-way \n"));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<=== PeerPairMsg3Action: send Msg4 of 4-way \n"));
 }
 
 /*
@@ -877,109 +871,114 @@ VOID PeerPairMsg3Action(
     Return:
     ==========================================================================
 */
-VOID PeerPairMsg4Action(
-    IN PRTMP_ADAPTER    pAd,
-    IN MAC_TABLE_ENTRY  *pEntry,
-    IN MLME_QUEUE_ELEM  *Elem)
+VOID PeerPairMsg4Action(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem)
 {
-	PEAPOL_PACKET		pMsg4;
-    PHEADER_802_11      pHeader;
-    UINT		MsgLen;
-    BOOLEAN             Cancelled;
-	UCHAR				group_cipher = Ndis802_11WEPDisabled;
-
-    DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg4Action\n"));
+	PEAPOL_PACKET pMsg4;
+	PHEADER_802_11 pHeader;
+	UINT MsgLen;
+	BOOLEAN Cancelled;
+	UCHAR group_cipher = Ndis802_11WEPDisabled;
 
-    do
-    {
-        if ((!pEntry) || (!pEntry->ValidAsCLI))
-            break;
+	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerPairMsg4Action\n"));
 
-        if (Elem->MsgLen < (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H + sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2 ) )
-            break;
+	do {
+		if ((!pEntry) || (!pEntry->ValidAsCLI))
+			break;
 
-        if (pEntry->WpaState < AS_PTKINIT_NEGOTIATING)
-            break;
+		if (Elem->MsgLen <
+		    (LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H +
+		     sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
+			break;
 
+		if (pEntry->WpaState < AS_PTKINIT_NEGOTIATING)
+			break;
 
-        // pointer to 802.11 header
-        pHeader = (PHEADER_802_11)Elem->Msg;
+		// pointer to 802.11 header
+		pHeader = (PHEADER_802_11) Elem->Msg;
 
 		// skip 802.11_header(24-byte) and LLC_header(8)
-		pMsg4 = (PEAPOL_PACKET)&Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+		pMsg4 =
+		    (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 		MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
-        // Sanity Check peer Pairwise message 4 - Replay Counter, MIC
-		if (PeerWpaMessageSanity(pAd, pMsg4, MsgLen, EAPOL_PAIR_MSG_4, pEntry) == FALSE)
+		// Sanity Check peer Pairwise message 4 - Replay Counter, MIC
+		if (PeerWpaMessageSanity
+		    (pAd, pMsg4, MsgLen, EAPOL_PAIR_MSG_4, pEntry) == FALSE)
 			break;
 
-        // 3. uses the MLME.SETKEYS.request to configure PTK into MAC
-        NdisZeroMemory(&pEntry->PairwiseKey, sizeof(CIPHER_KEY));
+		// 3. uses the MLME.SETKEYS.request to configure PTK into MAC
+		NdisZeroMemory(&pEntry->PairwiseKey, sizeof(CIPHER_KEY));
 
 		// reset IVEIV in Asic
 		AsicUpdateWCIDIVEIV(pAd, pEntry->Aid, 1, 0);
 
-        pEntry->PairwiseKey.KeyLen = LEN_TKIP_EK;
-        NdisMoveMemory(pEntry->PairwiseKey.Key, &pEntry->PTK[32], LEN_TKIP_EK);
-        NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pEntry->PTK[TKIP_AP_RXMICK_OFFSET], LEN_TKIP_RXMICK);
-        NdisMoveMemory(pEntry->PairwiseKey.TxMic, &pEntry->PTK[TKIP_AP_TXMICK_OFFSET], LEN_TKIP_TXMICK);
+		pEntry->PairwiseKey.KeyLen = LEN_TKIP_EK;
+		NdisMoveMemory(pEntry->PairwiseKey.Key, &pEntry->PTK[32],
+			       LEN_TKIP_EK);
+		NdisMoveMemory(pEntry->PairwiseKey.RxMic,
+			       &pEntry->PTK[TKIP_AP_RXMICK_OFFSET],
+			       LEN_TKIP_RXMICK);
+		NdisMoveMemory(pEntry->PairwiseKey.TxMic,
+			       &pEntry->PTK[TKIP_AP_TXMICK_OFFSET],
+			       LEN_TKIP_TXMICK);
 
 		// Set pairwise key to Asic
-        {
-            pEntry->PairwiseKey.CipherAlg = CIPHER_NONE;
-            if (pEntry->WepStatus == Ndis802_11Encryption2Enabled)
-                pEntry->PairwiseKey.CipherAlg = CIPHER_TKIP;
-            else if (pEntry->WepStatus == Ndis802_11Encryption3Enabled)
-                pEntry->PairwiseKey.CipherAlg = CIPHER_AES;
+		{
+			pEntry->PairwiseKey.CipherAlg = CIPHER_NONE;
+			if (pEntry->WepStatus == Ndis802_11Encryption2Enabled)
+				pEntry->PairwiseKey.CipherAlg = CIPHER_TKIP;
+			else if (pEntry->WepStatus ==
+				 Ndis802_11Encryption3Enabled)
+				pEntry->PairwiseKey.CipherAlg = CIPHER_AES;
 
 			// Add Pair-wise key to Asic
-            AsicAddPairwiseKeyEntry(
-                pAd,
-                pEntry->Addr,
-                (UCHAR)pEntry->Aid,
-                &pEntry->PairwiseKey);
+			AsicAddPairwiseKeyEntry(pAd,
+						pEntry->Addr,
+						(UCHAR) pEntry->Aid,
+						&pEntry->PairwiseKey);
 
 			// update WCID attribute table and IVEIV table for this entry
-			RTMPAddWcidAttributeEntry(
-				pAd,
-				pEntry->apidx,
-				0,
-				pEntry->PairwiseKey.CipherAlg,
-				pEntry);
-        }
-
-        // 4. upgrade state
-        pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
-        pEntry->WpaState = AS_PTKINITDONE;
-		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
+			RTMPAddWcidAttributeEntry(pAd,
+						  pEntry->apidx,
+						  0,
+						  pEntry->PairwiseKey.CipherAlg,
+						  pEntry);
+		}
 
+		// 4. upgrade state
+		pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
+		pEntry->WpaState = AS_PTKINITDONE;
+		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
 
 		if (pEntry->AuthMode == Ndis802_11AuthModeWPA2 ||
-			pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)
-		{
+		    pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK) {
 			pEntry->GTKState = REKEY_ESTABLISHED;
 			RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
 
-
 			// send wireless event - for set key done WPA2
 			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_SET_KEY_DONE_WPA2_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0);
-
-	        DBGPRINT(RT_DEBUG_OFF, ("AP SETKEYS DONE - WPA2, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
-									pEntry->AuthMode, GetAuthMode(pEntry->AuthMode),
-									pEntry->WepStatus, GetEncryptType(pEntry->WepStatus),
-									group_cipher,
-									GetEncryptType(group_cipher)));
+				RTMPSendWirelessEvent(pAd,
+						      IW_SET_KEY_DONE_WPA2_EVENT_FLAG,
+						      pEntry->Addr,
+						      pEntry->apidx, 0);
+
+			DBGPRINT(RT_DEBUG_OFF,
+				 ("AP SETKEYS DONE - WPA2, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
+				  pEntry->AuthMode,
+				  GetAuthMode(pEntry->AuthMode),
+				  pEntry->WepStatus,
+				  GetEncryptType(pEntry->WepStatus),
+				  group_cipher, GetEncryptType(group_cipher)));
+		} else {
+			// 5. init Group 2-way handshake if necessary.
+			WPAStart2WayGroupHS(pAd, pEntry);
+
+			pEntry->ReTryCounter = GROUP_MSG1_RETRY_TIMER_CTR;
+			RTMPModTimer(&pEntry->RetryTimer,
+				     PEER_MSG3_RETRY_EXEC_INTV);
 		}
-		else
-		{
-		// 5. init Group 2-way handshake if necessary.
-	        WPAStart2WayGroupHS(pAd, pEntry);
-
-		pEntry->ReTryCounter = GROUP_MSG1_RETRY_TIMER_CTR;
-			RTMPModTimer(&pEntry->RetryTimer, PEER_MSG3_RETRY_EXEC_INTV);
-		}
-    }while(FALSE);
+	} while (FALSE);
 
 }
 
@@ -991,57 +990,49 @@ VOID PeerPairMsg4Action(
 
     ==========================================================================
 */
-VOID WPAStart2WayGroupHS(
-    IN PRTMP_ADAPTER    pAd,
-    IN MAC_TABLE_ENTRY  *pEntry)
-{
-    UCHAR               Header802_3[14];
-	UCHAR				TxTsc[6];
-    EAPOL_PACKET	EAPOLPKT;
-	UCHAR				group_cipher = Ndis802_11WEPDisabled;
-	UCHAR				default_key = 0;
-	PUINT8				gnonce_ptr = NULL;
-	PUINT8				gtk_ptr = NULL;
-	PUINT8				pBssid = NULL;
+VOID WPAStart2WayGroupHS(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry)
+{
+	UCHAR Header802_3[14];
+	UCHAR TxTsc[6];
+	EAPOL_PACKET EAPOLPKT;
+	UCHAR group_cipher = Ndis802_11WEPDisabled;
+	UCHAR default_key = 0;
+	PUINT8 gnonce_ptr = NULL;
+	PUINT8 gtk_ptr = NULL;
+	PUINT8 pBssid = NULL;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> WPAStart2WayGroupHS\n"));
 
-    if ((!pEntry) || (!pEntry->ValidAsCLI))
-        return;
-
+	if ((!pEntry) || (!pEntry->ValidAsCLI))
+		return;
 
-    do
-    {
-        // Increment replay counter by 1
+	do {
+		// Increment replay counter by 1
 		ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
 
 		// Construct EAPoL message - Group Msg 1
 		NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
 		ConstructEapolMsg(pEntry,
-						  group_cipher,
-						  EAPOL_GROUP_MSG_1,
-						  default_key,
-						  (UCHAR *)gnonce_ptr,
-						  TxTsc,
-						  (UCHAR *)gtk_ptr,
-						  NULL,
-						  0,
-						  &EAPOLPKT);
+				  group_cipher,
+				  EAPOL_GROUP_MSG_1,
+				  default_key,
+				  (UCHAR *) gnonce_ptr,
+				  TxTsc, (UCHAR *) gtk_ptr, NULL, 0, &EAPOLPKT);
 
 		// Make outgoing frame
-        MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
-        RTMPToWirelessSta(pAd, pEntry,
-						  Header802_3, LENGTH_802_3,
-						  (PUCHAR)&EAPOLPKT,
-						  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4, FALSE);
-
-
+		MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
+		RTMPToWirelessSta(pAd, pEntry,
+				  Header802_3, LENGTH_802_3,
+				  (PUCHAR) & EAPOLPKT,
+				  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4,
+				  FALSE);
 
-    }while (FALSE);
+	} while (FALSE);
 
-    DBGPRINT(RT_DEBUG_TRACE, ("<=== WPAStart2WayGroupHS : send out Group Message 1 \n"));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<=== WPAStart2WayGroupHS : send out Group Message 1 \n"));
 
-    return;
+	return;
 }
 
 /*
@@ -1061,24 +1052,22 @@ VOID WPAStart2WayGroupHS(
 
 	========================================================================
 */
-VOID	PeerGroupMsg1Action(
-	IN PRTMP_ADAPTER    pAd,
-    IN MAC_TABLE_ENTRY  *pEntry,
-    IN MLME_QUEUE_ELEM  *Elem)
-{
-    UCHAR               Header802_3[14];
-	EAPOL_PACKET		EAPOLPKT;
-	PEAPOL_PACKET		pGroup;
-	UINT			MsgLen;
-	BOOLEAN             Cancelled;
-	UCHAR				default_key = 0;
-	UCHAR				group_cipher = Ndis802_11WEPDisabled;
-	PUINT8				pCurrentAddr = NULL;
+VOID PeerGroupMsg1Action(IN PRTMP_ADAPTER pAd,
+			 IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem)
+{
+	UCHAR Header802_3[14];
+	EAPOL_PACKET EAPOLPKT;
+	PEAPOL_PACKET pGroup;
+	UINT MsgLen;
+	BOOLEAN Cancelled;
+	UCHAR default_key = 0;
+	UCHAR group_cipher = Ndis802_11WEPDisabled;
+	PUINT8 pCurrentAddr = NULL;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerGroupMsg1Action \n"));
 
 	if ((!pEntry) || ((!pEntry->ValidAsCLI) && (!pEntry->ValidAsApCli)))
-        return;
+		return;
 
 	{
 		pCurrentAddr = pAd->CurrentAddress;
@@ -1087,53 +1076,52 @@ VOID	PeerGroupMsg1Action(
 	}
 
 	// Process Group Message 1 frame. skip 802.11 header(24) & LLC_SNAP header(8)
-	pGroup = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+	pGroup = (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
 	// Sanity Check peer group message 1 - Replay Counter, MIC, RSNIE
-	if (PeerWpaMessageSanity(pAd, pGroup, MsgLen, EAPOL_GROUP_MSG_1, pEntry) == FALSE)
+	if (PeerWpaMessageSanity(pAd, pGroup, MsgLen, EAPOL_GROUP_MSG_1, pEntry)
+	    == FALSE)
 		return;
 
 	// delete retry timer
 	RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
 
 	// Save Replay counter, it will use to construct message 2
-	NdisMoveMemory(pEntry->R_Counter, pGroup->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+	NdisMoveMemory(pEntry->R_Counter, pGroup->KeyDesc.ReplayCounter,
+		       LEN_KEY_DESC_REPLAY);
 
 	// Construct EAPoL message - Group Msg 2
 	NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
-	ConstructEapolMsg(pEntry,
-					  group_cipher,
-					  EAPOL_GROUP_MSG_2,
-					  default_key,
-					  NULL,					// Nonce not used
-					  NULL,					// TxRSC not used
-					  NULL,					// GTK not used
-					  NULL,					// RSN IE not used
-					  0,
-					  &EAPOLPKT);
+	ConstructEapolMsg(pEntry, group_cipher, EAPOL_GROUP_MSG_2, default_key, NULL,	// Nonce not used
+			  NULL,	// TxRSC not used
+			  NULL,	// GTK not used
+			  NULL,	// RSN IE not used
+			  0, &EAPOLPKT);
 
-    // open 802.1x port control and privacy filter
+	// open 802.1x port control and privacy filter
 	pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
 	pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
 
 	STA_PORT_SECURED(pAd);
-    // Indicate Connected for GUI
-    pAd->IndicateMediaState = NdisMediaStateConnected;
+	// Indicate Connected for GUI
+	pAd->IndicateMediaState = NdisMediaStateConnected;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("PeerGroupMsg1Action: AuthMode(%s) PairwiseCipher(%s) GroupCipher(%s) \n",
-									GetAuthMode(pEntry->AuthMode),
-									GetEncryptType(pEntry->WepStatus),
-									GetEncryptType(group_cipher)));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("PeerGroupMsg1Action: AuthMode(%s) PairwiseCipher(%s) GroupCipher(%s) \n",
+		  GetAuthMode(pEntry->AuthMode),
+		  GetEncryptType(pEntry->WepStatus),
+		  GetEncryptType(group_cipher)));
 
 	// init header and Fill Packet and send Msg 2 to authenticator
 	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
 	RTMPToWirelessSta(pAd, pEntry,
-					  Header802_3, sizeof(Header802_3),
-					  (PUCHAR)&EAPOLPKT,
-					  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4, FALSE);
+			  Header802_3, sizeof(Header802_3),
+			  (PUCHAR) & EAPOLPKT,
+			  CONV_ARRARY_TO_UINT16(EAPOLPKT.Body_Len) + 4, FALSE);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("<=== PeerGroupMsg1Action: sned group message 2\n"));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<=== PeerGroupMsg1Action: sned group message 2\n"));
 }
 
 /*
@@ -1143,68 +1131,77 @@ VOID	PeerGroupMsg1Action(
     Return:
     ==========================================================================
 */
-VOID PeerGroupMsg2Action(
-    IN PRTMP_ADAPTER    pAd,
-    IN MAC_TABLE_ENTRY  *pEntry,
-    IN VOID             *Msg,
-    IN UINT             MsgLen)
-{
-    UINT		Len;
-    PUCHAR		pData;
-    BOOLEAN		Cancelled;
-	PEAPOL_PACKET       pMsg2;
-	UCHAR				group_cipher = Ndis802_11WEPDisabled;
+VOID PeerGroupMsg2Action(IN PRTMP_ADAPTER pAd,
+			 IN MAC_TABLE_ENTRY * pEntry,
+			 IN VOID * Msg, IN UINT MsgLen)
+{
+	UINT Len;
+	PUCHAR pData;
+	BOOLEAN Cancelled;
+	PEAPOL_PACKET pMsg2;
+	UCHAR group_cipher = Ndis802_11WEPDisabled;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> PeerGroupMsg2Action \n"));
 
-    do
-    {
-        if ((!pEntry) || (!pEntry->ValidAsCLI))
-            break;
-
-        if (MsgLen < (LENGTH_802_1_H + LENGTH_EAPOL_H + sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
-            break;
+	do {
+		if ((!pEntry) || (!pEntry->ValidAsCLI))
+			break;
 
-        if (pEntry->WpaState != AS_PTKINITDONE)
-            break;
+		if (MsgLen <
+		    (LENGTH_802_1_H + LENGTH_EAPOL_H + sizeof(KEY_DESCRIPTER) -
+		     MAX_LEN_OF_RSNIE - 2))
+			break;
 
+		if (pEntry->WpaState != AS_PTKINITDONE)
+			break;
 
-        pData = (PUCHAR)Msg;
+		pData = (PUCHAR) Msg;
 		pMsg2 = (PEAPOL_PACKET) (pData + LENGTH_802_1_H);
-        Len = MsgLen - LENGTH_802_1_H;
+		Len = MsgLen - LENGTH_802_1_H;
 
 		// Sanity Check peer group message 2 - Replay Counter, MIC
-		if (PeerWpaMessageSanity(pAd, pMsg2, Len, EAPOL_GROUP_MSG_2, pEntry) == FALSE)
-            break;
+		if (PeerWpaMessageSanity
+		    (pAd, pMsg2, Len, EAPOL_GROUP_MSG_2, pEntry) == FALSE)
+			break;
 
-        // 3.  upgrade state
+		// 3.  upgrade state
 
 		RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
-        pEntry->GTKState = REKEY_ESTABLISHED;
+		pEntry->GTKState = REKEY_ESTABLISHED;
 
-		if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
-		{
+		if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2)
+		    || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)) {
 			// send wireless event - for set key done WPA2
 			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_SET_KEY_DONE_WPA2_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0);
-
-			DBGPRINT(RT_DEBUG_OFF, ("AP SETKEYS DONE - WPA2, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
-										pEntry->AuthMode, GetAuthMode(pEntry->AuthMode),
-										pEntry->WepStatus, GetEncryptType(pEntry->WepStatus),
-										group_cipher, GetEncryptType(group_cipher)));
-		}
-		else
-		{
+				RTMPSendWirelessEvent(pAd,
+						      IW_SET_KEY_DONE_WPA2_EVENT_FLAG,
+						      pEntry->Addr,
+						      pEntry->apidx, 0);
+
+			DBGPRINT(RT_DEBUG_OFF,
+				 ("AP SETKEYS DONE - WPA2, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
+				  pEntry->AuthMode,
+				  GetAuthMode(pEntry->AuthMode),
+				  pEntry->WepStatus,
+				  GetEncryptType(pEntry->WepStatus),
+				  group_cipher, GetEncryptType(group_cipher)));
+		} else {
 			// send wireless event - for set key done WPA
 			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_SET_KEY_DONE_WPA1_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0);
-
-		DBGPRINT(RT_DEBUG_OFF, ("AP SETKEYS DONE - WPA1, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
-										pEntry->AuthMode, GetAuthMode(pEntry->AuthMode),
-										pEntry->WepStatus, GetEncryptType(pEntry->WepStatus),
-										group_cipher, GetEncryptType(group_cipher)));
+				RTMPSendWirelessEvent(pAd,
+						      IW_SET_KEY_DONE_WPA1_EVENT_FLAG,
+						      pEntry->Addr,
+						      pEntry->apidx, 0);
+
+			DBGPRINT(RT_DEBUG_OFF,
+				 ("AP SETKEYS DONE - WPA1, AuthMode(%d)=%s, WepStatus(%d)=%s, GroupWepStatus(%d)=%s\n\n",
+				  pEntry->AuthMode,
+				  GetAuthMode(pEntry->AuthMode),
+				  pEntry->WepStatus,
+				  GetEncryptType(pEntry->WepStatus),
+				  group_cipher, GetEncryptType(group_cipher)));
 		}
-    }while(FALSE);
+	} while (FALSE);
 }
 
 /*
@@ -1229,29 +1226,26 @@ VOID PeerGroupMsg2Action(
 
 	========================================================================
 */
-BOOLEAN	WpaMsgTypeSubst(
-	IN	UCHAR	EAPType,
-	OUT	INT		*MsgType)
+BOOLEAN WpaMsgTypeSubst(IN UCHAR EAPType, OUT INT * MsgType)
 {
-	switch (EAPType)
-	{
-		case EAPPacket:
-			*MsgType = MT2_EAPPacket;
-			break;
-		case EAPOLStart:
-			*MsgType = MT2_EAPOLStart;
-			break;
-		case EAPOLLogoff:
-			*MsgType = MT2_EAPOLLogoff;
-			break;
-		case EAPOLKey:
-			*MsgType = MT2_EAPOLKey;
-			break;
-		case EAPOLASFAlert:
-			*MsgType = MT2_EAPOLASFAlert;
-			break;
-		default:
-			return FALSE;
+	switch (EAPType) {
+	case EAPPacket:
+		*MsgType = MT2_EAPPacket;
+		break;
+	case EAPOLStart:
+		*MsgType = MT2_EAPOLStart;
+		break;
+	case EAPOLLogoff:
+		*MsgType = MT2_EAPOLLogoff;
+		break;
+	case EAPOLKey:
+		*MsgType = MT2_EAPOLKey;
+		break;
+	case EAPOLASFAlert:
+		*MsgType = MT2_EAPOLASFAlert;
+		break;
+	default:
+		return FALSE;
 	}
 	return TRUE;
 }
@@ -1283,39 +1277,33 @@ BOOLEAN	WpaMsgTypeSubst(
 
 	========================================================================
 */
-VOID	PRF(
-	IN	UCHAR	*key,
-	IN	INT		key_len,
-	IN	UCHAR	*prefix,
-	IN	INT		prefix_len,
-	IN	UCHAR	*data,
-	IN	INT		data_len,
-	OUT	UCHAR	*output,
-	IN	INT		len)
-{
-	INT		i;
-    UCHAR   *input;
-	INT		currentindex = 0;
-	INT		total_len;
+VOID PRF(IN UCHAR * key,
+	 IN INT key_len,
+	 IN UCHAR * prefix,
+	 IN INT prefix_len,
+	 IN UCHAR * data, IN INT data_len, OUT UCHAR * output, IN INT len)
+{
+	INT i;
+	UCHAR *input;
+	INT currentindex = 0;
+	INT total_len;
 
 	// Allocate memory for input
-	os_alloc_mem(NULL, (PUCHAR *)&input, 1024);
-
-    if (input == NULL)
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("!!!PRF: no memory!!!\n"));
-        return;
-    }
+	os_alloc_mem(NULL, (PUCHAR *) & input, 1024);
 
+	if (input == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR, ("!!!PRF: no memory!!!\n"));
+		return;
+	}
 	// Generate concatenation input
 	NdisMoveMemory(input, prefix, prefix_len);
 
 	// Concatenate a single octet containing 0
-	input[prefix_len] =	0;
+	input[prefix_len] = 0;
 
 	// Concatenate specific data
 	NdisMoveMemory(&input[prefix_len + 1], data, data_len);
-	total_len =	prefix_len + 1 + data_len;
+	total_len = prefix_len + 1 + data_len;
 
 	// Concatenate a single octet containing 0
 	// This octet shall be update later
@@ -1324,15 +1312,15 @@ VOID	PRF(
 
 	// Iterate to calculate the result by hmac-sha-1
 	// Then concatenate to last result
-	for	(i = 0;	i <	(len + 19) / 20; i++)
-	{
-		HMAC_SHA1(key, key_len, input, total_len, &output[currentindex], SHA1_DIGEST_SIZE);
-		currentindex +=	20;
+	for (i = 0; i < (len + 19) / 20; i++) {
+		HMAC_SHA1(key, key_len, input, total_len, &output[currentindex],
+			  SHA1_DIGEST_SIZE);
+		currentindex += 20;
 
 		// update the last octet
 		input[total_len - 1]++;
 	}
-    os_free_mem(NULL, input);
+	os_free_mem(NULL, input);
 }
 
 /*
@@ -1342,34 +1330,33 @@ VOID	PRF(
 * Uc = PRF(P, Uc-1)
 */
 
-static void F(char *password, unsigned char *ssid, int ssidlength, int iterations, int count, unsigned char *output)
+static void F(char *password, unsigned char *ssid, int ssidlength,
+	      int iterations, int count, unsigned char *output)
 {
-    unsigned char digest[36], digest1[SHA1_DIGEST_SIZE];
-    int i, j;
+	unsigned char digest[36], digest1[SHA1_DIGEST_SIZE];
+	int i, j;
 
-    /* U1 = PRF(P, S || int(i)) */
-    memcpy(digest, ssid, ssidlength);
-    digest[ssidlength] = (unsigned char)((count>>24) & 0xff);
-    digest[ssidlength+1] = (unsigned char)((count>>16) & 0xff);
-    digest[ssidlength+2] = (unsigned char)((count>>8) & 0xff);
-    digest[ssidlength+3] = (unsigned char)(count & 0xff);
-    HMAC_SHA1((unsigned char*) password, (int) strlen(password), digest, ssidlength+4, digest1, SHA1_DIGEST_SIZE); // for WPA update
-
-    /* output = U1 */
-    memcpy(output, digest1, SHA1_DIGEST_SIZE);
-
-    for (i = 1; i < iterations; i++)
-    {
-        /* Un = PRF(P, Un-1) */
-        HMAC_SHA1((unsigned char*) password, (int) strlen(password), digest1, SHA1_DIGEST_SIZE, digest, SHA1_DIGEST_SIZE); // for WPA update
-        memcpy(digest1, digest, SHA1_DIGEST_SIZE);
-
-        /* output = output xor Un */
-        for (j = 0; j < SHA1_DIGEST_SIZE; j++)
-        {
-            output[j] ^= digest[j];
-        }
-    }
+	/* U1 = PRF(P, S || int(i)) */
+	memcpy(digest, ssid, ssidlength);
+	digest[ssidlength] = (unsigned char)((count >> 24) & 0xff);
+	digest[ssidlength + 1] = (unsigned char)((count >> 16) & 0xff);
+	digest[ssidlength + 2] = (unsigned char)((count >> 8) & 0xff);
+	digest[ssidlength + 3] = (unsigned char)(count & 0xff);
+	HMAC_SHA1((unsigned char *)password, (int)strlen(password), digest, ssidlength + 4, digest1, SHA1_DIGEST_SIZE);	// for WPA update
+
+	/* output = U1 */
+	memcpy(output, digest1, SHA1_DIGEST_SIZE);
+
+	for (i = 1; i < iterations; i++) {
+		/* Un = PRF(P, Un-1) */
+		HMAC_SHA1((unsigned char *)password, (int)strlen(password), digest1, SHA1_DIGEST_SIZE, digest, SHA1_DIGEST_SIZE);	// for WPA update
+		memcpy(digest1, digest, SHA1_DIGEST_SIZE);
+
+		/* output = output xor Un */
+		for (j = 0; j < SHA1_DIGEST_SIZE; j++) {
+			output[j] ^= digest[j];
+		}
+	}
 }
 
 /*
@@ -1380,16 +1367,14 @@ static void F(char *password, unsigned c
 */
 int PasswordHash(PSTRING password, PUCHAR ssid, INT ssidlength, PUCHAR output)
 {
-    if ((strlen(password) > 63) || (ssidlength > 32))
-        return 0;
+	if ((strlen(password) > 63) || (ssidlength > 32))
+		return 0;
 
-    F(password, ssid, ssidlength, 4096, 1, output);
-    F(password, ssid, ssidlength, 4096, 2, &output[SHA1_DIGEST_SIZE]);
-    return 1;
+	F(password, ssid, ssidlength, 4096, 1, output);
+	F(password, ssid, ssidlength, 4096, 2, &output[SHA1_DIGEST_SIZE]);
+	return 1;
 }
 
-
-
 /*
 	========================================================================
 
@@ -1414,21 +1399,20 @@ int PasswordHash(PSTRING password, PUCHA
 
 	========================================================================
 */
-VOID WpaDerivePTK(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR	*PMK,
-	IN	UCHAR	*ANonce,
-	IN	UCHAR	*AA,
-	IN	UCHAR	*SNonce,
-	IN	UCHAR	*SA,
-	OUT	UCHAR	*output,
-	IN	UINT	len)
-{
-	UCHAR	concatenation[76];
-	UINT	CurrPos = 0;
-	UCHAR	temp[32];
-	UCHAR	Prefix[] = {'P', 'a', 'i', 'r', 'w', 'i', 's', 'e', ' ', 'k', 'e', 'y', ' ',
-						'e', 'x', 'p', 'a', 'n', 's', 'i', 'o', 'n'};
+VOID WpaDerivePTK(IN PRTMP_ADAPTER pAd,
+		  IN UCHAR * PMK,
+		  IN UCHAR * ANonce,
+		  IN UCHAR * AA,
+		  IN UCHAR * SNonce,
+		  IN UCHAR * SA, OUT UCHAR * output, IN UINT len)
+{
+	UCHAR concatenation[76];
+	UINT CurrPos = 0;
+	UCHAR temp[32];
+	UCHAR Prefix[] =
+	    { 'P', 'a', 'i', 'r', 'w', 'i', 's', 'e', ' ', 'k', 'e', 'y', ' ',
+		'e', 'x', 'p', 'a', 'n', 's', 'i', 'o', 'n'
+	};
 
 	// initiate the concatenation input
 	NdisZeroMemory(temp, sizeof(temp));
@@ -1494,46 +1478,43 @@ VOID WpaDerivePTK(
 
 	========================================================================
 */
-VOID	GenRandom(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			*macAddr,
-	OUT	UCHAR			*random)
-{
-	INT		i, curr;
-	UCHAR	local[80], KeyCounter[32];
-	UCHAR	result[80];
-	ULONG	CurrentTime;
-	UCHAR	prefix[] = {'I', 'n', 'i', 't', ' ', 'C', 'o', 'u', 'n', 't', 'e', 'r'};
+VOID GenRandom(IN PRTMP_ADAPTER pAd, IN UCHAR * macAddr, OUT UCHAR * random)
+{
+	INT i, curr;
+	UCHAR local[80], KeyCounter[32];
+	UCHAR result[80];
+	ULONG CurrentTime;
+	UCHAR prefix[] =
+	    { 'I', 'n', 'i', 't', ' ', 'C', 'o', 'u', 'n', 't', 'e', 'r' };
 
 	// Zero the related information
 	NdisZeroMemory(result, 80);
 	NdisZeroMemory(local, 80);
 	NdisZeroMemory(KeyCounter, 32);
 
-	for	(i = 0;	i <	32;	i++)
-	{
+	for (i = 0; i < 32; i++) {
 		// copy the local MAC address
 		COPY_MAC_ADDR(local, macAddr);
-		curr =	MAC_ADDR_LEN;
+		curr = MAC_ADDR_LEN;
 
 		// concatenate the current time
 		NdisGetSystemUpTime(&CurrentTime);
-		NdisMoveMemory(&local[curr],  &CurrentTime,	sizeof(CurrentTime));
-		curr +=	sizeof(CurrentTime);
+		NdisMoveMemory(&local[curr], &CurrentTime, sizeof(CurrentTime));
+		curr += sizeof(CurrentTime);
 
 		// concatenate the last result
-		NdisMoveMemory(&local[curr],  result, 32);
-		curr +=	32;
+		NdisMoveMemory(&local[curr], result, 32);
+		curr += 32;
 
 		// concatenate a variable
-		NdisMoveMemory(&local[curr],  &i,  2);
-		curr +=	2;
+		NdisMoveMemory(&local[curr], &i, 2);
+		curr += 2;
 
 		// calculate the result
-		PRF(KeyCounter, 32, prefix,12, local, curr, result, 32);
+		PRF(KeyCounter, 32, prefix, 12, local, curr, result, 32);
 	}
 
-	NdisMoveMemory(random, result,	32);
+	NdisMoveMemory(random, result, 32);
 }
 
 /*
@@ -1556,170 +1537,169 @@ VOID	GenRandom(
 
 	========================================================================
 */
-static VOID RTMPMakeRsnIeCipher(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	UCHAR			ElementID,
-	IN	UINT			WepStatus,
-	IN	BOOLEAN			bMixCipher,
-	IN	UCHAR			FlexibleCipher,
-	OUT	PUCHAR			pRsnIe,
-	OUT	UCHAR			*rsn_len)
+static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
+				IN UCHAR ElementID,
+				IN UINT WepStatus,
+				IN BOOLEAN bMixCipher,
+				IN UCHAR FlexibleCipher,
+				OUT PUCHAR pRsnIe, OUT UCHAR * rsn_len)
 {
-	UCHAR	PairwiseCnt;
+	UCHAR PairwiseCnt;
 
 	*rsn_len = 0;
 
 	// decide WPA2 or WPA1
-	if (ElementID == Wpa2Ie)
-	{
-		RSNIE2	*pRsnie_cipher = (RSNIE2*)pRsnIe;
+	if (ElementID == Wpa2Ie) {
+		RSNIE2 *pRsnie_cipher = (RSNIE2 *) pRsnIe;
 
 		// Assign the verson as 1
 		pRsnie_cipher->version = 1;
 
-        switch (WepStatus)
-        {
-		// TKIP mode
-            case Ndis802_11Encryption2Enabled:
-                NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
-                pRsnie_cipher->ucount = 1;
-                NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA2_TKIP, 4);
-                *rsn_len = sizeof(RSNIE2);
-                break;
+		switch (WepStatus) {
+			// TKIP mode
+		case Ndis802_11Encryption2Enabled:
+			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
+			pRsnie_cipher->ucount = 1;
+			NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
+				       OUI_WPA2_TKIP, 4);
+			*rsn_len = sizeof(RSNIE2);
+			break;
 
 			// AES mode
-            case Ndis802_11Encryption3Enabled:
-				if (bMixCipher)
-					NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
-				else
-					NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_CCMP, 4);
-                pRsnie_cipher->ucount = 1;
-                NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA2_CCMP, 4);
-                *rsn_len = sizeof(RSNIE2);
-                break;
+		case Ndis802_11Encryption3Enabled:
+			if (bMixCipher)
+				NdisMoveMemory(pRsnie_cipher->mcast,
+					       OUI_WPA2_TKIP, 4);
+			else
+				NdisMoveMemory(pRsnie_cipher->mcast,
+					       OUI_WPA2_CCMP, 4);
+			pRsnie_cipher->ucount = 1;
+			NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
+				       OUI_WPA2_CCMP, 4);
+			*rsn_len = sizeof(RSNIE2);
+			break;
 
 			// TKIP-AES mix mode
-            case Ndis802_11Encryption4Enabled:
-                NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
+		case Ndis802_11Encryption4Enabled:
+			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
 
-				PairwiseCnt = 1;
-				// Insert WPA2 TKIP as the first pairwise cipher
-				if (MIX_CIPHER_WPA2_TKIP_ON(FlexibleCipher))
-				{
-			NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA2_TKIP, 4);
-					// Insert WPA2 AES as the secondary pairwise cipher
-					if (MIX_CIPHER_WPA2_AES_ON(FlexibleCipher))
-					{
-				NdisMoveMemory(pRsnie_cipher->ucast[0].oui + 4, OUI_WPA2_CCMP, 4);
-						PairwiseCnt = 2;
-					}
-				}
-				else
-				{
-					// Insert WPA2 AES as the first pairwise cipher
-					NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA2_CCMP, 4);
+			PairwiseCnt = 1;
+			// Insert WPA2 TKIP as the first pairwise cipher
+			if (MIX_CIPHER_WPA2_TKIP_ON(FlexibleCipher)) {
+				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
+					       OUI_WPA2_TKIP, 4);
+				// Insert WPA2 AES as the secondary pairwise cipher
+				if (MIX_CIPHER_WPA2_AES_ON(FlexibleCipher)) {
+					NdisMoveMemory(pRsnie_cipher->ucast[0].
+						       oui + 4, OUI_WPA2_CCMP,
+						       4);
+					PairwiseCnt = 2;
 				}
+			} else {
+				// Insert WPA2 AES as the first pairwise cipher
+				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
+					       OUI_WPA2_CCMP, 4);
+			}
 
-                pRsnie_cipher->ucount = PairwiseCnt;
-                *rsn_len = sizeof(RSNIE2) + (4 * (PairwiseCnt - 1));
-                break;
-        }
+			pRsnie_cipher->ucount = PairwiseCnt;
+			*rsn_len = sizeof(RSNIE2) + (4 * (PairwiseCnt - 1));
+			break;
+		}
 
 		if ((pAd->OpMode == OPMODE_STA) &&
-			(pAd->StaCfg.GroupCipher != Ndis802_11Encryption2Enabled) &&
-			(pAd->StaCfg.GroupCipher != Ndis802_11Encryption3Enabled))
-		{
-			UINT	GroupCipher = pAd->StaCfg.GroupCipher;
-			switch(GroupCipher)
-			{
-				case Ndis802_11GroupWEP40Enabled:
-					NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_WEP40, 4);
-					break;
-				case Ndis802_11GroupWEP104Enabled:
-					NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_WEP104, 4);
-					break;
+		    (pAd->StaCfg.GroupCipher != Ndis802_11Encryption2Enabled) &&
+		    (pAd->StaCfg.GroupCipher != Ndis802_11Encryption3Enabled)) {
+			UINT GroupCipher = pAd->StaCfg.GroupCipher;
+			switch (GroupCipher) {
+			case Ndis802_11GroupWEP40Enabled:
+				NdisMoveMemory(pRsnie_cipher->mcast,
+					       OUI_WPA2_WEP40, 4);
+				break;
+			case Ndis802_11GroupWEP104Enabled:
+				NdisMoveMemory(pRsnie_cipher->mcast,
+					       OUI_WPA2_WEP104, 4);
+				break;
 			}
 		}
-
 		// swap for big-endian platform
 		pRsnie_cipher->version = cpu2le16(pRsnie_cipher->version);
-	    pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);
-	}
-	else
-	{
-		RSNIE	*pRsnie_cipher = (RSNIE*)pRsnIe;
+		pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);
+	} else {
+		RSNIE *pRsnie_cipher = (RSNIE *) pRsnIe;
 
 		// Assign OUI and version
 		NdisMoveMemory(pRsnie_cipher->oui, OUI_WPA_VERSION, 4);
-        pRsnie_cipher->version = 1;
+		pRsnie_cipher->version = 1;
 
-		switch (WepStatus)
-		{
+		switch (WepStatus) {
 			// TKIP mode
-            case Ndis802_11Encryption2Enabled:
-                NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
-                pRsnie_cipher->ucount = 1;
-                NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA_TKIP, 4);
-                *rsn_len = sizeof(RSNIE);
-                break;
+		case Ndis802_11Encryption2Enabled:
+			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
+			pRsnie_cipher->ucount = 1;
+			NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
+				       OUI_WPA_TKIP, 4);
+			*rsn_len = sizeof(RSNIE);
+			break;
 
 			// AES mode
-            case Ndis802_11Encryption3Enabled:
-				if (bMixCipher)
-					NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
-				else
-					NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_CCMP, 4);
-                pRsnie_cipher->ucount = 1;
-                NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA_CCMP, 4);
-                *rsn_len = sizeof(RSNIE);
-                break;
+		case Ndis802_11Encryption3Enabled:
+			if (bMixCipher)
+				NdisMoveMemory(pRsnie_cipher->mcast,
+					       OUI_WPA_TKIP, 4);
+			else
+				NdisMoveMemory(pRsnie_cipher->mcast,
+					       OUI_WPA_CCMP, 4);
+			pRsnie_cipher->ucount = 1;
+			NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
+				       OUI_WPA_CCMP, 4);
+			*rsn_len = sizeof(RSNIE);
+			break;
 
 			// TKIP-AES mix mode
-            case Ndis802_11Encryption4Enabled:
-                NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
+		case Ndis802_11Encryption4Enabled:
+			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
 
-				PairwiseCnt = 1;
-				// Insert WPA TKIP as the first pairwise cipher
-				if (MIX_CIPHER_WPA_TKIP_ON(FlexibleCipher))
-				{
-			NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA_TKIP, 4);
-					// Insert WPA AES as the secondary pairwise cipher
-					if (MIX_CIPHER_WPA_AES_ON(FlexibleCipher))
-					{
-				NdisMoveMemory(pRsnie_cipher->ucast[0].oui + 4, OUI_WPA_CCMP, 4);
-						PairwiseCnt = 2;
-					}
-				}
-				else
-				{
-					// Insert WPA AES as the first pairwise cipher
-					NdisMoveMemory(pRsnie_cipher->ucast[0].oui, OUI_WPA_CCMP, 4);
+			PairwiseCnt = 1;
+			// Insert WPA TKIP as the first pairwise cipher
+			if (MIX_CIPHER_WPA_TKIP_ON(FlexibleCipher)) {
+				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
+					       OUI_WPA_TKIP, 4);
+				// Insert WPA AES as the secondary pairwise cipher
+				if (MIX_CIPHER_WPA_AES_ON(FlexibleCipher)) {
+					NdisMoveMemory(pRsnie_cipher->ucast[0].
+						       oui + 4, OUI_WPA_CCMP,
+						       4);
+					PairwiseCnt = 2;
 				}
+			} else {
+				// Insert WPA AES as the first pairwise cipher
+				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
+					       OUI_WPA_CCMP, 4);
+			}
 
-                pRsnie_cipher->ucount = PairwiseCnt;
-                *rsn_len = sizeof(RSNIE) + (4 * (PairwiseCnt - 1));
-                break;
-        }
+			pRsnie_cipher->ucount = PairwiseCnt;
+			*rsn_len = sizeof(RSNIE) + (4 * (PairwiseCnt - 1));
+			break;
+		}
 
 		if ((pAd->OpMode == OPMODE_STA) &&
-			(pAd->StaCfg.GroupCipher != Ndis802_11Encryption2Enabled) &&
-			(pAd->StaCfg.GroupCipher != Ndis802_11Encryption3Enabled))
-		{
-			UINT	GroupCipher = pAd->StaCfg.GroupCipher;
-			switch(GroupCipher)
-			{
-				case Ndis802_11GroupWEP40Enabled:
-					NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_WEP40, 4);
-					break;
-				case Ndis802_11GroupWEP104Enabled:
-					NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_WEP104, 4);
-					break;
+		    (pAd->StaCfg.GroupCipher != Ndis802_11Encryption2Enabled) &&
+		    (pAd->StaCfg.GroupCipher != Ndis802_11Encryption3Enabled)) {
+			UINT GroupCipher = pAd->StaCfg.GroupCipher;
+			switch (GroupCipher) {
+			case Ndis802_11GroupWEP40Enabled:
+				NdisMoveMemory(pRsnie_cipher->mcast,
+					       OUI_WPA_WEP40, 4);
+				break;
+			case Ndis802_11GroupWEP104Enabled:
+				NdisMoveMemory(pRsnie_cipher->mcast,
+					       OUI_WPA_WEP104, 4);
+				break;
 			}
 		}
-
 		// swap for big-endian platform
 		pRsnie_cipher->version = cpu2le16(pRsnie_cipher->version);
-	    pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);
+		pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);
 	}
 }
 
@@ -1742,61 +1722,59 @@ static VOID RTMPMakeRsnIeCipher(
 
 	========================================================================
 */
-static VOID RTMPMakeRsnIeAKM(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	UCHAR			ElementID,
-	IN	UINT			AuthMode,
-	IN	UCHAR			apidx,
-	OUT	PUCHAR			pRsnIe,
-	OUT	UCHAR			*rsn_len)
+static VOID RTMPMakeRsnIeAKM(IN PRTMP_ADAPTER pAd,
+			     IN UCHAR ElementID,
+			     IN UINT AuthMode,
+			     IN UCHAR apidx,
+			     OUT PUCHAR pRsnIe, OUT UCHAR * rsn_len)
 {
-	RSNIE_AUTH		*pRsnie_auth;
-	UCHAR			AkmCnt = 1;		// default as 1
+	RSNIE_AUTH *pRsnie_auth;
+	UCHAR AkmCnt = 1;	// default as 1
 
-	pRsnie_auth = (RSNIE_AUTH*)(pRsnIe + (*rsn_len));
+	pRsnie_auth = (RSNIE_AUTH *) (pRsnIe + (*rsn_len));
 
 	// decide WPA2 or WPA1
-	if (ElementID == Wpa2Ie)
-	{
+	if (ElementID == Wpa2Ie) {
 
-		switch (AuthMode)
-        {
-            case Ndis802_11AuthModeWPA2:
-            case Ndis802_11AuthModeWPA1WPA2:
-			NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA2_8021X_AKM, 4);
-                break;
-
-            case Ndis802_11AuthModeWPA2PSK:
-            case Ndis802_11AuthModeWPA1PSKWPA2PSK:
-			NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA2_PSK_AKM, 4);
-                break;
-			default:
-				AkmCnt = 0;
-				break;
+		switch (AuthMode) {
+		case Ndis802_11AuthModeWPA2:
+		case Ndis802_11AuthModeWPA1WPA2:
+			NdisMoveMemory(pRsnie_auth->auth[0].oui,
+				       OUI_WPA2_8021X_AKM, 4);
+			break;
 
-        }
-	}
-	else
-	{
-		switch (AuthMode)
-        {
-            case Ndis802_11AuthModeWPA:
-            case Ndis802_11AuthModeWPA1WPA2:
-                NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA_8021X_AKM, 4);
-                break;
-
-            case Ndis802_11AuthModeWPAPSK:
-            case Ndis802_11AuthModeWPA1PSKWPA2PSK:
-                NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA_PSK_AKM, 4);
-                break;
-
-			case Ndis802_11AuthModeWPANone:
-                NdisMoveMemory(pRsnie_auth->auth[0].oui, OUI_WPA_NONE_AKM, 4);
-                break;
-			default:
-				AkmCnt = 0;
-				break;
-        }
+		case Ndis802_11AuthModeWPA2PSK:
+		case Ndis802_11AuthModeWPA1PSKWPA2PSK:
+			NdisMoveMemory(pRsnie_auth->auth[0].oui,
+				       OUI_WPA2_PSK_AKM, 4);
+			break;
+		default:
+			AkmCnt = 0;
+			break;
+
+		}
+	} else {
+		switch (AuthMode) {
+		case Ndis802_11AuthModeWPA:
+		case Ndis802_11AuthModeWPA1WPA2:
+			NdisMoveMemory(pRsnie_auth->auth[0].oui,
+				       OUI_WPA_8021X_AKM, 4);
+			break;
+
+		case Ndis802_11AuthModeWPAPSK:
+		case Ndis802_11AuthModeWPA1PSKWPA2PSK:
+			NdisMoveMemory(pRsnie_auth->auth[0].oui,
+				       OUI_WPA_PSK_AKM, 4);
+			break;
+
+		case Ndis802_11AuthModeWPANone:
+			NdisMoveMemory(pRsnie_auth->auth[0].oui,
+				       OUI_WPA_NONE_AKM, 4);
+			break;
+		default:
+			AkmCnt = 0;
+			break;
+		}
 	}
 
 	pRsnie_auth->acount = AkmCnt;
@@ -1825,21 +1803,18 @@ static VOID RTMPMakeRsnIeAKM(
 
 	========================================================================
 */
-static VOID RTMPMakeRsnIeCap(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	UCHAR			ElementID,
-	IN	UCHAR			apidx,
-	OUT	PUCHAR			pRsnIe,
-	OUT	UCHAR			*rsn_len)
+static VOID RTMPMakeRsnIeCap(IN PRTMP_ADAPTER pAd,
+			     IN UCHAR ElementID,
+			     IN UCHAR apidx,
+			     OUT PUCHAR pRsnIe, OUT UCHAR * rsn_len)
 {
-	RSN_CAPABILITIES    *pRSN_Cap;
+	RSN_CAPABILITIES *pRSN_Cap;
 
 	// it could be ignored in WPA1 mode
 	if (ElementID == WpaIe)
 		return;
 
-	pRSN_Cap = (RSN_CAPABILITIES*)(pRsnIe + (*rsn_len));
-
+	pRSN_Cap = (RSN_CAPABILITIES *) (pRsnIe + (*rsn_len));
 
 	pRSN_Cap->word = cpu2le16(pRSN_Cap->word);
 
@@ -1847,7 +1822,6 @@ static VOID RTMPMakeRsnIeCap(
 
 }
 
-
 /*
 	========================================================================
 
@@ -1866,42 +1840,37 @@ static VOID RTMPMakeRsnIeCap(
 
 	========================================================================
 */
-VOID RTMPMakeRSNIE(
-    IN  PRTMP_ADAPTER   pAd,
-    IN  UINT            AuthMode,
-    IN  UINT            WepStatus,
-	IN	UCHAR			apidx)
-{
-	PUCHAR		pRsnIe = NULL;			// primary RSNIE
-	UCHAR		*rsnielen_cur_p = 0;	// the length of the primary RSNIE
-	UCHAR		*rsnielen_ex_cur_p = 0;	// the length of the secondary RSNIE
-	UCHAR		PrimaryRsnie;
-	BOOLEAN		bMixCipher = FALSE;	// indicate the pairwise and group cipher are different
-	UCHAR		p_offset;
-	WPA_MIX_PAIR_CIPHER		FlexibleCipher = WPA_TKIPAES_WPA2_TKIPAES;	// it provide the more flexible cipher combination in WPA-WPA2 and TKIPAES mode
+VOID RTMPMakeRSNIE(IN PRTMP_ADAPTER pAd,
+		   IN UINT AuthMode, IN UINT WepStatus, IN UCHAR apidx)
+{
+	PUCHAR pRsnIe = NULL;	// primary RSNIE
+	UCHAR *rsnielen_cur_p = 0;	// the length of the primary RSNIE
+	UCHAR *rsnielen_ex_cur_p = 0;	// the length of the secondary RSNIE
+	UCHAR PrimaryRsnie;
+	BOOLEAN bMixCipher = FALSE;	// indicate the pairwise and group cipher are different
+	UCHAR p_offset;
+	WPA_MIX_PAIR_CIPHER FlexibleCipher = WPA_TKIPAES_WPA2_TKIPAES;	// it provide the more flexible cipher combination in WPA-WPA2 and TKIPAES mode
 
 	rsnielen_cur_p = NULL;
 	rsnielen_ex_cur_p = NULL;
 
 	{
 		{
-			if (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)
-			{
+			if (pAd->StaCfg.WpaSupplicantUP !=
+			    WPA_SUPPLICANT_DISABLE) {
 				if (AuthMode < Ndis802_11AuthModeWPA)
 					return;
-			}
-			else
-			{
+			} else {
 				// Support WPAPSK or WPA2PSK in STA-Infra mode
 				// Support WPANone in STA-Adhoc mode
 				if ((AuthMode != Ndis802_11AuthModeWPAPSK) &&
-					(AuthMode != Ndis802_11AuthModeWPA2PSK) &&
-					(AuthMode != Ndis802_11AuthModeWPANone)
-					)
+				    (AuthMode != Ndis802_11AuthModeWPA2PSK) &&
+				    (AuthMode != Ndis802_11AuthModeWPANone)
+				    )
 					return;
 			}
 
-			DBGPRINT(RT_DEBUG_TRACE,("==> RTMPMakeRSNIE(STA)\n"));
+			DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPMakeRSNIE(STA)\n"));
 
 			// Zero RSNIE context
 			pAd->StaCfg.RSNIE_Len = 0;
@@ -1917,10 +1886,10 @@ VOID RTMPMakeRSNIE(
 
 	// indicate primary RSNIE as WPA or WPA2
 	if ((AuthMode == Ndis802_11AuthModeWPA) ||
-		(AuthMode == Ndis802_11AuthModeWPAPSK) ||
-		(AuthMode == Ndis802_11AuthModeWPANone) ||
-		(AuthMode == Ndis802_11AuthModeWPA1WPA2) ||
-		(AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))
+	    (AuthMode == Ndis802_11AuthModeWPAPSK) ||
+	    (AuthMode == Ndis802_11AuthModeWPANone) ||
+	    (AuthMode == Ndis802_11AuthModeWPA1WPA2) ||
+	    (AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))
 		PrimaryRsnie = WpaIe;
 	else
 		PrimaryRsnie = Wpa2Ie;
@@ -1928,10 +1897,12 @@ VOID RTMPMakeRSNIE(
 	{
 		// Build the primary RSNIE
 		// 1. insert cipher suite
-		RTMPMakeRsnIeCipher(pAd, PrimaryRsnie, WepStatus, bMixCipher, FlexibleCipher, pRsnIe, &p_offset);
+		RTMPMakeRsnIeCipher(pAd, PrimaryRsnie, WepStatus, bMixCipher,
+				    FlexibleCipher, pRsnIe, &p_offset);
 
 		// 2. insert AKM
-		RTMPMakeRsnIeAKM(pAd, PrimaryRsnie, AuthMode, apidx, pRsnIe, &p_offset);
+		RTMPMakeRsnIeAKM(pAd, PrimaryRsnie, AuthMode, apidx, pRsnIe,
+				 &p_offset);
 
 		// 3. insert capability
 		RTMPMakeRsnIeCap(pAd, PrimaryRsnie, apidx, pRsnIe, &p_offset);
@@ -1942,7 +1913,6 @@ VOID RTMPMakeRSNIE(
 
 	hex_dump("The primary RSNIE", pRsnIe, (*rsnielen_cur_p));
 
-
 }
 
 /*
@@ -1962,66 +1932,68 @@ VOID RTMPMakeRSNIE(
          FALSE			-	otherwise
     ==========================================================================
 */
-BOOLEAN RTMPCheckWPAframe(
-    IN PRTMP_ADAPTER    pAd,
-    IN PMAC_TABLE_ENTRY	pEntry,
-    IN PUCHAR           pData,
-    IN ULONG            DataByteCount,
-	IN UCHAR			FromWhichBSSID)
+BOOLEAN RTMPCheckWPAframe(IN PRTMP_ADAPTER pAd,
+			  IN PMAC_TABLE_ENTRY pEntry,
+			  IN PUCHAR pData,
+			  IN ULONG DataByteCount, IN UCHAR FromWhichBSSID)
 {
-	ULONG	Body_len;
+	ULONG Body_len;
 	BOOLEAN Cancelled;
 
-
-    if(DataByteCount < (LENGTH_802_1_H + LENGTH_EAPOL_H))
-        return FALSE;
-
+	if (DataByteCount < (LENGTH_802_1_H + LENGTH_EAPOL_H))
+		return FALSE;
 
 	// Skip LLC header
-    if (NdisEqualMemory(SNAP_802_1H, pData, 6) ||
-        // Cisco 1200 AP may send packet with SNAP_BRIDGE_TUNNEL
-        NdisEqualMemory(SNAP_BRIDGE_TUNNEL, pData, 6))
-    {
-        pData += 6;
-    }
+	if (NdisEqualMemory(SNAP_802_1H, pData, 6) ||
+	    // Cisco 1200 AP may send packet with SNAP_BRIDGE_TUNNEL
+	    NdisEqualMemory(SNAP_BRIDGE_TUNNEL, pData, 6)) {
+		pData += 6;
+	}
 	// Skip 2-bytes EAPoL type
-    if (NdisEqualMemory(EAPOL, pData, 2))
-    {
-        pData += 2;
-    }
-    else
-        return FALSE;
-
-    switch (*(pData+1))
-    {
-        case EAPPacket:
-			Body_len = (*(pData+2)<<8) | (*(pData+3));
-            DBGPRINT(RT_DEBUG_TRACE, ("Receive EAP-Packet frame, TYPE = 0, Length = %ld\n", Body_len));
-            break;
-        case EAPOLStart:
-            DBGPRINT(RT_DEBUG_TRACE, ("Receive EAPOL-Start frame, TYPE = 1 \n"));
-			if (pEntry->EnqueueEapolStartTimerRunning != EAPOL_START_DISABLE)
-            {
-		DBGPRINT(RT_DEBUG_TRACE, ("Cancel the EnqueueEapolStartTimerRunning \n"));
-                RTMPCancelTimer(&pEntry->EnqueueStartForPSKTimer, &Cancelled);
-                pEntry->EnqueueEapolStartTimerRunning = EAPOL_START_DISABLE;
-            }
-            break;
-        case EAPOLLogoff:
-            DBGPRINT(RT_DEBUG_TRACE, ("Receive EAPOLLogoff frame, TYPE = 2 \n"));
-            break;
-        case EAPOLKey:
-			Body_len = (*(pData+2)<<8) | (*(pData+3));
-            DBGPRINT(RT_DEBUG_TRACE, ("Receive EAPOL-Key frame, TYPE = 3, Length = %ld\n", Body_len));
-            break;
-        case EAPOLASFAlert:
-            DBGPRINT(RT_DEBUG_TRACE, ("Receive EAPOLASFAlert frame, TYPE = 4 \n"));
-            break;
-        default:
-            return FALSE;
+	if (NdisEqualMemory(EAPOL, pData, 2)) {
+		pData += 2;
+	} else
+		return FALSE;
+
+	switch (*(pData + 1)) {
+	case EAPPacket:
+		Body_len = (*(pData + 2) << 8) | (*(pData + 3));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Receive EAP-Packet frame, TYPE = 0, Length = %ld\n",
+			  Body_len));
+		break;
+	case EAPOLStart:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Receive EAPOL-Start frame, TYPE = 1 \n"));
+		if (pEntry->EnqueueEapolStartTimerRunning !=
+		    EAPOL_START_DISABLE) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Cancel the EnqueueEapolStartTimerRunning \n"));
+			RTMPCancelTimer(&pEntry->EnqueueStartForPSKTimer,
+					&Cancelled);
+			pEntry->EnqueueEapolStartTimerRunning =
+			    EAPOL_START_DISABLE;
+		}
+		break;
+	case EAPOLLogoff:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Receive EAPOLLogoff frame, TYPE = 2 \n"));
+		break;
+	case EAPOLKey:
+		Body_len = (*(pData + 2) << 8) | (*(pData + 3));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Receive EAPOL-Key frame, TYPE = 3, Length = %ld\n",
+			  Body_len));
+		break;
+	case EAPOLASFAlert:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Receive EAPOLASFAlert frame, TYPE = 4 \n"));
+		break;
+	default:
+		return FALSE;
 
-    }
-    return TRUE;
+	}
+	return TRUE;
 }
 
 /*
@@ -2044,23 +2016,22 @@ BOOLEAN RTMPCheckWPAframe(
 */
 PSTRING GetEapolMsgType(CHAR msg)
 {
-    if(msg == EAPOL_PAIR_MSG_1)
-        return "Pairwise Message 1";
-    else if(msg == EAPOL_PAIR_MSG_2)
-        return "Pairwise Message 2";
-	else if(msg == EAPOL_PAIR_MSG_3)
-        return "Pairwise Message 3";
-	else if(msg == EAPOL_PAIR_MSG_4)
-        return "Pairwise Message 4";
-	else if(msg == EAPOL_GROUP_MSG_1)
-        return "Group Message 1";
-	else if(msg == EAPOL_GROUP_MSG_2)
-        return "Group Message 2";
-    else
-	return "Invalid Message";
+	if (msg == EAPOL_PAIR_MSG_1)
+		return "Pairwise Message 1";
+	else if (msg == EAPOL_PAIR_MSG_2)
+		return "Pairwise Message 2";
+	else if (msg == EAPOL_PAIR_MSG_3)
+		return "Pairwise Message 3";
+	else if (msg == EAPOL_PAIR_MSG_4)
+		return "Pairwise Message 4";
+	else if (msg == EAPOL_GROUP_MSG_1)
+		return "Group Message 1";
+	else if (msg == EAPOL_GROUP_MSG_2)
+		return "Group Message 2";
+	else
+		return "Invalid Message";
 }
 
-
 /*
 	========================================================================
 
@@ -2071,64 +2042,62 @@ PSTRING GetEapolMsgType(CHAR msg)
 
 	Return Value:
 
-
 	========================================================================
 */
-BOOLEAN RTMPCheckRSNIE(
-	IN	PRTMP_ADAPTER	pAd,
-	IN  PUCHAR          pData,
-	IN  UCHAR           DataLen,
-	IN  MAC_TABLE_ENTRY *pEntry,
-	OUT	UCHAR			*Offset)
-{
-	PUCHAR              pVIE;
-	UCHAR               len;
-	PEID_STRUCT         pEid;
-	BOOLEAN				result = FALSE;
+BOOLEAN RTMPCheckRSNIE(IN PRTMP_ADAPTER pAd,
+		       IN PUCHAR pData,
+		       IN UCHAR DataLen,
+		       IN MAC_TABLE_ENTRY * pEntry, OUT UCHAR * Offset)
+{
+	PUCHAR pVIE;
+	UCHAR len;
+	PEID_STRUCT pEid;
+	BOOLEAN result = FALSE;
 
 	pVIE = pData;
-	len	 = DataLen;
+	len = DataLen;
 	*Offset = 0;
 
-	while (len > sizeof(RSNIE2))
-	{
+	while (len > sizeof(RSNIE2)) {
 		pEid = (PEID_STRUCT) pVIE;
 		// WPA RSN IE
-		if ((pEid->Eid == IE_WPA) && (NdisEqualMemory(pEid->Octet, WPA_OUI, 4)))
-		{
-			if ((pEntry->AuthMode == Ndis802_11AuthModeWPA || pEntry->AuthMode == Ndis802_11AuthModeWPAPSK) &&
-				(NdisEqualMemory(pVIE, pEntry->RSN_IE, pEntry->RSNIE_Len)) &&
-				(pEntry->RSNIE_Len == (pEid->Len + 2)))
-			{
-					result = TRUE;
+		if ((pEid->Eid == IE_WPA)
+		    && (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))) {
+			if ((pEntry->AuthMode == Ndis802_11AuthModeWPA
+			     || pEntry->AuthMode == Ndis802_11AuthModeWPAPSK)
+			    &&
+			    (NdisEqualMemory
+			     (pVIE, pEntry->RSN_IE, pEntry->RSNIE_Len))
+			    && (pEntry->RSNIE_Len == (pEid->Len + 2))) {
+				result = TRUE;
 			}
 
 			*Offset += (pEid->Len + 2);
 		}
 		// WPA2 RSN IE
-		else if ((pEid->Eid == IE_RSN) && (NdisEqualMemory(pEid->Octet + 2, RSN_OUI, 3)))
-		{
-			if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2 || pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK) &&
-				(pEid->Eid == pEntry->RSN_IE[0]) &&
-				((pEid->Len + 2) >= pEntry->RSNIE_Len) &&
-				(NdisEqualMemory(pEid->Octet, &pEntry->RSN_IE[2], pEntry->RSNIE_Len - 2)))
-			{
+		else if ((pEid->Eid == IE_RSN)
+			 && (NdisEqualMemory(pEid->Octet + 2, RSN_OUI, 3))) {
+			if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2
+			     || pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)
+			    && (pEid->Eid == pEntry->RSN_IE[0])
+			    && ((pEid->Len + 2) >= pEntry->RSNIE_Len)
+			    &&
+			    (NdisEqualMemory
+			     (pEid->Octet, &pEntry->RSN_IE[2],
+			      pEntry->RSNIE_Len - 2))) {
 
-					result = TRUE;
+				result = TRUE;
 			}
 
 			*Offset += (pEid->Len + 2);
-		}
-	else
-		{
+		} else {
 			break;
 		}
 
 		pVIE += (pEid->Len + 2);
-		len  -= (pEid->Len + 2);
+		len -= (pEid->Len + 2);
 	}
 
-
 	return result;
 
 }
@@ -2149,107 +2118,109 @@ BOOLEAN RTMPCheckRSNIE(
 
 	========================================================================
 */
-BOOLEAN RTMPParseEapolKeyData(
-	IN	PRTMP_ADAPTER	pAd,
-	IN  PUCHAR          pKeyData,
-	IN  UCHAR           KeyDataLen,
-	IN	UCHAR			GroupKeyIndex,
-	IN	UCHAR			MsgType,
-	IN	BOOLEAN			bWPA2,
-	IN  MAC_TABLE_ENTRY *pEntry)
-{
-    PKDE_ENCAP          pKDE = NULL;
-    PUCHAR              pMyKeyData = pKeyData;
-    UCHAR               KeyDataLength = KeyDataLen;
-    UCHAR               GTKLEN = 0;
-	UCHAR				DefaultIdx = 0;
-	UCHAR				skip_offset;
+BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
+			      IN PUCHAR pKeyData,
+			      IN UCHAR KeyDataLen,
+			      IN UCHAR GroupKeyIndex,
+			      IN UCHAR MsgType,
+			      IN BOOLEAN bWPA2, IN MAC_TABLE_ENTRY * pEntry)
+{
+	PKDE_ENCAP pKDE = NULL;
+	PUCHAR pMyKeyData = pKeyData;
+	UCHAR KeyDataLength = KeyDataLen;
+	UCHAR GTKLEN = 0;
+	UCHAR DefaultIdx = 0;
+	UCHAR skip_offset;
 
 	// Verify The RSN IE contained in pairewise_msg_2 && pairewise_msg_3 and skip it
-	if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_3)
-    {
+	if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_3) {
 		// Check RSN IE whether it is WPA2/WPA2PSK
-		if (!RTMPCheckRSNIE(pAd, pKeyData, KeyDataLen, pEntry, &skip_offset))
-		{
+		if (!RTMPCheckRSNIE
+		    (pAd, pKeyData, KeyDataLen, pEntry, &skip_offset)) {
 			// send wireless event - for RSN IE different
 			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_RSNIE_DIFF_EVENT_FLAG, pEntry->Addr, pEntry->apidx, 0);
-
-		DBGPRINT(RT_DEBUG_ERROR, ("RSN_IE Different in msg %d of 4-way handshake!\n", MsgType));
+				RTMPSendWirelessEvent(pAd,
+						      IW_RSNIE_DIFF_EVENT_FLAG,
+						      pEntry->Addr,
+						      pEntry->apidx, 0);
+
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("RSN_IE Different in msg %d of 4-way handshake!\n",
+				  MsgType));
 			hex_dump("Receive RSN_IE ", pKeyData, KeyDataLen);
-			hex_dump("Desired RSN_IE ", pEntry->RSN_IE, pEntry->RSNIE_Len);
+			hex_dump("Desired RSN_IE ", pEntry->RSN_IE,
+				 pEntry->RSNIE_Len);
 
 			return FALSE;
-	}
-	else
-		{
-			if (bWPA2 && MsgType == EAPOL_PAIR_MSG_3)
-			{
+		} else {
+			if (bWPA2 && MsgType == EAPOL_PAIR_MSG_3) {
 				WpaShowAllsuite(pMyKeyData, skip_offset);
 
 				// skip RSN IE
 				pMyKeyData += skip_offset;
 				KeyDataLength -= skip_offset;
-				DBGPRINT(RT_DEBUG_TRACE, ("RTMPParseEapolKeyData ==> WPA2/WPA2PSK RSN IE matched in Msg 3, Length(%d) \n", skip_offset));
-			}
-			else
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("RTMPParseEapolKeyData ==> WPA2/WPA2PSK RSN IE matched in Msg 3, Length(%d) \n",
+					  skip_offset));
+			} else
 				return TRUE;
 		}
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("RTMPParseEapolKeyData ==> KeyDataLength %d without RSN_IE \n", KeyDataLength));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPParseEapolKeyData ==> KeyDataLength %d without RSN_IE \n",
+		  KeyDataLength));
 	//hex_dump("remain data", pMyKeyData, KeyDataLength);
 
-
 	// Parse EKD format in pairwise_msg_3_WPA2 && group_msg_1_WPA2
-	if (bWPA2 && (MsgType == EAPOL_PAIR_MSG_3 || MsgType == EAPOL_GROUP_MSG_1))
-	{
+	if (bWPA2
+	    && (MsgType == EAPOL_PAIR_MSG_3 || MsgType == EAPOL_GROUP_MSG_1)) {
 		if (KeyDataLength >= 8)	// KDE format exclude GTK length
-	{
-		pKDE = (PKDE_ENCAP) pMyKeyData;
-
+		{
+			pKDE = (PKDE_ENCAP) pMyKeyData;
 
 			DefaultIdx = pKDE->GTKEncap.Kid;
 
 			// Sanity check - KED length
-			if (KeyDataLength < (pKDE->Len + 2))
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("ERROR: The len from KDE is too short \n"));
-			return FALSE;
-		}
-
+			if (KeyDataLength < (pKDE->Len + 2)) {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("ERROR: The len from KDE is too short \n"));
+				return FALSE;
+			}
 			// Get GTK length - refer to IEEE 802.11i-2004 p.82
-			GTKLEN = pKDE->Len -6;
-			if (GTKLEN < LEN_AES_KEY)
-	{
-				DBGPRINT(RT_DEBUG_ERROR, ("ERROR: GTK Key length is too short (%d) \n", GTKLEN));
-			return FALSE;
+			GTKLEN = pKDE->Len - 6;
+			if (GTKLEN < LEN_AES_KEY) {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("ERROR: GTK Key length is too short (%d) \n",
+					  GTKLEN));
+				return FALSE;
 			}
 
-	}
-		else
-	{
-			DBGPRINT(RT_DEBUG_ERROR, ("ERROR: KDE format length is too short \n"));
-	        return FALSE;
-	}
+		} else {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("ERROR: KDE format length is too short \n"));
+			return FALSE;
+		}
 
-		DBGPRINT(RT_DEBUG_TRACE, ("GTK in KDE format ,DefaultKeyID=%d, KeyLen=%d \n", DefaultIdx, GTKLEN));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("GTK in KDE format ,DefaultKeyID=%d, KeyLen=%d \n",
+			  DefaultIdx, GTKLEN));
 		// skip it
 		pMyKeyData += 8;
 		KeyDataLength -= 8;
 
-	}
-	else if (!bWPA2 && MsgType == EAPOL_GROUP_MSG_1)
-	{
+	} else if (!bWPA2 && MsgType == EAPOL_GROUP_MSG_1) {
 		DefaultIdx = GroupKeyIndex;
-		DBGPRINT(RT_DEBUG_TRACE, ("GTK DefaultKeyID=%d \n", DefaultIdx));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("GTK DefaultKeyID=%d \n", DefaultIdx));
 	}
-
 	// Sanity check - shared key index must be 1 ~ 3
-	if (DefaultIdx < 1 || DefaultIdx > 3)
-    {
-	DBGPRINT(RT_DEBUG_ERROR, ("ERROR: GTK Key index(%d) is invalid in %s %s \n", DefaultIdx, ((bWPA2) ? "WPA2" : "WPA"), GetEapolMsgType(MsgType)));
-        return FALSE;
+	if (DefaultIdx < 1 || DefaultIdx > 3) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("ERROR: GTK Key index(%d) is invalid in %s %s \n",
+			  DefaultIdx, ((bWPA2) ? "WPA2" : "WPA"),
+			  GetEapolMsgType(MsgType)));
+		return FALSE;
 	}
 
 	{
@@ -2265,43 +2236,43 @@ BOOLEAN RTMPParseEapolKeyData(
 		NdisZeroMemory(pSharedKey, sizeof(CIPHER_KEY));
 		pSharedKey->KeyLen = LEN_TKIP_EK;
 		NdisMoveMemory(pSharedKey->Key, pAd->StaCfg.GTK, LEN_TKIP_EK);
-		NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.GTK[16], LEN_TKIP_RXMICK);
-		NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24], LEN_TKIP_TXMICK);
+		NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.GTK[16],
+			       LEN_TKIP_RXMICK);
+		NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24],
+			       LEN_TKIP_TXMICK);
 
 		// Update Shared Key CipherAlg
 		pSharedKey->CipherAlg = CIPHER_NONE;
 		if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
 			pSharedKey->CipherAlg = CIPHER_TKIP;
-		else if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
+		else if (pAd->StaCfg.GroupCipher ==
+			 Ndis802_11Encryption3Enabled)
 			pSharedKey->CipherAlg = CIPHER_AES;
 		else if (pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP40Enabled)
 			pSharedKey->CipherAlg = CIPHER_WEP64;
-		else if (pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP104Enabled)
+		else if (pAd->StaCfg.GroupCipher ==
+			 Ndis802_11GroupWEP104Enabled)
 			pSharedKey->CipherAlg = CIPHER_WEP128;
 
-
 		// Update group key information to ASIC Shared Key Table
 		AsicAddSharedKeyEntry(pAd,
-							  BSS0,
-							  pAd->StaCfg.DefaultKeyId,
-							  pSharedKey->CipherAlg,
-							  pSharedKey->Key,
-							  pSharedKey->TxMic,
-							  pSharedKey->RxMic);
+				      BSS0,
+				      pAd->StaCfg.DefaultKeyId,
+				      pSharedKey->CipherAlg,
+				      pSharedKey->Key,
+				      pSharedKey->TxMic, pSharedKey->RxMic);
 
 		// Update ASIC WCID attribute table and IVEIV table
 		RTMPAddWcidAttributeEntry(pAd,
-								  BSS0,
-								  pAd->StaCfg.DefaultKeyId,
-								  pSharedKey->CipherAlg,
-								  NULL);
+					  BSS0,
+					  pAd->StaCfg.DefaultKeyId,
+					  pSharedKey->CipherAlg, NULL);
 	}
 
 	return TRUE;
 
 }
 
-
 /*
 	========================================================================
 
@@ -2339,7 +2310,6 @@ BOOLEAN RTMPParseEapolKeyData(
 		| Key Data			 |	n octets
 		+--------------------+
 
-
 	Arguments:
 		pAd			Pointer	to our adapter
 
@@ -2350,29 +2320,27 @@ BOOLEAN RTMPParseEapolKeyData(
 
 	========================================================================
 */
-VOID	ConstructEapolMsg(
-	IN	PMAC_TABLE_ENTRY	pEntry,
-    IN	UCHAR				GroupKeyWepStatus,
-    IN	UCHAR				MsgType,
-    IN	UCHAR				DefaultKeyIdx,
-	IN	UCHAR				*KeyNonce,
-	IN	UCHAR				*TxRSC,
-	IN	UCHAR				*GTK,
-	IN	UCHAR				*RSNIE,
-	IN	UCHAR				RSNIE_Len,
-    OUT PEAPOL_PACKET       pMsg)
+VOID ConstructEapolMsg(IN PMAC_TABLE_ENTRY pEntry,
+		       IN UCHAR GroupKeyWepStatus,
+		       IN UCHAR MsgType,
+		       IN UCHAR DefaultKeyIdx,
+		       IN UCHAR * KeyNonce,
+		       IN UCHAR * TxRSC,
+		       IN UCHAR * GTK,
+		       IN UCHAR * RSNIE,
+		       IN UCHAR RSNIE_Len, OUT PEAPOL_PACKET pMsg)
 {
-	BOOLEAN	bWPA2 = FALSE;
-	UCHAR	KeyDescVer;
+	BOOLEAN bWPA2 = FALSE;
+	UCHAR KeyDescVer;
 
 	// Choose WPA2 or not
 	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) ||
-		(pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
+	    (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
 		bWPA2 = TRUE;
 
-    // Init Packet and Fill header
-    pMsg->ProVer = EAPOL_VER;
-    pMsg->ProType = EAPOLKey;
+	// Init Packet and Fill header
+	pMsg->ProVer = EAPOL_VER;
+	pMsg->ProType = EAPOLKey;
 
 	// Default 95 bytes, the EAPoL-Key descriptor exclude Key-data field
 	SET_UINT16_TO_ARRARY(pMsg->Body_Len, LEN_EAPOL_KEY_MSG);
@@ -2387,8 +2355,11 @@ VOID	ConstructEapolMsg(
 	{
 		// Fill in Key information, refer to IEEE Std 802.11i-2004 page 78
 		// When either the pairwise or the group cipher is AES, the DESC_TYPE_AES(2) shall be used.
-		KeyDescVer = (((pEntry->WepStatus == Ndis802_11Encryption3Enabled) ||
-					(GroupKeyWepStatus == Ndis802_11Encryption3Enabled)) ? (DESC_TYPE_AES) : (DESC_TYPE_TKIP));
+		KeyDescVer =
+		    (((pEntry->WepStatus == Ndis802_11Encryption3Enabled)
+		      || (GroupKeyWepStatus ==
+			  Ndis802_11Encryption3Enabled)) ? (DESC_TYPE_AES)
+		     : (DESC_TYPE_TKIP));
 	}
 
 	pMsg->KeyDesc.KeyInfo.KeyDescVer = KeyDescVer;
@@ -2396,7 +2367,7 @@ VOID	ConstructEapolMsg(
 	// Specify Key Type as Group(0) or Pairwise(1)
 	if (MsgType >= EAPOL_GROUP_MSG_1)
 		pMsg->KeyDesc.KeyInfo.KeyType = GROUPKEY;
-				else
+	else
 		pMsg->KeyDesc.KeyInfo.KeyType = PAIRWISEKEY;
 
 	// Specify Key Index, only group_msg1_WPA1
@@ -2406,89 +2377,92 @@ VOID	ConstructEapolMsg(
 	if (MsgType == EAPOL_PAIR_MSG_3)
 		pMsg->KeyDesc.KeyInfo.Install = 1;
 
-	if ((MsgType == EAPOL_PAIR_MSG_1) || (MsgType == EAPOL_PAIR_MSG_3) || (MsgType == EAPOL_GROUP_MSG_1))
+	if ((MsgType == EAPOL_PAIR_MSG_1) || (MsgType == EAPOL_PAIR_MSG_3)
+	    || (MsgType == EAPOL_GROUP_MSG_1))
 		pMsg->KeyDesc.KeyInfo.KeyAck = 1;
 
 	if (MsgType != EAPOL_PAIR_MSG_1)
 		pMsg->KeyDesc.KeyInfo.KeyMic = 1;
 
 	if ((bWPA2 && (MsgType >= EAPOL_PAIR_MSG_3)) ||
-		(!bWPA2 && (MsgType >= EAPOL_GROUP_MSG_1)))
-					{
-	pMsg->KeyDesc.KeyInfo.Secure = 1;
-					}
+	    (!bWPA2 && (MsgType >= EAPOL_GROUP_MSG_1))) {
+		pMsg->KeyDesc.KeyInfo.Secure = 1;
+	}
 
 	if (bWPA2 && ((MsgType == EAPOL_PAIR_MSG_3) ||
-		(MsgType == EAPOL_GROUP_MSG_1)))
-				{
-        pMsg->KeyDesc.KeyInfo.EKD_DL = 1;
-				}
-
+		      (MsgType == EAPOL_GROUP_MSG_1))) {
+		pMsg->KeyDesc.KeyInfo.EKD_DL = 1;
+	}
 	// key Information element has done.
-	*(USHORT *)(&pMsg->KeyDesc.KeyInfo) = cpu2le16(*(USHORT *)(&pMsg->KeyDesc.KeyInfo));
+	*(USHORT *) (&pMsg->KeyDesc.KeyInfo) =
+	    cpu2le16(*(USHORT *) (&pMsg->KeyDesc.KeyInfo));
 
 	// Fill in Key Length
-		{
-		if (MsgType >= EAPOL_GROUP_MSG_1)
-			{
-			// the length of group key cipher
-			pMsg->KeyDesc.KeyLength[1] = ((GroupKeyWepStatus == Ndis802_11Encryption2Enabled) ? TKIP_GTK_LENGTH : LEN_AES_KEY);
-	}
-	else
 	{
+		if (MsgType >= EAPOL_GROUP_MSG_1) {
+			// the length of group key cipher
+			pMsg->KeyDesc.KeyLength[1] =
+			    ((GroupKeyWepStatus ==
+			      Ndis802_11Encryption2Enabled) ? TKIP_GTK_LENGTH :
+			     LEN_AES_KEY);
+		} else {
 			// the length of pairwise key cipher
-			pMsg->KeyDesc.KeyLength[1] = ((pEntry->WepStatus == Ndis802_11Encryption2Enabled) ? LEN_TKIP_KEY : LEN_AES_KEY);
+			pMsg->KeyDesc.KeyLength[1] =
+			    ((pEntry->WepStatus ==
+			      Ndis802_11Encryption2Enabled) ? LEN_TKIP_KEY :
+			     LEN_AES_KEY);
 		}
 	}
 
 	// Fill in replay counter
-    NdisMoveMemory(pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter, LEN_KEY_DESC_REPLAY);
+	NdisMoveMemory(pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter,
+		       LEN_KEY_DESC_REPLAY);
 
 	// Fill Key Nonce field
 	// ANonce : pairwise_msg1 & pairwise_msg3
 	// SNonce : pairwise_msg2
 	// GNonce : group_msg1_wpa1
-	if ((MsgType <= EAPOL_PAIR_MSG_3) || ((!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1))))
-	NdisMoveMemory(pMsg->KeyDesc.KeyNonce, KeyNonce, LEN_KEY_DESC_NONCE);
+	if ((MsgType <= EAPOL_PAIR_MSG_3)
+	    || ((!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1))))
+		NdisMoveMemory(pMsg->KeyDesc.KeyNonce, KeyNonce,
+			       LEN_KEY_DESC_NONCE);
 
 	// Fill key IV - WPA2 as 0, WPA1 as random
-	if (!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1))
-					{
+	if (!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1)) {
 		// Suggest IV be random number plus some number,
-		NdisMoveMemory(pMsg->KeyDesc.KeyIv, &KeyNonce[16], LEN_KEY_DESC_IV);
-        pMsg->KeyDesc.KeyIv[15] += 2;
-				}
-
-    // Fill Key RSC field
-    // It contains the RSC for the GTK being installed.
-	if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2) || (MsgType == EAPOL_GROUP_MSG_1))
-				{
-        NdisMoveMemory(pMsg->KeyDesc.KeyRsc, TxRSC, 6);
-				}
-
+		NdisMoveMemory(pMsg->KeyDesc.KeyIv, &KeyNonce[16],
+			       LEN_KEY_DESC_IV);
+		pMsg->KeyDesc.KeyIv[15] += 2;
+	}
+	// Fill Key RSC field
+	// It contains the RSC for the GTK being installed.
+	if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2)
+	    || (MsgType == EAPOL_GROUP_MSG_1)) {
+		NdisMoveMemory(pMsg->KeyDesc.KeyRsc, TxRSC, 6);
+	}
 	// Clear Key MIC field for MIC calculation later
-    NdisZeroMemory(pMsg->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
+	NdisZeroMemory(pMsg->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
 
 	ConstructEapolKeyData(pEntry,
-						  GroupKeyWepStatus,
-						  KeyDescVer,
-						  MsgType,
-						  DefaultKeyIdx,
-						  GTK,
-						  RSNIE,
-						  RSNIE_Len,
-						  pMsg);
+			      GroupKeyWepStatus,
+			      KeyDescVer,
+			      MsgType,
+			      DefaultKeyIdx, GTK, RSNIE, RSNIE_Len, pMsg);
 
 	// Calculate MIC and fill in KeyMic Field except Pairwise Msg 1.
-	if (MsgType != EAPOL_PAIR_MSG_1)
-			{
+	if (MsgType != EAPOL_PAIR_MSG_1) {
 		CalculateMIC(KeyDescVer, pEntry->PTK, pMsg);
-		}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("===> ConstructEapolMsg for %s %s\n", ((bWPA2) ? "WPA2" : "WPA"), GetEapolMsgType(MsgType)));
-	DBGPRINT(RT_DEBUG_TRACE, ("	     Body length = %d \n", CONV_ARRARY_TO_UINT16(pMsg->Body_Len)));
-	DBGPRINT(RT_DEBUG_TRACE, ("	     Key length  = %d \n", CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyLength)));
+	}
 
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("===> ConstructEapolMsg for %s %s\n",
+		  ((bWPA2) ? "WPA2" : "WPA"), GetEapolMsgType(MsgType)));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("	     Body length = %d \n",
+		  CONV_ARRARY_TO_UINT16(pMsg->Body_Len)));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("	     Key length  = %d \n",
+		  CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyLength)));
 
 }
 
@@ -2509,38 +2483,35 @@ VOID	ConstructEapolMsg(
 
 	========================================================================
 */
-VOID	ConstructEapolKeyData(
-	IN	PMAC_TABLE_ENTRY	pEntry,
-	IN	UCHAR			GroupKeyWepStatus,
-	IN	UCHAR			keyDescVer,
-	IN	UCHAR			MsgType,
-	IN	UCHAR			DefaultKeyIdx,
-	IN	UCHAR			*GTK,
-	IN	UCHAR			*RSNIE,
-	IN	UCHAR			RSNIE_LEN,
-	OUT PEAPOL_PACKET   pMsg)
-{
-	UCHAR		*mpool, *Key_Data, *Rc4GTK;
-	UCHAR       ekey[(LEN_KEY_DESC_IV+LEN_EAP_EK)];
-	ULONG		data_offset;
-	BOOLEAN		bWPA2Capable = FALSE;
-	PRTMP_ADAPTER	pAd = pEntry->pAd;
-	BOOLEAN		GTK_Included = FALSE;
+VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
+			   IN UCHAR GroupKeyWepStatus,
+			   IN UCHAR keyDescVer,
+			   IN UCHAR MsgType,
+			   IN UCHAR DefaultKeyIdx,
+			   IN UCHAR * GTK,
+			   IN UCHAR * RSNIE,
+			   IN UCHAR RSNIE_LEN, OUT PEAPOL_PACKET pMsg)
+{
+	UCHAR *mpool, *Key_Data, *Rc4GTK;
+	UCHAR ekey[(LEN_KEY_DESC_IV + LEN_EAP_EK)];
+	ULONG data_offset;
+	BOOLEAN bWPA2Capable = FALSE;
+	PRTMP_ADAPTER pAd = pEntry->pAd;
+	BOOLEAN GTK_Included = FALSE;
 
 	// Choose WPA2 or not
 	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) ||
-		(pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
+	    (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
 		bWPA2Capable = TRUE;
 
 	if (MsgType == EAPOL_PAIR_MSG_1 ||
-		MsgType == EAPOL_PAIR_MSG_4 ||
-		MsgType == EAPOL_GROUP_MSG_2)
+	    MsgType == EAPOL_PAIR_MSG_4 || MsgType == EAPOL_GROUP_MSG_2)
 		return;
 
 	// allocate memory pool
-	os_alloc_mem(NULL, (PUCHAR *)&mpool, 1500);
+	os_alloc_mem(NULL, (PUCHAR *) & mpool, 1500);
 
-    if (mpool == NULL)
+	if (mpool == NULL)
 		return;
 
 	/* Rc4GTK Len = 512 */
@@ -2553,80 +2524,68 @@ VOID	ConstructEapolKeyData(
 	data_offset = 0;
 
 	// Encapsulate RSNIE in pairwise_msg2 & pairwise_msg3
-	if (RSNIE_LEN && ((MsgType == EAPOL_PAIR_MSG_2) || (MsgType == EAPOL_PAIR_MSG_3)))
-	{
-		PUINT8	pmkid_ptr = NULL;
-		UINT8	pmkid_len = 0;
-
+	if (RSNIE_LEN
+	    && ((MsgType == EAPOL_PAIR_MSG_2)
+		|| (MsgType == EAPOL_PAIR_MSG_3))) {
+		PUINT8 pmkid_ptr = NULL;
+		UINT8 pmkid_len = 0;
 
 		RTMPInsertRSNIE(&Key_Data[data_offset],
-						&data_offset,
-						RSNIE,
-						RSNIE_LEN,
-						pmkid_ptr,
-						pmkid_len);
+				&data_offset,
+				RSNIE, RSNIE_LEN, pmkid_ptr, pmkid_len);
 	}
 
-
 	// Encapsulate KDE format in pairwise_msg3_WPA2 & group_msg1_WPA2
-	if (bWPA2Capable && ((MsgType == EAPOL_PAIR_MSG_3) || (MsgType == EAPOL_GROUP_MSG_1)))
-        {
+	if (bWPA2Capable
+	    && ((MsgType == EAPOL_PAIR_MSG_3)
+		|| (MsgType == EAPOL_GROUP_MSG_1))) {
 		// Key Data Encapsulation (KDE) format - 802.11i-2004  Figure-43w and Table-20h
-        Key_Data[data_offset + 0] = 0xDD;
+		Key_Data[data_offset + 0] = 0xDD;
 
-		if (GroupKeyWepStatus == Ndis802_11Encryption3Enabled)
-		{
-			Key_Data[data_offset + 1] = 0x16;// 4+2+16(OUI+DataType+DataField)
-		}
-		else
-		{
-			Key_Data[data_offset + 1] = 0x26;// 4+2+32(OUI+DataType+DataField)
+		if (GroupKeyWepStatus == Ndis802_11Encryption3Enabled) {
+			Key_Data[data_offset + 1] = 0x16;	// 4+2+16(OUI+DataType+DataField)
+		} else {
+			Key_Data[data_offset + 1] = 0x26;	// 4+2+32(OUI+DataType+DataField)
 		}
 
-        Key_Data[data_offset + 2] = 0x00;
-        Key_Data[data_offset + 3] = 0x0F;
-        Key_Data[data_offset + 4] = 0xAC;
-        Key_Data[data_offset + 5] = 0x01;
+		Key_Data[data_offset + 2] = 0x00;
+		Key_Data[data_offset + 3] = 0x0F;
+		Key_Data[data_offset + 4] = 0xAC;
+		Key_Data[data_offset + 5] = 0x01;
 
 		// GTK KDE format - 802.11i-2004  Figure-43x
-        Key_Data[data_offset + 6] = (DefaultKeyIdx & 0x03);
-        Key_Data[data_offset + 7] = 0x00;	// Reserved Byte
+		Key_Data[data_offset + 6] = (DefaultKeyIdx & 0x03);
+		Key_Data[data_offset + 7] = 0x00;	// Reserved Byte
 
 		data_offset += 8;
 	}
 
-
 	// Encapsulate GTK
 	// Only for pairwise_msg3_WPA2 and group_msg1
-	if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2Capable) || (MsgType == EAPOL_GROUP_MSG_1))
-	{
+	if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2Capable)
+	    || (MsgType == EAPOL_GROUP_MSG_1)) {
 		// Fill in GTK
-		if (GroupKeyWepStatus == Ndis802_11Encryption3Enabled)
-		{
-			NdisMoveMemory(&Key_Data[data_offset], GTK, LEN_AES_KEY);
+		if (GroupKeyWepStatus == Ndis802_11Encryption3Enabled) {
+			NdisMoveMemory(&Key_Data[data_offset], GTK,
+				       LEN_AES_KEY);
 			data_offset += LEN_AES_KEY;
-		}
-		else
-		{
-			NdisMoveMemory(&Key_Data[data_offset], GTK, TKIP_GTK_LENGTH);
+		} else {
+			NdisMoveMemory(&Key_Data[data_offset], GTK,
+				       TKIP_GTK_LENGTH);
 			data_offset += TKIP_GTK_LENGTH;
 		}
 
 		GTK_Included = TRUE;
 	}
 
-
 	// This whole key-data field shall be encrypted if a GTK is included.
 	// Encrypt the data material in key data field with KEK
-	if (GTK_Included)
-	{
+	if (GTK_Included) {
 		//hex_dump("GTK_Included", Key_Data, data_offset);
 
-		if (
-			(keyDescVer == DESC_TYPE_AES))
-		{
-			UCHAR	remainder = 0;
-			UCHAR	pad_len = 0;
+		if ((keyDescVer == DESC_TYPE_AES)) {
+			UCHAR remainder = 0;
+			UCHAR pad_len = 0;
 
 			// Key Descriptor Version 2 or 3: AES key wrap, defined in IETF RFC 3394,
 			// shall be used to encrypt the Key Data field using the KEK field from
@@ -2636,9 +2595,8 @@ VOID	ConstructEapolKeyData(
 			// shall be padded before encrypting if the key data length is less than 16
 			// octets or if it is not a multiple of 8. The padding consists of appending
 			// a single octet 0xdd followed by zero or more 0x00 octets.
-			if ((remainder = data_offset & 0x07) != 0)
-			{
-				INT		i;
+			if ((remainder = data_offset & 0x07) != 0) {
+				INT i;
 
 				pad_len = (8 - remainder);
 				Key_Data[data_offset] = 0xDD;
@@ -2646,33 +2604,35 @@ VOID	ConstructEapolKeyData(
 					Key_Data[data_offset + i] = 0;
 
 				data_offset += pad_len;
-        }
+			}
 
-			AES_GTK_KEY_WRAP(&pEntry->PTK[16], Key_Data, data_offset, Rc4GTK);
-            // AES wrap function will grow 8 bytes in length
-            data_offset += 8;
-	}
-	else
-	{
-			/*	Key Descriptor Version 1: ARC4 is used to encrypt the Key Data field
-				using the KEK field from the derived PTK. */
+			AES_GTK_KEY_WRAP(&pEntry->PTK[16], Key_Data,
+					 data_offset, Rc4GTK);
+			// AES wrap function will grow 8 bytes in length
+			data_offset += 8;
+		} else {
+			/*      Key Descriptor Version 1: ARC4 is used to encrypt the Key Data field
+			   using the KEK field from the derived PTK. */
 
 			// PREPARE Encrypted  "Key DATA" field.  (Encrypt GTK with RC4, usinf PTK[16]->[31] as Key, IV-field as IV)
 			// put TxTsc in Key RSC field
-			pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;   //Init crc32.
+			pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;	//Init crc32.
 
 			// ekey is the contanetion of IV-field, and PTK[16]->PTK[31]
-			NdisMoveMemory(ekey, pMsg->KeyDesc.KeyIv, LEN_KEY_DESC_IV);
-			NdisMoveMemory(&ekey[LEN_KEY_DESC_IV], &pEntry->PTK[16], LEN_EAP_EK);
-			ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, ekey, sizeof(ekey));  //INIT SBOX, KEYLEN+3(IV)
-			pAd->PrivateInfo.FCSCRC32 = RTMP_CALC_FCS32(pAd->PrivateInfo.FCSCRC32, Key_Data, data_offset);
-			WPAARCFOUR_ENCRYPT(&pAd->PrivateInfo.WEPCONTEXT, Rc4GTK, Key_Data, data_offset);
+			NdisMoveMemory(ekey, pMsg->KeyDesc.KeyIv,
+				       LEN_KEY_DESC_IV);
+			NdisMoveMemory(&ekey[LEN_KEY_DESC_IV], &pEntry->PTK[16],
+				       LEN_EAP_EK);
+			ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, ekey, sizeof(ekey));	//INIT SBOX, KEYLEN+3(IV)
+			pAd->PrivateInfo.FCSCRC32 =
+			    RTMP_CALC_FCS32(pAd->PrivateInfo.FCSCRC32, Key_Data,
+					    data_offset);
+			WPAARCFOUR_ENCRYPT(&pAd->PrivateInfo.WEPCONTEXT, Rc4GTK,
+					   Key_Data, data_offset);
 		}
 
 		NdisMoveMemory(pMsg->KeyDesc.KeyData, Rc4GTK, data_offset);
-        }
-	else
-	{
+	} else {
 		NdisMoveMemory(pMsg->KeyDesc.KeyData, Key_Data, data_offset);
 	}
 
@@ -2700,41 +2660,36 @@ VOID	ConstructEapolKeyData(
 
 	========================================================================
 */
-static VOID	CalculateMIC(
-	IN	UCHAR			KeyDescVer,
-	IN	UCHAR			*PTK,
-	OUT PEAPOL_PACKET   pMsg)
-{
-    UCHAR   *OutBuffer;
-	ULONG	FrameLen = 0;
-	UCHAR	mic[LEN_KEY_DESC_MIC];
-	UCHAR	digest[80];
+static VOID CalculateMIC(IN UCHAR KeyDescVer,
+			 IN UCHAR * PTK, OUT PEAPOL_PACKET pMsg)
+{
+	UCHAR *OutBuffer;
+	ULONG FrameLen = 0;
+	UCHAR mic[LEN_KEY_DESC_MIC];
+	UCHAR digest[80];
 
 	// allocate memory for MIC calculation
-	os_alloc_mem(NULL, (PUCHAR *)&OutBuffer, 512);
+	os_alloc_mem(NULL, (PUCHAR *) & OutBuffer, 512);
 
-    if (OutBuffer == NULL)
-    {
+	if (OutBuffer == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR, ("!!!CalculateMIC: no memory!!!\n"));
 		return;
-    }
-
+	}
 	// make a frame for calculating MIC.
-    MakeOutgoingFrame(OutBuffer,		&FrameLen,
-                      CONV_ARRARY_TO_UINT16(pMsg->Body_Len) + 4,	pMsg,
-                      END_OF_ARGS);
+	MakeOutgoingFrame(OutBuffer, &FrameLen,
+			  CONV_ARRARY_TO_UINT16(pMsg->Body_Len) + 4, pMsg,
+			  END_OF_ARGS);
 
 	NdisZeroMemory(mic, sizeof(mic));
 
 	// Calculate MIC
-    if (KeyDescVer == DESC_TYPE_AES)
-	{
-		HMAC_SHA1(PTK, LEN_EAP_MICK, OutBuffer,  FrameLen, digest, SHA1_DIGEST_SIZE);
+	if (KeyDescVer == DESC_TYPE_AES) {
+		HMAC_SHA1(PTK, LEN_EAP_MICK, OutBuffer, FrameLen, digest,
+			  SHA1_DIGEST_SIZE);
 		NdisMoveMemory(mic, digest, LEN_KEY_DESC_MIC);
-	}
-	else
-	{
-		HMAC_MD5(PTK,  LEN_EAP_MICK, OutBuffer, FrameLen, mic, MD5_DIGEST_SIZE);
+	} else {
+		HMAC_MD5(PTK, LEN_EAP_MICK, OutBuffer, FrameLen, mic,
+			 MD5_DIGEST_SIZE);
 	}
 
 	// store the calculated MIC
@@ -2759,66 +2714,58 @@ static VOID	CalculateMIC(
 
 	========================================================================
 */
-NDIS_STATUS	RTMPSoftDecryptBroadCastData(
-    IN  PRTMP_ADAPTER   pAd,
-	IN	RX_BLK							*pRxBlk,
-	IN  NDIS_802_11_ENCRYPTION_STATUS	GroupCipher,
-	IN  PCIPHER_KEY						pShard_key)
+NDIS_STATUS RTMPSoftDecryptBroadCastData(IN PRTMP_ADAPTER pAd,
+					 IN RX_BLK * pRxBlk,
+					 IN NDIS_802_11_ENCRYPTION_STATUS
+					 GroupCipher, IN PCIPHER_KEY pShard_key)
 {
-	PRXWI_STRUC			pRxWI = pRxBlk->pRxWI;
-
-
+	PRXWI_STRUC pRxWI = pRxBlk->pRxWI;
 
 	// handle WEP decryption
-	if (GroupCipher == Ndis802_11Encryption1Enabled)
-	{
-		if (RTMPSoftDecryptWEP(pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount, pShard_key))
-		{
+	if (GroupCipher == Ndis802_11Encryption1Enabled) {
+		if (RTMPSoftDecryptWEP
+		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount,
+		     pShard_key)) {
 
 			//Minus IV[4] & ICV[4]
 			pRxWI->MPDUtotalByteCount -= 8;
-		}
-		else
-			{
-			DBGPRINT(RT_DEBUG_ERROR, ("ERROR : Software decrypt WEP data fails.\n"));
+		} else {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("ERROR : Software decrypt WEP data fails.\n"));
 			// give up this frame
 			return NDIS_STATUS_FAILURE;
 		}
 	}
 	// handle TKIP decryption
-	else if (GroupCipher == Ndis802_11Encryption2Enabled)
-	{
-		if (RTMPSoftDecryptTKIP(pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount, 0, pShard_key))
-		{
+	else if (GroupCipher == Ndis802_11Encryption2Enabled) {
+		if (RTMPSoftDecryptTKIP
+		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount, 0,
+		     pShard_key)) {
 
 			//Minus 8 bytes MIC, 8 bytes IV/EIV, 4 bytes ICV
 			pRxWI->MPDUtotalByteCount -= 20;
-			}
-			else
-			{
-			DBGPRINT(RT_DEBUG_ERROR, ("ERROR : RTMPSoftDecryptTKIP Failed\n"));
+		} else {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("ERROR : RTMPSoftDecryptTKIP Failed\n"));
 			// give up this frame
 			return NDIS_STATUS_FAILURE;
-			}
+		}
 	}
 	// handle AES decryption
-	else if (GroupCipher == Ndis802_11Encryption3Enabled)
-	{
-		if (RTMPSoftDecryptAES(pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount , pShard_key))
-		{
+	else if (GroupCipher == Ndis802_11Encryption3Enabled) {
+		if (RTMPSoftDecryptAES
+		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount,
+		     pShard_key)) {
 
 			//8 bytes MIC, 8 bytes IV/EIV (CCMP Header)
 			pRxWI->MPDUtotalByteCount -= 16;
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("ERROR : RTMPSoftDecryptAES Failed\n"));
+		} else {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("ERROR : RTMPSoftDecryptAES Failed\n"));
 			// give up this frame
 			return NDIS_STATUS_FAILURE;
 		}
-	}
-	else
-	{
+	} else {
 		// give up this frame
 		return NDIS_STATUS_FAILURE;
 	}
@@ -2827,118 +2774,95 @@ NDIS_STATUS	RTMPSoftDecryptBroadCastData
 
 }
 
-
-PUINT8	GetSuiteFromRSNIE(
-		IN	PUINT8	rsnie,
-		IN	UINT	rsnie_len,
-		IN	UINT8	type,
-		OUT	UINT8	*count)
+PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
+			 IN UINT rsnie_len, IN UINT8 type, OUT UINT8 * count)
 {
 	PEID_STRUCT pEid;
-	INT			len;
-	PUINT8		pBuf;
-	INT			offset = 0;
-	PRSNIE_AUTH	pAkm;
-	UINT16		acount;
-	BOOLEAN		isWPA2 = FALSE;
+	INT len;
+	PUINT8 pBuf;
+	INT offset = 0;
+	PRSNIE_AUTH pAkm;
+	UINT16 acount;
+	BOOLEAN isWPA2 = FALSE;
 
-	pEid = (PEID_STRUCT)rsnie;
+	pEid = (PEID_STRUCT) rsnie;
 	len = rsnie_len - 2;	// exclude IE and length
-	pBuf = (PUINT8)&pEid->Octet[0];
-
-
+	pBuf = (PUINT8) & pEid->Octet[0];
 
 	// set default value
 	*count = 0;
 
 	// Check length
-	if ((len <= 0) || (pEid->Len != len))
-	{
+	if ((len <= 0) || (pEid->Len != len)) {
 		DBGPRINT_ERR(("%s : The length is invalid\n", __func__));
 		return NULL;
 	}
-
 	// Check WPA or WPA2
-	if (pEid->Eid == IE_WPA)
-	{
-		PRSNIE	pRsnie = (PRSNIE)pBuf;
+	if (pEid->Eid == IE_WPA) {
+		PRSNIE pRsnie = (PRSNIE) pBuf;
 		UINT16 ucount;
 
-		if (len < sizeof(RSNIE))
-	{
-			DBGPRINT_ERR(("%s : The length is too short for WPA\n", __func__));
+		if (len < sizeof(RSNIE)) {
+			DBGPRINT_ERR(("%s : The length is too short for WPA\n",
+				      __func__));
 			return NULL;
 		}
-
 		// Get the count of pairwise cipher
 		ucount = cpu2le16(pRsnie->ucount);
-		if (ucount > 2)
-		{
-			DBGPRINT_ERR(("%s : The count(%d) of pairwise cipher is invlaid\n",
-											__func__, ucount));
+		if (ucount > 2) {
+			DBGPRINT_ERR(("%s : The count(%d) of pairwise cipher is invlaid\n", __func__, ucount));
 			return NULL;
 		}
-
 		// Get the group cipher
-		if (type == GROUP_SUITE)
-		{
+		if (type == GROUP_SUITE) {
 			*count = 1;
 			return pRsnie->mcast;
 		}
 		// Get the pairwise cipher suite
-		else if (type == PAIRWISE_SUITE)
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("%s : The count of pairwise cipher is %d\n",
-										__func__, ucount));
+		else if (type == PAIRWISE_SUITE) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("%s : The count of pairwise cipher is %d\n",
+				  __func__, ucount));
 			*count = ucount;
 			return pRsnie->ucast[0].oui;
-	}
+		}
 
 		offset = sizeof(RSNIE) + (4 * (ucount - 1));
 
-	}
-	else if (pEid->Eid == IE_RSN)
-	{
-		PRSNIE2	pRsnie = (PRSNIE2)pBuf;
+	} else if (pEid->Eid == IE_RSN) {
+		PRSNIE2 pRsnie = (PRSNIE2) pBuf;
 		UINT16 ucount;
 
 		isWPA2 = TRUE;
 
-		if (len < sizeof(RSNIE2))
-		{
-			DBGPRINT_ERR(("%s : The length is too short for WPA2\n", __func__));
+		if (len < sizeof(RSNIE2)) {
+			DBGPRINT_ERR(("%s : The length is too short for WPA2\n",
+				      __func__));
 			return NULL;
 		}
-
 		// Get the count of pairwise cipher
 		ucount = cpu2le16(pRsnie->ucount);
-		if (ucount > 2)
-		{
-			DBGPRINT_ERR(("%s : The count(%d) of pairwise cipher is invlaid\n",
-											__func__, ucount));
+		if (ucount > 2) {
+			DBGPRINT_ERR(("%s : The count(%d) of pairwise cipher is invlaid\n", __func__, ucount));
 			return NULL;
 		}
-
 		// Get the group cipher
-		if (type == GROUP_SUITE)
-		{
+		if (type == GROUP_SUITE) {
 			*count = 1;
 			return pRsnie->mcast;
 		}
 		// Get the pairwise cipher suite
-		else if (type == PAIRWISE_SUITE)
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("%s : The count of pairwise cipher is %d\n",
-										__func__, ucount));
+		else if (type == PAIRWISE_SUITE) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("%s : The count of pairwise cipher is %d\n",
+				  __func__, ucount));
 			*count = ucount;
 			return pRsnie->ucast[0].oui;
 		}
 
 		offset = sizeof(RSNIE2) + (4 * (ucount - 1));
 
-	}
-	else
-	{
+	} else {
 		DBGPRINT_ERR(("%s : Unknown IE (%d)\n", __func__, pEid->Eid));
 		return NULL;
 	}
@@ -2947,53 +2871,45 @@ PUINT8	GetSuiteFromRSNIE(
 	pBuf += offset;
 	len -= offset;
 
-	if (len < sizeof(RSNIE_AUTH))
-	{
-		DBGPRINT_ERR(("%s : The length of RSNIE is too short\n", __func__));
+	if (len < sizeof(RSNIE_AUTH)) {
+		DBGPRINT_ERR(("%s : The length of RSNIE is too short\n",
+			      __func__));
 		return NULL;
 	}
-
 	// pointer to AKM count
-	pAkm = (PRSNIE_AUTH)pBuf;
+	pAkm = (PRSNIE_AUTH) pBuf;
 
 	// Get the count of pairwise cipher
 	acount = cpu2le16(pAkm->acount);
-	if (acount > 2)
-    {
+	if (acount > 2) {
 		DBGPRINT_ERR(("%s : The count(%d) of AKM is invlaid\n",
-										__func__, acount));
+			      __func__, acount));
 		return NULL;
-    }
-
+	}
 	// Get the AKM suite
-	if (type == AKM_SUITE)
-    {
+	if (type == AKM_SUITE) {
 		DBGPRINT(RT_DEBUG_TRACE, ("%s : The count of AKM is %d\n",
-									__func__, acount));
+					  __func__, acount));
 		*count = acount;
 		return pAkm->auth[0].oui;
-    }
+	}
 	offset = sizeof(RSNIE_AUTH) + (4 * (acount - 1));
 
 	pBuf += offset;
 	len -= offset;
 
 	// The remaining length must larger than (RSN-Capability(2) + PMKID-Count(2) + PMKID(16~))
-	if (len >= (sizeof(RSN_CAPABILITIES) + 2 + LEN_PMKID))
-    {
+	if (len >= (sizeof(RSN_CAPABILITIES) + 2 + LEN_PMKID)) {
 		// Skip RSN capability and PMKID-Count
 		pBuf += (sizeof(RSN_CAPABILITIES) + 2);
 		len -= (sizeof(RSN_CAPABILITIES) + 2);
 
 		// Get PMKID
-		if (type == PMKID_LIST)
-            {
+		if (type == PMKID_LIST) {
 			*count = 1;
 			return pBuf;
-            }
-    }
-	else
-	{
+		}
+	} else {
 		DBGPRINT_ERR(("%s : it can't get any more information beyond AKM \n", __func__));
 		return NULL;
 	}
@@ -3004,9 +2920,7 @@ PUINT8	GetSuiteFromRSNIE(
 
 }
 
-VOID WpaShowAllsuite(
-	IN	PUINT8	rsnie,
-	IN	UINT	rsnie_len)
+VOID WpaShowAllsuite(IN PUINT8 rsnie, IN UINT rsnie_len)
 {
 	PUINT8 pSuite = NULL;
 	UINT8 count;
@@ -3014,99 +2928,89 @@ VOID WpaShowAllsuite(
 	hex_dump("RSNIE", rsnie, rsnie_len);
 
 	// group cipher
-	if ((pSuite = GetSuiteFromRSNIE(rsnie, rsnie_len, GROUP_SUITE, &count)) != NULL)
-	{
-		hex_dump("group cipher", pSuite, 4*count);
+	if ((pSuite =
+	     GetSuiteFromRSNIE(rsnie, rsnie_len, GROUP_SUITE,
+			       &count)) != NULL) {
+		hex_dump("group cipher", pSuite, 4 * count);
 	}
-
 	// pairwise cipher
-	if ((pSuite = GetSuiteFromRSNIE(rsnie, rsnie_len, PAIRWISE_SUITE, &count)) != NULL)
-	{
-		hex_dump("pairwise cipher", pSuite, 4*count);
+	if ((pSuite =
+	     GetSuiteFromRSNIE(rsnie, rsnie_len, PAIRWISE_SUITE,
+			       &count)) != NULL) {
+		hex_dump("pairwise cipher", pSuite, 4 * count);
 	}
-
 	// AKM
-	if ((pSuite = GetSuiteFromRSNIE(rsnie, rsnie_len, AKM_SUITE, &count)) != NULL)
-	{
-		hex_dump("AKM suite", pSuite, 4*count);
+	if ((pSuite =
+	     GetSuiteFromRSNIE(rsnie, rsnie_len, AKM_SUITE, &count)) != NULL) {
+		hex_dump("AKM suite", pSuite, 4 * count);
 	}
-
 	// PMKID
-	if ((pSuite = GetSuiteFromRSNIE(rsnie, rsnie_len, PMKID_LIST, &count)) != NULL)
-	{
+	if ((pSuite =
+	     GetSuiteFromRSNIE(rsnie, rsnie_len, PMKID_LIST, &count)) != NULL) {
 		hex_dump("PMKID", pSuite, LEN_PMKID);
 	}
 
 }
 
-VOID RTMPInsertRSNIE(
-	IN PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN PUINT8 rsnie_ptr,
-	IN UINT8  rsnie_len,
-	IN PUINT8 pmkid_ptr,
-	IN UINT8  pmkid_len)
-{
-	PUCHAR	pTmpBuf;
-	ULONG	TempLen = 0;
-	UINT8	extra_len = 0;
-	UINT16	pmk_count = 0;
-	UCHAR	ie_num;
-	UINT8	total_len = 0;
-    UCHAR	WPA2_OUI[3]={0x00,0x0F,0xAC};
+VOID RTMPInsertRSNIE(IN PUCHAR pFrameBuf,
+		     OUT PULONG pFrameLen,
+		     IN PUINT8 rsnie_ptr,
+		     IN UINT8 rsnie_len,
+		     IN PUINT8 pmkid_ptr, IN UINT8 pmkid_len)
+{
+	PUCHAR pTmpBuf;
+	ULONG TempLen = 0;
+	UINT8 extra_len = 0;
+	UINT16 pmk_count = 0;
+	UCHAR ie_num;
+	UINT8 total_len = 0;
+	UCHAR WPA2_OUI[3] = { 0x00, 0x0F, 0xAC };
 
 	pTmpBuf = pFrameBuf;
 
 	/* PMKID-List Must larger than 0 and the multiple of 16. */
-	if (pmkid_len > 0 && ((pmkid_len & 0x0f) == 0))
-	{
+	if (pmkid_len > 0 && ((pmkid_len & 0x0f) == 0)) {
 		extra_len = sizeof(UINT16) + pmkid_len;
 
 		pmk_count = (pmkid_len >> 4);
 		pmk_count = cpu2le16(pmk_count);
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_WARN, ("%s : The length is PMKID-List is invalid (%d), so don't insert it.\n",
-									__func__, pmkid_len));
+	} else {
+		DBGPRINT(RT_DEBUG_WARN,
+			 ("%s : The length is PMKID-List is invalid (%d), so don't insert it.\n",
+			  __func__, pmkid_len));
 	}
 
-	if (rsnie_len != 0)
-    {
+	if (rsnie_len != 0) {
 		ie_num = IE_WPA;
 		total_len = rsnie_len;
 
-		if (NdisEqualMemory(rsnie_ptr + 2, WPA2_OUI, sizeof(WPA2_OUI)))
-	{
+		if (NdisEqualMemory(rsnie_ptr + 2, WPA2_OUI, sizeof(WPA2_OUI))) {
 			ie_num = IE_RSN;
 			total_len += extra_len;
-	}
+		}
 
 		/* construct RSNIE body */
-		MakeOutgoingFrame(pTmpBuf,			&TempLen,
-						  1,				&ie_num,
-						  1,				&total_len,
-						  rsnie_len,		rsnie_ptr,
-						  END_OF_ARGS);
+		MakeOutgoingFrame(pTmpBuf, &TempLen,
+				  1, &ie_num,
+				  1, &total_len,
+				  rsnie_len, rsnie_ptr, END_OF_ARGS);
 
 		pTmpBuf += TempLen;
 		*pFrameLen = *pFrameLen + TempLen;
 
-		if (ie_num == IE_RSN)
-	{
+		if (ie_num == IE_RSN) {
 			/* Insert PMKID-List field */
-			if (extra_len > 0)
-		{
-				MakeOutgoingFrame(pTmpBuf,					&TempLen,
-								  2,						&pmk_count,
-								  pmkid_len,				pmkid_ptr,
-								  END_OF_ARGS);
+			if (extra_len > 0) {
+				MakeOutgoingFrame(pTmpBuf, &TempLen,
+						  2, &pmk_count,
+						  pmkid_len, pmkid_ptr,
+						  END_OF_ARGS);
 
 				pTmpBuf += TempLen;
 				*pFrameLen = *pFrameLen + TempLen;
+			}
 		}
 	}
-	}
 
 	return;
 }
--- a/drivers/staging/rt2860/common/crypt_hmac.c
+++ b/drivers/staging/rt2860/common/crypt_hmac.c
@@ -26,7 +26,6 @@
 
 #include "../crypt_hmac.h"
 
-
 #ifdef HMAC_SHA1_SUPPORT
 /*
 ========================================================================
@@ -47,66 +46,63 @@ Note:
     None
 ========================================================================
 */
-VOID HMAC_SHA1 (
-    IN  const UINT8 Key[],
-    IN  UINT KeyLen,
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen,
-    OUT UINT8 MAC[],
-    IN  UINT MACLen)
+VOID HMAC_SHA1(IN const UINT8 Key[],
+	       IN UINT KeyLen,
+	       IN const UINT8 Message[],
+	       IN UINT MessageLen, OUT UINT8 MAC[], IN UINT MACLen)
 {
-    SHA1_CTX_STRUC sha_ctx1;
-    SHA1_CTX_STRUC sha_ctx2;
-    UINT8 K0[SHA1_BLOCK_SIZE];
-    UINT8 Digest[SHA1_DIGEST_SIZE];
-    UINT index;
-
-    NdisZeroMemory(&sha_ctx1, sizeof(SHA1_CTX_STRUC));
-    NdisZeroMemory(&sha_ctx2, sizeof(SHA1_CTX_STRUC));
-    /*
-     * If the length of K = B(Block size): K0 = K.
-     * If the length of K > B: hash K to obtain an L byte string,
-     * then append (B-L) zeros to create a B-byte string K0 (i.e., K0 = H(K) || 00...00).
-     * If the length of K < B: append zeros to the end of K to create a B-byte string K0
-     */
-    NdisZeroMemory(K0, SHA1_BLOCK_SIZE);
-    if (KeyLen <= SHA1_BLOCK_SIZE)
-        NdisMoveMemory(K0, Key, KeyLen);
-    else
-        RT_SHA1(Key, KeyLen, K0);
-    /* End of if */
-
-    /* Exclusive-Or K0 with ipad */
-    /* ipad: Inner pad; the byte x¡¦36¡¦ repeated B times. */
-    for (index = 0; index < SHA1_BLOCK_SIZE; index++)
-        K0[index] ^= 0x36;
-        /* End of for */
-
-    RT_SHA1_Init(&sha_ctx1);
-    /* H(K0^ipad) */
-    SHA1_Append(&sha_ctx1, K0, sizeof(K0));
-    /* H((K0^ipad)||text) */
-    SHA1_Append(&sha_ctx1, Message, MessageLen);
-    SHA1_End(&sha_ctx1, Digest);
-
-    /* Exclusive-Or K0 with opad and remove ipad */
-    /* opad: Outer pad; the byte x¡¦5c¡¦ repeated B times. */
-    for (index = 0; index < SHA1_BLOCK_SIZE; index++)
-        K0[index] ^= 0x36^0x5c;
-        /* End of for */
-
-    RT_SHA1_Init(&sha_ctx2);
-    /* H(K0^opad) */
-    SHA1_Append(&sha_ctx2, K0, sizeof(K0));
-    /* H( (K0^opad) || H((K0^ipad)||text) ) */
-    SHA1_Append(&sha_ctx2, Digest, SHA1_DIGEST_SIZE);
-    SHA1_End(&sha_ctx2, Digest);
-
-    if (MACLen > SHA1_DIGEST_SIZE)
-        NdisMoveMemory(MAC, Digest, SHA1_DIGEST_SIZE);
-    else
-        NdisMoveMemory(MAC, Digest, MACLen);
-} /* End of HMAC_SHA1 */
+	SHA1_CTX_STRUC sha_ctx1;
+	SHA1_CTX_STRUC sha_ctx2;
+	UINT8 K0[SHA1_BLOCK_SIZE];
+	UINT8 Digest[SHA1_DIGEST_SIZE];
+	UINT index;
+
+	NdisZeroMemory(&sha_ctx1, sizeof(SHA1_CTX_STRUC));
+	NdisZeroMemory(&sha_ctx2, sizeof(SHA1_CTX_STRUC));
+	/*
+	 * If the length of K = B(Block size): K0 = K.
+	 * If the length of K > B: hash K to obtain an L byte string,
+	 * then append (B-L) zeros to create a B-byte string K0 (i.e., K0 = H(K) || 00...00).
+	 * If the length of K < B: append zeros to the end of K to create a B-byte string K0
+	 */
+	NdisZeroMemory(K0, SHA1_BLOCK_SIZE);
+	if (KeyLen <= SHA1_BLOCK_SIZE)
+		NdisMoveMemory(K0, Key, KeyLen);
+	else
+		RT_SHA1(Key, KeyLen, K0);
+	/* End of if */
+
+	/* Exclusive-Or K0 with ipad */
+	/* ipad: Inner pad; the byte x¡¦36¡¦ repeated B times. */
+	for (index = 0; index < SHA1_BLOCK_SIZE; index++)
+		K0[index] ^= 0x36;
+	/* End of for */
+
+	RT_SHA1_Init(&sha_ctx1);
+	/* H(K0^ipad) */
+	SHA1_Append(&sha_ctx1, K0, sizeof(K0));
+	/* H((K0^ipad)||text) */
+	SHA1_Append(&sha_ctx1, Message, MessageLen);
+	SHA1_End(&sha_ctx1, Digest);
+
+	/* Exclusive-Or K0 with opad and remove ipad */
+	/* opad: Outer pad; the byte x¡¦5c¡¦ repeated B times. */
+	for (index = 0; index < SHA1_BLOCK_SIZE; index++)
+		K0[index] ^= 0x36 ^ 0x5c;
+	/* End of for */
+
+	RT_SHA1_Init(&sha_ctx2);
+	/* H(K0^opad) */
+	SHA1_Append(&sha_ctx2, K0, sizeof(K0));
+	/* H( (K0^opad) || H((K0^ipad)||text) ) */
+	SHA1_Append(&sha_ctx2, Digest, SHA1_DIGEST_SIZE);
+	SHA1_End(&sha_ctx2, Digest);
+
+	if (MACLen > SHA1_DIGEST_SIZE)
+		NdisMoveMemory(MAC, Digest, SHA1_DIGEST_SIZE);
+	else
+		NdisMoveMemory(MAC, Digest, MACLen);
+}				/* End of HMAC_SHA1 */
 #endif /* HMAC_SHA1_SUPPORT */
 
 #ifdef HMAC_MD5_SUPPORT
@@ -129,66 +125,63 @@ Note:
     None
 ========================================================================
 */
-VOID HMAC_MD5(
-    IN  const UINT8 Key[],
-    IN  UINT KeyLen,
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen,
-    OUT UINT8 MAC[],
-    IN  UINT MACLen)
+VOID HMAC_MD5(IN const UINT8 Key[],
+	      IN UINT KeyLen,
+	      IN const UINT8 Message[],
+	      IN UINT MessageLen, OUT UINT8 MAC[], IN UINT MACLen)
 {
-    MD5_CTX_STRUC md5_ctx1;
-    MD5_CTX_STRUC md5_ctx2;
-    UINT8 K0[MD5_BLOCK_SIZE];
-    UINT8 Digest[MD5_DIGEST_SIZE];
-    UINT index;
-
-    NdisZeroMemory(&md5_ctx1, sizeof(MD5_CTX_STRUC));
-    NdisZeroMemory(&md5_ctx2, sizeof(MD5_CTX_STRUC));
-    /*
-     * If the length of K = B(Block size): K0 = K.
-     * If the length of K > B: hash K to obtain an L byte string,
-     * then append (B-L) zeros to create a B-byte string K0 (i.e., K0 = H(K) || 00...00).
-     * If the length of K < B: append zeros to the end of K to create a B-byte string K0
-     */
-    NdisZeroMemory(K0, MD5_BLOCK_SIZE);
-    if (KeyLen <= MD5_BLOCK_SIZE) {
-        NdisMoveMemory(K0, Key, KeyLen);
-    } else {
-        RT_MD5(Key, KeyLen, K0);
-    }
-
-    /* Exclusive-Or K0 with ipad */
-    /* ipad: Inner pad; the byte x¡¦36¡¦ repeated B times. */
-    for (index = 0; index < MD5_BLOCK_SIZE; index++)
-        K0[index] ^= 0x36;
-        /* End of for */
-
-    MD5_Init(&md5_ctx1);
-    /* H(K0^ipad) */
-    MD5_Append(&md5_ctx1, K0, sizeof(K0));
-    /* H((K0^ipad)||text) */
-    MD5_Append(&md5_ctx1, Message, MessageLen);
-    MD5_End(&md5_ctx1, Digest);
-
-    /* Exclusive-Or K0 with opad and remove ipad */
-    /* opad: Outer pad; the byte x¡¦5c¡¦ repeated B times. */
-    for (index = 0; index < MD5_BLOCK_SIZE; index++)
-        K0[index] ^= 0x36^0x5c;
-        /* End of for */
-
-    MD5_Init(&md5_ctx2);
-    /* H(K0^opad) */
-    MD5_Append(&md5_ctx2, K0, sizeof(K0));
-    /* H( (K0^opad) || H((K0^ipad)||text) ) */
-    MD5_Append(&md5_ctx2, Digest, MD5_DIGEST_SIZE);
-    MD5_End(&md5_ctx2, Digest);
-
-    if (MACLen > MD5_DIGEST_SIZE)
-        NdisMoveMemory(MAC, Digest, MD5_DIGEST_SIZE);
-    else
-        NdisMoveMemory(MAC, Digest, MACLen);
-} /* End of HMAC_SHA256 */
+	MD5_CTX_STRUC md5_ctx1;
+	MD5_CTX_STRUC md5_ctx2;
+	UINT8 K0[MD5_BLOCK_SIZE];
+	UINT8 Digest[MD5_DIGEST_SIZE];
+	UINT index;
+
+	NdisZeroMemory(&md5_ctx1, sizeof(MD5_CTX_STRUC));
+	NdisZeroMemory(&md5_ctx2, sizeof(MD5_CTX_STRUC));
+	/*
+	 * If the length of K = B(Block size): K0 = K.
+	 * If the length of K > B: hash K to obtain an L byte string,
+	 * then append (B-L) zeros to create a B-byte string K0 (i.e., K0 = H(K) || 00...00).
+	 * If the length of K < B: append zeros to the end of K to create a B-byte string K0
+	 */
+	NdisZeroMemory(K0, MD5_BLOCK_SIZE);
+	if (KeyLen <= MD5_BLOCK_SIZE) {
+		NdisMoveMemory(K0, Key, KeyLen);
+	} else {
+		RT_MD5(Key, KeyLen, K0);
+	}
+
+	/* Exclusive-Or K0 with ipad */
+	/* ipad: Inner pad; the byte x¡¦36¡¦ repeated B times. */
+	for (index = 0; index < MD5_BLOCK_SIZE; index++)
+		K0[index] ^= 0x36;
+	/* End of for */
+
+	MD5_Init(&md5_ctx1);
+	/* H(K0^ipad) */
+	MD5_Append(&md5_ctx1, K0, sizeof(K0));
+	/* H((K0^ipad)||text) */
+	MD5_Append(&md5_ctx1, Message, MessageLen);
+	MD5_End(&md5_ctx1, Digest);
+
+	/* Exclusive-Or K0 with opad and remove ipad */
+	/* opad: Outer pad; the byte x¡¦5c¡¦ repeated B times. */
+	for (index = 0; index < MD5_BLOCK_SIZE; index++)
+		K0[index] ^= 0x36 ^ 0x5c;
+	/* End of for */
+
+	MD5_Init(&md5_ctx2);
+	/* H(K0^opad) */
+	MD5_Append(&md5_ctx2, K0, sizeof(K0));
+	/* H( (K0^opad) || H((K0^ipad)||text) ) */
+	MD5_Append(&md5_ctx2, Digest, MD5_DIGEST_SIZE);
+	MD5_End(&md5_ctx2, Digest);
+
+	if (MACLen > MD5_DIGEST_SIZE)
+		NdisMoveMemory(MAC, Digest, MD5_DIGEST_SIZE);
+	else
+		NdisMoveMemory(MAC, Digest, MACLen);
+}				/* End of HMAC_SHA256 */
 #endif /* HMAC_MD5_SUPPORT */
 
 /* End of crypt_hmac.c */
--- a/drivers/staging/rt2860/common/crypt_md5.c
+++ b/drivers/staging/rt2860/common/crypt_md5.c
@@ -36,7 +36,7 @@
 #define I(x, y, z) ((y) ^ ((x) | (~z)))
 
 #define ROTL(x,n,w) ((x << n) | (x >> (w - n)))
-#define ROTL32(x,n) ROTL(x,n,32) /* 32 bits word */
+#define ROTL32(x,n) ROTL(x,n,32)	/* 32 bits word */
 
 #define ROUND1(a, b, c, d, x, s, ac) {          \
     (a) += F((b),(c),(d)) + (x) + (UINT32)(ac); \
@@ -59,11 +59,10 @@
     (a) += (b);                                 \
 }
 static const UINT32 MD5_DefaultHashValue[4] = {
-    0x67452301UL, 0xefcdab89UL, 0x98badcfeUL, 0x10325476UL
+	0x67452301UL, 0xefcdab89UL, 0x98badcfeUL, 0x10325476UL
 };
 #endif /* MD5_SUPPORT */
 
-
 #ifdef MD5_SUPPORT
 /*
 ========================================================================
@@ -80,16 +79,14 @@ Note:
     None
 ========================================================================
 */
-VOID MD5_Init (
-    IN  MD5_CTX_STRUC *pMD5_CTX)
+VOID MD5_Init(IN MD5_CTX_STRUC * pMD5_CTX)
 {
-    NdisMoveMemory(pMD5_CTX->HashValue, MD5_DefaultHashValue,
-        sizeof(MD5_DefaultHashValue));
-    NdisZeroMemory(pMD5_CTX->Block, MD5_BLOCK_SIZE);
-    pMD5_CTX->BlockLen   = 0;
-    pMD5_CTX->MessageLen = 0;
-} /* End of MD5_Init */
-
+	NdisMoveMemory(pMD5_CTX->HashValue, MD5_DefaultHashValue,
+		       sizeof(MD5_DefaultHashValue));
+	NdisZeroMemory(pMD5_CTX->Block, MD5_BLOCK_SIZE);
+	pMD5_CTX->BlockLen = 0;
+	pMD5_CTX->MessageLen = 0;
+}				/* End of MD5_Init */
 
 /*
 ========================================================================
@@ -106,124 +103,122 @@ Note:
     T[i] := floor(abs(sin(i + 1)) * (2 pow 32)), i is number of round
 ========================================================================
 */
-VOID MD5_Hash (
-    IN  MD5_CTX_STRUC *pMD5_CTX)
+VOID MD5_Hash(IN MD5_CTX_STRUC * pMD5_CTX)
 {
-    UINT32 X_i;
-    UINT32 X[16];
-    UINT32 a,b,c,d;
-
-    /* Prepare the message schedule, {X_i} */
-    NdisMoveMemory(X, pMD5_CTX->Block, MD5_BLOCK_SIZE);
-    for (X_i = 0; X_i < 16; X_i++)
-        X[X_i] = cpu2le32(X[X_i]); /* Endian Swap */
-        /* End of for */
-
-    /* MD5 hash computation */
-    /* Initialize the working variables */
-    a = pMD5_CTX->HashValue[0];
-    b = pMD5_CTX->HashValue[1];
-    c = pMD5_CTX->HashValue[2];
-    d = pMD5_CTX->HashValue[3];
-
-    /*
-     *  Round 1
-     *  Let [abcd k s i] denote the operation
-     *  a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s)
-     */
-    ROUND1(a, b, c, d, X[ 0],  7, 0xd76aa478); /* 1 */
-    ROUND1(d, a, b, c, X[ 1], 12, 0xe8c7b756); /* 2 */
-    ROUND1(c, d, a, b, X[ 2], 17, 0x242070db); /* 3 */
-    ROUND1(b, c, d, a, X[ 3], 22, 0xc1bdceee); /* 4 */
-    ROUND1(a, b, c, d, X[ 4],  7, 0xf57c0faf); /* 5 */
-    ROUND1(d, a, b, c, X[ 5], 12, 0x4787c62a); /* 6 */
-    ROUND1(c, d, a, b, X[ 6], 17, 0xa8304613); /* 7 */
-    ROUND1(b, c, d, a, X[ 7], 22, 0xfd469501); /* 8 */
-    ROUND1(a, b, c, d, X[ 8],  7, 0x698098d8); /* 9 */
-    ROUND1(d, a, b, c, X[ 9], 12, 0x8b44f7af); /* 10 */
-    ROUND1(c, d, a, b, X[10], 17, 0xffff5bb1); /* 11 */
-    ROUND1(b, c, d, a, X[11], 22, 0x895cd7be); /* 12 */
-    ROUND1(a, b, c, d, X[12],  7, 0x6b901122); /* 13 */
-    ROUND1(d, a, b, c, X[13], 12, 0xfd987193); /* 14 */
-    ROUND1(c, d, a, b, X[14], 17, 0xa679438e); /* 15 */
-    ROUND1(b, c, d, a, X[15], 22, 0x49b40821); /* 16 */
-
-    /*
-     *  Round 2
-     *  Let [abcd k s i] denote the operation
-     *  a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s)
-     */
-    ROUND2(a, b, c, d, X[ 1],  5, 0xf61e2562); /* 17 */
-    ROUND2(d, a, b, c, X[ 6],  9, 0xc040b340); /* 18 */
-    ROUND2(c, d, a, b, X[11], 14, 0x265e5a51); /* 19 */
-    ROUND2(b, c, d, a, X[ 0], 20, 0xe9b6c7aa); /* 20 */
-    ROUND2(a, b, c, d, X[ 5],  5, 0xd62f105d); /* 21 */
-    ROUND2(d, a, b, c, X[10],  9,  0x2441453); /* 22 */
-    ROUND2(c, d, a, b, X[15], 14, 0xd8a1e681); /* 23 */
-    ROUND2(b, c, d, a, X[ 4], 20, 0xe7d3fbc8); /* 24 */
-    ROUND2(a, b, c, d, X[ 9],  5, 0x21e1cde6); /* 25 */
-    ROUND2(d, a, b, c, X[14],  9, 0xc33707d6); /* 26 */
-    ROUND2(c, d, a, b, X[ 3], 14, 0xf4d50d87); /* 27 */
-    ROUND2(b, c, d, a, X[ 8], 20, 0x455a14ed); /* 28 */
-    ROUND2(a, b, c, d, X[13],  5, 0xa9e3e905); /* 29 */
-    ROUND2(d, a, b, c, X[ 2],  9, 0xfcefa3f8); /* 30 */
-    ROUND2(c, d, a, b, X[ 7], 14, 0x676f02d9); /* 31 */
-    ROUND2(b, c, d, a, X[12], 20, 0x8d2a4c8a); /* 32 */
-
-    /*
-     *  Round 3
-     *  Let [abcd k s t] denote the operation
-     *  a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s)
-     */
-    ROUND3(a, b, c, d, X[ 5],  4, 0xfffa3942); /* 33 */
-    ROUND3(d, a, b, c, X[ 8], 11, 0x8771f681); /* 34 */
-    ROUND3(c, d, a, b, X[11], 16, 0x6d9d6122); /* 35 */
-    ROUND3(b, c, d, a, X[14], 23, 0xfde5380c); /* 36 */
-    ROUND3(a, b, c, d, X[ 1],  4, 0xa4beea44); /* 37 */
-    ROUND3(d, a, b, c, X[ 4], 11, 0x4bdecfa9); /* 38 */
-    ROUND3(c, d, a, b, X[ 7], 16, 0xf6bb4b60); /* 39 */
-    ROUND3(b, c, d, a, X[10], 23, 0xbebfbc70); /* 40 */
-    ROUND3(a, b, c, d, X[13],  4, 0x289b7ec6); /* 41 */
-    ROUND3(d, a, b, c, X[ 0], 11, 0xeaa127fa); /* 42 */
-    ROUND3(c, d, a, b, X[ 3], 16, 0xd4ef3085); /* 43 */
-    ROUND3(b, c, d, a, X[ 6], 23,  0x4881d05); /* 44 */
-    ROUND3(a, b, c, d, X[ 9],  4, 0xd9d4d039); /* 45 */
-    ROUND3(d, a, b, c, X[12], 11, 0xe6db99e5); /* 46 */
-    ROUND3(c, d, a, b, X[15], 16, 0x1fa27cf8); /* 47 */
-    ROUND3(b, c, d, a, X[ 2], 23, 0xc4ac5665); /* 48 */
-
-    /*
-     *  Round 4
-     *  Let [abcd k s t] denote the operation
-     *  a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s)
-     */
-    ROUND4(a, b, c, d, X[ 0],  6, 0xf4292244); /* 49 */
-    ROUND4(d, a, b, c, X[ 7], 10, 0x432aff97); /* 50 */
-    ROUND4(c, d, a, b, X[14], 15, 0xab9423a7); /* 51 */
-    ROUND4(b, c, d, a, X[ 5], 21, 0xfc93a039); /* 52 */
-    ROUND4(a, b, c, d, X[12],  6, 0x655b59c3); /* 53 */
-    ROUND4(d, a, b, c, X[ 3], 10, 0x8f0ccc92); /* 54 */
-    ROUND4(c, d, a, b, X[10], 15, 0xffeff47d); /* 55 */
-    ROUND4(b, c, d, a, X[ 1], 21, 0x85845dd1); /* 56 */
-    ROUND4(a, b, c, d, X[ 8],  6, 0x6fa87e4f); /* 57 */
-    ROUND4(d, a, b, c, X[15], 10, 0xfe2ce6e0); /* 58 */
-    ROUND4(c, d, a, b, X[ 6], 15, 0xa3014314); /* 59 */
-    ROUND4(b, c, d, a, X[13], 21, 0x4e0811a1); /* 60 */
-    ROUND4(a, b, c, d, X[ 4],  6, 0xf7537e82); /* 61 */
-    ROUND4(d, a, b, c, X[11], 10, 0xbd3af235); /* 62 */
-    ROUND4(c, d, a, b, X[ 2], 15, 0x2ad7d2bb); /* 63 */
-    ROUND4(b, c, d, a, X[ 9], 21, 0xeb86d391); /* 64 */
-
-    /* Compute the i^th intermediate hash value H^(i) */
-    pMD5_CTX->HashValue[0] += a;
-    pMD5_CTX->HashValue[1] += b;
-    pMD5_CTX->HashValue[2] += c;
-    pMD5_CTX->HashValue[3] += d;
-
-    NdisZeroMemory(pMD5_CTX->Block, MD5_BLOCK_SIZE);
-    pMD5_CTX->BlockLen = 0;
-} /* End of MD5_Hash */
-
+	UINT32 X_i;
+	UINT32 X[16];
+	UINT32 a, b, c, d;
+
+	/* Prepare the message schedule, {X_i} */
+	NdisMoveMemory(X, pMD5_CTX->Block, MD5_BLOCK_SIZE);
+	for (X_i = 0; X_i < 16; X_i++)
+		X[X_i] = cpu2le32(X[X_i]);	/* Endian Swap */
+	/* End of for */
+
+	/* MD5 hash computation */
+	/* Initialize the working variables */
+	a = pMD5_CTX->HashValue[0];
+	b = pMD5_CTX->HashValue[1];
+	c = pMD5_CTX->HashValue[2];
+	d = pMD5_CTX->HashValue[3];
+
+	/*
+	 *  Round 1
+	 *  Let [abcd k s i] denote the operation
+	 *  a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s)
+	 */
+	ROUND1(a, b, c, d, X[0], 7, 0xd76aa478);	/* 1 */
+	ROUND1(d, a, b, c, X[1], 12, 0xe8c7b756);	/* 2 */
+	ROUND1(c, d, a, b, X[2], 17, 0x242070db);	/* 3 */
+	ROUND1(b, c, d, a, X[3], 22, 0xc1bdceee);	/* 4 */
+	ROUND1(a, b, c, d, X[4], 7, 0xf57c0faf);	/* 5 */
+	ROUND1(d, a, b, c, X[5], 12, 0x4787c62a);	/* 6 */
+	ROUND1(c, d, a, b, X[6], 17, 0xa8304613);	/* 7 */
+	ROUND1(b, c, d, a, X[7], 22, 0xfd469501);	/* 8 */
+	ROUND1(a, b, c, d, X[8], 7, 0x698098d8);	/* 9 */
+	ROUND1(d, a, b, c, X[9], 12, 0x8b44f7af);	/* 10 */
+	ROUND1(c, d, a, b, X[10], 17, 0xffff5bb1);	/* 11 */
+	ROUND1(b, c, d, a, X[11], 22, 0x895cd7be);	/* 12 */
+	ROUND1(a, b, c, d, X[12], 7, 0x6b901122);	/* 13 */
+	ROUND1(d, a, b, c, X[13], 12, 0xfd987193);	/* 14 */
+	ROUND1(c, d, a, b, X[14], 17, 0xa679438e);	/* 15 */
+	ROUND1(b, c, d, a, X[15], 22, 0x49b40821);	/* 16 */
+
+	/*
+	 *  Round 2
+	 *  Let [abcd k s i] denote the operation
+	 *  a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s)
+	 */
+	ROUND2(a, b, c, d, X[1], 5, 0xf61e2562);	/* 17 */
+	ROUND2(d, a, b, c, X[6], 9, 0xc040b340);	/* 18 */
+	ROUND2(c, d, a, b, X[11], 14, 0x265e5a51);	/* 19 */
+	ROUND2(b, c, d, a, X[0], 20, 0xe9b6c7aa);	/* 20 */
+	ROUND2(a, b, c, d, X[5], 5, 0xd62f105d);	/* 21 */
+	ROUND2(d, a, b, c, X[10], 9, 0x2441453);	/* 22 */
+	ROUND2(c, d, a, b, X[15], 14, 0xd8a1e681);	/* 23 */
+	ROUND2(b, c, d, a, X[4], 20, 0xe7d3fbc8);	/* 24 */
+	ROUND2(a, b, c, d, X[9], 5, 0x21e1cde6);	/* 25 */
+	ROUND2(d, a, b, c, X[14], 9, 0xc33707d6);	/* 26 */
+	ROUND2(c, d, a, b, X[3], 14, 0xf4d50d87);	/* 27 */
+	ROUND2(b, c, d, a, X[8], 20, 0x455a14ed);	/* 28 */
+	ROUND2(a, b, c, d, X[13], 5, 0xa9e3e905);	/* 29 */
+	ROUND2(d, a, b, c, X[2], 9, 0xfcefa3f8);	/* 30 */
+	ROUND2(c, d, a, b, X[7], 14, 0x676f02d9);	/* 31 */
+	ROUND2(b, c, d, a, X[12], 20, 0x8d2a4c8a);	/* 32 */
+
+	/*
+	 *  Round 3
+	 *  Let [abcd k s t] denote the operation
+	 *  a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s)
+	 */
+	ROUND3(a, b, c, d, X[5], 4, 0xfffa3942);	/* 33 */
+	ROUND3(d, a, b, c, X[8], 11, 0x8771f681);	/* 34 */
+	ROUND3(c, d, a, b, X[11], 16, 0x6d9d6122);	/* 35 */
+	ROUND3(b, c, d, a, X[14], 23, 0xfde5380c);	/* 36 */
+	ROUND3(a, b, c, d, X[1], 4, 0xa4beea44);	/* 37 */
+	ROUND3(d, a, b, c, X[4], 11, 0x4bdecfa9);	/* 38 */
+	ROUND3(c, d, a, b, X[7], 16, 0xf6bb4b60);	/* 39 */
+	ROUND3(b, c, d, a, X[10], 23, 0xbebfbc70);	/* 40 */
+	ROUND3(a, b, c, d, X[13], 4, 0x289b7ec6);	/* 41 */
+	ROUND3(d, a, b, c, X[0], 11, 0xeaa127fa);	/* 42 */
+	ROUND3(c, d, a, b, X[3], 16, 0xd4ef3085);	/* 43 */
+	ROUND3(b, c, d, a, X[6], 23, 0x4881d05);	/* 44 */
+	ROUND3(a, b, c, d, X[9], 4, 0xd9d4d039);	/* 45 */
+	ROUND3(d, a, b, c, X[12], 11, 0xe6db99e5);	/* 46 */
+	ROUND3(c, d, a, b, X[15], 16, 0x1fa27cf8);	/* 47 */
+	ROUND3(b, c, d, a, X[2], 23, 0xc4ac5665);	/* 48 */
+
+	/*
+	 *  Round 4
+	 *  Let [abcd k s t] denote the operation
+	 *  a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s)
+	 */
+	ROUND4(a, b, c, d, X[0], 6, 0xf4292244);	/* 49 */
+	ROUND4(d, a, b, c, X[7], 10, 0x432aff97);	/* 50 */
+	ROUND4(c, d, a, b, X[14], 15, 0xab9423a7);	/* 51 */
+	ROUND4(b, c, d, a, X[5], 21, 0xfc93a039);	/* 52 */
+	ROUND4(a, b, c, d, X[12], 6, 0x655b59c3);	/* 53 */
+	ROUND4(d, a, b, c, X[3], 10, 0x8f0ccc92);	/* 54 */
+	ROUND4(c, d, a, b, X[10], 15, 0xffeff47d);	/* 55 */
+	ROUND4(b, c, d, a, X[1], 21, 0x85845dd1);	/* 56 */
+	ROUND4(a, b, c, d, X[8], 6, 0x6fa87e4f);	/* 57 */
+	ROUND4(d, a, b, c, X[15], 10, 0xfe2ce6e0);	/* 58 */
+	ROUND4(c, d, a, b, X[6], 15, 0xa3014314);	/* 59 */
+	ROUND4(b, c, d, a, X[13], 21, 0x4e0811a1);	/* 60 */
+	ROUND4(a, b, c, d, X[4], 6, 0xf7537e82);	/* 61 */
+	ROUND4(d, a, b, c, X[11], 10, 0xbd3af235);	/* 62 */
+	ROUND4(c, d, a, b, X[2], 15, 0x2ad7d2bb);	/* 63 */
+	ROUND4(b, c, d, a, X[9], 21, 0xeb86d391);	/* 64 */
+
+	/* Compute the i^th intermediate hash value H^(i) */
+	pMD5_CTX->HashValue[0] += a;
+	pMD5_CTX->HashValue[1] += b;
+	pMD5_CTX->HashValue[2] += c;
+	pMD5_CTX->HashValue[3] += d;
+
+	NdisZeroMemory(pMD5_CTX->Block, MD5_BLOCK_SIZE);
+	pMD5_CTX->BlockLen = 0;
+}				/* End of MD5_Hash */
 
 /*
 ========================================================================
@@ -243,34 +238,30 @@ Note:
     None
 ========================================================================
 */
-VOID MD5_Append (
-    IN  MD5_CTX_STRUC *pMD5_CTX,
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen)
+VOID MD5_Append(IN MD5_CTX_STRUC * pMD5_CTX,
+		IN const UINT8 Message[], IN UINT MessageLen)
 {
-    UINT appendLen = 0;
-    UINT diffLen = 0;
-
-    while (appendLen != MessageLen) {
-        diffLen = MessageLen - appendLen;
-        if ((pMD5_CTX->BlockLen + diffLen) < MD5_BLOCK_SIZE) {
-            NdisMoveMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen,
-                Message + appendLen, diffLen);
-            pMD5_CTX->BlockLen += diffLen;
-            appendLen += diffLen;
-        }
-        else
-        {
-            NdisMoveMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen,
-                Message + appendLen, MD5_BLOCK_SIZE - pMD5_CTX->BlockLen);
-            appendLen += (MD5_BLOCK_SIZE - pMD5_CTX->BlockLen);
-            pMD5_CTX->BlockLen = MD5_BLOCK_SIZE;
-            MD5_Hash(pMD5_CTX);
-        } /* End of if */
-    } /* End of while */
-    pMD5_CTX->MessageLen += MessageLen;
-} /* End of MD5_Append */
+	UINT appendLen = 0;
+	UINT diffLen = 0;
 
+	while (appendLen != MessageLen) {
+		diffLen = MessageLen - appendLen;
+		if ((pMD5_CTX->BlockLen + diffLen) < MD5_BLOCK_SIZE) {
+			NdisMoveMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen,
+				       Message + appendLen, diffLen);
+			pMD5_CTX->BlockLen += diffLen;
+			appendLen += diffLen;
+		} else {
+			NdisMoveMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen,
+				       Message + appendLen,
+				       MD5_BLOCK_SIZE - pMD5_CTX->BlockLen);
+			appendLen += (MD5_BLOCK_SIZE - pMD5_CTX->BlockLen);
+			pMD5_CTX->BlockLen = MD5_BLOCK_SIZE;
+			MD5_Hash(pMD5_CTX);
+		}		/* End of if */
+	}			/* End of while */
+	pMD5_CTX->MessageLen += MessageLen;
+}				/* End of MD5_Append */
 
 /*
 ========================================================================
@@ -289,34 +280,32 @@ Note:
     None
 ========================================================================
 */
-VOID MD5_End (
-    IN  MD5_CTX_STRUC *pMD5_CTX,
-    OUT UINT8 DigestMessage[])
+VOID MD5_End(IN MD5_CTX_STRUC * pMD5_CTX, OUT UINT8 DigestMessage[])
 {
-    UINT index;
-    UINT64 message_length_bits;
-
-    /* append 1 bits to end of the message */
-    NdisFillMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen, 1, 0x80);
+	UINT index;
+	UINT64 message_length_bits;
 
-    /* 55 = 64 - 8 - 1: append 1 bit(1 byte) and message length (8 bytes) */
-    if (pMD5_CTX->BlockLen > 55)
-        MD5_Hash(pMD5_CTX);
-        /* End of if */
-
-    /* Append the length of message in rightmost 64 bits */
-    message_length_bits = pMD5_CTX->MessageLen*8;
-    message_length_bits = cpu2le64(message_length_bits);
-    NdisMoveMemory(&pMD5_CTX->Block[56], &message_length_bits, 8);
-    MD5_Hash(pMD5_CTX);
-
-    /* Return message digest, transform the UINT32 hash value to bytes */
-    for (index = 0; index < 4;index++)
-        pMD5_CTX->HashValue[index] = cpu2le32(pMD5_CTX->HashValue[index]);
-        /* End of for */
-    NdisMoveMemory(DigestMessage, pMD5_CTX->HashValue, MD5_DIGEST_SIZE);
-} /* End of MD5_End */
+	/* append 1 bits to end of the message */
+	NdisFillMemory(pMD5_CTX->Block + pMD5_CTX->BlockLen, 1, 0x80);
 
+	/* 55 = 64 - 8 - 1: append 1 bit(1 byte) and message length (8 bytes) */
+	if (pMD5_CTX->BlockLen > 55)
+		MD5_Hash(pMD5_CTX);
+	/* End of if */
+
+	/* Append the length of message in rightmost 64 bits */
+	message_length_bits = pMD5_CTX->MessageLen * 8;
+	message_length_bits = cpu2le64(message_length_bits);
+	NdisMoveMemory(&pMD5_CTX->Block[56], &message_length_bits, 8);
+	MD5_Hash(pMD5_CTX);
+
+	/* Return message digest, transform the UINT32 hash value to bytes */
+	for (index = 0; index < 4; index++)
+		pMD5_CTX->HashValue[index] =
+		    cpu2le32(pMD5_CTX->HashValue[index]);
+	/* End of for */
+	NdisMoveMemory(DigestMessage, pMD5_CTX->HashValue, MD5_DIGEST_SIZE);
+}				/* End of MD5_End */
 
 /*
 ========================================================================
@@ -334,18 +323,16 @@ Note:
     None
 ========================================================================
 */
-VOID RT_MD5 (
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen,
-    OUT UINT8 DigestMessage[])
+VOID RT_MD5(IN const UINT8 Message[],
+	    IN UINT MessageLen, OUT UINT8 DigestMessage[])
 {
-    MD5_CTX_STRUC md5_ctx;
+	MD5_CTX_STRUC md5_ctx;
 
-    NdisZeroMemory(&md5_ctx, sizeof(MD5_CTX_STRUC));
-    MD5_Init(&md5_ctx);
-    MD5_Append(&md5_ctx, Message, MessageLen);
-    MD5_End(&md5_ctx, DigestMessage);
-} /* End of RT_MD5 */
+	NdisZeroMemory(&md5_ctx, sizeof(MD5_CTX_STRUC));
+	MD5_Init(&md5_ctx);
+	MD5_Append(&md5_ctx, Message, MessageLen);
+	MD5_End(&md5_ctx, DigestMessage);
+}				/* End of RT_MD5 */
 
 #endif /* MD5_SUPPORT */
 
--- a/drivers/staging/rt2860/common/crypt_sha2.c
+++ b/drivers/staging/rt2860/common/crypt_sha2.c
@@ -27,11 +27,11 @@
 #include "../crypt_sha2.h"
 
 /* Basic operations */
-#define SHR(x,n) (x >> n) /* SHR(x)^n, right shift n bits , x is w-bit word, 0 <= n <= w */
-#define ROTR(x,n,w) ((x >> n) | (x << (w - n))) /* ROTR(x)^n, circular right shift n bits , x is w-bit word, 0 <= n <= w */
-#define ROTL(x,n,w) ((x << n) | (x >> (w - n))) /* ROTL(x)^n, circular left shift n bits , x is w-bit word, 0 <= n <= w */
-#define ROTR32(x,n) ROTR(x,n,32) /* 32 bits word */
-#define ROTL32(x,n) ROTL(x,n,32) /* 32 bits word */
+#define SHR(x,n) (x >> n)	/* SHR(x)^n, right shift n bits , x is w-bit word, 0 <= n <= w */
+#define ROTR(x,n,w) ((x >> n) | (x << (w - n)))	/* ROTR(x)^n, circular right shift n bits , x is w-bit word, 0 <= n <= w */
+#define ROTL(x,n,w) ((x << n) | (x >> (w - n)))	/* ROTL(x)^n, circular left shift n bits , x is w-bit word, 0 <= n <= w */
+#define ROTR32(x,n) ROTR(x,n,32)	/* 32 bits word */
+#define ROTL32(x,n) ROTL(x,n,32)	/* 32 bits word */
 
 /* Basic functions */
 #define Ch(x,y,z) ((x & y) ^ ((~x) & z))
@@ -42,10 +42,11 @@
 /* SHA1 constants */
 #define SHA1_MASK 0x0000000f
 static const UINT32 SHA1_K[4] = {
-    0x5a827999UL, 0x6ed9eba1UL, 0x8f1bbcdcUL, 0xca62c1d6UL
+	0x5a827999UL, 0x6ed9eba1UL, 0x8f1bbcdcUL, 0xca62c1d6UL
 };
+
 static const UINT32 SHA1_DefaultHashValue[5] = {
-    0x67452301UL, 0xefcdab89UL, 0x98badcfeUL, 0x10325476UL, 0xc3d2e1f0UL
+	0x67452301UL, 0xefcdab89UL, 0x98badcfeUL, 0x10325476UL, 0xc3d2e1f0UL
 };
 
 /*
@@ -63,16 +64,14 @@ Note:
     None
 ========================================================================
 */
-VOID RT_SHA1_Init (
-    IN  SHA1_CTX_STRUC *pSHA_CTX)
+VOID RT_SHA1_Init(IN SHA1_CTX_STRUC * pSHA_CTX)
 {
-    NdisMoveMemory(pSHA_CTX->HashValue, SHA1_DefaultHashValue,
-        sizeof(SHA1_DefaultHashValue));
-    NdisZeroMemory(pSHA_CTX->Block, SHA1_BLOCK_SIZE);
-    pSHA_CTX->MessageLen = 0;
-    pSHA_CTX->BlockLen   = 0;
-} /* End of RT_SHA1_Init */
-
+	NdisMoveMemory(pSHA_CTX->HashValue, SHA1_DefaultHashValue,
+		       sizeof(SHA1_DefaultHashValue));
+	NdisZeroMemory(pSHA_CTX->Block, SHA1_BLOCK_SIZE);
+	pSHA_CTX->MessageLen = 0;
+	pSHA_CTX->BlockLen = 0;
+}				/* End of RT_SHA1_Init */
 
 /*
 ========================================================================
@@ -89,67 +88,67 @@ Note:
     None
 ========================================================================
 */
-VOID SHA1_Hash (
-    IN  SHA1_CTX_STRUC *pSHA_CTX)
+VOID SHA1_Hash(IN SHA1_CTX_STRUC * pSHA_CTX)
 {
-    UINT32 W_i,t,s;
-    UINT32 W[16];
-    UINT32 a,b,c,d,e,T,f_t = 0;
-
-    /* Prepare the message schedule, {W_i}, 0 < t < 15 */
-    NdisMoveMemory(W, pSHA_CTX->Block, SHA1_BLOCK_SIZE);
-    for (W_i = 0; W_i < 16; W_i++)
-        W[W_i] = cpu2be32(W[W_i]); /* Endian Swap */
-        /* End of for */
-
-    /* SHA256 hash computation */
-    /* Initialize the working variables */
-    a = pSHA_CTX->HashValue[0];
-    b = pSHA_CTX->HashValue[1];
-    c = pSHA_CTX->HashValue[2];
-    d = pSHA_CTX->HashValue[3];
-    e = pSHA_CTX->HashValue[4];
-
-    /* 80 rounds */
-    for (t = 0;t < 80;t++) {
-        s = t & SHA1_MASK;
-        if (t > 15) { /* Prepare the message schedule, {W_i}, 16 < t < 79 */
-            W[s] = (W[(s+13) & SHA1_MASK]) ^ (W[(s+8) & SHA1_MASK]) ^ (W[(s+2) & SHA1_MASK]) ^ W[s];
-            W[s] = ROTL32(W[s],1);
-        } /* End of if */
-        switch (t / 20) {
-            case 0:
-                 f_t = Ch(b,c,d);
-                 break;
-            case 1:
-                 f_t = Parity(b,c,d);
-                 break;
-            case 2:
-                 f_t = Maj(b,c,d);
-                 break;
-            case 3:
-                 f_t = Parity(b,c,d);
-                 break;
-        } /* End of switch */
-        T = ROTL32(a,5) + f_t + e + SHA1_K[t / 20] + W[s];
-        e = d;
-        d = c;
-        c = ROTL32(b,30);
-        b = a;
-        a = T;
-     } /* End of for */
-
-     /* Compute the i^th intermediate hash value H^(i) */
-     pSHA_CTX->HashValue[0] += a;
-     pSHA_CTX->HashValue[1] += b;
-     pSHA_CTX->HashValue[2] += c;
-     pSHA_CTX->HashValue[3] += d;
-     pSHA_CTX->HashValue[4] += e;
-
-    NdisZeroMemory(pSHA_CTX->Block, SHA1_BLOCK_SIZE);
-    pSHA_CTX->BlockLen = 0;
-} /* End of SHA1_Hash */
-
+	UINT32 W_i, t, s;
+	UINT32 W[16];
+	UINT32 a, b, c, d, e, T, f_t = 0;
+
+	/* Prepare the message schedule, {W_i}, 0 < t < 15 */
+	NdisMoveMemory(W, pSHA_CTX->Block, SHA1_BLOCK_SIZE);
+	for (W_i = 0; W_i < 16; W_i++)
+		W[W_i] = cpu2be32(W[W_i]);	/* Endian Swap */
+	/* End of for */
+
+	/* SHA256 hash computation */
+	/* Initialize the working variables */
+	a = pSHA_CTX->HashValue[0];
+	b = pSHA_CTX->HashValue[1];
+	c = pSHA_CTX->HashValue[2];
+	d = pSHA_CTX->HashValue[3];
+	e = pSHA_CTX->HashValue[4];
+
+	/* 80 rounds */
+	for (t = 0; t < 80; t++) {
+		s = t & SHA1_MASK;
+		if (t > 15) {	/* Prepare the message schedule, {W_i}, 16 < t < 79 */
+			W[s] =
+			    (W[(s + 13) & SHA1_MASK]) ^ (W[(s + 8) & SHA1_MASK])
+			    ^ (W[(s + 2) & SHA1_MASK]) ^ W[s];
+			W[s] = ROTL32(W[s], 1);
+		}		/* End of if */
+		switch (t / 20) {
+		case 0:
+			f_t = Ch(b, c, d);
+			break;
+		case 1:
+			f_t = Parity(b, c, d);
+			break;
+		case 2:
+			f_t = Maj(b, c, d);
+			break;
+		case 3:
+			f_t = Parity(b, c, d);
+			break;
+		}		/* End of switch */
+		T = ROTL32(a, 5) + f_t + e + SHA1_K[t / 20] + W[s];
+		e = d;
+		d = c;
+		c = ROTL32(b, 30);
+		b = a;
+		a = T;
+	}			/* End of for */
+
+	/* Compute the i^th intermediate hash value H^(i) */
+	pSHA_CTX->HashValue[0] += a;
+	pSHA_CTX->HashValue[1] += b;
+	pSHA_CTX->HashValue[2] += c;
+	pSHA_CTX->HashValue[3] += d;
+	pSHA_CTX->HashValue[4] += e;
+
+	NdisZeroMemory(pSHA_CTX->Block, SHA1_BLOCK_SIZE);
+	pSHA_CTX->BlockLen = 0;
+}				/* End of SHA1_Hash */
 
 /*
 ========================================================================
@@ -169,34 +168,30 @@ Note:
     None
 ========================================================================
 */
-VOID SHA1_Append (
-    IN  SHA1_CTX_STRUC *pSHA_CTX,
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen)
+VOID SHA1_Append(IN SHA1_CTX_STRUC * pSHA_CTX,
+		 IN const UINT8 Message[], IN UINT MessageLen)
 {
-    UINT appendLen = 0;
-    UINT diffLen   = 0;
-
-    while (appendLen != MessageLen) {
-        diffLen = MessageLen - appendLen;
-        if ((pSHA_CTX->BlockLen + diffLen) <  SHA1_BLOCK_SIZE) {
-            NdisMoveMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen,
-                Message + appendLen, diffLen);
-            pSHA_CTX->BlockLen += diffLen;
-            appendLen += diffLen;
-        }
-        else
-        {
-            NdisMoveMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen,
-                Message + appendLen, SHA1_BLOCK_SIZE - pSHA_CTX->BlockLen);
-            appendLen += (SHA1_BLOCK_SIZE - pSHA_CTX->BlockLen);
-            pSHA_CTX->BlockLen = SHA1_BLOCK_SIZE;
-            SHA1_Hash(pSHA_CTX);
-        } /* End of if */
-    } /* End of while */
-    pSHA_CTX->MessageLen += MessageLen;
-} /* End of SHA1_Append */
+	UINT appendLen = 0;
+	UINT diffLen = 0;
 
+	while (appendLen != MessageLen) {
+		diffLen = MessageLen - appendLen;
+		if ((pSHA_CTX->BlockLen + diffLen) < SHA1_BLOCK_SIZE) {
+			NdisMoveMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen,
+				       Message + appendLen, diffLen);
+			pSHA_CTX->BlockLen += diffLen;
+			appendLen += diffLen;
+		} else {
+			NdisMoveMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen,
+				       Message + appendLen,
+				       SHA1_BLOCK_SIZE - pSHA_CTX->BlockLen);
+			appendLen += (SHA1_BLOCK_SIZE - pSHA_CTX->BlockLen);
+			pSHA_CTX->BlockLen = SHA1_BLOCK_SIZE;
+			SHA1_Hash(pSHA_CTX);
+		}		/* End of if */
+	}			/* End of while */
+	pSHA_CTX->MessageLen += MessageLen;
+}				/* End of SHA1_Append */
 
 /*
 ========================================================================
@@ -215,34 +210,32 @@ Note:
     None
 ========================================================================
 */
-VOID SHA1_End (
-    IN  SHA1_CTX_STRUC *pSHA_CTX,
-    OUT UINT8 DigestMessage[])
+VOID SHA1_End(IN SHA1_CTX_STRUC * pSHA_CTX, OUT UINT8 DigestMessage[])
 {
-    UINT index;
-    UINT64 message_length_bits;
-
-    /* Append bit 1 to end of the message */
-    NdisFillMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen, 1, 0x80);
+	UINT index;
+	UINT64 message_length_bits;
 
-    /* 55 = 64 - 8 - 1: append 1 bit(1 byte) and message length (8 bytes) */
-    if (pSHA_CTX->BlockLen > 55)
-        SHA1_Hash(pSHA_CTX);
-        /* End of if */
-
-    /* Append the length of message in rightmost 64 bits */
-    message_length_bits = pSHA_CTX->MessageLen*8;
-    message_length_bits = cpu2be64(message_length_bits);
-    NdisMoveMemory(&pSHA_CTX->Block[56], &message_length_bits, 8);
-    SHA1_Hash(pSHA_CTX);
-
-    /* Return message digest, transform the UINT32 hash value to bytes */
-    for (index = 0; index < 5;index++)
-        pSHA_CTX->HashValue[index] = cpu2be32(pSHA_CTX->HashValue[index]);
-        /* End of for */
-    NdisMoveMemory(DigestMessage, pSHA_CTX->HashValue, SHA1_DIGEST_SIZE);
-} /* End of SHA1_End */
+	/* Append bit 1 to end of the message */
+	NdisFillMemory(pSHA_CTX->Block + pSHA_CTX->BlockLen, 1, 0x80);
 
+	/* 55 = 64 - 8 - 1: append 1 bit(1 byte) and message length (8 bytes) */
+	if (pSHA_CTX->BlockLen > 55)
+		SHA1_Hash(pSHA_CTX);
+	/* End of if */
+
+	/* Append the length of message in rightmost 64 bits */
+	message_length_bits = pSHA_CTX->MessageLen * 8;
+	message_length_bits = cpu2be64(message_length_bits);
+	NdisMoveMemory(&pSHA_CTX->Block[56], &message_length_bits, 8);
+	SHA1_Hash(pSHA_CTX);
+
+	/* Return message digest, transform the UINT32 hash value to bytes */
+	for (index = 0; index < 5; index++)
+		pSHA_CTX->HashValue[index] =
+		    cpu2be32(pSHA_CTX->HashValue[index]);
+	/* End of for */
+	NdisMoveMemory(DigestMessage, pSHA_CTX->HashValue, SHA1_DIGEST_SIZE);
+}				/* End of SHA1_End */
 
 /*
 ========================================================================
@@ -260,19 +253,17 @@ Note:
     None
 ========================================================================
 */
-VOID RT_SHA1 (
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen,
-    OUT UINT8 DigestMessage[])
+VOID RT_SHA1(IN const UINT8 Message[],
+	     IN UINT MessageLen, OUT UINT8 DigestMessage[])
 {
 
-    SHA1_CTX_STRUC sha_ctx;
+	SHA1_CTX_STRUC sha_ctx;
 
-    NdisZeroMemory(&sha_ctx, sizeof(SHA1_CTX_STRUC));
-    RT_SHA1_Init(&sha_ctx);
-    SHA1_Append(&sha_ctx, Message, MessageLen);
-    SHA1_End(&sha_ctx, DigestMessage);
-} /* End of RT_SHA1 */
+	NdisZeroMemory(&sha_ctx, sizeof(SHA1_CTX_STRUC));
+	RT_SHA1_Init(&sha_ctx);
+	SHA1_Append(&sha_ctx, Message, MessageLen);
+	SHA1_End(&sha_ctx, DigestMessage);
+}				/* End of RT_SHA1 */
 #endif /* SHA1_SUPPORT */
 
 /* End of crypt_sha2.c */
--- a/drivers/staging/rt2860/common/dfs.c
+++ b/drivers/staging/rt2860/common/dfs.c
@@ -52,17 +52,13 @@
 
 	========================================================================
 */
-BOOLEAN RadarChannelCheck(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			Ch)
+BOOLEAN RadarChannelCheck(IN PRTMP_ADAPTER pAd, IN UCHAR Ch)
 {
-	INT		i;
+	INT i;
 	BOOLEAN result = FALSE;
 
-	for (i=0; i<pAd->ChannelListNum; i++)
-	{
-		if (Ch == pAd->ChannelList[i].Channel)
-		{
+	for (i = 0; i < pAd->ChannelListNum; i++) {
+		if (Ch == pAd->ChannelList[i].Channel) {
 			result = pAd->ChannelList[i].DfsReq;
 			break;
 		}
--- a/drivers/staging/rt2860/common/ee_efuse.c
+++ b/drivers/staging/rt2860/common/ee_efuse.c
@@ -35,37 +35,30 @@
 	--------    ----------    ----------------------------------------------
 */
 
-
 #include	"../rt_config.h"
 
-
-
 #define EFUSE_USAGE_MAP_START	0x2d0
 #define EFUSE_USAGE_MAP_END		0x2fc
 #define EFUSE_USAGE_MAP_SIZE	45
 
-
-
 #define EFUSE_EEPROM_DEFULT_FILE	"RT30xxEEPROM.bin"
 #define MAX_EEPROM_BIN_FILE_SIZE	1024
 
-
-
 #define EFUSE_TAG				0x2fe
 
-typedef	union	_EFUSE_CTRL_STRUC {
-	struct	{
-		UINT32            EFSROM_AOUT:6;
-		UINT32            EFSROM_MODE:2;
-		UINT32            EFSROM_LDO_OFF_TIME:6;
-		UINT32            EFSROM_LDO_ON_TIME:2;
-		UINT32            EFSROM_AIN:10;
-		UINT32            RESERVED:4;
-		UINT32            EFSROM_KICK:1;
-		UINT32            SEL_EFUSE:1;
-	}	field;
-	UINT32			word;
-}	EFUSE_CTRL_STRUC, *PEFUSE_CTRL_STRUC;
+typedef union _EFUSE_CTRL_STRUC {
+	struct {
+		UINT32 EFSROM_AOUT:6;
+		UINT32 EFSROM_MODE:2;
+		UINT32 EFSROM_LDO_OFF_TIME:6;
+		UINT32 EFSROM_LDO_ON_TIME:2;
+		UINT32 EFSROM_AIN:10;
+		UINT32 RESERVED:4;
+		UINT32 EFSROM_KICK:1;
+		UINT32 SEL_EFUSE:1;
+	} field;
+	UINT32 word;
+} EFUSE_CTRL_STRUC, *PEFUSE_CTRL_STRUC;
 
 /*
 ========================================================================
@@ -80,16 +73,13 @@ typedef	union	_EFUSE_CTRL_STRUC {
 
 ========================================================================
 */
-UCHAR eFuseReadRegisters(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT Offset,
-	IN	USHORT Length,
-	OUT	USHORT* pData)
+UCHAR eFuseReadRegisters(IN PRTMP_ADAPTER pAd,
+			 IN USHORT Offset, IN USHORT Length, OUT USHORT * pData)
 {
-	EFUSE_CTRL_STRUC		eFuseCtrlStruc;
-	int	i;
-	USHORT	efuseDataOffset;
-	UINT32	data;
+	EFUSE_CTRL_STRUC eFuseCtrlStruc;
+	int i;
+	USHORT efuseDataOffset;
+	UINT32 data;
 
 	RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
 
@@ -108,12 +98,10 @@ UCHAR eFuseReadRegisters(
 
 	//Step3. Polling EFSROM_KICK(0x580, bit30) until it become 0 again.
 	i = 0;
-	while(i < 500)
-	{
+	while (i < 500) {
 		//rtmp.HwMemoryReadDword(EFUSE_CTRL, (DWORD *) &eFuseCtrlStruc, 4);
 		RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
-		if(eFuseCtrlStruc.field.EFSROM_KICK == 0)
-		{
+		if (eFuseCtrlStruc.field.EFSROM_KICK == 0) {
 			break;
 		}
 		RTMPusecDelay(2);
@@ -121,28 +109,25 @@ UCHAR eFuseReadRegisters(
 	}
 
 	//if EFSROM_AOUT is not found in physical address, write 0xffff
-	if (eFuseCtrlStruc.field.EFSROM_AOUT == 0x3f)
-	{
-		for(i=0; i<Length/2; i++)
-			*(pData+2*i) = 0xffff;
-	}
-	else
-	{
+	if (eFuseCtrlStruc.field.EFSROM_AOUT == 0x3f) {
+		for (i = 0; i < Length / 2; i++)
+			*(pData + 2 * i) = 0xffff;
+	} else {
 		//Step4. Read 16-byte of data from EFUSE_DATA0-3 (0x590-0x59C)
-		efuseDataOffset =  EFUSE_DATA3 - (Offset & 0xC);
+		efuseDataOffset = EFUSE_DATA3 - (Offset & 0xC);
 		//data hold 4 bytes data.
 		//In RTMP_IO_READ32 will automatically execute 32-bytes swapping
 		RTMP_IO_READ32(pAd, efuseDataOffset, &data);
 		//Decide the upper 2 bytes or the bottom 2 bytes.
-		// Little-endian		S	|	S	Big-endian
-		// addr	3	2	1	0	|	0	1	2	3
-		// Ori-V	D	C	B	A	|	A	B	C	D
+		// Little-endian                S       |       S       Big-endian
+		// addr 3       2       1       0       |       0       1       2       3
+		// Ori-V        D       C       B       A       |       A       B       C       D
 		//After swapping
-		//		D	C	B	A	|	D	C	B	A
+		//              D       C       B       A       |       D       C       B       A
 		//Return 2-bytes
 		//The return byte statrs from S. Therefore, the little-endian will return BA, the Big-endian will return DC.
 		//For returning the bottom 2 bytes, the Big-endian should shift right 2-bytes.
-		data = data >> (8*(Offset & 0x3));
+		data = data >> (8 * (Offset & 0x3));
 
 		NdisMoveMemory(pData, &data, Length);
 	}
@@ -164,16 +149,14 @@ UCHAR eFuseReadRegisters(
 
 ========================================================================
 */
-VOID eFusePhysicalReadRegisters(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT Offset,
-	IN	USHORT Length,
-	OUT	USHORT* pData)
+VOID eFusePhysicalReadRegisters(IN PRTMP_ADAPTER pAd,
+				IN USHORT Offset,
+				IN USHORT Length, OUT USHORT * pData)
 {
-	EFUSE_CTRL_STRUC		eFuseCtrlStruc;
-	int	i;
-	USHORT	efuseDataOffset;
-	UINT32	data;
+	EFUSE_CTRL_STRUC eFuseCtrlStruc;
+	int i;
+	USHORT efuseDataOffset;
+	UINT32 data;
 
 	RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
 
@@ -192,10 +175,9 @@ VOID eFusePhysicalReadRegisters(
 
 	//Step3. Polling EFSROM_KICK(0x580, bit30) until it become 0 again.
 	i = 0;
-	while(i < 500)
-	{
+	while (i < 500) {
 		RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
-		if(eFuseCtrlStruc.field.EFSROM_KICK == 0)
+		if (eFuseCtrlStruc.field.EFSROM_KICK == 0)
 			break;
 		RTMPusecDelay(2);
 		i++;
@@ -209,11 +191,11 @@ VOID eFusePhysicalReadRegisters(
 	//594:B A 9 8
 	//598:7 6 5 4
 	//59C:3 2 1 0
-	efuseDataOffset =  EFUSE_DATA3 - (Offset & 0xC)  ;
+	efuseDataOffset = EFUSE_DATA3 - (Offset & 0xC);
 
 	RTMP_IO_READ32(pAd, efuseDataOffset, &data);
 
-	data = data >> (8*(Offset & 0x3));
+	data = data >> (8 * (Offset & 0x3));
 
 	NdisMoveMemory(pData, &data, Length);
 
@@ -232,24 +214,20 @@ VOID eFusePhysicalReadRegisters(
 
 ========================================================================
 */
-static VOID eFuseReadPhysical(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUSHORT lpInBuffer,
-	IN	ULONG nInBufferSize,
-	OUT	PUSHORT lpOutBuffer,
-	IN	ULONG nOutBufferSize
-)
+static VOID eFuseReadPhysical(IN PRTMP_ADAPTER pAd,
+			      IN PUSHORT lpInBuffer,
+			      IN ULONG nInBufferSize,
+			      OUT PUSHORT lpOutBuffer, IN ULONG nOutBufferSize)
 {
-	USHORT* pInBuf = (USHORT*)lpInBuffer;
-	USHORT* pOutBuf = (USHORT*)lpOutBuffer;
+	USHORT *pInBuf = (USHORT *) lpInBuffer;
+	USHORT *pOutBuf = (USHORT *) lpOutBuffer;
+
+	USHORT Offset = pInBuf[0];	//addr
+	USHORT Length = pInBuf[1];	//length
+	int i;
 
-	USHORT Offset = pInBuf[0];					//addr
-	USHORT Length = pInBuf[1];					//length
-	int		i;
-
-	for(i=0; i<Length; i+=2)
-	{
-		eFusePhysicalReadRegisters(pAd,Offset+i, 2, &pOutBuf[i/2]);
+	for (i = 0; i < Length; i += 2) {
+		eFusePhysicalReadRegisters(pAd, Offset + i, 2, &pOutBuf[i / 2]);
 	}
 }
 
@@ -266,116 +244,100 @@ static VOID eFuseReadPhysical(
 
 ========================================================================
 */
-INT set_eFuseGetFreeBlockCount_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg)
+INT set_eFuseGetFreeBlockCount_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 {
 	USHORT i;
-	USHORT	LogicalAddress;
-	USHORT efusefreenum=0;
-	if(!pAd->bUseEfuse)
+	USHORT LogicalAddress;
+	USHORT efusefreenum = 0;
+	if (!pAd->bUseEfuse)
 		return FALSE;
-	for (i = EFUSE_USAGE_MAP_START; i <= EFUSE_USAGE_MAP_END; i+=2)
-	{
+	for (i = EFUSE_USAGE_MAP_START; i <= EFUSE_USAGE_MAP_END; i += 2) {
 		eFusePhysicalReadRegisters(pAd, i, 2, &LogicalAddress);
-		if( (LogicalAddress & 0xff) == 0)
-		{
-			efusefreenum= (UCHAR) (EFUSE_USAGE_MAP_END-i+1);
+		if ((LogicalAddress & 0xff) == 0) {
+			efusefreenum = (UCHAR) (EFUSE_USAGE_MAP_END - i + 1);
 			break;
-		}
-		else if(( (LogicalAddress >> 8) & 0xff) == 0)
-		{
-			efusefreenum = (UCHAR) (EFUSE_USAGE_MAP_END-i);
+		} else if (((LogicalAddress >> 8) & 0xff) == 0) {
+			efusefreenum = (UCHAR) (EFUSE_USAGE_MAP_END - i);
 			break;
 		}
 
-		if(i == EFUSE_USAGE_MAP_END)
+		if (i == EFUSE_USAGE_MAP_END)
 			efusefreenum = 0;
 	}
-	printk("efuseFreeNumber is %d\n",efusefreenum);
+	printk("efuseFreeNumber is %d\n", efusefreenum);
 	return TRUE;
 }
 
-
-INT set_eFusedump_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg)
+INT set_eFusedump_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 {
-USHORT InBuf[3];
-	INT i=0;
-	if(!pAd->bUseEfuse)
+	USHORT InBuf[3];
+	INT i = 0;
+	if (!pAd->bUseEfuse)
 		return FALSE;
-	for(i =0; i<EFUSE_USAGE_MAP_END/2; i++)
-	{
-		InBuf[0] = 2*i;
+	for (i = 0; i < EFUSE_USAGE_MAP_END / 2; i++) {
+		InBuf[0] = 2 * i;
 		InBuf[1] = 2;
 		InBuf[2] = 0x0;
 
 		eFuseReadPhysical(pAd, &InBuf[0], 4, &InBuf[2], 2);
-		if(i%4==0)
-		printk("\nBlock %x:",i/8);
-		printk("%04x ",InBuf[2]);
+		if (i % 4 == 0)
+			printk("\nBlock %x:", i / 8);
+		printk("%04x ", InBuf[2]);
 	}
 	return TRUE;
 }
 
-int rtmp_ee_efuse_read16(
-	IN RTMP_ADAPTER *pAd,
-	IN USHORT Offset,
-	OUT USHORT *pValue)
+int rtmp_ee_efuse_read16(IN RTMP_ADAPTER * pAd,
+			 IN USHORT Offset, OUT USHORT * pValue)
 {
 	eFuseReadRegisters(pAd, Offset, 2, pValue);
 	return (*pValue);
 }
 
-int RtmpEfuseSupportCheck(
-	IN RTMP_ADAPTER *pAd)
+int RtmpEfuseSupportCheck(IN RTMP_ADAPTER * pAd)
 {
 	USHORT value;
 
-	if (IS_RT30xx(pAd))
-	{
+	if (IS_RT30xx(pAd)) {
 		eFusePhysicalReadRegisters(pAd, EFUSE_TAG, 2, &value);
 		pAd->EFuseTag = (value & 0xff);
 	}
 	return 0;
 }
 
-VOID eFuseGetFreeBlockCount(IN PRTMP_ADAPTER pAd,
-	PUINT EfuseFreeBlock)
+VOID eFuseGetFreeBlockCount(IN PRTMP_ADAPTER pAd, PUINT EfuseFreeBlock)
 {
 	USHORT i;
-	USHORT	LogicalAddress;
-	if(!pAd->bUseEfuse)
-		{
-		DBGPRINT(RT_DEBUG_TRACE,("eFuseGetFreeBlockCount Only supports efuse Mode\n"));
-		return ;
-		}
-	for (i = EFUSE_USAGE_MAP_START; i <= EFUSE_USAGE_MAP_END; i+=2)
-	{
+	USHORT LogicalAddress;
+	if (!pAd->bUseEfuse) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("eFuseGetFreeBlockCount Only supports efuse Mode\n"));
+		return;
+	}
+	for (i = EFUSE_USAGE_MAP_START; i <= EFUSE_USAGE_MAP_END; i += 2) {
 		eFusePhysicalReadRegisters(pAd, i, 2, &LogicalAddress);
-		if( (LogicalAddress & 0xff) == 0)
-		{
-			*EfuseFreeBlock= (UCHAR) (EFUSE_USAGE_MAP_END-i+1);
+		if ((LogicalAddress & 0xff) == 0) {
+			*EfuseFreeBlock = (UCHAR) (EFUSE_USAGE_MAP_END - i + 1);
 			break;
-		}
-		else if(( (LogicalAddress >> 8) & 0xff) == 0)
-		{
-			*EfuseFreeBlock = (UCHAR) (EFUSE_USAGE_MAP_END-i);
+		} else if (((LogicalAddress >> 8) & 0xff) == 0) {
+			*EfuseFreeBlock = (UCHAR) (EFUSE_USAGE_MAP_END - i);
 			break;
 		}
 
-		if(i == EFUSE_USAGE_MAP_END)
+		if (i == EFUSE_USAGE_MAP_END)
 			*EfuseFreeBlock = 0;
 	}
-	DBGPRINT(RT_DEBUG_TRACE,("eFuseGetFreeBlockCount is 0x%x\n",*EfuseFreeBlock));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("eFuseGetFreeBlockCount is 0x%x\n", *EfuseFreeBlock));
 }
 
-INT eFuse_init(
-	IN PRTMP_ADAPTER pAd)
+INT eFuse_init(IN PRTMP_ADAPTER pAd)
 {
-	UINT	EfuseFreeBlock=0;
-	DBGPRINT(RT_DEBUG_ERROR, ("NVM is Efuse and its size =%x[%x-%x] \n",EFUSE_USAGE_MAP_SIZE,EFUSE_USAGE_MAP_START,EFUSE_USAGE_MAP_END));
+	UINT EfuseFreeBlock = 0;
+	DBGPRINT(RT_DEBUG_ERROR,
+		 ("NVM is Efuse and its size =%x[%x-%x] \n",
+		  EFUSE_USAGE_MAP_SIZE, EFUSE_USAGE_MAP_START,
+		  EFUSE_USAGE_MAP_END));
 	eFuseGetFreeBlockCount(pAd, &EfuseFreeBlock);
 
 	return 0;
--- a/drivers/staging/rt2860/common/ee_prom.c
+++ b/drivers/staging/rt2860/common/ee_prom.c
@@ -35,25 +35,18 @@
 	--------    ----------    ----------------------------------------------
 */
 
-
 #include	"../rt_config.h"
 
-
-
 // IRQL = PASSIVE_LEVEL
-static inline VOID RaiseClock(
-    IN	PRTMP_ADAPTER	pAd,
-    IN  UINT32 *x)
+static inline VOID RaiseClock(IN PRTMP_ADAPTER pAd, IN UINT32 * x)
 {
 	*x = *x | EESK;
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, *x);
-	RTMPusecDelay(1);				// Max frequency = 1MHz in Spec. definition
+	RTMPusecDelay(1);	// Max frequency = 1MHz in Spec. definition
 }
 
 // IRQL = PASSIVE_LEVEL
-static inline VOID LowerClock(
-    IN	PRTMP_ADAPTER	pAd,
-    IN  UINT32 *x)
+static inline VOID LowerClock(IN PRTMP_ADAPTER pAd, IN UINT32 * x)
 {
 	*x = *x & ~EESK;
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, *x);
@@ -61,67 +54,60 @@ static inline VOID LowerClock(
 }
 
 // IRQL = PASSIVE_LEVEL
-static inline USHORT ShiftInBits(
-	IN PRTMP_ADAPTER	pAd)
+static inline USHORT ShiftInBits(IN PRTMP_ADAPTER pAd)
 {
-	UINT32		x,i;
-	USHORT      data=0;
+	UINT32 x, i;
+	USHORT data = 0;
 
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
 
-	x &= ~( EEDO | EEDI);
+	x &= ~(EEDO | EEDI);
 
-	for(i=0; i<16; i++)
-	{
+	for (i = 0; i < 16; i++) {
 		data = data << 1;
 		RaiseClock(pAd, &x);
 
 		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-		LowerClock(pAd, &x); //prevent read failed
+		LowerClock(pAd, &x);	//prevent read failed
 
 		x &= ~(EEDI);
-		if(x & EEDO)
-		    data |= 1;
+		if (x & EEDO)
+			data |= 1;
 	}
 
 	return data;
 }
 
-
 // IRQL = PASSIVE_LEVEL
-static inline VOID ShiftOutBits(
-	IN PRTMP_ADAPTER	pAd,
-	IN USHORT			data,
-	IN USHORT			count)
+static inline VOID ShiftOutBits(IN PRTMP_ADAPTER pAd,
+				IN USHORT data, IN USHORT count)
 {
-	UINT32       x,mask;
+	UINT32 x, mask;
 
 	mask = 0x01 << (count - 1);
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
 
 	x &= ~(EEDO | EEDI);
 
-	do
-	{
-	    x &= ~EEDI;
-	    if(data & mask)		x |= EEDI;
+	do {
+		x &= ~EEDI;
+		if (data & mask)
+			x |= EEDI;
 
-	    RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
+		RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 
-	    RaiseClock(pAd, &x);
-	    LowerClock(pAd, &x);
+		RaiseClock(pAd, &x);
+		LowerClock(pAd, &x);
 
-	    mask = mask >> 1;
-	} while(mask);
+		mask = mask >> 1;
+	} while (mask);
 
 	x &= ~EEDI;
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 }
 
-
 // IRQL = PASSIVE_LEVEL
-static inline VOID EEpromCleanup(
-	IN PRTMP_ADAPTER	pAd)
+static inline VOID EEpromCleanup(IN PRTMP_ADAPTER pAd)
 {
 	UINT32 x;
 
@@ -134,11 +120,9 @@ static inline VOID EEpromCleanup(
 	LowerClock(pAd, &x);
 }
 
-
-static inline VOID EWEN(
-	IN PRTMP_ADAPTER	pAd)
+static inline VOID EWEN(IN PRTMP_ADAPTER pAd)
 {
-	UINT32	x;
+	UINT32 x;
 
 	// reset bits and set EECS
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
@@ -157,11 +141,9 @@ static inline VOID EWEN(
 	EEpromCleanup(pAd);
 }
 
-
-static inline VOID EWDS(
-	IN PRTMP_ADAPTER	pAd)
+static inline VOID EWDS(IN PRTMP_ADAPTER pAd)
 {
-	UINT32	x;
+	UINT32 x;
 
 	// reset bits and set EECS
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
@@ -180,16 +162,12 @@ static inline VOID EWDS(
 	EEpromCleanup(pAd);
 }
 
-
 // IRQL = PASSIVE_LEVEL
-int rtmp_ee_prom_read16(
-	IN PRTMP_ADAPTER	pAd,
-	IN USHORT			Offset,
-	OUT USHORT			*pValue)
+int rtmp_ee_prom_read16(IN PRTMP_ADAPTER pAd,
+			IN USHORT Offset, OUT USHORT * pValue)
 {
-	UINT32		x;
-	USHORT		data;
-
+	UINT32 x;
+	USHORT data;
 
 	Offset /= 2;
 	// reset bits and set EECS
@@ -199,13 +177,11 @@ int rtmp_ee_prom_read16(
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 
 	// patch can not access e-Fuse issue
-	if (!(IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)))
-	{
+	if (!(IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
 		// kick a pulse
 		RaiseClock(pAd, &x);
 		LowerClock(pAd, &x);
 	}
-
 	// output the read_opcode and register number in that order
 	ShiftOutBits(pAd, EEPROM_READ_OPCODE, 3);
 	ShiftOutBits(pAd, Offset, pAd->EEPROMAddressNum);
@@ -215,7 +191,6 @@ int rtmp_ee_prom_read16(
 
 	EEpromCleanup(pAd);
 
-
 	*pValue = data;
 
 	return NDIS_STATUS_SUCCESS;
--- a/drivers/staging/rt2860/common/eeprom.c
+++ b/drivers/staging/rt2860/common/eeprom.c
@@ -36,62 +36,56 @@
 */
 #include "../rt_config.h"
 
-
-INT RtmpChipOpsEepromHook(
-	IN RTMP_ADAPTER *pAd,
-	IN INT			infType)
+INT RtmpChipOpsEepromHook(IN RTMP_ADAPTER * pAd, IN INT infType)
 {
-	RTMP_CHIP_OP	*pChipOps = &pAd->chipOps;
+	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
 #ifdef RT30xx
 #ifdef RTMP_EFUSE_SUPPORT
-	UINT32			eFuseCtrl, MacCsr0;
+	UINT32 eFuseCtrl, MacCsr0;
 	int index;
 
 	index = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
 		pAd->MACVersion = MacCsr0;
 
-		if ((pAd->MACVersion != 0x00) && (pAd->MACVersion != 0xFFFFFFFF))
-				break;
+		if ((pAd->MACVersion != 0x00)
+		    && (pAd->MACVersion != 0xFFFFFFFF))
+			break;
 
 		RTMPusecDelay(10);
 	} while (index++ < 100);
 
-	pAd->bUseEfuse=FALSE;
+	pAd->bUseEfuse = FALSE;
 	RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrl);
-	pAd->bUseEfuse = ( (eFuseCtrl & 0x80000000) == 0x80000000) ? 1 : 0;
-	if(pAd->bUseEfuse)
-			{
+	pAd->bUseEfuse = ((eFuseCtrl & 0x80000000) == 0x80000000) ? 1 : 0;
+	if (pAd->bUseEfuse) {
 		pChipOps->eeinit = eFuse_init;
 		pChipOps->eeread = rtmp_ee_efuse_read16;
-		return 0 ;
-	     }
-		else
+		return 0;
+	} else
 		DBGPRINT(RT_DEBUG_TRACE, ("NVM is EEPROM\n"));
 #endif // RTMP_EFUSE_SUPPORT //
 #endif // RT30xx //
 
-	switch(infType)
-		{
+	switch (infType) {
 #ifdef RTMP_PCI_SUPPORT
-		case RTMP_DEV_INF_PCI:
-			pChipOps->eeinit = NULL;
-			pChipOps->eeread = rtmp_ee_prom_read16;
-					break;
+	case RTMP_DEV_INF_PCI:
+		pChipOps->eeinit = NULL;
+		pChipOps->eeread = rtmp_ee_prom_read16;
+		break;
 #endif // RTMP_PCI_SUPPORT //
 #ifdef RTMP_USB_SUPPORT
-		case RTMP_DEV_INF_USB:
-			pChipOps->eeinit = NULL;
-			pChipOps->eeread = RTUSBReadEEPROM16;
-					break;
+	case RTMP_DEV_INF_USB:
+		pChipOps->eeinit = NULL;
+		pChipOps->eeread = RTUSBReadEEPROM16;
+		break;
 #endif // RTMP_USB_SUPPORT //
 
-		default:
-			DBGPRINT(RT_DEBUG_ERROR, ("RtmpChipOpsEepromHook() failed!\n"));
-						break;
-					}
+	default:
+		DBGPRINT(RT_DEBUG_ERROR, ("RtmpChipOpsEepromHook() failed!\n"));
+		break;
+	}
 
 	return 0;
 }
--- a/drivers/staging/rt2860/common/mlme.c
+++ b/drivers/staging/rt2860/common/mlme.c
@@ -39,300 +39,309 @@
 #include "../rt_config.h"
 #include <stdarg.h>
 
-UCHAR	CISCO_OUI[] = {0x00, 0x40, 0x96};
+UCHAR CISCO_OUI[] = { 0x00, 0x40, 0x96 };
 
-UCHAR	WPA_OUI[] = {0x00, 0x50, 0xf2, 0x01};
-UCHAR	RSN_OUI[] = {0x00, 0x0f, 0xac};
-UCHAR   WME_INFO_ELEM[]  = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};
-UCHAR   WME_PARM_ELEM[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
-UCHAR	Ccx2QosInfo[] = {0x00, 0x40, 0x96, 0x04};
-UCHAR   RALINK_OUI[]  = {0x00, 0x0c, 0x43};
-UCHAR   BROADCOM_OUI[]  = {0x00, 0x90, 0x4c};
-UCHAR   WPS_OUI[] = {0x00, 0x50, 0xf2, 0x04};
-UCHAR	PRE_N_HT_OUI[]	= {0x00, 0x90, 0x4c};
+UCHAR WPA_OUI[] = { 0x00, 0x50, 0xf2, 0x01 };
+UCHAR RSN_OUI[] = { 0x00, 0x0f, 0xac };
+UCHAR WME_INFO_ELEM[] = { 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01 };
+UCHAR WME_PARM_ELEM[] = { 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01 };
+UCHAR Ccx2QosInfo[] = { 0x00, 0x40, 0x96, 0x04 };
+UCHAR RALINK_OUI[] = { 0x00, 0x0c, 0x43 };
+UCHAR BROADCOM_OUI[] = { 0x00, 0x90, 0x4c };
+UCHAR WPS_OUI[] = { 0x00, 0x50, 0xf2, 0x04 };
+UCHAR PRE_N_HT_OUI[] = { 0x00, 0x90, 0x4c };
 
 UCHAR RateSwitchTable[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x11, 0x00,  0,  0,  0,						// Initial used item after association
-    0x00, 0x00,  0, 40, 101,
-    0x01, 0x00,  1, 40, 50,
-    0x02, 0x00,  2, 35, 45,
-    0x03, 0x00,  3, 20, 45,
-    0x04, 0x21,  0, 30, 50,
-    0x05, 0x21,  1, 20, 50,
-    0x06, 0x21,  2, 20, 50,
-    0x07, 0x21,  3, 15, 50,
-    0x08, 0x21,  4, 15, 30,
-    0x09, 0x21,  5, 10, 25,
-    0x0a, 0x21,  6,  8, 25,
-    0x0b, 0x21,  7,  8, 25,
-    0x0c, 0x20, 12,  15, 30,
-    0x0d, 0x20, 13,  8, 20,
-    0x0e, 0x20, 14,  8, 20,
-    0x0f, 0x20, 15,  8, 25,
-    0x10, 0x22, 15,  8, 25,
-    0x11, 0x00,  0,  0,  0,
-    0x12, 0x00,  0,  0,  0,
-    0x13, 0x00,  0,  0,  0,
-    0x14, 0x00,  0,  0,  0,
-    0x15, 0x00,  0,  0,  0,
-    0x16, 0x00,  0,  0,  0,
-    0x17, 0x00,  0,  0,  0,
-    0x18, 0x00,  0,  0,  0,
-    0x19, 0x00,  0,  0,  0,
-    0x1a, 0x00,  0,  0,  0,
-    0x1b, 0x00,  0,  0,  0,
-    0x1c, 0x00,  0,  0,  0,
-    0x1d, 0x00,  0,  0,  0,
-    0x1e, 0x00,  0,  0,  0,
-    0x1f, 0x00,  0,  0,  0,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x11, 0x00, 0, 0, 0,	// Initial used item after association
+	0x00, 0x00, 0, 40, 101,
+	0x01, 0x00, 1, 40, 50,
+	0x02, 0x00, 2, 35, 45,
+	0x03, 0x00, 3, 20, 45,
+	0x04, 0x21, 0, 30, 50,
+	0x05, 0x21, 1, 20, 50,
+	0x06, 0x21, 2, 20, 50,
+	0x07, 0x21, 3, 15, 50,
+	0x08, 0x21, 4, 15, 30,
+	0x09, 0x21, 5, 10, 25,
+	0x0a, 0x21, 6, 8, 25,
+	0x0b, 0x21, 7, 8, 25,
+	0x0c, 0x20, 12, 15, 30,
+	0x0d, 0x20, 13, 8, 20,
+	0x0e, 0x20, 14, 8, 20,
+	0x0f, 0x20, 15, 8, 25,
+	0x10, 0x22, 15, 8, 25,
+	0x11, 0x00, 0, 0, 0,
+	0x12, 0x00, 0, 0, 0,
+	0x13, 0x00, 0, 0, 0,
+	0x14, 0x00, 0, 0, 0,
+	0x15, 0x00, 0, 0, 0,
+	0x16, 0x00, 0, 0, 0,
+	0x17, 0x00, 0, 0, 0,
+	0x18, 0x00, 0, 0, 0,
+	0x19, 0x00, 0, 0, 0,
+	0x1a, 0x00, 0, 0, 0,
+	0x1b, 0x00, 0, 0, 0,
+	0x1c, 0x00, 0, 0, 0,
+	0x1d, 0x00, 0, 0, 0,
+	0x1e, 0x00, 0, 0, 0,
+	0x1f, 0x00, 0, 0, 0,
 };
 
 UCHAR RateSwitchTable11B[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x04, 0x03,  0,  0,  0,						// Initial used item after association
-    0x00, 0x00,  0, 40, 101,
-    0x01, 0x00,  1, 40, 50,
-    0x02, 0x00,  2, 35, 45,
-    0x03, 0x00,  3, 20, 45,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x04, 0x03, 0, 0, 0,	// Initial used item after association
+	0x00, 0x00, 0, 40, 101,
+	0x01, 0x00, 1, 40, 50,
+	0x02, 0x00, 2, 35, 45,
+	0x03, 0x00, 3, 20, 45,
 };
 
 UCHAR RateSwitchTable11BG[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0a, 0x00,  0,  0,  0,						// Initial used item after association
-    0x00, 0x00,  0, 40, 101,
-    0x01, 0x00,  1, 40, 50,
-    0x02, 0x00,  2, 35, 45,
-    0x03, 0x00,  3, 20, 45,
-    0x04, 0x10,  2, 20, 35,
-    0x05, 0x10,  3, 16, 35,
-    0x06, 0x10,  4, 10, 25,
-    0x07, 0x10,  5, 16, 25,
-    0x08, 0x10,  6, 10, 25,
-    0x09, 0x10,  7, 10, 13,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0a, 0x00, 0, 0, 0,	// Initial used item after association
+	0x00, 0x00, 0, 40, 101,
+	0x01, 0x00, 1, 40, 50,
+	0x02, 0x00, 2, 35, 45,
+	0x03, 0x00, 3, 20, 45,
+	0x04, 0x10, 2, 20, 35,
+	0x05, 0x10, 3, 16, 35,
+	0x06, 0x10, 4, 10, 25,
+	0x07, 0x10, 5, 16, 25,
+	0x08, 0x10, 6, 10, 25,
+	0x09, 0x10, 7, 10, 13,
 };
 
 UCHAR RateSwitchTable11G[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x08, 0x00,  0,  0,  0,						// Initial used item after association
-    0x00, 0x10,  0, 20, 101,
-    0x01, 0x10,  1, 20, 35,
-    0x02, 0x10,  2, 20, 35,
-    0x03, 0x10,  3, 16, 35,
-    0x04, 0x10,  4, 10, 25,
-    0x05, 0x10,  5, 16, 25,
-    0x06, 0x10,  6, 10, 25,
-    0x07, 0x10,  7, 10, 13,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x08, 0x00, 0, 0, 0,	// Initial used item after association
+	0x00, 0x10, 0, 20, 101,
+	0x01, 0x10, 1, 20, 35,
+	0x02, 0x10, 2, 20, 35,
+	0x03, 0x10, 3, 16, 35,
+	0x04, 0x10, 4, 10, 25,
+	0x05, 0x10, 5, 16, 25,
+	0x06, 0x10, 6, 10, 25,
+	0x07, 0x10, 7, 10, 13,
 };
 
 UCHAR RateSwitchTable11N1S[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0c, 0x0a,  0,  0,  0,						// Initial used item after association
-    0x00, 0x00,  0, 40, 101,
-    0x01, 0x00,  1, 40, 50,
-    0x02, 0x00,  2, 25, 45,
-    0x03, 0x21,  0, 20, 35,
-    0x04, 0x21,  1, 20, 35,
-    0x05, 0x21,  2, 20, 35,
-    0x06, 0x21,  3, 15, 35,
-    0x07, 0x21,  4, 15, 30,
-    0x08, 0x21,  5, 10, 25,
-    0x09, 0x21,  6,  8, 14,
-    0x0a, 0x21,  7,  8, 14,
-    0x0b, 0x23,  7,  8, 14,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0c, 0x0a, 0, 0, 0,	// Initial used item after association
+	0x00, 0x00, 0, 40, 101,
+	0x01, 0x00, 1, 40, 50,
+	0x02, 0x00, 2, 25, 45,
+	0x03, 0x21, 0, 20, 35,
+	0x04, 0x21, 1, 20, 35,
+	0x05, 0x21, 2, 20, 35,
+	0x06, 0x21, 3, 15, 35,
+	0x07, 0x21, 4, 15, 30,
+	0x08, 0x21, 5, 10, 25,
+	0x09, 0x21, 6, 8, 14,
+	0x0a, 0x21, 7, 8, 14,
+	0x0b, 0x23, 7, 8, 14,
 };
 
 UCHAR RateSwitchTable11N2S[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0e, 0x0c,  0,  0,  0,						// Initial used item after association
-    0x00, 0x00,  0, 40, 101,
-    0x01, 0x00,  1, 40, 50,
-    0x02, 0x00,  2, 25, 45,
-    0x03, 0x21,  0, 20, 35,
-    0x04, 0x21,  1, 20, 35,
-    0x05, 0x21,  2, 20, 35,
-    0x06, 0x21,  3, 15, 35,
-    0x07, 0x21,  4, 15, 30,
-    0x08, 0x20, 11, 15, 30,
-    0x09, 0x20, 12, 15, 30,
-    0x0a, 0x20, 13,  8, 20,
-    0x0b, 0x20, 14,  8, 20,
-    0x0c, 0x20, 15,  8, 25,
-    0x0d, 0x22, 15,  8, 15,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0e, 0x0c, 0, 0, 0,	// Initial used item after association
+	0x00, 0x00, 0, 40, 101,
+	0x01, 0x00, 1, 40, 50,
+	0x02, 0x00, 2, 25, 45,
+	0x03, 0x21, 0, 20, 35,
+	0x04, 0x21, 1, 20, 35,
+	0x05, 0x21, 2, 20, 35,
+	0x06, 0x21, 3, 15, 35,
+	0x07, 0x21, 4, 15, 30,
+	0x08, 0x20, 11, 15, 30,
+	0x09, 0x20, 12, 15, 30,
+	0x0a, 0x20, 13, 8, 20,
+	0x0b, 0x20, 14, 8, 20,
+	0x0c, 0x20, 15, 8, 25,
+	0x0d, 0x22, 15, 8, 15,
 };
 
 UCHAR RateSwitchTable11N3S[] = {
-// Item No.	Mode	Curr-MCS	TrainUp	TrainDown	// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0b, 0x00,  0,  0,  0,	// 0x0a, 0x00,  0,  0,  0,      // Initial used item after association
-    0x00, 0x21,  0, 30, 101,
-    0x01, 0x21,  1, 20, 50,
-    0x02, 0x21,  2, 20, 50,
-    0x03, 0x21,  3, 15, 50,
-    0x04, 0x21,  4, 15, 30,
-    0x05, 0x20, 11, 15, 30,	// Required by System-Alan @ 20080812
-    0x06, 0x20, 12, 15, 30,	// 0x05, 0x20, 12, 15, 30,
-    0x07, 0x20, 13,  8, 20,	// 0x06, 0x20, 13,  8, 20,
-    0x08, 0x20, 14,  8, 20,	// 0x07, 0x20, 14,  8, 20,
-    0x09, 0x20, 15,  8, 25,	// 0x08, 0x20, 15,  8, 25,
-    0x0a, 0x22, 15,  8, 25,	// 0x09, 0x22, 15,  8, 25,
+// Item No.     Mode    Curr-MCS        TrainUp TrainDown       // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0b, 0x00, 0, 0, 0,	// 0x0a, 0x00,  0,  0,  0,      // Initial used item after association
+	0x00, 0x21, 0, 30, 101,
+	0x01, 0x21, 1, 20, 50,
+	0x02, 0x21, 2, 20, 50,
+	0x03, 0x21, 3, 15, 50,
+	0x04, 0x21, 4, 15, 30,
+	0x05, 0x20, 11, 15, 30,	// Required by System-Alan @ 20080812
+	0x06, 0x20, 12, 15, 30,	// 0x05, 0x20, 12, 15, 30,
+	0x07, 0x20, 13, 8, 20,	// 0x06, 0x20, 13,  8, 20,
+	0x08, 0x20, 14, 8, 20,	// 0x07, 0x20, 14,  8, 20,
+	0x09, 0x20, 15, 8, 25,	// 0x08, 0x20, 15,  8, 25,
+	0x0a, 0x22, 15, 8, 25,	// 0x09, 0x22, 15,  8, 25,
 };
 
 UCHAR RateSwitchTable11N2SForABand[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0b, 0x09,  0,  0,  0,						// Initial used item after association
-    0x00, 0x21,  0, 30, 101,
-    0x01, 0x21,  1, 20, 50,
-    0x02, 0x21,  2, 20, 50,
-    0x03, 0x21,  3, 15, 50,
-    0x04, 0x21,  4, 15, 30,
-    0x05, 0x21,  5, 15, 30,
-    0x06, 0x20, 12,  15, 30,
-    0x07, 0x20, 13,  8, 20,
-    0x08, 0x20, 14,  8, 20,
-    0x09, 0x20, 15,  8, 25,
-    0x0a, 0x22, 15,  8, 25,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0b, 0x09, 0, 0, 0,	// Initial used item after association
+	0x00, 0x21, 0, 30, 101,
+	0x01, 0x21, 1, 20, 50,
+	0x02, 0x21, 2, 20, 50,
+	0x03, 0x21, 3, 15, 50,
+	0x04, 0x21, 4, 15, 30,
+	0x05, 0x21, 5, 15, 30,
+	0x06, 0x20, 12, 15, 30,
+	0x07, 0x20, 13, 8, 20,
+	0x08, 0x20, 14, 8, 20,
+	0x09, 0x20, 15, 8, 25,
+	0x0a, 0x22, 15, 8, 25,
 };
 
-UCHAR RateSwitchTable11N3SForABand[] = { // 3*3
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0b, 0x09,  0,  0,  0,						// Initial used item after association
-    0x00, 0x21,  0, 30, 101,
-    0x01, 0x21,  1, 20, 50,
-    0x02, 0x21,  2, 20, 50,
-    0x03, 0x21,  3, 15, 50,
-    0x04, 0x21,  4, 15, 30,
-    0x05, 0x21,  5, 15, 30,
-    0x06, 0x20, 12,  15, 30,
-    0x07, 0x20, 13,  8, 20,
-    0x08, 0x20, 14,  8, 20,
-    0x09, 0x20, 15,  8, 25,
-    0x0a, 0x22, 15,  8, 25,
+UCHAR RateSwitchTable11N3SForABand[] = {	// 3*3
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0b, 0x09, 0, 0, 0,	// Initial used item after association
+	0x00, 0x21, 0, 30, 101,
+	0x01, 0x21, 1, 20, 50,
+	0x02, 0x21, 2, 20, 50,
+	0x03, 0x21, 3, 15, 50,
+	0x04, 0x21, 4, 15, 30,
+	0x05, 0x21, 5, 15, 30,
+	0x06, 0x20, 12, 15, 30,
+	0x07, 0x20, 13, 8, 20,
+	0x08, 0x20, 14, 8, 20,
+	0x09, 0x20, 15, 8, 25,
+	0x0a, 0x22, 15, 8, 25,
 };
 
 UCHAR RateSwitchTable11BGN1S[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0c, 0x0a,  0,  0,  0,						// Initial used item after association
-    0x00, 0x00,  0, 40, 101,
-    0x01, 0x00,  1, 40, 50,
-    0x02, 0x00,  2, 25, 45,
-    0x03, 0x21,  0, 20, 35,
-    0x04, 0x21,  1, 20, 35,
-    0x05, 0x21,  2, 20, 35,
-    0x06, 0x21,  3, 15, 35,
-    0x07, 0x21,  4, 15, 30,
-    0x08, 0x21,  5, 10, 25,
-    0x09, 0x21,  6,  8, 14,
-    0x0a, 0x21,  7,  8, 14,
-    0x0b, 0x23,  7,  8, 14,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0c, 0x0a, 0, 0, 0,	// Initial used item after association
+	0x00, 0x00, 0, 40, 101,
+	0x01, 0x00, 1, 40, 50,
+	0x02, 0x00, 2, 25, 45,
+	0x03, 0x21, 0, 20, 35,
+	0x04, 0x21, 1, 20, 35,
+	0x05, 0x21, 2, 20, 35,
+	0x06, 0x21, 3, 15, 35,
+	0x07, 0x21, 4, 15, 30,
+	0x08, 0x21, 5, 10, 25,
+	0x09, 0x21, 6, 8, 14,
+	0x0a, 0x21, 7, 8, 14,
+	0x0b, 0x23, 7, 8, 14,
 };
 
 UCHAR RateSwitchTable11BGN2S[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0e, 0x0c,  0,  0,  0,						// Initial used item after association
-    0x00, 0x00,  0, 40, 101,
-    0x01, 0x00,  1, 40, 50,
-    0x02, 0x00,  2, 25, 45,
-    0x03, 0x21,  0, 20, 35,
-    0x04, 0x21,  1, 20, 35,
-    0x05, 0x21,  2, 20, 35,
-    0x06, 0x21,  3, 15, 35,
-    0x07, 0x21,  4, 15, 30,
-    0x08, 0x20, 11, 15, 30,
-    0x09, 0x20, 12, 15, 30,
-    0x0a, 0x20, 13,  8, 20,
-    0x0b, 0x20, 14,  8, 20,
-    0x0c, 0x20, 15,  8, 25,
-    0x0d, 0x22, 15,  8, 15,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0e, 0x0c, 0, 0, 0,	// Initial used item after association
+	0x00, 0x00, 0, 40, 101,
+	0x01, 0x00, 1, 40, 50,
+	0x02, 0x00, 2, 25, 45,
+	0x03, 0x21, 0, 20, 35,
+	0x04, 0x21, 1, 20, 35,
+	0x05, 0x21, 2, 20, 35,
+	0x06, 0x21, 3, 15, 35,
+	0x07, 0x21, 4, 15, 30,
+	0x08, 0x20, 11, 15, 30,
+	0x09, 0x20, 12, 15, 30,
+	0x0a, 0x20, 13, 8, 20,
+	0x0b, 0x20, 14, 8, 20,
+	0x0c, 0x20, 15, 8, 25,
+	0x0d, 0x22, 15, 8, 15,
 };
 
-UCHAR RateSwitchTable11BGN3S[] = { // 3*3
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0a, 0x00,  0,  0,  0,						// Initial used item after association
-    0x00, 0x21,  0, 30,101,	//50
-    0x01, 0x21,  1, 20, 50,
-    0x02, 0x21,  2, 20, 50,
-    0x03, 0x21,  3, 20, 50,
-    0x04, 0x21,  4, 15, 50,
-    0x05, 0x20, 20, 15, 30,
-    0x06, 0x20, 21,  8, 20,
-    0x07, 0x20, 22,  8, 20,
-    0x08, 0x20, 23,  8, 25,
-    0x09, 0x22, 23,  8, 25,
+UCHAR RateSwitchTable11BGN3S[] = {	// 3*3
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0a, 0x00, 0, 0, 0,	// Initial used item after association
+	0x00, 0x21, 0, 30, 101,	//50
+	0x01, 0x21, 1, 20, 50,
+	0x02, 0x21, 2, 20, 50,
+	0x03, 0x21, 3, 20, 50,
+	0x04, 0x21, 4, 15, 50,
+	0x05, 0x20, 20, 15, 30,
+	0x06, 0x20, 21, 8, 20,
+	0x07, 0x20, 22, 8, 20,
+	0x08, 0x20, 23, 8, 25,
+	0x09, 0x22, 23, 8, 25,
 };
 
 UCHAR RateSwitchTable11BGN2SForABand[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0b, 0x09,  0,  0,  0,						// Initial used item after association
-    0x00, 0x21,  0, 30,101,	//50
-    0x01, 0x21,  1, 20, 50,
-    0x02, 0x21,  2, 20, 50,
-    0x03, 0x21,  3, 15, 50,
-    0x04, 0x21,  4, 15, 30,
-    0x05, 0x21,  5, 15, 30,
-    0x06, 0x20, 12, 15, 30,
-    0x07, 0x20, 13,  8, 20,
-    0x08, 0x20, 14,  8, 20,
-    0x09, 0x20, 15,  8, 25,
-    0x0a, 0x22, 15,  8, 25,
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0b, 0x09, 0, 0, 0,	// Initial used item after association
+	0x00, 0x21, 0, 30, 101,	//50
+	0x01, 0x21, 1, 20, 50,
+	0x02, 0x21, 2, 20, 50,
+	0x03, 0x21, 3, 15, 50,
+	0x04, 0x21, 4, 15, 30,
+	0x05, 0x21, 5, 15, 30,
+	0x06, 0x20, 12, 15, 30,
+	0x07, 0x20, 13, 8, 20,
+	0x08, 0x20, 14, 8, 20,
+	0x09, 0x20, 15, 8, 25,
+	0x0a, 0x22, 15, 8, 25,
 };
 
-UCHAR RateSwitchTable11BGN3SForABand[] = { // 3*3
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-    0x0c, 0x09,  0,  0,  0,						// Initial used item after association
-    0x00, 0x21,  0, 30,101,	//50
-    0x01, 0x21,  1, 20, 50,
-    0x02, 0x21,  2, 20, 50,
-    0x03, 0x21,  3, 15, 50,
-    0x04, 0x21,  4, 15, 30,
-    0x05, 0x21,  5, 15, 30,
-    0x06, 0x21, 12, 15, 30,
-    0x07, 0x20, 20, 15, 30,
-    0x08, 0x20, 21,  8, 20,
-    0x09, 0x20, 22,  8, 20,
-    0x0a, 0x20, 23,  8, 25,
-    0x0b, 0x22, 23,  8, 25,
+UCHAR RateSwitchTable11BGN3SForABand[] = {	// 3*3
+// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
+	0x0c, 0x09, 0, 0, 0,	// Initial used item after association
+	0x00, 0x21, 0, 30, 101,	//50
+	0x01, 0x21, 1, 20, 50,
+	0x02, 0x21, 2, 20, 50,
+	0x03, 0x21, 3, 15, 50,
+	0x04, 0x21, 4, 15, 30,
+	0x05, 0x21, 5, 15, 30,
+	0x06, 0x21, 12, 15, 30,
+	0x07, 0x20, 20, 15, 30,
+	0x08, 0x20, 21, 8, 20,
+	0x09, 0x20, 22, 8, 20,
+	0x0a, 0x20, 23, 8, 25,
+	0x0b, 0x22, 23, 8, 25,
 };
 
-
-extern UCHAR	 OfdmRateToRxwiMCS[];
+extern UCHAR OfdmRateToRxwiMCS[];
 // since RT61 has better RX sensibility, we have to limit TX ACK rate not to exceed our normal data TX rate.
 // otherwise the WLAN peer may not be able to receive the ACK thus downgrade its data TX rate
-ULONG BasicRateMask[12]				= {0xfffff001 /* 1-Mbps */, 0xfffff003 /* 2 Mbps */, 0xfffff007 /* 5.5 */, 0xfffff00f /* 11 */,
-									  0xfffff01f /* 6 */	 , 0xfffff03f /* 9 */	  , 0xfffff07f /* 12 */ , 0xfffff0ff /* 18 */,
-									  0xfffff1ff /* 24 */	 , 0xfffff3ff /* 36 */	  , 0xfffff7ff /* 48 */ , 0xffffffff /* 54 */};
+ULONG BasicRateMask[12] =
+    { 0xfffff001 /* 1-Mbps */ , 0xfffff003 /* 2 Mbps */ , 0xfffff007 /* 5.5 */ ,
+0xfffff00f /* 11 */ ,
+	0xfffff01f /* 6 */ , 0xfffff03f /* 9 */ , 0xfffff07f /* 12 */ ,
+	    0xfffff0ff /* 18 */ ,
+	0xfffff1ff /* 24 */ , 0xfffff3ff /* 36 */ , 0xfffff7ff /* 48 */ ,
+	    0xffffffff /* 54 */
+};
 
-UCHAR BROADCAST_ADDR[MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-UCHAR ZERO_MAC_ADDR[MAC_ADDR_LEN]  = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+UCHAR BROADCAST_ADDR[MAC_ADDR_LEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+UCHAR ZERO_MAC_ADDR[MAC_ADDR_LEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 
 // e.g. RssiSafeLevelForTxRate[RATE_36]" means if the current RSSI is greater than
-//		this value, then it's quaranteed capable of operating in 36 mbps TX rate in
-//		clean environment.
-//								  TxRate: 1   2   5.5	11	 6	  9    12	18	 24   36   48	54	 72  100
-CHAR RssiSafeLevelForTxRate[] ={  -92, -91, -90, -87, -88, -86, -85, -83, -81, -78, -72, -71, -40, -40 };
-
-UCHAR  RateIdToMbps[]	 = { 1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54, 72, 100};
-USHORT RateIdTo500Kbps[] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 144, 200};
-
-UCHAR  SsidIe	 = IE_SSID;
-UCHAR  SupRateIe = IE_SUPP_RATES;
-UCHAR  ExtRateIe = IE_EXT_SUPP_RATES;
-UCHAR  HtCapIe = IE_HT_CAP;
-UCHAR  AddHtInfoIe = IE_ADD_HT;
-UCHAR  NewExtChanIe = IE_SECONDARY_CH_OFFSET;
-UCHAR  ErpIe	 = IE_ERP;
-UCHAR  DsIe 	 = IE_DS_PARM;
-UCHAR  TimIe	 = IE_TIM;
-UCHAR  WpaIe	 = IE_WPA;
-UCHAR  Wpa2Ie	 = IE_WPA2;
-UCHAR  IbssIe	 = IE_IBSS_PARM;
-
-extern UCHAR	WPA_OUI[];
-
-UCHAR	SES_OUI[] = {0x00, 0x90, 0x4c};
-
-UCHAR	ZeroSsid[32] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
-
+//              this value, then it's quaranteed capable of operating in 36 mbps TX rate in
+//              clean environment.
+//                                                                TxRate: 1   2   5.5   11       6        9    12       18       24   36   48   54       72  100
+CHAR RssiSafeLevelForTxRate[] =
+    { -92, -91, -90, -87, -88, -86, -85, -83, -81, -78, -72, -71, -40, -40 };
+
+UCHAR RateIdToMbps[] = { 1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54, 72, 100 };
+USHORT RateIdTo500Kbps[] =
+    { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 144, 200 };
+
+UCHAR SsidIe = IE_SSID;
+UCHAR SupRateIe = IE_SUPP_RATES;
+UCHAR ExtRateIe = IE_EXT_SUPP_RATES;
+UCHAR HtCapIe = IE_HT_CAP;
+UCHAR AddHtInfoIe = IE_ADD_HT;
+UCHAR NewExtChanIe = IE_SECONDARY_CH_OFFSET;
+UCHAR ErpIe = IE_ERP;
+UCHAR DsIe = IE_DS_PARM;
+UCHAR TimIe = IE_TIM;
+UCHAR WpaIe = IE_WPA;
+UCHAR Wpa2Ie = IE_WPA2;
+UCHAR IbssIe = IE_IBSS_PARM;
+
+extern UCHAR WPA_OUI[];
+
+UCHAR SES_OUI[] = { 0x00, 0x90, 0x4c };
+
+UCHAR ZeroSsid[32] =
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	    0x00, 0x00, 0x00, 0x00
+};
 
 /*
 	==========================================================================
@@ -347,17 +356,15 @@ UCHAR	ZeroSsid[32] = {0x00,0x00,0x00,0x0
 
 	==========================================================================
 */
-NDIS_STATUS MlmeInit(
-	IN PRTMP_ADAPTER pAd)
+NDIS_STATUS MlmeInit(IN PRTMP_ADAPTER pAd)
 {
 	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> MLME Initialize\n"));
 
-	do
-	{
+	do {
 		Status = MlmeQueueInit(&pAd->Mlme.Queue);
-		if(Status != NDIS_STATUS_SUCCESS)
+		if (Status != NDIS_STATUS_SUCCESS)
 			break;
 
 		pAd->Mlme.bRunning = FALSE;
@@ -367,48 +374,60 @@ NDIS_STATUS MlmeInit(
 			BssTableInit(&pAd->ScanTab);
 
 			// init STA state machines
-			AssocStateMachineInit(pAd, &pAd->Mlme.AssocMachine, pAd->Mlme.AssocFunc);
-			AuthStateMachineInit(pAd, &pAd->Mlme.AuthMachine, pAd->Mlme.AuthFunc);
-			AuthRspStateMachineInit(pAd, &pAd->Mlme.AuthRspMachine, pAd->Mlme.AuthRspFunc);
-			SyncStateMachineInit(pAd, &pAd->Mlme.SyncMachine, pAd->Mlme.SyncFunc);
-
-
-
+			AssocStateMachineInit(pAd, &pAd->Mlme.AssocMachine,
+					      pAd->Mlme.AssocFunc);
+			AuthStateMachineInit(pAd, &pAd->Mlme.AuthMachine,
+					     pAd->Mlme.AuthFunc);
+			AuthRspStateMachineInit(pAd, &pAd->Mlme.AuthRspMachine,
+						pAd->Mlme.AuthRspFunc);
+			SyncStateMachineInit(pAd, &pAd->Mlme.SyncMachine,
+					     pAd->Mlme.SyncFunc);
 
 			// Since we are using switch/case to implement it, the init is different from the above
 			// state machine init
 			MlmeCntlInit(pAd, &pAd->Mlme.CntlMachine, NULL);
 		}
 
+		WpaStateMachineInit(pAd, &pAd->Mlme.WpaMachine,
+				    pAd->Mlme.WpaFunc);
 
-		WpaStateMachineInit(pAd, &pAd->Mlme.WpaMachine, pAd->Mlme.WpaFunc);
-
-
-		ActionStateMachineInit(pAd, &pAd->Mlme.ActMachine, pAd->Mlme.ActFunc);
+		ActionStateMachineInit(pAd, &pAd->Mlme.ActMachine,
+				       pAd->Mlme.ActFunc);
 
 		// Init mlme periodic timer
-		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer, GET_TIMER_FUNCTION(MlmePeriodicExec), pAd, TRUE);
+		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer,
+			      GET_TIMER_FUNCTION(MlmePeriodicExec), pAd, TRUE);
 
 		// Set mlme periodic timer
 		RTMPSetTimer(&pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
 
 		// software-based RX Antenna diversity
-		RTMPInitTimer(pAd, &pAd->Mlme.RxAntEvalTimer, GET_TIMER_FUNCTION(AsicRxAntEvalTimeout), pAd, FALSE);
+		RTMPInitTimer(pAd, &pAd->Mlme.RxAntEvalTimer,
+			      GET_TIMER_FUNCTION(AsicRxAntEvalTimeout), pAd,
+			      FALSE);
 
 		{
 #ifdef RTMP_PCI_SUPPORT
-	        if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-	        {
-	            // only PCIe cards need these two timers
-	    		RTMPInitTimer(pAd, &pAd->Mlme.PsPollTimer, GET_TIMER_FUNCTION(PsPollWakeExec), pAd, FALSE);
-	    		RTMPInitTimer(pAd, &pAd->Mlme.RadioOnOffTimer, GET_TIMER_FUNCTION(RadioOnExec), pAd, FALSE);
-	        }
+			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
+				// only PCIe cards need these two timers
+				RTMPInitTimer(pAd, &pAd->Mlme.PsPollTimer,
+					      GET_TIMER_FUNCTION
+					      (PsPollWakeExec), pAd, FALSE);
+				RTMPInitTimer(pAd, &pAd->Mlme.RadioOnOffTimer,
+					      GET_TIMER_FUNCTION(RadioOnExec),
+					      pAd, FALSE);
+			}
 #endif // RTMP_PCI_SUPPORT //
 
-			RTMPInitTimer(pAd, &pAd->Mlme.LinkDownTimer, GET_TIMER_FUNCTION(LinkDownExec), pAd, FALSE);
+			RTMPInitTimer(pAd, &pAd->Mlme.LinkDownTimer,
+				      GET_TIMER_FUNCTION(LinkDownExec), pAd,
+				      FALSE);
 
 #ifdef RTMP_MAC_USB
-			RTMPInitTimer(pAd, &pAd->Mlme.AutoWakeupTimer, GET_TIMER_FUNCTION(RtmpUsbStaAsicForceWakeupTimeout), pAd, FALSE);
+			RTMPInitTimer(pAd, &pAd->Mlme.AutoWakeupTimer,
+				      GET_TIMER_FUNCTION
+				      (RtmpUsbStaAsicForceWakeupTimeout), pAd,
+				      FALSE);
 			pAd->Mlme.AutoWakeupTimerRunning = FALSE;
 #endif // RTMP_MAC_USB //
 		}
@@ -434,43 +453,37 @@ NDIS_STATUS MlmeInit(
 
 	==========================================================================
  */
-VOID MlmeHandler(
-	IN PRTMP_ADAPTER pAd)
+VOID MlmeHandler(IN PRTMP_ADAPTER pAd)
 {
-	MLME_QUEUE_ELEM 	   *Elem = NULL;
+	MLME_QUEUE_ELEM *Elem = NULL;
 
 	// Only accept MLME and Frame from peer side, no other (control/data) frame should
 	// get into this state machine
 
 	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
-	if(pAd->Mlme.bRunning)
-	{
+	if (pAd->Mlme.bRunning) {
 		NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
 		return;
-	}
-	else
-	{
+	} else {
 		pAd->Mlme.bRunning = TRUE;
 	}
 	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
 
-	while (!MlmeQueueEmpty(&pAd->Mlme.Queue))
-	{
+	while (!MlmeQueueEmpty(&pAd->Mlme.Queue)) {
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS) ||
-			RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS) ||
-			RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("Device Halted or Removed or MlmeRest, exit MlmeHandler! (queue num = %ld)\n", pAd->Mlme.Queue.Num));
+		    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS) ||
+		    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Device Halted or Removed or MlmeRest, exit MlmeHandler! (queue num = %ld)\n",
+				  pAd->Mlme.Queue.Num));
 			break;
 		}
-
 		//From message type, determine which state machine I should drive
-		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem))
-		{
+		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
 #ifdef RTMP_MAC_USB
-			if (Elem->MsgType == MT2_RESET_CONF)
-			{
-				DBGPRINT_RAW(RT_DEBUG_TRACE, ("!!! reset MLME state machine !!!\n"));
+			if (Elem->MsgType == MT2_RESET_CONF) {
+				DBGPRINT_RAW(RT_DEBUG_TRACE,
+					     ("!!! reset MLME state machine !!!\n"));
 				MlmeRestartStateMachine(pAd);
 				Elem->Occupied = FALSE;
 				Elem->MsgLen = 0;
@@ -479,50 +492,63 @@ VOID MlmeHandler(
 #endif // RTMP_MAC_USB //
 
 			// if dequeue success
-			switch (Elem->Machine)
-			{
+			switch (Elem->Machine) {
 				// STA state machines
-				case ASSOC_STATE_MACHINE:
-					StateMachinePerformAction(pAd, &pAd->Mlme.AssocMachine, Elem);
-					break;
-				case AUTH_STATE_MACHINE:
-					StateMachinePerformAction(pAd, &pAd->Mlme.AuthMachine, Elem);
-					break;
-				case AUTH_RSP_STATE_MACHINE:
-					StateMachinePerformAction(pAd, &pAd->Mlme.AuthRspMachine, Elem);
-					break;
-				case SYNC_STATE_MACHINE:
-					StateMachinePerformAction(pAd, &pAd->Mlme.SyncMachine, Elem);
-					break;
-				case MLME_CNTL_STATE_MACHINE:
-					MlmeCntlMachinePerformAction(pAd, &pAd->Mlme.CntlMachine, Elem);
-					break;
-				case WPA_PSK_STATE_MACHINE:
-					StateMachinePerformAction(pAd, &pAd->Mlme.WpaPskMachine, Elem);
-					break;
-
-
-
-				case ACTION_STATE_MACHINE:
-					StateMachinePerformAction(pAd, &pAd->Mlme.ActMachine, Elem);
-					break;
+			case ASSOC_STATE_MACHINE:
+				StateMachinePerformAction(pAd,
+							  &pAd->Mlme.
+							  AssocMachine, Elem);
+				break;
+			case AUTH_STATE_MACHINE:
+				StateMachinePerformAction(pAd,
+							  &pAd->Mlme.
+							  AuthMachine, Elem);
+				break;
+			case AUTH_RSP_STATE_MACHINE:
+				StateMachinePerformAction(pAd,
+							  &pAd->Mlme.
+							  AuthRspMachine, Elem);
+				break;
+			case SYNC_STATE_MACHINE:
+				StateMachinePerformAction(pAd,
+							  &pAd->Mlme.
+							  SyncMachine, Elem);
+				break;
+			case MLME_CNTL_STATE_MACHINE:
+				MlmeCntlMachinePerformAction(pAd,
+							     &pAd->Mlme.
+							     CntlMachine, Elem);
+				break;
+			case WPA_PSK_STATE_MACHINE:
+				StateMachinePerformAction(pAd,
+							  &pAd->Mlme.
+							  WpaPskMachine, Elem);
+				break;
 
-				case WPA_STATE_MACHINE:
-					StateMachinePerformAction(pAd, &pAd->Mlme.WpaMachine, Elem);
-					break;
+			case ACTION_STATE_MACHINE:
+				StateMachinePerformAction(pAd,
+							  &pAd->Mlme.ActMachine,
+							  Elem);
+				break;
 
+			case WPA_STATE_MACHINE:
+				StateMachinePerformAction(pAd,
+							  &pAd->Mlme.WpaMachine,
+							  Elem);
+				break;
 
-				default:
-					DBGPRINT(RT_DEBUG_TRACE, ("ERROR: Illegal machine %ld in MlmeHandler()\n", Elem->Machine));
-					break;
-			} // end of switch
+			default:
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("ERROR: Illegal machine %ld in MlmeHandler()\n",
+					  Elem->Machine));
+				break;
+			}	// end of switch
 
 			// free MLME element
 			Elem->Occupied = FALSE;
 			Elem->MsgLen = 0;
 
-		}
-		else {
+		} else {
 			DBGPRINT_ERR(("MlmeHandler: MlmeQueue empty\n"));
 		}
 	}
@@ -545,74 +571,67 @@ VOID MlmeHandler(
 
 	==========================================================================
  */
-VOID MlmeHalt(
-	IN PRTMP_ADAPTER pAd)
+VOID MlmeHalt(IN PRTMP_ADAPTER pAd)
 {
-	BOOLEAN 	  Cancelled;
+	BOOLEAN Cancelled;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeHalt\n"));
 
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
-	{
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
 		// disable BEACON generation and other BEACON related hardware timers
 		AsicDisableSync(pAd);
 	}
 
 	{
 		// Cancel pending timers
-		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,		&Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,		&Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,	&Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,		&Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,		&Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,		&Cancelled);
-
+		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
 
 #ifdef RTMP_MAC_PCI
-	    if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
-			&&(pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-	    {
-	   	    RTMPCancelTimer(&pAd->Mlme.PsPollTimer,		&Cancelled);
-		    RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer,		&Cancelled);
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
+		    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
+			RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
+			RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer, &Cancelled);
 		}
 #endif // RTMP_MAC_PCI //
 
-		RTMPCancelTimer(&pAd->Mlme.LinkDownTimer,		&Cancelled);
+		RTMPCancelTimer(&pAd->Mlme.LinkDownTimer, &Cancelled);
 
 #ifdef RTMP_MAC_USB
 		RTMPCancelTimer(&pAd->Mlme.AutoWakeupTimer, &Cancelled);
 #endif // RTMP_MAC_USB //
 	}
 
-	RTMPCancelTimer(&pAd->Mlme.PeriodicTimer,		&Cancelled);
-	RTMPCancelTimer(&pAd->Mlme.RxAntEvalTimer,		&Cancelled);
-
-
+	RTMPCancelTimer(&pAd->Mlme.PeriodicTimer, &Cancelled);
+	RTMPCancelTimer(&pAd->Mlme.RxAntEvalTimer, &Cancelled);
 
-	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
-	{
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
 		RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
 
 		// Set LED
 		RTMPSetLED(pAd, LED_HALT);
-        RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, firmware is not done it.
+		RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, firmware is not done it.
 #ifdef RTMP_MAC_USB
-        {
-            LED_CFG_STRUC LedCfg;
-            RTMP_IO_READ32(pAd, LED_CFG, &LedCfg.word);
-            LedCfg.field.LedPolar = 0;
-            LedCfg.field.RLedMode = 0;
-            LedCfg.field.GLedMode = 0;
-            LedCfg.field.YLedMode = 0;
-            RTMP_IO_WRITE32(pAd, LED_CFG, LedCfg.word);
-        }
+		{
+			LED_CFG_STRUC LedCfg;
+			RTMP_IO_READ32(pAd, LED_CFG, &LedCfg.word);
+			LedCfg.field.LedPolar = 0;
+			LedCfg.field.RLedMode = 0;
+			LedCfg.field.GLedMode = 0;
+			LedCfg.field.YLedMode = 0;
+			RTMP_IO_WRITE32(pAd, LED_CFG, LedCfg.word);
+		}
 #endif // RTMP_MAC_USB //
 
 		if (pChipOps->AsicHaltAction)
 			pChipOps->AsicHaltAction(pAd);
 	}
 
-	RTMPusecDelay(5000);    //  5 msec to gurantee Ant Diversity timer canceled
+	RTMPusecDelay(5000);	//  5 msec to gurantee Ant Diversity timer canceled
 
 	MlmeQueueDestroy(&pAd->Mlme.Queue);
 	NdisFreeSpinLock(&pAd->Mlme.TaskLock);
@@ -620,10 +639,10 @@ VOID MlmeHalt(
 	DBGPRINT(RT_DEBUG_TRACE, ("<== MlmeHalt\n"));
 }
 
-VOID MlmeResetRalinkCounters(
-	IN  PRTMP_ADAPTER   pAd)
+VOID MlmeResetRalinkCounters(IN PRTMP_ADAPTER pAd)
 {
-	pAd->RalinkCounters.LastOneSecRxOkDataCnt = pAd->RalinkCounters.OneSecRxOkDataCnt;
+	pAd->RalinkCounters.LastOneSecRxOkDataCnt =
+	    pAd->RalinkCounters.OneSecRxOkDataCnt;
 	// clear all OneSecxxx counters.
 	pAd->RalinkCounters.OneSecBeaconSentCnt = 0;
 	pAd->RalinkCounters.OneSecFalseCCACnt = 0;
@@ -653,7 +672,6 @@ VOID MlmeResetRalinkCounters(
 	return;
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -670,26 +688,25 @@ VOID MlmeResetRalinkCounters(
 
 	==========================================================================
  */
-#define ADHOC_BEACON_LOST_TIME		(8*OS_HZ)  // 8 sec
-VOID MlmePeriodicExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+#define ADHOC_BEACON_LOST_TIME		(8*OS_HZ)	// 8 sec
+VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
+		      IN PVOID FunctionContext,
+		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	ULONG			TxTotalCnt;
-	PRTMP_ADAPTER	pAd = (RTMP_ADAPTER *)FunctionContext;
+	ULONG TxTotalCnt;
+	PRTMP_ADAPTER pAd = (RTMP_ADAPTER *) FunctionContext;
 
 #ifdef RTMP_MAC_PCI
 	{
-	    // If Hardware controlled Radio enabled, we have to check GPIO pin2 every 2 second.
+		// If Hardware controlled Radio enabled, we have to check GPIO pin2 every 2 second.
 		// Move code to here, because following code will return when radio is off
-		if ((pAd->Mlme.PeriodicRound % (MLME_TASK_EXEC_MULTIPLE * 2) == 0) && (pAd->StaCfg.bHardwareRadio == TRUE) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
-			/*&&(pAd->bPCIclkOff == FALSE)*/)
-		{
-			UINT32				data = 0;
+		if ((pAd->Mlme.PeriodicRound % (MLME_TASK_EXEC_MULTIPLE * 2) ==
+		     0) && (pAd->StaCfg.bHardwareRadio == TRUE)
+		    && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
+		    && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		    /*&&(pAd->bPCIclkOff == FALSE) */
+		    ) {
+			UINT32 data = 0;
 
 			// Read GPIO pin2 as Hardware controlled radio state
 #ifndef RT3090
@@ -699,39 +716,34 @@ VOID MlmePeriodicExec(
 #ifdef RT3090
 // Read GPIO pin2 as Hardware controlled radio state
 // We need to Read GPIO if HW said so no mater what advance power saving
-if ((pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd))
-	&& (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))
-	&& (pAd->StaCfg.PSControl.field.EnablePSinIdle == TRUE))
-	{
-	// Want to make sure device goes to L0 state before reading register.
-	RTMPPCIeLinkCtrlValueRestore(pAd, 0);
-	RTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);
-	RTMPPCIeLinkCtrlSetting(pAd, 3);
-	}
-else
-	RTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);
+			if ((pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd))
+			    &&
+			    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))
+			    && (pAd->StaCfg.PSControl.field.EnablePSinIdle ==
+				TRUE)) {
+				// Want to make sure device goes to L0 state before reading register.
+				RTMPPCIeLinkCtrlValueRestore(pAd, 0);
+				RTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);
+				RTMPPCIeLinkCtrlSetting(pAd, 3);
+			} else
+				RTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);
 #endif // RT3090 //
 //KH(PCIE PS):Added based on Jane-->
 
-			if (data & 0x04)
-			{
+			if (data & 0x04) {
 				pAd->StaCfg.bHwRadio = TRUE;
-			}
-			else
-			{
+			} else {
 				pAd->StaCfg.bHwRadio = FALSE;
 			}
-			if (pAd->StaCfg.bRadio != (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio))
-			{
-				pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio);
-				if (pAd->StaCfg.bRadio == TRUE)
-				{
+			if (pAd->StaCfg.bRadio !=
+			    (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio)) {
+				pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio
+						      && pAd->StaCfg.bSwRadio);
+				if (pAd->StaCfg.bRadio == TRUE) {
 					MlmeRadioOn(pAd);
 					// Update extra information
 					pAd->ExtraInfo = EXTRA_INFO_CLEAR;
-				}
-				else
-				{
+				} else {
 					MlmeRadioOff(pAd);
 					// Update extra information
 					pAd->ExtraInfo = HW_RADIO_OFF;
@@ -744,9 +756,9 @@ else
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_HALT_IN_PROGRESS |
-								fRTMP_ADAPTER_RADIO_OFF |
-								fRTMP_ADAPTER_RADIO_MEASUREMENT |
-								fRTMP_ADAPTER_RESET_IN_PROGRESS))))
+				  fRTMP_ADAPTER_RADIO_OFF |
+				  fRTMP_ADAPTER_RADIO_MEASUREMENT |
+				  fRTMP_ADAPTER_RESET_IN_PROGRESS))))
 		return;
 
 	RTMP_MLME_PRE_SANITY_CHECK(pAd);
@@ -756,30 +768,26 @@ else
 		if (MONITOR_ON(pAd))
 			return;
 
-		if (pAd->Mlme.PeriodicRound & 0x1)
-		{
+		if (pAd->Mlme.PeriodicRound & 0x1) {
 			// This is the fix for wifi 11n extension channel overlapping test case.  for 2860D
 			if (((pAd->MACVersion & 0xffff) == 0x0101) &&
-				(STA_TGN_WIFI_ON(pAd)) &&
-				(pAd->CommonCfg.IOTestParm.bToggle == FALSE))
-
-				{
-					RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x24Bf);
-					pAd->CommonCfg.IOTestParm.bToggle = TRUE;
-				}
-				else if ((STA_TGN_WIFI_ON(pAd)) &&
-						((pAd->MACVersion & 0xffff) == 0x0101))
-				{
-					RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x243f);
-					pAd->CommonCfg.IOTestParm.bToggle = FALSE;
-				}
+			    (STA_TGN_WIFI_ON(pAd)) &&
+			    (pAd->CommonCfg.IOTestParm.bToggle == FALSE))
+			{
+				RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x24Bf);
+				pAd->CommonCfg.IOTestParm.bToggle = TRUE;
+			} else if ((STA_TGN_WIFI_ON(pAd)) &&
+				   ((pAd->MACVersion & 0xffff) == 0x0101)) {
+				RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x243f);
+				pAd->CommonCfg.IOTestParm.bToggle = FALSE;
+			}
 		}
 	}
 
 	pAd->bUpdateBcnCntDone = FALSE;
 
-//	RECBATimerTimeout(SystemSpecific1,FunctionContext,SystemSpecific2,SystemSpecific3);
-	pAd->Mlme.PeriodicRound ++;
+//      RECBATimerTimeout(SystemSpecific1,FunctionContext,SystemSpecific2,SystemSpecific3);
+	pAd->Mlme.PeriodicRound++;
 
 #ifdef RTMP_MAC_USB
 	// execute every 100ms, update the Tx FIFO Cnt for update Tx Rate.
@@ -787,40 +795,37 @@ else
 #endif // RTMP_MAC_USB //
 
 	// execute every 500ms
-	if ((pAd->Mlme.PeriodicRound % 5 == 0) && RTMPAutoRateSwitchCheck(pAd)/*(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))*/)
+	if ((pAd->Mlme.PeriodicRound % 5 == 0)
+	    && RTMPAutoRateSwitchCheck(pAd)
+	    /*(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */ )
 	{
 		// perform dynamic tx rate switching based on past TX history
 		{
-			if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-					)
-				&& (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)))
+			if ((OPSTATUS_TEST_FLAG
+			     (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
+			    )
+			    && (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)))
 				MlmeDynamicTxRateSwitching(pAd);
 		}
 	}
-
 	// Normal 1 second Mlme PeriodicExec.
-	if (pAd->Mlme.PeriodicRound %MLME_TASK_EXEC_MULTIPLE == 0)
-	{
-                pAd->Mlme.OneSecPeriodicRound ++;
-
-
-
+	if (pAd->Mlme.PeriodicRound % MLME_TASK_EXEC_MULTIPLE == 0) {
+		pAd->Mlme.OneSecPeriodicRound++;
 
 		//ORIBATimerTimeout(pAd);
 
 		// Media status changed, report to NDIS
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE))
-		{
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE)) {
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);
-			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-			{
-				pAd->IndicateMediaState = NdisMediaStateConnected;
+			if (OPSTATUS_TEST_FLAG
+			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
+				pAd->IndicateMediaState =
+				    NdisMediaStateConnected;
 				RTMP_IndicateMediaState(pAd);
 
-			}
-			else
-			{
-				pAd->IndicateMediaState = NdisMediaStateDisconnected;
+			} else {
+				pAd->IndicateMediaState =
+				    NdisMediaStateDisconnected;
 				RTMP_IndicateMediaState(pAd);
 			}
 		}
@@ -835,42 +840,39 @@ else
 		RTUSBWatchDog(pAd);
 #endif // RTMP_MAC_USB //
 
-   		// Need statistics after read counter. So put after NICUpdateRawCounters
+		// Need statistics after read counter. So put after NICUpdateRawCounters
 		ORIBATimerTimeout(pAd);
 
 		// if MGMT RING is full more than twice within 1 second, we consider there's
 		// a hardware problem stucking the TX path. In this case, try a hardware reset
 		// to recover the system
-	//	if (pAd->RalinkCounters.MgmtRingFullCount >= 2)
-	//		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HARDWARE_ERROR);
-	//	else
-	//		pAd->RalinkCounters.MgmtRingFullCount = 0;
+		//      if (pAd->RalinkCounters.MgmtRingFullCount >= 2)
+		//              RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HARDWARE_ERROR);
+		//      else
+		//              pAd->RalinkCounters.MgmtRingFullCount = 0;
 
 		// The time period for checking antenna is according to traffic
 		{
-		if (pAd->Mlme.bEnableAutoAntennaCheck)
-		{
-			TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-							 pAd->RalinkCounters.OneSecTxRetryOkCount +
-							 pAd->RalinkCounters.OneSecTxFailCount;
-
-			// dynamic adjust antenna evaluation period according to the traffic
-			if (TxTotalCnt > 50)
-			{
-				if (pAd->Mlme.OneSecPeriodicRound % 10 == 0)
-				{
-					AsicEvaluateRxAnt(pAd);
-				}
-			}
-			else
-			{
-				if (pAd->Mlme.OneSecPeriodicRound % 3 == 0)
-				{
-					AsicEvaluateRxAnt(pAd);
+			if (pAd->Mlme.bEnableAutoAntennaCheck) {
+				TxTotalCnt =
+				    pAd->RalinkCounters.OneSecTxNoRetryOkCount +
+				    pAd->RalinkCounters.OneSecTxRetryOkCount +
+				    pAd->RalinkCounters.OneSecTxFailCount;
+
+				// dynamic adjust antenna evaluation period according to the traffic
+				if (TxTotalCnt > 50) {
+					if (pAd->Mlme.OneSecPeriodicRound %
+					    10 == 0) {
+						AsicEvaluateRxAnt(pAd);
+					}
+				} else {
+					if (pAd->Mlme.OneSecPeriodicRound % 3 ==
+					    0) {
+						AsicEvaluateRxAnt(pAd);
+					}
 				}
 			}
 		}
-		}
 
 		STAMlmePeriodicExec(pAd);
 
@@ -878,7 +880,8 @@ else
 
 		{
 #ifdef RTMP_MAC_PCI
-			if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) && (pAd->bPCIclkOff == FALSE))
+			if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)
+			    && (pAd->bPCIclkOff == FALSE))
 #endif // RTMP_MAC_PCI //
 			{
 				// When Adhoc beacon is enabled and RTS/CTS is enabled, there is a chance that hardware MAC FSM will run into a deadlock
@@ -888,16 +891,18 @@ else
 				// 2. If in 0x10F4 the ((bit29==1) && (bit7==1)) OR ((bit29==1) && (bit5==1)), it means the deadlock has occurred.
 				// 3. If the deadlock occurred, reset MAC/BBP by setting 0x1004 to 0x0001 for a while then setting it back to 0x000C again.
 
-				UINT32	MacReg = 0;
+				UINT32 MacReg = 0;
 
 				RTMP_IO_READ32(pAd, 0x10F4, &MacReg);
-				if (((MacReg & 0x20000000) && (MacReg & 0x80)) || ((MacReg & 0x20000000) && (MacReg & 0x20)))
-				{
+				if (((MacReg & 0x20000000) && (MacReg & 0x80))
+				    || ((MacReg & 0x20000000)
+					&& (MacReg & 0x20))) {
 					RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x1);
 					RTMPusecDelay(1);
 					RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0xC);
 
-					DBGPRINT(RT_DEBUG_WARN,("Warning, MAC specific condition occurs \n"));
+					DBGPRINT(RT_DEBUG_WARN,
+						 ("Warning, MAC specific condition occurs \n"));
 				}
 			}
 		}
@@ -905,11 +910,9 @@ else
 		RTMP_MLME_HANDLER(pAd);
 	}
 
-
 	pAd->bUpdateBcnCntDone = FALSE;
 }
 
-
 /*
 	==========================================================================
 	Validate SSID for connection try and rescan purpose
@@ -918,94 +921,72 @@ else
 	IRQL = DISPATCH_LEVEL
 	==========================================================================
  */
-BOOLEAN MlmeValidateSSID(
-	IN PUCHAR	pSsid,
-	IN UCHAR	SsidLen)
+BOOLEAN MlmeValidateSSID(IN PUCHAR pSsid, IN UCHAR SsidLen)
 {
-	int	index;
+	int index;
 
 	if (SsidLen > MAX_LEN_OF_SSID)
 		return (FALSE);
 
 	// Check each character value
-	for (index = 0; index < SsidLen; index++)
-    {
+	for (index = 0; index < SsidLen; index++) {
 		if (pSsid[index] < 0x20)
 			return (FALSE);
-    }
+	}
 
 	// All checked
 	return (TRUE);
 }
 
-VOID MlmeSelectTxRateTable(
-	IN PRTMP_ADAPTER		pAd,
-	IN PMAC_TABLE_ENTRY		pEntry,
-	IN PUCHAR				*ppTable,
-	IN PUCHAR				pTableSize,
-	IN PUCHAR				pInitTxRateIdx)
+VOID MlmeSelectTxRateTable(IN PRTMP_ADAPTER pAd,
+			   IN PMAC_TABLE_ENTRY pEntry,
+			   IN PUCHAR * ppTable,
+			   IN PUCHAR pTableSize, IN PUCHAR pInitTxRateIdx)
 {
-	do
-	{
+	do {
 		// decide the rate table for tuning
-		if (pAd->CommonCfg.TxRateTableSize > 0)
-	{
+		if (pAd->CommonCfg.TxRateTableSize > 0) {
 			*ppTable = RateSwitchTable;
 			*pTableSize = RateSwitchTable[0];
 			*pInitTxRateIdx = RateSwitchTable[1];
 
 			break;
-	}
+		}
 
-		if ((pAd->OpMode == OPMODE_STA) && ADHOC_ON(pAd))
-	{
-			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) &&
-				(pEntry->HTCapability.MCSSet[0] == 0xff) &&
-				((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
-			{// 11N 1S Adhoc
+		if ((pAd->OpMode == OPMODE_STA) && ADHOC_ON(pAd)) {
+			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1))) {	// 11N 1S Adhoc
 				*ppTable = RateSwitchTable11N1S;
 				*pTableSize = RateSwitchTable11N1S[0];
 				*pInitTxRateIdx = RateSwitchTable11N1S[1];
 
-			}
-			else if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) &&
-					(pEntry->HTCapability.MCSSet[0] == 0xff) &&
-					(pEntry->HTCapability.MCSSet[1] == 0xff) &&
-					(pAd->Antenna.field.TxPath == 2))
-			{// 11N 2S Adhoc
-				if (pAd->LatchRfRegs.Channel <= 14)
-		{
+			} else if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2)) {	// 11N 2S Adhoc
+				if (pAd->LatchRfRegs.Channel <= 14) {
 					*ppTable = RateSwitchTable11N2S;
 					*pTableSize = RateSwitchTable11N2S[0];
-					*pInitTxRateIdx = RateSwitchTable11N2S[1];
-		}
-				else
-				{
+					*pInitTxRateIdx =
+					    RateSwitchTable11N2S[1];
+				} else {
 					*ppTable = RateSwitchTable11N2SForABand;
-					*pTableSize = RateSwitchTable11N2SForABand[0];
-					*pInitTxRateIdx = RateSwitchTable11N2SForABand[1];
-	}
+					*pTableSize =
+					    RateSwitchTable11N2SForABand[0];
+					*pInitTxRateIdx =
+					    RateSwitchTable11N2SForABand[1];
+				}
 
-	}
-			else
-				if ((pEntry->RateLen == 4)
-					&& (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)
-					)
-			{
+			} else if ((pEntry->RateLen == 4)
+				   && (pEntry->HTCapability.MCSSet[0] == 0)
+				   && (pEntry->HTCapability.MCSSet[1] == 0)
+			    ) {
 				*ppTable = RateSwitchTable11B;
 				*pTableSize = RateSwitchTable11B[0];
 				*pInitTxRateIdx = RateSwitchTable11B[1];
 
-			}
-			else if (pAd->LatchRfRegs.Channel <= 14)
-			{
+			} else if (pAd->LatchRfRegs.Channel <= 14) {
 				*ppTable = RateSwitchTable11BG;
 				*pTableSize = RateSwitchTable11BG[0];
 				*pInitTxRateIdx = RateSwitchTable11BG[1];
 
-			}
-			else
-			{
+			} else {
 				*ppTable = RateSwitchTable11G;
 				*pTableSize = RateSwitchTable11G[0];
 				*pInitTxRateIdx = RateSwitchTable11G[1];
@@ -1013,99 +994,82 @@ VOID MlmeSelectTxRateTable(
 			}
 			break;
 		}
-
 		//if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
-		//	((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
-		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) &&
-			((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1)))
-		{// 11BGN 1S AP
+		//      ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
+		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1))) {	// 11BGN 1S AP
 			*ppTable = RateSwitchTable11BGN1S;
 			*pTableSize = RateSwitchTable11BGN1S[0];
 			*pInitTxRateIdx = RateSwitchTable11BGN1S[1];
 
 			break;
-	}
-
+		}
 		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
-		//	(pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
-		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) &&
-			(pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2))
-		{// 11BGN 2S AP
-			if (pAd->LatchRfRegs.Channel <= 14)
-	{
+		//      (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
+		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2)) {	// 11BGN 2S AP
+			if (pAd->LatchRfRegs.Channel <= 14) {
 				*ppTable = RateSwitchTable11BGN2S;
 				*pTableSize = RateSwitchTable11BGN2S[0];
 				*pInitTxRateIdx = RateSwitchTable11BGN2S[1];
 
-			}
-			else
-			{
+			} else {
 				*ppTable = RateSwitchTable11BGN2SForABand;
 				*pTableSize = RateSwitchTable11BGN2SForABand[0];
-				*pInitTxRateIdx = RateSwitchTable11BGN2SForABand[1];
+				*pInitTxRateIdx =
+				    RateSwitchTable11BGN2SForABand[1];
 
 			}
 			break;
 		}
-
 		//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
-		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1)))
-		{// 11N 1S AP
+		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1))) {	// 11N 1S AP
 			*ppTable = RateSwitchTable11N1S;
 			*pTableSize = RateSwitchTable11N1S[0];
 			*pInitTxRateIdx = RateSwitchTable11N1S[1];
 
 			break;
 		}
-
 		//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
-		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2))
-		{// 11N 2S AP
-			if (pAd->LatchRfRegs.Channel <= 14)
-			{
-			*ppTable = RateSwitchTable11N2S;
-			*pTableSize = RateSwitchTable11N2S[0];
-			*pInitTxRateIdx = RateSwitchTable11N2S[1];
-			}
-			else
-			{
+		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2)) {	// 11N 2S AP
+			if (pAd->LatchRfRegs.Channel <= 14) {
+				*ppTable = RateSwitchTable11N2S;
+				*pTableSize = RateSwitchTable11N2S[0];
+				*pInitTxRateIdx = RateSwitchTable11N2S[1];
+			} else {
 				*ppTable = RateSwitchTable11N2SForABand;
 				*pTableSize = RateSwitchTable11N2SForABand[0];
-				*pInitTxRateIdx = RateSwitchTable11N2SForABand[1];
+				*pInitTxRateIdx =
+				    RateSwitchTable11N2SForABand[1];
 			}
 
 			break;
 		}
 		//else if ((pAd->StaActive.SupRateLen == 4) && (pAd->StaActive.ExtRateLen == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
-		if ((pEntry->RateLen == 4 || pAd->CommonCfg.PhyMode==PHY_11B)
-		//Iverson mark for Adhoc b mode,sta will use rate 54  Mbps when connect with sta b/g/n mode
-		/* && (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)*/
-			)
-		{// B only AP
+		if ((pEntry->RateLen == 4 || pAd->CommonCfg.PhyMode == PHY_11B)
+		    //Iverson mark for Adhoc b mode,sta will use rate 54  Mbps when connect with sta b/g/n mode
+		    /* && (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0) */
+		    ) {		// B only AP
 			*ppTable = RateSwitchTable11B;
 			*pTableSize = RateSwitchTable11B[0];
 			*pInitTxRateIdx = RateSwitchTable11B[1];
 
 			break;
 		}
-
 		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen > 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
 		if ((pEntry->RateLen > 8)
-			&& (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)
-			)
-		{// B/G  mixed AP
+		    && (pEntry->HTCapability.MCSSet[0] == 0)
+		    && (pEntry->HTCapability.MCSSet[1] == 0)
+		    ) {		// B/G  mixed AP
 			*ppTable = RateSwitchTable11BG;
 			*pTableSize = RateSwitchTable11BG[0];
 			*pInitTxRateIdx = RateSwitchTable11BG[1];
 
 			break;
 		}
-
 		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
 		if ((pEntry->RateLen == 8)
-			&& (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)
-			)
-		{// G only AP
+		    && (pEntry->HTCapability.MCSSet[0] == 0)
+		    && (pEntry->HTCapability.MCSSet[1] == 0)
+		    ) {		// G only AP
 			*ppTable = RateSwitchTable11G;
 			*pTableSize = RateSwitchTable11G[0];
 			*pInitTxRateIdx = RateSwitchTable11G[1];
@@ -1115,356 +1079,390 @@ VOID MlmeSelectTxRateTable(
 
 		{
 			//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
-			if ((pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0))
-			{	// Legacy mode
-				if (pAd->CommonCfg.MaxTxRate <= RATE_11)
-				{
+			if ((pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)) {	// Legacy mode
+				if (pAd->CommonCfg.MaxTxRate <= RATE_11) {
 					*ppTable = RateSwitchTable11B;
 					*pTableSize = RateSwitchTable11B[0];
 					*pInitTxRateIdx = RateSwitchTable11B[1];
-				}
-				else if ((pAd->CommonCfg.MaxTxRate > RATE_11) && (pAd->CommonCfg.MinTxRate > RATE_11))
-				{
+				} else if ((pAd->CommonCfg.MaxTxRate > RATE_11)
+					   && (pAd->CommonCfg.MinTxRate >
+					       RATE_11)) {
 					*ppTable = RateSwitchTable11G;
 					*pTableSize = RateSwitchTable11G[0];
 					*pInitTxRateIdx = RateSwitchTable11G[1];
 
-				}
-				else
-				{
+				} else {
 					*ppTable = RateSwitchTable11BG;
 					*pTableSize = RateSwitchTable11BG[0];
-					*pInitTxRateIdx = RateSwitchTable11BG[1];
+					*pInitTxRateIdx =
+					    RateSwitchTable11BG[1];
 				}
 				break;
 			}
-			if (pAd->LatchRfRegs.Channel <= 14)
-			{
-				if (pAd->CommonCfg.TxStream == 1)
-				{
+			if (pAd->LatchRfRegs.Channel <= 14) {
+				if (pAd->CommonCfg.TxStream == 1) {
 					*ppTable = RateSwitchTable11N1S;
 					*pTableSize = RateSwitchTable11N1S[0];
-					*pInitTxRateIdx = RateSwitchTable11N1S[1];
-					DBGPRINT_RAW(RT_DEBUG_ERROR,("DRS: unkown mode,default use 11N 1S AP \n"));
-				}
-				else
-				{
+					*pInitTxRateIdx =
+					    RateSwitchTable11N1S[1];
+					DBGPRINT_RAW(RT_DEBUG_ERROR,
+						     ("DRS: unkown mode,default use 11N 1S AP \n"));
+				} else {
 					*ppTable = RateSwitchTable11N2S;
 					*pTableSize = RateSwitchTable11N2S[0];
-					*pInitTxRateIdx = RateSwitchTable11N2S[1];
-					DBGPRINT_RAW(RT_DEBUG_ERROR,("DRS: unkown mode,default use 11N 2S AP \n"));
+					*pInitTxRateIdx =
+					    RateSwitchTable11N2S[1];
+					DBGPRINT_RAW(RT_DEBUG_ERROR,
+						     ("DRS: unkown mode,default use 11N 2S AP \n"));
 				}
-			}
-			else
-			{
-				if (pAd->CommonCfg.TxStream == 1)
-				{
+			} else {
+				if (pAd->CommonCfg.TxStream == 1) {
 					*ppTable = RateSwitchTable11N1S;
 					*pTableSize = RateSwitchTable11N1S[0];
-					*pInitTxRateIdx = RateSwitchTable11N1S[1];
-					DBGPRINT_RAW(RT_DEBUG_ERROR,("DRS: unkown mode,default use 11N 1S AP \n"));
-				}
-				else
-				{
+					*pInitTxRateIdx =
+					    RateSwitchTable11N1S[1];
+					DBGPRINT_RAW(RT_DEBUG_ERROR,
+						     ("DRS: unkown mode,default use 11N 1S AP \n"));
+				} else {
 					*ppTable = RateSwitchTable11N2SForABand;
-					*pTableSize = RateSwitchTable11N2SForABand[0];
-					*pInitTxRateIdx = RateSwitchTable11N2SForABand[1];
-					DBGPRINT_RAW(RT_DEBUG_ERROR,("DRS: unkown mode,default use 11N 2S AP \n"));
+					*pTableSize =
+					    RateSwitchTable11N2SForABand[0];
+					*pInitTxRateIdx =
+					    RateSwitchTable11N2SForABand[1];
+					DBGPRINT_RAW(RT_DEBUG_ERROR,
+						     ("DRS: unkown mode,default use 11N 2S AP \n"));
 				}
 			}
-			DBGPRINT_RAW(RT_DEBUG_ERROR,("DRS: unkown mode (SupRateLen=%d, ExtRateLen=%d, MCSSet[0]=0x%x, MCSSet[1]=0x%x)\n",
-				pAd->StaActive.SupRateLen, pAd->StaActive.ExtRateLen, pAd->StaActive.SupportedPhyInfo.MCSSet[0], pAd->StaActive.SupportedPhyInfo.MCSSet[1]));
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("DRS: unkown mode (SupRateLen=%d, ExtRateLen=%d, MCSSet[0]=0x%x, MCSSet[1]=0x%x)\n",
+				      pAd->StaActive.SupRateLen,
+				      pAd->StaActive.ExtRateLen,
+				      pAd->StaActive.SupportedPhyInfo.MCSSet[0],
+				      pAd->StaActive.SupportedPhyInfo.
+				      MCSSet[1]));
 		}
-	} while(FALSE);
+	} while (FALSE);
 }
 
-
-VOID STAMlmePeriodicExec(
-	PRTMP_ADAPTER pAd)
+VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 {
-	ULONG			    TxTotalCnt;
-	int	i;
+	ULONG TxTotalCnt;
+	int i;
 
 	/*
-		We return here in ATE mode, because the statistics
-		that ATE need are not collected via this routine.
-	*/
+	   We return here in ATE mode, because the statistics
+	   that ATE need are not collected via this routine.
+	 */
 #if defined(RT305x)||defined(RT3070)
 	// request by Gary, if Rssi0 > -42, BBP 82 need to be changed from 0x62 to 0x42, , bbp 67 need to be changed from 0x20 to 0x18
-	if (!pAd->CommonCfg.HighPowerPatchDisabled)
-	{
+	if (!pAd->CommonCfg.HighPowerPatchDisabled) {
 #ifdef RT3070
-		 if ( (IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201)))
+		if ((IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201)))
 #endif // RT3070 //
-                {
-				if ((pAd->StaCfg.RssiSample.AvgRssi0 != 0) && (pAd->StaCfg.RssiSample.AvgRssi0 > (pAd->BbpRssiToDbmDelta - 35)))
-				{
-					 RT30xxWriteRFRegister(pAd, RF_R27, 0x20);
-				 }
-				else
-				{
-					RT30xxWriteRFRegister(pAd, RF_R27, 0x23);
-				}
-		 }
+		{
+			if ((pAd->StaCfg.RssiSample.AvgRssi0 != 0)
+			    && (pAd->StaCfg.RssiSample.AvgRssi0 >
+				(pAd->BbpRssiToDbmDelta - 35))) {
+				RT30xxWriteRFRegister(pAd, RF_R27, 0x20);
+			} else {
+				RT30xxWriteRFRegister(pAd, RF_R27, 0x23);
+			}
+		}
 	}
 #endif
 #ifdef PCIE_PS_SUPPORT
 // don't perform idle-power-save mechanism within 3 min after driver initialization.
 // This can make rebooter test more robust
-if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-	{
-	if ((pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd))
-		&& (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
-		&& (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
-		&& (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)))
-		{
-		if (IS_RT3090(pAd)|| IS_RT3572(pAd) || IS_RT3390(pAd))
-			{
-			if (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-	{
-				DBGPRINT(RT_DEBUG_TRACE, ("%s\n", __func__));
-				RT28xxPciAsicRadioOff(pAd, GUI_IDLE_POWER_SAVE, 0);
-				}
-			else
-				{
-				AsicSendCommandToMcu(pAd, 0x30, PowerSafeCID, 0xff, 0x2);
-				// Wait command success
-				AsicCheckCommanOk(pAd, PowerSafeCID);
-				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
-				DBGPRINT(RT_DEBUG_TRACE, ("PSM - rt30xx Issue Sleep command)\n"));
-				}
-			}
-		else if (pAd->Mlme.OneSecPeriodicRound > 180)
-                {
-			if (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-				{
-				DBGPRINT(RT_DEBUG_TRACE, ("%s\n", __func__));
-				RT28xxPciAsicRadioOff(pAd, GUI_IDLE_POWER_SAVE, 0);
-				 }
-				else
-				{
-				AsicSendCommandToMcu(pAd, 0x30, PowerSafeCID, 0xff, 0x02);
-				// Wait command success
-				AsicCheckCommanOk(pAd, PowerSafeCID);
-				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
-				DBGPRINT(RT_DEBUG_TRACE, ("PSM -  rt28xx Issue Sleep command)\n"));
-				}
-		 }
-	}
-	else
-		{
-		DBGPRINT(RT_DEBUG_TRACE,("STAMlmePeriodicExec MMCHK - CommonCfg.Ssid[%d]=%c%c%c%c... MlmeAux.Ssid[%d]=%c%c%c%c...\n",
-			pAd->CommonCfg.SsidLen, pAd->CommonCfg.Ssid[0], pAd->CommonCfg.Ssid[1], pAd->CommonCfg.Ssid[2], pAd->CommonCfg.Ssid[3],
-			pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid[0], pAd->MlmeAux.Ssid[1], pAd->MlmeAux.Ssid[2], pAd->MlmeAux.Ssid[3]));
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
+		if ((pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd))
+		    && (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
+		    && (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+		    && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))) {
+			if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
+				if (pAd->StaCfg.PSControl.field.EnableNewPS ==
+				    TRUE) {
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("%s\n", __func__));
+					RT28xxPciAsicRadioOff(pAd,
+							      GUI_IDLE_POWER_SAVE,
+							      0);
+				} else {
+					AsicSendCommandToMcu(pAd, 0x30,
+							     PowerSafeCID, 0xff,
+							     0x2);
+					// Wait command success
+					AsicCheckCommanOk(pAd, PowerSafeCID);
+					RTMP_SET_FLAG(pAd,
+						      fRTMP_ADAPTER_IDLE_RADIO_OFF);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("PSM - rt30xx Issue Sleep command)\n"));
+				}
+			} else if (pAd->Mlme.OneSecPeriodicRound > 180) {
+				if (pAd->StaCfg.PSControl.field.EnableNewPS ==
+				    TRUE) {
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("%s\n", __func__));
+					RT28xxPciAsicRadioOff(pAd,
+							      GUI_IDLE_POWER_SAVE,
+							      0);
+				} else {
+					AsicSendCommandToMcu(pAd, 0x30,
+							     PowerSafeCID, 0xff,
+							     0x02);
+					// Wait command success
+					AsicCheckCommanOk(pAd, PowerSafeCID);
+					RTMP_SET_FLAG(pAd,
+						      fRTMP_ADAPTER_IDLE_RADIO_OFF);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("PSM -  rt28xx Issue Sleep command)\n"));
+				}
+			}
+		} else {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("STAMlmePeriodicExec MMCHK - CommonCfg.Ssid[%d]=%c%c%c%c... MlmeAux.Ssid[%d]=%c%c%c%c...\n",
+				  pAd->CommonCfg.SsidLen,
+				  pAd->CommonCfg.Ssid[0],
+				  pAd->CommonCfg.Ssid[1],
+				  pAd->CommonCfg.Ssid[2],
+				  pAd->CommonCfg.Ssid[3], pAd->MlmeAux.SsidLen,
+				  pAd->MlmeAux.Ssid[0], pAd->MlmeAux.Ssid[1],
+				  pAd->MlmeAux.Ssid[2], pAd->MlmeAux.Ssid[3]));
 		}
 	}
 #endif // PCIE_PS_SUPPORT //
 
-    if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)
-    {
-	// WPA MIC error should block association attempt for 60 seconds
+	if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE) {
+		// WPA MIC error should block association attempt for 60 seconds
 		if (pAd->StaCfg.bBlockAssoc &&
-			RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastMicErrorTime + (60*OS_HZ)))
-		pAd->StaCfg.bBlockAssoc = FALSE;
-    }
+		    RTMP_TIME_AFTER(pAd->Mlme.Now32,
+				    pAd->StaCfg.LastMicErrorTime +
+				    (60 * OS_HZ)))
+			pAd->StaCfg.bBlockAssoc = FALSE;
+	}
 
-    if ((pAd->PreMediaState != pAd->IndicateMediaState) && (pAd->CommonCfg.bWirelessEvent))
-	{
-		if (pAd->IndicateMediaState == NdisMediaStateConnected)
-		{
-			RTMPSendWirelessEvent(pAd, IW_STA_LINKUP_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+	if ((pAd->PreMediaState != pAd->IndicateMediaState)
+	    && (pAd->CommonCfg.bWirelessEvent)) {
+		if (pAd->IndicateMediaState == NdisMediaStateConnected) {
+			RTMPSendWirelessEvent(pAd, IW_STA_LINKUP_EVENT_FLAG,
+					      pAd->MacTab.Content[BSSID_WCID].
+					      Addr, BSS0, 0);
 		}
 		pAd->PreMediaState = pAd->IndicateMediaState;
 	}
 
-
-
-
-	if (pAd->CommonCfg.PSPXlink && ADHOC_ON(pAd))
-	{
-	}
-	else
-	{
-	AsicStaBbpTuning(pAd);
+	if (pAd->CommonCfg.PSPXlink && ADHOC_ON(pAd)) {
+	} else {
+		AsicStaBbpTuning(pAd);
 	}
 
 	TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-					 pAd->RalinkCounters.OneSecTxRetryOkCount +
-					 pAd->RalinkCounters.OneSecTxFailCount;
+	    pAd->RalinkCounters.OneSecTxRetryOkCount +
+	    pAd->RalinkCounters.OneSecTxFailCount;
 
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-	{
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
 		// update channel quality for Roaming and UI LinkQuality display
 		MlmeCalculateChannelQuality(pAd, NULL, pAd->Mlme.Now32);
 	}
-
 	// must be AFTER MlmeDynamicTxRateSwitching() because it needs to know if
 	// Radio is currently in noisy environment
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-	AsicAdjustTxPower(pAd);
+		AsicAdjustTxPower(pAd);
 
-	if (INFRA_ON(pAd))
-	{
+	if (INFRA_ON(pAd)) {
 
 		// Is PSM bit consistent with user power management policy?
 		// This is the only place that will set PSM bit ON.
 		if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-		MlmeCheckPsmChange(pAd, pAd->Mlme.Now32);
+			MlmeCheckPsmChange(pAd, pAd->Mlme.Now32);
 
 		pAd->RalinkCounters.LastOneSecTotalTxCount = TxTotalCnt;
 
-		if ((RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastBeaconRxTime + (1*OS_HZ))) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) &&
-			(((TxTotalCnt + pAd->RalinkCounters.OneSecRxOkCnt) < 600)))
-		{
+		if ((RTMP_TIME_AFTER
+		     (pAd->Mlme.Now32,
+		      pAd->StaCfg.LastBeaconRxTime + (1 * OS_HZ)))
+		    &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		    &&
+		    (((TxTotalCnt + pAd->RalinkCounters.OneSecRxOkCnt) <
+		      600))) {
 			RTMPSetAGCInitValue(pAd, BW_20);
-			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - No BEACON. restore R66 to the low bound(%d) \n", (0x2E + GET_LNA_GAIN(pAd))));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MMCHK - No BEACON. restore R66 to the low bound(%d) \n",
+				  (0x2E + GET_LNA_GAIN(pAd))));
+		}
+		//if ((pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
+		//    (pAd->RalinkCounters.OneSecTxRetryOkCount == 0))
+		{
+			if (pAd->CommonCfg.bAPSDCapable
+			    && pAd->CommonCfg.APEdcaParm.bAPSDCapable) {
+				// When APSD is enabled, the period changes as 20 sec
+				if ((pAd->Mlme.OneSecPeriodicRound % 20) == 8)
+					RTMPSendNullFrame(pAd,
+							  pAd->CommonCfg.TxRate,
+							  TRUE);
+			} else {
+				// Send out a NULL frame every 10 sec to inform AP that STA is still alive (Avoid being age out)
+				if ((pAd->Mlme.OneSecPeriodicRound % 10) == 8) {
+					if (pAd->CommonCfg.bWmmCapable)
+						RTMPSendNullFrame(pAd,
+								  pAd->
+								  CommonCfg.
+								  TxRate, TRUE);
+					else
+						RTMPSendNullFrame(pAd,
+								  pAd->
+								  CommonCfg.
+								  TxRate,
+								  FALSE);
+				}
+			}
 		}
 
-        //if ((pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
-        //    (pAd->RalinkCounters.OneSecTxRetryOkCount == 0))
-        {
-    		if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable)
-    		{
-    		    // When APSD is enabled, the period changes as 20 sec
-    			if ((pAd->Mlme.OneSecPeriodicRound % 20) == 8)
-    				RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
-    		}
-    		else
-    		{
-    		    // Send out a NULL frame every 10 sec to inform AP that STA is still alive (Avoid being age out)
-    			if ((pAd->Mlme.OneSecPeriodicRound % 10) == 8)
-                {
-                    if (pAd->CommonCfg.bWmmCapable)
-    					RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
-                    else
-						RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, FALSE);
-                }
-    		}
-        }
-
-		if (CQI_IS_DEAD(pAd->Mlme.ChannelQuality))
-			{
-			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - No BEACON. Dead CQI. Auto Recovery attempt #%ld\n", pAd->RalinkCounters.BadCQIAutoRecoveryCount));
+		if (CQI_IS_DEAD(pAd->Mlme.ChannelQuality)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MMCHK - No BEACON. Dead CQI. Auto Recovery attempt #%ld\n",
+				  pAd->RalinkCounters.BadCQIAutoRecoveryCount));
 
 			// Lost AP, send disconnect & link down event
 			LinkDown(pAd, FALSE);
 
-
-		RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL, 0);
+			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL,
+						0);
 
 			// RTMPPatchMacBbpBug(pAd);
 			MlmeAutoReconnectLastSSID(pAd);
-		}
-		else if (CQI_IS_BAD(pAd->Mlme.ChannelQuality))
-		{
-			pAd->RalinkCounters.BadCQIAutoRecoveryCount ++;
-			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Bad CQI. Auto Recovery attempt #%ld\n", pAd->RalinkCounters.BadCQIAutoRecoveryCount));
+		} else if (CQI_IS_BAD(pAd->Mlme.ChannelQuality)) {
+			pAd->RalinkCounters.BadCQIAutoRecoveryCount++;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MMCHK - Bad CQI. Auto Recovery attempt #%ld\n",
+				  pAd->RalinkCounters.BadCQIAutoRecoveryCount));
 			MlmeAutoReconnectLastSSID(pAd);
 		}
 
-		if (pAd->StaCfg.bAutoRoaming)
-		{
-			BOOLEAN	rv = FALSE;
-			CHAR	dBmToRoam = pAd->StaCfg.dBmToRoam;
-			CHAR	MaxRssi = RTMPMaxRssi(pAd,
-										  pAd->StaCfg.RssiSample.LastRssi0,
-										  pAd->StaCfg.RssiSample.LastRssi1,
-										  pAd->StaCfg.RssiSample.LastRssi2);
+		if (pAd->StaCfg.bAutoRoaming) {
+			BOOLEAN rv = FALSE;
+			CHAR dBmToRoam = pAd->StaCfg.dBmToRoam;
+			CHAR MaxRssi = RTMPMaxRssi(pAd,
+						   pAd->StaCfg.RssiSample.
+						   LastRssi0,
+						   pAd->StaCfg.RssiSample.
+						   LastRssi1,
+						   pAd->StaCfg.RssiSample.
+						   LastRssi2);
 
 			// Scanning, ignore Roaming
-			if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS) &&
-				(pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE) &&
-				(MaxRssi <= dBmToRoam))
-	{
-				DBGPRINT(RT_DEBUG_TRACE, ("Rssi=%d, dBmToRoam=%d\n", MaxRssi, (CHAR)dBmToRoam));
-
+			if (!RTMP_TEST_FLAG
+			    (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)
+			    && (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
+			    && (MaxRssi <= dBmToRoam)) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("Rssi=%d, dBmToRoam=%d\n", MaxRssi,
+					  (CHAR) dBmToRoam));
 
 				// Add auto seamless roaming
 				if (rv == FALSE)
 					rv = MlmeCheckForFastRoaming(pAd);
 
-				if (rv == FALSE)
-		{
-					if ((pAd->StaCfg.LastScanTime + 10 * OS_HZ) < pAd->Mlme.Now32)
-			{
-						DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Roaming, No eligable entry, try new scan!\n"));
+				if (rv == FALSE) {
+					if ((pAd->StaCfg.LastScanTime +
+					     10 * OS_HZ) < pAd->Mlme.Now32) {
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("MMCHK - Roaming, No eligable entry, try new scan!\n"));
 						pAd->StaCfg.ScanCnt = 2;
-						pAd->StaCfg.LastScanTime = pAd->Mlme.Now32;
+						pAd->StaCfg.LastScanTime =
+						    pAd->Mlme.Now32;
 						MlmeAutoScan(pAd);
-			}
+					}
+				}
 			}
 		}
-		}
-	}
-	else if (ADHOC_ON(pAd))
-	{
+	} else if (ADHOC_ON(pAd)) {
 		// If all peers leave, and this STA becomes the last one in this IBSS, then change MediaState
 		// to DISCONNECTED. But still holding this IBSS (i.e. sending BEACON) so that other STAs can
 		// join later.
-		if (RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastBeaconRxTime + ADHOC_BEACON_LOST_TIME) &&
-			OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-		{
-			MLME_START_REQ_STRUCT     StartReq;
+		if (RTMP_TIME_AFTER
+		    (pAd->Mlme.Now32,
+		     pAd->StaCfg.LastBeaconRxTime + ADHOC_BEACON_LOST_TIME)
+		    && OPSTATUS_TEST_FLAG(pAd,
+					  fOP_STATUS_MEDIA_STATE_CONNECTED)) {
+			MLME_START_REQ_STRUCT StartReq;
 
-			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - excessive BEACON lost, last STA in this IBSS, MediaState=Disconnected\n"));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MMCHK - excessive BEACON lost, last STA in this IBSS, MediaState=Disconnected\n"));
 			LinkDown(pAd, FALSE);
 
-			StartParmFill(pAd, &StartReq, (CHAR *)pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
-			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ, sizeof(MLME_START_REQ_STRUCT), &StartReq);
+			StartParmFill(pAd, &StartReq,
+				      (CHAR *) pAd->MlmeAux.Ssid,
+				      pAd->MlmeAux.SsidLen);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ,
+				    sizeof(MLME_START_REQ_STRUCT), &StartReq);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
 		}
 
-		for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++)
-		{
+		for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
 			MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[i];
 
 			if (pEntry->ValidAsCLI == FALSE)
 				continue;
 
-			if (RTMP_TIME_AFTER(pAd->Mlme.Now32, pEntry->LastBeaconRxTime + ADHOC_BEACON_LOST_TIME))
-				MacTableDeleteEntry(pAd, pEntry->Aid, pEntry->Addr);
+			if (RTMP_TIME_AFTER
+			    (pAd->Mlme.Now32,
+			     pEntry->LastBeaconRxTime + ADHOC_BEACON_LOST_TIME))
+				MacTableDeleteEntry(pAd, pEntry->Aid,
+						    pEntry->Addr);
 		}
-	}
-	else // no INFRA nor ADHOC connection
+	} else			// no INFRA nor ADHOC connection
 	{
 
 		if (pAd->StaCfg.bScanReqIsFromWebUI &&
-			RTMP_TIME_BEFORE(pAd->Mlme.Now32, pAd->StaCfg.LastScanTime + (30 * OS_HZ)))
+		    RTMP_TIME_BEFORE(pAd->Mlme.Now32,
+				     pAd->StaCfg.LastScanTime + (30 * OS_HZ)))
 			goto SKIP_AUTO_SCAN_CONN;
-        else
-            pAd->StaCfg.bScanReqIsFromWebUI = FALSE;
+		else
+			pAd->StaCfg.bScanReqIsFromWebUI = FALSE;
 
 		if ((pAd->StaCfg.bAutoReconnect == TRUE)
-			&& RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)
-			&& (MlmeValidateSSID(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen) == TRUE))
-		{
-			if ((pAd->ScanTab.BssNr==0) && (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE))
-			{
-				MLME_SCAN_REQ_STRUCT	   ScanReq;
-
-				if (RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastScanTime + (10 * OS_HZ)))
-				{
-					DBGPRINT(RT_DEBUG_TRACE, ("STAMlmePeriodicExec():CNTL - ScanTab.BssNr==0, start a new ACTIVE scan SSID[%s]\n", pAd->MlmeAux.AutoReconnectSsid));
-					ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen, BSS_ANY, SCAN_ACTIVE);
-					MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ, sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
-					pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+		    && RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)
+		    &&
+		    (MlmeValidateSSID
+		     (pAd->MlmeAux.AutoReconnectSsid,
+		      pAd->MlmeAux.AutoReconnectSsidLen) == TRUE)) {
+			if ((pAd->ScanTab.BssNr == 0)
+			    && (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)) {
+				MLME_SCAN_REQ_STRUCT ScanReq;
+
+				if (RTMP_TIME_AFTER
+				    (pAd->Mlme.Now32,
+				     pAd->StaCfg.LastScanTime + (10 * OS_HZ))) {
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("STAMlmePeriodicExec():CNTL - ScanTab.BssNr==0, start a new ACTIVE scan SSID[%s]\n",
+						  pAd->MlmeAux.
+						  AutoReconnectSsid));
+					ScanParmFill(pAd, &ScanReq,
+						     (PSTRING) pAd->MlmeAux.
+						     AutoReconnectSsid,
+						     pAd->MlmeAux.
+						     AutoReconnectSsidLen,
+						     BSS_ANY, SCAN_ACTIVE);
+					MlmeEnqueue(pAd, SYNC_STATE_MACHINE,
+						    MT2_MLME_SCAN_REQ,
+						    sizeof
+						    (MLME_SCAN_REQ_STRUCT),
+						    &ScanReq);
+					pAd->Mlme.CntlMachine.CurrState =
+					    CNTL_WAIT_OID_LIST_SCAN;
 					// Reset Missed scan number
-					pAd->StaCfg.LastScanTime = pAd->Mlme.Now32;
-				}
-				else if (pAd->StaCfg.BssType == BSS_ADHOC)	// Quit the forever scan when in a very clean room
+					pAd->StaCfg.LastScanTime =
+					    pAd->Mlme.Now32;
+				} else if (pAd->StaCfg.BssType == BSS_ADHOC)	// Quit the forever scan when in a very clean room
 					MlmeAutoReconnectLastSSID(pAd);
-			}
-			else if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
-			{
-				if ((pAd->Mlme.OneSecPeriodicRound % 7) == 0)
-				{
+			} else if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
+				if ((pAd->Mlme.OneSecPeriodicRound % 7) == 0) {
 					MlmeAutoScan(pAd);
-					pAd->StaCfg.LastScanTime = pAd->Mlme.Now32;
-				}
-				else
-				{
-						MlmeAutoReconnectLastSSID(pAd);
+					pAd->StaCfg.LastScanTime =
+					    pAd->Mlme.Now32;
+				} else {
+					MlmeAutoReconnectLastSSID(pAd);
 				}
 			}
 		}
@@ -1472,86 +1470,81 @@ if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_P
 
 SKIP_AUTO_SCAN_CONN:
 
-    if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap !=0) && (pAd->MacTab.fAnyBASession == FALSE))
-	{
+	if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap != 0)
+	    && (pAd->MacTab.fAnyBASession == FALSE)) {
 		pAd->MacTab.fAnyBASession = TRUE;
-		AsicUpdateProtect(pAd, HT_FORCERTSCTS,  ALLN_SETPROTECT, FALSE, FALSE);
-	}
-	else if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap ==0) && (pAd->MacTab.fAnyBASession == TRUE))
-	{
+		AsicUpdateProtect(pAd, HT_FORCERTSCTS, ALLN_SETPROTECT, FALSE,
+				  FALSE);
+	} else if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap == 0)
+		   && (pAd->MacTab.fAnyBASession == TRUE)) {
 		pAd->MacTab.fAnyBASession = FALSE;
-		AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode,  ALLN_SETPROTECT, FALSE, FALSE);
+		AsicUpdateProtect(pAd,
+				  pAd->MlmeAux.AddHtInfo.AddHtInfo2.
+				  OperaionMode, ALLN_SETPROTECT, FALSE, FALSE);
 	}
 
 	return;
 }
 
 // Link down report
-VOID LinkDownExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+VOID LinkDownExec(IN PVOID SystemSpecific1,
+		  IN PVOID FunctionContext,
+		  IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
-	if (pAd != NULL)
-	{
-		MLME_DISASSOC_REQ_STRUCT   DisassocReq;
+	if (pAd != NULL) {
+		MLME_DISASSOC_REQ_STRUCT DisassocReq;
 
 		if ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) &&
-			(INFRA_ON(pAd)))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("LinkDownExec(): disassociate with current AP...\n"));
-			DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
-						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+		    (INFRA_ON(pAd))) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("LinkDownExec(): disassociate with current AP...\n"));
+			DisassocParmFill(pAd, &DisassocReq,
+					 pAd->CommonCfg.Bssid,
+					 REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
+				    MT2_MLME_DISASSOC_REQ,
+				    sizeof(MLME_DISASSOC_REQ_STRUCT),
+				    &DisassocReq);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
 
-	pAd->IndicateMediaState = NdisMediaStateDisconnected;
-	RTMP_IndicateMediaState(pAd);
-    pAd->ExtraInfo = GENERAL_LINK_DOWN;
+			pAd->IndicateMediaState = NdisMediaStateDisconnected;
+			RTMP_IndicateMediaState(pAd);
+			pAd->ExtraInfo = GENERAL_LINK_DOWN;
 		}
 	}
 }
 
 // IRQL = DISPATCH_LEVEL
-VOID MlmeAutoScan(
-	IN PRTMP_ADAPTER pAd)
+VOID MlmeAutoScan(IN PRTMP_ADAPTER pAd)
 {
 	// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
-	if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
-	{
+	if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
 		DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Driver auto scan\n"));
 		MlmeEnqueue(pAd,
-					MLME_CNTL_STATE_MACHINE,
-					OID_802_11_BSSID_LIST_SCAN,
-					pAd->MlmeAux.AutoReconnectSsidLen,
-					pAd->MlmeAux.AutoReconnectSsid);
+			    MLME_CNTL_STATE_MACHINE,
+			    OID_802_11_BSSID_LIST_SCAN,
+			    pAd->MlmeAux.AutoReconnectSsidLen,
+			    pAd->MlmeAux.AutoReconnectSsid);
 		RTMP_MLME_HANDLER(pAd);
 	}
 }
 
 // IRQL = DISPATCH_LEVEL
-VOID MlmeAutoReconnectLastSSID(
-	IN PRTMP_ADAPTER pAd)
+VOID MlmeAutoReconnectLastSSID(IN PRTMP_ADAPTER pAd)
 {
-	if (pAd->StaCfg.bAutoConnectByBssid)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("Driver auto reconnect to last OID_802_11_BSSID setting - %02X:%02X:%02X:%02X:%02X:%02X\n",
-									pAd->MlmeAux.Bssid[0],
-									pAd->MlmeAux.Bssid[1],
-									pAd->MlmeAux.Bssid[2],
-									pAd->MlmeAux.Bssid[3],
-									pAd->MlmeAux.Bssid[4],
-									pAd->MlmeAux.Bssid[5]));
+	if (pAd->StaCfg.bAutoConnectByBssid) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Driver auto reconnect to last OID_802_11_BSSID setting - %02X:%02X:%02X:%02X:%02X:%02X\n",
+			  pAd->MlmeAux.Bssid[0], pAd->MlmeAux.Bssid[1],
+			  pAd->MlmeAux.Bssid[2], pAd->MlmeAux.Bssid[3],
+			  pAd->MlmeAux.Bssid[4], pAd->MlmeAux.Bssid[5]));
 
 		pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
 		MlmeEnqueue(pAd,
-			 MLME_CNTL_STATE_MACHINE,
-			 OID_802_11_BSSID,
-			 MAC_ADDR_LEN,
-			 pAd->MlmeAux.Bssid);
+			    MLME_CNTL_STATE_MACHINE,
+			    OID_802_11_BSSID, MAC_ADDR_LEN, pAd->MlmeAux.Bssid);
 
 		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 
@@ -1559,23 +1552,24 @@ VOID MlmeAutoReconnectLastSSID(
 	}
 	// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
 	else if ((pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
-		(MlmeValidateSSID(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen) == TRUE))
-	{
+		 (MlmeValidateSSID
+		  (pAd->MlmeAux.AutoReconnectSsid,
+		   pAd->MlmeAux.AutoReconnectSsidLen) == TRUE)) {
 		NDIS_802_11_SSID OidSsid;
 		OidSsid.SsidLength = pAd->MlmeAux.AutoReconnectSsidLen;
-		NdisMoveMemory(OidSsid.Ssid, pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+		NdisMoveMemory(OidSsid.Ssid, pAd->MlmeAux.AutoReconnectSsid,
+			       pAd->MlmeAux.AutoReconnectSsidLen);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("Driver auto reconnect to last OID_802_11_SSID setting - %s, len - %d\n", pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen));
-		MlmeEnqueue(pAd,
-					MLME_CNTL_STATE_MACHINE,
-					OID_802_11_SSID,
-					sizeof(NDIS_802_11_SSID),
-					&OidSsid);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Driver auto reconnect to last OID_802_11_SSID setting - %s, len - %d\n",
+			  pAd->MlmeAux.AutoReconnectSsid,
+			  pAd->MlmeAux.AutoReconnectSsidLen));
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, OID_802_11_SSID,
+			    sizeof(NDIS_802_11_SSID), &OidSsid);
 		RTMP_MLME_HANDLER(pAd);
 	}
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1588,47 +1582,50 @@ VOID MlmeAutoReconnectLastSSID(
 	Output:
 	==========================================================================
  */
-VOID MlmeCheckForRoaming(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG	Now32)
-{
-	USHORT	   i;
-	BSS_TABLE  *pRoamTab = &pAd->MlmeAux.RoamTab;
-	BSS_ENTRY  *pBss;
+VOID MlmeCheckForRoaming(IN PRTMP_ADAPTER pAd, IN ULONG Now32)
+{
+	USHORT i;
+	BSS_TABLE *pRoamTab = &pAd->MlmeAux.RoamTab;
+	BSS_ENTRY *pBss;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeCheckForRoaming\n"));
 	// put all roaming candidates into RoamTab, and sort in RSSI order
 	BssTableInit(pRoamTab);
-	for (i = 0; i < pAd->ScanTab.BssNr; i++)
-	{
+	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
 		pBss = &pAd->ScanTab.BssEntry[i];
 
-		if ((pBss->LastBeaconRxTime + pAd->StaCfg.BeaconLostTime) < Now32)
-			continue;	 // AP disappear
+		if ((pBss->LastBeaconRxTime + pAd->StaCfg.BeaconLostTime) <
+		    Now32)
+			continue;	// AP disappear
 		if (pBss->Rssi <= RSSI_THRESHOLD_FOR_ROAMING)
-			continue;	 // RSSI too weak. forget it.
+			continue;	// RSSI too weak. forget it.
 		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))
-			continue;	 // skip current AP
-		if (pBss->Rssi < (pAd->StaCfg.RssiSample.LastRssi0 + RSSI_DELTA))
-			continue;	 // only AP with stronger RSSI is eligible for roaming
+			continue;	// skip current AP
+		if (pBss->Rssi <
+		    (pAd->StaCfg.RssiSample.LastRssi0 + RSSI_DELTA))
+			continue;	// only AP with stronger RSSI is eligible for roaming
 
 		// AP passing all above rules is put into roaming candidate table
-		NdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss, sizeof(BSS_ENTRY));
+		NdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss,
+			       sizeof(BSS_ENTRY));
 		pRoamTab->BssNr += 1;
 	}
 
-	if (pRoamTab->BssNr > 0)
-	{
+	if (pRoamTab->BssNr > 0) {
 		// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
-		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
-		{
-			pAd->RalinkCounters.PoorCQIRoamingCount ++;
-			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Roaming attempt #%ld\n", pAd->RalinkCounters.PoorCQIRoamingCount));
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_MLME_ROAMING_REQ, 0, NULL);
+		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
+			pAd->RalinkCounters.PoorCQIRoamingCount++;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MMCHK - Roaming attempt #%ld\n",
+				  pAd->RalinkCounters.PoorCQIRoamingCount));
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
+				    MT2_MLME_ROAMING_REQ, 0, NULL);
 			RTMP_MLME_HANDLER(pAd);
 		}
 	}
-	DBGPRINT(RT_DEBUG_TRACE, ("<== MlmeCheckForRoaming(# of candidate= %d)\n",pRoamTab->BssNr));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<== MlmeCheckForRoaming(# of candidate= %d)\n",
+		  pRoamTab->BssNr));
 }
 
 /*
@@ -1643,64 +1640,76 @@ VOID MlmeCheckForRoaming(
 	Output:
 	==========================================================================
  */
-BOOLEAN MlmeCheckForFastRoaming(
-	IN	PRTMP_ADAPTER	pAd)
+BOOLEAN MlmeCheckForFastRoaming(IN PRTMP_ADAPTER pAd)
 {
-	USHORT		i;
-	BSS_TABLE	*pRoamTab = &pAd->MlmeAux.RoamTab;
-	BSS_ENTRY	*pBss;
+	USHORT i;
+	BSS_TABLE *pRoamTab = &pAd->MlmeAux.RoamTab;
+	BSS_ENTRY *pBss;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeCheckForFastRoaming\n"));
 	// put all roaming candidates into RoamTab, and sort in RSSI order
 	BssTableInit(pRoamTab);
-	for (i = 0; i < pAd->ScanTab.BssNr; i++)
-		{
+	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
 		pBss = &pAd->ScanTab.BssEntry[i];
 
-        if ((pBss->Rssi <= -50) && (pBss->Channel == pAd->CommonCfg.Channel))
-			continue;	 // RSSI too weak. forget it.
+		if ((pBss->Rssi <= -50)
+		    && (pBss->Channel == pAd->CommonCfg.Channel))
+			continue;	// RSSI too weak. forget it.
 		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))
-			continue;	 // skip current AP
-		if (!SSID_EQUAL(pBss->Ssid, pBss->SsidLen, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen))
-			continue;	 // skip different SSID
-        if (pBss->Rssi < (RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0, pAd->StaCfg.RssiSample.LastRssi1, pAd->StaCfg.RssiSample.LastRssi2) + RSSI_DELTA))
-			continue;	 // skip AP without better RSSI
-
-        DBGPRINT(RT_DEBUG_TRACE, ("LastRssi0 = %d, pBss->Rssi = %d\n", RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0, pAd->StaCfg.RssiSample.LastRssi1, pAd->StaCfg.RssiSample.LastRssi2), pBss->Rssi));
+			continue;	// skip current AP
+		if (!SSID_EQUAL
+		    (pBss->Ssid, pBss->SsidLen, pAd->CommonCfg.Ssid,
+		     pAd->CommonCfg.SsidLen))
+			continue;	// skip different SSID
+		if (pBss->Rssi <
+		    (RTMPMaxRssi
+		     (pAd, pAd->StaCfg.RssiSample.LastRssi0,
+		      pAd->StaCfg.RssiSample.LastRssi1,
+		      pAd->StaCfg.RssiSample.LastRssi2) + RSSI_DELTA))
+			continue;	// skip AP without better RSSI
+
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("LastRssi0 = %d, pBss->Rssi = %d\n",
+			  RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0,
+				      pAd->StaCfg.RssiSample.LastRssi1,
+				      pAd->StaCfg.RssiSample.LastRssi2),
+			  pBss->Rssi));
 		// AP passing all above rules is put into roaming candidate table
-		NdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss, sizeof(BSS_ENTRY));
+		NdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss,
+			       sizeof(BSS_ENTRY));
 		pRoamTab->BssNr += 1;
-		}
+	}
 
-	DBGPRINT(RT_DEBUG_TRACE, ("<== MlmeCheckForFastRoaming (BssNr=%d)\n", pRoamTab->BssNr));
-	if (pRoamTab->BssNr > 0)
-		{
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<== MlmeCheckForFastRoaming (BssNr=%d)\n", pRoamTab->BssNr));
+	if (pRoamTab->BssNr > 0) {
 		// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
-		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
-				{
-			pAd->RalinkCounters.PoorCQIRoamingCount ++;
-			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Roaming attempt #%ld\n", pAd->RalinkCounters.PoorCQIRoamingCount));
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_MLME_ROAMING_REQ, 0, NULL);
+		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
+			pAd->RalinkCounters.PoorCQIRoamingCount++;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MMCHK - Roaming attempt #%ld\n",
+				  pAd->RalinkCounters.PoorCQIRoamingCount));
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
+				    MT2_MLME_ROAMING_REQ, 0, NULL);
 			RTMP_MLME_HANDLER(pAd);
 			return TRUE;
-				}
-				}
-
+		}
+	}
+
 	return FALSE;
 }
 
-VOID MlmeSetTxRate(
-	IN PRTMP_ADAPTER		pAd,
-	IN PMAC_TABLE_ENTRY		pEntry,
-	IN PRTMP_TX_RATE_SWITCH	pTxRate)
+VOID MlmeSetTxRate(IN PRTMP_ADAPTER pAd,
+		   IN PMAC_TABLE_ENTRY pEntry, IN PRTMP_TX_RATE_SWITCH pTxRate)
 {
-	UCHAR	MaxMode = MODE_OFDM;
+	UCHAR MaxMode = MODE_OFDM;
 
 	MaxMode = MODE_HTGREENFIELD;
 
-	if (pTxRate->STBC && (pAd->StaCfg.MaxHTPhyMode.field.STBC) && (pAd->Antenna.field.TxPath == 2))
+	if (pTxRate->STBC && (pAd->StaCfg.MaxHTPhyMode.field.STBC)
+	    && (pAd->Antenna.field.TxPath == 2))
 		pAd->StaCfg.HTPhyMode.field.STBC = STBC_USE;
-			else
+	else
 		pAd->StaCfg.HTPhyMode.field.STBC = STBC_NONE;
 
 	if (pTxRate->CurrMCS < MCS_AUTO)
@@ -1709,86 +1718,109 @@ VOID MlmeSetTxRate(
 	if (pAd->StaCfg.HTPhyMode.field.MCS > 7)
 		pAd->StaCfg.HTPhyMode.field.STBC = STBC_NONE;
 
-	if (ADHOC_ON(pAd))
-			{
+	if (ADHOC_ON(pAd)) {
 		// If peer adhoc is b-only mode, we can't send 11g rate.
 		pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
-		pEntry->HTPhyMode.field.STBC	= STBC_NONE;
+		pEntry->HTPhyMode.field.STBC = STBC_NONE;
 
 		//
 		// For Adhoc MODE_CCK, driver will use AdhocBOnlyJoined flag to roll back to B only if necessary
 		//
-		pEntry->HTPhyMode.field.MODE	= pTxRate->Mode;
-		pEntry->HTPhyMode.field.ShortGI	= pAd->StaCfg.HTPhyMode.field.ShortGI;
-		pEntry->HTPhyMode.field.MCS		= pAd->StaCfg.HTPhyMode.field.MCS;
+		pEntry->HTPhyMode.field.MODE = pTxRate->Mode;
+		pEntry->HTPhyMode.field.ShortGI =
+		    pAd->StaCfg.HTPhyMode.field.ShortGI;
+		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
 
 		// Patch speed error in status page
 		pAd->StaCfg.HTPhyMode.field.MODE = pEntry->HTPhyMode.field.MODE;
-			}
-			else
-			{
+	} else {
 		if (pTxRate->Mode <= MaxMode)
-		pAd->StaCfg.HTPhyMode.field.MODE = pTxRate->Mode;
+			pAd->StaCfg.HTPhyMode.field.MODE = pTxRate->Mode;
 
-        if (pTxRate->ShortGI && (pAd->StaCfg.MaxHTPhyMode.field.ShortGI))
+		if (pTxRate->ShortGI
+		    && (pAd->StaCfg.MaxHTPhyMode.field.ShortGI))
 			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_400;
 		else
 			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
 
 		// Reexam each bandwidth's SGI support.
-		if (pAd->StaCfg.HTPhyMode.field.ShortGI == GI_400)
-		{
-			if ((pEntry->HTPhyMode.field.BW == BW_20) && (!CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_SGI20_CAPABLE)))
+		if (pAd->StaCfg.HTPhyMode.field.ShortGI == GI_400) {
+			if ((pEntry->HTPhyMode.field.BW == BW_20)
+			    &&
+			    (!CLIENT_STATUS_TEST_FLAG
+			     (pEntry, fCLIENT_STATUS_SGI20_CAPABLE)))
 				pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
-			if ((pEntry->HTPhyMode.field.BW == BW_40) && (!CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_SGI40_CAPABLE)))
+			if ((pEntry->HTPhyMode.field.BW == BW_40)
+			    &&
+			    (!CLIENT_STATUS_TEST_FLAG
+			     (pEntry, fCLIENT_STATUS_SGI40_CAPABLE)))
 				pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
 		}
+		// Turn RTS/CTS rate to 6Mbps.
+		if ((pEntry->HTPhyMode.field.MCS == 0)
+		    && (pAd->StaCfg.HTPhyMode.field.MCS != 0)) {
+			pEntry->HTPhyMode.field.MCS =
+			    pAd->StaCfg.HTPhyMode.field.MCS;
+			if (pAd->MacTab.fAnyBASession) {
+				AsicUpdateProtect(pAd, HT_FORCERTSCTS,
+						  ALLN_SETPROTECT, TRUE,
+						  (BOOLEAN) pAd->MlmeAux.
+						  AddHtInfo.AddHtInfo2.
+						  NonGfPresent);
+			} else {
+				AsicUpdateProtect(pAd,
+						  pAd->MlmeAux.AddHtInfo.
+						  AddHtInfo2.OperaionMode,
+						  ALLN_SETPROTECT, TRUE,
+						  (BOOLEAN) pAd->MlmeAux.
+						  AddHtInfo.AddHtInfo2.
+						  NonGfPresent);
+			}
+		} else if ((pEntry->HTPhyMode.field.MCS == 8)
+			   && (pAd->StaCfg.HTPhyMode.field.MCS != 8)) {
+			pEntry->HTPhyMode.field.MCS =
+			    pAd->StaCfg.HTPhyMode.field.MCS;
+			if (pAd->MacTab.fAnyBASession) {
+				AsicUpdateProtect(pAd, HT_FORCERTSCTS,
+						  ALLN_SETPROTECT, TRUE,
+						  (BOOLEAN) pAd->MlmeAux.
+						  AddHtInfo.AddHtInfo2.
+						  NonGfPresent);
+			} else {
+				AsicUpdateProtect(pAd,
+						  pAd->MlmeAux.AddHtInfo.
+						  AddHtInfo2.OperaionMode,
+						  ALLN_SETPROTECT, TRUE,
+						  (BOOLEAN) pAd->MlmeAux.
+						  AddHtInfo.AddHtInfo2.
+						  NonGfPresent);
+			}
+		} else if ((pEntry->HTPhyMode.field.MCS != 0)
+			   && (pAd->StaCfg.HTPhyMode.field.MCS == 0)) {
+			AsicUpdateProtect(pAd, HT_RTSCTS_6M, ALLN_SETPROTECT,
+					  TRUE,
+					  (BOOLEAN) pAd->MlmeAux.AddHtInfo.
+					  AddHtInfo2.NonGfPresent);
+
+		} else if ((pEntry->HTPhyMode.field.MCS != 8)
+			   && (pAd->StaCfg.HTPhyMode.field.MCS == 8)) {
+			AsicUpdateProtect(pAd, HT_RTSCTS_6M, ALLN_SETPROTECT,
+					  TRUE,
+					  (BOOLEAN) pAd->MlmeAux.AddHtInfo.
+					  AddHtInfo2.NonGfPresent);
+		}
+
+		pEntry->HTPhyMode.field.STBC = pAd->StaCfg.HTPhyMode.field.STBC;
+		pEntry->HTPhyMode.field.ShortGI =
+		    pAd->StaCfg.HTPhyMode.field.ShortGI;
+		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+		pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
+		if ((pAd->StaCfg.MaxHTPhyMode.field.MODE == MODE_HTGREENFIELD)
+		    && pAd->WIFItestbed.bGreenField)
+			pEntry->HTPhyMode.field.MODE = MODE_HTGREENFIELD;
+	}
 
-        // Turn RTS/CTS rate to 6Mbps.
-		if ((pEntry->HTPhyMode.field.MCS == 0) && (pAd->StaCfg.HTPhyMode.field.MCS != 0))
-			{
-			pEntry->HTPhyMode.field.MCS		= pAd->StaCfg.HTPhyMode.field.MCS;
-			if (pAd->MacTab.fAnyBASession)
-			{
-				AsicUpdateProtect(pAd, HT_FORCERTSCTS, ALLN_SETPROTECT, TRUE, (BOOLEAN)pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent);
-            }
-			else
-			{
-				AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, TRUE, (BOOLEAN)pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent);
-				}
-			}
-		else if ((pEntry->HTPhyMode.field.MCS == 8) && (pAd->StaCfg.HTPhyMode.field.MCS != 8))
-			{
-			pEntry->HTPhyMode.field.MCS		= pAd->StaCfg.HTPhyMode.field.MCS;
-			if (pAd->MacTab.fAnyBASession)
-				{
-				AsicUpdateProtect(pAd, HT_FORCERTSCTS, ALLN_SETPROTECT, TRUE, (BOOLEAN)pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent);
-				}
-				else
-				{
-				AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, TRUE, (BOOLEAN)pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent);
-				}
-			}
-		else if ((pEntry->HTPhyMode.field.MCS != 0) && (pAd->StaCfg.HTPhyMode.field.MCS == 0))
-				{
-			AsicUpdateProtect(pAd, HT_RTSCTS_6M, ALLN_SETPROTECT, TRUE, (BOOLEAN)pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent);
-
-				}
-		else if ((pEntry->HTPhyMode.field.MCS != 8) && (pAd->StaCfg.HTPhyMode.field.MCS == 8))
-				{
-			AsicUpdateProtect(pAd, HT_RTSCTS_6M, ALLN_SETPROTECT, TRUE, (BOOLEAN)pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent);
-			}
-
-		pEntry->HTPhyMode.field.STBC	= pAd->StaCfg.HTPhyMode.field.STBC;
-		pEntry->HTPhyMode.field.ShortGI	= pAd->StaCfg.HTPhyMode.field.ShortGI;
-		pEntry->HTPhyMode.field.MCS		= pAd->StaCfg.HTPhyMode.field.MCS;
-		pEntry->HTPhyMode.field.MODE	= pAd->StaCfg.HTPhyMode.field.MODE;
-        if ((pAd->StaCfg.MaxHTPhyMode.field.MODE == MODE_HTGREENFIELD) &&
-            pAd->WIFItestbed.bGreenField)
-            pEntry->HTPhyMode.field.MODE = MODE_HTGREENFIELD;
-		}
-
-    pAd->LastTxRate = (USHORT)(pEntry->HTPhyMode.word);
+	pAd->LastTxRate = (USHORT) (pEntry->HTPhyMode.word);
 }
 
 /*
@@ -1808,42 +1840,37 @@ VOID MlmeSetTxRate(
 		call this routine every second
 	==========================================================================
  */
-VOID MlmeDynamicTxRateSwitching(
-	IN PRTMP_ADAPTER pAd)
+VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR					UpRateIdx = 0, DownRateIdx = 0, CurrRateIdx;
-	ULONG					i, AccuTxTotalCnt = 0, TxTotalCnt;
-	ULONG					TxErrorRatio = 0;
-	BOOLEAN					bTxRateChanged = FALSE, bUpgradeQuality = FALSE;
-	PRTMP_TX_RATE_SWITCH	pCurrTxRate, pNextTxRate = NULL;
-	PUCHAR					pTable;
-	UCHAR					TableSize = 0;
-	UCHAR					InitTxRateIdx = 0, TrainUp, TrainDown;
-	CHAR					Rssi, RssiOffset = 0;
-	TX_STA_CNT1_STRUC		StaTx1;
-	TX_STA_CNT0_STRUC		TxStaCnt0;
-	ULONG					TxRetransmit = 0, TxSuccess = 0, TxFailCount = 0;
-	MAC_TABLE_ENTRY			*pEntry;
-	RSSI_SAMPLE				*pRssi = &pAd->StaCfg.RssiSample;
-
+	UCHAR UpRateIdx = 0, DownRateIdx = 0, CurrRateIdx;
+	ULONG i, AccuTxTotalCnt = 0, TxTotalCnt;
+	ULONG TxErrorRatio = 0;
+	BOOLEAN bTxRateChanged = FALSE, bUpgradeQuality = FALSE;
+	PRTMP_TX_RATE_SWITCH pCurrTxRate, pNextTxRate = NULL;
+	PUCHAR pTable;
+	UCHAR TableSize = 0;
+	UCHAR InitTxRateIdx = 0, TrainUp, TrainDown;
+	CHAR Rssi, RssiOffset = 0;
+	TX_STA_CNT1_STRUC StaTx1;
+	TX_STA_CNT0_STRUC TxStaCnt0;
+	ULONG TxRetransmit = 0, TxSuccess = 0, TxFailCount = 0;
+	MAC_TABLE_ENTRY *pEntry;
+	RSSI_SAMPLE *pRssi = &pAd->StaCfg.RssiSample;
 
 	//
 	// walk through MAC table, see if need to change AP's TX rate toward each entry
 	//
-	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++)
-	{
+	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
 		pEntry = &pAd->MacTab.Content[i];
 
-	// check if this entry need to switch rate automatically
+		// check if this entry need to switch rate automatically
 		if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pEntry) == FALSE)
 			continue;
 
-		if ((pAd->MacTab.Size == 1) || (pEntry->ValidAsDls))
-		{
+		if ((pAd->MacTab.Size == 1) || (pEntry->ValidAsDls)) {
 			Rssi = RTMPMaxRssi(pAd,
-							   pRssi->AvgRssi0,
-							   pRssi->AvgRssi1,
-							   pRssi->AvgRssi2);
+					   pRssi->AvgRssi0,
+					   pRssi->AvgRssi1, pRssi->AvgRssi2);
 
 			// Update statistic counter
 			RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
@@ -1854,55 +1881,63 @@ VOID MlmeDynamicTxRateSwitching(
 			TxFailCount = TxStaCnt0.field.TxFailCount;
 			TxTotalCnt = TxRetransmit + TxSuccess + TxFailCount;
 
-			pAd->RalinkCounters.OneSecTxRetryOkCount += StaTx1.field.TxRetransmit;
-			pAd->RalinkCounters.OneSecTxNoRetryOkCount += StaTx1.field.TxSuccess;
-			pAd->RalinkCounters.OneSecTxFailCount += TxStaCnt0.field.TxFailCount;
-			pAd->WlanCounters.TransmittedFragmentCount.u.LowPart += StaTx1.field.TxSuccess;
-			pAd->WlanCounters.RetryCount.u.LowPart += StaTx1.field.TxRetransmit;
-			pAd->WlanCounters.FailedCount.u.LowPart += TxStaCnt0.field.TxFailCount;
+			pAd->RalinkCounters.OneSecTxRetryOkCount +=
+			    StaTx1.field.TxRetransmit;
+			pAd->RalinkCounters.OneSecTxNoRetryOkCount +=
+			    StaTx1.field.TxSuccess;
+			pAd->RalinkCounters.OneSecTxFailCount +=
+			    TxStaCnt0.field.TxFailCount;
+			pAd->WlanCounters.TransmittedFragmentCount.u.LowPart +=
+			    StaTx1.field.TxSuccess;
+			pAd->WlanCounters.RetryCount.u.LowPart +=
+			    StaTx1.field.TxRetransmit;
+			pAd->WlanCounters.FailedCount.u.LowPart +=
+			    TxStaCnt0.field.TxFailCount;
 
 			// if no traffic in the past 1-sec period, don't change TX rate,
 			// but clear all bad history. because the bad history may affect the next
 			// Chariot throughput test
-			AccuTxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-						 pAd->RalinkCounters.OneSecTxRetryOkCount +
-						 pAd->RalinkCounters.OneSecTxFailCount;
+			AccuTxTotalCnt =
+			    pAd->RalinkCounters.OneSecTxNoRetryOkCount +
+			    pAd->RalinkCounters.OneSecTxRetryOkCount +
+			    pAd->RalinkCounters.OneSecTxFailCount;
 
 			if (TxTotalCnt)
-				TxErrorRatio = ((TxRetransmit + TxFailCount) * 100) / TxTotalCnt;
-		}
-		else
-	{
+				TxErrorRatio =
+				    ((TxRetransmit +
+				      TxFailCount) * 100) / TxTotalCnt;
+		} else {
 			if (INFRA_ON(pAd) && (i == 1))
 				Rssi = RTMPMaxRssi(pAd,
-								   pRssi->AvgRssi0,
-								   pRssi->AvgRssi1,
-								   pRssi->AvgRssi2);
+						   pRssi->AvgRssi0,
+						   pRssi->AvgRssi1,
+						   pRssi->AvgRssi2);
 			else
 				Rssi = RTMPMaxRssi(pAd,
-								   pEntry->RssiSample.AvgRssi0,
-								   pEntry->RssiSample.AvgRssi1,
-								   pEntry->RssiSample.AvgRssi2);
+						   pEntry->RssiSample.AvgRssi0,
+						   pEntry->RssiSample.AvgRssi1,
+						   pEntry->RssiSample.AvgRssi2);
 
 			TxTotalCnt = pEntry->OneSecTxNoRetryOkCount +
-				 pEntry->OneSecTxRetryOkCount +
-				 pEntry->OneSecTxFailCount;
+			    pEntry->OneSecTxRetryOkCount +
+			    pEntry->OneSecTxFailCount;
 
 			if (TxTotalCnt)
-				TxErrorRatio = ((pEntry->OneSecTxRetryOkCount + pEntry->OneSecTxFailCount) * 100) / TxTotalCnt;
-	}
+				TxErrorRatio =
+				    ((pEntry->OneSecTxRetryOkCount +
+				      pEntry->OneSecTxFailCount) * 100) /
+				    TxTotalCnt;
+		}
 
-		if (TxTotalCnt)
-		{
+		if (TxTotalCnt) {
 			/*
-				Three AdHoc connections can not work normally if one AdHoc connection is disappeared from a heavy traffic environment generated by ping tool
-				We force to set LongRtyLimit and ShortRtyLimit to 0 to stop retransmitting packet, after a while, resoring original settings
-			*/
-			if (TxErrorRatio == 100)
-			{
-				TX_RTY_CFG_STRUC	TxRtyCfg,TxRtyCfgtmp;
-				ULONG	Index;
-				ULONG	MACValue;
+			   Three AdHoc connections can not work normally if one AdHoc connection is disappeared from a heavy traffic environment generated by ping tool
+			   We force to set LongRtyLimit and ShortRtyLimit to 0 to stop retransmitting packet, after a while, resoring original settings
+			 */
+			if (TxErrorRatio == 100) {
+				TX_RTY_CFG_STRUC TxRtyCfg, TxRtyCfgtmp;
+				ULONG Index;
+				ULONG MACValue;
 
 				RTMP_IO_READ32(pAd, TX_RTY_CFG, &TxRtyCfg.word);
 				TxRtyCfgtmp.word = TxRtyCfg.word;
@@ -1914,42 +1949,49 @@ VOID MlmeDynamicTxRateSwitching(
 
 				Index = 0;
 				MACValue = 0;
-				do
-		{
-					RTMP_IO_READ32(pAd, TXRXQ_PCNT, &MACValue);
+				do {
+					RTMP_IO_READ32(pAd, TXRXQ_PCNT,
+						       &MACValue);
 					if ((MACValue & 0xffffff) == 0)
 						break;
 					Index++;
 					RTMPusecDelay(1000);
-				}while((Index < 330)&&(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)));
+				} while ((Index < 330)
+					 &&
+					 (!RTMP_TEST_FLAG
+					  (pAd,
+					   fRTMP_ADAPTER_HALT_IN_PROGRESS)));
 
 				RTMP_IO_READ32(pAd, TX_RTY_CFG, &TxRtyCfg.word);
-				TxRtyCfg.field.LongRtyLimit = TxRtyCfgtmp.field.LongRtyLimit;
-				TxRtyCfg.field.ShortRtyLimit = TxRtyCfgtmp.field.ShortRtyLimit;
+				TxRtyCfg.field.LongRtyLimit =
+				    TxRtyCfgtmp.field.LongRtyLimit;
+				TxRtyCfg.field.ShortRtyLimit =
+				    TxRtyCfgtmp.field.ShortRtyLimit;
 				RTMP_IO_WRITE32(pAd, TX_RTY_CFG, TxRtyCfg.word);
+			}
 		}
-	}
 
 		CurrRateIdx = pEntry->CurrTxRateIndex;
 
-		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize, &InitTxRateIdx);
+		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize,
+				      &InitTxRateIdx);
 
-		if (CurrRateIdx >= TableSize)
-		{
+		if (CurrRateIdx >= TableSize) {
 			CurrRateIdx = TableSize - 1;
 		}
-
 		// When switch from Fixed rate -> auto rate, the REAL TX rate might be different from pAd->CommonCfg.TxRateIndex.
 		// So need to sync here.
-		pCurrTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(CurrRateIdx+1)*5];
+		pCurrTxRate =
+		    (PRTMP_TX_RATE_SWITCH) & pTable[(CurrRateIdx + 1) * 5];
 		if ((pEntry->HTPhyMode.field.MCS != pCurrTxRate->CurrMCS)
-			//&& (pAd->StaCfg.bAutoTxRateSwitch == TRUE)
-			)
-		{
+		    //&& (pAd->StaCfg.bAutoTxRateSwitch == TRUE)
+		    ) {
 
 			// Need to sync Real Tx rate and our record.
 			// Then return for next DRS.
-			pCurrTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(InitTxRateIdx+1)*5];
+			pCurrTxRate =
+			    (PRTMP_TX_RATE_SWITCH) & pTable[(InitTxRateIdx + 1)
+							    * 5];
 			pEntry->CurrTxRateIndex = InitTxRateIdx;
 			MlmeSetTxRate(pAd, pEntry, pCurrTxRate);
 
@@ -1957,222 +1999,176 @@ VOID MlmeDynamicTxRateSwitching(
 			RESET_ONE_SEC_TX_CNT(pEntry);
 			continue;
 		}
-
 		// decide the next upgrade rate and downgrade rate, if any
-		if ((CurrRateIdx > 0) && (CurrRateIdx < (TableSize - 1)))
-	{
+		if ((CurrRateIdx > 0) && (CurrRateIdx < (TableSize - 1))) {
 			UpRateIdx = CurrRateIdx + 1;
-			DownRateIdx = CurrRateIdx -1;
-	}
-		else if (CurrRateIdx == 0)
-		{
+			DownRateIdx = CurrRateIdx - 1;
+		} else if (CurrRateIdx == 0) {
 			UpRateIdx = CurrRateIdx + 1;
 			DownRateIdx = CurrRateIdx;
-		}
-		else if (CurrRateIdx == (TableSize - 1))
-	{
+		} else if (CurrRateIdx == (TableSize - 1)) {
 			UpRateIdx = CurrRateIdx;
 			DownRateIdx = CurrRateIdx - 1;
-	}
+		}
 
-		pCurrTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(CurrRateIdx+1)*5];
+		pCurrTxRate =
+		    (PRTMP_TX_RATE_SWITCH) & pTable[(CurrRateIdx + 1) * 5];
 
-		if ((Rssi > -65) && (pCurrTxRate->Mode >= MODE_HTMIX))
-	{
-			TrainUp		= (pCurrTxRate->TrainUp + (pCurrTxRate->TrainUp >> 1));
-			TrainDown	= (pCurrTxRate->TrainDown + (pCurrTxRate->TrainDown >> 1));
-	}
-	else
-	{
-			TrainUp		= pCurrTxRate->TrainUp;
-			TrainDown	= pCurrTxRate->TrainDown;
-	}
+		if ((Rssi > -65) && (pCurrTxRate->Mode >= MODE_HTMIX)) {
+			TrainUp =
+			    (pCurrTxRate->TrainUp +
+			     (pCurrTxRate->TrainUp >> 1));
+			TrainDown =
+			    (pCurrTxRate->TrainDown +
+			     (pCurrTxRate->TrainDown >> 1));
+		} else {
+			TrainUp = pCurrTxRate->TrainUp;
+			TrainDown = pCurrTxRate->TrainDown;
+		}
 
 		//pAd->DrsCounters.LastTimeTxRateChangeAction = pAd->DrsCounters.LastSecTxRateChangeAction;
 
 		//
 		// Keep the last time TxRateChangeAction status.
 		//
-		pEntry->LastTimeTxRateChangeAction = pEntry->LastSecTxRateChangeAction;
-
-
+		pEntry->LastTimeTxRateChangeAction =
+		    pEntry->LastSecTxRateChangeAction;
 
 		//
 		// CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI
 		//         (criteria copied from RT2500 for Netopia case)
 		//
-		if (TxTotalCnt <= 15)
-	{
-			CHAR	idx = 0;
-			UCHAR	TxRateIdx;
-			UCHAR	MCS0 = 0, MCS1 = 0, MCS2 = 0, MCS3 = 0, MCS4 = 0,  MCS5 =0, MCS6 = 0, MCS7 = 0;
-	        UCHAR	MCS12 = 0, MCS13 = 0, MCS14 = 0, MCS15 = 0;
-			UCHAR	MCS20 = 0, MCS21 = 0, MCS22 = 0, MCS23 = 0; // 3*3
+		if (TxTotalCnt <= 15) {
+			CHAR idx = 0;
+			UCHAR TxRateIdx;
+			UCHAR MCS0 = 0, MCS1 = 0, MCS2 = 0, MCS3 = 0, MCS4 =
+			    0, MCS5 = 0, MCS6 = 0, MCS7 = 0;
+			UCHAR MCS12 = 0, MCS13 = 0, MCS14 = 0, MCS15 = 0;
+			UCHAR MCS20 = 0, MCS21 = 0, MCS22 = 0, MCS23 = 0;	// 3*3
 
 			// check the existence and index of each needed MCS
-			while (idx < pTable[0])
-			{
-				pCurrTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(idx+1)*5];
+			while (idx < pTable[0]) {
+				pCurrTxRate =
+				    (PRTMP_TX_RATE_SWITCH) & pTable[(idx + 1) *
+								    5];
 
-				if (pCurrTxRate->CurrMCS == MCS_0)
-		{
+				if (pCurrTxRate->CurrMCS == MCS_0) {
 					MCS0 = idx;
-		}
-				else if (pCurrTxRate->CurrMCS == MCS_1)
-		{
+				} else if (pCurrTxRate->CurrMCS == MCS_1) {
 					MCS1 = idx;
-				}
-				else if (pCurrTxRate->CurrMCS == MCS_2)
-			{
+				} else if (pCurrTxRate->CurrMCS == MCS_2) {
 					MCS2 = idx;
-			}
-				else if (pCurrTxRate->CurrMCS == MCS_3)
-			{
+				} else if (pCurrTxRate->CurrMCS == MCS_3) {
 					MCS3 = idx;
-				}
-				else if (pCurrTxRate->CurrMCS == MCS_4)
-				{
+				} else if (pCurrTxRate->CurrMCS == MCS_4) {
 					MCS4 = idx;
-			}
-	            else if (pCurrTxRate->CurrMCS == MCS_5)
-	            {
-	                MCS5 = idx;
-		}
-	            else if (pCurrTxRate->CurrMCS == MCS_6)
-		{
-	                MCS6 = idx;
-	            }
+				} else if (pCurrTxRate->CurrMCS == MCS_5) {
+					MCS5 = idx;
+				} else if (pCurrTxRate->CurrMCS == MCS_6) {
+					MCS6 = idx;
+				}
 				//else if (pCurrTxRate->CurrMCS == MCS_7)
 				else if ((pCurrTxRate->CurrMCS == MCS_7) && (pCurrTxRate->ShortGI == GI_800))	// prevent the highest MCS using short GI when 1T and low throughput
-			{
+				{
 					MCS7 = idx;
-			}
-				else if (pCurrTxRate->CurrMCS == MCS_12)
-			{
+				} else if (pCurrTxRate->CurrMCS == MCS_12) {
 					MCS12 = idx;
-			}
-				else if (pCurrTxRate->CurrMCS == MCS_13)
-				{
+				} else if (pCurrTxRate->CurrMCS == MCS_13) {
 					MCS13 = idx;
-		}
-				else if (pCurrTxRate->CurrMCS == MCS_14)
-		{
+				} else if (pCurrTxRate->CurrMCS == MCS_14) {
 					MCS14 = idx;
-		}
-				//else if ((pCurrTxRate->CurrMCS == MCS_15)/* && (pCurrTxRate->ShortGI == GI_800)*/)	//we hope to use ShortGI as initial rate
+				}
+				//else if ((pCurrTxRate->CurrMCS == MCS_15)/* && (pCurrTxRate->ShortGI == GI_800)*/)    //we hope to use ShortGI as initial rate
 				else if ((pCurrTxRate->CurrMCS == MCS_15) && (pCurrTxRate->ShortGI == GI_800))	//we hope to use ShortGI as initial rate, however Atheros's chip has bugs when short GI
-		{
+				{
 					MCS15 = idx;
-		}
-				else if (pCurrTxRate->CurrMCS == MCS_20) // 3*3
+				} else if (pCurrTxRate->CurrMCS == MCS_20)	// 3*3
 				{
 					MCS20 = idx;
-				}
-				else if (pCurrTxRate->CurrMCS == MCS_21)
-				{
+				} else if (pCurrTxRate->CurrMCS == MCS_21) {
 					MCS21 = idx;
-				}
-				else if (pCurrTxRate->CurrMCS == MCS_22)
-				{
+				} else if (pCurrTxRate->CurrMCS == MCS_22) {
 					MCS22 = idx;
-				}
-				else if (pCurrTxRate->CurrMCS == MCS_23)
-				{
+				} else if (pCurrTxRate->CurrMCS == MCS_23) {
 					MCS23 = idx;
 				}
-				idx ++;
+				idx++;
 			}
 
-			if (pAd->LatchRfRegs.Channel <= 14)
-			{
-				if (pAd->NicConfig2.field.ExternalLNAForG)
-				{
+			if (pAd->LatchRfRegs.Channel <= 14) {
+				if (pAd->NicConfig2.field.ExternalLNAForG) {
 					RssiOffset = 2;
-				}
-				else
-				{
+				} else {
 					RssiOffset = 5;
 				}
-			}
-			else
-			{
-				if (pAd->NicConfig2.field.ExternalLNAForA)
-				{
+			} else {
+				if (pAd->NicConfig2.field.ExternalLNAForA) {
 					RssiOffset = 5;
-				}
-				else
-				{
+				} else {
 					RssiOffset = 8;
 				}
 			}
 
-			/*if (MCS15)*/
-			if ((pTable == RateSwitchTable11BGN3S) ||
-				(pTable == RateSwitchTable11N3S) ||
-				(pTable == RateSwitchTable))
-			{// N mode with 3 stream // 3*3
+			/*if (MCS15) */
+			if ((pTable == RateSwitchTable11BGN3S) || (pTable == RateSwitchTable11N3S) || (pTable == RateSwitchTable)) {	// N mode with 3 stream // 3*3
 				if (MCS23 && (Rssi >= -70))
 					TxRateIdx = MCS23;
 				else if (MCS22 && (Rssi >= -72))
 					TxRateIdx = MCS22;
-        	    else if (MCS21 && (Rssi >= -76))
+				else if (MCS21 && (Rssi >= -76))
 					TxRateIdx = MCS21;
 				else if (MCS20 && (Rssi >= -78))
 					TxRateIdx = MCS20;
-			else if (MCS4 && (Rssi >= -82))
-				TxRateIdx = MCS4;
-			else if (MCS3 && (Rssi >= -84))
-				TxRateIdx = MCS3;
-			else if (MCS2 && (Rssi >= -86))
-				TxRateIdx = MCS2;
-			else if (MCS1 && (Rssi >= -88))
-				TxRateIdx = MCS1;
-			else
-				TxRateIdx = MCS0;
-		}
-//		else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand) || (pTable == RateSwitchTable))
-		else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand)) // 3*3
-			{// N mode with 2 stream
-				if (MCS15 && (Rssi >= (-70+RssiOffset)))
+				else if (MCS4 && (Rssi >= -82))
+					TxRateIdx = MCS4;
+				else if (MCS3 && (Rssi >= -84))
+					TxRateIdx = MCS3;
+				else if (MCS2 && (Rssi >= -86))
+					TxRateIdx = MCS2;
+				else if (MCS1 && (Rssi >= -88))
+					TxRateIdx = MCS1;
+				else
+					TxRateIdx = MCS0;
+			}
+//              else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand) || (pTable == RateSwitchTable))
+			else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) || (pTable == RateSwitchTable11N2S) || (pTable == RateSwitchTable11N2SForABand))	// 3*3
+			{	// N mode with 2 stream
+				if (MCS15 && (Rssi >= (-70 + RssiOffset)))
 					TxRateIdx = MCS15;
-				else if (MCS14 && (Rssi >= (-72+RssiOffset)))
+				else if (MCS14 && (Rssi >= (-72 + RssiOffset)))
 					TxRateIdx = MCS14;
-				else if (MCS13 && (Rssi >= (-76+RssiOffset)))
+				else if (MCS13 && (Rssi >= (-76 + RssiOffset)))
 					TxRateIdx = MCS13;
-				else if (MCS12 && (Rssi >= (-78+RssiOffset)))
+				else if (MCS12 && (Rssi >= (-78 + RssiOffset)))
 					TxRateIdx = MCS12;
-				else if (MCS4 && (Rssi >= (-82+RssiOffset)))
+				else if (MCS4 && (Rssi >= (-82 + RssiOffset)))
 					TxRateIdx = MCS4;
-				else if (MCS3 && (Rssi >= (-84+RssiOffset)))
+				else if (MCS3 && (Rssi >= (-84 + RssiOffset)))
 					TxRateIdx = MCS3;
-				else if (MCS2 && (Rssi >= (-86+RssiOffset)))
+				else if (MCS2 && (Rssi >= (-86 + RssiOffset)))
 					TxRateIdx = MCS2;
-				else if (MCS1 && (Rssi >= (-88+RssiOffset)))
+				else if (MCS1 && (Rssi >= (-88 + RssiOffset)))
 					TxRateIdx = MCS1;
 				else
 					TxRateIdx = MCS0;
-			}
-			else if ((pTable == RateSwitchTable11BGN1S) || (pTable == RateSwitchTable11N1S))
-			{// N mode with 1 stream
-				if (MCS7 && (Rssi > (-72+RssiOffset)))
+			} else if ((pTable == RateSwitchTable11BGN1S) || (pTable == RateSwitchTable11N1S)) {	// N mode with 1 stream
+				if (MCS7 && (Rssi > (-72 + RssiOffset)))
 					TxRateIdx = MCS7;
-				else if (MCS6 && (Rssi > (-74+RssiOffset)))
+				else if (MCS6 && (Rssi > (-74 + RssiOffset)))
 					TxRateIdx = MCS6;
-				else if (MCS5 && (Rssi > (-77+RssiOffset)))
+				else if (MCS5 && (Rssi > (-77 + RssiOffset)))
 					TxRateIdx = MCS5;
-				else if (MCS4 && (Rssi > (-79+RssiOffset)))
+				else if (MCS4 && (Rssi > (-79 + RssiOffset)))
 					TxRateIdx = MCS4;
-				else if (MCS3 && (Rssi > (-81+RssiOffset)))
+				else if (MCS3 && (Rssi > (-81 + RssiOffset)))
 					TxRateIdx = MCS3;
-				else if (MCS2 && (Rssi > (-83+RssiOffset)))
+				else if (MCS2 && (Rssi > (-83 + RssiOffset)))
 					TxRateIdx = MCS2;
-				else if (MCS1 && (Rssi > (-86+RssiOffset)))
+				else if (MCS1 && (Rssi > (-86 + RssiOffset)))
 					TxRateIdx = MCS1;
 				else
 					TxRateIdx = MCS0;
-			}
-			else
-			{// Legacy mode
+			} else {	// Legacy mode
 				if (MCS7 && (Rssi > -70))
 					TxRateIdx = MCS7;
 				else if (MCS6 && (Rssi > -74))
@@ -2193,15 +2189,21 @@ VOID MlmeDynamicTxRateSwitching(
 					TxRateIdx = MCS0;
 			}
 
-	//		if (TxRateIdx != pAd->CommonCfg.TxRateIndex)
+			//              if (TxRateIdx != pAd->CommonCfg.TxRateIndex)
 			{
 				pEntry->CurrTxRateIndex = TxRateIdx;
-				pNextTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(pEntry->CurrTxRateIndex+1)*5];
+				pNextTxRate =
+				    (PRTMP_TX_RATE_SWITCH) &
+				    pTable[(pEntry->CurrTxRateIndex + 1) * 5];
 				MlmeSetTxRate(pAd, pEntry, pNextTxRate);
 			}
 
-			NdisZeroMemory(pEntry->TxQuality, sizeof(USHORT) * MAX_STEP_OF_TX_RATE_SWITCH);
-			NdisZeroMemory(pEntry->PER, sizeof(UCHAR) * MAX_STEP_OF_TX_RATE_SWITCH);
+			NdisZeroMemory(pEntry->TxQuality,
+				       sizeof(USHORT) *
+				       MAX_STEP_OF_TX_RATE_SWITCH);
+			NdisZeroMemory(pEntry->PER,
+				       sizeof(UCHAR) *
+				       MAX_STEP_OF_TX_RATE_SWITCH);
 			pEntry->fLastSecAccordingRSSI = TRUE;
 			// reset all OneSecTx counters
 			RESET_ONE_SEC_TX_CNT(pEntry);
@@ -2209,8 +2211,7 @@ VOID MlmeDynamicTxRateSwitching(
 			continue;
 		}
 
-		if (pEntry->fLastSecAccordingRSSI == TRUE)
-		{
+		if (pEntry->fLastSecAccordingRSSI == TRUE) {
 			pEntry->fLastSecAccordingRSSI = FALSE;
 			pEntry->LastSecTxRateChangeAction = 0;
 			// reset all OneSecTx counters
@@ -2219,91 +2220,93 @@ VOID MlmeDynamicTxRateSwitching(
 			continue;
 		}
 
-		do
-		{
-			BOOLEAN	bTrainUpDown = FALSE;
+		do {
+			BOOLEAN bTrainUpDown = FALSE;
 
-			pEntry->CurrTxRateStableTime ++;
+			pEntry->CurrTxRateStableTime++;
 
 			// downgrade TX quality if PER >= Rate-Down threshold
-			if (TxErrorRatio >= TrainDown)
-			{
+			if (TxErrorRatio >= TrainDown) {
 				bTrainUpDown = TRUE;
-				pEntry->TxQuality[CurrRateIdx] = DRS_TX_QUALITY_WORST_BOUND;
+				pEntry->TxQuality[CurrRateIdx] =
+				    DRS_TX_QUALITY_WORST_BOUND;
 			}
 			// upgrade TX quality if PER <= Rate-Up threshold
-			else if (TxErrorRatio <= TrainUp)
-			{
+			else if (TxErrorRatio <= TrainUp) {
 				bTrainUpDown = TRUE;
 				bUpgradeQuality = TRUE;
 				if (pEntry->TxQuality[CurrRateIdx])
-					pEntry->TxQuality[CurrRateIdx] --;  // quality very good in CurrRate
+					pEntry->TxQuality[CurrRateIdx]--;	// quality very good in CurrRate
 
 				if (pEntry->TxRateUpPenalty)
-					pEntry->TxRateUpPenalty --;
+					pEntry->TxRateUpPenalty--;
 				else if (pEntry->TxQuality[UpRateIdx])
-					pEntry->TxQuality[UpRateIdx] --;    // may improve next UP rate's quality
+					pEntry->TxQuality[UpRateIdx]--;	// may improve next UP rate's quality
 			}
 
-			pEntry->PER[CurrRateIdx] = (UCHAR)TxErrorRatio;
+			pEntry->PER[CurrRateIdx] = (UCHAR) TxErrorRatio;
 
-			if (bTrainUpDown)
-			{
+			if (bTrainUpDown) {
 				// perform DRS - consider TxRate Down first, then rate up.
-				if ((CurrRateIdx != DownRateIdx) && (pEntry->TxQuality[CurrRateIdx] >= DRS_TX_QUALITY_WORST_BOUND))
-				{
+				if ((CurrRateIdx != DownRateIdx)
+				    && (pEntry->TxQuality[CurrRateIdx] >=
+					DRS_TX_QUALITY_WORST_BOUND)) {
 					pEntry->CurrTxRateIndex = DownRateIdx;
-				}
-				else if ((CurrRateIdx != UpRateIdx) && (pEntry->TxQuality[UpRateIdx] <= 0))
-				{
+				} else if ((CurrRateIdx != UpRateIdx)
+					   && (pEntry->TxQuality[UpRateIdx] <=
+					       0)) {
 					pEntry->CurrTxRateIndex = UpRateIdx;
 				}
 			}
 		} while (FALSE);
 
 		// if rate-up happen, clear all bad history of all TX rates
-		if (pEntry->CurrTxRateIndex > CurrRateIdx)
-		{
+		if (pEntry->CurrTxRateIndex > CurrRateIdx) {
 			pEntry->CurrTxRateStableTime = 0;
 			pEntry->TxRateUpPenalty = 0;
-			pEntry->LastSecTxRateChangeAction = 1; // rate UP
-			NdisZeroMemory(pEntry->TxQuality, sizeof(USHORT) * MAX_STEP_OF_TX_RATE_SWITCH);
-			NdisZeroMemory(pEntry->PER, sizeof(UCHAR) * MAX_STEP_OF_TX_RATE_SWITCH);
+			pEntry->LastSecTxRateChangeAction = 1;	// rate UP
+			NdisZeroMemory(pEntry->TxQuality,
+				       sizeof(USHORT) *
+				       MAX_STEP_OF_TX_RATE_SWITCH);
+			NdisZeroMemory(pEntry->PER,
+				       sizeof(UCHAR) *
+				       MAX_STEP_OF_TX_RATE_SWITCH);
 
 			//
 			// For TxRate fast train up
 			//
-			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning)
-			{
-				RTMPSetTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer, 100);
+			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning) {
+				RTMPSetTimer(&pAd->StaCfg.
+					     StaQuickResponeForRateUpTimer,
+					     100);
 
-				pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = TRUE;
+				pAd->StaCfg.
+				    StaQuickResponeForRateUpTimerRunning = TRUE;
 			}
 			bTxRateChanged = TRUE;
 		}
 		// if rate-down happen, only clear DownRate's bad history
-		else if (pEntry->CurrTxRateIndex < CurrRateIdx)
-		{
+		else if (pEntry->CurrTxRateIndex < CurrRateIdx) {
 			pEntry->CurrTxRateStableTime = 0;
-			pEntry->TxRateUpPenalty = 0;           // no penalty
-			pEntry->LastSecTxRateChangeAction = 2; // rate DOWN
+			pEntry->TxRateUpPenalty = 0;	// no penalty
+			pEntry->LastSecTxRateChangeAction = 2;	// rate DOWN
 			pEntry->TxQuality[pEntry->CurrTxRateIndex] = 0;
 			pEntry->PER[pEntry->CurrTxRateIndex] = 0;
 
 			//
 			// For TxRate fast train down
 			//
-			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning)
-			{
-				RTMPSetTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer, 100);
+			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning) {
+				RTMPSetTimer(&pAd->StaCfg.
+					     StaQuickResponeForRateUpTimer,
+					     100);
 
-				pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = TRUE;
+				pAd->StaCfg.
+				    StaQuickResponeForRateUpTimerRunning = TRUE;
 			}
 			bTxRateChanged = TRUE;
-		}
-		else
-		{
-			pEntry->LastSecTxRateChangeAction = 0; // rate no change
+		} else {
+			pEntry->LastSecTxRateChangeAction = 0;	// rate no change
 			bTxRateChanged = FALSE;
 		}
 
@@ -2312,21 +2315,28 @@ VOID MlmeDynamicTxRateSwitching(
 			UCHAR tmpTxRate;
 
 			// to fix tcp ack issue
-			if (!bTxRateChanged && (pAd->RalinkCounters.OneSecReceivedByteCount > (pAd->RalinkCounters.OneSecTransmittedByteCount * 5)))
-			{
+			if (!bTxRateChanged
+			    && (pAd->RalinkCounters.OneSecReceivedByteCount >
+				(pAd->RalinkCounters.
+				 OneSecTransmittedByteCount * 5))) {
 				tmpTxRate = DownRateIdx;
-				DBGPRINT_RAW(RT_DEBUG_TRACE,("DRS: Rx(%d) is 5 times larger than Tx(%d), use low rate (curr=%d, tmp=%d)\n",
-					pAd->RalinkCounters.OneSecReceivedByteCount, pAd->RalinkCounters.OneSecTransmittedByteCount, pEntry->CurrTxRateIndex, tmpTxRate));
-			}
-			else
-			{
+				DBGPRINT_RAW(RT_DEBUG_TRACE,
+					     ("DRS: Rx(%d) is 5 times larger than Tx(%d), use low rate (curr=%d, tmp=%d)\n",
+					      pAd->RalinkCounters.
+					      OneSecReceivedByteCount,
+					      pAd->RalinkCounters.
+					      OneSecTransmittedByteCount,
+					      pEntry->CurrTxRateIndex,
+					      tmpTxRate));
+			} else {
 				tmpTxRate = pEntry->CurrTxRateIndex;
 			}
 
-			pNextTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(tmpTxRate+1)*5];
+			pNextTxRate =
+			    (PRTMP_TX_RATE_SWITCH) & pTable[(tmpTxRate + 1) *
+							    5];
 		}
-		if (bTxRateChanged && pNextTxRate)
-		{
+		if (bTxRateChanged && pNextTxRate) {
 			MlmeSetTxRate(pAd, pEntry, pNextTxRate);
 		}
 		// reset all OneSecTx counters
@@ -2350,35 +2360,33 @@ VOID MlmeDynamicTxRateSwitching(
 
 	========================================================================
 */
-VOID StaQuickResponeForRateUpExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
-{
-	PRTMP_ADAPTER			pAd = (PRTMP_ADAPTER)FunctionContext;
-	UCHAR					UpRateIdx = 0, DownRateIdx = 0, CurrRateIdx = 0;
-	ULONG					TxTotalCnt;
-	ULONG					TxErrorRatio = 0;
-	BOOLEAN					bTxRateChanged; //, bUpgradeQuality = FALSE;
-	PRTMP_TX_RATE_SWITCH	pCurrTxRate, pNextTxRate = NULL;
-	PUCHAR					pTable;
-	UCHAR					TableSize = 0;
-	UCHAR					InitTxRateIdx = 0, TrainUp, TrainDown;
-	TX_STA_CNT1_STRUC		StaTx1;
-	TX_STA_CNT0_STRUC		TxStaCnt0;
-	CHAR					Rssi, ratio;
-	ULONG					TxRetransmit = 0, TxSuccess = 0, TxFailCount = 0;
-	MAC_TABLE_ENTRY			*pEntry;
-	ULONG					i;
+VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
+				  IN PVOID FunctionContext,
+				  IN PVOID SystemSpecific2,
+				  IN PVOID SystemSpecific3)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) FunctionContext;
+	UCHAR UpRateIdx = 0, DownRateIdx = 0, CurrRateIdx = 0;
+	ULONG TxTotalCnt;
+	ULONG TxErrorRatio = 0;
+	BOOLEAN bTxRateChanged;	//, bUpgradeQuality = FALSE;
+	PRTMP_TX_RATE_SWITCH pCurrTxRate, pNextTxRate = NULL;
+	PUCHAR pTable;
+	UCHAR TableSize = 0;
+	UCHAR InitTxRateIdx = 0, TrainUp, TrainDown;
+	TX_STA_CNT1_STRUC StaTx1;
+	TX_STA_CNT0_STRUC TxStaCnt0;
+	CHAR Rssi, ratio;
+	ULONG TxRetransmit = 0, TxSuccess = 0, TxFailCount = 0;
+	MAC_TABLE_ENTRY *pEntry;
+	ULONG i;
 
 	pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
 
-    //
-    // walk through MAC table, see if need to change AP's TX rate toward each entry
-    //
-	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++)
-	{
+	//
+	// walk through MAC table, see if need to change AP's TX rate toward each entry
+	//
+	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
 		pEntry = &pAd->MacTab.Content[i];
 
 		// check if this entry need to switch rate automatically
@@ -2387,51 +2395,48 @@ VOID StaQuickResponeForRateUpExec(
 
 		if (INFRA_ON(pAd) && (i == 1))
 			Rssi = RTMPMaxRssi(pAd,
-							   pAd->StaCfg.RssiSample.AvgRssi0,
-							   pAd->StaCfg.RssiSample.AvgRssi1,
-							   pAd->StaCfg.RssiSample.AvgRssi2);
+					   pAd->StaCfg.RssiSample.AvgRssi0,
+					   pAd->StaCfg.RssiSample.AvgRssi1,
+					   pAd->StaCfg.RssiSample.AvgRssi2);
 		else
 			Rssi = RTMPMaxRssi(pAd,
-							   pEntry->RssiSample.AvgRssi0,
-							   pEntry->RssiSample.AvgRssi1,
-							   pEntry->RssiSample.AvgRssi2);
+					   pEntry->RssiSample.AvgRssi0,
+					   pEntry->RssiSample.AvgRssi1,
+					   pEntry->RssiSample.AvgRssi2);
 
 		CurrRateIdx = pAd->CommonCfg.TxRateIndex;
 
-			MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize, &InitTxRateIdx);
+		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize,
+				      &InitTxRateIdx);
 
 		// decide the next upgrade rate and downgrade rate, if any
-		if ((CurrRateIdx > 0) && (CurrRateIdx < (TableSize - 1)))
-		{
+		if ((CurrRateIdx > 0) && (CurrRateIdx < (TableSize - 1))) {
 			UpRateIdx = CurrRateIdx + 1;
-			DownRateIdx = CurrRateIdx -1;
-		}
-		else if (CurrRateIdx == 0)
-		{
+			DownRateIdx = CurrRateIdx - 1;
+		} else if (CurrRateIdx == 0) {
 			UpRateIdx = CurrRateIdx + 1;
 			DownRateIdx = CurrRateIdx;
-		}
-		else if (CurrRateIdx == (TableSize - 1))
-		{
+		} else if (CurrRateIdx == (TableSize - 1)) {
 			UpRateIdx = CurrRateIdx;
 			DownRateIdx = CurrRateIdx - 1;
 		}
 
-		pCurrTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(CurrRateIdx+1)*5];
+		pCurrTxRate =
+		    (PRTMP_TX_RATE_SWITCH) & pTable[(CurrRateIdx + 1) * 5];
 
-		if ((Rssi > -65) && (pCurrTxRate->Mode >= MODE_HTMIX))
-		{
-			TrainUp		= (pCurrTxRate->TrainUp + (pCurrTxRate->TrainUp >> 1));
-			TrainDown	= (pCurrTxRate->TrainDown + (pCurrTxRate->TrainDown >> 1));
-		}
-		else
-		{
-			TrainUp		= pCurrTxRate->TrainUp;
-			TrainDown	= pCurrTxRate->TrainDown;
+		if ((Rssi > -65) && (pCurrTxRate->Mode >= MODE_HTMIX)) {
+			TrainUp =
+			    (pCurrTxRate->TrainUp +
+			     (pCurrTxRate->TrainUp >> 1));
+			TrainDown =
+			    (pCurrTxRate->TrainDown +
+			     (pCurrTxRate->TrainDown >> 1));
+		} else {
+			TrainUp = pCurrTxRate->TrainUp;
+			TrainDown = pCurrTxRate->TrainDown;
 		}
 
-		if (pAd->MacTab.Size == 1)
-		{
+		if (pAd->MacTab.Size == 1) {
 			// Update statistic counter
 			RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
 			RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
@@ -2441,52 +2446,64 @@ VOID StaQuickResponeForRateUpExec(
 			TxFailCount = TxStaCnt0.field.TxFailCount;
 			TxTotalCnt = TxRetransmit + TxSuccess + TxFailCount;
 
-			pAd->RalinkCounters.OneSecTxRetryOkCount += StaTx1.field.TxRetransmit;
-			pAd->RalinkCounters.OneSecTxNoRetryOkCount += StaTx1.field.TxSuccess;
-			pAd->RalinkCounters.OneSecTxFailCount += TxStaCnt0.field.TxFailCount;
-			pAd->WlanCounters.TransmittedFragmentCount.u.LowPart += StaTx1.field.TxSuccess;
-			pAd->WlanCounters.RetryCount.u.LowPart += StaTx1.field.TxRetransmit;
-			pAd->WlanCounters.FailedCount.u.LowPart += TxStaCnt0.field.TxFailCount;
+			pAd->RalinkCounters.OneSecTxRetryOkCount +=
+			    StaTx1.field.TxRetransmit;
+			pAd->RalinkCounters.OneSecTxNoRetryOkCount +=
+			    StaTx1.field.TxSuccess;
+			pAd->RalinkCounters.OneSecTxFailCount +=
+			    TxStaCnt0.field.TxFailCount;
+			pAd->WlanCounters.TransmittedFragmentCount.u.LowPart +=
+			    StaTx1.field.TxSuccess;
+			pAd->WlanCounters.RetryCount.u.LowPart +=
+			    StaTx1.field.TxRetransmit;
+			pAd->WlanCounters.FailedCount.u.LowPart +=
+			    TxStaCnt0.field.TxFailCount;
 
 			if (TxTotalCnt)
-				TxErrorRatio = ((TxRetransmit + TxFailCount) * 100) / TxTotalCnt;
-		}
-		else
-		{
+				TxErrorRatio =
+				    ((TxRetransmit +
+				      TxFailCount) * 100) / TxTotalCnt;
+		} else {
 			TxTotalCnt = pEntry->OneSecTxNoRetryOkCount +
-				 pEntry->OneSecTxRetryOkCount +
-				 pEntry->OneSecTxFailCount;
+			    pEntry->OneSecTxRetryOkCount +
+			    pEntry->OneSecTxFailCount;
 
 			if (TxTotalCnt)
-				TxErrorRatio = ((pEntry->OneSecTxRetryOkCount + pEntry->OneSecTxFailCount) * 100) / TxTotalCnt;
+				TxErrorRatio =
+				    ((pEntry->OneSecTxRetryOkCount +
+				      pEntry->OneSecTxFailCount) * 100) /
+				    TxTotalCnt;
 		}
 
-
 		//
 		// CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI
 		//         (criteria copied from RT2500 for Netopia case)
 		//
-		if (TxTotalCnt <= 12)
-		{
-			NdisZeroMemory(pAd->DrsCounters.TxQuality, sizeof(USHORT) * MAX_STEP_OF_TX_RATE_SWITCH);
-			NdisZeroMemory(pAd->DrsCounters.PER, sizeof(UCHAR) * MAX_STEP_OF_TX_RATE_SWITCH);
+		if (TxTotalCnt <= 12) {
+			NdisZeroMemory(pAd->DrsCounters.TxQuality,
+				       sizeof(USHORT) *
+				       MAX_STEP_OF_TX_RATE_SWITCH);
+			NdisZeroMemory(pAd->DrsCounters.PER,
+				       sizeof(UCHAR) *
+				       MAX_STEP_OF_TX_RATE_SWITCH);
 
-			if ((pAd->DrsCounters.LastSecTxRateChangeAction == 1) && (CurrRateIdx != DownRateIdx))
-			{
+			if ((pAd->DrsCounters.LastSecTxRateChangeAction == 1)
+			    && (CurrRateIdx != DownRateIdx)) {
 				pAd->CommonCfg.TxRateIndex = DownRateIdx;
-				pAd->DrsCounters.TxQuality[CurrRateIdx] = DRS_TX_QUALITY_WORST_BOUND;
-			}
-			else if ((pAd->DrsCounters.LastSecTxRateChangeAction == 2) && (CurrRateIdx != UpRateIdx))
-			{
+				pAd->DrsCounters.TxQuality[CurrRateIdx] =
+				    DRS_TX_QUALITY_WORST_BOUND;
+			} else
+			    if ((pAd->DrsCounters.LastSecTxRateChangeAction ==
+				 2) && (CurrRateIdx != UpRateIdx)) {
 				pAd->CommonCfg.TxRateIndex = UpRateIdx;
 			}
 
-			DBGPRINT_RAW(RT_DEBUG_TRACE,("QuickDRS: TxTotalCnt <= 15, train back to original rate \n"));
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("QuickDRS: TxTotalCnt <= 15, train back to original rate \n"));
 			return;
 		}
 
-		do
-		{
+		do {
 			ULONG OneSecTxNoRetryOKRationCount;
 
 			if (pAd->DrsCounters.LastTimeTxRateChangeAction == 0)
@@ -2495,65 +2512,72 @@ VOID StaQuickResponeForRateUpExec(
 				ratio = 4;
 
 			// downgrade TX quality if PER >= Rate-Down threshold
-			if (TxErrorRatio >= TrainDown)
-			{
-				pAd->DrsCounters.TxQuality[CurrRateIdx] = DRS_TX_QUALITY_WORST_BOUND;
+			if (TxErrorRatio >= TrainDown) {
+				pAd->DrsCounters.TxQuality[CurrRateIdx] =
+				    DRS_TX_QUALITY_WORST_BOUND;
 			}
 
-			pAd->DrsCounters.PER[CurrRateIdx] = (UCHAR)TxErrorRatio;
+			pAd->DrsCounters.PER[CurrRateIdx] =
+			    (UCHAR) TxErrorRatio;
 
 			OneSecTxNoRetryOKRationCount = (TxSuccess * ratio);
 
 			// perform DRS - consider TxRate Down first, then rate up.
-			if ((pAd->DrsCounters.LastSecTxRateChangeAction == 1) && (CurrRateIdx != DownRateIdx))
-			{
-				if ((pAd->DrsCounters.LastTxOkCount + 2) >= OneSecTxNoRetryOKRationCount)
-				{
-					pAd->CommonCfg.TxRateIndex = DownRateIdx;
-					pAd->DrsCounters.TxQuality[CurrRateIdx] = DRS_TX_QUALITY_WORST_BOUND;
+			if ((pAd->DrsCounters.LastSecTxRateChangeAction == 1)
+			    && (CurrRateIdx != DownRateIdx)) {
+				if ((pAd->DrsCounters.LastTxOkCount + 2) >=
+				    OneSecTxNoRetryOKRationCount) {
+					pAd->CommonCfg.TxRateIndex =
+					    DownRateIdx;
+					pAd->DrsCounters.
+					    TxQuality[CurrRateIdx] =
+					    DRS_TX_QUALITY_WORST_BOUND;
 
 				}
 
-			}
-			else if ((pAd->DrsCounters.LastSecTxRateChangeAction == 2) && (CurrRateIdx != UpRateIdx))
-			{
-				if ((TxErrorRatio >= 50) || (TxErrorRatio >= TrainDown))
-				{
+			} else
+			    if ((pAd->DrsCounters.LastSecTxRateChangeAction ==
+				 2) && (CurrRateIdx != UpRateIdx)) {
+				if ((TxErrorRatio >= 50)
+				    || (TxErrorRatio >= TrainDown)) {
 
-				}
-				else if ((pAd->DrsCounters.LastTxOkCount + 2) >= OneSecTxNoRetryOKRationCount)
-				{
+				} else if ((pAd->DrsCounters.LastTxOkCount + 2)
+					   >= OneSecTxNoRetryOKRationCount) {
 					pAd->CommonCfg.TxRateIndex = UpRateIdx;
 				}
 			}
-		}while (FALSE);
+		} while (FALSE);
 
 		// if rate-up happen, clear all bad history of all TX rates
-		if (pAd->CommonCfg.TxRateIndex > CurrRateIdx)
-		{
+		if (pAd->CommonCfg.TxRateIndex > CurrRateIdx) {
 			pAd->DrsCounters.TxRateUpPenalty = 0;
-			NdisZeroMemory(pAd->DrsCounters.TxQuality, sizeof(USHORT) * MAX_STEP_OF_TX_RATE_SWITCH);
-			NdisZeroMemory(pAd->DrsCounters.PER, sizeof(UCHAR) * MAX_STEP_OF_TX_RATE_SWITCH);
+			NdisZeroMemory(pAd->DrsCounters.TxQuality,
+				       sizeof(USHORT) *
+				       MAX_STEP_OF_TX_RATE_SWITCH);
+			NdisZeroMemory(pAd->DrsCounters.PER,
+				       sizeof(UCHAR) *
+				       MAX_STEP_OF_TX_RATE_SWITCH);
 			bTxRateChanged = TRUE;
 		}
 		// if rate-down happen, only clear DownRate's bad history
-		else if (pAd->CommonCfg.TxRateIndex < CurrRateIdx)
-		{
-			DBGPRINT_RAW(RT_DEBUG_TRACE,("QuickDRS: --TX rate from %d to %d \n", CurrRateIdx, pAd->CommonCfg.TxRateIndex));
-
-			pAd->DrsCounters.TxRateUpPenalty = 0;           // no penalty
-			pAd->DrsCounters.TxQuality[pAd->CommonCfg.TxRateIndex] = 0;
+		else if (pAd->CommonCfg.TxRateIndex < CurrRateIdx) {
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("QuickDRS: --TX rate from %d to %d \n",
+				      CurrRateIdx, pAd->CommonCfg.TxRateIndex));
+
+			pAd->DrsCounters.TxRateUpPenalty = 0;	// no penalty
+			pAd->DrsCounters.TxQuality[pAd->CommonCfg.TxRateIndex] =
+			    0;
 			pAd->DrsCounters.PER[pAd->CommonCfg.TxRateIndex] = 0;
 			bTxRateChanged = TRUE;
-		}
-		else
-		{
+		} else {
 			bTxRateChanged = FALSE;
 		}
 
-		pNextTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(pAd->CommonCfg.TxRateIndex+1)*5];
-		if (bTxRateChanged && pNextTxRate)
-		{
+		pNextTxRate =
+		    (PRTMP_TX_RATE_SWITCH) &
+		    pTable[(pAd->CommonCfg.TxRateIndex + 1) * 5];
+		if (bTxRateChanged && pNextTxRate) {
 			MlmeSetTxRate(pAd, pEntry, pNextTxRate);
 		}
 	}
@@ -2578,11 +2602,9 @@ VOID StaQuickResponeForRateUpExec(
 
 	==========================================================================
  */
-VOID MlmeCheckPsmChange(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG	Now32)
+VOID MlmeCheckPsmChange(IN PRTMP_ADAPTER pAd, IN ULONG Now32)
 {
-	ULONG	PowerMode;
+	ULONG PowerMode;
 
 	// condition -
 	// 1. Psm maybe ON only happen in INFRASTRUCTURE mode
@@ -2590,43 +2612,40 @@ VOID MlmeCheckPsmChange(
 	// 3. but current psm is not in PWR_SAVE
 	// 4. CNTL state machine is not doing SCANning
 	// 5. no TX SUCCESS event for the past 1-sec period
-		PowerMode = pAd->StaCfg.WindowsPowerMode;
+	PowerMode = pAd->StaCfg.WindowsPowerMode;
 
 	if (INFRA_ON(pAd) &&
-		(PowerMode != Ndis802_11PowerModeCAM) &&
-		(pAd->StaCfg.Psm == PWR_ACTIVE) &&
-//		(! RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-		(pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)&&
-		RTMP_TEST_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP)
-		 /*&&
-		(pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
-		(pAd->RalinkCounters.OneSecTxRetryOkCount == 0)*/)
-	{
-			NdisGetSystemUpTime(&pAd->Mlme.LastSendNULLpsmTime);
-			pAd->RalinkCounters.RxCountSinceLastNULL = 0;
+	    (PowerMode != Ndis802_11PowerModeCAM) &&
+	    (pAd->StaCfg.Psm == PWR_ACTIVE) &&
+//              (! RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+	    (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
+	    RTMP_TEST_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP)
+	    /*&&
+	       (pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
+	       (pAd->RalinkCounters.OneSecTxRetryOkCount == 0) */
+	    ) {
+		NdisGetSystemUpTime(&pAd->Mlme.LastSendNULLpsmTime);
+		pAd->RalinkCounters.RxCountSinceLastNULL = 0;
 		RTMP_SET_PSM_BIT(pAd, PWR_SAVE);
-			if (!(pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable))
-			{
-				RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, FALSE);
-			}
-			else
-			{
-				RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
-			}
+		if (!
+		    (pAd->CommonCfg.bAPSDCapable
+		     && pAd->CommonCfg.APEdcaParm.bAPSDCapable)) {
+			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, FALSE);
+		} else {
+			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
 		}
+	}
 }
 
 // IRQL = PASSIVE_LEVEL
 // IRQL = DISPATCH_LEVEL
-VOID MlmeSetPsmBit(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT psm)
+VOID MlmeSetPsmBit(IN PRTMP_ADAPTER pAd, IN USHORT psm)
 {
 	AUTO_RSP_CFG_STRUC csr4;
 
 	pAd->StaCfg.Psm = psm;
 	RTMP_IO_READ32(pAd, AUTO_RSP_CFG, &csr4.word);
-	csr4.field.AckCtsPsmBit = (psm == PWR_SAVE)? 1:0;
+	csr4.field.AckCtsPsmBit = (psm == PWR_SAVE) ? 1 : 0;
 	RTMP_IO_WRITE32(pAd, AUTO_RSP_CFG, csr4.word);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("MlmeSetPsmBit = %d\n", psm));
@@ -2651,29 +2670,26 @@ VOID MlmeSetPsmBit(
 		channel quality based on the most up-to-date information
 	==========================================================================
  */
-VOID MlmeCalculateChannelQuality(
-	IN PRTMP_ADAPTER pAd,
-	IN PMAC_TABLE_ENTRY pMacEntry,
-	IN ULONG Now32)
+VOID MlmeCalculateChannelQuality(IN PRTMP_ADAPTER pAd,
+				 IN PMAC_TABLE_ENTRY pMacEntry, IN ULONG Now32)
 {
 	ULONG TxOkCnt, TxCnt, TxPER, TxPRR;
 	ULONG RxCnt, RxPER;
 	UCHAR NorRssi;
-	CHAR  MaxRssi;
+	CHAR MaxRssi;
 	RSSI_SAMPLE *pRssiSample = NULL;
 	UINT32 OneSecTxNoRetryOkCount = 0;
 	UINT32 OneSecTxRetryOkCount = 0;
 	UINT32 OneSecTxFailCount = 0;
 	UINT32 OneSecRxOkCnt = 0;
 	UINT32 OneSecRxFcsErrCnt = 0;
-	ULONG ChannelQuality = 0;  // 0..100, Channel Quality Indication for Roaming
+	ULONG ChannelQuality = 0;	// 0..100, Channel Quality Indication for Roaming
 	ULONG BeaconLostTime = pAd->StaCfg.BeaconLostTime;
 
-
-	if (pAd->OpMode == OPMODE_STA)
-	{
+	if (pAd->OpMode == OPMODE_STA) {
 		pRssiSample = &pAd->StaCfg.RssiSample;
-		OneSecTxNoRetryOkCount = pAd->RalinkCounters.OneSecTxNoRetryOkCount;
+		OneSecTxNoRetryOkCount =
+		    pAd->RalinkCounters.OneSecTxNoRetryOkCount;
 		OneSecTxRetryOkCount = pAd->RalinkCounters.OneSecTxRetryOkCount;
 		OneSecTxFailCount = pAd->RalinkCounters.OneSecTxFailCount;
 		OneSecRxOkCnt = pAd->RalinkCounters.OneSecRxOkCnt;
@@ -2681,21 +2697,17 @@ VOID MlmeCalculateChannelQuality(
 	}
 
 	MaxRssi = RTMPMaxRssi(pAd, pRssiSample->LastRssi0,
-								pRssiSample->LastRssi1,
-								pRssiSample->LastRssi2);
+			      pRssiSample->LastRssi1, pRssiSample->LastRssi2);
 
 	//
 	// calculate TX packet error ratio and TX retry ratio - if too few TX samples, skip TX related statistics
 	//
 	TxOkCnt = OneSecTxNoRetryOkCount + OneSecTxRetryOkCount;
 	TxCnt = TxOkCnt + OneSecTxFailCount;
-	if (TxCnt < 5)
-	{
+	if (TxCnt < 5) {
 		TxPER = 0;
 		TxPRR = 0;
-	}
-	else
-	{
+	} else {
 		TxPER = (OneSecTxFailCount * 100) / TxCnt;
 		TxPRR = ((TxCnt - OneSecTxNoRetryOkCount) * 100) / TxCnt;
 	}
@@ -2712,16 +2724,13 @@ VOID MlmeCalculateChannelQuality(
 	//
 	// decide ChannelQuality based on: 1)last BEACON received time, 2)last RSSI, 3)TxPER, and 4)RxPER
 	//
-	if ((pAd->OpMode == OPMODE_STA) &&
-		INFRA_ON(pAd) &&
-		(OneSecTxNoRetryOkCount < 2) && // no heavy traffic
-		((pAd->StaCfg.LastBeaconRxTime + BeaconLostTime) < Now32))
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("BEACON lost > %ld msec with TxOkCnt=%ld -> CQI=0\n", BeaconLostTime, TxOkCnt));
+	if ((pAd->OpMode == OPMODE_STA) && INFRA_ON(pAd) && (OneSecTxNoRetryOkCount < 2) &&	// no heavy traffic
+	    ((pAd->StaCfg.LastBeaconRxTime + BeaconLostTime) < Now32)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("BEACON lost > %ld msec with TxOkCnt=%ld -> CQI=0\n",
+			  BeaconLostTime, TxOkCnt));
 		ChannelQuality = 0;
-	}
-	else
-	{
+	} else {
 		// Normalize Rssi
 		if (MaxRssi > -40)
 			NorRssi = 100;
@@ -2730,24 +2739,20 @@ VOID MlmeCalculateChannelQuality(
 		else
 			NorRssi = (MaxRssi + 90) * 2;
 
-		// ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER	 (RSSI 0..100), (TxPER 100..0), (RxPER 100..0)
+		// ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER        (RSSI 0..100), (TxPER 100..0), (RxPER 100..0)
 		ChannelQuality = (RSSI_WEIGHTING * NorRssi +
-								   TX_WEIGHTING * (100 - TxPRR) +
-								   RX_WEIGHTING* (100 - RxPER)) / 100;
+				  TX_WEIGHTING * (100 - TxPRR) +
+				  RX_WEIGHTING * (100 - RxPER)) / 100;
 	}
 
-
 	if (pAd->OpMode == OPMODE_STA)
-		pAd->Mlme.ChannelQuality = (ChannelQuality > 100) ? 100 : ChannelQuality;
-
+		pAd->Mlme.ChannelQuality =
+		    (ChannelQuality > 100) ? 100 : ChannelQuality;
 
 }
 
-
 // IRQL = DISPATCH_LEVEL
-VOID MlmeSetTxPreamble(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT TxPreamble)
+VOID MlmeSetTxPreamble(IN PRTMP_ADAPTER pAd, IN USHORT TxPreamble)
 {
 	AUTO_RSP_CFG_STRUC csr4;
 
@@ -2758,16 +2763,15 @@ VOID MlmeSetTxPreamble(
 	//TxPreamble = Rt802_11PreambleLong;
 
 	RTMP_IO_READ32(pAd, AUTO_RSP_CFG, &csr4.word);
-	if (TxPreamble == Rt802_11PreambleLong)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("MlmeSetTxPreamble (= LONG PREAMBLE)\n"));
+	if (TxPreamble == Rt802_11PreambleLong) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeSetTxPreamble (= LONG PREAMBLE)\n"));
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
 		csr4.field.AutoResponderPreamble = 0;
-	}
-	else
-	{
+	} else {
 		// NOTE: 1Mbps should always use long preamble
-		DBGPRINT(RT_DEBUG_TRACE, ("MlmeSetTxPreamble (= SHORT PREAMBLE)\n"));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeSetTxPreamble (= SHORT PREAMBLE)\n"));
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
 		csr4.field.AutoResponderPreamble = 1;
 	}
@@ -2782,64 +2786,53 @@ VOID MlmeSetTxPreamble(
     ==========================================================================
  */
 
-VOID UpdateBasicRateBitmap(
-    IN  PRTMP_ADAPTER   pAdapter)
+VOID UpdateBasicRateBitmap(IN PRTMP_ADAPTER pAdapter)
 {
-    INT  i, j;
-                  /* 1  2  5.5, 11,  6,  9, 12, 18, 24, 36, 48,  54 */
-    UCHAR rate[] = { 2, 4,  11, 22, 12, 18, 24, 36, 48, 72, 96, 108 };
-    UCHAR *sup_p = pAdapter->CommonCfg.SupRate;
-    UCHAR *ext_p = pAdapter->CommonCfg.ExtRate;
-    ULONG bitmap = pAdapter->CommonCfg.BasicRateBitmap;
+	INT i, j;
+	/* 1  2  5.5, 11,  6,  9, 12, 18, 24, 36, 48,  54 */
+	UCHAR rate[] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 };
+	UCHAR *sup_p = pAdapter->CommonCfg.SupRate;
+	UCHAR *ext_p = pAdapter->CommonCfg.ExtRate;
+	ULONG bitmap = pAdapter->CommonCfg.BasicRateBitmap;
 
-
-    /* if A mode, always use fix BasicRateBitMap */
-    //if (pAdapter->CommonCfg.Channel == PHY_11A)
+	/* if A mode, always use fix BasicRateBitMap */
+	//if (pAdapter->CommonCfg.Channel == PHY_11A)
 	if (pAdapter->CommonCfg.Channel > 14)
-        pAdapter->CommonCfg.BasicRateBitmap = 0x150; /* 6, 12, 24M */
-    /* End of if */
+		pAdapter->CommonCfg.BasicRateBitmap = 0x150;	/* 6, 12, 24M */
+	/* End of if */
 
-    if (pAdapter->CommonCfg.BasicRateBitmap > 4095)
-    {
-        /* (2 ^ MAX_LEN_OF_SUPPORTED_RATES) -1 */
-        return;
-    } /* End of if */
-
-    for(i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
-    {
-        sup_p[i] &= 0x7f;
-        ext_p[i] &= 0x7f;
-    } /* End of for */
-
-    for(i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
-    {
-        if (bitmap & (1 << i))
-        {
-            for(j=0; j<MAX_LEN_OF_SUPPORTED_RATES; j++)
-            {
-                if (sup_p[j] == rate[i])
-                    sup_p[j] |= 0x80;
-                /* End of if */
-            } /* End of for */
-
-            for(j=0; j<MAX_LEN_OF_SUPPORTED_RATES; j++)
-            {
-                if (ext_p[j] == rate[i])
-                    ext_p[j] |= 0x80;
-                /* End of if */
-            } /* End of for */
-        } /* End of if */
-    } /* End of for */
-} /* End of UpdateBasicRateBitmap */
+	if (pAdapter->CommonCfg.BasicRateBitmap > 4095) {
+		/* (2 ^ MAX_LEN_OF_SUPPORTED_RATES) -1 */
+		return;
+	}
+	/* End of if */
+	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
+		sup_p[i] &= 0x7f;
+		ext_p[i] &= 0x7f;
+	}			/* End of for */
+
+	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
+		if (bitmap & (1 << i)) {
+			for (j = 0; j < MAX_LEN_OF_SUPPORTED_RATES; j++) {
+				if (sup_p[j] == rate[i])
+					sup_p[j] |= 0x80;
+				/* End of if */
+			}	/* End of for */
+
+			for (j = 0; j < MAX_LEN_OF_SUPPORTED_RATES; j++) {
+				if (ext_p[j] == rate[i])
+					ext_p[j] |= 0x80;
+				/* End of if */
+			}	/* End of for */
+		}		/* End of if */
+	}			/* End of for */
+}				/* End of UpdateBasicRateBitmap */
 
 // IRQL = PASSIVE_LEVEL
 // IRQL = DISPATCH_LEVEL
 // bLinkUp is to identify the inital link speed.
 // TRUE indicates the rate update at linkup, we should not try to set the rate at 54Mbps.
-VOID MlmeUpdateTxRates(
-	IN PRTMP_ADAPTER 		pAd,
-	IN 	BOOLEAN		 		bLinkUp,
-	IN	UCHAR				apidx)
+VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 {
 	int i, num;
 	UCHAR Rate = RATE_6, MaxDesire = RATE_1, MaxSupport = RATE_1;
@@ -2847,52 +2840,86 @@ VOID MlmeUpdateTxRates(
 	ULONG BasicRateBitmap = 0;
 	UCHAR CurrBasicRate = RATE_1;
 	UCHAR *pSupRate, SupRateLen, *pExtRate, ExtRateLen;
-	PHTTRANSMIT_SETTING		pHtPhy = NULL;
-	PHTTRANSMIT_SETTING		pMaxHtPhy = NULL;
-	PHTTRANSMIT_SETTING		pMinHtPhy = NULL;
-	BOOLEAN 				*auto_rate_cur_p;
-	UCHAR					HtMcs = MCS_AUTO;
+	PHTTRANSMIT_SETTING pHtPhy = NULL;
+	PHTTRANSMIT_SETTING pMaxHtPhy = NULL;
+	PHTTRANSMIT_SETTING pMinHtPhy = NULL;
+	BOOLEAN *auto_rate_cur_p;
+	UCHAR HtMcs = MCS_AUTO;
 
 	// find max desired rate
 	UpdateBasicRateBitmap(pAd);
 
 	num = 0;
 	auto_rate_cur_p = NULL;
-	for (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
-	{
-		switch (pAd->CommonCfg.DesireRate[i] & 0x7f)
-		{
-			case 2:  Rate = RATE_1;   num++;   break;
-			case 4:  Rate = RATE_2;   num++;   break;
-			case 11: Rate = RATE_5_5; num++;   break;
-			case 22: Rate = RATE_11;  num++;   break;
-			case 12: Rate = RATE_6;   num++;   break;
-			case 18: Rate = RATE_9;   num++;   break;
-			case 24: Rate = RATE_12;  num++;   break;
-			case 36: Rate = RATE_18;  num++;   break;
-			case 48: Rate = RATE_24;  num++;   break;
-			case 72: Rate = RATE_36;  num++;   break;
-			case 96: Rate = RATE_48;  num++;   break;
-			case 108: Rate = RATE_54; num++;   break;
+	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
+		switch (pAd->CommonCfg.DesireRate[i] & 0x7f) {
+		case 2:
+			Rate = RATE_1;
+			num++;
+			break;
+		case 4:
+			Rate = RATE_2;
+			num++;
+			break;
+		case 11:
+			Rate = RATE_5_5;
+			num++;
+			break;
+		case 22:
+			Rate = RATE_11;
+			num++;
+			break;
+		case 12:
+			Rate = RATE_6;
+			num++;
+			break;
+		case 18:
+			Rate = RATE_9;
+			num++;
+			break;
+		case 24:
+			Rate = RATE_12;
+			num++;
+			break;
+		case 36:
+			Rate = RATE_18;
+			num++;
+			break;
+		case 48:
+			Rate = RATE_24;
+			num++;
+			break;
+		case 72:
+			Rate = RATE_36;
+			num++;
+			break;
+		case 96:
+			Rate = RATE_48;
+			num++;
+			break;
+		case 108:
+			Rate = RATE_54;
+			num++;
+			break;
 			//default: Rate = RATE_1;   break;
 		}
-		if (MaxDesire < Rate)  MaxDesire = Rate;
+		if (MaxDesire < Rate)
+			MaxDesire = Rate;
 	}
 
 //===========================================================================
 //===========================================================================
 	{
-		pHtPhy 		= &pAd->StaCfg.HTPhyMode;
-		pMaxHtPhy	= &pAd->StaCfg.MaxHTPhyMode;
-		pMinHtPhy	= &pAd->StaCfg.MinHTPhyMode;
+		pHtPhy = &pAd->StaCfg.HTPhyMode;
+		pMaxHtPhy = &pAd->StaCfg.MaxHTPhyMode;
+		pMinHtPhy = &pAd->StaCfg.MinHTPhyMode;
 
 		auto_rate_cur_p = &pAd->StaCfg.bAutoTxRateSwitch;
-		HtMcs 		= pAd->StaCfg.DesiredTransmitSetting.field.MCS;
+		HtMcs = pAd->StaCfg.DesiredTransmitSetting.field.MCS;
 
 		if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
-			(pAd->CommonCfg.PhyMode == PHY_11B) &&
-			(MaxDesire > RATE_11))
-		{
+		    (pAd->CommonCfg.PhyMode == PHY_11B) &&
+		    (MaxDesire > RATE_11)) {
 			MaxDesire = RATE_11;
 		}
 	}
@@ -2904,41 +2931,32 @@ VOID MlmeUpdateTxRates(
 
 	// Auto rate switching is enabled only if more than one DESIRED RATES are
 	// specified; otherwise disabled
-	if (num <= 1)
-	{
+	if (num <= 1) {
 		//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= FALSE;
+		//pAd->CommonCfg.bAutoTxRateSwitch      = FALSE;
 		*auto_rate_cur_p = FALSE;
-	}
-	else
-	{
+	} else {
 		//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= TRUE;
+		//pAd->CommonCfg.bAutoTxRateSwitch      = TRUE;
 		*auto_rate_cur_p = TRUE;
 	}
 
-	if (HtMcs != MCS_AUTO)
-	{
+	if (HtMcs != MCS_AUTO) {
 		//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= FALSE;
+		//pAd->CommonCfg.bAutoTxRateSwitch      = FALSE;
 		*auto_rate_cur_p = FALSE;
-	}
-	else
-	{
+	} else {
 		//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= TRUE;
+		//pAd->CommonCfg.bAutoTxRateSwitch      = TRUE;
 		*auto_rate_cur_p = TRUE;
 	}
 
-	if ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA))
-	{
+	if ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA)) {
 		pSupRate = &pAd->StaActive.SupRate[0];
 		pExtRate = &pAd->StaActive.ExtRate[0];
 		SupRateLen = pAd->StaActive.SupRateLen;
 		ExtRateLen = pAd->StaActive.ExtRateLen;
-	}
-	else
-	{
+	} else {
 		pSupRate = &pAd->CommonCfg.SupRate[0];
 		pExtRate = &pAd->CommonCfg.ExtRate[0];
 		SupRateLen = pAd->CommonCfg.SupRateLen;
@@ -2946,67 +2964,162 @@ VOID MlmeUpdateTxRates(
 	}
 
 	// find max supported rate
-	for (i=0; i<SupRateLen; i++)
-	{
-		switch (pSupRate[i] & 0x7f)
-		{
-			case 2:   Rate = RATE_1;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0001;	 break;
-			case 4:   Rate = RATE_2;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0002;	 break;
-			case 11:  Rate = RATE_5_5;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0004;	 break;
-			case 22:  Rate = RATE_11;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0008;	 break;
-			case 12:  Rate = RATE_6;	/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0010;  break;
-			case 18:  Rate = RATE_9;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0020;	 break;
-			case 24:  Rate = RATE_12;	/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0040;  break;
-			case 36:  Rate = RATE_18;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0080;	 break;
-			case 48:  Rate = RATE_24;	/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0100;  break;
-			case 72:  Rate = RATE_36;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0200;	 break;
-			case 96:  Rate = RATE_48;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0400;	 break;
-			case 108: Rate = RATE_54;	if (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0800;	 break;
-			default:  Rate = RATE_1;	break;
-		}
-		if (MaxSupport < Rate)	MaxSupport = Rate;
-
-		if (MinSupport > Rate) MinSupport = Rate;
-	}
-
-	for (i=0; i<ExtRateLen; i++)
-	{
-		switch (pExtRate[i] & 0x7f)
-		{
-			case 2:   Rate = RATE_1;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0001;	 break;
-			case 4:   Rate = RATE_2;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0002;	 break;
-			case 11:  Rate = RATE_5_5;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0004;	 break;
-			case 22:  Rate = RATE_11;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0008;	 break;
-			case 12:  Rate = RATE_6;	/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0010;  break;
-			case 18:  Rate = RATE_9;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0020;	 break;
-			case 24:  Rate = RATE_12;	/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0040;  break;
-			case 36:  Rate = RATE_18;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0080;	 break;
-			case 48:  Rate = RATE_24;	/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0100;  break;
-			case 72:  Rate = RATE_36;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0200;	 break;
-			case 96:  Rate = RATE_48;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0400;	 break;
-			case 108: Rate = RATE_54;	if (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0800;	 break;
-			default:  Rate = RATE_1;	break;
-		}
-		if (MaxSupport < Rate)	MaxSupport = Rate;
-
-		if (MinSupport > Rate) MinSupport = Rate;
-	}
-
-	RTMP_IO_WRITE32(pAd, LEGACY_BASIC_RATE, BasicRateBitmap);
-
-	// bug fix
+	for (i = 0; i < SupRateLen; i++) {
+		switch (pSupRate[i] & 0x7f) {
+		case 2:
+			Rate = RATE_1;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0001;
+			break;
+		case 4:
+			Rate = RATE_2;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0002;
+			break;
+		case 11:
+			Rate = RATE_5_5;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0004;
+			break;
+		case 22:
+			Rate = RATE_11;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0008;
+			break;
+		case 12:
+			Rate = RATE_6;	/*if (pSupRate[i] & 0x80) */
+			BasicRateBitmap |= 0x0010;
+			break;
+		case 18:
+			Rate = RATE_9;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0020;
+			break;
+		case 24:
+			Rate = RATE_12;	/*if (pSupRate[i] & 0x80) */
+			BasicRateBitmap |= 0x0040;
+			break;
+		case 36:
+			Rate = RATE_18;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0080;
+			break;
+		case 48:
+			Rate = RATE_24;	/*if (pSupRate[i] & 0x80) */
+			BasicRateBitmap |= 0x0100;
+			break;
+		case 72:
+			Rate = RATE_36;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0200;
+			break;
+		case 96:
+			Rate = RATE_48;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0400;
+			break;
+		case 108:
+			Rate = RATE_54;
+			if (pSupRate[i] & 0x80)
+				BasicRateBitmap |= 0x0800;
+			break;
+		default:
+			Rate = RATE_1;
+			break;
+		}
+		if (MaxSupport < Rate)
+			MaxSupport = Rate;
+
+		if (MinSupport > Rate)
+			MinSupport = Rate;
+	}
+
+	for (i = 0; i < ExtRateLen; i++) {
+		switch (pExtRate[i] & 0x7f) {
+		case 2:
+			Rate = RATE_1;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0001;
+			break;
+		case 4:
+			Rate = RATE_2;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0002;
+			break;
+		case 11:
+			Rate = RATE_5_5;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0004;
+			break;
+		case 22:
+			Rate = RATE_11;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0008;
+			break;
+		case 12:
+			Rate = RATE_6;	/*if (pExtRate[i] & 0x80) */
+			BasicRateBitmap |= 0x0010;
+			break;
+		case 18:
+			Rate = RATE_9;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0020;
+			break;
+		case 24:
+			Rate = RATE_12;	/*if (pExtRate[i] & 0x80) */
+			BasicRateBitmap |= 0x0040;
+			break;
+		case 36:
+			Rate = RATE_18;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0080;
+			break;
+		case 48:
+			Rate = RATE_24;	/*if (pExtRate[i] & 0x80) */
+			BasicRateBitmap |= 0x0100;
+			break;
+		case 72:
+			Rate = RATE_36;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0200;
+			break;
+		case 96:
+			Rate = RATE_48;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0400;
+			break;
+		case 108:
+			Rate = RATE_54;
+			if (pExtRate[i] & 0x80)
+				BasicRateBitmap |= 0x0800;
+			break;
+		default:
+			Rate = RATE_1;
+			break;
+		}
+		if (MaxSupport < Rate)
+			MaxSupport = Rate;
+
+		if (MinSupport > Rate)
+			MinSupport = Rate;
+	}
+
+	RTMP_IO_WRITE32(pAd, LEGACY_BASIC_RATE, BasicRateBitmap);
+
+	// bug fix
 	// pAd->CommonCfg.BasicRateBitmap = BasicRateBitmap;
 
 	// calculate the exptected ACK rate for each TX rate. This info is used to caculate
 	// the DURATION field of outgoing uniicast DATA/MGMT frame
-	for (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
-	{
+	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
 		if (BasicRateBitmap & (0x01 << i))
-			CurrBasicRate = (UCHAR)i;
+			CurrBasicRate = (UCHAR) i;
 		pAd->CommonCfg.ExpectedACKRate[i] = CurrBasicRate;
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("MlmeUpdateTxRates[MaxSupport = %d] = MaxDesire %d Mbps\n", RateIdToMbps[MaxSupport], RateIdToMbps[MaxDesire]));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("MlmeUpdateTxRates[MaxSupport = %d] = MaxDesire %d Mbps\n",
+		  RateIdToMbps[MaxSupport], RateIdToMbps[MaxDesire]));
 	// max tx rate = min {max desire rate, max supported rate}
 	if (MaxSupport < MaxDesire)
 		pAd->CommonCfg.MaxTxRate = MaxSupport;
@@ -3017,13 +3130,12 @@ VOID MlmeUpdateTxRates(
 	// 2003-07-31 john - 2500 doesn't have good sensitivity at high OFDM rates. to increase the success
 	// ratio of initial DHCP packet exchange, TX rate starts from a lower rate depending
 	// on average RSSI
-	//	 1. RSSI >= -70db, start at 54 Mbps (short distance)
-	//	 2. -70 > RSSI >= -75, start at 24 Mbps (mid distance)
-	//	 3. -75 > RSSI, start at 11 Mbps (long distance)
+	//       1. RSSI >= -70db, start at 54 Mbps (short distance)
+	//       2. -70 > RSSI >= -75, start at 24 Mbps (mid distance)
+	//       3. -75 > RSSI, start at 11 Mbps (long distance)
 	//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)/* &&
-	//	OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)*/)
-	if (*auto_rate_cur_p)
-	{
+	//      OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)*/)
+	if (*auto_rate_cur_p) {
 		short dbm = 0;
 
 		dbm = pAd->StaCfg.RssiSample.AvgRssi0 - pAd->BbpRssiToDbmDelta;
@@ -3043,113 +3155,132 @@ VOID MlmeUpdateTxRates(
 			pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;
 
 		pAd->CommonCfg.TxRateIndex = 0;
-	}
-	else
-	{
+	} else {
 		pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;
-		pHtPhy->field.MCS	= (pAd->CommonCfg.MaxTxRate > 3) ? (pAd->CommonCfg.MaxTxRate - 4) : pAd->CommonCfg.MaxTxRate;
-		pHtPhy->field.MODE	= (pAd->CommonCfg.MaxTxRate > 3) ? MODE_OFDM : MODE_CCK;
-
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.STBC	= pHtPhy->field.STBC;
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.ShortGI	= pHtPhy->field.ShortGI;
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MCS		= pHtPhy->field.MCS;
-		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE	= pHtPhy->field.MODE;
+		pHtPhy->field.MCS =
+		    (pAd->CommonCfg.MaxTxRate >
+		     3) ? (pAd->CommonCfg.MaxTxRate -
+			   4) : pAd->CommonCfg.MaxTxRate;
+		pHtPhy->field.MODE =
+		    (pAd->CommonCfg.MaxTxRate > 3) ? MODE_OFDM : MODE_CCK;
+
+		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.STBC =
+		    pHtPhy->field.STBC;
+		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.ShortGI =
+		    pHtPhy->field.ShortGI;
+		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MCS =
+		    pHtPhy->field.MCS;
+		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE =
+		    pHtPhy->field.MODE;
 	}
 
-	if (pAd->CommonCfg.TxRate <= RATE_11)
-	{
+	if (pAd->CommonCfg.TxRate <= RATE_11) {
 		pMaxHtPhy->field.MODE = MODE_CCK;
 		pMaxHtPhy->field.MCS = pAd->CommonCfg.TxRate;
 		pMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;
-	}
-	else
-	{
+	} else {
 		pMaxHtPhy->field.MODE = MODE_OFDM;
 		pMaxHtPhy->field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.TxRate];
-		if (pAd->CommonCfg.MinTxRate >= RATE_6 && (pAd->CommonCfg.MinTxRate <= RATE_54))
-			{pMinHtPhy->field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MinTxRate];}
-		else
-			{pMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;}
+		if (pAd->CommonCfg.MinTxRate >= RATE_6
+		    && (pAd->CommonCfg.MinTxRate <= RATE_54)) {
+			pMinHtPhy->field.MCS =
+			    OfdmRateToRxwiMCS[pAd->CommonCfg.MinTxRate];
+		} else {
+			pMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;
+		}
 	}
 
 	pHtPhy->word = (pMaxHtPhy->word);
-	if (bLinkUp && (pAd->OpMode == OPMODE_STA))
-	{
-			pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word = pHtPhy->word;
-			pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word = pMaxHtPhy->word;
-			pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word = pMinHtPhy->word;
-	}
-	else
-	{
-		switch (pAd->CommonCfg.PhyMode)
-		{
-			case PHY_11BG_MIXED:
-			case PHY_11B:
-			case PHY_11BGN_MIXED:
-				pAd->CommonCfg.MlmeRate = RATE_1;
-				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
-				pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
+	if (bLinkUp && (pAd->OpMode == OPMODE_STA)) {
+		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word = pHtPhy->word;
+		pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word =
+		    pMaxHtPhy->word;
+		pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word =
+		    pMinHtPhy->word;
+	} else {
+		switch (pAd->CommonCfg.PhyMode) {
+		case PHY_11BG_MIXED:
+		case PHY_11B:
+		case PHY_11BGN_MIXED:
+			pAd->CommonCfg.MlmeRate = RATE_1;
+			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
+			pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
 
-//#ifdef	WIFI_TEST
-				pAd->CommonCfg.RtsRate = RATE_11;
+//#ifdef        WIFI_TEST
+			pAd->CommonCfg.RtsRate = RATE_11;
 //#else
-//				pAd->CommonCfg.RtsRate = RATE_1;
+//                              pAd->CommonCfg.RtsRate = RATE_1;
 //#endif
-				break;
-			case PHY_11G:
-			case PHY_11A:
-			case PHY_11AGN_MIXED:
-			case PHY_11GN_MIXED:
-			case PHY_11N_2_4G:
-			case PHY_11AN_MIXED:
-			case PHY_11N_5G:
+			break;
+		case PHY_11G:
+		case PHY_11A:
+		case PHY_11AGN_MIXED:
+		case PHY_11GN_MIXED:
+		case PHY_11N_2_4G:
+		case PHY_11AN_MIXED:
+		case PHY_11N_5G:
+			pAd->CommonCfg.MlmeRate = RATE_6;
+			pAd->CommonCfg.RtsRate = RATE_6;
+			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+			pAd->CommonCfg.MlmeTransmit.field.MCS =
+			    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+			break;
+		case PHY_11ABG_MIXED:
+		case PHY_11ABGN_MIXED:
+			if (pAd->CommonCfg.Channel <= 14) {
+				pAd->CommonCfg.MlmeRate = RATE_1;
+				pAd->CommonCfg.RtsRate = RATE_1;
+				pAd->CommonCfg.MlmeTransmit.field.MODE =
+				    MODE_CCK;
+				pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
+			} else {
 				pAd->CommonCfg.MlmeRate = RATE_6;
 				pAd->CommonCfg.RtsRate = RATE_6;
-				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-				pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-				break;
-			case PHY_11ABG_MIXED:
-			case PHY_11ABGN_MIXED:
-				if (pAd->CommonCfg.Channel <= 14)
-	{
-					pAd->CommonCfg.MlmeRate = RATE_1;
-					pAd->CommonCfg.RtsRate = RATE_1;
-					pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
-					pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
-	}
-				else
-	{
-					pAd->CommonCfg.MlmeRate = RATE_6;
-					pAd->CommonCfg.RtsRate = RATE_6;
-					pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-					pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-	}
-				break;
-			default: // error
-				pAd->CommonCfg.MlmeRate = RATE_6;
-				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-				pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-				pAd->CommonCfg.RtsRate = RATE_1;
-				break;
+				pAd->CommonCfg.MlmeTransmit.field.MODE =
+				    MODE_OFDM;
+				pAd->CommonCfg.MlmeTransmit.field.MCS =
+				    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+			}
+			break;
+		default:	// error
+			pAd->CommonCfg.MlmeRate = RATE_6;
+			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+			pAd->CommonCfg.MlmeTransmit.field.MCS =
+			    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+			pAd->CommonCfg.RtsRate = RATE_1;
+			break;
 		}
 		//
 		// Keep Basic Mlme Rate.
 		//
-		pAd->MacTab.Content[MCAST_WCID].HTPhyMode.word = pAd->CommonCfg.MlmeTransmit.word;
+		pAd->MacTab.Content[MCAST_WCID].HTPhyMode.word =
+		    pAd->CommonCfg.MlmeTransmit.word;
 		if (pAd->CommonCfg.MlmeTransmit.field.MODE == MODE_OFDM)
-			pAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS = OfdmRateToRxwiMCS[RATE_24];
+			pAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS =
+			    OfdmRateToRxwiMCS[RATE_24];
 		else
-			pAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS = RATE_1;
+			pAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS =
+			    RATE_1;
 		pAd->CommonCfg.BasicMlmeRate = pAd->CommonCfg.MlmeRate;
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE, (" MlmeUpdateTxRates (MaxDesire=%d, MaxSupport=%d, MaxTxRate=%d, MinRate=%d, Rate Switching =%d)\n",
-			 RateIdToMbps[MaxDesire], RateIdToMbps[MaxSupport], RateIdToMbps[pAd->CommonCfg.MaxTxRate], RateIdToMbps[pAd->CommonCfg.MinTxRate],
-			 /*OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)*/*auto_rate_cur_p));
-	DBGPRINT(RT_DEBUG_TRACE, (" MlmeUpdateTxRates (TxRate=%d, RtsRate=%d, BasicRateBitmap=0x%04lx)\n",
-			 RateIdToMbps[pAd->CommonCfg.TxRate], RateIdToMbps[pAd->CommonCfg.RtsRate], BasicRateBitmap));
-	DBGPRINT(RT_DEBUG_TRACE, ("MlmeUpdateTxRates (MlmeTransmit=0x%x, MinHTPhyMode=%x, MaxHTPhyMode=0x%x, HTPhyMode=0x%x)\n",
-			 pAd->CommonCfg.MlmeTransmit.word, pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word ,pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word ,pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word ));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 (" MlmeUpdateTxRates (MaxDesire=%d, MaxSupport=%d, MaxTxRate=%d, MinRate=%d, Rate Switching =%d)\n",
+		  RateIdToMbps[MaxDesire], RateIdToMbps[MaxSupport],
+		  RateIdToMbps[pAd->CommonCfg.MaxTxRate],
+		  RateIdToMbps[pAd->CommonCfg.MinTxRate],
+		  /*OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) */
+		  *auto_rate_cur_p));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 (" MlmeUpdateTxRates (TxRate=%d, RtsRate=%d, BasicRateBitmap=0x%04lx)\n",
+		  RateIdToMbps[pAd->CommonCfg.TxRate],
+		  RateIdToMbps[pAd->CommonCfg.RtsRate], BasicRateBitmap));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("MlmeUpdateTxRates (MlmeTransmit=0x%x, MinHTPhyMode=%x, MaxHTPhyMode=0x%x, HTPhyMode=0x%x)\n",
+		  pAd->CommonCfg.MlmeTransmit.word,
+		  pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word,
+		  pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word,
+		  pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word));
 }
 
 /*
@@ -3164,59 +3295,60 @@ VOID MlmeUpdateTxRates(
 
 	==========================================================================
  */
-VOID MlmeUpdateHtTxRates(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR				apidx)
-{
-	UCHAR	StbcMcs; //j, StbcMcs, bitmask;
-	CHAR	i; // 3*3
-	RT_HT_CAPABILITY	*pRtHtCap = NULL;
-	RT_HT_PHY_INFO		*pActiveHtPhy = NULL;
-	ULONG		BasicMCS;
+VOID MlmeUpdateHtTxRates(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
+{
+	UCHAR StbcMcs;		//j, StbcMcs, bitmask;
+	CHAR i;			// 3*3
+	RT_HT_CAPABILITY *pRtHtCap = NULL;
+	RT_HT_PHY_INFO *pActiveHtPhy = NULL;
+	ULONG BasicMCS;
 	UCHAR j, bitmask;
-	PRT_HT_PHY_INFO			pDesireHtPhy = NULL;
-	PHTTRANSMIT_SETTING		pHtPhy = NULL;
-	PHTTRANSMIT_SETTING		pMaxHtPhy = NULL;
-	PHTTRANSMIT_SETTING		pMinHtPhy = NULL;
-	BOOLEAN					*auto_rate_cur_p;
+	PRT_HT_PHY_INFO pDesireHtPhy = NULL;
+	PHTTRANSMIT_SETTING pHtPhy = NULL;
+	PHTTRANSMIT_SETTING pMaxHtPhy = NULL;
+	PHTTRANSMIT_SETTING pMinHtPhy = NULL;
+	BOOLEAN *auto_rate_cur_p;
 
-	DBGPRINT(RT_DEBUG_TRACE,("MlmeUpdateHtTxRates===> \n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("MlmeUpdateHtTxRates===> \n"));
 
 	auto_rate_cur_p = NULL;
 
 	{
-		pDesireHtPhy	= &pAd->StaCfg.DesiredHtPhyInfo;
-		pActiveHtPhy	= &pAd->StaCfg.DesiredHtPhyInfo;
-		pHtPhy		= &pAd->StaCfg.HTPhyMode;
-		pMaxHtPhy	= &pAd->StaCfg.MaxHTPhyMode;
-		pMinHtPhy	= &pAd->StaCfg.MinHTPhyMode;
+		pDesireHtPhy = &pAd->StaCfg.DesiredHtPhyInfo;
+		pActiveHtPhy = &pAd->StaCfg.DesiredHtPhyInfo;
+		pHtPhy = &pAd->StaCfg.HTPhyMode;
+		pMaxHtPhy = &pAd->StaCfg.MaxHTPhyMode;
+		pMinHtPhy = &pAd->StaCfg.MinHTPhyMode;
 
 		auto_rate_cur_p = &pAd->StaCfg.bAutoTxRateSwitch;
 	}
 
-	if ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA))
-	{
+	if ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA)) {
 		if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
 			return;
 
 		pRtHtCap = &pAd->StaActive.SupportedHtPhy;
 		pActiveHtPhy = &pAd->StaActive.SupportedPhyInfo;
-		StbcMcs = (UCHAR)pAd->MlmeAux.AddHtInfo.AddHtInfo3.StbcMcs;
-		BasicMCS =pAd->MlmeAux.AddHtInfo.MCSSet[0]+(pAd->MlmeAux.AddHtInfo.MCSSet[1]<<8)+(StbcMcs<<16);
-		if ((pAd->CommonCfg.DesiredHtPhy.TxSTBC) && (pRtHtCap->RxSTBC) && (pAd->Antenna.field.TxPath == 2))
+		StbcMcs = (UCHAR) pAd->MlmeAux.AddHtInfo.AddHtInfo3.StbcMcs;
+		BasicMCS =
+		    pAd->MlmeAux.AddHtInfo.MCSSet[0] +
+		    (pAd->MlmeAux.AddHtInfo.MCSSet[1] << 8) + (StbcMcs << 16);
+		if ((pAd->CommonCfg.DesiredHtPhy.TxSTBC) && (pRtHtCap->RxSTBC)
+		    && (pAd->Antenna.field.TxPath == 2))
 			pMaxHtPhy->field.STBC = STBC_USE;
 		else
 			pMaxHtPhy->field.STBC = STBC_NONE;
-	}
-	else
-	{
+	} else {
 		if (pDesireHtPhy->bHtEnable == FALSE)
 			return;
 
 		pRtHtCap = &pAd->CommonCfg.DesiredHtPhy;
-		StbcMcs = (UCHAR)pAd->CommonCfg.AddHTInfo.AddHtInfo3.StbcMcs;
-		BasicMCS = pAd->CommonCfg.AddHTInfo.MCSSet[0]+(pAd->CommonCfg.AddHTInfo.MCSSet[1]<<8)+(StbcMcs<<16);
-		if ((pAd->CommonCfg.DesiredHtPhy.TxSTBC) && (pRtHtCap->RxSTBC) && (pAd->Antenna.field.TxPath == 2))
+		StbcMcs = (UCHAR) pAd->CommonCfg.AddHTInfo.AddHtInfo3.StbcMcs;
+		BasicMCS =
+		    pAd->CommonCfg.AddHTInfo.MCSSet[0] +
+		    (pAd->CommonCfg.AddHTInfo.MCSSet[1] << 8) + (StbcMcs << 16);
+		if ((pAd->CommonCfg.DesiredHtPhy.TxSTBC) && (pRtHtCap->RxSTBC)
+		    && (pAd->Antenna.field.TxPath == 2))
 			pMaxHtPhy->field.STBC = STBC_USE;
 		else
 			pMaxHtPhy->field.STBC = STBC_NONE;
@@ -3228,33 +3360,37 @@ VOID MlmeUpdateHtTxRates(
 	else
 		pMaxHtPhy->field.MODE = MODE_HTMIX;
 
-    if ((pAd->CommonCfg.DesiredHtPhy.ChannelWidth) && (pRtHtCap->ChannelWidth))
+	if ((pAd->CommonCfg.DesiredHtPhy.ChannelWidth)
+	    && (pRtHtCap->ChannelWidth))
 		pMaxHtPhy->field.BW = BW_40;
 	else
 		pMaxHtPhy->field.BW = BW_20;
 
-    if (pMaxHtPhy->field.BW == BW_20)
-		pMaxHtPhy->field.ShortGI = (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20 & pRtHtCap->ShortGIfor20);
+	if (pMaxHtPhy->field.BW == BW_20)
+		pMaxHtPhy->field.ShortGI =
+		    (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20 & pRtHtCap->
+		     ShortGIfor20);
 	else
-		pMaxHtPhy->field.ShortGI = (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40 & pRtHtCap->ShortGIfor40);
+		pMaxHtPhy->field.ShortGI =
+		    (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40 & pRtHtCap->
+		     ShortGIfor40);
 
-	if (pDesireHtPhy->MCSSet[4] != 0)
-	{
+	if (pDesireHtPhy->MCSSet[4] != 0) {
 		pMaxHtPhy->field.MCS = 32;
 	}
 
-	for (i=23; i>=0; i--) // 3*3
+	for (i = 23; i >= 0; i--)	// 3*3
 	{
-		j = i/8;
-		bitmask = (1<<(i-(j*8)));
+		j = i / 8;
+		bitmask = (1 << (i - (j * 8)));
 
-		if ((pActiveHtPhy->MCSSet[j] & bitmask) && (pDesireHtPhy->MCSSet[j] & bitmask))
-	{
+		if ((pActiveHtPhy->MCSSet[j] & bitmask)
+		    && (pDesireHtPhy->MCSSet[j] & bitmask)) {
 			pMaxHtPhy->field.MCS = i;
 			break;
-	}
+		}
 
-		if (i==0)
+		if (i == 0)
 			break;
 	}
 
@@ -3264,30 +3400,29 @@ VOID MlmeUpdateHtTxRates(
 	pMinHtPhy->field.STBC = 0;
 	pMinHtPhy->field.ShortGI = 0;
 	//If STA assigns fixed rate. update to fixed here.
-	if ( (pAd->OpMode == OPMODE_STA) && (pDesireHtPhy->MCSSet[0] != 0xff))
-	{
-		if (pDesireHtPhy->MCSSet[4] != 0)
-	{
+	if ((pAd->OpMode == OPMODE_STA) && (pDesireHtPhy->MCSSet[0] != 0xff)) {
+		if (pDesireHtPhy->MCSSet[4] != 0) {
 			pMaxHtPhy->field.MCS = 32;
 			pMinHtPhy->field.MCS = 32;
-			DBGPRINT(RT_DEBUG_TRACE,("MlmeUpdateHtTxRates<=== Use Fixed MCS = %d\n",pMinHtPhy->field.MCS));
-	}
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("MlmeUpdateHtTxRates<=== Use Fixed MCS = %d\n",
+				  pMinHtPhy->field.MCS));
+		}
 
-		for (i=23; (CHAR)i >= 0; i--) // 3*3
-	{
-			j = i/8;
-			bitmask = (1<<(i-(j*8)));
-			if ( (pDesireHtPhy->MCSSet[j] & bitmask) && (pActiveHtPhy->MCSSet[j] & bitmask))
+		for (i = 23; (CHAR) i >= 0; i--)	// 3*3
 		{
+			j = i / 8;
+			bitmask = (1 << (i - (j * 8)));
+			if ((pDesireHtPhy->MCSSet[j] & bitmask)
+			    && (pActiveHtPhy->MCSSet[j] & bitmask)) {
 				pMaxHtPhy->field.MCS = i;
 				pMinHtPhy->field.MCS = i;
 				break;
-		}
-			if (i==0)
+			}
+			if (i == 0)
 				break;
+		}
 	}
-	}
-
 
 	// Decide ht rate
 	pHtPhy->field.STBC = pMaxHtPhy->field.STBC;
@@ -3302,16 +3437,17 @@ VOID MlmeUpdateHtTxRates(
 	else
 		*auto_rate_cur_p = TRUE;
 
-	DBGPRINT(RT_DEBUG_TRACE, (" MlmeUpdateHtTxRates<---.AMsduSize = %d  \n", pAd->CommonCfg.DesiredHtPhy.AmsduSize ));
-	DBGPRINT(RT_DEBUG_TRACE,("TX: MCS[0] = %x (choose %d), BW = %d, ShortGI = %d, MODE = %d,  \n", pActiveHtPhy->MCSSet[0],pHtPhy->field.MCS,
-		pHtPhy->field.BW, pHtPhy->field.ShortGI, pHtPhy->field.MODE));
-	DBGPRINT(RT_DEBUG_TRACE,("MlmeUpdateHtTxRates<=== \n"));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 (" MlmeUpdateHtTxRates<---.AMsduSize = %d  \n",
+		  pAd->CommonCfg.DesiredHtPhy.AmsduSize));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("TX: MCS[0] = %x (choose %d), BW = %d, ShortGI = %d, MODE = %d,  \n",
+		  pActiveHtPhy->MCSSet[0], pHtPhy->field.MCS, pHtPhy->field.BW,
+		  pHtPhy->field.ShortGI, pHtPhy->field.MODE));
+	DBGPRINT(RT_DEBUG_TRACE, ("MlmeUpdateHtTxRates<=== \n"));
 }
 
-
-VOID BATableInit(
-	IN PRTMP_ADAPTER pAd,
-    IN BA_TABLE *Tab)
+VOID BATableInit(IN PRTMP_ADAPTER pAd, IN BA_TABLE * Tab)
 {
 	int i;
 
@@ -3319,27 +3455,23 @@ VOID BATableInit(
 	Tab->numAsRecipient = 0;
 	Tab->numDoneOriginator = 0;
 	NdisAllocateSpinLock(&pAd->BATabLock);
-	for (i = 0; i < MAX_LEN_OF_BA_REC_TABLE; i++)
-	{
+	for (i = 0; i < MAX_LEN_OF_BA_REC_TABLE; i++) {
 		Tab->BARecEntry[i].REC_BA_Status = Recipient_NONE;
 		NdisAllocateSpinLock(&(Tab->BARecEntry[i].RxReRingLock));
 	}
-	for (i = 0; i < MAX_LEN_OF_BA_ORI_TABLE; i++)
-	{
+	for (i = 0; i < MAX_LEN_OF_BA_ORI_TABLE; i++) {
 		Tab->BAOriEntry[i].ORI_BA_Status = Originator_NONE;
 	}
 }
 
 // IRQL = DISPATCH_LEVEL
-VOID MlmeRadioOff(
-	IN PRTMP_ADAPTER pAd)
+VOID MlmeRadioOff(IN PRTMP_ADAPTER pAd)
 {
 	RTMP_MLME_RADIO_OFF(pAd);
 }
 
 // IRQL = DISPATCH_LEVEL
-VOID MlmeRadioOn(
-	IN PRTMP_ADAPTER pAd)
+VOID MlmeRadioOn(IN PRTMP_ADAPTER pAd)
 {
 	RTMP_MLME_RADIO_ON(pAd);
 }
@@ -3348,7 +3480,6 @@ VOID MlmeRadioOn(
 // bss_table.c
 // ===========================================================================================
 
-
 /*! \brief initialize BSS table
  *	\param p_tab pointer to the table
  *	\return none
@@ -3359,21 +3490,18 @@ VOID MlmeRadioOn(
  IRQL = DISPATCH_LEVEL
 
  */
-VOID BssTableInit(
-	IN BSS_TABLE *Tab)
+VOID BssTableInit(IN BSS_TABLE * Tab)
 {
 	int i;
 
 	Tab->BssNr = 0;
-    Tab->BssOverlapNr = 0;
-	for (i = 0; i < MAX_LEN_OF_BSS_TABLE; i++)
-			{
+	Tab->BssOverlapNr = 0;
+	for (i = 0; i < MAX_LEN_OF_BSS_TABLE; i++) {
 		NdisZeroMemory(&Tab->BssEntry[i], sizeof(BSS_ENTRY));
 		Tab->BssEntry[i].Rssi = -127;	// initial the rssi as a minimum value
 	}
 }
 
-
 /*! \brief search the BSS table by SSID
  *	\param p_tab pointer to the bss table
  *	\param ssid SSID string
@@ -3385,116 +3513,102 @@ VOID BssTableInit(
  IRQL = DISPATCH_LEVEL
 
  */
-ULONG BssTableSearch(
-	IN BSS_TABLE *Tab,
-	IN PUCHAR	 pBssid,
-	IN UCHAR	 Channel)
+ULONG BssTableSearch(IN BSS_TABLE * Tab, IN PUCHAR pBssid, IN UCHAR Channel)
 {
 	UCHAR i;
 
-	for (i = 0; i < Tab->BssNr; i++)
-	{
+	for (i = 0; i < Tab->BssNr; i++) {
 		//
 		// Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G.
 		// We should distinguish this case.
 		//
 		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
-			 ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
-			MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid))
-		{
+		     ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
+		    MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid)) {
 			return i;
 		}
 	}
-	return (ULONG)BSS_NOT_FOUND;
+	return (ULONG) BSS_NOT_FOUND;
 }
 
-ULONG BssSsidTableSearch(
-	IN BSS_TABLE *Tab,
-	IN PUCHAR	 pBssid,
-	IN PUCHAR	 pSsid,
-	IN UCHAR	 SsidLen,
-	IN UCHAR	 Channel)
+ULONG BssSsidTableSearch(IN BSS_TABLE * Tab,
+			 IN PUCHAR pBssid,
+			 IN PUCHAR pSsid, IN UCHAR SsidLen, IN UCHAR Channel)
 {
 	UCHAR i;
 
-	for (i = 0; i < Tab->BssNr; i++)
-	{
+	for (i = 0; i < Tab->BssNr; i++) {
 		//
 		// Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G.
 		// We should distinguish this case.
 		//
 		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
-			 ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
-			MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid) &&
-			SSID_EQUAL(pSsid, SsidLen, Tab->BssEntry[i].Ssid, Tab->BssEntry[i].SsidLen))
-		{
+		     ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
+		    MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid) &&
+		    SSID_EQUAL(pSsid, SsidLen, Tab->BssEntry[i].Ssid,
+			       Tab->BssEntry[i].SsidLen)) {
 			return i;
 		}
 	}
-	return (ULONG)BSS_NOT_FOUND;
+	return (ULONG) BSS_NOT_FOUND;
 }
 
-ULONG BssTableSearchWithSSID(
-	IN BSS_TABLE *Tab,
-	IN PUCHAR	 Bssid,
-	IN PUCHAR	 pSsid,
-	IN UCHAR	 SsidLen,
-	IN UCHAR	 Channel)
+ULONG BssTableSearchWithSSID(IN BSS_TABLE * Tab,
+			     IN PUCHAR Bssid,
+			     IN PUCHAR pSsid,
+			     IN UCHAR SsidLen, IN UCHAR Channel)
 {
 	UCHAR i;
 
-	for (i = 0; i < Tab->BssNr; i++)
-	{
+	for (i = 0; i < Tab->BssNr; i++) {
 		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
-			((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
-			MAC_ADDR_EQUAL(&(Tab->BssEntry[i].Bssid), Bssid) &&
-			(SSID_EQUAL(pSsid, SsidLen, Tab->BssEntry[i].Ssid, Tab->BssEntry[i].SsidLen) ||
-			(NdisEqualMemory(pSsid, ZeroSsid, SsidLen)) ||
-			(NdisEqualMemory(Tab->BssEntry[i].Ssid, ZeroSsid, Tab->BssEntry[i].SsidLen))))
-		{
+		     ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
+		    MAC_ADDR_EQUAL(&(Tab->BssEntry[i].Bssid), Bssid) &&
+		    (SSID_EQUAL
+		     (pSsid, SsidLen, Tab->BssEntry[i].Ssid,
+		      Tab->BssEntry[i].SsidLen)
+		     || (NdisEqualMemory(pSsid, ZeroSsid, SsidLen))
+		     ||
+		     (NdisEqualMemory
+		      (Tab->BssEntry[i].Ssid, ZeroSsid,
+		       Tab->BssEntry[i].SsidLen)))) {
 			return i;
 		}
 	}
-	return (ULONG)BSS_NOT_FOUND;
+	return (ULONG) BSS_NOT_FOUND;
 }
 
-
-ULONG BssSsidTableSearchBySSID(
-	IN BSS_TABLE *Tab,
-	IN PUCHAR	 pSsid,
-	IN UCHAR	 SsidLen)
+ULONG BssSsidTableSearchBySSID(IN BSS_TABLE * Tab,
+			       IN PUCHAR pSsid, IN UCHAR SsidLen)
 {
 	UCHAR i;
 
-	for (i = 0; i < Tab->BssNr; i++)
-	{
-		if (SSID_EQUAL(pSsid, SsidLen, Tab->BssEntry[i].Ssid, Tab->BssEntry[i].SsidLen))
-		{
+	for (i = 0; i < Tab->BssNr; i++) {
+		if (SSID_EQUAL
+		    (pSsid, SsidLen, Tab->BssEntry[i].Ssid,
+		     Tab->BssEntry[i].SsidLen)) {
 			return i;
+		}
 	}
-	}
-	return (ULONG)BSS_NOT_FOUND;
+	return (ULONG) BSS_NOT_FOUND;
 }
 
-
 // IRQL = DISPATCH_LEVEL
-VOID BssTableDeleteEntry(
-	IN OUT	BSS_TABLE *Tab,
-	IN		PUCHAR	  pBssid,
-	IN		UCHAR	  Channel)
+VOID BssTableDeleteEntry(IN OUT BSS_TABLE * Tab,
+			 IN PUCHAR pBssid, IN UCHAR Channel)
 {
 	UCHAR i, j;
 
-	for (i = 0; i < Tab->BssNr; i++)
-	{
+	for (i = 0; i < Tab->BssNr; i++) {
 		if ((Tab->BssEntry[i].Channel == Channel) &&
-			(MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid)))
-		{
-			for (j = i; j < Tab->BssNr - 1; j++)
-			{
-				NdisMoveMemory(&(Tab->BssEntry[j]), &(Tab->BssEntry[j + 1]), sizeof(BSS_ENTRY));
+		    (MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid))) {
+			for (j = i; j < Tab->BssNr - 1; j++) {
+				NdisMoveMemory(&(Tab->BssEntry[j]),
+					       &(Tab->BssEntry[j + 1]),
+					       sizeof(BSS_ENTRY));
 			}
-			NdisZeroMemory(&(Tab->BssEntry[Tab->BssNr - 1]), sizeof(BSS_ENTRY));
+			NdisZeroMemory(&(Tab->BssEntry[Tab->BssNr - 1]),
+				       sizeof(BSS_ENTRY));
 			Tab->BssNr -= 1;
 			return;
 		}
@@ -3510,21 +3624,20 @@ VOID BssTableDeleteEntry(
 	// IRQL = DISPATCH_LEVEL
 	========================================================================
 */
-VOID BATableDeleteORIEntry(
-	IN OUT	PRTMP_ADAPTER pAd,
-	IN		BA_ORI_ENTRY	*pBAORIEntry)
+VOID BATableDeleteORIEntry(IN OUT PRTMP_ADAPTER pAd,
+			   IN BA_ORI_ENTRY * pBAORIEntry)
 {
 
-	if (pBAORIEntry->ORI_BA_Status != Originator_NONE)
-	{
+	if (pBAORIEntry->ORI_BA_Status != Originator_NONE) {
 		NdisAcquireSpinLock(&pAd->BATabLock);
-		if (pBAORIEntry->ORI_BA_Status == Originator_Done)
-		{
+		if (pBAORIEntry->ORI_BA_Status == Originator_Done) {
 			pAd->BATable.numAsOriginator -= 1;
-			DBGPRINT(RT_DEBUG_TRACE, ("BATableDeleteORIEntry numAsOriginator= %ld\n", pAd->BATable.numAsRecipient));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BATableDeleteORIEntry numAsOriginator= %ld\n",
+				  pAd->BATable.numAsRecipient));
 			// Erase Bitmap flag.
 		}
-		pAd->MacTab.Content[pBAORIEntry->Wcid].TXBAbitmap &= (~(1<<(pBAORIEntry->TID) ));	// If STA mode,  erase flag here
+		pAd->MacTab.Content[pBAORIEntry->Wcid].TXBAbitmap &= (~(1 << (pBAORIEntry->TID)));	// If STA mode,  erase flag here
 		pAd->MacTab.Content[pBAORIEntry->Wcid].BAOriWcidArray[pBAORIEntry->TID] = 0;	// If STA mode,  erase flag here
 		pBAORIEntry->ORI_BA_Status = Originator_NONE;
 		pBAORIEntry->Token = 1;
@@ -3542,69 +3655,45 @@ VOID BATableDeleteORIEntry(
  IRQL = DISPATCH_LEVEL
 
  */
-VOID BssEntrySet(
-	IN PRTMP_ADAPTER pAd,
-	OUT BSS_ENTRY *pBss,
-	IN PUCHAR pBssid,
-	IN CHAR Ssid[],
-	IN UCHAR SsidLen,
-	IN UCHAR BssType,
-	IN USHORT BeaconPeriod,
-	IN PCF_PARM pCfParm,
-	IN USHORT AtimWin,
-	IN USHORT CapabilityInfo,
-	IN UCHAR SupRate[],
-	IN UCHAR SupRateLen,
-	IN UCHAR ExtRate[],
-	IN UCHAR ExtRateLen,
-	IN HT_CAPABILITY_IE *pHtCapability,
-	IN ADD_HT_INFO_IE *pAddHtInfo,	// AP might use this additional ht info IE
-	IN UCHAR			HtCapabilityLen,
-	IN UCHAR			AddHtInfoLen,
-	IN UCHAR			NewExtChanOffset,
-	IN UCHAR Channel,
-	IN CHAR Rssi,
-	IN LARGE_INTEGER TimeStamp,
-	IN UCHAR CkipFlag,
-	IN PEDCA_PARM pEdcaParm,
-	IN PQOS_CAPABILITY_PARM pQosCapability,
-	IN PQBSS_LOAD_PARM pQbssLoad,
-	IN USHORT LengthVIE,
-	IN PNDIS_802_11_VARIABLE_IEs pVIE)
+VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, IN CHAR Ssid[], IN UCHAR SsidLen, IN UCHAR BssType, IN USHORT BeaconPeriod, IN PCF_PARM pCfParm, IN USHORT AtimWin, IN USHORT CapabilityInfo, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN HT_CAPABILITY_IE * pHtCapability, IN ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+		 IN UCHAR HtCapabilityLen,
+		 IN UCHAR AddHtInfoLen,
+		 IN UCHAR NewExtChanOffset,
+		 IN UCHAR Channel,
+		 IN CHAR Rssi,
+		 IN LARGE_INTEGER TimeStamp,
+		 IN UCHAR CkipFlag,
+		 IN PEDCA_PARM pEdcaParm,
+		 IN PQOS_CAPABILITY_PARM pQosCapability,
+		 IN PQBSS_LOAD_PARM pQbssLoad,
+		 IN USHORT LengthVIE, IN PNDIS_802_11_VARIABLE_IEs pVIE)
 {
 	COPY_MAC_ADDR(pBss->Bssid, pBssid);
 	// Default Hidden SSID to be TRUE, it will be turned to FALSE after coping SSID
 	pBss->Hidden = 1;
-	if (SsidLen > 0)
-	{
+	if (SsidLen > 0) {
 		// For hidden SSID AP, it might send beacon with SSID len equal to 0
 		// Or send beacon /probe response with SSID len matching real SSID length,
 		// but SSID is all zero. such as "00-00-00-00" with length 4.
 		// We have to prevent this case overwrite correct table
-		if (NdisEqualMemory(Ssid, ZeroSsid, SsidLen) == 0)
-		{
-		    NdisZeroMemory(pBss->Ssid, MAX_LEN_OF_SSID);
+		if (NdisEqualMemory(Ssid, ZeroSsid, SsidLen) == 0) {
+			NdisZeroMemory(pBss->Ssid, MAX_LEN_OF_SSID);
 			NdisMoveMemory(pBss->Ssid, Ssid, SsidLen);
 			pBss->SsidLen = SsidLen;
 			pBss->Hidden = 0;
 		}
-	}
-	else
+	} else
 		pBss->SsidLen = 0;
 	pBss->BssType = BssType;
 	pBss->BeaconPeriod = BeaconPeriod;
-	if (BssType == BSS_INFRA)
-	{
-		if (pCfParm->bValid)
-		{
+	if (BssType == BSS_INFRA) {
+		if (pCfParm->bValid) {
 			pBss->CfpCount = pCfParm->CfpCount;
 			pBss->CfpPeriod = pCfParm->CfpPeriod;
 			pBss->CfpMaxDuration = pCfParm->CfpMaxDuration;
 			pBss->CfpDurRemaining = pCfParm->CfpDurRemaining;
 		}
-	}
-	else
-	{
+	} else {
 		pBss->AtimWin = AtimWin;
 	}
 
@@ -3616,7 +3705,8 @@ VOID BssEntrySet(
 	if (SupRateLen <= MAX_LEN_OF_SUPPORTED_RATES)
 		NdisMoveMemory(pBss->SupRate, SupRate, SupRateLen);
 	else
-		NdisMoveMemory(pBss->SupRate, SupRate, MAX_LEN_OF_SUPPORTED_RATES);
+		NdisMoveMemory(pBss->SupRate, SupRate,
+			       MAX_LEN_OF_SUPPORTED_RATES);
 	pBss->SupRateLen = SupRateLen;
 	ASSERT(ExtRateLen <= MAX_LEN_OF_SUPPORTED_RATES);
 	NdisMoveMemory(pBss->ExtRate, ExtRate, ExtRateLen);
@@ -3634,35 +3724,39 @@ VOID BssEntrySet(
 	pBss->FixIEs.Capabilities = CapabilityInfo;
 
 	// New for microsoft Variable IEs
-	if (LengthVIE != 0)
-	{
+	if (LengthVIE != 0) {
 		pBss->VarIELen = LengthVIE;
 		NdisMoveMemory(pBss->VarIEs, pVIE, pBss->VarIELen);
-	}
-	else
-	{
+	} else {
 		pBss->VarIELen = 0;
 	}
 
 	pBss->AddHtInfoLen = 0;
 	pBss->HtCapabilityLen = 0;
-	if (HtCapabilityLen> 0)
-	{
+	if (HtCapabilityLen > 0) {
 		pBss->HtCapabilityLen = HtCapabilityLen;
-		NdisMoveMemory(&pBss->HtCapability, pHtCapability, HtCapabilityLen);
-		if (AddHtInfoLen > 0)
-		{
+		NdisMoveMemory(&pBss->HtCapability, pHtCapability,
+			       HtCapabilityLen);
+		if (AddHtInfoLen > 0) {
 			pBss->AddHtInfoLen = AddHtInfoLen;
-			NdisMoveMemory(&pBss->AddHtInfo, pAddHtInfo, AddHtInfoLen);
+			NdisMoveMemory(&pBss->AddHtInfo, pAddHtInfo,
+				       AddHtInfoLen);
 
-				if ((pAddHtInfo->ControlChan > 2)&& (pAddHtInfo->AddHtInfo.ExtChanOffset == EXTCHA_BELOW) && (pHtCapability->HtCapInfo.ChannelWidth == BW_40))
-				{
-					pBss->CentralChannel = pAddHtInfo->ControlChan - 2;
-		}
-				else if ((pAddHtInfo->AddHtInfo.ExtChanOffset == EXTCHA_ABOVE) && (pHtCapability->HtCapInfo.ChannelWidth == BW_40))
-		{
-						pBss->CentralChannel = pAddHtInfo->ControlChan + 2;
-				}
+			if ((pAddHtInfo->ControlChan > 2)
+			    && (pAddHtInfo->AddHtInfo.ExtChanOffset ==
+				EXTCHA_BELOW)
+			    && (pHtCapability->HtCapInfo.ChannelWidth ==
+				BW_40)) {
+				pBss->CentralChannel =
+				    pAddHtInfo->ControlChan - 2;
+			} else
+			    if ((pAddHtInfo->AddHtInfo.ExtChanOffset ==
+				 EXTCHA_ABOVE)
+				&& (pHtCapability->HtCapInfo.ChannelWidth ==
+				    BW_40)) {
+				pBss->CentralChannel =
+				    pAddHtInfo->ControlChan + 2;
+			}
 		}
 	}
 
@@ -3674,53 +3768,51 @@ VOID BssEntrySet(
 	else
 		pBss->EdcaParm.bValid = FALSE;
 	if (pQosCapability)
-		NdisMoveMemory(&pBss->QosCapability, pQosCapability, sizeof(QOS_CAPABILITY_PARM));
+		NdisMoveMemory(&pBss->QosCapability, pQosCapability,
+			       sizeof(QOS_CAPABILITY_PARM));
 	else
 		pBss->QosCapability.bValid = FALSE;
 	if (pQbssLoad)
-		NdisMoveMemory(&pBss->QbssLoad, pQbssLoad, sizeof(QBSS_LOAD_PARM));
+		NdisMoveMemory(&pBss->QbssLoad, pQbssLoad,
+			       sizeof(QBSS_LOAD_PARM));
 	else
 		pBss->QbssLoad.bValid = FALSE;
 
 	{
-		PEID_STRUCT     pEid;
-		USHORT          Length = 0;
-
+		PEID_STRUCT pEid;
+		USHORT Length = 0;
 
 		NdisZeroMemory(&pBss->WpaIE.IE[0], MAX_CUSTOM_LEN);
 		NdisZeroMemory(&pBss->RsnIE.IE[0], MAX_CUSTOM_LEN);
 		pEid = (PEID_STRUCT) pVIE;
-		while ((Length + 2 + (USHORT)pEid->Len) <= LengthVIE)
-	{
-			switch(pEid->Eid)
-		{
-				case IE_WPA:
-					if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))
-				{
-						if ((pEid->Len + 2) > MAX_CUSTOM_LEN)
-					{
-							pBss->WpaIE.IELen = 0;
-							break;
+		while ((Length + 2 + (USHORT) pEid->Len) <= LengthVIE) {
+			switch (pEid->Eid) {
+			case IE_WPA:
+				if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4)) {
+					if ((pEid->Len + 2) > MAX_CUSTOM_LEN) {
+						pBss->WpaIE.IELen = 0;
+						break;
 					}
-						pBss->WpaIE.IELen = pEid->Len + 2;
-						NdisMoveMemory(pBss->WpaIE.IE, pEid, pBss->WpaIE.IELen);
+					pBss->WpaIE.IELen = pEid->Len + 2;
+					NdisMoveMemory(pBss->WpaIE.IE, pEid,
+						       pBss->WpaIE.IELen);
 				}
 				break;
-                case IE_RSN:
-                    if (NdisEqualMemory(pEid->Octet + 2, RSN_OUI, 3))
-					{
-						if ((pEid->Len + 2) > MAX_CUSTOM_LEN)
-						{
-							pBss->RsnIE.IELen = 0;
-								break;
+			case IE_RSN:
+				if (NdisEqualMemory
+				    (pEid->Octet + 2, RSN_OUI, 3)) {
+					if ((pEid->Len + 2) > MAX_CUSTOM_LEN) {
+						pBss->RsnIE.IELen = 0;
+						break;
 					}
-						pBss->RsnIE.IELen = pEid->Len + 2;
-						NdisMoveMemory(pBss->RsnIE.IE, pEid, pBss->RsnIE.IELen);
+					pBss->RsnIE.IELen = pEid->Len + 2;
+					NdisMoveMemory(pBss->RsnIE.IE, pEid,
+						       pBss->RsnIE.IELen);
 				}
 				break;
-		}
-			Length = Length + 2 + (USHORT)pEid->Len;  // Eid[1] + Len[1]+ content[Len]
-			pEid = (PEID_STRUCT)((UCHAR*)pEid + 2 + pEid->Len);
+			}
+			Length = Length + 2 + (USHORT) pEid->Len;	// Eid[1] + Len[1]+ content[Len]
+			pEid = (PEID_STRUCT) ((UCHAR *) pEid + 2 + pEid->Len);
 		}
 	}
 }
@@ -3748,191 +3840,209 @@ VOID BssEntrySet(
  IRQL = DISPATCH_LEVEL
 
  */
-ULONG BssTableSetEntry(
-	IN		PRTMP_ADAPTER	pAd,
-	OUT BSS_TABLE *Tab,
-	IN PUCHAR pBssid,
-	IN CHAR Ssid[],
-	IN UCHAR SsidLen,
-	IN UCHAR BssType,
-	IN USHORT BeaconPeriod,
-	IN CF_PARM *CfParm,
-	IN USHORT AtimWin,
-	IN USHORT CapabilityInfo,
-	IN UCHAR SupRate[],
-	IN UCHAR SupRateLen,
-	IN UCHAR ExtRate[],
-	IN UCHAR ExtRateLen,
-	IN HT_CAPABILITY_IE *pHtCapability,
-	IN ADD_HT_INFO_IE *pAddHtInfo,	// AP might use this additional ht info IE
-	IN UCHAR			HtCapabilityLen,
-	IN UCHAR			AddHtInfoLen,
-	IN UCHAR			NewExtChanOffset,
-	IN UCHAR ChannelNo,
-	IN CHAR Rssi,
-	IN LARGE_INTEGER TimeStamp,
-	IN UCHAR CkipFlag,
-	IN PEDCA_PARM pEdcaParm,
-	IN PQOS_CAPABILITY_PARM pQosCapability,
-	IN PQBSS_LOAD_PARM pQbssLoad,
-	IN USHORT LengthVIE,
-	IN PNDIS_802_11_VARIABLE_IEs pVIE)
-{
-	ULONG	Idx;
-
-	Idx = BssTableSearchWithSSID(Tab, pBssid,  (UCHAR *)Ssid, SsidLen, ChannelNo);
-	if (Idx == BSS_NOT_FOUND)
-	{
-		if (Tab->BssNr >= MAX_LEN_OF_BSS_TABLE)
-	    {
+ULONG BssTableSetEntry(IN PRTMP_ADAPTER pAd, OUT BSS_TABLE * Tab, IN PUCHAR pBssid, IN CHAR Ssid[], IN UCHAR SsidLen, IN UCHAR BssType, IN USHORT BeaconPeriod, IN CF_PARM * CfParm, IN USHORT AtimWin, IN USHORT CapabilityInfo, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN HT_CAPABILITY_IE * pHtCapability, IN ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+		       IN UCHAR HtCapabilityLen,
+		       IN UCHAR AddHtInfoLen,
+		       IN UCHAR NewExtChanOffset,
+		       IN UCHAR ChannelNo,
+		       IN CHAR Rssi,
+		       IN LARGE_INTEGER TimeStamp,
+		       IN UCHAR CkipFlag,
+		       IN PEDCA_PARM pEdcaParm,
+		       IN PQOS_CAPABILITY_PARM pQosCapability,
+		       IN PQBSS_LOAD_PARM pQbssLoad,
+		       IN USHORT LengthVIE, IN PNDIS_802_11_VARIABLE_IEs pVIE)
+{
+	ULONG Idx;
+
+	Idx =
+	    BssTableSearchWithSSID(Tab, pBssid, (UCHAR *) Ssid, SsidLen,
+				   ChannelNo);
+	if (Idx == BSS_NOT_FOUND) {
+		if (Tab->BssNr >= MAX_LEN_OF_BSS_TABLE) {
 			//
 			// It may happen when BSS Table was full.
 			// The desired AP will not be added into BSS Table
 			// In this case, if we found the desired AP then overwrite BSS Table.
 			//
-			if(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-	{
-				if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, pBssid) ||
-					SSID_EQUAL(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, Ssid, SsidLen))
-	{
+			if (!OPSTATUS_TEST_FLAG
+			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
+				if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, pBssid)
+				    || SSID_EQUAL(pAd->MlmeAux.Ssid,
+						  pAd->MlmeAux.SsidLen, Ssid,
+						  SsidLen)) {
 					Idx = Tab->BssOverlapNr;
-					BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid, SsidLen, BssType, BeaconPeriod, CfParm, AtimWin,
-						CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,pHtCapability, pAddHtInfo,HtCapabilityLen, AddHtInfoLen,
-						NewExtChanOffset, ChannelNo, Rssi, TimeStamp, CkipFlag, pEdcaParm, pQosCapability, pQbssLoad, LengthVIE, pVIE);
-                    Tab->BssOverlapNr = (Tab->BssOverlapNr++) % MAX_LEN_OF_BSS_TABLE;
+					BssEntrySet(pAd, &Tab->BssEntry[Idx],
+						    pBssid, Ssid, SsidLen,
+						    BssType, BeaconPeriod,
+						    CfParm, AtimWin,
+						    CapabilityInfo, SupRate,
+						    SupRateLen, ExtRate,
+						    ExtRateLen, pHtCapability,
+						    pAddHtInfo, HtCapabilityLen,
+						    AddHtInfoLen,
+						    NewExtChanOffset, ChannelNo,
+						    Rssi, TimeStamp, CkipFlag,
+						    pEdcaParm, pQosCapability,
+						    pQbssLoad, LengthVIE, pVIE);
+					Tab->BssOverlapNr =
+					    (Tab->BssOverlapNr++) %
+					    MAX_LEN_OF_BSS_TABLE;
 				}
 				return Idx;
-				}
-			else
-				{
-			return BSS_NOT_FOUND;
-				}
+			} else {
+				return BSS_NOT_FOUND;
+			}
 		}
 		Idx = Tab->BssNr;
-		BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid, SsidLen, BssType, BeaconPeriod, CfParm, AtimWin,
-					CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,pHtCapability, pAddHtInfo,HtCapabilityLen, AddHtInfoLen,
-					NewExtChanOffset, ChannelNo, Rssi, TimeStamp, CkipFlag, pEdcaParm, pQosCapability, pQbssLoad, LengthVIE, pVIE);
+		BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid, SsidLen,
+			    BssType, BeaconPeriod, CfParm, AtimWin,
+			    CapabilityInfo, SupRate, SupRateLen, ExtRate,
+			    ExtRateLen, pHtCapability, pAddHtInfo,
+			    HtCapabilityLen, AddHtInfoLen, NewExtChanOffset,
+			    ChannelNo, Rssi, TimeStamp, CkipFlag, pEdcaParm,
+			    pQosCapability, pQbssLoad, LengthVIE, pVIE);
 		Tab->BssNr++;
-	}
-	else
-	{
+	} else {
 		/* avoid  Hidden SSID form beacon to overwirite correct SSID from probe response */
-		if ((SSID_EQUAL(Ssid, SsidLen, Tab->BssEntry[Idx].Ssid, Tab->BssEntry[Idx].SsidLen)) ||
-			(NdisEqualMemory(Tab->BssEntry[Idx].Ssid, ZeroSsid, Tab->BssEntry[Idx].SsidLen)))
-		{
-			BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid, SsidLen, BssType, BeaconPeriod,CfParm, AtimWin,
-						CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,pHtCapability, pAddHtInfo,HtCapabilityLen, AddHtInfoLen,
-						NewExtChanOffset, ChannelNo, Rssi, TimeStamp, CkipFlag, pEdcaParm, pQosCapability, pQbssLoad, LengthVIE, pVIE);
+		if ((SSID_EQUAL
+		     (Ssid, SsidLen, Tab->BssEntry[Idx].Ssid,
+		      Tab->BssEntry[Idx].SsidLen))
+		    ||
+		    (NdisEqualMemory
+		     (Tab->BssEntry[Idx].Ssid, ZeroSsid,
+		      Tab->BssEntry[Idx].SsidLen))) {
+			BssEntrySet(pAd, &Tab->BssEntry[Idx], pBssid, Ssid,
+				    SsidLen, BssType, BeaconPeriod, CfParm,
+				    AtimWin, CapabilityInfo, SupRate,
+				    SupRateLen, ExtRate, ExtRateLen,
+				    pHtCapability, pAddHtInfo, HtCapabilityLen,
+				    AddHtInfoLen, NewExtChanOffset, ChannelNo,
+				    Rssi, TimeStamp, CkipFlag, pEdcaParm,
+				    pQosCapability, pQbssLoad, LengthVIE, pVIE);
 		}
 	}
 
 	return Idx;
 }
 
-
 // IRQL = DISPATCH_LEVEL
-VOID BssTableSsidSort(
-	IN	PRTMP_ADAPTER	pAd,
-	OUT BSS_TABLE *OutTab,
-	IN	CHAR Ssid[],
-	IN	UCHAR SsidLen)
+VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
+		      OUT BSS_TABLE * OutTab, IN CHAR Ssid[], IN UCHAR SsidLen)
 {
 	INT i;
 	BssTableInit(OutTab);
 
-	for (i = 0; i < pAd->ScanTab.BssNr; i++)
-	{
+	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
 		BSS_ENTRY *pInBss = &pAd->ScanTab.BssEntry[i];
-		BOOLEAN	bIsHiddenApIncluded = FALSE;
+		BOOLEAN bIsHiddenApIncluded = FALSE;
 
 		if (((pAd->CommonCfg.bIEEE80211H == 1) &&
-            (pAd->MlmeAux.Channel > 14) &&
-             RadarChannelCheck(pAd, pInBss->Channel))
-            )
-{
+		     (pAd->MlmeAux.Channel > 14) &&
+		     RadarChannelCheck(pAd, pInBss->Channel))
+		    ) {
 			if (pInBss->Hidden)
 				bIsHiddenApIncluded = TRUE;
-}
+		}
 
 		if ((pInBss->BssType == pAd->StaCfg.BssType) &&
-			(SSID_EQUAL(Ssid, SsidLen, pInBss->Ssid, pInBss->SsidLen) || bIsHiddenApIncluded))
-		{
+		    (SSID_EQUAL(Ssid, SsidLen, pInBss->Ssid, pInBss->SsidLen)
+		     || bIsHiddenApIncluded)) {
 			BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
 
-
-
 			// 2.4G/5G N only mode
 			if ((pInBss->HtCapabilityLen == 0) &&
-				((pAd->CommonCfg.PhyMode == PHY_11N_2_4G) || (pAd->CommonCfg.PhyMode == PHY_11N_5G)))
-			{
-				DBGPRINT(RT_DEBUG_TRACE,("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
+			    ((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
+			     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
 				continue;
-	}
+			}
 			// New for WPA2
 			// Check the Authmode first
-			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
-			{
+			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
 				// Check AuthMode and AuthModeAux for matching, in case AP support dual-mode
-				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode) && (pAd->StaCfg.AuthMode != pInBss->AuthModeAux))
+				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode)
+				    && (pAd->StaCfg.AuthMode !=
+					pInBss->AuthModeAux))
 					// None matched
 					continue;
 
 				// Check cipher suite, AP must have more secured cipher than station setting
-				if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
-				{
+				if ((pAd->StaCfg.AuthMode ==
+				     Ndis802_11AuthModeWPA)
+				    || (pAd->StaCfg.AuthMode ==
+					Ndis802_11AuthModeWPAPSK)) {
 					// If it's not mixed mode, we should only let BSS pass with the same encryption
 					if (pInBss->WPA.bMixMode == FALSE)
-						if (pAd->StaCfg.WepStatus != pInBss->WPA.GroupCipher)
+						if (pAd->StaCfg.WepStatus !=
+						    pInBss->WPA.GroupCipher)
 							continue;
 
 					// check group cipher
-					if ((pAd->StaCfg.WepStatus < pInBss->WPA.GroupCipher) &&
-						(pInBss->WPA.GroupCipher != Ndis802_11GroupWEP40Enabled) &&
-						(pInBss->WPA.GroupCipher != Ndis802_11GroupWEP104Enabled))
+					if ((pAd->StaCfg.WepStatus <
+					     pInBss->WPA.GroupCipher)
+					    && (pInBss->WPA.GroupCipher !=
+						Ndis802_11GroupWEP40Enabled)
+					    && (pInBss->WPA.GroupCipher !=
+						Ndis802_11GroupWEP104Enabled))
 						continue;
 
 					// check pairwise cipher, skip if none matched
 					// If profile set to AES, let it pass without question.
 					// If profile set to TKIP, we must find one mateched
-					if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
-						(pAd->StaCfg.WepStatus != pInBss->WPA.PairCipher) &&
-						(pAd->StaCfg.WepStatus != pInBss->WPA.PairCipherAux))
+					if ((pAd->StaCfg.WepStatus ==
+					     Ndis802_11Encryption2Enabled)
+					    && (pAd->StaCfg.WepStatus !=
+						pInBss->WPA.PairCipher)
+					    && (pAd->StaCfg.WepStatus !=
+						pInBss->WPA.PairCipherAux))
 						continue;
-				}
-				else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
-				{
+				} else
+				    if ((pAd->StaCfg.AuthMode ==
+					 Ndis802_11AuthModeWPA2)
+					|| (pAd->StaCfg.AuthMode ==
+					    Ndis802_11AuthModeWPA2PSK)) {
 					// If it's not mixed mode, we should only let BSS pass with the same encryption
 					if (pInBss->WPA2.bMixMode == FALSE)
-						if (pAd->StaCfg.WepStatus != pInBss->WPA2.GroupCipher)
+						if (pAd->StaCfg.WepStatus !=
+						    pInBss->WPA2.GroupCipher)
 							continue;
 
 					// check group cipher
-					if ((pAd->StaCfg.WepStatus < pInBss->WPA.GroupCipher) &&
-						(pInBss->WPA2.GroupCipher != Ndis802_11GroupWEP40Enabled) &&
-						(pInBss->WPA2.GroupCipher != Ndis802_11GroupWEP104Enabled))
+					if ((pAd->StaCfg.WepStatus <
+					     pInBss->WPA.GroupCipher)
+					    && (pInBss->WPA2.GroupCipher !=
+						Ndis802_11GroupWEP40Enabled)
+					    && (pInBss->WPA2.GroupCipher !=
+						Ndis802_11GroupWEP104Enabled))
 						continue;
 
 					// check pairwise cipher, skip if none matched
 					// If profile set to AES, let it pass without question.
 					// If profile set to TKIP, we must find one mateched
-					if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
-						(pAd->StaCfg.WepStatus != pInBss->WPA2.PairCipher) &&
-						(pAd->StaCfg.WepStatus != pInBss->WPA2.PairCipherAux))
+					if ((pAd->StaCfg.WepStatus ==
+					     Ndis802_11Encryption2Enabled)
+					    && (pAd->StaCfg.WepStatus !=
+						pInBss->WPA2.PairCipher)
+					    && (pAd->StaCfg.WepStatus !=
+						pInBss->WPA2.PairCipherAux))
 						continue;
 				}
 			}
 			// Bss Type matched, SSID matched.
 			// We will check wepstatus for qualification Bss
-			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus)
-			{
-				DBGPRINT(RT_DEBUG_TRACE,("StaCfg.WepStatus=%d, while pInBss->WepStatus=%d\n", pAd->StaCfg.WepStatus, pInBss->WepStatus));
+			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("StaCfg.WepStatus=%d, while pInBss->WepStatus=%d\n",
+					  pAd->StaCfg.WepStatus,
+					  pInBss->WepStatus));
 				//
 				// For the SESv2 case, we will not qualify WepStatus.
-	//
+				//
 				if (!pInBss->bSES)
 					continue;
 			}
-
 			// Since the AP is using hidden SSID, and we are trying to connect to ANY
 			// It definitely will fail. So, skip it.
 			// CCX also require not even try to connect it!!
@@ -3942,108 +4052,123 @@ VOID BssTableSsidSort(
 			// If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region
 			// If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead,
 			if ((pInBss->CentralChannel != pInBss->Channel) &&
-				(pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40))
-	{
-				if (RTMPCheckChannel(pAd, pInBss->CentralChannel, pInBss->Channel) == FALSE)
-	{
-					pAd->CommonCfg.RegTransmitSetting.field.BW = BW_20;
+			    (pAd->CommonCfg.RegTransmitSetting.field.BW ==
+			     BW_40)) {
+				if (RTMPCheckChannel
+				    (pAd, pInBss->CentralChannel,
+				     pInBss->Channel) == FALSE) {
+					pAd->CommonCfg.RegTransmitSetting.field.
+					    BW = BW_20;
 					SetCommonHT(pAd);
-					pAd->CommonCfg.RegTransmitSetting.field.BW = BW_40;
-				}
-				else
-				{
-					if (pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BAND_WIDTH_20)
-					{
+					pAd->CommonCfg.RegTransmitSetting.field.
+					    BW = BW_40;
+				} else {
+					if (pAd->CommonCfg.DesiredHtPhy.
+					    ChannelWidth == BAND_WIDTH_20) {
 						SetCommonHT(pAd);
 					}
-		}
-	}
-
+				}
+			}
 			// copy matching BSS from InTab to OutTab
 			NdisMoveMemory(pOutBss, pInBss, sizeof(BSS_ENTRY));
 
 			OutTab->BssNr++;
-		}
-		else if ((pInBss->BssType == pAd->StaCfg.BssType) && (SsidLen == 0))
-	{
+		} else if ((pInBss->BssType == pAd->StaCfg.BssType)
+			   && (SsidLen == 0)) {
 			BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
 
-
 			// 2.4G/5G N only mode
 			if ((pInBss->HtCapabilityLen == 0) &&
-				((pAd->CommonCfg.PhyMode == PHY_11N_2_4G) || (pAd->CommonCfg.PhyMode == PHY_11N_5G)))
-		{
-				DBGPRINT(RT_DEBUG_TRACE,("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
+			    ((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
+			     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
 				continue;
 			}
-
 			// New for WPA2
 			// Check the Authmode first
-			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
-			{
+			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
 				// Check AuthMode and AuthModeAux for matching, in case AP support dual-mode
-				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode) && (pAd->StaCfg.AuthMode != pInBss->AuthModeAux))
+				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode)
+				    && (pAd->StaCfg.AuthMode !=
+					pInBss->AuthModeAux))
 					// None matched
 					continue;
 
 				// Check cipher suite, AP must have more secured cipher than station setting
-				if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
-				{
+				if ((pAd->StaCfg.AuthMode ==
+				     Ndis802_11AuthModeWPA)
+				    || (pAd->StaCfg.AuthMode ==
+					Ndis802_11AuthModeWPAPSK)) {
 					// If it's not mixed mode, we should only let BSS pass with the same encryption
 					if (pInBss->WPA.bMixMode == FALSE)
-						if (pAd->StaCfg.WepStatus != pInBss->WPA.GroupCipher)
+						if (pAd->StaCfg.WepStatus !=
+						    pInBss->WPA.GroupCipher)
 							continue;
 
 					// check group cipher
-					if (pAd->StaCfg.WepStatus < pInBss->WPA.GroupCipher)
+					if (pAd->StaCfg.WepStatus <
+					    pInBss->WPA.GroupCipher)
 						continue;
 
 					// check pairwise cipher, skip if none matched
 					// If profile set to AES, let it pass without question.
 					// If profile set to TKIP, we must find one mateched
-					if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
-						(pAd->StaCfg.WepStatus != pInBss->WPA.PairCipher) &&
-						(pAd->StaCfg.WepStatus != pInBss->WPA.PairCipherAux))
+					if ((pAd->StaCfg.WepStatus ==
+					     Ndis802_11Encryption2Enabled)
+					    && (pAd->StaCfg.WepStatus !=
+						pInBss->WPA.PairCipher)
+					    && (pAd->StaCfg.WepStatus !=
+						pInBss->WPA.PairCipherAux))
 						continue;
-				}
-				else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
-				{
+				} else
+				    if ((pAd->StaCfg.AuthMode ==
+					 Ndis802_11AuthModeWPA2)
+					|| (pAd->StaCfg.AuthMode ==
+					    Ndis802_11AuthModeWPA2PSK)) {
 					// If it's not mixed mode, we should only let BSS pass with the same encryption
 					if (pInBss->WPA2.bMixMode == FALSE)
-						if (pAd->StaCfg.WepStatus != pInBss->WPA2.GroupCipher)
+						if (pAd->StaCfg.WepStatus !=
+						    pInBss->WPA2.GroupCipher)
 							continue;
 
 					// check group cipher
-					if (pAd->StaCfg.WepStatus < pInBss->WPA2.GroupCipher)
+					if (pAd->StaCfg.WepStatus <
+					    pInBss->WPA2.GroupCipher)
 						continue;
 
 					// check pairwise cipher, skip if none matched
 					// If profile set to AES, let it pass without question.
 					// If profile set to TKIP, we must find one mateched
-					if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) &&
-						(pAd->StaCfg.WepStatus != pInBss->WPA2.PairCipher) &&
-						(pAd->StaCfg.WepStatus != pInBss->WPA2.PairCipherAux))
+					if ((pAd->StaCfg.WepStatus ==
+					     Ndis802_11Encryption2Enabled)
+					    && (pAd->StaCfg.WepStatus !=
+						pInBss->WPA2.PairCipher)
+					    && (pAd->StaCfg.WepStatus !=
+						pInBss->WPA2.PairCipherAux))
 						continue;
 				}
 			}
 			// Bss Type matched, SSID matched.
 			// We will check wepstatus for qualification Bss
 			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus)
-					continue;
+				continue;
 
 			// If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region
 			// If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead,
 			if ((pInBss->CentralChannel != pInBss->Channel) &&
-				(pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40))
-				{
-				if (RTMPCheckChannel(pAd, pInBss->CentralChannel, pInBss->Channel) == FALSE)
-				{
-					pAd->CommonCfg.RegTransmitSetting.field.BW = BW_20;
+			    (pAd->CommonCfg.RegTransmitSetting.field.BW ==
+			     BW_40)) {
+				if (RTMPCheckChannel
+				    (pAd, pInBss->CentralChannel,
+				     pInBss->Channel) == FALSE) {
+					pAd->CommonCfg.RegTransmitSetting.field.
+					    BW = BW_20;
 					SetCommonHT(pAd);
-					pAd->CommonCfg.RegTransmitSetting.field.BW = BW_40;
-				}
+					pAd->CommonCfg.RegTransmitSetting.field.
+					    BW = BW_40;
 				}
-
+			}
 			// copy matching BSS from InTab to OutTab
 			NdisMoveMemory(pOutBss, pInBss, sizeof(BSS_ENTRY));
 
@@ -4051,359 +4176,364 @@ VOID BssTableSsidSort(
 		}
 
 		if (OutTab->BssNr >= MAX_LEN_OF_BSS_TABLE)
-				break;
-			}
+			break;
+	}
 
 	BssTableSortByRssi(OutTab);
 }
 
-
 // IRQL = DISPATCH_LEVEL
-VOID BssTableSortByRssi(
-	IN OUT BSS_TABLE *OutTab)
+VOID BssTableSortByRssi(IN OUT BSS_TABLE * OutTab)
 {
-	INT	  i, j;
+	INT i, j;
 	BSS_ENTRY TmpBss;
 
-	for (i = 0; i < OutTab->BssNr - 1; i++)
-			{
-		for (j = i+1; j < OutTab->BssNr; j++)
-				{
-			if (OutTab->BssEntry[j].Rssi > OutTab->BssEntry[i].Rssi)
-					{
-				NdisMoveMemory(&TmpBss, &OutTab->BssEntry[j], sizeof(BSS_ENTRY));
-				NdisMoveMemory(&OutTab->BssEntry[j], &OutTab->BssEntry[i], sizeof(BSS_ENTRY));
-				NdisMoveMemory(&OutTab->BssEntry[i], &TmpBss, sizeof(BSS_ENTRY));
-					}
-					}
-					}
+	for (i = 0; i < OutTab->BssNr - 1; i++) {
+		for (j = i + 1; j < OutTab->BssNr; j++) {
+			if (OutTab->BssEntry[j].Rssi > OutTab->BssEntry[i].Rssi) {
+				NdisMoveMemory(&TmpBss, &OutTab->BssEntry[j],
+					       sizeof(BSS_ENTRY));
+				NdisMoveMemory(&OutTab->BssEntry[j],
+					       &OutTab->BssEntry[i],
+					       sizeof(BSS_ENTRY));
+				NdisMoveMemory(&OutTab->BssEntry[i], &TmpBss,
+					       sizeof(BSS_ENTRY));
+			}
+		}
+	}
 }
 
-
-VOID BssCipherParse(
-	IN OUT	PBSS_ENTRY	pBss)
-{
-	PEID_STRUCT		 pEid;
-	PUCHAR				pTmp;
-	PRSN_IE_HEADER_STRUCT			pRsnHeader;
-	PCIPHER_SUITE_STRUCT			pCipher;
-	PAKM_SUITE_STRUCT				pAKM;
-	USHORT							Count;
-	INT								Length;
-	NDIS_802_11_ENCRYPTION_STATUS	TmpCipher;
+VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
+{
+	PEID_STRUCT pEid;
+	PUCHAR pTmp;
+	PRSN_IE_HEADER_STRUCT pRsnHeader;
+	PCIPHER_SUITE_STRUCT pCipher;
+	PAKM_SUITE_STRUCT pAKM;
+	USHORT Count;
+	INT Length;
+	NDIS_802_11_ENCRYPTION_STATUS TmpCipher;
 
 	//
 	// WepStatus will be reset later, if AP announce TKIP or AES on the beacon frame.
 	//
-	if (pBss->Privacy)
-						{
-		pBss->WepStatus		= Ndis802_11WEPEnabled;
-					}
-					else
-					{
-		pBss->WepStatus		= Ndis802_11WEPDisabled;
-					}
+	if (pBss->Privacy) {
+		pBss->WepStatus = Ndis802_11WEPEnabled;
+	} else {
+		pBss->WepStatus = Ndis802_11WEPDisabled;
+	}
 	// Set default to disable & open authentication before parsing variable IE
-	pBss->AuthMode		= Ndis802_11AuthModeOpen;
-	pBss->AuthModeAux	= Ndis802_11AuthModeOpen;
+	pBss->AuthMode = Ndis802_11AuthModeOpen;
+	pBss->AuthModeAux = Ndis802_11AuthModeOpen;
 
 	// Init WPA setting
-	pBss->WPA.PairCipher	= Ndis802_11WEPDisabled;
+	pBss->WPA.PairCipher = Ndis802_11WEPDisabled;
 	pBss->WPA.PairCipherAux = Ndis802_11WEPDisabled;
-	pBss->WPA.GroupCipher	= Ndis802_11WEPDisabled;
+	pBss->WPA.GroupCipher = Ndis802_11WEPDisabled;
 	pBss->WPA.RsnCapability = 0;
-	pBss->WPA.bMixMode		= FALSE;
+	pBss->WPA.bMixMode = FALSE;
 
 	// Init WPA2 setting
-	pBss->WPA2.PairCipher	 = Ndis802_11WEPDisabled;
+	pBss->WPA2.PairCipher = Ndis802_11WEPDisabled;
 	pBss->WPA2.PairCipherAux = Ndis802_11WEPDisabled;
-	pBss->WPA2.GroupCipher	 = Ndis802_11WEPDisabled;
+	pBss->WPA2.GroupCipher = Ndis802_11WEPDisabled;
 	pBss->WPA2.RsnCapability = 0;
-	pBss->WPA2.bMixMode	 = FALSE;
-
+	pBss->WPA2.bMixMode = FALSE;
 
 	Length = (INT) pBss->VarIELen;
 
-	while (Length > 0)
-	    {
+	while (Length > 0) {
 		// Parse cipher suite base on WPA1 & WPA2, they should be parsed differently
 		pTmp = ((PUCHAR) pBss->VarIEs) + pBss->VarIELen - Length;
 		pEid = (PEID_STRUCT) pTmp;
-		switch (pEid->Eid)
-	    {
-			case IE_WPA:
-				if (NdisEqualMemory(pEid->Octet, SES_OUI, 3) && (pEid->Len == 7))
-		{
-					pBss->bSES = TRUE;
+		switch (pEid->Eid) {
+		case IE_WPA:
+			if (NdisEqualMemory(pEid->Octet, SES_OUI, 3)
+			    && (pEid->Len == 7)) {
+				pBss->bSES = TRUE;
+				break;
+			} else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4) !=
+				   1) {
+				// if unsupported vendor specific IE
+				break;
+			}
+			// Skip OUI, version, and multicast suite
+			// This part should be improved in the future when AP supported multiple cipher suite.
+			// For now, it's OK since almost all APs have fixed cipher suite supported.
+			// pTmp = (PUCHAR) pEid->Octet;
+			pTmp += 11;
+
+			// Cipher Suite Selectors from Spec P802.11i/D3.2 P26.
+			//      Value      Meaning
+			//      0                       None
+			//      1                       WEP-40
+			//      2                       Tkip
+			//      3                       WRAP
+			//      4                       AES
+			//      5                       WEP-104
+			// Parse group cipher
+			switch (*pTmp) {
+			case 1:
+				pBss->WPA.GroupCipher =
+				    Ndis802_11GroupWEP40Enabled;
+				break;
+			case 5:
+				pBss->WPA.GroupCipher =
+				    Ndis802_11GroupWEP104Enabled;
+				break;
+			case 2:
+				pBss->WPA.GroupCipher =
+				    Ndis802_11Encryption2Enabled;
+				break;
+			case 4:
+				pBss->WPA.GroupCipher =
+				    Ndis802_11Encryption3Enabled;
+				break;
+			default:
+				break;
+			}
+			// number of unicast suite
+			pTmp += 1;
+
+			// skip all unicast cipher suites
+			//Count = *(PUSHORT) pTmp;
+			Count = (pTmp[1] << 8) + pTmp[0];
+			pTmp += sizeof(USHORT);
+
+			// Parsing all unicast cipher suite
+			while (Count > 0) {
+				// Skip OUI
+				pTmp += 3;
+				TmpCipher = Ndis802_11WEPDisabled;
+				switch (*pTmp) {
+				case 1:
+				case 5:	// Although WEP is not allowed in WPA related auth mode, we parse it anyway
+					TmpCipher =
+					    Ndis802_11Encryption1Enabled;
 					break;
-		}
-				else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4) != 1)
-		{
-					// if unsupported vendor specific IE
+				case 2:
+					TmpCipher =
+					    Ndis802_11Encryption2Enabled;
+					break;
+				case 4:
+					TmpCipher =
+					    Ndis802_11Encryption3Enabled;
+					break;
+				default:
 					break;
-		}
-				// Skip OUI, version, and multicast suite
-				// This part should be improved in the future when AP supported multiple cipher suite.
-				// For now, it's OK since almost all APs have fixed cipher suite supported.
-				// pTmp = (PUCHAR) pEid->Octet;
-				pTmp   += 11;
-
-				// Cipher Suite Selectors from Spec P802.11i/D3.2 P26.
-				//	Value	   Meaning
-				//	0			None
-				//	1			WEP-40
-				//	2			Tkip
-				//	3			WRAP
-				//	4			AES
-				//	5			WEP-104
-				// Parse group cipher
-				switch (*pTmp)
-	{
-					case 1:
-						pBss->WPA.GroupCipher = Ndis802_11GroupWEP40Enabled;
-						break;
-					case 5:
-						pBss->WPA.GroupCipher = Ndis802_11GroupWEP104Enabled;
-						break;
-					case 2:
-						pBss->WPA.GroupCipher = Ndis802_11Encryption2Enabled;
-						break;
-					case 4:
-						pBss->WPA.GroupCipher = Ndis802_11Encryption3Enabled;
-						break;
-					default:
-						break;
 				}
-				// number of unicast suite
-				pTmp   += 1;
-
-				// skip all unicast cipher suites
-				//Count = *(PUSHORT) pTmp;
-				Count = (pTmp[1]<<8) + pTmp[0];
-				pTmp   += sizeof(USHORT);
-
-				// Parsing all unicast cipher suite
-				while (Count > 0)
-		{
-					// Skip OUI
-					pTmp += 3;
-					TmpCipher = Ndis802_11WEPDisabled;
-					switch (*pTmp)
-		{
-						case 1:
-						case 5: // Although WEP is not allowed in WPA related auth mode, we parse it anyway
-							TmpCipher = Ndis802_11Encryption1Enabled;
-							break;
-						case 2:
-							TmpCipher = Ndis802_11Encryption2Enabled;
-							break;
-						case 4:
-							TmpCipher = Ndis802_11Encryption3Enabled;
-							break;
-						default:
-							break;
-		}
-					if (TmpCipher > pBss->WPA.PairCipher)
-		{
-						// Move the lower cipher suite to PairCipherAux
-						pBss->WPA.PairCipherAux = pBss->WPA.PairCipher;
-						pBss->WPA.PairCipher	= TmpCipher;
-	}
-					else
-		{
-						pBss->WPA.PairCipherAux = TmpCipher;
-	}
-					pTmp++;
-					Count--;
-	}
-
-				// 4. get AKM suite counts
-				//Count	= *(PUSHORT) pTmp;
-				Count = (pTmp[1]<<8) + pTmp[0];
-				pTmp   += sizeof(USHORT);
-				pTmp   += 3;
+				if (TmpCipher > pBss->WPA.PairCipher) {
+					// Move the lower cipher suite to PairCipherAux
+					pBss->WPA.PairCipherAux =
+					    pBss->WPA.PairCipher;
+					pBss->WPA.PairCipher = TmpCipher;
+				} else {
+					pBss->WPA.PairCipherAux = TmpCipher;
+				}
+				pTmp++;
+				Count--;
+			}
+
+			// 4. get AKM suite counts
+			//Count = *(PUSHORT) pTmp;
+			Count = (pTmp[1] << 8) + pTmp[0];
+			pTmp += sizeof(USHORT);
+			pTmp += 3;
+
+			switch (*pTmp) {
+			case 1:
+				// Set AP support WPA-enterprise mode
+				if (pBss->AuthMode == Ndis802_11AuthModeOpen)
+					pBss->AuthMode = Ndis802_11AuthModeWPA;
+				else
+					pBss->AuthModeAux =
+					    Ndis802_11AuthModeWPA;
+				break;
+			case 2:
+				// Set AP support WPA-PSK mode
+				if (pBss->AuthMode == Ndis802_11AuthModeOpen)
+					pBss->AuthMode =
+					    Ndis802_11AuthModeWPAPSK;
+				else
+					pBss->AuthModeAux =
+					    Ndis802_11AuthModeWPAPSK;
+				break;
+			default:
+				break;
+			}
+			pTmp += 1;
 
-				switch (*pTmp)
-		{
-					case 1:
-						// Set AP support WPA-enterprise mode
-						if (pBss->AuthMode == Ndis802_11AuthModeOpen)
-							pBss->AuthMode = Ndis802_11AuthModeWPA;
-	else
-							pBss->AuthModeAux = Ndis802_11AuthModeWPA;
-						break;
-					case 2:
-						// Set AP support WPA-PSK mode
-						if (pBss->AuthMode == Ndis802_11AuthModeOpen)
-							pBss->AuthMode = Ndis802_11AuthModeWPAPSK;
-		else
-							pBss->AuthModeAux = Ndis802_11AuthModeWPAPSK;
-						break;
-					default:
-						break;
-	}
-				pTmp   += 1;
+			// Fixed for WPA-None
+			if (pBss->BssType == BSS_ADHOC) {
+				pBss->AuthMode = Ndis802_11AuthModeWPANone;
+				pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
+				pBss->WepStatus = pBss->WPA.GroupCipher;
+				// Patched bugs for old driver
+				if (pBss->WPA.PairCipherAux ==
+				    Ndis802_11WEPDisabled)
+					pBss->WPA.PairCipherAux =
+					    pBss->WPA.GroupCipher;
+			} else
+				pBss->WepStatus = pBss->WPA.PairCipher;
+
+			// Check the Pair & Group, if different, turn on mixed mode flag
+			if (pBss->WPA.GroupCipher != pBss->WPA.PairCipher)
+				pBss->WPA.bMixMode = TRUE;
 
-				// Fixed for WPA-None
-				if (pBss->BssType == BSS_ADHOC)
-		{
-					pBss->AuthMode	  = Ndis802_11AuthModeWPANone;
-					pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
-					pBss->WepStatus   = pBss->WPA.GroupCipher;
-					// Patched bugs for old driver
-					if (pBss->WPA.PairCipherAux == Ndis802_11WEPDisabled)
-						pBss->WPA.PairCipherAux = pBss->WPA.GroupCipher;
-		}
-		else
-					pBss->WepStatus   = pBss->WPA.PairCipher;
+			break;
 
-				// Check the Pair & Group, if different, turn on mixed mode flag
-				if (pBss->WPA.GroupCipher != pBss->WPA.PairCipher)
-					pBss->WPA.bMixMode = TRUE;
+		case IE_RSN:
+			pRsnHeader = (PRSN_IE_HEADER_STRUCT) pTmp;
 
+			// 0. Version must be 1
+			if (le2cpu16(pRsnHeader->Version) != 1)
 				break;
+			pTmp += sizeof(RSN_IE_HEADER_STRUCT);
 
-			case IE_RSN:
-				pRsnHeader = (PRSN_IE_HEADER_STRUCT) pTmp;
+			// 1. Check group cipher
+			pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
+			if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
+				break;
 
-				// 0. Version must be 1
-				if (le2cpu16(pRsnHeader->Version) != 1)
-					break;
-				pTmp   += sizeof(RSN_IE_HEADER_STRUCT);
+			// Parse group cipher
+			switch (pCipher->Type) {
+			case 1:
+				pBss->WPA2.GroupCipher =
+				    Ndis802_11GroupWEP40Enabled;
+				break;
+			case 5:
+				pBss->WPA2.GroupCipher =
+				    Ndis802_11GroupWEP104Enabled;
+				break;
+			case 2:
+				pBss->WPA2.GroupCipher =
+				    Ndis802_11Encryption2Enabled;
+				break;
+			case 4:
+				pBss->WPA2.GroupCipher =
+				    Ndis802_11Encryption3Enabled;
+				break;
+			default:
+				break;
+			}
+			// set to correct offset for next parsing
+			pTmp += sizeof(CIPHER_SUITE_STRUCT);
 
-				// 1. Check group cipher
+			// 2. Get pairwise cipher counts
+			//Count = *(PUSHORT) pTmp;
+			Count = (pTmp[1] << 8) + pTmp[0];
+			pTmp += sizeof(USHORT);
+
+			// 3. Get pairwise cipher
+			// Parsing all unicast cipher suite
+			while (Count > 0) {
+				// Skip OUI
 				pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
-				if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
-						break;
-
-				// Parse group cipher
-				switch (pCipher->Type)
-				{
-					case 1:
-						pBss->WPA2.GroupCipher = Ndis802_11GroupWEP40Enabled;
-						break;
-					case 5:
-						pBss->WPA2.GroupCipher = Ndis802_11GroupWEP104Enabled;
-						break;
-					case 2:
-						pBss->WPA2.GroupCipher = Ndis802_11Encryption2Enabled;
-						break;
-					case 4:
-						pBss->WPA2.GroupCipher = Ndis802_11Encryption3Enabled;
-						break;
-					default:
-						break;
+				TmpCipher = Ndis802_11WEPDisabled;
+				switch (pCipher->Type) {
+				case 1:
+				case 5:	// Although WEP is not allowed in WPA related auth mode, we parse it anyway
+					TmpCipher =
+					    Ndis802_11Encryption1Enabled;
+					break;
+				case 2:
+					TmpCipher =
+					    Ndis802_11Encryption2Enabled;
+					break;
+				case 4:
+					TmpCipher =
+					    Ndis802_11Encryption3Enabled;
+					break;
+				default:
+					break;
 				}
-				// set to correct offset for next parsing
-				pTmp   += sizeof(CIPHER_SUITE_STRUCT);
+				if (TmpCipher > pBss->WPA2.PairCipher) {
+					// Move the lower cipher suite to PairCipherAux
+					pBss->WPA2.PairCipherAux =
+					    pBss->WPA2.PairCipher;
+					pBss->WPA2.PairCipher = TmpCipher;
+				} else {
+					pBss->WPA2.PairCipherAux = TmpCipher;
+				}
+				pTmp += sizeof(CIPHER_SUITE_STRUCT);
+				Count--;
+			}
+
+			// 4. get AKM suite counts
+			//Count = *(PUSHORT) pTmp;
+			Count = (pTmp[1] << 8) + pTmp[0];
+			pTmp += sizeof(USHORT);
+
+			// 5. Get AKM ciphers
+			// Parsing all AKM ciphers
+			while (Count > 0) {
+				pAKM = (PAKM_SUITE_STRUCT) pTmp;
+				if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
+					break;
 
-				// 2. Get pairwise cipher counts
-				//Count = *(PUSHORT) pTmp;
-				Count = (pTmp[1]<<8) + pTmp[0];
-				pTmp   += sizeof(USHORT);
-
-				// 3. Get pairwise cipher
-				// Parsing all unicast cipher suite
-				while (Count > 0)
-	{
-					// Skip OUI
-					pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
-					TmpCipher = Ndis802_11WEPDisabled;
-					switch (pCipher->Type)
-	{
-						case 1:
-						case 5: // Although WEP is not allowed in WPA related auth mode, we parse it anyway
-							TmpCipher = Ndis802_11Encryption1Enabled;
-							break;
-						case 2:
-							TmpCipher = Ndis802_11Encryption2Enabled;
-							break;
-						case 4:
-							TmpCipher = Ndis802_11Encryption3Enabled;
-							break;
-						default:
-							break;
-	}
-					if (TmpCipher > pBss->WPA2.PairCipher)
-	{
-						// Move the lower cipher suite to PairCipherAux
-						pBss->WPA2.PairCipherAux = pBss->WPA2.PairCipher;
-						pBss->WPA2.PairCipher	 = TmpCipher;
-	}
+				switch (pAKM->Type) {
+				case 1:
+					// Set AP support WPA-enterprise mode
+					if (pBss->AuthMode ==
+					    Ndis802_11AuthModeOpen)
+						pBss->AuthMode =
+						    Ndis802_11AuthModeWPA2;
 					else
-	{
-						pBss->WPA2.PairCipherAux = TmpCipher;
-	}
-					pTmp += sizeof(CIPHER_SUITE_STRUCT);
-					Count--;
-	}
-
-				// 4. get AKM suite counts
-				//Count	= *(PUSHORT) pTmp;
-				Count = (pTmp[1]<<8) + pTmp[0];
-				pTmp   += sizeof(USHORT);
-
-				// 5. Get AKM ciphers
-				// Parsing all AKM ciphers
-				while (Count > 0)
-			{
-					pAKM = (PAKM_SUITE_STRUCT) pTmp;
-					if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
-						break;
-
-					switch (pAKM->Type)
-				{
-						case 1:
-							// Set AP support WPA-enterprise mode
-							if (pBss->AuthMode == Ndis802_11AuthModeOpen)
-								pBss->AuthMode = Ndis802_11AuthModeWPA2;
-				else
-								pBss->AuthModeAux = Ndis802_11AuthModeWPA2;
-							break;
-						case 2:
-							// Set AP support WPA-PSK mode
-							if (pBss->AuthMode == Ndis802_11AuthModeOpen)
-								pBss->AuthMode = Ndis802_11AuthModeWPA2PSK;
-							else
-								pBss->AuthModeAux = Ndis802_11AuthModeWPA2PSK;
-							break;
-						default:
-							if (pBss->AuthMode == Ndis802_11AuthModeOpen)
-								pBss->AuthMode = Ndis802_11AuthModeMax;
-							else
-								pBss->AuthModeAux = Ndis802_11AuthModeMax;
-							break;
+						pBss->AuthModeAux =
+						    Ndis802_11AuthModeWPA2;
+					break;
+				case 2:
+					// Set AP support WPA-PSK mode
+					if (pBss->AuthMode ==
+					    Ndis802_11AuthModeOpen)
+						pBss->AuthMode =
+						    Ndis802_11AuthModeWPA2PSK;
+					else
+						pBss->AuthModeAux =
+						    Ndis802_11AuthModeWPA2PSK;
+					break;
+				default:
+					if (pBss->AuthMode ==
+					    Ndis802_11AuthModeOpen)
+						pBss->AuthMode =
+						    Ndis802_11AuthModeMax;
+					else
+						pBss->AuthModeAux =
+						    Ndis802_11AuthModeMax;
+					break;
 				}
-					pTmp   += (Count * sizeof(AKM_SUITE_STRUCT));
-					Count--;
+				pTmp += (Count * sizeof(AKM_SUITE_STRUCT));
+				Count--;
 			}
 
-				// Fixed for WPA-None
-				if (pBss->BssType == BSS_ADHOC)
-				{
-					pBss->AuthMode = Ndis802_11AuthModeWPANone;
-					pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
-					pBss->WPA.PairCipherAux = pBss->WPA2.PairCipherAux;
-					pBss->WPA.GroupCipher	= pBss->WPA2.GroupCipher;
-					pBss->WepStatus			= pBss->WPA.GroupCipher;
-					// Patched bugs for old driver
-					if (pBss->WPA.PairCipherAux == Ndis802_11WEPDisabled)
-						pBss->WPA.PairCipherAux = pBss->WPA.GroupCipher;
-	}
-				pBss->WepStatus   = pBss->WPA2.PairCipher;
-
-				// 6. Get RSN capability
-				//pBss->WPA2.RsnCapability = *(PUSHORT) pTmp;
-				pBss->WPA2.RsnCapability = (pTmp[1]<<8) + pTmp[0];
-				pTmp += sizeof(USHORT);
-
-				// Check the Pair & Group, if different, turn on mixed mode flag
-				if (pBss->WPA2.GroupCipher != pBss->WPA2.PairCipher)
-					pBss->WPA2.bMixMode = TRUE;
+			// Fixed for WPA-None
+			if (pBss->BssType == BSS_ADHOC) {
+				pBss->AuthMode = Ndis802_11AuthModeWPANone;
+				pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
+				pBss->WPA.PairCipherAux =
+				    pBss->WPA2.PairCipherAux;
+				pBss->WPA.GroupCipher = pBss->WPA2.GroupCipher;
+				pBss->WepStatus = pBss->WPA.GroupCipher;
+				// Patched bugs for old driver
+				if (pBss->WPA.PairCipherAux ==
+				    Ndis802_11WEPDisabled)
+					pBss->WPA.PairCipherAux =
+					    pBss->WPA.GroupCipher;
+			}
+			pBss->WepStatus = pBss->WPA2.PairCipher;
+
+			// 6. Get RSN capability
+			//pBss->WPA2.RsnCapability = *(PUSHORT) pTmp;
+			pBss->WPA2.RsnCapability = (pTmp[1] << 8) + pTmp[0];
+			pTmp += sizeof(USHORT);
+
+			// Check the Pair & Group, if different, turn on mixed mode flag
+			if (pBss->WPA2.GroupCipher != pBss->WPA2.PairCipher)
+				pBss->WPA2.bMixMode = TRUE;
 
-				break;
-			default:
-				break;
+			break;
+		default:
+			break;
 		}
 		Length -= (pEid->Len + 2);
 	}
@@ -4419,18 +4549,15 @@ VOID BssCipherParse(
  *	\pre
  *	\post
  */
-VOID MacAddrRandomBssid(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pAddr)
+VOID MacAddrRandomBssid(IN PRTMP_ADAPTER pAd, OUT PUCHAR pAddr)
 {
 	INT i;
 
-	for (i = 0; i < MAC_ADDR_LEN; i++)
-	{
+	for (i = 0; i < MAC_ADDR_LEN; i++) {
 		pAddr[i] = RandomByte(pAd);
 	}
 
-	pAddr[0] = (pAddr[0] & 0xfe) | 0x02;  // the first 2 bits must be 01xxxxxxxx
+	pAddr[0] = (pAddr[0] & 0xfe) | 0x02;	// the first 2 bits must be 01xxxxxxxx
 }
 
 /*! \brief init the management mac frame header
@@ -4448,23 +4575,20 @@ VOID MacAddrRandomBssid(
 	IRQL = DISPATCH_LEVEL
 
  */
-VOID MgtMacHeaderInit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN OUT PHEADER_802_11 pHdr80211,
-	IN UCHAR SubType,
-	IN UCHAR ToDs,
-	IN PUCHAR pDA,
-	IN PUCHAR pBssid)
+VOID MgtMacHeaderInit(IN PRTMP_ADAPTER pAd,
+		      IN OUT PHEADER_802_11 pHdr80211,
+		      IN UCHAR SubType,
+		      IN UCHAR ToDs, IN PUCHAR pDA, IN PUCHAR pBssid)
 {
 	NdisZeroMemory(pHdr80211, sizeof(HEADER_802_11));
 
 	pHdr80211->FC.Type = BTYPE_MGMT;
 	pHdr80211->FC.SubType = SubType;
-//	if (SubType == SUBTYPE_ACK)	// sample, no use, it will conflict with ACTION frame sub type
-//		pHdr80211->FC.Type = BTYPE_CNTL;
+//      if (SubType == SUBTYPE_ACK)     // sample, no use, it will conflict with ACTION frame sub type
+//              pHdr80211->FC.Type = BTYPE_CNTL;
 	pHdr80211->FC.ToDs = ToDs;
 	COPY_MAC_ADDR(pHdr80211->Addr1, pDA);
-		COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
+	COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
 	COPY_MAC_ADDR(pHdr80211->Addr3, pBssid);
 }
 
@@ -4490,31 +4614,27 @@ VOID MgtMacHeaderInit(
 	IRQL = DISPATCH_LEVEL
 
  ****************************************************************************/
-ULONG MakeOutgoingFrame(
-	OUT UCHAR *Buffer,
-	OUT ULONG *FrameLen, ...)
-{
-	UCHAR   *p;
-	int	leng;
-	ULONG	TotLeng;
+ULONG MakeOutgoingFrame(OUT UCHAR * Buffer, OUT ULONG * FrameLen, ...)
+{
+	UCHAR *p;
+	int leng;
+	ULONG TotLeng;
 	va_list Args;
 
 	// calculates the total length
 	TotLeng = 0;
 	va_start(Args, FrameLen);
-	do
-	{
+	do {
 		leng = va_arg(Args, int);
-		if (leng == END_OF_ARGS)
-		{
+		if (leng == END_OF_ARGS) {
 			break;
-	}
+		}
 		p = va_arg(Args, PVOID);
 		NdisMoveMemory(&Buffer[TotLeng], p, leng);
 		TotLeng = TotLeng + leng;
-	} while(TRUE);
+	} while (TRUE);
 
-	va_end(Args); /* clean up */
+	va_end(Args);		/* clean up */
 	*FrameLen = TotLeng;
 	return TotLeng;
 }
@@ -4533,19 +4653,17 @@ ULONG MakeOutgoingFrame(
  IRQL = PASSIVE_LEVEL
 
  */
-NDIS_STATUS MlmeQueueInit(
-	IN MLME_QUEUE *Queue)
+NDIS_STATUS MlmeQueueInit(IN MLME_QUEUE * Queue)
 {
 	INT i;
 
 	NdisAllocateSpinLock(&Queue->Lock);
 
-	Queue->Num	= 0;
+	Queue->Num = 0;
 	Queue->Head = 0;
 	Queue->Tail = 0;
 
-	for (i = 0; i < MAX_LEN_OF_MLME_QUEUE; i++)
-	{
+	for (i = 0; i < MAX_LEN_OF_MLME_QUEUE; i++) {
 		Queue->Entry[i].Occupied = FALSE;
 		Queue->Entry[i].MsgLen = 0;
 		NdisZeroMemory(Queue->Entry[i].Msg, MGMT_DMA_BUFFER_SIZE);
@@ -4569,52 +4687,47 @@ NDIS_STATUS MlmeQueueInit(
 	IRQL = DISPATCH_LEVEL
 
  */
-BOOLEAN MlmeEnqueue(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG Machine,
-	IN ULONG MsgType,
-	IN ULONG MsgLen,
-	IN VOID *Msg)
+BOOLEAN MlmeEnqueue(IN PRTMP_ADAPTER pAd,
+		    IN ULONG Machine,
+		    IN ULONG MsgType, IN ULONG MsgLen, IN VOID * Msg)
 {
 	INT Tail;
-	MLME_QUEUE	*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
+	MLME_QUEUE *Queue = (MLME_QUEUE *) & pAd->Mlme.Queue;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return FALSE;
 
 	// First check the size, it MUST not exceed the mlme queue size
-	if (MsgLen > MGMT_DMA_BUFFER_SIZE)
-		{
-		DBGPRINT_ERR(("MlmeEnqueue: msg too large, size = %ld \n", MsgLen));
+	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
+		DBGPRINT_ERR(("MlmeEnqueue: msg too large, size = %ld \n",
+			      MsgLen));
 		return FALSE;
 	}
 
-	if (MlmeQueueFull(Queue))
-		{
+	if (MlmeQueueFull(Queue)) {
 		return FALSE;
-			}
+	}
 
 	NdisAcquireSpinLock(&(Queue->Lock));
 	Tail = Queue->Tail;
 	Queue->Tail++;
 	Queue->Num++;
-	if (Queue->Tail == MAX_LEN_OF_MLME_QUEUE)
-			{
+	if (Queue->Tail == MAX_LEN_OF_MLME_QUEUE) {
 		Queue->Tail = 0;
-		}
+	}
 
 	Queue->Entry[Tail].Wcid = RESERVED_WCID;
 	Queue->Entry[Tail].Occupied = TRUE;
 	Queue->Entry[Tail].Machine = Machine;
 	Queue->Entry[Tail].MsgType = MsgType;
-	Queue->Entry[Tail].MsgLen  = MsgLen;
+	Queue->Entry[Tail].MsgLen = MsgLen;
 
-	if (Msg != NULL)
-			{
+	if (Msg != NULL) {
 		NdisMoveMemory(Queue->Entry[Tail].Msg, Msg, MsgLen);
-		}
+	}
 
 	NdisReleaseSpinLock(&(Queue->Lock));
 	return TRUE;
@@ -4634,77 +4747,68 @@ BOOLEAN MlmeEnqueue(
  IRQL = DISPATCH_LEVEL
 
  */
-BOOLEAN MlmeEnqueueForRecv(
-	IN	PRTMP_ADAPTER	pAd,
-	IN ULONG Wcid,
-	IN ULONG TimeStampHigh,
-	IN ULONG TimeStampLow,
-	IN UCHAR Rssi0,
-	IN UCHAR Rssi1,
-	IN UCHAR Rssi2,
-	IN ULONG MsgLen,
-	IN VOID *Msg,
-	IN UCHAR Signal)
-{
-	INT		 Tail, Machine;
-	PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
-	INT		 MsgType;
-	MLME_QUEUE	*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
-
+BOOLEAN MlmeEnqueueForRecv(IN PRTMP_ADAPTER pAd,
+			   IN ULONG Wcid,
+			   IN ULONG TimeStampHigh,
+			   IN ULONG TimeStampLow,
+			   IN UCHAR Rssi0,
+			   IN UCHAR Rssi1,
+			   IN UCHAR Rssi2,
+			   IN ULONG MsgLen, IN VOID * Msg, IN UCHAR Signal)
+{
+	INT Tail, Machine;
+	PFRAME_802_11 pFrame = (PFRAME_802_11) Msg;
+	INT MsgType;
+	MLME_QUEUE *Queue = (MLME_QUEUE *) & pAd->Mlme.Queue;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
-	{
+	if (RTMP_TEST_FLAG
+	    (pAd,
+	     fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST)) {
 		DBGPRINT_ERR(("MlmeEnqueueForRecv: fRTMP_ADAPTER_HALT_IN_PROGRESS\n"));
 		return FALSE;
 	}
-
 	// First check the size, it MUST not exceed the mlme queue size
-	if (MsgLen > MGMT_DMA_BUFFER_SIZE)
-	{
+	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
 		DBGPRINT_ERR(("MlmeEnqueueForRecv: frame too large, size = %ld \n", MsgLen));
 		return FALSE;
 	}
 
-	if (MlmeQueueFull(Queue))
-		{
+	if (MlmeQueueFull(Queue)) {
 		return FALSE;
 	}
 
-			{
-		if (!MsgTypeSubst(pAd, pFrame, &Machine, &MsgType))
-		{
-			DBGPRINT_ERR(("MlmeEnqueueForRecv: un-recongnized mgmt->subtype=%d\n",pFrame->Hdr.FC.SubType));
+	{
+		if (!MsgTypeSubst(pAd, pFrame, &Machine, &MsgType)) {
+			DBGPRINT_ERR(("MlmeEnqueueForRecv: un-recongnized mgmt->subtype=%d\n", pFrame->Hdr.FC.SubType));
 			return FALSE;
-			}
 		}
+	}
 
 	// OK, we got all the informations, it is time to put things into queue
 	NdisAcquireSpinLock(&(Queue->Lock));
 	Tail = Queue->Tail;
 	Queue->Tail++;
 	Queue->Num++;
-	if (Queue->Tail == MAX_LEN_OF_MLME_QUEUE)
-		{
+	if (Queue->Tail == MAX_LEN_OF_MLME_QUEUE) {
 		Queue->Tail = 0;
-		}
+	}
 	Queue->Entry[Tail].Occupied = TRUE;
 	Queue->Entry[Tail].Machine = Machine;
 	Queue->Entry[Tail].MsgType = MsgType;
-	Queue->Entry[Tail].MsgLen  = MsgLen;
+	Queue->Entry[Tail].MsgLen = MsgLen;
 	Queue->Entry[Tail].TimeStamp.u.LowPart = TimeStampLow;
 	Queue->Entry[Tail].TimeStamp.u.HighPart = TimeStampHigh;
 	Queue->Entry[Tail].Rssi0 = Rssi0;
 	Queue->Entry[Tail].Rssi1 = Rssi1;
 	Queue->Entry[Tail].Rssi2 = Rssi2;
 	Queue->Entry[Tail].Signal = Signal;
-	Queue->Entry[Tail].Wcid = (UCHAR)Wcid;
+	Queue->Entry[Tail].Wcid = (UCHAR) Wcid;
 
 	Queue->Entry[Tail].Channel = pAd->LatchRfRegs.Channel;
 
-	if (Msg != NULL)
-	{
+	if (Msg != NULL) {
 		NdisMoveMemory(Queue->Entry[Tail].Msg, Msg, MsgLen);
 	}
 
@@ -4715,7 +4819,6 @@ BOOLEAN MlmeEnqueueForRecv(
 	return TRUE;
 }
 
-
 /*! \brief	 Dequeue a message from the MLME Queue
  *	\param	*Queue	  The MLME Queue
  *	\param	*Elem	  The message dequeued from MLME Queue
@@ -4726,16 +4829,13 @@ BOOLEAN MlmeEnqueueForRecv(
  IRQL = DISPATCH_LEVEL
 
  */
-BOOLEAN MlmeDequeue(
-	IN MLME_QUEUE *Queue,
-	OUT MLME_QUEUE_ELEM **Elem)
+BOOLEAN MlmeDequeue(IN MLME_QUEUE * Queue, OUT MLME_QUEUE_ELEM ** Elem)
 {
 	NdisAcquireSpinLock(&(Queue->Lock));
 	*Elem = &(Queue->Entry[Queue->Head]);
 	Queue->Num--;
 	Queue->Head++;
-	if (Queue->Head == MAX_LEN_OF_MLME_QUEUE)
-	{
+	if (Queue->Head == MAX_LEN_OF_MLME_QUEUE) {
 		Queue->Head = 0;
 	}
 	NdisReleaseSpinLock(&(Queue->Lock));
@@ -4743,55 +4843,48 @@ BOOLEAN MlmeDequeue(
 }
 
 // IRQL = DISPATCH_LEVEL
-VOID	MlmeRestartStateMachine(
-	IN	PRTMP_ADAPTER	pAd)
+VOID MlmeRestartStateMachine(IN PRTMP_ADAPTER pAd)
 {
 #ifdef RTMP_MAC_PCI
-	MLME_QUEUE_ELEM		*Elem = NULL;
+	MLME_QUEUE_ELEM *Elem = NULL;
 #endif // RTMP_MAC_PCI //
-	BOOLEAN				Cancelled;
+	BOOLEAN Cancelled;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("MlmeRestartStateMachine \n"));
 
 #ifdef RTMP_MAC_PCI
 	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
-	if(pAd->Mlme.bRunning)
-	{
+	if (pAd->Mlme.bRunning) {
 		NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
 		return;
-	}
-	else
-	{
+	} else {
 		pAd->Mlme.bRunning = TRUE;
 	}
 	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
 
 	// Remove all Mlme queues elements
-	while (!MlmeQueueEmpty(&pAd->Mlme.Queue))
-	{
+	while (!MlmeQueueEmpty(&pAd->Mlme.Queue)) {
 		//From message type, determine which state machine I should drive
-		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem))
-		{
+		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
 			// free MLME element
 			Elem->Occupied = FALSE;
 			Elem->MsgLen = 0;
 
-		}
-		else {
+		} else {
 			DBGPRINT_ERR(("MlmeRestartStateMachine: MlmeQueue empty\n"));
-	}
+		}
 	}
 #endif // RTMP_MAC_PCI //
 
 	{
 		// Cancel all timer events
 		// Be careful to cancel new added timer
-		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,	  &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,   &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,  &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,	   &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,	   &Cancelled);
-		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,	   &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
 
 	}
 
@@ -4804,12 +4897,12 @@ VOID	MlmeRestartStateMachine(
 
 	{
 		// Set all state machines back IDLE
-		pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
-		pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
-		pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
 		pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
-		pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
-		pAd->Mlme.ActMachine.CurrState    = ACT_IDLE;
+		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+		pAd->Mlme.ActMachine.CurrState = ACT_IDLE;
 	}
 
 #ifdef RTMP_MAC_PCI
@@ -4829,8 +4922,7 @@ VOID	MlmeRestartStateMachine(
  IRQL = DISPATCH_LEVEL
 
  */
-BOOLEAN MlmeQueueEmpty(
-	IN MLME_QUEUE *Queue)
+BOOLEAN MlmeQueueEmpty(IN MLME_QUEUE * Queue)
 {
 	BOOLEAN Ans;
 
@@ -4851,13 +4943,13 @@ BOOLEAN MlmeQueueEmpty(
  IRQL = DISPATCH_LEVEL
 
  */
-BOOLEAN MlmeQueueFull(
-	IN MLME_QUEUE *Queue)
+BOOLEAN MlmeQueueFull(IN MLME_QUEUE * Queue)
 {
 	BOOLEAN Ans;
 
 	NdisAcquireSpinLock(&(Queue->Lock));
-	Ans = (Queue->Num == MAX_LEN_OF_MLME_QUEUE || Queue->Entry[Queue->Tail].Occupied);
+	Ans = (Queue->Num == MAX_LEN_OF_MLME_QUEUE
+	       || Queue->Entry[Queue->Tail].Occupied);
 	NdisReleaseSpinLock(&(Queue->Lock));
 
 	return Ans;
@@ -4873,18 +4965,16 @@ BOOLEAN MlmeQueueFull(
  IRQL = PASSIVE_LEVEL
 
  */
-VOID MlmeQueueDestroy(
-	IN MLME_QUEUE *pQueue)
+VOID MlmeQueueDestroy(IN MLME_QUEUE * pQueue)
 {
 	NdisAcquireSpinLock(&(pQueue->Lock));
-	pQueue->Num  = 0;
+	pQueue->Num = 0;
 	pQueue->Head = 0;
 	pQueue->Tail = 0;
 	NdisReleaseSpinLock(&(pQueue->Lock));
 	NdisFreeSpinLock(&(pQueue->Lock));
 }
 
-
 /*! \brief	 To substitute the message type if the message is coming from external
  *	\param	pFrame		   The frame received
  *	\param	*Machine	   The state machine
@@ -4896,108 +4986,97 @@ VOID MlmeQueueDestroy(
  IRQL = DISPATCH_LEVEL
 
  */
-BOOLEAN MsgTypeSubst(
-	IN PRTMP_ADAPTER  pAd,
-	IN PFRAME_802_11 pFrame,
-	OUT INT *Machine,
-	OUT INT *MsgType)
-{
-	USHORT	Seq, Alg;
-	UCHAR	EAPType;
-	PUCHAR	pData;
+BOOLEAN MsgTypeSubst(IN PRTMP_ADAPTER pAd,
+		     IN PFRAME_802_11 pFrame,
+		     OUT INT * Machine, OUT INT * MsgType)
+{
+	USHORT Seq, Alg;
+	UCHAR EAPType;
+	PUCHAR pData;
 
 	// Pointer to start of data frames including SNAP header
 	pData = (PUCHAR) pFrame + LENGTH_802_11;
 
 	// The only data type will pass to this function is EAPOL frame
-	if (pFrame->Hdr.FC.Type == BTYPE_DATA)
-	{
+	if (pFrame->Hdr.FC.Type == BTYPE_DATA) {
 		{
-	        *Machine = WPA_STATE_MACHINE;
-			EAPType = *((UCHAR*)pFrame + LENGTH_802_11 + LENGTH_802_1_H + 1);
-	        return (WpaMsgTypeSubst(EAPType, (INT *) MsgType));
+			*Machine = WPA_STATE_MACHINE;
+			EAPType =
+			    *((UCHAR *) pFrame + LENGTH_802_11 +
+			      LENGTH_802_1_H + 1);
+			return (WpaMsgTypeSubst(EAPType, (INT *) MsgType));
 		}
 	}
 
-	switch (pFrame->Hdr.FC.SubType)
-	{
-		case SUBTYPE_ASSOC_REQ:
-			*Machine = ASSOC_STATE_MACHINE;
-			*MsgType = MT2_PEER_ASSOC_REQ;
-			break;
-		case SUBTYPE_ASSOC_RSP:
-			*Machine = ASSOC_STATE_MACHINE;
-			*MsgType = MT2_PEER_ASSOC_RSP;
-			break;
-		case SUBTYPE_REASSOC_REQ:
-			*Machine = ASSOC_STATE_MACHINE;
-			*MsgType = MT2_PEER_REASSOC_REQ;
-			break;
-		case SUBTYPE_REASSOC_RSP:
-			*Machine = ASSOC_STATE_MACHINE;
-			*MsgType = MT2_PEER_REASSOC_RSP;
-			break;
-		case SUBTYPE_PROBE_REQ:
-			*Machine = SYNC_STATE_MACHINE;
-			*MsgType = MT2_PEER_PROBE_REQ;
-			break;
-		case SUBTYPE_PROBE_RSP:
-			*Machine = SYNC_STATE_MACHINE;
-			*MsgType = MT2_PEER_PROBE_RSP;
-			break;
-		case SUBTYPE_BEACON:
-			*Machine = SYNC_STATE_MACHINE;
-			*MsgType = MT2_PEER_BEACON;
-			break;
-		case SUBTYPE_ATIM:
-			*Machine = SYNC_STATE_MACHINE;
-			*MsgType = MT2_PEER_ATIM;
-			break;
-		case SUBTYPE_DISASSOC:
-			*Machine = ASSOC_STATE_MACHINE;
-			*MsgType = MT2_PEER_DISASSOC_REQ;
-			break;
-		case SUBTYPE_AUTH:
-			// get the sequence number from payload 24 Mac Header + 2 bytes algorithm
-			NdisMoveMemory(&Seq, &pFrame->Octet[2], sizeof(USHORT));
-			NdisMoveMemory(&Alg, &pFrame->Octet[0], sizeof(USHORT));
-			if (Seq == 1 || Seq == 3)
-		{
-				*Machine = AUTH_RSP_STATE_MACHINE;
-				*MsgType = MT2_PEER_AUTH_ODD;
-	}
-			else if (Seq == 2 || Seq == 4)
-	{
-				if (Alg == AUTH_MODE_OPEN || Alg == AUTH_MODE_KEY)
-		{
-					*Machine = AUTH_STATE_MACHINE;
-					*MsgType = MT2_PEER_AUTH_EVEN;
-		}
-	}
-			else
-	{
-				return FALSE;
-			}
-			break;
-		case SUBTYPE_DEAUTH:
+	switch (pFrame->Hdr.FC.SubType) {
+	case SUBTYPE_ASSOC_REQ:
+		*Machine = ASSOC_STATE_MACHINE;
+		*MsgType = MT2_PEER_ASSOC_REQ;
+		break;
+	case SUBTYPE_ASSOC_RSP:
+		*Machine = ASSOC_STATE_MACHINE;
+		*MsgType = MT2_PEER_ASSOC_RSP;
+		break;
+	case SUBTYPE_REASSOC_REQ:
+		*Machine = ASSOC_STATE_MACHINE;
+		*MsgType = MT2_PEER_REASSOC_REQ;
+		break;
+	case SUBTYPE_REASSOC_RSP:
+		*Machine = ASSOC_STATE_MACHINE;
+		*MsgType = MT2_PEER_REASSOC_RSP;
+		break;
+	case SUBTYPE_PROBE_REQ:
+		*Machine = SYNC_STATE_MACHINE;
+		*MsgType = MT2_PEER_PROBE_REQ;
+		break;
+	case SUBTYPE_PROBE_RSP:
+		*Machine = SYNC_STATE_MACHINE;
+		*MsgType = MT2_PEER_PROBE_RSP;
+		break;
+	case SUBTYPE_BEACON:
+		*Machine = SYNC_STATE_MACHINE;
+		*MsgType = MT2_PEER_BEACON;
+		break;
+	case SUBTYPE_ATIM:
+		*Machine = SYNC_STATE_MACHINE;
+		*MsgType = MT2_PEER_ATIM;
+		break;
+	case SUBTYPE_DISASSOC:
+		*Machine = ASSOC_STATE_MACHINE;
+		*MsgType = MT2_PEER_DISASSOC_REQ;
+		break;
+	case SUBTYPE_AUTH:
+		// get the sequence number from payload 24 Mac Header + 2 bytes algorithm
+		NdisMoveMemory(&Seq, &pFrame->Octet[2], sizeof(USHORT));
+		NdisMoveMemory(&Alg, &pFrame->Octet[0], sizeof(USHORT));
+		if (Seq == 1 || Seq == 3) {
 			*Machine = AUTH_RSP_STATE_MACHINE;
-			*MsgType = MT2_PEER_DEAUTH;
-			break;
-		case SUBTYPE_ACTION:
-			*Machine = ACTION_STATE_MACHINE;
-			//  Sometimes Sta will return with category bytes with MSB = 1, if they receive catogory out of their support
-			if ((pFrame->Octet[0]&0x7F) > MAX_PEER_CATE_MSG)
-		{
-				*MsgType = MT2_ACT_INVALID;
+			*MsgType = MT2_PEER_AUTH_ODD;
+		} else if (Seq == 2 || Seq == 4) {
+			if (Alg == AUTH_MODE_OPEN || Alg == AUTH_MODE_KEY) {
+				*Machine = AUTH_STATE_MACHINE;
+				*MsgType = MT2_PEER_AUTH_EVEN;
+			}
+		} else {
+			return FALSE;
 		}
-		else
-		{
-				*MsgType = (pFrame->Octet[0]&0x7F);
+		break;
+	case SUBTYPE_DEAUTH:
+		*Machine = AUTH_RSP_STATE_MACHINE;
+		*MsgType = MT2_PEER_DEAUTH;
+		break;
+	case SUBTYPE_ACTION:
+		*Machine = ACTION_STATE_MACHINE;
+		//  Sometimes Sta will return with category bytes with MSB = 1, if they receive catogory out of their support
+		if ((pFrame->Octet[0] & 0x7F) > MAX_PEER_CATE_MSG) {
+			*MsgType = MT2_ACT_INVALID;
+		} else {
+			*MsgType = (pFrame->Octet[0] & 0x7F);
 		}
-			break;
-		default:
-			return FALSE;
-			break;
+		break;
+	default:
+		return FALSE;
+		break;
 	}
 
 	return TRUE;
@@ -5021,29 +5100,25 @@ BOOLEAN MsgTypeSubst(
  IRQL = PASSIVE_LEVEL
 
  */
-VOID StateMachineInit(
-	IN STATE_MACHINE *S,
-	IN STATE_MACHINE_FUNC Trans[],
-	IN ULONG StNr,
-	IN ULONG MsgNr,
-	IN STATE_MACHINE_FUNC DefFunc,
-	IN ULONG InitState,
-	IN ULONG Base)
+VOID StateMachineInit(IN STATE_MACHINE * S,
+		      IN STATE_MACHINE_FUNC Trans[],
+		      IN ULONG StNr,
+		      IN ULONG MsgNr,
+		      IN STATE_MACHINE_FUNC DefFunc,
+		      IN ULONG InitState, IN ULONG Base)
 {
 	ULONG i, j;
 
 	// set number of states and messages
 	S->NrState = StNr;
-	S->NrMsg   = MsgNr;
-	S->Base    = Base;
+	S->NrMsg = MsgNr;
+	S->Base = Base;
 
-	S->TransFunc  = Trans;
+	S->TransFunc = Trans;
 
 	// init all state transition to default function
-	for (i = 0; i < StNr; i++)
-	{
-		for (j = 0; j < MsgNr; j++)
-		{
+	for (i = 0; i < StNr; i++) {
+		for (j = 0; j < MsgNr; j++) {
 			S->TransFunc[i * MsgNr + j] = DefFunc;
 		}
 	}
@@ -5063,18 +5138,15 @@ VOID StateMachineInit(
  IRQL = PASSIVE_LEVEL
 
  */
-VOID StateMachineSetAction(
-	IN STATE_MACHINE *S,
-	IN ULONG St,
-	IN ULONG Msg,
-	IN STATE_MACHINE_FUNC Func)
+VOID StateMachineSetAction(IN STATE_MACHINE * S,
+			   IN ULONG St,
+			   IN ULONG Msg, IN STATE_MACHINE_FUNC Func)
 {
 	ULONG MsgIdx;
 
 	MsgIdx = Msg - S->Base;
 
-	if (St < S->NrState && MsgIdx < S->NrMsg)
-	{
+	if (St < S->NrState && MsgIdx < S->NrMsg) {
 		// boundary checking before setting the action
 		S->TransFunc[St * S->NrMsg + MsgIdx] = Func;
 	}
@@ -5089,12 +5161,11 @@ VOID StateMachineSetAction(
  IRQL = DISPATCH_LEVEL
 
  */
-VOID StateMachinePerformAction(
-	IN	PRTMP_ADAPTER	pAd,
-	IN STATE_MACHINE *S,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID StateMachinePerformAction(IN PRTMP_ADAPTER pAd,
+			       IN STATE_MACHINE * S, IN MLME_QUEUE_ELEM * Elem)
 {
-	(*(S->TransFunc[S->CurrState * S->NrMsg + Elem->MsgType - S->Base]))(pAd, Elem);
+	(*(S->TransFunc[S->CurrState * S->NrMsg + Elem->MsgType - S->Base]))
+	    (pAd, Elem);
 }
 
 /*
@@ -5105,9 +5176,7 @@ VOID StateMachinePerformAction(
 		StateMachinePerformAction()
 	==========================================================================
  */
-VOID Drop(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID Drop(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 }
 
@@ -5123,9 +5192,7 @@ VOID Drop(
 
 	==========================================================================
  */
-VOID LfsrInit(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG Seed)
+VOID LfsrInit(IN PRTMP_ADAPTER pAd, IN ULONG Seed)
 {
 	if (Seed == 0)
 		pAd->Mlme.ShiftReg = 1;
@@ -5138,8 +5205,7 @@ VOID LfsrInit(
 	Description:
 	==========================================================================
  */
-UCHAR RandomByte(
-	IN PRTMP_ADAPTER pAd)
+UCHAR RandomByte(IN PRTMP_ADAPTER pAd)
 {
 	ULONG i;
 	UCHAR R, Result;
@@ -5147,17 +5213,15 @@ UCHAR RandomByte(
 	R = 0;
 
 	if (pAd->Mlme.ShiftReg == 0)
-	NdisGetSystemUpTime((ULONG *)&pAd->Mlme.ShiftReg);
+		NdisGetSystemUpTime((ULONG *) & pAd->Mlme.ShiftReg);
 
-	for (i = 0; i < 8; i++)
-	{
-		if (pAd->Mlme.ShiftReg & 0x00000001)
-		{
-			pAd->Mlme.ShiftReg = ((pAd->Mlme.ShiftReg ^ LFSR_MASK) >> 1) | 0x80000000;
+	for (i = 0; i < 8; i++) {
+		if (pAd->Mlme.ShiftReg & 0x00000001) {
+			pAd->Mlme.ShiftReg =
+			    ((pAd->Mlme.
+			      ShiftReg ^ LFSR_MASK) >> 1) | 0x80000000;
 			Result = 1;
-	}
-	else
-	{
+		} else {
 			pAd->Mlme.ShiftReg = pAd->Mlme.ShiftReg >> 1;
 			Result = 0;
 		}
@@ -5167,7 +5231,6 @@ UCHAR RandomByte(
 	return R;
 }
 
-
 /*
 	========================================================================
 
@@ -5184,13 +5247,11 @@ UCHAR RandomByte(
 
 	========================================================================
 */
-VOID	RTMPCheckRates(
-	IN		PRTMP_ADAPTER	pAd,
-	IN OUT	UCHAR			SupRate[],
-	IN OUT	UCHAR			*SupRateLen)
+VOID RTMPCheckRates(IN PRTMP_ADAPTER pAd,
+		    IN OUT UCHAR SupRate[], IN OUT UCHAR * SupRateLen)
 {
-	UCHAR	RateIdx, i, j;
-	UCHAR	NewRate[12], NewRateLen;
+	UCHAR RateIdx, i, j;
+	UCHAR NewRate[12], NewRateLen;
 
 	NewRateLen = 0;
 
@@ -5209,43 +5270,37 @@ VOID	RTMPCheckRates(
 	NdisMoveMemory(SupRate, NewRate, NewRateLen);
 }
 
-BOOLEAN RTMPCheckChannel(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		CentralChannel,
-	IN UCHAR		Channel)
-{
-	UCHAR		k;
-	UCHAR		UpperChannel = 0, LowerChannel = 0;
-	UCHAR		NoEffectChannelinList = 0;
+BOOLEAN RTMPCheckChannel(IN PRTMP_ADAPTER pAd,
+			 IN UCHAR CentralChannel, IN UCHAR Channel)
+{
+	UCHAR k;
+	UCHAR UpperChannel = 0, LowerChannel = 0;
+	UCHAR NoEffectChannelinList = 0;
 
 	// Find upper and lower channel according to 40MHz current operation.
-	if (CentralChannel < Channel)
-	{
+	if (CentralChannel < Channel) {
 		UpperChannel = Channel;
 		if (CentralChannel > 2)
 			LowerChannel = CentralChannel - 2;
 		else
 			return FALSE;
-	}
-	else if (CentralChannel > Channel)
-	{
+	} else if (CentralChannel > Channel) {
 		UpperChannel = CentralChannel + 2;
 		LowerChannel = Channel;
 	}
 
-	for (k = 0;k < pAd->ChannelListNum;k++)
-	{
-		if (pAd->ChannelList[k].Channel == UpperChannel)
-		{
-			NoEffectChannelinList ++;
+	for (k = 0; k < pAd->ChannelListNum; k++) {
+		if (pAd->ChannelList[k].Channel == UpperChannel) {
+			NoEffectChannelinList++;
 		}
-		if (pAd->ChannelList[k].Channel == LowerChannel)
-		{
-			NoEffectChannelinList ++;
+		if (pAd->ChannelList[k].Channel == LowerChannel) {
+			NoEffectChannelinList++;
 		}
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("Total Channel in Channel List = [%d]\n", NoEffectChannelinList));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Total Channel in Channel List = [%d]\n",
+		  NoEffectChannelinList));
 	if (NoEffectChannelinList == 2)
 		return TRUE;
 	else
@@ -5268,88 +5323,114 @@ BOOLEAN RTMPCheckChannel(
 
 	========================================================================
 */
-BOOLEAN 	RTMPCheckHt(
-	IN	PRTMP_ADAPTER			pAd,
-	IN	UCHAR					Wcid,
-	IN 	HT_CAPABILITY_IE		*pHtCapability,
-	IN 	ADD_HT_INFO_IE			*pAddHtInfo)
+BOOLEAN RTMPCheckHt(IN PRTMP_ADAPTER pAd,
+		    IN UCHAR Wcid,
+		    IN HT_CAPABILITY_IE * pHtCapability,
+		    IN ADD_HT_INFO_IE * pAddHtInfo)
 {
 	if (Wcid >= MAX_LEN_OF_MAC_TABLE)
 		return FALSE;
 
 	// If use AMSDU, set flag.
 	if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_AMSDU_INUSED);
+		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
+				       fCLIENT_STATUS_AMSDU_INUSED);
 	// Save Peer Capability
 	if (pHtCapability->HtCapInfo.ShortGIfor20)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_SGI20_CAPABLE);
+		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
+				       fCLIENT_STATUS_SGI20_CAPABLE);
 	if (pHtCapability->HtCapInfo.ShortGIfor40)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_SGI40_CAPABLE);
+		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
+				       fCLIENT_STATUS_SGI40_CAPABLE);
 	if (pHtCapability->HtCapInfo.TxSTBC)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_TxSTBC_CAPABLE);
+		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
+				       fCLIENT_STATUS_TxSTBC_CAPABLE);
 	if (pHtCapability->HtCapInfo.RxSTBC)
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_RxSTBC_CAPABLE);
-	if (pAd->CommonCfg.bRdg && pHtCapability->ExtHtCapInfo.RDGSupport)
-	{
-		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_RDG_CAPABLE);
+		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
+				       fCLIENT_STATUS_RxSTBC_CAPABLE);
+	if (pAd->CommonCfg.bRdg && pHtCapability->ExtHtCapInfo.RDGSupport) {
+		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
+				       fCLIENT_STATUS_RDG_CAPABLE);
 	}
 
-	if (Wcid < MAX_LEN_OF_MAC_TABLE)
-	{
-		pAd->MacTab.Content[Wcid].MpduDensity = pHtCapability->HtCapParm.MpduDensity;
+	if (Wcid < MAX_LEN_OF_MAC_TABLE) {
+		pAd->MacTab.Content[Wcid].MpduDensity =
+		    pHtCapability->HtCapParm.MpduDensity;
 	}
-
 	// Will check ChannelWidth for MCSSet[4] below
 	pAd->MlmeAux.HtCapability.MCSSet[4] = 0x1;
-    switch (pAd->CommonCfg.RxStream)
-	{
-		case 1:
-			pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
-			pAd->MlmeAux.HtCapability.MCSSet[1] = 0x00;
-            pAd->MlmeAux.HtCapability.MCSSet[2] = 0x00;
-            pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
-			break;
-		case 2:
-			pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
-			pAd->MlmeAux.HtCapability.MCSSet[1] = 0xff;
-            pAd->MlmeAux.HtCapability.MCSSet[2] = 0x00;
-            pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
-			break;
-		case 3:
-			pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
-			pAd->MlmeAux.HtCapability.MCSSet[1] = 0xff;
-            pAd->MlmeAux.HtCapability.MCSSet[2] = 0xff;
-            pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
-			break;
-	}
-
-	pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth = pAddHtInfo->AddHtInfo.RecomWidth & pAd->CommonCfg.DesiredHtPhy.ChannelWidth;
+	switch (pAd->CommonCfg.RxStream) {
+	case 1:
+		pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
+		pAd->MlmeAux.HtCapability.MCSSet[1] = 0x00;
+		pAd->MlmeAux.HtCapability.MCSSet[2] = 0x00;
+		pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
+		break;
+	case 2:
+		pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
+		pAd->MlmeAux.HtCapability.MCSSet[1] = 0xff;
+		pAd->MlmeAux.HtCapability.MCSSet[2] = 0x00;
+		pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
+		break;
+	case 3:
+		pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
+		pAd->MlmeAux.HtCapability.MCSSet[1] = 0xff;
+		pAd->MlmeAux.HtCapability.MCSSet[2] = 0xff;
+		pAd->MlmeAux.HtCapability.MCSSet[3] = 0x00;
+		break;
+	}
+
+	pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth =
+	    pAddHtInfo->AddHtInfo.RecomWidth & pAd->CommonCfg.DesiredHtPhy.
+	    ChannelWidth;
+
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPCheckHt:: HtCapInfo.ChannelWidth=%d, RecomWidth=%d, DesiredHtPhy.ChannelWidth=%d, BW40MAvailForA/G=%d/%d, PhyMode=%d \n",
+		  pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth,
+		  pAddHtInfo->AddHtInfo.RecomWidth,
+		  pAd->CommonCfg.DesiredHtPhy.ChannelWidth,
+		  pAd->NicConfig2.field.BW40MAvailForA,
+		  pAd->NicConfig2.field.BW40MAvailForG,
+		  pAd->CommonCfg.PhyMode));
 
-    DBGPRINT(RT_DEBUG_TRACE, ("RTMPCheckHt:: HtCapInfo.ChannelWidth=%d, RecomWidth=%d, DesiredHtPhy.ChannelWidth=%d, BW40MAvailForA/G=%d/%d, PhyMode=%d \n",
-		pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth, pAddHtInfo->AddHtInfo.RecomWidth, pAd->CommonCfg.DesiredHtPhy.ChannelWidth,
-		pAd->NicConfig2.field.BW40MAvailForA, pAd->NicConfig2.field.BW40MAvailForG, pAd->CommonCfg.PhyMode));
-
-	pAd->MlmeAux.HtCapability.HtCapInfo.GF =  pHtCapability->HtCapInfo.GF &pAd->CommonCfg.DesiredHtPhy.GF;
+	pAd->MlmeAux.HtCapability.HtCapInfo.GF =
+	    pHtCapability->HtCapInfo.GF & pAd->CommonCfg.DesiredHtPhy.GF;
 
 	// Send Assoc Req with my HT capability.
-	pAd->MlmeAux.HtCapability.HtCapInfo.AMsduSize =  pAd->CommonCfg.DesiredHtPhy.AmsduSize;
-	pAd->MlmeAux.HtCapability.HtCapInfo.MimoPs =  pAd->CommonCfg.DesiredHtPhy.MimoPs;
-	pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor20 =  (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20) & (pHtCapability->HtCapInfo.ShortGIfor20);
-	pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor40 =  (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40) & (pHtCapability->HtCapInfo.ShortGIfor40);
-	pAd->MlmeAux.HtCapability.HtCapInfo.TxSTBC =  (pAd->CommonCfg.DesiredHtPhy.TxSTBC)&(pHtCapability->HtCapInfo.RxSTBC);
-	pAd->MlmeAux.HtCapability.HtCapInfo.RxSTBC =  (pAd->CommonCfg.DesiredHtPhy.RxSTBC)&(pHtCapability->HtCapInfo.TxSTBC);
-	pAd->MlmeAux.HtCapability.HtCapParm.MaxRAmpduFactor = pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor;
-    pAd->MlmeAux.HtCapability.HtCapParm.MpduDensity = pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity;
-	pAd->MlmeAux.HtCapability.ExtHtCapInfo.PlusHTC = pHtCapability->ExtHtCapInfo.PlusHTC;
-	pAd->MacTab.Content[Wcid].HTCapability.ExtHtCapInfo.PlusHTC = pHtCapability->ExtHtCapInfo.PlusHTC;
-	if (pAd->CommonCfg.bRdg)
-	{
-		pAd->MlmeAux.HtCapability.ExtHtCapInfo.RDGSupport = pHtCapability->ExtHtCapInfo.RDGSupport;
-        pAd->MlmeAux.HtCapability.ExtHtCapInfo.PlusHTC = 1;
+	pAd->MlmeAux.HtCapability.HtCapInfo.AMsduSize =
+	    pAd->CommonCfg.DesiredHtPhy.AmsduSize;
+	pAd->MlmeAux.HtCapability.HtCapInfo.MimoPs =
+	    pAd->CommonCfg.DesiredHtPhy.MimoPs;
+	pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor20 =
+	    (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20) & (pHtCapability->
+							  HtCapInfo.
+							  ShortGIfor20);
+	pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor40 =
+	    (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40) & (pHtCapability->
+							  HtCapInfo.
+							  ShortGIfor40);
+	pAd->MlmeAux.HtCapability.HtCapInfo.TxSTBC =
+	    (pAd->CommonCfg.DesiredHtPhy.TxSTBC) & (pHtCapability->HtCapInfo.
+						    RxSTBC);
+	pAd->MlmeAux.HtCapability.HtCapInfo.RxSTBC =
+	    (pAd->CommonCfg.DesiredHtPhy.RxSTBC) & (pHtCapability->HtCapInfo.
+						    TxSTBC);
+	pAd->MlmeAux.HtCapability.HtCapParm.MaxRAmpduFactor =
+	    pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor;
+	pAd->MlmeAux.HtCapability.HtCapParm.MpduDensity =
+	    pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity;
+	pAd->MlmeAux.HtCapability.ExtHtCapInfo.PlusHTC =
+	    pHtCapability->ExtHtCapInfo.PlusHTC;
+	pAd->MacTab.Content[Wcid].HTCapability.ExtHtCapInfo.PlusHTC =
+	    pHtCapability->ExtHtCapInfo.PlusHTC;
+	if (pAd->CommonCfg.bRdg) {
+		pAd->MlmeAux.HtCapability.ExtHtCapInfo.RDGSupport =
+		    pHtCapability->ExtHtCapInfo.RDGSupport;
+		pAd->MlmeAux.HtCapability.ExtHtCapInfo.PlusHTC = 1;
 	}
 
-    if (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_20)
-        pAd->MlmeAux.HtCapability.MCSSet[4] = 0x0;  // BW20 can't transmit MCS32
+	if (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_20)
+		pAd->MlmeAux.HtCapability.MCSSet[4] = 0x0;	// BW20 can't transmit MCS32
 
 	COPY_AP_HTSETTINGS_FROM_BEACON(pAd, pHtCapability);
 	return TRUE;
@@ -5371,65 +5452,60 @@ BOOLEAN 	RTMPCheckHt(
 
 	========================================================================
 */
-VOID RTMPUpdateMlmeRate(
-	IN PRTMP_ADAPTER	pAd)
+VOID RTMPUpdateMlmeRate(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR	MinimumRate;
-	UCHAR	ProperMlmeRate; //= RATE_54;
-	UCHAR	i, j, RateIdx = 12; //1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
-	BOOLEAN	bMatch = FALSE;
-
-	switch (pAd->CommonCfg.PhyMode)
-	{
-		case PHY_11B:
+	UCHAR MinimumRate;
+	UCHAR ProperMlmeRate;	//= RATE_54;
+	UCHAR i, j, RateIdx = 12;	//1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
+	BOOLEAN bMatch = FALSE;
+
+	switch (pAd->CommonCfg.PhyMode) {
+	case PHY_11B:
+		ProperMlmeRate = RATE_11;
+		MinimumRate = RATE_1;
+		break;
+	case PHY_11BG_MIXED:
+	case PHY_11ABGN_MIXED:
+	case PHY_11BGN_MIXED:
+		if ((pAd->MlmeAux.SupRateLen == 4) &&
+		    (pAd->MlmeAux.ExtRateLen == 0))
+			// B only AP
 			ProperMlmeRate = RATE_11;
-			MinimumRate = RATE_1;
-			break;
-		case PHY_11BG_MIXED:
-		case PHY_11ABGN_MIXED:
-		case PHY_11BGN_MIXED:
-			if ((pAd->MlmeAux.SupRateLen == 4) &&
-				(pAd->MlmeAux.ExtRateLen == 0))
-				// B only AP
-				ProperMlmeRate = RATE_11;
-			else
-				ProperMlmeRate = RATE_24;
-
-			if (pAd->MlmeAux.Channel <= 14)
-				MinimumRate = RATE_1;
-			else
-				MinimumRate = RATE_6;
-			break;
-		case PHY_11A:
-		case PHY_11N_2_4G:	// rt2860 need to check mlmerate for 802.11n
-		case PHY_11GN_MIXED:
-		case PHY_11AGN_MIXED:
-		case PHY_11AN_MIXED:
-		case PHY_11N_5G:
+		else
 			ProperMlmeRate = RATE_24;
+
+		if (pAd->MlmeAux.Channel <= 14)
+			MinimumRate = RATE_1;
+		else
 			MinimumRate = RATE_6;
-			break;
-		case PHY_11ABG_MIXED:
-			ProperMlmeRate = RATE_24;
-			if (pAd->MlmeAux.Channel <= 14)
-			   MinimumRate = RATE_1;
-			else
-				MinimumRate = RATE_6;
-			break;
-		default: // error
-			ProperMlmeRate = RATE_1;
+		break;
+	case PHY_11A:
+	case PHY_11N_2_4G:	// rt2860 need to check mlmerate for 802.11n
+	case PHY_11GN_MIXED:
+	case PHY_11AGN_MIXED:
+	case PHY_11AN_MIXED:
+	case PHY_11N_5G:
+		ProperMlmeRate = RATE_24;
+		MinimumRate = RATE_6;
+		break;
+	case PHY_11ABG_MIXED:
+		ProperMlmeRate = RATE_24;
+		if (pAd->MlmeAux.Channel <= 14)
 			MinimumRate = RATE_1;
-			break;
+		else
+			MinimumRate = RATE_6;
+		break;
+	default:		// error
+		ProperMlmeRate = RATE_1;
+		MinimumRate = RATE_1;
+		break;
 	}
 
-	for (i = 0; i < pAd->MlmeAux.SupRateLen; i++)
-	{
-		for (j = 0; j < RateIdx; j++)
-		{
-			if ((pAd->MlmeAux.SupRate[i] & 0x7f) == RateIdTo500Kbps[j])
-			{
-				if (j == ProperMlmeRate)
-				{
+	for (i = 0; i < pAd->MlmeAux.SupRateLen; i++) {
+		for (j = 0; j < RateIdx; j++) {
+			if ((pAd->MlmeAux.SupRate[i] & 0x7f) ==
+			    RateIdTo500Kbps[j]) {
+				if (j == ProperMlmeRate) {
 					bMatch = TRUE;
 					break;
 				}
@@ -5440,16 +5516,12 @@ VOID RTMPUpdateMlmeRate(
 			break;
 	}
 
-	if (bMatch == FALSE)
-	{
-		for (i = 0; i < pAd->MlmeAux.ExtRateLen; i++)
-		{
-			for (j = 0; j < RateIdx; j++)
-			{
-				if ((pAd->MlmeAux.ExtRate[i] & 0x7f) == RateIdTo500Kbps[j])
-				{
-					if (j == ProperMlmeRate)
-					{
+	if (bMatch == FALSE) {
+		for (i = 0; i < pAd->MlmeAux.ExtRateLen; i++) {
+			for (j = 0; j < RateIdx; j++) {
+				if ((pAd->MlmeAux.ExtRate[i] & 0x7f) ==
+				    RateIdTo500Kbps[j]) {
+					if (j == ProperMlmeRate) {
 						bMatch = TRUE;
 						break;
 					}
@@ -5461,51 +5533,48 @@ VOID RTMPUpdateMlmeRate(
 		}
 	}
 
-	if (bMatch == FALSE)
-	{
+	if (bMatch == FALSE) {
 		ProperMlmeRate = MinimumRate;
 	}
 
 	pAd->CommonCfg.MlmeRate = MinimumRate;
 	pAd->CommonCfg.RtsRate = ProperMlmeRate;
-	if (pAd->CommonCfg.MlmeRate >= RATE_6)
-	{
+	if (pAd->CommonCfg.MlmeRate >= RATE_6) {
 		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-		pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE = MODE_OFDM;
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-	}
-	else
-	{
+		pAd->CommonCfg.MlmeTransmit.field.MCS =
+		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE =
+		    MODE_OFDM;
+		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS =
+		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+	} else {
 		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
 		pAd->CommonCfg.MlmeTransmit.field.MCS = pAd->CommonCfg.MlmeRate;
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE = MODE_CCK;
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS = pAd->CommonCfg.MlmeRate;
+		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE =
+		    MODE_CCK;
+		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS =
+		    pAd->CommonCfg.MlmeRate;
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPUpdateMlmeRate ==>   MlmeTransmit = 0x%x  \n" , pAd->CommonCfg.MlmeTransmit.word));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPUpdateMlmeRate ==>   MlmeTransmit = 0x%x  \n",
+		  pAd->CommonCfg.MlmeTransmit.word));
 }
 
-CHAR RTMPMaxRssi(
-	IN PRTMP_ADAPTER	pAd,
-	IN CHAR				Rssi0,
-	IN CHAR				Rssi1,
-	IN CHAR				Rssi2)
+CHAR RTMPMaxRssi(IN PRTMP_ADAPTER pAd,
+		 IN CHAR Rssi0, IN CHAR Rssi1, IN CHAR Rssi2)
 {
-	CHAR	larger = -127;
+	CHAR larger = -127;
 
-	if ((pAd->Antenna.field.RxPath == 1) && (Rssi0 != 0))
-	{
+	if ((pAd->Antenna.field.RxPath == 1) && (Rssi0 != 0)) {
 		larger = Rssi0;
 	}
 
-	if ((pAd->Antenna.field.RxPath >= 2) && (Rssi1 != 0))
-	{
+	if ((pAd->Antenna.field.RxPath >= 2) && (Rssi1 != 0)) {
 		larger = max(Rssi0, Rssi1);
 	}
 
-	if ((pAd->Antenna.field.RxPath == 3) && (Rssi2 != 0))
-	{
+	if ((pAd->Antenna.field.RxPath == 3) && (Rssi2 != 0)) {
 		larger = max(larger, Rssi2);
 	}
 
@@ -5515,7 +5584,6 @@ CHAR RTMPMaxRssi(
 	return larger;
 }
 
-
 /*
     ========================================================================
     Routine Description:
@@ -5529,78 +5597,70 @@ CHAR RTMPMaxRssi(
 
     ========================================================================
 */
-VOID AsicEvaluateRxAnt(
-	IN PRTMP_ADAPTER	pAd)
+VOID AsicEvaluateRxAnt(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR	BBPR3 = 0;
+	UCHAR BBPR3 = 0;
 
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS |
-				fRTMP_ADAPTER_HALT_IN_PROGRESS |
-				fRTMP_ADAPTER_RADIO_OFF |
-				fRTMP_ADAPTER_NIC_NOT_EXIST |
-							fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS) ||
-							OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
+			   fRTMP_ADAPTER_HALT_IN_PROGRESS |
+			   fRTMP_ADAPTER_RADIO_OFF |
+			   fRTMP_ADAPTER_NIC_NOT_EXIST |
+			   fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS) ||
+	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
 #ifdef RT30xx
-				|| (pAd->EepromAccess)
+	    || (pAd->EepromAccess)
 #endif // RT30xx //
 #ifdef RT3090
-							|| (pAd->bPCIclkOff == TRUE)
+	    || (pAd->bPCIclkOff == TRUE)
 #endif // RT3090 //
-				)
-			return;
-
+	    )
+		return;
 
 	{
 		//if (pAd->StaCfg.Psm == PWR_SAVE)
-		//	return;
+		//      return;
 
-	{
+		{
 
-		if (pAd->StaCfg.Psm == PWR_SAVE)
-			return;
+			if (pAd->StaCfg.Psm == PWR_SAVE)
+				return;
 
-		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBPR3);
-		BBPR3 &= (~0x18);
-		if(pAd->Antenna.field.RxPath == 3)
-		{
-			BBPR3 |= (0x10);
-		}
-		else if(pAd->Antenna.field.RxPath == 2)
-		{
-			BBPR3 |= (0x8);
-		}
-		else if(pAd->Antenna.field.RxPath == 1)
-		{
-			BBPR3 |= (0x0);
-		}
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
+			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBPR3);
+			BBPR3 &= (~0x18);
+			if (pAd->Antenna.field.RxPath == 3) {
+				BBPR3 |= (0x10);
+			} else if (pAd->Antenna.field.RxPath == 2) {
+				BBPR3 |= (0x8);
+			} else if (pAd->Antenna.field.RxPath == 1) {
+				BBPR3 |= (0x0);
+			}
+			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
 #ifdef RTMP_MAC_PCI
-		pAd->StaCfg.BBPR3 = BBPR3;
+			pAd->StaCfg.BBPR3 = BBPR3;
 #endif // RTMP_MAC_PCI //
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-		)
-	{
-		ULONG	TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-								pAd->RalinkCounters.OneSecTxRetryOkCount +
-								pAd->RalinkCounters.OneSecTxFailCount;
-
-			// dynamic adjust antenna evaluation period according to the traffic
-		if (TxTotalCnt > 50)
-		{
-			RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer, 20);
-			pAd->Mlme.bLowThroughput = FALSE;
-		}
-		else
-		{
-			RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer, 300);
-			pAd->Mlme.bLowThroughput = TRUE;
-		}
-	}
+			if (OPSTATUS_TEST_FLAG
+			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
+			    ) {
+				ULONG TxTotalCnt =
+				    pAd->RalinkCounters.OneSecTxNoRetryOkCount +
+				    pAd->RalinkCounters.OneSecTxRetryOkCount +
+				    pAd->RalinkCounters.OneSecTxFailCount;
+
+				// dynamic adjust antenna evaluation period according to the traffic
+				if (TxTotalCnt > 50) {
+					RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer,
+						     20);
+					pAd->Mlme.bLowThroughput = FALSE;
+				} else {
+					RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer,
+						     300);
+					pAd->Mlme.bLowThroughput = TRUE;
+				}
+			}
 		}
 
 	}
 
-
 }
 
 /*
@@ -5616,62 +5676,54 @@ VOID AsicEvaluateRxAnt(
 
     ========================================================================
 */
-VOID AsicRxAntEvalTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
-{
-	RTMP_ADAPTER	*pAd = (RTMP_ADAPTER *)FunctionContext;
-	UCHAR			BBPR3 = 0;
-	CHAR			larger = -127, rssi0, rssi1, rssi2;
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS	|
-							fRTMP_ADAPTER_HALT_IN_PROGRESS	|
-							fRTMP_ADAPTER_RADIO_OFF			|
-							fRTMP_ADAPTER_NIC_NOT_EXIST) ||
-							OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
+VOID AsicRxAntEvalTimeout(IN PVOID SystemSpecific1,
+			  IN PVOID FunctionContext,
+			  IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
+{
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
+	UCHAR BBPR3 = 0;
+	CHAR larger = -127, rssi0, rssi1, rssi2;
+
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS |
+			   fRTMP_ADAPTER_HALT_IN_PROGRESS |
+			   fRTMP_ADAPTER_RADIO_OFF |
+			   fRTMP_ADAPTER_NIC_NOT_EXIST) ||
+	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
 #ifdef RT30xx
-							|| (pAd->EepromAccess)
+	    || (pAd->EepromAccess)
 #endif // RT30xx //
 #ifdef RT3090
-							|| (pAd->bPCIclkOff == TRUE)
+	    || (pAd->bPCIclkOff == TRUE)
 #endif // RT3090 //
-							)
+	    )
 		return;
 
 	{
 		//if (pAd->StaCfg.Psm == PWR_SAVE)
-		//	return;
+		//      return;
 		{
 			if (pAd->StaCfg.Psm == PWR_SAVE)
 				return;
 
 			// if the traffic is low, use average rssi as the criteria
-			if (pAd->Mlme.bLowThroughput == TRUE)
-			{
+			if (pAd->Mlme.bLowThroughput == TRUE) {
 				rssi0 = pAd->StaCfg.RssiSample.LastRssi0;
 				rssi1 = pAd->StaCfg.RssiSample.LastRssi1;
 				rssi2 = pAd->StaCfg.RssiSample.LastRssi2;
-			}
-			else
-			{
+			} else {
 				rssi0 = pAd->StaCfg.RssiSample.AvgRssi0;
 				rssi1 = pAd->StaCfg.RssiSample.AvgRssi1;
 				rssi2 = pAd->StaCfg.RssiSample.AvgRssi2;
 			}
 
-			if(pAd->Antenna.field.RxPath == 3)
-			{
+			if (pAd->Antenna.field.RxPath == 3) {
 				larger = max(rssi0, rssi1);
 
 				if (larger > (rssi2 + 20))
 					pAd->Mlme.RealRxPath = 2;
 				else
 					pAd->Mlme.RealRxPath = 3;
-			}
-			else if(pAd->Antenna.field.RxPath == 2)
-			{
+			} else if (pAd->Antenna.field.RxPath == 2) {
 				if (rssi0 > (rssi1 + 20))
 					pAd->Mlme.RealRxPath = 1;
 				else
@@ -5680,16 +5732,11 @@ VOID AsicRxAntEvalTimeout(
 
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBPR3);
 			BBPR3 &= (~0x18);
-			if(pAd->Mlme.RealRxPath == 3)
-			{
+			if (pAd->Mlme.RealRxPath == 3) {
 				BBPR3 |= (0x10);
-			}
-			else if(pAd->Mlme.RealRxPath == 2)
-			{
+			} else if (pAd->Mlme.RealRxPath == 2) {
 				BBPR3 |= (0x8);
-			}
-			else if(pAd->Mlme.RealRxPath == 1)
-			{
+			} else if (pAd->Mlme.RealRxPath == 1) {
 				BBPR3 |= (0x0);
 			}
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
@@ -5699,17 +5746,13 @@ VOID AsicRxAntEvalTimeout(
 		}
 	}
 
-
 }
 
-
-VOID APSDPeriodicExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+VOID APSDPeriodicExec(IN PVOID SystemSpecific1,
+		      IN PVOID FunctionContext,
+		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
 	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
 		return;
@@ -5744,11 +5787,9 @@ VOID APSDPeriodicExec(
 
     ========================================================================
 */
-VOID RTMPSetPiggyBack(
-    IN PRTMP_ADAPTER    pAd,
-    IN BOOLEAN          bPiggyBack)
+VOID RTMPSetPiggyBack(IN PRTMP_ADAPTER pAd, IN BOOLEAN bPiggyBack)
 {
-	TX_LINK_CFG_STRUC  TxLinkCfg;
+	TX_LINK_CFG_STRUC TxLinkCfg;
 
 	RTMP_IO_READ32(pAd, TX_LINK_CFG, &TxLinkCfg.word);
 
@@ -5771,37 +5812,32 @@ VOID RTMPSetPiggyBack(
 
     ========================================================================
 */
-BOOLEAN RTMPCheckEntryEnableAutoRateSwitch(
-	IN PRTMP_ADAPTER    pAd,
-	IN PMAC_TABLE_ENTRY	pEntry)
+BOOLEAN RTMPCheckEntryEnableAutoRateSwitch(IN PRTMP_ADAPTER pAd,
+					   IN PMAC_TABLE_ENTRY pEntry)
 {
-	BOOLEAN		result = TRUE;
+	BOOLEAN result = TRUE;
 
 	{
 		// only associated STA counts
-		if (pEntry && (pEntry->ValidAsCLI) && (pEntry->Sst == SST_ASSOC))
-		{
+		if (pEntry && (pEntry->ValidAsCLI)
+		    && (pEntry->Sst == SST_ASSOC)) {
 			result = pAd->StaCfg.bAutoTxRateSwitch;
-		}
-		else
+		} else
 			result = FALSE;
 	}
 
 	return result;
 }
 
-
-BOOLEAN RTMPAutoRateSwitchCheck(
-	IN PRTMP_ADAPTER    pAd)
+BOOLEAN RTMPAutoRateSwitchCheck(IN PRTMP_ADAPTER pAd)
 {
 	{
-	if (pAd->StaCfg.bAutoTxRateSwitch)
-		return TRUE;
+		if (pAd->StaCfg.bAutoTxRateSwitch)
+			return TRUE;
 	}
 	return FALSE;
 }
 
-
 /*
     ========================================================================
     Routine Description:
@@ -5817,14 +5853,14 @@ BOOLEAN RTMPAutoRateSwitchCheck(
 
     ========================================================================
 */
-UCHAR RTMPStaFixedTxMode(
-	IN PRTMP_ADAPTER    pAd,
-	IN PMAC_TABLE_ENTRY	pEntry)
+UCHAR RTMPStaFixedTxMode(IN PRTMP_ADAPTER pAd, IN PMAC_TABLE_ENTRY pEntry)
 {
-	UCHAR	tx_mode = FIXED_TXMODE_HT;
+	UCHAR tx_mode = FIXED_TXMODE_HT;
 
 	{
-	tx_mode = (UCHAR)pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode;
+		tx_mode =
+		    (UCHAR) pAd->StaCfg.DesiredTransmitSetting.field.
+		    FixedTxMode;
 	}
 
 	return tx_mode;
@@ -5845,9 +5881,7 @@ UCHAR RTMPStaFixedTxMode(
 
     ========================================================================
 */
-VOID RTMPUpdateLegacyTxSetting(
-		UCHAR				fixed_tx_mode,
-		PMAC_TABLE_ENTRY	pEntry)
+VOID RTMPUpdateLegacyTxSetting(UCHAR fixed_tx_mode, PMAC_TABLE_ENTRY pEntry)
 {
 	HTTRANSMIT_SETTING TransmitSetting;
 
@@ -5859,26 +5893,24 @@ VOID RTMPUpdateLegacyTxSetting(
 	TransmitSetting.field.MODE = pEntry->HTPhyMode.field.MODE;
 	TransmitSetting.field.MCS = pEntry->HTPhyMode.field.MCS;
 
-	if (fixed_tx_mode == FIXED_TXMODE_CCK)
-	{
+	if (fixed_tx_mode == FIXED_TXMODE_CCK) {
 		TransmitSetting.field.MODE = MODE_CCK;
 		// CCK mode allow MCS 0~3
 		if (TransmitSetting.field.MCS > MCS_3)
 			TransmitSetting.field.MCS = MCS_3;
-	}
-	else
-	{
+	} else {
 		TransmitSetting.field.MODE = MODE_OFDM;
 		// OFDM mode allow MCS 0~7
 		if (TransmitSetting.field.MCS > MCS_7)
 			TransmitSetting.field.MCS = MCS_7;
 	}
 
-	if (pEntry->HTPhyMode.field.MODE >= TransmitSetting.field.MODE)
-	{
+	if (pEntry->HTPhyMode.field.MODE >= TransmitSetting.field.MODE) {
 		pEntry->HTPhyMode.word = TransmitSetting.word;
-		DBGPRINT(RT_DEBUG_TRACE, ("RTMPUpdateLegacyTxSetting : wcid-%d, MODE=%s, MCS=%d \n",
-				pEntry->Aid, GetPhyMode(pEntry->HTPhyMode.field.MODE), pEntry->HTPhyMode.field.MCS));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTMPUpdateLegacyTxSetting : wcid-%d, MODE=%s, MCS=%d \n",
+			  pEntry->Aid, GetPhyMode(pEntry->HTPhyMode.field.MODE),
+			  pEntry->HTPhyMode.field.MCS));
 	}
 }
 
@@ -5892,11 +5924,10 @@ VOID RTMPUpdateLegacyTxSetting(
 
 	==========================================================================
  */
-VOID AsicStaBbpTuning(
-	IN PRTMP_ADAPTER pAd)
+VOID AsicStaBbpTuning(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR	OrigR66Value = 0, R66;//, R66UpperBound = 0x30, R66LowerBound = 0x30;
-	CHAR	Rssi;
+	UCHAR OrigR66Value = 0, R66;	//, R66UpperBound = 0x30, R66LowerBound = 0x30;
+	CHAR Rssi;
 
 	// 2860C did not support Fase CCA, therefore can't tune
 	if (pAd->MACVersion == 0x28600100)
@@ -5905,156 +5936,138 @@ VOID AsicStaBbpTuning(
 	//
 	// work as a STA
 	//
-	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)  // no R66 tuning when SCANNING
+	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)	// no R66 tuning when SCANNING
 		return;
 
 	if ((pAd->OpMode == OPMODE_STA)
-		&& (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-			)
-		&& !(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+	    && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
+	    )
+	    && !(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 #ifdef RTMP_MAC_PCI
-		&& (pAd->bPCIclkOff == FALSE)
+	    && (pAd->bPCIclkOff == FALSE)
 #endif // RTMP_MAC_PCI //
-		)
-	{
+	    ) {
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66, &OrigR66Value);
 		R66 = OrigR66Value;
 
 		if (pAd->Antenna.field.RxPath > 1)
-			Rssi = (pAd->StaCfg.RssiSample.AvgRssi0 + pAd->StaCfg.RssiSample.AvgRssi1) >> 1;
+			Rssi =
+			    (pAd->StaCfg.RssiSample.AvgRssi0 +
+			     pAd->StaCfg.RssiSample.AvgRssi1) >> 1;
 		else
 			Rssi = pAd->StaCfg.RssiSample.AvgRssi0;
 
-		if (pAd->LatchRfRegs.Channel <= 14)
-		{	//BG band
+		if (pAd->LatchRfRegs.Channel <= 14) {	//BG band
 #ifdef RT30xx
 			// RT3070 is a no LNA solution, it should have different control regarding to AGC gain control
 			// Otherwise, it will have some throughput side effect when low RSSI
 
-			if (IS_RT3070(pAd)||IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-			{
-				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)
-				{
-					R66 = 0x1C + 2*GET_LNA_GAIN(pAd) + 0x20;
-					if (OrigR66Value != R66)
-					{
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
-				}
-				}
-				else
-				{
-					R66 = 0x1C + 2*GET_LNA_GAIN(pAd);
-					if (OrigR66Value != R66)
-					{
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+			if (IS_RT3070(pAd) || IS_RT3090(pAd) || IS_RT3572(pAd)
+			    || IS_RT3390(pAd)) {
+				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
+					R66 =
+					    0x1C + 2 * GET_LNA_GAIN(pAd) + 0x20;
+					if (OrigR66Value != R66) {
+						RTMP_BBP_IO_WRITE8_BY_REG_ID
+						    (pAd, BBP_R66, R66);
+					}
+				} else {
+					R66 = 0x1C + 2 * GET_LNA_GAIN(pAd);
+					if (OrigR66Value != R66) {
+						RTMP_BBP_IO_WRITE8_BY_REG_ID
+						    (pAd, BBP_R66, R66);
+					}
 				}
-			}
-			}
-			else
+			} else
 #endif // RT30xx //
 			{
-				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)
-				{
+				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
 					R66 = (0x2E + GET_LNA_GAIN(pAd)) + 0x10;
-					if (OrigR66Value != R66)
-					{
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+					if (OrigR66Value != R66) {
+						RTMP_BBP_IO_WRITE8_BY_REG_ID
+						    (pAd, BBP_R66, R66);
 					}
-				}
-				else
-				{
+				} else {
 					R66 = 0x2E + GET_LNA_GAIN(pAd);
-					if (OrigR66Value != R66)
-					{
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+					if (OrigR66Value != R66) {
+						RTMP_BBP_IO_WRITE8_BY_REG_ID
+						    (pAd, BBP_R66, R66);
 					}
 				}
 			}
-		}
-		else
-		{	//A band
-			if (pAd->CommonCfg.BBPCurrentBW == BW_20)
-			{
-				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)
-				{
-					R66 = 0x32 + (GET_LNA_GAIN(pAd)*5)/3 + 0x10;
-					if (OrigR66Value != R66)
-					{
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+		} else {	//A band
+			if (pAd->CommonCfg.BBPCurrentBW == BW_20) {
+				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
+					R66 =
+					    0x32 + (GET_LNA_GAIN(pAd) * 5) / 3 +
+					    0x10;
+					if (OrigR66Value != R66) {
+						RTMP_BBP_IO_WRITE8_BY_REG_ID
+						    (pAd, BBP_R66, R66);
 					}
-				}
-				else
-				{
-					R66 = 0x32 + (GET_LNA_GAIN(pAd)*5)/3;
-					if (OrigR66Value != R66)
-					{
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+				} else {
+					R66 =
+					    0x32 + (GET_LNA_GAIN(pAd) * 5) / 3;
+					if (OrigR66Value != R66) {
+						RTMP_BBP_IO_WRITE8_BY_REG_ID
+						    (pAd, BBP_R66, R66);
 					}
 				}
-			}
-			else
-			{
-				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)
-				{
-					R66 = 0x3A + (GET_LNA_GAIN(pAd)*5)/3 + 0x10;
-					if (OrigR66Value != R66)
-					{
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+			} else {
+				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
+					R66 =
+					    0x3A + (GET_LNA_GAIN(pAd) * 5) / 3 +
+					    0x10;
+					if (OrigR66Value != R66) {
+						RTMP_BBP_IO_WRITE8_BY_REG_ID
+						    (pAd, BBP_R66, R66);
 					}
-				}
-				else
-				{
-					R66 = 0x3A + (GET_LNA_GAIN(pAd)*5)/3;
-					if (OrigR66Value != R66)
-					{
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+				} else {
+					R66 =
+					    0x3A + (GET_LNA_GAIN(pAd) * 5) / 3;
+					if (OrigR66Value != R66) {
+						RTMP_BBP_IO_WRITE8_BY_REG_ID
+						    (pAd, BBP_R66, R66);
 					}
 				}
 			}
 		}
 
-
 	}
 }
 
-VOID RTMPSetAGCInitValue(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			BandWidth)
+VOID RTMPSetAGCInitValue(IN PRTMP_ADAPTER pAd, IN UCHAR BandWidth)
 {
-	UCHAR	R66 = 0x30;
+	UCHAR R66 = 0x30;
 
-	if (pAd->LatchRfRegs.Channel <= 14)
-	{	// BG band
+	if (pAd->LatchRfRegs.Channel <= 14) {	// BG band
 #ifdef RT30xx
 		/* Gary was verified Amazon AP and find that RT307x has BBP_R66 invalid default value */
 
-		if (IS_RT3070(pAd)||IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-		{
-			R66 = 0x1C + 2*GET_LNA_GAIN(pAd);
+		if (IS_RT3070(pAd) || IS_RT3090(pAd) || IS_RT3572(pAd)
+		    || IS_RT3390(pAd)) {
+			R66 = 0x1C + 2 * GET_LNA_GAIN(pAd);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
-		}
-		else
+		} else
 #endif // RT30xx //
 		{
-		R66 = 0x2E + GET_LNA_GAIN(pAd);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
-	}
-	}
-	else
-	{	//A band
-		{
-		if (BandWidth == BW_20)
-		{
-			R66 = (UCHAR)(0x32 + (GET_LNA_GAIN(pAd)*5)/3);
+			R66 = 0x2E + GET_LNA_GAIN(pAd);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
 		}
-		else
+	} else {		//A band
 		{
-			R66 = (UCHAR)(0x3A + (GET_LNA_GAIN(pAd)*5)/3);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+			if (BandWidth == BW_20) {
+				R66 =
+				    (UCHAR) (0x32 +
+					     (GET_LNA_GAIN(pAd) * 5) / 3);
+				RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+			} else {
+				R66 =
+				    (UCHAR) (0x3A +
+					     (GET_LNA_GAIN(pAd) * 5) / 3);
+				RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
+			}
 		}
 	}
-	}
 
 }
-
--- a/drivers/staging/rt2860/common/rt_channel.c
+++ b/drivers/staging/rt2860/common/rt_channel.c
@@ -26,951 +26,1411 @@
 */
 #include "../rt_config.h"
 
-
-CH_FREQ_MAP CH_HZ_ID_MAP[]=
-		{
-			{1, 2412},
-			{2, 2417},
-			{3, 2422},
-			{4, 2427},
-			{5, 2432},
-			{6, 2437},
-			{7, 2442},
-			{8, 2447},
-			{9, 2452},
-			{10, 2457},
-			{11, 2462},
-			{12, 2467},
-			{13, 2472},
-			{14, 2484},
-
-			/*  UNII */
-			{36, 5180},
-			{40, 5200},
-			{44, 5220},
-			{48, 5240},
-			{52, 5260},
-			{56, 5280},
-			{60, 5300},
-			{64, 5320},
-			{149, 5745},
-			{153, 5765},
-			{157, 5785},
-			{161, 5805},
-			{165, 5825},
-			{167, 5835},
-			{169, 5845},
-			{171, 5855},
-			{173, 5865},
-
-			/* HiperLAN2 */
-			{100, 5500},
-			{104, 5520},
-			{108, 5540},
-			{112, 5560},
-			{116, 5580},
-			{120, 5600},
-			{124, 5620},
-			{128, 5640},
-			{132, 5660},
-			{136, 5680},
-			{140, 5700},
-
-			/* Japan MMAC */
-			{34, 5170},
-			{38, 5190},
-			{42, 5210},
-			{46, 5230},
-
-			/*  Japan */
-			{184, 4920},
-			{188, 4940},
-			{192, 4960},
-			{196, 4980},
-
-			{208, 5040},	/* Japan, means J08 */
-			{212, 5060},	/* Japan, means J12 */
-			{216, 5080},	/* Japan, means J16 */
+CH_FREQ_MAP CH_HZ_ID_MAP[] = {
+	{1, 2412}
+	,
+	{2, 2417}
+	,
+	{3, 2422}
+	,
+	{4, 2427}
+	,
+	{5, 2432}
+	,
+	{6, 2437}
+	,
+	{7, 2442}
+	,
+	{8, 2447}
+	,
+	{9, 2452}
+	,
+	{10, 2457}
+	,
+	{11, 2462}
+	,
+	{12, 2467}
+	,
+	{13, 2472}
+	,
+	{14, 2484}
+	,
+
+	/*  UNII */
+	{36, 5180}
+	,
+	{40, 5200}
+	,
+	{44, 5220}
+	,
+	{48, 5240}
+	,
+	{52, 5260}
+	,
+	{56, 5280}
+	,
+	{60, 5300}
+	,
+	{64, 5320}
+	,
+	{149, 5745}
+	,
+	{153, 5765}
+	,
+	{157, 5785}
+	,
+	{161, 5805}
+	,
+	{165, 5825}
+	,
+	{167, 5835}
+	,
+	{169, 5845}
+	,
+	{171, 5855}
+	,
+	{173, 5865}
+	,
+
+	/* HiperLAN2 */
+	{100, 5500}
+	,
+	{104, 5520}
+	,
+	{108, 5540}
+	,
+	{112, 5560}
+	,
+	{116, 5580}
+	,
+	{120, 5600}
+	,
+	{124, 5620}
+	,
+	{128, 5640}
+	,
+	{132, 5660}
+	,
+	{136, 5680}
+	,
+	{140, 5700}
+	,
+
+	/* Japan MMAC */
+	{34, 5170}
+	,
+	{38, 5190}
+	,
+	{42, 5210}
+	,
+	{46, 5230}
+	,
+
+	/*  Japan */
+	{184, 4920}
+	,
+	{188, 4940}
+	,
+	{192, 4960}
+	,
+	{196, 4980}
+	,
+
+	{208, 5040}
+	,			/* Japan, means J08 */
+	{212, 5060}
+	,			/* Japan, means J12 */
+	{216, 5080}
+	,			/* Japan, means J16 */
 };
 
-INT	CH_HZ_ID_MAP_NUM = (sizeof(CH_HZ_ID_MAP)/sizeof(CH_FREQ_MAP));
-
-CH_REGION ChRegion[] =
-{
-		{	// Antigua and Berbuda
-			"AG",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  23, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, FALSE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Argentina
-			"AR",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149, 4,  30, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Aruba
-			"AW",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  23, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, FALSE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Australia
-			"AU",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149, 5,  30, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Austria
-			"AT",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, IDOR, TRUE},		// 5G, ch 36~48
-				{ 52,  4,  23, IDOR, TRUE},		// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, TRUE},		// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Bahamas
-			"BS",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149, 5,  30, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Barbados
-			"BB",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, FALSE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Bermuda
-			"BM",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, FALSE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Brazil
-			"BR",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11, 24, BOTH, FALSE},	// 5G, ch 100~140
-				{ 149, 5,  30, BOTH, FALSE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Belgium
-			"BE",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  18, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  18, IDOR, FALSE},	// 5G, ch 52~64
-				{ 0},							// end
-			}
-		},
-
-		{	// Bulgaria
-			"BG",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11, 30, ODOR, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Canada
-			"CA",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  23, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149, 5,  30, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Cayman IsLands
-			"KY",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, FALSE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Chile
-			"CL",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  20, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  20, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149, 5,  20, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// China
-			"CN",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 149, 4,  27, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Colombia
-			"CO",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  17, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, FALSE},	// 5G, ch 100~140
-				{ 149, 5,  30, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Costa Rica
-			"CR",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  17, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149, 4,  30, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Cyprus
-			"CY",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  24, IDOR, TRUE},		// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, TRUE},		// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Czech_Republic
-			"CZ",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  23, IDOR, TRUE},		// 5G, ch 52~64
-				{ 0},							// end
-			}
-		},
-
-		{	// Denmark
-			"DK",
-			CE,
-			{
-				{ 1,   13, 20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,  23, IDOR, TRUE},		// 5G, ch 52~64
-				{ 100, 11, 30, BOTH, TRUE},		// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Dominican Republic
-			"DO",
-			CE,
-			{
-				{ 1,   0,  20, BOTH, FALSE},	// 2.4 G, ch 0
-				{ 149, 4,  20, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Equador
-			"EC",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 100, 11,  27, BOTH, FALSE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// El Salvador
-			"SV",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,   23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,   30, BOTH, TRUE},	// 5G, ch 52~64
-				{ 149, 4,   36, BOTH, TRUE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Finland
-			"FI",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,   23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,   23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// France
-			"FR",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,   23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,   23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 0},							// end
-			}
-		},
-
-		{	// Germany
-			"DE",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,   23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,   23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Greece
-			"GR",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,   23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,  4,   23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, ODOR, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Guam
-			"GU",
-			CE,
-			{
-				{ 1,   11,  20, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 36,  4,   17, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,   24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, FALSE},	// 5G, ch 100~140
-				{ 149,  5,  30, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Guatemala
-			"GT",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,   17, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,   24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149,  4,  30, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Haiti
-			"HT",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,  4,   17, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,  4,   24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149,  4,  30, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Honduras
-			"HN",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 149,  4,  27, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Hong Kong
-			"HK",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, FALSE},	// 5G, ch 52~64
-				{ 149,  4,  30, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Hungary
-			"HU",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 0},							// end
-			}
-		},
-
-		{	// Iceland
-			"IS",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// India
-			"IN",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 149,	4,  24, IDOR, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Indonesia
-			"ID",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 149,	4,  27, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Ireland
-			"IE",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, ODOR, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Israel
-			"IL",
-			CE,
-			{
-				{ 1,    3,  20, IDOR, FALSE},	// 2.4 G, ch 1~3
-				{ 4,	6,  20, BOTH, FALSE},	// 2.4 G, ch 4~9
-				{ 10,	4,  20, IDOR, FALSE},	// 2.4 G, ch 10~13
-				{ 0},							// end
-			}
-		},
-
-		{	// Italy
-			"IT",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, ODOR, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Japan
-			"JP",
-			JAP,
-			{
-				{ 1,   14,  20, BOTH, FALSE},	// 2.4 G, ch 1~14
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 0},							// end
-			}
-		},
-
-		{	// Jordan
-			"JO",
-			CE,
-			{
-				{ 1,   13,  20, IDOR, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 149,	4,  23, IDOR, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Latvia
-			"LV",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Liechtenstein
-			"LI",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 52,	4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Lithuania
-			"LT",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
+INT CH_HZ_ID_MAP_NUM = (sizeof(CH_HZ_ID_MAP) / sizeof(CH_FREQ_MAP));
 
-		{	// Luxemburg
-			"LU",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Malaysia
-			"MY",
-			CE,
-			{
-				{ 36,	4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  23, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149,  5,  20, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Malta
-			"MT",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Marocco
-			"MA",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  24, IDOR, FALSE},	// 5G, ch 36~48
-				{ 0},							// end
-			}
-		},
-
-		{	// Mexico
-			"MX",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149,  5,  30, IDOR, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Netherlands
-			"NL",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  24, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// New Zealand
-			"NZ",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  24, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  24, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149,  4,  30, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Norway
-			"NO",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,	4,  24, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,	4,  24, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Peru
-			"PE",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 149,  4,  27, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Portugal
-			"PT",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Poland
-			"PL",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Romania
-			"RO",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Russia
-			"RU",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 149,  4,  20, IDOR, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Saudi Arabia
-			"SA",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149,  4,  23, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Serbia_and_Montenegro
-			"CS",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 0},							// end
-			}
-		},
-
-		{	// Singapore
-			"SG",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, BOTH, FALSE},	// 5G, ch 52~64
-				{ 149,  4,  20, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Slovakia
-			"SK",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Slovenia
-			"SI",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 0},							// end
-			}
-		},
-
-		{	// South Africa
-			"ZA",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, FALSE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 149,  4,  30, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// South Korea
-			"KR",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  20, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  20, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100,  8,  20, BOTH, FALSE},	// 5G, ch 100~128
-				{ 149,  4,  20, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Spain
-			"ES",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  17, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Sweden
-			"SE",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Switzerland
-			"CH",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~13
-				{ 36,   4,  23, IDOR, TRUE},	// 5G, ch 36~48
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 0},							// end
-			}
-		},
-
-		{	// Taiwan
-			"TW",
-			CE,
-			{
-				{ 1,   11,  30, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 52,   4,  23, IDOR, FALSE},	// 5G, ch 52~64
-				{ 0},							// end
-			}
-		},
-
-		{	// Turkey
-			"TR",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 36,   4,  23, BOTH, FALSE},	// 5G, ch 36~48
-				{ 52,   4,  23, BOTH, FALSE},	// 5G, ch 52~64
-				{ 0},							// end
-			}
-		},
-
-		{	// UK
-			"GB",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 36,   4,  23, IDOR, FALSE},	// 5G, ch 52~64
-				{ 52,   4,  23, IDOR, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 0},							// end
-			}
-		},
-
-		{	// Ukraine
-			"UA",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 0},							// end
-			}
-		},
-
-		{	// United_Arab_Emirates
-			"AE",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 0},							// end
-			}
-		},
-
-		{	// United_States
-			"US",
-			CE,
-			{
-				{ 1,   11,  30, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 36,   4,  17, IDOR, FALSE},	// 5G, ch 52~64
-				{ 52,   4,  24, BOTH, TRUE},	// 5G, ch 52~64
-				{ 100, 11,  30, BOTH, TRUE},	// 5G, ch 100~140
-				{ 149,  5,  30, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
-
-		{	// Venezuela
-			"VE",
-			CE,
-			{
-				{ 1,   13,  20, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 149,  4,  27, BOTH, FALSE},	// 5G, ch 149~161
-				{ 0},							// end
-			}
-		},
-
-		{	// Default
-			"",
-			CE,
-			{
-				{ 1,   11,  20, BOTH, FALSE},	// 2.4 G, ch 1~11
-				{ 36,   4,  20, BOTH, FALSE},	// 5G, ch 52~64
-				{ 52,   4,  20, BOTH, FALSE},	// 5G, ch 52~64
-				{ 100, 11,  20, BOTH, FALSE},	// 5G, ch 100~140
-				{ 149,  5,  20, BOTH, FALSE},	// 5G, ch 149~165
-				{ 0},							// end
-			}
-		},
+CH_REGION ChRegion[] = {
+	{			// Antigua and Berbuda
+	 "AG",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Argentina
+	 "AR",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Aruba
+	 "AW",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Australia
+	 "AU",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 5, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Austria
+	 "AT",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Bahamas
+	 "BS",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 5, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Barbados
+	 "BB",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Bermuda
+	 "BM",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Brazil
+	 "BR",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 24, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {149, 5, 30, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Belgium
+	 "BE",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 18, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 18, IDOR, FALSE}
+	  ,			// 5G, ch 52~64
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Bulgaria
+	 "BG",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, ODOR, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Canada
+	 "CA",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 5, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Cayman IsLands
+	 "KY",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Chile
+	 "CL",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 5, 20, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// China
+	 "CN",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {149, 4, 27, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Colombia
+	 "CO",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 17, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {149, 5, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Costa Rica
+	 "CR",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 17, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Cyprus
+	 "CY",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Czech_Republic
+	 "CZ",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Denmark
+	 "DK",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Dominican Republic
+	 "DO",
+	 CE,
+	 {
+	  {1, 0, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 0
+	  {149, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Equador
+	 "EC",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {100, 11, 27, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// El Salvador
+	 "SV",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 30, BOTH, TRUE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 36, BOTH, TRUE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Finland
+	 "FI",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// France
+	 "FR",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Germany
+	 "DE",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Greece
+	 "GR",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, ODOR, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Guam
+	 "GU",
+	 CE,
+	 {
+	  {1, 11, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {36, 4, 17, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {149, 5, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Guatemala
+	 "GT",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 17, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Haiti
+	 "HT",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 17, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Honduras
+	 "HN",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {149, 4, 27, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Hong Kong
+	 "HK",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Hungary
+	 "HU",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Iceland
+	 "IS",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// India
+	 "IN",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {149, 4, 24, IDOR, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Indonesia
+	 "ID",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {149, 4, 27, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Ireland
+	 "IE",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, ODOR, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Israel
+	 "IL",
+	 CE,
+	 {
+	  {1, 3, 20, IDOR, FALSE}
+	  ,			// 2.4 G, ch 1~3
+	  {4, 6, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 4~9
+	  {10, 4, 20, IDOR, FALSE}
+	  ,			// 2.4 G, ch 10~13
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Italy
+	 "IT",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, ODOR, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Japan
+	 "JP",
+	 JAP,
+	 {
+	  {1, 14, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~14
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Jordan
+	 "JO",
+	 CE,
+	 {
+	  {1, 13, 20, IDOR, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {149, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Latvia
+	 "LV",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Liechtenstein
+	 "LI",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Lithuania
+	 "LT",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Luxemburg
+	 "LU",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Malaysia
+	 "MY",
+	 CE,
+	 {
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 5, 20, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Malta
+	 "MT",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Marocco
+	 "MA",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 24, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Mexico
+	 "MX",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 5, 30, IDOR, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Netherlands
+	 "NL",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// New Zealand
+	 "NZ",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Norway
+	 "NO",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 24, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 24, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Peru
+	 "PE",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {149, 4, 27, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Portugal
+	 "PT",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Poland
+	 "PL",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Romania
+	 "RO",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Russia
+	 "RU",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {149, 4, 20, IDOR, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Saudi Arabia
+	 "SA",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Serbia_and_Montenegro
+	 "CS",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Singapore
+	 "SG",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {149, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Slovakia
+	 "SK",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Slovenia
+	 "SI",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// South Africa
+	 "ZA",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {149, 4, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// South Korea
+	 "KR",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 8, 20, BOTH, FALSE}
+	  ,			// 5G, ch 100~128
+	  {149, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Spain
+	 "ES",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 17, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Sweden
+	 "SE",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Switzerland
+	 "CH",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~13
+	  {36, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Taiwan
+	 "TW",
+	 CE,
+	 {
+	  {1, 11, 30, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {52, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 52~64
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Turkey
+	 "TR",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {36, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 36~48
+	  {52, 4, 23, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// UK
+	 "GB",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {36, 4, 23, IDOR, FALSE}
+	  ,			// 5G, ch 52~64
+	  {52, 4, 23, IDOR, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Ukraine
+	 "UA",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// United_Arab_Emirates
+	 "AE",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// United_States
+	 "US",
+	 CE,
+	 {
+	  {1, 11, 30, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {36, 4, 17, IDOR, FALSE}
+	  ,			// 5G, ch 52~64
+	  {52, 4, 24, BOTH, TRUE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 30, BOTH, TRUE}
+	  ,			// 5G, ch 100~140
+	  {149, 5, 30, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Venezuela
+	 "VE",
+	 CE,
+	 {
+	  {1, 13, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {149, 4, 27, BOTH, FALSE}
+	  ,			// 5G, ch 149~161
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
+
+	{			// Default
+	 "",
+	 CE,
+	 {
+	  {1, 11, 20, BOTH, FALSE}
+	  ,			// 2.4 G, ch 1~11
+	  {36, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {52, 4, 20, BOTH, FALSE}
+	  ,			// 5G, ch 52~64
+	  {100, 11, 20, BOTH, FALSE}
+	  ,			// 5G, ch 100~140
+	  {149, 5, 20, BOTH, FALSE}
+	  ,			// 5G, ch 149~165
+	  {0}
+	  ,			// end
+	  }
+	 }
+	,
 };
 
-
-static PCH_REGION GetChRegion(
-	IN PUCHAR CntryCode)
+static PCH_REGION GetChRegion(IN PUCHAR CntryCode)
 {
 	INT loop = 0;
 	PCH_REGION pChRegion = NULL;
 
-	while (strcmp((PSTRING) ChRegion[loop].CountReg, "") != 0)
-	{
-		if (strncmp((PSTRING) ChRegion[loop].CountReg, (PSTRING) CntryCode, 2) == 0)
-		{
+	while (strcmp((PSTRING) ChRegion[loop].CountReg, "") != 0) {
+		if (strncmp
+		    ((PSTRING) ChRegion[loop].CountReg, (PSTRING) CntryCode,
+		     2) == 0) {
 			pChRegion = &ChRegion[loop];
 			break;
 		}
@@ -982,54 +1442,49 @@ static PCH_REGION GetChRegion(
 	return pChRegion;
 }
 
-static VOID ChBandCheck(
-	IN UCHAR PhyMode,
-	OUT PUCHAR pChType)
+static VOID ChBandCheck(IN UCHAR PhyMode, OUT PUCHAR pChType)
 {
-	switch(PhyMode)
-	{
-		case PHY_11A:
-		case PHY_11AN_MIXED:
-			*pChType = BAND_5G;
-			break;
-		case PHY_11ABG_MIXED:
-		case PHY_11AGN_MIXED:
-		case PHY_11ABGN_MIXED:
-			*pChType = BAND_BOTH;
-			break;
-
-		default:
-			*pChType = BAND_24G;
-			break;
+	switch (PhyMode) {
+	case PHY_11A:
+	case PHY_11AN_MIXED:
+		*pChType = BAND_5G;
+		break;
+	case PHY_11ABG_MIXED:
+	case PHY_11AGN_MIXED:
+	case PHY_11ABGN_MIXED:
+		*pChType = BAND_BOTH;
+		break;
+
+	default:
+		*pChType = BAND_24G;
+		break;
 	}
 }
 
-static UCHAR FillChList(
-	IN PRTMP_ADAPTER pAd,
-	IN PCH_DESP pChDesp,
-	IN UCHAR Offset,
-	IN UCHAR increment)
+static UCHAR FillChList(IN PRTMP_ADAPTER pAd,
+			IN PCH_DESP pChDesp,
+			IN UCHAR Offset, IN UCHAR increment)
 {
 	INT i, j, l;
 	UCHAR channel;
 
 	j = Offset;
-	for (i = 0; i < pChDesp->NumOfCh; i++)
-	{
+	for (i = 0; i < pChDesp->NumOfCh; i++) {
 		channel = pChDesp->FirstChannel + i * increment;
-		for (l=0; l<MAX_NUM_OF_CHANNELS; l++)
-		{
-			if (channel == pAd->TxPower[l].Channel)
-			{
-				pAd->ChannelList[j].Power = pAd->TxPower[l].Power;
-				pAd->ChannelList[j].Power2 = pAd->TxPower[l].Power2;
+		for (l = 0; l < MAX_NUM_OF_CHANNELS; l++) {
+			if (channel == pAd->TxPower[l].Channel) {
+				pAd->ChannelList[j].Power =
+				    pAd->TxPower[l].Power;
+				pAd->ChannelList[j].Power2 =
+				    pAd->TxPower[l].Power2;
 				break;
 			}
 		}
 		if (l == MAX_NUM_OF_CHANNELS)
 			continue;
 
-		pAd->ChannelList[j].Channel = pChDesp->FirstChannel + i * increment;
+		pAd->ChannelList[j].Channel =
+		    pChDesp->FirstChannel + i * increment;
 		pAd->ChannelList[j].MaxTxPwr = pChDesp->MaxTxPwr;
 		pAd->ChannelList[j].DfsReq = pChDesp->DfsReq;
 		j++;
@@ -1039,11 +1494,8 @@ static UCHAR FillChList(
 	return j;
 }
 
-
-static inline VOID CreateChList(
-	IN PRTMP_ADAPTER pAd,
-	IN PCH_REGION pChRegion,
-	IN UCHAR Geography)
+static inline VOID CreateChList(IN PRTMP_ADAPTER pAd,
+				IN PCH_REGION pChRegion, IN UCHAR Geography)
 {
 	INT i;
 	UCHAR offset = 0;
@@ -1056,38 +1508,31 @@ static inline VOID CreateChList(
 
 	ChBandCheck(pAd->CommonCfg.PhyMode, &ChType);
 
-	for (i=0; i<10; i++)
-	{
+	for (i = 0; i < 10; i++) {
 		pChDesp = &pChRegion->ChDesp[i];
 		if (pChDesp->FirstChannel == 0)
 			break;
 
-		if (ChType == BAND_5G)
-		{
+		if (ChType == BAND_5G) {
 			if (pChDesp->FirstChannel <= 14)
 				continue;
-		}
-		else if (ChType == BAND_24G)
-		{
+		} else if (ChType == BAND_24G) {
 			if (pChDesp->FirstChannel > 14)
 				continue;
 		}
 
 		if ((pChDesp->Geography == BOTH)
-			|| (pChDesp->Geography == Geography))
-        {
+		    || (pChDesp->Geography == Geography)) {
 			if (pChDesp->FirstChannel > 14)
-                increment = 4;
-            else
-                increment = 1;
+				increment = 4;
+			else
+				increment = 1;
 			offset = FillChList(pAd, pChDesp, offset, increment);
-        }
+		}
 	}
 }
 
-
-VOID BuildChannelListEx(
-	IN PRTMP_ADAPTER pAd)
+VOID BuildChannelListEx(IN PRTMP_ADAPTER pAd)
 {
 	PCH_REGION pChReg;
 
@@ -1095,11 +1540,8 @@ VOID BuildChannelListEx(
 	CreateChList(pAd, pChReg, pAd->CommonCfg.Geography);
 }
 
-
-VOID BuildBeaconChList(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pBuf,
-	OUT	PULONG pBufLen)
+VOID BuildBeaconChList(IN PRTMP_ADAPTER pAd,
+		       OUT PUCHAR pBuf, OUT PULONG pBufLen)
 {
 	INT i;
 	ULONG TmpLen;
@@ -1115,46 +1557,35 @@ VOID BuildBeaconChList(
 	ChBandCheck(pAd->CommonCfg.PhyMode, &ChType);
 	*pBufLen = 0;
 
-	for (i=0; i<10; i++)
-	{
+	for (i = 0; i < 10; i++) {
 		pChDesp = &pChRegion->ChDesp[i];
 		if (pChDesp->FirstChannel == 0)
 			break;
 
-		if (ChType == BAND_5G)
-		{
+		if (ChType == BAND_5G) {
 			if (pChDesp->FirstChannel <= 14)
 				continue;
-		}
-		else if (ChType == BAND_24G)
-		{
+		} else if (ChType == BAND_24G) {
 			if (pChDesp->FirstChannel > 14)
 				continue;
 		}
 
 		if ((pChDesp->Geography == BOTH)
-			|| (pChDesp->Geography == pAd->CommonCfg.Geography))
-		{
-			MakeOutgoingFrame(pBuf + *pBufLen,		&TmpLen,
-								1,			&pChDesp->FirstChannel,
-								1,			&pChDesp->NumOfCh,
-								1,			&pChDesp->MaxTxPwr,
-								END_OF_ARGS);
+		    || (pChDesp->Geography == pAd->CommonCfg.Geography)) {
+			MakeOutgoingFrame(pBuf + *pBufLen, &TmpLen,
+					  1, &pChDesp->FirstChannel,
+					  1, &pChDesp->NumOfCh,
+					  1, &pChDesp->MaxTxPwr, END_OF_ARGS);
 			*pBufLen += TmpLen;
 		}
 	}
 }
 
-
-static BOOLEAN IsValidChannel(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR channel)
-
+static BOOLEAN IsValidChannel(IN PRTMP_ADAPTER pAd, IN UCHAR channel)
 {
 	INT i;
 
-	for (i = 0; i < pAd->ChannelListNum; i++)
-	{
+	for (i = 0; i < pAd->ChannelListNum; i++) {
 		if (pAd->ChannelList[i].Channel == channel)
 			break;
 	}
@@ -1165,10 +1596,7 @@ static BOOLEAN IsValidChannel(
 		return TRUE;
 }
 
-
-static UCHAR GetExtCh(
-	IN UCHAR Channel,
-	IN UCHAR Direction)
+static UCHAR GetExtCh(IN UCHAR Channel, IN UCHAR Direction)
 {
 	CHAR ExtCh;
 
@@ -1180,95 +1608,92 @@ static UCHAR GetExtCh(
 	return ExtCh;
 }
 
-
-VOID N_ChannelCheck(
-	IN PRTMP_ADAPTER pAd)
+VOID N_ChannelCheck(IN PRTMP_ADAPTER pAd)
 {
 	//UCHAR ChannelNum = pAd->ChannelListNum;
 	UCHAR Channel = pAd->CommonCfg.Channel;
 
-	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pAd->CommonCfg.RegTransmitSetting.field.BW  == BW_40))
-	{
-		if (Channel > 14)
-		{
-			if ((Channel == 36) || (Channel == 44) || (Channel == 52) || (Channel == 60) || (Channel == 100) || (Channel == 108) ||
-			    (Channel == 116) || (Channel == 124) || (Channel == 132) || (Channel == 149) || (Channel == 157))
-			{
-				pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_ABOVE;
-			}
-			else if ((Channel == 40) || (Channel == 48) || (Channel == 56) || (Channel == 64) || (Channel == 104) || (Channel == 112) ||
-					(Channel == 120) || (Channel == 128) || (Channel == 136) || (Channel == 153) || (Channel == 161))
-			{
-				pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_BELOW;
+	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
+	    && (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)) {
+		if (Channel > 14) {
+			if ((Channel == 36) || (Channel == 44)
+			    || (Channel == 52) || (Channel == 60)
+			    || (Channel == 100) || (Channel == 108)
+			    || (Channel == 116) || (Channel == 124)
+			    || (Channel == 132) || (Channel == 149)
+			    || (Channel == 157)) {
+				pAd->CommonCfg.RegTransmitSetting.field.EXTCHA =
+				    EXTCHA_ABOVE;
+			} else if ((Channel == 40) || (Channel == 48)
+				   || (Channel == 56) || (Channel == 64)
+				   || (Channel == 104) || (Channel == 112)
+				   || (Channel == 120) || (Channel == 128)
+				   || (Channel == 136) || (Channel == 153)
+				   || (Channel == 161)) {
+				pAd->CommonCfg.RegTransmitSetting.field.EXTCHA =
+				    EXTCHA_BELOW;
+			} else {
+				pAd->CommonCfg.RegTransmitSetting.field.BW =
+				    BW_20;
 			}
-			else
-			{
-				pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
-			}
-		}
-		else
-		{
-			do
-			{
+		} else {
+			do {
 				UCHAR ExtCh;
-				UCHAR Dir = pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
+				UCHAR Dir =
+				    pAd->CommonCfg.RegTransmitSetting.field.
+				    EXTCHA;
 				ExtCh = GetExtCh(Channel, Dir);
 				if (IsValidChannel(pAd, ExtCh))
 					break;
 
-				Dir = (Dir == EXTCHA_ABOVE) ? EXTCHA_BELOW : EXTCHA_ABOVE;
+				Dir =
+				    (Dir ==
+				     EXTCHA_ABOVE) ? EXTCHA_BELOW :
+				    EXTCHA_ABOVE;
 				ExtCh = GetExtCh(Channel, Dir);
-				if (IsValidChannel(pAd, ExtCh))
-				{
-					pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = Dir;
+				if (IsValidChannel(pAd, ExtCh)) {
+					pAd->CommonCfg.RegTransmitSetting.field.
+					    EXTCHA = Dir;
 					break;
 				}
-				pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
-			} while(FALSE);
-
-			if (Channel == 14)
-			{
-				pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
-				//pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_NONE;	// We didn't set the ExtCh as NONE due to it'll set in RTMPSetHT()
+				pAd->CommonCfg.RegTransmitSetting.field.BW =
+				    BW_20;
+			} while (FALSE);
+
+			if (Channel == 14) {
+				pAd->CommonCfg.RegTransmitSetting.field.BW =
+				    BW_20;
+				//pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_NONE; // We didn't set the ExtCh as NONE due to it'll set in RTMPSetHT()
 			}
 		}
 	}
 
-
 }
 
-
-VOID N_SetCenCh(
-	IN PRTMP_ADAPTER pAd)
+VOID N_SetCenCh(IN PRTMP_ADAPTER pAd)
 {
-	if (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
-	{
-		if (pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
-		{
-			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel + 2;
-		}
-		else
-		{
+	if (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40) {
+		if (pAd->CommonCfg.RegTransmitSetting.field.EXTCHA ==
+		    EXTCHA_ABOVE) {
+			pAd->CommonCfg.CentralChannel =
+			    pAd->CommonCfg.Channel + 2;
+		} else {
 			if (pAd->CommonCfg.Channel == 14)
-				pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel - 1;
+				pAd->CommonCfg.CentralChannel =
+				    pAd->CommonCfg.Channel - 1;
 			else
-				pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel - 2;
+				pAd->CommonCfg.CentralChannel =
+				    pAd->CommonCfg.Channel - 2;
 		}
-	}
-	else
-	{
+	} else {
 		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
 	}
 }
 
-
-UINT8 GetCuntryMaxTxPwr(
-	IN PRTMP_ADAPTER pAd,
-	IN UINT8 channel)
+UINT8 GetCuntryMaxTxPwr(IN PRTMP_ADAPTER pAd, IN UINT8 channel)
 {
 	int i;
-	for (i = 0; i < pAd->ChannelListNum; i++)
-	{
+	for (i = 0; i < pAd->ChannelListNum; i++) {
 		if (pAd->ChannelList[i].Channel == channel)
 			break;
 	}
--- a/drivers/staging/rt2860/common/rtmp_init.c
+++ b/drivers/staging/rt2860/common/rtmp_init.c
@@ -36,103 +36,103 @@
 */
 #include "../rt_config.h"
 
-UCHAR    BIT8[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
-char*   CipherName[] = {"none","wep64","wep128","TKIP","AES","CKIP64","CKIP128"};
+UCHAR BIT8[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
+char *CipherName[] =
+    { "none", "wep64", "wep128", "TKIP", "AES", "CKIP64", "CKIP128" };
 
 //
 // BBP register initialization set
 //
-REG_PAIR   BBPRegTable[] = {
-	{BBP_R65,		0x2C},		// fix rssi issue
-	{BBP_R66,		0x38},	// Also set this default value to pAd->BbpTuning.R66CurrentValue at initial
-	{BBP_R69,		0x12},
-	{BBP_R70,		0xa},	// BBP_R70 will change to 0x8 in ApStartUp and LinkUp for rt2860C, otherwise value is 0xa
-	{BBP_R73,		0x10},
-	{BBP_R81,		0x37},
-	{BBP_R82,		0x62},
-	{BBP_R83,		0x6A},
-	{BBP_R84,		0x99},	// 0x19 is for rt2860E and after. This is for extension channel overlapping IOT. 0x99 is for rt2860D and before
-	{BBP_R86,		0x00},	// middle range issue, Rory @2008-01-28
-	{BBP_R91,		0x04},	// middle range issue, Rory @2008-01-28
-	{BBP_R92,		0x00},	// middle range issue, Rory @2008-01-28
-	{BBP_R103,  	0x00}, 	// near range high-power issue, requested from Gary @2008-0528
-	{BBP_R105,		0x05},	// 0x05 is for rt2860E to turn on FEQ control. It is safe for rt2860D and before, because Bit 7:2 are reserved in rt2860D and before.
-	{BBP_R106,		0x35},  // for ShortGI throughput
+REG_PAIR BBPRegTable[] = {
+	{BBP_R65, 0x2C},	// fix rssi issue
+	{BBP_R66, 0x38},	// Also set this default value to pAd->BbpTuning.R66CurrentValue at initial
+	{BBP_R69, 0x12},
+	{BBP_R70, 0xa},		// BBP_R70 will change to 0x8 in ApStartUp and LinkUp for rt2860C, otherwise value is 0xa
+	{BBP_R73, 0x10},
+	{BBP_R81, 0x37},
+	{BBP_R82, 0x62},
+	{BBP_R83, 0x6A},
+	{BBP_R84, 0x99},	// 0x19 is for rt2860E and after. This is for extension channel overlapping IOT. 0x99 is for rt2860D and before
+	{BBP_R86, 0x00},	// middle range issue, Rory @2008-01-28
+	{BBP_R91, 0x04},	// middle range issue, Rory @2008-01-28
+	{BBP_R92, 0x00},	// middle range issue, Rory @2008-01-28
+	{BBP_R103, 0x00},	// near range high-power issue, requested from Gary @2008-0528
+	{BBP_R105, 0x05},	// 0x05 is for rt2860E to turn on FEQ control. It is safe for rt2860D and before, because Bit 7:2 are reserved in rt2860D and before.
+	{BBP_R106, 0x35},	// for ShortGI throughput
 };
-#define	NUM_BBP_REG_PARMS	(sizeof(BBPRegTable) / sizeof(REG_PAIR))
 
+#define	NUM_BBP_REG_PARMS	(sizeof(BBPRegTable) / sizeof(REG_PAIR))
 
 //
 // ASIC register initialization sets
 //
 
-RTMP_REG_PAIR	MACRegTable[] =	{
+RTMP_REG_PAIR MACRegTable[] = {
 #if defined(HW_BEACON_OFFSET) && (HW_BEACON_OFFSET == 0x200)
-	{BCN_OFFSET0,			0xf8f0e8e0}, /* 0x3800(e0), 0x3A00(e8), 0x3C00(f0), 0x3E00(f8), 512B for each beacon */
-	{BCN_OFFSET1,			0x6f77d0c8}, /* 0x3200(c8), 0x3400(d0), 0x1DC0(77), 0x1BC0(6f), 512B for each beacon */
+	{BCN_OFFSET0, 0xf8f0e8e0},	/* 0x3800(e0), 0x3A00(e8), 0x3C00(f0), 0x3E00(f8), 512B for each beacon */
+	{BCN_OFFSET1, 0x6f77d0c8},	/* 0x3200(c8), 0x3400(d0), 0x1DC0(77), 0x1BC0(6f), 512B for each beacon */
 #elif defined(HW_BEACON_OFFSET) && (HW_BEACON_OFFSET == 0x100)
-	{BCN_OFFSET0,			0xece8e4e0}, /* 0x3800, 0x3A00, 0x3C00, 0x3E00, 512B for each beacon */
-	{BCN_OFFSET1,			0xfcf8f4f0}, /* 0x3800, 0x3A00, 0x3C00, 0x3E00, 512B for each beacon */
+	{BCN_OFFSET0, 0xece8e4e0},	/* 0x3800, 0x3A00, 0x3C00, 0x3E00, 512B for each beacon */
+	{BCN_OFFSET1, 0xfcf8f4f0},	/* 0x3800, 0x3A00, 0x3C00, 0x3E00, 512B for each beacon */
 #else
-    #error You must re-calculate new value for BCN_OFFSET0 & BCN_OFFSET1 in MACRegTable[]!!!
+#error You must re-calculate new value for BCN_OFFSET0 & BCN_OFFSET1 in MACRegTable[]!!!
 #endif // HW_BEACON_OFFSET //
 
-	{LEGACY_BASIC_RATE,		0x0000013f}, //  Basic rate set bitmap
-	{HT_BASIC_RATE,		0x00008003}, // Basic HT rate set , 20M, MCS=3, MM. Format is the same as in TXWI.
-	{MAC_SYS_CTRL,		0x00}, // 0x1004, , default Disable RX
-	{RX_FILTR_CFG,		0x17f97}, //0x1400  , RX filter control,
-	{BKOFF_SLOT_CFG,	0x209}, // default set short slot time, CC_DELAY_TIME should be 2
-	//{TX_SW_CFG0,		0x40a06}, // Gary,2006-08-23
-	{TX_SW_CFG0,		0x0}, 		// Gary,2008-05-21 for CWC test
-	{TX_SW_CFG1,		0x80606}, // Gary,2006-08-23
-	{TX_LINK_CFG,		0x1020},		// Gary,2006-08-23
-	//{TX_TIMEOUT_CFG,	0x00182090},	// CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT
-	{TX_TIMEOUT_CFG,	0x000a2090},	// CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT , Modify for 2860E ,2007-08-01
-	{MAX_LEN_CFG,		MAX_AGGREGATION_SIZE | 0x00001000},	// 0x3018, MAX frame length. Max PSDU = 16kbytes.
-	{LED_CFG,		0x7f031e46}, // Gary, 2006-08-23
-
-	{PBF_MAX_PCNT,			0x1F3FBF9F}, 	//0x1F3f7f9f},		//Jan, 2006/04/20
-
-	{TX_RTY_CFG,			0x47d01f0f},	// Jan, 2006/11/16, Set TxWI->ACK =0 in Probe Rsp Modify for 2860E ,2007-08-03
-
-	{AUTO_RSP_CFG,			0x00000013},	// Initial Auto_Responder, because QA will turn off Auto-Responder
-	{CCK_PROT_CFG,			0x05740003 /*0x01740003*/},	// Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled.
-	{OFDM_PROT_CFG,			0x05740003 /*0x01740003*/},	// Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled.
+	{LEGACY_BASIC_RATE, 0x0000013f},	//  Basic rate set bitmap
+	{HT_BASIC_RATE, 0x00008003},	// Basic HT rate set , 20M, MCS=3, MM. Format is the same as in TXWI.
+	{MAC_SYS_CTRL, 0x00},	// 0x1004, , default Disable RX
+	{RX_FILTR_CFG, 0x17f97},	//0x1400  , RX filter control,
+	{BKOFF_SLOT_CFG, 0x209},	// default set short slot time, CC_DELAY_TIME should be 2
+	//{TX_SW_CFG0,          0x40a06}, // Gary,2006-08-23
+	{TX_SW_CFG0, 0x0},	// Gary,2008-05-21 for CWC test
+	{TX_SW_CFG1, 0x80606},	// Gary,2006-08-23
+	{TX_LINK_CFG, 0x1020},	// Gary,2006-08-23
+	//{TX_TIMEOUT_CFG,      0x00182090},    // CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT
+	{TX_TIMEOUT_CFG, 0x000a2090},	// CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT , Modify for 2860E ,2007-08-01
+	{MAX_LEN_CFG, MAX_AGGREGATION_SIZE | 0x00001000},	// 0x3018, MAX frame length. Max PSDU = 16kbytes.
+	{LED_CFG, 0x7f031e46},	// Gary, 2006-08-23
+
+	{PBF_MAX_PCNT, 0x1F3FBF9F},	//0x1F3f7f9f},          //Jan, 2006/04/20
+
+	{TX_RTY_CFG, 0x47d01f0f},	// Jan, 2006/11/16, Set TxWI->ACK =0 in Probe Rsp Modify for 2860E ,2007-08-03
+
+	{AUTO_RSP_CFG, 0x00000013},	// Initial Auto_Responder, because QA will turn off Auto-Responder
+	{CCK_PROT_CFG, 0x05740003 /*0x01740003 */ },	// Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled.
+	{OFDM_PROT_CFG, 0x05740003 /*0x01740003 */ },	// Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled.
 #ifdef RTMP_MAC_USB
-	{PBF_CFG, 				0xf40006}, 		// Only enable Queue 2
-	{MM40_PROT_CFG,			0x3F44084},		// Initial Auto_Responder, because QA will turn off Auto-Responder
-	{WPDMA_GLO_CFG,			0x00000030},
+	{PBF_CFG, 0xf40006},	// Only enable Queue 2
+	{MM40_PROT_CFG, 0x3F44084},	// Initial Auto_Responder, because QA will turn off Auto-Responder
+	{WPDMA_GLO_CFG, 0x00000030},
 #endif // RTMP_MAC_USB //
-	{GF20_PROT_CFG,			0x01744004},    // set 19:18 --> Short NAV for MIMO PS
-	{GF40_PROT_CFG,			0x03F44084},
-	{MM20_PROT_CFG,			0x01744004},
+	{GF20_PROT_CFG, 0x01744004},	// set 19:18 --> Short NAV for MIMO PS
+	{GF40_PROT_CFG, 0x03F44084},
+	{MM20_PROT_CFG, 0x01744004},
 #ifdef RTMP_MAC_PCI
-	{MM40_PROT_CFG,			0x03F54084},
+	{MM40_PROT_CFG, 0x03F54084},
 #endif // RTMP_MAC_PCI //
-	{TXOP_CTRL_CFG,			0x0000583f, /*0x0000243f*/ /*0x000024bf*/},	//Extension channel backoff.
-	{TX_RTS_CFG,			0x00092b20},
-	{EXP_ACK_TIME,			0x002400ca},	// default value
+	{TXOP_CTRL_CFG, 0x0000583f, /*0x0000243f *//*0x000024bf */ },	//Extension channel backoff.
+	{TX_RTS_CFG, 0x00092b20},
+	{EXP_ACK_TIME, 0x002400ca},	// default value
 
-	{TXOP_HLDR_ET, 			0x00000002},
+	{TXOP_HLDR_ET, 0x00000002},
 
 	/* Jerry comments 2008/01/16: we use SIFS = 10us in CCK defaultly, but it seems that 10us
-		is too small for INTEL 2200bg card, so in MBSS mode, the delta time between beacon0
-		and beacon1 is SIFS (10us), so if INTEL 2200bg card connects to BSS0, the ping
-		will always lost. So we change the SIFS of CCK from 10us to 16us. */
-	{XIFS_TIME_CFG,			0x33a41010},
-	{PWR_PIN_CFG,			0x00000003},	// patch for 2880-E
+	   is too small for INTEL 2200bg card, so in MBSS mode, the delta time between beacon0
+	   and beacon1 is SIFS (10us), so if INTEL 2200bg card connects to BSS0, the ping
+	   will always lost. So we change the SIFS of CCK from 10us to 16us. */
+	{XIFS_TIME_CFG, 0x33a41010},
+	{PWR_PIN_CFG, 0x00000003},	// patch for 2880-E
 };
 
-RTMP_REG_PAIR	STAMACRegTable[] =	{
-	{WMM_AIFSN_CFG,		0x00002273},
-	{WMM_CWMIN_CFG,	0x00002344},
-	{WMM_CWMAX_CFG,	0x000034aa},
+RTMP_REG_PAIR STAMACRegTable[] = {
+	{WMM_AIFSN_CFG, 0x00002273},
+	{WMM_CWMIN_CFG, 0x00002344},
+	{WMM_CWMAX_CFG, 0x000034aa},
 };
 
 #define	NUM_MAC_REG_PARMS		(sizeof(MACRegTable) / sizeof(RTMP_REG_PAIR))
 #define	NUM_STA_MAC_REG_PARMS	(sizeof(STAMACRegTable) / sizeof(RTMP_REG_PAIR))
 
-
 /*
 	========================================================================
 
@@ -152,52 +152,48 @@ RTMP_REG_PAIR	STAMACRegTable[] =	{
 
 	========================================================================
 */
-NDIS_STATUS	RTMPAllocAdapterBlock(
-	IN  PVOID	handle,
-	OUT	PRTMP_ADAPTER	*ppAdapter)
-{
-	PRTMP_ADAPTER	pAd;
-	NDIS_STATUS		Status;
-	INT 			index;
-	UCHAR			*pBeaconBuf = NULL;
+NDIS_STATUS RTMPAllocAdapterBlock(IN PVOID handle,
+				  OUT PRTMP_ADAPTER * ppAdapter)
+{
+	PRTMP_ADAPTER pAd;
+	NDIS_STATUS Status;
+	INT index;
+	UCHAR *pBeaconBuf = NULL;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPAllocAdapterBlock\n"));
 
 	*ppAdapter = NULL;
 
-	do
-	{
+	do {
 		// Allocate RTMP_ADAPTER memory block
 		pBeaconBuf = kmalloc(MAX_BEACON_SIZE, MEM_ALLOC_FLAG);
-		if (pBeaconBuf == NULL)
-		{
+		if (pBeaconBuf == NULL) {
 			Status = NDIS_STATUS_FAILURE;
 			DBGPRINT_ERR(("Failed to allocate memory - BeaconBuf!\n"));
 			break;
 		}
 		NdisZeroMemory(pBeaconBuf, MAX_BEACON_SIZE);
 
-		Status = AdapterBlockAllocateMemory(handle, (PVOID *)&pAd);
-		if (Status != NDIS_STATUS_SUCCESS)
-		{
+		Status = AdapterBlockAllocateMemory(handle, (PVOID *) & pAd);
+		if (Status != NDIS_STATUS_SUCCESS) {
 			DBGPRINT_ERR(("Failed to allocate memory - ADAPTER\n"));
 			break;
 		}
 		pAd->BeaconBuf = pBeaconBuf;
-		DBGPRINT(RT_DEBUG_OFF, ("\n\n=== pAd = %p, size = %d ===\n\n", pAd, (UINT32)sizeof(RTMP_ADAPTER)));
-
+		DBGPRINT(RT_DEBUG_OFF,
+			 ("\n\n=== pAd = %p, size = %d ===\n\n", pAd,
+			  (UINT32) sizeof(RTMP_ADAPTER)));
 
 		// Init spin locks
 		NdisAllocateSpinLock(&pAd->MgmtRingLock);
 #ifdef RTMP_MAC_PCI
 		NdisAllocateSpinLock(&pAd->RxRingLock);
 #ifdef RT3090
-	NdisAllocateSpinLock(&pAd->McuCmdLock);
+		NdisAllocateSpinLock(&pAd->McuCmdLock);
 #endif // RT3090 //
 #endif // RTMP_MAC_PCI //
 
-		for (index =0 ; index < NUM_OF_TX_RING; index++)
-		{
+		for (index = 0; index < NUM_OF_TX_RING; index++) {
 			NdisAllocateSpinLock(&pAd->TxSwQueueLock[index]);
 			NdisAllocateSpinLock(&pAd->DeQueueLock[index]);
 			pAd->DeQueueRunning[index] = FALSE;
@@ -234,14 +230,13 @@ NDIS_STATUS	RTMPAllocAdapterBlock(
 
 	========================================================================
 */
-VOID	RTMPReadTxPwrPerRate(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPReadTxPwrPerRate(IN PRTMP_ADAPTER pAd)
 {
-	ULONG		data, Adata, Gdata;
-	USHORT		i, value, value2;
-	INT			Apwrdelta, Gpwrdelta;
-	UCHAR		t1,t2,t3,t4;
-	BOOLEAN		bApwrdeltaMinus = TRUE, bGpwrdeltaMinus = TRUE;
+	ULONG data, Adata, Gdata;
+	USHORT i, value, value2;
+	INT Apwrdelta, Gpwrdelta;
+	UCHAR t1, t2, t3, t4;
+	BOOLEAN bApwrdeltaMinus = TRUE, bGpwrdeltaMinus = TRUE;
 
 	//
 	// Get power delta for 20MHz and 40MHz.
@@ -251,178 +246,168 @@ VOID	RTMPReadTxPwrPerRate(
 	Apwrdelta = 0;
 	Gpwrdelta = 0;
 
-	if ((value2 & 0xff) != 0xff)
-	{
+	if ((value2 & 0xff) != 0xff) {
 		if ((value2 & 0x80))
-			Gpwrdelta = (value2&0xf);
+			Gpwrdelta = (value2 & 0xf);
 
 		if ((value2 & 0x40))
 			bGpwrdeltaMinus = FALSE;
 		else
 			bGpwrdeltaMinus = TRUE;
 	}
-	if ((value2 & 0xff00) != 0xff00)
-	{
+	if ((value2 & 0xff00) != 0xff00) {
 		if ((value2 & 0x8000))
-			Apwrdelta = ((value2&0xf00)>>8);
+			Apwrdelta = ((value2 & 0xf00) >> 8);
 
 		if ((value2 & 0x4000))
 			bApwrdeltaMinus = FALSE;
 		else
 			bApwrdeltaMinus = TRUE;
 	}
-	DBGPRINT(RT_DEBUG_TRACE, ("Gpwrdelta = %x, Apwrdelta = %x .\n", Gpwrdelta, Apwrdelta));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Gpwrdelta = %x, Apwrdelta = %x .\n", Gpwrdelta, Apwrdelta));
 
 	//
 	// Get Txpower per MCS for 20MHz in 2.4G.
 	//
-	for (i=0; i<5; i++)
-	{
-		RT28xx_EEPROM_READ16(pAd, EEPROM_TXPOWER_BYRATE_20MHZ_2_4G + i*4, value);
+	for (i = 0; i < 5; i++) {
+		RT28xx_EEPROM_READ16(pAd,
+				     EEPROM_TXPOWER_BYRATE_20MHZ_2_4G + i * 4,
+				     value);
 		data = value;
-		if (bApwrdeltaMinus == FALSE)
-		{
-			t1 = (value&0xf)+(Apwrdelta);
+		if (bApwrdeltaMinus == FALSE) {
+			t1 = (value & 0xf) + (Apwrdelta);
 			if (t1 > 0xf)
 				t1 = 0xf;
-			t2 = ((value&0xf0)>>4)+(Apwrdelta);
+			t2 = ((value & 0xf0) >> 4) + (Apwrdelta);
 			if (t2 > 0xf)
 				t2 = 0xf;
-			t3 = ((value&0xf00)>>8)+(Apwrdelta);
+			t3 = ((value & 0xf00) >> 8) + (Apwrdelta);
 			if (t3 > 0xf)
 				t3 = 0xf;
-			t4 = ((value&0xf000)>>12)+(Apwrdelta);
+			t4 = ((value & 0xf000) >> 12) + (Apwrdelta);
 			if (t4 > 0xf)
 				t4 = 0xf;
-		}
-		else
-		{
-			if ((value&0xf) > Apwrdelta)
-				t1 = (value&0xf)-(Apwrdelta);
+		} else {
+			if ((value & 0xf) > Apwrdelta)
+				t1 = (value & 0xf) - (Apwrdelta);
 			else
 				t1 = 0;
-			if (((value&0xf0)>>4) > Apwrdelta)
-				t2 = ((value&0xf0)>>4)-(Apwrdelta);
+			if (((value & 0xf0) >> 4) > Apwrdelta)
+				t2 = ((value & 0xf0) >> 4) - (Apwrdelta);
 			else
 				t2 = 0;
-			if (((value&0xf00)>>8) > Apwrdelta)
-				t3 = ((value&0xf00)>>8)-(Apwrdelta);
+			if (((value & 0xf00) >> 8) > Apwrdelta)
+				t3 = ((value & 0xf00) >> 8) - (Apwrdelta);
 			else
 				t3 = 0;
-			if (((value&0xf000)>>12) > Apwrdelta)
-				t4 = ((value&0xf000)>>12)-(Apwrdelta);
+			if (((value & 0xf000) >> 12) > Apwrdelta)
+				t4 = ((value & 0xf000) >> 12) - (Apwrdelta);
 			else
 				t4 = 0;
 		}
-		Adata = t1 + (t2<<4) + (t3<<8) + (t4<<12);
-		if (bGpwrdeltaMinus == FALSE)
-		{
-			t1 = (value&0xf)+(Gpwrdelta);
+		Adata = t1 + (t2 << 4) + (t3 << 8) + (t4 << 12);
+		if (bGpwrdeltaMinus == FALSE) {
+			t1 = (value & 0xf) + (Gpwrdelta);
 			if (t1 > 0xf)
 				t1 = 0xf;
-			t2 = ((value&0xf0)>>4)+(Gpwrdelta);
+			t2 = ((value & 0xf0) >> 4) + (Gpwrdelta);
 			if (t2 > 0xf)
 				t2 = 0xf;
-			t3 = ((value&0xf00)>>8)+(Gpwrdelta);
+			t3 = ((value & 0xf00) >> 8) + (Gpwrdelta);
 			if (t3 > 0xf)
 				t3 = 0xf;
-			t4 = ((value&0xf000)>>12)+(Gpwrdelta);
+			t4 = ((value & 0xf000) >> 12) + (Gpwrdelta);
 			if (t4 > 0xf)
 				t4 = 0xf;
-		}
-		else
-		{
-			if ((value&0xf) > Gpwrdelta)
-				t1 = (value&0xf)-(Gpwrdelta);
+		} else {
+			if ((value & 0xf) > Gpwrdelta)
+				t1 = (value & 0xf) - (Gpwrdelta);
 			else
 				t1 = 0;
-			if (((value&0xf0)>>4) > Gpwrdelta)
-				t2 = ((value&0xf0)>>4)-(Gpwrdelta);
+			if (((value & 0xf0) >> 4) > Gpwrdelta)
+				t2 = ((value & 0xf0) >> 4) - (Gpwrdelta);
 			else
 				t2 = 0;
-			if (((value&0xf00)>>8) > Gpwrdelta)
-				t3 = ((value&0xf00)>>8)-(Gpwrdelta);
+			if (((value & 0xf00) >> 8) > Gpwrdelta)
+				t3 = ((value & 0xf00) >> 8) - (Gpwrdelta);
 			else
 				t3 = 0;
-			if (((value&0xf000)>>12) > Gpwrdelta)
-				t4 = ((value&0xf000)>>12)-(Gpwrdelta);
+			if (((value & 0xf000) >> 12) > Gpwrdelta)
+				t4 = ((value & 0xf000) >> 12) - (Gpwrdelta);
 			else
 				t4 = 0;
 		}
-		Gdata = t1 + (t2<<4) + (t3<<8) + (t4<<12);
+		Gdata = t1 + (t2 << 4) + (t3 << 8) + (t4 << 12);
 
-		RT28xx_EEPROM_READ16(pAd, EEPROM_TXPOWER_BYRATE_20MHZ_2_4G + i*4 + 2, value);
-		if (bApwrdeltaMinus == FALSE)
-		{
-			t1 = (value&0xf)+(Apwrdelta);
+		RT28xx_EEPROM_READ16(pAd,
+				     EEPROM_TXPOWER_BYRATE_20MHZ_2_4G + i * 4 +
+				     2, value);
+		if (bApwrdeltaMinus == FALSE) {
+			t1 = (value & 0xf) + (Apwrdelta);
 			if (t1 > 0xf)
 				t1 = 0xf;
-			t2 = ((value&0xf0)>>4)+(Apwrdelta);
+			t2 = ((value & 0xf0) >> 4) + (Apwrdelta);
 			if (t2 > 0xf)
 				t2 = 0xf;
-			t3 = ((value&0xf00)>>8)+(Apwrdelta);
+			t3 = ((value & 0xf00) >> 8) + (Apwrdelta);
 			if (t3 > 0xf)
 				t3 = 0xf;
-			t4 = ((value&0xf000)>>12)+(Apwrdelta);
+			t4 = ((value & 0xf000) >> 12) + (Apwrdelta);
 			if (t4 > 0xf)
 				t4 = 0xf;
-		}
-		else
-		{
-			if ((value&0xf) > Apwrdelta)
-				t1 = (value&0xf)-(Apwrdelta);
+		} else {
+			if ((value & 0xf) > Apwrdelta)
+				t1 = (value & 0xf) - (Apwrdelta);
 			else
 				t1 = 0;
-			if (((value&0xf0)>>4) > Apwrdelta)
-				t2 = ((value&0xf0)>>4)-(Apwrdelta);
+			if (((value & 0xf0) >> 4) > Apwrdelta)
+				t2 = ((value & 0xf0) >> 4) - (Apwrdelta);
 			else
 				t2 = 0;
-			if (((value&0xf00)>>8) > Apwrdelta)
-				t3 = ((value&0xf00)>>8)-(Apwrdelta);
+			if (((value & 0xf00) >> 8) > Apwrdelta)
+				t3 = ((value & 0xf00) >> 8) - (Apwrdelta);
 			else
 				t3 = 0;
-			if (((value&0xf000)>>12) > Apwrdelta)
-				t4 = ((value&0xf000)>>12)-(Apwrdelta);
+			if (((value & 0xf000) >> 12) > Apwrdelta)
+				t4 = ((value & 0xf000) >> 12) - (Apwrdelta);
 			else
 				t4 = 0;
 		}
-		Adata |= ((t1<<16) + (t2<<20) + (t3<<24) + (t4<<28));
-		if (bGpwrdeltaMinus == FALSE)
-		{
-			t1 = (value&0xf)+(Gpwrdelta);
+		Adata |= ((t1 << 16) + (t2 << 20) + (t3 << 24) + (t4 << 28));
+		if (bGpwrdeltaMinus == FALSE) {
+			t1 = (value & 0xf) + (Gpwrdelta);
 			if (t1 > 0xf)
 				t1 = 0xf;
-			t2 = ((value&0xf0)>>4)+(Gpwrdelta);
+			t2 = ((value & 0xf0) >> 4) + (Gpwrdelta);
 			if (t2 > 0xf)
 				t2 = 0xf;
-			t3 = ((value&0xf00)>>8)+(Gpwrdelta);
+			t3 = ((value & 0xf00) >> 8) + (Gpwrdelta);
 			if (t3 > 0xf)
 				t3 = 0xf;
-			t4 = ((value&0xf000)>>12)+(Gpwrdelta);
+			t4 = ((value & 0xf000) >> 12) + (Gpwrdelta);
 			if (t4 > 0xf)
 				t4 = 0xf;
-		}
-		else
-		{
-			if ((value&0xf) > Gpwrdelta)
-				t1 = (value&0xf)-(Gpwrdelta);
+		} else {
+			if ((value & 0xf) > Gpwrdelta)
+				t1 = (value & 0xf) - (Gpwrdelta);
 			else
 				t1 = 0;
-			if (((value&0xf0)>>4) > Gpwrdelta)
-				t2 = ((value&0xf0)>>4)-(Gpwrdelta);
+			if (((value & 0xf0) >> 4) > Gpwrdelta)
+				t2 = ((value & 0xf0) >> 4) - (Gpwrdelta);
 			else
 				t2 = 0;
-			if (((value&0xf00)>>8) > Gpwrdelta)
-				t3 = ((value&0xf00)>>8)-(Gpwrdelta);
+			if (((value & 0xf00) >> 8) > Gpwrdelta)
+				t3 = ((value & 0xf00) >> 8) - (Gpwrdelta);
 			else
 				t3 = 0;
-			if (((value&0xf000)>>12) > Gpwrdelta)
-				t4 = ((value&0xf000)>>12)-(Gpwrdelta);
+			if (((value & 0xf000) >> 12) > Gpwrdelta)
+				t4 = ((value & 0xf000) >> 12) - (Gpwrdelta);
 			else
 				t4 = 0;
 		}
-		Gdata |= ((t1<<16) + (t2<<20) + (t3<<24) + (t4<<28));
-		data |= (value<<16);
+		Gdata |= ((t1 << 16) + (t2 << 20) + (t3 << 24) + (t4 << 28));
+		data |= (value << 16);
 
 		/* For 20M/40M Power Delta issue */
 		pAd->Tx20MPwrCfgABand[i] = data;
@@ -431,12 +416,13 @@ VOID	RTMPReadTxPwrPerRate(
 		pAd->Tx40MPwrCfgGBand[i] = Gdata;
 
 		if (data != 0xffffffff)
-			RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + i*4, data);
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("20MHz BW, 2.4G band-%lx,  Adata = %lx,  Gdata = %lx \n", data, Adata, Gdata));
+			RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + i * 4, data);
+		DBGPRINT_RAW(RT_DEBUG_TRACE,
+			     ("20MHz BW, 2.4G band-%lx,  Adata = %lx,  Gdata = %lx \n",
+			      data, Adata, Gdata));
 	}
 }
 
-
 /*
 	========================================================================
 
@@ -455,12 +441,11 @@ VOID	RTMPReadTxPwrPerRate(
 
 	========================================================================
 */
-VOID	RTMPReadChannelPwr(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR				i, choffset;
-	EEPROM_TX_PWR_STRUC	    Power;
-	EEPROM_TX_PWR_STRUC	    Power2;
+	UCHAR i, choffset;
+	EEPROM_TX_PWR_STRUC Power;
+	EEPROM_TX_PWR_STRUC Power2;
 
 	// Read Tx power value for all channels
 	// Value from 1 - 0x7f. Default value is 24.
@@ -468,10 +453,11 @@ VOID	RTMPReadChannelPwr(
 	//             : 5.5G 0xF9 (-7) ~ 0x0F (15)
 
 	// 0. 11b/g, ch1 - ch 14
-	for (i = 0; i < 7; i++)
-	{
-		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX_PWR_OFFSET + i * 2, Power.word);
-		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX2_PWR_OFFSET + i * 2, Power2.word);
+	for (i = 0; i < 7; i++) {
+		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX_PWR_OFFSET + i * 2,
+				     Power.word);
+		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX2_PWR_OFFSET + i * 2,
+				     Power2.word);
 		pAd->TxPower[i * 2].Channel = i * 2 + 1;
 		pAd->TxPower[i * 2 + 1].Channel = i * 2 + 2;
 
@@ -499,131 +485,146 @@ VOID	RTMPReadChannelPwr(
 	// 1. U-NII lower/middle band: 36, 38, 40; 44, 46, 48; 52, 54, 56; 60, 62, 64 (including central frequency in BW 40MHz)
 	// 1.1 Fill up channel
 	choffset = 14;
-	for (i = 0; i < 4; i++)
-	{
-		pAd->TxPower[3 * i + choffset + 0].Channel	= 36 + i * 8 + 0;
-		pAd->TxPower[3 * i + choffset + 0].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 0].Power2	= DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 1].Channel	= 36 + i * 8 + 2;
-		pAd->TxPower[3 * i + choffset + 1].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 1].Power2	= DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 2].Channel	= 36 + i * 8 + 4;
-		pAd->TxPower[3 * i + choffset + 2].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 2].Power2	= DEFAULT_RF_TX_POWER;
+	for (i = 0; i < 4; i++) {
+		pAd->TxPower[3 * i + choffset + 0].Channel = 36 + i * 8 + 0;
+		pAd->TxPower[3 * i + choffset + 0].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
+
+		pAd->TxPower[3 * i + choffset + 1].Channel = 36 + i * 8 + 2;
+		pAd->TxPower[3 * i + choffset + 1].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
+
+		pAd->TxPower[3 * i + choffset + 2].Channel = 36 + i * 8 + 4;
+		pAd->TxPower[3 * i + choffset + 2].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 2].Power2 = DEFAULT_RF_TX_POWER;
 	}
 
 	// 1.2 Fill up power
-	for (i = 0; i < 6; i++)
-	{
-		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + i * 2, Power.word);
-		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + i * 2, Power2.word);
+	for (i = 0; i < 6; i++) {
+		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + i * 2,
+				     Power.word);
+		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + i * 2,
+				     Power2.word);
 
 		if ((Power.field.Byte0 < 16) && (Power.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power = Power.field.Byte0;
+			pAd->TxPower[i * 2 + choffset + 0].Power =
+			    Power.field.Byte0;
 
 		if ((Power.field.Byte1 < 16) && (Power.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power = Power.field.Byte1;
+			pAd->TxPower[i * 2 + choffset + 1].Power =
+			    Power.field.Byte1;
 
 		if ((Power2.field.Byte0 < 16) && (Power2.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power2 = Power2.field.Byte0;
+			pAd->TxPower[i * 2 + choffset + 0].Power2 =
+			    Power2.field.Byte0;
 
 		if ((Power2.field.Byte1 < 16) && (Power2.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power2 = Power2.field.Byte1;
+			pAd->TxPower[i * 2 + choffset + 1].Power2 =
+			    Power2.field.Byte1;
 	}
 
 	// 2. HipperLAN 2 100, 102 ,104; 108, 110, 112; 116, 118, 120; 124, 126, 128; 132, 134, 136; 140 (including central frequency in BW 40MHz)
 	// 2.1 Fill up channel
 	choffset = 14 + 12;
-	for (i = 0; i < 5; i++)
-	{
-		pAd->TxPower[3 * i + choffset + 0].Channel	= 100 + i * 8 + 0;
-		pAd->TxPower[3 * i + choffset + 0].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 0].Power2	= DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 1].Channel	= 100 + i * 8 + 2;
-		pAd->TxPower[3 * i + choffset + 1].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 1].Power2	= DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 2].Channel	= 100 + i * 8 + 4;
-		pAd->TxPower[3 * i + choffset + 2].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 2].Power2	= DEFAULT_RF_TX_POWER;
-	}
-	pAd->TxPower[3 * 5 + choffset + 0].Channel		= 140;
-	pAd->TxPower[3 * 5 + choffset + 0].Power		= DEFAULT_RF_TX_POWER;
-	pAd->TxPower[3 * 5 + choffset + 0].Power2		= DEFAULT_RF_TX_POWER;
+	for (i = 0; i < 5; i++) {
+		pAd->TxPower[3 * i + choffset + 0].Channel = 100 + i * 8 + 0;
+		pAd->TxPower[3 * i + choffset + 0].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
+
+		pAd->TxPower[3 * i + choffset + 1].Channel = 100 + i * 8 + 2;
+		pAd->TxPower[3 * i + choffset + 1].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
+
+		pAd->TxPower[3 * i + choffset + 2].Channel = 100 + i * 8 + 4;
+		pAd->TxPower[3 * i + choffset + 2].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 2].Power2 = DEFAULT_RF_TX_POWER;
+	}
+	pAd->TxPower[3 * 5 + choffset + 0].Channel = 140;
+	pAd->TxPower[3 * 5 + choffset + 0].Power = DEFAULT_RF_TX_POWER;
+	pAd->TxPower[3 * 5 + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
 
 	// 2.2 Fill up power
-	for (i = 0; i < 8; i++)
-	{
-		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2, Power.word);
-		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2, Power2.word);
+	for (i = 0; i < 8; i++) {
+		RT28xx_EEPROM_READ16(pAd,
+				     EEPROM_A_TX_PWR_OFFSET + (choffset - 14) +
+				     i * 2, Power.word);
+		RT28xx_EEPROM_READ16(pAd,
+				     EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) +
+				     i * 2, Power2.word);
 
 		if ((Power.field.Byte0 < 16) && (Power.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power = Power.field.Byte0;
+			pAd->TxPower[i * 2 + choffset + 0].Power =
+			    Power.field.Byte0;
 
 		if ((Power.field.Byte1 < 16) && (Power.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power = Power.field.Byte1;
+			pAd->TxPower[i * 2 + choffset + 1].Power =
+			    Power.field.Byte1;
 
 		if ((Power2.field.Byte0 < 16) && (Power2.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power2 = Power2.field.Byte0;
+			pAd->TxPower[i * 2 + choffset + 0].Power2 =
+			    Power2.field.Byte0;
 
 		if ((Power2.field.Byte1 < 16) && (Power2.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power2 = Power2.field.Byte1;
+			pAd->TxPower[i * 2 + choffset + 1].Power2 =
+			    Power2.field.Byte1;
 	}
 
 	// 3. U-NII upper band: 149, 151, 153; 157, 159, 161; 165, 167, 169; 171, 173 (including central frequency in BW 40MHz)
 	// 3.1 Fill up channel
 	choffset = 14 + 12 + 16;
-	/*for (i = 0; i < 2; i++)*/
-	for (i = 0; i < 3; i++)
-	{
-		pAd->TxPower[3 * i + choffset + 0].Channel	= 149 + i * 8 + 0;
-		pAd->TxPower[3 * i + choffset + 0].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 0].Power2	= DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 1].Channel	= 149 + i * 8 + 2;
-		pAd->TxPower[3 * i + choffset + 1].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 1].Power2	= DEFAULT_RF_TX_POWER;
-
-		pAd->TxPower[3 * i + choffset + 2].Channel	= 149 + i * 8 + 4;
-		pAd->TxPower[3 * i + choffset + 2].Power	= DEFAULT_RF_TX_POWER;
-		pAd->TxPower[3 * i + choffset + 2].Power2	= DEFAULT_RF_TX_POWER;
-	}
-	pAd->TxPower[3 * 3 + choffset + 0].Channel		= 171;
-	pAd->TxPower[3 * 3 + choffset + 0].Power		= DEFAULT_RF_TX_POWER;
-	pAd->TxPower[3 * 3 + choffset + 0].Power2		= DEFAULT_RF_TX_POWER;
-
-	pAd->TxPower[3 * 3 + choffset + 1].Channel		= 173;
-	pAd->TxPower[3 * 3 + choffset + 1].Power		= DEFAULT_RF_TX_POWER;
-	pAd->TxPower[3 * 3 + choffset + 1].Power2		= DEFAULT_RF_TX_POWER;
+	/*for (i = 0; i < 2; i++) */
+	for (i = 0; i < 3; i++) {
+		pAd->TxPower[3 * i + choffset + 0].Channel = 149 + i * 8 + 0;
+		pAd->TxPower[3 * i + choffset + 0].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
+
+		pAd->TxPower[3 * i + choffset + 1].Channel = 149 + i * 8 + 2;
+		pAd->TxPower[3 * i + choffset + 1].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
+
+		pAd->TxPower[3 * i + choffset + 2].Channel = 149 + i * 8 + 4;
+		pAd->TxPower[3 * i + choffset + 2].Power = DEFAULT_RF_TX_POWER;
+		pAd->TxPower[3 * i + choffset + 2].Power2 = DEFAULT_RF_TX_POWER;
+	}
+	pAd->TxPower[3 * 3 + choffset + 0].Channel = 171;
+	pAd->TxPower[3 * 3 + choffset + 0].Power = DEFAULT_RF_TX_POWER;
+	pAd->TxPower[3 * 3 + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
+
+	pAd->TxPower[3 * 3 + choffset + 1].Channel = 173;
+	pAd->TxPower[3 * 3 + choffset + 1].Power = DEFAULT_RF_TX_POWER;
+	pAd->TxPower[3 * 3 + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
 
 	// 3.2 Fill up power
-	/*for (i = 0; i < 4; i++)*/
-	for (i = 0; i < 6; i++)
-	{
-		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2, Power.word);
-		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2, Power2.word);
+	/*for (i = 0; i < 4; i++) */
+	for (i = 0; i < 6; i++) {
+		RT28xx_EEPROM_READ16(pAd,
+				     EEPROM_A_TX_PWR_OFFSET + (choffset - 14) +
+				     i * 2, Power.word);
+		RT28xx_EEPROM_READ16(pAd,
+				     EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) +
+				     i * 2, Power2.word);
 
 		if ((Power.field.Byte0 < 16) && (Power.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power = Power.field.Byte0;
+			pAd->TxPower[i * 2 + choffset + 0].Power =
+			    Power.field.Byte0;
 
 		if ((Power.field.Byte1 < 16) && (Power.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power = Power.field.Byte1;
+			pAd->TxPower[i * 2 + choffset + 1].Power =
+			    Power.field.Byte1;
 
 		if ((Power2.field.Byte0 < 16) && (Power2.field.Byte0 >= -7))
-			pAd->TxPower[i * 2 + choffset + 0].Power2 = Power2.field.Byte0;
+			pAd->TxPower[i * 2 + choffset + 0].Power2 =
+			    Power2.field.Byte0;
 
 		if ((Power2.field.Byte1 < 16) && (Power2.field.Byte1 >= -7))
-			pAd->TxPower[i * 2 + choffset + 1].Power2 = Power2.field.Byte1;
+			pAd->TxPower[i * 2 + choffset + 1].Power2 =
+			    Power2.field.Byte1;
 	}
 
 	// 4. Print and Debug
-	/*choffset = 14 + 12 + 16 + 7;*/
+	/*choffset = 14 + 12 + 16 + 7; */
 	choffset = 14 + 12 + 16 + 11;
 
-
 }
 
 /*
@@ -649,17 +650,14 @@ VOID	RTMPReadChannelPwr(
 
 	========================================================================
 */
-NDIS_STATUS	NICReadRegParameters(
-	IN	PRTMP_ADAPTER		pAd,
-	IN	NDIS_HANDLE			WrapperConfigurationContext
-	)
+NDIS_STATUS NICReadRegParameters(IN PRTMP_ADAPTER pAd,
+				 IN NDIS_HANDLE WrapperConfigurationContext)
 {
-	NDIS_STATUS						Status = NDIS_STATUS_SUCCESS;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
 	DBGPRINT_S(Status, ("<-- NICReadRegParameters, Status=%x\n", Status));
 	return Status;
 }
 
-
 /*
 	========================================================================
 
@@ -678,17 +676,15 @@ NDIS_STATUS	NICReadRegParameters(
 
 	========================================================================
 */
-VOID	NICReadEEPROMParameters(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			mac_addr)
-{
-	UINT32			data = 0;
-	USHORT			i, value, value2;
-	UCHAR			TmpPhy;
-	EEPROM_TX_PWR_STRUC	    Power;
-	EEPROM_VERSION_STRUC    Version;
-	EEPROM_ANTENNA_STRUC	Antenna;
-	EEPROM_NIC_CONFIG2_STRUC    NicConfig2;
+VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
+{
+	UINT32 data = 0;
+	USHORT i, value, value2;
+	UCHAR TmpPhy;
+	EEPROM_TX_PWR_STRUC Power;
+	EEPROM_VERSION_STRUC Version;
+	EEPROM_ANTENNA_STRUC Antenna;
+	EEPROM_NIC_CONFIG2_STRUC NicConfig2;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICReadEEPROMParameters\n"));
 
@@ -699,70 +695,72 @@ VOID	NICReadEEPROMParameters(
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &data);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> E2PROM_CSR = 0x%x\n", data));
 
-	if((data & 0x30) == 0)
-		pAd->EEPROMAddressNum = 6;		// 93C46
-	else if((data & 0x30) == 0x10)
-		pAd->EEPROMAddressNum = 8;     // 93C66
+	if ((data & 0x30) == 0)
+		pAd->EEPROMAddressNum = 6;	// 93C46
+	else if ((data & 0x30) == 0x10)
+		pAd->EEPROMAddressNum = 8;	// 93C66
 	else
-		pAd->EEPROMAddressNum = 8;     // 93C86
-	DBGPRINT(RT_DEBUG_TRACE, ("--> EEPROMAddressNum = %d\n", pAd->EEPROMAddressNum ));
+		pAd->EEPROMAddressNum = 8;	// 93C86
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("--> EEPROMAddressNum = %d\n", pAd->EEPROMAddressNum));
 
 	// RT2860 MAC no longer auto load MAC address from E2PROM. Driver has to intialize
 	// MAC address registers according to E2PROM setting
 	if (mac_addr == NULL ||
-		strlen((PSTRING) mac_addr) != 17 ||
-		mac_addr[2] != ':'  || mac_addr[5] != ':'  || mac_addr[8] != ':' ||
-		mac_addr[11] != ':' || mac_addr[14] != ':')
-	{
-		USHORT  Addr01,Addr23,Addr45 ;
+	    strlen((PSTRING) mac_addr) != 17 ||
+	    mac_addr[2] != ':' || mac_addr[5] != ':' || mac_addr[8] != ':' ||
+	    mac_addr[11] != ':' || mac_addr[14] != ':') {
+		USHORT Addr01, Addr23, Addr45;
 
 		RT28xx_EEPROM_READ16(pAd, 0x04, Addr01);
 		RT28xx_EEPROM_READ16(pAd, 0x06, Addr23);
 		RT28xx_EEPROM_READ16(pAd, 0x08, Addr45);
 
-		pAd->PermanentAddress[0] = (UCHAR)(Addr01 & 0xff);
-		pAd->PermanentAddress[1] = (UCHAR)(Addr01 >> 8);
-		pAd->PermanentAddress[2] = (UCHAR)(Addr23 & 0xff);
-		pAd->PermanentAddress[3] = (UCHAR)(Addr23 >> 8);
-		pAd->PermanentAddress[4] = (UCHAR)(Addr45 & 0xff);
-		pAd->PermanentAddress[5] = (UCHAR)(Addr45 >> 8);
-
-		DBGPRINT(RT_DEBUG_TRACE, ("Initialize MAC Address from E2PROM \n"));
-	}
-	else
-	{
-		INT		j;
-		PSTRING	macptr;
+		pAd->PermanentAddress[0] = (UCHAR) (Addr01 & 0xff);
+		pAd->PermanentAddress[1] = (UCHAR) (Addr01 >> 8);
+		pAd->PermanentAddress[2] = (UCHAR) (Addr23 & 0xff);
+		pAd->PermanentAddress[3] = (UCHAR) (Addr23 >> 8);
+		pAd->PermanentAddress[4] = (UCHAR) (Addr45 & 0xff);
+		pAd->PermanentAddress[5] = (UCHAR) (Addr45 >> 8);
+
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Initialize MAC Address from E2PROM \n"));
+	} else {
+		INT j;
+		PSTRING macptr;
 
 		macptr = (PSTRING) mac_addr;
 
-		for (j=0; j<MAC_ADDR_LEN; j++)
-		{
+		for (j = 0; j < MAC_ADDR_LEN; j++) {
 			AtoH(macptr, &pAd->PermanentAddress[j], 1);
-			macptr=macptr+3;
+			macptr = macptr + 3;
 		}
 
-		DBGPRINT(RT_DEBUG_TRACE, ("Initialize MAC Address from module parameter \n"));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Initialize MAC Address from module parameter \n"));
 	}
 
-
 	{
 		//more conveninet to test mbssid, so ap's bssid &0xf1
 		if (pAd->PermanentAddress[0] == 0xff)
-			pAd->PermanentAddress[0] = RandomByte(pAd)&0xf8;
+			pAd->PermanentAddress[0] = RandomByte(pAd) & 0xf8;
 
 		//if (pAd->PermanentAddress[5] == 0xff)
-		//	pAd->PermanentAddress[5] = RandomByte(pAd)&0xf8;
+		//      pAd->PermanentAddress[5] = RandomByte(pAd)&0xf8;
 
-		DBGPRINT_RAW(RT_DEBUG_TRACE,("E2PROM MAC: =%02x:%02x:%02x:%02x:%02x:%02x\n",
-			pAd->PermanentAddress[0], pAd->PermanentAddress[1],
-			pAd->PermanentAddress[2], pAd->PermanentAddress[3],
-			pAd->PermanentAddress[4], pAd->PermanentAddress[5]));
-		if (pAd->bLocalAdminMAC == FALSE)
-		{
+		DBGPRINT_RAW(RT_DEBUG_TRACE,
+			     ("E2PROM MAC: =%02x:%02x:%02x:%02x:%02x:%02x\n",
+			      pAd->PermanentAddress[0],
+			      pAd->PermanentAddress[1],
+			      pAd->PermanentAddress[2],
+			      pAd->PermanentAddress[3],
+			      pAd->PermanentAddress[4],
+			      pAd->PermanentAddress[5]));
+		if (pAd->bLocalAdminMAC == FALSE) {
 			MAC_DW0_STRUC csr2;
 			MAC_DW1_STRUC csr3;
-			COPY_MAC_ADDR(pAd->CurrentAddress, pAd->PermanentAddress);
+			COPY_MAC_ADDR(pAd->CurrentAddress,
+				      pAd->PermanentAddress);
 			csr2.field.Byte0 = pAd->CurrentAddress[0];
 			csr2.field.Byte1 = pAd->CurrentAddress[1];
 			csr2.field.Byte2 = pAd->CurrentAddress[2];
@@ -773,8 +771,9 @@ VOID	NICReadEEPROMParameters(
 			csr3.field.Byte5 = pAd->CurrentAddress[5];
 			csr3.field.U2MeMask = 0xff;
 			RTMP_IO_WRITE32(pAd, MAC_ADDR_DW1, csr3.word);
-			DBGPRINT_RAW(RT_DEBUG_TRACE,("E2PROM MAC: =%02x:%02x:%02x:%02x:%02x:%02x\n",
-							PRINT_MAC(pAd->PermanentAddress)));
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("E2PROM MAC: =%02x:%02x:%02x:%02x:%02x:%02x\n",
+				      PRINT_MAC(pAd->PermanentAddress)));
 		}
 	}
 
@@ -785,31 +784,33 @@ VOID	NICReadEEPROMParameters(
 	// if E2PROM version mismatch with driver's expectation, then skip
 	// all subsequent E2RPOM retieval and set a system error bit to notify GUI
 	RT28xx_EEPROM_READ16(pAd, EEPROM_VERSION_OFFSET, Version.word);
-	pAd->EepromVersion = Version.field.Version + Version.field.FaeReleaseNumber * 256;
-	DBGPRINT(RT_DEBUG_TRACE, ("E2PROM: Version = %d, FAE release #%d\n", Version.field.Version, Version.field.FaeReleaseNumber));
-
-	if (Version.field.Version > VALID_EEPROM_VERSION)
-	{
-		DBGPRINT_ERR(("E2PROM: WRONG VERSION 0x%x, should be %d\n",Version.field.Version, VALID_EEPROM_VERSION));
+	pAd->EepromVersion =
+	    Version.field.Version + Version.field.FaeReleaseNumber * 256;
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("E2PROM: Version = %d, FAE release #%d\n",
+		  Version.field.Version, Version.field.FaeReleaseNumber));
+
+	if (Version.field.Version > VALID_EEPROM_VERSION) {
+		DBGPRINT_ERR(("E2PROM: WRONG VERSION 0x%x, should be %d\n",
+			      Version.field.Version, VALID_EEPROM_VERSION));
 		/*pAd->SystemErrorBitmap |= 0x00000001;
 
-		// hard-code default value when no proper E2PROM installed
-		pAd->bAutoTxAgcA = FALSE;
-		pAd->bAutoTxAgcG = FALSE;
-
-		// Default the channel power
-		for (i = 0; i < MAX_NUM_OF_CHANNELS; i++)
-			pAd->TxPower[i].Power = DEFAULT_RF_TX_POWER;
-
-		// Default the channel power
-		for (i = 0; i < MAX_NUM_OF_11JCHANNELS; i++)
-			pAd->TxPower11J[i].Power = DEFAULT_RF_TX_POWER;
-
-		for(i = 0; i < NUM_EEPROM_BBP_PARMS; i++)
-			pAd->EEPROMDefaultValue[i] = 0xffff;
-		return;  */
+		   // hard-code default value when no proper E2PROM installed
+		   pAd->bAutoTxAgcA = FALSE;
+		   pAd->bAutoTxAgcG = FALSE;
+
+		   // Default the channel power
+		   for (i = 0; i < MAX_NUM_OF_CHANNELS; i++)
+		   pAd->TxPower[i].Power = DEFAULT_RF_TX_POWER;
+
+		   // Default the channel power
+		   for (i = 0; i < MAX_NUM_OF_11JCHANNELS; i++)
+		   pAd->TxPower11J[i].Power = DEFAULT_RF_TX_POWER;
+
+		   for(i = 0; i < NUM_EEPROM_BBP_PARMS; i++)
+		   pAd->EEPROMDefaultValue[i] = 0xffff;
+		   return;  */
 	}
-
 	// Read BBP default value from EEPROM and store to array(EEPROMDefaultValue) in pAd
 	RT28xx_EEPROM_READ16(pAd, EEPROM_NIC1_OFFSET, value);
 	pAd->EEPROMDefaultValue[0] = value;
@@ -820,10 +821,10 @@ VOID	NICReadEEPROMParameters(
 	RT28xx_EEPROM_READ16(pAd, 0x38, value);	// Country Region
 	pAd->EEPROMDefaultValue[2] = value;
 
-	for(i = 0; i < 8; i++)
-	{
-		RT28xx_EEPROM_READ16(pAd, EEPROM_BBP_BASE_OFFSET + i*2, value);
-		pAd->EEPROMDefaultValue[i+3] = value;
+	for (i = 0; i < 8; i++) {
+		RT28xx_EEPROM_READ16(pAd, EEPROM_BBP_BASE_OFFSET + i * 2,
+				     value);
+		pAd->EEPROMDefaultValue[i + 3] = value;
 	}
 
 	// We have to parse NIC configuration 0 at here.
@@ -831,61 +832,55 @@ VOID	NICReadEEPROMParameters(
 	// Therefore, we have to read TxAutoAgc control beforehand.
 	// Read Tx AGC control bit
 	Antenna.word = pAd->EEPROMDefaultValue[0];
-	if (Antenna.word == 0xFFFF)
-	{
+	if (Antenna.word == 0xFFFF) {
 #ifdef RT30xx
-		if(IS_RT3090(pAd)|| IS_RT3390(pAd))
-		{
+		if (IS_RT3090(pAd) || IS_RT3390(pAd)) {
 			Antenna.word = 0;
 			Antenna.field.RfIcType = RFIC_3020;
 			Antenna.field.TxPath = 1;
 			Antenna.field.RxPath = 1;
-		}
-		else
+		} else
 #endif // RT30xx //
 		{
 
-		Antenna.word = 0;
-		Antenna.field.RfIcType = RFIC_2820;
-		Antenna.field.TxPath = 1;
-		Antenna.field.RxPath = 2;
-		DBGPRINT(RT_DEBUG_WARN, ("E2PROM error, hard code as 0x%04x\n", Antenna.word));
+			Antenna.word = 0;
+			Antenna.field.RfIcType = RFIC_2820;
+			Antenna.field.TxPath = 1;
+			Antenna.field.RxPath = 2;
+			DBGPRINT(RT_DEBUG_WARN,
+				 ("E2PROM error, hard code as 0x%04x\n",
+				  Antenna.word));
 		}
 	}
-
 	// Choose the desired Tx&Rx stream.
-	if ((pAd->CommonCfg.TxStream == 0) || (pAd->CommonCfg.TxStream > Antenna.field.TxPath))
+	if ((pAd->CommonCfg.TxStream == 0)
+	    || (pAd->CommonCfg.TxStream > Antenna.field.TxPath))
 		pAd->CommonCfg.TxStream = Antenna.field.TxPath;
 
-	if ((pAd->CommonCfg.RxStream == 0) || (pAd->CommonCfg.RxStream > Antenna.field.RxPath))
-	{
+	if ((pAd->CommonCfg.RxStream == 0)
+	    || (pAd->CommonCfg.RxStream > Antenna.field.RxPath)) {
 		pAd->CommonCfg.RxStream = Antenna.field.RxPath;
 
 		if ((pAd->MACVersion < RALINK_2883_VERSION) &&
-			(pAd->CommonCfg.RxStream > 2))
-		{
+		    (pAd->CommonCfg.RxStream > 2)) {
 			// only 2 Rx streams for RT2860 series
 			pAd->CommonCfg.RxStream = 2;
 		}
 	}
-
 	// 3*3
 	// read value from EEPROM and set them to CSR174 ~ 177 in chain0 ~ chain2
 	// yet implement
-	for(i=0; i<3; i++)
-	{
+	for (i = 0; i < 3; i++) {
 	}
 
 	NicConfig2.word = pAd->EEPROMDefaultValue[1];
 
 	{
-		if ((NicConfig2.word & 0x00ff) == 0xff)
-		{
+		if ((NicConfig2.word & 0x00ff) == 0xff) {
 			NicConfig2.word &= 0xff00;
 		}
 
-		if ((NicConfig2.word >> 8) == 0xff)
-		{
+		if ((NicConfig2.word >> 8) == 0xff) {
 			NicConfig2.word &= 0x00ff;
 		}
 	}
@@ -895,7 +890,9 @@ VOID	NICReadEEPROMParameters(
 	else
 		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = FALSE;
 
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("NICReadEEPROMParameters: RxPath = %d, TxPath = %d\n", Antenna.field.RxPath, Antenna.field.TxPath));
+	DBGPRINT_RAW(RT_DEBUG_TRACE,
+		     ("NICReadEEPROMParameters: RxPath = %d, TxPath = %d\n",
+		      Antenna.field.RxPath, Antenna.field.TxPath));
 
 	// Save the antenna for future use
 	pAd->Antenna.word = Antenna.word;
@@ -909,28 +906,25 @@ VOID	NICReadEEPROMParameters(
 #endif // RTMP_RF_RW_SUPPORT //
 
 #ifdef RTMP_MAC_PCI
-		sprintf((PSTRING) pAd->nickname, "RT2860STA");
+	sprintf((PSTRING) pAd->nickname, "RT2860STA");
 #endif // RTMP_MAC_PCI //
 
-
 	//
 	// Reset PhyMode if we don't support 802.11a
 	// Only RFIC_2850 & RFIC_2750 support 802.11a
 	//
 	if ((Antenna.field.RfIcType != RFIC_2850)
-		&& (Antenna.field.RfIcType != RFIC_2750)
-		&& (Antenna.field.RfIcType != RFIC_3052))
-	{
+	    && (Antenna.field.RfIcType != RFIC_2750)
+	    && (Antenna.field.RfIcType != RFIC_3052)) {
 		if ((pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED) ||
-			(pAd->CommonCfg.PhyMode == PHY_11A))
+		    (pAd->CommonCfg.PhyMode == PHY_11A))
 			pAd->CommonCfg.PhyMode = PHY_11BG_MIXED;
-		else if ((pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED)	||
-				 (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED) 	||
-				 (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED) 	||
-				 (pAd->CommonCfg.PhyMode == PHY_11N_5G))
+		else if ((pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) ||
+			 (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED) ||
+			 (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED) ||
+			 (pAd->CommonCfg.PhyMode == PHY_11N_5G))
 			pAd->CommonCfg.PhyMode = PHY_11BGN_MIXED;
 	}
-
 	// Read TSSI reference and TSSI boundary for temperature compensation. This is ugly
 	// 0. 11b/g
 	{
@@ -945,7 +939,7 @@ VOID	NICReadEEPROMParameters(
 		pAd->TssiMinusBoundaryG[2] = Power.field.Byte0;
 		pAd->TssiMinusBoundaryG[1] = Power.field.Byte1;
 		RT28xx_EEPROM_READ16(pAd, 0x72, Power.word);
-		pAd->TssiRefG   = Power.field.Byte0; /* reference value [0] */
+		pAd->TssiRefG = Power.field.Byte0;	/* reference value [0] */
 		pAd->TssiPlusBoundaryG[1] = Power.field.Byte1;
 		RT28xx_EEPROM_READ16(pAd, 0x74, Power.word);
 		pAd->TssiPlusBoundaryG[2] = Power.field.Byte0;
@@ -955,17 +949,21 @@ VOID	NICReadEEPROMParameters(
 		pAd->TxAgcStepG = Power.field.Byte1;
 		pAd->TxAgcCompensateG = 0;
 		pAd->TssiMinusBoundaryG[0] = pAd->TssiRefG;
-		pAd->TssiPlusBoundaryG[0]  = pAd->TssiRefG;
+		pAd->TssiPlusBoundaryG[0] = pAd->TssiRefG;
 
 		// Disable TxAgc if the based value is not right
 		if (pAd->TssiRefG == 0xff)
 			pAd->bAutoTxAgcG = FALSE;
 
-		DBGPRINT(RT_DEBUG_TRACE,("E2PROM: G Tssi[-4 .. +4] = %d %d %d %d - %d -%d %d %d %d, step=%d, tuning=%d\n",
-			pAd->TssiMinusBoundaryG[4], pAd->TssiMinusBoundaryG[3], pAd->TssiMinusBoundaryG[2], pAd->TssiMinusBoundaryG[1],
-			pAd->TssiRefG,
-			pAd->TssiPlusBoundaryG[1], pAd->TssiPlusBoundaryG[2], pAd->TssiPlusBoundaryG[3], pAd->TssiPlusBoundaryG[4],
-			pAd->TxAgcStepG, pAd->bAutoTxAgcG));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("E2PROM: G Tssi[-4 .. +4] = %d %d %d %d - %d -%d %d %d %d, step=%d, tuning=%d\n",
+			  pAd->TssiMinusBoundaryG[4],
+			  pAd->TssiMinusBoundaryG[3],
+			  pAd->TssiMinusBoundaryG[2],
+			  pAd->TssiMinusBoundaryG[1], pAd->TssiRefG,
+			  pAd->TssiPlusBoundaryG[1], pAd->TssiPlusBoundaryG[2],
+			  pAd->TssiPlusBoundaryG[3], pAd->TssiPlusBoundaryG[4],
+			  pAd->TxAgcStepG, pAd->bAutoTxAgcG));
 	}
 	// 1. 11a
 	{
@@ -976,7 +974,7 @@ VOID	NICReadEEPROMParameters(
 		pAd->TssiMinusBoundaryA[2] = Power.field.Byte0;
 		pAd->TssiMinusBoundaryA[1] = Power.field.Byte1;
 		RT28xx_EEPROM_READ16(pAd, 0xD8, Power.word);
-		pAd->TssiRefA   = Power.field.Byte0;
+		pAd->TssiRefA = Power.field.Byte0;
 		pAd->TssiPlusBoundaryA[1] = Power.field.Byte1;
 		RT28xx_EEPROM_READ16(pAd, 0xDA, Power.word);
 		pAd->TssiPlusBoundaryA[2] = Power.field.Byte0;
@@ -986,17 +984,21 @@ VOID	NICReadEEPROMParameters(
 		pAd->TxAgcStepA = Power.field.Byte1;
 		pAd->TxAgcCompensateA = 0;
 		pAd->TssiMinusBoundaryA[0] = pAd->TssiRefA;
-		pAd->TssiPlusBoundaryA[0]  = pAd->TssiRefA;
+		pAd->TssiPlusBoundaryA[0] = pAd->TssiRefA;
 
 		// Disable TxAgc if the based value is not right
 		if (pAd->TssiRefA == 0xff)
 			pAd->bAutoTxAgcA = FALSE;
 
-		DBGPRINT(RT_DEBUG_TRACE,("E2PROM: A Tssi[-4 .. +4] = %d %d %d %d - %d -%d %d %d %d, step=%d, tuning=%d\n",
-			pAd->TssiMinusBoundaryA[4], pAd->TssiMinusBoundaryA[3], pAd->TssiMinusBoundaryA[2], pAd->TssiMinusBoundaryA[1],
-			pAd->TssiRefA,
-			pAd->TssiPlusBoundaryA[1], pAd->TssiPlusBoundaryA[2], pAd->TssiPlusBoundaryA[3], pAd->TssiPlusBoundaryA[4],
-			pAd->TxAgcStepA, pAd->bAutoTxAgcA));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("E2PROM: A Tssi[-4 .. +4] = %d %d %d %d - %d -%d %d %d %d, step=%d, tuning=%d\n",
+			  pAd->TssiMinusBoundaryA[4],
+			  pAd->TssiMinusBoundaryA[3],
+			  pAd->TssiMinusBoundaryA[2],
+			  pAd->TssiMinusBoundaryA[1], pAd->TssiRefA,
+			  pAd->TssiPlusBoundaryA[1], pAd->TssiPlusBoundaryA[2],
+			  pAd->TssiPlusBoundaryA[3], pAd->TssiPlusBoundaryA[4],
+			  pAd->TxAgcStepA, pAd->bAutoTxAgcA));
 	}
 	pAd->BbpRssiToDbmDelta = 0x0;
 
@@ -1006,14 +1008,15 @@ VOID	NICReadEEPROMParameters(
 		pAd->RfFreqOffset = (ULONG) (value & 0x00FF);
 	else
 		pAd->RfFreqOffset = 0;
-	DBGPRINT(RT_DEBUG_TRACE, ("E2PROM: RF FreqOffset=0x%lx \n", pAd->RfFreqOffset));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("E2PROM: RF FreqOffset=0x%lx \n", pAd->RfFreqOffset));
 
 	//CountryRegion byte offset (38h)
-	value = pAd->EEPROMDefaultValue[2] >> 8;		// 2.4G band
+	value = pAd->EEPROMDefaultValue[2] >> 8;	// 2.4G band
 	value2 = pAd->EEPROMDefaultValue[2] & 0x00FF;	// 5G band
 
-	if ((value <= REGION_MAXIMUM_BG_BAND) && (value2 <= REGION_MAXIMUM_A_BAND))
-	{
+	if ((value <= REGION_MAXIMUM_BG_BAND)
+	    && (value2 <= REGION_MAXIMUM_A_BAND)) {
 		pAd->CommonCfg.CountryRegion = ((UCHAR) value) | 0x80;
 		pAd->CommonCfg.CountryRegionForABand = ((UCHAR) value2) | 0x80;
 		TmpPhy = pAd->CommonCfg.PhyMode;
@@ -1021,7 +1024,6 @@ VOID	NICReadEEPROMParameters(
 		RTMPSetPhyMode(pAd, TmpPhy);
 		SetCommonHT(pAd);
 	}
-
 	//
 	// Get RSSI Offset on EEPROM 0x9Ah & 0x9Ch.
 	// The valid value are (-10 ~ 10)
@@ -1029,7 +1031,7 @@ VOID	NICReadEEPROMParameters(
 	RT28xx_EEPROM_READ16(pAd, EEPROM_RSSI_BG_OFFSET, value);
 	pAd->BGRssiOffset0 = value & 0x00ff;
 	pAd->BGRssiOffset1 = (value >> 8);
-	RT28xx_EEPROM_READ16(pAd, EEPROM_RSSI_BG_OFFSET+2, value);
+	RT28xx_EEPROM_READ16(pAd, EEPROM_RSSI_BG_OFFSET + 2, value);
 	pAd->BGRssiOffset2 = value & 0x00ff;
 	pAd->ALNAGain1 = (value >> 8);
 	RT28xx_EEPROM_READ16(pAd, EEPROM_LNA_OFFSET, value);
@@ -1051,13 +1053,13 @@ VOID	NICReadEEPROMParameters(
 	RT28xx_EEPROM_READ16(pAd, EEPROM_RSSI_A_OFFSET, value);
 	pAd->ARssiOffset0 = value & 0x00ff;
 	pAd->ARssiOffset1 = (value >> 8);
-	RT28xx_EEPROM_READ16(pAd, (EEPROM_RSSI_A_OFFSET+2), value);
+	RT28xx_EEPROM_READ16(pAd, (EEPROM_RSSI_A_OFFSET + 2), value);
 	pAd->ARssiOffset2 = value & 0x00ff;
 	pAd->ALNAGain2 = (value >> 8);
 
-	if (((UCHAR)pAd->ALNAGain1 == 0xFF) || (pAd->ALNAGain1 == 0x00))
+	if (((UCHAR) pAd->ALNAGain1 == 0xFF) || (pAd->ALNAGain1 == 0x00))
 		pAd->ALNAGain1 = pAd->ALNAGain0;
-	if (((UCHAR)pAd->ALNAGain2 == 0xFF) || (pAd->ALNAGain2 == 0x00))
+	if (((UCHAR) pAd->ALNAGain2 == 0xFF) || (pAd->ALNAGain2 == 0x00))
 		pAd->ALNAGain2 = pAd->ALNAGain0;
 
 	// Validate 11a RSSI_0 offset.
@@ -1079,15 +1081,13 @@ VOID	NICReadEEPROMParameters(
 	// Note: RT30xX default value is 0x00 and will program to RF_R17 only when this value is not zero.
 	//       RT359X default value is 0x02
 	//
-	if (IS_RT30xx(pAd) || IS_RT3572(pAd))
-	{
+	if (IS_RT30xx(pAd) || IS_RT3572(pAd)) {
 		RT28xx_EEPROM_READ16(pAd, EEPROM_TXMIXER_GAIN_2_4G, value);
 		pAd->TxMixerGain24G = 0;
 		value &= 0x00ff;
-		if (value != 0xff)
-		{
+		if (value != 0xff) {
 			value &= 0x07;
-			pAd->TxMixerGain24G = (UCHAR)value;
+			pAd->TxMixerGain24G = (UCHAR) value;
 		}
 	}
 #endif // RT30xx //
@@ -1096,7 +1096,7 @@ VOID	NICReadEEPROMParameters(
 	// Get LED Setting.
 	//
 	RT28xx_EEPROM_READ16(pAd, 0x3a, value);
-	pAd->LedCntl.word = (value>>8);
+	pAd->LedCntl.word = (value >> 8);
 	RT28xx_EEPROM_READ16(pAd, EEPROM_LED1_OFFSET, value);
 	pAd->Led1 = value;
 	RT28xx_EEPROM_READ16(pAd, EEPROM_LED2_OFFSET, value);
@@ -1133,40 +1133,35 @@ VOID	NICReadEEPROMParameters(
 
 	========================================================================
 */
-VOID	NICInitAsicFromEEPROM(
-	IN	PRTMP_ADAPTER	pAd)
+VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 {
-	UINT32					data = 0;
-	UCHAR	BBPR1 = 0;
-	USHORT					i;
-//	EEPROM_ANTENNA_STRUC	Antenna;
-	EEPROM_NIC_CONFIG2_STRUC    NicConfig2;
-	UCHAR	BBPR3 = 0;
+	UINT32 data = 0;
+	UCHAR BBPR1 = 0;
+	USHORT i;
+//      EEPROM_ANTENNA_STRUC    Antenna;
+	EEPROM_NIC_CONFIG2_STRUC NicConfig2;
+	UCHAR BBPR3 = 0;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitAsicFromEEPROM\n"));
-	for(i = 3; i < NUM_EEPROM_BBP_PARMS; i++)
-	{
+	for (i = 3; i < NUM_EEPROM_BBP_PARMS; i++) {
 		UCHAR BbpRegIdx, BbpValue;
 
-		if ((pAd->EEPROMDefaultValue[i] != 0xFFFF) && (pAd->EEPROMDefaultValue[i] != 0))
-		{
-			BbpRegIdx = (UCHAR)(pAd->EEPROMDefaultValue[i] >> 8);
-			BbpValue  = (UCHAR)(pAd->EEPROMDefaultValue[i] & 0xff);
+		if ((pAd->EEPROMDefaultValue[i] != 0xFFFF)
+		    && (pAd->EEPROMDefaultValue[i] != 0)) {
+			BbpRegIdx = (UCHAR) (pAd->EEPROMDefaultValue[i] >> 8);
+			BbpValue = (UCHAR) (pAd->EEPROMDefaultValue[i] & 0xff);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BbpRegIdx, BbpValue);
 		}
 	}
 
-
 	NicConfig2.word = pAd->EEPROMDefaultValue[1];
 
 	{
-		if ((NicConfig2.word & 0x00ff) == 0xff)
-		{
+		if ((NicConfig2.word & 0x00ff) == 0xff) {
 			NicConfig2.word &= 0xff00;
 		}
 
-		if ((NicConfig2.word >> 8) == 0xff)
-		{
+		if ((NicConfig2.word >> 8) == 0xff) {
 			NicConfig2.word &= 0x00ff;
 		}
 	}
@@ -1183,8 +1178,7 @@ VOID	NICInitAsicFromEEPROM(
 	//
 	// Send LED Setting to MCU.
 	//
-	if (pAd->LedCntl.word == 0xFF)
-	{
+	if (pAd->LedCntl.word == 0xFF) {
 		pAd->LedCntl.word = 0x01;
 		pAd->Led1 = 0x5555;
 		pAd->Led2 = 0x2221;
@@ -1197,49 +1191,48 @@ VOID	NICInitAsicFromEEPROM(
 #endif // RTMP_MAC_USB //
 	}
 
-	AsicSendCommandToMcu(pAd, 0x52, 0xff, (UCHAR)pAd->Led1, (UCHAR)(pAd->Led1 >> 8));
-	AsicSendCommandToMcu(pAd, 0x53, 0xff, (UCHAR)pAd->Led2, (UCHAR)(pAd->Led2 >> 8));
-	AsicSendCommandToMcu(pAd, 0x54, 0xff, (UCHAR)pAd->Led3, (UCHAR)(pAd->Led3 >> 8));
+	AsicSendCommandToMcu(pAd, 0x52, 0xff, (UCHAR) pAd->Led1,
+			     (UCHAR) (pAd->Led1 >> 8));
+	AsicSendCommandToMcu(pAd, 0x53, 0xff, (UCHAR) pAd->Led2,
+			     (UCHAR) (pAd->Led2 >> 8));
+	AsicSendCommandToMcu(pAd, 0x54, 0xff, (UCHAR) pAd->Led3,
+			     (UCHAR) (pAd->Led3 >> 8));
 	AsicSendCommandToMcu(pAd, 0x51, 0xff, 0, pAd->LedCntl.field.Polarity);
 
 	pAd->LedIndicatorStrength = 0xFF;
-    RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, before link up
+	RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, before link up
 
 	{
 		// Read Hardware controlled Radio state enable bit
-		if (NicConfig2.field.HardwareRadioControl == 1)
-		{
+		if (NicConfig2.field.HardwareRadioControl == 1) {
 			pAd->StaCfg.bHardwareRadio = TRUE;
 
 			// Read GPIO pin2 as Hardware controlled radio state
 			RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &data);
-			if ((data & 0x04) == 0)
-			{
+			if ((data & 0x04) == 0) {
 				pAd->StaCfg.bHwRadio = FALSE;
 				pAd->StaCfg.bRadio = FALSE;
-//				RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818);
+//                              RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818);
 				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 			}
-		}
-		else
+		} else
 			pAd->StaCfg.bHardwareRadio = FALSE;
 
-		if (pAd->StaCfg.bRadio == FALSE)
-		{
+		if (pAd->StaCfg.bRadio == FALSE) {
 			RTMPSetLED(pAd, LED_RADIO_OFF);
-		}
-		else
-		{
+		} else {
 			RTMPSetLED(pAd, LED_RADIO_ON);
 #ifdef RTMP_MAC_PCI
 #ifdef RT3090
-			AsicSendCommandToMcu(pAd, 0x30, PowerRadioOffCID, 0xff, 0x02);
+			AsicSendCommandToMcu(pAd, 0x30, PowerRadioOffCID, 0xff,
+					     0x02);
 			AsicCheckCommanOk(pAd, PowerRadioOffCID);
 #endif // RT3090 //
 #ifndef RT3090
 			AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);
 #endif // RT3090 //
-			AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00, 0x00);
+			AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00,
+					     0x00);
 			// 2-1. wait command ok.
 			AsicCheckCommanOk(pAd, PowerWakeCID);
 #endif // RTMP_MAC_PCI //
@@ -1248,32 +1241,29 @@ VOID	NICInitAsicFromEEPROM(
 
 #ifdef RTMP_MAC_PCI
 #ifdef RT30xx
-		if (IS_RT3090(pAd)|| IS_RT3572(pAd) || IS_RT3390(pAd))
-		{
-			RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
-			if (pChipOps->AsicReverseRfFromSleepMode)
-				pChipOps->AsicReverseRfFromSleepMode(pAd);
-		}
-		// 3090 MCU Wakeup command needs more time to be stable.
-		// Before stable, don't issue other MCU command to prevent from firmware error.
-
-		if ((IS_RT3090(pAd)|| IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)
-			&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-			&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-		{
-			DBGPRINT(RT_DEBUG_TRACE,
-				("%s, release Mcu Lock\n", __func__));
-			RTMP_SEM_LOCK(&pAd->McuCmdLock);
-			pAd->brt30xxBanMcuCmd = FALSE;
-			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-		}
+	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
+		RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+		if (pChipOps->AsicReverseRfFromSleepMode)
+			pChipOps->AsicReverseRfFromSleepMode(pAd);
+	}
+	// 3090 MCU Wakeup command needs more time to be stable.
+	// Before stable, don't issue other MCU command to prevent from firmware error.
+
+	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+	    && IS_VERSION_AFTER_F(pAd)
+	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("%s, release Mcu Lock\n", __func__));
+		RTMP_SEM_LOCK(&pAd->McuCmdLock);
+		pAd->brt30xxBanMcuCmd = FALSE;
+		RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
+	}
 #endif // RT30xx //
 #endif // RTMP_MAC_PCI //
 
 	// Turn off patching for cardbus controller
-	if (NicConfig2.field.CardbusAcceleration == 1)
-	{
-//		pAd->bTest1 = TRUE;
+	if (NicConfig2.field.CardbusAcceleration == 1) {
+//              pAd->bTest1 = TRUE;
 	}
 
 	if (NicConfig2.field.DynamicTxAgcControl == 1)
@@ -1288,16 +1278,11 @@ VOID	NICInitAsicFromEEPROM(
 
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBPR3);
 	BBPR3 &= (~0x18);
-	if(pAd->Antenna.field.RxPath == 3)
-	{
+	if (pAd->Antenna.field.RxPath == 3) {
 		BBPR3 |= (0x10);
-	}
-	else if(pAd->Antenna.field.RxPath == 2)
-	{
+	} else if (pAd->Antenna.field.RxPath == 2) {
 		BBPR3 |= (0x8);
-	}
-	else if(pAd->Antenna.field.RxPath == 1)
-	{
+	} else if (pAd->Antenna.field.RxPath == 1) {
 		BBPR3 |= (0x0);
 	}
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
@@ -1305,59 +1290,61 @@ VOID	NICInitAsicFromEEPROM(
 	{
 		// Handle the difference when 1T
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &BBPR1);
-		if(pAd->Antenna.field.TxPath == 1)
-		{
-		BBPR1 &= (~0x18);
+		if (pAd->Antenna.field.TxPath == 1) {
+			BBPR1 &= (~0x18);
 		}
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, BBPR1);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("Use Hw Radio Control Pin=%d; if used Pin=%d;\n",
-					pAd->CommonCfg.bHardwareRadio, pAd->CommonCfg.bHardwareRadio));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Use Hw Radio Control Pin=%d; if used Pin=%d;\n",
+			  pAd->CommonCfg.bHardwareRadio,
+			  pAd->CommonCfg.bHardwareRadio));
 	}
 
 #ifdef RTMP_MAC_USB
 #ifdef RT30xx
 	// update registers from EEPROM for RT3071 or later(3572/3592).
 
-	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	{
+	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
 		UCHAR RegIdx, RegValue;
 		USHORT value;
 
 		// after RT3071, write BBP from EEPROM 0xF0 to 0x102
-		for (i = 0xF0; i <= 0x102; i = i+2)
-		{
+		for (i = 0xF0; i <= 0x102; i = i + 2) {
 			value = 0xFFFF;
 			RT28xx_EEPROM_READ16(pAd, i, value);
-			if ((value != 0xFFFF) && (value != 0))
-			{
-				RegIdx = (UCHAR)(value >> 8);
-				RegValue  = (UCHAR)(value & 0xff);
-				RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, RegIdx, RegValue);
-				DBGPRINT(RT_DEBUG_TRACE, ("Update BBP Registers from EEPROM(0x%0x), BBP(0x%x) = 0x%x\n", i, RegIdx, RegValue));
+			if ((value != 0xFFFF) && (value != 0)) {
+				RegIdx = (UCHAR) (value >> 8);
+				RegValue = (UCHAR) (value & 0xff);
+				RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, RegIdx,
+							     RegValue);
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("Update BBP Registers from EEPROM(0x%0x), BBP(0x%x) = 0x%x\n",
+					  i, RegIdx, RegValue));
 			}
 		}
 
 		// after RT3071, write RF from EEPROM 0x104 to 0x116
-		for (i = 0x104; i <= 0x116; i = i+2)
-		{
+		for (i = 0x104; i <= 0x116; i = i + 2) {
 			value = 0xFFFF;
 			RT28xx_EEPROM_READ16(pAd, i, value);
-			if ((value != 0xFFFF) && (value != 0))
-			{
-				RegIdx = (UCHAR)(value >> 8);
-				RegValue  = (UCHAR)(value & 0xff);
+			if ((value != 0xFFFF) && (value != 0)) {
+				RegIdx = (UCHAR) (value >> 8);
+				RegValue = (UCHAR) (value & 0xff);
 				RT30xxWriteRFRegister(pAd, RegIdx, RegValue);
-				DBGPRINT(RT_DEBUG_TRACE, ("Update RF Registers from EEPROM0x%x), BBP(0x%x) = 0x%x\n", i, RegIdx, RegValue));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("Update RF Registers from EEPROM0x%x), BBP(0x%x) = 0x%x\n",
+					  i, RegIdx, RegValue));
 			}
 		}
 	}
 #endif // RT30xx //
 #endif // RTMP_MAC_USB //
 
-	DBGPRINT(RT_DEBUG_TRACE, ("TxPath = %d, RxPath = %d, RFIC=%d, Polar+LED mode=%x\n",
-				pAd->Antenna.field.TxPath, pAd->Antenna.field.RxPath,
-				pAd->RfIcType, pAd->LedCntl.word));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("TxPath = %d, RxPath = %d, RFIC=%d, Polar+LED mode=%x\n",
+		  pAd->Antenna.field.TxPath, pAd->Antenna.field.RxPath,
+		  pAd->RfIcType, pAd->LedCntl.word));
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitAsicFromEEPROM\n"));
 }
 
@@ -1379,37 +1366,36 @@ VOID	NICInitAsicFromEEPROM(
 
 	========================================================================
 */
-NDIS_STATUS	NICInitializeAdapter(
-	IN	PRTMP_ADAPTER	pAd,
-	IN   BOOLEAN    bHardReset)
+NDIS_STATUS NICInitializeAdapter(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 {
-	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
-	WPDMA_GLO_CFG_STRUC	GloCfg;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+	WPDMA_GLO_CFG_STRUC GloCfg;
 #ifdef RTMP_MAC_PCI
-	UINT32			Value;
-	DELAY_INT_CFG_STRUC	IntCfg;
+	UINT32 Value;
+	DELAY_INT_CFG_STRUC IntCfg;
 #endif // RTMP_MAC_PCI //
-//	INT_MASK_CSR_STRUC		IntMask;
-	ULONG	i =0, j=0;
-	AC_TXOP_CSR0_STRUC	csr0;
+//      INT_MASK_CSR_STRUC              IntMask;
+	ULONG i = 0, j = 0;
+	AC_TXOP_CSR0_STRUC csr0;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitializeAdapter\n"));
 
 	// 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits:
 retry:
 	i = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)  && (GloCfg.field.RxDMABusy == 0))
+		if ((GloCfg.field.TxDMABusy == 0)
+		    && (GloCfg.field.RxDMABusy == 0))
 			break;
 
 		RTMPusecDelay(1000);
 		i++;
-	}while ( i<100);
-	DBGPRINT(RT_DEBUG_TRACE, ("<== DMA offset 0x208 = 0x%x\n", GloCfg.word));
+	} while (i < 100);
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("<== DMA offset 0x208 = 0x%x\n", GloCfg.word));
 	GloCfg.word &= 0xff0;
-	GloCfg.field.EnTXWriteBackDDONE =1;
+	GloCfg.field.EnTXWriteBackDDONE = 1;
 	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
 
 	// Record HW Beacon offset
@@ -1435,35 +1421,36 @@ retry:
 #endif // RTMP_MAC_PCI //
 
 	// Initialze ASIC for TX & Rx operation
-	if (NICInitializeAsic(pAd , bHardReset) != NDIS_STATUS_SUCCESS)
-	{
-		if (j++ == 0)
-		{
+	if (NICInitializeAsic(pAd, bHardReset) != NDIS_STATUS_SUCCESS) {
+		if (j++ == 0) {
 			NICLoadFirmware(pAd);
 			goto retry;
 		}
 		return NDIS_STATUS_FAILURE;
 	}
 
-
 #ifdef RTMP_MAC_PCI
 	// Write AC_BK base address register
-	Value = RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BK].Cell[0].AllocPa);
+	Value =
+	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BK].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR1, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR1 : 0x%x\n", Value));
 
 	// Write AC_BE base address register
-	Value = RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BE].Cell[0].AllocPa);
+	Value =
+	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BE].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR0, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR0 : 0x%x\n", Value));
 
 	// Write AC_VI base address register
-	Value = RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_VI].Cell[0].AllocPa);
+	Value =
+	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_VI].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR2, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR2 : 0x%x\n", Value));
 
 	// Write AC_VO base address register
-	Value = RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_VO].Cell[0].AllocPa);
+	Value =
+	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_VO].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR3, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR3 : 0x%x\n", Value));
 
@@ -1479,23 +1466,23 @@ retry:
 
 	// Init RX Ring index pointer
 	pAd->RxRing.RxSwReadIdx = 0;
-	pAd->RxRing.RxCpuIdx = RX_RING_SIZE-1;
+	pAd->RxRing.RxCpuIdx = RX_RING_SIZE - 1;
 	RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
 
 	// Init TX rings index pointer
 	{
-		for (i=0; i<NUM_OF_TX_RING; i++)
-		{
+		for (i = 0; i < NUM_OF_TX_RING; i++) {
 			pAd->TxRing[i].TxSwFreeIdx = 0;
 			pAd->TxRing[i].TxCpuIdx = 0;
-			RTMP_IO_WRITE32(pAd, (TX_CTX_IDX0 + i * 0x10) ,  pAd->TxRing[i].TxCpuIdx);
+			RTMP_IO_WRITE32(pAd, (TX_CTX_IDX0 + i * 0x10),
+					pAd->TxRing[i].TxCpuIdx);
 		}
 	}
 
 	// init MGMT ring index pointer
 	pAd->MgmtRing.TxSwFreeIdx = 0;
 	pAd->MgmtRing.TxCpuIdx = 0;
-	RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX,  pAd->MgmtRing.TxCpuIdx);
+	RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
 
 	//
 	// set each Ring's SIZE  into ASIC. Descriptor Size is fixed by design.
@@ -1516,45 +1503,39 @@ retry:
 	RTMP_IO_WRITE32(pAd, RX_MAX_CNT, Value);
 #endif // RTMP_MAC_PCI //
 
-
 	// WMM parameter
 	csr0.word = 0;
 	RTMP_IO_WRITE32(pAd, WMM_TXOP0_CFG, csr0.word);
-	if (pAd->CommonCfg.PhyMode == PHY_11B)
-	{
+	if (pAd->CommonCfg.PhyMode == PHY_11B) {
 		csr0.field.Ac0Txop = 192;	// AC_VI: 192*32us ~= 6ms
 		csr0.field.Ac1Txop = 96;	// AC_VO: 96*32us  ~= 3ms
-	}
-	else
-	{
+	} else {
 		csr0.field.Ac0Txop = 96;	// AC_VI: 96*32us ~= 3ms
 		csr0.field.Ac1Txop = 48;	// AC_VO: 48*32us ~= 1.5ms
 	}
 	RTMP_IO_WRITE32(pAd, WMM_TXOP1_CFG, csr0.word);
 
-
 #ifdef RTMP_MAC_PCI
 	// 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits:
 	i = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)  && (GloCfg.field.RxDMABusy == 0))
+		if ((GloCfg.field.TxDMABusy == 0)
+		    && (GloCfg.field.RxDMABusy == 0))
 			break;
 
 		RTMPusecDelay(1000);
 		i++;
-	}while ( i < 100);
+	} while (i < 100);
 
 	GloCfg.word &= 0xff0;
-	GloCfg.field.EnTXWriteBackDDONE =1;
+	GloCfg.field.EnTXWriteBackDDONE = 1;
 	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
 
 	IntCfg.word = 0;
 	RTMP_IO_WRITE32(pAd, DELAY_INT_CFG, IntCfg.word);
 #endif // RTMP_MAC_PCI //
 
-
 	// reset action
 	// Load firmware
 	//  Status = NICLoadFirmware(pAd);
@@ -1581,47 +1562,43 @@ retry:
 
 	========================================================================
 */
-NDIS_STATUS	NICInitializeAsic(
-	IN	PRTMP_ADAPTER	pAd,
-	IN  BOOLEAN		bHardReset)
-{
-	ULONG			Index = 0;
-	UCHAR			R0 = 0xff;
-	UINT32			MacCsr12 = 0, Counter = 0;
+NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
+{
+	ULONG Index = 0;
+	UCHAR R0 = 0xff;
+	UINT32 MacCsr12 = 0, Counter = 0;
 #ifdef RTMP_MAC_USB
-	UINT32			MacCsr0 = 0;
-	NTSTATUS		Status;
-	UCHAR			Value = 0xff;
+	UINT32 MacCsr0 = 0;
+	NTSTATUS Status;
+	UCHAR Value = 0xff;
 #endif // RTMP_MAC_USB //
 #ifdef RT30xx
-	UCHAR			bbpreg=0;
-	UCHAR			RFValue=0;
+	UCHAR bbpreg = 0;
+	UCHAR RFValue = 0;
 #endif // RT30xx //
-	USHORT			KeyIdx;
-	INT				i,apidx;
+	USHORT KeyIdx;
+	INT i, apidx;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitializeAsic\n"));
 
 #ifdef RTMP_MAC_PCI
 	RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x3);	// To fix driver disable/enable hang issue when radio off
-	if (bHardReset == TRUE)
-	{
+	if (bHardReset == TRUE) {
 		RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x3);
-	}
-	else
+	} else
 		RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x1);
 
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x0);
 	// Initialize MAC register to default value
-	for (Index = 0; Index < NUM_MAC_REG_PARMS; Index++)
-	{
-		RTMP_IO_WRITE32(pAd, MACRegTable[Index].Register, MACRegTable[Index].Value);
+	for (Index = 0; Index < NUM_MAC_REG_PARMS; Index++) {
+		RTMP_IO_WRITE32(pAd, MACRegTable[Index].Register,
+				MACRegTable[Index].Value);
 	}
 
 	{
-		for (Index = 0; Index < NUM_STA_MAC_REG_PARMS; Index++)
-		{
-			RTMP_IO_WRITE32(pAd, STAMACRegTable[Index].Register, STAMACRegTable[Index].Value);
+		for (Index = 0; Index < NUM_STA_MAC_REG_PARMS; Index++) {
+			RTMP_IO_WRITE32(pAd, STAMACRegTable[Index].Register,
+					STAMACRegTable[Index].Value);
 		}
 	}
 #endif // RTMP_MAC_PCI //
@@ -1633,8 +1610,7 @@ NDIS_STATUS	NICInitializeAsic(
 
 	//To avoid hang-on issue when interface up in kernel 2.4,
 	//we use a local variable "MacCsr0" instead of using "pAd->MACVersion" directly.
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
 
 		if ((MacCsr0 != 0x00) && (MacCsr0 != 0xFFFFFFFF))
@@ -1644,7 +1620,8 @@ NDIS_STATUS	NICInitializeAsic(
 	} while (Index++ < 100);
 
 	pAd->MACVersion = MacCsr0;
-	DBGPRINT(RT_DEBUG_TRACE, ("MAC_CSR0  [ Ver:Rev=0x%08x]\n", pAd->MACVersion));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("MAC_CSR0  [ Ver:Rev=0x%08x]\n", pAd->MACVersion));
 	// turn on bit13 (set to zero) after rt2860D. This is to solve high-current issue.
 	RTMP_IO_READ32(pAd, PBF_SYS_CTRL, &MacCsr12);
 	MacCsr12 &= (~0x2000);
@@ -1657,57 +1634,47 @@ NDIS_STATUS	NICInitializeAsic(
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x0);
 
 	// Initialize MAC register to default value
-	for(Index=0; Index<NUM_MAC_REG_PARMS; Index++)
-	{
+	for (Index = 0; Index < NUM_MAC_REG_PARMS; Index++) {
 #ifdef RT30xx
-		if ((MACRegTable[Index].Register == TX_SW_CFG0) && (IS_RT3070(pAd) || IS_RT3071(pAd) || IS_RT3572(pAd) || IS_RT3090(pAd) ||  IS_RT3390(pAd)))
-		{
+		if ((MACRegTable[Index].Register == TX_SW_CFG0)
+		    && (IS_RT3070(pAd) || IS_RT3071(pAd) || IS_RT3572(pAd)
+			|| IS_RT3090(pAd) || IS_RT3390(pAd))) {
 			MACRegTable[Index].Value = 0x00000400;
 		}
 #endif // RT30xx //
-		RTMP_IO_WRITE32(pAd, (USHORT)MACRegTable[Index].Register, MACRegTable[Index].Value);
+		RTMP_IO_WRITE32(pAd, (USHORT) MACRegTable[Index].Register,
+				MACRegTable[Index].Value);
 	}
 
 	{
-		for (Index = 0; Index < NUM_STA_MAC_REG_PARMS; Index++)
-		{
-			RTMP_IO_WRITE32(pAd, (USHORT)STAMACRegTable[Index].Register, STAMACRegTable[Index].Value);
+		for (Index = 0; Index < NUM_STA_MAC_REG_PARMS; Index++) {
+			RTMP_IO_WRITE32(pAd,
+					(USHORT) STAMACRegTable[Index].Register,
+					STAMACRegTable[Index].Value);
 		}
 	}
 #endif // RTMP_MAC_USB //
 
 #ifdef RT30xx
 	// Initialize RT3070 serial MAC registers which is different from RT2870 serial
-	if (IS_RT3090(pAd) || IS_RT3572(pAd)||IS_RT3390(pAd))
-	{
+	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
 		RTMP_IO_WRITE32(pAd, TX_SW_CFG1, 0);
 
 		// RT3071 version E has fixed this issue
-		if ((pAd->MACVersion & 0xffff) < 0x0211)
-		{
-			if (pAd->NicConfig2.field.DACTestBit == 1)
-			{
+		if ((pAd->MACVersion & 0xffff) < 0x0211) {
+			if (pAd->NicConfig2.field.DACTestBit == 1) {
 				RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x2C);	// To fix throughput drop drastically
-			}
-			else
-			{
+			} else {
 				RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x0F);	// To fix throughput drop drastically
 			}
-		}
-		else
-		{
+		} else {
 			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x0);
 		}
-	}
-	else if (IS_RT3070(pAd))
-	{
-		if (((pAd->MACVersion & 0xffff) < 0x0201))
-		{
-		RTMP_IO_WRITE32(pAd, TX_SW_CFG1, 0);
+	} else if (IS_RT3070(pAd)) {
+		if (((pAd->MACVersion & 0xffff) < 0x0201)) {
+			RTMP_IO_WRITE32(pAd, TX_SW_CFG1, 0);
 			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x2C);	// To fix throughput drop drastically
-		}
-		else
-		{
+		} else {
 			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0);
 		}
 	}
@@ -1717,18 +1684,18 @@ NDIS_STATUS	NICInitializeAsic(
 	// Before program BBP, we need to wait BBP/RF get wake up.
 	//
 	Index = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, MAC_STATUS_CFG, &MacCsr12);
 
 		if ((MacCsr12 & 0x03) == 0)	// if BB.RF is stable
 			break;
 
-		DBGPRINT(RT_DEBUG_TRACE, ("Check MAC_STATUS_CFG  = Busy = %x\n", MacCsr12));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Check MAC_STATUS_CFG  = Busy = %x\n", MacCsr12));
 		RTMPusecDelay(1000);
 	} while (Index++ < 100);
 
-    // The commands to firmware should be after these commands, these commands will init firmware
+	// The commands to firmware should be after these commands, these commands will init firmware
 	// PCI and USB are not the same because PCI driver needs to wait for PCI bus ready
 	RTMP_IO_WRITE32(pAd, H2M_BBP_AGENT, 0);	// initialize BBP R/W access agent
 	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CSR, 0);
@@ -1741,8 +1708,7 @@ NDIS_STATUS	NICInitializeAsic(
 
 	// Read BBP register, make sure BBP is up and running before write new data
 	Index = 0;
-	do
-	{
+	do {
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R0, &R0);
 		DBGPRINT(RT_DEBUG_TRACE, ("BBP version = %x\n", R0));
 	} while ((++Index < 20) && ((R0 == 0xff) || (R0 == 0x00)));
@@ -1752,15 +1718,14 @@ NDIS_STATUS	NICInitializeAsic(
 		return NDIS_STATUS_FAILURE;
 
 	// Initialize BBP register to default value
-	for (Index = 0; Index < NUM_BBP_REG_PARMS; Index++)
-	{
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBPRegTable[Index].Register, BBPRegTable[Index].Value);
+	for (Index = 0; Index < NUM_BBP_REG_PARMS; Index++) {
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBPRegTable[Index].Register,
+					     BBPRegTable[Index].Value);
 	}
 
 #ifdef RTMP_MAC_PCI
 	// TODO: shiang, check MACVersion, currently, rbus-based chip use this.
-	if (pAd->MACVersion == 0x28720200)
-	{
+	if (pAd->MACVersion == 0x28720200) {
 		//UCHAR value;
 		ULONG value2;
 
@@ -1770,8 +1735,8 @@ NDIS_STATUS	NICInitializeAsic(
 
 		//Maximum PSDU length from 16K to 32K bytes
 		RTMP_IO_READ32(pAd, MAX_LEN_CFG, &value2);
-		value2 &= ~(0x3<<12);
-		value2 |= (0x2<<12);
+		value2 &= ~(0x3 << 12);
+		value2 |= (0x2 << 12);
 		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, value2);
 	}
 #endif // RTMP_MAC_PCI //
@@ -1779,53 +1744,45 @@ NDIS_STATUS	NICInitializeAsic(
 	// for rt2860E and after, init BBP_R84 with 0x19. This is for extension channel overlapping IOT.
 	// RT3090 should not program BBP R84 to 0x19, otherwise TX will block.
 	//3070/71/72,3090,3090A( are included in RT30xx),3572,3390
-	if (((pAd->MACVersion & 0xffff) != 0x0101) && !(IS_RT30xx(pAd)|| IS_RT3572(pAd) || IS_RT3390(pAd)))
+	if (((pAd->MACVersion & 0xffff) != 0x0101)
+	    && !(IS_RT30xx(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)))
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R84, 0x19);
 
 #ifdef RT30xx
 // add by johnli, RF power sequence setup
-	if (IS_RT30xx(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	{	//update for RT3070/71/72/90/91/92,3572,3390.
+	if (IS_RT30xx(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {	//update for RT3070/71/72/90/91/92,3572,3390.
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R79, 0x13);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R80, 0x05);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R81, 0x33);
 	}
 
-	if (IS_RT3090(pAd)||IS_RT3390(pAd))	// RT309x, RT3071/72
+	if (IS_RT3090(pAd) || IS_RT3390(pAd))	// RT309x, RT3071/72
 	{
 		// enable DC filter
-		if ((pAd->MACVersion & 0xffff) >= 0x0211)
-		{
+		if ((pAd->MACVersion & 0xffff) >= 0x0211) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R103, 0xc0);
 		}
-
 		// improve power consumption
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R138, &bbpreg);
-		if (pAd->Antenna.field.TxPath == 1)
-		{
+		if (pAd->Antenna.field.TxPath == 1) {
 			// turn off tx DAC_1
 			bbpreg = (bbpreg | 0x20);
 		}
 
-		if (pAd->Antenna.field.RxPath == 1)
-		{
+		if (pAd->Antenna.field.RxPath == 1) {
 			// turn off tx ADC_1
 			bbpreg &= (~0x2);
 		}
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R138, bbpreg);
 
 		// improve power consumption in RT3071 Ver.E
-		if ((pAd->MACVersion & 0xffff) >= 0x0211)
-		{
+		if ((pAd->MACVersion & 0xffff) >= 0x0211) {
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R31, &bbpreg);
 			bbpreg &= (~0x3);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R31, bbpreg);
 		}
-	}
-	else if (IS_RT3070(pAd))
-	{
-		if ((pAd->MACVersion & 0xffff) >= 0x0201)
-		{
+	} else if (IS_RT3070(pAd)) {
+		if ((pAd->MACVersion & 0xffff) >= 0x0201) {
 			// enable DC filter
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R103, 0xc0);
 
@@ -1834,19 +1791,16 @@ NDIS_STATUS	NICInitializeAsic(
 			bbpreg &= (~0x3);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R31, bbpreg);
 		}
-
 		// TX_LO1_en, RF R17 register Bit 3 to 0
 		RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
 		RFValue &= (~0x08);
 		// to fix rx long range issue
-		if (pAd->NicConfig2.field.ExternalLNAForG == 0)
-		{
+		if (pAd->NicConfig2.field.ExternalLNAForG == 0) {
 			RFValue |= 0x20;
 		}
 		// set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h
-		if (pAd->TxMixerGain24G >= 1)
-		{
-			RFValue &= (~0x7);  // clean bit [2:0]
+		if (pAd->TxMixerGain24G >= 1) {
+			RFValue &= (~0x7);	// clean bit [2:0]
 			RFValue |= pAd->TxMixerGain24G;
 		}
 		RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
@@ -1854,13 +1808,12 @@ NDIS_STATUS	NICInitializeAsic(
 // end johnli
 #endif // RT30xx //
 
-	if (pAd->MACVersion == 0x28600100)
-	{
+	if (pAd->MACVersion == 0x28600100) {
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x16);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x12);
-    }
+	}
 
-	if (pAd->MACVersion >= RALINK_2880E_VERSION && pAd->MACVersion < RALINK_3070_VERSION) // 3*3
+	if (pAd->MACVersion >= RALINK_2880E_VERSION && pAd->MACVersion < RALINK_3070_VERSION)	// 3*3
 	{
 		// enlarge MAX_LEN_CFG
 		UINT32 csr;
@@ -1869,25 +1822,25 @@ NDIS_STATUS	NICInitializeAsic(
 		csr |= 0x2000;
 		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, csr);
 	}
-
 #ifdef RTMP_MAC_USB
-{
-	UCHAR	MAC_Value[]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0,0};
-
-	//Initialize WCID table
-	Value = 0xff;
-	for(Index =0 ;Index < 254;Index++)
 	{
-		RTUSBMultiWrite(pAd, (USHORT)(MAC_WCID_BASE + Index * 8), MAC_Value, 8);
+		UCHAR MAC_Value[] =
+		    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0 };
+
+		//Initialize WCID table
+		Value = 0xff;
+		for (Index = 0; Index < 254; Index++) {
+			RTUSBMultiWrite(pAd,
+					(USHORT) (MAC_WCID_BASE + Index * 8),
+					MAC_Value, 8);
+		}
 	}
-}
 #endif // RTMP_MAC_USB //
 
 	// Add radio off control
 	{
-		if (pAd->StaCfg.bRadio == FALSE)
-		{
-//			RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818);
+		if (pAd->StaCfg.bRadio == FALSE) {
+//                      RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818);
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 			DBGPRINT(RT_DEBUG_TRACE, ("Set Radio Off\n"));
 		}
@@ -1904,35 +1857,33 @@ NDIS_STATUS	NICInitializeAsic(
 	// ASIC will keep garbage value after boot
 	// Clear all shared key table when initial
 	// This routine can be ignored in radio-ON/OFF operation.
-	if (bHardReset)
-	{
-		for (KeyIdx = 0; KeyIdx < 4; KeyIdx++)
-		{
-			RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4*KeyIdx, 0);
+	if (bHardReset) {
+		for (KeyIdx = 0; KeyIdx < 4; KeyIdx++) {
+			RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * KeyIdx,
+					0);
 		}
 
 		// Clear all pairwise key table when initial
-		for (KeyIdx = 0; KeyIdx < 256; KeyIdx++)
-		{
-			RTMP_IO_WRITE32(pAd, MAC_WCID_ATTRIBUTE_BASE + (KeyIdx * HW_WCID_ATTRI_SIZE), 1);
+		for (KeyIdx = 0; KeyIdx < 256; KeyIdx++) {
+			RTMP_IO_WRITE32(pAd,
+					MAC_WCID_ATTRIBUTE_BASE +
+					(KeyIdx * HW_WCID_ATTRI_SIZE), 1);
 		}
 	}
-
 	// assert HOST ready bit
 //  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x0); // 2004-09-14 asked by Mark
 //  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x4);
 
 	// It isn't necessary to clear this space when not hard reset.
-	if (bHardReset == TRUE)
-	{
+	if (bHardReset == TRUE) {
 		// clear all on-chip BEACON frame space
-		for (apidx = 0; apidx < HW_BEACON_MAX_COUNT; apidx++)
-		{
-			for (i = 0; i < HW_BEACON_OFFSET>>2; i+=4)
-				RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[apidx] + i, 0x00);
+		for (apidx = 0; apidx < HW_BEACON_MAX_COUNT; apidx++) {
+			for (i = 0; i < HW_BEACON_OFFSET >> 2; i += 4)
+				RTMP_IO_WRITE32(pAd,
+						pAd->BeaconOffset[apidx] + i,
+						0x00);
 		}
 	}
-
 #ifdef RTMP_MAC_USB
 	AsicDisableSync(pAd);
 	// Clear raw counters
@@ -1944,14 +1895,14 @@ NDIS_STATUS	NICInitializeAsic(
 	RTMP_IO_READ32(pAd, TX_STA_CNT2, &Counter);
 	// Default PCI clock cycle per ms is different as default setting, which is based on PCI.
 	RTMP_IO_READ32(pAd, USB_CYC_CFG, &Counter);
-	Counter&=0xffffff00;
-	Counter|=0x000001e;
+	Counter &= 0xffffff00;
+	Counter |= 0x000001e;
 	RTMP_IO_WRITE32(pAd, USB_CYC_CFG, Counter);
 #endif // RTMP_MAC_USB //
 
 	{
 		// for rt2860E and after, init TXOP_CTRL_CFG with 0x583f. This is for extension channel overlapping IOT.
-		if ((pAd->MACVersion&0xffff) != 0x0101)
+		if ((pAd->MACVersion & 0xffff) != 0x0101)
 			RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x583f);
 	}
 
@@ -1978,10 +1929,9 @@ NDIS_STATUS	NICInitializeAsic(
 
 	========================================================================
 */
-VOID	NICIssueReset(
-	IN	PRTMP_ADAPTER	pAd)
+VOID NICIssueReset(IN PRTMP_ADAPTER pAd)
 {
-	UINT32	Value = 0;
+	UINT32 Value = 0;
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICIssueReset\n"));
 
 	// Abort Tx, prevent ASIC from writing to Host memory
@@ -1993,7 +1943,7 @@ VOID	NICIssueReset(
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
 
 	// Issue reset and clear from reset state
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x03); // 2004-09-17 change from 0x01
+	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x03);	// 2004-09-17 change from 0x01
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x00);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICIssueReset\n"));
@@ -2015,132 +1965,115 @@ VOID	NICIssueReset(
 
 	========================================================================
 */
-BOOLEAN	NICCheckForHang(
-	IN	PRTMP_ADAPTER	pAd)
+BOOLEAN NICCheckForHang(IN PRTMP_ADAPTER pAd)
 {
 	return (FALSE);
 }
 
-VOID NICUpdateFifoStaCounters(
-	IN PRTMP_ADAPTER pAd)
+VOID NICUpdateFifoStaCounters(IN PRTMP_ADAPTER pAd)
 {
-	TX_STA_FIFO_STRUC	StaFifo;
-	MAC_TABLE_ENTRY		*pEntry;
-	UCHAR				i = 0;
-	UCHAR			pid = 0, wcid = 0;
-	CHAR				reTry;
-	UCHAR				succMCS;
-
-		do
-		{
-			RTMP_IO_READ32(pAd, TX_STA_FIFO, &StaFifo.word);
+	TX_STA_FIFO_STRUC StaFifo;
+	MAC_TABLE_ENTRY *pEntry;
+	UCHAR i = 0;
+	UCHAR pid = 0, wcid = 0;
+	CHAR reTry;
+	UCHAR succMCS;
 
-			if (StaFifo.field.bValid == 0)
-				break;
+	do {
+		RTMP_IO_READ32(pAd, TX_STA_FIFO, &StaFifo.word);
 
-			wcid = (UCHAR)StaFifo.field.wcid;
+		if (StaFifo.field.bValid == 0)
+			break;
 
+		wcid = (UCHAR) StaFifo.field.wcid;
 
 		/* ignore NoACK and MGMT frame use 0xFF as WCID */
-			if ((StaFifo.field.TxAckRequired == 0) || (wcid >= MAX_LEN_OF_MAC_TABLE))
-			{
-				i++;
-				continue;
-			}
+		if ((StaFifo.field.TxAckRequired == 0)
+		    || (wcid >= MAX_LEN_OF_MAC_TABLE)) {
+			i++;
+			continue;
+		}
 
-			/* PID store Tx MCS Rate */
-			pid = (UCHAR)StaFifo.field.PidType;
+		/* PID store Tx MCS Rate */
+		pid = (UCHAR) StaFifo.field.PidType;
 
-			pEntry = &pAd->MacTab.Content[wcid];
+		pEntry = &pAd->MacTab.Content[wcid];
 
-			pEntry->DebugFIFOCount++;
+		pEntry->DebugFIFOCount++;
 
-			if (StaFifo.field.TxBF) // 3*3
-				pEntry->TxBFCount++;
-
-			if (!StaFifo.field.TxSuccess)
-			{
-				pEntry->FIFOCount++;
-				pEntry->OneSecTxFailCount++;
-
-				if (pEntry->FIFOCount >= 1)
-				{
-					DBGPRINT(RT_DEBUG_TRACE, ("#"));
-					pEntry->NoBADataCountDown = 64;
-
-					if(pEntry->PsMode == PWR_ACTIVE)
-					{
-						int tid;
-						for (tid=0; tid<NUM_OF_TID; tid++)
-						{
-							BAOriSessionTearDown(pAd, pEntry->Aid,  tid, FALSE, FALSE);
-						}
+		if (StaFifo.field.TxBF)	// 3*3
+			pEntry->TxBFCount++;
 
-						// Update the continuous transmission counter except PS mode
-						pEntry->ContinueTxFailCnt++;
-					}
-					else
-					{
-						// Clear the FIFOCount when sta in Power Save mode. Basically we assume
-						//     this tx error happened due to sta just go to sleep.
-						pEntry->FIFOCount = 0;
-						pEntry->ContinueTxFailCnt = 0;
-					}
-					//pEntry->FIFOCount = 0;
-				}
-				//pEntry->bSendBAR = TRUE;
-			}
-			else
-			{
-				if ((pEntry->PsMode != PWR_SAVE) && (pEntry->NoBADataCountDown > 0))
-				{
-					pEntry->NoBADataCountDown--;
-					if (pEntry->NoBADataCountDown==0)
-					{
-						DBGPRINT(RT_DEBUG_TRACE, ("@\n"));
-					}
-				}
-
-				pEntry->FIFOCount = 0;
-				pEntry->OneSecTxNoRetryOkCount++;
-				// update NoDataIdleCount when sucessful send packet to STA.
-				pEntry->NoDataIdleCount = 0;
-				pEntry->ContinueTxFailCnt = 0;
-			}
+		if (!StaFifo.field.TxSuccess) {
+			pEntry->FIFOCount++;
+			pEntry->OneSecTxFailCount++;
 
-			succMCS = StaFifo.field.SuccessRate & 0x7F;
+			if (pEntry->FIFOCount >= 1) {
+				DBGPRINT(RT_DEBUG_TRACE, ("#"));
+				pEntry->NoBADataCountDown = 64;
 
-			reTry = pid - succMCS;
+				if (pEntry->PsMode == PWR_ACTIVE) {
+					int tid;
+					for (tid = 0; tid < NUM_OF_TID; tid++) {
+						BAOriSessionTearDown(pAd,
+								     pEntry->
+								     Aid, tid,
+								     FALSE,
+								     FALSE);
+					}
 
-			if (StaFifo.field.TxSuccess)
-			{
-				pEntry->TXMCSExpected[pid]++;
-				if (pid == succMCS)
-				{
-					pEntry->TXMCSSuccessful[pid]++;
+					// Update the continuous transmission counter except PS mode
+					pEntry->ContinueTxFailCnt++;
+				} else {
+					// Clear the FIFOCount when sta in Power Save mode. Basically we assume
+					//     this tx error happened due to sta just go to sleep.
+					pEntry->FIFOCount = 0;
+					pEntry->ContinueTxFailCnt = 0;
 				}
-				else
-				{
-					pEntry->TXMCSAutoFallBack[pid][succMCS]++;
+				//pEntry->FIFOCount = 0;
+			}
+			//pEntry->bSendBAR = TRUE;
+		} else {
+			if ((pEntry->PsMode != PWR_SAVE)
+			    && (pEntry->NoBADataCountDown > 0)) {
+				pEntry->NoBADataCountDown--;
+				if (pEntry->NoBADataCountDown == 0) {
+					DBGPRINT(RT_DEBUG_TRACE, ("@\n"));
 				}
 			}
-			else
-			{
-				pEntry->TXMCSFailed[pid]++;
+
+			pEntry->FIFOCount = 0;
+			pEntry->OneSecTxNoRetryOkCount++;
+			// update NoDataIdleCount when sucessful send packet to STA.
+			pEntry->NoDataIdleCount = 0;
+			pEntry->ContinueTxFailCnt = 0;
+		}
+
+		succMCS = StaFifo.field.SuccessRate & 0x7F;
+
+		reTry = pid - succMCS;
+
+		if (StaFifo.field.TxSuccess) {
+			pEntry->TXMCSExpected[pid]++;
+			if (pid == succMCS) {
+				pEntry->TXMCSSuccessful[pid]++;
+			} else {
+				pEntry->TXMCSAutoFallBack[pid][succMCS]++;
 			}
+		} else {
+			pEntry->TXMCSFailed[pid]++;
+		}
 
-			if (reTry > 0)
-			{
-				if ((pid >= 12) && succMCS <=7)
-				{
-					reTry -= 4;
-				}
-				pEntry->OneSecTxRetryOkCount += reTry;
+		if (reTry > 0) {
+			if ((pid >= 12) && succMCS <= 7) {
+				reTry -= 4;
 			}
+			pEntry->OneSecTxRetryOkCount += reTry;
+		}
 
-			i++;
-			// ASIC store 16 stack
-		} while ( i < (2*TX_RING_SIZE) );
+		i++;
+		// ASIC store 16 stack
+	} while (i < (2 * TX_RING_SIZE));
 
 }
 
@@ -2161,29 +2094,27 @@ VOID NICUpdateFifoStaCounters(
 
 	========================================================================
 */
-VOID NICUpdateRawCounters(
-	IN PRTMP_ADAPTER pAd)
+VOID NICUpdateRawCounters(IN PRTMP_ADAPTER pAd)
 {
-	UINT32	OldValue;//, Value2;
-	//ULONG	PageSum, OneSecTransmitCount;
-	//ULONG	TxErrorRatio, Retry, Fail;
-	RX_STA_CNT0_STRUC	 RxStaCnt0;
-	RX_STA_CNT1_STRUC   RxStaCnt1;
-	RX_STA_CNT2_STRUC   RxStaCnt2;
-	TX_STA_CNT0_STRUC 	 TxStaCnt0;
-	TX_STA_CNT1_STRUC	 StaTx1;
-	TX_STA_CNT2_STRUC	 StaTx2;
-	TX_AGG_CNT_STRUC	TxAggCnt;
-	TX_AGG_CNT0_STRUC	TxAggCnt0;
-	TX_AGG_CNT1_STRUC	TxAggCnt1;
-	TX_AGG_CNT2_STRUC	TxAggCnt2;
-	TX_AGG_CNT3_STRUC	TxAggCnt3;
-	TX_AGG_CNT4_STRUC	TxAggCnt4;
-	TX_AGG_CNT5_STRUC	TxAggCnt5;
-	TX_AGG_CNT6_STRUC	TxAggCnt6;
-	TX_AGG_CNT7_STRUC	TxAggCnt7;
-	COUNTER_RALINK		*pRalinkCounters;
-
+	UINT32 OldValue;	//, Value2;
+	//ULONG PageSum, OneSecTransmitCount;
+	//ULONG TxErrorRatio, Retry, Fail;
+	RX_STA_CNT0_STRUC RxStaCnt0;
+	RX_STA_CNT1_STRUC RxStaCnt1;
+	RX_STA_CNT2_STRUC RxStaCnt2;
+	TX_STA_CNT0_STRUC TxStaCnt0;
+	TX_STA_CNT1_STRUC StaTx1;
+	TX_STA_CNT2_STRUC StaTx2;
+	TX_AGG_CNT_STRUC TxAggCnt;
+	TX_AGG_CNT0_STRUC TxAggCnt0;
+	TX_AGG_CNT1_STRUC TxAggCnt1;
+	TX_AGG_CNT2_STRUC TxAggCnt2;
+	TX_AGG_CNT3_STRUC TxAggCnt3;
+	TX_AGG_CNT4_STRUC TxAggCnt4;
+	TX_AGG_CNT5_STRUC TxAggCnt5;
+	TX_AGG_CNT6_STRUC TxAggCnt6;
+	TX_AGG_CNT7_STRUC TxAggCnt7;
+	COUNTER_RALINK *pRalinkCounters;
 
 	pRalinkCounters = &pAd->RalinkCounters;
 
@@ -2192,15 +2123,16 @@ VOID NICUpdateRawCounters(
 
 	{
 		RTMP_IO_READ32(pAd, RX_STA_CNT1, &RxStaCnt1.word);
-	    // Update RX PLCP error counter
-	    pAd->PrivateInfo.PhyRxErrCnt += RxStaCnt1.field.PlcpErr;
+		// Update RX PLCP error counter
+		pAd->PrivateInfo.PhyRxErrCnt += RxStaCnt1.field.PlcpErr;
 		// Update False CCA counter
-		pAd->RalinkCounters.OneSecFalseCCACnt += RxStaCnt1.field.FalseCca;
+		pAd->RalinkCounters.OneSecFalseCCACnt +=
+		    RxStaCnt1.field.FalseCca;
 	}
 
 	// Update FCS counters
-	OldValue= pAd->WlanCounters.FCSErrorCount.u.LowPart;
-	pAd->WlanCounters.FCSErrorCount.u.LowPart += (RxStaCnt0.field.CrcErr); // >> 7);
+	OldValue = pAd->WlanCounters.FCSErrorCount.u.LowPart;
+	pAd->WlanCounters.FCSErrorCount.u.LowPart += (RxStaCnt0.field.CrcErr);	// >> 7);
 	if (pAd->WlanCounters.FCSErrorCount.u.LowPart < OldValue)
 		pAd->WlanCounters.FCSErrorCount.u.HighPart++;
 
@@ -2213,19 +2145,17 @@ VOID NICUpdateRawCounters(
 
 	// Update Duplicate Rcv check
 	pRalinkCounters->DuplicateRcv += RxStaCnt2.field.RxDupliCount;
-	pAd->WlanCounters.FrameDuplicateCount.u.LowPart += RxStaCnt2.field.RxDupliCount;
+	pAd->WlanCounters.FrameDuplicateCount.u.LowPart +=
+	    RxStaCnt2.field.RxDupliCount;
 	// Update RX Overflow counter
 	pAd->Counters8023.RxNoBuffer += (RxStaCnt2.field.RxFifoOverflowCount);
 
 	//pAd->RalinkCounters.RxCount = 0;
 #ifdef RTMP_MAC_USB
-	if (pRalinkCounters->RxCount != pAd->watchDogRxCnt)
-	{
+	if (pRalinkCounters->RxCount != pAd->watchDogRxCnt) {
 		pAd->watchDogRxCnt = pRalinkCounters->RxCount;
 		pAd->watchDogRxOverFlowCnt = 0;
-	}
-	else
-	{
+	} else {
 		if (RxStaCnt2.field.RxFifoOverflowCount)
 			pAd->watchDogRxOverFlowCnt++;
 		else
@@ -2233,25 +2163,29 @@ VOID NICUpdateRawCounters(
 	}
 #endif // RTMP_MAC_USB //
 
-
 	//if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) ||
-	//	(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) && (pAd->MacTab.Size != 1)))
-	if (!pAd->bUpdateBcnCntDone)
-	{
-	// Update BEACON sent count
-	RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
-	RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
-	RTMP_IO_READ32(pAd, TX_STA_CNT2, &StaTx2.word);
-	pRalinkCounters->OneSecBeaconSentCnt += TxStaCnt0.field.TxBeaconCount;
-	pRalinkCounters->OneSecTxRetryOkCount += StaTx1.field.TxRetransmit;
-	pRalinkCounters->OneSecTxNoRetryOkCount += StaTx1.field.TxSuccess;
-	pRalinkCounters->OneSecTxFailCount += TxStaCnt0.field.TxFailCount;
-	pAd->WlanCounters.TransmittedFragmentCount.u.LowPart += StaTx1.field.TxSuccess;
-	pAd->WlanCounters.RetryCount.u.LowPart += StaTx1.field.TxRetransmit;
-	pAd->WlanCounters.FailedCount.u.LowPart += TxStaCnt0.field.TxFailCount;
+	//      (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) && (pAd->MacTab.Size != 1)))
+	if (!pAd->bUpdateBcnCntDone) {
+		// Update BEACON sent count
+		RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
+		RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
+		RTMP_IO_READ32(pAd, TX_STA_CNT2, &StaTx2.word);
+		pRalinkCounters->OneSecBeaconSentCnt +=
+		    TxStaCnt0.field.TxBeaconCount;
+		pRalinkCounters->OneSecTxRetryOkCount +=
+		    StaTx1.field.TxRetransmit;
+		pRalinkCounters->OneSecTxNoRetryOkCount +=
+		    StaTx1.field.TxSuccess;
+		pRalinkCounters->OneSecTxFailCount +=
+		    TxStaCnt0.field.TxFailCount;
+		pAd->WlanCounters.TransmittedFragmentCount.u.LowPart +=
+		    StaTx1.field.TxSuccess;
+		pAd->WlanCounters.RetryCount.u.LowPart +=
+		    StaTx1.field.TxRetransmit;
+		pAd->WlanCounters.FailedCount.u.LowPart +=
+		    TxStaCnt0.field.TxFailCount;
 	}
 
-
 	//if (pAd->bStaFifoTest == TRUE)
 	{
 		RTMP_IO_READ32(pAd, TX_AGG_CNT, &TxAggCnt.word);
@@ -2265,58 +2199,87 @@ VOID NICUpdateRawCounters(
 		RTMP_IO_READ32(pAd, TX_AGG_CNT7, &TxAggCnt7.word);
 		pRalinkCounters->TxAggCount += TxAggCnt.field.AggTxCount;
 		pRalinkCounters->TxNonAggCount += TxAggCnt.field.NonAggTxCount;
-		pRalinkCounters->TxAgg1MPDUCount += TxAggCnt0.field.AggSize1Count;
-		pRalinkCounters->TxAgg2MPDUCount += TxAggCnt0.field.AggSize2Count;
-
-		pRalinkCounters->TxAgg3MPDUCount += TxAggCnt1.field.AggSize3Count;
-		pRalinkCounters->TxAgg4MPDUCount += TxAggCnt1.field.AggSize4Count;
-		pRalinkCounters->TxAgg5MPDUCount += TxAggCnt2.field.AggSize5Count;
-		pRalinkCounters->TxAgg6MPDUCount += TxAggCnt2.field.AggSize6Count;
-
-		pRalinkCounters->TxAgg7MPDUCount += TxAggCnt3.field.AggSize7Count;
-		pRalinkCounters->TxAgg8MPDUCount += TxAggCnt3.field.AggSize8Count;
-		pRalinkCounters->TxAgg9MPDUCount += TxAggCnt4.field.AggSize9Count;
-		pRalinkCounters->TxAgg10MPDUCount += TxAggCnt4.field.AggSize10Count;
-
-		pRalinkCounters->TxAgg11MPDUCount += TxAggCnt5.field.AggSize11Count;
-		pRalinkCounters->TxAgg12MPDUCount += TxAggCnt5.field.AggSize12Count;
-		pRalinkCounters->TxAgg13MPDUCount += TxAggCnt6.field.AggSize13Count;
-		pRalinkCounters->TxAgg14MPDUCount += TxAggCnt6.field.AggSize14Count;
-
-		pRalinkCounters->TxAgg15MPDUCount += TxAggCnt7.field.AggSize15Count;
-		pRalinkCounters->TxAgg16MPDUCount += TxAggCnt7.field.AggSize16Count;
+		pRalinkCounters->TxAgg1MPDUCount +=
+		    TxAggCnt0.field.AggSize1Count;
+		pRalinkCounters->TxAgg2MPDUCount +=
+		    TxAggCnt0.field.AggSize2Count;
+
+		pRalinkCounters->TxAgg3MPDUCount +=
+		    TxAggCnt1.field.AggSize3Count;
+		pRalinkCounters->TxAgg4MPDUCount +=
+		    TxAggCnt1.field.AggSize4Count;
+		pRalinkCounters->TxAgg5MPDUCount +=
+		    TxAggCnt2.field.AggSize5Count;
+		pRalinkCounters->TxAgg6MPDUCount +=
+		    TxAggCnt2.field.AggSize6Count;
+
+		pRalinkCounters->TxAgg7MPDUCount +=
+		    TxAggCnt3.field.AggSize7Count;
+		pRalinkCounters->TxAgg8MPDUCount +=
+		    TxAggCnt3.field.AggSize8Count;
+		pRalinkCounters->TxAgg9MPDUCount +=
+		    TxAggCnt4.field.AggSize9Count;
+		pRalinkCounters->TxAgg10MPDUCount +=
+		    TxAggCnt4.field.AggSize10Count;
+
+		pRalinkCounters->TxAgg11MPDUCount +=
+		    TxAggCnt5.field.AggSize11Count;
+		pRalinkCounters->TxAgg12MPDUCount +=
+		    TxAggCnt5.field.AggSize12Count;
+		pRalinkCounters->TxAgg13MPDUCount +=
+		    TxAggCnt6.field.AggSize13Count;
+		pRalinkCounters->TxAgg14MPDUCount +=
+		    TxAggCnt6.field.AggSize14Count;
+
+		pRalinkCounters->TxAgg15MPDUCount +=
+		    TxAggCnt7.field.AggSize15Count;
+		pRalinkCounters->TxAgg16MPDUCount +=
+		    TxAggCnt7.field.AggSize16Count;
 
 		// Calculate the transmitted A-MPDU count
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += TxAggCnt0.field.AggSize1Count;
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt0.field.AggSize2Count / 2);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt1.field.AggSize3Count / 3);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt1.field.AggSize4Count / 4);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt2.field.AggSize5Count / 5);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt2.field.AggSize6Count / 6);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt3.field.AggSize7Count / 7);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt3.field.AggSize8Count / 8);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt4.field.AggSize9Count / 9);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt4.field.AggSize10Count / 10);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt5.field.AggSize11Count / 11);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt5.field.AggSize12Count / 12);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt6.field.AggSize13Count / 13);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt6.field.AggSize14Count / 14);
-
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt7.field.AggSize15Count / 15);
-		pRalinkCounters->TransmittedAMPDUCount.u.LowPart += (TxAggCnt7.field.AggSize16Count / 16);
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    TxAggCnt0.field.AggSize1Count;
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt0.field.AggSize2Count / 2);
+
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt1.field.AggSize3Count / 3);
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt1.field.AggSize4Count / 4);
+
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt2.field.AggSize5Count / 5);
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt2.field.AggSize6Count / 6);
+
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt3.field.AggSize7Count / 7);
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt3.field.AggSize8Count / 8);
+
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt4.field.AggSize9Count / 9);
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt4.field.AggSize10Count / 10);
+
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt5.field.AggSize11Count / 11);
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt5.field.AggSize12Count / 12);
+
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt6.field.AggSize13Count / 13);
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt6.field.AggSize14Count / 14);
+
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt7.field.AggSize15Count / 15);
+		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
+		    (TxAggCnt7.field.AggSize16Count / 16);
 	}
 
-
-
 }
 
-
 /*
 	========================================================================
 
@@ -2336,8 +2299,7 @@ VOID NICUpdateRawCounters(
 
 	========================================================================
 */
-VOID	NICResetFromError(
-	IN	PRTMP_ADAPTER	pAd)
+VOID NICResetFromError(IN PRTMP_ADAPTER pAd)
 {
 	// Reset BBP (according to alex, reset ASIC will force reset BBP
 	// Therefore, skip the reset BBP
@@ -2355,18 +2317,15 @@ VOID	NICResetFromError(
 	AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
 }
 
-
-NDIS_STATUS NICLoadFirmware(
-	IN PRTMP_ADAPTER pAd)
+NDIS_STATUS NICLoadFirmware(IN PRTMP_ADAPTER pAd)
 {
-	NDIS_STATUS	 status = NDIS_STATUS_SUCCESS;
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
 	if (pAd->chipOps.loadFirmware)
 		status = pAd->chipOps.loadFirmware(pAd);
 
 	return status;
 }
 
-
 /*
 	========================================================================
 
@@ -2380,14 +2339,12 @@ NDIS_STATUS NICLoadFirmware(
 
 	========================================================================
 */
-VOID NICEraseFirmware(
-	IN PRTMP_ADAPTER pAd)
+VOID NICEraseFirmware(IN PRTMP_ADAPTER pAd)
 {
 	if (pAd->chipOps.eraseFirmware)
 		pAd->chipOps.eraseFirmware(pAd);
 
-}/* End of NICEraseFirmware */
-
+}				/* End of NICEraseFirmware */
 
 /*
 	========================================================================
@@ -2410,13 +2367,11 @@ VOID NICEraseFirmware(
 
 	========================================================================
 */
-NDIS_STATUS NICLoadRateSwitchingParams(
-	IN PRTMP_ADAPTER pAd)
+NDIS_STATUS NICLoadRateSwitchingParams(IN PRTMP_ADAPTER pAd)
 {
 	return NDIS_STATUS_SUCCESS;
 }
 
-
 /*
 	========================================================================
 
@@ -2438,20 +2393,16 @@ NDIS_STATUS NICLoadRateSwitchingParams(
 
 	========================================================================
 */
-ULONG	RTMPCompareMemory(
-	IN	PVOID	pSrc1,
-	IN	PVOID	pSrc2,
-	IN	ULONG	Length)
-{
-	PUCHAR	pMem1;
-	PUCHAR	pMem2;
-	ULONG	Index = 0;
+ULONG RTMPCompareMemory(IN PVOID pSrc1, IN PVOID pSrc2, IN ULONG Length)
+{
+	PUCHAR pMem1;
+	PUCHAR pMem2;
+	ULONG Index = 0;
 
 	pMem1 = (PUCHAR) pSrc1;
 	pMem2 = (PUCHAR) pSrc2;
 
-	for (Index = 0; Index < Length; Index++)
-	{
+	for (Index = 0; Index < Length; Index++) {
 		if (pMem1[Index] > pMem2[Index])
 			return (1);
 		else if (pMem1[Index] < pMem2[Index])
@@ -2482,22 +2433,18 @@ ULONG	RTMPCompareMemory(
 
 	========================================================================
 */
-VOID	RTMPZeroMemory(
-	IN	PVOID	pSrc,
-	IN	ULONG	Length)
+VOID RTMPZeroMemory(IN PVOID pSrc, IN ULONG Length)
 {
-	PUCHAR	pMem;
-	ULONG	Index = 0;
+	PUCHAR pMem;
+	ULONG Index = 0;
 
 	pMem = (PUCHAR) pSrc;
 
-	for (Index = 0; Index < Length; Index++)
-	{
+	for (Index = 0; Index < Length; Index++) {
 		pMem[Index] = 0x00;
 	}
 }
 
-
 /*
 	========================================================================
 
@@ -2519,22 +2466,18 @@ VOID	RTMPZeroMemory(
 
 	========================================================================
 */
-VOID	RTMPMoveMemory(
-	OUT	PVOID	pDest,
-	IN	PVOID	pSrc,
-	IN	ULONG	Length)
-{
-	PUCHAR	pMem1;
-	PUCHAR	pMem2;
-	UINT	Index;
+VOID RTMPMoveMemory(OUT PVOID pDest, IN PVOID pSrc, IN ULONG Length)
+{
+	PUCHAR pMem1;
+	PUCHAR pMem2;
+	UINT Index;
 
-	ASSERT((Length==0) || (pDest && pSrc));
+	ASSERT((Length == 0) || (pDest && pSrc));
 
 	pMem1 = (PUCHAR) pDest;
 	pMem2 = (PUCHAR) pSrc;
 
-	for (Index = 0; Index < Length; Index++)
-	{
+	for (Index = 0; Index < Length; Index++) {
 		pMem1[Index] = pMem2[Index];
 	}
 }
@@ -2557,10 +2500,9 @@ VOID	RTMPMoveMemory(
 
 	========================================================================
 */
-VOID	UserCfgInit(
-	IN	PRTMP_ADAPTER pAd)
+VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 {
-    UINT key_index, bss_index;
+	UINT key_index, bss_index;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> UserCfgInit\n"));
 
@@ -2586,19 +2528,19 @@ VOID	UserCfgInit(
 
 	pAd->CommonCfg.MaxPktOneTxBulk = 2;
 	pAd->CommonCfg.TxBulkFactor = 1;
-	pAd->CommonCfg.RxBulkFactor =1;
+	pAd->CommonCfg.RxBulkFactor = 1;
 
-	pAd->CommonCfg.TxPower = 100; //mW
+	pAd->CommonCfg.TxPower = 100;	//mW
 
-	NdisZeroMemory(&pAd->CommonCfg.IOTestParm, sizeof(pAd->CommonCfg.IOTestParm));
+	NdisZeroMemory(&pAd->CommonCfg.IOTestParm,
+		       sizeof(pAd->CommonCfg.IOTestParm));
 #endif // RTMP_MAC_USB //
 
-	for(key_index=0; key_index<SHARE_KEY_NUM; key_index++)
-	{
-		for(bss_index = 0; bss_index < MAX_MBSSID_NUM; bss_index++)
-		{
+	for (key_index = 0; key_index < SHARE_KEY_NUM; key_index++) {
+		for (bss_index = 0; bss_index < MAX_MBSSID_NUM; bss_index++) {
 			pAd->SharedKey[bss_index][key_index].KeyLen = 0;
-			pAd->SharedKey[bss_index][key_index].CipherAlg = CIPHER_NONE;
+			pAd->SharedKey[bss_index][key_index].CipherAlg =
+			    CIPHER_NONE;
 		}
 	}
 
@@ -2612,12 +2554,12 @@ VOID	UserCfgInit(
 	pAd->LedIndicatorStrength = 0;
 	pAd->RLnkCtrlOffset = 0;
 	pAd->HostLnkCtrlOffset = 0;
-	pAd->StaCfg.PSControl.field.EnableNewPS=TRUE;
+	pAd->StaCfg.PSControl.field.EnableNewPS = TRUE;
 	pAd->CheckDmaBusyCount = 0;
 #endif // RTMP_MAC_PCI //
 
-	pAd->bAutoTxAgcA = FALSE;			// Default is OFF
-	pAd->bAutoTxAgcG = FALSE;			// Default is OFF
+	pAd->bAutoTxAgcA = FALSE;	// Default is OFF
+	pAd->bAutoTxAgcG = FALSE;	// Default is OFF
 	pAd->RfIcType = RFIC_2820;
 
 	// Init timer for reset complete event
@@ -2626,25 +2568,22 @@ VOID	UserCfgInit(
 	pAd->bForcePrintRX = FALSE;
 	pAd->bStaFifoTest = FALSE;
 	pAd->bProtectionTest = FALSE;
-	pAd->CommonCfg.Dsifs = 10;      // in units of usec
-	pAd->CommonCfg.TxPower = 100; //mW
-	pAd->CommonCfg.TxPowerPercentage = 0xffffffff; // AUTO
-	pAd->CommonCfg.TxPowerDefault = 0xffffffff; // AUTO
-	pAd->CommonCfg.TxPreamble = Rt802_11PreambleAuto; // use Long preamble on TX by defaut
+	pAd->CommonCfg.Dsifs = 10;	// in units of usec
+	pAd->CommonCfg.TxPower = 100;	//mW
+	pAd->CommonCfg.TxPowerPercentage = 0xffffffff;	// AUTO
+	pAd->CommonCfg.TxPowerDefault = 0xffffffff;	// AUTO
+	pAd->CommonCfg.TxPreamble = Rt802_11PreambleAuto;	// use Long preamble on TX by defaut
 	pAd->CommonCfg.bUseZeroToDisableFragment = FALSE;
 	pAd->CommonCfg.RtsThreshold = 2347;
 	pAd->CommonCfg.FragmentThreshold = 2346;
-	pAd->CommonCfg.UseBGProtection = 0;    // 0: AUTO
-	pAd->CommonCfg.bEnableTxBurst = TRUE; //0;
-	pAd->CommonCfg.PhyMode = 0xff;     // unknown
+	pAd->CommonCfg.UseBGProtection = 0;	// 0: AUTO
+	pAd->CommonCfg.bEnableTxBurst = TRUE;	//0;
+	pAd->CommonCfg.PhyMode = 0xff;	// unknown
 	pAd->CommonCfg.BandState = UNKNOWN_BAND;
 	pAd->CommonCfg.RadarDetect.CSPeriod = 10;
 	pAd->CommonCfg.RadarDetect.CSCount = 0;
 	pAd->CommonCfg.RadarDetect.RDMode = RD_NORMAL_MODE;
 
-
-
-
 	pAd->CommonCfg.RadarDetect.ChMovingTime = 65;
 	pAd->CommonCfg.RadarDetect.LongPulseRadarTh = 3;
 	pAd->CommonCfg.bAPSDCapable = FALSE;
@@ -2657,18 +2596,22 @@ VOID	UserCfgInit(
 
 	NdisZeroMemory(&pAd->BeaconTxWI, sizeof(pAd->BeaconTxWI));
 
-	NdisZeroMemory(&pAd->CommonCfg.HtCapability, sizeof(pAd->CommonCfg.HtCapability));
+	NdisZeroMemory(&pAd->CommonCfg.HtCapability,
+		       sizeof(pAd->CommonCfg.HtCapability));
 	pAd->HTCEnable = FALSE;
 	pAd->bBroadComHT = FALSE;
 	pAd->CommonCfg.bRdg = FALSE;
 
-	NdisZeroMemory(&pAd->CommonCfg.AddHTInfo, sizeof(pAd->CommonCfg.AddHTInfo));
+	NdisZeroMemory(&pAd->CommonCfg.AddHTInfo,
+		       sizeof(pAd->CommonCfg.AddHTInfo));
 	pAd->CommonCfg.BACapability.field.MMPSmode = MMPS_ENABLE;
 	pAd->CommonCfg.BACapability.field.MpduDensity = 0;
 	pAd->CommonCfg.BACapability.field.Policy = IMMED_BA;
-	pAd->CommonCfg.BACapability.field.RxBAWinLimit = 64; //32;
-	pAd->CommonCfg.BACapability.field.TxBAWinLimit = 64; //32;
-	DBGPRINT(RT_DEBUG_TRACE, ("--> UserCfgInit. BACapability = 0x%x\n", pAd->CommonCfg.BACapability.word));
+	pAd->CommonCfg.BACapability.field.RxBAWinLimit = 64;	//32;
+	pAd->CommonCfg.BACapability.field.TxBAWinLimit = 64;	//32;
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("--> UserCfgInit. BACapability = 0x%x\n",
+		  pAd->CommonCfg.BACapability.word));
 
 	pAd->CommonCfg.BACapability.field.AutoBA = FALSE;
 	BATableInit(pAd, &pAd->BATable);
@@ -2677,16 +2620,15 @@ VOID	UserCfgInit(
 	pAd->CommonCfg.bHTProtect = 1;
 	pAd->CommonCfg.bMIMOPSEnable = TRUE;
 	//2008/11/05:KH add to support Antenna power-saving of AP<--
-	pAd->CommonCfg.bGreenAPEnable=FALSE;
+	pAd->CommonCfg.bGreenAPEnable = FALSE;
 	//2008/11/05:KH add to support Antenna power-saving of AP-->
 	pAd->CommonCfg.bBADecline = FALSE;
 	pAd->CommonCfg.bDisableReordering = FALSE;
 
-	if (pAd->MACVersion == 0x28720200)
-	{
-		pAd->CommonCfg.TxBASize = 13; //by Jerry recommend
-	}else{
-	pAd->CommonCfg.TxBASize = 7;
+	if (pAd->MACVersion == 0x28720200) {
+		pAd->CommonCfg.TxBASize = 13;	//by Jerry recommend
+	} else {
+		pAd->CommonCfg.TxBASize = 7;
 	}
 
 	pAd->CommonCfg.REGBACapability.word = pAd->CommonCfg.BACapability.word;
@@ -2701,7 +2643,7 @@ VOID	UserCfgInit(
 	pAd->CommonCfg.MlmeTransmit.field.BW = BW_20;
 	pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
 
-	pAd->CommonCfg.BeaconPeriod = 100;     // in mSec
+	pAd->CommonCfg.BeaconPeriod = 100;	// in mSec
 
 	//
 	// part II. intialize STA specific configuration
@@ -2724,18 +2666,19 @@ VOID	UserCfgInit(
 		pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
 		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
 		pAd->StaCfg.LastMicErrorTime = 0;
-		pAd->StaCfg.MicErrCnt        = 0;
-		pAd->StaCfg.bBlockAssoc      = FALSE;
-		pAd->StaCfg.WpaState         = SS_NOTUSE;
+		pAd->StaCfg.MicErrCnt = 0;
+		pAd->StaCfg.bBlockAssoc = FALSE;
+		pAd->StaCfg.WpaState = SS_NOTUSE;
 
-		pAd->CommonCfg.NdisRadioStateOff = FALSE;		// New to support microsoft disable radio with OID command
+		pAd->CommonCfg.NdisRadioStateOff = FALSE;	// New to support microsoft disable radio with OID command
 
 		pAd->StaCfg.RssiTrigger = 0;
 		NdisZeroMemory(&pAd->StaCfg.RssiSample, sizeof(RSSI_SAMPLE));
-		pAd->StaCfg.RssiTriggerMode = RSSI_TRIGGERED_UPON_BELOW_THRESHOLD;
+		pAd->StaCfg.RssiTriggerMode =
+		    RSSI_TRIGGERED_UPON_BELOW_THRESHOLD;
 		pAd->StaCfg.AtimWin = 0;
-		pAd->StaCfg.DefaultListenCount = 3;//default listen count;
-		pAd->StaCfg.BssType = BSS_INFRA;  // BSS_INFRA or BSS_ADHOC or BSS_MONITOR
+		pAd->StaCfg.DefaultListenCount = 3;	//default listen count;
+		pAd->StaCfg.BssType = BSS_INFRA;	// BSS_INFRA or BSS_ADHOC or BSS_MONITOR
 		pAd->StaCfg.bScanReqIsFromWebUI = FALSE;
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
@@ -2745,12 +2688,12 @@ VOID	UserCfgInit(
 	}
 
 #ifdef PCIE_PS_SUPPORT
-pAd->brt30xxBanMcuCmd = FALSE;
-pAd->b3090ESpecialChip = FALSE;
+	pAd->brt30xxBanMcuCmd = FALSE;
+	pAd->b3090ESpecialChip = FALSE;
 //KH Debug:the following must be removed
-pAd->StaCfg.PSControl.field.rt30xxPowerMode=3;
-pAd->StaCfg.PSControl.field.rt30xxForceASPMTest=0;
-pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM=1;
+	pAd->StaCfg.PSControl.field.rt30xxPowerMode = 3;
+	pAd->StaCfg.PSControl.field.rt30xxForceASPMTest = 0;
+	pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM = 1;
 #endif // PCIE_PS_SUPPORT //
 
 	// global variables mXXXX used in MAC protocol state machines
@@ -2759,8 +2702,8 @@ pAd->StaCfg.PSControl.field.rt30xxFollow
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
 
 	// PHY specification
-	pAd->CommonCfg.PhyMode = PHY_11BG_MIXED;		// default PHY mode
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);  // CCK use LONG preamble
+	pAd->CommonCfg.PhyMode = PHY_11BG_MIXED;	// default PHY mode
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);	// CCK use LONG preamble
 
 	{
 		// user desired power mode
@@ -2768,17 +2711,19 @@ pAd->StaCfg.PSControl.field.rt30xxFollow
 		pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
 		pAd->StaCfg.bWindowsACCAMEnable = FALSE;
 
-		RTMPInitTimer(pAd, &pAd->StaCfg.StaQuickResponeForRateUpTimer, GET_TIMER_FUNCTION(StaQuickResponeForRateUpExec), pAd, FALSE);
+		RTMPInitTimer(pAd, &pAd->StaCfg.StaQuickResponeForRateUpTimer,
+			      GET_TIMER_FUNCTION(StaQuickResponeForRateUpExec),
+			      pAd, FALSE);
 		pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
 
 		// Patch for Ndtest
 		pAd->StaCfg.ScanCnt = 0;
 
-		pAd->StaCfg.bHwRadio  = TRUE; // Default Hardware Radio status is On
-		pAd->StaCfg.bSwRadio  = TRUE; // Default Software Radio status is On
-		pAd->StaCfg.bRadio    = TRUE; // bHwRadio && bSwRadio
-		pAd->StaCfg.bHardwareRadio = FALSE;		// Default is OFF
-		pAd->StaCfg.bShowHiddenSSID = FALSE;		// Default no show
+		pAd->StaCfg.bHwRadio = TRUE;	// Default Hardware Radio status is On
+		pAd->StaCfg.bSwRadio = TRUE;	// Default Software Radio status is On
+		pAd->StaCfg.bRadio = TRUE;	// bHwRadio && bSwRadio
+		pAd->StaCfg.bHardwareRadio = FALSE;	// Default is OFF
+		pAd->StaCfg.bShowHiddenSSID = FALSE;	// Default no show
 
 		// Nitro mode control
 		pAd->StaCfg.bAutoReconnect = TRUE;
@@ -2789,14 +2734,16 @@ pAd->StaCfg.PSControl.field.rt30xxFollow
 		if (pAd->StaCfg.LastScanTime > 10 * OS_HZ)
 			pAd->StaCfg.LastScanTime -= (10 * OS_HZ);
 
-		NdisZeroMemory(pAd->nickname, IW_ESSID_MAX_SIZE+1);
+		NdisZeroMemory(pAd->nickname, IW_ESSID_MAX_SIZE + 1);
 #ifdef RTMP_MAC_PCI
 		sprintf((PSTRING) pAd->nickname, "RT2860STA");
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
-			sprintf((PSTRING) pAd->nickname, "RT2870STA");
+		sprintf((PSTRING) pAd->nickname, "RT2870STA");
 #endif // RTMP_MAC_USB //
-		RTMPInitTimer(pAd, &pAd->StaCfg.WpaDisassocAndBlockAssocTimer, GET_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc), pAd, FALSE);
+		RTMPInitTimer(pAd, &pAd->StaCfg.WpaDisassocAndBlockAssocTimer,
+			      GET_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc),
+			      pAd, FALSE);
 		pAd->StaCfg.IEEE8021X = FALSE;
 		pAd->StaCfg.IEEE8021x_required_keys = FALSE;
 		pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_DISABLE;
@@ -2805,7 +2752,6 @@ pAd->StaCfg.PSControl.field.rt30xxFollow
 
 		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
 
-
 		pAd->StaCfg.bAutoConnectByBssid = FALSE;
 		pAd->StaCfg.BeaconLostTime = BEACON_LOST_TIME;
 		NdisZeroMemory(pAd->StaCfg.WpaPassPhrase, 64);
@@ -2824,15 +2770,14 @@ pAd->StaCfg.PSControl.field.rt30xxFollow
 	// part III. AP configurations
 	//
 
-
 	//
 	// part IV. others
 	//
 	// dynamic BBP R66:sensibity tuning to overcome background noise
-	pAd->BbpTuning.bEnable                = TRUE;
+	pAd->BbpTuning.bEnable = TRUE;
 	pAd->BbpTuning.FalseCcaLowerThreshold = 100;
 	pAd->BbpTuning.FalseCcaUpperThreshold = 512;
-	pAd->BbpTuning.R66Delta               = 4;
+	pAd->BbpTuning.R66Delta = 4;
 	pAd->Mlme.bEnableAutoAntennaCheck = TRUE;
 
 	//
@@ -2855,24 +2800,25 @@ pAd->StaCfg.PSControl.field.rt30xxFollow
 	//RTMPInitTimer(pAd, &pAd->RECBATimer, RECBATimerTimeout, pAd, TRUE);
 	//RTMPSetTimer(&pAd->RECBATimer, REORDER_EXEC_INTV);
 
-
-
 	pAd->CommonCfg.bWiFiTest = FALSE;
 #ifdef RTMP_MAC_PCI
 	pAd->bPCIclkOff = FALSE;
 #endif // RTMP_MAC_PCI //
 
-RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
+	RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- UserCfgInit\n"));
 }
 
 // IRQL = PASSIVE_LEVEL
 UCHAR BtoH(STRING ch)
 {
-	if (ch >= '0' && ch <= '9') return (ch - '0');        // Handle numerals
-	if (ch >= 'A' && ch <= 'F') return (ch - 'A' + 0xA);  // Handle capitol hex digits
-	if (ch >= 'a' && ch <= 'f') return (ch - 'a' + 0xA);  // Handle small hex digits
-	return(255);
+	if (ch >= '0' && ch <= '9')
+		return (ch - '0');	// Handle numerals
+	if (ch >= 'A' && ch <= 'F')
+		return (ch - 'A' + 0xA);	// Handle capitol hex digits
+	if (ch >= 'a' && ch <= 'f')
+		return (ch - 'a' + 0xA);	// Handle small hex digits
+	return (255);
 }
 
 //
@@ -2900,19 +2846,16 @@ void AtoH(PSTRING src, PUCHAR dest, int 
 	srcptr = src;
 	destTemp = (PUCHAR) dest;
 
-	while(destlen--)
-	{
-		*destTemp = BtoH(*srcptr++) << 4;    // Put 1st ascii byte in upper nibble.
-		*destTemp += BtoH(*srcptr++);      // Add 2nd ascii byte to above.
+	while (destlen--) {
+		*destTemp = BtoH(*srcptr++) << 4;	// Put 1st ascii byte in upper nibble.
+		*destTemp += BtoH(*srcptr++);	// Add 2nd ascii byte to above.
 		destTemp++;
 	}
 }
 
-
 //+++Mark by shiang, not use now, need to remove after confirm
 //---Mark by shiang, not use now, need to remove after confirm
 
-
 /*
 	========================================================================
 
@@ -2932,29 +2875,26 @@ void AtoH(PSTRING src, PUCHAR dest, int 
 
 	========================================================================
 */
-VOID	RTMPInitTimer(
-	IN	PRTMP_ADAPTER			pAd,
-	IN	PRALINK_TIMER_STRUCT	pTimer,
-	IN	PVOID					pTimerFunc,
-	IN	PVOID					pData,
-	IN	BOOLEAN					Repeat)
+VOID RTMPInitTimer(IN PRTMP_ADAPTER pAd,
+		   IN PRALINK_TIMER_STRUCT pTimer,
+		   IN PVOID pTimerFunc, IN PVOID pData, IN BOOLEAN Repeat)
 {
 	//
 	// Set Valid to TRUE for later used.
 	// It will crash if we cancel a timer or set a timer
 	// that we haven't initialize before.
 	//
-	pTimer->Valid      = TRUE;
+	pTimer->Valid = TRUE;
 
 	pTimer->PeriodicType = Repeat;
-	pTimer->State      = FALSE;
+	pTimer->State = FALSE;
 	pTimer->cookie = (ULONG) pData;
 
 #ifdef RTMP_TIMER_TASK_SUPPORT
 	pTimer->pAd = pAd;
 #endif // RTMP_TIMER_TASK_SUPPORT //
 
-	RTMP_OS_Init_Timer(pAd,	&pTimer->TimerObj,	pTimerFunc, (PVOID) pTimer);
+	RTMP_OS_Init_Timer(pAd, &pTimer->TimerObj, pTimerFunc, (PVOID) pTimer);
 }
 
 /*
@@ -2975,32 +2915,23 @@ VOID	RTMPInitTimer(
 
 	========================================================================
 */
-VOID	RTMPSetTimer(
-	IN	PRALINK_TIMER_STRUCT	pTimer,
-	IN	ULONG					Value)
+VOID RTMPSetTimer(IN PRALINK_TIMER_STRUCT pTimer, IN ULONG Value)
 {
-	if (pTimer->Valid)
-	{
+	if (pTimer->Valid) {
 		pTimer->TimerValue = Value;
-		pTimer->State      = FALSE;
-		if (pTimer->PeriodicType == TRUE)
-		{
+		pTimer->State = FALSE;
+		if (pTimer->PeriodicType == TRUE) {
 			pTimer->Repeat = TRUE;
 			RTMP_SetPeriodicTimer(&pTimer->TimerObj, Value);
-		}
-		else
-		{
+		} else {
 			pTimer->Repeat = FALSE;
 			RTMP_OS_Add_Timer(&pTimer->TimerObj, Value);
 		}
-	}
-	else
-	{
+	} else {
 		DBGPRINT_ERR(("RTMPSetTimer failed, Timer hasn't been initialize!\n"));
 	}
 }
 
-
 /*
 	========================================================================
 
@@ -3019,28 +2950,20 @@ VOID	RTMPSetTimer(
 
 	========================================================================
 */
-VOID	RTMPModTimer(
-	IN	PRALINK_TIMER_STRUCT	pTimer,
-	IN	ULONG					Value)
+VOID RTMPModTimer(IN PRALINK_TIMER_STRUCT pTimer, IN ULONG Value)
 {
-	BOOLEAN	Cancel;
+	BOOLEAN Cancel;
 
-	if (pTimer->Valid)
-	{
+	if (pTimer->Valid) {
 		pTimer->TimerValue = Value;
-		pTimer->State      = FALSE;
-		if (pTimer->PeriodicType == TRUE)
-		{
+		pTimer->State = FALSE;
+		if (pTimer->PeriodicType == TRUE) {
 			RTMPCancelTimer(pTimer, &Cancel);
 			RTMPSetTimer(pTimer, Value);
-		}
-		else
-		{
+		} else {
 			RTMP_OS_Mod_Timer(&pTimer->TimerObj, Value);
 		}
-	}
-	else
-	{
+	} else {
 		DBGPRINT_ERR(("RTMPModTimer failed, Timer hasn't been initialize!\n"));
 	}
 }
@@ -3066,28 +2989,23 @@ VOID	RTMPModTimer(
 
 	========================================================================
 */
-VOID	RTMPCancelTimer(
-	IN	PRALINK_TIMER_STRUCT	pTimer,
-	OUT	BOOLEAN					*pCancelled)
+VOID RTMPCancelTimer(IN PRALINK_TIMER_STRUCT pTimer, OUT BOOLEAN * pCancelled)
 {
-	if (pTimer->Valid)
-	{
+	if (pTimer->Valid) {
 		if (pTimer->State == FALSE)
 			pTimer->Repeat = FALSE;
 
-			RTMP_OS_Del_Timer(&pTimer->TimerObj, pCancelled);
+		RTMP_OS_Del_Timer(&pTimer->TimerObj, pCancelled);
 
 		if (*pCancelled == TRUE)
 			pTimer->State = TRUE;
 
 #ifdef RTMP_TIMER_TASK_SUPPORT
 		// We need to go-through the TimerQ to findout this timer handler and remove it if
-		//		it's still waiting for execution.
+		//              it's still waiting for execution.
 		RtmpTimerQRemove(pTimer->pAd, pTimer);
 #endif // RTMP_TIMER_TASK_SUPPORT //
-	}
-	else
-	{
+	} else {
 		DBGPRINT_ERR(("RTMPCancelTimer failed, Timer hasn't been initialize!\n"));
 	}
 }
@@ -3112,64 +3030,64 @@ VOID	RTMPCancelTimer(
 
 	========================================================================
 */
-VOID RTMPSetLED(
-	IN PRTMP_ADAPTER 	pAd,
-	IN UCHAR			Status)
-{
-	//ULONG			data;
-	UCHAR			HighByte = 0;
-	UCHAR			LowByte;
-
-	LowByte = pAd->LedCntl.field.LedMode&0x7f;
-	switch (Status)
-	{
-		case LED_LINK_DOWN:
-			HighByte = 0x20;
-			AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-			pAd->LedIndicatorStrength = 0;
-			break;
-		case LED_LINK_UP:
-			if (pAd->CommonCfg.Channel > 14)
-				HighByte = 0xa0;
-			else
-				HighByte = 0x60;
-			AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-			break;
-		case LED_RADIO_ON:
-			HighByte = 0x20;
-			AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-			break;
-		case LED_HALT:
-			LowByte = 0; // Driver sets MAC register and MAC controls LED
-		case LED_RADIO_OFF:
-			HighByte = 0;
-			AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-			break;
-        case LED_WPS:
-			HighByte = 0x10;
-			AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-			break;
-		case LED_ON_SITE_SURVEY:
-			HighByte = 0x08;
-			AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-			break;
-		case LED_POWER_UP:
-			HighByte = 0x04;
-			AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
-			break;
-		default:
-			DBGPRINT(RT_DEBUG_WARN, ("RTMPSetLED::Unknown Status %d\n", Status));
-			break;
+VOID RTMPSetLED(IN PRTMP_ADAPTER pAd, IN UCHAR Status)
+{
+	//ULONG                 data;
+	UCHAR HighByte = 0;
+	UCHAR LowByte;
+
+	LowByte = pAd->LedCntl.field.LedMode & 0x7f;
+	switch (Status) {
+	case LED_LINK_DOWN:
+		HighByte = 0x20;
+		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
+		pAd->LedIndicatorStrength = 0;
+		break;
+	case LED_LINK_UP:
+		if (pAd->CommonCfg.Channel > 14)
+			HighByte = 0xa0;
+		else
+			HighByte = 0x60;
+		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
+		break;
+	case LED_RADIO_ON:
+		HighByte = 0x20;
+		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
+		break;
+	case LED_HALT:
+		LowByte = 0;	// Driver sets MAC register and MAC controls LED
+	case LED_RADIO_OFF:
+		HighByte = 0;
+		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
+		break;
+	case LED_WPS:
+		HighByte = 0x10;
+		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
+		break;
+	case LED_ON_SITE_SURVEY:
+		HighByte = 0x08;
+		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
+		break;
+	case LED_POWER_UP:
+		HighByte = 0x04;
+		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
+		break;
+	default:
+		DBGPRINT(RT_DEBUG_WARN,
+			 ("RTMPSetLED::Unknown Status %d\n", Status));
+		break;
 	}
 
-    //
+	//
 	// Keep LED status for LED SiteSurvey mode.
 	// After SiteSurvey, we will set the LED mode to previous status.
 	//
 	if ((Status != LED_ON_SITE_SURVEY) && (Status != LED_POWER_UP))
 		pAd->LedStatus = Status;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPSetLED::Mode=%d,HighByte=0x%02x,LowByte=0x%02x\n", pAd->LedCntl.field.LedMode, HighByte, LowByte));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPSetLED::Mode=%d,HighByte=0x%02x,LowByte=0x%02x\n",
+		  pAd->LedCntl.field.LedMode, HighByte, LowByte));
 }
 
 /*
@@ -3199,35 +3117,32 @@ VOID RTMPSetLED(
 		 > -57  Excellent
 	========================================================================
 */
-VOID RTMPSetSignalLED(
-	IN PRTMP_ADAPTER 	pAd,
-	IN NDIS_802_11_RSSI Dbm)
-{
-	UCHAR		nLed = 0;
-
-	if (pAd->LedCntl.field.LedMode == LED_MODE_SIGNAL_STREGTH)
-	{
-	if (Dbm <= -90)
-		nLed = 0;
-	else if (Dbm <= -81)
-		nLed = 1;
-	else if (Dbm <= -71)
-		nLed = 3;
-	else if (Dbm <= -67)
-		nLed = 7;
-	else if (Dbm <= -57)
-		nLed = 15;
-	else
-		nLed = 31;
+VOID RTMPSetSignalLED(IN PRTMP_ADAPTER pAd, IN NDIS_802_11_RSSI Dbm)
+{
+	UCHAR nLed = 0;
 
-	//
-	// Update Signal Stregth to firmware if changed.
-	//
-	if (pAd->LedIndicatorStrength != nLed)
-	{
-		AsicSendCommandToMcu(pAd, 0x51, 0xff, nLed, pAd->LedCntl.field.Polarity);
-		pAd->LedIndicatorStrength = nLed;
-	}
+	if (pAd->LedCntl.field.LedMode == LED_MODE_SIGNAL_STREGTH) {
+		if (Dbm <= -90)
+			nLed = 0;
+		else if (Dbm <= -81)
+			nLed = 1;
+		else if (Dbm <= -71)
+			nLed = 3;
+		else if (Dbm <= -67)
+			nLed = 7;
+		else if (Dbm <= -57)
+			nLed = 15;
+		else
+			nLed = 31;
+
+		//
+		// Update Signal Stregth to firmware if changed.
+		//
+		if (pAd->LedIndicatorStrength != nLed) {
+			AsicSendCommandToMcu(pAd, 0x51, 0xff, nLed,
+					     pAd->LedCntl.field.Polarity);
+			pAd->LedIndicatorStrength = nLed;
+		}
 	}
 }
 
@@ -3249,11 +3164,10 @@ VOID RTMPSetSignalLED(
 		Before Enable RX, make sure you have enabled Interrupt.
 	========================================================================
 */
-VOID RTMPEnableRxTx(
-	IN PRTMP_ADAPTER	pAd)
+VOID RTMPEnableRxTx(IN PRTMP_ADAPTER pAd)
 {
-//	WPDMA_GLO_CFG_STRUC	GloCfg;
-//	ULONG	i = 0;
+//      WPDMA_GLO_CFG_STRUC     GloCfg;
+//      ULONG   i = 0;
 	UINT32 rx_filter_flag;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPEnableRxTx\n"));
@@ -3262,19 +3176,15 @@ VOID RTMPEnableRxTx(
 	RT28XXDMAEnable(pAd);
 
 	// enable RX of MAC block
-	if (pAd->OpMode == OPMODE_AP)
-	{
+	if (pAd->OpMode == OPMODE_AP) {
 		rx_filter_flag = APNORMAL;
 
-
-		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);     // enable RX of DMA block
-	}
-	else
-	{
+		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);	// enable RX of DMA block
+	} else {
 		if (pAd->CommonCfg.PSPXlink)
 			rx_filter_flag = PSPXLINK;
 		else
-			rx_filter_flag = STANORMAL;     // Staion not drop control frame will fail WiFi Certification.
+			rx_filter_flag = STANORMAL;	// Staion not drop control frame will fail WiFi Certification.
 		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);
 	}
 
@@ -3282,43 +3192,37 @@ VOID RTMPEnableRxTx(
 	DBGPRINT(RT_DEBUG_TRACE, ("<== RTMPEnableRxTx\n"));
 }
 
-
 //+++Add by shiang, move from os/linux/rt_main_dev.c
 void CfgInitHook(PRTMP_ADAPTER pAd)
 {
 	pAd->bBroadComHT = TRUE;
 }
 
-
-int rt28xx_init(
-	IN PRTMP_ADAPTER pAd,
-	IN PSTRING pDefaultMac,
-	IN PSTRING pHostName)
-{
-	UINT					index;
-	UCHAR					TmpPhy;
-	NDIS_STATUS				Status;
-	UINT32					MacCsr0 = 0;
-
+int rt28xx_init(IN PRTMP_ADAPTER pAd,
+		IN PSTRING pDefaultMac, IN PSTRING pHostName)
+{
+	UINT index;
+	UCHAR TmpPhy;
+	NDIS_STATUS Status;
+	UINT32 MacCsr0 = 0;
 
 #ifdef RTMP_MAC_PCI
 	{
-	// If dirver doesn't wake up firmware here,
-	// NICLoadFirmware will hang forever when interface is up again.
-	// RT2860 PCI
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE) &&
-		OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-	{
-		AUTO_WAKEUP_STRUC AutoWakeupCfg;
+		// If dirver doesn't wake up firmware here,
+		// NICLoadFirmware will hang forever when interface is up again.
+		// RT2860 PCI
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE) &&
+		    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
+			AUTO_WAKEUP_STRUC AutoWakeupCfg;
 			AsicForceWakeup(pAd, TRUE);
-		AutoWakeupCfg.word = 0;
-		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-	}
+			AutoWakeupCfg.word = 0;
+			RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG,
+					AutoWakeupCfg.word);
+			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
+		}
 	}
 #endif // RTMP_MAC_PCI //
 
-
 	// reset Adapter flags
 	RTMP_CLEAR_FLAGS(pAd);
 
@@ -3329,23 +3233,24 @@ int rt28xx_init(
 
 	// Make sure MAC gets ready.
 	index = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
 		pAd->MACVersion = MacCsr0;
 
-		if ((pAd->MACVersion != 0x00) && (pAd->MACVersion != 0xFFFFFFFF))
+		if ((pAd->MACVersion != 0x00)
+		    && (pAd->MACVersion != 0xFFFFFFFF))
 			break;
 
 		RTMPusecDelay(10);
 	} while (index++ < 100);
-	DBGPRINT(RT_DEBUG_TRACE, ("MAC_CSR0  [ Ver:Rev=0x%08x]\n", pAd->MACVersion));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("MAC_CSR0  [ Ver:Rev=0x%08x]\n", pAd->MACVersion));
 
 #ifdef RTMP_MAC_PCI
 #ifdef PCIE_PS_SUPPORT
 	/*Iverson patch PCIE L1 issue to make sure that driver can be read,write ,BBP and RF register  at pcie L.1 level */
-	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))&&OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-	{
+	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+	    && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
 		RTMP_IO_READ32(pAd, AUX_CTRL, &MacCsr0);
 		MacCsr0 |= 0x402;
 		RTMP_IO_WRITE32(pAd, AUX_CTRL, MacCsr0);
@@ -3360,12 +3265,11 @@ int rt28xx_init(
 	// Disable DMA
 	RT28XXDMADisable(pAd);
 
-
 	// Load 8051 firmware
 	Status = NICLoadFirmware(pAd);
-	if (Status != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT_ERR(("NICLoadFirmware failed, Status[=0x%08x]\n", Status));
+	if (Status != NDIS_STATUS_SUCCESS) {
+		DBGPRINT_ERR(("NICLoadFirmware failed, Status[=0x%08x]\n",
+			      Status));
 		goto err1;
 	}
 
@@ -3374,16 +3278,15 @@ int rt28xx_init(
 	// Disable interrupts here which is as soon as possible
 	// This statement should never be true. We might consider to remove it later
 #ifdef RTMP_MAC_PCI
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE))
-	{
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE)) {
 		RTMP_ASIC_INTERRUPT_DISABLE(pAd);
 	}
 #endif // RTMP_MAC_PCI //
 
 	Status = RTMPAllocTxRxRingMemory(pAd);
-	if (Status != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT_ERR(("RTMPAllocDMAMemory failed, Status[=0x%08x]\n", Status));
+	if (Status != NDIS_STATUS_SUCCESS) {
+		DBGPRINT_ERR(("RTMPAllocDMAMemory failed, Status[=0x%08x]\n",
+			      Status));
 		goto err1;
 	}
 
@@ -3397,12 +3300,10 @@ int rt28xx_init(
 		goto err2;
 
 	Status = MlmeInit(pAd);
-	if (Status != NDIS_STATUS_SUCCESS)
-	{
+	if (Status != NDIS_STATUS_SUCCESS) {
 		DBGPRINT_ERR(("MlmeInit failed, Status[=0x%08x]\n", Status));
 		goto err2;
 	}
-
 	// Initialize pAd->StaCfg, pAd->ApCfg, pAd->CommonCfg to manufacture default
 	//
 	UserCfgInit(pAd);
@@ -3410,12 +3311,12 @@ int rt28xx_init(
 	if (Status != NDIS_STATUS_SUCCESS)
 		goto err3;
 
-//	COPY_MAC_ADDR(pAd->ApCfg.MBSSID[apidx].Bssid, netif->hwaddr);
-//	pAd->bForcePrintTX = TRUE;
+//      COPY_MAC_ADDR(pAd->ApCfg.MBSSID[apidx].Bssid, netif->hwaddr);
+//      pAd->bForcePrintTX = TRUE;
 
 	CfgInitHook(pAd);
 
-		NdisAllocateSpinLock(&pAd->MacTabLock);
+	NdisAllocateSpinLock(&pAd->MacTabLock);
 
 	MeasureReqTabInit(pAd);
 	TpcReqTabInit(pAd);
@@ -3424,11 +3325,11 @@ int rt28xx_init(
 	// Init the hardware, we need to init asic before read registry, otherwise mac register will be reset
 	//
 	Status = NICInitializeAdapter(pAd, TRUE);
-	if (Status != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT_ERR(("NICInitializeAdapter failed, Status[=0x%08x]\n", Status));
+	if (Status != NDIS_STATUS_SUCCESS) {
+		DBGPRINT_ERR(("NICInitializeAdapter failed, Status[=0x%08x]\n",
+			      Status));
 		if (Status != NDIS_STATUS_SUCCESS)
-		goto err3;
+			goto err3;
 	}
 
 	DBGPRINT(RT_DEBUG_OFF, ("1. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
@@ -3443,15 +3344,22 @@ int rt28xx_init(
 #endif // RTMP_MAC_USB //
 
 	//Init Ba Capability parameters.
-//	RT28XX_BA_INIT(pAd);
-	pAd->CommonCfg.DesiredHtPhy.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
-	pAd->CommonCfg.DesiredHtPhy.AmsduEnable = (USHORT)pAd->CommonCfg.BACapability.field.AmsduEnable;
-	pAd->CommonCfg.DesiredHtPhy.AmsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
-	pAd->CommonCfg.DesiredHtPhy.MimoPs = (USHORT)pAd->CommonCfg.BACapability.field.MMPSmode;
+//      RT28XX_BA_INIT(pAd);
+	pAd->CommonCfg.DesiredHtPhy.MpduDensity =
+	    (UCHAR) pAd->CommonCfg.BACapability.field.MpduDensity;
+	pAd->CommonCfg.DesiredHtPhy.AmsduEnable =
+	    (USHORT) pAd->CommonCfg.BACapability.field.AmsduEnable;
+	pAd->CommonCfg.DesiredHtPhy.AmsduSize =
+	    (USHORT) pAd->CommonCfg.BACapability.field.AmsduSize;
+	pAd->CommonCfg.DesiredHtPhy.MimoPs =
+	    (USHORT) pAd->CommonCfg.BACapability.field.MMPSmode;
 	// UPdata to HT IE
-	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs = (USHORT)pAd->CommonCfg.BACapability.field.MMPSmode;
-	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
-	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
+	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs =
+	    (USHORT) pAd->CommonCfg.BACapability.field.MMPSmode;
+	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize =
+	    (USHORT) pAd->CommonCfg.BACapability.field.AmsduSize;
+	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity =
+	    (UCHAR) pAd->CommonCfg.BACapability.field.MpduDensity;
 
 	// after reading Registry, we now know if in AP mode or STA mode
 
@@ -3463,11 +3371,11 @@ int rt28xx_init(
 	DBGPRINT(RT_DEBUG_OFF, ("2. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
 
 	// We should read EEPROM for all cases.  rt2860b
-	NICReadEEPROMParameters(pAd, (PUCHAR)pDefaultMac);
+	NICReadEEPROMParameters(pAd, (PUCHAR) pDefaultMac);
 
 	DBGPRINT(RT_DEBUG_OFF, ("3. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
 
-	NICInitAsicFromEEPROM(pAd); //rt2860b
+	NICInitAsicFromEEPROM(pAd);	//rt2860b
 
 	// Set PHY to appropriate mode
 	TmpPhy = pAd->CommonCfg.PhyMode;
@@ -3476,25 +3384,28 @@ int rt28xx_init(
 	SetCommonHT(pAd);
 
 	// No valid channels.
-	if (pAd->ChannelListNum == 0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("Wrong configuration. No valid channel found. Check \"ContryCode\" and \"ChannelGeography\" setting.\n"));
+	if (pAd->ChannelListNum == 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("Wrong configuration. No valid channel found. Check \"ContryCode\" and \"ChannelGeography\" setting.\n"));
 		goto err4;
 	}
 
-	DBGPRINT(RT_DEBUG_OFF, ("MCS Set = %02x %02x %02x %02x %02x\n", pAd->CommonCfg.HtCapability.MCSSet[0],
-           pAd->CommonCfg.HtCapability.MCSSet[1], pAd->CommonCfg.HtCapability.MCSSet[2],
-           pAd->CommonCfg.HtCapability.MCSSet[3], pAd->CommonCfg.HtCapability.MCSSet[4]));
+	DBGPRINT(RT_DEBUG_OFF,
+		 ("MCS Set = %02x %02x %02x %02x %02x\n",
+		  pAd->CommonCfg.HtCapability.MCSSet[0],
+		  pAd->CommonCfg.HtCapability.MCSSet[1],
+		  pAd->CommonCfg.HtCapability.MCSSet[2],
+		  pAd->CommonCfg.HtCapability.MCSSet[3],
+		  pAd->CommonCfg.HtCapability.MCSSet[4]));
 
 #ifdef RTMP_RF_RW_SUPPORT
 	//Init RT30xx RFRegisters after read RFIC type from EEPROM
 	NICInitRFRegisters(pAd);
 #endif // RTMP_RF_RW_SUPPORT //
 
-//		APInitialize(pAd);
-
+//              APInitialize(pAd);
 
-		//
+	//
 	// Initialize RF register to default value
 	//
 	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
@@ -3504,26 +3415,23 @@ int rt28xx_init(
 	//2008/11/28:KH marked the following codes to patch Frequency offset bug
 	//AsicSendCommandToMcu(pAd, 0x72, 0xFF, 0x00, 0x00);
 
-	if (pAd && (Status != NDIS_STATUS_SUCCESS))
-	{
+	if (pAd && (Status != NDIS_STATUS_SUCCESS)) {
 		//
 		// Undo everything if it failed
 		//
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-		{
-//			NdisMDeregisterInterrupt(&pAd->Interrupt);
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+//                      NdisMDeregisterInterrupt(&pAd->Interrupt);
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
 		}
-//		RTMPFreeAdapter(pAd); // we will free it in disconnect()
-	}
-	else if (pAd)
-	{
+//              RTMPFreeAdapter(pAd); // we will free it in disconnect()
+	} else if (pAd) {
 		// Microsoft HCT require driver send a disconnect event after driver initialization.
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-//		pAd->IndicateMediaState = NdisMediaStateDisconnected;
+//              pAd->IndicateMediaState = NdisMediaStateDisconnected;
 		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_DISCONNECT Event B!\n"));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("NDIS_STATUS_MEDIA_DISCONNECT Event B!\n"));
 
 #ifdef RTMP_MAC_USB
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
@@ -3533,14 +3441,12 @@ int rt28xx_init(
 		// Support multiple BulkIn IRP,
 		// the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1.
 		//
-		for(index=0; index<pAd->CommonCfg.NumOfBulkInIRP; index++)
-		{
+		for (index = 0; index < pAd->CommonCfg.NumOfBulkInIRP; index++) {
 			RTUSBBulkReceive(pAd);
-			DBGPRINT(RT_DEBUG_TRACE, ("RTUSBBulkReceive!\n" ));
+			DBGPRINT(RT_DEBUG_TRACE, ("RTUSBBulkReceive!\n"));
 		}
 #endif // RTMP_MAC_USB //
-	}// end of else
-
+	}			// end of else
 
 	// Set up the Mac address
 	RtmpOSNetDevAddrSet(pAd->net_dev, &pAd->CurrentAddress[0]);
@@ -3549,7 +3455,6 @@ int rt28xx_init(
 
 	return TRUE;
 
-
 err4:
 err3:
 	MlmeHalt(pAd);
@@ -3557,7 +3462,7 @@ err2:
 	RTMPFreeTxRxRingMemory(pAd);
 err1:
 
-	os_free_mem(pAd, pAd->mpdu_blk_pool.mem); // free BA pool
+	os_free_mem(pAd, pAd->mpdu_blk_pool.mem);	// free BA pool
 
 	// shall not set priv to NULL here because the priv didn't been free yet.
 	//net_dev->ml_priv = 0;
@@ -3568,14 +3473,12 @@ err0:
 	DBGPRINT(RT_DEBUG_ERROR, ("!!! rt28xx Initialized fail !!!\n"));
 	return FALSE;
 }
-//---Add by shiang, move from os/linux/rt_main_dev.c
 
+//---Add by shiang, move from os/linux/rt_main_dev.c
 
-static INT RtmpChipOpsRegister(
-	IN RTMP_ADAPTER *pAd,
-	IN INT			infType)
+static INT RtmpChipOpsRegister(IN RTMP_ADAPTER * pAd, IN INT infType)
 {
-	RTMP_CHIP_OP	*pChipOps = &pAd->chipOps;
+	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
 	int status;
 
 	memset(pChipOps, 0, sizeof(RTMP_CHIP_OP));
@@ -3584,74 +3487,64 @@ static INT RtmpChipOpsRegister(
 	status = RtmpChipOpsEepromHook(pAd, infType);
 
 	/* set mcu related hook functions */
-	switch(infType)
-	{
+	switch (infType) {
 #ifdef RTMP_PCI_SUPPORT
-		case RTMP_DEV_INF_PCI:
-			pChipOps->loadFirmware = RtmpAsicLoadFirmware;
-			pChipOps->eraseFirmware = RtmpAsicEraseFirmware;
-			pChipOps->sendCommandToMcu = RtmpAsicSendCommandToMcu;
-			break;
+	case RTMP_DEV_INF_PCI:
+		pChipOps->loadFirmware = RtmpAsicLoadFirmware;
+		pChipOps->eraseFirmware = RtmpAsicEraseFirmware;
+		pChipOps->sendCommandToMcu = RtmpAsicSendCommandToMcu;
+		break;
 #endif // RTMP_PCI_SUPPORT //
 #ifdef RTMP_USB_SUPPORT
-		case RTMP_DEV_INF_USB:
-			pChipOps->loadFirmware = RtmpAsicLoadFirmware;
-			pChipOps->sendCommandToMcu = RtmpAsicSendCommandToMcu;
-			break;
+	case RTMP_DEV_INF_USB:
+		pChipOps->loadFirmware = RtmpAsicLoadFirmware;
+		pChipOps->sendCommandToMcu = RtmpAsicSendCommandToMcu;
+		break;
 #endif // RTMP_USB_SUPPORT //
-		default:
-			break;
+	default:
+		break;
 	}
 
 	return status;
 }
 
-
-INT RtmpRaDevCtrlInit(
-	IN RTMP_ADAPTER *pAd,
-	IN RTMP_INF_TYPE infType)
+INT RtmpRaDevCtrlInit(IN RTMP_ADAPTER * pAd, IN RTMP_INF_TYPE infType)
 {
-	//VOID	*handle;
+	//VOID  *handle;
 
 	// Assign the interface type. We need use it when do register/EEPROM access.
 	pAd->infType = infType;
 
-
 	pAd->OpMode = OPMODE_STA;
-	DBGPRINT(RT_DEBUG_TRACE, ("STA Driver version-%s\n", STA_DRIVER_VERSION));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("STA Driver version-%s\n", STA_DRIVER_VERSION));
 
 #ifdef RTMP_MAC_USB
 	init_MUTEX(&(pAd->UsbVendorReq_semaphore));
-	os_alloc_mem(pAd, (PUCHAR *)&pAd->UsbVendorReqBuf,
+	os_alloc_mem(pAd, (PUCHAR *) & pAd->UsbVendorReqBuf,
 		     MAX_PARAM_BUFFER_SIZE - 1);
-	if (pAd->UsbVendorReqBuf == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("Allocate vendor request temp buffer failed!\n"));
+	if (pAd->UsbVendorReqBuf == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("Allocate vendor request temp buffer failed!\n"));
 		return FALSE;
 	}
 #endif // RTMP_MAC_USB //
 
 	RtmpChipOpsRegister(pAd, infType);
 
-
 	return 0;
 }
 
-
-BOOLEAN RtmpRaDevCtrlExit(IN RTMP_ADAPTER *pAd)
+BOOLEAN RtmpRaDevCtrlExit(IN RTMP_ADAPTER * pAd)
 {
 
-
 	RTMPFreeAdapter(pAd);
 
 	return TRUE;
 }
 
-
 // not yet support MBSS
-PNET_DEV get_netdev_from_bssid(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			FromWhichBSSID)
+PNET_DEV get_netdev_from_bssid(IN PRTMP_ADAPTER pAd, IN UCHAR FromWhichBSSID)
 {
 	PNET_DEV dev_p = NULL;
 
@@ -3660,5 +3553,5 @@ PNET_DEV get_netdev_from_bssid(
 	}
 
 	ASSERT(dev_p);
-	return dev_p; /* return one of MBSS */
+	return dev_p;		/* return one of MBSS */
 }
--- a/drivers/staging/rt2860/common/rtmp_mcu.c
+++ b/drivers/staging/rt2860/common/rtmp_mcu.c
@@ -35,7 +35,6 @@
 	--------    ----------    ----------------------------------------------
 */
 
-
 #include	"../rt_config.h"
 
 #if defined(RT2860) || defined(RT3090)
@@ -83,12 +82,11 @@
 
 	========================================================================
 */
-INT RtmpAsicEraseFirmware(
-	IN PRTMP_ADAPTER pAd)
+INT RtmpAsicEraseFirmware(IN PRTMP_ADAPTER pAd)
 {
 	ULONG i;
 
-	for(i=0; i<MAX_FIRMWARE_IMAGE_SIZE; i+=4)
+	for (i = 0; i < MAX_FIRMWARE_IMAGE_SIZE; i += 4)
 		RTMP_IO_WRITE32(pAd, FIRMWARE_IMAGE_BASE + i, 0);
 
 	return 0;
@@ -111,16 +109,15 @@ INT RtmpAsicEraseFirmware(
 
 	========================================================================
 */
-NDIS_STATUS RtmpAsicLoadFirmware(
-	IN PRTMP_ADAPTER pAd)
+NDIS_STATUS RtmpAsicLoadFirmware(IN PRTMP_ADAPTER pAd)
 {
 
-	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
-	PUCHAR			pFirmwareImage = NULL;
-	ULONG			FileLength, Index;
-	UINT32			MacReg = 0;
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+	PUCHAR pFirmwareImage = NULL;
+	ULONG FileLength, Index;
+	UINT32 MacReg = 0;
 #ifdef RTMP_MAC_USB
-	UINT32			Version = (pAd->MACVersion >> 16);
+	UINT32 Version = (pAd->MACVersion >> 16);
 #endif
 
 	// New 8k byte firmware size for RT3071/RT3072
@@ -136,14 +133,13 @@ NDIS_STATUS RtmpAsicLoadFirmware(
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
 		/* the firmware image consists of two parts */
-		if ((Version != 0x2860) && (Version != 0x2872) && (Version != 0x3070))
-		{	/* use the second part */
+		if ((Version != 0x2860) && (Version != 0x2872) && (Version != 0x3070)) {	/* use the second part */
 			//printk("KH:Use New Version,part2\n");
-			pFirmwareImage = (PUCHAR)&FirmwareImage_3070[FIRMWAREIMAGEV1_LENGTH];
+			pFirmwareImage =
+			    (PUCHAR) &
+			    FirmwareImage_3070[FIRMWAREIMAGEV1_LENGTH];
 			FileLength = FIRMWAREIMAGEV2_LENGTH;
-		}
-		else
-		{
+		} else {
 			//printk("KH:Use New Version,part1\n");
 			if (Version == 0x3070)
 				pFirmwareImage = FirmwareImage_3070;
@@ -156,11 +152,9 @@ NDIS_STATUS RtmpAsicLoadFirmware(
 
 	RTMP_WRITE_FIRMWARE(pAd, pFirmwareImage, FileLength);
 
-
 	/* check if MCU is ready */
 	Index = 0;
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, PBF_SYS_CTRL, &MacReg);
 
 		if (MacReg & 0x80)
@@ -169,138 +163,124 @@ NDIS_STATUS RtmpAsicLoadFirmware(
 		RTMPusecDelay(1000);
 	} while (Index++ < 1000);
 
-	if (Index > 1000)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("NICLoadFirmware: MCU is not ready\n\n\n"));
+	if (Index > 1000) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("NICLoadFirmware: MCU is not ready\n\n\n"));
 		Status = NDIS_STATUS_FAILURE;
 	}
 
-    DBGPRINT(RT_DEBUG_TRACE, ("<=== %s (status=%d)\n", __func__, Status));
+	DBGPRINT(RT_DEBUG_TRACE, ("<=== %s (status=%d)\n", __func__, Status));
 
-    return Status;
+	return Status;
 }
 
-
-INT RtmpAsicSendCommandToMcu(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 Command,
-	IN UCHAR		 Token,
-	IN UCHAR		 Arg0,
-	IN UCHAR		 Arg1)
+INT RtmpAsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
+			     IN UCHAR Command,
+			     IN UCHAR Token, IN UCHAR Arg0, IN UCHAR Arg1)
 {
-	HOST_CMD_CSR_STRUC	H2MCmd;
-	H2M_MAILBOX_STRUC	H2MMailbox;
-	ULONG				i = 0;
+	HOST_CMD_CSR_STRUC H2MCmd;
+	H2M_MAILBOX_STRUC H2MMailbox;
+	ULONG i = 0;
 
 #ifdef PCIE_PS_SUPPORT
 	// 3090F power solution 3 has hw limitation that needs to ban all mcu command
 	// when firmware is in radio state.  For other chip doesn't have this limitation.
-	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
-		&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-		&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
-	{
+	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+	     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
+	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)) {
 		RTMP_SEM_LOCK(&pAd->McuCmdLock);
 		if ((pAd->brt30xxBanMcuCmd == TRUE)
-			&& (Command != WAKE_MCU_CMD) && (Command != RFOFF_MCU_CMD))
-		{
+		    && (Command != WAKE_MCU_CMD) && (Command != RFOFF_MCU_CMD)) {
 			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
-			DBGPRINT(RT_DEBUG_TRACE, (" Ban Mcu Cmd %x in sleep mode\n",  Command));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 (" Ban Mcu Cmd %x in sleep mode\n", Command));
 			return FALSE;
-		}
-		else if ((Command == SLEEP_MCU_CMD)
-			||(Command == RFOFF_MCU_CMD))
-		{
+		} else if ((Command == SLEEP_MCU_CMD)
+			   || (Command == RFOFF_MCU_CMD)) {
 			pAd->brt30xxBanMcuCmd = TRUE;
-		}
-		else if (Command != WAKE_MCU_CMD)
-		{
+		} else if (Command != WAKE_MCU_CMD) {
 			pAd->brt30xxBanMcuCmd = FALSE;
 		}
 
 		RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
 
 	}
-	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
-		&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-		&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-		&& (Command == WAKE_MCU_CMD))
-	{
-
-	do
-	{
-			RTMP_IO_FORCE_READ32(pAd, H2M_MAILBOX_CSR, &H2MMailbox.word);
+	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+	     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
+	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
+	    && (Command == WAKE_MCU_CMD)) {
+
+		do {
+			RTMP_IO_FORCE_READ32(pAd, H2M_MAILBOX_CSR,
+					     &H2MMailbox.word);
 			if (H2MMailbox.field.Owner == 0)
 				break;
 
 			RTMPusecDelay(2);
-			DBGPRINT(RT_DEBUG_INFO, ("AsicSendCommanToMcu::Mail box is busy\n"));
-		} while(i++ < 100);
+			DBGPRINT(RT_DEBUG_INFO,
+				 ("AsicSendCommanToMcu::Mail box is busy\n"));
+		} while (i++ < 100);
 
-		if (i >= 100)
-		{
+		if (i >= 100) {
 			DBGPRINT_ERR(("H2M_MAILBOX still hold by MCU. command fail\n"));
 			return FALSE;
 		}
 
-		H2MMailbox.field.Owner	  = 1;	   // pass ownership to MCU
+		H2MMailbox.field.Owner = 1;	// pass ownership to MCU
 		H2MMailbox.field.CmdToken = Token;
 		H2MMailbox.field.HighByte = Arg1;
-		H2MMailbox.field.LowByte  = Arg0;
+		H2MMailbox.field.LowByte = Arg0;
 		RTMP_IO_FORCE_WRITE32(pAd, H2M_MAILBOX_CSR, H2MMailbox.word);
 
-		H2MCmd.word			  = 0;
-		H2MCmd.field.HostCommand  = Command;
+		H2MCmd.word = 0;
+		H2MCmd.field.HostCommand = Command;
 		RTMP_IO_FORCE_WRITE32(pAd, HOST_CMD_CSR, H2MCmd.word);
 
-
-	}
-	else
+	} else
 #endif // PCIE_PS_SUPPORT //
 	{
-	do
-	{
-		RTMP_IO_READ32(pAd, H2M_MAILBOX_CSR, &H2MMailbox.word);
-		if (H2MMailbox.field.Owner == 0)
-			break;
+		do {
+			RTMP_IO_READ32(pAd, H2M_MAILBOX_CSR, &H2MMailbox.word);
+			if (H2MMailbox.field.Owner == 0)
+				break;
 
-		RTMPusecDelay(2);
-	} while(i++ < 100);
+			RTMPusecDelay(2);
+		} while (i++ < 100);
 
-	if (i > 100)
-	{
+		if (i > 100) {
 #ifdef RTMP_MAC_PCI
 #endif // RTMP_MAC_PCI //
-		{
-		DBGPRINT_ERR(("H2M_MAILBOX still hold by MCU. command fail\n"));
+			{
+				DBGPRINT_ERR(("H2M_MAILBOX still hold by MCU. command fail\n"));
+			}
+			return FALSE;
 		}
-		return FALSE;
-	}
-
 #ifdef RTMP_MAC_PCI
 #endif // RTMP_MAC_PCI //
 
-	H2MMailbox.field.Owner	  = 1;	   // pass ownership to MCU
-	H2MMailbox.field.CmdToken = Token;
-	H2MMailbox.field.HighByte = Arg1;
-	H2MMailbox.field.LowByte  = Arg0;
-	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CSR, H2MMailbox.word);
-
-	H2MCmd.word			  = 0;
-	H2MCmd.field.HostCommand  = Command;
-	RTMP_IO_WRITE32(pAd, HOST_CMD_CSR, H2MCmd.word);
+		H2MMailbox.field.Owner = 1;	// pass ownership to MCU
+		H2MMailbox.field.CmdToken = Token;
+		H2MMailbox.field.HighByte = Arg1;
+		H2MMailbox.field.LowByte = Arg0;
+		RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CSR, H2MMailbox.word);
 
-	if (Command != 0x80)
-	{
+		H2MCmd.word = 0;
+		H2MCmd.field.HostCommand = Command;
+		RTMP_IO_WRITE32(pAd, HOST_CMD_CSR, H2MCmd.word);
+
+		if (Command != 0x80) {
+		}
 	}
-}
 #ifdef PCIE_PS_SUPPORT
 	// 3090 MCU Wakeup command needs more time to be stable.
 	// Before stable, don't issue other MCU command to prevent from firmware error.
-	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
-		&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
-		&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
-		&& (Command == WAKE_MCU_CMD))
-	{
+	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
+	     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
+	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
+	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
+	    && (Command == WAKE_MCU_CMD)) {
 		RTMPusecDelay(2000);
 		//Put this is after RF programming.
 		//NdisAcquireSpinLock(&pAd->McuCmdLock);
--- a/drivers/staging/rt2860/common/rtmp_timer.c
+++ b/drivers/staging/rt2860/common/rtmp_timer.c
@@ -40,7 +40,6 @@
 
 #include "../rt_config.h"
 
-
 BUILD_TIMER_FUNCTION(MlmePeriodicExec);
 //BUILD_TIMER_FUNCTION(MlmeRssiReportExec);
 BUILD_TIMER_FUNCTION(AsicRxAntEvalTimeout);
@@ -68,30 +67,25 @@ BUILD_TIMER_FUNCTION(RtmpUsbStaAsicForce
 #endif // RTMP_MAC_USB //
 
 #if defined(AP_LED) || defined(STA_LED)
-extern void LedCtrlMain(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
+extern void LedCtrlMain(IN PVOID SystemSpecific1,
+			IN PVOID FunctionContext,
+			IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
 BUILD_TIMER_FUNCTION(LedCtrlMain);
 #endif
 
-
 #ifdef RTMP_TIMER_TASK_SUPPORT
-static void RtmpTimerQHandle(RTMP_ADAPTER *pAd)
+static void RtmpTimerQHandle(RTMP_ADAPTER * pAd)
 {
 #ifndef KTHREAD_SUPPORT
 	int status;
 #endif
-	RALINK_TIMER_STRUCT	*pTimer;
-	RTMP_TIMER_TASK_ENTRY	*pEntry;
-	unsigned long	irqFlag;
+	RALINK_TIMER_STRUCT *pTimer;
+	RTMP_TIMER_TASK_ENTRY *pEntry;
+	unsigned long irqFlag;
 	RTMP_OS_TASK *pTask;
 
-
 	pTask = &pAd->timerTask;
-	while(!pTask->task_killed)
-	{
+	while (!pTask->task_killed) {
 		pTimer = NULL;
 
 #ifdef KTHREAD_SUPPORT
@@ -104,12 +98,10 @@ static void RtmpTimerQHandle(RTMP_ADAPTE
 			break;
 
 		// event happened.
-		while(pAd->TimerQ.pQHead)
-		{
+		while (pAd->TimerQ.pQHead) {
 			RTMP_INT_LOCK(&pAd->TimerQLock, irqFlag);
 			pEntry = pAd->TimerQ.pQHead;
-			if (pEntry)
-			{
+			if (pEntry) {
 				pTimer = pEntry->pRaTimer;
 
 				// update pQHead
@@ -123,18 +115,21 @@ static void RtmpTimerQHandle(RTMP_ADAPTE
 			}
 			RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlag);
 
-			if (pTimer)
-			{
-				if ((pTimer->handle != NULL) && (!pAd->PM_FlgSuspend))
-					pTimer->handle(NULL, (PVOID) pTimer->cookie, NULL, pTimer);
-				if ((pTimer->Repeat) && (pTimer->State == FALSE))
-					RTMP_OS_Add_Timer(&pTimer->TimerObj, pTimer->TimerValue);
+			if (pTimer) {
+				if ((pTimer->handle != NULL)
+				    && (!pAd->PM_FlgSuspend))
+					pTimer->handle(NULL,
+						       (PVOID) pTimer->cookie,
+						       NULL, pTimer);
+				if ((pTimer->Repeat)
+				    && (pTimer->State == FALSE))
+					RTMP_OS_Add_Timer(&pTimer->TimerObj,
+							  pTimer->TimerValue);
 			}
 		}
 
 #ifndef KTHREAD_SUPPORT
-		if (status != 0)
-		{
+		if (status != 0) {
 			pAd->TimerQ.status = RTMP_TASK_STAT_STOPED;
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
 			break;
@@ -143,22 +138,19 @@ static void RtmpTimerQHandle(RTMP_ADAPTE
 	}
 }
 
-
-INT RtmpTimerQThread(
-	IN OUT PVOID Context)
+INT RtmpTimerQThread(IN OUT PVOID Context)
 {
-	RTMP_OS_TASK	*pTask;
-	PRTMP_ADAPTER	pAd;
-
+	RTMP_OS_TASK *pTask;
+	PRTMP_ADAPTER pAd;
 
-	pTask = (RTMP_OS_TASK *)Context;
-	pAd = (PRTMP_ADAPTER)pTask->priv;
+	pTask = (RTMP_OS_TASK *) Context;
+	pAd = (PRTMP_ADAPTER) pTask->priv;
 
 	RtmpOSTaskCustomize(pTask);
 
 	RtmpTimerQHandle(pAd);
 
-	DBGPRINT(RT_DEBUG_TRACE,( "<---%s\n",__func__));
+	DBGPRINT(RT_DEBUG_TRACE, ("<---%s\n", __func__));
 #ifndef KTHREAD_SUPPORT
 	pTask->taskPID = THREAD_PID_INIT_VALUE;
 #endif
@@ -182,20 +174,16 @@ INT RtmpTimerQThread(
 
 }
 
-
-RTMP_TIMER_TASK_ENTRY *RtmpTimerQInsert(
-	IN RTMP_ADAPTER *pAd,
-	IN RALINK_TIMER_STRUCT *pTimer)
+RTMP_TIMER_TASK_ENTRY *RtmpTimerQInsert(IN RTMP_ADAPTER * pAd,
+					IN RALINK_TIMER_STRUCT * pTimer)
 {
 	RTMP_TIMER_TASK_ENTRY *pQNode = NULL, *pQTail;
 	unsigned long irqFlags;
-	RTMP_OS_TASK	*pTask = &pAd->timerTask;
+	RTMP_OS_TASK *pTask = &pAd->timerTask;
 
 	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
-	if (pAd->TimerQ.status & RTMP_TASK_CAN_DO_INSERT)
-	{
-		if(pAd->TimerQ.pQPollFreeList)
-		{
+	if (pAd->TimerQ.status & RTMP_TASK_CAN_DO_INSERT) {
+		if (pAd->TimerQ.pQPollFreeList) {
 			pQNode = pAd->TimerQ.pQPollFreeList;
 			pAd->TimerQ.pQPollFreeList = pQNode->pNext;
 
@@ -212,8 +200,7 @@ RTMP_TIMER_TASK_ENTRY *RtmpTimerQInsert(
 	}
 	RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
 
-	if (pQNode)
-	{
+	if (pQNode) {
 #ifdef KTHREAD_SUPPORT
 		WAKE_UP(pTask);
 #else
@@ -224,20 +211,15 @@ RTMP_TIMER_TASK_ENTRY *RtmpTimerQInsert(
 	return pQNode;
 }
 
-
-BOOLEAN RtmpTimerQRemove(
-	IN RTMP_ADAPTER *pAd,
-	IN RALINK_TIMER_STRUCT *pTimer)
+BOOLEAN RtmpTimerQRemove(IN RTMP_ADAPTER * pAd, IN RALINK_TIMER_STRUCT * pTimer)
 {
 	RTMP_TIMER_TASK_ENTRY *pNode, *pPrev = NULL;
 	unsigned long irqFlags;
 
 	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
-	if (pAd->TimerQ.status >= RTMP_TASK_STAT_INITED)
-	{
+	if (pAd->TimerQ.status >= RTMP_TASK_STAT_INITED) {
 		pNode = pAd->TimerQ.pQHead;
-		while (pNode)
-		{
+		while (pNode) {
 			if (pNode->pRaTimer == pTimer)
 				break;
 			pPrev = pNode;
@@ -245,8 +227,7 @@ BOOLEAN RtmpTimerQRemove(
 		}
 
 		// Now move it to freeList queue.
-		if (pNode)
-		{
+		if (pNode) {
 			if (pNode == pAd->TimerQ.pQHead)
 				pAd->TimerQ.pQHead = pNode->pNext;
 			if (pNode == pAd->TimerQ.pQTail)
@@ -264,15 +245,13 @@ BOOLEAN RtmpTimerQRemove(
 	return TRUE;
 }
 
-
-void RtmpTimerQExit(RTMP_ADAPTER *pAd)
+void RtmpTimerQExit(RTMP_ADAPTER * pAd)
 {
 	RTMP_TIMER_TASK_ENTRY *pTimerQ;
 	unsigned long irqFlags;
 
 	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
-	while (pAd->TimerQ.pQHead)
-	{
+	while (pAd->TimerQ.pQHead) {
 		pTimerQ = pAd->TimerQ.pQHead;
 		pAd->TimerQ.pQHead = pTimerQ->pNext;
 		// remove the timeQ
@@ -288,10 +267,9 @@ void RtmpTimerQExit(RTMP_ADAPTER *pAd)
 
 }
 
-
-void RtmpTimerQInit(RTMP_ADAPTER *pAd)
+void RtmpTimerQInit(RTMP_ADAPTER * pAd)
 {
-	int	i;
+	int i;
 	RTMP_TIMER_TASK_ENTRY *pQNode, *pEntry;
 	unsigned long irqFlags;
 
@@ -299,16 +277,17 @@ void RtmpTimerQInit(RTMP_ADAPTER *pAd)
 
 	NdisZeroMemory(&pAd->TimerQ, sizeof(pAd->TimerQ));
 
-	os_alloc_mem(pAd, &pAd->TimerQ.pTimerQPoll, sizeof(RTMP_TIMER_TASK_ENTRY) * TIMER_QUEUE_SIZE_MAX);
-	if (pAd->TimerQ.pTimerQPoll)
-	{
+	os_alloc_mem(pAd, &pAd->TimerQ.pTimerQPoll,
+		     sizeof(RTMP_TIMER_TASK_ENTRY) * TIMER_QUEUE_SIZE_MAX);
+	if (pAd->TimerQ.pTimerQPoll) {
 		pEntry = NULL;
-		pQNode = (RTMP_TIMER_TASK_ENTRY *)pAd->TimerQ.pTimerQPoll;
-		NdisZeroMemory(pAd->TimerQ.pTimerQPoll, sizeof(RTMP_TIMER_TASK_ENTRY) * TIMER_QUEUE_SIZE_MAX);
+		pQNode = (RTMP_TIMER_TASK_ENTRY *) pAd->TimerQ.pTimerQPoll;
+		NdisZeroMemory(pAd->TimerQ.pTimerQPoll,
+			       sizeof(RTMP_TIMER_TASK_ENTRY) *
+			       TIMER_QUEUE_SIZE_MAX);
 
 		RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
-		for (i = 0 ;i <TIMER_QUEUE_SIZE_MAX; i++)
-		{
+		for (i = 0; i < TIMER_QUEUE_SIZE_MAX; i++) {
 			pQNode->pNext = pEntry;
 			pEntry = pQNode;
 			pQNode++;
--- a/drivers/staging/rt2860/common/rt_rf.c
+++ b/drivers/staging/rt2860/common/rt_rf.c
@@ -35,10 +35,8 @@
 	--------    ----------    ----------------------------------------------
 */
 
-
 #include "../rt_config.h"
 
-
 #ifdef RTMP_RF_RW_SUPPORT
 /*
 	========================================================================
@@ -55,27 +53,26 @@
 
 	========================================================================
 */
-NDIS_STATUS RT30xxWriteRFRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			regID,
-	IN	UCHAR			value)
+NDIS_STATUS RT30xxWriteRFRegister(IN PRTMP_ADAPTER pAd,
+				  IN UCHAR regID, IN UCHAR value)
 {
-	RF_CSR_CFG_STRUC	rfcsr;
-	UINT				i = 0;
+	RF_CSR_CFG_STRUC rfcsr;
+	UINT i = 0;
 
-	do
-	{
+	do {
 		RTMP_IO_READ32(pAd, RF_CSR_CFG, &rfcsr.word);
 
 		if (!rfcsr.field.RF_CSR_KICK)
 			break;
 		i++;
 	}
-	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+	while ((i < RETRY_LIMIT)
+	       && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
 
-	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Retry count exhausted or device removed!!!\n"));
+	if ((i == RETRY_LIMIT)
+	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     ("Retry count exhausted or device removed!!!\n"));
 		return STATUS_UNSUCCESSFUL;
 	}
 
@@ -89,7 +86,6 @@ NDIS_STATUS RT30xxWriteRFRegister(
 	return NDIS_STATUS_SUCCESS;
 }
 
-
 /*
 	========================================================================
 
@@ -105,20 +101,16 @@ NDIS_STATUS RT30xxWriteRFRegister(
 
 	========================================================================
 */
-NDIS_STATUS RT30xxReadRFRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			regID,
-	IN	PUCHAR			pValue)
+NDIS_STATUS RT30xxReadRFRegister(IN PRTMP_ADAPTER pAd,
+				 IN UCHAR regID, IN PUCHAR pValue)
 {
-	RF_CSR_CFG_STRUC	rfcsr;
-	UINT				i=0, k=0;
+	RF_CSR_CFG_STRUC rfcsr;
+	UINT i = 0, k = 0;
 
-	for (i=0; i<MAX_BUSY_COUNT; i++)
-	{
+	for (i = 0; i < MAX_BUSY_COUNT; i++) {
 		RTMP_IO_READ32(pAd, RF_CSR_CFG, &rfcsr.word);
 
-		if (rfcsr.field.RF_CSR_KICK == BUSY)
-		{
+		if (rfcsr.field.RF_CSR_KICK == BUSY) {
 			continue;
 		}
 		rfcsr.word = 0;
@@ -126,40 +118,34 @@ NDIS_STATUS RT30xxReadRFRegister(
 		rfcsr.field.RF_CSR_KICK = 1;
 		rfcsr.field.TESTCSR_RFACC_REGNUM = regID;
 		RTMP_IO_WRITE32(pAd, RF_CSR_CFG, rfcsr.word);
-		for (k=0; k<MAX_BUSY_COUNT; k++)
-		{
+		for (k = 0; k < MAX_BUSY_COUNT; k++) {
 			RTMP_IO_READ32(pAd, RF_CSR_CFG, &rfcsr.word);
 
 			if (rfcsr.field.RF_CSR_KICK == IDLE)
 				break;
 		}
 		if ((rfcsr.field.RF_CSR_KICK == IDLE) &&
-			(rfcsr.field.TESTCSR_RFACC_REGNUM == regID))
-		{
-			*pValue = (UCHAR)rfcsr.field.RF_CSR_DATA;
+		    (rfcsr.field.TESTCSR_RFACC_REGNUM == regID)) {
+			*pValue = (UCHAR) rfcsr.field.RF_CSR_DATA;
 			break;
 		}
 	}
-	if (rfcsr.field.RF_CSR_KICK == BUSY)
-	{
-		DBGPRINT_ERR(("RF read R%d=0x%x fail, i[%d], k[%d]\n", regID, rfcsr.word,i,k));
+	if (rfcsr.field.RF_CSR_KICK == BUSY) {
+		DBGPRINT_ERR(("RF read R%d=0x%x fail, i[%d], k[%d]\n", regID,
+			      rfcsr.word, i, k));
 		return STATUS_UNSUCCESSFUL;
 	}
 
 	return STATUS_SUCCESS;
 }
 
-
-VOID NICInitRFRegisters(
-	IN RTMP_ADAPTER *pAd)
+VOID NICInitRFRegisters(IN RTMP_ADAPTER * pAd)
 {
 	if (pAd->chipOps.AsicRfInit)
 		pAd->chipOps.AsicRfInit(pAd);
 }
 
-
-VOID RtmpChipOpsRFHook(
-	IN RTMP_ADAPTER *pAd)
+VOID RtmpChipOpsRFHook(IN RTMP_ADAPTER * pAd)
 {
 	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
 
@@ -172,27 +158,27 @@ VOID RtmpChipOpsRFHook(
 	/* We depends on RfICType and MACVersion to assign the corresponding operation callbacks. */
 
 #ifdef RT30xx
-	if (IS_RT30xx(pAd))
-	{
+	if (IS_RT30xx(pAd)) {
 		pChipOps->pRFRegTable = RT30xx_RFRegTable;
 		pChipOps->AsicHaltAction = RT30xxHaltAction;
 #ifdef RT3070
-		if((IS_RT3070(pAd) || IS_RT3071(pAd)) && (pAd->infType == RTMP_DEV_INF_USB))
-		{
+		if ((IS_RT3070(pAd) || IS_RT3071(pAd))
+		    && (pAd->infType == RTMP_DEV_INF_USB)) {
 			pChipOps->AsicRfInit = NICInitRT3070RFRegisters;
-			if (IS_RT3071(pAd))
-			{
-				pChipOps->AsicRfTurnOff = RT30xxLoadRFSleepModeSetup;
-				pChipOps->AsicReverseRfFromSleepMode = RT30xxReverseRFSleepModeSetup;
+			if (IS_RT3071(pAd)) {
+				pChipOps->AsicRfTurnOff =
+				    RT30xxLoadRFSleepModeSetup;
+				pChipOps->AsicReverseRfFromSleepMode =
+				    RT30xxReverseRFSleepModeSetup;
 			}
 		}
 #endif // RT3070 //
 #ifdef RT3090
-		if (IS_RT3090(pAd) && (pAd->infType == RTMP_DEV_INF_PCI))
-		{
+		if (IS_RT3090(pAd) && (pAd->infType == RTMP_DEV_INF_PCI)) {
 			pChipOps->AsicRfTurnOff = RT30xxLoadRFSleepModeSetup;
 			pChipOps->AsicRfInit = NICInitRT3090RFRegisters;
-			pChipOps->AsicReverseRfFromSleepMode = RT30xxReverseRFSleepModeSetup;
+			pChipOps->AsicReverseRfFromSleepMode =
+			    RT30xxReverseRFSleepModeSetup;
 		}
 #endif // RT3090 //
 	}
--- a/drivers/staging/rt2860/common/spectrum.c
+++ b/drivers/staging/rt2860/common/spectrum.c
@@ -24,7 +24,6 @@
  *                                                                       *
  *************************************************************************
 
-
     Module Name:
 	action.c
 
@@ -40,94 +39,237 @@
 #include "../rt_config.h"
 #include "action.h"
 
-
 /* The regulatory information in the USA (US) */
-DOT11_REGULATORY_INFORMATION USARegulatoryInfo[] =
-{
+DOT11_REGULATORY_INFORMATION USARegulatoryInfo[] = {
 /*  "regulatory class"  "number of channels"  "Max Tx Pwr"  "channel list" */
-    {0,	                {0,                   0,           {0}}}, // Invlid entry
-    {1,                 {4,                   16,           {36, 40, 44, 48}}},
-    {2,                 {4,                   23,           {52, 56, 60, 64}}},
-    {3,                 {4,                   29,           {149, 153, 157, 161}}},
-    {4,                 {11,                  23,           {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}}},
-    {5,                 {5,                   30,           {149, 153, 157, 161, 165}}},
-    {6,                 {10,                  14,           {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}}},
-    {7,                 {10,                  27,           {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}}},
-    {8,                 {5,                   17,           {11, 13, 15, 17, 19}}},
-    {9,                 {5,                   30,           {11, 13, 15, 17, 19}}},
-    {10,                {2,                   20,           {21, 25}}},
-    {11,                {2,                   33,            {21, 25}}},
-    {12,                {11,                  30,            {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}}}
+	{0, {0, 0, {0}
+	     }
+	 }
+	,			// Invlid entry
+	{1, {4, 16, {36, 40, 44, 48}
+	     }
+	 }
+	,
+	{2, {4, 23, {52, 56, 60, 64}
+	     }
+	 }
+	,
+	{3, {4, 29, {149, 153, 157, 161}
+	     }
+	 }
+	,
+	{4, {11, 23, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}
+	     }
+	 }
+	,
+	{5, {5, 30, {149, 153, 157, 161, 165}
+	     }
+	 }
+	,
+	{6, {10, 14, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
+	     }
+	 }
+	,
+	{7, {10, 27, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
+	     }
+	 }
+	,
+	{8, {5, 17, {11, 13, 15, 17, 19}
+	     }
+	 }
+	,
+	{9, {5, 30, {11, 13, 15, 17, 19}
+	     }
+	 }
+	,
+	{10, {2, 20, {21, 25}
+	      }
+	 }
+	,
+	{11, {2, 33, {21, 25}
+	      }
+	 }
+	,
+	{12, {11, 30, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
+	      }
+	 }
 };
-#define USA_REGULATORY_INFO_SIZE (sizeof(USARegulatoryInfo) / sizeof(DOT11_REGULATORY_INFORMATION))
 
+#define USA_REGULATORY_INFO_SIZE (sizeof(USARegulatoryInfo) / sizeof(DOT11_REGULATORY_INFORMATION))
 
 /* The regulatory information in Europe */
-DOT11_REGULATORY_INFORMATION EuropeRegulatoryInfo[] =
-{
+DOT11_REGULATORY_INFORMATION EuropeRegulatoryInfo[] = {
 /*  "regulatory class"  "number of channels"  "Max Tx Pwr"  "channel list" */
-    {0,                 {0,                   0,           {0}}}, // Invalid entry
-    {1,                 {4,                   20,           {36, 40, 44, 48}}},
-    {2,                 {4,                   20,           {52, 56, 60, 64}}},
-    {3,                 {11,                  30,           {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}}},
-    {4,                 {13,                  20,           {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}}}
+	{0, {0, 0, {0}
+	     }
+	 }
+	,			// Invalid entry
+	{1, {4, 20, {36, 40, 44, 48}
+	     }
+	 }
+	,
+	{2, {4, 20, {52, 56, 60, 64}
+	     }
+	 }
+	,
+	{3, {11, 30, {100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}
+	     }
+	 }
+	,
+	{4, {13, 20, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}
+	     }
+	 }
 };
-#define EU_REGULATORY_INFO_SIZE (sizeof(EuropeRegulatoryInfo) / sizeof(DOT11_REGULATORY_INFORMATION))
 
+#define EU_REGULATORY_INFO_SIZE (sizeof(EuropeRegulatoryInfo) / sizeof(DOT11_REGULATORY_INFORMATION))
 
 /* The regulatory information in Japan */
-DOT11_REGULATORY_INFORMATION JapanRegulatoryInfo[] =
-{
+DOT11_REGULATORY_INFORMATION JapanRegulatoryInfo[] = {
 /*  "regulatory class"  "number of channels"  "Max Tx Pwr"  "channel list" */
-    {0,                 {0,                   0,           {0}}}, // Invalid entry
-    {1,                 {4,                   22,           {34, 38, 42, 46}}},
-    {2,                 {3,                   24,           {8, 12, 16}}},
-    {3,                 {3,                   24,           {8, 12, 16}}},
-    {4,                 {3,                   24,           {8, 12, 16}}},
-    {5,                 {3,                   24,           {8, 12, 16}}},
-    {6,                 {3,                   22,           {8, 12, 16}}},
-    {7,                 {4,                   24,           {184, 188, 192, 196}}},
-    {8,                 {4,                   24,           {184, 188, 192, 196}}},
-    {9,                 {4,                   24,           {184, 188, 192, 196}}},
-    {10,                {4,                   24,           {184, 188, 192, 196}}},
-    {11,                {4,                   22,           {184, 188, 192, 196}}},
-    {12,                {4,                   24,           {7, 8, 9, 11}}},
-    {13,                {4,                   24,           {7, 8, 9, 11}}},
-    {14,                {4,                   24,           {7, 8, 9, 11}}},
-    {15,                {4,                   24,           {7, 8, 9, 11}}},
-    {16,                {6,                   24,           {183, 184, 185, 187, 188, 189}}},
-    {17,                {6,                   24,           {183, 184, 185, 187, 188, 189}}},
-    {18,                {6,                   24,           {183, 184, 185, 187, 188, 189}}},
-    {19,                {6,                   24,           {183, 184, 185, 187, 188, 189}}},
-    {20,                {6,                   17,           {183, 184, 185, 187, 188, 189}}},
-    {21,                {6,                   24,           {6, 7, 8, 9, 10, 11}}},
-    {22,                {6,                   24,           {6, 7, 8, 9, 10, 11}}},
-    {23,                {6,                   24,           {6, 7, 8, 9, 10, 11}}},
-    {24,                {6,                   24,           {6, 7, 8, 9, 10, 11}}},
-    {25,                {8,                   24,           {182, 183, 184, 185, 186, 187, 188, 189}}},
-    {26,                {8,                   24,           {182, 183, 184, 185, 186, 187, 188, 189}}},
-    {27,                {8,                   24,           {182, 183, 184, 185, 186, 187, 188, 189}}},
-    {28,                {8,                   24,           {182, 183, 184, 185, 186, 187, 188, 189}}},
-    {29,                {8,                   17,           {182, 183, 184, 185, 186, 187, 188, 189}}},
-    {30,                {13,                  23,           {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}}},
-    {31,                {1,                   23,           {14}}},
-    {32,                {4,                   22,           {52, 56, 60, 64}}}
+	{0, {0, 0, {0}
+	     }
+	 }
+	,			// Invalid entry
+	{1, {4, 22, {34, 38, 42, 46}
+	     }
+	 }
+	,
+	{2, {3, 24, {8, 12, 16}
+	     }
+	 }
+	,
+	{3, {3, 24, {8, 12, 16}
+	     }
+	 }
+	,
+	{4, {3, 24, {8, 12, 16}
+	     }
+	 }
+	,
+	{5, {3, 24, {8, 12, 16}
+	     }
+	 }
+	,
+	{6, {3, 22, {8, 12, 16}
+	     }
+	 }
+	,
+	{7, {4, 24, {184, 188, 192, 196}
+	     }
+	 }
+	,
+	{8, {4, 24, {184, 188, 192, 196}
+	     }
+	 }
+	,
+	{9, {4, 24, {184, 188, 192, 196}
+	     }
+	 }
+	,
+	{10, {4, 24, {184, 188, 192, 196}
+	      }
+	 }
+	,
+	{11, {4, 22, {184, 188, 192, 196}
+	      }
+	 }
+	,
+	{12, {4, 24, {7, 8, 9, 11}
+	      }
+	 }
+	,
+	{13, {4, 24, {7, 8, 9, 11}
+	      }
+	 }
+	,
+	{14, {4, 24, {7, 8, 9, 11}
+	      }
+	 }
+	,
+	{15, {4, 24, {7, 8, 9, 11}
+	      }
+	 }
+	,
+	{16, {6, 24, {183, 184, 185, 187, 188, 189}
+	      }
+	 }
+	,
+	{17, {6, 24, {183, 184, 185, 187, 188, 189}
+	      }
+	 }
+	,
+	{18, {6, 24, {183, 184, 185, 187, 188, 189}
+	      }
+	 }
+	,
+	{19, {6, 24, {183, 184, 185, 187, 188, 189}
+	      }
+	 }
+	,
+	{20, {6, 17, {183, 184, 185, 187, 188, 189}
+	      }
+	 }
+	,
+	{21, {6, 24, {6, 7, 8, 9, 10, 11}
+	      }
+	 }
+	,
+	{22, {6, 24, {6, 7, 8, 9, 10, 11}
+	      }
+	 }
+	,
+	{23, {6, 24, {6, 7, 8, 9, 10, 11}
+	      }
+	 }
+	,
+	{24, {6, 24, {6, 7, 8, 9, 10, 11}
+	      }
+	 }
+	,
+	{25, {8, 24, {182, 183, 184, 185, 186, 187, 188, 189}
+	      }
+	 }
+	,
+	{26, {8, 24, {182, 183, 184, 185, 186, 187, 188, 189}
+	      }
+	 }
+	,
+	{27, {8, 24, {182, 183, 184, 185, 186, 187, 188, 189}
+	      }
+	 }
+	,
+	{28, {8, 24, {182, 183, 184, 185, 186, 187, 188, 189}
+	      }
+	 }
+	,
+	{29, {8, 17, {182, 183, 184, 185, 186, 187, 188, 189}
+	      }
+	 }
+	,
+	{30, {13, 23, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}
+	      }
+	 }
+	,
+	{31, {1, 23, {14}
+	      }
+	 }
+	,
+	{32, {4, 22, {52, 56, 60, 64}
+	      }
+	 }
 };
-#define JP_REGULATORY_INFO_SIZE (sizeof(JapanRegulatoryInfo) / sizeof(DOT11_REGULATORY_INFORMATION))
 
+#define JP_REGULATORY_INFO_SIZE (sizeof(JapanRegulatoryInfo) / sizeof(DOT11_REGULATORY_INFORMATION))
 
-CHAR RTMP_GetTxPwr(
-	IN PRTMP_ADAPTER pAd,
-	IN HTTRANSMIT_SETTING HTTxMode)
-{
-typedef struct __TX_PWR_CFG
-{
-	UINT8 Mode;
-	UINT8 MCS;
-	UINT16 req;
-	UINT8 shift;
-	UINT32 BitMask;
-} TX_PWR_CFG;
+CHAR RTMP_GetTxPwr(IN PRTMP_ADAPTER pAd, IN HTTRANSMIT_SETTING HTTxMode)
+{
+	typedef struct __TX_PWR_CFG {
+		UINT8 Mode;
+		UINT8 MCS;
+		UINT16 req;
+		UINT8 shift;
+		UINT32 BitMask;
+	} TX_PWR_CFG;
 
 	UINT32 Value;
 	INT Idx;
@@ -137,7 +279,6 @@ typedef struct __TX_PWR_CFG
 	CHAR DaltaPwr;
 	ULONG TxPwr[5];
 
-
 	TX_PWR_CFG TxPwrCfg[] = {
 		{MODE_CCK, 0, 0, 4, 0x000000f0},
 		{MODE_CCK, 1, 0, 0, 0x0000000f},
@@ -152,7 +293,7 @@ typedef struct __TX_PWR_CFG
 		{MODE_OFDM, 5, 1, 0, 0x0000000f},
 		{MODE_OFDM, 6, 1, 12, 0x0000f000},
 		{MODE_OFDM, 7, 1, 8, 0x00000f00}
-		,{MODE_HTMIX, 0, 1, 20, 0x00f00000},
+		, {MODE_HTMIX, 0, 1, 20, 0x00f00000},
 		{MODE_HTMIX, 1, 1, 16, 0x000f0000},
 		{MODE_HTMIX, 2, 1, 28, 0xf0000000},
 		{MODE_HTMIX, 3, 1, 24, 0x0f000000},
@@ -174,50 +315,40 @@ typedef struct __TX_PWR_CFG
 	CurTxPwr = 19;
 
 	/* check Tx Power setting from UI. */
-	if (pAd->CommonCfg.TxPowerPercentage > 90)
-		;
-	else if (pAd->CommonCfg.TxPowerPercentage > 60)  /* reduce Pwr for 1 dB. */
+	if (pAd->CommonCfg.TxPowerPercentage > 90) ;
+	else if (pAd->CommonCfg.TxPowerPercentage > 60)	/* reduce Pwr for 1 dB. */
 		CurTxPwr -= 1;
-	else if (pAd->CommonCfg.TxPowerPercentage > 30)  /* reduce Pwr for 3 dB. */
+	else if (pAd->CommonCfg.TxPowerPercentage > 30)	/* reduce Pwr for 3 dB. */
 		CurTxPwr -= 3;
-	else if (pAd->CommonCfg.TxPowerPercentage > 15)  /* reduce Pwr for 6 dB. */
+	else if (pAd->CommonCfg.TxPowerPercentage > 15)	/* reduce Pwr for 6 dB. */
 		CurTxPwr -= 6;
-	else if (pAd->CommonCfg.TxPowerPercentage > 9)   /* reduce Pwr for 9 dB. */
+	else if (pAd->CommonCfg.TxPowerPercentage > 9)	/* reduce Pwr for 9 dB. */
 		CurTxPwr -= 9;
-	else                                           /* reduce Pwr for 12 dB. */
+	else			/* reduce Pwr for 12 dB. */
 		CurTxPwr -= 12;
 
-	if (pAd->CommonCfg.BBPCurrentBW == BW_40)
-	{
-		if (pAd->CommonCfg.CentralChannel > 14)
-		{
+	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
+		if (pAd->CommonCfg.CentralChannel > 14) {
 			TxPwr[0] = pAd->Tx40MPwrCfgABand[0];
 			TxPwr[1] = pAd->Tx40MPwrCfgABand[1];
 			TxPwr[2] = pAd->Tx40MPwrCfgABand[2];
 			TxPwr[3] = pAd->Tx40MPwrCfgABand[3];
 			TxPwr[4] = pAd->Tx40MPwrCfgABand[4];
-		}
-		else
-		{
+		} else {
 			TxPwr[0] = pAd->Tx40MPwrCfgGBand[0];
 			TxPwr[1] = pAd->Tx40MPwrCfgGBand[1];
 			TxPwr[2] = pAd->Tx40MPwrCfgGBand[2];
 			TxPwr[3] = pAd->Tx40MPwrCfgGBand[3];
 			TxPwr[4] = pAd->Tx40MPwrCfgGBand[4];
 		}
-	}
-	else
-	{
-		if (pAd->CommonCfg.Channel > 14)
-		{
+	} else {
+		if (pAd->CommonCfg.Channel > 14) {
 			TxPwr[0] = pAd->Tx20MPwrCfgABand[0];
 			TxPwr[1] = pAd->Tx20MPwrCfgABand[1];
 			TxPwr[2] = pAd->Tx20MPwrCfgABand[2];
 			TxPwr[3] = pAd->Tx20MPwrCfgABand[3];
 			TxPwr[4] = pAd->Tx20MPwrCfgABand[4];
-		}
-		else
-		{
+		} else {
 			TxPwr[0] = pAd->Tx20MPwrCfgGBand[0];
 			TxPwr[1] = pAd->Tx20MPwrCfgGBand[1];
 			TxPwr[2] = pAd->Tx20MPwrCfgGBand[2];
@@ -226,44 +357,36 @@ typedef struct __TX_PWR_CFG
 		}
 	}
 
-
-	switch(HTTxMode.field.MODE)
-	{
-		case MODE_CCK:
-		case MODE_OFDM:
-			Value = TxPwr[1];
+	switch (HTTxMode.field.MODE) {
+	case MODE_CCK:
+	case MODE_OFDM:
+		Value = TxPwr[1];
+		TxPwrRef = (Value & 0x00000f00) >> 8;
+
+		break;
+
+	case MODE_HTMIX:
+	case MODE_HTGREENFIELD:
+		if (pAd->CommonCfg.TxStream == 1) {
+			Value = TxPwr[2];
 			TxPwrRef = (Value & 0x00000f00) >> 8;
-
-			break;
-
-		case MODE_HTMIX:
-		case MODE_HTGREENFIELD:
-			if (pAd->CommonCfg.TxStream == 1)
-			{
-				Value = TxPwr[2];
-				TxPwrRef = (Value & 0x00000f00) >> 8;
-			}
-			else if (pAd->CommonCfg.TxStream == 2)
-			{
-				Value = TxPwr[3];
-				TxPwrRef = (Value & 0x00000f00) >> 8;
-			}
-			break;
+		} else if (pAd->CommonCfg.TxStream == 2) {
+			Value = TxPwr[3];
+			TxPwrRef = (Value & 0x00000f00) >> 8;
+		}
+		break;
 	}
 
-	PhyMode =
-				(HTTxMode.field.MODE == MODE_HTGREENFIELD)
-				? MODE_HTMIX :
-				HTTxMode.field.MODE;
+	PhyMode = (HTTxMode.field.MODE == MODE_HTGREENFIELD)
+	    ? MODE_HTMIX : HTTxMode.field.MODE;
 
-	for (Idx = 0; Idx < MAX_TXPWR_TAB_SIZE; Idx++)
-	{
+	for (Idx = 0; Idx < MAX_TXPWR_TAB_SIZE; Idx++) {
 		if ((TxPwrCfg[Idx].Mode == PhyMode)
-			&& (TxPwrCfg[Idx].MCS == HTTxMode.field.MCS))
-		{
+		    && (TxPwrCfg[Idx].MCS == HTTxMode.field.MCS)) {
 			Value = TxPwr[TxPwrCfg[Idx].req];
-			DaltaPwr = TxPwrRef - (CHAR)((Value & TxPwrCfg[Idx].BitMask)
-											>> TxPwrCfg[Idx].shift);
+			DaltaPwr =
+			    TxPwrRef - (CHAR) ((Value & TxPwrCfg[Idx].BitMask)
+					       >> TxPwrCfg[Idx].shift);
 			CurTxPwr -= DaltaPwr;
 			break;
 		}
@@ -272,23 +395,24 @@ typedef struct __TX_PWR_CFG
 	return CurTxPwr;
 }
 
-
-VOID MeasureReqTabInit(
-	IN PRTMP_ADAPTER pAd)
+VOID MeasureReqTabInit(IN PRTMP_ADAPTER pAd)
 {
 	NdisAllocateSpinLock(&pAd->CommonCfg.MeasureReqTabLock);
 
-	pAd->CommonCfg.pMeasureReqTab = kmalloc(sizeof(MEASURE_REQ_TAB), GFP_ATOMIC);
+	pAd->CommonCfg.pMeasureReqTab =
+	    kmalloc(sizeof(MEASURE_REQ_TAB), GFP_ATOMIC);
 	if (pAd->CommonCfg.pMeasureReqTab)
-		NdisZeroMemory(pAd->CommonCfg.pMeasureReqTab, sizeof(MEASURE_REQ_TAB));
+		NdisZeroMemory(pAd->CommonCfg.pMeasureReqTab,
+			       sizeof(MEASURE_REQ_TAB));
 	else
-		DBGPRINT(RT_DEBUG_ERROR, ("%s Fail to alloc memory for pAd->CommonCfg.pMeasureReqTab.\n", __func__));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s Fail to alloc memory for pAd->CommonCfg.pMeasureReqTab.\n",
+			  __func__));
 
 	return;
 }
 
-VOID MeasureReqTabExit(
-	IN PRTMP_ADAPTER pAd)
+VOID MeasureReqTabExit(IN PRTMP_ADAPTER pAd)
 {
 	NdisFreeSpinLock(&pAd->CommonCfg.MeasureReqTabLock);
 
@@ -299,18 +423,16 @@ VOID MeasureReqTabExit(
 	return;
 }
 
-PMEASURE_REQ_ENTRY MeasureReqLookUp(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken)
+PMEASURE_REQ_ENTRY MeasureReqLookUp(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 {
 	UINT HashIdx;
 	PMEASURE_REQ_TAB pTab = pAd->CommonCfg.pMeasureReqTab;
 	PMEASURE_REQ_ENTRY pEntry = NULL;
 	PMEASURE_REQ_ENTRY pPrevEntry = NULL;
 
-	if (pTab == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: pMeasureReqTab doesn't exist.\n", __func__));
+	if (pTab == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: pMeasureReqTab doesn't exist.\n", __func__));
 		return NULL;
 	}
 
@@ -319,12 +441,10 @@ PMEASURE_REQ_ENTRY MeasureReqLookUp(
 	HashIdx = MQ_DIALOGTOKEN_HASH_INDEX(DialogToken);
 	pEntry = pTab->Hash[HashIdx];
 
-	while (pEntry)
-	{
+	while (pEntry) {
 		if (pEntry->DialogToken == DialogToken)
 			break;
-		else
-		{
+		else {
 			pPrevEntry = pEntry;
 			pEntry = pEntry->pNext;
 		}
@@ -335,9 +455,7 @@ PMEASURE_REQ_ENTRY MeasureReqLookUp(
 	return pEntry;
 }
 
-PMEASURE_REQ_ENTRY MeasureReqInsert(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken)
+PMEASURE_REQ_ENTRY MeasureReqInsert(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 {
 	INT i;
 	ULONG HashIdx;
@@ -345,40 +463,41 @@ PMEASURE_REQ_ENTRY MeasureReqInsert(
 	PMEASURE_REQ_ENTRY pEntry = NULL, pCurrEntry;
 	ULONG Now;
 
-	if(pTab == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: pMeasureReqTab doesn't exist.\n", __func__));
+	if (pTab == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: pMeasureReqTab doesn't exist.\n", __func__));
 		return NULL;
 	}
 
 	pEntry = MeasureReqLookUp(pAd, DialogToken);
-	if (pEntry == NULL)
-	{
+	if (pEntry == NULL) {
 		RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
-		for (i = 0; i < MAX_MEASURE_REQ_TAB_SIZE; i++)
-		{
+		for (i = 0; i < MAX_MEASURE_REQ_TAB_SIZE; i++) {
 			NdisGetSystemUpTime(&Now);
 			pEntry = &pTab->Content[i];
 
 			if ((pEntry->Valid == TRUE)
-				&& RTMP_TIME_AFTER((unsigned long)Now, (unsigned long)(pEntry->lastTime + MQ_REQ_AGE_OUT)))
+			    && RTMP_TIME_AFTER((unsigned long)Now,
+					       (unsigned long)(pEntry->
+							       lastTime +
+							       MQ_REQ_AGE_OUT)))
 			{
 				PMEASURE_REQ_ENTRY pPrevEntry = NULL;
-				ULONG HashIdx = MQ_DIALOGTOKEN_HASH_INDEX(pEntry->DialogToken);
-				PMEASURE_REQ_ENTRY pProbeEntry = pTab->Hash[HashIdx];
+				ULONG HashIdx =
+				    MQ_DIALOGTOKEN_HASH_INDEX(pEntry->
+							      DialogToken);
+				PMEASURE_REQ_ENTRY pProbeEntry =
+				    pTab->Hash[HashIdx];
 
 				// update Hash list
-				do
-				{
-					if (pProbeEntry == pEntry)
-					{
-						if (pPrevEntry == NULL)
-						{
-							pTab->Hash[HashIdx] = pEntry->pNext;
-						}
-						else
-						{
-							pPrevEntry->pNext = pEntry->pNext;
+				do {
+					if (pProbeEntry == pEntry) {
+						if (pPrevEntry == NULL) {
+							pTab->Hash[HashIdx] =
+							    pEntry->pNext;
+						} else {
+							pPrevEntry->pNext =
+							    pEntry->pNext;
 						}
 						break;
 					}
@@ -387,7 +506,8 @@ PMEASURE_REQ_ENTRY MeasureReqInsert(
 					pProbeEntry = pProbeEntry->pNext;
 				} while (pProbeEntry);
 
-				NdisZeroMemory(pEntry, sizeof(MEASURE_REQ_ENTRY));
+				NdisZeroMemory(pEntry,
+					       sizeof(MEASURE_REQ_ENTRY));
 				pTab->Size--;
 
 				break;
@@ -397,30 +517,24 @@ PMEASURE_REQ_ENTRY MeasureReqInsert(
 				break;
 		}
 
-		if (i < MAX_MEASURE_REQ_TAB_SIZE)
-		{
+		if (i < MAX_MEASURE_REQ_TAB_SIZE) {
 			NdisGetSystemUpTime(&Now);
 			pEntry->lastTime = Now;
 			pEntry->Valid = TRUE;
 			pEntry->DialogToken = DialogToken;
 			pTab->Size++;
-		}
-		else
-		{
+		} else {
 			pEntry = NULL;
-			DBGPRINT(RT_DEBUG_ERROR, ("%s: pMeasureReqTab tab full.\n", __func__));
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s: pMeasureReqTab tab full.\n", __func__));
 		}
 
 		// add this Neighbor entry into HASH table
-		if (pEntry)
-		{
+		if (pEntry) {
 			HashIdx = MQ_DIALOGTOKEN_HASH_INDEX(DialogToken);
-			if (pTab->Hash[HashIdx] == NULL)
-			{
+			if (pTab->Hash[HashIdx] == NULL) {
 				pTab->Hash[HashIdx] = pEntry;
-			}
-			else
-			{
+			} else {
 				pCurrEntry = pTab->Hash[HashIdx];
 				while (pCurrEntry->pNext != NULL)
 					pCurrEntry = pCurrEntry->pNext;
@@ -434,45 +548,35 @@ PMEASURE_REQ_ENTRY MeasureReqInsert(
 	return pEntry;
 }
 
-VOID MeasureReqDelete(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken)
+VOID MeasureReqDelete(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 {
 	PMEASURE_REQ_TAB pTab = pAd->CommonCfg.pMeasureReqTab;
 	PMEASURE_REQ_ENTRY pEntry = NULL;
 
-	if(pTab == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: pMeasureReqTab doesn't exist.\n", __func__));
+	if (pTab == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: pMeasureReqTab doesn't exist.\n", __func__));
 		return;
 	}
-
 	// if empty, return
-	if (pTab->Size == 0)
-	{
+	if (pTab->Size == 0) {
 		DBGPRINT(RT_DEBUG_ERROR, ("pMeasureReqTab empty.\n"));
 		return;
 	}
 
 	pEntry = MeasureReqLookUp(pAd, DialogToken);
-	if (pEntry != NULL)
-	{
+	if (pEntry != NULL) {
 		PMEASURE_REQ_ENTRY pPrevEntry = NULL;
 		ULONG HashIdx = MQ_DIALOGTOKEN_HASH_INDEX(pEntry->DialogToken);
 		PMEASURE_REQ_ENTRY pProbeEntry = pTab->Hash[HashIdx];
 
 		RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
 		// update Hash list
-		do
-		{
-			if (pProbeEntry == pEntry)
-			{
-				if (pPrevEntry == NULL)
-				{
+		do {
+			if (pProbeEntry == pEntry) {
+				if (pPrevEntry == NULL) {
 					pTab->Hash[HashIdx] = pEntry->pNext;
-				}
-				else
-				{
+				} else {
 					pPrevEntry->pNext = pEntry->pNext;
 				}
 				break;
@@ -491,8 +595,7 @@ VOID MeasureReqDelete(
 	return;
 }
 
-VOID TpcReqTabInit(
-	IN PRTMP_ADAPTER pAd)
+VOID TpcReqTabInit(IN PRTMP_ADAPTER pAd)
 {
 	NdisAllocateSpinLock(&pAd->CommonCfg.TpcReqTabLock);
 
@@ -500,13 +603,14 @@ VOID TpcReqTabInit(
 	if (pAd->CommonCfg.pTpcReqTab)
 		NdisZeroMemory(pAd->CommonCfg.pTpcReqTab, sizeof(TPC_REQ_TAB));
 	else
-		DBGPRINT(RT_DEBUG_ERROR, ("%s Fail to alloc memory for pAd->CommonCfg.pTpcReqTab.\n", __func__));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s Fail to alloc memory for pAd->CommonCfg.pTpcReqTab.\n",
+			  __func__));
 
 	return;
 }
 
-VOID TpcReqTabExit(
-	IN PRTMP_ADAPTER pAd)
+VOID TpcReqTabExit(IN PRTMP_ADAPTER pAd)
 {
 	NdisFreeSpinLock(&pAd->CommonCfg.TpcReqTabLock);
 
@@ -517,18 +621,16 @@ VOID TpcReqTabExit(
 	return;
 }
 
-static PTPC_REQ_ENTRY TpcReqLookUp(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken)
+static PTPC_REQ_ENTRY TpcReqLookUp(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 {
 	UINT HashIdx;
 	PTPC_REQ_TAB pTab = pAd->CommonCfg.pTpcReqTab;
 	PTPC_REQ_ENTRY pEntry = NULL;
 	PTPC_REQ_ENTRY pPrevEntry = NULL;
 
-	if (pTab == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: pTpcReqTab doesn't exist.\n", __func__));
+	if (pTab == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: pTpcReqTab doesn't exist.\n", __func__));
 		return NULL;
 	}
 
@@ -537,12 +639,10 @@ static PTPC_REQ_ENTRY TpcReqLookUp(
 	HashIdx = TPC_DIALOGTOKEN_HASH_INDEX(DialogToken);
 	pEntry = pTab->Hash[HashIdx];
 
-	while (pEntry)
-	{
+	while (pEntry) {
 		if (pEntry->DialogToken == DialogToken)
 			break;
-		else
-		{
+		else {
 			pPrevEntry = pEntry;
 			pEntry = pEntry->pNext;
 		}
@@ -553,10 +653,7 @@ static PTPC_REQ_ENTRY TpcReqLookUp(
 	return pEntry;
 }
 
-
-static PTPC_REQ_ENTRY TpcReqInsert(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken)
+static PTPC_REQ_ENTRY TpcReqInsert(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 {
 	INT i;
 	ULONG HashIdx;
@@ -564,40 +661,41 @@ static PTPC_REQ_ENTRY TpcReqInsert(
 	PTPC_REQ_ENTRY pEntry = NULL, pCurrEntry;
 	ULONG Now;
 
-	if(pTab == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: pTpcReqTab doesn't exist.\n", __func__));
+	if (pTab == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: pTpcReqTab doesn't exist.\n", __func__));
 		return NULL;
 	}
 
 	pEntry = TpcReqLookUp(pAd, DialogToken);
-	if (pEntry == NULL)
-	{
+	if (pEntry == NULL) {
 		RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
-		for (i = 0; i < MAX_TPC_REQ_TAB_SIZE; i++)
-		{
+		for (i = 0; i < MAX_TPC_REQ_TAB_SIZE; i++) {
 			NdisGetSystemUpTime(&Now);
 			pEntry = &pTab->Content[i];
 
 			if ((pEntry->Valid == TRUE)
-				&& RTMP_TIME_AFTER((unsigned long)Now, (unsigned long)(pEntry->lastTime + TPC_REQ_AGE_OUT)))
+			    && RTMP_TIME_AFTER((unsigned long)Now,
+					       (unsigned long)(pEntry->
+							       lastTime +
+							       TPC_REQ_AGE_OUT)))
 			{
 				PTPC_REQ_ENTRY pPrevEntry = NULL;
-				ULONG HashIdx = TPC_DIALOGTOKEN_HASH_INDEX(pEntry->DialogToken);
-				PTPC_REQ_ENTRY pProbeEntry = pTab->Hash[HashIdx];
+				ULONG HashIdx =
+				    TPC_DIALOGTOKEN_HASH_INDEX(pEntry->
+							       DialogToken);
+				PTPC_REQ_ENTRY pProbeEntry =
+				    pTab->Hash[HashIdx];
 
 				// update Hash list
-				do
-				{
-					if (pProbeEntry == pEntry)
-					{
-						if (pPrevEntry == NULL)
-						{
-							pTab->Hash[HashIdx] = pEntry->pNext;
-						}
-						else
-						{
-							pPrevEntry->pNext = pEntry->pNext;
+				do {
+					if (pProbeEntry == pEntry) {
+						if (pPrevEntry == NULL) {
+							pTab->Hash[HashIdx] =
+							    pEntry->pNext;
+						} else {
+							pPrevEntry->pNext =
+							    pEntry->pNext;
 						}
 						break;
 					}
@@ -616,30 +714,24 @@ static PTPC_REQ_ENTRY TpcReqInsert(
 				break;
 		}
 
-		if (i < MAX_TPC_REQ_TAB_SIZE)
-		{
+		if (i < MAX_TPC_REQ_TAB_SIZE) {
 			NdisGetSystemUpTime(&Now);
 			pEntry->lastTime = Now;
 			pEntry->Valid = TRUE;
 			pEntry->DialogToken = DialogToken;
 			pTab->Size++;
-		}
-		else
-		{
+		} else {
 			pEntry = NULL;
-			DBGPRINT(RT_DEBUG_ERROR, ("%s: pTpcReqTab tab full.\n", __func__));
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s: pTpcReqTab tab full.\n", __func__));
 		}
 
 		// add this Neighbor entry into HASH table
-		if (pEntry)
-		{
+		if (pEntry) {
 			HashIdx = TPC_DIALOGTOKEN_HASH_INDEX(DialogToken);
-			if (pTab->Hash[HashIdx] == NULL)
-			{
+			if (pTab->Hash[HashIdx] == NULL) {
 				pTab->Hash[HashIdx] = pEntry;
-			}
-			else
-			{
+			} else {
 				pCurrEntry = pTab->Hash[HashIdx];
 				while (pCurrEntry->pNext != NULL)
 					pCurrEntry = pCurrEntry->pNext;
@@ -653,45 +745,35 @@ static PTPC_REQ_ENTRY TpcReqInsert(
 	return pEntry;
 }
 
-static VOID TpcReqDelete(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken)
+static VOID TpcReqDelete(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 {
 	PTPC_REQ_TAB pTab = pAd->CommonCfg.pTpcReqTab;
 	PTPC_REQ_ENTRY pEntry = NULL;
 
-	if(pTab == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: pTpcReqTab doesn't exist.\n", __func__));
+	if (pTab == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: pTpcReqTab doesn't exist.\n", __func__));
 		return;
 	}
-
 	// if empty, return
-	if (pTab->Size == 0)
-	{
+	if (pTab->Size == 0) {
 		DBGPRINT(RT_DEBUG_ERROR, ("pTpcReqTab empty.\n"));
 		return;
 	}
 
 	pEntry = TpcReqLookUp(pAd, DialogToken);
-	if (pEntry != NULL)
-	{
+	if (pEntry != NULL) {
 		PTPC_REQ_ENTRY pPrevEntry = NULL;
 		ULONG HashIdx = TPC_DIALOGTOKEN_HASH_INDEX(pEntry->DialogToken);
 		PTPC_REQ_ENTRY pProbeEntry = pTab->Hash[HashIdx];
 
 		RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
 		// update Hash list
-		do
-		{
-			if (pProbeEntry == pEntry)
-			{
-				if (pPrevEntry == NULL)
-				{
+		do {
+			if (pProbeEntry == pEntry) {
+				if (pPrevEntry == NULL) {
 					pTab->Hash[HashIdx] = pEntry->pNext;
-				}
-				else
-				{
+				} else {
 					pPrevEntry->pNext = pEntry->pNext;
 				}
 				break;
@@ -720,8 +802,7 @@ static VOID TpcReqDelete(
 	Return	: Current Time Stamp.
 	==========================================================================
  */
-static UINT64 GetCurrentTimeStamp(
-	IN PRTMP_ADAPTER pAd)
+static UINT64 GetCurrentTimeStamp(IN PRTMP_ADAPTER pAd)
 {
 	// get current time stamp.
 	return 0;
@@ -737,11 +818,9 @@ static UINT64 GetCurrentTimeStamp(
 	Return	: Current Time Stamp.
 	==========================================================================
  */
-static UINT8 GetCurTxPwr(
-	IN PRTMP_ADAPTER pAd,
-	IN UINT8 Wcid)
+static UINT8 GetCurTxPwr(IN PRTMP_ADAPTER pAd, IN UINT8 Wcid)
 {
-	return 16; /* 16 dBm */
+	return 16;		/* 16 dBm */
 }
 
 /*
@@ -754,12 +833,10 @@ static UINT8 GetCurTxPwr(
 	Return	: Current Time Stamp.
 	==========================================================================
  */
-VOID InsertChannelRepIE(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN PSTRING pCountry,
-	IN UINT8 RegulatoryClass)
+VOID InsertChannelRepIE(IN PRTMP_ADAPTER pAd,
+			OUT PUCHAR pFrameBuf,
+			OUT PULONG pFrameLen,
+			IN PSTRING pCountry, IN UINT8 RegulatoryClass)
 {
 	ULONG TempLen;
 	UINT8 Len;
@@ -767,43 +844,43 @@ VOID InsertChannelRepIE(
 	PUCHAR pChListPtr = NULL;
 
 	Len = 1;
-	if (strncmp(pCountry, "US", 2) == 0)
-	{
-		if (RegulatoryClass >= USA_REGULATORY_INFO_SIZE)
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("%s: USA Unknow Requlatory class (%d)\n",
-						__func__, RegulatoryClass));
+	if (strncmp(pCountry, "US", 2) == 0) {
+		if (RegulatoryClass >= USA_REGULATORY_INFO_SIZE) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s: USA Unknow Requlatory class (%d)\n",
+				  __func__, RegulatoryClass));
 			return;
 		}
 
-		Len += USARegulatoryInfo[RegulatoryClass].ChannelSet.NumberOfChannels;
-		pChListPtr = USARegulatoryInfo[RegulatoryClass].ChannelSet.ChannelList;
-	}
-	else if (strncmp(pCountry, "JP", 2) == 0)
-	{
-		if (RegulatoryClass >= JP_REGULATORY_INFO_SIZE)
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("%s: JP Unknow Requlatory class (%d)\n",
-						__func__, RegulatoryClass));
+		Len +=
+		    USARegulatoryInfo[RegulatoryClass].ChannelSet.
+		    NumberOfChannels;
+		pChListPtr =
+		    USARegulatoryInfo[RegulatoryClass].ChannelSet.ChannelList;
+	} else if (strncmp(pCountry, "JP", 2) == 0) {
+		if (RegulatoryClass >= JP_REGULATORY_INFO_SIZE) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s: JP Unknow Requlatory class (%d)\n",
+				  __func__, RegulatoryClass));
 			return;
 		}
 
-		Len += JapanRegulatoryInfo[RegulatoryClass].ChannelSet.NumberOfChannels;
-		pChListPtr = JapanRegulatoryInfo[RegulatoryClass].ChannelSet.ChannelList;
-	}
-	else
-	{
+		Len +=
+		    JapanRegulatoryInfo[RegulatoryClass].ChannelSet.
+		    NumberOfChannels;
+		pChListPtr =
+		    JapanRegulatoryInfo[RegulatoryClass].ChannelSet.ChannelList;
+	} else {
 		DBGPRINT(RT_DEBUG_ERROR, ("%s: Unknow Country (%s)\n",
-					__func__, pCountry));
+					  __func__, pCountry));
 		return;
 	}
 
-	MakeOutgoingFrame(pFrameBuf,	&TempLen,
-					1,				&IEId,
-					1,				&Len,
-					1,				&RegulatoryClass,
-					Len -1,			pChListPtr,
-					END_OF_ARGS);
+	MakeOutgoingFrame(pFrameBuf, &TempLen,
+			  1, &IEId,
+			  1, &Len,
+			  1, &RegulatoryClass,
+			  Len - 1, pChListPtr, END_OF_ARGS);
 
 	*pFrameLen = *pFrameLen + TempLen;
 
@@ -823,16 +900,12 @@ VOID InsertChannelRepIE(
 	Return	: None.
 	==========================================================================
  */
-VOID InsertDialogToken(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN UINT8 DialogToken)
+VOID InsertDialogToken(IN PRTMP_ADAPTER pAd,
+		       OUT PUCHAR pFrameBuf,
+		       OUT PULONG pFrameLen, IN UINT8 DialogToken)
 {
 	ULONG TempLen;
-	MakeOutgoingFrame(pFrameBuf,	&TempLen,
-					1,				&DialogToken,
-					END_OF_ARGS);
+	MakeOutgoingFrame(pFrameBuf, &TempLen, 1, &DialogToken, END_OF_ARGS);
 
 	*pFrameLen = *pFrameLen + TempLen;
 
@@ -851,19 +924,15 @@ VOID InsertDialogToken(
 	Return	: None.
 	==========================================================================
  */
- static VOID InsertTpcReqIE(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen)
+static VOID InsertTpcReqIE(IN PRTMP_ADAPTER pAd,
+			   OUT PUCHAR pFrameBuf, OUT PULONG pFrameLen)
 {
 	ULONG TempLen;
 	ULONG Len = 0;
 	UINT8 ElementID = IE_TPC_REQUEST;
 
-	MakeOutgoingFrame(pFrameBuf,					&TempLen,
-						1,							&ElementID,
-						1,							&Len,
-						END_OF_ARGS);
+	MakeOutgoingFrame(pFrameBuf, &TempLen,
+			  1, &ElementID, 1, &Len, END_OF_ARGS);
 
 	*pFrameLen = *pFrameLen + TempLen;
 
@@ -884,12 +953,10 @@ VOID InsertDialogToken(
 	Return	: None.
 	==========================================================================
  */
-VOID InsertTpcReportIE(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN UINT8 TxPwr,
-	IN UINT8 LinkMargin)
+VOID InsertTpcReportIE(IN PRTMP_ADAPTER pAd,
+		       OUT PUCHAR pFrameBuf,
+		       OUT PULONG pFrameLen,
+		       IN UINT8 TxPwr, IN UINT8 LinkMargin)
 {
 	ULONG TempLen;
 	ULONG Len = sizeof(TPC_REPORT_INFO);
@@ -899,15 +966,12 @@ VOID InsertTpcReportIE(
 	TpcReportIE.TxPwr = TxPwr;
 	TpcReportIE.LinkMargin = LinkMargin;
 
-	MakeOutgoingFrame(pFrameBuf,					&TempLen,
-						1,							&ElementID,
-						1,							&Len,
-						Len,						&TpcReportIE,
-						END_OF_ARGS);
+	MakeOutgoingFrame(pFrameBuf, &TempLen,
+			  1, &ElementID,
+			  1, &Len, Len, &TpcReportIE, END_OF_ARGS);
 
 	*pFrameLen = *pFrameLen + TempLen;
 
-
 	return;
 }
 
@@ -926,13 +990,11 @@ VOID InsertTpcReportIE(
 	Return	: None.
 	==========================================================================
  */
-static VOID InsertChSwAnnIE(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN UINT8 ChSwMode,
-	IN UINT8 NewChannel,
-	IN UINT8 ChSwCnt)
+static VOID InsertChSwAnnIE(IN PRTMP_ADAPTER pAd,
+			    OUT PUCHAR pFrameBuf,
+			    OUT PULONG pFrameLen,
+			    IN UINT8 ChSwMode,
+			    IN UINT8 NewChannel, IN UINT8 ChSwCnt)
 {
 	ULONG TempLen;
 	ULONG Len = sizeof(CH_SW_ANN_INFO);
@@ -943,15 +1005,11 @@ static VOID InsertChSwAnnIE(
 	ChSwAnnIE.Channel = NewChannel;
 	ChSwAnnIE.ChSwCnt = ChSwCnt;
 
-	MakeOutgoingFrame(pFrameBuf,				&TempLen,
-						1,						&ElementID,
-						1,						&Len,
-						Len,					&ChSwAnnIE,
-						END_OF_ARGS);
+	MakeOutgoingFrame(pFrameBuf, &TempLen,
+			  1, &ElementID, 1, &Len, Len, &ChSwAnnIE, END_OF_ARGS);
 
 	*pFrameLen = *pFrameLen + TempLen;
 
-
 	return;
 }
 
@@ -970,25 +1028,21 @@ static VOID InsertChSwAnnIE(
 		7. Measure Start time.
 		8. Measure Duration.
 
-
 	Return	: None.
 	==========================================================================
  */
-static VOID InsertMeasureReqIE(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN UINT8 Len,
-	IN PMEASURE_REQ_INFO pMeasureReqIE)
+static VOID InsertMeasureReqIE(IN PRTMP_ADAPTER pAd,
+			       OUT PUCHAR pFrameBuf,
+			       OUT PULONG pFrameLen,
+			       IN UINT8 Len, IN PMEASURE_REQ_INFO pMeasureReqIE)
 {
 	ULONG TempLen;
 	UINT8 ElementID = IE_MEASUREMENT_REQUEST;
 
-	MakeOutgoingFrame(pFrameBuf,					&TempLen,
-						1,							&ElementID,
-						1,							&Len,
-						sizeof(MEASURE_REQ_INFO),	pMeasureReqIE,
-						END_OF_ARGS);
+	MakeOutgoingFrame(pFrameBuf, &TempLen,
+			  1, &ElementID,
+			  1, &Len,
+			  sizeof(MEASURE_REQ_INFO), pMeasureReqIE, END_OF_ARGS);
 
 	*pFrameLen = *pFrameLen + TempLen;
 
@@ -1012,13 +1066,11 @@ static VOID InsertMeasureReqIE(
 	Return	: None.
 	==========================================================================
  */
-static VOID InsertMeasureReportIE(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN PMEASURE_REPORT_INFO pMeasureReportIE,
-	IN UINT8 ReportLnfoLen,
-	IN PUINT8 pReportInfo)
+static VOID InsertMeasureReportIE(IN PRTMP_ADAPTER pAd,
+				  OUT PUCHAR pFrameBuf,
+				  OUT PULONG pFrameLen,
+				  IN PMEASURE_REPORT_INFO pMeasureReportIE,
+				  IN UINT8 ReportLnfoLen, IN PUINT8 pReportInfo)
 {
 	ULONG TempLen;
 	ULONG Len;
@@ -1026,19 +1078,15 @@ static VOID InsertMeasureReportIE(
 
 	Len = sizeof(MEASURE_REPORT_INFO) + ReportLnfoLen;
 
-	MakeOutgoingFrame(pFrameBuf,					&TempLen,
-						1,							&ElementID,
-						1,							&Len,
-						Len,						pMeasureReportIE,
-						END_OF_ARGS);
+	MakeOutgoingFrame(pFrameBuf, &TempLen,
+			  1, &ElementID,
+			  1, &Len, Len, pMeasureReportIE, END_OF_ARGS);
 
 	*pFrameLen = *pFrameLen + TempLen;
 
-	if ((ReportLnfoLen > 0) && (pReportInfo != NULL))
-	{
-		MakeOutgoingFrame(pFrameBuf + *pFrameLen,		&TempLen,
-							ReportLnfoLen,				pReportInfo,
-							END_OF_ARGS);
+	if ((ReportLnfoLen > 0) && (pReportInfo != NULL)) {
+		MakeOutgoingFrame(pFrameBuf + *pFrameLen, &TempLen,
+				  ReportLnfoLen, pReportInfo, END_OF_ARGS);
 
 		*pFrameLen = *pFrameLen + TempLen;
 	}
@@ -1057,43 +1105,40 @@ static VOID InsertMeasureReportIE(
 	Return	: None.
 	==========================================================================
  */
-VOID MakeMeasurementReqFrame(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pOutBuffer,
-	OUT PULONG pFrameLen,
-	IN UINT8 TotalLen,
-	IN UINT8 Category,
-	IN UINT8 Action,
-	IN UINT8 MeasureToken,
-	IN UINT8 MeasureReqMode,
-	IN UINT8 MeasureReqType,
-	IN UINT8 NumOfRepetitions)
+VOID MakeMeasurementReqFrame(IN PRTMP_ADAPTER pAd,
+			     OUT PUCHAR pOutBuffer,
+			     OUT PULONG pFrameLen,
+			     IN UINT8 TotalLen,
+			     IN UINT8 Category,
+			     IN UINT8 Action,
+			     IN UINT8 MeasureToken,
+			     IN UINT8 MeasureReqMode,
+			     IN UINT8 MeasureReqType, IN UINT8 NumOfRepetitions)
 {
 	ULONG TempLen;
 	MEASURE_REQ_INFO MeasureReqIE;
 
-	InsertActField(pAd, (pOutBuffer + *pFrameLen), pFrameLen, Category, Action);
+	InsertActField(pAd, (pOutBuffer + *pFrameLen), pFrameLen, Category,
+		       Action);
 
 	// fill Dialog Token
-	InsertDialogToken(pAd, (pOutBuffer + *pFrameLen), pFrameLen, MeasureToken);
+	InsertDialogToken(pAd, (pOutBuffer + *pFrameLen), pFrameLen,
+			  MeasureToken);
 
 	/* fill Number of repetitions. */
-	if (Category == CATEGORY_RM)
-	{
-		MakeOutgoingFrame((pOutBuffer+*pFrameLen),	&TempLen,
-						2,							&NumOfRepetitions,
-						END_OF_ARGS);
+	if (Category == CATEGORY_RM) {
+		MakeOutgoingFrame((pOutBuffer + *pFrameLen), &TempLen,
+				  2, &NumOfRepetitions, END_OF_ARGS);
 
 		*pFrameLen += TempLen;
 	}
-
 	// prepare Measurement IE.
 	NdisZeroMemory(&MeasureReqIE, sizeof(MEASURE_REQ_INFO));
 	MeasureReqIE.Token = MeasureToken;
 	MeasureReqIE.ReqMode.word = MeasureReqMode;
 	MeasureReqIE.ReqType = MeasureReqType;
-	InsertMeasureReqIE(pAd, (pOutBuffer+*pFrameLen), pFrameLen,
-		TotalLen, &MeasureReqIE);
+	InsertMeasureReqIE(pAd, (pOutBuffer + *pFrameLen), pFrameLen,
+			   TotalLen, &MeasureReqIE);
 
 	return;
 }
@@ -1110,15 +1155,13 @@ VOID MakeMeasurementReqFrame(
 	Return	: None.
 	==========================================================================
  */
-VOID EnqueueMeasurementRep(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pDA,
-	IN UINT8 DialogToken,
-	IN UINT8 MeasureToken,
-	IN UINT8 MeasureReqMode,
-	IN UINT8 MeasureReqType,
-	IN UINT8 ReportInfoLen,
-	IN PUINT8 pReportInfo)
+VOID EnqueueMeasurementRep(IN PRTMP_ADAPTER pAd,
+			   IN PUCHAR pDA,
+			   IN UINT8 DialogToken,
+			   IN UINT8 MeasureToken,
+			   IN UINT8 MeasureReqMode,
+			   IN UINT8 MeasureReqType,
+			   IN UINT8 ReportInfoLen, IN PUINT8 pReportInfo)
 {
 	PUCHAR pOutBuffer = NULL;
 	NDIS_STATUS NStatus;
@@ -1128,18 +1171,19 @@ VOID EnqueueMeasurementRep(
 
 	// build action frame header.
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
-						pAd->CurrentAddress);
+			 pAd->CurrentAddress);
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
-	if(NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("%s() allocate memory failed \n", __func__));
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s() allocate memory failed \n", __func__));
 		return;
 	}
-	NdisMoveMemory(pOutBuffer, (PCHAR)&ActHdr, sizeof(HEADER_802_11));
+	NdisMoveMemory(pOutBuffer, (PCHAR) & ActHdr, sizeof(HEADER_802_11));
 	FrameLen = sizeof(HEADER_802_11);
 
-	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen, CATEGORY_SPECTRUM, SPEC_MRP);
+	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
+		       CATEGORY_SPECTRUM, SPEC_MRP);
 
 	// fill Dialog Token
 	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
@@ -1149,7 +1193,8 @@ VOID EnqueueMeasurementRep(
 	MeasureRepIE.Token = MeasureToken;
 	MeasureRepIE.ReportMode = MeasureReqMode;
 	MeasureRepIE.ReportType = MeasureReqType;
-	InsertMeasureReportIE(pAd, (pOutBuffer + FrameLen), &FrameLen, &MeasureRepIE, ReportInfoLen, pReportInfo);
+	InsertMeasureReportIE(pAd, (pOutBuffer + FrameLen), &FrameLen,
+			      &MeasureRepIE, ReportInfoLen, pReportInfo);
 
 	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
@@ -1169,10 +1214,7 @@ VOID EnqueueMeasurementRep(
 	Return	: None.
 	==========================================================================
  */
-VOID EnqueueTPCReq(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pDA,
-	IN UCHAR DialogToken)
+VOID EnqueueTPCReq(IN PRTMP_ADAPTER pAd, IN PUCHAR pDA, IN UCHAR DialogToken)
 {
 	PUCHAR pOutBuffer = NULL;
 	NDIS_STATUS NStatus;
@@ -1182,18 +1224,19 @@ VOID EnqueueTPCReq(
 
 	// build action frame header.
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
-						pAd->CurrentAddress);
+			 pAd->CurrentAddress);
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
-	if(NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("%s() allocate memory failed \n", __func__));
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s() allocate memory failed \n", __func__));
 		return;
 	}
-	NdisMoveMemory(pOutBuffer, (PCHAR)&ActHdr, sizeof(HEADER_802_11));
+	NdisMoveMemory(pOutBuffer, (PCHAR) & ActHdr, sizeof(HEADER_802_11));
 	FrameLen = sizeof(HEADER_802_11);
 
-	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen, CATEGORY_SPECTRUM, SPEC_TPCRQ);
+	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
+		       CATEGORY_SPECTRUM, SPEC_TPCRQ);
 
 	// fill Dialog Token
 	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
@@ -1219,12 +1262,9 @@ VOID EnqueueTPCReq(
 	Return	: None.
 	==========================================================================
  */
-VOID EnqueueTPCRep(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pDA,
-	IN UINT8 DialogToken,
-	IN UINT8 TxPwr,
-	IN UINT8 LinkMargin)
+VOID EnqueueTPCRep(IN PRTMP_ADAPTER pAd,
+		   IN PUCHAR pDA,
+		   IN UINT8 DialogToken, IN UINT8 TxPwr, IN UINT8 LinkMargin)
 {
 	PUCHAR pOutBuffer = NULL;
 	NDIS_STATUS NStatus;
@@ -1234,24 +1274,26 @@ VOID EnqueueTPCRep(
 
 	// build action frame header.
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
-						pAd->CurrentAddress);
+			 pAd->CurrentAddress);
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
-	if(NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("%s() allocate memory failed \n", __func__));
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s() allocate memory failed \n", __func__));
 		return;
 	}
-	NdisMoveMemory(pOutBuffer, (PCHAR)&ActHdr, sizeof(HEADER_802_11));
+	NdisMoveMemory(pOutBuffer, (PCHAR) & ActHdr, sizeof(HEADER_802_11));
 	FrameLen = sizeof(HEADER_802_11);
 
-	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen, CATEGORY_SPECTRUM, SPEC_TPCRP);
+	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
+		       CATEGORY_SPECTRUM, SPEC_TPCRP);
 
 	// fill Dialog Token
 	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
 
 	// Insert TPC Request IE.
-	InsertTpcReportIE(pAd, (pOutBuffer + FrameLen), &FrameLen, TxPwr, LinkMargin);
+	InsertTpcReportIE(pAd, (pOutBuffer + FrameLen), &FrameLen, TxPwr,
+			  LinkMargin);
 
 	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
@@ -1273,11 +1315,8 @@ VOID EnqueueTPCRep(
 	Return	: None.
 	==========================================================================
  */
-VOID EnqueueChSwAnn(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pDA,
-	IN UINT8 ChSwMode,
-	IN UINT8 NewCh)
+VOID EnqueueChSwAnn(IN PRTMP_ADAPTER pAd,
+		    IN PUCHAR pDA, IN UINT8 ChSwMode, IN UINT8 NewCh)
 {
 	PUCHAR pOutBuffer = NULL;
 	NDIS_STATUS NStatus;
@@ -1287,20 +1326,22 @@ VOID EnqueueChSwAnn(
 
 	// build action frame header.
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
-						pAd->CurrentAddress);
+			 pAd->CurrentAddress);
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
-	if(NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("%s() allocate memory failed \n", __func__));
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s() allocate memory failed \n", __func__));
 		return;
 	}
-	NdisMoveMemory(pOutBuffer, (PCHAR)&ActHdr, sizeof(HEADER_802_11));
+	NdisMoveMemory(pOutBuffer, (PCHAR) & ActHdr, sizeof(HEADER_802_11));
 	FrameLen = sizeof(HEADER_802_11);
 
-	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen, CATEGORY_SPECTRUM, SPEC_CHANNEL_SWITCH);
+	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
+		       CATEGORY_SPECTRUM, SPEC_CHANNEL_SWITCH);
 
-	InsertChSwAnnIE(pAd, (pOutBuffer + FrameLen), &FrameLen, ChSwMode, NewCh, 0);
+	InsertChSwAnnIE(pAd, (pOutBuffer + FrameLen), &FrameLen, ChSwMode,
+			NewCh, 0);
 
 	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
@@ -1308,53 +1349,41 @@ VOID EnqueueChSwAnn(
 	return;
 }
 
-static BOOLEAN DfsRequirementCheck(
-	IN PRTMP_ADAPTER pAd,
-	IN UINT8 Channel)
+static BOOLEAN DfsRequirementCheck(IN PRTMP_ADAPTER pAd, IN UINT8 Channel)
 {
 	BOOLEAN Result = FALSE;
 	INT i;
 
-	do
-	{
+	do {
 		// check DFS procedure is running.
 		// make sure DFS procedure won't start twice.
-		if (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)
-		{
+		if (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE) {
 			Result = FALSE;
 			break;
 		}
-
 		// check the new channel carried from Channel Switch Announcemnet is valid.
-		for (i=0; i<pAd->ChannelListNum; i++)
-		{
+		for (i = 0; i < pAd->ChannelListNum; i++) {
 			if ((Channel == pAd->ChannelList[i].Channel)
-				&&(pAd->ChannelList[i].RemainingTimeForUse == 0))
-			{
+			    && (pAd->ChannelList[i].RemainingTimeForUse == 0)) {
 				// found radar signal in the channel. the channel can't use at least for 30 minutes.
-				pAd->ChannelList[i].RemainingTimeForUse = 1800;//30 min = 1800 sec
+				pAd->ChannelList[i].RemainingTimeForUse = 1800;	//30 min = 1800 sec
 				Result = TRUE;
 				break;
 			}
 		}
-	} while(FALSE);
+	} while (FALSE);
 
 	return Result;
 }
 
-VOID NotifyChSwAnnToPeerAPs(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pRA,
-	IN PUCHAR pTA,
-	IN UINT8 ChSwMode,
-	IN UINT8 Channel)
+VOID NotifyChSwAnnToPeerAPs(IN PRTMP_ADAPTER pAd,
+			    IN PUCHAR pRA,
+			    IN PUCHAR pTA, IN UINT8 ChSwMode, IN UINT8 Channel)
 {
 }
 
-static VOID StartDFSProcedure(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR Channel,
-	IN UINT8 ChSwMode)
+static VOID StartDFSProcedure(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR Channel, IN UINT8 ChSwMode)
 {
 	// start DFS procedure
 	pAd->CommonCfg.Channel = Channel;
@@ -1375,7 +1404,6 @@ static VOID StartDFSProcedure(
 		2. message length.
 		3. Channel switch announcement infomation buffer.
 
-
 	Return	: None.
 	==========================================================================
  */
@@ -1387,13 +1415,12 @@ static VOID StartDFSProcedure(
   +----+-----+-----------+------------+-----------+
     1    1        1           1            1
 */
-static BOOLEAN PeerChSwAnnSanity(
-	IN PRTMP_ADAPTER pAd,
-	IN VOID *pMsg,
-	IN ULONG MsgLen,
-	OUT PCH_SW_ANN_INFO pChSwAnnInfo)
+static BOOLEAN PeerChSwAnnSanity(IN PRTMP_ADAPTER pAd,
+				 IN VOID * pMsg,
+				 IN ULONG MsgLen,
+				 OUT PCH_SW_ANN_INFO pChSwAnnInfo)
 {
-	PFRAME_802_11 Fr = (PFRAME_802_11)pMsg;
+	PFRAME_802_11 Fr = (PFRAME_802_11) pMsg;
 	PUCHAR pFramePtr = Fr->Octet;
 	BOOLEAN result = FALSE;
 	PEID_STRUCT eid_ptr;
@@ -1408,23 +1435,25 @@ static BOOLEAN PeerChSwAnnSanity(
 	if (pChSwAnnInfo == NULL)
 		return result;
 
-	eid_ptr = (PEID_STRUCT)pFramePtr;
-	while (((UCHAR*)eid_ptr + eid_ptr->Len + 1) < ((PUCHAR)pFramePtr + MsgLen))
-	{
-		switch(eid_ptr->Eid)
-		{
-			case IE_CHANNEL_SWITCH_ANNOUNCEMENT:
-				NdisMoveMemory(&pChSwAnnInfo->ChSwMode, eid_ptr->Octet, 1);
-				NdisMoveMemory(&pChSwAnnInfo->Channel, eid_ptr->Octet + 1, 1);
-				NdisMoveMemory(&pChSwAnnInfo->ChSwCnt, eid_ptr->Octet + 2, 1);
+	eid_ptr = (PEID_STRUCT) pFramePtr;
+	while (((UCHAR *) eid_ptr + eid_ptr->Len + 1) <
+	       ((PUCHAR) pFramePtr + MsgLen)) {
+		switch (eid_ptr->Eid) {
+		case IE_CHANNEL_SWITCH_ANNOUNCEMENT:
+			NdisMoveMemory(&pChSwAnnInfo->ChSwMode, eid_ptr->Octet,
+				       1);
+			NdisMoveMemory(&pChSwAnnInfo->Channel,
+				       eid_ptr->Octet + 1, 1);
+			NdisMoveMemory(&pChSwAnnInfo->ChSwCnt,
+				       eid_ptr->Octet + 2, 1);
 
-				result = TRUE;
-                break;
+			result = TRUE;
+			break;
 
-			default:
-				break;
+		default:
+			break;
 		}
-		eid_ptr = (PEID_STRUCT)((UCHAR*)eid_ptr + 2 + eid_ptr->Len);
+		eid_ptr = (PEID_STRUCT) ((UCHAR *) eid_ptr + 2 + eid_ptr->Len);
 	}
 
 	return result;
@@ -1443,15 +1472,14 @@ static BOOLEAN PeerChSwAnnSanity(
 	Return	: None.
 	==========================================================================
  */
-static BOOLEAN PeerMeasureReqSanity(
-	IN PRTMP_ADAPTER pAd,
-	IN VOID *pMsg,
-	IN ULONG MsgLen,
-	OUT PUINT8 pDialogToken,
-	OUT PMEASURE_REQ_INFO pMeasureReqInfo,
-	OUT PMEASURE_REQ pMeasureReq)
+static BOOLEAN PeerMeasureReqSanity(IN PRTMP_ADAPTER pAd,
+				    IN VOID * pMsg,
+				    IN ULONG MsgLen,
+				    OUT PUINT8 pDialogToken,
+				    OUT PMEASURE_REQ_INFO pMeasureReqInfo,
+				    OUT PMEASURE_REQ pMeasureReq)
 {
-	PFRAME_802_11 Fr = (PFRAME_802_11)pMsg;
+	PFRAME_802_11 Fr = (PFRAME_802_11) pMsg;
 	PUCHAR pFramePtr = Fr->Octet;
 	BOOLEAN result = FALSE;
 	PEID_STRUCT eid_ptr;
@@ -1473,29 +1501,32 @@ static BOOLEAN PeerMeasureReqSanity(
 	pFramePtr += 1;
 	MsgLen -= 1;
 
-	eid_ptr = (PEID_STRUCT)pFramePtr;
-	while (((UCHAR*)eid_ptr + eid_ptr->Len + 1) < ((PUCHAR)pFramePtr + MsgLen))
-	{
-		switch(eid_ptr->Eid)
-		{
-			case IE_MEASUREMENT_REQUEST:
-				NdisMoveMemory(&pMeasureReqInfo->Token, eid_ptr->Octet, 1);
-				NdisMoveMemory(&pMeasureReqInfo->ReqMode.word, eid_ptr->Octet + 1, 1);
-				NdisMoveMemory(&pMeasureReqInfo->ReqType, eid_ptr->Octet + 2, 1);
-				ptr = (PUCHAR)(eid_ptr->Octet + 3);
-				NdisMoveMemory(&pMeasureReq->ChNum, ptr, 1);
-				NdisMoveMemory(&MeasureStartTime, ptr + 1, 8);
-				pMeasureReq->MeasureStartTime = SWAP64(MeasureStartTime);
-				NdisMoveMemory(&MeasureDuration, ptr + 9, 2);
-				pMeasureReq->MeasureDuration = SWAP16(MeasureDuration);
+	eid_ptr = (PEID_STRUCT) pFramePtr;
+	while (((UCHAR *) eid_ptr + eid_ptr->Len + 1) <
+	       ((PUCHAR) pFramePtr + MsgLen)) {
+		switch (eid_ptr->Eid) {
+		case IE_MEASUREMENT_REQUEST:
+			NdisMoveMemory(&pMeasureReqInfo->Token, eid_ptr->Octet,
+				       1);
+			NdisMoveMemory(&pMeasureReqInfo->ReqMode.word,
+				       eid_ptr->Octet + 1, 1);
+			NdisMoveMemory(&pMeasureReqInfo->ReqType,
+				       eid_ptr->Octet + 2, 1);
+			ptr = (PUCHAR) (eid_ptr->Octet + 3);
+			NdisMoveMemory(&pMeasureReq->ChNum, ptr, 1);
+			NdisMoveMemory(&MeasureStartTime, ptr + 1, 8);
+			pMeasureReq->MeasureStartTime =
+			    SWAP64(MeasureStartTime);
+			NdisMoveMemory(&MeasureDuration, ptr + 9, 2);
+			pMeasureReq->MeasureDuration = SWAP16(MeasureDuration);
 
-				result = TRUE;
-				break;
+			result = TRUE;
+			break;
 
-			default:
-				break;
+		default:
+			break;
 		}
-		eid_ptr = (PEID_STRUCT)((UCHAR*)eid_ptr + 2 + eid_ptr->Len);
+		eid_ptr = (PEID_STRUCT) ((UCHAR *) eid_ptr + 2 + eid_ptr->Len);
 	}
 
 	return result;
@@ -1535,15 +1566,15 @@ static BOOLEAN PeerMeasureReqSanity(
   +-----+---------------+---------------------+-------+------------+----------+
      0          1                  2              3         4          5-7
 */
-static BOOLEAN PeerMeasureReportSanity(
-	IN PRTMP_ADAPTER pAd,
-	IN VOID *pMsg,
-	IN ULONG MsgLen,
-	OUT PUINT8 pDialogToken,
-	OUT PMEASURE_REPORT_INFO pMeasureReportInfo,
-	OUT PUINT8 pReportBuf)
+static BOOLEAN PeerMeasureReportSanity(IN PRTMP_ADAPTER pAd,
+				       IN VOID * pMsg,
+				       IN ULONG MsgLen,
+				       OUT PUINT8 pDialogToken,
+				       OUT PMEASURE_REPORT_INFO
+				       pMeasureReportInfo,
+				       OUT PUINT8 pReportBuf)
 {
-	PFRAME_802_11 Fr = (PFRAME_802_11)pMsg;
+	PFRAME_802_11 Fr = (PFRAME_802_11) pMsg;
 	PUCHAR pFramePtr = Fr->Octet;
 	BOOLEAN result = FALSE;
 	PEID_STRUCT eid_ptr;
@@ -1563,51 +1594,60 @@ static BOOLEAN PeerMeasureReportSanity(
 	pFramePtr += 1;
 	MsgLen -= 1;
 
-	eid_ptr = (PEID_STRUCT)pFramePtr;
-	while (((UCHAR*)eid_ptr + eid_ptr->Len + 1) < ((PUCHAR)pFramePtr + MsgLen))
-	{
-		switch(eid_ptr->Eid)
-		{
-			case IE_MEASUREMENT_REPORT:
-				NdisMoveMemory(&pMeasureReportInfo->Token, eid_ptr->Octet, 1);
-				NdisMoveMemory(&pMeasureReportInfo->ReportMode, eid_ptr->Octet + 1, 1);
-				NdisMoveMemory(&pMeasureReportInfo->ReportType, eid_ptr->Octet + 2, 1);
-				if (pMeasureReportInfo->ReportType == RM_BASIC)
-				{
-					PMEASURE_BASIC_REPORT pReport = (PMEASURE_BASIC_REPORT)pReportBuf;
-					ptr = (PUCHAR)(eid_ptr->Octet + 3);
-					NdisMoveMemory(&pReport->ChNum, ptr, 1);
-					NdisMoveMemory(&pReport->MeasureStartTime, ptr + 1, 8);
-					NdisMoveMemory(&pReport->MeasureDuration, ptr + 9, 2);
-					NdisMoveMemory(&pReport->Map, ptr + 11, 1);
-
-				}
-				else if (pMeasureReportInfo->ReportType == RM_CCA)
-				{
-					PMEASURE_CCA_REPORT pReport = (PMEASURE_CCA_REPORT)pReportBuf;
-					ptr = (PUCHAR)(eid_ptr->Octet + 3);
-					NdisMoveMemory(&pReport->ChNum, ptr, 1);
-					NdisMoveMemory(&pReport->MeasureStartTime, ptr + 1, 8);
-					NdisMoveMemory(&pReport->MeasureDuration, ptr + 9, 2);
-					NdisMoveMemory(&pReport->CCA_Busy_Fraction, ptr + 11, 1);
-
-				}
-				else if (pMeasureReportInfo->ReportType == RM_RPI_HISTOGRAM)
-				{
-					PMEASURE_RPI_REPORT pReport = (PMEASURE_RPI_REPORT)pReportBuf;
-					ptr = (PUCHAR)(eid_ptr->Octet + 3);
-					NdisMoveMemory(&pReport->ChNum, ptr, 1);
-					NdisMoveMemory(&pReport->MeasureStartTime, ptr + 1, 8);
-					NdisMoveMemory(&pReport->MeasureDuration, ptr + 9, 2);
-					NdisMoveMemory(&pReport->RPI_Density, ptr + 11, 8);
-				}
-				result = TRUE;
-                break;
+	eid_ptr = (PEID_STRUCT) pFramePtr;
+	while (((UCHAR *) eid_ptr + eid_ptr->Len + 1) <
+	       ((PUCHAR) pFramePtr + MsgLen)) {
+		switch (eid_ptr->Eid) {
+		case IE_MEASUREMENT_REPORT:
+			NdisMoveMemory(&pMeasureReportInfo->Token,
+				       eid_ptr->Octet, 1);
+			NdisMoveMemory(&pMeasureReportInfo->ReportMode,
+				       eid_ptr->Octet + 1, 1);
+			NdisMoveMemory(&pMeasureReportInfo->ReportType,
+				       eid_ptr->Octet + 2, 1);
+			if (pMeasureReportInfo->ReportType == RM_BASIC) {
+				PMEASURE_BASIC_REPORT pReport =
+				    (PMEASURE_BASIC_REPORT) pReportBuf;
+				ptr = (PUCHAR) (eid_ptr->Octet + 3);
+				NdisMoveMemory(&pReport->ChNum, ptr, 1);
+				NdisMoveMemory(&pReport->MeasureStartTime,
+					       ptr + 1, 8);
+				NdisMoveMemory(&pReport->MeasureDuration,
+					       ptr + 9, 2);
+				NdisMoveMemory(&pReport->Map, ptr + 11, 1);
+
+			} else if (pMeasureReportInfo->ReportType == RM_CCA) {
+				PMEASURE_CCA_REPORT pReport =
+				    (PMEASURE_CCA_REPORT) pReportBuf;
+				ptr = (PUCHAR) (eid_ptr->Octet + 3);
+				NdisMoveMemory(&pReport->ChNum, ptr, 1);
+				NdisMoveMemory(&pReport->MeasureStartTime,
+					       ptr + 1, 8);
+				NdisMoveMemory(&pReport->MeasureDuration,
+					       ptr + 9, 2);
+				NdisMoveMemory(&pReport->CCA_Busy_Fraction,
+					       ptr + 11, 1);
+
+			} else if (pMeasureReportInfo->ReportType ==
+				   RM_RPI_HISTOGRAM) {
+				PMEASURE_RPI_REPORT pReport =
+				    (PMEASURE_RPI_REPORT) pReportBuf;
+				ptr = (PUCHAR) (eid_ptr->Octet + 3);
+				NdisMoveMemory(&pReport->ChNum, ptr, 1);
+				NdisMoveMemory(&pReport->MeasureStartTime,
+					       ptr + 1, 8);
+				NdisMoveMemory(&pReport->MeasureDuration,
+					       ptr + 9, 2);
+				NdisMoveMemory(&pReport->RPI_Density, ptr + 11,
+					       8);
+			}
+			result = TRUE;
+			break;
 
-			default:
-				break;
+		default:
+			break;
 		}
-		eid_ptr = (PEID_STRUCT)((UCHAR*)eid_ptr + 2 + eid_ptr->Len);
+		eid_ptr = (PEID_STRUCT) ((UCHAR *) eid_ptr + 2 + eid_ptr->Len);
 	}
 
 	return result;
@@ -1626,13 +1666,11 @@ static BOOLEAN PeerMeasureReportSanity(
 	Return	: None.
 	==========================================================================
  */
-static BOOLEAN PeerTpcReqSanity(
-	IN PRTMP_ADAPTER pAd,
-	IN VOID *pMsg,
-	IN ULONG MsgLen,
-	OUT PUINT8 pDialogToken)
+static BOOLEAN PeerTpcReqSanity(IN PRTMP_ADAPTER pAd,
+				IN VOID * pMsg,
+				IN ULONG MsgLen, OUT PUINT8 pDialogToken)
 {
-	PFRAME_802_11 Fr = (PFRAME_802_11)pMsg;
+	PFRAME_802_11 Fr = (PFRAME_802_11) pMsg;
 	PUCHAR pFramePtr = Fr->Octet;
 	BOOLEAN result = FALSE;
 	PEID_STRUCT eid_ptr;
@@ -1650,19 +1688,18 @@ static BOOLEAN PeerTpcReqSanity(
 	pFramePtr += 1;
 	MsgLen -= 1;
 
-	eid_ptr = (PEID_STRUCT)pFramePtr;
-	while (((UCHAR*)eid_ptr + eid_ptr->Len + 1) < ((PUCHAR)pFramePtr + MsgLen))
-	{
-		switch(eid_ptr->Eid)
-		{
-			case IE_TPC_REQUEST:
-				result = TRUE;
-                break;
+	eid_ptr = (PEID_STRUCT) pFramePtr;
+	while (((UCHAR *) eid_ptr + eid_ptr->Len + 1) <
+	       ((PUCHAR) pFramePtr + MsgLen)) {
+		switch (eid_ptr->Eid) {
+		case IE_TPC_REQUEST:
+			result = TRUE;
+			break;
 
-			default:
-				break;
+		default:
+			break;
 		}
-		eid_ptr = (PEID_STRUCT)((UCHAR*)eid_ptr + 2 + eid_ptr->Len);
+		eid_ptr = (PEID_STRUCT) ((UCHAR *) eid_ptr + 2 + eid_ptr->Len);
 	}
 
 	return result;
@@ -1682,14 +1719,13 @@ static BOOLEAN PeerTpcReqSanity(
 	Return	: None.
 	==========================================================================
  */
-static BOOLEAN PeerTpcRepSanity(
-	IN PRTMP_ADAPTER pAd,
-	IN VOID *pMsg,
-	IN ULONG MsgLen,
-	OUT PUINT8 pDialogToken,
-	OUT PTPC_REPORT_INFO pTpcRepInfo)
+static BOOLEAN PeerTpcRepSanity(IN PRTMP_ADAPTER pAd,
+				IN VOID * pMsg,
+				IN ULONG MsgLen,
+				OUT PUINT8 pDialogToken,
+				OUT PTPC_REPORT_INFO pTpcRepInfo)
 {
-	PFRAME_802_11 Fr = (PFRAME_802_11)pMsg;
+	PFRAME_802_11 Fr = (PFRAME_802_11) pMsg;
 	PUCHAR pFramePtr = Fr->Octet;
 	BOOLEAN result = FALSE;
 	PEID_STRUCT eid_ptr;
@@ -1707,21 +1743,21 @@ static BOOLEAN PeerTpcRepSanity(
 	pFramePtr += 1;
 	MsgLen -= 1;
 
-	eid_ptr = (PEID_STRUCT)pFramePtr;
-	while (((UCHAR*)eid_ptr + eid_ptr->Len + 1) < ((PUCHAR)pFramePtr + MsgLen))
-	{
-		switch(eid_ptr->Eid)
-		{
-			case IE_TPC_REPORT:
-				NdisMoveMemory(&pTpcRepInfo->TxPwr, eid_ptr->Octet, 1);
-				NdisMoveMemory(&pTpcRepInfo->LinkMargin, eid_ptr->Octet + 1, 1);
-				result = TRUE;
-                break;
+	eid_ptr = (PEID_STRUCT) pFramePtr;
+	while (((UCHAR *) eid_ptr + eid_ptr->Len + 1) <
+	       ((PUCHAR) pFramePtr + MsgLen)) {
+		switch (eid_ptr->Eid) {
+		case IE_TPC_REPORT:
+			NdisMoveMemory(&pTpcRepInfo->TxPwr, eid_ptr->Octet, 1);
+			NdisMoveMemory(&pTpcRepInfo->LinkMargin,
+				       eid_ptr->Octet + 1, 1);
+			result = TRUE;
+			break;
 
-			default:
-				break;
+		default:
+			break;
 		}
-		eid_ptr = (PEID_STRUCT)((UCHAR*)eid_ptr + 2 + eid_ptr->Len);
+		eid_ptr = (PEID_STRUCT) ((UCHAR *) eid_ptr + 2 + eid_ptr->Len);
 	}
 
 	return result;
@@ -1738,64 +1774,69 @@ static BOOLEAN PeerTpcRepSanity(
 	Return	: None.
 	==========================================================================
  */
-static VOID PeerChSwAnnAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+static VOID PeerChSwAnnAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	CH_SW_ANN_INFO ChSwAnnInfo;
-	PFRAME_802_11 pFr = (PFRAME_802_11)Elem->Msg;
+	PFRAME_802_11 pFr = (PFRAME_802_11) Elem->Msg;
 	UCHAR index = 0, Channel = 0, NewChannel = 0;
 	ULONG Bssidx = 0;
 
 	NdisZeroMemory(&ChSwAnnInfo, sizeof(CH_SW_ANN_INFO));
-	if (! PeerChSwAnnSanity(pAd, Elem->Msg, Elem->MsgLen, &ChSwAnnInfo))
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("Invalid Channel Switch Action Frame.\n"));
+	if (!PeerChSwAnnSanity(pAd, Elem->Msg, Elem->MsgLen, &ChSwAnnInfo)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Invalid Channel Switch Action Frame.\n"));
 		return;
 	}
 
-	if (pAd->OpMode == OPMODE_STA)
-	{
-		Bssidx = BssTableSearch(&pAd->ScanTab, pFr->Hdr.Addr3, pAd->CommonCfg.Channel);
-		if (Bssidx == BSS_NOT_FOUND)
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("PeerChSwAnnAction - Bssidx is not found\n"));
+	if (pAd->OpMode == OPMODE_STA) {
+		Bssidx =
+		    BssTableSearch(&pAd->ScanTab, pFr->Hdr.Addr3,
+				   pAd->CommonCfg.Channel);
+		if (Bssidx == BSS_NOT_FOUND) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("PeerChSwAnnAction - Bssidx is not found\n"));
 			return;
 		}
 
-		DBGPRINT(RT_DEBUG_TRACE, ("\n****Bssidx is %d, Channel = %d\n", index, pAd->ScanTab.BssEntry[Bssidx].Channel));
-		hex_dump("SSID",pAd->ScanTab.BssEntry[Bssidx].Bssid ,6);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("\n****Bssidx is %d, Channel = %d\n", index,
+			  pAd->ScanTab.BssEntry[Bssidx].Channel));
+		hex_dump("SSID", pAd->ScanTab.BssEntry[Bssidx].Bssid, 6);
 
 		Channel = pAd->CommonCfg.Channel;
 		NewChannel = ChSwAnnInfo.Channel;
 
-		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0) && (Channel != NewChannel))
-		{
+		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0)
+		    && (Channel != NewChannel)) {
 			// Switching to channel 1 can prevent from rescanning the current channel immediately (by auto reconnection).
 			// In addition, clear the MLME queue and the scan table to discard the RX packets and previous scanning results.
 			AsicSwitchChannel(pAd, 1, FALSE);
 			AsicLockChannel(pAd, 1);
-		    LinkDown(pAd, FALSE);
+			LinkDown(pAd, FALSE);
 			MlmeQueueInit(&pAd->Mlme.Queue);
 			BssTableInit(&pAd->ScanTab);
-		    RTMPusecDelay(1000000);		// use delay to prevent STA do reassoc
+			RTMPusecDelay(1000000);	// use delay to prevent STA do reassoc
 
 			// channel sanity check
-			for (index = 0 ; index < pAd->ChannelListNum; index++)
-			{
-				if (pAd->ChannelList[index].Channel == NewChannel)
-				{
-					pAd->ScanTab.BssEntry[Bssidx].Channel = NewChannel;
+			for (index = 0; index < pAd->ChannelListNum; index++) {
+				if (pAd->ChannelList[index].Channel ==
+				    NewChannel) {
+					pAd->ScanTab.BssEntry[Bssidx].Channel =
+					    NewChannel;
 					pAd->CommonCfg.Channel = NewChannel;
-					AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-					AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-					DBGPRINT(RT_DEBUG_TRACE, ("&&&&&&&&&&&&&&&&PeerChSwAnnAction - STA receive channel switch announcement IE (New Channel =%d)\n", NewChannel));
+					AsicSwitchChannel(pAd,
+							  pAd->CommonCfg.
+							  Channel, FALSE);
+					AsicLockChannel(pAd,
+							pAd->CommonCfg.Channel);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("&&&&&&&&&&&&&&&&PeerChSwAnnAction - STA receive channel switch announcement IE (New Channel =%d)\n",
+						  NewChannel));
 					break;
 				}
 			}
 
-			if (index >= pAd->ChannelListNum)
-			{
+			if (index >= pAd->ChannelListNum) {
 				DBGPRINT_ERR(("&&&&&&&&&&&&&&&&&&&&&&&&&&PeerChSwAnnAction(can not find New Channel=%d in ChannelList[%d]\n", pAd->CommonCfg.Channel, pAd->ChannelListNum));
 			}
 		}
@@ -1804,7 +1845,6 @@ static VOID PeerChSwAnnAction(
 	return;
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -1816,21 +1856,23 @@ static VOID PeerChSwAnnAction(
 	Return	: None.
 	==========================================================================
  */
-static VOID PeerMeasureReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+static VOID PeerMeasureReqAction(IN PRTMP_ADAPTER pAd,
+				 IN MLME_QUEUE_ELEM * Elem)
 {
-	PFRAME_802_11 pFr = (PFRAME_802_11)Elem->Msg;
+	PFRAME_802_11 pFr = (PFRAME_802_11) Elem->Msg;
 	UINT8 DialogToken;
 	MEASURE_REQ_INFO MeasureReqInfo;
-	MEASURE_REQ	MeasureReq;
+	MEASURE_REQ MeasureReq;
 	MEASURE_REPORT_MODE ReportMode;
 
-	if(PeerMeasureReqSanity(pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &MeasureReqInfo, &MeasureReq))
-	{
+	if (PeerMeasureReqSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &MeasureReqInfo,
+	     &MeasureReq)) {
 		ReportMode.word = 0;
 		ReportMode.field.Incapable = 1;
-		EnqueueMeasurementRep(pAd, pFr->Hdr.Addr2, DialogToken, MeasureReqInfo.Token, ReportMode.word, MeasureReqInfo.ReqType, 0, NULL);
+		EnqueueMeasurementRep(pAd, pFr->Hdr.Addr2, DialogToken,
+				      MeasureReqInfo.Token, ReportMode.word,
+				      MeasureReqInfo.ReqType, 0, NULL);
 	}
 
 	return;
@@ -1847,54 +1889,65 @@ static VOID PeerMeasureReqAction(
 	Return	: None.
 	==========================================================================
  */
-static VOID PeerMeasureReportAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+static VOID PeerMeasureReportAction(IN PRTMP_ADAPTER pAd,
+				    IN MLME_QUEUE_ELEM * Elem)
 {
 	MEASURE_REPORT_INFO MeasureReportInfo;
-	PFRAME_802_11 pFr = (PFRAME_802_11)Elem->Msg;
+	PFRAME_802_11 pFr = (PFRAME_802_11) Elem->Msg;
 	UINT8 DialogToken;
 	PUINT8 pMeasureReportInfo;
 
-//	if (pAd->CommonCfg.bIEEE80211H != TRUE)
-//		return;
+//      if (pAd->CommonCfg.bIEEE80211H != TRUE)
+//              return;
 
-	if ((pMeasureReportInfo = kmalloc(sizeof(MEASURE_RPI_REPORT), GFP_ATOMIC)) == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s unable to alloc memory for measure report buffer (size=%zu).\n", __func__, sizeof(MEASURE_RPI_REPORT)));
+	if ((pMeasureReportInfo =
+	     kmalloc(sizeof(MEASURE_RPI_REPORT), GFP_ATOMIC)) == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s unable to alloc memory for measure report buffer (size=%zu).\n",
+			  __func__, sizeof(MEASURE_RPI_REPORT)));
 		return;
 	}
 
 	NdisZeroMemory(&MeasureReportInfo, sizeof(MEASURE_REPORT_INFO));
 	NdisZeroMemory(pMeasureReportInfo, sizeof(MEASURE_RPI_REPORT));
-	if (PeerMeasureReportSanity(pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &MeasureReportInfo, pMeasureReportInfo))
-	{
+	if (PeerMeasureReportSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &MeasureReportInfo,
+	     pMeasureReportInfo)) {
 		do {
 			PMEASURE_REQ_ENTRY pEntry = NULL;
 
 			// Not a autonomous measure report.
 			// check the dialog token field. drop it if the dialog token doesn't match.
 			if ((DialogToken != 0)
-				&& ((pEntry = MeasureReqLookUp(pAd, DialogToken)) == NULL))
+			    && ((pEntry = MeasureReqLookUp(pAd, DialogToken)) ==
+				NULL))
 				break;
 
 			if (pEntry != NULL)
 				MeasureReqDelete(pAd, pEntry->DialogToken);
 
-			if (MeasureReportInfo.ReportType == RM_BASIC)
-			{
-				PMEASURE_BASIC_REPORT pBasicReport = (PMEASURE_BASIC_REPORT)pMeasureReportInfo;
+			if (MeasureReportInfo.ReportType == RM_BASIC) {
+				PMEASURE_BASIC_REPORT pBasicReport =
+				    (PMEASURE_BASIC_REPORT) pMeasureReportInfo;
 				if ((pBasicReport->Map.field.Radar)
-					&& (DfsRequirementCheck(pAd, pBasicReport->ChNum) == TRUE))
-				{
-					NotifyChSwAnnToPeerAPs(pAd, pFr->Hdr.Addr1, pFr->Hdr.Addr2, 1, pBasicReport->ChNum);
-					StartDFSProcedure(pAd, pBasicReport->ChNum, 1);
+				    &&
+				    (DfsRequirementCheck
+				     (pAd, pBasicReport->ChNum) == TRUE)) {
+					NotifyChSwAnnToPeerAPs(pAd,
+							       pFr->Hdr.Addr1,
+							       pFr->Hdr.Addr2,
+							       1,
+							       pBasicReport->
+							       ChNum);
+					StartDFSProcedure(pAd,
+							  pBasicReport->ChNum,
+							  1);
 				}
 			}
 		} while (FALSE);
-	}
-	else
-		DBGPRINT(RT_DEBUG_TRACE, ("Invalid Measurement Report Frame.\n"));
+	} else
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Invalid Measurement Report Frame.\n"));
 
 	kfree(pMeasureReportInfo);
 
@@ -1912,11 +1965,9 @@ static VOID PeerMeasureReportAction(
 	Return	: None.
 	==========================================================================
  */
-static VOID PeerTpcReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+static VOID PeerTpcReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	PFRAME_802_11 pFr = (PFRAME_802_11)Elem->Msg;
+	PFRAME_802_11 pFr = (PFRAME_802_11) Elem->Msg;
 	PUCHAR pFramePtr = pFr->Octet;
 	UINT8 DialogToken;
 	UINT8 TxPwr = GetCurTxPwr(pAd, Elem->Wcid);
@@ -1924,12 +1975,12 @@ static VOID PeerTpcReqAction(
 	CHAR RealRssi;
 
 	// link margin: Ratio of the received signal power to the minimum desired by the station (STA). The
-	//				STA may incorporate rate information and channel conditions, including interference, into its computation
-	//				of link margin.
+	//                              STA may incorporate rate information and channel conditions, including interference, into its computation
+	//                              of link margin.
 
 	RealRssi = RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0),
-								ConvertToRssi(pAd, Elem->Rssi1, RSSI_1),
-								ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
+			       ConvertToRssi(pAd, Elem->Rssi1, RSSI_1),
+			       ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
 
 	// skip Category and action code.
 	pFramePtr += 2;
@@ -1939,7 +1990,8 @@ static VOID PeerTpcReqAction(
 
 	LinkMargin = (RealRssi / MIN_RCV_PWR);
 	if (PeerTpcReqSanity(pAd, Elem->Msg, Elem->MsgLen, &DialogToken))
-		EnqueueTPCRep(pAd, pFr->Hdr.Addr2, DialogToken, TxPwr, LinkMargin);
+		EnqueueTPCRep(pAd, pFr->Hdr.Addr2, DialogToken, TxPwr,
+			      LinkMargin);
 
 	return;
 }
@@ -1955,22 +2007,21 @@ static VOID PeerTpcReqAction(
 	Return	: None.
 	==========================================================================
  */
-static VOID PeerTpcRepAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+static VOID PeerTpcRepAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	UINT8 DialogToken;
 	TPC_REPORT_INFO TpcRepInfo;
 	PTPC_REQ_ENTRY pEntry = NULL;
 
 	NdisZeroMemory(&TpcRepInfo, sizeof(TPC_REPORT_INFO));
-	if (PeerTpcRepSanity(pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &TpcRepInfo))
-	{
-		if ((pEntry = TpcReqLookUp(pAd, DialogToken)) != NULL)
-		{
+	if (PeerTpcRepSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, &DialogToken, &TpcRepInfo)) {
+		if ((pEntry = TpcReqLookUp(pAd, DialogToken)) != NULL) {
 			TpcReqDelete(pAd, pEntry->DialogToken);
-			DBGPRINT(RT_DEBUG_TRACE, ("%s: DialogToken=%x, TxPwr=%d, LinkMargin=%d\n",
-				__func__, DialogToken, TpcRepInfo.TxPwr, TpcRepInfo.LinkMargin));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("%s: DialogToken=%x, TxPwr=%d, LinkMargin=%d\n",
+				  __func__, DialogToken, TpcRepInfo.TxPwr,
+				  TpcRepInfo.LinkMargin));
 		}
 	}
 
@@ -1989,41 +2040,37 @@ static VOID PeerTpcRepAction(
 	Return	: None.
 	==========================================================================
  */
-VOID PeerSpectrumAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerSpectrumAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 
-	UCHAR	Action = Elem->Msg[LENGTH_802_11+1];
+	UCHAR Action = Elem->Msg[LENGTH_802_11 + 1];
 
 	if (pAd->CommonCfg.bIEEE80211H != TRUE)
 		return;
 
-	switch(Action)
-	{
-		case SPEC_MRQ:
-			// current rt2860 unable do such measure specified in Measurement Request.
-			// reject all measurement request.
-			PeerMeasureReqAction(pAd, Elem);
-			break;
-
-		case SPEC_MRP:
-			PeerMeasureReportAction(pAd, Elem);
-			break;
+	switch (Action) {
+	case SPEC_MRQ:
+		// current rt2860 unable do such measure specified in Measurement Request.
+		// reject all measurement request.
+		PeerMeasureReqAction(pAd, Elem);
+		break;
 
-		case SPEC_TPCRQ:
-			PeerTpcReqAction(pAd, Elem);
-			break;
+	case SPEC_MRP:
+		PeerMeasureReportAction(pAd, Elem);
+		break;
 
-		case SPEC_TPCRP:
-			PeerTpcRepAction(pAd, Elem);
-			break;
+	case SPEC_TPCRQ:
+		PeerTpcReqAction(pAd, Elem);
+		break;
 
-		case SPEC_CHANNEL_SWITCH:
+	case SPEC_TPCRP:
+		PeerTpcRepAction(pAd, Elem);
+		break;
 
+	case SPEC_CHANNEL_SWITCH:
 
-			PeerChSwAnnAction(pAd, Elem);
-			break;
+		PeerChSwAnnAction(pAd, Elem);
+		break;
 	}
 
 	return;
@@ -2038,9 +2085,7 @@ VOID PeerSpectrumAction(
 	Return	: None.
 	==========================================================================
  */
-INT Set_MeasureReq_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg)
+INT Set_MeasureReq_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 {
 	UINT Aid = 1;
 	UINT ArgIdx;
@@ -2059,42 +2104,43 @@ INT Set_MeasureReq_Proc(
 	NDIS_STATUS NStatus;
 	ULONG FrameLen;
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);  //Get an unused nonpaged memory
-	if(NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("%s() allocate memory failed \n", __func__));
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s() allocate memory failed \n", __func__));
 		goto END_OF_MEASURE_REQ;
 	}
 
 	ArgIdx = 1;
-	while ((thisChar = strsep((char **)&arg, "-")) != NULL)
-	{
-		switch(ArgIdx)
-		{
-			case 1:	// Aid.
-				Aid = (UINT8) simple_strtol(thisChar, 0, 16);
-				break;
+	while ((thisChar = strsep((char **)&arg, "-")) != NULL) {
+		switch (ArgIdx) {
+		case 1:	// Aid.
+			Aid = (UINT8) simple_strtol(thisChar, 0, 16);
+			break;
 
-			case 2: // Measurement Request Type.
-				MeasureReqType = simple_strtol(thisChar, 0, 16);
-				if (MeasureReqType > 3)
-				{
-					DBGPRINT(RT_DEBUG_ERROR, ("%s: unknow MeasureReqType(%d)\n", __func__, MeasureReqType));
-					goto END_OF_MEASURE_REQ;
-				}
-				break;
+		case 2:	// Measurement Request Type.
+			MeasureReqType = simple_strtol(thisChar, 0, 16);
+			if (MeasureReqType > 3) {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("%s: unknow MeasureReqType(%d)\n",
+					  __func__, MeasureReqType));
+				goto END_OF_MEASURE_REQ;
+			}
+			break;
 
-			case 3: // Measurement channel.
-				MeasureCh = (UINT8) simple_strtol(thisChar, 0, 16);
-				break;
+		case 3:	// Measurement channel.
+			MeasureCh = (UINT8) simple_strtol(thisChar, 0, 16);
+			break;
 		}
 		ArgIdx++;
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE, ("%s::Aid = %d, MeasureReqType=%d MeasureCh=%d\n", __func__, Aid, MeasureReqType, MeasureCh));
-	if (!VALID_WCID(Aid))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: unknow sta of Aid(%d)\n", __func__, Aid));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("%s::Aid = %d, MeasureReqType=%d MeasureCh=%d\n", __func__,
+		  Aid, MeasureReqType, MeasureCh));
+	if (!VALID_WCID(Aid)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: unknow sta of Aid(%d)\n", __func__, Aid));
 		goto END_OF_MEASURE_REQ;
 	}
 
@@ -2104,18 +2150,18 @@ INT Set_MeasureReq_Proc(
 	MeasureReqInsert(pAd, MeasureReqToken);
 
 	// build action frame header.
-	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pAd->MacTab.Content[Aid].Addr,
-						pAd->CurrentAddress);
+	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0,
+			 pAd->MacTab.Content[Aid].Addr, pAd->CurrentAddress);
 
-	NdisMoveMemory(pOutBuffer, (PCHAR)&ActHdr, sizeof(HEADER_802_11));
+	NdisMoveMemory(pOutBuffer, (PCHAR) & ActHdr, sizeof(HEADER_802_11));
 	FrameLen = sizeof(HEADER_802_11);
 
 	TotalLen = sizeof(MEASURE_REQ_INFO) + sizeof(MEASURE_REQ);
 
 	MakeMeasurementReqFrame(pAd, pOutBuffer, &FrameLen,
-		sizeof(MEASURE_REQ_INFO), CATEGORY_RM, RM_BASIC,
-		MeasureReqToken, MeasureReqMode.word,
-		MeasureReqType, 0);
+				sizeof(MEASURE_REQ_INFO), CATEGORY_RM, RM_BASIC,
+				MeasureReqToken, MeasureReqMode.word,
+				MeasureReqType, 0);
 
 	MeasureReq.ChNum = MeasureCh;
 	MeasureReq.MeasureStartTime = cpu2le64(MeasureStartTime);
@@ -2123,13 +2169,13 @@ INT Set_MeasureReq_Proc(
 
 	{
 		ULONG TempLen;
-		MakeOutgoingFrame(	pOutBuffer+FrameLen,	&TempLen,
-							sizeof(MEASURE_REQ),	&MeasureReq,
-							END_OF_ARGS);
+		MakeOutgoingFrame(pOutBuffer + FrameLen, &TempLen,
+				  sizeof(MEASURE_REQ), &MeasureReq,
+				  END_OF_ARGS);
 		FrameLen += TempLen;
 	}
 
-	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, (UINT)FrameLen);
+	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, (UINT) FrameLen);
 
 END_OF_MEASURE_REQ:
 	MlmeFreeMemory(pAd, pOutBuffer);
@@ -2137,9 +2183,7 @@ END_OF_MEASURE_REQ:
 	return TRUE;
 }
 
-INT Set_TpcReq_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg)
+INT Set_TpcReq_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 {
 	UINT Aid;
 
@@ -2148,9 +2192,9 @@ INT Set_TpcReq_Proc(
 	Aid = (UINT) simple_strtol(arg, 0, 16);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("%s::Aid = %d\n", __func__, Aid));
-	if (!VALID_WCID(Aid))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s: unknow sta of Aid(%d)\n", __func__, Aid));
+	if (!VALID_WCID(Aid)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: unknow sta of Aid(%d)\n", __func__, Aid));
 		return TRUE;
 	}
 
@@ -2160,4 +2204,3 @@ INT Set_TpcReq_Proc(
 
 	return TRUE;
 }
-
