From jmm@debian.org  Wed Feb 18 16:01:06 2009
From: Moritz Muehlenhoff <jmm@debian.org>
Date: Wed, 18 Feb 2009 19:50:08 +0100
Subject: Staging: wlan-ng: Remove more dead code from  p80211netdev.c
To: greg@kroah.com
Cc: Moritz Muehlenhoff <jmm@debian.org>
Message-ID: <1234983009-5290-2-git-send-email-jmm@debian.org>


Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/wlan-ng/p80211netdev.c |  264 ---------------------------------
 1 file changed, 264 deletions(-)

--- a/drivers/staging/wlan-ng/p80211netdev.c
+++ b/drivers/staging/wlan-ng/p80211netdev.c
@@ -101,11 +101,6 @@ static int p80211knetdev_open(netdevice_
 static int p80211knetdev_stop(netdevice_t *netdev);
 static int p80211knetdev_hard_start_xmit(struct sk_buff *skb,
 					 netdevice_t *netdev);
-static void p80211knetdev_set_multicast_list(netdevice_t *dev);
-static int p80211knetdev_do_ioctl(netdevice_t *dev, struct ifreq *ifr,
-				  int cmd);
-static int p80211knetdev_set_mac_address(netdevice_t *dev, void *addr);
-static void p80211knetdev_tx_timeout(netdevice_t *netdev);
 static int p80211_rx_typedrop(wlandevice_t *wlandev, u16 fc);
 
 int wlan_watchdog = 5000;
@@ -462,252 +457,6 @@ failed:
 }
 
 /*----------------------------------------------------------------
-* p80211knetdev_set_multicast_list
-*
-* Called from higher lavers whenever there's a need to set/clear
-* promiscuous mode or rewrite the multicast list.
-*
-* Arguments:
-*	none
-*
-* Returns:
-*	nothing
-----------------------------------------------------------------*/
-static void p80211knetdev_set_multicast_list(netdevice_t *dev)
-{
-	wlandevice_t *wlandev = dev->ml_priv;
-
-	/* TODO:  real multicast support as well */
-
-	if (wlandev->set_multicast_list)
-		wlandev->set_multicast_list(wlandev, dev);
-
-}
-
-#ifdef SIOCETHTOOL
-
-static int p80211netdev_ethtool(wlandevice_t *wlandev, void __user *useraddr)
-{
-	u32 ethcmd;
-	struct ethtool_drvinfo info;
-	struct ethtool_value edata;
-
-	memset(&info, 0, sizeof(info));
-	memset(&edata, 0, sizeof(edata));
-
-	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
-		return -EFAULT;
-
-	switch (ethcmd) {
-	case ETHTOOL_GDRVINFO:
-		info.cmd = ethcmd;
-		snprintf(info.driver, sizeof(info.driver), "p80211_%s",
-			 wlandev->nsdname);
-		snprintf(info.version, sizeof(info.version), "%s",
-			 WLAN_RELEASE);
-
-		if (copy_to_user(useraddr, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-#ifdef ETHTOOL_GLINK
-	case ETHTOOL_GLINK:
-		edata.cmd = ethcmd;
-
-		if (wlandev->linkstatus &&
-		    (wlandev->macmode != WLAN_MACMODE_NONE)) {
-			edata.data = 1;
-		} else {
-			edata.data = 0;
-		}
-
-		if (copy_to_user(useraddr, &edata, sizeof(edata)))
-			return -EFAULT;
-		return 0;
-	}
-#endif
-
-	return -EOPNOTSUPP;
-}
-
-#endif
-
-/*----------------------------------------------------------------
-* p80211knetdev_do_ioctl
-*
-* Handle an ioctl call on one of our devices.  Everything Linux
-* ioctl specific is done here.  Then we pass the contents of the
-* ifr->data to the request message handler.
-*
-* Arguments:
-*	dev	Linux kernel netdevice
-*	ifr	Our private ioctl request structure, typed for the
-*		generic struct ifreq so we can use ptr to func
-*		w/o cast.
-*
-* Returns:
-*	zero on success, a negative errno on failure.  Possible values:
-*		-ENETDOWN Device isn't up.
-*		-EBUSY	cmd already in progress
-*		-ETIME	p80211 cmd timed out (MSD may have its own timers)
-*		-EFAULT memory fault copying msg from user buffer
-*		-ENOMEM unable to allocate kernel msg buffer
-*		-ENOSYS	bad magic, it the cmd really for us?
-*		-EintR	sleeping on cmd, awakened by signal, cmd cancelled.
-*
-* Call Context:
-*	Process thread (ioctl caller).  TODO: SMP support may require
-*	locks.
-----------------------------------------------------------------*/
-static int p80211knetdev_do_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd)
-{
-	int result = 0;
-	p80211ioctl_req_t *req = (p80211ioctl_req_t *) ifr;
-	wlandevice_t *wlandev = dev->ml_priv;
-	u8 *msgbuf;
-
-	pr_debug("rx'd ioctl, cmd=%d, len=%d\n", cmd, req->len);
-
-#ifdef SIOCETHTOOL
-	if (cmd == SIOCETHTOOL) {
-		result =
-		    p80211netdev_ethtool(wlandev, (void __user *)ifr->ifr_data);
-		goto bail;
-	}
-#endif
-
-	/* Test the magic, assume ifr is good if it's there */
-	if (req->magic != P80211_IOCTL_MAGIC) {
-		result = -ENOSYS;
-		goto bail;
-	}
-
-	if (cmd == P80211_IFTEST) {
-		result = 0;
-		goto bail;
-	} else if (cmd != P80211_IFREQ) {
-		result = -ENOSYS;
-		goto bail;
-	}
-
-	/* Allocate a buf of size req->len */
-	if ((msgbuf = kmalloc(req->len, GFP_KERNEL))) {
-		if (copy_from_user(msgbuf, (void __user *)req->data, req->len))
-			result = -EFAULT;
-		else
-			result = p80211req_dorequest(wlandev, msgbuf);
-
-		if (result == 0) {
-			if (copy_to_user
-			    ((void __user *)req->data, msgbuf, req->len)) {
-				result = -EFAULT;
-			}
-		}
-		kfree(msgbuf);
-	} else {
-		result = -ENOMEM;
-	}
-bail:
-	return result;		/* If allocate,copyfrom or copyto fails, return errno */
-}
-
-/*----------------------------------------------------------------
-* p80211knetdev_set_mac_address
-*
-* Handles the ioctl for changing the MACAddress of a netdevice
-*
-* references: linux/netdevice.h and drivers/net/net_init.c
-*
-* NOTE: [MSM] We only prevent address changes when the netdev is
-* up.  We don't control anything based on dot11 state.  If the
-* address is changed on a STA that's currently associated, you
-* will probably lose the ability to send and receive data frames.
-* Just be aware.  Therefore, this should usually only be done
-* prior to scan/join/auth/assoc.
-*
-* Arguments:
-*	dev	netdevice struct
-*	addr	the new MACAddress (a struct)
-*
-* Returns:
-*	zero on success, a negative errno on failure.  Possible values:
-*		-EBUSY	device is bussy (cmd not possible)
-*		-and errors returned by: p80211req_dorequest(..)
-*
-* by: Collin R. Mulliner <collin@mulliner.org>
-----------------------------------------------------------------*/
-static int p80211knetdev_set_mac_address(netdevice_t *dev, void *addr)
-{
-	struct sockaddr *new_addr = addr;
-	p80211msg_dot11req_mibset_t dot11req;
-	p80211item_unk392_t *mibattr;
-	p80211item_pstr6_t *macaddr;
-	p80211item_uint32_t *resultcode;
-	int result = 0;
-
-	/* If we're running, we don't allow MAC address changes */
-	if (netif_running(dev))
-		return -EBUSY;
-
-	/* Set up some convenience pointers. */
-	mibattr = &dot11req.mibattribute;
-	macaddr = (p80211item_pstr6_t *)&mibattr->data;
-	resultcode = &dot11req.resultcode;
-
-	/* Set up a dot11req_mibset */
-	memset(&dot11req, 0, sizeof(p80211msg_dot11req_mibset_t));
-	dot11req.msgcode = DIDmsg_dot11req_mibset;
-	dot11req.msglen = sizeof(p80211msg_dot11req_mibset_t);
-	memcpy(dot11req.devname,
-	       ((wlandevice_t *) dev->ml_priv)->name, WLAN_DEVNAMELEN_MAX - 1);
-
-	/* Set up the mibattribute argument */
-	mibattr->did = DIDmsg_dot11req_mibset_mibattribute;
-	mibattr->status = P80211ENUM_msgitem_status_data_ok;
-	mibattr->len = sizeof(mibattr->data);
-
-	macaddr->did = DIDmib_dot11mac_dot11OperationTable_dot11MACAddress;
-	macaddr->status = P80211ENUM_msgitem_status_data_ok;
-	macaddr->len = sizeof(macaddr->data);
-	macaddr->data.len = ETH_ALEN;
-	memcpy(&macaddr->data.data, new_addr->sa_data, ETH_ALEN);
-
-	/* Set up the resultcode argument */
-	resultcode->did = DIDmsg_dot11req_mibset_resultcode;
-	resultcode->status = P80211ENUM_msgitem_status_no_value;
-	resultcode->len = sizeof(resultcode->data);
-	resultcode->data = 0;
-
-	/* now fire the request */
-	result = p80211req_dorequest(dev->ml_priv, (u8 *)&dot11req);
-
-	/* If the request wasn't successful, report an error and don't
-	 * change the netdev address
-	 */
-	if (result != 0 || resultcode->data != P80211ENUM_resultcode_success) {
-		printk(KERN_ERR
-		       "Low-level driver failed dot11req_mibset(dot11MACAddress).\n");
-		result = -EADDRNOTAVAIL;
-	} else {
-		/* everything's ok, change the addr in netdev */
-		memcpy(dev->dev_addr, new_addr->sa_data, dev->addr_len);
-	}
-
-	return result;
-}
-
-static int wlan_change_mtu(netdevice_t *dev, int new_mtu)
-{
-	/* 2312 is max 802.11 payload, 20 is overhead, (ether + llc +snap)
-	   and another 8 for wep. */
-	if ((new_mtu < 68) || (new_mtu > (2312 - 20 - 8)))
-		return -EINVAL;
-
-	dev->mtu = new_mtu;
-
-	return 0;
-}
-
-/*----------------------------------------------------------------
 * wlan_setup
 *
 * Roughly matches the functionality of ether_setup.  Here
@@ -1085,16 +834,3 @@ static int p80211_rx_typedrop(wlandevice
 	}
 	return drop;
 }
-
-static void p80211knetdev_tx_timeout(netdevice_t *netdev)
-{
-	wlandevice_t *wlandev = netdev->ml_priv;
-
-	if (wlandev->tx_timeout) {
-		wlandev->tx_timeout(wlandev);
-	} else {
-		printk(KERN_WARNING "Implement tx_timeout for %s\n",
-		       wlandev->nsdname);
-		netif_wake_queue(wlandev->netdev);
-	}
-}
