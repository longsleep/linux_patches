From mz.mzet@gmail.com  Thu Nov 19 11:51:43 2009
From: Mariusz Ziulek <mz.mzet@gmail.com>
Date: Thu, 12 Nov 2009 15:01:16 +0100
Subject: [PATCH 1/2] staging: dst: fix coding style
To: greg@kroah.com
Cc: Mariusz Ziulek <mz.mzet@gmail.com>
Message-ID: <1258034476-29197-1-git-send-email-mz.mzet@gmail.com>


From: Mariusz Ziulek <mz.mzet@gmail.com>


Signed-off-by: Mariusz Ziulek <mz.mzet@gmail.com>
Cc: Evgeniy Polyakov <zbr@ioremap.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/dst/crypto.c      |   64 +++++++++++++++++----------------
 drivers/staging/dst/dcore.c       |   26 +++++++------
 drivers/staging/dst/export.c      |   31 ++++++++--------
 drivers/staging/dst/state.c       |   73 ++++++++++++++++++++------------------
 drivers/staging/dst/thread_pool.c |   39 ++++++++++----------
 drivers/staging/dst/trans.c       |   18 +++++----
 6 files changed, 135 insertions(+), 116 deletions(-)

--- a/drivers/staging/dst/crypto.c
+++ b/drivers/staging/dst/crypto.c
@@ -64,7 +64,8 @@ err_out_exit:
 	return ERR_PTR(err);
 }
 
-static struct crypto_ablkcipher *dst_init_cipher(struct dst_crypto_ctl *ctl, u8 *key)
+static struct crypto_ablkcipher *dst_init_cipher(struct dst_crypto_ctl *ctl,
+		u8 *key)
 {
 	int err = -EINVAL;
 	struct crypto_ablkcipher *cipher;
@@ -105,7 +106,7 @@ static void dst_crypto_pages_free(struct
 {
 	unsigned int i;
 
-	for (i=0; i<e->page_num; ++i)
+	for (i = 0; i < e->page_num; ++i)
 		__free_page(e->pages[i]);
 	kfree(e->pages);
 }
@@ -118,7 +119,7 @@ static int dst_crypto_pages_alloc(struct
 	if (!e->pages)
 		return -ENOMEM;
 
-	for (i=0; i<num; ++i) {
+	for (i = 0; i < num; ++i) {
 		e->pages[i] = alloc_page(GFP_KERNEL);
 		if (!e->pages[i])
 			goto err_out_free_pages;
@@ -139,7 +140,8 @@ err_out_free_pages:
  * Initialize crypto engine for given node.
  * Setup cipher/hash, keys, pool of threads and private data.
  */
-static int dst_crypto_engine_init(struct dst_crypto_engine *e, struct dst_node *n)
+static int dst_crypto_engine_init(struct dst_crypto_engine *e,
+		struct dst_node *n)
 {
 	int err;
 	struct dst_crypto_ctl *ctl = &n->crypto;
@@ -198,8 +200,7 @@ static void dst_crypto_engine_exit(struc
 /*
  * Waiting for cipher processing to be completed.
  */
-struct dst_crypto_completion
-{
+struct dst_crypto_completion {
 	struct completion		complete;
 	int				error;
 };
@@ -237,17 +238,17 @@ static int dst_crypto_process(struct abl
 		err = crypto_ablkcipher_decrypt(req);
 
 	switch (err) {
-		case -EINPROGRESS:
-		case -EBUSY:
-			err = wait_for_completion_interruptible_timeout(&c.complete,
-					timeout);
-			if (!err)
-				err = -ETIMEDOUT;
-			else
-				err = c.error;
-			break;
-		default:
-			break;
+	case -EINPROGRESS:
+	case -EBUSY:
+		err = wait_for_completion_interruptible_timeout(&c.complete,
+				timeout);
+		if (!err)
+			err = -ETIMEDOUT;
+		else
+			err = c.error;
+		break;
+	default:
+		break;
 	}
 
 	return err;
@@ -263,7 +264,7 @@ static int dst_crypto_process(struct abl
  * temporary storage, which is then being sent to the remote peer.
  */
 static int dst_trans_iter_out(struct bio *bio, struct dst_crypto_engine *e,
-		int (* iterator) (struct dst_crypto_engine *e,
+		int (*iterator) (struct dst_crypto_engine *e,
 				  struct scatterlist *dst,
 				  struct scatterlist *src))
 {
@@ -286,7 +287,7 @@ static int dst_trans_iter_out(struct bio
 }
 
 static int dst_trans_iter_in(struct bio *bio, struct dst_crypto_engine *e,
-		int (* iterator) (struct dst_crypto_engine *e,
+		int (*iterator) (struct dst_crypto_engine *e,
 				  struct scatterlist *dst,
 				  struct scatterlist *src))
 {
@@ -411,9 +412,9 @@ static void dst_crypto_thread_cleanup(vo
  * Initialize crypto engine for given node: store keys, create pool
  * of threads, initialize each one.
  *
- * Each thread has unique ID, but 0 and 1 are reserved for receiving and accepting
- * threads (if export node), so IDs could start from 2, but starting them
- * from 10 allows easily understand what this thread is for.
+ * Each thread has unique ID, but 0 and 1 are reserved for receiving and
+ * accepting threads (if export node), so IDs could start from 2, but starting
+ * them from 10 allows easily understand what this thread is for.
  */
 int dst_node_crypto_init(struct dst_node *n, struct dst_crypto_ctl *ctl)
 {
@@ -436,10 +437,10 @@ int dst_node_crypto_init(struct dst_node
 	}
 	memcpy(&n->crypto, ctl, sizeof(struct dst_crypto_ctl));
 
-	for (i=0; i<ctl->thread_num; ++i) {
+	for (i = 0; i < ctl->thread_num; ++i) {
 		snprintf(name, sizeof(name), "%s-crypto-%d", n->name, i);
 		/* Unique ids... */
-		err = thread_pool_add_worker(n->pool, name, i+10,
+		err = thread_pool_add_worker(n->pool, name, i + 10,
 			dst_crypto_thread_init, dst_crypto_thread_cleanup, n);
 		if (err)
 			goto err_out_free_threads;
@@ -496,8 +497,8 @@ static void dst_dump_bio(struct bio *bio
 				bv->bv_len, bv->bv_offset);
 
 		p = kmap(bv->bv_page) + bv->bv_offset;
-		for (i=0; i<bv->bv_len; ++i)
-			printk("%02x ", p[i]);
+		for (i = 0; i < bv->bv_len; ++i)
+			printk(KERN_DEBUG "%02x ", p[i]);
 		kunmap(bv->bv_page);
 		printk("\n");
 	}
@@ -532,7 +533,7 @@ static int dst_crypto_process_sending(st
 			printk(KERN_DEBUG "%s: bio: %llu/%u, rw: %lu, hash: ",
 				__func__, (u64)bio->bi_sector,
 				bio->bi_size, bio_data_dir(bio));
-			for (i=0; i<crypto_hash_digestsize(e->hash); ++i)
+			for (i = 0; i < crypto_hash_digestsize(e->hash); ++i)
 					printk("%02x ", hash[i]);
 			printk("\n");
 		}
@@ -572,9 +573,9 @@ static int dst_crypto_process_receiving(
 			unsigned int i;
 
 			printk(", recv/calc: ");
-			for (i=0; i<crypto_hash_digestsize(e->hash); ++i) {
+			for (i = 0; i < crypto_hash_digestsize(e->hash); ++i)
 				printk("%02x/%02x ", recv_hash[i], hash[i]);
-			}
+
 		}
 		printk("\n");
 #endif
@@ -680,8 +681,9 @@ static int dst_export_crypto_action(void
 	struct dst_export_priv *p = bio->bi_private;
 	int err;
 
-	dprintk("%s: e: %p, data: %p, bio: %llu/%u, dir: %lu.\n", __func__,
-		e, e->data, (u64)bio->bi_sector, bio->bi_size, bio_data_dir(bio));
+	dprintk("%s: e: %p, data: %p, bio: %llu/%u, dir: %lu.\n",
+			__func__, e, e->data, (u64)bio->bi_sector,
+			bio->bi_size, bio_data_dir(bio));
 
 	e->enc = (bio_data_dir(bio) == READ);
 	e->iv = p->cmd.id;
--- a/drivers/staging/dst/dcore.c
+++ b/drivers/staging/dst/dcore.c
@@ -116,7 +116,7 @@ static int dst_request(struct request_qu
 		 * bio_rw_flagged(bio, BIO_RW_DISCARD) only, which does not
 		 * work in this case.
 		 */
-		//err = -EOPNOTSUPP;
+		/* err = -EOPNOTSUPP; */
 		err = 0;
 		goto end_io;
 	}
@@ -197,7 +197,8 @@ static int dst_node_create_disk(struct d
 	n->disk->fops = &dst_blk_ops;
 	n->disk->queue = n->queue;
 	n->disk->private_data = n;
-	snprintf(n->disk->disk_name, sizeof(n->disk->disk_name), "dst-%s", n->name);
+	snprintf(n->disk->disk_name, sizeof(n->disk->disk_name),
+			"dst-%s", n->name);
 
 	return 0;
 
@@ -246,7 +247,8 @@ static ssize_t dst_show_type(struct devi
 		return sprintf(buf, "%u.%u.%u.%u:%d\n",
 			NIPQUAD(sin->sin_addr.s_addr), ntohs(sin->sin_port));
 	} else if (family == AF_INET6) {
-		struct sockaddr_in6 *sin = (struct sockaddr_in6 *)&info->net.addr;
+		struct sockaddr_in6 *sin = (struct sockaddr_in6 *)
+				&info->net.addr;
 		return sprintf(buf,
 			"%pi6:%d\n",
 			&sin->sin6_addr, ntohs(sin->sin6_port));
@@ -261,7 +263,7 @@ static ssize_t dst_show_type(struct devi
 		sz -= size;
 		buf += size;
 
-		for (i=0; i<addrlen; ++i) {
+		for (i = 0; i < addrlen; ++i) {
 			if (sz < 3)
 				break;
 
@@ -286,7 +288,7 @@ static int dst_create_node_attributes(st
 {
 	int err, i;
 
-	for (i=0; i<ARRAY_SIZE(dst_node_attrs); ++i) {
+	for (i = 0; i < ARRAY_SIZE(dst_node_attrs); ++i) {
 		err = device_create_file(&n->info->device,
 				&dst_node_attrs[i]);
 		if (err)
@@ -306,7 +308,7 @@ static void dst_remove_node_attributes(s
 {
 	int i;
 
-	for (i=0; i<ARRAY_SIZE(dst_node_attrs); ++i)
+	for (i = 0; i < ARRAY_SIZE(dst_node_attrs); ++i)
 		device_remove_file(&n->info->device,
 				&dst_node_attrs[i]);
 }
@@ -358,7 +360,7 @@ err_out_exit:
  */
 static inline unsigned int dst_hash(char *str, unsigned int size)
 {
-	return (jhash(str, size, 0) % dst_hashtable_size);
+	return jhash(str, size, 0) % dst_hashtable_size;
 }
 
 static void dst_node_remove(struct dst_node *n)
@@ -641,7 +643,8 @@ static int dst_start_remote(struct dst_n
 	dst_node_set_size(n);
 	add_disk(n->disk);
 
-	dprintk("DST: started remote node '%s', minor: %d.\n", n->name, n->disk->first_minor);
+	dprintk("DST: started remote node '%s', minor: %d.\n",
+			n->name, n->disk->first_minor);
 
 	return 0;
 }
@@ -740,7 +743,8 @@ static int dst_node_remove_unload(struct
 	 * counter will be equal to 1),
 	 * and subsequent dst_node_put() calls will free the node.
 	 */
-	dprintk("%s: going to sleep with %d refcnt.\n", __func__, atomic_read(&n->refcnt));
+	dprintk("%s: going to sleep with %d refcnt.\n",
+			__func__, atomic_read(&n->refcnt));
 	wait_event(n->wait, atomic_read(&n->refcnt) <= 2);
 
 	dst_node_put(n);
@@ -921,7 +925,7 @@ static int __init dst_hashtable_init(voi
 	if (!dst_hashtable)
 		return -ENOMEM;
 
-	for (i=0; i<dst_hashtable_size; ++i)
+	for (i = 0; i < dst_hashtable_size; ++i)
 		INIT_LIST_HEAD(&dst_hashtable[i]);
 
 	return 0;
@@ -932,7 +936,7 @@ static void dst_hashtable_exit(void)
 	unsigned int i;
 	struct dst_node *n, *tmp;
 
-	for (i=0; i<dst_hashtable_size; ++i) {
+	for (i = 0; i < dst_hashtable_size; ++i) {
 		list_for_each_entry_safe(n, tmp, &dst_hashtable[i], node_entry) {
 			dst_node_remove_unload(n);
 		}
--- a/drivers/staging/dst/export.c
+++ b/drivers/staging/dst/export.c
@@ -53,7 +53,8 @@ void dst_export_exit(void)
  * its permissions are checked in a security attributes and sent
  * back.
  */
-static unsigned int dst_check_permissions(struct dst_state *main, struct dst_state *st)
+static unsigned int dst_check_permissions(struct dst_state *main,
+		struct dst_state *st)
 {
 	struct dst_node *n = main->node;
 	struct dst_secure *sentry;
@@ -73,9 +74,9 @@ static unsigned int dst_check_permission
 
 		/*
 		 * This '2' below is a port field. This may be very wrong to do
-		 * in atalk for example though. If there will be any need to extent
-		 * protocol to something else, I can create per-family helpers and
-		 * use them instead of this memcmp.
+		 * in atalk for example though. If there will be any need
+		 * to extent protocol to something else, I can create
+		 * per-family helpers and use them instead of this memcmp.
 		 */
 		if (memcmp(s->addr.sa_data + 2, sa->sa_data + 2,
 					sa->sa_data_len - 2))
@@ -125,8 +126,8 @@ static struct dst_state *dst_accept_clie
 				 * Magic HZ? Polling check above is not safe in
 				 * all cases (like socket reset in BH context),
 				 * so it is simpler just to postpone it to the
-				 * process context instead of implementing special
-				 * locking there.
+				 * process context instead of implementing
+				 * special locking there.
 				 */
 				schedule_timeout(HZ);
 			}
@@ -272,8 +273,8 @@ static void dst_state_cleanup_export(str
 			if (p)
 				bio_put(p->bio);
 
-			dprintk("%s: st: %p, refcnt: %d, list_empty: %d, p: %p.\n",
-				__func__, st, atomic_read(&st->refcnt),
+			dprintk("%s: st: %p, refcnt: %d, list_empty: %d, p: "
+				"%p.\n", __func__, st, atomic_read(&st->refcnt),
 				list_empty(&st->request_list), p);
 		}
 	}
@@ -303,9 +304,9 @@ static int dst_accept(void *init_data, v
 		if (!err) {
 			while (n->trans_scan_timeout) {
 				err = wait_event_interruptible_timeout(st->thread_wait,
-						!list_empty(&st->request_list) ||
-						!n->trans_scan_timeout ||
-						st->need_exit,
+					!list_empty(&st->request_list) ||
+					!n->trans_scan_timeout ||
+					st->need_exit,
 					HZ);
 
 				if (!n->trans_scan_timeout || st->need_exit)
@@ -341,8 +342,9 @@ static int dst_accept(void *init_data, v
 int dst_start_export(struct dst_node *n)
 {
 	if (list_empty(&n->security_list)) {
-		printk(KERN_ERR "You are trying to export node '%s' without security attributes.\n"
-				"No clients will be allowed to connect. Exiting.\n", n->name);
+		printk(KERN_ERR "You are trying to export node '%s' "
+				"without security attributes.\nNo clients will "
+				"be allowed to connect. Exiting.\n", n->name);
 		return -EINVAL;
 	}
 	return dst_node_trans_init(n, sizeof(struct dst_export_priv));
@@ -552,7 +554,8 @@ int dst_process_io(struct dst_state *st)
 	if (!bio)
 		goto err_out_exit;
 
-	priv = (struct dst_export_priv *)(((void *)bio) - sizeof (struct dst_export_priv));
+	priv = (struct dst_export_priv *)(((void *)bio) -
+			sizeof (struct dst_export_priv));
 
 	priv->state = dst_state_get(st);
 	priv->bio = bio;
--- a/drivers/staging/dst/state.c
+++ b/drivers/staging/dst/state.c
@@ -30,13 +30,13 @@
  * Polling machinery.
  */
 
-struct dst_poll_helper
-{
-	poll_table 		pt;
+struct dst_poll_helper {
+	poll_table		pt;
 	struct dst_state	*st;
 };
 
-static int dst_queue_wake(wait_queue_t *wait, unsigned mode, int sync, void *key)
+static int dst_queue_wake(wait_queue_t *wait, unsigned mode,
+		int sync, void *key)
 {
 	struct dst_state *st = container_of(wait, struct dst_state, wait);
 
@@ -92,7 +92,7 @@ static int dst_data_recv_header(struct s
 	msg.msg_namelen = 0;
 	msg.msg_control = NULL;
 	msg.msg_controllen = 0;
-	msg.msg_flags = (block)?MSG_WAITALL:MSG_DONTWAIT;
+	msg.msg_flags = (block) ? MSG_WAITALL : MSG_DONTWAIT;
 
 	err = kernel_recvmsg(sock, &msg, &iov, 1, iov.iov_len,
 			msg.msg_flags);
@@ -217,8 +217,8 @@ void dst_dump_addr(struct socket *sk, st
 {
 	if (sk->ops->family == AF_INET) {
 		struct sockaddr_in *sin = (struct sockaddr_in *)sa;
-		printk(KERN_INFO "%s %u.%u.%u.%u:%d.\n",
-			str, NIPQUAD(sin->sin_addr.s_addr), ntohs(sin->sin_port));
+		printk(KERN_INFO "%s %u.%u.%u.%u:%d.\n", str,
+			NIPQUAD(sin->sin_addr.s_addr), ntohs(sin->sin_port));
 	} else if (sk->ops->family == AF_INET6) {
 		struct sockaddr_in6 *sin = (struct sockaddr_in6 *)sa;
 		printk(KERN_INFO "%s %pi6:%d",
@@ -271,13 +271,13 @@ err_out_exit:
  * State reset is used to reconnect to the remote peer.
  * May fail, but who cares, we will try again later.
  */
-static void inline dst_state_reset_nolock(struct dst_state *st)
+static inline void dst_state_reset_nolock(struct dst_state *st)
 {
 	dst_state_exit_connected(st);
 	dst_state_init_connected(st);
 }
 
-static void inline dst_state_reset(struct dst_state *st)
+static inline void dst_state_reset(struct dst_state *st)
 {
 	dst_state_lock(st);
 	dst_state_reset_nolock(st);
@@ -335,9 +335,11 @@ static int dst_send_ping(struct dst_stat
 
 		cmd->cmd = __cpu_to_be32(DST_PING);
 
-		err = dst_data_send_header(st->socket, cmd, sizeof(struct dst_cmd), 0);
+		err = dst_data_send_header(st->socket, cmd,
+				sizeof(struct dst_cmd), 0);
 	}
-	dprintk("%s: st: %p, socket: %p, err: %d.\n", __func__, st, st->socket, err);
+	dprintk("%s: st: %p, socket: %p, err: %d.\n", __func__,
+			st, st->socket, err);
 	dst_state_unlock(st);
 
 	return err;
@@ -390,8 +392,7 @@ int dst_data_recv(struct dst_state *st, 
 		err = -ECONNRESET;
 		dst_state_lock(st);
 
-		if (		st->socket &&
-				(st->read_socket == st->socket) &&
+		if (st->socket && (st->read_socket == st->socket) &&
 				(revents & POLLIN)) {
 			err = dst_data_recv_raw(st, data, size);
 			if (err > 0) {
@@ -402,8 +403,9 @@ int dst_data_recv(struct dst_state *st, 
 		}
 
 		if (revents & err_mask || !st->socket) {
-			dprintk("%s: revents: %x, socket: %p, size: %u, err: %d.\n",
-					__func__, revents, st->socket, size, err);
+			dprintk("%s: revents: %x, socket: %p, size: %u, "
+					"err: %d.\n", __func__, revents,
+					st->socket, size, err);
 			err = -ECONNRESET;
 		}
 
@@ -440,7 +442,8 @@ static int dst_process_cfg(struct dst_st
 /*
  * Receive block IO from the network.
  */
-static int dst_recv_bio(struct dst_state *st, struct bio *bio, unsigned int total_size)
+static int dst_recv_bio(struct dst_state *st, struct bio *bio,
+		unsigned int total_size)
 {
 	struct bio_vec *bv;
 	int i, err;
@@ -450,9 +453,10 @@ static int dst_recv_bio(struct dst_state
 	bio_for_each_segment(bv, bio, i) {
 		sz = min(total_size, bv->bv_len);
 
-		dprintk("%s: bio: %llu/%u, total: %u, len: %u, sz: %u, off: %u.\n",
-			__func__, (u64)bio->bi_sector, bio->bi_size, total_size,
-			bv->bv_len, sz, bv->bv_offset);
+		dprintk("%s: bio: %llu/%u, total: %u, len: %u, sz: %u, "
+				"off: %u.\n", __func__, (u64)bio->bi_sector,
+				bio->bi_size, total_size, bv->bv_len, sz,
+				bv->bv_offset);
 
 		data = kmap(bv->bv_page) + bv->bv_offset;
 		err = dst_data_recv(st, data, sz);
@@ -590,7 +594,8 @@ static int dst_recv_processing(struct ds
 			cmd->flags, cmd->rw);
 
 	/*
-	 * This should catch protocol breakage and random garbage instead of commands.
+	 * This should catch protocol breakage and random garbage
+	 * instead of commands.
 	 */
 	if (unlikely(cmd->csize > st->size - sizeof(struct dst_cmd))) {
 		err = -EBADMSG;
@@ -599,20 +604,20 @@ static int dst_recv_processing(struct ds
 
 	err = -EPROTO;
 	switch (cmd->cmd) {
-		case DST_IO_RESPONSE:
-			err = dst_process_io_response(st);
-			break;
-		case DST_IO:
-			err = dst_process_io(st);
-			break;
-		case DST_CFG:
-			err = dst_process_cfg(st);
-			break;
-		case DST_PING:
-			err = 0;
-			break;
-		default:
-			break;
+	case DST_IO_RESPONSE:
+		err = dst_process_io_response(st);
+		break;
+	case DST_IO:
+		err = dst_process_io(st);
+		break;
+	case DST_CFG:
+		err = dst_process_cfg(st);
+		break;
+	case DST_PING:
+		err = 0;
+		break;
+	default:
+		break;
 	}
 
 out_exit:
--- a/drivers/staging/dst/thread_pool.c
+++ b/drivers/staging/dst/thread_pool.c
@@ -30,8 +30,7 @@
  * When action is being performed, thread can not be used by other users,
  * instead they will sleep until there is free thread to pick their work.
  */
-struct thread_pool_worker
-{
+struct thread_pool_worker {
 	struct list_head	worker_entry;
 
 	struct task_struct	*thread;
@@ -48,8 +47,8 @@ struct thread_pool_worker
 	void			*private;
 	void			*schedule_data;
 
-	int			(* action)(void *private, void *schedule_data);
-	void			(* cleanup)(void *private);
+	int			(*action)(void *private, void *schedule_data);
+	void			(*cleanup)(void *private);
 };
 
 static void thread_pool_exit_worker(struct thread_pool_worker *w)
@@ -116,10 +115,12 @@ void thread_pool_del_worker(struct threa
 	struct thread_pool_worker *w = NULL;
 
 	while (!w && p->thread_num) {
-		wait_event(p->wait, !list_empty(&p->ready_list) || !p->thread_num);
+		wait_event(p->wait, !list_empty(&p->ready_list) ||
+				!p->thread_num);
 
 		dprintk("%s: locking list_empty: %d, thread_num: %d.\n",
-				__func__, list_empty(&p->ready_list), p->thread_num);
+				__func__, list_empty(&p->ready_list),
+				p->thread_num);
 
 		mutex_lock(&p->thread_lock);
 		if (!list_empty(&p->ready_list)) {
@@ -127,8 +128,9 @@ void thread_pool_del_worker(struct threa
 					struct thread_pool_worker,
 					worker_entry);
 
-			dprintk("%s: deleting w: %p, thread_num: %d, list: %p [%p.%p].\n",
-					__func__, w, p->thread_num, &p->ready_list,
+			dprintk("%s: deleting w: %p, thread_num: %d, "
+					"list: %p [%p.%p].\n", __func__,
+					w, p->thread_num, &p->ready_list,
 					p->ready_list.prev, p->ready_list.next);
 
 			p->thread_num--;
@@ -182,8 +184,8 @@ void thread_pool_del_worker_id(struct th
 int thread_pool_add_worker(struct thread_pool *p,
 		char *name,
 		unsigned int id,
-		void *(* init)(void *private),
-		void (* cleanup)(void *private),
+		void *(*init)(void *private),
+		void (*cleanup)(void *private),
 		void *private)
 {
 	struct thread_pool_worker *w;
@@ -243,8 +245,8 @@ void thread_pool_destroy(struct thread_p
  * They will have sequential IDs started from zero.
  */
 struct thread_pool *thread_pool_create(int num, char *name,
-		void *(* init)(void *private),
-		void (* cleanup)(void *private),
+		void *(*init)(void *private),
+		void (*cleanup)(void *private),
 		void *private)
 {
 	struct thread_pool_worker *w, *tmp;
@@ -262,7 +264,7 @@ struct thread_pool *thread_pool_create(i
 	INIT_LIST_HEAD(&p->active_list);
 	p->thread_num = 0;
 
-	for (i=0; i<num; ++i) {
+	for (i = 0; i < num; ++i) {
 		err = thread_pool_add_worker(p, name, i, init,
 				cleanup, private);
 		if (err)
@@ -287,8 +289,8 @@ err_out_exit:
  * private data.
  */
 int thread_pool_schedule_private(struct thread_pool *p,
-		int (* setup)(void *private, void *data),
-		int (* action)(void *private, void *data),
+		int (*setup)(void *private, void *data),
+		int (*action)(void *private, void *data),
 		void *data, long timeout, void *id)
 {
 	struct thread_pool_worker *w, *tmp, *worker = NULL;
@@ -321,7 +323,8 @@ int thread_pool_schedule_private(struct 
 				w->has_data = 1;
 				wake_up(&w->wait);
 			} else {
-				list_move_tail(&w->worker_entry, &p->ready_list);
+				list_move_tail(&w->worker_entry,
+						&p->ready_list);
 			}
 
 			break;
@@ -336,8 +339,8 @@ int thread_pool_schedule_private(struct 
  * Schedule execution on arbitrary thread from the pool.
  */
 int thread_pool_schedule(struct thread_pool *p,
-		int (* setup)(void *private, void *data),
-		int (* action)(void *private, void *data),
+		int (*setup)(void *private, void *data),
+		int (*action)(void *private, void *data),
 		void *data, long timeout)
 {
 	return thread_pool_schedule_private(p, setup,
--- a/drivers/staging/dst/trans.c
+++ b/drivers/staging/dst/trans.c
@@ -58,7 +58,7 @@ struct dst_trans *dst_trans_search(struc
 	}
 
 	dprintk("%s: %s transaction: id: %llu.\n", __func__,
-			(ret)?"found":"not found", gen);
+			(ret) ? "found" : "not found", gen);
 
 	return ret;
 }
@@ -88,9 +88,9 @@ static int dst_trans_insert(struct dst_t
 
 	new->send_time = jiffies;
 	if (ret) {
-		printk("%s: exist: old: gen: %llu, bio: %llu/%u, send_time: %lu, "
-				"new: gen: %llu, bio: %llu/%u, send_time: %lu.\n",
-			__func__,
+		printk(KERN_DEBUG "%s: exist: old: gen: %llu, bio: %llu/%u, "
+			"send_time: %lu, new: gen: %llu, bio: %llu/%u, "
+			"send_time: %lu.\n", __func__,
 			ret->gen, (u64)ret->bio->bi_sector,
 			ret->bio->bi_size, ret->send_time,
 			new->gen, (u64)new->bio->bi_sector,
@@ -206,7 +206,8 @@ err_out_exit:
  */
 static void dst_trans_scan(struct work_struct *work)
 {
-	struct dst_node *n = container_of(work, struct dst_node, trans_work.work);
+	struct dst_node *n = container_of(work, struct dst_node,
+			trans_work.work);
 	struct rb_node *rb_node;
 	struct dst_trans *t;
 	unsigned long timeout = n->trans_scan_timeout;
@@ -246,8 +247,8 @@ static void dst_trans_scan(struct work_s
 	mutex_unlock(&n->trans_lock);
 
 	/*
-	 * If no timeout specified then system is in the middle of exiting process,
-	 * so no need to reschedule scanning process again.
+	 * If no timeout specified then system is in the middle of exiting
+	 * process, so no need to reschedule scanning process again.
 	 */
 	if (timeout) {
 		if (!num)
@@ -313,7 +314,8 @@ int dst_node_trans_init(struct dst_node 
 	if (!n->trans_cache)
 		goto err_out_exit;
 
-	n->trans_pool = mempool_create_slab_pool(dst_mempool_num, n->trans_cache);
+	n->trans_pool = mempool_create_slab_pool(dst_mempool_num,
+			n->trans_cache);
 	if (!n->trans_pool)
 		goto err_out_cache_destroy;
 
