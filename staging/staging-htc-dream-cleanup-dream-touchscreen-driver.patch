From pavel@ucw.cz  Mon Jul 27 08:44:02 2009
From: Pavel Machek <pavel@ucw.cz>
Date: Mon, 20 Jul 2009 23:59:11 +0200
Subject: Staging: HTC Dream: Cleanup Dream touchscreen driver
To: greg@kroah.com, swetland@google.com, arve@android.com
Message-ID: <20090720215911.GA21429@elf.ucw.cz>

From: Pavel Machek <pavel@ucw.cz>

This is first part of touchscreen cleanups. I did not remove
earlysuspend functionality for now (to help Google merge the changes).

I mainly introduced helpers to reduce code duplication, and split huge
functions into smaller ones.

Signed-off-by: Pavel Machek <pavel@ucw.cz>
Cc: Arve Hjønnevåg <arve@android.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/dream/synaptics_i2c_rmi.c |  362 ++++++++++++++----------------
 1 file changed, 180 insertions(+), 182 deletions(-)

--- a/drivers/staging/dream/synaptics_i2c_rmi.c
+++ b/drivers/staging/dream/synaptics_i2c_rmi.c
@@ -1,6 +1,8 @@
-/* drivers/input/keyboard/synaptics_i2c_rmi.c
+/*
+ * Support for synaptics touchscreen.
  *
  * Copyright (C) 2007 Google, Inc.
+ * Author: Arve Hjønnevåg <arve@android.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -15,6 +17,9 @@
 
 #include <linux/module.h>
 #include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
 #include <linux/hrtimer.h>
 #include <linux/i2c.h>
 #include <linux/input.h>
@@ -23,18 +28,16 @@
 #include <linux/platform_device.h>
 #include "synaptics_i2c_rmi.h"
 
-#define swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
-
 static struct workqueue_struct *synaptics_wq;
 
 struct synaptics_ts_data {
-	uint16_t addr;
+	u16 addr;
 	struct i2c_client *client;
 	struct input_dev *input_dev;
 	int use_irq;
 	struct hrtimer timer;
 	struct work_struct  work;
-	uint16_t max[2];
+	u16 max[2];
 	int snap_state[2][2];
 	int snap_down_on[2];
 	int snap_down_off[2];
@@ -42,13 +45,28 @@ struct synaptics_ts_data {
 	int snap_up_off[2];
 	int snap_down[2];
 	int snap_up[2];
-	uint32_t flags;
+	u32 flags;
 	int (*power)(int on);
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	struct early_suspend early_suspend;
 #endif
 };
 
+static int i2c_set(struct synaptics_ts_data *ts, u8 reg, u8 val, char *msg)
+{
+	int ret = i2c_smbus_write_byte_data(ts->client, reg, val);
+	if (ret < 0)
+		pr_err("i2c_smbus_write_byte_data failed (%s)\n", msg);
+	return ret;
+}
+
+static int i2c_read(struct synaptics_ts_data *ts, u8 reg, char *msg)
+{
+	int ret = i2c_smbus_read_byte_data(ts->client, reg);
+	if (ret < 0)
+		pr_err("i2c_smbus_read_byte_data failed (%s)\n", msg);
+	return ret;
+}
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void synaptics_ts_early_suspend(struct early_suspend *h);
 static void synaptics_ts_late_resume(struct early_suspend *h);
@@ -58,150 +76,119 @@ static int synaptics_init_panel(struct s
 {
 	int ret;
 
-	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
-	if (ret < 0) {
-		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
-		goto err_page_select_failed;
-	}
-	ret = i2c_smbus_write_byte_data(ts->client, 0x41, 0x04); /* Set "No Clip Z" */
-	if (ret < 0)
-		printk(KERN_ERR "i2c_smbus_write_byte_data failed for No Clip Z\n");
+	ret = i2c_set(ts, 0xff, 0x10, "set page select");
+	if (ret == 0)
+		ret = i2c_set(ts, 0x41, 0x04, "set No Clip Z");
 
-err_page_select_failed:
-	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x04); /* page select = 0x04 */
-	if (ret < 0)
-		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
-	ret = i2c_smbus_write_byte_data(ts->client, 0xf0, 0x81); /* normal operation, 80 reports per second */
-	if (ret < 0)
-		printk(KERN_ERR "synaptics_ts_resume: i2c_smbus_write_byte_data failed\n");
+	ret = i2c_set(ts, 0xff, 0x04, "fallback page select");
+	ret = i2c_set(ts, 0xf0, 0x81, "select 80 reports per second");
 	return ret;
 }
 
+static void decode_report(struct synaptics_ts_data *ts, u8 *buf)
+{
+	int pos[2][2];
+	int f, a;
+	int base = 2;
+	int z = buf[1];
+	int w = buf[0] >> 4;
+	int finger = buf[0] & 7;
+	int finger2_pressed;
+
+	for (f = 0; f < 2; f++) {
+		u32 flip_flag = SYNAPTICS_FLIP_X;
+		for (a = 0; a < 2; a++) {
+			int p = buf[base + 1];
+			p |= (u16)(buf[base] & 0x1f) << 8;
+			if (ts->flags & flip_flag)
+				p = ts->max[a] - p;
+			if (ts->flags & SYNAPTICS_SNAP_TO_INACTIVE_EDGE) {
+				if (ts->snap_state[f][a]) {
+					if (p <= ts->snap_down_off[a])
+						p = ts->snap_down[a];
+					else if (p >= ts->snap_up_off[a])
+						p = ts->snap_up[a];
+					else
+						ts->snap_state[f][a] = 0;
+				} else {
+					if (p <= ts->snap_down_on[a]) {
+						p = ts->snap_down[a];
+						ts->snap_state[f][a] = 1;
+					} else if (p >= ts->snap_up_on[a]) {
+						p = ts->snap_up[a];
+						ts->snap_state[f][a] = 1;
+					}
+				}
+			}
+			pos[f][a] = p;
+			base += 2;
+			flip_flag <<= 1;
+		}
+		base += 2;
+		if (ts->flags & SYNAPTICS_SWAP_XY)
+			swap(pos[f][0], pos[f][1]);
+	}
+	if (z) {
+		input_report_abs(ts->input_dev, ABS_X, pos[0][0]);
+		input_report_abs(ts->input_dev, ABS_Y, pos[0][1]);
+	}
+	input_report_abs(ts->input_dev, ABS_PRESSURE, z);
+	input_report_abs(ts->input_dev, ABS_TOOL_WIDTH, w);
+	input_report_key(ts->input_dev, BTN_TOUCH, finger);
+	finger2_pressed = finger > 1 && finger != 7;
+	input_report_key(ts->input_dev, BTN_2, finger2_pressed);
+	if (finger2_pressed) {
+		input_report_abs(ts->input_dev, ABS_HAT0X, pos[1][0]);
+		input_report_abs(ts->input_dev, ABS_HAT0Y, pos[1][1]);
+	}
+	input_sync(ts->input_dev);
+}
+
 static void synaptics_ts_work_func(struct work_struct *work)
 {
 	int i;
 	int ret;
 	int bad_data = 0;
 	struct i2c_msg msg[2];
-	uint8_t start_reg;
-	uint8_t buf[15];
-	struct synaptics_ts_data *ts = container_of(work, struct synaptics_ts_data, work);
+	u8 start_reg = 0;
+	u8 buf[15];
+	struct synaptics_ts_data *ts =
+		container_of(work, struct synaptics_ts_data, work);
 
 	msg[0].addr = ts->client->addr;
 	msg[0].flags = 0;
 	msg[0].len = 1;
 	msg[0].buf = &start_reg;
-	start_reg = 0x00;
 	msg[1].addr = ts->client->addr;
 	msg[1].flags = I2C_M_RD;
 	msg[1].len = sizeof(buf);
 	msg[1].buf = buf;
 
-	/* printk("synaptics_ts_work_func\n"); */
 	for (i = 0; i < ((ts->use_irq && !bad_data) ? 1 : 10); i++) {
 		ret = i2c_transfer(ts->client->adapter, msg, 2);
 		if (ret < 0) {
-			printk(KERN_ERR "synaptics_ts_work_func: i2c_transfer failed\n");
+			pr_err("ts_work: i2c_transfer failed\n");
 			bad_data = 1;
-		} else {
-			/* printk("synaptics_ts_work_func: %x %x %x %x %x %x" */
-			/*        " %x %x %x %x %x %x %x %x %x, ret %d\n", */
-			/*        buf[0], buf[1], buf[2], buf[3], */
-			/*        buf[4], buf[5], buf[6], buf[7], */
-			/*        buf[8], buf[9], buf[10], buf[11], */
-			/*        buf[12], buf[13], buf[14], ret); */
-			if ((buf[14] & 0xc0) != 0x40) {
-				printk(KERN_WARNING "synaptics_ts_work_func:"
-				       " bad read %x %x %x %x %x %x %x %x %x"
-				       " %x %x %x %x %x %x, ret %d\n",
-				       buf[0], buf[1], buf[2], buf[3],
-				       buf[4], buf[5], buf[6], buf[7],
-				       buf[8], buf[9], buf[10], buf[11],
-				       buf[12], buf[13], buf[14], ret);
-				if (bad_data)
-					synaptics_init_panel(ts);
-				bad_data = 1;
-				continue;
-			}
-			bad_data = 0;
-			if ((buf[14] & 1) == 0) {
-				/* printk("read %d coordinates\n", i); */
-				break;
-			} else {
-				int pos[2][2];
-				int f, a;
-				int base;
-				/* int x = buf[3] | (uint16_t)(buf[2] & 0x1f) << 8; */
-				/* int y = buf[5] | (uint16_t)(buf[4] & 0x1f) << 8; */
-				int z = buf[1];
-				int w = buf[0] >> 4;
-				int finger = buf[0] & 7;
-
-				/* int x2 = buf[3+6] | (uint16_t)(buf[2+6] & 0x1f) << 8; */
-				/* int y2 = buf[5+6] | (uint16_t)(buf[4+6] & 0x1f) << 8; */
-				/* int z2 = buf[1+6]; */
-				/* int w2 = buf[0+6] >> 4; */
-				/* int finger2 = buf[0+6] & 7; */
-
-				/* int dx = (int8_t)buf[12]; */
-				/* int dy = (int8_t)buf[13]; */
-				int finger2_pressed;
-
-				/* printk("x %4d, y %4d, z %3d, w %2d, F %d, 2nd: x %4d, y %4d, z %3d, w %2d, F %d, dx %4d, dy %4d\n", */
-				/*	x, y, z, w, finger, */
-				/*	x2, y2, z2, w2, finger2, */
-				/*	dx, dy); */
-
-				base = 2;
-				for (f = 0; f < 2; f++) {
-					uint32_t flip_flag = SYNAPTICS_FLIP_X;
-					for (a = 0; a < 2; a++) {
-						int p = buf[base + 1];
-						p |= (uint16_t)(buf[base] & 0x1f) << 8;
-						if (ts->flags & flip_flag)
-							p = ts->max[a] - p;
-						if (ts->flags & SYNAPTICS_SNAP_TO_INACTIVE_EDGE) {
-							if (ts->snap_state[f][a]) {
-								if (p <= ts->snap_down_off[a])
-									p = ts->snap_down[a];
-								else if (p >= ts->snap_up_off[a])
-									p = ts->snap_up[a];
-								else
-									ts->snap_state[f][a] = 0;
-							} else {
-								if (p <= ts->snap_down_on[a]) {
-									p = ts->snap_down[a];
-									ts->snap_state[f][a] = 1;
-								} else if (p >= ts->snap_up_on[a]) {
-									p = ts->snap_up[a];
-									ts->snap_state[f][a] = 1;
-								}
-							}
-						}
-						pos[f][a] = p;
-						base += 2;
-						flip_flag <<= 1;
-					}
-					base += 2;
-					if (ts->flags & SYNAPTICS_SWAP_XY)
-						swap(pos[f][0], pos[f][1]);
-				}
-				if (z) {
-					input_report_abs(ts->input_dev, ABS_X, pos[0][0]);
-					input_report_abs(ts->input_dev, ABS_Y, pos[0][1]);
-				}
-				input_report_abs(ts->input_dev, ABS_PRESSURE, z);
-				input_report_abs(ts->input_dev, ABS_TOOL_WIDTH, w);
-				input_report_key(ts->input_dev, BTN_TOUCH, finger);
-				finger2_pressed = finger > 1 && finger != 7;
-				input_report_key(ts->input_dev, BTN_2, finger2_pressed);
-				if (finger2_pressed) {
-					input_report_abs(ts->input_dev, ABS_HAT0X, pos[1][0]);
-					input_report_abs(ts->input_dev, ABS_HAT0Y, pos[1][1]);
-				}
-				input_sync(ts->input_dev);
-			}
+			continue;
+		}
+		if ((buf[14] & 0xc0) != 0x40) {
+			pr_warning("synaptics_ts_work_func:"
+			       " bad read %x %x %x %x %x %x %x %x %x"
+			       " %x %x %x %x %x %x, ret %d\n",
+			       buf[0], buf[1], buf[2], buf[3],
+			       buf[4], buf[5], buf[6], buf[7],
+			       buf[8], buf[9], buf[10], buf[11],
+			       buf[12], buf[13], buf[14], ret);
+			if (bad_data)
+				synaptics_init_panel(ts);
+			bad_data = 1;
+			continue;
 		}
+		bad_data = 0;
+		if ((buf[14] & 1) == 0)
+			break;
+
+		decode_report(ts, buf);
 	}
 	if (ts->use_irq)
 		enable_irq(ts->client->irq);
@@ -209,8 +196,8 @@ static void synaptics_ts_work_func(struc
 
 static enum hrtimer_restart synaptics_ts_timer_func(struct hrtimer *timer)
 {
-	struct synaptics_ts_data *ts = container_of(timer, struct synaptics_ts_data, timer);
-	/* printk("synaptics_ts_timer_func\n"); */
+	struct synaptics_ts_data *ts =
+		container_of(timer, struct synaptics_ts_data, timer);
 
 	queue_work(synaptics_wq, &ts->work);
 
@@ -222,12 +209,46 @@ static irqreturn_t synaptics_ts_irq_hand
 {
 	struct synaptics_ts_data *ts = dev_id;
 
-	/* printk("synaptics_ts_irq_handler\n"); */
-	disable_irq(ts->client->irq);
+	disable_irq_nosync(ts->client->irq);
 	queue_work(synaptics_wq, &ts->work);
 	return IRQ_HANDLED;
 }
 
+static int detect(struct synaptics_ts_data *ts, u32 *panel_version)
+{
+	int ret;
+	int retry = 10;
+
+	ret = i2c_set(ts, 0xf4, 0x01, "reset device");
+
+	while (retry-- > 0) {
+		ret = i2c_smbus_read_byte_data(ts->client, 0xe4);
+		if (ret >= 0)
+			break;
+		msleep(100);
+	}
+	if (ret < 0) {
+		pr_err("i2c_smbus_read_byte_data failed\n");
+		return ret;
+	}
+
+	*panel_version = ret << 8;
+	ret = i2c_read(ts, 0xe5, "product minor");
+	if (ret < 0)
+		return ret;
+	*panel_version |= ret;
+
+	ret = i2c_read(ts, 0xe3, "property");
+	if (ret < 0)
+		return ret;
+
+	pr_info("synaptics: version %x, product property %x\n",
+		*panel_version, ret);
+	return 0;
+}
+
+static struct synaptics_i2c_rmi_platform_data fake_pdata;
+
 static int synaptics_ts_probe(
 	struct i2c_client *client, const struct i2c_device_id *id)
 {
@@ -251,7 +272,7 @@ static int synaptics_ts_probe(
 	int snap_top_off;
 	int snap_bottom_on;
 	int snap_bottom_off;
-	uint32_t panel_version;
+	uint32_t panel_version = 0;
 
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
 		printk(KERN_ERR "synaptics_ts_probe: need I2C_FUNC_I2C\n");
@@ -270,48 +291,21 @@ static int synaptics_ts_probe(
 	pdata = client->dev.platform_data;
 	if (pdata)
 		ts->power = pdata->power;
+	else
+		pdata = &fake_pdata;
+
 	if (ts->power) {
 		ret = ts->power(1);
 		if (ret < 0) {
-			printk(KERN_ERR "synaptics_ts_probe power on failed\n");
+			pr_err("synaptics_ts_probe power on failed\n");
 			goto err_power_failed;
 		}
 	}
 
-	ret = i2c_smbus_write_byte_data(ts->client, 0xf4, 0x01); /* device command = reset */
-	if (ret < 0) {
-		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
-		/* fail? */
-	}
-	{
-		int retry = 10;
-		while (retry-- > 0) {
-			ret = i2c_smbus_read_byte_data(ts->client, 0xe4);
-			if (ret >= 0)
-				break;
-			msleep(100);
-		}
-	}
-	if (ret < 0) {
-		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
-		goto err_detect_failed;
-	}
-	printk(KERN_INFO "synaptics_ts_probe: Product Major Version %x\n", ret);
-	panel_version = ret << 8;
-	ret = i2c_smbus_read_byte_data(ts->client, 0xe5);
-	if (ret < 0) {
-		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+	ret = detect(ts, &panel_version);
+	if (ret)
 		goto err_detect_failed;
-	}
-	printk(KERN_INFO "synaptics_ts_probe: Product Minor Version %x\n", ret);
-	panel_version |= ret;
 
-	ret = i2c_smbus_read_byte_data(ts->client, 0xe3);
-	if (ret < 0) {
-		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
-		goto err_detect_failed;
-	}
-	printk(KERN_INFO "synaptics_ts_probe: product property %x\n", ret);
 
 	if (pdata) {
 		while (pdata->version > panel_version)
@@ -397,29 +391,30 @@ static int synaptics_ts_probe(
 	}
 	ret = i2c_smbus_read_word_data(ts->client, 0x04);
 	if (ret < 0) {
-		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		pr_err("i2c_smbus_read_word_data failed\n");
 		goto err_detect_failed;
 	}
 	ts->max[0] = max_x = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
 	ret = i2c_smbus_read_word_data(ts->client, 0x06);
 	if (ret < 0) {
-		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		pr_err("i2c_smbus_read_word_data failed\n");
 		goto err_detect_failed;
 	}
 	ts->max[1] = max_y = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
 	if (ts->flags & SYNAPTICS_SWAP_XY)
 		swap(max_x, max_y);
 
-	ret = synaptics_init_panel(ts); /* will also switch back to page 0x04 */
+	/* will also switch back to page 0x04 */
+	ret = synaptics_init_panel(ts);
 	if (ret < 0) {
-		printk(KERN_ERR "synaptics_init_panel failed\n");
+		pr_err("synaptics_init_panel failed\n");
 		goto err_detect_failed;
 	}
 
 	ts->input_dev = input_allocate_device();
 	if (ts->input_dev == NULL) {
 		ret = -ENOMEM;
-		printk(KERN_ERR "synaptics_ts_probe: Failed to allocate input device\n");
+		pr_err("synaptics: Failed to allocate input device\n");
 		goto err_input_dev_alloc_failed;
 	}
 	ts->input_dev->name = "synaptics-rmi-touchscreen";
@@ -497,7 +492,8 @@ static int synaptics_ts_probe(
 	register_early_suspend(&ts->early_suspend);
 #endif
 
-	printk(KERN_INFO "synaptics_ts_probe: Start touchscreen %s in %s mode\n", ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+	pr_info("synaptics: Start touchscreen %s in %s mode\n",
+		ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
 
 	return 0;
 
@@ -528,6 +524,7 @@ static int synaptics_ts_remove(struct i2
 	return 0;
 }
 
+#ifdef CONFIG_PM
 static int synaptics_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 {
 	int ret;
@@ -540,17 +537,13 @@ static int synaptics_ts_suspend(struct i
 	ret = cancel_work_sync(&ts->work);
 	if (ret && ts->use_irq) /* if work was pending disable-count is now 2 */
 		enable_irq(client->irq);
-	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
-	if (ret < 0)
-		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+	i2c_set(ts, 0xf1, 0, "disable interrupt");
+	i2c_set(ts, 0xf0, 0x86, "deep sleep");
 
-	ret = i2c_smbus_write_byte_data(client, 0xf0, 0x86); /* deep sleep */
-	if (ret < 0)
-		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
 	if (ts->power) {
 		ret = ts->power(0);
 		if (ret < 0)
-			printk(KERN_ERR "synaptics_ts_resume power off failed\n");
+			pr_err("synaptics_ts_suspend power off failed\n");
 	}
 	return 0;
 }
@@ -563,18 +556,16 @@ static int synaptics_ts_resume(struct i2
 	if (ts->power) {
 		ret = ts->power(1);
 		if (ret < 0)
-			printk(KERN_ERR "synaptics_ts_resume power on failed\n");
+			pr_err("synaptics_ts_resume power on failed\n");
 	}
 
 	synaptics_init_panel(ts);
 
-	if (ts->use_irq)
+	if (ts->use_irq) {
 		enable_irq(client->irq);
-
-	if (!ts->use_irq)
+		i2c_set(ts, 0xf1, 0x01, "enable abs int");
+	} else
 		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-	else
-		i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
 
 	return 0;
 }
@@ -594,6 +585,12 @@ static void synaptics_ts_late_resume(str
 	synaptics_ts_resume(ts->client);
 }
 #endif
+#else
+#define synaptics_ts_suspend NULL
+#define synaptics_ts_resume NULL
+#endif
+
+
 
 static const struct i2c_device_id synaptics_ts_id[] = {
 	{ SYNAPTICS_I2C_RMI_NAME, 0 },
@@ -633,3 +630,4 @@ module_exit(synaptics_ts_exit);
 
 MODULE_DESCRIPTION("Synaptics Touchscreen Driver");
 MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Arve Hjønnevåg <arve@android.com>");
