From alan@linux.intel.com  Mon Oct 26 14:55:32 2009
From: Alan Cox <alan@linux.intel.com>
Date: Tue, 06 Oct 2009 15:48:57 +0100
Subject: Staging: et131x: first pass RX cleanup
To: greg@kroah.com
Message-ID: <20091006144854.8604.59073.stgit@localhost.localdomain>


Sort out the variable naming and clean up types and obvious trivia

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/et131x/et1310_rx.c |  414 ++++++++++++++++++-------------------
 1 file changed, 205 insertions(+), 209 deletions(-)

--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -106,9 +106,9 @@ void nic_return_rfd(struct et131x_adapte
  */
 int et131x_rx_dma_memory_alloc(struct et131x_adapter *adapter)
 {
-	uint32_t OuterLoop, InnerLoop;
-	uint32_t bufsize;
-	uint32_t pktStatRingSize, FBRChunkSize;
+	u32 i, j;
+	u32 bufsize;
+	u32 pktStatRingSize, FBRChunkSize;
 	RX_RING_t *rx_ring;
 
 	/* Setup some convenience pointers */
@@ -227,11 +227,11 @@ int et131x_rx_dma_memory_alloc(struct et
 					rx_ring->Fbr0offset);
 #endif
 
-	for (OuterLoop = 0; OuterLoop < (rx_ring->Fbr1NumEntries / FBR_CHUNKS);
-	     OuterLoop++) {
-		uint64_t Fbr1Offset;
-		uint64_t Fbr1TempPa;
-		uint32_t Fbr1Align;
+	for (i = 0; i < (rx_ring->Fbr1NumEntries / FBR_CHUNKS);
+	     i++) {
+		u64 Fbr1Offset;
+		u64 Fbr1TempPa;
+		u32 Fbr1Align;
 
 		/* This code allocates an area of memory big enough for N
 		 * free buffers + (buffer_size - 1) so that the buffers can
@@ -247,39 +247,39 @@ int et131x_rx_dma_memory_alloc(struct et
 
 		FBRChunkSize =
 		    (FBR_CHUNKS * rx_ring->Fbr1BufferSize) + Fbr1Align - 1;
-		rx_ring->Fbr1MemVa[OuterLoop] =
+		rx_ring->Fbr1MemVa[i] =
 		    pci_alloc_consistent(adapter->pdev, FBRChunkSize,
-					 &rx_ring->Fbr1MemPa[OuterLoop]);
+					 &rx_ring->Fbr1MemPa[i]);
 
-		if (!rx_ring->Fbr1MemVa[OuterLoop]) {
+		if (!rx_ring->Fbr1MemVa[i]) {
 		dev_err(&adapter->pdev->dev,
 				"Could not alloc memory\n");
 			return -ENOMEM;
 		}
 
 		/* See NOTE in "Save Physical Address" comment above */
-		Fbr1TempPa = rx_ring->Fbr1MemPa[OuterLoop];
+		Fbr1TempPa = rx_ring->Fbr1MemPa[i];
 
 		et131x_align_allocated_memory(adapter,
 					      &Fbr1TempPa,
 					      &Fbr1Offset, (Fbr1Align - 1));
 
-		for (InnerLoop = 0; InnerLoop < FBR_CHUNKS; InnerLoop++) {
-			uint32_t index = (OuterLoop * FBR_CHUNKS) + InnerLoop;
+		for (j = 0; j < FBR_CHUNKS; j++) {
+			u32 index = (i * FBR_CHUNKS) + j;
 
 			/* Save the Virtual address of this index for quick
 			 * access later
 			 */
 			rx_ring->Fbr[1]->Va[index] =
-			    (uint8_t *) rx_ring->Fbr1MemVa[OuterLoop] +
-			    (InnerLoop * rx_ring->Fbr1BufferSize) + Fbr1Offset;
+			    (uint8_t *) rx_ring->Fbr1MemVa[i] +
+			    (j * rx_ring->Fbr1BufferSize) + Fbr1Offset;
 
 			/* now store the physical address in the descriptor
 			 * so the device can access it
 			 */
 			rx_ring->Fbr[1]->PAHigh[index] =
-			    (uint32_t) (Fbr1TempPa >> 32);
-			rx_ring->Fbr[1]->PALow[index] = (uint32_t) Fbr1TempPa;
+			    (u32) (Fbr1TempPa >> 32);
+			rx_ring->Fbr[1]->PALow[index] = (u32) Fbr1TempPa;
 
 			Fbr1TempPa += rx_ring->Fbr1BufferSize;
 
@@ -292,40 +292,40 @@ int et131x_rx_dma_memory_alloc(struct et
 
 #ifdef USE_FBR0
 	/* Same for FBR0 (if in use) */
-	for (OuterLoop = 0; OuterLoop < (rx_ring->Fbr0NumEntries / FBR_CHUNKS);
-	     OuterLoop++) {
-		uint64_t Fbr0Offset;
-		uint64_t Fbr0TempPa;
+	for (i = 0; i < (rx_ring->Fbr0NumEntries / FBR_CHUNKS);
+	     i++) {
+		u64 Fbr0Offset;
+		u64 Fbr0TempPa;
 
 		FBRChunkSize = ((FBR_CHUNKS + 1) * rx_ring->Fbr0BufferSize) - 1;
-		rx_ring->Fbr0MemVa[OuterLoop] =
+		rx_ring->Fbr0MemVa[i] =
 		    pci_alloc_consistent(adapter->pdev, FBRChunkSize,
-					 &rx_ring->Fbr0MemPa[OuterLoop]);
+					 &rx_ring->Fbr0MemPa[i]);
 
-		if (!rx_ring->Fbr0MemVa[OuterLoop]) {
+		if (!rx_ring->Fbr0MemVa[i]) {
 			dev_err(&adapter->pdev->dev,
 				"Could not alloc memory\n");
 			return -ENOMEM;
 		}
 
 		/* See NOTE in "Save Physical Address" comment above */
-		Fbr0TempPa = rx_ring->Fbr0MemPa[OuterLoop];
+		Fbr0TempPa = rx_ring->Fbr0MemPa[i];
 
 		et131x_align_allocated_memory(adapter,
 					      &Fbr0TempPa,
 					      &Fbr0Offset,
 					      rx_ring->Fbr0BufferSize - 1);
 
-		for (InnerLoop = 0; InnerLoop < FBR_CHUNKS; InnerLoop++) {
-			uint32_t index = (OuterLoop * FBR_CHUNKS) + InnerLoop;
+		for (j = 0; j < FBR_CHUNKS; j++) {
+			u32 index = (i * FBR_CHUNKS) + j;
 
 			rx_ring->Fbr[0]->Va[index] =
-			    (uint8_t *) rx_ring->Fbr0MemVa[OuterLoop] +
-			    (InnerLoop * rx_ring->Fbr0BufferSize) + Fbr0Offset;
+			    (uint8_t *) rx_ring->Fbr0MemVa[i] +
+			    (j * rx_ring->Fbr0BufferSize) + Fbr0Offset;
 
 			rx_ring->Fbr[0]->PAHigh[index] =
-			    (uint32_t) (Fbr0TempPa >> 32);
-			rx_ring->Fbr[0]->PALow[index] = (uint32_t) Fbr0TempPa;
+			    (u32) (Fbr0TempPa >> 32);
+			rx_ring->Fbr[0]->PALow[index] = (u32) Fbr0TempPa;
 
 			Fbr0TempPa += rx_ring->Fbr0BufferSize;
 
@@ -400,10 +400,10 @@ int et131x_rx_dma_memory_alloc(struct et
  */
 void et131x_rx_dma_memory_free(struct et131x_adapter *adapter)
 {
-	uint32_t index;
-	uint32_t bufsize;
-	uint32_t pktStatRingSize;
-	PMP_RFD pMpRfd;
+	u32 index;
+	u32 bufsize;
+	u32 pktStatRingSize;
+	PMP_RFD rfd;
 	RX_RING_t *rx_ring;
 
 	/* Setup some convenience pointers */
@@ -413,18 +413,18 @@ void et131x_rx_dma_memory_free(struct et
 	WARN_ON(rx_ring->nReadyRecv != rx_ring->NumRfd);
 
 	while (!list_empty(&rx_ring->RecvList)) {
-		pMpRfd = (MP_RFD *) list_entry(rx_ring->RecvList.next,
+		rfd = (MP_RFD *) list_entry(rx_ring->RecvList.next,
 					       MP_RFD, list_node);
 
-		list_del(&pMpRfd->list_node);
-		et131x_rfd_resources_free(adapter, pMpRfd);
+		list_del(&rfd->list_node);
+		et131x_rfd_resources_free(adapter, rfd);
 	}
 
 	while (!list_empty(&rx_ring->RecvPendingList)) {
-		pMpRfd = (MP_RFD *) list_entry(rx_ring->RecvPendingList.next,
+		rfd = (MP_RFD *) list_entry(rx_ring->RecvPendingList.next,
 					       MP_RFD, list_node);
-		list_del(&pMpRfd->list_node);
-		et131x_rfd_resources_free(adapter, pMpRfd);
+		list_del(&rfd->list_node);
+		et131x_rfd_resources_free(adapter, rfd);
 	}
 
 	/* Free Free Buffer Ring 1 */
@@ -433,7 +433,7 @@ void et131x_rx_dma_memory_free(struct et
 		for (index = 0; index <
 		     (rx_ring->Fbr1NumEntries / FBR_CHUNKS); index++) {
 			if (rx_ring->Fbr1MemVa[index]) {
-				uint32_t Fbr1Align;
+				u32 Fbr1Align;
 
 				if (rx_ring->Fbr1BufferSize > 4096)
 					Fbr1Align = 4096;
@@ -552,49 +552,49 @@ void et131x_rx_dma_memory_free(struct et
 int et131x_init_recv(struct et131x_adapter *adapter)
 {
 	int status = -ENOMEM;
-	PMP_RFD pMpRfd = NULL;
-	uint32_t RfdCount;
-	uint32_t TotalNumRfd = 0;
+	PMP_RFD rfd = NULL;
+	u32 rfdct;
+	u32 numrfd = 0;
 	RX_RING_t *rx_ring = NULL;
 
 	/* Setup some convenience pointers */
 	rx_ring = (RX_RING_t *) &adapter->RxRing;
 
 	/* Setup each RFD */
-	for (RfdCount = 0; RfdCount < rx_ring->NumRfd; RfdCount++) {
-		pMpRfd = (MP_RFD *) kmem_cache_alloc(rx_ring->RecvLookaside,
+	for (rfdct = 0; rfdct < rx_ring->NumRfd; rfdct++) {
+		rfd = (MP_RFD *) kmem_cache_alloc(rx_ring->RecvLookaside,
 						     GFP_ATOMIC | GFP_DMA);
 
-		if (!pMpRfd) {
+		if (!rfd) {
 			dev_err(&adapter->pdev->dev,
 				  "Couldn't alloc RFD out of kmem_cache\n");
 			status = -ENOMEM;
 			continue;
 		}
 
-		status = et131x_rfd_resources_alloc(adapter, pMpRfd);
+		status = et131x_rfd_resources_alloc(adapter, rfd);
 		if (status != 0) {
 			dev_err(&adapter->pdev->dev,
 				  "Couldn't alloc packet for RFD\n");
-			kmem_cache_free(rx_ring->RecvLookaside, pMpRfd);
+			kmem_cache_free(rx_ring->RecvLookaside, rfd);
 			continue;
 		}
 
 		/* Add this RFD to the RecvList */
-		list_add_tail(&pMpRfd->list_node, &rx_ring->RecvList);
+		list_add_tail(&rfd->list_node, &rx_ring->RecvList);
 
 		/* Increment both the available RFD's, and the total RFD's. */
 		rx_ring->nReadyRecv++;
-		TotalNumRfd++;
+		numrfd++;
 	}
 
-	if (TotalNumRfd > NIC_MIN_NUM_RFD)
+	if (numrfd > NIC_MIN_NUM_RFD)
 		status = 0;
 
-	rx_ring->NumRfd = TotalNumRfd;
+	rx_ring->NumRfd = numrfd;
 
 	if (status != 0) {
-		kmem_cache_free(rx_ring->RecvLookaside, pMpRfd);
+		kmem_cache_free(rx_ring->RecvLookaside, rfd);
 		dev_err(&adapter->pdev->dev,
 			  "Allocation problems in et131x_init_recv\n");
 	}
@@ -604,13 +604,13 @@ int et131x_init_recv(struct et131x_adapt
 /**
  * et131x_rfd_resources_alloc
  * @adapter: pointer to our private adapter structure
- * @pMpRfd: pointer to a RFD
+ * @rfd: pointer to a RFD
  *
  * Returns 0 on success and errno on failure (as defined in errno.h)
  */
-int et131x_rfd_resources_alloc(struct et131x_adapter *adapter, MP_RFD *pMpRfd)
+int et131x_rfd_resources_alloc(struct et131x_adapter *adapter, MP_RFD *rfd)
 {
-	pMpRfd->Packet = NULL;
+	rfd->Packet = NULL;
 
 	return 0;
 }
@@ -618,12 +618,12 @@ int et131x_rfd_resources_alloc(struct et
 /**
  * et131x_rfd_resources_free - Free the packet allocated for the given RFD
  * @adapter: pointer to our private adapter structure
- * @pMpRfd: pointer to a RFD
+ * @rfd: pointer to a RFD
  */
-void et131x_rfd_resources_free(struct et131x_adapter *adapter, MP_RFD *pMpRfd)
+void et131x_rfd_resources_free(struct et131x_adapter *adapter, MP_RFD *rfd)
 {
-	pMpRfd->Packet = NULL;
-	kmem_cache_free(adapter->RxRing.RecvLookaside, pMpRfd);
+	rfd->Packet = NULL;
+	kmem_cache_free(adapter->RxRing.RecvLookaside, rfd);
 }
 
 /**
@@ -633,9 +633,9 @@ void et131x_rfd_resources_free(struct et
 void ConfigRxDmaRegs(struct et131x_adapter *etdev)
 {
 	struct _RXDMA_t __iomem *rx_dma = &etdev->regs->rxdma;
-	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
+	struct _rx_ring_t *rx_local = &etdev->RxRing;
 	PFBR_DESC_t fbr_entry;
-	uint32_t entry;
+	u32 entry;
 	RXDMA_PSR_NUM_DES_t psr_num_des;
 	unsigned long flags;
 
@@ -649,19 +649,19 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	 * are ever returned, make sure the high part is retrieved here
 	 * before storing the adjusted address.
 	 */
-	writel((uint32_t) ((u64)pRxLocal->pRxStatusPa >> 32),
+	writel((u32) ((u64)rx_local->pRxStatusPa >> 32),
 	       &rx_dma->dma_wb_base_hi);
-	writel((uint32_t) pRxLocal->pRxStatusPa, &rx_dma->dma_wb_base_lo);
+	writel((u32) rx_local->pRxStatusPa, &rx_dma->dma_wb_base_lo);
 
-	memset(pRxLocal->pRxStatusVa, 0, sizeof(RX_STATUS_BLOCK_t));
+	memset(rx_local->pRxStatusVa, 0, sizeof(RX_STATUS_BLOCK_t));
 
 	/* Set the address and parameters of the packet status ring into the
 	 * 1310's registers
 	 */
-	writel((uint32_t) ((u64)pRxLocal->pPSRingPa >> 32),
+	writel((u32) ((u64)rx_local->pPSRingPa >> 32),
 	       &rx_dma->psr_base_hi);
-	writel((uint32_t) pRxLocal->pPSRingPa, &rx_dma->psr_base_lo);
-	writel(pRxLocal->PsrNumEntries - 1, &rx_dma->psr_num_des.value);
+	writel((u32) rx_local->pPSRingPa, &rx_dma->psr_base_lo);
+	writel(rx_local->PsrNumEntries - 1, &rx_dma->psr_num_des.value);
 	writel(0, &rx_dma->psr_full_offset.value);
 
 	psr_num_des.value = readl(&rx_dma->psr_num_des.value);
@@ -671,14 +671,14 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	spin_lock_irqsave(&etdev->RcvLock, flags);
 
 	/* These local variables track the PSR in the adapter structure */
-	pRxLocal->local_psr_full.bits.psr_full = 0;
-	pRxLocal->local_psr_full.bits.psr_full_wrap = 0;
+	rx_local->local_psr_full.bits.psr_full = 0;
+	rx_local->local_psr_full.bits.psr_full_wrap = 0;
 
 	/* Now's the best time to initialize FBR1 contents */
-	fbr_entry = (PFBR_DESC_t) pRxLocal->pFbr1RingVa;
-	for (entry = 0; entry < pRxLocal->Fbr1NumEntries; entry++) {
-		fbr_entry->addr_hi = pRxLocal->Fbr[1]->PAHigh[entry];
-		fbr_entry->addr_lo = pRxLocal->Fbr[1]->PALow[entry];
+	fbr_entry = (PFBR_DESC_t) rx_local->pFbr1RingVa;
+	for (entry = 0; entry < rx_local->Fbr1NumEntries; entry++) {
+		fbr_entry->addr_hi = rx_local->Fbr[1]->PAHigh[entry];
+		fbr_entry->addr_lo = rx_local->Fbr[1]->PALow[entry];
 		fbr_entry->word2.bits.bi = entry;
 		fbr_entry++;
 	}
@@ -686,38 +686,38 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	/* Set the address and parameters of Free buffer ring 1 (and 0 if
 	 * required) into the 1310's registers
 	 */
-	writel((uint32_t) (pRxLocal->Fbr1Realpa >> 32), &rx_dma->fbr1_base_hi);
-	writel((uint32_t) pRxLocal->Fbr1Realpa, &rx_dma->fbr1_base_lo);
-	writel(pRxLocal->Fbr1NumEntries - 1, &rx_dma->fbr1_num_des.value);
+	writel((u32) (rx_local->Fbr1Realpa >> 32), &rx_dma->fbr1_base_hi);
+	writel((u32) rx_local->Fbr1Realpa, &rx_dma->fbr1_base_lo);
+	writel(rx_local->Fbr1NumEntries - 1, &rx_dma->fbr1_num_des.value);
 	writel(ET_DMA10_WRAP, &rx_dma->fbr1_full_offset);
 
 	/* This variable tracks the free buffer ring 1 full position, so it
 	 * has to match the above.
 	 */
-	pRxLocal->local_Fbr1_full = ET_DMA10_WRAP;
-	writel(((pRxLocal->Fbr1NumEntries * LO_MARK_PERCENT_FOR_RX) / 100) - 1,
+	rx_local->local_Fbr1_full = ET_DMA10_WRAP;
+	writel(((rx_local->Fbr1NumEntries * LO_MARK_PERCENT_FOR_RX) / 100) - 1,
 	       &rx_dma->fbr1_min_des.value);
 
 #ifdef USE_FBR0
 	/* Now's the best time to initialize FBR0 contents */
-	fbr_entry = (PFBR_DESC_t) pRxLocal->pFbr0RingVa;
-	for (entry = 0; entry < pRxLocal->Fbr0NumEntries; entry++) {
-		fbr_entry->addr_hi = pRxLocal->Fbr[0]->PAHigh[entry];
-		fbr_entry->addr_lo = pRxLocal->Fbr[0]->PALow[entry];
+	fbr_entry = (PFBR_DESC_t) rx_local->pFbr0RingVa;
+	for (entry = 0; entry < rx_local->Fbr0NumEntries; entry++) {
+		fbr_entry->addr_hi = rx_local->Fbr[0]->PAHigh[entry];
+		fbr_entry->addr_lo = rx_local->Fbr[0]->PALow[entry];
 		fbr_entry->word2.bits.bi = entry;
 		fbr_entry++;
 	}
 
-	writel((uint32_t) (pRxLocal->Fbr0Realpa >> 32), &rx_dma->fbr0_base_hi);
-	writel((uint32_t) pRxLocal->Fbr0Realpa, &rx_dma->fbr0_base_lo);
-	writel(pRxLocal->Fbr0NumEntries - 1, &rx_dma->fbr0_num_des.value);
+	writel((u32) (rx_local->Fbr0Realpa >> 32), &rx_dma->fbr0_base_hi);
+	writel((u32) rx_local->Fbr0Realpa, &rx_dma->fbr0_base_lo);
+	writel(rx_local->Fbr0NumEntries - 1, &rx_dma->fbr0_num_des.value);
 	writel(ET_DMA10_WRAP, &rx_dma->fbr0_full_offset);
 
 	/* This variable tracks the free buffer ring 0 full position, so it
 	 * has to match the above.
 	 */
-	pRxLocal->local_Fbr0_full = ET_DMA10_WRAP;
-	writel(((pRxLocal->Fbr0NumEntries * LO_MARK_PERCENT_FOR_RX) / 100) - 1,
+	rx_local->local_Fbr0_full = ET_DMA10_WRAP;
+	writel(((rx_local->Fbr0NumEntries * LO_MARK_PERCENT_FOR_RX) / 100) - 1,
 	       &rx_dma->fbr0_min_des.value);
 #endif
 
@@ -818,7 +818,7 @@ void et131x_rx_dma_enable(struct et131x_
  * nic_rx_pkts - Checks the hardware for available packets
  * @etdev: pointer to our adapter
  *
- * Returns pMpRfd, a pointer to our MPRFD.
+ * Returns rfd, a pointer to our MPRFD.
  *
  * Checks the hardware for available packets, using completion ring
  * If packets are available, it gets an RFD from the RecvList, attaches
@@ -827,119 +827,119 @@ void et131x_rx_dma_enable(struct et131x_
  */
 PMP_RFD nic_rx_pkts(struct et131x_adapter *etdev)
 {
-	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
-	PRX_STATUS_BLOCK_t pRxStatusBlock;
-	PPKT_STAT_DESC_t pPSREntry;
-	PMP_RFD pMpRfd;
-	uint32_t nIndex;
-	uint8_t *pBufVa;
+	struct _rx_ring_t *rx_local = &etdev->RxRing;
+	PRX_STATUS_BLOCK_t status;
+	PPKT_STAT_DESC_t psr;
+	PMP_RFD rfd;
+	u32 i;
+	uint8_t *buf;
 	unsigned long flags;
 	struct list_head *element;
-	uint8_t ringIndex;
-	uint16_t bufferIndex;
-	uint32_t localLen;
+	uint8_t rindex;
+	uint16_t bindex;
+	u32 len;
 	PKT_STAT_DESC_WORD0_t Word0;
 
 	/* RX Status block is written by the DMA engine prior to every
 	 * interrupt. It contains the next to be used entry in the Packet
 	 * Status Ring, and also the two Free Buffer rings.
 	 */
-	pRxStatusBlock = (PRX_STATUS_BLOCK_t) pRxLocal->pRxStatusVa;
+	status = (PRX_STATUS_BLOCK_t) rx_local->pRxStatusVa;
 
-	if (pRxStatusBlock->Word1.bits.PSRoffset ==
-			pRxLocal->local_psr_full.bits.psr_full &&
-			pRxStatusBlock->Word1.bits.PSRwrap ==
-			pRxLocal->local_psr_full.bits.psr_full_wrap) {
+	if (status->Word1.bits.PSRoffset ==
+			rx_local->local_psr_full.bits.psr_full &&
+			status->Word1.bits.PSRwrap ==
+			rx_local->local_psr_full.bits.psr_full_wrap) {
 		/* Looks like this ring is not updated yet */
 		return NULL;
 	}
 
 	/* The packet status ring indicates that data is available. */
-	pPSREntry = (PPKT_STAT_DESC_t) (pRxLocal->pPSRingVa) +
-			pRxLocal->local_psr_full.bits.psr_full;
+	psr = (PPKT_STAT_DESC_t) (rx_local->pPSRingVa) +
+			rx_local->local_psr_full.bits.psr_full;
 
 	/* Grab any information that is required once the PSR is
 	 * advanced, since we can no longer rely on the memory being
 	 * accurate
 	 */
-	localLen = pPSREntry->word1.bits.length;
-	ringIndex = (uint8_t) pPSREntry->word1.bits.ri;
-	bufferIndex = (uint16_t) pPSREntry->word1.bits.bi;
-	Word0 = pPSREntry->word0;
+	len = psr->word1.bits.length;
+	rindex = (uint8_t) psr->word1.bits.ri;
+	bindex = (uint16_t) psr->word1.bits.bi;
+	Word0 = psr->word0;
 
 	/* Indicate that we have used this PSR entry. */
-	if (++pRxLocal->local_psr_full.bits.psr_full >
-	    pRxLocal->PsrNumEntries - 1) {
-		pRxLocal->local_psr_full.bits.psr_full = 0;
-		pRxLocal->local_psr_full.bits.psr_full_wrap ^= 1;
+	if (++rx_local->local_psr_full.bits.psr_full >
+	    rx_local->PsrNumEntries - 1) {
+		rx_local->local_psr_full.bits.psr_full = 0;
+		rx_local->local_psr_full.bits.psr_full_wrap ^= 1;
 	}
 
-	writel(pRxLocal->local_psr_full.value,
+	writel(rx_local->local_psr_full.value,
 	       &etdev->regs->rxdma.psr_full_offset.value);
 
 #ifndef USE_FBR0
-	if (ringIndex != 1) {
+	if (rindex != 1) {
 		return NULL;
 	}
 #endif
 
 #ifdef USE_FBR0
-	if (ringIndex > 1 ||
-		(ringIndex == 0 &&
-		bufferIndex > pRxLocal->Fbr0NumEntries - 1) ||
-		(ringIndex == 1 &&
-		bufferIndex > pRxLocal->Fbr1NumEntries - 1))
+	if (rindex > 1 ||
+		(rindex == 0 &&
+		bindex > rx_local->Fbr0NumEntries - 1) ||
+		(rindex == 1 &&
+		bindex > rx_local->Fbr1NumEntries - 1))
 #else
-	if (ringIndex != 1 ||
-		bufferIndex > pRxLocal->Fbr1NumEntries - 1)
+	if (rindex != 1 ||
+		bindex > rx_local->Fbr1NumEntries - 1)
 #endif
 	{
 		/* Illegal buffer or ring index cannot be used by S/W*/
 		dev_err(&etdev->pdev->dev,
 			  "NICRxPkts PSR Entry %d indicates "
 			  "length of %d and/or bad bi(%d)\n",
-			  pRxLocal->local_psr_full.bits.psr_full,
-			  localLen, bufferIndex);
+			  rx_local->local_psr_full.bits.psr_full,
+			  len, bindex);
 		return NULL;
 	}
 
 	/* Get and fill the RFD. */
 	spin_lock_irqsave(&etdev->RcvLock, flags);
 
-	pMpRfd = NULL;
-	element = pRxLocal->RecvList.next;
-	pMpRfd = (PMP_RFD) list_entry(element, MP_RFD, list_node);
+	rfd = NULL;
+	element = rx_local->RecvList.next;
+	rfd = (PMP_RFD) list_entry(element, MP_RFD, list_node);
 
-	if (pMpRfd == NULL) {
+	if (rfd == NULL) {
 		spin_unlock_irqrestore(&etdev->RcvLock, flags);
 		return NULL;
 	}
 
-	list_del(&pMpRfd->list_node);
-	pRxLocal->nReadyRecv--;
+	list_del(&rfd->list_node);
+	rx_local->nReadyRecv--;
 
 	spin_unlock_irqrestore(&etdev->RcvLock, flags);
 
-	pMpRfd->bufferindex = bufferIndex;
-	pMpRfd->ringindex = ringIndex;
+	rfd->bufferindex = bindex;
+	rfd->ringindex = rindex;
 
 	/* In V1 silicon, there is a bug which screws up filtering of
 	 * runt packets.  Therefore runt packet filtering is disabled
 	 * in the MAC and the packets are dropped here.  They are
 	 * also counted here.
 	 */
-	if (localLen < (NIC_MIN_PACKET_SIZE + 4)) {
+	if (len < (NIC_MIN_PACKET_SIZE + 4)) {
 		etdev->Stats.other_errors++;
-		localLen = 0;
+		len = 0;
 	}
 
-	if (localLen) {
+	if (len) {
 		if (etdev->ReplicaPhyLoopbk == 1) {
-			pBufVa = pRxLocal->Fbr[ringIndex]->Va[bufferIndex];
+			buf = rx_local->Fbr[rindex]->Va[bindex];
 
-			if (memcmp(&pBufVa[6], &etdev->CurrentAddress[0],
+			if (memcmp(&buf[6], &etdev->CurrentAddress[0],
 				   ETH_ALEN) == 0) {
-				if (memcmp(&pBufVa[42], "Replica packet",
+				if (memcmp(&buf[42], "Replica packet",
 					   ETH_HLEN)) {
 					etdev->ReplicaPhyLoopbkPF = 1;
 				}
@@ -959,28 +959,28 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 			if ((etdev->PacketFilter & ET131X_PACKET_TYPE_MULTICAST)
 			    && !(etdev->PacketFilter & ET131X_PACKET_TYPE_PROMISCUOUS)
 			    && !(etdev->PacketFilter & ET131X_PACKET_TYPE_ALL_MULTICAST)) {
-				pBufVa = pRxLocal->Fbr[ringIndex]->
-						Va[bufferIndex];
+				buf = rx_local->Fbr[rindex]->
+						Va[bindex];
 
 				/* Loop through our list to see if the
 				 * destination address of this packet
 				 * matches one in our list.
 				 */
-				for (nIndex = 0;
-				     nIndex < etdev->MCAddressCount;
-				     nIndex++) {
-					if (pBufVa[0] ==
-					    etdev->MCList[nIndex][0]
-					    && pBufVa[1] ==
-					    etdev->MCList[nIndex][1]
-					    && pBufVa[2] ==
-					    etdev->MCList[nIndex][2]
-					    && pBufVa[3] ==
-					    etdev->MCList[nIndex][3]
-					    && pBufVa[4] ==
-					    etdev->MCList[nIndex][4]
-					    && pBufVa[5] ==
-					    etdev->MCList[nIndex][5]) {
+				for (i = 0;
+				     i < etdev->MCAddressCount;
+				     i++) {
+					if (buf[0] ==
+					    etdev->MCList[i][0]
+					    && buf[1] ==
+					    etdev->MCList[i][1]
+					    && buf[2] ==
+					    etdev->MCList[i][2]
+					    && buf[3] ==
+					    etdev->MCList[i][3]
+					    && buf[4] ==
+					    etdev->MCList[i][4]
+					    && buf[5] ==
+					    etdev->MCList[i][5]) {
 						break;
 					}
 				}
@@ -993,11 +993,11 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 				 * so we free our RFD when we return
 				 * from this function.
 				 */
-				if (nIndex == etdev->MCAddressCount)
-					localLen = 0;
+				if (i == etdev->MCAddressCount)
+					len = 0;
 			}
 
-			if (localLen > 0)
+			if (len > 0)
 				etdev->Stats.multircv++;
 		} else if (Word0.value & ALCATEL_BROADCAST_PKT)
 			etdev->Stats.brdcstrcv++;
@@ -1010,24 +1010,24 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 			etdev->Stats.unircv++;
 	}
 
-	if (localLen > 0) {
+	if (len > 0) {
 		struct sk_buff *skb = NULL;
 
-		/* pMpRfd->PacketSize = localLen - 4; */
-		pMpRfd->PacketSize = localLen;
+		/* rfd->PacketSize = len - 4; */
+		rfd->PacketSize = len;
 
-		skb = dev_alloc_skb(pMpRfd->PacketSize + 2);
+		skb = dev_alloc_skb(rfd->PacketSize + 2);
 		if (!skb) {
 			dev_err(&etdev->pdev->dev,
 				  "Couldn't alloc an SKB for Rx\n");
 			return NULL;
 		}
 
-		etdev->net_stats.rx_bytes += pMpRfd->PacketSize;
+		etdev->net_stats.rx_bytes += rfd->PacketSize;
 
-		memcpy(skb_put(skb, pMpRfd->PacketSize),
-		       pRxLocal->Fbr[ringIndex]->Va[bufferIndex],
-		       pMpRfd->PacketSize);
+		memcpy(skb_put(skb, rfd->PacketSize),
+		       rx_local->Fbr[rindex]->Va[bindex],
+		       rfd->PacketSize);
 
 		skb->dev = etdev->netdev;
 		skb->protocol = eth_type_trans(skb, etdev->netdev);
@@ -1035,11 +1035,11 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 
 		netif_rx(skb);
 	} else {
-		pMpRfd->PacketSize = 0;
+		rfd->PacketSize = 0;
 	}
 
-	nic_return_rfd(etdev, pMpRfd);
-	return pMpRfd;
+	nic_return_rfd(etdev, rfd);
+	return rfd;
 }
 
 /**
@@ -1050,7 +1050,7 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
  */
 void et131x_reset_recv(struct et131x_adapter *etdev)
 {
-	PMP_RFD pMpRfd;
+	PMP_RFD rfd;
 	struct list_head *element;
 
 	WARN_ON(list_empty(&etdev->RxRing.RecvList));
@@ -1061,9 +1061,9 @@ void et131x_reset_recv(struct et131x_ada
 	while (!list_empty(&etdev->RxRing.RecvPendingList)) {
 		element = etdev->RxRing.RecvPendingList.next;
 
-		pMpRfd = (PMP_RFD) list_entry(element, MP_RFD, list_node);
+		rfd = (PMP_RFD) list_entry(element, MP_RFD, list_node);
 
-		list_move_tail(&pMpRfd->list_node, &etdev->RxRing.RecvList);
+		list_move_tail(&rfd->list_node, &etdev->RxRing.RecvList);
 	}
 }
 
@@ -1075,27 +1075,24 @@ void et131x_reset_recv(struct et131x_ada
  */
 void et131x_handle_recv_interrupt(struct et131x_adapter *etdev)
 {
-	PMP_RFD pMpRfd = NULL;
-	struct sk_buff *PacketArray[NUM_PACKETS_HANDLED];
-	PMP_RFD RFDFreeArray[NUM_PACKETS_HANDLED];
-	uint32_t PacketArrayCount = 0;
-	uint32_t PacketsToHandle;
-	uint32_t PacketFreeCount = 0;
-	bool TempUnfinishedRec = false;
-
-	PacketsToHandle = NUM_PACKETS_HANDLED;
+	PMP_RFD rfd = NULL;
+	struct sk_buff *packets[NUM_PACKETS_HANDLED];
+	PMP_RFD freed[NUM_PACKETS_HANDLED];
+	u32 count = 0;
+	u32 nfree = 0;
+	bool done = true;
 
 	/* Process up to available RFD's */
-	while (PacketArrayCount < PacketsToHandle) {
+	while (count < NUM_PACKETS_HANDLED) {
 		if (list_empty(&etdev->RxRing.RecvList)) {
 			WARN_ON(etdev->RxRing.nReadyRecv != 0);
-			TempUnfinishedRec = true;
+			done = false;
 			break;
 		}
 
-		pMpRfd = nic_rx_pkts(etdev);
+		rfd = nic_rx_pkts(etdev);
 
-		if (pMpRfd == NULL)
+		if (rfd == NULL)
 			break;
 
 		/* Do not receive any packets until a filter has been set.
@@ -1105,7 +1102,7 @@ void et131x_handle_recv_interrupt(struct
 		 */
 		if (!etdev->PacketFilter ||
 		    !(etdev->Flags & fMP_ADAPTER_LINK_DETECTION) ||
-		    pMpRfd->PacketSize == 0) {
+		    rfd->PacketSize == 0) {
 			continue;
 		}
 
@@ -1123,25 +1120,24 @@ void et131x_handle_recv_interrupt(struct
 			 * pending list anyway.
 			 */
 		} else {
-			RFDFreeArray[PacketFreeCount] = pMpRfd;
-			PacketFreeCount++;
+			freed[nfree] = rfd;
+			nfree++;
 
 			dev_warn(&etdev->pdev->dev,
 				    "RFD's are running out\n");
 		}
 
-		PacketArray[PacketArrayCount] = pMpRfd->Packet;
-		PacketArrayCount++;
+		packets[count] = rfd->Packet;
+		count++;
 	}
 
-	if ((PacketArrayCount == NUM_PACKETS_HANDLED) || TempUnfinishedRec) {
+	if (count == NUM_PACKETS_HANDLED || !done) {
 		etdev->RxRing.UnfinishedReceives = true;
 		writel(PARM_TX_TIME_INT_DEF * NANO_IN_A_MICRO,
 		       &etdev->regs->global.watchdog_timer);
-	} else {
+	} else
 		/* Watchdog timer will disable itself if appropriate. */
 		etdev->RxRing.UnfinishedReceives = false;
-	}
 }
 
 static inline u32 bump_fbr(u32 *fbr, u32 limit)
@@ -1165,14 +1161,14 @@ static inline u32 bump_fbr(u32 *fbr, u32
 /**
  * NICReturnRFD - Recycle a RFD and put it back onto the receive list
  * @etdev: pointer to our adapter
- * @pMpRfd: pointer to the RFD
+ * @rfd: pointer to the RFD
  */
-void nic_return_rfd(struct et131x_adapter *etdev, PMP_RFD pMpRfd)
+void nic_return_rfd(struct et131x_adapter *etdev, PMP_RFD rfd)
 {
 	struct _rx_ring_t *rx_local = &etdev->RxRing;
 	struct _RXDMA_t __iomem *rx_dma = &etdev->regs->rxdma;
-	uint16_t bi = pMpRfd->bufferindex;
-	uint8_t ri = pMpRfd->ringindex;
+	uint16_t bi = rfd->bufferindex;
+	uint8_t ri = rfd->ringindex;
 	unsigned long flags;
 
 	/* We don't use any of the OOB data besides status. Otherwise, we
@@ -1186,7 +1182,7 @@ void nic_return_rfd(struct et131x_adapte
 		spin_lock_irqsave(&etdev->FbrLock, flags);
 
 		if (ri == 1) {
-			PFBR_DESC_t pNextDesc =
+			PFBR_DESC_t next =
 			    (PFBR_DESC_t) (rx_local->pFbr1RingVa) +
 			    INDEX10(rx_local->local_Fbr1_full);
 
@@ -1194,9 +1190,9 @@ void nic_return_rfd(struct et131x_adapte
 			 * the PA / Buffer Index for the returned buffer into
 			 * the oldest (next to be freed)FBR entry
 			 */
-			pNextDesc->addr_hi = rx_local->Fbr[1]->PAHigh[bi];
-			pNextDesc->addr_lo = rx_local->Fbr[1]->PALow[bi];
-			pNextDesc->word2.value = bi;
+			next->addr_hi = rx_local->Fbr[1]->PAHigh[bi];
+			next->addr_lo = rx_local->Fbr[1]->PALow[bi];
+			next->word2.value = bi;
 
 			writel(bump_fbr(&rx_local->local_Fbr1_full,
 				rx_local->Fbr1NumEntries - 1),
@@ -1204,7 +1200,7 @@ void nic_return_rfd(struct et131x_adapte
 		}
 #ifdef USE_FBR0
 		else {
-			PFBR_DESC_t pNextDesc =
+			PFBR_DESC_t next =
 			    (PFBR_DESC_t) rx_local->pFbr0RingVa +
 			    INDEX10(rx_local->local_Fbr0_full);
 
@@ -1212,9 +1208,9 @@ void nic_return_rfd(struct et131x_adapte
 			 * the PA / Buffer Index for the returned buffer into
 			 * the oldest (next to be freed) FBR entry
 			 */
-			pNextDesc->addr_hi = rx_local->Fbr[0]->PAHigh[bi];
-			pNextDesc->addr_lo = rx_local->Fbr[0]->PALow[bi];
-			pNextDesc->word2.value = bi;
+			next->addr_hi = rx_local->Fbr[0]->PAHigh[bi];
+			next->addr_lo = rx_local->Fbr[0]->PALow[bi];
+			next->word2.value = bi;
 
 			writel(bump_fbr(&rx_local->local_Fbr0_full,
 					rx_local->Fbr0NumEntries - 1),
@@ -1231,7 +1227,7 @@ void nic_return_rfd(struct et131x_adapte
 	 * our list
 	 */
 	spin_lock_irqsave(&etdev->RcvLock, flags);
-	list_add_tail(&pMpRfd->list_node, &rx_local->RecvList);
+	list_add_tail(&rfd->list_node, &rx_local->RecvList);
 	rx_local->nReadyRecv++;
 	spin_unlock_irqrestore(&etdev->RcvLock, flags);
 
