From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Subject: Staging: rt28x0: fix comments in *.c files

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/rt2860/chips/rt3070.c      |   68 ++---
 drivers/staging/rt2860/chips/rt3090.c      |   34 +-
 drivers/staging/rt2860/chips/rt30xx.c      |  146 +++++------
 drivers/staging/rt2860/pci_main_dev.c      |  290 +++++++++++-----------
 drivers/staging/rt2860/rt_linux.c          |  110 ++++----
 drivers/staging/rt2860/rt_main_dev.c       |  172 ++++++-------
 drivers/staging/rt2860/rt_pci_rbus.c       |  164 ++++++------
 drivers/staging/rt2860/rt_usb.c            |  106 ++++----
 drivers/staging/rt2860/sta_ioctl.c         |  368 ++++++++++++++---------------
 drivers/staging/rt2860/usb_main_dev.c      |   76 ++---
 drivers/staging/rt2870/common/rtusb_bulk.c |  170 ++++++-------
 drivers/staging/rt2870/common/rtusb_data.c |   10 
 drivers/staging/rt2870/common/rtusb_io.c   |  162 ++++++------
 13 files changed, 938 insertions(+), 938 deletions(-)

--- a/drivers/staging/rt2860/chips/rt3070.c
+++ b/drivers/staging/rt2860/chips/rt3070.c
@@ -41,18 +41,18 @@
 
 #ifndef RTMP_RF_RW_SUPPORT
 #error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
-#endif // RTMP_RF_RW_SUPPORT //
+#endif /* RTMP_RF_RW_SUPPORT // */
 
 VOID NICInitRT3070RFRegisters(IN PRTMP_ADAPTER pAd)
 {
 	INT i;
 	UCHAR RFValue;
 
-	// Driver must read EEPROM to get RfIcType before initial RF registers
-	// Initialize RF register to default value
+	/* Driver must read EEPROM to get RfIcType before initial RF registers */
+	/* Initialize RF register to default value */
 	if (IS_RT3070(pAd) || IS_RT3071(pAd)) {
-		// Init RF calibration
-		// Driver should toggle RF R30 bit7 before init RF registers
+		/* Init RF calibration */
+		/* Driver should toggle RF R30 bit7 before init RF registers */
 		UINT32 RfReg = 0;
 		UINT32 data;
 
@@ -63,38 +63,38 @@ VOID NICInitRT3070RFRegisters(IN PRTMP_A
 		RfReg &= 0x7F;
 		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR) RfReg);
 
-		// Initialize RF register to default value
+		/* Initialize RF register to default value */
 		for (i = 0; i < NUM_RF_REG_PARMS; i++) {
 			RT30xxWriteRFRegister(pAd,
 					      RT30xx_RFRegTable[i].Register,
 					      RT30xx_RFRegTable[i].Value);
 		}
 
-		// add by johnli
+		/* add by johnli */
 		if (IS_RT3070(pAd)) {
-			//
-			// The DAC issue(LDO_CFG0) has been fixed in RT3070(F).
-			// The voltage raising patch is no longer needed for RT3070(F)
-			//
+			/* */
+			/* The DAC issue(LDO_CFG0) has been fixed in RT3070(F). */
+			/* The voltage raising patch is no longer needed for RT3070(F) */
+			/* */
 			if ((pAd->MACVersion & 0xffff) < 0x0201) {
-				//  Update MAC 0x05D4 from 01xxxxxx to 0Dxxxxxx (voltage 1.2V to 1.35V) for RT3070 to improve yield rate
+				/*  Update MAC 0x05D4 from 01xxxxxx to 0Dxxxxxx (voltage 1.2V to 1.35V) for RT3070 to improve yield rate */
 				RTUSBReadMACRegister(pAd, LDO_CFG0, &data);
 				data = ((data & 0xF0FFFFFF) | 0x0D000000);
 				RTUSBWriteMACRegister(pAd, LDO_CFG0, data);
 			}
 		} else if (IS_RT3071(pAd)) {
-			// Driver should set RF R6 bit6 on before init RF registers
+			/* Driver should set RF R6 bit6 on before init RF registers */
 			RT30xxReadRFRegister(pAd, RF_R06, (PUCHAR) & RfReg);
 			RfReg |= 0x40;
 			RT30xxWriteRFRegister(pAd, RF_R06, (UCHAR) RfReg);
 
-			// init R31
+			/* init R31 */
 			RT30xxWriteRFRegister(pAd, RF_R31, 0x14);
 
-			// RT3071 version E has fixed this issue
+			/* RT3071 version E has fixed this issue */
 			if ((pAd->NicConfig2.field.DACTestBit == 1)
 			    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
-				// patch tx EVM issue temporarily
+				/* patch tx EVM issue temporarily */
 				RTUSBReadMACRegister(pAd, LDO_CFG0, &data);
 				data = ((data & 0xE0FFFFFF) | 0x0D000000);
 				RTUSBWriteMACRegister(pAd, LDO_CFG0, data);
@@ -104,35 +104,35 @@ VOID NICInitRT3070RFRegisters(IN PRTMP_A
 				RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
 			}
 
-			// patch LNA_PE_G1 failed issue
+			/* patch LNA_PE_G1 failed issue */
 			RTUSBReadMACRegister(pAd, GPIO_SWITCH, &data);
 			data &= ~(0x20);
 			RTUSBWriteMACRegister(pAd, GPIO_SWITCH, data);
 		}
-		//For RF filter Calibration
+		/*For RF filter Calibration */
 		RTMPFilterCalibration(pAd);
 
-		// Initialize RF R27 register, set RF R27 must be behind RTMPFilterCalibration()
-		//
-		// TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F).
-		// Raising RF voltage is no longer needed for RT3070(F)
-		//
+		/* Initialize RF R27 register, set RF R27 must be behind RTMPFilterCalibration() */
+		/* */
+		/* TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F). */
+		/* Raising RF voltage is no longer needed for RT3070(F) */
+		/* */
 		if ((IS_RT3070(pAd)) && ((pAd->MACVersion & 0xffff) < 0x0201)) {
 			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
 		} else if ((IS_RT3071(pAd))
 			   && ((pAd->MACVersion & 0xffff) < 0x0211)) {
 			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
 		}
-		// set led open drain enable
+		/* set led open drain enable */
 		RTUSBReadMACRegister(pAd, OPT_14, &data);
 		data |= 0x01;
 		RTUSBWriteMACRegister(pAd, OPT_14, data);
 
-		// move from RT30xxLoadRFNormalModeSetup because it's needed for both RT3070 and RT3071
-		// TX_LO1_en, RF R17 register Bit 3 to 0
+		/* move from RT30xxLoadRFNormalModeSetup because it's needed for both RT3070 and RT3071 */
+		/* TX_LO1_en, RF R17 register Bit 3 to 0 */
 		RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
 		RFValue &= (~0x08);
-		// to fix rx long range issue
+		/* to fix rx long range issue */
 		if (pAd->NicConfig2.field.ExternalLNAForG == 0) {
 			if ((IS_RT3071(pAd)
 			     && ((pAd->MACVersion & 0xffff) >= 0x0211))
@@ -140,22 +140,22 @@ VOID NICInitRT3070RFRegisters(IN PRTMP_A
 				RFValue |= 0x20;
 			}
 		}
-		// set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h
+		/* set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h */
 		if (pAd->TxMixerGain24G >= 1) {
-			RFValue &= (~0x7);	// clean bit [2:0]
+			RFValue &= (~0x7);	/* clean bit [2:0] */
 			RFValue |= pAd->TxMixerGain24G;
 		}
 		RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
 
 		if (IS_RT3071(pAd)) {
-			// add by johnli, RF power sequence setup, load RF normal operation-mode setup
+			/* add by johnli, RF power sequence setup, load RF normal operation-mode setup */
 			RT30xxLoadRFNormalModeSetup(pAd);
 		} else if (IS_RT3070(pAd)) {
 			/* add by johnli, reset RF_R27 when interface down & up to fix throughput problem */
-			// LDORF_VC, RF R27 register Bit 2 to 0
+			/* LDORF_VC, RF R27 register Bit 2 to 0 */
 			RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
-			// TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F).
-			// Raising RF voltage is no longer needed for RT3070(F)
+			/* TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F). */
+			/* Raising RF voltage is no longer needed for RT3070(F) */
 			if ((pAd->MACVersion & 0xffff) < 0x0201)
 				RFValue = (RFValue & (~0x77)) | 0x3;
 			else
@@ -166,4 +166,4 @@ VOID NICInitRT3070RFRegisters(IN PRTMP_A
 	}
 
 }
-#endif // RT3070 //
+#endif /* RT3070 // */
--- a/drivers/staging/rt2860/chips/rt3090.c
+++ b/drivers/staging/rt2860/chips/rt3090.c
@@ -41,16 +41,16 @@
 
 #ifndef RTMP_RF_RW_SUPPORT
 #error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
-#endif // RTMP_RF_RW_SUPPORT //
+#endif /* RTMP_RF_RW_SUPPORT // */
 
 VOID NICInitRT3090RFRegisters(IN PRTMP_ADAPTER pAd)
 {
 	INT i;
-	// Driver must read EEPROM to get RfIcType before initial RF registers
-	// Initialize RF register to default value
+	/* Driver must read EEPROM to get RfIcType before initial RF registers */
+	/* Initialize RF register to default value */
 	if (IS_RT3090(pAd)) {
-		// Init RF calibration
-		// Driver should toggle RF R30 bit7 before init RF registers
+		/* Init RF calibration */
+		/* Driver should toggle RF R30 bit7 before init RF registers */
 		UINT32 RfReg = 0, data;
 
 		RT30xxReadRFRegister(pAd, RF_R30, (PUCHAR) & RfReg);
@@ -60,14 +60,14 @@ VOID NICInitRT3090RFRegisters(IN PRTMP_A
 		RfReg &= 0x7F;
 		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR) RfReg);
 
-		// init R24, R31
+		/* init R24, R31 */
 		RT30xxWriteRFRegister(pAd, RF_R24, 0x0F);
 		RT30xxWriteRFRegister(pAd, RF_R31, 0x0F);
 
-		// RT309x version E has fixed this issue
+		/* RT309x version E has fixed this issue */
 		if ((pAd->NicConfig2.field.DACTestBit == 1)
 		    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
-			// patch tx EVM issue temporarily
+			/* patch tx EVM issue temporarily */
 			RTMP_IO_READ32(pAd, LDO_CFG0, &data);
 			data = ((data & 0xE0FFFFFF) | 0x0D000000);
 			RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
@@ -77,43 +77,43 @@ VOID NICInitRT3090RFRegisters(IN PRTMP_A
 			RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
 		}
 
-		// patch LNA_PE_G1 failed issue
+		/* patch LNA_PE_G1 failed issue */
 		RTMP_IO_READ32(pAd, GPIO_SWITCH, &data);
 		data &= ~(0x20);
 		RTMP_IO_WRITE32(pAd, GPIO_SWITCH, data);
 
-		// Initialize RF register to default value
+		/* Initialize RF register to default value */
 		for (i = 0; i < NUM_RF_REG_PARMS; i++) {
 			RT30xxWriteRFRegister(pAd,
 					      RT30xx_RFRegTable[i].Register,
 					      RT30xx_RFRegTable[i].Value);
 		}
 
-		// Driver should set RF R6 bit6 on before calibration
+		/* Driver should set RF R6 bit6 on before calibration */
 		RT30xxReadRFRegister(pAd, RF_R06, (PUCHAR) & RfReg);
 		RfReg |= 0x40;
 		RT30xxWriteRFRegister(pAd, RF_R06, (UCHAR) RfReg);
 
-		//For RF filter Calibration
+		/*For RF filter Calibration */
 		RTMPFilterCalibration(pAd);
 
-		// Initialize RF R27 register, set RF R27 must be behind RTMPFilterCalibration()
+		/* Initialize RF R27 register, set RF R27 must be behind RTMPFilterCalibration() */
 		if ((pAd->MACVersion & 0xffff) < 0x0211)
 			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
 
-		// set led open drain enable
+		/* set led open drain enable */
 		RTMP_IO_READ32(pAd, OPT_14, &data);
 		data |= 0x01;
 		RTMP_IO_WRITE32(pAd, OPT_14, data);
 
-		// set default antenna as main
+		/* set default antenna as main */
 		if (pAd->RfIcType == RFIC_3020)
 			AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt);
 
-		// add by johnli, RF power sequence setup, load RF normal operation-mode setup
+		/* add by johnli, RF power sequence setup, load RF normal operation-mode setup */
 		RT30xxLoadRFNormalModeSetup(pAd);
 	}
 
 }
 
-#endif // RT3090 //
+#endif /* RT3090 // */
--- a/drivers/staging/rt2860/chips/rt30xx.c
+++ b/drivers/staging/rt2860/chips/rt30xx.c
@@ -39,13 +39,13 @@
 
 #ifndef RTMP_RF_RW_SUPPORT
 #error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
-#endif // RTMP_RF_RW_SUPPORT //
+#endif /* RTMP_RF_RW_SUPPORT // */
 
 #include "../rt_config.h"
 
-//
-// RF register initialization set
-//
+/* */
+/* RF register initialization set */
+/* */
 REG_PAIR RT30xx_RFRegTable[] = {
 	{RF_R04, 0x40}
 	,
@@ -89,12 +89,12 @@ REG_PAIR RT30xx_RFRegTable[] = {
 
 UCHAR NUM_RF_REG_PARMS = (sizeof(RT30xx_RFRegTable) / sizeof(REG_PAIR));
 
-// Antenna divesity use GPIO3 and EESK pin for control
-// Antenna and EEPROM access are both using EESK pin,
-// Therefor we should avoid accessing EESK at the same time
-// Then restore antenna after EEPROM access
-// The original name of this function is AsicSetRxAnt(), now change to
-//VOID AsicSetRxAnt(
+/* Antenna divesity use GPIO3 and EESK pin for control */
+/* Antenna and EEPROM access are both using EESK pin, */
+/* Therefor we should avoid accessing EESK at the same time */
+/* Then restore antenna after EEPROM access */
+/* The original name of this function is AsicSetRxAnt(), now change to */
+/*VOID AsicSetRxAnt( */
 VOID RT30xxSetRxAnt(IN PRTMP_ADAPTER pAd, IN UCHAR Ant)
 {
 	UINT32 Value;
@@ -109,16 +109,16 @@ VOID RT30xxSetRxAnt(IN PRTMP_ADAPTER pAd
 	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
 		return;
 	}
-	// the antenna selection is through firmware and MAC register(GPIO3)
+	/* the antenna selection is through firmware and MAC register(GPIO3) */
 	if (Ant == 0) {
-		// Main antenna
+		/* Main antenna */
 #ifdef RTMP_MAC_PCI
 		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
 		x |= (EESK);
 		RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 #else
 		AsicSendCommandToMcu(pAd, 0x73, 0xFF, 0x1, 0x0);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 		RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &Value);
 		Value &= ~(0x0808);
@@ -126,14 +126,14 @@ VOID RT30xxSetRxAnt(IN PRTMP_ADAPTER pAd
 		DBGPRINT_RAW(RT_DEBUG_TRACE,
 			     ("AsicSetRxAnt, switch to main antenna\n"));
 	} else {
-		// Aux antenna
+		/* Aux antenna */
 #ifdef RTMP_MAC_PCI
 		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
 		x &= ~(EESK);
 		RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 #else
 		AsicSendCommandToMcu(pAd, 0x73, 0xFF, 0x0, 0x0);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 		RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &Value);
 		Value &= ~(0x0808);
 		Value |= 0x08;
@@ -165,14 +165,14 @@ VOID RTMPFilterCalibration(IN PRTMP_ADAP
 	UINT loop = 0, count = 0, loopcnt = 0, ReTry = 0;
 	UCHAR RF_R24_Value = 0;
 
-	// Give bbp filter initial value
+	/* Give bbp filter initial value */
 	pAd->Mlme.CaliBW20RfR24 = 0x1F;
-	pAd->Mlme.CaliBW40RfR24 = 0x2F;	//Bit[5] must be 1 for BW 40
+	pAd->Mlme.CaliBW40RfR24 = 0x2F;	/*Bit[5] must be 1 for BW 40 */
 
 	do {
-		if (loop == 1)	//BandWidth = 40 MHz
+		if (loop == 1)	/*BandWidth = 40 MHz */
 		{
-			// Write 0x27 to RF_R24 to program filter
+			/* Write 0x27 to RF_R24 to program filter */
 			RF_R24_Value = 0x27;
 			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
 			if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
@@ -180,19 +180,19 @@ VOID RTMPFilterCalibration(IN PRTMP_ADAP
 			else
 				FilterTarget = 0x19;
 
-			// when calibrate BW40, BBP mask must set to BW40.
+			/* when calibrate BW40, BBP mask must set to BW40. */
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 			BBPValue &= (~0x18);
 			BBPValue |= (0x10);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
 
-			// set to BW40
+			/* set to BW40 */
 			RT30xxReadRFRegister(pAd, RF_R31, &value);
 			value |= 0x20;
 			RT30xxWriteRFRegister(pAd, RF_R31, value);
-		} else		//BandWidth = 20 MHz
+		} else		/*BandWidth = 20 MHz */
 		{
-			// Write 0x07 to RF_R24 to program filter
+			/* Write 0x07 to RF_R24 to program filter */
 			RF_R24_Value = 0x07;
 			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
 			if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
@@ -200,39 +200,39 @@ VOID RTMPFilterCalibration(IN PRTMP_ADAP
 			else
 				FilterTarget = 0x16;
 
-			// set to BW20
+			/* set to BW20 */
 			RT30xxReadRFRegister(pAd, RF_R31, &value);
 			value &= (~0x20);
 			RT30xxWriteRFRegister(pAd, RF_R31, value);
 		}
 
-		// Write 0x01 to RF_R22 to enable baseband loopback mode
+		/* Write 0x01 to RF_R22 to enable baseband loopback mode */
 		RT30xxReadRFRegister(pAd, RF_R22, &value);
 		value |= 0x01;
 		RT30xxWriteRFRegister(pAd, RF_R22, value);
 
-		// Write 0x00 to BBP_R24 to set power & frequency of passband test tone
+		/* Write 0x00 to BBP_R24 to set power & frequency of passband test tone */
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R24, 0);
 
 		do {
-			// Write 0x90 to BBP_R25 to transmit test tone
+			/* Write 0x90 to BBP_R25 to transmit test tone */
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R25, 0x90);
 
 			RTMPusecDelay(1000);
-			// Read BBP_R55[6:0] for received power, set R55x = BBP_R55[6:0]
+			/* Read BBP_R55[6:0] for received power, set R55x = BBP_R55[6:0] */
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R55, &value);
 			R55x = value & 0xFF;
 
 		} while ((ReTry++ < 100) && (R55x == 0));
 
-		// Write 0x06 to BBP_R24 to set power & frequency of stopband test tone
+		/* Write 0x06 to BBP_R24 to set power & frequency of stopband test tone */
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R24, 0x06);
 
 		while (TRUE) {
-			// Write 0x90 to BBP_R25 to transmit test tone
+			/* Write 0x90 to BBP_R25 to transmit test tone */
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R25, 0x90);
 
-			//We need to wait for calibration
+			/*We need to wait for calibration */
 			RTMPusecDelay(1000);
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R55, &value);
 			value &= 0xFF;
@@ -245,27 +245,27 @@ VOID RTMPFilterCalibration(IN PRTMP_ADAP
 				break;
 			}
 
-			// prevent infinite loop cause driver hang.
+			/* prevent infinite loop cause driver hang. */
 			if (loopcnt++ > 100) {
 				DBGPRINT(RT_DEBUG_ERROR,
 					 ("RTMPFilterCalibration - can't find a valid value, loopcnt=%d stop calibrating",
 					  loopcnt));
 				break;
 			}
-			// Write RF_R24 to program filter
+			/* Write RF_R24 to program filter */
 			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
 		}
 
 		if (count > 0) {
 			RF_R24_Value = RF_R24_Value - ((count) ? (1) : (0));
 		}
-		// Store for future usage
+		/* Store for future usage */
 		if (loopcnt < 100) {
 			if (loop++ == 0) {
-				//BandWidth = 20 MHz
+				/*BandWidth = 20 MHz */
 				pAd->Mlme.CaliBW20RfR24 = (UCHAR) RF_R24_Value;
 			} else {
-				//BandWidth = 40 MHz
+				/*BandWidth = 40 MHz */
 				pAd->Mlme.CaliBW40RfR24 = (UCHAR) RF_R24_Value;
 				break;
 			}
@@ -274,20 +274,20 @@ VOID RTMPFilterCalibration(IN PRTMP_ADAP
 
 		RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
 
-		// reset count
+		/* reset count */
 		count = 0;
 	} while (TRUE);
 
-	//
-	// Set back to initial state
-	//
+	/* */
+	/* Set back to initial state */
+	/* */
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R24, 0);
 
 	RT30xxReadRFRegister(pAd, RF_R22, &value);
 	value &= ~(0x01);
 	RT30xxWriteRFRegister(pAd, RF_R22, value);
 
-	// set BBP back to BW20
+	/* set BBP back to BW20 */
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 	BBPValue &= (~0x18);
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
@@ -297,7 +297,7 @@ VOID RTMPFilterCalibration(IN PRTMP_ADAP
 		  pAd->Mlme.CaliBW20RfR24, pAd->Mlme.CaliBW40RfR24));
 }
 
-// add by johnli, RF power sequence setup
+/* add by johnli, RF power sequence setup */
 /*
 	==========================================================================
 	Description:
@@ -310,12 +310,12 @@ VOID RT30xxLoadRFNormalModeSetup(IN PRTM
 {
 	UCHAR RFValue;
 
-	// RX0_PD & TX0_PD, RF R1 register Bit 2 & Bit 3 to 0 and RF_BLOCK_en,RX1_PD & TX1_PD, Bit0, Bit 4 & Bit5 to 1
+	/* RX0_PD & TX0_PD, RF R1 register Bit 2 & Bit 3 to 0 and RF_BLOCK_en,RX1_PD & TX1_PD, Bit0, Bit 4 & Bit5 to 1 */
 	RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
 	RFValue = (RFValue & (~0x0C)) | 0x31;
 	RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
 
-	// TX_LO2_en, RF R15 register Bit 3 to 0
+	/* TX_LO2_en, RF R15 register Bit 3 to 0 */
 	RT30xxReadRFRegister(pAd, RF_R15, &RFValue);
 	RFValue &= (~0x08);
 	RT30xxWriteRFRegister(pAd, RF_R15, RFValue);
@@ -338,22 +338,22 @@ VOID RT30xxLoadRFNormalModeSetup(IN PRTM
 	   RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
 	 */
 
-	// RX_LO1_en, RF R20 register Bit 3 to 0
+	/* RX_LO1_en, RF R20 register Bit 3 to 0 */
 	RT30xxReadRFRegister(pAd, RF_R20, &RFValue);
 	RFValue &= (~0x08);
 	RT30xxWriteRFRegister(pAd, RF_R20, RFValue);
 
-	// RX_LO2_en, RF R21 register Bit 3 to 0
+	/* RX_LO2_en, RF R21 register Bit 3 to 0 */
 	RT30xxReadRFRegister(pAd, RF_R21, &RFValue);
 	RFValue &= (~0x08);
 	RT30xxWriteRFRegister(pAd, RF_R21, RFValue);
 
 	/* add by johnli, reset RF_R27 when interface down & up to fix throughput problem */
-	// LDORF_VC, RF R27 register Bit 2 to 0
+	/* LDORF_VC, RF R27 register Bit 2 to 0 */
 	RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
-	// TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F).
-	// Raising RF voltage is no longer needed for RT3070(F)
-	if (IS_RT3090(pAd))	// RT309x and RT3071/72
+	/* TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F). */
+	/* Raising RF voltage is no longer needed for RT3070(F) */
+	if (IS_RT3090(pAd))	/* RT309x and RT3071/72 */
 	{
 		if ((pAd->MACVersion & 0xffff) < 0x0211)
 			RFValue = (RFValue & (~0x77)) | 0x3;
@@ -379,35 +379,35 @@ VOID RT30xxLoadRFSleepModeSetup(IN PRTMP
 
 #ifdef RTMP_MAC_USB
 	if (!IS_RT3572(pAd))
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	{
-		// RF_BLOCK_en. RF R1 register Bit 0 to 0
+		/* RF_BLOCK_en. RF R1 register Bit 0 to 0 */
 		RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
 		RFValue &= (~0x01);
 		RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
 
-		// VCO_IC, RF R7 register Bit 4 & Bit 5 to 0
+		/* VCO_IC, RF R7 register Bit 4 & Bit 5 to 0 */
 		RT30xxReadRFRegister(pAd, RF_R07, &RFValue);
 		RFValue &= (~0x30);
 		RT30xxWriteRFRegister(pAd, RF_R07, RFValue);
 
-		// Idoh, RF R9 register Bit 1, Bit 2 & Bit 3 to 0
+		/* Idoh, RF R9 register Bit 1, Bit 2 & Bit 3 to 0 */
 		RT30xxReadRFRegister(pAd, RF_R09, &RFValue);
 		RFValue &= (~0x0E);
 		RT30xxWriteRFRegister(pAd, RF_R09, RFValue);
 
-		// RX_CTB_en, RF R21 register Bit 7 to 0
+		/* RX_CTB_en, RF R21 register Bit 7 to 0 */
 		RT30xxReadRFRegister(pAd, RF_R21, &RFValue);
 		RFValue &= (~0x80);
 		RT30xxWriteRFRegister(pAd, RF_R21, RFValue);
 	}
 
-	if (IS_RT3090(pAd) ||	// IS_RT3090 including RT309x and RT3071/72
+	if (IS_RT3090(pAd) ||	/* IS_RT3090 including RT309x and RT3071/72 */
 	    IS_RT3572(pAd) ||
 	    (IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201))) {
 #ifdef RTMP_MAC_USB
 		if (!IS_RT3572(pAd))
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 		{
 			RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
 			RFValue |= 0x77;
@@ -435,36 +435,36 @@ VOID RT30xxReverseRFSleepModeSetup(IN PR
 
 #ifdef RTMP_MAC_USB
 	if (!IS_RT3572(pAd))
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	{
-		// RF_BLOCK_en, RF R1 register Bit 0 to 1
+		/* RF_BLOCK_en, RF R1 register Bit 0 to 1 */
 		RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
 		RFValue |= 0x01;
 		RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
 
-		// VCO_IC, RF R7 register Bit 4 & Bit 5 to 1
+		/* VCO_IC, RF R7 register Bit 4 & Bit 5 to 1 */
 		RT30xxReadRFRegister(pAd, RF_R07, &RFValue);
 		RFValue |= 0x30;
 		RT30xxWriteRFRegister(pAd, RF_R07, RFValue);
 
-		// Idoh, RF R9 register Bit 1, Bit 2 & Bit 3 to 1
+		/* Idoh, RF R9 register Bit 1, Bit 2 & Bit 3 to 1 */
 		RT30xxReadRFRegister(pAd, RF_R09, &RFValue);
 		RFValue |= 0x0E;
 		RT30xxWriteRFRegister(pAd, RF_R09, RFValue);
 
-		// RX_CTB_en, RF R21 register Bit 7 to 1
+		/* RX_CTB_en, RF R21 register Bit 7 to 1 */
 		RT30xxReadRFRegister(pAd, RF_R21, &RFValue);
 		RFValue |= 0x80;
 		RT30xxWriteRFRegister(pAd, RF_R21, RFValue);
 	}
 
-	if (IS_RT3090(pAd) ||	// IS_RT3090 including RT309x and RT3071/72
+	if (IS_RT3090(pAd) ||	/* IS_RT3090 including RT309x and RT3071/72 */
 	    IS_RT3572(pAd) ||
 	    IS_RT3390(pAd) ||
 	    (IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201))) {
 #ifdef RTMP_MAC_USB
 		if (!IS_RT3572(pAd))
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 		{
 			RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
 			if ((pAd->MACVersion & 0xffff) < 0x0211)
@@ -473,10 +473,10 @@ VOID RT30xxReverseRFSleepModeSetup(IN PR
 				RFValue = (RFValue & (~0x77));
 			RT30xxWriteRFRegister(pAd, RF_R27, RFValue);
 		}
-		// RT3071 version E has fixed this issue
+		/* RT3071 version E has fixed this issue */
 		if ((pAd->NicConfig2.field.DACTestBit == 1)
 		    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
-			// patch tx EVM issue temporarily
+			/* patch tx EVM issue temporarily */
 			RTMP_IO_READ32(pAd, LDO_CFG0, &MACValue);
 			MACValue = ((MACValue & 0xE0FFFFFF) | 0x0D000000);
 			RTMP_IO_WRITE32(pAd, LDO_CFG0, MACValue);
@@ -491,22 +491,22 @@ VOID RT30xxReverseRFSleepModeSetup(IN PR
 		RT30xxWriteRFRegister(pAd, RF_R08, 0x80);
 }
 
-// end johnli
+/* end johnli */
 
 VOID RT30xxHaltAction(IN PRTMP_ADAPTER pAd)
 {
 	UINT32 TxPinCfg = 0x00050F0F;
 
-	//
-	// Turn off LNA_PE or TRSW_POL
-	//
+	/* */
+	/* Turn off LNA_PE or TRSW_POL */
+	/* */
 	if (IS_RT3070(pAd) || IS_RT3071(pAd) || IS_RT3572(pAd)) {
 		if ((IS_RT3071(pAd) || IS_RT3572(pAd))
 #ifdef RTMP_EFUSE_SUPPORT
 		    && (pAd->bUseEfuse)
-#endif // RTMP_EFUSE_SUPPORT //
+#endif /* RTMP_EFUSE_SUPPORT // */
 		    ) {
-			TxPinCfg &= 0xFFFBF0F0;	// bit18 off
+			TxPinCfg &= 0xFFFBF0F0;	/* bit18 off */
 		} else {
 			TxPinCfg &= 0xFFFFF0F0;
 		}
@@ -515,4 +515,4 @@ VOID RT30xxHaltAction(IN PRTMP_ADAPTER p
 	}
 }
 
-#endif // RT30xx //
+#endif /* RT30xx // */
--- a/drivers/staging/rt2860/pci_main_dev.c
+++ b/drivers/staging/rt2860/pci_main_dev.c
@@ -38,17 +38,17 @@
 #include "rt_config.h"
 #include <linux/pci.h>
 
-// Following information will be show when you run 'modinfo'
-// *** If you have a solution for the bug in current version of driver, please mail to me.
-// Otherwise post to forum in ralinktech's web site(www.ralinktech.com) and let all users help you. ***
+/* Following information will be show when you run 'modinfo' */
+/* *** If you have a solution for the bug in current version of driver, please mail to me. */
+/* Otherwise post to forum in ralinktech's web site(www.ralinktech.com) and let all users help you. *** */
 MODULE_AUTHOR("Jett Chen <jett_chen@ralinktech.com>");
 MODULE_DESCRIPTION("RT2860/RT3090 Wireless Lan Linux Driver");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("rt3090sta");
 
-//
-// Function declarations
-//
+/* */
+/* Function declarations */
+/* */
 extern int rt28xx_close(IN struct net_device *net_dev);
 extern int rt28xx_open(struct net_device *net_dev);
 
@@ -64,14 +64,14 @@ static VOID RTMPInitPCIeDevice(IN struct
 #ifdef CONFIG_PM
 static int rt2860_suspend(struct pci_dev *pci_dev, pm_message_t state);
 static int rt2860_resume(struct pci_dev *pci_dev);
-#endif // CONFIG_PM //
+#endif /* CONFIG_PM // */
 
-//
-// Ralink PCI device table, include all supported chipsets
-//
+/* */
+/* Ralink PCI device table, include all supported chipsets */
+/* */
 static struct pci_device_id rt2860_pci_tbl[] __devinitdata = {
 #ifdef RT2860
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2860_PCI_DEVICE_ID)},	//RT28602.4G
+	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2860_PCI_DEVICE_ID)},	/*RT28602.4G */
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2860_PCIe_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2760_PCI_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2790_PCIe_DEVICE_ID)},
@@ -88,13 +88,13 @@ static struct pci_device_id rt2860_pci_t
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3090_PCIe_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3091_PCIe_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3092_PCIe_DEVICE_ID)},
-#endif // RT3090 //
+#endif /* RT3090 // */
 #ifdef RT3390
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3390_PCIe_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3391_PCIe_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3392_PCIe_DEVICE_ID)},
-#endif // RT3390 //
-	{0,}			// terminate list
+#endif /* RT3390 // */
+	{0,}			/* terminate list */
 };
 
 MODULE_DEVICE_TABLE(pci, rt2860_pci_tbl);
@@ -102,9 +102,9 @@ MODULE_DEVICE_TABLE(pci, rt2860_pci_tbl)
 MODULE_VERSION(STA_DRIVER_VERSION);
 #endif
 
-//
-// Our PCI driver structure
-//
+/* */
+/* Our PCI driver structure */
+/* */
 static struct pci_driver rt2860_driver = {
 name:	"rt2860",
 id_table:rt2860_pci_tbl,
@@ -125,8 +125,8 @@ resume:rt2860_resume,
 
 VOID RT2860RejectPendingPackets(IN PRTMP_ADAPTER pAd)
 {
-	// clear PS packets
-	// clear TxSw packets
+	/* clear PS packets */
+	/* clear TxSw packets */
 }
 
 static int rt2860_suspend(struct pci_dev *pci_dev, pm_message_t state)
@@ -146,33 +146,33 @@ static int rt2860_suspend(struct pci_dev
 		/* and 1 suspend/resume function for 1 module, not for each interface */
 		/* so Linux will call suspend/resume function once */
 		if (VIRTUAL_IF_NUM(pAd) > 0) {
-			// avoid users do suspend after interface is down
+			/* avoid users do suspend after interface is down */
 
-			// stop interface
+			/* stop interface */
 			netif_carrier_off(net_dev);
 			netif_stop_queue(net_dev);
 
-			// mark device as removed from system and therefore no longer available
+			/* mark device as removed from system and therefore no longer available */
 			netif_device_detach(net_dev);
 
-			// mark halt flag
+			/* mark halt flag */
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
-			// take down the device
+			/* take down the device */
 			rt28xx_close((PNET_DEV) net_dev);
 
 			RT_MOD_DEC_USE_COUNT();
 		}
 	}
 
-	// reference to http://vovo2000.com/type-lab/linux/kernel-api/linux-kernel-api.html
-	// enable device to generate PME# when suspended
-	// pci_choose_state(): Choose the power state of a PCI device to be suspended
+	/* reference to http://vovo2000.com/type-lab/linux/kernel-api/linux-kernel-api.html */
+	/* enable device to generate PME# when suspended */
+	/* pci_choose_state(): Choose the power state of a PCI device to be suspended */
 	retval = pci_enable_wake(pci_dev, pci_choose_state(pci_dev, state), 1);
-	// save the PCI configuration space of a device before suspending
+	/* save the PCI configuration space of a device before suspending */
 	pci_save_state(pci_dev);
-	// disable PCI device after use
+	/* disable PCI device after use */
 	pci_disable_device(pci_dev);
 
 	retval = pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));
@@ -187,22 +187,22 @@ static int rt2860_resume(struct pci_dev 
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) NULL;
 	INT32 retval;
 
-	// set the power state of a PCI device
-	// PCI has 4 power states, DO (normal) ~ D3(less power)
-	// in include/linux/pci.h, you can find that
-	// #define PCI_D0          ((pci_power_t __force) 0)
-	// #define PCI_D1          ((pci_power_t __force) 1)
-	// #define PCI_D2          ((pci_power_t __force) 2)
-	// #define PCI_D3hot       ((pci_power_t __force) 3)
-	// #define PCI_D3cold      ((pci_power_t __force) 4)
-	// #define PCI_UNKNOWN     ((pci_power_t __force) 5)
-	// #define PCI_POWER_ERROR ((pci_power_t __force) -1)
+	/* set the power state of a PCI device */
+	/* PCI has 4 power states, DO (normal) ~ D3(less power) */
+	/* in include/linux/pci.h, you can find that */
+	/* #define PCI_D0          ((pci_power_t __force) 0) */
+	/* #define PCI_D1          ((pci_power_t __force) 1) */
+	/* #define PCI_D2          ((pci_power_t __force) 2) */
+	/* #define PCI_D3hot       ((pci_power_t __force) 3) */
+	/* #define PCI_D3cold      ((pci_power_t __force) 4) */
+	/* #define PCI_UNKNOWN     ((pci_power_t __force) 5) */
+	/* #define PCI_POWER_ERROR ((pci_power_t __force) -1) */
 	retval = pci_set_power_state(pci_dev, PCI_D0);
 
-	// restore the saved state of a PCI device
+	/* restore the saved state of a PCI device */
 	pci_restore_state(pci_dev);
 
-	// initialize device before it's used by a driver
+	/* initialize device before it's used by a driver */
 	if (pci_enable_device(pci_dev)) {
 		printk("pci enable fail!\n");
 		return 0;
@@ -220,16 +220,16 @@ static int rt2860_resume(struct pci_dev 
 		/* and 1 suspend/resume function for 1 module, not for each interface */
 		/* so Linux will call suspend/resume function once */
 		if (VIRTUAL_IF_NUM(pAd) > 0) {
-			// mark device as attached from system and restart if needed
+			/* mark device as attached from system and restart if needed */
 			netif_device_attach(net_dev);
 
 			if (rt28xx_open((PNET_DEV) net_dev) != 0) {
-				// open fail
+				/* open fail */
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("<=== rt2860_resume()\n"));
 				return 0;
 			}
-			// increase MODULE use count
+			/* increase MODULE use count */
 			RT_MOD_INC_USE_COUNT();
 
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
@@ -244,16 +244,16 @@ static int rt2860_resume(struct pci_dev 
 	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2860_resume()\n"));
 	return 0;
 }
-#endif // CONFIG_PM //
+#endif /* CONFIG_PM // */
 
 static INT __init rt2860_init_module(VOID)
 {
 	return pci_register_driver(&rt2860_driver);
 }
 
-//
-// Driver module unload function
-//
+/* */
+/* Driver module unload function */
+/* */
 static VOID __exit rt2860_cleanup_module(VOID)
 {
 	pci_unregister_driver(&rt2860_driver);
@@ -262,9 +262,9 @@ static VOID __exit rt2860_cleanup_module
 module_init(rt2860_init_module);
 module_exit(rt2860_cleanup_module);
 
-//
-// PCI device probe & initialization function
-//
+/* */
+/* PCI device probe & initialization function */
+/* */
 static INT __devinit rt2860_probe(IN struct pci_dev *pci_dev,
 				  IN const struct pci_device_id *pci_id)
 {
@@ -278,8 +278,8 @@ static INT __devinit rt2860_probe(IN str
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_probe\n"));
 
-//PCIDevInit==============================================
-	// wake up and enable device
+/*PCIDevInit============================================== */
+	/* wake up and enable device */
 	if ((rv = pci_enable_device(pci_dev)) != 0) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("Enable PCI device failed, errno=%d!\n", rv));
@@ -293,7 +293,7 @@ static INT __devinit rt2860_probe(IN str
 			 ("Request PCI resource failed, errno=%d!\n", rv));
 		goto err_out;
 	}
-	// map physical address to virtual address for accessing register
+	/* map physical address to virtual address for accessing register */
 	csr_addr =
 	    (unsigned long)ioremap(pci_resource_start(pci_dev, 0),
 				   pci_resource_len(pci_dev, 0));
@@ -310,11 +310,11 @@ static INT __devinit rt2860_probe(IN str
 			  (ULONG) csr_addr, pci_dev->irq));
 	}
 
-	// Set DMA master
+	/* Set DMA master */
 	pci_set_master(pci_dev);
 
-//RtmpDevInit==============================================
-	// Allocate RTMP_ADAPTER adapter structure
+/*RtmpDevInit============================================== */
+	/* Allocate RTMP_ADAPTER adapter structure */
 	handle = kmalloc(sizeof(struct os_cookie), GFP_KERNEL);
 	if (handle == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR,
@@ -325,25 +325,25 @@ static INT __devinit rt2860_probe(IN str
 
 	((POS_COOKIE) handle)->pci_dev = pci_dev;
 
-	rv = RTMPAllocAdapterBlock(handle, &pAd);	//shiang: we may need the pci_dev for allocate structure of "RTMP_ADAPTER"
+	rv = RTMPAllocAdapterBlock(handle, &pAd);	/*shiang: we may need the pci_dev for allocate structure of "RTMP_ADAPTER" */
 	if (rv != NDIS_STATUS_SUCCESS)
 		goto err_out_iounmap;
-	// Here are the RTMP_ADAPTER structure with pci-bus specific parameters.
+	/* Here are the RTMP_ADAPTER structure with pci-bus specific parameters. */
 	pAd->CSRBaseAddress = (PUCHAR) csr_addr;
 	DBGPRINT(RT_DEBUG_ERROR,
 		 ("pAd->CSRBaseAddress =0x%lx, csr_addr=0x%lx!\n",
 		  (ULONG) pAd->CSRBaseAddress, csr_addr));
 	RtmpRaDevCtrlInit(pAd, RTMP_DEV_INF_PCI);
 
-//NetDevInit==============================================
+/*NetDevInit============================================== */
 	net_dev = RtmpPhyNetDevInit(pAd, &netDevHook);
 	if (net_dev == NULL)
 		goto err_out_free_radev;
 
-	// Here are the net_device structure with pci-bus specific parameters.
-	net_dev->irq = pci_dev->irq;	// Interrupt IRQ number
-	net_dev->base_addr = csr_addr;	// Save CSR virtual address and irq to device structure
-	pci_set_drvdata(pci_dev, net_dev);	// Set driver data
+	/* Here are the net_device structure with pci-bus specific parameters. */
+	net_dev->irq = pci_dev->irq;	/* Interrupt IRQ number */
+	net_dev->base_addr = csr_addr;	/* Save CSR virtual address and irq to device structure */
+	pci_set_drvdata(pci_dev, net_dev);	/* Set driver data */
 
 /* for supporting Network Manager */
 	/* Set the sysfs physical device reference for the network logical device
@@ -351,8 +351,8 @@ static INT __devinit rt2860_probe(IN str
 	 */
 	SET_NETDEV_DEV(net_dev, &(pci_dev->dev));
 
-//All done, it's time to register the net device to linux kernel.
-	// Register this device
+/*All done, it's time to register the net device to linux kernel. */
+	/* Register this device */
 	rv = RtmpOSNetDevAttach(net_dev, &netDevHook);
 	if (rv)
 		goto err_out_free_netdev;
@@ -362,7 +362,7 @@ static INT __devinit rt2860_probe(IN str
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2860_probe\n"));
 
-	return 0;		// probe ok
+	return 0;		/* probe ok */
 
 	/* --------------------------- ERROR HANDLE --------------------------- */
 err_out_free_netdev:
@@ -393,39 +393,39 @@ static VOID __devexit rt2860_remove_one(
 {
 	PNET_DEV net_dev = pci_get_drvdata(pci_dev);
 	RTMP_ADAPTER *pAd = NULL;
-	ULONG csr_addr = net_dev->base_addr;	// pAd->CSRBaseAddress;
+	ULONG csr_addr = net_dev->base_addr;	/* pAd->CSRBaseAddress; */
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_remove_one\n"));
 
 	if (pAd != NULL) {
-		// Unregister/Free all allocated net_device.
+		/* Unregister/Free all allocated net_device. */
 		RtmpPhyNetDevExit(pAd, net_dev);
 
-		// Unmap CSR base address
+		/* Unmap CSR base address */
 		iounmap((char *)(csr_addr));
 
-		// release memory region
+		/* release memory region */
 		release_mem_region(pci_resource_start(pci_dev, 0),
 				   pci_resource_len(pci_dev, 0));
 
-		// Free RTMP_ADAPTER related structures.
+		/* Free RTMP_ADAPTER related structures. */
 		RtmpRaDevCtrlExit(pAd);
 
 	} else {
-		// Unregister network device
+		/* Unregister network device */
 		RtmpOSNetDevDetach(net_dev);
 
-		// Unmap CSR base address
+		/* Unmap CSR base address */
 		iounmap((char *)(net_dev->base_addr));
 
-		// release memory region
+		/* release memory region */
 		release_mem_region(pci_resource_start(pci_dev, 0),
 				   pci_resource_len(pci_dev, 0));
 	}
 
-	// Free the root net_device
+	/* Free the root net_device */
 	RtmpOSNetDevFree(net_dev);
 
 }
@@ -475,7 +475,7 @@ static VOID RTMPInitPCIeDevice(IN struct
 		   (device_id == NIC3090_PCIe_DEVICE_ID) ||
 		   (device_id == NIC3091_PCIe_DEVICE_ID) ||
 		   (device_id == NIC3092_PCIe_DEVICE_ID) ||
-#endif // RT3090 //
+#endif /* RT3090 // */
 		   0) {
 		UINT32 MacCsr0 = 0, Index = 0;
 		do {
@@ -487,8 +487,8 @@ static VOID RTMPInitPCIeDevice(IN struct
 			RTMPusecDelay(10);
 		} while (Index++ < 100);
 
-		// Support advanced power save after 2892/2790.
-		// MAC version at offset 0x1000 is 0x2872XXXX/0x2870XXXX(PCIe, USB, SDIO).
+		/* Support advanced power save after 2892/2790. */
+		/* MAC version at offset 0x1000 is 0x2872XXXX/0x2870XXXX(PCIe, USB, SDIO). */
 		if ((MacCsr0 & 0xffff0000) != 0x28600000) {
 			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_PCIE_DEVICE);
 		}
@@ -509,7 +509,7 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 		return;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
-	// Init EEPROM, and save settings
+	/* Init EEPROM, and save settings */
 	if (!(IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
 		RT28xx_EEPROM_READ16(pAd, 0x22, PCIePowerSaveLevel);
 		pAd->PCIePowerSaveLevel = PCIePowerSaveLevel & 0xff;
@@ -541,16 +541,16 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 			PCIePowerSaveLevel &= 0xff;
 			PCIePowerSaveLevel = PCIePowerSaveLevel >> 6;
 			switch (PCIePowerSaveLevel) {
-			case 0:	// Only support L0
+			case 0:	/* Only support L0 */
 				pAd->LnkCtrlBitMask = 0;
 				break;
-			case 1:	// Only enable L0s
+			case 1:	/* Only enable L0s */
 				pAd->LnkCtrlBitMask = 1;
 				break;
-			case 2:	// enable L1, L0s
+			case 2:	/* enable L1, L0s */
 				pAd->LnkCtrlBitMask = 3;
 				break;
-			case 3:	// sync with host clk and enable L1, L0s
+			case 3:	/* sync with host clk and enable L1, L0s */
 				pAd->LnkCtrlBitMask = 0x103;
 				break;
 			}
@@ -580,7 +580,7 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 	} else if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
 		UCHAR LinkCtrlSetting = 0;
 
-		// Check 3090E special setting chip.
+		/* Check 3090E special setting chip. */
 		RT28xx_EEPROM_READ16(pAd, 0x24, data2);
 		if ((data2 == 0x9280) && ((pAd->MACVersion & 0xffff) == 0x0211)) {
 			pAd->b3090ESpecialChip = TRUE;
@@ -588,37 +588,37 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 		}
 
 		RTMP_IO_READ32(pAd, AUX_CTRL, &MacValue);
-		//enable WAKE_PCIE function, which forces to enable PCIE clock when mpu interrupt asserting.
-		//Force PCIE 125MHz CLK to toggle
+		/*enable WAKE_PCIE function, which forces to enable PCIE clock when mpu interrupt asserting. */
+		/*Force PCIE 125MHz CLK to toggle */
 		MacValue |= 0x402;
 		RTMP_IO_WRITE32(pAd, AUX_CTRL, MacValue);
 		DBGPRINT_RAW(RT_DEBUG_ERROR,
 			     (" AUX_CTRL = 0x%32x\n", MacValue));
 
-		// for RT30xx F and after, PCIe infterface, and for power solution 3
+		/* for RT30xx F and after, PCIe infterface, and for power solution 3 */
 		if ((IS_VERSION_AFTER_F(pAd))
 		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode >= 2)
 		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode <= 3)) {
 			RTMP_IO_READ32(pAd, AUX_CTRL, &MacValue);
 			DBGPRINT_RAW(RT_DEBUG_ERROR,
 				     (" Read AUX_CTRL = 0x%x\n", MacValue));
-			// turn on bit 12.
-			//enable 32KHz clock mode for power saving
+			/* turn on bit 12. */
+			/*enable 32KHz clock mode for power saving */
 			MacValue |= 0x1000;
 			if (MacValue != 0xffffffff) {
 				RTMP_IO_WRITE32(pAd, AUX_CTRL, MacValue);
 				DBGPRINT_RAW(RT_DEBUG_ERROR,
 					     (" Write AUX_CTRL = 0x%x\n",
 					      MacValue));
-				// 1. if use PCIePowerSetting is 2 or 3, need to program OSC_CTRL to 0x3ff11.
+				/* 1. if use PCIePowerSetting is 2 or 3, need to program OSC_CTRL to 0x3ff11. */
 				MacValue = 0x3ff11;
 				RTMP_IO_WRITE32(pAd, OSC_CTRL, MacValue);
 				DBGPRINT_RAW(RT_DEBUG_ERROR,
 					     (" OSC_CTRL = 0x%x\n", MacValue));
-				// 2. Write PCI register Clk ref bit
+				/* 2. Write PCI register Clk ref bit */
 				RTMPrt3xSetPCIePowerLinkCtrl(pAd);
 			} else {
-				// Error read Aux_Ctrl value.  Force to use solution 1
+				/* Error read Aux_Ctrl value.  Force to use solution 1 */
 				DBGPRINT(RT_DEBUG_ERROR,
 					 (" Error Value in AUX_CTRL = 0x%x\n",
 					  MacValue));
@@ -627,20 +627,20 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 					 (" Force to use power solution1 \n"));
 			}
 		}
-		// 1. read setting from inf file.
+		/* 1. read setting from inf file. */
 
 		PCIePowerSaveLevel =
 		    (USHORT) pAd->StaCfg.PSControl.field.rt30xxPowerMode;
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("====> rt30xx Read PowerLevelMode =  0x%x.\n",
 			  PCIePowerSaveLevel));
-		// 2. Check EnableNewPS.
+		/* 2. Check EnableNewPS. */
 		if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
 			PCIePowerSaveLevel = 1;
 
 		if (IS_VERSION_BEFORE_F(pAd)
 		    && (pAd->b3090ESpecialChip == FALSE)) {
-			// Chip Version E only allow 1, So force set 1.
+			/* Chip Version E only allow 1, So force set 1. */
 			PCIePowerSaveLevel &= 0x1;
 			pAd->PCIePowerSaveLevel = (USHORT) PCIePowerSaveLevel;
 			DBGPRINT(RT_DEBUG_TRACE,
@@ -650,7 +650,7 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 			AsicSendCommandToMcu(pAd, 0x83, 0xff,
 					     (UCHAR) PCIePowerSaveLevel, 0x00);
 		} else {
-			// Chip Version F and after only allow 1 or 2 or 3. This might be modified after new chip version come out.
+			/* Chip Version F and after only allow 1 or 2 or 3. This might be modified after new chip version come out. */
 			if (!
 			    ((PCIePowerSaveLevel == 1)
 			     || (PCIePowerSaveLevel == 3)))
@@ -659,8 +659,8 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 				 ("====> rt30xx F Write 0x83 Command = 0x%x.\n",
 				  PCIePowerSaveLevel));
 			pAd->PCIePowerSaveLevel = (USHORT) PCIePowerSaveLevel;
-			// for 3090F , we need to add high-byte arg for 0x83 command to indicate the link control setting in
-			// PCI Configuration Space. Because firmware can't read PCI Configuration Space
+			/* for 3090F , we need to add high-byte arg for 0x83 command to indicate the link control setting in */
+			/* PCI Configuration Space. Because firmware can't read PCI Configuration Space */
 			if ((pAd->Rt3xxRalinkLinkCtrl & 0x2)
 			    && (pAd->Rt3xxHostLinkCtrl & 0x2)) {
 				LinkCtrlSetting = 1;
@@ -673,11 +673,11 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 					     LinkCtrlSetting);
 		}
 	}
-	// Find Ralink PCIe Device's Express Capability Offset
+	/* Find Ralink PCIe Device's Express Capability Offset */
 	pos = pci_find_capability(pObj->pci_dev, PCI_CAP_ID_EXP);
 
 	if (pos != 0) {
-		// Ralink PCIe Device's Link Control Register Offset
+		/* Ralink PCIe Device's Link Control Register Offset */
 		pAd->RLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
 		pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
 				     &reg16);
@@ -698,7 +698,7 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 				 ("Write (Ralink PCIe Link Control Register)  offset 0x%x = 0x%x\n",
 				  pos + PCI_EXP_LNKCTL, Configuration));
 		}
-#endif // RT2860 //
+#endif /* RT2860 // */
 
 		RTMPFindHostPCIDev(pAd);
 		if (pObj->parent_pci_dev) {
@@ -711,14 +711,14 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 				bFindIntel = TRUE;
 				RTMP_SET_PSFLAG(pAd, fRTMP_PS_TOGGLE_L1);
 			}
-			// Find PCI-to-PCI Bridge Express Capability Offset
+			/* Find PCI-to-PCI Bridge Express Capability Offset */
 			pos =
 			    pci_find_capability(pObj->parent_pci_dev,
 						PCI_CAP_ID_EXP);
 
 			if (pos != 0) {
 				BOOLEAN bChange = FALSE;
-				// PCI-to-PCI Bridge Link Control Register Offset
+				/* PCI-to-PCI Bridge Link Control Register Offset */
 				pAd->HostLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
 				pci_read_config_word(pObj->parent_pci_dev,
 						     pAd->HostLnkCtrlOffset,
@@ -739,7 +739,7 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 				case NIC2790_PCIe_DEVICE_ID:
 					bChange = TRUE;
 					break;
-#endif // RT2860 //
+#endif /* RT2860 // */
 #ifdef RT3090
 				case NIC3090_PCIe_DEVICE_ID:
 				case NIC3091_PCIe_DEVICE_ID:
@@ -747,7 +747,7 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 					if (bFindIntel == FALSE)
 						bChange = TRUE;
 					break;
-#endif // RT3090 //
+#endif /* RT3090 // */
 				default:
 					break;
 				}
@@ -782,14 +782,14 @@ VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_
 	if (bFindIntel == FALSE) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("Doesn't find Intel PCI host controller. \n"));
-		// Doesn't switch L0, L1, So set PCIePowerSaveLevel to 0xff
+		/* Doesn't switch L0, L1, So set PCIePowerSaveLevel to 0xff */
 		pAd->PCIePowerSaveLevel = 0xff;
 		if ((pAd->RLnkCtrlOffset != 0)
 #ifdef RT3090
 		    && ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
 			|| (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
 			|| (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
-#endif // RT3090 //
+#endif /* RT3090 // */
 		    ) {
 			pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
 					     &reg16);
@@ -871,20 +871,20 @@ VOID RTMPPCIeLinkCtrlValueRestore(IN PRT
 	if (!((pObj->DeviceID == NIC2860_PCIe_DEVICE_ID)
 	      || (pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)))
 		return;
-#endif // RT2860 //
-	// Check PSControl Configuration
+#endif /* RT2860 // */
+	/* Check PSControl Configuration */
 	if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
 		return;
 
-	//3090 will not execute the following codes.
-	// Check interface : If not PCIe interface, return.
+	/*3090 will not execute the following codes. */
+	/* Check interface : If not PCIe interface, return. */
 
 #ifdef RT3090
 	if ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
 	    || (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
 	    || (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
 		return;
-#endif // RT3090 //
+#endif /* RT3090 // */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
 	PCIePowerSaveLevel = pAd->PCIePowerSaveLevel;
@@ -898,7 +898,7 @@ VOID RTMPPCIeLinkCtrlValueRestore(IN PRT
 				  Configuration);
 		if ((Configuration != 0) && (Configuration != 0xFFFF)) {
 			Configuration &= 0xfefc;
-			// If call from interface down, restore to orginial setting.
+			/* If call from interface down, restore to orginial setting. */
 			if (Level == RESTORE_CLOSE) {
 				Configuration |= pAd->HostLnkCtrlConfiguration;
 			} else
@@ -920,7 +920,7 @@ VOID RTMPPCIeLinkCtrlValueRestore(IN PRT
 				  Configuration);
 		if ((Configuration != 0) && (Configuration != 0xFFFF)) {
 			Configuration &= 0xfefc;
-			// If call from interface down, restore to orginial setting.
+			/* If call from interface down, restore to orginial setting. */
 			if (Level == RESTORE_CLOSE)
 				Configuration |= pAd->RLnkCtrlConfiguration;
 			else
@@ -965,20 +965,20 @@ VOID RTMPPCIeLinkCtrlSetting(IN PRTMP_AD
 	if (!((pObj->DeviceID == NIC2860_PCIe_DEVICE_ID)
 	      || (pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)))
 		return;
-#endif // RT2860 //
-	// Check PSControl Configuration
+#endif /* RT2860 // */
+	/* Check PSControl Configuration */
 	if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
 		return;
 
-	// Check interface : If not PCIe interface, return.
-	//Block 3090 to enter the following function
+	/* Check interface : If not PCIe interface, return. */
+	/*Block 3090 to enter the following function */
 
 #ifdef RT3090
 	if ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
 	    || (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
 	    || (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
 		return;
-#endif // RT3090 //
+#endif /* RT3090 // */
 	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP)) {
 		DBGPRINT(RT_DEBUG_INFO,
 			 ("RTMPPCIePowerLinkCtrl return on fRTMP_PS_CAN_GO_SLEEP flag\n"));
@@ -993,27 +993,27 @@ VOID RTMPPCIeLinkCtrlSetting(IN PRTMP_AD
 	}
 	PCIePowerSaveLevel = PCIePowerSaveLevel >> 6;
 
-	// Skip non-exist deice right away
+	/* Skip non-exist deice right away */
 	if (pObj->parent_pci_dev && (pAd->HostLnkCtrlOffset != 0)) {
 		PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset,
 				  Configuration);
 		switch (PCIePowerSaveLevel) {
 		case 0:
-			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00
+			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00 */
 			Configuration &= 0xfefc;
 			break;
 		case 1:
-			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01
+			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01 */
 			Configuration &= 0xfefc;
 			Configuration |= 0x1;
 			break;
 		case 2:
-			//  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11
+			/*  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 */
 			Configuration &= 0xfefc;
 			Configuration |= 0x3;
 			break;
 		case 3:
-			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1
+			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1 */
 			Configuration &= 0xfefc;
 			Configuration |= 0x103;
 			break;
@@ -1026,7 +1026,7 @@ VOID RTMPPCIeLinkCtrlSetting(IN PRTMP_AD
 	}
 
 	if (pObj->pci_dev && (pAd->RLnkCtrlOffset != 0)) {
-		// first 2892 chip not allow to frequently set mode 3. will cause hang problem.
+		/* first 2892 chip not allow to frequently set mode 3. will cause hang problem. */
 		if (PCIePowerSaveLevel > Max)
 			PCIePowerSaveLevel = Max;
 
@@ -1034,25 +1034,25 @@ VOID RTMPPCIeLinkCtrlSetting(IN PRTMP_AD
 				  Configuration);
 		switch (PCIePowerSaveLevel) {
 		case 0:
-			// No PCI power safe
-			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00 .
+			/* No PCI power safe */
+			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00 . */
 			Configuration &= 0xfefc;
 			break;
 		case 1:
-			//  L0
-			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01 .
+			/*  L0 */
+			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01 . */
 			Configuration &= 0xfefc;
 			Configuration |= 0x1;
 			break;
 		case 2:
-			// L0 and L1
-			//  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11
+			/* L0 and L1 */
+			/*  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 */
 			Configuration &= 0xfefc;
 			Configuration |= 0x3;
 			break;
 		case 3:
-			// L0 , L1 and clock management.
-			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1
+			/* L0 , L1 and clock management. */
+			/* Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1 */
 			Configuration &= 0xfefc;
 			Configuration |= 0x103;
 			pAd->bPCIclkOff = TRUE;
@@ -1091,35 +1091,35 @@ VOID RTMPrt3xSetPCIePowerLinkCtrl(IN PRT
 		 ("RTMPrt3xSetPCIePowerLinkCtrl.===> %lx\n",
 		  pAd->StaCfg.PSControl.word));
 
-	// Check PSControl Configuration
+	/* Check PSControl Configuration */
 	if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
 		return;
 	RTMPFindHostPCIDev(pAd);
 	if (pObj->parent_pci_dev) {
-		// Find PCI-to-PCI Bridge Express Capability Offset
+		/* Find PCI-to-PCI Bridge Express Capability Offset */
 		pos = pci_find_capability(pObj->parent_pci_dev, PCI_CAP_ID_EXP);
 
 		if (pos != 0) {
 			pAd->HostLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
 		}
-		// If configurared to turn on L1.
+		/* If configurared to turn on L1. */
 		HostConfiguration = 0;
 		if (pAd->StaCfg.PSControl.field.rt30xxForceASPMTest == 1) {
 			DBGPRINT(RT_DEBUG_TRACE, ("Enter,PSM : Force ASPM \n"));
 
-			// Skip non-exist deice right away
+			/* Skip non-exist deice right away */
 			if ((pAd->HostLnkCtrlOffset != 0)) {
 				PCI_REG_READ_WORD(pObj->parent_pci_dev,
 						  pAd->HostLnkCtrlOffset,
 						  HostConfiguration);
-				// Prepare Configuration to write to Host
+				/* Prepare Configuration to write to Host */
 				HostConfiguration |= 0x3;
 				PCI_REG_WIRTE_WORD(pObj->parent_pci_dev,
 						   pAd->HostLnkCtrlOffset,
 						   HostConfiguration);
 				pAd->Rt3xxHostLinkCtrl = HostConfiguration;
-				// Because in rt30xxForceASPMTest Mode, Force turn on L0s, L1.
-				// Fix HostConfiguration bit0:1 = 0x3 for later use.
+				/* Because in rt30xxForceASPMTest Mode, Force turn on L0s, L1. */
+				/* Fix HostConfiguration bit0:1 = 0x3 for later use. */
 				HostConfiguration = 0x3;
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("PSM : Force ASPM : "
@@ -1129,7 +1129,7 @@ VOID RTMPrt3xSetPCIePowerLinkCtrl(IN PRT
 		} else if (pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM ==
 			   1) {
 
-			// Skip non-exist deice right away
+			/* Skip non-exist deice right away */
 			if ((pAd->HostLnkCtrlOffset != 0)) {
 				PCI_REG_READ_WORD(pObj->parent_pci_dev,
 						  pAd->HostLnkCtrlOffset,
@@ -1143,12 +1143,12 @@ VOID RTMPrt3xSetPCIePowerLinkCtrl(IN PRT
 			}
 		}
 	}
-	// Prepare to write Ralink setting.
-	// Find Ralink PCIe Device's Express Capability Offset
+	/* Prepare to write Ralink setting. */
+	/* Find Ralink PCIe Device's Express Capability Offset */
 	pos = pci_find_capability(pObj->pci_dev, PCI_CAP_ID_EXP);
 
 	if (pos != 0) {
-		// Ralink PCIe Device's Link Control Register Offset
+		/* Ralink PCIe Device's Link Control Register Offset */
 		pAd->RLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
 		pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
 				     &reg16);
--- a/drivers/staging/rt2860/rt_linux.c
+++ b/drivers/staging/rt2860/rt_linux.c
@@ -30,9 +30,9 @@
 
 ULONG RTDebugLevel = RT_DEBUG_ERROR;
 
-// for wireless system event message
+/* for wireless system event message */
 char const *pWirelessSysEventText[IW_SYS_EVENT_TYPE_NUM] = {
-	// system status event
+	/* system status event */
 	"had associated successfully",	/* IW_ASSOC_EVENT_FLAG */
 	"had disassociated",	/* IW_DISASSOC_EVENT_FLAG */
 	"had deauthenticated",	/* IW_DEAUTH_EVENT_FLAG */
@@ -54,7 +54,7 @@ char const *pWirelessSysEventText[IW_SYS
 	    "scan terminate!! Busy!! Enqueue fail!!"	/* IW_SCAN_ENQUEUE_FAIL_EVENT_FLAG */
 };
 
-// for wireless IDS_spoof_attack event message
+/* for wireless IDS_spoof_attack event message */
 char const *pWirelessSpoofEventText[IW_SPOOF_EVENT_TYPE_NUM] = {
 	"detected conflict SSID",	/* IW_CONFLICT_SSID_EVENT_FLAG */
 	"detected spoofed association response",	/* IW_SPOOF_ASSOC_RESP_EVENT_FLAG */
@@ -68,7 +68,7 @@ char const *pWirelessSpoofEventText[IW_S
 	"detected replay attack"	/* IW_REPLAY_ATTACK_EVENT_FLAG */
 };
 
-// for wireless IDS_flooding_attack event message
+/* for wireless IDS_flooding_attack event message */
 char const *pWirelessFloodEventText[IW_FLOOD_EVENT_TYPE_NUM] = {
 	"detected authentication flooding",	/* IW_FLOOD_AUTH_EVENT_FLAG */
 	"detected association request flooding",	/* IW_FLOOD_ASSOC_REQ_EVENT_FLAG */
@@ -129,10 +129,10 @@ VOID RTMP_OS_Del_Timer(IN NDIS_MINIPORT_
 
 VOID RTMP_OS_Release_Packet(IN PRTMP_ADAPTER pAd, IN PQUEUE_ENTRY pEntry)
 {
-	//RTMPFreeNdisPacket(pAd, (struct sk_buff *)pEntry);
+	/*RTMPFreeNdisPacket(pAd, (struct sk_buff *)pEntry); */
 }
 
-// Unify all delay routine by using udelay
+/* Unify all delay routine by using udelay */
 VOID RTMPusecDelay(IN ULONG usec)
 {
 	ULONG i;
@@ -149,7 +149,7 @@ void RTMP_GetCurrentSystemTime(LARGE_INT
 	time->u.LowPart = jiffies;
 }
 
-// pAd MUST allow to be NULL
+/* pAd MUST allow to be NULL */
 NDIS_STATUS os_alloc_mem(IN RTMP_ADAPTER * pAd, OUT UCHAR ** mem, IN ULONG size)
 {
 	*mem = (PUCHAR) kmalloc(size, GFP_ATOMIC);
@@ -159,7 +159,7 @@ NDIS_STATUS os_alloc_mem(IN RTMP_ADAPTER
 		return (NDIS_STATUS_FAILURE);
 }
 
-// pAd MUST allow to be NULL
+/* pAd MUST allow to be NULL */
 NDIS_STATUS os_free_mem(IN PRTMP_ADAPTER pAd, IN PVOID mem)
 {
 
@@ -249,8 +249,8 @@ VOID RTMPFreeAdapter(IN PRTMP_ADAPTER pA
 	NdisFreeSpinLock(&pAd->RxRingLock);
 #ifdef RT3090
 	NdisFreeSpinLock(&pAd->McuCmdLock);
-#endif // RT3090 //
-#endif // RTMP_MAC_PCI //
+#endif /* RT3090 // */
+#endif /* RTMP_MAC_PCI // */
 
 	for (index = 0; index < NUM_OF_TX_RING; index++) {
 		NdisFreeSpinLock(&pAd->TxSwQueueLock[index]);
@@ -260,7 +260,7 @@ VOID RTMPFreeAdapter(IN PRTMP_ADAPTER pA
 
 	NdisFreeSpinLock(&pAd->irq_lock);
 
-	vfree(pAd);		// pci_free_consistent(os_cookie->pci_dev,sizeof(RTMP_ADAPTER),pAd,os_cookie->pAd_pa);
+	vfree(pAd);		/* pci_free_consistent(os_cookie->pci_dev,sizeof(RTMP_ADAPTER),pAd,os_cookie->pAd_pa); */
 	if (os_cookie)
 		kfree(os_cookie);
 }
@@ -303,7 +303,7 @@ NDIS_STATUS RTMPCloneNdisPacket(IN PRTMP
 	ASSERT(pInPacket);
 	ASSERT(ppOutPacket);
 
-	// 1. Allocate a packet
+	/* 1. Allocate a packet */
 	pkt = dev_alloc_skb(2048);
 
 	if (pkt == NULL) {
@@ -322,7 +322,7 @@ NDIS_STATUS RTMPCloneNdisPacket(IN PRTMP
 	return NDIS_STATUS_SUCCESS;
 }
 
-// the allocated NDIS PACKET must be freed via RTMPFreeNdisPacket()
+/* the allocated NDIS PACKET must be freed via RTMPFreeNdisPacket() */
 NDIS_STATUS RTMPAllocateNdisPacket(IN PRTMP_ADAPTER pAd,
 				   OUT PNDIS_PACKET * ppPacket,
 				   IN PUCHAR pHeader,
@@ -333,7 +333,7 @@ NDIS_STATUS RTMPAllocateNdisPacket(IN PR
 	ASSERT(pData);
 	ASSERT(DataLen);
 
-	// 1. Allocate a packet
+	/* 1. Allocate a packet */
 	pPacket =
 	    (PNDIS_PACKET *) dev_alloc_skb(HeaderLen + DataLen +
 					   RTMP_PKT_TAIL_PADDING);
@@ -344,18 +344,18 @@ NDIS_STATUS RTMPAllocateNdisPacket(IN PR
 #endif
 		return NDIS_STATUS_FAILURE;
 	}
-	// 2. clone the frame content
+	/* 2. clone the frame content */
 	if (HeaderLen > 0)
 		NdisMoveMemory(GET_OS_PKT_DATAPTR(pPacket), pHeader, HeaderLen);
 	if (DataLen > 0)
 		NdisMoveMemory(GET_OS_PKT_DATAPTR(pPacket) + HeaderLen, pData,
 			       DataLen);
 
-	// 3. update length of packet
+	/* 3. update length of packet */
 	skb_put(GET_OS_PKT_TYPE(pPacket), HeaderLen + DataLen);
 
 	RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
-//      printk("%s : pPacket = %p, len = %d\n", __func__, pPacket, GET_OS_PKT_LEN(pPacket));
+/*      printk("%s : pPacket = %p, len = %d\n", __func__, pPacket, GET_OS_PKT_LEN(pPacket)); */
 	*ppPacket = pPacket;
 	return NDIS_STATUS_SUCCESS;
 }
@@ -372,9 +372,9 @@ VOID RTMPFreeNdisPacket(IN PRTMP_ADAPTER
 	dev_kfree_skb_any(RTPKT_TO_OSPKT(pPacket));
 }
 
-// IRQL = DISPATCH_LEVEL
-// NOTE: we do have an assumption here, that Byte0 and Byte1 always reasid at the same
-//                       scatter gather buffer
+/* IRQL = DISPATCH_LEVEL */
+/* NOTE: we do have an assumption here, that Byte0 and Byte1 always reasid at the same */
+/*                       scatter gather buffer */
 NDIS_STATUS Sniff2BytesFromNdisBuffer(IN PNDIS_BUFFER pFirstBuffer,
 				      IN UCHAR DesiredOffset,
 				      OUT PUCHAR pByte0, OUT PUCHAR pByte1)
@@ -481,7 +481,7 @@ PNDIS_PACKET duplicate_pkt_with_TKIP_MIC
 
 	skb = RTPKT_TO_OSPKT(pPacket);
 	if (skb_tailroom(skb) < TKIP_TX_MIC_SIZE) {
-		// alloc a new skb and copy the packet
+		/* alloc a new skb and copy the packet */
 		newskb =
 		    skb_copy_expand(skb, skb_headroom(skb), TKIP_TX_MIC_SIZE,
 				    GFP_ATOMIC);
@@ -507,11 +507,11 @@ PNDIS_PACKET ClonePacket(IN PRTMP_ADAPTE
 	ASSERT(pPacket);
 	pRxPkt = RTPKT_TO_OSPKT(pPacket);
 
-	// clone the packet
+	/* clone the packet */
 	pClonedPkt = skb_clone(pRxPkt, MEM_ALLOC_FLAG);
 
 	if (pClonedPkt) {
-		// set the correct dataptr and data len
+		/* set the correct dataptr and data len */
 		pClonedPkt->dev = pRxPkt->dev;
 		pClonedPkt->data = pData;
 		pClonedPkt->len = DataSize;
@@ -521,9 +521,9 @@ PNDIS_PACKET ClonePacket(IN PRTMP_ADAPTE
 	return pClonedPkt;
 }
 
-//
-// change OS packet DataPtr and DataLen
-//
+/* */
+/* change OS packet DataPtr and DataLen */
+/* */
 void update_os_packet_info(IN PRTMP_ADAPTER pAd,
 			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
@@ -555,10 +555,10 @@ void wlan_802_11_to_802_3_packet(IN PRTM
 	pOSPkt->len = pRxBlk->DataSize;
 	pOSPkt->tail = pOSPkt->data + pOSPkt->len;
 
-	//
-	// copy 802.3 header
-	//
-	//
+	/* */
+	/* copy 802.3 header */
+	/* */
+	/* */
 
 	NdisMoveMemory(skb_push(pOSPkt, LENGTH_802_3), pHeader802_3,
 		       LENGTH_802_3);
@@ -633,7 +633,7 @@ VOID RTMPSendWirelessEvent(IN PRTMP_ADAP
 			   IN PUCHAR pAddr, IN UCHAR BssIdx, IN CHAR Rssi)
 {
 
-	//union         iwreq_data      wrqu;
+	/*union         iwreq_data      wrqu; */
 	PSTRING pBuf = NULL, pBufPtr = NULL;
 	USHORT event, type, BufLen;
 	UCHAR event_table_len = 0;
@@ -668,9 +668,9 @@ VOID RTMPSendWirelessEvent(IN PRTMP_ADAP
 			  event));
 		return;
 	}
-	//Allocate memory and copy the msg.
+	/*Allocate memory and copy the msg. */
 	if ((pBuf = kmalloc(IW_CUSTOM_MAX_LEN, GFP_ATOMIC)) != NULL) {
-		//Prepare the payload
+		/*Prepare the payload */
 		memset(pBuf, 0, IW_CUSTOM_MAX_LEN);
 
 		pBufPtr = pBuf;
@@ -706,7 +706,7 @@ VOID RTMPSendWirelessEvent(IN PRTMP_ADAP
 
 		RtmpOSWrielessEventSend(pAd, IWEVCUSTOM, Event_flag, NULL,
 					(PUCHAR) pBuf, BufLen);
-		//DBGPRINT(RT_DEBUG_TRACE, ("%s : %s\n", __func__, pBuf));
+		/*DBGPRINT(RT_DEBUG_TRACE, ("%s : %s\n", __func__, pBuf)); */
 
 		kfree(pBuf);
 	} else
@@ -723,7 +723,7 @@ void send_monitor_packets(IN PRTMP_ADAPT
 	USHORT header_len = 0;
 	UCHAR temp_header[40] = { 0 };
 
-	u_int32_t ralinkrate[256] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 109, 110, 111, 112, 13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260, 27, 54, 81, 108, 162, 216, 243, 270,	// Last 38
+	u_int32_t ralinkrate[256] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 109, 110, 111, 112, 13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260, 27, 54, 81, 108, 162, 216, 243, 270,	/* Last 38 */
 		54, 108, 162, 216, 324, 432, 486, 540, 14, 29, 43, 57, 87, 115,
 		    130, 144, 29, 59, 87, 115, 173, 230, 260, 288, 30, 60, 90,
 		    120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540,
@@ -761,39 +761,39 @@ void send_monitor_packets(IN PRTMP_ADAPT
 		else
 			header_len = LENGTH_802_11;
 
-		// QOS
+		/* QOS */
 		if (pRxBlk->pHeader->FC.SubType & 0x08) {
 			header_len += 2;
-			// Data skip QOS contorl field
+			/* Data skip QOS contorl field */
 			pRxBlk->DataSize -= 2;
 		}
-		// Order bit: A-Ralink or HTC+
+		/* Order bit: A-Ralink or HTC+ */
 		if (pRxBlk->pHeader->FC.Order) {
 			header_len += 4;
-			// Data skip HTC contorl field
+			/* Data skip HTC contorl field */
 			pRxBlk->DataSize -= 4;
 		}
-		// Copy Header
+		/* Copy Header */
 		if (header_len <= 40)
 			NdisMoveMemory(temp_header, pRxBlk->pData, header_len);
 
-		// skip HW padding
+		/* skip HW padding */
 		if (pRxBlk->RxD.L2PAD)
 			pRxBlk->pData += (header_len + 2);
 		else
 			pRxBlk->pData += header_len;
-	}			//end if
+	}			/*end if */
 
 	if (pRxBlk->DataSize < pOSPkt->len) {
 		skb_trim(pOSPkt, pRxBlk->DataSize);
 	} else {
 		skb_put(pOSPkt, (pRxBlk->DataSize - pOSPkt->len));
-	}			//end if
+	}			/*end if */
 
 	if ((pRxBlk->pData - pOSPkt->data) > 0) {
 		skb_put(pOSPkt, (pRxBlk->pData - pOSPkt->data));
 		skb_pull(pOSPkt, (pRxBlk->pData - pOSPkt->data));
-	}			//end if
+	}			/*end if */
 
 	if (skb_headroom(pOSPkt) < (sizeof(wlan_ng_prism2_header) + header_len)) {
 		if (pskb_expand_head
@@ -803,8 +803,8 @@ void send_monitor_packets(IN PRTMP_ADAPT
 				 ("%s : Reallocate header size of sk_buff fail!\n",
 				  __func__));
 			goto err_free_sk_buff;
-		}		//end if
-	}			//end if
+		}		/*end if */
+	}			/*end if */
 
 	if (header_len > 0)
 		NdisMoveMemory(skb_push(pOSPkt, header_len), temp_header,
@@ -856,7 +856,7 @@ void send_monitor_packets(IN PRTMP_ADAPT
 	ph->signal.did = DIDmsg_lnxind_wlansniffrm_signal;
 	ph->signal.status = 0;
 	ph->signal.len = 4;
-	ph->signal.data = 0;	//rssi + noise;
+	ph->signal.data = 0;	/*rssi + noise; */
 
 	ph->noise.did = DIDmsg_lnxind_wlansniffrm_noise;
 	ph->noise.status = 0;
@@ -948,7 +948,7 @@ int RtmpOSIRQRelease(IN PNET_DEV pNetDev
 		free_irq(pObj->pci_dev->irq, (net_dev));
 		RTMP_MSI_DISABLE(pAd);
 	}
-#endif // RTMP_PCI_SUPPORT //
+#endif /* RTMP_PCI_SUPPORT // */
 
 	return 0;
 }
@@ -985,7 +985,7 @@ void RtmpOSFileSeek(RTMP_OS_FD osfd, int
 
 int RtmpOSFileRead(RTMP_OS_FD osfd, char *pDataPtr, int readLen)
 {
-	// The object must have a read method
+	/* The object must have a read method */
 	if (osfd->f_op && osfd->f_op->read) {
 		return osfd->f_op->read(osfd, pDataPtr, readLen, &osfd->f_pos);
 	} else {
@@ -1090,7 +1090,7 @@ NDIS_STATUS RtmpOSTaskAttach(IN RTMP_OS_
 	} else {
 		pTask->taskPID = GET_PID(pid_number);
 
-		// Wait for the thread to start
+		/* Wait for the thread to start */
 		wait_for_completion(&pTask->taskComplete);
 		status = NDIS_STATUS_SUCCESS;
 	}
@@ -1172,7 +1172,7 @@ int RtmpOSNetDevAddrSet(IN PNET_DEV pNet
 	net_dev = pNetDev;
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-	// work-around for the SuSE due to it has it's own interface name management system.
+	/* work-around for the SuSE due to it has it's own interface name management system. */
 	{
 		NdisZeroMemory(pAd->StaCfg.dev_name, 16);
 		NdisMoveMemory(pAd->StaCfg.dev_name, net_dev->name,
@@ -1245,7 +1245,7 @@ void RtmpOSNetDevFree(PNET_DEV pNetDev)
 
 INT RtmpOSNetDevAlloc(IN PNET_DEV * new_dev_p, IN UINT32 privDataSize)
 {
-	// assign it as null first.
+	/* assign it as null first. */
 	*new_dev_p = NULL;
 
 	DBGPRINT(RT_DEBUG_TRACE,
@@ -1281,7 +1281,7 @@ void RtmpOSNetDeviceRefPut(PNET_DEV pNet
 INT RtmpOSNetDevDestory(IN RTMP_ADAPTER * pAd, IN PNET_DEV pNetDev)
 {
 
-	// TODO: Need to fix this
+	/* TODO: Need to fix this */
 	printk("WARNING: This function(%s) not implement yet!!!\n", __func__);
 	return 0;
 }
@@ -1297,7 +1297,7 @@ int RtmpOSNetDevAttach(IN PNET_DEV pNetD
 	int ret, rtnl_locked = FALSE;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("RtmpOSNetDevAttach()--->\n"));
-	// If we need hook some callback function to the net device structrue, now do it.
+	/* If we need hook some callback function to the net device structrue, now do it. */
 	if (pDevOpHook) {
 		PRTMP_ADAPTER pAd = NULL;
 
@@ -1312,7 +1312,7 @@ int RtmpOSNetDevAttach(IN PNET_DEV pNetD
 			pNetDev->wireless_handlers = &rt28xx_iw_handler_def;
 		}
 
-		// copy the net device mac address to the net_device structure.
+		/* copy the net device mac address to the net_device structure. */
 		NdisMoveMemory(pNetDev->dev_addr, &pDevOpHook->devAddr[0],
 			       MAC_ADDR_LEN);
 
--- a/drivers/staging/rt2860/rt_main_dev.c
+++ b/drivers/staging/rt2860/rt_main_dev.c
@@ -41,8 +41,8 @@
 /* Private Variables Used                                              */
 /*---------------------------------------------------------------------*/
 
-PSTRING mac = "";		// default 00:00:00:00:00:00
-PSTRING hostname = "";		// default CMPC
+PSTRING mac = "";		/* default 00:00:00:00:00:00 */
+PSTRING hostname = "";		/* default CMPC */
 module_param(mac, charp, 0);
 MODULE_PARM_DESC(mac, "rt28xx: wireless mac addr");
 
@@ -50,11 +50,11 @@ MODULE_PARM_DESC(mac, "rt28xx: wireless 
 /* Prototypes of Functions Used                                        */
 /*---------------------------------------------------------------------*/
 
-// public function prototype
+/* public function prototype */
 int rt28xx_close(IN struct net_device *net_dev);
 int rt28xx_open(struct net_device *net_dev);
 
-// private function prototype
+/* private function prototype */
 static INT rt28xx_send_packets(IN struct sk_buff *skb_p,
 			       IN struct net_device *net_dev);
 
@@ -87,9 +87,9 @@ int MainVirtualIF_close(IN struct net_de
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-	// Sanity check for pAd
+	/* Sanity check for pAd */
 	if (pAd == NULL)
-		return 0;	// close ok
+		return 0;	/* close ok */
 
 	netif_carrier_off(pAd->net_dev);
 	netif_stop_queue(pAd->net_dev);
@@ -117,7 +117,7 @@ int MainVirtualIF_close(IN struct net_de
 					       sizeof
 					       (MLME_DISASSOC_REQ_STRUCT));
 
-				// Prevent to connect AP again in STAMlmePeriodicExec
+				/* Prevent to connect AP again in STAMlmePeriodicExec */
 				pAd->MlmeAux.AutoReconnectSsidLen = 32;
 				NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid,
 					       pAd->MlmeAux.
@@ -142,7 +142,7 @@ int MainVirtualIF_close(IN struct net_de
 
 	RT_MOD_DEC_USE_COUNT();
 
-	return 0;		// close ok
+	return 0;		/* close ok */
 }
 
 /*
@@ -171,14 +171,14 @@ int MainVirtualIF_open(IN struct net_dev
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-	// Sanity check for pAd
+	/* Sanity check for pAd */
 	if (pAd == NULL)
-		return 0;	// close ok
+		return 0;	/* close ok */
 
 	if (VIRTUAL_IF_UP(pAd) != 0)
 		return -1;
 
-	// increase MODULE use count
+	/* increase MODULE use count */
 	RT_MOD_INC_USE_COUNT();
 
 	netif_start_queue(net_dev);
@@ -218,35 +218,35 @@ int rt28xx_close(IN PNET_DEV dev)
 #ifdef RTMP_MAC_USB
 	DECLARE_WAIT_QUEUE_HEAD(unlink_wakeup);
 	DECLARE_WAITQUEUE(wait, current);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> rt28xx_close\n"));
 
 	Cancelled = FALSE;
-	// Sanity check for pAd
+	/* Sanity check for pAd */
 	if (pAd == NULL)
-		return 0;	// close ok
+		return 0;	/* close ok */
 
 	{
 #ifdef RTMP_MAC_PCI
 		RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_CLOSE);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-		// If dirver doesn't wake up firmware here,
-		// NICLoadFirmware will hang forever when interface is up again.
+		/* If dirver doesn't wake up firmware here, */
+		/* NICLoadFirmware will hang forever when interface is up again. */
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
 			AsicForceWakeup(pAd, TRUE);
 		}
 #ifdef RTMP_MAC_USB
 		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 		MlmeRadioOff(pAd);
 #ifdef RTMP_MAC_PCI
 		pAd->bPCIclkOff = FALSE;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 	}
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
@@ -261,13 +261,13 @@ int rt28xx_close(IN PNET_DEV dev)
 	}
 
 #ifdef RTMP_MAC_USB
-	// ensure there are no more active urbs.
+	/* ensure there are no more active urbs. */
 	add_wait_queue(&unlink_wakeup, &wait);
 	pAd->wait = &unlink_wakeup;
 
-	// maybe wait for deletions to finish.
+	/* maybe wait for deletions to finish. */
 	i = 0;
-	//while((i < 25) && atomic_read(&pAd->PendingRx) > 0)
+	/*while((i < 25) && atomic_read(&pAd->PendingRx) > 0) */
 	while (i < 25) {
 		unsigned long IrqFlags;
 
@@ -278,17 +278,17 @@ int rt28xx_close(IN PNET_DEV dev)
 		}
 		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 
-		msleep(UNLINK_TIMEOUT_MS);	//Time in millisecond
+		msleep(UNLINK_TIMEOUT_MS);	/*Time in millisecond */
 		i++;
 	}
 	pAd->wait = NULL;
 	remove_wait_queue(&unlink_wakeup, &wait);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	// Stop Mlme state machine
+	/* Stop Mlme state machine */
 	MlmeHalt(pAd);
 
-	// Close net tasklets
+	/* Close net tasklets */
 	RtmpNetTaskExit(pAd);
 
 	{
@@ -298,25 +298,25 @@ int rt28xx_close(IN PNET_DEV dev)
 	MeasureReqTabExit(pAd);
 	TpcReqTabExit(pAd);
 
-	// Close kernel threads
+	/* Close kernel threads */
 	RtmpMgmtTaskExit(pAd);
 
 #ifdef RTMP_MAC_PCI
 	{
 		BOOLEAN brc;
-		//      ULONG                   Value;
+		/*      ULONG                   Value; */
 
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE)) {
 			RTMP_ASIC_INTERRUPT_DISABLE(pAd);
 		}
-		// Receive packets to clear DMA index after disable interrupt.
-		//RTMPHandleRxDoneInterrupt(pAd);
-		// put to radio off to save power when driver unload.  After radiooff, can't write /read register.  So need to finish all
-		// register access before Radio off.
+		/* Receive packets to clear DMA index after disable interrupt. */
+		/*RTMPHandleRxDoneInterrupt(pAd); */
+		/* put to radio off to save power when driver unload.  After radiooff, can't write /read register.  So need to finish all */
+		/* register access before Radio off. */
 
 		brc = RT28xxPciAsicRadioOff(pAd, RTMP_HALT, 0);
 
-//In  solution 3 of 3090F, the bPCIclkOff will be set to TRUE after calling RT28xxPciAsicRadioOff
+/*In  solution 3 of 3090F, the bPCIclkOff will be set to TRUE after calling RT28xxPciAsicRadioOff */
 		pAd->bPCIclkOff = FALSE;
 
 		if (brc == FALSE) {
@@ -335,22 +335,22 @@ int rt28xx_close(IN PNET_DEV dev)
 	// Disable Rx, register value supposed will remain after reset
 	NICIssueReset(pAd);
 */
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// Free IRQ
+	/* Free IRQ */
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 #ifdef RTMP_MAC_PCI
-		// Deregister interrupt function
+		/* Deregister interrupt function */
 		RtmpOSIRQRelease(net_dev);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
 	}
-	// Free Ring or USB buffers
+	/* Free Ring or USB buffers */
 	RTMPFreeTxRxRingMemory(pAd);
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
 
-	// Free BA reorder resource
+	/* Free BA reorder resource */
 	ba_reordering_resource_release(pAd);
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_START_UP);
@@ -360,7 +360,7 @@ int rt28xx_close(IN PNET_DEV dev)
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt28xx_close\n"));
-	return 0;		// close ok
+	return 0;		/* close ok */
 }				/* End of rt28xx_close */
 
 /*
@@ -383,11 +383,11 @@ int rt28xx_open(IN PNET_DEV dev)
 	struct net_device *net_dev = (struct net_device *)dev;
 	PRTMP_ADAPTER pAd = NULL;
 	int retval = 0;
-	//POS_COOKIE pObj;
+	/*POS_COOKIE pObj; */
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-	// Sanity check for pAd
+	/* Sanity check for pAd */
 	if (pAd == NULL) {
 		/* if 1st open fail, pAd will be free;
 		   So the net_dev->ml_priv will be NULL in 2rd open */
@@ -399,52 +399,52 @@ int rt28xx_open(IN PNET_DEV dev)
 			net_dev->wireless_handlers =
 			    (struct iw_handler_def *)&rt28xx_iw_handler_def;
 	}
-	// Request interrupt service routine for PCI device
-	// register the interrupt routine with the os
+	/* Request interrupt service routine for PCI device */
+	/* register the interrupt routine with the os */
 	RtmpOSIRQRequest(net_dev);
 
-	// Init IRQ parameters stored in pAd
+	/* Init IRQ parameters stored in pAd */
 	RTMP_IRQ_INIT(pAd);
 
-	// Chip & other init
+	/* Chip & other init */
 	if (rt28xx_init(pAd, mac, hostname) == FALSE)
 		goto err;
 
-	// Enable Interrupt
+	/* Enable Interrupt */
 	RTMP_IRQ_ENABLE(pAd);
 
-	// Now Enable RxTx
+	/* Now Enable RxTx */
 	RTMPEnableRxTx(pAd);
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_START_UP);
 
 	{
 		UINT32 reg = 0;
-		RTMP_IO_READ32(pAd, 0x1300, &reg);	// clear garbage interrupts
+		RTMP_IO_READ32(pAd, 0x1300, &reg);	/* clear garbage interrupts */
 		printk("0x1300 = %08x\n", reg);
 	}
 
 	{
-//      u32 reg;
-//      UINT8  byte;
-//      u16 tmp;
-
-//      RTMP_IO_READ32(pAd, XIFS_TIME_CFG, &reg);
-
-//      tmp = 0x0805;
-//      reg  = (reg & 0xffff0000) | tmp;
-//      RTMP_IO_WRITE32(pAd, XIFS_TIME_CFG, reg);
+/*      u32 reg; */
+/*      UINT8  byte; */
+/*      u16 tmp; */
+
+/*      RTMP_IO_READ32(pAd, XIFS_TIME_CFG, &reg); */
+
+/*      tmp = 0x0805; */
+/*      reg  = (reg & 0xffff0000) | tmp; */
+/*      RTMP_IO_WRITE32(pAd, XIFS_TIME_CFG, reg); */
 
 	}
 #ifdef RTMP_MAC_PCI
 	RTMPInitPCIeLinkCtrlValue(pAd);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	return (retval);
 
 err:
-//+++Add by shiang, move from rt28xx_init() to here.
+/*+++Add by shiang, move from rt28xx_init() to here. */
 	RtmpOSIRQRelease(net_dev);
-//---Add by shiang, move from rt28xx_init() to here.
+/*---Add by shiang, move from rt28xx_init() to here. */
 	return (-1);
 }				/* End of rt28xx_open */
 
@@ -463,7 +463,7 @@ PNET_DEV RtmpPhyNetDevInit(IN RTMP_ADAPT
 			   IN RTMP_OS_NETDEV_OP_HOOK * pNetDevHook)
 {
 	struct net_device *net_dev = NULL;
-//      NDIS_STATUS             Status;
+/*      NDIS_STATUS             Status; */
 
 	net_dev =
 	    RtmpOSNetDevCreate(pAd, INT_MAIN, 0, sizeof(PRTMP_ADAPTER),
@@ -518,16 +518,16 @@ int rt28xx_packet_xmit(struct sk_buff *s
 	/* RT2870STA does this in RTMPSendPackets() */
 
 	{
-		// Drop send request since we are in monitor mode
+		/* Drop send request since we are in monitor mode */
 		if (MONITOR_ON(pAd)) {
 			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 			goto done;
 		}
 	}
 
-	// EapolStart size is 18
+	/* EapolStart size is 18 */
 	if (skb->len < 14) {
-		//printk("bad packet size: %d\n", pkt->len);
+		/*printk("bad packet size: %d\n", pkt->len); */
 		hex_dump("bad packet", skb->data, skb->len);
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 		goto done;
@@ -577,7 +577,7 @@ static int rt28xx_send_packets(IN struct
 	return rt28xx_packet_xmit(skb_p);
 }
 
-// This function will be called when query /proc
+/* This function will be called when query /proc */
 struct iw_statistics *rt28xx_get_wireless_stats(IN struct net_device *net_dev)
 {
 	PRTMP_ADAPTER pAd = NULL;
@@ -586,9 +586,9 @@ struct iw_statistics *rt28xx_get_wireles
 
 	DBGPRINT(RT_DEBUG_TRACE, ("rt28xx_get_wireless_stats --->\n"));
 
-	pAd->iw_stats.status = 0;	// Status - device dependent for now
+	pAd->iw_stats.status = 0;	/* Status - device dependent for now */
 
-	// link quality
+	/* link quality */
 	if (pAd->OpMode == OPMODE_STA)
 		pAd->iw_stats.qual.qual =
 		    ((pAd->Mlme.ChannelQuality * 12) / 10 + 10);
@@ -603,16 +603,16 @@ struct iw_statistics *rt28xx_get_wireles
 				pAd->StaCfg.RssiSample.LastRssi2);
 	}
 
-	pAd->iw_stats.qual.noise = pAd->BbpWriteLatch[66];	// noise level (dBm)
+	pAd->iw_stats.qual.noise = pAd->BbpWriteLatch[66];	/* noise level (dBm) */
 
 	pAd->iw_stats.qual.noise += 256 - 143;
-	pAd->iw_stats.qual.updated = 1;	// Flags to know if updated
+	pAd->iw_stats.qual.updated = 1;	/* Flags to know if updated */
 #ifdef IW_QUAL_DBM
-	pAd->iw_stats.qual.updated |= IW_QUAL_DBM;	// Level + Noise are dBm
-#endif // IW_QUAL_DBM //
+	pAd->iw_stats.qual.updated |= IW_QUAL_DBM;	/* Level + Noise are dBm */
+#endif /* IW_QUAL_DBM // */
 
-	pAd->iw_stats.discard.nwid = 0;	// Rx : Wrong nwid/essid
-	pAd->iw_stats.miss.beacon = 0;	// Missed beacons/superframe
+	pAd->iw_stats.discard.nwid = 0;	/* Rx : Wrong nwid/essid */
+	pAd->iw_stats.miss.beacon = 0;	/* Missed beacons/superframe */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<--- rt28xx_get_wireless_stats\n"));
 	return &pAd->iw_stats;
@@ -620,7 +620,7 @@ struct iw_statistics *rt28xx_get_wireles
 
 void tbtt_tasklet(unsigned long data)
 {
-//#define MAX_TX_IN_TBTT                (16)
+/*#define MAX_TX_IN_TBTT                (16) */
 
 }
 
@@ -664,24 +664,24 @@ static struct net_device_stats *RT28xx_g
 		pAd->stats.rx_dropped = 0;
 		pAd->stats.tx_dropped = 0;
 
-		pAd->stats.multicast = pAd->WlanCounters.MulticastReceivedFrameCount.QuadPart;	// multicast packets received
-		pAd->stats.collisions = pAd->Counters8023.OneCollision + pAd->Counters8023.MoreCollisions;	// Collision packets
+		pAd->stats.multicast = pAd->WlanCounters.MulticastReceivedFrameCount.QuadPart;	/* multicast packets received */
+		pAd->stats.collisions = pAd->Counters8023.OneCollision + pAd->Counters8023.MoreCollisions;	/* Collision packets */
 
 		pAd->stats.rx_length_errors = 0;
-		pAd->stats.rx_over_errors = pAd->Counters8023.RxNoBuffer;	// receiver ring buff overflow
-		pAd->stats.rx_crc_errors = 0;	//pAd->WlanCounters.FCSErrorCount;     // recved pkt with crc error
-		pAd->stats.rx_frame_errors = pAd->Counters8023.RcvAlignmentErrors;	// recv'd frame alignment error
-		pAd->stats.rx_fifo_errors = pAd->Counters8023.RxNoBuffer;	// recv'r fifo overrun
-		pAd->stats.rx_missed_errors = 0;	// receiver missed packet
+		pAd->stats.rx_over_errors = pAd->Counters8023.RxNoBuffer;	/* receiver ring buff overflow */
+		pAd->stats.rx_crc_errors = 0;	/*pAd->WlanCounters.FCSErrorCount;     // recved pkt with crc error */
+		pAd->stats.rx_frame_errors = pAd->Counters8023.RcvAlignmentErrors;	/* recv'd frame alignment error */
+		pAd->stats.rx_fifo_errors = pAd->Counters8023.RxNoBuffer;	/* recv'r fifo overrun */
+		pAd->stats.rx_missed_errors = 0;	/* receiver missed packet */
 
-		// detailed tx_errors
+		/* detailed tx_errors */
 		pAd->stats.tx_aborted_errors = 0;
 		pAd->stats.tx_carrier_errors = 0;
 		pAd->stats.tx_fifo_errors = 0;
 		pAd->stats.tx_heartbeat_errors = 0;
 		pAd->stats.tx_window_errors = 0;
 
-		// for cslip etc
+		/* for cslip etc */
 		pAd->stats.rx_compressed = 0;
 		pAd->stats.tx_compressed = 0;
 
@@ -693,7 +693,7 @@ static struct net_device_stats *RT28xx_g
 BOOLEAN RtmpPhyNetDevExit(IN RTMP_ADAPTER * pAd, IN PNET_DEV net_dev)
 {
 
-	// Unregister network device
+	/* Unregister network device */
 	if (net_dev != NULL) {
 		printk
 		    ("RtmpOSNetDevDetach(): RtmpOSNetDeviceDetach(), dev->name=%s!\n",
@@ -724,7 +724,7 @@ Note:
 NDIS_STATUS AdapterBlockAllocateMemory(IN PVOID handle, OUT PVOID * ppAd)
 {
 
-	*ppAd = (PVOID) vmalloc(sizeof(RTMP_ADAPTER));	//pci_alloc_consistent(pci_dev, sizeof(RTMP_ADAPTER), phy_addr);
+	*ppAd = (PVOID) vmalloc(sizeof(RTMP_ADAPTER));	/*pci_alloc_consistent(pci_dev, sizeof(RTMP_ADAPTER), phy_addr); */
 
 	if (*ppAd) {
 		NdisZeroMemory(*ppAd, sizeof(RTMP_ADAPTER));
--- a/drivers/staging/rt2860/rt_pci_rbus.c
+++ b/drivers/staging/rt2860/rt_pci_rbus.c
@@ -51,23 +51,23 @@ static void fifo_statistic_full_tasklet(
 /*---------------------------------------------------------------------*/
 /* Symbol & Macro Definitions                                          */
 /*---------------------------------------------------------------------*/
-#define RT2860_INT_RX_DLY				(1<<0)	// bit 0
-#define RT2860_INT_TX_DLY				(1<<1)	// bit 1
-#define RT2860_INT_RX_DONE				(1<<2)	// bit 2
-#define RT2860_INT_AC0_DMA_DONE			(1<<3)	// bit 3
-#define RT2860_INT_AC1_DMA_DONE			(1<<4)	// bit 4
-#define RT2860_INT_AC2_DMA_DONE			(1<<5)	// bit 5
-#define RT2860_INT_AC3_DMA_DONE			(1<<6)	// bit 6
-#define RT2860_INT_HCCA_DMA_DONE		(1<<7)	// bit 7
-#define RT2860_INT_MGMT_DONE			(1<<8)	// bit 8
+#define RT2860_INT_RX_DLY				(1<<0)	/* bit 0 */
+#define RT2860_INT_TX_DLY				(1<<1)	/* bit 1 */
+#define RT2860_INT_RX_DONE				(1<<2)	/* bit 2 */
+#define RT2860_INT_AC0_DMA_DONE			(1<<3)	/* bit 3 */
+#define RT2860_INT_AC1_DMA_DONE			(1<<4)	/* bit 4 */
+#define RT2860_INT_AC2_DMA_DONE			(1<<5)	/* bit 5 */
+#define RT2860_INT_AC3_DMA_DONE			(1<<6)	/* bit 6 */
+#define RT2860_INT_HCCA_DMA_DONE		(1<<7)	/* bit 7 */
+#define RT2860_INT_MGMT_DONE			(1<<8)	/* bit 8 */
 
 #define INT_RX			RT2860_INT_RX_DONE
 
-#define INT_AC0_DLY		(RT2860_INT_AC0_DMA_DONE)	//| RT2860_INT_TX_DLY)
-#define INT_AC1_DLY		(RT2860_INT_AC1_DMA_DONE)	//| RT2860_INT_TX_DLY)
-#define INT_AC2_DLY		(RT2860_INT_AC2_DMA_DONE)	//| RT2860_INT_TX_DLY)
-#define INT_AC3_DLY		(RT2860_INT_AC3_DMA_DONE)	//| RT2860_INT_TX_DLY)
-#define INT_HCCA_DLY	(RT2860_INT_HCCA_DMA_DONE)	//| RT2860_INT_TX_DLY)
+#define INT_AC0_DLY		(RT2860_INT_AC0_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
+#define INT_AC1_DLY		(RT2860_INT_AC1_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
+#define INT_AC2_DLY		(RT2860_INT_AC2_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
+#define INT_AC3_DLY		(RT2860_INT_AC3_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
+#define INT_HCCA_DLY	(RT2860_INT_HCCA_DMA_DONE)	/*| RT2860_INT_TX_DLY) */
 #define INT_MGMT_DLY	RT2860_INT_MGMT_DONE
 
 /***************************************************************************
@@ -76,7 +76,7 @@ static void fifo_statistic_full_tasklet(
   *		Mainly for Hardware TxDesc/RxDesc/MgmtDesc, DMA Memory for TxData/RxData, etc.,
   *
   **************************************************************************/
-// Function for TxDesc Memory allocation.
+/* Function for TxDesc Memory allocation. */
 void RTMP_AllocateTxDescMemory(IN PRTMP_ADAPTER pAd,
 			       IN UINT Index,
 			       IN ULONG Length,
@@ -92,7 +92,7 @@ void RTMP_AllocateTxDescMemory(IN PRTMP_
 
 }
 
-// Function for MgmtDesc Memory allocation.
+/* Function for MgmtDesc Memory allocation. */
 void RTMP_AllocateMgmtDescMemory(IN PRTMP_ADAPTER pAd,
 				 IN ULONG Length,
 				 IN BOOLEAN Cached,
@@ -107,7 +107,7 @@ void RTMP_AllocateMgmtDescMemory(IN PRTM
 
 }
 
-// Function for RxDesc Memory allocation.
+/* Function for RxDesc Memory allocation. */
 void RTMP_AllocateRxDescMemory(IN PRTMP_ADAPTER pAd,
 			       IN ULONG Length,
 			       IN BOOLEAN Cached,
@@ -122,7 +122,7 @@ void RTMP_AllocateRxDescMemory(IN PRTMP_
 
 }
 
-// Function for free allocated Desc Memory.
+/* Function for free allocated Desc Memory. */
 void RTMP_FreeDescMemory(IN PRTMP_ADAPTER pAd,
 			 IN ULONG Length,
 			 IN PVOID VirtualAddress,
@@ -134,7 +134,7 @@ void RTMP_FreeDescMemory(IN PRTMP_ADAPTE
 			    PhysicalAddress);
 }
 
-// Function for TxData DMA Memory allocation.
+/* Function for TxData DMA Memory allocation. */
 void RTMP_AllocateFirstTxBuffer(IN PRTMP_ADAPTER pAd,
 				IN UINT Index,
 				IN ULONG Length,
@@ -305,12 +305,12 @@ static inline void rt2860_int_enable(PRT
 
 	pAd->int_disable_mask &= ~(mode);
 	regValue = pAd->int_enable_reg & ~(pAd->int_disable_mask);
-	//if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+	/*if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) */
 	{
-		RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);	// 1:enable
+		RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);	/* 1:enable */
 	}
-	//else
-	//      DBGPRINT(RT_DEBUG_TRACE, ("fOP_STATUS_DOZE !\n"));
+	/*else */
+	/*      DBGPRINT(RT_DEBUG_TRACE, ("fOP_STATUS_DOZE !\n")); */
 
 	if (regValue != 0)
 		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE);
@@ -322,7 +322,7 @@ static inline void rt2860_int_disable(PR
 
 	pAd->int_disable_mask |= mode;
 	regValue = pAd->int_enable_reg & ~(pAd->int_disable_mask);
-	RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);	// 0: disable
+	RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);	/* 0: disable */
 
 	if (regValue == 0) {
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE);
@@ -341,23 +341,23 @@ static void mgmt_dma_done_tasklet(unsign
 	INT_SOURCE_CSR_STRUC IntSource;
 	POS_COOKIE pObj;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-//      printk("mgmt_dma_done_process\n");
+/*      printk("mgmt_dma_done_process\n"); */
 	IntSource.word = 0;
 	IntSource.field.MgmtDmaDone = 1;
 	pAd->int_pending &= ~INT_MGMT_DLY;
 
 	RTMPHandleMgmtRingDmaDoneInterrupt(pAd);
 
-	// if you use RTMP_SEM_LOCK, sometimes kernel will hang up, no any
-	// bug report output
+	/* if you use RTMP_SEM_LOCK, sometimes kernel will hang up, no any */
+	/* bug report output */
 	RTMP_INT_LOCK(&pAd->irq_lock, flags);
 	/*
 	 * double check to avoid lose of interrupts
@@ -380,8 +380,8 @@ static void rx_done_tasklet(unsigned lon
 	BOOLEAN bReschedule = 0;
 	POS_COOKIE pObj;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
@@ -413,8 +413,8 @@ void fifo_statistic_full_tasklet(unsigne
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) data;
 	POS_COOKIE pObj;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
@@ -449,15 +449,15 @@ static void ac3_dma_done_tasklet(unsigne
 	POS_COOKIE pObj;
 	BOOLEAN bReschedule = 0;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-//      printk("ac0_dma_done_process\n");
+/*      printk("ac0_dma_done_process\n"); */
 	IntSource.word = 0;
 	IntSource.field.Ac3DmaDone = 1;
 	pAd->int_pending &= ~INT_AC3_DLY;
@@ -487,8 +487,8 @@ static void ac2_dma_done_tasklet(unsigne
 	POS_COOKIE pObj;
 	BOOLEAN bReschedule = 0;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
@@ -525,15 +525,15 @@ static void ac1_dma_done_tasklet(unsigne
 	POS_COOKIE pObj;
 	BOOLEAN bReschedule = 0;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-//      printk("ac0_dma_done_process\n");
+/*      printk("ac0_dma_done_process\n"); */
 	IntSource.word = 0;
 	IntSource.field.Ac1DmaDone = 1;
 	pAd->int_pending &= ~INT_AC1_DLY;
@@ -563,20 +563,20 @@ static void ac0_dma_done_tasklet(unsigne
 	POS_COOKIE pObj;
 	BOOLEAN bReschedule = 0;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-//      printk("ac0_dma_done_process\n");
+/*      printk("ac0_dma_done_process\n"); */
 	IntSource.word = 0;
 	IntSource.field.Ac0DmaDone = 1;
 	pAd->int_pending &= ~INT_AC0_DLY;
 
-//      RTMPHandleMgmtRingDmaDoneInterrupt(pAd);
+/*      RTMPHandleMgmtRingDmaDoneInterrupt(pAd); */
 	bReschedule = RTMPHandleTxRingDmaDoneInterrupt(pAd, IntSource);
 
 	RTMP_INT_LOCK(&pAd->irq_lock, flags);
@@ -617,52 +617,52 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 	   RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word);
 	   Or kernel will panic after ifconfig ra0 down sometimes */
 
-	//
-	// Inital the Interrupt source.
-	//
+	/* */
+	/* Inital the Interrupt source. */
+	/* */
 	IntSource.word = 0x00000000L;
-//      McuIntSource.word = 0x00000000L;
+/*      McuIntSource.word = 0x00000000L; */
 
-	//
-	// Get the interrupt sources & saved to local variable
-	//
-	//RTMP_IO_READ32(pAd, where, &McuIntSource.word);
-	//RTMP_IO_WRITE32(pAd, , McuIntSource.word);
-
-	//
-	// Flag fOP_STATUS_DOZE On, means ASIC put to sleep, elase means ASICK WakeUp
-	// And at the same time, clock maybe turned off that say there is no DMA service.
-	// when ASIC get to sleep.
-	// To prevent system hang on power saving.
-	// We need to check it before handle the INT_SOURCE_CSR, ASIC must be wake up.
-	//
-	// RT2661 => when ASIC is sleeping, MAC register cannot be read and written.
-	// RT2860 => when ASIC is sleeping, MAC register can be read and written.
-//      if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+	/* */
+	/* Get the interrupt sources & saved to local variable */
+	/* */
+	/*RTMP_IO_READ32(pAd, where, &McuIntSource.word); */
+	/*RTMP_IO_WRITE32(pAd, , McuIntSource.word); */
+
+	/* */
+	/* Flag fOP_STATUS_DOZE On, means ASIC put to sleep, elase means ASICK WakeUp */
+	/* And at the same time, clock maybe turned off that say there is no DMA service. */
+	/* when ASIC get to sleep. */
+	/* To prevent system hang on power saving. */
+	/* We need to check it before handle the INT_SOURCE_CSR, ASIC must be wake up. */
+	/* */
+	/* RT2661 => when ASIC is sleeping, MAC register cannot be read and written. */
+	/* RT2860 => when ASIC is sleeping, MAC register can be read and written. */
+/*      if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) */
 	{
 		RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IntSource.word);
-		RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word);	// write 1 to clear
+		RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word);	/* write 1 to clear */
 	}
-//      else
-//              DBGPRINT(RT_DEBUG_TRACE, (">>>fOP_STATUS_DOZE<<<\n"));
+/*      else */
+/*              DBGPRINT(RT_DEBUG_TRACE, (">>>fOP_STATUS_DOZE<<<\n")); */
 
-//      RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IsrAfterClear);
-//      RTMP_IO_READ32(pAd, MCU_INT_SOURCE_CSR, &McuIsrAfterClear);
-//      DBGPRINT(RT_DEBUG_INFO, ("====> RTMPHandleInterrupt(ISR=%08x,Mcu ISR=%08x, After clear ISR=%08x, MCU ISR=%08x)\n",
-//                      IntSource.word, McuIntSource.word, IsrAfterClear, McuIsrAfterClear));
+/*      RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IsrAfterClear); */
+/*      RTMP_IO_READ32(pAd, MCU_INT_SOURCE_CSR, &McuIsrAfterClear); */
+/*      DBGPRINT(RT_DEBUG_INFO, ("====> RTMPHandleInterrupt(ISR=%08x,Mcu ISR=%08x, After clear ISR=%08x, MCU ISR=%08x)\n", */
+/*                      IntSource.word, McuIntSource.word, IsrAfterClear, McuIsrAfterClear)); */
 
-	// Do nothing if Reset in progress
+	/* Do nothing if Reset in progress */
 	if (RTMP_TEST_FLAG
 	    (pAd,
 	     (fRTMP_ADAPTER_RESET_IN_PROGRESS |
 	      fRTMP_ADAPTER_HALT_IN_PROGRESS))) {
 		return IRQ_HANDLED;
 	}
-	//
-	// Handle interrupt, walk through all bits
-	// Should start from highest priority interrupt
-	// The priority can be adjust by altering processing if statement
-	//
+	/* */
+	/* Handle interrupt, walk through all bits */
+	/* Should start from highest priority interrupt */
+	/* The priority can be adjust by altering processing if statement */
+	/* */
 
 #ifdef DBG
 
@@ -670,11 +670,11 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 
 	pAd->bPCIclkOff = FALSE;
 
-	// If required spinlock, each interrupt service routine has to acquire
-	// and release itself.
-	//
+	/* If required spinlock, each interrupt service routine has to acquire */
+	/* and release itself. */
+	/* */
 
-	// Do nothing if NIC doesn't exist
+	/* Do nothing if NIC doesn't exist */
 	if (IntSource.word == 0xffffffff) {
 		RTMP_SET_FLAG(pAd,
 			      (fRTMP_ADAPTER_NIC_NOT_EXIST |
--- a/drivers/staging/rt2860/rt_usb.c
+++ b/drivers/staging/rt2860/rt_usb.c
@@ -138,15 +138,15 @@ VOID RtmpMgmtTaskExit(IN RTMP_ADAPTER * 
 	INT ret;
 	RTMP_OS_TASK *pTask;
 
-	// Sleep 50 milliseconds so pending io might finish normally
+	/* Sleep 50 milliseconds so pending io might finish normally */
 	RTMPusecDelay(50000);
 
-	// We want to wait until all pending receives and sends to the
-	// device object. We cancel any
-	// irps. Wait until sends and receives have stopped.
+	/* We want to wait until all pending receives and sends to the */
+	/* device object. We cancel any */
+	/* irps. Wait until sends and receives have stopped. */
 	RTUSBCancelPendingIRPs(pAd);
 
-	// We need clear timerQ related structure before exits of the timer thread.
+	/* We need clear timerQ related structure before exits of the timer thread. */
 	RtmpTimerQExit(pAd);
 
 	/* Terminate Mlme Thread */
@@ -172,7 +172,7 @@ VOID RtmpMgmtTaskExit(IN RTMP_ADAPTER * 
 		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_STOPED;
 		NdisReleaseSpinLock(&pAd->CmdQLock);
 		mb();
-		//RTUSBCMDUp(pAd);
+		/*RTUSBCMDUp(pAd); */
 		ret = RtmpOSTaskKill(pTask);
 		if (ret == NDIS_STATUS_FAILURE) {
 			DBGPRINT(RT_DEBUG_ERROR, ("%s: kill task(%s) failed!\n",
@@ -211,12 +211,12 @@ static void rtusb_dataout_complete(unsig
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 	Status = pUrb->status;
 
-	// Store BulkOut PipeId
+	/* Store BulkOut PipeId */
 	BulkOutPipeId = pHTTXContext->BulkOutPipeId;
 	pAd->BulkOutDataOneSecCount++;
 
-	//DBGPRINT(RT_DEBUG_LOUD, ("Done-B(%d):I=0x%lx, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", BulkOutPipeId, in_interrupt(), pHTTXContext->CurWritePosition,
-	//              pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
+	/*DBGPRINT(RT_DEBUG_LOUD, ("Done-B(%d):I=0x%lx, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", BulkOutPipeId, in_interrupt(), pHTTXContext->CurWritePosition, */
+	/*              pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad)); */
 
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 	pAd->BulkOutPending[BulkOutPipeId] = FALSE;
@@ -229,11 +229,11 @@ static void rtusb_dataout_complete(unsig
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 
 		pAd->Counters8023.GoodTransmits++;
-		//RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+		/*RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
 		FREE_HTTX_RING(pAd, BulkOutPipeId, pHTTXContext);
-		//RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+		/*RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
 
-	} else			// STATUS_OTHER
+	} else			/* STATUS_OTHER */
 	{
 		PUCHAR pBuf;
 
@@ -264,15 +264,15 @@ static void rtusb_dataout_complete(unsig
 			     ("\t>>BulkOut Header:%x %x %x %x %x %x %x %x\n",
 			      pBuf[0], pBuf[1], pBuf[2], pBuf[3], pBuf[4],
 			      pBuf[5], pBuf[6], pBuf[7]));
-		//DBGPRINT_RAW(RT_DEBUG_ERROR, (">>BulkOutCompleteCancel=0x%x, BulkOutCompleteOther=0x%x\n", pAd->BulkOutCompleteCancel, pAd->BulkOutCompleteOther));
+		/*DBGPRINT_RAW(RT_DEBUG_ERROR, (">>BulkOutCompleteCancel=0x%x, BulkOutCompleteOther=0x%x\n", pAd->BulkOutCompleteCancel, pAd->BulkOutCompleteOther)); */
 
 	}
 
-	//
-	// bInUse = TRUE, means some process are filling TX data, after that must turn on bWaitingBulkOut
-	// bWaitingBulkOut = TRUE, means the TX data are waiting for bulk out.
-	//
-	//RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+	/* */
+	/* bInUse = TRUE, means some process are filling TX data, after that must turn on bWaitingBulkOut */
+	/* bWaitingBulkOut = TRUE, means the TX data are waiting for bulk out. */
+	/* */
+	/*RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
 	if ((pHTTXContext->ENextBulkOutPosition !=
 	     pHTTXContext->CurWritePosition)
 	    && (pHTTXContext->ENextBulkOutPosition !=
@@ -280,15 +280,15 @@ static void rtusb_dataout_complete(unsig
 	    && !RTUSB_TEST_BULK_FLAG(pAd,
 				     (fRTUSB_BULK_OUT_DATA_FRAG <<
 				      BulkOutPipeId))) {
-		// Indicate There is data avaliable
+		/* Indicate There is data avaliable */
 		RTUSB_SET_BULK_FLAG(pAd,
 				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
 				     BulkOutPipeId));
 	}
-	//RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+	/*RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
 
-	// Always call Bulk routine, even reset bulk.
-	// The protection of rest bulk should be in BulkOut routine
+	/* Always call Bulk routine, even reset bulk. */
+	/* The protection of rest bulk should be in BulkOut routine */
 	RTUSBKickBulkOut(pAd);
 }
 
@@ -305,7 +305,7 @@ static void rtusb_null_frame_done_taskle
 	pAd = pNullContext->pAd;
 	Status = pUrb->status;
 
-	// Reset Null frame context flags
+	/* Reset Null frame context flags */
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], irqFlag);
 	pNullContext->IRPPending = FALSE;
 	pNullContext->InUse = FALSE;
@@ -316,7 +316,7 @@ static void rtusb_null_frame_done_taskle
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
 
 		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	} else			// STATUS_OTHER
+	} else			/* STATUS_OTHER */
 	{
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
 		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
@@ -336,8 +336,8 @@ static void rtusb_null_frame_done_taskle
 		}
 	}
 
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
+	/* Always call Bulk routine, even reset bulk. */
+	/* The protectioon of rest bulk should be in BulkOut routine */
 	RTUSBKickBulkOut(pAd);
 }
 
@@ -354,7 +354,7 @@ static void rtusb_rts_frame_done_tasklet
 	pAd = pRTSContext->pAd;
 	Status = pUrb->status;
 
-	// Reset RTS frame context flags
+	/* Reset RTS frame context flags */
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], irqFlag);
 	pRTSContext->IRPPending = FALSE;
 	pRTSContext->InUse = FALSE;
@@ -362,7 +362,7 @@ static void rtusb_rts_frame_done_tasklet
 	if (Status == USB_ST_NOERROR) {
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
 		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	} else			// STATUS_OTHER
+	} else			/* STATUS_OTHER */
 	{
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
 		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
@@ -385,8 +385,8 @@ static void rtusb_rts_frame_done_tasklet
 	pAd->BulkOutPending[pRTSContext->BulkOutPipeId] = FALSE;
 	RTMP_SEM_UNLOCK(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId]);
 
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
+	/* Always call Bulk routine, even reset bulk. */
+	/* The protectioon of rest bulk should be in BulkOut routine */
 	RTUSBKickBulkOut(pAd);
 
 }
@@ -403,14 +403,14 @@ static void rtusb_pspoll_frame_done_task
 	pAd = pPsPollContext->pAd;
 	Status = pUrb->status;
 
-	// Reset PsPoll context flags
+	/* Reset PsPoll context flags */
 	pPsPollContext->IRPPending = FALSE;
 	pPsPollContext->InUse = FALSE;
 	pAd->watchDogTxPendingCnt[0] = 0;
 
 	if (Status == USB_ST_NOERROR) {
 		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	} else			// STATUS_OTHER
+	} else			/* STATUS_OTHER */
 	{
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
 		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
@@ -430,8 +430,8 @@ static void rtusb_pspoll_frame_done_task
 	pAd->BulkOutPending[0] = FALSE;
 	RTMP_SEM_UNLOCK(&pAd->BulkOutLock[0]);
 
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
+	/* Always call Bulk routine, even reset bulk. */
+	/* The protectioon of rest bulk should be in BulkOut routine */
 	RTUSBKickBulkOut(pAd);
 
 }
@@ -467,26 +467,26 @@ static void rx_done_tasklet(unsigned lon
 	pRxContext->InUse = FALSE;
 	pRxContext->IRPPending = FALSE;
 	pRxContext->BulkInOffset += pUrb->actual_length;
-	//NdisInterlockedDecrement(&pAd->PendingRx);
+	/*NdisInterlockedDecrement(&pAd->PendingRx); */
 	pAd->PendingRx--;
 
 	if (Status == USB_ST_NOERROR) {
 		pAd->BulkInComplete++;
 		pAd->NextRxBulkInPosition = 0;
-		if (pRxContext->BulkInOffset)	// As jan's comment, it may bulk-in success but size is zero.
+		if (pRxContext->BulkInOffset)	/* As jan's comment, it may bulk-in success but size is zero. */
 		{
 			pRxContext->Readable = TRUE;
 			INC_RING_INDEX(pAd->NextRxBulkInIndex, RX_RING_SIZE);
 		}
 		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-	} else			// STATUS_OTHER
+	} else			/* STATUS_OTHER */
 	{
 		pAd->BulkInCompleteFail++;
-		// Still read this packet although it may comtain wrong bytes.
+		/* Still read this packet although it may comtain wrong bytes. */
 		pRxContext->Readable = FALSE;
 		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 
-		// Parsing all packets. because after reset, the index will reset to all zero.
+		/* Parsing all packets. because after reset, the index will reset to all zero. */
 		if ((!RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
 					   fRTMP_ADAPTER_BULKIN_RESET |
 					   fRTMP_ADAPTER_HALT_IN_PROGRESS |
@@ -533,7 +533,7 @@ static void rtusb_mgmt_dma_done_tasklet(
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
 
 	if (Status != USB_ST_NOERROR) {
-		//Bulk-Out fail status handle
+		/*Bulk-Out fail status handle */
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
 		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
 		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
@@ -541,7 +541,7 @@ static void rtusb_mgmt_dma_done_tasklet(
 			DBGPRINT_RAW(RT_DEBUG_ERROR,
 				     ("Bulk Out MLME Failed, Status=%d!\n",
 				      Status));
-			// TODO: How to handle about the MLMEBulkOut failed issue. Need to resend the mgmt pkt?
+			/* TODO: How to handle about the MLMEBulkOut failed issue. Need to resend the mgmt pkt? */
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
 			pAd->bulkResetPipeid =
 			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
@@ -552,7 +552,7 @@ static void rtusb_mgmt_dma_done_tasklet(
 	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
 
 	RTMP_IRQ_LOCK(&pAd->MLMEBulkOutLock, IrqFlags);
-	// Reset MLME context flags
+	/* Reset MLME context flags */
 	pMLMEContext->IRPPending = FALSE;
 	pMLMEContext->InUse = FALSE;
 	pMLMEContext->bWaitingBulkOut = FALSE;
@@ -561,27 +561,27 @@ static void rtusb_mgmt_dma_done_tasklet(
 	pPacket = pAd->MgmtRing.Cell[index].pNdisPacket;
 	pAd->MgmtRing.Cell[index].pNdisPacket = NULL;
 
-	// Increase MgmtRing Index
+	/* Increase MgmtRing Index */
 	INC_RING_INDEX(pAd->MgmtRing.TxDmaIdx, MGMT_RING_SIZE);
 	pAd->MgmtRing.TxSwFreeIdx++;
 	RTMP_IRQ_UNLOCK(&pAd->MLMEBulkOutLock, IrqFlags);
 
-	// No-matter success or fail, we free the mgmt packet.
+	/* No-matter success or fail, we free the mgmt packet. */
 	if (pPacket)
 		RTMPFreeNdisPacket(pAd, pPacket);
 
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
 				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
 				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		// do nothing and return directly.
+		/* do nothing and return directly. */
 	} else {
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET) && ((pAd->bulkResetPipeid & BULKOUT_MGMT_RESET_FLAG) == BULKOUT_MGMT_RESET_FLAG)) {	// For Mgmt Bulk-Out failed, ignore it now.
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET) && ((pAd->bulkResetPipeid & BULKOUT_MGMT_RESET_FLAG) == BULKOUT_MGMT_RESET_FLAG)) {	/* For Mgmt Bulk-Out failed, ignore it now. */
 			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
 						NULL, 0);
 		} else {
 
-			// Always call Bulk routine, even reset bulk.
-			// The protectioon of rest bulk should be in BulkOut routine
+			/* Always call Bulk routine, even reset bulk. */
+			/* The protectioon of rest bulk should be in BulkOut routine */
 			if (pAd->MgmtRing.TxSwFreeIdx <
 			    MGMT_RING_SIZE
 			    /* pMLMEContext->bWaitingBulkOut == TRUE */ ) {
@@ -609,7 +609,7 @@ static void rtusb_ac3_dma_done_tasklet(u
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
 				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
 				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		// do nothing and return directly.
+		/* do nothing and return directly. */
 	} else {
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
 			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
@@ -649,7 +649,7 @@ static void rtusb_ac2_dma_done_tasklet(u
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
 				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
 				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		// do nothing and return directly.
+		/* do nothing and return directly. */
 	} else {
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
 			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
@@ -689,7 +689,7 @@ static void rtusb_ac1_dma_done_tasklet(u
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
 				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
 				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		// do nothing and return directly.
+		/* do nothing and return directly. */
 	} else {
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
 			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
@@ -729,7 +729,7 @@ static void rtusb_ac0_dma_done_tasklet(u
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
 				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
 				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
-		// do nothing and return directly.
+		/* do nothing and return directly. */
 	} else {
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
 			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
@@ -757,7 +757,7 @@ NDIS_STATUS RtmpNetTaskInit(IN RTMP_ADAP
 {
 	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-	// Create receive tasklet
+	/* Create receive tasklet */
 	tasklet_init(&pObj->rx_done_task, rx_done_tasklet, (ULONG) pAd);
 	tasklet_init(&pObj->mgmt_dma_done_task, rtusb_mgmt_dma_done_tasklet,
 		     (unsigned long)pAd);
--- a/drivers/staging/rt2860/sta_ioctl.c
+++ b/drivers/staging/rt2860/sta_ioctl.c
@@ -61,15 +61,15 @@ typedef struct PACKED _RT_VERSION_INFO {
 	UINT DriverBuildDay;
 } RT_VERSION_INFO, *PRT_VERSION_INFO;
 
-static __s32 ralinkrate[] = { 2, 4, 11, 22,	// CCK
-	12, 18, 24, 36, 48, 72, 96, 108,	// OFDM
-	13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260,	// 20MHz, 800ns GI, MCS: 0 ~ 15
-	39, 78, 117, 156, 234, 312, 351, 390,	// 20MHz, 800ns GI, MCS: 16 ~ 23
-	27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,	// 40MHz, 800ns GI, MCS: 0 ~ 15
-	81, 162, 243, 324, 486, 648, 729, 810,	// 40MHz, 800ns GI, MCS: 16 ~ 23
-	14, 29, 43, 57, 87, 115, 130, 144, 29, 59, 87, 115, 173, 230, 260, 288,	// 20MHz, 400ns GI, MCS: 0 ~ 15
-	43, 87, 130, 173, 260, 317, 390, 433,	// 20MHz, 400ns GI, MCS: 16 ~ 23
-	30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,	// 40MHz, 400ns GI, MCS: 0 ~ 15
+static __s32 ralinkrate[] = { 2, 4, 11, 22,	/* CCK */
+	12, 18, 24, 36, 48, 72, 96, 108,	/* OFDM */
+	13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260,	/* 20MHz, 800ns GI, MCS: 0 ~ 15 */
+	39, 78, 117, 156, 234, 312, 351, 390,	/* 20MHz, 800ns GI, MCS: 16 ~ 23 */
+	27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,	/* 40MHz, 800ns GI, MCS: 0 ~ 15 */
+	81, 162, 243, 324, 486, 648, 729, 810,	/* 40MHz, 800ns GI, MCS: 16 ~ 23 */
+	14, 29, 43, 57, 87, 115, 130, 144, 29, 59, 87, 115, 173, 230, 260, 288,	/* 20MHz, 400ns GI, MCS: 0 ~ 15 */
+	43, 87, 130, 173, 260, 317, 390, 433,	/* 20MHz, 400ns GI, MCS: 16 ~ 23 */
+	30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,	/* 40MHz, 400ns GI, MCS: 0 ~ 15 */
 	90, 180, 270, 360, 540, 720, 810, 900
 };
 
@@ -93,7 +93,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 					       pKey->KeyLength);
 				goto end;
 			}
-			// Update PTK
+			/* Update PTK */
 			NdisZeroMemory(&pAd->SharedKey[BSS0][0],
 				       sizeof(CIPHER_KEY));
 			pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
@@ -119,7 +119,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 					       LEN_TKIP_RXMICK);
 			}
 
-			// Decide its ChiperAlg
+			/* Decide its ChiperAlg */
 			if (pAd->StaCfg.PairCipher ==
 			    Ndis802_11Encryption2Enabled)
 				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
@@ -129,7 +129,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 			else
 				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_NONE;
 
-			// Update these related information to MAC_TABLE_ENTRY
+			/* Update these related information to MAC_TABLE_ENTRY */
 			pEntry = &pAd->MacTab.Content[BSSID_WCID];
 			NdisMoveMemory(pEntry->PairwiseKey.Key,
 				       pAd->SharedKey[BSS0][0].Key,
@@ -143,7 +143,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 			pEntry->PairwiseKey.CipherAlg =
 			    pAd->SharedKey[BSS0][0].CipherAlg;
 
-			// Update pairwise key information to ASIC Shared Key Table
+			/* Update pairwise key information to ASIC Shared Key Table */
 			AsicAddSharedKeyEntry(pAd,
 					      BSS0,
 					      0,
@@ -152,7 +152,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 					      pAd->SharedKey[BSS0][0].TxMic,
 					      pAd->SharedKey[BSS0][0].RxMic);
 
-			// Update ASIC WCID attribute table and IVEIV table
+			/* Update ASIC WCID attribute table and IVEIV table */
 			RTMPAddWcidAttributeEntry(pAd,
 						  BSS0,
 						  0,
@@ -160,16 +160,16 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 						  CipherAlg, pEntry);
 
 			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2) {
-				// set 802.1x port control
-				//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+				/* set 802.1x port control */
+				/*pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 				STA_PORT_SECURED(pAd);
 
-				// Indicate Connected for GUI
+				/* Indicate Connected for GUI */
 				pAd->IndicateMediaState =
 				    NdisMediaStateConnected;
 			}
 		} else {
-			// Update GTK
+			/* Update GTK */
 			pAd->StaCfg.DefaultKeyId = (pKey->KeyIndex & 0xFF);
 			NdisZeroMemory(&pAd->
 				       SharedKey[BSS0][pAd->StaCfg.
@@ -213,7 +213,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 					       LEN_TKIP_RXMICK);
 			}
 
-			// Update Shared Key CipherAlg
+			/* Update Shared Key CipherAlg */
 			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].
 			    CipherAlg = CIPHER_NONE;
 			if (pAd->StaCfg.GroupCipher ==
@@ -225,7 +225,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 				pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].
 				    CipherAlg = CIPHER_AES;
 
-			// Update group key information to ASIC Shared Key Table
+			/* Update group key information to ASIC Shared Key Table */
 			AsicAddSharedKeyEntry(pAd,
 					      BSS0,
 					      pAd->StaCfg.DefaultKeyId,
@@ -242,7 +242,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 								   DefaultKeyId].
 					      RxMic);
 
-			// Update ASIC WCID attribute table and IVEIV table
+			/* Update ASIC WCID attribute table and IVEIV table */
 			RTMPAddWcidAttributeEntry(pAd,
 						  BSS0,
 						  pAd->StaCfg.DefaultKeyId,
@@ -251,14 +251,14 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 								       DefaultKeyId].
 						  CipherAlg, NULL);
 
-			// set 802.1x port control
-			//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+			/* set 802.1x port control */
+			/*pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 			STA_PORT_SECURED(pAd);
 
-			// Indicate Connected for GUI
+			/* Indicate Connected for GUI */
 			pAd->IndicateMediaState = NdisMediaStateConnected;
 		}
-	} else			// dynamic WEP from wpa_supplicant
+	} else			/* dynamic WEP from wpa_supplicant */
 	{
 		UCHAR CipherAlg;
 		PUCHAR Key;
@@ -269,7 +269,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 		KeyIdx = pKey->KeyIndex & 0x0fffffff;
 
 		if (KeyIdx < 4) {
-			// it is a default shared key, for Pairwise key setting
+			/* it is a default shared key, for Pairwise key setting */
 			if (pKey->KeyIndex & 0x80000000) {
 				pEntry = MacTableLookup(pAd, pKey->BSSID);
 
@@ -277,14 +277,14 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 					DBGPRINT(RT_DEBUG_TRACE,
 						 ("RTMPAddKey: Set Pair-wise Key\n"));
 
-					// set key material and key length
+					/* set key material and key length */
 					pEntry->PairwiseKey.KeyLen =
 					    (UCHAR) pKey->KeyLength;
 					NdisMoveMemory(pEntry->PairwiseKey.Key,
 						       &pKey->KeyMaterial,
 						       pKey->KeyLength);
 
-					// set Cipher type
+					/* set Cipher type */
 					if (pKey->KeyLength == 5)
 						pEntry->PairwiseKey.CipherAlg =
 						    CIPHER_WEP64;
@@ -292,7 +292,7 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 						pEntry->PairwiseKey.CipherAlg =
 						    CIPHER_WEP128;
 
-					// Add Pair-wise key to Asic
+					/* Add Pair-wise key to Asic */
 					AsicAddPairwiseKeyEntry(pAd,
 								pEntry->Addr,
 								(UCHAR) pEntry->
@@ -300,8 +300,8 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 								&pEntry->
 								PairwiseKey);
 
-					// update WCID attribute table and IVEIV table for this entry
-					RTMPAddWcidAttributeEntry(pAd, BSS0, KeyIdx,	// The value may be not zero
+					/* update WCID attribute table and IVEIV table for this entry */
+					RTMPAddWcidAttributeEntry(pAd, BSS0, KeyIdx,	/* The value may be not zero */
 								  pEntry->
 								  PairwiseKey.
 								  CipherAlg,
@@ -309,17 +309,17 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 
 				}
 			} else {
-				// Default key for tx (shared key)
+				/* Default key for tx (shared key) */
 				pAd->StaCfg.DefaultKeyId = (UCHAR) KeyIdx;
 
-				// set key material and key length
+				/* set key material and key length */
 				pAd->SharedKey[BSS0][KeyIdx].KeyLen =
 				    (UCHAR) pKey->KeyLength;
 				NdisMoveMemory(pAd->SharedKey[BSS0][KeyIdx].Key,
 					       &pKey->KeyMaterial,
 					       pKey->KeyLength);
 
-				// Set Ciper type
+				/* Set Ciper type */
 				if (pKey->KeyLength == 5)
 					pAd->SharedKey[BSS0][KeyIdx].CipherAlg =
 					    CIPHER_WEP64;
@@ -331,12 +331,12 @@ VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN
 				    pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
 				Key = pAd->SharedKey[BSS0][KeyIdx].Key;
 
-				// Set Group key material to Asic
+				/* Set Group key material to Asic */
 				AsicAddSharedKeyEntry(pAd, BSS0, KeyIdx,
 						      CipherAlg, Key, NULL,
 						      NULL);
 
-				// Update WCID attribute table and IVEIV table for this group key table
+				/* Update WCID attribute table and IVEIV table for this group key table */
 				RTMPAddWcidAttributeEntry(pAd, BSS0, KeyIdx,
 							  CipherAlg, NULL);
 
@@ -364,8 +364,8 @@ rt_ioctl_giwname(struct net_device *dev,
 		 struct iw_request_info *info, char *name, char *extra)
 {
 	strncpy(name, "Ralink STA", IFNAMSIZ);
-	// RT2870 2.1.0.0 uses "RT2870 Wireless"
-	// RT3090 2.1.0.0 uses "RT2860 Wireless"
+	/* RT2870 2.1.0.0 uses "RT2870 Wireless" */
+	/* RT3090 2.1.0.0 uses "RT2860 Wireless" */
 	return 0;
 }
 
@@ -378,7 +378,7 @@ int rt_ioctl_siwfreq(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -388,9 +388,9 @@ int rt_ioctl_siwfreq(struct net_device *
 		return -EINVAL;
 
 	if ((freq->e == 0) && (freq->m <= 1000))
-		chan = freq->m;	// Setting by channel number
+		chan = freq->m;	/* Setting by channel number */
 	else
-		MAP_KHZ_TO_CHANNEL_ID((freq->m / 100), chan);	// Setting by frequency - search the table , like 2.412G, 2.422G,
+		MAP_KHZ_TO_CHANNEL_ID((freq->m / 100), chan);	/* Setting by frequency - search the table , like 2.412G, 2.422G, */
 
 	if (ChannelSanity(pAdapter, chan) == TRUE) {
 		pAdapter->CommonCfg.Channel = chan;
@@ -430,7 +430,7 @@ int rt_ioctl_siwmode(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -453,7 +453,7 @@ int rt_ioctl_siwmode(struct net_device *
 		return -EINVAL;
 	}
 
-	// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+	/* Reset Ralink supplicant to not use, it will be set to start when UI set PMK key */
 	pAdapter->StaCfg.WpaState = SS_NOTUSE;
 
 	return 0;
@@ -486,7 +486,7 @@ int rt_ioctl_siwsens(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -591,7 +591,7 @@ int rt_ioctl_siwap(struct net_device *de
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -602,10 +602,10 @@ int rt_ioctl_siwap(struct net_device *de
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("!!! MLME busy, reset MLME state machine !!!\n"));
 	}
-	// tell CNTL state machine to call NdisMSetInformationComplete() after completing
-	// this request, because this request is initiated by NDIS.
+	/* tell CNTL state machine to call NdisMSetInformationComplete() after completing */
+	/* this request, because this request is initiated by NDIS. */
 	pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
-	// Prevent to connect AP again in STAMlmePeriodicExec
+	/* Prevent to connect AP again in STAMlmePeriodicExec */
 	pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
 
 	memset(Bssid, 0, MAC_ADDR_LEN);
@@ -634,7 +634,7 @@ int rt_ioctl_giwap(struct net_device *de
 		ap_addr->sa_family = ARPHRD_ETHER;
 		memcpy(ap_addr->sa_data, &pAdapter->CommonCfg.Bssid, ETH_ALEN);
 	}
-	// Add for RT2870
+	/* Add for RT2870 */
 	else if (pAdapter->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) {
 		ap_addr->sa_family = ARPHRD_ETHER;
 		memcpy(ap_addr->sa_data, &pAdapter->MlmeAux.Bssid, ETH_ALEN);
@@ -667,12 +667,12 @@ static void set_quality(PRTMP_ADAPTER pA
 {
 	__u8 ChannelQuality;
 
-	// Normalize Rssi
+	/* Normalize Rssi */
 	if (rssi >= -50)
 		ChannelQuality = 100;
-	else if (rssi >= -80)	// between -50 ~ -80dbm
+	else if (rssi >= -80)	/* between -50 ~ -80dbm */
 		ChannelQuality = (__u8) (24 + ((rssi + 80) * 26) / 10);
-	else if (rssi >= -90)	// between -80 ~ -90dbm
+	else if (rssi >= -90)	/* between -80 ~ -90dbm */
 		ChannelQuality = (__u8) ((rssi + 90) * 26) / 10;
 	else
 		ChannelQuality = 0;
@@ -680,7 +680,7 @@ static void set_quality(PRTMP_ADAPTER pA
 	iq->qual = (__u8) ChannelQuality;
 
 	iq->level = (__u8) (rssi);
-	iq->noise = (pAdapter->BbpWriteLatch[66] > pAdapter->BbpTuning.FalseCcaUpperThreshold) ? ((__u8) pAdapter->BbpTuning.FalseCcaUpperThreshold) : ((__u8) pAdapter->BbpWriteLatch[66]);	// noise level (dBm)
+	iq->noise = (pAdapter->BbpWriteLatch[66] > pAdapter->BbpTuning.FalseCcaUpperThreshold) ? ((__u8) pAdapter->BbpTuning.FalseCcaUpperThreshold) : ((__u8) pAdapter->BbpWriteLatch[66]);	/* noise level (dBm) */
 	iq->noise += 256 - 143;
 	iq->updated = pAdapter->iw_stats.qual.updated;
 }
@@ -697,12 +697,12 @@ int rt_ioctl_iwaplist(struct net_device 
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		data->length = 0;
 		return 0;
-		//return -ENETDOWN;
+		/*return -ENETDOWN; */
 	}
 
 	for (i = 0; i < IW_MAX_AP; i++) {
@@ -733,7 +733,7 @@ int rt_ioctl_siwscan(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -781,10 +781,10 @@ int rt_ioctl_siwscan(struct net_device *
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("!!! MLME busy, reset MLME state machine !!!\n"));
 		}
-		// tell CNTL state machine to call NdisMSetInformationComplete() after completing
-		// this request, because this request is initiated by NDIS.
+		/* tell CNTL state machine to call NdisMSetInformationComplete() after completing */
+		/* this request, because this request is initiated by NDIS. */
 		pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
-		// Reset allowed scan retries
+		/* Reset allowed scan retries */
 		pAdapter->StaCfg.ScanCnt = 0;
 		pAdapter->StaCfg.LastScanTime = Now;
 
@@ -837,8 +837,8 @@ int rt_ioctl_giwscan(struct net_device *
 		if (current_ev >= end_buf) {
 			return -E2BIG;
 		}
-		//MAC address
-		//================================
+		/*MAC address */
+		/*================================ */
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWAP;
 		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
@@ -935,8 +935,8 @@ int rt_ioctl_giwscan(struct net_device *
 		if (current_ev == previous_ev)
 			return -E2BIG;
 
-		//ESSID
-		//================================
+		/*ESSID */
+		/*================================ */
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWESSID;
 		iwe.u.data.length = pAdapter->ScanTab.BssEntry[i].SsidLen;
@@ -950,8 +950,8 @@ int rt_ioctl_giwscan(struct net_device *
 		if (current_ev == previous_ev)
 			return -E2BIG;
 
-		//Network Type
-		//================================
+		/*Network Type */
+		/*================================ */
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWMODE;
 		if (pAdapter->ScanTab.BssEntry[i].BssType == Ndis802_11IBSS) {
@@ -971,8 +971,8 @@ int rt_ioctl_giwscan(struct net_device *
 		if (current_ev == previous_ev)
 			return -E2BIG;
 
-		//Channel and Frequency
-		//================================
+		/*Channel and Frequency */
+		/*================================ */
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWFREQ;
 		if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
@@ -989,8 +989,8 @@ int rt_ioctl_giwscan(struct net_device *
 		if (current_ev == previous_ev)
 			return -E2BIG;
 
-		//Add quality statistics
-		//================================
+		/*Add quality statistics */
+		/*================================ */
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = IWEVQUAL;
 		iwe.u.qual.level = 0;
@@ -1003,8 +1003,8 @@ int rt_ioctl_giwscan(struct net_device *
 		if (current_ev == previous_ev)
 			return -E2BIG;
 
-		//Encyption key
-		//================================
+		/*Encyption key */
+		/*================================ */
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWENCODE;
 		if (CAP_IS_PRIVACY_ON
@@ -1024,8 +1024,8 @@ int rt_ioctl_giwscan(struct net_device *
 		if (current_ev == previous_ev)
 			return -E2BIG;
 
-		//Bit Rate
-		//================================
+		/*Bit Rate */
+		/*================================ */
 		if (pAdapter->ScanTab.BssEntry[i].SupRateLen) {
 			UCHAR tmpRate =
 			    pAdapter->ScanTab.BssEntry[i].SupRate[pAdapter->
@@ -1083,7 +1083,7 @@ int rt_ioctl_giwscan(struct net_device *
 			else
 				return -E2BIG;
 		}
-		//WPA IE
+		/*WPA IE */
 		if (pAdapter->ScanTab.BssEntry[i].WpaIE.IELen > 0) {
 			memset(&iwe, 0, sizeof(iwe));
 			memset(&custom[0], 0, MAX_CUSTOM_LEN);
@@ -1099,7 +1099,7 @@ int rt_ioctl_giwscan(struct net_device *
 			if (current_ev == previous_ev)
 				return -E2BIG;
 		}
-		//WPA2 IE
+		/*WPA2 IE */
 		if (pAdapter->ScanTab.BssEntry[i].RsnIE.IELen > 0) {
 			memset(&iwe, 0, sizeof(iwe));
 			memset(&custom[0], 0, MAX_CUSTOM_LEN);
@@ -1133,7 +1133,7 @@ int rt_ioctl_siwessid(struct net_device 
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1142,7 +1142,7 @@ int rt_ioctl_siwessid(struct net_device 
 	if (data->flags) {
 		PSTRING pSsidString = NULL;
 
-		// Includes null character.
+		/* Includes null character. */
 		if (data->length > (IW_ESSID_MAX_SIZE + 1))
 			return -E2BIG;
 
@@ -1155,7 +1155,7 @@ int rt_ioctl_siwessid(struct net_device 
 		} else
 			return -ENOMEM;
 	} else {
-		// ANY ssid
+		/* ANY ssid */
 		if (Set_SSID_Proc(pAdapter, "") == FALSE)
 			return -EINVAL;
 	}
@@ -1183,14 +1183,14 @@ int rt_ioctl_giwessid(struct net_device 
 		       pAdapter->CommonCfg.SsidLen);
 	}
 #ifdef RTMP_MAC_USB
-	// Add for RT2870
+	/* Add for RT2870 */
 	else if (pAdapter->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) {
 		data->length = pAdapter->CommonCfg.SsidLen;
 		memcpy(essid, pAdapter->CommonCfg.Ssid,
 		       pAdapter->CommonCfg.SsidLen);
 	}
-#endif // RTMP_MAC_USB //
-	else {			//the ANY ssid was specified
+#endif /* RTMP_MAC_USB // */
+	else {			/*the ANY ssid was specified */
 		data->length = 0;
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("MediaState is not connected, ess\n"));
@@ -1208,7 +1208,7 @@ int rt_ioctl_siwnickn(struct net_device 
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1249,7 +1249,7 @@ int rt_ioctl_siwrts(struct net_device *d
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1278,7 +1278,7 @@ int rt_ioctl_giwrts(struct net_device *d
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1300,7 +1300,7 @@ int rt_ioctl_siwfrag(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1328,7 +1328,7 @@ int rt_ioctl_giwfrag(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1351,7 +1351,7 @@ int rt_ioctl_siwencode(struct net_device
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1366,7 +1366,7 @@ int rt_ioctl_siwencode(struct net_device
 		goto done;
 	} else if (erq->flags & IW_ENCODE_RESTRICTED
 		   || erq->flags & IW_ENCODE_OPEN) {
-		//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+		/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 		STA_PORT_SECURED(pAdapter);
 		pAdapter->StaCfg.PairCipher = Ndis802_11WEPEnabled;
 		pAdapter->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
@@ -1390,7 +1390,7 @@ int rt_ioctl_siwencode(struct net_device
 				 ("==>rt_ioctl_siwencode::Wrong keyIdx=%d! Using default key instead (%d)\n",
 				  keyIdx, pAdapter->StaCfg.DefaultKeyId));
 
-			//Using default key
+			/*Using default key */
 			keyIdx = pAdapter->StaCfg.DefaultKeyId;
 		} else
 			pAdapter->StaCfg.DefaultKeyId = keyIdx;
@@ -1455,7 +1455,7 @@ rt_ioctl_giwencode(struct net_device *de
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1469,14 +1469,14 @@ rt_ioctl_giwencode(struct net_device *de
 		erq->length = 0;
 		erq->flags = IW_ENCODE_DISABLED;
 	} else if ((kid > 0) && (kid <= 4)) {
-		// copy wep key
+		/* copy wep key */
 		erq->flags = kid;	/* NB: base 1 */
 		if (erq->length > pAdapter->SharedKey[BSS0][kid - 1].KeyLen)
 			erq->length = pAdapter->SharedKey[BSS0][kid - 1].KeyLen;
 		memcpy(key, pAdapter->SharedKey[BSS0][kid - 1].Key,
 		       erq->length);
-		//if ((kid == pAdapter->PortCfg.DefaultKeyId))
-		//erq->flags |= IW_ENCODE_ENABLED;      /* XXX */
+		/*if ((kid == pAdapter->PortCfg.DefaultKeyId)) */
+		/*erq->flags |= IW_ENCODE_ENABLED; */	/* XXX */
 		if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared)
 			erq->flags |= IW_ENCODE_RESTRICTED;	/* XXX */
 		else
@@ -1493,7 +1493,7 @@ rt_ioctl_giwencode(struct net_device *de
 		memcpy(key,
 		       pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].
 		       Key, erq->length);
-		// copy default key ID
+		/* copy default key ID */
 		if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared)
 			erq->flags |= IW_ENCODE_RESTRICTED;	/* XXX */
 		else
@@ -1595,7 +1595,7 @@ int rt_ioctl_siwmlme(struct net_device *
 			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 		}
 		break;
-#endif // IW_MLME_DEAUTH //
+#endif /* IW_MLME_DEAUTH // */
 #ifdef IW_MLME_DISASSOC
 	case IW_MLME_DISASSOC:
 		DBGPRINT(RT_DEBUG_TRACE,
@@ -1612,7 +1612,7 @@ int rt_ioctl_siwmlme(struct net_device *
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
 		MlmeDisassocReqAction(pAd, &MsgElem);
 		break;
-#endif // IW_MLME_DISASSOC //
+#endif /* IW_MLME_DISASSOC // */
 	default:
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("====> %s - Unknow Command\n", __func__));
@@ -1631,7 +1631,7 @@ int rt_ioctl_siwauth(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1712,10 +1712,10 @@ int rt_ioctl_siwauth(struct net_device *
 				    Ndis802_11AuthModeWPA2;
 				pAdapter->StaCfg.IEEE8021X = FALSE;
 			} else
-				// WEP 1x
+				/* WEP 1x */
 				pAdapter->StaCfg.IEEE8021X = TRUE;
 		} else if (param->value == 0) {
-			//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+			/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 			STA_PORT_SECURED(pAdapter);
 		}
 		DBGPRINT(RT_DEBUG_TRACE,
@@ -1742,7 +1742,7 @@ int rt_ioctl_siwauth(struct net_device *
 			pAdapter->StaCfg.PortSecured =
 			    WPA_802_1X_PORT_NOT_SECURED;
 		else {
-			//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+			/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 			STA_PORT_SECURED(pAdapter);
 		}
 		DBGPRINT(RT_DEBUG_TRACE,
@@ -1781,7 +1781,7 @@ int rt_ioctl_giwauth(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1831,7 +1831,7 @@ void fnSetCipherKey(IN PRTMP_ADAPTER pAd
 		       LEN_TKIP_RXMICK);
 	pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CipherAlg;
 
-	// Update group key information to ASIC Shared Key Table
+	/* Update group key information to ASIC Shared Key Table */
 	AsicAddSharedKeyEntry(pAdapter,
 			      BSS0,
 			      keyIdx,
@@ -1841,14 +1841,14 @@ void fnSetCipherKey(IN PRTMP_ADAPTER pAd
 			      pAdapter->SharedKey[BSS0][keyIdx].RxMic);
 
 	if (bGTK)
-		// Update ASIC WCID attribute table and IVEIV table
+		/* Update ASIC WCID attribute table and IVEIV table */
 		RTMPAddWcidAttributeEntry(pAdapter,
 					  BSS0,
 					  keyIdx,
 					  pAdapter->SharedKey[BSS0][keyIdx].
 					  CipherAlg, NULL);
 	else
-		// Update ASIC WCID attribute table and IVEIV table
+		/* Update ASIC WCID attribute table and IVEIV table */
 		RTMPAddWcidAttributeEntry(pAdapter,
 					  BSS0,
 					  keyIdx,
@@ -1869,7 +1869,7 @@ int rt_ioctl_siwencodeext(struct net_dev
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -1877,7 +1877,7 @@ int rt_ioctl_siwencodeext(struct net_dev
 
 	if (encoding->flags & IW_ENCODE_DISABLED) {
 		keyIdx = (encoding->flags & IW_ENCODE_INDEX) - 1;
-		// set BSSID wcid entry of the Pair-wise Key table as no-security mode
+		/* set BSSID wcid entry of the Pair-wise Key table as no-security mode */
 		AsicRemovePairwiseKeyEntry(pAdapter, BSS0, BSSID_WCID);
 		pAdapter->SharedKey[BSS0][keyIdx].KeyLen = 0;
 		pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_NONE;
@@ -1888,7 +1888,7 @@ int rt_ioctl_siwencodeext(struct net_dev
 			 ("%s::Remove all keys!(encoding->flags = %x)\n",
 			  __func__, encoding->flags));
 	} else {
-		// Get Key Index and convet to our own defined key index
+		/* Get Key Index and convet to our own defined key index */
 		keyIdx = (encoding->flags & IW_ENCODE_INDEX) - 1;
 		if ((keyIdx < 0) || (keyIdx >= NR_WEP_KEYS))
 			return -EINVAL;
@@ -1930,7 +1930,7 @@ int rt_ioctl_siwencodeext(struct net_dev
 			    Ndis802_11GroupWEP40Enabled
 			    || pAdapter->StaCfg.GroupCipher ==
 			    Ndis802_11GroupWEP104Enabled) {
-				// Set Group key material to Asic
+				/* Set Group key material to Asic */
 				AsicAddSharedKeyEntry(pAdapter, BSS0, keyIdx,
 						      pAdapter->
 						      SharedKey[BSS0][keyIdx].
@@ -1939,7 +1939,7 @@ int rt_ioctl_siwencodeext(struct net_dev
 						      SharedKey[BSS0][keyIdx].
 						      Key, NULL, NULL);
 
-				// Update WCID attribute table and IVEIV table for this group key table
+				/* Update WCID attribute table and IVEIV table for this group key table */
 				RTMPAddWcidAttributeEntry(pAdapter, BSS0,
 							  keyIdx,
 							  pAdapter->
@@ -1949,7 +1949,7 @@ int rt_ioctl_siwencodeext(struct net_dev
 
 				STA_PORT_SECURED(pAdapter);
 
-				// Indicate Connected for GUI
+				/* Indicate Connected for GUI */
 				pAdapter->IndicateMediaState =
 				    NdisMediaStateConnected;
 			}
@@ -1964,7 +1964,7 @@ int rt_ioctl_siwencodeext(struct net_dev
 						       CIPHER_TKIP, FALSE, ext);
 					if (pAdapter->StaCfg.AuthMode >=
 					    Ndis802_11AuthModeWPA2) {
-						//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+						/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 						STA_PORT_SECURED(pAdapter);
 						pAdapter->IndicateMediaState =
 						    NdisMediaStateConnected;
@@ -1975,8 +1975,8 @@ int rt_ioctl_siwencodeext(struct net_dev
 					fnSetCipherKey(pAdapter, keyIdx,
 						       CIPHER_TKIP, TRUE, ext);
 
-					// set 802.1x port control
-					//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+					/* set 802.1x port control */
+					/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 					STA_PORT_SECURED(pAdapter);
 					pAdapter->IndicateMediaState =
 					    NdisMediaStateConnected;
@@ -1990,7 +1990,7 @@ int rt_ioctl_siwencodeext(struct net_dev
 					       FALSE, ext);
 				if (pAdapter->StaCfg.AuthMode >=
 				    Ndis802_11AuthModeWPA2)
-					//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+					/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 					STA_PORT_SECURED(pAdapter);
 				pAdapter->IndicateMediaState =
 				    NdisMediaStateConnected;
@@ -1998,8 +1998,8 @@ int rt_ioctl_siwencodeext(struct net_dev
 				fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES,
 					       TRUE, ext);
 
-				// set 802.1x port control
-				//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+				/* set 802.1x port control */
+				/*pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 				STA_PORT_SECURED(pAdapter);
 				pAdapter->IndicateMediaState =
 				    NdisMediaStateConnected;
@@ -2142,7 +2142,7 @@ int rt_ioctl_giwgenie(struct net_device 
 	} else {
 		UCHAR RSNIe = IE_WPA;
 
-		if (wrqu->data.length < (pAd->StaCfg.RSNIE_Len + 2))	// ID, Len
+		if (wrqu->data.length < (pAd->StaCfg.RSNIE_Len + 2))	/* ID, Len */
 			return -E2BIG;
 		wrqu->data.length = pAd->StaCfg.RSNIE_Len + 2;
 
@@ -2183,7 +2183,7 @@ int rt_ioctl_siwpmksa(struct net_device 
 	case IW_PMKSA_REMOVE:
 		for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum;
 		     CachedIdx++) {
-			// compare the BSSID
+			/* compare the BSSID */
 			if (NdisEqualMemory
 			    (pPmksa->bssid.sa_data,
 			     pAd->StaCfg.SavedPMK[CachedIdx].BSSID,
@@ -2219,7 +2219,7 @@ int rt_ioctl_siwpmksa(struct net_device 
 	case IW_PMKSA_ADD:
 		for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum;
 		     CachedIdx++) {
-			// compare the BSSID
+			/* compare the BSSID */
 			if (NdisEqualMemory
 			    (pPmksa->bssid.sa_data,
 			     pAd->StaCfg.SavedPMK[CachedIdx].BSSID,
@@ -2227,7 +2227,7 @@ int rt_ioctl_siwpmksa(struct net_device 
 				break;
 		}
 
-		// Found, replace it
+		/* Found, replace it */
 		if (CachedIdx < PMKID_NO) {
 			DBGPRINT(RT_DEBUG_OFF,
 				 ("Update PMKID, idx = %d\n", CachedIdx));
@@ -2238,9 +2238,9 @@ int rt_ioctl_siwpmksa(struct net_device 
 				       PMKID[0], pPmksa->pmkid, 16);
 			pAd->StaCfg.SavedPMKNum++;
 		}
-		// Not found, replace the last one
+		/* Not found, replace the last one */
 		else {
-			// Randomly replace one
+			/* Randomly replace one */
 			CachedIdx = (pPmksa->bssid.sa_data[5] % PMKID_NO);
 			DBGPRINT(RT_DEBUG_OFF,
 				 ("Update PMKID, idx = %d\n", CachedIdx));
@@ -2272,7 +2272,7 @@ int rt_ioctl_siwrate(struct net_device *
 
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("rt_ioctl_siwrate::Network is down!\n"));
@@ -2285,7 +2285,7 @@ int rt_ioctl_siwrate(struct net_device *
 	   rate = X, fixed = 1 => (fixed rate X)
 	 */
 	if (rate == -1) {
-		//Auto Rate
+		/*Auto Rate */
 		pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
 		pAd->StaCfg.bAutoTxRateSwitch = TRUE;
 		if ((pAd->CommonCfg.PhyMode <= PHY_11G) ||
@@ -2311,7 +2311,7 @@ int rt_ioctl_siwrate(struct net_device *
 				  pAd->StaCfg.DesiredTransmitSetting.field.
 				  MCS));
 		} else {
-			// TODO: rate = X, fixed = 0 => (rates <= X)
+			/* TODO: rate = X, fixed = 0 => (rates <= X) */
 			return -EOPNOTSUPP;
 		}
 	}
@@ -2342,7 +2342,7 @@ int rt_ioctl_giwrate(struct net_device *
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
 	rate_count = sizeof(ralinkrate) / sizeof(__s32);
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
@@ -2359,7 +2359,7 @@ int rt_ioctl_giwrate(struct net_device *
 		    pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word;
 
 	if (ht_setting.field.MODE >= MODE_HTMIX) {
-//      rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS);
+/*      rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS); */
 		rate_index =
 		    12 + ((UCHAR) ht_setting.field.BW * 24) +
 		    ((UCHAR) ht_setting.field.ShortGI * 48) +
@@ -2460,7 +2460,7 @@ INT rt28xx_sta_ioctl(IN struct net_devic
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-	//check if the interface is down
+	/*check if the interface is down */
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		{
 			DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
@@ -2468,7 +2468,7 @@ INT rt28xx_sta_ioctl(IN struct net_devic
 		}
 	}
 
-	{			// determine this ioctl command is comming from which interface.
+	{			/* determine this ioctl command is comming from which interface. */
 		pObj->ioctl_if_type = INT_MAIN;
 		pObj->ioctl_if = MAIN_MBSSID;
 	}
@@ -2484,41 +2484,41 @@ INT rt28xx_sta_ioctl(IN struct net_devic
 			rt_ioctl_giwname(net_dev, NULL, name, NULL);
 			break;
 		}
-	case SIOCGIWESSID:	//Get ESSID
+	case SIOCGIWESSID:	/*Get ESSID */
 		{
 			struct iw_point *essid = &wrq->u.essid;
 			rt_ioctl_giwessid(net_dev, NULL, essid, essid->pointer);
 			break;
 		}
-	case SIOCSIWESSID:	//Set ESSID
+	case SIOCSIWESSID:	/*Set ESSID */
 		{
 			struct iw_point *essid = &wrq->u.essid;
 			rt_ioctl_siwessid(net_dev, NULL, essid, essid->pointer);
 			break;
 		}
-	case SIOCSIWNWID:	// set network id (the cell)
-	case SIOCGIWNWID:	// get network id
+	case SIOCSIWNWID:	/* set network id (the cell) */
+	case SIOCGIWNWID:	/* get network id */
 		Status = -EOPNOTSUPP;
 		break;
-	case SIOCSIWFREQ:	//set channel/frequency (Hz)
+	case SIOCSIWFREQ:	/*set channel/frequency (Hz) */
 		{
 			struct iw_freq *freq = &wrq->u.freq;
 			rt_ioctl_siwfreq(net_dev, NULL, freq, NULL);
 			break;
 		}
-	case SIOCGIWFREQ:	// get channel/frequency (Hz)
+	case SIOCGIWFREQ:	/* get channel/frequency (Hz) */
 		{
 			struct iw_freq *freq = &wrq->u.freq;
 			rt_ioctl_giwfreq(net_dev, NULL, freq, NULL);
 			break;
 		}
-	case SIOCSIWNICKN:	//set node name/nickname
+	case SIOCSIWNICKN:	/*set node name/nickname */
 		{
-			//struct iw_point *data=&wrq->u.data;
-			//rt_ioctl_siwnickn(net_dev, NULL, data, NULL);
+			/*struct iw_point *data=&wrq->u.data; */
+			/*rt_ioctl_siwnickn(net_dev, NULL, data, NULL); */
 			break;
 		}
-	case SIOCGIWNICKN:	//get node name/nickname
+	case SIOCGIWNICKN:	/*get node name/nickname */
 		{
 			struct iw_point *erq = NULL;
 			erq = &wrq->u.data;
@@ -2528,37 +2528,37 @@ INT rt28xx_sta_ioctl(IN struct net_devic
 					 erq->length);
 			break;
 		}
-	case SIOCGIWRATE:	//get default bit rate (bps)
+	case SIOCGIWRATE:	/*get default bit rate (bps) */
 		rt_ioctl_giwrate(net_dev, NULL, &wrq->u, NULL);
 		break;
-	case SIOCSIWRATE:	//set default bit rate (bps)
+	case SIOCSIWRATE:	/*set default bit rate (bps) */
 		rt_ioctl_siwrate(net_dev, NULL, &wrq->u, NULL);
 		break;
-	case SIOCGIWRTS:	// get RTS/CTS threshold (bytes)
+	case SIOCGIWRTS:	/* get RTS/CTS threshold (bytes) */
 		{
 			struct iw_param *rts = &wrq->u.rts;
 			rt_ioctl_giwrts(net_dev, NULL, rts, NULL);
 			break;
 		}
-	case SIOCSIWRTS:	//set RTS/CTS threshold (bytes)
+	case SIOCSIWRTS:	/*set RTS/CTS threshold (bytes) */
 		{
 			struct iw_param *rts = &wrq->u.rts;
 			rt_ioctl_siwrts(net_dev, NULL, rts, NULL);
 			break;
 		}
-	case SIOCGIWFRAG:	//get fragmentation thr (bytes)
+	case SIOCGIWFRAG:	/*get fragmentation thr (bytes) */
 		{
 			struct iw_param *frag = &wrq->u.frag;
 			rt_ioctl_giwfrag(net_dev, NULL, frag, NULL);
 			break;
 		}
-	case SIOCSIWFRAG:	//set fragmentation thr (bytes)
+	case SIOCSIWFRAG:	/*set fragmentation thr (bytes) */
 		{
 			struct iw_param *frag = &wrq->u.frag;
 			rt_ioctl_siwfrag(net_dev, NULL, frag, NULL);
 			break;
 		}
-	case SIOCGIWENCODE:	//get encoding token & mode
+	case SIOCGIWENCODE:	/*get encoding token & mode */
 		{
 			struct iw_point *erq = &wrq->u.encoding;
 			if (erq)
@@ -2566,7 +2566,7 @@ INT rt28xx_sta_ioctl(IN struct net_devic
 						   erq->pointer);
 			break;
 		}
-	case SIOCSIWENCODE:	//set encoding token & mode
+	case SIOCSIWENCODE:	/*set encoding token & mode */
 		{
 			struct iw_point *erq = &wrq->u.encoding;
 			if (erq)
@@ -2574,41 +2574,41 @@ INT rt28xx_sta_ioctl(IN struct net_devic
 						   erq->pointer);
 			break;
 		}
-	case SIOCGIWAP:	//get access point MAC addresses
+	case SIOCGIWAP:	/*get access point MAC addresses */
 		{
 			struct sockaddr *ap_addr = &wrq->u.ap_addr;
 			rt_ioctl_giwap(net_dev, NULL, ap_addr,
 				       ap_addr->sa_data);
 			break;
 		}
-	case SIOCSIWAP:	//set access point MAC addresses
+	case SIOCSIWAP:	/*set access point MAC addresses */
 		{
 			struct sockaddr *ap_addr = &wrq->u.ap_addr;
 			rt_ioctl_siwap(net_dev, NULL, ap_addr,
 				       ap_addr->sa_data);
 			break;
 		}
-	case SIOCGIWMODE:	//get operation mode
+	case SIOCGIWMODE:	/*get operation mode */
 		{
 			__u32 *mode = &wrq->u.mode;
 			rt_ioctl_giwmode(net_dev, NULL, mode, NULL);
 			break;
 		}
-	case SIOCSIWMODE:	//set operation mode
+	case SIOCSIWMODE:	/*set operation mode */
 		{
 			__u32 *mode = &wrq->u.mode;
 			rt_ioctl_siwmode(net_dev, NULL, mode, NULL);
 			break;
 		}
-	case SIOCGIWSENS:	//get sensitivity (dBm)
-	case SIOCSIWSENS:	//set sensitivity (dBm)
-	case SIOCGIWPOWER:	//get Power Management settings
-	case SIOCSIWPOWER:	//set Power Management settings
-	case SIOCGIWTXPOW:	//get transmit power (dBm)
-	case SIOCSIWTXPOW:	//set transmit power (dBm)
-	case SIOCGIWRANGE:	//Get range of parameters
-	case SIOCGIWRETRY:	//get retry limits and lifetime
-	case SIOCSIWRETRY:	//set retry limits and lifetime
+	case SIOCGIWSENS:	/*get sensitivity (dBm) */
+	case SIOCSIWSENS:	/*set sensitivity (dBm) */
+	case SIOCGIWPOWER:	/*get Power Management settings */
+	case SIOCSIWPOWER:	/*set Power Management settings */
+	case SIOCGIWTXPOW:	/*get transmit power (dBm) */
+	case SIOCSIWTXPOW:	/*set transmit power (dBm) */
+	case SIOCGIWRANGE:	/*Get range of parameters */
+	case SIOCGIWRETRY:	/*get retry limits and lifetime */
+	case SIOCSIWRETRY:	/*set retry limits and lifetime */
 	case RT_PRIV_IOCTL:
 	case RT_PRIV_IOCTL_EXT:
 	case RTPRIV_IOCTL_SET:
@@ -2625,7 +2625,7 @@ INT rt28xx_sta_ioctl(IN struct net_devic
 		break;
 	}
 
-	if (StateMachineTouched)	// Upper layer sent a MLME-related operations
+	if (StateMachineTouched)	/* Upper layer sent a MLME-related operations */
 		RTMP_MLME_HANDLER(pAd);
 
 	return Status;
@@ -2650,7 +2650,7 @@ INT Set_SSID_Proc(IN PRTMP_ADAPTER pAdap
 		if (strlen(arg) != 0) {
 			NdisMoveMemory(Ssid.Ssid, arg, strlen(arg));
 			Ssid.SsidLength = strlen(arg);
-		} else		//ANY ssid
+		} else		/*ANY ssid */
 		{
 			Ssid.SsidLength = 0;
 			memcpy(Ssid.Ssid, "", 0);
@@ -2704,7 +2704,7 @@ INT Set_SSID_Proc(IN PRTMP_ADAPTER pAdap
 	} else
 		success = FALSE;
 
-	if (StateMachineTouched)	// Upper layer sent a MLME-related operations
+	if (StateMachineTouched)	/* Upper layer sent a MLME-related operations */
 		RTMP_MLME_HANDLER(pAdapter);
 
 	return success;
@@ -2724,7 +2724,7 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 
 	if (strcmp(arg, "Adhoc") == 0) {
 		if (pAdapter->StaCfg.BssType != BSS_ADHOC) {
-			// Config has changed
+			/* Config has changed */
 			pAdapter->bConfigChanged = TRUE;
 			if (MONITOR_ON(pAdapter)) {
 				RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG,
@@ -2738,9 +2738,9 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 				LinkDown(pAdapter, FALSE);
 			}
 			if (INFRA_ON(pAdapter)) {
-				//BOOLEAN Cancelled;
-				// Set the AutoReconnectSsid to prevent it reconnect to old SSID
-				// Since calling this indicate user don't want to connect to that SSID anymore.
+				/*BOOLEAN Cancelled; */
+				/* Set the AutoReconnectSsid to prevent it reconnect to old SSID */
+				/* Since calling this indicate user don't want to connect to that SSID anymore. */
 				pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
 				NdisZeroMemory(pAdapter->MlmeAux.
 					       AutoReconnectSsid,
@@ -2759,7 +2759,7 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 			 ("===>Set_NetworkType_Proc::(AD-HOC)\n"));
 	} else if (strcmp(arg, "Infra") == 0) {
 		if (pAdapter->StaCfg.BssType != BSS_INFRA) {
-			// Config has changed
+			/* Config has changed */
 			pAdapter->bConfigChanged = TRUE;
 			if (MONITOR_ON(pAdapter)) {
 				RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG,
@@ -2773,8 +2773,8 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 				LinkDown(pAdapter, FALSE);
 			}
 			if (ADHOC_ON(pAdapter)) {
-				// Set the AutoReconnectSsid to prevent it reconnect to old SSID
-				// Since calling this indicate user don't want to connect to that SSID anymore.
+				/* Set the AutoReconnectSsid to prevent it reconnect to old SSID */
+				/* Since calling this indicate user don't want to connect to that SSID anymore. */
 				pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
 				NdisZeroMemory(pAdapter->MlmeAux.
 					       AutoReconnectSsid,
@@ -2794,9 +2794,9 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 		OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_INFRA_ON);
 		OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_ADHOC_ON);
 		OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED);
-		// disable all periodic state machine
+		/* disable all periodic state machine */
 		pAdapter->StaCfg.bAutoReconnect = FALSE;
-		// reset all mlme state machine
+		/* reset all mlme state machine */
 		RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("fOP_STATUS_MEDIA_STATE_CONNECTED \n"));
@@ -2812,7 +2812,7 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 		    pAdapter->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
 		    pAdapter->CommonCfg.RegTransmitSetting.field.EXTCHA ==
 		    EXTCHA_ABOVE) {
-			// 40MHz ,control channel at lower
+			/* 40MHz ,control channel at lower */
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
 						    &bbpValue);
 			bbpValue &= (~0x18);
@@ -2820,7 +2820,7 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4,
 						     bbpValue);
 			pAdapter->CommonCfg.BBPCurrentBW = BW_40;
-			//  RX : control channel at lower
+			/*  RX : control channel at lower */
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R3,
 						    &bbpValue);
 			bbpValue &= (~0x20);
@@ -2846,7 +2846,7 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 			   BW_40
 			   && pAdapter->CommonCfg.RegTransmitSetting.field.
 			   EXTCHA == EXTCHA_BELOW) {
-			// 40MHz ,control channel at upper
+			/* 40MHz ,control channel at upper */
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
 						    &bbpValue);
 			bbpValue &= (~0x18);
@@ -2875,7 +2875,7 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 				  pAdapter->CommonCfg.Channel,
 				  pAdapter->CommonCfg.CentralChannel));
 		} else {
-			// 20MHz
+			/* 20MHz */
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
 						    &bbpValue);
 			bbpValue &= (~0x18);
@@ -2889,13 +2889,13 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 				 ("BW_20, Channel(%d)\n",
 				  pAdapter->CommonCfg.Channel));
 		}
-		// Enable Rx with promiscuous reception
+		/* Enable Rx with promiscuous reception */
 		RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG, 0x3);
-		// ASIC supporsts sniffer function with replacing RSSI with timestamp.
-		//RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value);
-		//Value |= (0x80);
-		//RTMP_IO_WRITE32(pAdapter, MAC_SYS_CTRL, Value);
-		// disable sync
+		/* ASIC supporsts sniffer function with replacing RSSI with timestamp. */
+		/*RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value); */
+		/*Value |= (0x80); */
+		/*RTMP_IO_WRITE32(pAdapter, MAC_SYS_CTRL, Value); */
+		/* disable sync */
 		RTMP_IO_READ32(pAdapter, BCN_TIME_CFG, &csr.word);
 		csr.field.bBeaconGen = 0;
 		csr.field.bTBTTEnable = 0;
@@ -2903,11 +2903,11 @@ INT Set_NetworkType_Proc(IN PRTMP_ADAPTE
 		RTMP_IO_WRITE32(pAdapter, BCN_TIME_CFG, csr.word);
 
 		pAdapter->StaCfg.BssType = BSS_MONITOR;
-		pAdapter->net_dev->type = ARPHRD_IEEE80211_PRISM;	//ARPHRD_IEEE80211; // IEEE80211
+		pAdapter->net_dev->type = ARPHRD_IEEE80211_PRISM;	/*ARPHRD_IEEE80211; // IEEE80211 */
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("===>Set_NetworkType_Proc::(MONITOR)\n"));
 	}
-	// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+	/* Reset Ralink supplicant to not use, it will be set to start when UI set PMK key */
 	pAdapter->StaCfg.WpaState = SS_NOTUSE;
 
 	DBGPRINT(RT_DEBUG_TRACE,
--- a/drivers/staging/rt2860/usb_main_dev.c
+++ b/drivers/staging/rt2860/usb_main_dev.c
@@ -26,9 +26,9 @@
 
 #include "rt_config.h"
 
-// Following information will be show when you run 'modinfo'
-// *** If you have a solution for the bug in current version of driver, please mail to me.
-// Otherwise post to forum in ralinktech's web site(www.ralinktech.com) and let all users help you. ***
+/* Following information will be show when you run 'modinfo' */
+/* *** If you have a solution for the bug in current version of driver, please mail to me. */
+/* Otherwise post to forum in ralinktech's web site(www.ralinktech.com) and let all users help you. *** */
 MODULE_AUTHOR("Paul Lin <paul_lin@ralinktech.com>");
 MODULE_DESCRIPTION("RT2870/RT3070 Wireless Lan Linux Driver");
 MODULE_LICENSE("GPL");
@@ -101,7 +101,7 @@ struct usb_device_id rtusb_usb_id[] = {
 	{USB_DEVICE(0x1737, 0x0071)},	/* Linksys WUSB600N */
 	{USB_DEVICE(0x0411, 0x00e8)},	/* Buffalo WLI-UC-G300N */
 	{USB_DEVICE(0x050d, 0x815c)},	/* Belkin F5D8053 */
-#endif // RT2870 //
+#endif /* RT2870 // */
 #ifdef RT3070
 	{USB_DEVICE(0x148F, 0x3070)},	/* Ralink 3070 */
 	{USB_DEVICE(0x148F, 0x3071)},	/* Ralink 3071 */
@@ -134,7 +134,7 @@ struct usb_device_id rtusb_usb_id[] = {
 	{USB_DEVICE(0x5A57, 0x0283)},	/* Zinwell 3072 */
 	{USB_DEVICE(0x04BB, 0x0945)},	/* I-O DATA 3072 */
 	{USB_DEVICE(0x203D, 0x1480)},	/* Encore 3070 */
-#endif // RT3070 //
+#endif /* RT3070 // */
 	{USB_DEVICE(0x0DF6, 0x003F)},	/* Sitecom WL-608 */
 	{USB_DEVICE(0x1737, 0x0077)},	/* Linksys WUSB54GC-EU v3 */
 	{USB_DEVICE(0x2001, 0x3C09)},	/* D-Link */
@@ -207,14 +207,14 @@ BOOLEAN RT28XXChipsetCheck(IN void *_dev
 
 /**************************************************************************/
 /**************************************************************************/
-//tested for kernel 2.6series
+/*tested for kernel 2.6series */
 /**************************************************************************/
 /**************************************************************************/
 
 #ifdef CONFIG_PM
 static int rt2870_suspend(struct usb_interface *intf, pm_message_t state);
 static int rt2870_resume(struct usb_interface *intf);
-#endif // CONFIG_PM //
+#endif /* CONFIG_PM // */
 
 static int rtusb_probe(struct usb_interface *intf,
 		       const struct usb_device_id *id);
@@ -264,8 +264,8 @@ static BOOLEAN USBDevConfigInit(IN struc
 			((iface_desc->endpoint[i].desc.
 			  bEndpointAddress & USB_ENDPOINT_DIR_MASK) ==
 			 USB_DIR_OUT)) {
-			// there are 6 bulk out EP. EP6 highest priority.
-			// EP1-4 is EDCA.  EP5 is HCCA.
+			/* there are 6 bulk out EP. EP6 highest priority. */
+			/* EP1-4 is EDCA.  EP5 is HCCA. */
 			pAd->BulkOutEpAddr[BulkOutIdx++] =
 			    iface_desc->endpoint[i].desc.bEndpointAddress;
 			pAd->BulkOutMaxPacketSize =
@@ -340,8 +340,8 @@ resume:rt2870_resume,
 
 VOID RT2870RejectPendingPackets(IN PRTMP_ADAPTER pAd)
 {
-	// clear PS packets
-	// clear TxSw packets
+	/* clear PS packets */
+	/* clear TxSw packets */
 }
 
 static int rt2870_suspend(struct usb_interface *intf, pm_message_t state)
@@ -379,16 +379,16 @@ static int rt2870_resume(struct usb_inte
 	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2870_resume()\n"));
 	return 0;
 }
-#endif // CONFIG_PM //
+#endif /* CONFIG_PM // */
 
-// Init driver module
+/* Init driver module */
 INT __init rtusb_init(void)
 {
 	printk("rtusb init --->\n");
 	return usb_register(&rtusb_driver);
 }
 
-// Deinit driver module
+/* Deinit driver module */
 VOID __exit rtusb_exit(void)
 {
 	usb_deregister(&rtusb_driver);
@@ -442,7 +442,7 @@ INT MlmeThread(IN void *Context)
 #endif
 
 		/* lock the device pointers , need to check if required */
-		//down(&(pAd->usbdev_semaphore));
+		/*down(&(pAd->usbdev_semaphore)); */
 
 		if (!pAd->PM_FlgSuspend)
 			MlmeHandler(pAd);
@@ -521,7 +521,7 @@ INT RTUSBCmdThread(IN void *Context)
 			CMDHandler(pAd);
 	}
 
-	if (pAd && !pAd->PM_FlgSuspend) {	// Clear the CmdQElements.
+	if (pAd && !pAd->PM_FlgSuspend) {	/* Clear the CmdQElements. */
 		CmdQElmt *pCmdQElmt = NULL;
 
 		NdisAcquireSpinLock(&pAd->CmdQLock);
@@ -633,10 +633,10 @@ VOID RTUSBWatchDog(IN RTMP_ADAPTER * pAd
 			       fRTMP_ADAPTER_NIC_NOT_EXIST |
 			       fRTMP_ADAPTER_BULKOUT_RESET)))
 			    ) {
-				// FIXME: Following code just support single bulk out. If you wanna support multiple bulk out. Modify it!
+				/* FIXME: Following code just support single bulk out. If you wanna support multiple bulk out. Modify it! */
 				pHTTXContext =
 				    (PHT_TX_CONTEXT) (&pAd->TxContext[idx]);
-				if (pHTTXContext->IRPPending) {	// Check TxContext.
+				if (pHTTXContext->IRPPending) {	/* Check TxContext. */
 					pUrb = pHTTXContext->pUrb;
 
 					actual_length = pUrb->actual_length;
@@ -647,7 +647,7 @@ VOID RTUSBWatchDog(IN RTMP_ADAPTER * pAd
 					PTX_CONTEXT pMLMEContext, pNULLContext,
 					    pPsPollContext;
 
-					//Check MgmtContext.
+					/*Check MgmtContext. */
 					pMLMEContext =
 					    (PTX_CONTEXT) (pAd->MgmtRing.
 							   Cell[pAd->MgmtRing.
@@ -688,7 +688,7 @@ VOID RTUSBWatchDog(IN RTMP_ADAPTER * pAd
 					     && pAd->TransferedLength[idx] <
 					     transfer_buffer_length
 					     && actual_length != 0
-//                                      && TxRxQ_Pcnt==0
+/*                                      && TxRxQ_Pcnt==0 */
 					     && pAd->watchDogTxPendingCnt[idx] >
 					     3)
 					    || isDataPacket == FALSE
@@ -699,10 +699,10 @@ VOID RTUSBWatchDog(IN RTMP_ADAPTER * pAd
 							  idx));
 						DBGPRINT(RT_DEBUG_TRACE,
 							 ("Unlink the pending URB!\n"));
-						// unlink it now
+						/* unlink it now */
 						RTUSB_UNLINK_URB(pUrb);
-						// Sleep 200 microseconds to give cancellation time to work
-						//RTMPusecDelay(200);
+						/* Sleep 200 microseconds to give cancellation time to work */
+						/*RTMPusecDelay(200); */
 						needDumpSeq = TRUE;
 					}
 				} else {
@@ -721,7 +721,7 @@ VOID RTUSBWatchDog(IN RTMP_ADAPTER * pAd
 		}
 	}
 
-	// For Sigma debug, dump the ba_reordering sequence.
+	/* For Sigma debug, dump the ba_reordering sequence. */
 	if ((needDumpSeq == TRUE) && (pAd->CommonCfg.bDisableReordering == 0)) {
 		USHORT Idx;
 		PBA_REC_ENTRY pBAEntry = NULL;
@@ -780,22 +780,22 @@ static void rt2870_disconnect(struct usb
 	}
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST);
 
-	// for debug, wait to show some messages to /proc system
+	/* for debug, wait to show some messages to /proc system */
 	udelay(1);
 
 	RtmpPhyNetDevExit(pAd, pAd->net_dev);
 
-	// FIXME: Shall we need following delay and flush the schedule??
+	/* FIXME: Shall we need following delay and flush the schedule?? */
 	udelay(1);
 	flush_scheduled_work();
 	udelay(1);
 
-	// free the root net_device
+	/* free the root net_device */
 	RtmpOSNetDevFree(pAd->net_dev);
 
 	RtmpRaDevCtrlExit(pAd);
 
-	// release a use of the usb device structure
+	/* release a use of the usb device structure */
 	usb_put_dev(dev);
 	udelay(1);
 
@@ -815,12 +815,12 @@ static int __devinit rt2870_probe(IN str
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===>rt2870_probe()!\n"));
 
-	// Check chipset vendor/product ID
-	//if (RT28XXChipsetCheck(_dev_p) == FALSE)
-	//      goto err_out;
+	/* Check chipset vendor/product ID */
+	/*if (RT28XXChipsetCheck(_dev_p) == FALSE) */
+	/*      goto err_out; */
 
-//RtmpDevInit=============================================
-	// Allocate RTMP_ADAPTER adapter structure
+/*RtmpDevInit============================================= */
+	/* Allocate RTMP_ADAPTER adapter structure */
 	handle = kmalloc(sizeof(struct os_cookie), GFP_KERNEL);
 	if (handle == NULL) {
 		printk
@@ -834,18 +834,18 @@ static int __devinit rt2870_probe(IN str
 		kfree(handle);
 		goto err_out;
 	}
-//USBDevInit==============================================
+/*USBDevInit============================================== */
 	if (USBDevConfigInit(usb_dev, intf, pAd) == FALSE)
 		goto err_out_free_radev;
 
 	RtmpRaDevCtrlInit(pAd, RTMP_DEV_INF_USB);
 
-//NetDevInit==============================================
+/*NetDevInit============================================== */
 	net_dev = RtmpPhyNetDevInit(pAd, &netDevHook);
 	if (net_dev == NULL)
 		goto err_out_free_radev;
 
-	// Here are the net_device structure with usb specific parameters.
+	/* Here are the net_device structure with usb specific parameters. */
 	/* for supporting Network Manager.
 	 * Set the sysfs physical device reference for the network logical device if set prior to registration will
 	 * cause a symlink during initialization.
@@ -854,8 +854,8 @@ static int __devinit rt2870_probe(IN str
 
 	pAd->StaCfg.OriDevType = net_dev->type;
 
-//All done, it's time to register the net device to linux kernel.
-	// Register this device
+/*All done, it's time to register the net device to linux kernel. */
+	/* Register this device */
 	status = RtmpOSNetDevAttach(net_dev, &netDevHook);
 	if (status != 0)
 		goto err_out_free_netdev;
--- a/drivers/staging/rt2870/common/rtusb_bulk.c
+++ b/drivers/staging/rt2870/common/rtusb_bulk.c
@@ -40,11 +40,11 @@
 #ifdef RTMP_MAC_USB
 
 #include "../rt_config.h"
-// Match total 6 bulkout endpoint to corresponding queue.
+/* Match total 6 bulkout endpoint to corresponding queue. */
 UCHAR EpToQueue[6] =
     { FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_MGMT };
 
-//static BOOLEAN SingleBulkOut = FALSE;
+/*static BOOLEAN SingleBulkOut = FALSE; */
 
 void RTUSB_FILL_BULK_URB(struct urb *pUrb,
 			 struct usb_device *pUsb_Dev,
@@ -69,7 +69,7 @@ VOID RTUSBInitTxDesc(IN PRTMP_ADAPTER pA
 	pUrb = pTxContext->pUrb;
 	ASSERT(pUrb);
 
-	// Store BulkOut PipeId
+	/* Store BulkOut PipeId */
 	pTxContext->BulkOutPipeId = BulkOutPipeId;
 
 	if (pTxContext->bAggregatible) {
@@ -79,7 +79,7 @@ VOID RTUSBInitTxDesc(IN PRTMP_ADAPTER pA
 		    (PUCHAR) pTxContext->TransferBuffer->field.WirelessPacket;
 	}
 
-	//Initialize a tx bulk urb
+	/*Initialize a tx bulk urb */
 	RTUSB_FILL_BULK_URB(pUrb,
 			    pObj->pUsb_Dev,
 			    usb_sndbulkpipe(pObj->pUsb_Dev,
@@ -108,14 +108,14 @@ VOID RTUSBInitHTTxDesc(IN PRTMP_ADAPTER 
 	pUrb = pTxContext->pUrb;
 	ASSERT(pUrb);
 
-	// Store BulkOut PipeId
+	/* Store BulkOut PipeId */
 	pTxContext->BulkOutPipeId = BulkOutPipeId;
 
 	pSrc =
 	    &pTxContext->TransferBuffer->field.WirelessPacket[pTxContext->
 							      NextBulkOutPosition];
 
-	//Initialize a tx bulk urb
+	/*Initialize a tx bulk urb */
 	RTUSB_FILL_BULK_URB(pUrb,
 			    pObj->pUsb_Dev,
 			    usb_sndbulkpipe(pObj->pUsb_Dev,
@@ -142,7 +142,7 @@ VOID RTUSBInitRxDesc(IN PRTMP_ADAPTER pA
 	else
 		RX_bulk_size = MAX_RXBULK_SIZE;
 
-	//Initialize a rx bulk urb
+	/*Initialize a rx bulk urb */
 	RTUSB_FILL_BULK_URB(pUrb,
 			    pObj->pUsb_Dev,
 			    usb_rcvbulkpipe(pObj->pUsb_Dev, pAd->BulkInEpAddr),
@@ -223,7 +223,7 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 		BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
 
-		// Clear Data flag
+		/* Clear Data flag */
 		RTUSB_CLEAR_BULK_FLAG(pAd,
 				      (fRTUSB_BULK_OUT_DATA_FRAG <<
 				       BulkOutPipeId));
@@ -234,15 +234,15 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 		return;
 	}
-	// Clear Data flag
+	/* Clear Data flag */
 	RTUSB_CLEAR_BULK_FLAG(pAd,
 			      (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
 	RTUSB_CLEAR_BULK_FLAG(pAd,
 			      (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
 
-	//DBGPRINT(RT_DEBUG_TRACE,("BulkOut-B:I=0x%lx, CWPos=%ld, CWRPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", in_interrupt(),
-	//                                                      pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition,
-	//                                                      pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
+	/*DBGPRINT(RT_DEBUG_TRACE,("BulkOut-B:I=0x%lx, CWPos=%ld, CWRPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", in_interrupt(), */
+	/*                                                      pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition, */
+	/*                                                      pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad)); */
 	pHTTXContext->NextBulkOutPosition = pHTTXContext->ENextBulkOutPosition;
 	ThisBulkSize = 0;
 	TmpBulkEndPos = pHTTXContext->NextBulkOutPosition;
@@ -282,12 +282,12 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 				 ("RTUSBBulkOutDataPacket AMPDU = %d.\n",
 				  pTxWI->AMPDU));
 
-		// add by Iverson, limit BulkOut size to 4k to pass WMM b mode 2T1R test items
-		//if ((ThisBulkSize != 0)  && (pTxWI->AMPDU == 0))
+		/* add by Iverson, limit BulkOut size to 4k to pass WMM b mode 2T1R test items */
+		/*if ((ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */
 		if ((ThisBulkSize != 0) && (pTxWI->PHYMODE == MODE_CCK)) {
 			if (((ThisBulkSize & 0xffff8000) != 0)
 			    || ((ThisBulkSize & 0x1000) == 0x1000)) {
-				// Limit BulkOut size to about 4k bytes.
+				/* Limit BulkOut size to about 4k bytes. */
 				pHTTXContext->ENextBulkOutPosition =
 				    TmpBulkEndPos;
 				break;
@@ -297,21 +297,21 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 				     0))
 				/*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */
 				) {
-				// For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size.
-				// For performence in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04.
+				/* For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size. */
+				/* For performence in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04. */
 				pHTTXContext->ENextBulkOutPosition =
 				    TmpBulkEndPos;
 				break;
 			}
 		}
-		// end Iverson
+		/* end Iverson */
 		else {
-			if (((ThisBulkSize & 0xffff8000) != 0) || ((ThisBulkSize & 0x6000) == 0x6000)) {	// Limit BulkOut size to about 24k bytes.
+			if (((ThisBulkSize & 0xffff8000) != 0) || ((ThisBulkSize & 0x6000) == 0x6000)) {	/* Limit BulkOut size to about 24k bytes. */
 				pHTTXContext->ENextBulkOutPosition =
 				    TmpBulkEndPos;
 				break;
-			} else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize & 0xfffff800) != 0)) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */ ) {	// For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size.
-				// For performence in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04.
+			} else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize & 0xfffff800) != 0)) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */ ) {	/* For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size. */
+				/* For performence in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04. */
 				pHTTXContext->ENextBulkOutPosition =
 				    TmpBulkEndPos;
 				break;
@@ -368,10 +368,10 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 			pAd->BulkOutPending[BulkOutPipeId] = FALSE;
 			BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId],
 					IrqFlags);
-			//DBGPRINT(RT_DEBUG_LOUD,("Out:pTxInfo->USBDMATxPktLen=%d!\n", pTxInfo->USBDMATxPktLen));
+			/*DBGPRINT(RT_DEBUG_LOUD,("Out:pTxInfo->USBDMATxPktLen=%d!\n", pTxInfo->USBDMATxPktLen)); */
 			return;
 		}
-		// Increase Total transmit byte counter
+		/* Increase Total transmit byte counter */
 		pAd->RalinkCounters.OneSecTransmittedByteCount +=
 		    pTxWI->MPDUtotalByteCount;
 		pAd->RalinkCounters.TransmittedByteCount +=
@@ -379,7 +379,7 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 
 		pLastTxInfo = pTxInfo;
 
-		// Make sure we use EDCA QUEUE.
+		/* Make sure we use EDCA QUEUE. */
 		pTxInfo->QSEL = FIFO_EDCA;
 		ThisBulkSize += (pTxInfo->USBDMATxPktLen + 4);
 		TmpBulkEndPos += (pTxInfo->USBDMATxPktLen + 4);
@@ -400,7 +400,7 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 
 	} while (TRUE);
 
-	// adjust the pTxInfo->USBDMANextVLD value of last pTxInfo.
+	/* adjust the pTxInfo->USBDMANextVLD value of last pTxInfo. */
 	if (pLastTxInfo) {
 		pLastTxInfo->USBDMANextVLD = 0;
 	}
@@ -446,7 +446,7 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 				      pBuf[0], pBuf[1], pBuf[2], pBuf[3],
 				      pBuf[4], pBuf[5], pBuf[6], pBuf[7]));
 		}
-		//DBGPRINT(RT_DEBUG_LOUD,("ENPos==CWPos=%ld, CWRPos=%ld, bCSPad=%d!\n", pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->bCopySavePad));
+		/*DBGPRINT(RT_DEBUG_LOUD,("ENPos==CWPos=%ld, CWRPos=%ld, bCSPad=%d!\n", pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->bCopySavePad)); */
 	}
 
 	if (pAd->bForcePrintTX == TRUE)
@@ -456,9 +456,9 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 			  pHTTXContext->NextBulkOutPosition,
 			  pHTTXContext->ENextBulkOutPosition,
 			  pHTTXContext->bCopySavePad));
-	//DBGPRINT(RT_DEBUG_LOUD,("BulkOut-A:Size=%ld, CWPos=%ld, CWRPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d, bLRound=%d!\n", ThisBulkSize, pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad, bTxQLastRound));
+	/*DBGPRINT(RT_DEBUG_LOUD,("BulkOut-A:Size=%ld, CWPos=%ld, CWRPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d, bLRound=%d!\n", ThisBulkSize, pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad, bTxQLastRound)); */
 
-	// USB DMA engine requires to pad extra 4 bytes. This pad doesn't count into real bulkoutsize.
+	/* USB DMA engine requires to pad extra 4 bytes. This pad doesn't count into real bulkoutsize. */
 	pAppendant = &pWirelessPkt[TmpBulkEndPos];
 	NdisZeroMemory(pAppendant, 8);
 	ThisBulkSize += 4;
@@ -470,7 +470,7 @@ VOID RTUSBBulkOutDataPacket(IN PRTMP_ADA
 	pAd->watchDogTxPendingCnt[BulkOutPipeId] = 1;
 	BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
 
-	// Init Tx context descriptor
+	/* Init Tx context descriptor */
 	RTUSBInitHTTxDesc(pAd, pHTTXContext, BulkOutPipeId, ThisBulkSize,
 			  (usb_complete_t) RTUSBBulkOutDataPacketComplete);
 
@@ -506,7 +506,7 @@ VOID RTUSBBulkOutDataPacketComplete(purb
 	pAd = pHTTXContext->pAd;
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-	// Store BulkOut PipeId
+	/* Store BulkOut PipeId */
 	BulkOutPipeId = pHTTXContext->BulkOutPipeId;
 	pAd->BulkOutDataOneSecCount++;
 
@@ -562,13 +562,13 @@ VOID RTUSBBulkOutNullFrame(IN PRTMP_ADAP
 	pNullContext->IRPPending = TRUE;
 	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
 
-	// Increase Total transmit byte counter
+	/* Increase Total transmit byte counter */
 	pAd->RalinkCounters.TransmittedByteCount += pNullContext->BulkOutSize;
 
-	// Clear Null frame bulk flag
+	/* Clear Null frame bulk flag */
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
 
-	// Init Tx context descriptor
+	/* Init Tx context descriptor */
 	RTUSBInitTxDesc(pAd, pNullContext, 0,
 			(usb_complete_t) RTUSBBulkOutNullFrameComplete);
 
@@ -588,7 +588,7 @@ VOID RTUSBBulkOutNullFrame(IN PRTMP_ADAP
 
 }
 
-// NULL frame use BulkOutPipeId = 0
+/* NULL frame use BulkOutPipeId = 0 */
 VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb, struct pt_regs * pt_regs)
 {
 	PRTMP_ADAPTER pAd;
@@ -633,7 +633,7 @@ VOID RTUSBBulkOutMLMEPacket(IN PRTMP_ADA
 	    (pMLMEContext->InUse == FALSE) ||
 	    (pMLMEContext->bWaitingBulkOut == FALSE)) {
 
-		// Clear MLME bulk flag
+		/* Clear MLME bulk flag */
 		RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
 
 		return;
@@ -652,17 +652,17 @@ VOID RTUSBBulkOutMLMEPacket(IN PRTMP_ADA
 	pMLMEContext->bWaitingBulkOut = FALSE;
 	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
 
-	// Increase Total transmit byte counter
+	/* Increase Total transmit byte counter */
 	pAd->RalinkCounters.TransmittedByteCount += pMLMEContext->BulkOutSize;
 
-	// Clear MLME bulk flag
+	/* Clear MLME bulk flag */
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
 
-	// Init Tx context descriptor
+	/* Init Tx context descriptor */
 	RTUSBInitTxDesc(pAd, pMLMEContext, MGMTPIPEIDX,
 			(usb_complete_t) RTUSBBulkOutMLMEPacketComplete);
 
-	//For mgmt urb buffer, because we use sk_buff, so we need to notify the USB controller do dma mapping.
+	/*For mgmt urb buffer, because we use sk_buff, so we need to notify the USB controller do dma mapping. */
 	pUrb->transfer_dma = 0;
 	pUrb->transfer_flags &= (~URB_NO_TRANSFER_DMA_MAP);
 
@@ -680,8 +680,8 @@ VOID RTUSBBulkOutMLMEPacket(IN PRTMP_ADA
 
 		return;
 	}
-	//DBGPRINT_RAW(RT_DEBUG_INFO, ("<---RTUSBBulkOutMLMEPacket \n"));
-//      printk("<---RTUSBBulkOutMLMEPacket,Cpu=%d!, Dma=%d, SwIdx=%d!\n", pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx);
+	/*DBGPRINT_RAW(RT_DEBUG_INFO, ("<---RTUSBBulkOutMLMEPacket \n")); */
+/*      printk("<---RTUSBBulkOutMLMEPacket,Cpu=%d!, Dma=%d, SwIdx=%d!\n", pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx); */
 }
 
 VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb, struct pt_regs * pt_regs)
@@ -692,7 +692,7 @@ VOID RTUSBBulkOutMLMEPacketComplete(purb
 	POS_COOKIE pObj;
 	int index;
 
-	//DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutMLMEPacketComplete\n"));
+	/*DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutMLMEPacketComplete\n")); */
 	pMLMEContext = (PTX_CONTEXT) pUrb->context;
 	pAd = pMLMEContext->pAd;
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
@@ -734,10 +734,10 @@ VOID RTUSBBulkOutPsPoll(IN PRTMP_ADAPTER
 	pPsPollContext->IRPPending = TRUE;
 	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
 
-	// Clear PS-Poll bulk flag
+	/* Clear PS-Poll bulk flag */
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL);
 
-	// Init Tx context descriptor
+	/* Init Tx context descriptor */
 	RTUSBInitTxDesc(pAd, pPsPollContext, MGMTPIPEIDX,
 			(usb_complete_t) RTUSBBulkOutPsPollComplete);
 
@@ -757,7 +757,7 @@ VOID RTUSBBulkOutPsPoll(IN PRTMP_ADAPTER
 
 }
 
-// PS-Poll frame use BulkOutPipeId = 0
+/* PS-Poll frame use BulkOutPipeId = 0 */
 VOID RTUSBBulkOutPsPollComplete(purbb_t pUrb, struct pt_regs * pt_regs)
 {
 	PRTMP_ADAPTER pAd;
@@ -794,12 +794,12 @@ VOID DoBulkIn(IN RTMP_ADAPTER * pAd)
 	pAd->BulkInReq++;
 	RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 
-	// Init Rx context descriptor
+	/* Init Rx context descriptor */
 	NdisZeroMemory(pRxContext->TransferBuffer, pRxContext->BulkInOffset);
 	RTUSBInitRxDesc(pAd, pRxContext);
 
 	pUrb = pRxContext->pUrb;
-	if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {	// fail
+	if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {	/* fail */
 
 		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
 		pRxContext->InUse = FALSE;
@@ -809,9 +809,9 @@ VOID DoBulkIn(IN RTMP_ADAPTER * pAd)
 		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("RTUSBBulkReceive: Submit Rx URB failed %d\n", ret));
-	} else {		// success
+	} else {		/* success */
 		ASSERT((pRxContext->InUse == pRxContext->IRPPending));
-		//printk("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n", pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex);
+		/*printk("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n", pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex); */
 	}
 }
 
@@ -864,10 +864,10 @@ VOID RTUSBBulkReceive(IN PRTMP_ADAPTER p
 			pRxContext->bRxHandling = TRUE;
 			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 
-			// read RxContext, Since not
+			/* read RxContext, Since not */
 			STARxDoneInterruptHandle(pAd, TRUE);
 
-			// Finish to handle this bulkIn buffer.
+			/* Finish to handle this bulkIn buffer. */
 			RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
 			pRxContext->BulkInOffset = 0;
 			pRxContext->Readable = FALSE;
@@ -914,9 +914,9 @@ VOID RTUSBBulkReceive(IN PRTMP_ADAPTER p
 */
 VOID RTUSBBulkRxComplete(purbb_t pUrb, struct pt_regs *pt_regs)
 {
-	// use a receive tasklet to handle received packets;
-	// or sometimes hardware IRQ will be disabled here, so we can not
-	// use spin_lock_bh()/spin_unlock_bh() after IRQ is disabled. :<
+	/* use a receive tasklet to handle received packets; */
+	/* or sometimes hardware IRQ will be disabled here, so we can not */
+	/* use spin_lock_bh()/spin_unlock_bh() after IRQ is disabled. :< */
 	PRX_CONTEXT pRxContext;
 	PRTMP_ADAPTER pAd;
 	POS_COOKIE pObj;
@@ -945,19 +945,19 @@ VOID RTUSBBulkRxComplete(purbb_t pUrb, s
 */
 VOID RTUSBKickBulkOut(IN PRTMP_ADAPTER pAd)
 {
-	// BulkIn Reset will reset whole USB PHY. So we need to make sure fRTMP_ADAPTER_BULKIN_RESET not flaged.
+	/* BulkIn Reset will reset whole USB PHY. So we need to make sure fRTMP_ADAPTER_BULKIN_RESET not flaged. */
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)
 	    ) {
-		// 2. PS-Poll frame is next
+		/* 2. PS-Poll frame is next */
 		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL)) {
 			RTUSBBulkOutPsPoll(pAd);
 		}
-		// 5. Mlme frame is next
+		/* 5. Mlme frame is next */
 		else if ((RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME)) ||
 			 (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE)) {
 			RTUSBBulkOutMLMEPacket(pAd, pAd->MgmtRing.TxDmaIdx);
 		}
-		// 6. Data frame normal is next
+		/* 6. Data frame normal is next */
 		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL)) {
 			if (((!RTMP_TEST_FLAG
 			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
@@ -1006,14 +1006,14 @@ VOID RTUSBKickBulkOut(IN PRTMP_ADAPTER p
 						       NextBulkOutIndex[3]);
 			}
 		}
-		// 7. Null frame is the last
+		/* 7. Null frame is the last */
 		else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL)) {
 			if (!RTMP_TEST_FLAG
 			    (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
 				RTUSBBulkOutNullFrame(pAd);
 			}
 		}
-		// 8. No data avaliable
+		/* 8. No data avaliable */
 		else {
 
 		}
@@ -1116,8 +1116,8 @@ VOID RTUSBCancelPendingBulkInIRP(IN PRTM
 			RTUSB_UNLINK_URB(pRxContext->pUrb);
 			pRxContext->IRPPending = FALSE;
 			pRxContext->InUse = FALSE;
-			//NdisInterlockedDecrement(&pAd->PendingRx);
-			//pAd->PendingRx--;
+			/*NdisInterlockedDecrement(&pAd->PendingRx); */
+			/*pAd->PendingRx--; */
 		}
 	}
 	DBGPRINT_RAW(RT_DEBUG_TRACE, ("<---RTUSBCancelPendingBulkInIRP\n"));
@@ -1145,65 +1145,65 @@ VOID RTUSBCancelPendingBulkOutIRP(IN PRT
 	PTX_CONTEXT pPsPollContext;
 	PTX_CONTEXT pRTSContext;
 	UINT i, Idx;
-//      unsigned int            IrqFlags;
-//      NDIS_SPIN_LOCK          *pLock;
-//      BOOLEAN                         *pPending;
+/*      unsigned int            IrqFlags; */
+/*      NDIS_SPIN_LOCK          *pLock; */
+/*      BOOLEAN                         *pPending; */
 
-//      pLock = &pAd->BulkOutLock[MGMTPIPEIDX];
-//      pPending = &pAd->BulkOutPending[MGMTPIPEIDX];
+/*      pLock = &pAd->BulkOutLock[MGMTPIPEIDX]; */
+/*      pPending = &pAd->BulkOutPending[MGMTPIPEIDX]; */
 
 	for (Idx = 0; Idx < 4; Idx++) {
 		pHTTXContext = &(pAd->TxContext[Idx]);
 
 		if (pHTTXContext->IRPPending == TRUE) {
 
-			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
-			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
-			//      when the last IRP on the list has been  cancelled; that's how we exit this loop
-			//
+			/* Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself */
+			/* remove it from the HeadPendingSendList and NULL out HeadPendingSendList */
+			/*      when the last IRP on the list has been  cancelled; that's how we exit this loop */
+			/* */
 
 			RTUSB_UNLINK_URB(pHTTXContext->pUrb);
 
-			// Sleep 200 microseconds to give cancellation time to work
+			/* Sleep 200 microseconds to give cancellation time to work */
 			RTMPusecDelay(200);
 		}
 
 		pAd->BulkOutPending[Idx] = FALSE;
 	}
 
-	//RTMP_IRQ_LOCK(pLock, IrqFlags);
+	/*RTMP_IRQ_LOCK(pLock, IrqFlags); */
 	for (i = 0; i < MGMT_RING_SIZE; i++) {
 		pMLMEContext = (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
 		if (pMLMEContext && (pMLMEContext->IRPPending == TRUE)) {
 
-			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
-			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
-			//      when the last IRP on the list has been  cancelled; that's how we exit this loop
-			//
+			/* Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself */
+			/* remove it from the HeadPendingSendList and NULL out HeadPendingSendList */
+			/*      when the last IRP on the list has been  cancelled; that's how we exit this loop */
+			/* */
 
 			RTUSB_UNLINK_URB(pMLMEContext->pUrb);
 			pMLMEContext->IRPPending = FALSE;
 
-			// Sleep 200 microsecs to give cancellation time to work
+			/* Sleep 200 microsecs to give cancellation time to work */
 			RTMPusecDelay(200);
 		}
 	}
 	pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
-	//RTMP_IRQ_UNLOCK(pLock, IrqFlags);
+	/*RTMP_IRQ_UNLOCK(pLock, IrqFlags); */
 
 	for (i = 0; i < BEACON_RING_SIZE; i++) {
 		pBeaconContext = &(pAd->BeaconContext[i]);
 
 		if (pBeaconContext->IRPPending == TRUE) {
 
-			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
-			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
-			//      when the last IRP on the list has been  cancelled; that's how we exit this loop
-			//
+			/* Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself */
+			/* remove it from the HeadPendingSendList and NULL out HeadPendingSendList */
+			/*      when the last IRP on the list has been  cancelled; that's how we exit this loop */
+			/* */
 
 			RTUSB_UNLINK_URB(pBeaconContext->pUrb);
 
-			// Sleep 200 microsecs to give cancellation time to work
+			/* Sleep 200 microsecs to give cancellation time to work */
 			RTMPusecDelay(200);
 		}
 	}
@@ -1227,4 +1227,4 @@ VOID RTUSBCancelPendingBulkOutIRP(IN PRT
 	}
 }
 
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
--- a/drivers/staging/rt2870/common/rtusb_data.c
+++ b/drivers/staging/rt2870/common/rtusb_data.c
@@ -41,7 +41,7 @@
 
 #include "../rt_config.h"
 
-extern UCHAR Phy11BGNextRateUpward[];	// defined in mlme.c
+extern UCHAR Phy11BGNextRateUpward[];	/* defined in mlme.c */
 extern UCHAR EpToQueue[];
 
 VOID REPORT_AMSDU_FRAMES_TO_LLC(IN PRTMP_ADAPTER pAd,
@@ -89,8 +89,8 @@ NDIS_STATUS RTUSBFreeDescriptorRequest(I
 				       IN UCHAR BulkOutPipeId,
 				       IN UINT32 NumberRequired)
 {
-//      UCHAR                   FreeNumber = 0;
-//      UINT                    Index;
+/*      UCHAR                   FreeNumber = 0; */
+/*      UINT                    Index; */
 	NDIS_STATUS Status = NDIS_STATUS_FAILURE;
 	unsigned long IrqFlags;
 	HT_TX_CONTEXT *pHTTXContext;
@@ -251,7 +251,7 @@ VOID RTMPWriteTxInfo(IN PRTMP_ADAPTER pA
 	if (QueueSel != FIFO_EDCA)
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("====> QueueSel != FIFO_EDCA<============\n"));
-	pTxInfo->USBDMANextVLD = FALSE;	//NextValid;  // Need to check with Jan about this.
+	pTxInfo->USBDMANextVLD = FALSE;	/*NextValid;  // Need to check with Jan about this. */
 	pTxInfo->USBDMATxburst = TxBurst;
 	pTxInfo->WIV = bWiv;
 	pTxInfo->SwUseLastRound = 0;
@@ -259,4 +259,4 @@ VOID RTMPWriteTxInfo(IN PRTMP_ADAPTER pA
 	pTxInfo->rsv2 = 0;
 }
 
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
--- a/drivers/staging/rt2870/common/rtusb_io.c
+++ b/drivers/staging/rt2870/common/rtusb_io.c
@@ -88,7 +88,7 @@ NTSTATUS RTUSBFirmwareWrite(IN PRTMP_ADA
 {
 	UINT32 MacReg;
 	NTSTATUS Status;
-//      ULONG           i;
+/*      ULONG           i; */
 	USHORT writeLen;
 
 	Status = RTUSBReadMACRegister(pAd, MAC_CSR0, &MacReg);
@@ -100,11 +100,11 @@ NTSTATUS RTUSBFirmwareWrite(IN PRTMP_ADA
 	Status = RTUSBWriteMACRegister(pAd, 0x701c, 0xffffffff);
 	Status = RTUSBFirmwareRun(pAd);
 
-	//2008/11/28:KH add to fix the dead rf frequency offset bug<--
+	/*2008/11/28:KH add to fix the dead rf frequency offset bug<-- */
 	RTMPusecDelay(10000);
 	RTUSBWriteMACRegister(pAd, H2M_MAILBOX_CSR, 0);
-	AsicSendCommandToMcu(pAd, 0x72, 0x00, 0x00, 0x00);	//reset rf by MCU supported by new firmware
-	//2008/11/28:KH add to fix the dead rf frequency offset bug-->
+	AsicSendCommandToMcu(pAd, 0x72, 0x00, 0x00, 0x00);	/*reset rf by MCU supported by new firmware */
+	/*2008/11/28:KH add to fix the dead rf frequency offset bug--> */
 
 	return Status;
 }
@@ -171,7 +171,7 @@ NTSTATUS RTUSBMultiWrite_OneByte(IN PRTM
 {
 	NTSTATUS Status;
 
-	// TODO: In 2870, use this funciton carefully cause it's not stable.
+	/* TODO: In 2870, use this funciton carefully cause it's not stable. */
 	Status = RTUSB_VendorRequest(pAd,
 				     USBD_TRANSFER_DIRECTION_OUT,
 				     DEVICE_VENDOR_REQUEST_OUT,
@@ -304,7 +304,7 @@ NTSTATUS RTUSBReadBBPRegister(IN PRTMP_A
 	UINT i = 0;
 	NTSTATUS status;
 
-	// Verify the busy condition
+	/* Verify the busy condition */
 	do {
 		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
 		if (status >= 0) {
@@ -320,16 +320,16 @@ NTSTATUS RTUSBReadBBPRegister(IN PRTMP_A
 
 	if ((i == RETRY_LIMIT)
 	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-		//
-		// Read failed then Return Default value.
-		//
+		/* */
+		/* Read failed then Return Default value. */
+		/* */
 		*pValue = pAd->BbpWriteLatch[Id];
 
 		DBGPRINT_RAW(RT_DEBUG_ERROR,
 			     ("Retry count exhausted or device removed!!!\n"));
 		return STATUS_UNSUCCESSFUL;
 	}
-	// Prepare for write material
+	/* Prepare for write material */
 	BbpCsr.word = 0;
 	BbpCsr.field.fRead = 1;
 	BbpCsr.field.Busy = 1;
@@ -337,7 +337,7 @@ NTSTATUS RTUSBReadBBPRegister(IN PRTMP_A
 	RTUSBWriteMACRegister(pAd, BBP_CSR_CFG, BbpCsr.word);
 
 	i = 0;
-	// Verify the busy condition
+	/* Verify the busy condition */
 	do {
 		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
 		if (status >= 0) {
@@ -355,9 +355,9 @@ NTSTATUS RTUSBReadBBPRegister(IN PRTMP_A
 
 	if ((i == RETRY_LIMIT)
 	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
-		//
-		// Read failed then Return Default value.
-		//
+		/* */
+		/* Read failed then Return Default value. */
+		/* */
 		*pValue = pAd->BbpWriteLatch[Id];
 
 		DBGPRINT_RAW(RT_DEBUG_ERROR,
@@ -389,7 +389,7 @@ NTSTATUS RTUSBWriteBBPRegister(IN PRTMP_
 	BBP_CSR_CFG_STRUC BbpCsr;
 	UINT i = 0;
 	NTSTATUS status;
-	// Verify the busy condition
+	/* Verify the busy condition */
 	do {
 		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
 		if (status >= 0) {
@@ -410,7 +410,7 @@ NTSTATUS RTUSBWriteBBPRegister(IN PRTMP_
 			     ("Retry count exhausted or device removed!!!\n"));
 		return STATUS_UNSUCCESSFUL;
 	}
-	// Prepare for write material
+	/* Prepare for write material */
 	BbpCsr.word = 0;
 	BbpCsr.field.fRead = 0;
 	BbpCsr.field.Value = Value;
@@ -561,11 +561,11 @@ VOID RTUSBPutToSleep(IN PRTMP_ADAPTER pA
 {
 	UINT32 value;
 
-	// Timeout 0x40 x 50us
+	/* Timeout 0x40 x 50us */
 	value = (SLEEPCID << 16) + (OWNERMCU << 24) + (0x40 << 8) + 1;
 	RTUSBWriteMACRegister(pAd, 0x7010, value);
 	RTUSBWriteMACRegister(pAd, 0x404, 0x30);
-	//RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
+	/*RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS); */
 	DBGPRINT_RAW(RT_DEBUG_ERROR, ("Sleep Mailbox testvalue %x\n", value));
 
 }
@@ -959,7 +959,7 @@ NTSTATUS RTUSB_ResetDevice(IN PRTMP_ADAP
 	NTSTATUS Status = TRUE;
 
 	DBGPRINT_RAW(RT_DEBUG_TRACE, ("--->USB_ResetDevice\n"));
-	//RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+	/*RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS); */
 	return Status;
 }
 
@@ -968,9 +968,9 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 	PCmdQElmt cmdqelmt;
 	PUCHAR pData;
 	NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
-//      ULONG                   Now = 0;
+/*      ULONG                   Now = 0; */
 	NTSTATUS ntStatus;
-//      unsigned long   IrqFlags;
+/*      unsigned long   IrqFlags; */
 
 	while (pAd && pAd->CmdQ.size > 0) {
 		NdisStatus = NDIS_STATUS_SUCCESS;
@@ -993,7 +993,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 					UINT32 data;
 
 					{
-						// Read GPIO pin2 as Hardware controlled radio state
+						/* Read GPIO pin2 as Hardware controlled radio state */
 
 						RTUSBReadMACRegister(pAd,
 								     GPIO_CTRL_CFG,
@@ -1023,7 +1023,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 
 								MlmeRadioOn
 								    (pAd);
-								// Update extra information
+								/* Update extra information */
 								pAd->ExtraInfo =
 								    EXTRA_INFO_CLEAR;
 							} else {
@@ -1033,7 +1033,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 
 								MlmeRadioOff
 								    (pAd);
-								// Update extra information
+								/* Update extra information */
 								pAd->ExtraInfo =
 								    HW_RADIO_OFF;
 							}
@@ -1056,15 +1056,15 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 					UCHAR Index;
 					int ret = 0;
 					PHT_TX_CONTEXT pHTTXContext;
-//                                              RTMP_TX_RING *pTxRing;
+/*                                              RTMP_TX_RING *pTxRing; */
 					unsigned long IrqFlags;
 
 					DBGPRINT_RAW(RT_DEBUG_TRACE,
 						     ("CmdThread : CMDTHREAD_RESET_BULK_OUT(ResetPipeid=0x%0x)===>\n",
 						      pAd->bulkResetPipeid));
-					// All transfers must be aborted or cancelled before attempting to reset the pipe.
-					//RTUSBCancelPendingBulkOutIRP(pAd);
-					// Wait 10ms to let previous packet that are already in HW FIFO to clear. by MAXLEE 12-25-2007
+					/* All transfers must be aborted or cancelled before attempting to reset the pipe. */
+					/*RTUSBCancelPendingBulkOutIRP(pAd); */
+					/* Wait 10ms to let previous packet that are already in HW FIFO to clear. by MAXLEE 12-25-2007 */
 					Index = 0;
 					do {
 						RTUSBReadMACRegister(pAd,
@@ -1079,12 +1079,12 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 					MACValue = 0;
 					RTUSBReadMACRegister(pAd, USB_DMA_CFG,
 							     &MACValue);
-					// To prevent Read Register error, we 2nd check the validity.
+					/* To prevent Read Register error, we 2nd check the validity. */
 					if ((MACValue & 0xc00000) == 0)
 						RTUSBReadMACRegister(pAd,
 								     USB_DMA_CFG,
 								     &MACValue);
-					// To prevent Read Register error, we 3rd check the validity.
+					/* To prevent Read Register error, we 3rd check the validity. */
 					if ((MACValue & 0xc00000) == 0)
 						RTUSBReadMACRegister(pAd,
 								     USB_DMA_CFG,
@@ -1093,7 +1093,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 					RTUSBWriteMACRegister(pAd, USB_DMA_CFG,
 							      MACValue);
 
-					// Wait 1ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007
+					/* Wait 1ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007 */
 					RTMPusecDelay(1000);
 
 					MACValue &= (~0x80000);
@@ -1102,8 +1102,8 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 					DBGPRINT_RAW(RT_DEBUG_TRACE,
 						     ("\tSet 0x2a0 bit19. Clear USB DMA TX path\n"));
 
-					// Wait 5ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007
-					//RTMPusecDelay(5000);
+					/* Wait 5ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007 */
+					/*RTMPusecDelay(5000); */
 
 					if ((pAd->
 					     bulkResetPipeid &
@@ -1127,7 +1127,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						    &(pAd->
 						      TxContext[pAd->
 								bulkResetPipeid]);
-						//NdisAcquireSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
+						/*NdisAcquireSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]); */
 						RTMP_INT_LOCK(&pAd->
 							      BulkOutLock[pAd->
 									  bulkResetPipeid],
@@ -1148,11 +1148,11 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 							     bulkResetPipeid] =
 							    1;
 
-							// no matter what, clean the flag
+							/* no matter what, clean the flag */
 							RTMP_CLEAR_FLAG(pAd,
 									fRTMP_ADAPTER_BULKOUT_RESET);
 
-							//NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
+							/*NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]); */
 							RTMP_INT_UNLOCK(&pAd->
 									BulkOutLock
 									[pAd->
@@ -1259,8 +1259,8 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 								}
 							}
 						} else {
-							//NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
-							//RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+							/*NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]); */
+							/*RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags); */
 
 							DBGPRINT_RAW
 							    (RT_DEBUG_ERROR,
@@ -1338,7 +1338,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 								     ("\tTX Occupied by %d!\n",
 								      pendingContext));
 							}
-							// no matter what, clean the flag
+							/* no matter what, clean the flag */
 							RTMP_CLEAR_FLAG(pAd,
 									fRTMP_ADAPTER_BULKOUT_RESET);
 
@@ -1358,7 +1358,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						RTMPDeQueuePacket(pAd, FALSE,
 								  NUM_OF_TX_RING,
 								  MAX_TX_PROCESS);
-						//RTUSBKickBulkOut(pAd);
+						/*RTUSBKickBulkOut(pAd); */
 					}
 
 				}
@@ -1403,12 +1403,12 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 				DBGPRINT_RAW(RT_DEBUG_TRACE,
 					     ("CmdThread : CMDTHREAD_RESET_BULK_IN === >\n"));
 
-				// All transfers must be aborted or cancelled before attempting to reset the pipe.
+				/* All transfers must be aborted or cancelled before attempting to reset the pipe. */
 				{
 					UINT32 MACValue;
 
 					{
-						//while ((atomic_read(&pAd->PendingRx) > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+						/*while ((atomic_read(&pAd->PendingRx) > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) */
 						if ((pAd->PendingRx > 0)
 						    &&
 						    (!RTMP_TEST_FLAG
@@ -1425,7 +1425,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						}
 					}
 
-					// Wait 10ms before reading register.
+					/* Wait 10ms before reading register. */
 					RTMPusecDelay(10000);
 					ntStatus =
 					    RTUSBReadMACRegister(pAd, MAC_CSR0,
@@ -1505,7 +1505,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						     i <
 						     pAd->CommonCfg.
 						     NumOfBulkInIRP; i++) {
-							//RTUSBBulkReceive(pAd);
+							/*RTUSBBulkReceive(pAd); */
 							PRX_CONTEXT pRxContext;
 							PURB pUrb;
 							int ret = 0;
@@ -1541,11 +1541,11 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 									BulkInLock,
 									IrqFlags);
 
-							// Init Rx context descriptor
+							/* Init Rx context descriptor */
 							RTUSBInitRxDesc(pAd,
 									pRxContext);
 							pUrb = pRxContext->pUrb;
-							if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {	// fail
+							if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {	/* fail */
 
 								RTMP_IRQ_LOCK
 								    (&pAd->
@@ -1571,9 +1571,9 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 								      ret,
 								      pUrb->
 								      status));
-							} else {	// success
-								//DBGPRINT(RT_DEBUG_TRACE, ("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n",
-								//                                                      pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex));
+							} else {	/* success */
+								/*DBGPRINT(RT_DEBUG_TRACE, ("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n", */
+								/*                                                      pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex)); */
 								DBGPRINT_RAW
 								    (RT_DEBUG_TRACE,
 								     ("CMDTHREAD_RESET_BULK_IN: Submit Rx URB Done, status=%d!\n",
@@ -1584,7 +1584,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						}
 
 					} else {
-						// Card must be removed
+						/* Card must be removed */
 						if (NT_SUCCESS(ntStatus) !=
 						    TRUE) {
 							RTMP_SET_FLAG(pAd,
@@ -1643,7 +1643,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						      MACValue));
 					RTUSBWriteMACRegister(pAd, offset,
 							      MACValue);
-					// Read bitmask
+					/* Read bitmask */
 					RTUSBReadMACRegister(pAd, offset + 4,
 							     &MACRValue);
 					if (SetAsicWcid.DeleteTid != 0xffffffff)
@@ -1693,7 +1693,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						     ("Cmd : CMDTHREAD_SET_ASIC_WCID_CIPHER : WCID = %ld, Cipher = %lx.\n",
 						      SetAsicWcidAttri.WCID,
 						      SetAsicWcidAttri.Cipher));
-					// Read bitmask
+					/* Read bitmask */
 					RTUSBReadMACRegister(pAd, offset,
 							     &MACRValue);
 					MACRValue = 0;
@@ -1725,10 +1725,10 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						     ("2-offset = %x , MACValue= %x,\n",
 						      offset, MACRValue));
 
-					//
-					// Update cipher algorithm. WSTA always use BSS0
-					//
-					// for adhoc mode only ,because wep status slow than add key, when use zero config
+					/* */
+					/* Update cipher algorithm. WSTA always use BSS0 */
+					/* */
+					/* for adhoc mode only ,because wep status slow than add key, when use zero config */
 					if (pAd->StaCfg.BssType == BSS_ADHOC) {
 						offset =
 						    MAC_WCID_ATTRIBUTE_BASE;
@@ -1745,7 +1745,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 								      offset,
 								      MACRValue);
 
-						//Update group key cipher,,because wep status slow than add key, when use zero config
+						/*Update group key cipher,,because wep status slow than add key, when use zero config */
 						RTUSBReadMACRegister(pAd,
 								     SHARED_KEY_MODE_BASE
 								     +
@@ -1770,8 +1770,8 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 				}
 				break;
 
-//Benson modified for USB interface, avoid in interrupt when write key, 20080724 -->
-			case RT_CMD_SET_KEY_TABLE:	//General call for AsicAddPairwiseKeyEntry()
+/*Benson modified for USB interface, avoid in interrupt when write key, 20080724 --> */
+			case RT_CMD_SET_KEY_TABLE:	/*General call for AsicAddPairwiseKeyEntry() */
 				{
 					RT_ADD_PAIRWISE_KEY_ENTRY KeyInfo;
 					KeyInfo =
@@ -1786,7 +1786,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 				}
 				break;
 
-			case RT_CMD_SET_RX_WCID_TABLE:	//General call for RTMPAddWcidAttributeEntry()
+			case RT_CMD_SET_RX_WCID_TABLE:	/*General call for RTMPAddWcidAttributeEntry() */
 				{
 					PMAC_TABLE_ENTRY pEntry;
 					UCHAR KeyIdx = 0;
@@ -1802,7 +1802,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 								  pEntry);
 				}
 				break;
-//Benson modified for USB interface, avoid in interrupt when write key, 20080724 <--
+/*Benson modified for USB interface, avoid in interrupt when write key, 20080724 <-- */
 
 			case CMDTHREAD_SET_CLIENT_MAC_ENTRY:
 				{
@@ -1865,17 +1865,17 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 							      DefaultKeyId].
 							     CipherAlg, FALSE);
 						} else {
-							//
-							// Other case, disable engine.
-							// Don't worry WPA key, we will add WPA Key after 4-Way handshaking.
-							//
+							/* */
+							/* Other case, disable engine. */
+							/* Don't worry WPA key, we will add WPA Key after 4-Way handshaking. */
+							/* */
 							USHORT offset;
 							offset =
 							    MAC_WCID_ATTRIBUTE_BASE
 							    +
 							    (pEntry->Aid *
 							     HW_WCID_ATTRI_SIZE);
-							// RX_PKEY_MODE:0 for no security; RX_KEY_TAB:0 for shared key table; BSS_IDX:0
+							/* RX_PKEY_MODE:0 for no security; RX_KEY_TAB:0 for shared key table; BSS_IDX:0 */
 							RTUSBWriteMACRegister
 							    (pAd, offset, 0);
 						}
@@ -1894,7 +1894,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 				}
 				break;
 
-// add by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet
+/* add by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet */
 			case CMDTHREAD_UPDATE_PROTECT:
 				{
 					AsicUpdateProtect(pAd, 0,
@@ -1902,7 +1902,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 							  TRUE, 0);
 				}
 				break;
-// end johnli
+/* end johnli */
 
 			case OID_802_11_ADD_WEP:
 				{
@@ -1916,7 +1916,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 					pWepKey = (PNDIS_802_11_WEP) pData;
 					KeyIdx = pWepKey->KeyIndex & 0x0fffffff;
 
-					// it is a shared key
+					/* it is a shared key */
 					if ((KeyIdx >= 4)
 					    || ((pWepKey->KeyLength != 5)
 						&& (pWepKey->KeyLength !=
@@ -1944,10 +1944,10 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						     5) ? CIPHER_WEP64 :
 						    CIPHER_WEP128;
 
-						//
-						// Change the WEP cipher to CKIP cipher if CKIP KP on.
-						// Funk UI or Meetinghouse UI will add ckip key from this path.
-						//
+						/* */
+						/* Change the WEP cipher to CKIP cipher if CKIP KP on. */
+						/* Funk UI or Meetinghouse UI will add ckip key from this path. */
+						/* */
 
 						if (pAd->OpMode == OPMODE_STA) {
 							pAd->MacTab.
@@ -1968,7 +1968,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 						    CipherAlg = CipherAlg;
 						if (pWepKey->
 						    KeyIndex & 0x80000000) {
-							// Default key for tx (shared key)
+							/* Default key for tx (shared key) */
 							UCHAR IVEIV[8];
 							UINT32 WCIDAttri, Value;
 							USHORT offset, offset2;
@@ -1977,8 +1977,8 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 							pAd->StaCfg.
 							    DefaultKeyId =
 							    (UCHAR) KeyIdx;
-							// Add BSSID to WCTable. because this is Tx wep key.
-							// WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:1=PAIRWISE KEY, BSSIdx is 0
+							/* Add BSSID to WCTable. because this is Tx wep key. */
+							/* WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:1=PAIRWISE KEY, BSSIdx is 0 */
 							WCIDAttri =
 							    (CipherAlg << 1) |
 							    SHAREDKEYTABLE;
@@ -1991,9 +1991,9 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 							RTUSBWriteMACRegister
 							    (pAd, offset,
 							     WCIDAttri);
-							// 1. IV/EIV
-							// Specify key index to find shared key.
-							IVEIV[3] = (UCHAR) (KeyIdx << 6);	//WEP Eiv bit off. groupkey index is not 0
+							/* 1. IV/EIV */
+							/* Specify key index to find shared key. */
+							IVEIV[3] = (UCHAR) (KeyIdx << 6);	/*WEP Eiv bit off. groupkey index is not 0 */
 							offset =
 							    PAIRWISE_IVEIV_TABLE_BASE
 							    +
@@ -2030,7 +2030,7 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 								i += 4;
 							}
 
-							// 2. WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:use share key, BSSIdx is 0
+							/* 2. WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:use share key, BSSIdx is 0 */
 							WCIDAttri =
 							    (pAd->
 							     SharedKey[BSS0]
@@ -2109,4 +2109,4 @@ VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 	}			/* end of while */
 }
 
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
