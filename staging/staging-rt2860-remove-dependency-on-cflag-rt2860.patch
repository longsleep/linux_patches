From mark.einon@gmail.com  Tue Mar 17 15:59:03 2009
From: Mark Einon <mark.einon@gmail.com>
Date: Fri, 13 Mar 2009 23:28:15 +0000
Subject: Staging: rt2860: Remove dependency on CFLAG RT2860
To: gregkh@suse.de
Message-ID: <20090313232815.GA4836@EeeFedora10>
Content-Disposition: inline


From: Mark Einon <mark.einon@gmail.com>

Removed the CFLAG RT2860 from Makefile and dependency on it in the driver code.

Signed-off-by: Mark Einon <mark.einon@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---

 drivers/staging/rt2860/Makefile           |    1 
 drivers/staging/rt2860/common/cmm_data.c  |   23 -------------
 drivers/staging/rt2860/common/cmm_info.c  |    6 ---
 drivers/staging/rt2860/common/mlme.c      |   51 +-----------------------------
 drivers/staging/rt2860/common/rtmp_init.c |   29 -----------------
 drivers/staging/rt2860/config.mk          |    4 --
 drivers/staging/rt2860/rt28xx.h           |    4 --
 drivers/staging/rt2860/rt_ate.c           |   18 ----------
 drivers/staging/rt2860/rt_ate.h           |    6 ---
 drivers/staging/rt2860/rt_config.h        |    2 -
 drivers/staging/rt2860/rt_linux.c         |    4 --
 drivers/staging/rt2860/rt_linux.h         |   16 ---------
 drivers/staging/rt2860/rt_main_dev.c      |   12 -------
 drivers/staging/rt2860/rtmp.h             |   24 --------------
 drivers/staging/rt2860/rtmp_def.h         |    2 -
 drivers/staging/rt2860/sta/connect.c      |   12 -------
 drivers/staging/rt2860/sta/dls.c          |    4 --
 drivers/staging/rt2860/sta/rtmp_data.c    |    6 ---
 drivers/staging/rt2860/sta/sync.c         |   10 -----
 drivers/staging/rt2860/sta_ioctl.c        |    4 --
 20 files changed, 5 insertions(+), 233 deletions(-)

--- a/drivers/staging/rt2860/common/cmm_data.c
+++ b/drivers/staging/rt2860/common/cmm_data.c
@@ -105,9 +105,7 @@ NDIS_STATUS MiniportMMRequest(
 	PNDIS_PACKET	pPacket;
 	NDIS_STATUS  	Status = NDIS_STATUS_SUCCESS;
 	ULONG	 		FreeNum;
-#ifdef RT2860
 	unsigned long	IrqFlags = 0;
-#endif // RT2860 //
 	UCHAR			IrqState;
 	UCHAR			rtmpHwHdr[TXINFO_SIZE + TXWI_SIZE]; //RTMP_HW_HDR_LEN];
 
@@ -118,10 +116,9 @@ NDIS_STATUS MiniportMMRequest(
 	// 2860C use Tx Ring
 
 	IrqState = pAd->irq_disabled;
-#ifdef RT2860
+
 	if ((pAd->MACVersion == 0x28600100) && (!IrqState))
 		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-#endif // RT2860 //
 
 	do
 	{
@@ -175,17 +172,14 @@ NDIS_STATUS MiniportMMRequest(
 
 	} while (FALSE);
 
-#ifdef RT2860
 	// 2860C use Tx Ring
 	if ((pAd->MACVersion == 0x28600100) && (!IrqState))
 		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-#endif // RT2860 //
 
 	return Status;
 }
 
 
-#ifdef RT2860
 NDIS_STATUS MiniportMMRequestUnlock(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	UCHAR			QueIdx,
@@ -253,7 +247,6 @@ NDIS_STATUS MiniportMMRequestUnlock(
 
 	return Status;
 }
-#endif // RT2860 //
 
 
 /*
@@ -290,17 +283,14 @@ NDIS_STATUS MlmeHardTransmit(
 		return NDIS_STATUS_FAILURE;
 	}
 
-#ifdef RT2860
 	if ( pAd->MACVersion == 0x28600100 )
 		return MlmeHardTransmitTxRing(pAd,QueIdx,pPacket);
 	else
-#endif // RT2860 //
 		return MlmeHardTransmitMgmtRing(pAd,QueIdx,pPacket);
 
 }
 
 
-#ifdef RT2860
 NDIS_STATUS MlmeHardTransmitTxRing(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	UCHAR	QueIdx,
@@ -509,7 +499,6 @@ NDIS_STATUS MlmeHardTransmitTxRing(
 
 	return NDIS_STATUS_SUCCESS;
 }
-#endif // RT2860 //
 
 
 NDIS_STATUS MlmeHardTransmitMgmtRing(
@@ -1076,7 +1065,6 @@ VOID RTMPDeQueuePacket(
 				break;
 			}
 
-#ifdef RT2860
 			FreeNumber[QueIdx] = GET_TXRING_FREENO(pAd, QueIdx);
 
 #ifdef DBG_DIAGNOSE
@@ -1101,7 +1089,6 @@ VOID RTMPDeQueuePacket(
 				RTMPFreeTXDUponTxDmaDone(pAd, QueIdx);
 				FreeNumber[QueIdx] = GET_TXRING_FREENO(pAd, QueIdx);
 			}
-#endif // RT2860 //
 
 			// probe the Queue Head
 			pQueue = &pAd->TxSwQueue[QueIdx];
@@ -1180,12 +1167,10 @@ VOID RTMPDeQueuePacket(
 				Status = STAHardTransmit(pAd, pTxBlk, QueIdx);
 #endif // CONFIG_STA_SUPPORT //
 
-#ifdef RT2860
 			DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
 			// static rate also need NICUpdateFifoStaCounters() function.
 			//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
 				NICUpdateFifoStaCounters(pAd);
-#endif // RT2860 //
 		}
 
 		RT28XX_STOP_DEQUEUE(pAd, QueIdx, IrqFlags);
@@ -1764,7 +1749,6 @@ PQUEUE_HEADER	RTMPCheckTxSwQueue(
 }
 
 
-#ifdef RT2860
 BOOLEAN  RTMPFreeTXDUponTxDmaDone(
 	IN PRTMP_ADAPTER	pAd,
 	IN UCHAR			QueIdx)
@@ -2309,7 +2293,6 @@ VOID DBGPRINT_RX_RING(
 	DBGPRINT_RAW(RT_DEBUG_TRACE,(" 	RxSwReadIdx [%d]=", AC0freeIdx));
 	DBGPRINT_RAW(RT_DEBUG_TRACE,("	pending-NDIS=%ld\n", pAd->RalinkCounters.PendingNdisPacketCount));
 }
-#endif // RT2860 //
 
 /*
 	========================================================================
@@ -2634,9 +2617,7 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(
 					pEntry->AuthMode = pAd->StaCfg.AuthMode;
 					pEntry->WepStatus = pAd->StaCfg.WepStatus;
 					pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
-#ifdef RT2860
 					AsicRemovePairwiseKeyEntry(pAd, pEntry->apidx, (UCHAR)i);
-#endif // RT2860 //
 				}
 #endif // CONFIG_STA_SUPPORT //
 			}
@@ -2823,9 +2804,7 @@ VOID MacTableReset(
 
 	for (i=1; i<MAX_LEN_OF_MAC_TABLE; i++)
 	{
-#ifdef RT2860
 		RT28XX_STA_ENTRY_MAC_RESET(pAd, i);
-#endif // RT2860 //
 		if (pAd->MacTab.Content[i].ValidAsCLI == TRUE)
 	   {
 
--- a/drivers/staging/rt2860/common/cmm_info.c
+++ b/drivers/staging/rt2860/common/cmm_info.c
@@ -814,7 +814,6 @@ INT	Show_DescInfo_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			arg)
 {
-#ifdef RT2860
 	INT i, QueIdx=0;
 	PRT28XX_RXD_STRUC pRxD;
     PTXD_STRUC pTxD;
@@ -845,7 +844,6 @@ INT	Show_DescInfo_Proc(
 	    hex_dump("Rx Descriptor", (char *)pRxD, 16);
 		printk("pRxD->DDONE = %x\n", pRxD->DDONE);
 	}
-#endif // RT2860 //
 
 	return TRUE;
 }
@@ -1803,9 +1801,7 @@ VOID	RTMPAddWcidAttributeEntry(
 	}
 
 	// For key index and ext IV bit, so only need to update the position(offset+3).
-#ifdef RT2860
 	RTMP_IO_WRITE8(pAd, offset+3, IVEIV);
-#endif // RT2860 //
 
 	DBGPRINT(RT_DEBUG_TRACE,("RTMPAddWcidAttributeEntry: WCID #%d, KeyIndex #%d, Alg=%s\n",Wcid, KeyIdx, CipherName[CipherAlg]));
 	DBGPRINT(RT_DEBUG_TRACE,("	WCIDAttri = 0x%x \n",  WCIDAttri));
@@ -2827,9 +2823,7 @@ INT	Set_OpMode_Proc(
 
 	Value = simple_strtol(arg, 0, 10);
 
-#ifdef RT2860
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-#endif // RT2860 //
 	{
 		DBGPRINT(RT_DEBUG_ERROR, ("Can not switch operate mode on interface up !! \n"));
 		return FALSE;
--- a/drivers/staging/rt2860/common/mlme.c
+++ b/drivers/staging/rt2860/common/mlme.c
@@ -527,7 +527,6 @@ NDIS_STATUS MlmeInit(
 
 
 #ifdef CONFIG_STA_SUPPORT
-#ifdef RT2860
 		IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
 		{
 	        if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE))
@@ -537,7 +536,6 @@ NDIS_STATUS MlmeInit(
 	    		RTMPInitTimer(pAd, &pAd->Mlme.RadioOnOffTimer, GET_TIMER_FUNCTION(RadioOnExec), pAd, FALSE);
 	        }
 		}
-#endif // RT2860 //
 #endif // CONFIG_STA_SUPPORT //
 
 	} while (FALSE);
@@ -711,13 +709,11 @@ VOID MlmeHalt(
 		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,		&Cancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,		&Cancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,		&Cancelled);
-#ifdef RT2860
 	    if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE))
 	    {
 	   	    RTMPCancelTimer(&pAd->Mlme.PsPollTimer,		&Cancelled);
 		    RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer,		&Cancelled);
 		}
-#endif // RT2860 //
 
 #ifdef QOS_DLS_SUPPORT
 		for (i=0; i<MAX_NUM_OF_DLS_ENTRY; i++)
@@ -822,7 +818,6 @@ VOID MlmePeriodicExec(
 	}
 
 #ifdef CONFIG_STA_SUPPORT
-#ifdef RT2860
 	IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
 	{
 	    // If Hardware controlled Radio enabled, we have to check GPIO pin2 every 2 second.
@@ -863,7 +858,6 @@ VOID MlmePeriodicExec(
 			}
 		}
 	}
-#endif // RT2860 //
 #endif // CONFIG_STA_SUPPORT //
 
 	// Do nothing if the driver is starting halt state.
@@ -1075,9 +1069,7 @@ VOID MlmePeriodicExec(
 #ifdef CONFIG_STA_SUPPORT
 		IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
 		{
-#ifdef RT2860
 			if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) && (pAd->bPCIclkOff == FALSE))
-#endif // RT2860 //
 			{
 				// When Adhoc beacon is enabled and RTS/CTS is enabled, there is a chance that hardware MAC FSM will run into a deadlock
 				// and sending CTS-to-self over and over.
@@ -5036,16 +5028,13 @@ BOOLEAN MlmeDequeue(
 VOID	MlmeRestartStateMachine(
 	IN	PRTMP_ADAPTER	pAd)
 {
-#ifdef RT2860
 	MLME_QUEUE_ELEM		*Elem = NULL;
-#endif // RT2860 //
 #ifdef CONFIG_STA_SUPPORT
 	BOOLEAN				Cancelled;
 #endif // CONFIG_STA_SUPPORT //
 
 	DBGPRINT(RT_DEBUG_TRACE, ("MlmeRestartStateMachine \n"));
 
-#ifdef RT2860
 	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
 	if(pAd->Mlme.bRunning)
 	{
@@ -5073,7 +5062,6 @@ VOID	MlmeRestartStateMachine(
 			DBGPRINT_ERR(("MlmeRestartStateMachine: MlmeQueue empty\n"));
 		}
 	}
-#endif // RT2860 //
 
 #ifdef CONFIG_STA_SUPPORT
 	IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
@@ -5122,12 +5110,10 @@ VOID	MlmeRestartStateMachine(
 	}
 #endif // CONFIG_STA_SUPPORT //
 
-#ifdef RT2860
 	// Remove running state
 	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
 	pAd->Mlme.bRunning = FALSE;
 	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
-#endif // RT2860 //
 }
 
 /*! \brief	test if the MLME Queue is empty
@@ -6799,7 +6785,6 @@ VOID AsicEnableIbssSync(
 	csr9.field.bTsfTicking = 0;
 	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr9.word);
 
-#ifdef RT2860
 	// move BEACON TXD and frame content to on-chip memory
 	ptr = (PUCHAR)&pAd->BeaconTxWI;
 	for (i=0; i<TXWI_SIZE; i+=4)  // 16-byte TXWI field
@@ -6817,7 +6802,6 @@ VOID AsicEnableIbssSync(
 		RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr);
 		ptr +=4;
 	}
-#endif // RT2860 //
 
 	// start sending BEACON
 	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
@@ -7186,9 +7170,7 @@ VOID AsicAddSharedKeyEntry(
 {
 	ULONG offset; //, csr0;
 	SHAREDKEY_MODE_STRUC csr1;
-#ifdef RT2860
 	INT   i;
-#endif // RT2860 //
 
 	DBGPRINT(RT_DEBUG_TRACE, ("AsicAddSharedKeyEntry BssIndex=%d, KeyIdx=%d\n", BssIndex,KeyIdx));
 //============================================================================================
@@ -7210,7 +7192,6 @@ VOID AsicAddSharedKeyEntry(
 	//
 	// fill key material - key + TX MIC + RX MIC
 	//
-#ifdef RT2860
 	offset = SHARED_KEY_TABLE_BASE + (4*BssIndex + KeyIdx)*HW_KEY_ENTRY_SIZE;
 	for (i=0; i<MAX_LEN_OF_SHARE_KEY; i++)
 	{
@@ -7234,7 +7215,6 @@ VOID AsicAddSharedKeyEntry(
 			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
 		}
 	}
-#endif // RT2860 //
 
 
 	//
@@ -7409,9 +7389,7 @@ VOID AsicAddKeyEntry(
 	PUCHAR		pTxtsc = pCipherKey->TxTsc;
 	UCHAR		CipherAlg = pCipherKey->CipherAlg;
 	SHAREDKEY_MODE_STRUC csr1;
-#ifdef RT2860
 	UCHAR		i;
-#endif // RT2860 //
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> AsicAddKeyEntry\n"));
 	//
@@ -7426,7 +7404,6 @@ VOID AsicAddKeyEntry(
 	// 2.) Set Key to Asic
 	//
 	//for (i = 0; i < KeyLen; i++)
-#ifdef RT2860
 	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i++)
 	{
 		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
@@ -7452,7 +7429,6 @@ VOID AsicAddKeyEntry(
 			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
 		}
 	}
-#endif // RT2860 //
 
 
 	//
@@ -7461,7 +7437,6 @@ VOID AsicAddKeyEntry(
 	//
 	if (bTxKey)
 	{
-#ifdef RT2860
 		offset = MAC_IVEIV_TABLE_BASE + (WCID * HW_IVEIV_ENTRY_SIZE);
 		//
 		// Write IV
@@ -7484,7 +7459,6 @@ VOID AsicAddKeyEntry(
 		{
 			RTMP_IO_WRITE8(pAd, offset + i, pTxtsc[i + 2]);
 		}
-#endif // RT2860 //
 
 		AsicUpdateWCIDAttribute(pAd, WCID, BssIndex, CipherAlg, bUsePairewiseKeyTable);
 	}
@@ -7550,12 +7524,10 @@ VOID AsicAddPairwiseKeyEntry(
 
 	// EKEY
 	offset = PAIRWISE_KEY_TABLE_BASE + (WCID * HW_KEY_ENTRY_SIZE);
-#ifdef RT2860
 	for (i=0; i<MAX_LEN_OF_PEER_KEY; i++)
 	{
 		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
 	}
-#endif // RT2860 //
 	for (i=0; i<MAX_LEN_OF_PEER_KEY; i+=4)
 	{
 		UINT32 Value;
@@ -7567,22 +7539,18 @@ VOID AsicAddPairwiseKeyEntry(
 	//  MIC KEY
 	if (pTxMic)
 	{
-#ifdef RT2860
 		for (i=0; i<8; i++)
 		{
 			RTMP_IO_WRITE8(pAd, offset+i, pTxMic[i]);
 		}
-#endif // RT2860 //
 	}
 	offset += 8;
 	if (pRxMic)
 	{
-#ifdef RT2860
 		for (i=0; i<8; i++)
 		{
 			RTMP_IO_WRITE8(pAd, offset+i, pRxMic[i]);
 		}
-#endif // RT2860 //
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE,("AsicAddPairwiseKeyEntry: WCID #%d Alg=%s\n",WCID, CipherName[CipherAlg]));
@@ -7631,11 +7599,9 @@ BOOLEAN AsicSendCommandToMcu(
 	HOST_CMD_CSR_STRUC	H2MCmd;
 	H2M_MAILBOX_STRUC	H2MMailbox;
 	ULONG				i = 0;
-#ifdef RT2860
 #ifdef RALINK_ATE
 	static UINT32 j = 0;
 #endif // RALINK_ATE //
-#endif // RT2860 //
 	do
 	{
 		RTMP_IO_READ32(pAd, H2M_MAILBOX_CSR, &H2MMailbox.word);
@@ -7647,7 +7613,6 @@ BOOLEAN AsicSendCommandToMcu(
 
 	if (i >= 100)
 	{
-#ifdef RT2860
 #ifdef RALINK_ATE
 		if (pAd->ate.bFWLoading == TRUE)
 		{
@@ -7672,7 +7637,6 @@ BOOLEAN AsicSendCommandToMcu(
 		}
 		else
 #endif // RALINK_ATE //
-#endif // RT2860 //
 		{
 			UINT32 Data;
 
@@ -7700,7 +7664,6 @@ BOOLEAN AsicSendCommandToMcu(
 		//return FALSE;
 	}
 
-#ifdef RT2860
 #ifdef RALINK_ATE
 	else if (pAd->ate.bFWLoading == TRUE)
 	{
@@ -7710,7 +7673,6 @@ BOOLEAN AsicSendCommandToMcu(
 		j = 0;
 	}
 #endif // RALINK_ATE //
-#endif // RT2860 //
 
 	H2MMailbox.field.Owner	  = 1;	   // pass ownership to MCU
 	H2MMailbox.field.CmdToken = Token;
@@ -7729,7 +7691,6 @@ BOOLEAN AsicSendCommandToMcu(
 	return TRUE;
 }
 
-#ifdef RT2860
 BOOLEAN AsicCheckCommanOk(
 	IN PRTMP_ADAPTER pAd,
 	IN UCHAR		 Command)
@@ -7794,7 +7755,6 @@ BOOLEAN AsicCheckCommanOk(
 
 	return FALSE;
 }
-#endif // RT2860 //
 
 /*
 	========================================================================
@@ -8206,10 +8166,8 @@ VOID AsicEvaluateRxAnt(
 	}
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
 #ifdef CONFIG_STA_SUPPORT
-#ifdef RT2860
 	IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
     	pAd->StaCfg.BBPR3 = BBPR3;
-#endif // RT2860 //
 #endif // CONFIG_STA_SUPPORT //
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
 		)
@@ -8321,9 +8279,7 @@ VOID AsicRxAntEvalTimeout(
 			BBPR3 |= (0x0);
 		}
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
-#ifdef RT2860
-    pAd->StaCfg.BBPR3 = BBPR3;
-#endif // RT2860 //
+		pAd->StaCfg.BBPR3 = BBPR3;
 	}
 
 #endif // CONFIG_STA_SUPPORT //
@@ -8549,10 +8505,7 @@ VOID AsicStaBbpTuning(
 		&& (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
 			)
 		&& !(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-#ifdef RT2860
-		&& (pAd->bPCIclkOff == FALSE)
-#endif // RT2860 //
-		)
+		&& (pAd->bPCIclkOff == FALSE))
 	{
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66, &OrigR66Value);
 		R66 = OrigR66Value;
--- a/drivers/staging/rt2860/common/rtmp_init.c
+++ b/drivers/staging/rt2860/common/rtmp_init.c
@@ -149,9 +149,7 @@ RTMP_REG_PAIR	MACRegTable[] =	{
 	{GF20_PROT_CFG,			0x01744004},    // set 19:18 --> Short NAV for MIMO PS
 	{GF40_PROT_CFG,			0x03F44084},
 	{MM20_PROT_CFG,			0x01744004},
-#ifdef RT2860
 	{MM40_PROT_CFG,			0x03F54084},
-#endif // RT2860 //
 	{TXOP_CTRL_CFG,			0x0000583f, /*0x0000243f*/ /*0x000024bf*/},	//Extension channel backoff.
 	{TX_RTS_CFG,			0x00092b20},
 	{EXP_ACK_TIME,			0x002400ca},	// default value
@@ -188,9 +186,7 @@ RTMP_REG_PAIR	STAMACRegTable[] =	{
 #define FIRMWAREIMAGEV1_LENGTH	0x1000
 #define FIRMWAREIMAGEV2_LENGTH	0x1000
 
-#ifdef RT2860
 #define FIRMWARE_MINOR_VERSION	2
-#endif // RT2860 //
 
 
 /*
@@ -248,9 +244,7 @@ NDIS_STATUS	RTMPAllocAdapterBlock(
 
 		// Init spin locks
 		NdisAllocateSpinLock(&pAd->MgmtRingLock);
-#ifdef RT2860
 		NdisAllocateSpinLock(&pAd->RxRingLock);
-#endif // RT2860 //
 
 		for (index =0 ; index < NUM_OF_TX_RING; index++)
 		{
@@ -1555,10 +1549,7 @@ VOID	NICInitAsicFromEEPROM(
 		pAd->LedCntl.word = 0x01;
 		pAd->Led1 = 0x5555;
 		pAd->Led2 = 0x2221;
-
-#ifdef RT2860
 		pAd->Led3 = 0xA9F8;
-#endif // RT2860 //
 	}
 
 	AsicSendCommandToMcu(pAd, 0x52, 0xff, (UCHAR)pAd->Led1, (UCHAR)(pAd->Led1 >> 8));
@@ -1594,12 +1585,10 @@ VOID	NICInitAsicFromEEPROM(
 		else
 		{
 			RTMPSetLED(pAd, LED_RADIO_ON);
-#ifdef RT2860
 			AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);
 			AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00, 0x00);
 			// 2-1. wait command ok.
 			AsicCheckCommanOk(pAd, PowerWakeCID);
-#endif // RT2860 //
 		}
 	}
 #endif // CONFIG_STA_SUPPORT //
@@ -1677,10 +1666,8 @@ NDIS_STATUS	NICInitializeAdapter(
 {
 	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
 	WPDMA_GLO_CFG_STRUC	GloCfg;
-#ifdef RT2860
 	UINT32			Value;
 	DELAY_INT_CFG_STRUC	IntCfg;
-#endif // RT2860 //
 	ULONG	i =0, j=0;
 	AC_TXOP_CSR0_STRUC	csr0;
 
@@ -1719,11 +1706,9 @@ retry:
 
 	// asic simulation sequence put this ahead before loading firmware.
 	// pbf hardware reset
-#ifdef RT2860
 	RTMP_IO_WRITE32(pAd, WPDMA_RST_IDX, 0x1003f);	// 0x10000 for reset rx, 0x3f resets all 6 tx rings.
 	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0xe1f);
 	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0xe00);
-#endif // RT2860 //
 
 	// Initialze ASIC for TX & Rx operation
 	if (NICInitializeAsic(pAd , bHardReset) != NDIS_STATUS_SUCCESS)
@@ -1737,7 +1722,6 @@ retry:
 	}
 
 
-#ifdef RT2860
 	// Write AC_BK base address register
 	Value = RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BK].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR1, Value);
@@ -1810,7 +1794,6 @@ retry:
 	// Write RX_RING_CSR register
 	Value = RX_RING_SIZE;
 	RTMP_IO_WRITE32(pAd, RX_MAX_CNT, Value);
-#endif // RT2860 //
 
 
 	// WMM parameter
@@ -1829,7 +1812,6 @@ retry:
 	RTMP_IO_WRITE32(pAd, WMM_TXOP1_CFG, csr0.word);
 
 
-#ifdef RT2860
 	// 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits:
 	i = 0;
 	do
@@ -1848,7 +1830,6 @@ retry:
 
 	IntCfg.word = 0;
 	RTMP_IO_WRITE32(pAd, DELAY_INT_CFG, IntCfg.word);
-#endif // RT2860 //
 
 
 	// reset action
@@ -1889,7 +1870,6 @@ NDIS_STATUS	NICInitializeAsic(
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitializeAsic\n"));
 
-#ifdef RT2860
 	if (bHardReset == TRUE)
 	{
 		RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x3);
@@ -1914,7 +1894,6 @@ NDIS_STATUS	NICInitializeAsic(
 		}
 	}
 #endif // CONFIG_STA_SUPPORT //
-#endif // RT2860 //
 
 
 	//
@@ -3153,12 +3132,10 @@ VOID	UserCfgInit(
 	pAd->CommonCfg.BBPCurrentBW = BW_20;
 
 	pAd->LedCntl.word = 0;
-#ifdef RT2860
 	pAd->LedIndicatorStregth = 0;
 	pAd->RLnkCtrlOffset = 0;
 	pAd->HostLnkCtrlOffset = 0;
 	pAd->CheckDmaBusyCount = 0;
-#endif // RT2860 //
 
 	pAd->bAutoTxAgcA = FALSE;			// Default is OFF
 	pAd->bAutoTxAgcG = FALSE;			// Default is OFF
@@ -3418,9 +3395,7 @@ VOID	UserCfgInit(
 	pAd->ate.bRxFer = 0;
 	pAd->ate.bQATxStart = FALSE;
 	pAd->ate.bQARxStart = FALSE;
-#ifdef RT2860
 	pAd->ate.bFWLoading = FALSE;
-#endif // RT2860 //
 #ifdef RALINK_28xx_QA
 	//pAd->ate.Repeat = 0;
 	pAd->ate.TxStatus = 0;
@@ -3430,9 +3405,7 @@ VOID	UserCfgInit(
 
 
 	pAd->CommonCfg.bWiFiTest = FALSE;
-#ifdef RT2860
-    pAd->bPCIclkOff = FALSE;
-#endif // RT2860 //
+	pAd->bPCIclkOff = FALSE;
 
 	RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- UserCfgInit\n"));
--- a/drivers/staging/rt2860/config.mk
+++ b/drivers/staging/rt2860/config.mk
@@ -108,10 +108,6 @@ ifeq ($(HAS_EXT_BUILD_CHANNEL_LIST),y)
 WFLAGS += -DEXT_BUILD_CHANNEL_LIST
 endif
 
-ifeq ($(CHIPSET),2860)
-WFLAGS +=-DRT2860
-endif
-
 ifeq ($(CHIPSET),2870)
 WFLAGS +=-DRT2870
 endif
--- a/drivers/staging/rt2860/Makefile
+++ b/drivers/staging/rt2860/Makefile
@@ -2,7 +2,6 @@ obj-$(CONFIG_RT2860)	+= rt2860sta.o
 
 # TODO: all of these should be removed
 EXTRA_CFLAGS += -DLINUX -DAGGREGATION_SUPPORT -DPIGGYBACK_SUPPORT -DWMM_SUPPORT
-EXTRA_CFLAGS += -DRT2860
 EXTRA_CFLAGS += -DCONFIG_STA_SUPPORT
 EXTRA_CFLAGS += -DDBG
 EXTRA_CFLAGS += -DDOT11_N_SUPPORT
--- a/drivers/staging/rt2860/rt28xx.h
+++ b/drivers/staging/rt2860/rt28xx.h
@@ -1670,11 +1670,9 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 #define E2PROM_CSR          0x0004
 #define IO_CNTL_CSR         0x77d0
 
-#ifdef RT2860
 // 8051 firmware image for RT2860 - base address = 0x4000
 #define FIRMWARE_IMAGE_BASE     0x2000
 #define MAX_FIRMWARE_IMAGE_SIZE 0x2000    // 8kbyte
-#endif // RT2860 //
 
 
 // ================================================================
@@ -2029,7 +2027,6 @@ typedef	struct	PACKED _TXWI_STRUC {
 //
 // Rx descriptor format, Rx	Ring
 //
-#ifdef RT2860
 #ifdef RT_BIG_ENDIAN
 typedef	struct	PACKED _RXD_STRUC	{
 	// Word 0
@@ -2098,7 +2095,6 @@ typedef	struct	PACKED _RXD_STRUC	{
 	UINT32		Rsv1:13;
 }	RXD_STRUC, *PRXD_STRUC, RT28XX_RXD_STRUC, *PRT28XX_RXD_STRUC;
 #endif
-#endif // RT2860 //
 //
 // RXWI wireless information format, in PBF. invisible in driver.
 //
--- a/drivers/staging/rt2860/rt_ate.c
+++ b/drivers/staging/rt2860/rt_ate.c
@@ -68,7 +68,6 @@ static int CheckMCSValid(
 	IN UCHAR Mode,
 	IN UCHAR Mcs);
 
-#ifdef RT2860
 static VOID ATEWriteTxWI(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PTXWI_STRUC 	pOutTxWI,
@@ -87,7 +86,6 @@ static VOID ATEWriteTxWI(
 	IN	UCHAR			Txopmode,
 	IN	BOOLEAN			CfAck,
 	IN	HTTRANSMIT_SETTING	*pTransmit);
-#endif // RT2860 //
 
 
 static VOID SetJapanFilter(
@@ -95,7 +93,6 @@ static VOID SetJapanFilter(
 
 /*=========================end of prototype=========================*/
 
-#ifdef RT2860
 static INT TxDmaBusy(
 	IN PRTMP_ADAPTER pAd)
 {
@@ -153,7 +150,6 @@ static VOID RtmpDmaEnable(
 
 	return;
 }
-#endif // RT2860 //
 
 
 static VOID BbpSoftReset(
@@ -488,7 +484,6 @@ static INT ATETxPwrHandler(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
 */
-#ifdef RT2860
 static INT	ATECmdHandler(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			arg)
@@ -1297,7 +1292,6 @@ static INT	ATECmdHandler(
 
 	return TRUE;
 }
-#endif // RT2860 //
 /*                                                           */
 /*                                                           */
 /*=======================End of RT2860=======================*/
@@ -2907,7 +2901,6 @@ VOID ATEAsicAdjustTxPower(
 		None
 	========================================================================
 */
-#ifdef RT2860
 static VOID ATEWriteTxWI(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PTXWI_STRUC 	pOutTxWI,
@@ -2972,7 +2965,6 @@ static VOID ATEWriteTxWI(
 
         return;
 }
-#endif // RT2860 //
 
 /*
 	========================================================================
@@ -3249,13 +3241,11 @@ VOID RTMPStationStart(
     IN  PRTMP_ADAPTER   pAd)
 {
     ATEDBGPRINT(RT_DEBUG_TRACE, ("==> RTMPStationStart\n"));
-#ifdef RT2860
-	pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+epAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 	//
 	// We did not cancel this timer when entering ATE mode.
 	//
 //	RTMPSetTimer(&pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
-#endif // RT2860 //
 	ATEDBGPRINT(RT_DEBUG_TRACE, ("<== RTMPStationStart\n"));
 }
 #endif // CONFIG_STA_SUPPORT //
@@ -3268,7 +3258,6 @@ VOID RTMPStationStart(
 		This routine should only be used in ATE mode.
 	==========================================================================
  */
-#ifdef RT2860
 static INT ATESetUpFrame(
 	IN PRTMP_ADAPTER pAd,
 	IN UINT32 TxIdx)
@@ -3455,7 +3444,6 @@ static INT ATESetUpFrame(
 /*                                                           */
 /*                                                           */
 /*=======================End of RT2860=======================*/
-#endif // RT2860 //
 
 
 VOID rt_ee_read_all(PRTMP_ADAPTER pAd, USHORT *Data)
@@ -4578,9 +4566,7 @@ VOID RtmpDoAte(
 						{
 							if (pAdapter->ate.TxCount == 0)
 							{
-#ifdef RT2860
 								pAdapter->ate.TxCount = 0xFFFFFFFF;
-#endif // RT2860 //
 							}
 							ATEDBGPRINT(RT_DEBUG_TRACE,("START TXFRAME\n"));
 							pAdapter->ate.bQATxStart = TRUE;
@@ -5375,7 +5361,6 @@ TX_START_ERROR:
 
 				memcpy((PUCHAR)&value, (PUCHAR)&(pRaCfg->status), 2);
 				value = ntohs(value);
-#ifdef RT2860
 				/* TX_FRAME_COUNT == 0 means tx infinitely */
 				if (value == 0)
 				{
@@ -5387,7 +5372,6 @@ TX_START_ERROR:
 
 				}
 				else
-#endif // RT2860 //
 				{
 					sprintf((PCHAR)str, "%d", value);
 					Set_ATE_TX_COUNT_Proc(pAdapter, str);
--- a/drivers/staging/rt2860/rt_ate.h
+++ b/drivers/staging/rt2860/rt_ate.h
@@ -31,12 +31,10 @@
 #ifndef UCOS
 #define ate_print printk
 #define ATEDBGPRINT DBGPRINT
-#ifdef RT2860
 #define EEPROM_SIZE								0x200
 #ifdef CONFIG_STA_SUPPORT
 #define EEPROM_BIN_FILE_NAME  "/etc/Wireless/RT2860STA/e2p.bin"
 #endif // CONFIG_STA_SUPPORT //
-#endif // RT2860 //
 
 #else // !UCOS //
 #define fATE_LOAD_EEPROM						0x0C43
@@ -69,7 +67,6 @@ do{   int (*org_remote_display)(char *) 
 #define ATE_ON(_p)              (((_p)->ate.Mode) != ATE_STOP)
 
 /* RT2880_iNIC will define "RT2860". */
-#ifdef RT2860
 #define ATE_BBP_IO_READ8_BY_REG_ID(_A, _I, _pV)        \
 {                                                       \
     BBP_CSR_CFG_STRUC  BbpCsr;                             \
@@ -131,10 +128,8 @@ do{   int (*org_remote_display)(char *) 
         ATEDBGPRINT(RT_DEBUG_ERROR, ("BBP write R%d fail\n", _I));     \
     }                                                   \
 }
-#endif // RT2860 //
 
 /* RT2880_iNIC will define RT2860. */
-#ifdef RT2860
 #define EEPROM_SIZE								0x200
 /* iNIC has its own EEPROM_BIN_FILE_NAME */
 #ifndef UCOS
@@ -142,7 +137,6 @@ do{   int (*org_remote_display)(char *) 
 #define EEPROM_BIN_FILE_NAME  "/etc/Wireless/RT2860STA/e2p.bin"
 #endif // CONFIG_STA_SUPPORT //
 #endif // !UCOS //
-#endif // RT2860 //
 
 
 
--- a/drivers/staging/rt2860/rt_config.h
+++ b/drivers/staging/rt2860/rt_config.h
@@ -53,9 +53,7 @@
 #include    "rtmp_def.h"
 #include    "rt28xx.h"
 
-#ifdef RT2860
 #include	"rt2860.h"
-#endif // RT2860 //
 
 
 #include    "oid.h"
--- a/drivers/staging/rt2860/rt_linux.c
+++ b/drivers/staging/rt2860/rt_linux.c
@@ -48,10 +48,8 @@ BUILD_TIMER_FUNCTION(LeapAuthTimeout);
 #endif
 BUILD_TIMER_FUNCTION(StaQuickResponeForRateUpExec);
 BUILD_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc);
-#ifdef RT2860
 BUILD_TIMER_FUNCTION(PsPollWakeExec);
 BUILD_TIMER_FUNCTION(RadioOnExec);
-#endif // RT2860 //
 #ifdef QOS_DLS_SUPPORT
 BUILD_TIMER_FUNCTION(DlsTimeoutAction);
 #endif // QOS_DLS_SUPPORT //
@@ -293,9 +291,7 @@ VOID	RTMPFreeAdapter(
 
 	NdisFreeSpinLock(&pAd->MgmtRingLock);
 
-#ifdef RT2860
 	NdisFreeSpinLock(&pAd->RxRingLock);
-#endif // RT2860 //
 
 	for (index =0 ; index < NUM_OF_TX_RING; index++)
 	{
--- a/drivers/staging/rt2860/rt_linux.h
+++ b/drivers/staging/rt2860/rt_linux.h
@@ -89,7 +89,6 @@ typedef int (*HARD_START_XMIT_FUNC)(stru
 // add by kathy
 
 #ifdef CONFIG_STA_SUPPORT
-#ifdef RT2860
 #define STA_PROFILE_PATH			"/etc/Wireless/RT2860STA/RT2860STA.dat"
 #define STA_RTMP_FIRMWARE_FILE_NAME "/etc/Wireless/RT2860STA/RT2860STA.bin"
 #define STA_NIC_DEVICE_NAME			"RT2860STA"
@@ -97,18 +96,15 @@ typedef int (*HARD_START_XMIT_FUNC)(stru
 #ifdef MULTIPLE_CARD_SUPPORT
 #define CARD_INFO_PATH			"/etc/Wireless/RT2860STA/RT2860STACard.dat"
 #endif // MULTIPLE_CARD_SUPPORT //
-#endif // RT2860 //
 
 
 #endif // CONFIG_STA_SUPPORT //
 
-#ifdef RT2860
 #ifndef PCI_DEVICE
 #define PCI_DEVICE(vend,dev) \
 	.vendor = (vend), .device = (dev), \
 	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
 #endif // PCI_DEVICE //
-#endif // RT2860 //
 
 #define RTMP_TIME_AFTER(a,b)		\
 	(typecheck(unsigned long, (unsigned long)a) && \
@@ -174,11 +170,9 @@ struct os_lock  {
 
 
 struct os_cookie {
-#ifdef RT2860
 	struct pci_dev 			*pci_dev;
 	struct pci_dev 			*parent_pci_dev;
 	dma_addr_t		  		pAd_pa;
-#endif // RT2860 //
 
 
 	struct tasklet_struct 	rx_done_task;
@@ -189,9 +183,7 @@ struct os_cookie {
 	struct tasklet_struct 	ac3_dma_done_task;
 	struct tasklet_struct 	hcca_dma_done_task;
 	struct tasklet_struct	tbtt_task;
-#ifdef RT2860
 	struct tasklet_struct	fifo_statistic_full_task;
-#endif // RT2860 //
 
 
 	unsigned long			apd_pid; //802.1x daemon pid
@@ -246,7 +238,6 @@ void linux_pci_unmap_single(void *handle
 
 #define RT2860_PCI_DEVICE_ID		0x0601
 
-#ifdef RT2860
 #define PCI_MAP_SINGLE(_handle, _ptr, _size, _sd_idx, _dir) \
 	linux_pci_map_single(_handle, _ptr, _size, _sd_idx, _dir)
 
@@ -261,7 +252,6 @@ void linux_pci_unmap_single(void *handle
 
 #define DEV_ALLOC_SKB(_length) \
 	dev_alloc_skb(_length)
-#endif // RT2860 //
 
 
 
@@ -381,7 +371,6 @@ extern ULONG    RTDebugLevel;
 	spin_unlock_irqrestore((spinlock_t *)(__lock), ((unsigned long)__irqflag));	\
 }
 
-#ifdef RT2860
 #if defined(INF_TWINPASS) || defined(INF_DANUBE) || defined(IKANOS_VX_1X0)
 //Patch for ASIC turst read/write bug, needs to remove after metel fix
 #define RTMP_IO_READ32(_A, _R, _pV)									\
@@ -483,7 +472,6 @@ extern ULONG    RTDebugLevel;
 	writew((_V), (PUSHORT)((_A)->CSRBaseAddress + (_R)));	\
 }
 #endif
-#endif // RT2860 //
 
 
 #ifndef wait_event_interruptible_timeout
@@ -535,7 +523,6 @@ typedef void (*TIMER_FUNCTION)(unsigned 
 #define MlmeAllocateMemory(_pAd, _ppVA) os_alloc_mem(_pAd, _ppVA, MGMT_DMA_BUFFER_SIZE)
 #define MlmeFreeMemory(_pAd, _pVA)     os_free_mem(_pAd, _pVA)
 
-#ifdef RT2860
 #define BUILD_TIMER_FUNCTION(_func)												\
 void linux_##_func(unsigned long data)											\
 {																				\
@@ -545,7 +532,6 @@ void linux_##_func(unsigned long data)		
 	if (pTimer->Repeat)															\
 		RTMP_OS_Add_Timer(&pTimer->TimerObj, pTimer->TimerValue);				\
 }
-#endif // RT2860 //
 
 
 
@@ -898,7 +884,6 @@ int rt28xx_packet_xmit(struct sk_buff *s
 
 void rtmp_os_thread_init(PUCHAR pThreadName, PVOID pNotify);
 
-#ifdef RT2860
 #if !defined(PCI_CAP_ID_EXP)
 #define PCI_CAP_ID_EXP			    0x10
 #endif
@@ -912,6 +897,5 @@ void rtmp_os_thread_init(PUCHAR pThreadN
 #endif
 
 #define PCIBUS_INTEL_VENDOR         0x8086
-#endif // RT2860 //
 
 
--- a/drivers/staging/rt2860/rt_main_dev.c
+++ b/drivers/staging/rt2860/rt_main_dev.c
@@ -71,9 +71,7 @@ extern void ba_reordering_resource_relea
 #endif // DOT11_N_SUPPORT //
 extern NDIS_STATUS NICLoadRateSwitchingParams(IN PRTMP_ADAPTER pAd);
 
-#ifdef RT2860
 extern void init_thread_task(PRTMP_ADAPTER pAd);
-#endif // RT2860 //
 
 // public function prototype
 INT __devinit rt28xx_probe(IN void *_dev_p, IN void *_dev_id_p,
@@ -310,9 +308,7 @@ int rt28xx_close(IN PNET_DEV dev)
 #endif // WPA_SUPPLICANT_SUPPORT //
 
 		MlmeRadioOff(pAd);
-#ifdef RT2860
 		pAd->bPCIclkOff = FALSE;
-#endif // RT2860 //
 	}
 #endif // CONFIG_STA_SUPPORT //
 
@@ -346,7 +342,6 @@ int rt28xx_close(IN PNET_DEV dev)
 	TpcReqTabExit(pAd);
 
 
-#ifdef RT2860
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE))
 	{
 		NICDisableInterrupt(pAd);
@@ -362,7 +357,6 @@ int rt28xx_close(IN PNET_DEV dev)
 		RT28XX_IRQ_RELEASE(net_dev)
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
 	}
-#endif // RT2860 //
 
 
 	// Free Ring or USB buffers
@@ -426,12 +420,10 @@ static int rt28xx_init(IN struct net_dev
 
 	// Disable interrupts here which is as soon as possible
 	// This statement should never be true. We might consider to remove it later
-#ifdef RT2860
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE))
 	{
 		NICDisableInterrupt(pAd);
 	}
-#endif // RT2860 //
 
 	Status = RTMPAllocTxRxRingMemory(pAd);
 	if (Status != NDIS_STATUS_SUCCESS)
@@ -720,10 +712,8 @@ int rt28xx_open(IN PNET_DEV dev)
 	}
 
 #ifdef CONFIG_STA_SUPPORT
-#ifdef RT2860
 	IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
         RTMPInitPCIeLinkCtrlValue(pAd);
-#endif // RT2860 //
 #endif // CONFIG_STA_SUPPORT //
 
 	return (retval);
@@ -1203,9 +1193,7 @@ INT __devinit   rt28xx_probe(
     PRTMP_ADAPTER       pAd = (PRTMP_ADAPTER) NULL;
     INT                 status;
 	PVOID				handle;
-#ifdef RT2860
 	struct pci_dev *dev_p = (struct pci_dev *)_dev_p;
-#endif // RT2860 //
 
 
 #ifdef CONFIG_STA_SUPPORT
--- a/drivers/staging/rt2860/rtmp_def.h
+++ b/drivers/staging/rt2860/rtmp_def.h
@@ -111,7 +111,6 @@
 // Entry number for each DMA descriptor ring
 //
 
-#ifdef RT2860
 #define TX_RING_SIZE            64 //64
 #define MGMT_RING_SIZE          128
 #define RX_RING_SIZE            128 //64
@@ -119,7 +118,6 @@
 #define MAX_DMA_DONE_PROCESS    TX_RING_SIZE
 #define MAX_TX_DONE_PROCESS     TX_RING_SIZE //8
 #define LOCAL_TXBUF_SIZE        2
-#endif // RT2860 //
 
 
 #ifdef MULTIPLE_CARD_SUPPORT
--- a/drivers/staging/rt2860/rtmp.h
+++ b/drivers/staging/rt2860/rtmp.h
@@ -203,9 +203,7 @@ typedef	struct _ATE_INFO {
 	BOOLEAN	bRxFer;
 	BOOLEAN	bQATxStart; // Have compiled QA in and use it to ATE tx.
 	BOOLEAN	bQARxStart;	// Have compiled QA in and use it to ATE rx.
-#ifdef RT2860
 	BOOLEAN	bFWLoading;	// Reload firmware when ATE is done.
-#endif // RT2860 //
 	UINT32	RxTotalCnt;
 	UINT32	RxCntPerSec;
 
@@ -485,7 +483,6 @@ typedef struct  _QUEUE_HEADER   {
 //
 #define MAX_BUSY_COUNT  100         // Number of retry before failing access BBP & RF indirect register
 //
-#ifdef RT2860
 #define RTMP_RF_IO_WRITE32(_A, _V)                  \
 {                                                   \
     PHY_CSR4_STRUC  Value;                          \
@@ -649,7 +646,6 @@ typedef struct  _QUEUE_HEADER   {
     }                                                   \
     }                                                   \
 }
-#endif // RT2860 //
 
 
 #define     MAP_CHANNEL_ID_TO_KHZ(ch, khz)  {               \
@@ -901,7 +897,6 @@ typedef struct _RTMP_SCATTER_GATHER_LIST
 // Enqueue this frame to MLME engine
 // We need to enqueue the whole frame because MLME need to pass data type
 // information from 802.11 header
-#ifdef RT2860
 #define REPORT_MGMT_FRAME_TO_MLME(_pAd, Wcid, _pFrame, _FrameSize, _Rssi0, _Rssi1, _Rssi2, _PlcpSignal)        \
 {                                                                                       \
     UINT32 High32TSF, Low32TSF;                                                          \
@@ -909,7 +904,6 @@ typedef struct _RTMP_SCATTER_GATHER_LIST
     RTMP_IO_READ32(_pAd, TSF_TIMER_DW0, &Low32TSF);                                        \
     MlmeEnqueueForRecv(_pAd, Wcid, High32TSF, Low32TSF, (UCHAR)_Rssi0, (UCHAR)_Rssi1,(UCHAR)_Rssi2,_FrameSize, _pFrame, (UCHAR)_PlcpSignal);   \
 }
-#endif // RT2860 //
 
 #define NDIS_QUERY_BUFFER(_NdisBuf, _ppVA, _pBufLen)                    \
     NdisQueryBuffer(_NdisBuf, _ppVA, _pBufLen)
@@ -1008,9 +1002,7 @@ typedef struct  _RTMP_REORDERBUF
 	UCHAR 		DataOffset;
 	USHORT 		Datasize;
 	ULONG                   AllocSize;
-#ifdef RT2860
 	NDIS_PHYSICAL_ADDRESS   AllocPa;            // TxBuf physical address
-#endif // RT2860 //
 }   RTMP_REORDERBUF, *PRTMP_REORDERBUF;
 
 //
@@ -1445,11 +1437,9 @@ typedef struct _MLME_STRUCT {
 	RALINK_TIMER_STRUCT     APSDPeriodicTimer;
 	RALINK_TIMER_STRUCT     LinkDownTimer;
 	RALINK_TIMER_STRUCT     LinkUpTimer;
-#ifdef RT2860
     UCHAR                   bPsPollTimerRunning;
     RALINK_TIMER_STRUCT     PsPollTimer;
 	RALINK_TIMER_STRUCT     RadioOnOffTimer;
-#endif // RT2860 //
 	ULONG                   PeriodicRound;
 	ULONG                   OneSecPeriodicRound;
 
@@ -2237,9 +2227,7 @@ typedef struct _STA_ADMIN_CONFIG {
 	RT_HT_PHY_INFO					DesiredHtPhyInfo;
 	BOOLEAN							bAutoTxRateSwitch;
 
-#ifdef RT2860
     UCHAR       BBPR3;
-#endif // RT2860 //
 
 #ifdef EXT_BUILD_CHANNEL_LIST
 	UCHAR				IEEE80211dClientMode;
@@ -2672,7 +2660,6 @@ typedef struct _RTMP_ADAPTER
 	PNET_DEV				net_dev;
 	ULONG					VirtualIfCnt;
 
-#ifdef RT2860
     USHORT		            LnkCtrlBitMask;
     USHORT		            RLnkCtrlConfiguration;
     USHORT                  RLnkCtrlOffset;
@@ -2699,7 +2686,6 @@ typedef struct _RTMP_ADAPTER
 	RTMP_DMABUF             RxDescRing;                 // Shared memory for RX descriptors
 	RTMP_DMABUF             TxDescRing[NUM_OF_TX_RING]; 	// Shared memory for Tx descriptors
 	RTMP_TX_RING            TxRing[NUM_OF_TX_RING];     	// AC0~4 + HCCA
-#endif // RT2860 //
 
 
 	NDIS_SPIN_LOCK          irq_lock;
@@ -2732,10 +2718,8 @@ typedef struct _RTMP_ADAPTER
 /*      Rx related parameters                                                           */
 /*****************************************************************************************/
 
-#ifdef RT2860
 	RTMP_RX_RING            RxRing;
 	NDIS_SPIN_LOCK          RxRingLock;                 // Rx Ring spinlock
-#endif // RT2860 //
 
 
 
@@ -3193,7 +3177,6 @@ typedef struct _TX_BLK_
 //------------------------------------------------------------------------------------------
 
 
-#ifdef RT2860
 //
 // Enable & Disable NIC interrupt via writing interrupt mask register
 // Since it use ADAPTER structure, it have to be put after structure definition.
@@ -3226,7 +3209,6 @@ __inline    VOID    NICEnableInterrupt(
 	//RTMP_IO_WRITE32(pAd, PBF_INT_ENA, 0x00000030); // 1 : enable
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE);
 }
-#endif // RT2860 //
 
 #ifdef RT_BIG_ENDIAN
 static inline VOID	WriteBackToDescriptor(
@@ -3303,7 +3285,6 @@ static inline VOID	RTMPWIEndianChange(
 		Call this function when read or update descriptor
 	========================================================================
 */
-#ifdef RT2860
 static inline VOID	RTMPDescriptorEndianChange(
 	IN	PUCHAR			pData,
 	IN	ULONG			DescriptorType)
@@ -3313,7 +3294,6 @@ static inline VOID	RTMPDescriptorEndianC
 	*((UINT32 *)(pData +12)) = SWAP32(*((UINT32 *)(pData + 12)));	// Byte 12~15
 	*((UINT32 *)(pData + 4)) = SWAP32(*((UINT32 *)(pData + 4)));				// Byte 4~7, this must be swapped last
 }
-#endif // RT2860 //
 
 /*
 	========================================================================
@@ -4319,11 +4299,9 @@ BOOLEAN AsicSendCommandToMcu(
 	IN UCHAR         Arg0,
 	IN UCHAR         Arg1);
 
-#ifdef RT2860
 BOOLEAN AsicCheckCommanOk(
 	IN PRTMP_ADAPTER pAd,
 	IN UCHAR		 Command);
-#endif // RT2860 //
 
 VOID MacAddrRandomBssid(
 	IN  PRTMP_ADAPTER   pAd,
@@ -6993,7 +6971,6 @@ void kill_thread_task(PRTMP_ADAPTER pAd)
 
 void tbtt_tasklet(unsigned long data);
 
-#ifdef RT2860
 //
 // Function Prototype in cmm_data_2860.c
 //
@@ -7108,7 +7085,6 @@ VOID RT28xxPciMlmeRadioOn(
 
 VOID RT28xxPciMlmeRadioOFF(
 	IN PRTMP_ADAPTER pAd);
-#endif // RT2860 //
 
 VOID AsicTurnOffRFClk(
 	IN PRTMP_ADAPTER    pAd,
--- a/drivers/staging/rt2860/sta/connect.c
+++ b/drivers/staging/rt2860/sta/connect.c
@@ -1275,7 +1275,6 @@ VOID LinkUp(
 	//rt2860b. Don't know why need this
 	SwitchBetweenWepAndCkip(pAd);
 
-#ifdef RT2860
 	// Before power save before link up function, We will force use 1R.
 	// So after link up, check Rx antenna # again.
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
@@ -1293,7 +1292,6 @@ VOID LinkUp(
 	}
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 	pAd->StaCfg.BBPR3 = Value;
-#endif // RT2860 //
 
 	if (BssType == BSS_ADHOC)
 	{
@@ -1341,9 +1339,7 @@ VOID LinkUp(
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
 		Value &= (~0x20);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
-#ifdef RT2860
         pAd->StaCfg.BBPR3 = Value;
-#endif // RT2860 //
 
 		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Data);
 		Data &= 0xfffffffe;
@@ -1378,9 +1374,7 @@ VOID LinkUp(
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
 	    Value |= (0x20);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
-#ifdef RT2860
         pAd->StaCfg.BBPR3 = Value;
-#endif // RT2860 //
 
 		if (pAd->MACVersion == 0x28600100)
 		{
@@ -1411,9 +1405,7 @@ VOID LinkUp(
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
 		Value &= (~0x20);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
-#ifdef RT2860
         pAd->StaCfg.BBPR3 = Value;
-#endif // RT2860 //
 
 		if (pAd->MACVersion == 0x28600100)
 		{
@@ -2001,7 +1993,6 @@ VOID LinkDown(
 	DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK DOWN !!!\n"));
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
 
-#ifdef RT2860
     if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE))
     {
 	    BOOLEAN Cancelled;
@@ -2018,7 +2009,6 @@ VOID LinkDown(
     }
 
     pAd->bPCIclkOff = FALSE;
-#endif // RT2860 //
 	if (ADHOC_ON(pAd))		// Adhoc mode link down
 	{
 		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK DOWN 1!!!\n"));
@@ -2533,7 +2523,6 @@ VOID AuthParmFill(
 
 	==========================================================================
  */
-#ifdef RT2860
 VOID ComposePsPoll(
 	IN PRTMP_ADAPTER pAd)
 {
@@ -2557,7 +2546,6 @@ VOID ComposeNullFrame(
 	COPY_MAC_ADDR(pAd->NullFrame.Addr2, pAd->CurrentAddress);
 	COPY_MAC_ADDR(pAd->NullFrame.Addr3, pAd->CommonCfg.Bssid);
 }
-#endif // RT2860 //
 
 
 
--- a/drivers/staging/rt2860/sta/dls.c
+++ b/drivers/staging/rt2860/sta/dls.c
@@ -1419,7 +1419,6 @@ BOOLEAN RTMPRcvFrameDLSCheck(
 				//AsicAddKeyEntry(pAd, (USHORT)(i + 2), BSS0, 0, &PairwiseKey, TRUE, TRUE);	// reserve 0 for multicast, 1 for unicast
 				//AsicUpdateRxWCIDTable(pAd, (USHORT)(i + 2), pAddr);
 				// Add Pair-wise key to Asic
-#ifdef RT2860
             	AsicAddPairwiseKeyEntry(pAd,
 										pAd->StaCfg.DLSEntry[i].MacAddr,
 										(UCHAR)pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
@@ -1431,7 +1430,6 @@ BOOLEAN RTMPRcvFrameDLSCheck(
 										  PairwiseKey.CipherAlg,
 										  pEntry);
 
-#endif // RT2860 //
 				NdisMoveMemory(&pEntry->PairwiseKey, &PairwiseKey, sizeof(CIPHER_KEY));
 				DBGPRINT(RT_DEBUG_TRACE,("DLS - Receive STAKey Message-1 (Peer STA MAC Address STAKey) \n"));
 
@@ -1477,7 +1475,6 @@ BOOLEAN RTMPRcvFrameDLSCheck(
 				//AsicAddKeyEntry(pAd, (USHORT)(i + 2), BSS0, 0, &PairwiseKey, TRUE, TRUE);	// reserve 0 for multicast, 1 for unicast
 				//AsicUpdateRxWCIDTable(pAd, (USHORT)(i + 2), pAddr);
 				// Add Pair-wise key to Asic
-#ifdef RT2860
             	AsicAddPairwiseKeyEntry(pAd,
 										pAd->StaCfg.DLSEntry[i].MacAddr,
 										(UCHAR)pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
@@ -1488,7 +1485,6 @@ BOOLEAN RTMPRcvFrameDLSCheck(
 										  0,
 										  PairwiseKey.CipherAlg,
 										  pEntry);
-#endif // RT2860 //
 				NdisMoveMemory(&pEntry->PairwiseKey, &PairwiseKey, sizeof(CIPHER_KEY));
 				DBGPRINT(RT_DEBUG_TRACE,("DLS - Receive STAKey Message-1 (Initiator STA MAC Address STAKey)\n"));
 
--- a/drivers/staging/rt2860/sta_ioctl.c
+++ b/drivers/staging/rt2860/sta_ioctl.c
@@ -583,9 +583,7 @@ rt_ioctl_giwname(struct net_device *dev,
 {
 //	PRTMP_ADAPTER pAdapter = dev->ml_priv;
 
-#ifdef RT2860
     strncpy(name, "RT2860 Wireless", IFNAMSIZ);
-#endif // RT2860 //
 	return 0;
 }
 
@@ -5321,7 +5319,6 @@ INT RTMPQueryInformation(
 		case RT_OID_802_11_PRODUCTID:
 			DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_802_11_PRODUCTID \n"));
 
-#ifdef RT2860
 			{
 
 				USHORT  device_id;
@@ -5331,7 +5328,6 @@ INT RTMPQueryInformation(
 					DBGPRINT(RT_DEBUG_TRACE, (" pci_dev = NULL\n"));
 				sprintf(tmp, "%04x %04x\n", NIC_PCI_VENDOR_ID, device_id);
 			}
-#endif // RT2860 //
 			wrq->u.data.length = strlen(tmp);
 			Status = copy_to_user(wrq->u.data.pointer, tmp, wrq->u.data.length);
 			break;
--- a/drivers/staging/rt2860/sta/rtmp_data.c
+++ b/drivers/staging/rt2860/sta/rtmp_data.c
@@ -75,7 +75,6 @@ VOID STARxEAPOLFrameIndicate(
 
                     if (pAd->StaCfg.DesireSharedKey[idx].KeyLen > 0)
     				{
-#ifdef RT2860
 						MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[BSSID_WCID];
 
 						// Set key material and cipherAlg to Asic
@@ -89,7 +88,6 @@ VOID STARxEAPOLFrameIndicate(
 
                         pAd->IndicateMediaState = NdisMediaStateConnected;
                         pAd->ExtraInfo = GENERAL_LINK_UP;
-#endif // RT2860 //
 						// For Preventing ShardKey Table is cleared by remove key procedure.
     					pAd->SharedKey[BSS0][idx].CipherAlg = CipherAlg;
 						pAd->SharedKey[BSS0][idx].KeyLen = pAd->StaCfg.DesireSharedKey[idx].KeyLen;
@@ -693,14 +691,12 @@ BOOLEAN STARxDoneInterruptHandle(
 			break;
 		}
 
-#ifdef RT2860
 		if (RxProcessed++ > MAX_RX_PROCESS_CNT)
 		{
 			// need to reschedule rx handle
 			bReschedule = TRUE;
 			break;
 		}
-#endif // RT2860 //
 
 		RxProcessed ++; // test
 
@@ -1227,7 +1223,6 @@ NDIS_STATUS STASendPacket(
 
 	========================================================================
 */
-#ifdef RT2860
 NDIS_STATUS RTMPFreeTXDRequest(
 	IN		PRTMP_ADAPTER	pAd,
 	IN		UCHAR			QueIdx,
@@ -1271,7 +1266,6 @@ NDIS_STATUS RTMPFreeTXDRequest(
 
 	return (Status);
 }
-#endif // RT2860 //
 
 
 
--- a/drivers/staging/rt2860/sta/sync.c
+++ b/drivers/staging/rt2860/sta/sync.c
@@ -228,7 +228,6 @@ VOID MlmeScanReqAction(
 	// Increase the scan retry counters.
 	pAd->StaCfg.ScanCnt++;
 
-#ifdef RT2860
     if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE)) &&
         (IDLE_ON(pAd)) &&
 		(pAd->StaCfg.bRadio == TRUE) &&
@@ -236,7 +235,6 @@ VOID MlmeScanReqAction(
 	{
 		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
 	}
-#endif // RT2860 //
 
 	// first check the parameter sanity
 	if (MlmeScanReqSanity(pAd,
@@ -349,7 +347,6 @@ VOID MlmeJoinReqAction(
 
 	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - MlmeJoinReqAction(BSS #%ld)\n", pInfo->BssIdx));
 
-#ifdef RT2860
     if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE)) &&
         (IDLE_ON(pAd)) &&
 		(pAd->StaCfg.bRadio == TRUE) &&
@@ -357,7 +354,6 @@ VOID MlmeJoinReqAction(
 	{
 		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
 	}
-#endif // RT2860 //
 
 	// reset all the timers
 	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
@@ -1532,12 +1528,10 @@ VOID PeerBeacon(
 				//  5. otherwise, put PHY back to sleep to save battery.
 				if (MessageToMe)
 				{
-#ifdef RT2860
 					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE))
 					{
 						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
 					}
-#endif // RT2860 //
 					if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable &&
 						pAd->CommonCfg.bAPSDAC_BE && pAd->CommonCfg.bAPSDAC_BK && pAd->CommonCfg.bAPSDAC_VI && pAd->CommonCfg.bAPSDAC_VO)
 					{
@@ -1548,12 +1542,10 @@ VOID PeerBeacon(
 				}
 				else if (BcastFlag && (DtimCount == 0) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM))
 				{
-#ifdef RT2860
 					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE))
 					{
 						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
 					}
-#endif // RT2860 //
 				}
 				else if ((pAd->TxSwQueue[QID_AC_BK].Number != 0)													||
 						(pAd->TxSwQueue[QID_AC_BE].Number != 0)														||
@@ -1567,12 +1559,10 @@ VOID PeerBeacon(
 				{
 					// TODO: consider scheduled HCCA. might not be proper to use traditional DTIM-based power-saving scheme
 					// can we cheat here (i.e. just check MGMT & AC_BE) for better performance?
-#ifdef RT2860
 					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE))
 					{
 						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
 					}
-#endif // RT2860 //
 				}
 				else
 				{
