From wfp5p@virginia.edu Fri Mar 27 08:31:15 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Fri, 27 Mar 2009 11:31:11 -0400
Subject: Staging: comedi: remove C99 comments in ni_labpc.c
To: greg@kroah.com
Cc: abbotti@mev.co.uk, fmhess@users.sourceforge.net, ds@schleef.org
Message-ID: <20090327153111.7154.40678.stgit@viridian.itc.Virginia.EDU>


Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/comedi/drivers/ni_labpc.c |  378 +++++++++++++++---------------
 1 file changed, 189 insertions(+), 189 deletions(-)

--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -74,7 +74,7 @@ NI manuals:
 */
 
 #undef LABPC_DEBUG
-//#define LABPC_DEBUG   // enable debugging messages
+/* #define LABPC_DEBUG    enable debugging messages */
 
 #include "../comedidev.h"
 
@@ -89,78 +89,78 @@ NI manuals:
 
 #define DRV_NAME "ni_labpc"
 
-#define LABPC_SIZE           32	// size of io region used by board
-#define LABPC_TIMER_BASE            500	// 2 MHz master clock
+#define LABPC_SIZE           32	/*  size of io region used by board */
+#define LABPC_TIMER_BASE            500	/*  2 MHz master clock */
 
 /* Registers for the lab-pc+ */
 
-//write-only registers
+/* write-only registers */
 #define COMMAND1_REG	0x0
 #define   ADC_GAIN_MASK	(0x7 << 4)
 #define   ADC_CHAN_BITS(x)	((x) & 0x7)
-#define   ADC_SCAN_EN_BIT	0x80	// enables multi channel scans
+#define   ADC_SCAN_EN_BIT	0x80	/*  enables multi channel scans */
 #define COMMAND2_REG	0x1
-#define   PRETRIG_BIT	0x1	// enable pretriggering (used in conjunction with SWTRIG)
-#define   HWTRIG_BIT	0x2	// enable paced conversions on external trigger
-#define   SWTRIG_BIT	0x4	// enable paced conversions
-#define   CASCADE_BIT	0x8	// use two cascaded counters for pacing
+#define   PRETRIG_BIT	0x1	/*  enable pretriggering (used in conjunction with SWTRIG) */
+#define   HWTRIG_BIT	0x2	/*  enable paced conversions on external trigger */
+#define   SWTRIG_BIT	0x4	/*  enable paced conversions */
+#define   CASCADE_BIT	0x8	/*  use two cascaded counters for pacing */
 #define   DAC_PACED_BIT(channel)	(0x40 << ((channel) & 0x1))
 #define COMMAND3_REG	0x2
-#define   DMA_EN_BIT	0x1	// enable dma transfers
-#define   DIO_INTR_EN_BIT	0x2	// enable interrupts for 8255
-#define   DMATC_INTR_EN_BIT	0x4	// enable dma terminal count interrupt
-#define   TIMER_INTR_EN_BIT	0x8	// enable timer interrupt
-#define   ERR_INTR_EN_BIT	0x10	// enable error interrupt
-#define   ADC_FNE_INTR_EN_BIT	0x20	// enable fifo not empty interrupt
+#define   DMA_EN_BIT	0x1	/*  enable dma transfers */
+#define   DIO_INTR_EN_BIT	0x2	/*  enable interrupts for 8255 */
+#define   DMATC_INTR_EN_BIT	0x4	/*  enable dma terminal count interrupt */
+#define   TIMER_INTR_EN_BIT	0x8	/*  enable timer interrupt */
+#define   ERR_INTR_EN_BIT	0x10	/*  enable error interrupt */
+#define   ADC_FNE_INTR_EN_BIT	0x20	/*  enable fifo not empty interrupt */
 #define ADC_CONVERT_REG	0x3
 #define DAC_LSB_REG(channel)	(0x4 + 2 * ((channel) & 0x1))
 #define DAC_MSB_REG(channel)	(0x5 + 2 * ((channel) & 0x1))
 #define ADC_CLEAR_REG	0x8
 #define DMATC_CLEAR_REG	0xa
 #define TIMER_CLEAR_REG	0xc
-#define COMMAND6_REG	0xe	// 1200 boards only
-#define   ADC_COMMON_BIT	0x1	// select ground or common-mode reference
-#define   ADC_UNIP_BIT	0x2	// adc unipolar
-#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))	// dac unipolar
-#define   ADC_FHF_INTR_EN_BIT	0x20	// enable fifo half full interrupt
-#define   A1_INTR_EN_BIT	0x40	// enable interrupt on end of hardware count
-#define   ADC_SCAN_UP_BIT 0x80	// scan up from channel zero instead of down to zero
+#define COMMAND6_REG	0xe	/*  1200 boards only */
+#define   ADC_COMMON_BIT	0x1	/*  select ground or common-mode reference */
+#define   ADC_UNIP_BIT	0x2	/*  adc unipolar */
+#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))	/*  dac unipolar */
+#define   ADC_FHF_INTR_EN_BIT	0x20	/*  enable fifo half full interrupt */
+#define   A1_INTR_EN_BIT	0x40	/*  enable interrupt on end of hardware count */
+#define   ADC_SCAN_UP_BIT 0x80	/*  scan up from channel zero instead of down to zero */
 #define COMMAND4_REG	0xf
-#define   INTERVAL_SCAN_EN_BIT	0x1	// enables 'interval' scanning
-#define   EXT_SCAN_EN_BIT	0x2	// enables external signal on counter b1 output to trigger scan
-#define   EXT_CONVERT_OUT_BIT	0x4	// chooses direction (output or input) for EXTCONV* line
-#define   ADC_DIFF_BIT	0x8	// chooses differential inputs for adc (in conjunction with board jumper)
+#define   INTERVAL_SCAN_EN_BIT	0x1	/*  enables 'interval' scanning */
+#define   EXT_SCAN_EN_BIT	0x2	/*  enables external signal on counter b1 output to trigger scan */
+#define   EXT_CONVERT_OUT_BIT	0x4	/*  chooses direction (output or input) for EXTCONV* line */
+#define   ADC_DIFF_BIT	0x8	/*  chooses differential inputs for adc (in conjunction with board jumper) */
 #define   EXT_CONVERT_DISABLE_BIT	0x10
-#define COMMAND5_REG	0x1c	// 1200 boards only, calibration stuff
-#define   EEPROM_WRITE_UNPROTECT_BIT	0x4	// enable eeprom for write
-#define   DITHER_EN_BIT	0x8	// enable dithering
-#define   CALDAC_LOAD_BIT	0x10	// load calibration dac
-#define   SCLOCK_BIT	0x20	// serial clock - rising edge writes, falling edge reads
-#define   SDATA_BIT	0x40	// serial data bit for writing to eeprom or calibration dacs
-#define   EEPROM_EN_BIT	0x80	// enable eeprom for read/write
+#define COMMAND5_REG	0x1c	/*  1200 boards only, calibration stuff */
+#define   EEPROM_WRITE_UNPROTECT_BIT	0x4	/*  enable eeprom for write */
+#define   DITHER_EN_BIT	0x8	/*  enable dithering */
+#define   CALDAC_LOAD_BIT	0x10	/*  load calibration dac */
+#define   SCLOCK_BIT	0x20	/*  serial clock - rising edge writes, falling edge reads */
+#define   SDATA_BIT	0x40	/*  serial data bit for writing to eeprom or calibration dacs */
+#define   EEPROM_EN_BIT	0x80	/*  enable eeprom for read/write */
 #define INTERVAL_COUNT_REG	0x1e
 #define INTERVAL_LOAD_REG	0x1f
 #define   INTERVAL_LOAD_BITS	0x1
 
-// read-only registers
+/* read-only registers */
 #define STATUS1_REG	0x0
-#define   DATA_AVAIL_BIT	0x1	// data is available in fifo
-#define   OVERRUN_BIT	0x2	// overrun has occurred
-#define   OVERFLOW_BIT	0x4	// fifo overflow
-#define   TIMER_BIT	0x8	// timer interrupt has occured
-#define   DMATC_BIT	0x10	// dma terminal count has occured
-#define   EXT_TRIG_BIT	0x40	// external trigger has occured
-#define STATUS2_REG	0x1d	// 1200 boards only
-#define   EEPROM_OUT_BIT	0x1	// programmable eeprom serial output
-#define   A1_TC_BIT	0x2	// counter A1 terminal count
-#define   FNHF_BIT	0x4	// fifo not half full
+#define   DATA_AVAIL_BIT	0x1	/*  data is available in fifo */
+#define   OVERRUN_BIT	0x2	/*  overrun has occurred */
+#define   OVERFLOW_BIT	0x4	/*  fifo overflow */
+#define   TIMER_BIT	0x8	/*  timer interrupt has occured */
+#define   DMATC_BIT	0x10	/*  dma terminal count has occured */
+#define   EXT_TRIG_BIT	0x40	/*  external trigger has occured */
+#define STATUS2_REG	0x1d	/*  1200 boards only */
+#define   EEPROM_OUT_BIT	0x1	/*  programmable eeprom serial output */
+#define   A1_TC_BIT	0x2	/*  counter A1 terminal count */
+#define   FNHF_BIT	0x4	/*  fifo not half full */
 #define ADC_FIFO_REG	0xa
 
 #define DIO_BASE_REG	0x10
 #define COUNTER_A_BASE_REG	0x14
 #define COUNTER_A_CONTROL_REG	(COUNTER_A_BASE_REG + 0x3)
-#define   INIT_A0_BITS	0x14	// check modes put conversion pacer output in harmless state (a0 mode 2)
-#define   INIT_A1_BITS	0x70	// put hardware conversion counter output in harmless state (a1 mode 0)
+#define   INIT_A0_BITS	0x14	/*  check modes put conversion pacer output in harmless state (a0 mode 2) */
+#define   INIT_A1_BITS	0x70	/*  put hardware conversion counter output in harmless state (a1 mode 0) */
 #define COUNTER_B_BASE_REG	0x18
 
 static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it);
@@ -212,9 +212,9 @@ enum scan_mode {
 	MODE_MULT_CHAN_DOWN,
 };
 
-//analog input ranges
+/* analog input ranges */
 #define NUM_LABPC_PLUS_AI_RANGES 16
-// indicates unipolar ranges
+/* indicates unipolar ranges */
 static const int labpc_plus_is_unipolar[NUM_LABPC_PLUS_AI_RANGES] = {
 	0,
 	0,
@@ -234,7 +234,7 @@ static const int labpc_plus_is_unipolar[
 	1,
 };
 
-// map range index to gain bits
+/* map range index to gain bits */
 static const int labpc_plus_ai_gain_bits[NUM_LABPC_PLUS_AI_RANGES] = {
 	0x00,
 	0x10,
@@ -276,7 +276,7 @@ static const struct comedi_lrange range_
 };
 
 #define NUM_LABPC_1200_AI_RANGES 14
-// indicates unipolar ranges
+/* indicates unipolar ranges */
 const int labpc_1200_is_unipolar[NUM_LABPC_1200_AI_RANGES] = {
 	0,
 	0,
@@ -294,7 +294,7 @@ const int labpc_1200_is_unipolar[NUM_LAB
 	1,
 };
 
-// map range index to gain bits
+/* map range index to gain bits */
 const int labpc_1200_ai_gain_bits[NUM_LABPC_1200_AI_RANGES] = {
 	0x00,
 	0x20,
@@ -331,7 +331,7 @@ const struct comedi_lrange range_labpc_1
 		}
 };
 
-//analog output ranges
+/* analog output ranges */
 #define AO_RANGE_IS_UNIPOLAR 0x1
 static const struct comedi_lrange range_labpc_ao = {
 	2,
@@ -411,7 +411,7 @@ static const struct labpc_board_struct l
 		ai_scan_up:1,
 		memory_mapped_io:1,
 		},
-	// dummy entry so pci board works when comedi_config is passed driver name
+	/*  dummy entry so pci board works when comedi_config is passed driver name */
 	{
 		.name = DRV_NAME,
 		.bustype = pci_bustype,
@@ -424,8 +424,8 @@ static const struct labpc_board_struct l
  */
 #define thisboard ((struct labpc_board_struct *)dev->board_ptr)
 
-static const int dma_buffer_size = 0xff00;	// size in bytes of dma buffer
-static const int sample_size = 2;	// 2 bytes per sample
+static const int dma_buffer_size = 0xff00;	/*  size in bytes of dma buffer */
+static const int sample_size = 2;	/*  2 bytes per sample */
 
 #define devpriv ((struct labpc_private *)dev->private)
 
@@ -481,7 +481,7 @@ int labpc_common_attach(struct comedi_de
 		printk("io base address is zero!\n");
 		return -EINVAL;
 	}
-	// request io regions for isa boards
+	/*  request io regions for isa boards */
 	if (thisboard->bustype == isa_bustype) {
 		/* check if io addresses are available */
 		if (!request_region(iobase, LABPC_SIZE,
@@ -499,7 +499,7 @@ int labpc_common_attach(struct comedi_de
 		devpriv->read_byte = labpc_inb;
 		devpriv->write_byte = labpc_outb;
 	}
-	// initialize board's command registers
+	/*  initialize board's command registers */
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
@@ -524,12 +524,12 @@ int labpc_common_attach(struct comedi_de
 	}
 	dev->irq = irq;
 
-	// grab dma channel
+	/*  grab dma channel */
 	if (dma_chan > 3) {
 		printk(" invalid dma channel %u\n", dma_chan);
 		return -EINVAL;
 	} else if (dma_chan) {
-		// allocate dma buffer
+		/*  allocate dma buffer */
 		devpriv->dma_buffer =
 			kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL) {
@@ -562,7 +562,7 @@ int labpc_common_attach(struct comedi_de
 		SDF_CMD_READ;
 	s->n_chan = 8;
 	s->len_chanlist = 8;
-	s->maxdata = (1 << 12) - 1;	// 12 bit resolution
+	s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
 	s->range_table = thisboard->ai_range_table;
 	s->do_cmd = labpc_ai_cmd;
 	s->do_cmdtest = labpc_ai_cmdtest;
@@ -577,7 +577,7 @@ int labpc_common_attach(struct comedi_de
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = NUM_AO_CHAN;
-		s->maxdata = (1 << 12) - 1;	// 12 bit resolution
+		s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
 		s->range_table = &range_labpc_ao;
 		s->insn_read = labpc_ao_rinsn;
 		s->insn_write = labpc_ao_winsn;
@@ -595,14 +595,14 @@ int labpc_common_attach(struct comedi_de
 
 	/* 8255 dio */
 	s = dev->subdevices + 2;
-	// if board uses io memory we have to give a custom callback function to the 8255 driver
+	/*  if board uses io memory we have to give a custom callback function to the 8255 driver */
 	if (thisboard->memory_mapped_io)
 		subdev_8255_init(dev, s, labpc_dio_mem_callback,
 			(unsigned long)(dev->iobase + DIO_BASE_REG));
 	else
 		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
 
-	// calibration subdevices for boards that have one
+	/*  calibration subdevices for boards that have one */
 	s = dev->subdevices + 3;
 	if (thisboard->register_layout == labpc_1200_layout) {
 		s->type = COMEDI_SUBD_CALIB;
@@ -656,7 +656,7 @@ static int labpc_attach(struct comedi_de
 	if (alloc_private(dev, sizeof(struct labpc_private)) < 0)
 		return -ENOMEM;
 
-	// get base address, irq etc. based on bustype
+	/*  get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
 	case isa_bustype:
 		iobase = it->options[0];
@@ -692,7 +692,7 @@ static int labpc_attach(struct comedi_de
 	return labpc_common_attach(dev, iobase, irq, dma_chan);
 }
 
-// adapted from ni_pcimio for finding mite based boards (pc-1200)
+/* adapted from ni_pcimio for finding mite based boards (pc-1200) */
 #ifdef CONFIG_COMEDI_PCI
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot)
 {
@@ -701,7 +701,7 @@ static int labpc_find_device(struct come
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
-		// if bus/slot are specified then make sure we have the right bus/slot
+		/*  if bus/slot are specified then make sure we have the right bus/slot */
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number
 				|| slot != PCI_SLOT(mite->pcidev->devfn))
@@ -712,7 +712,7 @@ static int labpc_find_device(struct come
 				continue;
 			if (mite_device_id(mite) == labpc_boards[i].device_id) {
 				devpriv->mite = mite;
-				// fixup board pointer, in case we were using the dummy "ni_labpc" entry
+				/*  fixup board pointer, in case we were using the dummy "ni_labpc" entry */
 				dev->board_ptr = &labpc_boards[i];
 				return 0;
 			}
@@ -980,7 +980,7 @@ static int labpc_ai_cmdtest(struct comed
 		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
-	// can't have external stop and start triggers at once
+	/*  can't have external stop and start triggers at once */
 	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
 		err++;
 
@@ -1008,7 +1008,7 @@ static int labpc_ai_cmdtest(struct comed
 			err++;
 		}
 	}
-	// make sure scan timing is not too fast
+	/*  make sure scan timing is not too fast */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->convert_src == TRIG_TIMER &&
 			cmd->scan_begin_arg <
@@ -1024,7 +1024,7 @@ static int labpc_ai_cmdtest(struct comed
 			err++;
 		}
 	}
-	// stop source
+	/*  stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		if (!cmd->stop_arg) {
@@ -1038,7 +1038,7 @@ static int labpc_ai_cmdtest(struct comed
 			err++;
 		}
 		break;
-		// TRIG_EXT doesn't care since it doesn't trigger off a numbered channel
+		/*  TRIG_EXT doesn't care since it doesn't trigger off a numbered channel */
 	default:
 		break;
 	}
@@ -1081,7 +1081,7 @@ static int labpc_ai_cmd(struct comedi_de
 	range = CR_RANGE(cmd->chanlist[0]);
 	aref = CR_AREF(cmd->chanlist[0]);
 
-	// make sure board is disabled before setting up aquisition
+	/*  make sure board is disabled before setting up aquisition */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
@@ -1090,68 +1090,68 @@ static int labpc_ai_cmd(struct comedi_de
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	// initialize software conversion count
+	/*  initialize software conversion count */
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 	}
-	// setup hardware conversion counter
+	/*  setup hardware conversion counter */
 	if (cmd->stop_src == TRIG_EXT) {
-		// load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0
+		/*  load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
 			1, 3, 0);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a1");
 			return -1;
 		}
-	} else			// otherwise, just put a1 in mode 0 with no count to set its output low
+	} else			/*  otherwise, just put a1 in mode 0 with no count to set its output low */
 		devpriv->write_byte(INIT_A1_BITS,
 			dev->iobase + COUNTER_A_CONTROL_REG);
 
-	// figure out what method we will use to transfer data
-	if (devpriv->dma_chan &&	// need a dma channel allocated
-		// dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for
+	/*  figure out what method we will use to transfer data */
+	if (devpriv->dma_chan &&	/*  need a dma channel allocated */
+		/*  dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for */
 		(cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
-		// only available on the isa boards
+		/*  only available on the isa boards */
 		thisboard->bustype == isa_bustype) {
 		xfer = isa_dma_transfer;
-	} else if (thisboard->register_layout == labpc_1200_layout &&	// pc-plus has no fifo-half full interrupt
-		// wake-end-of-scan should interrupt on fifo not empty
+	} else if (thisboard->register_layout == labpc_1200_layout &&	/*  pc-plus has no fifo-half full interrupt */
+		/*  wake-end-of-scan should interrupt on fifo not empty */
 		(cmd->flags & TRIG_WAKE_EOS) == 0 &&
-		// make sure we are taking more than just a few points
+		/*  make sure we are taking more than just a few points */
 		(cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {
 		xfer = fifo_half_full_transfer;
 	} else
 		xfer = fifo_not_empty_transfer;
 	devpriv->current_transfer = xfer;
 
-	// setup command6 register for 1200 boards
+	/*  setup command6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
-		// reference inputs to ground or common?
+		/*  reference inputs to ground or common? */
 		if (aref != AREF_GROUND)
 			devpriv->command6_bits |= ADC_COMMON_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_COMMON_BIT;
-		// bipolar or unipolar range?
+		/*  bipolar or unipolar range? */
 		if (thisboard->ai_range_is_unipolar[range])
 			devpriv->command6_bits |= ADC_UNIP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_UNIP_BIT;
-		// interrupt on fifo half full?
+		/*  interrupt on fifo half full? */
 		if (xfer == fifo_half_full_transfer)
 			devpriv->command6_bits |= ADC_FHF_INTR_EN_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
-		// enable interrupt on counter a1 terminal count?
+		/*  enable interrupt on counter a1 terminal count? */
 		if (cmd->stop_src == TRIG_EXT)
 			devpriv->command6_bits |= A1_INTR_EN_BIT;
 		else
 			devpriv->command6_bits &= ~A1_INTR_EN_BIT;
-		// are we scanning up or down through channels?
+		/*  are we scanning up or down through channels? */
 		if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP)
 			devpriv->command6_bits |= ADC_SCAN_UP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_SCAN_UP_BIT;
-		// write to register
+		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
 			dev->iobase + COMMAND6_REG);
 	}
@@ -1162,13 +1162,13 @@ static int labpc_ai_cmd(struct comedi_de
 		channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
 	else
 		channel = CR_CHAN(cmd->chanlist[0]);
-	// munge channel bits for differential / scan disabled mode
+	/*  munge channel bits for differential / scan disabled mode */
 	if (labpc_ai_scan_mode(cmd) != MODE_SINGLE_CHAN && aref == AREF_DIFF)
 		channel *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(channel);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
-	// manual says to set scan enable bit on second pass
+	/*  manual says to set scan enable bit on second pass */
 	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||
 		labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
@@ -1178,7 +1178,7 @@ static int labpc_ai_cmd(struct comedi_de
 		devpriv->write_byte(devpriv->command1_bits,
 			dev->iobase + COMMAND1_REG);
 	}
-	// setup any external triggering/pacing (command4 register)
+	/*  setup any external triggering/pacing (command4 register) */
 	devpriv->command4_bits = 0;
 	if (cmd->convert_src != TRIG_EXT)
 		devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
@@ -1189,21 +1189,21 @@ static int labpc_ai_cmd(struct comedi_de
 		if (cmd->scan_begin_src == TRIG_EXT)
 			devpriv->command4_bits |= EXT_SCAN_EN_BIT;
 	}
-	// single-ended/differential
+	/*  single-ended/differential */
 	if (aref == AREF_DIFF)
 		devpriv->command4_bits |= ADC_DIFF_BIT;
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
 	devpriv->write_byte(cmd->chanlist_len,
 		dev->iobase + INTERVAL_COUNT_REG);
-	// load count
+	/*  load count */
 	devpriv->write_byte(INTERVAL_LOAD_BITS,
 		dev->iobase + INTERVAL_LOAD_REG);
 
 	if (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) {
-		// set up pacing
+		/*  set up pacing */
 		labpc_adc_timing(dev, cmd);
-		// load counter b0 in mode 3
+		/*  load counter b0 in mode 3 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
 			0, devpriv->divisor_b0, 3);
 		if (ret < 0) {
@@ -1211,9 +1211,9 @@ static int labpc_ai_cmd(struct comedi_de
 			return -1;
 		}
 	}
-	// set up conversion pacing
+	/*  set up conversion pacing */
 	if (labpc_ai_convert_period(cmd)) {
-		// load counter a0 in mode 2
+		/*  load counter a0 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
 			0, devpriv->divisor_a0, 2);
 		if (ret < 0) {
@@ -1224,9 +1224,9 @@ static int labpc_ai_cmd(struct comedi_de
 		devpriv->write_byte(INIT_A0_BITS,
 			dev->iobase + COUNTER_A_CONTROL_REG);
 
-	// set up scan pacing
+	/*  set up scan pacing */
 	if (labpc_ai_scan_period(cmd)) {
-		// load counter b1 in mode 2
+		/*  load counter b1 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
 			1, devpriv->divisor_b1, 2);
 		if (ret < 0) {
@@ -1237,7 +1237,7 @@ static int labpc_ai_cmd(struct comedi_de
 
 	labpc_clear_adc_fifo(dev);
 
-	// set up dma transfer
+	/*  set up dma transfer */
 	if (xfer == isa_dma_transfer) {
 		irq_flags = claim_dma_lock();
 		disable_dma(devpriv->dma_chan);
@@ -1246,7 +1246,7 @@ static int labpc_ai_cmd(struct comedi_de
 		clear_dma_ff(devpriv->dma_chan);
 		set_dma_addr(devpriv->dma_chan,
 			virt_to_bus(devpriv->dma_buffer));
-		// set appropriate size of transfer
+		/*  set appropriate size of transfer */
 		devpriv->dma_transfer_size = labpc_suggest_transfer_size(*cmd);
 		if (cmd->stop_src == TRIG_COUNT &&
 			devpriv->count * sample_size <
@@ -1257,24 +1257,24 @@ static int labpc_ai_cmd(struct comedi_de
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
 		release_dma_lock(irq_flags);
-		// enable board's dma
+		/*  enable board's dma */
 		devpriv->command3_bits |= DMA_EN_BIT | DMATC_INTR_EN_BIT;
 	} else
 		devpriv->command3_bits &= ~DMA_EN_BIT & ~DMATC_INTR_EN_BIT;
 
-	// enable error interrupts
+	/*  enable error interrupts */
 	devpriv->command3_bits |= ERR_INTR_EN_BIT;
-	// enable fifo not empty interrupt?
+	/*  enable fifo not empty interrupt? */
 	if (xfer == fifo_not_empty_transfer)
 		devpriv->command3_bits |= ADC_FNE_INTR_EN_BIT;
 	else
 		devpriv->command3_bits &= ~ADC_FNE_INTR_EN_BIT;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	// startup aquisition
+	/*  startup aquisition */
 
-	// command2 reg
-	// use 2 cascaded counters for pacing
+	/*  command2 reg */
+	/*  use 2 cascaded counters for pacing */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits |= CASCADE_BIT;
 	switch (cmd->start_src) {
@@ -1325,7 +1325,7 @@ static irqreturn_t labpc_interrupt(int i
 	cmd = &async->cmd;
 	async->events = 0;
 
-	// read board status
+	/*  read board status */
 	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	if (thisboard->register_layout == labpc_1200_layout)
 		devpriv->status2_bits =
@@ -1339,7 +1339,7 @@ static irqreturn_t labpc_interrupt(int i
 	}
 
 	if (devpriv->status1_bits & OVERRUN_BIT) {
-		// clear error interrupt
+		/*  clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
@@ -1348,7 +1348,7 @@ static irqreturn_t labpc_interrupt(int i
 	}
 
 	if (devpriv->current_transfer == isa_dma_transfer) {
-		// if a dma terminal count of external stop trigger has occurred
+		/*  if a dma terminal count of external stop trigger has occurred */
 		if (devpriv->status1_bits & DMATC_BIT ||
 			(thisboard->register_layout == labpc_1200_layout
 				&& devpriv->status2_bits & A1_TC_BIT)) {
@@ -1359,19 +1359,19 @@ static irqreturn_t labpc_interrupt(int i
 
 	if (devpriv->status1_bits & TIMER_BIT) {
 		comedi_error(dev, "handled timer interrupt?");
-		// clear it
+		/*  clear it */
 		devpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);
 	}
 
 	if (devpriv->status1_bits & OVERFLOW_BIT) {
-		// clear error interrupt
+		/*  clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
 		comedi_error(dev, "overflow");
 		return IRQ_HANDLED;
 	}
-	// handle external stop trigger
+	/*  handle external stop trigger */
 	if (cmd->stop_src == TRIG_EXT) {
 		if (devpriv->status2_bits & A1_TC_BIT) {
 			labpc_drain_dregs(dev);
@@ -1392,7 +1392,7 @@ static irqreturn_t labpc_interrupt(int i
 	return IRQ_HANDLED;
 }
 
-// read all available samples from ai fifo
+/* read all available samples from ai fifo */
 static int labpc_drain_fifo(struct comedi_device * dev)
 {
 	unsigned int lsb, msb;
@@ -1405,7 +1405,7 @@ static int labpc_drain_fifo(struct comed
 
 	for (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;
 		i++) {
-		// quit if we have all the data we want
+		/*  quit if we have all the data we want */
 		if (async->cmd.stop_src == TRIG_COUNT) {
 			if (devpriv->count == 0)
 				break;
@@ -1444,7 +1444,7 @@ static void labpc_drain_dma(struct comed
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv->dma_chan);
 
-	// figure out how many points to read
+	/*  figure out how many points to read */
 	max_points = devpriv->dma_transfer_size / sample_size;
 	/* residue is the number of points left to be done on the dma
 	 * transfer.  It should always be zero at this point unless
@@ -1455,7 +1455,7 @@ static void labpc_drain_dma(struct comed
 	if (devpriv->count < num_points && async->cmd.stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
 
-	// figure out how many points will be stored next time
+	/*  figure out how many points will be stored next time */
 	leftover = 0;
 	if (async->cmd.stop_src != TRIG_COUNT) {
 		leftover = devpriv->dma_transfer_size / sample_size;
@@ -1472,7 +1472,7 @@ static void labpc_drain_dma(struct comed
 	if (async->cmd.stop_src == TRIG_COUNT)
 		devpriv->count -= num_points;
 
-	// set address and count for next transfer
+	/*  set address and count for next transfer */
 	set_dma_addr(devpriv->dma_chan, virt_to_bus(devpriv->dma_buffer));
 	set_dma_count(devpriv->dma_chan, leftover * sample_size);
 	release_dma_lock(flags);
@@ -1486,7 +1486,7 @@ static void handle_isa_dma(struct comedi
 
 	enable_dma(devpriv->dma_chan);
 
-	// clear dma tc interrupt
+	/*  clear dma tc interrupt */
 	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
 }
 
@@ -1509,13 +1509,13 @@ static int labpc_ai_rinsn(struct comedi_
 	int timeout = 1000;
 	unsigned long flags;
 
-	// disable timed conversions
+	/*  disable timed conversions */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// disable interrupt generation and dma
+	/*  disable interrupt generation and dma */
 	devpriv->command3_bits = 0;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
@@ -1524,41 +1524,41 @@ static int labpc_ai_rinsn(struct comedi_
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
-	// munge channel bits for differential/scan disabled mode
+	/*  munge channel bits for differential/scan disabled mode */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		chan *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(chan);
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 
-	// setup command6 register for 1200 boards
+	/*  setup command6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
-		// reference inputs to ground or common?
+		/*  reference inputs to ground or common? */
 		if (CR_AREF(insn->chanspec) != AREF_GROUND)
 			devpriv->command6_bits |= ADC_COMMON_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_COMMON_BIT;
-		// bipolar or unipolar range?
+		/*  bipolar or unipolar range? */
 		if (thisboard->ai_range_is_unipolar[range])
 			devpriv->command6_bits |= ADC_UNIP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_UNIP_BIT;
-		// don't interrupt on fifo half full
+		/*  don't interrupt on fifo half full */
 		devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
-		// don't enable interrupt on counter a1 terminal count?
+		/*  don't enable interrupt on counter a1 terminal count? */
 		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
-		// write to register
+		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
 			dev->iobase + COMMAND6_REG);
 	}
-	// setup command4 register
+	/*  setup command4 register */
 	devpriv->command4_bits = 0;
 	devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
-	// single-ended/differential
+	/*  single-ended/differential */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		devpriv->command4_bits |= ADC_DIFF_BIT;
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
-	// initialize pacer counter output to make sure it doesn't cause any problems
+	/*  initialize pacer counter output to make sure it doesn't cause any problems */
 	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
 
 	labpc_clear_adc_fifo(dev);
@@ -1585,7 +1585,7 @@ static int labpc_ai_rinsn(struct comedi_
 	return n;
 }
 
-// analog output insn
+/* analog output insn */
 static int labpc_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
@@ -1595,7 +1595,7 @@ static int labpc_ao_winsn(struct comedi_
 
 	channel = CR_CHAN(insn->chanspec);
 
-	// turn off pacing of analog output channel
+	/*  turn off pacing of analog output channel */
 	/* note: hardware bug in daqcard-1200 means pacing cannot
 	 * be independently enabled/disabled for its the two channels */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
@@ -1603,30 +1603,30 @@ static int labpc_ao_winsn(struct comedi_
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// set range
+	/*  set range */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		range = CR_RANGE(insn->chanspec);
 		if (range & AO_RANGE_IS_UNIPOLAR)
 			devpriv->command6_bits |= DAC_UNIP_BIT(channel);
 		else
 			devpriv->command6_bits &= ~DAC_UNIP_BIT(channel);
-		// write to register
+		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
 			dev->iobase + COMMAND6_REG);
 	}
-	// send data
+	/*  send data */
 	lsb = data[0] & 0xff;
 	msb = (data[0] >> 8) & 0xff;
 	devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));
 	devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));
 
-	// remember value for readback
+	/*  remember value for readback */
 	devpriv->ao_value[channel] = data[0];
 
 	return 1;
 }
 
-// analog output readback insn
+/* analog output readback insn */
 static int labpc_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
@@ -1666,7 +1666,7 @@ static int labpc_eeprom_write_insn(struc
 	int channel = CR_CHAN(insn->chanspec);
 	int ret;
 
-	// only allow writes to user area of eeprom
+	/*  only allow writes to user area of eeprom */
 	if (channel < 16 || channel > 127) {
 		printk("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");
 		return -EINVAL;
@@ -1679,7 +1679,7 @@ static int labpc_eeprom_write_insn(struc
 	return 1;
 }
 
-// utility function that suggests a dma transfer size in bytes
+/* utility function that suggests a dma transfer size in bytes */
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)
 {
 	unsigned int size;
@@ -1687,14 +1687,14 @@ static unsigned int labpc_suggest_transf
 
 	if (cmd.convert_src == TRIG_TIMER)
 		freq = 1000000000 / cmd.convert_arg;
-	// return some default value
+	/*  return some default value */
 	else
 		freq = 0xffffffff;
 
-	// make buffer fill in no more than 1/3 second
+	/*  make buffer fill in no more than 1/3 second */
 	size = (freq / 3) * sample_size;
 
-	// set a minimum and maximum size allowed
+	/*  set a minimum and maximum size allowed */
 	if (size > dma_buffer_size)
 		size = dma_buffer_size - dma_buffer_size % sample_size;
 	else if (size < sample_size)
@@ -1703,16 +1703,16 @@ static unsigned int labpc_suggest_transf
 	return size;
 }
 
-// figures out what counter values to use based on command
+/* figures out what counter values to use based on command */
 static void labpc_adc_timing(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
-	const int max_counter_value = 0x10000;	// max value for 16 bit counter in mode 2
-	const int min_counter_value = 2;	// min value for 16 bit counter in mode 2
+	const int max_counter_value = 0x10000;	/*  max value for 16 bit counter in mode 2 */
+	const int min_counter_value = 2;	/*  min value for 16 bit counter in mode 2 */
 	unsigned int base_period;
 
-	// if both convert and scan triggers are TRIG_TIMER, then they both rely on counter b0
+	/*  if both convert and scan triggers are TRIG_TIMER, then they both rely on counter b0 */
 	if (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {
-		// pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters)
+		/*  pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters) */
 		devpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /
 			(LABPC_TIMER_BASE * max_counter_value) + 1;
 		if (devpriv->divisor_b0 < min_counter_value)
@@ -1722,7 +1722,7 @@ static void labpc_adc_timing(struct come
 
 		base_period = LABPC_TIMER_BASE * devpriv->divisor_b0;
 
-		// set a0 for conversion frequency and b1 for scan frequency
+		/*  set a0 for conversion frequency and b1 for scan frequency */
 		switch (cmd->flags & TRIG_ROUND_MASK) {
 		default:
 		case TRIG_ROUND_NEAREST:
@@ -1748,7 +1748,7 @@ static void labpc_adc_timing(struct come
 				labpc_ai_scan_period(cmd) / base_period;
 			break;
 		}
-		// make sure a0 and b1 values are acceptable
+		/*  make sure a0 and b1 values are acceptable */
 		if (devpriv->divisor_a0 < min_counter_value)
 			devpriv->divisor_a0 = min_counter_value;
 		if (devpriv->divisor_a0 > max_counter_value)
@@ -1757,12 +1757,12 @@ static void labpc_adc_timing(struct come
 			devpriv->divisor_b1 = min_counter_value;
 		if (devpriv->divisor_b1 > max_counter_value)
 			devpriv->divisor_b1 = max_counter_value;
-		// write corrected timings to command
+		/*  write corrected timings to command */
 		labpc_set_ai_convert_period(cmd,
 			base_period * devpriv->divisor_a0);
 		labpc_set_ai_scan_period(cmd,
 			base_period * devpriv->divisor_b1);
-		// if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions
+		/*  if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions */
 	} else if (labpc_ai_scan_period(cmd)) {
 		unsigned int scan_period;
 
@@ -1795,16 +1795,16 @@ static int labpc_dio_mem_callback(int di
 	}
 }
 
-// lowlevel write to eeprom/dac
+/* lowlevel write to eeprom/dac */
 static void labpc_serial_out(struct comedi_device * dev, unsigned int value,
 	unsigned int value_width)
 {
 	int i;
 
 	for (i = 1; i <= value_width; i++) {
-		// clear serial clock
+		/*  clear serial clock */
 		devpriv->command5_bits &= ~SCLOCK_BIT;
-		// send bits most significant bit first
+		/*  send bits most significant bit first */
 		if (value & (1 << (value_width - i)))
 			devpriv->command5_bits |= SDATA_BIT;
 		else
@@ -1812,7 +1812,7 @@ static void labpc_serial_out(struct come
 		comedi_udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
-		// set clock to load bit
+		/*  set clock to load bit */
 		devpriv->command5_bits |= SCLOCK_BIT;
 		comedi_udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
@@ -1820,25 +1820,25 @@ static void labpc_serial_out(struct come
 	}
 }
 
-// lowlevel read from eeprom
+/* lowlevel read from eeprom */
 static unsigned int labpc_serial_in(struct comedi_device * dev)
 {
 	unsigned int value = 0;
 	int i;
-	const int value_width = 8;	// number of bits wide values are
+	const int value_width = 8;	/*  number of bits wide values are */
 
 	for (i = 1; i <= value_width; i++) {
-		// set serial clock
+		/*  set serial clock */
 		devpriv->command5_bits |= SCLOCK_BIT;
 		comedi_udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
-		// clear clock bit
+		/*  clear clock bit */
 		devpriv->command5_bits &= ~SCLOCK_BIT;
 		comedi_udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
 			dev->iobase + COMMAND5_REG);
-		// read bits most significant bit first
+		/*  read bits most significant bit first */
 		comedi_udelay(1);
 		devpriv->status2_bits =
 			devpriv->read_byte(dev->iobase + STATUS2_REG);
@@ -1853,10 +1853,10 @@ static unsigned int labpc_serial_in(stru
 static unsigned int labpc_eeprom_read(struct comedi_device * dev, unsigned int address)
 {
 	unsigned int value;
-	const int read_instruction = 0x3;	// bits to tell eeprom to expect a read
-	const int write_length = 8;	// 8 bit write lengths to eeprom
+	const int read_instruction = 0x3;	/*  bits to tell eeprom to expect a read */
+	const int write_length = 8;	/*  8 bit write lengths to eeprom */
 
-	// enable read/write to eeprom
+	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1864,14 +1864,14 @@ static unsigned int labpc_eeprom_read(st
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// send read instruction
+	/*  send read instruction */
 	labpc_serial_out(dev, read_instruction, write_length);
-	// send 8 bit address to read from
+	/*  send 8 bit address to read from */
 	labpc_serial_out(dev, address, write_length);
-	// read result
+	/*  read result */
 	value = labpc_serial_in(dev);
 
-	// disable read/write to eeprom
+	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1884,12 +1884,12 @@ static unsigned int labpc_eeprom_write(s
 {
 	const int write_enable_instruction = 0x6;
 	const int write_instruction = 0x2;
-	const int write_length = 8;	// 8 bit write lengths to eeprom
+	const int write_length = 8;	/*  8 bit write lengths to eeprom */
 	const int write_in_progress_bit = 0x1;
 	const int timeout = 10000;
 	int i;
 
-	// make sure there isn't already a write in progress
+	/*  make sure there isn't already a write in progress */
 	for (i = 0; i < timeout; i++) {
 		if ((labpc_eeprom_read_status(dev) & write_in_progress_bit) ==
 			0)
@@ -1899,10 +1899,10 @@ static unsigned int labpc_eeprom_write(s
 		comedi_error(dev, "eeprom write timed out");
 		return -ETIME;
 	}
-	// update software copy of eeprom
+	/*  update software copy of eeprom */
 	devpriv->eeprom_data[address] = value;
 
-	// enable read/write to eeprom
+	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1910,26 +1910,26 @@ static unsigned int labpc_eeprom_write(s
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// send write_enable instruction
+	/*  send write_enable instruction */
 	labpc_serial_out(dev, write_enable_instruction, write_length);
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// send write instruction
+	/*  send write instruction */
 	devpriv->command5_bits |= EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 	labpc_serial_out(dev, write_instruction, write_length);
-	// send 8 bit address to write to
+	/*  send 8 bit address to write to */
 	labpc_serial_out(dev, address, write_length);
-	// write value
+	/*  write value */
 	labpc_serial_out(dev, value, write_length);
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// disable read/write to eeprom
+	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1941,9 +1941,9 @@ static unsigned int labpc_eeprom_read_st
 {
 	unsigned int value;
 	const int read_status_instruction = 0x5;
-	const int write_length = 8;	// 8 bit write lengths to eeprom
+	const int write_length = 8;	/*  8 bit write lengths to eeprom */
 
-	// enable read/write to eeprom
+	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1951,12 +1951,12 @@ static unsigned int labpc_eeprom_read_st
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// send read status instruction
+	/*  send read status instruction */
 	labpc_serial_out(dev, read_status_instruction, write_length);
-	// read result
+	/*  read result */
 	value = labpc_serial_in(dev);
 
-	// disable read/write to eeprom
+	/*  disable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
@@ -1964,7 +1964,7 @@ static unsigned int labpc_eeprom_read_st
 	return value;
 }
 
-// writes to 8 bit calibration dacs
+/* writes to 8 bit calibration dacs */
 static void write_caldac(struct comedi_device * dev, unsigned int channel,
 	unsigned int value)
 {
@@ -1972,18 +1972,18 @@ static void write_caldac(struct comedi_d
 		return;
 	devpriv->caldac[channel] = value;
 
-	// clear caldac load bit and make sure we don't write to eeprom
+	/*  clear caldac load bit and make sure we don't write to eeprom */
 	devpriv->command5_bits &=
 		~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
-	// write 4 bit channel
+	/*  write 4 bit channel */
 	labpc_serial_out(dev, channel, 4);
-	// write 8 bit caldac value
+	/*  write 8 bit caldac value */
 	labpc_serial_out(dev, value, 8);
 
-	// set and clear caldac bit to load caldac value
+	/*  set and clear caldac bit to load caldac value */
 	devpriv->command5_bits |= CALDAC_LOAD_BIT;
 	comedi_udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
