From alan@lxorguk.ukuu.org.uk  Tue Jun 23 14:49:09 2009
From: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date: Wed, 10 Jun 2009 17:30:41 +0100
Subject: Staging: et1310: Fix the coding style
To: greg@kroah.com
Message-ID: <20090610163040.24035.89058.stgit@t61.ukuu.org.uk>


From: Alan Cox <alan@linux.intel.com>

UTF-8 for copyright symbols etc included. Typedefs and anything else which
would cause actual code changes skipped.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/et131x/et1310_address_map.h | 2214 ++++++++++++++--------------
 drivers/staging/et131x/et1310_eeprom.c      |   46 
 drivers/staging/et131x/et1310_eeprom.h      |    6 
 drivers/staging/et131x/et1310_jagcore.c     |   20 
 drivers/staging/et131x/et1310_jagcore.h     |   17 
 drivers/staging/et131x/et1310_mac.c         |  112 -
 drivers/staging/et131x/et1310_mac.h         |    8 
 drivers/staging/et131x/et1310_phy.c         |  202 +-
 drivers/staging/et131x/et1310_phy.h         |  940 +++++------
 drivers/staging/et131x/et1310_pm.c          |   19 
 drivers/staging/et131x/et1310_pm.h          |    8 
 drivers/staging/et131x/et1310_rx.c          |  115 -
 drivers/staging/et131x/et1310_rx.h          |  194 +-
 drivers/staging/et131x/et1310_tx.c          |  120 -
 drivers/staging/et131x/et1310_tx.h          |  102 -
 drivers/staging/et131x/et131x_adapter.h     |   74 
 drivers/staging/et131x/et131x_config.c      |   38 
 drivers/staging/et131x/et131x_debug.c       |   12 
 drivers/staging/et131x/et131x_debug.h       |   24 
 drivers/staging/et131x/et131x_defs.h        |   12 
 drivers/staging/et131x/et131x_initpci.c     |   74 
 drivers/staging/et131x/et131x_initpci.h     |    6 
 drivers/staging/et131x/et131x_isr.c         |   44 
 drivers/staging/et131x/et131x_isr.h         |    6 
 drivers/staging/et131x/et131x_netdev.c      |  123 -
 drivers/staging/et131x/et131x_netdev.h      |    6 
 drivers/staging/et131x/et131x_version.h     |    6 
 27 files changed, 2245 insertions(+), 2303 deletions(-)

--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -65,11 +65,11 @@ typedef union _Q_ADDR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:22;	// bits 10-31
-		u32 addr:10;	// bits 0-9
+		u32 unused:22;	/* bits 10-31 */
+		u32 addr:10;	/* bits 0-9 */
 #else
-		u32 addr:10;	// bits 0-9
-		u32 unused:22;	// bits 10-31
+		u32 addr:10;	/* bits 0-9 */
+		u32 unused:22;	/* bits 10-31 */
 #endif
 	} bits;
 } Q_ADDR_t, *PQ_ADDR_t;
@@ -106,29 +106,29 @@ typedef union _PM_CSR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:22;		// bits 10-31
-		u32 pm_jagcore_rx_rdy:1;	// bit 9
-		u32 pm_jagcore_tx_rdy:1;	// bit 8
-		u32 pm_phy_lped_en:1;	// bit 7
-		u32 pm_phy_sw_coma:1;	// bit 6
-		u32 pm_rxclk_gate:1;	// bit 5
-		u32 pm_txclk_gate:1;	// bit 4
-		u32 pm_sysclk_gate:1;	// bit 3
-		u32 pm_jagcore_rx_en:1;	// bit 2
-		u32 pm_jagcore_tx_en:1;	// bit 1
-		u32 pm_gigephy_en:1;	// bit 0
-#else
-		u32 pm_gigephy_en:1;	// bit 0
-		u32 pm_jagcore_tx_en:1;	// bit 1
-		u32 pm_jagcore_rx_en:1;	// bit 2
-		u32 pm_sysclk_gate:1;	// bit 3
-		u32 pm_txclk_gate:1;	// bit 4
-		u32 pm_rxclk_gate:1;	// bit 5
-		u32 pm_phy_sw_coma:1;	// bit 6
-		u32 pm_phy_lped_en:1;	// bit 7
-		u32 pm_jagcore_tx_rdy:1;	// bit 8
-		u32 pm_jagcore_rx_rdy:1;	// bit 9
-		u32 unused:22;		// bits 10-31
+		u32 unused:22;		/* bits 10-31 */
+		u32 pm_jagcore_rx_rdy:1;	/* bit 9 */
+		u32 pm_jagcore_tx_rdy:1;	/* bit 8 */
+		u32 pm_phy_lped_en:1;	/* bit 7 */
+		u32 pm_phy_sw_coma:1;	/* bit 6 */
+		u32 pm_rxclk_gate:1;	/* bit 5 */
+		u32 pm_txclk_gate:1;	/* bit 4 */
+		u32 pm_sysclk_gate:1;	/* bit 3 */
+		u32 pm_jagcore_rx_en:1;	/* bit 2 */
+		u32 pm_jagcore_tx_en:1;	/* bit 1 */
+		u32 pm_gigephy_en:1;	/* bit 0 */
+#else
+		u32 pm_gigephy_en:1;	/* bit 0 */
+		u32 pm_jagcore_tx_en:1;	/* bit 1 */
+		u32 pm_jagcore_rx_en:1;	/* bit 2 */
+		u32 pm_sysclk_gate:1;	/* bit 3 */
+		u32 pm_txclk_gate:1;	/* bit 4 */
+		u32 pm_rxclk_gate:1;	/* bit 5 */
+		u32 pm_phy_sw_coma:1;	/* bit 6 */
+		u32 pm_phy_lped_en:1;	/* bit 7 */
+		u32 pm_jagcore_tx_rdy:1;	/* bit 8 */
+		u32 pm_jagcore_rx_rdy:1;	/* bit 9 */
+		u32 unused:22;		/* bits 10-31 */
 #endif
 	} bits;
 } PM_CSR_t, *PPM_CSR_t;
@@ -141,45 +141,45 @@ typedef union _INTERRUPT_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused5:11;			// bits 21-31
-		u32 slv_timeout:1;			// bit 20
-		u32 mac_stat_interrupt:1;		// bit 19
-		u32 rxmac_interrupt:1;		// bit 18
-		u32 txmac_interrupt:1;		// bit 17
-		u32 phy_interrupt:1;		// bit 16
-		u32 wake_on_lan:1;			// bit 15
-		u32 watchdog_interrupt:1;		// bit 14
-		u32 unused4:4;			// bits 10-13
-		u32 rxdma_err:1;			// bit 9
-		u32 rxdma_pkt_stat_ring_low:1;	// bit 8
-		u32 rxdma_fb_ring1_low:1;		// bit 7
-		u32 rxdma_fb_ring0_low:1;		// bit 6
-		u32 rxdma_xfr_done:1;		// bit 5
-		u32 txdma_err:1;			// bit 4
-		u32 txdma_isr:1;			// bit 3
-		u32 unused3:1;			// bit 2
-		u32 unused2:1;			// bit 1
-		u32 unused1:1;			// bit 0
-#else
-		u32 unused1:1;			// bit 0
-		u32 unused2:1;			// bit 1
-		u32 unused3:1;			// bit 2
-		u32 txdma_isr:1;			// bit 3
-		u32 txdma_err:1;			// bit 4
-		u32 rxdma_xfr_done:1;		// bit 5
-		u32 rxdma_fb_ring0_low:1;		// bit 6
-		u32 rxdma_fb_ring1_low:1;		// bit 7
-		u32 rxdma_pkt_stat_ring_low:1;	// bit 8
-		u32 rxdma_err:1;			// bit 9
-		u32 unused4:4;			// bits 10-13
-		u32 watchdog_interrupt:1;		// bit 14
-		u32 wake_on_lan:1;			// bit 15
-		u32 phy_interrupt:1;		// bit 16
-		u32 txmac_interrupt:1;		// bit 17
-		u32 rxmac_interrupt:1;		// bit 18
-		u32 mac_stat_interrupt:1;		// bit 19
-		u32 slv_timeout:1;			// bit 20
-		u32 unused5:11;			// bits 21-31
+		u32 unused5:11;			/* bits 21-31 */
+		u32 slv_timeout:1;			/* bit 20 */
+		u32 mac_stat_interrupt:1;		/* bit 19 */
+		u32 rxmac_interrupt:1;		/* bit 18 */
+		u32 txmac_interrupt:1;		/* bit 17 */
+		u32 phy_interrupt:1;		/* bit 16 */
+		u32 wake_on_lan:1;			/* bit 15 */
+		u32 watchdog_interrupt:1;		/* bit 14 */
+		u32 unused4:4;			/* bits 10-13 */
+		u32 rxdma_err:1;			/* bit 9 */
+		u32 rxdma_pkt_stat_ring_low:1;	/* bit 8 */
+		u32 rxdma_fb_ring1_low:1;		/* bit 7 */
+		u32 rxdma_fb_ring0_low:1;		/* bit 6 */
+		u32 rxdma_xfr_done:1;		/* bit 5 */
+		u32 txdma_err:1;			/* bit 4 */
+		u32 txdma_isr:1;			/* bit 3 */
+		u32 unused3:1;			/* bit 2 */
+		u32 unused2:1;			/* bit 1 */
+		u32 unused1:1;			/* bit 0 */
+#else
+		u32 unused1:1;			/* bit 0 */
+		u32 unused2:1;			/* bit 1 */
+		u32 unused3:1;			/* bit 2 */
+		u32 txdma_isr:1;			/* bit 3 */
+		u32 txdma_err:1;			/* bit 4 */
+		u32 rxdma_xfr_done:1;		/* bit 5 */
+		u32 rxdma_fb_ring0_low:1;		/* bit 6 */
+		u32 rxdma_fb_ring1_low:1;		/* bit 7 */
+		u32 rxdma_pkt_stat_ring_low:1;	/* bit 8 */
+		u32 rxdma_err:1;			/* bit 9 */
+		u32 unused4:4;			/* bits 10-13 */
+		u32 watchdog_interrupt:1;		/* bit 14 */
+		u32 wake_on_lan:1;			/* bit 15 */
+		u32 phy_interrupt:1;		/* bit 16 */
+		u32 txmac_interrupt:1;		/* bit 17 */
+		u32 rxmac_interrupt:1;		/* bit 18 */
+		u32 mac_stat_interrupt:1;		/* bit 19 */
+		u32 slv_timeout:1;			/* bit 20 */
+		u32 unused5:11;			/* bits 21-31 */
 #endif
 	} bits;
 } INTERRUPT_t, *PINTERRUPT_t;
@@ -210,25 +210,25 @@ typedef union _SW_RESET_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 selfclr_disable:1;	// bit 31
-		u32 unused:24;		// bits 7-30
-		u32 mmc_sw_reset:1;	// bit 6
-		u32 mac_stat_sw_reset:1;	// bit 5
-		u32 mac_sw_reset:1;	// bit 4
-		u32 rxmac_sw_reset:1;	// bit 3
-		u32 txmac_sw_reset:1;	// bit 2
-		u32 rxdma_sw_reset:1;	// bit 1
-		u32 txdma_sw_reset:1;	// bit 0
-#else
-		u32 txdma_sw_reset:1;	// bit 0
-		u32 rxdma_sw_reset:1;	// bit 1
-		u32 txmac_sw_reset:1;	// bit 2
-		u32 rxmac_sw_reset:1;	// bit 3
-		u32 mac_sw_reset:1;	// bit 4
-		u32 mac_stat_sw_reset:1;	// bit 5
-		u32 mmc_sw_reset:1;	// bit 6
-		u32 unused:24;		// bits 7-30
-		u32 selfclr_disable:1;	// bit 31
+		u32 selfclr_disable:1;	/* bit 31 */
+		u32 unused:24;		/* bits 7-30 */
+		u32 mmc_sw_reset:1;	/* bit 6 */
+		u32 mac_stat_sw_reset:1;	/* bit 5 */
+		u32 mac_sw_reset:1;	/* bit 4 */
+		u32 rxmac_sw_reset:1;	/* bit 3 */
+		u32 txmac_sw_reset:1;	/* bit 2 */
+		u32 rxdma_sw_reset:1;	/* bit 1 */
+		u32 txdma_sw_reset:1;	/* bit 0 */
+#else
+		u32 txdma_sw_reset:1;	/* bit 0 */
+		u32 rxdma_sw_reset:1;	/* bit 1 */
+		u32 txmac_sw_reset:1;	/* bit 2 */
+		u32 rxmac_sw_reset:1;	/* bit 3 */
+		u32 mac_sw_reset:1;	/* bit 4 */
+		u32 mac_stat_sw_reset:1;	/* bit 5 */
+		u32 mmc_sw_reset:1;	/* bit 6 */
+		u32 unused:24;		/* bits 7-30 */
+		u32 selfclr_disable:1;	/* bit 31 */
 #endif
 	} bits;
 } SW_RESET_t, *PSW_RESET_t;
@@ -241,11 +241,11 @@ typedef union _SLV_TIMER_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:8;	// bits 24-31
-		u32 timer_ini:24;	// bits 0-23
+		u32 unused:8;	/* bits 24-31 */
+		u32 timer_ini:24;	/* bits 0-23 */
 #else
-		u32 timer_ini:24;	// bits 0-23
-		u32 unused:8;	// bits 24-31
+		u32 timer_ini:24;	/* bits 0-23 */
+		u32 unused:8;	/* bits 24-31 */
 #endif
 	} bits;
 } SLV_TIMER_t, *PSLV_TIMER_t;
@@ -258,15 +258,15 @@ typedef union _MSI_CONFIG_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused1:13;	// bits 19-31
-		u32 msi_tc:3;	// bits 16-18
-		u32 unused2:11;	// bits 5-15
-		u32 msi_vector:5;	// bits 0-4
-#else
-		u32 msi_vector:5;	// bits 0-4
-		u32 unused2:11;	// bits 5-15
-		u32 msi_tc:3;	// bits 16-18
-		u32 unused1:13;	// bits 19-31
+		u32 unused1:13;	/* bits 19-31 */
+		u32 msi_tc:3;	/* bits 16-18 */
+		u32 unused2:11;	/* bits 5-15 */
+		u32 msi_vector:5;	/* bits 0-4 */
+#else
+		u32 msi_vector:5;	/* bits 0-4 */
+		u32 unused2:11;	/* bits 5-15 */
+		u32 msi_tc:3;	/* bits 16-18 */
+		u32 unused1:13;	/* bits 19-31 */
 #endif
 	} bits;
 } MSI_CONFIG_t, *PMSI_CONFIG_t;
@@ -279,13 +279,13 @@ typedef union _LOOPBACK_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:30;		// bits 2-31
-		u32 dma_loopback:1;	// bit 1
-		u32 mac_loopback:1;	// bit 0
-#else
-		u32 mac_loopback:1;	// bit 0
-		u32 dma_loopback:1;	// bit 1
-		u32 unused:30;		// bits 2-31
+		u32 unused:30;		/* bits 2-31 */
+		u32 dma_loopback:1;	/* bit 1 */
+		u32 mac_loopback:1;	/* bit 0 */
+#else
+		u32 mac_loopback:1;	/* bit 0 */
+		u32 dma_loopback:1;	/* bit 1 */
+		u32 unused:30;		/* bits 2-31 */
 #endif
 	} bits;
 } LOOPBACK_t, *PLOOPBACK_t;
@@ -294,22 +294,22 @@ typedef union _LOOPBACK_t {
  * GLOBAL Module of JAGCore Address Mapping
  * Located at address 0x0000
  */
-typedef struct _GLOBAL_t {			// Location:
-	Q_ADDR_t txq_start_addr;		//  0x0000
-	Q_ADDR_t txq_end_addr;			//  0x0004
-	Q_ADDR_t rxq_start_addr;		//  0x0008
-	Q_ADDR_t rxq_end_addr;			//  0x000C
-	PM_CSR_t pm_csr;			//  0x0010
-	u32 unused;				//  0x0014
-	INTERRUPT_t int_status;			//  0x0018
-	INTERRUPT_t int_mask;			//  0x001C
-	INTERRUPT_t int_alias_clr_en;		//  0x0020
-	INTERRUPT_t int_status_alias;		//  0x0024
-	SW_RESET_t sw_reset;			//  0x0028
-	SLV_TIMER_t slv_timer;			//  0x002C
-	MSI_CONFIG_t msi_config;		//  0x0030
-	LOOPBACK_t loopback;			//  0x0034
-	u32 watchdog_timer;			//  0x0038
+typedef struct _GLOBAL_t {			/* Location: */
+	Q_ADDR_t txq_start_addr;		/*  0x0000 */
+	Q_ADDR_t txq_end_addr;			/*  0x0004 */
+	Q_ADDR_t rxq_start_addr;		/*  0x0008 */
+	Q_ADDR_t rxq_end_addr;			/*  0x000C */
+	PM_CSR_t pm_csr;			/*  0x0010 */
+	u32 unused;				/*  0x0014 */
+	INTERRUPT_t int_status;			/*  0x0018 */
+	INTERRUPT_t int_mask;			/*  0x001C */
+	INTERRUPT_t int_alias_clr_en;		/*  0x0020 */
+	INTERRUPT_t int_status_alias;		/*  0x0024 */
+	SW_RESET_t sw_reset;			/*  0x0028 */
+	SLV_TIMER_t slv_timer;			/*  0x002C */
+	MSI_CONFIG_t msi_config;		/*  0x0030 */
+	LOOPBACK_t loopback;			/*  0x0034 */
+	u32 watchdog_timer;			/*  0x0038 */
 } GLOBAL_t, *PGLOBAL_t;
 
 /* END OF GLOBAL REGISTER ADDRESS MAP */
@@ -325,21 +325,21 @@ typedef union _TXDMA_CSR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused2:19;		// bits 13-31
-		u32 traffic_class:4;	// bits 9-12
-		u32 sngl_epkt_mode:1;	// bit 8
-		u32 cache_thrshld:4;	// bits 4-7
-		u32 unused1:2;		// bits 2-3
-		u32 drop_TLP_disable:1;	// bit 1
-		u32 halt:1;		// bit 0
-#else
-		u32 halt:1;		// bit 0
-		u32 drop_TLP_disable:1;	// bit 1
-		u32 unused1:2;		// bits 2-3
-		u32 cache_thrshld:4;	// bits 4-7
-		u32 sngl_epkt_mode:1;	// bit 8
-		u32 traffic_class:4;	// bits 9-12
-		u32 unused2:19;		// bits 13-31
+		u32 unused2:19;		/* bits 13-31 */
+		u32 traffic_class:4;	/* bits 9-12 */
+		u32 sngl_epkt_mode:1;	/* bit 8 */
+		u32 cache_thrshld:4;	/* bits 4-7 */
+		u32 unused1:2;		/* bits 2-3 */
+		u32 drop_TLP_disable:1;	/* bit 1 */
+		u32 halt:1;		/* bit 0 */
+#else
+		u32 halt:1;		/* bit 0 */
+		u32 drop_TLP_disable:1;	/* bit 1 */
+		u32 unused1:2;		/* bits 2-3 */
+		u32 cache_thrshld:4;	/* bits 4-7 */
+		u32 sngl_epkt_mode:1;	/* bit 8 */
+		u32 traffic_class:4;	/* bits 9-12 */
+		u32 unused2:19;		/* bits 13-31 */
 #endif
 	} bits;
 } TXDMA_CSR_t, *PTXDMA_CSR_t;
@@ -364,11 +364,11 @@ typedef union _TXDMA_PR_NUM_DES_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:22;	// bits 10-31
-		u32 pr_ndes:10;	// bits 0-9
+		u32 unused:22;	/* bits 10-31 */
+		u32 pr_ndes:10;	/* bits 0-9 */
 #else
-		u32 pr_ndes:10;	// bits 0-9
-		u32 unused:22;	// bits 10-31
+		u32 pr_ndes:10;	/* bits 0-9 */
+		u32 unused:22;	/* bits 10-31 */
 #endif
 	} bits;
 } TXDMA_PR_NUM_DES_t, *PTXDMA_PR_NUM_DES_t;
@@ -378,13 +378,13 @@ typedef union _DMA10W_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:21;	// bits 11-31
-		u32 wrap:1;	// bit 10
-		u32 val:10;	// bits 0-9
-#else
-		u32 val:10;	// bits 0-9
-		u32 wrap:1;	// bit 10
-		u32 unused:21;	// bits 11-31
+		u32 unused:21;	/* bits 11-31 */
+		u32 wrap:1;	/* bit 10 */
+		u32 val:10;	/* bits 0-9 */
+#else
+		u32 val:10;	/* bits 0-9 */
+		u32 wrap:1;	/* bit 10 */
+		u32 unused:21;	/* bits 11-31 */
 #endif
 	} bits;
 } DMA10W_t, *PDMA10W_t;
@@ -435,13 +435,13 @@ typedef union _DMA4W_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:27;	// bits 5-31
-		u32 wrap:1;	// bit 4
-		u32 val:4;		// bit 0-3
-#else
-		u32 val:4;		// bits 0-3
-		u32 wrap:1;	// bit 4
-		u32 unused:27;	// bits 5-31
+		u32 unused:27;	/* bits 5-31 */
+		u32 wrap:1;	/* bit 4 */
+		u32 val:4;		/* bit 0-3 */
+#else
+		u32 val:4;		/* bits 0-3 */
+		u32 wrap:1;	/* bit 4 */
+		u32 unused:27;	/* bits 5-31 */
 #endif
 	} bits;
 } DMA4W_t, *PDMA4W_t;
@@ -466,25 +466,25 @@ typedef union _TXDMA_ERROR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused3:22;		// bits 10-31
-		u32 WrbkRewind:1;	// bit 9
-		u32 WrbkResend:1;	// bit 8
-		u32 unused2:2;		// bits 6-7
-		u32 DescrRewind:1;	// bit 5
-		u32 DescrResend:1;	// bit 4
-		u32 unused1:2;		// bits 2-3
-		u32 PyldRewind:1;	// bit 1
-		u32 PyldResend:1;	// bit 0
-#else
-		u32 PyldResend:1;	// bit 0
-		u32 PyldRewind:1;	// bit 1
-		u32 unused1:2;		// bits 2-3
-		u32 DescrResend:1;	// bit 4
-		u32 DescrRewind:1;	// bit 5
-		u32 unused2:2;		// bits 6-7
-		u32 WrbkResend:1;	// bit 8
-		u32 WrbkRewind:1;	// bit 9
-		u32 unused3:22;		// bits 10-31
+		u32 unused3:22;		/* bits 10-31 */
+		u32 WrbkRewind:1;	/* bit 9 */
+		u32 WrbkResend:1;	/* bit 8 */
+		u32 unused2:2;		/* bits 6-7 */
+		u32 DescrRewind:1;	/* bit 5 */
+		u32 DescrResend:1;	/* bit 4 */
+		u32 unused1:2;		/* bits 2-3 */
+		u32 PyldRewind:1;	/* bit 1 */
+		u32 PyldResend:1;	/* bit 0 */
+#else
+		u32 PyldResend:1;	/* bit 0 */
+		u32 PyldRewind:1;	/* bit 1 */
+		u32 unused1:2;		/* bits 2-3 */
+		u32 DescrResend:1;	/* bit 4 */
+		u32 DescrRewind:1;	/* bit 5 */
+		u32 unused2:2;		/* bits 6-7 */
+		u32 WrbkResend:1;	/* bit 8 */
+		u32 WrbkRewind:1;	/* bit 9 */
+		u32 unused3:22;		/* bits 10-31 */
 #endif
 	} bits;
 } TXDMA_ERROR_t, *PTXDMA_ERROR_t;
@@ -493,33 +493,33 @@ typedef union _TXDMA_ERROR_t {
  * Tx DMA Module of JAGCore Address Mapping
  * Located at address 0x1000
  */
-typedef struct _TXDMA_t {		// Location:
-	TXDMA_CSR_t csr;		//  0x1000
-	u32 pr_base_hi;			//  0x1004
-	u32 pr_base_lo;			//  0x1008
-	TXDMA_PR_NUM_DES_t pr_num_des;	//  0x100C
-	DMA10W_t txq_wr_addr;		//  0x1010
-	DMA10W_t txq_wr_addr_ext;	//  0x1014
-	DMA10W_t txq_rd_addr;		//  0x1018
-	u32 dma_wb_base_hi;		//  0x101C
-	u32 dma_wb_base_lo;		//  0x1020
-	DMA10W_t service_request;	//  0x1024
-	DMA10W_t service_complete;	//  0x1028
-	DMA4W_t cache_rd_index;		//  0x102C
-	DMA4W_t cache_wr_index;		//  0x1030
-	TXDMA_ERROR_t TxDmaError;	//  0x1034
-	u32 DescAbortCount;		//  0x1038
-	u32 PayloadAbortCnt;		//  0x103c
-	u32 WriteBackAbortCnt;		//  0x1040
-	u32 DescTimeoutCnt;		//  0x1044
-	u32 PayloadTimeoutCnt;		//  0x1048
-	u32 WriteBackTimeoutCnt;	//  0x104c
-	u32 DescErrorCount;		//  0x1050
-	u32 PayloadErrorCnt;		//  0x1054
-	u32 WriteBackErrorCnt;		//  0x1058
-	u32 DroppedTLPCount;		//  0x105c
-	DMA10W_t NewServiceComplete;	//  0x1060
-	u32 EthernetPacketCount;	//  0x1064
+typedef struct _TXDMA_t {		/* Location: */
+	TXDMA_CSR_t csr;		/*  0x1000 */
+	u32 pr_base_hi;			/*  0x1004 */
+	u32 pr_base_lo;			/*  0x1008 */
+	TXDMA_PR_NUM_DES_t pr_num_des;	/*  0x100C */
+	DMA10W_t txq_wr_addr;		/*  0x1010 */
+	DMA10W_t txq_wr_addr_ext;	/*  0x1014 */
+	DMA10W_t txq_rd_addr;		/*  0x1018 */
+	u32 dma_wb_base_hi;		/*  0x101C */
+	u32 dma_wb_base_lo;		/*  0x1020 */
+	DMA10W_t service_request;	/*  0x1024 */
+	DMA10W_t service_complete;	/*  0x1028 */
+	DMA4W_t cache_rd_index;		/*  0x102C */
+	DMA4W_t cache_wr_index;		/*  0x1030 */
+	TXDMA_ERROR_t TxDmaError;	/*  0x1034 */
+	u32 DescAbortCount;		/*  0x1038 */
+	u32 PayloadAbortCnt;		/*  0x103c */
+	u32 WriteBackAbortCnt;		/*  0x1040 */
+	u32 DescTimeoutCnt;		/*  0x1044 */
+	u32 PayloadTimeoutCnt;		/*  0x1048 */
+	u32 WriteBackTimeoutCnt;	/*  0x104c */
+	u32 DescErrorCount;		/*  0x1050 */
+	u32 PayloadErrorCnt;		/*  0x1054 */
+	u32 WriteBackErrorCnt;		/*  0x1058 */
+	u32 DroppedTLPCount;		/*  0x105c */
+	DMA10W_t NewServiceComplete;	/*  0x1060 */
+	u32 EthernetPacketCount;	/*  0x1064 */
 } TXDMA_t, *PTXDMA_t;
 
 /* END OF TXDMA REGISTER ADDRESS MAP */
@@ -535,37 +535,37 @@ typedef union _RXDMA_CSR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused2:14;		// bits 18-31
-		u32 halt_status:1;	// bit 17
-		u32 pkt_done_flush:1;	// bit 16
-		u32 pkt_drop_disable:1;	// bit 15
-		u32 unused1:1;		// bit 14
-		u32 fbr1_enable:1;	// bit 13
-		u32 fbr1_size:2;	// bits 11-12
-		u32 fbr0_enable:1;	// bit 10
-		u32 fbr0_size:2;	// bits 8-9
-		u32 dma_big_endian:1;	// bit 7
-		u32 pkt_big_endian:1;	// bit 6
-		u32 psr_big_endian:1;	// bit 5
-		u32 fbr_big_endian:1;	// bit 4
-		u32 tc:3;		// bits 1-3
-		u32 halt:1;		// bit 0
-#else
-		u32 halt:1;		// bit 0
-		u32 tc:3;		// bits 1-3
-		u32 fbr_big_endian:1;	// bit 4
-		u32 psr_big_endian:1;	// bit 5
-		u32 pkt_big_endian:1;	// bit 6
-		u32 dma_big_endian:1;	// bit 7
-		u32 fbr0_size:2;	// bits 8-9
-		u32 fbr0_enable:1;	// bit 10
-		u32 fbr1_size:2;	// bits 11-12
-		u32 fbr1_enable:1;	// bit 13
-		u32 unused1:1;		// bit 14
-		u32 pkt_drop_disable:1;	// bit 15
-		u32 pkt_done_flush:1;	// bit 16
-		u32 halt_status:1;	// bit 17
-		u32 unused2:14;		// bits 18-31
+		u32 unused2:14;		/* bits 18-31 */
+		u32 halt_status:1;	/* bit 17 */
+		u32 pkt_done_flush:1;	/* bit 16 */
+		u32 pkt_drop_disable:1;	/* bit 15 */
+		u32 unused1:1;		/* bit 14 */
+		u32 fbr1_enable:1;	/* bit 13 */
+		u32 fbr1_size:2;	/* bits 11-12 */
+		u32 fbr0_enable:1;	/* bit 10 */
+		u32 fbr0_size:2;	/* bits 8-9 */
+		u32 dma_big_endian:1;	/* bit 7 */
+		u32 pkt_big_endian:1;	/* bit 6 */
+		u32 psr_big_endian:1;	/* bit 5 */
+		u32 fbr_big_endian:1;	/* bit 4 */
+		u32 tc:3;		/* bits 1-3 */
+		u32 halt:1;		/* bit 0 */
+#else
+		u32 halt:1;		/* bit 0 */
+		u32 tc:3;		/* bits 1-3 */
+		u32 fbr_big_endian:1;	/* bit 4 */
+		u32 psr_big_endian:1;	/* bit 5 */
+		u32 pkt_big_endian:1;	/* bit 6 */
+		u32 dma_big_endian:1;	/* bit 7 */
+		u32 fbr0_size:2;	/* bits 8-9 */
+		u32 fbr0_enable:1;	/* bit 10 */
+		u32 fbr1_size:2;	/* bits 11-12 */
+		u32 fbr1_enable:1;	/* bit 13 */
+		u32 unused1:1;		/* bit 14 */
+		u32 pkt_drop_disable:1;	/* bit 15 */
+		u32 pkt_done_flush:1;	/* bit 16 */
+		u32 halt_status:1;	/* bit 17 */
+		u32 unused2:14;		/* bits 18-31 */
 #endif
 	} bits;
 } RXDMA_CSR_t, *PRXDMA_CSR_t;
@@ -590,11 +590,11 @@ typedef union _RXDMA_NUM_PKT_DONE_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:24;	// bits 8-31
-		u32 num_done:8;	// bits 0-7
+		u32 unused:24;	/* bits 8-31 */
+		u32 num_done:8;	/* bits 0-7 */
 #else
-		u32 num_done:8;	// bits 0-7
-		u32 unused:24;	// bits 8-31
+		u32 num_done:8;	/* bits 0-7 */
+		u32 unused:24;	/* bits 8-31 */
 #endif
 	} bits;
 } RXDMA_NUM_PKT_DONE_t, *PRXDMA_NUM_PKT_DONE_t;
@@ -607,11 +607,11 @@ typedef union _RXDMA_MAX_PKT_TIME_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:14;		// bits 18-31
-		u32 time_done:18;	// bits 0-17
+		u32 unused:14;		/* bits 18-31 */
+		u32 time_done:18;	/* bits 0-17 */
 #else
-		u32 time_done:18;	// bits 0-17
-		u32 unused:14;		// bits 18-31
+		u32 time_done:18;	/* bits 0-17 */
+		u32 unused:14;		/* bits 18-31 */
 #endif
 	} bits;
 } RXDMA_MAX_PKT_TIME_t, *PRXDMA_MAX_PKT_TIME_t;
@@ -654,11 +654,11 @@ typedef union _RXDMA_PSR_NUM_DES_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:20;		// bits 12-31
-		u32 psr_ndes:12;	// bit 0-11
+		u32 unused:20;		/* bits 12-31 */
+		u32 psr_ndes:12;	/* bit 0-11 */
 #else
-		u32 psr_ndes:12;	// bit 0-11
-		u32 unused:20;		// bits 12-31
+		u32 psr_ndes:12;	/* bit 0-11 */
+		u32 unused:20;		/* bits 12-31 */
 #endif
 	} bits;
 } RXDMA_PSR_NUM_DES_t, *PRXDMA_PSR_NUM_DES_t;
@@ -671,13 +671,13 @@ typedef union _RXDMA_PSR_AVAIL_OFFSET_t 
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:19;		// bits 13-31
-		u32 psr_avail_wrap:1;	// bit 12
-		u32 psr_avail:12;	// bit 0-11
-#else
-		u32 psr_avail:12;	// bit 0-11
-		u32 psr_avail_wrap:1;	// bit 12
-		u32 unused:19;		// bits 13-31
+		u32 unused:19;		/* bits 13-31 */
+		u32 psr_avail_wrap:1;	/* bit 12 */
+		u32 psr_avail:12;	/* bit 0-11 */
+#else
+		u32 psr_avail:12;	/* bit 0-11 */
+		u32 psr_avail_wrap:1;	/* bit 12 */
+		u32 unused:19;		/* bits 13-31 */
 #endif
 	} bits;
 } RXDMA_PSR_AVAIL_OFFSET_t, *PRXDMA_PSR_AVAIL_OFFSET_t;
@@ -690,13 +690,13 @@ typedef union _RXDMA_PSR_FULL_OFFSET_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:19;		// bits 13-31
-		u32 psr_full_wrap:1;	// bit 12
-		u32 psr_full:12;	// bit 0-11
-#else
-		u32 psr_full:12;	// bit 0-11
-		u32 psr_full_wrap:1;	// bit 12
-		u32 unused:19;		// bits 13-31
+		u32 unused:19;		/* bits 13-31 */
+		u32 psr_full_wrap:1;	/* bit 12 */
+		u32 psr_full:12;	/* bit 0-11 */
+#else
+		u32 psr_full:12;	/* bit 0-11 */
+		u32 psr_full_wrap:1;	/* bit 12 */
+		u32 unused:19;		/* bits 13-31 */
 #endif
 	} bits;
 } RXDMA_PSR_FULL_OFFSET_t, *PRXDMA_PSR_FULL_OFFSET_t;
@@ -709,11 +709,11 @@ typedef union _RXDMA_PSR_ACCESS_INDEX_t 
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:27;	// bits 5-31
-		u32 psr_ai:5;	// bits 0-4
+		u32 unused:27;	/* bits 5-31 */
+		u32 psr_ai:5;	/* bits 0-4 */
 #else
-		u32 psr_ai:5;	// bits 0-4
-		u32 unused:27;	// bits 5-31
+		u32 psr_ai:5;	/* bits 0-4 */
+		u32 unused:27;	/* bits 5-31 */
 #endif
 	} bits;
 } RXDMA_PSR_ACCESS_INDEX_t, *PRXDMA_PSR_ACCESS_INDEX_t;
@@ -726,11 +726,11 @@ typedef union _RXDMA_PSR_MIN_DES_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:20;	// bits 12-31
-		u32 psr_min:12;	// bits 0-11
+		u32 unused:20;	/* bits 12-31 */
+		u32 psr_min:12;	/* bits 0-11 */
 #else
-		u32 psr_min:12;	// bits 0-11
-		u32 unused:20;	// bits 12-31
+		u32 psr_min:12;	/* bits 0-11 */
+		u32 unused:20;	/* bits 12-31 */
 #endif
 	} bits;
 } RXDMA_PSR_MIN_DES_t, *PRXDMA_PSR_MIN_DES_t;
@@ -755,11 +755,11 @@ typedef union _RXDMA_FBR_NUM_DES_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:22;		// bits 10-31
-		u32 fbr_ndesc:10;	// bits 0-9
+		u32 unused:22;		/* bits 10-31 */
+		u32 fbr_ndesc:10;	/* bits 0-9 */
 #else
-		u32 fbr_ndesc:10;	// bits 0-9
-		u32 unused:22;		// bits 10-31
+		u32 fbr_ndesc:10;	/* bits 0-9 */
+		u32 unused:22;		/* bits 10-31 */
 #endif
 	} bits;
 } RXDMA_FBR_NUM_DES_t, *PRXDMA_FBR_NUM_DES_t;
@@ -784,11 +784,11 @@ typedef union _RXDMA_FBC_RD_INDEX_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:27;	// bits 5-31
-		u32 fbc_rdi:5;	// bit 0-4
+		u32 unused:27;	/* bits 5-31 */
+		u32 fbc_rdi:5;	/* bit 0-4 */
 #else
-		u32 fbc_rdi:5;	// bit 0-4
-		u32 unused:27;	// bits 5-31
+		u32 fbc_rdi:5;	/* bit 0-4 */
+		u32 unused:27;	/* bits 5-31 */
 #endif
 	} bits;
 } RXDMA_FBC_RD_INDEX_t, *PRXDMA_FBC_RD_INDEX_t;
@@ -801,11 +801,11 @@ typedef union _RXDMA_FBR_MIN_DES_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:22;	// bits 10-31
-		u32 fbr_min:10;	// bits 0-9
+		u32 unused:22;	/* bits 10-31 */
+		u32 fbr_min:10;	/* bits 0-9 */
 #else
-		u32 fbr_min:10;	// bits 0-9
-		u32 unused:22;	// bits 10-31
+		u32 fbr_min:10;	/* bits 0-9 */
+		u32 unused:22;	/* bits 10-31 */
 #endif
 	} bits;
 } RXDMA_FBR_MIN_DES_t, *PRXDMA_FBR_MIN_DES_t;
@@ -850,36 +850,36 @@ typedef union _RXDMA_FBR_MIN_DES_t {
  * Rx DMA Module of JAGCore Address Mapping
  * Located at address 0x2000
  */
-typedef struct _RXDMA_t {				// Location:
-	RXDMA_CSR_t csr;				//  0x2000
-	u32 dma_wb_base_lo;				//  0x2004
-	u32 dma_wb_base_hi;				//  0x2008
-	RXDMA_NUM_PKT_DONE_t num_pkt_done;		//  0x200C
-	RXDMA_MAX_PKT_TIME_t max_pkt_time;		//  0x2010
-	DMA10W_t rxq_rd_addr;				//  0x2014
-	DMA10W_t rxq_rd_addr_ext;			//  0x2018
-	DMA10W_t rxq_wr_addr;				//  0x201C
-	u32 psr_base_lo;				//  0x2020
-	u32 psr_base_hi;				//  0x2024
-	RXDMA_PSR_NUM_DES_t psr_num_des;		//  0x2028
-	RXDMA_PSR_AVAIL_OFFSET_t psr_avail_offset;	//  0x202C
-	RXDMA_PSR_FULL_OFFSET_t psr_full_offset;	//  0x2030
-	RXDMA_PSR_ACCESS_INDEX_t psr_access_index;	//  0x2034
-	RXDMA_PSR_MIN_DES_t psr_min_des;		//  0x2038
-	u32 fbr0_base_lo;				//  0x203C
-	u32 fbr0_base_hi;				//  0x2040
-	RXDMA_FBR_NUM_DES_t fbr0_num_des;		//  0x2044
-	DMA10W_t fbr0_avail_offset;			//  0x2048
-	DMA10W_t fbr0_full_offset;			//  0x204C
-	RXDMA_FBC_RD_INDEX_t fbr0_rd_index;		//  0x2050
-	RXDMA_FBR_MIN_DES_t fbr0_min_des;		//  0x2054
-	u32 fbr1_base_lo;				//  0x2058
-	u32 fbr1_base_hi;				//  0x205C
-	RXDMA_FBR_NUM_DES_t fbr1_num_des;		//  0x2060
-	DMA10W_t fbr1_avail_offset;			//  0x2064
-	DMA10W_t fbr1_full_offset;			//  0x2068
-	RXDMA_FBC_RD_INDEX_t fbr1_rd_index;		//  0x206C
-	RXDMA_FBR_MIN_DES_t fbr1_min_des;		//  0x2070
+typedef struct _RXDMA_t {				/* Location: */
+	RXDMA_CSR_t csr;				/*  0x2000 */
+	u32 dma_wb_base_lo;				/*  0x2004 */
+	u32 dma_wb_base_hi;				/*  0x2008 */
+	RXDMA_NUM_PKT_DONE_t num_pkt_done;		/*  0x200C */
+	RXDMA_MAX_PKT_TIME_t max_pkt_time;		/*  0x2010 */
+	DMA10W_t rxq_rd_addr;				/*  0x2014 */
+	DMA10W_t rxq_rd_addr_ext;			/*  0x2018 */
+	DMA10W_t rxq_wr_addr;				/*  0x201C */
+	u32 psr_base_lo;				/*  0x2020 */
+	u32 psr_base_hi;				/*  0x2024 */
+	RXDMA_PSR_NUM_DES_t psr_num_des;		/*  0x2028 */
+	RXDMA_PSR_AVAIL_OFFSET_t psr_avail_offset;	/*  0x202C */
+	RXDMA_PSR_FULL_OFFSET_t psr_full_offset;	/*  0x2030 */
+	RXDMA_PSR_ACCESS_INDEX_t psr_access_index;	/*  0x2034 */
+	RXDMA_PSR_MIN_DES_t psr_min_des;		/*  0x2038 */
+	u32 fbr0_base_lo;				/*  0x203C */
+	u32 fbr0_base_hi;				/*  0x2040 */
+	RXDMA_FBR_NUM_DES_t fbr0_num_des;		/*  0x2044 */
+	DMA10W_t fbr0_avail_offset;			/*  0x2048 */
+	DMA10W_t fbr0_full_offset;			/*  0x204C */
+	RXDMA_FBC_RD_INDEX_t fbr0_rd_index;		/*  0x2050 */
+	RXDMA_FBR_MIN_DES_t fbr0_min_des;		/*  0x2054 */
+	u32 fbr1_base_lo;				/*  0x2058 */
+	u32 fbr1_base_hi;				/*  0x205C */
+	RXDMA_FBR_NUM_DES_t fbr1_num_des;		/*  0x2060 */
+	DMA10W_t fbr1_avail_offset;			/*  0x2064 */
+	DMA10W_t fbr1_full_offset;			/*  0x2068 */
+	RXDMA_FBC_RD_INDEX_t fbr1_rd_index;		/*  0x206C */
+	RXDMA_FBR_MIN_DES_t fbr1_min_des;		/*  0x2070 */
 } RXDMA_t, *PRXDMA_t;
 
 /* END OF RXDMA REGISTER ADDRESS MAP */
@@ -895,25 +895,25 @@ typedef union _TXMAC_CTL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:24;		// bits 8-31
-		u32 cklseg_diable:1;	// bit 7
-		u32 ckbcnt_disable:1;	// bit 6
-		u32 cksegnum:1;		// bit 5
-		u32 async_disable:1;	// bit 4
-		u32 fc_disable:1;	// bit 3
-		u32 mcif_disable:1;	// bit 2
-		u32 mif_disable:1;	// bit 1
-		u32 txmac_en:1;		// bit 0
-#else
-		u32 txmac_en:1;		// bit 0
-		u32 mif_disable:1;	// bit 1 mac interface
-		u32 mcif_disable:1;	// bit 2 mem. contr. interface
-		u32 fc_disable:1;	// bit 3
-		u32 async_disable:1;	// bit 4
-		u32 cksegnum:1;		// bit 5
-		u32 ckbcnt_disable:1;	// bit 6
-		u32 cklseg_diable:1;	// bit 7
-		u32 unused:24;		// bits 8-31
+		u32 unused:24;		/* bits 8-31 */
+		u32 cklseg_diable:1;	/* bit 7 */
+		u32 ckbcnt_disable:1;	/* bit 6 */
+		u32 cksegnum:1;		/* bit 5 */
+		u32 async_disable:1;	/* bit 4 */
+		u32 fc_disable:1;	/* bit 3 */
+		u32 mcif_disable:1;	/* bit 2 */
+		u32 mif_disable:1;	/* bit 1 */
+		u32 txmac_en:1;		/* bit 0 */
+#else
+		u32 txmac_en:1;		/* bit 0 */
+		u32 mif_disable:1;	/* bit 1 mac interface */
+		u32 mcif_disable:1;	/* bit 2 mem. contr. interface */
+		u32 fc_disable:1;	/* bit 3 */
+		u32 async_disable:1;	/* bit 4 */
+		u32 cksegnum:1;		/* bit 5 */
+		u32 ckbcnt_disable:1;	/* bit 6 */
+		u32 cklseg_diable:1;	/* bit 7 */
+		u32 unused:24;		/* bits 8-31 */
 #endif
 	} bits;
 } TXMAC_CTL_t, *PTXMAC_CTL_t;
@@ -926,15 +926,15 @@ typedef union _TXMAC_SHADOW_PTR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved2:5;	// bits 27-31
-		u32 txq_rd_ptr:11;	// bits 16-26
-		u32 reserved:5;		// bits 11-15
-		u32 txq_wr_ptr:11;	// bits 0-10
-#else
-		u32 txq_wr_ptr:11;	// bits 0-10
-		u32 reserved:5;		// bits 11-15
-		u32 txq_rd_ptr:11;	// bits 16-26
-		u32 reserved2:5;	// bits 27-31
+		u32 reserved2:5;	/* bits 27-31 */
+		u32 txq_rd_ptr:11;	/* bits 16-26 */
+		u32 reserved:5;		/* bits 11-15 */
+		u32 txq_wr_ptr:11;	/* bits 0-10 */
+#else
+		u32 txq_wr_ptr:11;	/* bits 0-10 */
+		u32 reserved:5;		/* bits 11-15 */
+		u32 txq_rd_ptr:11;	/* bits 16-26 */
+		u32 reserved2:5;	/* bits 27-31 */
 #endif
 	} bits;
 } TXMAC_SHADOW_PTR_t, *PTXMAC_SHADOW_PTR_t;
@@ -947,15 +947,15 @@ typedef union _TXMAC_ERR_CNT_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:20;		// bits 12-31
-		u32 reserved:4;		// bits 8-11
-		u32 txq_underrun:4;	// bits 4-7
-		u32 fifo_underrun:4;	// bits 0-3
-#else
-		u32 fifo_underrun:4;	// bits 0-3
-		u32 txq_underrun:4;	// bits 4-7
-		u32 reserved:4;		// bits 8-11
-		u32 unused:20;		// bits 12-31
+		u32 unused:20;		/* bits 12-31 */
+		u32 reserved:4;		/* bits 8-11 */
+		u32 txq_underrun:4;	/* bits 4-7 */
+		u32 fifo_underrun:4;	/* bits 0-3 */
+#else
+		u32 fifo_underrun:4;	/* bits 0-3 */
+		u32 txq_underrun:4;	/* bits 4-7 */
+		u32 reserved:4;		/* bits 8-11 */
+		u32 unused:20;		/* bits 12-31 */
 #endif
 	} bits;
 } TXMAC_ERR_CNT_t, *PTXMAC_ERR_CNT_t;
@@ -968,11 +968,11 @@ typedef union _TXMAC_MAX_FILL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:20;		// bits 12-31
-		u32 max_fill:12;	// bits 0-11
+		u32 unused:20;		/* bits 12-31 */
+		u32 max_fill:12;	/* bits 0-11 */
 #else
-		u32 max_fill:12;	// bits 0-11
-		u32 unused:20;		// bits 12-31
+		u32 max_fill:12;	/* bits 0-11 */
+		u32 unused:20;		/* bits 12-31 */
 #endif
 	} bits;
 } TXMAC_MAX_FILL_t, *PTXMAC_MAX_FILL_t;
@@ -985,11 +985,11 @@ typedef union _TXMAC_CF_PARAM_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 cfep:16;	// bits 16-31
-		u32 cfpt:16;	// bits 0-15
+		u32 cfep:16;	/* bits 16-31 */
+		u32 cfpt:16;	/* bits 0-15 */
 #else
-		u32 cfpt:16;	// bits 0-15
-		u32 cfep:16;	// bits 16-31
+		u32 cfpt:16;	/* bits 0-15 */
+		u32 cfep:16;	/* bits 16-31 */
 #endif
 	} bits;
 } TXMAC_CF_PARAM_t, *PTXMAC_CF_PARAM_t;
@@ -1002,17 +1002,17 @@ typedef union _TXMAC_TXTEST_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused2:15;		// bits 17-31
-		u32 reserved1:1;	// bit 16
-		u32 txtest_en:1;	// bit 15
-		u32 unused1:4;		// bits 11-14
-		u32 txqtest_ptr:11;	// bits 0-11
-#else
-		u32 txqtest_ptr:11;	// bits 0-10
-		u32 unused1:4;		// bits 11-14
-		u32 txtest_en:1;	// bit 15
-		u32 reserved1:1;	// bit 16
-		u32 unused2:15;		// bits 17-31
+		u32 unused2:15;		/* bits 17-31 */
+		u32 reserved1:1;	/* bit 16 */
+		u32 txtest_en:1;	/* bit 15 */
+		u32 unused1:4;		/* bits 11-14 */
+		u32 txqtest_ptr:11;	/* bits 0-11 */
+#else
+		u32 txqtest_ptr:11;	/* bits 0-10 */
+		u32 unused1:4;		/* bits 11-14 */
+		u32 txtest_en:1;	/* bit 15 */
+		u32 reserved1:1;	/* bit 16 */
+		u32 unused2:15;		/* bits 17-31 */
 #endif
 	} bits;
 } TXMAC_TXTEST_t, *PTXMAC_TXTEST_t;
@@ -1025,25 +1025,25 @@ typedef union _TXMAC_ERR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused2:23;		// bits 9-31
-		u32 fifo_underrun:1;	// bit 8
-		u32 unused1:2;		// bits 6-7
-		u32 ctrl2_err:1;	// bit 5
-		u32 txq_underrun:1;	// bit 4
-		u32 bcnt_err:1;		// bit 3
-		u32 lseg_err:1;		// bit 2
-		u32 segnum_err:1;	// bit 1
-		u32 seg0_err:1;		// bit 0
-#else
-		u32 seg0_err:1;		// bit 0
-		u32 segnum_err:1;	// bit 1
-		u32 lseg_err:1;		// bit 2
-		u32 bcnt_err:1;		// bit 3
-		u32 txq_underrun:1;	// bit 4
-		u32 ctrl2_err:1;	// bit 5
-		u32 unused1:2;		// bits 6-7
-		u32 fifo_underrun:1;	// bit 8
-		u32 unused2:23;		// bits 9-31
+		u32 unused2:23;		/* bits 9-31 */
+		u32 fifo_underrun:1;	/* bit 8 */
+		u32 unused1:2;		/* bits 6-7 */
+		u32 ctrl2_err:1;	/* bit 5 */
+		u32 txq_underrun:1;	/* bit 4 */
+		u32 bcnt_err:1;		/* bit 3 */
+		u32 lseg_err:1;		/* bit 2 */
+		u32 segnum_err:1;	/* bit 1 */
+		u32 seg0_err:1;		/* bit 0 */
+#else
+		u32 seg0_err:1;		/* bit 0 */
+		u32 segnum_err:1;	/* bit 1 */
+		u32 lseg_err:1;		/* bit 2 */
+		u32 bcnt_err:1;		/* bit 3 */
+		u32 txq_underrun:1;	/* bit 4 */
+		u32 ctrl2_err:1;	/* bit 5 */
+		u32 unused1:2;		/* bits 6-7 */
+		u32 fifo_underrun:1;	/* bit 8 */
+		u32 unused2:23;		/* bits 9-31 */
 #endif
 	} bits;
 } TXMAC_ERR_t, *PTXMAC_ERR_t;
@@ -1056,25 +1056,25 @@ typedef union _TXMAC_ERR_INT_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused2:23;		// bits 9-31
-		u32 fifo_underrun:1;	// bit 8
-		u32 unused1:2;		// bits 6-7
-		u32 ctrl2_err:1;	// bit 5
-		u32 txq_underrun:1;	// bit 4
-		u32 bcnt_err:1;		// bit 3
-		u32 lseg_err:1;		// bit 2
-		u32 segnum_err:1;	// bit 1
-		u32 seg0_err:1;		// bit 0
-#else
-		u32 seg0_err:1;		// bit 0
-		u32 segnum_err:1;	// bit 1
-		u32 lseg_err:1;		// bit 2
-		u32 bcnt_err:1;		// bit 3
-		u32 txq_underrun:1;	// bit 4
-		u32 ctrl2_err:1;	// bit 5
-		u32 unused1:2;		// bits 6-7
-		u32 fifo_underrun:1;	// bit 8
-		u32 unused2:23;		// bits 9-31
+		u32 unused2:23;		/* bits 9-31 */
+		u32 fifo_underrun:1;	/* bit 8 */
+		u32 unused1:2;		/* bits 6-7 */
+		u32 ctrl2_err:1;	/* bit 5 */
+		u32 txq_underrun:1;	/* bit 4 */
+		u32 bcnt_err:1;		/* bit 3 */
+		u32 lseg_err:1;		/* bit 2 */
+		u32 segnum_err:1;	/* bit 1 */
+		u32 seg0_err:1;		/* bit 0 */
+#else
+		u32 seg0_err:1;		/* bit 0 */
+		u32 segnum_err:1;	/* bit 1 */
+		u32 lseg_err:1;		/* bit 2 */
+		u32 bcnt_err:1;		/* bit 3 */
+		u32 txq_underrun:1;	/* bit 4 */
+		u32 ctrl2_err:1;	/* bit 5 */
+		u32 unused1:2;		/* bits 6-7 */
+		u32 fifo_underrun:1;	/* bit 8 */
+		u32 unused2:23;		/* bits 9-31 */
 #endif
 	} bits;
 } TXMAC_ERR_INT_t, *PTXMAC_ERR_INT_t;
@@ -1087,13 +1087,13 @@ typedef union _TXMAC_CP_CTRL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:30;		// bits 2-31
-		u32 bp_req:1;		// bit 1
-		u32 bp_xonxoff:1;	// bit 0
-#else
-		u32 bp_xonxoff:1;	// bit 0
-		u32 bp_req:1;		// bit 1
-		u32 unused:30;		// bits 2-31
+		u32 unused:30;		/* bits 2-31 */
+		u32 bp_req:1;		/* bit 1 */
+		u32 bp_xonxoff:1;	/* bit 0 */
+#else
+		u32 bp_xonxoff:1;	/* bit 0 */
+		u32 bp_req:1;		/* bit 1 */
+		u32 unused:30;		/* bits 2-31 */
 #endif
 	} bits;
 } TXMAC_BP_CTRL_t, *PTXMAC_BP_CTRL_t;
@@ -1101,16 +1101,16 @@ typedef union _TXMAC_CP_CTRL_t {
 /*
  * Tx MAC Module of JAGCore Address Mapping
  */
-typedef struct _TXMAC_t {		// Location:
-	TXMAC_CTL_t ctl;		//  0x3000
-	TXMAC_SHADOW_PTR_t shadow_ptr;	//  0x3004
-	TXMAC_ERR_CNT_t err_cnt;	//  0x3008
-	TXMAC_MAX_FILL_t max_fill;	//  0x300C
-	TXMAC_CF_PARAM_t cf_param;	//  0x3010
-	TXMAC_TXTEST_t tx_test;		//  0x3014
-	TXMAC_ERR_t err;		//  0x3018
-	TXMAC_ERR_INT_t err_int;	//  0x301C
-	TXMAC_BP_CTRL_t bp_ctrl;	//  0x3020
+typedef struct _TXMAC_t {		/* Location: */
+	TXMAC_CTL_t ctl;		/*  0x3000 */
+	TXMAC_SHADOW_PTR_t shadow_ptr;	/*  0x3004 */
+	TXMAC_ERR_CNT_t err_cnt;	/*  0x3008 */
+	TXMAC_MAX_FILL_t max_fill;	/*  0x300C */
+	TXMAC_CF_PARAM_t cf_param;	/*  0x3010 */
+	TXMAC_TXTEST_t tx_test;		/*  0x3014 */
+	TXMAC_ERR_t err;		/*  0x3018 */
+	TXMAC_ERR_INT_t err_int;	/*  0x301C */
+	TXMAC_BP_CTRL_t bp_ctrl;	/*  0x3020 */
 } TXMAC_t, *PTXMAC_t;
 
 /* END OF TXMAC REGISTER ADDRESS MAP */
@@ -1125,23 +1125,23 @@ typedef union _RXMAC_CTRL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:25;		// bits 7-31
-		u32 rxmac_int_disable:1;	// bit 6
-		u32 async_disable:1;		// bit 5
-		u32 mif_disable:1;		// bit 4
-		u32 wol_disable:1;		// bit 3
-		u32 pkt_filter_disable:1;	// bit 2
-		u32 mcif_disable:1;		// bit 1
-		u32 rxmac_en:1;			// bit 0
-#else
-		u32 rxmac_en:1;			// bit 0
-		u32 mcif_disable:1;		// bit 1
-		u32 pkt_filter_disable:1;	// bit 2
-		u32 wol_disable:1;		// bit 3
-		u32 mif_disable:1;		// bit 4
-		u32 async_disable:1;		// bit 5
-		u32 rxmac_int_disable:1;	// bit 6
-		u32 reserved:25;		// bits 7-31
+		u32 reserved:25;		/* bits 7-31 */
+		u32 rxmac_int_disable:1;	/* bit 6 */
+		u32 async_disable:1;		/* bit 5 */
+		u32 mif_disable:1;		/* bit 4 */
+		u32 wol_disable:1;		/* bit 3 */
+		u32 pkt_filter_disable:1;	/* bit 2 */
+		u32 mcif_disable:1;		/* bit 1 */
+		u32 rxmac_en:1;			/* bit 0 */
+#else
+		u32 rxmac_en:1;			/* bit 0 */
+		u32 mcif_disable:1;		/* bit 1 */
+		u32 pkt_filter_disable:1;	/* bit 2 */
+		u32 wol_disable:1;		/* bit 3 */
+		u32 mif_disable:1;		/* bit 4 */
+		u32 async_disable:1;		/* bit 5 */
+		u32 rxmac_int_disable:1;	/* bit 6 */
+		u32 reserved:25;		/* bits 7-31 */
 #endif
 	} bits;
 } RXMAC_CTRL_t, *PRXMAC_CTRL_t;
@@ -1154,35 +1154,35 @@ typedef union _RXMAC_WOL_CTL_CRC0_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 crc0:16;		// bits 16-31
-		u32 reserve:4;		// bits 12-15
-		u32 ignore_pp:1;	// bit 11
-		u32 ignore_mp:1;	// bit 10
-		u32 clr_intr:1;		// bit 9
-		u32 ignore_link_chg:1;	// bit 8
-		u32 ignore_uni:1;	// bit 7
-		u32 ignore_multi:1;	// bit 6
-		u32 ignore_broad:1;	// bit 5
-		u32 valid_crc4:1;	// bit 4
-		u32 valid_crc3:1;	// bit 3
-		u32 valid_crc2:1;	// bit 2
-		u32 valid_crc1:1;	// bit 1
-		u32 valid_crc0:1;	// bit 0
-#else
-		u32 valid_crc0:1;	// bit 0
-		u32 valid_crc1:1;	// bit 1
-		u32 valid_crc2:1;	// bit 2
-		u32 valid_crc3:1;	// bit 3
-		u32 valid_crc4:1;	// bit 4
-		u32 ignore_broad:1;	// bit 5
-		u32 ignore_multi:1;	// bit 6
-		u32 ignore_uni:1;	// bit 7
-		u32 ignore_link_chg:1;	// bit 8
-		u32 clr_intr:1;		// bit 9
-		u32 ignore_mp:1;	// bit 10
-		u32 ignore_pp:1;	// bit 11
-		u32 reserve:4;		// bits 12-15
-		u32 crc0:16;		// bits 16-31
+		u32 crc0:16;		/* bits 16-31 */
+		u32 reserve:4;		/* bits 12-15 */
+		u32 ignore_pp:1;	/* bit 11 */
+		u32 ignore_mp:1;	/* bit 10 */
+		u32 clr_intr:1;		/* bit 9 */
+		u32 ignore_link_chg:1;	/* bit 8 */
+		u32 ignore_uni:1;	/* bit 7 */
+		u32 ignore_multi:1;	/* bit 6 */
+		u32 ignore_broad:1;	/* bit 5 */
+		u32 valid_crc4:1;	/* bit 4 */
+		u32 valid_crc3:1;	/* bit 3 */
+		u32 valid_crc2:1;	/* bit 2 */
+		u32 valid_crc1:1;	/* bit 1 */
+		u32 valid_crc0:1;	/* bit 0 */
+#else
+		u32 valid_crc0:1;	/* bit 0 */
+		u32 valid_crc1:1;	/* bit 1 */
+		u32 valid_crc2:1;	/* bit 2 */
+		u32 valid_crc3:1;	/* bit 3 */
+		u32 valid_crc4:1;	/* bit 4 */
+		u32 ignore_broad:1;	/* bit 5 */
+		u32 ignore_multi:1;	/* bit 6 */
+		u32 ignore_uni:1;	/* bit 7 */
+		u32 ignore_link_chg:1;	/* bit 8 */
+		u32 clr_intr:1;		/* bit 9 */
+		u32 ignore_mp:1;	/* bit 10 */
+		u32 ignore_pp:1;	/* bit 11 */
+		u32 reserve:4;		/* bits 12-15 */
+		u32 crc0:16;		/* bits 16-31 */
 #endif
 	} bits;
 } RXMAC_WOL_CTL_CRC0_t, *PRXMAC_WOL_CTL_CRC0_t;
@@ -1195,11 +1195,11 @@ typedef union _RXMAC_WOL_CRC12_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 crc2:16;	// bits 16-31
-		u32 crc1:16;	// bits 0-15
+		u32 crc2:16;	/* bits 16-31 */
+		u32 crc1:16;	/* bits 0-15 */
 #else
-		u32 crc1:16;	// bits 0-15
-		u32 crc2:16;	// bits 16-31
+		u32 crc1:16;	/* bits 0-15 */
+		u32 crc2:16;	/* bits 16-31 */
 #endif
 	} bits;
 } RXMAC_WOL_CRC12_t, *PRXMAC_WOL_CRC12_t;
@@ -1212,11 +1212,11 @@ typedef union _RXMAC_WOL_CRC34_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 crc4:16;	// bits 16-31
-		u32 crc3:16;	// bits 0-15
+		u32 crc4:16;	/* bits 16-31 */
+		u32 crc3:16;	/* bits 0-15 */
 #else
-		u32 crc3:16;	// bits 0-15
-		u32 crc4:16;	// bits 16-31
+		u32 crc3:16;	/* bits 0-15 */
+		u32 crc4:16;	/* bits 16-31 */
 #endif
 	} bits;
 } RXMAC_WOL_CRC34_t, *PRXMAC_WOL_CRC34_t;
@@ -1229,15 +1229,15 @@ typedef union _RXMAC_WOL_SA_LO_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 sa3:8;	// bits 24-31
-		u32 sa4:8;	// bits 16-23
-		u32 sa5:8;	// bits 8-15
-		u32 sa6:8;	// bits 0-7
-#else
-		u32 sa6:8;	// bits 0-7
-		u32 sa5:8;	// bits 8-15
-		u32 sa4:8;	// bits 16-23
-		u32 sa3:8;	// bits 24-31
+		u32 sa3:8;	/* bits 24-31 */
+		u32 sa4:8;	/* bits 16-23 */
+		u32 sa5:8;	/* bits 8-15 */
+		u32 sa6:8;	/* bits 0-7 */
+#else
+		u32 sa6:8;	/* bits 0-7 */
+		u32 sa5:8;	/* bits 8-15 */
+		u32 sa4:8;	/* bits 16-23 */
+		u32 sa3:8;	/* bits 24-31 */
 #endif
 	} bits;
 } RXMAC_WOL_SA_LO_t, *PRXMAC_WOL_SA_LO_t;
@@ -1250,13 +1250,13 @@ typedef union _RXMAC_WOL_SA_HI_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:16;	// bits 16-31
-		u32 sa1:8;		// bits 8-15
-		u32 sa2:8;		// bits 0-7
-#else
-		u32 sa2:8;		// bits 0-7
-		u32 sa1:8;		// bits 8-15
-		u32 reserved:16;	// bits 16-31
+		u32 reserved:16;	/* bits 16-31 */
+		u32 sa1:8;		/* bits 8-15 */
+		u32 sa2:8;		/* bits 0-7 */
+#else
+		u32 sa2:8;		/* bits 0-7 */
+		u32 sa1:8;		/* bits 8-15 */
+		u32 reserved:16;	/* bits 16-31 */
 #endif
 	} bits;
 } RXMAC_WOL_SA_HI_t, *PRXMAC_WOL_SA_HI_t;
@@ -1275,15 +1275,15 @@ typedef union _RXMAC_UNI_PF_ADDR1_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 addr1_3:8;	// bits 24-31
-		u32 addr1_4:8;	// bits 16-23
-		u32 addr1_5:8;	// bits 8-15
-		u32 addr1_6:8;	// bits 0-7
-#else
-		u32 addr1_6:8;	// bits 0-7
-		u32 addr1_5:8;	// bits 8-15
-		u32 addr1_4:8;	// bits 16-23
-		u32 addr1_3:8;	// bits 24-31
+		u32 addr1_3:8;	/* bits 24-31 */
+		u32 addr1_4:8;	/* bits 16-23 */
+		u32 addr1_5:8;	/* bits 8-15 */
+		u32 addr1_6:8;	/* bits 0-7 */
+#else
+		u32 addr1_6:8;	/* bits 0-7 */
+		u32 addr1_5:8;	/* bits 8-15 */
+		u32 addr1_4:8;	/* bits 16-23 */
+		u32 addr1_3:8;	/* bits 24-31 */
 #endif
 	} bits;
 } RXMAC_UNI_PF_ADDR1_t, *PRXMAC_UNI_PF_ADDR1_t;
@@ -1296,15 +1296,15 @@ typedef union _RXMAC_UNI_PF_ADDR2_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 addr2_3:8;	// bits 24-31
-		u32 addr2_4:8;	// bits 16-23
-		u32 addr2_5:8;	// bits 8-15
-		u32 addr2_6:8;	// bits 0-7
-#else
-		u32 addr2_6:8;	// bits 0-7
-		u32 addr2_5:8;	// bits 8-15
-		u32 addr2_4:8;	// bits 16-23
-		u32 addr2_3:8;	// bits 24-31
+		u32 addr2_3:8;	/* bits 24-31 */
+		u32 addr2_4:8;	/* bits 16-23 */
+		u32 addr2_5:8;	/* bits 8-15 */
+		u32 addr2_6:8;	/* bits 0-7 */
+#else
+		u32 addr2_6:8;	/* bits 0-7 */
+		u32 addr2_5:8;	/* bits 8-15 */
+		u32 addr2_4:8;	/* bits 16-23 */
+		u32 addr2_3:8;	/* bits 24-31 */
 #endif
 	} bits;
 } RXMAC_UNI_PF_ADDR2_t, *PRXMAC_UNI_PF_ADDR2_t;
@@ -1317,15 +1317,15 @@ typedef union _RXMAC_UNI_PF_ADDR3_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 addr2_1:8;	// bits 24-31
-		u32 addr2_2:8;	// bits 16-23
-		u32 addr1_1:8;	// bits 8-15
-		u32 addr1_2:8;	// bits 0-7
-#else
-		u32 addr1_2:8;	// bits 0-7
-		u32 addr1_1:8;	// bits 8-15
-		u32 addr2_2:8;	// bits 16-23
-		u32 addr2_1:8;	// bits 24-31
+		u32 addr2_1:8;	/* bits 24-31 */
+		u32 addr2_2:8;	/* bits 16-23 */
+		u32 addr1_1:8;	/* bits 8-15 */
+		u32 addr1_2:8;	/* bits 0-7 */
+#else
+		u32 addr1_2:8;	/* bits 0-7 */
+		u32 addr1_1:8;	/* bits 8-15 */
+		u32 addr2_2:8;	/* bits 16-23 */
+		u32 addr2_1:8;	/* bits 24-31 */
 #endif
 	} bits;
 } RXMAC_UNI_PF_ADDR3_t, *PRXMAC_UNI_PF_ADDR3_t;
@@ -1344,21 +1344,21 @@ typedef union _RXMAC_PF_CTRL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused2:9;		// bits 23-31
-		u32 min_pkt_size:7;	// bits 16-22
-		u32 unused1:12;		// bits 4-15
-		u32 filter_frag_en:1;	// bit 3
-		u32 filter_uni_en:1;	// bit 2
-		u32 filter_multi_en:1;	// bit 1
-		u32 filter_broad_en:1;	// bit 0
-#else
-		u32 filter_broad_en:1;	// bit 0
-		u32 filter_multi_en:1;	// bit 1
-		u32 filter_uni_en:1;	// bit 2
-		u32 filter_frag_en:1;	// bit 3
-		u32 unused1:12;		// bits 4-15
-		u32 min_pkt_size:7;	// bits 16-22
-		u32 unused2:9;		// bits 23-31
+		u32 unused2:9;		/* bits 23-31 */
+		u32 min_pkt_size:7;	/* bits 16-22 */
+		u32 unused1:12;		/* bits 4-15 */
+		u32 filter_frag_en:1;	/* bit 3 */
+		u32 filter_uni_en:1;	/* bit 2 */
+		u32 filter_multi_en:1;	/* bit 1 */
+		u32 filter_broad_en:1;	/* bit 0 */
+#else
+		u32 filter_broad_en:1;	/* bit 0 */
+		u32 filter_multi_en:1;	/* bit 1 */
+		u32 filter_uni_en:1;	/* bit 2 */
+		u32 filter_frag_en:1;	/* bit 3 */
+		u32 unused1:12;		/* bits 4-15 */
+		u32 min_pkt_size:7;	/* bits 16-22 */
+		u32 unused2:9;		/* bits 23-31 */
 #endif
 	} bits;
 } RXMAC_PF_CTRL_t, *PRXMAC_PF_CTRL_t;
@@ -1371,15 +1371,15 @@ typedef union _RXMAC_MCIF_CTRL_MAX_SEG_t
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:22;	// bits 10-31
-		u32 max_size:8;	// bits 2-9
-		u32 fc_en:1;	// bit 1
-		u32 seg_en:1;	// bit 0
-#else
-		u32 seg_en:1;	// bit 0
-		u32 fc_en:1;	// bit 1
-		u32 max_size:8;	// bits 2-9
-		u32 reserved:22;	// bits 10-31
+		u32 reserved:22;	/* bits 10-31 */
+		u32 max_size:8;	/* bits 2-9 */
+		u32 fc_en:1;	/* bit 1 */
+		u32 seg_en:1;	/* bit 0 */
+#else
+		u32 seg_en:1;	/* bit 0 */
+		u32 fc_en:1;	/* bit 1 */
+		u32 max_size:8;	/* bits 2-9 */
+		u32 reserved:22;	/* bits 10-31 */
 #endif
 	} bits;
 } RXMAC_MCIF_CTRL_MAX_SEG_t, *PRXMAC_MCIF_CTRL_MAX_SEG_t;
@@ -1392,15 +1392,15 @@ typedef union _RXMAC_MCIF_WATER_MARK_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved2:6;	// bits 26-31
-		u32 mark_hi:10;	// bits 16-25
-		u32 reserved1:6;	// bits 10-15
-		u32 mark_lo:10;	// bits 0-9
-#else
-		u32 mark_lo:10;	// bits 0-9
-		u32 reserved1:6;	// bits 10-15
-		u32 mark_hi:10;	// bits 16-25
-		u32 reserved2:6;	// bits 26-31
+		u32 reserved2:6;	/* bits 26-31 */
+		u32 mark_hi:10;	/* bits 16-25 */
+		u32 reserved1:6;	/* bits 10-15 */
+		u32 mark_lo:10;	/* bits 0-9 */
+#else
+		u32 mark_lo:10;	/* bits 0-9 */
+		u32 reserved1:6;	/* bits 10-15 */
+		u32 mark_hi:10;	/* bits 16-25 */
+		u32 reserved2:6;	/* bits 26-31 */
 #endif
 	} bits;
 } RXMAC_MCIF_WATER_MARK_t, *PRXMAC_MCIF_WATER_MARK_t;
@@ -1413,15 +1413,15 @@ typedef union _RXMAC_RXQ_DIAG_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved2:6;	// bits 26-31
-		u32 rd_ptr:10;	// bits 16-25
-		u32 reserved1:6;	// bits 10-15
-		u32 wr_ptr:10;	// bits 0-9
-#else
-		u32 wr_ptr:10;	// bits 0-9
-		u32 reserved1:6;	// bits 10-15
-		u32 rd_ptr:10;	// bits 16-25
-		u32 reserved2:6;	// bits 26-31
+		u32 reserved2:6;	/* bits 26-31 */
+		u32 rd_ptr:10;	/* bits 16-25 */
+		u32 reserved1:6;	/* bits 10-15 */
+		u32 wr_ptr:10;	/* bits 0-9 */
+#else
+		u32 wr_ptr:10;	/* bits 0-9 */
+		u32 reserved1:6;	/* bits 10-15 */
+		u32 rd_ptr:10;	/* bits 16-25 */
+		u32 reserved2:6;	/* bits 26-31 */
 #endif
 	} bits;
 } RXMAC_RXQ_DIAG_t, *PRXMAC_RXQ_DIAG_t;
@@ -1434,15 +1434,15 @@ typedef union _RXMAC_SPACE_AVAIL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved2:15;		// bits 17-31
-		u32 space_avail_en:1;	// bit 16
-		u32 reserved1:6;		// bits 10-15
-		u32 space_avail:10;	// bits 0-9
-#else
-		u32 space_avail:10;	// bits 0-9
-		u32 reserved1:6;		// bits 10-15
-		u32 space_avail_en:1;	// bit 16
-		u32 reserved2:15;		// bits 17-31
+		u32 reserved2:15;		/* bits 17-31 */
+		u32 space_avail_en:1;	/* bit 16 */
+		u32 reserved1:6;		/* bits 10-15 */
+		u32 space_avail:10;	/* bits 0-9 */
+#else
+		u32 space_avail:10;	/* bits 0-9 */
+		u32 reserved1:6;		/* bits 10-15 */
+		u32 space_avail_en:1;	/* bit 16 */
+		u32 reserved2:15;		/* bits 17-31 */
 #endif
 	} bits;
 } RXMAC_SPACE_AVAIL_t, *PRXMAC_SPACE_AVAIL_t;
@@ -1455,13 +1455,13 @@ typedef union _RXMAC_MIF_CTL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserve:14;		// bits 18-31
-		u32 drop_pkt_en:1;		// bit 17
-		u32 drop_pkt_mask:17;	// bits 0-16
-#else
-		u32 drop_pkt_mask:17;	// bits 0-16
-		u32 drop_pkt_en:1;		// bit 17
-		u32 reserve:14;		// bits 18-31
+		u32 reserve:14;		/* bits 18-31 */
+		u32 drop_pkt_en:1;		/* bit 17 */
+		u32 drop_pkt_mask:17;	/* bits 0-16 */
+#else
+		u32 drop_pkt_mask:17;	/* bits 0-16 */
+		u32 drop_pkt_en:1;		/* bit 17 */
+		u32 reserve:14;		/* bits 18-31 */
 #endif
 	} bits;
 } RXMAC_MIF_CTL_t, *PRXMAC_MIF_CTL_t;
@@ -1474,17 +1474,17 @@ typedef union _RXMAC_ERROR_REG_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserve:28;	// bits 4-31
-		u32 mif:1;		// bit 3
-		u32 async:1;	// bit 2
-		u32 pkt_filter:1;	// bit 1
-		u32 mcif:1;	// bit 0
-#else
-		u32 mcif:1;	// bit 0
-		u32 pkt_filter:1;	// bit 1
-		u32 async:1;	// bit 2
-		u32 mif:1;		// bit 3
-		u32 reserve:28;	// bits 4-31
+		u32 reserve:28;	/* bits 4-31 */
+		u32 mif:1;		/* bit 3 */
+		u32 async:1;	/* bit 2 */
+		u32 pkt_filter:1;	/* bit 1 */
+		u32 mcif:1;	/* bit 0 */
+#else
+		u32 mcif:1;	/* bit 0 */
+		u32 pkt_filter:1;	/* bit 1 */
+		u32 async:1;	/* bit 2 */
+		u32 mif:1;		/* bit 3 */
+		u32 reserve:28;	/* bits 4-31 */
 #endif
 	} bits;
 } RXMAC_ERROR_REG_t, *PRXMAC_ERROR_REG_t;
@@ -1492,48 +1492,48 @@ typedef union _RXMAC_ERROR_REG_t {
 /*
  * Rx MAC Module of JAGCore Address Mapping
  */
-typedef struct _RXMAC_t {				// Location:
-	RXMAC_CTRL_t ctrl;				//  0x4000
-	RXMAC_WOL_CTL_CRC0_t crc0;			//  0x4004
-	RXMAC_WOL_CRC12_t crc12;			//  0x4008
-	RXMAC_WOL_CRC34_t crc34;			//  0x400C
-	RXMAC_WOL_SA_LO_t sa_lo;			//  0x4010
-	RXMAC_WOL_SA_HI_t sa_hi;			//  0x4014
-	u32 mask0_word0;				//  0x4018
-	u32 mask0_word1;				//  0x401C
-	u32 mask0_word2;				//  0x4020
-	u32 mask0_word3;				//  0x4024
-	u32 mask1_word0;				//  0x4028
-	u32 mask1_word1;				//  0x402C
-	u32 mask1_word2;				//  0x4030
-	u32 mask1_word3;				//  0x4034
-	u32 mask2_word0;				//  0x4038
-	u32 mask2_word1;				//  0x403C
-	u32 mask2_word2;				//  0x4040
-	u32 mask2_word3;				//  0x4044
-	u32 mask3_word0;				//  0x4048
-	u32 mask3_word1;				//  0x404C
-	u32 mask3_word2;				//  0x4050
-	u32 mask3_word3;				//  0x4054
-	u32 mask4_word0;				//  0x4058
-	u32 mask4_word1;				//  0x405C
-	u32 mask4_word2;				//  0x4060
-	u32 mask4_word3;				//  0x4064
-	RXMAC_UNI_PF_ADDR1_t uni_pf_addr1;		//  0x4068
-	RXMAC_UNI_PF_ADDR2_t uni_pf_addr2;		//  0x406C
-	RXMAC_UNI_PF_ADDR3_t uni_pf_addr3;		//  0x4070
-	u32 multi_hash1;				//  0x4074
-	u32 multi_hash2;				//  0x4078
-	u32 multi_hash3;				//  0x407C
-	u32 multi_hash4;				//  0x4080
-	RXMAC_PF_CTRL_t pf_ctrl;			//  0x4084
-	RXMAC_MCIF_CTRL_MAX_SEG_t mcif_ctrl_max_seg;	//  0x4088
-	RXMAC_MCIF_WATER_MARK_t mcif_water_mark;	//  0x408C
-	RXMAC_RXQ_DIAG_t rxq_diag;			//  0x4090
-	RXMAC_SPACE_AVAIL_t space_avail;		//  0x4094
+typedef struct _RXMAC_t {				/* Location: */
+	RXMAC_CTRL_t ctrl;				/*  0x4000 */
+	RXMAC_WOL_CTL_CRC0_t crc0;			/*  0x4004 */
+	RXMAC_WOL_CRC12_t crc12;			/*  0x4008 */
+	RXMAC_WOL_CRC34_t crc34;			/*  0x400C */
+	RXMAC_WOL_SA_LO_t sa_lo;			/*  0x4010 */
+	RXMAC_WOL_SA_HI_t sa_hi;			/*  0x4014 */
+	u32 mask0_word0;				/*  0x4018 */
+	u32 mask0_word1;				/*  0x401C */
+	u32 mask0_word2;				/*  0x4020 */
+	u32 mask0_word3;				/*  0x4024 */
+	u32 mask1_word0;				/*  0x4028 */
+	u32 mask1_word1;				/*  0x402C */
+	u32 mask1_word2;				/*  0x4030 */
+	u32 mask1_word3;				/*  0x4034 */
+	u32 mask2_word0;				/*  0x4038 */
+	u32 mask2_word1;				/*  0x403C */
+	u32 mask2_word2;				/*  0x4040 */
+	u32 mask2_word3;				/*  0x4044 */
+	u32 mask3_word0;				/*  0x4048 */
+	u32 mask3_word1;				/*  0x404C */
+	u32 mask3_word2;				/*  0x4050 */
+	u32 mask3_word3;				/*  0x4054 */
+	u32 mask4_word0;				/*  0x4058 */
+	u32 mask4_word1;				/*  0x405C */
+	u32 mask4_word2;				/*  0x4060 */
+	u32 mask4_word3;				/*  0x4064 */
+	RXMAC_UNI_PF_ADDR1_t uni_pf_addr1;		/*  0x4068 */
+	RXMAC_UNI_PF_ADDR2_t uni_pf_addr2;		/*  0x406C */
+	RXMAC_UNI_PF_ADDR3_t uni_pf_addr3;		/*  0x4070 */
+	u32 multi_hash1;				/*  0x4074 */
+	u32 multi_hash2;				/*  0x4078 */
+	u32 multi_hash3;				/*  0x407C */
+	u32 multi_hash4;				/*  0x4080 */
+	RXMAC_PF_CTRL_t pf_ctrl;			/*  0x4084 */
+	RXMAC_MCIF_CTRL_MAX_SEG_t mcif_ctrl_max_seg;	/*  0x4088 */
+	RXMAC_MCIF_WATER_MARK_t mcif_water_mark;	/*  0x408C */
+	RXMAC_RXQ_DIAG_t rxq_diag;			/*  0x4090 */
+	RXMAC_SPACE_AVAIL_t space_avail;		/*  0x4094 */
 
-	RXMAC_MIF_CTL_t mif_ctrl;			//  0x4098
-	RXMAC_ERROR_REG_t err_reg;			//  0x409C
+	RXMAC_MIF_CTL_t mif_ctrl;			/*  0x4098 */
+	RXMAC_ERROR_REG_t err_reg;			/*  0x409C */
 } RXMAC_t, *PRXMAC_t;
 
 /* END OF TXMAC REGISTER ADDRESS MAP */
@@ -1549,39 +1549,39 @@ typedef union _MAC_CFG1_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 soft_reset:1;		// bit 31
-		u32 sim_reset:1;		// bit 30
-		u32 reserved3:10;		// bits 20-29
-		u32 reset_rx_mc:1;		// bit 19
-		u32 reset_tx_mc:1;		// bit 18
-		u32 reset_rx_fun:1;	// bit 17
-		u32 reset_tx_fun:1;	// bit 16
-		u32 reserved2:7;		// bits 9-15
-		u32 loop_back:1;		// bit 8
-		u32 reserved1:2;		// bits 6-7
-		u32 rx_flow:1;		// bit 5
-		u32 tx_flow:1;		// bit 4
-		u32 syncd_rx_en:1;		// bit 3
-		u32 rx_enable:1;		// bit 2
-		u32 syncd_tx_en:1;		// bit 1
-		u32 tx_enable:1;		// bit 0
-#else
-		u32 tx_enable:1;		// bit 0
-		u32 syncd_tx_en:1;		// bit 1
-		u32 rx_enable:1;		// bit 2
-		u32 syncd_rx_en:1;		// bit 3
-		u32 tx_flow:1;		// bit 4
-		u32 rx_flow:1;		// bit 5
-		u32 reserved1:2;		// bits 6-7
-		u32 loop_back:1;		// bit 8
-		u32 reserved2:7;		// bits 9-15
-		u32 reset_tx_fun:1;	// bit 16
-		u32 reset_rx_fun:1;	// bit 17
-		u32 reset_tx_mc:1;		// bit 18
-		u32 reset_rx_mc:1;		// bit 19
-		u32 reserved3:10;		// bits 20-29
-		u32 sim_reset:1;		// bit 30
-		u32 soft_reset:1;		// bit 31
+		u32 soft_reset:1;		/* bit 31 */
+		u32 sim_reset:1;		/* bit 30 */
+		u32 reserved3:10;		/* bits 20-29 */
+		u32 reset_rx_mc:1;		/* bit 19 */
+		u32 reset_tx_mc:1;		/* bit 18 */
+		u32 reset_rx_fun:1;	/* bit 17 */
+		u32 reset_tx_fun:1;	/* bit 16 */
+		u32 reserved2:7;		/* bits 9-15 */
+		u32 loop_back:1;		/* bit 8 */
+		u32 reserved1:2;		/* bits 6-7 */
+		u32 rx_flow:1;		/* bit 5 */
+		u32 tx_flow:1;		/* bit 4 */
+		u32 syncd_rx_en:1;		/* bit 3 */
+		u32 rx_enable:1;		/* bit 2 */
+		u32 syncd_tx_en:1;		/* bit 1 */
+		u32 tx_enable:1;		/* bit 0 */
+#else
+		u32 tx_enable:1;		/* bit 0 */
+		u32 syncd_tx_en:1;		/* bit 1 */
+		u32 rx_enable:1;		/* bit 2 */
+		u32 syncd_rx_en:1;		/* bit 3 */
+		u32 tx_flow:1;		/* bit 4 */
+		u32 rx_flow:1;		/* bit 5 */
+		u32 reserved1:2;		/* bits 6-7 */
+		u32 loop_back:1;		/* bit 8 */
+		u32 reserved2:7;		/* bits 9-15 */
+		u32 reset_tx_fun:1;	/* bit 16 */
+		u32 reset_rx_fun:1;	/* bit 17 */
+		u32 reset_tx_mc:1;		/* bit 18 */
+		u32 reset_rx_mc:1;		/* bit 19 */
+		u32 reserved3:10;		/* bits 20-29 */
+		u32 sim_reset:1;		/* bit 30 */
+		u32 soft_reset:1;		/* bit 31 */
 #endif
 	} bits;
 } MAC_CFG1_t, *PMAC_CFG1_t;
@@ -1594,29 +1594,29 @@ typedef union _MAC_CFG2_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved3:16;		// bits 16-31
-		u32 preamble_len:4;	// bits 12-15
-		u32 reserved2:2;		// bits 10-11
-		u32 if_mode:2;		// bits 8-9
-		u32 reserved1:2;		// bits 6-7
-		u32 huge_frame:1;		// bit 5
-		u32 len_check:1;		// bit 4
-		u32 undefined:1;		// bit 3
-		u32 pad_crc:1;		// bit 2
-		u32 crc_enable:1;		// bit 1
-		u32 full_duplex:1;		// bit 0
-#else
-		u32 full_duplex:1;		// bit 0
-		u32 crc_enable:1;		// bit 1
-		u32 pad_crc:1;		// bit 2
-		u32 undefined:1;		// bit 3
-		u32 len_check:1;		// bit 4
-		u32 huge_frame:1;		// bit 5
-		u32 reserved1:2;		// bits 6-7
-		u32 if_mode:2;		// bits 8-9
-		u32 reserved2:2;		// bits 10-11
-		u32 preamble_len:4;	// bits 12-15
-		u32 reserved3:16;		// bits 16-31
+		u32 reserved3:16;		/* bits 16-31 */
+		u32 preamble_len:4;	/* bits 12-15 */
+		u32 reserved2:2;		/* bits 10-11 */
+		u32 if_mode:2;		/* bits 8-9 */
+		u32 reserved1:2;		/* bits 6-7 */
+		u32 huge_frame:1;		/* bit 5 */
+		u32 len_check:1;		/* bit 4 */
+		u32 undefined:1;		/* bit 3 */
+		u32 pad_crc:1;		/* bit 2 */
+		u32 crc_enable:1;		/* bit 1 */
+		u32 full_duplex:1;		/* bit 0 */
+#else
+		u32 full_duplex:1;		/* bit 0 */
+		u32 crc_enable:1;		/* bit 1 */
+		u32 pad_crc:1;		/* bit 2 */
+		u32 undefined:1;		/* bit 3 */
+		u32 len_check:1;		/* bit 4 */
+		u32 huge_frame:1;		/* bit 5 */
+		u32 reserved1:2;		/* bits 6-7 */
+		u32 if_mode:2;		/* bits 8-9 */
+		u32 reserved2:2;		/* bits 10-11 */
+		u32 preamble_len:4;	/* bits 12-15 */
+		u32 reserved3:16;		/* bits 16-31 */
 #endif
 	} bits;
 } MAC_CFG2_t, *PMAC_CFG2_t;
@@ -1629,21 +1629,21 @@ typedef union _MAC_IPG_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:1;		// bit 31
-		u32 non_B2B_ipg_1:7;	// bits 24-30
-		u32 undefined2:1;		// bit 23
-		u32 non_B2B_ipg_2:7;	// bits 16-22
-		u32 min_ifg_enforce:8;	// bits 8-15
-		u32 undefined1:1;		// bit 7
-		u32 B2B_ipg:7;		// bits 0-6
-#else
-		u32 B2B_ipg:7;		// bits 0-6
-		u32 undefined1:1;		// bit 7
-		u32 min_ifg_enforce:8;	// bits 8-15
-		u32 non_B2B_ipg_2:7;	// bits 16-22
-		u32 undefined2:1;		// bit 23
-		u32 non_B2B_ipg_1:7;	// bits 24-30
-		u32 reserved:1;		// bit 31
+		u32 reserved:1;		/* bit 31 */
+		u32 non_B2B_ipg_1:7;	/* bits 24-30 */
+		u32 undefined2:1;		/* bit 23 */
+		u32 non_B2B_ipg_2:7;	/* bits 16-22 */
+		u32 min_ifg_enforce:8;	/* bits 8-15 */
+		u32 undefined1:1;		/* bit 7 */
+		u32 B2B_ipg:7;		/* bits 0-6 */
+#else
+		u32 B2B_ipg:7;		/* bits 0-6 */
+		u32 undefined1:1;		/* bit 7 */
+		u32 min_ifg_enforce:8;	/* bits 8-15 */
+		u32 non_B2B_ipg_2:7;	/* bits 16-22 */
+		u32 undefined2:1;		/* bit 23 */
+		u32 non_B2B_ipg_1:7;	/* bits 24-30 */
+		u32 reserved:1;		/* bit 31 */
 #endif
 	} bits;
 } MAC_IPG_t, *PMAC_IPG_t;
@@ -1656,25 +1656,25 @@ typedef union _MAC_HFDP_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved2:8;		// bits 24-31
-		u32 alt_beb_trunc:4;	// bits 23-20
-		u32 alt_beb_enable:1;	// bit 19
-		u32 bp_no_backoff:1;	// bit 18
-		u32 no_backoff:1;		// bit 17
-		u32 excess_defer:1;	// bit 16
-		u32 rexmit_max:4;		// bits 12-15
-		u32 reserved1:2;		// bits 10-11
-		u32 coll_window:10;	// bits 0-9
-#else
-		u32 coll_window:10;	// bits 0-9
-		u32 reserved1:2;		// bits 10-11
-		u32 rexmit_max:4;		// bits 12-15
-		u32 excess_defer:1;	// bit 16
-		u32 no_backoff:1;		// bit 17
-		u32 bp_no_backoff:1;	// bit 18
-		u32 alt_beb_enable:1;	// bit 19
-		u32 alt_beb_trunc:4;	// bits 23-20
-		u32 reserved2:8;		// bits 24-31
+		u32 reserved2:8;		/* bits 24-31 */
+		u32 alt_beb_trunc:4;	/* bits 23-20 */
+		u32 alt_beb_enable:1;	/* bit 19 */
+		u32 bp_no_backoff:1;	/* bit 18 */
+		u32 no_backoff:1;		/* bit 17 */
+		u32 excess_defer:1;	/* bit 16 */
+		u32 rexmit_max:4;		/* bits 12-15 */
+		u32 reserved1:2;		/* bits 10-11 */
+		u32 coll_window:10;	/* bits 0-9 */
+#else
+		u32 coll_window:10;	/* bits 0-9 */
+		u32 reserved1:2;		/* bits 10-11 */
+		u32 rexmit_max:4;		/* bits 12-15 */
+		u32 excess_defer:1;	/* bit 16 */
+		u32 no_backoff:1;		/* bit 17 */
+		u32 bp_no_backoff:1;	/* bit 18 */
+		u32 alt_beb_enable:1;	/* bit 19 */
+		u32 alt_beb_trunc:4;	/* bits 23-20 */
+		u32 reserved2:8;		/* bits 24-31 */
 #endif
 	} bits;
 } MAC_HFDP_t, *PMAC_HFDP_t;
@@ -1687,11 +1687,11 @@ typedef union _MAC_MAX_FM_LEN_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:16;	// bits 16-31
-		u32 max_len:16;	// bits 0-15
+		u32 reserved:16;	/* bits 16-31 */
+		u32 max_len:16;	/* bits 0-15 */
 #else
-		u32 max_len:16;	// bits 0-15
-		u32 reserved:16;	// bits 16-31
+		u32 max_len:16;	/* bits 0-15 */
+		u32 reserved:16;	/* bits 16-31 */
 #endif
 	} bits;
 } MAC_MAX_FM_LEN_t, *PMAC_MAX_FM_LEN_t;
@@ -1710,11 +1710,11 @@ typedef union _MAC_TEST_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:29;	// bits 3-31
-		u32 mac_test:3;	// bits 0-2
+		u32 unused:29;	/* bits 3-31 */
+		u32 mac_test:3;	/* bits 0-2 */
 #else
-		u32 mac_test:3;	// bits 0-2
-		u32 unused:29;	// bits 3-31
+		u32 mac_test:3;	/* bits 0-2 */
+		u32 unused:29;	/* bits 3-31 */
 #endif
 	} bits;
 } MAC_TEST_t, *PMAC_TEST_t;
@@ -1727,19 +1727,19 @@ typedef union _MII_MGMT_CFG_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reset_mii_mgmt:1;	// bit 31
-		u32 reserved:25;		// bits 6-30
-		u32 scan_auto_incremt:1;	// bit 5
-		u32 preamble_suppress:1;	// bit 4
-		u32 undefined:1;		// bit 3
-		u32 mgmt_clk_reset:3;	// bits 0-2
-#else
-		u32 mgmt_clk_reset:3;	// bits 0-2
-		u32 undefined:1;		// bit 3
-		u32 preamble_suppress:1;	// bit 4
-		u32 scan_auto_incremt:1;	// bit 5
-		u32 reserved:25;		// bits 6-30
-		u32 reset_mii_mgmt:1;	// bit 31
+		u32 reset_mii_mgmt:1;	/* bit 31 */
+		u32 reserved:25;		/* bits 6-30 */
+		u32 scan_auto_incremt:1;	/* bit 5 */
+		u32 preamble_suppress:1;	/* bit 4 */
+		u32 undefined:1;		/* bit 3 */
+		u32 mgmt_clk_reset:3;	/* bits 0-2 */
+#else
+		u32 mgmt_clk_reset:3;	/* bits 0-2 */
+		u32 undefined:1;		/* bit 3 */
+		u32 preamble_suppress:1;	/* bit 4 */
+		u32 scan_auto_incremt:1;	/* bit 5 */
+		u32 reserved:25;		/* bits 6-30 */
+		u32 reset_mii_mgmt:1;	/* bit 31 */
 #endif
 	} bits;
 } MII_MGMT_CFG_t, *PMII_MGMT_CFG_t;
@@ -1752,13 +1752,13 @@ typedef union _MII_MGMT_CMD_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:30;	// bits 2-31
-		u32 scan_cycle:1;	// bit 1
-		u32 read_cycle:1;	// bit 0
-#else
-		u32 read_cycle:1;	// bit 0
-		u32 scan_cycle:1;	// bit 1
-		u32 reserved:30;	// bits 2-31
+		u32 reserved:30;	/* bits 2-31 */
+		u32 scan_cycle:1;	/* bit 1 */
+		u32 read_cycle:1;	/* bit 0 */
+#else
+		u32 read_cycle:1;	/* bit 0 */
+		u32 scan_cycle:1;	/* bit 1 */
+		u32 reserved:30;	/* bits 2-31 */
 #endif
 	} bits;
 } MII_MGMT_CMD_t, *PMII_MGMT_CMD_t;
@@ -1771,15 +1771,15 @@ typedef union _MII_MGMT_ADDR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved2:19;	// bit 13-31
-		u32 phy_addr:5;	// bits 8-12
-		u32 reserved1:3;	// bits 5-7
-		u32 reg_addr:5;	// bits 0-4
-#else
-		u32 reg_addr:5;	// bits 0-4
-		u32 reserved1:3;	// bits 5-7
-		u32 phy_addr:5;	// bits 8-12
-		u32 reserved2:19;	// bit 13-31
+		u32 reserved2:19;	/* bit 13-31 */
+		u32 phy_addr:5;	/* bits 8-12 */
+		u32 reserved1:3;	/* bits 5-7 */
+		u32 reg_addr:5;	/* bits 0-4 */
+#else
+		u32 reg_addr:5;	/* bits 0-4 */
+		u32 reserved1:3;	/* bits 5-7 */
+		u32 phy_addr:5;	/* bits 8-12 */
+		u32 reserved2:19;	/* bit 13-31 */
 #endif
 	} bits;
 } MII_MGMT_ADDR_t, *PMII_MGMT_ADDR_t;
@@ -1792,11 +1792,11 @@ typedef union _MII_MGMT_CTRL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:16;	// bits 16-31
-		u32 phy_ctrl:16;	// bits 0-15
+		u32 reserved:16;	/* bits 16-31 */
+		u32 phy_ctrl:16;	/* bits 0-15 */
 #else
-		u32 phy_ctrl:16;	// bits 0-15
-		u32 reserved:16;	// bits 16-31
+		u32 phy_ctrl:16;	/* bits 0-15 */
+		u32 reserved:16;	/* bits 16-31 */
 #endif
 	} bits;
 } MII_MGMT_CTRL_t, *PMII_MGMT_CTRL_t;
@@ -1809,11 +1809,11 @@ typedef union _MII_MGMT_STAT_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:16;	// bits 16-31
-		u32 phy_stat:16;	// bits 0-15
+		u32 reserved:16;	/* bits 16-31 */
+		u32 phy_stat:16;	/* bits 0-15 */
 #else
-		u32 phy_stat:16;	// bits 0-15
-		u32 reserved:16;	// bits 16-31
+		u32 phy_stat:16;	/* bits 0-15 */
+		u32 reserved:16;	/* bits 16-31 */
 #endif
 	} bits;
 } MII_MGMT_STAT_t, *PMII_MGMT_STAT_t;
@@ -1826,15 +1826,15 @@ typedef union _MII_MGMT_INDICATOR_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:29;	// bits 3-31
-		u32 not_valid:1;	// bit 2
-		u32 scanning:1;	// bit 1
-		u32 busy:1;	// bit 0
-#else
-		u32 busy:1;	// bit 0
-		u32 scanning:1;	// bit 1
-		u32 not_valid:1;	// bit 2
-		u32 reserved:29;	// bits 3-31
+		u32 reserved:29;	/* bits 3-31 */
+		u32 not_valid:1;	/* bit 2 */
+		u32 scanning:1;	/* bit 1 */
+		u32 busy:1;	/* bit 0 */
+#else
+		u32 busy:1;	/* bit 0 */
+		u32 scanning:1;	/* bit 1 */
+		u32 not_valid:1;	/* bit 2 */
+		u32 reserved:29;	/* bits 3-31 */
 #endif
 	} bits;
 } MII_MGMT_INDICATOR_t, *PMII_MGMT_INDICATOR_t;
@@ -1847,41 +1847,41 @@ typedef union _MAC_IF_CTRL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reset_if_module:1;	// bit 31
-		u32 reserved4:3;		// bit 28-30
-		u32 tbi_mode:1;		// bit 27
-		u32 ghd_mode:1;		// bit 26
-		u32 lhd_mode:1;		// bit 25
-		u32 phy_mode:1;		// bit 24
-		u32 reset_per_mii:1;	// bit 23
-		u32 reserved3:6;		// bits 17-22
-		u32 speed:1;		// bit 16
-		u32 reset_pe100x:1;	// bit 15
-		u32 reserved2:4;		// bits 11-14
-		u32 force_quiet:1;		// bit 10
-		u32 no_cipher:1;		// bit 9
-		u32 disable_link_fail:1;	// bit 8
-		u32 reset_gpsi:1;		// bit 7
-		u32 reserved1:6;		// bits 1-6
-		u32 enab_jab_protect:1;	// bit 0
-#else
-		u32 enab_jab_protect:1;	// bit 0
-		u32 reserved1:6;		// bits 1-6
-		u32 reset_gpsi:1;		// bit 7
-		u32 disable_link_fail:1;	// bit 8
-		u32 no_cipher:1;		// bit 9
-		u32 force_quiet:1;		// bit 10
-		u32 reserved2:4;		// bits 11-14
-		u32 reset_pe100x:1;	// bit 15
-		u32 speed:1;		// bit 16
-		u32 reserved3:6;		// bits 17-22
-		u32 reset_per_mii:1;	// bit 23
-		u32 phy_mode:1;		// bit 24
-		u32 lhd_mode:1;		// bit 25
-		u32 ghd_mode:1;		// bit 26
-		u32 tbi_mode:1;		// bit 27
-		u32 reserved4:3;		// bit 28-30
-		u32 reset_if_module:1;	// bit 31
+		u32 reset_if_module:1;	/* bit 31 */
+		u32 reserved4:3;		/* bit 28-30 */
+		u32 tbi_mode:1;		/* bit 27 */
+		u32 ghd_mode:1;		/* bit 26 */
+		u32 lhd_mode:1;		/* bit 25 */
+		u32 phy_mode:1;		/* bit 24 */
+		u32 reset_per_mii:1;	/* bit 23 */
+		u32 reserved3:6;		/* bits 17-22 */
+		u32 speed:1;		/* bit 16 */
+		u32 reset_pe100x:1;	/* bit 15 */
+		u32 reserved2:4;		/* bits 11-14 */
+		u32 force_quiet:1;		/* bit 10 */
+		u32 no_cipher:1;		/* bit 9 */
+		u32 disable_link_fail:1;	/* bit 8 */
+		u32 reset_gpsi:1;		/* bit 7 */
+		u32 reserved1:6;		/* bits 1-6 */
+		u32 enab_jab_protect:1;	/* bit 0 */
+#else
+		u32 enab_jab_protect:1;	/* bit 0 */
+		u32 reserved1:6;		/* bits 1-6 */
+		u32 reset_gpsi:1;		/* bit 7 */
+		u32 disable_link_fail:1;	/* bit 8 */
+		u32 no_cipher:1;		/* bit 9 */
+		u32 force_quiet:1;		/* bit 10 */
+		u32 reserved2:4;		/* bits 11-14 */
+		u32 reset_pe100x:1;	/* bit 15 */
+		u32 speed:1;		/* bit 16 */
+		u32 reserved3:6;		/* bits 17-22 */
+		u32 reset_per_mii:1;	/* bit 23 */
+		u32 phy_mode:1;		/* bit 24 */
+		u32 lhd_mode:1;		/* bit 25 */
+		u32 ghd_mode:1;		/* bit 26 */
+		u32 tbi_mode:1;		/* bit 27 */
+		u32 reserved4:3;		/* bit 28-30 */
+		u32 reset_if_module:1;	/* bit 31 */
 #endif
 	} bits;
 } MAC_IF_CTRL_t, *PMAC_IF_CTRL_t;
@@ -1894,29 +1894,29 @@ typedef union _MAC_IF_STAT_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:22;		// bits 10-31
-		u32 excess_defer:1;	// bit 9
-		u32 clash:1;		// bit 8
-		u32 phy_jabber:1;		// bit 7
-		u32 phy_link_ok:1;		// bit 6
-		u32 phy_full_duplex:1;	// bit 5
-		u32 phy_speed:1;		// bit 4
-		u32 pe100x_link_fail:1;	// bit 3
-		u32 pe10t_loss_carrie:1;	// bit 2
-		u32 pe10t_sqe_error:1;	// bit 1
-		u32 pe10t_jabber:1;	// bit 0
-#else
-		u32 pe10t_jabber:1;	// bit 0
-		u32 pe10t_sqe_error:1;	// bit 1
-		u32 pe10t_loss_carrie:1;	// bit 2
-		u32 pe100x_link_fail:1;	// bit 3
-		u32 phy_speed:1;		// bit 4
-		u32 phy_full_duplex:1;	// bit 5
-		u32 phy_link_ok:1;		// bit 6
-		u32 phy_jabber:1;		// bit 7
-		u32 clash:1;		// bit 8
-		u32 excess_defer:1;	// bit 9
-		u32 reserved:22;		// bits 10-31
+		u32 reserved:22;		/* bits 10-31 */
+		u32 excess_defer:1;	/* bit 9 */
+		u32 clash:1;		/* bit 8 */
+		u32 phy_jabber:1;		/* bit 7 */
+		u32 phy_link_ok:1;		/* bit 6 */
+		u32 phy_full_duplex:1;	/* bit 5 */
+		u32 phy_speed:1;		/* bit 4 */
+		u32 pe100x_link_fail:1;	/* bit 3 */
+		u32 pe10t_loss_carrie:1;	/* bit 2 */
+		u32 pe10t_sqe_error:1;	/* bit 1 */
+		u32 pe10t_jabber:1;	/* bit 0 */
+#else
+		u32 pe10t_jabber:1;	/* bit 0 */
+		u32 pe10t_sqe_error:1;	/* bit 1 */
+		u32 pe10t_loss_carrie:1;	/* bit 2 */
+		u32 pe100x_link_fail:1;	/* bit 3 */
+		u32 phy_speed:1;		/* bit 4 */
+		u32 phy_full_duplex:1;	/* bit 5 */
+		u32 phy_link_ok:1;		/* bit 6 */
+		u32 phy_jabber:1;		/* bit 7 */
+		u32 clash:1;		/* bit 8 */
+		u32 excess_defer:1;	/* bit 9 */
+		u32 reserved:22;		/* bits 10-31 */
 #endif
 	} bits;
 } MAC_IF_STAT_t, *PMAC_IF_STAT_t;
@@ -1929,15 +1929,15 @@ typedef union _MAC_STATION_ADDR1_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 Octet6:8;	// bits 24-31
-		u32 Octet5:8;	// bits 16-23
-		u32 Octet4:8;	// bits 8-15
-		u32 Octet3:8;	// bits 0-7
-#else
-		u32 Octet3:8;	// bits 0-7
-		u32 Octet4:8;	// bits 8-15
-		u32 Octet5:8;	// bits 16-23
-		u32 Octet6:8;	// bits 24-31
+		u32 Octet6:8;	/* bits 24-31 */
+		u32 Octet5:8;	/* bits 16-23 */
+		u32 Octet4:8;	/* bits 8-15 */
+		u32 Octet3:8;	/* bits 0-7 */
+#else
+		u32 Octet3:8;	/* bits 0-7 */
+		u32 Octet4:8;	/* bits 8-15 */
+		u32 Octet5:8;	/* bits 16-23 */
+		u32 Octet6:8;	/* bits 24-31 */
 #endif
 	} bits;
 } MAC_STATION_ADDR1_t, *PMAC_STATION_ADDR1_t;
@@ -1950,13 +1950,13 @@ typedef union _MAC_STATION_ADDR2_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 Octet2:8;	// bits 24-31
-		u32 Octet1:8;	// bits 16-23
-		u32 reserved:16;	// bits 0-15
-#else
-		u32 reserved:16;	// bit 0-15
-		u32 Octet1:8;	// bits 16-23
-		u32 Octet2:8;	// bits 24-31
+		u32 Octet2:8;	/* bits 24-31 */
+		u32 Octet1:8;	/* bits 16-23 */
+		u32 reserved:16;	/* bits 0-15 */
+#else
+		u32 reserved:16;	/* bit 0-15 */
+		u32 Octet1:8;	/* bits 16-23 */
+		u32 Octet2:8;	/* bits 24-31 */
 #endif
 	} bits;
 } MAC_STATION_ADDR2_t, *PMAC_STATION_ADDR2_t;
@@ -1964,25 +1964,25 @@ typedef union _MAC_STATION_ADDR2_t {
 /*
  * MAC Module of JAGCore Address Mapping
  */
-typedef struct _MAC_t {					// Location:
-	MAC_CFG1_t cfg1;				//  0x5000
-	MAC_CFG2_t cfg2;				//  0x5004
-	MAC_IPG_t ipg;					//  0x5008
-	MAC_HFDP_t hfdp;				//  0x500C
-	MAC_MAX_FM_LEN_t max_fm_len;			//  0x5010
-	u32 rsv1;					//  0x5014
-	u32 rsv2;					//  0x5018
-	MAC_TEST_t mac_test;				//  0x501C
-	MII_MGMT_CFG_t mii_mgmt_cfg;			//  0x5020
-	MII_MGMT_CMD_t mii_mgmt_cmd;			//  0x5024
-	MII_MGMT_ADDR_t mii_mgmt_addr;			//  0x5028
-	MII_MGMT_CTRL_t mii_mgmt_ctrl;			//  0x502C
-	MII_MGMT_STAT_t mii_mgmt_stat;			//  0x5030
-	MII_MGMT_INDICATOR_t mii_mgmt_indicator;	//  0x5034
-	MAC_IF_CTRL_t if_ctrl;				//  0x5038
-	MAC_IF_STAT_t if_stat;				//  0x503C
-	MAC_STATION_ADDR1_t station_addr_1;		//  0x5040
-	MAC_STATION_ADDR2_t station_addr_2;		//  0x5044
+typedef struct _MAC_t {					/* Location: */
+	MAC_CFG1_t cfg1;				/*  0x5000 */
+	MAC_CFG2_t cfg2;				/*  0x5004 */
+	MAC_IPG_t ipg;					/*  0x5008 */
+	MAC_HFDP_t hfdp;				/*  0x500C */
+	MAC_MAX_FM_LEN_t max_fm_len;			/*  0x5010 */
+	u32 rsv1;					/*  0x5014 */
+	u32 rsv2;					/*  0x5018 */
+	MAC_TEST_t mac_test;				/*  0x501C */
+	MII_MGMT_CFG_t mii_mgmt_cfg;			/*  0x5020 */
+	MII_MGMT_CMD_t mii_mgmt_cmd;			/*  0x5024 */
+	MII_MGMT_ADDR_t mii_mgmt_addr;			/*  0x5028 */
+	MII_MGMT_CTRL_t mii_mgmt_ctrl;			/*  0x502C */
+	MII_MGMT_STAT_t mii_mgmt_stat;			/*  0x5030 */
+	MII_MGMT_INDICATOR_t mii_mgmt_indicator;	/*  0x5034 */
+	MAC_IF_CTRL_t if_ctrl;				/*  0x5038 */
+	MAC_IF_STAT_t if_stat;				/*  0x503C */
+	MAC_STATION_ADDR1_t station_addr_1;		/*  0x5040 */
+	MAC_STATION_ADDR2_t station_addr_2;		/*  0x5044 */
 } MAC_t, *PMAC_t;
 
 /* END OF MAC REGISTER ADDRESS MAP */
@@ -1997,57 +1997,57 @@ typedef union _MAC_STAT_REG_1_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 tr64:1;	// bit 31
-		u32 tr127:1;	// bit 30
-		u32 tr255:1;	// bit 29
-		u32 tr511:1;	// bit 28
-		u32 tr1k:1;	// bit 27
-		u32 trmax:1;	// bit 26
-		u32 trmgv:1;	// bit 25
-		u32 unused:8;	// bits 17-24
-		u32 rbyt:1;	// bit 16
-		u32 rpkt:1;	// bit 15
-		u32 rfcs:1;	// bit 14
-		u32 rmca:1;	// bit 13
-		u32 rbca:1;	// bit 12
-		u32 rxcf:1;	// bit 11
-		u32 rxpf:1;	// bit 10
-		u32 rxuo:1;	// bit 9
-		u32 raln:1;	// bit 8
-		u32 rflr:1;	// bit 7
-		u32 rcde:1;	// bit 6
-		u32 rcse:1;	// bit 5
-		u32 rund:1;	// bit 4
-		u32 rovr:1;	// bit 3
-		u32 rfrg:1;	// bit 2
-		u32 rjbr:1;	// bit 1
-		u32 rdrp:1;	// bit 0
-#else
-		u32 rdrp:1;	// bit 0
-		u32 rjbr:1;	// bit 1
-		u32 rfrg:1;	// bit 2
-		u32 rovr:1;	// bit 3
-		u32 rund:1;	// bit 4
-		u32 rcse:1;	// bit 5
-		u32 rcde:1;	// bit 6
-		u32 rflr:1;	// bit 7
-		u32 raln:1;	// bit 8
-		u32 rxuo:1;	// bit 9
-		u32 rxpf:1;	// bit 10
-		u32 rxcf:1;	// bit 11
-		u32 rbca:1;	// bit 12
-		u32 rmca:1;	// bit 13
-		u32 rfcs:1;	// bit 14
-		u32 rpkt:1;	// bit 15
-		u32 rbyt:1;	// bit 16
-		u32 unused:8;	// bits 17-24
-		u32 trmgv:1;	// bit 25
-		u32 trmax:1;	// bit 26
-		u32 tr1k:1;	// bit 27
-		u32 tr511:1;	// bit 28
-		u32 tr255:1;	// bit 29
-		u32 tr127:1;	// bit 30
-		u32 tr64:1;	// bit 31
+		u32 tr64:1;	/* bit 31 */
+		u32 tr127:1;	/* bit 30 */
+		u32 tr255:1;	/* bit 29 */
+		u32 tr511:1;	/* bit 28 */
+		u32 tr1k:1;	/* bit 27 */
+		u32 trmax:1;	/* bit 26 */
+		u32 trmgv:1;	/* bit 25 */
+		u32 unused:8;	/* bits 17-24 */
+		u32 rbyt:1;	/* bit 16 */
+		u32 rpkt:1;	/* bit 15 */
+		u32 rfcs:1;	/* bit 14 */
+		u32 rmca:1;	/* bit 13 */
+		u32 rbca:1;	/* bit 12 */
+		u32 rxcf:1;	/* bit 11 */
+		u32 rxpf:1;	/* bit 10 */
+		u32 rxuo:1;	/* bit 9 */
+		u32 raln:1;	/* bit 8 */
+		u32 rflr:1;	/* bit 7 */
+		u32 rcde:1;	/* bit 6 */
+		u32 rcse:1;	/* bit 5 */
+		u32 rund:1;	/* bit 4 */
+		u32 rovr:1;	/* bit 3 */
+		u32 rfrg:1;	/* bit 2 */
+		u32 rjbr:1;	/* bit 1 */
+		u32 rdrp:1;	/* bit 0 */
+#else
+		u32 rdrp:1;	/* bit 0 */
+		u32 rjbr:1;	/* bit 1 */
+		u32 rfrg:1;	/* bit 2 */
+		u32 rovr:1;	/* bit 3 */
+		u32 rund:1;	/* bit 4 */
+		u32 rcse:1;	/* bit 5 */
+		u32 rcde:1;	/* bit 6 */
+		u32 rflr:1;	/* bit 7 */
+		u32 raln:1;	/* bit 8 */
+		u32 rxuo:1;	/* bit 9 */
+		u32 rxpf:1;	/* bit 10 */
+		u32 rxcf:1;	/* bit 11 */
+		u32 rbca:1;	/* bit 12 */
+		u32 rmca:1;	/* bit 13 */
+		u32 rfcs:1;	/* bit 14 */
+		u32 rpkt:1;	/* bit 15 */
+		u32 rbyt:1;	/* bit 16 */
+		u32 unused:8;	/* bits 17-24 */
+		u32 trmgv:1;	/* bit 25 */
+		u32 trmax:1;	/* bit 26 */
+		u32 tr1k:1;	/* bit 27 */
+		u32 tr511:1;	/* bit 28 */
+		u32 tr255:1;	/* bit 29 */
+		u32 tr127:1;	/* bit 30 */
+		u32 tr64:1;	/* bit 31 */
 #endif
 	} bits;
 } MAC_STAT_REG_1_t, *PMAC_STAT_REG_1_t;
@@ -2060,49 +2060,49 @@ typedef union _MAC_STAT_REG_2_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:12;	// bit 20-31
-		u32 tjbr:1;	// bit 19
-		u32 tfcs:1;	// bit 18
-		u32 txcf:1;	// bit 17
-		u32 tovr:1;	// bit 16
-		u32 tund:1;	// bit 15
-		u32 tfrg:1;	// bit 14
-		u32 tbyt:1;	// bit 13
-		u32 tpkt:1;	// bit 12
-		u32 tmca:1;	// bit 11
-		u32 tbca:1;	// bit 10
-		u32 txpf:1;	// bit 9
-		u32 tdfr:1;	// bit 8
-		u32 tedf:1;	// bit 7
-		u32 tscl:1;	// bit 6
-		u32 tmcl:1;	// bit 5
-		u32 tlcl:1;	// bit 4
-		u32 txcl:1;	// bit 3
-		u32 tncl:1;	// bit 2
-		u32 tpfh:1;	// bit 1
-		u32 tdrp:1;	// bit 0
-#else
-		u32 tdrp:1;	// bit 0
-		u32 tpfh:1;	// bit 1
-		u32 tncl:1;	// bit 2
-		u32 txcl:1;	// bit 3
-		u32 tlcl:1;	// bit 4
-		u32 tmcl:1;	// bit 5
-		u32 tscl:1;	// bit 6
-		u32 tedf:1;	// bit 7
-		u32 tdfr:1;	// bit 8
-		u32 txpf:1;	// bit 9
-		u32 tbca:1;	// bit 10
-		u32 tmca:1;	// bit 11
-		u32 tpkt:1;	// bit 12
-		u32 tbyt:1;	// bit 13
-		u32 tfrg:1;	// bit 14
-		u32 tund:1;	// bit 15
-		u32 tovr:1;	// bit 16
-		u32 txcf:1;	// bit 17
-		u32 tfcs:1;	// bit 18
-		u32 tjbr:1;	// bit 19
-		u32 unused:12;	// bit 20-31
+		u32 unused:12;	/* bit 20-31 */
+		u32 tjbr:1;	/* bit 19 */
+		u32 tfcs:1;	/* bit 18 */
+		u32 txcf:1;	/* bit 17 */
+		u32 tovr:1;	/* bit 16 */
+		u32 tund:1;	/* bit 15 */
+		u32 tfrg:1;	/* bit 14 */
+		u32 tbyt:1;	/* bit 13 */
+		u32 tpkt:1;	/* bit 12 */
+		u32 tmca:1;	/* bit 11 */
+		u32 tbca:1;	/* bit 10 */
+		u32 txpf:1;	/* bit 9 */
+		u32 tdfr:1;	/* bit 8 */
+		u32 tedf:1;	/* bit 7 */
+		u32 tscl:1;	/* bit 6 */
+		u32 tmcl:1;	/* bit 5 */
+		u32 tlcl:1;	/* bit 4 */
+		u32 txcl:1;	/* bit 3 */
+		u32 tncl:1;	/* bit 2 */
+		u32 tpfh:1;	/* bit 1 */
+		u32 tdrp:1;	/* bit 0 */
+#else
+		u32 tdrp:1;	/* bit 0 */
+		u32 tpfh:1;	/* bit 1 */
+		u32 tncl:1;	/* bit 2 */
+		u32 txcl:1;	/* bit 3 */
+		u32 tlcl:1;	/* bit 4 */
+		u32 tmcl:1;	/* bit 5 */
+		u32 tscl:1;	/* bit 6 */
+		u32 tedf:1;	/* bit 7 */
+		u32 tdfr:1;	/* bit 8 */
+		u32 txpf:1;	/* bit 9 */
+		u32 tbca:1;	/* bit 10 */
+		u32 tmca:1;	/* bit 11 */
+		u32 tpkt:1;	/* bit 12 */
+		u32 tbyt:1;	/* bit 13 */
+		u32 tfrg:1;	/* bit 14 */
+		u32 tund:1;	/* bit 15 */
+		u32 tovr:1;	/* bit 16 */
+		u32 txcf:1;	/* bit 17 */
+		u32 tfcs:1;	/* bit 18 */
+		u32 tjbr:1;	/* bit 19 */
+		u32 unused:12;	/* bit 20-31 */
 #endif
 	} bits;
 } MAC_STAT_REG_2_t, *PMAC_STAT_REG_2_t;
@@ -2110,152 +2110,152 @@ typedef union _MAC_STAT_REG_2_t {
 /*
  * MAC STATS Module of JAGCore Address Mapping
  */
-typedef struct _MAC_STAT_t {		// Location:
-	u32 pad[32];		//  0x6000 - 607C
+typedef struct _MAC_STAT_t {		/* Location: */
+	u32 pad[32];		/*  0x6000 - 607C */
 
-	// Tx/Rx 0-64 Byte Frame Counter
-	u32 TR64;			//  0x6080
+	/* Tx/Rx 0-64 Byte Frame Counter */
+	u32 TR64;			/*  0x6080 */
 
-	// Tx/Rx 65-127 Byte Frame Counter
-	u32 TR127;			//  0x6084
+	/* Tx/Rx 65-127 Byte Frame Counter */
+	u32 TR127;			/*  0x6084 */
 
-	// Tx/Rx 128-255 Byte Frame Counter
-	u32 TR255;			//  0x6088
+	/* Tx/Rx 128-255 Byte Frame Counter */
+	u32 TR255;			/*  0x6088 */
 
-	// Tx/Rx 256-511 Byte Frame Counter
-	u32 TR511;			//  0x608C
+	/* Tx/Rx 256-511 Byte Frame Counter */
+	u32 TR511;			/*  0x608C */
 
-	// Tx/Rx 512-1023 Byte Frame Counter
-	u32 TR1K;			//  0x6090
+	/* Tx/Rx 512-1023 Byte Frame Counter */
+	u32 TR1K;			/*  0x6090 */
 
-	// Tx/Rx 1024-1518 Byte Frame Counter
-	u32 TRMax;			//  0x6094
+	/* Tx/Rx 1024-1518 Byte Frame Counter */
+	u32 TRMax;			/*  0x6094 */
 
-	// Tx/Rx 1519-1522 Byte Good VLAN Frame Count
-	u32 TRMgv;			//  0x6098
+	/* Tx/Rx 1519-1522 Byte Good VLAN Frame Count */
+	u32 TRMgv;			/*  0x6098 */
 
-	// Rx Byte Counter
-	u32 RByt;			//  0x609C
+	/* Rx Byte Counter */
+	u32 RByt;			/*  0x609C */
 
-	// Rx Packet Counter
-	u32 RPkt;			//  0x60A0
+	/* Rx Packet Counter */
+	u32 RPkt;			/*  0x60A0 */
 
-	// Rx FCS Error Counter
-	u32 RFcs;			//  0x60A4
+	/* Rx FCS Error Counter */
+	u32 RFcs;			/*  0x60A4 */
 
-	// Rx Multicast Packet Counter
-	u32 RMca;			//  0x60A8
+	/* Rx Multicast Packet Counter */
+	u32 RMca;			/*  0x60A8 */
 
-	// Rx Broadcast Packet Counter
-	u32 RBca;			//  0x60AC
+	/* Rx Broadcast Packet Counter */
+	u32 RBca;			/*  0x60AC */
 
-	// Rx Control Frame Packet Counter
-	u32 RxCf;			//  0x60B0
+	/* Rx Control Frame Packet Counter */
+	u32 RxCf;			/*  0x60B0 */
 
-	// Rx Pause Frame Packet Counter
-	u32 RxPf;			//  0x60B4
+	/* Rx Pause Frame Packet Counter */
+	u32 RxPf;			/*  0x60B4 */
 
-	// Rx Unknown OP Code Counter
-	u32 RxUo;			//  0x60B8
+	/* Rx Unknown OP Code Counter */
+	u32 RxUo;			/*  0x60B8 */
 
-	// Rx Alignment Error Counter
-	u32 RAln;			//  0x60BC
+	/* Rx Alignment Error Counter */
+	u32 RAln;			/*  0x60BC */
 
-	// Rx Frame Length Error Counter
-	u32 RFlr;			//  0x60C0
+	/* Rx Frame Length Error Counter */
+	u32 RFlr;			/*  0x60C0 */
 
-	// Rx Code Error Counter
-	u32 RCde;			//  0x60C4
+	/* Rx Code Error Counter */
+	u32 RCde;			/*  0x60C4 */
 
-	// Rx Carrier Sense Error Counter
-	u32 RCse;			//  0x60C8
+	/* Rx Carrier Sense Error Counter */
+	u32 RCse;			/*  0x60C8 */
 
-	// Rx Undersize Packet Counter
-	u32 RUnd;			//  0x60CC
+	/* Rx Undersize Packet Counter */
+	u32 RUnd;			/*  0x60CC */
 
-	// Rx Oversize Packet Counter
-	u32 ROvr;			//  0x60D0
+	/* Rx Oversize Packet Counter */
+	u32 ROvr;			/*  0x60D0 */
 
-	// Rx Fragment Counter
-	u32 RFrg;			//  0x60D4
+	/* Rx Fragment Counter */
+	u32 RFrg;			/*  0x60D4 */
 
-	// Rx Jabber Counter
-	u32 RJbr;			//  0x60D8
+	/* Rx Jabber Counter */
+	u32 RJbr;			/*  0x60D8 */
 
-	// Rx Drop
-	u32 RDrp;			//  0x60DC
+	/* Rx Drop */
+	u32 RDrp;			/*  0x60DC */
 
-	// Tx Byte Counter
-	u32 TByt;			//  0x60E0
+	/* Tx Byte Counter */
+	u32 TByt;			/*  0x60E0 */
 
-	// Tx Packet Counter
-	u32 TPkt;			//  0x60E4
+	/* Tx Packet Counter */
+	u32 TPkt;			/*  0x60E4 */
 
-	// Tx Multicast Packet Counter
-	u32 TMca;			//  0x60E8
+	/* Tx Multicast Packet Counter */
+	u32 TMca;			/*  0x60E8 */
 
-	// Tx Broadcast Packet Counter
-	u32 TBca;			//  0x60EC
+	/* Tx Broadcast Packet Counter */
+	u32 TBca;			/*  0x60EC */
 
-	// Tx Pause Control Frame Counter
-	u32 TxPf;			//  0x60F0
+	/* Tx Pause Control Frame Counter */
+	u32 TxPf;			/*  0x60F0 */
 
-	// Tx Deferral Packet Counter
-	u32 TDfr;			//  0x60F4
+	/* Tx Deferral Packet Counter */
+	u32 TDfr;			/*  0x60F4 */
 
-	// Tx Excessive Deferral Packet Counter
-	u32 TEdf;			//  0x60F8
+	/* Tx Excessive Deferral Packet Counter */
+	u32 TEdf;			/*  0x60F8 */
 
-	// Tx Single Collision Packet Counter
-	u32 TScl;			//  0x60FC
+	/* Tx Single Collision Packet Counter */
+	u32 TScl;			/*  0x60FC */
 
-	// Tx Multiple Collision Packet Counter
-	u32 TMcl;			//  0x6100
+	/* Tx Multiple Collision Packet Counter */
+	u32 TMcl;			/*  0x6100 */
 
-	// Tx Late Collision Packet Counter
-	u32 TLcl;			//  0x6104
+	/* Tx Late Collision Packet Counter */
+	u32 TLcl;			/*  0x6104 */
 
-	// Tx Excessive Collision Packet Counter
-	u32 TXcl;			//  0x6108
+	/* Tx Excessive Collision Packet Counter */
+	u32 TXcl;			/*  0x6108 */
 
-	// Tx Total Collision Packet Counter
-	u32 TNcl;			//  0x610C
+	/* Tx Total Collision Packet Counter */
+	u32 TNcl;			/*  0x610C */
 
-	// Tx Pause Frame Honored Counter
-	u32 TPfh;			//  0x6110
+	/* Tx Pause Frame Honored Counter */
+	u32 TPfh;			/*  0x6110 */
 
-	// Tx Drop Frame Counter
-	u32 TDrp;			//  0x6114
+	/* Tx Drop Frame Counter */
+	u32 TDrp;			/*  0x6114 */
 
-	// Tx Jabber Frame Counter
-	u32 TJbr;			//  0x6118
+	/* Tx Jabber Frame Counter */
+	u32 TJbr;			/*  0x6118 */
 
-	// Tx FCS Error Counter
-	u32 TFcs;			//  0x611C
+	/* Tx FCS Error Counter */
+	u32 TFcs;			/*  0x611C */
 
-	// Tx Control Frame Counter
-	u32 TxCf;			//  0x6120
+	/* Tx Control Frame Counter */
+	u32 TxCf;			/*  0x6120 */
 
-	// Tx Oversize Frame Counter
-	u32 TOvr;			//  0x6124
+	/* Tx Oversize Frame Counter */
+	u32 TOvr;			/*  0x6124 */
 
-	// Tx Undersize Frame Counter
-	u32 TUnd;			//  0x6128
+	/* Tx Undersize Frame Counter */
+	u32 TUnd;			/*  0x6128 */
 
-	// Tx Fragments Frame Counter
-	u32 TFrg;			//  0x612C
+	/* Tx Fragments Frame Counter */
+	u32 TFrg;			/*  0x612C */
 
-	// Carry Register One Register
-	MAC_STAT_REG_1_t Carry1;	//  0x6130
+	/* Carry Register One Register */
+	MAC_STAT_REG_1_t Carry1;	/*  0x6130 */
 
-	// Carry Register Two Register
-	MAC_STAT_REG_2_t Carry2;	//  0x6134
+	/* Carry Register Two Register */
+	MAC_STAT_REG_2_t Carry2;	/*  0x6134 */
 
-	// Carry Register One Mask Register
-	MAC_STAT_REG_1_t Carry1M;	//  0x6138
+	/* Carry Register One Mask Register */
+	MAC_STAT_REG_1_t Carry1M;	/*  0x6138 */
 
-	// Carry Register Two Mask Register
-	MAC_STAT_REG_2_t Carry2M;	//  0x613C
+	/* Carry Register Two Mask Register */
+	MAC_STAT_REG_2_t Carry2M;	/*  0x613C */
 } MAC_STAT_t, *PMAC_STAT_t;
 
 /* END OF MAC STAT REGISTER ADDRESS MAP */
@@ -2271,23 +2271,23 @@ typedef union _MMC_CTRL_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:25;		// bits 7-31
-		u32 force_ce:1;		// bit 6
-		u32 rxdma_disable:1;	// bit 5
-		u32 txdma_disable:1;	// bit 4
-		u32 txmac_disable:1;	// bit 3
-		u32 rxmac_disable:1;	// bit 2
-		u32 arb_disable:1;		// bit 1
-		u32 mmc_enable:1;		// bit 0
-#else
-		u32 mmc_enable:1;		// bit 0
-		u32 arb_disable:1;		// bit 1
-		u32 rxmac_disable:1;	// bit 2
-		u32 txmac_disable:1;	// bit 3
-		u32 txdma_disable:1;	// bit 4
-		u32 rxdma_disable:1;	// bit 5
-		u32 force_ce:1;		// bit 6
-		u32 reserved:25;		// bits 7-31
+		u32 reserved:25;		/* bits 7-31 */
+		u32 force_ce:1;		/* bit 6 */
+		u32 rxdma_disable:1;	/* bit 5 */
+		u32 txdma_disable:1;	/* bit 4 */
+		u32 txmac_disable:1;	/* bit 3 */
+		u32 rxmac_disable:1;	/* bit 2 */
+		u32 arb_disable:1;		/* bit 1 */
+		u32 mmc_enable:1;		/* bit 0 */
+#else
+		u32 mmc_enable:1;		/* bit 0 */
+		u32 arb_disable:1;		/* bit 1 */
+		u32 rxmac_disable:1;	/* bit 2 */
+		u32 txmac_disable:1;	/* bit 3 */
+		u32 txdma_disable:1;	/* bit 4 */
+		u32 rxdma_disable:1;	/* bit 5 */
+		u32 force_ce:1;		/* bit 6 */
+		u32 reserved:25;		/* bits 7-31 */
 #endif
 	} bits;
 } MMC_CTRL_t, *PMMC_CTRL_t;
@@ -2300,21 +2300,21 @@ typedef union _MMC_SRAM_ACCESS_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 byte_enable:16;	// bits 16-31
-		u32 reserved2:2;		// bits 14-15
-		u32 req_addr:10;		// bits 4-13
-		u32 reserved1:1;		// bit 3
-		u32 is_ctrl_word:1;	// bit 2
-		u32 wr_access:1;		// bit 1
-		u32 req_access:1;		// bit 0
-#else
-		u32 req_access:1;		// bit 0
-		u32 wr_access:1;		// bit 1
-		u32 is_ctrl_word:1;	// bit 2
-		u32 reserved1:1;		// bit 3
-		u32 req_addr:10;		// bits 4-13
-		u32 reserved2:2;		// bits 14-15
-		u32 byte_enable:16;	// bits 16-31
+		u32 byte_enable:16;	/* bits 16-31 */
+		u32 reserved2:2;		/* bits 14-15 */
+		u32 req_addr:10;		/* bits 4-13 */
+		u32 reserved1:1;		/* bit 3 */
+		u32 is_ctrl_word:1;	/* bit 2 */
+		u32 wr_access:1;		/* bit 1 */
+		u32 req_access:1;		/* bit 0 */
+#else
+		u32 req_access:1;		/* bit 0 */
+		u32 wr_access:1;		/* bit 1 */
+		u32 is_ctrl_word:1;	/* bit 2 */
+		u32 reserved1:1;		/* bit 3 */
+		u32 req_addr:10;		/* bits 4-13 */
+		u32 reserved2:2;		/* bits 14-15 */
+		u32 byte_enable:16;	/* bits 16-31 */
 #endif
 	} bits;
 } MMC_SRAM_ACCESS_t, *PMMC_SRAM_ACCESS_t;
@@ -2328,13 +2328,13 @@ typedef union _MMC_SRAM_ACCESS_t {
 /*
  * Memory Control Module of JAGCore Address Mapping
  */
-typedef struct _MMC_t {			// Location:
-	MMC_CTRL_t mmc_ctrl;		//  0x7000
-	MMC_SRAM_ACCESS_t sram_access;	//  0x7004
-	u32 sram_word1;		//  0x7008
-	u32 sram_word2;		//  0x700C
-	u32 sram_word3;		//  0x7010
-	u32 sram_word4;		//  0x7014
+typedef struct _MMC_t {			/* Location: */
+	MMC_CTRL_t mmc_ctrl;		/*  0x7000 */
+	MMC_SRAM_ACCESS_t sram_access;	/*  0x7004 */
+	u32 sram_word1;		/*  0x7008 */
+	u32 sram_word2;		/*  0x700C */
+	u32 sram_word3;		/*  0x7010 */
+	u32 sram_word4;		/*  0x7014 */
 } MMC_t, *PMMC_t;
 
 /* END OF MMC REGISTER ADDRESS MAP */
@@ -2361,30 +2361,30 @@ typedef struct _EXP_ROM_t {
  */
 typedef struct _ADDRESS_MAP_t {
 	GLOBAL_t global;
-	// unused section of global address map
+	/* unused section of global address map */
 	u8 unused_global[4096 - sizeof(GLOBAL_t)];
 	TXDMA_t txdma;
-	// unused section of txdma address map
+	/* unused section of txdma address map */
 	u8 unused_txdma[4096 - sizeof(TXDMA_t)];
 	RXDMA_t rxdma;
-	// unused section of rxdma address map
+	/* unused section of rxdma address map */
 	u8 unused_rxdma[4096 - sizeof(RXDMA_t)];
 	TXMAC_t txmac;
-	// unused section of txmac address map
+	/* unused section of txmac address map */
 	u8 unused_txmac[4096 - sizeof(TXMAC_t)];
 	RXMAC_t rxmac;
-	// unused section of rxmac address map
+	/* unused section of rxmac address map */
 	u8 unused_rxmac[4096 - sizeof(RXMAC_t)];
 	MAC_t mac;
-	// unused section of mac address map
+	/* unused section of mac address map */
 	u8 unused_mac[4096 - sizeof(MAC_t)];
 	MAC_STAT_t macStat;
-	// unused section of mac stat address map
+	/* unused section of mac stat address map */
 	u8 unused_mac_stat[4096 - sizeof(MAC_STAT_t)];
 	MMC_t mmc;
-	// unused section of mmc address map
+	/* unused section of mmc address map */
 	u8 unused_mmc[4096 - sizeof(MMC_t)];
-	// unused section of address map
+	/* unused section of address map */
 	u8 unused_[1015808];
 
 /* Take this out until it is not empty */
@@ -2392,8 +2392,8 @@ typedef struct _ADDRESS_MAP_t {
 	EXP_ROM_t exp_rom;
 #endif
 
-	u8 unused_exp_rom[4096];	// MGS-size TBD
-	u8 unused__[524288];	// unused section of address map
+	u8 unused_exp_rom[4096];	/* MGS-size TBD */
+	u8 unused__[524288];	/* unused section of address map */
 } ADDRESS_MAP_t, *PADDRESS_MAP_t;
 
 #endif /* _ET1310_ADDRESS_MAP_H_ */
--- a/drivers/staging/et131x/et1310_eeprom.c
+++ b/drivers/staging/et131x/et1310_eeprom.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -74,9 +74,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -155,7 +155,7 @@ int32_t EepromWriteByte(struct et131x_ad
 			uint8_t bData, uint32_t unEepromId,
 			uint32_t unAddressingMode)
 {
-        struct pci_dev *pdev = pAdapter->pdev;
+	struct pci_dev *pdev = pAdapter->pdev;
 	int32_t nIndex;
 	int32_t nRetries;
 	int32_t nError = false;
@@ -226,23 +226,20 @@ int32_t EepromWriteByte(struct et131x_ad
 		bStatus = EXTRACT_STATUS_REGISTER(unDword1);
 
 		if (bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
-		    bStatus & LBCIF_STATUS_I2C_IDLE) {
-		    	/* bits 1:0 are equal to 1 */
+			bStatus & LBCIF_STATUS_I2C_IDLE)
+			/* bits 1:0 are equal to 1 */
 			break;
-		}
 	}
 
-	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS)) {
+	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS))
 		return FAILURE;
-	}
 
 	/* Step 2: */
 	bControl = 0;
 	bControl |= LBCIF_CONTROL_LBCIF_ENABLE | LBCIF_CONTROL_I2C_WRITE;
 
-	if (unAddressingMode == DUAL_BYTE) {
+	if (unAddressingMode == DUAL_BYTE)
 		bControl |= LBCIF_CONTROL_TWO_BYTE_ADDR;
-	}
 
 	if (pci_write_config_byte(pdev, LBCIF_CONTROL_REGISTER_OFFSET,
 				  bControl)) {
@@ -281,20 +278,19 @@ int32_t EepromWriteByte(struct et131x_ad
 			bStatus = EXTRACT_STATUS_REGISTER(unDword1);
 
 			if (bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
-			    bStatus & LBCIF_STATUS_I2C_IDLE) {
-			    	/* I2C write complete */
+				bStatus & LBCIF_STATUS_I2C_IDLE) {
+				/* I2C write complete */
 				break;
 			}
 		}
 
-		if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS)) {
+		if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS))
 			break;
-		}
 
 		/*
 		 * Step 6: Don't break here if we are revision 1, this is
 		 *	   so we do a blind write for load bug.
-	         */
+		 */
 		if (bStatus & LBCIF_STATUS_GENERAL_ERROR
 		    && pAdapter->RevisionID == 0) {
 			break;
@@ -342,9 +338,8 @@ int32_t EepromWriteByte(struct et131x_ad
 
 		bControl = EXTRACT_CONTROL_REG(unData);
 
-		if (bControl != 0xC0 || nIndex == 10000) {
+		if (bControl != 0xC0 || nIndex == 10000)
 			break;
-		}
 
 		nIndex++;
 	}
@@ -366,7 +361,7 @@ int32_t EepromReadByte(struct et131x_ada
 		       uint8_t *pbData, uint32_t unEepromId,
 		       uint32_t unAddressingMode)
 {
-        struct pci_dev *pdev = pAdapter->pdev;
+	struct pci_dev *pdev = pAdapter->pdev;
 	int32_t nIndex;
 	int32_t nError = 0;
 	uint8_t bControl;
@@ -425,17 +420,15 @@ int32_t EepromReadByte(struct et131x_ada
 		}
 	}
 
-	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS)) {
+	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS))
 		return FAILURE;
-	}
 
 	/* Step 2: */
 	bControl = 0;
 	bControl |= LBCIF_CONTROL_LBCIF_ENABLE;
 
-	if (unAddressingMode == DUAL_BYTE) {
+	if (unAddressingMode == DUAL_BYTE)
 		bControl |= LBCIF_CONTROL_TWO_BYTE_ADDR;
-	}
 
 	if (pci_write_config_byte(pdev, LBCIF_CONTROL_REGISTER_OFFSET,
 				  bControl)) {
@@ -469,9 +462,8 @@ int32_t EepromReadByte(struct et131x_ada
 		}
 	}
 
-	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS)) {
+	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS))
 		return FAILURE;
-	}
 
 	/* Step 6: */
 	*pbData = EXTRACT_DATA_REGISTER(unDword1);
--- a/drivers/staging/et131x/et1310_eeprom.h
+++ b/drivers/staging/et131x/et1310_eeprom.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
--- a/drivers/staging/et131x/et1310_jagcore.c
+++ b/drivers/staging/et131x/et1310_jagcore.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -73,9 +73,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -198,21 +198,19 @@ void et131x_enable_interrupts(struct et1
 	uint32_t MaskValue;
 
 	/* Enable all global interrupts */
-	if ((adapter->FlowControl == TxOnly) || (adapter->FlowControl == Both)) {
+	if (adapter->FlowControl == TxOnly || adapter->FlowControl == Both)
 		MaskValue = INT_MASK_ENABLE;
-	} else {
+	else
 		MaskValue = INT_MASK_ENABLE_NO_FLOW;
-	}
 
-	if (adapter->DriverNoPhyAccess) {
+	if (adapter->DriverNoPhyAccess)
 		MaskValue |= 0x10000;
-	}
 
 	adapter->CachedMaskValue.value = MaskValue;
 	writel(MaskValue, &adapter->CSRAddress->global.int_mask.value);
 }
 
-void et131x_disable_interrupts(struct et131x_adapter * adapter)
+void et131x_disable_interrupts(struct et131x_adapter *adapter)
 {
 	/* Disable all global interrupts */
 	adapter->CachedMaskValue.value = INT_MASK_DISABLE;
--- a/drivers/staging/et131x/et1310_jagcore.h
+++ b/drivers/staging/et131x/et1310_jagcore.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -62,8 +62,8 @@
 #include "et1310_address_map.h"
 
 
-#define INTERNAL_MEM_SIZE       0x400	//1024 of internal memory
-#define INTERNAL_MEM_RX_OFFSET  0x1FF	//50%   Tx, 50%   Rx
+#define INTERNAL_MEM_SIZE       0x400	/* 1024 of internal memory */
+#define INTERNAL_MEM_RX_OFFSET  0x1FF	/* 50%   Tx, 50%   Rx */
 
 #define REGS_MAX_ARRAY          4096
 
@@ -78,9 +78,10 @@
  */
 #define INT_MASK_DISABLE            0xffffffff
 
-// NOTE: Masking out MAC_STAT Interrupt for now...
-//#define INT_MASK_ENABLE             0xfff6bf17
-//#define INT_MASK_ENABLE_NO_FLOW     0xfff6bfd7
+/* NOTE: Masking out MAC_STAT Interrupt for now...
+ * #define INT_MASK_ENABLE             0xfff6bf17
+ * #define INT_MASK_ENABLE_NO_FLOW     0xfff6bfd7
+ */
 #define INT_MASK_ENABLE             0xfffebf17
 #define INT_MASK_ENABLE_NO_FLOW     0xfffebfd7
 
--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -73,9 +73,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -118,10 +118,10 @@ void ConfigMACRegs1(struct et131x_adapte
 	writel(0xC00F0000, &pMac->cfg1.value);
 
 	/* Next lets configure the MAC Inter-packet gap register */
-	ipg.bits.non_B2B_ipg_1 = 0x38;		// 58d
-	ipg.bits.non_B2B_ipg_2 = 0x58;		// 88d
-	ipg.bits.min_ifg_enforce = 0x50;	// 80d
-	ipg.bits.B2B_ipg = 0x60;		// 96d
+	ipg.bits.non_B2B_ipg_1 = 0x38;		/* 58d */
+	ipg.bits.non_B2B_ipg_2 = 0x58;		/* 88d */
+	ipg.bits.min_ifg_enforce = 0x50;	/* 80d */
+	ipg.bits.B2B_ipg = 0x60;		/* 96d */
 	writel(ipg.value, &pMac->ipg.value);
 
 	/* Next lets configure the MAC Half Duplex register */
@@ -131,7 +131,7 @@ void ConfigMACRegs1(struct et131x_adapte
 	hfdp.bits.no_backoff = 0x0;
 	hfdp.bits.excess_defer = 0x1;
 	hfdp.bits.rexmit_max = 0xF;
-	hfdp.bits.coll_window = 0x37;		// 55d
+	hfdp.bits.coll_window = 0x37;		/* 55d */
 	writel(hfdp.value, &pMac->hfdp.value);
 
 	/* Next lets configure the MAC Interface Control register */
@@ -251,21 +251,20 @@ void ConfigMACRegs2(struct et131x_adapte
 		udelay(10);
 		delay++;
 		cfg1.value = readl(&pMac->cfg1.value);
-	} while ((!cfg1.bits.syncd_rx_en ||
-		  !cfg1.bits.syncd_tx_en) &&
-		 delay < 100);
+	} while ((!cfg1.bits.syncd_rx_en || !cfg1.bits.syncd_tx_en) &&
+								 delay < 100);
 
 	if (delay == 100) {
 		DBG_ERROR(et131x_dbginfo,
-			  "Syncd bits did not respond correctly cfg1 word 0x%08x\n",
-			  cfg1.value);
+		    "Syncd bits did not respond correctly cfg1 word 0x%08x\n",
+			cfg1.value);
 	}
 
 	DBG_TRACE(et131x_dbginfo,
-		  "Speed %d, Dup %d, CFG1 0x%08x, CFG2 0x%08x, if_ctrl 0x%08x\n",
-		  pAdapter->uiLinkSpeed, pAdapter->uiDuplexMode,
-		  readl(&pMac->cfg1.value), readl(&pMac->cfg2.value),
-		  readl(&pMac->if_ctrl.value));
+		"Speed %d, Dup %d, CFG1 0x%08x, CFG2 0x%08x, if_ctrl 0x%08x\n",
+		pAdapter->uiLinkSpeed, pAdapter->uiDuplexMode,
+		readl(&pMac->cfg1.value), readl(&pMac->cfg2.value),
+		readl(&pMac->if_ctrl.value));
 
 	/* Enable TXMAC */
 	ctl.bits.txmac_en = 0x1;
@@ -409,11 +408,10 @@ void ConfigRxMacRegs(struct et131x_adapt
 	 * bit 16: Receive frame truncated.
 	 * bit 17: Drop packet enable
 	 */
-	if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_100MBPS) {
+	if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_100MBPS)
 		writel(0x30038, &pRxMac->mif_ctrl.value);
-	} else {
+	else
 		writel(0x30030, &pRxMac->mif_ctrl.value);
-	}
 
 	/* Finally we initialize RxMac to be enabled & WOL disabled.  Packet
 	 * filter is always enabled since it is where the runt packets are
@@ -540,7 +538,7 @@ void ConfigMacStatRegs(struct et131x_ada
 	DBG_LEAVE(et131x_dbginfo);
 }
 
-void ConfigFlowControl(struct et131x_adapter * pAdapter)
+void ConfigFlowControl(struct et131x_adapter *pAdapter)
 {
 	if (pAdapter->uiDuplexMode == 0) {
 		pAdapter->FlowControl = None;
@@ -558,21 +556,19 @@ void ConfigFlowControl(struct et131x_ada
 			pAdapter->FlowControl = pAdapter->RegistryFlowControl;
 		} else if ((RemotePause == TRUEPHY_BIT_SET) &&
 			   (RemoteAsyncPause == TRUEPHY_BIT_CLEAR)) {
-			if (pAdapter->RegistryFlowControl == Both) {
+			if (pAdapter->RegistryFlowControl == Both)
 				pAdapter->FlowControl = Both;
-			} else {
+			else
 				pAdapter->FlowControl = None;
-			}
 		} else if ((RemotePause == TRUEPHY_BIT_CLEAR) &&
 			   (RemoteAsyncPause == TRUEPHY_BIT_CLEAR)) {
 			pAdapter->FlowControl = None;
 		} else {/* if (RemotePause == TRUEPHY_CLEAR_BIT &&
 			       RemoteAsyncPause == TRUEPHY_SET_BIT) */
-			if (pAdapter->RegistryFlowControl == Both) {
+			if (pAdapter->RegistryFlowControl == Both)
 				pAdapter->FlowControl = RxOnly;
-			} else {
+			else
 				pAdapter->FlowControl = None;
-			}
 		}
 	}
 }
@@ -635,48 +631,34 @@ void HandleMacStatInterrupt(struct et131
 	 * revolution of the counter.  This routine is called when the counter
 	 * block indicates that one of the counters has wrapped.
 	 */
-	if (Carry1.bits.rfcs) {
+	if (Carry1.bits.rfcs)
 		pAdapter->Stats.code_violations += COUNTER_WRAP_16_BIT;
-	}
-	if (Carry1.bits.raln) {
+	if (Carry1.bits.raln)
 		pAdapter->Stats.alignment_err += COUNTER_WRAP_12_BIT;
-	}
-	if (Carry1.bits.rflr) {
+	if (Carry1.bits.rflr)
 		pAdapter->Stats.length_err += COUNTER_WRAP_16_BIT;
-	}
-	if (Carry1.bits.rfrg) {
+	if (Carry1.bits.rfrg)
 		pAdapter->Stats.other_errors += COUNTER_WRAP_16_BIT;
-	}
-	if (Carry1.bits.rcde) {
+	if (Carry1.bits.rcde)
 		pAdapter->Stats.crc_err += COUNTER_WRAP_16_BIT;
-	}
-	if (Carry1.bits.rovr) {
+	if (Carry1.bits.rovr)
 		pAdapter->Stats.rx_ov_flow += COUNTER_WRAP_16_BIT;
-	}
-	if (Carry1.bits.rdrp) {
+	if (Carry1.bits.rdrp)
 		pAdapter->Stats.norcvbuf += COUNTER_WRAP_16_BIT;
-	}
-	if (Carry2.bits.tovr) {
+	if (Carry2.bits.tovr)
 		pAdapter->Stats.max_pkt_error += COUNTER_WRAP_12_BIT;
-	}
-	if (Carry2.bits.tund) {
+	if (Carry2.bits.tund)
 		pAdapter->Stats.tx_uflo += COUNTER_WRAP_12_BIT;
-	}
-	if (Carry2.bits.tscl) {
+	if (Carry2.bits.tscl)
 		pAdapter->Stats.first_collision += COUNTER_WRAP_12_BIT;
-	}
-	if (Carry2.bits.tdfr) {
+	if (Carry2.bits.tdfr)
 		pAdapter->Stats.tx_deferred += COUNTER_WRAP_12_BIT;
-	}
-	if (Carry2.bits.tmcl) {
+	if (Carry2.bits.tmcl)
 		pAdapter->Stats.excessive_collisions += COUNTER_WRAP_12_BIT;
-	}
-	if (Carry2.bits.tlcl) {
+	if (Carry2.bits.tlcl)
 		pAdapter->Stats.late_collisions += COUNTER_WRAP_12_BIT;
-	}
-	if (Carry2.bits.tncl) {
+	if (Carry2.bits.tncl)
 		pAdapter->Stats.collisions += COUNTER_WRAP_12_BIT;
-	}
 
 	DBG_LEAVE(et131x_dbginfo);
 }
@@ -707,14 +689,14 @@ void SetupDeviceForMulticast(struct et13
 		/* Loop through our multicast array and set up the device */
 		for (nIndex = 0; nIndex < pAdapter->MCAddressCount; nIndex++) {
 			DBG_VERBOSE(et131x_dbginfo,
-				    "MCList[%d]: %02x:%02x:%02x:%02x:%02x:%02x\n",
-				    nIndex,
-				    pAdapter->MCList[nIndex][0],
-				    pAdapter->MCList[nIndex][1],
-				    pAdapter->MCList[nIndex][2],
-				    pAdapter->MCList[nIndex][3],
-				    pAdapter->MCList[nIndex][4],
-				    pAdapter->MCList[nIndex][5]);
+			    "MCList[%d]: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			    nIndex,
+			    pAdapter->MCList[nIndex][0],
+			    pAdapter->MCList[nIndex][1],
+			    pAdapter->MCList[nIndex][2],
+			    pAdapter->MCList[nIndex][3],
+			    pAdapter->MCList[nIndex][4],
+			    pAdapter->MCList[nIndex][5]);
 
 			result = ether_crc(6, pAdapter->MCList[nIndex]);
 
--- a/drivers/staging/et131x/et1310_mac.h
+++ b/drivers/staging/et131x/et1310_mac.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -73,7 +73,7 @@
 #define COUNTER_MASK_16_BIT (COUNTER_WRAP_16_BIT - 1)
 #define COUNTER_MASK_12_BIT (COUNTER_WRAP_12_BIT - 1)
 
-#define UPDATE_COUNTER(HostCnt,DevCnt) \
+#define UPDATE_COUNTER(HostCnt, DevCnt) \
     HostCnt = HostCnt + DevCnt;
 
 /* Forward declaration of the private adapter structure */
--- a/drivers/staging/et131x/et1310_phy.c
+++ b/drivers/staging/et131x/et1310_phy.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright * 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright * 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -74,9 +74,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -258,8 +258,8 @@ int MiWrite(struct et131x_adapter *adapt
 	writel(0, &mac->mii_mgmt_cmd.value);
 
 	/* set the registers we touched back to the state at which we entered
-         * this function
-         */
+	 * this function
+	 */
 	writel(miiAddr.value, &mac->mii_mgmt_addr.value);
 	writel(miiCmd.value, &mac->mii_mgmt_cmd.value);
 
@@ -449,22 +449,20 @@ static int et131x_xcvr_init(struct et131
 
 		switch (adapter->AiForceSpeed) {
 		case 10:
-			if (adapter->AiForceDpx == 1) {
+			if (adapter->AiForceDpx == 1)
 				TPAL_SetPhy10HalfDuplex(adapter);
-			} else if (adapter->AiForceDpx == 2) {
+			else if (adapter->AiForceDpx == 2)
 				TPAL_SetPhy10FullDuplex(adapter);
-			} else {
+			else
 				TPAL_SetPhy10Force(adapter);
-			}
 			break;
 		case 100:
-			if (adapter->AiForceDpx == 1) {
+			if (adapter->AiForceDpx == 1)
 				TPAL_SetPhy100HalfDuplex(adapter);
-			} else if (adapter->AiForceDpx == 2) {
+			else if (adapter->AiForceDpx == 2)
 				TPAL_SetPhy100FullDuplex(adapter);
-			} else {
+			else
 				TPAL_SetPhy100Force(adapter);
-			}
 			break;
 		case 1000:
 			TPAL_SetPhy1000FullDuplex(adapter);
@@ -505,16 +503,17 @@ void et131x_Mii_check(struct et131x_adap
 			spin_unlock_irqrestore(&pAdapter->Lock, lockflags);
 
 			/* Don't indicate state if we're in loopback mode */
-			if (pAdapter->RegistryPhyLoopbk == false) {
+			if (pAdapter->RegistryPhyLoopbk == false)
 				netif_carrier_on(pAdapter->netdev);
-			}
 		} else {
 			DBG_WARNING(et131x_dbginfo,
 				    "Link down cable problem\n");
 
 			if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_10MBPS) {
-				// NOTE - Is there a way to query this without TruePHY?
-				// && TRU_QueryCoreType(pAdapter->hTruePhy, 0) == EMI_TRUEPHY_A13O) {
+				/* NOTE - Is there a way to query this without
+				 * TruePHY?
+				 * && TRU_QueryCoreType(pAdapter->hTruePhy, 0) == EMI_TRUEPHY_A13O) {
+				 */
 				uint16_t Register18;
 
 				MiRead(pAdapter, 0x12, &Register18);
@@ -543,9 +542,8 @@ void et131x_Mii_check(struct et131x_adap
 				/* Only indicate state if we're in loopback
 				 * mode
 				 */
-				if (pAdapter->RegistryPhyLoopbk == false) {
+				if (pAdapter->RegistryPhyLoopbk == false)
 					netif_carrier_off(pAdapter->netdev);
-				}
 			}
 
 			pAdapter->uiLinkSpeed = 0;
@@ -574,15 +572,14 @@ void et131x_Mii_check(struct et131x_adap
 			/* Setup the PHY into coma mode until the cable is
 			 * plugged back in
 			 */
-			if (pAdapter->RegistryPhyComa == 1) {
+			if (pAdapter->RegistryPhyComa == 1)
 				EnablePhyComa(pAdapter);
-			}
 		}
 	}
 
 	if (bmsr_ints.bits.auto_neg_complete ||
-	    ((pAdapter->AiForceDpx == 3) && (bmsr_ints.bits.link_status))) {
-		if (bmsr.bits.auto_neg_complete || (pAdapter->AiForceDpx == 3)) {
+	    (pAdapter->AiForceDpx == 3 && bmsr_ints.bits.link_status)) {
+		if (bmsr.bits.auto_neg_complete || pAdapter->AiForceDpx == 3) {
 			ET1310_PhyLinkStatus(pAdapter,
 					     &ucLinkStatus, &uiAutoNegStatus,
 					     &uiSpeed, &uiDuplex, &uiMdiMdix,
@@ -592,15 +589,18 @@ void et131x_Mii_check(struct et131x_adap
 			pAdapter->uiDuplexMode = uiDuplex;
 
 			DBG_TRACE(et131x_dbginfo,
-				  "pAdapter->uiLinkSpeed 0x%04x, pAdapter->uiDuplex 0x%08x\n",
-				  pAdapter->uiLinkSpeed,
-				  pAdapter->uiDuplexMode);
+				"pAdapter->uiLinkSpeed 0x%04x, pAdapter->uiDuplex 0x%08x\n",
+				pAdapter->uiLinkSpeed,
+				pAdapter->uiDuplexMode);
 
 			pAdapter->PoMgmt.TransPhyComaModeOnBoot = 20;
 
 			if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_10MBPS) {
-				// NOTE - Is there a way to query this without TruePHY?
-				// && TRU_QueryCoreType(pAdapter->hTruePhy, 0) == EMI_TRUEPHY_A13O) {
+				/*
+				 * NOTE - Is there a way to query this without
+				 * TruePHY?
+				 * && TRU_QueryCoreType(pAdapter->hTruePhy, 0)== EMI_TRUEPHY_A13O) {
+				 */
 				uint16_t Register18;
 
 				MiRead(pAdapter, 0x12, &Register18);
@@ -612,12 +612,10 @@ void et131x_Mii_check(struct et131x_adap
 
 			ConfigFlowControl(pAdapter);
 
-			if ((pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) &&
-			    (pAdapter->RegistryJumboPacket > 2048))
-			{
+			if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS &&
+					pAdapter->RegistryJumboPacket > 2048)
 				ET1310_PhyAndOrReg(pAdapter, 0x16, 0xcfff,
-						   0x2000);
-			}
+								   0x2000);
 
 			SetRxDmaTimer(pAdapter);
 			ConfigMACRegs2(pAdapter);
@@ -843,11 +841,10 @@ void TPAL_SetPhyAutoNeg(struct et131x_ad
 
 	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_BOTH);
 
-	if (pAdapter->DeviceID != ET131X_PCI_DEVICE_ID_FAST) {
+	if (pAdapter->DeviceID != ET131X_PCI_DEVICE_ID_FAST)
 		ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_FULL);
-	} else {
+	else
 		ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
-	}
 
 	/* Make sure auto-neg is ON (it is disabled in FORCE modes) */
 	ET1310_PhyAutoNeg(pAdapter, true);
@@ -910,64 +907,65 @@ void ET1310_PhyInit(struct et131x_adapte
 {
 	uint16_t usData, usIndex;
 
-	if (pAdapter == NULL) {
+	if (pAdapter == NULL)
 		return;
-	}
 
-	// get the identity (again ?)
+	/* get the identity (again ?) */
 	MiRead(pAdapter, PHY_ID_1, &usData);
 	MiRead(pAdapter, PHY_ID_2, &usData);
 
-	// what does this do/achieve ?
-	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData);	// should read 0002
+	/* what does this do/achieve ? */
+	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
 	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG,	0x0006);
 
-	// read modem register 0402, should I do something with the return data ?
+	/* read modem register 0402, should I do something with the return
+	   data ? */
 	MiWrite(pAdapter, PHY_INDEX_REG, 0x0402);
 	MiRead(pAdapter, PHY_DATA_REG, &usData);
 
-	// what does this do/achieve ?
+	/* what does this do/achieve ? */
 	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0002);
 
-	// get the identity (again ?)
+	/* get the identity (again ?) */
 	MiRead(pAdapter, PHY_ID_1, &usData);
 	MiRead(pAdapter, PHY_ID_2, &usData);
 
-	// what does this achieve ?
-	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData);	// should read 0002
+	/* what does this achieve ? */
+	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
 	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0006);
 
-	// read modem register 0402, should I do something with the return data?
+	/* read modem register 0402, should I do something with
+	   the return data? */
 	MiWrite(pAdapter, PHY_INDEX_REG, 0x0402);
 	MiRead(pAdapter, PHY_DATA_REG, &usData);
 
 	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0002);
 
-	// what does this achieve (should return 0x1040)
+	/* what does this achieve (should return 0x1040) */
 	MiRead(pAdapter, PHY_CONTROL, &usData);
-	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData);	// should read 0002
+	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
 	MiWrite(pAdapter, PHY_CONTROL, 0x1840);
 
 	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0007);
 
-	// here the writing of the array starts....
+	/* here the writing of the array starts.... */
 	usIndex = 0;
 	while (ConfigPhy[usIndex][0] != 0x0000) {
-		// write value
+		/* write value */
 		MiWrite(pAdapter, PHY_INDEX_REG, ConfigPhy[usIndex][0]);
 		MiWrite(pAdapter, PHY_DATA_REG, ConfigPhy[usIndex][1]);
 
-		// read it back
+		/* read it back */
 		MiWrite(pAdapter, PHY_INDEX_REG, ConfigPhy[usIndex][0]);
 		MiRead(pAdapter, PHY_DATA_REG, &usData);
 
-		// do a check on the value read back ?
+		/* do a check on the value read back ? */
 		usIndex++;
 	}
-	// here the writing of the array ends...
+	/* here the writing of the array ends... */
 
-	MiRead(pAdapter, PHY_CONTROL, &usData);	// 0x1840
-	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData);	// should read 0007
+	MiRead(pAdapter, PHY_CONTROL, &usData);		/* 0x1840 */
+	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData);/* should read 0007 */
 	MiWrite(pAdapter, PHY_CONTROL, 0x1040);
 	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0002);
 }
@@ -984,11 +982,11 @@ void ET1310_PhyPowerDown(struct et131x_a
 	MiRead(pAdapter, PHY_CONTROL, &usData);
 
 	if (down == false) {
-		// Power UP
+		/* Power UP */
 		usData &= ~0x0800;
 		MiWrite(pAdapter, PHY_CONTROL, usData);
 	} else {
-		// Power DOWN
+		/* Power DOWN */
 		usData |= 0x0800;
 		MiWrite(pAdapter, PHY_CONTROL, usData);
 	}
@@ -1001,11 +999,11 @@ void ET1310_PhyAutoNeg(struct et131x_ada
 	MiRead(pAdapter, PHY_CONTROL, &usData);
 
 	if (enable == true) {
-		// Autonegotiation ON
+		/* Autonegotiation ON */
 		usData |= 0x1000;
 		MiWrite(pAdapter, PHY_CONTROL, usData);
 	} else {
-		// Autonegotiation OFF
+		/* Autonegotiation OFF */
 		usData &= ~0x1000;
 		MiWrite(pAdapter, PHY_CONTROL, usData);
 	}
@@ -1018,11 +1016,11 @@ void ET1310_PhyDuplexMode(struct et131x_
 	MiRead(pAdapter, PHY_CONTROL, &usData);
 
 	if (duplex == TRUEPHY_DUPLEX_FULL) {
-		// Set Full Duplex
+		/* Set Full Duplex */
 		usData |= 0x100;
 		MiWrite(pAdapter, PHY_CONTROL, usData);
 	} else {
-		// Set Half Duplex
+		/* Set Half Duplex */
 		usData &= ~0x100;
 		MiWrite(pAdapter, PHY_CONTROL, usData);
 	}
@@ -1032,20 +1030,20 @@ void ET1310_PhySpeedSelect(struct et131x
 {
 	uint16_t usData;
 
-	// Read the PHY control register
+	/* Read the PHY control register */
 	MiRead(pAdapter, PHY_CONTROL, &usData);
 
-	// Clear all Speed settings (Bits 6, 13)
+	/* Clear all Speed settings (Bits 6, 13) */
 	usData &= ~0x2040;
 
-	// Reset the speed bits based on user selection
+	/* Reset the speed bits based on user selection */
 	switch (speed) {
 	case TRUEPHY_SPEED_10MBPS:
-		// Bits already cleared above, do nothing
+		/* Bits already cleared above, do nothing */
 		break;
 
 	case TRUEPHY_SPEED_100MBPS:
-		// 100M == Set bit 13
+		/* 100M == Set bit 13 */
 		usData |= 0x2000;
 		break;
 
@@ -1055,7 +1053,7 @@ void ET1310_PhySpeedSelect(struct et131x
 		break;
 	}
 
-	// Write back the new speed
+	/* Write back the new speed */
 	MiWrite(pAdapter, PHY_CONTROL, usData);
 }
 
@@ -1064,24 +1062,24 @@ void ET1310_PhyAdvertise1000BaseT(struct
 {
 	uint16_t usData;
 
-	// Read the PHY 1000 Base-T Control Register
+	/* Read the PHY 1000 Base-T Control Register */
 	MiRead(pAdapter, PHY_1000_CONTROL, &usData);
 
-	// Clear Bits 8,9
+	/* Clear Bits 8,9 */
 	usData &= ~0x0300;
 
 	switch (duplex) {
 	case TRUEPHY_ADV_DUPLEX_NONE:
-		// Duplex already cleared, do nothing
+		/* Duplex already cleared, do nothing */
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_FULL:
-		// Set Bit 9
+		/* Set Bit 9 */
 		usData |= 0x0200;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_HALF:
-		// Set Bit 8
+		/* Set Bit 8 */
 		usData |= 0x0100;
 		break;
 
@@ -1091,7 +1089,7 @@ void ET1310_PhyAdvertise1000BaseT(struct
 		break;
 	}
 
-	// Write back advertisement
+	/* Write back advertisement */
 	MiWrite(pAdapter, PHY_1000_CONTROL, usData);
 }
 
@@ -1100,35 +1098,35 @@ void ET1310_PhyAdvertise100BaseT(struct 
 {
 	uint16_t usData;
 
-	// Read the Autonegotiation Register (10/100)
+	/* Read the Autonegotiation Register (10/100) */
 	MiRead(pAdapter, PHY_AUTO_ADVERTISEMENT, &usData);
 
-	// Clear bits 7,8
+	/* Clear bits 7,8 */
 	usData &= ~0x0180;
 
 	switch (duplex) {
 	case TRUEPHY_ADV_DUPLEX_NONE:
-		// Duplex already cleared, do nothing
+		/* Duplex already cleared, do nothing */
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_FULL:
-		// Set Bit 8
+		/* Set Bit 8 */
 		usData |= 0x0100;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_HALF:
-		// Set Bit 7
+		/* Set Bit 7 */
 		usData |= 0x0080;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_BOTH:
 	default:
-		// Set Bits 7,8
+		/* Set Bits 7,8 */
 		usData |= 0x0180;
 		break;
 	}
 
-	// Write back advertisement
+	/* Write back advertisement */
 	MiWrite(pAdapter, PHY_AUTO_ADVERTISEMENT, usData);
 }
 
@@ -1137,35 +1135,35 @@ void ET1310_PhyAdvertise10BaseT(struct e
 {
 	uint16_t usData;
 
-	// Read the Autonegotiation Register (10/100)
+	/* Read the Autonegotiation Register (10/100) */
 	MiRead(pAdapter, PHY_AUTO_ADVERTISEMENT, &usData);
 
-	// Clear bits 5,6
+	/* Clear bits 5,6 */
 	usData &= ~0x0060;
 
 	switch (duplex) {
 	case TRUEPHY_ADV_DUPLEX_NONE:
-		// Duplex already cleared, do nothing
+		/* Duplex already cleared, do nothing */
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_FULL:
-		// Set Bit 6
+		/* Set Bit 6 */
 		usData |= 0x0040;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_HALF:
-		// Set Bit 5
+		/* Set Bit 5 */
 		usData |= 0x0020;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_BOTH:
 	default:
-		// Set Bits 5,6
+		/* Set Bits 5,6 */
 		usData |= 0x0060;
 		break;
 	}
 
-	// Write back advertisement
+	/* Write back advertisement */
 	MiWrite(pAdapter, PHY_AUTO_ADVERTISEMENT, usData);
 }
 
@@ -1200,18 +1198,15 @@ void ET1310_PhyLinkStatus(struct et131x_
 		    TRUEPHY_ANEG_DISABLED;
 	}
 
-	if (uiLinkSpeed) {
+	if (uiLinkSpeed)
 		*uiLinkSpeed = (usVmiPhyStatus & 0x0300) >> 8;
-	}
 
-	if (uiDuplexMode) {
+	if (uiDuplexMode)
 		*uiDuplexMode = (usVmiPhyStatus & 0x0080) >> 7;
-	}
 
-	if (uiMdiMdix) {
+	if (uiMdiMdix)
 		/* NOTE: Need to complete this */
 		*uiMdiMdix = 0;
-	}
 
 	if (uiMasterSlave) {
 		*uiMasterSlave =
@@ -1231,16 +1226,16 @@ void ET1310_PhyAndOrReg(struct et131x_ad
 {
 	uint16_t reg;
 
-	// Read the requested register
+	/* Read the requested register */
 	MiRead(pAdapter, regnum, &reg);
 
-	// Apply the AND mask
+	/* Apply the AND mask */
 	reg &= andMask;
 
-	// Apply the OR mask
+	/* Apply the OR mask */
 	reg |= orMask;
 
-	// Write the value back to the register
+	/* Write the value back to the register */
 	MiWrite(pAdapter, regnum, reg);
 }
 
@@ -1250,17 +1245,16 @@ void ET1310_PhyAccessMiBit(struct et131x
 	uint16_t reg;
 	uint16_t mask = 0;
 
-	// Create a mask to isolate the requested bit
+	/* Create a mask to isolate the requested bit */
 	mask = 0x0001 << bitnum;
 
-	// Read the requested register
+	/* Read the requested register */
 	MiRead(pAdapter, regnum, &reg);
 
 	switch (action) {
 	case TRUEPHY_BIT_READ:
-		if (value != NULL) {
+		if (value != NULL)
 			*value = (reg & mask) >> bitnum;
-		}
 		break;
 
 	case TRUEPHY_BIT_SET:
--- a/drivers/staging/et131x/et1310_phy.h
+++ b/drivers/staging/et131x/et1310_phy.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -105,31 +105,31 @@ typedef void *TRUEPHY_OSAL_HANDLE;
 
 /* PHY Register Mapping(MI) Management Interface Regs */
 typedef struct _MI_REGS_t {
-	u8 bmcr;		// Basic mode control reg(Reg 0x00)
-	u8 bmsr;		// Basic mode status reg(Reg 0x01)
-	u8 idr1;		// Phy identifier reg 1(Reg 0x02)
-	u8 idr2;		// Phy identifier reg 2(Reg 0x03)
-	u8 anar;		// Auto-Negotiation advertisement(Reg 0x04)
-	u8 anlpar;		// Auto-Negotiation link Partner Ability(Reg 0x05)
-	u8 aner;		// Auto-Negotiation expansion reg(Reg 0x06)
-	u8 annptr;		// Auto-Negotiation next page transmit reg(Reg 0x07)
-	u8 lpnpr;		// link partner next page reg(Reg 0x08)
-	u8 gcr;		// Gigabit basic mode control reg(Reg 0x09)
-	u8 gsr;		// Gigabit basic mode status reg(Reg 0x0A)
-	u8 mi_res1[4];	// Future use by MI working group(Reg 0x0B - 0x0E)
-	u8 esr;		// Extended status reg(Reg 0x0F)
-	u8 mi_res2[3];	// Future use by MI working group(Reg 0x10 - 0x12)
-	u8 loop_ctl;	// Loopback Control Reg(Reg 0x13)
-	u8 mi_res3;	// Future use by MI working group(Reg 0x14)
-	u8 mcr;		// MI Control Reg(Reg 0x15)
-	u8 pcr;		// Configuration Reg(Reg 0x16)
-	u8 phy_ctl;	// PHY Control Reg(Reg 0x17)
-	u8 imr;		// Interrupt Mask Reg(Reg 0x18)
-	u8 isr;		// Interrupt Status Reg(Reg 0x19)
-	u8 psr;		// PHY Status Reg(Reg 0x1A)
-	u8 lcr1;		// LED Control 1 Reg(Reg 0x1B)
-	u8 lcr2;		// LED Control 2 Reg(Reg 0x1C)
-	u8 mi_res4[3];	// Future use by MI working group(Reg 0x1D - 0x1F)
+	u8 bmcr;	/* Basic mode control reg(Reg 0x00) */
+	u8 bmsr;	/* Basic mode status reg(Reg 0x01) */
+	u8 idr1;	/* Phy identifier reg 1(Reg 0x02) */
+	u8 idr2;	/* Phy identifier reg 2(Reg 0x03) */
+	u8 anar;	/* Auto-Negotiation advertisement(Reg 0x04) */
+	u8 anlpar;	/* Auto-Negotiation link Partner Ability(Reg 0x05) */
+	u8 aner;	/* Auto-Negotiation expansion reg(Reg 0x06) */
+	u8 annptr;	/* Auto-Negotiation next page transmit reg(Reg 0x07) */
+	u8 lpnpr;	/* link partner next page reg(Reg 0x08) */
+	u8 gcr;		/* Gigabit basic mode control reg(Reg 0x09) */
+	u8 gsr;		/* Gigabit basic mode status reg(Reg 0x0A) */
+	u8 mi_res1[4];	/* Future use by MI working group(Reg 0x0B - 0x0E) */
+	u8 esr;		/* Extended status reg(Reg 0x0F) */
+	u8 mi_res2[3];	/* Future use by MI working group(Reg 0x10 - 0x12) */
+	u8 loop_ctl;	/* Loopback Control Reg(Reg 0x13) */
+	u8 mi_res3;	/* Future use by MI working group(Reg 0x14) */
+	u8 mcr;		/* MI Control Reg(Reg 0x15) */
+	u8 pcr;		/* Configuration Reg(Reg 0x16) */
+	u8 phy_ctl;	/* PHY Control Reg(Reg 0x17) */
+	u8 imr;		/* Interrupt Mask Reg(Reg 0x18) */
+	u8 isr;		/* Interrupt Status Reg(Reg 0x19) */
+	u8 psr;		/* PHY Status Reg(Reg 0x1A) */
+	u8 lcr1;		/* LED Control 1 Reg(Reg 0x1B) */
+	u8 lcr2;		/* LED Control 2 Reg(Reg 0x1C) */
+	u8 mi_res4[3];	/* Future use by MI working group(Reg 0x1D - 0x1F) */
 } MI_REGS_t, *PMI_REGS_t;
 
 /* MI Register 0: Basic mode control register */
@@ -137,29 +137,29 @@ typedef union _MI_BMCR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 reset:1;		// bit 15
-		u16 loopback:1;		// bit 14
-		u16 speed_sel:1;		// bit 13
-		u16 enable_autoneg:1;	// bit 12
-		u16 power_down:1;		// bit 11
-		u16 isolate:1;		// bit 10
-		u16 restart_autoneg:1;	// bit 9
-		u16 duplex_mode:1;		// bit 8
-		u16 col_test:1;		// bit 7
-		u16 speed_1000_sel:1;	// bit 6
-		u16 res1:6;		// bits 0-5
-#else
-		u16 res1:6;		// bits 0-5
-		u16 speed_1000_sel:1;	// bit 6
-		u16 col_test:1;		// bit 7
-		u16 duplex_mode:1;		// bit 8
-		u16 restart_autoneg:1;	// bit 9
-		u16 isolate:1;		// bit 10
-		u16 power_down:1;		// bit 11
-		u16 enable_autoneg:1;	// bit 12
-		u16 speed_sel:1;		// bit 13
-		u16 loopback:1;		// bit 14
-		u16 reset:1;		// bit 15
+		u16 reset:1;		/* bit 15 */
+		u16 loopback:1;		/* bit 14 */
+		u16 speed_sel:1;		/* bit 13 */
+		u16 enable_autoneg:1;	/* bit 12 */
+		u16 power_down:1;		/* bit 11 */
+		u16 isolate:1;		/* bit 10 */
+		u16 restart_autoneg:1;	/* bit 9 */
+		u16 duplex_mode:1;		/* bit 8 */
+		u16 col_test:1;		/* bit 7 */
+		u16 speed_1000_sel:1;	/* bit 6 */
+		u16 res1:6;		/* bits 0-5 */
+#else
+		u16 res1:6;		/* bits 0-5 */
+		u16 speed_1000_sel:1;	/* bit 6 */
+		u16 col_test:1;		/* bit 7 */
+		u16 duplex_mode:1;		/* bit 8 */
+		u16 restart_autoneg:1;	/* bit 9 */
+		u16 isolate:1;		/* bit 10 */
+		u16 power_down:1;		/* bit 11 */
+		u16 enable_autoneg:1;	/* bit 12 */
+		u16 speed_sel:1;		/* bit 13 */
+		u16 loopback:1;		/* bit 14 */
+		u16 reset:1;		/* bit 15 */
 #endif
 	} bits;
 } MI_BMCR_t, *PMI_BMCR_t;
@@ -169,39 +169,39 @@ typedef union _MI_BMSR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 link_100T4:1;		// bit 15
-		u16 link_100fdx:1;		// bit 14
-		u16 link_100hdx:1;		// bit 13
-		u16 link_10fdx:1;		// bit 12
-		u16 link_10hdx:1;		// bit 11
-		u16 link_100T2fdx:1;	// bit 10
-		u16 link_100T2hdx:1;	// bit 9
-		u16 extend_status:1;	// bit 8
-		u16 res1:1;		// bit 7
-		u16 preamble_supress:1;	// bit 6
-		u16 auto_neg_complete:1;	// bit 5
-		u16 remote_fault:1;	// bit 4
-		u16 auto_neg_able:1;	// bit 3
-		u16 link_status:1;		// bit 2
-		u16 jabber_detect:1;	// bit 1
-		u16 ext_cap:1;		// bit 0
-#else
-		u16 ext_cap:1;		// bit 0
-		u16 jabber_detect:1;	// bit 1
-		u16 link_status:1;		// bit 2
-		u16 auto_neg_able:1;	// bit 3
-		u16 remote_fault:1;	// bit 4
-		u16 auto_neg_complete:1;	// bit 5
-		u16 preamble_supress:1;	// bit 6
-		u16 res1:1;		// bit 7
-		u16 extend_status:1;	// bit 8
-		u16 link_100T2hdx:1;	// bit 9
-		u16 link_100T2fdx:1;	// bit 10
-		u16 link_10hdx:1;		// bit 11
-		u16 link_10fdx:1;		// bit 12
-		u16 link_100hdx:1;		// bit 13
-		u16 link_100fdx:1;		// bit 14
-		u16 link_100T4:1;		// bit 15
+		u16 link_100T4:1;		/* bit 15 */
+		u16 link_100fdx:1;		/* bit 14 */
+		u16 link_100hdx:1;		/* bit 13 */
+		u16 link_10fdx:1;		/* bit 12 */
+		u16 link_10hdx:1;		/* bit 11 */
+		u16 link_100T2fdx:1;	/* bit 10 */
+		u16 link_100T2hdx:1;	/* bit 9 */
+		u16 extend_status:1;	/* bit 8 */
+		u16 res1:1;		/* bit 7 */
+		u16 preamble_supress:1;	/* bit 6 */
+		u16 auto_neg_complete:1;	/* bit 5 */
+		u16 remote_fault:1;	/* bit 4 */
+		u16 auto_neg_able:1;	/* bit 3 */
+		u16 link_status:1;		/* bit 2 */
+		u16 jabber_detect:1;	/* bit 1 */
+		u16 ext_cap:1;		/* bit 0 */
+#else
+		u16 ext_cap:1;		/* bit 0 */
+		u16 jabber_detect:1;	/* bit 1 */
+		u16 link_status:1;		/* bit 2 */
+		u16 auto_neg_able:1;	/* bit 3 */
+		u16 remote_fault:1;	/* bit 4 */
+		u16 auto_neg_complete:1;	/* bit 5 */
+		u16 preamble_supress:1;	/* bit 6 */
+		u16 res1:1;		/* bit 7 */
+		u16 extend_status:1;	/* bit 8 */
+		u16 link_100T2hdx:1;	/* bit 9 */
+		u16 link_100T2fdx:1;	/* bit 10 */
+		u16 link_10hdx:1;		/* bit 11 */
+		u16 link_10fdx:1;		/* bit 12 */
+		u16 link_100hdx:1;		/* bit 13 */
+		u16 link_100fdx:1;		/* bit 14 */
+		u16 link_100T4:1;		/* bit 15 */
 #endif
 	} bits;
 } MI_BMSR_t, *PMI_BMSR_t;
@@ -210,7 +210,7 @@ typedef union _MI_BMSR_t {
 typedef union _MI_IDR1_t {
 	u16 value;
 	struct {
-		u16 ieee_address:16;	// 0x0282 default(bits 0-15)
+		u16 ieee_address:16;	/* 0x0282 default(bits 0-15) */
 	} bits;
 } MI_IDR1_t, *PMI_IDR1_t;
 
@@ -219,13 +219,13 @@ typedef union _MI_IDR2_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 ieee_address:6;	// 111100 default(bits 10-15)
-		u16 model_no:6;		// 000001 default(bits 4-9)
-		u16 rev_no:4;		// 0010   default(bits 0-3)
-#else
-		u16 rev_no:4;		// 0010   default(bits 0-3)
-		u16 model_no:6;		// 000001 default(bits 4-9)
-		u16 ieee_address:6;	// 111100 default(bits 10-15)
+		u16 ieee_address:6;	/* 111100 default(bits 10-15) */
+		u16 model_no:6;		/* 000001 default(bits 4-9) */
+		u16 rev_no:4;		/* 0010   default(bits 0-3) */
+#else
+		u16 rev_no:4;		/* 0010   default(bits 0-3) */
+		u16 model_no:6;		/* 000001 default(bits 4-9) */
+		u16 ieee_address:6;	/* 111100 default(bits 10-15) */
 #endif
 	} bits;
 } MI_IDR2_t, *PMI_IDR2_t;
@@ -235,31 +235,31 @@ typedef union _MI_ANAR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 np_indication:1;	// bit 15
-		u16 res2:1;		// bit 14
-		u16 remote_fault:1;	// bit 13
-		u16 res1:1;		// bit 12
-		u16 cap_asmpause:1;	// bit 11
-		u16 cap_pause:1;		// bit 10
-		u16 cap_100T4:1;		// bit 9
-		u16 cap_100fdx:1;		// bit 8
-		u16 cap_100hdx:1;		// bit 7
-		u16 cap_10fdx:1;		// bit 6
-		u16 cap_10hdx:1;		// bit 5
-		u16 selector:5;		// bits 0-4
-#else
-		u16 selector:5;		// bits 0-4
-		u16 cap_10hdx:1;		// bit 5
-		u16 cap_10fdx:1;		// bit 6
-		u16 cap_100hdx:1;		// bit 7
-		u16 cap_100fdx:1;		// bit 8
-		u16 cap_100T4:1;		// bit 9
-		u16 cap_pause:1;		// bit 10
-		u16 cap_asmpause:1;	// bit 11
-		u16 res1:1;		// bit 12
-		u16 remote_fault:1;	// bit 13
-		u16 res2:1;		// bit 14
-		u16 np_indication:1;	// bit 15
+		u16 np_indication:1;	/* bit 15 */
+		u16 res2:1;		/* bit 14 */
+		u16 remote_fault:1;	/* bit 13 */
+		u16 res1:1;		/* bit 12 */
+		u16 cap_asmpause:1;	/* bit 11 */
+		u16 cap_pause:1;		/* bit 10 */
+		u16 cap_100T4:1;		/* bit 9 */
+		u16 cap_100fdx:1;		/* bit 8 */
+		u16 cap_100hdx:1;		/* bit 7 */
+		u16 cap_10fdx:1;		/* bit 6 */
+		u16 cap_10hdx:1;		/* bit 5 */
+		u16 selector:5;		/* bits 0-4 */
+#else
+		u16 selector:5;		/* bits 0-4 */
+		u16 cap_10hdx:1;		/* bit 5 */
+		u16 cap_10fdx:1;		/* bit 6 */
+		u16 cap_100hdx:1;		/* bit 7 */
+		u16 cap_100fdx:1;		/* bit 8 */
+		u16 cap_100T4:1;		/* bit 9 */
+		u16 cap_pause:1;		/* bit 10 */
+		u16 cap_asmpause:1;	/* bit 11 */
+		u16 res1:1;		/* bit 12 */
+		u16 remote_fault:1;	/* bit 13 */
+		u16 res2:1;		/* bit 14 */
+		u16 np_indication:1;	/* bit 15 */
 #endif
 	} bits;
 } MI_ANAR_t, *PMI_ANAR_t;
@@ -269,31 +269,31 @@ typedef struct _MI_ANLPAR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 np_indication:1;	// bit 15
-		u16 acknowledge:1;		// bit 14
-		u16 remote_fault:1;	// bit 13
-		u16 res1:1;		// bit 12
-		u16 cap_asmpause:1;	// bit 11
-		u16 cap_pause:1;		// bit 10
-		u16 cap_100T4:1;		// bit 9
-		u16 cap_100fdx:1;		// bit 8
-		u16 cap_100hdx:1;		// bit 7
-		u16 cap_10fdx:1;		// bit 6
-		u16 cap_10hdx:1;		// bit 5
-		u16 selector:5;		// bits 0-4
-#else
-		u16 selector:5;		// bits 0-4
-		u16 cap_10hdx:1;		// bit 5
-		u16 cap_10fdx:1;		// bit 6
-		u16 cap_100hdx:1;		// bit 7
-		u16 cap_100fdx:1;		// bit 8
-		u16 cap_100T4:1;		// bit 9
-		u16 cap_pause:1;		// bit 10
-		u16 cap_asmpause:1;	// bit 11
-		u16 res1:1;		// bit 12
-		u16 remote_fault:1;	// bit 13
-		u16 acknowledge:1;		// bit 14
-		u16 np_indication:1;	// bit 15
+		u16 np_indication:1;	/* bit 15 */
+		u16 acknowledge:1;		/* bit 14 */
+		u16 remote_fault:1;	/* bit 13 */
+		u16 res1:1;		/* bit 12 */
+		u16 cap_asmpause:1;	/* bit 11 */
+		u16 cap_pause:1;		/* bit 10 */
+		u16 cap_100T4:1;		/* bit 9 */
+		u16 cap_100fdx:1;		/* bit 8 */
+		u16 cap_100hdx:1;		/* bit 7 */
+		u16 cap_10fdx:1;		/* bit 6 */
+		u16 cap_10hdx:1;		/* bit 5 */
+		u16 selector:5;		/* bits 0-4 */
+#else
+		u16 selector:5;		/* bits 0-4 */
+		u16 cap_10hdx:1;		/* bit 5 */
+		u16 cap_10fdx:1;		/* bit 6 */
+		u16 cap_100hdx:1;		/* bit 7 */
+		u16 cap_100fdx:1;		/* bit 8 */
+		u16 cap_100T4:1;		/* bit 9 */
+		u16 cap_pause:1;		/* bit 10 */
+		u16 cap_asmpause:1;	/* bit 11 */
+		u16 res1:1;		/* bit 12 */
+		u16 remote_fault:1;	/* bit 13 */
+		u16 acknowledge:1;		/* bit 14 */
+		u16 np_indication:1;	/* bit 15 */
 #endif
 	} bits;
 } MI_ANLPAR_t, *PMI_ANLPAR_t;
@@ -303,19 +303,19 @@ typedef union _MI_ANER_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 res:11;	// bits 5-15
-		u16 pdf:1;		// bit 4
-		u16 lp_np_able:1;	// bit 3
-		u16 np_able:1;	// bit 2
-		u16 page_rx:1;	// bit 1
-		u16 lp_an_able:1;	// bit 0
-#else
-		u16 lp_an_able:1;	// bit 0
-		u16 page_rx:1;	// bit 1
-		u16 np_able:1;	// bit 2
-		u16 lp_np_able:1;	// bit 3
-		u16 pdf:1;		// bit 4
-		u16 res:11;	// bits 5-15
+		u16 res:11;	/* bits 5-15 */
+		u16 pdf:1;		/* bit 4 */
+		u16 lp_np_able:1;	/* bit 3 */
+		u16 np_able:1;	/* bit 2 */
+		u16 page_rx:1;	/* bit 1 */
+		u16 lp_an_able:1;	/* bit 0 */
+#else
+		u16 lp_an_able:1;	/* bit 0 */
+		u16 page_rx:1;	/* bit 1 */
+		u16 np_able:1;	/* bit 2 */
+		u16 lp_np_able:1;	/* bit 3 */
+		u16 pdf:1;		/* bit 4 */
+		u16 res:11;	/* bits 5-15 */
 #endif
 	} bits;
 } MI_ANER_t, *PMI_ANER_t;
@@ -325,19 +325,19 @@ typedef union _MI_ANNPTR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 np:1;		// bit 15
-		u16 res1:1;	// bit 14
-		u16 msg_page:1;	// bit 13
-		u16 ack2:1;	// bit 12
-		u16 toggle:1;	// bit 11
-		u16 msg:11;	// bits 0-10
-#else
-		u16 msg:11;	// bits 0-10
-		u16 toggle:1;	// bit 11
-		u16 ack2:1;	// bit 12
-		u16 msg_page:1;	// bit 13
-		u16 res1:1;	// bit 14
-		u16 np:1;		// bit 15
+		u16 np:1;		/* bit 15 */
+		u16 res1:1;	/* bit 14 */
+		u16 msg_page:1;	/* bit 13 */
+		u16 ack2:1;	/* bit 12 */
+		u16 toggle:1;	/* bit 11 */
+		u16 msg:11;	/* bits 0-10 */
+#else
+		u16 msg:11;	/* bits 0-10 */
+		u16 toggle:1;	/* bit 11 */
+		u16 ack2:1;	/* bit 12 */
+		u16 msg_page:1;	/* bit 13 */
+		u16 res1:1;	/* bit 14 */
+		u16 np:1;		/* bit 15 */
 #endif
 	} bits;
 } MI_ANNPTR_t, *PMI_ANNPTR_t;
@@ -347,19 +347,19 @@ typedef union _MI_LPNPR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 np:1;		// bit 15
-		u16 ack:1;		// bit 14
-		u16 msg_page:1;	// bit 13
-		u16 ack2:1;	// bit 12
-		u16 toggle:1;	// bit 11
-		u16 msg:11;	// bits 0-10
-#else
-		u16 msg:11;	// bits 0-10
-		u16 toggle:1;	// bit 11
-		u16 ack2:1;	// bit 12
-		u16 msg_page:1;	// bit 13
-		u16 ack:1;		// bit 14
-		u16 np:1;		// bit 15
+		u16 np:1;		/* bit 15 */
+		u16 ack:1;		/* bit 14 */
+		u16 msg_page:1;	/* bit 13 */
+		u16 ack2:1;	/* bit 12 */
+		u16 toggle:1;	/* bit 11 */
+		u16 msg:11;	/* bits 0-10 */
+#else
+		u16 msg:11;	/* bits 0-10 */
+		u16 toggle:1;	/* bit 11 */
+		u16 ack2:1;	/* bit 12 */
+		u16 msg_page:1;	/* bit 13 */
+		u16 ack:1;		/* bit 14 */
+		u16 np:1;		/* bit 15 */
 #endif
 	} bits;
 } MI_LPNPR_t, *PMI_LPNPR_t;
@@ -369,21 +369,21 @@ typedef union _MI_GCR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 test_mode:3;		// bits 13-15
-		u16 ms_config_en:1;	// bit 12
-		u16 ms_value:1;		// bit 11
-		u16 port_type:1;		// bit 10
-		u16 link_1000fdx:1;	// bit 9
-		u16 link_1000hdx:1;	// bit 8
-		u16 res:8;			// bit 0-7
-#else
-		u16 res:8;			// bit 0-7
-		u16 link_1000hdx:1;	// bit 8
-		u16 link_1000fdx:1;	// bit 9
-		u16 port_type:1;		// bit 10
-		u16 ms_value:1;		// bit 11
-		u16 ms_config_en:1;	// bit 12
-		u16 test_mode:3;		// bits 13-15
+		u16 test_mode:3;		/* bits 13-15 */
+		u16 ms_config_en:1;	/* bit 12 */
+		u16 ms_value:1;		/* bit 11 */
+		u16 port_type:1;		/* bit 10 */
+		u16 link_1000fdx:1;	/* bit 9 */
+		u16 link_1000hdx:1;	/* bit 8 */
+		u16 res:8;			/* bit 0-7 */
+#else
+		u16 res:8;			/* bit 0-7 */
+		u16 link_1000hdx:1;	/* bit 8 */
+		u16 link_1000fdx:1;	/* bit 9 */
+		u16 port_type:1;		/* bit 10 */
+		u16 ms_value:1;		/* bit 11 */
+		u16 ms_config_en:1;	/* bit 12 */
+		u16 test_mode:3;		/* bits 13-15 */
 #endif
 	} bits;
 } MI_GCR_t, *PMI_GCR_t;
@@ -393,23 +393,23 @@ typedef union _MI_GSR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 ms_config_fault:1;	// bit 15
-		u16 ms_resolve:1;		// bit 14
-		u16 local_rx_status:1;	// bit 13
-		u16 remote_rx_status:1;	// bit 12
-		u16 link_1000fdx:1;	// bit 11
-		u16 link_1000hdx:1;	// bit 10
-		u16 res:2;			// bits 8-9
-		u16 idle_err_cnt:8;	// bits 0-7
-#else
-		u16 idle_err_cnt:8;	// bits 0-7
-		u16 res:2;			// bits 8-9
-		u16 link_1000hdx:1;	// bit 10
-		u16 link_1000fdx:1;	// bit 11
-		u16 remote_rx_status:1;	// bit 12
-		u16 local_rx_status:1;	// bit 13
-		u16 ms_resolve:1;		// bit 14
-		u16 ms_config_fault:1;	// bit 15
+		u16 ms_config_fault:1;	/* bit 15 */
+		u16 ms_resolve:1;		/* bit 14 */
+		u16 local_rx_status:1;	/* bit 13 */
+		u16 remote_rx_status:1;	/* bit 12 */
+		u16 link_1000fdx:1;	/* bit 11 */
+		u16 link_1000hdx:1;	/* bit 10 */
+		u16 res:2;			/* bits 8-9 */
+		u16 idle_err_cnt:8;	/* bits 0-7 */
+#else
+		u16 idle_err_cnt:8;	/* bits 0-7 */
+		u16 res:2;			/* bits 8-9 */
+		u16 link_1000hdx:1;	/* bit 10 */
+		u16 link_1000fdx:1;	/* bit 11 */
+		u16 remote_rx_status:1;	/* bit 12 */
+		u16 local_rx_status:1;	/* bit 13 */
+		u16 ms_resolve:1;		/* bit 14 */
+		u16 ms_config_fault:1;	/* bit 15 */
 #endif
 	} bits;
 } MI_GSR_t, *PMI_GSR_t;
@@ -419,39 +419,39 @@ typedef union _MI_RES_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 res15:1;	// bit 15
-		u16 res14:1;	// bit 14
-		u16 res13:1;	// bit 13
-		u16 res12:1;	// bit 12
-		u16 res11:1;	// bit 11
-		u16 res10:1;	// bit 10
-		u16 res9:1;	// bit 9
-		u16 res8:1;	// bit 8
-		u16 res7:1;	// bit 7
-		u16 res6:1;	// bit 6
-		u16 res5:1;	// bit 5
-		u16 res4:1;	// bit 4
-		u16 res3:1;	// bit 3
-		u16 res2:1;	// bit 2
-		u16 res1:1;	// bit 1
-		u16 res0:1;	// bit 0
-#else
-		u16 res0:1;	// bit 0
-		u16 res1:1;	// bit 1
-		u16 res2:1;	// bit 2
-		u16 res3:1;	// bit 3
-		u16 res4:1;	// bit 4
-		u16 res5:1;	// bit 5
-		u16 res6:1;	// bit 6
-		u16 res7:1;	// bit 7
-		u16 res8:1;	// bit 8
-		u16 res9:1;	// bit 9
-		u16 res10:1;	// bit 10
-		u16 res11:1;	// bit 11
-		u16 res12:1;	// bit 12
-		u16 res13:1;	// bit 13
-		u16 res14:1;	// bit 14
-		u16 res15:1;	// bit 15
+		u16 res15:1;	/* bit 15 */
+		u16 res14:1;	/* bit 14 */
+		u16 res13:1;	/* bit 13 */
+		u16 res12:1;	/* bit 12 */
+		u16 res11:1;	/* bit 11 */
+		u16 res10:1;	/* bit 10 */
+		u16 res9:1;	/* bit 9 */
+		u16 res8:1;	/* bit 8 */
+		u16 res7:1;	/* bit 7 */
+		u16 res6:1;	/* bit 6 */
+		u16 res5:1;	/* bit 5 */
+		u16 res4:1;	/* bit 4 */
+		u16 res3:1;	/* bit 3 */
+		u16 res2:1;	/* bit 2 */
+		u16 res1:1;	/* bit 1 */
+		u16 res0:1;	/* bit 0 */
+#else
+		u16 res0:1;	/* bit 0 */
+		u16 res1:1;	/* bit 1 */
+		u16 res2:1;	/* bit 2 */
+		u16 res3:1;	/* bit 3 */
+		u16 res4:1;	/* bit 4 */
+		u16 res5:1;	/* bit 5 */
+		u16 res6:1;	/* bit 6 */
+		u16 res7:1;	/* bit 7 */
+		u16 res8:1;	/* bit 8 */
+		u16 res9:1;	/* bit 9 */
+		u16 res10:1;	/* bit 10 */
+		u16 res11:1;	/* bit 11 */
+		u16 res12:1;	/* bit 12 */
+		u16 res13:1;	/* bit 13 */
+		u16 res14:1;	/* bit 14 */
+		u16 res15:1;	/* bit 15 */
 #endif
 	} bits;
 } MI_RES_t, *PMI_RES_t;
@@ -461,17 +461,17 @@ typedef union _MI_ESR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 link_1000Xfdx:1;	// bit 15
-		u16 link_1000Xhdx:1;	// bit 14
-		u16 link_1000fdx:1;	// bit 13
-		u16 link_1000hdx:1;	// bit 12
-		u16 res:12;		// bit 0-11
-#else
-		u16 res:12;		// bit 0-11
-		u16 link_1000hdx:1;	// bit 12
-		u16 link_1000fdx:1;	// bit 13
-		u16 link_1000Xhdx:1;	// bit 14
-		u16 link_1000Xfdx:1;	// bit 15
+		u16 link_1000Xfdx:1;	/* bit 15 */
+		u16 link_1000Xhdx:1;	/* bit 14 */
+		u16 link_1000fdx:1;	/* bit 13 */
+		u16 link_1000hdx:1;	/* bit 12 */
+		u16 res:12;		/* bit 0-11 */
+#else
+		u16 res:12;		/* bit 0-11 */
+		u16 link_1000hdx:1;	/* bit 12 */
+		u16 link_1000fdx:1;	/* bit 13 */
+		u16 link_1000Xhdx:1;	/* bit 14 */
+		u16 link_1000Xfdx:1;	/* bit 15 */
 #endif
 	} bits;
 } MI_ESR_t, *PMI_ESR_t;
@@ -483,21 +483,21 @@ typedef union _MI_LCR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 mii_en:1;		// bit 15
-		u16 pcs_en:1;		// bit 14
-		u16 pmd_en:1;		// bit 13
-		u16 all_digital_en:1;	// bit 12
-		u16 replica_en:1;		// bit 11
-		u16 line_driver_en:1;	// bit 10
-		u16 res:10;		// bit 0-9
-#else
-		u16 res:10;		// bit 0-9
-		u16 line_driver_en:1;	// bit 10
-		u16 replica_en:1;		// bit 11
-		u16 all_digital_en:1;	// bit 12
-		u16 pmd_en:1;		// bit 13
-		u16 pcs_en:1;		// bit 14
-		u16 mii_en:1;		// bit 15
+		u16 mii_en:1;		/* bit 15 */
+		u16 pcs_en:1;		/* bit 14 */
+		u16 pmd_en:1;		/* bit 13 */
+		u16 all_digital_en:1;	/* bit 12 */
+		u16 replica_en:1;		/* bit 11 */
+		u16 line_driver_en:1;	/* bit 10 */
+		u16 res:10;		/* bit 0-9 */
+#else
+		u16 res:10;		/* bit 0-9 */
+		u16 line_driver_en:1;	/* bit 10 */
+		u16 replica_en:1;		/* bit 11 */
+		u16 all_digital_en:1;	/* bit 12 */
+		u16 pmd_en:1;		/* bit 13 */
+		u16 pcs_en:1;		/* bit 14 */
+		u16 mii_en:1;		/* bit 15 */
 #endif
 	} bits;
 } MI_LCR_t, *PMI_LCR_t;
@@ -509,19 +509,19 @@ typedef union _MI_MICR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 res1:5;		// bits 11-15
-		u16 mi_error_count:7;	// bits 4-10
-		u16 res2:1;		// bit 3
-		u16 ignore_10g_fr:1;	// bit 2
-		u16 res3:1;		// bit 1
-		u16 preamble_supress_en:1;	// bit 0
-#else
-		u16 preamble_supress_en:1;	// bit 0
-		u16 res3:1;		// bit 1
-		u16 ignore_10g_fr:1;	// bit 2
-		u16 res2:1;		// bit 3
-		u16 mi_error_count:7;	// bits 4-10
-		u16 res1:5;		// bits 11-15
+		u16 res1:5;		/* bits 11-15 */
+		u16 mi_error_count:7;	/* bits 4-10 */
+		u16 res2:1;		/* bit 3 */
+		u16 ignore_10g_fr:1;	/* bit 2 */
+		u16 res3:1;		/* bit 1 */
+		u16 preamble_supress_en:1;	/* bit 0 */
+#else
+		u16 preamble_supress_en:1;	/* bit 0 */
+		u16 res3:1;		/* bit 1 */
+		u16 ignore_10g_fr:1;	/* bit 2 */
+		u16 res2:1;		/* bit 3 */
+		u16 mi_error_count:7;	/* bits 4-10 */
+		u16 res1:5;		/* bits 11-15 */
 #endif
 	} bits;
 } MI_MICR_t, *PMI_MICR_t;
@@ -531,31 +531,31 @@ typedef union _MI_PHY_CONFIG_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 crs_tx_en:1;		// bit 15
-		u16 res1:1;		// bit 14
-		u16 tx_fifo_depth:2;	// bits 12-13
-		u16 speed_downshift:2;	// bits 10-11
-		u16 pbi_detect:1;		// bit 9
-		u16 tbi_rate:1;		// bit 8
-		u16 alternate_np:1;	// bit 7
-		u16 group_mdio_en:1;	// bit 6
-		u16 tx_clock_en:1;		// bit 5
-		u16 sys_clock_en:1;	// bit 4
-		u16 res2:1;		// bit 3
-		u16 mac_if_mode:3;		// bits 0-2
-#else
-		u16 mac_if_mode:3;		// bits 0-2
-		u16 res2:1;		// bit 3
-		u16 sys_clock_en:1;	// bit 4
-		u16 tx_clock_en:1;		// bit 5
-		u16 group_mdio_en:1;	// bit 6
-		u16 alternate_np:1;	// bit 7
-		u16 tbi_rate:1;		// bit 8
-		u16 pbi_detect:1;		// bit 9
-		u16 speed_downshift:2;	// bits 10-11
-		u16 tx_fifo_depth:2;	// bits 12-13
-		u16 res1:1;		// bit 14
-		u16 crs_tx_en:1;		// bit 15
+		u16 crs_tx_en:1;		/* bit 15 */
+		u16 res1:1;		/* bit 14 */
+		u16 tx_fifo_depth:2;	/* bits 12-13 */
+		u16 speed_downshift:2;	/* bits 10-11 */
+		u16 pbi_detect:1;		/* bit 9 */
+		u16 tbi_rate:1;		/* bit 8 */
+		u16 alternate_np:1;	/* bit 7 */
+		u16 group_mdio_en:1;	/* bit 6 */
+		u16 tx_clock_en:1;		/* bit 5 */
+		u16 sys_clock_en:1;	/* bit 4 */
+		u16 res2:1;		/* bit 3 */
+		u16 mac_if_mode:3;		/* bits 0-2 */
+#else
+		u16 mac_if_mode:3;		/* bits 0-2 */
+		u16 res2:1;		/* bit 3 */
+		u16 sys_clock_en:1;	/* bit 4 */
+		u16 tx_clock_en:1;		/* bit 5 */
+		u16 group_mdio_en:1;	/* bit 6 */
+		u16 alternate_np:1;	/* bit 7 */
+		u16 tbi_rate:1;		/* bit 8 */
+		u16 pbi_detect:1;		/* bit 9 */
+		u16 speed_downshift:2;	/* bits 10-11 */
+		u16 tx_fifo_depth:2;	/* bits 12-13 */
+		u16 res1:1;		/* bit 14 */
+		u16 crs_tx_en:1;		/* bit 15 */
 #endif
 	} bits;
 } MI_PHY_CONFIG_t, *PMI_PHY_CONFIG_t;
@@ -565,29 +565,29 @@ typedef union _MI_PHY_CONTROL_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 res1:1;		// bit 15
-		u16 tdr_en:1;		// bit 14
-		u16 res2:1;		// bit 13
-		u16 downshift_attempts:2;	// bits 11-12
-		u16 res3:5;		// bit 6-10
-		u16 jabber_10baseT:1;	// bit 5
-		u16 sqe_10baseT:1;		// bit 4
-		u16 tp_loopback_10baseT:1;	// bit 3
-		u16 preamble_gen_en:1;	// bit 2
-		u16 res4:1;		// bit 1
-		u16 force_int:1;		// bit 0
-#else
-		u16 force_int:1;		// bit 0
-		u16 res4:1;		// bit 1
-		u16 preamble_gen_en:1;	// bit 2
-		u16 tp_loopback_10baseT:1;	// bit 3
-		u16 sqe_10baseT:1;		// bit 4
-		u16 jabber_10baseT:1;	// bit 5
-		u16 res3:5;		// bit 6-10
-		u16 downshift_attempts:2;	// bits 11-12
-		u16 res2:1;		// bit 13
-		u16 tdr_en:1;		// bit 14
-		u16 res1:1;		// bit 15
+		u16 res1:1;		/* bit 15 */
+		u16 tdr_en:1;		/* bit 14 */
+		u16 res2:1;		/* bit 13 */
+		u16 downshift_attempts:2;	/* bits 11-12 */
+		u16 res3:5;		/* bit 6-10 */
+		u16 jabber_10baseT:1;	/* bit 5 */
+		u16 sqe_10baseT:1;		/* bit 4 */
+		u16 tp_loopback_10baseT:1;	/* bit 3 */
+		u16 preamble_gen_en:1;	/* bit 2 */
+		u16 res4:1;		/* bit 1 */
+		u16 force_int:1;		/* bit 0 */
+#else
+		u16 force_int:1;		/* bit 0 */
+		u16 res4:1;		/* bit 1 */
+		u16 preamble_gen_en:1;	/* bit 2 */
+		u16 tp_loopback_10baseT:1;	/* bit 3 */
+		u16 sqe_10baseT:1;		/* bit 4 */
+		u16 jabber_10baseT:1;	/* bit 5 */
+		u16 res3:5;		/* bit 6-10 */
+		u16 downshift_attempts:2;	/* bits 11-12 */
+		u16 res2:1;		/* bit 13 */
+		u16 tdr_en:1;		/* bit 14 */
+		u16 res1:1;		/* bit 15 */
 #endif
 	} bits;
 } MI_PHY_CONTROL_t, *PMI_PHY_CONTROL_t;
@@ -597,29 +597,29 @@ typedef union _MI_IMR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 res1:6;		// bits 10-15
-		u16 mdio_sync_lost:1;	// bit 9
-		u16 autoneg_status:1;	// bit 8
-		u16 hi_bit_err:1;		// bit 7
-		u16 np_rx:1;		// bit 6
-		u16 err_counter_full:1;	// bit 5
-		u16 fifo_over_underflow:1;	// bit 4
-		u16 rx_status:1;		// bit 3
-		u16 link_status:1;		// bit 2
-		u16 automatic_speed:1;	// bit 1
-		u16 int_en:1;		// bit 0
-#else
-		u16 int_en:1;		// bit 0
-		u16 automatic_speed:1;	// bit 1
-		u16 link_status:1;		// bit 2
-		u16 rx_status:1;		// bit 3
-		u16 fifo_over_underflow:1;	// bit 4
-		u16 err_counter_full:1;	// bit 5
-		u16 np_rx:1;		// bit 6
-		u16 hi_bit_err:1;		// bit 7
-		u16 autoneg_status:1;	// bit 8
-		u16 mdio_sync_lost:1;	// bit 9
-		u16 res1:6;		// bits 10-15
+		u16 res1:6;		/* bits 10-15 */
+		u16 mdio_sync_lost:1;	/* bit 9 */
+		u16 autoneg_status:1;	/* bit 8 */
+		u16 hi_bit_err:1;		/* bit 7 */
+		u16 np_rx:1;		/* bit 6 */
+		u16 err_counter_full:1;	/* bit 5 */
+		u16 fifo_over_underflow:1;	/* bit 4 */
+		u16 rx_status:1;		/* bit 3 */
+		u16 link_status:1;		/* bit 2 */
+		u16 automatic_speed:1;	/* bit 1 */
+		u16 int_en:1;		/* bit 0 */
+#else
+		u16 int_en:1;		/* bit 0 */
+		u16 automatic_speed:1;	/* bit 1 */
+		u16 link_status:1;		/* bit 2 */
+		u16 rx_status:1;		/* bit 3 */
+		u16 fifo_over_underflow:1;	/* bit 4 */
+		u16 err_counter_full:1;	/* bit 5 */
+		u16 np_rx:1;		/* bit 6 */
+		u16 hi_bit_err:1;		/* bit 7 */
+		u16 autoneg_status:1;	/* bit 8 */
+		u16 mdio_sync_lost:1;	/* bit 9 */
+		u16 res1:6;		/* bits 10-15 */
 #endif
 	} bits;
 } MI_IMR_t, *PMI_IMR_t;
@@ -629,29 +629,29 @@ typedef union _MI_ISR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 res1:6;		// bits 10-15
-		u16 mdio_sync_lost:1;	// bit 9
-		u16 autoneg_status:1;	// bit 8
-		u16 hi_bit_err:1;		// bit 7
-		u16 np_rx:1;		// bit 6
-		u16 err_counter_full:1;	// bit 5
-		u16 fifo_over_underflow:1;	// bit 4
-		u16 rx_status:1;		// bit 3
-		u16 link_status:1;		// bit 2
-		u16 automatic_speed:1;	// bit 1
-		u16 int_en:1;		// bit 0
-#else
-		u16 int_en:1;		// bit 0
-		u16 automatic_speed:1;	// bit 1
-		u16 link_status:1;		// bit 2
-		u16 rx_status:1;		// bit 3
-		u16 fifo_over_underflow:1;	// bit 4
-		u16 err_counter_full:1;	// bit 5
-		u16 np_rx:1;		// bit 6
-		u16 hi_bit_err:1;		// bit 7
-		u16 autoneg_status:1;	// bit 8
-		u16 mdio_sync_lost:1;	// bit 9
-		u16 res1:6;		// bits 10-15
+		u16 res1:6;		/* bits 10-15 */
+		u16 mdio_sync_lost:1;	/* bit 9 */
+		u16 autoneg_status:1;	/* bit 8 */
+		u16 hi_bit_err:1;		/* bit 7 */
+		u16 np_rx:1;		/* bit 6 */
+		u16 err_counter_full:1;	/* bit 5 */
+		u16 fifo_over_underflow:1;	/* bit 4 */
+		u16 rx_status:1;		/* bit 3 */
+		u16 link_status:1;		/* bit 2 */
+		u16 automatic_speed:1;	/* bit 1 */
+		u16 int_en:1;		/* bit 0 */
+#else
+		u16 int_en:1;		/* bit 0 */
+		u16 automatic_speed:1;	/* bit 1 */
+		u16 link_status:1;		/* bit 2 */
+		u16 rx_status:1;		/* bit 3 */
+		u16 fifo_over_underflow:1;	/* bit 4 */
+		u16 err_counter_full:1;	/* bit 5 */
+		u16 np_rx:1;		/* bit 6 */
+		u16 hi_bit_err:1;		/* bit 7 */
+		u16 autoneg_status:1;	/* bit 8 */
+		u16 mdio_sync_lost:1;	/* bit 9 */
+		u16 res1:6;		/* bits 10-15 */
 #endif
 	} bits;
 } MI_ISR_t, *PMI_ISR_t;
@@ -661,35 +661,35 @@ typedef union _MI_PSR_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 res1:1;		// bit 15
-		u16 autoneg_fault:2;	// bit 13-14
-		u16 autoneg_status:1;	// bit 12
-		u16 mdi_x_status:1;	// bit 11
-		u16 polarity_status:1;	// bit 10
-		u16 speed_status:2;	// bits 8-9
-		u16 duplex_status:1;	// bit 7
-		u16 link_status:1;		// bit 6
-		u16 tx_status:1;		// bit 5
-		u16 rx_status:1;		// bit 4
-		u16 collision_status:1;	// bit 3
-		u16 autoneg_en:1;		// bit 2
-		u16 pause_en:1;		// bit 1
-		u16 asymmetric_dir:1;	// bit 0
-#else
-		u16 asymmetric_dir:1;	// bit 0
-		u16 pause_en:1;		// bit 1
-		u16 autoneg_en:1;		// bit 2
-		u16 collision_status:1;	// bit 3
-		u16 rx_status:1;		// bit 4
-		u16 tx_status:1;		// bit 5
-		u16 link_status:1;		// bit 6
-		u16 duplex_status:1;	// bit 7
-		u16 speed_status:2;	// bits 8-9
-		u16 polarity_status:1;	// bit 10
-		u16 mdi_x_status:1;	// bit 11
-		u16 autoneg_status:1;	// bit 12
-		u16 autoneg_fault:2;	// bit 13-14
-		u16 res1:1;		// bit 15
+		u16 res1:1;		/* bit 15 */
+		u16 autoneg_fault:2;	/* bit 13-14 */
+		u16 autoneg_status:1;	/* bit 12 */
+		u16 mdi_x_status:1;	/* bit 11 */
+		u16 polarity_status:1;	/* bit 10 */
+		u16 speed_status:2;	/* bits 8-9 */
+		u16 duplex_status:1;	/* bit 7 */
+		u16 link_status:1;		/* bit 6 */
+		u16 tx_status:1;		/* bit 5 */
+		u16 rx_status:1;		/* bit 4 */
+		u16 collision_status:1;	/* bit 3 */
+		u16 autoneg_en:1;		/* bit 2 */
+		u16 pause_en:1;		/* bit 1 */
+		u16 asymmetric_dir:1;	/* bit 0 */
+#else
+		u16 asymmetric_dir:1;	/* bit 0 */
+		u16 pause_en:1;		/* bit 1 */
+		u16 autoneg_en:1;		/* bit 2 */
+		u16 collision_status:1;	/* bit 3 */
+		u16 rx_status:1;		/* bit 4 */
+		u16 tx_status:1;		/* bit 5 */
+		u16 link_status:1;		/* bit 6 */
+		u16 duplex_status:1;	/* bit 7 */
+		u16 speed_status:2;	/* bits 8-9 */
+		u16 polarity_status:1;	/* bit 10 */
+		u16 mdi_x_status:1;	/* bit 11 */
+		u16 autoneg_status:1;	/* bit 12 */
+		u16 autoneg_fault:2;	/* bit 13-14 */
+		u16 res1:1;		/* bit 15 */
 #endif
 	} bits;
 } MI_PSR_t, *PMI_PSR_t;
@@ -699,25 +699,25 @@ typedef union _MI_LCR1_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 res1:2;		// bits 14-15
-		u16 led_dup_indicate:2;	// bits 12-13
-		u16 led_10baseT:2;		// bits 10-11
-		u16 led_collision:2;	// bits 8-9
-		u16 res2:2;		// bits 6-7
-		u16 res3:2;		// bits 4-5
-		u16 pulse_dur:2;		// bits 2-3
-		u16 pulse_stretch1:1;	// bit 1
-		u16 pulse_stretch0:1;	// bit 0
-#else
-		u16 pulse_stretch0:1;	// bit 0
-		u16 pulse_stretch1:1;	// bit 1
-		u16 pulse_dur:2;		// bits 2-3
-		u16 res3:2;		// bits 4-5
-		u16 res2:2;		// bits 6-7
-		u16 led_collision:2;	// bits 8-9
-		u16 led_10baseT:2;		// bits 10-11
-		u16 led_dup_indicate:2;	// bits 12-13
-		u16 res1:2;		// bits 14-15
+		u16 res1:2;		/* bits 14-15 */
+		u16 led_dup_indicate:2;	/* bits 12-13 */
+		u16 led_10baseT:2;		/* bits 10-11 */
+		u16 led_collision:2;	/* bits 8-9 */
+		u16 res2:2;		/* bits 6-7 */
+		u16 res3:2;		/* bits 4-5 */
+		u16 pulse_dur:2;		/* bits 2-3 */
+		u16 pulse_stretch1:1;	/* bit 1 */
+		u16 pulse_stretch0:1;	/* bit 0 */
+#else
+		u16 pulse_stretch0:1;	/* bit 0 */
+		u16 pulse_stretch1:1;	/* bit 1 */
+		u16 pulse_dur:2;		/* bits 2-3 */
+		u16 res3:2;		/* bits 4-5 */
+		u16 res2:2;		/* bits 6-7 */
+		u16 led_collision:2;	/* bits 8-9 */
+		u16 led_10baseT:2;		/* bits 10-11 */
+		u16 led_dup_indicate:2;	/* bits 12-13 */
+		u16 res1:2;		/* bits 14-15 */
 #endif
 	} bits;
 } MI_LCR1_t, *PMI_LCR1_t;
@@ -727,15 +727,15 @@ typedef union _MI_LCR2_t {
 	u16 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u16 led_link:4;		// bits 12-15
-		u16 led_tx_rx:4;		// bits 8-11
-		u16 led_100BaseTX:4;	// bits 4-7
-		u16 led_1000BaseT:4;	// bits 0-3
-#else
-		u16 led_1000BaseT:4;	// bits 0-3
-		u16 led_100BaseTX:4;	// bits 4-7
-		u16 led_tx_rx:4;		// bits 8-11
-		u16 led_link:4;		// bits 12-15
+		u16 led_link:4;		/* bits 12-15 */
+		u16 led_tx_rx:4;		/* bits 8-11 */
+		u16 led_100BaseTX:4;	/* bits 4-7 */
+		u16 led_1000BaseT:4;	/* bits 0-3 */
+#else
+		u16 led_1000BaseT:4;	/* bits 0-3 */
+		u16 led_100BaseTX:4;	/* bits 4-7 */
+		u16 led_tx_rx:4;		/* bits 8-11 */
+		u16 led_link:4;		/* bits 12-15 */
 #endif
 	} bits;
 } MI_LCR2_t, *PMI_LCR2_t;
@@ -802,41 +802,41 @@ void SetPhy_10BaseTHalfDuplex(struct et1
 
 /* Defines for PHY access routines */
 
-// Define bit operation flags
+/* Define bit operation flags */
 #define TRUEPHY_BIT_CLEAR               0
 #define TRUEPHY_BIT_SET                 1
 #define TRUEPHY_BIT_READ                2
 
-// Define read/write operation flags
+/* Define read/write operation flags */
 #ifndef TRUEPHY_READ
 #define TRUEPHY_READ                    0
 #define TRUEPHY_WRITE                   1
 #define TRUEPHY_MASK                    2
 #endif
 
-// Define speeds
+/* Define speeds */
 #define TRUEPHY_SPEED_10MBPS            0
 #define TRUEPHY_SPEED_100MBPS           1
 #define TRUEPHY_SPEED_1000MBPS          2
 
-// Define duplex modes
+/* Define duplex modes */
 #define TRUEPHY_DUPLEX_HALF             0
 #define TRUEPHY_DUPLEX_FULL             1
 
-// Define master/slave configuration values
+/* Define master/slave configuration values */
 #define TRUEPHY_CFG_SLAVE               0
 #define TRUEPHY_CFG_MASTER              1
 
-// Define MDI/MDI-X settings
+/* Define MDI/MDI-X settings */
 #define TRUEPHY_MDI                     0
 #define TRUEPHY_MDIX                    1
 #define TRUEPHY_AUTO_MDI_MDIX           2
 
-// Define 10Base-T link polarities
+/* Define 10Base-T link polarities */
 #define TRUEPHY_POLARITY_NORMAL         0
 #define TRUEPHY_POLARITY_INVERTED       1
 
-// Define auto-negotiation results
+/* Define auto-negotiation results */
 #define TRUEPHY_ANEG_NOT_COMPLETE       0
 #define TRUEPHY_ANEG_COMPLETE           1
 #define TRUEPHY_ANEG_DISABLED           2
@@ -848,38 +848,38 @@ void SetPhy_10BaseTHalfDuplex(struct et1
 #define TRUEPHY_ADV_DUPLEX_BOTH     \
     (TRUEPHY_ADV_DUPLEX_FULL | TRUEPHY_ADV_DUPLEX_HALF)
 
-#define PHY_CONTROL                0x00	//#define TRU_MI_CONTROL_REGISTER                 0
-#define PHY_STATUS                 0x01	//#define TRU_MI_STATUS_REGISTER                  1
-#define PHY_ID_1                   0x02	//#define TRU_MI_PHY_IDENTIFIER_1_REGISTER        2
-#define PHY_ID_2                   0x03	//#define TRU_MI_PHY_IDENTIFIER_2_REGISTER        3
-#define PHY_AUTO_ADVERTISEMENT     0x04	//#define TRU_MI_ADVERTISEMENT_REGISTER           4
-#define PHY_AUTO_LINK_PARTNER      0x05	//#define TRU_MI_LINK_PARTNER_ABILITY_REGISTER    5
-#define PHY_AUTO_EXPANSION         0x06	//#define TRU_MI_EXPANSION_REGISTER               6
-#define PHY_AUTO_NEXT_PAGE_TX      0x07	//#define TRU_MI_NEXT_PAGE_TRANSMIT_REGISTER      7
-#define PHY_LINK_PARTNER_NEXT_PAGE 0x08	//#define TRU_MI_LINK_PARTNER_NEXT_PAGE_REGISTER  8
-#define PHY_1000_CONTROL           0x09	//#define TRU_MI_1000BASET_CONTROL_REGISTER       9
-#define PHY_1000_STATUS            0x0A	//#define TRU_MI_1000BASET_STATUS_REGISTER        10
+#define PHY_CONTROL                0x00	/* #define TRU_MI_CONTROL_REGISTER                 0 */
+#define PHY_STATUS                 0x01	/* #define TRU_MI_STATUS_REGISTER                  1 */
+#define PHY_ID_1                   0x02	/* #define TRU_MI_PHY_IDENTIFIER_1_REGISTER        2 */
+#define PHY_ID_2                   0x03	/* #define TRU_MI_PHY_IDENTIFIER_2_REGISTER        3 */
+#define PHY_AUTO_ADVERTISEMENT     0x04	/* #define TRU_MI_ADVERTISEMENT_REGISTER           4 */
+#define PHY_AUTO_LINK_PARTNER      0x05	/* #define TRU_MI_LINK_PARTNER_ABILITY_REGISTER    5 */
+#define PHY_AUTO_EXPANSION         0x06	/* #define TRU_MI_EXPANSION_REGISTER               6 */
+#define PHY_AUTO_NEXT_PAGE_TX      0x07	/* #define TRU_MI_NEXT_PAGE_TRANSMIT_REGISTER      7 */
+#define PHY_LINK_PARTNER_NEXT_PAGE 0x08	/* #define TRU_MI_LINK_PARTNER_NEXT_PAGE_REGISTER  8 */
+#define PHY_1000_CONTROL           0x09	/* #define TRU_MI_1000BASET_CONTROL_REGISTER       9 */
+#define PHY_1000_STATUS            0x0A	/* #define TRU_MI_1000BASET_STATUS_REGISTER        10 */
 
-#define PHY_EXTENDED_STATUS        0x0F	//#define TRU_MI_EXTENDED_STATUS_REGISTER         15
+#define PHY_EXTENDED_STATUS        0x0F	/* #define TRU_MI_EXTENDED_STATUS_REGISTER         15 */
 
-// some defines for modem registers that seem to be 'reserved'
+/* some defines for modem registers that seem to be 'reserved' */
 #define PHY_INDEX_REG              0x10
 #define PHY_DATA_REG               0x11
 
-#define PHY_MPHY_CONTROL_REG       0x12	//#define TRU_VMI_MPHY_CONTROL_REGISTER           18
+#define PHY_MPHY_CONTROL_REG       0x12	/* #define TRU_VMI_MPHY_CONTROL_REGISTER           18 */
 
-#define PHY_LOOPBACK_CONTROL       0x13	//#define TRU_VMI_LOOPBACK_CONTROL_1_REGISTER     19
-					//#define TRU_VMI_LOOPBACK_CONTROL_2_REGISTER     20
-#define PHY_REGISTER_MGMT_CONTROL  0x15	//#define TRU_VMI_MI_SEQ_CONTROL_REGISTER         21
-#define PHY_CONFIG                 0x16	//#define TRU_VMI_CONFIGURATION_REGISTER          22
-#define PHY_PHY_CONTROL            0x17	//#define TRU_VMI_PHY_CONTROL_REGISTER            23
-#define PHY_INTERRUPT_MASK         0x18	//#define TRU_VMI_INTERRUPT_MASK_REGISTER         24
-#define PHY_INTERRUPT_STATUS       0x19	//#define TRU_VMI_INTERRUPT_STATUS_REGISTER       25
-#define PHY_PHY_STATUS             0x1A	//#define TRU_VMI_PHY_STATUS_REGISTER             26
-#define PHY_LED_1                  0x1B	//#define TRU_VMI_LED_CONTROL_1_REGISTER          27
-#define PHY_LED_2                  0x1C	//#define TRU_VMI_LED_CONTROL_2_REGISTER          28
-					//#define TRU_VMI_LINK_CONTROL_REGISTER           29
-					//#define TRU_VMI_TIMING_CONTROL_REGISTER
+#define PHY_LOOPBACK_CONTROL       0x13	/* #define TRU_VMI_LOOPBACK_CONTROL_1_REGISTER     19 */
+					/* #define TRU_VMI_LOOPBACK_CONTROL_2_REGISTER     20 */
+#define PHY_REGISTER_MGMT_CONTROL  0x15	/* #define TRU_VMI_MI_SEQ_CONTROL_REGISTER         21 */
+#define PHY_CONFIG                 0x16	/* #define TRU_VMI_CONFIGURATION_REGISTER          22 */
+#define PHY_PHY_CONTROL            0x17	/* #define TRU_VMI_PHY_CONTROL_REGISTER            23 */
+#define PHY_INTERRUPT_MASK         0x18	/* #define TRU_VMI_INTERRUPT_MASK_REGISTER         24 */
+#define PHY_INTERRUPT_STATUS       0x19	/* #define TRU_VMI_INTERRUPT_STATUS_REGISTER       25 */
+#define PHY_PHY_STATUS             0x1A	/* #define TRU_VMI_PHY_STATUS_REGISTER             26 */
+#define PHY_LED_1                  0x1B	/* #define TRU_VMI_LED_CONTROL_1_REGISTER          27 */
+#define PHY_LED_2                  0x1C	/* #define TRU_VMI_LED_CONTROL_2_REGISTER          28 */
+					/* #define TRU_VMI_LINK_CONTROL_REGISTER           29 */
+					/* #define TRU_VMI_TIMING_CONTROL_REGISTER */
 
 /* Prototypes for PHY access routines */
 void ET1310_PhyInit(struct et131x_adapter *adapter);
--- a/drivers/staging/et131x/et1310_pm.c
+++ b/drivers/staging/et131x/et1310_pm.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -73,9 +73,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -139,9 +139,8 @@ void EnablePhyComa(struct et131x_adapter
 	spin_unlock_irqrestore(&pAdapter->SendHWLock, lockflags);
 
 	/* Wait for outstanding Receive packets */
-	while ((MP_GET_RCV_REF(pAdapter) != 0) && (LoopCounter-- > 0)) {
+	while ((MP_GET_RCV_REF(pAdapter) != 0) && (LoopCounter-- > 0))
 		mdelay(2);
-	}
 
 	/* Gate off JAGCore 3 clock domains */
 	GlobalPmCSR.bits.pm_sysclk_gate = 0;
@@ -188,9 +187,9 @@ void DisablePhyComa(struct et131x_adapte
 	et131x_reset_recv(pAdapter);
 
 	/* Bring the device back to the state it was during init prior to
-         * autonegotiation being complete.  This way, when we get the auto-neg
-         * complete interrupt, we can complete init by calling ConfigMacREGS2.
-         */
+	 * autonegotiation being complete.  This way, when we get the auto-neg
+	 * complete interrupt, we can complete init by calling ConfigMacREGS2.
+	 */
 	et131x_soft_reset(pAdapter);
 
 	/* setup et1310 as per the documentation ?? */
--- a/drivers/staging/et131x/et1310_pm.h
+++ b/drivers/staging/et131x/et1310_pm.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -62,7 +62,7 @@
 #include "et1310_address_map.h"
 
 #define MAX_WOL_PACKET_SIZE    0x80
-#define MAX_WOL_MASK_SIZE      ( MAX_WOL_PACKET_SIZE / 8 )
+#define MAX_WOL_MASK_SIZE      (MAX_WOL_PACKET_SIZE / 8)
 #define NUM_WOL_PATTERNS       0x5
 #define CRC16_POLY             0x1021
 
--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -74,9 +74,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -120,7 +120,7 @@ int et131x_rx_dma_memory_alloc(struct et
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Setup some convenience pointers */
-	rx_ring = (RX_RING_t *) & adapter->RxRing;
+	rx_ring = (RX_RING_t *) &adapter->RxRing;
 
 	/* Alloc memory for the lookup table */
 #ifdef USE_FBR0
@@ -250,11 +250,10 @@ int et131x_rx_dma_memory_alloc(struct et
 		 * the size of FBR0.  By allocating N buffers at once, we
 		 * reduce this overhead.
 		 */
-		if (rx_ring->Fbr1BufferSize > 4096) {
+		if (rx_ring->Fbr1BufferSize > 4096)
 			Fbr1Align = 4096;
-		} else {
+		else
 			Fbr1Align = rx_ring->Fbr1BufferSize;
-		}
 
 		FBRChunkSize =
 		    (FBR_CHUNKS * rx_ring->Fbr1BufferSize) + Fbr1Align - 1;
@@ -443,7 +442,7 @@ void et131x_rx_dma_memory_free(struct et
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Setup some convenience pointers */
-	rx_ring = (RX_RING_t *) & adapter->RxRing;
+	rx_ring = (RX_RING_t *) &adapter->RxRing;
 
 	/* Free RFDs and associated packet descriptors */
 	DBG_ASSERT(rx_ring->nReadyRecv == rx_ring->NumRfd);
@@ -471,11 +470,10 @@ void et131x_rx_dma_memory_free(struct et
 			if (rx_ring->Fbr1MemVa[index]) {
 				uint32_t Fbr1Align;
 
-				if (rx_ring->Fbr1BufferSize > 4096) {
+				if (rx_ring->Fbr1BufferSize > 4096)
 					Fbr1Align = 4096;
-				} else {
+				else
 					Fbr1Align = rx_ring->Fbr1BufferSize;
-				}
 
 				bufsize =
 				    (rx_ring->Fbr1BufferSize * FBR_CHUNKS) +
@@ -491,8 +489,8 @@ void et131x_rx_dma_memory_free(struct et
 		}
 
 		/* Now the FIFO itself */
-		rx_ring->pFbr1RingVa = (void *)((uint8_t *) rx_ring->pFbr1RingVa -
-						rx_ring->Fbr1offset);
+		rx_ring->pFbr1RingVa = (void *)((uint8_t *)
+				rx_ring->pFbr1RingVa - rx_ring->Fbr1offset);
 
 		bufsize =
 		    (sizeof(FBR_DESC_t) * rx_ring->Fbr1NumEntries) + 0xfff;
@@ -525,8 +523,8 @@ void et131x_rx_dma_memory_free(struct et
 		}
 
 		/* Now the FIFO itself */
-		rx_ring->pFbr0RingVa = (void *)((uint8_t *) rx_ring->pFbr0RingVa -
-						rx_ring->Fbr0offset);
+		rx_ring->pFbr0RingVa = (void *)((uint8_t *)
+				rx_ring->pFbr0RingVa - rx_ring->Fbr0offset);
 
 		bufsize =
 		    (sizeof(FBR_DESC_t) * rx_ring->Fbr0NumEntries) + 0xfff;
@@ -556,12 +554,12 @@ void et131x_rx_dma_memory_free(struct et
 
 	/* Free area of memory for the writeback of status information */
 	if (rx_ring->pRxStatusVa) {
-		rx_ring->pRxStatusVa = (void *)((uint8_t *) rx_ring->pRxStatusVa -
-						rx_ring->RxStatusOffset);
+		rx_ring->pRxStatusVa = (void *)((uint8_t *)
+				rx_ring->pRxStatusVa - rx_ring->RxStatusOffset);
 
 		pci_free_consistent(adapter->pdev,
-				    sizeof(RX_STATUS_BLOCK_t) + 0x7,
-				    rx_ring->pRxStatusVa, rx_ring->pRxStatusPa);
+				sizeof(RX_STATUS_BLOCK_t) + 0x7,
+				rx_ring->pRxStatusVa, rx_ring->pRxStatusPa);
 
 		rx_ring->pRxStatusVa = NULL;
 	}
@@ -606,7 +604,7 @@ int et131x_init_recv(struct et131x_adapt
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Setup some convenience pointers */
-	rx_ring = (RX_RING_t *) & adapter->RxRing;
+	rx_ring = (RX_RING_t *) &adapter->RxRing;
 
 	/* Setup each RFD */
 	for (RfdCount = 0; RfdCount < rx_ring->NumRfd; RfdCount++) {
@@ -636,9 +634,8 @@ int et131x_init_recv(struct et131x_adapt
 		TotalNumRfd++;
 	}
 
-	if (TotalNumRfd > NIC_MIN_NUM_RFD) {
+	if (TotalNumRfd > NIC_MIN_NUM_RFD)
 		status = 0;
-	}
 
 	rx_ring->NumRfd = TotalNumRfd;
 
@@ -841,11 +838,10 @@ void et131x_rx_dma_disable(struct et131x
 	if (csr.bits.halt_status != 1) {
 		udelay(5);
 		csr.value = readl(&pAdapter->CSRAddress->rxdma.csr.value);
-		if (csr.bits.halt_status != 1) {
+		if (csr.bits.halt_status != 1)
 			DBG_ERROR(et131x_dbginfo,
-				  "RX Dma failed to enter halt state. CSR 0x%08x\n",
-				  csr.value);
-		}
+				"RX Dma failed to enter halt state. CSR 0x%08x\n",
+				csr.value);
 	}
 
 	DBG_LEAVE(et131x_dbginfo);
@@ -859,30 +855,28 @@ void et131x_rx_dma_enable(struct et131x_
 {
 	DBG_RX_ENTER(et131x_dbginfo);
 
-	if (pAdapter->RegistryPhyLoopbk) {
-	/* RxDMA is disabled for loopback operation. */
+	if (pAdapter->RegistryPhyLoopbk)
+		/* RxDMA is disabled for loopback operation. */
 		writel(0x1, &pAdapter->CSRAddress->rxdma.csr.value);
-	} else {
+	else {
 	/* Setup the receive dma configuration register for normal operation */
 		RXDMA_CSR_t csr = { 0 };
 
 		csr.bits.fbr1_enable = 1;
-		if (pAdapter->RxRing.Fbr1BufferSize == 4096) {
+		if (pAdapter->RxRing.Fbr1BufferSize == 4096)
 			csr.bits.fbr1_size = 1;
-		} else if (pAdapter->RxRing.Fbr1BufferSize == 8192) {
+		else if (pAdapter->RxRing.Fbr1BufferSize == 8192)
 			csr.bits.fbr1_size = 2;
-		} else if (pAdapter->RxRing.Fbr1BufferSize == 16384) {
+		else if (pAdapter->RxRing.Fbr1BufferSize == 16384)
 			csr.bits.fbr1_size = 3;
-		}
 #ifdef USE_FBR0
 		csr.bits.fbr0_enable = 1;
-		if (pAdapter->RxRing.Fbr0BufferSize == 256) {
+		if (pAdapter->RxRing.Fbr0BufferSize == 256)
 			csr.bits.fbr0_size = 1;
-		} else if (pAdapter->RxRing.Fbr0BufferSize == 512) {
+		else if (pAdapter->RxRing.Fbr0BufferSize == 512)
 			csr.bits.fbr0_size = 2;
-		} else if (pAdapter->RxRing.Fbr0BufferSize == 1024) {
+		else if (pAdapter->RxRing.Fbr0BufferSize == 1024)
 			csr.bits.fbr0_size = 3;
-		}
 #endif
 		writel(csr.value, &pAdapter->CSRAddress->rxdma.csr.value);
 
@@ -892,8 +886,8 @@ void et131x_rx_dma_enable(struct et131x_
 			csr.value = readl(&pAdapter->CSRAddress->rxdma.csr.value);
 			if (csr.bits.halt_status != 0) {
 				DBG_ERROR(et131x_dbginfo,
-					  "RX Dma failed to exit halt state.  CSR 0x%08x\n",
-					  csr.value);
+					"RX Dma failed to exit halt state.  CSR 0x%08x\n",
+					csr.value);
 			}
 		}
 	}
@@ -938,8 +932,8 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 
 	if (pRxStatusBlock->Word1.bits.PSRoffset ==
 			pRxLocal->local_psr_full.bits.psr_full &&
-	    pRxStatusBlock->Word1.bits.PSRwrap ==
-	    		pRxLocal->local_psr_full.bits.psr_full_wrap) {
+			pRxStatusBlock->Word1.bits.PSRwrap ==
+			pRxLocal->local_psr_full.bits.psr_full_wrap) {
 		/* Looks like this ring is not updated yet */
 		DBG_RX(et131x_dbginfo, "(0)\n");
 		DBG_RX_LEAVE(et131x_dbginfo);
@@ -999,13 +993,13 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 
 #ifdef USE_FBR0
 	if (ringIndex > 1 ||
-	    (ringIndex == 0 &&
-	     bufferIndex > pRxLocal->Fbr0NumEntries - 1) ||
-	    (ringIndex == 1 &&
-	     bufferIndex > pRxLocal->Fbr1NumEntries - 1))
+		(ringIndex == 0 &&
+		bufferIndex > pRxLocal->Fbr0NumEntries - 1) ||
+		(ringIndex == 1 &&
+		bufferIndex > pRxLocal->Fbr1NumEntries - 1))
 #else
 	if (ringIndex != 1 ||
-	    bufferIndex > pRxLocal->Fbr1NumEntries - 1)
+		bufferIndex > pRxLocal->Fbr1NumEntries - 1)
 #endif
 	{
 		/* Illegal buffer or ring index cannot be used by S/W*/
@@ -1124,30 +1118,27 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 				 * so we free our RFD when we return
 				 * from this function.
 				 */
-				if (nIndex == pAdapter->MCAddressCount) {
+				if (nIndex == pAdapter->MCAddressCount)
 					localLen = 0;
-				}
 			}
 
-			if (localLen > 0) {
+			if (localLen > 0)
 				pAdapter->Stats.multircv++;
-			}
-		} else if (Word0.value & ALCATEL_BROADCAST_PKT) {
+		} else if (Word0.value & ALCATEL_BROADCAST_PKT)
 			pAdapter->Stats.brdcstrcv++;
-		} else {
+		else
 			/* Not sure what this counter measures in
 			 * promiscuous mode. Perhaps we should check
 			 * the MAC address to see if it is directed
 			 * to us in promiscuous mode.
 			 */
 			pAdapter->Stats.unircv++;
-		}
 	}
 
 	if (localLen > 0) {
 		struct sk_buff *skb = NULL;
 
-		//pMpRfd->PacketSize = localLen - 4;
+		/* pMpRfd->PacketSize = localLen - 4; */
 		pMpRfd->PacketSize = localLen;
 
 		skb = dev_alloc_skb(pMpRfd->PacketSize + 2);
@@ -1240,9 +1231,8 @@ void et131x_handle_recv_interrupt(struct
 
 		pMpRfd = nic_rx_pkts(pAdapter);
 
-		if (pMpRfd == NULL) {
+		if (pMpRfd == NULL)
 			break;
-		}
 
 		/* Do not receive any packets until a filter has been set.
 		 * Do not receive any packets until we are at D0.
@@ -1270,12 +1260,13 @@ void et131x_handle_recv_interrupt(struct
 			 * Besides, we don't really need (at this point) the
 			 * pending list anyway.
 			 */
-			//spin_lock_irqsave( &pAdapter->RcvPendLock, lockflags );
-			//list_add_tail( &pMpRfd->list_node, &pAdapter->RxRing.RecvPendingList );
-			//spin_unlock_irqrestore( &pAdapter->RcvPendLock, lockflags );
+			/* spin_lock_irqsave( &pAdapter->RcvPendLock, lockflags );
+			 * list_add_tail( &pMpRfd->list_node, &pAdapter->RxRing.RecvPendingList );
+			 * spin_unlock_irqrestore( &pAdapter->RcvPendLock, lockflags );
+			 */
 
 			/* Update the number of outstanding Recvs */
-			//MP_INC_RCV_REF( pAdapter );
+			/* MP_INC_RCV_REF( pAdapter ); */
 		} else {
 			RFDFreeArray[PacketFreeCount] = pMpRfd;
 			PacketFreeCount++;
--- a/drivers/staging/et131x/et1310_rx.h
+++ b/drivers/staging/et131x/et1310_rx.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -64,10 +64,10 @@
 #define USE_FBR0 true
 
 #ifdef USE_FBR0
-//#define FBR0_BUFFER_SIZE 256
+/* #define FBR0_BUFFER_SIZE 256 */
 #endif
 
-//#define FBR1_BUFFER_SIZE 2048
+/* #define FBR1_BUFFER_SIZE 2048 */
 
 #define FBR_CHUNKS 32
 
@@ -95,11 +95,11 @@ typedef union _FBR_WORD2_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 reserved:22;	// bits 10-31
-		u32 bi:10;		// bits 0-9(Buffer Index)
+		u32 reserved:22;	/* bits 10-31 */
+		u32 bi:10;		/* bits 0-9(Buffer Index) */
 #else
-		u32 bi:10;		// bits 0-9(Buffer Index)
-		u32 reserved:22;	// bit 10-31
+		u32 bi:10;		/* bits 0-9(Buffer Index) */
+		u32 reserved:22;	/* bit 10-31 */
 #endif
 	} bits;
 } FBR_WORD2_t, *PFBR_WORD2_t;
@@ -115,70 +115,70 @@ typedef union _PKT_STAT_DESC_WORD0_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		// top 16 bits are from the Alcatel Status Word as enumerated in
-		// PE-MCXMAC Data Sheet IPD DS54 0210-1 (also IPD-DS80 0205-2)
+		/* top 16 bits are from the Alcatel Status Word as enumerated in */
+		/* PE-MCXMAC Data Sheet IPD DS54 0210-1 (also IPD-DS80 0205-2) */
 #if 0
-		u32 asw_trunc:1;		// bit 31(Rx frame truncated)
+		u32 asw_trunc:1;		/* bit 31(Rx frame truncated) */
 #endif
-		u32 asw_long_evt:1;	// bit 31(Rx long event)
-		u32 asw_VLAN_tag:1;	// bit 30(VLAN tag detected)
-		u32 asw_unsupported_op:1;	// bit 29(unsupported OP code)
-		u32 asw_pause_frame:1;	// bit 28(is a pause frame)
-		u32 asw_control_frame:1;	// bit 27(is a control frame)
-		u32 asw_dribble_nibble:1;	// bit 26(spurious bits after EOP)
-		u32 asw_broadcast:1;	// bit 25(has a broadcast address)
-		u32 asw_multicast:1;	// bit 24(has a multicast address)
-		u32 asw_OK:1;		// bit 23(valid CRC + no code error)
-		u32 asw_too_long:1;	// bit 22(frame length > 1518 bytes)
-		u32 asw_len_chk_err:1;	// bit 21(frame length field incorrect)
-		u32 asw_CRC_err:1;		// bit 20(CRC error)
-		u32 asw_code_err:1;	// bit 19(one or more nibbles signalled as errors)
-		u32 asw_false_carrier_event:1;	// bit 18(bad carrier since last good packet)
-		u32 asw_RX_DV_event:1;	// bit 17(short receive event detected)
-		u32 asw_prev_pkt_dropped:1;// bit 16(e.g. IFG too small on previous)
-		u32 unused:5;		// bits 11-15
-		u32 vp:1;			// bit 10(VLAN Packet)
-		u32 jp:1;			// bit 9(Jumbo Packet)
-		u32 ft:1;			// bit 8(Frame Truncated)
-		u32 drop:1;		// bit 7(Drop packet)
-		u32 rxmac_error:1;		// bit 6(RXMAC Error Indicator)
-		u32 wol:1;			// bit 5(WOL Event)
-		u32 tcpp:1;		// bit 4(TCP checksum pass)
-		u32 tcpa:1;		// bit 3(TCP checksum assist)
-		u32 ipp:1;			// bit 2(IP checksum pass)
-		u32 ipa:1;			// bit 1(IP checksum assist)
-		u32 hp:1;			// bit 0(hash pass)
+		u32 asw_long_evt:1;	/* bit 31(Rx long event) */
+		u32 asw_VLAN_tag:1;	/* bit 30(VLAN tag detected) */
+		u32 asw_unsupported_op:1;	/* bit 29(unsupported OP code) */
+		u32 asw_pause_frame:1;	/* bit 28(is a pause frame) */
+		u32 asw_control_frame:1;	/* bit 27(is a control frame) */
+		u32 asw_dribble_nibble:1;	/* bit 26(spurious bits after EOP) */
+		u32 asw_broadcast:1;	/* bit 25(has a broadcast address) */
+		u32 asw_multicast:1;	/* bit 24(has a multicast address) */
+		u32 asw_OK:1;		/* bit 23(valid CRC + no code error) */
+		u32 asw_too_long:1;	/* bit 22(frame length > 1518 bytes) */
+		u32 asw_len_chk_err:1;	/* bit 21(frame length field incorrect) */
+		u32 asw_CRC_err:1;		/* bit 20(CRC error) */
+		u32 asw_code_err:1;	/* bit 19(one or more nibbles signalled as errors) */
+		u32 asw_false_carrier_event:1;	/* bit 18(bad carrier since last good packet) */
+		u32 asw_RX_DV_event:1;	/* bit 17(short receive event detected) */
+		u32 asw_prev_pkt_dropped:1;/* bit 16(e.g. IFG too small on previous) */
+		u32 unused:5;		/* bits 11-15 */
+		u32 vp:1;			/* bit 10(VLAN Packet) */
+		u32 jp:1;			/* bit 9(Jumbo Packet) */
+		u32 ft:1;			/* bit 8(Frame Truncated) */
+		u32 drop:1;		/* bit 7(Drop packet) */
+		u32 rxmac_error:1;		/* bit 6(RXMAC Error Indicator) */
+		u32 wol:1;			/* bit 5(WOL Event) */
+		u32 tcpp:1;		/* bit 4(TCP checksum pass) */
+		u32 tcpa:1;		/* bit 3(TCP checksum assist) */
+		u32 ipp:1;			/* bit 2(IP checksum pass) */
+		u32 ipa:1;			/* bit 1(IP checksum assist) */
+		u32 hp:1;			/* bit 0(hash pass) */
 #else
-		u32 hp:1;			// bit 0(hash pass)
-		u32 ipa:1;			// bit 1(IP checksum assist)
-		u32 ipp:1;			// bit 2(IP checksum pass)
-		u32 tcpa:1;		// bit 3(TCP checksum assist)
-		u32 tcpp:1;		// bit 4(TCP checksum pass)
-		u32 wol:1;			// bit 5(WOL Event)
-		u32 rxmac_error:1;		// bit 6(RXMAC Error Indicator)
-		u32 drop:1;		// bit 7(Drop packet)
-		u32 ft:1;			// bit 8(Frame Truncated)
-		u32 jp:1;			// bit 9(Jumbo Packet)
-		u32 vp:1;			// bit 10(VLAN Packet)
-		u32 unused:5;		// bits 11-15
-		u32 asw_prev_pkt_dropped:1;// bit 16(e.g. IFG too small on previous)
-		u32 asw_RX_DV_event:1;	// bit 17(short receive event detected)
-		u32 asw_false_carrier_event:1;	// bit 18(bad carrier since last good packet)
-		u32 asw_code_err:1;	// bit 19(one or more nibbles signalled as errors)
-		u32 asw_CRC_err:1;		// bit 20(CRC error)
-		u32 asw_len_chk_err:1;	// bit 21(frame length field incorrect)
-		u32 asw_too_long:1;	// bit 22(frame length > 1518 bytes)
-		u32 asw_OK:1;		// bit 23(valid CRC + no code error)
-		u32 asw_multicast:1;	// bit 24(has a multicast address)
-		u32 asw_broadcast:1;	// bit 25(has a broadcast address)
-		u32 asw_dribble_nibble:1;	// bit 26(spurious bits after EOP)
-		u32 asw_control_frame:1;	// bit 27(is a control frame)
-		u32 asw_pause_frame:1;	// bit 28(is a pause frame)
-		u32 asw_unsupported_op:1;	// bit 29(unsupported OP code)
-		u32 asw_VLAN_tag:1;	// bit 30(VLAN tag detected)
-		u32 asw_long_evt:1;	// bit 31(Rx long event)
+		u32 hp:1;			/* bit 0(hash pass) */
+		u32 ipa:1;			/* bit 1(IP checksum assist) */
+		u32 ipp:1;			/* bit 2(IP checksum pass) */
+		u32 tcpa:1;		/* bit 3(TCP checksum assist) */
+		u32 tcpp:1;		/* bit 4(TCP checksum pass) */
+		u32 wol:1;			/* bit 5(WOL Event) */
+		u32 rxmac_error:1;		/* bit 6(RXMAC Error Indicator) */
+		u32 drop:1;		/* bit 7(Drop packet) */
+		u32 ft:1;			/* bit 8(Frame Truncated) */
+		u32 jp:1;			/* bit 9(Jumbo Packet) */
+		u32 vp:1;			/* bit 10(VLAN Packet) */
+		u32 unused:5;		/* bits 11-15 */
+		u32 asw_prev_pkt_dropped:1;/* bit 16(e.g. IFG too small on previous) */
+		u32 asw_RX_DV_event:1;	/* bit 17(short receive event detected) */
+		u32 asw_false_carrier_event:1;	/* bit 18(bad carrier since last good packet) */
+		u32 asw_code_err:1;	/* bit 19(one or more nibbles signalled as errors) */
+		u32 asw_CRC_err:1;		/* bit 20(CRC error) */
+		u32 asw_len_chk_err:1;	/* bit 21(frame length field incorrect) */
+		u32 asw_too_long:1;	/* bit 22(frame length > 1518 bytes) */
+		u32 asw_OK:1;		/* bit 23(valid CRC + no code error) */
+		u32 asw_multicast:1;	/* bit 24(has a multicast address) */
+		u32 asw_broadcast:1;	/* bit 25(has a broadcast address) */
+		u32 asw_dribble_nibble:1;	/* bit 26(spurious bits after EOP) */
+		u32 asw_control_frame:1;	/* bit 27(is a control frame) */
+		u32 asw_pause_frame:1;	/* bit 28(is a pause frame) */
+		u32 asw_unsupported_op:1;	/* bit 29(unsupported OP code) */
+		u32 asw_VLAN_tag:1;	/* bit 30(VLAN tag detected) */
+		u32 asw_long_evt:1;	/* bit 31(Rx long event) */
 #if 0
-		u32 asw_trunc:1;		// bit 31(Rx frame truncated)
+		u32 asw_trunc:1;		/* bit 31(Rx frame truncated) */
 #endif
 #endif
 	} bits;
@@ -188,15 +188,15 @@ typedef union _PKT_STAT_DESC_WORD1_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:4;	// bits 28-31
-		u32 ri:2;		// bits 26-27(Ring Index)
-		u32 bi:10;		// bits 16-25(Buffer Index)
-		u32 length:16;	// bit 0-15(length in bytes)
+		u32 unused:4;	/* bits 28-31 */
+		u32 ri:2;		/* bits 26-27(Ring Index) */
+		u32 bi:10;		/* bits 16-25(Buffer Index) */
+		u32 length:16;	/* bit 0-15(length in bytes) */
 #else
-		u32 length:16;	// bit 0-15(length in bytes)
-		u32 bi:10;		// bits 16-25(Buffer Index)
-		u32 ri:2;		// bits 26-27(Ring Index)
-		u32 unused:4;	// bits 28-31
+		u32 length:16;	/* bit 0-15(length in bytes) */
+		u32 bi:10;		/* bits 16-25(Buffer Index) */
+		u32 ri:2;		/* bits 26-27(Ring Index) */
+		u32 unused:4;	/* bits 28-31 */
 #endif
 	} bits;
 } PKT_STAT_DESC_WORD1_t, *PPKT_STAT_WORD1_t;
@@ -217,19 +217,19 @@ typedef union _rxstat_word0_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 FBR1unused:5;	// bits 27-31
-		u32 FBR1wrap:1;	// bit 26
-		u32 FBR1offset:10;	// bits 16-25
-		u32 FBR0unused:5;	// bits 11-15
-		u32 FBR0wrap:1;	// bit 10
-		u32 FBR0offset:10;	// bits 0-9
+		u32 FBR1unused:5;	/* bits 27-31 */
+		u32 FBR1wrap:1;	/* bit 26 */
+		u32 FBR1offset:10;	/* bits 16-25 */
+		u32 FBR0unused:5;	/* bits 11-15 */
+		u32 FBR0wrap:1;	/* bit 10 */
+		u32 FBR0offset:10;	/* bits 0-9 */
 #else
-		u32 FBR0offset:10;	// bits 0-9
-		u32 FBR0wrap:1;	// bit 10
-		u32 FBR0unused:5;	// bits 11-15
-		u32 FBR1offset:10;	// bits 16-25
-		u32 FBR1wrap:1;	// bit 26
-		u32 FBR1unused:5;	// bits 27-31
+		u32 FBR0offset:10;	/* bits 0-9 */
+		u32 FBR0wrap:1;	/* bit 10 */
+		u32 FBR0unused:5;	/* bits 11-15 */
+		u32 FBR1offset:10;	/* bits 16-25 */
+		u32 FBR1wrap:1;	/* bit 26 */
+		u32 FBR1unused:5;	/* bits 27-31 */
 #endif
 	} bits;
 } RXSTAT_WORD0_t, *PRXSTAT_WORD0_t;
@@ -243,15 +243,15 @@ typedef union _rxstat_word1_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 PSRunused:3;	// bits 29-31
-		u32 PSRwrap:1;	// bit 28
-		u32 PSRoffset:12;	// bits 16-27
-		u32 reserved:16;	// bits 0-15
+		u32 PSRunused:3;	/* bits 29-31 */
+		u32 PSRwrap:1;	/* bit 28 */
+		u32 PSRoffset:12;	/* bits 16-27 */
+		u32 reserved:16;	/* bits 0-15 */
 #else
-		u32 reserved:16;	// bits 0-15
-		u32 PSRoffset:12;	// bits 16-27
-		u32 PSRwrap:1;	// bit 28
-		u32 PSRunused:3;	// bits 29-31
+		u32 reserved:16;	/* bits 0-15 */
+		u32 PSRoffset:12;	/* bits 16-27 */
+		u32 PSRwrap:1;	/* bit 28 */
+		u32 PSRunused:3;	/* bits 29-31 */
 #endif
 	} bits;
 } RXSTAT_WORD1_t, *PRXSTAT_WORD1_t;
--- a/drivers/staging/et131x/et1310_tx.c
+++ b/drivers/staging/et131x/et1310_tx.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -74,9 +74,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -127,7 +127,7 @@ int et131x_tx_dma_memory_alloc(struct et
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Allocate memory for the TCB's (Transmit Control Block) */
-	adapter->TxRing.MpTcbMem = (MP_TCB *) kcalloc(NUM_TCB, sizeof(MP_TCB),
+	adapter->TxRing.MpTcbMem = (MP_TCB *)kcalloc(NUM_TCB, sizeof(MP_TCB),
 						      GFP_ATOMIC | GFP_DMA);
 	if (!adapter->TxRing.MpTcbMem) {
 		DBG_ERROR(et131x_dbginfo, "Cannot alloc memory for TCBs\n");
@@ -238,10 +238,7 @@ void et131x_tx_dma_memory_free(struct et
 	}
 
 	/* Free the memory for MP_TCB structures */
-	if (adapter->TxRing.MpTcbMem) {
-		kfree(adapter->TxRing.MpTcbMem);
-		adapter->TxRing.MpTcbMem = NULL;
-	}
+	kfree(adapter->TxRing.MpTcbMem);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
@@ -308,7 +305,7 @@ void et131x_tx_dma_enable(struct et131x_
 	DBG_ENTER(et131x_dbginfo);
 
 	if (pAdapter->RegistryPhyLoopbk) {
-	/* TxDMA is disabled for loopback operation. */
+		/* TxDMA is disabled for loopback operation. */
 		writel(0x101, &pAdapter->CSRAddress->txdma.csr.value);
 	} else {
 		TXDMA_CSR_t csr = { 0 };
@@ -405,11 +402,14 @@ int et131x_send_packets(struct sk_buff *
 		/* We need to see if the link is up; if it's not, make the
 		 * netif layer think we're good and drop the packet
 		 */
-		//if( MP_SHOULD_FAIL_SEND( pAdapter ) || pAdapter->DriverNoPhyAccess )
+		/*
+		 * if( MP_SHOULD_FAIL_SEND( pAdapter ) ||
+		 *  pAdapter->DriverNoPhyAccess )
+		 */
 		if (MP_SHOULD_FAIL_SEND(pAdapter) || pAdapter->DriverNoPhyAccess
 		    || !netif_carrier_ok(netdev)) {
 			DBG_VERBOSE(et131x_dbginfo,
-				    "Can't Tx, Link is DOWN; drop the packet\n");
+				"Can't Tx, Link is DOWN; drop the packet\n");
 
 			dev_kfree_skb_any(skb);
 			skb = NULL;
@@ -496,9 +496,8 @@ static int et131x_send_packet(struct sk_
 
 	pAdapter->TxRing.TCBReadyQueueHead = pMpTcb->Next;
 
-	if (pAdapter->TxRing.TCBReadyQueueHead == NULL) {
+	if (pAdapter->TxRing.TCBReadyQueueHead == NULL)
 		pAdapter->TxRing.TCBReadyQueueTail = NULL;
-	}
 
 	spin_unlock_irqrestore(&pAdapter->TCBReadyQLock, lockflags);
 
@@ -519,9 +518,8 @@ static int et131x_send_packet(struct sk_
 	pMpTcb->Next = NULL;
 
 	/* Call the NIC specific send handler. */
-	if (status == 0) {
+	if (status == 0)
 		status = nic_send_packet(pAdapter, pMpTcb);
-	}
 
 	if (status != 0) {
 		spin_lock_irqsave(&pAdapter->TCBReadyQLock, lockflags);
@@ -749,11 +747,10 @@ static int nic_send_packet(struct et131x
 	if ((pAdapter->TxRing.txDmaReadyToSend.bits.val == 0) ||
 	    (pAdapter->TxRing.txDmaReadyToSend.bits.val ==
 	     NUM_DESC_PER_RING_TX)) {
-		if (pAdapter->TxRing.txDmaReadyToSend.bits.wrap) {
+		if (pAdapter->TxRing.txDmaReadyToSend.bits.wrap)
 			pAdapter->TxRing.txDmaReadyToSend.value = 0;
-		} else {
+		else
 			pAdapter->TxRing.txDmaReadyToSend.value = 0x400;
-		}
 	}
 
 	if (iRemainder) {
@@ -765,24 +762,21 @@ static int nic_send_packet(struct et131x
 	}
 
 	if (pAdapter->TxRing.txDmaReadyToSend.bits.val == 0) {
-		if (pAdapter->TxRing.txDmaReadyToSend.value) {
+		if (pAdapter->TxRing.txDmaReadyToSend.value)
 			pMpTcb->WrIndex.value = NUM_DESC_PER_RING_TX - 1;
-		} else {
+		else
 			pMpTcb->WrIndex.value =
 			    0x400 | (NUM_DESC_PER_RING_TX - 1);
-		}
-	} else {
+	} else
 		pMpTcb->WrIndex.value =
 		    pAdapter->TxRing.txDmaReadyToSend.value - 1;
-	}
 
 	spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags2);
 
-	if (pAdapter->TxRing.CurrSendTail) {
+	if (pAdapter->TxRing.CurrSendTail)
 		pAdapter->TxRing.CurrSendTail->Next = pMpTcb;
-	} else {
+	else
 		pAdapter->TxRing.CurrSendHead = pMpTcb;
-	}
 
 	pAdapter->TxRing.CurrSendTail = pMpTcb;
 
@@ -870,14 +864,14 @@ static int nic_send_packet(struct et131x
 			DBG_TX(et131x_dbginfo,
 			       "Even number of descs, split 1st elem\n");
 			iSplitFirstElement = 1;
-			//SegmentSize = pFragList[0].size / 2;
+			/* SegmentSize = pFragList[0].size / 2; */
 			SegmentSize = (pPacket->len - pPacket->data_len) / 2;
 		}
 	} else if (FragListCount & 0x1) {
 		DBG_TX(et131x_dbginfo, "Odd number of descs, split 1st elem\n");
 
 		iSplitFirstElement = 1;
-		//SegmentSize = pFragList[0].size / 2;
+		/* SegmentSize = pFragList[0].size / 2; */
 		SegmentSize = (pPacket->len - pPacket->data_len) / 2;
 	}
 
@@ -918,9 +912,8 @@ static int nic_send_packet(struct et131x
 	       FragListCount, iSplitFirstElement, loopEnd);
 
 	for (loopIndex = 0; loopIndex < loopEnd; loopIndex++) {
-		if (loopIndex > iSplitFirstElement) {
+		if (loopIndex > iSplitFirstElement)
 			fragIndex++;
-		}
 
 		DBG_TX(et131x_dbginfo,
 		       "In loop, loopIndex: %d\t fragIndex: %d\n", loopIndex,
@@ -935,13 +928,17 @@ static int nic_send_packet(struct et131x
 		       pPacket->len,
 		       pAdapter->TxRing.txDmaReadyToSend.bits.serv_req);
 
-		// NOTE - Should we do a paranoia check here to make sure the fragment
-		// actually has a length? It's HIGHLY unlikely the fragment would
-		// contain no data...
+		/*
+		 * NOTE - Should we do a paranoia check here to make sure the fragment
+		 * actually has a length? It's HIGHLY unlikely the fragment would
+		 * contain no data...
+		 */
 		if (1) {
-			// NOTE - Currently always getting 32-bit addrs, and dma_addr_t is
-			//        only 32-bit, so leave "high" ptr value out for now
-			CurDesc.DataBufferPtrHigh = 0;
+			/* NOTE - Currently always getting 32-bit addrs, and
+			 * dma_addr_t is only 32-bit, so leave "high" ptr
+			 * value out for now
+			 * CurDesc.DataBufferPtrHigh = 0;
+			 */
 
 			CurDesc.word2.value = 0;
 			CurDesc.word3.value = 0;
@@ -1128,7 +1125,7 @@ static int nic_send_packet(struct et131x
 
 	if (pAdapter->uiDuplexMode == 0 &&
 	    pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE) {
-		// NOTE - Same 32/64-bit issue as above...
+		/* NOTE - Same 32/64-bit issue as above... */
 		CurDesc.DataBufferPtrHigh = 0x0;
 		CurDesc.DataBufferPtrLow = pAdapter->TxRing.pTxDummyBlkPa;
 		CurDesc.word2.value = 0;
@@ -1183,18 +1180,17 @@ static int nic_send_packet(struct et131x
 		}
 
 		DBG_TX(et131x_dbginfo, "Padding descriptor %d by %d bytes\n",
-		       //pAdapter->TxRing.txDmaReadyToSend.value,
+		       /* pAdapter->TxRing.txDmaReadyToSend.value, */
 		       pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
 		       NIC_MIN_PACKET_SIZE - pMpTcb->PacketLength);
 	}
 
 	spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags2);
 
-	if (pAdapter->TxRing.CurrSendTail) {
+	if (pAdapter->TxRing.CurrSendTail)
 		pAdapter->TxRing.CurrSendTail->Next = pMpTcb;
-	} else {
+	else
 		pAdapter->TxRing.CurrSendHead = pMpTcb;
-	}
 
 	pAdapter->TxRing.CurrSendTail = pMpTcb;
 
@@ -1235,19 +1231,19 @@ static int nic_send_packet(struct et131x
  *
  * Assumption - Send spinlock has been acquired
  */
-__inline void et131x_free_send_packet(struct et131x_adapter *pAdapter, PMP_TCB pMpTcb)
+inline void et131x_free_send_packet(struct et131x_adapter *pAdapter,
+							PMP_TCB pMpTcb)
 {
 	unsigned long lockflags;
 	TX_DESC_ENTRY_t *desc = NULL;
 	struct net_device_stats *stats = &pAdapter->net_stats;
 
-	if (MP_TEST_FLAG(pMpTcb, fMP_DEST_BROAD)) {
+	if (MP_TEST_FLAG(pMpTcb, fMP_DEST_BROAD))
 		atomic_inc(&pAdapter->Stats.brdcstxmt);
-	} else if (MP_TEST_FLAG(pMpTcb, fMP_DEST_MULTI)) {
+	else if (MP_TEST_FLAG(pMpTcb, fMP_DEST_MULTI))
 		atomic_inc(&pAdapter->Stats.multixmt);
-	} else {
+	else
 		atomic_inc(&pAdapter->Stats.unixmt);
-	}
 
 	if (pMpTcb->Packet) {
 		stats->tx_bytes += pMpTcb->Packet->len;
@@ -1298,14 +1294,12 @@ __inline void et131x_free_send_packet(st
 
 			if (++pMpTcb->WrIndexStart.bits.val >=
 			    NUM_DESC_PER_RING_TX) {
-				if (pMpTcb->WrIndexStart.bits.wrap) {
+				if (pMpTcb->WrIndexStart.bits.wrap)
 					pMpTcb->WrIndexStart.value = 0;
-				} else {
+				else
 					pMpTcb->WrIndexStart.value = 0x400;
-				}
 			}
-		}
-		while (desc != (pAdapter->TxRing.pTxDescRingVa +
+		} while (desc != (pAdapter->TxRing.pTxDescRingVa +
 				pMpTcb->WrIndex.bits.val));
 
 		DBG_TX(et131x_dbginfo,
@@ -1371,9 +1365,8 @@ void et131x_free_busy_send_packets(struc
 
 		pAdapter->TxRing.CurrSendHead = pNext;
 
-		if (pNext == NULL) {
+		if (pNext == NULL)
 			pAdapter->TxRing.CurrSendTail = NULL;
-		}
 
 		pAdapter->TxRing.nBusySend--;
 
@@ -1391,7 +1384,7 @@ void et131x_free_busy_send_packets(struc
 
 	if (FreeCounter == NUM_TCB) {
 		DBG_ERROR(et131x_dbginfo,
-			  "MpFreeBusySendPackets exitted loop for a bad reason\n");
+		    "MpFreeBusySendPackets exitted loop for a bad reason\n");
 		BUG();
 	}
 
@@ -1454,9 +1447,8 @@ static void et131x_update_tcb_list(struc
 	       ServiceComplete.bits.val < pMpTcb->WrIndex.bits.val) {
 		pAdapter->TxRing.nBusySend--;
 		pAdapter->TxRing.CurrSendHead = pMpTcb->Next;
-		if (pMpTcb->Next == NULL) {
+		if (pMpTcb->Next == NULL)
 			pAdapter->TxRing.CurrSendTail = NULL;
-		}
 
 		spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
 		MP_FREE_SEND_PACKET_FUN(pAdapter, pMpTcb);
@@ -1470,9 +1462,8 @@ static void et131x_update_tcb_list(struc
 	       ServiceComplete.bits.val > pMpTcb->WrIndex.bits.val) {
 		pAdapter->TxRing.nBusySend--;
 		pAdapter->TxRing.CurrSendHead = pMpTcb->Next;
-		if (pMpTcb->Next == NULL) {
+		if (pMpTcb->Next == NULL)
 			pAdapter->TxRing.CurrSendTail = NULL;
-		}
 
 		spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
 		MP_FREE_SEND_PACKET_FUN(pAdapter, pMpTcb);
@@ -1483,9 +1474,8 @@ static void et131x_update_tcb_list(struc
 	}
 
 	/* Wake up the queue when we hit a low-water mark */
-	if (pAdapter->TxRing.nBusySend <= (NUM_TCB / 3)) {
+	if (pAdapter->TxRing.nBusySend <= (NUM_TCB / 3))
 		netif_wake_queue(pAdapter->netdev);
-	}
 
 	spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
 }
@@ -1504,7 +1494,7 @@ static void et131x_check_send_wait_list(
 	spin_lock_irqsave(&pAdapter->SendWaitLock, lockflags);
 
 	while (!list_empty(&pAdapter->TxRing.SendWaitQueue) &&
-	       MP_TCB_RESOURCES_AVAILABLE(pAdapter)) {
+				MP_TCB_RESOURCES_AVAILABLE(pAdapter)) {
 		struct list_head *pEntry;
 
 		DBG_VERBOSE(et131x_dbginfo, "Tx packets on the wait queue\n");
@@ -1514,8 +1504,8 @@ static void et131x_check_send_wait_list(
 		pAdapter->TxRing.nWaitSend--;
 
 		DBG_WARNING(et131x_dbginfo,
-			    "MpHandleSendInterrupt - sent a queued pkt. Waiting %d\n",
-			    pAdapter->TxRing.nWaitSend);
+		    "MpHandleSendInterrupt - sent a queued pkt. Waiting %d\n",
+				pAdapter->TxRing.nWaitSend);
 	}
 
 	spin_unlock_irqrestore(&pAdapter->SendWaitLock, lockflags);
--- a/drivers/staging/et131x/et1310_tx.h
+++ b/drivers/staging/et131x/et1310_tx.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -70,15 +70,15 @@ typedef union _txdesc_word2_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 vlan_prio:3;		// bits 29-31(VLAN priority)
-		u32 vlan_cfi:1;		// bit 28(cfi)
-		u32 vlan_tag:12;		// bits 16-27(VLAN tag)
-		u32 length_in_bytes:16;	// bits  0-15(packet length)
+		u32 vlan_prio:3;		/* bits 29-31(VLAN priority) */
+		u32 vlan_cfi:1;		/* bit 28(cfi) */
+		u32 vlan_tag:12;		/* bits 16-27(VLAN tag) */
+		u32 length_in_bytes:16;	/* bits  0-15(packet length) */
 #else
-		u32 length_in_bytes:16;	// bits  0-15(packet length)
-		u32 vlan_tag:12;		// bits 16-27(VLAN tag)
-		u32 vlan_cfi:1;		// bit 28(cfi)
-		u32 vlan_prio:3;		// bits 29-31(VLAN priority)
+		u32 length_in_bytes:16;	/* bits  0-15(packet length) */
+		u32 vlan_tag:12;		/* bits 16-27(VLAN tag) */
+		u32 vlan_cfi:1;		/* bit 28(cfi) */
+		u32 vlan_prio:3;		/* bits 29-31(VLAN priority) */
 #endif	/* _BIT_FIELDS_HTOL */
 	} bits;
 } TXDESC_WORD2_t, *PTXDESC_WORD2_t;
@@ -91,39 +91,39 @@ typedef union _txdesc_word3_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:17;	// bits 15-31
-		u32 udpa:1;	// bit 14(UDP checksum assist)
-		u32 tcpa:1;	// bit 13(TCP checksum assist)
-		u32 ipa:1;		// bit 12(IP checksum assist)
-		u32 vlan:1;	// bit 11(append VLAN tag)
-		u32 hp:1;		// bit 10(Packet is a Huge packet)
-		u32 pp:1;		// bit  9(pad packet)
-		u32 mac:1;		// bit  8(MAC override)
-		u32 crc:1;		// bit  7(append CRC)
-		u32 e:1;		// bit  6(Tx frame has error)
-		u32 pf:1;		// bit  5(send pause frame)
-		u32 bp:1;		// bit  4(Issue half-duplex backpressure (XON/XOFF)
-		u32 cw:1;		// bit  3(Control word - no packet data)
-		u32 ir:1;		// bit  2(interrupt the processor when this pkt sent)
-		u32 f:1;		// bit  1(first packet in the sequence)
-		u32 l:1;		// bit  0(last packet in the sequence)
+		u32 unused:17;	/* bits 15-31 */
+		u32 udpa:1;	/* bit 14(UDP checksum assist) */
+		u32 tcpa:1;	/* bit 13(TCP checksum assist) */
+		u32 ipa:1;		/* bit 12(IP checksum assist) */
+		u32 vlan:1;	/* bit 11(append VLAN tag) */
+		u32 hp:1;		/* bit 10(Packet is a Huge packet) */
+		u32 pp:1;		/* bit  9(pad packet) */
+		u32 mac:1;		/* bit  8(MAC override) */
+		u32 crc:1;		/* bit  7(append CRC) */
+		u32 e:1;		/* bit  6(Tx frame has error) */
+		u32 pf:1;		/* bit  5(send pause frame) */
+		u32 bp:1;		/* bit  4(Issue half-duplex backpressure (XON/XOFF) */
+		u32 cw:1;		/* bit  3(Control word - no packet data) */
+		u32 ir:1;		/* bit  2(interrupt the processor when this pkt sent) */
+		u32 f:1;		/* bit  1(first packet in the sequence) */
+		u32 l:1;		/* bit  0(last packet in the sequence) */
 #else
-		u32 l:1;		// bit  0(last packet in the sequence)
-		u32 f:1;		// bit  1(first packet in the sequence)
-		u32 ir:1;		// bit  2(interrupt the processor when this pkt sent)
-		u32 cw:1;		// bit  3(Control word - no packet data)
-		u32 bp:1;		// bit  4(Issue half-duplex backpressure (XON/XOFF)
-		u32 pf:1;		// bit  5(send pause frame)
-		u32 e:1;		// bit  6(Tx frame has error)
-		u32 crc:1;		// bit  7(append CRC)
-		u32 mac:1;		// bit  8(MAC override)
-		u32 pp:1;		// bit  9(pad packet)
-		u32 hp:1;		// bit 10(Packet is a Huge packet)
-		u32 vlan:1;	// bit 11(append VLAN tag)
-		u32 ipa:1;		// bit 12(IP checksum assist)
-		u32 tcpa:1;	// bit 13(TCP checksum assist)
-		u32 udpa:1;	// bit 14(UDP checksum assist)
-		u32 unused:17;	// bits 15-31
+		u32 l:1;		/* bit  0(last packet in the sequence) */
+		u32 f:1;		/* bit  1(first packet in the sequence) */
+		u32 ir:1;		/* bit  2(interrupt the processor when this pkt sent) */
+		u32 cw:1;		/* bit  3(Control word - no packet data) */
+		u32 bp:1;		/* bit  4(Issue half-duplex backpressure (XON/XOFF) */
+		u32 pf:1;		/* bit  5(send pause frame) */
+		u32 e:1;		/* bit  6(Tx frame has error) */
+		u32 crc:1;		/* bit  7(append CRC) */
+		u32 mac:1;		/* bit  8(MAC override) */
+		u32 pp:1;		/* bit  9(pad packet) */
+		u32 hp:1;		/* bit 10(Packet is a Huge packet) */
+		u32 vlan:1;	/* bit 11(append VLAN tag) */
+		u32 ipa:1;		/* bit 12(IP checksum assist) */
+		u32 tcpa:1;	/* bit 13(TCP checksum assist) */
+		u32 udpa:1;	/* bit 14(UDP checksum assist) */
+		u32 unused:17;	/* bits 15-31 */
 #endif	/* _BIT_FIELDS_HTOL */
 	} bits;
 } TXDESC_WORD3_t, *PTXDESC_WORD3_t;
@@ -132,8 +132,8 @@ typedef union _txdesc_word3_t {
 typedef struct _tx_desc_entry_t {
 	u32 DataBufferPtrHigh;
 	u32 DataBufferPtrLow;
-	TXDESC_WORD2_t word2;	// control words how to xmit the
-	TXDESC_WORD3_t word3;	// data (detailed above)
+	TXDESC_WORD2_t word2;	/* control words how to xmit the */
+	TXDESC_WORD3_t word3;	/* data (detailed above) */
 } TX_DESC_ENTRY_t, *PTX_DESC_ENTRY_t;
 
 
@@ -147,13 +147,13 @@ typedef union _tx_status_block_t {
 	u32 value;
 	struct {
 #ifdef _BIT_FIELDS_HTOL
-		u32 unused:21;		// bits 11-31
-		u32 serv_cpl_wrap:1;	// bit 10
-		u32 serv_cpl:10;		// bits 0-9
+		u32 unused:21;		/* bits 11-31 */
+		u32 serv_cpl_wrap:1;	/* bit 10 */
+		u32 serv_cpl:10;		/* bits 0-9 */
 #else
-		u32 serv_cpl:10;		// bits 0-9
-		u32 serv_cpl_wrap:1;	// bit 10
-		u32 unused:21;		// bits 11-31
+		u32 serv_cpl:10;		/* bits 0-9 */
+		u32 serv_cpl_wrap:1;	/* bit 10 */
+		u32 unused:21;		/* bits 11-31 */
 #endif
 	} bits;
 } TX_STATUS_BLOCK_t, *PTX_STATUS_BLOCK_t;
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -67,7 +67,7 @@
  * Do not change these values: if changed, then change also in respective
  * TXdma and Rxdma engines
  */
-#define NUM_DESC_PER_RING_TX         512	// TX Do not change these values
+#define NUM_DESC_PER_RING_TX         512	/* TX Do not change these values */
 #define NUM_TCB                      64
 
 /*
@@ -118,10 +118,10 @@
 
 #define MP_SHOULD_FAIL_SEND(_M)   ((_M)->Flags & fMP_ADAPTER_FAIL_SEND_MASK)
 #define MP_IS_NOT_READY(_M)       ((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK)
-#define MP_IS_READY(_M)           !((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK)
+#define MP_IS_READY(_M)           (!((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK))
 
-#define MP_HAS_CABLE(_M)           !((_M)->Flags & fMP_ADAPTER_NO_CABLE)
-#define MP_LINK_DETECTED(_M)       !((_M)->Flags & fMP_ADAPTER_LINK_DETECTION)
+#define MP_HAS_CABLE(_M)           (!((_M)->Flags & fMP_ADAPTER_NO_CABLE))
+#define MP_LINK_DETECTED(_M)       (!((_M)->Flags & fMP_ADAPTER_LINK_DETECTION))
 
 /* Counters for error rate monitoring */
 typedef struct _MP_ERR_COUNTERS {
@@ -136,7 +136,7 @@ typedef struct _MP_ERR_COUNTERS {
 typedef struct _MP_RFD {
 	struct list_head list_node;
 	struct sk_buff *Packet;
-	u32 PacketSize;	// total size of receive frame
+	u32 PacketSize;	/* total size of receive frame */
 	u16 iBufferIndex;
 	u8 iRingIndex;
 } MP_RFD, *PMP_RFD;
@@ -152,8 +152,8 @@ typedef enum _eflow_control_t {
 /* Struct to define some device statistics */
 typedef struct _ce_stats_t {
 	/* Link Input/Output stats */
-	uint64_t ipackets;	// # of in packets
-	uint64_t opackets;	// # of out packets
+	uint64_t ipackets;	/* # of in packets */
+	uint64_t opackets;	/* # of out packets */
 
 	/* MIB II variables
 	 *
@@ -161,21 +161,21 @@ typedef struct _ce_stats_t {
 	 * MUST have 32, then we'll need another way to perform atomic
 	 * operations
 	 */
-	u32 unircv;	// # multicast packets received
-	atomic_t unixmt;	// # multicast packets for Tx
-	u32 multircv;	// # multicast packets received
-	atomic_t multixmt;	// # multicast packets for Tx
-	u32 brdcstrcv;	// # broadcast packets received
-	atomic_t brdcstxmt;	// # broadcast packets for Tx
-	u32 norcvbuf;	// # Rx packets discarded
-	u32 noxmtbuf;	// # Tx packets discarded
+	u32 unircv;	/* # multicast packets received */
+	atomic_t unixmt;	/* # multicast packets for Tx */
+	u32 multircv;	/* # multicast packets received */
+	atomic_t multixmt;	/* # multicast packets for Tx */
+	u32 brdcstrcv;	/* # broadcast packets received */
+	atomic_t brdcstxmt;	/* # broadcast packets for Tx */
+	u32 norcvbuf;	/* # Rx packets discarded */
+	u32 noxmtbuf;	/* # Tx packets discarded */
 
 	/* Transciever state informations. */
 	u8 xcvr_addr;
 	u32 xcvr_id;
 
 	/* Tx Statistics. */
-	u32 tx_uflo;		// Tx Underruns
+	u32 tx_uflo;		/* Tx Underruns */
 
 	u32 collisions;
 	u32 excessive_collisions;
@@ -185,7 +185,7 @@ typedef struct _ce_stats_t {
 	u32 tx_deferred;
 
 	/* Rx Statistics. */
-	u32 rx_ov_flow;	// Rx Over Flow
+	u32 rx_ov_flow;	/* Rx Over Flow */
 
 	u32 length_err;
 	u32 alignment_err;
@@ -268,16 +268,16 @@ struct et131x_adapter {
 	u32 pci_cfg_state[64 / sizeof(u32)];
 
 	/* Registry parameters */
-	u8 SpeedDuplex;		// speed/duplex
-	eFLOW_CONTROL_t RegistryFlowControl;	// for 802.3x flow control
-	u8 RegistryWOLMatch;	// Enable WOL pattern-matching
-	u8 RegistryWOLLink;	// Link state change is independant
-	u8 RegistryPhyComa;	// Phy Coma mode enable/disable
-
-	u32 RegistryRxMemEnd;	// Size of internal rx memory
-	u8 RegistryMACStat;	// If set, read MACSTAT, else don't
-	u32 RegistryVlanTag;	// 802.1q Vlan TAG
-	u32 RegistryJumboPacket;	// Max supported ethernet packet size
+	u8 SpeedDuplex;		/* speed/duplex */
+	eFLOW_CONTROL_t RegistryFlowControl;	/* for 802.3x flow control */
+	u8 RegistryWOLMatch;	/* Enable WOL pattern-matching */
+	u8 RegistryWOLLink;	/* Link state change is independant */
+	u8 RegistryPhyComa;	/* Phy Coma mode enable/disable */
+
+	u32 RegistryRxMemEnd;	/* Size of internal rx memory */
+	u8 RegistryMACStat;	/* If set, read MACSTAT, else don't */
+	u32 RegistryVlanTag;	/* 802.1q Vlan TAG */
+	u32 RegistryJumboPacket;	/* Max supported ethernet packet size */
 
 	u32 RegistryTxNumBuffers;
 	u32 RegistryTxTimeInterval;
@@ -290,12 +290,12 @@ struct et131x_adapter {
 	u8 RegistryNMIDisable;
 	u32 RegistryDMACache;
 	u32 RegistrySCGain;
-	u8 RegistryPhyLoopbk;	// Enable Phy loopback
+	u8 RegistryPhyLoopbk;	/* Enable Phy loopback */
 
 	/* Derived from the registry: */
-	u8 AiForceDpx;		// duplex setting
-	u16 AiForceSpeed;		// 'Speed', user over-ride of line speed
-	eFLOW_CONTROL_t FlowControl;	// flow control validated by the far-end
+	u8 AiForceDpx;		/* duplex setting */
+	u16 AiForceSpeed;		/* 'Speed', user over-ride of line speed */
+	eFLOW_CONTROL_t FlowControl;	/* flow control validated by the far-end */
 	enum {
 		NETIF_STATUS_INVALID = 0,
 		NETIF_STATUS_MEDIA_CONNECT,
@@ -313,7 +313,7 @@ struct et131x_adapter {
 	MP_POWER_MGMT PoMgmt;
 	INTERRUPT_t CachedMaskValue;
 
-	atomic_t RcvRefCount;	// Num packets not yet returned
+	atomic_t RcvRefCount;	/* Num packets not yet returned */
 
 	/* Xcvr status at last poll */
 	MI_BMSR_t Bmsr;
@@ -329,8 +329,8 @@ struct et131x_adapter {
 	PCI_CFG_SPACE_REGS PciCfgRegs;
 
 	/* Loopback specifics */
-	u8 ReplicaPhyLoopbk;	// Replica Enable
-	u8 ReplicaPhyLoopbkPF;	// Replica Enable Pass/Fail
+	u8 ReplicaPhyLoopbk;	/* Replica Enable */
+	u8 ReplicaPhyLoopbkPF;	/* Replica Enable Pass/Fail */
 
 	/* Stats */
 	CE_STATS_t Stats;
--- a/drivers/staging/et131x/et131x_config.c
+++ b/drivers/staging/et131x/et131x_config.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -74,9 +74,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -198,7 +198,7 @@ MODULE_PARM_DESC(et131x_nmi_disable, "Di
 static u32 et131x_speed_set = PARM_SPEED_DUPLEX_DEF;
 module_param(et131x_speed_set, uint, 0);
 MODULE_PARM_DESC(et131x_speed_set,
-		 "Set Link speed and dublex manually (0-5)  [0] \n  1 : 10Mb   Half-Duplex \n  2 : 10Mb   Full-Duplex \n  3 : 100Mb  Half-Duplex \n  4 : 100Mb  Full-Duplex \n  5 : 1000Mb Full-Duplex \n 0 : Auto Speed Auto Dublex");
+		"Set Link speed and dublex manually (0-5)  [0] \n  1 : 10Mb   Half-Duplex \n  2 : 10Mb   Full-Duplex \n  3 : 100Mb  Half-Duplex \n  4 : 100Mb  Full-Duplex \n  5 : 1000Mb Full-Duplex \n 0 : Auto Speed Auto Dublex");
 
 /**
  * et131x_config_parse
@@ -242,7 +242,7 @@ void et131x_config_parse(struct et131x_a
 		pAdapter->SpeedDuplex = PARM_SPEED_DUPLEX_DEF;
 	}
 
-	//  pAdapter->SpeedDuplex            = PARM_SPEED_DUPLEX_DEF;
+	/*  pAdapter->SpeedDuplex            = PARM_SPEED_DUPLEX_DEF; */
 
 	pAdapter->RegistryVlanTag = PARM_VLAN_TAG_DEF;
 	pAdapter->RegistryFlowControl = PARM_FLOW_CTL_DEF;
@@ -259,11 +259,10 @@ void et131x_config_parse(struct et131x_a
 	pAdapter->RegistrySCGain = PARM_SC_GAIN_DEF;
 	pAdapter->RegistryPMWOL = PARM_PM_WOL_DEF;
 
-	if (et131x_nmi_disable != PARM_NMI_DISABLE_DEF) {
+	if (et131x_nmi_disable != PARM_NMI_DISABLE_DEF)
 		pAdapter->RegistryNMIDisable = et131x_nmi_disable;
-	} else {
+	else
 		pAdapter->RegistryNMIDisable = PARM_NMI_DISABLE_DEF;
-	}
 
 	pAdapter->RegistryDMACache = PARM_DMA_CACHE_DEF;
 	pAdapter->RegistryPhyLoopbk = PARM_PHY_LOOPBK_DEF;
@@ -283,39 +282,38 @@ void et131x_config_parse(struct et131x_a
 	 * Set up as if we are auto negotiating always and then change if we
 	 * go into force mode
 	 */
-	pAdapter->AiForceSpeed = 0;	// Auto speed
-	pAdapter->AiForceDpx = 0;	// Auto FDX
+	pAdapter->AiForceSpeed = 0;	/* Auto speed */
+	pAdapter->AiForceDpx = 0;	/* Auto FDX */
 
 	/* If we are the 10/100 device, and gigabit is somehow requested then
 	 * knock it down to 100 full.
 	 */
-	if ((pAdapter->DeviceID == ET131X_PCI_DEVICE_ID_FAST) &&
-	    (pAdapter->SpeedDuplex == 5)) {
+	if (pAdapter->DeviceID == ET131X_PCI_DEVICE_ID_FAST &&
+	    pAdapter->SpeedDuplex == 5)
 		pAdapter->SpeedDuplex = 4;
-	}
 
 	switch (pAdapter->SpeedDuplex) {
-	case 1:		// 10Mb   Half-Duplex
+	case 1:		/* 10Mb   Half-Duplex */
 		pAdapter->AiForceSpeed = 10;
 		pAdapter->AiForceDpx = 1;
 		break;
 
-	case 2:		// 10Mb   Full-Duplex
+	case 2:		/* 10Mb   Full-Duplex */
 		pAdapter->AiForceSpeed = 10;
 		pAdapter->AiForceDpx = 2;
 		break;
 
-	case 3:		// 100Mb  Half-Duplex
+	case 3:		/* 100Mb  Half-Duplex */
 		pAdapter->AiForceSpeed = 100;
 		pAdapter->AiForceDpx = 1;
 		break;
 
-	case 4:		// 100Mb  Full-Duplex
+	case 4:		/* 100Mb  Full-Duplex */
 		pAdapter->AiForceSpeed = 100;
 		pAdapter->AiForceDpx = 2;
 		break;
 
-	case 5:		// 1000Mb Full-Duplex
+	case 5:		/* 1000Mb Full-Duplex */
 		pAdapter->AiForceSpeed = 1000;
 		pAdapter->AiForceDpx = 2;
 		break;
--- a/drivers/staging/et131x/et131x_debug.c
+++ b/drivers/staging/et131x/et131x_debug.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -76,9 +76,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -214,4 +214,4 @@ void DumpDeviceReg(int dbgLvl, struct et
 	}
 }
 
-#endif // CONFIG_ET131X_DEBUG
+#endif /* CONFIG_ET131X_DEBUG */
--- a/drivers/staging/et131x/et131x_debug.h
+++ b/drivers/staging/et131x/et131x_debug.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -21,7 +21,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -42,7 +42,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -97,7 +97,7 @@
 #endif /* DBG_PRINTC */
 
 #ifndef DBG_TRAP
-#define DBG_TRAP		{}	/* BUG() */
+#define DBG_TRAP		do {} while (0)	/* BUG() */
 #endif /* DBG_TRAP */
 
 #define _ENTER_STR	">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
@@ -227,16 +227,16 @@ typedef struct {
 #define DBG_PRINT(S...)
 #define DBG_ENTER(A)
 #define DBG_LEAVE(A)
-#define DBG_PARAM(A,N,F,S...)
-#define DBG_ERROR(A,S...)
-#define DBG_WARNING(A,S...)
-#define DBG_NOTICE(A,S...)
-#define DBG_TRACE(A,S...)
-#define DBG_VERBOSE(A,S...)
-#define DBG_RX(A,S...)
+#define DBG_PARAM(A, N, F, S...)
+#define DBG_ERROR(A, S...)
+#define DBG_WARNING(A, S...)
+#define DBG_NOTICE(A, S...)
+#define DBG_TRACE(A, S...)
+#define DBG_VERBOSE(A, S...)
+#define DBG_RX(A, S...)
 #define DBG_RX_ENTER(A)
 #define DBG_RX_LEAVE(A)
-#define DBG_TX(A,S...)
+#define DBG_TX(A, S...)
 #define DBG_TX_ENTER(A)
 #define DBG_TX_LEAVE(A)
 #define DBG_ASSERT(C)
--- a/drivers/staging/et131x/et131x_defs.h
+++ b/drivers/staging/et131x/et131x_defs.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -118,9 +118,9 @@
 #define ET1310_PCI_ADVANCED_ERR		0x100
 
 /* PCI Vendor/Product IDs */
-#define ET131X_PCI_VENDOR_ID		0x11C1	// Agere Systems
-#define ET131X_PCI_DEVICE_ID_GIG	0xED00	// ET1310 1000 Base-T
-#define ET131X_PCI_DEVICE_ID_FAST	0xED01	// ET1310 100  Base-T
+#define ET131X_PCI_VENDOR_ID		0x11C1	/* Agere Systems */
+#define ET131X_PCI_DEVICE_ID_GIG	0xED00	/* ET1310 1000 Base-T 8 */
+#define ET131X_PCI_DEVICE_ID_FAST	0xED01	/* ET1310 100  Base-T */
 
 /* Define order of magnitude converter */
 #define NANO_IN_A_MICRO	1000
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -21,7 +21,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -42,7 +42,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -76,9 +76,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -155,8 +155,8 @@ static struct pci_driver et131x_driver =
       .id_table	= et131x_pci_table,
       .probe	= et131x_pci_setup,
       .remove	= __devexit_p(et131x_pci_remove),
-      .suspend	= NULL,		//et131x_pci_suspend,
-      .resume	= NULL,		//et131x_pci_resume,
+      .suspend	= NULL,		/* et131x_pci_suspend */
+      .resume	= NULL,		/* et131x_pci_resume */
 };
 
 
@@ -252,9 +252,8 @@ int et131x_find_adapter(struct et131x_ad
 		RegisterVal = inb(ET1310_NMI_DISABLE);
 		RegisterVal &= 0xf3;
 
-		if (adapter->RegistryNMIDisable == 2) {
+		if (adapter->RegistryNMIDisable == 2)
 			RegisterVal |= 0xc;
-		}
 
 		outb(ET1310_NMI_DISABLE, RegisterVal);
 	}
@@ -266,7 +265,7 @@ int et131x_find_adapter(struct et131x_ad
 				      &eepromStat);
 
 	/* THIS IS A WORKAROUND:
- 	 * I need to call this function twice to get my card in a
+	 * I need to call this function twice to get my card in a
 	 * LG M1 Express Dual running. I tried also a msleep before this
 	 * function, because I thougth there could be some time condidions
 	 * but it didn't work. Call the whole function twice also work.
@@ -331,9 +330,9 @@ int et131x_find_adapter(struct et131x_ad
 	EepromReadByte(adapter, 0x70, &adapter->eepromData[0], 0, SINGLE_BYTE);
 	EepromReadByte(adapter, 0x71, &adapter->eepromData[1], 0, SINGLE_BYTE);
 
-	if (adapter->eepromData[0] != 0xcd) {
-		adapter->eepromData[1] = 0x00;	// Disable all optional features
-	}
+	if (adapter->eepromData[0] != 0xcd)
+		/* Disable all optional features */
+		adapter->eepromData[1] = 0x00;
 
 	/* Let's set up the PORT LOGIC Register.  First we need to know what
 	 * the max_payload_size is
@@ -347,7 +346,7 @@ int et131x_find_adapter(struct et131x_ad
 	}
 
 	/* Program the Ack/Nak latency and replay timers */
-	maxPayload &= 0x07;	// Only the lower 3 bits are valid
+	maxPayload &= 0x07;	/* Only the lower 3 bits are valid */
 
 	if (maxPayload < 2) {
 		const uint16_t AckNak[2] = { 0x76, 0xD0 };
@@ -390,7 +389,7 @@ int et131x_find_adapter(struct et131x_ad
 	result = pci_read_config_byte(pdev, 0x51, &read_size_reg);
 	if (result != PCIBIOS_SUCCESSFUL) {
 		DBG_ERROR(et131x_dbginfo,
-			  "Could not read PCI config space for Max read size\n");
+			"Could not read PCI config space for Max read size\n");
 		DBG_LEAVE(et131x_dbginfo);
 		return -EIO;
 	}
@@ -401,7 +400,7 @@ int et131x_find_adapter(struct et131x_ad
 	result = pci_write_config_byte(pdev, 0x51, read_size_reg);
 	if (result != PCIBIOS_SUCCESSFUL) {
 		DBG_ERROR(et131x_dbginfo,
-			  "Could not write PCI config space for Max read size\n");
+		      "Could not write PCI config space for Max read size\n");
 		DBG_LEAVE(et131x_dbginfo);
 		return -EIO;
 	}
@@ -411,7 +410,7 @@ int et131x_find_adapter(struct et131x_ad
 				      &adapter->PciXDevCtl);
 	if (result != PCIBIOS_SUCCESSFUL) {
 		DBG_ERROR(et131x_dbginfo,
-			  "Could not read PCI config space for PCI Express Dev Ctl\n");
+		  "Could not read PCI config space for PCI Express Dev Ctl\n");
 		DBG_LEAVE(et131x_dbginfo);
 		return -EIO;
 	}
@@ -428,7 +427,7 @@ int et131x_find_adapter(struct et131x_ad
 					adapter->PermanentAddress + i);
 			if (result != PCIBIOS_SUCCESSFUL) {
 				DBG_ERROR(et131x_dbginfo,
-					  "Could not read PCI config space for MAC address\n");
+						"Could not read PCI config space for MAC address\n");
 				DBG_LEAVE(et131x_dbginfo);
 				return -EIO;
 			}
@@ -454,14 +453,12 @@ void et131x_error_timer_handler(unsigned
 	pm_csr.value = readl(&pAdapter->CSRAddress->global.pm_csr.value);
 
 	if (pm_csr.bits.pm_phy_sw_coma == 0) {
-		if (pAdapter->RegistryMACStat) {
+		if (pAdapter->RegistryMACStat)
 			UpdateMacStatHostCounters(pAdapter);
-		}
-	} else {
+	} else
 		DBG_VERBOSE(et131x_dbginfo,
 			    "No interrupts, in PHY coma, pm_csr = 0x%x\n",
 			    pm_csr.value);
-	}
 
 	if (!pAdapter->Bmsr.bits.link_status &&
 	    pAdapter->RegistryPhyComa &&
@@ -473,8 +470,9 @@ void et131x_error_timer_handler(unsigned
 		if (!pAdapter->Bmsr.bits.link_status
 		    && pAdapter->RegistryPhyComa) {
 			if (pm_csr.bits.pm_phy_sw_coma == 0) {
-				// NOTE - This was originally a 'sync with interrupt'. How
-				//        to do that under Linux?
+				/* NOTE - This was originally a 'sync with
+				 *  interrupt'. How to do that under Linux?
+				 */
 				et131x_enable_interrupts(pAdapter);
 				EnablePhyComa(pAdapter);
 			}
@@ -483,7 +481,7 @@ void et131x_error_timer_handler(unsigned
 
 	/* This is a periodic timer, so reschedule */
 	mod_timer(&pAdapter->ErrorTimer, jiffies +
-		  TX_ERROR_PERIOD * HZ / 1000);
+					  TX_ERROR_PERIOD * HZ / 1000);
 }
 
 /**
@@ -542,9 +540,8 @@ int et131x_adapter_setup(struct et131x_a
 	/* Move the following code to Timer function?? */
 	status = et131x_xcvr_find(pAdapter);
 
-	if (status != 0) {
+	if (status != 0)
 		DBG_WARNING(et131x_dbginfo, "Could not find the xcvr\n");
-	}
 
 	/* Prepare the TRUEPHY library. */
 	ET1310_PhyInit(pAdapter);
@@ -559,11 +556,10 @@ int et131x_adapter_setup(struct et131x_a
 	 * We need to turn off 1000 base half dulplex, the mac does not
 	 * support it. For the 10/100 part, turn off all gig advertisement
 	 */
-	if (pAdapter->DeviceID != ET131X_PCI_DEVICE_ID_FAST) {
+	if (pAdapter->DeviceID != ET131X_PCI_DEVICE_ID_FAST)
 		ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_FULL);
-	} else {
+	else
 		ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
-	}
 
 	/* Power up PHY */
 	ET1310_PhyPowerDown(pAdapter, 0);
@@ -861,9 +857,11 @@ int __devinit et131x_pci_setup(struct pc
 	/* Setup the fundamental net_device and private adapter structure elements  */
 	DBG_TRACE(et131x_dbginfo, "Setting fundamental net_device info...\n");
 	SET_NETDEV_DEV(netdev, &pdev->dev);
+	/*
 	if (pci_using_dac) {
-		//netdev->features |= NETIF_F_HIGHDMA;
+		netdev->features |= NETIF_F_HIGHDMA;
 	}
+	*/
 
 	/*
 	 * NOTE - Turn this on when we're ready to deal with SG-DMA
@@ -884,9 +882,9 @@ int __devinit et131x_pci_setup(struct pc
 	 * receiving a scattered buffer from the network stack, so leave it
 	 * off until checksums are calculated in HW.
 	 */
-	//netdev->features |= NETIF_F_SG;
-	//netdev->features |= NETIF_F_NO_CSUM;
-	//netdev->features |= NETIF_F_LLTX;
+	/* netdev->features |= NETIF_F_SG; */
+	/* netdev->features |= NETIF_F_NO_CSUM; */
+	/* netdev->features |= NETIF_F_LLTX; */
 
 	/* Allocate private adapter struct and copy in relevant information */
 	adapter = netdev_priv(netdev);
@@ -921,7 +919,7 @@ int __devinit et131x_pci_setup(struct pc
 	 *       lump it's init with the device specific init below into a
 	 *       single init function?
 	 */
-	//while (et131x_find_adapter(adapter, pdev) != 0);
+	/* while (et131x_find_adapter(adapter, pdev) != 0); */
 	et131x_find_adapter(adapter, pdev);
 
 	/* Map the bus-relative registers to system virtual memory */
@@ -1002,7 +1000,8 @@ int __devinit et131x_pci_setup(struct pc
 	/* Initialize link state */
 	et131x_link_detection_handler((unsigned long)adapter);
 
-	/* Intialize variable for counting how long we do not have link status */
+	/* Intialize variable for counting how long we do not have
+							link status */
 	adapter->PoMgmt.TransPhyComaModeOnBoot = 0;
 
 	/* We can enable interrupts now
@@ -1014,7 +1013,8 @@ int __devinit et131x_pci_setup(struct pc
 
 	/* Register the net_device struct with the Linux network layer */
 	DBG_TRACE(et131x_dbginfo, "Registering net_device...\n");
-	if ((result = register_netdev(netdev)) != 0) {
+	result = register_netdev(netdev);
+	if (result != 0) {
 		DBG_ERROR(et131x_dbginfo, "register_netdev() failed\n");
 		goto err_mem_free;
 	}
--- a/drivers/staging/et131x/et131x_initpci.h
+++ b/drivers/staging/et131x/et131x_initpci.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
--- a/drivers/staging/et131x/et131x_isr.c
+++ b/drivers/staging/et131x/et131x_isr.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -74,9 +74,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -151,29 +151,24 @@ irqreturn_t et131x_isr(int irq, void *de
 
 	/* This is our interrupt, so process accordingly */
 #ifdef CONFIG_ET131X_DEBUG
-	if (status.bits.rxdma_xfr_done) {
+	if (status.bits.rxdma_xfr_done)
 		adapter->Stats.RxDmaInterruptsPerSec++;
-	}
 
-	if (status.bits.txdma_isr) {
+	if (status.bits.txdma_isr)
 		adapter->Stats.TxDmaInterruptsPerSec++;
-	}
 #endif
 
 	if (status.bits.watchdog_interrupt) {
 		PMP_TCB pMpTcb = adapter->TxRing.CurrSendHead;
 
-		if (pMpTcb) {
-			if (++pMpTcb->PacketStaleCount > 1) {
+		if (pMpTcb)
+			if (++pMpTcb->PacketStaleCount > 1)
 				status.bits.txdma_isr = 1;
-			}
-		}
 
-		if (adapter->RxRing.UnfinishedReceives) {
+		if (adapter->RxRing.UnfinishedReceives)
 			status.bits.rxdma_xfr_done = 1;
-		} else if (pMpTcb == NULL) {
+		else if (pMpTcb == NULL)
 			writel(0, &adapter->CSRAddress->global.watchdog_timer);
-		}
 
 		status.bits.watchdog_interrupt = 0;
 #ifdef CONFIG_ET131X_DEBUG
@@ -284,7 +279,8 @@ void et131x_isr_handler(struct work_stru
 				/* Tell the device to send a pause packet via
 				 * the back pressure register
 				 */
-				pm_csr.value = readl(&iomem->global.pm_csr.value);
+				pm_csr.value =
+					readl(&iomem->global.pm_csr.value);
 				if (pm_csr.bits.pm_phy_sw_coma == 0) {
 					TXMAC_BP_CTRL_t bp_ctrl = { 0 };
 
@@ -332,7 +328,7 @@ void et131x_isr_handler(struct work_stru
 			 * something bad has occurred. A reset might be the
 			 * thing to do.
 			 */
-			// TRAP();
+			/* TRAP();*/
 
 			pAdapter->TxMacTest.value =
 				readl(&iomem->txmac.tx_test.value);
@@ -425,7 +421,7 @@ void et131x_isr_handler(struct work_stru
 			 * otherwise we just want the device to be reset and
 			 * continue
 			 */
-			//DBG_TRAP();
+			/* DBG_TRAP(); */
 		}
 
 		/* Handle RXMAC Interrupt */
@@ -436,10 +432,11 @@ void et131x_isr_handler(struct work_stru
 			 * set the flag to cause us to reset so we can solve
 			 * this issue.
 			 */
-			// MP_SET_FLAG( pAdapter, fMP_ADAPTER_HARDWARE_ERROR );
+			/* MP_SET_FLAG( pAdapter,
+						fMP_ADAPTER_HARDWARE_ERROR); */
 
 			DBG_WARNING(et131x_dbginfo,
-				    "RXMAC interrupt, error 0x%08x.  Requesting reset\n",
+			  "RXMAC interrupt, error 0x%08x.  Requesting reset\n",
 				    readl(&iomem->rxmac.err_reg.value));
 
 			DBG_WARNING(et131x_dbginfo,
@@ -452,7 +449,7 @@ void et131x_isr_handler(struct work_stru
 			 * otherwise we just want the device to be reset and
 			 * continue
 			 */
-			// TRAP();
+			/* TRAP(); */
 		}
 
 		/* Handle MAC_STAT Interrupt */
@@ -482,7 +479,6 @@ void et131x_isr_handler(struct work_stru
 		}
 	}
 
-	if (pAdapter->PoMgmt.PowerState == NdisDeviceStateD0) {
+	if (pAdapter->PoMgmt.PowerState == NdisDeviceStateD0)
 		et131x_enable_interrupts(pAdapter);
-	}
 }
--- a/drivers/staging/et131x/et131x_isr.h
+++ b/drivers/staging/et131x/et131x_isr.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
--- a/drivers/staging/et131x/et131x_netdev.c
+++ b/drivers/staging/et131x/et131x_netdev.c
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
@@ -73,9 +73,9 @@
 #include <linux/interrupt.h>
 #include <linux/in.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
 
 #include <linux/mii.h>
 #include <linux/netdevice.h>
@@ -153,16 +153,16 @@ struct net_device *et131x_device_alloc(v
 	/* Setup the function registration table (and other data) for a
 	 * net_device
 	 */
-	//netdev->init               = &et131x_init;
-	//netdev->set_config = &et131x_config;
+	/* netdev->init               = &et131x_init; */
+	/* netdev->set_config = &et131x_config; */
 	netdev->watchdog_timeo = ET131X_TX_TIMEOUT;
 	netdev->netdev_ops = &et131x_netdev_ops;
 
-	//netdev->ethtool_ops        = &et131x_ethtool_ops;
+	/* netdev->ethtool_ops        = &et131x_ethtool_ops; */
 
-	// Poll?
-	//netdev->poll               = &et131x_poll;
-	//netdev->poll_controller    = &et131x_poll_controller;
+	/* Poll? */
+	/* netdev->poll               = &et131x_poll; */
+	/* netdev->poll_controller    = &et131x_poll_controller; */
 
 	DBG_LEAVE(et131x_dbginfo);
 	return netdev;
@@ -194,23 +194,25 @@ struct net_device_stats *et131x_stats(st
 	stats->rx_over_errors = devstat->rx_ov_flow;
 	stats->rx_crc_errors = devstat->crc_err;
 
-	// NOTE: These stats don't have corresponding values in CE_STATS, so we're
-	//       going to have to update these directly from within the TX/RX code
-	//stats->rx_bytes            = 20; //devstat->;
-	//stats->tx_bytes            = 20; //devstat->;
-	//stats->rx_dropped          = devstat->;
-	//stats->tx_dropped          = devstat->;
-
-	// NOTE: Not used, can't find analogous statistics
-	//stats->rx_frame_errors     = devstat->;
-	//stats->rx_fifo_errors      = devstat->;
-	//stats->rx_missed_errors    = devstat->;
-
-	//stats->tx_aborted_errors   = devstat->;
-	//stats->tx_carrier_errors   = devstat->;
-	//stats->tx_fifo_errors      = devstat->;
-	//stats->tx_heartbeat_errors = devstat->;
-	//stats->tx_window_errors    = devstat->;
+	/* NOTE: These stats don't have corresponding values in CE_STATS,
+	 * so we're going to have to update these directly from within the
+	 * TX/RX code
+	 */
+	/* stats->rx_bytes            = 20; devstat->; */
+	/* stats->tx_bytes            = 20;  devstat->; */
+	/* stats->rx_dropped          = devstat->; */
+	/* stats->tx_dropped          = devstat->; */
+
+	/*  NOTE: Not used, can't find analogous statistics */
+	/* stats->rx_frame_errors     = devstat->; */
+	/* stats->rx_fifo_errors      = devstat->; */
+	/* stats->rx_missed_errors    = devstat->; */
+
+	/* stats->tx_aborted_errors   = devstat->; */
+	/* stats->tx_carrier_errors   = devstat->; */
+	/* stats->tx_fifo_errors      = devstat->; */
+	/* stats->tx_heartbeat_errors = devstat->; */
+	/* stats->tx_window_errors    = devstat->; */
 
 	DBG_LEAVE(et131x_dbginfo);
 	return stats;
@@ -414,10 +416,11 @@ int et131x_set_packet_filter(struct et13
 		 */
 		if (filter & ET131X_PACKET_TYPE_ALL_MULTICAST) {
 			DBG_VERBOSE(et131x_dbginfo,
-				    "Multicast filtering OFF (Rx ALL MULTICAST)\n");
+			      "Multicast filtering OFF (Rx ALL MULTICAST)\n");
 			pf_ctrl.bits.filter_multi_en = 0;
 		} else {
-			DBG_VERBOSE(et131x_dbginfo, "Multicast filtering ON\n");
+			DBG_VERBOSE(et131x_dbginfo,
+				"Multicast filtering ON\n");
 			SetupDeviceForMulticast(adapter);
 			pf_ctrl.bits.filter_multi_en = 1;
 			ctrl.bits.pkt_filter_disable = 0;
@@ -505,9 +508,7 @@ void et131x_multicast(struct net_device 
 
 	if (netdev->mc_count > NIC_MAX_MCAST_LIST) {
 		DBG_WARNING(et131x_dbginfo,
-			    "ACCEPT ALL MULTICAST for now, as there's more Multicast "
-			    "addresses than the HW supports\n");
-
+			    "ACCEPT ALL MULTICAST for now, as there's more Multicast addresses than the HW supports\n");
 		adapter->PacketFilter |= ET131X_PACKET_TYPE_ALL_MULTICAST;
 	}
 
@@ -525,10 +526,10 @@ void et131x_multicast(struct net_device 
 	adapter->MCAddressCount = netdev->mc_count;
 
 	if (netdev->mc_count) {
-		if (mclist->dmi_addrlen != ETH_ALEN) {
+		if (mclist->dmi_addrlen != ETH_ALEN)
 			DBG_WARNING(et131x_dbginfo,
-				    "Multicast addrs are not ETH_ALEN in size\n");
-		} else {
+				"Multicast addrs are not ETH_ALEN in size\n");
+		else {
 			count = netdev->mc_count - 1;
 			memcpy(adapter->MCList[count], mclist->dmi_addr,
 			       ETH_ALEN);
@@ -662,15 +663,15 @@ void et131x_tx_timeout(struct net_device
 					       lockflags);
 
 			DBG_WARNING(et131x_dbginfo,
-				    "Send stuck - reset.  pMpTcb->WrIndex %x, Flags 0x%08x\n",
-				    pMpTcb->WrIndex.bits.val,
-				    pMpTcb->Flags);
+				"Send stuck - reset.  pMpTcb->WrIndex %x, Flags 0x%08x\n",
+				pMpTcb->WrIndex.bits.val,
+				pMpTcb->Flags);
 
 			DBG_WARNING(et131x_dbginfo,
-				    "pDesc 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
-				    pDesc->DataBufferPtrHigh,
-				    pDesc->DataBufferPtrLow, pDesc->word2.value,
-				    pDesc->word3.value);
+				"pDesc 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
+				pDesc->DataBufferPtrHigh,
+				pDesc->DataBufferPtrLow, pDesc->word2.value,
+				pDesc->word3.value);
 
 			DBG_WARNING(et131x_dbginfo,
 				    "WbStatus 0x%08x\n", txDmaComplete.value);
@@ -737,7 +738,7 @@ int et131x_change_mtu(struct net_device 
 	result = et131x_adapter_memory_alloc(adapter);
 	if (result != 0) {
 		DBG_WARNING(et131x_dbginfo,
-			    "Change MTU failed; couldn't re-alloc DMA memory\n");
+			"Change MTU failed; couldn't re-alloc DMA memory\n");
 		return result;
 	}
 
@@ -750,9 +751,8 @@ int et131x_change_mtu(struct net_device 
 	et131x_adapter_setup(adapter);
 
 	/* Enable interrupts */
-	if (MP_TEST_FLAG(adapter, fMP_ADAPTER_INTERRUPT_IN_USE)) {
+	if (MP_TEST_FLAG(adapter, fMP_ADAPTER_INTERRUPT_IN_USE))
 		et131x_enable_interrupts(adapter);
-	}
 
 	/* Restart the Tx and Rx DMA engines */
 	et131x_rx_dma_enable(adapter);
@@ -781,8 +781,8 @@ int et131x_set_mac_addr(struct net_devic
 	struct sockaddr *address = new_mac;
 
 	DBG_ENTER(et131x_dbginfo);
-	// begin blux
-	// DBG_VERBOSE( et131x_dbginfo, "Function not implemented!!\n" );
+	/* begin blux */
+	/* DBG_VERBOSE( et131x_dbginfo, "Function not implemented!!\n" ); */
 
 	if (adapter == NULL) {
 		DBG_LEAVE(et131x_dbginfo);
@@ -808,22 +808,24 @@ int et131x_set_mac_addr(struct net_devic
 	et131x_handle_recv_interrupt(adapter);
 
 	/* Set the new MAC */
-	// netdev->set_mac_address  = &new_mac;
-	// netdev->mtu = new_mtu;
+	/* netdev->set_mac_address  = &new_mac; */
+	/* netdev->mtu = new_mtu; */
 
 	memcpy(netdev->dev_addr, address->sa_data, netdev->addr_len);
 
-	printk("%s: Setting MAC address to %02x:%02x:%02x:%02x:%02x:%02x\n",
-	       netdev->name, netdev->dev_addr[0], netdev->dev_addr[1],
-	       netdev->dev_addr[2], netdev->dev_addr[3], netdev->dev_addr[4],
-	       netdev->dev_addr[5]);
+	printk(KERN_INFO
+		"%s: Setting MAC address to %02x:%02x:%02x:%02x:%02x:%02x\n",
+			netdev->name,
+			netdev->dev_addr[0], netdev->dev_addr[1],
+			netdev->dev_addr[2], netdev->dev_addr[3],
+			netdev->dev_addr[4], netdev->dev_addr[5]);
 
 	/* Free Rx DMA memory */
 	et131x_adapter_memory_free(adapter);
 
 	/* Set the config parameter for Jumbo Packet support */
-	// adapter->RegistryJumboPacket = new_mtu + 14;
-	// blux: not needet here, w'll change the MAC
+	/* adapter->RegistryJumboPacket = new_mtu + 14; */
+	/* blux: not needet here, we'll change the MAC */
 
 	et131x_soft_reset(adapter);
 
@@ -831,23 +833,22 @@ int et131x_set_mac_addr(struct net_devic
 	result = et131x_adapter_memory_alloc(adapter);
 	if (result != 0) {
 		DBG_WARNING(et131x_dbginfo,
-			    "Change MAC failed; couldn't re-alloc DMA memory\n");
+			"Change MAC failed; couldn't re-alloc DMA memory\n");
 		return result;
 	}
 
 	et131x_init_send(adapter);
 
 	et131x_setup_hardware_properties(adapter);
-	// memcpy( netdev->dev_addr, adapter->CurrentAddress, ETH_ALEN );
-	// blux: no, do not override our nice address
+	/* memcpy( netdev->dev_addr, adapter->CurrentAddress, ETH_ALEN ); */
+	/* blux: no, do not override our nice address */
 
 	/* Init the device with the new settings */
 	et131x_adapter_setup(adapter);
 
 	/* Enable interrupts */
-	if (MP_TEST_FLAG(adapter, fMP_ADAPTER_INTERRUPT_IN_USE)) {
+	if (MP_TEST_FLAG(adapter, fMP_ADAPTER_INTERRUPT_IN_USE))
 		et131x_enable_interrupts(adapter);
-	}
 
 	/* Restart the Tx and Rx DMA engines */
 	et131x_rx_dma_enable(adapter);
--- a/drivers/staging/et131x/et131x_netdev.h
+++ b/drivers/staging/et131x/et131x_netdev.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -20,7 +20,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -41,7 +41,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
--- a/drivers/staging/et131x/et131x_version.h
+++ b/drivers/staging/et131x/et131x_version.h
@@ -2,7 +2,7 @@
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *   http://www.agere.com
  *
@@ -19,7 +19,7 @@
  * software indicates your acceptance of these terms and conditions.  If you do
  * not agree with these terms and conditions, do not use the software.
  *
- * Copyright © 2005 Agere Systems Inc.
+ * Copyright Â© 2005 Agere Systems Inc.
  * All rights reserved.
  *
  * Redistribution and use in source or binary forms, with or without
@@ -40,7 +40,7 @@
  *
  * Disclaimer
  *
- * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
  * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
