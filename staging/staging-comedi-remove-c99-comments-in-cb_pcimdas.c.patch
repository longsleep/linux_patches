From wfp5p@virginia.edu Fri Mar 27 08:30:54 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Fri, 27 Mar 2009 11:30:50 -0400
Subject: Staging: comedi: remove C99 comments in cb_pcimdas.c
To: greg@kroah.com
Cc: abbotti@mev.co.uk, fmhess@users.sourceforge.net, ds@schleef.org
Message-ID: <20090327153049.7154.79779.stgit@viridian.itc.Virginia.EDU>


Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/comedi/drivers/cb_pcimdas.c |  122 ++++++++++++++--------------
 1 file changed, 61 insertions(+), 61 deletions(-)

--- a/drivers/staging/comedi/drivers/cb_pcimdas.c
+++ b/drivers/staging/comedi/drivers/cb_pcimdas.c
@@ -48,24 +48,24 @@ See http://www.measurementcomputing.com/
 #include "plx9052.h"
 #include "8255.h"
 
-//#define CBPCIMDAS_DEBUG
+/* #define CBPCIMDAS_DEBUG */
 #undef CBPCIMDAS_DEBUG
 
 /* Registers for the PCIM-DAS1602/16 */
 
-// sizes of io regions (bytes)
-#define BADR0_SIZE 2		//??
+/* sizes of io regions (bytes) */
+#define BADR0_SIZE 2		/* ?? */
 #define BADR1_SIZE 4
 #define BADR2_SIZE 6
 #define BADR3_SIZE 16
 #define BADR4_SIZE 4
 
-//DAC Offsets
+/* DAC Offsets */
 #define ADC_TRIG 0
 #define DAC0_OFFSET 2
 #define DAC1_OFFSET 4
 
-//AI and Counter Constants
+/* AI and Counter Constants */
 #define MUX_LIMITS 0
 #define MAIN_CONN_DIO 1
 #define ADC_STAT 2
@@ -86,17 +86,17 @@ See http://www.measurementcomputing.com/
 struct cb_pcimdas_board {
 	const char *name;
 	unsigned short device_id;
-	int ai_se_chans;	// Inputs in single-ended mode
-	int ai_diff_chans;	// Inputs in differential mode
-	int ai_bits;		// analog input resolution
-	int ai_speed;		// fastest conversion period in ns
-	int ao_nchan;		// number of analog out channels
-	int ao_bits;		// analogue output resolution
-	int has_ao_fifo;	// analog output has fifo
-	int ao_scan_speed;	// analog output speed for 1602 series (for a scan, not conversion)
-	int fifo_size;		// number of samples fifo can hold
-	int dio_bits;		// number of dio bits
-	int has_dio;		// has DIO
+	int ai_se_chans;	/*  Inputs in single-ended mode */
+	int ai_diff_chans;	/*  Inputs in differential mode */
+	int ai_bits;		/*  analog input resolution */
+	int ai_speed;		/*  fastest conversion period in ns */
+	int ao_nchan;		/*  number of analog out channels */
+	int ao_bits;		/*  analogue output resolution */
+	int has_ao_fifo;	/*  analog output has fifo */
+	int ao_scan_speed;	/*  analog output speed for 1602 series (for a scan, not conversion) */
+	int fifo_size;		/*  number of samples fifo can hold */
+	int dio_bits;		/*  number of dio bits */
+	int has_dio;		/*  has DIO */
 	const struct comedi_lrange *ranges;
 };
 
@@ -107,16 +107,16 @@ static const struct cb_pcimdas_board cb_
 	      ai_se_chans:16,
 	      ai_diff_chans:8,
 	      ai_bits:	16,
-	      ai_speed:10000,	//??
+	      ai_speed:10000,	/* ?? */
 	      ao_nchan:2,
 	      ao_bits:	12,
-	      has_ao_fifo:0,	//??
+	      has_ao_fifo:0,	/* ?? */
 	      ao_scan_speed:10000,
-			//??
+			/* ?? */
 	      fifo_size:1024,
 	      dio_bits:24,
 	      has_dio:	1,
-//              ranges:         &cb_pcimdas_ranges,
+/* ranges:         &cb_pcimdas_ranges, */
 		},
 };
 
@@ -129,7 +129,7 @@ static DEFINE_PCI_DEVICE_TABLE(cb_pcimda
 
 MODULE_DEVICE_TABLE(pci, cb_pcimdas_pci_table);
 
-#define N_BOARDS 1		// Max number of boards supported
+#define N_BOARDS 1		/*  Max number of boards supported */
 
 /*
  * Useful for shorthand access to the particular board structure
@@ -142,10 +142,10 @@ MODULE_DEVICE_TABLE(pci, cb_pcimdas_pci_
 struct cb_pcimdas_private {
 	int data;
 
-	// would be useful for a PCI device
+	/*  would be useful for a PCI device */
 	struct pci_dev *pci_dev;
 
-	//base addresses
+	/* base addresses */
 	unsigned long BADR0;
 	unsigned long BADR1;
 	unsigned long BADR2;
@@ -155,11 +155,11 @@ struct cb_pcimdas_private {
 	/* Used for AO readback */
 	unsigned int ao_readback[2];
 
-	// Used for DIO
-	unsigned short int port_a;	// copy of BADR4+0
-	unsigned short int port_b;	// copy of BADR4+1
-	unsigned short int port_c;	// copy of BADR4+2
-	unsigned short int dio_mode;	// copy of BADR4+3
+	/*  Used for DIO */
+	unsigned short int port_a;	/*  copy of BADR4+0 */
+	unsigned short int port_b;	/*  copy of BADR4+1 */
+	unsigned short int port_c;	/*  copy of BADR4+2 */
+	unsigned short int dio_mode;	/*  copy of BADR4+3 */
 
 };
 
@@ -202,7 +202,7 @@ static int cb_pcimdas_attach(struct come
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;
 	int index;
-	//int i;
+	/* int i; */
 
 	printk("comedi%d: cb_pcimdas: ", dev->minor);
 
@@ -220,17 +220,17 @@ static int cb_pcimdas_attach(struct come
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
-		// is it not a computer boards card?
+		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
-		// loop through cards supported by this driver
+		/*  loop through cards supported by this driver */
 		for (index = 0; index < N_BOARDS; index++) {
 			if (cb_pcimdas_boards[index].device_id !=
 				pcidev->device)
 				continue;
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
 					PCI_SLOT(pcidev->devfn) !=
 					it->options[1]) {
@@ -252,7 +252,7 @@ static int cb_pcimdas_attach(struct come
 	printk("Found %s on bus %i, slot %i\n", cb_pcimdas_boards[index].name,
 		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
-	// Warn about non-tested features
+	/*  Warn about non-tested features */
 	switch (thisboard->device_id) {
 	case 0x56:
 		break;
@@ -280,16 +280,16 @@ static int cb_pcimdas_attach(struct come
 	printk("devpriv->BADR4 = 0x%lx\n", devpriv->BADR4);
 #endif
 
-// Dont support IRQ yet
-//      // get irq
-//      if(comedi_request_irq(devpriv->pci_dev->irq, cb_pcimdas_interrupt, IRQF_SHARED, "cb_pcimdas", dev ))
-//      {
-//              printk(" unable to allocate irq %u\n", devpriv->pci_dev->irq);
-//              return -EINVAL;
-//      }
-//      dev->irq = devpriv->pci_dev->irq;
+/* Dont support IRQ yet */
+/*  get irq */
+/* if(comedi_request_irq(devpriv->pci_dev->irq, cb_pcimdas_interrupt, IRQF_SHARED, "cb_pcimdas", dev )) */
+/* { */
+/* printk(" unable to allocate irq %u\n", devpriv->pci_dev->irq); */
+/* return -EINVAL; */
+/* } */
+/* dev->irq = devpriv->pci_dev->irq; */
 
-	//Initialize dev->board_name
+	/* Initialize dev->board_name */
 	dev->board_name = thisboard->name;
 
 /*
@@ -300,24 +300,24 @@ static int cb_pcimdas_attach(struct come
 		return -ENOMEM;
 
 	s = dev->subdevices + 0;
-	//dev->read_subdev=s;
-	// analog input subdevice
+	/* dev->read_subdev=s; */
+	/*  analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = thisboard->ai_se_chans;
 	s->maxdata = (1 << thisboard->ai_bits) - 1;
 	s->range_table = &range_unknown;
-	s->len_chanlist = 1;	// This is the maximum chanlist length that
-	// the board can handle
+	s->len_chanlist = 1;	/*  This is the maximum chanlist length that */
+	/*  the board can handle */
 	s->insn_read = cb_pcimdas_ai_rinsn;
 
 	s = dev->subdevices + 1;
-	// analog output subdevice
+	/*  analog output subdevice */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE;
 	s->n_chan = thisboard->ao_nchan;
 	s->maxdata = 1 << thisboard->ao_bits;
-	s->range_table = &range_unknown;	//ranges are hardware settable, but not software readable.
+	s->range_table = &range_unknown;	/* ranges are hardware settable, but not software readable. */
 	s->insn_write = &cb_pcimdas_ao_winsn;
 	s->insn_read = &cb_pcimdas_ao_rinsn;
 
@@ -382,27 +382,27 @@ static int cb_pcimdas_ai_rinsn(struct co
 	unsigned short chanlims;
 	int maxchans;
 
-	// only support sw initiated reads from a single channel
+	/*  only support sw initiated reads from a single channel */
 
-	//check channel number
-	if ((inb(devpriv->BADR3 + 2) & 0x20) == 0)	//differential mode
+	/* check channel number */
+	if ((inb(devpriv->BADR3 + 2) & 0x20) == 0)	/* differential mode */
 		maxchans = thisboard->ai_diff_chans;
 	else
 		maxchans = thisboard->ai_se_chans;
 
 	if (chan > (maxchans - 1))
-		return -ETIMEDOUT;	//*** Wrong error code. Fixme.
+		return -ETIMEDOUT;	/* *** Wrong error code. Fixme. */
 
-	//configure for sw initiated read
+	/* configure for sw initiated read */
 	d = inb(devpriv->BADR3 + 5);
-	if ((d & 0x03) > 0) {	//only reset if needed.
+	if ((d & 0x03) > 0) {	/* only reset if needed. */
 		d = d & 0xfd;
 		outb(d, devpriv->BADR3 + 5);
 	}
-	outb(0x01, devpriv->BADR3 + 6);	//set bursting off, conversions on
-	outb(0x00, devpriv->BADR3 + 7);	//set range to 10V. UP/BP is controlled by a switch on the board
+	outb(0x01, devpriv->BADR3 + 6);	/* set bursting off, conversions on */
+	outb(0x00, devpriv->BADR3 + 7);	/* set range to 10V. UP/BP is controlled by a switch on the board */
 
-	// write channel limits to multiplexer, set Low (bits 0-3) and High (bits 4-7) channels to chan.
+	/*  write channel limits to multiplexer, set Low (bits 0-3) and High (bits 4-7) channels to chan. */
 	chanlims = chan | (chan << 4);
 	outb(chanlims, devpriv->BADR3 + 0);
 
@@ -411,8 +411,8 @@ static int cb_pcimdas_ai_rinsn(struct co
 		/* trigger conversion */
 		outw(0, devpriv->BADR2 + 0);
 
-#define TIMEOUT 1000		//typically takes 5 loops on a lightly loaded Pentium 100MHz,
-		//this is likely to be 100 loops on a 2GHz machine, so set 1000 as the limit.
+#define TIMEOUT 1000		/* typically takes 5 loops on a lightly loaded Pentium 100MHz, */
+		/* this is likely to be 100 loops on a 2GHz machine, so set 1000 as the limit. */
 
 		/* wait for conversion to end */
 		for (i = 0; i < TIMEOUT; i++) {
@@ -428,7 +428,7 @@ static int cb_pcimdas_ai_rinsn(struct co
 		d = inw(devpriv->BADR2 + 0);
 
 		/* mangle the data as necessary */
-		//d ^= 1<<(thisboard->ai_bits-1); // 16 bit data from ADC, so no mangle needed.
+		/* d ^= 1<<(thisboard->ai_bits-1); // 16 bit data from ADC, so no mangle needed. */
 
 		data[n] = d;
 	}
