From eba5cd4f44799ea6376fb36f11d4171e1ab3d098 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Mon, 23 Mar 2009 12:36:38 -0700
Subject: [PATCH] Staging: epl: remove BYTE

It's u8 in kernelspace, not BYTE.

Cc: Daniel Krueger <daniel.krueger@systec-electronic.com>
Cc: Ronald Sieber <Ronald.Sieber@systec-electronic.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/epl/Debug.h              |    4 -
 drivers/staging/epl/Edrv8139.c           |   28 +++----
 drivers/staging/epl/EdrvFec.h            |    2 
 drivers/staging/epl/EdrvSim.h            |    2 
 drivers/staging/epl/Epl.h                |    6 -
 drivers/staging/epl/EplAmi.h             |   14 +--
 drivers/staging/epl/EplApiGeneric.c      |   32 ++++----
 drivers/staging/epl/EplApiLinuxKernel.c  |    2 
 drivers/staging/epl/EplApiProcessImage.c |    4 -
 drivers/staging/epl/EplDll.h             |    4 -
 drivers/staging/epl/EplDllCal.h          |    2 
 drivers/staging/epl/EplDllk.c            |   98 +++++++++++++-------------
 drivers/staging/epl/EplDllkCal.c         |   10 +-
 drivers/staging/epl/EplDlluCal.c         |    2 
 drivers/staging/epl/EplErrorHandlerk.c   |    2 
 drivers/staging/epl/EplEvent.h           |    2 
 drivers/staging/epl/EplEventk.c          |    6 -
 drivers/staging/epl/EplEventu.c          |    6 -
 drivers/staging/epl/EplFrame.h           |  110 ++++++++++++++---------------
 drivers/staging/epl/EplInstDef.h         |   12 +--
 drivers/staging/epl/EplNmtCnu.c          |   20 ++---
 drivers/staging/epl/EplNmtMnu.c          |   42 +++++------
 drivers/staging/epl/EplNmtk.c            |    2 
 drivers/staging/epl/EplObd.c             |   40 +++++-----
 drivers/staging/epl/EplObd.h             |    8 +-
 drivers/staging/epl/EplObdMacro.h        |    4 -
 drivers/staging/epl/EplObdu.c            |    2 
 drivers/staging/epl/EplObduCal.c         |    2 
 drivers/staging/epl/EplPdo.h             |    2 
 drivers/staging/epl/EplPdok.c            |   14 +--
 drivers/staging/epl/EplPdou.c            |    8 +-
 drivers/staging/epl/EplSdoAsndu.c        |    4 -
 drivers/staging/epl/EplSdoAsySequ.c      |   28 +++----
 drivers/staging/epl/EplSdoComu.c         |   58 +++++++--------
 drivers/staging/epl/EplSdoUdpu.c         |    2 
 drivers/staging/epl/EplTarget.h          |    6 -
 drivers/staging/epl/ShbIpc-LinuxKernel.c |    2 
 drivers/staging/epl/TimerHighReskX86.c   |    2 
 drivers/staging/epl/amix86.c             |  116 +++++++++++++++----------------
 drivers/staging/epl/demo_main.c          |   26 +++---
 drivers/staging/epl/edrv.h               |   20 ++---
 drivers/staging/epl/global.h             |    3 
 drivers/staging/epl/kernel/EplDllk.h     |    8 +-
 drivers/staging/epl/kernel/EplDllkCal.h  |    2 
 drivers/staging/epl/kernel/EplObdk.h     |    2 
 drivers/staging/epl/proc_fs.c            |    4 -
 drivers/staging/epl/user/EplCfgMau.h     |   20 ++---
 drivers/staging/epl/user/EplDlluCal.h    |    2 
 drivers/staging/epl/user/EplObdu.h       |    2 
 drivers/staging/epl/user/EplObduCal.h    |    2 
 drivers/staging/epl/user/EplPdou.h       |    8 +-
 51 files changed, 404 insertions(+), 405 deletions(-)

--- a/drivers/staging/epl/amix86.c
+++ b/drivers/staging/epl/amix86.c
@@ -115,12 +115,12 @@ typedef struct {
 //
 //---------------------------------------------------------------------------
 
-//------------< write BYTE in big endian >--------------------------
+//------------< write u8 in big endian >--------------------------
 /*
-void AmiSetByteToBe (void *pAddr_p, BYTE bByteVal_p)
+void AmiSetByteToBe (void *pAddr_p, u8 bByteVal_p)
 {
 
-	*(BYTE *)pAddr_p = bByteVal_p;
+	*(u8 *)pAddr_p = bByteVal_p;
 
 }
 */
@@ -173,12 +173,12 @@ void AmiSetDwordToBe(void *pAddr_p, DWOR
 //
 //---------------------------------------------------------------------------
 
-//------------< write BYTE in little endian >--------------------------
+//------------< write u8 in little endian >--------------------------
 /*
-void AmiSetByteToLe (void *pAddr_p, BYTE bByteVal_p)
+void AmiSetByteToLe (void *pAddr_p, u8 bByteVal_p)
 {
 
-	*(BYTE *)pAddr_p = bByteVal_p;
+	*(u8 *)pAddr_p = bByteVal_p;
 
 }
 */
@@ -220,12 +220,12 @@ void AmiSetDwordToLe(void *pAddr_p, DWOR
 //
 //---------------------------------------------------------------------------
 
-//------------< read BYTE in big endian >---------------------------
+//------------< read u8 in big endian >---------------------------
 /*
-BYTE AmiGetByteFromBe (void *pAddr_p)
+u8 AmiGetByteFromBe (void *pAddr_p)
 {
 
-	return ( *(BYTE *)pAddr_p );
+	return ( *(u8 *)pAddr_p );
 
 }
 */
@@ -279,12 +279,12 @@ DWORD AmiGetDwordFromBe(void *pAddr_p)
 //
 //---------------------------------------------------------------------------
 
-//------------< read BYTE in little endian >---------------------------
+//------------< read u8 in little endian >---------------------------
 /*
-BYTE AmiGetByteFromLe (void *pAddr_p)
+u8 AmiGetByteFromLe (void *pAddr_p)
 {
 
-	return ( *(BYTE *)pAddr_p );
+	return ( *(u8 *)pAddr_p );
 
 }
 */
@@ -326,9 +326,9 @@ DWORD AmiGetDwordFromLe(void *pAddr_p)
 
 void AmiSetDword24ToBe(void *pAddr_p, DWORD dwDwordVal_p)
 {
-	((BYTE *) pAddr_p)[0] = ((BYTE *) & dwDwordVal_p)[2];
-	((BYTE *) pAddr_p)[1] = ((BYTE *) & dwDwordVal_p)[1];
-	((BYTE *) pAddr_p)[2] = ((BYTE *) & dwDwordVal_p)[0];
+	((u8 *) pAddr_p)[0] = ((u8 *) & dwDwordVal_p)[2];
+	((u8 *) pAddr_p)[1] = ((u8 *) & dwDwordVal_p)[1];
+	((u8 *) pAddr_p)[2] = ((u8 *) & dwDwordVal_p)[0];
 }
 
 //---------------------------------------------------------------------------
@@ -348,9 +348,9 @@ void AmiSetDword24ToBe(void *pAddr_p, DW
 
 void AmiSetDword24ToLe(void *pAddr_p, DWORD dwDwordVal_p)
 {
-	((BYTE *) pAddr_p)[0] = ((BYTE *) & dwDwordVal_p)[0];
-	((BYTE *) pAddr_p)[1] = ((BYTE *) & dwDwordVal_p)[1];
-	((BYTE *) pAddr_p)[2] = ((BYTE *) & dwDwordVal_p)[2];
+	((u8 *) pAddr_p)[0] = ((u8 *) & dwDwordVal_p)[0];
+	((u8 *) pAddr_p)[1] = ((u8 *) & dwDwordVal_p)[1];
+	((u8 *) pAddr_p)[2] = ((u8 *) & dwDwordVal_p)[2];
 }
 
 //---------------------------------------------------------------------------
@@ -417,14 +417,14 @@ DWORD AmiGetDword24FromLe(void *pAddr_p)
 //---------------------------------------------------------------------------
 void AmiSetQword64ToBe(void *pAddr_p, QWORD qwQwordVal_p)
 {
-	((BYTE *) pAddr_p)[0] = ((BYTE *) & qwQwordVal_p)[7];
-	((BYTE *) pAddr_p)[1] = ((BYTE *) & qwQwordVal_p)[6];
-	((BYTE *) pAddr_p)[2] = ((BYTE *) & qwQwordVal_p)[5];
-	((BYTE *) pAddr_p)[3] = ((BYTE *) & qwQwordVal_p)[4];
-	((BYTE *) pAddr_p)[4] = ((BYTE *) & qwQwordVal_p)[3];
-	((BYTE *) pAddr_p)[5] = ((BYTE *) & qwQwordVal_p)[2];
-	((BYTE *) pAddr_p)[6] = ((BYTE *) & qwQwordVal_p)[1];
-	((BYTE *) pAddr_p)[7] = ((BYTE *) & qwQwordVal_p)[0];
+	((u8 *) pAddr_p)[0] = ((u8 *) & qwQwordVal_p)[7];
+	((u8 *) pAddr_p)[1] = ((u8 *) & qwQwordVal_p)[6];
+	((u8 *) pAddr_p)[2] = ((u8 *) & qwQwordVal_p)[5];
+	((u8 *) pAddr_p)[3] = ((u8 *) & qwQwordVal_p)[4];
+	((u8 *) pAddr_p)[4] = ((u8 *) & qwQwordVal_p)[3];
+	((u8 *) pAddr_p)[5] = ((u8 *) & qwQwordVal_p)[2];
+	((u8 *) pAddr_p)[6] = ((u8 *) & qwQwordVal_p)[1];
+	((u8 *) pAddr_p)[7] = ((u8 *) & qwQwordVal_p)[0];
 }
 
 //---------------------------------------------------------------------------
@@ -466,14 +466,14 @@ QWORD AmiGetQword64FromBe(void *pAddr_p)
 {
 	tqwStruct qwStruct;
 
-	((BYTE *) & qwStruct.m_qwQword)[0] = ((BYTE *) pAddr_p)[7];
-	((BYTE *) & qwStruct.m_qwQword)[1] = ((BYTE *) pAddr_p)[6];
-	((BYTE *) & qwStruct.m_qwQword)[2] = ((BYTE *) pAddr_p)[5];
-	((BYTE *) & qwStruct.m_qwQword)[3] = ((BYTE *) pAddr_p)[4];
-	((BYTE *) & qwStruct.m_qwQword)[4] = ((BYTE *) pAddr_p)[3];
-	((BYTE *) & qwStruct.m_qwQword)[5] = ((BYTE *) pAddr_p)[2];
-	((BYTE *) & qwStruct.m_qwQword)[6] = ((BYTE *) pAddr_p)[1];
-	((BYTE *) & qwStruct.m_qwQword)[7] = ((BYTE *) pAddr_p)[0];
+	((u8 *) & qwStruct.m_qwQword)[0] = ((u8 *) pAddr_p)[7];
+	((u8 *) & qwStruct.m_qwQword)[1] = ((u8 *) pAddr_p)[6];
+	((u8 *) & qwStruct.m_qwQword)[2] = ((u8 *) pAddr_p)[5];
+	((u8 *) & qwStruct.m_qwQword)[3] = ((u8 *) pAddr_p)[4];
+	((u8 *) & qwStruct.m_qwQword)[4] = ((u8 *) pAddr_p)[3];
+	((u8 *) & qwStruct.m_qwQword)[5] = ((u8 *) pAddr_p)[2];
+	((u8 *) & qwStruct.m_qwQword)[6] = ((u8 *) pAddr_p)[1];
+	((u8 *) & qwStruct.m_qwQword)[7] = ((u8 *) pAddr_p)[0];
 
 	return (qwStruct.m_qwQword);
 }
@@ -520,11 +520,11 @@ QWORD AmiGetQword64FromLe(void *pAddr_p)
 void AmiSetQword40ToBe(void *pAddr_p, QWORD qwQwordVal_p)
 {
 
-	((BYTE *) pAddr_p)[0] = ((BYTE *) & qwQwordVal_p)[4];
-	((BYTE *) pAddr_p)[1] = ((BYTE *) & qwQwordVal_p)[3];
-	((BYTE *) pAddr_p)[2] = ((BYTE *) & qwQwordVal_p)[2];
-	((BYTE *) pAddr_p)[3] = ((BYTE *) & qwQwordVal_p)[1];
-	((BYTE *) pAddr_p)[4] = ((BYTE *) & qwQwordVal_p)[0];
+	((u8 *) pAddr_p)[0] = ((u8 *) & qwQwordVal_p)[4];
+	((u8 *) pAddr_p)[1] = ((u8 *) & qwQwordVal_p)[3];
+	((u8 *) pAddr_p)[2] = ((u8 *) & qwQwordVal_p)[2];
+	((u8 *) pAddr_p)[3] = ((u8 *) & qwQwordVal_p)[1];
+	((u8 *) pAddr_p)[4] = ((u8 *) & qwQwordVal_p)[0];
 
 }
 
@@ -547,7 +547,7 @@ void AmiSetQword40ToLe(void *pAddr_p, QW
 {
 
 	((DWORD *) pAddr_p)[0] = ((DWORD *) & qwQwordVal_p)[0];
-	((BYTE *) pAddr_p)[4] = ((BYTE *) & qwQwordVal_p)[4];
+	((u8 *) pAddr_p)[4] = ((u8 *) & qwQwordVal_p)[4];
 
 }
 
@@ -621,12 +621,12 @@ QWORD AmiGetQword40FromLe(void *pAddr_p)
 void AmiSetQword48ToBe(void *pAddr_p, QWORD qwQwordVal_p)
 {
 
-	((BYTE *) pAddr_p)[0] = ((BYTE *) & qwQwordVal_p)[5];
-	((BYTE *) pAddr_p)[1] = ((BYTE *) & qwQwordVal_p)[4];
-	((BYTE *) pAddr_p)[2] = ((BYTE *) & qwQwordVal_p)[3];
-	((BYTE *) pAddr_p)[3] = ((BYTE *) & qwQwordVal_p)[2];
-	((BYTE *) pAddr_p)[4] = ((BYTE *) & qwQwordVal_p)[1];
-	((BYTE *) pAddr_p)[5] = ((BYTE *) & qwQwordVal_p)[0];
+	((u8 *) pAddr_p)[0] = ((u8 *) & qwQwordVal_p)[5];
+	((u8 *) pAddr_p)[1] = ((u8 *) & qwQwordVal_p)[4];
+	((u8 *) pAddr_p)[2] = ((u8 *) & qwQwordVal_p)[3];
+	((u8 *) pAddr_p)[3] = ((u8 *) & qwQwordVal_p)[2];
+	((u8 *) pAddr_p)[4] = ((u8 *) & qwQwordVal_p)[1];
+	((u8 *) pAddr_p)[5] = ((u8 *) & qwQwordVal_p)[0];
 
 }
 
@@ -723,13 +723,13 @@ QWORD AmiGetQword48FromLe(void *pAddr_p)
 void AmiSetQword56ToBe(void *pAddr_p, QWORD qwQwordVal_p)
 {
 
-	((BYTE *) pAddr_p)[0] = ((BYTE *) & qwQwordVal_p)[6];
-	((BYTE *) pAddr_p)[1] = ((BYTE *) & qwQwordVal_p)[5];
-	((BYTE *) pAddr_p)[2] = ((BYTE *) & qwQwordVal_p)[4];
-	((BYTE *) pAddr_p)[3] = ((BYTE *) & qwQwordVal_p)[3];
-	((BYTE *) pAddr_p)[4] = ((BYTE *) & qwQwordVal_p)[2];
-	((BYTE *) pAddr_p)[5] = ((BYTE *) & qwQwordVal_p)[1];
-	((BYTE *) pAddr_p)[6] = ((BYTE *) & qwQwordVal_p)[0];
+	((u8 *) pAddr_p)[0] = ((u8 *) & qwQwordVal_p)[6];
+	((u8 *) pAddr_p)[1] = ((u8 *) & qwQwordVal_p)[5];
+	((u8 *) pAddr_p)[2] = ((u8 *) & qwQwordVal_p)[4];
+	((u8 *) pAddr_p)[3] = ((u8 *) & qwQwordVal_p)[3];
+	((u8 *) pAddr_p)[4] = ((u8 *) & qwQwordVal_p)[2];
+	((u8 *) pAddr_p)[5] = ((u8 *) & qwQwordVal_p)[1];
+	((u8 *) pAddr_p)[6] = ((u8 *) & qwQwordVal_p)[0];
 
 }
 
@@ -753,7 +753,7 @@ void AmiSetQword56ToLe(void *pAddr_p, QW
 
 	((DWORD *) pAddr_p)[0] = ((DWORD *) & qwQwordVal_p)[0];
 	((WORD *) pAddr_p)[2] = ((WORD *) & qwQwordVal_p)[2];
-	((BYTE *) pAddr_p)[6] = ((BYTE *) & qwQwordVal_p)[6];
+	((u8 *) pAddr_p)[6] = ((u8 *) & qwQwordVal_p)[6];
 
 }
 
@@ -827,8 +827,8 @@ QWORD AmiGetQword56FromLe(void *pAddr_p)
 void AmiSetTimeOfDay(void *pAddr_p, tTimeOfDay *pTimeOfDay_p)
 {
 
-	AmiSetDwordToLe(((BYTE *) pAddr_p), pTimeOfDay_p->m_dwMs & 0x0FFFFFFF);
-	AmiSetWordToLe(((BYTE *) pAddr_p) + 4, pTimeOfDay_p->m_wDays);
+	AmiSetDwordToLe(((u8 *) pAddr_p), pTimeOfDay_p->m_dwMs & 0x0FFFFFFF);
+	AmiSetWordToLe(((u8 *) pAddr_p) + 4, pTimeOfDay_p->m_wDays);
 
 }
 
@@ -850,8 +850,8 @@ void AmiSetTimeOfDay(void *pAddr_p, tTim
 void AmiGetTimeOfDay(void *pAddr_p, tTimeOfDay *pTimeOfDay_p)
 {
 
-	pTimeOfDay_p->m_dwMs = AmiGetDwordFromLe(((BYTE *) pAddr_p)) & 0x0FFFFFFF;
-	pTimeOfDay_p->m_wDays = AmiGetWordFromLe(((BYTE *) pAddr_p) + 4);
+	pTimeOfDay_p->m_dwMs = AmiGetDwordFromLe(((u8 *) pAddr_p)) & 0x0FFFFFFF;
+	pTimeOfDay_p->m_wDays = AmiGetWordFromLe(((u8 *) pAddr_p) + 4);
 
 }
 
--- a/drivers/staging/epl/Debug.h
+++ b/drivers/staging/epl/Debug.h
@@ -634,13 +634,13 @@
 extern "C" {
 #endif
 
-	void DumpData(char *szStr_p, BYTE *pbData_p, WORD wSize_p);
+	void DumpData(char *szStr_p, u8 *pbData_p, WORD wSize_p);
 
 #ifdef __cplusplus
 }				// von extern "C"
 #endif
 #define DEBUG_DUMP_DATA(lvl,str,ptr,siz)    if ((DEBUG_GLB_LVL() & (lvl))==(lvl)) \
-                                                    DumpData (str, (BYTE *)(ptr), (WORD)(siz));
+                                                    DumpData (str, (u8 *)(ptr), (WORD)(siz));
 #else
 
 #define DEBUG_DUMP_DATA(lvl,str,ptr,siz)
--- a/drivers/staging/epl/demo_main.c
+++ b/drivers/staging/epl/demo_main.c
@@ -118,7 +118,7 @@ MODULE_DESCRIPTION("EPL MN demo");
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #else
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)
@@ -148,25 +148,25 @@ void TgtDbgSignalTracePoint(BYTE bTraceP
 // modul globale vars
 //---------------------------------------------------------------------------
 
-const BYTE abMacAddr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+const u8 abMacAddr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 
-BYTE bVarIn1_l;
-BYTE bVarOut1_l;
-BYTE bVarOut1Old_l;
-BYTE bModeSelect_l;		// state of the pushbuttons to select the mode
-BYTE bSpeedSelect_l;		// state of the pushbuttons to increase/decrease the speed
-BYTE bSpeedSelectOld_l;		// old state of the pushbuttons
+u8 bVarIn1_l;
+u8 bVarOut1_l;
+u8 bVarOut1Old_l;
+u8 bModeSelect_l;		// state of the pushbuttons to select the mode
+u8 bSpeedSelect_l;		// state of the pushbuttons to increase/decrease the speed
+u8 bSpeedSelectOld_l;		// old state of the pushbuttons
 DWORD dwLeds_l;			// current state of all LEDs
-BYTE bLedsRow1_l;		// current state of the LEDs in row 1
-BYTE bLedsRow2_l;		// current state of the LEDs in row 2
-BYTE abSelect_l[3];		// pushbuttons from CNs
+u8 bLedsRow1_l;		// current state of the LEDs in row 1
+u8 bLedsRow2_l;		// current state of the LEDs in row 2
+u8 abSelect_l[3];		// pushbuttons from CNs
 
 DWORD dwMode_l;			// current mode
 int iCurCycleCount_l;		// current cycle count
 int iMaxCycleCount_l;		// maximum cycle count (i.e. number of cycles until next light movement step)
 int iToggle;			// indicates the light movement direction
 
-BYTE abDomain_l[3000];
+u8 abDomain_l[3000];
 
 static wait_queue_head_t WaitQueueShutdown_g;	// wait queue for tEplNmtEventSwitchOff
 static atomic_t AtomicShutdown_g = ATOMIC_INIT(FALSE);
@@ -263,7 +263,7 @@ static int __init EplLinInit(void)
 	EplApiInitParam.m_uiSizeOfStruct = sizeof(EplApiInitParam);
 	EPL_MEMCPY(EplApiInitParam.m_abMacAddress, abMacAddr,
 		   sizeof(EplApiInitParam.m_abMacAddress));
-//    EplApiInitParam.m_abMacAddress[5] = (BYTE) EplApiInitParam.m_uiNodeId;
+//	EplApiInitParam.m_abMacAddress[5] = (u8) EplApiInitParam.m_uiNodeId;
 	EplApiInitParam.m_dwFeatureFlags = -1;
 	EplApiInitParam.m_dwCycleLen = uiCycleLen_g;	// required for error detection
 	EplApiInitParam.m_uiIsochrTxMaxPayload = 100;	// const
--- a/drivers/staging/epl/Edrv8139.c
+++ b/drivers/staging/epl/Edrv8139.c
@@ -234,7 +234,7 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
@@ -282,9 +282,9 @@ typedef struct
 typedef struct {
 	struct pci_dev *m_pPciDev;	// pointer to PCI device structure
 	void *m_pIoAddr;	// pointer to register space of Ethernet controller
-	BYTE *m_pbRxBuf;	// pointer to Rx buffer
+	u8 *m_pbRxBuf;	// pointer to Rx buffer
 	dma_addr_t m_pRxBufDma;
-	BYTE *m_pbTxBuf;	// pointer to Tx buffer
+	u8 *m_pbTxBuf;	// pointer to Tx buffer
 	dma_addr_t m_pTxBufDma;
 	BOOL m_afTxBufUsed[EDRV_MAX_TX_BUFFERS];
 	unsigned int m_uiCurTxDesc;
@@ -359,7 +359,7 @@ static struct pci_driver EdrvDriver = {
 // local function prototypes
 //---------------------------------------------------------------------------
 
-static BYTE EdrvCalcHash(BYTE * pbMAC_p);
+static u8 EdrvCalcHash(u8 * pbMAC_p);
 
 //---------------------------------------------------------------------------
 //
@@ -453,11 +453,11 @@ tEplKernel EdrvShutdown(void)
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvDefineRxMacAddrEntry(BYTE * pbMacAddr_p)
+tEplKernel EdrvDefineRxMacAddrEntry(u8 * pbMacAddr_p)
 {
 	tEplKernel Ret = kEplSuccessful;
 	DWORD dwData;
-	BYTE bHash;
+	u8 bHash;
 
 	bHash = EdrvCalcHash(pbMacAddr_p);
 /*
@@ -494,11 +494,11 @@ tEplKernel EdrvDefineRxMacAddrEntry(BYTE
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvUndefineRxMacAddrEntry(BYTE * pbMacAddr_p)
+tEplKernel EdrvUndefineRxMacAddrEntry(u8 * pbMacAddr_p)
 {
 	tEplKernel Ret = kEplSuccessful;
 	DWORD dwData;
-	BYTE bHash;
+	u8 bHash;
 
 	bHash = EdrvCalcHash(pbMacAddr_p);
 
@@ -720,7 +720,7 @@ tEplKernel EdrvTxMsgStart(tEdrvTxBuffer 
 //---------------------------------------------------------------------------
 static void EdrvReinitRx(void)
 {
-	BYTE bCmd;
+	u8 bCmd;
 
 	// simply switch off and on the receiver
 	// this will reset the CAPR register
@@ -765,7 +765,7 @@ static int TgtEthIsr(int nIrqNum_p, void
 	DWORD dwTxStatus;
 	DWORD dwRxStatus;
 	WORD wCurRx;
-	BYTE *pbRxBuf;
+	u8 *pbRxBuf;
 	unsigned int uiLength;
 	int iHandled = IRQ_HANDLED;
 
@@ -1215,15 +1215,15 @@ static void EdrvRemoveOne(struct pci_dev
 //#define CRC32_POLY    0xEDB88320  //
 // G(x) = x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + x7 + x5 + x4 + x2 + x + 1
 
-static BYTE EdrvCalcHash(BYTE * pbMAC_p)
+static u8 EdrvCalcHash(u8 * pbMAC_p)
 {
 	DWORD dwByteCounter;
 	DWORD dwBitCounter;
 	DWORD dwData;
 	DWORD dwCrc;
 	DWORD dwCarry;
-	BYTE *pbData;
-	BYTE bHash;
+	u8 *pbData;
+	u8 bHash;
 
 	pbData = pbMAC_p;
 
@@ -1246,7 +1246,7 @@ static BYTE EdrvCalcHash(BYTE * pbMAC_p)
 //    printk("MyCRC = 0x%08lX\n", dwCrc);
 	// only upper 6 bits (HASH_BITS) are used
 	// which point to specific bit in the hash registers
-	bHash = (BYTE) ((dwCrc >> (32 - HASH_BITS)) & 0x3f);
+	bHash = (u8) ((dwCrc >> (32 - HASH_BITS)) & 0x3f);
 
 	return bHash;
 }
--- a/drivers/staging/epl/EdrvFec.h
+++ b/drivers/staging/epl/EdrvFec.h
@@ -98,7 +98,7 @@
 typedef struct {
 	WORD m_wStatus;		// control / status  ---  used by edrv, do not change in application
 	WORD m_wLength;		// transfer length
-	BYTE *m_pbData;		// buffer address
+	u8 *m_pbData;		// buffer address
 } tBufferDescr;
 
 #if ((TARGET_HARDWARE & TGT_CPU_MASK_) == TGT_CPU_5282)
--- a/drivers/staging/epl/edrv.h
+++ b/drivers/staging/epl/edrv.h
@@ -104,7 +104,7 @@ typedef struct _tEdrvTxBuffer {
 	unsigned int m_uiTxMsgLen;	// IN: length of message to be send (set for each transmit call)
 	// ----------------------
 	unsigned int m_uiBufferNumber;	// OUT: number of the buffer, set by ethernetdriver
-	BYTE *m_pbBuffer;	// OUT: pointer to the buffer, set by ethernetdriver
+	u8 *m_pbBuffer;	// OUT: pointer to the buffer, set by ethernetdriver
 	tEplNetTime m_NetTime;	// OUT: Timestamp of end of transmission, set by ethernetdriver
 	// ----------------------
 	unsigned int m_uiMaxBufferLen;	// IN/OUT: maximum length of the buffer
@@ -114,21 +114,21 @@ typedef struct _tEdrvTxBuffer {
 typedef struct _tEdrvRxBuffer {
 	tEdrvBufferInFrame m_BufferInFrame;	// OUT position of received buffer in an ethernet-frame
 	unsigned int m_uiRxMsgLen;	// OUT: length of received buffer (without CRC)
-	BYTE *m_pbBuffer;	// OUT: pointer to the buffer, set by ethernetdriver
+	u8 *m_pbBuffer;	// OUT: pointer to the buffer, set by ethernetdriver
 	tEplNetTime m_NetTime;	// OUT: Timestamp of end of receiption
 
 } tEdrvRxBuffer;
 
-//typedef void (*tEdrvRxHandler) (BYTE bBufferInFrame_p, tBufferDescr * pbBuffer_p);
-//typedef void (*tEdrvRxHandler) (BYTE bBufferInFrame_p, BYTE * pbEthernetData_p, WORD wDataLen_p);
+//typedef void (*tEdrvRxHandler) (u8 bBufferInFrame_p, tBufferDescr * pbBuffer_p);
+//typedef void (*tEdrvRxHandler) (u8 bBufferInFrame_p, u8 * pbEthernetData_p, WORD wDataLen_p);
 typedef void (*tEdrvRxHandler) (tEdrvRxBuffer * pRxBuffer_p);
 typedef void (*tEdrvTxHandler) (tEdrvTxBuffer * pTxBuffer_p);
 
 // format of init structure
 typedef struct {
-	BYTE m_abMyMacAddr[6];	// the own MAC address
+	u8 m_abMyMacAddr[6];	// the own MAC address
 
-//    BYTE            m_bNoOfRxBuffDescr;     // number of entries in rx bufferdescriptor table
+//    u8            m_bNoOfRxBuffDescr;     // number of entries in rx bufferdescriptor table
 //    tBufferDescr *  m_pRxBuffDescrTable;    // rx bufferdescriptor table
 //    WORD            m_wRxBufferSize;        // size of the whole rx buffer
 
@@ -145,11 +145,11 @@ tEplKernel EdrvInit(tEdrvInitParam * pEd
 
 tEplKernel EdrvShutdown(void);
 
-tEplKernel EdrvDefineRxMacAddrEntry(BYTE * pbMacAddr_p);
-tEplKernel EdrvUndefineRxMacAddrEntry(BYTE * pbMacAddr_p);
+tEplKernel EdrvDefineRxMacAddrEntry(u8 * pbMacAddr_p);
+tEplKernel EdrvUndefineRxMacAddrEntry(u8 * pbMacAddr_p);
 
-//tEplKernel EdrvDefineUnicastEntry     (BYTE * pbUCEntry_p);
-//tEplKernel EdrvUndfineUnicastEntry    (BYTE * pbUCEntry_p);
+//tEplKernel EdrvDefineUnicastEntry     (u8 * pbUCEntry_p);
+//tEplKernel EdrvUndfineUnicastEntry    (u8 * pbUCEntry_p);
 
 tEplKernel EdrvAllocTxMsgBuffer(tEdrvTxBuffer * pBuffer_p);
 tEplKernel EdrvReleaseTxMsgBuffer(tEdrvTxBuffer * pBuffer_p);
--- a/drivers/staging/epl/EdrvSim.h
+++ b/drivers/staging/epl/EdrvSim.h
@@ -83,7 +83,7 @@
 // function prototypes
 //---------------------------------------------------------------------------
 
-void EdrvRxInterruptHandler(BYTE bBufferInFrame_p, BYTE * pbEthernetData_p,
+void EdrvRxInterruptHandler(u8 bBufferInFrame_p, u8 * pbEthernetData_p,
 			    WORD wDataLen_p);
 
 #endif // #ifndef _EDRVSIM_H_
--- a/drivers/staging/epl/EplAmi.h
+++ b/drivers/staging/epl/EplAmi.h
@@ -69,7 +69,7 @@
 
    16.09.2002  -as
                To save code space the functions AmiSetByte and AmiGetByte
-               are replaced by macros. For targets which assign BYTE by
+               are replaced by macros. For targets which assign u8 by
                an 16Bit type, the definition of macros must changed to
                functions.
 
@@ -105,10 +105,10 @@ extern "C" {
 //
 // To save code space the function AmiSetByte is replaced by
 // an macro.
-// void  AmiSetByte  (void * pAddr_p, BYTE bByteVal_p);
+// void  AmiSetByte  (void * pAddr_p, u8 bByteVal_p);
 
-#define AmiSetByteToBe(pAddr_p, bByteVal_p)  {*(BYTE *)(pAddr_p) = (bByteVal_p);}
-#define AmiSetByteToLe(pAddr_p, bByteVal_p)  {*(BYTE *)(pAddr_p) = (bByteVal_p);}
+#define AmiSetByteToBe(pAddr_p, bByteVal_p)  {*(u8 *)(pAddr_p) = (bByteVal_p);}
+#define AmiSetByteToLe(pAddr_p, bByteVal_p)  {*(u8 *)(pAddr_p) = (bByteVal_p);}
 
 void AmiSetWordToBe(void *pAddr_p, WORD wWordVal_p);
 void AmiSetDwordToBe(void *pAddr_p, DWORD dwDwordVal_p);
@@ -121,10 +121,10 @@ void AmiSetDwordToLe(void *pAddr_p, DWOR
 //
 // To save code space the function AmiGetByte is replaced by
 // an macro.
-// BYTE   AmiGetByte  (void * pAddr_p);
+// u8   AmiGetByte  (void * pAddr_p);
 
-#define AmiGetByteFromBe(pAddr_p)  (*(BYTE *)(pAddr_p))
-#define AmiGetByteFromLe(pAddr_p)  (*(BYTE *)(pAddr_p))
+#define AmiGetByteFromBe(pAddr_p)  (*(u8 *)(pAddr_p))
+#define AmiGetByteFromLe(pAddr_p)  (*(u8 *)(pAddr_p))
 
 WORD AmiGetWordFromBe(void *pAddr_p);
 DWORD AmiGetDwordFromBe(void *pAddr_p);
--- a/drivers/staging/epl/EplApiGeneric.c
+++ b/drivers/staging/epl/EplApiGeneric.c
@@ -556,9 +556,9 @@ tEplKernel EplApiLinkObject(unsigned int
 			    tEplObdSize *pEntrySize_p,
 			    unsigned int uiFirstSubindex_p)
 {
-	BYTE bVarEntries;
-	BYTE bIndexEntries;
-	BYTE *pbData;
+	u8 bVarEntries;
+	u8 bIndexEntries;
+	u8 *pbData;
 	unsigned int uiSubindex;
 	tEplVarParam VarParam;
 	tEplObdSize EntrySize;
@@ -574,8 +574,8 @@ tEplKernel EplApiLinkObject(unsigned int
 		goto Exit;
 	}
 
-	pbData = (BYTE *)pVar_p;
-	bVarEntries = (BYTE) * puiVarEntries_p;
+	pbData = (u8 *)pVar_p;
+	bVarEntries = (u8) * puiVarEntries_p;
 	UsedSize = 0;
 
 	// init VarParam structure with default values
@@ -607,7 +607,7 @@ tEplKernel EplApiLinkObject(unsigned int
 	// object actually has.
 	if ((bIndexEntries > (bVarEntries + uiFirstSubindex_p - 1)) &&
 	    (bVarEntries != 0x00)) {
-		bIndexEntries = (BYTE) (bVarEntries + uiFirstSubindex_p - 1);
+		bIndexEntries = (u8) (bVarEntries + uiFirstSubindex_p - 1);
 	}
 	// map entries
 	for (uiSubindex = uiFirstSubindex_p; uiSubindex <= bIndexEntries;
@@ -1012,9 +1012,9 @@ tEplKernel EplApiCbObdAccess(tEplObdCbPa
 	case 0x1F9E:		// NMT_ResetCmd_U8
 		{
 			if (pParam_p->m_ObdEvent == kEplObdEvPreWrite) {
-				BYTE bNmtCommand;
+				u8 bNmtCommand;
 
-				bNmtCommand = *((BYTE *) pParam_p->m_pArg);
+				bNmtCommand = *((u8 *) pParam_p->m_pArg);
 				// check value range
 				switch ((tEplNmtCommand) bNmtCommand) {
 				case kEplNmtCmdResetNode:
@@ -1032,9 +1032,9 @@ tEplKernel EplApiCbObdAccess(tEplObdCbPa
 					break;
 				}
 			} else if (pParam_p->m_ObdEvent == kEplObdEvPostWrite) {
-				BYTE bNmtCommand;
+				u8 bNmtCommand;
 
-				bNmtCommand = *((BYTE *) pParam_p->m_pArg);
+				bNmtCommand = *((u8 *) pParam_p->m_pArg);
 				// check value range
 				switch ((tEplNmtCommand) bNmtCommand) {
 				case kEplNmtCmdResetNode:
@@ -1187,11 +1187,11 @@ static tEplKernel EplApiProcessEvent(tEp
 static tEplKernel EplApiCbNmtStateChange(tEplEventNmtStateChange NmtStateChange_p)
 {
 	tEplKernel Ret = kEplSuccessful;
-	BYTE bNmtState;
+	u8 bNmtState;
 	tEplApiEventArg EventArg;
 
 	// save NMT state in OD
-	bNmtState = (BYTE) NmtStateChange_p.m_NewNmtState;
+	bNmtState = (u8) NmtStateChange_p.m_NewNmtState;
 	Ret = EplObdWriteEntry(0x1F8C, 0, &bNmtState, 1);
 	if (Ret != kEplSuccessful) {
 		goto Exit;
@@ -1270,7 +1270,7 @@ static tEplKernel EplApiCbNmtStateChange
 	case kEplNmtCsNotActive:
 		{
 			// indicate completion of reset in NMT_ResetCmd_U8
-			bNmtState = (BYTE) kEplNmtCmdInvalidService;
+			bNmtState = (u8) kEplNmtCmdInvalidService;
 			Ret = EplObdWriteEntry(0x1F9E, 0, &bNmtState, 1);
 			if (Ret != kEplSuccessful) {
 				goto Exit;
@@ -1413,7 +1413,7 @@ static tEplKernel EplApiUpdateDllConfig(
 	tEplDllIdentParam DllIdentParam;
 	tEplObdSize ObdSize;
 	WORD wTemp;
-	BYTE bTemp;
+	u8 bTemp;
 
 	// configure Dll
 	EPL_MEMSET(&DllConfigParam, 0, sizeof(DllConfigParam));
@@ -1633,7 +1633,7 @@ static tEplKernel EplApiUpdateObd(void)
 {
 	tEplKernel Ret = kEplSuccessful;
 	WORD wTemp;
-	BYTE bTemp;
+	u8 bTemp;
 
 	// set node id in OD
 	Ret = EplObdSetNodeId(EplApiInstance_g.m_InitParam.m_uiNodeId,	// node id
@@ -1730,7 +1730,7 @@ static tEplKernel EplApiUpdateObd(void)
     }*/
 
 	if (EplApiInstance_g.m_InitParam.m_uiMultiplCycleCnt <= 0xFF) {
-		bTemp = (BYTE) EplApiInstance_g.m_InitParam.m_uiMultiplCycleCnt;
+		bTemp = (u8) EplApiInstance_g.m_InitParam.m_uiMultiplCycleCnt;
 		Ret = EplObdWriteEntry(0x1F98, 7, &bTemp, 1);
 /*    if(Ret != kEplSuccessful)
     {
--- a/drivers/staging/epl/EplApiLinuxKernel.c
+++ b/drivers/staging/epl/EplApiLinuxKernel.c
@@ -139,7 +139,7 @@ MODULE_DESCRIPTION("EPL API driver");
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #else
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)
--- a/drivers/staging/epl/EplApiProcessImage.c
+++ b/drivers/staging/epl/EplApiProcessImage.c
@@ -126,10 +126,10 @@
 #if ((EPL_API_PROCESS_IMAGE_SIZE_IN > 0) || (EPL_API_PROCESS_IMAGE_SIZE_OUT > 0))
 typedef struct {
 #if EPL_API_PROCESS_IMAGE_SIZE_IN > 0
-	BYTE m_abProcessImageInput[EPL_API_PROCESS_IMAGE_SIZE_IN];
+	u8 m_abProcessImageInput[EPL_API_PROCESS_IMAGE_SIZE_IN];
 #endif
 #if EPL_API_PROCESS_IMAGE_SIZE_OUT > 0
-	BYTE m_abProcessImageOutput[EPL_API_PROCESS_IMAGE_SIZE_OUT];
+	u8 m_abProcessImageOutput[EPL_API_PROCESS_IMAGE_SIZE_OUT];
 #endif
 
 } tEplApiProcessImageInstance;
--- a/drivers/staging/epl/EplDllCal.h
+++ b/drivers/staging/epl/EplDllCal.h
@@ -112,7 +112,7 @@ typedef struct {
 typedef struct {
 	tEplDllReqServiceId m_Service;
 	unsigned int m_uiNodeId;
-	BYTE m_bSoaFlag1;
+	u8 m_bSoaFlag1;
 
 } tEplDllCalIssueRequest;
 
--- a/drivers/staging/epl/EplDll.h
+++ b/drivers/staging/epl/EplDll.h
@@ -185,8 +185,8 @@ typedef struct {
 	DWORD m_dwIpAddress;
 	DWORD m_dwSubnetMask;
 	DWORD m_dwDefaultGateway;
-	BYTE m_sHostname[32];
-	BYTE m_abVendorSpecificExt2[48];
+	u8 m_sHostname[32];
+	u8 m_abVendorSpecificExt2[48];
 
 } tEplDllIdentParam;
 
--- a/drivers/staging/epl/EplDllk.c
+++ b/drivers/staging/epl/EplDllk.c
@@ -121,7 +121,7 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
@@ -195,12 +195,12 @@ typedef enum {
 } tEplDllState;
 
 typedef struct {
-	BYTE m_be_abSrcMac[6];
+	u8 m_be_abSrcMac[6];
 	tEdrvTxBuffer *m_pTxBuffer;	// Buffers for Tx-Frames
 	unsigned int m_uiMaxTxFrames;
-	BYTE m_bFlag1;		// Flag 1 with EN, EC for PRes, StatusRes
-	BYTE m_bMnFlag1;	// Flag 1 with EA, ER from PReq, SoA of MN
-	BYTE m_bFlag2;		// Flag 2 with PR and RS for PRes, StatusRes, IdentRes
+	u8 m_bFlag1;		// Flag 1 with EN, EC for PRes, StatusRes
+	u8 m_bMnFlag1;	// Flag 1 with EA, ER from PReq, SoA of MN
+	u8 m_bFlag2;		// Flag 2 with PR and RS for PRes, StatusRes, IdentRes
 	tEplDllConfigParam m_DllConfigParam;
 	tEplDllIdentParam m_DllIdentParam;
 	tEplDllState m_DllState;
@@ -513,7 +513,7 @@ tEplKernel EplDllkCreateTxFrame(unsigned
 			       EPL_C_DLL_ETHERTYPE_EPL);
 		// source node ID
 		AmiSetByteToLe(&pTxFrame->m_le_bSrcNodeId,
-			       (BYTE) EplDllkInstance_g.m_DllConfigParam.
+			       (u8) EplDllkInstance_g.m_DllConfigParam.
 			       m_uiNodeId);
 		// source MAC address
 		EPL_MEMCPY(&pTxFrame->m_be_abSrcMac[0],
@@ -530,7 +530,7 @@ tEplKernel EplDllkCreateTxFrame(unsigned
 				{	// IdentResponses and StatusResponses are Broadcast
 					AmiSetByteToLe(&pTxFrame->
 						       m_le_bDstNodeId,
-						       (BYTE)
+						       (u8)
 						       EPL_C_ADR_BROADCAST);
 					break;
 				}
@@ -549,10 +549,10 @@ tEplKernel EplDllkCreateTxFrame(unsigned
 					  EPL_C_DLL_MULTICAST_SOC);
 			// destination node ID
 			AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId,
-				       (BYTE) EPL_C_ADR_BROADCAST);
+				       (u8) EPL_C_ADR_BROADCAST);
 			// reset Flags
-			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soc.m_le_bFlag1, (BYTE) 0);
-			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soc.m_le_bFlag2, (BYTE) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soc.m_le_bFlag1, (u8) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soc.m_le_bFlag2, (u8) 0);
 			break;
 
 		case kEplMsgTypeSoa:
@@ -561,13 +561,13 @@ tEplKernel EplDllkCreateTxFrame(unsigned
 					  EPL_C_DLL_MULTICAST_SOA);
 			// destination node ID
 			AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId,
-				       (BYTE) EPL_C_ADR_BROADCAST);
+				       (u8) EPL_C_ADR_BROADCAST);
 			// reset Flags
-			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag1, (BYTE) 0);
-			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag2, (BYTE) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag1, (u8) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag2, (u8) 0);
 			// EPL profile version
 			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bEplVersion,
-				       (BYTE) EPL_SPEC_VERSION);
+				       (u8) EPL_SPEC_VERSION);
 			break;
 
 		case kEplMsgTypePres:
@@ -576,18 +576,18 @@ tEplKernel EplDllkCreateTxFrame(unsigned
 					  EPL_C_DLL_MULTICAST_PRES);
 			// destination node ID
 			AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId,
-				       (BYTE) EPL_C_ADR_BROADCAST);
+				       (u8) EPL_C_ADR_BROADCAST);
 			// reset Flags
-			//AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1, (BYTE) 0);
-			//AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag2, (BYTE) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1, (u8) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag2, (u8) 0);
 			// PDO size
 			//AmiSetWordToLe(&pTxFrame->m_Data.m_Pres.m_le_wSize, 0);
 			break;
 
 		case kEplMsgTypePreq:
 			// reset Flags
-			//AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag1, (BYTE) 0);
-			//AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag2, (BYTE) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag1, (u8) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag2, (u8) 0);
 			// PDO size
 			//AmiSetWordToLe(&pTxFrame->m_Data.m_Preq.m_le_wSize, 0);
 			break;
@@ -596,7 +596,7 @@ tEplKernel EplDllkCreateTxFrame(unsigned
 			break;
 		}
 		// EPL message type
-		AmiSetByteToLe(&pTxFrame->m_le_bMessageType, (BYTE) MsgType_p);
+		AmiSetByteToLe(&pTxFrame->m_le_bMessageType, (u8) MsgType_p);
 	}
 
 	*ppFrame_p = pTxFrame;
@@ -672,7 +672,7 @@ tEplKernel EplDllkProcess(tEplEvent * pE
 	tEdrvTxBuffer *pTxBuffer;
 	unsigned int uiHandle;
 	unsigned int uiFrameSize;
-	BYTE abMulticastMac[6];
+	u8 abMulticastMac[6];
 	tEplDllAsyncReqPriority AsyncReqPriority;
 	unsigned int uiFrameCount;
 	tEplNmtState NmtState;
@@ -711,7 +711,7 @@ tEplKernel EplDllkProcess(tEplEvent * pE
 			// EPL profile version
 			AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
 				       m_IdentResponse.m_le_bEplProfileVersion,
-				       (BYTE) EPL_SPEC_VERSION);
+				       (u8) EPL_SPEC_VERSION);
 			// FeatureFlags
 			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
 					m_IdentResponse.m_le_dwFeatureFlags,
@@ -1232,7 +1232,7 @@ tEplKernel EplDllkProcess(tEplEvent * pE
 				}
 				if (uiFrameCount > 0) {
 					EplDllkInstance_g.m_bFlag2 =
-					    (BYTE) (((AsyncReqPriority <<
+					    (u8) (((AsyncReqPriority <<
 						      EPL_FRAME_FLAG2_PR_SHIFT)
 						     & EPL_FRAME_FLAG2_PR)
 						    | (uiFrameCount &
@@ -1306,7 +1306,7 @@ tEplKernel EplDllkProcess(tEplEvent * pE
 					}
 					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
 						       m_le_bNmtStatus,
-						       (BYTE) NmtState);
+						       (u8) NmtState);
 					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
 						       m_le_bFlag2,
 						       EplDllkInstance_g.
@@ -1532,7 +1532,7 @@ tEplKernel EplDllkSetAsndServiceIdFilter
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkSetFlag1OfNode(unsigned int uiNodeId_p, BYTE bSoaFlag1_p)
+tEplKernel EplDllkSetFlag1OfNode(unsigned int uiNodeId_p, u8 bSoaFlag1_p)
 {
 	tEplKernel Ret = kEplSuccessful;
 	tEplDllkNodeInfo *pNodeInfo;
@@ -1663,7 +1663,7 @@ tEplKernel EplDllkAddNode(tEplDllNodeInf
 		pIntNodeInfo->m_pPreqTxBuffer =
 		    &EplDllkInstance_g.m_pTxBuffer[uiHandle];
 		AmiSetByteToLe(&pFrame->m_le_bDstNodeId,
-			       (BYTE) pNodeInfo_p->m_uiNodeId);
+			       (u8) pNodeInfo_p->m_uiNodeId);
 
 		// set up destination MAC address
 		EPL_MEMCPY(pFrame->m_be_abDstMac, pIntNodeInfo->m_be_abMacAddr,
@@ -2430,7 +2430,7 @@ static void EplDllkCbFrameReceived(tEdrv
 	tEplDllReqServiceId ReqServiceId;
 	unsigned int uiAsndServiceId;
 	unsigned int uiNodeId;
-	BYTE bFlag1;
+	u8 bFlag1;
 
 	BENCHMARK_MOD_02_SET(3);
 	NmtState = EplNmtkGetNmtState();
@@ -2465,7 +2465,7 @@ static void EplDllkCbFrameReceived(tEdrv
 					// update frame (NMT state, RD, RS, PR, MS, EN flags)
 					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
 						       m_le_bNmtStatus,
-						       (BYTE) NmtState);
+						       (u8) NmtState);
 					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
 						       m_le_bFlag2,
 						       EplDllkInstance_g.
@@ -2540,7 +2540,7 @@ static void EplDllkCbFrameReceived(tEdrv
 					// update frame (NMT state, RD, RS, PR, MS, EN flags)
 					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
 						       m_le_bNmtStatus,
-						       (BYTE) NmtState);
+						       (u8) NmtState);
 					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
 						       m_le_bFlag2,
 						       EplDllkInstance_g.
@@ -2802,7 +2802,7 @@ static void EplDllkCbFrameReceived(tEdrv
 				}
 				AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
 					       m_le_bNmtStatus,
-					       (BYTE) NmtState);
+					       (u8) NmtState);
 				AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
 					       m_le_bFlag2,
 					       EplDllkInstance_g.m_bFlag2);
@@ -2887,7 +2887,7 @@ static void EplDllkCbFrameReceived(tEdrv
 							       m_Payload.
 							       m_StatusResponse.
 							       m_le_bNmtStatus,
-							       (BYTE) NmtState);
+							       (u8) NmtState);
 						AmiSetByteToLe(&pTxFrame->
 							       m_Data.m_Asnd.
 							       m_Payload.
@@ -2953,7 +2953,7 @@ static void EplDllkCbFrameReceived(tEdrv
 							       m_Payload.
 							       m_IdentResponse.
 							       m_le_bNmtStatus,
-							       (BYTE) NmtState);
+							       (u8) NmtState);
 						AmiSetByteToLe(&pTxFrame->
 							       m_Data.m_Asnd.
 							       m_Payload.
@@ -3285,7 +3285,7 @@ static void EplDllkCbFrameTransmitted(tE
 						       m_Payload.
 						       m_StatusResponse.
 						       m_le_bNmtStatus,
-						       (BYTE) NmtState);
+						       (u8) NmtState);
 					AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.
 						       m_Payload.
 						       m_StatusResponse.
@@ -3321,7 +3321,7 @@ static void EplDllkCbFrameTransmitted(tE
 						       m_Payload.
 						       m_IdentResponse.
 						       m_le_bNmtStatus,
-						       (BYTE) NmtState);
+						       (u8) NmtState);
 					AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.
 						       m_Payload.
 						       m_IdentResponse.
@@ -3361,12 +3361,12 @@ static void EplDllkCbFrameTransmitted(tE
 						if ((AmiGetByteFromLe
 						     (&pTxFrame->
 						      m_le_bMessageType)
-						     == (BYTE) kEplMsgTypeAsnd)
+						     == (u8) kEplMsgTypeAsnd)
 						    &&
 						    (AmiGetByteFromLe
 						     (&pTxFrame->m_Data.m_Asnd.
 						      m_le_bServiceId)
-						     == (BYTE) kEplDllAsndNmtCommand)) {	// post event directly to NmtMnu module
+						     == (u8) kEplDllAsndNmtCommand)) {	// post event directly to NmtMnu module
 							Event.m_EventSink =
 							    kEplEventSinkNmtMnu;
 							Event.m_EventType =
@@ -3505,7 +3505,7 @@ static tEplKernel EplDllkCheckFrame(tEpl
 		if (wEtherType == EPL_C_DLL_ETHERTYPE_EPL) {
 			// source node ID
 			AmiSetByteToLe(&pFrame_p->m_le_bSrcNodeId,
-				       (BYTE) EplDllkInstance_g.
+				       (u8) EplDllkInstance_g.
 				       m_DllConfigParam.m_uiNodeId);
 
 			// check message type
@@ -3514,7 +3514,7 @@ static tEplKernel EplDllkCheckFrame(tEpl
 			if (MsgType == 0) {
 				MsgType = kEplMsgTypeAsnd;
 				AmiSetByteToLe(&pFrame_p->m_le_bMessageType,
-					       (BYTE) MsgType);
+					       (u8) MsgType);
 			}
 
 			if (MsgType == kEplMsgTypeAsnd) {
@@ -3825,24 +3825,24 @@ static tEplKernel EplDllkMnSendSoa(tEplN
 			// update frame (target)
 			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
 				       m_le_bReqServiceId,
-				       (BYTE) EplDllkInstance_g.
+				       (u8) EplDllkInstance_g.
 				       m_LastReqServiceId);
 			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
 				       m_le_bReqServiceTarget,
-				       (BYTE) EplDllkInstance_g.
+				       (u8) EplDllkInstance_g.
 				       m_uiLastTargetNodeId);
 
 		} else {	// invite nobody
 			// update frame (target)
 			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
-				       m_le_bReqServiceId, (BYTE) 0);
+				       m_le_bReqServiceId, (u8) 0);
 			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
-				       m_le_bReqServiceTarget, (BYTE) 0);
+				       m_le_bReqServiceTarget, (u8) 0);
 		}
 
 		// update frame (NMT state)
 		AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bNmtStatus,
-			       (BYTE) NmtState_p);
+			       (u8) NmtState_p);
 
 		// send SoA frame
 		Ret = EdrvSendTxMsg(pTxBuffer);
@@ -3919,7 +3919,7 @@ static tEplKernel EplDllkMnSendPreq(tEpl
 	tEplKernel Ret = kEplSuccessful;
 	tEdrvTxBuffer *pTxBuffer = NULL;
 	tEplFrame *pTxFrame;
-	BYTE bFlag1 = 0;
+	u8 bFlag1 = 0;
 
 	if (EplDllkInstance_g.m_pCurNodeInfo == NULL) {	// start with first isochronous CN
 		EplDllkInstance_g.m_pCurNodeInfo =
@@ -3970,7 +3970,7 @@ static tEplKernel EplDllkMnSendPreq(tEpl
 		if (pTxBuffer == &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES]) {	// PRes of MN will be sent
 			// update NMT state
 			AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bNmtStatus,
-				       (BYTE) NmtState_p);
+				       (u8) NmtState_p);
 			*pDllStateProposed_p = kEplDllMsWaitSoaTrig;
 		}
 		// $$$ d.k. set EPL_FRAME_FLAG1_MS if necessary
@@ -4013,7 +4013,7 @@ static tEplKernel EplDllkAsyncFrameNotRe
 					       unsigned int uiNodeId_p)
 {
 	tEplKernel Ret = kEplSuccessful;
-	BYTE abBuffer[18];
+	u8 abBuffer[18];
 	tEplFrame *pFrame = (tEplFrame *) abBuffer;
 	tEplFrameInfo FrameInfo;
 
@@ -4024,13 +4024,13 @@ static tEplKernel EplDllkAsyncFrameNotRe
 		// ASnd service registered?
 		if (EplDllkInstance_g.m_aAsndFilter[ReqServiceId_p] == kEplDllAsndFilterAny) {	// ASnd service ID is registered
 			AmiSetByteToLe(&pFrame->m_le_bSrcNodeId,
-				       (BYTE) uiNodeId_p);
+				       (u8) uiNodeId_p);
 			// EPL MsgType ASnd
 			AmiSetByteToLe(&pFrame->m_le_bMessageType,
-				       (BYTE) kEplMsgTypeAsnd);
+				       (u8) kEplMsgTypeAsnd);
 			// ASnd Service ID
 			AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_le_bServiceId,
-				       (BYTE) ReqServiceId_p);
+				       (u8) ReqServiceId_p);
 			// create frame info structure
 			FrameInfo.m_pFrame = pFrame;
 			FrameInfo.m_uiFrameSize = 18;	// empty non existing ASnd frame
--- a/drivers/staging/epl/EplDllkCal.c
+++ b/drivers/staging/epl/EplDllkCal.c
@@ -142,9 +142,9 @@ typedef struct {
 	tShbInstance m_ShbInstanceTxGen;	// FIFO for Tx frames with generic priority
 #else
 	unsigned int m_uiFrameSizeNmt;
-	BYTE m_abFrameNmt[1500];
+	u8 m_abFrameNmt[1500];
 	unsigned int m_uiFrameSizeGen;
-	BYTE m_abFrameGen[1500];
+	u8 m_abFrameGen[1500];
 #endif
 
 	tEplDllkCalStatistics m_Statistics;
@@ -536,7 +536,7 @@ tEplKernel EplDllkCalAsyncGetTxFrame(voi
 	case kEplDllAsyncReqPrioNmt:	// NMT request priority
 		ShbError =
 		    ShbCirReadDataBlock(EplDllkCalInstance_g.m_ShbInstanceTxNmt,
-					(BYTE *) pFrame_p, *puiFrameSize_p,
+					(u8 *) pFrame_p, *puiFrameSize_p,
 					&ulFrameSize);
 		// returns kShbOk, kShbDataTruncated, kShbInvalidArg, kShbNoReadableData
 		break;
@@ -544,7 +544,7 @@ tEplKernel EplDllkCalAsyncGetTxFrame(voi
 	default:		// generic priority
 		ShbError =
 		    ShbCirReadDataBlock(EplDllkCalInstance_g.m_ShbInstanceTxGen,
-					(BYTE *) pFrame_p, *puiFrameSize_p,
+					(u8 *) pFrame_p, *puiFrameSize_p,
 					&ulFrameSize);
 		// returns kShbOk, kShbDataTruncated, kShbInvalidArg, kShbNoReadableData
 		break;
@@ -876,7 +876,7 @@ tEplKernel EplDllkCalGetStatistics(tEplD
 //---------------------------------------------------------------------------
 
 tEplKernel EplDllkCalIssueRequest(tEplDllReqServiceId Service_p,
-				  unsigned int uiNodeId_p, BYTE bSoaFlag1_p)
+				  unsigned int uiNodeId_p, u8 bSoaFlag1_p)
 {
 	tEplKernel Ret = kEplSuccessful;
 
--- a/drivers/staging/epl/EplDlluCal.c
+++ b/drivers/staging/epl/EplDlluCal.c
@@ -355,7 +355,7 @@ tEplKernel EplDlluCalAsyncSend(tEplFrame
 //---------------------------------------------------------------------------
 
 tEplKernel EplDlluCalIssueRequest(tEplDllReqServiceId Service_p,
-				  unsigned int uiNodeId_p, BYTE bSoaFlag1_p)
+				  unsigned int uiNodeId_p, u8 bSoaFlag1_p)
 {
 	tEplKernel Ret = kEplSuccessful;
 
--- a/drivers/staging/epl/EplErrorHandlerk.c
+++ b/drivers/staging/epl/EplErrorHandlerk.c
@@ -770,7 +770,7 @@ static tEplKernel EplErrorHandlerkLinkAr
 	tEplKernel Ret = kEplSuccessful;
 	tEplVarParam VarParam;
 	tEplObdSize EntrySize;
-	BYTE bIndexEntries;
+	u8 bIndexEntries;
 
 	EntrySize = (tEplObdSize) sizeof(bIndexEntries);
 	Ret = EplObdReadEntry(uiIndex_p,
--- a/drivers/staging/epl/EplEvent.h
+++ b/drivers/staging/epl/EplEvent.h
@@ -248,7 +248,7 @@ typedef struct {
 	tEplEventSource m_EventSource;	// module which posted this error event
 	tEplKernel m_EplError;	// EPL error which occured
 	union {
-		BYTE m_bArg;
+		u8 m_bArg;
 		DWORD m_dwArg;
 		tEplEventSource m_EventSource;	// from Eventk/u module (originating error source)
 		tEplEventObdError m_ObdError;	// from Obd module
--- a/drivers/staging/epl/EplEventk.c
+++ b/drivers/staging/epl/EplEventk.c
@@ -100,7 +100,7 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
@@ -760,7 +760,7 @@ tEplKernel EplEventkPostError(tEplEventS
 			      unsigned int uiArgSize_p, void *pArg_p)
 {
 	tEplKernel Ret;
-	BYTE abBuffer[EPL_MAX_EVENT_ARG_SIZE];
+	u8 abBuffer[EPL_MAX_EVENT_ARG_SIZE];
 	tEplEventError *pEventError = (tEplEventError *) abBuffer;
 	tEplEvent EplEvent;
 
@@ -814,7 +814,7 @@ static void EplEventkRxSignalHandlerCb(t
 	tShbError ShbError;
 //unsigned long   ulBlockCount;
 //unsigned long   ulDataSize;
-	BYTE abDataBuffer[sizeof(tEplEvent) + EPL_MAX_EVENT_ARG_SIZE];
+	u8 abDataBuffer[sizeof(tEplEvent) + EPL_MAX_EVENT_ARG_SIZE];
 	// d.k.: abDataBuffer contains the complete tEplEvent structure
 	//       and behind this the argument
 
--- a/drivers/staging/epl/EplEventu.c
+++ b/drivers/staging/epl/EplEventu.c
@@ -96,7 +96,7 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
@@ -693,7 +693,7 @@ tEplKernel EplEventuPostError(tEplEventS
 			      unsigned int uiArgSize_p, void *pArg_p)
 {
 	tEplKernel Ret;
-	BYTE abBuffer[EPL_MAX_EVENT_ARG_SIZE];
+	u8 abBuffer[EPL_MAX_EVENT_ARG_SIZE];
 	tEplEventError *pEventError = (tEplEventError *) abBuffer;
 	tEplEvent EplEvent;
 
@@ -750,7 +750,7 @@ static void EplEventuRxSignalHandlerCb(t
 	tShbError ShbError;
 //unsigned long   ulBlockCount;
 //unsigned long   ulDataSize;
-	BYTE abDataBuffer[sizeof(tEplEvent) + EPL_MAX_EVENT_ARG_SIZE];
+	u8 abDataBuffer[sizeof(tEplEvent) + EPL_MAX_EVENT_ARG_SIZE];
 	// d.k.: abDataBuffer contains the complete tEplEvent structure
 	//       and behind this the argument
 
--- a/drivers/staging/epl/EplFrame.h
+++ b/drivers/staging/epl/EplFrame.h
@@ -122,11 +122,11 @@
 
 typedef struct {
 	// Offset 17
-	BYTE m_le_bRes1;	// reserved
+	u8 m_le_bRes1;	// reserved
 	// Offset 18
-	BYTE m_le_bFlag1;	// Flags: MC, PS
+	u8 m_le_bFlag1;	// Flags: MC, PS
 	// Offset 19
-	BYTE m_le_bFlag2;	// Flags: res
+	u8 m_le_bFlag2;	// Flags: res
 	// Offset 20
 	tEplNetTime m_le_NetTime;	// supported if D_NMT_NetTimeIsRealTime_BOOL is set
 	// Offset 28
@@ -136,54 +136,54 @@ typedef struct {
 
 typedef struct {
 	// Offset 17
-	BYTE m_le_bRes1;	// reserved
+	u8 m_le_bRes1;	// reserved
 	// Offset 18
-	BYTE m_le_bFlag1;	// Flags: MS, EA, RD
+	u8 m_le_bFlag1;	// Flags: MS, EA, RD
 	// Offset 19
-	BYTE m_le_bFlag2;	// Flags: res
+	u8 m_le_bFlag2;	// Flags: res
 	// Offset 20
-	BYTE m_le_bPdoVersion;
+	u8 m_le_bPdoVersion;
 	// Offset 21
-	BYTE m_le_bRes2;	// reserved
+	u8 m_le_bRes2;	// reserved
 	// Offset 22
 	WORD m_le_wSize;
 	// Offset 24
-	BYTE m_le_abPayload[256 /*D_NMT_IsochrRxMaxPayload_U16 */ ];
+	u8 m_le_abPayload[256 /*D_NMT_IsochrRxMaxPayload_U16 */ ];
 
 } PACK_STRUCT tEplPreqFrame;
 
 typedef struct {
 	// Offset 17
-	BYTE m_le_bNmtStatus;	// NMT state
+	u8 m_le_bNmtStatus;	// NMT state
 	// Offset 18
-	BYTE m_le_bFlag1;	// Flags: MS, EN, RD
+	u8 m_le_bFlag1;	// Flags: MS, EN, RD
 	// Offset 19
-	BYTE m_le_bFlag2;	// Flags: PR, RS
+	u8 m_le_bFlag2;	// Flags: PR, RS
 	// Offset 20
-	BYTE m_le_bPdoVersion;
+	u8 m_le_bPdoVersion;
 	// Offset 21
-	BYTE m_le_bRes2;	// reserved
+	u8 m_le_bRes2;	// reserved
 	// Offset 22
 	WORD m_le_wSize;
 	// Offset 24
-	BYTE m_le_abPayload[256	/*D_NMT_IsochrRxMaxPayload_U16
+	u8 m_le_abPayload[256	/*D_NMT_IsochrRxMaxPayload_U16
 				   / D_NMT_IsochrTxMaxPayload_U16 */ ];
 
 } PACK_STRUCT tEplPresFrame;
 
 typedef struct {
 	// Offset 17
-	BYTE m_le_bNmtStatus;	// NMT state
+	u8 m_le_bNmtStatus;	// NMT state
 	// Offset 18
-	BYTE m_le_bFlag1;	// Flags: EA, ER
+	u8 m_le_bFlag1;	// Flags: EA, ER
 	// Offset 19
-	BYTE m_le_bFlag2;	// Flags: res
+	u8 m_le_bFlag2;	// Flags: res
 	// Offset 20
-	BYTE m_le_bReqServiceId;
+	u8 m_le_bReqServiceId;
 	// Offset 21
-	BYTE m_le_bReqServiceTarget;
+	u8 m_le_bReqServiceTarget;
 	// Offset 22
-	BYTE m_le_bEplVersion;
+	u8 m_le_bEplVersion;
 
 } PACK_STRUCT tEplSoaFrame;
 
@@ -191,16 +191,16 @@ typedef struct {
 	WORD m_wEntryType;
 	WORD m_wErrorCode;
 	tEplNetTime m_TimeStamp;
-	BYTE m_abAddInfo[8];
+	u8 m_abAddInfo[8];
 
 } PACK_STRUCT tEplErrHistoryEntry;
 
 typedef struct {
 	// Offset 18
-	BYTE m_le_bFlag1;	// Flags: EN, EC
-	BYTE m_le_bFlag2;	// Flags: PR, RS
-	BYTE m_le_bNmtStatus;	// NMT state
-	BYTE m_le_bRes1[3];
+	u8 m_le_bFlag1;	// Flags: EN, EC
+	u8 m_le_bFlag2;	// Flags: PR, RS
+	u8 m_le_bNmtStatus;	// NMT state
+	u8 m_le_bRes1[3];
 	QWORD m_le_qwStaticError;	// static error bit field
 	tEplErrHistoryEntry m_le_aErrHistoryEntry[14];
 
@@ -208,12 +208,12 @@ typedef struct {
 
 typedef struct {
 	// Offset 18
-	BYTE m_le_bFlag1;	// Flags: res
-	BYTE m_le_bFlag2;	// Flags: PR, RS
-	BYTE m_le_bNmtStatus;	// NMT state
-	BYTE m_le_bIdentRespFlags;	// Flags: FW
-	BYTE m_le_bEplProfileVersion;
-	BYTE m_le_bRes1;
+	u8 m_le_bFlag1;	// Flags: res
+	u8 m_le_bFlag2;	// Flags: PR, RS
+	u8 m_le_bNmtStatus;	// NMT state
+	u8 m_le_bIdentRespFlags;	// Flags: FW
+	u8 m_le_bEplProfileVersion;
+	u8 m_le_bRes1;
 	DWORD m_le_dwFeatureFlags;	// NMT_FeatureFlags_U32
 	WORD m_le_wMtu;		// NMT_CycleTiming_REC.AsyncMTU_U16: C_IP_MIN_MTU - C_IP_MAX_MTU
 	WORD m_le_wPollInSize;	// NMT_CycleTiming_REC.PReqActPayload_U16
@@ -233,44 +233,44 @@ typedef struct {
 	DWORD m_le_dwIpAddress;
 	DWORD m_le_dwSubnetMask;
 	DWORD m_le_dwDefaultGateway;
-	BYTE m_le_sHostname[32];
-	BYTE m_le_abVendorSpecificExt2[48];
+	u8 m_le_sHostname[32];
+	u8 m_le_abVendorSpecificExt2[48];
 
 } PACK_STRUCT tEplIdentResponse;
 
 typedef struct {
 	// Offset 18
-	BYTE m_le_bNmtCommandId;
-	BYTE m_le_bRes1;
-	BYTE m_le_abNmtCommandData[32];
+	u8 m_le_bNmtCommandId;
+	u8 m_le_bRes1;
+	u8 m_le_abNmtCommandData[32];
 
 } PACK_STRUCT tEplNmtCommandService;
 
 typedef struct {
-	BYTE m_le_bReserved;
-	BYTE m_le_bTransactionId;
-	BYTE m_le_bFlags;
-	BYTE m_le_bCommandId;
+	u8 m_le_bReserved;
+	u8 m_le_bTransactionId;
+	u8 m_le_bFlags;
+	u8 m_le_bCommandId;
 	WORD m_le_wSegmentSize;
 	WORD m_le_wReserved;
-	BYTE m_le_abCommandData[8];	// just reserve a minimum number of bytes as a placeholder
+	u8 m_le_abCommandData[8];	// just reserve a minimum number of bytes as a placeholder
 
 } PACK_STRUCT tEplAsySdoCom;
 
 // asynchronous SDO Sequence Header
 typedef struct {
-	BYTE m_le_bRecSeqNumCon;
-	BYTE m_le_bSendSeqNumCon;
-	BYTE m_le_abReserved[2];
+	u8 m_le_bRecSeqNumCon;
+	u8 m_le_bSendSeqNumCon;
+	u8 m_le_abReserved[2];
 	tEplAsySdoCom m_le_abSdoSeqPayload;
 
 } PACK_STRUCT tEplAsySdoSeq;
 
 typedef struct {
 	// Offset 18
-	BYTE m_le_bNmtCommandId;
-	BYTE m_le_bTargetNodeId;
-	BYTE m_le_abNmtCommandData[32];
+	u8 m_le_bNmtCommandId;
+	u8 m_le_bTargetNodeId;
+	u8 m_le_abNmtCommandData[32];
 
 } PACK_STRUCT tEplNmtRequestService;
 
@@ -281,14 +281,14 @@ typedef union {
 	tEplNmtCommandService m_NmtCommandService;
 	tEplNmtRequestService m_NmtRequestService;
 	tEplAsySdoSeq m_SdoSequenceFrame;
-	BYTE m_le_abPayload[256	/*D_NMT_ASndTxMaxPayload_U16
+	u8 m_le_abPayload[256	/*D_NMT_ASndTxMaxPayload_U16
 				   / D_NMT_ASndRxMaxPayload_U16 */ ];
 
 } tEplAsndPayload;
 
 typedef struct {
 	// Offset 17
-	BYTE m_le_bServiceId;
+	u8 m_le_bServiceId;
 	// Offset 18
 	tEplAsndPayload m_Payload;
 
@@ -306,17 +306,17 @@ typedef union {
 
 typedef struct {
 	// Offset 0
-	BYTE m_be_abDstMac[6];	// MAC address of the addressed nodes
+	u8 m_be_abDstMac[6];	// MAC address of the addressed nodes
 	// Offset 6
-	BYTE m_be_abSrcMac[6];	// MAC address of the transmitting node
+	u8 m_be_abSrcMac[6];	// MAC address of the transmitting node
 	// Offset 12
 	WORD m_be_wEtherType;	// Ethernet message type (big endian)
 	// Offset 14
-	BYTE m_le_bMessageType;	// EPL message type
+	u8 m_le_bMessageType;	// EPL message type
 	// Offset 15
-	BYTE m_le_bDstNodeId;	// EPL node ID of the addressed nodes
+	u8 m_le_bDstNodeId;	// EPL node ID of the addressed nodes
 	// Offset 16
-	BYTE m_le_bSrcNodeId;	// EPL node ID of the transmitting node
+	u8 m_le_bSrcNodeId;	// EPL node ID of the transmitting node
 	// Offset 17
 	tEplFrameData m_Data;
 
--- a/drivers/staging/epl/Epl.h
+++ b/drivers/staging/epl/Epl.h
@@ -139,7 +139,7 @@ typedef struct {
 	unsigned int m_uiSizeOfStruct;
 	BOOL m_fAsyncOnly;	// do not need to register PRes
 	unsigned int m_uiNodeId;	// local node ID
-	BYTE m_abMacAddress[6];	// local MAC address
+	u8 m_abMacAddress[6];	// local MAC address
 
 	// 0x1F82: NMT_FeatureFlags_U32
 	DWORD m_dwFeatureFlags;
@@ -189,8 +189,8 @@ typedef struct {
 	DWORD m_dwIpAddress;
 	DWORD m_dwSubnetMask;
 	DWORD m_dwDefaultGateway;
-	BYTE m_sHostname[32];
-	BYTE m_abVendorSpecificExt2[48];
+	u8 m_sHostname[32];
+	u8 m_abVendorSpecificExt2[48];
 
 	char *m_pszDevName;	// NMT_ManufactDevName_VS (0x1008/0 local OD)
 	char *m_pszHwVersion;	// NMT_ManufactHwVers_VS  (0x1009/0 local OD)
--- a/drivers/staging/epl/EplInstDef.h
+++ b/drivers/staging/epl/EplInstDef.h
@@ -71,6 +71,8 @@
 #ifndef _EPLINSTDEF_H_
 #define _EPLINSTDEF_H_
 
+#include <linux/kernel.h>
+
 // =========================================================================
 // types and macros for generating instances
 // =========================================================================
@@ -84,7 +86,7 @@ typedef enum {
 //------------------------------------------------------------------------------------------
 
 typedef void *tEplPtrInstance;
-typedef BYTE tEplInstanceHdl;
+typedef u8 tEplInstanceHdl;
 
 // define const for illegale values
 #define CCM_ILLINSTANCE      NULL
@@ -214,8 +216,8 @@ typedef BYTE tEplInstanceHdl;
         tFastByte            InstNumber      = 0;                          \
         tFastByte            i               = EPL_MAX_INSTANCES;          \
         do {                                                               \
-            pInstance->m_InstState = (BYTE) kStateUnused;                  \
-            pInstance->m_bInstIndex = (BYTE) InstNumber;                   \
+            pInstance->m_InstState = (u8) kStateUnused;                  \
+            pInstance->m_bInstIndex = (u8) InstNumber;                   \
             pInstance++; InstNumber++; i--;                                \
         } while (i != 0);                                                  \
     }
@@ -243,8 +245,8 @@ typedef BYTE tEplInstanceHdl;
     // this macro defines member variables in instance table which are needed in
     // all modules of Epl stack
 #define EPL_MCO_DECL_INSTANCE_MEMBER() \
-        STATIC  BYTE                            m_InstState; \
-        STATIC  BYTE                            m_bInstIndex;
+        STATIC  u8                            m_InstState; \
+        STATIC  u8                            m_bInstIndex;
 
 #define EPL_MCO_INSTANCE_PARAM_IDX_()           EPL_MCO_INSTANCE_PARAM_ (EPL_MCO_GLB_VAR (m_bInstIndex))
 #define EPL_MCO_INSTANCE_PARAM_IDX()            EPL_MCO_INSTANCE_PARAM (EPL_MCO_GLB_VAR (m_bInstIndex))
--- a/drivers/staging/epl/EplNmtCnu.c
+++ b/drivers/staging/epl/EplNmtCnu.c
@@ -108,7 +108,7 @@ static tEplNmtCnuInstance EplNmtCnuInsta
 
 static tEplNmtCommand EplNmtCnuGetNmtCommand(tEplFrameInfo * pFrameInfo_p);
 
-static BOOL EplNmtCnuNodeIdList(BYTE * pbNmtCommandDate_p);
+static BOOL EplNmtCnuNodeIdList(u8 * pbNmtCommandDate_p);
 
 static tEplKernel EplNmtCnuCommandCb(tEplFrameInfo *pFrameInfo_p);
 
@@ -248,15 +248,15 @@ EPLDLLEXPORT tEplKernel EplNmtCnuSendNmt
 	EPL_MEMSET(&NmtRequestFrame.m_be_abSrcMac[0], 0x00, sizeof(NmtRequestFrame.m_be_abSrcMac));	// set by DLL
 	AmiSetWordToBe(&NmtRequestFrame.m_be_wEtherType,
 		       EPL_C_DLL_ETHERTYPE_EPL);
-	AmiSetByteToLe(&NmtRequestFrame.m_le_bDstNodeId, (BYTE) EPL_C_ADR_MN_DEF_NODE_ID);	// node id of the MN
+	AmiSetByteToLe(&NmtRequestFrame.m_le_bDstNodeId, (u8) EPL_C_ADR_MN_DEF_NODE_ID);	// node id of the MN
 	AmiSetByteToLe(&NmtRequestFrame.m_le_bMessageType,
-		       (BYTE) kEplMsgTypeAsnd);
+		       (u8) kEplMsgTypeAsnd);
 	AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_le_bServiceId,
-		       (BYTE) kEplDllAsndNmtRequest);
+		       (u8) kEplDllAsndNmtRequest);
 	AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.
 		       m_NmtRequestService.m_le_bNmtCommandId,
-		       (BYTE) NmtCommand_p);
-	AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.m_le_bTargetNodeId, (BYTE) uiNodeId_p);	// target for the nmt command
+		       (u8) NmtCommand_p);
+	AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.m_le_bTargetNodeId, (u8) uiNodeId_p);	// target for the nmt command
 	EPL_MEMSET(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.
 		   m_le_abNmtCommandData[0], 0x00,
 		   sizeof(NmtRequestFrame.m_Data.m_Asnd.m_Payload.
@@ -673,18 +673,18 @@ static tEplNmtCommand EplNmtCnuGetNmtCom
 // State:
 //
 //---------------------------------------------------------------------------
-static BOOL EplNmtCnuNodeIdList(BYTE * pbNmtCommandDate_p)
+static BOOL EplNmtCnuNodeIdList(u8 * pbNmtCommandDate_p)
 {
 	BOOL fNodeIdInList;
 	unsigned int uiByteOffset;
-	BYTE bBitOffset;
-	BYTE bNodeListByte;
+	u8 bBitOffset;
+	u8 bNodeListByte;
 
 	// get byte-offset of the own nodeid in NodeIdList
 	// devide though 8
 	uiByteOffset = (unsigned int)(EplNmtCnuInstance_g.m_uiNodeId >> 3);
 	// get bitoffset
-	bBitOffset = (BYTE) EplNmtCnuInstance_g.m_uiNodeId % 8;
+	bBitOffset = (u8) EplNmtCnuInstance_g.m_uiNodeId % 8;
 
 	bNodeListByte = AmiGetByteFromLe(&pbNmtCommandDate_p[uiByteOffset]);
 	if ((bNodeListByte & bBitOffset) == 0) {
--- a/drivers/staging/epl/EplNmtk.c
+++ b/drivers/staging/epl/EplNmtk.c
@@ -88,7 +88,7 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
--- a/drivers/staging/epl/EplNmtMnu.c
+++ b/drivers/staging/epl/EplNmtMnu.c
@@ -94,7 +94,7 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
@@ -417,7 +417,7 @@ tEplKernel EplNmtMnuSendNmtCommandEx(uns
 {
 	tEplKernel Ret = kEplSuccessful;
 	tEplFrameInfo FrameInfo;
-	BYTE abBuffer[EPL_C_DLL_MINSIZE_NMTCMDEXT];
+	u8 abBuffer[EPL_C_DLL_MINSIZE_NMTCMDEXT];
 	tEplFrame *pFrame = (tEplFrame *) abBuffer;
 	BOOL fSoftDeleteNode = FALSE;
 
@@ -437,11 +437,11 @@ tEplKernel EplNmtMnuSendNmtCommandEx(uns
 
 	// build frame
 	EPL_MEMSET(pFrame, 0x00, sizeof(abBuffer));
-	AmiSetByteToLe(&pFrame->m_le_bDstNodeId, (BYTE) uiNodeId_p);
+	AmiSetByteToLe(&pFrame->m_le_bDstNodeId, (u8) uiNodeId_p);
 	AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_le_bServiceId,
-		       (BYTE) kEplDllAsndNmtCommand);
+		       (u8) kEplDllAsndNmtCommand);
 	AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.
-		       m_le_bNmtCommandId, (BYTE) NmtCommand_p);
+		       m_le_bNmtCommandId, (u8) NmtCommand_p);
 	if ((pNmtCommandData_p != NULL) && (uiDataSize_p > 0)) {	// copy command data to frame
 		EPL_MEMCPY(&pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.
 			   m_le_abNmtCommandData[0], pNmtCommandData_p,
@@ -572,7 +572,7 @@ tEplKernel EplNmtMnuTriggerStateChange(u
 	tEplKernel Ret = kEplSuccessful;
 	tEplNmtMnuIntNodeEvent NodeEvent;
 	tEplObdSize ObdSize;
-	BYTE bNmtState;
+	u8 bNmtState;
 	WORD wErrorCode = EPL_E_NO_ERROR;
 
 	if ((uiNodeId_p == 0) || (uiNodeId_p >= EPL_C_ADR_BROADCAST)) {
@@ -967,7 +967,7 @@ EPLDLLEXPORT tEplKernel EplNmtMnuProcess
 					   EPL_NMTMNU_TIMERARG_NODE_MASK);
 			if (uiNodeId != 0) {
 				tEplObdSize ObdSize;
-				BYTE bNmtState;
+				u8 bNmtState;
 				tEplNmtMnuNodeInfo *pNodeInfo;
 
 				pNodeInfo = EPL_NMTMNU_GET_NODEINFO(uiNodeId);
@@ -1147,7 +1147,7 @@ EPLDLLEXPORT tEplKernel EplNmtMnuProcess
 			tEplFrame *pFrame = (tEplFrame *) pEvent_p->m_pArg;
 			unsigned int uiNodeId;
 			tEplNmtCommand NmtCommand;
-			BYTE bNmtState;
+			u8 bNmtState;
 
 			uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bDstNodeId);
 			NmtCommand =
@@ -1159,30 +1159,30 @@ EPLDLLEXPORT tEplKernel EplNmtMnuProcess
 			switch (NmtCommand) {
 			case kEplNmtCmdStartNode:
 				bNmtState =
-				    (BYTE) (kEplNmtCsOperational & 0xFF);
+				    (u8) (kEplNmtCsOperational & 0xFF);
 				break;
 
 			case kEplNmtCmdStopNode:
-				bNmtState = (BYTE) (kEplNmtCsStopped & 0xFF);
+				bNmtState = (u8) (kEplNmtCsStopped & 0xFF);
 				break;
 
 			case kEplNmtCmdEnterPreOperational2:
 				bNmtState =
-				    (BYTE) (kEplNmtCsPreOperational2 & 0xFF);
+				    (u8) (kEplNmtCsPreOperational2 & 0xFF);
 				break;
 
 			case kEplNmtCmdEnableReadyToOperate:
 				// d.k. do not change expected node state, because of DS 1.0.0 7.3.1.2.1 Plain NMT State Command
 				//      and because node may not change NMT state within EPL_C_NMT_STATE_TOLERANCE
 				bNmtState =
-				    (BYTE) (kEplNmtCsPreOperational2 & 0xFF);
+				    (u8) (kEplNmtCsPreOperational2 & 0xFF);
 				break;
 
 			case kEplNmtCmdResetNode:
 			case kEplNmtCmdResetCommunication:
 			case kEplNmtCmdResetConfiguration:
 			case kEplNmtCmdSwReset:
-				bNmtState = (BYTE) (kEplNmtCsNotActive & 0xFF);
+				bNmtState = (u8) (kEplNmtCsNotActive & 0xFF);
 				// EplNmtMnuProcessInternalEvent() sets internal node state to kEplNmtMnuNodeStateUnknown
 				// after next unresponded IdentRequest/StatusRequest
 				break;
@@ -1927,7 +1927,7 @@ static tEplKernel EplNmtMnuProcessIntern
 	switch (NodeEvent_p) {
 	case kEplNmtMnuIntNodeEventIdentResponse:
 		{
-			BYTE bNmtState;
+			u8 bNmtState;
 
 			EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
 							uiNodeId_p,
@@ -1954,7 +1954,7 @@ static tEplKernel EplNmtMnuProcessIntern
 				    ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
 			}
 			// update object 0x1F8F NMT_MNNodeExpState_AU8 to PreOp1 (even if local state >= PreOp2)
-			bNmtState = (BYTE) (kEplNmtCsPreOperational1 & 0xFF);
+			bNmtState = (u8) (kEplNmtCsPreOperational1 & 0xFF);
 			Ret =
 			    EplObduWriteEntry(0x1F8F, uiNodeId_p, &bNmtState,
 					      1);
@@ -2434,11 +2434,11 @@ static tEplKernel EplNmtMnuProcessIntern
 
 	case kEplNmtMnuIntNodeEventNmtCmdSent:
 		{
-			BYTE bNmtState;
+			u8 bNmtState;
 
 			// update expected NMT state with the one that results
 			// from the sent NMT command
-			bNmtState = (BYTE) (NodeNmtState_p & 0xFF);
+			bNmtState = (u8) (NodeNmtState_p & 0xFF);
 
 			// write object 0x1F8F NMT_MNNodeExpState_AU8
 			Ret =
@@ -2628,8 +2628,8 @@ static tEplKernel EplNmtMnuCheckNmtState
 {
 	tEplKernel Ret = kEplSuccessful;
 	tEplObdSize ObdSize;
-	BYTE bNmtState;
-	BYTE bNmtStatePrev;
+	u8 bNmtState;
+	u8 bNmtStatePrev;
 	tEplNmtState ExpNmtState;
 
 	ObdSize = 1;
@@ -2640,8 +2640,8 @@ static tEplKernel EplNmtMnuCheckNmtState
 	}
 	// compute expected NMT state
 	ExpNmtState = (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS);
-	// compute BYTE of current NMT state
-	bNmtState = ((BYTE) NodeNmtState_p & 0xFF);
+	// compute u8 of current NMT state
+	bNmtState = ((u8) NodeNmtState_p & 0xFF);
 
 	if (ExpNmtState == kEplNmtCsNotActive) {	// ignore the current state, because the CN shall be not active
 		Ret = kEplReject;
--- a/drivers/staging/epl/EplObd.c
+++ b/drivers/staging/epl/EplObd.c
@@ -123,7 +123,7 @@ typedef union {
 
 EPL_MCO_DECL_INSTANCE_VAR()
 
-BYTE abEplObdTrashObject_g[8];
+u8 abEplObdTrashObject_g[8];
 
 //---------------------------------------------------------------------------
 // local function prototypes
@@ -833,7 +833,7 @@ EPLDLLEXPORT unsigned int EplObdGetNodeI
 {
 	tEplKernel Ret;
 	tEplObdSize ObdSize;
-	BYTE bNodeId;
+	u8 bNodeId;
 
 	bNodeId = 0;
 	ObdSize = sizeof(bNodeId);
@@ -871,16 +871,16 @@ EPLDLLEXPORT tEplKernel EplObdSetNodeId(
 {
 	tEplKernel Ret;
 	tEplObdSize ObdSize;
-	BYTE fHwBool;
-	BYTE bNodeId;
+	u8 fHwBool;
+	u8 bNodeId;
 
 	// check Node Id
 	if (uiNodeId_p == EPL_C_ADR_INVALID) {
 		Ret = kEplInvalidNodeId;
 		goto Exit;
 	}
-	bNodeId = (BYTE) uiNodeId_p;
-	ObdSize = sizeof(BYTE);
+	bNodeId = (u8) uiNodeId_p;
+	ObdSize = sizeof(u8);
 	// write NodeId to OD entry
 	Ret = EplObdWriteEntry(EPL_MCO_PTR_INSTANCE_PTR_
 			       EPL_OBD_NODE_ID_INDEX,
@@ -1072,7 +1072,7 @@ EPLDLLEXPORT tEplKernel EplObdReadEntryT
 	case kEplObdTypInt8:
 	case kEplObdTypUInt8:
 		{
-			AmiSetByteToLe(pDstData_p, *((BYTE *) pSrcData));
+			AmiSetByteToLe(pDstData_p, *((u8 *) pSrcData));
 			break;
 		}
 
@@ -1222,7 +1222,7 @@ EPLDLLEXPORT tEplKernel EplObdWriteEntry
 	case kEplObdTypInt8:
 	case kEplObdTypUInt8:
 		{
-			*((BYTE *) pBuffer) = AmiGetByteFromLe(pSrcData_p);
+			*((u8 *) pBuffer) = AmiGetByteFromLe(pSrcData_p);
 			break;
 		}
 
@@ -1503,7 +1503,7 @@ static tEplObdSize EplObdGetStrLen(void 
 {
 
 	tEplObdSize StrLen = 0;
-	BYTE *pbString;
+	u8 *pbString;
 
 	if (pObjData_p == NULL) {
 		goto Exit;
@@ -2094,7 +2094,7 @@ static tEplKernel EplObdWriteEntryPost(E
 // Function:    EplObdGetObjectSize()
 //
 // Description: function to get size of object
-//              The function determines if an object type an fixed data type (BYTE, WORD, ...)
+//              The function determines if an object type an fixed data type (u8, WORD, ...)
 //              or non fixed object (string, domain). This information is used to decide
 //              if download data are stored temporary or not. For objects with fixed data length
 //              and types a value range checking can process.
@@ -2463,7 +2463,7 @@ static void *EplObdGetObjectCurrentPtr(t
 			} else {
 				Size = EplObdGetObjectSize(pSubIndexEntry_p);
 			}
-			pData = ((BYTE *) pData) + (Size * uiArrayIndex);
+			pData = ((u8 *) pData) + (Size * uiArrayIndex);
 		}
 		// check if VarEntry
 		if ((pSubIndexEntry_p->m_Access & kEplObdAccVar) != 0) {
@@ -2772,14 +2772,14 @@ static tEplKernel EplObdAccessOdPartInte
 	Ret = kEplSuccessful;
 
 	// prepare structure for STORE RESTORE callback function
-	CbStore.m_bCurrentOdPart = (BYTE) CurrentOdPart_p;
+	CbStore.m_bCurrentOdPart = (u8) CurrentOdPart_p;
 	CbStore.m_pData = NULL;
 	CbStore.m_ObjSize = 0;
 
 	// command of first action depends on direction to access
 #if (EPL_OBD_USE_STORE_RESTORE != FALSE)
 	if (Direction_p == kEplObdDirLoad) {
-		CbStore.m_bCommand = (BYTE) kEplObdCommOpenRead;
+		CbStore.m_bCommand = (u8) kEplObdCommOpenRead;
 
 		// call callback function for previous command
 		Ret = EplObdCallStoreCallback(EPL_MCO_INSTANCE_PTR_ & CbStore);
@@ -2787,9 +2787,9 @@ static tEplKernel EplObdAccessOdPartInte
 			goto Exit;
 		}
 		// set command for index and subindex loop
-		CbStore.m_bCommand = (BYTE) kEplObdCommReadObj;
+		CbStore.m_bCommand = (u8) kEplObdCommReadObj;
 	} else if (Direction_p == kEplObdDirStore) {
-		CbStore.m_bCommand = (BYTE) kEplObdCommOpenWrite;
+		CbStore.m_bCommand = (u8) kEplObdCommOpenWrite;
 
 		// call callback function for previous command
 		Ret = EplObdCallStoreCallback(EPL_MCO_INSTANCE_PTR_ & CbStore);
@@ -2797,7 +2797,7 @@ static tEplKernel EplObdAccessOdPartInte
 			goto Exit;
 		}
 		// set command for index and subindex loop
-		CbStore.m_bCommand = (BYTE) kEplObdCommWriteObj;
+		CbStore.m_bCommand = (u8) kEplObdCommWriteObj;
 	}
 #endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
 
@@ -2848,7 +2848,7 @@ static tEplKernel EplObdAccessOdPartInte
                             }
                             else
                             {
-                                EplObdInitVarEntry ((tEplObdVarEntry *) (((BYTE *) pSubIndex->m_pCurrent) + (sizeof (tEplObdVarEntry) * pSubIndex->m_uiSubIndex)),
+                                EplObdInitVarEntry ((tEplObdVarEntry *) (((u8 *) pSubIndex->m_pCurrent) + (sizeof (tEplObdVarEntry) * pSubIndex->m_uiSubIndex)),
                                     pSubIndex->m_Type, ObjSize);
                             }
 */
@@ -3003,11 +3003,11 @@ static tEplKernel EplObdAccessOdPartInte
 #if (EPL_OBD_USE_STORE_RESTORE != FALSE)
 	else {
 		if (Direction_p == kEplObdDirLoad) {
-			CbStore.m_bCommand = (BYTE) kEplObdCommCloseRead;
+			CbStore.m_bCommand = (u8) kEplObdCommCloseRead;
 		} else if (Direction_p == kEplObdDirStore) {
-			CbStore.m_bCommand = (BYTE) kEplObdCommCloseWrite;
+			CbStore.m_bCommand = (u8) kEplObdCommCloseWrite;
 		} else if (Direction_p == kEplObdDirRestore) {
-			CbStore.m_bCommand = (BYTE) kEplObdCommClear;
+			CbStore.m_bCommand = (u8) kEplObdCommClear;
 		} else {
 			goto Exit;
 		}
--- a/drivers/staging/epl/EplObd.h
+++ b/drivers/staging/epl/EplObd.h
@@ -309,7 +309,7 @@ typedef struct {
 
 typedef struct {
 	tEplObdSize m_Size;
-	BYTE *m_pString;
+	u8 *m_pString;
 
 } tEplObdOString;		// 000C
 
@@ -327,8 +327,8 @@ typedef struct {
 
 typedef struct {
 	tEplObdSize m_Size;
-	BYTE *m_pDefString;	// $$$ d.k. it is unused, so we could delete it
-	BYTE *m_pString;
+	u8 *m_pDefString;	// $$$ d.k. it is unused, so we could delete it
+	u8 *m_pString;
 
 } tEplObdOStringDef;
 
@@ -431,7 +431,7 @@ typedef struct {
 	unsigned int m_uiUpperObjIndex;	// upper limit of ObjIndex
 	tInitTabEntryCallback m_fpInitTabEntry;	// will be called if ObjIndex was found
 	void *m_pTabBase;	// base address of table
-	unsigned int m_uiEntrySize;	// size of table entry      // 25-feb-2005 r.d.: expansion from BYTE to WORD necessary for PDO bit mapping
+	unsigned int m_uiEntrySize;	// size of table entry      // 25-feb-2005 r.d.: expansion from u8 to WORD necessary for PDO bit mapping
 	unsigned int m_uiMaxEntries;	// max. tabel entries
 
 } tEplObdModulTabParam;
--- a/drivers/staging/epl/EplObdMacro.h
+++ b/drivers/staging/epl/EplObdMacro.h
@@ -105,8 +105,8 @@
 #define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)                 static char  szCur##ind##_##sub##_g[size+1]; \
                                                                                         static  tEplObdVStringDef  xDef##ind##_##sub##_g = {size, val, szCur##ind##_##sub##_g};
 
-#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)                     static  BYTE  bCur##ind##_##sub##_g[size]; \
-                                                                                        static  tEplObdOStringDef  xDef##ind##_##sub##_g = {size, ((BYTE*)""), bCur##ind##_##sub##_g};
+#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)                     static  u8  bCur##ind##_##sub##_g[size]; \
+                                                                                        static  tEplObdOStringDef  xDef##ind##_##sub##_g = {size, ((u8*)""), bCur##ind##_##sub##_g};
 #define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
 #define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)             static  dtyp  xDef##ind##_##sub##_g        = val;
 #define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high) static  dtyp  xDef##ind##_##sub##_g[3]     = {val,low,high};
--- a/drivers/staging/epl/EplObdu.c
+++ b/drivers/staging/epl/EplObdu.c
@@ -275,7 +275,7 @@ EPLDLLEXPORT tEplKernel EplObduRegisterU
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT void EplObduInitVarEntry(tEplObdVarEntry *pVarEntry_p,
-				      BYTE bType_p, tEplObdSize ObdSize_p)
+				      u8 bType_p, tEplObdSize ObdSize_p)
 {
 	EplObduCalInitVarEntry(pVarEntry_p, bType_p, ObdSize_p);
 }
--- a/drivers/staging/epl/EplObduCal.c
+++ b/drivers/staging/epl/EplObduCal.c
@@ -297,7 +297,7 @@ EPLDLLEXPORT tEplKernel EplObduCalRegist
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT void EplObduCalInitVarEntry(tEplObdVarEntry *pVarEntry_p,
-					 BYTE bType_p, tEplObdSize ObdSize_p)
+					 u8 bType_p, tEplObdSize ObdSize_p)
 {
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
 	EplObdInitVarEntry(pVarEntry_p, bType_p, ObdSize_p);
--- a/drivers/staging/epl/EplPdo.h
+++ b/drivers/staging/epl/EplPdo.h
@@ -104,7 +104,7 @@ typedef struct {
 	//               TPDO: 0x00=PRes, MN: CnNodeId=PReq
 
 	BOOL m_fTxRx;
-	BYTE m_bMappingVersion;
+	u8 m_bMappingVersion;
 	unsigned int m_uiMaxMappingEntries;	// maximum number of mapping entries, i.e. size of m_aPdoMapping
 	tEplPdoMapping m_aPdoMapping[1];
 
--- a/drivers/staging/epl/EplPdok.c
+++ b/drivers/staging/epl/EplPdok.c
@@ -319,14 +319,14 @@ tEplKernel EplPdokProcess(tEplEvent * pE
 	WORD wBitSize;
 	WORD wVarSize;
 	QWORD qwObjectMapping;
-	BYTE bMappSubindex;
-	BYTE bObdSubindex;
+	u8 bMappSubindex;
+	u8 bObdSubindex;
 	WORD wObdMappIndex;
 	WORD wObdCommIndex;
 	WORD wPdoId;
-	BYTE bObdData;
-	BYTE bObjectCount;
-	BYTE bFrameData;
+	u8 bObdData;
+	u8 bObjectCount;
+	u8 bFrameData;
 	BOOL fValid;
 	tEplObdSize ObdSize;
 	tEplFrame *pFrame;
@@ -441,7 +441,7 @@ tEplKernel EplPdokProcess(tEplEvent * pE
 				    (WORD) (qwObjectMapping &
 					    0x000000000000FFFFLL);
 				bObdSubindex =
-				    (BYTE) ((qwObjectMapping &
+				    (u8) ((qwObjectMapping &
 					     0x0000000000FF0000LL) >> 16);
 				wBitOffset =
 				    (WORD) ((qwObjectMapping &
@@ -571,7 +571,7 @@ tEplKernel EplPdokProcess(tEplEvent * pE
 				    (WORD) (qwObjectMapping &
 					    0x000000000000FFFFLL);
 				bObdSubindex =
-				    (BYTE) ((qwObjectMapping &
+				    (u8) ((qwObjectMapping &
 					     0x0000000000FF0000LL) >> 16);
 				wBitOffset =
 				    (WORD) ((qwObjectMapping &
--- a/drivers/staging/epl/EplPdou.c
+++ b/drivers/staging/epl/EplPdou.c
@@ -232,10 +232,10 @@ tEplKernel EplPdouCbObdAccess(tEplObdCbP
 	unsigned int uiPdoId;
 	unsigned int uiIndexType;
 	tEplObdSize ObdSize;
-	BYTE bObjectCount;
+	u8 bObjectCount;
 	QWORD qwObjectMapping;
 	tEplObdAccess AccessType;
-	BYTE bMappSubindex;
+	u8 bMappSubindex;
 	unsigned int uiCurPdoSize;
 	WORD wMaxPdoSize;
 	unsigned int uiSubIndex;
@@ -293,7 +293,7 @@ tEplKernel EplPdouCbObdAccess(tEplObdCbP
 	if (pParam_p->m_uiSubIndex == 0) {	// object mapping count accessed
 
 		// PDO is enabled or disabled
-		bObjectCount = *((BYTE *) pParam_p->m_pArg);
+		bObjectCount = *((u8 *) pParam_p->m_pArg);
 
 		if (bObjectCount == 0) {	// PDO shall be disabled
 
@@ -399,7 +399,7 @@ static tEplKernel EplPdouCheckPdoValidit
 {
 	tEplKernel Ret = kEplSuccessful;
 	tEplObdSize ObdSize;
-	BYTE bObjectCount;
+	u8 bObjectCount;
 
 	ObdSize = 1;
 	// read number of mapped objects from OD; this indicates if the PDO is valid
--- a/drivers/staging/epl/EplSdoAsndu.c
+++ b/drivers/staging/epl/EplSdoAsndu.c
@@ -339,10 +339,10 @@ tEplKernel EplSdoAsnduSendData(tEplSdoCo
 	// own node id not needed -> filled by DLL
 
 	// set message type
-	AmiSetByteToLe(&pSrcData_p->m_le_bMessageType, (BYTE) kEplMsgTypeAsnd);	// ASnd == 0x06
+	AmiSetByteToLe(&pSrcData_p->m_le_bMessageType, (u8) kEplMsgTypeAsnd);	// ASnd == 0x06
 	// target node id
 	AmiSetByteToLe(&pSrcData_p->m_le_bDstNodeId,
-		       (BYTE) SdoAsndInstance_g.
+		       (u8) SdoAsndInstance_g.
 		       m_auiSdoAsndConnection[uiArray]);
 	// set source-nodeid (filled by DLL 0)
 	AmiSetByteToLe(&pSrcData_p->m_le_bSrcNodeId, 0x00);
--- a/drivers/staging/epl/EplSdoAsySequ.c
+++ b/drivers/staging/epl/EplSdoAsySequ.c
@@ -128,11 +128,11 @@ typedef enum {
 
 // structure for History-Buffer
 typedef struct {
-	BYTE m_bFreeEntries;
-	BYTE m_bWrite;		// index of the next free buffer entry
-	BYTE m_bAck;		// index of the next message which should become acknowledged
-	BYTE m_bRead;		// index between m_bAck and m_bWrite to the next message for retransmission
-	BYTE m_aabHistoryFrame[EPL_SDO_HISTORY_SIZE]
+	u8 m_bFreeEntries;
+	u8 m_bWrite;		// index of the next free buffer entry
+	u8 m_bAck;		// index of the next message which should become acknowledged
+	u8 m_bRead;		// index between m_bAck and m_bWrite to the next message for retransmission
+	u8 m_aabHistoryFrame[EPL_SDO_HISTORY_SIZE]
 	    [EPL_SEQ_HISTROY_FRAME_SIZE];
 	unsigned int m_auiFrameSize[EPL_SDO_HISTORY_SIZE];
 
@@ -152,8 +152,8 @@ typedef enum {
 typedef struct {
 	tEplSdoConHdl m_ConHandle;
 	tEplAsySdoState m_SdoState;
-	BYTE m_bRecSeqNum;	// name from view of the communication partner
-	BYTE m_bSendSeqNum;	// name from view of the communication partner
+	u8 m_bRecSeqNum;	// name from view of the communication partner
+	u8 m_bSendSeqNum;	// name from view of the communication partner
 	tEplAsySdoConHistory m_SdoConHistory;
 	tEplTimerHdl m_EplTimerHdl;
 	unsigned int m_uiRetryCount;	// retry counter
@@ -214,7 +214,7 @@ static tEplKernel EplSdoAsyAddFrameToHis
 					     unsigned int uiSize_p);
 
 static tEplKernel EplSdoAsyAckFrameToHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
-					     BYTE bRecSeqNumber_p);
+					     u8 bRecSeqNumber_p);
 
 static tEplKernel EplSdoAsyReadFromHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
 					   tEplFrame ** ppFrame_p,
@@ -1498,7 +1498,7 @@ static tEplKernel EplSdoAsySeqProcess(un
 				// frame received
 			case kAsySdoSeqEventFrameRec:
 				{
-					BYTE bSendSeqNumCon =
+					u8 bSendSeqNumCon =
 					    AmiGetByteFromLe(&pRecFrame_p->
 							     m_le_bSendSeqNumCon);
 
@@ -2016,7 +2016,7 @@ static tEplKernel EplSdoAsySeqSendIntern
 					 BOOL fFrameInHistory_p)
 {
 	tEplKernel Ret;
-	BYTE abFrame[EPL_SEQ_FRAME_SIZE];
+	u8 abFrame[EPL_SEQ_FRAME_SIZE];
 	tEplFrame *pEplFrame;
 	unsigned int uiFreeEntries;
 
@@ -2154,7 +2154,7 @@ tEplKernel EplSdoAsyReceiveCb(tEplSdoCon
 #endif
 
 	EPL_DBGLVL_SDO_TRACE2("Handle: 0x%x , First Databyte 0x%x\n", ConHdl_p,
-			      ((BYTE *) pSdoSeqData_p)[0]);
+			      ((u8 *) pSdoSeqData_p)[0]);
 
 	// search controll structure for this connection
 	pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiCount];
@@ -2328,12 +2328,12 @@ static tEplKernel EplSdoAsyAddFrameToHis
 //
 //---------------------------------------------------------------------------
 static tEplKernel EplSdoAsyAckFrameToHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
-					     BYTE bRecSeqNumber_p)
+					     u8 bRecSeqNumber_p)
 {
 	tEplKernel Ret;
 	tEplAsySdoConHistory *pHistory;
-	BYTE bAckIndex;
-	BYTE bCurrentSeqNum;
+	u8 bAckIndex;
+	u8 bCurrentSeqNum;
 
 	Ret = kEplSuccessful;
 
--- a/drivers/staging/epl/EplSdoComu.c
+++ b/drivers/staging/epl/EplSdoComu.c
@@ -156,14 +156,14 @@ typedef enum {
 typedef struct {
 	tEplSdoSeqConHdl m_SdoSeqConHdl;	// if != 0 -> entry used
 	tEplSdoComState m_SdoComState;
-	BYTE m_bTransactionId;
+	u8 m_bTransactionId;
 	unsigned int m_uiNodeId;	// NodeId of the target
 	// -> needed to reinit connection
 	//    after timeout
 	tEplSdoTransType m_SdoTransType;	// Auto, Expedited, Segmented
 	tEplSdoServiceType m_SdoServiceType;	// WriteByIndex, ReadByIndex
 	tEplSdoType m_SdoProtType;	// protocol layer: Auto, Udp, Asnd, Pdo
-	BYTE *m_pData;		// pointer to data
+	u8 *m_pData;		// pointer to data
 	unsigned int m_uiTransSize;	// number of bytes
 	// to transfer
 	unsigned int m_uiTransferredByte;	// number of bytes
@@ -765,7 +765,7 @@ tEplKernel EplSdoComSdoAbort(tEplSdoComC
 		goto Exit;
 	}
 	// save pointer to abort code
-	pSdoComCon->m_pData = (BYTE *) & dwAbortCode_p;
+	pSdoComCon->m_pData = (u8 *) & dwAbortCode_p;
 
 	Ret = EplSdoComProcessIntern(SdoComConHdl_p,
 				     kEplSdoComConEventAbort,
@@ -998,7 +998,7 @@ static tEplKernel EplSdoComProcessIntern
 {
 	tEplKernel Ret;
 	tEplSdoComCon *pSdoComCon;
-	BYTE bFlag;
+	u8 bFlag;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
 	DWORD dwAbortCode;
@@ -1137,7 +1137,7 @@ static tEplKernel EplSdoComProcessIntern
 									pSdoComCon->
 									    m_pData
 									    =
-									    (BYTE
+									    (u8
 									     *)
 									    &
 									    dwAbortCode;
@@ -1282,7 +1282,7 @@ static tEplKernel EplSdoComProcessIntern
 							if (pSdoComCon->
 							    m_dwLastAbortCode ==
 							    0) {
-								( /*(BYTE*) */
+								( /*(u8*) */
 								 pSdoComCon->
 								 m_pData) +=
 						      uiSize;
@@ -1320,7 +1320,7 @@ static tEplKernel EplSdoComProcessIntern
 									pSdoComCon->
 									    m_pData
 									    =
-									    (BYTE
+									    (u8
 									     *)
 									    &
 									    pSdoComCon->
@@ -1986,7 +1986,7 @@ static tEplKernel EplSdoComServerInitRea
 	if (Ret == kEplObdSubindexNotExist) {	// subentry doesn't exist
 		dwAbortCode = EPL_SDOAC_SUB_INDEX_NOT_EXIST;
 		// send abort
-		pSdoComCon_p->m_pData = (BYTE *) & dwAbortCode;
+		pSdoComCon_p->m_pData = (u8 *) & dwAbortCode;
 		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
 						     uiIndex,
 						     uiSubindex,
@@ -1995,7 +1995,7 @@ static tEplKernel EplSdoComServerInitRea
 	} else if (Ret != kEplSuccessful) {	// entry doesn't exist
 		dwAbortCode = EPL_SDOAC_OBJECT_NOT_EXIST;
 		// send abort
-		pSdoComCon_p->m_pData = (BYTE *) & dwAbortCode;
+		pSdoComCon_p->m_pData = (u8 *) & dwAbortCode;
 		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
 						     uiIndex,
 						     uiSubindex,
@@ -2013,7 +2013,7 @@ static tEplKernel EplSdoComServerInitRea
 			dwAbortCode = EPL_SDOAC_UNSUPPORTED_ACCESS;
 		}
 		// send abort
-		pSdoComCon_p->m_pData = (BYTE *) & dwAbortCode;
+		pSdoComCon_p->m_pData = (u8 *) & dwAbortCode;
 		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
 						     uiIndex,
 						     uiSubindex,
@@ -2050,7 +2050,7 @@ static tEplKernel EplSdoComServerInitRea
 		// error -> abort
 		dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
 		// send abort
-		pSdoComCon_p->m_pData = (BYTE *) & dwAbortCode;
+		pSdoComCon_p->m_pData = (u8 *) & dwAbortCode;
 		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
 						     uiIndex,
 						     uiSubindex,
@@ -2089,11 +2089,11 @@ static tEplKernel EplSdoComServerSendFra
 						 tEplSdoComSendType SendType_p)
 {
 	tEplKernel Ret;
-	BYTE abFrame[EPL_MAX_SDO_FRAME_SIZE];
+	u8 abFrame[EPL_MAX_SDO_FRAME_SIZE];
 	tEplFrame *pFrame;
 	tEplAsySdoCom *pCommandFrame;
 	unsigned int uiSizeOfFrame;
-	BYTE bFlag;
+	u8 bFlag;
 
 	Ret = kEplSuccessful;
 
@@ -2373,7 +2373,7 @@ static tEplKernel EplSdoComServerInitWri
 	tEplObdSize EntrySize;
 	tEplObdAccess AccessType;
 	DWORD dwAbortCode;
-	BYTE *pbSrcData;
+	u8 *pbSrcData;
 
 	dwAbortCode = 0;
 
@@ -2426,7 +2426,7 @@ static tEplKernel EplSdoComServerInitWri
 		pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_SUB_INDEX_NOT_EXIST;
 		// send abort
 		// d.k. This is wrong: k.t. not needed send abort on end of write
-		/*pSdoComCon_p->m_pData = (BYTE*)pSdoComCon_p->m_dwLastAbortCode;
+		/*pSdoComCon_p->m_pData = (u8*)pSdoComCon_p->m_dwLastAbortCode;
 		   Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
 		   uiIndex,
 		   uiSubindex,
@@ -2437,7 +2437,7 @@ static tEplKernel EplSdoComServerInitWri
 		// send abort
 		// d.k. This is wrong: k.t. not needed send abort on end of write
 		/*
-		   pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
+		   pSdoComCon_p->m_pData = (u8*)&dwAbortCode;
 		   Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
 		   uiIndex,
 		   uiSubindex,
@@ -2457,7 +2457,7 @@ static tEplKernel EplSdoComServerInitWri
 		}
 		// send abort
 		// d.k. This is wrong: k.t. not needed send abort on end of write
-		/*pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
+		/*pSdoComCon_p->m_pData = (u8*)&dwAbortCode;
 		   Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
 		   uiIndex,
 		   uiSubindex,
@@ -2548,7 +2548,7 @@ static tEplKernel EplSdoComServerInitWri
 			    EPL_SDOAC_DATA_TYPE_LENGTH_TOO_HIGH;
 			// send abort
 			// d.k. This is wrong: k.t. not needed send abort on end of write
-			/*pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
+			/*pSdoComCon_p->m_pData = (u8*)&dwAbortCode;
 			   Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
 			   uiIndex,
 			   uiSubindex,
@@ -2570,7 +2570,7 @@ static tEplKernel EplSdoComServerInitWri
 			    EPL_SDOAC_GENERAL_ERROR;
 			// send abort
 			// d.k. This is wrong: k.t. not needed send abort on end of write
-/*            pSdoComCon_p->m_pData = (BYTE*)&pSdoComCon_p->m_dwLastAbortCode;
+/*            pSdoComCon_p->m_pData = (u8*)&pSdoComCon_p->m_dwLastAbortCode;
             Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
                                         uiIndex,
                                         uiSubindex,
@@ -2585,7 +2585,7 @@ static tEplKernel EplSdoComServerInitWri
 		pSdoComCon_p->m_uiTransSize -= uiBytesToTransfer;
 
 		// update target pointer
-		( /*(BYTE*) */ pSdoComCon_p->m_pData) += uiBytesToTransfer;
+		( /*(u8*) */ pSdoComCon_p->m_pData) += uiBytesToTransfer;
 
 		// send acknowledge without any Command layer data
 		Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
@@ -2597,7 +2597,7 @@ static tEplKernel EplSdoComServerInitWri
 	if (pSdoComCon_p->m_dwLastAbortCode != 0) {
 		// send abort
 		pSdoComCon_p->m_pData =
-		    (BYTE *) & pSdoComCon_p->m_dwLastAbortCode;
+		    (u8 *) & pSdoComCon_p->m_dwLastAbortCode;
 		Ret =
 		    EplSdoComServerSendFrameIntern(pSdoComCon_p, uiIndex,
 						   uiSubindex,
@@ -2634,12 +2634,12 @@ static tEplKernel EplSdoComServerInitWri
 static tEplKernel EplSdoComClientSend(tEplSdoComCon * pSdoComCon_p)
 {
 	tEplKernel Ret;
-	BYTE abFrame[EPL_MAX_SDO_FRAME_SIZE];
+	u8 abFrame[EPL_MAX_SDO_FRAME_SIZE];
 	tEplFrame *pFrame;
 	tEplAsySdoCom *pCommandFrame;
 	unsigned int uiSizeOfFrame;
-	BYTE bFlags;
-	BYTE *pbPayload;
+	u8 bFlags;
+	u8 *pbPayload;
 
 	Ret = kEplSuccessful;
 
@@ -2683,7 +2683,7 @@ static tEplKernel EplSdoComClientSend(tE
 						       m_uiTargetIndex);
 					pbPayload += 2;
 					AmiSetByteToLe(pbPayload,
-						       (BYTE) pSdoComCon_p->
+						       (u8) pSdoComCon_p->
 						       m_uiTargetSubIndex);
 					// calc size
 					uiSizeOfFrame += 4;
@@ -2725,7 +2725,7 @@ static tEplKernel EplSdoComClientSend(tE
 							       m_uiTargetIndex);
 						pbPayload += 2;
 						AmiSetByteToLe(pbPayload,
-							       (BYTE)
+							       (u8)
 							       pSdoComCon_p->
 							       m_uiTargetSubIndex);
 						// on byte for reserved
@@ -2764,7 +2764,7 @@ static tEplKernel EplSdoComClientSend(tE
 							       m_uiTargetIndex);
 						pbPayload += 2;
 						AmiSetByteToLe(pbPayload,
-							       (BYTE)
+							       (u8)
 							       pSdoComCon_p->
 							       m_uiTargetSubIndex);
 						// + 2 -> one byte for subindex and one byte reserved
@@ -2943,7 +2943,7 @@ static tEplKernel EplSdoComClientProcess
 					      tEplAsySdoCom * pAsySdoCom_p)
 {
 	tEplKernel Ret;
-	BYTE bBuffer;
+	u8 bBuffer;
 	unsigned int uiBuffer;
 	unsigned int uiDataSize;
 	unsigned long ulBuffer;
@@ -3219,7 +3219,7 @@ static tEplKernel EplSdoComClientSendAbo
 					   DWORD dwAbortCode_p)
 {
 	tEplKernel Ret;
-	BYTE abFrame[EPL_MAX_SDO_FRAME_SIZE];
+	u8 abFrame[EPL_MAX_SDO_FRAME_SIZE];
 	tEplFrame *pFrame;
 	tEplAsySdoCom *pCommandFrame;
 	unsigned int uiSizeOfFrame;
--- a/drivers/staging/epl/EplSdoUdpu.c
+++ b/drivers/staging/epl/EplSdoUdpu.c
@@ -550,7 +550,7 @@ static int EplSdoUdpThread(void *pArg_p)
 	int iError;
 	int iCount;
 	int iFreeEntry;
-	BYTE abBuffer[EPL_MAX_SDO_REC_FRAME_SIZE];
+	u8 abBuffer[EPL_MAX_SDO_REC_FRAME_SIZE];
 	unsigned int uiSize;
 	tEplSdoConHdl SdoConHdl;
 
--- a/drivers/staging/epl/EplTarget.h
+++ b/drivers/staging/epl/EplTarget.h
@@ -134,8 +134,8 @@
 // functions for ethernet driver
 tEplKernel TgtInitEthIsr(void);
 void TgtFreeEthIsr(void);
-void TgtEnableGlobalInterrupt(BYTE fEnable_p);
-void TgtEnableEthInterrupt0(BYTE fEnable_p, unsigned int uiInterruptMask_p);
-void TgtEnableEthInterrupt1(BYTE fEnable_p, unsigned int uiInterruptMask_p);
+void TgtEnableGlobalInterrupt(u8 fEnable_p);
+void TgtEnableEthInterrupt0(u8 fEnable_p, unsigned int uiInterruptMask_p);
+void TgtEnableEthInterrupt1(u8 fEnable_p, unsigned int uiInterruptMask_p);
 
 #endif // #ifndef _EPLTARGET_H_
--- a/drivers/staging/epl/global.h
+++ b/drivers/staging/epl/global.h
@@ -30,9 +30,6 @@
 #define TRACE  printk
 
 // --- logic types ---
-#ifndef BYTE
-#define BYTE unsigned char
-#endif
 #ifndef WORD
 #define WORD unsigned short int
 #endif
--- a/drivers/staging/epl/kernel/EplDllkCal.h
+++ b/drivers/staging/epl/kernel/EplDllkCal.h
@@ -124,7 +124,7 @@ tEplKernel EplDllkCalProcess(tEplEvent *
 tEplKernel EplDllkCalAsyncClearQueues(void);
 
 tEplKernel EplDllkCalIssueRequest(tEplDllReqServiceId Service_p,
-				  unsigned int uiNodeId_p, BYTE bSoaFlag1_p);
+				  unsigned int uiNodeId_p, u8 bSoaFlag1_p);
 
 tEplKernel EplDllkCalAsyncGetSoaRequest(tEplDllReqServiceId * pReqServiceId_p,
 					unsigned int *puiNodeId_p);
--- a/drivers/staging/epl/kernel/EplDllk.h
+++ b/drivers/staging/epl/kernel/EplDllk.h
@@ -85,7 +85,7 @@
 typedef tEplKernel(*tEplDllkCbAsync) (tEplFrameInfo * pFrameInfo_p);
 
 typedef struct {
-	BYTE m_be_abSrcMac[6];
+	u8 m_be_abSrcMac[6];
 
 } tEplDllkInitParam;
 
@@ -100,8 +100,8 @@ struct _tEplDllkNodeInfo {
 	unsigned long m_ulDllErrorEvents;
 	tEplNmtState m_NmtState;
 	WORD m_wPresPayloadLimit;
-	BYTE m_be_abMacAddr[6];
-	BYTE m_bSoaFlag1;
+	u8 m_be_abMacAddr[6];
+	u8 m_bSoaFlag1;
 	BOOL m_fSoftDelete;	// delete node after error and ignore error
 
 };
@@ -154,7 +154,7 @@ tEplKernel EplDllkDeleteNode(unsigned in
 
 tEplKernel EplDllkSoftDeleteNode(unsigned int uiNodeId_p);
 
-tEplKernel EplDllkSetFlag1OfNode(unsigned int uiNodeId_p, BYTE bSoaFlag1_p);
+tEplKernel EplDllkSetFlag1OfNode(unsigned int uiNodeId_p, u8 bSoaFlag1_p);
 
 tEplKernel EplDllkGetFirstNodeInfo(tEplDllkNodeInfo ** ppNodeInfo_p);
 
--- a/drivers/staging/epl/kernel/EplObdk.h
+++ b/drivers/staging/epl/kernel/EplObdk.h
@@ -85,7 +85,7 @@
 // global variables
 //---------------------------------------------------------------------------
 
-extern BYTE abEplObdTrashObject_g[8];
+extern u8 abEplObdTrashObject_g[8];
 
 //---------------------------------------------------------------------------
 // function prototypes
--- a/drivers/staging/epl/proc_fs.c
+++ b/drivers/staging/epl/proc_fs.c
@@ -145,7 +145,7 @@ static int EplLinProcRead(char *pcBuffer
 static int EplLinProcWrite(struct file *file, const char __user * buffer,
 			   unsigned long count, void *data);
 
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 
 EPLDLLEXPORT DWORD EplIdentuGetRunningRequests(void);
@@ -191,7 +191,7 @@ tEplKernel EplLinProcFree(void)
 //---------------------------------------------------------------------------
 
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p)
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p)
 {
 
 	if (bTracePointNumber_p >=
--- a/drivers/staging/epl/ShbIpc-LinuxKernel.c
+++ b/drivers/staging/epl/ShbIpc-LinuxKernel.c
@@ -677,7 +677,7 @@ void *ShbIpcGetShMemPtr(tShbInstance pSh
 	pShbMemHeader =
 	    ShbIpcGetShbMemHeader(ShbIpcGetShbMemInst(pShbInstance_p));
 	if (pShbMemHeader != NULL) {
-		pShbShMemPtr = (BYTE *) pShbMemHeader + sizeof(tShbMemHeader);
+		pShbShMemPtr = (u8 *) pShbMemHeader + sizeof(tShbMemHeader);
 	} else {
 		pShbShMemPtr = NULL;
 	}
--- a/drivers/staging/epl/TimerHighReskX86.c
+++ b/drivers/staging/epl/TimerHighReskX86.c
@@ -103,7 +103,7 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-void TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
 void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
--- a/drivers/staging/epl/user/EplCfgMau.h
+++ b/drivers/staging/epl/user/EplCfgMau.h
@@ -133,18 +133,18 @@ typedef struct {
 	tEplSdoComConHdl m_SdoComConHdl;	// handle for sdo connection
 	DWORD m_dwLastAbortCode;
 	unsigned int m_uiLastIndex;	// last index of configuration, to compair with actual index
-	BYTE *m_pbConcise;	// Ptr to concise DCF
-	BYTE *m_pbActualIndex;	// Ptr to actual index in the DCF segment
+	u8 *m_pbConcise;	// Ptr to concise DCF
+	u8 *m_pbActualIndex;	// Ptr to actual index in the DCF segment
 	tfpEplCfgMaCb m_pfnCfgMaCb;	// Ptr to CfgMa Callback, is call if configuration finished
 	tEplKernel m_EplKernelError;	// errorcode
 	DWORD m_dwNumValueCopy;	// numeric values are copied in this variable
 	unsigned int m_uiPdoNodeId;	// buffer for PDO node id
-	BYTE m_bNrOfMappedObject;	// number of mapped objects
+	u8 m_bNrOfMappedObject;	// number of mapped objects
 	unsigned int m_uiNodeId;	// Epl node addresse
 	tEplSdocState m_SdocState;	// bitcoded state of the SDO transfer
 	unsigned int m_uiLastSubIndex;	// last subindex of configuration
 	BOOL m_fOneTranferOk;	// atleased one transfer was successful
-	BYTE m_bEventFlag;	// for Eventsignaling to the State Maschine
+	u8 m_bEventFlag;	// for Eventsignaling to the State Maschine
 	DWORD m_dwCntObjectInDcf;	// number of Objects in DCF
 	tEplCfgMaIndexType m_SkipCfg;	// TRUE if a adsitional Configurationprocess
 	// have to insert e.g. PDO-mapping
@@ -199,13 +199,13 @@ tEplKernel plCfgMaDelInstance(void);
 // Parameters:  uiNodeId_p              = NodeId of the node to configure
 //              pbConcise_p             = pointer to DCF
 //              fpCfgMaCb_p             = pointer to callback function (should not be NULL)
-//              SizeOfConcise_p         = size of DCF in BYTE -> for future use
+//              SizeOfConcise_p         = size of DCF in u8 -> for future use
 //              DcfType_p               = type of the DCF
 //
 // Returns:     tCopKernel              = error code
 //---------------------------------------------------------------------------
 tEplKernel EplCfgMaStartConfig(unsigned int uiNodeId_p,
-			       BYTE * pbConcise_p,
+			       u8 * pbConcise_p,
 			       tfpEplCfgMaCb fpCfgMaCb_p,
 			       tEplObdSize SizeOfConcise_p,
 			       tEplCfgMaDcfTyp DcfType_p);
@@ -235,13 +235,13 @@ tEplKernel EplCfgMaStartConfigNode(unsig
 // Parameters:  uiNodeId_p              = NodeId of the node to configure
 //              pbConcise_p             = pointer to DCF
 //              fpCfgMaCb_p             = pointer to callback function (should not be NULL)
-//              SizeOfConcise_p         = size of DCF in BYTE -> for future use
+//              SizeOfConcise_p         = size of DCF in u8 -> for future use
 //              DcfType_p               = type of the DCF
 //
 // Returns:     tCopKernel              = error code
 //---------------------------------------------------------------------------
 tEplKernel EplCfgMaStartConfigNodeDcf(unsigned int uiNodeId_p,
-				      BYTE * pbConcise_p,
+				      u8 * pbConcise_p,
 				      tfpEplCfgMaCb fpCfgMaCb_p,
 				      tEplObdSize SizeOfConcise_p,
 				      tEplCfgMaDcfTyp DcfType_p);
@@ -253,13 +253,13 @@ tEplKernel EplCfgMaStartConfigNodeDcf(un
 //
 // Parameters:  uiNodeId_p              = NodeId of the node to configure
 //              pbConcise_p             = pointer to DCF
-//              SizeOfConcise_p        = size of DCF in BYTE -> for future use
+//              SizeOfConcise_p        = size of DCF in u8 -> for future use
 //              DcfType_p               = type of the DCF
 //
 // Returns:     tCopKernel              = error code
 //---------------------------------------------------------------------------
 tEplKernel EplCfgMaLinkDcf(unsigned int uiNodeId_p,
-			   BYTE * pbConcise_p,
+			   u8 * pbConcise_p,
 			   tEplObdSize SizeOfConcise_p,
 			   tEplCfgMaDcfTyp DcfType_p);
 
--- a/drivers/staging/epl/user/EplDlluCal.h
+++ b/drivers/staging/epl/user/EplDlluCal.h
@@ -110,7 +110,7 @@ tEplKernel EplDlluCalDeleteNode(unsigned
 tEplKernel EplDlluCalSoftDeleteNode(unsigned int uiNodeId_p);
 
 tEplKernel EplDlluCalIssueRequest(tEplDllReqServiceId Service_p,
-				  unsigned int uiNodeId_p, BYTE bSoaFlag1_p);
+				  unsigned int uiNodeId_p, u8 bSoaFlag1_p);
 
 #endif
 
--- a/drivers/staging/epl/user/EplObduCal.h
+++ b/drivers/staging/epl/user/EplObduCal.h
@@ -106,7 +106,7 @@ EPLDLLEXPORT void *EplObduCalGetObjectDa
 EPLDLLEXPORT tEplKernel EplObduCalRegisterUserOd(tEplObdEntryPtr pUserOd_p);
 //---------------------------------------------------------------------------
 EPLDLLEXPORT void EplObduCalInitVarEntry(tEplObdVarEntry *pVarEntry_p,
-					 BYTE bType_p, tEplObdSize ObdSize_p);
+					 u8 bType_p, tEplObdSize ObdSize_p);
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplObdSize EplObduCalGetDataSize(unsigned int uiIndex_p,
 					       unsigned int uiSubIndex_p);
--- a/drivers/staging/epl/user/EplObdu.h
+++ b/drivers/staging/epl/user/EplObdu.h
@@ -117,7 +117,7 @@ EPLDLLEXPORT tEplKernel EplObduRegisterU
 
 // ---------------------------------------------------------------------
 EPLDLLEXPORT void EplObduInitVarEntry(tEplObdVarEntry *pVarEntry_p,
-				      BYTE bType_p, tEplObdSize ObdSize_p);
+				      u8 bType_p, tEplObdSize ObdSize_p);
 
 // ---------------------------------------------------------------------
 EPLDLLEXPORT tEplObdSize EplObduGetDataSize(unsigned int uiIndex_p,
--- a/drivers/staging/epl/user/EplPdou.h
+++ b/drivers/staging/epl/user/EplPdou.h
@@ -97,12 +97,12 @@ tEplKernel EplPdouCbObdAccess(tEplObdCbP
 // returns error if bPdoId_p is already valid
 /*
 tEplKernel EplPdouSetMapping(
-    BYTE bPdoId_p, BOOL fTxRx_p, BYTE bNodeId, BYTE bMappingVersion,
-    tEplPdoMapping * pMapping_p, BYTE bMaxEntries_p);
+    u8 bPdoId_p, BOOL fTxRx_p, u8 bNodeId, u8 bMappingVersion,
+    tEplPdoMapping * pMapping_p, u8 bMaxEntries_p);
 
 tEplKernel EplPdouGetMapping(
-    BYTE bPdoId_p, BOOL fTxRx_p, BYTE * pbNodeId, BYTE * pbMappingVersion,
-    tEplPdoMapping * pMapping_p, BYTE * pbMaxEntries_p);
+    u8 bPdoId_p, BOOL fTxRx_p, u8 * pbNodeId, u8 * pbMappingVersion,
+    tEplPdoMapping * pMapping_p, u8 * pbMaxEntries_p);
 */
 
 #endif // #ifndef _EPL_PDOU_H_
