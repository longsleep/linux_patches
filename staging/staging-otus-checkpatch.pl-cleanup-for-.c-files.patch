From mithlesh@linsyssoft.com  Tue Oct 27 11:22:38 2009
From: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date: Mon, 26 Oct 2009 21:22:20 -0700 (PDT)
Subject: Staging: otus : checkpatch.pl cleanup for .c files
To: Greg Kroah-Hartman <gregkh@suse.de>
Cc: devel@linuxdriverproject.org, Luis.Rodriguez@Atheros.com
Message-ID: <alpine.LFD.2.00.0910262121430.5305@localhost.localdomain>


First patch for checkpatch.pl error and warning fixes for .c files of otus
driver in staging tree.

Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/otus/apdbg.c    |  659 ++++++++++++++++++----------------------
 drivers/staging/otus/wrap_dbg.c |   59 +--
 drivers/staging/otus/wrap_mem.c |   92 ++---
 3 files changed, 380 insertions(+), 430 deletions(-)

--- a/drivers/staging/otus/apdbg.c
+++ b/drivers/staging/otus/apdbg.c
@@ -38,39 +38,39 @@
 
 #include <linux/sockios.h>
 
-#define ZM_IOCTL_REG_READ           0x01
-#define ZM_IOCTL_REG_WRITE          0x02
-#define ZM_IOCTL_MEM_DUMP           0x03
-#define ZM_IOCTL_REG_DUMP           0x05
-#define ZM_IOCTL_TXD_DUMP           0x06
-#define ZM_IOCTL_RXD_DUMP           0x07
-#define ZM_IOCTL_MEM_READ           0x0B
-#define ZM_IOCTL_MEM_WRITE          0x0C
-#define ZM_IOCTL_DMA_TEST           0x10
-#define ZM_IOCTL_REG_TEST           0x11
-#define ZM_IOCTL_TEST               0x80
-#define ZM_IOCTL_TALLY              0x81 //CWYang(+)
-#define ZM_IOCTL_RTS                0xA0
-#define ZM_IOCTL_MIX_MODE           0xA1
-#define ZM_IOCTL_FRAG               0xA2
-#define ZM_IOCTL_SCAN               0xA3
-#define ZM_IOCTL_KEY                0xA4
-#define ZM_IOCTL_RATE               0xA5
-#define ZM_IOCTL_ENCRYPTION_MODE    0xA6
-#define ZM_IOCTL_GET_TXCNT          0xA7
-#define ZM_IOCTL_GET_DEAGG_CNT      0xA8
-#define ZM_IOCTL_DURATION_MODE      0xA9
-#define ZM_IOCTL_SET_AES_KEY        0xAA
-#define ZM_IOCTL_SET_AES_MODE       0xAB
-#define ZM_IOCTL_SIGNAL_STRENGTH    0xAC //CWYang(+)
-#define ZM_IOCTL_SIGNAL_QUALITY     0xAD //CWYang(+)
-#define ZM_IOCTL_SET_PIBSS_MODE     0xAE
-#define	ZDAPIOCTL                   SIOCDEVPRIVATE
+#define ZM_IOCTL_REG_READ			0x01
+#define ZM_IOCTL_REG_WRITE			0x02
+#define ZM_IOCTL_MEM_DUMP			0x03
+#define ZM_IOCTL_REG_DUMP			0x05
+#define ZM_IOCTL_TXD_DUMP			0x06
+#define ZM_IOCTL_RXD_DUMP			0x07
+#define ZM_IOCTL_MEM_READ			0x0B
+#define ZM_IOCTL_MEM_WRITE			0x0C
+#define ZM_IOCTL_DMA_TEST			0x10
+#define ZM_IOCTL_REG_TEST			0x11
+#define ZM_IOCTL_TEST				0x80
+#define ZM_IOCTL_TALLY				0x81 /* CWYang(+) */
+#define ZM_IOCTL_RTS				0xA0
+#define ZM_IOCTL_MIX_MODE			0xA1
+#define ZM_IOCTL_FRAG				0xA2
+#define ZM_IOCTL_SCAN				0xA3
+#define ZM_IOCTL_KEY				0xA4
+#define ZM_IOCTL_RATE				0xA5
+#define ZM_IOCTL_ENCRYPTION_MODE		0xA6
+#define ZM_IOCTL_GET_TXCNT			0xA7
+#define ZM_IOCTL_GET_DEAGG_CNT			0xA8
+#define ZM_IOCTL_DURATION_MODE			0xA9
+#define ZM_IOCTL_SET_AES_KEY			0xAA
+#define ZM_IOCTL_SET_AES_MODE			0xAB
+#define ZM_IOCTL_SIGNAL_STRENGTH		0xAC /* CWYang(+) */
+#define ZM_IOCTL_SIGNAL_QUALITY			0xAD /* CWYang(+) */
+#define ZM_IOCTL_SET_PIBSS_MODE			0xAE
+#define	ZDAPIOCTL				SIOCDEVPRIVATE
 
 struct zdap_ioctl {
-	unsigned short cmd;                /* Command to run */
-	unsigned int   addr;                /* Length of the data buffer */
-	unsigned int   value;               /* Pointer to the data buffer */
+	unsigned short cmd;			/* Command to run */
+	unsigned int   addr;			/* Length of the data buffer */
+	unsigned int   value;			/* Pointer to the data buffer */
 	unsigned char data[0x100];
 };
 
@@ -79,13 +79,13 @@ struct zdap_ioctl {
 #if 0
 
 #define SKIP_ELEM { \
-    while(isxdigit(*p)) \
-        p++; \
+	while (isxdigit(*p)) \
+		p++; \
 }
 
 #define SKIP_DELIMETER { \
-    if(*p == ':' || *p == ' ') \
-        p++; \
+	if (*p == ':' || *p == ' ') \
+		p++; \
 }
 
 #endif
@@ -97,361 +97,308 @@ char *prgname;
 
 int set_ioctl(int sock, struct ifreq *req)
 {
-    if (ioctl(sock, ZDAPIOCTL, req) < 0) {
-        fprintf(stderr, "%s: ioctl(SIOCGIFMAP): %s\n",
-                prgname, strerror(errno));
-        return -1;
-    }
+	if (ioctl(sock, ZDAPIOCTL, req) < 0) {
+		fprintf(stderr, "%s: ioctl(SIOCGIFMAP): %s\n",
+			prgname, strerror(errno));
+		return -1;
+	}
 
-    return 0;
+	return 0;
 }
 
 
 int read_reg(int sock, struct ifreq *req)
 {
-    struct zdap_ioctl *zdreq = 0;
+	struct zdap_ioctl *zdreq = 0;
 
-    if (!set_ioctl(sock, req))
-        return -1;
+	if (!set_ioctl(sock, req))
+			return -1;
 
-    //zdreq = (struct zdap_ioctl *)req->ifr_data;
-    //printf( "reg = %4x, value = %4x\n", zdreq->addr, zdreq->value);
+	/*
+	 * zdreq = (struct zdap_ioctl *)req->ifr_data;
+	 * printf( "reg = %4x, value = %4x\n", zdreq->addr, zdreq->value);
+	 */
 
-    return 0;
+	return 0;
 }
 
 
 int read_mem(int sock, struct ifreq *req)
 {
-    struct zdap_ioctl *zdreq = 0;
-    int i;
+	struct zdap_ioctl *zdreq = 0;
+	int i;
 
-    if (!set_ioctl(sock, req))
-        return -1;
+	if (!set_ioctl(sock, req))
+		return -1;
 
-    /*zdreq = (struct zdap_ioctl *)req->ifr_data;
-    printf( "dump mem from %x, length = %x\n", zdreq->addr, zdreq->value);
+	/*
+	 * zdreq = (struct zdap_ioctl *)req->ifr_data;
+	 * printf("dump mem from %x, length = %x\n", zdreq->addr, zdreq->value);
+	 *
+	 * for (i=0; i<zdreq->value; i++) {
+	 *	printf("%02x", zdreq->data[i]);
+	 *	printf(" ");
+	 *
+	 *	if ((i>0) && ((i+1)%16 == 0))
+	 *		printf("\n");
+	 * }
+	 */
 
-    for (i=0; i<zdreq->value; i++) {
-        printf("%02x", zdreq->data[i]);
-        printf(" ");
-
-        if ((i>0) && ((i+1)%16 == 0))
-            printf("\n");
-    }*/
-
-    return 0;
+	return 0;
 }
 
 
 int main(int argc, char **argv)
 {
-    int sock;
-    int addr, value;
-    struct ifreq req;
-    char *action = NULL;
-    struct zdap_ioctl zdreq;
-
-    prgname = argv[0];
-
-    if (argc < 3) {
-        fprintf(stderr,"%s: usage is \"%s <ifname> <operation> [<address>] [<value>]\"\n",
-                prgname, prgname);
-        fprintf(stderr,"valid operation: read, write, mem, reg,\n");
-        fprintf(stderr,"               : txd, rxd, rmem, wmem\n");
-        fprintf(stderr,"               : dmat, regt, test\n");
-
-        fprintf(stderr,"    scan, Channel Scan\n");
-        fprintf(stderr,"    rts <decimal>, Set RTS Threshold\n");
-        fprintf(stderr,"    frag <decimal>, Set Fragment Threshold\n");
-        fprintf(stderr,"    rate <0-28>, 0:AUTO, 1-4:CCK, 5-12:OFDM, 13-28:HT\n");
-        fprintf(stderr,"    TBD mix <0 or 1>, Set 1 to enable mixed mode\n");
-        fprintf(stderr,"    enc, <0-3>, 0=>OPEN, 1=>WEP64, 2=>WEP128, 3=>WEP256\n");
-        fprintf(stderr,"    skey <key>, Set WEP key\n");
-        fprintf(stderr,"    txcnt, Get TxQ Cnt\n");
-        fprintf(stderr,"    dagcnt, Get Deaggregate Cnt\n");
-        fprintf(stderr,"    durmode <mode>, Set Duration Mode 0=>HW, 1=>SW\n");
-        fprintf(stderr,"    aeskey <user> <key>\n");
-        fprintf(stderr,"    aesmode <mode>\n");
-        fprintf(stderr,"    wlanmode <0,1> 0:Station mode, 1:PIBSS mode\n");
-        fprintf(stderr,"    tal <0,1>, Get Current Tally Info, 0=>read, 1=>read and reset\n");
-
-        exit(1);
-    }
-
-    strcpy(req.ifr_name, argv[1]);
-    zdreq.addr = 0;
-    zdreq.value = 0;
-
-    /* a silly raw socket just for ioctl()ling it */
-    sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
-    if (sock < 0) {
-        fprintf(stderr, "%s: socket(): %s\n", argv[0], strerror(errno));
-        exit(1);
-    }
-
-    if (argc >= 4)
-    {
-        sscanf(argv[3], "%x", &addr);
-    }
-
-    if (argc >= 5)
-    {
-        sscanf(argv[4], "%x", &value);
-    }
-
-    zdreq.addr = addr;
-    zdreq.value = value;
-
-    if (!strcmp(argv[2], "read"))
-    {
-        zdreq.cmd = ZM_IOCTL_REG_READ;
-    }
-    else if (!strcmp(argv[2], "mem"))
-    {
-        zdreq.cmd = ZM_IOCTL_MEM_DUMP;
-    }
-    else if (!strcmp(argv[2], "write"))
-    {
-        zdreq.cmd = ZM_IOCTL_REG_WRITE;
-    }
-    else if (!strcmp(argv[2], "reg"))
-    {
-        zdreq.cmd = ZM_IOCTL_REG_DUMP;
-    }
-    else if (!strcmp(argv[2], "txd"))
-    {
-        zdreq.cmd = ZM_IOCTL_TXD_DUMP;
-    }
-    else if (!strcmp(argv[2], "rxd"))
-    {
-        zdreq.cmd = ZM_IOCTL_RXD_DUMP;
-    }
-    else if (!strcmp(argv[2], "rmem"))
-    {
-        zdreq.cmd = ZM_IOCTL_MEM_READ;
-    }
-    else if (!strcmp(argv[2], "wmem"))
-    {
-        zdreq.cmd = ZM_IOCTL_MEM_WRITE;
-    }
-    else if (!strcmp(argv[2], "dmat"))
-    {
-        zdreq.cmd = ZM_IOCTL_DMA_TEST;
-    }
-    else if (!strcmp(argv[2], "regt"))
-    {
-        zdreq.cmd = ZM_IOCTL_REG_TEST;
-    }
-    else if (!strcmp(argv[2], "test"))
-    {
-        zdreq.cmd = ZM_IOCTL_TEST;
-    }
-    else if (!strcmp(argv[2], "tal"))
-    {
-        sscanf(argv[3], "%d", &addr);
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_TALLY;
-    }
-    else if (!strcmp(argv[2], "rts"))
-    {
-        sscanf(argv[3], "%d", &addr);
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_RTS;
-    }
-    else if (!strcmp(argv[2], "mix"))
-    {
-        zdreq.cmd = ZM_IOCTL_MIX_MODE;
-    }
-    else if (!strcmp(argv[2], "frag"))
-    {
-        sscanf(argv[3], "%d", &addr);
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_FRAG;
-    }
-    else if (!strcmp(argv[2], "scan"))
-    {
-        zdreq.cmd = ZM_IOCTL_SCAN;
-    }
-    else if (!strcmp(argv[2], "skey"))
-    {
-        zdreq.cmd = ZM_IOCTL_KEY;
-
-        if (argc >= 4)
-        {
-            unsigned char temp[29];
-            int i;
-            int keyLen;
-            int encType;
-
-            keyLen = strlen(argv[3]);
-
-            if (keyLen == 10)
-            {
-                sscanf(argv[3], "%02x%02x%02x%02x%02x", &temp[0], &temp[1],
-                        &temp[2], &temp[3], &temp[4]);
-            }
-            else if (keyLen == 26)
-            {
-                sscanf(argv[3], "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
-                        &temp[0], &temp[1], &temp[2], &temp[3], &temp[4],
-                        &temp[5], &temp[6], &temp[7], &temp[8], &temp[9],
-                         &temp[10], &temp[11], &temp[12]);
-            }
-            else if (keyLen == 58)
-            {
-                sscanf(argv[3], "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
-                        &temp[0], &temp[1], &temp[2], &temp[3], &temp[4],
-                        &temp[5], &temp[6], &temp[7], &temp[8], &temp[9],
-                        &temp[10], &temp[11], &temp[12], &temp[13], &temp[14],
-                        &temp[15], &temp[16], &temp[17], &temp[18], &temp[19],
-                        &temp[20], &temp[21], &temp[22], &temp[23], &temp[24],
-                        &temp[25], &temp[26], &temp[27], &temp[28]);
-            }
-            else
-            {
-                fprintf(stderr, "Invalid key length\n");
-                exit(1);
-            }
-            zdreq.addr = keyLen/2;
-
-            for(i=0; i<zdreq.addr; i++)
-            {
-                zdreq.data[i] = temp[i];
-            }
-        }
-        else
-        {
-            printf("Error : Key required!\n");
-        }
-    }
-    else if (!strcmp(argv[2], "rate"))
-    {
-        sscanf(argv[3], "%d", &addr);
-
-        if (addr > 28)
-        {
-            fprintf(stderr, "Invalid rate, range:0~28\n");
-            exit(1);
-        }
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_RATE;
-    }
-    else if (!strcmp(argv[2], "enc"))
-    {
-        sscanf(argv[3], "%d", &addr);
-
-        if (addr > 3)
-        {
-            fprintf(stderr, "Invalid encryption mode, range:0~3\n");
-            exit(1);
-        }
-
-        if (addr == 2)
-        {
-            addr = 5;
-        }
-        else if (addr == 3)
-        {
-            addr = 6;
-        }
-
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_ENCRYPTION_MODE;
-    }
-    else if (!strcmp(argv[2], "txcnt"))
-    {
-        zdreq.cmd = ZM_IOCTL_GET_TXCNT;
-    }
-    else if (!strcmp(argv[2], "dagcnt"))
-    {
-        sscanf(argv[3], "%d", &addr);
-
-        if (addr != 0 && addr != 1)
-        {
-            fprintf(stderr, "The value should be 0 or 1\n");
-            exit(0);
-        }
-
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_GET_DEAGG_CNT;
-    }
-    else if (!strcmp(argv[2], "durmode"))
-    {
-        sscanf(argv[3], "%d", &addr);
-
-        if (addr != 0 && addr != 1)
-        {
-            fprintf(stderr, "The Duration mode should be 0 or 1\n");
-            exit(0);
-        }
-
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_DURATION_MODE;
-    }
-    else if (!strcmp(argv[2], "aeskey"))
-    {
-        unsigned char temp[16];
-        int i;
-
-        sscanf(argv[3], "%d", &addr);
-
-        sscanf(argv[4], "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", &temp[0], &temp[1], &temp[2], &temp[3], &temp[4], &temp[5], &temp[6], &temp[7], &temp[8], &temp[9], &temp[10], &temp[11], &temp[12], &temp[13], &temp[14], &temp[15]);
-
-        for(i = 0; i < 16; i++)
-        {
-            zdreq.data[i] = temp[i];
-        }
-
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_SET_AES_KEY;
-    }
-    else if (!strcmp(argv[2], "aesmode"))
-    {
-        sscanf(argv[3], "%d", &addr);
-
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_SET_AES_MODE;
-    }
-    else if (!strcmp(argv[2], "wlanmode"))
-    {
-        sscanf(argv[3], "%d", &addr);
-
-        zdreq.addr = addr;
-        zdreq.cmd = ZM_IOCTL_SET_PIBSS_MODE;
-    }
-    else
-    {
-	    fprintf(stderr, "error action\n");
-        exit(1);
-    }
+	int sock;
+	int addr, value;
+	struct ifreq req;
+	char *action = NULL;
+	struct zdap_ioctl zdreq;
+
+	prgname = argv[0];
+
+	if (argc < 3) {
+		fprintf(stderr, "%s: usage is \"%s <ifname> <operation>"
+				"[<address>] [<value>]\"\n", prgname, prgname);
+		fprintf(stderr, "valid operation : read, write, mem, reg, \n");
+		fprintf(stderr, "		: txd, rxd, rmem, wmem\n");
+		fprintf(stderr, "		: dmat, regt, test\n");
+
+		fprintf(stderr, "	scan, Channel Scan\n");
+		fprintf(stderr, "	rts <decimal>, Set RTS Threshold\n");
+		fprintf(stderr, "	frag <decimal>, Set Fragment"
+			" Threshold\n");
+		fprintf(stderr, "	rate <0-28>, 0:AUTO, 1-4:CCK,"
+			" 5-12:OFDM, 13-28:HT\n");
+		fprintf(stderr, "	TBD mix <0 or 1>, Set 1 to enable"
+			" mixed mode\n");
+		fprintf(stderr, "	enc, <0-3>, 0=>OPEN, 1=>WEP64, "
+			"2=>WEP128, 3=>WEP256\n");
+		fprintf(stderr, "	skey <key>, Set WEP key\n");
+		fprintf(stderr, "	txcnt, Get TxQ Cnt\n");
+		fprintf(stderr, "	dagcnt, Get Deaggregate Cnt\n");
+		fprintf(stderr, "	durmode <mode>, Set Duration Mode "
+			"0=>HW, 1=>SW\n");
+		fprintf(stderr, "	aeskey <user> <key>\n");
+		fprintf(stderr, "	aesmode <mode>\n");
+		fprintf(stderr, "	wlanmode <0,1> 0:Station mode, "
+			"1:PIBSS mode\n");
+		fprintf(stderr, "	tal <0,1>, Get Current Tally Info, "
+			"0=>read, 1=>read and reset\n");
+
+		exit(1);
+	}
+
+	strcpy(req.ifr_name, argv[1]);
+	zdreq.addr = 0;
+	zdreq.value = 0;
+
+	/* a silly raw socket just for ioctl()ling it */
+	sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+	if (sock < 0) {
+		fprintf(stderr, "%s: socket(): %s\n", argv[0], strerror(errno));
+		exit(1);
+	}
+
+	if (argc >= 4)
+		sscanf(argv[3], "%x", &addr);
+
+	if (argc >= 5)
+		sscanf(argv[4], "%x", &value);
+
+	zdreq.addr = addr;
+	zdreq.value = value;
+
+	if (!strcmp(argv[2], "read"))
+		zdreq.cmd = ZM_IOCTL_REG_READ;
+	else if (!strcmp(argv[2], "mem"))
+		zdreq.cmd = ZM_IOCTL_MEM_DUMP;
+	else if (!strcmp(argv[2], "write"))
+		zdreq.cmd = ZM_IOCTL_REG_WRITE;
+	else if (!strcmp(argv[2], "reg"))
+		zdreq.cmd = ZM_IOCTL_REG_DUMP;
+	else if (!strcmp(argv[2], "txd"))
+		zdreq.cmd = ZM_IOCTL_TXD_DUMP;
+	else if (!strcmp(argv[2], "rxd"))
+		zdreq.cmd = ZM_IOCTL_RXD_DUMP;
+	else if (!strcmp(argv[2], "rmem"))
+		zdreq.cmd = ZM_IOCTL_MEM_READ;
+	else if (!strcmp(argv[2], "wmem"))
+		zdreq.cmd = ZM_IOCTL_MEM_WRITE;
+	else if (!strcmp(argv[2], "dmat"))
+		zdreq.cmd = ZM_IOCTL_DMA_TEST;
+	else if (!strcmp(argv[2], "regt"))
+		zdreq.cmd = ZM_IOCTL_REG_TEST;
+	else if (!strcmp(argv[2], "test"))
+		zdreq.cmd = ZM_IOCTL_TEST;
+	else if (!strcmp(argv[2], "tal")) {
+		sscanf(argv[3], "%d", &addr);
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_TALLY;
+	} else if (!strcmp(argv[2], "rts")) {
+		sscanf(argv[3], "%d", &addr);
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_RTS;
+	} else if (!strcmp(argv[2], "mix")) {
+		zdreq.cmd = ZM_IOCTL_MIX_MODE;
+	} else if (!strcmp(argv[2], "frag")) {
+		sscanf(argv[3], "%d", &addr);
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_FRAG;
+	} else if (!strcmp(argv[2], "scan")) {
+		zdreq.cmd = ZM_IOCTL_SCAN;
+	} else if (!strcmp(argv[2], "skey")) {
+		zdreq.cmd = ZM_IOCTL_KEY;
+
+		if (argc >= 4) {
+			unsigned char temp[29];
+			int i;
+			int keyLen;
+			int encType;
+
+			keyLen = strlen(argv[3]);
+
+			if (keyLen == 10)
+				sscanf(argv[3], "%02x%02x%02x%02x%02x",
+					&temp[0], &temp[1], &temp[2], &temp[3],
+					&temp[4]);
+			else if (keyLen == 26)
+				sscanf(argv[3], "%02x%02x%02x%02x%02x%02x"
+					"%02x%02x%02x%02x%02x%02x%02x",
+					&temp[0], &temp[1], &temp[2], &temp[3],
+					&temp[4], &temp[5], &temp[6], &temp[7],
+					&temp[8], &temp[9], &temp[10],
+					&temp[11], &temp[12]);
+			else if (keyLen == 58)
+				sscanf(argv[3], "%02x%02x%02x%02x%02x%02x"
+					"%02x%02x%02x%02x%02x%02x%02x%02x%02x"
+					"%02x%02x%02x%02x%02x%02x%02x%02x%02x"
+					"%02x%02x%02x%02x%02x",
+					&temp[0], &temp[1], &temp[2], &temp[3],
+					&temp[4], &temp[5], &temp[6], &temp[7],
+					&temp[8], &temp[9], &temp[10],
+					&temp[11], &temp[12], &temp[13],
+					&temp[14], &temp[15], &temp[16],
+					&temp[17], &temp[18], &temp[19],
+					&temp[20], &temp[21], &temp[22],
+					&temp[23], &temp[24], &temp[25],
+					&temp[26], &temp[27], &temp[28]);
+			else {
+				fprintf(stderr, "Invalid key length\n");
+				exit(1);
+			}
+			zdreq.addr = keyLen/2;
+
+			for (i = 0; i < zdreq.addr; i++)
+				zdreq.data[i] = temp[i];
+		} else {
+			printf("Error : Key required!\n");
+		}
+	} else if (!strcmp(argv[2], "rate")) {
+		sscanf(argv[3], "%d", &addr);
+
+		if (addr > 28) {
+			fprintf(stderr, "Invalid rate, range:0~28\n");
+			exit(1);
+		}
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_RATE;
+	} else if (!strcmp(argv[2], "enc")) {
+		sscanf(argv[3], "%d", &addr);
+
+		if (addr > 3) {
+			fprintf(stderr, "Invalid encryption mode, range:0~3\n");
+			exit(1);
+		}
+
+		if (addr == 2)
+			addr = 5;
+		else if (addr == 3)
+			addr = 6;
+
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_ENCRYPTION_MODE;
+	} else if (!strcmp(argv[2], "txcnt")) {
+		zdreq.cmd = ZM_IOCTL_GET_TXCNT;
+	} else if (!strcmp(argv[2], "dagcnt")) {
+		sscanf(argv[3], "%d", &addr);
+
+		if (addr != 0 && addr != 1) {
+			fprintf(stderr, "The value should be 0 or 1\n");
+			exit(0);
+		}
+
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_GET_DEAGG_CNT;
+	} else if (!strcmp(argv[2], "durmode"))	{
+		sscanf(argv[3], "%d", &addr);
+
+		if (addr != 0 && addr != 1) {
+			fprintf(stderr, "The Duration mode should be 0 or 1\n");
+			exit(0);
+		}
+
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_DURATION_MODE;
+	} else if (!strcmp(argv[2], "aeskey")) {
+		unsigned char temp[16];
+		int i;
+
+		sscanf(argv[3], "%d", &addr);
+
+		sscanf(argv[4], "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
+			"%02x%02x%02x%02x%02x%02x", &temp[0], &temp[1],
+			&temp[2], &temp[3], &temp[4], &temp[5], &temp[6],
+			&temp[7], &temp[8], &temp[9], &temp[10], &temp[11],
+			&temp[12], &temp[13], &temp[14], &temp[15]);
+
+		for (i = 0; i < 16; i++)
+			zdreq.data[i] = temp[i];
+
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_SET_AES_KEY;
+	} else if (!strcmp(argv[2], "aesmode")) {
+		sscanf(argv[3], "%d", &addr);
+
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_SET_AES_MODE;
+	} else if (!strcmp(argv[2], "wlanmode")) {
+		sscanf(argv[3], "%d", &addr);
+
+		zdreq.addr = addr;
+		zdreq.cmd = ZM_IOCTL_SET_PIBSS_MODE;
+	} else 	{
+		fprintf(stderr, "error action\n");
+		exit(1);
+	}
 
-    req.ifr_data = (char *)&zdreq;
-    set_ioctl(sock, &req);
+	req.ifr_data = (char *)&zdreq;
+	set_ioctl(sock, &req);
 
 fail:
-    exit(0);
+	exit(0);
 }
 
 unsigned char asctohex(char *str)
 {
-    unsigned char value;
+	unsigned char value;
 
-    value = hex(*str) & 0x0f;
-    value = value << 4;
-    str++;
-    value |= hex(*str) & 0x0f;
+	value = hex(*str) & 0x0f;
+	value = value << 4;
+	str++;
+	value |= hex(*str) & 0x0f;
 
-    return value;
+	return value;
 }
 
 char hex(char v)
 {
-    if(isdigit(v))
-        return v - '0';
-    else if(isxdigit(v))
-        return (tolower(v) - 'a' + 10);
-    else
-        return 0;
+	if (isdigit(v))
+		return v - '0';
+	else if (isxdigit(v))
+		return tolower(v) - 'a' + 10;
+	else
+		return 0;
 }
 
--- a/drivers/staging/otus/wrap_dbg.c
+++ b/drivers/staging/otus/wrap_dbg.c
@@ -29,70 +29,67 @@
 #include <linux/netlink.h>
 #include <net/iw_handler.h>
 
-void zfwDumpBuf(zdev_t* dev, zbuf_t* buf)
+void zfwDumpBuf(zdev_t *dev, zbuf_t *buf)
 {
-    u16_t i;
+	u16_t i;
 
-    for (i=0; i<buf->len; i++)
-    {
-        printk("%02x ", *(((u8_t*)buf->data)+i));
-        if ((i&0xf)==0xf)
-        {
-            printk("\n");
-        }
-    }
-    printk("\n");
+	for (i = 0; i < buf->len; i++) {
+		printk(KERN_DEBUG "%02x ", *(((u8_t *)buf->data)+i));
+		if ((i & 0xf) == 0xf)
+			printk(KERN_DEBUG "\n");
+	}
+	printk(KERN_DEBUG "\n");
 }
 
 
-void zfwDbgReadRegDone(zdev_t* dev, u32_t addr, u32_t val)
+void zfwDbgReadRegDone(zdev_t *dev, u32_t addr, u32_t val)
 {
-    printk("Read addr:%x = %x\n", addr, val);
+	printk(KERN_DEBUG "Read addr:%x = %x\n", addr, val);
 }
 
-void zfwDbgWriteRegDone(zdev_t* dev, u32_t addr, u32_t val)
+void zfwDbgWriteRegDone(zdev_t *dev, u32_t addr, u32_t val)
 {
-    printk("Write addr:%x = %x\n", addr, val);
+	printk(KERN_DEBUG "Write addr:%x = %x\n", addr, val);
 }
 
-void zfwDbgReadTallyDone(zdev_t* dev)
+void zfwDbgReadTallyDone(zdev_t *dev)
 {
-    //printk("Read Tall Done\n");
+	/* printk(KERN_DEBUG "Read Tall Done\n"); */
 }
 
-void zfwDbgWriteEepromDone(zdev_t* dev, u32_t addr, u32_t val)
+void zfwDbgWriteEepromDone(zdev_t *dev, u32_t addr, u32_t val)
 {
 }
 
-void zfwDbgQueryHwTxBusyDone(zdev_t* dev, u32_t val)
+void zfwDbgQueryHwTxBusyDone(zdev_t *dev, u32_t val)
 {
 }
 
-//For Evl ++
-void zfwDbgReadFlashDone(zdev_t* dev, u32_t addr, u32_t* rspdata, u32_t datalen)
+/* For Evl ++ */
+void zfwDbgReadFlashDone(zdev_t *dev, u32_t addr, u32_t *rspdata, u32_t datalen)
 {
-    printk("Read Flash addr:%x length:%x\n", addr, datalen);
+	printk(KERN_DEBUG "Read Flash addr:%x length:%x\n", addr, datalen);
 }
 
-void zfwDbgProgrameFlashDone(zdev_t* dev)
+void zfwDbgProgrameFlashDone(zdev_t *dev)
 {
-    printk("Program Flash Done\n");
+	printk(KERN_DEBUG "Program Flash Done\n");
 }
 
-void zfwDbgProgrameFlashChkDone(zdev_t* dev)
+void zfwDbgProgrameFlashChkDone(zdev_t *dev)
 {
-    printk("Program Flash Done\n");
+	printk(KERN_DEBUG "Program Flash Done\n");
 }
 
-void zfwDbgGetFlashChkSumDone(zdev_t* dev, u32_t* rspdata)
+void zfwDbgGetFlashChkSumDone(zdev_t *dev, u32_t *rspdata)
 {
-    printk("Get Flash ChkSum Done\n");
+	printk(KERN_DEBUG "Get Flash ChkSum Done\n");
 }
 
-void zfwDbgDownloadFwInitDone(zdev_t* dev)
+void zfwDbgDownloadFwInitDone(zdev_t *dev)
 {
-    printk("Download FW Init Done\n");
+	printk(KERN_DEBUG "Download FW Init Done\n");
 }
-//For Evl --
+/* For Evl -- */
 
 /* Leave an empty line below to remove warning message on some compiler */
--- a/drivers/staging/otus/wrap_mem.c
+++ b/drivers/staging/otus/wrap_mem.c
@@ -30,69 +30,75 @@
 #include <net/iw_handler.h>
 
 /* Memory management */
-/* Called to allocate uncached memory, allocated memory must    */
-/* in 4-byte boundary                                           */
-void* zfwMemAllocate(zdev_t* dev, u32_t size)
-{
-    void* mem = NULL;
-    mem = kmalloc(size, GFP_ATOMIC);
-    return mem;
+/* Called to allocate uncached memory, allocated memory must	*/
+/* in 4-byte boundary						*/
+void *zfwMemAllocate(zdev_t *dev, u32_t size)
+{
+	void *mem = NULL;
+	mem = kmalloc(size, GFP_ATOMIC);
+	return mem;
 }
 
 
 /* Called to free allocated memory */
-void zfwMemFree(zdev_t* dev, void* mem, u32_t size)
+void zfwMemFree(zdev_t *dev, void *mem, u32_t size)
 {
-    kfree(mem);
-    return;
+	kfree(mem);
+	return;
 }
 
-void zfwMemoryCopy(u8_t* dst, u8_t* src, u16_t length)
+void zfwMemoryCopy(u8_t *dst, u8_t *src, u16_t length)
 {
-    //u16_t i;
+	/* u16_t i; */
 
-    memcpy(dst, src, length);
-    //for(i=0; i<length; i++)
-    //{
-    //    dst[i] = src[i];
-    //}
-    return;
+	memcpy(dst, src, length);
+	/*
+	 * for(i=0; i<length; i++)
+	 * {
+	 *	dst[i] = src[i];
+	 * }
+	 */
+	return;
 }
 
-void zfwZeroMemory(u8_t* va, u16_t length)
+void zfwZeroMemory(u8_t *va, u16_t length)
 {
-    //u16_t i;
-    memset(va, 0, length);
-    //for(i=0; i<length; i++)
-    //{
-    //    va[i] = 0;
-    //}
-    return;
+	/* u16_t i; */
+	memset(va, 0, length);
+	/*
+	 * for(i=0; i<length; i++)
+	 * {
+	 *	va[i] = 0;
+	 * }
+	 */
+	return;
 }
 
-void zfwMemoryMove(u8_t* dst, u8_t* src, u16_t length)
+void zfwMemoryMove(u8_t *dst, u8_t *src, u16_t length)
 {
-    memcpy(dst, src, length);
-    return;
+	memcpy(dst, src, length);
+	return;
 }
 
-u8_t zfwMemoryIsEqual(u8_t* m1, u8_t* m2, u16_t length)
+u8_t zfwMemoryIsEqual(u8_t *m1, u8_t *m2, u16_t length)
 {
-    //u16_t i;
-    int ret;
+	/* u16_t i; */
+	int ret;
 
-    ret = memcmp(m1, m2, length);
+	ret = memcmp(m1, m2, length);
 
-    return ((ret==0)?TRUE:FALSE);
-    //for(i=0; i<length; i++)
-    //{
-    //    if ( m1[i] != m2[i] )
-    //    {
-    //        return FALSE;
-    //    }
-    //}
-
-    //return TRUE;
+	return ((ret == 0) ? TRUE : FALSE);
+	/*
+	 * for(i=0; i<length; i++)
+	 *{
+	 *	 if ( m1[i] != m2[i] )
+	 *	{
+	 *		return FALSE;
+	 *	}
+	 *}
+	 *
+	 * return TRUE;
+	 */
 }
 
 /* Leave an empty line below to remove warning message on some compiler */
