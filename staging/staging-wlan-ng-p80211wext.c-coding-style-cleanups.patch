From jmm@debian.org  Sun Feb  8 13:39:07 2009
From: Moritz Muehlenhoff <jmm@debian.org>
Date: Sun,  8 Feb 2009 02:20:50 +0100
Subject: Staging: wlan-ng: p80211wext.c: Coding style cleanups
To: greg@kroah.com
Cc: Moritz Muehlenhoff <jmm@debian.org>
Message-ID: <1234056065-25818-6-git-send-email-jmm@debian.org>


Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/wlan-ng/p80211wext.c | 1132 ++++++++++++++++++-----------------
 1 file changed, 587 insertions(+), 545 deletions(-)

--- a/drivers/staging/wlan-ng/p80211wext.c
+++ b/drivers/staging/wlan-ng/p80211wext.c
@@ -79,16 +79,14 @@ static int p80211wext_giwessid(netdevice
 
 static u8 p80211_mhz_to_channel(u16 mhz)
 {
-	if (mhz >= 5000) {
-		return ((mhz - 5000) / 5);
-	}
+	if (mhz >= 5000)
+		return (mhz - 5000) / 5;
 
 	if (mhz == 2482)
 		return 14;
 
-	if (mhz >= 2407) {
-		return ((mhz - 2407) / 5);
-	}
+	if (mhz >= 2407)
+		return (mhz - 2407) / 5;
 
 	return 0;
 }
@@ -102,19 +100,15 @@ static u16 p80211_channel_to_mhz(u8 ch, 
 		return 0;
 
 	/* 5G */
-
-	if (dot11a) {
-		return (5000 + (5 * ch));
-	}
+	if (dot11a)
+		return 5000 + (5 * ch);
 
 	/* 2.4G */
-
 	if (ch == 14)
 		return 2484;
 
-	if ((ch < 14) && (ch > 0)) {
-		return (2407 + (5 * ch));
-	}
+	if ((ch < 14) && (ch > 0))
+		return 2407 + (5 * ch);
 
 	return 0;
 }
@@ -124,44 +118,41 @@ static const long p80211wext_channel_fre
 	2412, 2417, 2422, 2427, 2432, 2437, 2442,
 	2447, 2452, 2457, 2462, 2467, 2472, 2484
 };
+
 #define NUM_CHANNELS ARRAY_SIZE(p80211wext_channel_freq)
 
-/* steal a spare bit to store the shared/opensystems state. should default to open if not set */
+/* steal a spare bit to store the shared/opensystems state.
+   should default to open if not set */
 #define HOSTWEP_SHAREDKEY BIT(3)
 
-
-/** function declarations =============== */
-
-static int qual_as_percent(int snr ) {
-  if ( snr <= 0 )
-    return 0;
-  if ( snr <= 40 )
-    return snr*5/2;
-  return 100;
+static int qual_as_percent(int snr)
+{
+	if (snr <= 0)
+		return 0;
+	if (snr <= 40)
+		return snr * 5 / 2;
+	return 100;
 }
 
-
-
-
 static int p80211wext_dorequest(wlandevice_t *wlandev, u32 did, u32 data)
 {
-	p80211msg_dot11req_mibset_t	msg;
-	p80211item_uint32_t		mibitem;
-	int	result;
+	p80211msg_dot11req_mibset_t msg;
+	p80211item_uint32_t mibitem;
+	int result;
 
 	msg.msgcode = DIDmsg_dot11req_mibset;
 	mibitem.did = did;
 	mibitem.data = data;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	return result;
 }
 
 static int p80211wext_autojoin(wlandevice_t *wlandev)
 {
-	p80211msg_lnxreq_autojoin_t     msg;
-	struct iw_point			data;
+	p80211msg_lnxreq_autojoin_t msg;
+	struct iw_point data;
 	char ssid[IW_ESSID_MAX_SIZE];
 
 	int result;
@@ -175,23 +166,22 @@ static int p80211wext_autojoin(wlandevic
 		goto exit;
 	}
 
-	if ( wlandev->hostwep & HOSTWEP_SHAREDKEY )
-	  msg.authtype.data = P80211ENUM_authalg_sharedkey;
+	if (wlandev->hostwep & HOSTWEP_SHAREDKEY)
+		msg.authtype.data = P80211ENUM_authalg_sharedkey;
 	else
-	  msg.authtype.data = P80211ENUM_authalg_opensystem;
+		msg.authtype.data = P80211ENUM_authalg_opensystem;
 
 	msg.msgcode = DIDmsg_lnxreq_autojoin;
 
 	/* Trim the last '\0' to fit the SSID format */
 
-	if (data.length && ssid[data.length-1] == '\0') {
+	if (data.length && ssid[data.length - 1] == '\0')
 		data.length = data.length - 1;
-	}
 
 	memcpy(msg.ssid.data.data, ssid, data.length);
 	msg.ssid.data.len = data.length;
 
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -205,15 +195,15 @@ exit:
 }
 
 /* called by /proc/net/wireless */
-struct iw_statistics* p80211wext_get_wireless_stats (netdevice_t *dev)
+struct iw_statistics *p80211wext_get_wireless_stats(netdevice_t * dev)
 {
-	p80211msg_lnxreq_commsquality_t  quality;
+	p80211msg_lnxreq_commsquality_t quality;
 	wlandevice_t *wlandev = dev->ml_priv;
-	struct iw_statistics* wstats = &wlandev->wstats;
+	struct iw_statistics *wstats = &wlandev->wstats;
 	int retval;
 
 	/* Check */
-	if ( (wlandev == NULL) || (wlandev->msdstate != WLAN_MSD_RUNNING) )
+	if ((wlandev == NULL) || (wlandev->msdstate != WLAN_MSD_RUNNING))
 		return NULL;
 
 	/* XXX Only valid in station mode */
@@ -225,22 +215,22 @@ struct iw_statistics* p80211wext_get_wir
 	quality.dbm.status = P80211ENUM_msgitem_status_data_ok;
 
 	/* send message to nsd */
-	if ( wlandev->mlmerequest == NULL )
+	if (wlandev->mlmerequest == NULL)
 		return NULL;
 
-	retval = wlandev->mlmerequest(wlandev, (p80211msg_t*) &quality);
+	retval = wlandev->mlmerequest(wlandev, (p80211msg_t *)&quality);
 
-	wstats->qual.qual = qual_as_percent(quality.link.data);    /* overall link quality */
-	wstats->qual.level = quality.level.data;  /* instant signal level */
-	wstats->qual.noise = quality.noise.data;  /* instant noise level */
+	wstats->qual.qual = qual_as_percent(quality.link.data);	/* overall link quality */
+	wstats->qual.level = quality.level.data;	/* instant signal level */
+	wstats->qual.noise = quality.noise.data;	/* instant noise level */
 
 	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
 	wstats->discard.code = wlandev->rx.decrypt_err;
 	wstats->discard.nwid = 0;
 	wstats->discard.misc = 0;
 
-	wstats->discard.fragment = 0;  // incomplete fragments
-	wstats->discard.retries = 0;   // tx retries.
+	wstats->discard.fragment = 0;	/* incomplete fragments */
+	wstats->discard.retries = 0;	/* tx retries. */
 	wstats->miss.beacon = 0;
 
 	return wstats;
@@ -280,15 +270,15 @@ static int p80211wext_giwfreq(netdevice_
 			      struct iw_freq *freq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
 	msg.msgcode = DIDmsg_dot11req_mibget;
 	mibitem.did = DIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentChannel;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -306,7 +296,7 @@ static int p80211wext_giwfreq(netdevice_
 	freq->e = 1;
 	freq->m = p80211_channel_to_mhz(mibitem.data, 0) * 100000;
 
- exit:
+exit:
 	return err;
 }
 
@@ -315,8 +305,8 @@ static int p80211wext_siwfreq(netdevice_
 			      struct iw_freq *freq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
@@ -329,20 +319,20 @@ static int p80211wext_siwfreq(netdevice_
 	mibitem.did = DIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentChannel;
 	mibitem.status = P80211ENUM_msgitem_status_data_ok;
 
-	if ( (freq->e == 0) && (freq->m <= 1000) )
+	if ((freq->e == 0) && (freq->m <= 1000))
 		mibitem.data = freq->m;
 	else
 		mibitem.data = p80211_mhz_to_channel(freq->m);
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
 		goto exit;
 	}
 
- exit:
+exit:
 	return err;
 }
 
@@ -375,10 +365,10 @@ static int p80211wext_siwmode(netdevice_
 			      __u32 *mode, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
-	int 	result;
-	int     err = 0;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
+	int result;
+	int err = 0;
 
 	if (!wlan_wext_write) {
 		err = (-EOPNOTSUPP);
@@ -416,29 +406,28 @@ static int p80211wext_siwmode(netdevice_
 	mibitem.did = DIDmib_p2_p2Static_p2CnfPortType;
 	mibitem.data = (*mode == IW_MODE_ADHOC) ? 0 : 1;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result)
 		err = -EFAULT;
 
- exit:
+exit:
 	return err;
 }
 
-
 static int p80211wext_giwrange(netdevice_t *dev,
 			       struct iw_request_info *info,
 			       struct iw_point *data, char *extra)
 {
-        struct iw_range *range = (struct iw_range *) extra;
+	struct iw_range *range = (struct iw_range *)extra;
 	int i, val;
 
-	// for backward compatability set size & zero everything we don't understand
+	/* for backward compatability set size and zero everything we don't understand */
 	data->length = sizeof(*range);
-	memset(range,0,sizeof(*range));
+	memset(range, 0, sizeof(*range));
 
 	range->txpower_capa = IW_TXPOW_DBM;
-	// XXX what about min/max_pmp, min/max_pmt, etc.
+	/* XXX what about min/max_pmp, min/max_pmt, etc. */
 
 	range->we_version_compiled = WIRELESS_EXT;
 	range->we_version_source = 13;
@@ -448,18 +437,18 @@ static int p80211wext_giwrange(netdevice
 	range->min_retry = 0;
 	range->max_retry = 255;
 
-        range->event_capa[0] = (IW_EVENT_CAPA_K_0 |  //mode/freq/ssid
-                                IW_EVENT_CAPA_MASK(SIOCGIWAP) |
-                                IW_EVENT_CAPA_MASK(SIOCGIWSCAN));
-        range->event_capa[1] = IW_EVENT_CAPA_K_1;  //encode
-        range->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVQUAL) |
-                                IW_EVENT_CAPA_MASK(IWEVCUSTOM) );
+	range->event_capa[0] = (IW_EVENT_CAPA_K_0 |	/* mode/freq/ssid */
+				IW_EVENT_CAPA_MASK(SIOCGIWAP) |
+				IW_EVENT_CAPA_MASK(SIOCGIWSCAN));
+	range->event_capa[1] = IW_EVENT_CAPA_K_1;	/* encode */
+	range->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVQUAL) |
+				IW_EVENT_CAPA_MASK(IWEVCUSTOM));
 
 	range->num_channels = NUM_CHANNELS;
 
 	/* XXX need to filter against the regulatory domain &| active set */
 	val = 0;
-	for (i = 0; i < NUM_CHANNELS ; i++) {
+	for (i = 0; i < NUM_CHANNELS; i++) {
 		range->freq[val].i = i + 1;
 		range->freq[val].m = p80211wext_channel_freq[i] * 100000;
 		range->freq[val].e = 1;
@@ -473,7 +462,7 @@ static int p80211wext_giwrange(netdevice
 	range->max_qual.level = 0;
 	range->max_qual.noise = 0;
 	range->sensitivity = 3;
-	// XXX these need to be nsd-specific!
+	/* XXX these need to be nsd-specific! */
 
 	range->min_rts = 0;
 	range->max_rts = 2347;
@@ -485,11 +474,11 @@ static int p80211wext_giwrange(netdevice
 	range->encoding_size[0] = 5;
 	range->encoding_size[1] = 13;
 
-	// XXX what about num_bitrates/throughput?
+	/* XXX what about num_bitrates/throughput? */
 	range->num_bitrates = 0;
 
 	/* estimated max throughput */
-	// XXX need to cap it if we're running at ~2Mbps..
+	/* XXX need to cap it if we're running at ~2Mbps.. */
 	range->throughput = 5500000;
 
 	return 0;
@@ -545,7 +534,7 @@ static int p80211wext_giwencode(netdevic
 	erq->length = wlandev->wep_keylens[i];
 	memcpy(key, wlandev->wep_keys[i], erq->length);
 
- exit:
+exit:
 	return err;
 }
 
@@ -554,8 +543,8 @@ static int p80211wext_siwencode(netdevic
 				struct iw_point *erq, char *key)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211msg_dot11req_mibset_t	msg;
-	p80211item_pstr32_t		pstr;
+	p80211msg_dot11req_mibset_t msg;
+	p80211item_pstr32_t pstr;
 
 	int err = 0;
 	int result = 0;
@@ -567,18 +556,20 @@ static int p80211wext_siwencode(netdevic
 	}
 
 	/* Check the Key index first. */
-	if((i = (erq->flags & IW_ENCODE_INDEX))) {
+	if ((i = (erq->flags & IW_ENCODE_INDEX))) {
 
 		if ((i < 1) || (i > NUM_WEPKEYS)) {
 			err = -EINVAL;
 			goto exit;
-		}
-		else
+		} else
 			i--;
 
 		/* Set current key number only if no keys are given */
 		if (erq->flags & IW_ENCODE_NOKEY) {
-			result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID, i);
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID,
+						 i);
 
 			if (result) {
 				err = -EFAULT;
@@ -587,12 +578,12 @@ static int p80211wext_siwencode(netdevic
 		}
 
 	} else {
-		// Use defaultkey if no Key Index
+		/* Use defaultkey if no Key Index */
 		i = wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK;
 	}
 
 	/* Check if there is no key information in the iwconfig request */
-	if((erq->flags & IW_ENCODE_NOKEY) == 0 ) {
+	if ((erq->flags & IW_ENCODE_NOKEY) == 0) {
 
 		/*------------------------------------------------------------
 		 * If there is WEP Key for setting, check the Key Information
@@ -609,32 +600,35 @@ static int p80211wext_siwencode(netdevic
 			memcpy(pstr.data.data, key, erq->length);
 			pstr.data.len = erq->length;
 
-			switch(i)
-			{
-				case 0:
-					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
-					break;
-
-				case 1:
-					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
-					break;
-
-				case 2:
-					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
-					break;
-
-				case 3:
-					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
-					break;
-
-				default:
-					err = -EINVAL;
-					goto exit;
+			switch (i) {
+			case 0:
+				pstr.did =
+				    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
+				break;
+
+			case 1:
+				pstr.did =
+				    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
+				break;
+
+			case 2:
+				pstr.did =
+				    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
+				break;
+
+			case 3:
+				pstr.did =
+				    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
+				break;
+
+			default:
+				err = -EINVAL;
+				goto exit;
 			}
 
 			msg.msgcode = DIDmsg_dot11req_mibset;
 			memcpy(&msg.mibattribute.data, &pstr, sizeof(pstr));
-			result = p80211req_dorequest(wlandev, (u8*)&msg);
+			result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 			if (result) {
 				err = -EFAULT;
@@ -646,9 +640,15 @@ static int p80211wext_siwencode(netdevic
 
 	/* Check the PrivacyInvoked flag */
 	if (erq->flags & IW_ENCODE_DISABLED) {
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_false);
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+					 P80211ENUM_truth_false);
 	} else {
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_true);
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+					 P80211ENUM_truth_true);
 	}
 
 	if (result) {
@@ -657,17 +657,22 @@ static int p80211wext_siwencode(netdevic
 	}
 
 	/*  The  security  mode  may  be open or restricted, and its meaning
-	    depends on the card used. With  most  cards,  in  open  mode  no
-	    authentication  is  used  and  the  card  may  also  accept non-
-	    encrypted sessions, whereas in restricted  mode  only  encrypted
-	    sessions  are  accepted  and the card will use authentication if
-	    available.
-	*/
+	   depends on the card used. With  most  cards,  in  open  mode  no
+	   authentication  is  used  and  the  card  may  also  accept non-
+	   encrypted sessions, whereas in restricted  mode  only  encrypted
+	   sessions  are  accepted  and the card will use authentication if
+	   available.
+	 */
 	if (erq->flags & IW_ENCODE_RESTRICTED) {
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_true);
-	}
-	else if (erq->flags & IW_ENCODE_OPEN) {
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_false);
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+					 P80211ENUM_truth_true);
+	} else if (erq->flags & IW_ENCODE_OPEN) {
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+					 P80211ENUM_truth_false);
 	}
 
 	if (result) {
@@ -675,7 +680,7 @@ static int p80211wext_siwencode(netdevic
 		goto exit;
 	}
 
- exit:
+exit:
 
 	return err;
 }
@@ -695,7 +700,7 @@ static int p80211wext_giwessid(netdevice
 		data->length++;
 #endif
 	} else {
-	  	memset(essid, 0, sizeof(wlandev->ssid.data));
+		memset(essid, 0, sizeof(wlandev->ssid.data));
 		data->length = 0;
 		data->flags = 0;
 	}
@@ -708,7 +713,7 @@ static int p80211wext_siwessid(netdevice
 			       struct iw_point *data, char *essid)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211msg_lnxreq_autojoin_t     msg;
+	p80211msg_lnxreq_autojoin_t msg;
 
 	int result;
 	int err = 0;
@@ -719,41 +724,38 @@ static int p80211wext_siwessid(netdevice
 		goto exit;
 	}
 
-
-	if ( wlandev->hostwep & HOSTWEP_SHAREDKEY )
-	  msg.authtype.data = P80211ENUM_authalg_sharedkey;
+	if (wlandev->hostwep & HOSTWEP_SHAREDKEY)
+		msg.authtype.data = P80211ENUM_authalg_sharedkey;
 	else
-	  msg.authtype.data = P80211ENUM_authalg_opensystem;
+		msg.authtype.data = P80211ENUM_authalg_opensystem;
 
 	msg.msgcode = DIDmsg_lnxreq_autojoin;
 
 #if (WIRELESS_EXT < 21)
-	if (length) length--;
+	if (length)
+		length--;
 #endif
 
 	/* Trim the last '\0' to fit the SSID format */
-
-	if (length && essid[length-1] == '\0') {
-	  length--;
-	}
+	if (length && essid[length - 1] == '\0')
+		length--;
 
 	memcpy(msg.ssid.data.data, essid, length);
 	msg.ssid.data.len = length;
 
-	pr_debug("autojoin_ssid for %s \n",essid);
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
-        pr_debug("autojoin_ssid %d\n",result);
+	pr_debug("autojoin_ssid for %s \n", essid);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	pr_debug("autojoin_ssid %d\n", result);
 
 	if (result) {
 		err = -EFAULT;
 		goto exit;
 	}
 
- exit:
+exit:
 	return err;
 }
 
-
 static int p80211wext_siwcommit(netdevice_t *dev,
 				struct iw_request_info *info,
 				struct iw_point *data, char *essid)
@@ -769,25 +771,24 @@ static int p80211wext_siwcommit(netdevic
 	/* Auto Join */
 	err = p80211wext_autojoin(wlandev);
 
- exit:
+exit:
 	return err;
 }
 
-
 static int p80211wext_giwrate(netdevice_t *dev,
 			      struct iw_request_info *info,
 			      struct iw_param *rrq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
 	msg.msgcode = DIDmsg_dot11req_mibget;
 	mibitem.did = DIDmib_p2_p2MAC_p2CurrentTxRate;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -796,7 +797,7 @@ static int p80211wext_giwrate(netdevice_
 
 	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
 
-	rrq->fixed = 0;   /* can it change? */
+	rrq->fixed = 0;		/* can it change? */
 	rrq->disabled = 0;
 	rrq->value = 0;
 
@@ -821,7 +822,7 @@ static int p80211wext_giwrate(netdevice_
 	default:
 		err = -EINVAL;
 	}
- exit:
+exit:
 	return err;
 }
 
@@ -830,15 +831,15 @@ static int p80211wext_giwrts(netdevice_t
 			     struct iw_param *rts, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
 	msg.msgcode = DIDmsg_dot11req_mibget;
 	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11RTSThreshold;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -851,18 +852,17 @@ static int p80211wext_giwrts(netdevice_t
 	rts->disabled = (rts->value == 2347);
 	rts->fixed = 1;
 
- exit:
+exit:
 	return err;
 }
 
-
 static int p80211wext_siwrts(netdevice_t *dev,
 			     struct iw_request_info *info,
 			     struct iw_param *rts, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
@@ -879,14 +879,14 @@ static int p80211wext_siwrts(netdevice_t
 		mibitem.data = rts->value;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
 		goto exit;
 	}
 
- exit:
+exit:
 	return err;
 }
 
@@ -895,15 +895,16 @@ static int p80211wext_giwfrag(netdevice_
 			      struct iw_param *frag, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
 	msg.msgcode = DIDmsg_dot11req_mibget;
-	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
+	mibitem.did =
+	    DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -916,7 +917,7 @@ static int p80211wext_giwfrag(netdevice_
 	frag->disabled = (frag->value == 2346);
 	frag->fixed = 1;
 
- exit:
+exit:
 	return err;
 }
 
@@ -925,8 +926,8 @@ static int p80211wext_siwfrag(netdevice_
 			      struct iw_param *frag, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
@@ -936,7 +937,8 @@ static int p80211wext_siwfrag(netdevice_
 	}
 
 	msg.msgcode = DIDmsg_dot11req_mibset;
-	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
+	mibitem.did =
+	    DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
 
 	if (frag->disabled)
 		mibitem.data = 2346;
@@ -944,14 +946,14 @@ static int p80211wext_siwfrag(netdevice_
 		mibitem.data = frag->value;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
 		goto exit;
 	}
 
- exit:
+exit:
 	return err;
 }
 
@@ -968,8 +970,8 @@ static int p80211wext_giwretry(netdevice
 			       struct iw_param *rrq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 	u16 shortretry, longretry, lifetime;
@@ -978,7 +980,7 @@ static int p80211wext_giwretry(netdevice
 	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -992,7 +994,7 @@ static int p80211wext_giwretry(netdevice
 	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -1003,10 +1005,11 @@ static int p80211wext_giwretry(netdevice
 
 	longretry = mibitem.data;
 
-	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
+	mibitem.did =
+	    DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -1034,7 +1037,7 @@ static int p80211wext_giwretry(netdevice
 		}
 	}
 
- exit:
+exit:
 	return err;
 
 }
@@ -1044,8 +1047,8 @@ static int p80211wext_siwretry(netdevice
 			       struct iw_param *rrq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
@@ -1062,11 +1065,12 @@ static int p80211wext_siwretry(netdevice
 	msg.msgcode = DIDmsg_dot11req_mibset;
 
 	if ((rrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {
-		mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
-		mibitem.data =  rrq->value /= 1024;
+		mibitem.did =
+		    DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
+		mibitem.data = rrq->value /= 1024;
 
 		memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-		result = p80211req_dorequest(wlandev, (u8*)&msg);
+		result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 		if (result) {
 			err = -EFAULT;
@@ -1074,11 +1078,13 @@ static int p80211wext_siwretry(netdevice
 		}
 	} else {
 		if (rrq->flags & IW_RETRY_LONG) {
-			mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit;
+			mibitem.did =
+			    DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit;
 			mibitem.data = rrq->value;
 
-			memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-			result = p80211req_dorequest(wlandev, (u8*)&msg);
+			memcpy(&msg.mibattribute.data, &mibitem,
+			       sizeof(mibitem));
+			result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 			if (result) {
 				err = -EFAULT;
@@ -1087,11 +1093,13 @@ static int p80211wext_siwretry(netdevice
 		}
 
 		if (rrq->flags & IW_RETRY_SHORT) {
-			mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit;
+			mibitem.did =
+			    DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit;
 			mibitem.data = rrq->value;
 
-			memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-			result = p80211req_dorequest(wlandev, (u8*)&msg);
+			memcpy(&msg.mibattribute.data, &mibitem,
+			       sizeof(mibitem));
+			result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 			if (result) {
 				err = -EFAULT;
@@ -1100,42 +1108,43 @@ static int p80211wext_siwretry(netdevice
 		}
 	}
 
- exit:
+exit:
 	return err;
 
 }
 
 static int p80211wext_siwtxpow(netdevice_t *dev,
-                               struct iw_request_info *info,
-                               struct iw_param *rrq, char *extra)
+			       struct iw_request_info *info,
+			       struct iw_param *rrq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-        p80211item_uint32_t             mibitem;
-        p80211msg_dot11req_mibset_t     msg;
-        int result;
-        int err = 0;
-
-       if (!wlan_wext_write) {
-                err = (-EOPNOTSUPP);
-                goto exit;
-        }
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
+	int result;
+	int err = 0;
 
-        msg.msgcode = DIDmsg_dot11req_mibset;
-	mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	msg.msgcode = DIDmsg_dot11req_mibset;
+	mibitem.did =
+	    DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
 	if (rrq->fixed == 0)
-	  mibitem.data = 30;
+		mibitem.data = 30;
 	else
-	  mibitem.data = rrq->value;
-        memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-        result = p80211req_dorequest(wlandev, (u8*)&msg);
-
-        if (result) {
-                err = -EFAULT;
-                goto exit;
-        }
+		mibitem.data = rrq->value;
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
 
- exit:
-        return err;
+exit:
+	return err;
 }
 
 static int p80211wext_giwtxpow(netdevice_t *dev,
@@ -1143,16 +1152,17 @@ static int p80211wext_giwtxpow(netdevice
 			       struct iw_param *rrq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
 	int result;
 	int err = 0;
 
 	msg.msgcode = DIDmsg_dot11req_mibget;
-	mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
+	mibitem.did =
+	    DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
 
 	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 
 	if (result) {
 		err = -EFAULT;
@@ -1161,14 +1171,14 @@ static int p80211wext_giwtxpow(netdevice
 
 	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
 
-	// XXX handle OFF by setting disabled = 1;
+	/* XXX handle OFF by setting disabled = 1; */
 
-	rrq->flags = 0; // IW_TXPOW_DBM;
+	rrq->flags = 0;		/* IW_TXPOW_DBM; */
 	rrq->disabled = 0;
 	rrq->fixed = 0;
 	rrq->value = mibitem.data;
 
- exit:
+exit:
 	return err;
 }
 
@@ -1177,30 +1187,31 @@ static int p80211wext_siwspy(netdevice_t
 			     struct iw_point *srq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-        struct sockaddr address[IW_MAX_SPY];
-        int number = srq->length;
-        int i;
-
+	struct sockaddr address[IW_MAX_SPY];
+	int number = srq->length;
+	int i;
 
 	/* Copy the data from the input buffer */
-	memcpy(address, extra, sizeof(struct sockaddr)*number);
+	memcpy(address, extra, sizeof(struct sockaddr) * number);
 
-        wlandev->spy_number = 0;
+	wlandev->spy_number = 0;
 
-        if (number > 0) {
+	if (number > 0) {
 
-                /* extract the addresses */
-                for (i = 0; i < number; i++) {
+		/* extract the addresses */
+		for (i = 0; i < number; i++) {
 
-                        memcpy(wlandev->spy_address[i], address[i].sa_data, ETH_ALEN);
+			memcpy(wlandev->spy_address[i], address[i].sa_data,
+			       ETH_ALEN);
 		}
 
-                /* reset stats */
-                memset(wlandev->spy_stat, 0, sizeof(struct iw_quality) * IW_MAX_SPY);
+		/* reset stats */
+		memset(wlandev->spy_stat, 0,
+		       sizeof(struct iw_quality) * IW_MAX_SPY);
 
-                /* set number of addresses */
-                wlandev->spy_number = number;
-        }
+		/* set number of addresses */
+		wlandev->spy_number = number;
+	}
 
 	return 0;
 }
@@ -1212,63 +1223,66 @@ static int p80211wext_giwspy(netdevice_t
 {
 	wlandevice_t *wlandev = dev->ml_priv;
 
-        struct sockaddr address[IW_MAX_SPY];
-        struct iw_quality spy_stat[IW_MAX_SPY];
-        int number;
-        int i;
-
-        number = wlandev->spy_number;
-
-        if (number > 0) {
-
-                /* populate address and spy struct's */
-                for (i = 0; i < number; i++) {
-                        memcpy(address[i].sa_data, wlandev->spy_address[i], ETH_ALEN);
-                        address[i].sa_family = AF_UNIX;
-                	memcpy(&spy_stat[i], &wlandev->spy_stat[i], sizeof(struct iw_quality));
-                }
+	struct sockaddr address[IW_MAX_SPY];
+	struct iw_quality spy_stat[IW_MAX_SPY];
+	int number;
+	int i;
+
+	number = wlandev->spy_number;
+
+	if (number > 0) {
+
+		/* populate address and spy struct's */
+		for (i = 0; i < number; i++) {
+			memcpy(address[i].sa_data, wlandev->spy_address[i],
+			       ETH_ALEN);
+			address[i].sa_family = AF_UNIX;
+			memcpy(&spy_stat[i], &wlandev->spy_stat[i],
+			       sizeof(struct iw_quality));
+		}
 
 		/* reset update flag */
-                for (i=0; i < number; i++)
-                        wlandev->spy_stat[i].updated = 0;
-        }
-
-        /* push stuff to user space */
-        srq->length = number;
-	memcpy(extra, address, sizeof(struct sockaddr)*number);
-	memcpy(extra+sizeof(struct sockaddr)*number, spy_stat, sizeof(struct iw_quality)*number);
+		for (i = 0; i < number; i++)
+			wlandev->spy_stat[i].updated = 0;
+	}
+
+	/* push stuff to user space */
+	srq->length = number;
+	memcpy(extra, address, sizeof(struct sockaddr) * number);
+	memcpy(extra + sizeof(struct sockaddr) * number, spy_stat,
+	       sizeof(struct iw_quality) * number);
 
 	return 0;
 }
 
-static int prism2_result2err (int prism2_result)
+static int prism2_result2err(int prism2_result)
 {
 	int err = 0;
 
 	switch (prism2_result) {
-		case P80211ENUM_resultcode_invalid_parameters:
-			err = -EINVAL;
-			break;
-		case P80211ENUM_resultcode_implementation_failure:
-			err = -EIO;
-			break;
-		case P80211ENUM_resultcode_not_supported:
-			err = -EOPNOTSUPP;
-			break;
-		default:
-			err = 0;
-			break;
+	case P80211ENUM_resultcode_invalid_parameters:
+		err = -EINVAL;
+		break;
+	case P80211ENUM_resultcode_implementation_failure:
+		err = -EIO;
+		break;
+	case P80211ENUM_resultcode_not_supported:
+		err = -EOPNOTSUPP;
+		break;
+	default:
+		err = 0;
+		break;
 	}
 
 	return err;
 }
 
 static int p80211wext_siwscan(netdevice_t *dev,
-			     struct iw_request_info *info,
-			     struct iw_point *srq, char *extra)
+			      struct iw_request_info *info,
+			      struct iw_point *srq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211msg_dot11req_scan_t	msg;
+	p80211msg_dot11req_scan_t msg;
 	int result;
 	int err = 0;
 	int i = 0;
@@ -1283,35 +1297,34 @@ static int p80211wext_siwscan(netdevice_
 	msg.msgcode = DIDmsg_dot11req_scan;
 	msg.bsstype.data = P80211ENUM_bsstype_any;
 
-	memset(&(msg.bssid.data), 0xFF, sizeof (p80211item_pstr6_t));
+	memset(&(msg.bssid.data), 0xFF, sizeof(p80211item_pstr6_t));
 	msg.bssid.data.len = 6;
 
 	msg.scantype.data = P80211ENUM_scantype_active;
 	msg.probedelay.data = 0;
 
 	for (i = 1; i <= 14; i++)
-		msg.channellist.data.data[i-1] = i;
+		msg.channellist.data.data[i - 1] = i;
 	msg.channellist.data.len = 14;
 
 	msg.maxchanneltime.data = 250;
 	msg.minchanneltime.data = 200;
 
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
 	if (result)
-		err = prism2_result2err (msg.resultcode.data);
+		err = prism2_result2err(msg.resultcode.data);
 
- exit:
+exit:
 	return err;
 }
 
-
 /* Helper to translate scan into Wireless Extensions scan results.
  * Inspired by the prism54 code, which was in turn inspired by the
  * airo driver code.
  */
-static char *
-wext_translate_bss(struct iw_request_info *info, char *current_ev,
-		   char *end_buf, p80211msg_dot11req_scan_results_t *bss)
+static char *wext_translate_bss(struct iw_request_info *info, char *current_ev,
+				char *end_buf,
+				p80211msg_dot11req_scan_results_t *bss)
 {
 	struct iw_event iwe;	/* Temporary buffer */
 
@@ -1319,7 +1332,9 @@ wext_translate_bss(struct iw_request_inf
 	memcpy(iwe.u.ap_addr.sa_data, bss->bssid.data.data, WLAN_BSSID_LEN);
 	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
 	iwe.cmd = SIOCGIWAP;
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_ADDR_LEN);
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_ADDR_LEN);
 
 	/* The following entries will be displayed in the same order we give them */
 
@@ -1328,33 +1343,39 @@ wext_translate_bss(struct iw_request_inf
 		char essid[IW_ESSID_MAX_SIZE + 1];
 		int size;
 
-		size = min_t(unsigned short, IW_ESSID_MAX_SIZE, bss->ssid.data.len);
-		memset(&essid, 0, sizeof (essid));
+		size =
+		    min_t(unsigned short, IW_ESSID_MAX_SIZE,
+			  bss->ssid.data.len);
+		memset(&essid, 0, sizeof(essid));
 		memcpy(&essid, bss->ssid.data.data, size);
 		pr_debug(" essid size = %d\n", size);
 		iwe.u.data.length = size;
 		iwe.u.data.flags = 1;
 		iwe.cmd = SIOCGIWESSID;
-		current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, &essid[0]);
+		current_ev =
+		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+					 &essid[0]);
 		pr_debug(" essid size OK.\n");
 	}
 
 	switch (bss->bsstype.data) {
-		case P80211ENUM_bsstype_infrastructure:
-			iwe.u.mode = IW_MODE_MASTER;
-			break;
+	case P80211ENUM_bsstype_infrastructure:
+		iwe.u.mode = IW_MODE_MASTER;
+		break;
 
-		case P80211ENUM_bsstype_independent:
-			iwe.u.mode = IW_MODE_ADHOC;
-			break;
+	case P80211ENUM_bsstype_independent:
+		iwe.u.mode = IW_MODE_ADHOC;
+		break;
 
-		default:
-			iwe.u.mode = 0;
-			break;
+	default:
+		iwe.u.mode = 0;
+		break;
 	}
 	iwe.cmd = SIOCGIWMODE;
 	if (iwe.u.mode)
-		current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_UINT_LEN);
+		current_ev =
+		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+					 IW_EV_UINT_LEN);
 
 	/* Encryption capability */
 	if (bss->privacy.data == P80211ENUM_truth_true)
@@ -1363,13 +1384,16 @@ wext_translate_bss(struct iw_request_inf
 		iwe.u.data.flags = IW_ENCODE_DISABLED;
 	iwe.u.data.length = 0;
 	iwe.cmd = SIOCGIWENCODE;
-	current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, NULL);
+	current_ev =
+	    iwe_stream_add_point(info, current_ev, end_buf, &iwe, NULL);
 
 	/* Add frequency. (short) bss->channel is the frequency in MHz */
 	iwe.u.freq.m = bss->dschannel.data;
 	iwe.u.freq.e = 0;
 	iwe.cmd = SIOCGIWFREQ;
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_FREQ_LEN);
 
 	/* Add quality statistics */
 	iwe.u.qual.level = bss->signal.data;
@@ -1377,18 +1401,19 @@ wext_translate_bss(struct iw_request_inf
 	/* do a simple SNR for quality */
 	iwe.u.qual.qual = qual_as_percent(bss->signal.data - bss->noise.data);
 	iwe.cmd = IWEVQUAL;
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_QUAL_LEN);
 
 	return current_ev;
 }
 
-
 static int p80211wext_giwscan(netdevice_t *dev,
-			     struct iw_request_info *info,
-			     struct iw_point *srq, char *extra)
+			      struct iw_request_info *info,
+			      struct iw_point *srq, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
-	p80211msg_dot11req_scan_results_t	msg;
+	p80211msg_dot11req_scan_results_t msg;
 	int result = 0;
 	int err = 0;
 	int i = 0;
@@ -1404,109 +1429,115 @@ static int p80211wext_giwscan(netdevice_
 		msg.msgcode = DIDmsg_dot11req_scan_results;
 		msg.bssindex.data = i;
 
-		result = p80211req_dorequest(wlandev, (u8*)&msg);
+		result = p80211req_dorequest(wlandev, (u8 *)&msg);
 		if ((result != 0) ||
 		    (msg.resultcode.data != P80211ENUM_resultcode_success)) {
 			break;
 		}
 
-		current_ev = wext_translate_bss(info, current_ev, extra + IW_SCAN_MAX_DATA, &msg);
+		current_ev =
+		    wext_translate_bss(info, current_ev,
+				       extra + IW_SCAN_MAX_DATA, &msg);
 		scan_good = 1;
 		i++;
 	} while (i < IW_MAX_AP);
 
 	srq->length = (current_ev - extra);
-	srq->flags = 0;	/* todo */
+	srq->flags = 0;		/* todo */
 
 	if (result && !scan_good)
-		err = prism2_result2err (msg.resultcode.data);
+		err = prism2_result2err(msg.resultcode.data);
 
 	return err;
 }
 
-/*****************************************************/
-//extra wireless extensions stuff to support NetworkManager (I hope)
+/* extra wireless extensions stuff to support NetworkManager (I hope) */
 
 /* SIOCSIWENCODEEXT */
 static int p80211wext_set_encodeext(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
 {
-  wlandevice_t *wlandev = dev->ml_priv;
-  struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
-	p80211msg_dot11req_mibset_t	msg;
-	p80211item_pstr32_t		*pstr;
-
-  int result = 0;
-  struct iw_point *encoding = &wrqu->encoding;
-  int idx = encoding->flags & IW_ENCODE_INDEX;
-
-  pr_debug("set_encode_ext flags[%d] alg[%d] keylen[%d]\n",ext->ext_flags,(int)ext->alg,(int)ext->key_len);
-
-
-  if ( ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY ) {
-    // set default key ? I'm not sure if this the the correct thing to do here
-
-    if ( idx ) {
-      if (idx < 1 || idx > NUM_WEPKEYS) {
-	return -EINVAL;
-      } else
-	idx--;
-    }
-    pr_debug("setting default key (%d)\n",idx);
-    result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID, idx);
-    if ( result )
-      return -EFAULT;
-  }
-
-
-  if ( ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY ) {
-    if (!(ext->alg & IW_ENCODE_ALG_WEP)) {
-      pr_debug("asked to set a non wep key :(");
-      return -EINVAL;
-    }
-    if (idx) {
-      if (idx <1 || idx > NUM_WEPKEYS)
-	return -EINVAL;
-      else
-	idx--;
-    }
-    pr_debug("Set WEP key (%d)\n",idx);
-    wlandev->wep_keylens[idx] = ext->key_len;
-    memcpy(wlandev->wep_keys[idx], ext->key, ext->key_len);
-
-    memset( &msg,0,sizeof(msg));
-    pstr = (p80211item_pstr32_t*)&msg.mibattribute.data;
-    memcpy(pstr->data.data, ext->key,ext->key_len);
-    pstr->data.len = ext->key_len;
-    switch (idx) {
-    case 0:
-      pstr->did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
-      break;
-    case 1:
-      pstr->did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
-      break;
-    case 2:
-      pstr->did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
-      break;
-    case 3:
-      pstr->did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
-      break;
-    default:
-      break;
-    }
-    msg.msgcode = DIDmsg_dot11req_mibset;
-    result = p80211req_dorequest(wlandev,(u8*)&msg);
-    pr_debug("result (%d)\n",result);
-  }
-  return result;
+	wlandevice_t *wlandev = dev->ml_priv;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	p80211msg_dot11req_mibset_t msg;
+	p80211item_pstr32_t *pstr;
+
+	int result = 0;
+	struct iw_point *encoding = &wrqu->encoding;
+	int idx = encoding->flags & IW_ENCODE_INDEX;
+
+	pr_debug("set_encode_ext flags[%d] alg[%d] keylen[%d]\n",
+	       ext->ext_flags, (int)ext->alg, (int)ext->key_len);
+
+	if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+		/* set default key ? I'm not sure if this the the correct thing to do here */
+
+		if (idx) {
+			if (idx < 1 || idx > NUM_WEPKEYS)
+				return -EINVAL;
+			else
+				idx--;
+		}
+		pr_debug("setting default key (%d)\n", idx);
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID,
+					 idx);
+		if (result)
+			return -EFAULT;
+	}
+
+	if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		if (!(ext->alg & IW_ENCODE_ALG_WEP)) {
+			pr_debug("asked to set a non wep key :(");
+			return -EINVAL;
+		}
+		if (idx) {
+			if (idx < 1 || idx > NUM_WEPKEYS)
+				return -EINVAL;
+			else
+				idx--;
+		}
+		pr_debug("Set WEP key (%d)\n", idx);
+		wlandev->wep_keylens[idx] = ext->key_len;
+		memcpy(wlandev->wep_keys[idx], ext->key, ext->key_len);
+
+		memset(&msg, 0, sizeof(msg));
+		pstr = (p80211item_pstr32_t *)&msg.mibattribute.data;
+		memcpy(pstr->data.data, ext->key, ext->key_len);
+		pstr->data.len = ext->key_len;
+		switch (idx) {
+		case 0:
+			pstr->did =
+			    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
+			break;
+		case 1:
+			pstr->did =
+			    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
+			break;
+		case 2:
+			pstr->did =
+			    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
+			break;
+		case 3:
+			pstr->did =
+			    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
+			break;
+		default:
+			break;
+		}
+		msg.msgcode = DIDmsg_dot11req_mibset;
+		result = p80211req_dorequest(wlandev, (u8 *)&msg);
+		pr_debug("result (%d)\n", result);
+	}
+	return result;
 }
 
 /* SIOCGIWENCODEEXT */
 static int p80211wext_get_encodeext(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
 {
 	wlandevice_t *wlandev = dev->ml_priv;
 	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
@@ -1516,22 +1547,24 @@ static int p80211wext_get_encodeext(stru
 	int max_len;
 	int idx;
 
-	pr_debug("get_encode_ext flags[%d] alg[%d] keylen[%d]\n",ext->ext_flags,(int)ext->alg,(int)ext->key_len);
-
+	pr_debug("get_encode_ext flags[%d] alg[%d] keylen[%d]\n",
+	       ext->ext_flags, (int)ext->alg, (int)ext->key_len);
 
 	max_len = encoding->length - sizeof(*ext);
-	if ( max_len <= 0) {
-		pr_debug("get_encodeext max_len [%d] invalid\n",max_len);
+	if (max_len <= 0) {
+		pr_debug("get_encodeext max_len [%d] invalid\n",
+		       max_len);
 		result = -EINVAL;
 		goto exit;
 	}
 	idx = encoding->flags & IW_ENCODE_INDEX;
 
-	pr_debug("get_encode_ext index [%d]\n",idx);
+	pr_debug("get_encode_ext index [%d]\n", idx);
 
 	if (idx) {
-		if (idx < 1 || idx > NUM_WEPKEYS ) {
-			pr_debug("get_encode_ext invalid key index [%d]\n",idx);
+		if (idx < 1 || idx > NUM_WEPKEYS) {
+			printk(KERN_DEBUG
+			       "get_encode_ext invalid key index [%d]\n", idx);
 			result = -EINVAL;
 			goto exit;
 		}
@@ -1542,198 +1575,207 @@ static int p80211wext_get_encodeext(stru
 	}
 
 	encoding->flags = idx + 1;
-	memset(ext,0,sizeof(*ext));
+	memset(ext, 0, sizeof(*ext));
 
 	ext->alg = IW_ENCODE_ALG_WEP;
 	ext->key_len = wlandev->wep_keylens[idx];
-	memcpy( ext->key, wlandev->wep_keys[idx] , ext->key_len );
+	memcpy(ext->key, wlandev->wep_keys[idx], ext->key_len);
 
 	encoding->flags |= IW_ENCODE_ENABLED;
 exit:
 	return result;
 }
 
-
 /* SIOCSIWAUTH */
-static int p80211_wext_set_iwauth (struct net_device *dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *wrqu, char *extra)
-{
-  wlandevice_t *wlandev = dev->ml_priv;
-  struct iw_param *param = &wrqu->param;
-  int result =0;
-
-  pr_debug("set_iwauth flags[%d]\n",(int)param->flags & IW_AUTH_INDEX );
-
-  switch (param->flags & IW_AUTH_INDEX) {
-  case IW_AUTH_DROP_UNENCRYPTED:
-    pr_debug("drop_unencrypted %d\n",param->value);
-    if (param->value)
-      result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_true);
-    else
-      result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_false);
-    break;
-
-  case IW_AUTH_PRIVACY_INVOKED:
-    pr_debug("privacy invoked %d\n",param->value);
-    if ( param->value)
-      result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_true);
-    else
-      result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_false);
-
-    break;
-
-  case IW_AUTH_80211_AUTH_ALG:
-    if ( param->value & IW_AUTH_ALG_OPEN_SYSTEM ) {
-      pr_debug("set open_system\n");
-      wlandev->hostwep &= ~HOSTWEP_SHAREDKEY;
-    } else if ( param->value & IW_AUTH_ALG_SHARED_KEY) {
-      pr_debug("set shared key\n");
-      wlandev->hostwep |= HOSTWEP_SHAREDKEY;
-    } else {
-      /* don't know what to do know :( */
-      pr_debug("unknown AUTH_ALG (%d)\n",param->value);
-      result = -EINVAL;
-    }
-    break;
-
-  default:
-    break;
-  }
+static int p80211_wext_set_iwauth(struct net_device *dev,
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
+{
+	wlandevice_t *wlandev = dev->ml_priv;
+	struct iw_param *param = &wrqu->param;
+	int result = 0;
+
+	pr_debug("set_iwauth flags[%d]\n",
+	       (int)param->flags & IW_AUTH_INDEX);
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_DROP_UNENCRYPTED:
+		pr_debug("drop_unencrypted %d\n", param->value);
+		if (param->value)
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+						 P80211ENUM_truth_true);
+		else
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+						 P80211ENUM_truth_false);
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		pr_debug("privacy invoked %d\n", param->value);
+		if (param->value)
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+						 P80211ENUM_truth_true);
+		else
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+						 P80211ENUM_truth_false);
+
+		break;
 
+	case IW_AUTH_80211_AUTH_ALG:
+		if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+			pr_debug("set open_system\n");
+			wlandev->hostwep &= ~HOSTWEP_SHAREDKEY;
+		} else if (param->value & IW_AUTH_ALG_SHARED_KEY) {
+			pr_debug("set shared key\n");
+			wlandev->hostwep |= HOSTWEP_SHAREDKEY;
+		} else {
+			/* don't know what to do know  */
+			pr_debug("unknown AUTH_ALG (%d)\n",
+			       param->value);
+			result = -EINVAL;
+		}
+		break;
 
+	default:
+		break;
+	}
 
-  return result;
+	return result;
 }
 
 /* SIOCSIWAUTH */
-static int p80211_wext_get_iwauth (struct net_device *dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *wrqu, char *extra)
-{
-  wlandevice_t *wlandev = dev->ml_priv;
-  struct iw_param *param = &wrqu->param;
-  int result =0;
-
-  pr_debug("get_iwauth flags[%d]\n",(int)param->flags & IW_AUTH_INDEX );
-
-  switch (param->flags & IW_AUTH_INDEX) {
-  case IW_AUTH_DROP_UNENCRYPTED:
-    param->value = wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED?1:0;
-    break;
-
-  case IW_AUTH_PRIVACY_INVOKED:
-    param->value = wlandev->hostwep & HOSTWEP_PRIVACYINVOKED?1:0;
-    break;
-
-  case IW_AUTH_80211_AUTH_ALG:
-    param->value = wlandev->hostwep & HOSTWEP_SHAREDKEY?IW_AUTH_ALG_SHARED_KEY:IW_AUTH_ALG_OPEN_SYSTEM;
-    break;
-
-
-  default:
-    break;
-  }
-
-
-
-  return result;
-}
-
-static iw_handler p80211wext_handlers[] =  {
-	(iw_handler) p80211wext_siwcommit,		/* SIOCSIWCOMMIT */
-	(iw_handler) p80211wext_giwname,		/* SIOCGIWNAME */
-	(iw_handler) NULL,				/* SIOCSIWNWID */
-	(iw_handler) NULL,				/* SIOCGIWNWID */
-	(iw_handler) p80211wext_siwfreq,  		/* SIOCSIWFREQ */
-	(iw_handler) p80211wext_giwfreq,  		/* SIOCGIWFREQ */
-	(iw_handler) p80211wext_siwmode,       		/* SIOCSIWMODE */
-	(iw_handler) p80211wext_giwmode,       		/* SIOCGIWMODE */
-	(iw_handler) NULL,                 		/* SIOCSIWSENS */
-	(iw_handler) NULL,                		/* SIOCGIWSENS */
-	(iw_handler) NULL, /* not used */     		/* SIOCSIWRANGE */
-	(iw_handler) p80211wext_giwrange,      		/* SIOCGIWRANGE */
-	(iw_handler) NULL, /* not used */     		/* SIOCSIWPRIV */
-	(iw_handler) NULL, /* kernel code */   		/* SIOCGIWPRIV */
-	(iw_handler) NULL, /* not used */     		/* SIOCSIWSTATS */
-	(iw_handler) NULL, /* kernel code */   		/* SIOCGIWSTATS */
-	(iw_handler) p80211wext_siwspy,			/* SIOCSIWSPY */
-	(iw_handler) p80211wext_giwspy,			/* SIOCGIWSPY */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,              		/* SIOCSIWAP */
-	(iw_handler) p80211wext_giwap,         		/* SIOCGIWAP */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,                  		/* SIOCGIWAPLIST */
-	(iw_handler) p80211wext_siwscan,		/* SIOCSIWSCAN */
-	(iw_handler) p80211wext_giwscan,		/* SIOCGIWSCAN */
-	(iw_handler) p80211wext_siwessid,  		/* SIOCSIWESSID */
-	(iw_handler) p80211wext_giwessid,      		/* SIOCGIWESSID */
-	(iw_handler) NULL,                 		/* SIOCSIWNICKN */
-	(iw_handler) p80211wext_giwessid,      		/* SIOCGIWNICKN */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,                		/* SIOCSIWRATE */
-	(iw_handler) p80211wext_giwrate,      		/* SIOCGIWRATE */
-	(iw_handler) p80211wext_siwrts,  		/* SIOCSIWRTS */
-	(iw_handler) p80211wext_giwrts,        		/* SIOCGIWRTS */
-	(iw_handler) p80211wext_siwfrag,      		/* SIOCSIWFRAG */
-	(iw_handler) p80211wext_giwfrag,   		/* SIOCGIWFRAG */
-	(iw_handler) p80211wext_siwtxpow,           	/* SIOCSIWTXPOW */
-	(iw_handler) p80211wext_giwtxpow,  		/* SIOCGIWTXPOW */
-	(iw_handler) p80211wext_siwretry,     		/* SIOCSIWRETRY */
-	(iw_handler) p80211wext_giwretry,  		/* SIOCGIWRETRY */
-	(iw_handler) p80211wext_siwencode,     		/* SIOCSIWENCODE */
-	(iw_handler) p80211wext_giwencode,  		/* SIOCGIWENCODE */
-	(iw_handler) NULL,                 		/* SIOCSIWPOWER */
-	(iw_handler) NULL,                  		/* SIOCGIWPOWER */
+static int p80211_wext_get_iwauth(struct net_device *dev,
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
+{
+	wlandevice_t *wlandev = dev->ml_priv;
+	struct iw_param *param = &wrqu->param;
+	int result = 0;
+
+	pr_debug("get_iwauth flags[%d]\n",
+	       (int)param->flags & IW_AUTH_INDEX);
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_DROP_UNENCRYPTED:
+		param->value =
+		    wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED ? 1 : 0;
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		param->value =
+		    wlandev->hostwep & HOSTWEP_PRIVACYINVOKED ? 1 : 0;
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		param->value =
+		    wlandev->
+		    hostwep & HOSTWEP_SHAREDKEY ? IW_AUTH_ALG_SHARED_KEY :
+		    IW_AUTH_ALG_OPEN_SYSTEM;
+		break;
+
+	default:
+		break;
+	}
+
+	return result;
+}
+
+static iw_handler p80211wext_handlers[] = {
+	(iw_handler) p80211wext_siwcommit,	/* SIOCSIWCOMMIT */
+	(iw_handler) p80211wext_giwname,	/* SIOCGIWNAME */
+	(iw_handler) NULL,	/* SIOCSIWNWID */
+	(iw_handler) NULL,	/* SIOCGIWNWID */
+	(iw_handler) p80211wext_siwfreq,	/* SIOCSIWFREQ */
+	(iw_handler) p80211wext_giwfreq,	/* SIOCGIWFREQ */
+	(iw_handler) p80211wext_siwmode,	/* SIOCSIWMODE */
+	(iw_handler) p80211wext_giwmode,	/* SIOCGIWMODE */
+	(iw_handler) NULL,	/* SIOCSIWSENS */
+	(iw_handler) NULL,	/* SIOCGIWSENS */
+	(iw_handler) NULL,	/* not used *//* SIOCSIWRANGE */
+	(iw_handler) p80211wext_giwrange,	/* SIOCGIWRANGE */
+	(iw_handler) NULL,	/* not used *//* SIOCSIWPRIV */
+	(iw_handler) NULL,	/* kernel code *//* SIOCGIWPRIV */
+	(iw_handler) NULL,	/* not used *//* SIOCSIWSTATS */
+	(iw_handler) NULL,	/* kernel code *//* SIOCGIWSTATS */
+	(iw_handler) p80211wext_siwspy,	/* SIOCSIWSPY */
+	(iw_handler) p80211wext_giwspy,	/* SIOCGIWSPY */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* SIOCSIWAP */
+	(iw_handler) p80211wext_giwap,	/* SIOCGIWAP */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* SIOCGIWAPLIST */
+	(iw_handler) p80211wext_siwscan,	/* SIOCSIWSCAN */
+	(iw_handler) p80211wext_giwscan,	/* SIOCGIWSCAN */
+	(iw_handler) p80211wext_siwessid,	/* SIOCSIWESSID */
+	(iw_handler) p80211wext_giwessid,	/* SIOCGIWESSID */
+	(iw_handler) NULL,	/* SIOCSIWNICKN */
+	(iw_handler) p80211wext_giwessid,	/* SIOCGIWNICKN */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* SIOCSIWRATE */
+	(iw_handler) p80211wext_giwrate,	/* SIOCGIWRATE */
+	(iw_handler) p80211wext_siwrts,	/* SIOCSIWRTS */
+	(iw_handler) p80211wext_giwrts,	/* SIOCGIWRTS */
+	(iw_handler) p80211wext_siwfrag,	/* SIOCSIWFRAG */
+	(iw_handler) p80211wext_giwfrag,	/* SIOCGIWFRAG */
+	(iw_handler) p80211wext_siwtxpow,	/* SIOCSIWTXPOW */
+	(iw_handler) p80211wext_giwtxpow,	/* SIOCGIWTXPOW */
+	(iw_handler) p80211wext_siwretry,	/* SIOCSIWRETRY */
+	(iw_handler) p80211wext_giwretry,	/* SIOCGIWRETRY */
+	(iw_handler) p80211wext_siwencode,	/* SIOCSIWENCODE */
+	(iw_handler) p80211wext_giwencode,	/* SIOCGIWENCODE */
+	(iw_handler) NULL,	/* SIOCSIWPOWER */
+	(iw_handler) NULL,	/* SIOCGIWPOWER */
 /* WPA operations */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL, /* SIOCSIWGENIE	set generic IE */
-	(iw_handler) NULL, /* SIOCGIWGENIE	get generic IE */
-	(iw_handler) p80211_wext_set_iwauth, /* SIOCSIWAUTH	set authentication mode params */
-	(iw_handler) p80211_wext_get_iwauth, /* SIOCGIWAUTH	get authentication mode params */
-
-	(iw_handler) p80211wext_set_encodeext, /* SIOCSIWENCODEEXT  set encoding token & mode */
-	(iw_handler) p80211wext_get_encodeext, /* SIOCGIWENCODEEXT  get encoding token & mode */
-	(iw_handler) NULL, /* SIOCSIWPMKSA	PMKSA cache operation */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* SIOCSIWGENIE      set generic IE */
+	(iw_handler) NULL,	/* SIOCGIWGENIE      get generic IE */
+	(iw_handler) p80211_wext_set_iwauth,	/* SIOCSIWAUTH     set authentication mode params */
+	(iw_handler) p80211_wext_get_iwauth,	/* SIOCGIWAUTH     get authentication mode params */
+
+	(iw_handler) p80211wext_set_encodeext,	/* SIOCSIWENCODEEXT  set encoding token & mode */
+	(iw_handler) p80211wext_get_encodeext,	/* SIOCGIWENCODEEXT  get encoding token & mode */
+	(iw_handler) NULL,	/* SIOCSIWPMKSA      PMKSA cache operation */
 };
 
 struct iw_handler_def p80211wext_handler_def = {
 	.num_standard = ARRAY_SIZE(p80211wext_handlers),
 	.num_private = 0,
 	.num_private_args = 0,
-        .standard = p80211wext_handlers,
+	.standard = p80211wext_handlers,
 	.private = NULL,
 	.private_args = NULL,
 	.get_wireless_stats = p80211wext_get_wireless_stats
 };
 
-
 int p80211wext_event_associated(wlandevice_t *wlandev, int assoc)
 {
-        union iwreq_data data;
+	union iwreq_data data;
 
-        /* Send the association state first */
-        data.ap_addr.sa_family = ARPHRD_ETHER;
-        if (assoc) {
-                memcpy(data.ap_addr.sa_data, wlandev->bssid, ETH_ALEN);
-        } else {
-                memset(data.ap_addr.sa_data, 0, ETH_ALEN);
-        }
+	/* Send the association state first */
+	data.ap_addr.sa_family = ARPHRD_ETHER;
+	if (assoc)
+		memcpy(data.ap_addr.sa_data, wlandev->bssid, ETH_ALEN);
+	else
+		memset(data.ap_addr.sa_data, 0, ETH_ALEN);
 
-        if (wlan_wext_write)
-                wireless_send_event(wlandev->netdev, SIOCGIWAP, &data, NULL);
+	if (wlan_wext_write)
+		wireless_send_event(wlandev->netdev, SIOCGIWAP, &data, NULL);
 
-        if (!assoc) goto done;
+	if (!assoc)
+		goto done;
 
-        // XXX send association data, like IEs, etc etc.
+	/* XXX send association data, like IEs, etc etc. */
 
- done:
-        return 0;
+done:
+	return 0;
 }
-
-
-
-
