From foo@baz Wed Jul 29 15:40:18 PDT 2009
Date: Wed, 29 Jul 2009 15:40:18 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Staging: hv: osd: add osd_ prefix to global functions

From: Greg Kroah-Hartman <gregkh@suse.de>

Put a "osd_" prefix on the osd.c functions in order for us to play nicer
in the kernel namespace.

Cc: Bill Pemberton <wfp5p@virginia.edu>
Cc: Hank Janssen <hjanssen@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/hv/Channel.c     |   26 +++++++++++++-------------
 drivers/staging/hv/ChannelMgmt.c |   18 +++++++++---------
 drivers/staging/hv/Connection.c  |   14 +++++++-------
 drivers/staging/hv/Hv.c          |   16 ++++++++--------
 drivers/staging/hv/NetVsc.c      |   24 ++++++++++++------------
 drivers/staging/hv/RndisFilter.c |   10 +++++-----
 drivers/staging/hv/StorVsc.c     |   16 ++++++++--------
 drivers/staging/hv/include/osd.h |   27 ++++++++++++---------------
 drivers/staging/hv/osd.c         |   32 +++++++++++---------------------
 9 files changed, 85 insertions(+), 98 deletions(-)

--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -230,7 +230,7 @@ VmbusChannelOpen(
 	NewChannel->ChannelCallbackContext = Context;
 
 	/* Allocate the ring buffer */
-	out = PageAlloc((SendRingBufferSize + RecvRingBufferSize) >> PAGE_SHIFT);
+	out = osd_PageAlloc((SendRingBufferSize + RecvRingBufferSize) >> PAGE_SHIFT);
 	/* out = kzalloc(sendRingBufferSize + recvRingBufferSize, GFP_KERNEL); */
 	ASSERT(out);
 	ASSERT(((unsigned long)out & (PAGE_SIZE-1)) == 0);
@@ -268,7 +268,7 @@ VmbusChannelOpen(
 	openInfo = kmalloc(sizeof(VMBUS_CHANNEL_MSGINFO) + sizeof(VMBUS_CHANNEL_OPEN_CHANNEL), GFP_KERNEL);
 	ASSERT(openInfo != NULL);
 
-	openInfo->WaitEvent = WaitEventCreate();
+	openInfo->WaitEvent = osd_WaitEventCreate();
 
 	openMsg = (VMBUS_CHANNEL_OPEN_CHANNEL*)openInfo->Msg;
 	openMsg->Header.MessageType				= ChannelMessageOpenChannel;
@@ -299,7 +299,7 @@ VmbusChannelOpen(
 	}
 
 	/* FIXME: Need to time-out here */
-	WaitEventWait(openInfo->WaitEvent);
+	osd_WaitEventWait(openInfo->WaitEvent);
 
 	if (openInfo->Response.OpenResult.Status == 0)
 	{
@@ -547,7 +547,7 @@ VmbusChannelEstablishGpadl(
 	ASSERT(msgInfo != NULL);
 	ASSERT(msgCount >0);
 
-	msgInfo->WaitEvent = WaitEventCreate();
+	msgInfo->WaitEvent = osd_WaitEventCreate();
 	gpadlMsg = (VMBUS_CHANNEL_GPADL_HEADER*)msgInfo->Msg;
 	gpadlMsg->Header.MessageType = ChannelMessageGpadlHeader;
 	gpadlMsg->ChildRelId = Channel->OfferMsg.ChildRelId;
@@ -587,7 +587,7 @@ VmbusChannelEstablishGpadl(
 			ASSERT(ret == 0);
 		}
 	}
-	WaitEventWait(msgInfo->WaitEvent);
+	osd_WaitEventWait(msgInfo->WaitEvent);
 
 	/* At this point, we received the gpadl created msg */
 	DPRINT_DBG(VMBUS, "Received GPADL created (relid %d, status %d handle %x)",
@@ -639,7 +639,7 @@ VmbusChannelTeardownGpadl(
 	info = kmalloc(sizeof(VMBUS_CHANNEL_MSGINFO) + sizeof(VMBUS_CHANNEL_GPADL_TEARDOWN), GFP_KERNEL);
 	ASSERT(info != NULL);
 
-	info->WaitEvent = WaitEventCreate();
+	info->WaitEvent = osd_WaitEventCreate();
 
 	msg = (VMBUS_CHANNEL_GPADL_TEARDOWN*)info->Msg;
 
@@ -657,7 +657,7 @@ VmbusChannelTeardownGpadl(
 		/* TODO: */
 	}
 
-	WaitEventWait(info->WaitEvent);
+	osd_WaitEventWait(info->WaitEvent);
 
 	/* Received a torndown response */
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
@@ -696,13 +696,13 @@ VmbusChannelClose(
 
 	/* Stop callback and cancel the timer asap */
 	Channel->OnChannelCallback = NULL;
-	TimerStop(Channel->PollTimer);
+	osd_TimerStop(Channel->PollTimer);
 
 	/* Send a closing message */
 	info = kmalloc(sizeof(VMBUS_CHANNEL_MSGINFO) + sizeof(VMBUS_CHANNEL_CLOSE_CHANNEL), GFP_KERNEL);
 	ASSERT(info != NULL);
 
-	/* info->waitEvent = WaitEventCreate(); */
+	/* info->waitEvent = osd_WaitEventCreate(); */
 
 	msg = (VMBUS_CHANNEL_CLOSE_CHANNEL*)info->Msg;
 	msg->Header.MessageType				= ChannelMessageCloseChannel;
@@ -726,7 +726,7 @@ VmbusChannelClose(
 	RingBufferCleanup(&Channel->Outbound);
 	RingBufferCleanup(&Channel->Inbound);
 
-	PageFree(Channel->RingBufferPages, Channel->RingBufferPageCount);
+	osd_PageFree(Channel->RingBufferPages, Channel->RingBufferPageCount);
 
 	kfree(info);
 
@@ -1154,9 +1154,9 @@ VmbusChannelOnChannelEvent(
 	DumpVmbusChannel(Channel);
 	ASSERT(Channel->OnChannelCallback);
 #ifdef ENABLE_POLLING
-	TimerStop(Channel->PollTimer);
+	osd_TimerStop(Channel->PollTimer);
 	Channel->OnChannelCallback(Channel->ChannelCallbackContext);
-	TimerStart(Channel->PollTimer, 100 /* 100us */);
+	osd_TimerStart(Channel->PollTimer, 100 /* 100us */);
 #else
 	Channel->OnChannelCallback(Channel->ChannelCallbackContext);
 #endif
@@ -1182,7 +1182,7 @@ VmbusChannelOnTimer(
 	{
 		channel->OnChannelCallback(channel->ChannelCallbackContext);
 #ifdef ENABLE_POLLING
-		TimerStart(channel->PollTimer, 100 /* 100us */);
+		osd_TimerStart(channel->PollTimer, 100 /* 100us */);
 #endif
 	}
 }
--- a/drivers/staging/hv/ChannelMgmt.c
+++ b/drivers/staging/hv/ChannelMgmt.c
@@ -141,7 +141,7 @@ static VMBUS_CHANNEL* AllocVmbusChannel(
 
 	spin_lock_init(&channel->inbound_lock);
 
-	channel->PollTimer = TimerCreate(VmbusChannelOnTimer, channel);
+	channel->PollTimer = osd_TimerCreate(VmbusChannelOnTimer, channel);
 	if (!channel->PollTimer)
 	{
 		kfree(channel);
@@ -152,7 +152,7 @@ static VMBUS_CHANNEL* AllocVmbusChannel(
 	channel->ControlWQ = create_workqueue("hv_vmbus_ctl");
 	if (!channel->ControlWQ)
 	{
-		TimerClose(channel->PollTimer);
+		osd_TimerClose(channel->PollTimer);
 		kfree(channel);
 		return NULL;
 	}
@@ -195,7 +195,7 @@ Description:
 --*/
 static void FreeVmbusChannel(VMBUS_CHANNEL* Channel)
 {
-	TimerClose(Channel->PollTimer);
+	osd_TimerClose(Channel->PollTimer);
 
 	/* We have to release the channel's workqueue/thread in the vmbus's workqueue/thread context */
 	/* ie we can't destroy ourselves. */
@@ -495,7 +495,7 @@ VmbusChannelOnOpenResult(
 				openMsg->OpenId == result->OpenId)
 			{
 				memcpy(&msgInfo->Response.OpenResult, result, sizeof(VMBUS_CHANNEL_OPEN_RESULT));
-				WaitEventSet(msgInfo->WaitEvent);
+				osd_WaitEventSet(msgInfo->WaitEvent);
 				break;
 			}
 		}
@@ -550,7 +550,7 @@ VmbusChannelOnGpadlCreated(
 					(gpadlCreated->Gpadl == gpadlHeader->Gpadl))
 			{
 				memcpy(&msgInfo->Response.GpadlCreated, gpadlCreated, sizeof(VMBUS_CHANNEL_GPADL_CREATED));
-				WaitEventSet(msgInfo->WaitEvent);
+				osd_WaitEventSet(msgInfo->WaitEvent);
 				break;
 			}
 		}
@@ -602,7 +602,7 @@ VmbusChannelOnGpadlTorndown(
 			if (gpadlTorndown->Gpadl == gpadlTeardown->Gpadl)
 			{
 				memcpy(&msgInfo->Response.GpadlTorndown, gpadlTorndown, sizeof(VMBUS_CHANNEL_GPADL_TORNDOWN));
-				WaitEventSet(msgInfo->WaitEvent);
+				osd_WaitEventSet(msgInfo->WaitEvent);
 				break;
 			}
 		}
@@ -650,7 +650,7 @@ VmbusChannelOnVersionResponse(
 		{
 			initiate = (VMBUS_CHANNEL_INITIATE_CONTACT*)requestHeader;
 			memcpy(&msgInfo->Response.VersionResponse, versionResponse, sizeof(VMBUS_CHANNEL_VERSION_RESPONSE));
-			WaitEventSet(msgInfo->WaitEvent);
+			osd_WaitEventSet(msgInfo->WaitEvent);
 		}
 	}
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
@@ -732,7 +732,7 @@ VmbusChannelRequestOffers(
 	msgInfo = kmalloc(sizeof(VMBUS_CHANNEL_MSGINFO) + sizeof(VMBUS_CHANNEL_MESSAGE_HEADER), GFP_KERNEL);
 	ASSERT(msgInfo != NULL);
 
-	msgInfo->WaitEvent = WaitEventCreate();
+	msgInfo->WaitEvent = osd_WaitEventCreate();
 	msg = (VMBUS_CHANNEL_MESSAGE_HEADER*)msgInfo->Msg;
 
 	msg->MessageType = ChannelMessageRequestOffers;
@@ -752,7 +752,7 @@ VmbusChannelRequestOffers(
 
 		goto Cleanup;
 	}
-	/* WaitEventWait(msgInfo->waitEvent); */
+	/* osd_WaitEventWait(msgInfo->waitEvent); */
 
 	/*SpinlockAcquire(gVmbusConnection.channelMsgLock);
 	REMOVE_ENTRY_LIST(&msgInfo->msgListEntry);
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -77,7 +77,7 @@ VmbusConnect(void)
 	 * Setup the vmbus event connection for channel interrupt
 	 * abstraction stuff
 	 */
-	gVmbusConnection.InterruptPage = PageAlloc(1);
+	gVmbusConnection.InterruptPage = osd_PageAlloc(1);
 	if (gVmbusConnection.InterruptPage == NULL)
 	{
 		ret = -1;
@@ -91,7 +91,7 @@ VmbusConnect(void)
 	 * notification facility. The 1st page for parent->child and
 	 * the 2nd page for child->parent
 	 */
-	gVmbusConnection.MonitorPages = PageAlloc(2);
+	gVmbusConnection.MonitorPages = osd_PageAlloc(2);
 	if (gVmbusConnection.MonitorPages == NULL)
 	{
 		ret = -1;
@@ -105,7 +105,7 @@ VmbusConnect(void)
 		goto Cleanup;
 	}
 
-	msgInfo->WaitEvent = WaitEventCreate();
+	msgInfo->WaitEvent = osd_WaitEventCreate();
 	msg = (VMBUS_CHANNEL_INITIATE_CONTACT*)msgInfo->Msg;
 
 	msg->Header.MessageType = ChannelMessageInitiateContact;
@@ -135,7 +135,7 @@ VmbusConnect(void)
 	}
 
 	/* Wait for the connection response */
-	WaitEventWait(msgInfo->WaitEvent);
+	osd_WaitEventWait(msgInfo->WaitEvent);
 
 	REMOVE_ENTRY_LIST(&msgInfo->MsgListEntry);
 
@@ -170,13 +170,13 @@ Cleanup:
 
 	if (gVmbusConnection.InterruptPage)
 	{
-		PageFree(gVmbusConnection.InterruptPage, 1);
+		osd_PageFree(gVmbusConnection.InterruptPage, 1);
 		gVmbusConnection.InterruptPage = NULL;
 	}
 
 	if (gVmbusConnection.MonitorPages)
 	{
-		PageFree(gVmbusConnection.MonitorPages, 2);
+		osd_PageFree(gVmbusConnection.MonitorPages, 2);
 		gVmbusConnection.MonitorPages = NULL;
 	}
 
@@ -228,7 +228,7 @@ VmbusDisconnect(
 		goto Cleanup;
 	}
 
-	PageFree(gVmbusConnection.InterruptPage, 1);
+	osd_PageFree(gVmbusConnection.InterruptPage, 1);
 
 	/* TODO: iterate thru the msg list and free up */
 
--- a/drivers/staging/hv/Hv.c
+++ b/drivers/staging/hv/Hv.c
@@ -267,8 +267,8 @@ HvInit (
 	if (gHvContext.GuestId == HV_LINUX_GUEST_ID)
 	{
 		/* Allocate the hypercall page memory */
-		/* virtAddr = PageAlloc(1); */
-		virtAddr = VirtualAllocExec(PAGE_SIZE);
+		/* virtAddr = osd_PageAlloc(1); */
+		virtAddr = osd_VirtualAllocExec(PAGE_SIZE);
 
 		if (!virtAddr)
 		{
@@ -520,14 +520,14 @@ HvSynicInit (
 	}
 	else
 	{
-		gHvContext.synICMessagePage[0] = PageAlloc(1);
+		gHvContext.synICMessagePage[0] = osd_PageAlloc(1);
 		if (gHvContext.synICMessagePage[0] == NULL)
 		{
 			DPRINT_ERR(VMBUS, "unable to allocate SYNIC message page!!");
 			goto Cleanup;
 		}
 
-		gHvContext.synICEventPage[0] = PageAlloc(1);
+		gHvContext.synICEventPage[0] = osd_PageAlloc(1);
 		if (gHvContext.synICEventPage[0] == NULL)
 		{
 			DPRINT_ERR(VMBUS, "unable to allocate SYNIC event page!!");
@@ -587,12 +587,12 @@ Cleanup:
 	{
 		if (gHvContext.synICEventPage[0])
 		{
-			PageFree(gHvContext.synICEventPage[0],1);
+			osd_PageFree(gHvContext.synICEventPage[0],1);
 		}
 
 		if (gHvContext.synICMessagePage[0])
 		{
-			PageFree(gHvContext.synICMessagePage[0], 1);
+			osd_PageFree(gHvContext.synICMessagePage[0], 1);
 		}
 	}
 
@@ -654,8 +654,8 @@ HvSynicCleanup(
 
 		WriteMsr(HV_X64_MSR_SIEFP, siefp.AsUINT64);
 
-		PageFree(gHvContext.synICMessagePage[0], 1);
-		PageFree(gHvContext.synICEventPage[0], 1);
+		osd_PageFree(gHvContext.synICMessagePage[0], 1);
+		osd_PageFree(gHvContext.synICEventPage[0], 1);
 	}
 
 	DPRINT_EXIT(VMBUS);
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -68,25 +68,22 @@ struct osd_timer {
 
 /* Osd routines */
 
-extern void* VirtualAllocExec(unsigned int size);
+extern void *osd_VirtualAllocExec(unsigned int size);
 
-extern void* PageAlloc(unsigned int count);
-extern void PageFree(void* page, unsigned int count);
+extern void *osd_PageAlloc(unsigned int count);
+extern void osd_PageFree(void* page, unsigned int count);
 
-extern void* MemMapIO(unsigned long phys, unsigned long size);
-extern void MemUnmapIO(void* virt);
-
-extern struct osd_timer *TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context);
-extern void TimerClose(struct osd_timer *t);
-extern int TimerStop(struct osd_timer *t);
-extern void TimerStart(struct osd_timer *t, u32 expirationInUs);
-
-extern struct osd_waitevent *WaitEventCreate(void);
-extern void WaitEventSet(struct osd_waitevent *waitEvent);
-extern int	WaitEventWait(struct osd_waitevent *waitEvent);
+extern struct osd_timer *osd_TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context);
+extern void osd_TimerClose(struct osd_timer *t);
+extern int osd_TimerStop(struct osd_timer *t);
+extern void osd_TimerStart(struct osd_timer *t, u32 expirationInUs);
+
+extern struct osd_waitevent *osd_WaitEventCreate(void);
+extern void osd_WaitEventSet(struct osd_waitevent *waitEvent);
+extern int osd_WaitEventWait(struct osd_waitevent *waitEvent);
 
 /* If >0, waitEvent got signaled. If ==0, timeout. If < 0, error */
-extern int	WaitEventWaitEx(struct osd_waitevent *waitEvent, u32 TimeoutInMs);
+extern int osd_WaitEventWaitEx(struct osd_waitevent *waitEvent, u32 TimeoutInMs);
 
 
 int osd_schedule_callback(struct workqueue_struct *wq,
--- a/drivers/staging/hv/NetVsc.c
+++ b/drivers/staging/hv/NetVsc.c
@@ -280,7 +280,7 @@ NetVscInitializeReceiveBufferWithNetVsp(
 	ASSERT(netDevice->ReceiveBufferSize > 0);
 	ASSERT((netDevice->ReceiveBufferSize & (PAGE_SIZE-1)) == 0); /* page-size grandularity */
 
-	netDevice->ReceiveBuffer = PageAlloc(netDevice->ReceiveBufferSize >> PAGE_SHIFT);
+	netDevice->ReceiveBuffer = osd_PageAlloc(netDevice->ReceiveBufferSize >> PAGE_SHIFT);
 	if (!netDevice->ReceiveBuffer)
 	{
 		DPRINT_ERR(NETVSC, "unable to allocate receive buffer of size %d", netDevice->ReceiveBufferSize);
@@ -307,7 +307,7 @@ NetVscInitializeReceiveBufferWithNetVsp(
 		goto Cleanup;
 	}
 
-	/* WaitEventWait(ext->ChannelInitEvent); */
+	/* osd_WaitEventWait(ext->ChannelInitEvent); */
 
 	/* Notify the NetVsp of the gpadl handle */
 	DPRINT_INFO(NETVSC, "Sending NvspMessage1TypeSendReceiveBuffer...");
@@ -333,7 +333,7 @@ NetVscInitializeReceiveBufferWithNetVsp(
 		goto Cleanup;
 	}
 
-	WaitEventWait(netDevice->ChannelInitEvent);
+	osd_WaitEventWait(netDevice->ChannelInitEvent);
 
 	/* Check the response */
 	if (initPacket->Messages.Version1Messages.SendReceiveBufferComplete.Status != NvspStatusSuccess)
@@ -409,7 +409,7 @@ NetVscInitializeSendBufferWithNetVsp(
 	ASSERT(netDevice->SendBufferSize > 0);
 	ASSERT((netDevice->SendBufferSize & (PAGE_SIZE-1)) == 0); /* page-size grandularity */
 
-	netDevice->SendBuffer = PageAlloc(netDevice->SendBufferSize >> PAGE_SHIFT);
+	netDevice->SendBuffer = osd_PageAlloc(netDevice->SendBufferSize >> PAGE_SHIFT);
 	if (!netDevice->SendBuffer)
 	{
 		DPRINT_ERR(NETVSC, "unable to allocate send buffer of size %d", netDevice->SendBufferSize);
@@ -436,7 +436,7 @@ NetVscInitializeSendBufferWithNetVsp(
 		goto Cleanup;
 	}
 
-	/* WaitEventWait(ext->ChannelInitEvent); */
+	/* osd_WaitEventWait(ext->ChannelInitEvent); */
 
 	/* Notify the NetVsp of the gpadl handle */
 	DPRINT_INFO(NETVSC, "Sending NvspMessage1TypeSendSendBuffer...");
@@ -462,7 +462,7 @@ NetVscInitializeSendBufferWithNetVsp(
 		goto Cleanup;
 	}
 
-	WaitEventWait(netDevice->ChannelInitEvent);
+	osd_WaitEventWait(netDevice->ChannelInitEvent);
 
 	/* Check the response */
 	if (initPacket->Messages.Version1Messages.SendSendBufferComplete.Status != NvspStatusSuccess)
@@ -556,7 +556,7 @@ NetVscDestroyReceiveBuffer(
 		DPRINT_INFO(NETVSC, "Freeing up receive buffer...");
 
 		/* Free up the receive buffer */
-		PageFree(NetDevice->ReceiveBuffer, NetDevice->ReceiveBufferSize >> PAGE_SHIFT);
+		osd_PageFree(NetDevice->ReceiveBuffer, NetDevice->ReceiveBufferSize >> PAGE_SHIFT);
 		NetDevice->ReceiveBuffer = NULL;
 	}
 
@@ -641,7 +641,7 @@ NetVscDestroySendBuffer(
 		DPRINT_INFO(NETVSC, "Freeing up send buffer...");
 
 		/* Free up the receive buffer */
-		PageFree(NetDevice->SendBuffer, NetDevice->SendBufferSize >> PAGE_SHIFT);
+		osd_PageFree(NetDevice->SendBuffer, NetDevice->SendBufferSize >> PAGE_SHIFT);
 		NetDevice->SendBuffer = NULL;
 	}
 
@@ -695,7 +695,7 @@ NetVscConnectToVsp(
 		goto Cleanup;
 	}
 
-	WaitEventWait(netDevice->ChannelInitEvent);
+	osd_WaitEventWait(netDevice->ChannelInitEvent);
 
 	/* Now, check the response */
 	/* ASSERT(initPacket->Messages.InitMessages.InitComplete.MaximumMdlChainLength <= MAX_MULTIPAGE_BUFFER_COUNT); */
@@ -747,7 +747,7 @@ NetVscConnectToVsp(
 	 * packet) since our Vmbus always set the
 	 * VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED flag
 	 */
-	 /* WaitEventWait(NetVscChannel->ChannelInitEvent); */
+	 /* osd_WaitEventWait(NetVscChannel->ChannelInitEvent); */
 
 	/* Post the big receive buffer to NetVSP */
 	ret = NetVscInitializeReceiveBufferWithNetVsp(Device);
@@ -830,7 +830,7 @@ NetVscOnDeviceAdd(
 
 		INSERT_TAIL_LIST(&netDevice->ReceivePacketList, &packet->ListEntry);
 	}
-	netDevice->ChannelInitEvent = WaitEventCreate();
+	netDevice->ChannelInitEvent = osd_WaitEventCreate();
 
 	/* Open the channel */
 	ret = Device->Driver->VmbusChannelInterface.Open(Device,
@@ -1014,7 +1014,7 @@ NetVscOnSendCompletion(
 	{
 		/* Copy the response back */
 		memcpy(&netDevice->ChannelInitPacket, nvspPacket, sizeof(NVSP_MESSAGE));
-		WaitEventSet(netDevice->ChannelInitEvent);
+		osd_WaitEventSet(netDevice->ChannelInitEvent);
 	}
 	else if (nvspPacket->Header.MessageType == NvspMessage1TypeSendRNDISPacketComplete)
 	{
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -56,7 +56,7 @@ struct osd_callback_struct {
 	void *data;
 };
 
-void* VirtualAllocExec(unsigned int size)
+void *osd_VirtualAllocExec(unsigned int size)
 {
 #ifdef __x86_64__
 	return __vmalloc(size, GFP_KERNEL, PAGE_KERNEL_EXEC);
@@ -65,7 +65,7 @@ void* VirtualAllocExec(unsigned int size
 #endif
 }
 
-void* PageAlloc(unsigned int count)
+void *osd_PageAlloc(unsigned int count)
 {
 	void *p;
 	p = (void *)__get_free_pages(GFP_KERNEL, get_order(count * PAGE_SIZE));
@@ -81,23 +81,13 @@ void* PageAlloc(unsigned int count)
 	/* return p; */
 }
 
-void PageFree(void* page, unsigned int count)
+void osd_PageFree(void* page, unsigned int count)
 {
 	free_pages((unsigned long)page, get_order(count * PAGE_SIZE));
 	/*struct page* p = virt_to_page(page);
 	__free_page(p);*/
 }
 
-void *MemMapIO(unsigned long phys, unsigned long size)
-{
-	return (void*)phys_to_virt(phys); /* return ioremap_nocache(phys, size); */
-}
-
-void MemUnmapIO(void *virt)
-{
-	/* iounmap(virt); */
-}
-
 static void TimerCallback(unsigned long data)
 {
 	struct osd_timer *t = (struct osd_timer *) data;
@@ -105,7 +95,7 @@ static void TimerCallback(unsigned long 
 	t->callback(t->context);
 }
 
-struct osd_timer *TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context)
+struct osd_timer *osd_TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context)
 {
 	struct osd_timer *t = kmalloc(sizeof(struct osd_timer), GFP_KERNEL);
 	if (!t)
@@ -123,24 +113,24 @@ struct osd_timer *TimerCreate(PFN_TIMER_
 	return t;
 }
 
-void TimerStart(struct osd_timer *t, u32 expirationInUs)
+void osd_TimerStart(struct osd_timer *t, u32 expirationInUs)
 {
 	t->timer.expires = jiffies + usecs_to_jiffies(expirationInUs);
 	add_timer(&t->timer);
 }
 
-int TimerStop(struct osd_timer *t)
+int osd_TimerStop(struct osd_timer *t)
 {
 	return del_timer(&t->timer);
 }
 
-void TimerClose(struct osd_timer *t)
+void osd_TimerClose(struct osd_timer *t)
 {
 	del_timer(&t->timer);
 	kfree(t);
 }
 
-struct osd_waitevent *WaitEventCreate(void)
+struct osd_waitevent *osd_WaitEventCreate(void)
 {
 	struct osd_waitevent *wait = kmalloc(sizeof(struct osd_waitevent), GFP_KERNEL);
 	if (!wait)
@@ -153,13 +143,13 @@ struct osd_waitevent *WaitEventCreate(vo
 	return wait;
 }
 
-void WaitEventSet(struct osd_waitevent *waitEvent)
+void osd_WaitEventSet(struct osd_waitevent *waitEvent)
 {
 	waitEvent->condition = 1;
 	wake_up_interruptible(&waitEvent->event);
 }
 
-int WaitEventWait(struct osd_waitevent *waitEvent)
+int osd_WaitEventWait(struct osd_waitevent *waitEvent)
 {
 	int ret=0;
 
@@ -169,7 +159,7 @@ int WaitEventWait(struct osd_waitevent *
 	return ret;
 }
 
-int WaitEventWaitEx(struct osd_waitevent *waitEvent, u32 TimeoutInMs)
+int osd_WaitEventWaitEx(struct osd_waitevent *waitEvent, u32 TimeoutInMs)
 {
 	int ret=0;
 
--- a/drivers/staging/hv/RndisFilter.c
+++ b/drivers/staging/hv/RndisFilter.c
@@ -244,7 +244,7 @@ static inline RNDIS_REQUEST* GetRndisReq
 		return NULL;
 	}
 
-	request->WaitEvent = WaitEventCreate();
+	request->WaitEvent = osd_WaitEventCreate();
 	if (!request->WaitEvent)
 	{
 		kfree(request);
@@ -424,7 +424,7 @@ RndisFilterReceiveResponse(
 			}
 		}
 
-		WaitEventSet(request->WaitEvent);
+		osd_WaitEventSet(request->WaitEvent);
 	}
 	else
 	{
@@ -621,7 +621,7 @@ RndisFilterQueryDevice(
 		goto Cleanup;
 	}
 
-	WaitEventWait(request->WaitEvent);
+	osd_WaitEventWait(request->WaitEvent);
 
 	/* Copy the response back */
 	queryComplete = &request->ResponseMessage.Message.QueryComplete;
@@ -711,7 +711,7 @@ RndisFilterSetPacketFilter(
 		goto Cleanup;
 	}
 
-	ret = WaitEventWaitEx(request->WaitEvent, 2000/*2sec*/);
+	ret = osd_WaitEventWaitEx(request->WaitEvent, 2000/*2sec*/);
 	if (!ret)
 	{
 		ret = -1;
@@ -822,7 +822,7 @@ RndisFilterInitDevice(
 		goto Cleanup;
 	}
 
-	WaitEventWait(request->WaitEvent);
+	osd_WaitEventWait(request->WaitEvent);
 
 	initComplete = &request->ResponseMessage.Message.InitializeComplete;
 	status = initComplete->Status;
--- a/drivers/staging/hv/StorVsc.c
+++ b/drivers/staging/hv/StorVsc.c
@@ -378,7 +378,7 @@ static int StorVscChannelInit(struct hv_
 	/* Now, initiate the vsc/vsp initialization protocol on the open channel */
 
 	memset(request, sizeof(STORVSC_REQUEST_EXTENSION), 0);
-	request->WaitEvent = WaitEventCreate();
+	request->WaitEvent = osd_WaitEventCreate();
 
 	vstorPacket->Operation = VStorOperationBeginInitialization;
 	vstorPacket->Flags = REQUEST_COMPLETION_FLAG;
@@ -401,7 +401,7 @@ static int StorVscChannelInit(struct hv_
 		goto Cleanup;
 	}
 
-	WaitEventWait(request->WaitEvent);
+	osd_WaitEventWait(request->WaitEvent);
 
 	if (vstorPacket->Operation != VStorOperationCompleteIo || vstorPacket->Status != 0)
 	{
@@ -431,7 +431,7 @@ static int StorVscChannelInit(struct hv_
 		goto Cleanup;
 	}
 
-	WaitEventWait(request->WaitEvent);
+	osd_WaitEventWait(request->WaitEvent);
 
 	/* TODO: Check returned version */
 	if (vstorPacket->Operation != VStorOperationCompleteIo || vstorPacket->Status != 0)
@@ -461,7 +461,7 @@ static int StorVscChannelInit(struct hv_
 		goto Cleanup;
 	}
 
-	WaitEventWait(request->WaitEvent);
+	osd_WaitEventWait(request->WaitEvent);
 
 	/* TODO: Check returned version */
 	if (vstorPacket->Operation != VStorOperationCompleteIo || vstorPacket->Status != 0)
@@ -495,7 +495,7 @@ static int StorVscChannelInit(struct hv_
 		goto Cleanup;
 	}
 
-	WaitEventWait(request->WaitEvent);
+	osd_WaitEventWait(request->WaitEvent);
 
 	if (vstorPacket->Operation != VStorOperationCompleteIo || vstorPacket->Status != 0)
 	{
@@ -649,7 +649,7 @@ StorVscOnHostReset(
 	request = &storDevice->ResetRequest;
 	vstorPacket = &request->VStorPacket;
 
-	request->WaitEvent = WaitEventCreate();
+	request->WaitEvent = osd_WaitEventCreate();
 
     vstorPacket->Operation = VStorOperationResetBus;
     vstorPacket->Flags = REQUEST_COMPLETION_FLAG;
@@ -668,7 +668,7 @@ StorVscOnHostReset(
 	}
 
 	/* FIXME: Add a timeout */
-	WaitEventWait(request->WaitEvent);
+	osd_WaitEventWait(request->WaitEvent);
 
 	kfree(request->WaitEvent);
 	DPRINT_INFO(STORVSC, "host adapter reset completed");
@@ -959,7 +959,7 @@ StorVscOnChannelCallback(
 
 				memcpy(&request->VStorPacket, packet, sizeof(VSTOR_PACKET));
 
-				WaitEventSet(request->WaitEvent);
+				osd_WaitEventSet(request->WaitEvent);
 			}
 			else
 			{
