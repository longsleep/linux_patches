From hartleys@visionengravers.com  Fri Feb 26 17:04:05 2010
From: H Hartley Sweeten <hartleys@visionengravers.com>
Date: Fri, 26 Feb 2010 17:58:07 -0700
Subject: staging: dt3155: revert u_long to u64 usage
Cc: greg@kroah.com, ss@aao.gov.au
Message-ID: <201002261758.07585.hartleys@visionengravers.com>
Content-Disposition: inline


Commit 9c1390a923ddb6fba1cf9d7440743369140c6d8a replaced
all u_int's with u32 and u_long's with u64. Unfortunately, a u_long
is still only 32-bits so they should have been replaced with u32 also.

This can be verified by the register definitions in dt3155_io.h.  It
specifically states that the memory mapped registers are 32-bit.

Fix this by changing all the u64 to u32.

Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
Cc: Greg Kroah-Hartman <greg@kroah.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/dt3155/allocator.c  |    2 
 drivers/staging/dt3155/allocator.h  |    2 
 drivers/staging/dt3155/dt3155.h     |   24 ++--
 drivers/staging/dt3155/dt3155_drv.c |   28 ++---
 drivers/staging/dt3155/dt3155_io.c  |   16 +--
 drivers/staging/dt3155/dt3155_io.h  |  174 ++++++++++++++++++------------------
 drivers/staging/dt3155/dt3155_isr.c |   54 +++++------
 drivers/staging/dt3155/dt3155_isr.h |    2 
 8 files changed, 151 insertions(+), 151 deletions(-)

--- a/drivers/staging/dt3155/allocator.c
+++ b/drivers/staging/dt3155/allocator.c
@@ -195,7 +195,7 @@ int allocator_free_dma(unsigned long add
  * On cleanup everything is released. If the list is not empty, that a
  * problem of our clients
  */
-int allocator_init(u64 *allocator_max)
+int allocator_init(u32 *allocator_max)
 {
 	/* check how much free memory is there */
 	void *remapped;
--- a/drivers/staging/dt3155/allocator.h
+++ b/drivers/staging/dt3155/allocator.h
@@ -24,5 +24,5 @@
 
 void allocator_free_dma(unsigned long address);
 unsigned long allocator_allocate_dma(unsigned long kilobytes, int priority);
-int allocator_init(u64 *);
+int allocator_init(u32 *);
 void allocator_cleanup(void);
--- a/drivers/staging/dt3155/dt3155.h
+++ b/drivers/staging/dt3155/dt3155.h
@@ -79,8 +79,8 @@ struct dt3155_config_s {
 
 /* hold data for each frame */
 typedef struct {
-	u64 addr;		/* address of the buffer with the frame */
-	u64 tag;		/* unique number for the frame */
+	u32 addr;		/* address of the buffer with the frame */
+	u32 tag;		/* unique number for the frame */
 	struct timeval time;	/* time that capture took place */
 } frame_info_t;
 
@@ -101,14 +101,14 @@ struct dt3155_fbuffer_s {
 	int locked_buf;			/* Buffers used by user */
 
 	int ready_que[BOARD_MAX_BUFFS];
-	u64 ready_head;	/* The most recent buffer located here */
-	u64 ready_len;	/* The number of ready buffers */
+	u32 ready_head;	/* The most recent buffer located here */
+	u32 ready_len;	/* The number of ready buffers */
 
 	int even_happened;
 	int even_stopped;
 
 	int stop_acquire;	/* Flag to stop interrupts */
-	u64 frame_count;	/* Counter for frames acquired by this card */
+	u32 frame_count;	/* Counter for frames acquired by this card */
 };
 
 
@@ -122,13 +122,13 @@ struct dt3155_fbuffer_s {
 /* There is one status structure for each card. */
 typedef struct dt3155_status_s {
 	int fixed_mode;		/* if 1, we are in fixed frame mode */
-	u64 reg_addr;	/* Register address for a single card */
-	u64 mem_addr;	/* Buffer start addr for this card */
-	u64 mem_size;	/* This is the amount of mem available  */
+	u32 reg_addr;	/* Register address for a single card */
+	u32 mem_addr;	/* Buffer start addr for this card */
+	u32 mem_size;	/* This is the amount of mem available  */
 	u32 irq;		/* this card's irq */
 	struct dt3155_config_s config;		/* configuration struct */
 	struct dt3155_fbuffer_s fbuffer;	/* frame buffer state struct */
-	u64 state;		/* this card's state */
+	u32 state;		/* this card's state */
 	u32 device_installed;	/* Flag if installed. 1=installed */
 } dt3155_status_t;
 
@@ -161,9 +161,9 @@ extern struct dt3155_status_s dt3155_sta
 
 /* User code will probably want to declare one of these for each card */
 typedef struct dt3155_read_s {
-	u64 offset;
-	u64 frame_seq;
-	u64 state;
+	u32 offset;
+	u32 frame_seq;
+	u32 state;
 
 	frame_info_t frame_info;
 } dt3155_read_t;
--- a/drivers/staging/dt3155/dt3155_drv.c
+++ b/drivers/staging/dt3155/dt3155_drv.c
@@ -137,7 +137,7 @@ u32  dt3155_dev_open[ MAXBOARDS ] = {0
 };
 
 u32  ndevices = 0;
-u64 unique_tag = 0;;
+u32 unique_tag = 0;;
 
 
 /*
@@ -180,7 +180,7 @@ static inline void dt3155_isr( int irq,
   int    minor = -1;
   int    index;
   unsigned long flags;
-  u64 buffer_addr;
+  u32 buffer_addr;
 
   /* find out who issued the interrupt */
   for ( index = 0; index < ndevices; index++ ) {
@@ -249,7 +249,7 @@ static inline void dt3155_isr( int irq,
 	{
 	  /* GCS (Aug 2, 2002) -- In field mode, dma the odd field
 	     into the lower half of the buffer */
-	  const u64 stride =  dt3155_status[ minor ].config.cols;
+	  const u32 stride =  dt3155_status[ minor ].config.cols;
 	  buffer_addr = dt3155_fbuffer[ minor ]->
 	    frame_info[ dt3155_fbuffer[ minor ]->active_buf ].addr
 	    + (DT3155_MAX_ROWS / 2) * stride;
@@ -312,7 +312,7 @@ static inline void dt3155_isr( int irq,
 	      dt3155_fbuffer[ minor ]->even_stopped = 0;
 
 	      printk(KERN_DEBUG "dt3155:  state is now %x\n",
-		     (u32)dt3155_status[minor].state);
+		     dt3155_status[minor].state);
 	    }
 	  else
 	    {
@@ -428,7 +428,7 @@ static inline void dt3155_isr( int irq,
  *****************************************************/
 static void dt3155_init_isr(int minor)
 {
-  const u64 stride =  dt3155_status[ minor ].config.cols;
+  const u32 stride =  dt3155_status[ minor ].config.cols;
 
   switch (dt3155_status[ minor ].state & DT3155_STATE_MODE)
     {
@@ -706,7 +706,7 @@ static int dt3155_open( struct inode* in
 
   if (dt3155_status[ minor ].state != DT3155_STATE_IDLE) {
     printk ("DT3155:  Not in idle state (state = %x)\n",
-	    (u32)dt3155_status[ minor ].state);
+	    dt3155_status[ minor ].state);
     return -EBUSY;
   }
 
@@ -762,7 +762,7 @@ static ssize_t dt3155_read(struct file *
 {
   /* which device are we reading from? */
   int		minor = MINOR(filep->f_dentry->d_inode->i_rdev);
-  u64		offset;
+  u32		offset;
   int		frame_index;
   frame_info_t	*frame_info_p;
 
@@ -820,11 +820,11 @@ static ssize_t dt3155_read(struct file *
   offset = frame_info_p->addr - dt3155_status[minor].mem_addr;
 
   put_user(offset, (unsigned int *) buf);
-  buf += sizeof(u64);
+  buf += sizeof(u32);
   put_user( dt3155_status[minor].fbuffer.frame_count, (unsigned int *) buf);
-  buf += sizeof(u64);
+  buf += sizeof(u32);
   put_user(dt3155_status[minor].state, (unsigned int *) buf);
-  buf += sizeof(u64);
+  buf += sizeof(u32);
   if (copy_to_user(buf, frame_info_p, sizeof(frame_info_t)))
       return -EFAULT;
 
@@ -931,7 +931,7 @@ static int find_PCI (void)
       dt3155_status[ pci_index-1 ].device_installed = 1;
       printk("DT3155: Installing device %d w/irq %d and address %p\n",
 	     pci_index,
-	     (u32)dt3155_status[pci_index-1].irq,
+	     dt3155_status[pci_index-1].irq,
 	     dt3155_lbase[pci_index-1]);
 
     }
@@ -944,7 +944,7 @@ err:
   return DT_3155_FAILURE;
 }
 
-u64 allocatorAddr = 0;
+u32 allocatorAddr = 0;
 
 /*****************************************************
  * init_module()
@@ -1024,9 +1024,9 @@ int init_module(void)
 	     dt3155_status[ index ].config.rows);
       printk("DT3155: m_addr = 0x%x; m_size = %ld; "
 	     "state = %d; device_installed = %d\n",
-	     (u32)dt3155_status[ index ].mem_addr,
+	     dt3155_status[ index ].mem_addr,
 	     (long int)dt3155_status[ index ].mem_size,
-	     (u32)dt3155_status[ index ].state,
+	     dt3155_status[ index ].state,
 	     dt3155_status[ index ].device_installed);
     }
 
--- a/drivers/staging/dt3155/dt3155_io.c
+++ b/drivers/staging/dt3155/dt3155_io.c
@@ -27,12 +27,12 @@
 
 
 /****** local copies of board's 32 bit registers ******/
-u64 even_dma_start_r;	/*  bit 0 should always be 0 */
-u64 odd_dma_start_r;	/*               .. */
-u64 even_dma_stride_r;	/*  bits 0&1 should always be 0 */
-u64 odd_dma_stride_r;	/*               .. */
-u64 even_pixel_fmt_r;
-u64 odd_pixel_fmt_r;
+u32 even_dma_start_r;	/*  bit 0 should always be 0 */
+u32 odd_dma_start_r;	/*               .. */
+u32 even_dma_stride_r;	/*  bits 0&1 should always be 0 */
+u32 odd_dma_stride_r;	/*               .. */
+u32 even_pixel_fmt_r;
+u32 odd_pixel_fmt_r;
 
 FIFO_TRIGGER_R		fifo_trigger_r;
 XFER_MODE_R		xfer_mode_r;
@@ -40,8 +40,8 @@ CSR1_R			csr1_r;
 RETRY_WAIT_CNT_R	retry_wait_cnt_r;
 INT_CSR_R		int_csr_r;
 
-u64 even_fld_mask_r;
-u64 odd_fld_mask_r;
+u32 even_fld_mask_r;
+u32 odd_fld_mask_r;
 
 MASK_LENGTH_R		mask_length_r;
 FIFO_FLAG_CNT_R		fifo_flag_cnt_r;
--- a/drivers/staging/dt3155/dt3155_io.h
+++ b/drivers/staging/dt3155/dt3155_io.h
@@ -36,8 +36,8 @@ MA 02111-1307 USA
 
 /* macros to access registers */
 
-#define WriteMReg(Address, Data)	(*((u64 *)(Address)) = Data)
-#define ReadMReg(Address, Data)		(Data = *((u64 *)(Address)))
+#define WriteMReg(Address, Data)	(*((u32 *)(Address)) = Data)
+#define ReadMReg(Address, Data)		(Data = *((u32 *)(Address)))
 
 /***************** 32 bit register globals  **************/
 
@@ -71,114 +71,114 @@ MA 02111-1307 USA
 /******** Assignments and Typedefs for 32 bit Memory Mapped Registers ********/
 
 typedef union fifo_trigger_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 PACKED:6;
-		u64       :9;
-		u64 PLANER:7;
-		u64       :9;
+		u32 PACKED:6;
+		u32       :9;
+		u32 PLANER:7;
+		u32       :9;
 	} fld;
 } FIFO_TRIGGER_R;
 
 typedef union xfer_mode_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64             :2;
-		u64 FIELD_TOGGLE:1;
-		u64             :5;
-		u64             :2;
-		u64             :22;
+		u32             :2;
+		u32 FIELD_TOGGLE:1;
+		u32             :5;
+		u32             :2;
+		u32             :22;
 	} fld;
 } XFER_MODE_R;
 
 typedef union csr1_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 CAP_CONT_EVE:1;
-		u64 CAP_CONT_ODD:1;
-		u64 CAP_SNGL_EVE:1;
-		u64 CAP_SNGL_ODD:1;
-		u64 FLD_DN_EVE  :1;
-		u64 FLD_DN_ODD  :1;
-		u64 SRST        :1;
-		u64 FIFO_EN     :1;
-		u64 FLD_CRPT_EVE:1;
-		u64 FLD_CRPT_ODD:1;
-		u64 ADDR_ERR_EVE:1;
-		u64 ADDR_ERR_ODD:1;
-		u64 CRPT_DIS    :1;
-		u64 RANGE_EN    :1;
-		u64             :16;
+		u32 CAP_CONT_EVE:1;
+		u32 CAP_CONT_ODD:1;
+		u32 CAP_SNGL_EVE:1;
+		u32 CAP_SNGL_ODD:1;
+		u32 FLD_DN_EVE  :1;
+		u32 FLD_DN_ODD  :1;
+		u32 SRST        :1;
+		u32 FIFO_EN     :1;
+		u32 FLD_CRPT_EVE:1;
+		u32 FLD_CRPT_ODD:1;
+		u32 ADDR_ERR_EVE:1;
+		u32 ADDR_ERR_ODD:1;
+		u32 CRPT_DIS    :1;
+		u32 RANGE_EN    :1;
+		u32             :16;
 	} fld;
 } CSR1_R;
 
 typedef union retry_wait_cnt_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 RTRY_WAIT_CNT:8;
-		u64              :24;
+		u32 RTRY_WAIT_CNT:8;
+		u32              :24;
 	} fld;
 } RETRY_WAIT_CNT_R;
 
 typedef union int_csr_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 FLD_END_EVE   :1;
-		u64 FLD_END_ODD   :1;
-		u64 FLD_START     :1;
-		u64               :5;
-		u64 FLD_END_EVE_EN:1;
-		u64 FLD_END_ODD_EN:1;
-		u64 FLD_START_EN  :1;
-		u64               :21;
+		u32 FLD_END_EVE   :1;
+		u32 FLD_END_ODD   :1;
+		u32 FLD_START     :1;
+		u32               :5;
+		u32 FLD_END_EVE_EN:1;
+		u32 FLD_END_ODD_EN:1;
+		u32 FLD_START_EN  :1;
+		u32               :21;
 	} fld;
 } INT_CSR_R;
 
 typedef union mask_length_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 MASK_LEN_EVE:5;
-		u64             :11;
-		u64 MASK_LEN_ODD:5;
-		u64             :11;
+		u32 MASK_LEN_EVE:5;
+		u32             :11;
+		u32 MASK_LEN_ODD:5;
+		u32             :11;
 	} fld;
 } MASK_LENGTH_R;
 
 typedef union fifo_flag_cnt_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 AF_COUNT:7;
-		u64         :9;
-		u64 AE_COUNT:7;
-		u64         :9;
+		u32 AF_COUNT:7;
+		u32         :9;
+		u32 AE_COUNT:7;
+		u32         :9;
 	} fld;
 } FIFO_FLAG_CNT_R;
 
 typedef union iic_clk_dur {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 PHASE_1:8;
-		u64 PHASE_2:8;
-		u64 PHASE_3:8;
-		u64 PHASE_4:8;
+		u32 PHASE_1:8;
+		u32 PHASE_2:8;
+		u32 PHASE_3:8;
+		u32 PHASE_4:8;
 	} fld;
 } IIC_CLK_DUR_R;
 
 typedef union iic_csr1_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 AUTO_EN     :1;
-		u64 BYPASS      :1;
-		u64 SDA_OUT     :1;
-		u64 SCL_OUT     :1;
-		u64             :4;
-		u64 AUTO_ABORT  :1;
-		u64 DIRECT_ABORT:1;
-		u64 SDA_IN      :1;
-		u64 SCL_IN      :1;
-		u64             :4;
-		u64 AUTO_ADDR   :8;
-		u64 RD_DATA     :8;
+		u32 AUTO_EN     :1;
+		u32 BYPASS      :1;
+		u32 SDA_OUT     :1;
+		u32 SCL_OUT     :1;
+		u32             :4;
+		u32 AUTO_ABORT  :1;
+		u32 DIRECT_ABORT:1;
+		u32 SDA_IN      :1;
+		u32 SCL_IN      :1;
+		u32             :4;
+		u32 AUTO_ADDR   :8;
+		u32 RD_DATA     :8;
 	} fld;
 } IIC_CSR1_R;
 
@@ -186,14 +186,14 @@ typedef union iic_csr1_tag {
  * iic_csr2_tag
  */
 typedef union iic_csr2_tag {
-	u64   reg;
+	u32   reg;
 	struct {
-		u64 DIR_WR_DATA :8;
-		u64 DIR_SUB_ADDR:8;
-		u64 DIR_RD      :1;
-		u64 DIR_ADDR    :7;
-		u64 NEW_CYCLE   :1;
-		u64             :7;
+		u32 DIR_WR_DATA :8;
+		u32 DIR_SUB_ADDR:8;
+		u32 DIR_RD      :1;
+		u32 DIR_ADDR    :7;
+		u32 NEW_CYCLE   :1;
+		u32             :7;
 	} fld;
 }  IIC_CSR2_R;
 
@@ -203,10 +203,10 @@ typedef union iic_csr2_tag {
  * dma_upper_lmt_tag
  */
 typedef union dma_upper_lmt_tag   {
-	u64 reg;
+	u32 reg;
 	struct {
-		u64 DMA_UPPER_LMT_VAL:24;
-		u64                  :8;
+		u32 DMA_UPPER_LMT_VAL:24;
+		u32                  :8;
 	} fld;
 } DMA_UPPER_LMT_R;
 
@@ -214,12 +214,12 @@ typedef union dma_upper_lmt_tag   {
 /*
  * Global declarations of local copies of boards' 32 bit registers
  */
-extern u64 even_dma_start_r;		/*  bit 0 should always be 0 */
-extern u64 odd_dma_start_r;		/*               ..          */
-extern u64 even_dma_stride_r;	/*  bits 0&1 should always be 0 */
-extern u64 odd_dma_stride_r;		/*               ..             */
-extern u64 even_pixel_fmt_r;
-extern u64 odd_pixel_fmt_r;
+extern u32 even_dma_start_r;		/*  bit 0 should always be 0 */
+extern u32 odd_dma_start_r;		/*               ..          */
+extern u32 even_dma_stride_r;	/*  bits 0&1 should always be 0 */
+extern u32 odd_dma_stride_r;		/*               ..             */
+extern u32 even_pixel_fmt_r;
+extern u32 odd_pixel_fmt_r;
 
 extern FIFO_TRIGGER_R		fifo_trigger_r;
 extern XFER_MODE_R		xfer_mode_r;
@@ -227,8 +227,8 @@ extern CSR1_R			csr1_r;
 extern RETRY_WAIT_CNT_R		retry_wait_cnt_r;
 extern INT_CSR_R		int_csr_r;
 
-extern u64 even_fld_mask_r;
-extern u64 odd_fld_mask_r;
+extern u32 even_fld_mask_r;
+extern u32 odd_fld_mask_r;
 
 extern MASK_LENGTH_R		mask_length_r;
 extern FIFO_FLAG_CNT_R		fifo_flag_cnt_r;
--- a/drivers/staging/dt3155/dt3155_isr.c
+++ b/drivers/staging/dt3155/dt3155_isr.c
@@ -220,7 +220,7 @@ inline void printques( int m )
  *  the start address up to the beginning of the
  *  next 4MB chunk (assuming bufsize < 4MB).
  *****************************************************/
-u64 adjust_4MB (u64 buf_addr, u64 bufsize) {
+u32 adjust_4MB (u32 buf_addr, u32 bufsize) {
   if (((buf_addr+bufsize) & UPPER_10_BITS) != (buf_addr & UPPER_10_BITS))
     return (buf_addr+bufsize) & UPPER_10_BITS;
   else
@@ -235,26 +235,26 @@ u64 adjust_4MB (u64 buf_addr, u64 bufsiz
  *  buffers.  If there is not enough free space
  *  try for less memory.
  *****************************************************/
-void allocate_buffers (u64 *buf_addr, u64* total_size_kbs,
-		       u64 bufsize)
+void allocate_buffers (u32 *buf_addr, u32* total_size_kbs,
+		       u32 bufsize)
 {
   /* Compute the minimum amount of memory guaranteed to hold all
      MAXBUFFERS such that no buffer crosses the 4MB boundary.
      Store this value in the variable "full_size" */
 
-  u64 allocator_max;
-  u64 bufs_per_chunk = (FOUR_MB / bufsize);
-  u64 filled_chunks = (MAXBUFFERS-1) / bufs_per_chunk;
-  u64 leftover_bufs = MAXBUFFERS - filled_chunks * bufs_per_chunk;
+  u32 allocator_max;
+  u32 bufs_per_chunk = (FOUR_MB / bufsize);
+  u32 filled_chunks = (MAXBUFFERS-1) / bufs_per_chunk;
+  u32 leftover_bufs = MAXBUFFERS - filled_chunks * bufs_per_chunk;
 
-  u64 full_size = bufsize      /* possibly unusable part of 1st chunk */
+  u32 full_size = bufsize      /* possibly unusable part of 1st chunk */
     + filled_chunks * FOUR_MB   /* max # of completely filled 4mb chunks */
     + leftover_bufs * bufsize;  /* these buffs will be in a partly filled
 				   chunk at beginning or end */
 
-  u64 full_size_kbs = 1 + (full_size-1) / 1024;
-  u64 min_size_kbs = 2*ndevices*bufsize / 1024;
-  u64 size_kbs;
+  u32 full_size_kbs = 1 + (full_size-1) / 1024;
+  u32 min_size_kbs = 2*ndevices*bufsize / 1024;
+  u32 size_kbs;
 
   /* Now, try to allocate full_size.  If this fails, keep trying for
      less & less memory until it succeeds. */
@@ -264,13 +264,13 @@ void allocate_buffers (u64 *buf_addr, u6
 #endif
   size_kbs = full_size_kbs;
   *buf_addr = 0;
-  printk ("DT3155: We would like to get: %d KB\n", (u32)(full_size_kbs));
-  printk ("DT3155: ...but need at least: %d KB\n", (u32)(min_size_kbs));
-  printk ("DT3155: ...the allocator has: %d KB\n", (u32)(allocator_max));
+  printk("DT3155: We would like to get: %d KB\n", full_size_kbs);
+  printk("DT3155: ...but need at least: %d KB\n", min_size_kbs);
+  printk("DT3155: ...the allocator has: %d KB\n", allocator_max);
   size_kbs = (full_size_kbs <= allocator_max ? full_size_kbs : allocator_max);
   if (size_kbs > min_size_kbs) {
     if ((*buf_addr = allocator_allocate_dma (size_kbs, GFP_KERNEL)) != 0) {
-      printk ("DT3155:  Managed to allocate: %d KB\n", (u32)size_kbs);
+      printk("DT3155:  Managed to allocate: %d KB\n", size_kbs);
       *total_size_kbs = size_kbs;
       return;
     }
@@ -298,17 +298,17 @@ void allocate_buffers (u64 *buf_addr, u6
  * 4MB boundary.  Also, add error checking.  This
  * function will return -ENOMEM when not enough memory.
  *****************************************************/
-u64 dt3155_setup_buffers(u64 *allocatorAddr)
+u32 dt3155_setup_buffers(u32 *allocatorAddr)
 
 {
-  u64 index;
-  u64 rambuff_addr; /* start of allocation */
-  u64 rambuff_size; /* total size allocated to driver */
-  u64 rambuff_acm;  /* accumlator, keep track of how much
+  u32 index;
+  u32 rambuff_addr; /* start of allocation */
+  u32 rambuff_size; /* total size allocated to driver */
+  u32 rambuff_acm;  /* accumlator, keep track of how much
 			  is left after being split up*/
-  u64 rambuff_end;  /* end of rambuff */
-  u64 numbufs;      /* number of useful buffers allocated (per device) */
-  u64 bufsize      = DT3155_MAX_ROWS * DT3155_MAX_COLS;
+  u32 rambuff_end;  /* end of rambuff */
+  u32 numbufs;      /* number of useful buffers allocated (per device) */
+  u32 bufsize      = DT3155_MAX_ROWS * DT3155_MAX_COLS;
   int m;               /* minor # of device, looped for all devs */
 
   /* zero the fbuffer status and address structure */
@@ -326,9 +326,9 @@ u64 dt3155_setup_buffers(u64 *allocatorA
 
   /* allocate a large contiguous chunk of RAM */
   allocate_buffers (&rambuff_addr, &rambuff_size, bufsize);
-  printk( "DT3155: mem info\n" );
-  printk( "  - rambuf_addr = 0x%x \n", (u32)rambuff_addr );
-  printk( "  - length (kb) = %u \n",  (u32)rambuff_size );
+  printk("DT3155: mem info\n");
+  printk("  - rambuf_addr = 0x%x \n", rambuff_addr);
+  printk("  - length (kb) = %u \n", rambuff_size);
   if( rambuff_addr == 0 )
     {
       printk( KERN_INFO
@@ -350,7 +350,7 @@ u64 dt3155_setup_buffers(u64 *allocatorA
   /* Following line is OK, will waste buffers if index
    * not evenly divisible by ndevices -NJC*/
   numbufs = index / ndevices;
-  printk ("  - numbufs = %u\n", (u32) numbufs);
+  printk("  - numbufs = %u\n", numbufs);
   if (numbufs < 2) {
     printk( KERN_INFO
 	    "DT3155: Error setup_buffers() couldn't allocate 2 bufs/board\n" );
--- a/drivers/staging/dt3155/dt3155_isr.h
+++ b/drivers/staging/dt3155/dt3155_isr.h
@@ -42,7 +42,7 @@ extern struct dt3155_fbuffer_s *dt3155_f
 /* Initialize the buffering system.  This should */
 /* be called prior to enabling interrupts */
 
-u64 dt3155_setup_buffers(u64 *allocatorAddr);
+u32 dt3155_setup_buffers(u32 *allocatorAddr);
 
 /* Get the next frame of data if it is ready.  Returns */
 /* zero if no data is ready.  If there is data but */
