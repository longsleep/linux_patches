From alan@linux.intel.com  Thu Aug 27 14:27:32 2009
From: Alan Cox <alan@linux.intel.com>
Date: Thu, 27 Aug 2009 11:01:49 +0100
Subject: Staging: et131x: clean up PM_CSR_t
To: greg@kroah.com
Message-ID: <20090827100147.23892.37494.stgit@localhost.localdomain>


Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_address_map.h |   45 ++++++++--------------------
 drivers/staging/et131x/et1310_mac.c         |   12 +++----
 drivers/staging/et131x/et1310_pm.c          |   27 ++++++----------
 drivers/staging/et131x/et131x_initpci.c     |   20 +++---------
 drivers/staging/et131x/et131x_isr.c         |   13 +++-----
 5 files changed, 43 insertions(+), 74 deletions(-)


--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -73,37 +73,20 @@
 /*
  * structure for power management control status reg in global address map
  * located at address 0x0010
+ *	jagcore_rx_rdy	bit 9
+ *	jagcore_tx_rdy	bit 8
+ *	phy_lped_en	bit 7
+ *	phy_sw_coma	bit 6
+ *	rxclk_gate	bit 5
+ *	txclk_gate	bit 4
+ *	sysclk_gate	bit 3
+ *	jagcore_rx_en	bit 2
+ *	jagcore_tx_en	bit 1
+ *	gigephy_en	bit 0
  */
-typedef union _PM_CSR_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 unused:22;		/* bits 10-31 */
-		u32 pm_jagcore_rx_rdy:1;	/* bit 9 */
-		u32 pm_jagcore_tx_rdy:1;	/* bit 8 */
-		u32 pm_phy_lped_en:1;	/* bit 7 */
-		u32 pm_phy_sw_coma:1;	/* bit 6 */
-		u32 pm_rxclk_gate:1;	/* bit 5 */
-		u32 pm_txclk_gate:1;	/* bit 4 */
-		u32 pm_sysclk_gate:1;	/* bit 3 */
-		u32 pm_jagcore_rx_en:1;	/* bit 2 */
-		u32 pm_jagcore_tx_en:1;	/* bit 1 */
-		u32 pm_gigephy_en:1;	/* bit 0 */
-#else
-		u32 pm_gigephy_en:1;	/* bit 0 */
-		u32 pm_jagcore_tx_en:1;	/* bit 1 */
-		u32 pm_jagcore_rx_en:1;	/* bit 2 */
-		u32 pm_sysclk_gate:1;	/* bit 3 */
-		u32 pm_txclk_gate:1;	/* bit 4 */
-		u32 pm_rxclk_gate:1;	/* bit 5 */
-		u32 pm_phy_sw_coma:1;	/* bit 6 */
-		u32 pm_phy_lped_en:1;	/* bit 7 */
-		u32 pm_jagcore_tx_rdy:1;	/* bit 8 */
-		u32 pm_jagcore_rx_rdy:1;	/* bit 9 */
-		u32 unused:22;		/* bits 10-31 */
-#endif
-	} bits;
-} PM_CSR_t, *PPM_CSR_t;
+
+#define ET_PM_PHY_SW_COMA		0x40
+#define ET_PMCSR_INIT			0x38
 
 /*
  * structure for interrupt status reg in global address map
@@ -271,7 +254,7 @@ typedef struct _GLOBAL_t {			/* Location
 	u32 txq_end_addr;			/*  0x0004 */
 	u32 rxq_start_addr;			/*  0x0008 */
 	u32 rxq_end_addr;			/*  0x000C */
-	PM_CSR_t pm_csr;			/*  0x0010 */
+	u32 pm_csr;				/*  0x0010 */
 	u32 unused;				/*  0x0014 */
 	INTERRUPT_t int_status;			/*  0x0018 */
 	INTERRUPT_t int_mask;			/*  0x001C */
--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -672,7 +672,7 @@ void SetupDeviceForMulticast(struct et13
 	uint32_t hash2 = 0;
 	uint32_t hash3 = 0;
 	uint32_t hash4 = 0;
-	PM_CSR_t pm_csr;
+	u32 pm_csr;
 
 	DBG_ENTER(et131x_dbginfo);
 
@@ -718,8 +718,8 @@ void SetupDeviceForMulticast(struct et13
 	}
 
 	/* Write out the new hash to the device */
-	pm_csr.value = readl(&etdev->regs->global.pm_csr.value);
-	if (pm_csr.bits.pm_phy_sw_coma == 0) {
+	pm_csr = readl(&etdev->regs->global.pm_csr);
+	if ((pm_csr & ET_PM_PHY_SW_COMA) == 0) {
 		writel(hash1, &rxmac->multi_hash1);
 		writel(hash2, &rxmac->multi_hash2);
 		writel(hash3, &rxmac->multi_hash3);
@@ -735,7 +735,7 @@ void SetupDeviceForUnicast(struct et131x
 	RXMAC_UNI_PF_ADDR1_t uni_pf1;
 	RXMAC_UNI_PF_ADDR2_t uni_pf2;
 	RXMAC_UNI_PF_ADDR3_t uni_pf3;
-	PM_CSR_t pm_csr;
+	u32 pm_csr;
 
 	DBG_ENTER(et131x_dbginfo);
 
@@ -763,8 +763,8 @@ void SetupDeviceForUnicast(struct et131x
 	uni_pf1.bits.addr1_5 = etdev->CurrentAddress[4];
 	uni_pf1.bits.addr1_6 = etdev->CurrentAddress[5];
 
-	pm_csr.value = readl(&etdev->regs->global.pm_csr.value);
-	if (pm_csr.bits.pm_phy_sw_coma == 0) {
+	pm_csr = readl(&etdev->regs->global.pm_csr);
+	if ((pm_csr & ET_PM_PHY_SW_COMA) == 0) {
 		writel(uni_pf1.value, &rxmac->uni_pf_addr1.value);
 		writel(uni_pf2.value, &rxmac->uni_pf_addr2.value);
 		writel(uni_pf3.value, &rxmac->uni_pf_addr3.value);
--- a/drivers/staging/et131x/et1310_pm.c
+++ b/drivers/staging/et131x/et1310_pm.c
@@ -120,12 +120,11 @@ extern dbg_info_t *et131x_dbginfo;
 void EnablePhyComa(struct et131x_adapter *etdev)
 {
 	unsigned long flags;
-	PM_CSR_t GlobalPmCSR;
-	int32_t LoopCounter = 10;
+	u32 GlobalPmCSR;
 
 	DBG_ENTER(et131x_dbginfo);
 
-	GlobalPmCSR.value = readl(&etdev->regs->global.pm_csr.value);
+	GlobalPmCSR = readl(&etdev->regs->global.pm_csr);
 
 	/* Save the GbE PHY speed and duplex modes. Need to restore this
 	 * when cable is plugged back in
@@ -141,14 +140,12 @@ void EnablePhyComa(struct et131x_adapter
 	/* Wait for outstanding Receive packets */
 
 	/* Gate off JAGCore 3 clock domains */
-	GlobalPmCSR.bits.pm_sysclk_gate = 0;
-	GlobalPmCSR.bits.pm_txclk_gate = 0;
-	GlobalPmCSR.bits.pm_rxclk_gate = 0;
-	writel(GlobalPmCSR.value, &etdev->regs->global.pm_csr.value);
+	GlobalPmCSR &= ~ET_PMCSR_INIT;
+	writel(GlobalPmCSR, &etdev->regs->global.pm_csr);
 
 	/* Program gigE PHY in to Coma mode */
-	GlobalPmCSR.bits.pm_phy_sw_coma = 1;
-	writel(GlobalPmCSR.value, &etdev->regs->global.pm_csr.value);
+	GlobalPmCSR |= ET_PM_PHY_SW_COMA;
+	writel(GlobalPmCSR, &etdev->regs->global.pm_csr);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
@@ -159,18 +156,16 @@ void EnablePhyComa(struct et131x_adapter
  */
 void DisablePhyComa(struct et131x_adapter *etdev)
 {
-	PM_CSR_t GlobalPmCSR;
+	u32 GlobalPmCSR;
 
 	DBG_ENTER(et131x_dbginfo);
 
-	GlobalPmCSR.value = readl(&etdev->regs->global.pm_csr.value);
+	GlobalPmCSR = readl(&etdev->regs->global.pm_csr);
 
 	/* Disable phy_sw_coma register and re-enable JAGCore clocks */
-	GlobalPmCSR.bits.pm_sysclk_gate = 1;
-	GlobalPmCSR.bits.pm_txclk_gate = 1;
-	GlobalPmCSR.bits.pm_rxclk_gate = 1;
-	GlobalPmCSR.bits.pm_phy_sw_coma = 0;
-	writel(GlobalPmCSR.value, &etdev->regs->global.pm_csr.value);
+	GlobalPmCSR |= ET_PMCSR_INIT;
+	GlobalPmCSR &= ~ET_PM_PHY_SW_COMA;
+	writel(GlobalPmCSR, &etdev->regs->global.pm_csr);
 
 	/* Restore the GbE PHY speed and duplex modes;
 	 * Reset JAGCore; re-configure and initialize JAGCore and gigE PHY
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -474,16 +474,16 @@ int et131x_find_adapter(struct et131x_ad
 void et131x_error_timer_handler(unsigned long data)
 {
 	struct et131x_adapter *etdev = (struct et131x_adapter *) data;
-	PM_CSR_t pm_csr;
+	u32 pm_csr;
 
-	pm_csr.value = readl(&etdev->regs->global.pm_csr.value);
+	pm_csr = readl(&etdev->regs->global.pm_csr);
 
-	if (pm_csr.bits.pm_phy_sw_coma == 0)
+	if ((pm_csr & ET_PM_PHY_SW_COMA) == 0)
 		UpdateMacStatHostCounters(etdev);
 	else
 		DBG_VERBOSE(et131x_dbginfo,
 			    "No interrupts, in PHY coma, pm_csr = 0x%x\n",
-			    pm_csr.value);
+			    pm_csr);
 
 	if (!etdev->Bmsr.bits.link_status &&
 	    etdev->RegistryPhyComa &&
@@ -494,7 +494,7 @@ void et131x_error_timer_handler(unsigned
 	if (etdev->PoMgmt.TransPhyComaModeOnBoot == 10) {
 		if (!etdev->Bmsr.bits.link_status
 		    && etdev->RegistryPhyComa) {
-			if (pm_csr.bits.pm_phy_sw_coma == 0) {
+			if ((pm_csr & ET_PM_PHY_SW_COMA) == 0) {
 				/* NOTE - This was originally a 'sync with
 				 *  interrupt'. How to do that under Linux?
 				 */
@@ -1002,15 +1002,7 @@ int __devinit et131x_pci_setup(struct pc
 	/* Perform device-specific initialization here (See code below) */
 
 	/* If Phy COMA mode was enabled when we went down, disable it here. */
-	{
-		PM_CSR_t GlobalPmCSR = { 0 };
-
-		GlobalPmCSR.bits.pm_sysclk_gate = 1;
-		GlobalPmCSR.bits.pm_txclk_gate = 1;
-		GlobalPmCSR.bits.pm_rxclk_gate = 1;
-		writel(GlobalPmCSR.value,
-		       &adapter->regs->global.pm_csr.value);
-	}
+	writel(ET_PMCSR_INIT,  &adapter->regs->global.pm_csr);
 
 	/* Issue a global reset to the et1310 */
 	DBG_TRACE(et131x_dbginfo, "Issuing soft reset...\n");
--- a/drivers/staging/et131x/et131x_isr.c
+++ b/drivers/staging/et131x/et131x_isr.c
@@ -274,14 +274,13 @@ void et131x_isr_handler(struct work_stru
 			 */
 			if (etdev->FlowControl == TxOnly ||
 			    etdev->FlowControl == Both) {
-				PM_CSR_t pm_csr;
+				u32 pm_csr;
 
 				/* Tell the device to send a pause packet via
 				 * the back pressure register
 				 */
-				pm_csr.value =
-					readl(&iomem->global.pm_csr.value);
-				if (pm_csr.bits.pm_phy_sw_coma == 0) {
+				pm_csr = readl(&iomem->global.pm_csr);
+				if ((pm_csr & ET_PM_PHY_SW_COMA) == 0) {
 					TXMAC_BP_CTRL_t bp_ctrl = { 0 };
 
 					bp_ctrl.bits.bp_req = 1;
@@ -351,7 +350,7 @@ void et131x_isr_handler(struct work_stru
 
 		/* Handle the PHY interrupt */
 		if (GlobStatus.bits.phy_interrupt) {
-			PM_CSR_t pm_csr;
+			u32 pm_csr;
 			MI_BMSR_t BmsrInts, BmsrData;
 			MI_ISR_t myIsr;
 
@@ -360,8 +359,8 @@ void et131x_isr_handler(struct work_stru
 			/* If we are in coma mode when we get this interrupt,
 			 * we need to disable it.
 			 */
-			pm_csr.value = readl(&iomem->global.pm_csr.value);
-			if (pm_csr.bits.pm_phy_sw_coma == 1) {
+			pm_csr = readl(&iomem->global.pm_csr);
+			if (pm_csr & ET_PM_PHY_SW_COMA) {
 				/*
 				 * Check to see if we are in coma mode and if
 				 * so, disable it because we will not be able
