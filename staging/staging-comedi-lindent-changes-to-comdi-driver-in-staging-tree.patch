From mithlesh@linsyssoft.com  Thu Jul  2 13:01:37 2009
From: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date: Mon, 8 Jun 2009 21:04:41 +0530 (IST)
Subject: Staging: Comedi: Lindent changes to comdi driver in staging tree
To: Greg Kroah-Hartman <gregkh@suse.de>
Message-ID: <alpine.LFD.2.00.0906082103440.26893@localhost.localdomain>


Lindent changes to comdi driver in staging tree.
This patch is followed by the checkpatch.pl error fixes.
Did not make them part of this patch as the patch size is already huge.

Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/comedi/comedi.h                     |  998 ++++-----
 drivers/staging/comedi/comedi_compat32.c            |  115 -
 drivers/staging/comedi/comedi_compat32.h            |    4 
 drivers/staging/comedi/comedi_fops.c                |  278 +-
 drivers/staging/comedi/comedidev.h                  |   85 
 drivers/staging/comedi/comedilib.h                  |   77 
 drivers/staging/comedi/drivers.c                    |  179 -
 drivers/staging/comedi/drivers/8253.h               |   69 
 drivers/staging/comedi/drivers/8255.c               |   54 
 drivers/staging/comedi/drivers/8255.h               |   16 
 drivers/staging/comedi/drivers/acl7225b.c           |   22 
 drivers/staging/comedi/drivers/adl_pci6208.c        |   93 
 drivers/staging/comedi/drivers/adl_pci7296.c        |   39 
 drivers/staging/comedi/drivers/adl_pci7432.c        |   59 
 drivers/staging/comedi/drivers/adl_pci8164.c        |  126 -
 drivers/staging/comedi/drivers/adl_pci9111.c        |  361 +--
 drivers/staging/comedi/drivers/adl_pci9118.c        |  534 ++--
 drivers/staging/comedi/drivers/adq12b.c             |  367 +--
 drivers/staging/comedi/drivers/adv_pci1710.c        |  417 ++-
 drivers/staging/comedi/drivers/adv_pci1723.c        |   73 
 drivers/staging/comedi/drivers/adv_pci_dio.c        |  306 +-
 drivers/staging/comedi/drivers/aio_aio12_8.c        |   36 
 drivers/staging/comedi/drivers/aio_iiro_16.c        |   30 
 drivers/staging/comedi/drivers/amplc_dio200.c       |  314 +-
 drivers/staging/comedi/drivers/amplc_pc236.c        |  118 -
 drivers/staging/comedi/drivers/amplc_pc263.c        |  101 
 drivers/staging/comedi/drivers/amplc_pci224.c       |  260 +-
 drivers/staging/comedi/drivers/amplc_pci230.c       |  495 ++--
 drivers/staging/comedi/drivers/c6xdigio.c           |   42 
 drivers/staging/comedi/drivers/cb_das16_cs.c        |  166 -
 drivers/staging/comedi/drivers/cb_pcidas.c          |  671 +++---
 drivers/staging/comedi/drivers/cb_pcidas64.c        | 1840 ++++++++---------
 drivers/staging/comedi/drivers/cb_pcidda.c          |  218 +-
 drivers/staging/comedi/drivers/cb_pcidio.c          |   74 
 drivers/staging/comedi/drivers/cb_pcimdas.c         |   89 
 drivers/staging/comedi/drivers/cb_pcimdda.c         |   61 
 drivers/staging/comedi/drivers/comedi_bond.c        |   56 
 drivers/staging/comedi/drivers/comedi_fc.c          |   14 
 drivers/staging/comedi/drivers/comedi_fc.h          |    4 
 drivers/staging/comedi/drivers/comedi_parport.c     |   29 
 drivers/staging/comedi/drivers/comedi_test.c        |  143 -
 drivers/staging/comedi/drivers/contec_pci_dio.c     |   48 
 drivers/staging/comedi/drivers/daqboard2000.c       |  119 -
 drivers/staging/comedi/drivers/das08.c              |  642 +++--
 drivers/staging/comedi/drivers/das08.h              |    3 
 drivers/staging/comedi/drivers/das08_cs.c           |   24 
 drivers/staging/comedi/drivers/das16.c              |  870 ++++----
 drivers/staging/comedi/drivers/das16m1.c            |  132 -
 drivers/staging/comedi/drivers/das1800.c            |  692 +++---
 drivers/staging/comedi/drivers/das6402.c            |   23 
 drivers/staging/comedi/drivers/das800.c             |  236 +-
 drivers/staging/comedi/drivers/dmm32at.c            |  144 -
 drivers/staging/comedi/drivers/dt2801.c             |  242 +-
 drivers/staging/comedi/drivers/dt2811.c             |  178 +
 drivers/staging/comedi/drivers/dt2814.c             |   16 
 drivers/staging/comedi/drivers/dt2815.c             |   38 
 drivers/staging/comedi/drivers/dt2817.c             |   19 
 drivers/staging/comedi/drivers/dt282x.c             |  264 +-
 drivers/staging/comedi/drivers/dt3000.c             |  145 -
 drivers/staging/comedi/drivers/dt9812.c             |   85 
 drivers/staging/comedi/drivers/fl512.c              |   37 
 drivers/staging/comedi/drivers/gsc_hpdi.c           |  236 +-
 drivers/staging/comedi/drivers/icp_multi.c          |  200 +
 drivers/staging/comedi/drivers/icp_multi.h          |   74 
 drivers/staging/comedi/drivers/ii_pci20kc.c         |  127 -
 drivers/staging/comedi/drivers/jr3_pci.c            |  298 +-
 drivers/staging/comedi/drivers/jr3_pci.h            |   40 
 drivers/staging/comedi/drivers/ke_counter.c         |   67 
 drivers/staging/comedi/drivers/me4000.c             |  881 ++++----
 drivers/staging/comedi/drivers/me_daq.c             |  218 +-
 drivers/staging/comedi/drivers/mite.c               |  138 -
 drivers/staging/comedi/drivers/mite.h               |  144 -
 drivers/staging/comedi/drivers/mpc624.c             |   48 
 drivers/staging/comedi/drivers/mpc8260cpm.c         |   26 
 drivers/staging/comedi/drivers/multiq3.c            |   45 
 drivers/staging/comedi/drivers/ni_6527.c            |  107 
 drivers/staging/comedi/drivers/ni_65xx.c            |  442 ++--
 drivers/staging/comedi/drivers/ni_660x.c            |  291 +-
 drivers/staging/comedi/drivers/ni_670x.c            |   97 
 drivers/staging/comedi/drivers/ni_at_a2150.c        |   93 
 drivers/staging/comedi/drivers/ni_at_ao.c           |   69 
 drivers/staging/comedi/drivers/ni_atmio.c           |  318 +-
 drivers/staging/comedi/drivers/ni_atmio16d.c        |  126 -
 drivers/staging/comedi/drivers/ni_daq_700.c         |   80 
 drivers/staging/comedi/drivers/ni_daq_dio24.c       |   43 
 drivers/staging/comedi/drivers/ni_labpc.c           |  452 ++--
 drivers/staging/comedi/drivers/ni_labpc.h           |    5 
 drivers/staging/comedi/drivers/ni_labpc_cs.c        |   70 
 drivers/staging/comedi/drivers/ni_mio_common.c      | 1662 ++++++++-------
 drivers/staging/comedi/drivers/ni_mio_cs.c          |   36 
 drivers/staging/comedi/drivers/ni_pcidio.c          |  341 +--
 drivers/staging/comedi/drivers/ni_pcimio.c          | 2163 ++++++++++----------
 drivers/staging/comedi/drivers/ni_stc.h             |   64 
 drivers/staging/comedi/drivers/ni_tio.c             |  475 ++--
 drivers/staging/comedi/drivers/ni_tio.h             |   47 
 drivers/staging/comedi/drivers/ni_tio_internal.h    |   58 
 drivers/staging/comedi/drivers/ni_tiocmd.c          |  105 
 drivers/staging/comedi/drivers/pcl711.c             |  107 
 drivers/staging/comedi/drivers/pcl724.c             |   33 
 drivers/staging/comedi/drivers/pcl725.c             |    7 
 drivers/staging/comedi/drivers/pcl726.c             |   59 
 drivers/staging/comedi/drivers/pcl730.c             |   16 
 drivers/staging/comedi/drivers/pcl812.c             |  480 ++--
 drivers/staging/comedi/drivers/pcl816.c             |  220 +-
 drivers/staging/comedi/drivers/pcl818.c             |  338 +--
 drivers/staging/comedi/drivers/pcm3724.c            |   28 
 drivers/staging/comedi/drivers/pcm3730.c            |   16 
 drivers/staging/comedi/drivers/pcmad.c              |   17 
 drivers/staging/comedi/drivers/pcmda12.c            |   25 
 drivers/staging/comedi/drivers/pcmmio.c             |  289 +-
 drivers/staging/comedi/drivers/pcmuio.c             |  228 +-
 drivers/staging/comedi/drivers/plx9080.h            |    8 
 drivers/staging/comedi/drivers/poc.c                |  102 
 drivers/staging/comedi/drivers/quatech_daqp_cs.c    |  115 -
 drivers/staging/comedi/drivers/rtd520.c             |  485 ++--
 drivers/staging/comedi/drivers/rti800.c             |   83 
 drivers/staging/comedi/drivers/rti802.c             |   21 
 drivers/staging/comedi/drivers/s526.c               |  199 -
 drivers/staging/comedi/drivers/s626.c               | 1026 +++++----
 drivers/staging/comedi/drivers/s626.h               |   16 
 drivers/staging/comedi/drivers/serial2002.c         |  201 +
 drivers/staging/comedi/drivers/skel.c               |   82 
 drivers/staging/comedi/drivers/ssv_dnp.c            |   40 
 drivers/staging/comedi/drivers/unioxx5.c            |  106 
 drivers/staging/comedi/drivers/usbdux.c             |  268 +-
 drivers/staging/comedi/drivers/usbduxfast.c         |  461 ++--
 drivers/staging/comedi/drivers/vmk80xx.c            |  135 -
 drivers/staging/comedi/kcomedilib/data.c            |   12 
 drivers/staging/comedi/kcomedilib/dio.c             |    8 
 drivers/staging/comedi/kcomedilib/get.c             |   55 
 drivers/staging/comedi/kcomedilib/kcomedilib_main.c |   35 
 drivers/staging/comedi/proc.c                       |   23 
 drivers/staging/comedi/range.c                      |   21 
 133 files changed, 14961 insertions(+), 13080 deletions(-)

--- a/drivers/staging/comedi/comedi_compat32.c
+++ b/drivers/staging/comedi/comedi_compat32.c
@@ -51,7 +51,7 @@
 struct comedi32_chaninfo_struct {
 	unsigned int subdev;
 	compat_uptr_t maxdata_list;	/* 32-bit 'unsigned int *' */
-	compat_uptr_t flaglist;		/* 32-bit 'unsigned int *' */
+	compat_uptr_t flaglist;	/* 32-bit 'unsigned int *' */
 	compat_uptr_t rangelist;	/* 32-bit 'unsigned int *' */
 	unsigned int unused[4];
 };
@@ -74,16 +74,16 @@ struct comedi32_cmd_struct {
 	unsigned int scan_end_arg;
 	unsigned int stop_src;
 	unsigned int stop_arg;
-	compat_uptr_t chanlist;		/* 32-bit 'unsigned int *' */
+	compat_uptr_t chanlist;	/* 32-bit 'unsigned int *' */
 	unsigned int chanlist_len;
-	compat_uptr_t data;		/* 32-bit 'short *' */
+	compat_uptr_t data;	/* 32-bit 'short *' */
 	unsigned int data_len;
 };
 
 struct comedi32_insn_struct {
 	unsigned int insn;
 	unsigned int n;
-	compat_uptr_t data;		/* 32-bit 'unsigned int *' */
+	compat_uptr_t data;	/* 32-bit 'unsigned int *' */
 	unsigned int subdev;
 	unsigned int chanspec;
 	unsigned int unused[3];
@@ -91,19 +91,19 @@ struct comedi32_insn_struct {
 
 struct comedi32_insnlist_struct {
 	unsigned int n_insns;
-	compat_uptr_t insns;		/* 32-bit 'struct comedi_insn *' */
+	compat_uptr_t insns;	/* 32-bit 'struct comedi_insn *' */
 };
 
 /* Handle translated ioctl. */
 static int translated_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
+			    unsigned long arg)
 {
 	if (!file->f_op)
 		return -ENOTTY;
 
 #ifdef HAVE_UNLOCKED_IOCTL
 	if (file->f_op->unlocked_ioctl) {
-		int rc = (int)(*file->f_op->unlocked_ioctl)(file, cmd, arg);
+		int rc = (int)(*file->f_op->unlocked_ioctl) (file, cmd, arg);
 		if (rc == -ENOIOCTLCMD)
 			rc = -ENOTTY;
 		return rc;
@@ -112,8 +112,8 @@ static int translated_ioctl(struct file 
 	if (file->f_op->ioctl) {
 		int rc;
 		lock_kernel();
-		rc = (*file->f_op->ioctl)(file->f_dentry->d_inode,
-				file, cmd, arg);
+		rc = (*file->f_op->ioctl) (file->f_dentry->d_inode,
+					   file, cmd, arg);
 		unlock_kernel();
 		return rc;
 	}
@@ -136,8 +136,7 @@ static int compat_chaninfo(struct file *
 
 	/* Copy chaninfo structure.  Ignore unused members. */
 	if (!access_ok(VERIFY_READ, chaninfo32, sizeof(*chaninfo32))
-			|| !access_ok(VERIFY_WRITE, chaninfo,
-				sizeof(*chaninfo))) {
+	    || !access_ok(VERIFY_WRITE, chaninfo, sizeof(*chaninfo))) {
 		return -EFAULT;
 	}
 	err = 0;
@@ -171,8 +170,7 @@ static int compat_rangeinfo(struct file 
 
 	/* Copy rangeinfo structure. */
 	if (!access_ok(VERIFY_READ, rangeinfo32, sizeof(*rangeinfo32))
-			|| !access_ok(VERIFY_WRITE, rangeinfo,
-				sizeof(*rangeinfo))) {
+	    || !access_ok(VERIFY_WRITE, rangeinfo, sizeof(*rangeinfo))) {
 		return -EFAULT;
 	}
 	err = 0;
@@ -184,12 +182,12 @@ static int compat_rangeinfo(struct file 
 		return -EFAULT;
 
 	return translated_ioctl(file, COMEDI_RANGEINFO,
-			(unsigned long)rangeinfo);
+				(unsigned long)rangeinfo);
 }
 
 /* Copy 32-bit cmd structure to native cmd structure. */
-static int get_compat_cmd(struct comedi_cmd __user *cmd,
-		struct comedi32_cmd_struct __user *cmd32)
+static int get_compat_cmd(struct comedi_cmd __user * cmd,
+			  struct comedi32_cmd_struct __user * cmd32)
 {
 	int err;
 	union {
@@ -199,7 +197,7 @@ static int get_compat_cmd(struct comedi_
 
 	/* Copy cmd structure. */
 	if (!access_ok(VERIFY_READ, cmd32, sizeof(*cmd32))
-			|| !access_ok(VERIFY_WRITE, cmd, sizeof(*cmd))) {
+	    || !access_ok(VERIFY_WRITE, cmd, sizeof(*cmd))) {
 		return -EFAULT;
 	}
 	err = 0;
@@ -239,7 +237,8 @@ static int get_compat_cmd(struct comedi_
 }
 
 /* Copy native cmd structure to 32-bit cmd structure. */
-static int put_compat_cmd(struct comedi32_cmd_struct __user *cmd32, struct comedi_cmd __user *cmd)
+static int put_compat_cmd(struct comedi32_cmd_struct __user * cmd32,
+			  struct comedi_cmd __user * cmd)
 {
 	int err;
 	unsigned int temp;
@@ -249,7 +248,7 @@ static int put_compat_cmd(struct comedi3
 	/* (Could use ptr_to_compat() to set them, but that wasn't implemented
 	 * until kernel version 2.6.11.) */
 	if (!access_ok(VERIFY_READ, cmd, sizeof(*cmd))
-			|| !access_ok(VERIFY_WRITE, cmd32, sizeof(*cmd32))) {
+	    || !access_ok(VERIFY_WRITE, cmd32, sizeof(*cmd32))) {
 		return -EFAULT;
 	}
 	err = 0;
@@ -329,8 +328,8 @@ static int compat_cmdtest(struct file *f
 }
 
 /* Copy 32-bit insn structure to native insn structure. */
-static int get_compat_insn(struct comedi_insn __user *insn,
-		struct comedi32_insn_struct __user *insn32)
+static int get_compat_insn(struct comedi_insn __user * insn,
+			   struct comedi32_insn_struct __user * insn32)
 {
 	int err;
 	union {
@@ -341,7 +340,7 @@ static int get_compat_insn(struct comedi
 	/* Copy insn structure.  Ignore the unused members. */
 	err = 0;
 	if (!access_ok(VERIFY_READ, insn32, sizeof(*insn32))
-			|| !access_ok(VERIFY_WRITE, insn, sizeof(*insn)))
+	    || !access_ok(VERIFY_WRITE, insn, sizeof(*insn)))
 		return -EFAULT;
 
 	err |= __get_user(temp.uint, &insn32->insn);
@@ -385,7 +384,7 @@ static int compat_insnlist(struct file *
 
 	/* Allocate user memory to copy insnlist and insns into. */
 	s = compat_alloc_user_space(offsetof(struct combined_insnlist,
-				insn[n_insns]));
+					     insn[n_insns]));
 
 	/* Set native insnlist structure. */
 	if (!access_ok(VERIFY_WRITE, &s->insnlist, sizeof(s->insnlist))) {
@@ -404,7 +403,7 @@ static int compat_insnlist(struct file *
 	}
 
 	return translated_ioctl(file, COMEDI_INSNLIST,
-			(unsigned long)&s->insnlist);
+				(unsigned long)&s->insnlist);
 }
 
 /* Handle 32-bit COMEDI_INSN ioctl. */
@@ -427,7 +426,7 @@ static int compat_insn(struct file *file
 /* Process untranslated ioctl. */
 /* Returns -ENOIOCTLCMD for unrecognised ioctl codes. */
 static inline int raw_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
+			    unsigned long arg)
 {
 	int rc;
 
@@ -477,8 +476,7 @@ static inline int raw_ioctl(struct file 
 
 /* compat_ioctl file operation. */
 /* Returns -ENOIOCTLCMD for unrecognised ioctl codes. */
-long comedi_compat_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
+long comedi_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	return raw_ioctl(file, cmd, arg);
 }
@@ -497,7 +495,7 @@ long comedi_compat_ioctl(struct file *fi
 
 /* Handler for all 32-bit ioctl codes registered by this driver. */
 static int mapped_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg,
-		struct file *file)
+			struct file *file)
 {
 	int rc;
 
@@ -515,27 +513,27 @@ static int mapped_ioctl(unsigned int fd,
 
 struct ioctl32_map {
 	unsigned int cmd;
-	int (*handler)(unsigned int, unsigned int, unsigned long,
+	int (*handler) (unsigned int, unsigned int, unsigned long,
 			struct file *);
 	int registered;
 };
 
 static struct ioctl32_map comedi_ioctl32_map[] = {
-	{ COMEDI_DEVCONFIG, mapped_ioctl, 0 },
-	{ COMEDI_DEVINFO, mapped_ioctl, 0 },
-	{ COMEDI_SUBDINFO, mapped_ioctl, 0 },
-	{ COMEDI_BUFCONFIG, mapped_ioctl, 0 },
-	{ COMEDI_BUFINFO, mapped_ioctl, 0 },
-	{ COMEDI_LOCK, mapped_ioctl, 0 },
-	{ COMEDI_UNLOCK, mapped_ioctl, 0 },
-	{ COMEDI_CANCEL, mapped_ioctl, 0 },
-	{ COMEDI_POLL, mapped_ioctl, 0 },
-	{ COMEDI32_CHANINFO, mapped_ioctl, 0 },
-	{ COMEDI32_RANGEINFO, mapped_ioctl, 0 },
-	{ COMEDI32_CMD, mapped_ioctl, 0 },
-	{ COMEDI32_CMDTEST, mapped_ioctl, 0 },
-	{ COMEDI32_INSNLIST, mapped_ioctl, 0 },
-	{ COMEDI32_INSN, mapped_ioctl, 0 },
+	{COMEDI_DEVCONFIG, mapped_ioctl, 0},
+	{COMEDI_DEVINFO, mapped_ioctl, 0},
+	{COMEDI_SUBDINFO, mapped_ioctl, 0},
+	{COMEDI_BUFCONFIG, mapped_ioctl, 0},
+	{COMEDI_BUFINFO, mapped_ioctl, 0},
+	{COMEDI_LOCK, mapped_ioctl, 0},
+	{COMEDI_UNLOCK, mapped_ioctl, 0},
+	{COMEDI_CANCEL, mapped_ioctl, 0},
+	{COMEDI_POLL, mapped_ioctl, 0},
+	{COMEDI32_CHANINFO, mapped_ioctl, 0},
+	{COMEDI32_RANGEINFO, mapped_ioctl, 0},
+	{COMEDI32_CMD, mapped_ioctl, 0},
+	{COMEDI32_CMDTEST, mapped_ioctl, 0},
+	{COMEDI32_INSNLIST, mapped_ioctl, 0},
+	{COMEDI32_INSN, mapped_ioctl, 0},
 };
 
 #define NUM_IOCTL32_MAPS ARRAY_SIZE(comedi_ioctl32_map)
@@ -547,13 +545,13 @@ void comedi_register_ioctl32(void)
 
 	for (n = 0; n < NUM_IOCTL32_MAPS; n++) {
 		rc = register_ioctl32_conversion(comedi_ioctl32_map[n].cmd,
-				comedi_ioctl32_map[n].handler);
+						 comedi_ioctl32_map[n].handler);
 		if (rc) {
 			printk(KERN_WARNING
-					"comedi: failed to register 32-bit "
-					"compatible ioctl handler for 0x%X - "
-					"expect bad things to happen!\n",
-					comedi_ioctl32_map[n].cmd);
+			       "comedi: failed to register 32-bit "
+			       "compatible ioctl handler for 0x%X - "
+			       "expect bad things to happen!\n",
+			       comedi_ioctl32_map[n].cmd);
 		}
 		comedi_ioctl32_map[n].registered = !rc;
 	}
@@ -566,15 +564,16 @@ void comedi_unregister_ioctl32(void)
 
 	for (n = 0; n < NUM_IOCTL32_MAPS; n++) {
 		if (comedi_ioctl32_map[n].registered) {
-			rc = unregister_ioctl32_conversion(
-					comedi_ioctl32_map[n].cmd,
-					comedi_ioctl32_map[n].handler);
+			rc = unregister_ioctl32_conversion(comedi_ioctl32_map
+							   [n].cmd,
+							   comedi_ioctl32_map
+							   [n].handler);
 			if (rc) {
 				printk(KERN_ERR
-					"comedi: failed to unregister 32-bit "
-					"compatible ioctl handler for 0x%X - "
-					"expect kernel Oops!\n",
-					comedi_ioctl32_map[n].cmd);
+				       "comedi: failed to unregister 32-bit "
+				       "compatible ioctl handler for 0x%X - "
+				       "expect kernel Oops!\n",
+				       comedi_ioctl32_map[n].cmd);
 			} else {
 				comedi_ioctl32_map[n].registered = 0;
 			}
@@ -582,6 +581,6 @@ void comedi_unregister_ioctl32(void)
 	}
 }
 
-#endif	/* HAVE_COMPAT_IOCTL */
+#endif /* HAVE_COMPAT_IOCTL */
 
-#endif	/* CONFIG_COMPAT */
+#endif /* CONFIG_COMPAT */
--- a/drivers/staging/comedi/comedi_compat32.h
+++ b/drivers/staging/comedi/comedi_compat32.h
@@ -28,14 +28,14 @@
 #define _COMEDI_COMPAT32_H
 
 #include <linux/compat.h>
-#include <linux/fs.h>	/* For HAVE_COMPAT_IOCTL and HAVE_UNLOCKED_IOCTL */
+#include <linux/fs.h>		/* For HAVE_COMPAT_IOCTL and HAVE_UNLOCKED_IOCTL */
 
 #ifdef CONFIG_COMPAT
 
 #ifdef HAVE_COMPAT_IOCTL
 
 extern long comedi_compat_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg);
+				unsigned long arg);
 #define comedi_register_ioctl32() do {} while (0)
 #define comedi_unregister_ioctl32() do {} while (0)
 
--- a/drivers/staging/comedi/comedidev.h
+++ b/drivers/staging/comedi/comedidev.h
@@ -156,28 +156,30 @@ struct comedi_subdevice {
 
 	unsigned int *chanlist;	/* driver-owned chanlist (not used) */
 
-	int (*insn_read) (struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-		unsigned int *);
-	int (*insn_write) (struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-		unsigned int *);
-	int (*insn_bits) (struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-		unsigned int *);
-	int (*insn_config) (struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-		unsigned int *);
+	int (*insn_read) (struct comedi_device *, struct comedi_subdevice *,
+			  struct comedi_insn *, unsigned int *);
+	int (*insn_write) (struct comedi_device *, struct comedi_subdevice *,
+			   struct comedi_insn *, unsigned int *);
+	int (*insn_bits) (struct comedi_device *, struct comedi_subdevice *,
+			  struct comedi_insn *, unsigned int *);
+	int (*insn_config) (struct comedi_device *, struct comedi_subdevice *,
+			    struct comedi_insn *, unsigned int *);
 
 	int (*do_cmd) (struct comedi_device *, struct comedi_subdevice *);
-	int (*do_cmdtest) (struct comedi_device *, struct comedi_subdevice *, struct comedi_cmd *);
+	int (*do_cmdtest) (struct comedi_device *, struct comedi_subdevice *,
+			   struct comedi_cmd *);
 	int (*poll) (struct comedi_device *, struct comedi_subdevice *);
 	int (*cancel) (struct comedi_device *, struct comedi_subdevice *);
 	/* int (*do_lock)(struct comedi_device *,struct comedi_subdevice *); */
 	/* int (*do_unlock)(struct comedi_device *,struct comedi_subdevice *); */
 
 	/* called when the buffer changes */
-	int (*buf_change) (struct comedi_device *dev, struct comedi_subdevice *s,
-		unsigned long new_size);
+	int (*buf_change) (struct comedi_device * dev,
+			   struct comedi_subdevice * s, unsigned long new_size);
 
-	void (*munge) (struct comedi_device *dev, struct comedi_subdevice *s, void *data,
-		unsigned int num_bytes, unsigned int start_chan_index);
+	void (*munge) (struct comedi_device * dev, struct comedi_subdevice * s,
+		       void *data, unsigned int num_bytes,
+		       unsigned int start_chan_index);
 	enum dma_data_direction async_dma_dir;
 
 	unsigned int state;
@@ -231,7 +233,7 @@ struct comedi_async {
 	int (*cb_func) (unsigned int flags, void *);
 	void *cb_arg;
 
-	int (*inttrig) (struct comedi_device *dev, struct comedi_subdevice *s,
+	int (*inttrig) (struct comedi_device * dev, struct comedi_subdevice * s,
 			unsigned int x);
 };
 
@@ -281,8 +283,8 @@ struct comedi_device {
 
 	struct fasync_struct *async_queue;
 
-	void (*open) (struct comedi_device *dev);
-	void (*close) (struct comedi_device *dev);
+	void (*open) (struct comedi_device * dev);
+	void (*close) (struct comedi_device * dev);
 };
 
 struct comedi_device_file_info {
@@ -316,8 +318,9 @@ static const unsigned COMEDI_SUBDEVICE_M
 
 struct comedi_device_file_info *comedi_get_device_file_info(unsigned minor);
 
-static inline struct comedi_subdevice *comedi_get_read_subdevice(
-				const struct comedi_device_file_info *info)
+static inline struct comedi_subdevice *comedi_get_read_subdevice(const struct
+								 comedi_device_file_info
+								 *info)
 {
 	if (info->read_subdevice)
 		return info->read_subdevice;
@@ -326,8 +329,9 @@ static inline struct comedi_subdevice *c
 	return info->device->read_subdev;
 }
 
-static inline struct comedi_subdevice *comedi_get_write_subdevice(
-				const struct comedi_device_file_info *info)
+static inline struct comedi_subdevice *comedi_get_write_subdevice(const struct
+								  comedi_device_file_info
+								  *info)
 {
 	if (info->write_subdevice)
 		return info->write_subdevice;
@@ -337,7 +341,8 @@ static inline struct comedi_subdevice *c
 }
 
 void comedi_device_detach(struct comedi_device *dev);
-int comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+int comedi_device_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 int comedi_driver_register(struct comedi_driver *);
 int comedi_driver_unregister(struct comedi_driver *);
 
@@ -346,8 +351,8 @@ void cleanup_polling(void);
 void start_polling(struct comedi_device *);
 void stop_polling(struct comedi_device *);
 
-int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s, unsigned long
-	new_size);
+int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
+		     unsigned long new_size);
 
 #ifdef CONFIG_PROC_FS
 void comedi_proc_init(void);
@@ -356,6 +361,7 @@ void comedi_proc_cleanup(void);
 static inline void comedi_proc_init(void)
 {
 }
+
 static inline void comedi_proc_cleanup(void)
 {
 }
@@ -378,10 +384,10 @@ enum subdevice_runflags {
 int do_rangeinfo_ioctl(struct comedi_device *dev, struct comedi_rangeinfo *arg);
 int check_chanlist(struct comedi_subdevice *s, int n, unsigned int *chanlist);
 void comedi_set_subdevice_runflags(struct comedi_subdevice *s, unsigned mask,
-	unsigned bits);
+				   unsigned bits);
 unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s);
 int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+	       struct comedi_insn *insn, unsigned int *data);
 
 /* range stuff */
 
@@ -421,7 +427,8 @@ static inline int alloc_subdevices(struc
 
 	dev->n_subdevices = num_subdevices;
 	dev->subdevices =
-		kcalloc(num_subdevices, sizeof(struct comedi_subdevice), GFP_KERNEL);
+	    kcalloc(num_subdevices, sizeof(struct comedi_subdevice),
+		    GFP_KERNEL);
 	if (!dev->subdevices)
 		return -ENOMEM;
 	for (i = 0; i < num_subdevices; ++i) {
@@ -451,7 +458,8 @@ static inline unsigned int bytes_per_sam
 
 /* must be used in attach to set dev->hw_dev if you wish to dma directly
 into comedi's buffer */
-static inline void comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)
+static inline void comedi_set_hw_dev(struct comedi_device *dev,
+				     struct device *hw_dev)
 {
 	if (dev->hw_dev)
 		put_device(dev->hw_dev);
@@ -467,21 +475,23 @@ int comedi_buf_put(struct comedi_async *
 int comedi_buf_get(struct comedi_async *async, short *x);
 
 unsigned int comedi_buf_write_n_available(struct comedi_async *async);
-unsigned int comedi_buf_write_alloc(struct comedi_async *async, unsigned int nbytes);
+unsigned int comedi_buf_write_alloc(struct comedi_async *async,
+				    unsigned int nbytes);
 unsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,
-	unsigned int nbytes);
+					   unsigned int nbytes);
 unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes);
 unsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes);
 unsigned comedi_buf_read_free(struct comedi_async *async, unsigned int nbytes);
 unsigned int comedi_buf_read_n_available(struct comedi_async *async);
 void comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,
-	const void *source, unsigned int num_bytes);
+			  const void *source, unsigned int num_bytes);
 void comedi_buf_memcpy_from(struct comedi_async *async, unsigned int offset,
-	void *destination, unsigned int num_bytes);
+			    void *destination, unsigned int num_bytes);
 static inline unsigned comedi_buf_write_n_allocated(struct comedi_async *async)
 {
 	return async->buf_write_alloc_count - async->buf_write_count;
 }
+
 static inline unsigned comedi_buf_read_n_allocated(struct comedi_async *async)
 {
 	return async->buf_read_alloc_count - async->buf_read_count;
@@ -516,25 +526,26 @@ static inline void *comedi_aux_data(int 
 
 int comedi_alloc_board_minor(struct device *hardware_device);
 void comedi_free_board_minor(unsigned minor);
-int comedi_alloc_subdevice_minor(struct comedi_device *dev, struct comedi_subdevice *s);
+int comedi_alloc_subdevice_minor(struct comedi_device *dev,
+				 struct comedi_subdevice *s);
 void comedi_free_subdevice_minor(struct comedi_subdevice *s);
 int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name);
 void comedi_pci_auto_unconfig(struct pci_dev *pcidev);
-struct usb_device;	/* forward declaration */
+struct usb_device;		/* forward declaration */
 int comedi_usb_auto_config(struct usb_device *usbdev, const char *board_name);
 void comedi_usb_auto_unconfig(struct usb_device *usbdev);
 
 #ifdef CONFIG_COMEDI_PCI_DRIVERS
-	#define CONFIG_COMEDI_PCI
+#define CONFIG_COMEDI_PCI
 #endif
 #ifdef CONFIG_COMEDI_PCI_DRIVERS_MODULE
-	#define CONFIG_COMEDI_PCI
+#define CONFIG_COMEDI_PCI
 #endif
 #ifdef CONFIG_COMEDI_PCMCIA_DRIVERS
-	#define CONFIG_COMEDI_PCMCIA
+#define CONFIG_COMEDI_PCMCIA
 #endif
 #ifdef CONFIG_COMEDI_PCMCIA_DRIVERS_MODULE
-	#define CONFIG_COMEDI_PCMCIA
+#define CONFIG_COMEDI_PCMCIA
 #endif
 
 #endif /* _COMEDIDEV_H */
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -68,26 +68,33 @@ module_param(comedi_num_legacy_minors, i
 
 static DEFINE_SPINLOCK(comedi_file_info_table_lock);
 static struct comedi_device_file_info
-    *comedi_file_info_table[COMEDI_NUM_MINORS];
+*comedi_file_info_table[COMEDI_NUM_MINORS];
 
-static int do_devconfig_ioctl(struct comedi_device *dev, struct comedi_devconfig *arg);
+static int do_devconfig_ioctl(struct comedi_device *dev,
+			      struct comedi_devconfig *arg);
 static int do_bufconfig_ioctl(struct comedi_device *dev, void *arg);
-static int do_devinfo_ioctl(struct comedi_device *dev, struct comedi_devinfo *arg,
-			    struct file *file);
-static int do_subdinfo_ioctl(struct comedi_device *dev, struct comedi_subdinfo *arg,
-			     void *file);
-static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *arg);
+static int do_devinfo_ioctl(struct comedi_device *dev,
+			    struct comedi_devinfo *arg, struct file *file);
+static int do_subdinfo_ioctl(struct comedi_device *dev,
+			     struct comedi_subdinfo *arg, void *file);
+static int do_chaninfo_ioctl(struct comedi_device *dev,
+			     struct comedi_chaninfo *arg);
 static int do_bufinfo_ioctl(struct comedi_device *dev, void *arg);
 static int do_cmd_ioctl(struct comedi_device *dev, void *arg, void *file);
-static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
-static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
-static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *file);
+static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
+			 void *file);
+static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
+			   void *file);
+static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
+			   void *file);
 static int do_cmdtest_ioctl(struct comedi_device *dev, void *arg, void *file);
 static int do_insnlist_ioctl(struct comedi_device *dev, void *arg, void *file);
 static int do_insn_ioctl(struct comedi_device *dev, void *arg, void *file);
-static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd, void *file);
+static int do_poll_ioctl(struct comedi_device *dev, unsigned int subd,
+			 void *file);
 
-extern void do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s);
+extern void do_become_nonbusy(struct comedi_device *dev,
+			      struct comedi_subdevice *s);
 static int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int comedi_fasync(int fd, struct file *file, int on);
@@ -202,7 +209,8 @@ done:
 	writes:
 		none
 */
-static int do_devconfig_ioctl(struct comedi_device *dev, struct comedi_devconfig *arg)
+static int do_devconfig_ioctl(struct comedi_device *dev,
+			      struct comedi_devconfig *arg)
 {
 	struct comedi_devconfig it;
 	int ret;
@@ -342,8 +350,8 @@ copyback:
 		devinfo structure
 
 */
-static int do_devinfo_ioctl(struct comedi_device *dev, struct comedi_devinfo *arg,
-			    struct file *file)
+static int do_devinfo_ioctl(struct comedi_device *dev,
+			    struct comedi_devinfo *arg, struct file *file)
 {
 	struct comedi_devinfo devinfo;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
@@ -392,14 +400,16 @@ static int do_devinfo_ioctl(struct comed
 		array of subdevice info structures at arg
 
 */
-static int do_subdinfo_ioctl(struct comedi_device *dev, struct comedi_subdinfo *arg,
-			     void *file)
+static int do_subdinfo_ioctl(struct comedi_device *dev,
+			     struct comedi_subdinfo *arg, void *file)
 {
 	int ret, i;
 	struct comedi_subdinfo *tmp, *us;
 	struct comedi_subdevice *s;
 
-	tmp = kcalloc(dev->n_subdevices, sizeof(struct comedi_subdinfo), GFP_KERNEL);
+	tmp =
+	    kcalloc(dev->n_subdevices, sizeof(struct comedi_subdinfo),
+		    GFP_KERNEL);
 	if (!tmp)
 		return -ENOMEM;
 
@@ -472,7 +482,8 @@ static int do_subdinfo_ioctl(struct come
 		arrays at elements of chaninfo structure
 
 */
-static int do_chaninfo_ioctl(struct comedi_device *dev, struct comedi_chaninfo *arg)
+static int do_chaninfo_ioctl(struct comedi_device *dev,
+			     struct comedi_chaninfo *arg)
 {
 	struct comedi_subdevice *s;
 	struct comedi_chaninfo it;
@@ -514,7 +525,7 @@ static int do_chaninfo_ioctl(struct come
 		}
 #if 0
 		if (copy_to_user(it.rangelist, s->range_type_list,
-				 s->n_chan*sizeof(unsigned int)))
+				 s->n_chan * sizeof(unsigned int)))
 			return -EFAULT;
 #endif
 	}
@@ -589,8 +600,8 @@ copyback:
 	return 0;
 }
 
-static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn, unsigned int *data,
-		      void *file);
+static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
+		      unsigned int *data, void *file);
 /*
  * 	COMEDI_INSNLIST
  * 	synchronous instructions
@@ -626,7 +637,8 @@ static int do_insnlist_ioctl(struct come
 		goto error;
 	}
 
-	insns = kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);
+	insns =
+	    kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);
 	if (!insns) {
 		DPRINTK("kmalloc failed\n");
 		ret = -ENOMEM;
@@ -678,7 +690,8 @@ error:
 	return i;
 }
 
-static int check_insn_config_length(struct comedi_insn *insn, unsigned int *data)
+static int check_insn_config_length(struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -725,22 +738,22 @@ static int check_insn_config_length(stru
 		if (insn->n == 5)
 			return 0;
 		break;
-	/* by default we allow the insn since we don't have checks for
-	 * all possible cases yet */
+		/* by default we allow the insn since we don't have checks for
+		 * all possible cases yet */
 	default:
 		printk("comedi: no check for data length of config insn id "
-			  "%i is implemented.\n"
-			  " Add a check to %s in %s.\n"
-			  " Assuming n=%i is correct.\n", data[0], __func__,
-			  __FILE__, insn->n);
+		       "%i is implemented.\n"
+		       " Add a check to %s in %s.\n"
+		       " Assuming n=%i is correct.\n", data[0], __func__,
+		       __FILE__, insn->n);
 		return 0;
 		break;
 	}
 	return -EINVAL;
 }
 
-static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn, unsigned int *data,
-		      void *file)
+static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
+		      unsigned int *data, void *file)
 {
 	struct comedi_subdevice *s;
 	int ret = 0;
@@ -920,7 +933,8 @@ static int do_insn_ioctl(struct comedi_d
 	if (insn.n > MAX_SAMPLES)
 		insn.n = MAX_SAMPLES;
 	if (insn.insn & INSN_MASK_WRITE) {
-		if (copy_from_user(data, insn.data, insn.n * sizeof(unsigned int))) {
+		if (copy_from_user
+		    (data, insn.data, insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
@@ -929,7 +943,8 @@ static int do_insn_ioctl(struct comedi_d
 	if (ret < 0)
 		goto error;
 	if (insn.insn & INSN_MASK_READ) {
-		if (copy_to_user(insn.data, data, insn.n * sizeof(unsigned int))) {
+		if (copy_to_user
+		    (insn.data, data, insn.n * sizeof(unsigned int))) {
 			ret = -EFAULT;
 			goto error;
 		}
@@ -1202,7 +1217,8 @@ cleanup:
 
 */
 
-static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
+static int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,
+			 void *file)
 {
 	int ret = 0;
 	unsigned long flags;
@@ -1246,7 +1262,8 @@ static int do_lock_ioctl(struct comedi_d
 	This function isn't protected by the semaphore, since
 	we already own the lock.
 */
-static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
+static int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,
+			   void *file)
 {
 	struct comedi_subdevice *s;
 
@@ -1286,7 +1303,8 @@ static int do_unlock_ioctl(struct comedi
 		nothing
 
 */
-static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
+static int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,
+			   void *file)
 {
 	struct comedi_subdevice *s;
 
@@ -1322,7 +1340,8 @@ static int do_cancel_ioctl(struct comedi
 		nothing
 
 */
-static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg, void *file)
+static int do_poll_ioctl(struct comedi_device *dev, unsigned int arg,
+			 void *file)
 {
 	struct comedi_subdevice *s;
 
@@ -1371,7 +1390,7 @@ void comedi_unmap(struct vm_area_struct 
 }
 
 static struct vm_operations_struct comedi_vm_ops = {
-	.close =	comedi_unmap,
+	.close = comedi_unmap,
 };
 
 static int comedi_mmap(struct file *file, struct vm_area_struct *vma)
@@ -1428,10 +1447,10 @@ static int comedi_mmap(struct file *file
 	n_pages = size >> PAGE_SHIFT;
 	for (i = 0; i < n_pages; ++i) {
 		if (remap_pfn_range(vma, start,
-				    page_to_pfn(virt_to_page(async->
-							     buf_page_list[i].
-							     virt_addr)),
-				    PAGE_SIZE, PAGE_SHARED)) {
+				    page_to_pfn(virt_to_page
+						(async->buf_page_list
+						 [i].virt_addr)), PAGE_SIZE,
+				    PAGE_SHARED)) {
 			retval = -EAGAIN;
 			goto done;
 		}
@@ -1449,7 +1468,7 @@ done:
 	return retval;
 }
 
-static unsigned int comedi_poll(struct file *file, poll_table *wait)
+static unsigned int comedi_poll(struct file *file, poll_table * wait)
 {
 	unsigned int mask = 0;
 	const unsigned minor = iminor(file->f_dentry->d_inode);
@@ -1496,7 +1515,7 @@ static unsigned int comedi_poll(struct f
 }
 
 static ssize_t comedi_write(struct file *file, const char *buf, size_t nbytes,
-			    loff_t *offset)
+			    loff_t * offset)
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
@@ -1598,7 +1617,7 @@ done:
 }
 
 static ssize_t comedi_read(struct file *file, char *buf, size_t nbytes,
-			   loff_t *offset)
+			   loff_t * offset)
 {
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
@@ -1729,7 +1748,8 @@ static int comedi_open(struct inode *ino
 	const unsigned minor = iminor(inode);
 	struct comedi_device_file_info *dev_file_info =
 	    comedi_get_device_file_info(minor);
-	struct comedi_device *dev = dev_file_info ? dev_file_info->device : NULL;
+	struct comedi_device *dev =
+	    dev_file_info ? dev_file_info->device : NULL;
 
 	if (dev == NULL) {
 		DPRINTK("invalid minor number\n");
@@ -1846,22 +1866,22 @@ static int comedi_fasync(int fd, struct 
 }
 
 const struct file_operations comedi_fops = {
-      .owner =		THIS_MODULE,
+	.owner = THIS_MODULE,
 #ifdef HAVE_UNLOCKED_IOCTL
-      .unlocked_ioctl =	comedi_unlocked_ioctl,
+	.unlocked_ioctl = comedi_unlocked_ioctl,
 #else
-      .ioctl =		comedi_ioctl,
+	.ioctl = comedi_ioctl,
 #endif
 #ifdef HAVE_COMPAT_IOCTL
-      .compat_ioctl =	comedi_compat_ioctl,
+	.compat_ioctl = comedi_compat_ioctl,
 #endif
-      .open =		comedi_open,
-      .release =	comedi_close,
-      .read =		comedi_read,
-      .write =		comedi_write,
-      .mmap =		comedi_mmap,
-      .poll =		comedi_poll,
-      .fasync =		comedi_fasync,
+	.open = comedi_open,
+	.release = comedi_close,
+	.read = comedi_read,
+	.write = comedi_write,
+	.mmap = comedi_mmap,
+	.poll = comedi_poll,
+	.fasync = comedi_fasync,
 };
 
 struct class *comedi_class;
@@ -1952,7 +1972,6 @@ static void __exit comedi_cleanup(void)
 	for (i = 0; i < COMEDI_NUM_MINORS; ++i)
 		BUG_ON(comedi_file_info_table[i]);
 
-
 	class_destroy(comedi_class);
 	cdev_del(&comedi_cdev);
 	unregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);
@@ -1981,8 +2000,9 @@ void comedi_event(struct comedi_device *
 	if ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) == 0)
 		return;
 
-	if (s->async->
-	    events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
+	if (s->
+	    async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+			     COMEDI_CB_OVERFLOW)) {
 		runflags_mask |= SRF_RUNNING;
 	}
 	/* remember if an error event has occured, so an error
@@ -2000,12 +2020,10 @@ void comedi_event(struct comedi_device *
 		if (comedi_get_subdevice_runflags(s) & SRF_USER) {
 			wake_up_interruptible(&async->wait_head);
 			if (s->subdev_flags & SDF_CMD_READ) {
-				kill_fasync(&dev->async_queue, SIGIO,
-					    POLL_IN);
+				kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
 			}
 			if (s->subdev_flags & SDF_CMD_WRITE) {
-				kill_fasync(&dev->async_queue, SIGIO,
-					    POLL_OUT);
+				kill_fasync(&dev->async_queue, SIGIO, POLL_OUT);
 			}
 		} else {
 			if (async->cb_func)
@@ -2103,7 +2121,8 @@ int comedi_alloc_board_minor(struct devi
 		comedi_device_cleanup(info->device);
 		kfree(info->device);
 		kfree(info);
-		printk(KERN_ERR "comedi: error: ran out of minor numbers for board device files.\n");
+		printk(KERN_ERR
+		       "comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	info->device->minor = i;
@@ -2115,29 +2134,33 @@ int comedi_alloc_board_minor(struct devi
 	dev_set_drvdata(csdev, info);
 	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_max_read_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_max_read_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_read_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_read_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_max_write_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_max_write_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_write_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_write_buffer_kb.attr.name);
 		comedi_free_board_minor(i);
 		return retval;
 	}
@@ -2194,7 +2217,8 @@ int comedi_alloc_subdevice_minor(struct 
 	spin_unlock_irqrestore(&comedi_file_info_table_lock, flags);
 	if (i == COMEDI_NUM_MINORS) {
 		kfree(info);
-		printk(KERN_ERR "comedi: error: ran out of minor numbers for board device files.\n");
+		printk(KERN_ERR
+		       "comedi: error: ran out of minor numbers for board device files.\n");
 		return -EBUSY;
 	}
 	s->minor = i;
@@ -2207,29 +2231,33 @@ int comedi_alloc_subdevice_minor(struct 
 	dev_set_drvdata(csdev, info);
 	retval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_max_read_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_max_read_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_read_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_read_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_read_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_max_write_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_max_write_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
 	}
 	retval = device_create_file(csdev, &dev_attr_write_buffer_kb);
 	if (retval) {
-		printk(KERN_ERR "comedi: failed to create sysfs attribute file \"%s\".\n",
-			dev_attr_write_buffer_kb.attr.name);
+		printk(KERN_ERR
+		       "comedi: failed to create sysfs attribute file \"%s\".\n",
+		       dev_attr_write_buffer_kb.attr.name);
 		comedi_free_subdevice_minor(s);
 		return retval;
 	}
@@ -2295,7 +2323,7 @@ static int resize_async_buffer(struct co
 		return -EINVAL;
 
 	/* make sure buffer is an integral number of pages
-		* (we round up) */
+	 * (we round up) */
 	new_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;
 
 	retval = comedi_buf_alloc(dev, s, new_size);
@@ -2324,16 +2352,16 @@ static ssize_t show_max_read_buffer_kb(s
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned max_buffer_size_kb = 0;
 	struct comedi_subdevice *const read_subdevice =
-					comedi_get_read_subdevice(info);
+	    comedi_get_read_subdevice(info);
 
 	mutex_lock(&info->device->mutex);
 	if (read_subdevice &&
 	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
 	    read_subdevice->async) {
 		max_buffer_size_kb = read_subdevice->async->max_bufsize /
-					bytes_per_kibi;
+		    bytes_per_kibi;
 	}
-	retval =  snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
 	mutex_unlock(&info->device->mutex);
 
 	return retval;
@@ -2347,14 +2375,14 @@ static ssize_t store_max_read_buffer_kb(
 	unsigned long new_max_size_kb;
 	uint64_t new_max_size;
 	struct comedi_subdevice *const read_subdevice =
-					comedi_get_read_subdevice(info);
+	    comedi_get_read_subdevice(info);
 
 	if (strict_strtoul(buf, 10, &new_max_size_kb))
 		return -EINVAL;
-	if (new_max_size_kb != (uint32_t)new_max_size_kb)
+	if (new_max_size_kb != (uint32_t) new_max_size_kb)
 		return -EINVAL;
-	new_max_size = ((uint64_t)new_max_size_kb) * bytes_per_kibi;
-	if (new_max_size != (uint32_t)new_max_size)
+	new_max_size = ((uint64_t) new_max_size_kb) * bytes_per_kibi;
+	if (new_max_size != (uint32_t) new_max_size)
 		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
@@ -2372,9 +2400,8 @@ static ssize_t store_max_read_buffer_kb(
 
 static struct device_attribute dev_attr_max_read_buffer_kb = {
 	.attr = {
-			.name = "max_read_buffer_kb",
-			.mode = S_IRUGO | S_IWUSR
-		},
+		 .name = "max_read_buffer_kb",
+		 .mode = S_IRUGO | S_IWUSR},
 	.show = &show_max_read_buffer_kb,
 	.store = &store_max_read_buffer_kb
 };
@@ -2386,16 +2413,16 @@ static ssize_t show_read_buffer_kb(struc
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned buffer_size_kb = 0;
 	struct comedi_subdevice *const read_subdevice =
-					comedi_get_read_subdevice(info);
+	    comedi_get_read_subdevice(info);
 
 	mutex_lock(&info->device->mutex);
 	if (read_subdevice &&
-		(read_subdevice->subdev_flags & SDF_CMD_READ) &&
-		read_subdevice->async) {
+	    (read_subdevice->subdev_flags & SDF_CMD_READ) &&
+	    read_subdevice->async) {
 		buffer_size_kb = read_subdevice->async->prealloc_bufsz /
-					bytes_per_kibi;
+		    bytes_per_kibi;
 	}
-	retval =  snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
 	mutex_unlock(&info->device->mutex);
 
 	return retval;
@@ -2410,14 +2437,14 @@ static ssize_t store_read_buffer_kb(stru
 	uint64_t new_size;
 	int retval;
 	struct comedi_subdevice *const read_subdevice =
-					comedi_get_read_subdevice(info);
+	    comedi_get_read_subdevice(info);
 
 	if (strict_strtoul(buf, 10, &new_size_kb))
 		return -EINVAL;
-	if (new_size_kb != (uint32_t)new_size_kb)
+	if (new_size_kb != (uint32_t) new_size_kb)
 		return -EINVAL;
-	new_size = ((uint64_t)new_size_kb) * bytes_per_kibi;
-	if (new_size != (uint32_t)new_size)
+	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
+	if (new_size != (uint32_t) new_size)
 		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
@@ -2438,9 +2465,8 @@ static ssize_t store_read_buffer_kb(stru
 
 static struct device_attribute dev_attr_read_buffer_kb = {
 	.attr = {
-			.name = "read_buffer_kb",
-			.mode = S_IRUGO | S_IWUSR | S_IWGRP
-		},
+		 .name = "read_buffer_kb",
+		 .mode = S_IRUGO | S_IWUSR | S_IWGRP},
 	.show = &show_read_buffer_kb,
 	.store = &store_read_buffer_kb
 };
@@ -2453,16 +2479,16 @@ static ssize_t show_max_write_buffer_kb(
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned max_buffer_size_kb = 0;
 	struct comedi_subdevice *const write_subdevice =
-					comedi_get_write_subdevice(info);
+	    comedi_get_write_subdevice(info);
 
 	mutex_lock(&info->device->mutex);
 	if (write_subdevice &&
 	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
 	    write_subdevice->async) {
 		max_buffer_size_kb = write_subdevice->async->max_bufsize /
-					bytes_per_kibi;
+		    bytes_per_kibi;
 	}
-	retval =  snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);
 	mutex_unlock(&info->device->mutex);
 
 	return retval;
@@ -2476,14 +2502,14 @@ static ssize_t store_max_write_buffer_kb
 	unsigned long new_max_size_kb;
 	uint64_t new_max_size;
 	struct comedi_subdevice *const write_subdevice =
-					comedi_get_write_subdevice(info);
+	    comedi_get_write_subdevice(info);
 
 	if (strict_strtoul(buf, 10, &new_max_size_kb))
 		return -EINVAL;
-	if (new_max_size_kb != (uint32_t)new_max_size_kb)
+	if (new_max_size_kb != (uint32_t) new_max_size_kb)
 		return -EINVAL;
-	new_max_size = ((uint64_t)new_max_size_kb) * bytes_per_kibi;
-	if (new_max_size != (uint32_t)new_max_size)
+	new_max_size = ((uint64_t) new_max_size_kb) * bytes_per_kibi;
+	if (new_max_size != (uint32_t) new_max_size)
 		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
@@ -2501,9 +2527,8 @@ static ssize_t store_max_write_buffer_kb
 
 static struct device_attribute dev_attr_max_write_buffer_kb = {
 	.attr = {
-			.name = "max_write_buffer_kb",
-			.mode = S_IRUGO | S_IWUSR
-		},
+		 .name = "max_write_buffer_kb",
+		 .mode = S_IRUGO | S_IWUSR},
 	.show = &show_max_write_buffer_kb,
 	.store = &store_max_write_buffer_kb
 };
@@ -2515,16 +2540,16 @@ static ssize_t show_write_buffer_kb(stru
 	struct comedi_device_file_info *info = dev_get_drvdata(dev);
 	unsigned buffer_size_kb = 0;
 	struct comedi_subdevice *const write_subdevice =
-					comedi_get_write_subdevice(info);
+	    comedi_get_write_subdevice(info);
 
 	mutex_lock(&info->device->mutex);
 	if (write_subdevice &&
 	    (write_subdevice->subdev_flags & SDF_CMD_WRITE) &&
 	    write_subdevice->async) {
 		buffer_size_kb = write_subdevice->async->prealloc_bufsz /
-					bytes_per_kibi;
+		    bytes_per_kibi;
 	}
-	retval =  snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
+	retval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);
 	mutex_unlock(&info->device->mutex);
 
 	return retval;
@@ -2539,14 +2564,14 @@ static ssize_t store_write_buffer_kb(str
 	uint64_t new_size;
 	int retval;
 	struct comedi_subdevice *const write_subdevice =
-					comedi_get_write_subdevice(info);
+	    comedi_get_write_subdevice(info);
 
 	if (strict_strtoul(buf, 10, &new_size_kb))
 		return -EINVAL;
-	if (new_size_kb != (uint32_t)new_size_kb)
+	if (new_size_kb != (uint32_t) new_size_kb)
 		return -EINVAL;
-	new_size = ((uint64_t)new_size_kb) * bytes_per_kibi;
-	if (new_size != (uint32_t)new_size)
+	new_size = ((uint64_t) new_size_kb) * bytes_per_kibi;
+	if (new_size != (uint32_t) new_size)
 		return -EINVAL;
 
 	mutex_lock(&info->device->mutex);
@@ -2557,7 +2582,7 @@ static ssize_t store_write_buffer_kb(str
 		return -EINVAL;
 	}
 	retval = resize_async_buffer(info->device, write_subdevice,
-		write_subdevice->async, new_size);
+				     write_subdevice->async, new_size);
 	mutex_unlock(&info->device->mutex);
 
 	if (retval < 0)
@@ -2567,9 +2592,8 @@ static ssize_t store_write_buffer_kb(str
 
 static struct device_attribute dev_attr_write_buffer_kb = {
 	.attr = {
-			.name = "write_buffer_kb",
-			.mode = S_IRUGO | S_IWUSR | S_IWGRP
-		},
+		 .name = "write_buffer_kb",
+		 .mode = S_IRUGO | S_IWUSR | S_IWGRP},
 	.show = &show_write_buffer_kb,
 	.store = &store_write_buffer_kb
 };
--- a/drivers/staging/comedi/comedi.h
+++ b/drivers/staging/comedi/comedi.h
@@ -121,10 +121,10 @@ extern "C" {
 #define TRIG_BOGUS	0x0001	/* do the motions */
 #define TRIG_DITHER	0x0002	/* enable dithering */
 #define TRIG_DEGLITCH	0x0004	/* enable deglitching */
-/*#define TRIG_RT       0x0008 */	/* perform op in real time */
+	/*#define TRIG_RT       0x0008 *//* perform op in real time */
 #define TRIG_CONFIG	0x0010	/* perform configuration, not triggering */
 #define TRIG_WAKE_EOS	0x0020	/* wake up on end-of-scan events */
-/*#define TRIG_WRITE    0x0040*/	/* write to bidirectional devices */
+	/*#define TRIG_WRITE    0x0040*//* write to bidirectional devices */
 
 /* command flags */
 /* These flags are used in comedi_cmd structures */
@@ -199,93 +199,91 @@ extern "C" {
 #define SDF_LSAMPL	0x10000000	/* subdevice uses 32-bit samples */
 #define SDF_PACKED	0x20000000	/* subdevice can do packed DIO */
 /* re recyle these flags for PWM */
-#define SDF_PWM_COUNTER SDF_MODE0       /* PWM can automatically switch off */
-#define SDF_PWM_HBRIDGE SDF_MODE1       /* PWM is signed (H-bridge) */
-
-
+#define SDF_PWM_COUNTER SDF_MODE0	/* PWM can automatically switch off */
+#define SDF_PWM_HBRIDGE SDF_MODE1	/* PWM is signed (H-bridge) */
 
 /* subdevice types */
 
-enum comedi_subdevice_type {
-	COMEDI_SUBD_UNUSED,	/* unused by driver */
-	COMEDI_SUBD_AI,	/* analog input */
-	COMEDI_SUBD_AO,	/* analog output */
-	COMEDI_SUBD_DI,	/* digital input */
-	COMEDI_SUBD_DO,	/* digital output */
-	COMEDI_SUBD_DIO,	/* digital input/output */
-	COMEDI_SUBD_COUNTER,	/* counter */
-	COMEDI_SUBD_TIMER,	/* timer */
-	COMEDI_SUBD_MEMORY,	/* memory, EEPROM, DPRAM */
-	COMEDI_SUBD_CALIB,	/* calibration DACs */
-	COMEDI_SUBD_PROC,	/* processor, DSP */
-	COMEDI_SUBD_SERIAL,	/* serial IO */
-	COMEDI_SUBD_PWM         /* PWM */
-};
+	enum comedi_subdevice_type {
+		COMEDI_SUBD_UNUSED,	/* unused by driver */
+		COMEDI_SUBD_AI,	/* analog input */
+		COMEDI_SUBD_AO,	/* analog output */
+		COMEDI_SUBD_DI,	/* digital input */
+		COMEDI_SUBD_DO,	/* digital output */
+		COMEDI_SUBD_DIO,	/* digital input/output */
+		COMEDI_SUBD_COUNTER,	/* counter */
+		COMEDI_SUBD_TIMER,	/* timer */
+		COMEDI_SUBD_MEMORY,	/* memory, EEPROM, DPRAM */
+		COMEDI_SUBD_CALIB,	/* calibration DACs */
+		COMEDI_SUBD_PROC,	/* processor, DSP */
+		COMEDI_SUBD_SERIAL,	/* serial IO */
+		COMEDI_SUBD_PWM	/* PWM */
+	};
 
 /* configuration instructions */
 
-enum configuration_ids {
-	INSN_CONFIG_DIO_INPUT = 0,
-	INSN_CONFIG_DIO_OUTPUT = 1,
-	INSN_CONFIG_DIO_OPENDRAIN = 2,
-	INSN_CONFIG_ANALOG_TRIG = 16,
+	enum configuration_ids {
+		INSN_CONFIG_DIO_INPUT = 0,
+		INSN_CONFIG_DIO_OUTPUT = 1,
+		INSN_CONFIG_DIO_OPENDRAIN = 2,
+		INSN_CONFIG_ANALOG_TRIG = 16,
 /*	INSN_CONFIG_WAVEFORM = 17, */
 /*	INSN_CONFIG_TRIG = 18, */
 /*	INSN_CONFIG_COUNTER = 19, */
-	INSN_CONFIG_ALT_SOURCE = 20,
-	INSN_CONFIG_DIGITAL_TRIG = 21,
-	INSN_CONFIG_BLOCK_SIZE = 22,
-	INSN_CONFIG_TIMER_1 = 23,
-	INSN_CONFIG_FILTER = 24,
-	INSN_CONFIG_CHANGE_NOTIFY = 25,
-
-	 /*ALPHA*/ INSN_CONFIG_SERIAL_CLOCK = 26,
-	INSN_CONFIG_BIDIRECTIONAL_DATA = 27,
-	INSN_CONFIG_DIO_QUERY = 28,
-	INSN_CONFIG_PWM_OUTPUT = 29,
-	INSN_CONFIG_GET_PWM_OUTPUT = 30,
-	INSN_CONFIG_ARM = 31,
-	INSN_CONFIG_DISARM = 32,
-	INSN_CONFIG_GET_COUNTER_STATUS = 33,
-	INSN_CONFIG_RESET = 34,
-	INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR = 1001,	/* Use CTR as single pulsegenerator */
-	INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR = 1002,	/* Use CTR as pulsetraingenerator */
-	INSN_CONFIG_GPCT_QUADRATURE_ENCODER = 1003,	/* Use the counter as encoder */
-	INSN_CONFIG_SET_GATE_SRC = 2001,	/* Set gate source */
-	INSN_CONFIG_GET_GATE_SRC = 2002,	/* Get gate source */
-	INSN_CONFIG_SET_CLOCK_SRC = 2003,	/* Set master clock source */
-	INSN_CONFIG_GET_CLOCK_SRC = 2004,	/* Get master clock source */
-	INSN_CONFIG_SET_OTHER_SRC = 2005,	/* Set other source */
-/*	INSN_CONFIG_GET_OTHER_SRC = 2006,*/	/* Get other source */
-	INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE = 2006,	/* Get size in bytes of
-							   subdevice's on-board
-							   fifos used during
-							   streaming
-							   input/output */
-	INSN_CONFIG_SET_COUNTER_MODE = 4097,
-	INSN_CONFIG_8254_SET_MODE = INSN_CONFIG_SET_COUNTER_MODE,	/* deprecated */
-	INSN_CONFIG_8254_READ_STATUS = 4098,
-	INSN_CONFIG_SET_ROUTING = 4099,
-	INSN_CONFIG_GET_ROUTING = 4109,
+		INSN_CONFIG_ALT_SOURCE = 20,
+		INSN_CONFIG_DIGITAL_TRIG = 21,
+		INSN_CONFIG_BLOCK_SIZE = 22,
+		INSN_CONFIG_TIMER_1 = 23,
+		INSN_CONFIG_FILTER = 24,
+		INSN_CONFIG_CHANGE_NOTIFY = 25,
+
+		 /*ALPHA*/ INSN_CONFIG_SERIAL_CLOCK = 26,
+		INSN_CONFIG_BIDIRECTIONAL_DATA = 27,
+		INSN_CONFIG_DIO_QUERY = 28,
+		INSN_CONFIG_PWM_OUTPUT = 29,
+		INSN_CONFIG_GET_PWM_OUTPUT = 30,
+		INSN_CONFIG_ARM = 31,
+		INSN_CONFIG_DISARM = 32,
+		INSN_CONFIG_GET_COUNTER_STATUS = 33,
+		INSN_CONFIG_RESET = 34,
+		INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR = 1001,	/* Use CTR as single pulsegenerator */
+		INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR = 1002,	/* Use CTR as pulsetraingenerator */
+		INSN_CONFIG_GPCT_QUADRATURE_ENCODER = 1003,	/* Use the counter as encoder */
+		INSN_CONFIG_SET_GATE_SRC = 2001,	/* Set gate source */
+		INSN_CONFIG_GET_GATE_SRC = 2002,	/* Get gate source */
+		INSN_CONFIG_SET_CLOCK_SRC = 2003,	/* Set master clock source */
+		INSN_CONFIG_GET_CLOCK_SRC = 2004,	/* Get master clock source */
+		INSN_CONFIG_SET_OTHER_SRC = 2005,	/* Set other source */
+		/*	INSN_CONFIG_GET_OTHER_SRC = 2006,*//* Get other source */
+		INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE = 2006,	/* Get size in bytes of
+								   subdevice's on-board
+								   fifos used during
+								   streaming
+								   input/output */
+		INSN_CONFIG_SET_COUNTER_MODE = 4097,
+		INSN_CONFIG_8254_SET_MODE = INSN_CONFIG_SET_COUNTER_MODE,	/* deprecated */
+		INSN_CONFIG_8254_READ_STATUS = 4098,
+		INSN_CONFIG_SET_ROUTING = 4099,
+		INSN_CONFIG_GET_ROUTING = 4109,
 /* PWM */
-	INSN_CONFIG_PWM_SET_PERIOD = 5000,   /* sets frequency */
-	INSN_CONFIG_PWM_GET_PERIOD = 5001,   /* gets frequency */
-	INSN_CONFIG_GET_PWM_STATUS = 5002,          /* is it running? */
-	INSN_CONFIG_PWM_SET_H_BRIDGE = 5003, /* sets H bridge: duty cycle and sign bit for a relay  at the same time*/
-	INSN_CONFIG_PWM_GET_H_BRIDGE = 5004  /* gets H bridge data: duty cycle and the sign bit */
-};
-
-enum comedi_io_direction {
-	COMEDI_INPUT = 0,
-	COMEDI_OUTPUT = 1,
-	COMEDI_OPENDRAIN = 2
-};
-
-enum comedi_support_level {
-	COMEDI_UNKNOWN_SUPPORT = 0,
-	COMEDI_SUPPORTED,
-	COMEDI_UNSUPPORTED
-};
+		INSN_CONFIG_PWM_SET_PERIOD = 5000,	/* sets frequency */
+		INSN_CONFIG_PWM_GET_PERIOD = 5001,	/* gets frequency */
+		INSN_CONFIG_GET_PWM_STATUS = 5002,	/* is it running? */
+		INSN_CONFIG_PWM_SET_H_BRIDGE = 5003,	/* sets H bridge: duty cycle and sign bit for a relay  at the same time */
+		INSN_CONFIG_PWM_GET_H_BRIDGE = 5004	/* gets H bridge data: duty cycle and the sign bit */
+	};
+
+	enum comedi_io_direction {
+		COMEDI_INPUT = 0,
+		COMEDI_OUTPUT = 1,
+		COMEDI_OPENDRAIN = 2
+	};
+
+	enum comedi_support_level {
+		COMEDI_UNKNOWN_SUPPORT = 0,
+		COMEDI_SUPPORTED,
+		COMEDI_UNSUPPORTED
+	};
 
 /* ioctls */
 
@@ -309,133 +307,132 @@ enum comedi_support_level {
 
 /* structures */
 
-struct comedi_trig {
-	unsigned int subdev;	/* subdevice */
-	unsigned int mode;	/* mode */
-	unsigned int flags;
-	unsigned int n_chan;	/* number of channels */
-	unsigned int *chanlist;	/* channel/range list */
-	short *data;	/* data list, size depends on subd flags */
-	unsigned int n;	/* number of scans */
-	unsigned int trigsrc;
-	unsigned int trigvar;
-	unsigned int trigvar1;
-	unsigned int data_len;
-	unsigned int unused[3];
-};
-
-struct comedi_insn {
-	unsigned int insn;
-	unsigned int n;
-	unsigned int *data;
-	unsigned int subdev;
-	unsigned int chanspec;
-	unsigned int unused[3];
-};
-
-struct comedi_insnlist {
-	unsigned int n_insns;
-	struct comedi_insn *insns;
-};
-
-struct comedi_cmd {
-	unsigned int subdev;
-	unsigned int flags;
-
-	unsigned int start_src;
-	unsigned int start_arg;
-
-	unsigned int scan_begin_src;
-	unsigned int scan_begin_arg;
-
-	unsigned int convert_src;
-	unsigned int convert_arg;
-
-	unsigned int scan_end_src;
-	unsigned int scan_end_arg;
-
-	unsigned int stop_src;
-	unsigned int stop_arg;
-
-	unsigned int *chanlist;	/* channel/range list */
-	unsigned int chanlist_len;
-
-	short *data;	/* data list, size depends on subd flags */
-	unsigned int data_len;
-};
-
-struct comedi_chaninfo {
-	unsigned int subdev;
-	unsigned int *maxdata_list;
-	unsigned int *flaglist;
-	unsigned int *rangelist;
-	unsigned int unused[4];
-};
-
-struct comedi_rangeinfo {
-	unsigned int range_type;
-	void *range_ptr;
-};
-
-struct comedi_krange {
-	int min;	/* fixed point, multiply by 1e-6 */
-	int max;	/* fixed point, multiply by 1e-6 */
-	unsigned int flags;
-};
-
-
-struct comedi_subdinfo {
-	unsigned int type;
-	unsigned int n_chan;
-	unsigned int subd_flags;
-	unsigned int timer_type;
-	unsigned int len_chanlist;
-	unsigned int maxdata;
-	unsigned int flags;	/* channel flags */
-	unsigned int range_type;	/* lookup in kernel */
-	unsigned int settling_time_0;
-	unsigned insn_bits_support;	/* see support_level enum for values*/
-	unsigned int unused[8];
-};
-
-struct comedi_devinfo {
-	unsigned int version_code;
-	unsigned int n_subdevs;
-	char driver_name[COMEDI_NAMELEN];
-	char board_name[COMEDI_NAMELEN];
-	int read_subdevice;
-	int write_subdevice;
-	int unused[30];
-};
-
-struct comedi_devconfig {
-	char board_name[COMEDI_NAMELEN];
-	int options[COMEDI_NDEVCONFOPTS];
-};
-
-struct comedi_bufconfig {
-	unsigned int subdevice;
-	unsigned int flags;
-
-	unsigned int maximum_size;
-	unsigned int size;
-
-	unsigned int unused[4];
-};
-
-struct comedi_bufinfo {
-	unsigned int subdevice;
-	unsigned int bytes_read;
-
-	unsigned int buf_write_ptr;
-	unsigned int buf_read_ptr;
-	unsigned int buf_write_count;
-	unsigned int buf_read_count;
+	struct comedi_trig {
+		unsigned int subdev;	/* subdevice */
+		unsigned int mode;	/* mode */
+		unsigned int flags;
+		unsigned int n_chan;	/* number of channels */
+		unsigned int *chanlist;	/* channel/range list */
+		short *data;	/* data list, size depends on subd flags */
+		unsigned int n;	/* number of scans */
+		unsigned int trigsrc;
+		unsigned int trigvar;
+		unsigned int trigvar1;
+		unsigned int data_len;
+		unsigned int unused[3];
+	};
+
+	struct comedi_insn {
+		unsigned int insn;
+		unsigned int n;
+		unsigned int *data;
+		unsigned int subdev;
+		unsigned int chanspec;
+		unsigned int unused[3];
+	};
+
+	struct comedi_insnlist {
+		unsigned int n_insns;
+		struct comedi_insn *insns;
+	};
+
+	struct comedi_cmd {
+		unsigned int subdev;
+		unsigned int flags;
+
+		unsigned int start_src;
+		unsigned int start_arg;
+
+		unsigned int scan_begin_src;
+		unsigned int scan_begin_arg;
+
+		unsigned int convert_src;
+		unsigned int convert_arg;
+
+		unsigned int scan_end_src;
+		unsigned int scan_end_arg;
+
+		unsigned int stop_src;
+		unsigned int stop_arg;
+
+		unsigned int *chanlist;	/* channel/range list */
+		unsigned int chanlist_len;
+
+		short *data;	/* data list, size depends on subd flags */
+		unsigned int data_len;
+	};
+
+	struct comedi_chaninfo {
+		unsigned int subdev;
+		unsigned int *maxdata_list;
+		unsigned int *flaglist;
+		unsigned int *rangelist;
+		unsigned int unused[4];
+	};
+
+	struct comedi_rangeinfo {
+		unsigned int range_type;
+		void *range_ptr;
+	};
+
+	struct comedi_krange {
+		int min;	/* fixed point, multiply by 1e-6 */
+		int max;	/* fixed point, multiply by 1e-6 */
+		unsigned int flags;
+	};
+
+	struct comedi_subdinfo {
+		unsigned int type;
+		unsigned int n_chan;
+		unsigned int subd_flags;
+		unsigned int timer_type;
+		unsigned int len_chanlist;
+		unsigned int maxdata;
+		unsigned int flags;	/* channel flags */
+		unsigned int range_type;	/* lookup in kernel */
+		unsigned int settling_time_0;
+		unsigned insn_bits_support;	/* see support_level enum for values */
+		unsigned int unused[8];
+	};
+
+	struct comedi_devinfo {
+		unsigned int version_code;
+		unsigned int n_subdevs;
+		char driver_name[COMEDI_NAMELEN];
+		char board_name[COMEDI_NAMELEN];
+		int read_subdevice;
+		int write_subdevice;
+		int unused[30];
+	};
+
+	struct comedi_devconfig {
+		char board_name[COMEDI_NAMELEN];
+		int options[COMEDI_NDEVCONFOPTS];
+	};
+
+	struct comedi_bufconfig {
+		unsigned int subdevice;
+		unsigned int flags;
+
+		unsigned int maximum_size;
+		unsigned int size;
+
+		unsigned int unused[4];
+	};
+
+	struct comedi_bufinfo {
+		unsigned int subdevice;
+		unsigned int bytes_read;
+
+		unsigned int buf_write_ptr;
+		unsigned int buf_read_ptr;
+		unsigned int buf_write_count;
+		unsigned int buf_read_count;
 
-	unsigned int bytes_written;
+		unsigned int bytes_written;
 
-	unsigned int unused[4];
-};
+		unsigned int unused[4];
+	};
 
 /* range stuff */
 
@@ -486,298 +483,284 @@ struct comedi_bufinfo {
 
 */
 
-enum i8254_mode {
-	I8254_MODE0 = (0 << 1),	/* Interrupt on terminal count */
-	I8254_MODE1 = (1 << 1),	/* Hardware retriggerable one-shot */
-	I8254_MODE2 = (2 << 1),	/* Rate generator */
-	I8254_MODE3 = (3 << 1),	/* Square wave mode */
-	I8254_MODE4 = (4 << 1),	/* Software triggered strobe */
-	I8254_MODE5 = (5 << 1),	/* Hardware triggered strobe (retriggerable) */
-	I8254_BCD = 1,	/* use binary-coded decimal instead of binary (pretty useless) */
-	I8254_BINARY = 0
-};
-
-static inline unsigned NI_USUAL_PFI_SELECT(unsigned pfi_channel)
-{
-	if (pfi_channel < 10)
-		return 0x1 + pfi_channel;
-	else
-		return 0xb + pfi_channel;
-}
-static inline unsigned NI_USUAL_RTSI_SELECT(unsigned rtsi_channel)
-{
-	if (rtsi_channel < 7)
-		return 0xb + rtsi_channel;
-	else
-		return 0x1b;
-}
+	enum i8254_mode {
+		I8254_MODE0 = (0 << 1),	/* Interrupt on terminal count */
+		I8254_MODE1 = (1 << 1),	/* Hardware retriggerable one-shot */
+		I8254_MODE2 = (2 << 1),	/* Rate generator */
+		I8254_MODE3 = (3 << 1),	/* Square wave mode */
+		I8254_MODE4 = (4 << 1),	/* Software triggered strobe */
+		I8254_MODE5 = (5 << 1),	/* Hardware triggered strobe (retriggerable) */
+		I8254_BCD = 1,	/* use binary-coded decimal instead of binary (pretty useless) */
+		I8254_BINARY = 0
+	};
+
+	static inline unsigned NI_USUAL_PFI_SELECT(unsigned pfi_channel) {
+		if (pfi_channel < 10)
+			return 0x1 + pfi_channel;
+		else
+			return 0xb + pfi_channel;
+	} static inline unsigned NI_USUAL_RTSI_SELECT(unsigned rtsi_channel) {
+		if (rtsi_channel < 7)
+			return 0xb + rtsi_channel;
+		else
+			return 0x1b;
+	}
 /* mode bits for NI general-purpose counters, set with
  * INSN_CONFIG_SET_COUNTER_MODE */
 #define NI_GPCT_COUNTING_MODE_SHIFT 16
 #define NI_GPCT_INDEX_PHASE_BITSHIFT 20
 #define NI_GPCT_COUNTING_DIRECTION_SHIFT 24
-enum ni_gpct_mode_bits {
-	NI_GPCT_GATE_ON_BOTH_EDGES_BIT = 0x4,
-	NI_GPCT_EDGE_GATE_MODE_MASK = 0x18,
-	NI_GPCT_EDGE_GATE_STARTS_STOPS_BITS = 0x0,
-	NI_GPCT_EDGE_GATE_STOPS_STARTS_BITS = 0x8,
-	NI_GPCT_EDGE_GATE_STARTS_BITS = 0x10,
-	NI_GPCT_EDGE_GATE_NO_STARTS_NO_STOPS_BITS = 0x18,
-	NI_GPCT_STOP_MODE_MASK = 0x60,
-	NI_GPCT_STOP_ON_GATE_BITS = 0x00,
-	NI_GPCT_STOP_ON_GATE_OR_TC_BITS = 0x20,
-	NI_GPCT_STOP_ON_GATE_OR_SECOND_TC_BITS = 0x40,
-	NI_GPCT_LOAD_B_SELECT_BIT = 0x80,
-	NI_GPCT_OUTPUT_MODE_MASK = 0x300,
-	NI_GPCT_OUTPUT_TC_PULSE_BITS = 0x100,
-	NI_GPCT_OUTPUT_TC_TOGGLE_BITS = 0x200,
-	NI_GPCT_OUTPUT_TC_OR_GATE_TOGGLE_BITS = 0x300,
-	NI_GPCT_HARDWARE_DISARM_MASK = 0xc00,
-	NI_GPCT_NO_HARDWARE_DISARM_BITS = 0x000,
-	NI_GPCT_DISARM_AT_TC_BITS = 0x400,
-	NI_GPCT_DISARM_AT_GATE_BITS = 0x800,
-	NI_GPCT_DISARM_AT_TC_OR_GATE_BITS = 0xc00,
-	NI_GPCT_LOADING_ON_TC_BIT = 0x1000,
-	NI_GPCT_LOADING_ON_GATE_BIT = 0x4000,
-	NI_GPCT_COUNTING_MODE_MASK = 0x7 << NI_GPCT_COUNTING_MODE_SHIFT,
-	NI_GPCT_COUNTING_MODE_NORMAL_BITS =
-		0x0 << NI_GPCT_COUNTING_MODE_SHIFT,
-	NI_GPCT_COUNTING_MODE_QUADRATURE_X1_BITS =
-		0x1 << NI_GPCT_COUNTING_MODE_SHIFT,
-	NI_GPCT_COUNTING_MODE_QUADRATURE_X2_BITS =
-		0x2 << NI_GPCT_COUNTING_MODE_SHIFT,
-	NI_GPCT_COUNTING_MODE_QUADRATURE_X4_BITS =
-		0x3 << NI_GPCT_COUNTING_MODE_SHIFT,
-	NI_GPCT_COUNTING_MODE_TWO_PULSE_BITS =
-		0x4 << NI_GPCT_COUNTING_MODE_SHIFT,
-	NI_GPCT_COUNTING_MODE_SYNC_SOURCE_BITS =
-		0x6 << NI_GPCT_COUNTING_MODE_SHIFT,
-	NI_GPCT_INDEX_PHASE_MASK = 0x3 << NI_GPCT_INDEX_PHASE_BITSHIFT,
-	NI_GPCT_INDEX_PHASE_LOW_A_LOW_B_BITS =
-		0x0 << NI_GPCT_INDEX_PHASE_BITSHIFT,
-	NI_GPCT_INDEX_PHASE_LOW_A_HIGH_B_BITS =
-		0x1 << NI_GPCT_INDEX_PHASE_BITSHIFT,
-	NI_GPCT_INDEX_PHASE_HIGH_A_LOW_B_BITS =
-		0x2 << NI_GPCT_INDEX_PHASE_BITSHIFT,
-	NI_GPCT_INDEX_PHASE_HIGH_A_HIGH_B_BITS =
-		0x3 << NI_GPCT_INDEX_PHASE_BITSHIFT,
-	NI_GPCT_INDEX_ENABLE_BIT = 0x400000,
-	NI_GPCT_COUNTING_DIRECTION_MASK =
-		0x3 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
-	NI_GPCT_COUNTING_DIRECTION_DOWN_BITS =
-		0x00 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
-	NI_GPCT_COUNTING_DIRECTION_UP_BITS =
-		0x1 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
-	NI_GPCT_COUNTING_DIRECTION_HW_UP_DOWN_BITS =
-		0x2 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
-	NI_GPCT_COUNTING_DIRECTION_HW_GATE_BITS =
-		0x3 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
-	NI_GPCT_RELOAD_SOURCE_MASK = 0xc000000,
-	NI_GPCT_RELOAD_SOURCE_FIXED_BITS = 0x0,
-	NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS = 0x4000000,
-	NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS = 0x8000000,
-	NI_GPCT_OR_GATE_BIT = 0x10000000,
-	NI_GPCT_INVERT_OUTPUT_BIT = 0x20000000
-};
+	enum ni_gpct_mode_bits {
+		NI_GPCT_GATE_ON_BOTH_EDGES_BIT = 0x4,
+		NI_GPCT_EDGE_GATE_MODE_MASK = 0x18,
+		NI_GPCT_EDGE_GATE_STARTS_STOPS_BITS = 0x0,
+		NI_GPCT_EDGE_GATE_STOPS_STARTS_BITS = 0x8,
+		NI_GPCT_EDGE_GATE_STARTS_BITS = 0x10,
+		NI_GPCT_EDGE_GATE_NO_STARTS_NO_STOPS_BITS = 0x18,
+		NI_GPCT_STOP_MODE_MASK = 0x60,
+		NI_GPCT_STOP_ON_GATE_BITS = 0x00,
+		NI_GPCT_STOP_ON_GATE_OR_TC_BITS = 0x20,
+		NI_GPCT_STOP_ON_GATE_OR_SECOND_TC_BITS = 0x40,
+		NI_GPCT_LOAD_B_SELECT_BIT = 0x80,
+		NI_GPCT_OUTPUT_MODE_MASK = 0x300,
+		NI_GPCT_OUTPUT_TC_PULSE_BITS = 0x100,
+		NI_GPCT_OUTPUT_TC_TOGGLE_BITS = 0x200,
+		NI_GPCT_OUTPUT_TC_OR_GATE_TOGGLE_BITS = 0x300,
+		NI_GPCT_HARDWARE_DISARM_MASK = 0xc00,
+		NI_GPCT_NO_HARDWARE_DISARM_BITS = 0x000,
+		NI_GPCT_DISARM_AT_TC_BITS = 0x400,
+		NI_GPCT_DISARM_AT_GATE_BITS = 0x800,
+		NI_GPCT_DISARM_AT_TC_OR_GATE_BITS = 0xc00,
+		NI_GPCT_LOADING_ON_TC_BIT = 0x1000,
+		NI_GPCT_LOADING_ON_GATE_BIT = 0x4000,
+		NI_GPCT_COUNTING_MODE_MASK = 0x7 << NI_GPCT_COUNTING_MODE_SHIFT,
+		NI_GPCT_COUNTING_MODE_NORMAL_BITS =
+		    0x0 << NI_GPCT_COUNTING_MODE_SHIFT,
+		NI_GPCT_COUNTING_MODE_QUADRATURE_X1_BITS =
+		    0x1 << NI_GPCT_COUNTING_MODE_SHIFT,
+		NI_GPCT_COUNTING_MODE_QUADRATURE_X2_BITS =
+		    0x2 << NI_GPCT_COUNTING_MODE_SHIFT,
+		NI_GPCT_COUNTING_MODE_QUADRATURE_X4_BITS =
+		    0x3 << NI_GPCT_COUNTING_MODE_SHIFT,
+		NI_GPCT_COUNTING_MODE_TWO_PULSE_BITS =
+		    0x4 << NI_GPCT_COUNTING_MODE_SHIFT,
+		NI_GPCT_COUNTING_MODE_SYNC_SOURCE_BITS =
+		    0x6 << NI_GPCT_COUNTING_MODE_SHIFT,
+		NI_GPCT_INDEX_PHASE_MASK = 0x3 << NI_GPCT_INDEX_PHASE_BITSHIFT,
+		NI_GPCT_INDEX_PHASE_LOW_A_LOW_B_BITS =
+		    0x0 << NI_GPCT_INDEX_PHASE_BITSHIFT,
+		NI_GPCT_INDEX_PHASE_LOW_A_HIGH_B_BITS =
+		    0x1 << NI_GPCT_INDEX_PHASE_BITSHIFT,
+		NI_GPCT_INDEX_PHASE_HIGH_A_LOW_B_BITS =
+		    0x2 << NI_GPCT_INDEX_PHASE_BITSHIFT,
+		NI_GPCT_INDEX_PHASE_HIGH_A_HIGH_B_BITS =
+		    0x3 << NI_GPCT_INDEX_PHASE_BITSHIFT,
+		NI_GPCT_INDEX_ENABLE_BIT = 0x400000,
+		NI_GPCT_COUNTING_DIRECTION_MASK =
+		    0x3 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
+		NI_GPCT_COUNTING_DIRECTION_DOWN_BITS =
+		    0x00 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
+		NI_GPCT_COUNTING_DIRECTION_UP_BITS =
+		    0x1 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
+		NI_GPCT_COUNTING_DIRECTION_HW_UP_DOWN_BITS =
+		    0x2 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
+		NI_GPCT_COUNTING_DIRECTION_HW_GATE_BITS =
+		    0x3 << NI_GPCT_COUNTING_DIRECTION_SHIFT,
+		NI_GPCT_RELOAD_SOURCE_MASK = 0xc000000,
+		NI_GPCT_RELOAD_SOURCE_FIXED_BITS = 0x0,
+		NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS = 0x4000000,
+		NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS = 0x8000000,
+		NI_GPCT_OR_GATE_BIT = 0x10000000,
+		NI_GPCT_INVERT_OUTPUT_BIT = 0x20000000
+	};
 
 /* Bits for setting a clock source with
  * INSN_CONFIG_SET_CLOCK_SRC when using NI general-purpose counters. */
-enum ni_gpct_clock_source_bits {
-	NI_GPCT_CLOCK_SRC_SELECT_MASK = 0x3f,
-	NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS = 0x0,
-	NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS = 0x1,
-	NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS = 0x2,
-	NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS = 0x3,
-	NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS = 0x4,
-	NI_GPCT_NEXT_TC_CLOCK_SRC_BITS = 0x5,
-	NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS = 0x6,	/* NI 660x-specific */
-	NI_GPCT_PXI10_CLOCK_SRC_BITS = 0x7,
-	NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS = 0x8,
-	NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS = 0x9,
-	NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK = 0x30000000,
-	NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS = 0x0,
-	NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS = 0x10000000, /* divide source by 2 */
-	NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS = 0x20000000, /* divide source by 8 */
-	NI_GPCT_INVERT_CLOCK_SRC_BIT = 0x80000000
-};
-static inline unsigned NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(unsigned n)
-{
-	/* NI 660x-specific */
-	return 0x10 + n;
-}
-static inline unsigned NI_GPCT_RTSI_CLOCK_SRC_BITS(unsigned n)
-{
-	return 0x18 + n;
-}
-static inline unsigned NI_GPCT_PFI_CLOCK_SRC_BITS(unsigned n)
-{
-	/* no pfi on NI 660x */
-	return 0x20 + n;
-}
+	enum ni_gpct_clock_source_bits {
+		NI_GPCT_CLOCK_SRC_SELECT_MASK = 0x3f,
+		NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS = 0x0,
+		NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS = 0x1,
+		NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS = 0x2,
+		NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS = 0x3,
+		NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS = 0x4,
+		NI_GPCT_NEXT_TC_CLOCK_SRC_BITS = 0x5,
+		NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS = 0x6,	/* NI 660x-specific */
+		NI_GPCT_PXI10_CLOCK_SRC_BITS = 0x7,
+		NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS = 0x8,
+		NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS = 0x9,
+		NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK = 0x30000000,
+		NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS = 0x0,
+		NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS = 0x10000000,	/* divide source by 2 */
+		NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS = 0x20000000,	/* divide source by 8 */
+		NI_GPCT_INVERT_CLOCK_SRC_BIT = 0x80000000
+	};
+	static inline unsigned NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(unsigned n) {
+		/* NI 660x-specific */
+		return 0x10 + n;
+	}
+	static inline unsigned NI_GPCT_RTSI_CLOCK_SRC_BITS(unsigned n) {
+		return 0x18 + n;
+	}
+	static inline unsigned NI_GPCT_PFI_CLOCK_SRC_BITS(unsigned n) {
+		/* no pfi on NI 660x */
+		return 0x20 + n;
+	}
 
 /* Possibilities for setting a gate source with
 INSN_CONFIG_SET_GATE_SRC when using NI general-purpose counters.
 May be bitwise-or'd with CR_EDGE or CR_INVERT. */
-enum ni_gpct_gate_select {
-	/* m-series gates */
-	NI_GPCT_TIMESTAMP_MUX_GATE_SELECT = 0x0,
-	NI_GPCT_AI_START2_GATE_SELECT = 0x12,
-	NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT = 0x13,
-	NI_GPCT_NEXT_OUT_GATE_SELECT = 0x14,
-	NI_GPCT_AI_START1_GATE_SELECT = 0x1c,
-	NI_GPCT_NEXT_SOURCE_GATE_SELECT = 0x1d,
-	NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT = 0x1e,
-	NI_GPCT_LOGIC_LOW_GATE_SELECT = 0x1f,
-	/* more gates for 660x */
-	NI_GPCT_SOURCE_PIN_i_GATE_SELECT = 0x100,
-	NI_GPCT_GATE_PIN_i_GATE_SELECT = 0x101,
-	/* more gates for 660x "second gate" */
-	NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT = 0x201,
-	NI_GPCT_SELECTED_GATE_GATE_SELECT = 0x21e,
-	/* m-series "second gate" sources are unknown,
-	   we should add them here with an offset of 0x300 when known. */
-	NI_GPCT_DISABLED_GATE_SELECT = 0x8000,
-};
-static inline unsigned NI_GPCT_GATE_PIN_GATE_SELECT(unsigned n)
-{
-	return 0x102 + n;
-}
-static inline unsigned NI_GPCT_RTSI_GATE_SELECT(unsigned n)
-{
-	return NI_USUAL_RTSI_SELECT(n);
-}
-static inline unsigned NI_GPCT_PFI_GATE_SELECT(unsigned n)
-{
-	return NI_USUAL_PFI_SELECT(n);
-}
-static inline unsigned NI_GPCT_UP_DOWN_PIN_GATE_SELECT(unsigned n)
-{
-	return 0x202 + n;
-}
+	enum ni_gpct_gate_select {
+		/* m-series gates */
+		NI_GPCT_TIMESTAMP_MUX_GATE_SELECT = 0x0,
+		NI_GPCT_AI_START2_GATE_SELECT = 0x12,
+		NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT = 0x13,
+		NI_GPCT_NEXT_OUT_GATE_SELECT = 0x14,
+		NI_GPCT_AI_START1_GATE_SELECT = 0x1c,
+		NI_GPCT_NEXT_SOURCE_GATE_SELECT = 0x1d,
+		NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT = 0x1e,
+		NI_GPCT_LOGIC_LOW_GATE_SELECT = 0x1f,
+		/* more gates for 660x */
+		NI_GPCT_SOURCE_PIN_i_GATE_SELECT = 0x100,
+		NI_GPCT_GATE_PIN_i_GATE_SELECT = 0x101,
+		/* more gates for 660x "second gate" */
+		NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT = 0x201,
+		NI_GPCT_SELECTED_GATE_GATE_SELECT = 0x21e,
+		/* m-series "second gate" sources are unknown,
+		   we should add them here with an offset of 0x300 when known. */
+		NI_GPCT_DISABLED_GATE_SELECT = 0x8000,
+	};
+	static inline unsigned NI_GPCT_GATE_PIN_GATE_SELECT(unsigned n) {
+		return 0x102 + n;
+	}
+	static inline unsigned NI_GPCT_RTSI_GATE_SELECT(unsigned n) {
+		return NI_USUAL_RTSI_SELECT(n);
+	}
+	static inline unsigned NI_GPCT_PFI_GATE_SELECT(unsigned n) {
+		return NI_USUAL_PFI_SELECT(n);
+	}
+	static inline unsigned NI_GPCT_UP_DOWN_PIN_GATE_SELECT(unsigned n) {
+		return 0x202 + n;
+	}
 
 /* Possibilities for setting a source with
 INSN_CONFIG_SET_OTHER_SRC when using NI general-purpose counters. */
-enum ni_gpct_other_index {
-	NI_GPCT_SOURCE_ENCODER_A,
-	NI_GPCT_SOURCE_ENCODER_B,
-	NI_GPCT_SOURCE_ENCODER_Z
-};
-enum ni_gpct_other_select {
-	/* m-series gates */
-	/* Still unknown, probably only need NI_GPCT_PFI_OTHER_SELECT */
-	NI_GPCT_DISABLED_OTHER_SELECT = 0x8000,
-};
-static inline unsigned NI_GPCT_PFI_OTHER_SELECT(unsigned n)
-{
-	return NI_USUAL_PFI_SELECT(n);
-}
+	enum ni_gpct_other_index {
+		NI_GPCT_SOURCE_ENCODER_A,
+		NI_GPCT_SOURCE_ENCODER_B,
+		NI_GPCT_SOURCE_ENCODER_Z
+	};
+	enum ni_gpct_other_select {
+		/* m-series gates */
+		/* Still unknown, probably only need NI_GPCT_PFI_OTHER_SELECT */
+		NI_GPCT_DISABLED_OTHER_SELECT = 0x8000,
+	};
+	static inline unsigned NI_GPCT_PFI_OTHER_SELECT(unsigned n) {
+		return NI_USUAL_PFI_SELECT(n);
+	}
 
 /* start sources for ni general-purpose counters for use with
 INSN_CONFIG_ARM */
-enum ni_gpct_arm_source {
-	NI_GPCT_ARM_IMMEDIATE = 0x0,
-	NI_GPCT_ARM_PAIRED_IMMEDIATE = 0x1,	/* Start both the counter and
-						   the adjacent paired counter
-						   simultaneously */
-	/* NI doesn't document bits for selecting hardware arm triggers.  If
-	 * the NI_GPCT_ARM_UNKNOWN bit is set, we will pass the least
-	 * significant bits (3 bits for 660x or 5 bits for m-series) through to
-	 * the hardware.  This will at least allow someone to figure out what
-	 * the bits do later. */
-	NI_GPCT_ARM_UNKNOWN = 0x1000,
-};
+	enum ni_gpct_arm_source {
+		NI_GPCT_ARM_IMMEDIATE = 0x0,
+		NI_GPCT_ARM_PAIRED_IMMEDIATE = 0x1,	/* Start both the counter and
+							   the adjacent paired counter
+							   simultaneously */
+		/* NI doesn't document bits for selecting hardware arm triggers.  If
+		 * the NI_GPCT_ARM_UNKNOWN bit is set, we will pass the least
+		 * significant bits (3 bits for 660x or 5 bits for m-series) through to
+		 * the hardware.  This will at least allow someone to figure out what
+		 * the bits do later. */
+		NI_GPCT_ARM_UNKNOWN = 0x1000,
+	};
 
 /* digital filtering options for ni 660x for use with INSN_CONFIG_FILTER. */
-enum ni_gpct_filter_select {
-	NI_GPCT_FILTER_OFF = 0x0,
-	NI_GPCT_FILTER_TIMEBASE_3_SYNC = 0x1,
-	NI_GPCT_FILTER_100x_TIMEBASE_1 = 0x2,
-	NI_GPCT_FILTER_20x_TIMEBASE_1 = 0x3,
-	NI_GPCT_FILTER_10x_TIMEBASE_1 = 0x4,
-	NI_GPCT_FILTER_2x_TIMEBASE_1 = 0x5,
-	NI_GPCT_FILTER_2x_TIMEBASE_3 = 0x6
-};
+	enum ni_gpct_filter_select {
+		NI_GPCT_FILTER_OFF = 0x0,
+		NI_GPCT_FILTER_TIMEBASE_3_SYNC = 0x1,
+		NI_GPCT_FILTER_100x_TIMEBASE_1 = 0x2,
+		NI_GPCT_FILTER_20x_TIMEBASE_1 = 0x3,
+		NI_GPCT_FILTER_10x_TIMEBASE_1 = 0x4,
+		NI_GPCT_FILTER_2x_TIMEBASE_1 = 0x5,
+		NI_GPCT_FILTER_2x_TIMEBASE_3 = 0x6
+	};
 
 /* PFI digital filtering options for ni m-series for use with
  * INSN_CONFIG_FILTER. */
-enum ni_pfi_filter_select {
-	NI_PFI_FILTER_OFF = 0x0,
-	NI_PFI_FILTER_125ns = 0x1,
-	NI_PFI_FILTER_6425ns = 0x2,
-	NI_PFI_FILTER_2550us = 0x3
-};
+	enum ni_pfi_filter_select {
+		NI_PFI_FILTER_OFF = 0x0,
+		NI_PFI_FILTER_125ns = 0x1,
+		NI_PFI_FILTER_6425ns = 0x2,
+		NI_PFI_FILTER_2550us = 0x3
+	};
 
 /* master clock sources for ni mio boards and INSN_CONFIG_SET_CLOCK_SRC */
-enum ni_mio_clock_source {
-	NI_MIO_INTERNAL_CLOCK = 0,
-	NI_MIO_RTSI_CLOCK = 1,	/* doesn't work for m-series, use
-				   NI_MIO_PLL_RTSI_CLOCK() */
-	/* the NI_MIO_PLL_* sources are m-series only */
-	NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK = 2,
-	NI_MIO_PLL_PXI10_CLOCK = 3,
-	NI_MIO_PLL_RTSI0_CLOCK = 4
-};
-static inline unsigned NI_MIO_PLL_RTSI_CLOCK(unsigned rtsi_channel)
-{
-	return NI_MIO_PLL_RTSI0_CLOCK + rtsi_channel;
-}
+	enum ni_mio_clock_source {
+		NI_MIO_INTERNAL_CLOCK = 0,
+		NI_MIO_RTSI_CLOCK = 1,	/* doesn't work for m-series, use
+					   NI_MIO_PLL_RTSI_CLOCK() */
+		/* the NI_MIO_PLL_* sources are m-series only */
+		NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK = 2,
+		NI_MIO_PLL_PXI10_CLOCK = 3,
+		NI_MIO_PLL_RTSI0_CLOCK = 4
+	};
+	static inline unsigned NI_MIO_PLL_RTSI_CLOCK(unsigned rtsi_channel) {
+		return NI_MIO_PLL_RTSI0_CLOCK + rtsi_channel;
+	}
 
 /* Signals which can be routed to an NI RTSI pin with INSN_CONFIG_SET_ROUTING.
  The numbers assigned are not arbitrary, they correspond to the bits required
  to program the board. */
-enum ni_rtsi_routing {
-	NI_RTSI_OUTPUT_ADR_START1 = 0,
-	NI_RTSI_OUTPUT_ADR_START2 = 1,
-	NI_RTSI_OUTPUT_SCLKG = 2,
-	NI_RTSI_OUTPUT_DACUPDN = 3,
-	NI_RTSI_OUTPUT_DA_START1 = 4,
-	NI_RTSI_OUTPUT_G_SRC0 = 5,
-	NI_RTSI_OUTPUT_G_GATE0 = 6,
-	NI_RTSI_OUTPUT_RGOUT0 = 7,
-	NI_RTSI_OUTPUT_RTSI_BRD_0 = 8,
-	NI_RTSI_OUTPUT_RTSI_OSC = 12	/* pre-m-series always have RTSI clock
-					   on line 7 */
-};
-static inline unsigned NI_RTSI_OUTPUT_RTSI_BRD(unsigned n)
-{
-	return NI_RTSI_OUTPUT_RTSI_BRD_0 + n;
-}
+	enum ni_rtsi_routing {
+		NI_RTSI_OUTPUT_ADR_START1 = 0,
+		NI_RTSI_OUTPUT_ADR_START2 = 1,
+		NI_RTSI_OUTPUT_SCLKG = 2,
+		NI_RTSI_OUTPUT_DACUPDN = 3,
+		NI_RTSI_OUTPUT_DA_START1 = 4,
+		NI_RTSI_OUTPUT_G_SRC0 = 5,
+		NI_RTSI_OUTPUT_G_GATE0 = 6,
+		NI_RTSI_OUTPUT_RGOUT0 = 7,
+		NI_RTSI_OUTPUT_RTSI_BRD_0 = 8,
+		NI_RTSI_OUTPUT_RTSI_OSC = 12	/* pre-m-series always have RTSI clock
+						   on line 7 */
+	};
+	static inline unsigned NI_RTSI_OUTPUT_RTSI_BRD(unsigned n) {
+		return NI_RTSI_OUTPUT_RTSI_BRD_0 + n;
+	}
 
 /* Signals which can be routed to an NI PFI pin on an m-series board with
  * INSN_CONFIG_SET_ROUTING.  These numbers are also returned by
  * INSN_CONFIG_GET_ROUTING on pre-m-series boards, even though their routing
  * cannot be changed.  The numbers assigned are not arbitrary, they correspond
  * to the bits required to program the board. */
-enum ni_pfi_routing {
-	NI_PFI_OUTPUT_PFI_DEFAULT = 0,
-	NI_PFI_OUTPUT_AI_START1 = 1,
-	NI_PFI_OUTPUT_AI_START2 = 2,
-	NI_PFI_OUTPUT_AI_CONVERT = 3,
-	NI_PFI_OUTPUT_G_SRC1 = 4,
-	NI_PFI_OUTPUT_G_GATE1 = 5,
-	NI_PFI_OUTPUT_AO_UPDATE_N = 6,
-	NI_PFI_OUTPUT_AO_START1 = 7,
-	NI_PFI_OUTPUT_AI_START_PULSE = 8,
-	NI_PFI_OUTPUT_G_SRC0 = 9,
-	NI_PFI_OUTPUT_G_GATE0 = 10,
-	NI_PFI_OUTPUT_EXT_STROBE = 11,
-	NI_PFI_OUTPUT_AI_EXT_MUX_CLK = 12,
-	NI_PFI_OUTPUT_GOUT0 = 13,
-	NI_PFI_OUTPUT_GOUT1 = 14,
-	NI_PFI_OUTPUT_FREQ_OUT = 15,
-	NI_PFI_OUTPUT_PFI_DO = 16,
-	NI_PFI_OUTPUT_I_ATRIG = 17,
-	NI_PFI_OUTPUT_RTSI0 = 18,
-	NI_PFI_OUTPUT_PXI_STAR_TRIGGER_IN = 26,
-	NI_PFI_OUTPUT_SCXI_TRIG1 = 27,
-	NI_PFI_OUTPUT_DIO_CHANGE_DETECT_RTSI = 28,
-	NI_PFI_OUTPUT_CDI_SAMPLE = 29,
-	NI_PFI_OUTPUT_CDO_UPDATE = 30
-};
-static inline unsigned NI_PFI_OUTPUT_RTSI(unsigned rtsi_channel)
-{
-	return NI_PFI_OUTPUT_RTSI0 + rtsi_channel;
-}
+	enum ni_pfi_routing {
+		NI_PFI_OUTPUT_PFI_DEFAULT = 0,
+		NI_PFI_OUTPUT_AI_START1 = 1,
+		NI_PFI_OUTPUT_AI_START2 = 2,
+		NI_PFI_OUTPUT_AI_CONVERT = 3,
+		NI_PFI_OUTPUT_G_SRC1 = 4,
+		NI_PFI_OUTPUT_G_GATE1 = 5,
+		NI_PFI_OUTPUT_AO_UPDATE_N = 6,
+		NI_PFI_OUTPUT_AO_START1 = 7,
+		NI_PFI_OUTPUT_AI_START_PULSE = 8,
+		NI_PFI_OUTPUT_G_SRC0 = 9,
+		NI_PFI_OUTPUT_G_GATE0 = 10,
+		NI_PFI_OUTPUT_EXT_STROBE = 11,
+		NI_PFI_OUTPUT_AI_EXT_MUX_CLK = 12,
+		NI_PFI_OUTPUT_GOUT0 = 13,
+		NI_PFI_OUTPUT_GOUT1 = 14,
+		NI_PFI_OUTPUT_FREQ_OUT = 15,
+		NI_PFI_OUTPUT_PFI_DO = 16,
+		NI_PFI_OUTPUT_I_ATRIG = 17,
+		NI_PFI_OUTPUT_RTSI0 = 18,
+		NI_PFI_OUTPUT_PXI_STAR_TRIGGER_IN = 26,
+		NI_PFI_OUTPUT_SCXI_TRIG1 = 27,
+		NI_PFI_OUTPUT_DIO_CHANGE_DETECT_RTSI = 28,
+		NI_PFI_OUTPUT_CDI_SAMPLE = 29,
+		NI_PFI_OUTPUT_CDO_UPDATE = 30
+	};
+	static inline unsigned NI_PFI_OUTPUT_RTSI(unsigned rtsi_channel) {
+		return NI_PFI_OUTPUT_RTSI0 + rtsi_channel;
+	}
 
 /* Signals which can be routed to output on a NI PFI pin on a 660x board
  with INSN_CONFIG_SET_ROUTING.  The numbers assigned are
@@ -785,72 +768,67 @@ static inline unsigned NI_PFI_OUTPUT_RTS
  to program the board.  Lines 0 to 7 can only be set to
  NI_660X_PFI_OUTPUT_DIO.  Lines 32 to 39 can only be set to
  NI_660X_PFI_OUTPUT_COUNTER. */
-enum ni_660x_pfi_routing {
-	NI_660X_PFI_OUTPUT_COUNTER = 1,	/* counter */
-	NI_660X_PFI_OUTPUT_DIO = 2,	/* static digital output */
-};
+	enum ni_660x_pfi_routing {
+		NI_660X_PFI_OUTPUT_COUNTER = 1,	/* counter */
+		NI_660X_PFI_OUTPUT_DIO = 2,	/* static digital output */
+	};
 
 /* NI External Trigger lines.  These values are not arbitrary, but are related
  * to the bits required to program the board (offset by 1 for historical
  * reasons). */
-static inline unsigned NI_EXT_PFI(unsigned pfi_channel)
-{
-	return NI_USUAL_PFI_SELECT(pfi_channel) - 1;
-}
-static inline unsigned NI_EXT_RTSI(unsigned rtsi_channel)
-{
-	return NI_USUAL_RTSI_SELECT(rtsi_channel) - 1;
-}
+	static inline unsigned NI_EXT_PFI(unsigned pfi_channel) {
+		return NI_USUAL_PFI_SELECT(pfi_channel) - 1;
+	}
+	static inline unsigned NI_EXT_RTSI(unsigned rtsi_channel) {
+		return NI_USUAL_RTSI_SELECT(rtsi_channel) - 1;
+	}
 
 /* status bits for INSN_CONFIG_GET_COUNTER_STATUS */
-enum comedi_counter_status_flags {
-	COMEDI_COUNTER_ARMED = 0x1,
-	COMEDI_COUNTER_COUNTING = 0x2,
-	COMEDI_COUNTER_TERMINAL_COUNT = 0x4,
-};
+	enum comedi_counter_status_flags {
+		COMEDI_COUNTER_ARMED = 0x1,
+		COMEDI_COUNTER_COUNTING = 0x2,
+		COMEDI_COUNTER_TERMINAL_COUNT = 0x4,
+	};
 
 /* Clock sources for CDIO subdevice on NI m-series boards.  Used as the
  * scan_begin_arg for a comedi_command. These sources may also be bitwise-or'd
  * with CR_INVERT to change polarity. */
-enum ni_m_series_cdio_scan_begin_src {
-	NI_CDIO_SCAN_BEGIN_SRC_GROUND = 0,
-	NI_CDIO_SCAN_BEGIN_SRC_AI_START = 18,
-	NI_CDIO_SCAN_BEGIN_SRC_AI_CONVERT = 19,
-	NI_CDIO_SCAN_BEGIN_SRC_PXI_STAR_TRIGGER = 20,
-	NI_CDIO_SCAN_BEGIN_SRC_G0_OUT = 28,
-	NI_CDIO_SCAN_BEGIN_SRC_G1_OUT = 29,
-	NI_CDIO_SCAN_BEGIN_SRC_ANALOG_TRIGGER = 30,
-	NI_CDIO_SCAN_BEGIN_SRC_AO_UPDATE = 31,
-	NI_CDIO_SCAN_BEGIN_SRC_FREQ_OUT = 32,
-	NI_CDIO_SCAN_BEGIN_SRC_DIO_CHANGE_DETECT_IRQ = 33
-};
-static inline unsigned NI_CDIO_SCAN_BEGIN_SRC_PFI(unsigned pfi_channel)
-{
-	return NI_USUAL_PFI_SELECT(pfi_channel);
-}
-static inline unsigned NI_CDIO_SCAN_BEGIN_SRC_RTSI(unsigned rtsi_channel)
-{
-	return NI_USUAL_RTSI_SELECT(rtsi_channel);
-}
+	enum ni_m_series_cdio_scan_begin_src {
+		NI_CDIO_SCAN_BEGIN_SRC_GROUND = 0,
+		NI_CDIO_SCAN_BEGIN_SRC_AI_START = 18,
+		NI_CDIO_SCAN_BEGIN_SRC_AI_CONVERT = 19,
+		NI_CDIO_SCAN_BEGIN_SRC_PXI_STAR_TRIGGER = 20,
+		NI_CDIO_SCAN_BEGIN_SRC_G0_OUT = 28,
+		NI_CDIO_SCAN_BEGIN_SRC_G1_OUT = 29,
+		NI_CDIO_SCAN_BEGIN_SRC_ANALOG_TRIGGER = 30,
+		NI_CDIO_SCAN_BEGIN_SRC_AO_UPDATE = 31,
+		NI_CDIO_SCAN_BEGIN_SRC_FREQ_OUT = 32,
+		NI_CDIO_SCAN_BEGIN_SRC_DIO_CHANGE_DETECT_IRQ = 33
+	};
+	static inline unsigned NI_CDIO_SCAN_BEGIN_SRC_PFI(unsigned pfi_channel) {
+		return NI_USUAL_PFI_SELECT(pfi_channel);
+	}
+	static inline unsigned NI_CDIO_SCAN_BEGIN_SRC_RTSI(unsigned
+							   rtsi_channel) {
+		return NI_USUAL_RTSI_SELECT(rtsi_channel);
+	}
 
 /* scan_begin_src for scan_begin_arg==TRIG_EXT with analog output command on NI
  * boards.  These scan begin sources can also be bitwise-or'd with CR_INVERT to
  * change polarity. */
-static inline unsigned NI_AO_SCAN_BEGIN_SRC_PFI(unsigned pfi_channel)
-{
-	return NI_USUAL_PFI_SELECT(pfi_channel);
-}
-static inline unsigned NI_AO_SCAN_BEGIN_SRC_RTSI(unsigned rtsi_channel)
-{
-	return NI_USUAL_RTSI_SELECT(rtsi_channel);
-}
+	static inline unsigned NI_AO_SCAN_BEGIN_SRC_PFI(unsigned pfi_channel) {
+		return NI_USUAL_PFI_SELECT(pfi_channel);
+	}
+	static inline unsigned NI_AO_SCAN_BEGIN_SRC_RTSI(unsigned rtsi_channel) {
+		return NI_USUAL_RTSI_SELECT(rtsi_channel);
+	}
 
 /* Bits for setting a clock source with
  * INSN_CONFIG_SET_CLOCK_SRC when using NI frequency output subdevice. */
-enum ni_freq_out_clock_source_bits {
-	NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC,	/* 10 MHz */
-	NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC	/* 100 KHz */
-};
+	enum ni_freq_out_clock_source_bits {
+		NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC,	/* 10 MHz */
+		NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC	/* 100 KHz */
+	};
 
 /* Values for setting a clock source with INSN_CONFIG_SET_CLOCK_SRC for
  * 8254 counter subdevices on Amplicon DIO boards (amplc_dio200 driver). */
--- a/drivers/staging/comedi/comedilib.h
+++ b/drivers/staging/comedi/comedilib.h
@@ -58,29 +58,31 @@ int comedi_fileno(void *dev);
 
 int comedi_cancel(void *dev, unsigned int subdev);
 int comedi_register_callback(void *dev, unsigned int subdev,
-	unsigned int mask, int (*cb) (unsigned int, void *), void *arg);
+			     unsigned int mask, int (*cb) (unsigned int,
+							   void *), void *arg);
 
 int comedi_command(void *dev, struct comedi_cmd *cmd);
 int comedi_command_test(void *dev, struct comedi_cmd *cmd);
 int comedi_trigger(void *dev, unsigned int subdev, struct comedi_trig *it);
 int __comedi_trigger(void *dev, unsigned int subdev, struct comedi_trig *it);
 int comedi_data_write(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int range, unsigned int aref, unsigned int data);
+		      unsigned int range, unsigned int aref, unsigned int data);
 int comedi_data_read(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int range, unsigned int aref, unsigned int *data);
+		     unsigned int range, unsigned int aref, unsigned int *data);
 int comedi_data_read_hint(void *dev, unsigned int subdev,
-	unsigned int chan, unsigned int range, unsigned int aref);
-int comedi_data_read_delayed(void *dev, unsigned int subdev,
-	unsigned int chan, unsigned int range, unsigned int aref,
-	unsigned int *data, unsigned int nano_sec);
+			  unsigned int chan, unsigned int range,
+			  unsigned int aref);
+int comedi_data_read_delayed(void *dev, unsigned int subdev, unsigned int chan,
+			     unsigned int range, unsigned int aref,
+			     unsigned int *data, unsigned int nano_sec);
 int comedi_dio_config(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int io);
+		      unsigned int io);
 int comedi_dio_read(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int *val);
+		    unsigned int *val);
 int comedi_dio_write(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int val);
+		     unsigned int val);
 int comedi_dio_bitfield(void *dev, unsigned int subdev, unsigned int mask,
-	unsigned int *bits);
+			unsigned int *bits);
 int comedi_get_n_subdevices(void *dev);
 int comedi_get_version_code(void *dev);
 const char *comedi_get_driver_name(void *dev);
@@ -89,31 +91,29 @@ int comedi_get_subdevice_type(void *dev,
 int comedi_find_subdevice_by_type(void *dev, int type, unsigned int subd);
 int comedi_get_n_channels(void *dev, unsigned int subdevice);
 unsigned int comedi_get_maxdata(void *dev, unsigned int subdevice, unsigned
-	int chan);
-int comedi_get_n_ranges(void *dev, unsigned int subdevice, unsigned int
-	chan);
+				int chan);
+int comedi_get_n_ranges(void *dev, unsigned int subdevice, unsigned int chan);
 int comedi_do_insn(void *dev, struct comedi_insn *insn);
 int comedi_poll(void *dev, unsigned int subdev);
 
 /* DEPRECATED functions */
-int comedi_get_rangetype(void *dev, unsigned int subdevice,
-	unsigned int chan);
+int comedi_get_rangetype(void *dev, unsigned int subdevice, unsigned int chan);
 
 /* ALPHA functions */
 unsigned int comedi_get_subdevice_flags(void *dev, unsigned int subdevice);
 int comedi_get_len_chanlist(void *dev, unsigned int subdevice);
 int comedi_get_krange(void *dev, unsigned int subdevice, unsigned int
-	chan, unsigned int range, struct comedi_krange *krange);
+		      chan, unsigned int range, struct comedi_krange *krange);
 unsigned int comedi_get_buf_head_pos(void *dev, unsigned int subdevice);
 int comedi_set_user_int_count(void *dev, unsigned int subdevice,
-	unsigned int buf_user_count);
+			      unsigned int buf_user_count);
 int comedi_map(void *dev, unsigned int subdev, void *ptr);
 int comedi_unmap(void *dev, unsigned int subdev);
 int comedi_get_buffer_size(void *dev, unsigned int subdev);
 int comedi_mark_buffer_read(void *dev, unsigned int subdevice,
-	unsigned int num_bytes);
+			    unsigned int num_bytes);
 int comedi_mark_buffer_written(void *d, unsigned int subdevice,
-	unsigned int num_bytes);
+			       unsigned int num_bytes);
 int comedi_get_buffer_contents(void *dev, unsigned int subdevice);
 int comedi_get_buffer_offset(void *dev, unsigned int subdevice);
 
@@ -135,53 +135,56 @@ int comedi_unlock(unsigned int minor, un
 
 int comedi_cancel(unsigned int minor, unsigned int subdev);
 int comedi_register_callback(unsigned int minor, unsigned int subdev,
-	unsigned int mask, int (*cb) (unsigned int, void *), void *arg);
+			     unsigned int mask, int (*cb) (unsigned int,
+							   void *), void *arg);
 
 int comedi_command(unsigned int minor, struct comedi_cmd *cmd);
 int comedi_command_test(unsigned int minor, struct comedi_cmd *cmd);
-int comedi_trigger(unsigned int minor, unsigned int subdev, struct comedi_trig *it);
-int __comedi_trigger(unsigned int minor, unsigned int subdev, struct comedi_trig *it);
+int comedi_trigger(unsigned int minor, unsigned int subdev,
+		   struct comedi_trig *it);
+int __comedi_trigger(unsigned int minor, unsigned int subdev,
+		     struct comedi_trig *it);
 int comedi_data_write(unsigned int dev, unsigned int subdev, unsigned int chan,
-	unsigned int range, unsigned int aref, unsigned int data);
+		      unsigned int range, unsigned int aref, unsigned int data);
 int comedi_data_read(unsigned int dev, unsigned int subdev, unsigned int chan,
-	unsigned int range, unsigned int aref, unsigned int *data);
+		     unsigned int range, unsigned int aref, unsigned int *data);
 int comedi_dio_config(unsigned int dev, unsigned int subdev, unsigned int chan,
-	unsigned int io);
+		      unsigned int io);
 int comedi_dio_read(unsigned int dev, unsigned int subdev, unsigned int chan,
-	unsigned int *val);
+		    unsigned int *val);
 int comedi_dio_write(unsigned int dev, unsigned int subdev, unsigned int chan,
-	unsigned int val);
+		     unsigned int val);
 int comedi_dio_bitfield(unsigned int dev, unsigned int subdev,
-	unsigned int mask, unsigned int *bits);
+			unsigned int mask, unsigned int *bits);
 int comedi_get_n_subdevices(unsigned int dev);
 int comedi_get_version_code(unsigned int dev);
 char *comedi_get_driver_name(unsigned int dev);
 char *comedi_get_board_name(unsigned int minor);
 int comedi_get_subdevice_type(unsigned int minor, unsigned int subdevice);
 int comedi_find_subdevice_by_type(unsigned int minor, int type,
-	unsigned int subd);
+				  unsigned int subd);
 int comedi_get_n_channels(unsigned int minor, unsigned int subdevice);
 unsigned int comedi_get_maxdata(unsigned int minor, unsigned int subdevice, unsigned
-	int chan);
+				int chan);
 int comedi_get_n_ranges(unsigned int minor, unsigned int subdevice, unsigned int
-	chan);
+			chan);
 int comedi_do_insn(unsigned int minor, struct comedi_insn *insn);
 int comedi_poll(unsigned int minor, unsigned int subdev);
 
 /* DEPRECATED functions */
 int comedi_get_rangetype(unsigned int minor, unsigned int subdevice,
-	unsigned int chan);
+			 unsigned int chan);
 
 /* ALPHA functions */
 unsigned int comedi_get_subdevice_flags(unsigned int minor, unsigned int
-	subdevice);
+					subdevice);
 int comedi_get_len_chanlist(unsigned int minor, unsigned int subdevice);
 int comedi_get_krange(unsigned int minor, unsigned int subdevice, unsigned int
-	chan, unsigned int range, struct comedi_krange *krange);
+		      chan, unsigned int range, struct comedi_krange *krange);
 unsigned int comedi_get_buf_head_pos(unsigned int minor, unsigned int
-	subdevice);
+				     subdevice);
 int comedi_set_user_int_count(unsigned int minor, unsigned int subdevice,
-	unsigned int buf_user_count);
+			      unsigned int buf_user_count);
 int comedi_map(unsigned int minor, unsigned int subdev, void **ptr);
 int comedi_unmap(unsigned int minor, unsigned int subdev);
 
--- a/drivers/staging/comedi/drivers/8253.h
+++ b/drivers/staging/comedi/drivers/8253.h
@@ -29,8 +29,10 @@
 #define i8253_cascade_ns_to_timer i8253_cascade_ns_to_timer_2div
 
 static inline void i8253_cascade_ns_to_timer_2div_old(int i8253_osc_base,
-	unsigned int *d1, unsigned int *d2, unsigned int *nanosec,
-	int round_mode)
+						      unsigned int *d1,
+						      unsigned int *d2,
+						      unsigned int *nanosec,
+						      int round_mode)
 {
 	int divider;
 	int div1, div2;
@@ -78,8 +80,10 @@ static inline void i8253_cascade_ns_to_t
 }
 
 static inline void i8253_cascade_ns_to_timer_power(int i8253_osc_base,
-	unsigned int *d1, unsigned int *d2, unsigned int *nanosec,
-	int round_mode)
+						   unsigned int *d1,
+						   unsigned int *d2,
+						   unsigned int *nanosec,
+						   int round_mode)
 {
 	int div1, div2;
 	int base;
@@ -118,8 +122,10 @@ static inline void i8253_cascade_ns_to_t
 }
 
 static inline void i8253_cascade_ns_to_timer_2div(int i8253_osc_base,
-	unsigned int *d1, unsigned int *d2, unsigned int *nanosec,
-	int round_mode)
+						  unsigned int *d1,
+						  unsigned int *d2,
+						  unsigned int *nanosec,
+						  int round_mode)
 {
 	unsigned int divider;
 	unsigned int div1, div2;
@@ -136,12 +142,11 @@ static inline void i8253_cascade_ns_to_t
 	div2 = *d2 ? *d2 : max_count;
 	divider = div1 * div2;
 	if (div1 * div2 * i8253_osc_base == *nanosec &&
-		div1 > 1 && div1 <= max_count &&
-		div2 > 1 && div2 <= max_count &&
-		/* check for overflow */
-		divider > div1 && divider > div2 &&
-		divider * i8253_osc_base > divider &&
-		divider * i8253_osc_base > i8253_osc_base) {
+	    div1 > 1 && div1 <= max_count && div2 > 1 && div2 <= max_count &&
+	    /* check for overflow */
+	    divider > div1 && divider > div2 &&
+	    divider * i8253_osc_base > divider &&
+	    divider * i8253_osc_base > i8253_osc_base) {
 		return;
 	}
 
@@ -158,10 +163,10 @@ static inline void i8253_cascade_ns_to_t
 	if (start < 2)
 		start = 2;
 	for (div1 = start; div1 <= divider / div1 + 1 && div1 <= max_count;
-		div1++) {
+	     div1++) {
 		for (div2 = divider / div1;
-			div1 * div2 <= divider + div1 + 1 && div2 <= max_count;
-			div2++) {
+		     div1 * div2 <= divider + div1 + 1 && div2 <= max_count;
+		     div2++) {
 			ns = i8253_osc_base * div1 * div2;
 			if (ns <= *nanosec && ns > ns_glb) {
 				ns_glb = ns;
@@ -229,7 +234,8 @@ static inline void i8253_cascade_ns_to_t
 #define i8254_control_reg	3
 
 static inline int i8254_load(unsigned long base_address, unsigned int regshift,
-	unsigned int counter_number, unsigned int count, unsigned int mode)
+			     unsigned int counter_number, unsigned int count,
+			     unsigned int mode)
 {
 	unsigned int byte;
 
@@ -255,7 +261,8 @@ static inline int i8254_load(unsigned lo
 }
 
 static inline int i8254_mm_load(void *base_address, unsigned int regshift,
-	unsigned int counter_number, unsigned int count, unsigned int mode)
+				unsigned int counter_number, unsigned int count,
+				unsigned int mode)
 {
 	unsigned int byte;
 
@@ -282,7 +289,7 @@ static inline int i8254_mm_load(void *ba
 
 /* Returns 16 bit counter value, should work for 8253 also.*/
 static inline int i8254_read(unsigned long base_address, unsigned int regshift,
-	unsigned int counter_number)
+			     unsigned int counter_number)
 {
 	unsigned int byte;
 	int ret;
@@ -303,7 +310,7 @@ static inline int i8254_read(unsigned lo
 }
 
 static inline int i8254_mm_read(void *base_address, unsigned int regshift,
-	unsigned int counter_number)
+				unsigned int counter_number)
 {
 	unsigned int byte;
 	int ret;
@@ -325,7 +332,8 @@ static inline int i8254_mm_read(void *ba
 
 /* Loads 16 bit initial counter value, should work for 8253 also. */
 static inline void i8254_write(unsigned long base_address,
-	unsigned int regshift, unsigned int counter_number, unsigned int count)
+			       unsigned int regshift,
+			       unsigned int counter_number, unsigned int count)
 {
 	unsigned int byte;
 
@@ -339,7 +347,9 @@ static inline void i8254_write(unsigned 
 }
 
 static inline void i8254_mm_write(void *base_address,
-	unsigned int regshift, unsigned int counter_number, unsigned int count)
+				  unsigned int regshift,
+				  unsigned int counter_number,
+				  unsigned int count)
 {
 	unsigned int byte;
 
@@ -360,7 +370,8 @@ static inline void i8254_mm_write(void *
  *   I8254_BCD, I8254_BINARY
  */
 static inline int i8254_set_mode(unsigned long base_address,
-	unsigned int regshift, unsigned int counter_number, unsigned int mode)
+				 unsigned int regshift,
+				 unsigned int counter_number, unsigned int mode)
 {
 	unsigned int byte;
 
@@ -378,7 +389,9 @@ static inline int i8254_set_mode(unsigne
 }
 
 static inline int i8254_mm_set_mode(void *base_address,
-	unsigned int regshift, unsigned int counter_number, unsigned int mode)
+				    unsigned int regshift,
+				    unsigned int counter_number,
+				    unsigned int mode)
 {
 	unsigned int byte;
 
@@ -396,18 +409,20 @@ static inline int i8254_mm_set_mode(void
 }
 
 static inline int i8254_status(unsigned long base_address,
-	unsigned int regshift, unsigned int counter_number)
+			       unsigned int regshift,
+			       unsigned int counter_number)
 {
 	outb(0xE0 | (2 << counter_number),
-		base_address + (i8254_control_reg << regshift));
+	     base_address + (i8254_control_reg << regshift));
 	return inb(base_address + (counter_number << regshift));
 }
 
 static inline int i8254_mm_status(void *base_address,
-	unsigned int regshift, unsigned int counter_number)
+				  unsigned int regshift,
+				  unsigned int counter_number)
 {
 	writeb(0xE0 | (2 << counter_number),
-		base_address + (i8254_control_reg << regshift));
+	       base_address + (i8254_control_reg << regshift));
 	return readb(base_address + (counter_number << regshift));
 }
 
--- a/drivers/staging/comedi/drivers/8255.c
+++ b/drivers/staging/comedi/drivers/8255.c
@@ -105,7 +105,8 @@ struct subdev_8255_struct {
 #define CALLBACK_FUNC	(((struct subdev_8255_struct *)s->private)->cb_func)
 #define subdevpriv	((struct subdev_8255_struct *)s->private)
 
-static int dev_8255_attach(struct comedi_device *dev, struct comedi_devconfig * it);
+static int dev_8255_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it);
 static int dev_8255_detach(struct comedi_device *dev);
 static struct comedi_driver driver_8255 = {
 	.driver_name = "8255",
@@ -116,9 +117,10 @@ static struct comedi_driver driver_8255 
 
 COMEDI_INITCLEANUP(driver_8255);
 
-static void do_config(struct comedi_device *dev, struct comedi_subdevice * s);
+static void do_config(struct comedi_device *dev, struct comedi_subdevice *s);
 
-void subdev_8255_interrupt(struct comedi_device *dev, struct comedi_subdevice * s)
+void subdev_8255_interrupt(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	short d;
 
@@ -143,8 +145,9 @@ static int subdev_8255_cb(int dir, int p
 	}
 }
 
-static int subdev_8255_insn(struct comedi_device *dev, struct comedi_subdevice * s,
-	struct comedi_insn *insn, unsigned int *data)
+static int subdev_8255_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -152,13 +155,13 @@ static int subdev_8255_insn(struct comed
 
 		if (data[0] & 0xff)
 			CALLBACK_FUNC(1, _8255_DATA, s->state & 0xff,
-				CALLBACK_ARG);
+				      CALLBACK_ARG);
 		if (data[0] & 0xff00)
 			CALLBACK_FUNC(1, _8255_DATA + 1, (s->state >> 8) & 0xff,
-				CALLBACK_ARG);
+				      CALLBACK_ARG);
 		if (data[0] & 0xff0000)
 			CALLBACK_FUNC(1, _8255_DATA + 2,
-				(s->state >> 16) & 0xff, CALLBACK_ARG);
+				      (s->state >> 16) & 0xff, CALLBACK_ARG);
 	}
 
 	data[1] = CALLBACK_FUNC(0, _8255_DATA, 0, CALLBACK_ARG);
@@ -168,8 +171,9 @@ static int subdev_8255_insn(struct comed
 	return 2;
 }
 
-static int subdev_8255_insn_config(struct comedi_device *dev, struct comedi_subdevice * s,
-	struct comedi_insn *insn, unsigned int *data)
+static int subdev_8255_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int mask;
 	unsigned int bits;
@@ -205,7 +209,7 @@ static int subdev_8255_insn_config(struc
 	return 1;
 }
 
-static void do_config(struct comedi_device *dev, struct comedi_subdevice * s)
+static void do_config(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int config;
 
@@ -222,8 +226,9 @@ static void do_config(struct comedi_devi
 	CALLBACK_FUNC(1, _8255_CR, config, CALLBACK_ARG);
 }
 
-static int subdev_8255_cmdtest(struct comedi_device *dev, struct comedi_subdevice * s,
-	struct comedi_cmd *cmd)
+static int subdev_8255_cmdtest(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -297,22 +302,25 @@ static int subdev_8255_cmdtest(struct co
 	return 0;
 }
 
-static int subdev_8255_cmd(struct comedi_device *dev, struct comedi_subdevice * s)
+static int subdev_8255_cmd(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	/* FIXME */
 
 	return 0;
 }
 
-static int subdev_8255_cancel(struct comedi_device *dev, struct comedi_subdevice * s)
+static int subdev_8255_cancel(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	/* FIXME */
 
 	return 0;
 }
 
-int subdev_8255_init(struct comedi_device *dev, struct comedi_subdevice * s, int (*cb) (int,
-		int, int, unsigned long), unsigned long arg)
+int subdev_8255_init(struct comedi_device *dev, struct comedi_subdevice *s,
+		     int (*cb) (int, int, int, unsigned long),
+		     unsigned long arg)
 {
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
@@ -340,8 +348,9 @@ int subdev_8255_init(struct comedi_devic
 	return 0;
 }
 
-int subdev_8255_init_irq(struct comedi_device *dev, struct comedi_subdevice * s,
-	int (*cb) (int, int, int, unsigned long), unsigned long arg)
+int subdev_8255_init_irq(struct comedi_device *dev, struct comedi_subdevice *s,
+			 int (*cb) (int, int, int, unsigned long),
+			 unsigned long arg)
 {
 	int ret;
 
@@ -358,7 +367,7 @@ int subdev_8255_init_irq(struct comedi_d
 	return 0;
 }
 
-void subdev_8255_cleanup(struct comedi_device *dev, struct comedi_subdevice * s)
+void subdev_8255_cleanup(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (s->private) {
 		/* this test does nothing, so comment it out
@@ -376,7 +385,8 @@ void subdev_8255_cleanup(struct comedi_d
 
  */
 
-static int dev_8255_attach(struct comedi_device *dev, struct comedi_devconfig * it)
+static int dev_8255_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it)
 {
 	int ret;
 	unsigned long iobase;
@@ -410,7 +420,7 @@ static int dev_8255_attach(struct comedi
 			dev->subdevices[i].type = COMEDI_SUBD_UNUSED;
 		} else {
 			subdev_8255_init(dev, dev->subdevices + i, NULL,
-				iobase);
+					 iobase);
 		}
 	}
 
--- a/drivers/staging/comedi/drivers/8255.h
+++ b/drivers/staging/comedi/drivers/8255.h
@@ -29,16 +29,20 @@
 #if defined(CONFIG_COMEDI_8255) || defined(CONFIG_COMEDI_8255_MODULE)
 
 int subdev_8255_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	int (*cb) (int, int, int, unsigned long), unsigned long arg);
+		     int (*cb) (int, int, int, unsigned long),
+		     unsigned long arg);
 int subdev_8255_init_irq(struct comedi_device *dev, struct comedi_subdevice *s,
-	int (*cb) (int, int, int, unsigned long), unsigned long arg);
+			 int (*cb) (int, int, int, unsigned long),
+			 unsigned long arg);
 void subdev_8255_cleanup(struct comedi_device *dev, struct comedi_subdevice *s);
-void subdev_8255_interrupt(struct comedi_device *dev, struct comedi_subdevice *s);
+void subdev_8255_interrupt(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
 
 #else
 
-static inline int subdev_8255_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *x, unsigned long y)
+static inline int subdev_8255_init(struct comedi_device *dev,
+				   struct comedi_subdevice *s, void *x,
+				   unsigned long y)
 {
 	printk("8255 support not configured -- disabling subdevice\n");
 
@@ -48,7 +52,7 @@ static inline int subdev_8255_init(struc
 }
 
 static inline void subdev_8255_cleanup(struct comedi_device *dev,
-	struct comedi_subdevice *s)
+				       struct comedi_subdevice *s)
 {
 }
 
--- a/drivers/staging/comedi/drivers/acl7225b.c
+++ b/drivers/staging/comedi/drivers/acl7225b.c
@@ -22,7 +22,8 @@ Devices: [Adlink] ACL-7225b (acl7225b), 
 #define ACL7225_DI_LO  2	/* Digital input low byte (DI0-DI7) */
 #define ACL7225_DI_HI  3	/* Digital input high byte (DI8-DI15) */
 
-static int acl7225b_attach(struct comedi_device *dev, struct comedi_devconfig * it);
+static int acl7225b_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it);
 static int acl7225b_detach(struct comedi_device *dev);
 
 struct boardtype {
@@ -50,8 +51,9 @@ static struct comedi_driver driver_acl72
 
 COMEDI_INITCLEANUP(driver_acl7225b);
 
-static int acl7225b_do_insn(struct comedi_device *dev, struct comedi_subdevice * s,
-	struct comedi_insn *insn, unsigned int *data)
+static int acl7225b_do_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -64,26 +66,28 @@ static int acl7225b_do_insn(struct comed
 		outb(s->state & 0xff, dev->iobase + (unsigned long)s->private);
 	if (data[0] & 0xff00)
 		outb((s->state >> 8),
-			dev->iobase + (unsigned long)s->private + 1);
+		     dev->iobase + (unsigned long)s->private + 1);
 
 	data[1] = s->state;
 
 	return 2;
 }
 
-static int acl7225b_di_insn(struct comedi_device *dev, struct comedi_subdevice * s,
-	struct comedi_insn *insn, unsigned int *data)
+static int acl7225b_di_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
 
 	data[1] = inb(dev->iobase + (unsigned long)s->private) |
-		(inb(dev->iobase + (unsigned long)s->private + 1) << 8);
+	    (inb(dev->iobase + (unsigned long)s->private + 1) << 8);
 
 	return 2;
 }
 
-static int acl7225b_attach(struct comedi_device *dev, struct comedi_devconfig * it)
+static int acl7225b_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int iobase, iorange;
@@ -91,7 +95,7 @@ static int acl7225b_attach(struct comedi
 	iobase = it->options[0];
 	iorange = this_board->io_range;
 	printk("comedi%d: acl7225b: board=%s 0x%04x ", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 	if (!request_region(iobase, iorange, "acl7225b")) {
 		printk("I/O port conflict\n");
 		return -EIO;
--- a/drivers/staging/comedi/drivers/adl_pci6208.c
+++ b/drivers/staging/comedi/drivers/adl_pci6208.c
@@ -66,23 +66,23 @@ struct pci6208_board {
 
 static const struct pci6208_board pci6208_boards[] = {
 	/*{
-	.name = "pci6208v",
-	.dev_id = 0x6208,      // not sure
-	.ao_chans = 8
-	   // ,	.ao_bits = 16
+	   .name = "pci6208v",
+	   .dev_id = 0x6208,      // not sure
+	   .ao_chans = 8
+	   // , .ao_bits = 16
 	   },
 	   {
-	.name = "pci6216v",
-	.dev_id = 0x6208,      // not sure
-	.ao_chans = 16
-	   // ,	.ao_bits = 16
+	   .name = "pci6216v",
+	   .dev_id = 0x6208,      // not sure
+	   .ao_chans = 16
+	   // , .ao_bits = 16
 	   }, */
 	{
-	.name = "pci6208a",
-	.dev_id = 0x6208,
-	.ao_chans = 8
-			/* ,	.ao_bits = 16 */
-		}
+	 .name = "pci6208a",
+	 .dev_id = 0x6208,
+	 .ao_chans = 8
+	 /* ,    .ao_bits = 16 */
+	 }
 };
 
 /* This is used by modprobe to translate PCI IDs to drivers.  Should
@@ -90,8 +90,9 @@ static const struct pci6208_board pci620
 static DEFINE_PCI_DEVICE_TABLE(pci6208_pci_table) = {
 	/* { PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
 	/* { PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
-	{PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci6208_pci_table);
@@ -107,7 +108,8 @@ struct pci6208_private {
 
 #define devpriv ((struct pci6208_private *)dev->private)
 
-static int pci6208_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci6208_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pci6208_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver_pci6208 = {
@@ -122,13 +124,15 @@ COMEDI_PCI_INITCLEANUP(driver_pci6208, p
 static int pci6208_find_device(struct comedi_device *dev, int bus, int slot);
 static int
 pci6208_pci_setup(struct pci_dev *pci_dev, unsigned long *io_base_ptr,
-	int dev_minor);
+		  int dev_minor);
 
 /*read/write functions*/
-static int pci6208_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pci6208_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pci6208_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int pci6208_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 /* static int pci6208_dio_insn_bits(struct comedi_device *dev,struct comedi_subdevice *s, */
 /* struct comedi_insn *insn,unsigned int *data); */
 /* static int pci6208_dio_insn_config(struct comedi_device *dev,struct comedi_subdevice *s, */
@@ -140,7 +144,8 @@ static int pci6208_ao_rinsn(struct comed
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pci6208_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci6208_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int retval;
@@ -217,8 +222,9 @@ static int pci6208_detach(struct comedi_
 	return 0;
 }
 
-static int pci6208_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci6208_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i = 0, Data_Read;
 	unsigned short chan = CR_CHAN(insn->chanspec);
@@ -242,8 +248,9 @@ static int pci6208_ao_winsn(struct comed
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int pci6208_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci6208_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -309,8 +316,8 @@ static int pci6208_find_device(struct co
 	int i;
 
 	for (pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) {
 		if (pci_dev->vendor == PCI_VENDOR_ID_ADLINK) {
 			for (i = 0; i < ARRAY_SIZE(pci6208_boards); i++) {
 				if (pci6208_boards[i].dev_id == pci_dev->device) {
@@ -318,9 +325,9 @@ static int pci6208_find_device(struct co
 					if ((bus != 0) || (slot != 0)) {
 						/*  are we on the wrong bus/slot? */
 						if (pci_dev->bus->number
-							!= bus ||
-							PCI_SLOT(pci_dev->devfn)
-							!= slot) {
+						    != bus ||
+						    PCI_SLOT(pci_dev->devfn)
+						    != slot) {
 							continue;
 						}
 					}
@@ -332,16 +339,16 @@ static int pci6208_find_device(struct co
 	}
 
 	printk("comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",
-		dev->minor, bus, slot);
+	       dev->minor, bus, slot);
 	return -EIO;
 
-      found:
+found:
 	printk("comedi%d: found %s (b:s:f=%d:%d:%d) , irq=%d\n",
-		dev->minor,
-		pci6208_boards[i].name,
-		pci_dev->bus->number,
-		PCI_SLOT(pci_dev->devfn),
-		PCI_FUNC(pci_dev->devfn), pci_dev->irq);
+	       dev->minor,
+	       pci6208_boards[i].name,
+	       pci_dev->bus->number,
+	       PCI_SLOT(pci_dev->devfn),
+	       PCI_FUNC(pci_dev->devfn), pci_dev->irq);
 
 	/*  TODO: Warn about non-tested boards. */
 	/* switch(board->device_id) */
@@ -355,13 +362,15 @@ static int pci6208_find_device(struct co
 
 static int
 pci6208_pci_setup(struct pci_dev *pci_dev, unsigned long *io_base_ptr,
-	int dev_minor)
+		  int dev_minor)
 {
 	unsigned long io_base, io_range, lcr_io_base, lcr_io_range;
 
 	/*  Enable PCI device and request regions */
 	if (comedi_pci_enable(pci_dev, PCI6208_DRIVER_NAME) < 0) {
-		printk("comedi%d: Failed to enable PCI device and request regions\n", dev_minor);
+		printk
+		    ("comedi%d: Failed to enable PCI device and request regions\n",
+		     dev_minor);
 		return -EIO;
 	}
 	/*  Read local configuration register base address [PCI_BASE_ADDRESS #1]. */
@@ -369,14 +378,14 @@ pci6208_pci_setup(struct pci_dev *pci_de
 	lcr_io_range = pci_resource_len(pci_dev, 1);
 
 	printk("comedi%d: local config registers at address 0x%4lx [0x%4lx]\n",
-		dev_minor, lcr_io_base, lcr_io_range);
+	       dev_minor, lcr_io_base, lcr_io_range);
 
 	/*  Read PCI6208 register base address [PCI_BASE_ADDRESS #2]. */
 	io_base = pci_resource_start(pci_dev, 2);
 	io_range = pci_resource_end(pci_dev, 2) - io_base + 1;
 
 	printk("comedi%d: 6208 registers at address 0x%4lx [0x%4lx]\n",
-		dev_minor, io_base, io_range);
+	       dev_minor, io_base, io_range);
 
 	*io_base_ptr = io_base;
 	/* devpriv->io_range = io_range; */
--- a/drivers/staging/comedi/drivers/adl_pci7296.c
+++ b/drivers/staging/comedi/drivers/adl_pci7296.c
@@ -49,9 +49,10 @@ Configuration Options:
 #define PCI_DEVICE_ID_PCI7296 0x7296
 
 static DEFINE_PCI_DEVICE_TABLE(adl_pci7296_pci_table) = {
-	{PCI_VENDOR_ID_ADLINK, PCI_DEVICE_ID_PCI7296, PCI_ANY_ID, PCI_ANY_ID, 0,
-		0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_ADLINK, PCI_DEVICE_ID_PCI7296, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, adl_pci7296_pci_table);
@@ -61,10 +62,10 @@ struct adl_pci7296_private {
 	struct pci_dev *pci_dev;
 };
 
-
 #define devpriv ((struct adl_pci7296_private *)dev->private)
 
-static int adl_pci7296_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int adl_pci7296_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it);
 static int adl_pci7296_detach(struct comedi_device *dev);
 static struct comedi_driver driver_adl_pci7296 = {
 	.driver_name = "adl_pci7296",
@@ -73,7 +74,8 @@ static struct comedi_driver driver_adl_p
 	.detach = adl_pci7296_detach,
 };
 
-static int adl_pci7296_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int adl_pci7296_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev;
 	struct comedi_subdevice *s;
@@ -94,21 +96,23 @@ static int adl_pci7296_attach(struct com
 		return -ENOMEM;
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 
 		if (pcidev->vendor == PCI_VENDOR_ID_ADLINK &&
-			pcidev->device == PCI_DEVICE_ID_PCI7296) {
+		    pcidev->device == PCI_DEVICE_ID_PCI7296) {
 			if (bus || slot) {
 				/* requested particular bus/slot */
 				if (pcidev->bus->number != bus
-					|| PCI_SLOT(pcidev->devfn) != slot) {
+				    || PCI_SLOT(pcidev->devfn) != slot) {
 					continue;
 				}
 			}
 			devpriv->pci_dev = pcidev;
 			if (comedi_pci_enable(pcidev, "adl_pci7296") < 0) {
-				printk("comedi%d: Failed to enable PCI device and request regions\n", dev->minor);
+				printk
+				    ("comedi%d: Failed to enable PCI device and request regions\n",
+				     dev->minor);
 				return -EIO;
 			}
 
@@ -118,23 +122,26 @@ static int adl_pci7296_attach(struct com
 			/*  four 8255 digital io subdevices */
 			s = dev->subdevices + 0;
 			subdev_8255_init(dev, s, NULL,
-				(unsigned long)(dev->iobase));
+					 (unsigned long)(dev->iobase));
 
 			s = dev->subdevices + 1;
 			ret = subdev_8255_init(dev, s, NULL,
-				(unsigned long)(dev->iobase + PORT2A));
+					       (unsigned long)(dev->iobase +
+							       PORT2A));
 			if (ret < 0)
 				return ret;
 
 			s = dev->subdevices + 2;
 			ret = subdev_8255_init(dev, s, NULL,
-				(unsigned long)(dev->iobase + PORT3A));
+					       (unsigned long)(dev->iobase +
+							       PORT3A));
 			if (ret < 0)
 				return ret;
 
 			s = dev->subdevices + 3;
 			ret = subdev_8255_init(dev, s, NULL,
-				(unsigned long)(dev->iobase + PORT4A));
+					       (unsigned long)(dev->iobase +
+							       PORT4A));
 			if (ret < 0)
 				return ret;
 
@@ -145,7 +152,7 @@ static int adl_pci7296_attach(struct com
 	}
 
 	printk("comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",
-		dev->minor, bus, slot);
+	       dev->minor, bus, slot);
 	return -EIO;
 }
 
--- a/drivers/staging/comedi/drivers/adl_pci7432.c
+++ b/drivers/staging/comedi/drivers/adl_pci7432.c
@@ -44,9 +44,10 @@ Configuration Options:
 #define PCI_DEVICE_ID_PCI7432 0x7432
 
 static DEFINE_PCI_DEVICE_TABLE(adl_pci7432_pci_table) = {
-	{PCI_VENDOR_ID_ADLINK, PCI_DEVICE_ID_PCI7432, PCI_ANY_ID, PCI_ANY_ID, 0,
-		0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_ADLINK, PCI_DEVICE_ID_PCI7432, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, adl_pci7432_pci_table);
@@ -58,7 +59,8 @@ struct adl_pci7432_private {
 
 #define devpriv ((struct adl_pci7432_private *)dev->private)
 
-static int adl_pci7432_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int adl_pci7432_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it);
 static int adl_pci7432_detach(struct comedi_device *dev);
 static struct comedi_driver driver_adl_pci7432 = {
 	.driver_name = "adl_pci7432",
@@ -69,15 +71,20 @@ static struct comedi_driver driver_adl_p
 
 /* Digital IO */
 
-static int adl_pci7432_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-
-static int adl_pci7432_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int adl_pci7432_di_insn_bits(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data);
+
+static int adl_pci7432_do_insn_bits(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data);
 
 /*            */
 
-static int adl_pci7432_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int adl_pci7432_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev;
 	struct comedi_subdevice *s;
@@ -97,21 +104,23 @@ static int adl_pci7432_attach(struct com
 		return -ENOMEM;
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 
 		if (pcidev->vendor == PCI_VENDOR_ID_ADLINK &&
-			pcidev->device == PCI_DEVICE_ID_PCI7432) {
+		    pcidev->device == PCI_DEVICE_ID_PCI7432) {
 			if (bus || slot) {
 				/* requested particular bus/slot */
 				if (pcidev->bus->number != bus
-					|| PCI_SLOT(pcidev->devfn) != slot) {
+				    || PCI_SLOT(pcidev->devfn) != slot) {
 					continue;
 				}
 			}
 			devpriv->pci_dev = pcidev;
 			if (comedi_pci_enable(pcidev, "adl_pci7432") < 0) {
-				printk("comedi%d: Failed to enable PCI device and request regions\n", dev->minor);
+				printk
+				    ("comedi%d: Failed to enable PCI device and request regions\n",
+				     dev->minor);
 				return -EIO;
 			}
 			dev->iobase = pci_resource_start(pcidev, 2);
@@ -120,7 +129,7 @@ static int adl_pci7432_attach(struct com
 			s = dev->subdevices + 0;
 			s->type = COMEDI_SUBD_DI;
 			s->subdev_flags =
-				SDF_READABLE | SDF_GROUND | SDF_COMMON;
+			    SDF_READABLE | SDF_GROUND | SDF_COMMON;
 			s->n_chan = 32;
 			s->maxdata = 1;
 			s->len_chanlist = 32;
@@ -131,7 +140,7 @@ static int adl_pci7432_attach(struct com
 			s = dev->subdevices + 1;
 			s->type = COMEDI_SUBD_DO;
 			s->subdev_flags =
-				SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
+			    SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
 			s->n_chan = 32;
 			s->maxdata = 1;
 			s->len_chanlist = 32;
@@ -146,7 +155,7 @@ static int adl_pci7432_attach(struct com
 	}
 
 	printk("comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",
-		dev->minor, bus, slot);
+	       dev->minor, bus, slot);
 	return -EIO;
 }
 
@@ -164,8 +173,10 @@ static int adl_pci7432_detach(struct com
 	return 0;
 }
 
-static int adl_pci7432_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int adl_pci7432_do_insn_bits(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	printk("comedi: pci7432_do_insn_bits called\n");
 	printk("comedi: data0: %8x data1: %8x\n", data[0], data[1]);
@@ -178,14 +189,16 @@ static int adl_pci7432_do_insn_bits(stru
 		s->state |= (data[0] & data[1]);
 
 		printk("comedi: out: %8x on iobase %4lx\n", s->state,
-			dev->iobase + PCI7432_DO);
+		       dev->iobase + PCI7432_DO);
 		outl(s->state & 0xffffffff, dev->iobase + PCI7432_DO);
 	}
 	return 2;
 }
 
-static int adl_pci7432_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int adl_pci7432_di_insn_bits(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	printk("comedi: pci7432_di_insn_bits called\n");
 	printk("comedi: data0: %8x data1: %8x\n", data[0], data[1]);
--- a/drivers/staging/comedi/drivers/adl_pci8164.c
+++ b/drivers/staging/comedi/drivers/adl_pci8164.c
@@ -56,9 +56,10 @@ Configuration Options:
 #define PCI_DEVICE_ID_PCI8164 0x8164
 
 static DEFINE_PCI_DEVICE_TABLE(adl_pci8164_pci_table) = {
-	{PCI_VENDOR_ID_ADLINK, PCI_DEVICE_ID_PCI8164, PCI_ANY_ID, PCI_ANY_ID, 0,
-		0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_ADLINK, PCI_DEVICE_ID_PCI8164, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, adl_pci8164_pci_table);
@@ -70,7 +71,8 @@ struct adl_pci8164_private {
 
 #define devpriv ((struct adl_pci8164_private *)dev->private)
 
-static int adl_pci8164_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int adl_pci8164_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it);
 static int adl_pci8164_detach(struct comedi_device *dev);
 static struct comedi_driver driver_adl_pci8164 = {
 	.driver_name = "adl_pci8164",
@@ -79,31 +81,48 @@ static struct comedi_driver driver_adl_p
 	.detach = adl_pci8164_detach,
 };
 
-static int adl_pci8164_insn_read_msts(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int adl_pci8164_insn_read_msts(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data);
 
-static int adl_pci8164_insn_read_ssts(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int adl_pci8164_insn_read_ssts(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data);
 
-static int adl_pci8164_insn_read_buf0(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int adl_pci8164_insn_read_buf0(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data);
 
-static int adl_pci8164_insn_read_buf1(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int adl_pci8164_insn_read_buf1(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data);
 
-static int adl_pci8164_insn_write_cmd(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int adl_pci8164_insn_write_cmd(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data);
 
-static int adl_pci8164_insn_write_otp(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int adl_pci8164_insn_write_otp(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data);
 
 static int adl_pci8164_insn_write_buf0(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data);
 
 static int adl_pci8164_insn_write_buf1(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data);
 
-static int adl_pci8164_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int adl_pci8164_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev;
 	struct comedi_subdevice *s;
@@ -123,21 +142,23 @@ static int adl_pci8164_attach(struct com
 		return -ENOMEM;
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 
 		if (pcidev->vendor == PCI_VENDOR_ID_ADLINK &&
-			pcidev->device == PCI_DEVICE_ID_PCI8164) {
+		    pcidev->device == PCI_DEVICE_ID_PCI8164) {
 			if (bus || slot) {
 				/* requested particular bus/slot */
 				if (pcidev->bus->number != bus
-					|| PCI_SLOT(pcidev->devfn) != slot) {
+				    || PCI_SLOT(pcidev->devfn) != slot) {
 					continue;
 				}
 			}
 			devpriv->pci_dev = pcidev;
 			if (comedi_pci_enable(pcidev, "adl_pci8164") < 0) {
-				printk("comedi%d: Failed to enable PCI device and request regions\n", dev->minor);
+				printk
+				    ("comedi%d: Failed to enable PCI device and request regions\n",
+				     dev->minor);
 				return -EIO;
 			}
 			dev->iobase = pci_resource_start(pcidev, 2);
@@ -190,7 +211,7 @@ static int adl_pci8164_attach(struct com
 	}
 
 	printk("comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",
-		dev->minor, bus, slot);
+	       dev->minor, bus, slot);
 	return -EIO;
 }
 
@@ -216,8 +237,7 @@ static void adl_pci8164_insn_read(struct
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn,
 				  unsigned int *data,
-				  char *action,
-				  unsigned short offset)
+				  char *action, unsigned short offset)
 {
 	int axis, axis_reg;
 	char *axisname;
@@ -247,8 +267,8 @@ static void adl_pci8164_insn_read(struct
 	}
 
 	data[0] = inw(dev->iobase + axis_reg + offset);
-	printk("comedi: pci8164 %s read -> %04X:%04X on axis %s\n", action, data[0],
-		data[1], axisname);
+	printk("comedi: pci8164 %s read -> %04X:%04X on axis %s\n", action,
+	       data[0], data[1], axisname);
 }
 
 static int adl_pci8164_insn_read_msts(struct comedi_device *dev,
@@ -260,22 +280,28 @@ static int adl_pci8164_insn_read_msts(st
 	return 2;
 }
 
-static int adl_pci8164_insn_read_ssts(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int adl_pci8164_insn_read_ssts(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	adl_pci8164_insn_read(dev, s, insn, data, "SSTS", PCI8164_SSTS);
 	return 2;
 }
 
-static int adl_pci8164_insn_read_buf0(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int adl_pci8164_insn_read_buf0(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	adl_pci8164_insn_read(dev, s, insn, data, "BUF0", PCI8164_BUF0);
 	return 2;
 }
 
-static int adl_pci8164_insn_read_buf1(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int adl_pci8164_insn_read_buf1(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	adl_pci8164_insn_read(dev, s, insn, data, "BUF1", PCI8164_BUF1);
 	return 2;
@@ -286,11 +312,10 @@ static int adl_pci8164_insn_read_buf1(st
  * const to the data for outw()
  */
 static void adl_pci8164_insn_out(struct comedi_device *dev,
-					struct comedi_subdevice *s,
-					struct comedi_insn *insn,
-					unsigned int *data,
-					char *action,
-					unsigned short offset)
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data,
+				 char *action, unsigned short offset)
 {
 	unsigned int axis, axis_reg;
 
@@ -327,30 +352,37 @@ static void adl_pci8164_insn_out(struct 
 
 }
 
-
-static int adl_pci8164_insn_write_cmd(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int adl_pci8164_insn_write_cmd(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	adl_pci8164_insn_out(dev, s, insn, data, "CMD", PCI8164_CMD);
 	return 2;
 }
 
-static int adl_pci8164_insn_write_otp(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int adl_pci8164_insn_write_otp(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	adl_pci8164_insn_out(dev, s, insn, data, "OTP", PCI8164_OTP);
 	return 2;
 }
 
 static int adl_pci8164_insn_write_buf0(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data)
 {
 	adl_pci8164_insn_out(dev, s, insn, data, "BUF0", PCI8164_BUF0);
 	return 2;
 }
 
 static int adl_pci8164_insn_write_buf1(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data)
 {
 	adl_pci8164_insn_out(dev, s, insn, data, "BUF1", PCI8164_BUF1);
 	return 2;
--- a/drivers/staging/comedi/drivers/adl_pci9111.c
+++ b/drivers/staging/comedi/drivers/adl_pci9111.c
@@ -264,27 +264,32 @@ TODO:
 
 /*  Function prototypes */
 
-static int pci9111_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci9111_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pci9111_detach(struct comedi_device *dev);
-static void pci9111_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *data, unsigned int num_bytes, unsigned int start_chan_index);
+static void pci9111_ai_munge(struct comedi_device *dev,
+			     struct comedi_subdevice *s, void *data,
+			     unsigned int num_bytes,
+			     unsigned int start_chan_index);
 
 static const struct comedi_lrange pci9111_hr_ai_range = {
 	5,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 BIP_RANGE(0.625)
+	 }
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci9111_pci_table) = {
-	{PCI_VENDOR_ID_ADLINK, PCI9111_HR_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0,
-		0, 0},
-	/* { PCI_VENDOR_ID_ADLINK, PCI9111_HG_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
-	{0}
+	{
+	PCI_VENDOR_ID_ADLINK, PCI9111_HR_DEVICE_ID, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0},
+	    /* { PCI_VENDOR_ID_ADLINK, PCI9111_HG_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
+	{
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci9111_pci_table);
@@ -309,17 +314,17 @@ struct pci9111_board {
 
 static const struct pci9111_board pci9111_boards[] = {
 	{
-	.name = "pci9111_hr",
-	.device_id = PCI9111_HR_DEVICE_ID,
-	.ai_channel_nbr = PCI9111_AI_CHANNEL_NBR,
-	.ao_channel_nbr = PCI9111_AO_CHANNEL_NBR,
-	.ai_resolution = PCI9111_HR_AI_RESOLUTION,
-	.ai_resolution_mask = PCI9111_HR_AI_RESOLUTION_MASK,
-	.ao_resolution = PCI9111_AO_RESOLUTION,
-	.ao_resolution_mask = PCI9111_AO_RESOLUTION_MASK,
-	.ai_range_list = &pci9111_hr_ai_range,
-	.ao_range_list = &range_bipolar10,
-	.ai_acquisition_period_min_ns = PCI9111_AI_ACQUISITION_PERIOD_MIN_NS}
+	 .name = "pci9111_hr",
+	 .device_id = PCI9111_HR_DEVICE_ID,
+	 .ai_channel_nbr = PCI9111_AI_CHANNEL_NBR,
+	 .ao_channel_nbr = PCI9111_AO_CHANNEL_NBR,
+	 .ai_resolution = PCI9111_HR_AI_RESOLUTION,
+	 .ai_resolution_mask = PCI9111_HR_AI_RESOLUTION_MASK,
+	 .ao_resolution = PCI9111_AO_RESOLUTION,
+	 .ao_resolution_mask = PCI9111_AO_RESOLUTION_MASK,
+	 .ai_range_list = &pci9111_hr_ai_range,
+	 .ao_range_list = &range_bipolar10,
+	 .ai_acquisition_period_min_ns = PCI9111_AI_ACQUISITION_PERIOD_MIN_NS}
 };
 
 #define pci9111_board_nbr \
@@ -379,9 +384,11 @@ struct pci9111_private_data {
 #define PLX9050_SOFTWARE_INTERRUPT	(1 << 7)
 
 static void plx9050_interrupt_control(unsigned long io_base,
-	bool LINTi1_enable,
-	bool LINTi1_active_high,
-	bool LINTi2_enable, bool LINTi2_active_high, bool interrupt_enable)
+				      bool LINTi1_enable,
+				      bool LINTi1_active_high,
+				      bool LINTi2_enable,
+				      bool LINTi2_active_high,
+				      bool interrupt_enable)
 {
 	int flags = 0;
 
@@ -409,16 +416,19 @@ static void plx9050_interrupt_control(un
 static void pci9111_timer_set(struct comedi_device *dev)
 {
 	pci9111_8254_control_set(PCI9111_8254_COUNTER_0 |
-		PCI9111_8254_READ_LOAD_LSB_MSB |
-		PCI9111_8254_MODE_0 | PCI9111_8254_BINARY_COUNTER);
+				 PCI9111_8254_READ_LOAD_LSB_MSB |
+				 PCI9111_8254_MODE_0 |
+				 PCI9111_8254_BINARY_COUNTER);
 
 	pci9111_8254_control_set(PCI9111_8254_COUNTER_1 |
-		PCI9111_8254_READ_LOAD_LSB_MSB |
-		PCI9111_8254_MODE_2 | PCI9111_8254_BINARY_COUNTER);
+				 PCI9111_8254_READ_LOAD_LSB_MSB |
+				 PCI9111_8254_MODE_2 |
+				 PCI9111_8254_BINARY_COUNTER);
 
 	pci9111_8254_control_set(PCI9111_8254_COUNTER_2 |
-		PCI9111_8254_READ_LOAD_LSB_MSB |
-		PCI9111_8254_MODE_2 | PCI9111_8254_BINARY_COUNTER);
+				 PCI9111_8254_READ_LOAD_LSB_MSB |
+				 PCI9111_8254_MODE_2 |
+				 PCI9111_8254_BINARY_COUNTER);
 
 	udelay(1);
 
@@ -433,7 +443,7 @@ enum pci9111_trigger_sources {
 };
 
 static void pci9111_trigger_source_set(struct comedi_device *dev,
-	enum pci9111_trigger_sources source)
+				       enum pci9111_trigger_sources source)
 {
 	int flags;
 
@@ -491,7 +501,8 @@ enum pci9111_ISC1_sources {
 };
 
 static void pci9111_interrupt_source_set(struct comedi_device *dev,
-	enum pci9111_ISC0_sources irq_0_source, enum pci9111_ISC1_sources irq_1_source)
+					 enum pci9111_ISC0_sources irq_0_source,
+					 enum pci9111_ISC1_sources irq_1_source)
 {
 	int flags;
 
@@ -514,12 +525,13 @@ static void pci9111_interrupt_source_set
 
 #undef AI_DO_CMD_DEBUG
 
-static int pci9111_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci9111_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	/*  Disable interrupts */
 
 	plx9050_interrupt_control(dev_private->lcr_io_base, true, true, true,
-		true, false);
+				  true, false);
 
 	pci9111_trigger_source_set(dev, software);
 
@@ -543,19 +555,19 @@ static int pci9111_ai_cancel(struct come
 
 static int
 pci9111_ai_do_cmd_test(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd)
+		       struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int tmp;
 	int error = 0;
 	int range, reference;
 	int i;
-	struct pci9111_board *board = (struct pci9111_board *) dev->board_ptr;
+	struct pci9111_board *board = (struct pci9111_board *)dev->board_ptr;
 
 	/*  Step 1 : check if trigger are trivialy valid */
 
 	pci9111_check_trigger_src(cmd->start_src, TRIG_NOW);
 	pci9111_check_trigger_src(cmd->scan_begin_src,
-		TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);
+				  TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);
 	pci9111_check_trigger_src(cmd->convert_src, TRIG_TIMER | TRIG_EXT);
 	pci9111_check_trigger_src(cmd->scan_end_src, TRIG_COUNT);
 	pci9111_check_trigger_src(cmd->stop_src, TRIG_COUNT | TRIG_NONE);
@@ -569,21 +581,21 @@ pci9111_ai_do_cmd_test(struct comedi_dev
 		error++;
 
 	if ((cmd->scan_begin_src != TRIG_TIMER) &&
-		(cmd->scan_begin_src != TRIG_FOLLOW) &&
-		(cmd->scan_begin_src != TRIG_EXT))
+	    (cmd->scan_begin_src != TRIG_FOLLOW) &&
+	    (cmd->scan_begin_src != TRIG_EXT))
 		error++;
 
 	if ((cmd->convert_src != TRIG_TIMER) && (cmd->convert_src != TRIG_EXT)) {
 		error++;
 	}
 	if ((cmd->convert_src == TRIG_TIMER) &&
-		!((cmd->scan_begin_src == TRIG_TIMER) ||
-			(cmd->scan_begin_src == TRIG_FOLLOW))) {
+	    !((cmd->scan_begin_src == TRIG_TIMER) ||
+	      (cmd->scan_begin_src == TRIG_FOLLOW))) {
 		error++;
 	}
 	if ((cmd->convert_src == TRIG_EXT) &&
-		!((cmd->scan_begin_src == TRIG_EXT) ||
-			(cmd->scan_begin_src == TRIG_FOLLOW))) {
+	    !((cmd->scan_begin_src == TRIG_EXT) ||
+	      (cmd->scan_begin_src == TRIG_FOLLOW))) {
 		error++;
 	}
 
@@ -613,7 +625,7 @@ pci9111_ai_do_cmd_test(struct comedi_dev
 	}
 
 	if ((cmd->convert_src == TRIG_TIMER) &&
-		(cmd->convert_arg < board->ai_acquisition_period_min_ns)) {
+	    (cmd->convert_arg < board->ai_acquisition_period_min_ns)) {
 		cmd->convert_arg = board->ai_acquisition_period_min_ns;
 		error++;
 	}
@@ -623,7 +635,7 @@ pci9111_ai_do_cmd_test(struct comedi_dev
 	}
 
 	if ((cmd->scan_begin_src == TRIG_TIMER) &&
-		(cmd->scan_begin_arg < board->ai_acquisition_period_min_ns)) {
+	    (cmd->scan_begin_arg < board->ai_acquisition_period_min_ns)) {
 		cmd->scan_begin_arg = board->ai_acquisition_period_min_ns;
 		error++;
 	}
@@ -637,7 +649,7 @@ pci9111_ai_do_cmd_test(struct comedi_dev
 	}
 
 	if ((cmd->scan_end_src == TRIG_COUNT) &&
-		(cmd->scan_end_arg != cmd->chanlist_len)) {
+	    (cmd->scan_end_arg != cmd->chanlist_len)) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		error++;
 	}
@@ -659,9 +671,10 @@ pci9111_ai_do_cmd_test(struct comedi_dev
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer_2div(PCI9111_8254_CLOCK_PERIOD_NS,
-			&(dev_private->timer_divisor_1),
-			&(dev_private->timer_divisor_2),
-			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(dev_private->timer_divisor_1),
+					       &(dev_private->timer_divisor_2),
+					       &(cmd->convert_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			error++;
 	}
@@ -679,7 +692,7 @@ pci9111_ai_do_cmd_test(struct comedi_dev
 		if (cmd->scan_begin_arg != scan_begin_min) {
 			if (scan_begin_min < cmd->scan_begin_arg) {
 				scan_factor =
-					cmd->scan_begin_arg / scan_begin_min;
+				    cmd->scan_begin_arg / scan_begin_min;
 				scan_begin_arg = scan_factor * scan_begin_min;
 				if (cmd->scan_begin_arg != scan_begin_arg) {
 					cmd->scan_begin_arg = scan_begin_arg;
@@ -706,27 +719,27 @@ pci9111_ai_do_cmd_test(struct comedi_dev
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				if (CR_CHAN(cmd->chanlist[i]) != i) {
 					comedi_error(dev,
-						"entries in chanlist must be consecutive "
-						"channels,counting upwards from 0\n");
+						     "entries in chanlist must be consecutive "
+						     "channels,counting upwards from 0\n");
 					error++;
 				}
 				if (CR_RANGE(cmd->chanlist[i]) != range) {
 					comedi_error(dev,
-						"entries in chanlist must all have the same gain\n");
+						     "entries in chanlist must all have the same gain\n");
 					error++;
 				}
 				if (CR_AREF(cmd->chanlist[i]) != reference) {
 					comedi_error(dev,
-						"entries in chanlist must all have the same reference\n");
+						     "entries in chanlist must all have the same reference\n");
 					error++;
 				}
 			}
 		} else {
 			if ((CR_CHAN(cmd->chanlist[0]) >
-					(board->ai_channel_nbr - 1))
-				|| (CR_CHAN(cmd->chanlist[0]) < 0)) {
+			     (board->ai_channel_nbr - 1))
+			    || (CR_CHAN(cmd->chanlist[0]) < 0)) {
 				comedi_error(dev,
-					"channel number is out of limits\n");
+					     "channel number is out of limits\n");
 				error++;
 			}
 		}
@@ -741,13 +754,14 @@ pci9111_ai_do_cmd_test(struct comedi_dev
 
 /*  Analog input command */
 
-static int pci9111_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *subdevice)
+static int pci9111_ai_do_cmd(struct comedi_device *dev,
+			     struct comedi_subdevice *subdevice)
 {
 	struct comedi_cmd *async_cmd = &subdevice->async->cmd;
 
 	if (!dev->irq) {
 		comedi_error(dev,
-			"no irq assigned for PCI9111, cannot do hardware conversion");
+			     "no irq assigned for PCI9111, cannot do hardware conversion");
 		return -1;
 	}
 	/*  Set channel scan limit */
@@ -772,7 +786,7 @@ static int pci9111_ai_do_cmd(struct come
 	switch (async_cmd->stop_src) {
 	case TRIG_COUNT:
 		dev_private->stop_counter =
-			async_cmd->stop_arg * async_cmd->chanlist_len;
+		    async_cmd->stop_arg * async_cmd->chanlist_len;
 		dev_private->stop_is_none = 0;
 		break;
 
@@ -792,28 +806,29 @@ static int pci9111_ai_do_cmd(struct come
 	switch (async_cmd->convert_src) {
 	case TRIG_TIMER:
 		i8253_cascade_ns_to_timer_2div(PCI9111_8254_CLOCK_PERIOD_NS,
-			&(dev_private->timer_divisor_1),
-			&(dev_private->timer_divisor_2),
-			&(async_cmd->convert_arg),
-			async_cmd->flags & TRIG_ROUND_MASK);
+					       &(dev_private->timer_divisor_1),
+					       &(dev_private->timer_divisor_2),
+					       &(async_cmd->convert_arg),
+					       async_cmd->
+					       flags & TRIG_ROUND_MASK);
 #ifdef AI_DO_CMD_DEBUG
 		printk(PCI9111_DRIVER_NAME ": divisors = %d, %d\n",
-			dev_private->timer_divisor_1,
-			dev_private->timer_divisor_2);
+		       dev_private->timer_divisor_1,
+		       dev_private->timer_divisor_2);
 #endif
 
 		pci9111_trigger_source_set(dev, software);
 		pci9111_timer_set(dev);
 		pci9111_fifo_reset();
 		pci9111_interrupt_source_set(dev, irq_on_fifo_half_full,
-			irq_on_timer_tick);
+					     irq_on_timer_tick);
 		pci9111_trigger_source_set(dev, timer_pacer);
 		plx9050_interrupt_control(dev_private->lcr_io_base, true, true,
-			false, true, true);
+					  false, true, true);
 
 		dev_private->scan_delay =
-			(async_cmd->scan_begin_arg / (async_cmd->convert_arg *
-				async_cmd->chanlist_len)) - 1;
+		    (async_cmd->scan_begin_arg / (async_cmd->convert_arg *
+						  async_cmd->chanlist_len)) - 1;
 
 		break;
 
@@ -822,9 +837,9 @@ static int pci9111_ai_do_cmd(struct come
 		pci9111_trigger_source_set(dev, external);
 		pci9111_fifo_reset();
 		pci9111_interrupt_source_set(dev, irq_on_fifo_half_full,
-			irq_on_timer_tick);
+					     irq_on_timer_tick);
 		plx9050_interrupt_control(dev_private->lcr_io_base, true, true,
-			false, true, true);
+					  false, true, true);
 
 		break;
 
@@ -837,45 +852,47 @@ static int pci9111_ai_do_cmd(struct come
 	dev_private->chanlist_len = async_cmd->chanlist_len;
 	dev_private->chunk_counter = 0;
 	dev_private->chunk_num_samples =
-		dev_private->chanlist_len * (1 + dev_private->scan_delay);
+	    dev_private->chanlist_len * (1 + dev_private->scan_delay);
 
 #ifdef AI_DO_CMD_DEBUG
 	printk(PCI9111_DRIVER_NAME ": start interruptions!\n");
 	printk(PCI9111_DRIVER_NAME ": trigger source = %2x\n",
-		pci9111_trigger_and_autoscan_get());
+	       pci9111_trigger_and_autoscan_get());
 	printk(PCI9111_DRIVER_NAME ": irq source     = %2x\n",
-		pci9111_interrupt_and_fifo_get());
+	       pci9111_interrupt_and_fifo_get());
 	printk(PCI9111_DRIVER_NAME ": ai_do_cmd\n");
 	printk(PCI9111_DRIVER_NAME ": stop counter   = %d\n",
-		dev_private->stop_counter);
+	       dev_private->stop_counter);
 	printk(PCI9111_DRIVER_NAME ": scan delay     = %d\n",
-		dev_private->scan_delay);
+	       dev_private->scan_delay);
 	printk(PCI9111_DRIVER_NAME ": chanlist_len   = %d\n",
-		dev_private->chanlist_len);
+	       dev_private->chanlist_len);
 	printk(PCI9111_DRIVER_NAME ": chunk num samples = %d\n",
-		dev_private->chunk_num_samples);
+	       dev_private->chunk_num_samples);
 #endif
 
 	return 0;
 }
 
-static void pci9111_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *data, unsigned int num_bytes, unsigned int start_chan_index)
+static void pci9111_ai_munge(struct comedi_device *dev,
+			     struct comedi_subdevice *s, void *data,
+			     unsigned int num_bytes,
+			     unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
 	short *array = data;
 	int resolution =
-		((struct pci9111_board *) dev->board_ptr)->ai_resolution;
+	    ((struct pci9111_board *)dev->board_ptr)->ai_resolution;
 
 	for (i = 0; i < num_samples; i++) {
 		if (resolution == PCI9111_HR_AI_RESOLUTION)
 			array[i] =
-				(array[i] & PCI9111_HR_AI_RESOLUTION_MASK) ^
-				PCI9111_HR_AI_RESOLUTION_2_CMP_BIT;
+			    (array[i] & PCI9111_HR_AI_RESOLUTION_MASK) ^
+			    PCI9111_HR_AI_RESOLUTION_2_CMP_BIT;
 		else
 			array[i] =
-				((array[i] >> 4) & PCI9111_AI_RESOLUTION_MASK) ^
-				PCI9111_AI_RESOLUTION_2_CMP_BIT;
+			    ((array[i] >> 4) & PCI9111_AI_RESOLUTION_MASK) ^
+			    PCI9111_AI_RESOLUTION_2_CMP_BIT;
 	}
 }
 
@@ -905,18 +922,12 @@ static irqreturn_t pci9111_interrupt(int
 
 	/*  Check if we are source of interrupt */
 	intcsr = inb(dev_private->lcr_io_base +
-		PLX9050_REGISTER_INTERRUPT_CONTROL);
+		     PLX9050_REGISTER_INTERRUPT_CONTROL);
 	if (!(((intcsr & PLX9050_PCI_INTERRUPT_ENABLE) != 0)
-			&& (((intcsr & (PLX9050_LINTI1_ENABLE |
-							PLX9050_LINTI1_STATUS))
-					==
-					(PLX9050_LINTI1_ENABLE |
-						PLX9050_LINTI1_STATUS))
-				|| ((intcsr & (PLX9050_LINTI2_ENABLE |
-							PLX9050_LINTI2_STATUS))
-					==
-					(PLX9050_LINTI2_ENABLE |
-						PLX9050_LINTI2_STATUS))))) {
+	      && (((intcsr & (PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS))
+		   == (PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS))
+		  || ((intcsr & (PLX9050_LINTI2_ENABLE | PLX9050_LINTI2_STATUS))
+		      == (PLX9050_LINTI2_ENABLE | PLX9050_LINTI2_STATUS))))) {
 		/*  Not the source of the interrupt. */
 		/*  (N.B. not using PLX9050_SOFTWARE_INTERRUPT) */
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
@@ -924,12 +935,11 @@ static irqreturn_t pci9111_interrupt(int
 	}
 
 	if ((intcsr & (PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS)) ==
-		(PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS)) {
+	    (PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS)) {
 		/*  Interrupt comes from fifo_half-full signal */
 
 		if (pci9111_is_fifo_full()) {
-			spin_unlock_irqrestore(&dev->spinlock,
-				irq_flags);
+			spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 			comedi_error(dev, PCI9111_DRIVER_NAME " fifo overflow");
 			pci9111_interrupt_clear();
 			pci9111_ai_cancel(dev, subdevice);
@@ -948,73 +958,70 @@ static irqreturn_t pci9111_interrupt(int
 #endif
 
 			num_samples =
-				PCI9111_FIFO_HALF_SIZE >
-				dev_private->stop_counter
-				&& !dev_private->stop_is_none ? dev_private->
-				stop_counter : PCI9111_FIFO_HALF_SIZE;
+			    PCI9111_FIFO_HALF_SIZE >
+			    dev_private->stop_counter
+			    && !dev_private->
+			    stop_is_none ? dev_private->stop_counter :
+			    PCI9111_FIFO_HALF_SIZE;
 			insw(PCI9111_IO_BASE + PCI9111_REGISTER_AD_FIFO_VALUE,
-				dev_private->ai_bounce_buffer, num_samples);
+			     dev_private->ai_bounce_buffer, num_samples);
 
 			if (dev_private->scan_delay < 1) {
 				bytes_written =
-					cfc_write_array_to_buffer(subdevice,
-					dev_private->ai_bounce_buffer,
-					num_samples * sizeof(short));
+				    cfc_write_array_to_buffer(subdevice,
+							      dev_private->
+							      ai_bounce_buffer,
+							      num_samples *
+							      sizeof(short));
 			} else {
 				int position = 0;
 				int to_read;
 
 				while (position < num_samples) {
 					if (dev_private->chunk_counter <
-						dev_private->chanlist_len) {
+					    dev_private->chanlist_len) {
 						to_read =
-							dev_private->
-							chanlist_len -
-							dev_private->
-							chunk_counter;
+						    dev_private->chanlist_len -
+						    dev_private->chunk_counter;
 
 						if (to_read >
-							num_samples - position)
+						    num_samples - position)
 							to_read =
-								num_samples -
-								position;
+							    num_samples -
+							    position;
 
 						bytes_written +=
-							cfc_write_array_to_buffer
-							(subdevice,
-							dev_private->
-							ai_bounce_buffer +
-							position,
-							to_read *
-							sizeof(short));
+						    cfc_write_array_to_buffer
+						    (subdevice,
+						     dev_private->ai_bounce_buffer
+						     + position,
+						     to_read * sizeof(short));
 					} else {
 						to_read =
-							dev_private->
-							chunk_num_samples -
-							dev_private->
-							chunk_counter;
+						    dev_private->chunk_num_samples
+						    -
+						    dev_private->chunk_counter;
 						if (to_read >
-							num_samples - position)
+						    num_samples - position)
 							to_read =
-								num_samples -
-								position;
+							    num_samples -
+							    position;
 
 						bytes_written +=
-							sizeof(short) *
-							to_read;
+						    sizeof(short) * to_read;
 					}
 
 					position += to_read;
 					dev_private->chunk_counter += to_read;
 
 					if (dev_private->chunk_counter >=
-						dev_private->chunk_num_samples)
+					    dev_private->chunk_num_samples)
 						dev_private->chunk_counter = 0;
 				}
 			}
 
 			dev_private->stop_counter -=
-				bytes_written / sizeof(short);
+			    bytes_written / sizeof(short);
 		}
 	}
 
@@ -1044,17 +1051,18 @@ static irqreturn_t pci9111_interrupt(int
 #undef AI_INSN_DEBUG
 
 static int pci9111_ai_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *subdevice, struct comedi_insn *insn, unsigned int *data)
+				struct comedi_subdevice *subdevice,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int resolution =
-		((struct pci9111_board *) dev->board_ptr)->ai_resolution;
+	    ((struct pci9111_board *)dev->board_ptr)->ai_resolution;
 
 	int timeout, i;
 
 #ifdef AI_INSN_DEBUG
 	printk(PCI9111_DRIVER_NAME ": ai_insn set c/r/n = %2x/%2x/%2x\n",
-		CR_CHAN((&insn->chanspec)[0]),
-		CR_RANGE((&insn->chanspec)[0]), insn->n);
+	       CR_CHAN((&insn->chanspec)[0]),
+	       CR_RANGE((&insn->chanspec)[0]), insn->n);
 #endif
 
 	pci9111_ai_channel_set(CR_CHAN((&insn->chanspec)[0]));
@@ -1080,7 +1088,7 @@ static int pci9111_ai_insn_read(struct c
 		pci9111_fifo_reset();
 		return -ETIME;
 
-	      conversion_done:
+conversion_done:
 
 		if (resolution == PCI9111_HR_AI_RESOLUTION) {
 			data[i] = pci9111_hr_ai_get_data();
@@ -1091,8 +1099,8 @@ static int pci9111_ai_insn_read(struct c
 
 #ifdef AI_INSN_DEBUG
 	printk(PCI9111_DRIVER_NAME ": ai_insn get c/r/t = %2x/%2x/%2x\n",
-		pci9111_ai_channel_get(),
-		pci9111_ai_range_get(), pci9111_trigger_and_autoscan_get());
+	       pci9111_ai_channel_get(),
+	       pci9111_ai_range_get(), pci9111_trigger_and_autoscan_get());
 #endif
 
 	return i;
@@ -1102,7 +1110,8 @@ static int pci9111_ai_insn_read(struct c
 
 static int
 pci9111_ao_insn_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+		      struct comedi_subdevice *s, struct comedi_insn *insn,
+		      unsigned int *data)
 {
 	int i;
 
@@ -1117,7 +1126,8 @@ pci9111_ao_insn_write(struct comedi_devi
 /*  Analog output readback */
 
 static int pci9111_ao_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -1135,7 +1145,8 @@ static int pci9111_ao_insn_read(struct c
 /*  Digital inputs */
 
 static int pci9111_di_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *subdevice, struct comedi_insn *insn, unsigned int *data)
+				struct comedi_subdevice *subdevice,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -1148,7 +1159,8 @@ static int pci9111_di_insn_bits(struct c
 /*  Digital outputs */
 
 static int pci9111_do_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *subdevice, struct comedi_insn *insn, unsigned int *data)
+				struct comedi_subdevice *subdevice,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -1181,7 +1193,7 @@ static int pci9111_reset(struct comedi_d
 	/*  Set trigger source to software */
 
 	plx9050_interrupt_control(dev_private->lcr_io_base, true, true, true,
-		true, false);
+				  true, false);
 
 	pci9111_trigger_source_set(dev, software);
 	pci9111_pretrigger_set(dev, false);
@@ -1201,7 +1213,8 @@ static int pci9111_reset(struct comedi_d
 /*       - Register PCI device */
 /*       - Declare device driver capability */
 
-static int pci9111_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci9111_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *subdevice;
 	unsigned long io_base, io_range, lcr_io_base, lcr_io_range;
@@ -1217,29 +1230,29 @@ static int pci9111_attach(struct comedi_
 	printk("comedi%d: " PCI9111_DRIVER_NAME " driver\n", dev->minor);
 
 	for (pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pci_device != NULL;
-		pci_device =
-		pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_device)) {
+	     pci_device != NULL;
+	     pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_device)) {
 		if (pci_device->vendor == PCI_VENDOR_ID_ADLINK) {
 			for (i = 0; i < pci9111_board_nbr; i++) {
 				if (pci9111_boards[i].device_id ==
-					pci_device->device) {
+				    pci_device->device) {
 					/*  was a particular bus/slot requested? */
 					if ((it->options[0] != 0)
-						|| (it->options[1] != 0)) {
+					    || (it->options[1] != 0)) {
 						/*  are we on the wrong bus/slot? */
 						if (pci_device->bus->number !=
-							it->options[0]
-							|| PCI_SLOT(pci_device->
-								devfn) !=
-							it->options[1]) {
+						    it->options[0]
+						    ||
+						    PCI_SLOT(pci_device->devfn)
+						    != it->options[1]) {
 							continue;
 						}
 					}
 
 					dev->board_ptr = pci9111_boards + i;
-					board = (struct pci9111_board *) dev->
-						board_ptr;
+					board =
+					    (struct pci9111_board *)
+					    dev->board_ptr;
 					dev_private->pci_device = pci_device;
 					goto found;
 				}
@@ -1248,17 +1261,17 @@ static int pci9111_attach(struct comedi_
 	}
 
 	printk("comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",
-		dev->minor, it->options[0], it->options[1]);
+	       dev->minor, it->options[0], it->options[1]);
 	return -EIO;
 
-      found:
+found:
 
 	printk("comedi%d: found %s (b:s:f=%d:%d:%d) , irq=%d\n",
-		dev->minor,
-		pci9111_boards[i].name,
-		pci_device->bus->number,
-		PCI_SLOT(pci_device->devfn),
-		PCI_FUNC(pci_device->devfn), pci_device->irq);
+	       dev->minor,
+	       pci9111_boards[i].name,
+	       pci_device->bus->number,
+	       PCI_SLOT(pci_device->devfn),
+	       PCI_FUNC(pci_device->devfn), pci_device->irq);
 
 	/*  TODO: Warn about non-tested boards. */
 
@@ -1270,11 +1283,15 @@ static int pci9111_attach(struct comedi_
 	lcr_io_base = pci_resource_start(pci_device, 1);
 	lcr_io_range = pci_resource_len(pci_device, 1);
 
-	printk("comedi%d: local configuration registers at address 0x%4lx [0x%4lx]\n", dev->minor, lcr_io_base, lcr_io_range);
+	printk
+	    ("comedi%d: local configuration registers at address 0x%4lx [0x%4lx]\n",
+	     dev->minor, lcr_io_base, lcr_io_range);
 
 	/*  Enable PCI device and request regions */
 	if (comedi_pci_enable(pci_device, PCI9111_DRIVER_NAME) < 0) {
-		printk("comedi%d: Failed to enable PCI device and request regions\n", dev->minor);
+		printk
+		    ("comedi%d: Failed to enable PCI device and request regions\n",
+		     dev->minor);
 		return -EIO;
 	}
 	/*  Read PCI6308 register base address [PCI_BASE_ADDRESS #2]. */
@@ -1283,7 +1300,7 @@ static int pci9111_attach(struct comedi_
 	io_range = pci_resource_len(pci_device, 2);
 
 	printk("comedi%d: 6503 registers at address 0x%4lx [0x%4lx]\n",
-		dev->minor, io_base, io_range);
+	       dev->minor, io_base, io_range);
 
 	dev->iobase = io_base;
 	dev->board_name = board->name;
@@ -1301,7 +1318,7 @@ static int pci9111_attach(struct comedi_
 		if (request_irq(pci_device->irq, pci9111_interrupt,
 				IRQF_SHARED, PCI9111_DRIVER_NAME, dev) != 0) {
 			printk("comedi%d: unable to allocate irq  %u\n",
-				dev->minor, pci_device->irq);
+			       dev->minor, pci_device->irq);
 			return -EINVAL;
 		}
 	}
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -154,32 +154,33 @@ Configuration options:
 #define EXTTRG_AI	0	/* ext trg is used by AI */
 
 static const struct comedi_lrange range_pci9118dg_hr = { 8, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     BIP_RANGE(0.625),
+							     UNI_RANGE(10),
+							     UNI_RANGE(5),
+							     UNI_RANGE(2.5),
+							     UNI_RANGE(1.25)
+							     }
 };
 
 static const struct comedi_lrange range_pci9118hg = { 8, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.005),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01)
-	}
+							  BIP_RANGE(5),
+							  BIP_RANGE(0.5),
+							  BIP_RANGE(0.05),
+							  BIP_RANGE(0.005),
+							  UNI_RANGE(10),
+							  UNI_RANGE(1),
+							  UNI_RANGE(0.1),
+							  UNI_RANGE(0.01)
+							  }
 };
 
 #define PCI9118_BIPOLAR_RANGES	4	/* used for test on mixture of BIP/UNI ranges */
 
-static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci9118_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pci9118_detach(struct comedi_device *dev);
 
 struct boardtype {
@@ -204,28 +205,29 @@ struct boardtype {
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci9118_pci_table) = {
-	{PCI_VENDOR_ID_AMCC, 0x80d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMCC, 0x80d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci9118_pci_table);
 
 static const struct boardtype boardtypes[] = {
 	{"pci9118dg", PCI_VENDOR_ID_AMCC, 0x80d9,
-			AMCC_OP_REG_SIZE, IORANGE_9118,
-			16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
-			&range_pci9118dg_hr, &range_bipolar10,
-		3000, 12, 512},
+	 AMCC_OP_REG_SIZE, IORANGE_9118,
+	 16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
+	 &range_pci9118dg_hr, &range_bipolar10,
+	 3000, 12, 512},
 	{"pci9118hg", PCI_VENDOR_ID_AMCC, 0x80d9,
-			AMCC_OP_REG_SIZE, IORANGE_9118,
-			16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
-			&range_pci9118hg, &range_bipolar10,
-		3000, 12, 512},
+	 AMCC_OP_REG_SIZE, IORANGE_9118,
+	 16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
+	 &range_pci9118hg, &range_bipolar10,
+	 3000, 12, 512},
 	{"pci9118hr", PCI_VENDOR_ID_AMCC, 0x80d9,
-			AMCC_OP_REG_SIZE, IORANGE_9118,
-			16, 8, 256, PCI9118_CHANLEN, 2, 0xffff, 0x0fff,
-			&range_pci9118dg_hr, &range_bipolar10,
-		10000, 40, 512},
+	 AMCC_OP_REG_SIZE, IORANGE_9118,
+	 16, 8, 256, PCI9118_CHANLEN, 2, 0xffff, 0x0fff,
+	 &range_pci9118dg_hr, &range_bipolar10,
+	 10000, 40, 512},
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct boardtype))
@@ -309,27 +311,34 @@ struct pci9118_private {
 ==============================================================================
 */
 
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n_chan, unsigned int *chanlist, int frontadd, int backadd);
-static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
-	int usedma, char eoshandle);
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2);
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int n_chan,
+			      unsigned int *chanlist, int frontadd,
+			      int backadd);
+static int setup_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int n_chan,
+			      unsigned int *chanlist, int rot, int frontadd,
+			      int backadd, int usedma, char eoshandle);
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2);
 static int pci9118_reset(struct comedi_device *dev);
 static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source);
 static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source);
-static int pci9118_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci9118_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int *tim1, unsigned int *tim2,
-	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
-	char usessh, unsigned int chnsshfront);
+				  struct comedi_subdevice *s,
+				  unsigned int *tim1, unsigned int *tim2,
+				  unsigned int flags, int chans,
+				  unsigned int *div1, unsigned int *div2,
+				  char usessh, unsigned int chnsshfront);
 
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ai(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_read_ai(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 
 	int n, timeout;
@@ -358,15 +367,14 @@ static int pci9118_insn_read_ai(struct c
 		outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 		return -ETIME;
 
-	      conv_finish:
+conv_finish:
 		if (devpriv->ai16bits) {
 			data[n] =
-				(inl(dev->iobase +
-					PCI9118_AD_DATA) & 0xffff) ^ 0x8000;
+			    (inl(dev->iobase +
+				 PCI9118_AD_DATA) & 0xffff) ^ 0x8000;
 		} else {
 			data[n] =
-				(inw(dev->iobase +
-					PCI9118_AD_DATA) >> 4) & 0xfff;
+			    (inw(dev->iobase + PCI9118_AD_DATA) >> 4) & 0xfff;
 		}
 	}
 
@@ -378,8 +386,9 @@ static int pci9118_insn_read_ai(struct c
 /*
 ==============================================================================
 */
-static int pci9118_insn_write_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_write_ao(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chanreg, ch;
 
@@ -401,8 +410,9 @@ static int pci9118_insn_write_ao(struct 
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_read_ao(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan;
 
@@ -416,8 +426,9 @@ static int pci9118_insn_read_ao(struct c
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_di(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_bits_di(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
 
@@ -427,8 +438,9 @@ static int pci9118_insn_bits_di(struct c
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_do(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_bits_do(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -446,29 +458,31 @@ static int pci9118_insn_bits_do(struct c
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	devpriv->AdFunctionReg =
-		AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
+	    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
 	outl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1) & 0xff,
-		dev->iobase + PCI9118_CNT0);
+	     dev->iobase + PCI9118_CNT0);
 	outl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 9) & 0xff,
-		dev->iobase + PCI9118_CNT0);
+	     dev->iobase + PCI9118_CNT0);
 	devpriv->AdFunctionReg |= AdFunction_Start;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 }
 
 static unsigned int defragment_dma_buffer(struct comedi_device *dev,
-	struct comedi_subdevice *s, short *dma_buffer, unsigned int num_samples)
+					  struct comedi_subdevice *s,
+					  short *dma_buffer,
+					  unsigned int num_samples)
 {
 	unsigned int i = 0, j = 0;
 	unsigned int start_pos = devpriv->ai_add_front,
-		stop_pos = devpriv->ai_add_front + devpriv->ai_n_chan;
+	    stop_pos = devpriv->ai_add_front + devpriv->ai_n_chan;
 	unsigned int raw_scanlen = devpriv->ai_add_front + devpriv->ai_n_chan +
-		devpriv->ai_add_back;
+	    devpriv->ai_add_back;
 
 	for (i = 0; i < num_samples; i++) {
 		if (devpriv->ai_act_dmapos >= start_pos &&
-			devpriv->ai_act_dmapos < stop_pos) {
+		    devpriv->ai_act_dmapos < stop_pos) {
 			dma_buffer[j++] = dma_buffer[i];
 		}
 		devpriv->ai_act_dmapos++;
@@ -482,18 +496,20 @@ static unsigned int defragment_dma_buffe
 ==============================================================================
 */
 static unsigned int move_block_from_dma(struct comedi_device *dev,
-	struct comedi_subdevice *s, short *dma_buffer, unsigned int num_samples)
+					struct comedi_subdevice *s,
+					short *dma_buffer,
+					unsigned int num_samples)
 {
 	unsigned int num_bytes;
 
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
 	devpriv->ai_act_scan +=
-		(s->async->cur_chan + num_samples) / devpriv->ai_n_scanlen;
+	    (s->async->cur_chan + num_samples) / devpriv->ai_n_scanlen;
 	s->async->cur_chan += num_samples;
 	s->async->cur_chan %= devpriv->ai_n_scanlen;
 	num_bytes =
-		cfc_write_array_to_buffer(s, dma_buffer,
-		num_samples * sizeof(short));
+	    cfc_write_array_to_buffer(s, dma_buffer,
+				      num_samples * sizeof(short));
 	if (num_bytes < num_samples * sizeof(short))
 		return -1;
 	return 0;
@@ -503,7 +519,8 @@ static unsigned int move_block_from_dma(
 ==============================================================================
 */
 static char pci9118_decode_error_status(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned char m)
+					struct comedi_subdevice *s,
+					unsigned char m)
 {
 	if (m & 0x100) {
 		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
@@ -511,7 +528,7 @@ static char pci9118_decode_error_status(
 	}
 	if (m & 0x008) {
 		comedi_error(dev,
-			"A/D Burst Mode Overrun Status (Fatal Error!)");
+			     "A/D Burst Mode Overrun Status (Fatal Error!)");
 		devpriv->ai_maskerr &= ~0x008L;
 	}
 	if (m & 0x004) {
@@ -532,8 +549,10 @@ static char pci9118_decode_error_status(
 	return 0;
 }
 
-static void pci9118_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *data, unsigned int num_bytes, unsigned int start_chan_index)
+static void pci9118_ai_munge(struct comedi_device *dev,
+			     struct comedi_subdevice *s, void *data,
+			     unsigned int num_bytes,
+			     unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
 	short *array = data;
@@ -553,8 +572,10 @@ static void pci9118_ai_munge(struct come
 ==============================================================================
 */
 static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned short int_adstat, unsigned int int_amcc,
-	unsigned short int_daq)
+					   struct comedi_subdevice *s,
+					   unsigned short int_adstat,
+					   unsigned int int_amcc,
+					   unsigned short int_daq)
 {
 	register short sampl;
 
@@ -570,9 +591,9 @@ static void interrupt_pci9118_ai_onesamp
 	if (devpriv->ai16bits == 0) {
 		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	/*  data dropout! */
 			printk
-				("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
-				sampl & 0x000f,
-				devpriv->chanlist[s->async->cur_chan]);
+			    ("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
+			     sampl & 0x000f,
+			     devpriv->chanlist[s->async->cur_chan]);
 			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 			pci9118_ai_cancel(dev, s);
 			comedi_event(dev, s);
@@ -599,9 +620,11 @@ static void interrupt_pci9118_ai_onesamp
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_dma(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned short int_adstat, unsigned int int_amcc,
-	unsigned short int_daq)
+static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     unsigned short int_adstat,
+				     unsigned int int_amcc,
+				     unsigned short int_daq)
 {
 	unsigned int next_dma_buf, samplesinbuf, sampls, m;
 
@@ -632,11 +655,11 @@ static void interrupt_pci9118_ai_dma(str
 	if (devpriv->dma_doublebuf) {	/*  switch DMA buffers if is used double buffering */
 		next_dma_buf = 1 - devpriv->dma_actbuf;
 		outl(devpriv->dmabuf_hw[next_dma_buf],
-			devpriv->iobase_a + AMCC_OP_REG_MWAR);
+		     devpriv->iobase_a + AMCC_OP_REG_MWAR);
 		outl(devpriv->dmabuf_use_size[next_dma_buf],
-			devpriv->iobase_a + AMCC_OP_REG_MWTC);
+		     devpriv->iobase_a + AMCC_OP_REG_MWTC);
 		devpriv->dmabuf_used_size[next_dma_buf] =
-			devpriv->dmabuf_use_size[next_dma_buf];
+		    devpriv->dmabuf_use_size[next_dma_buf];
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev);
 	}
@@ -646,8 +669,8 @@ static void interrupt_pci9118_ai_dma(str
 /* DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr); */
 		sampls = m;
 		move_block_from_dma(dev, s,
-			devpriv->dmabuf_virt[devpriv->dma_actbuf],
-			samplesinbuf);
+				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
+				    samplesinbuf);
 		m = m - sampls;	/*  m= how many samples was transfered */
 	}
 /* DPRINTK("YYY\n"); */
@@ -662,9 +685,9 @@ static void interrupt_pci9118_ai_dma(str
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
 	} else {		/*  restart DMA if is not used double buffering */
 		outl(devpriv->dmabuf_hw[0],
-			devpriv->iobase_a + AMCC_OP_REG_MWAR);
+		     devpriv->iobase_a + AMCC_OP_REG_MWAR);
 		outl(devpriv->dmabuf_use_size[0],
-			devpriv->iobase_a + AMCC_OP_REG_MWTC);
+		     devpriv->iobase_a + AMCC_OP_REG_MWTC);
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev);
 	}
@@ -700,18 +723,18 @@ static irqreturn_t interrupt_pci9118(int
 			if ((int_adstat & AdStatus_DTH) && (int_daq & Int_DTrg)) {	/*  start stop of measure */
 				if (devpriv->ai12_startstop & START_AI_EXT) {
 					devpriv->ai12_startstop &=
-						~START_AI_EXT;
+					    ~START_AI_EXT;
 					if (!(devpriv->ai12_startstop &
-							STOP_AI_EXT))
+					      STOP_AI_EXT))
 						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
 					start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1, devpriv->ai_divisor2);	/*  start pacer */
 					outl(devpriv->AdControlReg,
-						dev->iobase + PCI9118_ADCNTRL);
+					     dev->iobase + PCI9118_ADCNTRL);
 				} else {
-					if (devpriv->
-						ai12_startstop & STOP_AI_EXT) {
+					if (devpriv->ai12_startstop &
+					    STOP_AI_EXT) {
 						devpriv->ai12_startstop &=
-							~STOP_AI_EXT;
+						    ~STOP_AI_EXT;
 						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
 						devpriv->ai_neverending = 0;	/* well, on next interrupt from DMA/EOC measure will stop */
 					}
@@ -719,7 +742,7 @@ static irqreturn_t interrupt_pci9118(int
 			}
 
 		(devpriv->int_ai_func) (dev, dev->subdevices + 0, int_adstat,
-			int_amcc, int_daq);
+					int_amcc, int_daq);
 
 	}
 	return IRQ_HANDLED;
@@ -728,8 +751,8 @@ static irqreturn_t interrupt_pci9118(int
 /*
 ==============================================================================
 */
-static int pci9118_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+static int pci9118_ai_inttrig(struct comedi_device *dev,
+			      struct comedi_subdevice *s, unsigned int trignum)
 {
 	if (trignum != devpriv->ai_inttrig_start)
 		return -EINVAL;
@@ -741,7 +764,7 @@ static int pci9118_ai_inttrig(struct com
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	if (devpriv->ai_do != 3) {
 		start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-			devpriv->ai_divisor2);
+			    devpriv->ai_divisor2);
 		devpriv->AdControlReg |= AdControl_SoftG;
 	}
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
@@ -752,8 +775,9 @@ static int pci9118_ai_inttrig(struct com
 /*
 ==============================================================================
 */
-static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pci9118_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -799,21 +823,21 @@ static int pci9118_ai_cmdtest(struct com
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
 	if (cmd->start_src != TRIG_NOW &&
-		cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT) {
+	    cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT) {
 		cmd->start_src = TRIG_NOW;
 		err++;
 	}
 
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_INT &&
-		cmd->scan_begin_src != TRIG_FOLLOW) {
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_INT &&
+	    cmd->scan_begin_src != TRIG_FOLLOW) {
 		cmd->scan_begin_src = TRIG_FOLLOW;
 		err++;
 	}
 
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW) {
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW) {
 		cmd->convert_src = TRIG_TIMER;
 		err++;
 	}
@@ -824,8 +848,8 @@ static int pci9118_ai_cmdtest(struct com
 	}
 
 	if (cmd->stop_src != TRIG_NONE &&
-		cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_INT && cmd->stop_src != TRIG_EXT) {
+	    cmd->stop_src != TRIG_COUNT &&
+	    cmd->stop_src != TRIG_INT && cmd->stop_src != TRIG_EXT) {
 		cmd->stop_src = TRIG_COUNT;
 		err++;
 	}
@@ -841,13 +865,13 @@ static int pci9118_ai_cmdtest(struct com
 	}
 
 	if ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&
-		(!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW)))) {
+	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW)))) {
 		cmd->convert_src = TRIG_TIMER;
 		err++;
 	}
 
 	if ((cmd->scan_begin_src == TRIG_FOLLOW) &&
-		(!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT)))) {
+	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT)))) {
 		cmd->convert_src = TRIG_TIMER;
 		err++;
 	}
@@ -875,7 +899,7 @@ static int pci9118_ai_cmdtest(struct com
 		}
 
 	if ((cmd->scan_begin_src == TRIG_TIMER) &&
-		(cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
+	    (cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
 		cmd->scan_begin_src = TRIG_FOLLOW;
 		cmd->convert_arg = cmd->scan_begin_arg;
 		cmd->scan_begin_arg = 0;
@@ -938,8 +962,7 @@ static int pci9118_ai_cmdtest(struct com
 
 	if ((cmd->scan_end_arg % cmd->chanlist_len)) {
 		cmd->scan_end_arg =
-			cmd->chanlist_len * (cmd->scan_end_arg /
-			cmd->chanlist_len);
+		    cmd->chanlist_len * (cmd->scan_end_arg / cmd->chanlist_len);
 		err++;
 	}
 
@@ -952,8 +975,8 @@ static int pci9118_ai_cmdtest(struct com
 		tmp = cmd->scan_begin_arg;
 /* printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
-			&divisor2, &cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->scan_begin_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 /* printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
 			cmd->scan_begin_arg = this_board->ai_ns_min;
@@ -964,31 +987,31 @@ static int pci9118_ai_cmdtest(struct com
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 /* printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER
-			&& cmd->convert_src == TRIG_NOW) {
+		    && cmd->convert_src == TRIG_NOW) {
 			if (cmd->convert_arg == 0) {
 				if (cmd->scan_begin_arg <
-					this_board->ai_ns_min *
-					(cmd->scan_end_arg + 2)) {
+				    this_board->ai_ns_min *
+				    (cmd->scan_end_arg + 2)) {
 					cmd->scan_begin_arg =
-						this_board->ai_ns_min *
-						(cmd->scan_end_arg + 2);
+					    this_board->ai_ns_min *
+					    (cmd->scan_end_arg + 2);
 /* printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			} else {
 				if (cmd->scan_begin_arg <
-					cmd->convert_arg * cmd->chanlist_len) {
+				    cmd->convert_arg * cmd->chanlist_len) {
 					cmd->scan_begin_arg =
-						cmd->convert_arg *
-						cmd->chanlist_len;
+					    cmd->convert_arg *
+					    cmd->chanlist_len;
 /* printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
@@ -1001,7 +1024,7 @@ static int pci9118_ai_cmdtest(struct com
 
 	if (cmd->chanlist)
 		if (!check_channel_list(dev, s, cmd->chanlist_len,
-				cmd->chanlist, 0, 0))
+					cmd->chanlist, 0, 0))
 			return 5;	/*  incorrect channels list */
 
 	return 0;
@@ -1034,19 +1057,22 @@ static int Compute_and_setup_dma(struct 
 			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			printk
-				("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
-				dev->minor, dmalen0,
-				devpriv->ai_n_realscanlen << 1);
+			    ("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
+			     dev->minor, dmalen0,
+			     devpriv->ai_n_realscanlen << 1);
 		} else {
 			/*  short first DMA buffer to one scan */
 			dmalen0 = devpriv->ai_n_realscanlen << 1;
-			DPRINTK("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen0, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
+			DPRINTK
+			    ("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n",
+			     dmalen0, devpriv->ai_n_realscanlen,
+			     devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
 				dmalen0 += 2;
 			if (dmalen0 < 4) {
 				printk
-					("comedi%d: ERR: DMA0 buf len bug? (%d<4)\n",
-					dev->minor, dmalen0);
+				    ("comedi%d: ERR: DMA0 buf len bug? (%d<4)\n",
+				     dev->minor, dmalen0);
 				dmalen0 = 4;
 			}
 		}
@@ -1056,19 +1082,22 @@ static int Compute_and_setup_dma(struct 
 			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			printk
-				("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
-				dev->minor, dmalen1,
-				devpriv->ai_n_realscanlen << 1);
+			    ("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
+			     dev->minor, dmalen1,
+			     devpriv->ai_n_realscanlen << 1);
 		} else {
 			/*  short second DMA buffer to one scan */
 			dmalen1 = devpriv->ai_n_realscanlen << 1;
-			DPRINTK("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen1, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
+			DPRINTK
+			    ("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n",
+			     dmalen1, devpriv->ai_n_realscanlen,
+			     devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
 				dmalen1 -= 2;
 			if (dmalen1 < 4) {
 				printk
-					("comedi%d: ERR: DMA1 buf len bug? (%d<4)\n",
-					dev->minor, dmalen1);
+				    ("comedi%d: ERR: DMA1 buf len bug? (%d<4)\n",
+				     dev->minor, dmalen1);
 				dmalen1 = 4;
 			}
 		}
@@ -1080,15 +1109,15 @@ static int Compute_and_setup_dma(struct 
 		/*  if it's possible then allign DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
-			(dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
-			(devpriv->ai_n_realscanlen << 1);
+		    (dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
+		    (devpriv->ai_n_realscanlen << 1);
 		dmalen0 &= ~3L;
 		if (!dmalen0)
 			dmalen0 = i;	/*  uff. very long scan? */
 		i = dmalen1;
 		dmalen1 =
-			(dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
-			(devpriv->ai_n_realscanlen << 1);
+		    (dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
+		    (devpriv->ai_n_realscanlen << 1);
 		dmalen1 &= ~3L;
 		if (!dmalen1)
 			dmalen1 = i;	/*  uff. very long scan? */
@@ -1096,23 +1125,25 @@ static int Compute_and_setup_dma(struct 
 		if (!devpriv->ai_neverending) {
 			/*  fits whole measure into one DMA buffer? */
 			if (dmalen0 >
-				((devpriv->ai_n_realscanlen << 1) *
-					devpriv->ai_scans)) {
-				DPRINTK("3.0 ai_n_realscanlen=%d ai_scans=%d \n", devpriv->ai_n_realscanlen, devpriv->ai_scans);
+			    ((devpriv->ai_n_realscanlen << 1) *
+			     devpriv->ai_scans)) {
+				DPRINTK
+				    ("3.0 ai_n_realscanlen=%d ai_scans=%d \n",
+				     devpriv->ai_n_realscanlen,
+				     devpriv->ai_scans);
 				dmalen0 =
-					(devpriv->ai_n_realscanlen << 1) *
-					devpriv->ai_scans;
+				    (devpriv->ai_n_realscanlen << 1) *
+				    devpriv->ai_scans;
 				DPRINTK("3.1 dmalen0=%d dmalen1=%d \n", dmalen0,
 					dmalen1);
 				dmalen0 &= ~3L;
 			} else {	/*  fits whole measure into two DMA buffer? */
 				if (dmalen1 >
-					((devpriv->ai_n_realscanlen << 1) *
-						devpriv->ai_scans - dmalen0))
+				    ((devpriv->ai_n_realscanlen << 1) *
+				     devpriv->ai_scans - dmalen0))
 					dmalen1 =
-						(devpriv->
-						ai_n_realscanlen << 1) *
-						devpriv->ai_scans - dmalen0;
+					    (devpriv->ai_n_realscanlen << 1) *
+					    devpriv->ai_scans - dmalen0;
 				DPRINTK("3.2 dmalen0=%d dmalen1=%d \n", dmalen0,
 					dmalen1);
 				dmalen1 &= ~3L;
@@ -1131,16 +1162,16 @@ static int Compute_and_setup_dma(struct 
 #if 0
 	if (devpriv->ai_n_scanlen < this_board->half_fifo_size) {
 		devpriv->dmabuf_panic_size[0] =
-			(this_board->half_fifo_size / devpriv->ai_n_scanlen +
-			1) * devpriv->ai_n_scanlen * sizeof(short);
+		    (this_board->half_fifo_size / devpriv->ai_n_scanlen +
+		     1) * devpriv->ai_n_scanlen * sizeof(short);
 		devpriv->dmabuf_panic_size[1] =
-			(this_board->half_fifo_size / devpriv->ai_n_scanlen +
-			1) * devpriv->ai_n_scanlen * sizeof(short);
+		    (this_board->half_fifo_size / devpriv->ai_n_scanlen +
+		     1) * devpriv->ai_n_scanlen * sizeof(short);
 	} else {
 		devpriv->dmabuf_panic_size[0] =
-			(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[0];
+		    (devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[0];
 		devpriv->dmabuf_panic_size[1] =
-			(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[1];
+		    (devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[1];
 	}
 #endif
 
@@ -1149,12 +1180,12 @@ static int Compute_and_setup_dma(struct 
 	outl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);
 	/*  init DMA transfer */
 	outl(0x00000000 | AINT_WRITE_COMPL,
-		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 /* outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR); */
 
 	outl(inl(devpriv->iobase_a +
-			AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
-		EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
+		 AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
+	     EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow bus mastering */
 
 	DPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");
@@ -1164,7 +1195,8 @@ static int Compute_and_setup_dma(struct 
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_sampl(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",
 		dev->minor, devpriv->ai_do);
@@ -1183,7 +1215,7 @@ static int pci9118_ai_docmd_sampl(struct
 		return -EIO;
 	default:
 		comedi_error(dev,
-			"pci9118_ai_docmd_sampl() mode number bug!\n");
+			     "pci9118_ai_docmd_sampl() mode number bug!\n");
 		return -EIO;
 	};
 
@@ -1204,7 +1236,7 @@ static int pci9118_ai_docmd_sampl(struct
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		if (devpriv->ai_do != 3) {
 			start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-				devpriv->ai_divisor2);
+				    devpriv->ai_divisor2);
 			devpriv->AdControlReg |= AdControl_SoftG;
 		}
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
@@ -1217,7 +1249,8 @@ static int pci9118_ai_docmd_sampl(struct
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_dma(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci9118_ai_docmd_dma(struct comedi_device *dev,
+				struct comedi_subdevice *s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",
 		dev->minor, devpriv->ai_do, devpriv->usedma);
@@ -1226,34 +1259,34 @@ static int pci9118_ai_docmd_dma(struct c
 	switch (devpriv->ai_do) {
 	case 1:
 		devpriv->AdControlReg |=
-			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
 		break;
 	case 2:
 		devpriv->AdControlReg |=
-			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
 		devpriv->AdFunctionReg =
-			AdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |
-			AdFunction_BS;
+		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |
+		    AdFunction_BS;
 		if (devpriv->usessh && (!devpriv->softsshdelay))
 			devpriv->AdFunctionReg |= AdFunction_BSSH;
 		outl(devpriv->ai_n_realscanlen, dev->iobase + PCI9118_BURST);
 		break;
 	case 3:
 		devpriv->AdControlReg |=
-			((AdControl_ExtM | AdControl_Dma) & 0xff);
+		    ((AdControl_ExtM | AdControl_Dma) & 0xff);
 		devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
 		break;
 	case 4:
 		devpriv->AdControlReg |=
-			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
 		devpriv->AdFunctionReg =
-			AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
+		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		outl(0x30, dev->iobase + PCI9118_CNTCTRL);
 		outl((devpriv->dmabuf_hw[0] >> 1) & 0xff,
-			dev->iobase + PCI9118_CNT0);
+		     dev->iobase + PCI9118_CNT0);
 		outl((devpriv->dmabuf_hw[0] >> 9) & 0xff,
-			dev->iobase + PCI9118_CNT0);
+		     dev->iobase + PCI9118_CNT0);
 		devpriv->AdFunctionReg |= AdFunction_Start;
 		break;
 	default:
@@ -1268,14 +1301,14 @@ static int pci9118_ai_docmd_dma(struct c
 	devpriv->int_ai_func = interrupt_pci9118_ai_dma;	/* transfer function */
 
 	outl(0x02000000 | AINT_WRITE_COMPL,
-		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 		if (devpriv->ai_do != 3) {
 			start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-				devpriv->ai_divisor2);
+				    devpriv->ai_divisor2);
 			devpriv->AdControlReg |= AdControl_SoftG;
 		}
 		outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
@@ -1338,7 +1371,7 @@ static int pci9118_ai_cmd(struct comedi_
 	/*  use sample&hold signal? */
 	if (cmd->convert_src == TRIG_NOW) {
 		devpriv->usessh = 1;
-	}			/*  yes */
+	} /*  yes */
 	else {
 		devpriv->usessh = 0;
 	}			/*  no */
@@ -1354,7 +1387,7 @@ static int pci9118_ai_cmd(struct comedi_
 	if (devpriv->master) {
 		devpriv->usedma = 1;
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
-			(devpriv->ai_n_scanlen == 1)) {
+		    (devpriv->ai_n_scanlen == 1)) {
 			if (cmd->convert_src == TRIG_NOW) {
 				devpriv->ai_add_back = 1;
 			}
@@ -1363,8 +1396,8 @@ static int pci9118_ai_cmd(struct comedi_
 			}
 		}
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
-			(devpriv->ai_n_scanlen & 1) &&
-			(devpriv->ai_n_scanlen > 1)) {
+		    (devpriv->ai_n_scanlen & 1) &&
+		    (devpriv->ai_n_scanlen > 1)) {
 			if (cmd->scan_begin_src == TRIG_FOLLOW) {
 				/* vpriv->useeoshandle=1; // change DMA transfer block to fit EOS on every second call */
 				devpriv->usedma = 0;	/*  XXX maybe can be corrected to use 16 bit DMA */
@@ -1392,16 +1425,16 @@ static int pci9118_ai_cmd(struct comedi_
 			devpriv->ai_add_front = addchans + 1;
 			if (devpriv->usedma == 1)
 				if ((devpriv->ai_add_front +
-						devpriv->ai_n_chan +
-						devpriv->ai_add_back) & 1)
+				     devpriv->ai_n_chan +
+				     devpriv->ai_add_back) & 1)
 					devpriv->ai_add_front++;	/*  round up to 32 bit */
 		}
-	}			/*  well, we now know what must be all added */
-
+	}
+	/*  well, we now know what must be all added */
 	devpriv->ai_n_realscanlen =	/*  what we must take from card in real to have ai_n_scanlen on output? */
-		(devpriv->ai_add_front + devpriv->ai_n_chan +
-		devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
-		devpriv->ai_n_chan);
+	    (devpriv->ai_add_front + devpriv->ai_n_chan +
+	     devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
+				      devpriv->ai_n_chan);
 
 	DPRINTK("2 usedma=%d realscan=%d af=%u n_chan=%d ab=%d n_scanlen=%d\n",
 		devpriv->usedma,
@@ -1411,13 +1444,13 @@ static int pci9118_ai_cmd(struct comedi_
 
 	/*  check and setup channel list */
 	if (!check_channel_list(dev, s, devpriv->ai_n_chan,
-			devpriv->ai_chanlist, devpriv->ai_add_front,
-			devpriv->ai_add_back))
+				devpriv->ai_chanlist, devpriv->ai_add_front,
+				devpriv->ai_add_back))
 		return -EINVAL;
 	if (!setup_channel_list(dev, s, devpriv->ai_n_chan,
-			devpriv->ai_chanlist, 0, devpriv->ai_add_front,
-			devpriv->ai_add_back, devpriv->usedma,
-			devpriv->useeoshandle))
+				devpriv->ai_chanlist, 0, devpriv->ai_add_front,
+				devpriv->ai_add_back, devpriv->usedma,
+				devpriv->useeoshandle))
 		return -EINVAL;
 
 	/*  compute timers settings */
@@ -1429,32 +1462,36 @@ static int pci9118_ai_cmd(struct comedi_
 			devpriv->ai_do = 1;
 		}
 		pci9118_calc_divisors(devpriv->ai_do, dev, s,
-			&cmd->scan_begin_arg, &cmd->convert_arg,
-			devpriv->ai_flags, devpriv->ai_n_realscanlen,
-			&devpriv->ai_divisor1, &devpriv->ai_divisor2,
-			devpriv->usessh, devpriv->ai_add_front);
+				      &cmd->scan_begin_arg, &cmd->convert_arg,
+				      devpriv->ai_flags,
+				      devpriv->ai_n_realscanlen,
+				      &devpriv->ai_divisor1,
+				      &devpriv->ai_divisor2, devpriv->usessh,
+				      devpriv->ai_add_front);
 		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
 	if ((cmd->scan_begin_src == TRIG_TIMER) && ((cmd->convert_src == TRIG_TIMER) || (cmd->convert_src == TRIG_NOW))) {	/*  double timed action */
 		if (!devpriv->usedma) {
 			comedi_error(dev,
-				"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!");
+				     "cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!");
 			return -EIO;
 		}
 
 		devpriv->ai_do = 2;
 		pci9118_calc_divisors(devpriv->ai_do, dev, s,
-			&cmd->scan_begin_arg, &cmd->convert_arg,
-			devpriv->ai_flags, devpriv->ai_n_realscanlen,
-			&devpriv->ai_divisor1, &devpriv->ai_divisor2,
-			devpriv->usessh, devpriv->ai_add_front);
+				      &cmd->scan_begin_arg, &cmd->convert_arg,
+				      devpriv->ai_flags,
+				      devpriv->ai_n_realscanlen,
+				      &devpriv->ai_divisor1,
+				      &devpriv->ai_divisor2, devpriv->usessh,
+				      devpriv->ai_add_front);
 		devpriv->ai_timer1 = cmd->scan_begin_arg;
 		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
 	if ((cmd->scan_begin_src == TRIG_FOLLOW)
-		&& (cmd->convert_src == TRIG_EXT)) {
+	    && (cmd->convert_src == TRIG_EXT)) {
 		devpriv->ai_do = 3;
 	}
 
@@ -1486,8 +1523,9 @@ static int pci9118_ai_cmd(struct comedi_
 /*
 ==============================================================================
 */
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n_chan, unsigned int *chanlist, int frontadd, int backadd)
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int n_chan,
+			      unsigned int *chanlist, int frontadd, int backadd)
 {
 	unsigned int i, differencial = 0, bipolar = 0;
 
@@ -1498,9 +1536,8 @@ static int check_channel_list(struct com
 	}
 	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
 		printk
-			("comedi%d: range/channel list is too long for actual configuration (%d>%d)!",
-			dev->minor, n_chan,
-			s->len_chanlist - frontadd - backadd);
+		    ("comedi%d: range/channel list is too long for actual configuration (%d>%d)!",
+		     dev->minor, n_chan, s->len_chanlist - frontadd - backadd);
 		return 0;
 	}
 
@@ -1511,22 +1548,21 @@ static int check_channel_list(struct com
 	if (n_chan > 1)
 		for (i = 1; i < n_chan; i++) {	/*  check S.E/diff */
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
-				(differencial)) {
+			    (differencial)) {
 				comedi_error(dev,
-					"Differencial and single ended inputs cann't be mixtured!");
+					     "Differencial and single ended inputs cann't be mixtured!");
 				return 0;
 			}
 			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=
-				(bipolar)) {
+			    (bipolar)) {
 				comedi_error(dev,
-					"Bipolar and unipolar ranges cann't be mixtured!");
+					     "Bipolar and unipolar ranges cann't be mixtured!");
 				return 0;
 			}
 			if ((!devpriv->usemux) & (differencial) &
-				(CR_CHAN(chanlist[i]) >=
-					this_board->n_aichand)) {
+			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
 				comedi_error(dev,
-					"If AREF_DIFF is used then is available only first 8 channels!");
+					     "If AREF_DIFF is used then is available only first 8 channels!");
 				return 0;
 			}
 		}
@@ -1537,14 +1573,17 @@ static int check_channel_list(struct com
 /*
 ==============================================================================
 */
-static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
-	int usedma, char useeos)
+static int setup_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int n_chan,
+			      unsigned int *chanlist, int rot, int frontadd,
+			      int backadd, int usedma, char useeos)
 {
 	unsigned int i, differencial = 0, bipolar = 0;
 	unsigned int scanquad, gain, ssh = 0x00;
 
-	DPRINTK("adl_pci9118 EDBG: BGN: setup_channel_list(%d,.,%d,.,%d,%d,%d,%d)\n", dev->minor, n_chan, rot, frontadd, backadd, usedma);
+	DPRINTK
+	    ("adl_pci9118 EDBG: BGN: setup_channel_list(%d,.,%d,.,%d,%d,%d,%d)\n",
+	     dev->minor, n_chan, rot, frontadd, backadd, usedma);
 
 	if (usedma == 1) {
 		rot = 8;
@@ -1625,7 +1664,7 @@ static int setup_channel_list(struct com
 	if (useeos) {
 		for (i = 1; i < n_chan; i++) {	/*  store range list to card */
 			devpriv->chanlist[(n_chan + i) ^ usedma] =
-				(CR_CHAN(chanlist[i]) & 0xf) << rot;
+			    (CR_CHAN(chanlist[i]) & 0xf) << rot;
 		}
 		devpriv->chanlist[(2 * n_chan) ^ usedma] = devpriv->chanlist[0 ^ usedma];	/*  for 32bit oerations */
 		useeos = 2;
@@ -1652,18 +1691,22 @@ static int setup_channel_list(struct com
   calculate 8254 divisors if they are used for dual timing
 */
 static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int *tim1, unsigned int *tim2,
-	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
-	char usessh, unsigned int chnsshfront)
-{
-	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_calc_divisors(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n", mode, dev->minor, *tim1, *tim2, flags, chans, usessh, chnsshfront);
+				  struct comedi_subdevice *s,
+				  unsigned int *tim1, unsigned int *tim2,
+				  unsigned int flags, int chans,
+				  unsigned int *div1, unsigned int *div2,
+				  char usessh, unsigned int chnsshfront)
+{
+	DPRINTK
+	    ("adl_pci9118 EDBG: BGN: pci9118_calc_divisors(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n",
+	     mode, dev->minor, *tim1, *tim2, flags, chans, usessh, chnsshfront);
 	switch (mode) {
 	case 1:
 	case 4:
 		if (*tim2 < this_board->ai_ns_min)
 			*tim2 = this_board->ai_ns_min;
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, div1, div2,
-			tim2, flags & TRIG_ROUND_NEAREST);
+					  tim2, flags & TRIG_ROUND_NEAREST);
 		DPRINTK("OSC base=%u div1=%u div2=%u timer1=%u\n",
 			devpriv->i8254_osc_base, *div1, *div2, *tim1);
 		break;
@@ -1710,8 +1753,8 @@ static void pci9118_calc_divisors(char m
 /*
 ==============================================================================
 */
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2)
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2)
 {
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
@@ -1760,7 +1803,8 @@ static int pci9118_exttrg_del(struct com
 /*
 ==============================================================================
 */
-static int pci9118_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci9118_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	if (devpriv->usedma)
 		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
@@ -1835,7 +1879,8 @@ static int pci9118_reset(struct comedi_d
 /*
 ==============================================================================
 */
-static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci9118_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret, pages, i;
@@ -1848,8 +1893,7 @@ static int pci9118_attach(struct comedi_
 	unsigned char pci_bus, pci_slot, pci_func;
 	u16 u16w;
 
-	printk("comedi%d: adl_pci9118: board=%s", dev->minor,
-		this_board->name);
+	printk("comedi%d: adl_pci9118: board=%s", dev->minor, this_board->name);
 
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
@@ -1869,12 +1913,13 @@ static int pci9118_attach(struct comedi_
 	errstr = "not found!";
 	pcidev = NULL;
 	while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_AMCC,
-				this_board->device_id, pcidev))) {
+						this_board->device_id,
+						pcidev))) {
 		/* Found matching vendor/device. */
 		if (opt_bus || opt_slot) {
 			/* Check bus/slot. */
 			if (opt_bus != pcidev->bus->number
-				|| opt_slot != PCI_SLOT(pcidev->devfn))
+			    || opt_slot != PCI_SLOT(pcidev->devfn))
 				continue;	/* no match */
 		}
 		/*
@@ -1882,7 +1927,8 @@ static int pci9118_attach(struct comedi_
 		 * Enable PCI device and request regions.
 		 */
 		if (comedi_pci_enable(pcidev, "adl_pci9118")) {
-			errstr = "failed to enable PCI device and request regions!";
+			errstr =
+			    "failed to enable PCI device and request regions!";
 			continue;
 		}
 		break;
@@ -1891,7 +1937,7 @@ static int pci9118_attach(struct comedi_
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
 			printk(" - Card at b:s %d:%d %s\n",
-				opt_bus, opt_slot, errstr);
+			       opt_bus, opt_slot, errstr);
 		} else {
 			printk(" - Card %s\n", errstr);
 		}
@@ -1910,7 +1956,7 @@ static int pci9118_attach(struct comedi_
 	iobase_9 = pci_resource_start(pcidev, 2);
 
 	printk(", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus, pci_slot,
-		pci_func, iobase_9, iobase_a);
+	       pci_func, iobase_9, iobase_a);
 
 	dev->iobase = iobase_9;
 	dev->board_name = this_board->name;
@@ -1926,7 +1972,7 @@ static int pci9118_attach(struct comedi_
 		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
 				"ADLink PCI-9118", dev)) {
 			printk(", unable to allocate IRQ %d, DISABLING IT",
-				irq);
+			       irq);
 			irq = 0;	/* Can't use IRQ */
 		} else {
 			printk(", irq=%u", irq);
@@ -1942,8 +1988,8 @@ static int pci9118_attach(struct comedi_
 		for (i = 0; i < 2; i++) {
 			for (pages = 4; pages >= 0; pages--) {
 				devpriv->dmabuf_virt[i] =
-					(short *) __get_free_pages(GFP_KERNEL,
-								   pages);
+				    (short *)__get_free_pages(GFP_KERNEL,
+							      pages);
 				if (devpriv->dmabuf_virt[i])
 					break;
 			}
@@ -1951,10 +1997,10 @@ static int pci9118_attach(struct comedi_
 				devpriv->dmabuf_pages[i] = pages;
 				devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
 				devpriv->dmabuf_samples[i] =
-					devpriv->dmabuf_size[i] >> 1;
+				    devpriv->dmabuf_size[i] >> 1;
 				devpriv->dmabuf_hw[i] =
-					virt_to_bus((void *)devpriv->
-					dmabuf_virt[i]);
+				    virt_to_bus((void *)
+						devpriv->dmabuf_virt[i]);
 			}
 		}
 		if (!devpriv->dmabuf_virt[0]) {
@@ -2090,10 +2136,10 @@ static int pci9118_detach(struct comedi_
 		}
 		if (devpriv->dmabuf_virt[0])
 			free_pages((unsigned long)devpriv->dmabuf_virt[0],
-				devpriv->dmabuf_pages[0]);
+				   devpriv->dmabuf_pages[0]);
 		if (devpriv->dmabuf_virt[1])
 			free_pages((unsigned long)devpriv->dmabuf_virt[1],
-				devpriv->dmabuf_pages[1]);
+				   devpriv->dmabuf_pages[1]);
 	}
 
 	return 0;
--- a/drivers/staging/comedi/drivers/adq12b.c
+++ b/drivers/staging/comedi/drivers/adq12b.c
@@ -62,7 +62,6 @@ If you do not specify any options, they 
        single-ended             0                  1-2     1-2 (factory default)
        differential             1                  2-3     2-3
 
-
    written by jeremy theler <thelerg@ib.cnea.gov.ar>
 
    instituto balseiro
@@ -101,39 +100,39 @@ If you do not specify any options, they 
 
 /* available ranges through the PGA gains */
 static const struct comedi_lrange range_adq12b_ai_bipolar = { 4, {
-        BIP_RANGE(5),
-        BIP_RANGE(2),
-        BIP_RANGE(1),
-        BIP_RANGE(0.5)
-}};
+								  BIP_RANGE(5),
+								  BIP_RANGE(2),
+								  BIP_RANGE(1),
+								  BIP_RANGE(0.5)
+								  }
+};
 
 static const struct comedi_lrange range_adq12b_ai_unipolar = { 4, {
-        UNI_RANGE(5),
-        UNI_RANGE(2),
-        UNI_RANGE(1),
-        UNI_RANGE(0.5)
-}};
-
-
+								   UNI_RANGE(5),
+								   UNI_RANGE(2),
+								   UNI_RANGE(1),
+								   UNI_RANGE
+								   (0.5)
+								   }
+};
 
 struct adq12b_board {
-        const char *name;
-        int ai_se_chans;
-        int ai_diff_chans;
-        int ai_bits;
-        int di_chans;
-        int do_chans;
+	const char *name;
+	int ai_se_chans;
+	int ai_diff_chans;
+	int ai_bits;
+	int di_chans;
+	int do_chans;
 };
 
 static const struct adq12b_board adq12b_boards[] = {
-        {
-	.name = "adq12b",
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.di_chans = 5,
-	.do_chans = 8
-        }
+	{
+	 .name = "adq12b",
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .di_chans = 5,
+	 .do_chans = 8}
 /* potentially, more adq-based deviced will be added */
 /*,
 	.name = "adq12b",
@@ -147,11 +146,11 @@ static const struct adq12b_board adq12b_
 #define thisboard ((const struct adq12b_board *)dev->board_ptr)
 
 struct adq12b_private {
-        int unipolar;          /* option 2 of comedi_config (1 is iobase) */
-        int differential;      /* option 3 of comedi_config */
-        int last_channel;
-        int last_range;
-        unsigned int digital_state;
+	int unipolar;		/* option 2 of comedi_config (1 is iobase) */
+	int differential;	/* option 3 of comedi_config */
+	int last_channel;
+	int last_range;
+	unsigned int digital_state;
 };
 
 #define devpriv ((struct adq12b_private *)dev->private)
@@ -162,21 +161,28 @@ struct adq12b_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int adq12b_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int adq12b_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int adq12b_detach(struct comedi_device *dev);
-static struct comedi_driver driver_adq12b={
-        driver_name:    "adq12b",
-        module:         THIS_MODULE,
-        attach:         adq12b_attach,
-        detach:         adq12b_detach,
-        board_name:     &adq12b_boards[0].name,
-        offset:         sizeof(struct adq12b_board),
-        num_names:      ARRAY_SIZE(adq12b_boards),
+static struct comedi_driver driver_adq12b = {
+driver_name:"adq12b",
+module:THIS_MODULE,
+attach:adq12b_attach,
+detach:adq12b_detach,
+board_name:&adq12b_boards[0].name,
+offset:sizeof(struct adq12b_board),
+num_names:ARRAY_SIZE(adq12b_boards),
 };
 
-static int adq12b_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
-static int adq12b_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
-static int adq12b_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+static int adq12b_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int adq12b_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int adq12b_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -186,109 +192,108 @@ static int adq12b_do_insn_bits(struct co
  */
 static int adq12b_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-        struct comedi_subdevice *s;
-        unsigned long iobase;
-        int unipolar, differential;
-
-        iobase = it->options[0];
-        unipolar = it->options[1];
-        differential = it->options[2];
-
-        printk("comedi%d: adq12b called with options base=0x%03lx, %s and %s\n", dev->minor, iobase, (unipolar==1)?"unipolar":"bipolar", (differential==1) ? "differential" : "single-ended");
-
-        /* if no address was specified, try the default 0x300 */
-        if (iobase == 0) {
-          printk("comedi%d: adq12b warning: I/O base address not specified. Trying the default 0x300.\n", dev->minor);
-          iobase = 0x300;
-        }
-
-        printk("comedi%d: adq12b: 0x%04lx ", dev->minor, iobase);
-        if (!request_region(iobase, ADQ12B_SIZE, "adq12b")) {
-          printk("I/O port conflict\n");
-          return -EIO;
-        }
-        dev->iobase = iobase;
+	struct comedi_subdevice *s;
+	unsigned long iobase;
+	int unipolar, differential;
+
+	iobase = it->options[0];
+	unipolar = it->options[1];
+	differential = it->options[2];
+
+	printk("comedi%d: adq12b called with options base=0x%03lx, %s and %s\n",
+	       dev->minor, iobase, (unipolar == 1) ? "unipolar" : "bipolar",
+	       (differential == 1) ? "differential" : "single-ended");
+
+	/* if no address was specified, try the default 0x300 */
+	if (iobase == 0) {
+		printk
+		    ("comedi%d: adq12b warning: I/O base address not specified. Trying the default 0x300.\n",
+		     dev->minor);
+		iobase = 0x300;
+	}
+
+	printk("comedi%d: adq12b: 0x%04lx ", dev->minor, iobase);
+	if (!request_region(iobase, ADQ12B_SIZE, "adq12b")) {
+		printk("I/O port conflict\n");
+		return -EIO;
+	}
+	dev->iobase = iobase;
 
 /*
  * Initialize dev->board_name.  Note that we can use the "thisboard"
  * macro now, since we just initialized it in the last line.
  */
-        dev->board_name = thisboard->name;
+	dev->board_name = thisboard->name;
 
 /*
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
  */
-        if (alloc_private (dev, sizeof (struct adq12b_private)) < 0)
-          return -ENOMEM;
+	if (alloc_private(dev, sizeof(struct adq12b_private)) < 0)
+		return -ENOMEM;
 
 /* fill in devpriv structure */
-        devpriv->unipolar = unipolar;
-        devpriv->differential = differential;
+	devpriv->unipolar = unipolar;
+	devpriv->differential = differential;
 	devpriv->digital_state = 0;
 /* initialize channel and range to -1 so we make sure we always write
    at least once to the CTREG in the instruction */
-        devpriv->last_channel = -1;
-        devpriv->last_range = -1;
-
+	devpriv->last_channel = -1;
+	devpriv->last_range = -1;
 
 /*
  * Allocate the subdevice structures.  alloc_subdevice() is a
  * convenient macro defined in comedidev.h.
  */
-        if (alloc_subdevices (dev, 3)<0)
-           return -ENOMEM;
-
-        s = dev->subdevices+0;
-        /* analog input subdevice */
-        s->type = COMEDI_SUBD_AI;
-        if (differential) {
-          s->subdev_flags = SDF_READABLE|SDF_GROUND|SDF_DIFF;
-          s->n_chan = thisboard->ai_diff_chans;
-        } else {
-          s->subdev_flags = SDF_READABLE|SDF_GROUND;
-          s->n_chan = thisboard->ai_se_chans;
-        }
-
-        if (unipolar) {
-          s->range_table = &range_adq12b_ai_unipolar;
-        } else {
-          s->range_table = &range_adq12b_ai_bipolar;
-        }
-
-        s->maxdata = (1 << thisboard->ai_bits)-1;
-
-
-        s->len_chanlist = 4;  /* This is the maximum chanlist length that
-                                 the board can handle */
-        s->insn_read = adq12b_ai_rinsn;
-
-
-        s = dev->subdevices+1;
-        /* digital input subdevice */
-        s->type = COMEDI_SUBD_DI;
-        s->subdev_flags = SDF_READABLE;
-        s->n_chan=thisboard->di_chans;
-        s->maxdata = 1;
-        s->range_table = &range_digital;
-        s->insn_bits = adq12b_di_insn_bits;
-
-        s = dev->subdevices+2;
-        /* digital output subdevice */
-        s->type = COMEDI_SUBD_DO;
-        s->subdev_flags = SDF_WRITABLE;
-        s->n_chan = thisboard->do_chans;
-        s->maxdata = 1;
-        s->range_table = &range_digital;
-        s->insn_bits = adq12b_do_insn_bits;
+	if (alloc_subdevices(dev, 3) < 0)
+		return -ENOMEM;
 
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	s->type = COMEDI_SUBD_AI;
+	if (differential) {
+		s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
+		s->n_chan = thisboard->ai_diff_chans;
+	} else {
+		s->subdev_flags = SDF_READABLE | SDF_GROUND;
+		s->n_chan = thisboard->ai_se_chans;
+	}
+
+	if (unipolar) {
+		s->range_table = &range_adq12b_ai_unipolar;
+	} else {
+		s->range_table = &range_adq12b_ai_bipolar;
+	}
+
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+
+	s->len_chanlist = 4;	/* This is the maximum chanlist length that
+				   the board can handle */
+	s->insn_read = adq12b_ai_rinsn;
+
+	s = dev->subdevices + 1;
+	/* digital input subdevice */
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = thisboard->di_chans;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = adq12b_di_insn_bits;
+
+	s = dev->subdevices + 2;
+	/* digital output subdevice */
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITABLE;
+	s->n_chan = thisboard->do_chans;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = adq12b_do_insn_bits;
 
-        printk("attached\n");
+	printk("attached\n");
 
-        return 0;
+	return 0;
 }
 
-
 /*
  * _detach is called to deconfigure a device.  It should deallocate
  * resources.
@@ -299,14 +304,14 @@ static int adq12b_attach(struct comedi_d
  */
 static int adq12b_detach(struct comedi_device *dev)
 {
-        if (dev->iobase)
-          release_region(dev->iobase, ADQ12B_SIZE);
+	if (dev->iobase)
+		release_region(dev->iobase, ADQ12B_SIZE);
 
-        kfree(devpriv);
+	kfree(devpriv);
 
-        printk("comedi%d: adq12b: removed\n", dev->minor);
+	printk("comedi%d: adq12b: removed\n", dev->minor);
 
-        return 0;
+	return 0;
 }
 
 /*
@@ -314,79 +319,83 @@ static int adq12b_detach(struct comedi_d
  * mode.
  */
 
-static int adq12b_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+static int adq12b_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
-        int n, i;
-        int range, channel;
-        unsigned char hi, lo, status;
-
-        /* change channel and range only if it is different from the previous */
-        range = CR_RANGE(insn->chanspec);
-        channel = CR_CHAN(insn->chanspec);
-        if (channel != devpriv->last_channel || range != devpriv->last_range) {
-          outb((range << 4) | channel, dev->iobase + ADQ12B_CTREG);
-          udelay(50);   /* wait for the mux to settle */
-        }
-
-        /* trigger conversion */
-        status = inb(dev->iobase + ADQ12B_ADLOW);
-
-        /* convert n samples */
-        for (n=0; n < insn->n; n++){
-
-          /* wait for end of convertion */
-	  i = 0;
-          do {
+	int n, i;
+	int range, channel;
+	unsigned char hi, lo, status;
+
+	/* change channel and range only if it is different from the previous */
+	range = CR_RANGE(insn->chanspec);
+	channel = CR_CHAN(insn->chanspec);
+	if (channel != devpriv->last_channel || range != devpriv->last_range) {
+		outb((range << 4) | channel, dev->iobase + ADQ12B_CTREG);
+		udelay(50);	/* wait for the mux to settle */
+	}
+
+	/* trigger conversion */
+	status = inb(dev->iobase + ADQ12B_ADLOW);
+
+	/* convert n samples */
+	for (n = 0; n < insn->n; n++) {
+
+		/* wait for end of convertion */
+		i = 0;
+		do {
 /* udelay(1); */
-	    status = inb(dev->iobase + ADQ12B_STINR);
-            status = status & ADQ12B_EOC;
-          } while (status == 0 && ++i < TIMEOUT);
+			status = inb(dev->iobase + ADQ12B_STINR);
+			status = status & ADQ12B_EOC;
+		} while (status == 0 && ++i < TIMEOUT);
 /* } while (++i < 10); */
 
-          /* read data */
-          hi = inb(dev->iobase + ADQ12B_ADHIG);
-          lo = inb(dev->iobase + ADQ12B_ADLOW);
+		/* read data */
+		hi = inb(dev->iobase + ADQ12B_ADHIG);
+		lo = inb(dev->iobase + ADQ12B_ADLOW);
 
-          /* printk("debug: chan=%d range=%d status=%d hi=%d lo=%d\n", channel, range, status,  hi, lo); */
-          data[n] = (hi << 8) | lo;
+		/* printk("debug: chan=%d range=%d status=%d hi=%d lo=%d\n", channel, range, status,  hi, lo); */
+		data[n] = (hi << 8) | lo;
 
-        }
+	}
 
-        /* return the number of samples read/written */
-        return n;
+	/* return the number of samples read/written */
+	return n;
 }
 
-
-static int adq12b_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s, 	struct comedi_insn *insn, unsigned int *data)
+static int adq12b_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
-        /* only bits 0-4 have information about digital inputs */
-        data[1] = (inb(dev->iobase+ADQ12B_STINR) & (0x1f));
+	/* only bits 0-4 have information about digital inputs */
+	data[1] = (inb(dev->iobase + ADQ12B_STINR) & (0x1f));
 
-        return 2;
+	return 2;
 }
 
-
-static int adq12b_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s, 	struct comedi_insn *insn, unsigned int *data)
+static int adq12b_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
-        int channel;
+	int channel;
 
 	for (channel = 0; channel < 8; channel++)
-	  if (((data[0]>>channel) & 0x01) != 0)
-            outb((((data[1]>>channel)&0x01)<<3) | channel, dev->iobase + ADQ12B_OUTBR);
-
-        /* store information to retrieve when asked for reading */
-        if (data[0]) {
-          devpriv->digital_state &= ~data[0];
-          devpriv->digital_state |= (data[0]&data[1]);
-        }
+		if (((data[0] >> channel) & 0x01) != 0)
+			outb((((data[1] >> channel) & 0x01) << 3) | channel,
+			     dev->iobase + ADQ12B_OUTBR);
+
+	/* store information to retrieve when asked for reading */
+	if (data[0]) {
+		devpriv->digital_state &= ~data[0];
+		devpriv->digital_state |= (data[0] & data[1]);
+	}
 
-        data[1] = devpriv->digital_state;
+	data[1] = devpriv->digital_state;
 
-        return 2;
+	return 2;
 }
 
-
 /*
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
--- a/drivers/staging/comedi/drivers/adv_pci1710.c
+++ b/drivers/staging/comedi/drivers/adv_pci1710.c
@@ -124,67 +124,69 @@ Configuration options:
 #define Syncont_SC0	 1	/* set synchronous output mode */
 
 static const struct comedi_lrange range_pci1710_3 = { 9, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			BIP_RANGE(10),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-	}
+							  BIP_RANGE(5),
+							  BIP_RANGE(2.5),
+							  BIP_RANGE(1.25),
+							  BIP_RANGE(0.625),
+							  BIP_RANGE(10),
+							  UNI_RANGE(10),
+							  UNI_RANGE(5),
+							  UNI_RANGE(2.5),
+							  UNI_RANGE(1.25)
+							  }
 };
 
 static const char range_codes_pci1710_3[] =
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x10, 0x11, 0x12, 0x13 };
+    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x10, 0x11, 0x12, 0x13 };
 
 static const struct comedi_lrange range_pci1710hg = { 12, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.005),
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01)
-	}
+							   BIP_RANGE(5),
+							   BIP_RANGE(0.5),
+							   BIP_RANGE(0.05),
+							   BIP_RANGE(0.005),
+							   BIP_RANGE(10),
+							   BIP_RANGE(1),
+							   BIP_RANGE(0.1),
+							   BIP_RANGE(0.01),
+							   UNI_RANGE(10),
+							   UNI_RANGE(1),
+							   UNI_RANGE(0.1),
+							   UNI_RANGE(0.01)
+							   }
 };
 
 static const char range_codes_pci1710hg[] =
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12,
-		0x13 };
+    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12,
+	0x13
+};
 
 static const struct comedi_lrange range_pci17x1 = { 5, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625)
-	}
+							BIP_RANGE(10),
+							BIP_RANGE(5),
+							BIP_RANGE(2.5),
+							BIP_RANGE(1.25),
+							BIP_RANGE(0.625)
+							}
 };
 
 static const char range_codes_pci17x1[] = { 0x00, 0x01, 0x02, 0x03, 0x04 };
 
 static const struct comedi_lrange range_pci1720 = { 4, {
-			UNI_RANGE(5),
-			UNI_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(10)
-	}
+							UNI_RANGE(5),
+							UNI_RANGE(10),
+							BIP_RANGE(5),
+							BIP_RANGE(10)
+							}
 };
 
 static const struct comedi_lrange range_pci171x_da = { 2, {
-			UNI_RANGE(5),
-			UNI_RANGE(10),
-	}
+							   UNI_RANGE(5),
+							   UNI_RANGE(10),
+							   }
 };
 
-static int pci1710_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci1710_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pci1710_detach(struct comedi_device *dev);
 
 struct boardtype {
@@ -209,49 +211,50 @@ struct boardtype {
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci1710_pci_table) = {
-	{PCI_VENDOR_ID_ADVANTECH, 0x1710, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1711, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1713, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1720, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1731, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_ADVANTECH, 0x1710, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1711, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1713, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1720, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1731, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci1710_pci_table);
 
 static const struct boardtype boardtypes[] = {
 	{"pci1710", 0x1710,
-		IORANGE_171x, 1, TYPE_PCI171X,
-		16, 8, 2, 16, 16, 1, 0x0fff, 0x0fff,
-		&range_pci1710_3, range_codes_pci1710_3,
-		&range_pci171x_da,
-		10000, 2048},
+	 IORANGE_171x, 1, TYPE_PCI171X,
+	 16, 8, 2, 16, 16, 1, 0x0fff, 0x0fff,
+	 &range_pci1710_3, range_codes_pci1710_3,
+	 &range_pci171x_da,
+	 10000, 2048},
 	{"pci1710hg", 0x1710,
-		IORANGE_171x, 1, TYPE_PCI171X,
-		16, 8, 2, 16, 16, 1, 0x0fff, 0x0fff,
-		&range_pci1710hg, range_codes_pci1710hg,
-		&range_pci171x_da,
-		10000, 2048},
+	 IORANGE_171x, 1, TYPE_PCI171X,
+	 16, 8, 2, 16, 16, 1, 0x0fff, 0x0fff,
+	 &range_pci1710hg, range_codes_pci1710hg,
+	 &range_pci171x_da,
+	 10000, 2048},
 	{"pci1711", 0x1711,
-		IORANGE_171x, 1, TYPE_PCI171X,
-		16, 0, 2, 16, 16, 1, 0x0fff, 0x0fff,
-		&range_pci17x1, range_codes_pci17x1, &range_pci171x_da,
-		10000, 512},
+	 IORANGE_171x, 1, TYPE_PCI171X,
+	 16, 0, 2, 16, 16, 1, 0x0fff, 0x0fff,
+	 &range_pci17x1, range_codes_pci17x1, &range_pci171x_da,
+	 10000, 512},
 	{"pci1713", 0x1713,
-		IORANGE_171x, 1, TYPE_PCI1713,
-		32, 16, 0, 0, 0, 0, 0x0fff, 0x0000,
-		&range_pci1710_3, range_codes_pci1710_3, NULL,
-		10000, 2048},
+	 IORANGE_171x, 1, TYPE_PCI1713,
+	 32, 16, 0, 0, 0, 0, 0x0fff, 0x0000,
+	 &range_pci1710_3, range_codes_pci1710_3, NULL,
+	 10000, 2048},
 	{"pci1720", 0x1720,
-		IORANGE_1720, 0, TYPE_PCI1720,
-		0, 0, 4, 0, 0, 0, 0x0000, 0x0fff,
-		NULL, NULL, &range_pci1720,
-		0, 0},
+	 IORANGE_1720, 0, TYPE_PCI1720,
+	 0, 0, 4, 0, 0, 0, 0x0000, 0x0fff,
+	 NULL, NULL, &range_pci1720,
+	 0, 0},
 	{"pci1731", 0x1731,
-		IORANGE_171x, 1, TYPE_PCI171X,
-		16, 0, 0, 16, 16, 0, 0x0fff, 0x0000,
-		&range_pci17x1, range_codes_pci17x1, NULL,
-		10000, 512},
+	 IORANGE_171x, 1, TYPE_PCI171X,
+	 16, 0, 0, 16, 16, 0, 0x0fff, 0x0000,
+	 &range_pci17x1, range_codes_pci17x1, NULL,
+	 10000, 512},
 	/*  dummy entry corresponding to driver name */
 	{.name = DRV_NAME},
 };
@@ -292,7 +295,7 @@ struct pci1710_private {
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_flags;	/*  flaglist */
 	unsigned int ai_data_len;	/*  len of data buffer */
-	short *ai_data;	/*  data buffer */
+	short *ai_data;		/*  data buffer */
 	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
 	short ao_data[4];	/*  data output buffer */
@@ -306,14 +309,18 @@ struct pci1710_private {
 ==============================================================================
 */
 
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan);
-static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen);
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2);
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int n_chan);
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int n_chan,
+			       unsigned int seglen);
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2);
 static int pci1710_reset(struct comedi_device *dev);
-static int pci171x_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci171x_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 
 static const unsigned int muxonechan[] = { 0x0000, 0x0101, 0x0202, 0x0303, 0x0404, 0x0505, 0x0606, 0x0707,	/*  used for gain list programming */
 	0x0808, 0x0909, 0x0a0a, 0x0b0b, 0x0c0c, 0x0d0d, 0x0e0e, 0x0f0f,
@@ -324,8 +331,9 @@ static const unsigned int muxonechan[] =
 /*
 ==============================================================================
 */
-static int pci171x_insn_read_ai(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci171x_insn_read_ai(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int n, timeout;
 #ifdef PCI171x_PARANOIDCHECK
@@ -364,10 +372,12 @@ static int pci171x_insn_read_ai(struct c
 		outb(0, dev->iobase + PCI171x_CLRFIFO);
 		outb(0, dev->iobase + PCI171x_CLRINT);
 		data[n] = 0;
-		DPRINTK("adv_pci1710 EDBG: END: pci171x_insn_read_ai(...) n=%d\n", n);
+		DPRINTK
+		    ("adv_pci1710 EDBG: END: pci171x_insn_read_ai(...) n=%d\n",
+		     n);
 		return -ETIME;
 
-	      conv_finish:
+conv_finish:
 #ifdef PCI171x_PARANOIDCHECK
 		idata = inw(dev->iobase + PCI171x_AD_DATA);
 		if (this_board->cardtype != TYPE_PCI1713)
@@ -392,8 +402,9 @@ static int pci171x_insn_read_ai(struct c
 /*
 ==============================================================================
 */
-static int pci171x_insn_write_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci171x_insn_write_ao(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan, range, ofs;
 
@@ -423,8 +434,9 @@ static int pci171x_insn_write_ao(struct 
 /*
 ==============================================================================
 */
-static int pci171x_insn_read_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci171x_insn_read_ao(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan;
 
@@ -438,8 +450,9 @@ static int pci171x_insn_read_ao(struct c
 /*
 ==============================================================================
 */
-static int pci171x_insn_bits_di(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci171x_insn_bits_di(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	data[1] = inw(dev->iobase + PCI171x_DI);
 
@@ -449,8 +462,9 @@ static int pci171x_insn_bits_di(struct c
 /*
 ==============================================================================
 */
-static int pci171x_insn_bits_do(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci171x_insn_bits_do(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -465,8 +479,10 @@ static int pci171x_insn_bits_do(struct c
 /*
 ==============================================================================
 */
-static int pci171x_insn_counter_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci171x_insn_counter_read(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 	unsigned int msb, lsb, ccntrl;
 	int i;
@@ -487,8 +503,10 @@ static int pci171x_insn_counter_read(str
 /*
 ==============================================================================
 */
-static int pci171x_insn_counter_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci171x_insn_counter_write(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	uint msb, lsb, ccntrl, status;
 
@@ -515,7 +533,9 @@ static int pci171x_insn_counter_write(st
 ==============================================================================
 */
 static int pci171x_insn_counter_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data)
 {
 #ifdef unused
 	/* This doesn't work like a normal Comedi counter config */
@@ -550,8 +570,9 @@ static int pci171x_insn_counter_config(s
 /*
 ==============================================================================
 */
-static int pci1720_insn_write_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1720_insn_write_ao(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int n, rangereg, chan;
 
@@ -596,8 +617,8 @@ static void interrupt_pci1710_every_samp
 	}
 	if (m & Status_FF) {
 		printk
-			("comedi%d: A/D FIFO Full status (Fatal Error!) (%4x)\n",
-			dev->minor, m);
+		    ("comedi%d: A/D FIFO Full status (Fatal Error!) (%4x)\n",
+		     dev->minor, m);
 		pci171x_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
@@ -613,16 +634,17 @@ static void interrupt_pci1710_every_samp
 		DPRINTK("%04x:", sampl);
 		if (this_board->cardtype != TYPE_PCI1713)
 			if ((sampl & 0xf000) !=
-				devpriv->act_chanlist[s->async->cur_chan]) {
+			    devpriv->act_chanlist[s->async->cur_chan]) {
 				printk
-					("comedi: A/D data dropout: received data from channel %d, expected %d!\n",
-					(sampl & 0xf000) >> 12,
-					(devpriv->act_chanlist[s->async->
-							cur_chan] & 0xf000) >>
-					12);
+				    ("comedi: A/D data dropout: received data from channel %d, expected %d!\n",
+				     (sampl & 0xf000) >> 12,
+				     (devpriv->
+				      act_chanlist[s->
+						   async->cur_chan] & 0xf000) >>
+				     12);
 				pci171x_ai_cancel(dev, s);
 				s->async->events |=
-					COMEDI_CB_EOA | COMEDI_CB_ERROR;
+				    COMEDI_CB_EOA | COMEDI_CB_ERROR;
 				comedi_event(dev, s);
 				return;
 			}
@@ -631,7 +653,7 @@ static void interrupt_pci1710_every_samp
 		comedi_buf_put(s->async, sampl & 0x0fff);
 #else
 		comedi_buf_put(s->async,
-			inw(dev->iobase + PCI171x_AD_DATA) & 0x0fff);
+			       inw(dev->iobase + PCI171x_AD_DATA) & 0x0fff);
 #endif
 		++s->async->cur_chan;
 
@@ -641,7 +663,10 @@ static void interrupt_pci1710_every_samp
 
 		if (s->async->cur_chan == 0) {	/*  one scan done */
 			devpriv->ai_act_scan++;
-			DPRINTK("adv_pci1710 EDBG: EOS1 bic %d bip %d buc %d bup %d\n", s->async->buf_int_count, s->async->buf_int_ptr, s->async->buf_user_count, s->async->buf_user_ptr);
+			DPRINTK
+			    ("adv_pci1710 EDBG: EOS1 bic %d bip %d buc %d bup %d\n",
+			     s->async->buf_int_count, s->async->buf_int_ptr,
+			     s->async->buf_user_count, s->async->buf_user_ptr);
 			DPRINTK("adv_pci1710 EDBG: EOS2\n");
 			if ((!devpriv->neverending_ai) && (devpriv->ai_act_scan >= devpriv->ai_scans)) {	/*  all data sampled */
 				pci171x_ai_cancel(dev, s);
@@ -661,8 +686,8 @@ static void interrupt_pci1710_every_samp
 /*
 ==============================================================================
 */
-static int move_block_from_fifo(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n, int turn)
+static int move_block_from_fifo(struct comedi_device *dev,
+				struct comedi_subdevice *s, int n, int turn)
 {
 	int i, j;
 #ifdef PCI171x_PARANOIDCHECK
@@ -677,22 +702,21 @@ static int move_block_from_fifo(struct c
 		if (this_board->cardtype != TYPE_PCI1713)
 			if ((sampl & 0xf000) != devpriv->act_chanlist[j]) {
 				printk
-					("comedi%d: A/D  FIFO data dropout: received data from channel %d, expected %d! (%d/%d/%d/%d/%d/%4x)\n",
-					dev->minor, (sampl & 0xf000) >> 12,
-					(devpriv->
-						act_chanlist[j] & 0xf000) >> 12,
-					i, j, devpriv->ai_act_scan, n, turn,
-					sampl);
+				    ("comedi%d: A/D  FIFO data dropout: received data from channel %d, expected %d! (%d/%d/%d/%d/%d/%4x)\n",
+				     dev->minor, (sampl & 0xf000) >> 12,
+				     (devpriv->act_chanlist[j] & 0xf000) >> 12,
+				     i, j, devpriv->ai_act_scan, n, turn,
+				     sampl);
 				pci171x_ai_cancel(dev, s);
 				s->async->events |=
-					COMEDI_CB_EOA | COMEDI_CB_ERROR;
+				    COMEDI_CB_EOA | COMEDI_CB_ERROR;
 				comedi_event(dev, s);
 				return 1;
 			}
 		comedi_buf_put(s->async, sampl & 0x0fff);
 #else
 		comedi_buf_put(s->async,
-			inw(dev->iobase + PCI171x_AD_DATA) & 0x0fff);
+			       inw(dev->iobase + PCI171x_AD_DATA) & 0x0fff);
 #endif
 		j++;
 		if (j >= devpriv->ai_n_chan) {
@@ -717,7 +741,7 @@ static void interrupt_pci1710_half_fifo(
 	m = inw(dev->iobase + PCI171x_STATUS);
 	if (!(m & Status_FH)) {
 		printk("comedi%d: A/D FIFO not half full! (%4x)\n",
-			dev->minor, m);
+		       dev->minor, m);
 		pci171x_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
@@ -725,8 +749,8 @@ static void interrupt_pci1710_half_fifo(
 	}
 	if (m & Status_FF) {
 		printk
-			("comedi%d: A/D FIFO Full status (Fatal Error!) (%4x)\n",
-			dev->minor, m);
+		    ("comedi%d: A/D FIFO Full status (Fatal Error!) (%4x)\n",
+		     dev->minor, m);
 		pci171x_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
@@ -804,7 +828,7 @@ static irqreturn_t interrupt_service_pci
 ==============================================================================
 */
 static int pci171x_ai_docmd_and_mode(int mode, struct comedi_device *dev,
-	struct comedi_subdevice *s)
+				     struct comedi_subdevice *s)
 {
 	unsigned int divisor1, divisor2;
 	unsigned int seglen;
@@ -814,11 +838,11 @@ static int pci171x_ai_docmd_and_mode(int
 	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
-		devpriv->ai_n_chan);
+				    devpriv->ai_n_chan);
 	if (seglen < 1)
 		return -EINVAL;
 	setup_channel_list(dev, s, devpriv->ai_chanlist,
-		devpriv->ai_n_chan, seglen);
+			   devpriv->ai_n_chan, seglen);
 
 	outb(0, dev->iobase + PCI171x_CLRFIFO);
 	outb(0, dev->iobase + PCI171x_CLRINT);
@@ -840,7 +864,7 @@ static int pci171x_ai_docmd_and_mode(int
 
 	if ((devpriv->ai_scans == 0) || (devpriv->ai_scans == -1)) {
 		devpriv->neverending_ai = 1;
-	}			/* well, user want neverending */
+	} /* well, user want neverending */
 	else {
 		devpriv->neverending_ai = 0;
 	}
@@ -853,16 +877,19 @@ static int pci171x_ai_docmd_and_mode(int
 		if (mode == 2) {
 			devpriv->ai_et_CntrlReg = devpriv->CntrlReg;
 			devpriv->CntrlReg &=
-				~(Control_PACER | Control_ONEFH | Control_GATE);
+			    ~(Control_PACER | Control_ONEFH | Control_GATE);
 			devpriv->CntrlReg |= Control_EXT;
 			devpriv->ai_et = 1;
 		} else {
 			devpriv->ai_et = 0;
 		}
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
-			&divisor2, &devpriv->ai_timer1,
-			devpriv->ai_flags & TRIG_ROUND_MASK);
-		DPRINTK("adv_pci1710 EDBG: OSC base=%u div1=%u div2=%u timer=%u\n", devpriv->i8254_osc_base, divisor1, divisor2, devpriv->ai_timer1);
+					  &divisor2, &devpriv->ai_timer1,
+					  devpriv->ai_flags & TRIG_ROUND_MASK);
+		DPRINTK
+		    ("adv_pci1710 EDBG: OSC base=%u div1=%u div2=%u timer=%u\n",
+		     devpriv->i8254_osc_base, divisor1, divisor2,
+		     devpriv->ai_timer1);
 		outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);
 		if (mode != 2) {
 			/*  start pacer */
@@ -889,21 +916,22 @@ static int pci171x_ai_docmd_and_mode(int
 static void pci171x_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
 	printk("adv_pci1710 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
-		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
+	       cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
 	printk("adv_pci1710 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
-		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
+	       cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
 	printk("adv_pci1710 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
-		cmd->scan_end_src);
+	       cmd->scan_end_src);
 	printk("adv_pci1710 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n",
-		e, cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
+	       e, cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 #endif
 
 /*
 ==============================================================================
 */
-static int pci171x_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pci171x_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -943,7 +971,9 @@ static int pci171x_ai_cmdtest(struct com
 #ifdef PCI171X_EXTDEBUG
 		pci171x_cmdtest_out(1, cmd);
 #endif
-		DPRINTK("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) err=%d ret=1\n", err);
+		DPRINTK
+		    ("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) err=%d ret=1\n",
+		     err);
 		return 1;
 	}
 
@@ -974,7 +1004,9 @@ static int pci171x_ai_cmdtest(struct com
 #ifdef PCI171X_EXTDEBUG
 		pci171x_cmdtest_out(2, cmd);
 #endif
-		DPRINTK("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) err=%d ret=2\n", err);
+		DPRINTK
+		    ("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) err=%d ret=2\n",
+		     err);
 		return 2;
 	}
 
@@ -1030,7 +1062,9 @@ static int pci171x_ai_cmdtest(struct com
 #ifdef PCI171X_EXTDEBUG
 		pci171x_cmdtest_out(3, cmd);
 #endif
-		DPRINTK("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) err=%d ret=3\n", err);
+		DPRINTK
+		    ("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) err=%d ret=3\n",
+		     err);
 		return 3;
 	}
 
@@ -1039,8 +1073,8 @@ static int pci171x_ai_cmdtest(struct com
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -1048,7 +1082,9 @@ static int pci171x_ai_cmdtest(struct com
 	}
 
 	if (err) {
-		DPRINTK("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) err=%d ret=4\n", err);
+		DPRINTK
+		    ("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) err=%d ret=4\n",
+		     err);
 		return 4;
 	}
 
@@ -1056,7 +1092,7 @@ static int pci171x_ai_cmdtest(struct com
 
 	if (cmd->chanlist) {
 		if (!check_channel_list(dev, s, cmd->chanlist,
-				cmd->chanlist_len))
+					cmd->chanlist_len))
 			return 5;	/*  incorrect channels list */
 	}
 
@@ -1090,7 +1126,8 @@ static int pci171x_ai_cmd(struct comedi_
 		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 and 2 */
 			devpriv->ai_timer1 = cmd->convert_arg;
 			return pci171x_ai_docmd_and_mode(cmd->start_src ==
-				TRIG_EXT ? 2 : 1, dev, s);
+							 TRIG_EXT ? 2 : 1, dev,
+							 s);
 		}
 		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
 			return pci171x_ai_docmd_and_mode(3, dev, s);
@@ -1106,8 +1143,9 @@ static int pci171x_ai_cmd(struct comedi_
  If it's ok, then program scan/gain logic.
  This works for all cards.
 */
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan)
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int chansegment[32];
 	unsigned int i, nowmustbechan, seglen, segpos;
@@ -1128,18 +1166,18 @@ static int check_channel_list(struct com
 			if (CR_CHAN(chanlist[i]) & 1)	/*  odd channel cann't by differencial */
 				if (CR_AREF(chanlist[i]) == AREF_DIFF) {
 					comedi_error(dev,
-						"Odd channel can't be differential input!\n");
+						     "Odd channel can't be differential input!\n");
 					return 0;
 				}
 			nowmustbechan =
-				(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
+			    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
 			if (CR_AREF(chansegment[i - 1]) == AREF_DIFF)
 				nowmustbechan = (nowmustbechan + 1) % s->n_chan;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
 				printk
-					("channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
-					i, CR_CHAN(chanlist[i]), nowmustbechan,
-					CR_CHAN(chanlist[0]));
+				    ("channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+				     i, CR_CHAN(chanlist[i]), nowmustbechan,
+				     CR_CHAN(chanlist[0]));
 				return 0;
 			}
 			chansegment[i] = chanlist[i];	/*  well, this is next correct channel in list */
@@ -1149,13 +1187,13 @@ static int check_channel_list(struct com
 			/* printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
 				printk
-					("bad channel, reference or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
-					i, CR_CHAN(chansegment[i]),
-					CR_RANGE(chansegment[i]),
-					CR_AREF(chansegment[i]),
-					CR_CHAN(chanlist[i % seglen]),
-					CR_RANGE(chanlist[i % seglen]),
-					CR_AREF(chansegment[i % seglen]));
+				    ("bad channel, reference or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+				     i, CR_CHAN(chansegment[i]),
+				     CR_RANGE(chansegment[i]),
+				     CR_AREF(chansegment[i]),
+				     CR_CHAN(chanlist[i % seglen]),
+				     CR_RANGE(chanlist[i % seglen]),
+				     CR_AREF(chansegment[i % seglen]));
 				return 0;	/*  chan/gain list is strange */
 			}
 		}
@@ -1165,8 +1203,10 @@ static int check_channel_list(struct com
 	return seglen;
 }
 
-static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen)
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int n_chan,
+			       unsigned int seglen)
 {
 	unsigned int i, range, chanprog;
 
@@ -1185,14 +1225,14 @@ static void setup_channel_list(struct co
 		outw(range, dev->iobase + PCI171x_RANGE);	/* select gain */
 #ifdef PCI171x_PARANOIDCHECK
 		devpriv->act_chanlist[i] =
-			(CR_CHAN(chanlist[i]) << 12) & 0xf000;
+		    (CR_CHAN(chanlist[i]) << 12) & 0xf000;
 #endif
 		DPRINTK("GS: %2d. [%4x]=%4x %4x\n", i, chanprog, range,
 			devpriv->act_chanlist[i]);
 	}
 
 	devpriv->ai_et_MuxVal =
-		CR_CHAN(chanlist[0]) | (CR_CHAN(chanlist[seglen - 1]) << 8);
+	    CR_CHAN(chanlist[0]) | (CR_CHAN(chanlist[seglen - 1]) << 8);
 	outw(devpriv->ai_et_MuxVal, dev->iobase + PCI171x_MUX);	/* select channel interval to scan */
 	DPRINTK("MUX: %4x L%4x.H%4x\n",
 		CR_CHAN(chanlist[0]) | (CR_CHAN(chanlist[seglen - 1]) << 8),
@@ -1202,8 +1242,8 @@ static void setup_channel_list(struct co
 /*
 ==============================================================================
 */
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2)
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2)
 {
 	DPRINTK("adv_pci1710 EDBG: BGN: start_pacer(%d,%u,%u)\n", mode,
 		divisor1, divisor2);
@@ -1222,7 +1262,8 @@ static void start_pacer(struct comedi_de
 /*
 ==============================================================================
 */
-static int pci171x_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci171x_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	DPRINTK("adv_pci1710 EDBG: BGN: pci171x_ai_cancel(...)\n");
 
@@ -1318,7 +1359,8 @@ static int pci1710_reset(struct comedi_d
 /*
 ==============================================================================
 */
-static int pci1710_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci1710_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret, subdev, n_subdevices;
@@ -1347,36 +1389,35 @@ static int pci1710_attach(struct comedi_
 	pcidev = NULL;
 	board_index = this_board - boardtypes;
 	while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_ADVANTECH,
-		PCI_ANY_ID, pcidev))) {
-		if (strcmp (this_board->name, DRV_NAME) == 0)
-		{
-			for (i = 0; i < n_boardtypes; ++i)
-			{
-				if (pcidev->device == boardtypes[i].device_id)
-				{
+						PCI_ANY_ID, pcidev))) {
+		if (strcmp(this_board->name, DRV_NAME) == 0) {
+			for (i = 0; i < n_boardtypes; ++i) {
+				if (pcidev->device == boardtypes[i].device_id) {
 					board_index = i;
 					break;
 				}
 			}
-			if (i == n_boardtypes) continue;
-		}else
-		{
-			if (pcidev->device != boardtypes[board_index].device_id) continue;
+			if (i == n_boardtypes)
+				continue;
+		} else {
+			if (pcidev->device != boardtypes[board_index].device_id)
+				continue;
 		}
 
 		/* Found matching vendor/device. */
 		if (opt_bus || opt_slot) {
 			/* Check bus/slot. */
 			if (opt_bus != pcidev->bus->number
-				|| opt_slot != PCI_SLOT(pcidev->devfn))
+			    || opt_slot != PCI_SLOT(pcidev->devfn))
 				continue;	/* no match */
 		}
 		/*
-		* Look for device that isn't in use.
-		* Enable PCI device and request regions.
-		*/
+		 * Look for device that isn't in use.
+		 * Enable PCI device and request regions.
+		 */
 		if (comedi_pci_enable(pcidev, DRV_NAME)) {
-			errstr = "failed to enable PCI device and request regions!";
+			errstr =
+			    "failed to enable PCI device and request regions!";
 			continue;
 		}
 		/*  fixup board_ptr in case we were using the dummy entry with the driver name */
@@ -1387,7 +1428,7 @@ static int pci1710_attach(struct comedi_
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
 			printk(" - Card at b:s %d:%d %s\n",
-				opt_bus, opt_slot, errstr);
+			       opt_bus, opt_slot, errstr);
 		} else {
 			printk(" - Card %s\n", errstr);
 		}
@@ -1401,7 +1442,7 @@ static int pci1710_attach(struct comedi_
 	iobase = pci_resource_start(pcidev, 2);
 
 	printk(", b:s:f=%d:%d:%d, io=0x%4lx", pci_bus, pci_slot, pci_func,
-		iobase);
+	       iobase);
 
 	dev->iobase = iobase;
 
@@ -1434,8 +1475,8 @@ static int pci1710_attach(struct comedi_
 					IRQF_SHARED, "Advantech PCI-1710",
 					dev)) {
 				printk
-					(", unable to allocate IRQ %d, DISABLING IT",
-					irq);
+				    (", unable to allocate IRQ %d, DISABLING IT",
+				     irq);
 				irq = 0;	/* Can't use IRQ */
 			} else {
 				printk(", irq=%u", irq);
--- a/drivers/staging/comedi/drivers/adv_pci1723.c
+++ b/drivers/staging/comedi/drivers/adv_pci1723.c
@@ -95,8 +95,8 @@ TODO:
 /* static unsigned short pci_list_builded=0;      =1 list of card is know */
 
 static const struct comedi_lrange range_pci1723 = { 1, {
-			BIP_RANGE(10)
-	}
+							BIP_RANGE(10)
+							}
 };
 
 /*
@@ -116,23 +116,24 @@ struct pci1723_board {
 
 static const struct pci1723_board boardtypes[] = {
 	{
-	.name = "pci1723",
-	.vendor_id = ADVANTECH_VENDOR,
-	.device_id = 0x1723,
-	.iorange = IORANGE_1723,
-	.cardtype = TYPE_PCI1723,
-	.n_aochan = 8,
-	.n_diochan = 16,
-	.ao_maxdata = 0xffff,
-	.rangelist_ao = &range_pci1723,
-		},
+	 .name = "pci1723",
+	 .vendor_id = ADVANTECH_VENDOR,
+	 .device_id = 0x1723,
+	 .iorange = IORANGE_1723,
+	 .cardtype = TYPE_PCI1723,
+	 .n_aochan = 8,
+	 .n_diochan = 16,
+	 .ao_maxdata = 0xffff,
+	 .rangelist_ao = &range_pci1723,
+	 },
 };
 
 /* This is used by modprobe to translate PCI IDs to drivers.  Should
  * only be used for PCI and ISA-PnP devices */
 static DEFINE_PCI_DEVICE_TABLE(pci1723_pci_table) = {
-	{PCI_VENDOR_ID_ADVANTECH, 0x1723, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_ADVANTECH, 0x1723, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci1723_pci_table);
@@ -143,7 +144,8 @@ MODULE_DEVICE_TABLE(pci, pci1723_pci_tab
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci1723_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci1723_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pci1723_detach(struct comedi_device *dev);
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pci1723_board))
@@ -189,7 +191,7 @@ static int pci1723_reset(struct comedi_d
 		/*  set all ranges to +/- 10V */
 		devpriv->da_range[i] = 0;
 		outw(((devpriv->da_range[i] << 4) | i),
-			PCI1723_RANGE_CALIBRATION_MODE);
+		     PCI1723_RANGE_CALIBRATION_MODE);
 	}
 
 	outw(0, dev->iobase + PCI1723_CHANGE_CHA_OUTPUT_TYPE_STROBE);	/*  update ranges */
@@ -202,8 +204,9 @@ static int pci1723_reset(struct comedi_d
 	return 0;
 }
 
-static int pci1723_insn_read_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1723_insn_read_ao(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan;
 
@@ -218,8 +221,9 @@ static int pci1723_insn_read_ao(struct c
 /*
   analog data output;
 */
-static int pci1723_ao_write_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1723_ao_write_winsn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan;
 	chan = CR_CHAN(insn->chanspec);
@@ -238,8 +242,9 @@ static int pci1723_ao_write_winsn(struct
 /*
   digital i/o config/query
 */
-static int pci1723_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1723_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int mask;
 	unsigned int bits;
@@ -278,8 +283,9 @@ static int pci1723_dio_insn_config(struc
 /*
   digital i/o bits read/write
 */
-static int pci1723_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1723_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -294,7 +300,8 @@ static int pci1723_dio_insn_bits(struct 
  * Attach is called by the Comedi core to configure the driver
  * for a pci1723 board.
  */
-static int pci1723_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci1723_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret, subdev, n_subdevices;
@@ -304,8 +311,7 @@ static int pci1723_attach(struct comedi_
 	int opt_bus, opt_slot;
 	const char *errstr;
 
-	printk("comedi%d: adv_pci1723: board=%s", dev->minor,
-		this_board->name);
+	printk("comedi%d: adv_pci1723: board=%s", dev->minor, this_board->name);
 
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
@@ -321,12 +327,12 @@ static int pci1723_attach(struct comedi_
 	pcidev = NULL;
 	while (NULL != (pcidev =
 			pci_get_device(PCI_VENDOR_ID_ADVANTECH,
-				this_board->device_id, pcidev))) {
+				       this_board->device_id, pcidev))) {
 		/* Found matching vendor/device. */
 		if (opt_bus || opt_slot) {
 			/* Check bus/slot. */
 			if (opt_bus != pcidev->bus->number
-				|| opt_slot != PCI_SLOT(pcidev->devfn))
+			    || opt_slot != PCI_SLOT(pcidev->devfn))
 				continue;	/* no match */
 		}
 		/*
@@ -334,7 +340,8 @@ static int pci1723_attach(struct comedi_
 		 * Enable PCI device and request regions.
 		 */
 		if (comedi_pci_enable(pcidev, "adv_pci1723")) {
-			errstr = "failed to enable PCI device and request regions!";
+			errstr =
+			    "failed to enable PCI device and request regions!";
 			continue;
 		}
 		break;
@@ -343,7 +350,7 @@ static int pci1723_attach(struct comedi_
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
 			printk(" - Card at b:s %d:%d %s\n",
-				opt_bus, opt_slot, errstr);
+			       opt_bus, opt_slot, errstr);
 		} else {
 			printk(" - Card %s\n", errstr);
 		}
@@ -356,7 +363,7 @@ static int pci1723_attach(struct comedi_
 	iobase = pci_resource_start(pcidev, 2);
 
 	printk(", b:s:f=%d:%d:%d, io=0x%4x", pci_bus, pci_slot, pci_func,
-		iobase);
+	       iobase);
 
 	dev->iobase = iobase;
 
@@ -416,7 +423,7 @@ static int pci1723_attach(struct comedi_
 		s = dev->subdevices + subdev;
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags =
-			SDF_READABLE | SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
+		    SDF_READABLE | SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
 		s->n_chan = this_board->n_diochan;
 		s->maxdata = 1;
 		s->len_chanlist = this_board->n_diochan;
--- a/drivers/staging/comedi/drivers/adv_pci_dio.c
+++ b/drivers/staging/comedi/drivers/adv_pci_dio.c
@@ -84,13 +84,13 @@ enum hw_io_access {
 #define PCI173x_BOARDID	   4	/* R:   Board I/D switch for 1730/3/4 */
 
 /*  Advantech PCI-1736UP */
-#define PCI1736_IDI        0    /* R:   Isolated digital input  0-15 */
-#define PCI1736_IDO        0    /* W:   Isolated digital output 0-15 */
-#define PCI1736_3_INT_EN        0x08    /* R/W: enable/disable interrupts */
-#define PCI1736_3_INT_RF        0x0c    /* R/W: set falling/raising edge for interrupts */
-#define PCI1736_3_INT_CLR       0x10    /* R/W: clear interrupts */
-#define PCI1736_BOARDID    4            /* R:   Board I/D switch for 1736UP */
-#define PCI1736_MAINREG    0            /* Normal register (2) doesn't work */
+#define PCI1736_IDI        0	/* R:   Isolated digital input  0-15 */
+#define PCI1736_IDO        0	/* W:   Isolated digital output 0-15 */
+#define PCI1736_3_INT_EN        0x08	/* R/W: enable/disable interrupts */
+#define PCI1736_3_INT_RF        0x0c	/* R/W: set falling/raising edge for interrupts */
+#define PCI1736_3_INT_CLR       0x10	/* R/W: clear interrupts */
+#define PCI1736_BOARDID    4	/* R:   Board I/D switch for 1736UP */
+#define PCI1736_MAINREG    0	/* Normal register (2) doesn't work */
 
 /*  Advantech PCI-1750 */
 #define PCI1750_IDI	   0	/* R:   Isolated digital input  0-15 */
@@ -183,7 +183,8 @@ enum hw_io_access {
 
 #define OMBCMD_RETRY	0x03	/* 3 times try request before error */
 
-static int pci_dio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci_dio_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pci_dio_detach(struct comedi_device *dev);
 
 struct diosubd_data {
@@ -207,117 +208,118 @@ struct dio_boardtype {
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci_dio_pci_table) = {
-	{PCI_VENDOR_ID_ADVANTECH, 0x1730, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1733, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1734, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1736, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1750, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1751, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1752, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1753, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1754, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1756, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1760, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_ADVANTECH, 0x1762, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_ADVANTECH, 0x1730, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1733, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1734, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1736, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1750, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1751, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1752, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1753, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1754, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1756, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1760, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_ADVANTECH, 0x1762, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci_dio_pci_table);
 
 static const struct dio_boardtype boardtypes[] = {
 	{"pci1730", PCI_VENDOR_ID_ADVANTECH, 0x1730, PCIDIO_MAINREG,
-			TYPE_PCI1730,
-			{{16, PCI1730_DI, 2, 0}, {16, PCI1730_IDI, 2, 0}},
-			{{16, PCI1730_DO, 2, 0}, {16, PCI1730_IDO, 2, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{4, PCI173x_BOARDID, 1, SDF_INTERNAL},
-			IO_8b,
-		},
+	 TYPE_PCI1730,
+	 {{16, PCI1730_DI, 2, 0}, {16, PCI1730_IDI, 2, 0}},
+	 {{16, PCI1730_DO, 2, 0}, {16, PCI1730_IDO, 2, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {4, PCI173x_BOARDID, 1, SDF_INTERNAL},
+	 IO_8b,
+	 },
 	{"pci1733", PCI_VENDOR_ID_ADVANTECH, 0x1733, PCIDIO_MAINREG,
-			TYPE_PCI1733,
-			{{0, 0, 0, 0}, {32, PCI1733_IDI, 4, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{4, PCI173x_BOARDID, 1, SDF_INTERNAL},
-		IO_8b},
+	 TYPE_PCI1733,
+	 {{0, 0, 0, 0}, {32, PCI1733_IDI, 4, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {4, PCI173x_BOARDID, 1, SDF_INTERNAL},
+	 IO_8b},
 	{"pci1734", PCI_VENDOR_ID_ADVANTECH, 0x1734, PCIDIO_MAINREG,
-			TYPE_PCI1734,
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{0, 0, 0, 0}, {32, PCI1734_IDO, 4, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{4, PCI173x_BOARDID, 1, SDF_INTERNAL},
-		IO_8b},
+	 TYPE_PCI1734,
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{0, 0, 0, 0}, {32, PCI1734_IDO, 4, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {4, PCI173x_BOARDID, 1, SDF_INTERNAL},
+	 IO_8b},
 	{"pci1736", PCI_VENDOR_ID_ADVANTECH, 0x1736, PCI1736_MAINREG,
-			TYPE_PCI1736,
-			{{0, 0, 0, 0}, {16, PCI1736_IDI, 2, 0}},
-			{{0, 0, 0, 0}, {16, PCI1736_IDO, 2, 0}},
-			{{ 0, 0, 0, 0}, { 0, 0, 0, 0}},
-			{ 4, PCI1736_BOARDID, 1, SDF_INTERNAL},
-			IO_8b,
-        },
+	 TYPE_PCI1736,
+	 {{0, 0, 0, 0}, {16, PCI1736_IDI, 2, 0}},
+	 {{0, 0, 0, 0}, {16, PCI1736_IDO, 2, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {4, PCI1736_BOARDID, 1, SDF_INTERNAL},
+	 IO_8b,
+	 },
 	{"pci1750", PCI_VENDOR_ID_ADVANTECH, 0x1750, PCIDIO_MAINREG,
-			TYPE_PCI1750,
-			{{0, 0, 0, 0}, {16, PCI1750_IDI, 2, 0}},
-			{{0, 0, 0, 0}, {16, PCI1750_IDO, 2, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{0, 0, 0, 0},
-		IO_8b},
+	 TYPE_PCI1750,
+	 {{0, 0, 0, 0}, {16, PCI1750_IDI, 2, 0}},
+	 {{0, 0, 0, 0}, {16, PCI1750_IDO, 2, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {0, 0, 0, 0},
+	 IO_8b},
 	{"pci1751", PCI_VENDOR_ID_ADVANTECH, 0x1751, PCIDIO_MAINREG,
-			TYPE_PCI1751,
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{48, PCI1751_DIO, 2, 0}, {0, 0, 0, 0}},
-			{0, 0, 0, 0},
-		IO_8b},
+	 TYPE_PCI1751,
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{48, PCI1751_DIO, 2, 0}, {0, 0, 0, 0}},
+	 {0, 0, 0, 0},
+	 IO_8b},
 	{"pci1752", PCI_VENDOR_ID_ADVANTECH, 0x1752, PCIDIO_MAINREG,
-			TYPE_PCI1752,
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{32, PCI1752_IDO, 2, 0}, {32, PCI1752_IDO2, 2, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{4, PCI175x_BOARDID, 1, SDF_INTERNAL},
-		IO_16b},
+	 TYPE_PCI1752,
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{32, PCI1752_IDO, 2, 0}, {32, PCI1752_IDO2, 2, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {4, PCI175x_BOARDID, 1, SDF_INTERNAL},
+	 IO_16b},
 	{"pci1753", PCI_VENDOR_ID_ADVANTECH, 0x1753, PCIDIO_MAINREG,
-			TYPE_PCI1753,
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{96, PCI1753_DIO, 4, 0}, {0, 0, 0, 0}},
-			{0, 0, 0, 0},
-		IO_8b},
+	 TYPE_PCI1753,
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{96, PCI1753_DIO, 4, 0}, {0, 0, 0, 0}},
+	 {0, 0, 0, 0},
+	 IO_8b},
 	{"pci1753e", PCI_VENDOR_ID_ADVANTECH, 0x1753, PCIDIO_MAINREG,
-			TYPE_PCI1753E,
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{96, PCI1753_DIO, 4, 0}, {96, PCI1753E_DIO, 4, 0}},
-			{0, 0, 0, 0},
-		IO_8b},
+	 TYPE_PCI1753E,
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{96, PCI1753_DIO, 4, 0}, {96, PCI1753E_DIO, 4, 0}},
+	 {0, 0, 0, 0},
+	 IO_8b},
 	{"pci1754", PCI_VENDOR_ID_ADVANTECH, 0x1754, PCIDIO_MAINREG,
-			TYPE_PCI1754,
-			{{32, PCI1754_IDI, 2, 0}, {32, PCI1754_IDI2, 2, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{4, PCI175x_BOARDID, 1, SDF_INTERNAL},
-		IO_16b},
+	 TYPE_PCI1754,
+	 {{32, PCI1754_IDI, 2, 0}, {32, PCI1754_IDI2, 2, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {4, PCI175x_BOARDID, 1, SDF_INTERNAL},
+	 IO_16b},
 	{"pci1756", PCI_VENDOR_ID_ADVANTECH, 0x1756, PCIDIO_MAINREG,
-			TYPE_PCI1756,
-			{{0, 0, 0, 0}, {32, PCI1756_IDI, 2, 0}},
-			{{0, 0, 0, 0}, {32, PCI1756_IDO, 2, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{4, PCI175x_BOARDID, 1, SDF_INTERNAL},
-		IO_16b},
+	 TYPE_PCI1756,
+	 {{0, 0, 0, 0}, {32, PCI1756_IDI, 2, 0}},
+	 {{0, 0, 0, 0}, {32, PCI1756_IDO, 2, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {4, PCI175x_BOARDID, 1, SDF_INTERNAL},
+	 IO_16b},
 	{"pci1760", PCI_VENDOR_ID_ADVANTECH, 0x1760, 0,
-			TYPE_PCI1760,
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},	/*  This card have own setup work */
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{0, 0, 0, 0},
-		IO_8b},
+	 TYPE_PCI1760,
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},	/*  This card have own setup work */
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {0, 0, 0, 0},
+	 IO_8b},
 	{"pci1762", PCI_VENDOR_ID_ADVANTECH, 0x1762, PCIDIO_MAINREG,
-			TYPE_PCI1762,
-			{{0, 0, 0, 0}, {16, PCI1762_IDI, 1, 0}},
-			{{0, 0, 0, 0}, {16, PCI1762_RO, 1, 0}},
-			{{0, 0, 0, 0}, {0, 0, 0, 0}},
-			{4, PCI1762_BOARDID, 1, SDF_INTERNAL},
-		IO_16b}
+	 TYPE_PCI1762,
+	 {{0, 0, 0, 0}, {16, PCI1762_IDI, 1, 0}},
+	 {{0, 0, 0, 0}, {16, PCI1762_RO, 1, 0}},
+	 {{0, 0, 0, 0}, {0, 0, 0, 0}},
+	 {4, PCI1762_BOARDID, 1, SDF_INTERNAL},
+	 IO_16b}
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct dio_boardtype))
@@ -357,8 +359,9 @@ static struct pci_dio_private *pci_priv 
 /*
 ==============================================================================
 */
-static int pci_dio_insn_bits_di_b(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci_dio_insn_bits_di_b(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	const struct diosubd_data *d = (const struct diosubd_data *)s->private;
 	int i;
@@ -374,8 +377,9 @@ static int pci_dio_insn_bits_di_b(struct
 /*
 ==============================================================================
 */
-static int pci_dio_insn_bits_di_w(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci_dio_insn_bits_di_w(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	const struct diosubd_data *d = (const struct diosubd_data *)s->private;
 	int i;
@@ -390,8 +394,9 @@ static int pci_dio_insn_bits_di_w(struct
 /*
 ==============================================================================
 */
-static int pci_dio_insn_bits_do_b(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci_dio_insn_bits_do_b(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	const struct diosubd_data *d = (const struct diosubd_data *)s->private;
 	int i;
@@ -401,7 +406,7 @@ static int pci_dio_insn_bits_do_b(struct
 		s->state |= (data[0] & data[1]);
 		for (i = 0; i < d->regs; i++)
 			outb((s->state >> (8 * i)) & 0xff,
-				dev->iobase + d->addr + i);
+			     dev->iobase + d->addr + i);
 	}
 	data[1] = s->state;
 
@@ -411,8 +416,9 @@ static int pci_dio_insn_bits_do_b(struct
 /*
 ==============================================================================
 */
-static int pci_dio_insn_bits_do_w(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci_dio_insn_bits_do_w(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	const struct diosubd_data *d = (const struct diosubd_data *)s->private;
 	int i;
@@ -422,7 +428,7 @@ static int pci_dio_insn_bits_do_w(struct
 		s->state |= (data[0] & data[1]);
 		for (i = 0; i < d->regs; i++)
 			outw((s->state >> (16 * i)) & 0xffff,
-				dev->iobase + d->addr + 2 * i);
+			     dev->iobase + d->addr + 2 * i);
 	}
 	data[1] = s->state;
 
@@ -433,7 +439,8 @@ static int pci_dio_insn_bits_do_w(struct
 ==============================================================================
 */
 static int pci1760_unchecked_mbxrequest(struct comedi_device *dev,
-	unsigned char *omb, unsigned char *imb, int repeats)
+					unsigned char *omb, unsigned char *imb,
+					int repeats)
 {
 	int cnt, tout, ok = 0;
 
@@ -472,11 +479,11 @@ static int pci1760_clear_imb2(struct com
 }
 
 static int pci1760_mbxrequest(struct comedi_device *dev,
-	unsigned char *omb, unsigned char *imb)
+			      unsigned char *omb, unsigned char *imb)
 {
 	if (omb[2] == CMD_ClearIMB2) {
 		comedi_error(dev,
-			"bug! this function should not be used for CMD_ClearIMB2 command");
+			     "bug! this function should not be used for CMD_ClearIMB2 command");
 		return -EINVAL;
 	}
 	if (inb(dev->iobase + IMB2) == omb[2]) {
@@ -491,8 +498,9 @@ static int pci1760_mbxrequest(struct com
 /*
 ==============================================================================
 */
-static int pci1760_insn_bits_di(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1760_insn_bits_di(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	data[1] = inb(dev->iobase + IMB3);
 
@@ -502,8 +510,9 @@ static int pci1760_insn_bits_di(struct c
 /*
 ==============================================================================
 */
-static int pci1760_insn_bits_do(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1760_insn_bits_do(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int ret;
 	unsigned char omb[4] = {
@@ -530,8 +539,9 @@ static int pci1760_insn_bits_do(struct c
 /*
 ==============================================================================
 */
-static int pci1760_insn_cnt_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1760_insn_cnt_read(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int ret, n;
 	unsigned char omb[4] = {
@@ -555,8 +565,9 @@ static int pci1760_insn_cnt_read(struct 
 /*
 ==============================================================================
 */
-static int pci1760_insn_cnt_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci1760_insn_cnt_write(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int ret;
 	unsigned char chan = CR_CHAN(insn->chanspec) & 0x07;
@@ -570,7 +581,7 @@ static int pci1760_insn_cnt_write(struct
 	unsigned char imb[4];
 
 	if (devpriv->CntResValue[chan] != (data[0] & 0xffff)) {	/*  Set reset value if different */
-		ret =  pci1760_mbxrequest(dev, omb, imb);
+		ret = pci1760_mbxrequest(dev, omb, imb);
 		if (!ret)
 			return ret;
 		devpriv->CntResValue[chan] = data[0] & 0xffff;
@@ -697,11 +708,11 @@ static int pci_dio_reset(struct comedi_d
 		break;
 
 	case TYPE_PCI1736:
-		outb(0, dev->iobase+PCI1736_IDO);
-		outb(0, dev->iobase+PCI1736_IDO+1);
-		outb(0, dev->iobase+PCI1736_3_INT_EN);  /*  disable interrupts */
-		outb(0x0f, dev->iobase+PCI1736_3_INT_CLR);/*  clear interrupts */
-		outb(0, dev->iobase+PCI1736_3_INT_RF);  /*  set rising edge trigger */
+		outb(0, dev->iobase + PCI1736_IDO);
+		outb(0, dev->iobase + PCI1736_IDO + 1);
+		outb(0, dev->iobase + PCI1736_3_INT_EN);	/*  disable interrupts */
+		outb(0x0f, dev->iobase + PCI1736_3_INT_CLR);	/*  clear interrupts */
+		outb(0, dev->iobase + PCI1736_3_INT_RF);	/*  set rising edge trigger */
 		break;
 
 	case TYPE_PCI1750:
@@ -756,7 +767,8 @@ static int pci_dio_reset(struct comedi_d
 /*
 ==============================================================================
 */
-static int pci1760_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci1760_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int subdev = 0;
@@ -809,7 +821,7 @@ static int pci1760_attach(struct comedi_
 ==============================================================================
 */
 static int pci_dio_add_di(struct comedi_device *dev, struct comedi_subdevice *s,
-	const struct diosubd_data *d, int subdev)
+			  const struct diosubd_data *d, int subdev)
 {
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON | d->specflags;
@@ -836,7 +848,7 @@ static int pci_dio_add_di(struct comedi_
 ==============================================================================
 */
 static int pci_dio_add_do(struct comedi_device *dev, struct comedi_subdevice *s,
-	const struct diosubd_data *d, int subdev)
+			  const struct diosubd_data *d, int subdev)
 {
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
@@ -863,8 +875,9 @@ static int pci_dio_add_do(struct comedi_
 /*
 ==============================================================================
 */
-static int CheckAndAllocCard(struct comedi_device *dev, struct comedi_devconfig *it,
-	struct pci_dev *pcidev)
+static int CheckAndAllocCard(struct comedi_device *dev,
+			     struct comedi_devconfig *it,
+			     struct pci_dev *pcidev)
 {
 	struct pci_dio_private *pr, *prev;
 
@@ -889,7 +902,8 @@ static int CheckAndAllocCard(struct come
 /*
 ==============================================================================
 */
-static int pci_dio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci_dio_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret, subdev, n_subdevices, i, j;
@@ -905,8 +919,8 @@ static int pci_dio_attach(struct comedi_
 	}
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		/*  loop through cards supported by this driver */
 		for (i = 0; i < n_boardtypes; ++i) {
 			if (boardtypes[i].vendor_id != pcidev->vendor)
@@ -917,13 +931,13 @@ static int pci_dio_attach(struct comedi_
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
 			ret = CheckAndAllocCard(dev, it, pcidev);
-			if (ret != 1) continue;
+			if (ret != 1)
+				continue;
 			dev->board_ptr = boardtypes + i;
 			break;
 		}
@@ -932,20 +946,19 @@ static int pci_dio_attach(struct comedi_
 	}
 
 	if (!dev->board_ptr) {
-		printk
-			(", Error: Requested type of the card was not found!\n");
+		printk(", Error: Requested type of the card was not found!\n");
 		return -EIO;
 	}
 
 	if (comedi_pci_enable(pcidev, driver_pci_dio.driver_name)) {
 		printk
-			(", Error: Can't enable PCI device and request regions!\n");
+		    (", Error: Can't enable PCI device and request regions!\n");
 		return -EIO;
 	}
 	iobase = pci_resource_start(pcidev, this_board->main_pci_region);
 	printk(", b:s:f=%d:%d:%d, io=0x%4lx",
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn),
-		PCI_FUNC(pcidev->devfn), iobase);
+	       pcidev->bus->number, PCI_SLOT(pcidev->devfn),
+	       PCI_FUNC(pcidev->devfn), iobase);
 
 	dev->iobase = iobase;
 	dev->board_name = this_board->name;
@@ -994,8 +1007,9 @@ static int pci_dio_attach(struct comedi_
 		for (j = 0; j < this_board->sdio[i].regs; j++) {
 			s = dev->subdevices + subdev;
 			subdev_8255_init(dev, s, NULL,
-				dev->iobase + this_board->sdio[i].addr +
-				SIZE_8255 * j);
+					 dev->iobase +
+					 this_board->sdio[i].addr +
+					 SIZE_8255 * j);
 			subdev++;
 		}
 
--- a/drivers/staging/comedi/drivers/aio_aio12_8.c
+++ b/drivers/staging/comedi/drivers/aio_aio12_8.c
@@ -77,7 +77,7 @@ struct aio12_8_boardtype {
 
 static const struct aio12_8_boardtype board_types[] = {
 	{
-	.name = "aio_aio12_8"},
+	 .name = "aio_aio12_8"},
 };
 
 #define	thisboard	((const struct aio12_8_boardtype  *) dev->board_ptr)
@@ -88,13 +88,14 @@ struct aio12_8_private {
 
 #define devpriv	((struct aio12_8_private *) dev->private)
 
-static int aio_aio12_8_ai_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int aio_aio12_8_ai_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	unsigned char control =
-		ADC_MODE_NORMAL |
-		(CR_RANGE(insn->chanspec) << 3) | CR_CHAN(insn->chanspec);
+	    ADC_MODE_NORMAL |
+	    (CR_RANGE(insn->chanspec) << 3) | CR_CHAN(insn->chanspec);
 
 	/* read status to clear EOC latch */
 	inb(dev->iobase + AIO12_8_STATUS);
@@ -107,7 +108,7 @@ static int aio_aio12_8_ai_read(struct co
 
 		/*  Wait for conversion to complete */
 		while (timeout &&
-			!(inb(dev->iobase + AIO12_8_STATUS) & STATUS_ADC_EOC)) {
+		       !(inb(dev->iobase + AIO12_8_STATUS) & STATUS_ADC_EOC)) {
 			timeout--;
 			printk("timeout %d\n", timeout);
 			udelay(1);
@@ -122,8 +123,9 @@ static int aio_aio12_8_ai_read(struct co
 	return n;
 }
 
-static int aio_aio12_8_ao_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int aio_aio12_8_ao_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int val = devpriv->ao_readback[CR_CHAN(insn->chanspec)];
@@ -133,8 +135,9 @@ static int aio_aio12_8_ao_read(struct co
 	return insn->n;
 }
 
-static int aio_aio12_8_ao_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int aio_aio12_8_ao_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -154,14 +157,15 @@ static int aio_aio12_8_ao_write(struct c
 static const struct comedi_lrange range_aio_aio12_8 = {
 	4,
 	{
-			UNI_RANGE(5),
-			BIP_RANGE(5),
-			UNI_RANGE(10),
-			BIP_RANGE(10),
-		}
+	 UNI_RANGE(5),
+	 BIP_RANGE(5),
+	 UNI_RANGE(10),
+	 BIP_RANGE(10),
+	 }
 };
 
-static int aio_aio12_8_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int aio_aio12_8_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it)
 {
 	int iobase;
 	struct comedi_subdevice *s;
--- a/drivers/staging/comedi/drivers/aio_iiro_16.c
+++ b/drivers/staging/comedi/drivers/aio_iiro_16.c
@@ -52,9 +52,9 @@ struct aio_iiro_16_board {
 
 static const struct aio_iiro_16_board aio_iiro_16_boards[] = {
 	{
-	.name = "aio_iiro_16",
-	.di = 16,
-	.do_ = 16},
+	 .name = "aio_iiro_16",
+	 .di = 16,
+	 .do_ = 16},
 };
 
 #define	thisboard	((const struct aio_iiro_16_board *) dev->board_ptr)
@@ -67,7 +67,8 @@ struct aio_iiro_16_private {
 
 #define	devpriv	((struct aio_iiro_16_private *) dev->private)
 
-static int aio_iiro_16_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int aio_iiro_16_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it);
 
 static int aio_iiro_16_detach(struct comedi_device *dev);
 
@@ -82,12 +83,17 @@ static struct comedi_driver driver_aio_i
 };
 
 static int aio_iiro_16_dio_insn_bits_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+					  struct comedi_subdevice *s,
+					  struct comedi_insn *insn,
+					  unsigned int *data);
 
 static int aio_iiro_16_dio_insn_bits_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+					   struct comedi_subdevice *s,
+					   struct comedi_insn *insn,
+					   unsigned int *data);
 
-static int aio_iiro_16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int aio_iiro_16_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it)
 {
 	int iobase;
 	struct comedi_subdevice *s;
@@ -143,7 +149,9 @@ static int aio_iiro_16_detach(struct com
 }
 
 static int aio_iiro_16_dio_insn_bits_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+					   struct comedi_subdevice *s,
+					   struct comedi_insn *insn,
+					   unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -153,7 +161,7 @@ static int aio_iiro_16_dio_insn_bits_wri
 		s->state |= data[0] & data[1];
 		outb(s->state & 0xff, dev->iobase + AIO_IIRO_16_RELAY_0_7);
 		outb((s->state >> 8) & 0xff,
-			dev->iobase + AIO_IIRO_16_RELAY_8_15);
+		     dev->iobase + AIO_IIRO_16_RELAY_8_15);
 	}
 
 	data[1] = s->state;
@@ -162,7 +170,9 @@ static int aio_iiro_16_dio_insn_bits_wri
 }
 
 static int aio_iiro_16_dio_insn_bits_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+					  struct comedi_subdevice *s,
+					  struct comedi_insn *insn,
+					  unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -290,60 +290,60 @@ struct dio200_board {
 
 static const struct dio200_board dio200_boards[] = {
 	{
-	.name = "pc212e",
-	.bustype = isa_bustype,
-	.model = pc212e_model,
-	.layout = pc212_layout,
-		},
+	 .name = "pc212e",
+	 .bustype = isa_bustype,
+	 .model = pc212e_model,
+	 .layout = pc212_layout,
+	 },
 	{
-	.name = "pc214e",
-	.bustype = isa_bustype,
-	.model = pc214e_model,
-	.layout = pc214_layout,
-		},
+	 .name = "pc214e",
+	 .bustype = isa_bustype,
+	 .model = pc214e_model,
+	 .layout = pc214_layout,
+	 },
 	{
-	.name = "pc215e",
-	.bustype = isa_bustype,
-	.model = pc215e_model,
-	.layout = pc215_layout,
-		},
+	 .name = "pc215e",
+	 .bustype = isa_bustype,
+	 .model = pc215e_model,
+	 .layout = pc215_layout,
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "pci215",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI215,
-	.bustype = pci_bustype,
-	.model = pci215_model,
-	.layout = pc215_layout,
-		},
+	 .name = "pci215",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI215,
+	 .bustype = pci_bustype,
+	 .model = pci215_model,
+	 .layout = pc215_layout,
+	 },
 #endif
 	{
-	.name = "pc218e",
-	.bustype = isa_bustype,
-	.model = pc218e_model,
-	.layout = pc218_layout,
-		},
+	 .name = "pc218e",
+	 .bustype = isa_bustype,
+	 .model = pc218e_model,
+	 .layout = pc218_layout,
+	 },
 	{
-	.name = "pc272e",
-	.bustype = isa_bustype,
-	.model = pc272e_model,
-	.layout = pc272_layout,
-		},
+	 .name = "pc272e",
+	 .bustype = isa_bustype,
+	 .model = pc272e_model,
+	 .layout = pc272_layout,
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "pci272",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI272,
-	.bustype = pci_bustype,
-	.model = pci272_model,
-	.layout = pc272_layout,
-		},
+	 .name = "pci272",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI272,
+	 .bustype = pci_bustype,
+	 .model = pci272_model,
+	 .layout = pc272_layout,
+	 },
 #endif
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = DIO200_DRIVER_NAME,
-	.devid = PCI_DEVICE_ID_INVALID,
-	.bustype = pci_bustype,
-	.model = anypci_model,	/* wildcard */
-		},
+	 .name = DIO200_DRIVER_NAME,
+	 .devid = PCI_DEVICE_ID_INVALID,
+	 .bustype = pci_bustype,
+	 .model = anypci_model,	/* wildcard */
+	 },
 #endif
 };
 
@@ -367,51 +367,51 @@ struct dio200_layout_struct {
 
 static const struct dio200_layout_struct dio200_layouts[] = {
 	[pc212_layout] = {
-	.n_subdevs = 6,
-	.sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
-					sd_8254,
-				sd_intr},
-	.sdinfo = {0x00, 0x08, 0x0C, 0x10, 0x14,
-				0x3F},
-	.has_int_sce = 1,
-	.has_clk_gat_sce = 1,
-		},
+			  .n_subdevs = 6,
+			  .sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
+				     sd_8254,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x08, 0x0C, 0x10, 0x14,
+				     0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
 	[pc214_layout] = {
-	.n_subdevs = 4,
-	.sdtype = {sd_8255, sd_8255, sd_8254,
-				sd_intr},
-	.sdinfo = {0x00, 0x08, 0x10, 0x01},
-	.has_int_sce = 0,
-	.has_clk_gat_sce = 0,
-		},
+			  .n_subdevs = 4,
+			  .sdtype = {sd_8255, sd_8255, sd_8254,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x08, 0x10, 0x01},
+			  .has_int_sce = 0,
+			  .has_clk_gat_sce = 0,
+			  },
 	[pc215_layout] = {
-	.n_subdevs = 5,
-	.sdtype = {sd_8255, sd_8255, sd_8254,
-					sd_8254,
-				sd_intr},
-	.sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
-	.has_int_sce = 1,
-	.has_clk_gat_sce = 1,
-		},
+			  .n_subdevs = 5,
+			  .sdtype = {sd_8255, sd_8255, sd_8254,
+				     sd_8254,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
 	[pc218_layout] = {
-	.n_subdevs = 7,
-	.sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
-					sd_8254,
-				sd_intr},
-	.sdinfo = {0x00, 0x04, 0x08, 0x0C, 0x10,
-					0x14,
-				0x3F},
-	.has_int_sce = 1,
-	.has_clk_gat_sce = 1,
-		},
+			  .n_subdevs = 7,
+			  .sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
+				     sd_8254,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x04, 0x08, 0x0C, 0x10,
+				     0x14,
+				     0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
 	[pc272_layout] = {
-	.n_subdevs = 4,
-	.sdtype = {sd_8255, sd_8255, sd_8255,
-				sd_intr},
-	.sdinfo = {0x00, 0x08, 0x10, 0x3F},
-	.has_int_sce = 1,
-	.has_clk_gat_sce = 0,
-		},
+			  .n_subdevs = 4,
+			  .sdtype = {sd_8255, sd_8255, sd_8255,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x08, 0x10, 0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 0,
+			  },
 };
 
 /*
@@ -420,11 +420,12 @@ static const struct dio200_layout_struct
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, dio200_pci_table);
@@ -475,7 +476,8 @@ struct dio200_subdev_intr {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dio200_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dio200_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_dio200 = {
 	.driver_name = DIO200_DRIVER_NAME,
@@ -500,7 +502,7 @@ COMEDI_INITCLEANUP(driver_amplc_dio200);
 #ifdef CONFIG_COMEDI_PCI
 static int
 dio200_find_pci(struct comedi_device *dev, int bus, int slot,
-	struct pci_dev **pci_dev_p)
+		struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
 
@@ -508,13 +510,13 @@ dio200_find_pci(struct comedi_device *de
 
 	/* Look for matching PCI device. */
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
-			PCI_ANY_ID, pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
+				      PCI_ANY_ID, pci_dev)) {
 		/* If bus/slot specified, check them. */
 		if (bus || slot) {
 			if (bus != pci_dev->bus->number
-				|| slot != PCI_SLOT(pci_dev->devfn))
+			    || slot != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
 		if (thisboard->model == anypci_model) {
@@ -545,11 +547,11 @@ dio200_find_pci(struct comedi_device *de
 	/* No match found. */
 	if (bus || slot) {
 		printk(KERN_ERR
-			"comedi%d: error! no %s found at pci %02x:%02x!\n",
-			dev->minor, thisboard->name, bus, slot);
+		       "comedi%d: error! no %s found at pci %02x:%02x!\n",
+		       dev->minor, thisboard->name, bus, slot);
 	} else {
 		printk(KERN_ERR "comedi%d: error! no %s found!\n",
-			dev->minor, thisboard->name);
+		       dev->minor, thisboard->name);
 	}
 	return -EIO;
 }
@@ -564,7 +566,7 @@ dio200_request_region(unsigned minor, un
 {
 	if (!from || !request_region(from, extent, DIO200_DRIVER_NAME)) {
 		printk(KERN_ERR "comedi%d: I/O port conflict (%#lx,%lu)!\n",
-			minor, from, extent);
+		       minor, from, extent);
 		return -EIO;
 	}
 	return 0;
@@ -574,8 +576,9 @@ dio200_request_region(unsigned minor, un
  * 'insn_bits' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+dio200_subdev_intr_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -593,7 +596,8 @@ dio200_subdev_intr_insn_bits(struct come
 /*
  * Called to stop acquisition for an 'INTERRUPT' subdevice.
  */
-static void dio200_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static void dio200_stop_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -607,7 +611,8 @@ static void dio200_stop_intr(struct come
 /*
  * Called to start acquisition for an 'INTERRUPT' subdevice.
  */
-static int dio200_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dio200_start_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	unsigned int n;
 	unsigned isn_bits;
@@ -644,7 +649,7 @@ static int dio200_start_intr(struct come
  */
 static int
 dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			  unsigned int trignum)
 {
 	struct dio200_subdev_intr *subpriv;
 	unsigned long flags;
@@ -673,7 +678,8 @@ dio200_inttrig_start_intr(struct comedi_
  * This is called from the interrupt service routine to handle a read
  * scan on an 'INTERRUPT' subdevice.
  */
-static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dio200_handle_read_intr(struct comedi_device *dev,
+				   struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned triggered;
@@ -699,7 +705,7 @@ static int dio200_handle_read_intr(struc
 		 */
 		cur_enabled = subpriv->enabled_isns;
 		while ((intstat = (inb(subpriv->iobase) & subpriv->valid_isns
-					& ~triggered)) != 0) {
+				   & ~triggered)) != 0) {
 			triggered |= intstat;
 			cur_enabled &= ~triggered;
 			outb(cur_enabled, subpriv->iobase);
@@ -748,12 +754,12 @@ static int dio200_handle_read_intr(struc
 				/* Write the scan to the buffer. */
 				if (comedi_buf_put(s->async, val)) {
 					s->async->events |= (COMEDI_CB_BLOCK |
-						COMEDI_CB_EOS);
+							     COMEDI_CB_EOS);
 				} else {
 					/* Error!  Stop acquisition.  */
 					dio200_stop_intr(dev, s);
 					s->async->events |= COMEDI_CB_ERROR
-						| COMEDI_CB_OVERFLOW;
+					    | COMEDI_CB_OVERFLOW;
 					comedi_error(dev, "buffer overflow");
 				}
 
@@ -764,9 +770,9 @@ static int dio200_handle_read_intr(struc
 						subpriv->stopcount--;
 						if (subpriv->stopcount == 0) {
 							s->async->events |=
-								COMEDI_CB_EOA;
+							    COMEDI_CB_EOA;
 							dio200_stop_intr(dev,
-								s);
+									 s);
 						}
 					}
 				}
@@ -785,7 +791,8 @@ static int dio200_handle_read_intr(struc
 /*
  * 'cancel' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dio200_subdev_intr_cancel(struct comedi_device *dev,
+				     struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
@@ -803,8 +810,8 @@ static int dio200_subdev_intr_cancel(str
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+dio200_subdev_intr_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -909,7 +916,8 @@ dio200_subdev_intr_cmdtest(struct comedi
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dio200_subdev_intr_cmd(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct dio200_subdev_intr *subpriv = s->private;
@@ -956,14 +964,15 @@ static int dio200_subdev_intr_cmd(struct
  */
 static int
 dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long iobase, unsigned valid_isns, int has_int_sce)
+			unsigned long iobase, unsigned valid_isns,
+			int has_int_sce)
 {
 	struct dio200_subdev_intr *subpriv;
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
 	if (!subpriv) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return -ENOMEM;
 	}
 	subpriv->iobase = iobase;
@@ -1000,7 +1009,8 @@ dio200_subdev_intr_init(struct comedi_de
  * This function cleans up an 'INTERRUPT' subdevice.
  */
 static void
-dio200_subdev_intr_cleanup(struct comedi_device *dev, struct comedi_subdevice *s)
+dio200_subdev_intr_cleanup(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -1023,7 +1033,8 @@ static irqreturn_t dio200_interrupt(int 
 
 	if (devpriv->intr_sd >= 0) {
 		handled = dio200_handle_read_intr(dev,
-			dev->subdevices + devpriv->intr_sd);
+						  dev->subdevices +
+						  devpriv->intr_sd);
 	} else {
 		handled = 0;
 	}
@@ -1036,7 +1047,7 @@ static irqreturn_t dio200_interrupt(int 
  */
 static int
 dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1051,7 +1062,7 @@ dio200_subdev_8254_read(struct comedi_de
  */
 static int
 dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1065,8 +1076,8 @@ dio200_subdev_8254_write(struct comedi_d
  * Set gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_gate_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
-	unsigned int gate_src)
+dio200_set_gate_src(struct dio200_subdev_8254 *subpriv,
+		    unsigned int counter_number, unsigned int gate_src)
 {
 	unsigned char byte;
 
@@ -1088,7 +1099,8 @@ dio200_set_gate_src(struct dio200_subdev
  * Get gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_gate_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number)
+dio200_get_gate_src(struct dio200_subdev_8254 *subpriv,
+		    unsigned int counter_number)
 {
 	if (!subpriv->has_clk_gat_sce)
 		return -1;
@@ -1102,8 +1114,8 @@ dio200_get_gate_src(struct dio200_subdev
  * Set clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_clock_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
-	unsigned int clock_src)
+dio200_set_clock_src(struct dio200_subdev_8254 *subpriv,
+		     unsigned int counter_number, unsigned int clock_src)
 {
 	unsigned char byte;
 
@@ -1125,8 +1137,8 @@ dio200_set_clock_src(struct dio200_subde
  * Get clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_clock_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
-	unsigned int *period_ns)
+dio200_get_clock_src(struct dio200_subdev_8254 *subpriv,
+		     unsigned int counter_number, unsigned int *period_ns)
 {
 	unsigned clock_src;
 
@@ -1145,7 +1157,7 @@ dio200_get_clock_src(struct dio200_subde
  */
 static int
 dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int ret;
@@ -1197,7 +1209,8 @@ dio200_subdev_8254_config(struct comedi_
  */
 static int
 dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long iobase, unsigned offset, int has_clk_gat_sce)
+			unsigned long iobase, unsigned offset,
+			int has_clk_gat_sce)
 {
 	struct dio200_subdev_8254 *subpriv;
 	unsigned int chan;
@@ -1205,7 +1218,7 @@ dio200_subdev_8254_init(struct comedi_de
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
 	if (!subpriv) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return -ENOMEM;
 	}
 
@@ -1224,16 +1237,16 @@ dio200_subdev_8254_init(struct comedi_de
 		/* Derive CLK_SCE and GAT_SCE register offsets from
 		 * 8254 offset. */
 		subpriv->clk_sce_iobase =
-			DIO200_XCLK_SCE + (offset >> 3) + iobase;
+		    DIO200_XCLK_SCE + (offset >> 3) + iobase;
 		subpriv->gat_sce_iobase =
-			DIO200_XGAT_SCE + (offset >> 3) + iobase;
+		    DIO200_XGAT_SCE + (offset >> 3) + iobase;
 		subpriv->which = (offset >> 2) & 1;
 	}
 
 	/* Initialize channels. */
 	for (chan = 0; chan < 3; chan++) {
 		i8254_set_mode(subpriv->iobase, 0, chan,
-			I8254_MODE0 | I8254_BINARY);
+			       I8254_MODE0 | I8254_BINARY);
 		if (subpriv->has_clk_gat_sce) {
 			/* Gate source 0 is VCC (logic 1). */
 			dio200_set_gate_src(subpriv, chan, 0);
@@ -1249,7 +1262,8 @@ dio200_subdev_8254_init(struct comedi_de
  * This function cleans up an '8254' counter subdevice.
  */
 static void
-dio200_subdev_8254_cleanup(struct comedi_device *dev, struct comedi_subdevice *s)
+dio200_subdev_8254_cleanup(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -1280,12 +1294,12 @@ static int dio200_attach(struct comedi_d
 	int ret;
 
 	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
-		DIO200_DRIVER_NAME);
+	       DIO200_DRIVER_NAME);
 
 	ret = alloc_private(dev, sizeof(struct dio200_private));
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -1310,8 +1324,8 @@ static int dio200_attach(struct comedi_d
 #endif
 	default:
 		printk(KERN_ERR
-			"comedi%d: %s: BUG! cannot determine board type!\n",
-			dev->minor, DIO200_DRIVER_NAME);
+		       "comedi%d: %s: BUG! cannot determine board type!\n",
+		       dev->minor, DIO200_DRIVER_NAME);
 		return -EINVAL;
 		break;
 	}
@@ -1324,8 +1338,8 @@ static int dio200_attach(struct comedi_d
 		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 		if (ret < 0) {
 			printk(KERN_ERR
-				"comedi%d: error! cannot enable PCI device and request regions!\n",
-				dev->minor);
+			       "comedi%d: error! cannot enable PCI device and request regions!\n",
+			       dev->minor);
 			return ret;
 		}
 		iobase = pci_resource_start(pci_dev, 2);
@@ -1345,7 +1359,7 @@ static int dio200_attach(struct comedi_d
 	ret = alloc_subdevices(dev, layout->n_subdevs);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -1355,7 +1369,8 @@ static int dio200_attach(struct comedi_d
 		case sd_8254:
 			/* counter subdevice (8254) */
 			ret = dio200_subdev_8254_init(dev, s, iobase,
-				layout->sdinfo[n], layout->has_clk_gat_sce);
+						      layout->sdinfo[n],
+						      layout->has_clk_gat_sce);
 			if (ret < 0) {
 				return ret;
 			}
@@ -1363,7 +1378,7 @@ static int dio200_attach(struct comedi_d
 		case sd_8255:
 			/* digital i/o subdevice (8255) */
 			ret = subdev_8255_init(dev, s, 0,
-				iobase + layout->sdinfo[n]);
+					       iobase + layout->sdinfo[n]);
 			if (ret < 0) {
 				return ret;
 			}
@@ -1372,8 +1387,11 @@ static int dio200_attach(struct comedi_d
 			/* 'INTERRUPT' subdevice */
 			if (irq) {
 				ret = dio200_subdev_intr_init(dev, s,
-					iobase + DIO200_INT_SCE,
-					layout->sdinfo[n], layout->has_int_sce);
+							      iobase +
+							      DIO200_INT_SCE,
+							      layout->sdinfo[n],
+							      layout->
+							      has_int_sce);
 				if (ret < 0) {
 					return ret;
 				}
@@ -1403,8 +1421,8 @@ static int dio200_attach(struct comedi_d
 			dev->irq = irq;
 		} else {
 			printk(KERN_WARNING
-				"comedi%d: warning! irq %u unavailable!\n",
-				dev->minor, irq);
+			       "comedi%d: warning! irq %u unavailable!\n",
+			       dev->minor, irq);
 		}
 	}
 
@@ -1441,7 +1459,7 @@ static int dio200_detach(struct comedi_d
 	unsigned n;
 
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor,
-		DIO200_DRIVER_NAME);
+	       DIO200_DRIVER_NAME);
 
 	if (dev->irq) {
 		free_irq(dev->irq, dev);
@@ -1482,7 +1500,7 @@ static int dio200_detach(struct comedi_d
 	}
 	if (dev->board_name) {
 		printk(KERN_INFO "comedi%d: %s removed\n",
-			dev->minor, dev->board_name);
+		       dev->minor, dev->board_name);
 	}
 
 	return 0;
--- a/drivers/staging/comedi/drivers/amplc_pc236.c
+++ b/drivers/staging/comedi/drivers/amplc_pc236.c
@@ -107,36 +107,37 @@ struct pc236_board {
 };
 static const struct pc236_board pc236_boards[] = {
 	{
-	.name = "pc36at",
-	.fancy_name = "PC36AT",
-	.bustype = isa_bustype,
-	.model = pc36at_model,
-		},
+	 .name = "pc36at",
+	 .fancy_name = "PC36AT",
+	 .bustype = isa_bustype,
+	 .model = pc36at_model,
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "pci236",
-	.fancy_name = "PCI236",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI236,
-	.bustype = pci_bustype,
-	.model = pci236_model,
-		},
+	 .name = "pci236",
+	 .fancy_name = "PCI236",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI236,
+	 .bustype = pci_bustype,
+	 .model = pci236_model,
+	 },
 #endif
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = PC236_DRIVER_NAME,
-	.fancy_name = PC236_DRIVER_NAME,
-	.devid = PCI_DEVICE_ID_INVALID,
-	.bustype = pci_bustype,
-	.model = anypci_model,	/* wildcard */
-		},
+	 .name = PC236_DRIVER_NAME,
+	 .fancy_name = PC236_DRIVER_NAME,
+	 .devid = PCI_DEVICE_ID_INVALID,
+	 .bustype = pci_bustype,
+	 .model = anypci_model,	/* wildcard */
+	 },
 #endif
 };
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(pc236_pci_table) = {
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI236, PCI_ANY_ID,
-		PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI236,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pc236_pci_table);
@@ -186,16 +187,20 @@ COMEDI_INITCLEANUP(driver_amplc_pc236);
 #endif
 
 static int pc236_request_region(unsigned minor, unsigned long from,
-	unsigned long extent);
+				unsigned long extent);
 static void pc236_intr_disable(struct comedi_device *dev);
 static void pc236_intr_enable(struct comedi_device *dev);
 static int pc236_intr_check(struct comedi_device *dev);
-static int pc236_intr_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pc236_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int pc236_intr_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pc236_intr_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pc236_intr_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int pc236_intr_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd);
+static int pc236_intr_cmd(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
+static int pc236_intr_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 static irqreturn_t pc236_interrupt(int irq, void *d);
 
 /*
@@ -205,7 +210,7 @@ static irqreturn_t pc236_interrupt(int i
 #ifdef CONFIG_COMEDI_PCI
 static int
 pc236_find_pci(struct comedi_device *dev, int bus, int slot,
-	struct pci_dev **pci_dev_p)
+	       struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
 
@@ -213,13 +218,13 @@ pc236_find_pci(struct comedi_device *dev
 
 	/* Look for matching PCI device. */
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
-			PCI_ANY_ID, pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
+				      PCI_ANY_ID, pci_dev)) {
 		/* If bus/slot specified, check them. */
 		if (bus || slot) {
 			if (bus != pci_dev->bus->number
-				|| slot != PCI_SLOT(pci_dev->devfn))
+			    || slot != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
 		if (thisboard->model == anypci_model) {
@@ -250,11 +255,11 @@ pc236_find_pci(struct comedi_device *dev
 	/* No match found. */
 	if (bus || slot) {
 		printk(KERN_ERR
-			"comedi%d: error! no %s found at pci %02x:%02x!\n",
-			dev->minor, thisboard->name, bus, slot);
+		       "comedi%d: error! no %s found at pci %02x:%02x!\n",
+		       dev->minor, thisboard->name, bus, slot);
 	} else {
 		printk(KERN_ERR "comedi%d: error! no %s found!\n",
-			dev->minor, thisboard->name);
+		       dev->minor, thisboard->name);
 	}
 	return -EIO;
 }
@@ -279,7 +284,7 @@ static int pc236_attach(struct comedi_de
 	int ret;
 
 	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
-		PC236_DRIVER_NAME);
+	       PC236_DRIVER_NAME);
 /*
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
@@ -287,7 +292,7 @@ static int pc236_attach(struct comedi_de
 	ret = alloc_private(dev, sizeof(struct pc236_private));
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 	/* Process options. */
@@ -311,8 +316,8 @@ static int pc236_attach(struct comedi_de
 #endif /* CONFIG_COMEDI_PCI */
 	default:
 		printk(KERN_ERR
-			"comedi%d: %s: BUG! cannot determine board type!\n",
-			dev->minor, PC236_DRIVER_NAME);
+		       "comedi%d: %s: BUG! cannot determine board type!\n",
+		       dev->minor, PC236_DRIVER_NAME);
 		return -EINVAL;
 		break;
 	}
@@ -329,8 +334,8 @@ static int pc236_attach(struct comedi_de
 		ret = comedi_pci_enable(pci_dev, PC236_DRIVER_NAME);
 		if (ret < 0) {
 			printk(KERN_ERR
-				"comedi%d: error! cannot enable PCI device and request regions!\n",
-				dev->minor);
+			       "comedi%d: error! cannot enable PCI device and request regions!\n",
+			       dev->minor);
 			return ret;
 		}
 		devpriv->lcr_iobase = pci_resource_start(pci_dev, 1);
@@ -353,7 +358,7 @@ static int pc236_attach(struct comedi_de
 	ret = alloc_subdevices(dev, 2);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -362,7 +367,7 @@ static int pc236_attach(struct comedi_de
 	ret = subdev_8255_init(dev, s, NULL, iobase);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 	s = dev->subdevices + 1;
@@ -416,7 +421,7 @@ static int pc236_attach(struct comedi_de
 static int pc236_detach(struct comedi_device *dev)
 {
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor,
-		PC236_DRIVER_NAME);
+	       PC236_DRIVER_NAME);
 	if (devpriv) {
 		pc236_intr_disable(dev);
 	}
@@ -442,7 +447,7 @@ static int pc236_detach(struct comedi_de
 	}
 	if (dev->board_name) {
 		printk(KERN_INFO "comedi%d: %s removed\n",
-			dev->minor, dev->board_name);
+		       dev->minor, dev->board_name);
 	}
 	return 0;
 }
@@ -452,11 +457,11 @@ static int pc236_detach(struct comedi_de
  * if there is a conflict.
  */
 static int pc236_request_region(unsigned minor, unsigned long from,
-	unsigned long extent)
+				unsigned long extent)
 {
 	if (!from || !request_region(from, extent, PC236_DRIVER_NAME)) {
 		printk(KERN_ERR "comedi%d: I/O port conflict (%#lx,%lu)!\n",
-			minor, from, extent);
+		       minor, from, extent);
 		return -EIO;
 	}
 	return 0;
@@ -516,13 +521,13 @@ static int pc236_intr_check(struct comed
 #ifdef CONFIG_COMEDI_PCI
 		if (devpriv->lcr_iobase) {
 			if ((inl(devpriv->lcr_iobase + PLX9052_INTCSR)
-					& PLX9052_INTCSR_LI1STAT_MASK)
-				== PLX9052_INTCSR_LI1STAT_INACTIVE) {
+			     & PLX9052_INTCSR_LI1STAT_MASK)
+			    == PLX9052_INTCSR_LI1STAT_INACTIVE) {
 				retval = 0;
 			} else {
 				/* Clear interrupt and keep it enabled. */
 				outl(PCI236_INTR_ENABLE,
-					devpriv->lcr_iobase + PLX9052_INTCSR);
+				     devpriv->lcr_iobase + PLX9052_INTCSR);
 			}
 		}
 #endif
@@ -536,8 +541,9 @@ static int pc236_intr_check(struct comed
  * Input from subdevice 1.
  * Copied from the comedi_parport driver.
  */
-static int pc236_intr_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pc236_intr_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	data[1] = 0;
 	return 2;
@@ -547,8 +553,9 @@ static int pc236_intr_insn(struct comedi
  * Subdevice 1 command test.
  * Copied from the comedi_parport driver.
  */
-static int pc236_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pc236_intr_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -635,7 +642,8 @@ static int pc236_intr_cmd(struct comedi_
 /*
  * Subdevice 1 cancel command.
  */
-static int pc236_intr_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pc236_intr_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	pc236_intr_disable(dev);
 
--- a/drivers/staging/comedi/drivers/amplc_pc263.c
+++ b/drivers/staging/comedi/drivers/amplc_pc263.c
@@ -74,36 +74,37 @@ struct pc263_board {
 };
 static const struct pc263_board pc263_boards[] = {
 	{
-	.name = "pc263",
-	.fancy_name = "PC263",
-	.bustype = isa_bustype,
-	.model = pc263_model,
-		},
+	 .name = "pc263",
+	 .fancy_name = "PC263",
+	 .bustype = isa_bustype,
+	 .model = pc263_model,
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "pci263",
-	.fancy_name = "PCI263",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI263,
-	.bustype = pci_bustype,
-	.model = pci263_model,
-		},
+	 .name = "pci263",
+	 .fancy_name = "PCI263",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI263,
+	 .bustype = pci_bustype,
+	 .model = pci263_model,
+	 },
 #endif
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = PC263_DRIVER_NAME,
-	.fancy_name = PC263_DRIVER_NAME,
-	.devid = PCI_DEVICE_ID_INVALID,
-	.bustype = pci_bustype,
-	.model = anypci_model,	/* wildcard */
-		},
+	 .name = PC263_DRIVER_NAME,
+	 .fancy_name = PC263_DRIVER_NAME,
+	 .devid = PCI_DEVICE_ID_INVALID,
+	 .bustype = pci_bustype,
+	 .model = anypci_model,	/* wildcard */
+	 },
 #endif
 };
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(pc263_pci_table) = {
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI263, PCI_ANY_ID,
-		PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI263,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pc263_pci_table);
@@ -145,11 +146,13 @@ static struct comedi_driver driver_amplc
 };
 
 static int pc263_request_region(unsigned minor, unsigned long from,
-	unsigned long extent);
-static int pc263_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pc263_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+				unsigned long extent);
+static int pc263_dio_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int pc263_dio_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
 
 /*
  * This function looks for a PCI device matching the requested board name,
@@ -158,7 +161,7 @@ static int pc263_dio_insn_config(struct 
 #ifdef CONFIG_COMEDI_PCI
 static int
 pc263_find_pci(struct comedi_device *dev, int bus, int slot,
-	struct pci_dev **pci_dev_p)
+	       struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
 
@@ -166,13 +169,13 @@ pc263_find_pci(struct comedi_device *dev
 
 	/* Look for matching PCI device. */
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
-			PCI_ANY_ID, pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
+				      PCI_ANY_ID, pci_dev)) {
 		/* If bus/slot specified, check them. */
 		if (bus || slot) {
 			if (bus != pci_dev->bus->number
-				|| slot != PCI_SLOT(pci_dev->devfn))
+			    || slot != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
 		if (thisboard->model == anypci_model) {
@@ -203,11 +206,11 @@ pc263_find_pci(struct comedi_device *dev
 	/* No match found. */
 	if (bus || slot) {
 		printk(KERN_ERR
-			"comedi%d: error! no %s found at pci %02x:%02x!\n",
-			dev->minor, thisboard->name, bus, slot);
+		       "comedi%d: error! no %s found at pci %02x:%02x!\n",
+		       dev->minor, thisboard->name, bus, slot);
 	} else {
 		printk(KERN_ERR "comedi%d: error! no %s found!\n",
-			dev->minor, thisboard->name);
+		       dev->minor, thisboard->name);
 	}
 	return -EIO;
 }
@@ -230,7 +233,7 @@ static int pc263_attach(struct comedi_de
 	int ret;
 
 	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
-		PC263_DRIVER_NAME);
+	       PC263_DRIVER_NAME);
 /*
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
@@ -239,7 +242,7 @@ static int pc263_attach(struct comedi_de
 	ret = alloc_private(dev, sizeof(struct pc263_private));
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 #endif
@@ -261,8 +264,8 @@ static int pc263_attach(struct comedi_de
 #endif /* CONFIG_COMEDI_PCI */
 	default:
 		printk(KERN_ERR
-			"comedi%d: %s: BUG! cannot determine board type!\n",
-			dev->minor, PC263_DRIVER_NAME);
+		       "comedi%d: %s: BUG! cannot determine board type!\n",
+		       dev->minor, PC263_DRIVER_NAME);
 		return -EINVAL;
 		break;
 	}
@@ -278,8 +281,8 @@ static int pc263_attach(struct comedi_de
 		ret = comedi_pci_enable(pci_dev, PC263_DRIVER_NAME);
 		if (ret < 0) {
 			printk(KERN_ERR
-				"comedi%d: error! cannot enable PCI device and request regions!\n",
-				dev->minor);
+			       "comedi%d: error! cannot enable PCI device and request regions!\n",
+			       dev->minor);
 			return ret;
 		}
 		iobase = pci_resource_start(pci_dev, 2);
@@ -300,7 +303,7 @@ static int pc263_attach(struct comedi_de
 	ret = alloc_subdevices(dev, 1);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -344,7 +347,7 @@ static int pc263_attach(struct comedi_de
 static int pc263_detach(struct comedi_device *dev)
 {
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor,
-		PC263_DRIVER_NAME);
+	       PC263_DRIVER_NAME);
 
 #ifdef CONFIG_COMEDI_PCI
 	if (devpriv)
@@ -366,7 +369,7 @@ static int pc263_detach(struct comedi_de
 	}
 	if (dev->board_name) {
 		printk(KERN_INFO "comedi%d: %s removed\n",
-			dev->minor, dev->board_name);
+		       dev->minor, dev->board_name);
 	}
 	return 0;
 }
@@ -376,11 +379,11 @@ static int pc263_detach(struct comedi_de
  * if there is a conflict.
  */
 static int pc263_request_region(unsigned minor, unsigned long from,
-	unsigned long extent)
+				unsigned long extent)
 {
 	if (!from || !request_region(from, extent, PC263_DRIVER_NAME)) {
 		printk(KERN_ERR "comedi%d: I/O port conflict (%#lx,%lu)!\n",
-			minor, from, extent);
+		       minor, from, extent);
 		return -EIO;
 	}
 	return 0;
@@ -391,8 +394,9 @@ static int pc263_request_region(unsigned
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pc263_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pc263_dio_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -416,8 +420,9 @@ static int pc263_dio_insn_bits(struct co
 	return 2;
 }
 
-static int pc263_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pc263_dio_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 1)
 		return -EINVAL;
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -283,15 +283,15 @@ Caveats:
 static const struct comedi_lrange range_pci224_internal = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25),
+	 }
 };
 
 static const unsigned short hwrange_pci224_internal[8] = {
@@ -309,9 +309,9 @@ static const unsigned short hwrange_pci2
 static const struct comedi_lrange range_pci224_external = {
 	2,
 	{
-			RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
-			RANGE_ext(0, 1),	/* unipolar [0,+Vref] */
-		}
+	 RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
+	 RANGE_ext(0, 1),	/* unipolar [0,+Vref] */
+	 }
 };
 
 static const unsigned short hwrange_pci224_external[2] = {
@@ -324,8 +324,8 @@ static const unsigned short hwrange_pci2
 static const struct comedi_lrange range_pci234_ext2 = {
 	1,
 	{
-			RANGE_ext(-2, 2),
-		}
+	 RANGE_ext(-2, 2),
+	 }
 };
 
 /* The hardware selectable Vref external range for PCI234
@@ -333,8 +333,8 @@ static const struct comedi_lrange range_
 static const struct comedi_lrange range_pci234_ext = {
 	1,
 	{
-			RANGE_ext(-1, 1),
-		}
+	 RANGE_ext(-1, 1),
+	 }
 };
 
 /* This serves for all the PCI234 ranges. */
@@ -358,24 +358,24 @@ struct pci224_board {
 
 static const struct pci224_board pci224_boards[] = {
 	{
-	.name = "pci224",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI224,
-	.model = pci224_model,
-	.ao_chans = 16,
-	.ao_bits = 12,
-		},
+	 .name = "pci224",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI224,
+	 .model = pci224_model,
+	 .ao_chans = 16,
+	 .ao_bits = 12,
+	 },
 	{
-	.name = "pci234",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI234,
-	.model = pci234_model,
-	.ao_chans = 4,
-	.ao_bits = 16,
-		},
+	 .name = "pci234",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI234,
+	 .model = pci234_model,
+	 .ao_chans = 4,
+	 .ao_bits = 16,
+	 },
 	{
-	.name = DRIVER_NAME,
-	.devid = PCI_DEVICE_ID_INVALID,
-	.model = any_model,	/* wildcard */
-		},
+	 .name = DRIVER_NAME,
+	 .devid = PCI_DEVICE_ID_INVALID,
+	 .model = any_model,	/* wildcard */
+	 },
 };
 
 /*
@@ -383,11 +383,12 @@ static const struct pci224_board pci224_
  */
 
 static DEFINE_PCI_DEVICE_TABLE(pci224_pci_table) = {
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci224_pci_table);
@@ -428,7 +429,8 @@ struct pci224_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci224_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pci224_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_pci224 = {
 	.driver_name = DRIVER_NAME,
@@ -446,7 +448,8 @@ COMEDI_PCI_INITCLEANUP(driver_amplc_pci2
  * Called from the 'insn_write' function to perform a single write.
  */
 static void
-pci224_ao_set_data(struct comedi_device *dev, int chan, int range, unsigned int data)
+pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
+		   unsigned int data)
 {
 	unsigned short mangled;
 
@@ -456,9 +459,10 @@ pci224_ao_set_data(struct comedi_device 
 	outw(1 << chan, dev->iobase + PCI224_DACCEN);
 	/* Set range and reset FIFO. */
 	devpriv->daccon = COMBINE(devpriv->daccon, devpriv->hwrange[range],
-		(PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK));
+				  (PCI224_DACCON_POLAR_MASK |
+				   PCI224_DACCON_VREF_MASK));
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
-		dev->iobase + PCI224_DACCON);
+	     dev->iobase + PCI224_DACCON);
 	/*
 	 * Mangle the data.  The hardware expects:
 	 * - bipolar: 16-bit 2's complement
@@ -466,7 +470,7 @@ pci224_ao_set_data(struct comedi_device 
 	 */
 	mangled = (unsigned short)data << (16 - thisboard->ao_bits);
 	if ((devpriv->daccon & PCI224_DACCON_POLAR_MASK) ==
-		PCI224_DACCON_POLAR_BI) {
+	    PCI224_DACCON_POLAR_BI) {
 		mangled ^= 0x8000;
 	}
 	/* Write mangled data to the FIFO. */
@@ -480,7 +484,7 @@ pci224_ao_set_data(struct comedi_device 
  */
 static int
 pci224_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		     struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan, range;
@@ -507,7 +511,7 @@ pci224_ao_insn_write(struct comedi_devic
  */
 static int
 pci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan;
@@ -526,7 +530,7 @@ pci224_ao_insn_read(struct comedi_device
  */
 static void
 pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
-	unsigned int *nanosec, int round_mode)
+			   unsigned int *nanosec, int round_mode)
 {
 	i8253_cascade_ns_to_timer(osc_base, d1, d2, nanosec, round_mode);
 }
@@ -534,7 +538,8 @@ pci224_cascade_ns_to_timer(int osc_base,
 /*
  * Kills a command running on the AO subdevice.
  */
-static void pci224_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci224_ao_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -565,16 +570,19 @@ static void pci224_ao_stop(struct comedi
 	/* Reconfigure DAC for insn_write usage. */
 	outw(0, dev->iobase + PCI224_DACCEN);	/* Disable channels. */
 	devpriv->daccon = COMBINE(devpriv->daccon,
-		PCI224_DACCON_TRIG_SW | PCI224_DACCON_FIFOINTR_EMPTY,
-		PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK);
+				  PCI224_DACCON_TRIG_SW |
+				  PCI224_DACCON_FIFOINTR_EMPTY,
+				  PCI224_DACCON_TRIG_MASK |
+				  PCI224_DACCON_FIFOINTR_MASK);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
-		dev->iobase + PCI224_DACCON);
+	     dev->iobase + PCI224_DACCON);
 }
 
 /*
  * Handles start of acquisition for the AO subdevice.
  */
-static void pci224_ao_start(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci224_ao_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -601,7 +609,8 @@ static void pci224_ao_start(struct comed
 /*
  * Handles interrupts from the DAC FIFO.
  */
-static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci224_ao_handle_fifo(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_scans;
@@ -630,8 +639,7 @@ static void pci224_ao_handle_fifo(struct
 	switch (dacstat & PCI224_DACCON_FIFOFL_MASK) {
 	case PCI224_DACCON_FIFOFL_EMPTY:
 		room = PCI224_FIFO_ROOM_EMPTY;
-		if (!devpriv->ao_stop_continuous
-			&& devpriv->ao_stop_count == 0) {
+		if (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {
 			/* FIFO empty at end of counted acquisition. */
 			pci224_ao_stop(dev, s);
 			s->async->events |= COMEDI_CB_EOA;
@@ -656,7 +664,7 @@ static void pci224_ao_handle_fifo(struct
 			pci224_ao_stop(dev, s);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 			printk(KERN_ERR "comedi%d: "
-				"AO buffer underrun\n", dev->minor);
+			       "AO buffer underrun\n", dev->minor);
 		}
 	}
 	/* Determine how many new scans can be put in the FIFO. */
@@ -670,11 +678,10 @@ static void pci224_ao_handle_fifo(struct
 	/* Process scans. */
 	for (n = 0; n < num_scans; n++) {
 		cfc_read_array_from_buffer(s, &devpriv->ao_scan_vals[0],
-			bytes_per_scan);
+					   bytes_per_scan);
 		for (i = 0; i < cmd->chanlist_len; i++) {
-			outw(devpriv->ao_scan_vals[devpriv->
-					ao_scan_order[i]],
-				dev->iobase + PCI224_DACDATA);
+			outw(devpriv->ao_scan_vals[devpriv->ao_scan_order[i]],
+			     dev->iobase + PCI224_DACDATA);
 		}
 	}
 	if (!devpriv->ao_stop_continuous) {
@@ -685,14 +692,13 @@ static void pci224_ao_handle_fifo(struct
 			 * until FIFO is empty.
 			 */
 			devpriv->daccon = COMBINE(devpriv->daccon,
-				PCI224_DACCON_FIFOINTR_EMPTY,
-				PCI224_DACCON_FIFOINTR_MASK);
-			outw(devpriv->daccon,
-				dev->iobase + PCI224_DACCON);
+						  PCI224_DACCON_FIFOINTR_EMPTY,
+						  PCI224_DACCON_FIFOINTR_MASK);
+			outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 		}
 	}
 	if ((devpriv->daccon & PCI224_DACCON_TRIG_MASK) ==
-		PCI224_DACCON_TRIG_NONE) {
+	    PCI224_DACCON_TRIG_NONE) {
 		unsigned short trig;
 
 		/*
@@ -718,7 +724,7 @@ static void pci224_ao_handle_fifo(struct
 			}
 		}
 		devpriv->daccon = COMBINE(devpriv->daccon, trig,
-			PCI224_DACCON_TRIG_MASK);
+					  PCI224_DACCON_TRIG_MASK);
 		outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 	}
 	if (s->async->events) {
@@ -731,7 +737,7 @@ static void pci224_ao_handle_fifo(struct
  */
 static int
 pci224_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			unsigned int trignum)
 {
 	if (trignum != 0)
 		return -EINVAL;
@@ -750,7 +756,8 @@ pci224_ao_inttrig_start(struct comedi_de
  * 'do_cmdtest' function for AO subdevice.
  */
 static int
-pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
+pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+		  struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -828,13 +835,13 @@ pci224_ao_cmdtest(struct comedi_device *
 		/* Force to external trigger 0. */
 		if ((cmd->start_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->start_arg = COMBINE(cmd->start_arg, 0,
-				~CR_FLAGS_MASK);
+						 ~CR_FLAGS_MASK);
 			err++;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->start_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
 			cmd->start_arg = COMBINE(cmd->start_arg, 0,
-				CR_FLAGS_MASK & ~CR_EDGE);
+						 CR_FLAGS_MASK & ~CR_EDGE);
 			err++;
 		}
 		break;
@@ -859,14 +866,16 @@ pci224_ao_cmdtest(struct comedi_device *
 		/* Force to external trigger 0. */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				~CR_FLAGS_MASK);
+						      ~CR_FLAGS_MASK);
 			err++;
 		}
 		/* Only allow flags CR_EDGE and CR_INVERT.  Ignore CR_EDGE. */
 		if ((cmd->scan_begin_arg & CR_FLAGS_MASK &
-				~(CR_EDGE | CR_INVERT)) != 0) {
+		     ~(CR_EDGE | CR_INVERT)) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
+						      CR_FLAGS_MASK & ~(CR_EDGE
+									|
+									CR_INVERT));
 			err++;
 		}
 		break;
@@ -892,13 +901,13 @@ pci224_ao_cmdtest(struct comedi_device *
 		/* Force to external trigger 0. */
 		if ((cmd->stop_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
-				~CR_FLAGS_MASK);
+						~CR_FLAGS_MASK);
 			err++;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->stop_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
 			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
-				CR_FLAGS_MASK & ~CR_EDGE);
+						CR_FLAGS_MASK & ~CR_EDGE);
 		}
 		break;
 	case TRIG_NONE:
@@ -935,14 +944,14 @@ pci224_ao_cmdtest(struct comedi_device *
 		/* Be careful to avoid overflow! */
 		div2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;
 		div2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /
-			TIMEBASE_10MHZ;
+		    TIMEBASE_10MHZ;
 		if (div2 <= 0x10000) {
 			/* A single timer will suffice. */
 			if (div2 < 2)
 				div2 = 2;
 			cmd->scan_begin_arg = div2 * TIMEBASE_10MHZ;
 			if (cmd->scan_begin_arg < div2 ||
-				cmd->scan_begin_arg < TIMEBASE_10MHZ) {
+			    cmd->scan_begin_arg < TIMEBASE_10MHZ) {
 				/* Overflow! */
 				cmd->scan_begin_arg = MAX_SCAN_PERIOD;
 			}
@@ -951,7 +960,8 @@ pci224_ao_cmdtest(struct comedi_device *
 			div1 = devpriv->cached_div1;
 			div2 = devpriv->cached_div2;
 			pci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,
-				&cmd->scan_begin_arg, round_mode);
+						   &cmd->scan_begin_arg,
+						   round_mode);
 			devpriv->cached_div1 = div1;
 			devpriv->cached_div2 = div2;
 		}
@@ -1061,12 +1071,15 @@ static int pci224_ao_cmd(struct comedi_d
 	 * N.B. DAC FIFO interrupts are currently disabled.
 	 */
 	devpriv->daccon = COMBINE(devpriv->daccon,
-		(devpriv->hwrange[range] | PCI224_DACCON_TRIG_NONE |
-			PCI224_DACCON_FIFOINTR_NHALF),
-		(PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK |
-			PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK));
+				  (devpriv->
+				   hwrange[range] | PCI224_DACCON_TRIG_NONE |
+				   PCI224_DACCON_FIFOINTR_NHALF),
+				  (PCI224_DACCON_POLAR_MASK |
+				   PCI224_DACCON_VREF_MASK |
+				   PCI224_DACCON_TRIG_MASK |
+				   PCI224_DACCON_FIFOINTR_MASK));
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
-		dev->iobase + PCI224_DACCON);
+	     dev->iobase + PCI224_DACCON);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		unsigned int div1, div2, round;
@@ -1089,7 +1102,7 @@ static int pci224_ao_cmd(struct comedi_d
 		/* Be careful to avoid overflow! */
 		div2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;
 		div2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /
-			TIMEBASE_10MHZ;
+		    TIMEBASE_10MHZ;
 		if (div2 <= 0x10000) {
 			/* A single timer will suffice. */
 			if (div2 < 2)
@@ -1101,7 +1114,7 @@ static int pci224_ao_cmd(struct comedi_d
 			div1 = devpriv->cached_div1;
 			div2 = devpriv->cached_div2;
 			pci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,
-				&ns, round_mode);
+						   &ns, round_mode);
 		}
 
 		/*
@@ -1110,25 +1123,25 @@ static int pci224_ao_cmd(struct comedi_d
 		 */
 		/* Make sure Z2-0 is gated on.  */
 		outb(GAT_CONFIG(0, GAT_VCC),
-			devpriv->iobase1 + PCI224_ZGAT_SCE);
+		     devpriv->iobase1 + PCI224_ZGAT_SCE);
 		if (div1 == 1) {
 			/* Not cascading.  Z2-0 needs 10 MHz clock. */
 			outb(CLK_CONFIG(0, CLK_10MHZ),
-				devpriv->iobase1 + PCI224_ZCLK_SCE);
+			     devpriv->iobase1 + PCI224_ZCLK_SCE);
 		} else {
 			/* Cascading with Z2-2. */
 			/* Make sure Z2-2 is gated on.  */
 			outb(GAT_CONFIG(2, GAT_VCC),
-				devpriv->iobase1 + PCI224_ZGAT_SCE);
+			     devpriv->iobase1 + PCI224_ZGAT_SCE);
 			/* Z2-2 needs 10 MHz clock. */
 			outb(CLK_CONFIG(2, CLK_10MHZ),
-				devpriv->iobase1 + PCI224_ZCLK_SCE);
+			     devpriv->iobase1 + PCI224_ZCLK_SCE);
 			/* Load Z2-2 mode (2) and counter (div1). */
 			i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
-				2, div1, 2);
+				   2, div1, 2);
 			/* Z2-0 is clocked from Z2-2's output. */
 			outb(CLK_CONFIG(0, CLK_OUTNM1),
-				devpriv->iobase1 + PCI224_ZCLK_SCE);
+			     devpriv->iobase1 + PCI224_ZCLK_SCE);
 		}
 		/* Load Z2-0 mode (2) and counter (div2). */
 		i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0, 0, div2, 2);
@@ -1174,7 +1187,8 @@ static int pci224_ao_cmd(struct comedi_d
 /*
  * 'cancel' function for AO subdevice.
  */
-static int pci224_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci224_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	pci224_ao_stop(dev, s);
 	return 0;
@@ -1184,8 +1198,8 @@ static int pci224_ao_cancel(struct comed
  * 'munge' data for AO command.
  */
 static void
-pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s, void *data,
-	unsigned int num_bytes, unsigned int chan_index)
+pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
+		void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
 	short *array = data;
@@ -1198,7 +1212,7 @@ pci224_ao_munge(struct comedi_device *de
 	shift = 16 - thisboard->ao_bits;
 	/* Channels will be all bipolar or all unipolar. */
 	if ((devpriv->hwrange[CR_RANGE(async->cmd.chanlist[0])] &
-			PCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {
+	     PCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {
 		/* Unipolar */
 		offset = 0;
 	} else {
@@ -1253,7 +1267,7 @@ static irqreturn_t pci224_interrupt(int 
 		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		if (curenab != devpriv->intsce) {
 			outb(devpriv->intsce,
-				devpriv->iobase1 + PCI224_INT_SCE);
+			     devpriv->iobase1 + PCI224_INT_SCE);
 		}
 		devpriv->intr_running = 0;
 		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
@@ -1267,7 +1281,7 @@ static irqreturn_t pci224_interrupt(int 
  */
 static int
 pci224_find_pci(struct comedi_device *dev, int bus, int slot,
-	struct pci_dev **pci_dev_p)
+		struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
 
@@ -1275,13 +1289,13 @@ pci224_find_pci(struct comedi_device *de
 
 	/* Look for matching PCI device. */
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
-			pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
+				      pci_dev)) {
 		/* If bus/slot specified, check them. */
 		if (bus || slot) {
 			if (bus != pci_dev->bus->number
-				|| slot != PCI_SLOT(pci_dev->devfn))
+			    || slot != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
 		if (thisboard->model == any_model) {
@@ -1310,11 +1324,11 @@ pci224_find_pci(struct comedi_device *de
 	/* No match found. */
 	if (bus || slot) {
 		printk(KERN_ERR "comedi%d: error! "
-			"no %s found at pci %02x:%02x!\n",
-			dev->minor, thisboard->name, bus, slot);
+		       "no %s found at pci %02x:%02x!\n",
+		       dev->minor, thisboard->name, bus, slot);
 	} else {
 		printk(KERN_ERR "comedi%d: error! no %s found!\n",
-			dev->minor, thisboard->name);
+		       dev->minor, thisboard->name);
 	}
 	return -EIO;
 }
@@ -1341,7 +1355,7 @@ static int pci224_attach(struct comedi_d
 	ret = alloc_private(dev, sizeof(struct pci224_private));
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -1353,8 +1367,8 @@ static int pci224_attach(struct comedi_d
 	ret = comedi_pci_enable(pci_dev, DRIVER_NAME);
 	if (ret < 0) {
 		printk(KERN_ERR
-			"comedi%d: error! cannot enable PCI device "
-			"and request regions!\n", dev->minor);
+		       "comedi%d: error! cannot enable PCI device "
+		       "and request regions!\n", dev->minor);
 		return ret;
 	}
 	spin_lock_init(&devpriv->ao_spinlock);
@@ -1365,21 +1379,21 @@ static int pci224_attach(struct comedi_d
 
 	/* Allocate readback buffer for AO channels. */
 	devpriv->ao_readback = kmalloc(sizeof(devpriv->ao_readback[0]) *
-		thisboard->ao_chans, GFP_KERNEL);
+				       thisboard->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_readback) {
 		return -ENOMEM;
 	}
 
 	/* Allocate buffer to hold values for AO channel scan. */
 	devpriv->ao_scan_vals = kmalloc(sizeof(devpriv->ao_scan_vals[0]) *
-		thisboard->ao_chans, GFP_KERNEL);
+					thisboard->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_scan_vals) {
 		return -ENOMEM;
 	}
 
 	/* Allocate buffer to hold AO channel scan order. */
 	devpriv->ao_scan_order = kmalloc(sizeof(devpriv->ao_scan_order[0]) *
-		thisboard->ao_chans, GFP_KERNEL);
+					 thisboard->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_scan_order) {
 		return -ENOMEM;
 	}
@@ -1393,15 +1407,16 @@ static int pci224_attach(struct comedi_d
 	outw(0, dev->iobase + PCI224_DACCEN);
 	outw(0, dev->iobase + PCI224_FIFOSIZ);
 	devpriv->daccon = (PCI224_DACCON_TRIG_SW | PCI224_DACCON_POLAR_BI |
-		PCI224_DACCON_FIFOENAB | PCI224_DACCON_FIFOINTR_EMPTY);
+			   PCI224_DACCON_FIFOENAB |
+			   PCI224_DACCON_FIFOINTR_EMPTY);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
-		dev->iobase + PCI224_DACCON);
+	     dev->iobase + PCI224_DACCON);
 
 	/* Allocate subdevices.  There is only one!  */
 	ret = alloc_subdevices(dev, 1);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -1427,22 +1442,22 @@ static int pci224_attach(struct comedi_d
 		const struct comedi_lrange **range_table_list;
 
 		s->range_table_list = range_table_list =
-			kmalloc(sizeof(struct comedi_lrange *) * s->n_chan,
-			GFP_KERNEL);
+		    kmalloc(sizeof(struct comedi_lrange *) * s->n_chan,
+			    GFP_KERNEL);
 		if (!s->range_table_list) {
 			return -ENOMEM;
 		}
 		for (n = 2; n < 3 + s->n_chan; n++) {
 			if (it->options[n] < 0 || it->options[n] > 1) {
 				printk(KERN_WARNING "comedi%d: %s: warning! "
-					"bad options[%u]=%d\n",
-					dev->minor, DRIVER_NAME, n,
-					it->options[n]);
+				       "bad options[%u]=%d\n",
+				       dev->minor, DRIVER_NAME, n,
+				       it->options[n]);
 			}
 		}
 		for (n = 0; n < s->n_chan; n++) {
 			if (n < COMEDI_NDEVCONFOPTS - 3 &&
-				it->options[3 + n] == 1) {
+			    it->options[3 + n] == 1) {
 				if (it->options[2] == 1) {
 					range_table_list[n] = &range_pci234_ext;
 				} else {
@@ -1451,7 +1466,7 @@ static int pci224_attach(struct comedi_d
 			} else {
 				if (it->options[2] == 1) {
 					range_table_list[n] =
-						&range_pci234_ext2;
+					    &range_pci234_ext2;
 				} else {
 					range_table_list[n] = &range_bipolar10;
 				}
@@ -1466,9 +1481,8 @@ static int pci224_attach(struct comedi_d
 		} else {
 			if (it->options[2] != 0) {
 				printk(KERN_WARNING "comedi%d: %s: warning! "
-					"bad options[2]=%d\n",
-					dev->minor, DRIVER_NAME,
-					it->options[2]);
+				       "bad options[2]=%d\n",
+				       dev->minor, DRIVER_NAME, it->options[2]);
 			}
 			s->range_table = &range_pci224_internal;
 			devpriv->hwrange = hwrange_pci224_internal;
@@ -1482,7 +1496,7 @@ static int pci224_attach(struct comedi_d
 				  DRIVER_NAME, dev);
 		if (ret < 0) {
 			printk(KERN_ERR "comedi%d: error! "
-				"unable to allocate irq %u\n", dev->minor, irq);
+			       "unable to allocate irq %u\n", dev->minor, irq);
 			return ret;
 		} else {
 			dev->irq = irq;
@@ -1545,7 +1559,7 @@ static int pci224_detach(struct comedi_d
 	}
 	if (dev->board_name) {
 		printk(KERN_INFO "comedi%d: %s removed\n",
-			dev->minor, dev->board_name);
+		       dev->minor, dev->board_name);
 	}
 
 	return 0;
--- a/drivers/staging/comedi/drivers/amplc_pci230.c
+++ b/drivers/staging/comedi/drivers/amplc_pci230.c
@@ -457,55 +457,56 @@ struct pci230_board {
 };
 static const struct pci230_board pci230_boards[] = {
 	{
-	.name = "pci230+",
-	.id = PCI_DEVICE_ID_PCI230,
-	.ai_chans = 16,
-	.ai_bits = 16,
-	.ao_chans = 2,
-	.ao_bits = 12,
-	.have_dio = 1,
-	.min_hwver = 1,
-		},
+	 .name = "pci230+",
+	 .id = PCI_DEVICE_ID_PCI230,
+	 .ai_chans = 16,
+	 .ai_bits = 16,
+	 .ao_chans = 2,
+	 .ao_bits = 12,
+	 .have_dio = 1,
+	 .min_hwver = 1,
+	 },
 	{
-	.name = "pci260+",
-	.id = PCI_DEVICE_ID_PCI260,
-	.ai_chans = 16,
-	.ai_bits = 16,
-	.ao_chans = 0,
-	.ao_bits = 0,
-	.have_dio = 0,
-	.min_hwver = 1,
-		},
+	 .name = "pci260+",
+	 .id = PCI_DEVICE_ID_PCI260,
+	 .ai_chans = 16,
+	 .ai_bits = 16,
+	 .ao_chans = 0,
+	 .ao_bits = 0,
+	 .have_dio = 0,
+	 .min_hwver = 1,
+	 },
 	{
-	.name = "pci230",
-	.id = PCI_DEVICE_ID_PCI230,
-	.ai_chans = 16,
-	.ai_bits = 12,
-	.ao_chans = 2,
-	.ao_bits = 12,
-	.have_dio = 1,
-		},
+	 .name = "pci230",
+	 .id = PCI_DEVICE_ID_PCI230,
+	 .ai_chans = 16,
+	 .ai_bits = 12,
+	 .ao_chans = 2,
+	 .ao_bits = 12,
+	 .have_dio = 1,
+	 },
 	{
-	.name = "pci260",
-	.id = PCI_DEVICE_ID_PCI260,
-	.ai_chans = 16,
-	.ai_bits = 12,
-	.ao_chans = 0,
-	.ao_bits = 0,
-	.have_dio = 0,
-		},
+	 .name = "pci260",
+	 .id = PCI_DEVICE_ID_PCI260,
+	 .ai_chans = 16,
+	 .ai_bits = 12,
+	 .ao_chans = 0,
+	 .ao_bits = 0,
+	 .have_dio = 0,
+	 },
 	{
-	.name = "amplc_pci230",	/* Wildcard matches any above */
-	.id = PCI_DEVICE_ID_INVALID,
-		},
+	 .name = "amplc_pci230",	/* Wildcard matches any above */
+	 .id = PCI_DEVICE_ID_INVALID,
+	 },
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci230_pci_table) = {
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230, PCI_ANY_ID, PCI_ANY_ID,
-		0, 0, 0},
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260, PCI_ANY_ID, PCI_ANY_ID,
-		0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci230_pci_table);
@@ -571,14 +572,14 @@ static const unsigned int pci230_timebas
 
 /* PCI230 analogue input range table */
 static const struct comedi_lrange pci230_ai_range = { 7, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5)
-	}
+							  BIP_RANGE(10),
+							  BIP_RANGE(5),
+							  BIP_RANGE(2.5),
+							  BIP_RANGE(1.25),
+							  UNI_RANGE(10),
+							  UNI_RANGE(5),
+							  UNI_RANGE(2.5)
+							  }
 };
 
 /* PCI230 analogue gain bits for each input range. */
@@ -589,9 +590,9 @@ static const unsigned char pci230_ai_bip
 
 /* PCI230 analogue output range table */
 static const struct comedi_lrange pci230_ao_range = { 2, {
-			UNI_RANGE(10),
-			BIP_RANGE(10)
-	}
+							  UNI_RANGE(10),
+							  BIP_RANGE(10)
+							  }
 };
 
 /* PCI230 daccon bipolar flag for each analogue output range. */
@@ -603,7 +604,8 @@ static const unsigned char pci230_ao_bip
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci230_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pci230_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_pci230 = {
 	.driver_name = "amplc_pci230",
@@ -617,35 +619,48 @@ static struct comedi_driver driver_amplc
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci230, pci230_pci_table);
 
-static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pci230_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pci230_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pci230_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int pci230_ao_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int pci230_ao_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
 static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
-	unsigned int mode, uint64_t ns, unsigned int round);
+				    unsigned int mode, uint64_t ns,
+				    unsigned int round);
 static void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round);
 static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct);
 static irqreturn_t pci230_interrupt(int irq, void *d);
-static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int pci230_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 static int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s);
-static void pci230_handle_ao_nofifo(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int pci230_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static void pci230_ao_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
+static void pci230_handle_ao_nofifo(struct comedi_device *dev,
+				    struct comedi_subdevice *s);
+static int pci230_handle_ao_fifo(struct comedi_device *dev,
+				 struct comedi_subdevice *s);
+static int pci230_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 static int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci230_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s);
-static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci230_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static void pci230_ai_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
+static void pci230_handle_ai(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 
 static short pci230_ai_read(struct comedi_device *dev)
 {
 	/* Read sample. */
-	short data = (short) inw(dev->iobase + PCI230_ADCDATA);
+	short data = (short)inw(dev->iobase + PCI230_ADCDATA);
 
 	/* PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
 	 * four bits reserved for expansion). */
@@ -661,7 +676,7 @@ static short pci230_ai_read(struct comed
 }
 
 static inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,
-	short datum)
+						    short datum)
 {
 	/* If a bipolar range was specified, mangle it (straight binary->twos
 	 * complement). */
@@ -676,26 +691,28 @@ static inline unsigned short pci230_ao_m
 	return (unsigned short)datum;
 }
 
-static inline void pci230_ao_write_nofifo(struct comedi_device *dev, short datum,
-	unsigned int chan)
+static inline void pci230_ao_write_nofifo(struct comedi_device *dev,
+					  short datum, unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
 	devpriv->ao_readback[chan] = datum;
 
 	/* Write mangled datum to appropriate DACOUT register. */
 	outw(pci230_ao_mangle_datum(dev, datum), dev->iobase + (((chan) == 0)
-			? PCI230_DACOUT1 : PCI230_DACOUT2));
+								? PCI230_DACOUT1
+								:
+								PCI230_DACOUT2));
 }
 
 static inline void pci230_ao_write_fifo(struct comedi_device *dev, short datum,
-	unsigned int chan)
+					unsigned int chan)
 {
 	/* Store unmangled datum to be read back later. */
 	devpriv->ao_readback[chan] = datum;
 
 	/* Write mangled datum to appropriate DACDATA register. */
 	outw(pci230_ao_mangle_datum(dev, datum),
-		dev->iobase + PCI230P2_DACDATA);
+	     dev->iobase + PCI230P2_DACDATA);
 }
 
 /*
@@ -713,7 +730,7 @@ static int pci230_attach(struct comedi_d
 	int i = 0, irq_hdl, rc;
 
 	printk("comedi%d: amplc_pci230: attach %s %d,%d\n", dev->minor,
-		thisboard->name, it->options[0], it->options[1]);
+	       thisboard->name, it->options[0], it->options[1]);
 
 	/* Allocate the private structure area using alloc_private().
 	 * Macro defined in comedidev.h - memsets struct fields to 0. */
@@ -726,12 +743,12 @@ static int pci230_attach(struct comedi_d
 	spin_lock_init(&devpriv->ao_stop_spinlock);
 	/* Find card */
 	for (pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) {
 		if (it->options[0] || it->options[1]) {
 			/* Match against bus/slot options. */
 			if (it->options[0] != pci_dev->bus->number ||
-				it->options[1] != PCI_SLOT(pci_dev->devfn))
+			    it->options[1] != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
 		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
@@ -748,7 +765,7 @@ static int pci230_attach(struct comedi_d
 						 * First check length of
 						 * registers. */
 						if (pci_resource_len(pci_dev, 3)
-							< 32) {
+						    < 32) {
 							/* Not a '+' model. */
 							continue;
 						}
@@ -790,7 +807,7 @@ static int pci230_attach(struct comedi_d
 	}
 	if (!pci_dev) {
 		printk("comedi%d: No %s card found\n", dev->minor,
-			thisboard->name);
+		       thisboard->name);
 		return -EIO;
 	}
 	devpriv->pci_dev = pci_dev;
@@ -803,7 +820,7 @@ static int pci230_attach(struct comedi_d
 	/* Enable PCI device and reserve I/O spaces. */
 	if (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {
 		printk("comedi%d: failed to enable PCI device "
-			"and request regions\n", dev->minor);
+		       "and request regions\n", dev->minor);
 		return -EIO;
 	}
 
@@ -813,7 +830,7 @@ static int pci230_attach(struct comedi_d
 	iobase2 = pci_resource_start(pci_dev, 3);
 
 	printk("comedi%d: %s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",
-		dev->minor, dev->board_name, iobase1, iobase2);
+	       dev->minor, dev->board_name, iobase1, iobase2);
 
 	devpriv->iobase1 = iobase1;
 	dev->iobase = iobase2;
@@ -829,9 +846,9 @@ static int pci230_attach(struct comedi_d
 		devpriv->hwver = inw(dev->iobase + PCI230P_HWVER);
 		if (devpriv->hwver < thisboard->min_hwver) {
 			printk("comedi%d: %s - bad hardware version "
-				"- got %u, need %u\n", dev->minor,
-				dev->board_name, devpriv->hwver,
-				thisboard->min_hwver);
+			       "- got %u, need %u\n", dev->minor,
+			       dev->board_name, devpriv->hwver,
+			       thisboard->min_hwver);
 			return -EIO;
 		}
 		if (devpriv->hwver > 0) {
@@ -844,7 +861,7 @@ static int pci230_attach(struct comedi_d
 				extfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;
 			}
 			if ((thisboard->ao_chans > 0)
-				&& (devpriv->hwver >= 2)) {
+			    && (devpriv->hwver >= 2)) {
 				/* Enable DAC FIFO functionality. */
 				extfunc |= PCI230P2_EXTFUNC_DACFIFO;
 			}
@@ -854,8 +871,8 @@ static int pci230_attach(struct comedi_d
 			/* Temporarily enable DAC FIFO, reset it and disable
 			 * FIFO wraparound. */
 			outw(devpriv->daccon | PCI230P2_DAC_FIFO_EN
-				| PCI230P2_DAC_FIFO_RESET,
-				dev->iobase + PCI230_DACCON);
+			     | PCI230P2_DAC_FIFO_RESET,
+			     dev->iobase + PCI230_DACCON);
 			/* Clear DAC FIFO channel enable register. */
 			outw(0, dev->iobase + PCI230P2_DACEN);
 			/* Disable DAC FIFO. */
@@ -869,23 +886,23 @@ static int pci230_attach(struct comedi_d
 	/* Set ADC to a reasonable state. */
 	devpriv->adcg = 0;
 	devpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE
-		| PCI230_ADC_IR_BIP;
+	    | PCI230_ADC_IR_BIP;
 	outw(1 << 0, dev->iobase + PCI230_ADCEN);
 	outw(devpriv->adcg, dev->iobase + PCI230_ADCG);
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
-		dev->iobase + PCI230_ADCCON);
+	     dev->iobase + PCI230_ADCCON);
 
 	/* Register the interrupt handler. */
 	irq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,
 			      IRQF_SHARED, "amplc_pci230", dev);
 	if (irq_hdl < 0) {
 		printk("comedi%d: unable to register irq, "
-			"commands will not be available %d\n", dev->minor,
-			devpriv->pci_dev->irq);
+		       "commands will not be available %d\n", dev->minor,
+		       devpriv->pci_dev->irq);
 	} else {
 		dev->irq = devpriv->pci_dev->irq;
 		printk("comedi%d: registered irq %u\n", dev->minor,
-			devpriv->pci_dev->irq);
+		       devpriv->pci_dev->irq);
 	}
 
 	/*
@@ -941,7 +958,7 @@ static int pci230_attach(struct comedi_d
 	/* digital i/o subdevice */
 	if (thisboard->have_dio) {
 		rc = subdev_8255_init(dev, s, NULL,
-			(devpriv->iobase1 + PCI230_PPI_X_BASE));
+				      (devpriv->iobase1 + PCI230_PPI_X_BASE));
 		if (rc < 0)
 			return rc;
 	} else {
@@ -985,7 +1002,7 @@ static int pci230_detach(struct comedi_d
 }
 
 static int get_resources(struct comedi_device *dev, unsigned int res_mask,
-	unsigned char owner)
+			 unsigned char owner)
 {
 	int ok;
 	unsigned int i;
@@ -997,7 +1014,7 @@ static int get_resources(struct comedi_d
 	claimed = 0;
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
-		&& (res_mask != 0); b <<= 1, i++) {
+	     && (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == OWNER_NONE) {
@@ -1007,7 +1024,7 @@ static int get_resources(struct comedi_d
 				for (b = 1, i = 0; claimed != 0; b <<= 1, i++) {
 					if ((claimed & b) != 0) {
 						devpriv->res_owner[i]
-							= OWNER_NONE;
+						    = OWNER_NONE;
 						claimed &= ~b;
 					}
 				}
@@ -1020,14 +1037,14 @@ static int get_resources(struct comedi_d
 	return ok;
 }
 
-static inline int get_one_resource(struct comedi_device *dev, unsigned int resource,
-	unsigned char owner)
+static inline int get_one_resource(struct comedi_device *dev,
+				   unsigned int resource, unsigned char owner)
 {
 	return get_resources(dev, (1U << resource), owner);
 }
 
 static void put_resources(struct comedi_device *dev, unsigned int res_mask,
-	unsigned char owner)
+			  unsigned char owner)
 {
 	unsigned int i;
 	unsigned int b;
@@ -1035,7 +1052,7 @@ static void put_resources(struct comedi_
 
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
-		&& (res_mask != 0); b <<= 1, i++) {
+	     && (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
 			res_mask &= ~b;
 			if (devpriv->res_owner[i] == owner) {
@@ -1046,13 +1063,14 @@ static void put_resources(struct comedi_
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
 
-static inline void put_one_resource(struct comedi_device *dev, unsigned int resource,
-	unsigned char owner)
+static inline void put_one_resource(struct comedi_device *dev,
+				    unsigned int resource, unsigned char owner)
 {
 	put_resources(dev, (1U << resource), owner);
 }
 
-static inline void put_all_resources(struct comedi_device *dev, unsigned char owner)
+static inline void put_all_resources(struct comedi_device *dev,
+				     unsigned char owner)
 {
 	put_resources(dev, (1U << NUM_RESOURCES) - 1, owner);
 }
@@ -1060,8 +1078,9 @@ static inline void put_all_resources(str
 /*
  *  COMEDI_SUBD_AI instruction;
  */
-static int pci230_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci230_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	unsigned int n, i;
 	unsigned int chan, range, aref;
@@ -1112,7 +1131,7 @@ static int pci230_ai_rinsn(struct comedi
 		adccon |= PCI230_ADC_IM_SE;
 	}
 	devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
-		| (pci230_ai_gain[range] << gainshift);
+	    | (pci230_ai_gain[range] << gainshift);
 	if (devpriv->ai_bipolar) {
 		adccon |= PCI230_ADC_IR_BIP;
 	} else {
@@ -1135,9 +1154,9 @@ static int pci230_ai_rinsn(struct comedi
 		/* Trigger conversion by toggling Z2-CT2 output (finish with
 		 * output high). */
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			I8254_MODE0);
+			       I8254_MODE0);
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			I8254_MODE1);
+			       I8254_MODE1);
 
 #define TIMEOUT 100
 		/* wait for conversion to end */
@@ -1165,8 +1184,9 @@ static int pci230_ai_rinsn(struct comedi
 /*
  *  COMEDI_SUBD_AO instructions;
  */
-static int pci230_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci230_ao_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i;
 	int chan, range;
@@ -1193,8 +1213,9 @@ static int pci230_ao_winsn(struct comedi
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int pci230_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci230_ao_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1205,8 +1226,8 @@ static int pci230_ao_rinsn(struct comedi
 	return i;
 }
 
-static int pci230_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pci230_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1317,17 +1338,16 @@ static int pci230_ao_cmdtest(struct come
 		/* Trigger number must be 0. */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				~CR_FLAGS_MASK);
+						      ~CR_FLAGS_MASK);
 			err++;
 		}
 		/* The only flags allowed are CR_EDGE and CR_INVERT.  The
 		 * CR_EDGE flag is ignored. */
 		if ((cmd->scan_begin_arg
-				& (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) !=
-			0) {
+		     & (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
 			cmd->scan_begin_arg =
-				COMBINE(cmd->scan_begin_arg, 0,
-				CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
+			    COMBINE(cmd->scan_begin_arg, 0,
+				    CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
 			err++;
 		}
 		break;
@@ -1361,7 +1381,7 @@ static int pci230_ao_cmdtest(struct come
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -1419,7 +1439,8 @@ static int pci230_ao_cmdtest(struct come
 }
 
 static int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int trig_num)
+					struct comedi_subdevice *s,
+					unsigned int trig_num)
 {
 	unsigned long irqflags;
 
@@ -1431,16 +1452,16 @@ static int pci230_ao_inttrig_scan_begin(
 		/* Perform scan. */
 		if (devpriv->hwver < 2) {
 			/* Not using DAC FIFO. */
-			spin_unlock_irqrestore(&devpriv->
-				ao_stop_spinlock, irqflags);
+			spin_unlock_irqrestore(&devpriv->ao_stop_spinlock,
+					       irqflags);
 			pci230_handle_ao_nofifo(dev, s);
 			comedi_event(dev, s);
 		} else {
 			/* Using DAC FIFO. */
 			/* Read DACSWTRIG register to trigger conversion. */
 			inw(dev->iobase + PCI230P2_DACSWTRIG);
-			spin_unlock_irqrestore(&devpriv->
-				ao_stop_spinlock, irqflags);
+			spin_unlock_irqrestore(&devpriv->ao_stop_spinlock,
+					       irqflags);
 		}
 		/* Delay.  Should driver be responsible for this? */
 		/* XXX TODO: See if DAC busy bit can be used. */
@@ -1450,7 +1471,8 @@ static int pci230_ao_inttrig_scan_begin(
 	return 1;
 }
 
-static void pci230_ao_start(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_ao_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1499,7 +1521,8 @@ static void pci230_ao_start(struct comed
 				break;
 			}
 			devpriv->daccon = (devpriv->daccon
-				& ~PCI230P2_DAC_TRIG_MASK) | scantrig;
+					   & ~PCI230P2_DAC_TRIG_MASK) |
+			    scantrig;
 			outw(devpriv->daccon, dev->iobase + PCI230_DACCON);
 
 		}
@@ -1509,17 +1532,17 @@ static void pci230_ao_start(struct comed
 				/* Not using DAC FIFO. */
 				/* Enable CT1 timer interrupt. */
 				spin_lock_irqsave(&devpriv->isr_spinlock,
-					irqflags);
+						  irqflags);
 				devpriv->int_en |= PCI230_INT_ZCLK_CT1;
 				devpriv->ier |= PCI230_INT_ZCLK_CT1;
 				outb(devpriv->ier,
-					devpriv->iobase1 + PCI230_INT_SCE);
-				spin_unlock_irqrestore(&devpriv->
-					isr_spinlock, irqflags);
+				     devpriv->iobase1 + PCI230_INT_SCE);
+				spin_unlock_irqrestore(&devpriv->isr_spinlock,
+						       irqflags);
 			}
 			/* Set CT1 gate high to start counting. */
 			outb(GAT_CONFIG(1, GAT_VCC),
-				devpriv->iobase1 + PCI230_ZGAT_SCE);
+			     devpriv->iobase1 + PCI230_ZGAT_SCE);
 			break;
 		case TRIG_INT:
 			async->inttrig = pci230_ao_inttrig_scan_begin;
@@ -1527,19 +1550,19 @@ static void pci230_ao_start(struct comed
 		}
 		if (devpriv->hwver >= 2) {
 			/* Using DAC FIFO.  Enable DAC FIFO interrupt. */
-			spin_lock_irqsave(&devpriv->isr_spinlock,
-				irqflags);
+			spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
 			devpriv->int_en |= PCI230P2_INT_DAC;
 			devpriv->ier |= PCI230P2_INT_DAC;
 			outb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);
 			spin_unlock_irqrestore(&devpriv->isr_spinlock,
-				irqflags);
+					       irqflags);
 		}
 	}
 }
 
-static int pci230_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trig_num)
+static int pci230_ao_inttrig_start(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int trig_num)
 {
 	if (trig_num != 0)
 		return -EINVAL;
@@ -1600,24 +1623,25 @@ static int pci230_ao_cmd(struct comedi_d
 		 * N.B. DAC FIFO interrupts are currently disabled.
 		 */
 		daccon |= PCI230P2_DAC_FIFO_EN | PCI230P2_DAC_FIFO_RESET
-			| PCI230P2_DAC_FIFO_UNDERRUN_CLEAR
-			| PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;
+		    | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR
+		    | PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;
 	}
 
 	/* Set DACCON. */
 	outw(daccon, dev->iobase + PCI230_DACCON);
 	/* Preserve most of DACCON apart from write-only, transient bits. */
 	devpriv->daccon = daccon
-		& ~(PCI230P2_DAC_FIFO_RESET | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
+	    & ~(PCI230P2_DAC_FIFO_RESET | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		/* Set the counter timer 1 to the specified scan frequency. */
 		/* cmd->scan_begin_arg is sampling period in ns */
 		/* gate it off for now. */
 		outb(GAT_CONFIG(1, GAT_GND),
-			devpriv->iobase1 + PCI230_ZGAT_SCE);
+		     devpriv->iobase1 + PCI230_ZGAT_SCE);
 		pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
-			cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);
+					cmd->scan_begin_arg,
+					cmd->flags & TRIG_ROUND_MASK);
 	}
 
 	/* N.B. cmd->start_src == TRIG_INT */
@@ -1637,7 +1661,7 @@ static int pci230_ai_check_scan_period(s
 	}
 	min_scan_period = chanlist_len * cmd->convert_arg;
 	if ((min_scan_period < chanlist_len)
-		|| (min_scan_period < cmd->convert_arg)) {
+	    || (min_scan_period < cmd->convert_arg)) {
 		/* Arithmetic overflow. */
 		min_scan_period = UINT_MAX;
 		err++;
@@ -1650,8 +1674,8 @@ static int pci230_ai_check_scan_period(s
 	return !err;
 }
 
-static int pci230_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pci230_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1679,7 +1703,7 @@ static int pci230_ai_cmdtest(struct come
 	 * EXTTRIG/EXTCONVCLK input on pin 17 instead. */
 	if ((thisboard->have_dio) || (thisboard->min_hwver > 0)) {
 		cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT
-			| TRIG_EXT;
+		    | TRIG_EXT;
 	} else {
 		cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;
 	}
@@ -1723,7 +1747,7 @@ static int pci230_ai_cmdtest(struct come
 	/* If scan_begin_src is not TRIG_FOLLOW, then a monostable will be
 	 * set up to generate a fixed number of timed conversion pulses. */
 	if ((cmd->scan_begin_src != TRIG_FOLLOW)
-		&& (cmd->convert_src != TRIG_TIMER))
+	    && (cmd->convert_src != TRIG_TIMER))
 		err++;
 
 	if (err)
@@ -1788,17 +1812,17 @@ static int pci230_ai_cmdtest(struct come
 			/* Trigger number must be 0. */
 			if ((cmd->convert_arg & ~CR_FLAGS_MASK) != 0) {
 				cmd->convert_arg = COMBINE(cmd->convert_arg, 0,
-					~CR_FLAGS_MASK);
+							   ~CR_FLAGS_MASK);
 				err++;
 			}
 			/* The only flags allowed are CR_INVERT and CR_EDGE.
 			 * CR_EDGE is required. */
 			if ((cmd->convert_arg & (CR_FLAGS_MASK & ~CR_INVERT))
-				!= CR_EDGE) {
+			    != CR_EDGE) {
 				/* Set CR_EDGE, preserve CR_INVERT. */
 				cmd->convert_arg =
-					COMBINE(cmd->start_arg, (CR_EDGE | 0),
-					CR_FLAGS_MASK & ~CR_INVERT);
+				    COMBINE(cmd->start_arg, (CR_EDGE | 0),
+					    CR_FLAGS_MASK & ~CR_INVERT);
 				err++;
 			}
 		} else {
@@ -1836,13 +1860,13 @@ static int pci230_ai_cmdtest(struct come
 		 * of CT2 (sample convert trigger is CT2) */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				~CR_FLAGS_MASK);
+						      ~CR_FLAGS_MASK);
 			err++;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				CR_FLAGS_MASK & ~CR_EDGE);
+						      CR_FLAGS_MASK & ~CR_EDGE);
 			err++;
 		}
 	} else if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -1867,7 +1891,7 @@ static int pci230_ai_cmdtest(struct come
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		pci230_ns_to_single_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -1876,11 +1900,11 @@ static int pci230_ai_cmdtest(struct come
 		/* N.B. cmd->convert_arg is also TRIG_TIMER */
 		tmp = cmd->scan_begin_arg;
 		pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (!pci230_ai_check_scan_period(cmd)) {
 			/* Was below minimum required.  Round up. */
 			pci230_ns_to_single_timer(&cmd->scan_begin_arg,
-				TRIG_ROUND_UP);
+						  TRIG_ROUND_UP);
 			pci230_ai_check_scan_period(cmd);
 		}
 		if (tmp != cmd->scan_begin_arg)
@@ -1921,20 +1945,19 @@ static int pci230_ai_cmdtest(struct come
 			 * differential.  (These are remapped in software.  In
 			 * hardware, only the even channels are available.) */
 			if ((aref == AREF_DIFF)
-				&& (chan >= (s->n_chan / 2))) {
+			    && (chan >= (s->n_chan / 2))) {
 				errors |= diffchan_err;
 			}
 			if (n > 0) {
 				/* Channel numbers must strictly increase or
 				 * subsequence must repeat exactly. */
 				if ((chan <= prev_chan)
-					&& (subseq_len == 0)) {
+				    && (subseq_len == 0)) {
 					subseq_len = n;
 				}
 				if ((subseq_len > 0)
-					&& (cmd->chanlist[n] !=
-						cmd->chanlist[n %
-							subseq_len])) {
+				    && (cmd->chanlist[n] !=
+					cmd->chanlist[n % subseq_len])) {
 					errors |= seq_err;
 				}
 				/* Channels must have same AREF. */
@@ -1948,8 +1971,8 @@ static int pci230_ai_cmdtest(struct come
 				/* Single-ended channel pairs must have same
 				 * range.  */
 				if ((aref != AREF_DIFF)
-					&& (((chan ^ prev_chan) & ~1) == 0)
-					&& (range != prev_range)) {
+				    && (((chan ^ prev_chan) & ~1) == 0)
+				    && (range != prev_range)) {
 					errors |= rangepair_err;
 				}
 			}
@@ -1983,7 +2006,7 @@ static int pci230_ai_cmdtest(struct come
 			 * does, and we can't tell them apart!
 			 */
 			if ((subseq_len > 1)
-				&& (CR_CHAN(cmd->chanlist[0]) != 0)) {
+			    && (CR_CHAN(cmd->chanlist[0]) != 0)) {
 				errors |= buggy_chan0_err;
 			}
 		}
@@ -2021,11 +2044,11 @@ static int pci230_ai_cmdtest(struct come
 			if ((errors & buggy_chan0_err) != 0) {
 				/* Use printk instead of DPRINTK here. */
 				printk("comedi: comedi%d: amplc_pci230: "
-					"ai_cmdtest: Buggy PCI230+/260+ "
-					"h/w version %u requires first channel "
-					"of multi-channel sequence to be 0 "
-					"(corrected in h/w version 4)\n",
-					dev->minor, devpriv->hwver);
+				       "ai_cmdtest: Buggy PCI230+/260+ "
+				       "h/w version %u requires first channel "
+				       "of multi-channel sequence to be 0 "
+				       "(corrected in h/w version 4)\n",
+				       dev->minor, devpriv->hwver);
 			}
 		}
 	}
@@ -2037,7 +2060,7 @@ static int pci230_ai_cmdtest(struct come
 }
 
 static void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,
-	struct comedi_subdevice *s)
+						struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int scanlen = cmd->scan_end_arg;
@@ -2050,13 +2073,12 @@ static void pci230_ai_update_fifo_trigge
 		wake = scanlen - devpriv->ai_scan_pos;
 	} else {
 		if (devpriv->ai_continuous
-			|| (devpriv->ai_scan_count
-				>= PCI230_ADC_FIFOLEVEL_HALFFULL)
-			|| (scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+		    || (devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL)
+		    || (scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)) {
 			wake = PCI230_ADC_FIFOLEVEL_HALFFULL;
 		} else {
 			wake = (devpriv->ai_scan_count * scanlen)
-				- devpriv->ai_scan_pos;
+			    - devpriv->ai_scan_pos;
 		}
 	}
 	if (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {
@@ -2080,8 +2102,9 @@ static void pci230_ai_update_fifo_trigge
 	}
 }
 
-static int pci230_ai_inttrig_convert(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trig_num)
+static int pci230_ai_inttrig_convert(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     unsigned int trig_num)
 {
 	unsigned long irqflags;
 
@@ -2095,36 +2118,35 @@ static int pci230_ai_inttrig_convert(str
 		/* Trigger conversion by toggling Z2-CT2 output.  Finish
 		 * with output high. */
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			I8254_MODE0);
+			       I8254_MODE0);
 		i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,
-			I8254_MODE1);
+			       I8254_MODE1);
 		/* Delay.  Should driver be responsible for this?  An
 		 * alternative would be to wait until conversion is complete,
 		 * but we can't tell when it's complete because the ADC busy
 		 * bit has a different meaning when FIFO enabled (and when
 		 * FIFO not enabled, it only works for software triggers). */
 		if (((devpriv->adccon & PCI230_ADC_IM_MASK)
-				== PCI230_ADC_IM_DIF)
-			&& (devpriv->hwver == 0)) {
+		     == PCI230_ADC_IM_DIF)
+		    && (devpriv->hwver == 0)) {
 			/* PCI230/260 in differential mode */
 			delayus = 8;
 		} else {
 			/* single-ended or PCI230+/260+ */
 			delayus = 4;
 		}
-		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
-			irqflags);
+		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 		udelay(delayus);
 	} else {
-		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock,
-			irqflags);
+		spin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);
 	}
 
 	return 1;
 }
 
 static int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int trig_num)
+					struct comedi_subdevice *s,
+					unsigned int trig_num)
 {
 	unsigned long irqflags;
 	unsigned char zgat;
@@ -2145,7 +2167,8 @@ static int pci230_ai_inttrig_scan_begin(
 	return 1;
 }
 
-static void pci230_ai_start(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_ai_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	unsigned short conv;
@@ -2203,7 +2226,7 @@ static void pci230_ai_start(struct comed
 			break;
 		}
 		devpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK)
-			| conv;
+		    | conv;
 		outw(devpriv->adccon, dev->iobase + PCI230_ADCCON);
 		if (cmd->convert_src == TRIG_INT) {
 			async->inttrig = pci230_ai_inttrig_convert;
@@ -2267,11 +2290,11 @@ static void pci230_ai_start(struct comed
 					 * gated on to start counting. */
 					zgat = GAT_CONFIG(1, GAT_VCC);
 					outb(zgat, devpriv->iobase1
-						+ PCI230_ZGAT_SCE);
+					     + PCI230_ZGAT_SCE);
 					break;
 				case TRIG_INT:
 					async->inttrig =
-						pci230_ai_inttrig_scan_begin;
+					    pci230_ai_inttrig_scan_begin;
 					break;
 				}
 			}
@@ -2282,8 +2305,9 @@ static void pci230_ai_start(struct comed
 	}
 }
 
-static int pci230_ai_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trig_num)
+static int pci230_ai_inttrig_start(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int trig_num)
 {
 	if (trig_num != 0)
 		return -EINVAL;
@@ -2394,7 +2418,7 @@ static int pci230_ai_cmd(struct comedi_d
 			adcen |= 1 << chan;
 		}
 		devpriv->adcg = (devpriv->adcg & ~(3 << gainshift))
-			| (pci230_ai_gain[range] << gainshift);
+		    | (pci230_ai_gain[range] << gainshift);
 	}
 
 	/* Set channel scan list. */
@@ -2439,7 +2463,7 @@ static int pci230_ai_cmd(struct comedi_d
 		outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 		/* Set counter/timer 2 to the specified conversion period. */
 		pci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 		if (cmd->scan_begin_src != TRIG_FOLLOW) {
 			/*
 			 * Set up monostable on CT0 output for scan timing.  A
@@ -2456,8 +2480,9 @@ static int pci230_ai_cmd(struct comedi_d
 			zgat = GAT_CONFIG(0, GAT_VCC);
 			outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 			pci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,
-				((uint64_t) cmd->convert_arg
-					* cmd->scan_end_arg), TRIG_ROUND_UP);
+						((uint64_t) cmd->convert_arg
+						 * cmd->scan_end_arg),
+						TRIG_ROUND_UP);
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				/*
 				 * Monostable on CT0 will be triggered by
@@ -2468,8 +2493,10 @@ static int pci230_ai_cmd(struct comedi_d
 				zgat = GAT_CONFIG(1, GAT_GND);
 				outb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);
 				pci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,
-					cmd->scan_begin_arg,
-					cmd->flags & TRIG_ROUND_MASK);
+							cmd->scan_begin_arg,
+							cmd->
+							flags &
+							TRIG_ROUND_MASK);
 			}
 		}
 	}
@@ -2485,7 +2512,7 @@ static int pci230_ai_cmd(struct comedi_d
 }
 
 static unsigned int divide_ns(uint64_t ns, unsigned int timebase,
-	unsigned int round_mode)
+			      unsigned int round_mode)
 {
 	uint64_t div;
 	unsigned int rem;
@@ -2510,7 +2537,7 @@ static unsigned int divide_ns(uint64_t n
 /* Given desired period in ns, returns the required internal clock source
  * and gets the initial count. */
 static unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,
-	unsigned int round_mode)
+					    unsigned int round_mode)
 {
 	unsigned int clk_src, cnt;
 
@@ -2535,7 +2562,8 @@ static void pci230_ns_to_single_timer(un
 }
 
 static void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,
-	unsigned int mode, uint64_t ns, unsigned int round)
+				    unsigned int mode, uint64_t ns,
+				    unsigned int round)
 {
 	unsigned int clk_src;
 	unsigned int count;
@@ -2556,7 +2584,7 @@ static void pci230_ct_setup_ns_mode(stru
 static void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)
 {
 	i8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,
-		I8254_MODE1);
+		       I8254_MODE1);
 	/* Counter ct, 8254 mode 1, initial count not written. */
 }
 
@@ -2564,7 +2592,7 @@ static void pci230_cancel_ct(struct come
 static irqreturn_t pci230_interrupt(int irq, void *d)
 {
 	unsigned char status_int, valid_status_int;
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 	unsigned long irqflags;
 
@@ -2624,7 +2652,8 @@ static irqreturn_t pci230_interrupt(int 
 	return IRQ_HANDLED;
 }
 
-static void pci230_handle_ao_nofifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_handle_ao_nofifo(struct comedi_device *dev,
+				    struct comedi_subdevice *s)
 {
 	short data;
 	int i, ret;
@@ -2661,7 +2690,8 @@ static void pci230_handle_ao_nofifo(stru
 
 /* Loads DAC FIFO (if using it) from buffer. */
 /* Returns 0 if AO finished due to completion or error, 1 if still going. */
-static int pci230_handle_ao_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci230_handle_ao_fifo(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -2699,7 +2729,7 @@ static int pci230_handle_ao_fifo(struct 
 		 * (otherwise there will be loads of "DAC FIFO not half full"
 		 * interrupts). */
 		if ((num_scans == 0)
-			&& ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
+		    && ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {
 			comedi_error(dev, "AO buffer underrun");
 			events |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;
 		}
@@ -2728,7 +2758,7 @@ static int pci230_handle_ao_fifo(struct 
 
 				comedi_buf_get(async, &datum);
 				pci230_ao_write_fifo(dev, datum,
-					CR_CHAN(cmd->chanlist[i]));
+						     CR_CHAN(cmd->chanlist[i]));
 			}
 		}
 		events |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;
@@ -2739,10 +2769,11 @@ static int pci230_handle_ao_fifo(struct 
 				 * to FIFO.  Set FIFO interrupt trigger level
 				 * to 'empty'. */
 				devpriv->daccon = (devpriv->daccon
-					& ~PCI230P2_DAC_INT_FIFO_MASK)
-					| PCI230P2_DAC_INT_FIFO_EMPTY;
+						   &
+						   ~PCI230P2_DAC_INT_FIFO_MASK)
+				    | PCI230P2_DAC_INT_FIFO_EMPTY;
 				outw(devpriv->daccon,
-					dev->iobase + PCI230_DACCON);
+				     dev->iobase + PCI230_DACCON);
 			}
 		}
 		/* Check if FIFO underrun occurred while writing to FIFO. */
@@ -2753,7 +2784,7 @@ static int pci230_handle_ao_fifo(struct 
 		}
 	}
 	if ((events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
-		!= 0) {
+	    != 0) {
 		/* Stopping AO due to completion or error. */
 		pci230_ao_stop(dev, s);
 		running = 0;
@@ -2764,7 +2795,8 @@ static int pci230_handle_ao_fifo(struct 
 	return running;
 }
 
-static void pci230_handle_ai(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_handle_ai(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	unsigned int events = 0;
 	unsigned int status_fifo;
@@ -2780,11 +2812,11 @@ static void pci230_handle_ai(struct come
 	} else if (devpriv->ai_scan_count == 0) {
 		todo = 0;
 	} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL)
-		|| (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
+		   || (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {
 		todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 	} else {
 		todo = (devpriv->ai_scan_count * scanlen)
-			- devpriv->ai_scan_pos;
+		    - devpriv->ai_scan_pos;
 		if (todo > PCI230_ADC_FIFOLEVEL_HALFFULL) {
 			todo = PCI230_ADC_FIFOLEVEL_HALFFULL;
 		}
@@ -2817,7 +2849,7 @@ static void pci230_handle_ai(struct come
 				if (devpriv->hwver > 0) {
 					/* Read PCI230+/260+ ADC FIFO level. */
 					fifoamount = inw(dev->iobase
-						+ PCI230P_ADCFFLEV);
+							 + PCI230P_ADCFFLEV);
 					if (fifoamount == 0) {
 						/* Shouldn't happen. */
 						break;
@@ -2854,7 +2886,7 @@ static void pci230_handle_ai(struct come
 	async->events |= events;
 
 	if ((async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-				COMEDI_CB_OVERFLOW)) != 0) {
+			      COMEDI_CB_OVERFLOW)) != 0) {
 		/* disable hardware conversions */
 		pci230_ai_stop(dev, s);
 	} else {
@@ -2863,7 +2895,8 @@ static void pci230_handle_ai(struct come
 	}
 }
 
-static void pci230_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_ao_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	unsigned char intsrc;
@@ -2910,21 +2943,23 @@ static void pci230_ao_stop(struct comedi
 		 * disable FIFO. */
 		devpriv->daccon &= PCI230_DAC_OR_MASK;
 		outw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET
-			| PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
-			dev->iobase + PCI230_DACCON);
+		     | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,
+		     dev->iobase + PCI230_DACCON);
 	}
 
 	/* Release resources. */
 	put_all_resources(dev, OWNER_AOCMD);
 }
 
-static int pci230_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci230_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	pci230_ao_stop(dev, s);
 	return 0;
 }
 
-static void pci230_ai_stop(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci230_ai_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long irqflags;
 	struct comedi_cmd *cmd;
@@ -2964,15 +2999,17 @@ static void pci230_ai_stop(struct comedi
 	/* Reset FIFO, disable FIFO and set start conversion source to none.
 	 * Keep se/diff and bip/uni settings */
 	devpriv->adccon = (devpriv->adccon & (PCI230_ADC_IR_MASK
-			| PCI230_ADC_IM_MASK)) | PCI230_ADC_TRIG_NONE;
+					      | PCI230_ADC_IM_MASK)) |
+	    PCI230_ADC_TRIG_NONE;
 	outw(devpriv->adccon | PCI230_ADC_FIFO_RESET,
-		dev->iobase + PCI230_ADCCON);
+	     dev->iobase + PCI230_ADCCON);
 
 	/* Release resources. */
 	put_all_resources(dev, OWNER_AICMD);
 }
 
-static int pci230_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci230_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	pci230_ai_stop(dev, s);
 	return 0;
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -48,13 +48,14 @@
 #include <asm/system.h>
 
 static int postconfig(struct comedi_device *dev);
-static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static void *comedi_recognize(struct comedi_driver * driv, const char *name);
+static int insn_rw_emulate_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static void *comedi_recognize(struct comedi_driver *driv, const char *name);
 static void comedi_report_boards(struct comedi_driver *driv);
 static int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s);
 int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size);
+		     unsigned long new_size);
 
 struct comedi_driver *comedi_drivers;
 
@@ -123,7 +124,8 @@ int comedi_device_attach(struct comedi_d
 
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
-			printk("comedi: failed to increment module count, skipping\n");
+			printk
+			    ("comedi: failed to increment module count, skipping\n");
 			continue;
 		}
 		if (driv->num_names) {
@@ -195,16 +197,20 @@ int comedi_driver_unregister(struct come
 
 	/* check for devices using this driver */
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
-		struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(i);
+		struct comedi_device_file_info *dev_file_info =
+		    comedi_get_device_file_info(i);
 		struct comedi_device *dev;
 
-		if (dev_file_info == NULL) continue;
+		if (dev_file_info == NULL)
+			continue;
 		dev = dev_file_info->device;
 
 		mutex_lock(&dev->mutex);
 		if (dev->attached && dev->driver == driver) {
 			if (dev->use_count)
-				printk("BUG! detaching device with use_count=%d\n", dev->use_count);
+				printk
+				    ("BUG! detaching device with use_count=%d\n",
+				     dev->use_count);
 			comedi_device_detach(dev);
 		}
 		mutex_unlock(&dev->mutex);
@@ -242,10 +248,11 @@ static int postconfig(struct comedi_devi
 
 		if (s->do_cmd) {
 			BUG_ON((s->subdev_flags & (SDF_CMD_READ |
-				SDF_CMD_WRITE)) == 0);
+						   SDF_CMD_WRITE)) == 0);
 			BUG_ON(!s->do_cmdtest);
 
-			async = kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
+			async =
+			    kzalloc(sizeof(struct comedi_async), GFP_KERNEL);
 			if (async == NULL) {
 				printk("failed to allocate async struct\n");
 				return -ENOMEM;
@@ -298,7 +305,7 @@ static int postconfig(struct comedi_devi
 }
 
 /*  generic recognize function for drivers that register their supported board names */
-void *comedi_recognize(struct comedi_driver * driv, const char *name)
+void *comedi_recognize(struct comedi_driver *driv, const char *name)
 {
 	unsigned i;
 	const char *const *name_ptr = driv->board_name;
@@ -306,8 +313,8 @@ void *comedi_recognize(struct comedi_dri
 		if (strcmp(*name_ptr, name) == 0)
 			return (void *)name_ptr;
 		name_ptr =
-			(const char *const *)((const char *)name_ptr +
-			driv->offset);
+		    (const char *const *)((const char *)name_ptr +
+					  driv->offset);
 	}
 
 	return NULL;
@@ -319,7 +326,7 @@ void comedi_report_boards(struct comedi_
 	const char *const *name_ptr;
 
 	printk("comedi: valid board names for %s driver are:\n",
-		driv->driver_name);
+	       driv->driver_name);
 
 	name_ptr = driv->board_name;
 	for (i = 0; i < driv->num_names; i++) {
@@ -337,13 +344,14 @@ static int poll_invalid(struct comedi_de
 }
 
 int insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+	       struct comedi_insn *insn, unsigned int *data)
 {
 	return -EINVAL;
 }
 
-static int insn_rw_emulate_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int insn_rw_emulate_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	struct comedi_insn new_insn;
 	int ret;
@@ -351,7 +359,7 @@ static int insn_rw_emulate_bits(struct c
 
 	unsigned chan = CR_CHAN(insn->chanspec);
 	const unsigned base_bitfield_channel =
-		(chan < channels_per_bitfield) ? 0 : chan;
+	    (chan < channels_per_bitfield) ? 0 : chan;
 	unsigned int new_data[2];
 	memset(new_data, 0, sizeof(new_data));
 	memset(&new_insn, 0, sizeof(new_insn));
@@ -379,7 +387,7 @@ static int insn_rw_emulate_bits(struct c
 	return 1;
 }
 
-static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
+static inline unsigned long uvirt_to_kva(pgd_t * pgd, unsigned long adr)
 {
 	unsigned long ret = 0UL;
 	pmd_t *pmd;
@@ -394,7 +402,7 @@ static inline unsigned long uvirt_to_kva
 			pte = *ptep;
 			if (pte_present(pte)) {
 				ret = (unsigned long)
-					page_address(pte_page(pte));
+				    page_address(pte_page(pte));
 				ret |= (adr & (PAGE_SIZE - 1));
 			}
 		}
@@ -413,7 +421,7 @@ static inline unsigned long kvirt_to_kva
 }
 
 int comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size)
+		     unsigned long new_size)
 {
 	struct comedi_async *async = s->async;
 
@@ -434,18 +442,22 @@ int comedi_buf_alloc(struct comedi_devic
 		unsigned i;
 		for (i = 0; i < async->n_buf_pages; ++i) {
 			if (async->buf_page_list[i].virt_addr) {
-				mem_map_unreserve(virt_to_page(async->
-						buf_page_list[i].virt_addr));
+				mem_map_unreserve(virt_to_page
+						  (async->buf_page_list[i].
+						   virt_addr));
 				if (s->async_dma_dir != DMA_NONE) {
 					dma_free_coherent(dev->hw_dev,
-						PAGE_SIZE,
-						async->buf_page_list[i].
-						virt_addr,
-						async->buf_page_list[i].
-						dma_addr);
+							  PAGE_SIZE,
+							  async->
+							  buf_page_list
+							  [i].virt_addr,
+							  async->
+							  buf_page_list
+							  [i].dma_addr);
 				} else {
-					free_page((unsigned long)async->
-						buf_page_list[i].virt_addr);
+					free_page((unsigned long)
+						  async->buf_page_list[i].
+						  virt_addr);
 				}
 			}
 		}
@@ -460,40 +472,42 @@ int comedi_buf_alloc(struct comedi_devic
 		struct page **pages = NULL;
 
 		async->buf_page_list =
-			vmalloc(sizeof(struct comedi_buf_page) * n_pages);
+		    vmalloc(sizeof(struct comedi_buf_page) * n_pages);
 		if (async->buf_page_list) {
 			memset(async->buf_page_list, 0,
-				sizeof(struct comedi_buf_page) * n_pages);
+			       sizeof(struct comedi_buf_page) * n_pages);
 			pages = vmalloc(sizeof(struct page *) * n_pages);
 		}
 		if (pages) {
 			for (i = 0; i < n_pages; i++) {
 				if (s->async_dma_dir != DMA_NONE) {
 					async->buf_page_list[i].virt_addr =
-						dma_alloc_coherent(dev->hw_dev,
-						PAGE_SIZE,
-						&async->buf_page_list[i].
-						dma_addr,
-						GFP_KERNEL | __GFP_COMP);
+					    dma_alloc_coherent(dev->hw_dev,
+							       PAGE_SIZE,
+							       &async->
+							       buf_page_list
+							       [i].dma_addr,
+							       GFP_KERNEL |
+							       __GFP_COMP);
 				} else {
 					async->buf_page_list[i].virt_addr =
-						(void *)
-						get_zeroed_page(GFP_KERNEL);
+					    (void *)
+					    get_zeroed_page(GFP_KERNEL);
 				}
 				if (async->buf_page_list[i].virt_addr == NULL) {
 					break;
 				}
-				mem_map_reserve(virt_to_page(async->
-						buf_page_list[i].virt_addr));
+				mem_map_reserve(virt_to_page
+						(async->buf_page_list[i].
+						 virt_addr));
 				pages[i] =
-					virt_to_page(async->buf_page_list[i].
-					virt_addr);
+				    virt_to_page(async->
+						 buf_page_list[i].virt_addr);
 			}
 		}
 		if (i == n_pages) {
 			async->prealloc_buf =
-				vmap(pages, n_pages, VM_MAP,
-				PAGE_KERNEL_NOCACHE);
+			    vmap(pages, n_pages, VM_MAP, PAGE_KERNEL_NOCACHE);
 		}
 		if (pages) {
 			vfree(pages);
@@ -503,23 +517,25 @@ int comedi_buf_alloc(struct comedi_devic
 			if (async->buf_page_list) {
 				for (i = 0; i < n_pages; i++) {
 					if (async->buf_page_list[i].virt_addr ==
-						NULL) {
+					    NULL) {
 						break;
 					}
-					mem_map_unreserve(virt_to_page(async->
-							buf_page_list[i].
-							virt_addr));
+					mem_map_unreserve(virt_to_page
+							  (async->buf_page_list
+							   [i].virt_addr));
 					if (s->async_dma_dir != DMA_NONE) {
 						dma_free_coherent(dev->hw_dev,
-							PAGE_SIZE,
-							async->buf_page_list[i].
-							virt_addr,
-							async->buf_page_list[i].
-							dma_addr);
+								  PAGE_SIZE,
+								  async->
+								  buf_page_list
+								  [i].virt_addr,
+								  async->
+								  buf_page_list
+								  [i].dma_addr);
 					} else {
-						free_page((unsigned long)async->
-							buf_page_list[i].
-							virt_addr);
+						free_page((unsigned long)
+							  async->buf_page_list
+							  [i].virt_addr);
 					}
 				}
 				vfree(async->buf_page_list);
@@ -536,7 +552,8 @@ int comedi_buf_alloc(struct comedi_devic
 
 /* munging is applied to data by core as it passes between user
  * and kernel space */
-unsigned int comedi_buf_munge(struct comedi_async *async, unsigned int num_bytes)
+unsigned int comedi_buf_munge(struct comedi_async *async,
+			      unsigned int num_bytes)
 {
 	struct comedi_subdevice *s = async->subdevice;
 	unsigned int count = 0;
@@ -555,15 +572,15 @@ unsigned int comedi_buf_munge(struct com
 		block_size = num_bytes - count;
 		if (block_size < 0) {
 			printk("%s: %s: bug! block_size is negative\n",
-				__FILE__, __func__);
+			       __FILE__, __func__);
 			break;
 		}
 		if ((int)(async->munge_ptr + block_size -
-				async->prealloc_bufsz) > 0)
+			  async->prealloc_bufsz) > 0)
 			block_size = async->prealloc_bufsz - async->munge_ptr;
 
 		s->munge(s->device, s, async->prealloc_buf + async->munge_ptr,
-			block_size, async->munge_chan);
+			 block_size, async->munge_chan);
 
 		smp_wmb();	/* barrier insures data is munged in buffer before munge_count is incremented */
 
@@ -598,7 +615,8 @@ unsigned int comedi_buf_write_n_availabl
 }
 
 /* allocates chunk for the writer from free buffer space */
-unsigned int comedi_buf_write_alloc(struct comedi_async *async, unsigned int nbytes)
+unsigned int comedi_buf_write_alloc(struct comedi_async *async,
+				    unsigned int nbytes)
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
 
@@ -614,7 +632,7 @@ unsigned int comedi_buf_write_alloc(stru
 
 /* allocates nothing unless it can completely fulfill the request */
 unsigned int comedi_buf_write_alloc_strict(struct comedi_async *async,
-	unsigned int nbytes)
+					   unsigned int nbytes)
 {
 	unsigned int free_end = async->buf_read_count + async->prealloc_bufsz;
 
@@ -632,8 +650,9 @@ unsigned int comedi_buf_write_alloc_stri
 unsigned comedi_buf_write_free(struct comedi_async *async, unsigned int nbytes)
 {
 	if ((int)(async->buf_write_count + nbytes -
-			async->buf_write_alloc_count) > 0) {
-		printk("comedi: attempted to write-free more bytes than have been write-allocated.\n");
+		  async->buf_write_alloc_count) > 0) {
+		printk
+		    ("comedi: attempted to write-free more bytes than have been write-allocated.\n");
 		nbytes = async->buf_write_alloc_count - async->buf_write_count;
 	}
 	async->buf_write_count += nbytes;
@@ -649,7 +668,7 @@ unsigned comedi_buf_write_free(struct co
 unsigned comedi_buf_read_alloc(struct comedi_async *async, unsigned nbytes)
 {
 	if ((int)(async->buf_read_alloc_count + nbytes - async->munge_count) >
-		0) {
+	    0) {
 		nbytes = async->munge_count - async->buf_read_alloc_count;
 	}
 	async->buf_read_alloc_count += nbytes;
@@ -665,8 +684,9 @@ unsigned comedi_buf_read_free(struct com
 	/*  barrier insures data has been read out of buffer before read count is incremented */
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
-			async->buf_read_alloc_count) > 0) {
-		printk("comedi: attempted to read-free more bytes than have been read-allocated.\n");
+		  async->buf_read_alloc_count) > 0) {
+		printk
+		    ("comedi: attempted to read-free more bytes than have been read-allocated.\n");
 		nbytes = async->buf_read_alloc_count - async->buf_read_count;
 	}
 	async->buf_read_count += nbytes;
@@ -676,7 +696,7 @@ unsigned comedi_buf_read_free(struct com
 }
 
 void comedi_buf_memcpy_to(struct comedi_async *async, unsigned int offset,
-	const void *data, unsigned int num_bytes)
+			  const void *data, unsigned int num_bytes)
 {
 	unsigned int write_ptr = async->buf_write_ptr + offset;
 
@@ -701,7 +721,7 @@ void comedi_buf_memcpy_to(struct comedi_
 }
 
 void comedi_buf_memcpy_from(struct comedi_async *async, unsigned int offset,
-	void *dest, unsigned int nbytes)
+			    void *dest, unsigned int nbytes)
 {
 	void *src;
 	unsigned int read_ptr = async->buf_read_ptr + offset;
@@ -748,7 +768,7 @@ int comedi_buf_get(struct comedi_async *
 	if (n < sizeof(short))
 		return 0;
 	comedi_buf_read_alloc(async, sizeof(short));
-	*x = *(short *) (async->prealloc_buf + async->buf_read_ptr);
+	*x = *(short *)(async->prealloc_buf + async->buf_read_ptr);
 	comedi_buf_read_free(async, sizeof(short));
 	return 1;
 }
@@ -761,7 +781,7 @@ int comedi_buf_put(struct comedi_async *
 		async->events |= COMEDI_CB_ERROR;
 		return 0;
 	}
-	*(short *) (async->prealloc_buf + async->buf_write_ptr) = x;
+	*(short *)(async->prealloc_buf + async->buf_write_ptr) = x;
 	comedi_buf_write_free(async, sizeof(short));
 	return 1;
 }
@@ -785,7 +805,8 @@ void comedi_reset_async_buf(struct comed
 	async->events = 0;
 }
 
-int comedi_auto_config(struct device *hardware_device, const char *board_name, const int *options, unsigned num_options)
+int comedi_auto_config(struct device *hardware_device, const char *board_name,
+		       const int *options, unsigned num_options)
 {
 	struct comedi_devconfig it;
 	int minor;
@@ -799,7 +820,8 @@ int comedi_auto_config(struct device *ha
 	}
 
 	minor = comedi_alloc_board_minor(hardware_device);
-	if (minor < 0) return minor;
+	if (minor < 0)
+		return minor;
 
 	private_data = kmalloc(sizeof(unsigned), GFP_KERNEL);
 	if (private_data == NULL) {
@@ -822,8 +844,7 @@ int comedi_auto_config(struct device *ha
 	mutex_unlock(&dev_file_info->device->mutex);
 
 cleanup:
-	if (retval < 0)
-	{
+	if (retval < 0) {
 		kfree(private_data);
 		comedi_free_board_minor(minor);
 	}
@@ -833,7 +854,8 @@ cleanup:
 void comedi_auto_unconfig(struct device *hardware_device)
 {
 	unsigned *minor = (unsigned *)dev_get_drvdata(hardware_device);
-	if (minor == NULL) return;
+	if (minor == NULL)
+		return;
 
 	BUG_ON(*minor >= COMEDI_NUM_BOARD_MINORS);
 
@@ -860,8 +882,7 @@ void comedi_pci_auto_unconfig(struct pci
 	comedi_auto_unconfig(&pcidev->dev);
 }
 
-int comedi_usb_auto_config(struct usb_device *usbdev,
-	const char *board_name)
+int comedi_usb_auto_config(struct usb_device *usbdev, const char *board_name)
 {
 	BUG_ON(usbdev == NULL);
 	return comedi_auto_config(&usbdev->dev, board_name, NULL, 0);
--- a/drivers/staging/comedi/drivers/c6xdigio.c
+++ b/drivers/staging/comedi/drivers/c6xdigio.c
@@ -97,7 +97,8 @@ union encvaluetype {
 
 #define C6XDIGIO_TIME_OUT 20
 
-static int c6xdigio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int c6xdigio_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it);
 static int c6xdigio_detach(struct comedi_device *dev);
 struct comedi_driver driver_c6xdigio = {
 	.driver_name = "c6xdigio",
@@ -114,28 +115,28 @@ static void C6X_pwmInit(unsigned long ba
 
 	WriteByteToHwPort(baseAddr, 0x70);
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0)
-		&& (timeout < C6XDIGIO_TIME_OUT)) {
+	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
 	}
 
 	WriteByteToHwPort(baseAddr, 0x74);
 	timeout = 0;
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x80)
-		&& (timeout < C6XDIGIO_TIME_OUT)) {
+	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
 	}
 
 	WriteByteToHwPort(baseAddr, 0x70);
 	timeout = 0;
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x0)
-		&& (timeout < C6XDIGIO_TIME_OUT)) {
+	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
 	}
 
 	WriteByteToHwPort(baseAddr, 0x0);
 	timeout = 0;
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x80)
-		&& (timeout < C6XDIGIO_TIME_OUT)) {
+	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
 	}
 
@@ -315,38 +316,41 @@ static void C6X_encResetAll(unsigned lon
 
 	WriteByteToHwPort(baseAddr, 0x68);
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0)
-		&& (timeout < C6XDIGIO_TIME_OUT)) {
+	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
 	}
 	WriteByteToHwPort(baseAddr, 0x6C);
 	timeout = 0;
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x80)
-		&& (timeout < C6XDIGIO_TIME_OUT)) {
+	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
 	}
 	WriteByteToHwPort(baseAddr, 0x68);
 	timeout = 0;
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x0)
-		&& (timeout < C6XDIGIO_TIME_OUT)) {
+	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
 	}
 	WriteByteToHwPort(baseAddr, 0x0);
 	timeout = 0;
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x80)
-		&& (timeout < C6XDIGIO_TIME_OUT)) {
+	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
 	}
 }
 
 static int c6xdigio_pwmo_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	printk("c6xdigio_pwmo_insn_read %x\n", insn->n);
 	return insn->n;
 }
 
 static int c6xdigio_pwmo_insn_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -375,12 +379,13 @@ static int c6xdigio_pwmo_insn_write(stru
 /* { */
 /* int i; */
 /* int chan = CR_CHAN(insn->chanspec); */
-/*  *//* C6X_encResetAll( dev->iobase ); */
-/*  *//* return insn->n; */
+      /*  *//* C6X_encResetAll( dev->iobase ); */
+      /*  *//* return insn->n; */
 /* } */
 
 static int c6xdigio_ei_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	/*   printk("c6xdigio_ei__insn_read %x\n", insn->n); */
 	int n;
@@ -415,9 +420,9 @@ static void board_init(struct comedi_dev
 
 static const struct pnp_device_id c6xdigio_pnp_tbl[] = {
 	/* Standard LPT Printer Port */
-	{.id = "PNP0400", .driver_data = 0},
+	{.id = "PNP0400",.driver_data = 0},
 	/* ECP Printer Port */
-	{.id = "PNP0401", .driver_data = 0},
+	{.id = "PNP0401",.driver_data = 0},
 	{}
 };
 
@@ -426,7 +431,8 @@ static struct pnp_driver c6xdigio_pnp_dr
 	.id_table = c6xdigio_pnp_tbl,
 };
 
-static int c6xdigio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int c6xdigio_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it)
 {
 	int result = 0;
 	unsigned long iobase;
@@ -478,7 +484,7 @@ static int c6xdigio_attach(struct comedi
 	s->range_table = &range_unknown;
 
 	/*           s = dev->subdevices + 2; */
-	      /* pwm output subdevice */
+	/* pwm output subdevice */
 	/*       s->type = COMEDI_SUBD_COUNTER;  // Not sure what to put here */
 	/*       s->subdev_flags = SDF_WRITEABLE; */
 	/*       s->n_chan = 1; */
--- a/drivers/staging/comedi/drivers/cb_das16_cs.c
+++ b/drivers/staging/comedi/drivers/cb_das16_cs.c
@@ -62,20 +62,20 @@ struct das16cs_board {
 };
 static const struct das16cs_board das16cs_boards[] = {
 	{
-	.device_id = 0x0000,/* unknown */
-	.name = "PC-CARD DAS16/16",
-	.n_ao_chans = 0,
-		},
+	 .device_id = 0x0000,	/* unknown */
+	 .name = "PC-CARD DAS16/16",
+	 .n_ao_chans = 0,
+	 },
 	{
-	.device_id = 0x0039,
-	.name = "PC-CARD DAS16/16-AO",
-	.n_ao_chans = 2,
-		},
+	 .device_id = 0x0039,
+	 .name = "PC-CARD DAS16/16-AO",
+	 .n_ao_chans = 2,
+	 },
 	{
-	.device_id = 0x4009,
-	.name = "PCM-DAS16s/16",
-	.n_ao_chans = 0,
-		},
+	 .device_id = 0x4009,
+	 .name = "PCM-DAS16s/16",
+	 .n_ao_chans = 0,
+	 },
 };
 
 #define n_boards (sizeof(das16cs_boards)/sizeof(das16cs_boards[0]))
@@ -90,7 +90,8 @@ struct das16cs_private {
 };
 #define devpriv ((struct das16cs_private *)dev->private)
 
-static int das16cs_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das16cs_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int das16cs_detach(struct comedi_device *dev);
 static struct comedi_driver driver_das16cs = {
 	.driver_name = "cb_das16_cs",
@@ -102,31 +103,43 @@ static struct comedi_driver driver_das16
 static struct pcmcia_device *cur_dev = NULL;
 
 static const struct comedi_lrange das16cs_ai_range = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-	}
+							   RANGE(-10, 10),
+							   RANGE(-5, 5),
+							   RANGE(-2.5, 2.5),
+							   RANGE(-1.25, 1.25),
+							   }
 };
 
 static irqreturn_t das16cs_interrupt(int irq, void *d);
-static int das16cs_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das16cs_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int das16cs_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int das16cs_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das16cs_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das16cs_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das16cs_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das16cs_timer_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das16cs_timer_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int das16cs_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das16cs_ai_cmd(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
+static int das16cs_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd);
+static int das16cs_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das16cs_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das16cs_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int das16cs_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
+static int das16cs_timer_insn_read(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
+static int das16cs_timer_insn_config(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data);
 
 static int get_prodid(struct comedi_device *dev, struct pcmcia_device *link)
 {
@@ -140,15 +153,15 @@ static int get_prodid(struct comedi_devi
 	tuple.DesiredTuple = CISTPL_MANFID;
 	tuple.Attributes = TUPLE_RETURN_COMMON;
 	if ((pcmcia_get_first_tuple(link, &tuple) == 0) &&
-		(pcmcia_get_tuple_data(link, &tuple) == 0)) {
+	    (pcmcia_get_tuple_data(link, &tuple) == 0)) {
 		prodid = le16_to_cpu(buf[1]);
 	}
 
 	return prodid;
 }
 
-static const struct das16cs_board *das16cs_probe(struct comedi_device * dev,
-	struct pcmcia_device *link)
+static const struct das16cs_board *das16cs_probe(struct comedi_device *dev,
+						 struct pcmcia_device *link)
 {
 	int id;
 	int i;
@@ -166,7 +179,8 @@ static const struct das16cs_board *das16
 	return NULL;
 }
 
-static int das16cs_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int das16cs_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct pcmcia_device *link;
 	struct comedi_subdevice *s;
@@ -287,8 +301,9 @@ static irqreturn_t das16cs_interrupt(int
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int das16cs_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16cs_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int to;
@@ -334,8 +349,9 @@ static int das16cs_ai_cmd(struct comedi_
 	return -EINVAL;
 }
 
-static int das16cs_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int das16cs_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -381,7 +397,7 @@ static int das16cs_ai_cmdtest(struct com
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
@@ -463,7 +479,8 @@ static int das16cs_ai_cmdtest(struct com
 
 		tmp = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer(100, &div1, &div2,
-			&cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);
+					  &cmd->scan_begin_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -472,14 +489,15 @@ static int das16cs_ai_cmdtest(struct com
 
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(100, &div1, &div2,
-			&cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);
+					  &cmd->scan_begin_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->scan_end_arg) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -490,8 +508,9 @@ static int das16cs_ai_cmdtest(struct com
 	return 0;
 }
 
-static int das16cs_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16cs_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -536,8 +555,9 @@ static int das16cs_ao_winsn(struct comed
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int das16cs_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16cs_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -553,8 +573,9 @@ static int das16cs_ao_rinsn(struct comed
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int das16cs_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16cs_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -573,8 +594,9 @@ static int das16cs_dio_insn_bits(struct 
 	return 2;
 }
 
-static int das16cs_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16cs_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int bits;
@@ -593,8 +615,7 @@ static int das16cs_dio_insn_config(struc
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -611,14 +632,17 @@ static int das16cs_dio_insn_config(struc
 	return insn->n;
 }
 
-static int das16cs_timer_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16cs_timer_insn_read(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	return -EINVAL;
 }
 
-static int das16cs_timer_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16cs_timer_insn_config(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 	return -EINVAL;
 }
@@ -650,7 +674,7 @@ static int pc_debug = PCMCIA_DEBUG;
 module_param(pc_debug, int, 0644);
 #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args)
 static char *version =
-	"cb_das16_cs.c pcmcia code (David Schleef), modified from dummy_cs.c 1.31 2001/08/24 12:13:13 (David Hinds)";
+    "cb_das16_cs.c pcmcia code (David Schleef), modified from dummy_cs.c 1.31 2001/08/24 12:13:13 (David Hinds)";
 #else
 #define DEBUG(n, args...)
 #endif
@@ -739,7 +763,7 @@ static void das16cs_pcmcia_detach(struct
 	DEBUG(0, "das16cs_pcmcia_detach(0x%p)\n", link);
 
 	if (link->dev_node) {
-		((struct local_info_t *) link->priv)->stop = 1;
+		((struct local_info_t *)link->priv)->stop = 1;
 		das16cs_pcmcia_release(link);
 	}
 	/* This points to the parent struct local_info_t struct */
@@ -853,7 +877,7 @@ static void das16cs_pcmcia_config(struct
 		/* If we got this far, we're cool! */
 		break;
 
-	      next_entry:
+next_entry:
 		last_fn = GetNextTuple;
 
 		last_ret = pcmcia_get_next_tuple(link, &tuple);
@@ -893,20 +917,20 @@ static void das16cs_pcmcia_config(struct
 
 	/* Finally, report what we've done */
 	printk(KERN_INFO "%s: index 0x%02x",
-		dev->node.dev_name, link->conf.ConfigIndex);
+	       dev->node.dev_name, link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %u", link->irq.AssignedIRQ);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-			link->io.BasePort1 + link->io.NumPorts1 - 1);
+		       link->io.BasePort1 + link->io.NumPorts1 - 1);
 	if (link->io.NumPorts2)
 		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
-			link->io.BasePort2 + link->io.NumPorts2 - 1);
+		       link->io.BasePort2 + link->io.NumPorts2 - 1);
 	printk("\n");
 
 	return;
 
-      cs_failed:
+cs_failed:
 	cs_error(link, last_fn, last_ret);
 	das16cs_pcmcia_release(link);
 }				/* das16cs_pcmcia_config */
@@ -953,7 +977,7 @@ struct pcmcia_driver das16cs_driver = {
 	.id_table = das16cs_id_table,
 	.owner = THIS_MODULE,
 	.drv = {
-			.name = dev_info,
+		.name = dev_info,
 		},
 };
 
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -152,10 +152,12 @@ static inline unsigned int dac_convert_r
 {
 	return 0x70 + (2 * (channel & 0x1));
 }
+
 static inline unsigned int dac_lsb_4020_reg(unsigned int channel)
 {
 	return 0x70 + (4 * (channel & 0x1));
 }
+
 static inline unsigned int dac_msb_4020_reg(unsigned int channel)
 {
 	return 0x72 + (4 * (channel & 0x1));
@@ -269,10 +271,12 @@ static inline uint16_t adc_lo_chan_4020_
 {
 	return (channel & 0x3) << 8;
 };
+
 static inline uint16_t adc_hi_chan_4020_bits(unsigned int channel)
 {
 	return (channel & 0x3) << 10;
 };
+
 static inline uint16_t adc_mode_bits(unsigned int mode)
 {
 	return (mode & 0xf) << 12;
@@ -370,10 +374,12 @@ static inline unsigned int dma_chain_fla
 {
 	return (prepost_bits >> 6) & 0x3;
 }
+
 static inline unsigned int adc_upper_read_ptr_code(uint16_t prepost_bits)
 {
 	return (prepost_bits >> 12) & 0x3;
 }
+
 static inline unsigned int adc_upper_write_ptr_code(uint16_t prepost_bits)
 {
 	return (prepost_bits >> 14) & 0x3;
@@ -394,6 +400,7 @@ static inline uint8_t adc_src_4020_bits(
 {
 	return (source << 4) & ADC_SRC_4020_MASK;
 };
+
 static inline uint8_t attenuate_bit(unsigned int channel)
 {
 	/*  attenuate channel (+-5V input range) */
@@ -404,90 +411,91 @@ static inline uint8_t attenuate_bit(unsi
 static const struct comedi_lrange ai_ranges_64xx = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25)
+	 }
 };
 
 /* analog input ranges for 60xx boards */
 static const struct comedi_lrange ai_ranges_60xx = {
 	4,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.05),
+	 }
 };
 
 /* analog input ranges for 6030, etc boards */
 static const struct comedi_lrange ai_ranges_6030 = {
 	14,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.2),
-			BIP_RANGE(0.1),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2),
-			UNI_RANGE(1),
-			UNI_RANGE(0.5),
-			UNI_RANGE(0.2),
-			UNI_RANGE(0.1),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.2),
+	 BIP_RANGE(0.1),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.5),
+	 UNI_RANGE(0.2),
+	 UNI_RANGE(0.1),
+	 }
 };
 
 /* analog input ranges for 6052, etc boards */
 static const struct comedi_lrange ai_ranges_6052 = {
 	15,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.25),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.05),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2),
-			UNI_RANGE(1),
-			UNI_RANGE(0.5),
-			UNI_RANGE(0.2),
-			UNI_RANGE(0.1),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.25),
+	 BIP_RANGE(0.1),
+	 BIP_RANGE(0.05),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.5),
+	 UNI_RANGE(0.2),
+	 UNI_RANGE(0.1),
+	 }
 };
 
 /* analog input ranges for 4020 board */
 static const struct comedi_lrange ai_ranges_4020 = {
 	2,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(1),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(1),
+	 }
 };
 
 /* analog output ranges */
 static const struct comedi_lrange ao_ranges_64xx = {
 	4,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(10),
+	 }
 };
+
 static const int ao_range_code_64xx[] = {
 	0x0,
 	0x1,
@@ -498,9 +506,10 @@ static const int ao_range_code_64xx[] = 
 static const struct comedi_lrange ao_ranges_60xx = {
 	1,
 	{
-			BIP_RANGE(10),
-		}
+	 BIP_RANGE(10),
+	 }
 };
+
 static const int ao_range_code_60xx[] = {
 	0x0,
 };
@@ -508,10 +517,11 @@ static const int ao_range_code_60xx[] = 
 static const struct comedi_lrange ao_ranges_6030 = {
 	2,
 	{
-			BIP_RANGE(10),
-			UNI_RANGE(10),
-		}
+	 BIP_RANGE(10),
+	 UNI_RANGE(10),
+	 }
 };
+
 static const int ao_range_code_6030[] = {
 	0x0,
 	0x2,
@@ -520,10 +530,11 @@ static const int ao_range_code_6030[] = 
 static const struct comedi_lrange ao_ranges_4020 = {
 	2,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(10),
+	 }
 };
+
 static const int ao_range_code_4020[] = {
 	0x1,
 	0x0,
@@ -597,458 +608,478 @@ static const int bytes_in_sample = 2;
 
 static const struct pcidas64_board pcidas64_boards[] = {
 	{
-	.name = "pci-das6402/16",
-	.device_id = 0x1d,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das6402/12",	/*  XXX check */
-	.device_id = 0x1e,
-	.ai_se_chans = 64,
-	.ai_bits = 12,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m1/16",
-	.device_id = 0x35,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 1000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m2/16",
-	.device_id = 0x36,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 500,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m3/16",
-	.device_id = 0x37,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 333,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ao_range_table = &ao_ranges_64xx,
-	.ao_range_code = ao_range_code_64xx,
-	.ai_fifo = &ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-		.name = "pci-das6013",
-		.device_id = 0x78,
-		.ai_se_chans = 16,
-		.ai_bits = 16,
-		.ai_speed = 5000,
-		.ao_nchan = 0,
-		.ao_bits = 16,
-		.layout = LAYOUT_60XX,
-		.ai_range_table = &ai_ranges_60xx,
-		.ao_range_table = &ao_ranges_60xx,
-		.ao_range_code = ao_range_code_60xx,
-		.ai_fifo = &ai_fifo_60xx,
-		.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6014",
-	.device_id = 0x79,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6023",
-	.device_id = 0x5d,
-	.ai_se_chans = 16,
-	.ai_bits = 12,
-	.ai_speed = 5000,
-	.ao_nchan = 0,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das6025",
-	.device_id = 0x5e,
-	.ai_se_chans = 16,
-	.ai_bits = 12,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das6030",
-	.device_id = 0x5f,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 10000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6030,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6031",
-	.device_id = 0x60,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 10000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6030,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6032",
-	.device_id = 0x61,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 10000,
-	.ao_nchan = 0,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6033",
-	.device_id = 0x62,
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 10000,
-	.ao_nchan = 0,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6034",
-	.device_id = 0x63,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 0,
-	.ao_scan_speed = 0,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6035",
-	.device_id = 0x64,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6036",
-	.device_id = 0x6f,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 100000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_60xx,
-	.ao_range_table = &ao_ranges_60xx,
-	.ao_range_code = ao_range_code_60xx,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6040",
-	.device_id = 0x65,
-	.ai_se_chans = 16,
-	.ai_bits = 12,
-	.ai_speed = 2000,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 1000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6052,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6052",
-	.device_id = 0x66,
-	.ai_se_chans = 16,
-	.ai_bits = 16,
-	.ai_speed = 3333,
-	.ao_nchan = 2,
-	.ao_bits = 16,
-	.ao_scan_speed = 3333,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6052,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6070",
-	.device_id = 0x67,
-	.ai_se_chans = 16,
-	.ai_bits = 12,
-	.ai_speed = 800,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 1000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6052,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das6071",
-	.device_id = 0x68,
-	.ai_se_chans = 64,
-	.ai_bits = 12,
-	.ai_speed = 800,
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.ao_scan_speed = 1000,
-	.layout = LAYOUT_60XX,
-	.ai_range_table = &ai_ranges_6052,
-	.ao_range_table = &ao_ranges_6030,
-	.ao_range_code = ao_range_code_6030,
-	.ai_fifo = &ai_fifo_60xx,
-	.has_8255 = 0,
-		},
-	{
-	.name = "pci-das4020/12",
-	.device_id = 0x52,
-	.ai_se_chans = 4,
-	.ai_bits = 12,
-	.ai_speed = 50,
-	.ao_bits = 12,
-	.ao_nchan = 2,
-	.ao_scan_speed = 0,	/*  no hardware pacing on ao */
-	.layout = LAYOUT_4020,
-	.ai_range_table = &ai_ranges_4020,
-	.ao_range_table = &ao_ranges_4020,
-	.ao_range_code = ao_range_code_4020,
-	.ai_fifo = &ai_fifo_4020,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das6402/16",
+	 .device_id = 0x1d,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das6402/12",	/*  XXX check */
+	 .device_id = 0x1e,
+	 .ai_se_chans = 64,
+	 .ai_bits = 12,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m1/16",
+	 .device_id = 0x35,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 1000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m2/16",
+	 .device_id = 0x36,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 500,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m3/16",
+	 .device_id = 0x37,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 333,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ao_range_table = &ao_ranges_64xx,
+	 .ao_range_code = ao_range_code_64xx,
+	 .ai_fifo = &ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das6013",
+	 .device_id = 0x78,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .ao_bits = 16,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6014",
+	 .device_id = 0x79,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6023",
+	 .device_id = 0x5d,
+	 .ai_se_chans = 16,
+	 .ai_bits = 12,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das6025",
+	 .device_id = 0x5e,
+	 .ai_se_chans = 16,
+	 .ai_bits = 12,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das6030",
+	 .device_id = 0x5f,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6030,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6031",
+	 .device_id = 0x60,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6030,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6032",
+	 .device_id = 0x61,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,
+	 .ao_nchan = 0,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6033",
+	 .device_id = 0x62,
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,
+	 .ao_nchan = 0,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6034",
+	 .device_id = 0x63,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 0,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6035",
+	 .device_id = 0x64,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6036",
+	 .device_id = 0x6f,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 100000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_60xx,
+	 .ao_range_table = &ao_ranges_60xx,
+	 .ao_range_code = ao_range_code_60xx,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6040",
+	 .device_id = 0x65,
+	 .ai_se_chans = 16,
+	 .ai_bits = 12,
+	 .ai_speed = 2000,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 1000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6052,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6052",
+	 .device_id = 0x66,
+	 .ai_se_chans = 16,
+	 .ai_bits = 16,
+	 .ai_speed = 3333,
+	 .ao_nchan = 2,
+	 .ao_bits = 16,
+	 .ao_scan_speed = 3333,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6052,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6070",
+	 .device_id = 0x67,
+	 .ai_se_chans = 16,
+	 .ai_bits = 12,
+	 .ai_speed = 800,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 1000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6052,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das6071",
+	 .device_id = 0x68,
+	 .ai_se_chans = 64,
+	 .ai_bits = 12,
+	 .ai_speed = 800,
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .ao_scan_speed = 1000,
+	 .layout = LAYOUT_60XX,
+	 .ai_range_table = &ai_ranges_6052,
+	 .ao_range_table = &ao_ranges_6030,
+	 .ao_range_code = ao_range_code_6030,
+	 .ai_fifo = &ai_fifo_60xx,
+	 .has_8255 = 0,
+	 },
+	{
+	 .name = "pci-das4020/12",
+	 .device_id = 0x52,
+	 .ai_se_chans = 4,
+	 .ai_bits = 12,
+	 .ai_speed = 50,
+	 .ao_bits = 12,
+	 .ao_nchan = 2,
+	 .ao_scan_speed = 0,	/*  no hardware pacing on ao */
+	 .layout = LAYOUT_4020,
+	 .ai_range_table = &ai_ranges_4020,
+	 .ao_range_table = &ao_ranges_4020,
+	 .ao_range_code = ao_range_code_4020,
+	 .ai_fifo = &ai_fifo_4020,
+	 .has_8255 = 1,
+	 },
 #if 0
 	{
-	.name = "pci-das6402/16/jr",
-	.device_id = 0	/*  XXX, */
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 0,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m1/16/jr",
-	.device_id = 0	/*  XXX, */
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 1000,
-	.ao_nchan = 0,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m2/16/jr",
-	.device_id = 0	/*  XXX, */
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 500,
-	.ao_nchan = 0,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m3/16/jr",
-	.device_id = 0	/*  XXX, */
-	.ai_se_chans = 64,
-	.ai_bits = 16,
-	.ai_speed = 333,
-	.ao_nchan = 0,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m1/14",
-	.device_id = 0,	/*  XXX */
-	.ai_se_chans = 64,
-	.ai_bits = 14,
-	.ai_speed = 1000,
-	.ao_nchan = 2,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m2/14",
-	.device_id = 0,	/*  XXX */
-	.ai_se_chans = 64,
-	.ai_bits = 14,
-	.ai_speed = 500,
-	.ao_nchan = 2,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
-	{
-	.name = "pci-das64/m3/14",
-	.device_id = 0,	/*  XXX */
-	.ai_se_chans = 64,
-	.ai_bits = 14,
-	.ai_speed = 333,
-	.ao_nchan = 2,
-	.ao_scan_speed = 10000,
-	.layout = LAYOUT_64XX,
-	.ai_range_table = &ai_ranges_64xx,
-	.ai_fifo = ai_fifo_64xx,
-	.has_8255 = 1,
-		},
+	 .name = "pci-das6402/16/jr",
+	 .device_id = 0		/*  XXX, */
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m1/16/jr",
+	 .device_id = 0		/*  XXX, */
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 1000,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m2/16/jr",
+	 .device_id = 0		/*  XXX, */
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 500,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m3/16/jr",
+	 .device_id = 0		/*  XXX, */
+	 .ai_se_chans = 64,
+	 .ai_bits = 16,
+	 .ai_speed = 333,
+	 .ao_nchan = 0,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m1/14",
+	 .device_id = 0,	/*  XXX */
+	 .ai_se_chans = 64,
+	 .ai_bits = 14,
+	 .ai_speed = 1000,
+	 .ao_nchan = 2,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m2/14",
+	 .device_id = 0,	/*  XXX */
+	 .ai_se_chans = 64,
+	 .ai_bits = 14,
+	 .ai_speed = 500,
+	 .ao_nchan = 2,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
+	{
+	 .name = "pci-das64/m3/14",
+	 .device_id = 0,	/*  XXX */
+	 .ai_se_chans = 64,
+	 .ai_bits = 14,
+	 .ai_speed = 333,
+	 .ao_nchan = 2,
+	 .ao_scan_speed = 10000,
+	 .layout = LAYOUT_64XX,
+	 .ai_range_table = &ai_ranges_64xx,
+	 .ai_fifo = ai_fifo_64xx,
+	 .has_8255 = 1,
+	 },
 #endif
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pcidas64_pci_table) = {
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x001e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0035, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0036, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0037, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x005f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0061, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0062, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0063, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0064, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0066, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0067, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0068, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x006f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0078, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0079, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pcidas64_pci_table);
 
-static inline struct pcidas64_board *board(const struct comedi_device * dev)
+static inline struct pcidas64_board *board(const struct comedi_device *dev)
 {
-	return (struct pcidas64_board *) dev->board_ptr;
+	return (struct pcidas64_board *)dev->board_ptr;
 }
 
 static inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,
-	int use_differential)
+					      int use_differential)
 {
 	if ((board(dev)->layout == LAYOUT_64XX && !use_differential) ||
-		(board(dev)->layout == LAYOUT_60XX && use_differential))
+	    (board(dev)->layout == LAYOUT_60XX && use_differential))
 		return ADC_SE_DIFF_BIT;
 	else
 		return 0;
@@ -1107,11 +1138,10 @@ struct pcidas64_private {
 	short ao_bounce_buffer[DAC_FIFO_SIZE];
 };
 
-
 /* inline function that makes it easier to
  * access the private structure.
  */
-static inline struct pcidas64_private *priv(struct comedi_device * dev)
+static inline struct pcidas64_private *priv(struct comedi_device *dev)
 {
 	return dev->private;
 }
@@ -1132,76 +1162,86 @@ static struct comedi_driver driver_cb_pc
 };
 
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
+static int ao_readback_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+		      struct comedi_cmd *cmd);
 static int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *subdev,
-	unsigned int trig_num);
+static int ao_inttrig(struct comedi_device *dev,
+		      struct comedi_subdevice *subdev, unsigned int trig_num);
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+		      struct comedi_cmd *cmd);
 static irqreturn_t handle_interrupt(int irq, void *d);
 static int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int dio_callback(int dir, int port, int data, unsigned long arg);
 static int dio_callback_4020(int dir, int port, int data, unsigned long arg);
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
 static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dio_60xx_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
+static int dio_60xx_config_insn(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ad8402_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
+static int calib_read_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int calib_write_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int ad8402_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static void ad8402_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value);
-static int ad8402_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 unsigned int value);
+static int ad8402_write_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int eeprom_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 static unsigned int get_divisor(unsigned int ns, unsigned int flags);
 static void i2c_write(struct comedi_device *dev, unsigned int address,
-	const uint8_t *data, unsigned int length);
+		      const uint8_t * data, unsigned int length);
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value);
+			 unsigned int value);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-	uint8_t value);
+			     uint8_t value);
 /* static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b); */
-static int caldac_i2c_write(struct comedi_device *dev, unsigned int caldac_channel,
-	unsigned int value);
+static int caldac_i2c_write(struct comedi_device *dev,
+			    unsigned int caldac_channel, unsigned int value);
 static void abort_dma(struct comedi_device *dev, unsigned int channel);
 static void disable_plx_interrupts(struct comedi_device *dev);
-static int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples);
+static int set_ai_fifo_size(struct comedi_device *dev,
+			    unsigned int num_samples);
 static unsigned int ai_fifo_size(struct comedi_device *dev);
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
-	unsigned int num_entries);
+				      unsigned int num_entries);
 static void disable_ai_pacing(struct comedi_device *dev);
 static void disable_ai_interrupts(struct comedi_device *dev);
-static void enable_ai_interrupts(struct comedi_device *dev, const struct comedi_cmd *cmd);
+static void enable_ai_interrupts(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd);
 static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags);
-static void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd);
+static void load_ao_dma(struct comedi_device *dev,
+			const struct comedi_cmd *cmd);
 
 COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, pcidas64_pci_table);
 
 static unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,
-	unsigned int range_index)
+				       unsigned int range_index)
 {
 	const struct comedi_krange *range =
-		&board(dev)->ai_range_table->range[range_index];
+	    &board(dev)->ai_range_table->range[range_index];
 	unsigned int bits = 0;
 
 	switch (range->max) {
@@ -1242,7 +1282,7 @@ static unsigned int ai_range_bits_6xxx(c
 }
 
 static unsigned int hw_revision(const struct comedi_device *dev,
-	uint16_t hw_status_bits)
+				uint16_t hw_status_bits)
 {
 	if (board(dev)->layout == LAYOUT_4020)
 		return (hw_status_bits >> 13) & 0x7;
@@ -1250,8 +1290,9 @@ static unsigned int hw_revision(const st
 	return (hw_status_bits >> 12) & 0xf;
 }
 
-static void set_dac_range_bits(struct comedi_device *dev, volatile uint16_t *bits,
-	unsigned int channel, unsigned int range)
+static void set_dac_range_bits(struct comedi_device *dev,
+			       volatile uint16_t * bits, unsigned int channel,
+			       unsigned int range)
 {
 	unsigned int code = board(dev)->ao_range_code[range];
 
@@ -1276,38 +1317,38 @@ static void init_plx9080(struct comedi_d
 	void *plx_iobase = priv(dev)->plx9080_iobase;
 
 	priv(dev)->plx_control_bits =
-		readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);
+	    readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);
 
 	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
-		readl(plx_iobase + PLX_INTRCS_REG));
+		    readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
 	DEBUG_PRINT(" plx control reg 0x%x\n", priv(dev)->plx_control_bits);
 	DEBUG_PRINT(" plx mode/arbitration reg 0x%x\n",
-		readl(plx_iobase + PLX_MARB_REG));
+		    readl(plx_iobase + PLX_MARB_REG));
 	DEBUG_PRINT(" plx region0 reg 0x%x\n",
-		readl(plx_iobase + PLX_REGION0_REG));
+		    readl(plx_iobase + PLX_REGION0_REG));
 	DEBUG_PRINT(" plx region1 reg 0x%x\n",
-		readl(plx_iobase + PLX_REGION1_REG));
+		    readl(plx_iobase + PLX_REGION1_REG));
 
 	DEBUG_PRINT(" plx revision 0x%x\n",
-		readl(plx_iobase + PLX_REVISION_REG));
+		    readl(plx_iobase + PLX_REVISION_REG));
 	DEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_MODE_REG));
+		    readl(plx_iobase + PLX_DMA0_MODE_REG));
 	DEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",
-		readl(plx_iobase + PLX_DMA1_MODE_REG));
+		    readl(plx_iobase + PLX_DMA1_MODE_REG));
 	DEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
+		    readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
 	DEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
+		    readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
 	DEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
+		    readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
 	DEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
+		    readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
 	DEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",
-		readb(plx_iobase + PLX_DMA0_CS_REG));
+		    readb(plx_iobase + PLX_DMA0_CS_REG));
 	DEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
+		    readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
 	DEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));
 
 #ifdef __BIG_ENDIAN
@@ -1352,10 +1393,10 @@ static void init_plx9080(struct comedi_d
 
 	/*  enable interrupts on plx 9080 */
 	priv(dev)->plx_intcsr_bits |=
-		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
-		ICS_DMA0_E | ICS_DMA1_E;
+	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
+	    ICS_DMA0_E | ICS_DMA1_E;
 	writel(priv(dev)->plx_intcsr_bits,
-		priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	       priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 /* Allocate and initialize the subdevice structures.
@@ -1405,8 +1446,7 @@ static int setup_subdevices(struct comed
 	if (board(dev)->ao_nchan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags =
-			SDF_READABLE | SDF_WRITABLE | SDF_GROUND |
-			SDF_CMD_WRITE;
+		    SDF_READABLE | SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
 		s->n_chan = board(dev)->ao_nchan;
 		s->maxdata = (1 << board(dev)->ao_bits) - 1;
 		s->range_table = board(dev)->ao_range_table;
@@ -1452,14 +1492,14 @@ static int setup_subdevices(struct comed
 	if (board(dev)->has_8255) {
 		if (board(dev)->layout == LAYOUT_4020) {
 			dio_8255_iobase =
-				priv(dev)->main_iobase + I8255_4020_REG;
+			    priv(dev)->main_iobase + I8255_4020_REG;
 			subdev_8255_init(dev, s, dio_callback_4020,
-				(unsigned long)dio_8255_iobase);
+					 (unsigned long)dio_8255_iobase);
 		} else {
 			dio_8255_iobase =
-				priv(dev)->dio_counter_iobase + DIO_8255_OFFSET;
+			    priv(dev)->dio_counter_iobase + DIO_8255_OFFSET;
 			subdev_8255_init(dev, s, dio_callback,
-				(unsigned long)dio_8255_iobase);
+					 (unsigned long)dio_8255_iobase);
 		}
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
@@ -1527,7 +1567,7 @@ static void disable_plx_interrupts(struc
 {
 	priv(dev)->plx_intcsr_bits = 0;
 	writel(priv(dev)->plx_intcsr_bits,
-		priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	       priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 static void init_stc_registers(struct comedi_device *dev)
@@ -1541,7 +1581,7 @@ static void init_stc_registers(struct co
 	if (1)
 		priv(dev)->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
 	writew(priv(dev)->adc_control1_bits,
-		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
 
 	/*  6402/16 manual says this register must be initialized to 0xff? */
 	writew(0xff, priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
@@ -1551,7 +1591,7 @@ static void init_stc_registers(struct co
 		bits |= INTERNAL_CLOCK_4020_BITS;
 	priv(dev)->hw_config_bits |= bits;
 	writew(priv(dev)->hw_config_bits,
-		priv(dev)->main_iobase + HW_CONFIG_REG);
+	       priv(dev)->main_iobase + HW_CONFIG_REG);
 
 	writew(0, priv(dev)->main_iobase + DAQ_SYNC_REG);
 	writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
@@ -1561,13 +1601,13 @@ static void init_stc_registers(struct co
 	/*  set fifos to maximum size */
 	priv(dev)->fifo_size_bits |= DAC_FIFO_BITS;
 	set_ai_fifo_segment_length(dev,
-		board(dev)->ai_fifo->max_segment_length);
+				   board(dev)->ai_fifo->max_segment_length);
 
 	priv(dev)->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;
 	priv(dev)->intr_enable_bits =	/* EN_DAC_INTR_SRC_BIT | DAC_INTR_QEMPTY_BITS | */
-		EN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;
+	    EN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;
 	writew(priv(dev)->intr_enable_bits,
-		priv(dev)->main_iobase + INTR_ENABLE_REG);
+	       priv(dev)->main_iobase + INTR_ENABLE_REG);
 
 	disable_ai_pacing(dev);
 };
@@ -1579,8 +1619,8 @@ int alloc_and_init_dma_members(struct co
 	/*  alocate pci dma buffers */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)->ai_buffer[i] =
-			pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
-			&priv(dev)->ai_buffer_bus_addr[i]);
+		    pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
+					 &priv(dev)->ai_buffer_bus_addr[i]);
 		if (priv(dev)->ai_buffer[i] == NULL) {
 			return -ENOMEM;
 		}
@@ -1588,9 +1628,10 @@ int alloc_and_init_dma_members(struct co
 	for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 		if (ao_cmd_is_supported(board(dev))) {
 			priv(dev)->ao_buffer[i] =
-				pci_alloc_consistent(priv(dev)->hw_dev,
-				DMA_BUFFER_SIZE,
-				&priv(dev)->ao_buffer_bus_addr[i]);
+			    pci_alloc_consistent(priv(dev)->hw_dev,
+						 DMA_BUFFER_SIZE,
+						 &priv(dev)->
+						 ao_buffer_bus_addr[i]);
 			if (priv(dev)->ao_buffer[i] == NULL) {
 				return -ENOMEM;
 			}
@@ -1598,61 +1639,65 @@ int alloc_and_init_dma_members(struct co
 	}
 	/*  allocate dma descriptors */
 	priv(dev)->ai_dma_desc =
-		pci_alloc_consistent(priv(dev)->hw_dev,
-		sizeof(struct plx_dma_desc) * ai_dma_ring_count(board(dev)),
-		&priv(dev)->ai_dma_desc_bus_addr);
+	    pci_alloc_consistent(priv(dev)->hw_dev,
+				 sizeof(struct plx_dma_desc) *
+				 ai_dma_ring_count(board(dev)),
+				 &priv(dev)->ai_dma_desc_bus_addr);
 	if (priv(dev)->ai_dma_desc == NULL) {
 		return -ENOMEM;
 	}
 	DEBUG_PRINT("ai dma descriptors start at bus addr 0x%x\n",
-		priv(dev)->ai_dma_desc_bus_addr);
+		    priv(dev)->ai_dma_desc_bus_addr);
 	if (ao_cmd_is_supported(board(dev))) {
 		priv(dev)->ao_dma_desc =
-			pci_alloc_consistent(priv(dev)->hw_dev,
-			sizeof(struct plx_dma_desc) * AO_DMA_RING_COUNT,
-			&priv(dev)->ao_dma_desc_bus_addr);
+		    pci_alloc_consistent(priv(dev)->hw_dev,
+					 sizeof(struct plx_dma_desc) *
+					 AO_DMA_RING_COUNT,
+					 &priv(dev)->ao_dma_desc_bus_addr);
 		if (priv(dev)->ao_dma_desc == NULL) {
 			return -ENOMEM;
 		}
 		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",
-			priv(dev)->ao_dma_desc_bus_addr);
+			    priv(dev)->ao_dma_desc_bus_addr);
 	}
 	/*  initialize dma descriptors */
 	for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)->ai_dma_desc[i].pci_start_addr =
-			cpu_to_le32(priv(dev)->ai_buffer_bus_addr[i]);
+		    cpu_to_le32(priv(dev)->ai_buffer_bus_addr[i]);
 		if (board(dev)->layout == LAYOUT_4020)
 			priv(dev)->ai_dma_desc[i].local_start_addr =
-				cpu_to_le32(priv(dev)->local1_iobase +
-				ADC_FIFO_REG);
+			    cpu_to_le32(priv(dev)->local1_iobase +
+					ADC_FIFO_REG);
 		else
 			priv(dev)->ai_dma_desc[i].local_start_addr =
-				cpu_to_le32(priv(dev)->local0_iobase +
-				ADC_FIFO_REG);
+			    cpu_to_le32(priv(dev)->local0_iobase +
+					ADC_FIFO_REG);
 		priv(dev)->ai_dma_desc[i].transfer_size = cpu_to_le32(0);
 		priv(dev)->ai_dma_desc[i].next =
-			cpu_to_le32((priv(dev)->ai_dma_desc_bus_addr + ((i +
-						1) %
-					ai_dma_ring_count(board(dev))) *
-				sizeof(priv(dev)->
-					ai_dma_desc[0])) | PLX_DESC_IN_PCI_BIT |
-			PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI);
+		    cpu_to_le32((priv(dev)->ai_dma_desc_bus_addr + ((i +
+								     1) %
+								    ai_dma_ring_count
+								    (board
+								     (dev))) *
+				 sizeof(priv(dev)->ai_dma_desc[0])) |
+				PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
+				PLX_XFER_LOCAL_TO_PCI);
 	}
 	if (ao_cmd_is_supported(board(dev))) {
 		for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 			priv(dev)->ao_dma_desc[i].pci_start_addr =
-				cpu_to_le32(priv(dev)->ao_buffer_bus_addr[i]);
+			    cpu_to_le32(priv(dev)->ao_buffer_bus_addr[i]);
 			priv(dev)->ao_dma_desc[i].local_start_addr =
-				cpu_to_le32(priv(dev)->local0_iobase +
-				DAC_FIFO_REG);
+			    cpu_to_le32(priv(dev)->local0_iobase +
+					DAC_FIFO_REG);
 			priv(dev)->ao_dma_desc[i].transfer_size =
-				cpu_to_le32(0);
+			    cpu_to_le32(0);
 			priv(dev)->ao_dma_desc[i].next =
-				cpu_to_le32((priv(dev)->ao_dma_desc_bus_addr +
-					((i + 1) % (AO_DMA_RING_COUNT)) *
-					sizeof(priv(dev)->
-						ao_dma_desc[0])) |
-				PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
+			    cpu_to_le32((priv(dev)->ao_dma_desc_bus_addr +
+					 ((i + 1) % (AO_DMA_RING_COUNT)) *
+					 sizeof(priv(dev)->ao_dma_desc[0])) |
+					PLX_DESC_IN_PCI_BIT |
+					PLX_INTR_TERM_COUNT);
 		}
 	}
 	return 0;
@@ -1661,9 +1706,9 @@ int alloc_and_init_dma_members(struct co
 static inline void warn_external_queue(struct comedi_device *dev)
 {
 	comedi_error(dev,
-		"AO command and AI external channel queue cannot be used simultaneously.");
+		     "AO command and AI external channel queue cannot be used simultaneously.");
 	comedi_error(dev,
-		"Use internal AI channel queue (channels must be consecutive and use same range/aref)");
+		     "Use internal AI channel queue (channels must be consecutive and use same range/aref)");
 }
 
 /*
@@ -1690,8 +1735,8 @@ static int attach(struct comedi_device *
  */
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
@@ -1703,8 +1748,7 @@ static int attach(struct comedi_device *
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
@@ -1717,16 +1761,17 @@ static int attach(struct comedi_device *
 	}
 
 	if (dev->board_ptr == NULL) {
-		printk("No supported ComputerBoards/MeasurementComputing card found\n");
+		printk
+		    ("No supported ComputerBoards/MeasurementComputing card found\n");
 		return -EIO;
 	}
 
 	printk("Found %s on bus %i, slot %i\n", board(dev)->name,
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	if (comedi_pci_enable(pcidev, driver_cb_pcidas.driver_name)) {
 		printk(KERN_WARNING
-			" failed to enable PCI device and request regions\n");
+		       " failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 	pci_set_master(pcidev);
@@ -1735,23 +1780,25 @@ static int attach(struct comedi_device *
 	dev->board_name = board(dev)->name;
 
 	priv(dev)->plx9080_phys_iobase =
-		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
 	priv(dev)->main_phys_iobase =
-		pci_resource_start(pcidev, MAIN_BADDRINDEX);
+	    pci_resource_start(pcidev, MAIN_BADDRINDEX);
 	priv(dev)->dio_counter_phys_iobase =
-		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
+	    pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
 
 	/*  remap, won't work with 2.0 kernels but who cares */
 	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
-		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
-	priv(dev)->main_iobase = ioremap(priv(dev)->main_phys_iobase,
-		pci_resource_len(pcidev, MAIN_BADDRINDEX));
+					    pci_resource_len(pcidev,
+							     PLX9080_BADDRINDEX));
+	priv(dev)->main_iobase =
+	    ioremap(priv(dev)->main_phys_iobase,
+		    pci_resource_len(pcidev, MAIN_BADDRINDEX));
 	priv(dev)->dio_counter_iobase =
-		ioremap(priv(dev)->dio_counter_phys_iobase,
-		pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
+	    ioremap(priv(dev)->dio_counter_phys_iobase,
+		    pci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));
 
 	if (!priv(dev)->plx9080_iobase || !priv(dev)->main_iobase
-		|| !priv(dev)->dio_counter_iobase) {
+	    || !priv(dev)->dio_counter_iobase) {
 		printk(" failed to remap io memory\n");
 		return -ENOMEM;
 	}
@@ -1759,27 +1806,25 @@ static int attach(struct comedi_device *
 	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", priv(dev)->plx9080_iobase);
 	DEBUG_PRINT(" main remapped to 0x%p\n", priv(dev)->main_iobase);
 	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
-		priv(dev)->dio_counter_iobase);
+		    priv(dev)->dio_counter_iobase);
 
 	/*  figure out what local addresses are */
 	local_range =
-		readl(priv(dev)->plx9080_iobase +
-		PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
+	    readl(priv(dev)->plx9080_iobase + PLX_LAS0RNG_REG) & LRNG_MEM_MASK;
 	local_decode =
-		readl(priv(dev)->plx9080_iobase +
-		PLX_LAS0MAP_REG) & local_range & LMAP_MEM_MASK;
+	    readl(priv(dev)->plx9080_iobase +
+		  PLX_LAS0MAP_REG) & local_range & LMAP_MEM_MASK;
 	priv(dev)->local0_iobase =
-		((uint32_t) priv(dev)->
-		main_phys_iobase & ~local_range) | local_decode;
+	    ((uint32_t) priv(dev)->main_phys_iobase & ~local_range) |
+	    local_decode;
 	local_range =
-		readl(priv(dev)->plx9080_iobase +
-		PLX_LAS1RNG_REG) & LRNG_MEM_MASK;
+	    readl(priv(dev)->plx9080_iobase + PLX_LAS1RNG_REG) & LRNG_MEM_MASK;
 	local_decode =
-		readl(priv(dev)->plx9080_iobase +
-		PLX_LAS1MAP_REG) & local_range & LMAP_MEM_MASK;
+	    readl(priv(dev)->plx9080_iobase +
+		  PLX_LAS1MAP_REG) & local_range & LMAP_MEM_MASK;
 	priv(dev)->local1_iobase =
-		((uint32_t) priv(dev)->
-		dio_counter_phys_iobase & ~local_range) | local_decode;
+	    ((uint32_t) priv(dev)->dio_counter_phys_iobase & ~local_range) |
+	    local_decode;
 
 	DEBUG_PRINT(" local 0 io addr 0x%x\n", priv(dev)->local0_iobase);
 	DEBUG_PRINT(" local 1 io addr 0x%x\n", priv(dev)->local1_iobase);
@@ -1789,7 +1834,7 @@ static int attach(struct comedi_device *
 		return retval;
 
 	priv(dev)->hw_revision =
-		hw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));
+	    hw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));
 	printk(" stc hardware revision %i\n", priv(dev)->hw_revision);
 	init_plx9080(dev);
 	init_stc_registers(dev);
@@ -1840,32 +1885,40 @@ static int detach(struct comedi_device *
 			for (i = 0; i < ai_dma_ring_count(board(dev)); i++) {
 				if (priv(dev)->ai_buffer[i])
 					pci_free_consistent(priv(dev)->hw_dev,
-						DMA_BUFFER_SIZE,
-						priv(dev)->ai_buffer[i],
-						priv(dev)->
-						ai_buffer_bus_addr[i]);
+							    DMA_BUFFER_SIZE,
+							    priv(dev)->
+							    ai_buffer[i],
+							    priv
+							    (dev)->ai_buffer_bus_addr
+							    [i]);
 			}
 			for (i = 0; i < AO_DMA_RING_COUNT; i++) {
 				if (priv(dev)->ao_buffer[i])
 					pci_free_consistent(priv(dev)->hw_dev,
-						DMA_BUFFER_SIZE,
-						priv(dev)->ao_buffer[i],
-						priv(dev)->
-						ao_buffer_bus_addr[i]);
+							    DMA_BUFFER_SIZE,
+							    priv(dev)->
+							    ao_buffer[i],
+							    priv
+							    (dev)->ao_buffer_bus_addr
+							    [i]);
 			}
 			/*  free dma descriptors */
 			if (priv(dev)->ai_dma_desc)
 				pci_free_consistent(priv(dev)->hw_dev,
-					sizeof(struct plx_dma_desc) *
-					ai_dma_ring_count(board(dev)),
-					priv(dev)->ai_dma_desc,
-					priv(dev)->ai_dma_desc_bus_addr);
+						    sizeof(struct plx_dma_desc)
+						    *
+						    ai_dma_ring_count(board
+								      (dev)),
+						    priv(dev)->ai_dma_desc,
+						    priv(dev)->
+						    ai_dma_desc_bus_addr);
 			if (priv(dev)->ao_dma_desc)
 				pci_free_consistent(priv(dev)->hw_dev,
-					sizeof(struct plx_dma_desc) *
-					AO_DMA_RING_COUNT,
-					priv(dev)->ao_dma_desc,
-					priv(dev)->ao_dma_desc_bus_addr);
+						    sizeof(struct plx_dma_desc)
+						    * AO_DMA_RING_COUNT,
+						    priv(dev)->ao_dma_desc,
+						    priv(dev)->
+						    ao_dma_desc_bus_addr);
 			if (priv(dev)->main_phys_iobase) {
 				comedi_pci_disable(priv(dev)->hw_dev);
 			}
@@ -1879,7 +1932,7 @@ static int detach(struct comedi_device *
 }
 
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits = 0, n, i;
 	unsigned int channel, range, aref;
@@ -1901,14 +1954,14 @@ static int ai_rinsn(struct comedi_device
 	else
 		priv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;
 	writew(priv(dev)->adc_control1_bits,
-		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (board(dev)->layout != LAYOUT_4020) {
 		/*  use internal queue */
 		priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
 		writew(priv(dev)->hw_config_bits,
-			priv(dev)->main_iobase + HW_CONFIG_REG);
+		       priv(dev)->main_iobase + HW_CONFIG_REG);
 
 		/*  ALT_SOURCE is internal calibration reference */
 		if (insn->chanspec & CR_ALT_SOURCE) {
@@ -1920,9 +1973,9 @@ static int ai_rinsn(struct comedi_device
 			else
 				cal_en_bit = CAL_EN_64XX_BIT;
 			/*  select internal reference source to connect to channel 0 */
-			writew(cal_en_bit | adc_src_bits(priv(dev)->
-					calibration_source),
-				priv(dev)->main_iobase + CALIBRATION_REG);
+			writew(cal_en_bit |
+			       adc_src_bits(priv(dev)->calibration_source),
+			       priv(dev)->main_iobase + CALIBRATION_REG);
 		} else {
 			/*  make sure internal calibration source is turned off */
 			writew(0, priv(dev)->main_iobase + CALIBRATION_REG);
@@ -1938,7 +1991,7 @@ static int ai_rinsn(struct comedi_device
 		bits |= adc_chan_bits(channel);
 		/*  set stop channel */
 		writew(adc_chan_bits(channel),
-			priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
+		       priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
 		/*  set start channel, and rest of settings */
 		writew(bits, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
 	} else {
@@ -1948,8 +2001,7 @@ static int ai_rinsn(struct comedi_device
 		if (insn->chanspec & CR_ALT_SOURCE) {
 			DEBUG_PRINT("reading calibration source\n");
 			priv(dev)->i2c_cal_range_bits |=
-				adc_src_4020_bits(priv(dev)->
-				calibration_source);
+			    adc_src_4020_bits(priv(dev)->calibration_source);
 		} else {	/* select BNC inputs */
 			priv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);
 		}
@@ -1958,20 +2010,20 @@ static int ai_rinsn(struct comedi_device
 			priv(dev)->i2c_cal_range_bits |= attenuate_bit(channel);
 		else
 			priv(dev)->i2c_cal_range_bits &=
-				~attenuate_bit(channel);
+			    ~attenuate_bit(channel);
 		/*  update calibration/range i2c register only if necessary, as it is very slow */
 		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
 			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
-				sizeof(i2c_data));
+				  sizeof(i2c_data));
 		}
 
 		/* 4020 manual asks that sample interval register to be set before writing to convert register.
 		 * Using somewhat arbitrary setting of 4 master clock ticks = 0.1 usec */
 		writew(0,
-			priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+		       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 		writew(2,
-			priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+		       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	}
 
 	for (n = 0; n < insn->n; n++) {
@@ -1981,7 +2033,7 @@ static int ai_rinsn(struct comedi_device
 
 		/* trigger conversion, bits sent only matter for 4020 */
 		writew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),
-			priv(dev)->main_iobase + ADC_CONVERT_REG);
+		       priv(dev)->main_iobase + ADC_CONVERT_REG);
 
 		/*  wait for data */
 		for (i = 0; i < timeout; i++) {
@@ -1989,7 +2041,7 @@ static int ai_rinsn(struct comedi_device
 			DEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));
 			if (board(dev)->layout == LAYOUT_4020) {
 				if (readw(priv(dev)->main_iobase +
-						ADC_WRITE_PNTR_REG))
+					  ADC_WRITE_PNTR_REG))
 					break;
 			} else {
 				if (pipe_full_bits(bits))
@@ -2005,17 +2057,18 @@ static int ai_rinsn(struct comedi_device
 		}
 		if (board(dev)->layout == LAYOUT_4020)
 			data[n] =
-				readl(priv(dev)->dio_counter_iobase +
-				ADC_FIFO_REG) & 0xffff;
+			    readl(priv(dev)->dio_counter_iobase +
+				  ADC_FIFO_REG) & 0xffff;
 		else
 			data[n] =
-				readw(priv(dev)->main_iobase + PIPE1_READ_REG);
+			    readw(priv(dev)->main_iobase + PIPE1_READ_REG);
 	}
 
 	return n;
 }
 
-static int ai_config_calibration_source(struct comedi_device *dev, unsigned int *data)
+static int ai_config_calibration_source(struct comedi_device *dev,
+					unsigned int *data)
 {
 	unsigned int source = data[1];
 	int num_calibration_sources;
@@ -2046,8 +2099,7 @@ static int ai_config_block_size(struct c
 
 	if (requested_block_size) {
 		fifo_size =
-			requested_block_size * fifo->num_segments /
-			bytes_in_sample;
+		    requested_block_size * fifo->num_segments / bytes_in_sample;
 
 		retval = set_ai_fifo_size(dev, fifo_size);
 		if (retval < 0)
@@ -2062,7 +2114,8 @@ static int ai_config_block_size(struct c
 	return 2;
 }
 
-static int ai_config_master_clock_4020(struct comedi_device *dev, unsigned int *data)
+static int ai_config_master_clock_4020(struct comedi_device *dev,
+				       unsigned int *data)
 {
 	unsigned int divisor = data[4];
 	int retval = 0;
@@ -2104,7 +2157,7 @@ static int ai_config_master_clock(struct
 }
 
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int id = data[0];
 
@@ -2126,7 +2179,7 @@ static int ai_config_insn(struct comedi_
 }
 
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+		      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -2181,21 +2234,21 @@ static int ai_cmdtest(struct comedi_devi
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_OTHER &&
-		cmd->scan_begin_src != TRIG_FOLLOW)
+	    cmd->scan_begin_src != TRIG_OTHER &&
+	    cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 
 	/*  compatibility check */
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 
 	if (err)
@@ -2217,10 +2270,10 @@ static int ai_cmdtest(struct comedi_devi
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				/*  if scans are timed faster than conversion rate allows */
 				if (cmd->convert_arg * cmd->chanlist_len >
-					cmd->scan_begin_arg) {
+				    cmd->scan_begin_arg) {
 					cmd->scan_begin_arg =
-						cmd->convert_arg *
-						cmd->chanlist_len;
+					    cmd->convert_arg *
+					    cmd->chanlist_len;
 					err++;
 				}
 			}
@@ -2279,7 +2332,7 @@ static int ai_cmdtest(struct comedi_devi
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (aref != CR_AREF(cmd->chanlist[i])) {
 				comedi_error(dev,
-					"all elements in chanlist must use the same analog reference");
+					     "all elements in chanlist must use the same analog reference");
 				err++;
 				break;
 			}
@@ -2289,16 +2342,16 @@ static int ai_cmdtest(struct comedi_devi
 			unsigned int first_channel = CR_CHAN(cmd->chanlist[0]);
 			for (i = 1; i < cmd->chanlist_len; i++) {
 				if (CR_CHAN(cmd->chanlist[i]) !=
-					first_channel + i) {
+				    first_channel + i) {
 					comedi_error(dev,
-						"chanlist must use consecutive channels");
+						     "chanlist must use consecutive channels");
 					err++;
 					break;
 				}
 			}
 			if (cmd->chanlist_len == 3) {
 				comedi_error(dev,
-					"chanlist cannot be 3 channels long, use 1, 2, or 4 channels");
+					     "chanlist cannot be 3 channels long, use 1, 2, or 4 channels");
 				err++;
 			}
 		}
@@ -2321,7 +2374,8 @@ static int use_hw_sample_counter(struct 
 		return 0;
 }
 
-static void setup_sample_counters(struct comedi_device *dev, struct comedi_cmd *cmd)
+static void setup_sample_counters(struct comedi_device *dev,
+				  struct comedi_cmd *cmd)
 {
 	if (cmd->stop_src == TRIG_COUNT) {
 		/*  set software count */
@@ -2330,9 +2384,9 @@ static void setup_sample_counters(struct
 	/*  load hardware conversion counter */
 	if (use_hw_sample_counter(cmd)) {
 		writew(cmd->stop_arg & 0xffff,
-			priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
+		       priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
 		writew((cmd->stop_arg >> 16) & 0xff,
-			priv(dev)->main_iobase + ADC_COUNT_UPPER_REG);
+		       priv(dev)->main_iobase + ADC_COUNT_UPPER_REG);
 	} else {
 		writew(1, priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);
 	}
@@ -2343,8 +2397,8 @@ static inline unsigned int dma_transfer_
 	unsigned int num_samples;
 
 	num_samples =
-		priv(dev)->ai_fifo_segment_length *
-		board(dev)->ai_fifo->sample_packing_ratio;
+	    priv(dev)->ai_fifo_segment_length *
+	    board(dev)->ai_fifo->sample_packing_ratio;
 	if (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))
 		num_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);
 
@@ -2360,12 +2414,12 @@ static void disable_ai_pacing(struct com
 	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->adc_control1_bits &= ~ADC_SW_GATE_BIT;
 	writew(priv(dev)->adc_control1_bits,
-		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* disable pacing, triggering, etc */
 	writew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,
-		priv(dev)->main_iobase + ADC_CONTROL0_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL0_REG);
 }
 
 static void disable_ai_interrupts(struct comedi_device *dev)
@@ -2374,23 +2428,24 @@ static void disable_ai_interrupts(struct
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->intr_enable_bits &=
-		~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
-		~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
-		~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
+	    ~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &
+	    ~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &
+	    ~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;
 	writew(priv(dev)->intr_enable_bits,
-		priv(dev)->main_iobase + INTR_ENABLE_REG);
+	       priv(dev)->main_iobase + INTR_ENABLE_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 }
 
-static void enable_ai_interrupts(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void enable_ai_interrupts(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd)
 {
 	uint32_t bits;
 	unsigned long flags;
 
 	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
-		EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
+	    EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
 	/*  Use pio transfer and interrupt on end of conversion if TRIG_WAKE_EOS flag is set. */
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		/*  4020 doesn't support pio transfers except for fifo dregs */
@@ -2400,27 +2455,28 @@ static void enable_ai_interrupts(struct 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	priv(dev)->intr_enable_bits |= bits;
 	writew(priv(dev)->intr_enable_bits,
-		priv(dev)->main_iobase + INTR_ENABLE_REG);
+	       priv(dev)->main_iobase + INTR_ENABLE_REG);
 	DEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,
-	const struct comedi_cmd *cmd)
+					const struct comedi_cmd *cmd)
 {
 	/*  supposed to load counter with desired divisor minus 3 */
 	return cmd->convert_arg / TIMER_BASE - 3;
 }
 
-static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev, struct comedi_cmd *cmd)
+static uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,
+				     struct comedi_cmd *cmd)
 {
 	uint32_t count;
 	/*  figure out how long we need to delay at end of scan */
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		count = (cmd->scan_begin_arg -
-			(cmd->convert_arg * (cmd->chanlist_len - 1)))
-			/ TIMER_BASE;
+			 (cmd->convert_arg * (cmd->chanlist_len - 1)))
+		    / TIMER_BASE;
 		break;
 	case TRIG_FOLLOW:
 		count = cmd->convert_arg / TIMER_BASE;
@@ -2432,7 +2488,8 @@ static uint32_t ai_scan_counter_6xxx(str
 	return count - 3;
 }
 
-static uint32_t ai_convert_counter_4020(struct comedi_device *dev, struct comedi_cmd *cmd)
+static uint32_t ai_convert_counter_4020(struct comedi_device *dev,
+					struct comedi_cmd *cmd)
 {
 	unsigned int divisor;
 
@@ -2454,7 +2511,7 @@ static uint32_t ai_convert_counter_4020(
 }
 
 static void select_master_clock_4020(struct comedi_device *dev,
-	const struct comedi_cmd *cmd)
+				     const struct comedi_cmd *cmd)
 {
 	/*  select internal/external master clock */
 	priv(dev)->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;
@@ -2469,10 +2526,11 @@ static void select_master_clock_4020(str
 		priv(dev)->hw_config_bits |= INTERNAL_CLOCK_4020_BITS;
 	}
 	writew(priv(dev)->hw_config_bits,
-		priv(dev)->main_iobase + HW_CONFIG_REG);
+	       priv(dev)->main_iobase + HW_CONFIG_REG);
 }
 
-static void select_master_clock(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void select_master_clock(struct comedi_device *dev,
+				const struct comedi_cmd *cmd)
 {
 	switch (board(dev)->layout) {
 	case LAYOUT_4020:
@@ -2483,7 +2541,8 @@ static void select_master_clock(struct c
 	}
 }
 
-static inline void dma_start_sync(struct comedi_device *dev, unsigned int channel)
+static inline void dma_start_sync(struct comedi_device *dev,
+				  unsigned int channel)
 {
 	unsigned long flags;
 
@@ -2491,12 +2550,12 @@ static inline void dma_start_sync(struct
 	spin_lock_irqsave(&dev->spinlock, flags);
 	if (channel)
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
-			PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       PLX_CLEAR_DMA_INTR_BIT,
+		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	else
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
-			PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+		       PLX_CLEAR_DMA_INTR_BIT,
+		       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
@@ -2517,17 +2576,17 @@ static void set_ai_pacing(struct comedi_
 
 	/*  load lower 16 bits of convert interval */
 	writew(convert_counter & 0xffff,
-		priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
+	       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	DEBUG_PRINT("convert counter 0x%x\n", convert_counter);
 	/*  load upper 8 bits of convert interval */
 	writew((convert_counter >> 16) & 0xff,
-		priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
+	       priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 	/*  load lower 16 bits of scan delay */
 	writew(scan_counter & 0xffff,
-		priv(dev)->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
+	       priv(dev)->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
 	/*  load upper 8 bits of scan delay */
 	writew((scan_counter >> 16) & 0xff,
-		priv(dev)->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
+	       priv(dev)->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
 	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
 }
 
@@ -2536,10 +2595,10 @@ static int use_internal_queue_6xxx(const
 	int i;
 	for (i = 0; i + 1 < cmd->chanlist_len; i++) {
 		if (CR_CHAN(cmd->chanlist[i + 1]) !=
-			CR_CHAN(cmd->chanlist[i]) + 1)
+		    CR_CHAN(cmd->chanlist[i]) + 1)
 			return 0;
 		if (CR_RANGE(cmd->chanlist[i + 1]) !=
-			CR_RANGE(cmd->chanlist[i]))
+		    CR_RANGE(cmd->chanlist[i]))
 			return 0;
 		if (CR_AREF(cmd->chanlist[i + 1]) != CR_AREF(cmd->chanlist[i]))
 			return 0;
@@ -2547,7 +2606,8 @@ static int use_internal_queue_6xxx(const
 	return 1;
 }
 
-static int setup_channel_queue(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static int setup_channel_queue(struct comedi_device *dev,
+			       const struct comedi_cmd *cmd)
 {
 	unsigned short bits;
 	int i;
@@ -2556,25 +2616,26 @@ static int setup_channel_queue(struct co
 		if (use_internal_queue_6xxx(cmd)) {
 			priv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;
 			writew(priv(dev)->hw_config_bits,
-				priv(dev)->main_iobase + HW_CONFIG_REG);
+			       priv(dev)->main_iobase + HW_CONFIG_REG);
 			bits = 0;
 			/*  set channel */
 			bits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));
 			/*  set gain */
 			bits |= ai_range_bits_6xxx(dev,
-				CR_RANGE(cmd->chanlist[0]));
+						   CR_RANGE(cmd->chanlist[0]));
 			/*  set single-ended / differential */
 			bits |= se_diff_bit_6xxx(dev,
-				CR_AREF(cmd->chanlist[0]) == AREF_DIFF);
+						 CR_AREF(cmd->chanlist[0]) ==
+						 AREF_DIFF);
 			if (CR_AREF(cmd->chanlist[0]) == AREF_COMMON)
 				bits |= ADC_COMMON_BIT;
 			/*  set stop channel */
-			writew(adc_chan_bits(CR_CHAN(cmd->chanlist[cmd->
-							chanlist_len - 1])),
-				priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
+			writew(adc_chan_bits
+			       (CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])),
+			       priv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);
 			/*  set start channel, and rest of settings */
 			writew(bits,
-				priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
+			       priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);
 		} else {
 			/*  use external queue */
 			if (dev->write_subdev && dev->write_subdev->busy) {
@@ -2583,36 +2644,40 @@ static int setup_channel_queue(struct co
 			}
 			priv(dev)->hw_config_bits |= EXT_QUEUE_BIT;
 			writew(priv(dev)->hw_config_bits,
-				priv(dev)->main_iobase + HW_CONFIG_REG);
+			       priv(dev)->main_iobase + HW_CONFIG_REG);
 			/*  clear DAC buffer to prevent weird interactions */
 			writew(0,
-				priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
+			       priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);
 			/*  clear queue pointer */
 			writew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);
 			/*  load external queue */
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				bits = 0;
 				/*  set channel */
-				bits |= adc_chan_bits(CR_CHAN(cmd->
-						chanlist[i]));
+				bits |=
+				    adc_chan_bits(CR_CHAN(cmd->chanlist[i]));
 				/*  set gain */
 				bits |= ai_range_bits_6xxx(dev,
-					CR_RANGE(cmd->chanlist[i]));
+							   CR_RANGE(cmd->
+								    chanlist
+								    [i]));
 				/*  set single-ended / differential */
 				bits |= se_diff_bit_6xxx(dev,
-					CR_AREF(cmd->chanlist[i]) == AREF_DIFF);
+							 CR_AREF(cmd->
+								 chanlist[i]) ==
+							 AREF_DIFF);
 				if (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)
 					bits |= ADC_COMMON_BIT;
 				/*  mark end of queue */
 				if (i == cmd->chanlist_len - 1)
 					bits |= QUEUE_EOSCAN_BIT |
-						QUEUE_EOSEQ_BIT;
+					    QUEUE_EOSEQ_BIT;
 				writew(bits,
-					priv(dev)->main_iobase +
-					ADC_QUEUE_FIFO_REG);
+				       priv(dev)->main_iobase +
+				       ADC_QUEUE_FIFO_REG);
 				DEBUG_PRINT
-					("wrote 0x%x to external channel queue\n",
-					bits);
+				    ("wrote 0x%x to external channel queue\n",
+				     bits);
 			}
 			/* doing a queue clear is not specified in board docs,
 			 * but required for reliable operation */
@@ -2622,7 +2687,7 @@ static int setup_channel_queue(struct co
 		}
 	} else {
 		unsigned short old_cal_range_bits =
-			priv(dev)->i2c_cal_range_bits;
+		    priv(dev)->i2c_cal_range_bits;
 
 		priv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;
 		/* select BNC inputs */
@@ -2634,23 +2699,24 @@ static int setup_channel_queue(struct co
 
 			if (range == 0)
 				priv(dev)->i2c_cal_range_bits |=
-					attenuate_bit(channel);
+				    attenuate_bit(channel);
 			else
 				priv(dev)->i2c_cal_range_bits &=
-					~attenuate_bit(channel);
+				    ~attenuate_bit(channel);
 		}
 		/*  update calibration/range i2c register only if necessary, as it is very slow */
 		if (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {
 			uint8_t i2c_data = priv(dev)->i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,
-				sizeof(i2c_data));
+				  sizeof(i2c_data));
 		}
 	}
 	return 0;
 }
 
 static inline void load_first_dma_descriptor(struct comedi_device *dev,
-	unsigned int dma_channel, unsigned int descriptor_bits)
+					     unsigned int dma_channel,
+					     unsigned int descriptor_bits)
 {
 	/* The transfer size, pci address, and local address registers
 	 * are supposedly unused during chained dma,
@@ -2659,20 +2725,20 @@ static inline void load_first_dma_descri
 	 * block.  Initializing them to zero seems to fix the problem. */
 	if (dma_channel) {
 		writel(0,
-			priv(dev)->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);
 		writel(0, priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);
 		writel(0,
-			priv(dev)->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);
 		writel(descriptor_bits,
-			priv(dev)->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);
 	} else {
 		writel(0,
-			priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
 		writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 		writel(0,
-			priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
 		writel(descriptor_bits,
-			priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 	}
 }
 
@@ -2719,14 +2785,15 @@ static int ai_cmd(struct comedi_device *
 			priv(dev)->adc_control1_bits |= TWO_CHANNEL_4020_BITS;
 		priv(dev)->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;
 		priv(dev)->adc_control1_bits |=
-			adc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));
+		    adc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));
 		priv(dev)->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;
 		priv(dev)->adc_control1_bits |=
-			adc_hi_chan_4020_bits(CR_CHAN(cmd->chanlist[cmd->
-					chanlist_len - 1]));
+		    adc_hi_chan_4020_bits(CR_CHAN
+					  (cmd->
+					   chanlist[cmd->chanlist_len - 1]));
 	}
 	writew(priv(dev)->adc_control1_bits,
-		priv(dev)->main_iobase + ADC_CONTROL1_REG);
+	       priv(dev)->main_iobase + ADC_CONTROL1_REG);
 	DEBUG_PRINT("control1 bits 0x%x\n", priv(dev)->adc_control1_bits);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -2734,20 +2801,21 @@ static int ai_cmd(struct comedi_device *
 	writew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);
 
 	if ((cmd->flags & TRIG_WAKE_EOS) == 0 ||
-		board(dev)->layout == LAYOUT_4020) {
+	    board(dev)->layout == LAYOUT_4020) {
 		priv(dev)->ai_dma_index = 0;
 
 		/*  set dma transfer size */
 		for (i = 0; i < ai_dma_ring_count(board(dev)); i++)
 			priv(dev)->ai_dma_desc[i].transfer_size =
-				cpu_to_le32(dma_transfer_size(dev) *
-				sizeof(uint16_t));
+			    cpu_to_le32(dma_transfer_size(dev) *
+					sizeof(uint16_t));
 
 		/*  give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
-			priv(dev)->
-			ai_dma_desc_bus_addr | PLX_DESC_IN_PCI_BIT |
-			PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI);
+					  priv(dev)->ai_dma_desc_bus_addr |
+					  PLX_DESC_IN_PCI_BIT |
+					  PLX_INTR_TERM_COUNT |
+					  PLX_XFER_LOCAL_TO_PCI);
 
 		dma_start_sync(dev, 1);
 	}
@@ -2807,11 +2875,9 @@ static void pio_drain_ai_fifo_16(struct 
 	do {
 		/*  get least significant 15 bits */
 		read_index =
-			readw(priv(dev)->main_iobase +
-			ADC_READ_PNTR_REG) & 0x7fff;
+		    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 		write_index =
-			readw(priv(dev)->main_iobase +
-			ADC_WRITE_PNTR_REG) & 0x7fff;
+		    readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 		/* Get most significant bits (grey code).  Different boards use different code
 		 * so use a scheme that doesn't depend on encoding.  This read must
 		 * occur after reading least significant 15 bits to avoid race
@@ -2824,11 +2890,12 @@ static void pio_drain_ai_fifo_16(struct 
 		write_segment = adc_upper_write_ptr_code(prepost_bits);
 
 		DEBUG_PRINT(" rd seg %i, wrt seg %i, rd idx %i, wrt idx %i\n",
-			read_segment, write_segment, read_index, write_index);
+			    read_segment, write_segment, read_index,
+			    write_index);
 
 		if (read_segment != write_segment)
 			num_samples =
-				priv(dev)->ai_fifo_segment_length - read_index;
+			    priv(dev)->ai_fifo_segment_length - read_index;
 		else
 			num_samples = write_index - read_index;
 
@@ -2850,7 +2917,8 @@ static void pio_drain_ai_fifo_16(struct 
 
 		for (i = 0; i < num_samples; i++) {
 			cfc_write_to_buffer(s,
-				readw(priv(dev)->main_iobase + ADC_FIFO_REG));
+					    readw(priv(dev)->main_iobase +
+						  ADC_FIFO_REG));
 		}
 
 	} while (read_segment != write_segment);
@@ -2870,9 +2938,9 @@ static void pio_drain_ai_fifo_32(struct 
 	unsigned int max_transfer = 100000;
 	uint32_t fifo_data;
 	int write_code =
-		readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
+	    readw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;
 	int read_code =
-		readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
+	    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		if (max_transfer > priv(dev)->ai_count) {
@@ -2888,8 +2956,7 @@ static void pio_drain_ai_fifo_32(struct 
 			i++;
 		}
 		read_code =
-			readw(priv(dev)->main_iobase +
-			ADC_READ_PNTR_REG) & 0x7fff;
+		    readw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;
 	}
 	priv(dev)->ai_count -= i;
 }
@@ -2913,19 +2980,18 @@ static void drain_dma_buffers(struct com
 
 	if (channel)
 		pci_addr_reg =
-			priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+		    priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
 	else
 		pci_addr_reg =
-			priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+		    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
 	/*  loop until we have read all the full buffers */
 	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
-		(next_transfer_addr <
-			priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index]
-			|| next_transfer_addr >=
-			priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index] +
-			DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev));
-		j++) {
+	     (next_transfer_addr <
+	      priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index]
+	      || next_transfer_addr >=
+	      priv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index] +
+	      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev)); j++) {
 		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = dma_transfer_size(dev);
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -2934,15 +3000,16 @@ static void drain_dma_buffers(struct com
 			priv(dev)->ai_count -= num_samples;
 		}
 		cfc_write_array_to_buffer(dev->read_subdev,
-			priv(dev)->ai_buffer[priv(dev)->ai_dma_index],
-			num_samples * sizeof(uint16_t));
+					  priv(dev)->ai_buffer[priv(dev)->
+							       ai_dma_index],
+					  num_samples * sizeof(uint16_t));
 		priv(dev)->ai_dma_index =
-			(priv(dev)->ai_dma_index +
-			1) % ai_dma_ring_count(board(dev));
+		    (priv(dev)->ai_dma_index +
+		     1) % ai_dma_ring_count(board(dev));
 
 		DEBUG_PRINT("next buffer addr 0x%lx\n",
-			(unsigned long)priv(dev)->ai_buffer_bus_addr[priv(dev)->
-				ai_dma_index]);
+			    (unsigned long)priv(dev)->
+			    ai_buffer_bus_addr[priv(dev)->ai_dma_index]);
 		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
 	/* XXX check for dma ring buffer overrun (use end-of-chain bit to mark last
@@ -2950,7 +3017,7 @@ static void drain_dma_buffers(struct com
 }
 
 void handle_ai_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned int plx_status)
+			 unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
@@ -2968,7 +3035,7 @@ void handle_ai_interrupt(struct comedi_d
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
 
 		if (dma1_status & PLX_DMA_EN_BIT) {
@@ -2983,9 +3050,9 @@ void handle_ai_interrupt(struct comedi_d
 
 	/*  drain fifo with pio */
 	if ((status & ADC_DONE_BIT) ||
-		((cmd->flags & TRIG_WAKE_EOS) &&
-			(status & ADC_INTR_PENDING_BIT) &&
-			(board(dev)->layout != LAYOUT_4020))) {
+	    ((cmd->flags & TRIG_WAKE_EOS) &&
+	     (status & ADC_INTR_PENDING_BIT) &&
+	     (board(dev)->layout != LAYOUT_4020))) {
 		DEBUG_PRINT("pio fifo drain\n");
 		spin_lock_irqsave(&dev->spinlock, flags);
 		if (priv(dev)->ai_cmd_running) {
@@ -2996,7 +3063,7 @@ void handle_ai_interrupt(struct comedi_d
 	}
 	/*  if we are have all the data, then quit */
 	if ((cmd->stop_src == TRIG_COUNT && priv(dev)->ai_count <= 0) ||
-		(cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
+	    (cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {
 		async->events |= COMEDI_CB_EOA;
 	}
 
@@ -3026,14 +3093,15 @@ static int last_ao_dma_load_completed(st
 		return 0;
 
 	transfer_address =
-		readl(priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+	    readl(priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 	if (transfer_address != priv(dev)->ao_buffer_bus_addr[buffer_index])
 		return 0;
 
 	return 1;
 }
 
-static int ao_stopped_by_error(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static int ao_stopped_by_error(struct comedi_device *dev,
+			       const struct comedi_cmd *cmd)
 {
 	if (cmd->stop_src == TRIG_NONE)
 		return 1;
@@ -3047,10 +3115,10 @@ static int ao_stopped_by_error(struct co
 }
 
 static inline int ao_dma_needs_restart(struct comedi_device *dev,
-	unsigned short dma_status)
+				       unsigned short dma_status)
 {
 	if ((dma_status & PLX_DMA_DONE_BIT) == 0 ||
-		(dma_status & PLX_DMA_EN_BIT) == 0)
+	    (dma_status & PLX_DMA_EN_BIT) == 0)
 		return 0;
 	if (last_ao_dma_load_completed(dev))
 		return 0;
@@ -3063,7 +3131,7 @@ static void restart_ao_dma(struct comedi
 	unsigned int dma_desc_bits;
 
 	dma_desc_bits =
-		readl(priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+	    readl(priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 	dma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;
 	DEBUG_PRINT("restarting ao dma, descriptor reg 0x%x\n", dma_desc_bits);
 	load_first_dma_descriptor(dev, 0, dma_desc_bits);
@@ -3071,8 +3139,8 @@ static void restart_ao_dma(struct comedi
 	dma_start_sync(dev, 0);
 }
 
-static void handle_ao_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned int plx_status)
+static void handle_ao_interrupt(struct comedi_device *dev,
+				unsigned short status, unsigned int plx_status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async;
@@ -3091,12 +3159,12 @@ static void handle_ao_interrupt(struct c
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		if ((dma0_status & PLX_DMA_EN_BIT)
-			&& !(dma0_status & PLX_DMA_DONE_BIT))
+		    && !(dma0_status & PLX_DMA_DONE_BIT))
 			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
-				priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+			       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 		else
 			writeb(PLX_CLEAR_DMA_INTR_BIT,
-				priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+			       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT) {
@@ -3114,11 +3182,11 @@ static void handle_ao_interrupt(struct c
 		if (ao_stopped_by_error(dev, cmd))
 			async->events |= COMEDI_CB_ERROR;
 		DEBUG_PRINT("plx dma0 desc reg 0x%x\n",
-			readl(priv(dev)->plx9080_iobase +
-				PLX_DMA0_DESCRIPTOR_REG));
+			    readl(priv(dev)->plx9080_iobase +
+				  PLX_DMA0_DESCRIPTOR_REG));
 		DEBUG_PRINT("plx dma0 address reg 0x%x\n",
-			readl(priv(dev)->plx9080_iobase +
-				PLX_DMA0_PCI_ADDRESS_REG));
+			    readl(priv(dev)->plx9080_iobase +
+				  PLX_DMA0_PCI_ADDRESS_REG));
 	}
 	cfc_handle_events(dev, s);
 }
@@ -3141,7 +3209,7 @@ static irqreturn_t handle_interrupt(int 
 	 * interrupt handler */
 	if (dev->attached == 0) {
 		DEBUG_PRINT("cb_pcidas64: premature interrupt, ignoring",
-			status);
+			    status);
 		return IRQ_HANDLED;
 	}
 	handle_ai_interrupt(dev, status, plx_status);
@@ -3192,7 +3260,7 @@ static int ai_cancel(struct comedi_devic
 }
 
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int range = CR_RANGE(insn->chanspec);
@@ -3203,14 +3271,14 @@ static int ao_winsn(struct comedi_device
 	/*  set range */
 	set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, chan, range);
 	writew(priv(dev)->dac_control1_bits,
-		priv(dev)->main_iobase + DAC_CONTROL1_REG);
+	       priv(dev)->main_iobase + DAC_CONTROL1_REG);
 
 	/*  write to channel */
 	if (board(dev)->layout == LAYOUT_4020) {
 		writew(data[0] & 0xff,
-			priv(dev)->main_iobase + dac_lsb_4020_reg(chan));
+		       priv(dev)->main_iobase + dac_lsb_4020_reg(chan));
 		writew((data[0] >> 8) & 0xf,
-			priv(dev)->main_iobase + dac_msb_4020_reg(chan));
+		       priv(dev)->main_iobase + dac_msb_4020_reg(chan));
 	} else {
 		writew(data[0], priv(dev)->main_iobase + dac_convert_reg(chan));
 	}
@@ -3221,18 +3289,20 @@ static int ao_winsn(struct comedi_device
 	return 1;
 }
 
-static int ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ao_readback_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static void set_dac_control0_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void set_dac_control0_reg(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd)
 {
 	unsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |
-		WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
+	    WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;
 
 	if (cmd->start_src == TRIG_EXT) {
 		bits |= WAVEFORM_TRIG_EXT_BITS;
@@ -3249,7 +3319,8 @@ static void set_dac_control0_reg(struct 
 	writew(bits, priv(dev)->main_iobase + DAC_CONTROL0_REG);
 }
 
-static void set_dac_control1_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void set_dac_control1_reg(struct comedi_device *dev,
+				 const struct comedi_cmd *cmd)
 {
 	int i;
 
@@ -3259,14 +3330,15 @@ static void set_dac_control1_reg(struct 
 		channel = CR_CHAN(cmd->chanlist[i]);
 		range = CR_RANGE(cmd->chanlist[i]);
 		set_dac_range_bits(dev, &priv(dev)->dac_control1_bits, channel,
-			range);
+				   range);
 	}
 	priv(dev)->dac_control1_bits |= DAC_SW_GATE_BIT;
 	writew(priv(dev)->dac_control1_bits,
-		priv(dev)->main_iobase + DAC_CONTROL1_REG);
+	       priv(dev)->main_iobase + DAC_CONTROL1_REG);
 }
 
-static void set_dac_select_reg(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void set_dac_select_reg(struct comedi_device *dev,
+			       const struct comedi_cmd *cmd)
 {
 	uint16_t bits;
 	unsigned int first_channel, last_channel;
@@ -3281,7 +3353,8 @@ static void set_dac_select_reg(struct co
 	writew(bits, priv(dev)->main_iobase + DAC_SELECT_REG);
 }
 
-static void set_dac_interval_regs(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void set_dac_interval_regs(struct comedi_device *dev,
+				  const struct comedi_cmd *cmd)
 {
 	unsigned int divisor;
 
@@ -3294,13 +3367,13 @@ static void set_dac_interval_regs(struct
 		divisor = max_counter_value;
 	}
 	writew(divisor & 0xffff,
-		priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);
+	       priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);
 	writew((divisor >> 16) & 0xff,
-		priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
+	       priv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);
 }
 
 static unsigned int load_ao_dma_buffer(struct comedi_device *dev,
-	const struct comedi_cmd *cmd)
+				       const struct comedi_cmd *cmd)
 {
 	unsigned int num_bytes, buffer_index, prev_buffer_index;
 	unsigned int next_bits;
@@ -3309,7 +3382,7 @@ static unsigned int load_ao_dma_buffer(s
 	prev_buffer_index = prev_ao_dma_index(dev);
 
 	DEBUG_PRINT("attempting to load ao buffer %i (0x%x)\n", buffer_index,
-		priv(dev)->ao_buffer_bus_addr[buffer_index]);
+		    priv(dev)->ao_buffer_bus_addr[buffer_index]);
 
 	num_bytes = comedi_buf_read_n_available(dev->write_subdev->async);
 	if (num_bytes > DMA_BUFFER_SIZE)
@@ -3324,9 +3397,11 @@ static unsigned int load_ao_dma_buffer(s
 	DEBUG_PRINT("loading %i bytes\n", num_bytes);
 
 	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-		priv(dev)->ao_buffer[buffer_index], num_bytes);
+					       priv(dev)->
+					       ao_buffer[buffer_index],
+					       num_bytes);
 	priv(dev)->ao_dma_desc[buffer_index].transfer_size =
-		cpu_to_le32(num_bytes);
+	    cpu_to_le32(num_bytes);
 	/* set end of chain bit so we catch underruns */
 	next_bits = le32_to_cpu(priv(dev)->ao_dma_desc[buffer_index].next);
 	next_bits |= PLX_END_OF_CHAIN_BIT;
@@ -3348,7 +3423,7 @@ static void load_ao_dma(struct comedi_de
 	unsigned int num_bytes;
 	unsigned int next_transfer_addr;
 	void *pci_addr_reg =
-		priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+	    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 	unsigned int buffer_index;
 
 	do {
@@ -3356,10 +3431,10 @@ static void load_ao_dma(struct comedi_de
 		/* don't overwrite data that hasn't been transferred yet */
 		next_transfer_addr = readl(pci_addr_reg);
 		if (next_transfer_addr >=
-			priv(dev)->ao_buffer_bus_addr[buffer_index]
-			&& next_transfer_addr <
-			priv(dev)->ao_buffer_bus_addr[buffer_index] +
-			DMA_BUFFER_SIZE)
+		    priv(dev)->ao_buffer_bus_addr[buffer_index]
+		    && next_transfer_addr <
+		    priv(dev)->ao_buffer_bus_addr[buffer_index] +
+		    DMA_BUFFER_SIZE)
 			return;
 		num_bytes = load_ao_dma_buffer(dev, cmd);
 	} while (num_bytes >= DMA_BUFFER_SIZE);
@@ -3377,13 +3452,14 @@ static int prep_ao_dma(struct comedi_dev
 
 	num_bytes = (DAC_FIFO_SIZE / 2) * bytes_in_sample;
 	if (cmd->stop_src == TRIG_COUNT &&
-		num_bytes / bytes_in_sample > priv(dev)->ao_count)
+	    num_bytes / bytes_in_sample > priv(dev)->ao_count)
 		num_bytes = priv(dev)->ao_count * bytes_in_sample;
 	num_bytes = cfc_read_array_from_buffer(dev->write_subdev,
-		priv(dev)->ao_bounce_buffer, num_bytes);
+					       priv(dev)->ao_bounce_buffer,
+					       num_bytes);
 	for (i = 0; i < num_bytes / bytes_in_sample; i++) {
 		writew(priv(dev)->ao_bounce_buffer[i],
-			priv(dev)->main_iobase + DAC_FIFO_REG);
+		       priv(dev)->main_iobase + DAC_FIFO_REG);
 	}
 	priv(dev)->ao_count -= num_bytes / bytes_in_sample;
 	if (cmd->stop_src == TRIG_COUNT && priv(dev)->ao_count == 0)
@@ -3427,7 +3503,7 @@ static int ao_cmd(struct comedi_device *
 	set_dac_select_reg(dev, cmd);
 	set_dac_interval_regs(dev, cmd);
 	load_first_dma_descriptor(dev, 0, priv(dev)->ao_dma_desc_bus_addr |
-		PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
+				  PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);
 
 	set_dac_control1_reg(dev, cmd);
 	s->async->inttrig = ao_inttrig;
@@ -3436,7 +3512,7 @@ static int ao_cmd(struct comedi_device *
 }
 
 static int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trig_num)
+		      unsigned int trig_num)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval;
@@ -3459,7 +3535,7 @@ static int ao_inttrig(struct comedi_devi
 }
 
 static int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+		      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3502,14 +3578,14 @@ static int ao_cmdtest(struct comedi_devi
 	if (cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 
 	/*  compatibility check */
 	if (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 
 	if (err)
@@ -3523,9 +3599,9 @@ static int ao_cmdtest(struct comedi_devi
 			err++;
 		}
 		if (get_ao_divisor(cmd->scan_begin_arg,
-				cmd->flags) > max_counter_value) {
+				   cmd->flags) > max_counter_value) {
 			cmd->scan_begin_arg =
-				(max_counter_value + 2) * TIMER_BASE;
+			    (max_counter_value + 2) * TIMER_BASE;
 			err++;
 		}
 	}
@@ -3547,8 +3623,7 @@ static int ao_cmdtest(struct comedi_devi
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp_arg = cmd->scan_begin_arg;
 		cmd->scan_begin_arg =
-			get_divisor(cmd->scan_begin_arg,
-			cmd->flags) * TIMER_BASE;
+		    get_divisor(cmd->scan_begin_arg, cmd->flags) * TIMER_BASE;
 		if (tmp_arg != cmd->scan_begin_arg)
 			err++;
 	}
@@ -3561,7 +3636,7 @@ static int ao_cmdtest(struct comedi_devi
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) != first_channel + i) {
 				comedi_error(dev,
-					"chanlist must use consecutive channels");
+					     "chanlist must use consecutive channels");
 				err++;
 				break;
 			}
@@ -3603,7 +3678,7 @@ static int dio_callback_4020(int dir, in
 }
 
 static int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -3616,7 +3691,7 @@ static int di_rbits(struct comedi_device
 }
 
 static int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] &= 0xf;
 	/*  zero bits we are going to change */
@@ -3631,8 +3706,9 @@ static int do_wbits(struct comedi_device
 	return 2;
 }
 
-static int dio_60xx_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dio_60xx_config_insn(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int mask;
 
@@ -3653,19 +3729,19 @@ static int dio_60xx_config_insn(struct c
 	}
 
 	writeb(s->io_bits,
-		priv(dev)->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
+	       priv(dev)->dio_counter_iobase + DIO_DIRECTION_60XX_REG);
 
 	return 1;
 }
 
 static int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
 		s->state |= (data[0] & data[1]);
 		writeb(s->state,
-			priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
+		       priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
 	}
 
 	data[1] = readb(priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);
@@ -3674,7 +3750,7 @@ static int dio_60xx_wbits(struct comedi_
 }
 
 static void caldac_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value)
+			 unsigned int value)
 {
 	priv(dev)->caldac_state[channel] = value;
 
@@ -3691,8 +3767,9 @@ static void caldac_write(struct comedi_d
 	}
 }
 
-static int calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int calib_write_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3706,8 +3783,9 @@ static int calib_write_insn(struct comed
 	return 1;
 }
 
-static int calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int calib_read_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3717,7 +3795,7 @@ static int calib_read_insn(struct comedi
 }
 
 static void ad8402_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value)
+			 unsigned int value)
 {
 	static const int bitstream_length = 10;
 	unsigned int bit, register_bits;
@@ -3739,7 +3817,7 @@ static void ad8402_write(struct comedi_d
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 		udelay(ad8402_udelay);
 		writew(register_bits | SERIAL_CLOCK_BIT,
-			priv(dev)->main_iobase + CALIBRATION_REG);
+		       priv(dev)->main_iobase + CALIBRATION_REG);
 	}
 
 	udelay(ad8402_udelay);
@@ -3747,8 +3825,9 @@ static void ad8402_write(struct comedi_d
 }
 
 /* for pci-das6402/16, channel 0 is analog input gain and channel 1 is offset */
-static int ad8402_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ad8402_write_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -3764,8 +3843,9 @@ static int ad8402_write_insn(struct come
 	return 1;
 }
 
-static int ad8402_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ad8402_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -3781,7 +3861,7 @@ static uint16_t read_eeprom(struct comed
 	unsigned int bitstream = (read_command << 8) | address;
 	unsigned int bit;
 	void *const plx_control_addr =
-		priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
+	    priv(dev)->plx9080_iobase + PLX_CONTROL_REG;
 	uint16_t value;
 	static const int value_length = 16;
 	static const int eeprom_udelay = 1;
@@ -3836,8 +3916,9 @@ static uint16_t read_eeprom(struct comed
 	return value;
 }
 
-static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int eeprom_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));
 
@@ -3853,7 +3934,7 @@ static void check_adc_timing(struct come
 	unsigned int convert_divisor = 0, scan_divisor;
 	static const int min_convert_divisor = 3;
 	static const int max_convert_divisor =
-		max_counter_value + min_convert_divisor;
+	    max_counter_value + min_convert_divisor;
 	static const int min_scan_divisor_4020 = 2;
 	unsigned long long max_scan_divisor, min_scan_divisor;
 
@@ -3862,7 +3943,7 @@ static void check_adc_timing(struct come
 			cmd->convert_arg = 0;
 		} else {
 			convert_divisor =
-				get_divisor(cmd->convert_arg, cmd->flags);
+			    get_divisor(cmd->convert_arg, cmd->flags);
 			if (convert_divisor > max_convert_divisor)
 				convert_divisor = max_convert_divisor;
 			if (convert_divisor < min_convert_divisor)
@@ -3878,8 +3959,8 @@ static void check_adc_timing(struct come
 			/*  XXX check for integer overflows */
 			min_scan_divisor = convert_divisor * cmd->chanlist_len;
 			max_scan_divisor =
-				(convert_divisor * cmd->chanlist_len - 1) +
-				max_counter_value;
+			    (convert_divisor * cmd->chanlist_len - 1) +
+			    max_counter_value;
 		} else {
 			min_scan_divisor = min_scan_divisor_4020;
 			max_scan_divisor = max_counter_value + min_scan_divisor;
@@ -3931,7 +4012,8 @@ static int set_ai_fifo_size(struct comed
 	num_fifo_entries = num_samples / fifo->sample_packing_ratio;
 
 	retval = set_ai_fifo_segment_length(dev,
-		num_fifo_entries / fifo->num_segments);
+					    num_fifo_entries /
+					    fifo->num_segments);
 	if (retval < 0)
 		return retval;
 
@@ -3946,12 +4028,12 @@ static int set_ai_fifo_size(struct comed
 static unsigned int ai_fifo_size(struct comedi_device *dev)
 {
 	return priv(dev)->ai_fifo_segment_length *
-		board(dev)->ai_fifo->num_segments *
-		board(dev)->ai_fifo->sample_packing_ratio;
+	    board(dev)->ai_fifo->num_segments *
+	    board(dev)->ai_fifo->sample_packing_ratio;
 }
 
 static int set_ai_fifo_segment_length(struct comedi_device *dev,
-	unsigned int num_entries)
+				      unsigned int num_entries)
 {
 	static const int increment_size = 0x100;
 	const struct hw_fifo_info *const fifo = board(dev)->ai_fifo;
@@ -3970,12 +4052,12 @@ static int set_ai_fifo_segment_length(st
 	priv(dev)->fifo_size_bits &= ~fifo->fifo_size_reg_mask;
 	priv(dev)->fifo_size_bits |= bits;
 	writew(priv(dev)->fifo_size_bits,
-		priv(dev)->main_iobase + FIFO_SIZE_REG);
+	       priv(dev)->main_iobase + FIFO_SIZE_REG);
 
 	priv(dev)->ai_fifo_segment_length = num_increments * increment_size;
 
 	DEBUG_PRINT("set hardware fifo segment length to %i\n",
-		priv(dev)->ai_fifo_segment_length);
+		    priv(dev)->ai_fifo_segment_length);
 
 	return priv(dev)->ai_fifo_segment_length;
 }
@@ -4002,7 +4084,7 @@ static int set_ai_fifo_segment_length(st
 */
 
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-	uint8_t value)
+			     uint8_t value)
 {
 	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
@@ -4033,8 +4115,8 @@ static int caldac_8800_write(struct come
 }
 
 /* 4020 caldacs */
-static int caldac_i2c_write(struct comedi_device *dev, unsigned int caldac_channel,
-	unsigned int value)
+static int caldac_i2c_write(struct comedi_device *dev,
+			    unsigned int caldac_channel, unsigned int value)
 {
 	uint8_t serial_bytes[3];
 	uint8_t i2c_addr;
@@ -4108,8 +4190,8 @@ static void i2c_set_sda(struct comedi_de
 		priv(dev)->plx_control_bits &= ~data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		udelay(i2c_high_udelay);
-	} else			/*  set data line low */
-	{
+	} else {		/*  set data line low */
+
 		priv(dev)->plx_control_bits |= data_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		udelay(i2c_low_udelay);
@@ -4127,8 +4209,8 @@ static void i2c_set_scl(struct comedi_de
 		priv(dev)->plx_control_bits &= ~clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		udelay(i2c_high_udelay);
-	} else			/*  set clock line low */
-	{
+	} else {		/*  set clock line low */
+
 		priv(dev)->plx_control_bits |= clock_bit;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
 		udelay(i2c_low_udelay);
@@ -4180,7 +4262,7 @@ static void i2c_stop(struct comedi_devic
 }
 
 static void i2c_write(struct comedi_device *dev, unsigned int address,
-	const uint8_t *data, unsigned int length)
+		      const uint8_t * data, unsigned int length)
 {
 	unsigned int i;
 	uint8_t bitstream;
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -156,6 +156,7 @@ static inline unsigned int DAC_RANGE(uns
 {
 	return (range & 0x3) << (8 + 2 * (channel & 0x1));
 }
+
 static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
 {
 	return 0x3 << (8 + 2 * (channel & 0x1));
@@ -200,41 +201,41 @@ static inline unsigned int DAC_DATA_REG(
 static const struct comedi_lrange cb_pcidas_ranges = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25)
+	 }
 };
 
 /* pci-das1001 input ranges */
 static const struct comedi_lrange cb_pcidas_alt_ranges = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.1),
+	 BIP_RANGE(0.01),
+	 UNI_RANGE(10),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.1),
+	 UNI_RANGE(0.01)
+	 }
 };
 
 /* analog output ranges */
 static const struct comedi_lrange cb_pcidas_ao_ranges = {
 	4,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(10),
+	 }
 };
 
 enum trimpot_model {
@@ -260,131 +261,132 @@ struct cb_pcidas_board {
 
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	{
-	.name = "pci-das1602/16",
-	.device_id = 0x1,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.has_ao_fifo = 1,
-	.ao_scan_speed = 10000,
-	.fifo_size = 512,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD8402,
-	.has_dac08 = 1,
-		},
+	 .name = "pci-das1602/16",
+	 .device_id = 0x1,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 1,
+	 .ao_scan_speed = 10000,
+	 .fifo_size = 512,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD8402,
+	 .has_dac08 = 1,
+	 },
 	{
-	.name = "pci-das1200",
-	.device_id = 0xF,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 3200,
-	.ao_nchan = 2,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1200",
+	 .device_id = 0xF,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 3200,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1602/12",
-	.device_id = 0x10,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 3200,
-	.ao_nchan = 2,
-	.has_ao_fifo = 1,
-	.ao_scan_speed = 4000,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1602/12",
+	 .device_id = 0x10,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 3200,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 1,
+	 .ao_scan_speed = 4000,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1200/jr",
-	.device_id = 0x19,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 3200,
-	.ao_nchan = 0,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1200/jr",
+	 .device_id = 0x19,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 3200,
+	 .ao_nchan = 0,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1602/16/jr",
-	.device_id = 0x1C,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 0,
-	.has_ao_fifo = 0,
-	.fifo_size = 512,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD8402,
-	.has_dac08 = 1,
-		},
+	 .name = "pci-das1602/16/jr",
+	 .device_id = 0x1C,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 512,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD8402,
+	 .has_dac08 = 1,
+	 },
 	{
-	.name = "pci-das1000",
-	.device_id = 0x4C,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 4000,
-	.ao_nchan = 0,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1000",
+	 .device_id = 0x4C,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 4000,
+	 .ao_nchan = 0,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1001",
-	.device_id = 0x1a,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 6800,
-	.ao_nchan = 2,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_alt_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1001",
+	 .device_id = 0x1a,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 6800,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_alt_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1002",
-	.device_id = 0x1b,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 6800,
-	.ao_nchan = 2,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1002",
+	 .device_id = 0x1b,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 6800,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 };
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
-	{PCI_VENDOR_ID_CB, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x000f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0019, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x001c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x004c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x001a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x001b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_CB, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x000f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0019, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x001c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x004c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x001a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x001b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
@@ -438,7 +440,8 @@ struct cb_pcidas_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int cb_pcidas_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it);
 static int cb_pcidas_detach(struct comedi_device *dev);
 static struct comedi_driver driver_cb_pcidas = {
 	.driver_name = "cb_pcidas",
@@ -447,55 +450,75 @@ static struct comedi_driver driver_cb_pc
 	.detach = cb_pcidas_detach,
 };
 
-static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice * s,
-	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+			  struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data);
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
+static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data);
+static int cb_pcidas_ai_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd);
+static int cb_pcidas_ao_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *subdev,
 				unsigned int trig_num);
-static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd);
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d);
 static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status);
-static int cb_pcidas_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int cb_pcidas_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int cb_pcidas_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int cb_pcidas_ao_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s);
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
-	int round_flags);
-static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int caldac_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int caldac_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int trimpot_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_trimpot_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value);
-static int trimpot_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dac08_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+				    int round_flags);
+static int eeprom_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int caldac_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int caldac_write_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int trimpot_read_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_trimpot_write(struct comedi_device *dev,
+				   unsigned int channel, unsigned int value);
+static int trimpot_write_insn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int dac08_read_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
 static int dac08_write(struct comedi_device *dev, unsigned int value);
-static int dac08_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int dac08_write_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-	uint8_t value);
+			     uint8_t value);
 static int trimpot_7376_write(struct comedi_device *dev, uint8_t value);
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
-	uint8_t value);
+			      uint8_t value);
 static int nvram_read(struct comedi_device *dev, unsigned int address,
-	uint8_t *data);
+		      uint8_t * data);
 
 static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 {
@@ -506,7 +529,8 @@ static inline unsigned int cal_enable_bi
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.
  */
-static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int cb_pcidas_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;
@@ -527,8 +551,8 @@ static int cb_pcidas_attach(struct comed
 	printk("\n");
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;
@@ -540,8 +564,7 @@ static int cb_pcidas_attach(struct comed
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
@@ -552,13 +575,13 @@ static int cb_pcidas_attach(struct comed
 	}
 
 	printk("No supported ComputerBoards/MeasurementComputing card found on "
-		"requested position\n");
+	       "requested position\n");
 	return -EIO;
 
-      found:
+found:
 
 	printk("Found %s on bus %i, slot %i\n", cb_pcidas_boards[index].name,
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	/*
 	 * Enable PCI device and reserve I/O ports.
@@ -572,20 +595,20 @@ static int cb_pcidas_attach(struct comed
 	 * their base address.
 	 */
 	devpriv->s5933_config =
-		pci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);
 	devpriv->control_status =
-		pci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);
 	devpriv->adc_fifo =
-		pci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);
 	devpriv->pacer_counter_dio =
-		pci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);
 	if (thisboard->ao_nchan) {
 		devpriv->ao_registers =
-			pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
+		    pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
 	}
 	/*  disable and clear interrupts on amcc s5933 */
 	outl(INTCSR_INBOX_INTR_STATUS,
-		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	/*  get irq */
 	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
@@ -700,11 +723,11 @@ static int cb_pcidas_attach(struct comed
 	inl(devpriv->s5933_config + AMCC_OP_REG_IMB4);
 	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
 	devpriv->s5933_intcsr_bits =
-		INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
-		INTCSR_INBOX_FULL_INT;
+	    INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
+	    INTCSR_INBOX_FULL_INT;
 	/*  clear and enable interrupt on amcc s5933 */
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
-		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	return 1;
 }
@@ -725,11 +748,10 @@ static int cb_pcidas_detach(struct comed
 		if (devpriv->s5933_config) {
 			/*  disable and clear interrupts on amcc s5933 */
 			outl(INTCSR_INBOX_INTR_STATUS,
-				devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
 			printk("detaching, incsr is 0x%x\n",
-				inl(devpriv->s5933_config +
-					AMCC_OP_REG_INTCSR));
+			       inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR));
 #endif
 		}
 	}
@@ -751,8 +773,9 @@ static int cb_pcidas_detach(struct comed
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	unsigned int bits;
@@ -761,7 +784,7 @@ static int cb_pcidas_ai_rinsn(struct com
 	/*  enable calibration input if appropriate */
 	if (insn->chanspec & CR_ALT_SOURCE) {
 		outw(cal_enable_bits(dev),
-			devpriv->control_status + CALIBRATION_REG);
+		     devpriv->control_status + CALIBRATION_REG);
 		channel = 0;
 	} else {
 		outw(0, devpriv->control_status + CALIBRATION_REG);
@@ -769,7 +792,7 @@ static int cb_pcidas_ai_rinsn(struct com
 	}
 	/*  set mux limits and gain */
 	bits = BEGIN_SCAN(channel) |
-		END_SCAN(channel) | GAIN_BITS(CR_RANGE(insn->chanspec));
+	    END_SCAN(channel) | GAIN_BITS(CR_RANGE(insn->chanspec));
 	/*  set unipolar/bipolar */
 	if (CR_RANGE(insn->chanspec) & IS_UNIPOLAR)
 		bits |= UNIP;
@@ -803,7 +826,8 @@ static int cb_pcidas_ai_rinsn(struct com
 	return n;
 }
 
-static int ai_config_calibration_source(struct comedi_device *dev, unsigned int *data)
+static int ai_config_calibration_source(struct comedi_device *dev,
+					unsigned int *data)
 {
 	static const int num_calibration_sources = 8;
 	unsigned int source = data[1];
@@ -819,7 +843,7 @@ static int ai_config_calibration_source(
 }
 
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int id = data[0];
 
@@ -835,8 +859,10 @@ static int ai_config_insn(struct comedi_
 }
 
 /* analog output insn for pcidas-1000 and 1200 series */
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 	int channel;
 	unsigned long flags;
@@ -845,9 +871,9 @@ static int cb_pcidas_ao_nofifo_winsn(str
 	channel = CR_CHAN(insn->chanspec);
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
-		~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);
+	    ~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);
 	devpriv->ao_control_bits |=
-		DACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));
+	    DACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -860,8 +886,9 @@ static int cb_pcidas_ao_nofifo_winsn(str
 }
 
 /* analog output insn for pcidas-1602 series */
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int channel;
 	unsigned long flags;
@@ -873,11 +900,13 @@ static int cb_pcidas_ao_fifo_winsn(struc
 	channel = CR_CHAN(insn->chanspec);
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
-		~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &
-		~DAC_PACER_MASK;
+	    ~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &
+	    ~DAC_PACER_MASK;
 	devpriv->ao_control_bits |=
-		DACEN | DAC_RANGE(channel,
-		CR_RANGE(insn->chanspec)) | DAC_CHAN_EN(channel) | DAC_START;
+	    DACEN | DAC_RANGE(channel,
+			      CR_RANGE(insn->
+				       chanspec)) | DAC_CHAN_EN(channel) |
+	    DAC_START;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -891,16 +920,19 @@ static int cb_pcidas_ao_fifo_winsn(struc
 
 /* analog output readback insn */
 /* XXX loses track of analog output value back after an analog ouput command is executed */
-static int cb_pcidas_ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int eeprom_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	uint8_t nvram_data;
 	int retval;
@@ -914,16 +946,18 @@ static int eeprom_read_insn(struct comed
 	return 1;
 }
 
-static int caldac_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int caldac_write_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	const unsigned int channel = CR_CHAN(insn->chanspec);
 
 	return caldac_8800_write(dev, channel, data[0]);
 }
 
-static int caldac_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int caldac_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
 
@@ -939,26 +973,28 @@ static int dac08_write(struct comedi_dev
 	devpriv->dac08_value = value;
 
 	outw(cal_enable_bits(dev) | (value & 0xff),
-		devpriv->control_status + CALIBRATION_REG);
+	     devpriv->control_status + CALIBRATION_REG);
 	udelay(1);
 	outw(cal_enable_bits(dev) | SELECT_DAC08_BIT | (value & 0xff),
-		devpriv->control_status + CALIBRATION_REG);
+	     devpriv->control_status + CALIBRATION_REG);
 	udelay(1);
 	outw(cal_enable_bits(dev) | (value & 0xff),
-		devpriv->control_status + CALIBRATION_REG);
+	     devpriv->control_status + CALIBRATION_REG);
 	udelay(1);
 
 	return 1;
 }
 
-static int dac08_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dac08_write_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	return dac08_write(dev, data[0]);
 }
 
-static int dac08_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dac08_read_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	data[0] = devpriv->dac08_value;
 
@@ -966,7 +1002,7 @@ static int dac08_read_insn(struct comedi
 }
 
 static int cb_pcidas_trimpot_write(struct comedi_device *dev,
-	unsigned int channel, unsigned int value)
+				   unsigned int channel, unsigned int value)
 {
 	if (devpriv->trimpot_value[channel] == value)
 		return 1;
@@ -988,16 +1024,18 @@ static int cb_pcidas_trimpot_write(struc
 	return 1;
 }
 
-static int trimpot_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int trimpot_write_insn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
 	return cb_pcidas_trimpot_write(dev, channel, data[0]);
 }
 
-static int trimpot_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int trimpot_read_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -1006,8 +1044,9 @@ static int trimpot_read_insn(struct come
 	return 1;
 }
 
-static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1055,11 +1094,11 @@ static int cb_pcidas_ai_cmdtest(struct c
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_TIMER &&
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1070,8 +1109,7 @@ static int cb_pcidas_ai_cmdtest(struct c
 	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->start_src == TRIG_EXT &&
-		(cmd->convert_src == TRIG_EXT
-			|| cmd->scan_begin_src == TRIG_EXT))
+	    (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT))
 		err++;
 
 	if (err)
@@ -1086,9 +1124,9 @@ static int cb_pcidas_ai_cmdtest(struct c
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg <
-			thisboard->ai_speed * cmd->chanlist_len) {
+		    thisboard->ai_speed * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				thisboard->ai_speed * cmd->chanlist_len;
+			    thisboard->ai_speed * cmd->chanlist_len;
 			err++;
 		}
 	}
@@ -1119,16 +1157,20 @@ static int cb_pcidas_ai_cmdtest(struct c
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->scan_begin_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->convert_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -1142,14 +1184,14 @@ static int cb_pcidas_ai_cmdtest(struct c
 		start_chan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				(start_chan + i) % s->n_chan) {
+			    (start_chan + i) % s->n_chan) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					"entries in chanlist must all have the same gain\n");
+					     "entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -1161,7 +1203,8 @@ static int cb_pcidas_ai_cmdtest(struct c
 	return 0;
 }
 
-static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int cb_pcidas_ai_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1177,8 +1220,8 @@ static int cb_pcidas_ai_cmd(struct comed
 
 	/*  set mux limits, gain and pacer source */
 	bits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |
-		END_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
-		GAIN_BITS(CR_RANGE(cmd->chanlist[0]));
+	    END_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
+	    GAIN_BITS(CR_RANGE(cmd->chanlist[0]));
 	/*  set unipolar/bipolar */
 	if (CR_RANGE(cmd->chanlist[0]) & IS_UNIPOLAR)
 		bits |= UNIP;
@@ -1199,10 +1242,10 @@ static int cb_pcidas_ai_cmd(struct comed
 	/*  load counters */
 	if (cmd->convert_src == TRIG_TIMER)
 		cb_pcidas_load_counters(dev, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 	else if (cmd->scan_begin_src == TRIG_TIMER)
 		cb_pcidas_load_counters(dev, &cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 
 	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -1225,7 +1268,7 @@ static int cb_pcidas_ai_cmd(struct comed
 #endif
 	/*  enable (and clear) interrupts */
 	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
-		devpriv->control_status + INT_ADCFIFO);
+	     devpriv->control_status + INT_ADCFIFO);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set start trigger and burst mode */
@@ -1248,8 +1291,9 @@ static int cb_pcidas_ai_cmd(struct comed
 	return 0;
 }
 
-static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1294,7 +1338,7 @@ static int cb_pcidas_ao_cmdtest(struct c
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1336,8 +1380,10 @@ static int cb_pcidas_ao_cmdtest(struct c
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&(devpriv->ao_divisor1), &(devpriv->ao_divisor2),
-			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->ao_divisor1),
+					       &(devpriv->ao_divisor2),
+					       &(cmd->scan_begin_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -1348,9 +1394,9 @@ static int cb_pcidas_ao_cmdtest(struct c
 	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist && cmd->chanlist_len > 1) {
 		if (CR_CHAN(cmd->chanlist[0]) != 0 ||
-			CR_CHAN(cmd->chanlist[1]) != 1) {
+		    CR_CHAN(cmd->chanlist[1]) != 1) {
 			comedi_error(dev,
-				"channels must be ordered channel 0, channel 1 in chanlist\n");
+				     "channels must be ordered channel 0, channel 1 in chanlist\n");
 			err++;
 		}
 	}
@@ -1361,7 +1407,8 @@ static int cb_pcidas_ao_cmdtest(struct c
 	return 0;
 }
 
-static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int cb_pcidas_ao_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1373,10 +1420,11 @@ static int cb_pcidas_ao_cmd(struct comed
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		/*  enable channel */
 		devpriv->ao_control_bits |=
-			DAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));
+		    DAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));
 		/*  set range */
 		devpriv->ao_control_bits |= DAC_RANGE(CR_CHAN(cmd->chanlist[i]),
-			CR_RANGE(cmd->chanlist[i]));
+						      CR_RANGE(cmd->
+							       chanlist[i]));
 	}
 
 	/*  disable analog out before settings pacer source and count values */
@@ -1389,14 +1437,16 @@ static int cb_pcidas_ao_cmd(struct comed
 	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&(devpriv->ao_divisor1), &(devpriv->ao_divisor2),
-			&(cmd->scan_begin_arg), cmd->flags);
+					       &(devpriv->ao_divisor1),
+					       &(devpriv->ao_divisor2),
+					       &(cmd->scan_begin_arg),
+					       cmd->flags);
 
 		/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 1,
-			devpriv->ao_divisor1, 2);
+			   devpriv->ao_divisor1, 2);
 		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 2,
-			devpriv->ao_divisor2, 2);
+			   devpriv->ao_divisor2, 2);
 	}
 	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -1441,7 +1491,7 @@ static int cb_pcidas_ao_inttrig(struct c
 		num_points = devpriv->ao_count;
 
 	num_bytes = cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-		num_points * sizeof(short));
+					       num_points * sizeof(short));
 	num_points = num_bytes / sizeof(short);
 
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -1458,14 +1508,13 @@ static int cb_pcidas_ao_inttrig(struct c
 #endif
 	/*  enable and clear interrupts */
 	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
-		devpriv->control_status + INT_ADCFIFO);
+	     devpriv->control_status + INT_ADCFIFO);
 
 	/*  start dac */
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 #ifdef CB_PCIDAS_DEBUG
-	printk("comedi: sent 0x%x to dac control\n",
-		devpriv->ao_control_bits);
+	printk("comedi: sent 0x%x to dac control\n", devpriv->ao_control_bits);
 #endif
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -1476,7 +1525,7 @@ static int cb_pcidas_ao_inttrig(struct c
 
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
 	int status, s5933_status;
@@ -1505,7 +1554,7 @@ static irqreturn_t cb_pcidas_interrupt(i
 	inl_p(devpriv->s5933_config + AMCC_OP_REG_IMB4);
 	/*  clear interrupt on amcc s5933 */
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
-		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	status = inw(devpriv->control_status + INT_ADCFIFO);
 #ifdef CB_PCIDAS_DEBUG
@@ -1524,13 +1573,13 @@ static irqreturn_t cb_pcidas_interrupt(i
 		/*  read data */
 		num_samples = half_fifo;
 		if (async->cmd.stop_src == TRIG_COUNT &&
-			num_samples > devpriv->count) {
+		    num_samples > devpriv->count) {
 			num_samples = devpriv->count;
 		}
 		insw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,
-			num_samples);
+		     num_samples);
 		cfc_write_array_to_buffer(s, devpriv->ai_buffer,
-			num_samples * sizeof(short));
+					  num_samples * sizeof(short));
 		devpriv->count -= num_samples;
 		if (async->cmd.stop_src == TRIG_COUNT && devpriv->count == 0) {
 			async->events |= COMEDI_CB_EOA;
@@ -1539,14 +1588,14 @@ static irqreturn_t cb_pcidas_interrupt(i
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		/*  else if fifo not empty */
 	} else if (status & (ADNEI | EOBI)) {
 		for (i = 0; i < timeout; i++) {
 			/*  break if fifo is empty */
 			if ((ADNE & inw(devpriv->control_status +
-						INT_ADCFIFO)) == 0)
+					INT_ADCFIFO)) == 0)
 				break;
 			cfc_write_to_buffer(s, inw(devpriv->adc_fifo));
 			if (async->cmd.stop_src == TRIG_COUNT && --devpriv->count == 0) {	/* end of acquisition */
@@ -1558,15 +1607,15 @@ static irqreturn_t cb_pcidas_interrupt(i
 		/*  clear not-empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & EOAI) {
 		comedi_error(dev,
-			"bug! encountered end of aquisition interrupt?");
+			     "bug! encountered end of aquisition interrupt?");
 		/*  clear EOA interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/* check for fifo overflow */
@@ -1575,7 +1624,7 @@ static irqreturn_t cb_pcidas_interrupt(i
 		/*  clear overflow interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | LADFUL,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		cb_pcidas_cancel(dev, s);
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
@@ -1601,12 +1650,12 @@ static void handle_ao_interrupt(struct c
 		/*  clear dac empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAEMI,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
 			if (cmd->stop_src == TRIG_NONE ||
-				(cmd->stop_src == TRIG_COUNT
-					&& devpriv->ao_count)) {
+			    (cmd->stop_src == TRIG_COUNT
+			     && devpriv->ao_count)) {
 				comedi_error(dev, "dac fifo underflow");
 				cb_pcidas_ao_cancel(dev, s);
 				async->events |= COMEDI_CB_ERROR;
@@ -1619,11 +1668,11 @@ static void handle_ao_interrupt(struct c
 		/*  figure out how many points we are writing to fifo */
 		num_points = half_fifo;
 		if (cmd->stop_src == TRIG_COUNT &&
-			devpriv->ao_count < num_points)
+		    devpriv->ao_count < num_points)
 			num_points = devpriv->ao_count;
 		num_bytes =
-			cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-			num_points * sizeof(short));
+		    cfc_read_array_from_buffer(s, devpriv->ao_buffer,
+					       num_points * sizeof(short));
 		num_points = num_bytes / sizeof(short);
 
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -1631,11 +1680,11 @@ static void handle_ao_interrupt(struct c
 		}
 		/*  write data to board's fifo */
 		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
-			num_points);
+		      num_points);
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAHFI,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 
@@ -1643,7 +1692,8 @@ static void handle_ao_interrupt(struct c
 }
 
 /* cancel analog input command */
-static int cb_pcidas_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int cb_pcidas_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -1681,21 +1731,23 @@ static int cb_pcidas_ao_cancel(struct co
 }
 
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
-	int rounding_flags)
+				    int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-		&(devpriv->divisor2), ns, rounding_flags & TRIG_ROUND_MASK);
+				       &(devpriv->divisor2), ns,
+				       rounding_flags & TRIG_ROUND_MASK);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 1,
-		devpriv->divisor1, 2);
+		   devpriv->divisor1, 2);
 	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 2,
-		devpriv->divisor2, 2);
+		   devpriv->divisor2, 2);
 }
 
 static void write_calibration_bitstream(struct comedi_device *dev,
-	unsigned int register_bits, unsigned int bitstream,
-	unsigned int bitstream_length)
+					unsigned int register_bits,
+					unsigned int bitstream,
+					unsigned int bitstream_length)
 {
 	static const int write_delay = 1;
 	unsigned int bit;
@@ -1711,7 +1763,7 @@ static void write_calibration_bitstream(
 }
 
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-	uint8_t value)
+			     uint8_t value)
 {
 	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
@@ -1729,11 +1781,11 @@ static int caldac_8800_write(struct come
 	devpriv->caldac_value[address] = value;
 
 	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
-		bitstream_length);
+				    bitstream_length);
 
 	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
-		devpriv->control_status + CALIBRATION_REG);
+	     devpriv->control_status + CALIBRATION_REG);
 	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
 
@@ -1752,7 +1804,7 @@ static int trimpot_7376_write(struct com
 	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
-		bitstream_length);
+				    bitstream_length);
 
 	udelay(ad7376_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
@@ -1764,7 +1816,7 @@ static int trimpot_7376_write(struct com
  * ch 0 : adc gain
  * ch 1 : adc postgain offset */
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
-	uint8_t value)
+			      uint8_t value)
 {
 	static const int bitstream_length = 10;
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
@@ -1776,7 +1828,7 @@ static int trimpot_8402_write(struct com
 	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
-		bitstream_length);
+				    bitstream_length);
 
 	udelay(ad8402_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
@@ -1791,15 +1843,16 @@ static int wait_for_nvram_ready(unsigned
 
 	for (i = 0; i < timeout; i++) {
 		if ((inb(s5933_base_addr +
-					AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
-			== 0)
+			 AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
+		    == 0)
 			return 0;
 		udelay(1);
 	}
 	return -1;
 }
 
-static int nvram_read(struct comedi_device *dev, unsigned int address, uint8_t *data)
+static int nvram_read(struct comedi_device *dev, unsigned int address,
+		      uint8_t * data)
 {
 	unsigned long iobase = devpriv->s5933_config;
 
@@ -1807,10 +1860,10 @@ static int nvram_read(struct comedi_devi
 		return -ETIMEDOUT;
 
 	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,
-		iobase + AMCC_OP_REG_MCSR_NVCMD);
+	     iobase + AMCC_OP_REG_MCSR_NVCMD);
 	outb(address & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
 	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,
-		iobase + AMCC_OP_REG_MCSR_NVCMD);
+	     iobase + AMCC_OP_REG_MCSR_NVCMD);
 	outb((address >> 8) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
 	outb(MCSR_NV_ENABLE | MCSR_NV_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);
 
--- a/drivers/staging/comedi/drivers/cb_pcidda.c
+++ b/drivers/staging/comedi/drivers/cb_pcidda.c
@@ -115,13 +115,13 @@ Please report success/failure with other
 static const struct comedi_lrange cb_pcidda_ranges = {
 	6,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 }
 };
 
 /*
@@ -147,63 +147,64 @@ struct cb_pcidda_board {
 
 static const struct cb_pcidda_board cb_pcidda_boards[] = {
 	{
-	.name = "pci-dda02/12",
-	.status = 1,
-	.device_id = 0x20,
-	.ao_chans = 2,
-	.ao_bits = 12,
-	.ranges = &cb_pcidda_ranges,
-		},
+	 .name = "pci-dda02/12",
+	 .status = 1,
+	 .device_id = 0x20,
+	 .ao_chans = 2,
+	 .ao_bits = 12,
+	 .ranges = &cb_pcidda_ranges,
+	 },
 	{
-	.name = "pci-dda04/12",
-	.status = 1,
-	.device_id = 0x21,
-	.ao_chans = 4,
-	.ao_bits = 12,
-	.ranges = &cb_pcidda_ranges,
-		},
+	 .name = "pci-dda04/12",
+	 .status = 1,
+	 .device_id = 0x21,
+	 .ao_chans = 4,
+	 .ao_bits = 12,
+	 .ranges = &cb_pcidda_ranges,
+	 },
 	{
-	.name = "pci-dda08/12",
-	.status = 0,
-	.device_id = 0x22,
-	.ao_chans = 8,
-	.ao_bits = 12,
-	.ranges = &cb_pcidda_ranges,
-		},
+	 .name = "pci-dda08/12",
+	 .status = 0,
+	 .device_id = 0x22,
+	 .ao_chans = 8,
+	 .ao_bits = 12,
+	 .ranges = &cb_pcidda_ranges,
+	 },
 	{
-	.name = "pci-dda02/16",
-	.status = 2,
-	.device_id = 0x23,
-	.ao_chans = 2,
-	.ao_bits = 16,
-	.ranges = &cb_pcidda_ranges,
-		},
+	 .name = "pci-dda02/16",
+	 .status = 2,
+	 .device_id = 0x23,
+	 .ao_chans = 2,
+	 .ao_bits = 16,
+	 .ranges = &cb_pcidda_ranges,
+	 },
 	{
-	.name = "pci-dda04/16",
-	.status = 2,
-	.device_id = 0x24,
-	.ao_chans = 4,
-	.ao_bits = 16,
-	.ranges = &cb_pcidda_ranges,
-		},
+	 .name = "pci-dda04/16",
+	 .status = 2,
+	 .device_id = 0x24,
+	 .ao_chans = 4,
+	 .ao_bits = 16,
+	 .ranges = &cb_pcidda_ranges,
+	 },
 	{
-	.name = "pci-dda08/16",
-	.status = 0,
-	.device_id = 0x25,
-	.ao_chans = 8,
-	.ao_bits = 16,
-	.ranges = &cb_pcidda_ranges,
-		},
+	 .name = "pci-dda08/16",
+	 .status = 0,
+	 .device_id = 0x25,
+	 .ao_chans = 8,
+	 .ao_bits = 16,
+	 .ranges = &cb_pcidda_ranges,
+	 },
 };
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidda_pci_table) = {
-	{PCI_VENDOR_ID_CB, 0x0020, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0021, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0022, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0023, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0024, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0025, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_CB, 0x0020, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0021, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0022, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0023, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0024, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0025, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, cb_pcidda_pci_table);
@@ -239,11 +240,13 @@ struct cb_pcidda_private {
  */
 #define devpriv ((struct cb_pcidda_private *)dev->private)
 
-static int cb_pcidda_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int cb_pcidda_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it);
 static int cb_pcidda_detach(struct comedi_device *dev);
 /* static int cb_pcidda_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data); */
-static int cb_pcidda_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidda_ao_winsn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
 
 /* static int cb_pcidda_ai_cmd(struct comedi_device *dev, struct *comedi_subdevice *s);*/
 /* static int cb_pcidda_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd); */
@@ -251,11 +254,11 @@ static int cb_pcidda_ao_winsn(struct com
 
 static unsigned int cb_pcidda_serial_in(struct comedi_device *dev);
 static void cb_pcidda_serial_out(struct comedi_device *dev, unsigned int value,
-	unsigned int num_bits);
+				 unsigned int num_bits);
 static unsigned int cb_pcidda_read_eeprom(struct comedi_device *dev,
-	unsigned int address);
+					  unsigned int address);
 static void cb_pcidda_calibrate(struct comedi_device *dev, unsigned int channel,
-	unsigned int range);
+				unsigned int range);
 
 /*
  * The struct comedi_driver structure tells the Comedi core module
@@ -274,7 +277,8 @@ static struct comedi_driver driver_cb_pc
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.
  */
-static int cb_pcidda_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int cb_pcidda_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;
@@ -294,29 +298,29 @@ static int cb_pcidda_attach(struct comed
 	printk("\n");
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		if (pcidev->vendor == PCI_VENDOR_ID_CB) {
 			if (it->options[0] || it->options[1]) {
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
 			for (index = 0; index < N_BOARDS; index++) {
 				if (cb_pcidda_boards[index].device_id ==
-					pcidev->device) {
+				    pcidev->device) {
 					goto found;
 				}
 			}
 		}
 	}
 	if (!pcidev) {
-		printk("Not a ComputerBoards/MeasurementComputing card on requested position\n");
+		printk
+		    ("Not a ComputerBoards/MeasurementComputing card on requested position\n");
 		return -EIO;
 	}
-      found:
+found:
 	devpriv->pci_dev = pcidev;
 	dev->board_ptr = cb_pcidda_boards + index;
 	/*  "thisboard" macro can be used from here. */
@@ -326,7 +330,8 @@ static int cb_pcidda_attach(struct comed
 	 * Enable PCI device and request regions.
 	 */
 	if (comedi_pci_enable(pcidev, thisboard->name)) {
-		printk("cb_pcidda: failed to enable PCI device and request regions\n");
+		printk
+		    ("cb_pcidda: failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 
@@ -334,14 +339,17 @@ static int cb_pcidda_attach(struct comed
  * Allocate the I/O ports.
  */
 	devpriv->digitalio =
-		pci_resource_start(devpriv->pci_dev, DIGITALIO_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, DIGITALIO_BADRINDEX);
 	devpriv->dac = pci_resource_start(devpriv->pci_dev, DAC_BADRINDEX);
 
 /*
  * Warn about the status of the driver.
  */
 	if (thisboard->status == 2)
-		printk("WARNING: DRIVER FOR THIS BOARD NOT CHECKED WITH MANUAL. " "WORKS ASSUMING FULL COMPATIBILITY WITH PCI-DDA08/12. " "PLEASE REPORT USAGE TO <ivanmr@altavista.com>.\n");
+		printk
+		    ("WARNING: DRIVER FOR THIS BOARD NOT CHECKED WITH MANUAL. "
+		     "WORKS ASSUMING FULL COMPATIBILITY WITH PCI-DDA08/12. "
+		     "PLEASE REPORT USAGE TO <ivanmr@altavista.com>.\n");
 
 /*
  * Initialize dev->board_name.
@@ -423,7 +431,8 @@ static int cb_pcidda_detach(struct comed
  * I will program this later... ;-)
  */
 #if 0
-static int cb_pcidda_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int cb_pcidda_ai_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	printk("cb_pcidda_ai_cmd\n");
 	printk("subdev: %d\n", cmd->subdev);
@@ -442,8 +451,9 @@ static int cb_pcidda_ai_cmd(struct comed
 #endif
 
 #if 0
-static int cb_pcidda_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int cb_pcidda_ai_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -489,7 +499,7 @@ static int cb_pcidda_ai_cmdtest(struct c
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER
-		&& cmd->scan_begin_src != TRIG_EXT)
+	    && cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
@@ -569,21 +579,21 @@ static int cb_pcidda_ai_cmdtest(struct c
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		cb_pcidda_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				      cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		cb_pcidda_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				      cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->scan_end_arg) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -608,8 +618,9 @@ static int cb_pcidda_ns_to_timer(unsigne
 }
 #endif
 
-static int cb_pcidda_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidda_ao_winsn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int command;
 	unsigned int channel, range;
@@ -676,7 +687,7 @@ static unsigned int cb_pcidda_serial_in(
 
 /* lowlevel write to eeprom/dac */
 static void cb_pcidda_serial_out(struct comedi_device *dev, unsigned int value,
-	unsigned int num_bits)
+				 unsigned int num_bits)
 {
 	int i;
 
@@ -692,7 +703,7 @@ static void cb_pcidda_serial_out(struct 
 
 /* reads a 16 bit value from board's eeprom */
 static unsigned int cb_pcidda_read_eeprom(struct comedi_device *dev,
-	unsigned int address)
+					  unsigned int address)
 {
 	unsigned int i;
 	unsigned int cal2_bits;
@@ -725,8 +736,9 @@ static unsigned int cb_pcidda_read_eepro
 }
 
 /* writes to 8 bit calibration dacs */
-static void cb_pcidda_write_caldac(struct comedi_device *dev, unsigned int caldac,
-	unsigned int channel, unsigned int value)
+static void cb_pcidda_write_caldac(struct comedi_device *dev,
+				   unsigned int caldac, unsigned int channel,
+				   unsigned int value)
 {
 	unsigned int cal2_bits;
 	unsigned int i;
@@ -787,14 +799,14 @@ static unsigned int fine_offset_channel(
 
 /* returns eeprom address that provides offset for given ao channel and range */
 static unsigned int offset_eeprom_address(unsigned int ao_channel,
-	unsigned int range)
+					  unsigned int range)
 {
 	return 0x7 + 2 * range + 12 * ao_channel;
 }
 
 /* returns eeprom address that provides gain calibration for given ao channel and range */
 static unsigned int gain_eeprom_address(unsigned int ao_channel,
-	unsigned int range)
+					unsigned int range)
 {
 	return 0x8 + 2 * range + 12 * ao_channel;
 }
@@ -813,7 +825,7 @@ static unsigned int eeprom_fine_byte(uns
 
 /* set caldacs to eeprom values for given channel and range */
 static void cb_pcidda_calibrate(struct comedi_device *dev, unsigned int channel,
-	unsigned int range)
+				unsigned int range)
 {
 	unsigned int coarse_offset, fine_offset, coarse_gain, fine_gain;
 
@@ -822,27 +834,27 @@ static void cb_pcidda_calibrate(struct c
 
 	/*  get values from eeprom data */
 	coarse_offset =
-		eeprom_coarse_byte(devpriv->
-		eeprom_data[offset_eeprom_address(channel, range)]);
+	    eeprom_coarse_byte(devpriv->eeprom_data
+			       [offset_eeprom_address(channel, range)]);
 	fine_offset =
-		eeprom_fine_byte(devpriv->
-		eeprom_data[offset_eeprom_address(channel, range)]);
+	    eeprom_fine_byte(devpriv->eeprom_data
+			     [offset_eeprom_address(channel, range)]);
 	coarse_gain =
-		eeprom_coarse_byte(devpriv->
-		eeprom_data[gain_eeprom_address(channel, range)]);
+	    eeprom_coarse_byte(devpriv->eeprom_data
+			       [gain_eeprom_address(channel, range)]);
 	fine_gain =
-		eeprom_fine_byte(devpriv->
-		eeprom_data[gain_eeprom_address(channel, range)]);
+	    eeprom_fine_byte(devpriv->eeprom_data
+			     [gain_eeprom_address(channel, range)]);
 
 	/*  set caldacs */
 	cb_pcidda_write_caldac(dev, caldac_number(channel),
-		coarse_offset_channel(channel), coarse_offset);
+			       coarse_offset_channel(channel), coarse_offset);
 	cb_pcidda_write_caldac(dev, caldac_number(channel),
-		fine_offset_channel(channel), fine_offset);
+			       fine_offset_channel(channel), fine_offset);
 	cb_pcidda_write_caldac(dev, caldac_number(channel),
-		coarse_gain_channel(channel), coarse_gain);
+			       coarse_gain_channel(channel), coarse_gain);
 	cb_pcidda_write_caldac(dev, caldac_number(channel),
-		fine_gain_channel(channel), fine_gain);
+			       fine_gain_channel(channel), fine_gain);
 }
 
 /*
--- a/drivers/staging/comedi/drivers/cb_pcidio.c
+++ b/drivers/staging/comedi/drivers/cb_pcidio.c
@@ -63,23 +63,23 @@ struct pcidio_board {
 
 static const struct pcidio_board pcidio_boards[] = {
 	{
-	.name = "pci-dio24",
-	.n_8255 = 1,
-	.pcicontroler_badrindex = 1,
-	.dioregs_badrindex = 2,
-		},
+	 .name = "pci-dio24",
+	 .n_8255 = 1,
+	 .pcicontroler_badrindex = 1,
+	 .dioregs_badrindex = 2,
+	 },
 	{
-	.name = "pci-dio24h",
-	.n_8255 = 1,
-	.pcicontroler_badrindex = 1,
-	.dioregs_badrindex = 2,
-		},
+	 .name = "pci-dio24h",
+	 .n_8255 = 1,
+	 .pcicontroler_badrindex = 1,
+	 .dioregs_badrindex = 2,
+	 },
 	{
-	.name = "pci-dio48h",
-	.n_8255 = 2,
-	.pcicontroler_badrindex = 0,
-	.dioregs_badrindex = 1,
-		},
+	 .name = "pci-dio48h",
+	 .n_8255 = 2,
+	 .pcicontroler_badrindex = 0,
+	 .dioregs_badrindex = 1,
+	 },
 };
 
 /* This is used by modprobe to translate PCI IDs to drivers.  Should
@@ -87,10 +87,11 @@ static const struct pcidio_board pcidio_
 /* Please add your PCI vendor ID to comedidev.h, and it will be forwarded
  * upstream. */
 static DEFINE_PCI_DEVICE_TABLE(pcidio_pci_table) = {
-	{PCI_VENDOR_ID_CB, 0x0028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0014, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x000b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_CB, 0x0028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0014, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x000b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pcidio_pci_table);
@@ -127,7 +128,8 @@ struct pcidio_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcidio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcidio_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcidio_detach(struct comedi_device *dev);
 static struct comedi_driver driver_cb_pcidio = {
 	.driver_name = "cb_pcidio",
@@ -197,15 +199,13 @@ static int pcidio_attach(struct comedi_d
  */
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;
 		/*  loop through cards supported by this driver */
-		for (index = 0;
-			index < ARRAY_SIZE(pcidio_boards);
-			index++) {
+		for (index = 0; index < ARRAY_SIZE(pcidio_boards); index++) {
 			if (pcidio_pci_table[index].device != pcidev->device)
 				continue;
 
@@ -213,8 +213,7 @@ static int pcidio_attach(struct comedi_d
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
@@ -224,10 +223,10 @@ static int pcidio_attach(struct comedi_d
 	}
 
 	printk("No supported ComputerBoards/MeasurementComputing card found on "
-		"requested position\n");
+	       "requested position\n");
 	return -EIO;
 
-      found:
+found:
 
 /*
  * Initialize dev->board_name.  Note that we can use the "thisboard"
@@ -237,16 +236,17 @@ static int pcidio_attach(struct comedi_d
 
 	devpriv->pci_dev = pcidev;
 	printk("Found %s on bus %i, slot %i\n", thisboard->name,
-		devpriv->pci_dev->bus->number,
-		PCI_SLOT(devpriv->pci_dev->devfn));
+	       devpriv->pci_dev->bus->number,
+	       PCI_SLOT(devpriv->pci_dev->devfn));
 	if (comedi_pci_enable(pcidev, thisboard->name)) {
-		printk("cb_pcidio: failed to enable PCI device and request regions\n");
+		printk
+		    ("cb_pcidio: failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 	devpriv->dio_reg_base
-		=
-		pci_resource_start(devpriv->pci_dev,
-		pcidio_boards[index].dioregs_badrindex);
+	    =
+	    pci_resource_start(devpriv->pci_dev,
+			       pcidio_boards[index].dioregs_badrindex);
 
 /*
  * Allocate the subdevice structures.  alloc_subdevice() is a
@@ -257,9 +257,9 @@ static int pcidio_attach(struct comedi_d
 
 	for (i = 0; i < thisboard->n_8255; i++) {
 		subdev_8255_init(dev, dev->subdevices + i,
-			NULL, devpriv->dio_reg_base + i * 4);
+				 NULL, devpriv->dio_reg_base + i * 4);
 		printk(" subdev %d: base = 0x%lx\n", i,
-			devpriv->dio_reg_base + i * 4);
+		       devpriv->dio_reg_base + i * 4);
 	}
 
 	printk("attached\n");
--- a/drivers/staging/comedi/drivers/cb_pcimdas.c
+++ b/drivers/staging/comedi/drivers/cb_pcimdas.c
@@ -103,29 +103,31 @@ struct cb_pcimdas_board {
 
 static const struct cb_pcimdas_board cb_pcimdas_boards[] = {
 	{
-	.name = "PCIM-DAS1602/16",
-	.device_id = 0x56,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 16,
-	.ai_speed = 10000,	/* ?? */
-	.ao_nchan = 2,
-	.ao_bits = 12,
-	.has_ao_fifo = 0,	/* ?? */
-	.ao_scan_speed = 10000,
-			/* ?? */
-	.fifo_size = 1024,
-	.dio_bits = 24,
-	.has_dio = 1,
+	 .name = "PCIM-DAS1602/16",
+	 .device_id = 0x56,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 16,
+	 .ai_speed = 10000,	/* ?? */
+	 .ao_nchan = 2,
+	 .ao_bits = 12,
+	 .has_ao_fifo = 0,	/* ?? */
+	 .ao_scan_speed = 10000,
+	 /* ?? */
+	 .fifo_size = 1024,
+	 .dio_bits = 24,
+	 .has_dio = 1,
 /*	.ranges = &cb_pcimdas_ranges, */
-		},
+	 },
 };
 
 /* This is used by modprobe to translate PCI IDs to drivers.  Should
  * only be used for PCI and ISA-PnP devices */
 static DEFINE_PCI_DEVICE_TABLE(cb_pcimdas_pci_table) = {
-	{PCI_VENDOR_ID_COMPUTERBOARDS, 0x0056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, 0x0056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, cb_pcimdas_pci_table);
@@ -176,7 +178,8 @@ struct cb_pcimdas_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int cb_pcimdas_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int cb_pcimdas_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it);
 static int cb_pcimdas_detach(struct comedi_device *dev);
 static struct comedi_driver driver_cb_pcimdas = {
 	.driver_name = "cb_pcimdas",
@@ -185,12 +188,15 @@ static struct comedi_driver driver_cb_pc
 	.detach = cb_pcimdas_detach,
 };
 
-static int cb_pcimdas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcimdas_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcimdas_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcimdas_ai_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int cb_pcimdas_ao_winsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int cb_pcimdas_ao_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -198,7 +204,8 @@ static int cb_pcimdas_ao_rinsn(struct co
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int cb_pcimdas_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int cb_pcimdas_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;
@@ -219,22 +226,21 @@ static int cb_pcimdas_attach(struct come
 	printk("\n");
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
 		/*  loop through cards supported by this driver */
 		for (index = 0; index < N_BOARDS; index++) {
 			if (cb_pcimdas_boards[index].device_id !=
-				pcidev->device)
+			    pcidev->device)
 				continue;
 			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
@@ -245,13 +251,13 @@ static int cb_pcimdas_attach(struct come
 	}
 
 	printk("No supported ComputerBoards/MeasurementComputing card found on "
-		"requested position\n");
+	       "requested position\n");
 	return -EIO;
 
-      found:
+found:
 
 	printk("Found %s on bus %i, slot %i\n", cb_pcimdas_boards[index].name,
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	/*  Warn about non-tested features */
 	switch (thisboard->device_id) {
@@ -259,7 +265,7 @@ static int cb_pcimdas_attach(struct come
 		break;
 	default:
 		printk("THIS CARD IS UNSUPPORTED.\n"
-			"PLEASE REPORT USAGE TO <mocelet@sucs.org>\n");
+		       "PLEASE REPORT USAGE TO <mocelet@sucs.org>\n");
 	};
 
 	if (comedi_pci_enable(pcidev, "cb_pcimdas")) {
@@ -373,8 +379,9 @@ static int cb_pcimdas_detach(struct come
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int cb_pcimdas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcimdas_ai_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	unsigned int d;
@@ -438,8 +445,9 @@ static int cb_pcimdas_ai_rinsn(struct co
 	return n;
 }
 
-static int cb_pcimdas_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcimdas_ao_winsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -466,8 +474,9 @@ static int cb_pcimdas_ao_winsn(struct co
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int cb_pcimdas_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcimdas_ao_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
--- a/drivers/staging/comedi/drivers/cb_pcimdda.c
+++ b/drivers/staging/comedi/drivers/cb_pcimdda.c
@@ -118,16 +118,16 @@ enum DIO_METHODS {
 
 static const struct board_struct boards[] = {
 	{
-	.name = "cb_pcimdda06-16",
-	.device_id = PCI_ID_PCIM_DDA06_16,
-	.ao_chans = 6,
-	.ao_bits = 16,
-	.dio_chans = 24,
-	.dio_method = DIO_8255,
-	.dio_offset = 12,
-	.regs_badrindex = 3,
-	.reg_sz = 16,
-		}
+	 .name = "cb_pcimdda06-16",
+	 .device_id = PCI_ID_PCIM_DDA06_16,
+	 .ao_chans = 6,
+	 .ao_bits = 16,
+	 .dio_chans = 24,
+	 .dio_method = DIO_8255,
+	 .dio_offset = 12,
+	 .regs_badrindex = 3,
+	 .reg_sz = 16,
+	 }
 };
 
 /*
@@ -143,9 +143,10 @@ static const struct board_struct boards[
 /* Please add your PCI vendor ID to comedidev.h, and it will be forwarded
  * upstream. */
 static DEFINE_PCI_DEVICE_TABLE(pci_table) = {
-	{PCI_VENDOR_ID_COMPUTERBOARDS, PCI_ID_PCIM_DDA06_16, PCI_ANY_ID,
-		PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, PCI_ID_PCIM_DDA06_16, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci_table);
@@ -190,15 +191,15 @@ static struct comedi_driver cb_pcimdda_d
 
 MODULE_AUTHOR("Calin A. Culianu <calin@rtlab.org>");
 MODULE_DESCRIPTION("Comedi low-level driver for the Computerboards PCIM-DDA "
-	"series.  Currently only supports PCIM-DDA06-16 (which "
-	"also happens to be the only board in this series. :) ) ");
+		   "series.  Currently only supports PCIM-DDA06-16 (which "
+		   "also happens to be the only board in this series. :) ) ");
 MODULE_LICENSE("GPL");
 COMEDI_PCI_INITCLEANUP_NOMODULE(cb_pcimdda_driver, pci_table);
 
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
 static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
 
 /*---------------------------------------------------------------------------
   HELPER FUNCTION DECLARATIONS
@@ -207,7 +208,7 @@ static int ao_rinsn(struct comedi_device
 /* returns a maxdata value for a given n_bits */
 static inline unsigned int figure_out_maxdata(int bits)
 {
-	return ((unsigned int) 1 << bits) - 1;
+	return ((unsigned int)1 << bits) - 1;
 }
 
 /*
@@ -344,7 +345,7 @@ static int detach(struct comedi_device *
 
 		if (devpriv->attached_successfully && thisboard)
 			printk("comedi%d: %s: detached\n", dev->minor,
-				thisboard->name);
+			       thisboard->name);
 
 	}
 
@@ -352,7 +353,7 @@ static int detach(struct comedi_device *
 }
 
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -391,7 +392,7 @@ static int ao_winsn(struct comedi_device
    applications, I would imagine.
 */
 static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -431,8 +432,8 @@ static int probe(struct comedi_device *d
 	unsigned long registers;
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
@@ -444,8 +445,7 @@ static int probe(struct comedi_device *d
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
@@ -454,20 +454,21 @@ static int probe(struct comedi_device *d
 			devpriv->pci_dev = pcidev;
 			dev->board_ptr = boards + index;
 			if (comedi_pci_enable(pcidev, thisboard->name)) {
-				printk("cb_pcimdda: Failed to enable PCI device and request regions\n");
+				printk
+				    ("cb_pcimdda: Failed to enable PCI device and request regions\n");
 				return -EIO;
 			}
 			registers =
-				pci_resource_start(devpriv->pci_dev,
-				REGS_BADRINDEX);
+			    pci_resource_start(devpriv->pci_dev,
+					       REGS_BADRINDEX);
 			devpriv->registers = registers;
 			devpriv->dio_registers
-				= devpriv->registers + thisboard->dio_offset;
+			    = devpriv->registers + thisboard->dio_offset;
 			return 0;
 		}
 	}
 
 	printk("cb_pcimdda: No supported ComputerBoards/MeasurementComputing "
-		"card found at the requested position\n");
+	       "card found at the requested position\n");
 	return -ENODEV;
 }
--- a/drivers/staging/comedi/drivers/comedi_bond.c
+++ b/drivers/staging/comedi/drivers/comedi_bond.c
@@ -132,8 +132,8 @@ struct BondingBoard {
 
 static const struct BondingBoard bondingBoards[] = {
 	{
-		.name =	MODULE_NAME,
-	},
+	 .name = MODULE_NAME,
+	 },
 };
 
 /*
@@ -176,7 +176,8 @@ struct Private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int bonding_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int bonding_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int bonding_detach(struct comedi_device *dev);
 /** Build Private array of all devices.. */
 static int doDevConfig(struct comedi_device *dev, struct comedi_devconfig *it);
@@ -186,10 +187,10 @@ static void doDevUnconfig(struct comedi_
 static void *Realloc(const void *ptr, size_t len, size_t old_len);
 
 static struct comedi_driver driver_bonding = {
-      .driver_name =	MODULE_NAME,
-      .module =		THIS_MODULE,
-      .attach =		bonding_attach,
-      .detach =		bonding_detach,
+	.driver_name = MODULE_NAME,
+	.module = THIS_MODULE,
+	.attach = bonding_attach,
+	.detach = bonding_detach,
 	/* It is not necessary to implement the following members if you are
 	 * writing a driver for a ISA PnP or PCI card */
 	/* Most drivers will support multiple types of boards by
@@ -208,15 +209,18 @@ static struct comedi_driver driver_bondi
 	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
 	 * devices are such boards.
 	 */
-      .board_name =	&bondingBoards[0].name,
-      .offset =		sizeof(struct BondingBoard),
-      .num_names =	ARRAY_SIZE(bondingBoards),
+	.board_name = &bondingBoards[0].name,
+	.offset = sizeof(struct BondingBoard),
+	.num_names = ARRAY_SIZE(bondingBoards),
 };
 
-static int bonding_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+static int bonding_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
-static int bonding_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-				   struct comedi_insn *insn, unsigned int *data);
+static int bonding_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -224,7 +228,8 @@ static int bonding_dio_insn_config(struc
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int bonding_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int bonding_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 
@@ -293,7 +298,8 @@ static int bonding_detach(struct comedi_
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int bonding_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+static int bonding_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
 #define LSAMPL_BITS (sizeof(unsigned int)*8)
@@ -317,14 +323,14 @@ static int bonding_dio_insn_bits(struct 
 
 		/* Argh, we have >= LSAMPL_BITS chans.. take all bits */
 		if (bdev->nchans >= LSAMPL_BITS)
-			subdevMask = (unsigned int) (-1);
+			subdevMask = (unsigned int)(-1);
 
 		writeMask = (data[0] >> num_done) & subdevMask;
 		dataBits = (data[1] >> num_done) & subdevMask;
 
 		/* Read/Write the new digital lines */
 		if (comedi_dio_bitfield(bdev->dev, bdev->subdev, writeMask,
-				&dataBits) != 2)
+					&dataBits) != 2)
 			return -EINVAL;
 
 		/* Make room for the new bits in data[1], the return value */
@@ -340,7 +346,8 @@ static int bonding_dio_insn_bits(struct 
 	return insn->n;
 }
 
-static int bonding_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+static int bonding_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec), ret, io_bits = s->io_bits;
@@ -366,7 +373,7 @@ static int bonding_dio_insn_config(struc
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -435,7 +442,7 @@ static int doDevConfig(struct comedi_dev
 
 		/* Do DIO, as that's all we support now.. */
 		while ((sdev = comedi_find_subdevice_by_type(d, COMEDI_SUBD_DIO,
-					sdev + 1)) > -1) {
+							     sdev + 1)) > -1) {
 			nchans = comedi_get_n_channels(d, sdev);
 			if (nchans <= 0) {
 				ERROR("comedi_get_n_channels() returned %d "
@@ -465,8 +472,8 @@ static int doDevConfig(struct comedi_dev
 			/* ergh.. ugly.. we need to realloc :(  */
 			tmp = devpriv->ndevs * sizeof(bdev);
 			devpriv->devs =
-				Realloc(devpriv->devs,
-				++devpriv->ndevs * sizeof(bdev), tmp);
+			    Realloc(devpriv->devs,
+				    ++devpriv->ndevs * sizeof(bdev), tmp);
 			if (!devpriv->devs) {
 				ERROR("Could not allocate memory. "
 				      "Out of memory?");
@@ -478,10 +485,9 @@ static int doDevConfig(struct comedi_dev
 	/** Append dev:subdev to devpriv->name */
 				char buf[20];
 				int left =
-					MAX_BOARD_NAME - strlen(devpriv->name) -
-					1;
+				    MAX_BOARD_NAME - strlen(devpriv->name) - 1;
 				snprintf(buf, sizeof(buf), "%d:%d ", dev->minor,
-					bdev->subdev);
+					 bdev->subdev);
 				buf[sizeof(buf) - 1] = 0;
 				strncat(devpriv->name, buf, left);
 			}
--- a/drivers/staging/comedi/drivers/comedi_fc.c
+++ b/drivers/staging/comedi/drivers/comedi_fc.c
@@ -42,8 +42,8 @@ static void increment_scan_progress(stru
 }
 
 /* Writes an array of data points to comedi's buffer */
-unsigned int cfc_write_array_to_buffer(struct comedi_subdevice *subd, void *data,
-				       unsigned int num_bytes)
+unsigned int cfc_write_array_to_buffer(struct comedi_subdevice *subd,
+				       void *data, unsigned int num_bytes)
 {
 	struct comedi_async *async = subd->async;
 	unsigned int retval;
@@ -65,10 +65,11 @@ unsigned int cfc_write_array_to_buffer(s
 
 	return num_bytes;
 }
+
 EXPORT_SYMBOL(cfc_write_array_to_buffer);
 
-unsigned int cfc_read_array_from_buffer(struct comedi_subdevice *subd, void *data,
-					unsigned int num_bytes)
+unsigned int cfc_read_array_from_buffer(struct comedi_subdevice *subd,
+					void *data, unsigned int num_bytes)
 {
 	struct comedi_async *async = subd->async;
 
@@ -83,9 +84,11 @@ unsigned int cfc_read_array_from_buffer(
 
 	return num_bytes;
 }
+
 EXPORT_SYMBOL(cfc_read_array_from_buffer);
 
-unsigned int cfc_handle_events(struct comedi_device *dev, struct comedi_subdevice *subd)
+unsigned int cfc_handle_events(struct comedi_device *dev,
+			       struct comedi_subdevice *subd)
 {
 	unsigned int events = subd->async->events;
 
@@ -99,6 +102,7 @@ unsigned int cfc_handle_events(struct co
 
 	return events;
 }
+
 EXPORT_SYMBOL(cfc_handle_events);
 
 MODULE_AUTHOR("Frank Mori Hess <fmhess@users.sourceforge.net>");
--- a/drivers/staging/comedi/drivers/comedi_fc.h
+++ b/drivers/staging/comedi/drivers/comedi_fc.h
@@ -40,8 +40,8 @@ static inline unsigned int cfc_write_to_
 	return cfc_write_array_to_buffer(subd, &data, sizeof(data));
 };
 
-static inline unsigned int cfc_write_long_to_buffer(struct comedi_subdevice *subd,
-						    unsigned int data)
+static inline unsigned int cfc_write_long_to_buffer(struct comedi_subdevice
+						    *subd, unsigned int data)
 {
 	return cfc_write_array_to_buffer(subd, &data, sizeof(data));
 };
--- a/drivers/staging/comedi/drivers/comedi_parport.c
+++ b/drivers/staging/comedi/drivers/comedi_parport.c
@@ -91,13 +91,14 @@ pin, which can be used to wake up tasks.
 #define PARPORT_B 1
 #define PARPORT_C 2
 
-static int parport_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int parport_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int parport_detach(struct comedi_device *dev);
 static struct comedi_driver driver_parport = {
-      .driver_name =	"comedi_parport",
-      .module =		THIS_MODULE,
-      .attach =		parport_attach,
-      .detach =		parport_detach,
+	.driver_name = "comedi_parport",
+	.module = THIS_MODULE,
+	.attach = parport_attach,
+	.detach = parport_detach,
 };
 
 COMEDI_INITCLEANUP(driver_parport);
@@ -124,7 +125,8 @@ static int parport_insn_a(struct comedi_
 	return 2;
 }
 
-static int parport_insn_config_a(struct comedi_device *dev, struct comedi_subdevice *s,
+static int parport_insn_config_a(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
@@ -168,7 +170,8 @@ static int parport_insn_c(struct comedi_
 	return 2;
 }
 
-static int parport_intr_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+static int parport_intr_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
@@ -178,7 +181,8 @@ static int parport_intr_insn(struct come
 	return 2;
 }
 
-static int parport_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+static int parport_intr_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
 	int err = 0;
@@ -253,7 +257,8 @@ static int parport_intr_cmdtest(struct c
 	return 0;
 }
 
-static int parport_intr_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int parport_intr_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	devpriv->c_data |= 0x10;
 	outb(devpriv->c_data, dev->iobase + PARPORT_C);
@@ -263,7 +268,8 @@ static int parport_intr_cmd(struct comed
 	return 0;
 }
 
-static int parport_intr_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int parport_intr_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
 {
 	printk(KERN_DEBUG "parport_intr_cancel()\n");
 
@@ -292,7 +298,8 @@ static irqreturn_t parport_interrupt(int
 	return IRQ_HANDLED;
 }
 
-static int parport_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int parport_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	int ret;
 	unsigned int irq;
--- a/drivers/staging/comedi/drivers/comedi_test.c
+++ b/drivers/staging/comedi/drivers/comedi_test.c
@@ -69,11 +69,11 @@ struct waveform_board {
 
 static const struct waveform_board waveform_boards[] = {
 	{
-		.name =		"comedi_test",
-		.ai_chans =	N_CHANS,
-		.ai_bits =	16,
-		.have_dio =	0,
-	},
+	 .name = "comedi_test",
+	 .ai_chans = N_CHANS,
+	 .ai_bits = 16,
+	 .have_dio = 0,
+	 },
 };
 
 #define thisboard ((const struct waveform_board *)dev->board_ptr)
@@ -84,7 +84,7 @@ struct waveform_private {
 	struct timeval last;	/* time at which last timer interrupt occured */
 	unsigned int uvolt_amplitude;	/* waveform amplitude in microvolts */
 	unsigned long usec_period;	/* waveform period in microseconds */
-	unsigned long usec_current; /* current time (modulo waveform period) */
+	unsigned long usec_current;	/* current time (modulo waveform period) */
 	unsigned long usec_remainder;	/* usec since last scan; */
 	unsigned long ai_count;	/* number of conversions remaining */
 	unsigned int scan_period;	/* scan period in usec */
@@ -94,36 +94,42 @@ struct waveform_private {
 };
 #define devpriv ((struct waveform_private *)dev->private)
 
-static int waveform_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int waveform_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it);
 static int waveform_detach(struct comedi_device *dev);
 static struct comedi_driver driver_waveform = {
-      .driver_name =	"comedi_test",
-      .module =		THIS_MODULE,
-      .attach =		waveform_attach,
-      .detach =		waveform_detach,
-      .board_name =	&waveform_boards[0].name,
-      .offset =		sizeof(struct waveform_board),
-      .num_names =	ARRAY_SIZE(waveform_boards),
+	.driver_name = "comedi_test",
+	.module = THIS_MODULE,
+	.attach = waveform_attach,
+	.detach = waveform_detach,
+	.board_name = &waveform_boards[0].name,
+	.offset = sizeof(struct waveform_board),
+	.num_names = ARRAY_SIZE(waveform_boards),
 };
 
 COMEDI_INITCLEANUP(driver_waveform);
 
-static int waveform_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+static int waveform_ai_cmdtest(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       struct comedi_cmd *cmd);
-static int waveform_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int waveform_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int waveform_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+static int waveform_ai_cmd(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
+static int waveform_ai_cancel(struct comedi_device *dev,
+			      struct comedi_subdevice *s);
+static int waveform_ai_insn_read(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
-static int waveform_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int waveform_ao_insn_write(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data);
 static short fake_sawtooth(struct comedi_device *dev, unsigned int range,
-			     unsigned long current_time);
+			   unsigned long current_time);
 static short fake_squarewave(struct comedi_device *dev, unsigned int range,
-			       unsigned long current_time);
-static short fake_flatline(struct comedi_device *dev, unsigned int range,
 			     unsigned long current_time);
+static short fake_flatline(struct comedi_device *dev, unsigned int range,
+			   unsigned long current_time);
 static short fake_waveform(struct comedi_device *dev, unsigned int channel,
-			     unsigned int range, unsigned long current_time);
+			   unsigned int range, unsigned long current_time);
 
 /* 1000 nanosec in a microsec */
 static const int nano_per_micro = 1000;
@@ -132,9 +138,9 @@ static const int nano_per_micro = 1000;
 static const struct comedi_lrange waveform_ai_ranges = {
 	2,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 }
 };
 
 /*
@@ -144,7 +150,7 @@ static const struct comedi_lrange wavefo
 */
 static void waveform_ai_interrupt(unsigned long arg)
 {
-	struct comedi_device *dev = (struct comedi_device *) arg;
+	struct comedi_device *dev = (struct comedi_device *)arg;
 	struct comedi_async *async = dev->read_subdev->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int i, j;
@@ -156,27 +162,34 @@ static void waveform_ai_interrupt(unsign
 	do_gettimeofday(&now);
 
 	elapsed_time =
-		1000000 * (now.tv_sec - devpriv->last.tv_sec) + now.tv_usec -
-		devpriv->last.tv_usec;
+	    1000000 * (now.tv_sec - devpriv->last.tv_sec) + now.tv_usec -
+	    devpriv->last.tv_usec;
 	devpriv->last = now;
 	num_scans =
-		(devpriv->usec_remainder + elapsed_time) / devpriv->scan_period;
+	    (devpriv->usec_remainder + elapsed_time) / devpriv->scan_period;
 	devpriv->usec_remainder =
-		(devpriv->usec_remainder + elapsed_time) % devpriv->scan_period;
+	    (devpriv->usec_remainder + elapsed_time) % devpriv->scan_period;
 	async->events = 0;
 
 	for (i = 0; i < num_scans; i++) {
 		for (j = 0; j < cmd->chanlist_len; j++) {
 			cfc_write_to_buffer(dev->read_subdev,
-				fake_waveform(dev, CR_CHAN(cmd->chanlist[j]),
-					CR_RANGE(cmd->chanlist[j]),
-					devpriv->usec_current +
-					i * devpriv->scan_period +
-					j * devpriv->convert_period));
+					    fake_waveform(dev,
+							  CR_CHAN(cmd->
+								  chanlist[j]),
+							  CR_RANGE(cmd->
+								   chanlist[j]),
+							  devpriv->
+							  usec_current +
+							  i *
+							  devpriv->scan_period +
+							  j *
+							  devpriv->
+							  convert_period));
 		}
 		devpriv->ai_count++;
 		if (cmd->stop_src == TRIG_COUNT
-			&& devpriv->ai_count >= cmd->stop_arg) {
+		    && devpriv->ai_count >= cmd->stop_arg) {
 			async->events |= COMEDI_CB_EOA;
 			break;
 		}
@@ -193,7 +206,8 @@ static void waveform_ai_interrupt(unsign
 	comedi_event(dev, dev->read_subdev);
 }
 
-static int waveform_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int waveform_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int amplitude = it->options[0];
@@ -255,8 +269,8 @@ static int waveform_attach(struct comedi
 	devpriv->timer.data = (unsigned long)dev;
 
 	printk(KERN_INFO "comedi%d: comedi_test: "
-		"%i microvolt, %li microsecond waveform attached\n", dev->minor,
-		devpriv->uvolt_amplitude, devpriv->usec_period);
+	       "%i microvolt, %li microsecond waveform attached\n", dev->minor,
+	       devpriv->uvolt_amplitude, devpriv->usec_period);
 	return 1;
 }
 
@@ -270,7 +284,8 @@ static int waveform_detach(struct comedi
 	return 0;
 }
 
-static int waveform_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+static int waveform_ai_cmdtest(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       struct comedi_cmd *cmd)
 {
 	int err = 0;
@@ -336,10 +351,10 @@ static int waveform_ai_cmdtest(struct co
 			err++;
 		}
 		if (cmd->convert_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->chanlist_len) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->chanlist_len;
+			    cmd->convert_arg * cmd->chanlist_len;
 			err++;
 		}
 	}
@@ -377,8 +392,8 @@ static int waveform_ai_cmdtest(struct co
 		tmp = cmd->scan_begin_arg;
 		/* round to nearest microsec */
 		cmd->scan_begin_arg =
-			nano_per_micro * ((tmp +
-				(nano_per_micro / 2)) / nano_per_micro);
+		    nano_per_micro * ((tmp +
+				       (nano_per_micro / 2)) / nano_per_micro);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -386,8 +401,8 @@ static int waveform_ai_cmdtest(struct co
 		tmp = cmd->convert_arg;
 		/* round to nearest microsec */
 		cmd->convert_arg =
-			nano_per_micro * ((tmp +
-				(nano_per_micro / 2)) / nano_per_micro);
+		    nano_per_micro * ((tmp +
+				       (nano_per_micro / 2)) / nano_per_micro);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -398,13 +413,14 @@ static int waveform_ai_cmdtest(struct co
 	return 0;
 }
 
-static int waveform_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int waveform_ai_cmd(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (cmd->flags & TRIG_RT) {
 		comedi_error(dev,
-			"commands at RT priority not supported in this driver");
+			     "commands at RT priority not supported in this driver");
 		return -1;
 	}
 
@@ -430,7 +446,8 @@ static int waveform_ai_cmd(struct comedi
 	return 0;
 }
 
-static int waveform_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int waveform_ai_cancel(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	devpriv->timer_running = 0;
 	del_timer(&devpriv->timer);
@@ -438,12 +455,13 @@ static int waveform_ai_cancel(struct com
 }
 
 static short fake_sawtooth(struct comedi_device *dev, unsigned int range_index,
-			     unsigned long current_time)
+			   unsigned long current_time)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int offset = s->maxdata / 2;
 	u64 value;
-	const struct comedi_krange *krange = &s->range_table->range[range_index];
+	const struct comedi_krange *krange =
+	    &s->range_table->range[range_index];
 	u64 binary_amplitude;
 
 	binary_amplitude = s->maxdata;
@@ -458,13 +476,16 @@ static short fake_sawtooth(struct comedi
 
 	return offset + value;
 }
-static short fake_squarewave(struct comedi_device *dev, unsigned int range_index,
-			       unsigned long current_time)
+
+static short fake_squarewave(struct comedi_device *dev,
+			     unsigned int range_index,
+			     unsigned long current_time)
 {
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int offset = s->maxdata / 2;
 	u64 value;
-	const struct comedi_krange *krange = &s->range_table->range[range_index];
+	const struct comedi_krange *krange =
+	    &s->range_table->range[range_index];
 	current_time %= devpriv->usec_period;
 
 	value = s->maxdata;
@@ -478,14 +499,14 @@ static short fake_squarewave(struct come
 }
 
 static short fake_flatline(struct comedi_device *dev, unsigned int range_index,
-			     unsigned long current_time)
+			   unsigned long current_time)
 {
 	return dev->read_subdev->maxdata / 2;
 }
 
 /* generates a different waveform depending on what channel is read */
 static short fake_waveform(struct comedi_device *dev, unsigned int channel,
-			     unsigned int range, unsigned long current_time)
+			   unsigned int range, unsigned long current_time)
 {
 	enum {
 		SAWTOOTH_CHAN,
@@ -505,7 +526,8 @@ static short fake_waveform(struct comedi
 	return fake_flatline(dev, range, current_time);
 }
 
-static int waveform_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+static int waveform_ai_insn_read(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
 	int i, chan = CR_CHAN(insn->chanspec);
@@ -516,7 +538,8 @@ static int waveform_ai_insn_read(struct 
 	return insn->n;
 }
 
-static int waveform_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int waveform_ao_insn_write(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
 	int i, chan = CR_CHAN(insn->chanspec);
--- a/drivers/staging/comedi/drivers/contec_pci_dio.c
+++ b/drivers/staging/comedi/drivers/contec_pci_dio.c
@@ -57,9 +57,10 @@ static const struct contec_board contec_
 
 #define PCI_DEVICE_ID_PIO1616L 0x8172
 static DEFINE_PCI_DEVICE_TABLE(contec_pci_table) = {
-	{PCI_VENDOR_ID_CONTEC, PCI_DEVICE_ID_PIO1616L, PCI_ANY_ID, PCI_ANY_ID,
-		0, 0, PIO1616L},
-	{0}
+	{
+	PCI_VENDOR_ID_CONTEC, PCI_DEVICE_ID_PIO1616L, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, PIO1616L}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, contec_pci_table);
@@ -75,7 +76,8 @@ struct contec_private {
 
 #define devpriv ((struct contec_private *)dev->private)
 
-static int contec_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int contec_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int contec_detach(struct comedi_device *dev);
 static struct comedi_driver driver_contec = {
 	.driver_name = "contec_pci_dio",
@@ -85,14 +87,16 @@ static struct comedi_driver driver_conte
 };
 
 /* Classic digital IO */
-static int contec_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int contec_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int contec_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int contec_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 #if 0
 static int contec_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			  struct comedi_cmd *cmd);
 
 static int contec_ns_to_timer(unsigned int *ns, int round);
 #endif
@@ -113,22 +117,22 @@ static int contec_attach(struct comedi_d
 		return -ENOMEM;
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 
 		if (pcidev->vendor == PCI_VENDOR_ID_CONTEC &&
-			pcidev->device == PCI_DEVICE_ID_PIO1616L) {
+		    pcidev->device == PCI_DEVICE_ID_PIO1616L) {
 			if (it->options[0] || it->options[1]) {
 				/* Check bus and slot. */
 				if (it->options[0] != pcidev->bus->number ||
-					it->options[1] !=
-					PCI_SLOT(pcidev->devfn)) {
+				    it->options[1] != PCI_SLOT(pcidev->devfn)) {
 					continue;
 				}
 			}
 			devpriv->pci_dev = pcidev;
 			if (comedi_pci_enable(pcidev, "contec_pci_dio")) {
-				printk("error enabling PCI device and request regions!\n");
+				printk
+				    ("error enabling PCI device and request regions!\n");
 				return -EIO;
 			}
 			dev->iobase = pci_resource_start(pcidev, 0);
@@ -180,7 +184,7 @@ static int contec_detach(struct comedi_d
 
 #if 0
 static int contec_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			  struct comedi_cmd *cmd)
 {
 	printk("contec_cmdtest called\n");
 	return 0;
@@ -192,8 +196,9 @@ static int contec_ns_to_timer(unsigned i
 }
 #endif
 
-static int contec_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int contec_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
 	printk("contec_do_insn_bits called\n");
@@ -206,14 +211,15 @@ static int contec_do_insn_bits(struct co
 		s->state &= ~data[0];
 		s->state |= data[0] & data[1];
 		printk("  out: %d on %lx\n", s->state,
-			dev->iobase + thisboard->out_offs);
+		       dev->iobase + thisboard->out_offs);
 		outw(s->state, dev->iobase + thisboard->out_offs);
 	}
 	return 2;
 }
 
-static int contec_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int contec_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
 	printk("contec_di_insn_bits called\n");
--- a/drivers/staging/comedi/drivers/daqboard2000.c
+++ b/drivers/staging/comedi/drivers/daqboard2000.c
@@ -107,13 +107,10 @@ Configuration options:
 		  |    	   +---------------- Unipolar
 		  +------------------------- Correction gain high
 
-
-
    999. The card seems to have an incredible amount of capabilities, but
         trying to reverse engineer them from the Windows source is beyond my
 	patience.
 
-
  */
 
 #include "../comedidev.h"
@@ -147,25 +144,32 @@ Configuration options:
 
 /* Available ranges */
 static const struct comedi_lrange range_daqboard2000_ai = { 13, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(-0.625, 0.625),
-			RANGE(-0.3125, 0.3125),
-			RANGE(-0.156, 0.156),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25),
-			RANGE(0, 0.625),
-			RANGE(0, 0.3125)
-	}
+								 RANGE(-10, 10),
+								 RANGE(-5, 5),
+								 RANGE(-2.5,
+								       2.5),
+								 RANGE(-1.25,
+								       1.25),
+								 RANGE(-0.625,
+								       0.625),
+								 RANGE(-0.3125,
+								       0.3125),
+								 RANGE(-0.156,
+								       0.156),
+								 RANGE(0, 10),
+								 RANGE(0, 5),
+								 RANGE(0, 2.5),
+								 RANGE(0, 1.25),
+								 RANGE(0,
+								       0.625),
+								 RANGE(0,
+								       0.3125)
+								 }
 };
 
 static const struct comedi_lrange range_daqboard2000_ao = { 1, {
-			RANGE(-10, 10)
-	}
+								RANGE(-10, 10)
+								}
 };
 
 struct daqboard2000_hw {
@@ -297,7 +301,8 @@ struct daqboard2000_hw {
 #define DAQBOARD2000_PosRefDacSelect             0x0100
 #define DAQBOARD2000_NegRefDacSelect             0x0000
 
-static int daqboard2000_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int daqboard2000_attach(struct comedi_device *dev,
+			       struct comedi_devconfig *it);
 static int daqboard2000_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver_daqboard2000 = {
@@ -320,8 +325,9 @@ static const struct daq200_boardtype boa
 #define this_board ((const struct daq200_boardtype *)dev->board_ptr)
 
 static DEFINE_PCI_DEVICE_TABLE(daqboard2000_pci_table) = {
-	{0x1616, 0x0409, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	0x1616, 0x0409, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, daqboard2000_pci_table);
@@ -394,17 +400,18 @@ static void setup_sampling(struct comedi
 	writeAcqScanListEntry(dev, word3);
 }
 
-static int daqboard2000_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqboard2000_ai_insn_read(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 	int i;
 	struct daqboard2000_hw *fpga = devpriv->daq;
 	int gain, chan, timeout;
 
 	fpga->acqControl =
-		DAQBOARD2000_AcqResetScanListFifo |
-		DAQBOARD2000_AcqResetResultsFifo |
-		DAQBOARD2000_AcqResetConfigPipe;
+	    DAQBOARD2000_AcqResetScanListFifo |
+	    DAQBOARD2000_AcqResetResultsFifo | DAQBOARD2000_AcqResetConfigPipe;
 
 	/* If pacer clock is not set to some high value (> 10 us), we
 	   risk multiple samples to be put into the result FIFO. */
@@ -436,9 +443,8 @@ static int daqboard2000_ai_insn_read(str
 			/* udelay(2); */
 		}
 		for (timeout = 0; timeout < 20; timeout++) {
-			if (fpga->
-				acqControl &
-				DAQBOARD2000_AcqResultsFIFOHasValidData) {
+			if (fpga->acqControl &
+			    DAQBOARD2000_AcqResultsFIFOHasValidData) {
 				break;
 			}
 			/* udelay(2); */
@@ -451,8 +457,10 @@ static int daqboard2000_ai_insn_read(str
 	return i;
 }
 
-static int daqboard2000_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqboard2000_ao_insn_read(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -464,8 +472,10 @@ static int daqboard2000_ao_insn_read(str
 	return i;
 }
 
-static int daqboard2000_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqboard2000_ao_insn_write(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -521,7 +531,7 @@ static void daqboard2000_pulseProgPin(st
 	writel(DAQBOARD2000_SECRProgPinHi, devpriv->plx + 0x6c);
 	udelay(10000);
 	writel(DAQBOARD2000_SECRProgPinLo, devpriv->plx + 0x6c);
-	udelay(10000);	/* Not in the original code, but I like symmetry... */
+	udelay(10000);		/* Not in the original code, but I like symmetry... */
 }
 
 static int daqboard2000_pollCPLD(struct comedi_device *dev, int mask)
@@ -550,14 +560,14 @@ static int daqboard2000_writeCPLD(struct
 	udelay(10);
 	writew(data, devpriv->daq + 0x1000);
 	if ((readw(devpriv->daq + 0x1000) & DAQBOARD2000_CPLD_INIT) ==
-		DAQBOARD2000_CPLD_INIT) {
+	    DAQBOARD2000_CPLD_INIT) {
 		result = 1;
 	}
 	return result;
 }
 
 static int initialize_daqboard2000(struct comedi_device *dev,
-	unsigned char *cpld_array, int len)
+				   unsigned char *cpld_array, int len)
 {
 	int result = -EIO;
 	/* Read the serial EEPROM control register */
@@ -585,7 +595,7 @@ static int initialize_daqboard2000(struc
 		if (daqboard2000_pollCPLD(dev, DAQBOARD2000_CPLD_INIT)) {
 			for (i = 0; i < len; i++) {
 				if (cpld_array[i] == 0xff
-					&& cpld_array[i + 1] == 0x20) {
+				    && cpld_array[i + 1] == 0x20) {
 #ifdef DEBUG_EEPROM
 					printk("Preamble found at %d\n", i);
 #endif
@@ -594,8 +604,7 @@ static int initialize_daqboard2000(struc
 			}
 			for (; i < len; i += 2) {
 				int data =
-					(cpld_array[i] << 8) + cpld_array[i +
-					1];
+				    (cpld_array[i] << 8) + cpld_array[i + 1];
 				if (!daqboard2000_writeCPLD(dev, data)) {
 					break;
 				}
@@ -702,7 +711,7 @@ rmmod daqboard2000 ; rmmod comedi; make 
 */
 
 static int daqboard2000_8255_cb(int dir, int port, int data,
-	unsigned long ioaddr)
+				unsigned long ioaddr)
 {
 	int result = 0;
 	if (dir) {
@@ -718,7 +727,8 @@ static int daqboard2000_8255_cb(int dir,
 	return result;
 }
 
-static int daqboard2000_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int daqboard2000_attach(struct comedi_device *dev,
+			       struct comedi_devconfig *it)
 {
 	int result = 0;
 	struct comedi_subdevice *s;
@@ -737,21 +747,20 @@ static int daqboard2000_attach(struct co
 		return -ENOMEM;
 	}
 	for (card = pci_get_device(0x1616, 0x0409, NULL);
-		card != NULL;
-		card = pci_get_device(0x1616, 0x0409, card)) {
+	     card != NULL; card = pci_get_device(0x1616, 0x0409, card)) {
 		if (bus || slot) {
 			/* requested particular bus/slot */
 			if (card->bus->number != bus ||
-				PCI_SLOT(card->devfn) != slot) {
+			    PCI_SLOT(card->devfn) != slot) {
 				continue;
 			}
 		}
-		break;  /* found one */
+		break;		/* found one */
 	}
 	if (!card) {
 		if (bus || slot)
 			printk(" no daqboard2000 found at bus/slot: %d/%d\n",
-				bus, slot);
+			       bus, slot);
 		else
 			printk(" no daqboard2000 found\n");
 		return -EIO;
@@ -759,8 +768,8 @@ static int daqboard2000_attach(struct co
 		u32 id;
 		int i;
 		devpriv->pci_dev = card;
-		id = ((u32) card->subsystem_device << 16) | card->
-			subsystem_vendor;
+		id = ((u32) card->
+		      subsystem_device << 16) | card->subsystem_vendor;
 		for (i = 0; i < n_boardtypes; i++) {
 			if (boardtypes[i].id == id) {
 				printk(" %s", boardtypes[i].name);
@@ -768,7 +777,9 @@ static int daqboard2000_attach(struct co
 			}
 		}
 		if (!dev->board_ptr) {
-			printk(" unknown subsystem id %08x (pretend it is an ids2)", id);
+			printk
+			    (" unknown subsystem id %08x (pretend it is an ids2)",
+			     id);
 			dev->board_ptr = boardtypes;
 		}
 	}
@@ -780,9 +791,9 @@ static int daqboard2000_attach(struct co
 	}
 	devpriv->got_regions = 1;
 	devpriv->plx =
-		ioremap(pci_resource_start(card, 0), DAQBOARD2000_PLX_SIZE);
+	    ioremap(pci_resource_start(card, 0), DAQBOARD2000_PLX_SIZE);
 	devpriv->daq =
-		ioremap(pci_resource_start(card, 2), DAQBOARD2000_DAQ_SIZE);
+	    ioremap(pci_resource_start(card, 2), DAQBOARD2000_DAQ_SIZE);
 	if (!devpriv->plx || !devpriv->daq) {
 		return -ENOMEM;
 	}
@@ -844,10 +855,10 @@ static int daqboard2000_attach(struct co
 
 	s = dev->subdevices + 2;
 	result = subdev_8255_init(dev, s, daqboard2000_8255_cb,
-		(unsigned long)(dev->iobase + 0x40));
+				  (unsigned long)(dev->iobase + 0x40));
 
 	printk("\n");
-      out:
+out:
 	return result;
 }
 
--- a/drivers/staging/comedi/drivers/das08.c
+++ b/drivers/staging/comedi/drivers/das08.c
@@ -155,60 +155,66 @@ driver.
 /* gainlist same as _pgx_ below */
 
 static int das08_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int das08_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int das08_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das08jr_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das08jr_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das08jr_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das08ao_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
+static int das08jr_di_rbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das08jr_do_wbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das08jr_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das08ao_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static void i8254_set_mode_low(unsigned int base, int channel,
-	unsigned int mode);
+			       unsigned int mode);
 
 static const struct comedi_lrange range_das08_pgl = { 9, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-	}
+							  BIP_RANGE(10),
+							  BIP_RANGE(5),
+							  BIP_RANGE(2.5),
+							  BIP_RANGE(1.25),
+							  BIP_RANGE(0.625),
+							  UNI_RANGE(10),
+							  UNI_RANGE(5),
+							  UNI_RANGE(2.5),
+							  UNI_RANGE(1.25)
+							  }
 };
+
 static const struct comedi_lrange range_das08_pgh = { 12, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.01),
-			BIP_RANGE(0.005),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01),
-	}
+							   BIP_RANGE(10),
+							   BIP_RANGE(5),
+							   BIP_RANGE(1),
+							   BIP_RANGE(0.5),
+							   BIP_RANGE(0.1),
+							   BIP_RANGE(0.05),
+							   BIP_RANGE(0.01),
+							   BIP_RANGE(0.005),
+							   UNI_RANGE(10),
+							   UNI_RANGE(1),
+							   UNI_RANGE(0.1),
+							   UNI_RANGE(0.01),
+							   }
 };
+
 static const struct comedi_lrange range_das08_pgm = { 9, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.01),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01)
-	}
+							  BIP_RANGE(10),
+							  BIP_RANGE(5),
+							  BIP_RANGE(0.5),
+							  BIP_RANGE(0.05),
+							  BIP_RANGE(0.01),
+							  UNI_RANGE(10),
+							  UNI_RANGE(1),
+							  UNI_RANGE(0.1),
+							  UNI_RANGE(0.01)
+							  }
 };				/*
 				   cio-das08jr.pdf
 
@@ -234,7 +240,7 @@ static const struct comedi_lrange *const
 };
 
 static const int das08_pgh_gainlist[] =
-	{ 8, 0, 10, 2, 12, 4, 14, 6, 1, 3, 5, 7 };
+    { 8, 0, 10, 2, 12, 4, 14, 6, 1, 3, 5, 7 };
 static const int das08_pgl_gainlist[] = { 8, 0, 2, 4, 6, 1, 3, 5, 7 };
 static const int das08_pgm_gainlist[] = { 8, 0, 10, 12, 14, 9, 11, 13, 15 };
 
@@ -248,260 +254,261 @@ static const int *const das08_gainlists[
 
 static const struct das08_board_struct das08_boards[] = {
 	{
-	.name = "isa-das08",	/*  cio-das08.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pg_none,
-	.ai_encoding = das08_encode12,
-	.ao = NULL,
-	.ao_nbits = 12,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 8,
-	.i8254_offset = 4,
-	.iosize = 16,	/*  unchecked */
-		},
-	{
-	.name = "das08-pgm",	/*  cio-das08pgx.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pgm,
-	.ai_encoding = das08_encode12,
-	.ao = NULL,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 0,
-	.i8254_offset = 0x04,
-	.iosize = 16,	/*  unchecked */
-		},
-	{
-	.name = "das08-pgh",	/*  cio-das08pgx.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pgh,
-	.ai_encoding = das08_encode12,
-	.ao = NULL,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 0,
-	.i8254_offset = 0x04,
-	.iosize = 16,	/*  unchecked */
-		},
-	{
-	.name = "das08-pgl",	/*  cio-das08pgx.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pgl,
-	.ai_encoding = das08_encode12,
-	.ao = NULL,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 0,
-	.i8254_offset = 0x04,
-	.iosize = 16,	/*  unchecked */
-		},
-	{
-	.name = "das08-aoh",	/*  cio-das08_aox.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pgh,
-	.ai_encoding = das08_encode12,
-	.ao = das08ao_ao_winsn,	/*  8 */
-	.ao_nbits = 12,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 0x0c,
-	.i8254_offset = 0x04,
-	.iosize = 16,	/*  unchecked */
-		},
-	{
-	.name = "das08-aol",	/*  cio-das08_aox.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pgl,
-	.ai_encoding = das08_encode12,
-	.ao = das08ao_ao_winsn,	/*  8 */
-	.ao_nbits = 12,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 0x0c,
-	.i8254_offset = 0x04,
-	.iosize = 16,	/*  unchecked */
-		},
-	{
-	.name = "das08-aom",	/*  cio-das08_aox.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pgm,
-	.ai_encoding = das08_encode12,
-	.ao = das08ao_ao_winsn,	/*  8 */
-	.ao_nbits = 12,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 0x0c,
-	.i8254_offset = 0x04,
-	.iosize = 16,	/*  unchecked */
-		},
-	{
-	.name = "das08/jr-ao",	/*  cio-das08-jr-ao.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pg_none,
-	.ai_encoding = das08_encode12,
-	.ao = das08jr_ao_winsn,
-	.ao_nbits = 12,
-	.di = das08jr_di_rbits,
-	.do_ = das08jr_do_wbits,
-	.do_nchan = 8,
-	.i8255_offset = 0,
-	.i8254_offset = 0,
-	.iosize = 16,	/*  unchecked */
-		},
-	{
-	.name = "das08jr-16-ao",	/*  cio-das08jr-16-ao.pdf */
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_pg = das08_pg_none,
-	.ai_encoding = das08_encode12,
-	.ao = das08jr_ao_winsn,
-	.ao_nbits = 16,
-	.di = das08jr_di_rbits,
-	.do_ = das08jr_do_wbits,
-	.do_nchan = 8,
-	.i8255_offset = 0,
-	.i8254_offset = 0x04,
-	.iosize = 16,	/*  unchecked */
-		},
+	 .name = "isa-das08",	/*  cio-das08.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pg_none,
+	 .ai_encoding = das08_encode12,
+	 .ao = NULL,
+	 .ao_nbits = 12,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 8,
+	 .i8254_offset = 4,
+	 .iosize = 16,		/*  unchecked */
+	 },
+	{
+	 .name = "das08-pgm",	/*  cio-das08pgx.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pgm,
+	 .ai_encoding = das08_encode12,
+	 .ao = NULL,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x04,
+	 .iosize = 16,		/*  unchecked */
+	 },
+	{
+	 .name = "das08-pgh",	/*  cio-das08pgx.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pgh,
+	 .ai_encoding = das08_encode12,
+	 .ao = NULL,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x04,
+	 .iosize = 16,		/*  unchecked */
+	 },
+	{
+	 .name = "das08-pgl",	/*  cio-das08pgx.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pgl,
+	 .ai_encoding = das08_encode12,
+	 .ao = NULL,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x04,
+	 .iosize = 16,		/*  unchecked */
+	 },
+	{
+	 .name = "das08-aoh",	/*  cio-das08_aox.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pgh,
+	 .ai_encoding = das08_encode12,
+	 .ao = das08ao_ao_winsn,	/*  8 */
+	 .ao_nbits = 12,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 0x0c,
+	 .i8254_offset = 0x04,
+	 .iosize = 16,		/*  unchecked */
+	 },
+	{
+	 .name = "das08-aol",	/*  cio-das08_aox.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pgl,
+	 .ai_encoding = das08_encode12,
+	 .ao = das08ao_ao_winsn,	/*  8 */
+	 .ao_nbits = 12,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 0x0c,
+	 .i8254_offset = 0x04,
+	 .iosize = 16,		/*  unchecked */
+	 },
+	{
+	 .name = "das08-aom",	/*  cio-das08_aox.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pgm,
+	 .ai_encoding = das08_encode12,
+	 .ao = das08ao_ao_winsn,	/*  8 */
+	 .ao_nbits = 12,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 0x0c,
+	 .i8254_offset = 0x04,
+	 .iosize = 16,		/*  unchecked */
+	 },
+	{
+	 .name = "das08/jr-ao",	/*  cio-das08-jr-ao.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pg_none,
+	 .ai_encoding = das08_encode12,
+	 .ao = das08jr_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das08jr_di_rbits,
+	 .do_ = das08jr_do_wbits,
+	 .do_nchan = 8,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0,
+	 .iosize = 16,		/*  unchecked */
+	 },
+	{
+	 .name = "das08jr-16-ao",	/*  cio-das08jr-16-ao.pdf */
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_pg = das08_pg_none,
+	 .ai_encoding = das08_encode12,
+	 .ao = das08jr_ao_winsn,
+	 .ao_nbits = 16,
+	 .di = das08jr_di_rbits,
+	 .do_ = das08jr_do_wbits,
+	 .do_nchan = 8,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x04,
+	 .iosize = 16,		/*  unchecked */
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "das08",	/*  pci-das08 */
-	.id = PCI_DEVICE_ID_PCIDAS08,
-	.bustype = pci,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_bipolar5,
-	.ai_encoding = das08_encode12,
-	.ao = NULL,
-	.ao_nbits = 0,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 0,
-	.i8254_offset = 4,
-	.iosize = 8,
-		},
-#endif
-	{
-	.name = "pc104-das08",
-	.bustype = pc104,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_pg_none,
-	.ai_encoding = das08_encode12,
-	.ao = NULL,
-	.ao_nbits = 0,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 4,
-	.i8255_offset = 0,
-	.i8254_offset = 4,
-	.iosize = 16,	/*  unchecked */
-		},
+	 .name = "das08",	/*  pci-das08 */
+	 .id = PCI_DEVICE_ID_PCIDAS08,
+	 .bustype = pci,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_bipolar5,
+	 .ai_encoding = das08_encode12,
+	 .ao = NULL,
+	 .ao_nbits = 0,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 0,
+	 .i8254_offset = 4,
+	 .iosize = 8,
+	 },
+#endif
+	{
+	 .name = "pc104-das08",
+	 .bustype = pc104,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_pg_none,
+	 .ai_encoding = das08_encode12,
+	 .ao = NULL,
+	 .ao_nbits = 0,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 4,
+	 .i8255_offset = 0,
+	 .i8254_offset = 4,
+	 .iosize = 16,		/*  unchecked */
+	 },
 #if 0
 	{
-	.name = "das08/f",
-		},
+	 .name = "das08/f",
+	 },
 	{
-	.name = "das08jr",
-		},
+	 .name = "das08jr",
+	 },
 #endif
 	{
-	.name = "das08jr/16",
-	.bustype = isa,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_pg = das08_pg_none,
-	.ai_encoding = das08_encode16,
-	.ao = NULL,
-	.ao_nbits = 0,
-	.di = das08jr_di_rbits,
-	.do_ = das08jr_do_wbits,
-	.do_nchan = 8,
-	.i8255_offset = 0,
-	.i8254_offset = 0,
-	.iosize = 16,	/*  unchecked */
-		},
+	 .name = "das08jr/16",
+	 .bustype = isa,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_pg = das08_pg_none,
+	 .ai_encoding = das08_encode16,
+	 .ao = NULL,
+	 .ao_nbits = 0,
+	 .di = das08jr_di_rbits,
+	 .do_ = das08jr_do_wbits,
+	 .do_nchan = 8,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0,
+	 .iosize = 16,		/*  unchecked */
+	 },
 #if 0
 	{
-	.name = "das48-pga",	/*  cio-das48-pga.pdf */
-		},
+	 .name = "das48-pga",	/*  cio-das48-pga.pdf */
+	 },
 	{
-	.name = "das08-pga-g2",	/*  a KM board */
-		},
+	 .name = "das08-pga-g2",	/*  a KM board */
+	 },
 #endif
 };
 
 #ifdef CONFIG_COMEDI_PCMCIA
 struct das08_board_struct das08_cs_boards[NUM_DAS08_CS_BOARDS] = {
 	{
-	.name = "pcm-das08",
-	.id = 0x0,	/*  XXX */
-	.bustype = pcmcia,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_bipolar5,
-	.ai_encoding = das08_pcm_encode12,
-	.ao = NULL,
-	.ao_nbits = 0,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 3,
-	.i8255_offset = 0,
-	.i8254_offset = 0,
-	.iosize = 16,
-		},
+	 .name = "pcm-das08",
+	 .id = 0x0,		/*  XXX */
+	 .bustype = pcmcia,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_bipolar5,
+	 .ai_encoding = das08_pcm_encode12,
+	 .ao = NULL,
+	 .ao_nbits = 0,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 3,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0,
+	 .iosize = 16,
+	 },
 	/*  duplicate so driver name can be used also */
 	{
-	.name = "das08_cs",
-	.id = 0x0,	/*  XXX */
-	.bustype = pcmcia,
-	.ai = das08_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_pg = das08_bipolar5,
-	.ai_encoding = das08_pcm_encode12,
-	.ao = NULL,
-	.ao_nbits = 0,
-	.di = das08_di_rbits,
-	.do_ = das08_do_wbits,
-	.do_nchan = 3,
-	.i8255_offset = 0,
-	.i8254_offset = 0,
-	.iosize = 16,
-		},
+	 .name = "das08_cs",
+	 .id = 0x0,		/*  XXX */
+	 .bustype = pcmcia,
+	 .ai = das08_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_pg = das08_bipolar5,
+	 .ai_encoding = das08_pcm_encode12,
+	 .ao = NULL,
+	 .ao_nbits = 0,
+	 .di = das08_di_rbits,
+	 .do_ = das08_do_wbits,
+	 .do_nchan = 3,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0,
+	 .iosize = 16,
+	 },
 };
 #endif
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(das08_pci_table) = {
-	{PCI_VENDOR_ID_COMPUTERBOARDS, PCI_DEVICE_ID_PCIDAS08, PCI_ANY_ID,
-		PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_COMPUTERBOARDS, PCI_DEVICE_ID_PCIDAS08,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, das08_pci_table);
@@ -513,7 +520,7 @@ MODULE_DEVICE_TABLE(pci, das08_pci_table
 #define TIMEOUT 100000
 
 static int das08_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan;
@@ -538,7 +545,7 @@ static int das08_ai_rinsn(struct comedi_
 		/* set gain/range */
 		range = CR_RANGE(insn->chanspec);
 		outb(devpriv->pg_gainlist[range],
-			dev->iobase + DAS08AO_GAIN_CONTROL);
+		     dev->iobase + DAS08AO_GAIN_CONTROL);
 	}
 
 	for (n = 0; n < insn->n; n++) {
@@ -580,7 +587,7 @@ static int das08_ai_rinsn(struct comedi_
 }
 
 static int das08_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = 0;
 	data[1] = DAS08_IP(inb(dev->iobase + DAS08_STATUS));
@@ -589,7 +596,7 @@ static int das08_di_rbits(struct comedi_
 }
 
 static int das08_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int wbits;
 
@@ -611,8 +618,9 @@ static int das08_do_wbits(struct comedi_
 	return 2;
 }
 
-static int das08jr_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das08jr_di_rbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = 0;
 	data[1] = inb(dev->iobase + DAS08JR_DIO);
@@ -620,8 +628,9 @@ static int das08jr_di_rbits(struct comed
 	return 2;
 }
 
-static int das08jr_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das08jr_do_wbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	/*  null bits we are going to set */
 	devpriv->do_bits &= ~data[0];
@@ -634,8 +643,9 @@ static int das08jr_do_wbits(struct comed
 	return 2;
 }
 
-static int das08jr_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das08jr_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int lsb, msb;
@@ -668,8 +678,9 @@ static int das08jr_ao_winsn(struct comed
  * a different method to force an update.
  *
  */
-static int das08ao_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das08ao_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int lsb, msb;
@@ -716,7 +727,7 @@ static unsigned int i8254_read_channel_l
 }
 
 static void i8254_write_channel_low(unsigned int base, int chan,
-	unsigned int value)
+				    unsigned int value)
 {
 	unsigned int msb, lsb;
 
@@ -740,7 +751,7 @@ static unsigned int i8254_read_channel(s
 }
 
 static void i8254_write_channel(struct i8254_struct *st, int channel,
-	unsigned int value)
+				unsigned int value)
 {
 	int chan = st->logic2phys[channel];
 
@@ -755,13 +766,13 @@ static void i8254_initialize(struct i825
 }
 
 static void i8254_set_mode_low(unsigned int base, int channel,
-	unsigned int mode)
+			       unsigned int mode)
 {
 	outb((channel << 6) | 0x30 | (mode & 0x0F), base + I8254_CTRL);
 }
 
 static void i8254_set_mode(struct i8254_struct *st, int channel,
-	unsigned int mode)
+			   unsigned int mode)
 {
 	int chan = st->logic2phys[channel];
 
@@ -782,8 +793,9 @@ static unsigned int i8254_read_status(st
 	return i8254_read_status_low(st->iobase, chan);
 }
 
-static int das08_counter_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das08_counter_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = insn->chanspec;
 
@@ -794,8 +806,9 @@ static int das08_counter_read(struct com
 	return 1;
 }
 
-static int das08_counter_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das08_counter_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = insn->chanspec;
 
@@ -805,8 +818,9 @@ static int das08_counter_write(struct co
 	return 1;
 }
 
-static int das08_counter_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das08_counter_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = insn->chanspec;
 
@@ -835,8 +849,7 @@ static struct comedi_driver driver_das08
 	.attach = das08_attach,
 	.detach = das08_common_detach,
 	.board_name = &das08_boards[0].name,
-	.num_names = sizeof(das08_boards) /
-		sizeof(struct das08_board_struct),
+	.num_names = sizeof(das08_boards) / sizeof(struct das08_board_struct),
 	.offset = sizeof(struct das08_board_struct),
 };
 
@@ -921,7 +934,8 @@ int das08_common_attach(struct comedi_de
 	/* 8255 */
 	if (thisboard->i8255_offset != 0) {
 		subdev_8255_init(dev, s, NULL, (unsigned long)(dev->iobase +
-				thisboard->i8255_offset));
+							       thisboard->
+							       i8255_offset));
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
@@ -943,8 +957,8 @@ int das08_common_attach(struct comedi_de
 		devpriv->i8254.logic2phys[2] = 2;
 		devpriv->i8254.iobase = iobase + thisboard->i8254_offset;
 		devpriv->i8254.mode[0] =
-			devpriv->i8254.mode[1] =
-			devpriv->i8254.mode[2] = I8254_MODE0 | I8254_BINARY;
+		    devpriv->i8254.mode[1] =
+		    devpriv->i8254.mode[2] = I8254_MODE0 | I8254_BINARY;
 		i8254_initialize(&devpriv->i8254);
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
@@ -972,19 +986,19 @@ static int das08_attach(struct comedi_de
 #ifdef CONFIG_COMEDI_PCI
 		if (it->options[0] || it->options[1]) {
 			printk("bus %i slot %i ",
-				it->options[0], it->options[1]);
+			       it->options[0], it->options[1]);
 		}
 		printk("\n");
 		/*  find card */
 		for (pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-			pdev != NULL;
-			pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) {
+		     pdev != NULL;
+		     pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) {
 			if (pdev->vendor == PCI_VENDOR_ID_COMPUTERBOARDS
-				&& pdev->device == PCI_DEVICE_ID_PCIDAS08) {
+			    && pdev->device == PCI_DEVICE_ID_PCIDAS08) {
 				if (it->options[0] || it->options[1]) {
 					if (pdev->bus->number == it->options[0]
-						&& PCI_SLOT(pdev->devfn) ==
-						it->options[1]) {
+					    && PCI_SLOT(pdev->devfn) ==
+					    it->options[1]) {
 						break;
 					}
 				} else {
@@ -999,7 +1013,8 @@ static int das08_attach(struct comedi_de
 		devpriv->pdev = pdev;
 		/*  enable PCI device and reserve I/O spaces */
 		if (comedi_pci_enable(pdev, DRV_NAME)) {
-			printk(" Error enabling PCI device and requesting regions\n");
+			printk
+			    (" Error enabling PCI device and requesting regions\n");
 			return -EIO;
 		}
 		/*  read base addresses */
@@ -1018,10 +1033,10 @@ static int das08_attach(struct comedi_de
 		/* Enable local interrupt 1 and pci interrupt */
 		outw(INTR1_ENABLE | PCI_INTR_ENABLE, pci_iobase + INTCSR);
 #endif
-#else	/* CONFIG_COMEDI_PCI */
+#else /* CONFIG_COMEDI_PCI */
 		printk("this driver has not been built with PCI support.\n");
 		return -EINVAL;
-#endif	/* CONFIG_COMEDI_PCI */
+#endif /* CONFIG_COMEDI_PCI */
 	} else {
 		iobase = it->options[0];
 	}
@@ -1042,7 +1057,6 @@ int das08_common_detach(struct comedi_de
 		if (dev->iobase)
 			release_region(dev->iobase, thisboard->iosize);
 	}
-
 #ifdef CONFIG_COMEDI_PCI
 	if (devpriv) {
 		if (devpriv->pdev) {
--- a/drivers/staging/comedi/drivers/das08_cs.c
+++ b/drivers/staging/comedi/drivers/das08_cs.c
@@ -56,7 +56,8 @@ static struct pcmcia_device *cur_dev = N
 
 #define thisboard ((const struct das08_board_struct *)dev->board_ptr)
 
-static int das08_cs_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das08_cs_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it);
 
 static struct comedi_driver driver_das08_cs = {
 	.driver_name = "das08_cs",
@@ -65,11 +66,12 @@ static struct comedi_driver driver_das08
 	.detach = das08_common_detach,
 	.board_name = &das08_cs_boards[0].name,
 	.num_names = sizeof(das08_cs_boards) /
-		sizeof(struct das08_board_struct),
+	    sizeof(struct das08_board_struct),
 	.offset = sizeof(struct das08_board_struct),
 };
 
-static int das08_cs_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int das08_cs_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it)
 {
 	int ret;
 	unsigned long iobase;
@@ -122,7 +124,7 @@ static int pc_debug = PCMCIA_DEBUG;
 module_param(pc_debug, int, 0644);
 #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args)
 static const char *version =
-	"das08.c pcmcia code (Frank Hess), modified from dummy_cs.c 1.31 2001/08/24 12:13:13 (David Hinds)";
+    "das08.c pcmcia code (Frank Hess), modified from dummy_cs.c 1.31 2001/08/24 12:13:13 (David Hinds)";
 #else
 #define DEBUG(n, args...)
 #endif
@@ -226,7 +228,7 @@ static void das08_pcmcia_detach(struct p
 	DEBUG(0, "das08_pcmcia_detach(0x%p)\n", link);
 
 	if (link->dev_node) {
-		((struct local_info_t *) link->priv)->stop = 1;
+		((struct local_info_t *)link->priv)->stop = 1;
 		das08_pcmcia_release(link);
 	}
 
@@ -356,7 +358,7 @@ static void das08_pcmcia_config(struct p
 		/* If we got this far, we're cool! */
 		break;
 
-	      next_entry:
+next_entry:
 		last_fn = GetNextTuple;
 
 		last_ret = pcmcia_get_next_tuple(link, &tuple);
@@ -391,20 +393,20 @@ static void das08_pcmcia_config(struct p
 
 	/* Finally, report what we've done */
 	printk(KERN_INFO "%s: index 0x%02x",
-		dev->node.dev_name, link->conf.ConfigIndex);
+	       dev->node.dev_name, link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %u", link->irq.AssignedIRQ);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-			link->io.BasePort1 + link->io.NumPorts1 - 1);
+		       link->io.BasePort1 + link->io.NumPorts1 - 1);
 	if (link->io.NumPorts2)
 		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
-			link->io.BasePort2 + link->io.NumPorts2 - 1);
+		       link->io.BasePort2 + link->io.NumPorts2 - 1);
 	printk("\n");
 
 	return;
 
-      cs_failed:
+cs_failed:
 	cs_error(link, last_fn, last_ret);
 	das08_pcmcia_release(link);
 
@@ -470,7 +472,7 @@ struct pcmcia_driver das08_cs_driver = {
 	.id_table = das08_cs_id_table,
 	.owner = THIS_MODULE,
 	.drv = {
-			.name = dev_info,
+		.name = dev_info,
 		},
 };
 
--- a/drivers/staging/comedi/drivers/das08.h
+++ b/drivers/staging/comedi/drivers/das08.h
@@ -28,7 +28,8 @@ enum das08_bustype { isa, pci, pcmcia, p
 /* different ways ai data is encoded in first two registers */
 enum das08_ai_encoding { das08_encode12, das08_encode16, das08_pcm_encode12 };
 enum das08_lrange { das08_pg_none, das08_bipolar5, das08_pgh, das08_pgl,
-		das08_pgm };
+	das08_pgm
+};
 
 struct das08_board_struct {
 	const char *name;
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -238,61 +238,67 @@ static const int sample_size = 2;	/*  si
 #define   DAS1600_CLK_10MHZ		0x01
 
 static const struct comedi_lrange range_das1x01_bip = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01),
-	}
+							    BIP_RANGE(10),
+							    BIP_RANGE(1),
+							    BIP_RANGE(0.1),
+							    BIP_RANGE(0.01),
+							    }
 };
+
 static const struct comedi_lrange range_das1x01_unip = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01),
-	}
+							     UNI_RANGE(10),
+							     UNI_RANGE(1),
+							     UNI_RANGE(0.1),
+							     UNI_RANGE(0.01),
+							     }
 };
+
 static const struct comedi_lrange range_das1x02_bip = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-	}
+							    BIP_RANGE(10),
+							    BIP_RANGE(5),
+							    BIP_RANGE(2.5),
+							    BIP_RANGE(1.25),
+							    }
 };
+
 static const struct comedi_lrange range_das1x02_unip = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							     UNI_RANGE(10),
+							     UNI_RANGE(5),
+							     UNI_RANGE(2.5),
+							     UNI_RANGE(1.25),
+							     }
 };
+
 static const struct comedi_lrange range_das16jr = { 9, {
-			/*  also used by 16/330 */
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							/*  also used by 16/330 */
+							BIP_RANGE(10),
+							BIP_RANGE(5),
+							BIP_RANGE(2.5),
+							BIP_RANGE(1.25),
+							BIP_RANGE(0.625),
+							UNI_RANGE(10),
+							UNI_RANGE(5),
+							UNI_RANGE(2.5),
+							UNI_RANGE(1.25),
+							}
 };
+
 static const struct comedi_lrange range_das16jr_16 = { 8, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							   BIP_RANGE(10),
+							   BIP_RANGE(5),
+							   BIP_RANGE(2.5),
+							   BIP_RANGE(1.25),
+							   UNI_RANGE(10),
+							   UNI_RANGE(5),
+							   UNI_RANGE(2.5),
+							   UNI_RANGE(1.25),
+							   }
 };
 
 static const int das16jr_gainlist[] = { 8, 0, 1, 2, 3, 4, 5, 6, 7 };
 static const int das16jr_16_gainlist[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
 static const int das1600_gainlist[] = { 0, 1, 2, 3 };
+
 enum {
 	das16_pg_none = 0,
 	das16_pg_16jr,
@@ -307,6 +313,7 @@ static const int *const das16_gainlists[
 	das1600_gainlist,
 	das1600_gainlist,
 };
+
 static const struct comedi_lrange *const das16_ai_uni_lranges[] = {
 	&range_unknown,
 	&range_das16jr,
@@ -314,6 +321,7 @@ static const struct comedi_lrange *const
 	&range_das1x01_unip,
 	&range_das1x02_unip,
 };
+
 static const struct comedi_lrange *const das16_ai_bip_lranges[] = {
 	&range_unknown,
 	&range_das16jr,
@@ -328,20 +336,23 @@ struct munge_info {
 };
 
 static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s);
+			  struct comedi_cmd *cmd);
+static int das16_cmd_exec(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void das16_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *array, unsigned int num_bytes, unsigned int start_chan_index);
+static void das16_ai_munge(struct comedi_device *dev,
+			   struct comedi_subdevice *s, void *array,
+			   unsigned int num_bytes,
+			   unsigned int start_chan_index);
 
 static void das16_reset(struct comedi_device *dev);
 static irqreturn_t das16_dma_interrupt(int irq, void *d);
@@ -349,10 +360,10 @@ static void das16_timer_interrupt(unsign
 static void das16_interrupt(struct comedi_device *dev);
 
 static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
-	int flags);
+				    int flags);
 static int das1600_mode_detect(struct comedi_device *dev);
 static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
-	struct comedi_cmd cmd);
+						struct comedi_cmd cmd);
 
 static void reg_dump(struct comedi_device *dev);
 
@@ -376,324 +387,324 @@ struct das16_board {
 
 static const struct das16_board das16_boards[] = {
 	{
-	.name = "das-16",
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 15000,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x00,
-		},
-	{
-	.name = "das-16g",
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 15000,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x00,
-		},
-	{
-	.name = "das-16f",
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 8500,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x00,
-		},
-	{
-	.name = "cio-das16",	/*  cio-das16.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 20000,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x80,
-		},
-	{
-	.name = "cio-das16/f",	/*  das16.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x80,
-		},
-	{
-	.name = "cio-das16/jr",	/*  cio-das16jr.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 7692,
-	.ai_pg = das16_pg_16jr,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x10,
-	.id = 0x00,
-		},
-	{
-	.name = "pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 3300,
-	.ai_pg = das16_pg_16jr,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x10,
-	.id = 0x00,
-		},
-	{
-	.name = "cio-das16jr/16",	/*  cio-das16jr_16.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_16jr_16,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x10,
-	.id = 0x00,
-		},
-	{
-	.name = "pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_16jr_16,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x10,
-	.id = 0x00,
-		},
-	{
-	.name = "das-1201",	/*  4924.pdf (keithley user's manual) */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 20000,
-	.ai_pg = das16_pg_none,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0x20,
-		},
-	{
-	.name = "das-1202",	/*  4924.pdf (keithley user's manual) */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_none,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0x20,
-		},
-	{
-	.name = "das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1601,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
-		},
-	{
-	.name = "das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
-		},
-	{
-	.name = "das-1601",	/*  4919.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1601,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
-	{
-	.name = "das-1602",	/*  4919.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
-	{
-	.name = "cio-das1401/12",	/*  cio-das1400_series.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 6250,
-	.ai_pg = das16_pg_1601,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
-	{
-	.name = "cio-das1402/12",	/*  cio-das1400_series.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 6250,
-	.ai_pg = das16_pg_1602,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
-	{
-	.name = "cio-das1402/16",	/*  cio-das1400_series.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
-	{
-	.name = "cio-das1601/12",	/*  cio-das160x-1x.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 6250,
-	.ai_pg = das16_pg_1601,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
-	{
-	.name = "cio-das1602/12",	/*  cio-das160x-1x.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
-	{
-	.name = "cio-das1602/16",	/*  cio-das160x-1x.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
-	{
-	.name = "cio-das16/330",	/*  ? */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 3030,
-	.ai_pg = das16_pg_16jr,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0xf0},
+	 .name = "das-16",
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 15000,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x00,
+	 },
+	{
+	 .name = "das-16g",
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 15000,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x00,
+	 },
+	{
+	 .name = "das-16f",
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 8500,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x00,
+	 },
+	{
+	 .name = "cio-das16",	/*  cio-das16.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 20000,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x80,
+	 },
+	{
+	 .name = "cio-das16/f",	/*  das16.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x80,
+	 },
+	{
+	 .name = "cio-das16/jr",	/*  cio-das16jr.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 7692,
+	 .ai_pg = das16_pg_16jr,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x10,
+	 .id = 0x00,
+	 },
+	{
+	 .name = "pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 3300,
+	 .ai_pg = das16_pg_16jr,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x10,
+	 .id = 0x00,
+	 },
+	{
+	 .name = "cio-das16jr/16",	/*  cio-das16jr_16.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_16jr_16,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x10,
+	 .id = 0x00,
+	 },
+	{
+	 .name = "pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_16jr_16,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x10,
+	 .id = 0x00,
+	 },
+	{
+	 .name = "das-1201",	/*  4924.pdf (keithley user's manual) */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 20000,
+	 .ai_pg = das16_pg_none,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0x20,
+	 },
+	{
+	 .name = "das-1202",	/*  4924.pdf (keithley user's manual) */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_none,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0x20,
+	 },
+	{
+	 .name = "das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1601,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0		/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
+	 },
+	{
+	 .name = "das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0		/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
+	 },
+	{
+	 .name = "das-1601",	/*  4919.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1601,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
+	{
+	 .name = "das-1602",	/*  4919.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
+	{
+	 .name = "cio-das1401/12",	/*  cio-das1400_series.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 6250,
+	 .ai_pg = das16_pg_1601,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
+	{
+	 .name = "cio-das1402/12",	/*  cio-das1400_series.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 6250,
+	 .ai_pg = das16_pg_1602,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
+	{
+	 .name = "cio-das1402/16",	/*  cio-das1400_series.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
+	{
+	 .name = "cio-das1601/12",	/*  cio-das160x-1x.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 6250,
+	 .ai_pg = das16_pg_1601,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
+	{
+	 .name = "cio-das1602/12",	/*  cio-das160x-1x.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
+	{
+	 .name = "cio-das1602/16",	/*  cio-das160x-1x.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
+	{
+	 .name = "cio-das16/330",	/*  ? */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 3030,
+	 .ai_pg = das16_pg_16jr,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0xf0},
 #if 0
 	{
-	.name = "das16/330i",	/*  ? */
-		},
+	 .name = "das16/330i",	/*  ? */
+	 },
 	{
-	.name = "das16/jr/ctr5",	/*  ? */
-		},
+	 .name = "das16/jr/ctr5",	/*  ? */
+	 },
 	{
-	.name = "cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
-		},
+	 .name = "cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
+	 },
 #endif
 };
 
@@ -717,6 +728,7 @@ static inline int timer_period(void)
 {
 	return HZ / 20;
 }
+
 struct das16_private_struct {
 	unsigned int ai_unipolar;	/*  unipolar flag */
 	unsigned int ai_singleended;	/*  single ended flag */
@@ -742,7 +754,7 @@ struct das16_private_struct {
 #define thisboard ((struct das16_board *)(dev->board_ptr))
 
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			  struct comedi_cmd *cmd)
 {
 	int err = 0, tmp;
 	int gain, start_chan, i;
@@ -787,11 +799,11 @@ static int das16_cmd_test(struct comedi_
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_FOLLOW)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
 		err++;
@@ -826,9 +838,9 @@ static int das16_cmd_test(struct comedi_
 	/*  check against maximum frequency */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg <
-			thisboard->ai_speed * cmd->chanlist_len) {
+		    thisboard->ai_speed * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				thisboard->ai_speed * cmd->chanlist_len;
+			    thisboard->ai_speed * cmd->chanlist_len;
 			err++;
 		}
 	}
@@ -853,16 +865,20 @@ static int das16_cmd_test(struct comedi_
 		unsigned int tmp = cmd->scan_begin_arg;
 		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->scan_begin_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		err += (tmp != cmd->scan_begin_arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->convert_arg;
 		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->convert_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		err += (tmp != cmd->convert_arg);
 	}
 	if (err)
@@ -874,14 +890,14 @@ static int das16_cmd_test(struct comedi_
 		start_chan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				(start_chan + i) % s->n_chan) {
+			    (start_chan + i) % s->n_chan) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					"entries in chanlist must all have the same gain\n");
+					     "entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -901,19 +917,19 @@ static int das16_cmd_exec(struct comedi_
 	int range;
 
 	if (devpriv->dma_chan == 0 || (dev->irq == 0
-			&& devpriv->timer_mode == 0)) {
+				       && devpriv->timer_mode == 0)) {
 		comedi_error(dev,
-			"irq (or use of 'timer mode') dma required to execute comedi_cmd");
+			     "irq (or use of 'timer mode') dma required to execute comedi_cmd");
 		return -1;
 	}
 	if (cmd->flags & TRIG_RT) {
 		comedi_error(dev,
-			"isa dma transfers cannot be performed with TRIG_RT, aborting");
+			     "isa dma transfers cannot be performed with TRIG_RT, aborting");
 		return -1;
 	}
 
 	devpriv->adc_byte_count =
-		cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
+	    cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
 
 	/*  disable conversions for das1600 mode */
 	if (thisboard->size > 0x400) {
@@ -929,13 +945,13 @@ static int das16_cmd_exec(struct comedi_
 	if (thisboard->ai_pg != das16_pg_none) {
 		range = CR_RANGE(cmd->chanlist[0]);
 		outb((das16_gainlists[thisboard->ai_pg])[range],
-			dev->iobase + DAS16_GAIN);
+		     dev->iobase + DAS16_GAIN);
 	}
 
 	/* set counter mode and counts */
 	cmd->convert_arg =
-		das16_set_pacer(dev, cmd->convert_arg,
-		cmd->flags & TRIG_ROUND_MASK);
+	    das16_set_pacer(dev, cmd->convert_arg,
+			    cmd->flags & TRIG_ROUND_MASK);
 	DEBUG_PRINT("pacer period: %d ns\n", cmd->convert_arg);
 
 	/* enable counters */
@@ -960,7 +976,7 @@ static int das16_cmd_exec(struct comedi_
 	clear_dma_ff(devpriv->dma_chan);
 	devpriv->current_buffer = 0;
 	set_dma_addr(devpriv->dma_chan,
-		devpriv->dma_buffer_addr[devpriv->current_buffer]);
+		     devpriv->dma_buffer_addr[devpriv->current_buffer]);
 	/*  set appropriate size of transfer */
 	devpriv->dma_transfer_size = das16_suggest_transfer_size(dev, *cmd);
 	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
@@ -1031,7 +1047,7 @@ static void das16_reset(struct comedi_de
 }
 
 static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int range;
@@ -1051,7 +1067,7 @@ static int das16_ai_rinsn(struct comedi_
 	if (thisboard->ai_pg != das16_pg_none) {
 		range = CR_RANGE(insn->chanspec);
 		outb((das16_gainlists[thisboard->ai_pg])[range],
-			dev->iobase + DAS16_GAIN);
+		     dev->iobase + DAS16_GAIN);
 	}
 
 	for (n = 0; n < insn->n; n++) {
@@ -1079,7 +1095,7 @@ static int das16_ai_rinsn(struct comedi_
 }
 
 static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -1091,7 +1107,7 @@ static int das16_di_rbits(struct comedi_
 }
 
 static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int wbits;
 
@@ -1111,7 +1127,7 @@ static int das16_do_wbits(struct comedi_
 }
 
 static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int lsb, msb;
@@ -1154,7 +1170,7 @@ static irqreturn_t das16_dma_interrupt(i
 
 static void das16_timer_interrupt(unsigned long arg)
 {
-	struct comedi_device *dev = (struct comedi_device *) arg;
+	struct comedi_device *dev = (struct comedi_device *)arg;
 
 	das16_interrupt(dev);
 
@@ -1191,7 +1207,7 @@ static int disable_dma_on_even(struct co
 	}
 	if (i == disable_limit) {
 		comedi_error(dev,
-			"failed to get an even dma transfer, could be trouble.");
+			     "failed to get an even dma transfer, could be trouble.");
 	}
 	return residue;
 }
@@ -1248,13 +1264,13 @@ static void das16_interrupt(struct comed
 
 	/*  figure out how many bytes for next transfer */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->timer_mode == 0 &&
-		devpriv->dma_transfer_size > devpriv->adc_byte_count)
+	    devpriv->dma_transfer_size > devpriv->adc_byte_count)
 		devpriv->dma_transfer_size = devpriv->adc_byte_count;
 
 	/*  re-enable  dma */
 	if ((async->events & COMEDI_CB_EOA) == 0) {
 		set_dma_addr(devpriv->dma_chan,
-			devpriv->dma_buffer_addr[devpriv->current_buffer]);
+			     devpriv->dma_buffer_addr[devpriv->current_buffer]);
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
 		/* reenable conversions for das1600 mode, (stupid hardware) */
@@ -1267,16 +1283,17 @@ static void das16_interrupt(struct comed
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
 	cfc_write_array_to_buffer(s,
-		devpriv->dma_buffer[buffer_index], num_bytes);
+				  devpriv->dma_buffer[buffer_index], num_bytes);
 
 	cfc_handle_events(dev, s);
 }
 
 static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
-	int rounding_flags)
+				    int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
-		&(devpriv->divisor2), &ns, rounding_flags & TRIG_ROUND_MASK);
+				       &(devpriv->divisor2), &ns,
+				       rounding_flags & TRIG_ROUND_MASK);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 1, devpriv->divisor1, 2);
@@ -1295,12 +1312,12 @@ static void reg_dump(struct comedi_devic
 	DEBUG_PRINT("DAS16_PACER: %x\n", inb(dev->iobase + DAS16_PACER));
 	DEBUG_PRINT("DAS16_GAIN: %x\n", inb(dev->iobase + DAS16_GAIN));
 	DEBUG_PRINT("DAS16_CNTR_CONTROL: %x\n",
-		inb(dev->iobase + DAS16_CNTR_CONTROL));
+		    inb(dev->iobase + DAS16_CNTR_CONTROL));
 	DEBUG_PRINT("DAS1600_CONV: %x\n", inb(dev->iobase + DAS1600_CONV));
 	DEBUG_PRINT("DAS1600_BURST: %x\n", inb(dev->iobase + DAS1600_BURST));
 	DEBUG_PRINT("DAS1600_ENABLE: %x\n", inb(dev->iobase + DAS1600_ENABLE));
 	DEBUG_PRINT("DAS1600_STATUS_B: %x\n",
-		inb(dev->iobase + DAS1600_STATUS_B));
+		    inb(dev->iobase + DAS1600_STATUS_B));
 }
 
 static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -1331,7 +1348,7 @@ static int das16_probe(struct comedi_dev
 	printk(" id bits are 0x%02x\n", diobits);
 	if (thisboard->id != diobits) {
 		printk(" requested board's id bits are 0x%x (ignore)\n",
-			thisboard->id);
+		       thisboard->id);
 	}
 
 	return 0;
@@ -1393,8 +1410,9 @@ static int das16_attach(struct comedi_de
 	/*  check that clock setting is valid */
 	if (it->options[3]) {
 		if (it->options[3] != 0 &&
-			it->options[3] != 1 && it->options[3] != 10) {
-			printk("\n Invalid option.  Master clock must be set to 1 or 10 (MHz)\n");
+		    it->options[3] != 1 && it->options[3] != 10) {
+			printk
+			    ("\n Invalid option.  Master clock must be set to 1 or 10 (MHz)\n");
 			return -EINVAL;
 		}
 	}
@@ -1411,20 +1429,20 @@ static int das16_attach(struct comedi_de
 		}
 	} else {
 		printk(" 0x%04lx-0x%04lx 0x%04lx-0x%04lx\n",
-			iobase, iobase + 0x0f,
-			iobase + 0x400,
-			iobase + 0x400 + (thisboard->size & 0x3ff));
+		       iobase, iobase + 0x0f,
+		       iobase + 0x400,
+		       iobase + 0x400 + (thisboard->size & 0x3ff));
 		if (!request_region(iobase, 0x10, "das16")) {
 			printk(" I/O port conflict:  0x%04lx-0x%04lx\n",
-				iobase, iobase + 0x0f);
+			       iobase, iobase + 0x0f);
 			return -EIO;
 		}
 		if (!request_region(iobase + 0x400, thisboard->size & 0x3ff,
-				"das16")) {
+				    "das16")) {
 			release_region(iobase, 0x10);
 			printk(" I/O port conflict:  0x%04lx-0x%04lx\n",
-				iobase + 0x400,
-				iobase + 0x400 + (thisboard->size & 0x3ff));
+			       iobase + 0x400,
+			       iobase + 0x400 + (thisboard->size & 0x3ff));
 			return -EIO;
 		}
 	}
@@ -1470,13 +1488,16 @@ static int das16_attach(struct comedi_de
 		int i;
 		for (i = 0; i < 2; i++) {
 			devpriv->dma_buffer[i] = pci_alloc_consistent(NULL,
-				DAS16_DMA_SIZE, &devpriv->dma_buffer_addr[i]);
+								      DAS16_DMA_SIZE,
+								      &devpriv->
+								      dma_buffer_addr
+								      [i]);
 			if (devpriv->dma_buffer[i] == NULL)
 				return -ENOMEM;
 		}
 		if (request_dma(dma_chan, "das16")) {
 			printk(" failed to allocate dma channel %i\n",
-				dma_chan);
+			       dma_chan);
 			return -EINVAL;
 		}
 		devpriv->dma_chan = dma_chan;
@@ -1494,11 +1515,11 @@ static int das16_attach(struct comedi_de
 
 	/*  get any user-defined input range */
 	if (thisboard->ai_pg == das16_pg_none &&
-		(it->options[4] || it->options[5])) {
+	    (it->options[4] || it->options[5])) {
 		/*  allocate single-range range table */
 		devpriv->user_ai_range_table =
-			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
-			GFP_KERNEL);
+		    kmalloc(sizeof(struct comedi_lrange) +
+			    sizeof(struct comedi_krange), GFP_KERNEL);
 		/*  initialize ai range */
 		devpriv->user_ai_range_table->length = 1;
 		user_ai_range = devpriv->user_ai_range_table->range;
@@ -1510,8 +1531,8 @@ static int das16_attach(struct comedi_de
 	if (it->options[6] || it->options[7]) {
 		/*  allocate single-range range table */
 		devpriv->user_ao_range_table =
-			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
-			GFP_KERNEL);
+		    kmalloc(sizeof(struct comedi_lrange) +
+			    sizeof(struct comedi_krange), GFP_KERNEL);
 		/*  initialize ao range */
 		devpriv->user_ao_range_table->length = 1;
 		user_ao_range = devpriv->user_ao_range_table->range;
@@ -1612,7 +1633,7 @@ static int das16_attach(struct comedi_de
 	/* 8255 */
 	if (thisboard->i8255_offset != 0) {
 		subdev_8255_init(dev, s, NULL, (dev->iobase +
-				thisboard->i8255_offset));
+						thisboard->i8255_offset));
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
@@ -1646,8 +1667,9 @@ static int das16_detach(struct comedi_de
 		for (i = 0; i < 2; i++) {
 			if (devpriv->dma_buffer[i])
 				pci_free_consistent(NULL, DAS16_DMA_SIZE,
-					devpriv->dma_buffer[i],
-					devpriv->dma_buffer_addr[i]);
+						    devpriv->dma_buffer[i],
+						    devpriv->
+						    dma_buffer_addr[i]);
 		}
 		if (devpriv->dma_chan)
 			free_dma(devpriv->dma_chan);
@@ -1666,7 +1688,7 @@ static int das16_detach(struct comedi_de
 		} else {
 			release_region(dev->iobase, 0x10);
 			release_region(dev->iobase + 0x400,
-				thisboard->size & 0x3ff);
+				       thisboard->size & 0x3ff);
 		}
 	}
 
@@ -1677,7 +1699,7 @@ COMEDI_INITCLEANUP(driver_das16);
 
 /* utility function that suggests a dma transfer size in bytes */
 static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
-	struct comedi_cmd cmd)
+						struct comedi_cmd cmd)
 {
 	unsigned int size;
 	unsigned int freq;
@@ -1717,8 +1739,10 @@ static unsigned int das16_suggest_transf
 	return size;
 }
 
-static void das16_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *array, unsigned int num_bytes, unsigned int start_chan_index)
+static void das16_ai_munge(struct comedi_device *dev,
+			   struct comedi_subdevice *s, void *array,
+			   unsigned int num_bytes,
+			   unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
 	short *data = array;
--- a/drivers/staging/comedi/drivers/das16m1.c
+++ b/drivers/staging/comedi/drivers/das16m1.c
@@ -120,36 +120,41 @@ irq can be omitted, although the cmd int
 
 static const struct comedi_lrange range_das16m1 = { 9,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-			BIP_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 BIP_RANGE(0.625),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25),
+	 BIP_RANGE(10),
+	 }
 };
 
-static int das16m1_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das16m1_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das16m1_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-
-static int das16m1_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int das16m1_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s);
-static int das16m1_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int das16m1_do_wbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das16m1_di_rbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das16m1_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+
+static int das16m1_cmd_test(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd);
+static int das16m1_cmd_exec(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int das16m1_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 
 static int das16m1_poll(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t das16m1_interrupt(int irq, void *d);
 static void das16m1_handler(struct comedi_device *dev, unsigned int status);
 
-static unsigned int das16m1_set_pacer(struct comedi_device *dev, unsigned int ns,
-	int round_flag);
+static unsigned int das16m1_set_pacer(struct comedi_device *dev,
+				      unsigned int ns, int round_flag);
 
 static int das16m1_irq_bits(unsigned int irq);
 
@@ -160,12 +165,13 @@ struct das16m1_board {
 
 static const struct das16m1_board das16m1_boards[] = {
 	{
-	.name = "cio-das16/m1",	/*  CIO-DAS16_M1.pdf */
-	.ai_speed = 1000,	/*  1MHz max speed */
-		},
+	 .name = "cio-das16/m1",	/*  CIO-DAS16_M1.pdf */
+	 .ai_speed = 1000,	/*  1MHz max speed */
+	 },
 };
 
-static int das16m1_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das16m1_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int das16m1_detach(struct comedi_device *dev);
 static struct comedi_driver driver_das16m1 = {
 	.driver_name = "das16m1",
@@ -199,8 +205,8 @@ static inline short munge_sample(short d
 	return (data >> 4) & 0xfff;
 }
 
-static int das16m1_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int das16m1_cmd_test(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	unsigned int err = 0, tmp, i;
 
@@ -289,8 +295,10 @@ static int das16m1_cmd_test(struct comed
 		tmp = cmd->convert_arg;
 		/* calculate counter values that give desired timing */
 		i8253_cascade_ns_to_timer_2div(DAS16M1_XTAL,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->convert_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -304,13 +312,13 @@ static int das16m1_cmd_test(struct comed
 			/*  even/odd channels must go into even/odd queue addresses */
 			if ((i % 2) != (CR_CHAN(cmd->chanlist[i]) % 2)) {
 				comedi_error(dev, "bad chanlist:\n"
-					" even/odd channels must go have even/odd chanlist indices");
+					     " even/odd channels must go have even/odd chanlist indices");
 				err++;
 			}
 		}
 		if ((cmd->chanlist_len % 2) != 0) {
 			comedi_error(dev,
-				"chanlist must be of even length or length 1");
+				     "chanlist must be of even length or length 1");
 			err++;
 		}
 	}
@@ -321,7 +329,8 @@ static int das16m1_cmd_test(struct comed
 	return 0;
 }
 
-static int das16m1_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das16m1_cmd_exec(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -345,20 +354,20 @@ static int das16m1_cmd_exec(struct comed
 	/* remember current reading of counter so we know when counter has
 	 * actually been loaded */
 	devpriv->initial_hw_count =
-		i8254_read(dev->iobase + DAS16M1_8254_FIRST, 0, 1);
+	    i8254_read(dev->iobase + DAS16M1_8254_FIRST, 0, 1);
 	/* setup channel/gain queue */
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		outb(i, dev->iobase + DAS16M1_QUEUE_ADDR);
-		byte = Q_CHAN(CR_CHAN(cmd->
-				chanlist[i])) | Q_RANGE(CR_RANGE(cmd->
-				chanlist[i]));
+		byte =
+		    Q_CHAN(CR_CHAN(cmd->chanlist[i])) |
+		    Q_RANGE(CR_RANGE(cmd->chanlist[i]));
 		outb(byte, dev->iobase + DAS16M1_QUEUE_DATA);
 	}
 
 	/* set counter mode and counts */
 	cmd->convert_arg =
-		das16m1_set_pacer(dev, cmd->convert_arg,
-		cmd->flags & TRIG_ROUND_MASK);
+	    das16m1_set_pacer(dev, cmd->convert_arg,
+			      cmd->flags & TRIG_ROUND_MASK);
 
 	/*  set control & status register */
 	byte = 0;
@@ -392,8 +401,9 @@ static int das16m1_cancel(struct comedi_
 	return 0;
 }
 
-static int das16m1_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16m1_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int byte;
@@ -405,8 +415,8 @@ static int das16m1_ai_rinsn(struct comed
 
 	/* setup channel/gain queue */
 	outb(0, dev->iobase + DAS16M1_QUEUE_ADDR);
-	byte = Q_CHAN(CR_CHAN(insn->chanspec)) | Q_RANGE(CR_RANGE(insn->
-			chanspec));
+	byte =
+	    Q_CHAN(CR_CHAN(insn->chanspec)) | Q_RANGE(CR_RANGE(insn->chanspec));
 	outb(byte, dev->iobase + DAS16M1_QUEUE_DATA);
 
 	for (n = 0; n < insn->n; n++) {
@@ -429,8 +439,9 @@ static int das16m1_ai_rinsn(struct comed
 	return n;
 }
 
-static int das16m1_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16m1_di_rbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -441,8 +452,9 @@ static int das16m1_di_rbits(struct comed
 	return 2;
 }
 
-static int das16m1_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das16m1_do_wbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int wbits;
 
@@ -552,7 +564,7 @@ static void das16m1_handler(struct comed
 	insw(dev->iobase, devpriv->ai_buffer, num_samples);
 	munge_sample_array(devpriv->ai_buffer, num_samples);
 	cfc_write_array_to_buffer(s, devpriv->ai_buffer,
-		num_samples * sizeof(short));
+				  num_samples * sizeof(short));
 	devpriv->adc_count += num_samples;
 
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -577,17 +589,18 @@ static void das16m1_handler(struct comed
 /* This function takes a time in nanoseconds and sets the     *
  * 2 pacer clocks to the closest frequency possible. It also  *
  * returns the actual sampling period.                        */
-static unsigned int das16m1_set_pacer(struct comedi_device *dev, unsigned int ns,
-	int rounding_flags)
+static unsigned int das16m1_set_pacer(struct comedi_device *dev,
+				      unsigned int ns, int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(DAS16M1_XTAL, &(devpriv->divisor1),
-		&(devpriv->divisor2), &ns, rounding_flags & TRIG_ROUND_MASK);
+				       &(devpriv->divisor2), &ns,
+				       rounding_flags & TRIG_ROUND_MASK);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 	i8254_load(dev->iobase + DAS16M1_8254_SECOND, 0, 1, devpriv->divisor1,
-		2);
+		   2);
 	i8254_load(dev->iobase + DAS16M1_8254_SECOND, 0, 2, devpriv->divisor2,
-		2);
+		   2);
 
 	return ns;
 }
@@ -634,7 +647,8 @@ static int das16m1_irq_bits(unsigned int
  *   1  IRQ
  */
 
-static int das16m1_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int das16m1_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret;
@@ -652,14 +666,14 @@ static int das16m1_attach(struct comedi_
 	dev->board_name = thisboard->name;
 
 	printk(" io 0x%lx-0x%lx 0x%lx-0x%lx",
-		iobase, iobase + DAS16M1_SIZE,
-		iobase + DAS16M1_82C55, iobase + DAS16M1_82C55 + DAS16M1_SIZE2);
+	       iobase, iobase + DAS16M1_SIZE,
+	       iobase + DAS16M1_82C55, iobase + DAS16M1_82C55 + DAS16M1_SIZE2);
 	if (!request_region(iobase, DAS16M1_SIZE, driver_das16m1.driver_name)) {
 		printk(" I/O port conflict\n");
 		return -EIO;
 	}
 	if (!request_region(iobase + DAS16M1_82C55, DAS16M1_SIZE2,
-			driver_das16m1.driver_name)) {
+			    driver_das16m1.driver_name)) {
 		release_region(iobase, DAS16M1_SIZE);
 		printk(" I/O port conflict\n");
 		return -EIO;
@@ -682,7 +696,7 @@ static int das16m1_attach(struct comedi_
 		printk(", no irq\n");
 	} else {
 		printk(", invalid irq\n"
-			" valid irqs are 2, 3, 5, 7, 10, 11, 12, or 15\n");
+		       " valid irqs are 2, 3, 5, 7, 10, 11, 12, or 15\n");
 		return -EINVAL;
 	}
 
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -181,33 +181,44 @@ enum {
 	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
 };
 
-static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das1800_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int das1800_detach(struct comedi_device *dev);
 static int das1800_probe(struct comedi_device *dev);
-static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int das1800_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static irqreturn_t das1800_interrupt(int irq, void *d);
-static int das1800_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s);
+static int das1800_ai_poll(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
 static void das1800_ai_handler(struct comedi_device *dev);
-static void das1800_handle_dma(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int status);
-static void das1800_flush_dma(struct comedi_device *dev, struct comedi_subdevice *s);
-static void das1800_flush_dma_channel(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int channel, uint16_t *buffer);
+static void das1800_handle_dma(struct comedi_device *dev,
+			       struct comedi_subdevice *s, unsigned int status);
+static void das1800_flush_dma(struct comedi_device *dev,
+			      struct comedi_subdevice *s);
+static void das1800_flush_dma_channel(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      unsigned int channel, uint16_t * buffer);
 static void das1800_handle_fifo_half_full(struct comedi_device *dev,
-	struct comedi_subdevice *s);
+					  struct comedi_subdevice *s);
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
-	struct comedi_subdevice *s);
-static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das1800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das1800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+					  struct comedi_subdevice *s);
+static int das1800_ai_do_cmdtest(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_cmd *cmd);
+static int das1800_ai_do_cmd(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
+static int das1800_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das1800_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das1800_di_rbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das1800_do_wbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 
 static int das1800_set_frequency(struct comedi_device *dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
@@ -217,29 +228,29 @@ static unsigned int suggest_transfer_siz
 static const struct comedi_lrange range_ai_das1801 = {
 	8,
 	{
-			RANGE(-5, 5),
-			RANGE(-1, 1),
-			RANGE(-0.1, 0.1),
-			RANGE(-0.02, 0.02),
-			RANGE(0, 5),
-			RANGE(0, 1),
-			RANGE(0, 0.1),
-			RANGE(0, 0.02),
-		}
+	 RANGE(-5, 5),
+	 RANGE(-1, 1),
+	 RANGE(-0.1, 0.1),
+	 RANGE(-0.02, 0.02),
+	 RANGE(0, 5),
+	 RANGE(0, 1),
+	 RANGE(0, 0.1),
+	 RANGE(0, 0.02),
+	 }
 };
 
 static const struct comedi_lrange range_ai_das1802 = {
 	8,
 	{
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25),
-		}
+	 RANGE(-10, 10),
+	 RANGE(-5, 5),
+	 RANGE(-2.5, 2.5),
+	 RANGE(-1.25, 1.25),
+	 RANGE(0, 10),
+	 RANGE(0, 5),
+	 RANGE(0, 2.5),
+	 RANGE(0, 1.25),
+	 }
 };
 
 struct das1800_board {
@@ -260,203 +271,203 @@ struct das1800_board {
  */
 static const struct das1800_board das1800_boards[] = {
 	{
-	.name = "das-1701st",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1801,
-		},
-	{
-	.name = "das-1701st-da",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 4,
-	.range_ai = &range_ai_das1801,
-		},
-	{
-	.name = "das-1702st",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1702st-da",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 4,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1702hr",
-	.ai_speed = 20000,
-	.resolution = 16,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1702hr-da",
-	.ai_speed = 20000,
-	.resolution = 16,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1701ao",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 2,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1801,
-		},
-	{
-	.name = "das-1702ao",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 2,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1801st",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1801,
-		},
-	{
-	.name = "das-1801st-da",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 4,
-	.range_ai = &range_ai_das1801,
-		},
-	{
-	.name = "das-1802st",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1802st-da",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 4,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1802hr",
-	.ai_speed = 10000,
-	.resolution = 16,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1802hr-da",
-	.ai_speed = 10000,
-	.resolution = 16,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1801hc",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 64,
-	.common = 0,
-	.do_n_chan = 8,
-	.ao_ability = 1,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1801,
-		},
-	{
-	.name = "das-1802hc",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 64,
-	.common = 0,
-	.do_n_chan = 8,
-	.ao_ability = 1,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
-	{
-	.name = "das-1801ao",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 2,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1801,
-		},
-	{
-	.name = "das-1802ao",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 2,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1701st",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1801,
+	 },
+	{
+	 .name = "das-1701st-da",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 4,
+	 .range_ai = &range_ai_das1801,
+	 },
+	{
+	 .name = "das-1702st",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1702st-da",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 4,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1702hr",
+	 .ai_speed = 20000,
+	 .resolution = 16,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1702hr-da",
+	 .ai_speed = 20000,
+	 .resolution = 16,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1701ao",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 2,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1801,
+	 },
+	{
+	 .name = "das-1702ao",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 2,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1801st",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1801,
+	 },
+	{
+	 .name = "das-1801st-da",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 4,
+	 .range_ai = &range_ai_das1801,
+	 },
+	{
+	 .name = "das-1802st",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1802st-da",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 4,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1802hr",
+	 .ai_speed = 10000,
+	 .resolution = 16,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1802hr-da",
+	 .ai_speed = 10000,
+	 .resolution = 16,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1801hc",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 64,
+	 .common = 0,
+	 .do_n_chan = 8,
+	 .ao_ability = 1,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1801,
+	 },
+	{
+	 .name = "das-1802hc",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 64,
+	 .common = 0,
+	 .do_n_chan = 8,
+	 .ao_ability = 1,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
+	{
+	 .name = "das-1801ao",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 2,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1801,
+	 },
+	{
+	 .name = "das-1802ao",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 2,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
 };
 
 /*
@@ -490,8 +501,8 @@ struct das1800_private {
 static const struct comedi_lrange range_ao_1 = {
 	1,
 	{
-			RANGE(-10, 10),
-		}
+	 RANGE(-10, 10),
+	 }
 };
 
 /* analog out range for 'ao' boards */
@@ -522,7 +533,7 @@ static struct comedi_driver driver_das18
 COMEDI_INITCLEANUP(driver_das1800);
 
 static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
-	unsigned int dma1)
+			    unsigned int dma1)
 {
 	unsigned long flags;
 
@@ -550,8 +561,8 @@ static int das1800_init_dma(struct comed
 			break;
 		default:
 			printk(" only supports dma channels 5 through 7\n"
-				" Dual dma only allows the following combinations:\n"
-				" dma 5,6 / 6,7 / or 7,5\n");
+			       " Dual dma only allows the following combinations:\n"
+			       " dma 5,6 / 6,7 / or 7,5\n");
 			return -EINVAL;
 			break;
 		}
@@ -564,7 +575,7 @@ static int das1800_init_dma(struct comed
 		if (dma1) {
 			if (request_dma(dma1, driver_das1800.driver_name)) {
 				printk(" failed to allocate dma channel %i\n",
-					dma1);
+				       dma1);
 				return -EINVAL;
 			}
 			devpriv->dma1 = dma1;
@@ -575,7 +586,7 @@ static int das1800_init_dma(struct comed
 		devpriv->dma_current_buf = devpriv->ai_buf0;
 		if (dma1) {
 			devpriv->ai_buf1 =
-				kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+			    kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
 			if (devpriv->ai_buf1 == NULL)
 				return -ENOMEM;
 		}
@@ -591,7 +602,8 @@ static int das1800_init_dma(struct comed
 	return 0;
 }
 
-static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int das1800_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -607,7 +619,7 @@ static int das1800_attach(struct comedi_
 		return -ENOMEM;
 
 	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_das1800.driver_name,
-		iobase);
+	       iobase);
 	if (irq) {
 		printk(", irq %u", irq);
 		if (dma0) {
@@ -625,7 +637,9 @@ static int das1800_attach(struct comedi_
 
 	/* check if io addresses are available */
 	if (!request_region(iobase, DAS1800_SIZE, driver_das1800.driver_name)) {
-		printk(" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n", iobase, iobase + DAS1800_SIZE - 1);
+		printk
+		    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
+		     iobase, iobase + DAS1800_SIZE - 1);
 		return -EIO;
 	}
 	dev->iobase = iobase;
@@ -643,8 +657,10 @@ static int das1800_attach(struct comedi_
 	if (thisboard->ao_ability == 2) {
 		iobase2 = iobase + IOBASE2;
 		if (!request_region(iobase2, DAS1800_SIZE,
-				driver_das1800.driver_name)) {
-			printk(" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n", iobase2, iobase2 + DAS1800_SIZE - 1);
+				    driver_das1800.driver_name)) {
+			printk
+			    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
+			     iobase2, iobase2 + DAS1800_SIZE - 1);
 			return -EIO;
 		}
 		devpriv->iobase2 = iobase2;
@@ -694,7 +710,7 @@ static int das1800_attach(struct comedi_
 
 	if (devpriv->ai_buf0 == NULL) {
 		devpriv->ai_buf0 =
-			kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
+		    kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
 		if (devpriv->ai_buf0 == NULL)
 			return -ENOMEM;
 	}
@@ -759,7 +775,7 @@ static int das1800_attach(struct comedi_
 	if (thisboard->ao_ability == 1) {
 		/*  select 'update' dac channel for baseAddress + 0x0 */
 		outb(DAC(thisboard->ao_n_chan - 1),
-			dev->iobase + DAS1800_SELECT);
+		     dev->iobase + DAS1800_SELECT);
 		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
 	}
 
@@ -787,7 +803,7 @@ static int das1800_detach(struct comedi_
 	}
 
 	printk("comedi%d: %s: remove\n", dev->minor,
-		driver_das1800.driver_name);
+	       driver_das1800.driver_name);
 
 	return 0;
 };
@@ -800,42 +816,45 @@ static int das1800_probe(struct comedi_d
 	int board;
 
 	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;	/* get id bits */
-	board = ((struct das1800_board *) dev->board_ptr) - das1800_boards;
+	board = ((struct das1800_board *)dev->board_ptr) - das1800_boards;
 
 	switch (id) {
 	case 0x3:
 		if (board == das1801st_da || board == das1802st_da ||
-			board == das1701st_da || board == das1702st_da) {
+		    board == das1701st_da || board == das1702st_da) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1800st-da series\n");
+		printk
+		    (" Board model (probed, not recommended): das-1800st-da series\n");
 		return das1801st;
 		break;
 	case 0x4:
 		if (board == das1802hr_da || board == das1702hr_da) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1802hr-da\n");
+		printk
+		    (" Board model (probed, not recommended): das-1802hr-da\n");
 		return das1802hr;
 		break;
 	case 0x5:
 		if (board == das1801ao || board == das1802ao ||
-			board == das1701ao || board == das1702ao) {
+		    board == das1701ao || board == das1702ao) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1800ao series\n");
+		printk
+		    (" Board model (probed, not recommended): das-1800ao series\n");
 		return das1801ao;
 		break;
 	case 0x6:
 		if (board == das1802hr || board == das1702hr) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
 		printk(" Board model (probed, not recommended): das-1802hr\n");
@@ -843,32 +862,37 @@ static int das1800_probe(struct comedi_d
 		break;
 	case 0x7:
 		if (board == das1801st || board == das1802st ||
-			board == das1701st || board == das1702st) {
+		    board == das1701st || board == das1702st) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1800st series\n");
+		printk
+		    (" Board model (probed, not recommended): das-1800st series\n");
 		return das1801st;
 		break;
 	case 0x8:
 		if (board == das1801hc || board == das1802hc) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1800hc series\n");
+		printk
+		    (" Board model (probed, not recommended): das-1800hc series\n");
 		return das1801hc;
 		break;
 	default:
-		printk(" Board model: probe returned 0x%x (unknown, please report)\n", id);
+		printk
+		    (" Board model: probe returned 0x%x (unknown, please report)\n",
+		     id);
 		return board;
 		break;
 	}
 	return -1;
 }
 
-static int das1800_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das1800_ai_poll(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -963,18 +987,18 @@ static void das1800_ai_handler(struct co
 	return;
 }
 
-static void das1800_handle_dma(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int status)
+static void das1800_handle_dma(struct comedi_device *dev,
+			       struct comedi_subdevice *s, unsigned int status)
 {
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-		devpriv->dma_current_buf);
+				  devpriv->dma_current_buf);
 	/*  re-enable  dma channel */
 	set_dma_addr(devpriv->dma_current,
-		virt_to_bus(devpriv->dma_current_buf));
+		     virt_to_bus(devpriv->dma_current_buf));
 	set_dma_count(devpriv->dma_current, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma_current);
 	release_dma_lock(flags);
@@ -999,14 +1023,14 @@ static void das1800_handle_dma(struct co
 }
 
 static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
-	uint16_t sample)
+					    uint16_t sample)
 {
 	sample += 1 << (thisboard->resolution - 1);
 	return sample;
 }
 
-static void munge_data(struct comedi_device *dev, uint16_t *array,
-	unsigned int num_elements)
+static void munge_data(struct comedi_device *dev, uint16_t * array,
+		       unsigned int num_elements)
 {
 	unsigned int i;
 	int unipolar;
@@ -1024,8 +1048,9 @@ static void munge_data(struct comedi_dev
 
 /* Utility function used by das1800_flush_dma() and das1800_handle_dma().
  * Assumes dma lock is held */
-static void das1800_flush_dma_channel(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int channel, uint16_t *buffer)
+static void das1800_flush_dma_channel(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      unsigned int channel, uint16_t * buffer)
 {
 	unsigned int num_bytes, num_samples;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1054,14 +1079,15 @@ static void das1800_flush_dma_channel(st
 
 /* flushes remaining data from board when external trigger has stopped aquisition
  * and we are using dma transfers */
-static void das1800_flush_dma(struct comedi_device *dev, struct comedi_subdevice *s)
+static void das1800_flush_dma(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-		devpriv->dma_current_buf);
+				  devpriv->dma_current_buf);
 
 	if (dual_dma) {
 		/*  switch to other channel and flush it */
@@ -1073,7 +1099,7 @@ static void das1800_flush_dma(struct com
 			devpriv->dma_current_buf = devpriv->ai_buf0;
 		}
 		das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-			devpriv->dma_current_buf);
+					  devpriv->dma_current_buf);
 	}
 
 	release_dma_lock(flags);
@@ -1085,7 +1111,7 @@ static void das1800_flush_dma(struct com
 }
 
 static void das1800_handle_fifo_half_full(struct comedi_device *dev,
-	struct comedi_subdevice *s)
+					  struct comedi_subdevice *s)
 {
 	int numPoints = 0;	/* number of points to read */
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1097,14 +1123,14 @@ static void das1800_handle_fifo_half_ful
 	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, numPoints);
 	munge_data(dev, devpriv->ai_buf0, numPoints);
 	cfc_write_array_to_buffer(s, devpriv->ai_buf0,
-		numPoints * sizeof(devpriv->ai_buf0[0]));
+				  numPoints * sizeof(devpriv->ai_buf0[0]));
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count -= numPoints;
 	return;
 }
 
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
-	struct comedi_subdevice *s)
+					  struct comedi_subdevice *s)
 {
 	short dpnt;
 	int unipolar;
@@ -1140,8 +1166,9 @@ static int das1800_cancel(struct comedi_
 }
 
 /* test analog input cmd */
-static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int das1800_ai_do_cmdtest(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1185,17 +1212,17 @@ static int das1800_ai_do_cmdtest(struct 
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_TIMER &&
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 	/* compatibility check */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->convert_src != TRIG_TIMER)
+	    cmd->convert_src != TRIG_TIMER)
 		err++;
 
 	if (err)
@@ -1250,9 +1277,11 @@ static int das1800_ai_do_cmdtest(struct 
 			tmp_arg = cmd->convert_arg;
 			/* calculate counter values that give desired timing */
 			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-				&(devpriv->divisor1), &(devpriv->divisor2),
-				&(cmd->convert_arg),
-				cmd->flags & TRIG_ROUND_MASK);
+						       &(devpriv->divisor1),
+						       &(devpriv->divisor2),
+						       &(cmd->convert_arg),
+						       cmd->
+						       flags & TRIG_ROUND_MASK);
 			if (tmp_arg != cmd->convert_arg)
 				err++;
 		}
@@ -1261,27 +1290,32 @@ static int das1800_ai_do_cmdtest(struct 
 			/*  check that convert_arg is compatible */
 			tmp_arg = cmd->convert_arg;
 			cmd->convert_arg =
-				burst_convert_arg(cmd->convert_arg,
-				cmd->flags & TRIG_ROUND_MASK);
+			    burst_convert_arg(cmd->convert_arg,
+					      cmd->flags & TRIG_ROUND_MASK);
 			if (tmp_arg != cmd->convert_arg)
 				err++;
 
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				/*  if scans are timed faster than conversion rate allows */
 				if (cmd->convert_arg * cmd->chanlist_len >
-					cmd->scan_begin_arg) {
+				    cmd->scan_begin_arg) {
 					cmd->scan_begin_arg =
-						cmd->convert_arg *
-						cmd->chanlist_len;
+					    cmd->convert_arg *
+					    cmd->chanlist_len;
 					err++;
 				}
 				tmp_arg = cmd->scan_begin_arg;
 				/* calculate counter values that give desired timing */
 				i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-					&(devpriv->divisor1),
-					&(devpriv->divisor2),
-					&(cmd->scan_begin_arg),
-					cmd->flags & TRIG_ROUND_MASK);
+							       &(devpriv->
+								 divisor1),
+							       &(devpriv->
+								 divisor2),
+							       &(cmd->
+								 scan_begin_arg),
+							       cmd->
+							       flags &
+							       TRIG_ROUND_MASK);
 				if (tmp_arg != cmd->scan_begin_arg)
 					err++;
 			}
@@ -1297,7 +1331,7 @@ static int das1800_ai_do_cmdtest(struct 
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (unipolar != (CR_RANGE(cmd->chanlist[i]) & UNIPOLAR)) {
 				comedi_error(dev,
-					"unipolar and bipolar ranges cannot be mixed in the chanlist");
+					     "unipolar and bipolar ranges cannot be mixed in the chanlist");
 				err++;
 				break;
 			}
@@ -1394,9 +1428,11 @@ static int setup_counters(struct comedi_
 		if (cmd.convert_src == TRIG_TIMER) {
 			/* set conversion frequency */
 			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-				&(devpriv->divisor1), &(devpriv->divisor2),
-				&(cmd.convert_arg),
-				cmd.flags & TRIG_ROUND_MASK);
+						       &(devpriv->divisor1),
+						       &(devpriv->divisor2),
+						       &(cmd.convert_arg),
+						       cmd.
+						       flags & TRIG_ROUND_MASK);
 			if (das1800_set_frequency(dev) < 0) {
 				return -1;
 			}
@@ -1405,8 +1441,9 @@ static int setup_counters(struct comedi_
 	case TRIG_TIMER:	/*  in burst mode */
 		/* set scan frequency */
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-			&(devpriv->divisor2), &(cmd.scan_begin_arg),
-			cmd.flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor2),
+					       &(cmd.scan_begin_arg),
+					       cmd.flags & TRIG_ROUND_MASK);
 		if (das1800_set_frequency(dev) < 0) {
 			return -1;
 		}
@@ -1478,9 +1515,9 @@ static void program_chanlist(struct come
 	/* make channel / gain list */
 	for (i = 0; i < n; i++) {
 		chan_range =
-			CR_CHAN(cmd.chanlist[i]) | ((CR_RANGE(cmd.
-					chanlist[i]) & range_mask) <<
-			range_bitshift);
+		    CR_CHAN(cmd.
+			    chanlist[i]) | ((CR_RANGE(cmd.chanlist[i]) &
+					     range_mask) << range_bitshift);
 		outw(chan_range, dev->iobase + DAS1800_QRAM);
 	}
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
@@ -1490,7 +1527,8 @@ static void program_chanlist(struct come
 }
 
 /* analog input do_cmd */
-static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das1800_ai_do_cmd(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	int ret;
 	int control_a, control_c;
@@ -1499,7 +1537,7 @@ static int das1800_ai_do_cmd(struct come
 
 	if (!dev->irq) {
 		comedi_error(dev,
-			"no irq assigned for das-1800, cannot do hardware conversions");
+			     "no irq assigned for das-1800, cannot do hardware conversions");
 		return -1;
 	}
 
@@ -1542,7 +1580,7 @@ static int das1800_ai_do_cmd(struct come
 	if (control_c & BMDE) {
 		/*  program conversion period with number of microseconds minus 1 */
 		outb(cmd.convert_arg / 1000 - 1,
-			dev->iobase + DAS1800_BURST_RATE);
+		     dev->iobase + DAS1800_BURST_RATE);
 		outb(cmd.chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);
 	}
 	outb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);	/*  enable irq/dma */
@@ -1553,8 +1591,9 @@ static int das1800_ai_do_cmd(struct come
 }
 
 /* read analog input */
-static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das1800_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan, range, aref, chan_range;
@@ -1613,8 +1652,9 @@ static int das1800_ai_rinsn(struct comed
 }
 
 /* writes to an analog output channel */
-static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das1800_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 /* int range = CR_RANGE(insn->chanspec); */
@@ -1642,8 +1682,9 @@ static int das1800_ao_winsn(struct comed
 }
 
 /* reads from digital input channels */
-static int das1800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das1800_di_rbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 
 	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
@@ -1653,8 +1694,9 @@ static int das1800_di_rbits(struct comed
 }
 
 /* writes to digital output channels */
-static int das1800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das1800_do_wbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int wbits;
 
@@ -1679,11 +1721,11 @@ static int das1800_set_frequency(struct 
 
 	/*  counter 1, mode 2 */
 	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 1, devpriv->divisor1,
-			2))
+		       2))
 		err++;
 	/*  counter 2, mode 2 */
 	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 2, devpriv->divisor2,
-			2))
+		       2))
 		err++;
 	if (err)
 		return -1;
@@ -1736,7 +1778,7 @@ static unsigned int suggest_transfer_siz
 		break;
 	case TRIG_TIMER:
 		size = (fill_time / (cmd->scan_begin_arg * cmd->chanlist_len)) *
-			sample_size;
+		    sample_size;
 		break;
 	default:
 		size = DMA_BUF_SIZE;
@@ -1747,7 +1789,7 @@ static unsigned int suggest_transfer_siz
 	max_size = DMA_BUF_SIZE;
 	/*  if we are taking limited number of conversions, limit transfer size to that */
 	if (cmd->stop_src == TRIG_COUNT &&
-		cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
+	    cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
 		max_size = cmd->stop_arg * cmd->chanlist_len * sample_size;
 
 	if (size > max_size)
--- a/drivers/staging/comedi/drivers/das6402.c
+++ b/drivers/staging/comedi/drivers/das6402.c
@@ -99,7 +99,8 @@ This driver has suffered bitrot.
 #define	C2 0x80
 #define	RWLH 0x30
 
-static int das6402_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das6402_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int das6402_detach(struct comedi_device *dev);
 static struct comedi_driver driver_das6402 = {
 	.driver_name = "das6402",
@@ -117,7 +118,8 @@ struct das6402_private {
 };
 #define devpriv ((struct das6402_private *)dev->private)
 
-static void das6402_ai_fifo_dregs(struct comedi_device *dev, struct comedi_subdevice *s);
+static void das6402_ai_fifo_dregs(struct comedi_device *dev,
+				  struct comedi_subdevice *s);
 
 static void das6402_setcounter(struct comedi_device *dev)
 {
@@ -163,7 +165,7 @@ static irqreturn_t intr_handler(int irq,
 	}
 #ifdef DEBUG
 	printk("das6402: interrupt! das6402_irqcount=%i\n",
-		devpriv->das6402_irqcount);
+	       devpriv->das6402_irqcount);
 	printk("das6402: iobase+2=%i\n", inw_p(dev->iobase + 2));
 #endif
 
@@ -174,7 +176,7 @@ static irqreturn_t intr_handler(int irq,
 		outb(0x07, dev->iobase + 8);	/* clears all flip-flops */
 #ifdef DEBUG
 		printk("das6402: Got %i samples\n\n",
-			devpriv->das6402_wordsread - diff);
+		       devpriv->das6402_wordsread - diff);
 #endif
 		s->async->events |= COMEDI_CB_EOA;
 		comedi_event(dev, s);
@@ -196,7 +198,8 @@ static void das6402_ai_fifo_read(struct 
 }
 #endif
 
-static void das6402_ai_fifo_dregs(struct comedi_device *dev, struct comedi_subdevice *s)
+static void das6402_ai_fifo_dregs(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	while (1) {
 		if (!(inb(dev->iobase + 8) & 0x01))
@@ -205,7 +208,8 @@ static void das6402_ai_fifo_dregs(struct
 	}
 }
 
-static int das6402_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das6402_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	/*
 	 *  This function should reset the board from whatever condition it
@@ -227,8 +231,8 @@ static int das6402_ai_cancel(struct come
 }
 
 #ifdef unused
-static int das6402_ai_mode2(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_trig *it)
+static int das6402_ai_mode2(struct comedi_device *dev,
+			    struct comedi_subdevice *s, comedi_trig * it)
 {
 	devpriv->das6402_ignoreirq = 1;
 
@@ -300,7 +304,8 @@ static int das6402_detach(struct comedi_
 	return 0;
 }
 
-static int das6402_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int das6402_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	unsigned int irq;
 	unsigned long iobase;
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -118,114 +118,114 @@ struct das800_board {
 static const struct comedi_lrange range_das800_ai = {
 	1,
 	{
-			RANGE(-5, 5),
-		}
+	 RANGE(-5, 5),
+	 }
 };
 
 static const struct comedi_lrange range_das801_ai = {
 	9,
 	{
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE(-0.5, 0.5),
-			RANGE(0, 1),
-			RANGE(-0.05, 0.05),
-			RANGE(0, 0.1),
-			RANGE(-0.01, 0.01),
-			RANGE(0, 0.02),
-		}
+	 RANGE(-5, 5),
+	 RANGE(-10, 10),
+	 RANGE(0, 10),
+	 RANGE(-0.5, 0.5),
+	 RANGE(0, 1),
+	 RANGE(-0.05, 0.05),
+	 RANGE(0, 0.1),
+	 RANGE(-0.01, 0.01),
+	 RANGE(0, 0.02),
+	 }
 };
 
 static const struct comedi_lrange range_cio_das801_ai = {
 	9,
 	{
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE(-0.5, 0.5),
-			RANGE(0, 1),
-			RANGE(-0.05, 0.05),
-			RANGE(0, 0.1),
-			RANGE(-0.005, 0.005),
-			RANGE(0, 0.01),
-		}
+	 RANGE(-5, 5),
+	 RANGE(-10, 10),
+	 RANGE(0, 10),
+	 RANGE(-0.5, 0.5),
+	 RANGE(0, 1),
+	 RANGE(-0.05, 0.05),
+	 RANGE(0, 0.1),
+	 RANGE(-0.005, 0.005),
+	 RANGE(0, 0.01),
+	 }
 };
 
 static const struct comedi_lrange range_das802_ai = {
 	9,
 	{
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE(-2.5, 2.5),
-			RANGE(0, 5),
-			RANGE(-1.25, 1.25),
-			RANGE(0, 2.5),
-			RANGE(-0.625, 0.625),
-			RANGE(0, 1.25),
-		}
+	 RANGE(-5, 5),
+	 RANGE(-10, 10),
+	 RANGE(0, 10),
+	 RANGE(-2.5, 2.5),
+	 RANGE(0, 5),
+	 RANGE(-1.25, 1.25),
+	 RANGE(0, 2.5),
+	 RANGE(-0.625, 0.625),
+	 RANGE(0, 1.25),
+	 }
 };
 
 static const struct comedi_lrange range_das80216_ai = {
 	8,
 	{
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE(-5, 5),
-			RANGE(0, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(0, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(0, 1.25),
-		}
+	 RANGE(-10, 10),
+	 RANGE(0, 10),
+	 RANGE(-5, 5),
+	 RANGE(0, 5),
+	 RANGE(-2.5, 2.5),
+	 RANGE(0, 2.5),
+	 RANGE(-1.25, 1.25),
+	 RANGE(0, 1.25),
+	 }
 };
 
 enum { das800, ciodas800, das801, ciodas801, das802, ciodas802, ciodas80216 };
 
 static const struct das800_board das800_boards[] = {
 	{
-	.name = "das-800",
-	.ai_speed = 25000,
-	.ai_range = &range_das800_ai,
-	.resolution = 12,
-		},
-	{
-	.name = "cio-das800",
-	.ai_speed = 20000,
-	.ai_range = &range_das800_ai,
-	.resolution = 12,
-		},
-	{
-	.name = "das-801",
-	.ai_speed = 25000,
-	.ai_range = &range_das801_ai,
-	.resolution = 12,
-		},
-	{
-	.name = "cio-das801",
-	.ai_speed = 20000,
-	.ai_range = &range_cio_das801_ai,
-	.resolution = 12,
-		},
-	{
-	.name = "das-802",
-	.ai_speed = 25000,
-	.ai_range = &range_das802_ai,
-	.resolution = 12,
-		},
-	{
-	.name = "cio-das802",
-	.ai_speed = 20000,
-	.ai_range = &range_das802_ai,
-	.resolution = 12,
-		},
-	{
-	.name = "cio-das802/16",
-	.ai_speed = 10000,
-	.ai_range = &range_das80216_ai,
-	.resolution = 16,
-		},
+	 .name = "das-800",
+	 .ai_speed = 25000,
+	 .ai_range = &range_das800_ai,
+	 .resolution = 12,
+	 },
+	{
+	 .name = "cio-das800",
+	 .ai_speed = 20000,
+	 .ai_range = &range_das800_ai,
+	 .resolution = 12,
+	 },
+	{
+	 .name = "das-801",
+	 .ai_speed = 25000,
+	 .ai_range = &range_das801_ai,
+	 .resolution = 12,
+	 },
+	{
+	 .name = "cio-das801",
+	 .ai_speed = 20000,
+	 .ai_range = &range_cio_das801_ai,
+	 .resolution = 12,
+	 },
+	{
+	 .name = "das-802",
+	 .ai_speed = 25000,
+	 .ai_range = &range_das802_ai,
+	 .resolution = 12,
+	 },
+	{
+	 .name = "cio-das802",
+	 .ai_speed = 20000,
+	 .ai_range = &range_das802_ai,
+	 .resolution = 12,
+	 },
+	{
+	 .name = "cio-das802/16",
+	 .ai_speed = 10000,
+	 .ai_range = &range_das80216_ai,
+	 .resolution = 16,
+	 },
 };
 
 /*
@@ -243,7 +243,8 @@ struct das800_private {
 
 #define devpriv ((struct das800_private *)dev->private)
 
-static int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das800_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int das800_detach(struct comedi_device *dev);
 static int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
@@ -260,15 +261,20 @@ static struct comedi_driver driver_das80
 static irqreturn_t das800_interrupt(int irq, void *d);
 static void enable_das800(struct comedi_device *dev);
 static void disable_das800(struct comedi_device *dev);
-static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int das800_ai_do_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd);
+static int das800_ai_do_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int das800_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int das800_di_rbits(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int das800_do_wbits(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
 static int das800_probe(struct comedi_device *dev);
 static int das800_set_frequency(struct comedi_device *dev);
 
@@ -330,7 +336,7 @@ static int das800_probe(struct comedi_de
 		break;
 	default:
 		printk(" Board model: probe returned 0x%x (unknown)\n",
-			id_bits);
+		       id_bits);
 		return board;
 		break;
 	}
@@ -429,7 +435,7 @@ static irqreturn_t das800_interrupt(int 
 		 * We already have spinlock, so indirect addressing is safe */
 		outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be control register 1 */
 		outb(CONTROL1_INTE | devpriv->do_bits,
-			dev->iobase + DAS800_CONTROL1);
+		     dev->iobase + DAS800_CONTROL1);
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		/* otherwise, stop taking data */
 	} else {
@@ -585,8 +591,9 @@ static void disable_das800(struct comedi
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-static int das800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int das800_ai_do_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -676,8 +683,9 @@ static int das800_ai_do_cmdtest(struct c
 		tmp = cmd->convert_arg;
 		/* calculate counter values that give desired timing */
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-			&(devpriv->divisor2), &(cmd->convert_arg),
-			cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor2),
+					       &(cmd->convert_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -691,14 +699,14 @@ static int das800_ai_do_cmdtest(struct c
 		startChan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				(startChan + i) % N_CHAN_AI) {
+			    (startChan + i) % N_CHAN_AI) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					"entries in chanlist must all have the same gain\n");
+					     "entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -710,7 +718,8 @@ static int das800_ai_do_cmdtest(struct c
 	return 0;
 }
 
-static int das800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das800_ai_do_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	int startChan, endChan, scan, gain;
 	int conv_bits;
@@ -719,7 +728,7 @@ static int das800_ai_do_cmd(struct comed
 
 	if (!dev->irq) {
 		comedi_error(dev,
-			"no irq assigned for das-800, cannot do hardware conversions");
+			     "no irq assigned for das-800, cannot do hardware conversions");
 		return -1;
 	}
 
@@ -767,8 +776,10 @@ static int das800_ai_do_cmd(struct comed
 		conv_bits |= CASC | ITE;
 		/* set conversion frequency */
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-			&(devpriv->divisor2), &(async->cmd.convert_arg),
-			async->cmd.flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor2),
+					       &(async->cmd.convert_arg),
+					       async->cmd.
+					       flags & TRIG_ROUND_MASK);
 		if (das800_set_frequency(dev) < 0) {
 			comedi_error(dev, "Error setting up counters");
 			return -1;
@@ -789,8 +800,9 @@ static int das800_ai_do_cmd(struct comed
 	return 0;
 }
 
-static int das800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das800_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i, n;
 	int chan;
@@ -843,8 +855,9 @@ static int das800_ai_rinsn(struct comedi
 	return n;
 }
 
-static int das800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das800_di_rbits(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	unsigned int bits;
 
@@ -856,8 +869,9 @@ static int das800_di_rbits(struct comedi
 	return 2;
 }
 
-static int das800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das800_do_wbits(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int wbits;
 	unsigned long irq_flags;
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -168,11 +168,11 @@ Configuration Options:
 static const struct comedi_lrange dmm32at_airanges = {
 	4,
 	{
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-		}
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 }
 };
 
 /* register values for above ranges */
@@ -189,11 +189,11 @@ static const unsigned char dmm32at_range
 static const struct comedi_lrange dmm32at_aoranges = {
 	4,
 	{
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-		}
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 }
 };
 
 /*
@@ -214,16 +214,16 @@ struct dmm32at_board {
 };
 static const struct dmm32at_board dmm32at_boards[] = {
 	{
-	.name = "dmm32at",
-	.ai_chans = 32,
-	.ai_bits = 16,
-	.ai_ranges = &dmm32at_airanges,
-	.ao_chans = 4,
-	.ao_bits = 12,
-	.ao_ranges = &dmm32at_aoranges,
-	.have_dio = 1,
-	.dio_chans = 24,
-		},
+	 .name = "dmm32at",
+	 .ai_chans = 32,
+	 .ai_bits = 16,
+	 .ai_ranges = &dmm32at_airanges,
+	 .ao_chans = 4,
+	 .ao_bits = 12,
+	 .ao_ranges = &dmm32at_aoranges,
+	 .have_dio = 1,
+	 .dio_chans = 24,
+	 },
 };
 
 /*
@@ -259,7 +259,8 @@ struct dmm32at_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dmm32at_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int dmm32at_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dmm32at = {
 	.driver_name = "dmm32at",
@@ -290,20 +291,29 @@ static struct comedi_driver driver_dmm32
 };
 
 /* prototypes for driver functions below */
-static int dmm32at_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int dmm32at_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int dmm32at_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
+static int dmm32at_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd);
+static int dmm32at_ai_cmd(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
+static int dmm32at_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 static int dmm32at_ns_to_timer(unsigned int *ns, int round);
 static irqreturn_t dmm32at_isr(int irq, void *d);
 void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec);
@@ -314,7 +324,8 @@ void dmm32at_setaitimer(struct comedi_de
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int dmm32at_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	int ret;
 	struct comedi_subdevice *s;
@@ -369,12 +380,12 @@ static int dmm32at_attach(struct comedi_
 	airback = dmm_inb(dev, DMM32AT_AIRBACK);
 
 	printk("dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
-		ailo, aihi, fifostat);
+	       ailo, aihi, fifostat);
 	printk("dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x\n",
-		aistat, intstat, airback);
+	       aistat, intstat, airback);
 
 	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
-		(aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
+	    (aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
 		printk("dmmat32: board detection failed\n");
 		return -EIO;
 	}
@@ -450,7 +461,7 @@ static int dmm32at_attach(struct comedi_
 		dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
 		/* set the DIO's to the defualt input setting */
 		devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
-			DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
+		    DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
 		dmm_outb(dev, DMM32AT_DIOCONF, devpriv->dio_config);
 
 		/* set up the subdevice */
@@ -497,8 +508,9 @@ static int dmm32at_detach(struct comedi_
  * mode.
  */
 
-static int dmm32at_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	unsigned int d;
@@ -568,8 +580,9 @@ static int dmm32at_ai_rinsn(struct comed
 	return n;
 }
 
-static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int dmm32at_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -618,7 +631,7 @@ static int dmm32at_ai_cmdtest(struct com
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
@@ -703,21 +716,21 @@ static int dmm32at_ai_cmdtest(struct com
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		dmm32at_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				    cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		dmm32at_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				    cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->scan_end_arg) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -733,14 +746,14 @@ static int dmm32at_ai_cmdtest(struct com
 		start_chan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				(start_chan + i) % s->n_chan) {
+			    (start_chan + i) % s->n_chan) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					"entries in chanlist must all have the same gain\n");
+					     "entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -822,7 +835,8 @@ static int dmm32at_ai_cmd(struct comedi_
 
 }
 
-static int dmm32at_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dmm32at_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	devpriv->ai_scans_left = 1;
 	return 0;
@@ -893,8 +907,9 @@ static int dmm32at_ns_to_timer(unsigned 
 	return *ns;
 }
 
-static int dmm32at_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -936,8 +951,9 @@ static int dmm32at_ao_winsn(struct comed
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int dmm32at_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -953,8 +969,9 @@ static int dmm32at_ao_rinsn(struct comed
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int dmm32at_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned char diobits;
 
@@ -975,7 +992,7 @@ static int dmm32at_dio_insn_bits(struct 
 
 	/* if either part of dio is set for output */
 	if (((devpriv->dio_config & DMM32AT_DIRCL) == 0) ||
-		((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
+	    ((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
 		diobits = (s->state & 0x00ff0000) >> 16;
 		dmm_outb(dev, DMM32AT_DIOC, diobits);
 	}
@@ -1006,8 +1023,9 @@ static int dmm32at_dio_insn_bits(struct 
 	return 2;
 }
 
-static int dmm32at_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned char chanbit;
 	int chan = CR_CHAN(insn->chanspec);
--- a/drivers/staging/comedi/drivers/dt2801.c
+++ b/drivers/staging/comedi/drivers/dt2801.c
@@ -88,7 +88,8 @@ Configuration options:
 #define DT2801_STATUS		1
 #define DT2801_CMD		1
 
-static int dt2801_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt2801_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dt2801_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt2801 = {
 	.driver_name = "dt2801",
@@ -102,37 +103,57 @@ COMEDI_INITCLEANUP(driver_dt2801);
 #if 0
 /* ignore 'defined but not used' warning */
 static const struct comedi_lrange range_dt2801_ai_pgh_bipolar = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-	}
+								      RANGE(-10,
+									    10),
+								      RANGE(-5,
+									    5),
+								      RANGE
+								      (-2.5,
+								       2.5),
+								      RANGE
+								      (-1.25,
+								       1.25),
+								      }
 };
 #endif
 static const struct comedi_lrange range_dt2801_ai_pgl_bipolar = { 4, {
-			RANGE(-10, 10),
-			RANGE(-1, 1),
-			RANGE(-0.1, 0.1),
-			RANGE(-0.02, 0.02),
-	}
+								      RANGE(-10,
+									    10),
+								      RANGE(-1,
+									    1),
+								      RANGE
+								      (-0.1,
+								       0.1),
+								      RANGE
+								      (-0.02,
+								       0.02),
+								      }
 };
 
 #if 0
 /* ignore 'defined but not used' warning */
 static const struct comedi_lrange range_dt2801_ai_pgh_unipolar = { 4, {
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25),
-	}
+								       RANGE(0,
+									     10),
+								       RANGE(0,
+									     5),
+								       RANGE(0,
+									     2.5),
+								       RANGE(0,
+									     1.25),
+								       }
 };
 #endif
 static const struct comedi_lrange range_dt2801_ai_pgl_unipolar = { 4, {
-			RANGE(0, 10),
-			RANGE(0, 1),
-			RANGE(0, 0.1),
-			RANGE(0, 0.02),
-	}
+								       RANGE(0,
+									     10),
+								       RANGE(0,
+									     1),
+								       RANGE(0,
+									     0.1),
+								       RANGE(0,
+									     0.02),
+								       }
 };
 
 struct dt2801_board {
@@ -146,75 +167,74 @@ struct dt2801_board {
 	int dabits;
 };
 
-
 /* Typeid's for the different boards of the DT2801-series
    (taken from the test-software, that comes with the board)
    */
 static const struct dt2801_board boardtypes[] = {
 	{
-	.name = "dt2801",
-	.boardcode = 0x09,
-	.ad_diff = 2,
-	.ad_chan = 16,
-	.adbits = 12,
-	.adrangetype = 0,
-	.dabits = 12},
+	 .name = "dt2801",
+	 .boardcode = 0x09,
+	 .ad_diff = 2,
+	 .ad_chan = 16,
+	 .adbits = 12,
+	 .adrangetype = 0,
+	 .dabits = 12},
 	{
-	.name = "dt2801-a",
-	.boardcode = 0x52,
-	.ad_diff = 2,
-	.ad_chan = 16,
-	.adbits = 12,
-	.adrangetype = 0,
-	.dabits = 12},
+	 .name = "dt2801-a",
+	 .boardcode = 0x52,
+	 .ad_diff = 2,
+	 .ad_chan = 16,
+	 .adbits = 12,
+	 .adrangetype = 0,
+	 .dabits = 12},
 	{
-	.name = "dt2801/5716a",
-	.boardcode = 0x82,
-	.ad_diff = 1,
-	.ad_chan = 16,
-	.adbits = 16,
-	.adrangetype = 1,
-	.dabits = 12},
+	 .name = "dt2801/5716a",
+	 .boardcode = 0x82,
+	 .ad_diff = 1,
+	 .ad_chan = 16,
+	 .adbits = 16,
+	 .adrangetype = 1,
+	 .dabits = 12},
 	{
-	.name = "dt2805",
-	.boardcode = 0x12,
-	.ad_diff = 1,
-	.ad_chan = 16,
-	.adbits = 12,
-	.adrangetype = 0,
-	.dabits = 12},
+	 .name = "dt2805",
+	 .boardcode = 0x12,
+	 .ad_diff = 1,
+	 .ad_chan = 16,
+	 .adbits = 12,
+	 .adrangetype = 0,
+	 .dabits = 12},
 	{
-	.name = "dt2805/5716a",
-	.boardcode = 0x92,
-	.ad_diff = 1,
-	.ad_chan = 16,
-	.adbits = 16,
-	.adrangetype = 1,
-	.dabits = 12},
+	 .name = "dt2805/5716a",
+	 .boardcode = 0x92,
+	 .ad_diff = 1,
+	 .ad_chan = 16,
+	 .adbits = 16,
+	 .adrangetype = 1,
+	 .dabits = 12},
 	{
-	.name = "dt2808",
-	.boardcode = 0x20,
-	.ad_diff = 0,
-	.ad_chan = 16,
-	.adbits = 12,
-	.adrangetype = 2,
-	.dabits = 8},
+	 .name = "dt2808",
+	 .boardcode = 0x20,
+	 .ad_diff = 0,
+	 .ad_chan = 16,
+	 .adbits = 12,
+	 .adrangetype = 2,
+	 .dabits = 8},
 	{
-	.name = "dt2818",
-	.boardcode = 0xa2,
-	.ad_diff = 0,
-	.ad_chan = 4,
-	.adbits = 12,
-	.adrangetype = 0,
-	.dabits = 12},
+	 .name = "dt2818",
+	 .boardcode = 0xa2,
+	 .ad_diff = 0,
+	 .ad_chan = 4,
+	 .adbits = 12,
+	 .adrangetype = 0,
+	 .dabits = 12},
 	{
-	.name = "dt2809",
-	.boardcode = 0xb0,
-	.ad_diff = 0,
-	.ad_chan = 8,
-	.adbits = 12,
-	.adrangetype = 1,
-	.dabits = 12},
+	 .name = "dt2809",
+	 .boardcode = 0xb0,
+	 .ad_diff = 0,
+	 .ad_chan = 8,
+	 .adbits = 12,
+	 .adrangetype = 1,
+	 .dabits = 12},
 };
 
 #define boardtype (*(const struct dt2801_board *)dev->board_ptr)
@@ -227,16 +247,21 @@ struct dt2801_private {
 
 #define devpriv ((struct dt2801_private *)dev->private)
 
-static int dt2801_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dt2801_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dt2801_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dt2801_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dt2801_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int dt2801_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int dt2801_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int dt2801_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int dt2801_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int dt2801_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
 
 /* These are the low-level routines:
    writecommand: write a command to the board
@@ -299,7 +324,8 @@ static int dt2801_writedata(struct comed
 		}
 #if 0
 		if (stat & DT_S_READY) {
-			printk("dt2801: ready flag set (bad!) in dt2801_writedata()\n");
+			printk
+			    ("dt2801: ready flag set (bad!) in dt2801_writedata()\n");
 			return -EIO;
 		}
 #endif
@@ -353,7 +379,8 @@ static int dt2801_writecmd(struct comedi
 
 	stat = inb_p(dev->iobase + DT2801_STATUS);
 	if (stat & DT_S_COMPOSITE_ERROR) {
-		printk("dt2801: composite-error in dt2801_writecmd(), ignoring\n");
+		printk
+		    ("dt2801: composite-error in dt2801_writecmd(), ignoring\n");
 	}
 	if (!(stat & DT_S_READY)) {
 		printk("dt2801: !ready in dt2801_writecmd(), ignoring\n");
@@ -463,8 +490,8 @@ static const struct comedi_lrange *ai_ra
 	switch (type) {
 	case 0:
 		return (opt) ?
-			&range_dt2801_ai_pgl_unipolar :
-			&range_dt2801_ai_pgl_bipolar;
+		    &range_dt2801_ai_pgl_unipolar :
+		    &range_dt2801_ai_pgl_bipolar;
 	case 1:
 		return (opt) ? &range_unipolar10 : &range_bipolar10;
 	case 2:
@@ -510,10 +537,10 @@ static int dt2801_attach(struct comedi_d
 			goto havetype;
 	}
 	printk("dt2801: unrecognized board code=0x%02x, contact author\n",
-		board_code);
+	       board_code);
 	type = 0;
 
-      havetype:
+havetype:
 	dev->board_ptr = boardtypes + type;
 	printk("dt2801: %s at port 0x%lx", boardtype.name, iobase);
 
@@ -579,7 +606,7 @@ static int dt2801_attach(struct comedi_d
 	s->insn_config = dt2801_dio_insn_config;
 
 	ret = 0;
-      out:
+out:
 	printk("\n");
 
 	return ret;
@@ -611,8 +638,9 @@ static int dt2801_error(struct comedi_de
 	return -EIO;
 }
 
-static int dt2801_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2801_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int d;
 	int stat;
@@ -633,16 +661,18 @@ static int dt2801_ai_insn_read(struct co
 	return i;
 }
 
-static int dt2801_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2801_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int dt2801_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2801_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	dt2801_writecmd(dev, DT_C_WRITE_DAIM);
 	dt2801_writedata(dev, CR_CHAN(insn->chanspec));
@@ -653,8 +683,9 @@ static int dt2801_ao_insn_write(struct c
 	return 1;
 }
 
-static int dt2801_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2801_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int which = 0;
 
@@ -677,8 +708,9 @@ static int dt2801_dio_insn_bits(struct c
 	return 2;
 }
 
-static int dt2801_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2801_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int which = 0;
 
--- a/drivers/staging/comedi/drivers/dt2811.c
+++ b/drivers/staging/comedi/drivers/dt2811.c
@@ -53,46 +53,95 @@ Configuration options:
 static const char *driver_name = "dt2811";
 
 static const struct comedi_lrange range_dt2811_pgh_ai_5_unipolar = { 4, {
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25),
-			RANGE(0, 0.625)
-	}
+									 RANGE
+									 (0, 5),
+									 RANGE
+									 (0,
+									  2.5),
+									 RANGE
+									 (0,
+									  1.25),
+									 RANGE
+									 (0,
+									  0.625)
+									 }
 };
+
 static const struct comedi_lrange range_dt2811_pgh_ai_2_5_bipolar = { 4, {
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(-0.625, 0.625),
-			RANGE(-0.3125, 0.3125)
-	}
+									  RANGE
+									  (-2.5,
+									   2.5),
+									  RANGE
+									  (-1.25,
+									   1.25),
+									  RANGE
+									  (-0.625,
+									   0.625),
+									  RANGE
+									  (-0.3125,
+									   0.3125)
+									  }
 };
+
 static const struct comedi_lrange range_dt2811_pgh_ai_5_bipolar = { 4, {
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(-0.625, 0.625)
-	}
+									RANGE
+									(-5, 5),
+									RANGE
+									(-2.5,
+									 2.5),
+									RANGE
+									(-1.25,
+									 1.25),
+									RANGE
+									(-0.625,
+									 0.625)
+									}
 };
+
 static const struct comedi_lrange range_dt2811_pgl_ai_5_unipolar = { 4, {
-			RANGE(0, 5),
-			RANGE(0, 0.5),
-			RANGE(0, 0.05),
-			RANGE(0, 0.01)
-	}
+									 RANGE
+									 (0, 5),
+									 RANGE
+									 (0,
+									  0.5),
+									 RANGE
+									 (0,
+									  0.05),
+									 RANGE
+									 (0,
+									  0.01)
+									 }
 };
+
 static const struct comedi_lrange range_dt2811_pgl_ai_2_5_bipolar = { 4, {
-			RANGE(-2.5, 2.5),
-			RANGE(-0.25, 0.25),
-			RANGE(-0.025, 0.025),
-			RANGE(-0.005, 0.005)
-	}
+									  RANGE
+									  (-2.5,
+									   2.5),
+									  RANGE
+									  (-0.25,
+									   0.25),
+									  RANGE
+									  (-0.025,
+									   0.025),
+									  RANGE
+									  (-0.005,
+									   0.005)
+									  }
 };
+
 static const struct comedi_lrange range_dt2811_pgl_ai_5_bipolar = { 4, {
-			RANGE(-5, 5),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.05, 0.05),
-			RANGE(-0.01, 0.01)
-	}
+									RANGE
+									(-5, 5),
+									RANGE
+									(-0.5,
+									 0.5),
+									RANGE
+									(-0.05,
+									 0.05),
+									RANGE
+									(-0.01,
+									 0.01)
+									}
 };
 
 /*
@@ -202,20 +251,21 @@ struct dt2811_board {
 
 static const struct dt2811_board boardtypes[] = {
 	{"dt2811-pgh",
-			&range_dt2811_pgh_ai_5_bipolar,
-			&range_dt2811_pgh_ai_2_5_bipolar,
-			&range_dt2811_pgh_ai_5_unipolar,
-		},
+	 &range_dt2811_pgh_ai_5_bipolar,
+	 &range_dt2811_pgh_ai_2_5_bipolar,
+	 &range_dt2811_pgh_ai_5_unipolar,
+	 },
 	{"dt2811-pgl",
-			&range_dt2811_pgl_ai_5_bipolar,
-			&range_dt2811_pgl_ai_2_5_bipolar,
-			&range_dt2811_pgl_ai_5_unipolar,
-		},
+	 &range_dt2811_pgl_ai_5_bipolar,
+	 &range_dt2811_pgl_ai_2_5_bipolar,
+	 &range_dt2811_pgl_ai_5_unipolar,
+	 },
 };
 
 #define this_board ((const struct dt2811_board *)dev->board_ptr)
 
-static int dt2811_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt2811_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dt2811_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt2811 = {
 	.driver_name = "dt2811",
@@ -230,15 +280,18 @@ static struct comedi_driver driver_dt281
 COMEDI_INITCLEANUP(driver_dt2811);
 
 static int dt2811_ai_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int dt2811_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dt2811_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dt2811_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dt2811_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
+static int dt2811_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int dt2811_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int dt2811_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 enum { card_2811_pgh, card_2811_pgl };
 
@@ -349,7 +402,7 @@ static int dt2811_attach(struct comedi_d
 		irqs = probe_irq_on();
 
 		outb(DT2811_CLRERROR | DT2811_INTENB,
-			dev->iobase + DT2811_ADCSR);
+		     dev->iobase + DT2811_ADCSR);
 		outb(0, dev->iobase + DT2811_ADGCR);
 
 		udelay(100);
@@ -368,7 +421,7 @@ static int dt2811_attach(struct comedi_d
 			i = inb(dev->iobase + DT2811_ADDATHI);
 			printk("(irq = %d)\n", irq);
 			ret = request_irq(irq, dt2811_interrupt, 0,
-				driver_name, dev);
+					  driver_name, dev);
 			if (ret < 0)
 				return -EIO;
 			dev->irq = irq;
@@ -500,7 +553,7 @@ static int dt2811_detach(struct comedi_d
 }
 
 static int dt2811_ai_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int timeout = DT2811_TIMEOUT;
@@ -510,7 +563,7 @@ static int dt2811_ai_insn(struct comedi_
 		outb(chan, dev->iobase + DT2811_ADGCR);
 
 		while (timeout
-			&& inb(dev->iobase + DT2811_ADCSR) & DT2811_ADBUSY)
+		       && inb(dev->iobase + DT2811_ADCSR) & DT2811_ADBUSY)
 			timeout--;
 		if (!timeout)
 			return -ETIME;
@@ -526,7 +579,7 @@ static int dt2811_ai_insn(struct comedi_
 #if 0
 /* Wow.  This is code from the Comedi stone age.  But it hasn't been
  * replaced, so I'll let it stay. */
-int dt2811_adtrig(kdev_t minor, comedi_adtrig *adtrig)
+int dt2811_adtrig(kdev_t minor, comedi_adtrig * adtrig)
 {
 	struct comedi_device *dev = comedi_devices + minor;
 
@@ -537,7 +590,7 @@ int dt2811_adtrig(kdev_t minor, comedi_a
 	case COMEDI_MDEMAND:
 		dev->ntrig = adtrig->n - 1;
 		/*printk("dt2811: AD soft trigger\n"); */
-		/*outb(DT2811_CLRERROR|DT2811_INTENB,dev->iobase+DT2811_ADCSR); */ /* not neccessary */
+		/*outb(DT2811_CLRERROR|DT2811_INTENB,dev->iobase+DT2811_ADCSR); *//* not neccessary */
 		outb(dev->curadchan, dev->iobase + DT2811_ADGCR);
 		do_gettimeofday(&trigtime);
 		break;
@@ -551,7 +604,7 @@ int dt2811_adtrig(kdev_t minor, comedi_a
 #endif
 
 static int dt2811_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan;
@@ -561,15 +614,16 @@ static int dt2811_ao_insn(struct comedi_
 	for (i = 0; i < insn->n; i++) {
 		outb(data[i] & 0xff, dev->iobase + DT2811_DADAT0LO + 2 * chan);
 		outb((data[i] >> 8) & 0xff,
-			dev->iobase + DT2811_DADAT0HI + 2 * chan);
+		     dev->iobase + DT2811_DADAT0HI + 2 * chan);
 		devpriv->ao_readback[chan] = data[i];
 	}
 
 	return i;
 }
 
-static int dt2811_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2811_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan;
@@ -583,8 +637,9 @@ static int dt2811_ao_insn_read(struct co
 	return i;
 }
 
-static int dt2811_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2811_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -594,8 +649,9 @@ static int dt2811_di_insn_bits(struct co
 	return 2;
 }
 
-static int dt2811_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2811_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
--- a/drivers/staging/comedi/drivers/dt2814.c
+++ b/drivers/staging/comedi/drivers/dt2814.c
@@ -60,7 +60,8 @@ addition, the clock does not seem to be 
 #define DT2814_ENB 0x10
 #define DT2814_CHANMASK 0x0f
 
-static int dt2814_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt2814_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dt2814_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt2814 = {
 	.driver_name = "dt2814",
@@ -84,8 +85,9 @@ struct dt2814_private {
 #define DT2814_TIMEOUT 10
 #define DT2814_MAX_SPEED 100000	/* Arbitrary 10 khz limit */
 
-static int dt2814_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2814_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i, hi, lo;
 	int chan;
@@ -135,8 +137,8 @@ static int dt2814_ns_to_timer(unsigned i
 	return i;
 }
 
-static int dt2814_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int dt2814_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -234,8 +236,8 @@ static int dt2814_ai_cmd(struct comedi_d
 	int trigvar;
 
 	trigvar =
-		dt2814_ns_to_timer(&cmd->scan_begin_arg,
-		cmd->flags & TRIG_ROUND_MASK);
+	    dt2814_ns_to_timer(&cmd->scan_begin_arg,
+			       cmd->flags & TRIG_ROUND_MASK);
 
 	chan = CR_CHAN(cmd->chanlist[0]);
 
--- a/drivers/staging/comedi/drivers/dt2815.c
+++ b/drivers/staging/comedi/drivers/dt2815.c
@@ -62,12 +62,15 @@ Configuration options:
 #include <linux/delay.h>
 
 static const struct comedi_lrange range_dt2815_ao_32_current = { 1, {
-			RANGE_mA(0, 32)
-	}
+								     RANGE_mA(0,
+									      32)
+								     }
 };
+
 static const struct comedi_lrange range_dt2815_ao_20_current = { 1, {
-			RANGE_mA(4, 20)
-	}
+								     RANGE_mA(4,
+									      20)
+								     }
 };
 
 #define DT2815_SIZE 2
@@ -75,7 +78,8 @@ static const struct comedi_lrange range_
 #define DT2815_DATA 0
 #define DT2815_STATUS 1
 
-static int dt2815_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt2815_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dt2815_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt2815 = {
 	.driver_name = "dt2815",
@@ -94,7 +98,6 @@ struct dt2815_private {
 	unsigned int ao_readback[8];
 };
 
-
 #define devpriv ((struct dt2815_private *)dev->private)
 
 static int dt2815_wait_for_status(struct comedi_device *dev, int status)
@@ -108,8 +111,9 @@ static int dt2815_wait_for_status(struct
 	return status;
 }
 
-static int dt2815_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2815_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -122,7 +126,7 @@ static int dt2815_ao_insn_read(struct co
 }
 
 static int dt2815_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -136,8 +140,8 @@ static int dt2815_ao_insn(struct comedi_
 		status = dt2815_wait_for_status(dev, 0x00);
 		if (status != 0) {
 			printk
-				("dt2815: failed to write low byte on %d reason %x\n",
-				chan, status);
+			    ("dt2815: failed to write low byte on %d reason %x\n",
+			     chan, status);
 			return -EBUSY;
 		}
 
@@ -146,8 +150,8 @@ static int dt2815_ao_insn(struct comedi_
 		status = dt2815_wait_for_status(dev, 0x10);
 		if (status != 0x10) {
 			printk
-				("dt2815: failed to write high byte on %d reason %x\n",
-				chan, status);
+			    ("dt2815: failed to write high byte on %d reason %x\n",
+			     chan, status);
 			return -EBUSY;
 		}
 		devpriv->ao_readback[chan] = data[i];
@@ -212,12 +216,12 @@ static int dt2815_attach(struct comedi_d
 	s->range_table_list = devpriv->range_type_list;
 
 	current_range_type = (it->options[3])
-		? &range_dt2815_ao_20_current : &range_dt2815_ao_32_current;
+	    ? &range_dt2815_ao_20_current : &range_dt2815_ao_32_current;
 	voltage_range_type = (it->options[2])
-		? &range_bipolar5 : &range_unipolar5;
+	    ? &range_bipolar5 : &range_unipolar5;
 	for (i = 0; i < 8; i++) {
 		devpriv->range_type_list[i] = (it->options[5 + i])
-			? current_range_type : voltage_range_type;
+		    ? current_range_type : voltage_range_type;
 	}
 
 	/* Init the 2815 */
@@ -236,7 +240,7 @@ static int dt2815_attach(struct comedi_d
 			break;
 		} else if (status != 0x00) {
 			printk("dt2815: unexpected status 0x%x (@t=%d)\n",
-				status, i);
+			       status, i);
 			if (status & 0x60) {
 				outb(0x00, dev->iobase + DT2815_STATUS);
 			}
--- a/drivers/staging/comedi/drivers/dt2817.c
+++ b/drivers/staging/comedi/drivers/dt2817.c
@@ -47,7 +47,8 @@ Configuration options:
 #define DT2817_CR 0
 #define DT2817_DATA 1
 
-static int dt2817_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt2817_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dt2817_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt2817 = {
 	.driver_name = "dt2817",
@@ -58,8 +59,9 @@ static struct comedi_driver driver_dt281
 
 COMEDI_INITCLEANUP(driver_dt2817);
 
-static int dt2817_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2817_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int mask;
 	int chan;
@@ -96,8 +98,9 @@ static int dt2817_dio_insn_config(struct
 	return 1;
 }
 
-static int dt2817_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt2817_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int changed;
 
@@ -115,13 +118,13 @@ static int dt2817_dio_insn_bits(struct c
 			outb(s->state & 0xff, dev->iobase + DT2817_DATA + 0);
 		if (changed & 0x0000ff00)
 			outb((s->state >> 8) & 0xff,
-				dev->iobase + DT2817_DATA + 1);
+			     dev->iobase + DT2817_DATA + 1);
 		if (changed & 0x00ff0000)
 			outb((s->state >> 16) & 0xff,
-				dev->iobase + DT2817_DATA + 2);
+			     dev->iobase + DT2817_DATA + 2);
 		if (changed & 0xff000000)
 			outb((s->state >> 24) & 0xff,
-				dev->iobase + DT2817_DATA + 3);
+			     dev->iobase + DT2817_DATA + 3);
 	}
 	data[1] = inb(dev->iobase + DT2817_DATA + 0);
 	data[1] |= (inb(dev->iobase + DT2817_DATA + 1) << 8);
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -155,46 +155,78 @@ Notes:
 #define DT2821_BDINIT	0x0001	/* (W)   initialize board         */
 
 static const struct comedi_lrange range_dt282x_ai_lo_bipolar = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25)
-	}
+								     RANGE(-10,
+									   10),
+								     RANGE(-5,
+									   5),
+								     RANGE(-2.5,
+									   2.5),
+								     RANGE
+								     (-1.25,
+								      1.25)
+								     }
 };
+
 static const struct comedi_lrange range_dt282x_ai_lo_unipolar = { 4, {
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25)
-	}
+								      RANGE(0,
+									    10),
+								      RANGE(0,
+									    5),
+								      RANGE(0,
+									    2.5),
+								      RANGE(0,
+									    1.25)
+								      }
 };
+
 static const struct comedi_lrange range_dt282x_ai_5_bipolar = { 4, {
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(-0.625, 0.625),
-	}
+								    RANGE(-5,
+									  5),
+								    RANGE(-2.5,
+									  2.5),
+								    RANGE(-1.25,
+									  1.25),
+								    RANGE
+								    (-0.625,
+								     0.625),
+								    }
 };
+
 static const struct comedi_lrange range_dt282x_ai_5_unipolar = { 4, {
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25),
-			RANGE(0, 0.625),
-	}
+								     RANGE(0,
+									   5),
+								     RANGE(0,
+									   2.5),
+								     RANGE(0,
+									   1.25),
+								     RANGE(0,
+									   0.625),
+								     }
 };
+
 static const struct comedi_lrange range_dt282x_ai_hi_bipolar = { 4, {
-			RANGE(-10, 10),
-			RANGE(-1, 1),
-			RANGE(-0.1, 0.1),
-			RANGE(-0.02, 0.02)
-	}
+								     RANGE(-10,
+									   10),
+								     RANGE(-1,
+									   1),
+								     RANGE(-0.1,
+									   0.1),
+								     RANGE
+								     (-0.02,
+								      0.02)
+								     }
 };
+
 static const struct comedi_lrange range_dt282x_ai_hi_unipolar = { 4, {
-			RANGE(0, 10),
-			RANGE(0, 1),
-			RANGE(0, 0.1),
-			RANGE(0, 0.02)
-	}
+								      RANGE(0,
+									    10),
+								      RANGE(0,
+									    1),
+								      RANGE(0,
+									    0.1),
+								      RANGE(0,
+									    0.02)
+								      }
 };
 
 struct dt282x_board {
@@ -217,7 +249,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2821-f",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -226,7 +258,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2821-g",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -235,7 +267,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2823",
 	 .adbits = 16,
 	 .adchan_se = 0,
@@ -244,16 +276,16 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 16,
-	},
+	 },
 	{.name = "dt2824-pgh",
-	  .adbits = 12,
-	  .adchan_se = 16,
-	  .adchan_di = 8,
-	  .ai_speed = 20000,
-	  .ispgl = 0,
-	  .dachan = 0,
-	  .dabits = 0,
-	},
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 20000,
+	 .ispgl = 0,
+	 .dachan = 0,
+	 .dabits = 0,
+	 },
 	{.name = "dt2824-pgl",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -262,7 +294,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 1,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 	{.name = "dt2825",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -271,7 +303,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 1,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2827",
 	 .adbits = 16,
 	 .adchan_se = 0,
@@ -280,7 +312,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2828",
 	 .adbits = 12,
 	 .adchan_se = 4,
@@ -289,7 +321,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2829",
 	 .adbits = 16,
 	 .adchan_se = 8,
@@ -298,7 +330,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 16,
-	},
+	 },
 	{.name = "dt21-ez",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -307,7 +339,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt23-ez",
 	 .adbits = 16,
 	 .adchan_se = 16,
@@ -316,7 +348,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 	{.name = "dt24-ez",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -325,7 +357,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 0,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 	{.name = "dt24-ez-pgl",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -334,7 +366,7 @@ static const struct dt282x_board boardty
 	 .ispgl = 1,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 };
 
 #define n_boardtypes sizeof(boardtypes)/sizeof(struct dt282x_board)
@@ -394,7 +426,8 @@ struct dt282x_private {
 		if (_i){b}				\
 	}while (0)
 
-static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt282x_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dt282x_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt282x = {
 	.driver_name = "dt282x",
@@ -411,15 +444,17 @@ COMEDI_INITCLEANUP(driver_dt282x);
 static void free_resources(struct comedi_device *dev);
 static int prep_ai_dma(struct comedi_device *dev, int chan, int size);
 static int prep_ao_dma(struct comedi_device *dev, int chan, int size);
-static int dt282x_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int dt282x_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int dt282x_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int dt282x_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
 static int dt282x_ns_to_timer(int *nanosec, int round_mode);
 static void dt282x_disable_dma(struct comedi_device *dev);
 
 static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2);
 
 static void dt282x_munge(struct comedi_device *dev, short *buf,
-	unsigned int nbytes)
+			 unsigned int nbytes)
 {
 	unsigned int i;
 	unsigned short mask = (1 << boardtype.adbits) - 1;
@@ -628,7 +663,7 @@ static irqreturn_t dt282x_interrupt(int 
 		int ret;
 		short data;
 
-		data = (short) inw(dev->iobase + DT2821_ADDAT);
+		data = (short)inw(dev->iobase + DT2821_ADDAT);
 		data &= (1 << boardtype.adbits) - 1;
 		if (devpriv->ad_2scomp) {
 			data ^= 1 << (boardtype.adbits - 1);
@@ -654,7 +689,7 @@ static irqreturn_t dt282x_interrupt(int 
 }
 
 static void dt282x_load_changain(struct comedi_device *dev, int n,
-	unsigned int *chanlist)
+				 unsigned int *chanlist)
 {
 	unsigned int i;
 	unsigned int chan, range;
@@ -674,8 +709,9 @@ static void dt282x_load_changain(struct 
  *      - preload multiplexer
  *      - trigger conversion and wait for it to finish
  */
-static int dt282x_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -686,18 +722,15 @@ static int dt282x_ai_insn_read(struct co
 	dt282x_load_changain(dev, 1, &insn->chanspec);
 
 	update_supcsr(DT2821_PRLD);
-	wait_for(!mux_busy(), comedi_error(dev, "timeout\n");
-		return -ETIME;
-		);
+	wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
 
 	for (i = 0; i < insn->n; i++) {
 		update_supcsr(DT2821_STRIG);
 		wait_for(ad_done(), comedi_error(dev, "timeout\n");
-			return -ETIME;
-			);
+			 return -ETIME;);
 
 		data[i] =
-			inw(dev->iobase +
+		    inw(dev->iobase +
 			DT2821_ADDAT) & ((1 << boardtype.adbits) - 1);
 		if (devpriv->ad_2scomp)
 			data[i] ^= (1 << (boardtype.adbits - 1));
@@ -706,8 +739,8 @@ static int dt282x_ai_insn_read(struct co
 	return i;
 }
 
-static int dt282x_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int dt282x_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -746,7 +779,7 @@ static int dt282x_ai_cmdtest(struct come
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -825,7 +858,7 @@ static int dt282x_ai_cmd(struct comedi_d
 
 	if (devpriv->usedma == 0) {
 		comedi_error(dev,
-			"driver requires 2 dma channels to execute command");
+			     "driver requires 2 dma channels to execute command");
 		return -EIO;
 	}
 
@@ -865,9 +898,7 @@ static int dt282x_ai_cmd(struct comedi_d
 	update_adcsr(0);
 
 	update_supcsr(DT2821_PRLD);
-	wait_for(!mux_busy(), comedi_error(dev, "timeout\n");
-		return -ETIME;
-		);
+	wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
 		update_supcsr(DT2821_STRIG);
@@ -887,7 +918,8 @@ static void dt282x_disable_dma(struct co
 	}
 }
 
-static int dt282x_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dt282x_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	dt282x_disable_dma(dev);
 
@@ -937,16 +969,18 @@ static int dt282x_ns_to_timer(int *nanos
  *      offset binary if necessary, loads the data into the DAC
  *      data register, and performs the conversion.
  */
-static int dt282x_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int dt282x_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	short d;
 	unsigned int chan;
@@ -978,8 +1012,8 @@ static int dt282x_ao_insn_write(struct c
 	return 1;
 }
 
-static int dt282x_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int dt282x_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1029,7 +1063,7 @@ static int dt282x_ao_cmdtest(struct come
 		cmd->start_arg = 0;
 		err++;
 	}
-	if (cmd->scan_begin_arg < 5000 /* XXX unknown */) {
+	if (cmd->scan_begin_arg < 5000 /* XXX unknown */ ) {
 		cmd->scan_begin_arg = 5000;
 		err++;
 	}
@@ -1069,8 +1103,8 @@ static int dt282x_ao_cmdtest(struct come
 
 }
 
-static int dt282x_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int x)
+static int dt282x_ao_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int x)
 {
 	int size;
 
@@ -1078,7 +1112,7 @@ static int dt282x_ao_inttrig(struct come
 		return -EINVAL;
 
 	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,
-		devpriv->dma_maxsize);
+					  devpriv->dma_maxsize);
 	if (size == 0) {
 		printk("dt282x: AO underrun\n");
 		return -EPIPE;
@@ -1086,7 +1120,7 @@ static int dt282x_ao_inttrig(struct come
 	prep_ao_dma(dev, 0, size);
 
 	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
-		devpriv->dma_maxsize);
+					  devpriv->dma_maxsize);
 	if (size == 0) {
 		printk("dt282x: AO underrun\n");
 		return -EPIPE;
@@ -1106,7 +1140,7 @@ static int dt282x_ao_cmd(struct comedi_d
 
 	if (devpriv->usedma == 0) {
 		comedi_error(dev,
-			"driver requires 2 dma channels to execute command");
+			     "driver requires 2 dma channels to execute command");
 		return -EIO;
 	}
 
@@ -1132,7 +1166,8 @@ static int dt282x_ao_cmd(struct comedi_d
 	return 0;
 }
 
-static int dt282x_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dt282x_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	dt282x_disable_dma(dev);
 
@@ -1145,8 +1180,9 @@ static int dt282x_ao_cancel(struct comed
 	return 0;
 }
 
-static int dt282x_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -1159,8 +1195,9 @@ static int dt282x_dio_insn_bits(struct c
 	return 2;
 }
 
-static int dt282x_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int mask;
 
@@ -1190,10 +1227,12 @@ static const struct comedi_lrange *const
 	&range_dt282x_ai_5_bipolar,
 	&range_dt282x_ai_5_unipolar
 };
+
 static const struct comedi_lrange *const ai_range_pgl_table[] = {
 	&range_dt282x_ai_hi_bipolar,
 	&range_dt282x_ai_hi_unipolar
 };
+
 static const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 {
 	if (ispgl) {
@@ -1206,6 +1245,7 @@ static const struct comedi_lrange *opt_a
 		return ai_range_table[x];
 	}
 }
+
 static const struct comedi_lrange *const ao_range_table[] = {
 	&range_bipolar10,
 	&range_unipolar10,
@@ -1213,6 +1253,7 @@ static const struct comedi_lrange *const
 	&range_unipolar5,
 	&range_bipolar2_5
 };
+
 static const struct comedi_lrange *opt_ao_range_lkup(int x)
 {
 	if (x < 0 || x >= 5)
@@ -1264,23 +1305,23 @@ static int dt282x_attach(struct comedi_d
 	i = inw(dev->iobase + DT2821_ADCSR);
 #ifdef DEBUG
 	printk(" fingerprint=%x,%x,%x,%x,%x",
-		inw(dev->iobase + DT2821_ADCSR),
-		inw(dev->iobase + DT2821_CHANCSR),
-		inw(dev->iobase + DT2821_DACSR),
-		inw(dev->iobase + DT2821_SUPCSR),
-		inw(dev->iobase + DT2821_TMRCTR));
+	       inw(dev->iobase + DT2821_ADCSR),
+	       inw(dev->iobase + DT2821_CHANCSR),
+	       inw(dev->iobase + DT2821_DACSR),
+	       inw(dev->iobase + DT2821_SUPCSR),
+	       inw(dev->iobase + DT2821_TMRCTR));
 #endif
 
 	if (((inw(dev->iobase + DT2821_ADCSR) & DT2821_ADCSR_MASK)
-			!= DT2821_ADCSR_VAL) ||
-		((inw(dev->iobase + DT2821_CHANCSR) & DT2821_CHANCSR_MASK)
-			!= DT2821_CHANCSR_VAL) ||
-		((inw(dev->iobase + DT2821_DACSR) & DT2821_DACSR_MASK)
-			!= DT2821_DACSR_VAL) ||
-		((inw(dev->iobase + DT2821_SUPCSR) & DT2821_SUPCSR_MASK)
-			!= DT2821_SUPCSR_VAL) ||
-		((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)
-			!= DT2821_TMRCTR_VAL)) {
+	     != DT2821_ADCSR_VAL) ||
+	    ((inw(dev->iobase + DT2821_CHANCSR) & DT2821_CHANCSR_MASK)
+	     != DT2821_CHANCSR_VAL) ||
+	    ((inw(dev->iobase + DT2821_DACSR) & DT2821_DACSR_MASK)
+	     != DT2821_DACSR_VAL) ||
+	    ((inw(dev->iobase + DT2821_SUPCSR) & DT2821_SUPCSR_MASK)
+	     != DT2821_SUPCSR_VAL) ||
+	    ((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)
+	     != DT2821_TMRCTR_VAL)) {
 		printk(" board not found");
 		return -EIO;
 	}
@@ -1302,7 +1343,7 @@ static int dt282x_attach(struct comedi_d
 
 		irq = probe_irq_off(irqs);
 		restore_flags(flags);
-		if (0 /* error */) {
+		if (0 /* error */ ) {
 			printk(" error probing irq (bad)");
 		}
 	}
@@ -1330,7 +1371,7 @@ static int dt282x_attach(struct comedi_d
 		return ret;
 
 	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
-		it->options[opt_dma2]);
+			      it->options[opt_dma2]);
 	if (ret < 0)
 		return ret;
 
@@ -1344,10 +1385,9 @@ static int dt282x_attach(struct comedi_d
 	/* ai subdevice */
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_CMD_READ |
-		((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);
+	    ((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);
 	s->n_chan =
-		(it->options[opt_diff]) ? boardtype.adchan_di : boardtype.
-		adchan_se;
+	    (it->options[opt_diff]) ? boardtype.adchan_di : boardtype.adchan_se;
 	s->insn_read = dt282x_ai_insn_read;
 	s->do_cmdtest = dt282x_ai_cmdtest;
 	s->do_cmd = dt282x_ai_cmd;
@@ -1355,7 +1395,7 @@ static int dt282x_attach(struct comedi_d
 	s->maxdata = (1 << boardtype.adbits) - 1;
 	s->len_chanlist = 16;
 	s->range_table =
-		opt_ai_range_lkup(boardtype.ispgl, it->options[opt_ai_range]);
+	    opt_ai_range_lkup(boardtype.ispgl, it->options[opt_ai_range]);
 	devpriv->ad_2scomp = it->options[opt_ai_twos];
 
 	s++;
@@ -1375,9 +1415,9 @@ static int dt282x_attach(struct comedi_d
 		s->len_chanlist = 2;
 		s->range_table_list = devpriv->darangelist;
 		devpriv->darangelist[0] =
-			opt_ao_range_lkup(it->options[opt_ao0_range]);
+		    opt_ao_range_lkup(it->options[opt_ao0_range]);
 		devpriv->darangelist[1] =
-			opt_ao_range_lkup(it->options[opt_ao1_range]);
+		    opt_ao_range_lkup(it->options[opt_ao1_range]);
 		devpriv->da0_2scomp = it->options[opt_ao0_twos];
 		devpriv->da1_2scomp = it->options[opt_ao1_twos];
 	} else {
--- a/drivers/staging/comedi/drivers/dt3000.c
+++ b/drivers/staging/comedi/drivers/dt3000.c
@@ -68,18 +68,19 @@ AO commands are not supported.
 #define PCI_VENDOR_ID_DT	0x1116
 
 static const struct comedi_lrange range_dt3000_ai = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25)
-	}
+							  RANGE(-10, 10),
+							  RANGE(-5, 5),
+							  RANGE(-2.5, 2.5),
+							  RANGE(-1.25, 1.25)
+							  }
 };
+
 static const struct comedi_lrange range_dt3000_ai_pgl = { 4, {
-			RANGE(-10, 10),
-			RANGE(-1, 1),
-			RANGE(-0.1, 0.1),
-			RANGE(-0.02, 0.02)
-	}
+							      RANGE(-10, 10),
+							      RANGE(-1, 1),
+							      RANGE(-0.1, 0.1),
+							      RANGE(-0.02, 0.02)
+							      }
 };
 
 struct dt3k_boardtype {
@@ -94,7 +95,6 @@ struct dt3k_boardtype {
 	int dabits;
 };
 
-
 static const struct dt3k_boardtype dt3k_boardtypes[] = {
 	{.name = "dt3001",
 	 .device_id = 0x22,
@@ -104,7 +104,7 @@ static const struct dt3k_boardtype dt3k_
 	 .ai_speed = 3000,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt3001-pgl",
 	 .device_id = 0x27,
 	 .adchan = 16,
@@ -113,7 +113,7 @@ static const struct dt3k_boardtype dt3k_
 	 .ai_speed = 3000,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt3002",
 	 .device_id = 0x23,
 	 .adchan = 32,
@@ -122,7 +122,7 @@ static const struct dt3k_boardtype dt3k_
 	 .ai_speed = 3000,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 	{.name = "dt3003",
 	 .device_id = 0x24,
 	 .adchan = 64,
@@ -131,7 +131,7 @@ static const struct dt3k_boardtype dt3k_
 	 .ai_speed = 3000,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt3003-pgl",
 	 .device_id = 0x28,
 	 .adchan = 64,
@@ -140,7 +140,7 @@ static const struct dt3k_boardtype dt3k_
 	 .ai_speed = 3000,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt3004",
 	 .device_id = 0x25,
 	 .adchan = 16,
@@ -149,8 +149,8 @@ static const struct dt3k_boardtype dt3k_
 	 .ai_speed = 10000,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
-        {.name = "dt3005",		/* a.k.a. 3004-200 */
+	 },
+	{.name = "dt3005",	/* a.k.a. 3004-200 */
 	 .device_id = 0x26,
 	 .adchan = 16,
 	 .adbits = 16,
@@ -158,21 +158,22 @@ static const struct dt3k_boardtype dt3k_
 	 .ai_speed = 5000,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 };
 
 #define n_dt3k_boards sizeof(dt3k_boardtypes)/sizeof(struct dt3k_boardtype)
 #define this_board ((const struct dt3k_boardtype *)dev->board_ptr)
 
 static DEFINE_PCI_DEVICE_TABLE(dt3k_pci_table) = {
-	{PCI_VENDOR_ID_DT, 0x0022, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_DT, 0x0027, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_DT, 0x0023, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_DT, 0x0024, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_DT, 0x0028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_DT, 0x0025, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_DT, 0x0026, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_DT, 0x0022, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_DT, 0x0027, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_DT, 0x0023, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_DT, 0x0024, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_DT, 0x0028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_DT, 0x0025, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_DT, 0x0026, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, dt3k_pci_table);
@@ -276,7 +277,8 @@ struct dt3k_private {
 
 #define devpriv ((struct dt3k_private *)dev->private)
 
-static int dt3000_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt3000_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dt3000_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt3000 = {
 	.driver_name = "dt3000",
@@ -287,10 +289,12 @@ static struct comedi_driver driver_dt300
 
 COMEDI_PCI_INITCLEANUP(driver_dt3000, dt3k_pci_table);
 
-static void dt3k_ai_empty_fifo(struct comedi_device *dev, struct comedi_subdevice *s);
+static void dt3k_ai_empty_fifo(struct comedi_device *dev,
+			       struct comedi_subdevice *s);
 static int dt3k_ns_to_timer(unsigned int timer_base, unsigned int *arg,
-	unsigned int round_mode);
-static int dt3k_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+			    unsigned int round_mode);
+static int dt3k_ai_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 #ifdef DEBUG
 static void debug_intr_flags(unsigned int flags);
 #endif
@@ -319,8 +323,9 @@ static int dt3k_send_cmd(struct comedi_d
 	return -ETIME;
 }
 
-static unsigned int dt3k_readsingle(struct comedi_device *dev, unsigned int subsys,
-	unsigned int chan, unsigned int gain)
+static unsigned int dt3k_readsingle(struct comedi_device *dev,
+				    unsigned int subsys, unsigned int chan,
+				    unsigned int gain)
 {
 	writew(subsys, devpriv->io_addr + DPR_SubSys);
 
@@ -333,7 +338,7 @@ static unsigned int dt3k_readsingle(stru
 }
 
 static void dt3k_writesingle(struct comedi_device *dev, unsigned int subsys,
-	unsigned int chan, unsigned int data)
+			     unsigned int chan, unsigned int data)
 {
 	writew(subsys, devpriv->io_addr + DPR_SubSys);
 
@@ -388,6 +393,7 @@ static char *intr_flags[] = {
 	"AdFull", "AdSwError", "AdHwError", "DaEmpty",
 	"DaSwError", "DaHwError", "CtDone", "CmDone",
 };
+
 static void debug_intr_flags(unsigned int flags)
 {
 	int i;
@@ -401,7 +407,8 @@ static void debug_intr_flags(unsigned in
 }
 #endif
 
-static void dt3k_ai_empty_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static void dt3k_ai_empty_fifo(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
 {
 	int front;
 	int rear;
@@ -430,8 +437,8 @@ static void dt3k_ai_empty_fifo(struct co
 	writew(rear, devpriv->io_addr + DPR_AD_Buf_Rear);
 }
 
-static int dt3k_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int dt3k_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -528,7 +535,7 @@ static int dt3k_ai_cmdtest(struct comedi
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		dt3k_ns_to_timer(100, &cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	} else {
@@ -537,14 +544,14 @@ static int dt3k_ai_cmdtest(struct comedi
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		dt3k_ns_to_timer(50, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->scan_end_arg) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	} else {
@@ -558,7 +565,7 @@ static int dt3k_ai_cmdtest(struct comedi
 }
 
 static int dt3k_ns_to_timer(unsigned int timer_base, unsigned int *nanosec,
-	unsigned int round_mode)
+			    unsigned int round_mode)
 {
 	int divider, base, prescale;
 
@@ -608,7 +615,7 @@ static int dt3k_ai_cmd(struct comedi_dev
 		range = CR_RANGE(cmd->chanlist[i]);
 
 		writew((range << 6) | chan,
-			devpriv->io_addr + DPR_ADC_buffer + i);
+		       devpriv->io_addr + DPR_ADC_buffer + i);
 	}
 	aref = CR_AREF(cmd->chanlist[0]);
 
@@ -617,7 +624,7 @@ static int dt3k_ai_cmd(struct comedi_dev
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		divider = dt3k_ns_to_timer(50, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					   cmd->flags & TRIG_ROUND_MASK);
 		writew((divider >> 16), devpriv->io_addr + DPR_Params(1));
 		printk("param[1]=0x%04x\n", divider >> 16);
 		writew((divider & 0xffff), devpriv->io_addr + DPR_Params(2));
@@ -628,7 +635,7 @@ static int dt3k_ai_cmd(struct comedi_dev
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tscandiv = dt3k_ns_to_timer(100, &cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					    cmd->flags & TRIG_ROUND_MASK);
 		writew((tscandiv >> 16), devpriv->io_addr + DPR_Params(3));
 		printk("param[3]=0x%04x\n", tscandiv >> 16);
 		writew((tscandiv & 0xffff), devpriv->io_addr + DPR_Params(4));
@@ -650,7 +657,7 @@ static int dt3k_ai_cmd(struct comedi_dev
 	ret = dt3k_send_cmd(dev, CMD_CONFIG);
 
 	writew(DT3000_ADFULL | DT3000_ADSWERR | DT3000_ADHWERR,
-		devpriv->io_addr + DPR_Int_Mask);
+	       devpriv->io_addr + DPR_Int_Mask);
 
 	debug_n_ints = 0;
 
@@ -673,7 +680,7 @@ static int dt3k_ai_cancel(struct comedi_
 }
 
 static int dt3k_ai_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	unsigned int chan, gain, aref;
@@ -691,7 +698,7 @@ static int dt3k_ai_insn(struct comedi_de
 }
 
 static int dt3k_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	unsigned int chan;
@@ -705,8 +712,9 @@ static int dt3k_ao_insn(struct comedi_de
 	return i;
 }
 
-static int dt3k_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt3k_ao_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	unsigned int chan;
@@ -734,8 +742,9 @@ static void dt3k_dio_config(struct comed
 	dt3k_send_cmd(dev, CMD_CONFIG);
 }
 
-static int dt3k_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt3k_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int mask;
 
@@ -750,9 +759,9 @@ static int dt3k_dio_insn_config(struct c
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -765,8 +774,9 @@ static int dt3k_dio_insn_config(struct c
 	return insn->n;
 }
 
-static int dt3k_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt3k_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -781,8 +791,9 @@ static int dt3k_dio_insn_bits(struct com
 	return 2;
 }
 
-static int dt3k_mem_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt3k_mem_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int addr = CR_CHAN(insn->chanspec);
 	int i;
@@ -925,8 +936,8 @@ static int dt_pci_probe(struct comedi_de
 	pcidev = NULL;
 	while ((pcidev = dt_pci_find_device(pcidev, &board)) != NULL) {
 		if ((bus == 0 && slot == 0) ||
-			(pcidev->bus->number == bus &&
-			 PCI_SLOT(pcidev->devfn) == slot)) {
+		    (pcidev->bus->number == bus &&
+		     PCI_SLOT(pcidev->devfn) == slot)) {
 			break;
 		}
 	}
@@ -961,7 +972,7 @@ static int setup_pci(struct comedi_devic
 		return -ENOMEM;
 #if DEBUG
 	printk("0x%08llx mapped to %p, ",
-		(unsigned long long)devpriv->phys_addr, devpriv->io_addr);
+	       (unsigned long long)devpriv->phys_addr, devpriv->io_addr);
 #endif
 
 	return 0;
@@ -972,15 +983,17 @@ static struct pci_dev *dt_pci_find_devic
 	int i;
 
 	for (from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from);
-		from != NULL;
-		from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from)) {
+	     from != NULL;
+	     from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from)) {
 		for (i = 0; i < n_dt3k_boards; i++) {
 			if (from->device == dt3k_boardtypes[i].device_id) {
 				*board = i;
 				return from;
 			}
 		}
-		printk("unknown Data Translation PCI device found with device_id=0x%04x\n", from->device);
+		printk
+		    ("unknown Data Translation PCI device found with device_id=0x%04x\n",
+		     from->device);
 	}
 	*board = -1;
 	return from;
--- a/drivers/staging/comedi/drivers/dt9812.c
+++ b/drivers/staging/comedi/drivers/dt9812.c
@@ -89,9 +89,9 @@ for my needs.
 #define F020_MASK_DACxCN_DACxEN		0x80
 
 enum {
-				/* A/D  D/A  DI  DO  CT */
+	/* A/D  D/A  DI  DO  CT */
 	DT9812_DEVID_DT9812_10,	/*  8    2   8   8   1  +/- 10V */
-	DT9812_DEVID_DT9812_2PT5,/* 8    2   8   8   1  0-2.44V */
+	DT9812_DEVID_DT9812_2PT5,	/* 8    2   8   8   1  0-2.44V */
 #if 0
 	DT9812_DEVID_DT9813,	/*  16   2   4   4   1  +/- 10V */
 	DT9812_DEVID_DT9814	/*  24   2   0   0   1  +/- 10V */
@@ -266,7 +266,7 @@ static DECLARE_MUTEX(dt9812_mutex);
 
 static struct usb_device_id dt9812_table[] = {
 	{USB_DEVICE(0x0867, 0x9812)},
-	{ }			/* Terminating entry */
+	{}			/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(usb, dt9812_table);
@@ -301,23 +301,23 @@ struct slot_dt9812 {
 };
 
 static const struct comedi_lrange dt9812_10_ain_range = { 1, {
-			BIP_RANGE(10),
-	}
+							      BIP_RANGE(10),
+							      }
 };
 
 static const struct comedi_lrange dt9812_2pt5_ain_range = { 1, {
-			UNI_RANGE(2.5),
-	}
+								UNI_RANGE(2.5),
+								}
 };
 
 static const struct comedi_lrange dt9812_10_aout_range = { 1, {
-			BIP_RANGE(10),
-	}
+							       BIP_RANGE(10),
+							       }
 };
 
 static const struct comedi_lrange dt9812_2pt5_aout_range = { 1, {
-			UNI_RANGE(2.5),
-	}
+								 UNI_RANGE(2.5),
+								 }
 };
 
 static struct slot_dt9812 dt9812[DT9812_NUM_SLOTS];
@@ -346,7 +346,7 @@ static int dt9812_read_info(struct usb_d
 
 	cmd.cmd = cpu_to_le32(DT9812_R_FLASH_DATA);
 	cmd.u.flash_data_info.address =
-		cpu_to_le16(DT9812_DIAGS_BOARD_INFO_ADDR + offset);
+	    cpu_to_le16(DT9812_DIAGS_BOARD_INFO_ADDR + offset);
 	cmd.u.flash_data_info.numbytes = cpu_to_le16(buf_size);
 
 	/* DT9812 only responds to 32 byte writes!! */
@@ -365,7 +365,7 @@ static int dt9812_read_info(struct usb_d
 }
 
 static int dt9812_read_multiple_registers(struct usb_dt9812 *dev, int reg_count,
-					  u8 *address, u8 *value)
+					  u8 * address, u8 * value)
 {
 	struct dt9812_usb_cmd cmd;
 	int i, count, retval;
@@ -391,8 +391,8 @@ static int dt9812_read_multiple_register
 }
 
 static int dt9812_write_multiple_registers(struct usb_dt9812 *dev,
-					   int reg_count, u8 *address,
-					   u8 *value)
+					   int reg_count, u8 * address,
+					   u8 * value)
 {
 	struct dt9812_usb_cmd cmd;
 	int i, count, retval;
@@ -430,7 +430,7 @@ static int dt9812_rmw_multiple_registers
 	return retval;
 }
 
-static int dt9812_digital_in(struct slot_dt9812 *slot, u8 *bits)
+static int dt9812_digital_in(struct slot_dt9812 *slot, u8 * bits)
 {
 	int result = -ENODEV;
 
@@ -449,7 +449,7 @@ static int dt9812_digital_in(struct slot
 			 */
 			*bits = (value[0] & 0x7f) | ((value[1] & 0x08) << 4);
 			/* printk("%2.2x, %2.2x -> %2.2x\n",
-				  value[0], value[1], *bits); */
+			   value[0], value[1], *bits); */
 		}
 	}
 	up(&slot->mutex);
@@ -476,7 +476,7 @@ static int dt9812_digital_out(struct slo
 	return result;
 }
 
-static int dt9812_digital_out_shadow(struct slot_dt9812 *slot, u8 *bits)
+static int dt9812_digital_out_shadow(struct slot_dt9812 *slot, u8 * bits)
 {
 	int result = -ENODEV;
 
@@ -516,8 +516,7 @@ static void dt9812_configure_gain(struct
 
 	rmw->address = F020_SFR_ADC0CF;
 	rmw->and_mask = F020_MASK_ADC0CF_AMP0GN2 |
-			F020_MASK_ADC0CF_AMP0GN1 |
-			F020_MASK_ADC0CF_AMP0GN0;
+	    F020_MASK_ADC0CF_AMP0GN1 | F020_MASK_ADC0CF_AMP0GN0;
 	switch (gain) {
 		/*
 		 * 000 -> Gain =  1
@@ -529,7 +528,7 @@ static void dt9812_configure_gain(struct
 		 */
 	case DT9812_GAIN_0PT5:
 		rmw->or_value = F020_MASK_ADC0CF_AMP0GN2 ||
-				F020_MASK_ADC0CF_AMP0GN1;
+		    F020_MASK_ADC0CF_AMP0GN1;
 		break;
 	case DT9812_GAIN_1:
 		rmw->or_value = 0x00;
@@ -542,7 +541,7 @@ static void dt9812_configure_gain(struct
 		break;
 	case DT9812_GAIN_8:
 		rmw->or_value = F020_MASK_ADC0CF_AMP0GN1 ||
-				F020_MASK_ADC0CF_AMP0GN0;
+		    F020_MASK_ADC0CF_AMP0GN0;
 		break;
 	case DT9812_GAIN_16:
 		rmw->or_value = F020_MASK_ADC0CF_AMP0GN2;
@@ -553,7 +552,7 @@ static void dt9812_configure_gain(struct
 	}
 }
 
-static int dt9812_analog_in(struct slot_dt9812 *slot, int channel, u16 *value,
+static int dt9812_analog_in(struct slot_dt9812 *slot, int channel, u16 * value,
 			    enum dt9812_gain gain)
 {
 	struct dt9812_rmw_byte rmw[3];
@@ -620,7 +619,7 @@ exit:
 }
 
 static int dt9812_analog_out_shadow(struct slot_dt9812 *slot, int channel,
-				    u16 *value)
+				    u16 * value)
 {
 	int result = -ENODEV;
 
@@ -729,32 +728,32 @@ static int dt9812_probe(struct usb_inter
 			direction = USB_DIR_IN;
 			dev->message_pipe.addr = endpoint->bEndpointAddress;
 			dev->message_pipe.size =
-					le16_to_cpu(endpoint->wMaxPacketSize);
+			    le16_to_cpu(endpoint->wMaxPacketSize);
 
 			break;
 		case 1:
 			direction = USB_DIR_OUT;
 			dev->command_write.addr = endpoint->bEndpointAddress;
 			dev->command_write.size =
-					le16_to_cpu(endpoint->wMaxPacketSize);
+			    le16_to_cpu(endpoint->wMaxPacketSize);
 			break;
 		case 2:
 			direction = USB_DIR_IN;
 			dev->command_read.addr = endpoint->bEndpointAddress;
 			dev->command_read.size =
-					le16_to_cpu(endpoint->wMaxPacketSize);
+			    le16_to_cpu(endpoint->wMaxPacketSize);
 			break;
 		case 3:
 			direction = USB_DIR_OUT;
 			dev->write_stream.addr = endpoint->bEndpointAddress;
 			dev->write_stream.size =
-					le16_to_cpu(endpoint->wMaxPacketSize);
+			    le16_to_cpu(endpoint->wMaxPacketSize);
 			break;
 		case 4:
 			direction = USB_DIR_IN;
 			dev->read_stream.addr = endpoint->bEndpointAddress;
 			dev->read_stream.size =
-					le16_to_cpu(endpoint->wMaxPacketSize);
+			    le16_to_cpu(endpoint->wMaxPacketSize);
 			break;
 		}
 		if ((endpoint->bEndpointAddress & USB_DIR_IN) != direction) {
@@ -786,8 +785,7 @@ static int dt9812_probe(struct usb_inter
 		retval = -ENODEV;
 		goto error;
 	}
-	if (dt9812_read_info(dev, 3, &dev->product,
-			     sizeof(dev->product)) != 0) {
+	if (dt9812_read_info(dev, 3, &dev->product, sizeof(dev->product)) != 0) {
 		err("Failed to read product.");
 		retval = -ENODEV;
 		goto error;
@@ -940,8 +938,9 @@ static void dt9812_comedi_open(struct co
 	up(&devpriv->slot->mutex);
 }
 
-static int dt9812_di_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			   struct comedi_insn *insn, unsigned int *data)
+static int dt9812_di_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int n;
 	u8 bits = 0;
@@ -952,8 +951,9 @@ static int dt9812_di_rinsn(struct comedi
 	return n;
 }
 
-static int dt9812_do_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			   struct comedi_insn *insn, unsigned int *data)
+static int dt9812_do_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int n;
 	u8 bits = 0;
@@ -970,8 +970,9 @@ static int dt9812_do_winsn(struct comedi
 	return n;
 }
 
-static int dt9812_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			   struct comedi_insn *insn, unsigned int *data)
+static int dt9812_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int n;
 
@@ -985,8 +986,9 @@ static int dt9812_ai_rinsn(struct comedi
 	return n;
 }
 
-static int dt9812_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			   struct comedi_insn *insn, unsigned int *data)
+static int dt9812_ao_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int n;
 	u16 value;
@@ -999,8 +1001,9 @@ static int dt9812_ao_rinsn(struct comedi
 	return n;
 }
 
-static int dt9812_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			   struct comedi_insn *insn, unsigned int *data)
+static int dt9812_ao_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int n;
 
--- a/drivers/staging/comedi/drivers/fl512.c
+++ b/drivers/staging/comedi/drivers/fl512.c
@@ -32,14 +32,14 @@ struct fl512_private {
 #define devpriv ((struct fl512_private *) dev->private)
 
 static const struct comedi_lrange range_fl512 = { 4, {
-			BIP_RANGE(0.5),
-			BIP_RANGE(1),
-			BIP_RANGE(5),
-			BIP_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(5),
-			UNI_RANGE(10),
-	}
+						      BIP_RANGE(0.5),
+						      BIP_RANGE(1),
+						      BIP_RANGE(5),
+						      BIP_RANGE(10),
+						      UNI_RANGE(1),
+						      UNI_RANGE(5),
+						      UNI_RANGE(10),
+						      }
 };
 
 static int fl512_attach(struct comedi_device *dev, struct comedi_devconfig *it);
@@ -55,17 +55,20 @@ static struct comedi_driver driver_fl512
 COMEDI_INITCLEANUP(driver_fl512);
 
 static int fl512_ai_insn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
-static int fl512_ao_insn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_subdevice *s, struct comedi_insn *insn,
+			 unsigned int *data);
+static int fl512_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+			 struct comedi_insn *insn, unsigned int *data);
 static int fl512_ao_insn_readback(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
 
 /*
  * fl512_ai_insn : this is the analog input function
  */
 static int fl512_ai_insn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_subdevice *s, struct comedi_insn *insn,
+			 unsigned int *data)
 {
 	int n;
 	unsigned int lo_byte, hi_byte;
@@ -90,7 +93,8 @@ static int fl512_ai_insn(struct comedi_d
  * fl512_ao_insn : used to write to a DA port n times
  */
 static int fl512_ao_insn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_subdevice *s, struct comedi_insn *insn,
+			 unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);	/* get chan to write */
@@ -111,7 +115,8 @@ static int fl512_ao_insn(struct comedi_d
  * DA port
  */
 static int fl512_ao_insn_readback(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -130,7 +135,7 @@ static int fl512_attach(struct comedi_de
 {
 	unsigned long iobase;
 	struct comedi_subdevice *s;	/* pointer to the subdevice:
-				   Analog in, Analog out, ( not made ->and Digital IO) */
+					   Analog in, Analog out, ( not made ->and Digital IO) */
 
 	iobase = it->options[0];
 	printk("comedi:%d fl512: 0x%04lx", dev->minor, iobase);
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -58,7 +58,7 @@ static int hpdi_detach(struct comedi_dev
 void abort_dma(struct comedi_device *dev, unsigned int channel);
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			 struct comedi_cmd *cmd);
 static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t handle_interrupt(int irq, void *d);
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
@@ -149,7 +149,7 @@ enum board_control_bits {
 	TEST_MODE_ENABLE_BIT = 0x80000000,
 };
 uint32_t command_discrete_output_bits(unsigned int channel, int output,
-	int output_value)
+				      int output_value)
 {
 	uint32_t bits = 0;
 
@@ -193,11 +193,13 @@ uint32_t almost_empty_bits(unsigned int 
 {
 	return num_words & 0xffff;
 }
+
 unsigned int almost_full_num_words(uint32_t bits)
 {
 /* XXX need to add or subtract one? */
 	return (bits >> 16) & 0xffff;
 }
+
 unsigned int almost_empty_num_words(uint32_t bits)
 {
 	return bits & 0xffff;
@@ -268,33 +270,33 @@ struct hpdi_board {
 	int subdevice_id;	/*  pci subdevice id */
 };
 
-
 static const struct hpdi_board hpdi_boards[] = {
 	{
-	.name = "pci-hpdi32",
-	.device_id = PCI_DEVICE_ID_PLX_9080,
-	.subdevice_id = 0x2400,
-		},
+	 .name = "pci-hpdi32",
+	 .device_id = PCI_DEVICE_ID_PLX_9080,
+	 .subdevice_id = 0x2400,
+	 },
 #if 0
 	{
-	.name = "pxi-hpdi32",
-	.device_id = 0x9656,
-	.subdevice_id = 0x2705,
-		},
+	 .name = "pxi-hpdi32",
+	 .device_id = 0x9656,
+	 .subdevice_id = 0x2705,
+	 },
 #endif
 };
 
 static DEFINE_PCI_DEVICE_TABLE(hpdi_pci_table) = {
-	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX, 0x2400,
-		0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX,
+		    0x2400, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, hpdi_pci_table);
 
-static inline struct hpdi_board *board(const struct comedi_device * dev)
+static inline struct hpdi_board *board(const struct comedi_device *dev)
 {
-	return (struct hpdi_board *) dev->board_ptr;
+	return (struct hpdi_board *)dev->board_ptr;
 }
 
 struct hpdi_private {
@@ -321,8 +323,7 @@ struct hpdi_private {
 	unsigned dio_config_output:1;
 };
 
-
-static inline struct hpdi_private *priv(struct comedi_device * dev)
+static inline struct hpdi_private *priv(struct comedi_device *dev)
 {
 	return dev->private;
 }
@@ -336,8 +337,9 @@ static struct comedi_driver driver_hpdi 
 
 COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
 
-static int dio_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dio_config_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -350,8 +352,7 @@ static int dio_config_insn(struct comedi
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			priv(dev)->
-			dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    priv(dev)->dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	case INSN_CONFIG_BLOCK_SIZE:
@@ -377,29 +378,29 @@ static void init_plx9080(struct comedi_d
 
 	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
-		readl(plx_iobase + PLX_INTRCS_REG));
+		    readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
 	DEBUG_PRINT(" plx control reg 0x%x\n",
-		readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG));
+		    readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG));
 
 	DEBUG_PRINT(" plx revision 0x%x\n",
-		readl(plx_iobase + PLX_REVISION_REG));
+		    readl(plx_iobase + PLX_REVISION_REG));
 	DEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_MODE_REG));
+		    readl(plx_iobase + PLX_DMA0_MODE_REG));
 	DEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",
-		readl(plx_iobase + PLX_DMA1_MODE_REG));
+		    readl(plx_iobase + PLX_DMA1_MODE_REG));
 	DEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
+		    readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
 	DEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
+		    readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
 	DEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
+		    readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
 	DEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
+		    readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
 	DEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",
-		readb(plx_iobase + PLX_DMA0_CS_REG));
+		    readb(plx_iobase + PLX_DMA0_CS_REG));
 	DEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
+		    readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
 	DEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));
 #ifdef __BIG_ENDIAN
 	bits = BIGEND_DMA0 | BIGEND_DMA1;
@@ -448,7 +449,7 @@ static int setup_subdevices(struct comed
 /*	dev->write_subdev = s; */
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags =
-		SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL | SDF_CMD_READ;
+	    SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL | SDF_CMD_READ;
 	s->n_chan = 32;
 	s->len_chanlist = 32;
 	s->maxdata = 1;
@@ -469,21 +470,21 @@ static int init_hpdi(struct comedi_devic
 	udelay(10);
 
 	writel(almost_empty_bits(32) | almost_full_bits(32),
-		priv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);
+	       priv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);
 	writel(almost_empty_bits(32) | almost_full_bits(32),
-		priv(dev)->hpdi_iobase + TX_PROG_ALMOST_REG);
+	       priv(dev)->hpdi_iobase + TX_PROG_ALMOST_REG);
 
 	priv(dev)->tx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +
-			TX_FIFO_SIZE_REG));
+						  TX_FIFO_SIZE_REG));
 	priv(dev)->rx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +
-			RX_FIFO_SIZE_REG));
+						  RX_FIFO_SIZE_REG));
 
 	writel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
 	/*  enable interrupts */
 	plx_intcsr_bits =
-		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
-		ICS_DMA0_E;
+	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
+	    ICS_DMA0_E;
 	writel(plx_intcsr_bits, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 
 	return 0;
@@ -491,11 +492,11 @@ static int init_hpdi(struct comedi_devic
 
 /* setup dma descriptors so a link completes every 'transfer_size' bytes */
 static int setup_dma_descriptors(struct comedi_device *dev,
-	unsigned int transfer_size)
+				 unsigned int transfer_size)
 {
 	unsigned int buffer_index, buffer_offset;
 	uint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-		PLX_XFER_LOCAL_TO_PCI;
+	    PLX_XFER_LOCAL_TO_PCI;
 	unsigned int i;
 
 	if (transfer_size > DMA_BUFFER_SIZE)
@@ -506,26 +507,26 @@ static int setup_dma_descriptors(struct 
 
 	DEBUG_PRINT(" transfer_size %i\n", transfer_size);
 	DEBUG_PRINT(" descriptors at 0x%lx\n",
-		(unsigned long)priv(dev)->dma_desc_phys_addr);
+		    (unsigned long)priv(dev)->dma_desc_phys_addr);
 
 	buffer_offset = 0;
 	buffer_index = 0;
 	for (i = 0; i < NUM_DMA_DESCRIPTORS &&
-		buffer_index < NUM_DMA_BUFFERS; i++) {
+	     buffer_index < NUM_DMA_BUFFERS; i++) {
 		priv(dev)->dma_desc[i].pci_start_addr =
-			cpu_to_le32(priv(dev)->
-			dio_buffer_phys_addr[buffer_index] + buffer_offset);
+		    cpu_to_le32(priv(dev)->dio_buffer_phys_addr[buffer_index] +
+				buffer_offset);
 		priv(dev)->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);
 		priv(dev)->dma_desc[i].transfer_size =
-			cpu_to_le32(transfer_size);
+		    cpu_to_le32(transfer_size);
 		priv(dev)->dma_desc[i].next =
-			cpu_to_le32((priv(dev)->dma_desc_phys_addr + (i +
-					1) *
-				sizeof(priv(dev)->dma_desc[0])) | next_bits);
+		    cpu_to_le32((priv(dev)->dma_desc_phys_addr + (i +
+								  1) *
+				 sizeof(priv(dev)->dma_desc[0])) | next_bits);
 
 		priv(dev)->desc_dio_buffer[i] =
-			priv(dev)->dio_buffer[buffer_index] +
-			(buffer_offset / sizeof(uint32_t));
+		    priv(dev)->dio_buffer[buffer_index] +
+		    (buffer_offset / sizeof(uint32_t));
 
 		buffer_offset += transfer_size;
 		if (transfer_size + buffer_offset > DMA_BUFFER_SIZE) {
@@ -535,17 +536,18 @@ static int setup_dma_descriptors(struct 
 
 		DEBUG_PRINT(" desc %i\n", i);
 		DEBUG_PRINT(" start addr virt 0x%p, phys 0x%lx\n",
-			priv(dev)->desc_dio_buffer[i],
-			(unsigned long)priv(dev)->dma_desc[i].pci_start_addr);
+			    priv(dev)->desc_dio_buffer[i],
+			    (unsigned long)priv(dev)->dma_desc[i].
+			    pci_start_addr);
 		DEBUG_PRINT(" next 0x%lx\n",
-			(unsigned long)priv(dev)->dma_desc[i].next);
+			    (unsigned long)priv(dev)->dma_desc[i].next);
 	}
 	priv(dev)->num_dma_descriptors = i;
 	/*  fix last descriptor to point back to first */
 	priv(dev)->dma_desc[i - 1].next =
-		cpu_to_le32(priv(dev)->dma_desc_phys_addr | next_bits);
+	    cpu_to_le32(priv(dev)->dma_desc_phys_addr | next_bits);
 	DEBUG_PRINT(" desc %i next fixup 0x%lx\n", i - 1,
-		(unsigned long)priv(dev)->dma_desc[i - 1].next);
+		    (unsigned long)priv(dev)->dma_desc[i - 1].next);
 
 	priv(dev)->block_size = transfer_size;
 
@@ -567,14 +569,15 @@ static int hpdi_attach(struct comedi_dev
 	for (i = 0; i < ARRAY_SIZE(hpdi_boards) && dev->board_ptr == NULL; i++) {
 		do {
 			pcidev = pci_get_subsys(PCI_VENDOR_ID_PLX,
-				hpdi_boards[i].device_id, PCI_VENDOR_ID_PLX,
-				hpdi_boards[i].subdevice_id, pcidev);
+						hpdi_boards[i].device_id,
+						PCI_VENDOR_ID_PLX,
+						hpdi_boards[i].subdevice_id,
+						pcidev);
 			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1])
+				    PCI_SLOT(pcidev->devfn) != it->options[1])
 					continue;
 			}
 			if (pcidev) {
@@ -590,11 +593,11 @@ static int hpdi_attach(struct comedi_dev
 	}
 
 	printk("gsc_hpdi: found %s on bus %i, slot %i\n", board(dev)->name,
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	if (comedi_pci_enable(pcidev, driver_hpdi.driver_name)) {
 		printk(KERN_WARNING
-			" failed enable PCI device and request regions\n");
+		       " failed enable PCI device and request regions\n");
 		return -EIO;
 	}
 	pci_set_master(pcidev);
@@ -603,15 +606,17 @@ static int hpdi_attach(struct comedi_dev
 	dev->board_name = board(dev)->name;
 
 	priv(dev)->plx9080_phys_iobase =
-		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
 	priv(dev)->hpdi_phys_iobase =
-		pci_resource_start(pcidev, HPDI_BADDRINDEX);
+	    pci_resource_start(pcidev, HPDI_BADDRINDEX);
 
 	/*  remap, won't work with 2.0 kernels but who cares */
 	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
-		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
-	priv(dev)->hpdi_iobase = ioremap(priv(dev)->hpdi_phys_iobase,
-		pci_resource_len(pcidev, HPDI_BADDRINDEX));
+					    pci_resource_len(pcidev,
+							     PLX9080_BADDRINDEX));
+	priv(dev)->hpdi_iobase =
+	    ioremap(priv(dev)->hpdi_phys_iobase,
+		    pci_resource_len(pcidev, HPDI_BADDRINDEX));
 	if (!priv(dev)->plx9080_iobase || !priv(dev)->hpdi_iobase) {
 		printk(" failed to remap io memory\n");
 		return -ENOMEM;
@@ -635,16 +640,18 @@ static int hpdi_attach(struct comedi_dev
 	/*  alocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 		priv(dev)->dio_buffer[i] =
-			pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
-			&priv(dev)->dio_buffer_phys_addr[i]);
+		    pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
+					 &priv(dev)->dio_buffer_phys_addr[i]);
 		DEBUG_PRINT("dio_buffer at virt 0x%p, phys 0x%lx\n",
-			priv(dev)->dio_buffer[i],
-			(unsigned long)priv(dev)->dio_buffer_phys_addr[i]);
+			    priv(dev)->dio_buffer[i],
+			    (unsigned long)priv(dev)->dio_buffer_phys_addr[i]);
 	}
 	/*  allocate dma descriptors */
 	priv(dev)->dma_desc = pci_alloc_consistent(priv(dev)->hw_dev,
-		sizeof(struct plx_dma_desc) * NUM_DMA_DESCRIPTORS,
-		&priv(dev)->dma_desc_phys_addr);
+						   sizeof(struct plx_dma_desc) *
+						   NUM_DMA_DESCRIPTORS,
+						   &priv(dev)->
+						   dma_desc_phys_addr);
 	if (priv(dev)->dma_desc_phys_addr & 0xf) {
 		printk(" dma descriptors not quad-word aligned (bug)\n");
 		return -EIO;
@@ -681,18 +688,21 @@ static int hpdi_detach(struct comedi_dev
 			for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 				if (priv(dev)->dio_buffer[i])
 					pci_free_consistent(priv(dev)->hw_dev,
-						DMA_BUFFER_SIZE,
-						priv(dev)->dio_buffer[i],
-						priv(dev)->
-						dio_buffer_phys_addr[i]);
+							    DMA_BUFFER_SIZE,
+							    priv(dev)->
+							    dio_buffer[i],
+							    priv
+							    (dev)->dio_buffer_phys_addr
+							    [i]);
 			}
 			/*  free dma descriptors */
 			if (priv(dev)->dma_desc)
 				pci_free_consistent(priv(dev)->hw_dev,
-					sizeof(struct plx_dma_desc) *
-					NUM_DMA_DESCRIPTORS,
-					priv(dev)->dma_desc,
-					priv(dev)->dma_desc_phys_addr);
+						    sizeof(struct plx_dma_desc)
+						    * NUM_DMA_DESCRIPTORS,
+						    priv(dev)->dma_desc,
+						    priv(dev)->
+						    dma_desc_phys_addr);
 			if (priv(dev)->hpdi_phys_iobase) {
 				comedi_pci_disable(priv(dev)->hw_dev);
 			}
@@ -719,7 +729,7 @@ static int dio_config_block_size(struct 
 }
 
 static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+		       struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -805,7 +815,7 @@ static int di_cmd_test(struct comedi_dev
 			if (CR_CHAN(cmd->chanlist[i]) != i) {
 				/*  XXX could support 8 channels or 16 channels */
 				comedi_error(dev,
-					"chanlist must be channels 0 to 31 in order");
+					     "chanlist must be channels 0 to 31 in order");
 				err++;
 				break;
 			}
@@ -819,7 +829,7 @@ static int di_cmd_test(struct comedi_dev
 }
 
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			 struct comedi_cmd *cmd)
 {
 	if (priv(dev)->dio_config_output) {
 		return -EINVAL;
@@ -828,10 +838,10 @@ static int hpdi_cmd_test(struct comedi_d
 }
 
 static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
-	unsigned int offset)
+			       unsigned int offset)
 {
 	writel(bits | priv(dev)->bits[offset / sizeof(uint32_t)],
-		priv(dev)->hpdi_iobase + offset);
+	       priv(dev)->hpdi_iobase + offset);
 }
 
 static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -857,16 +867,16 @@ static int di_cmd(struct comedi_device *
 	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
 	/*  give location of first dma descriptor */
-	bits = priv(dev)->
-		dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-		PLX_XFER_LOCAL_TO_PCI;
+	bits =
+	    priv(dev)->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
+	    PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
 	writel(bits, priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 
 	/*  spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  enable dma transfer */
 	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
-		priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (cmd->stop_src == TRIG_COUNT)
@@ -876,10 +886,10 @@ static int di_cmd(struct comedi_device *
 
 	/*  clear over/under run status flags */
 	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
-		priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
+	       priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
 	/*  enable interrupts */
 	writel(intr_bit(RX_FULL_INTR),
-		priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
+	       priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
 	DEBUG_PRINT("hpdi: starting rx\n");
 	hpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);
@@ -905,22 +915,21 @@ static void drain_dma_buffers(struct com
 
 	if (channel)
 		pci_addr_reg =
-			priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+		    priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
 	else
 		pci_addr_reg =
-			priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+		    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
 	/*  loop until we have read all the full buffers */
 	j = 0;
 	for (next_transfer_addr = readl(pci_addr_reg);
-		(next_transfer_addr <
-			le32_to_cpu(priv(dev)->dma_desc[priv(dev)->
-					dma_desc_index].pci_start_addr)
-			|| next_transfer_addr >=
-			le32_to_cpu(priv(dev)->dma_desc[priv(dev)->
-					dma_desc_index].pci_start_addr) +
-			priv(dev)->block_size)
-		&& j < priv(dev)->num_dma_descriptors; j++) {
+	     (next_transfer_addr <
+	      le32_to_cpu(priv(dev)->dma_desc[priv(dev)->dma_desc_index].
+			  pci_start_addr)
+	      || next_transfer_addr >=
+	      le32_to_cpu(priv(dev)->dma_desc[priv(dev)->dma_desc_index].
+			  pci_start_addr) + priv(dev)->block_size)
+	     && j < priv(dev)->num_dma_descriptors; j++) {
 		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = priv(dev)->block_size / sizeof(uint32_t);
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -929,13 +938,15 @@ static void drain_dma_buffers(struct com
 			priv(dev)->dio_count -= num_samples;
 		}
 		cfc_write_array_to_buffer(dev->read_subdev,
-			priv(dev)->desc_dio_buffer[priv(dev)->dma_desc_index],
-			num_samples * sizeof(uint32_t));
+					  priv(dev)->desc_dio_buffer[priv(dev)->
+								     dma_desc_index],
+					  num_samples * sizeof(uint32_t));
 		priv(dev)->dma_desc_index++;
 		priv(dev)->dma_desc_index %= priv(dev)->num_dma_descriptors;
 
 		DEBUG_PRINT("next desc addr 0x%lx\n", (unsigned long)
-			priv(dev)->dma_desc[priv(dev)->dma_desc_index].next);
+			    priv(dev)->dma_desc[priv(dev)->dma_desc_index].
+			    next);
 		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
 	/*  XXX check for buffer overrun somehow */
@@ -969,14 +980,14 @@ static irqreturn_t handle_interrupt(int 
 	if (hpdi_intr_status) {
 		DEBUG_PRINT("hpdi: intr status 0x%x, ", hpdi_intr_status);
 		writel(hpdi_intr_status,
-			priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
+		       priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
 	/*  spin lock makes sure noone else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT) {
@@ -989,10 +1000,9 @@ static irqreturn_t handle_interrupt(int 
 	/*  spin lock makes sure noone else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
-	if (plx_status & ICS_DMA1_A)	/*  XXX */
-	{			/*  dma chan 1 interrupt */
+	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
 
 		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
@@ -1010,8 +1020,8 @@ static irqreturn_t handle_interrupt(int 
 		comedi_error(dev, "rx fifo overrun");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		DEBUG_PRINT("dma0_status 0x%x\n",
-			(int)readb(priv(dev)->plx9080_iobase +
-				PLX_DMA0_CS_REG));
+			    (int)readb(priv(dev)->plx9080_iobase +
+				       PLX_DMA0_CS_REG));
 	}
 
 	if (hpdi_board_status & RX_UNDERRUN_BIT) {
--- a/drivers/staging/comedi/drivers/icp_multi.c
+++ b/drivers/staging/comedi/drivers/icp_multi.c
@@ -110,11 +110,11 @@ Options:
 
 /*  Define analogue range */
 static const struct comedi_lrange range_analog = { 4, {
-			UNI_RANGE(5),
-			UNI_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(10)
-	}
+						       UNI_RANGE(5),
+						       UNI_RANGE(10),
+						       BIP_RANGE(5),
+						       BIP_RANGE(10)
+						       }
 };
 
 static const char range_codes_analog[] = { 0x00, 0x20, 0x10, 0x30 };
@@ -124,7 +124,8 @@ static const char range_codes_analog[] =
 	Forward declarations
 ==============================================================================
 */
-static int icp_multi_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int icp_multi_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it);
 static int icp_multi_detach(struct comedi_device *dev);
 
 /*
@@ -155,33 +156,33 @@ struct boardtype {
 
 static const struct boardtype boardtypes[] = {
 	{"icp_multi",		/*  Driver name */
-			DEVICE_ID,	/*  PCI device ID */
-			IORANGE_ICP_MULTI,	/*  I/O range length */
-			1,	/*  1=Card supports interrupts */
-			TYPE_ICP_MULTI,	/*  Card type = ICP MULTI */
-			16,	/*  Num of A/D channels */
-			8,	/*  Num of A/D channels in diff mode */
-			4,	/*  Num of D/A channels */
-			16,	/*  Num of digital inputs */
-			8,	/*  Num of digital outputs */
-			4,	/*  Num of counters */
-			0x0fff,	/*  Resolution of A/D */
-			0x0fff,	/*  Resolution of D/A */
-			&range_analog,	/*  Rangelist for A/D */
-			range_codes_analog,	/*  Range codes for programming */
-		&range_analog},	/*  Rangelist for D/A */
+	 DEVICE_ID,		/*  PCI device ID */
+	 IORANGE_ICP_MULTI,	/*  I/O range length */
+	 1,			/*  1=Card supports interrupts */
+	 TYPE_ICP_MULTI,	/*  Card type = ICP MULTI */
+	 16,			/*  Num of A/D channels */
+	 8,			/*  Num of A/D channels in diff mode */
+	 4,			/*  Num of D/A channels */
+	 16,			/*  Num of digital inputs */
+	 8,			/*  Num of digital outputs */
+	 4,			/*  Num of counters */
+	 0x0fff,		/*  Resolution of A/D */
+	 0x0fff,		/*  Resolution of D/A */
+	 &range_analog,		/*  Rangelist for A/D */
+	 range_codes_analog,	/*  Range codes for programming */
+	 &range_analog},	/*  Rangelist for D/A */
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct boardtype))
 
 static struct comedi_driver driver_icp_multi = {
-      driver_name:"icp_multi",
-      module : THIS_MODULE,
-      attach : icp_multi_attach,
-      detach : icp_multi_detach,
-      num_names : n_boardtypes,
-      board_name : &boardtypes[0].name,
-      offset : sizeof(struct boardtype),
+driver_name:"icp_multi",
+module:THIS_MODULE,
+attach:icp_multi_attach,
+detach:icp_multi_detach,
+num_names:n_boardtypes,
+board_name:&boardtypes[0].name,
+offset:sizeof(struct boardtype),
 };
 
 COMEDI_INITCLEANUP(driver_icp_multi);
@@ -199,9 +200,9 @@ struct icp_multi_private {
 	unsigned char act_chanlist_len;	/*  len of scanlist */
 	unsigned char act_chanlist_pos;	/*  actual position in MUX list */
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
-	short *ai_data;	/*  data buffer */
+	short *ai_data;		/*  data buffer */
 	short ao_data[4];	/*  data output buffer */
-	short di_data;	/*  Digital input data */
+	short di_data;		/*  Digital input data */
 	unsigned int do_data;	/*  Remember digital output data */
 };
 
@@ -215,11 +216,13 @@ struct icp_multi_private {
 */
 
 #if 0
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan);
-#endif
-static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan);
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int n_chan);
+#endif
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int n_chan);
 static int icp_multi_reset(struct comedi_device *dev);
 
 /*
@@ -246,8 +249,9 @@ static int icp_multi_reset(struct comedi
 
 ==============================================================================
 */
-static int icp_multi_insn_read_ai(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int icp_multi_insn_read_ai(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int n, timeout;
 
@@ -267,42 +271,42 @@ static int icp_multi_insn_read_ai(struct
 
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp_multi A ST=%4x IO=%p\n",
-		readw(devpriv->io_addr + ICP_MULTI_ADC_CSR),
-		devpriv->io_addr + ICP_MULTI_ADC_CSR);
+	       readw(devpriv->io_addr + ICP_MULTI_ADC_CSR),
+	       devpriv->io_addr + ICP_MULTI_ADC_CSR);
 #endif
 
 	for (n = 0; n < insn->n; n++) {
 		/*  Set start ADC bit */
 		devpriv->AdcCmdStatus |= ADC_ST;
 		writew(devpriv->AdcCmdStatus,
-			devpriv->io_addr + ICP_MULTI_ADC_CSR);
+		       devpriv->io_addr + ICP_MULTI_ADC_CSR);
 		devpriv->AdcCmdStatus &= ~ADC_ST;
 
 #ifdef ICP_MULTI_EXTDEBUG
 		printk("icp multi B n=%d ST=%4x\n", n,
-			readw(devpriv->io_addr + ICP_MULTI_ADC_CSR));
+		       readw(devpriv->io_addr + ICP_MULTI_ADC_CSR));
 #endif
 
 		udelay(1);
 
 #ifdef ICP_MULTI_EXTDEBUG
 		printk("icp multi C n=%d ST=%4x\n", n,
-			readw(devpriv->io_addr + ICP_MULTI_ADC_CSR));
+		       readw(devpriv->io_addr + ICP_MULTI_ADC_CSR));
 #endif
 
 		/*  Wait for conversion to complete, or get fed up waiting */
 		timeout = 100;
 		while (timeout--) {
 			if (!(readw(devpriv->io_addr +
-						ICP_MULTI_ADC_CSR) & ADC_BSY))
+				    ICP_MULTI_ADC_CSR) & ADC_BSY))
 				goto conv_finish;
 
 #ifdef ICP_MULTI_EXTDEBUG
 			if (!(timeout % 10))
 				printk("icp multi D n=%d tm=%d ST=%4x\n", n,
-					timeout,
-					readw(devpriv->io_addr +
-						ICP_MULTI_ADC_CSR));
+				       timeout,
+				       readw(devpriv->io_addr +
+					     ICP_MULTI_ADC_CSR));
 #endif
 
 			udelay(1);
@@ -318,19 +322,21 @@ static int icp_multi_insn_read_ai(struct
 		/*  Clear interrupt status */
 		devpriv->IntStatus |= ADC_READY;
 		writew(devpriv->IntStatus,
-			devpriv->io_addr + ICP_MULTI_INT_STAT);
+		       devpriv->io_addr + ICP_MULTI_INT_STAT);
 
 		/*  Clear data received */
 		data[n] = 0;
 
 #ifdef ICP_MULTI_EXTDEBUG
-		printk("icp multi EDBG: END: icp_multi_insn_read_ai(...) n=%d\n", n);
+		printk
+		    ("icp multi EDBG: END: icp_multi_insn_read_ai(...) n=%d\n",
+		     n);
 #endif
 		return -ETIME;
 
-	      conv_finish:
+conv_finish:
 		data[n] =
-			(readw(devpriv->io_addr + ICP_MULTI_AI) >> 4) & 0x0fff;
+		    (readw(devpriv->io_addr + ICP_MULTI_AI) >> 4) & 0x0fff;
 	}
 
 	/*  Disable interrupt */
@@ -365,8 +371,9 @@ static int icp_multi_insn_read_ai(struct
 
 ==============================================================================
 */
-static int icp_multi_insn_write_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int icp_multi_insn_write_ao(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan, range, timeout;
 
@@ -401,15 +408,15 @@ static int icp_multi_insn_write_ao(struc
 		timeout = 100;
 		while (timeout--) {
 			if (!(readw(devpriv->io_addr +
-						ICP_MULTI_DAC_CSR) & DAC_BSY))
+				    ICP_MULTI_DAC_CSR) & DAC_BSY))
 				goto dac_ready;
 
 #ifdef ICP_MULTI_EXTDEBUG
 			if (!(timeout % 10))
 				printk("icp multi A n=%d tm=%d ST=%4x\n", n,
-					timeout,
-					readw(devpriv->io_addr +
-						ICP_MULTI_DAC_CSR));
+				       timeout,
+				       readw(devpriv->io_addr +
+					     ICP_MULTI_DAC_CSR));
 #endif
 
 			udelay(1);
@@ -425,24 +432,26 @@ static int icp_multi_insn_write_ao(struc
 		/*  Clear interrupt status */
 		devpriv->IntStatus |= DAC_READY;
 		writew(devpriv->IntStatus,
-			devpriv->io_addr + ICP_MULTI_INT_STAT);
+		       devpriv->io_addr + ICP_MULTI_INT_STAT);
 
 		/*  Clear data received */
 		devpriv->ao_data[chan] = 0;
 
 #ifdef ICP_MULTI_EXTDEBUG
-		printk("icp multi EDBG: END: icp_multi_insn_write_ao(...) n=%d\n", n);
+		printk
+		    ("icp multi EDBG: END: icp_multi_insn_write_ao(...) n=%d\n",
+		     n);
 #endif
 		return -ETIME;
 
-	      dac_ready:
+dac_ready:
 		/*  Write data to analogue output data register */
 		writew(data[n], devpriv->io_addr + ICP_MULTI_AO);
 
 		/*  Set DAC_ST bit to write the data to selected channel */
 		devpriv->DacCmdStatus |= DAC_ST;
 		writew(devpriv->DacCmdStatus,
-			devpriv->io_addr + ICP_MULTI_DAC_CSR);
+		       devpriv->io_addr + ICP_MULTI_DAC_CSR);
 		devpriv->DacCmdStatus &= ~DAC_ST;
 
 		/*  Save analogue output data */
@@ -473,8 +482,9 @@ static int icp_multi_insn_write_ao(struc
 
 ==============================================================================
 */
-static int icp_multi_insn_read_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int icp_multi_insn_read_ao(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan;
 
@@ -506,8 +516,9 @@ static int icp_multi_insn_read_ao(struct
 
 ==============================================================================
 */
-static int icp_multi_insn_bits_di(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int icp_multi_insn_bits_di(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	data[1] = readw(devpriv->io_addr + ICP_MULTI_DI);
 
@@ -532,8 +543,9 @@ static int icp_multi_insn_bits_di(struct
 
 ==============================================================================
 */
-static int icp_multi_insn_bits_do(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int icp_multi_insn_bits_do(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG: BGN: icp_multi_insn_bits_do(...)\n");
@@ -574,8 +586,9 @@ static int icp_multi_insn_bits_do(struct
 
 ==============================================================================
 */
-static int icp_multi_insn_read_ctr(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int icp_multi_insn_read_ctr(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	return 0;
 }
@@ -598,8 +611,10 @@ static int icp_multi_insn_read_ctr(struc
 
 ==============================================================================
 */
-static int icp_multi_insn_write_ctr(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int icp_multi_insn_write_ctr(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	return 0;
 }
@@ -626,7 +641,7 @@ static irqreturn_t interrupt_service_icp
 
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG: BGN: interrupt_service_icp_multi(%d,...)\n",
-		irq);
+	       irq);
 #endif
 
 	/*  Is this interrupt from our board? */
@@ -637,7 +652,7 @@ static irqreturn_t interrupt_service_icp
 
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG: interrupt_service_icp_multi() ST: %4x\n",
-		readw(devpriv->io_addr + ICP_MULTI_INT_STAT));
+	       readw(devpriv->io_addr + ICP_MULTI_INT_STAT));
 #endif
 
 	/*  Determine which interrupt is active & handle it */
@@ -690,8 +705,9 @@ static irqreturn_t interrupt_service_icp
 
 ==============================================================================
 */
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan)
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int i;
 
@@ -709,13 +725,13 @@ static int check_channel_list(struct com
 		if (CR_AREF(chanlist[i]) == AREF_DIFF) {
 			if (CR_CHAN(chanlist[i]) > this_board->n_aichand) {
 				comedi_error(dev,
-					"Incorrect differential ai channel number");
+					     "Incorrect differential ai channel number");
 				return 0;
 			}
 		} else {
 			if (CR_CHAN(chanlist[i]) > this_board->n_aichan) {
 				comedi_error(dev,
-					"Incorrect ai channel number");
+					     "Incorrect ai channel number");
 				return 0;
 			}
 		}
@@ -744,8 +760,9 @@ static int check_channel_list(struct com
 
 ==============================================================================
 */
-static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan)
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int i, range, chanprog;
 	unsigned int diff;
@@ -788,11 +805,11 @@ static void setup_channel_list(struct co
 
 		/* Output channel, range, mode to ICP Multi */
 		writew(devpriv->AdcCmdStatus,
-			devpriv->io_addr + ICP_MULTI_ADC_CSR);
+		       devpriv->io_addr + ICP_MULTI_ADC_CSR);
 
 #ifdef ICP_MULTI_EXTDEBUG
 		printk("GS: %2d. [%4x]=%4x %4x\n", i, chanprog, range,
-			devpriv->act_chanlist[i]);
+		       devpriv->act_chanlist[i]);
 #endif
 	}
 
@@ -840,7 +857,7 @@ static int icp_multi_reset(struct comedi
 
 			/*  Output to command / status register */
 			writew(devpriv->DacCmdStatus,
-				devpriv->io_addr + ICP_MULTI_DAC_CSR);
+			       devpriv->io_addr + ICP_MULTI_DAC_CSR);
 
 			/*  Delay to allow DAC time to recover */
 			udelay(1);
@@ -871,7 +888,8 @@ static int icp_multi_reset(struct comedi
 
 ==============================================================================
 */
-static int icp_multi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int icp_multi_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret, subdev, n_subdevices;
@@ -891,15 +909,15 @@ static int icp_multi_attach(struct comed
 	if (pci_list_builded++ == 0) {
 		pci_card_list_init(PCI_VENDOR_ID_ICP,
 #ifdef ICP_MULTI_EXTDEBUG
-			1
+				   1
 #else
-			0
+				   0
 #endif
-			);
+		    );
 	}
 
 	printk("Anne's comedi%d: icp_multi: board=%s", dev->minor,
-		this_board->name);
+	       this_board->name);
 
 	card = select_and_alloc_pci_card(PCI_VENDOR_ID_ICP,
 					 this_board->device_id, it->options[0],
@@ -911,7 +929,7 @@ static int icp_multi_attach(struct comed
 	devpriv->card = card;
 
 	if ((pci_card_data(card, &pci_bus, &pci_slot, &pci_func, &io_addr[0],
-				&irq)) < 0) {
+			   &irq)) < 0) {
 		printk(" - Can't get configuration data!\n");
 		return -EIO;
 	}
@@ -920,7 +938,7 @@ static int icp_multi_attach(struct comed
 	devpriv->phys_iobase = iobase;
 
 	printk(", b:s:f=%d:%d:%d, io=0x%8llx \n", pci_bus, pci_slot, pci_func,
-		(unsigned long long)iobase);
+	       (unsigned long long)iobase);
 
 	devpriv->io_addr = ioremap(iobase, ICP_MULTI_SIZE);
 
@@ -930,7 +948,7 @@ static int icp_multi_attach(struct comed
 	}
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("0x%08llx mapped to %p, ", (unsigned long long)iobase,
-		devpriv->io_addr);
+	       devpriv->io_addr);
 #endif
 
 	dev->board_name = this_board->name;
@@ -957,7 +975,9 @@ static int icp_multi_attach(struct comed
 		if (irq) {
 			if (request_irq(irq, interrupt_service_icp_multi,
 					IRQF_SHARED, "Inova Icp Multi", dev)) {
-				printk(", unable to allocate IRQ %u, DISABLING IT", irq);
+				printk
+				    (", unable to allocate IRQ %u, DISABLING IT",
+				     irq);
 				irq = 0;	/* Can't use IRQ */
 			} else
 				printk(", irq=%u", irq);
--- a/drivers/staging/comedi/drivers/icp_multi.h
+++ b/drivers/staging/comedi/drivers/icp_multi.h
@@ -36,20 +36,26 @@ struct pcilst_struct *inova_devices;
 static void pci_card_list_init(unsigned short pci_vendor, char display);
 static void pci_card_list_cleanup(unsigned short pci_vendor);
 static struct pcilst_struct *find_free_pci_card_by_device(unsigned short
-	vendor_id, unsigned short device_id);
+							  vendor_id,
+							  unsigned short
+							  device_id);
 static int find_free_pci_card_by_position(unsigned short vendor_id,
-	unsigned short device_id, unsigned short pci_bus,
-	unsigned short pci_slot, struct pcilst_struct **card);
+					  unsigned short device_id,
+					  unsigned short pci_bus,
+					  unsigned short pci_slot,
+					  struct pcilst_struct **card);
 static struct pcilst_struct *select_and_alloc_pci_card(unsigned short vendor_id,
-	unsigned short device_id, unsigned short pci_bus,
-	unsigned short pci_slot);
+						       unsigned short device_id,
+						       unsigned short pci_bus,
+						       unsigned short pci_slot);
 
 static int pci_card_alloc(struct pcilst_struct *amcc);
 static int pci_card_free(struct pcilst_struct *amcc);
 static void pci_card_list_display(void);
 static int pci_card_data(struct pcilst_struct *amcc,
-	unsigned char *pci_bus, unsigned char *pci_slot,
-	unsigned char *pci_func, resource_size_t * io_addr, unsigned int *irq);
+			 unsigned char *pci_bus, unsigned char *pci_slot,
+			 unsigned char *pci_func, resource_size_t * io_addr,
+			 unsigned int *irq);
 
 /****************************************************************************/
 
@@ -64,12 +70,13 @@ static void pci_card_list_init(unsigned 
 	last = NULL;
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		if (pcidev->vendor == pci_vendor) {
 			inova = kmalloc(sizeof(*inova), GFP_KERNEL);
 			if (!inova) {
-				printk("icp_multi: pci_card_list_init: allocation failed\n");
+				printk
+				    ("icp_multi: pci_card_list_init: allocation failed\n");
 				pci_dev_put(pcidev);
 				break;
 			}
@@ -93,7 +100,7 @@ static void pci_card_list_init(unsigned 
 			 * pci_card_alloc. */
 			for (i = 0; i < 5; i++)
 				inova->io_addr[i] =
-					pci_resource_start(pcidev, i);
+				    pci_resource_start(pcidev, i);
 			inova->irq = pcidev->irq;
 		}
 	}
@@ -120,14 +127,16 @@ static void pci_card_list_cleanup(unsign
 /****************************************************************************/
 /* find first unused card with this device_id */
 static struct pcilst_struct *find_free_pci_card_by_device(unsigned short
-	vendor_id, unsigned short device_id)
+							  vendor_id,
+							  unsigned short
+							  device_id)
 {
 	struct pcilst_struct *inova, *next;
 
 	for (inova = inova_devices; inova; inova = next) {
 		next = inova->next;
 		if ((!inova->used) && (inova->device == device_id)
-			&& (inova->vendor == vendor_id))
+		    && (inova->vendor == vendor_id))
 			return inova;
 
 	}
@@ -138,8 +147,10 @@ static struct pcilst_struct *find_free_p
 /****************************************************************************/
 /* find card on requested position */
 static int find_free_pci_card_by_position(unsigned short vendor_id,
-	unsigned short device_id, unsigned short pci_bus,
-	unsigned short pci_slot, struct pcilst_struct **card)
+					  unsigned short device_id,
+					  unsigned short pci_bus,
+					  unsigned short pci_slot,
+					  struct pcilst_struct **card)
 {
 	struct pcilst_struct *inova, *next;
 
@@ -147,8 +158,8 @@ static int find_free_pci_card_by_positio
 	for (inova = inova_devices; inova; inova = next) {
 		next = inova->next;
 		if ((inova->vendor == vendor_id) && (inova->device == device_id)
-			&& (inova->pci_bus == pci_bus)
-			&& (inova->pci_slot == pci_slot)) {
+		    && (inova->pci_bus == pci_bus)
+		    && (inova->pci_slot == pci_slot)) {
 			if (!(inova->used)) {
 				*card = inova;
 				return 0;	/* ok, card is found */
@@ -211,7 +222,13 @@ static void pci_card_list_display(void)
 
 	for (inova = inova_devices; inova; inova = next) {
 		next = inova->next;
-		printk("%2d   %2d   %2d  0x%4x 0x%4x   0x%8llx 0x%8llx  %2u  %2d\n", inova->pci_bus, inova->pci_slot, inova->pci_func, inova->vendor, inova->device, (unsigned long long)inova->io_addr[0], (unsigned long long)inova->io_addr[2], inova->irq, inova->used);
+		printk
+		    ("%2d   %2d   %2d  0x%4x 0x%4x   0x%8llx 0x%8llx  %2u  %2d\n",
+		     inova->pci_bus, inova->pci_slot, inova->pci_func,
+		     inova->vendor, inova->device,
+		     (unsigned long long)inova->io_addr[0],
+		     (unsigned long long)inova->io_addr[2], inova->irq,
+		     inova->used);
 
 	}
 }
@@ -219,8 +236,9 @@ static void pci_card_list_display(void)
 /****************************************************************************/
 /* return all card information for driver */
 static int pci_card_data(struct pcilst_struct *inova,
-	unsigned char *pci_bus, unsigned char *pci_slot,
-	unsigned char *pci_func, resource_size_t * io_addr, unsigned int *irq)
+			 unsigned char *pci_bus, unsigned char *pci_slot,
+			 unsigned char *pci_func, resource_size_t * io_addr,
+			 unsigned int *irq)
 {
 	int i;
 
@@ -238,8 +256,9 @@ static int pci_card_data(struct pcilst_s
 /****************************************************************************/
 /* select and alloc card */
 static struct pcilst_struct *select_and_alloc_pci_card(unsigned short vendor_id,
-	unsigned short device_id, unsigned short pci_bus,
-	unsigned short pci_slot)
+						       unsigned short device_id,
+						       unsigned short pci_bus,
+						       unsigned short pci_slot)
 {
 	struct pcilst_struct *card;
 	int err;
@@ -253,16 +272,17 @@ static struct pcilst_struct *select_and_
 		}
 	} else {
 		switch (find_free_pci_card_by_position(vendor_id, device_id,
-				pci_bus, pci_slot, &card)) {
+						       pci_bus, pci_slot,
+						       &card)) {
 		case 1:
 			printk
-				(" - Card not found on requested position b:s %d:%d!\n",
-				pci_bus, pci_slot);
+			    (" - Card not found on requested position b:s %d:%d!\n",
+			     pci_bus, pci_slot);
 			return NULL;
 		case 2:
 			printk
-				(" - Card on requested position is used b:s %d:%d!\n",
-				pci_bus, pci_slot);
+			    (" - Card on requested position is used b:s %d:%d!\n",
+			     pci_bus, pci_slot);
 			return NULL;
 		}
 	}
--- a/drivers/staging/comedi/drivers/ii_pci20kc.c
+++ b/drivers/staging/comedi/drivers/ii_pci20kc.c
@@ -154,11 +154,11 @@ struct pci20xxx_private {
 	union pci20xxx_subdev_private subdev_private[PCI20000_MODULES];
 };
 
-
 #define devpriv ((struct pci20xxx_private *)dev->private)
 #define CHAN (CR_CHAN(it->chanlist[0]))
 
-static int pci20xxx_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci20xxx_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it);
 static int pci20xxx_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver_pci20xxx = {
@@ -169,10 +169,11 @@ static struct comedi_driver driver_pci20
 };
 
 static int pci20006_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	int opt0, int opt1);
+			 int opt0, int opt1);
 static int pci20341_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	int opt0, int opt1);
-static int pci20xxx_dio_init(struct comedi_device *dev, struct comedi_subdevice *s);
+			 int opt0, int opt1);
+static int pci20xxx_dio_init(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 
 /*
   options[0]	Board base address
@@ -201,7 +202,8 @@ static int pci20xxx_dio_init(struct come
 		1 == unipolar 10V  (0V -- +10V)
 		2 == bipolar 5V  (-5V -- +5V)
 */
-static int pci20xxx_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci20xxx_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it)
 {
 	unsigned char i;
 	int ret;
@@ -223,7 +225,9 @@ static int pci20xxx_attach(struct comedi
 	/* Check PCI-20001 C-2A Carrier Board ID */
 	if ((readb(devpriv->ioaddr) & PCI20000_ID) != PCI20000_ID) {
 		printk("comedi%d: ii_pci20kc", dev->minor);
-		printk(" PCI-20001 C-2A Carrier Board at base=0x%p not found !\n", devpriv->ioaddr);
+		printk
+		    (" PCI-20001 C-2A Carrier Board at base=0x%p not found !\n",
+		     devpriv->ioaddr);
 		return -EINVAL;
 	}
 	printk("comedi%d:\n", dev->minor);
@@ -237,22 +241,24 @@ static int pci20xxx_attach(struct comedi
 		switch (id) {
 		case PCI20006_ID:
 			sdp->pci20006.iobase =
-				devpriv->ioaddr + (i + 1) * PCI20000_OFFSET;
+			    devpriv->ioaddr + (i + 1) * PCI20000_OFFSET;
 			pci20006_init(dev, s, it->options[2 * i + 2],
-				it->options[2 * i + 3]);
+				      it->options[2 * i + 3]);
 			printk("comedi%d: ii_pci20kc", dev->minor);
 			printk(" PCI-20006 module in slot %d \n", i + 1);
 			break;
 		case PCI20341_ID:
 			sdp->pci20341.iobase =
-				devpriv->ioaddr + (i + 1) * PCI20000_OFFSET;
+			    devpriv->ioaddr + (i + 1) * PCI20000_OFFSET;
 			pci20341_init(dev, s, it->options[2 * i + 2],
-				it->options[2 * i + 3]);
+				      it->options[2 * i + 3]);
 			printk("comedi%d: ii_pci20kc", dev->minor);
 			printk(" PCI-20341 module in slot %d \n", i + 1);
 			break;
 		default:
-			printk("ii_pci20kc: unknown module code 0x%02x in slot %d: module disabled\n", id, i);
+			printk
+			    ("ii_pci20kc: unknown module code 0x%02x in slot %d: module disabled\n",
+			     id, i);
 			/* fall through */
 		case PCI20xxx_EMPTY_ID:
 			s->type = COMEDI_SUBD_UNUSED;
@@ -275,10 +281,12 @@ static int pci20xxx_detach(struct comedi
 
 /* pci20006m */
 
-static int pci20006_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pci20006_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pci20006_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int pci20006_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 static const struct comedi_lrange *pci20006_range_list[] = {
 	&range_bipolar10,
@@ -287,7 +295,7 @@ static const struct comedi_lrange *pci20
 };
 
 static int pci20006_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	int opt0, int opt1)
+			 int opt0, int opt1)
 {
 	union pci20xxx_subdev_private *sdp = s->private;
 
@@ -311,8 +319,9 @@ static int pci20006_init(struct comedi_d
 	return 0;
 }
 
-static int pci20006_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci20006_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	union pci20xxx_subdev_private *sdp = s->private;
 
@@ -321,8 +330,9 @@ static int pci20006_insn_read(struct com
 	return 1;
 }
 
-static int pci20006_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci20006_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	union pci20xxx_subdev_private *sdp = s->private;
 	int hi, lo;
@@ -354,15 +364,17 @@ static int pci20006_insn_write(struct co
 
 /* PCI20341M */
 
-static int pci20341_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pci20341_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
 
 static const int pci20341_timebase[] = { 0x00, 0x00, 0x00, 0x04 };
 static const int pci20341_settling_time[] = { 0x58, 0x58, 0x93, 0x99 };
 
 static const struct comedi_lrange range_bipolar0_5 = { 1, {BIP_RANGE(0.5)} };
 static const struct comedi_lrange range_bipolar0_05 = { 1, {BIP_RANGE(0.05)} };
-static const struct comedi_lrange range_bipolar0_025 = { 1, {BIP_RANGE(0.025)} };
+static const struct comedi_lrange range_bipolar0_025 =
+    { 1, {BIP_RANGE(0.025)} };
 
 static const struct comedi_lrange *const pci20341_ranges[] = {
 	&range_bipolar5,
@@ -372,7 +384,7 @@ static const struct comedi_lrange *const
 };
 
 static int pci20341_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	int opt0, int opt1)
+			 int opt0, int opt1)
 {
 	union pci20xxx_subdev_private *sdp = s->private;
 	int option;
@@ -402,10 +414,11 @@ static int pci20341_init(struct comedi_d
 	return 0;
 }
 
-static int pci20341_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci20341_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
-        union pci20xxx_subdev_private *sdp = s->private;
+	union pci20xxx_subdev_private *sdp = s->private;
 	unsigned int i = 0, j = 0;
 	int lo, hi;
 	unsigned char eoc;	/* end of conversion */
@@ -414,7 +427,7 @@ static int pci20341_insn_read(struct com
 
 	writeb(1, sdp->iobase + PCI20341_LCHAN_ADDR_REG);	/* write number of input channels */
 	clb = PCI20341_DAISY_CHAIN | PCI20341_MUX | (sdp->pci20341.ai_gain << 3)
-		| CR_CHAN(insn->chanspec);
+	    | CR_CHAN(insn->chanspec);
 	writeb(clb, sdp->iobase + PCI20341_CHAN_LIST);
 	writeb(0x00, sdp->iobase + PCI20341_CC_RESET);	/* reset settling time counter and trigger delay counter */
 	writeb(0x00, sdp->iobase + PCI20341_CHAN_RESET);
@@ -434,13 +447,15 @@ static int pci20341_insn_read(struct com
 			eoc = readb(sdp->iobase + PCI20341_STATUS_REG);
 		}
 		if (j >= 100) {
-			printk("comedi%d:  pci20xxx: AI interrupt channel %i polling exit !\n", dev->minor, i);
+			printk
+			    ("comedi%d:  pci20xxx: AI interrupt channel %i polling exit !\n",
+			     dev->minor, i);
 			return -EINVAL;
 		}
 		lo = readb(sdp->iobase + PCI20341_LDATA);
 		hi = readb(sdp->iobase + PCI20341_LDATA + 1);
 		boarddata = lo + 0x100 * hi;
-		data[i] = (short) ((boarddata + 0x8000) & 0xffff);	/* board-data -> comedi-data */
+		data[i] = (short)((boarddata + 0x8000) & 0xffff);	/* board-data -> comedi-data */
 	}
 
 	return i;
@@ -448,14 +463,19 @@ static int pci20341_insn_read(struct com
 
 /* native DIO */
 
-static void pci20xxx_dio_config(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pci20xxx_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pci20xxx_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static void pci20xxx_dio_config(struct comedi_device *dev,
+				struct comedi_subdevice *s);
+static int pci20xxx_dio_insn_bits(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
+static int pci20xxx_dio_insn_config(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data);
 
 /* initialize struct pci20xxx_private */
-static int pci20xxx_dio_init(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci20xxx_dio_init(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 
 	s->type = COMEDI_SUBD_DIO;
@@ -474,8 +494,10 @@ static int pci20xxx_dio_init(struct come
 	return 0;
 }
 
-static int pci20xxx_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci20xxx_dio_insn_config(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	int mask, bits;
 
@@ -499,8 +521,9 @@ static int pci20xxx_dio_insn_config(stru
 	return 1;
 }
 
-static int pci20xxx_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci20xxx_dio_insn_bits(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int mask = data[0];
 
@@ -510,16 +533,16 @@ static int pci20xxx_dio_insn_bits(struct
 	mask &= s->io_bits;
 	if (mask & 0x000000ff)
 		writeb((s->state >> 0) & 0xff,
-			devpriv->ioaddr + PCI20000_DIO_0);
+		       devpriv->ioaddr + PCI20000_DIO_0);
 	if (mask & 0x0000ff00)
 		writeb((s->state >> 8) & 0xff,
-			devpriv->ioaddr + PCI20000_DIO_1);
+		       devpriv->ioaddr + PCI20000_DIO_1);
 	if (mask & 0x00ff0000)
 		writeb((s->state >> 16) & 0xff,
-			devpriv->ioaddr + PCI20000_DIO_2);
+		       devpriv->ioaddr + PCI20000_DIO_2);
 	if (mask & 0xff000000)
 		writeb((s->state >> 24) & 0xff,
-			devpriv->ioaddr + PCI20000_DIO_3);
+		       devpriv->ioaddr + PCI20000_DIO_3);
 
 	data[1] = readb(devpriv->ioaddr + PCI20000_DIO_0);
 	data[1] |= readb(devpriv->ioaddr + PCI20000_DIO_1) << 8;
@@ -529,7 +552,8 @@ static int pci20xxx_dio_insn_bits(struct
 	return 2;
 }
 
-static void pci20xxx_dio_config(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci20xxx_dio_config(struct comedi_device *dev,
+				struct comedi_subdevice *s)
 {
 	unsigned char control_01;
 	unsigned char control_23;
@@ -543,7 +567,7 @@ static void pci20xxx_dio_config(struct c
 		/* output port 0 */
 		control_01 &= PCI20000_DIO_EOC;
 		buffer = (buffer & (~(DIO_BE << DIO_PS_0))) | (DIO_BO <<
-			DIO_PS_0);
+							       DIO_PS_0);
 	} else {
 		/* input port 0 */
 		control_01 = (control_01 & DIO_CAND) | PCI20000_DIO_EIC;
@@ -553,7 +577,7 @@ static void pci20xxx_dio_config(struct c
 		/* output port 1 */
 		control_01 &= PCI20000_DIO_OOC;
 		buffer = (buffer & (~(DIO_BE << DIO_PS_1))) | (DIO_BO <<
-			DIO_PS_1);
+							       DIO_PS_1);
 	} else {
 		/* input port 1 */
 		control_01 = (control_01 & DIO_CAND) | PCI20000_DIO_OIC;
@@ -563,7 +587,7 @@ static void pci20xxx_dio_config(struct c
 		/* output port 2 */
 		control_23 &= PCI20000_DIO_EOC;
 		buffer = (buffer & (~(DIO_BE << DIO_PS_2))) | (DIO_BO <<
-			DIO_PS_2);
+							       DIO_PS_2);
 	} else {
 		/* input port 2 */
 		control_23 = (control_23 & DIO_CAND) | PCI20000_DIO_EIC;
@@ -573,7 +597,7 @@ static void pci20xxx_dio_config(struct c
 		/* output port 3 */
 		control_23 &= PCI20000_DIO_OOC;
 		buffer = (buffer & (~(DIO_BE << DIO_PS_3))) | (DIO_BO <<
-			DIO_PS_3);
+							       DIO_PS_3);
 	} else {
 		/* input port 3 */
 		control_23 = (control_23 & DIO_CAND) | PCI20000_DIO_OIC;
@@ -598,7 +622,8 @@ static void pci20xxx_do(struct comedi_de
 	writeb((s->state >> 24) & 0xff, devpriv->ioaddr + PCI20000_DIO_3);
 }
 
-static unsigned int pci20xxx_di(struct comedi_device *dev, struct comedi_subdevice *s)
+static unsigned int pci20xxx_di(struct comedi_device *dev,
+				struct comedi_subdevice *s)
 {
 	/* XXX same note as above */
 	unsigned int bits;
--- a/drivers/staging/comedi/drivers/jr3_pci.c
+++ b/drivers/staging/comedi/drivers/jr3_pci.c
@@ -56,7 +56,8 @@ Devices: [JR3] PCI force sensor board (j
 #define PCI_DEVICE_ID_JR3_3_CHANNEL 0x3113
 #define PCI_DEVICE_ID_JR3_4_CHANNEL 0x3114
 
-static int jr3_pci_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int jr3_pci_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int jr3_pci_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver_jr3_pci = {
@@ -67,15 +68,16 @@ static struct comedi_driver driver_jr3_p
 };
 
 static DEFINE_PCI_DEVICE_TABLE(jr3_pci_pci_table) = {
-	{PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_1_CHANNEL,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_2_CHANNEL,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_3_CHANNEL,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_4_CHANNEL,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_1_CHANNEL,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_2_CHANNEL,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_3_CHANNEL,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_4_CHANNEL,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, jr3_pci_pci_table);
@@ -89,14 +91,12 @@ struct jr3_pci_dev_private {
 	struct timer_list timer;
 };
 
-
 struct poll_delay_t {
 
 	int min;
 	int max;
 };
 
-
 struct jr3_pci_subdev_private {
 	volatile struct jr3_channel *channel;
 	unsigned long next_time_min;
@@ -124,7 +124,7 @@ struct jr3_pci_subdev_private {
 /* Hotplug firmware loading stuff */
 
 typedef int comedi_firmware_callback(struct comedi_device *dev,
-				     const u8 *data, size_t size);
+				     const u8 * data, size_t size);
 
 static int comedi_load_firmware(struct comedi_device *dev, char *name,
 				comedi_firmware_callback cb)
@@ -143,7 +143,7 @@ static int comedi_load_firmware(struct c
 		strcat(firmware_path, prefix);
 		strcat(firmware_path, name);
 		result = request_firmware(&fw, firmware_path,
-			&devpriv->pci_dev->dev);
+					  &devpriv->pci_dev->dev);
 		if (result == 0) {
 			if (!cb)
 				result = -EINVAL;
@@ -178,7 +178,7 @@ struct transform_t {
 };
 
 static void set_transforms(volatile struct jr3_channel *channel,
-	struct transform_t transf, short num)
+			   struct transform_t transf, short num)
 {
 	int i;
 
@@ -197,7 +197,8 @@ static void set_transforms(volatile stru
 	}
 }
 
-static void use_transform(volatile struct jr3_channel *channel, short transf_num)
+static void use_transform(volatile struct jr3_channel *channel,
+			  short transf_num)
 {
 	set_s16(&channel->command_word0, 0x0500 + (transf_num & 0x000f));
 }
@@ -222,12 +223,12 @@ struct six_axis_t {
 };
 
 static void set_full_scales(volatile struct jr3_channel *channel,
-	struct six_axis_t full_scale)
+			    struct six_axis_t full_scale)
 {
 	printk("%d %d %d %d %d %d\n",
-		full_scale.fx,
-		full_scale.fy,
-		full_scale.fz, full_scale.mx, full_scale.my, full_scale.mz);
+	       full_scale.fx,
+	       full_scale.fy,
+	       full_scale.fz, full_scale.mx, full_scale.my, full_scale.mz);
 	set_s16(&channel->full_scale.fx, full_scale.fx);
 	set_s16(&channel->full_scale.fy, full_scale.fy);
 	set_s16(&channel->full_scale.fz, full_scale.fz);
@@ -237,7 +238,8 @@ static void set_full_scales(volatile str
 	set_s16(&channel->command_word0, 0x0a00);
 }
 
-static struct six_axis_t get_min_full_scales(volatile struct jr3_channel *channel)
+static struct six_axis_t get_min_full_scales(volatile struct jr3_channel
+					     *channel)
 {
 	struct six_axis_t result;
 	result.fx = get_s16(&channel->min_full_scale.fx);
@@ -249,7 +251,8 @@ static struct six_axis_t get_min_full_sc
 	return result;
 }
 
-static struct six_axis_t get_max_full_scales(volatile struct jr3_channel *channel)
+static struct six_axis_t get_max_full_scales(volatile struct jr3_channel
+					     *channel)
 {
 	struct six_axis_t result;
 	result.fx = get_s16(&channel->max_full_scale.fx);
@@ -261,8 +264,9 @@ static struct six_axis_t get_max_full_sc
 	return result;
 }
 
-static int jr3_pci_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int jr3_pci_ai_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int result;
 	struct jr3_pci_subdev_private *p;
@@ -277,9 +281,8 @@ static int jr3_pci_ai_insn_read(struct c
 
 		result = insn->n;
 		if (p->state != state_jr3_done ||
-			(get_u16(&p->channel->
-					errors) & (watch_dog | watch_dog2 |
-					sensor_change))) {
+		    (get_u16(&p->channel->errors) & (watch_dog | watch_dog2 |
+						     sensor_change))) {
 			/* No sensor or sensor changed */
 			if (p->state == state_jr3_done) {
 				/* Restart polling */
@@ -299,59 +302,51 @@ static int jr3_pci_ai_insn_read(struct c
 					int F = 0;
 					switch (axis) {
 					case 0:{
-							F = get_s16(&p->
-								channel->
-								filter[filter].
-								fx);
+							F = get_s16
+							    (&p->channel->filter
+							     [filter].fx);
 						}
 						break;
 					case 1:{
-							F = get_s16(&p->
-								channel->
-								filter[filter].
-								fy);
+							F = get_s16
+							    (&p->channel->filter
+							     [filter].fy);
 						}
 						break;
 					case 2:{
-							F = get_s16(&p->
-								channel->
-								filter[filter].
-								fz);
+							F = get_s16
+							    (&p->channel->filter
+							     [filter].fz);
 						}
 						break;
 					case 3:{
-							F = get_s16(&p->
-								channel->
-								filter[filter].
-								mx);
+							F = get_s16
+							    (&p->channel->filter
+							     [filter].mx);
 						}
 						break;
 					case 4:{
-							F = get_s16(&p->
-								channel->
-								filter[filter].
-								my);
+							F = get_s16
+							    (&p->channel->filter
+							     [filter].my);
 						}
 						break;
 					case 5:{
-							F = get_s16(&p->
-								channel->
-								filter[filter].
-								mz);
+							F = get_s16
+							    (&p->channel->filter
+							     [filter].mz);
 						}
 						break;
 					case 6:{
-							F = get_s16(&p->
-								channel->
-								filter[filter].
-								v1);
+							F = get_s16
+							    (&p->channel->filter
+							     [filter].v1);
 						}
 						break;
 					case 7:{
-							F = get_s16(&p->
-								channel->
-								filter[filter].
-								v2);
+							F = get_s16
+							    (&p->channel->filter
+							     [filter].v2);
 						}
 						break;
 					}
@@ -362,14 +357,14 @@ static int jr3_pci_ai_insn_read(struct c
 					data[i] = 0;
 				} else {
 					data[i] =
-						get_u16(&p->channel->model_no);
+					    get_u16(&p->channel->model_no);
 				}
 			} else if (channel == 57) {
 				if (p->state != state_jr3_done) {
 					data[i] = 0;
 				} else {
 					data[i] =
-						get_u16(&p->channel->serial_no);
+					    get_u16(&p->channel->serial_no);
 				}
 			}
 		}
@@ -389,12 +384,12 @@ static void jr3_pci_open(struct comedi_d
 		p = dev->subdevices[i].private;
 		if (p) {
 			printk("serial: %p %d (%d)\n", p, p->serial_no,
-				p->channel_no);
+			       p->channel_no);
 		}
 	}
 }
 
-int read_idm_word(const u8 *data, size_t size, int *pos, unsigned int *val)
+int read_idm_word(const u8 * data, size_t size, int *pos, unsigned int *val)
 {
 	int result = 0;
 	if (pos != 0 && val != 0) {
@@ -416,8 +411,8 @@ int read_idm_word(const u8 *data, size_t
 	return result;
 }
 
-static int jr3_download_firmware(struct comedi_device *dev, const u8 *data,
-	size_t size)
+static int jr3_download_firmware(struct comedi_device *dev, const u8 * data,
+				 size_t size)
 {
 	/*
 	 * IDM file format is:
@@ -461,24 +456,23 @@ static int jr3_download_firmware(struct 
 			while (more) {
 				unsigned int count, addr;
 				more = more
-					&& read_idm_word(data, size, &pos,
-					&count);
+				    && read_idm_word(data, size, &pos, &count);
 				if (more && count == 0xffff) {
 					break;
 				}
 				more = more
-					&& read_idm_word(data, size, &pos,
-					&addr);
+				    && read_idm_word(data, size, &pos, &addr);
 				printk("Loading#%d %4.4x bytes at %4.4x\n", i,
-					count, addr);
+				       count, addr);
 				while (more && count > 0) {
 					if (addr & 0x4000) {
 						/*  16 bit data, never seen in real life!! */
 						unsigned int data1;
 
 						more = more
-							&& read_idm_word(data,
-							size, &pos, &data1);
+						    && read_idm_word(data,
+								     size, &pos,
+								     &data1);
 						count--;
 						/* printk("jr3_data, not tested\n"); */
 						/* jr3[addr + 0x20000 * pnum] = data1; */
@@ -487,21 +481,23 @@ static int jr3_download_firmware(struct 
 						unsigned int data1, data2;
 
 						more = more
-							&& read_idm_word(data,
-							size, &pos, &data1);
+						    && read_idm_word(data,
+								     size, &pos,
+								     &data1);
 						more = more
-							&& read_idm_word(data,
-							size, &pos, &data2);
+						    && read_idm_word(data, size,
+								     &pos,
+								     &data2);
 						count -= 2;
 						if (more) {
-							set_u16(&p->iobase->
-								channel[i].
-								program_low
+							set_u16(&p->
+								iobase->channel
+								[i].program_low
 								[addr], data1);
 							udelay(1);
-							set_u16(&p->iobase->
-								channel[i].
-								program_high
+							set_u16(&p->
+								iobase->channel
+								[i].program_high
 								[addr], data2);
 							udelay(1);
 
@@ -538,7 +534,7 @@ static struct poll_delay_t jr3_pci_poll_
 				u16 model_no = get_u16(&channel->model_no);
 				u16 serial_no = get_u16(&channel->serial_no);
 				if ((errors & (watch_dog | watch_dog2)) ||
-					model_no == 0 || serial_no == 0) {
+				    model_no == 0 || serial_no == 0) {
 /*
  * Still no sensor, keep on polling. Since it takes up to 10 seconds
  * for offsets to stabilize, polling each second should suffice.
@@ -547,7 +543,7 @@ static struct poll_delay_t jr3_pci_poll_
 				} else {
 					p->retries = 0;
 					p->state =
-						state_jr3_init_wait_for_offset;
+					    state_jr3_init_wait_for_offset;
 					result = poll_delay_min_max(1000, 2000);
 				}
 			}
@@ -561,40 +557,44 @@ static struct poll_delay_t jr3_pci_poll_
 					struct transform_t transf;
 
 					p->model_no =
-						get_u16(&channel->model_no);
+					    get_u16(&channel->model_no);
 					p->serial_no =
-						get_u16(&channel->serial_no);
+					    get_u16(&channel->serial_no);
 
-					printk("Setting transform for channel %d\n", p->channel_no);
+					printk
+					    ("Setting transform for channel %d\n",
+					     p->channel_no);
 					printk("Sensor Model     = %i\n",
-						p->model_no);
+					       p->model_no);
 					printk("Sensor Serial    = %i\n",
-						p->serial_no);
+					       p->serial_no);
 
 					/*  Transformation all zeros */
 					transf.link[0].link_type =
-						(enum link_types)0;
+					    (enum link_types)0;
 					transf.link[0].link_amount = 0;
 					transf.link[1].link_type =
-						(enum link_types)0;
+					    (enum link_types)0;
 					transf.link[1].link_amount = 0;
 					transf.link[2].link_type =
-						(enum link_types)0;
+					    (enum link_types)0;
 					transf.link[2].link_amount = 0;
 					transf.link[3].link_type =
-						(enum link_types)0;
+					    (enum link_types)0;
 					transf.link[3].link_amount = 0;
 
 					set_transforms(channel, transf, 0);
 					use_transform(channel, 0);
 					p->state =
-						state_jr3_init_transform_complete;
+					    state_jr3_init_transform_complete;
 					result = poll_delay_min_max(20, 100);	/*  Allow 20 ms for completion */
 				}
 			} break;
 		case state_jr3_init_transform_complete:{
 				if (!is_complete(channel)) {
-					printk("state_jr3_init_transform_complete complete = %d\n", is_complete(channel));
+					printk
+					    ("state_jr3_init_transform_complete complete = %d\n",
+					     is_complete(channel));
 					result = poll_delay_min_max(20, 100);
 				} else {
 					/*  Set full scale */
@@ -602,7 +602,7 @@ static struct poll_delay_t jr3_pci_poll_
 					struct six_axis_t max_full_scale;
 
 					min_full_scale =
-						get_min_full_scales(channel);
+					    get_min_full_scales(channel);
 					printk("Obtained Min. Full Scales:\n");
 					printk("%i   ", (min_full_scale).fx);
 					printk("%i   ", (min_full_scale).fy);
@@ -613,7 +613,7 @@ static struct poll_delay_t jr3_pci_poll_
 					printk("\n");
 
 					max_full_scale =
-						get_max_full_scales(channel);
+					    get_max_full_scales(channel);
 					printk("Obtained Max. Full Scales:\n");
 					printk("%i   ", (max_full_scale).fx);
 					printk("%i   ", (max_full_scale).fy);
@@ -624,17 +624,19 @@ static struct poll_delay_t jr3_pci_poll_
 					printk("\n");
 
 					set_full_scales(channel,
-						max_full_scale);
+							max_full_scale);
 
 					p->state =
-						state_jr3_init_set_full_scale_complete;
+					    state_jr3_init_set_full_scale_complete;
 					result = poll_delay_min_max(20, 100);	/*  Allow 20 ms for completion */
 				}
 			}
 			break;
 		case state_jr3_init_set_full_scale_complete:{
 				if (!is_complete(channel)) {
-					printk("state_jr3_init_set_full_scale_complete complete = %d\n", is_complete(channel));
+					printk
+					    ("state_jr3_init_set_full_scale_complete complete = %d\n",
+					     is_complete(channel));
 					result = poll_delay_min_max(20, 100);
 				} else {
 					volatile struct force_array *full_scale;
@@ -642,32 +644,29 @@ static struct poll_delay_t jr3_pci_poll_
 					/*  Use ranges in kN or we will overflow arount 2000N! */
 					full_scale = &channel->full_scale;
 					p->range[0].range.min =
-						-get_s16(&full_scale->fx) *
-						1000;
+					    -get_s16(&full_scale->fx) * 1000;
 					p->range[0].range.max =
-						get_s16(&full_scale->fx) * 1000;
+					    get_s16(&full_scale->fx) * 1000;
 					p->range[1].range.min =
-						-get_s16(&full_scale->fy) *
-						1000;
+					    -get_s16(&full_scale->fy) * 1000;
 					p->range[1].range.max =
-						get_s16(&full_scale->fy) * 1000;
+					    get_s16(&full_scale->fy) * 1000;
 					p->range[2].range.min =
-						-get_s16(&full_scale->fz) *
-						1000;
+					    -get_s16(&full_scale->fz) * 1000;
 					p->range[2].range.max =
-						get_s16(&full_scale->fz) * 1000;
+					    get_s16(&full_scale->fz) * 1000;
 					p->range[3].range.min =
-						-get_s16(&full_scale->mx) * 100;
+					    -get_s16(&full_scale->mx) * 100;
 					p->range[3].range.max =
-						get_s16(&full_scale->mx) * 100;
+					    get_s16(&full_scale->mx) * 100;
 					p->range[4].range.min =
-						-get_s16(&full_scale->my) * 100;
+					    -get_s16(&full_scale->my) * 100;
 					p->range[4].range.max =
-						get_s16(&full_scale->my) * 100;
+					    get_s16(&full_scale->my) * 100;
 					p->range[5].range.min =
-						-get_s16(&full_scale->mz) * 100;
+					    -get_s16(&full_scale->mz) * 100;
 					p->range[5].range.max =
-						get_s16(&full_scale->mz) * 100;
+					    get_s16(&full_scale->mz) * 100;
 					p->range[6].range.min = -get_s16(&full_scale->v1) * 100;	/*  ?? */
 					p->range[6].range.max = get_s16(&full_scale->v1) * 100;	/*  ?? */
 					p->range[7].range.min = -get_s16(&full_scale->v2) * 100;	/*  ?? */
@@ -679,27 +678,38 @@ static struct poll_delay_t jr3_pci_poll_
 						int i;
 						for (i = 0; i < 9; i++) {
 							printk("%d %d - %d\n",
-								i,
-								p->range[i].
-								range.min,
-								p->range[i].
-								range.max);
+							       i,
+							       p->
+							       range[i].range.
+							       min,
+							       p->
+							       range[i].range.
+							       max);
 						}
 					}
 
 					use_offset(channel, 0);
 					p->state =
-						state_jr3_init_use_offset_complete;
+					    state_jr3_init_use_offset_complete;
 					result = poll_delay_min_max(40, 100);	/*  Allow 40 ms for completion */
 				}
 			}
 			break;
 		case state_jr3_init_use_offset_complete:{
 				if (!is_complete(channel)) {
-					printk("state_jr3_init_use_offset_complete complete = %d\n", is_complete(channel));
+					printk
+					    ("state_jr3_init_use_offset_complete complete = %d\n",
+					     is_complete(channel));
 					result = poll_delay_min_max(20, 100);
 				} else {
-					printk("Default offsets %d %d %d %d %d %d\n", get_s16(&channel->offsets.fx), get_s16(&channel->offsets.fy), get_s16(&channel->offsets.fz), get_s16(&channel->offsets.mx), get_s16(&channel->offsets.my), get_s16(&channel->offsets.mz));
+					printk
+					    ("Default offsets %d %d %d %d %d %d\n",
+					     get_s16(&channel->offsets.fx),
+					     get_s16(&channel->offsets.fy),
+					     get_s16(&channel->offsets.fz),
+					     get_s16(&channel->offsets.mx),
+					     get_s16(&channel->offsets.my),
+					     get_s16(&channel->offsets.mz));
 
 					set_s16(&channel->offsets.fx, 0);
 					set_s16(&channel->offsets.fy, 0);
@@ -730,7 +740,7 @@ static struct poll_delay_t jr3_pci_poll_
 static void jr3_pci_poll_dev(unsigned long data)
 {
 	unsigned long flags;
-	struct comedi_device *dev = (struct comedi_device *) data;
+	struct comedi_device *dev = (struct comedi_device *)data;
 	struct jr3_pci_dev_private *devpriv = dev->private;
 	unsigned long now;
 	int delay;
@@ -741,15 +751,16 @@ static void jr3_pci_poll_dev(unsigned lo
 	now = jiffies;
 	/*  Poll all channels that are ready to be polled */
 	for (i = 0; i < devpriv->n_channels; i++) {
-		struct jr3_pci_subdev_private *subdevpriv = dev->subdevices[i].private;
+		struct jr3_pci_subdev_private *subdevpriv =
+		    dev->subdevices[i].private;
 		if (now > subdevpriv->next_time_min) {
 			struct poll_delay_t sub_delay;
 
 			sub_delay = jr3_pci_poll_subdevice(&dev->subdevices[i]);
 			subdevpriv->next_time_min =
-				jiffies + msecs_to_jiffies(sub_delay.min);
+			    jiffies + msecs_to_jiffies(sub_delay.min);
 			subdevpriv->next_time_max =
-				jiffies + msecs_to_jiffies(sub_delay.max);
+			    jiffies + msecs_to_jiffies(sub_delay.max);
 			if (sub_delay.max && sub_delay.max < delay) {
 /*
 * Wake up as late as possible -> poll as many channels as possible
@@ -765,7 +776,8 @@ static void jr3_pci_poll_dev(unsigned lo
 	add_timer(&devpriv->timer);
 }
 
-static int jr3_pci_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int jr3_pci_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	int result = 0;
 	struct pci_dev *card = NULL;
@@ -779,7 +791,7 @@ static int jr3_pci_attach(struct comedi_
 
 	if (sizeof(struct jr3_channel) != 0xc00) {
 		printk("sizeof(struct jr3_channel) = %x [expected %x]\n",
-			(unsigned)sizeof(struct jr3_channel), 0xc00);
+		       (unsigned)sizeof(struct jr3_channel), 0xc00);
 		return -EINVAL;
 	}
 
@@ -822,7 +834,7 @@ static int jr3_pci_attach(struct comedi_
 					/* Take first available card */
 					break;
 				} else if (opt_bus == card->bus->number &&
-					opt_slot == PCI_SLOT(card->devfn)) {
+					   opt_slot == PCI_SLOT(card->devfn)) {
 					/* Take requested card */
 					break;
 				}
@@ -843,7 +855,8 @@ static int jr3_pci_attach(struct comedi_
 	}
 
 	devpriv->pci_enabled = 1;
-	devpriv->iobase = ioremap(pci_resource_start(card, 0), sizeof(struct jr3_t));
+	devpriv->iobase =
+	    ioremap(pci_resource_start(card, 0), sizeof(struct jr3_t));
 	result = alloc_subdevices(dev, devpriv->n_channels);
 	if (result < 0)
 		goto out;
@@ -855,7 +868,7 @@ static int jr3_pci_attach(struct comedi_
 		dev->subdevices[i].n_chan = 8 * 7 + 2;
 		dev->subdevices[i].insn_read = jr3_pci_ai_insn_read;
 		dev->subdevices[i].private =
-			kzalloc(sizeof(struct jr3_pci_subdev_private), GFP_KERNEL);
+		    kzalloc(sizeof(struct jr3_pci_subdev_private), GFP_KERNEL);
 		if (dev->subdevices[i].private) {
 			struct jr3_pci_subdev_private *p;
 			int j;
@@ -863,9 +876,9 @@ static int jr3_pci_attach(struct comedi_
 			p = dev->subdevices[i].private;
 			p->channel = &devpriv->iobase->channel[i].data;
 			printk("p->channel %p %p (%tx)\n",
-				p->channel, devpriv->iobase,
-				((char *)(p->channel) -
-					(char *)(devpriv->iobase)));
+			       p->channel, devpriv->iobase,
+			       ((char *)(p->channel) -
+				(char *)(devpriv->iobase)));
 			p->channel_no = i;
 			for (j = 0; j < 8; j++) {
 				int k;
@@ -875,7 +888,8 @@ static int jr3_pci_attach(struct comedi_
 				p->range[j].range.max = 1000000;
 				for (k = 0; k < 7; k++) {
 					p->range_table_list[j + k * 8] =
-						(struct comedi_lrange *) &p->range[j];
+					    (struct comedi_lrange *)&p->
+					    range[j];
 					p->maxdata_list[j + k * 8] = 0x7fff;
 				}
 			}
@@ -884,15 +898,15 @@ static int jr3_pci_attach(struct comedi_
 			p->range[8].range.max = 65536;
 
 			p->range_table_list[56] =
-				(struct comedi_lrange *) &p->range[8];
+			    (struct comedi_lrange *)&p->range[8];
 			p->range_table_list[57] =
-				(struct comedi_lrange *) &p->range[8];
+			    (struct comedi_lrange *)&p->range[8];
 			p->maxdata_list[56] = 0xffff;
 			p->maxdata_list[57] = 0xffff;
 			/*  Channel specific range and maxdata */
 			dev->subdevices[i].range_table = 0;
 			dev->subdevices[i].range_table_list =
-				p->range_table_list;
+			    p->range_table_list;
 			dev->subdevices[i].maxdata = 0;
 			dev->subdevices[i].maxdata_list = p->maxdata_list;
 		}
@@ -922,8 +936,8 @@ static int jr3_pci_attach(struct comedi_
 	msleep_interruptible(25);
 	for (i = 0; i < 0x18; i++) {
 		printk("%c",
-			get_u16(&devpriv->iobase->channel[0].data.
-				copyright[i]) >> 8);
+		       get_u16(&devpriv->iobase->channel[0].
+			       data.copyright[i]) >> 8);
 	}
 
 	/*  Start card timer */
@@ -939,7 +953,7 @@ static int jr3_pci_attach(struct comedi_
 	devpriv->timer.expires = jiffies + msecs_to_jiffies(1000);
 	add_timer(&devpriv->timer);
 
-      out:
+out:
 	return result;
 }
 
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -2,22 +2,22 @@
  * is 16 bits, but aligned on a 32 bit PCI boundary
  */
 
-static inline u16 get_u16(volatile const u32 *p)
+static inline u16 get_u16(volatile const u32 * p)
 {
 	return (u16) readl(p);
 }
 
-static inline void set_u16(volatile u32 *p, u16 val)
+static inline void set_u16(volatile u32 * p, u16 val)
 {
 	writel(val, p);
 }
 
-static inline s16 get_s16(volatile const s32 *p)
+static inline s16 get_s16(volatile const s32 * p)
 {
 	return (s16) readl(p);
 }
 
-static inline void set_s16(volatile s32 *p, s16 val)
+static inline void set_s16(volatile s32 * p, s16 val)
 {
 	writel(val, p);
 }
@@ -304,7 +304,7 @@ struct jr3_channel {
 	/* not set a full scale. */
 
 	struct six_axis_array default_FS;	/* offset 0x0068 */
-	s32 reserved3;	/* offset 0x006e */
+	s32 reserved3;		/* offset 0x006e */
 
 	/* Load_envelope_num is the load envelope number that is currently
 	 * in use. This value is set by the user after one of the load
@@ -341,7 +341,7 @@ struct jr3_channel {
 	 */
 
 	struct six_axis_array min_full_scale;	/* offset 0x0070 */
-	s32 reserved4;	/* offset 0x0076 */
+	s32 reserved4;		/* offset 0x0076 */
 
 	/* Transform_num is the transform number that is currently in use.
 	 * This value is set by the JR3 DSP after the user has used command
@@ -354,7 +354,7 @@ struct jr3_channel {
 	/*  min_full_scale (pg. 9) for more details. */
 
 	struct six_axis_array max_full_scale;	/* offset 0x0078 */
-	s32 reserved5;	/* offset 0x007e */
+	s32 reserved5;		/* offset 0x007e */
 
 	/* Peak_address is the address of the data which will be monitored
 	 * by the peak routine. This value is set by the user. The peak
@@ -398,14 +398,14 @@ struct jr3_channel {
 	 * offset # command (pg. 34). It can vary between 0 and 15.
 	 */
 
-	s32 offset_num;	/* offset 0x008e */
+	s32 offset_num;		/* offset 0x008e */
 
 	/* Vect_axes is a bit map showing which of the axes are being used
 	 * in the vector calculations. This value is set by the JR3 DSP
 	 * after the user has executed the set vector axes command (pg. 37).
 	 */
 
-	u32 vect_axes;	/* offset 0x008f */
+	u32 vect_axes;		/* offset 0x008f */
 
 	/* Filter0 is the decoupled, unfiltered data from the JR3 sensor.
 	 * This data has had the offsets removed.
@@ -465,7 +465,7 @@ struct jr3_channel {
 	 */
 
 	s32 near_sat_value;	/* offset 0x00e0 */
-	s32 sat_value;	/* offset 0x00e1 */
+	s32 sat_value;		/* offset 0x00e1 */
 
 	/* Rate_address, rate_divisor & rate_count contain the data used to
 	 * control the calculations of the rates. Rate_address is the
@@ -486,7 +486,7 @@ struct jr3_channel {
 
 	s32 rate_address;	/* offset 0x00e2 */
 	u32 rate_divisor;	/* offset 0x00e3 */
-	u32 rate_count;	/* offset 0x00e4 */
+	u32 rate_count;		/* offset 0x00e4 */
 
 	/* Command_word2 through command_word0 are the locations used to
 	 * send commands to the JR3 DSP. Their usage varies with the command
@@ -543,14 +543,14 @@ struct jr3_channel {
 	 * Issues section on pg. 49 for more details.
 	 */
 
-	u32 count_x;	/* offset 0x00ef */
+	u32 count_x;		/* offset 0x00ef */
 
 	/* Warnings & errors contain the warning and error bits
 	 * respectively. The format of these two words is discussed on page
 	 * 21 under the headings warnings_bits and error_bits.
 	 */
 
-	u32 warnings;	/* offset 0x00f0 */
+	u32 warnings;		/* offset 0x00f0 */
 	u32 errors;		/* offset 0x00f1 */
 
 	/* Threshold_bits is a word containing the bits that are set by the
@@ -565,7 +565,7 @@ struct jr3_channel {
 	 * description for cal_crc_bad (pg. 21) for more information.
 	 */
 
-	s32 last_CRC;	/* offset 0x00f3 */
+	s32 last_CRC;		/* offset 0x00f3 */
 
 	/* EEProm_ver_no contains the version number of the sensor EEProm.
 	 * EEProm version numbers can vary between 0 and 255.
@@ -591,16 +591,16 @@ struct jr3_channel {
 	 * different sensor configurations.
 	 */
 
-	u32 serial_no;	/* offset 0x00f8 */
-	u32 model_no;	/* offset 0x00f9 */
+	u32 serial_no;		/* offset 0x00f8 */
+	u32 model_no;		/* offset 0x00f9 */
 
 	/* Cal_day & cal_year are the sensor calibration date. Day is the
 	 * day of the year, with January 1 being 1, and December 31, being
 	 * 366 for leap years.
 	 */
 
-	s32 cal_day;	/* offset 0x00fa */
-	s32 cal_year;	/* offset 0x00fb */
+	s32 cal_day;		/* offset 0x00fa */
+	s32 cal_year;		/* offset 0x00fb */
 
 	/* Units is an enumerated read only value defining the engineering
 	 * units used in the sensor full scale. The meanings of particular
@@ -627,7 +627,7 @@ struct jr3_channel {
 
 	u32 units;		/* offset 0x00fc */
 	s32 bits;		/* offset 0x00fd */
-	s32 channels;	/* offset 0x00fe */
+	s32 channels;		/* offset 0x00fe */
 
 	/* Thickness specifies the overall thickness of the sensor from
 	 * flange to flange. The engineering units for this value are
@@ -636,7 +636,7 @@ struct jr3_channel {
 	 * transformation from the center of the sensor to either flange.
 	 */
 
-	s32 thickness;	/* offset 0x00ff */
+	s32 thickness;		/* offset 0x00ff */
 
 	/* Load_envelopes is a table containing the load envelope
 	 * descriptions. There are 16 possible load envelope slots in the
--- a/drivers/staging/comedi/drivers/ke_counter.c
+++ b/drivers/staging/comedi/drivers/ke_counter.c
@@ -52,9 +52,10 @@ static int cnt_attach(struct comedi_devi
 static int cnt_detach(struct comedi_device *dev);
 
 static DEFINE_PCI_DEVICE_TABLE(cnt_pci_table) = {
-	{PCI_VENDOR_ID_KOLTER, CNT_CARD_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		0},
-	{0}
+	{
+	PCI_VENDOR_ID_KOLTER, CNT_CARD_DEVICE_ID, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, cnt_pci_table);
@@ -69,13 +70,12 @@ struct cnt_board_struct {
 	int cnt_bits;
 };
 
-
 static const struct cnt_board_struct cnt_boards[] = {
 	{
-	.name = CNT_DRIVER_NAME,
-	.device_id = CNT_CARD_DEVICE_ID,
-	.cnt_channel_nbr = 3,
-	.cnt_bits = 24}
+	 .name = CNT_DRIVER_NAME,
+	 .device_id = CNT_CARD_DEVICE_ID,
+	 .cnt_channel_nbr = 3,
+	 .cnt_bits = 24}
 };
 
 #define cnt_board_nbr (sizeof(cnt_boards)/sizeof(struct cnt_board_struct))
@@ -87,7 +87,6 @@ struct cnt_device_private {
 	struct pci_dev *pcidev;
 };
 
-
 #define devpriv ((struct cnt_device_private *)dev->private)
 
 static struct comedi_driver cnt_driver = {
@@ -104,18 +103,19 @@ COMEDI_PCI_INITCLEANUP(cnt_driver, cnt_p
 /* This should be used only for resetting the counters; maybe it is better
    to make a special command 'reset'. */
 static int cnt_winsn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+		     struct comedi_subdevice *s, struct comedi_insn *insn,
+		     unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
 	outb((unsigned char)((data[0] >> 24) & 0xff),
-		dev->iobase + chan * 0x20 + 0x10);
+	     dev->iobase + chan * 0x20 + 0x10);
 	outb((unsigned char)((data[0] >> 16) & 0xff),
-		dev->iobase + chan * 0x20 + 0x0c);
+	     dev->iobase + chan * 0x20 + 0x0c);
 	outb((unsigned char)((data[0] >> 8) & 0xff),
-		dev->iobase + chan * 0x20 + 0x08);
+	     dev->iobase + chan * 0x20 + 0x08);
 	outb((unsigned char)((data[0] >> 0) & 0xff),
-		dev->iobase + chan * 0x20 + 0x04);
+	     dev->iobase + chan * 0x20 + 0x04);
 
 	/* return the number of samples written */
 	return 1;
@@ -124,7 +124,8 @@ static int cnt_winsn(struct comedi_devic
 /*-- counter read -----------------------------------------------------------*/
 
 static int cnt_rinsn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+		     struct comedi_subdevice *s, struct comedi_insn *insn,
+		     unsigned int *data)
 {
 	unsigned char a0, a1, a2, a3, a4;
 	int chan = CR_CHAN(insn->chanspec);
@@ -140,7 +141,7 @@ static int cnt_rinsn(struct comedi_devic
 	if (a4 > 0)
 		result = result - s->maxdata;
 
-	*data = (unsigned int) result;
+	*data = (unsigned int)result;
 
 	/* return the number of samples read */
 	return 1;
@@ -163,49 +164,51 @@ static int cnt_attach(struct comedi_devi
 
 	/* Probe the device to determine what device in the series it is. */
 	for (pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pci_device != NULL;
-		pci_device =
-		pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_device)) {
+	     pci_device != NULL;
+	     pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_device)) {
 		if (pci_device->vendor == PCI_VENDOR_ID_KOLTER) {
 			for (i = 0; i < cnt_board_nbr; i++) {
 				if (cnt_boards[i].device_id ==
-					pci_device->device) {
+				    pci_device->device) {
 					/* was a particular bus/slot requested? */
 					if ((it->options[0] != 0)
-						|| (it->options[1] != 0)) {
+					    || (it->options[1] != 0)) {
 						/* are we on the wrong bus/slot? */
 						if (pci_device->bus->number !=
-							it->options[0]
-							|| PCI_SLOT(pci_device->
-								devfn) !=
-							it->options[1]) {
+						    it->options[0]
+						    ||
+						    PCI_SLOT(pci_device->devfn)
+						    != it->options[1]) {
 							continue;
 						}
 					}
 
 					dev->board_ptr = cnt_boards + i;
-					board = (struct cnt_board_struct *) dev->
-						board_ptr;
+					board =
+					    (struct cnt_board_struct *)
+					    dev->board_ptr;
 					goto found;
 				}
 			}
 		}
 	}
 	printk("comedi%d: no supported board found! (req. bus/slot: %d/%d)\n",
-		dev->minor, it->options[0], it->options[1]);
+	       dev->minor, it->options[0], it->options[1]);
 	return -EIO;
 
-      found:
+found:
 	printk("comedi%d: found %s at PCI bus %d, slot %d\n", dev->minor,
-		board->name, pci_device->bus->number,
-		PCI_SLOT(pci_device->devfn));
+	       board->name, pci_device->bus->number,
+	       PCI_SLOT(pci_device->devfn));
 	devpriv->pcidev = pci_device;
 	dev->board_name = board->name;
 
 	/* enable PCI device and request regions */
 	error = comedi_pci_enable(pci_device, CNT_DRIVER_NAME);
 	if (error < 0) {
-		printk("comedi%d: failed to enable PCI device and request regions!\n", dev->minor);
+		printk
+		    ("comedi%d: failed to enable PCI device and request regions!\n",
+		     dev->minor);
 		return error;
 	}
 
--- a/drivers/staging/comedi/drivers/me4000.c
+++ b/drivers/staging/comedi/drivers/me4000.c
@@ -71,24 +71,21 @@ broken.
   ===========================================================================*/
 
 static DEFINE_PCI_DEVICE_TABLE(me4000_pci_table) = {
-	{PCI_VENDOR_ID_MEILHAUS, 0x4650, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-
-	{PCI_VENDOR_ID_MEILHAUS, 0x4660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4661, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4662, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4663, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-
-	{PCI_VENDOR_ID_MEILHAUS, 0x4670, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4671, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4672, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4673, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-
-	{PCI_VENDOR_ID_MEILHAUS, 0x4680, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4681, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4682, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_MEILHAUS, 0x4683, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-
-	{0}
+	{
+	PCI_VENDOR_ID_MEILHAUS, 0x4650, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4661, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4662, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4663, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4670, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4671, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4672, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4673, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4680, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4681, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4682, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, 0x4683, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, me4000_pci_table);
@@ -119,13 +116,14 @@ static const struct me4000_board me4000_
 /*-----------------------------------------------------------------------------
   Comedi function prototypes
   ---------------------------------------------------------------------------*/
-static int me4000_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int me4000_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int me4000_detach(struct comedi_device *dev);
 static struct comedi_driver driver_me4000 = {
-      driver_name:"me4000",
-      module : THIS_MODULE,
-      attach : me4000_attach,
-      detach : me4000_detach,
+driver_name:"me4000",
+module:THIS_MODULE,
+attach:me4000_attach,
+detach:me4000_detach,
 };
 
 /*-----------------------------------------------------------------------------
@@ -133,7 +131,8 @@ static struct comedi_driver driver_me400
   ---------------------------------------------------------------------------*/
 static int me4000_probe(struct comedi_device *dev, struct comedi_devconfig *it);
 static int get_registers(struct comedi_device *dev, struct pci_dev *pci_dev_p);
-static int init_board_info(struct comedi_device *dev, struct pci_dev *pci_dev_p);
+static int init_board_info(struct comedi_device *dev,
+			   struct pci_dev *pci_dev_p);
 static int init_ao_context(struct comedi_device *dev);
 static int init_ai_context(struct comedi_device *dev);
 static int init_dio_context(struct comedi_device *dev);
@@ -142,80 +141,95 @@ static int xilinx_download(struct comedi
 static int reset_board(struct comedi_device *dev);
 
 static int me4000_dio_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 
 static int me4000_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
 
 static int cnt_reset(struct comedi_device *dev, unsigned int channel);
 
 static int cnt_config(struct comedi_device *dev,
-	unsigned int channel, unsigned int mode);
+		      unsigned int channel, unsigned int mode);
 
 static int me4000_cnt_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
 
 static int me4000_cnt_insn_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
 
 static int me4000_cnt_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 
 static int me4000_ai_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *subdevice, struct comedi_insn *insn, unsigned int *data);
+			       struct comedi_subdevice *subdevice,
+			       struct comedi_insn *insn, unsigned int *data);
 
-static int me4000_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int me4000_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
 
 static int ai_check_chanlist(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd);
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 
 static int ai_round_cmd_args(struct comedi_device *dev,
-	struct comedi_subdevice *s,
-	struct comedi_cmd *cmd,
-	unsigned int *init_ticks,
-	unsigned int *scan_ticks, unsigned int *chan_ticks);
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd,
+			     unsigned int *init_ticks,
+			     unsigned int *scan_ticks,
+			     unsigned int *chan_ticks);
 
 static int ai_prepare(struct comedi_device *dev,
-	struct comedi_subdevice *s,
-	struct comedi_cmd *cmd,
-	unsigned int init_ticks,
-	unsigned int scan_ticks, unsigned int chan_ticks);
+		      struct comedi_subdevice *s,
+		      struct comedi_cmd *cmd,
+		      unsigned int init_ticks,
+		      unsigned int scan_ticks, unsigned int chan_ticks);
 
 static int ai_write_chanlist(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd);
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 
 static irqreturn_t me4000_ai_isr(int irq, void *dev_id);
 
 static int me4000_ai_do_cmd_test(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd);
+				 struct comedi_subdevice *s,
+				 struct comedi_cmd *cmd);
 
-static int me4000_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int me4000_ai_do_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
 
 static int me4000_ao_insn_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 
 static int me4000_ao_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 /*-----------------------------------------------------------------------------
   Meilhaus inline functions
   ---------------------------------------------------------------------------*/
 
 static inline void me4000_outb(struct comedi_device *dev, unsigned char value,
-	unsigned long port)
+			       unsigned long port)
 {
 	PORT_PDEBUG("--> 0x%02X port 0x%04lX\n", value, port);
 	outb(value, port);
 }
 
 static inline void me4000_outl(struct comedi_device *dev, unsigned long value,
-	unsigned long port)
+			       unsigned long port)
 {
 	PORT_PDEBUG("--> 0x%08lX port 0x%04lX\n", value, port);
 	outl(value, port);
 }
 
-static inline unsigned long me4000_inl(struct comedi_device *dev, unsigned long port)
+static inline unsigned long me4000_inl(struct comedi_device *dev,
+				       unsigned long port)
 {
 	unsigned long value;
 	value = inl(port);
@@ -223,7 +237,8 @@ static inline unsigned long me4000_inl(s
 	return value;
 }
 
-static inline unsigned char me4000_inb(struct comedi_device *dev, unsigned long port)
+static inline unsigned char me4000_inb(struct comedi_device *dev,
+				       unsigned long port)
 {
 	unsigned char value;
 	value = inb(port);
@@ -234,18 +249,18 @@ static inline unsigned char me4000_inb(s
 static const struct comedi_lrange me4000_ai_range = {
 	4,
 	{
-			UNI_RANGE(2.5),
-			UNI_RANGE(10),
-			BIP_RANGE(2.5),
-			BIP_RANGE(10),
-		}
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(10),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(10),
+	 }
 };
 
 static const struct comedi_lrange me4000_ao_range = {
 	1,
 	{
-			BIP_RANGE(10),
-		}
+	 BIP_RANGE(10),
+	 }
 };
 
 static int me4000_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -276,7 +291,7 @@ static int me4000_attach(struct comedi_d
 	if (thisboard->ai.count) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags =
-			SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
+		    SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
 		s->n_chan = thisboard->ai.count;
 		s->maxdata = 0xFFFF;	/*  16 bit ADC */
 		s->len_chanlist = ME4000_AI_CHANNEL_LIST_COUNT;
@@ -286,7 +301,9 @@ static int me4000_attach(struct comedi_d
 		if (info->irq > 0) {
 			if (request_irq(info->irq, me4000_ai_isr,
 					IRQF_SHARED, "ME-4000", dev)) {
-				printk("comedi%d: me4000: me4000_attach(): Unable to allocate irq\n", dev->minor);
+				printk
+				    ("comedi%d: me4000: me4000_attach(): Unable to allocate irq\n",
+				     dev->minor);
 			} else {
 				dev->read_subdev = s;
 				s->subdev_flags |= SDF_CMD_READ;
@@ -296,8 +313,8 @@ static int me4000_attach(struct comedi_d
 			}
 		} else {
 			printk(KERN_WARNING
-				"comedi%d: me4000: me4000_attach(): No interrupt available\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_attach(): No interrupt available\n",
+			       dev->minor);
 		}
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
@@ -346,7 +363,7 @@ static int me4000_attach(struct comedi_d
 	if (!me4000_inl(dev, info->dio_context.dir_reg)) {
 		s->io_bits |= 0xFF;
 		me4000_outl(dev, ME4000_DIO_CTRL_BIT_MODE_0,
-			info->dio_context.dir_reg);
+			    info->dio_context.dir_reg);
 	}
 
     /*=========================================================================
@@ -386,28 +403,28 @@ static int me4000_probe(struct comedi_de
 	 * Probe the device to determine what device in the series it is.
 	 */
 	for (pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pci_device != NULL;
-		pci_device =
-		pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_device)) {
+	     pci_device != NULL;
+	     pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_device)) {
 		if (pci_device->vendor == PCI_VENDOR_ID_MEILHAUS) {
 			for (i = 0; i < ME4000_BOARD_VERSIONS; i++) {
 				if (me4000_boards[i].device_id ==
-					pci_device->device) {
+				    pci_device->device) {
 					/* Was a particular bus/slot requested? */
 					if ((it->options[0] != 0)
-						|| (it->options[1] != 0)) {
+					    || (it->options[1] != 0)) {
 						/* Are we on the wrong bus/slot? */
 						if (pci_device->bus->number !=
-							it->options[0]
-							|| PCI_SLOT(pci_device->
-								devfn) !=
-							it->options[1]) {
+						    it->options[0]
+						    ||
+						    PCI_SLOT(pci_device->devfn)
+						    != it->options[1]) {
 							continue;
 						}
 					}
 					dev->board_ptr = me4000_boards + i;
-					board = (struct me4000_board *) dev->
-						board_ptr;
+					board =
+					    (struct me4000_board *)
+					    dev->board_ptr;
 					info->pci_dev_p = pci_device;
 					goto found;
 				}
@@ -416,16 +433,16 @@ static int me4000_probe(struct comedi_de
 	}
 
 	printk(KERN_ERR
-		"comedi%d: me4000: me4000_probe(): No supported board found (req. bus/slot : %d/%d)\n",
-		dev->minor, it->options[0], it->options[1]);
+	       "comedi%d: me4000: me4000_probe(): No supported board found (req. bus/slot : %d/%d)\n",
+	       dev->minor, it->options[0], it->options[1]);
 	return -ENODEV;
 
-      found:
+found:
 
 	printk(KERN_INFO
-		"comedi%d: me4000: me4000_probe(): Found %s at PCI bus %d, slot %d\n",
-		dev->minor, me4000_boards[i].name, pci_device->bus->number,
-		PCI_SLOT(pci_device->devfn));
+	       "comedi%d: me4000: me4000_probe(): Found %s at PCI bus %d, slot %d\n",
+	       dev->minor, me4000_boards[i].name, pci_device->bus->number,
+	       PCI_SLOT(pci_device->devfn));
 
 	/* Set data in device structure */
 	dev->board_name = board->name;
@@ -434,8 +451,8 @@ static int me4000_probe(struct comedi_de
 	result = comedi_pci_enable(pci_device, dev->board_name);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Cannot enable PCI device and request I/O regions\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Cannot enable PCI device and request I/O regions\n",
+		       dev->minor);
 		return result;
 	}
 
@@ -443,16 +460,16 @@ static int me4000_probe(struct comedi_de
 	result = get_registers(dev, pci_device);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Cannot get registers\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Cannot get registers\n",
+		       dev->minor);
 		return result;
 	}
 	/* Initialize board info */
 	result = init_board_info(dev, pci_device);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Cannot init baord info\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Cannot init baord info\n",
+		       dev->minor);
 		return result;
 	}
 
@@ -460,8 +477,8 @@ static int me4000_probe(struct comedi_de
 	result = init_ao_context(dev);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Cannot init ao context\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Cannot init ao context\n",
+		       dev->minor);
 		return result;
 	}
 
@@ -469,8 +486,8 @@ static int me4000_probe(struct comedi_de
 	result = init_ai_context(dev);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Cannot init ai context\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Cannot init ai context\n",
+		       dev->minor);
 		return result;
 	}
 
@@ -478,8 +495,8 @@ static int me4000_probe(struct comedi_de
 	result = init_dio_context(dev);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Cannot init dio context\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Cannot init dio context\n",
+		       dev->minor);
 		return result;
 	}
 
@@ -487,8 +504,8 @@ static int me4000_probe(struct comedi_de
 	result = init_cnt_context(dev);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Cannot init cnt context\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Cannot init cnt context\n",
+		       dev->minor);
 		return result;
 	}
 
@@ -496,8 +513,8 @@ static int me4000_probe(struct comedi_de
 	result = xilinx_download(dev);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Can't download firmware\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Can't download firmware\n",
+		       dev->minor);
 		return result;
 	}
 
@@ -505,8 +522,8 @@ static int me4000_probe(struct comedi_de
 	result = reset_board(dev);
 	if (result) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_probe(): Can't reset board\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_probe(): Can't reset board\n",
+		       dev->minor);
 		return result;
 	}
 
@@ -523,8 +540,8 @@ static int get_registers(struct comedi_d
 	info->plx_regbase = pci_resource_start(pci_dev_p, 1);
 	if (info->plx_regbase == 0) {
 		printk(KERN_ERR
-			"comedi%d: me4000: get_registers(): PCI base address 1 is not available\n",
-			dev->minor);
+		       "comedi%d: me4000: get_registers(): PCI base address 1 is not available\n",
+		       dev->minor);
 		return -ENODEV;
 	}
 	info->plx_regbase_size = pci_resource_len(pci_dev_p, 1);
@@ -534,8 +551,8 @@ static int get_registers(struct comedi_d
 	info->me4000_regbase = pci_resource_start(pci_dev_p, 2);
 	if (info->me4000_regbase == 0) {
 		printk(KERN_ERR
-			"comedi%d: me4000: get_registers(): PCI base address 2 is not available\n",
-			dev->minor);
+		       "comedi%d: me4000: get_registers(): PCI base address 2 is not available\n",
+		       dev->minor);
 		return -ENODEV;
 	}
 	info->me4000_regbase_size = pci_resource_len(pci_dev_p, 2);
@@ -545,8 +562,8 @@ static int get_registers(struct comedi_d
 	info->timer_regbase = pci_resource_start(pci_dev_p, 3);
 	if (info->timer_regbase == 0) {
 		printk(KERN_ERR
-			"comedi%d: me4000: get_registers(): PCI base address 3 is not available\n",
-			dev->minor);
+		       "comedi%d: me4000: get_registers(): PCI base address 3 is not available\n",
+		       dev->minor);
 		return -ENODEV;
 	}
 	info->timer_regbase_size = pci_resource_len(pci_dev_p, 3);
@@ -556,8 +573,8 @@ static int get_registers(struct comedi_d
 	info->program_regbase = pci_resource_start(pci_dev_p, 5);
 	if (info->program_regbase == 0) {
 		printk(KERN_ERR
-			"comedi%d: me4000: get_registers(): PCI base address 5 is not available\n",
-			dev->minor);
+		       "comedi%d: me4000: get_registers(): PCI base address 5 is not available\n",
+		       dev->minor);
 		return -ENODEV;
 	}
 	info->program_regbase_size = pci_resource_len(pci_dev_p, 5);
@@ -610,67 +627,67 @@ static int init_ao_context(struct comedi
 		switch (i) {
 		case 0:
 			info->ao_context[i].ctrl_reg =
-				info->me4000_regbase + ME4000_AO_00_CTRL_REG;
+			    info->me4000_regbase + ME4000_AO_00_CTRL_REG;
 			info->ao_context[i].status_reg =
-				info->me4000_regbase + ME4000_AO_00_STATUS_REG;
+			    info->me4000_regbase + ME4000_AO_00_STATUS_REG;
 			info->ao_context[i].fifo_reg =
-				info->me4000_regbase + ME4000_AO_00_FIFO_REG;
+			    info->me4000_regbase + ME4000_AO_00_FIFO_REG;
 			info->ao_context[i].single_reg =
-				info->me4000_regbase + ME4000_AO_00_SINGLE_REG;
+			    info->me4000_regbase + ME4000_AO_00_SINGLE_REG;
 			info->ao_context[i].timer_reg =
-				info->me4000_regbase + ME4000_AO_00_TIMER_REG;
+			    info->me4000_regbase + ME4000_AO_00_TIMER_REG;
 			info->ao_context[i].irq_status_reg =
-				info->me4000_regbase + ME4000_IRQ_STATUS_REG;
+			    info->me4000_regbase + ME4000_IRQ_STATUS_REG;
 			info->ao_context[i].preload_reg =
-				info->me4000_regbase + ME4000_AO_LOADSETREG_XX;
+			    info->me4000_regbase + ME4000_AO_LOADSETREG_XX;
 			break;
 		case 1:
 			info->ao_context[i].ctrl_reg =
-				info->me4000_regbase + ME4000_AO_01_CTRL_REG;
+			    info->me4000_regbase + ME4000_AO_01_CTRL_REG;
 			info->ao_context[i].status_reg =
-				info->me4000_regbase + ME4000_AO_01_STATUS_REG;
+			    info->me4000_regbase + ME4000_AO_01_STATUS_REG;
 			info->ao_context[i].fifo_reg =
-				info->me4000_regbase + ME4000_AO_01_FIFO_REG;
+			    info->me4000_regbase + ME4000_AO_01_FIFO_REG;
 			info->ao_context[i].single_reg =
-				info->me4000_regbase + ME4000_AO_01_SINGLE_REG;
+			    info->me4000_regbase + ME4000_AO_01_SINGLE_REG;
 			info->ao_context[i].timer_reg =
-				info->me4000_regbase + ME4000_AO_01_TIMER_REG;
+			    info->me4000_regbase + ME4000_AO_01_TIMER_REG;
 			info->ao_context[i].irq_status_reg =
-				info->me4000_regbase + ME4000_IRQ_STATUS_REG;
+			    info->me4000_regbase + ME4000_IRQ_STATUS_REG;
 			info->ao_context[i].preload_reg =
-				info->me4000_regbase + ME4000_AO_LOADSETREG_XX;
+			    info->me4000_regbase + ME4000_AO_LOADSETREG_XX;
 			break;
 		case 2:
 			info->ao_context[i].ctrl_reg =
-				info->me4000_regbase + ME4000_AO_02_CTRL_REG;
+			    info->me4000_regbase + ME4000_AO_02_CTRL_REG;
 			info->ao_context[i].status_reg =
-				info->me4000_regbase + ME4000_AO_02_STATUS_REG;
+			    info->me4000_regbase + ME4000_AO_02_STATUS_REG;
 			info->ao_context[i].fifo_reg =
-				info->me4000_regbase + ME4000_AO_02_FIFO_REG;
+			    info->me4000_regbase + ME4000_AO_02_FIFO_REG;
 			info->ao_context[i].single_reg =
-				info->me4000_regbase + ME4000_AO_02_SINGLE_REG;
+			    info->me4000_regbase + ME4000_AO_02_SINGLE_REG;
 			info->ao_context[i].timer_reg =
-				info->me4000_regbase + ME4000_AO_02_TIMER_REG;
+			    info->me4000_regbase + ME4000_AO_02_TIMER_REG;
 			info->ao_context[i].irq_status_reg =
-				info->me4000_regbase + ME4000_IRQ_STATUS_REG;
+			    info->me4000_regbase + ME4000_IRQ_STATUS_REG;
 			info->ao_context[i].preload_reg =
-				info->me4000_regbase + ME4000_AO_LOADSETREG_XX;
+			    info->me4000_regbase + ME4000_AO_LOADSETREG_XX;
 			break;
 		case 3:
 			info->ao_context[i].ctrl_reg =
-				info->me4000_regbase + ME4000_AO_03_CTRL_REG;
+			    info->me4000_regbase + ME4000_AO_03_CTRL_REG;
 			info->ao_context[i].status_reg =
-				info->me4000_regbase + ME4000_AO_03_STATUS_REG;
+			    info->me4000_regbase + ME4000_AO_03_STATUS_REG;
 			info->ao_context[i].fifo_reg =
-				info->me4000_regbase + ME4000_AO_03_FIFO_REG;
+			    info->me4000_regbase + ME4000_AO_03_FIFO_REG;
 			info->ao_context[i].single_reg =
-				info->me4000_regbase + ME4000_AO_03_SINGLE_REG;
+			    info->me4000_regbase + ME4000_AO_03_SINGLE_REG;
 			info->ao_context[i].timer_reg =
-				info->me4000_regbase + ME4000_AO_03_TIMER_REG;
+			    info->me4000_regbase + ME4000_AO_03_TIMER_REG;
 			info->ao_context[i].irq_status_reg =
-				info->me4000_regbase + ME4000_IRQ_STATUS_REG;
+			    info->me4000_regbase + ME4000_IRQ_STATUS_REG;
 			info->ao_context[i].preload_reg =
-				info->me4000_regbase + ME4000_AO_LOADSETREG_XX;
+			    info->me4000_regbase + ME4000_AO_LOADSETREG_XX;
 			break;
 		default:
 			break;
@@ -689,27 +706,27 @@ static int init_ai_context(struct comedi
 
 	info->ai_context.ctrl_reg = info->me4000_regbase + ME4000_AI_CTRL_REG;
 	info->ai_context.status_reg =
-		info->me4000_regbase + ME4000_AI_STATUS_REG;
+	    info->me4000_regbase + ME4000_AI_STATUS_REG;
 	info->ai_context.channel_list_reg =
-		info->me4000_regbase + ME4000_AI_CHANNEL_LIST_REG;
+	    info->me4000_regbase + ME4000_AI_CHANNEL_LIST_REG;
 	info->ai_context.data_reg = info->me4000_regbase + ME4000_AI_DATA_REG;
 	info->ai_context.chan_timer_reg =
-		info->me4000_regbase + ME4000_AI_CHAN_TIMER_REG;
+	    info->me4000_regbase + ME4000_AI_CHAN_TIMER_REG;
 	info->ai_context.chan_pre_timer_reg =
-		info->me4000_regbase + ME4000_AI_CHAN_PRE_TIMER_REG;
+	    info->me4000_regbase + ME4000_AI_CHAN_PRE_TIMER_REG;
 	info->ai_context.scan_timer_low_reg =
-		info->me4000_regbase + ME4000_AI_SCAN_TIMER_LOW_REG;
+	    info->me4000_regbase + ME4000_AI_SCAN_TIMER_LOW_REG;
 	info->ai_context.scan_timer_high_reg =
-		info->me4000_regbase + ME4000_AI_SCAN_TIMER_HIGH_REG;
+	    info->me4000_regbase + ME4000_AI_SCAN_TIMER_HIGH_REG;
 	info->ai_context.scan_pre_timer_low_reg =
-		info->me4000_regbase + ME4000_AI_SCAN_PRE_TIMER_LOW_REG;
+	    info->me4000_regbase + ME4000_AI_SCAN_PRE_TIMER_LOW_REG;
 	info->ai_context.scan_pre_timer_high_reg =
-		info->me4000_regbase + ME4000_AI_SCAN_PRE_TIMER_HIGH_REG;
+	    info->me4000_regbase + ME4000_AI_SCAN_PRE_TIMER_HIGH_REG;
 	info->ai_context.start_reg = info->me4000_regbase + ME4000_AI_START_REG;
 	info->ai_context.irq_status_reg =
-		info->me4000_regbase + ME4000_IRQ_STATUS_REG;
+	    info->me4000_regbase + ME4000_IRQ_STATUS_REG;
 	info->ai_context.sample_counter_reg =
-		info->me4000_regbase + ME4000_AI_SAMPLE_COUNTER_REG;
+	    info->me4000_regbase + ME4000_AI_SAMPLE_COUNTER_REG;
 
 	return 0;
 }
@@ -722,13 +739,13 @@ static int init_dio_context(struct comed
 	info->dio_context.dir_reg = info->me4000_regbase + ME4000_DIO_DIR_REG;
 	info->dio_context.ctrl_reg = info->me4000_regbase + ME4000_DIO_CTRL_REG;
 	info->dio_context.port_0_reg =
-		info->me4000_regbase + ME4000_DIO_PORT_0_REG;
+	    info->me4000_regbase + ME4000_DIO_PORT_0_REG;
 	info->dio_context.port_1_reg =
-		info->me4000_regbase + ME4000_DIO_PORT_1_REG;
+	    info->me4000_regbase + ME4000_DIO_PORT_1_REG;
 	info->dio_context.port_2_reg =
-		info->me4000_regbase + ME4000_DIO_PORT_2_REG;
+	    info->me4000_regbase + ME4000_DIO_PORT_2_REG;
 	info->dio_context.port_3_reg =
-		info->me4000_regbase + ME4000_DIO_PORT_3_REG;
+	    info->me4000_regbase + ME4000_DIO_PORT_3_REG;
 
 	return 0;
 }
@@ -740,11 +757,11 @@ static int init_cnt_context(struct comed
 
 	info->cnt_context.ctrl_reg = info->timer_regbase + ME4000_CNT_CTRL_REG;
 	info->cnt_context.counter_0_reg =
-		info->timer_regbase + ME4000_CNT_COUNTER_0_REG;
+	    info->timer_regbase + ME4000_CNT_COUNTER_0_REG;
 	info->cnt_context.counter_1_reg =
-		info->timer_regbase + ME4000_CNT_COUNTER_1_REG;
+	    info->timer_regbase + ME4000_CNT_COUNTER_1_REG;
 	info->cnt_context.counter_2_reg =
-		info->timer_regbase + ME4000_CNT_COUNTER_2_REG;
+	    info->timer_regbase + ME4000_CNT_COUNTER_2_REG;
 
 	return 0;
 }
@@ -783,8 +800,8 @@ static int xilinx_download(struct comedi
 	udelay(20);
 	if (!(inl(info->plx_regbase + PLX_INTCSR) & 0x20)) {
 		printk(KERN_ERR
-			"comedi%d: me4000: xilinx_download(): Can't init Xilinx\n",
-			dev->minor);
+		       "comedi%d: me4000: xilinx_download(): Can't init Xilinx\n",
+		       dev->minor);
 		return -EIO;
 	}
 
@@ -794,12 +811,12 @@ static int xilinx_download(struct comedi
 	outl(value, info->plx_regbase + PLX_ICR);
 	if (FIRMWARE_NOT_AVAILABLE) {
 		comedi_error(dev,
-			"xilinx firmware unavailable due to licensing, aborting");
+			     "xilinx firmware unavailable due to licensing, aborting");
 		return -EIO;
 	} else {
 		/* Download Xilinx firmware */
 		size = (xilinx_firm[0] << 24) + (xilinx_firm[1] << 16) +
-			(xilinx_firm[2] << 8) + xilinx_firm[3];
+		    (xilinx_firm[2] << 8) + xilinx_firm[3];
 		udelay(10);
 
 		for (idx = 0; idx < size; idx++) {
@@ -809,8 +826,8 @@ static int xilinx_download(struct comedi
 			/* Check if BUSY flag is low */
 			if (inl(info->plx_regbase + PLX_ICR) & 0x20) {
 				printk(KERN_ERR
-					"comedi%d: me4000: xilinx_download(): Xilinx is still busy (idx = %d)\n",
-					dev->minor, idx);
+				       "comedi%d: me4000: xilinx_download(): Xilinx is still busy (idx = %d)\n",
+				       dev->minor, idx);
 				return -EIO;
 			}
 		}
@@ -820,11 +837,11 @@ static int xilinx_download(struct comedi
 	if (inl(info->plx_regbase + PLX_ICR) & 0x4) {
 	} else {
 		printk(KERN_ERR
-			"comedi%d: me4000: xilinx_download(): DONE flag is not set\n",
-			dev->minor);
+		       "comedi%d: me4000: xilinx_download(): DONE flag is not set\n",
+		       dev->minor);
 		printk(KERN_ERR
-			"comedi%d: me4000: xilinx_download(): Download not succesful\n",
-			dev->minor);
+		       "comedi%d: me4000: xilinx_download(): Download not succesful\n",
+		       dev->minor);
 		return -EIO;
 	}
 
@@ -851,44 +868,44 @@ static int reset_board(struct comedi_dev
 
 	/* 0x8000 to the DACs means an output voltage of 0V */
 	me4000_outl(dev, 0x8000,
-		info->me4000_regbase + ME4000_AO_00_SINGLE_REG);
+		    info->me4000_regbase + ME4000_AO_00_SINGLE_REG);
 	me4000_outl(dev, 0x8000,
-		info->me4000_regbase + ME4000_AO_01_SINGLE_REG);
+		    info->me4000_regbase + ME4000_AO_01_SINGLE_REG);
 	me4000_outl(dev, 0x8000,
-		info->me4000_regbase + ME4000_AO_02_SINGLE_REG);
+		    info->me4000_regbase + ME4000_AO_02_SINGLE_REG);
 	me4000_outl(dev, 0x8000,
-		info->me4000_regbase + ME4000_AO_03_SINGLE_REG);
+		    info->me4000_regbase + ME4000_AO_03_SINGLE_REG);
 
 	/* Set both stop bits in the analog input control register */
 	me4000_outl(dev,
-		ME4000_AI_CTRL_BIT_IMMEDIATE_STOP | ME4000_AI_CTRL_BIT_STOP,
-		info->me4000_regbase + ME4000_AI_CTRL_REG);
+		    ME4000_AI_CTRL_BIT_IMMEDIATE_STOP | ME4000_AI_CTRL_BIT_STOP,
+		    info->me4000_regbase + ME4000_AI_CTRL_REG);
 
 	/* Set both stop bits in the analog output control register */
 	me4000_outl(dev,
-		ME4000_AO_CTRL_BIT_IMMEDIATE_STOP | ME4000_AO_CTRL_BIT_STOP,
-		info->me4000_regbase + ME4000_AO_00_CTRL_REG);
+		    ME4000_AO_CTRL_BIT_IMMEDIATE_STOP | ME4000_AO_CTRL_BIT_STOP,
+		    info->me4000_regbase + ME4000_AO_00_CTRL_REG);
 	me4000_outl(dev,
-		ME4000_AO_CTRL_BIT_IMMEDIATE_STOP | ME4000_AO_CTRL_BIT_STOP,
-		info->me4000_regbase + ME4000_AO_01_CTRL_REG);
+		    ME4000_AO_CTRL_BIT_IMMEDIATE_STOP | ME4000_AO_CTRL_BIT_STOP,
+		    info->me4000_regbase + ME4000_AO_01_CTRL_REG);
 	me4000_outl(dev,
-		ME4000_AO_CTRL_BIT_IMMEDIATE_STOP | ME4000_AO_CTRL_BIT_STOP,
-		info->me4000_regbase + ME4000_AO_02_CTRL_REG);
+		    ME4000_AO_CTRL_BIT_IMMEDIATE_STOP | ME4000_AO_CTRL_BIT_STOP,
+		    info->me4000_regbase + ME4000_AO_02_CTRL_REG);
 	me4000_outl(dev,
-		ME4000_AO_CTRL_BIT_IMMEDIATE_STOP | ME4000_AO_CTRL_BIT_STOP,
-		info->me4000_regbase + ME4000_AO_03_CTRL_REG);
+		    ME4000_AO_CTRL_BIT_IMMEDIATE_STOP | ME4000_AO_CTRL_BIT_STOP,
+		    info->me4000_regbase + ME4000_AO_03_CTRL_REG);
 
 	/* Enable interrupts on the PLX */
 	me4000_outl(dev, 0x43, info->plx_regbase + PLX_INTCSR);
 
 	/* Set the adustment register for AO demux */
 	me4000_outl(dev, ME4000_AO_DEMUX_ADJUST_VALUE,
-		info->me4000_regbase + ME4000_AO_DEMUX_ADJUST_REG);
+		    info->me4000_regbase + ME4000_AO_DEMUX_ADJUST_REG);
 
 	/* Set digital I/O direction for port 0 to output on isolated versions */
 	if (!(me4000_inl(dev, info->me4000_regbase + ME4000_DIO_DIR_REG) & 0x1)) {
 		me4000_outl(dev, 0x1,
-			info->me4000_regbase + ME4000_DIO_CTRL_REG);
+			    info->me4000_regbase + ME4000_DIO_CTRL_REG);
 	}
 
 	return 0;
@@ -915,7 +932,8 @@ static int me4000_detach(struct comedi_d
   ===========================================================================*/
 
 static int me4000_ai_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *subdevice, struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_subdevice *subdevice,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
 	int chan = CR_CHAN(insn->chanspec);
@@ -932,8 +950,8 @@ static int me4000_ai_insn_read(struct co
 		return 0;
 	} else if (insn->n > 1) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_insn_read(): Invalid instruction length %d\n",
-			dev->minor, insn->n);
+		       "comedi%d: me4000: me4000_ai_insn_read(): Invalid instruction length %d\n",
+		       dev->minor, insn->n);
 		return -EINVAL;
 	}
 
@@ -952,8 +970,8 @@ static int me4000_ai_insn_read(struct co
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_insn_read(): Invalid range specified\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_insn_read(): Invalid range specified\n",
+		       dev->minor);
 		return -EINVAL;
 	}
 
@@ -962,8 +980,8 @@ static int me4000_ai_insn_read(struct co
 	case AREF_COMMON:
 		if (chan >= thisboard->ai.count) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_insn_read(): Analog input is not available\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_insn_read(): Analog input is not available\n",
+			       dev->minor);
 			return -EINVAL;
 		}
 		entry |= ME4000_AI_LIST_INPUT_SINGLE_ENDED | chan;
@@ -972,23 +990,23 @@ static int me4000_ai_insn_read(struct co
 	case AREF_DIFF:
 		if (rang == 0 || rang == 1) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_insn_read(): Range must be bipolar when aref = diff\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_insn_read(): Range must be bipolar when aref = diff\n",
+			       dev->minor);
 			return -EINVAL;
 		}
 
 		if (chan >= thisboard->ai.diff_count) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_insn_read(): Analog input is not available\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_insn_read(): Analog input is not available\n",
+			       dev->minor);
 			return -EINVAL;
 		}
 		entry |= ME4000_AI_LIST_INPUT_DIFFERENTIAL | chan;
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_insn_read(): Invalid aref specified\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_insn_read(): Invalid aref specified\n",
+		       dev->minor);
 		return -EINVAL;
 	}
 
@@ -997,13 +1015,13 @@ static int me4000_ai_insn_read(struct co
 	/* Clear channel list, data fifo and both stop bits */
 	tmp = me4000_inl(dev, info->ai_context.ctrl_reg);
 	tmp &= ~(ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
-		ME4000_AI_CTRL_BIT_DATA_FIFO |
-		ME4000_AI_CTRL_BIT_STOP | ME4000_AI_CTRL_BIT_IMMEDIATE_STOP);
+		 ME4000_AI_CTRL_BIT_DATA_FIFO |
+		 ME4000_AI_CTRL_BIT_STOP | ME4000_AI_CTRL_BIT_IMMEDIATE_STOP);
 	me4000_outl(dev, tmp, info->ai_context.ctrl_reg);
 
 	/* Set the acquisition mode to single */
 	tmp &= ~(ME4000_AI_CTRL_BIT_MODE_0 | ME4000_AI_CTRL_BIT_MODE_1 |
-		ME4000_AI_CTRL_BIT_MODE_2);
+		 ME4000_AI_CTRL_BIT_MODE_2);
 	me4000_outl(dev, tmp, info->ai_context.ctrl_reg);
 
 	/* Enable channel list and data fifo */
@@ -1016,18 +1034,19 @@ static int me4000_ai_insn_read(struct co
 	/* Set the timer to maximum sample rate */
 	me4000_outl(dev, ME4000_AI_MIN_TICKS, info->ai_context.chan_timer_reg);
 	me4000_outl(dev, ME4000_AI_MIN_TICKS,
-		info->ai_context.chan_pre_timer_reg);
+		    info->ai_context.chan_pre_timer_reg);
 
 	/* Start conversion by dummy read */
 	me4000_inl(dev, info->ai_context.start_reg);
 
 	/* Wait until ready */
 	udelay(10);
-	if (!(me4000_inl(dev, info->ai_context.
-				status_reg) & ME4000_AI_STATUS_BIT_EF_DATA)) {
+	if (!
+	    (me4000_inl(dev, info->ai_context.status_reg) &
+	     ME4000_AI_STATUS_BIT_EF_DATA)) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_insn_read(): Value not available after wait\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_insn_read(): Value not available after wait\n",
+		       dev->minor);
 		return -EIO;
 	}
 
@@ -1038,7 +1057,8 @@ static int me4000_ai_insn_read(struct co
 	return 1;
 }
 
-static int me4000_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int me4000_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	unsigned long tmp;
 
@@ -1056,7 +1076,7 @@ static int me4000_ai_cancel(struct comed
 }
 
 static int ai_check_chanlist(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd)
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int aref;
 	int i;
@@ -1066,24 +1086,24 @@ static int ai_check_chanlist(struct come
 	/* Check whether a channel list is available */
 	if (!cmd->chanlist_len) {
 		printk(KERN_ERR
-			"comedi%d: me4000: ai_check_chanlist(): No channel list available\n",
-			dev->minor);
+		       "comedi%d: me4000: ai_check_chanlist(): No channel list available\n",
+		       dev->minor);
 		return -EINVAL;
 	}
 
 	/* Check the channel list size */
 	if (cmd->chanlist_len > ME4000_AI_CHANNEL_LIST_COUNT) {
 		printk(KERN_ERR
-			"comedi%d: me4000: ai_check_chanlist(): Channel list is to large\n",
-			dev->minor);
+		       "comedi%d: me4000: ai_check_chanlist(): Channel list is to large\n",
+		       dev->minor);
 		return -EINVAL;
 	}
 
 	/* Check the pointer */
 	if (!cmd->chanlist) {
 		printk(KERN_ERR
-			"comedi%d: me4000: ai_check_chanlist(): NULL pointer to channel list\n",
-			dev->minor);
+		       "comedi%d: me4000: ai_check_chanlist(): NULL pointer to channel list\n",
+		       dev->minor);
 		return -EFAULT;
 	}
 
@@ -1092,8 +1112,8 @@ static int ai_check_chanlist(struct come
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		if (CR_AREF(cmd->chanlist[i]) != aref) {
 			printk(KERN_ERR
-				"comedi%d: me4000: ai_check_chanlist(): Mode is not equal for all entries\n",
-				dev->minor);
+			       "comedi%d: me4000: ai_check_chanlist(): Mode is not equal for all entries\n",
+			       dev->minor);
 			return -EINVAL;
 		}
 	}
@@ -1102,10 +1122,10 @@ static int ai_check_chanlist(struct come
 	if (aref == SDF_DIFF) {
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) >=
-				thisboard->ai.diff_count) {
+			    thisboard->ai.diff_count) {
 				printk(KERN_ERR
-					"comedi%d: me4000: ai_check_chanlist(): Channel number to high\n",
-					dev->minor);
+				       "comedi%d: me4000: ai_check_chanlist(): Channel number to high\n",
+				       dev->minor);
 				return -EINVAL;
 			}
 		}
@@ -1113,8 +1133,8 @@ static int ai_check_chanlist(struct come
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) >= thisboard->ai.count) {
 				printk(KERN_ERR
-					"comedi%d: me4000: ai_check_chanlist(): Channel number to high\n",
-					dev->minor);
+				       "comedi%d: me4000: ai_check_chanlist(): Channel number to high\n",
+				       dev->minor);
 				return -EINVAL;
 			}
 		}
@@ -1124,10 +1144,10 @@ static int ai_check_chanlist(struct come
 	if (aref == SDF_DIFF) {
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			if (CR_RANGE(cmd->chanlist[i]) != 1 &&
-				CR_RANGE(cmd->chanlist[i]) != 2) {
+			    CR_RANGE(cmd->chanlist[i]) != 2) {
 				printk(KERN_ERR
-					"comedi%d: me4000: ai_check_chanlist(): Bipolar is not selected in differential mode\n",
-					dev->minor);
+				       "comedi%d: me4000: ai_check_chanlist(): Bipolar is not selected in differential mode\n",
+				       dev->minor);
 				return -EINVAL;
 			}
 		}
@@ -1137,10 +1157,10 @@ static int ai_check_chanlist(struct come
 }
 
 static int ai_round_cmd_args(struct comedi_device *dev,
-	struct comedi_subdevice *s,
-	struct comedi_cmd *cmd,
-	unsigned int *init_ticks,
-	unsigned int *scan_ticks, unsigned int *chan_ticks)
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd,
+			     unsigned int *init_ticks,
+			     unsigned int *scan_ticks, unsigned int *chan_ticks)
 {
 
 	int rest;
@@ -1153,7 +1173,7 @@ static int ai_round_cmd_args(struct come
 
 	PDEBUG("ai_round_cmd_arg(): start_arg = %d\n", cmd->start_arg);
 	PDEBUG("ai_round_cmd_arg(): scan_begin_arg = %d\n",
-		cmd->scan_begin_arg);
+	       cmd->scan_begin_arg);
 	PDEBUG("ai_round_cmd_arg(): convert_arg = %d\n", cmd->convert_arg);
 
 	if (cmd->start_arg) {
@@ -1203,19 +1223,19 @@ static int ai_round_cmd_args(struct come
 }
 
 static void ai_write_timer(struct comedi_device *dev,
-	unsigned int init_ticks,
-	unsigned int scan_ticks, unsigned int chan_ticks)
+			   unsigned int init_ticks,
+			   unsigned int scan_ticks, unsigned int chan_ticks)
 {
 
 	CALL_PDEBUG("In ai_write_timer()\n");
 
 	me4000_outl(dev, init_ticks - 1,
-		info->ai_context.scan_pre_timer_low_reg);
+		    info->ai_context.scan_pre_timer_low_reg);
 	me4000_outl(dev, 0x0, info->ai_context.scan_pre_timer_high_reg);
 
 	if (scan_ticks) {
 		me4000_outl(dev, scan_ticks - 1,
-			info->ai_context.scan_timer_low_reg);
+			    info->ai_context.scan_timer_low_reg);
 		me4000_outl(dev, 0x0, info->ai_context.scan_timer_high_reg);
 	}
 
@@ -1224,10 +1244,10 @@ static void ai_write_timer(struct comedi
 }
 
 static int ai_prepare(struct comedi_device *dev,
-	struct comedi_subdevice *s,
-	struct comedi_cmd *cmd,
-	unsigned int init_ticks,
-	unsigned int scan_ticks, unsigned int chan_ticks)
+		      struct comedi_subdevice *s,
+		      struct comedi_cmd *cmd,
+		      unsigned int init_ticks,
+		      unsigned int scan_ticks, unsigned int chan_ticks)
 {
 
 	unsigned long tmp = 0;
@@ -1242,42 +1262,42 @@ static int ai_prepare(struct comedi_devi
 
 	/* Start sources */
 	if ((cmd->start_src == TRIG_EXT &&
-			cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->convert_src == TRIG_TIMER) ||
-		(cmd->start_src == TRIG_EXT &&
-			cmd->scan_begin_src == TRIG_FOLLOW &&
-			cmd->convert_src == TRIG_TIMER)) {
+	     cmd->scan_begin_src == TRIG_TIMER &&
+	     cmd->convert_src == TRIG_TIMER) ||
+	    (cmd->start_src == TRIG_EXT &&
+	     cmd->scan_begin_src == TRIG_FOLLOW &&
+	     cmd->convert_src == TRIG_TIMER)) {
 		tmp = ME4000_AI_CTRL_BIT_MODE_1 |
-			ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
-			ME4000_AI_CTRL_BIT_DATA_FIFO;
+		    ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
+		    ME4000_AI_CTRL_BIT_DATA_FIFO;
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_EXT &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_EXT &&
+		   cmd->convert_src == TRIG_TIMER) {
 		tmp = ME4000_AI_CTRL_BIT_MODE_2 |
-			ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
-			ME4000_AI_CTRL_BIT_DATA_FIFO;
+		    ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
+		    ME4000_AI_CTRL_BIT_DATA_FIFO;
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_EXT &&
-		cmd->convert_src == TRIG_EXT) {
+		   cmd->scan_begin_src == TRIG_EXT &&
+		   cmd->convert_src == TRIG_EXT) {
 		tmp = ME4000_AI_CTRL_BIT_MODE_0 |
-			ME4000_AI_CTRL_BIT_MODE_1 |
-			ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
-			ME4000_AI_CTRL_BIT_DATA_FIFO;
+		    ME4000_AI_CTRL_BIT_MODE_1 |
+		    ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
+		    ME4000_AI_CTRL_BIT_DATA_FIFO;
 	} else {
 		tmp = ME4000_AI_CTRL_BIT_MODE_0 |
-			ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
-			ME4000_AI_CTRL_BIT_DATA_FIFO;
+		    ME4000_AI_CTRL_BIT_CHANNEL_FIFO |
+		    ME4000_AI_CTRL_BIT_DATA_FIFO;
 	}
 
 	/* Stop triggers */
 	if (cmd->stop_src == TRIG_COUNT) {
 		me4000_outl(dev, cmd->chanlist_len * cmd->stop_arg,
-			info->ai_context.sample_counter_reg);
+			    info->ai_context.sample_counter_reg);
 		tmp |= ME4000_AI_CTRL_BIT_HF_IRQ | ME4000_AI_CTRL_BIT_SC_IRQ;
 	} else if (cmd->stop_src == TRIG_NONE &&
-		cmd->scan_end_src == TRIG_COUNT) {
+		   cmd->scan_end_src == TRIG_COUNT) {
 		me4000_outl(dev, cmd->scan_end_arg,
-			info->ai_context.sample_counter_reg);
+			    info->ai_context.sample_counter_reg);
 		tmp |= ME4000_AI_CTRL_BIT_HF_IRQ | ME4000_AI_CTRL_BIT_SC_IRQ;
 	} else {
 		tmp |= ME4000_AI_CTRL_BIT_HF_IRQ;
@@ -1293,7 +1313,7 @@ static int ai_prepare(struct comedi_devi
 }
 
 static int ai_write_chanlist(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd)
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	unsigned int entry;
 	unsigned int chan;
@@ -1332,7 +1352,8 @@ static int ai_write_chanlist(struct come
 	return 0;
 }
 
-static int me4000_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int me4000_ai_do_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	int err;
 	unsigned int init_ticks = 0;
@@ -1349,7 +1370,7 @@ static int me4000_ai_do_cmd(struct comed
 
 	/* Round the timer arguments */
 	err = ai_round_cmd_args(dev,
-		s, cmd, &init_ticks, &scan_ticks, &chan_ticks);
+				s, cmd, &init_ticks, &scan_ticks, &chan_ticks);
 	if (err)
 		return err;
 
@@ -1377,7 +1398,8 @@ static int me4000_ai_do_cmd(struct comed
  * So I tried to adopt this scheme.
  */
 static int me4000_ai_do_cmd_test(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd)
+				 struct comedi_subdevice *s,
+				 struct comedi_cmd *cmd)
 {
 
 	unsigned int init_ticks;
@@ -1390,28 +1412,28 @@ static int me4000_ai_do_cmd_test(struct 
 	PDEBUG("me4000_ai_do_cmd_test(): subdev         = %d\n", cmd->subdev);
 	PDEBUG("me4000_ai_do_cmd_test(): flags          = %08X\n", cmd->flags);
 	PDEBUG("me4000_ai_do_cmd_test(): start_src      = %08X\n",
-		cmd->start_src);
+	       cmd->start_src);
 	PDEBUG("me4000_ai_do_cmd_test(): start_arg      = %d\n",
-		cmd->start_arg);
+	       cmd->start_arg);
 	PDEBUG("me4000_ai_do_cmd_test(): scan_begin_src = %08X\n",
-		cmd->scan_begin_src);
+	       cmd->scan_begin_src);
 	PDEBUG("me4000_ai_do_cmd_test(): scan_begin_arg = %d\n",
-		cmd->scan_begin_arg);
+	       cmd->scan_begin_arg);
 	PDEBUG("me4000_ai_do_cmd_test(): convert_src    = %08X\n",
-		cmd->convert_src);
+	       cmd->convert_src);
 	PDEBUG("me4000_ai_do_cmd_test(): convert_arg    = %d\n",
-		cmd->convert_arg);
+	       cmd->convert_arg);
 	PDEBUG("me4000_ai_do_cmd_test(): scan_end_src   = %08X\n",
-		cmd->scan_end_src);
+	       cmd->scan_end_src);
 	PDEBUG("me4000_ai_do_cmd_test(): scan_end_arg   = %d\n",
-		cmd->scan_end_arg);
+	       cmd->scan_end_arg);
 	PDEBUG("me4000_ai_do_cmd_test(): stop_src       = %08X\n",
-		cmd->stop_src);
+	       cmd->stop_src);
 	PDEBUG("me4000_ai_do_cmd_test(): stop_arg       = %d\n", cmd->stop_arg);
 	PDEBUG("me4000_ai_do_cmd_test(): chanlist       = %d\n",
-		(unsigned int)cmd->chanlist);
+	       (unsigned int)cmd->chanlist);
 	PDEBUG("me4000_ai_do_cmd_test(): chanlist_len   = %d\n",
-		cmd->chanlist_len);
+	       cmd->chanlist_len);
 
 	/* Only rounding flags are implemented */
 	cmd->flags &= TRIG_ROUND_NEAREST | TRIG_ROUND_UP | TRIG_ROUND_DOWN;
@@ -1432,8 +1454,8 @@ static int me4000_ai_do_cmd_test(struct 
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start source\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start source\n",
+		       dev->minor);
 		cmd->start_src = TRIG_NOW;
 		err++;
 	}
@@ -1448,8 +1470,8 @@ static int me4000_ai_do_cmd_test(struct 
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan begin source\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan begin source\n",
+		       dev->minor);
 		cmd->scan_begin_src = TRIG_FOLLOW;
 		err++;
 	}
@@ -1463,8 +1485,8 @@ static int me4000_ai_do_cmd_test(struct 
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert source\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert source\n",
+		       dev->minor);
 		cmd->convert_src = TRIG_TIMER;
 		err++;
 	}
@@ -1478,8 +1500,8 @@ static int me4000_ai_do_cmd_test(struct 
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end source\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end source\n",
+		       dev->minor);
 		cmd->scan_end_src = TRIG_NONE;
 		err++;
 	}
@@ -1493,8 +1515,8 @@ static int me4000_ai_do_cmd_test(struct 
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid stop source\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid stop source\n",
+		       dev->minor);
 		cmd->stop_src = TRIG_NONE;
 		err++;
 	}
@@ -1505,27 +1527,27 @@ static int me4000_ai_do_cmd_test(struct 
 	 * Stage 2. Check for trigger source conflicts.
 	 */
 	if (cmd->start_src == TRIG_NOW &&
-		cmd->scan_begin_src == TRIG_TIMER &&
-		cmd->convert_src == TRIG_TIMER) {
+	    cmd->scan_begin_src == TRIG_TIMER &&
+	    cmd->convert_src == TRIG_TIMER) {
 	} else if (cmd->start_src == TRIG_NOW &&
-		cmd->scan_begin_src == TRIG_FOLLOW &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_FOLLOW &&
+		   cmd->convert_src == TRIG_TIMER) {
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_TIMER &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_TIMER &&
+		   cmd->convert_src == TRIG_TIMER) {
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_FOLLOW &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_FOLLOW &&
+		   cmd->convert_src == TRIG_TIMER) {
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_EXT &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_EXT &&
+		   cmd->convert_src == TRIG_TIMER) {
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_EXT &&
-		cmd->convert_src == TRIG_EXT) {
+		   cmd->scan_begin_src == TRIG_EXT &&
+		   cmd->convert_src == TRIG_EXT) {
 	} else {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start trigger combination\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start trigger combination\n",
+		       dev->minor);
 		cmd->start_src = TRIG_NOW;
 		cmd->scan_begin_src = TRIG_FOLLOW;
 		cmd->convert_src = TRIG_TIMER;
@@ -1534,15 +1556,15 @@ static int me4000_ai_do_cmd_test(struct 
 
 	if (cmd->stop_src == TRIG_NONE && cmd->scan_end_src == TRIG_NONE) {
 	} else if (cmd->stop_src == TRIG_COUNT &&
-		cmd->scan_end_src == TRIG_NONE) {
+		   cmd->scan_end_src == TRIG_NONE) {
 	} else if (cmd->stop_src == TRIG_NONE &&
-		cmd->scan_end_src == TRIG_COUNT) {
+		   cmd->scan_end_src == TRIG_COUNT) {
 	} else if (cmd->stop_src == TRIG_COUNT &&
-		cmd->scan_end_src == TRIG_COUNT) {
+		   cmd->scan_end_src == TRIG_COUNT) {
 	} else {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid stop trigger combination\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid stop trigger combination\n",
+		       dev->minor);
 		cmd->stop_src = TRIG_NONE;
 		cmd->scan_end_src = TRIG_NONE;
 		err++;
@@ -1555,29 +1577,29 @@ static int me4000_ai_do_cmd_test(struct 
 	 */
 	if (cmd->chanlist_len < 1) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): No channel list\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): No channel list\n",
+		       dev->minor);
 		cmd->chanlist_len = 1;
 		err++;
 	}
 	if (init_ticks < 66) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Start arg to low\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Start arg to low\n",
+		       dev->minor);
 		cmd->start_arg = 2000;
 		err++;
 	}
 	if (scan_ticks && scan_ticks < 67) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Scan begin arg to low\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Scan begin arg to low\n",
+		       dev->minor);
 		cmd->scan_begin_arg = 2031;
 		err++;
 	}
 	if (chan_ticks < 66) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_do_cmd_test(): Convert arg to low\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_ai_do_cmd_test(): Convert arg to low\n",
+		       dev->minor);
 		cmd->convert_arg = 2000;
 		err++;
 	}
@@ -1589,123 +1611,123 @@ static int me4000_ai_do_cmd_test(struct 
 	 * Stage 4. Check for argument conflicts.
 	 */
 	if (cmd->start_src == TRIG_NOW &&
-		cmd->scan_begin_src == TRIG_TIMER &&
-		cmd->convert_src == TRIG_TIMER) {
+	    cmd->scan_begin_src == TRIG_TIMER &&
+	    cmd->convert_src == TRIG_TIMER) {
 
 		/* Check timer arguments */
 		if (init_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
+			       dev->minor);
 			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
+			       dev->minor);
 			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (scan_ticks <= cmd->chanlist_len * chan_ticks) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
+			       dev->minor);
 			cmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;	/*  At least one tick more */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_NOW &&
-		cmd->scan_begin_src == TRIG_FOLLOW &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_FOLLOW &&
+		   cmd->convert_src == TRIG_TIMER) {
 
 		/* Check timer arguments */
 		if (init_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
+			       dev->minor);
 			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
+			       dev->minor);
 			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_TIMER &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_TIMER &&
+		   cmd->convert_src == TRIG_TIMER) {
 
 		/* Check timer arguments */
 		if (init_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
+			       dev->minor);
 			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
+			       dev->minor);
 			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (scan_ticks <= cmd->chanlist_len * chan_ticks) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
+			       dev->minor);
 			cmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;	/*  At least one tick more */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_FOLLOW &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_FOLLOW &&
+		   cmd->convert_src == TRIG_TIMER) {
 
 		/* Check timer arguments */
 		if (init_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
+			       dev->minor);
 			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
+			       dev->minor);
 			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_EXT &&
-		cmd->convert_src == TRIG_TIMER) {
+		   cmd->scan_begin_src == TRIG_EXT &&
+		   cmd->convert_src == TRIG_TIMER) {
 
 		/* Check timer arguments */
 		if (init_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
+			       dev->minor);
 			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
+			       dev->minor);
 			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_EXT &&
-		cmd->scan_begin_src == TRIG_EXT &&
-		cmd->convert_src == TRIG_EXT) {
+		   cmd->scan_begin_src == TRIG_EXT &&
+		   cmd->convert_src == TRIG_EXT) {
 
 		/* Check timer arguments */
 		if (init_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
+			       dev->minor);
 			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
@@ -1713,8 +1735,8 @@ static int me4000_ai_do_cmd_test(struct 
 	if (cmd->stop_src == TRIG_COUNT) {
 		if (cmd->stop_arg == 0) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid stop arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid stop arg\n",
+			       dev->minor);
 			cmd->stop_arg = 1;
 			err++;
 		}
@@ -1722,8 +1744,8 @@ static int me4000_ai_do_cmd_test(struct 
 	if (cmd->scan_end_src == TRIG_COUNT) {
 		if (cmd->scan_end_arg == 0) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
+			       dev->minor);
 			cmd->scan_end_arg = 1;
 			err++;
 		}
@@ -1764,40 +1786,40 @@ static irqreturn_t me4000_ai_isr(int irq
 	/* Check if irq number is right */
 	if (irq != ai_context->irq) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ai_isr(): Incorrect interrupt num: %d\n",
-			dev->minor, irq);
+		       "comedi%d: me4000: me4000_ai_isr(): Incorrect interrupt num: %d\n",
+		       dev->minor, irq);
 		return IRQ_HANDLED;
 	}
 
 	if (me4000_inl(dev,
-			ai_context->
-			irq_status_reg) & ME4000_IRQ_STATUS_BIT_AI_HF) {
+		       ai_context->irq_status_reg) &
+	    ME4000_IRQ_STATUS_BIT_AI_HF) {
 		ISR_PDEBUG
-			("me4000_ai_isr(): Fifo half full interrupt occured\n");
+		    ("me4000_ai_isr(): Fifo half full interrupt occured\n");
 
 		/* Read status register to find out what happened */
 		tmp = me4000_inl(dev, ai_context->ctrl_reg);
 
 		if (!(tmp & ME4000_AI_STATUS_BIT_FF_DATA) &&
-			!(tmp & ME4000_AI_STATUS_BIT_HF_DATA) &&
-			(tmp & ME4000_AI_STATUS_BIT_EF_DATA)) {
+		    !(tmp & ME4000_AI_STATUS_BIT_HF_DATA) &&
+		    (tmp & ME4000_AI_STATUS_BIT_EF_DATA)) {
 			ISR_PDEBUG("me4000_ai_isr(): Fifo full\n");
 			c = ME4000_AI_FIFO_COUNT;
 
 			/* FIFO overflow, so stop conversion and disable all interrupts */
 			tmp |= ME4000_AI_CTRL_BIT_IMMEDIATE_STOP;
 			tmp &= ~(ME4000_AI_CTRL_BIT_HF_IRQ |
-				ME4000_AI_CTRL_BIT_SC_IRQ);
+				 ME4000_AI_CTRL_BIT_SC_IRQ);
 			me4000_outl(dev, tmp, ai_context->ctrl_reg);
 
 			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_isr(): FIFO overflow\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_isr(): FIFO overflow\n",
+			       dev->minor);
 		} else if ((tmp & ME4000_AI_STATUS_BIT_FF_DATA)
-			&& !(tmp & ME4000_AI_STATUS_BIT_HF_DATA)
-			&& (tmp & ME4000_AI_STATUS_BIT_EF_DATA)) {
+			   && !(tmp & ME4000_AI_STATUS_BIT_HF_DATA)
+			   && (tmp & ME4000_AI_STATUS_BIT_EF_DATA)) {
 			ISR_PDEBUG("me4000_ai_isr(): Fifo half full\n");
 
 			s->async->events |= COMEDI_CB_BLOCK;
@@ -1805,21 +1827,21 @@ static irqreturn_t me4000_ai_isr(int irq
 			c = ME4000_AI_FIFO_COUNT / 2;
 		} else {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_isr(): Can't determine state of fifo\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_isr(): Can't determine state of fifo\n",
+			       dev->minor);
 			c = 0;
 
 			/* Undefined state, so stop conversion and disable all interrupts */
 			tmp |= ME4000_AI_CTRL_BIT_IMMEDIATE_STOP;
 			tmp &= ~(ME4000_AI_CTRL_BIT_HF_IRQ |
-				ME4000_AI_CTRL_BIT_SC_IRQ);
+				 ME4000_AI_CTRL_BIT_SC_IRQ);
 			me4000_outl(dev, tmp, ai_context->ctrl_reg);
 
 			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_ai_isr(): Undefined FIFO state\n",
-				dev->minor);
+			       "comedi%d: me4000: me4000_ai_isr(): Undefined FIFO state\n",
+			       dev->minor);
 		}
 
 		ISR_PDEBUG("me4000_ai_isr(): Try to read %d values\n", c);
@@ -1833,14 +1855,14 @@ static irqreturn_t me4000_ai_isr(int irq
 				/* Buffer overflow, so stop conversion and disable all interrupts */
 				tmp |= ME4000_AI_CTRL_BIT_IMMEDIATE_STOP;
 				tmp &= ~(ME4000_AI_CTRL_BIT_HF_IRQ |
-					ME4000_AI_CTRL_BIT_SC_IRQ);
+					 ME4000_AI_CTRL_BIT_SC_IRQ);
 				me4000_outl(dev, tmp, ai_context->ctrl_reg);
 
 				s->async->events |= COMEDI_CB_OVERFLOW;
 
 				printk(KERN_ERR
-					"comedi%d: me4000: me4000_ai_isr(): Buffer overflow\n",
-					dev->minor);
+				       "comedi%d: me4000: me4000_ai_isr(): Buffer overflow\n",
+				       dev->minor);
 
 				break;
 			}
@@ -1855,10 +1877,9 @@ static irqreturn_t me4000_ai_isr(int irq
 	}
 
 	if (me4000_inl(dev,
-			ai_context->
-			irq_status_reg) & ME4000_IRQ_STATUS_BIT_SC) {
+		       ai_context->irq_status_reg) & ME4000_IRQ_STATUS_BIT_SC) {
 		ISR_PDEBUG
-			("me4000_ai_isr(): Sample counter interrupt occured\n");
+		    ("me4000_ai_isr(): Sample counter interrupt occured\n");
 
 		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOA;
 
@@ -1876,8 +1897,8 @@ static irqreturn_t me4000_ai_isr(int irq
 
 			if (!comedi_buf_put(s->async, lval)) {
 				printk(KERN_ERR
-					"comedi%d: me4000: me4000_ai_isr(): Buffer overflow\n",
-					dev->minor);
+				       "comedi%d: me4000: me4000_ai_isr(): Buffer overflow\n",
+				       dev->minor);
 				s->async->events |= COMEDI_CB_OVERFLOW;
 				break;
 			}
@@ -1885,7 +1906,7 @@ static irqreturn_t me4000_ai_isr(int irq
 
 		/* Work is done, so reset the interrupt */
 		ISR_PDEBUG
-			("me4000_ai_isr(): Reset interrupt from sample counter\n");
+		    ("me4000_ai_isr(): Reset interrupt from sample counter\n");
 		tmp |= ME4000_AI_CTRL_BIT_SC_IRQ_RESET;
 		me4000_outl(dev, tmp, ai_context->ctrl_reg);
 		tmp &= ~ME4000_AI_CTRL_BIT_SC_IRQ_RESET;
@@ -1905,7 +1926,8 @@ static irqreturn_t me4000_ai_isr(int irq
   ===========================================================================*/
 
 static int me4000_ao_insn_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 
 	int chan = CR_CHAN(insn->chanspec);
@@ -1919,29 +1941,29 @@ static int me4000_ao_insn_write(struct c
 		return 0;
 	} else if (insn->n > 1) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ao_insn_write(): Invalid instruction length %d\n",
-			dev->minor, insn->n);
+		       "comedi%d: me4000: me4000_ao_insn_write(): Invalid instruction length %d\n",
+		       dev->minor, insn->n);
 		return -EINVAL;
 	}
 
 	if (chan >= thisboard->ao.count) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ao_insn_write(): Invalid channel %d\n",
-			dev->minor, insn->n);
+		       "comedi%d: me4000: me4000_ao_insn_write(): Invalid channel %d\n",
+		       dev->minor, insn->n);
 		return -EINVAL;
 	}
 
 	if (rang != 0) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ao_insn_write(): Invalid range %d\n",
-			dev->minor, insn->n);
+		       "comedi%d: me4000: me4000_ao_insn_write(): Invalid range %d\n",
+		       dev->minor, insn->n);
 		return -EINVAL;
 	}
 
 	if (aref != AREF_GROUND && aref != AREF_COMMON) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_ao_insn_write(): Invalid aref %d\n",
-			dev->minor, insn->n);
+		       "comedi%d: me4000: me4000_ao_insn_write(): Invalid aref %d\n",
+		       dev->minor, insn->n);
 		return -EINVAL;
 	}
 
@@ -1963,14 +1985,17 @@ static int me4000_ao_insn_write(struct c
 }
 
 static int me4000_ao_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
 	if (insn->n == 0) {
 		return 0;
 	} else if (insn->n > 1) {
-		printk("comedi%d: me4000: me4000_ao_insn_read(): Invalid instruction length\n", dev->minor);
+		printk
+		    ("comedi%d: me4000: me4000_ao_insn_read(): Invalid instruction length\n",
+		     dev->minor);
 		return -EINVAL;
 	}
 
@@ -1984,7 +2009,8 @@ static int me4000_ao_insn_read(struct co
   ===========================================================================*/
 
 static int me4000_dio_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 
 	CALL_PDEBUG("In me4000_dio_insn_bits()\n");
@@ -1994,7 +2020,9 @@ static int me4000_dio_insn_bits(struct c
 		return 0;
 
 	if (insn->n != 2) {
-		printk("comedi%d: me4000: me4000_dio_insn_bits(): Invalid instruction length\n", dev->minor);
+		printk
+		    ("comedi%d: me4000: me4000_dio_insn_bits(): Invalid instruction length\n",
+		     dev->minor);
 		return -EINVAL;
 	}
 
@@ -2014,28 +2042,29 @@ static int me4000_dio_insn_bits(struct c
 
 		/* Write out the new digital output lines */
 		me4000_outl(dev, (s->state >> 0) & 0xFF,
-			info->dio_context.port_0_reg);
+			    info->dio_context.port_0_reg);
 		me4000_outl(dev, (s->state >> 8) & 0xFF,
-			info->dio_context.port_1_reg);
+			    info->dio_context.port_1_reg);
 		me4000_outl(dev, (s->state >> 16) & 0xFF,
-			info->dio_context.port_2_reg);
+			    info->dio_context.port_2_reg);
 		me4000_outl(dev, (s->state >> 24) & 0xFF,
-			info->dio_context.port_3_reg);
+			    info->dio_context.port_3_reg);
 	}
 
 	/* On return, data[1] contains the value of
 	   the digital input and output lines. */
 	data[1] =
-		((me4000_inl(dev, info->dio_context.port_0_reg) & 0xFF) << 0) |
-		((me4000_inl(dev, info->dio_context.port_1_reg) & 0xFF) << 8) |
-		((me4000_inl(dev, info->dio_context.port_2_reg) & 0xFF) << 16) |
-		((me4000_inl(dev, info->dio_context.port_3_reg) & 0xFF) << 24);
+	    ((me4000_inl(dev, info->dio_context.port_0_reg) & 0xFF) << 0) |
+	    ((me4000_inl(dev, info->dio_context.port_1_reg) & 0xFF) << 8) |
+	    ((me4000_inl(dev, info->dio_context.port_2_reg) & 0xFF) << 16) |
+	    ((me4000_inl(dev, info->dio_context.port_3_reg) & 0xFF) << 24);
 
 	return 2;
 }
 
 static int me4000_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned long tmp;
 	int chan = CR_CHAN(insn->chanspec);
@@ -2044,8 +2073,7 @@ static int me4000_dio_insn_config(struct
 
 	if (data[0] == INSN_CONFIG_DIO_QUERY) {
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 	}
 
@@ -2063,7 +2091,7 @@ static int me4000_dio_insn_config(struct
 		if (chan < 8) {
 			s->io_bits |= 0xFF;
 			tmp &= ~(ME4000_DIO_CTRL_BIT_MODE_0 |
-				ME4000_DIO_CTRL_BIT_MODE_1);
+				 ME4000_DIO_CTRL_BIT_MODE_1);
 			tmp |= ME4000_DIO_CTRL_BIT_MODE_0;
 		} else if (chan < 16) {
 			/*
@@ -2075,17 +2103,17 @@ static int me4000_dio_insn_config(struct
 
 			s->io_bits |= 0xFF00;
 			tmp &= ~(ME4000_DIO_CTRL_BIT_MODE_2 |
-				ME4000_DIO_CTRL_BIT_MODE_3);
+				 ME4000_DIO_CTRL_BIT_MODE_3);
 			tmp |= ME4000_DIO_CTRL_BIT_MODE_2;
 		} else if (chan < 24) {
 			s->io_bits |= 0xFF0000;
 			tmp &= ~(ME4000_DIO_CTRL_BIT_MODE_4 |
-				ME4000_DIO_CTRL_BIT_MODE_5);
+				 ME4000_DIO_CTRL_BIT_MODE_5);
 			tmp |= ME4000_DIO_CTRL_BIT_MODE_4;
 		} else if (chan < 32) {
 			s->io_bits |= 0xFF000000;
 			tmp &= ~(ME4000_DIO_CTRL_BIT_MODE_6 |
-				ME4000_DIO_CTRL_BIT_MODE_7);
+				 ME4000_DIO_CTRL_BIT_MODE_7);
 			tmp |= ME4000_DIO_CTRL_BIT_MODE_6;
 		} else {
 			return -EINVAL;
@@ -2101,19 +2129,19 @@ static int me4000_dio_insn_config(struct
 
 			s->io_bits &= ~0xFF;
 			tmp &= ~(ME4000_DIO_CTRL_BIT_MODE_0 |
-				ME4000_DIO_CTRL_BIT_MODE_1);
+				 ME4000_DIO_CTRL_BIT_MODE_1);
 		} else if (chan < 16) {
 			s->io_bits &= ~0xFF00;
 			tmp &= ~(ME4000_DIO_CTRL_BIT_MODE_2 |
-				ME4000_DIO_CTRL_BIT_MODE_3);
+				 ME4000_DIO_CTRL_BIT_MODE_3);
 		} else if (chan < 24) {
 			s->io_bits &= ~0xFF0000;
 			tmp &= ~(ME4000_DIO_CTRL_BIT_MODE_4 |
-				ME4000_DIO_CTRL_BIT_MODE_5);
+				 ME4000_DIO_CTRL_BIT_MODE_5);
 		} else if (chan < 32) {
 			s->io_bits &= ~0xFF000000;
 			tmp &= ~(ME4000_DIO_CTRL_BIT_MODE_6 |
-				ME4000_DIO_CTRL_BIT_MODE_7);
+				 ME4000_DIO_CTRL_BIT_MODE_7);
 		} else {
 			return -EINVAL;
 		}
@@ -2151,8 +2179,8 @@ static int cnt_reset(struct comedi_devic
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: cnt_reset(): Invalid channel\n",
-			dev->minor);
+		       "comedi%d: me4000: cnt_reset(): Invalid channel\n",
+		       dev->minor);
 		return -EINVAL;
 	}
 
@@ -2160,7 +2188,7 @@ static int cnt_reset(struct comedi_devic
 }
 
 static int cnt_config(struct comedi_device *dev, unsigned int channel,
-	unsigned int mode)
+		      unsigned int mode)
 {
 	int tmp = 0;
 
@@ -2178,8 +2206,8 @@ static int cnt_config(struct comedi_devi
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: cnt_config(): Invalid channel\n",
-			dev->minor);
+		       "comedi%d: me4000: cnt_config(): Invalid channel\n",
+		       dev->minor);
 		return -EINVAL;
 	}
 
@@ -2204,8 +2232,8 @@ static int cnt_config(struct comedi_devi
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: cnt_config(): Invalid counter mode\n",
-			dev->minor);
+		       "comedi%d: me4000: cnt_config(): Invalid counter mode\n",
+		       dev->minor);
 		return -EINVAL;
 	}
 
@@ -2217,7 +2245,8 @@ static int cnt_config(struct comedi_devi
 }
 
 static int me4000_cnt_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 
 	int err;
@@ -2228,8 +2257,8 @@ static int me4000_cnt_insn_config(struct
 	case GPCT_RESET:
 		if (insn->n != 1) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_cnt_insn_config(): Invalid instruction length%d\n",
-				dev->minor, insn->n);
+			       "comedi%d: me4000: me4000_cnt_insn_config(): Invalid instruction length%d\n",
+			       dev->minor, insn->n);
 			return -EINVAL;
 		}
 
@@ -2240,8 +2269,8 @@ static int me4000_cnt_insn_config(struct
 	case GPCT_SET_OPERATION:
 		if (insn->n != 2) {
 			printk(KERN_ERR
-				"comedi%d: me4000: me4000_cnt_insn_config(): Invalid instruction length%d\n",
-				dev->minor, insn->n);
+			       "comedi%d: me4000: me4000_cnt_insn_config(): Invalid instruction length%d\n",
+			       dev->minor, insn->n);
 			return -EINVAL;
 		}
 
@@ -2251,8 +2280,8 @@ static int me4000_cnt_insn_config(struct
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_cnt_insn_config(): Invalid instruction\n",
-			dev->minor);
+		       "comedi%d: me4000: me4000_cnt_insn_config(): Invalid instruction\n",
+		       dev->minor);
 		return -EINVAL;
 	}
 
@@ -2260,7 +2289,8 @@ static int me4000_cnt_insn_config(struct
 }
 
 static int me4000_cnt_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 
 	unsigned short tmp;
@@ -2272,8 +2302,8 @@ static int me4000_cnt_insn_read(struct c
 
 	if (insn->n > 1) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_cnt_insn_read(): Invalid instruction length %d\n",
-			dev->minor, insn->n);
+		       "comedi%d: me4000: me4000_cnt_insn_read(): Invalid instruction length %d\n",
+		       dev->minor, insn->n);
 		return -EINVAL;
 	}
 
@@ -2298,8 +2328,8 @@ static int me4000_cnt_insn_read(struct c
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_cnt_insn_read(): Invalid channel %d\n",
-			dev->minor, insn->chanspec);
+		       "comedi%d: me4000: me4000_cnt_insn_read(): Invalid channel %d\n",
+		       dev->minor, insn->chanspec);
 		return -EINVAL;
 	}
 
@@ -2307,7 +2337,8 @@ static int me4000_cnt_insn_read(struct c
 }
 
 static int me4000_cnt_insn_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 
 	unsigned short tmp;
@@ -2318,8 +2349,8 @@ static int me4000_cnt_insn_write(struct 
 		return 0;
 	} else if (insn->n > 1) {
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_cnt_insn_write(): Invalid instruction length %d\n",
-			dev->minor, insn->n);
+		       "comedi%d: me4000: me4000_cnt_insn_write(): Invalid instruction length %d\n",
+		       dev->minor, insn->n);
 		return -EINVAL;
 	}
 
@@ -2344,8 +2375,8 @@ static int me4000_cnt_insn_write(struct 
 		break;
 	default:
 		printk(KERN_ERR
-			"comedi%d: me4000: me4000_cnt_insn_write(): Invalid channel %d\n",
-			dev->minor, insn->chanspec);
+		       "comedi%d: me4000: me4000_cnt_insn_write(): Invalid channel %d\n",
+		       dev->minor, insn->chanspec);
 		return -EINVAL;
 	}
 
--- a/drivers/staging/comedi/drivers/me_daq.c
+++ b/drivers/staging/comedi/drivers/me_daq.c
@@ -151,46 +151,47 @@ static int me_detach(struct comedi_devic
 static const struct comedi_lrange me2000_ai_range = {
 	8,
 	{
-		BIP_RANGE(10),
-		BIP_RANGE(5),
-		BIP_RANGE(2.5),
-		BIP_RANGE(1.25),
-		UNI_RANGE(10),
-		UNI_RANGE(5),
-		UNI_RANGE(2.5),
-		UNI_RANGE(1.25)
-	}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25)
+	 }
 };
 
 static const struct comedi_lrange me2600_ai_range = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25)
+	 }
 };
 
 static const struct comedi_lrange me2600_ao_range = {
 	3,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			UNI_RANGE(10)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 UNI_RANGE(10)
+	 }
 };
 
 static DEFINE_PCI_DEVICE_TABLE(me_pci_table) = {
-	{PCI_VENDOR_ID_MEILHAUS, ME2600_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		0},
-	{PCI_VENDOR_ID_MEILHAUS, ME2000_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		0},
-	{0}
+	{
+	PCI_VENDOR_ID_MEILHAUS, ME2600_DEVICE_ID, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_MEILHAUS, ME2000_DEVICE_ID, PCI_ANY_ID,
+		    PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, me_pci_table);
@@ -212,48 +213,48 @@ struct me_board {
 
 static const struct me_board me_boards[] = {
 	{
-		/* -- ME-2600i -- */
-		.name = 		ME_DRIVER_NAME,
-		.device_id =		ME2600_DEVICE_ID,
-		/* Analog Output */
-		.ao_channel_nbr =	4,
-		.ao_resolution =	12,
-		.ao_resolution_mask =	0x0fff,
-		.ao_range_list =	&me2600_ao_range,
-		.ai_channel_nbr =	16,
-		/* Analog Input */
-		.ai_resolution =	12,
-		.ai_resolution_mask =	0x0fff,
-		.ai_range_list =	&me2600_ai_range,
-		.dio_channel_nbr =	32,
-		},
+	 /* -- ME-2600i -- */
+	 .name = ME_DRIVER_NAME,
+	 .device_id = ME2600_DEVICE_ID,
+	 /* Analog Output */
+	 .ao_channel_nbr = 4,
+	 .ao_resolution = 12,
+	 .ao_resolution_mask = 0x0fff,
+	 .ao_range_list = &me2600_ao_range,
+	 .ai_channel_nbr = 16,
+	 /* Analog Input */
+	 .ai_resolution = 12,
+	 .ai_resolution_mask = 0x0fff,
+	 .ai_range_list = &me2600_ai_range,
+	 .dio_channel_nbr = 32,
+	 },
 	{
-		/* -- ME-2000i -- */
-		.name =			ME_DRIVER_NAME,
-		.device_id =		ME2000_DEVICE_ID,
-		/* Analog Output */
-		.ao_channel_nbr =	0,
-		.ao_resolution =	0,
-		.ao_resolution_mask =	0,
-		.ao_range_list =	NULL,
-		.ai_channel_nbr =	16,
-		/* Analog Input */
-		.ai_resolution =	12,
-		.ai_resolution_mask =	0x0fff,
-		.ai_range_list =	&me2000_ai_range,
-		.dio_channel_nbr =	32,
-		}
+	 /* -- ME-2000i -- */
+	 .name = ME_DRIVER_NAME,
+	 .device_id = ME2000_DEVICE_ID,
+	 /* Analog Output */
+	 .ao_channel_nbr = 0,
+	 .ao_resolution = 0,
+	 .ao_resolution_mask = 0,
+	 .ao_range_list = NULL,
+	 .ai_channel_nbr = 16,
+	 /* Analog Input */
+	 .ai_resolution = 12,
+	 .ai_resolution_mask = 0x0fff,
+	 .ai_range_list = &me2000_ai_range,
+	 .dio_channel_nbr = 32,
+	 }
 };
 
 #define me_board_nbr (sizeof(me_boards)/sizeof(struct me_board))
 
-
 static struct comedi_driver me_driver = {
-      .driver_name =	ME_DRIVER_NAME,
-      .module =		THIS_MODULE,
-      .attach =		me_attach,
-      .detach =		me_detach,
+	.driver_name = ME_DRIVER_NAME,
+	.module = THIS_MODULE,
+	.attach = me_attach,
+	.detach = me_detach,
 };
+
 COMEDI_PCI_INITCLEANUP(me_driver, me_pci_table);
 
 /* Private data structure */
@@ -292,7 +293,8 @@ static inline void sleep(unsigned sec)
  *
  * ------------------------------------------------------------------
  */
-static int me_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+static int me_dio_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
 	int bits;
@@ -305,7 +307,7 @@ static int me_dio_insn_config(struct com
 		/* Enable Port A */
 		dev_private->control_2 |= ENABLE_PORT_A;
 		writew(dev_private->control_2,
-			dev_private->me_regbase + ME_CONTROL_2);
+		       dev_private->me_regbase + ME_CONTROL_2);
 	} else {		/* Port B in use */
 
 		bits = 0xffff0000;
@@ -313,7 +315,7 @@ static int me_dio_insn_config(struct com
 		/* Enable Port B */
 		dev_private->control_2 |= ENABLE_PORT_B;
 		writew(dev_private->control_2,
-			dev_private->me_regbase + ME_CONTROL_2);
+		       dev_private->me_regbase + ME_CONTROL_2);
 	}
 
 	if (data[0]) {
@@ -328,7 +330,8 @@ static int me_dio_insn_config(struct com
 }
 
 /* Digital instant input/outputs */
-static int me_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+static int me_dio_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int mask = data[0];
@@ -338,7 +341,7 @@ static int me_dio_insn_bits(struct comed
 	mask &= s->io_bits;
 	if (mask & 0x0000ffff) {	/* Port A */
 		writew((s->state & 0xffff),
-			dev_private->me_regbase + ME_DIO_PORT_A);
+		       dev_private->me_regbase + ME_DIO_PORT_A);
 	} else {
 		data[1] &= ~0x0000ffff;
 		data[1] |= readw(dev_private->me_regbase + ME_DIO_PORT_A);
@@ -346,7 +349,7 @@ static int me_dio_insn_bits(struct comed
 
 	if (mask & 0xffff0000) {	/* Port B */
 		writew(((s->state >> 16) & 0xffff),
-			dev_private->me_regbase + ME_DIO_PORT_B);
+		       dev_private->me_regbase + ME_DIO_PORT_B);
 	} else {
 		data[1] &= ~0xffff0000;
 		data[1] |= readw(dev_private->me_regbase + ME_DIO_PORT_B) << 16;
@@ -364,7 +367,8 @@ static int me_dio_insn_bits(struct comed
  */
 
 /* Analog instant input */
-static int me_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *subdevice,
+static int me_ai_insn_read(struct comedi_device *dev,
+			   struct comedi_subdevice *subdevice,
 			   struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned short value;
@@ -414,8 +418,8 @@ static int me_ai_insn_read(struct comedi
 	/* get value from ADC fifo */
 	if (i) {
 		data[0] =
-			(readw(dev_private->me_regbase +
-				ME_READ_AD_FIFO) ^ 0x800) & 0x0FFF;
+		    (readw(dev_private->me_regbase +
+			   ME_READ_AD_FIFO) ^ 0x800) & 0x0FFF;
 	} else {
 		printk(KERN_ERR "comedi%d: Cannot get single value\n",
 		       dev->minor);
@@ -450,14 +454,15 @@ static int me_ai_cancel(struct comedi_de
 }
 
 /* Test analog input command */
-static int me_ai_do_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd)
+static int me_ai_do_cmd_test(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	return 0;
 }
 
 /* Analog input command */
-static int me_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *subdevice)
+static int me_ai_do_cmd(struct comedi_device *dev,
+			struct comedi_subdevice *subdevice)
 {
 	return 0;
 }
@@ -471,7 +476,8 @@ static int me_ai_do_cmd(struct comedi_de
  */
 
 /* Analog instant output */
-static int me_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int me_ao_insn_write(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	int chan;
@@ -495,13 +501,13 @@ static int me_ao_insn_write(struct comed
 		dev_private->dac_control &= ~(0x0880 >> chan);
 		if (rang == 0)
 			dev_private->dac_control |=
-				((DAC_BIPOLAR_A | DAC_GAIN_1_A) >> chan);
+			    ((DAC_BIPOLAR_A | DAC_GAIN_1_A) >> chan);
 		else if (rang == 1)
 			dev_private->dac_control |=
-				((DAC_BIPOLAR_A | DAC_GAIN_0_A) >> chan);
+			    ((DAC_BIPOLAR_A | DAC_GAIN_0_A) >> chan);
 	}
 	writew(dev_private->dac_control,
-		dev_private->me_regbase + ME_DAC_CONTROL);
+	       dev_private->me_regbase + ME_DAC_CONTROL);
 
 	/* Update dac-control register */
 	readw(dev_private->me_regbase + ME_DAC_CONTROL_UPDATE);
@@ -510,7 +516,7 @@ static int me_ao_insn_write(struct comed
 	for (i = 0; i < insn->n; i++) {
 		chan = CR_CHAN((&insn->chanspec)[i]);
 		writew((data[0] & s->maxdata),
-			dev_private->me_regbase + ME_DAC_DATA_A + (chan << 1));
+		       dev_private->me_regbase + ME_DAC_DATA_A + (chan << 1));
 		dev_private->ao_readback[chan] = (data[0] & s->maxdata);
 	}
 
@@ -521,14 +527,15 @@ static int me_ao_insn_write(struct comed
 }
 
 /* Analog output readback */
-static int me_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-			   struct comedi_insn *insn, unsigned int *data)
+static int me_ao_insn_read(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
 		data[i] =
-			dev_private->ao_readback[CR_CHAN((&insn->chanspec)[i])];
+		    dev_private->ao_readback[CR_CHAN((&insn->chanspec)[i])];
 	}
 
 	return 1;
@@ -575,9 +582,9 @@ static int me2600_xilinx_download(struct
 	if (length < 16)
 		return -EINVAL;
 	file_length = (((unsigned int)me2600_firmware[0] & 0xff) << 24) +
-		      (((unsigned int)me2600_firmware[1] & 0xff) << 16) +
-		      (((unsigned int)me2600_firmware[2] & 0xff) << 8) +
-		      ((unsigned int)me2600_firmware[3] & 0xff);
+	    (((unsigned int)me2600_firmware[1] & 0xff) << 16) +
+	    (((unsigned int)me2600_firmware[2] & 0xff) << 8) +
+	    ((unsigned int)me2600_firmware[3] & 0xff);
 
 	/*
 	 * Loop for writing firmware byte by byte to xilinx
@@ -585,7 +592,7 @@ static int me2600_xilinx_download(struct
 	 */
 	for (i = 0; i < file_length; i++)
 		writeb((me2600_firmware[16 + i] & 0xff),
-			dev_private->me_regbase + 0x0);
+		       dev_private->me_regbase + 0x0);
 
 	/* Write 5 dummy values to xilinx */
 	for (i = 0; i < 5; i++)
@@ -653,33 +660,32 @@ static int me_attach(struct comedi_devic
 
 	/* Probe the device to determine what device in the series it is. */
 	for (pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pci_device != NULL;
-		pci_device =
-		pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_device)) {
+	     pci_device != NULL;
+	     pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_device)) {
 		if (pci_device->vendor == PCI_VENDOR_ID_MEILHAUS) {
 			for (i = 0; i < me_board_nbr; i++) {
 				if (me_boards[i].device_id ==
-					pci_device->device) {
+				    pci_device->device) {
 					/*
 					 * was a particular bus/slot requested?
 					 */
 					if ((it->options[0] != 0)
-						|| (it->options[1] != 0)) {
+					    || (it->options[1] != 0)) {
 						/*
 						 * are we on the wrong bus/slot?
 						 */
 						if (pci_device->bus->number !=
-							it->options[0]
-							|| PCI_SLOT(pci_device->
-								devfn) !=
-							it->options[1]) {
+						    it->options[0]
+						    ||
+						    PCI_SLOT(pci_device->devfn)
+						    != it->options[1]) {
 							continue;
 						}
 					}
 
 					dev->board_ptr = me_boards + i;
-					board = (struct me_board *) dev->
-						board_ptr;
+					board =
+					    (struct me_board *)dev->board_ptr;
 					dev_private->pci_device = pci_device;
 					goto found;
 				}
@@ -694,8 +700,8 @@ static int me_attach(struct comedi_devic
 
 found:
 	printk(KERN_INFO "comedi%d: found %s at PCI bus %d, slot %d\n",
-		dev->minor, me_boards[i].name,
-		pci_device->bus->number, PCI_SLOT(pci_device->devfn));
+	       dev->minor, me_boards[i].name,
+	       pci_device->bus->number, PCI_SLOT(pci_device->devfn));
 
 	/* Enable PCI device and request PCI regions */
 	if (comedi_pci_enable(pci_device, ME_DRIVER_NAME) < 0) {
@@ -711,7 +717,7 @@ found:
 	plx_regbase_tmp = pci_resource_start(pci_device, 0);
 	plx_regbase_size_tmp = pci_resource_len(pci_device, 0);
 	dev_private->plx_regbase =
-		ioremap(plx_regbase_tmp, plx_regbase_size_tmp);
+	    ioremap(plx_regbase_tmp, plx_regbase_size_tmp);
 	dev_private->plx_regbase_size = plx_regbase_size_tmp;
 	if (!dev_private->plx_regbase) {
 		printk("comedi%d: Failed to remap I/O memory\n", dev->minor);
@@ -736,18 +742,21 @@ found:
 			swap_regbase_tmp = regbase_tmp;
 
 			result = pci_write_config_dword(pci_device,
-				PCI_BASE_ADDRESS_0, plx_regbase_tmp);
+							PCI_BASE_ADDRESS_0,
+							plx_regbase_tmp);
 			if (result != PCIBIOS_SUCCESSFUL)
 				return -EIO;
 
 			result = pci_write_config_dword(pci_device,
-				PCI_BASE_ADDRESS_5, swap_regbase_tmp);
+							PCI_BASE_ADDRESS_5,
+							swap_regbase_tmp);
 			if (result != PCIBIOS_SUCCESSFUL)
 				return -EIO;
 		} else {
 			plx_regbase_tmp -= 0x80;
 			result = pci_write_config_dword(pci_device,
-				PCI_BASE_ADDRESS_0, plx_regbase_tmp);
+							PCI_BASE_ADDRESS_0,
+							plx_regbase_tmp);
 			if (result != PCIBIOS_SUCCESSFUL)
 				return -EIO;
 		}
@@ -822,7 +831,8 @@ found:
 	subdevice->insn_config = me_dio_insn_config;
 	subdevice->io_bits = 0;
 
-	printk(KERN_INFO "comedi%d: "ME_DRIVER_NAME" attached.\n", dev->minor);
+	printk(KERN_INFO "comedi%d: " ME_DRIVER_NAME " attached.\n",
+	       dev->minor);
 	return 0;
 }
 
--- a/drivers/staging/comedi/drivers/mite.c
+++ b/drivers/staging/comedi/drivers/mite.c
@@ -73,8 +73,8 @@ void mite_init(void)
 	struct mite_struct *mite;
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		if (pcidev->vendor == PCI_VENDOR_ID_NATINST) {
 			unsigned i;
 
@@ -99,14 +99,19 @@ void mite_init(void)
 
 static void dump_chip_signature(u32 csigr_bits)
 {
-	printk("mite: version = %i, type = %i, mite mode = %i, interface mode = %i\n", mite_csigr_version(csigr_bits), mite_csigr_type(csigr_bits), mite_csigr_mmode(csigr_bits), mite_csigr_imode(csigr_bits));
-	printk("mite: num channels = %i, write post fifo depth = %i, wins = %i, iowins = %i\n", mite_csigr_dmac(csigr_bits), mite_csigr_wpdep(csigr_bits), mite_csigr_wins(csigr_bits), mite_csigr_iowins(csigr_bits));
+	printk
+	    ("mite: version = %i, type = %i, mite mode = %i, interface mode = %i\n",
+	     mite_csigr_version(csigr_bits), mite_csigr_type(csigr_bits),
+	     mite_csigr_mmode(csigr_bits), mite_csigr_imode(csigr_bits));
+	printk
+	    ("mite: num channels = %i, write post fifo depth = %i, wins = %i, iowins = %i\n",
+	     mite_csigr_dmac(csigr_bits), mite_csigr_wpdep(csigr_bits),
+	     mite_csigr_wins(csigr_bits), mite_csigr_iowins(csigr_bits));
 }
 
 unsigned mite_fifo_size(struct mite_struct *mite, unsigned channel)
 {
-	unsigned fcr_bits = readl(mite->mite_io_addr +
-		MITE_FCR(channel));
+	unsigned fcr_bits = readl(mite->mite_io_addr + MITE_FCR(channel));
 	unsigned empty_count = (fcr_bits >> 16) & 0xff;
 	unsigned full_count = fcr_bits & 0xff;
 	return empty_count + full_count;
@@ -134,7 +139,7 @@ int mite_setup2(struct mite_struct *mite
 		return -ENOMEM;
 	}
 	printk("MITE:0x%08llx mapped to %p ",
-		(unsigned long long)mite->mite_phys_addr, mite->mite_io_addr);
+	       (unsigned long long)mite->mite_phys_addr, mite->mite_io_addr);
 
 	addr = pci_resource_start(mite->pcidev, 1);
 	mite->daq_phys_addr = addr;
@@ -146,19 +151,18 @@ int mite_setup2(struct mite_struct *mite
 		return -ENOMEM;
 	}
 	printk("DAQ:0x%08llx mapped to %p\n",
-		(unsigned long long)mite->daq_phys_addr, mite->daq_io_addr);
+	       (unsigned long long)mite->daq_phys_addr, mite->daq_io_addr);
 
 	if (use_iodwbsr_1) {
 		writel(0, mite->mite_io_addr + MITE_IODWBSR);
 		printk("mite: using I/O Window Base Size register 1\n");
-		writel(mite->
-			daq_phys_addr | WENAB |
-			MITE_IODWBSR_1_WSIZE_bits(length),
-			mite->mite_io_addr + MITE_IODWBSR_1);
+		writel(mite->daq_phys_addr | WENAB |
+		       MITE_IODWBSR_1_WSIZE_bits(length),
+		       mite->mite_io_addr + MITE_IODWBSR_1);
 		writel(0, mite->mite_io_addr + MITE_IODWCR_1);
 	} else {
 		writel(mite->daq_phys_addr | WENAB,
-			mite->mite_io_addr + MITE_IODWBSR);
+		       mite->mite_io_addr + MITE_IODWBSR);
 	}
 	/* make sure dma bursts work.  I got this from running a bus analyzer
 	   on a pxi-6281 and a pxi-6713.  6713 powered up with register value
@@ -167,15 +171,17 @@ int mite_setup2(struct mite_struct *mite
 	   then does a bitwise-or of 0x600 with it and writes it back.
 	 */
 	unknown_dma_burst_bits =
-		readl(mite->mite_io_addr + MITE_UNKNOWN_DMA_BURST_REG);
+	    readl(mite->mite_io_addr + MITE_UNKNOWN_DMA_BURST_REG);
 	unknown_dma_burst_bits |= UNKNOWN_DMA_BURST_ENABLE_BITS;
 	writel(unknown_dma_burst_bits,
-		mite->mite_io_addr + MITE_UNKNOWN_DMA_BURST_REG);
+	       mite->mite_io_addr + MITE_UNKNOWN_DMA_BURST_REG);
 
 	csigr_bits = readl(mite->mite_io_addr + MITE_CSIGR);
 	mite->num_channels = mite_csigr_dmac(csigr_bits);
 	if (mite->num_channels > MAX_MITE_DMA_CHANNELS) {
-		printk("mite: bug? chip claims to have %i dma channels.  Setting to %i.\n", mite->num_channels, MAX_MITE_DMA_CHANNELS);
+		printk
+		    ("mite: bug? chip claims to have %i dma channels.  Setting to %i.\n",
+		     mite->num_channels, MAX_MITE_DMA_CHANNELS);
 		mite->num_channels = MAX_MITE_DMA_CHANNELS;
 	}
 	dump_chip_signature(csigr_bits);
@@ -183,9 +189,9 @@ int mite_setup2(struct mite_struct *mite
 		writel(CHOR_DMARESET, mite->mite_io_addr + MITE_CHOR(i));
 		/* disable interrupts */
 		writel(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE | CHCR_CLR_SAR_IE |
-			CHCR_CLR_DONE_IE | CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |
-			CHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,
-			mite->mite_io_addr + MITE_CHCR(i));
+		       CHCR_CLR_DONE_IE | CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |
+		       CHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,
+		       mite->mite_io_addr + MITE_CHCR(i));
 	}
 	mite->fifo_size = mite_fifo_size(mite, 0);
 	printk("mite: fifo size is %i.\n", mite->fifo_size);
@@ -250,8 +256,10 @@ void mite_list_devices(void)
 }
 
 struct mite_channel *mite_request_channel_in_range(struct mite_struct *mite,
-	struct mite_dma_descriptor_ring *ring, unsigned min_channel,
-	unsigned max_channel)
+						   struct
+						   mite_dma_descriptor_ring
+						   *ring, unsigned min_channel,
+						   unsigned max_channel)
 {
 	int i;
 	unsigned long flags;
@@ -284,10 +292,10 @@ void mite_release_channel(struct mite_ch
 /* disable all channel's interrupts (do it after disarm/reset so
 MITE_CHCR reg isn't changed while dma is still active!) */
 		writel(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE |
-			CHCR_CLR_SAR_IE | CHCR_CLR_DONE_IE |
-			CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |
-			CHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,
-			mite->mite_io_addr + MITE_CHCR(mite_chan->channel));
+		       CHCR_CLR_SAR_IE | CHCR_CLR_DONE_IE |
+		       CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |
+		       CHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,
+		       mite->mite_io_addr + MITE_CHCR(mite_chan->channel));
 		mite->channel_allocated[mite_chan->channel] = 0;
 		mite_chan->ring = NULL;
 		mmiowb();
@@ -317,15 +325,18 @@ void mite_dma_arm(struct mite_channel *m
 
 /**************************************/
 
-int mite_buf_change(struct mite_dma_descriptor_ring *ring, struct comedi_async * async)
+int mite_buf_change(struct mite_dma_descriptor_ring *ring,
+		    struct comedi_async *async)
 {
 	unsigned int n_links;
 	int i;
 
 	if (ring->descriptors) {
 		dma_free_coherent(ring->hw_dev,
-			ring->n_links * sizeof(struct mite_dma_descriptor),
-			ring->descriptors, ring->descriptors_dma_addr);
+				  ring->n_links *
+				  sizeof(struct mite_dma_descriptor),
+				  ring->descriptors,
+				  ring->descriptors_dma_addr);
 	}
 	ring->descriptors = NULL;
 	ring->descriptors_dma_addr = 0;
@@ -339,9 +350,9 @@ int mite_buf_change(struct mite_dma_desc
 	MDPRINTK("ring->hw_dev=%p, n_links=0x%04x\n", ring->hw_dev, n_links);
 
 	ring->descriptors =
-		dma_alloc_coherent(ring->hw_dev,
-		n_links * sizeof(struct mite_dma_descriptor),
-		&ring->descriptors_dma_addr, GFP_KERNEL);
+	    dma_alloc_coherent(ring->hw_dev,
+			       n_links * sizeof(struct mite_dma_descriptor),
+			       &ring->descriptors_dma_addr, GFP_KERNEL);
 	if (!ring->descriptors) {
 		printk("mite: ring buffer allocation failed\n");
 		return -ENOMEM;
@@ -351,13 +362,14 @@ int mite_buf_change(struct mite_dma_desc
 	for (i = 0; i < n_links; i++) {
 		ring->descriptors[i].count = cpu_to_le32(PAGE_SIZE);
 		ring->descriptors[i].addr =
-			cpu_to_le32(async->buf_page_list[i].dma_addr);
+		    cpu_to_le32(async->buf_page_list[i].dma_addr);
 		ring->descriptors[i].next =
-			cpu_to_le32(ring->descriptors_dma_addr + (i +
-				1) * sizeof(struct mite_dma_descriptor));
+		    cpu_to_le32(ring->descriptors_dma_addr + (i +
+							      1) *
+				sizeof(struct mite_dma_descriptor));
 	}
 	ring->descriptors[n_links - 1].next =
-		cpu_to_le32(ring->descriptors_dma_addr);
+	    cpu_to_le32(ring->descriptors_dma_addr);
 	/* barrier is meant to insure that all the writes to the dma descriptors
 	   have completed before the dma controller is commanded to read them */
 	smp_wmb();
@@ -365,7 +377,7 @@ int mite_buf_change(struct mite_dma_desc
 }
 
 void mite_prep_dma(struct mite_channel *mite_chan,
-	unsigned int num_device_bits, unsigned int num_memory_bits)
+		   unsigned int num_device_bits, unsigned int num_memory_bits)
 {
 	unsigned int chor, chcr, mcr, dcr, lkcr;
 	struct mite_struct *mite = mite_chan->mite;
@@ -378,7 +390,7 @@ void mite_prep_dma(struct mite_channel *
 
 	/* short link chaining mode */
 	chcr = CHCR_SET_DMA_IE | CHCR_LINKSHORT | CHCR_SET_DONE_IE |
-		CHCR_BURSTEN;
+	    CHCR_BURSTEN;
 	/*
 	 * Link Complete Interrupt: interrupt every time a link
 	 * in MITE_RING is completed. This can generate a lot of
@@ -413,8 +425,7 @@ void mite_prep_dma(struct mite_channel *
 		mcr |= CR_PSIZE32;
 		break;
 	default:
-		printk
-			("mite: bug! invalid mem bit width for dma transfer\n");
+		printk("mite: bug! invalid mem bit width for dma transfer\n");
 		break;
 	}
 	writel(mcr, mite->mite_io_addr + MITE_MCR(mite_chan->channel));
@@ -433,8 +444,7 @@ void mite_prep_dma(struct mite_channel *
 		dcr |= CR_PSIZE32;
 		break;
 	default:
-		printk
-			("mite: bug! invalid dev bit width for dma transfer\n");
+		printk("mite: bug! invalid dev bit width for dma transfer\n");
 		break;
 	}
 	writel(dcr, mite->mite_io_addr + MITE_DCR(mite_chan->channel));
@@ -448,7 +458,7 @@ void mite_prep_dma(struct mite_channel *
 
 	/* starting address for link chaining */
 	writel(mite_chan->ring->descriptors_dma_addr,
-		mite->mite_io_addr + MITE_LKAR(mite_chan->channel));
+	       mite->mite_io_addr + MITE_LKAR(mite_chan->channel));
 
 	MDPRINTK("exit mite_prep_dma\n");
 }
@@ -459,15 +469,15 @@ u32 mite_device_bytes_transferred(struct
 	return readl(mite->mite_io_addr + MITE_DAR(mite_chan->channel));
 }
 
-u32 mite_bytes_in_transit(struct mite_channel *mite_chan)
+u32 mite_bytes_in_transit(struct mite_channel * mite_chan)
 {
 	struct mite_struct *mite = mite_chan->mite;
 	return readl(mite->mite_io_addr +
-		MITE_FCR(mite_chan->channel)) & 0x000000FF;
+		     MITE_FCR(mite_chan->channel)) & 0x000000FF;
 }
 
 /*  returns lower bound for number of bytes transferred from device to memory */
-u32 mite_bytes_written_to_memory_lb(struct mite_channel *mite_chan)
+u32 mite_bytes_written_to_memory_lb(struct mite_channel * mite_chan)
 {
 	u32 device_byte_count;
 
@@ -476,7 +486,7 @@ u32 mite_bytes_written_to_memory_lb(stru
 }
 
 /*  returns upper bound for number of bytes transferred from device to memory */
-u32 mite_bytes_written_to_memory_ub(struct mite_channel *mite_chan)
+u32 mite_bytes_written_to_memory_ub(struct mite_channel * mite_chan)
 {
 	u32 in_transit_count;
 
@@ -485,7 +495,7 @@ u32 mite_bytes_written_to_memory_ub(stru
 }
 
 /*  returns lower bound for number of bytes read from memory for transfer to device */
-u32 mite_bytes_read_from_memory_lb(struct mite_channel *mite_chan)
+u32 mite_bytes_read_from_memory_lb(struct mite_channel * mite_chan)
 {
 	u32 device_byte_count;
 
@@ -494,7 +504,7 @@ u32 mite_bytes_read_from_memory_lb(struc
 }
 
 /*  returns upper bound for number of bytes read from memory for transfer to device */
-u32 mite_bytes_read_from_memory_ub(struct mite_channel *mite_chan)
+u32 mite_bytes_read_from_memory_ub(struct mite_channel * mite_chan)
 {
 	u32 in_transit_count;
 
@@ -511,7 +521,7 @@ unsigned mite_dma_tcr(struct mite_channe
 	lkar = readl(mite->mite_io_addr + MITE_LKAR(mite_chan->channel));
 	tcr = readl(mite->mite_io_addr + MITE_TCR(mite_chan->channel));
 	MDPRINTK("mite_dma_tcr ch%i, lkar=0x%08x tcr=%d\n", mite_chan->channel,
-		lkar, tcr);
+		 lkar, tcr);
 
 	return tcr;
 }
@@ -526,7 +536,8 @@ void mite_dma_disarm(struct mite_channel
 	writel(chor, mite->mite_io_addr + MITE_CHOR(mite_chan->channel));
 }
 
-int mite_sync_input_dma(struct mite_channel *mite_chan, struct comedi_async * async)
+int mite_sync_input_dma(struct mite_channel *mite_chan,
+			struct comedi_async *async)
 {
 	int count;
 	unsigned int nbytes, old_alloc_count;
@@ -538,7 +549,7 @@ int mite_sync_input_dma(struct mite_chan
 
 	nbytes = mite_bytes_written_to_memory_lb(mite_chan);
 	if ((int)(mite_bytes_written_to_memory_ub(mite_chan) -
-			old_alloc_count) > 0) {
+		  old_alloc_count) > 0) {
 		printk("mite: DMA overwrite of free area\n");
 		async->events |= COMEDI_CB_OVERFLOW;
 		return -1;
@@ -561,24 +572,25 @@ int mite_sync_input_dma(struct mite_chan
 	return 0;
 }
 
-int mite_sync_output_dma(struct mite_channel *mite_chan, struct comedi_async * async)
+int mite_sync_output_dma(struct mite_channel *mite_chan,
+			 struct comedi_async *async)
 {
 	int count;
 	u32 nbytes_ub, nbytes_lb;
 	unsigned int old_alloc_count;
 	u32 stop_count =
-		async->cmd.stop_arg * cfc_bytes_per_scan(async->subdevice);
+	    async->cmd.stop_arg * cfc_bytes_per_scan(async->subdevice);
 
 	old_alloc_count = async->buf_read_alloc_count;
 	/*  read alloc as much as we can */
 	comedi_buf_read_alloc(async, async->prealloc_bufsz);
 	nbytes_lb = mite_bytes_read_from_memory_lb(mite_chan);
 	if (async->cmd.stop_src == TRIG_COUNT &&
-		(int)(nbytes_lb - stop_count) > 0)
+	    (int)(nbytes_lb - stop_count) > 0)
 		nbytes_lb = stop_count;
 	nbytes_ub = mite_bytes_read_from_memory_ub(mite_chan);
 	if (async->cmd.stop_src == TRIG_COUNT &&
-		(int)(nbytes_ub - stop_count) > 0)
+	    (int)(nbytes_ub - stop_count) > 0)
 		nbytes_ub = stop_count;
 	if ((int)(nbytes_ub - old_alloc_count) > 0) {
 		printk("mite: DMA underrun\n");
@@ -607,7 +619,7 @@ unsigned mite_get_status(struct mite_cha
 	if (status & CHSR_DONE) {
 		mite_chan->done = 1;
 		writel(CHOR_CLRDONE,
-			mite->mite_io_addr + MITE_CHOR(mite_chan->channel));
+		       mite->mite_io_addr + MITE_CHOR(mite_chan->channel));
 	}
 	mmiowb();
 	spin_unlock_irqrestore(&mite->lock, flags);
@@ -703,7 +715,7 @@ static const char *const mite_CHSR_strin
 void mite_dump_regs(struct mite_channel *mite_chan)
 {
 	unsigned long mite_io_addr =
-		(unsigned long)mite_chan->mite->mite_io_addr;
+	    (unsigned long)mite_chan->mite->mite_io_addr;
 	unsigned long addr = 0;
 	unsigned long temp = 0;
 
@@ -712,37 +724,37 @@ void mite_dump_regs(struct mite_channel 
 
 	addr = mite_io_addr + MITE_CHOR(channel);
 	printk("mite status[CHOR]at 0x%08lx =0x%08lx\n", addr, temp =
-		readl(addr));
+	       readl(addr));
 	mite_decode(mite_CHOR_strings, temp);
 	addr = mite_io_addr + MITE_CHCR(channel);
 	printk("mite status[CHCR]at 0x%08lx =0x%08lx\n", addr, temp =
-		readl(addr));
+	       readl(addr));
 	mite_decode(mite_CHCR_strings, temp);
 	addr = mite_io_addr + MITE_TCR(channel);
 	printk("mite status[TCR] at 0x%08lx =0x%08x\n", addr, readl(addr));
 	addr = mite_io_addr + MITE_MCR(channel);
 	printk("mite status[MCR] at 0x%08lx =0x%08lx\n", addr, temp =
-		readl(addr));
+	       readl(addr));
 	mite_decode(mite_MCR_strings, temp);
 
 	addr = mite_io_addr + MITE_MAR(channel);
 	printk("mite status[MAR] at 0x%08lx =0x%08x\n", addr, readl(addr));
 	addr = mite_io_addr + MITE_DCR(channel);
 	printk("mite status[DCR] at 0x%08lx =0x%08lx\n", addr, temp =
-		readl(addr));
+	       readl(addr));
 	mite_decode(mite_DCR_strings, temp);
 	addr = mite_io_addr + MITE_DAR(channel);
 	printk("mite status[DAR] at 0x%08lx =0x%08x\n", addr, readl(addr));
 	addr = mite_io_addr + MITE_LKCR(channel);
 	printk("mite status[LKCR]at 0x%08lx =0x%08lx\n", addr, temp =
-		readl(addr));
+	       readl(addr));
 	mite_decode(mite_LKCR_strings, temp);
 	addr = mite_io_addr + MITE_LKAR(channel);
 	printk("mite status[LKAR]at 0x%08lx =0x%08x\n", addr, readl(addr));
 
 	addr = mite_io_addr + MITE_CHSR(channel);
 	printk("mite status[CHSR]at 0x%08lx =0x%08lx\n", addr, temp =
-		readl(addr));
+	       readl(addr));
 	mite_decode(mite_CHSR_strings, temp);
 	addr = mite_io_addr + MITE_FCR(channel);
 	printk("mite status[FCR] at 0x%08lx =0x%08x\n\n", addr, readl(addr));
--- a/drivers/staging/comedi/drivers/mite.h
+++ b/drivers/staging/comedi/drivers/mite.h
@@ -80,10 +80,11 @@ struct mite_struct {
 };
 
 static inline struct mite_dma_descriptor_ring *mite_alloc_ring(struct
-	mite_struct *mite)
+							       mite_struct
+							       *mite)
 {
 	struct mite_dma_descriptor_ring *ring =
-		kmalloc(sizeof(struct mite_dma_descriptor_ring), GFP_KERNEL);
+	    kmalloc(sizeof(struct mite_dma_descriptor_ring), GFP_KERNEL);
 	if (ring == NULL)
 		return ring;
 	ring->hw_dev = get_device(&mite->pcidev->dev);
@@ -102,9 +103,10 @@ static inline void mite_free_ring(struct
 	if (ring) {
 		if (ring->descriptors) {
 			dma_free_coherent(ring->hw_dev,
-				ring->n_links *
-				sizeof(struct mite_dma_descriptor),
-				ring->descriptors, ring->descriptors_dma_addr);
+					  ring->n_links *
+					  sizeof(struct mite_dma_descriptor),
+					  ring->descriptors,
+					  ring->descriptors_dma_addr);
 		}
 		put_device(ring->hw_dev);
 		kfree(ring);
@@ -117,6 +119,7 @@ static inline unsigned int mite_irq(stru
 {
 	return mite->pcidev->irq;
 };
+
 static inline unsigned int mite_device_id(struct mite_struct *mite)
 {
 	return mite->pcidev->device;
@@ -129,21 +132,29 @@ int mite_setup2(struct mite_struct *mite
 void mite_unsetup(struct mite_struct *mite);
 void mite_list_devices(void);
 struct mite_channel *mite_request_channel_in_range(struct mite_struct *mite,
-	struct mite_dma_descriptor_ring *ring, unsigned min_channel,
-	unsigned max_channel);
+						   struct
+						   mite_dma_descriptor_ring
+						   *ring, unsigned min_channel,
+						   unsigned max_channel);
 static inline struct mite_channel *mite_request_channel(struct mite_struct
-	*mite, struct mite_dma_descriptor_ring *ring)
+							*mite,
+							struct
+							mite_dma_descriptor_ring
+							*ring)
 {
 	return mite_request_channel_in_range(mite, ring, 0,
-		mite->num_channels - 1);
+					     mite->num_channels - 1);
 }
+
 void mite_release_channel(struct mite_channel *mite_chan);
 
 unsigned mite_dma_tcr(struct mite_channel *mite_chan);
 void mite_dma_arm(struct mite_channel *mite_chan);
 void mite_dma_disarm(struct mite_channel *mite_chan);
-int mite_sync_input_dma(struct mite_channel *mite_chan, struct comedi_async * async);
-int mite_sync_output_dma(struct mite_channel *mite_chan, struct comedi_async * async);
+int mite_sync_input_dma(struct mite_channel *mite_chan,
+			struct comedi_async *async);
+int mite_sync_output_dma(struct mite_channel *mite_chan,
+			 struct comedi_async *async);
 u32 mite_bytes_written_to_memory_lb(struct mite_channel *mite_chan);
 u32 mite_bytes_written_to_memory_ub(struct mite_channel *mite_chan);
 u32 mite_bytes_read_from_memory_lb(struct mite_channel *mite_chan);
@@ -153,16 +164,16 @@ unsigned mite_get_status(struct mite_cha
 int mite_done(struct mite_channel *mite_chan);
 
 #if 0
-unsigned long mite_ll_from_kvmem(struct mite_struct *mite, struct comedi_async * async,
-	int len);
+unsigned long mite_ll_from_kvmem(struct mite_struct *mite,
+				 struct comedi_async *async, int len);
 void mite_setregs(struct mite_struct *mite, unsigned long ll_start, int chan,
-	int dir);
+		  int dir);
 #endif
 
 void mite_prep_dma(struct mite_channel *mite_chan,
-	unsigned int num_device_bits, unsigned int num_memory_bits);
+		   unsigned int num_device_bits, unsigned int num_memory_bits);
 int mite_buf_change(struct mite_dma_descriptor_ring *ring,
-	struct comedi_async *async);
+		    struct comedi_async *async);
 
 #ifdef DEBUG_MITE
 void mite_print_chsr(unsigned int chsr);
@@ -185,72 +196,88 @@ enum mite_registers {
 	MITE_PCI_CONFIG_OFFSET = 0x300,
 	MITE_CSIGR = 0x460	/* chip signature */
 };
-static inline int MITE_CHOR(int channel)	/*  channel operation */
-{
+static inline int MITE_CHOR(int channel)
+{				/*  channel operation */
 	return CHAN_OFFSET(channel) + 0x0;
 };
-static inline int MITE_CHCR(int channel)	/*  channel control */
-{
+
+static inline int MITE_CHCR(int channel)
+{				/*  channel control */
 	return CHAN_OFFSET(channel) + 0x4;
 };
-static inline int MITE_TCR(int channel)	/*  transfer count */
-{
+
+static inline int MITE_TCR(int channel)
+{				/*  transfer count */
 	return CHAN_OFFSET(channel) + 0x8;
 };
-static inline int MITE_MCR(int channel)	/*  memory configuration */
-{
+
+static inline int MITE_MCR(int channel)
+{				/*  memory configuration */
 	return CHAN_OFFSET(channel) + 0xc;
 };
-static inline int MITE_MAR(int channel)	/*  memory address */
-{
+
+static inline int MITE_MAR(int channel)
+{				/*  memory address */
 	return CHAN_OFFSET(channel) + 0x10;
 };
-static inline int MITE_DCR(int channel)	/*  device configuration */
-{
+
+static inline int MITE_DCR(int channel)
+{				/*  device configuration */
 	return CHAN_OFFSET(channel) + 0x14;
 };
-static inline int MITE_DAR(int channel)	/*  device address */
-{
+
+static inline int MITE_DAR(int channel)
+{				/*  device address */
 	return CHAN_OFFSET(channel) + 0x18;
 };
-static inline int MITE_LKCR(int channel)	/*  link configuration */
-{
+
+static inline int MITE_LKCR(int channel)
+{				/*  link configuration */
 	return CHAN_OFFSET(channel) + 0x1c;
 };
-static inline int MITE_LKAR(int channel)	/*  link address */
-{
+
+static inline int MITE_LKAR(int channel)
+{				/*  link address */
 	return CHAN_OFFSET(channel) + 0x20;
 };
-static inline int MITE_LLKAR(int channel)	/*  see mite section of tnt5002 manual */
-{
+
+static inline int MITE_LLKAR(int channel)
+{				/*  see mite section of tnt5002 manual */
 	return CHAN_OFFSET(channel) + 0x24;
 };
-static inline int MITE_BAR(int channel)	/*  base address */
-{
+
+static inline int MITE_BAR(int channel)
+{				/*  base address */
 	return CHAN_OFFSET(channel) + 0x28;
 };
-static inline int MITE_BCR(int channel)	/*  base count */
-{
+
+static inline int MITE_BCR(int channel)
+{				/*  base count */
 	return CHAN_OFFSET(channel) + 0x2c;
 };
-static inline int MITE_SAR(int channel)	/*  ? address */
-{
+
+static inline int MITE_SAR(int channel)
+{				/*  ? address */
 	return CHAN_OFFSET(channel) + 0x30;
 };
-static inline int MITE_WSCR(int channel)	/*  ? */
-{
+
+static inline int MITE_WSCR(int channel)
+{				/*  ? */
 	return CHAN_OFFSET(channel) + 0x34;
 };
-static inline int MITE_WSER(int channel)	/*  ? */
-{
+
+static inline int MITE_WSER(int channel)
+{				/*  ? */
 	return CHAN_OFFSET(channel) + 0x38;
 };
-static inline int MITE_CHSR(int channel)	/*  channel status */
-{
+
+static inline int MITE_CHSR(int channel)
+{				/*  channel status */
 	return CHAN_OFFSET(channel) + 0x3c;
 };
-static inline int MITE_FCR(int channel)	/*  fifo count */
-{
+
+static inline int MITE_FCR(int channel)
+{				/*  fifo count */
 	return CHAN_OFFSET(channel) + 0x40;
 };
 
@@ -275,22 +302,27 @@ static inline int mite_csigr_version(u32
 {
 	return csigr_bits & 0xf;
 };
+
 static inline int mite_csigr_type(u32 csigr_bits)
 {				/*  original mite = 0, minimite = 1 */
 	return (csigr_bits >> 4) & 0xf;
 };
+
 static inline int mite_csigr_mmode(u32 csigr_bits)
 {				/*  mite mode, minimite = 1 */
 	return (csigr_bits >> 8) & 0x3;
 };
+
 static inline int mite_csigr_imode(u32 csigr_bits)
 {				/*  cpu port interface mode, pci = 0x3 */
 	return (csigr_bits >> 12) & 0x3;
 };
+
 static inline int mite_csigr_dmac(u32 csigr_bits)
 {				/*  number of dma channels */
 	return (csigr_bits >> 16) & 0xf;
 };
+
 static inline int mite_csigr_wpdep(u32 csigr_bits)
 {				/*  write post fifo depth */
 	unsigned int wpdep_bits = (csigr_bits >> 20) & 0x7;
@@ -299,10 +331,12 @@ static inline int mite_csigr_wpdep(u32 c
 	else
 		return 1 << (wpdep_bits - 1);
 };
+
 static inline int mite_csigr_wins(u32 csigr_bits)
 {
 	return (csigr_bits >> 24) & 0x1f;
 };
+
 static inline int mite_csigr_iowins(u32 csigr_bits)
 {				/*  number of io windows */
 	return (csigr_bits >> 29) & 0x7;
@@ -366,9 +400,9 @@ enum MITE_CHCR_bits {
 	CHCR_LINKSHORT = (4 << 0),
 	CHCR_LINKLONG = (5 << 0),
 	CHCRPON =
-		(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE | CHCR_CLR_SAR_IE |
-		CHCR_CLR_DONE_IE | CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |
-		CHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE),
+	    (CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE | CHCR_CLR_SAR_IE |
+	     CHCR_CLR_DONE_IE | CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |
+	     CHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE),
 };
 
 enum ConfigRegister_bits {
@@ -390,12 +424,14 @@ static inline int CR_REQS(int source)
 {
 	return (source & 0x7) << 16;
 };
+
 static inline int CR_REQSDRQ(unsigned drq_line)
 {
 	/* This also works on m-series when
 	   using channels (drq_line) 4 or 5. */
 	return CR_REQS((drq_line & 0x3) | 0x4);
 }
+
 static inline int CR_RL(unsigned int retry_limit)
 {
 	int value = 0;
@@ -447,7 +483,7 @@ enum CHSR_bits {
 static inline void mite_dma_reset(struct mite_channel *mite_chan)
 {
 	writel(CHOR_DMARESET | CHOR_FRESET,
-		mite_chan->mite->mite_io_addr + MITE_CHOR(mite_chan->channel));
+	       mite_chan->mite->mite_io_addr + MITE_CHOR(mite_chan->channel));
 };
 
 #endif
--- a/drivers/staging/comedi/drivers/mpc624.c
+++ b/drivers/staging/comedi/drivers/mpc624.c
@@ -125,28 +125,29 @@ struct skel_private {
 	unsigned long int ulConvertionRate;	/*  set by mpc624_attach() from driver's parameters */
 };
 
-
 #define devpriv ((struct skel_private *)dev->private)
 /* ---------------------------------------------------------------------------- */
 static const struct comedi_lrange range_mpc624_bipolar1 = {
 	1,
 	{
 /* BIP_RANGE(1.01)  this is correct, */
-			/*  but my MPC-624 actually seems to have a range of 2.02 */
-			BIP_RANGE(2.02)
-		}
+	 /*  but my MPC-624 actually seems to have a range of 2.02 */
+	 BIP_RANGE(2.02)
+	 }
 };
+
 static const struct comedi_lrange range_mpc624_bipolar10 = {
 	1,
 	{
 /* BIP_RANGE(10.1)   this is correct, */
-			/*  but my MPC-624 actually seems to have a range of 20.2 */
-			BIP_RANGE(20.2)
-		}
+	 /*  but my MPC-624 actually seems to have a range of 20.2 */
+	 BIP_RANGE(20.2)
+	 }
 };
 
 /* ---------------------------------------------------------------------------- */
-static int mpc624_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int mpc624_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int mpc624_detach(struct comedi_device *dev);
 /* ---------------------------------------------------------------------------- */
 static struct comedi_driver driver_mpc624 = {
@@ -157,8 +158,9 @@ static struct comedi_driver driver_mpc62
 };
 
 /* ---------------------------------------------------------------------------- */
-static int mpc624_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int mpc624_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
 /* ---------------------------------------------------------------------------- */
 static int mpc624_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
@@ -222,7 +224,7 @@ static int mpc624_attach(struct comedi_d
 		break;
 	default:
 		printk
-			("illegal convertion rate setting! Valid numbers are 0..9. Using 9 => 6.875 Hz, ");
+		    ("illegal convertion rate setting! Valid numbers are 0..9. Using 9 => 6.875 Hz, ");
 		devpriv->ulConvertionRate = MPC624_SPEED_3_52_kHz;
 	}
 
@@ -270,8 +272,9 @@ static int mpc624_detach(struct comedi_d
 /* Timeout 200ms */
 #define TIMEOUT 200
 
-static int mpc624_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int mpc624_ai_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int n, i;
 	unsigned long int data_in, data_out;
@@ -316,16 +319,15 @@ static int mpc624_ai_rinsn(struct comedi
 			outb(0, dev->iobase + MPC624_ADC);
 			udelay(1);
 
-			if (data_out & (1 << 31))	/*  the next bit is a 1 */
-			{
+			if (data_out & (1 << 31)) {	/*  the next bit is a 1 */
 				/*  Set the ADSDI line (send to MPC624) */
 				outb(MPC624_ADSDI, dev->iobase + MPC624_ADC);
 				udelay(1);
 				/*  Set the clock high */
 				outb(MPC624_ADSCK | MPC624_ADSDI,
-					dev->iobase + MPC624_ADC);
-			} else	/*  the next bit is a 0 */
-			{
+				     dev->iobase + MPC624_ADC);
+			} else {	/*  the next bit is a 0 */
+
 				/*  Set the ADSDI line (send to MPC624) */
 				outb(0, dev->iobase + MPC624_ADC);
 				udelay(1);
@@ -336,8 +338,7 @@ static int mpc624_ai_rinsn(struct comedi
 			udelay(1);
 			data_in <<= 1;
 			data_in |=
-				(inb(dev->iobase +
-					MPC624_ADC) & MPC624_ADSDO) >> 4;
+			    (inb(dev->iobase + MPC624_ADC) & MPC624_ADSDO) >> 4;
 			udelay(1);
 
 			data_out <<= 1;
@@ -358,12 +359,11 @@ static int mpc624_ai_rinsn(struct comedi
 
 		if (data_in & MPC624_EOC_BIT)
 			printk("MPC624: EOC bit is set (data_in=%lu)!",
-				data_in);
+			       data_in);
 		if (data_in & MPC624_DMY_BIT)
 			printk("MPC624: DMY bit is set (data_in=%lu)!",
-				data_in);
-		if (data_in & MPC624_SGN_BIT)	/*  check the sign bit */
-		{		/*  The voltage is positive */
+			       data_in);
+		if (data_in & MPC624_SGN_BIT) {	/*  check the sign bit *//*  The voltage is positive */
 			data_in &= 0x3FFFFFFF;	/*  EOC and DMY should be 0, but we will mask them out just to be sure */
 			data[n] = data_in;	/*  comedi operates on unsigned numbers, so we don't clear the SGN bit */
 			/*  SGN bit is still set! It's correct, since we're converting to unsigned. */
--- a/drivers/staging/comedi/drivers/mpc8260cpm.c
+++ b/drivers/staging/comedi/drivers/mpc8260cpm.c
@@ -46,7 +46,8 @@ struct mpc8260cpm_private {
 
 #define devpriv ((struct mpc8260cpm_private *)dev->private)
 
-static int mpc8260cpm_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int mpc8260cpm_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it);
 static int mpc8260cpm_detach(struct comedi_device *dev);
 static struct comedi_driver driver_mpc8260cpm = {
 	.driver_name = "mpc8260cpm",
@@ -57,12 +58,15 @@ static struct comedi_driver driver_mpc82
 
 COMEDI_INITCLEANUP(driver_mpc8260cpm);
 
-static int mpc8260cpm_dio_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int mpc8260cpm_dio_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int mpc8260cpm_dio_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int mpc8260cpm_dio_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
-static int mpc8260cpm_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int mpc8260cpm_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int i;
@@ -114,8 +118,9 @@ static unsigned long *cpm_pdat(int port)
 	}
 }
 
-static int mpc8260cpm_dio_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int mpc8260cpm_dio_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	unsigned int d;
@@ -157,8 +162,9 @@ static int mpc8260cpm_dio_config(struct 
 	return 1;
 }
 
-static int mpc8260cpm_dio_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int mpc8260cpm_dio_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int port;
 	unsigned long *p;
--- a/drivers/staging/comedi/drivers/multiq3.c
+++ b/drivers/staging/comedi/drivers/multiq3.c
@@ -83,7 +83,8 @@ Devices: [Quanser Consulting] MultiQ-3 (
 
 #define MULTIQ3_TIMEOUT 30
 
-static int multiq3_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int multiq3_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int multiq3_detach(struct comedi_device *dev);
 static struct comedi_driver driver_multiq3 = {
 	.driver_name = "multiq3",
@@ -99,8 +100,9 @@ struct multiq3_private {
 };
 #define devpriv ((struct multiq3_private *)dev->private)
 
-static int multiq3_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int multiq3_ai_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan;
@@ -108,7 +110,7 @@ static int multiq3_ai_insn_read(struct c
 
 	chan = CR_CHAN(insn->chanspec);
 	outw(MULTIQ3_CONTROL_MUST | MULTIQ3_AD_MUX_EN | (chan << 3),
-		dev->iobase + MULTIQ3_CONTROL);
+	     dev->iobase + MULTIQ3_CONTROL);
 
 	for (i = 0; i < MULTIQ3_TIMEOUT; i++) {
 		if (inw(dev->iobase + MULTIQ3_STATUS) & MULTIQ3_STATUS_EOC)
@@ -121,7 +123,7 @@ static int multiq3_ai_insn_read(struct c
 		outw(0, dev->iobase + MULTIQ3_AD_CS);
 		for (i = 0; i < MULTIQ3_TIMEOUT; i++) {
 			if (inw(dev->iobase +
-					MULTIQ3_STATUS) & MULTIQ3_STATUS_EOC_I)
+				MULTIQ3_STATUS) & MULTIQ3_STATUS_EOC_I)
 				break;
 		}
 		if (i == MULTIQ3_TIMEOUT)
@@ -135,8 +137,9 @@ static int multiq3_ai_insn_read(struct c
 	return n;
 }
 
-static int multiq3_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int multiq3_ao_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -148,15 +151,16 @@ static int multiq3_ao_insn_read(struct c
 	return i;
 }
 
-static int multiq3_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int multiq3_ao_insn_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 
 	for (i = 0; i < insn->n; i++) {
 		outw(MULTIQ3_CONTROL_MUST | MULTIQ3_DA_LOAD | chan,
-			dev->iobase + MULTIQ3_CONTROL);
+		     dev->iobase + MULTIQ3_CONTROL);
 		outw(data[i], dev->iobase + MULTIQ3_DAC_DATA);
 		outw(MULTIQ3_CONTROL_MUST, dev->iobase + MULTIQ3_CONTROL);
 
@@ -166,8 +170,9 @@ static int multiq3_ao_insn_write(struct 
 	return i;
 }
 
-static int multiq3_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int multiq3_di_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -177,8 +182,9 @@ static int multiq3_di_insn_bits(struct c
 	return 2;
 }
 
-static int multiq3_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int multiq3_do_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -192,8 +198,10 @@ static int multiq3_do_insn_bits(struct c
 	return 2;
 }
 
-static int multiq3_encoder_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int multiq3_encoder_insn_read(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -218,7 +226,7 @@ static void encoder_reset(struct comedi_
 	int chan;
 	for (chan = 0; chan < dev->subdevices[4].n_chan; chan++) {
 		int control =
-			MULTIQ3_CONTROL_MUST | MULTIQ3_AD_MUX_EN | (chan << 3);
+		    MULTIQ3_CONTROL_MUST | MULTIQ3_AD_MUX_EN | (chan << 3);
 		outw(control, dev->iobase + MULTIQ3_CONTROL);
 		outb(MULTIQ3_EFLAG_RESET, dev->iobase + MULTIQ3_ENC_CONTROL);
 		outb(MULTIQ3_BP_RESET, dev->iobase + MULTIQ3_ENC_CONTROL);
@@ -236,7 +244,8 @@ static void encoder_reset(struct comedi_
    options[2] - number of encoder chips installed
  */
 
-static int multiq3_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int multiq3_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	int result = 0;
 	unsigned long iobase;
--- a/drivers/staging/comedi/drivers/ni_6527.c
+++ b/drivers/staging/comedi/drivers/ni_6527.c
@@ -76,7 +76,8 @@ Updated: Sat, 25 Jan 2003 13:24:40 -0800
 #define Rising_Edge_Detection_Enable(x)		(0x018+(x))
 #define Falling_Edge_Detection_Enable(x)	(0x020+(x))
 
-static int ni6527_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int ni6527_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int ni6527_detach(struct comedi_device *dev);
 static struct comedi_driver driver_ni6527 = {
 	.driver_name = "ni6527",
@@ -93,22 +94,23 @@ struct ni6527_board {
 
 static const struct ni6527_board ni6527_boards[] = {
 	{
-	.dev_id = 0x2b20,
-	.name = "pci-6527",
-		},
+	 .dev_id = 0x2b20,
+	 .name = "pci-6527",
+	 },
 	{
-	.dev_id = 0x2b10,
-	.name = "pxi-6527",
-		},
+	 .dev_id = 0x2b10,
+	 .name = "pxi-6527",
+	 },
 };
 
 #define n_ni6527_boards (sizeof(ni6527_boards)/sizeof(ni6527_boards[0]))
 #define this_board ((const struct ni6527_board *)dev->board_ptr)
 
 static DEFINE_PCI_DEVICE_TABLE(ni6527_pci_table) = {
-	{PCI_VENDOR_ID_NATINST, 0x2b10, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2b20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_NATINST, 0x2b10, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2b20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, ni6527_pci_table);
@@ -123,8 +125,9 @@ struct ni6527_private {
 
 static int ni6527_find_device(struct comedi_device *dev, int bus, int slot);
 
-static int ni6527_di_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni6527_di_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned int interval;
@@ -141,17 +144,14 @@ static int ni6527_di_insn_config(struct 
 
 		if (interval != devpriv->filter_interval) {
 			writeb(interval & 0xff,
-				devpriv->mite->daq_io_addr +
-				Filter_Interval(0));
+			       devpriv->mite->daq_io_addr + Filter_Interval(0));
 			writeb((interval >> 8) & 0xff,
-				devpriv->mite->daq_io_addr +
-				Filter_Interval(1));
+			       devpriv->mite->daq_io_addr + Filter_Interval(1));
 			writeb((interval >> 16) & 0x0f,
-				devpriv->mite->daq_io_addr +
-				Filter_Interval(2));
+			       devpriv->mite->daq_io_addr + Filter_Interval(2));
 
 			writeb(ClrInterval,
-				devpriv->mite->daq_io_addr + Clear_Register);
+			       devpriv->mite->daq_io_addr + Clear_Register);
 
 			devpriv->filter_interval = interval;
 		}
@@ -162,17 +162,18 @@ static int ni6527_di_insn_config(struct 
 	}
 
 	writeb(devpriv->filter_enable,
-		devpriv->mite->daq_io_addr + Filter_Enable(0));
+	       devpriv->mite->daq_io_addr + Filter_Enable(0));
 	writeb(devpriv->filter_enable >> 8,
-		devpriv->mite->daq_io_addr + Filter_Enable(1));
+	       devpriv->mite->daq_io_addr + Filter_Enable(1));
 	writeb(devpriv->filter_enable >> 16,
-		devpriv->mite->daq_io_addr + Filter_Enable(2));
+	       devpriv->mite->daq_io_addr + Filter_Enable(2));
 
 	return 2;
 }
 
-static int ni6527_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni6527_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -184,8 +185,9 @@ static int ni6527_di_insn_bits(struct co
 	return 2;
 }
 
-static int ni6527_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni6527_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -197,15 +199,15 @@ static int ni6527_do_insn_bits(struct co
 		 * but in Comedi, it is represented by 0. */
 		if (data[0] & 0x0000ff) {
 			writeb((s->state ^ 0xff),
-				devpriv->mite->daq_io_addr + Port_Register(3));
+			       devpriv->mite->daq_io_addr + Port_Register(3));
 		}
 		if (data[0] & 0x00ff00) {
 			writeb((s->state >> 8) ^ 0xff,
-				devpriv->mite->daq_io_addr + Port_Register(4));
+			       devpriv->mite->daq_io_addr + Port_Register(4));
 		}
 		if (data[0] & 0xff0000) {
 			writeb((s->state >> 16) ^ 0xff,
-				devpriv->mite->daq_io_addr + Port_Register(5));
+			       devpriv->mite->daq_io_addr + Port_Register(5));
 		}
 	}
 	data[1] = s->state;
@@ -226,7 +228,7 @@ static irqreturn_t ni6527_interrupt(int 
 		return IRQ_NONE;
 
 	writeb(ClrEdge | ClrOverflow,
-		devpriv->mite->daq_io_addr + Clear_Register);
+	       devpriv->mite->daq_io_addr + Clear_Register);
 
 	comedi_buf_put(s->async, 0);
 	s->async->events |= COMEDI_CB_EOS;
@@ -234,8 +236,9 @@ static irqreturn_t ni6527_interrupt(int 
 	return IRQ_HANDLED;
 }
 
-static int ni6527_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int ni6527_intr_cmdtest(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -310,28 +313,31 @@ static int ni6527_intr_cmdtest(struct co
 	return 0;
 }
 
-static int ni6527_intr_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int ni6527_intr_cmd(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	/* struct comedi_cmd *cmd = &s->async->cmd; */
 
 	writeb(ClrEdge | ClrOverflow,
-		devpriv->mite->daq_io_addr + Clear_Register);
+	       devpriv->mite->daq_io_addr + Clear_Register);
 	writeb(FallingEdgeIntEnable | RisingEdgeIntEnable |
-		MasterInterruptEnable | EdgeIntEnable,
-		devpriv->mite->daq_io_addr + Master_Interrupt_Control);
+	       MasterInterruptEnable | EdgeIntEnable,
+	       devpriv->mite->daq_io_addr + Master_Interrupt_Control);
 
 	return 0;
 }
 
-static int ni6527_intr_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int ni6527_intr_cancel(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	writeb(0x00, devpriv->mite->daq_io_addr + Master_Interrupt_Control);
 
 	return 0;
 }
 
-static int ni6527_intr_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni6527_intr_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -340,8 +346,9 @@ static int ni6527_intr_insn_bits(struct 
 	return 2;
 }
 
-static int ni6527_intr_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni6527_intr_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -349,18 +356,18 @@ static int ni6527_intr_insn_config(struc
 		return -EINVAL;
 
 	writeb(data[1],
-		devpriv->mite->daq_io_addr + Rising_Edge_Detection_Enable(0));
+	       devpriv->mite->daq_io_addr + Rising_Edge_Detection_Enable(0));
 	writeb(data[1] >> 8,
-		devpriv->mite->daq_io_addr + Rising_Edge_Detection_Enable(1));
+	       devpriv->mite->daq_io_addr + Rising_Edge_Detection_Enable(1));
 	writeb(data[1] >> 16,
-		devpriv->mite->daq_io_addr + Rising_Edge_Detection_Enable(2));
+	       devpriv->mite->daq_io_addr + Rising_Edge_Detection_Enable(2));
 
 	writeb(data[2],
-		devpriv->mite->daq_io_addr + Falling_Edge_Detection_Enable(0));
+	       devpriv->mite->daq_io_addr + Falling_Edge_Detection_Enable(0));
 	writeb(data[2] >> 8,
-		devpriv->mite->daq_io_addr + Falling_Edge_Detection_Enable(1));
+	       devpriv->mite->daq_io_addr + Falling_Edge_Detection_Enable(1));
 	writeb(data[2] >> 16,
-		devpriv->mite->daq_io_addr + Falling_Edge_Detection_Enable(2));
+	       devpriv->mite->daq_io_addr + Falling_Edge_Detection_Enable(2));
 
 	return 2;
 }
@@ -430,7 +437,7 @@ static int ni6527_attach(struct comedi_d
 	writeb(0x00, devpriv->mite->daq_io_addr + Filter_Enable(2));
 
 	writeb(ClrEdge | ClrOverflow | ClrFilter | ClrInterval,
-		devpriv->mite->daq_io_addr + Clear_Register);
+	       devpriv->mite->daq_io_addr + Clear_Register);
 	writeb(0x00, devpriv->mite->daq_io_addr + Master_Interrupt_Control);
 
 	ret = request_irq(mite_irq(devpriv->mite), ni6527_interrupt,
@@ -449,7 +456,7 @@ static int ni6527_detach(struct comedi_d
 {
 	if (devpriv && devpriv->mite && devpriv->mite->daq_io_addr) {
 		writeb(0x00,
-			devpriv->mite->daq_io_addr + Master_Interrupt_Control);
+		       devpriv->mite->daq_io_addr + Master_Interrupt_Control);
 	}
 
 	if (dev->irq) {
@@ -473,7 +480,7 @@ static int ni6527_find_device(struct com
 			continue;
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number ||
-				slot != PCI_SLOT(mite->pcidev->devfn))
+			    slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
 		for (i = 0; i < n_ni6527_boards; i++) {
--- a/drivers/staging/comedi/drivers/ni_65xx.c
+++ b/drivers/staging/comedi/drivers/ni_65xx.c
@@ -66,18 +66,22 @@ static inline unsigned Port_Data(unsigne
 {
 	return 0x40 + port * ni_65xx_port_offset;
 }
+
 static inline unsigned Port_Select(unsigned port)
 {
 	return 0x41 + port * ni_65xx_port_offset;
 }
+
 static inline unsigned Rising_Edge_Detection_Enable(unsigned port)
 {
 	return 0x42 + port * ni_65xx_port_offset;
 }
+
 static inline unsigned Falling_Edge_Detection_Enable(unsigned port)
 {
 	return 0x43 + port * ni_65xx_port_offset;
 }
+
 static inline unsigned Filter_Enable(unsigned port)
 {
 	return 0x44 + port * ni_65xx_port_offset;
@@ -103,7 +107,8 @@ static inline unsigned Filter_Enable(uns
 #define OverflowIntEnable		0x02
 #define EdgeIntEnable			0x01
 
-static int ni_65xx_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int ni_65xx_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int ni_65xx_detach(struct comedi_device *dev);
 static struct comedi_driver driver_ni_65xx = {
 	.driver_name = "ni_65xx",
@@ -124,161 +129,165 @@ struct ni_65xx_board {
 
 static const struct ni_65xx_board ni_65xx_boards[] = {
 	{
-	.dev_id = 0x7085,
-	.name = "pci-6509",
-	.num_dio_ports = 12,
-	.invert_outputs = 0},
-	{
-	.dev_id = 0x1710,
-	.name = "pxi-6509",
-	.num_dio_ports = 12,
-	.invert_outputs = 0},
-	{
-	.dev_id = 0x7124,
-	.name = "pci-6510",
-	.num_di_ports = 4},
-	{
-	.dev_id = 0x70c3,
-	.name = "pci-6511",
-	.num_di_ports = 8},
-	{
-	.dev_id = 0x70d3,
-	.name = "pxi-6511",
-	.num_di_ports = 8},
-	{
-	.dev_id = 0x70cc,
-	.name = "pci-6512",
-	.num_do_ports = 8},
-	{
-	.dev_id = 0x70d2,
-	.name = "pxi-6512",
-	.num_do_ports = 8},
-	{
-	.dev_id = 0x70c8,
-	.name = "pci-6513",
-	.num_do_ports = 8,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x70d1,
-	.name = "pxi-6513",
-	.num_do_ports = 8,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x7088,
-	.name = "pci-6514",
-	.num_di_ports = 4,
-	.num_do_ports = 4,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x70CD,
-	.name = "pxi-6514",
-	.num_di_ports = 4,
-	.num_do_ports = 4,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x7087,
-	.name = "pci-6515",
-	.num_di_ports = 4,
-	.num_do_ports = 4,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x70c9,
-	.name = "pxi-6515",
-	.num_di_ports = 4,
-	.num_do_ports = 4,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x7125,
-	.name = "pci-6516",
-	.num_do_ports = 4,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x7126,
-	.name = "pci-6517",
-	.num_do_ports = 4,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x7127,
-	.name = "pci-6518",
-	.num_di_ports = 2,
-	.num_do_ports = 2,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x7128,
-	.name = "pci-6519",
-	.num_di_ports = 2,
-	.num_do_ports = 2,
-	.invert_outputs = 1},
-	{
-	.dev_id = 0x71c5,
-	.name = "pci-6520",
-	.num_di_ports = 1,
-	.num_do_ports = 1,
-		},
-	{
-	.dev_id = 0x718b,
-	.name = "pci-6521",
-	.num_di_ports = 1,
-	.num_do_ports = 1,
-		},
-	{
-	.dev_id = 0x718c,
-	.name = "pxi-6521",
-	.num_di_ports = 1,
-	.num_do_ports = 1,
-		},
-	{
-	.dev_id = 0x70a9,
-	.name = "pci-6528",
-	.num_di_ports = 3,
-	.num_do_ports = 3,
-		},
-	{
-	.dev_id = 0x7086,
-	.name = "pxi-6528",
-	.num_di_ports = 3,
-	.num_do_ports = 3,
-		},
+	 .dev_id = 0x7085,
+	 .name = "pci-6509",
+	 .num_dio_ports = 12,
+	 .invert_outputs = 0},
+	{
+	 .dev_id = 0x1710,
+	 .name = "pxi-6509",
+	 .num_dio_ports = 12,
+	 .invert_outputs = 0},
+	{
+	 .dev_id = 0x7124,
+	 .name = "pci-6510",
+	 .num_di_ports = 4},
+	{
+	 .dev_id = 0x70c3,
+	 .name = "pci-6511",
+	 .num_di_ports = 8},
+	{
+	 .dev_id = 0x70d3,
+	 .name = "pxi-6511",
+	 .num_di_ports = 8},
+	{
+	 .dev_id = 0x70cc,
+	 .name = "pci-6512",
+	 .num_do_ports = 8},
+	{
+	 .dev_id = 0x70d2,
+	 .name = "pxi-6512",
+	 .num_do_ports = 8},
+	{
+	 .dev_id = 0x70c8,
+	 .name = "pci-6513",
+	 .num_do_ports = 8,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x70d1,
+	 .name = "pxi-6513",
+	 .num_do_ports = 8,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x7088,
+	 .name = "pci-6514",
+	 .num_di_ports = 4,
+	 .num_do_ports = 4,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x70CD,
+	 .name = "pxi-6514",
+	 .num_di_ports = 4,
+	 .num_do_ports = 4,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x7087,
+	 .name = "pci-6515",
+	 .num_di_ports = 4,
+	 .num_do_ports = 4,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x70c9,
+	 .name = "pxi-6515",
+	 .num_di_ports = 4,
+	 .num_do_ports = 4,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x7125,
+	 .name = "pci-6516",
+	 .num_do_ports = 4,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x7126,
+	 .name = "pci-6517",
+	 .num_do_ports = 4,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x7127,
+	 .name = "pci-6518",
+	 .num_di_ports = 2,
+	 .num_do_ports = 2,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x7128,
+	 .name = "pci-6519",
+	 .num_di_ports = 2,
+	 .num_do_ports = 2,
+	 .invert_outputs = 1},
+	{
+	 .dev_id = 0x71c5,
+	 .name = "pci-6520",
+	 .num_di_ports = 1,
+	 .num_do_ports = 1,
+	 },
+	{
+	 .dev_id = 0x718b,
+	 .name = "pci-6521",
+	 .num_di_ports = 1,
+	 .num_do_ports = 1,
+	 },
+	{
+	 .dev_id = 0x718c,
+	 .name = "pxi-6521",
+	 .num_di_ports = 1,
+	 .num_do_ports = 1,
+	 },
+	{
+	 .dev_id = 0x70a9,
+	 .name = "pci-6528",
+	 .num_di_ports = 3,
+	 .num_do_ports = 3,
+	 },
+	{
+	 .dev_id = 0x7086,
+	 .name = "pxi-6528",
+	 .num_di_ports = 3,
+	 .num_do_ports = 3,
+	 },
 };
 
 #define n_ni_65xx_boards (sizeof(ni_65xx_boards)/sizeof(ni_65xx_boards[0]))
-static inline const struct ni_65xx_board *board(struct comedi_device * dev)
+static inline const struct ni_65xx_board *board(struct comedi_device *dev)
 {
 	return dev->board_ptr;
 }
+
 static inline unsigned ni_65xx_port_by_channel(unsigned channel)
 {
 	return channel / ni_65xx_channels_per_port;
 }
-static inline unsigned ni_65xx_total_num_ports(const struct ni_65xx_board *board)
+
+static inline unsigned ni_65xx_total_num_ports(const struct ni_65xx_board
+					       *board)
 {
 	return board->num_dio_ports + board->num_di_ports + board->num_do_ports;
 }
 
 static DEFINE_PCI_DEVICE_TABLE(ni_65xx_pci_table) = {
-	{PCI_VENDOR_ID_NATINST, 0x1710, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7085, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7086, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7087, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7088, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70a9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70c3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70c8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70c9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70cc, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70CD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70d1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70d2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70d3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7124, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7125, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7126, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7127, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x7128, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x718b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x718c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x71c5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_NATINST, 0x1710, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7085, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7086, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7087, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7088, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70a9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70c3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70c8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70c9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70cc, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70CD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70d1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70d2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70d3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7124, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7125, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7126, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7127, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x7128, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x718b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x718c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x71c5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, ni_65xx_pci_table);
@@ -291,7 +300,7 @@ struct ni_65xx_private {
 	unsigned short dio_direction[NI_65XX_MAX_NUM_PORTS];
 };
 
-static inline struct ni_65xx_private *private(struct comedi_device * dev)
+static inline struct ni_65xx_private *private(struct comedi_device *dev)
 {
 	return dev->private;
 }
@@ -300,14 +309,16 @@ struct ni_65xx_subdevice_private {
 	unsigned base_port;
 };
 
-static inline struct ni_65xx_subdevice_private *sprivate(struct comedi_subdevice * subdev)
+static inline struct ni_65xx_subdevice_private *sprivate(struct comedi_subdevice
+							 *subdev)
 {
 	return subdev->private;
 }
+
 static struct ni_65xx_subdevice_private *ni_65xx_alloc_subdevice_private(void)
 {
 	struct ni_65xx_subdevice_private *subdev_private =
-		kzalloc(sizeof(struct ni_65xx_subdevice_private), GFP_KERNEL);
+	    kzalloc(sizeof(struct ni_65xx_subdevice_private), GFP_KERNEL);
 	if (subdev_private == NULL)
 		return NULL;
 	return subdev_private;
@@ -315,12 +326,13 @@ static struct ni_65xx_subdevice_private 
 
 static int ni_65xx_find_device(struct comedi_device *dev, int bus, int slot);
 
-static int ni_65xx_config_filter(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_65xx_config_filter(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	const unsigned chan = CR_CHAN(insn->chanspec);
 	const unsigned port =
-		sprivate(s)->base_port + ni_65xx_port_by_channel(chan);
+	    sprivate(s)->base_port + ni_65xx_port_by_channel(chan);
 
 	if (data[0] != INSN_CONFIG_FILTER)
 		return -EINVAL;
@@ -328,41 +340,42 @@ static int ni_65xx_config_filter(struct 
 		static const unsigned filter_resolution_ns = 200;
 		static const unsigned max_filter_interval = 0xfffff;
 		unsigned interval =
-			(data[1] +
-			(filter_resolution_ns / 2)) / filter_resolution_ns;
+		    (data[1] +
+		     (filter_resolution_ns / 2)) / filter_resolution_ns;
 		if (interval > max_filter_interval)
 			interval = max_filter_interval;
 		data[1] = interval * filter_resolution_ns;
 
 		if (interval != private(dev)->filter_interval) {
 			writeb(interval,
-				private(dev)->mite->daq_io_addr +
-				Filter_Interval);
+			       private(dev)->mite->daq_io_addr +
+			       Filter_Interval);
 			private(dev)->filter_interval = interval;
 		}
 
 		private(dev)->filter_enable[port] |=
-			1 << (chan % ni_65xx_channels_per_port);
+		    1 << (chan % ni_65xx_channels_per_port);
 	} else {
 		private(dev)->filter_enable[port] &=
-			~(1 << (chan % ni_65xx_channels_per_port));
+		    ~(1 << (chan % ni_65xx_channels_per_port));
 	}
 
 	writeb(private(dev)->filter_enable[port],
-		private(dev)->mite->daq_io_addr + Filter_Enable(port));
+	       private(dev)->mite->daq_io_addr + Filter_Enable(port));
 
 	return 2;
 }
 
-static int ni_65xx_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_65xx_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned port;
 
 	if (insn->n < 1)
 		return -EINVAL;
 	port = sprivate(s)->base_port +
-		ni_65xx_port_by_channel(CR_CHAN(insn->chanspec));
+	    ni_65xx_port_by_channel(CR_CHAN(insn->chanspec));
 	switch (data[0]) {
 	case INSN_CONFIG_FILTER:
 		return ni_65xx_config_filter(dev, s, insn, data);
@@ -393,8 +406,9 @@ static int ni_65xx_dio_insn_config(struc
 	return -EINVAL;
 }
 
-static int ni_65xx_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_65xx_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned base_bitfield_channel;
 	const unsigned max_ports_per_bitfield = 5;
@@ -405,8 +419,8 @@ static int ni_65xx_dio_insn_bits(struct 
 	base_bitfield_channel = CR_CHAN(insn->chanspec);
 	for (j = 0; j < max_ports_per_bitfield; ++j) {
 		const unsigned port =
-			sprivate(s)->base_port +
-			ni_65xx_port_by_channel(base_bitfield_channel) + j;
+		    sprivate(s)->base_port +
+		    ni_65xx_port_by_channel(base_bitfield_channel) + j;
 		unsigned base_port_channel;
 		unsigned port_mask, port_data, port_read_bits;
 		int bitshift;
@@ -431,18 +445,17 @@ static int ni_65xx_dio_insn_bits(struct 
 			unsigned bits;
 			private(dev)->output_bits[port] &= ~port_mask;
 			private(dev)->output_bits[port] |=
-				port_data & port_mask;
+			    port_data & port_mask;
 			bits = private(dev)->output_bits[port];
 			if (board(dev)->invert_outputs)
 				bits = ~bits;
 			writeb(bits,
-				private(dev)->mite->daq_io_addr +
-				Port_Data(port));
+			       private(dev)->mite->daq_io_addr +
+			       Port_Data(port));
 /* printk("wrote 0x%x to port %i\n", bits, port); */
 		}
 		port_read_bits =
-			readb(private(dev)->mite->daq_io_addr +
-			Port_Data(port));
+		    readb(private(dev)->mite->daq_io_addr + Port_Data(port));
 /* printk("read 0x%x from port %i\n", port_read_bits, port); */
 		if (bitshift > 0) {
 			port_read_bits <<= bitshift;
@@ -468,7 +481,7 @@ static irqreturn_t ni_65xx_interrupt(int
 		return IRQ_NONE;
 
 	writeb(ClrEdge | ClrOverflow,
-		private(dev)->mite->daq_io_addr + Clear_Register);
+	       private(dev)->mite->daq_io_addr + Clear_Register);
 
 	comedi_buf_put(s->async, 0);
 	s->async->events |= COMEDI_CB_EOS;
@@ -476,8 +489,9 @@ static irqreturn_t ni_65xx_interrupt(int
 	return IRQ_HANDLED;
 }
 
-static int ni_65xx_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int ni_65xx_intr_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -552,29 +566,32 @@ static int ni_65xx_intr_cmdtest(struct c
 	return 0;
 }
 
-static int ni_65xx_intr_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int ni_65xx_intr_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	/* struct comedi_cmd *cmd = &s->async->cmd; */
 
 	writeb(ClrEdge | ClrOverflow,
-		private(dev)->mite->daq_io_addr + Clear_Register);
+	       private(dev)->mite->daq_io_addr + Clear_Register);
 	writeb(FallingEdgeIntEnable | RisingEdgeIntEnable |
-		MasterInterruptEnable | EdgeIntEnable,
-		private(dev)->mite->daq_io_addr + Master_Interrupt_Control);
+	       MasterInterruptEnable | EdgeIntEnable,
+	       private(dev)->mite->daq_io_addr + Master_Interrupt_Control);
 
 	return 0;
 }
 
-static int ni_65xx_intr_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int ni_65xx_intr_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
 {
 	writeb(0x00,
-		private(dev)->mite->daq_io_addr + Master_Interrupt_Control);
+	       private(dev)->mite->daq_io_addr + Master_Interrupt_Control);
 
 	return 0;
 }
 
-static int ni_65xx_intr_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_65xx_intr_insn_bits(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -583,8 +600,10 @@ static int ni_65xx_intr_insn_bits(struct
 	return 2;
 }
 
-static int ni_65xx_intr_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_65xx_intr_insn_config(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -592,35 +611,36 @@ static int ni_65xx_intr_insn_config(stru
 		return -EINVAL;
 
 	writeb(data[1],
-		private(dev)->mite->daq_io_addr +
-		Rising_Edge_Detection_Enable(0));
+	       private(dev)->mite->daq_io_addr +
+	       Rising_Edge_Detection_Enable(0));
 	writeb(data[1] >> 8,
-		private(dev)->mite->daq_io_addr +
-		Rising_Edge_Detection_Enable(0x10));
+	       private(dev)->mite->daq_io_addr +
+	       Rising_Edge_Detection_Enable(0x10));
 	writeb(data[1] >> 16,
-		private(dev)->mite->daq_io_addr +
-		Rising_Edge_Detection_Enable(0x20));
+	       private(dev)->mite->daq_io_addr +
+	       Rising_Edge_Detection_Enable(0x20));
 	writeb(data[1] >> 24,
-		private(dev)->mite->daq_io_addr +
-		Rising_Edge_Detection_Enable(0x30));
+	       private(dev)->mite->daq_io_addr +
+	       Rising_Edge_Detection_Enable(0x30));
 
 	writeb(data[2],
-		private(dev)->mite->daq_io_addr +
-		Falling_Edge_Detection_Enable(0));
+	       private(dev)->mite->daq_io_addr +
+	       Falling_Edge_Detection_Enable(0));
 	writeb(data[2] >> 8,
-		private(dev)->mite->daq_io_addr +
-		Falling_Edge_Detection_Enable(0x10));
+	       private(dev)->mite->daq_io_addr +
+	       Falling_Edge_Detection_Enable(0x10));
 	writeb(data[2] >> 16,
-		private(dev)->mite->daq_io_addr +
-		Falling_Edge_Detection_Enable(0x20));
+	       private(dev)->mite->daq_io_addr +
+	       Falling_Edge_Detection_Enable(0x20));
 	writeb(data[2] >> 24,
-		private(dev)->mite->daq_io_addr +
-		Falling_Edge_Detection_Enable(0x30));
+	       private(dev)->mite->daq_io_addr +
+	       Falling_Edge_Detection_Enable(0x30));
 
 	return 2;
 }
 
-static int ni_65xx_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int ni_65xx_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned i;
@@ -647,7 +667,7 @@ static int ni_65xx_attach(struct comedi_
 	printk(" %s", dev->board_name);
 
 	printk(" ID=0x%02x",
-		readb(private(dev)->mite->daq_io_addr + ID_Register));
+	       readb(private(dev)->mite->daq_io_addr + ID_Register));
 
 	ret = alloc_subdevices(dev, 4);
 	if (ret < 0)
@@ -658,7 +678,7 @@ static int ni_65xx_attach(struct comedi_
 		s->type = COMEDI_SUBD_DI;
 		s->subdev_flags = SDF_READABLE;
 		s->n_chan =
-			board(dev)->num_di_ports * ni_65xx_channels_per_port;
+		    board(dev)->num_di_ports * ni_65xx_channels_per_port;
 		s->range_table = &range_digital;
 		s->maxdata = 1;
 		s->insn_config = ni_65xx_dio_insn_config;
@@ -676,7 +696,7 @@ static int ni_65xx_attach(struct comedi_
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 		s->n_chan =
-			board(dev)->num_do_ports * ni_65xx_channels_per_port;
+		    board(dev)->num_do_ports * ni_65xx_channels_per_port;
 		s->range_table = &range_digital;
 		s->maxdata = 1;
 		s->insn_bits = ni_65xx_dio_insn_bits;
@@ -693,7 +713,7 @@ static int ni_65xx_attach(struct comedi_
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 		s->n_chan =
-			board(dev)->num_dio_ports * ni_65xx_channels_per_port;
+		    board(dev)->num_dio_ports * ni_65xx_channels_per_port;
 		s->range_table = &range_digital;
 		s->maxdata = 1;
 		s->insn_config = ni_65xx_dio_insn_config;
@@ -705,8 +725,8 @@ static int ni_65xx_attach(struct comedi_
 		for (i = 0; i < board(dev)->num_dio_ports; ++i) {
 			/*  configure all ports for input */
 			writeb(0x1,
-				private(dev)->mite->daq_io_addr +
-				Port_Select(i));
+			       private(dev)->mite->daq_io_addr +
+			       Port_Select(i));
 		}
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
@@ -727,18 +747,18 @@ static int ni_65xx_attach(struct comedi_
 
 	for (i = 0; i < ni_65xx_total_num_ports(board(dev)); ++i) {
 		writeb(0x00,
-			private(dev)->mite->daq_io_addr + Filter_Enable(i));
+		       private(dev)->mite->daq_io_addr + Filter_Enable(i));
 		if (board(dev)->invert_outputs)
 			writeb(0x01,
-				private(dev)->mite->daq_io_addr + Port_Data(i));
+			       private(dev)->mite->daq_io_addr + Port_Data(i));
 		else
 			writeb(0x00,
-				private(dev)->mite->daq_io_addr + Port_Data(i));
+			       private(dev)->mite->daq_io_addr + Port_Data(i));
 	}
 	writeb(ClrEdge | ClrOverflow,
-		private(dev)->mite->daq_io_addr + Clear_Register);
+	       private(dev)->mite->daq_io_addr + Clear_Register);
 	writeb(0x00,
-		private(dev)->mite->daq_io_addr + Master_Interrupt_Control);
+	       private(dev)->mite->daq_io_addr + Master_Interrupt_Control);
 
 	/* Set filter interval to 0  (32bit reg) */
 	writeb(0x00000000, private(dev)->mite->daq_io_addr + Filter_Interval);
@@ -758,10 +778,10 @@ static int ni_65xx_attach(struct comedi_
 static int ni_65xx_detach(struct comedi_device *dev)
 {
 	if (private(dev) && private(dev)->mite
-		&& private(dev)->mite->daq_io_addr) {
+	    && private(dev)->mite->daq_io_addr) {
 		writeb(0x00,
-			private(dev)->mite->daq_io_addr +
-			Master_Interrupt_Control);
+		       private(dev)->mite->daq_io_addr +
+		       Master_Interrupt_Control);
 	}
 
 	if (dev->irq) {
@@ -793,7 +813,7 @@ static int ni_65xx_find_device(struct co
 			continue;
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number ||
-				slot != PCI_SLOT(mite->pcidev->devfn))
+			    slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
 		for (i = 0; i < n_ni_65xx_boards; i++) {
--- a/drivers/staging/comedi/drivers/ni_660x.c
+++ b/drivers/staging/comedi/drivers/ni_660x.c
@@ -201,7 +201,6 @@ struct NI_660xRegisterData {
 	enum ni_660x_register_width size;	/*  1 byte, 2 bytes, or 4 bytes */
 };
 
-
 static const struct NI_660xRegisterData registerData[NumRegisters] = {
 	{"G0 Interrupt Acknowledge", 0x004, NI_660x_WRITE, DATA_2B},
 	{"G0 Status Register", 0x004, NI_660x_READ, DATA_2B},
@@ -316,21 +315,25 @@ static inline unsigned ioconfig_bitshift
 	else
 		return 8;
 }
+
 static inline unsigned pfi_output_select_mask(unsigned pfi_channel)
 {
 	return 0x3 << ioconfig_bitshift(pfi_channel);
 }
+
 static inline unsigned pfi_output_select_bits(unsigned pfi_channel,
-	unsigned output_select)
+					      unsigned output_select)
 {
 	return (output_select & 0x3) << ioconfig_bitshift(pfi_channel);
 }
+
 static inline unsigned pfi_input_select_mask(unsigned pfi_channel)
 {
 	return 0x7 << (4 + ioconfig_bitshift(pfi_channel));
 }
+
 static inline unsigned pfi_input_select_bits(unsigned pfi_channel,
-	unsigned input_select)
+					     unsigned input_select)
 {
 	return (input_select & 0x7) << (4 + ioconfig_bitshift(pfi_channel));
 }
@@ -341,6 +344,7 @@ static inline unsigned dma_select_mask(u
 	BUG_ON(dma_channel >= MAX_DMA_CHANNEL);
 	return 0x1f << (8 * dma_channel);
 }
+
 enum dma_selection {
 	dma_selection_none = 0x1f,
 };
@@ -349,11 +353,13 @@ static inline unsigned dma_selection_cou
 	BUG_ON(counter_index >= counters_per_chip);
 	return counter_index;
 }
+
 static inline unsigned dma_select_bits(unsigned dma_channel, unsigned selection)
 {
 	BUG_ON(dma_channel >= MAX_DMA_CHANNEL);
 	return (selection << (8 * dma_channel)) & dma_select_mask(dma_channel);
 }
+
 static inline unsigned dma_reset_bit(unsigned dma_channel)
 {
 	BUG_ON(dma_channel >= MAX_DMA_CHANNEL);
@@ -388,36 +394,37 @@ struct ni_660x_board {
 
 static const struct ni_660x_board ni_660x_boards[] = {
 	{
-	.dev_id = 0x2c60,
-	.name = "PCI-6601",
-	.n_chips = 1,
-		},
+	 .dev_id = 0x2c60,
+	 .name = "PCI-6601",
+	 .n_chips = 1,
+	 },
 	{
-	.dev_id = 0x1310,
-	.name = "PCI-6602",
-	.n_chips = 2,
-		},
+	 .dev_id = 0x1310,
+	 .name = "PCI-6602",
+	 .n_chips = 2,
+	 },
 	{
-	.dev_id = 0x1360,
-	.name = "PXI-6602",
-	.n_chips = 2,
-		},
+	 .dev_id = 0x1360,
+	 .name = "PXI-6602",
+	 .n_chips = 2,
+	 },
 	{
-	.dev_id = 0x2cc0,
-	.name = "PXI-6608",
-	.n_chips = 2,
-		},
+	 .dev_id = 0x2cc0,
+	 .name = "PXI-6608",
+	 .n_chips = 2,
+	 },
 };
 
 #define NI_660X_MAX_NUM_CHIPS 2
 #define NI_660X_MAX_NUM_COUNTERS (NI_660X_MAX_NUM_CHIPS * counters_per_chip)
 
 static DEFINE_PCI_DEVICE_TABLE(ni_660x_pci_table) = {
-	{PCI_VENDOR_ID_NATINST, 0x2c60, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1310, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1360, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2cc0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_NATINST, 0x2c60, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1310, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1360, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2cc0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, ni_660x_pci_table);
@@ -436,24 +443,26 @@ struct ni_660x_private {
 	unsigned short pfi_output_selects[NUM_PFI_CHANNELS];
 };
 
-static inline struct ni_660x_private *private(struct comedi_device * dev)
+static inline struct ni_660x_private *private(struct comedi_device *dev)
 {
 	return dev->private;
 }
 
 /* initialized in ni_660x_find_device() */
-static inline const struct ni_660x_board *board(struct comedi_device * dev)
+static inline const struct ni_660x_board *board(struct comedi_device *dev)
 {
 	return dev->board_ptr;
 }
 
 #define n_ni_660x_boards (sizeof(ni_660x_boards)/sizeof(ni_660x_boards[0]))
 
-static int ni_660x_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int ni_660x_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int ni_660x_detach(struct comedi_device *dev);
 static void init_tio_chip(struct comedi_device *dev, int chipset);
-static void ni_660x_select_pfi_output(struct comedi_device *dev, unsigned pfi_channel,
-	unsigned output_select);
+static void ni_660x_select_pfi_output(struct comedi_device *dev,
+				      unsigned pfi_channel,
+				      unsigned output_select);
 
 static struct comedi_driver driver_ni_660x = {
 	.driver_name = "ni_660x",
@@ -466,21 +475,28 @@ COMEDI_PCI_INITCLEANUP(driver_ni_660x, n
 
 static int ni_660x_find_device(struct comedi_device *dev, int bus, int slot);
 static int ni_660x_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source);
+				   unsigned source);
 
 /* Possible instructions for a GPCT */
 static int ni_660x_GPCT_rinsn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
 static int ni_660x_GPCT_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data);
 static int ni_660x_GPCT_winsn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
 
 /* Possible instructions for Digital IO */
 static int ni_660x_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
 static int ni_660x_dio_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
 
 static inline unsigned ni_660x_num_counters(struct comedi_device *dev)
 {
@@ -697,7 +713,7 @@ static enum NI_660x_Register ni_gpct_to_
 		break;
 	default:
 		printk("%s: unhandled register 0x%x in switch.\n",
-			__func__, reg);
+		       __func__, reg);
 		BUG();
 		return 0;
 		break;
@@ -706,11 +722,12 @@ static enum NI_660x_Register ni_gpct_to_
 }
 
 static inline void ni_660x_write_register(struct comedi_device *dev,
-	unsigned chip_index, unsigned bits, enum NI_660x_Register reg)
+					  unsigned chip_index, unsigned bits,
+					  enum NI_660x_Register reg)
 {
 	void *const write_address =
-		private(dev)->mite->daq_io_addr + GPCT_OFFSET[chip_index] +
-		registerData[reg].offset;
+	    private(dev)->mite->daq_io_addr + GPCT_OFFSET[chip_index] +
+	    registerData[reg].offset;
 
 	switch (registerData[reg].size) {
 	case DATA_2B:
@@ -721,18 +738,19 @@ static inline void ni_660x_write_registe
 		break;
 	default:
 		printk("%s: %s: bug! unhandled case (reg=0x%x) in switch.\n",
-			__FILE__, __func__, reg);
+		       __FILE__, __func__, reg);
 		BUG();
 		break;
 	}
 }
 
 static inline unsigned ni_660x_read_register(struct comedi_device *dev,
-	unsigned chip_index, enum NI_660x_Register reg)
+					     unsigned chip_index,
+					     enum NI_660x_Register reg)
 {
 	void *const read_address =
-		private(dev)->mite->daq_io_addr + GPCT_OFFSET[chip_index] +
-		registerData[reg].offset;
+	    private(dev)->mite->daq_io_addr + GPCT_OFFSET[chip_index] +
+	    registerData[reg].offset;
 
 	switch (registerData[reg].size) {
 	case DATA_2B:
@@ -743,7 +761,7 @@ static inline unsigned ni_660x_read_regi
 		break;
 	default:
 		printk("%s: %s: bug! unhandled case (reg=0x%x) in switch.\n",
-			__FILE__, __func__, reg);
+		       __FILE__, __func__, reg);
 		BUG();
 		break;
 	}
@@ -751,65 +769,72 @@ static inline unsigned ni_660x_read_regi
 }
 
 static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
-	enum ni_gpct_register reg)
+				   enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	enum NI_660x_Register ni_660x_register = ni_gpct_to_660x_register(reg);
 	ni_660x_write_register(dev, counter->chip_index, bits,
-		ni_660x_register);
+			       ni_660x_register);
 }
 
 static unsigned ni_gpct_read_register(struct ni_gpct *counter,
-	enum ni_gpct_register reg)
+				      enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	enum NI_660x_Register ni_660x_register = ni_gpct_to_660x_register(reg);
 	return ni_660x_read_register(dev, counter->chip_index,
-		ni_660x_register);
+				     ni_660x_register);
 }
 
-static inline struct mite_dma_descriptor_ring *mite_ring(struct ni_660x_private * priv,
-	struct ni_gpct *counter)
+static inline struct mite_dma_descriptor_ring *mite_ring(struct ni_660x_private
+							 *priv,
+							 struct ni_gpct
+							 *counter)
 {
 	return priv->mite_rings[counter->chip_index][counter->counter_index];
 }
 
 static inline void ni_660x_set_dma_channel(struct comedi_device *dev,
-	unsigned mite_channel, struct ni_gpct *counter)
+					   unsigned mite_channel,
+					   struct ni_gpct *counter)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&private(dev)->soft_reg_copy_lock, flags);
 	private(dev)->dma_configuration_soft_copies[counter->chip_index] &=
-		~dma_select_mask(mite_channel);
+	    ~dma_select_mask(mite_channel);
 	private(dev)->dma_configuration_soft_copies[counter->chip_index] |=
-		dma_select_bits(mite_channel,
-		dma_selection_counter(counter->counter_index));
+	    dma_select_bits(mite_channel,
+			    dma_selection_counter(counter->counter_index));
 	ni_660x_write_register(dev, counter->chip_index,
-		private(dev)->dma_configuration_soft_copies[counter->
-			chip_index] | dma_reset_bit(mite_channel),
-		DMAConfigRegister);
+			       private(dev)->
+			       dma_configuration_soft_copies
+			       [counter->chip_index] |
+			       dma_reset_bit(mite_channel), DMAConfigRegister);
 	mmiowb();
 	spin_unlock_irqrestore(&private(dev)->soft_reg_copy_lock, flags);
 }
 
 static inline void ni_660x_unset_dma_channel(struct comedi_device *dev,
-	unsigned mite_channel, struct ni_gpct *counter)
+					     unsigned mite_channel,
+					     struct ni_gpct *counter)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&private(dev)->soft_reg_copy_lock, flags);
 	private(dev)->dma_configuration_soft_copies[counter->chip_index] &=
-		~dma_select_mask(mite_channel);
+	    ~dma_select_mask(mite_channel);
 	private(dev)->dma_configuration_soft_copies[counter->chip_index] |=
-		dma_select_bits(mite_channel, dma_selection_none);
+	    dma_select_bits(mite_channel, dma_selection_none);
 	ni_660x_write_register(dev, counter->chip_index,
-		private(dev)->dma_configuration_soft_copies[counter->
-			chip_index], DMAConfigRegister);
+			       private(dev)->
+			       dma_configuration_soft_copies
+			       [counter->chip_index], DMAConfigRegister);
 	mmiowb();
 	spin_unlock_irqrestore(&private(dev)->soft_reg_copy_lock, flags);
 }
 
 static int ni_660x_request_mite_channel(struct comedi_device *dev,
-	struct ni_gpct *counter, enum comedi_io_direction direction)
+					struct ni_gpct *counter,
+					enum comedi_io_direction direction)
 {
 	unsigned long flags;
 	struct mite_channel *mite_chan;
@@ -817,13 +842,12 @@ static int ni_660x_request_mite_channel(
 	spin_lock_irqsave(&private(dev)->mite_channel_lock, flags);
 	BUG_ON(counter->mite_chan);
 	mite_chan =
-		mite_request_channel(private(dev)->mite, mite_ring(private(dev),
-			counter));
+	    mite_request_channel(private(dev)->mite, mite_ring(private(dev),
+							       counter));
 	if (mite_chan == NULL) {
-		spin_unlock_irqrestore(&private(dev)->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&private(dev)->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for counter.");
+			     "failed to reserve mite dma channel for counter.");
 		return -EBUSY;
 	}
 	mite_chan->dir = direction;
@@ -833,7 +857,8 @@ static int ni_660x_request_mite_channel(
 	return 0;
 }
 
-void ni_660x_release_mite_channel(struct comedi_device *dev, struct ni_gpct *counter)
+void ni_660x_release_mite_channel(struct comedi_device *dev,
+				  struct ni_gpct *counter)
 {
 	unsigned long flags;
 
@@ -858,7 +883,7 @@ static int ni_660x_cmd(struct comedi_dev
 	retval = ni_660x_request_mite_channel(dev, counter, COMEDI_INPUT);
 	if (retval) {
 		comedi_error(dev,
-			"no dma channel available for use by counter");
+			     "no dma channel available for use by counter");
 		return retval;
 	}
 	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
@@ -867,8 +892,8 @@ static int ni_660x_cmd(struct comedi_dev
 	return retval;
 }
 
-static int ni_660x_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int ni_660x_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	struct ni_gpct *counter = subdev_to_counter(s);
 
@@ -893,19 +918,18 @@ static void set_tio_counterswap(struct c
 	 */
 	if (chipset)
 		ni_660x_write_register(dev, chipset, CounterSwap,
-			ClockConfigRegister);
+				       ClockConfigRegister);
 	else
 		ni_660x_write_register(dev, chipset, 0, ClockConfigRegister);
 }
 
 static void ni_660x_handle_gpct_interrupt(struct comedi_device *dev,
-	struct comedi_subdevice *s)
+					  struct comedi_subdevice *s)
 {
 	ni_tio_handle_interrupt(subdev_to_counter(s), s);
 	if (s->async->events) {
-		if (s->async->
-			events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
-				COMEDI_CB_OVERFLOW)) {
+		if (s->async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+					COMEDI_CB_OVERFLOW)) {
 			ni_660x_cancel(dev, s);
 		}
 		comedi_event(dev, s);
@@ -943,13 +967,14 @@ static int ni_660x_input_poll(struct com
 	return comedi_buf_read_n_available(s->async);
 }
 
-static int ni_660x_buf_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size)
+static int ni_660x_buf_change(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned long new_size)
 {
 	int ret;
 
 	ret = mite_buf_change(mite_ring(private(dev), subdev_to_counter(s)),
-		s->async);
+			      s->async);
 	if (ret < 0)
 		return ret;
 
@@ -982,7 +1007,7 @@ static int ni_660x_alloc_mite_rings(stru
 	for (i = 0; i < board(dev)->n_chips; ++i) {
 		for (j = 0; j < counters_per_chip; ++j) {
 			private(dev)->mite_rings[i][j] =
-				mite_alloc_ring(private(dev)->mite);
+			    mite_alloc_ring(private(dev)->mite);
 			if (private(dev)->mite_rings[i][j] == NULL) {
 				return -ENOMEM;
 			}
@@ -1003,7 +1028,8 @@ static void ni_660x_free_mite_rings(stru
 	}
 }
 
-static int ni_660x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int ni_660x_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret;
@@ -1056,8 +1082,11 @@ static int ni_660x_attach(struct comedi_
 	ni_660x_write_register(dev, 0, 0, STCDIOControl);
 
 	private(dev)->counter_dev = ni_gpct_device_construct(dev,
-		&ni_gpct_write_register, &ni_gpct_read_register,
-		ni_gpct_variant_660x, ni_660x_num_counters(dev));
+							     &ni_gpct_write_register,
+							     &ni_gpct_read_register,
+							     ni_gpct_variant_660x,
+							     ni_660x_num_counters
+							     (dev));
 	if (private(dev)->counter_dev == NULL)
 		return -ENOMEM;
 	for (i = 0; i < NI_660X_MAX_NUM_COUNTERS; ++i) {
@@ -1065,8 +1094,8 @@ static int ni_660x_attach(struct comedi_
 		if (i < ni_660x_num_counters(dev)) {
 			s->type = COMEDI_SUBD_COUNTER;
 			s->subdev_flags =
-				SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL |
-				SDF_CMD_READ /* | SDF_CMD_WRITE */ ;
+			    SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL |
+			    SDF_CMD_READ /* | SDF_CMD_WRITE */ ;
 			s->n_chan = 3;
 			s->maxdata = 0xffffffff;
 			s->insn_read = ni_660x_GPCT_rinsn;
@@ -1082,9 +1111,9 @@ static int ni_660x_attach(struct comedi_
 			s->private = &private(dev)->counter_dev->counters[i];
 
 			private(dev)->counter_dev->counters[i].chip_index =
-				i / counters_per_chip;
+			    i / counters_per_chip;
 			private(dev)->counter_dev->counters[i].counter_index =
-				i % counters_per_chip;
+			    i % counters_per_chip;
 		} else {
 			s->type = COMEDI_SUBD_UNUSED;
 		}
@@ -1100,7 +1129,7 @@ static int ni_660x_attach(struct comedi_
 			ni_660x_set_pfi_routing(dev, i, pfi_output_select_do);
 		else
 			ni_660x_set_pfi_routing(dev, i,
-				pfi_output_select_counter);
+						pfi_output_select_counter);
 		ni_660x_select_pfi_output(dev, i, pfi_output_select_high_Z);
 	}
 	/* to be safe, set counterswap bits on tio chips after all the counter
@@ -1119,7 +1148,7 @@ static int ni_660x_attach(struct comedi_
 	if (board(dev)->n_chips > 1)
 		global_interrupt_config_bits |= Cascade_Int_Enable_Bit;
 	ni_660x_write_register(dev, 0, global_interrupt_config_bits,
-		GlobalInterruptConfigRegister);
+			       GlobalInterruptConfigRegister);
 	printk("attached\n");
 	return 0;
 }
@@ -1145,7 +1174,7 @@ static int ni_660x_detach(struct comedi_
 
 static int
 ni_660x_GPCT_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		   struct comedi_insn *insn, unsigned int *data)
 {
 	return ni_tio_rinsn(subdev_to_counter(s), insn, data);
 }
@@ -1158,27 +1187,27 @@ static void init_tio_chip(struct comedi_
 	private(dev)->dma_configuration_soft_copies[chipset] = 0;
 	for (i = 0; i < MAX_DMA_CHANNEL; ++i) {
 		private(dev)->dma_configuration_soft_copies[chipset] |=
-			dma_select_bits(i,
-			dma_selection_none) & dma_select_mask(i);
+		    dma_select_bits(i, dma_selection_none) & dma_select_mask(i);
 	}
 	ni_660x_write_register(dev, chipset,
-		private(dev)->dma_configuration_soft_copies[chipset],
-		DMAConfigRegister);
-	for (i = 0; i < NUM_PFI_CHANNELS; ++i)
-	{
+			       private(dev)->
+			       dma_configuration_soft_copies[chipset],
+			       DMAConfigRegister);
+	for (i = 0; i < NUM_PFI_CHANNELS; ++i) {
 		ni_660x_write_register(dev, chipset, 0, IOConfigReg(i));
 	}
 }
 
 static int
 ni_660x_GPCT_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	return ni_tio_insn_config(subdev_to_counter(s), insn, data);
 }
 
 static int ni_660x_GPCT_winsn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	return ni_tio_winsn(subdev_to_counter(s), insn, data);
 }
@@ -1193,7 +1222,7 @@ static int ni_660x_find_device(struct co
 			continue;
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number ||
-				slot != PCI_SLOT(mite->pcidev->devfn))
+			    slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
 
@@ -1211,7 +1240,8 @@ static int ni_660x_find_device(struct co
 }
 
 static int ni_660x_dio_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned base_bitfield_channel = CR_CHAN(insn->chanspec);
 
@@ -1225,13 +1255,14 @@ static int ni_660x_dio_insn_bits(struct 
 	/* on return, data[1] contains the value of the digital
 	 * input and output lines. */
 	data[1] =
-		(ni_660x_read_register(dev, 0,
-			DIO32Input) >> base_bitfield_channel);
+	    (ni_660x_read_register(dev, 0,
+				   DIO32Input) >> base_bitfield_channel);
 	return 2;
 }
 
-static void ni_660x_select_pfi_output(struct comedi_device *dev, unsigned pfi_channel,
-	unsigned output_select)
+static void ni_660x_select_pfi_output(struct comedi_device *dev,
+				      unsigned pfi_channel,
+				      unsigned output_select)
 {
 	static const unsigned counter_4_7_first_pfi = 8;
 	static const unsigned counter_4_7_last_pfi = 23;
@@ -1240,33 +1271,41 @@ static void ni_660x_select_pfi_output(st
 	unsigned active_bits;
 	unsigned idle_bits;
 
-	if (board (dev)->n_chips > 1) {
+	if (board(dev)->n_chips > 1) {
 		if (output_select == pfi_output_select_counter &&
-			pfi_channel >= counter_4_7_first_pfi &&
-			pfi_channel <= counter_4_7_last_pfi) {
+		    pfi_channel >= counter_4_7_first_pfi &&
+		    pfi_channel <= counter_4_7_last_pfi) {
 			active_chipset = 1;
 			idle_chipset = 0;
-		}else {
+		} else {
 			active_chipset = 0;
 			idle_chipset = 1;
 		}
 	}
 
 	if (idle_chipset != active_chipset) {
-		idle_bits = ni_660x_read_register(dev, idle_chipset, IOConfigReg(pfi_channel));
+		idle_bits =
+		    ni_660x_read_register(dev, idle_chipset,
+					  IOConfigReg(pfi_channel));
 		idle_bits &= ~pfi_output_select_mask(pfi_channel);
-		idle_bits |= pfi_output_select_bits(pfi_channel, pfi_output_select_high_Z);
-		ni_660x_write_register(dev, idle_chipset, idle_bits, IOConfigReg(pfi_channel));
+		idle_bits |=
+		    pfi_output_select_bits(pfi_channel,
+					   pfi_output_select_high_Z);
+		ni_660x_write_register(dev, idle_chipset, idle_bits,
+				       IOConfigReg(pfi_channel));
 	}
 
-	active_bits = ni_660x_read_register(dev, active_chipset, IOConfigReg(pfi_channel));
+	active_bits =
+	    ni_660x_read_register(dev, active_chipset,
+				  IOConfigReg(pfi_channel));
 	active_bits &= ~pfi_output_select_mask(pfi_channel);
 	active_bits |= pfi_output_select_bits(pfi_channel, output_select);
-	ni_660x_write_register(dev, active_chipset, active_bits, IOConfigReg(pfi_channel));
+	ni_660x_write_register(dev, active_chipset, active_bits,
+			       IOConfigReg(pfi_channel));
 }
 
 static int ni_660x_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+				   unsigned source)
 {
 	if (source > num_pfi_output_selects)
 		return -EINVAL;
@@ -1284,18 +1323,21 @@ static int ni_660x_set_pfi_routing(struc
 	private(dev)->pfi_output_selects[chan] = source;
 	if (private(dev)->pfi_direction_bits & (((uint64_t) 1) << chan))
 		ni_660x_select_pfi_output(dev, chan,
-			private(dev)->pfi_output_selects[chan]);
+					  private(dev)->
+					  pfi_output_selects[chan]);
 	return 0;
 }
 
-static unsigned ni_660x_get_pfi_routing(struct comedi_device *dev, unsigned chan)
+static unsigned ni_660x_get_pfi_routing(struct comedi_device *dev,
+					unsigned chan)
 {
 	BUG_ON(chan >= NUM_PFI_CHANNELS);
 	return private(dev)->pfi_output_selects[chan];
 }
 
-static void ni660x_config_filter(struct comedi_device *dev, unsigned pfi_channel,
-	enum ni_gpct_filter_select filter)
+static void ni660x_config_filter(struct comedi_device *dev,
+				 unsigned pfi_channel,
+				 enum ni_gpct_filter_select filter)
 {
 	unsigned bits = ni_660x_read_register(dev, 0, IOConfigReg(pfi_channel));
 	bits &= ~pfi_input_select_mask(pfi_channel);
@@ -1304,7 +1346,8 @@ static void ni660x_config_filter(struct 
 }
 
 static int ni_660x_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -1317,7 +1360,8 @@ static int ni_660x_dio_insn_config(struc
 	case INSN_CONFIG_DIO_OUTPUT:
 		private(dev)->pfi_direction_bits |= ((uint64_t) 1) << chan;
 		ni_660x_select_pfi_output(dev, chan,
-			private(dev)->pfi_output_selects[chan]);
+					  private(dev)->
+					  pfi_output_selects[chan]);
 		break;
 	case INSN_CONFIG_DIO_INPUT:
 		private(dev)->pfi_direction_bits &= ~(((uint64_t) 1) << chan);
@@ -1325,9 +1369,8 @@ static int ni_660x_dio_insn_config(struc
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(private(dev)->
-			pfi_direction_bits & (((uint64_t) 1) << chan)) ?
-			COMEDI_OUTPUT : COMEDI_INPUT;
+		    (private(dev)->pfi_direction_bits &
+		     (((uint64_t) 1) << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return 0;
 	case INSN_CONFIG_SET_ROUTING:
 		return ni_660x_set_pfi_routing(dev, chan, data[1]);
--- a/drivers/staging/comedi/drivers/ni_670x.c
+++ b/drivers/staging/comedi/drivers/ni_670x.c
@@ -70,30 +70,32 @@ struct ni_670x_board {
 
 static const struct ni_670x_board ni_670x_boards[] = {
 	{
-	.dev_id = 0x2c90,
-	.name = "PCI-6703",
-	.ao_chans = 16,
-	.ao_bits = 16,
-		},
+	 .dev_id = 0x2c90,
+	 .name = "PCI-6703",
+	 .ao_chans = 16,
+	 .ao_bits = 16,
+	 },
 	{
-	.dev_id = 0x1920,
-	.name = "PXI-6704",
-	.ao_chans = 32,
-	.ao_bits = 16,
-		},
+	 .dev_id = 0x1920,
+	 .name = "PXI-6704",
+	 .ao_chans = 32,
+	 .ao_bits = 16,
+	 },
 	{
-	.dev_id = 0x1290,
-	.name = "PCI-6704",
-	.ao_chans = 32,
-	.ao_bits = 16,
-		},
+	 .dev_id = 0x1290,
+	 .name = "PCI-6704",
+	 .ao_chans = 32,
+	 .ao_bits = 16,
+	 },
 };
 
 static DEFINE_PCI_DEVICE_TABLE(ni_670x_pci_table) = {
-	{PCI_VENDOR_ID_NATINST, 0x2c90, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	/* { PCI_VENDOR_ID_NATINST, 0x0000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
-	{0}
+	{
+	PCI_VENDOR_ID_NATINST, 0x2c90, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	    /* { PCI_VENDOR_ID_NATINST, 0x0000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
+	{
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, ni_670x_pci_table);
@@ -108,11 +110,11 @@ struct ni_670x_private {
 	unsigned int ao_readback[32];
 };
 
-
 #define devpriv ((struct ni_670x_private *)dev->private)
 #define n_ni_670x_boards (sizeof(ni_670x_boards)/sizeof(ni_670x_boards[0]))
 
-static int ni_670x_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int ni_670x_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int ni_670x_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver_ni_670x = {
@@ -128,16 +130,22 @@ static struct comedi_lrange range_0_20mA
 
 static int ni_670x_find_device(struct comedi_device *dev, int bus, int slot);
 
-static int ni_670x_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_670x_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_670x_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_670x_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_670x_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int ni_670x_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int ni_670x_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int ni_670x_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
 
-static int ni_670x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int ni_670x_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret;
@@ -175,7 +183,7 @@ static int ni_670x_attach(struct comedi_
 		const struct comedi_lrange **range_table_list;
 
 		range_table_list = kmalloc(sizeof(struct comedi_lrange *) * 32,
-			GFP_KERNEL);
+					   GFP_KERNEL);
 		if (!range_table_list)
 			return -ENOMEM;
 		s->range_table_list = range_table_list;
@@ -223,8 +231,9 @@ static int ni_670x_detach(struct comedi_
 	return 0;
 }
 
-static int ni_670x_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_670x_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -249,8 +258,9 @@ static int ni_670x_ao_winsn(struct comed
 	return i;
 }
 
-static int ni_670x_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_670x_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -261,8 +271,9 @@ static int ni_670x_ao_rinsn(struct comed
 	return i;
 }
 
-static int ni_670x_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_670x_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -273,7 +284,7 @@ static int ni_670x_dio_insn_bits(struct 
 		s->state &= ~data[0];
 		s->state |= data[0] & data[1];
 		writel(s->state,
-			devpriv->mite->daq_io_addr + DIO_PORT0_DATA_OFFSET);
+		       devpriv->mite->daq_io_addr + DIO_PORT0_DATA_OFFSET);
 	}
 
 	/* on return, data[1] contains the value of the digital
@@ -283,8 +294,9 @@ static int ni_670x_dio_insn_bits(struct 
 	return 2;
 }
 
-static int ni_670x_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_670x_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -297,8 +309,7 @@ static int ni_670x_dio_insn_config(struc
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -320,7 +331,7 @@ static int ni_670x_find_device(struct co
 			continue;
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number
-				|| slot != PCI_SLOT(mite->pcidev->devfn))
+			    || slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
 
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -131,25 +131,25 @@ struct a2150_board {
 static const struct comedi_lrange range_a2150 = {
 	1,
 	{
-			RANGE(-2.828, 2.828),
-		}
+	 RANGE(-2.828, 2.828),
+	 }
 };
 
 /* enum must match board indices */
 enum { a2150_c, a2150_s };
 static const struct a2150_board a2150_boards[] = {
 	{
-	.name = "at-a2150c",
-	.clock = {31250, 22676, 20833, 19531},
-	.num_clocks = 4,
-	.ai_speed = 19531,
-		},
+	 .name = "at-a2150c",
+	 .clock = {31250, 22676, 20833, 19531},
+	 .num_clocks = 4,
+	 .ai_speed = 19531,
+	 },
 	{
-	.name = "at-a2150s",
-	.clock = {62500, 50000, 41667, 0},
-	.num_clocks = 3,
-	.ai_speed = 41667,
-		},
+	 .name = "at-a2150s",
+	 .clock = {62500, 50000, 41667, 0},
+	 .num_clocks = 3,
+	 .ai_speed = 41667,
+	 },
 };
 
 /*
@@ -167,7 +167,6 @@ struct a2150_private {
 	int config_bits;	/*  config register bits */
 };
 
-
 #define devpriv ((struct a2150_private *)dev->private)
 
 static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it);
@@ -182,16 +181,17 @@ static struct comedi_driver driver_a2150
 };
 
 static irqreturn_t a2150_interrupt(int irq, void *d);
-static int a2150_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int a2150_ai_cmdtest(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd);
 static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
-	int flags);
+			    int flags);
 static int a2150_probe(struct comedi_device *dev);
-static int a2150_set_chanlist(struct comedi_device *dev, unsigned int start_channel,
-	unsigned int num_channels);
+static int a2150_set_chanlist(struct comedi_device *dev,
+			      unsigned int start_channel,
+			      unsigned int num_channels);
 /*
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
@@ -335,7 +335,7 @@ static int a2150_attach(struct comedi_de
 	int i;
 
 	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_a2150.driver_name,
-		iobase);
+	       iobase);
 	if (irq) {
 		printk(", irq %u", irq);
 	} else {
@@ -391,7 +391,7 @@ static int a2150_attach(struct comedi_de
 		}
 		devpriv->dma = dma;
 		devpriv->dma_buffer =
-			kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
+		    kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL)
 			return -ENOMEM;
 
@@ -441,7 +441,8 @@ static int a2150_attach(struct comedi_de
 		udelay(1000);
 	}
 	if (i == timeout) {
-		printk(" timed out waiting for offset calibration to complete\n");
+		printk
+		    (" timed out waiting for offset calibration to complete\n");
 		return -ETIME;
 	}
 	devpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;
@@ -488,8 +489,8 @@ static int a2150_cancel(struct comedi_de
 	return 0;
 }
 
-static int a2150_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int a2150_ai_cmdtest(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -589,25 +590,24 @@ static int a2150_ai_cmdtest(struct comed
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) != (startChan + i)) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 		}
 		if (cmd->chanlist_len == 2 && CR_CHAN(cmd->chanlist[0]) == 1) {
 			comedi_error(dev,
-				"length 2 chanlist must be channels 0,1 or channels 2,3");
+				     "length 2 chanlist must be channels 0,1 or channels 2,3");
 			err++;
 		}
 		if (cmd->chanlist_len == 3) {
 			comedi_error(dev,
-				"chanlist must have 1,2 or 4 channels");
+				     "chanlist must have 1,2 or 4 channels");
 			err++;
 		}
 		if (CR_AREF(cmd->chanlist[0]) != CR_AREF(cmd->chanlist[1]) ||
-			CR_AREF(cmd->chanlist[2]) != CR_AREF(cmd->chanlist[3]))
-		{
+		    CR_AREF(cmd->chanlist[2]) != CR_AREF(cmd->chanlist[3])) {
 			comedi_error(dev,
-				"channels 0/1 and 2/3 must have the same analog reference");
+				     "channels 0/1 and 2/3 must have the same analog reference");
 			err++;
 		}
 	}
@@ -628,12 +628,12 @@ static int a2150_ai_cmd(struct comedi_de
 
 	if (!dev->irq || !devpriv->dma) {
 		comedi_error(dev,
-			" irq and dma required, cannot do hardware conversions");
+			     " irq and dma required, cannot do hardware conversions");
 		return -1;
 	}
 	if (cmd->flags & TRIG_RT) {
 		comedi_error(dev,
-			" dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
+			     " dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
 		return -1;
 	}
 	/*  clear fifo and reset triggering circuitry */
@@ -641,7 +641,7 @@ static int a2150_ai_cmd(struct comedi_de
 
 	/* setup chanlist */
 	if (a2150_set_chanlist(dev, CR_CHAN(cmd->chanlist[0]),
-			cmd->chanlist_len) < 0)
+			       cmd->chanlist_len) < 0)
 		return -1;
 
 	/*  setup ac/dc coupling */
@@ -673,14 +673,14 @@ static int a2150_ai_cmd(struct comedi_de
 	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
 	devpriv->dma_transfer_size =
-		sizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *
-		ONE_THIRD_SECOND / cmd->scan_begin_arg;
+	    sizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *
+	    ONE_THIRD_SECOND / cmd->scan_begin_arg;
 	if (devpriv->dma_transfer_size > A2150_DMA_BUFFER_SIZE)
 		devpriv->dma_transfer_size = A2150_DMA_BUFFER_SIZE;
 	if (devpriv->dma_transfer_size < sizeof(devpriv->dma_buffer[0]))
 		devpriv->dma_transfer_size = sizeof(devpriv->dma_buffer[0]);
 	devpriv->dma_transfer_size -=
-		devpriv->dma_transfer_size % sizeof(devpriv->dma_buffer[0]);
+	    devpriv->dma_transfer_size % sizeof(devpriv->dma_buffer[0]);
 	set_dma_count(devpriv->dma, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma);
 	release_dma_lock(lock_flags);
@@ -700,8 +700,8 @@ static int a2150_ai_cmd(struct comedi_de
 	trigger_bits = 0;
 	/*  decide if we need to wait 72 periods for valid data */
 	if (cmd->start_src == TRIG_NOW &&
-		(old_config_bits & CLOCK_MASK) !=
-		(devpriv->config_bits & CLOCK_MASK)) {
+	    (old_config_bits & CLOCK_MASK) !=
+	    (devpriv->config_bits & CLOCK_MASK)) {
 		/*  set trigger source to delay trigger */
 		trigger_bits |= DELAY_TRIGGER_BITS;
 	} else {
@@ -730,7 +730,7 @@ static int a2150_ai_cmd(struct comedi_de
 }
 
 static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int i, n;
 	static const int timeout = 100000;
@@ -804,7 +804,7 @@ static int a2150_ai_rinsn(struct comedi_
 /* sets bits in devpriv->clock_bits to nearest approximation of requested period,
  * adjusts requested period to actual timing. */
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
-	int flags)
+			    int flags)
 {
 	int lub, glb, temp;
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
@@ -866,19 +866,20 @@ static int a2150_get_timing(struct comed
 	devpriv->config_bits &= ~CLOCK_MASK;
 	if (*period == lub) {
 		devpriv->config_bits |=
-			CLOCK_SELECT_BITS(lub_index) |
-			CLOCK_DIVISOR_BITS(lub_divisor_shift);
+		    CLOCK_SELECT_BITS(lub_index) |
+		    CLOCK_DIVISOR_BITS(lub_divisor_shift);
 	} else {
 		devpriv->config_bits |=
-			CLOCK_SELECT_BITS(glb_index) |
-			CLOCK_DIVISOR_BITS(glb_divisor_shift);
+		    CLOCK_SELECT_BITS(glb_index) |
+		    CLOCK_DIVISOR_BITS(glb_divisor_shift);
 	}
 
 	return 0;
 }
 
-static int a2150_set_chanlist(struct comedi_device *dev, unsigned int start_channel,
-	unsigned int num_channels)
+static int a2150_set_chanlist(struct comedi_device *dev,
+			      unsigned int start_channel,
+			      unsigned int num_channels)
 {
 	if (start_channel + num_channels > 4)
 		return -1;
--- a/drivers/staging/comedi/drivers/ni_at_ao.c
+++ b/drivers/staging/comedi/drivers/ni_at_ao.c
@@ -158,13 +158,13 @@ struct atao_board {
 
 static const struct atao_board atao_boards[] = {
 	{
-	.name = "ai-ao-6",
-	.n_ao_chans = 6,
-		},
+	 .name = "ai-ao-6",
+	 .n_ao_chans = 6,
+	 },
 	{
-	.name = "ai-ao-10",
-	.n_ao_chans = 10,
-		},
+	 .name = "ai-ao-10",
+	 .n_ao_chans = 10,
+	 },
 };
 
 #define thisboard ((struct atao_board *)dev->board_ptr)
@@ -198,17 +198,21 @@ COMEDI_INITCLEANUP(driver_atao);
 static void atao_reset(struct comedi_device *dev);
 
 static int atao_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int atao_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int atao_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int atao_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int atao_calib_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int atao_calib_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
+static int atao_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int atao_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int atao_calib_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int atao_calib_insn_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
 
 static int atao_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
@@ -324,7 +328,7 @@ static void atao_reset(struct comedi_dev
 }
 
 static int atao_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -348,7 +352,7 @@ static int atao_ao_winsn(struct comedi_d
 }
 
 static int atao_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -359,8 +363,9 @@ static int atao_ao_rinsn(struct comedi_d
 	return i;
 }
 
-static int atao_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atao_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -376,8 +381,9 @@ static int atao_dio_insn_bits(struct com
 	return 2;
 }
 
-static int atao_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atao_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned int mask, bit;
@@ -401,8 +407,7 @@ static int atao_dio_insn_config(struct c
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -421,8 +426,9 @@ static int atao_dio_insn_config(struct c
  * DACs.  It is not explicitly stated in the manual how to access
  * the caldacs, but we can guess.
  */
-static int atao_calib_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atao_calib_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	for (i = 0; i < insn->n; i++) {
@@ -431,8 +437,9 @@ static int atao_calib_insn_read(struct c
 	return insn->n;
 }
 
-static int atao_calib_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atao_calib_insn_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bitstring, bit;
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -441,13 +448,13 @@ static int atao_calib_insn_write(struct 
 
 	for (bit = 1 << (11 - 1); bit; bit >>= 1) {
 		outw(devpriv->cfg2 | ((bit & bitstring) ? SDATA : 0),
-			dev->iobase + ATAO_CFG2);
+		     dev->iobase + ATAO_CFG2);
 		outw(devpriv->cfg2 | SCLK | ((bit & bitstring) ? SDATA : 0),
-			dev->iobase + ATAO_CFG2);
+		     dev->iobase + ATAO_CFG2);
 	}
 	/* strobe the appropriate caldac */
 	outw(devpriv->cfg2 | (((chan >> 3) + 1) << 14),
-		dev->iobase + ATAO_CFG2);
+	     dev->iobase + ATAO_CFG2);
 	outw(devpriv->cfg2, dev->iobase + ATAO_CFG2);
 
 	return insn->n;
--- a/drivers/staging/comedi/drivers/ni_atmio16d.c
+++ b/drivers/staging/comedi/drivers/ni_atmio16d.c
@@ -112,13 +112,13 @@ struct atmio16_board_t {
 
 static const struct atmio16_board_t atmio16_boards[] = {
 	{
-	.name = "atmio16",
-	.has_8255 = 0,
-		},
+	 .name = "atmio16",
+	 .has_8255 = 0,
+	 },
 	{
-	.name = "atmio16d",
-	.has_8255 = 1,
-		},
+	 .name = "atmio16d",
+	 .has_8255 = 1,
+	 },
 };
 
 #define n_atmio16_boards sizeof(atmio16_boards)/sizeof(atmio16_boards[0])
@@ -126,13 +126,17 @@ static const struct atmio16_board_t atmi
 #define boardtype ((const struct atmio16_board_t *)dev->board_ptr)
 
 /* function prototypes */
-static int atmio16d_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int atmio16d_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it);
 static int atmio16d_detach(struct comedi_device *dev);
 static irqreturn_t atmio16d_interrupt(int irq, void *d);
-static int atmio16d_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int atmio16d_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int atmio16d_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int atmio16d_ai_cmdtest(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_cmd *cmd);
+static int atmio16d_ai_cmd(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
+static int atmio16d_ai_cancel(struct comedi_device *dev,
+			      struct comedi_subdevice *s);
 static void reset_counters(struct comedi_device *dev);
 static void reset_atmio16d(struct comedi_device *dev);
 
@@ -151,27 +155,39 @@ COMEDI_INITCLEANUP(driver_atmio16d);
 
 /* range structs */
 static const struct comedi_lrange range_atmio16d_ai_10_bipolar = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.02)
-	}
+								       BIP_RANGE
+								       (10),
+								       BIP_RANGE
+								       (1),
+								       BIP_RANGE
+								       (0.1),
+								       BIP_RANGE
+								       (0.02)
+								       }
 };
 
 static const struct comedi_lrange range_atmio16d_ai_5_bipolar = { 4, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.01)
-	}
+								      BIP_RANGE
+								      (5),
+								      BIP_RANGE
+								      (0.5),
+								      BIP_RANGE
+								      (0.05),
+								      BIP_RANGE
+								      (0.01)
+								      }
 };
 
 static const struct comedi_lrange range_atmio16d_ai_unipolar = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.02)
-	}
+								     UNI_RANGE
+								     (10),
+								     UNI_RANGE
+								     (1),
+								     UNI_RANGE
+								     (0.1),
+								     UNI_RANGE
+								     (0.02)
+								     }
 };
 
 /* private data struct */
@@ -271,8 +287,9 @@ static irqreturn_t atmio16d_interrupt(in
 	return IRQ_HANDLED;
 }
 
-static int atmio16d_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int atmio16d_ai_cmdtest(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_cmd *cmd)
 {
 	int err = 0, tmp;
 #ifdef DEBUG1
@@ -310,8 +327,8 @@ static int atmio16d_ai_cmdtest(struct co
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_TIMER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -372,7 +389,8 @@ static int atmio16d_ai_cmdtest(struct co
 	return 0;
 }
 
-static int atmio16d_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int atmio16d_ai_cmd(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int timer, base_clock;
@@ -418,10 +436,10 @@ static int atmio16d_ai_cmd(struct comedi
 	} else if (cmd->convert_arg < 655360000) {
 		base_clock = CLOCK_100_KHZ;
 		timer = cmd->convert_arg / 10000;
-	} else if (cmd->convert_arg <= 0xffffffff /* 6553600000 */) {
+	} else if (cmd->convert_arg <= 0xffffffff /* 6553600000 */ ) {
 		base_clock = CLOCK_10_KHZ;
 		timer = cmd->convert_arg / 100000;
-	} else if (cmd->convert_arg <= 0xffffffff /* 65536000000 */) {
+	} else if (cmd->convert_arg <= 0xffffffff /* 65536000000 */ ) {
 		base_clock = CLOCK_1_KHZ;
 		timer = cmd->convert_arg / 1000000;
 	}
@@ -466,10 +484,10 @@ static int atmio16d_ai_cmd(struct comedi
 		tmp = sample_count & 0xFFFF;
 		if ((tmp == 0) || (tmp == 1)) {
 			outw((sample_count >> 16) & 0xFFFF,
-				dev->iobase + AM9513A_DATA_REG);
+			     dev->iobase + AM9513A_DATA_REG);
 		} else {
 			outw(((sample_count >> 16) & 0xFFFF) + 1,
-				dev->iobase + AM9513A_DATA_REG);
+			     dev->iobase + AM9513A_DATA_REG);
 		}
 		outw(0xFF70, dev->iobase + AM9513A_COM_REG);
 		devpriv->com_reg_1_state |= COMREG1_1632CNT;
@@ -486,10 +504,10 @@ static int atmio16d_ai_cmd(struct comedi
 		} else if (cmd->scan_begin_arg < 655360000) {
 			base_clock = CLOCK_100_KHZ;
 			timer = cmd->scan_begin_arg / 10000;
-		} else if (cmd->scan_begin_arg < 0xffffffff /* 6553600000 */) {
+		} else if (cmd->scan_begin_arg < 0xffffffff /* 6553600000 */ ) {
 			base_clock = CLOCK_10_KHZ;
 			timer = cmd->scan_begin_arg / 100000;
-		} else if (cmd->scan_begin_arg < 0xffffffff /* 65536000000 */) {
+		} else if (cmd->scan_begin_arg < 0xffffffff /* 65536000000 */ ) {
 			base_clock = CLOCK_1_KHZ;
 			timer = cmd->scan_begin_arg / 1000000;
 		}
@@ -522,7 +540,8 @@ static int atmio16d_ai_cmd(struct comedi
 }
 
 /* This will cancel a running acquisition operation */
-static int atmio16d_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int atmio16d_ai_cancel(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	reset_atmio16d(dev);
 
@@ -530,8 +549,9 @@ static int atmio16d_ai_cancel(struct com
 }
 
 /* Mode 0 is used to get a single conversion on demand */
-static int atmio16d_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atmio16d_ai_insn_read(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int i, t;
 	int chan;
@@ -589,8 +609,9 @@ static int atmio16d_ai_insn_read(struct 
 	return i;
 }
 
-static int atmio16d_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atmio16d_ao_insn_read(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 #ifdef DEBUG1
@@ -604,8 +625,9 @@ static int atmio16d_ao_insn_read(struct 
 	return i;
 }
 
-static int atmio16d_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atmio16d_ao_insn_write(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan;
@@ -639,8 +661,9 @@ static int atmio16d_ao_insn_write(struct
 	return i;
 }
 
-static int atmio16d_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atmio16d_dio_insn_bits(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -655,8 +678,10 @@ static int atmio16d_dio_insn_bits(struct
 	return 2;
 }
 
-static int atmio16d_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int atmio16d_dio_insn_config(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	int i;
 	int mask;
@@ -709,7 +734,8 @@ static int atmio16d_dio_insn_config(stru
    options[12] - dac1 coding
  */
 
-static int atmio16d_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int atmio16d_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it)
 {
 	unsigned int irq;
 	unsigned long iobase;
@@ -843,7 +869,7 @@ static int atmio16d_attach(struct comedi
 	s->n_chan = 0;
 	s->maxdata = 0
 #endif
-		printk("\n");
+	    printk("\n");
 
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/ni_atmio.c
+++ b/drivers/staging/comedi/drivers/ni_atmio.c
@@ -117,159 +117,159 @@ are not supported.
 
 static const struct ni_board_struct ni_boards[] = {
 	{.device_id = 44,
-	.isapnp_id = 0x0000,/* XXX unknown */
-	.name = "at-mio-16e-1",
-	.n_adchan = 16,
-	.adbits = 12,
-	.ai_fifo_depth = 8192,
-	.alwaysdither = 0,
-	.gainlkup = ai_gain_16,
-	.ai_speed = 800,
-	.n_aochan = 2,
-	.aobits = 12,
-	.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-	.ao_unipolar = 1,
-	.ao_speed = 1000,
-	.has_8255 = 0,
-			.num_p0_dio_channels = 8,
-	.caldac = {mb88341},
-		},
+	 .isapnp_id = 0x0000,	/* XXX unknown */
+	 .name = "at-mio-16e-1",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 8192,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 800,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .has_8255 = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {mb88341},
+	 },
 	{.device_id = 25,
-	.isapnp_id = 0x1900,
-	.name = "at-mio-16e-2",
-	.n_adchan = 16,
-	.adbits = 12,
-	.ai_fifo_depth = 2048,
-	.alwaysdither = 0,
-	.gainlkup = ai_gain_16,
-	.ai_speed = 2000,
-	.n_aochan = 2,
-	.aobits = 12,
-	.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-	.ao_unipolar = 1,
-	.ao_speed = 1000,
-	.has_8255 = 0,
-			.num_p0_dio_channels = 8,
-	.caldac = {mb88341},
-		},
+	 .isapnp_id = 0x1900,
+	 .name = "at-mio-16e-2",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 2048,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 2000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .has_8255 = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {mb88341},
+	 },
 	{.device_id = 36,
-	.isapnp_id = 0x2400,
-	.name = "at-mio-16e-10",
-	.n_adchan = 16,
-	.adbits = 12,
-	.ai_fifo_depth = 512,
-	.alwaysdither = 0,
-	.gainlkup = ai_gain_16,
-	.ai_speed = 10000,
-	.n_aochan = 2,
-	.aobits = 12,
-	.ao_fifo_depth = 0,
-			.ao_range_table = &range_ni_E_ao_ext,
-	.ao_unipolar = 1,
-	.ao_speed = 10000,
-			.num_p0_dio_channels = 8,
-	.caldac = {ad8804_debug},
-	.has_8255 = 0,
-		},
+	 .isapnp_id = 0x2400,
+	 .name = "at-mio-16e-10",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 10000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 10000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 0,
+	 },
 	{.device_id = 37,
-	.isapnp_id = 0x2500,
-	.name = "at-mio-16de-10",
-	.n_adchan = 16,
-	.adbits = 12,
-	.ai_fifo_depth = 512,
-	.alwaysdither = 0,
-	.gainlkup = ai_gain_16,
-	.ai_speed = 10000,
-	.n_aochan = 2,
-	.aobits = 12,
-	.ao_fifo_depth = 0,
-			.ao_range_table = &range_ni_E_ao_ext,
-	.ao_unipolar = 1,
-	.ao_speed = 10000,
-			.num_p0_dio_channels = 8,
-	.caldac = {ad8804_debug},
-	.has_8255 = 1,
-		},
+	 .isapnp_id = 0x2500,
+	 .name = "at-mio-16de-10",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 10000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 10000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 1,
+	 },
 	{.device_id = 38,
-	.isapnp_id = 0x2600,
-	.name = "at-mio-64e-3",
-	.n_adchan = 64,
-	.adbits = 12,
-	.ai_fifo_depth = 2048,
-	.alwaysdither = 0,
-	.gainlkup = ai_gain_16,
-	.ai_speed = 2000,
-	.n_aochan = 2,
-	.aobits = 12,
-	.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-	.ao_unipolar = 1,
-	.ao_speed = 1000,
-	.has_8255 = 0,
-			.num_p0_dio_channels = 8,
-	.caldac = {ad8804_debug},
-		},
+	 .isapnp_id = 0x2600,
+	 .name = "at-mio-64e-3",
+	 .n_adchan = 64,
+	 .adbits = 12,
+	 .ai_fifo_depth = 2048,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 2000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .has_8255 = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 },
 	{.device_id = 39,
-	.isapnp_id = 0x2700,
-	.name = "at-mio-16xe-50",
-	.n_adchan = 16,
-	.adbits = 16,
-	.ai_fifo_depth = 512,
-	.alwaysdither = 1,
-	.gainlkup = ai_gain_8,
-	.ai_speed = 50000,
-	.n_aochan = 2,
-	.aobits = 12,
-	.ao_fifo_depth = 0,
-			.ao_range_table = &range_bipolar10,
-	.ao_unipolar = 0,
-	.ao_speed = 50000,
-			.num_p0_dio_channels = 8,
-	.caldac = {dac8800, dac8043},
-	.has_8255 = 0,
-		},
+	 .isapnp_id = 0x2700,
+	 .name = "at-mio-16xe-50",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_8,
+	 .ai_speed = 50000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_speed = 50000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043},
+	 .has_8255 = 0,
+	 },
 	{.device_id = 50,
-	.isapnp_id = 0x0000,/* XXX unknown */
-	.name = "at-mio-16xe-10",
-	.n_adchan = 16,
-	.adbits = 16,
-	.ai_fifo_depth = 512,
-	.alwaysdither = 1,
-	.gainlkup = ai_gain_14,
-	.ai_speed = 10000,
-	.n_aochan = 2,
-	.aobits = 16,
-	.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-	.ao_unipolar = 1,
-	.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-	.caldac = {dac8800, dac8043, ad8522},
-	.has_8255 = 0,
-		},
+	 .isapnp_id = 0x0000,	/* XXX unknown */
+	 .name = "at-mio-16xe-10",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_14,
+	 .ai_speed = 10000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043, ad8522},
+	 .has_8255 = 0,
+	 },
 	{.device_id = 51,
-	.isapnp_id = 0x0000,/* XXX unknown */
-	.name = "at-ai-16xe-10",
-	.n_adchan = 16,
-	.adbits = 16,
-	.ai_fifo_depth = 512,
-	.alwaysdither = 1,	/* unknown */
-	.gainlkup = ai_gain_14,
-	.ai_speed = 10000,
-	.n_aochan = 0,
-	.aobits = 0,
-	.ao_fifo_depth = 0,
-	.ao_unipolar = 0,
-			.num_p0_dio_channels = 8,
-	.caldac = {dac8800, dac8043, ad8522},
-	.has_8255 = 0,
-		}
+	 .isapnp_id = 0x0000,	/* XXX unknown */
+	 .name = "at-ai-16xe-10",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,	/* unknown */
+	 .gainlkup = ai_gain_14,
+	 .ai_speed = 10000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043, ad8522},
+	 .has_8255 = 0,
+	 }
 };
 
 static const int ni_irqpin[] =
-	{ -1, -1, -1, 0, 1, 2, -1, 3, -1, -1, 4, 5, 6, -1, -1, 7 };
+    { -1, -1, -1, 0, 1, 2, -1, 3, -1, -1, 4, 5, 6, -1, -1, 7 };
 
 #define interrupt_pin(a)	(ni_irqpin[(a)])
 
@@ -279,8 +279,7 @@ static const int ni_irqpin[] =
 
 struct ni_private {
 	struct pnp_dev *isapnp_dev;
-	NI_PRIVATE_COMMON
-};
+ NI_PRIVATE_COMMON};
 #define devpriv ((struct ni_private *)dev->private)
 
 /* How we access registers */
@@ -330,17 +329,18 @@ static uint16_t ni_atmio_win_in(struct c
 }
 
 static struct pnp_device_id device_ids[] = {
-	{.id = "NIC1900", .driver_data = 0},
-	{.id = "NIC2400", .driver_data = 0},
-	{.id = "NIC2500", .driver_data = 0},
-	{.id = "NIC2600", .driver_data = 0},
-	{.id = "NIC2700", .driver_data = 0},
+	{.id = "NIC1900",.driver_data = 0},
+	{.id = "NIC2400",.driver_data = 0},
+	{.id = "NIC2500",.driver_data = 0},
+	{.id = "NIC2600",.driver_data = 0},
+	{.id = "NIC2700",.driver_data = 0},
 	{.id = ""}
 };
 
 MODULE_DEVICE_TABLE(pnp, device_ids);
 
-static int ni_atmio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int ni_atmio_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it);
 static int ni_atmio_detach(struct comedi_device *dev);
 static struct comedi_driver driver_atmio = {
 	.driver_name = "ni_atmio",
@@ -378,14 +378,17 @@ static int ni_isapnp_find_board(struct p
 
 	for (i = 0; i < n_ni_boards; i++) {
 		isapnp_dev = pnp_find_dev(NULL,
-			ISAPNP_VENDOR('N', 'I', 'C'),
-			ISAPNP_FUNCTION(ni_boards[i].isapnp_id), NULL);
+					  ISAPNP_VENDOR('N', 'I', 'C'),
+					  ISAPNP_FUNCTION(ni_boards[i].
+							  isapnp_id), NULL);
 
 		if (isapnp_dev == NULL || isapnp_dev->card == NULL)
 			continue;
 
 		if (pnp_device_attach(isapnp_dev) < 0) {
-			printk("ni_atmio: %s found but already active, skipping.\n", ni_boards[i].name);
+			printk
+			    ("ni_atmio: %s found but already active, skipping.\n",
+			     ni_boards[i].name);
 			continue;
 		}
 		if (pnp_activate_dev(isapnp_dev) < 0) {
@@ -393,7 +396,7 @@ static int ni_isapnp_find_board(struct p
 			return -EAGAIN;
 		}
 		if (!pnp_port_valid(isapnp_dev, 0)
-			|| !pnp_irq_valid(isapnp_dev, 0)) {
+		    || !pnp_irq_valid(isapnp_dev, 0)) {
 			pnp_device_detach(isapnp_dev);
 			printk("ni_atmio: pnp invalid port or irq, aborting\n");
 			return -ENOMEM;
@@ -406,7 +409,8 @@ static int ni_isapnp_find_board(struct p
 	return 0;
 }
 
-static int ni_atmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int ni_atmio_attach(struct comedi_device *dev,
+			   struct comedi_devconfig *it)
 {
 	struct pnp_dev *isapnp_dev;
 	int ret;
@@ -455,7 +459,7 @@ static int ni_atmio_attach(struct comedi
 		printk(" board fingerprint:");
 		for (i = 0; i < 16; i += 2) {
 			printk(" %04x %02x", inw(dev->iobase + i),
-				inb(dev->iobase + i + 1));
+			       inb(dev->iobase + i + 1));
 		}
 	}
 #endif
--- a/drivers/staging/comedi/drivers/ni_daq_700.c
+++ b/drivers/staging/comedi/drivers/ni_daq_700.c
@@ -56,7 +56,8 @@ static struct pcmcia_device *pcmcia_cur_
 
 #define DIO700_SIZE 8		/*  size of io region used by board */
 
-static int dio700_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dio700_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dio700_detach(struct comedi_device *dev);
 
 enum dio700_bustype { pcmcia_bustype };
@@ -74,17 +75,17 @@ struct dio700_board {
 
 static const struct dio700_board dio700_boards[] = {
 	{
-	.name = "daqcard-700",
-	.device_id = 0x4743,/*  0x10b is manufacturer id, 0x4743 is device id */
-	.bustype = pcmcia_bustype,
-	.have_dio = 1,
-		},
+	 .name = "daqcard-700",
+	 .device_id = 0x4743,	/*  0x10b is manufacturer id, 0x4743 is device id */
+	 .bustype = pcmcia_bustype,
+	 .have_dio = 1,
+	 },
 	{
-	.name = "ni_daq_700",
-	.device_id = 0x4743,/*  0x10b is manufacturer id, 0x4743 is device id */
-	.bustype = pcmcia_bustype,
-	.have_dio = 1,
-		},
+	 .name = "ni_daq_700",
+	 .device_id = 0x4743,	/*  0x10b is manufacturer id, 0x4743 is device id */
+	 .bustype = pcmcia_bustype,
+	 .have_dio = 1,
+	 },
 };
 
 /*
@@ -97,7 +98,6 @@ struct dio700_private {
 	int data;		/* number of data points left to be taken */
 };
 
-
 #define devpriv ((struct dio700_private *)dev->private)
 
 static struct comedi_driver driver_dio700 = {
@@ -156,8 +156,9 @@ static int subdev_700_cb(int dir, int po
 	}
 }
 
-static int subdev_700_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int subdev_700_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -165,7 +166,7 @@ static int subdev_700_insn(struct comedi
 
 		if (data[0] & 0xff)
 			CALLBACK_FUNC(1, _700_DATA, s->state & 0xff,
-				CALLBACK_ARG);
+				      CALLBACK_ARG);
 	}
 
 	data[1] = s->state & 0xff;
@@ -174,8 +175,9 @@ static int subdev_700_insn(struct comedi
 	return 2;
 }
 
-static int subdev_700_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int subdev_700_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 
 	switch (data[0]) {
@@ -185,9 +187,9 @@ static int subdev_700_insn_config(struct
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -202,8 +204,9 @@ static void do_config(struct comedi_devi
 	return;
 }
 
-static int subdev_700_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int subdev_700_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -284,15 +287,16 @@ static int subdev_700_cmd(struct comedi_
 	return 0;
 }
 
-static int subdev_700_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int subdev_700_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	/* FIXME */
 
 	return 0;
 }
 
-int subdev_700_init(struct comedi_device *dev, struct comedi_subdevice *s, int (*cb) (int,
-		int, int, unsigned long), unsigned long arg)
+int subdev_700_init(struct comedi_device *dev, struct comedi_subdevice *s,
+		    int (*cb) (int, int, int, unsigned long), unsigned long arg)
 {
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
@@ -321,7 +325,8 @@ int subdev_700_init(struct comedi_device
 }
 
 int subdev_700_init_irq(struct comedi_device *dev, struct comedi_subdevice *s,
-	int (*cb) (int, int, int, unsigned long), unsigned long arg)
+			int (*cb) (int, int, int, unsigned long),
+			unsigned long arg)
 {
 	int ret;
 
@@ -383,7 +388,7 @@ static int dio700_attach(struct comedi_d
 		break;
 	}
 	printk("comedi%d: ni_daq_700: %s, io 0x%lx", dev->minor,
-		thisboard->name, iobase);
+	       thisboard->name, iobase);
 #ifdef incomplete
 	if (irq) {
 		printk(", irq %u", irq);
@@ -553,7 +558,7 @@ static void dio700_cs_detach(struct pcmc
 	DEBUG(0, "dio700_cs_detach(0x%p)\n", link);
 
 	if (link->dev_node) {
-		((struct local_info_t *) link->priv)->stop = 1;
+		((struct local_info_t *)link->priv)->stop = 1;
 		dio700_release(link);
 	}
 
@@ -609,7 +614,7 @@ static void dio700_config(struct pcmcia_
 	}
 
 	last_ret = pcmcia_parse_tuple(&tuple, &parse);
-	 if (last_ret) {
+	if (last_ret) {
 		cs_error(link, ParseTuple, last_ret);
 		goto cs_failed;
 	}
@@ -681,7 +686,7 @@ static void dio700_config(struct pcmcia_
 
 		if ((cfg->mem.nwin > 0) || (dflt.mem.nwin > 0)) {
 			cistpl_mem_t *mem =
-				(cfg->mem.nwin) ? &cfg->mem : &dflt.mem;
+			    (cfg->mem.nwin) ? &cfg->mem : &dflt.mem;
 			req.Attributes = WIN_DATA_WIDTH_16 | WIN_MEMORY_TYPE_CM;
 			req.Attributes |= WIN_ENABLE;
 			req.Base = mem->win[0].host_addr;
@@ -699,7 +704,7 @@ static void dio700_config(struct pcmcia_
 		/* If we got this far, we're cool! */
 		break;
 
-	      next_entry:
+next_entry:
 
 		last_ret = pcmcia_get_next_tuple(link, &tuple);
 		if (last_ret) {
@@ -742,23 +747,23 @@ static void dio700_config(struct pcmcia_
 
 	/* Finally, report what we've done */
 	printk(KERN_INFO "%s: index 0x%02x",
-		dev->node.dev_name, link->conf.ConfigIndex);
+	       dev->node.dev_name, link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %d", link->irq.AssignedIRQ);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-			link->io.BasePort1 + link->io.NumPorts1 - 1);
+		       link->io.BasePort1 + link->io.NumPorts1 - 1);
 	if (link->io.NumPorts2)
 		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
-			link->io.BasePort2 + link->io.NumPorts2 - 1);
+		       link->io.BasePort2 + link->io.NumPorts2 - 1);
 	if (link->win)
 		printk(", mem 0x%06lx-0x%06lx", req.Base,
-			req.Base + req.Size - 1);
+		       req.Base + req.Size - 1);
 	printk("\n");
 
 	return;
 
-      cs_failed:
+cs_failed:
 	printk(KERN_INFO "ni_daq_700 cs failed");
 	dio700_release(link);
 
@@ -819,7 +824,7 @@ struct pcmcia_driver dio700_cs_driver = 
 	.id_table = dio700_cs_ids,
 	.owner = THIS_MODULE,
 	.drv = {
-			.name = dev_info,
+		.name = dev_info,
 		},
 };
 
@@ -836,6 +841,7 @@ static void __exit exit_dio700_cs(void)
 	DEBUG(0, "ni_daq_700: unloading\n");
 	pcmcia_unregister_driver(&dio700_cs_driver);
 }
+
 int __init init_module(void)
 {
 	int ret;
--- a/drivers/staging/comedi/drivers/ni_daq_dio24.c
+++ b/drivers/staging/comedi/drivers/ni_daq_dio24.c
@@ -37,7 +37,7 @@ This is just a wrapper around the 8255.o
 the PCMCIA interface.
 */
 
-/* #define LABPC_DEBUG */   /*  enable debugging messages */
+			    /* #define LABPC_DEBUG *//*  enable debugging messages */
 #undef LABPC_DEBUG
 
 #include <linux/interrupt.h>
@@ -74,17 +74,17 @@ struct dio24_board_struct {
 
 static const struct dio24_board_struct dio24_boards[] = {
 	{
-	.name = "daqcard-dio24",
-	.device_id = 0x475c,/*  0x10b is manufacturer id, 0x475c is device id */
-	.bustype = pcmcia_bustype,
-	.have_dio = 1,
-		},
+	 .name = "daqcard-dio24",
+	 .device_id = 0x475c,	/*  0x10b is manufacturer id, 0x475c is device id */
+	 .bustype = pcmcia_bustype,
+	 .have_dio = 1,
+	 },
 	{
-	.name = "ni_daq_dio24",
-	.device_id = 0x475c,/*  0x10b is manufacturer id, 0x475c is device id */
-	.bustype = pcmcia_bustype,
-	.have_dio = 1,
-		},
+	 .name = "ni_daq_dio24",
+	 .device_id = 0x475c,	/*  0x10b is manufacturer id, 0x475c is device id */
+	 .bustype = pcmcia_bustype,
+	 .have_dio = 1,
+	 },
 };
 
 /*
@@ -97,7 +97,6 @@ struct dio24_private {
 	int data;		/* number of data points left to be taken */
 };
 
-
 #define devpriv ((struct dio24_private *)dev->private)
 
 static struct comedi_driver driver_dio24 = {
@@ -140,7 +139,7 @@ static int dio24_attach(struct comedi_de
 		break;
 	}
 	printk("comedi%d: ni_daq_dio24: %s, io 0x%lx", dev->minor,
-		thisboard->name, iobase);
+	       thisboard->name, iobase);
 #ifdef incomplete
 	if (irq) {
 		printk(", irq %u", irq);
@@ -310,7 +309,7 @@ static void dio24_cs_detach(struct pcmci
 	DEBUG(0, "dio24_cs_detach(0x%p)\n", link);
 
 	if (link->dev_node) {
-		((struct local_info_t *) link->priv)->stop = 1;
+		((struct local_info_t *)link->priv)->stop = 1;
 		dio24_release(link);
 	}
 
@@ -439,7 +438,7 @@ static void dio24_config(struct pcmcia_d
 
 		if ((cfg->mem.nwin > 0) || (dflt.mem.nwin > 0)) {
 			cistpl_mem_t *mem =
-				(cfg->mem.nwin) ? &cfg->mem : &dflt.mem;
+			    (cfg->mem.nwin) ? &cfg->mem : &dflt.mem;
 			req.Attributes = WIN_DATA_WIDTH_16 | WIN_MEMORY_TYPE_CM;
 			req.Attributes |= WIN_ENABLE;
 			req.Base = mem->win[0].host_addr;
@@ -457,7 +456,7 @@ static void dio24_config(struct pcmcia_d
 		/* If we got this far, we're cool! */
 		break;
 
-	      next_entry:
+next_entry:
 
 		last_ret = pcmcia_get_next_tuple(link, &tuple);
 		if (last_ret) {
@@ -500,23 +499,23 @@ static void dio24_config(struct pcmcia_d
 
 	/* Finally, report what we've done */
 	printk(KERN_INFO "%s: index 0x%02x",
-		dev->node.dev_name, link->conf.ConfigIndex);
+	       dev->node.dev_name, link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %d", link->irq.AssignedIRQ);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-			link->io.BasePort1 + link->io.NumPorts1 - 1);
+		       link->io.BasePort1 + link->io.NumPorts1 - 1);
 	if (link->io.NumPorts2)
 		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
-			link->io.BasePort2 + link->io.NumPorts2 - 1);
+		       link->io.BasePort2 + link->io.NumPorts2 - 1);
 	if (link->win)
 		printk(", mem 0x%06lx-0x%06lx", req.Base,
-			req.Base + req.Size - 1);
+		       req.Base + req.Size - 1);
 	printk("\n");
 
 	return;
 
-      cs_failed:
+cs_failed:
 	printk(KERN_INFO "Fallo");
 	dio24_release(link);
 
@@ -576,7 +575,7 @@ struct pcmcia_driver dio24_cs_driver = {
 	.id_table = dio24_cs_ids,
 	.owner = THIS_MODULE,
 	.drv = {
-			.name = dev_info,
+		.name = dev_info,
 		},
 };
 
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -171,40 +171,46 @@ static int labpc_drain_fifo(struct comed
 static void labpc_drain_dma(struct comedi_device *dev);
 static void handle_isa_dma(struct comedi_device *dev);
 static void labpc_drain_dregs(struct comedi_device *dev);
-static int labpc_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int labpc_ai_cmdtest(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd);
 static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int labpc_calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int labpc_calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int labpc_eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int labpc_eeprom_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
+static int labpc_calib_read_insn(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int labpc_calib_write_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
+static int labpc_eeprom_read_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
+static int labpc_eeprom_write_insn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
 static unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd);
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd);
 #ifdef CONFIG_COMEDI_PCI
 static int labpc_find_device(struct comedi_device *dev, int bus, int slot);
 #endif
 static int labpc_dio_mem_callback(int dir, int port, int data,
-	unsigned long arg);
+				  unsigned long arg);
 static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
-	unsigned int num_bits);
+			     unsigned int num_bits);
 static unsigned int labpc_serial_in(struct comedi_device *dev);
 static unsigned int labpc_eeprom_read(struct comedi_device *dev,
-	unsigned int address);
+				      unsigned int address);
 static unsigned int labpc_eeprom_read_status(struct comedi_device *dev);
 static unsigned int labpc_eeprom_write(struct comedi_device *dev,
-	unsigned int address, unsigned int value);
+				       unsigned int address,
+				       unsigned int value);
 static void write_caldac(struct comedi_device *dev, unsigned int channel,
-	unsigned int value);
+			 unsigned int value);
 
 enum scan_mode {
 	MODE_SINGLE_CHAN,
@@ -254,26 +260,27 @@ static const int labpc_plus_ai_gain_bits
 	0x60,
 	0x70,
 };
+
 static const struct comedi_lrange range_labpc_plus_ai = {
 	NUM_LABPC_PLUS_AI_RANGES,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(4),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.25),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.05),
-			UNI_RANGE(10),
-			UNI_RANGE(8),
-			UNI_RANGE(5),
-			UNI_RANGE(2),
-			UNI_RANGE(1),
-			UNI_RANGE(0.5),
-			UNI_RANGE(0.2),
-			UNI_RANGE(0.1),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(4),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.25),
+	 BIP_RANGE(0.1),
+	 BIP_RANGE(0.05),
+	 UNI_RANGE(10),
+	 UNI_RANGE(8),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.5),
+	 UNI_RANGE(0.2),
+	 UNI_RANGE(0.1),
+	 }
 };
 
 #define NUM_LABPC_1200_AI_RANGES 14
@@ -312,24 +319,25 @@ const int labpc_1200_ai_gain_bits[NUM_LA
 	0x60,
 	0x70,
 };
+
 const struct comedi_lrange range_labpc_1200_ai = {
 	NUM_LABPC_1200_AI_RANGES,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.25),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.05),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2),
-			UNI_RANGE(1),
-			UNI_RANGE(0.5),
-			UNI_RANGE(0.2),
-			UNI_RANGE(0.1),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.5),
+	 BIP_RANGE(0.25),
+	 BIP_RANGE(0.1),
+	 BIP_RANGE(0.05),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.5),
+	 UNI_RANGE(0.2),
+	 UNI_RANGE(0.1),
+	 }
 };
 
 /* analog output ranges */
@@ -337,9 +345,9 @@ const struct comedi_lrange range_labpc_1
 static const struct comedi_lrange range_labpc_ao = {
 	2,
 	{
-			BIP_RANGE(5),
-			UNI_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 UNI_RANGE(10),
+	 }
 };
 
 /* functions that do inb/outb and readb/writeb so we can use
@@ -348,14 +356,17 @@ static inline unsigned int labpc_inb(uns
 {
 	return inb(address);
 }
+
 static inline void labpc_outb(unsigned int byte, unsigned long address)
 {
 	outb(byte, address);
 }
+
 static inline unsigned int labpc_readb(unsigned long address)
 {
 	return readb((void *)address);
 }
+
 static inline void labpc_writeb(unsigned int byte, unsigned long address)
 {
 	writeb(byte, (void *)address);
@@ -363,60 +374,60 @@ static inline void labpc_writeb(unsigned
 
 static const struct labpc_board_struct labpc_boards[] = {
 	{
-	.name = "lab-pc-1200",
-	.ai_speed = 10000,
-	.bustype = isa_bustype,
-	.register_layout = labpc_1200_layout,
-	.has_ao = 1,
-	.ai_range_table = &range_labpc_1200_ai,
-	.ai_range_code = labpc_1200_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_1200_is_unipolar,
-	.ai_scan_up = 1,
-	.memory_mapped_io = 0,
-		},
+	 .name = "lab-pc-1200",
+	 .ai_speed = 10000,
+	 .bustype = isa_bustype,
+	 .register_layout = labpc_1200_layout,
+	 .has_ao = 1,
+	 .ai_range_table = &range_labpc_1200_ai,
+	 .ai_range_code = labpc_1200_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
+	 .ai_scan_up = 1,
+	 .memory_mapped_io = 0,
+	 },
 	{
-	.name = "lab-pc-1200ai",
-	.ai_speed = 10000,
-	.bustype = isa_bustype,
-	.register_layout = labpc_1200_layout,
-	.has_ao = 0,
-	.ai_range_table = &range_labpc_1200_ai,
-	.ai_range_code = labpc_1200_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_1200_is_unipolar,
-	.ai_scan_up = 1,
-	.memory_mapped_io = 0,
-		},
+	 .name = "lab-pc-1200ai",
+	 .ai_speed = 10000,
+	 .bustype = isa_bustype,
+	 .register_layout = labpc_1200_layout,
+	 .has_ao = 0,
+	 .ai_range_table = &range_labpc_1200_ai,
+	 .ai_range_code = labpc_1200_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
+	 .ai_scan_up = 1,
+	 .memory_mapped_io = 0,
+	 },
 	{
-	.name = "lab-pc+",
-	.ai_speed = 12000,
-	.bustype = isa_bustype,
-	.register_layout = labpc_plus_layout,
-	.has_ao = 1,
-	.ai_range_table = &range_labpc_plus_ai,
-	.ai_range_code = labpc_plus_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_plus_is_unipolar,
-	.ai_scan_up = 0,
-	.memory_mapped_io = 0,
-		},
+	 .name = "lab-pc+",
+	 .ai_speed = 12000,
+	 .bustype = isa_bustype,
+	 .register_layout = labpc_plus_layout,
+	 .has_ao = 1,
+	 .ai_range_table = &range_labpc_plus_ai,
+	 .ai_range_code = labpc_plus_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_plus_is_unipolar,
+	 .ai_scan_up = 0,
+	 .memory_mapped_io = 0,
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "pci-1200",
-	.device_id = 0x161,
-	.ai_speed = 10000,
-	.bustype = pci_bustype,
-	.register_layout = labpc_1200_layout,
-	.has_ao = 1,
-	.ai_range_table = &range_labpc_1200_ai,
-	.ai_range_code = labpc_1200_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_1200_is_unipolar,
-	.ai_scan_up = 1,
-	.memory_mapped_io = 1,
-		},
+	 .name = "pci-1200",
+	 .device_id = 0x161,
+	 .ai_speed = 10000,
+	 .bustype = pci_bustype,
+	 .register_layout = labpc_1200_layout,
+	 .has_ao = 1,
+	 .ai_range_table = &range_labpc_1200_ai,
+	 .ai_range_code = labpc_1200_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
+	 .ai_scan_up = 1,
+	 .memory_mapped_io = 1,
+	 },
 	/*  dummy entry so pci board works when comedi_config is passed driver name */
 	{
-		.name = DRV_NAME,
-		.bustype = pci_bustype,
-		},
+	 .name = DRV_NAME,
+	 .bustype = pci_bustype,
+	 },
 #endif
 };
 
@@ -442,26 +453,28 @@ static struct comedi_driver driver_labpc
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(labpc_pci_table) = {
-	{PCI_VENDOR_ID_NATINST, 0x161, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_NATINST, 0x161, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, labpc_pci_table);
 #endif /* CONFIG_COMEDI_PCI */
 
 static inline int labpc_counter_load(struct comedi_device *dev,
-	unsigned long base_address, unsigned int counter_number,
-	unsigned int count, unsigned int mode)
+				     unsigned long base_address,
+				     unsigned int counter_number,
+				     unsigned int count, unsigned int mode)
 {
 	if (thisboard->memory_mapped_io)
 		return i8254_mm_load((void *)base_address, 0, counter_number,
-			count, mode);
+				     count, mode);
 	else
 		return i8254_load(base_address, 0, counter_number, count, mode);
 }
 
 int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
-	unsigned int irq, unsigned int dma_chan)
+			unsigned int irq, unsigned int dma_chan)
 {
 	struct comedi_subdevice *s;
 	int i;
@@ -469,7 +482,7 @@ int labpc_common_attach(struct comedi_de
 	short lsb, msb;
 
 	printk("comedi%d: ni_labpc: %s, io 0x%lx", dev->minor, thisboard->name,
-		iobase);
+	       iobase);
 	if (irq) {
 		printk(", irq %u", irq);
 	}
@@ -486,7 +499,7 @@ int labpc_common_attach(struct comedi_de
 	if (thisboard->bustype == isa_bustype) {
 		/* check if io addresses are available */
 		if (!request_region(iobase, LABPC_SIZE,
-				driver_labpc.driver_name)) {
+				    driver_labpc.driver_name)) {
 			printk("I/O port conflict\n");
 			return -EIO;
 		}
@@ -507,9 +520,9 @@ int labpc_common_attach(struct comedi_de
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 	if (thisboard->register_layout == labpc_1200_layout) {
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 		devpriv->write_byte(devpriv->command6_bits,
-			dev->iobase + COMMAND6_REG);
+				    dev->iobase + COMMAND6_REG);
 	}
 
 	/* grab our IRQ */
@@ -532,14 +545,14 @@ int labpc_common_attach(struct comedi_de
 	} else if (dma_chan) {
 		/*  allocate dma buffer */
 		devpriv->dma_buffer =
-			kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
+		    kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL) {
 			printk(" failed to allocate dma buffer\n");
 			return -ENOMEM;
 		}
 		if (request_dma(dma_chan, driver_labpc.driver_name)) {
 			printk(" failed to allocate dma channel %u\n",
-				dma_chan);
+			       dma_chan);
 			return -EINVAL;
 		}
 		devpriv->dma_chan = dma_chan;
@@ -559,8 +572,7 @@ int labpc_common_attach(struct comedi_de
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags =
-		SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF |
-		SDF_CMD_READ;
+	    SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;
 	s->n_chan = 8;
 	s->len_chanlist = 8;
 	s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
@@ -599,7 +611,7 @@ int labpc_common_attach(struct comedi_de
 	/*  if board uses io memory we have to give a custom callback function to the 8255 driver */
 	if (thisboard->memory_mapped_io)
 		subdev_8255_init(dev, s, labpc_dio_mem_callback,
-			(unsigned long)(dev->iobase + DIO_BASE_REG));
+				 (unsigned long)(dev->iobase + DIO_BASE_REG));
 	else
 		subdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);
 
@@ -681,7 +693,8 @@ static int labpc_attach(struct comedi_de
 #endif
 		break;
 	case pcmcia_bustype:
-		printk(" this driver does not support pcmcia cards, use ni_labpc_cs.o\n");
+		printk
+		    (" this driver does not support pcmcia cards, use ni_labpc_cs.o\n");
 		return -EINVAL;
 		break;
 	default:
@@ -705,7 +718,7 @@ static int labpc_find_device(struct come
 		/*  if bus/slot are specified then make sure we have the right bus/slot */
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number
-				|| slot != PCI_SLOT(mite->pcidev->devfn))
+			    || slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
 		for (i = 0; i < driver_labpc.num_names; i++) {
@@ -795,7 +808,7 @@ static enum scan_mode labpc_ai_scan_mode
 }
 
 static int labpc_ai_chanlist_invalid(const struct comedi_device *dev,
-	const struct comedi_cmd *cmd)
+				     const struct comedi_cmd *cmd)
 {
 	int mode, channel, range, aref, i;
 
@@ -810,7 +823,7 @@ static int labpc_ai_chanlist_invalid(con
 	if (mode == MODE_SINGLE_CHAN_INTERVAL) {
 		if (cmd->chanlist_len > 0xff) {
 			comedi_error(dev,
-				"ni_labpc: chanlist too long for single channel interval mode\n");
+				     "ni_labpc: chanlist too long for single channel interval mode\n");
 			return 1;
 		}
 	}
@@ -825,22 +838,22 @@ static int labpc_ai_chanlist_invalid(con
 		case MODE_SINGLE_CHAN_INTERVAL:
 			if (CR_CHAN(cmd->chanlist[i]) != channel) {
 				comedi_error(dev,
-					"channel scanning order specified in chanlist is not supported by hardware.\n");
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
 				return 1;
 			}
 			break;
 		case MODE_MULT_CHAN_UP:
 			if (CR_CHAN(cmd->chanlist[i]) != i) {
 				comedi_error(dev,
-					"channel scanning order specified in chanlist is not supported by hardware.\n");
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
 				return 1;
 			}
 			break;
 		case MODE_MULT_CHAN_DOWN:
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				cmd->chanlist_len - i - 1) {
+			    cmd->chanlist_len - i - 1) {
 				comedi_error(dev,
-					"channel scanning order specified in chanlist is not supported by hardware.\n");
+					     "channel scanning order specified in chanlist is not supported by hardware.\n");
 				return 1;
 			}
 			break;
@@ -852,13 +865,13 @@ static int labpc_ai_chanlist_invalid(con
 
 		if (CR_RANGE(cmd->chanlist[i]) != range) {
 			comedi_error(dev,
-				"entries in chanlist must all have the same range\n");
+				     "entries in chanlist must all have the same range\n");
 			return 1;
 		}
 
 		if (CR_AREF(cmd->chanlist[i]) != aref) {
 			comedi_error(dev,
-				"entries in chanlist must all have the same reference\n");
+				     "entries in chanlist must all have the same reference\n");
 			return 1;
 		}
 	}
@@ -883,7 +896,7 @@ static unsigned int labpc_ai_convert_per
 		return 0;
 
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-		cmd->scan_begin_src == TRIG_TIMER)
+	    cmd->scan_begin_src == TRIG_TIMER)
 		return cmd->scan_begin_arg;
 
 	return cmd->convert_arg;
@@ -895,7 +908,7 @@ static void labpc_set_ai_convert_period(
 		return;
 
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-		cmd->scan_begin_src == TRIG_TIMER) {
+	    cmd->scan_begin_src == TRIG_TIMER) {
 		cmd->scan_begin_arg = ns;
 		if (cmd->convert_arg > cmd->scan_begin_arg)
 			cmd->convert_arg = cmd->scan_begin_arg;
@@ -909,7 +922,7 @@ static unsigned int labpc_ai_scan_period
 		return 0;
 
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-		cmd->convert_src == TRIG_TIMER)
+	    cmd->convert_src == TRIG_TIMER)
 		return 0;
 
 	return cmd->scan_begin_arg;
@@ -921,14 +934,14 @@ static void labpc_set_ai_scan_period(str
 		return;
 
 	if (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&
-		cmd->convert_src == TRIG_TIMER)
+	    cmd->convert_src == TRIG_TIMER)
 		return;
 
 	cmd->scan_begin_arg = ns;
 }
 
-static int labpc_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int labpc_ai_cmdtest(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, tmp2;
@@ -972,13 +985,13 @@ static int labpc_ai_cmdtest(struct comed
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_FOLLOW &&
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
+	    cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
 	/*  can't have external stop and start triggers at once */
@@ -1012,16 +1025,16 @@ static int labpc_ai_cmdtest(struct comed
 	/*  make sure scan timing is not too fast */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->convert_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->chanlist_len) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->chanlist_len;
+			    cmd->convert_arg * cmd->chanlist_len;
 			err++;
 		}
 		if (cmd->scan_begin_arg <
-			thisboard->ai_speed * cmd->chanlist_len) {
+		    thisboard->ai_speed * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				thisboard->ai_speed * cmd->chanlist_len;
+			    thisboard->ai_speed * cmd->chanlist_len;
 			err++;
 		}
 	}
@@ -1099,27 +1112,27 @@ static int labpc_ai_cmd(struct comedi_de
 	if (cmd->stop_src == TRIG_EXT) {
 		/*  load counter a1 with count of 3 (pc+ manual says this is minimum allowed) using mode 0 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
-			1, 3, 0);
+					 1, 3, 0);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a1");
 			return -1;
 		}
 	} else			/*  otherwise, just put a1 in mode 0 with no count to set its output low */
 		devpriv->write_byte(INIT_A1_BITS,
-			dev->iobase + COUNTER_A_CONTROL_REG);
+				    dev->iobase + COUNTER_A_CONTROL_REG);
 
 	/*  figure out what method we will use to transfer data */
 	if (devpriv->dma_chan &&	/*  need a dma channel allocated */
-		/*  dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for */
-		(cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
-		/*  only available on the isa boards */
-		thisboard->bustype == isa_bustype) {
+	    /*  dma unsafe at RT priority, and too much setup time for TRIG_WAKE_EOS for */
+	    (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&
+	    /*  only available on the isa boards */
+	    thisboard->bustype == isa_bustype) {
 		xfer = isa_dma_transfer;
 	} else if (thisboard->register_layout == labpc_1200_layout &&	/*  pc-plus has no fifo-half full interrupt */
-		/*  wake-end-of-scan should interrupt on fifo not empty */
-		(cmd->flags & TRIG_WAKE_EOS) == 0 &&
-		/*  make sure we are taking more than just a few points */
-		(cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {
+		   /*  wake-end-of-scan should interrupt on fifo not empty */
+		   (cmd->flags & TRIG_WAKE_EOS) == 0 &&
+		   /*  make sure we are taking more than just a few points */
+		   (cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {
 		xfer = fifo_half_full_transfer;
 	} else
 		xfer = fifo_not_empty_transfer;
@@ -1154,7 +1167,7 @@ static int labpc_ai_cmd(struct comedi_de
 			devpriv->command6_bits &= ~ADC_SCAN_UP_BIT;
 		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
-			dev->iobase + COMMAND6_REG);
+				    dev->iobase + COMMAND6_REG);
 	}
 
 	/* setup channel list, etc (command1 register) */
@@ -1171,13 +1184,13 @@ static int labpc_ai_cmd(struct comedi_de
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 	/*  manual says to set scan enable bit on second pass */
 	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||
-		labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
+	    labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
 		/* need a brief delay before enabling scan, or scan list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
 		udelay(1);
 		devpriv->write_byte(devpriv->command1_bits,
-			dev->iobase + COMMAND1_REG);
+				    dev->iobase + COMMAND1_REG);
 	}
 	/*  setup any external triggering/pacing (command4 register) */
 	devpriv->command4_bits = 0;
@@ -1196,17 +1209,17 @@ static int labpc_ai_cmd(struct comedi_de
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
 	devpriv->write_byte(cmd->chanlist_len,
-		dev->iobase + INTERVAL_COUNT_REG);
+			    dev->iobase + INTERVAL_COUNT_REG);
 	/*  load count */
 	devpriv->write_byte(INTERVAL_LOAD_BITS,
-		dev->iobase + INTERVAL_LOAD_REG);
+			    dev->iobase + INTERVAL_LOAD_REG);
 
 	if (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) {
 		/*  set up pacing */
 		labpc_adc_timing(dev, cmd);
 		/*  load counter b0 in mode 3 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
-			0, devpriv->divisor_b0, 3);
+					 0, devpriv->divisor_b0, 3);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter b0");
 			return -1;
@@ -1216,20 +1229,20 @@ static int labpc_ai_cmd(struct comedi_de
 	if (labpc_ai_convert_period(cmd)) {
 		/*  load counter a0 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,
-			0, devpriv->divisor_a0, 2);
+					 0, devpriv->divisor_a0, 2);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter a0");
 			return -1;
 		}
 	} else
 		devpriv->write_byte(INIT_A0_BITS,
-			dev->iobase + COUNTER_A_CONTROL_REG);
+				    dev->iobase + COUNTER_A_CONTROL_REG);
 
 	/*  set up scan pacing */
 	if (labpc_ai_scan_period(cmd)) {
 		/*  load counter b1 in mode 2 */
 		ret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,
-			1, devpriv->divisor_b1, 2);
+					 1, devpriv->divisor_b1, 2);
 		if (ret < 0) {
 			comedi_error(dev, "error loading counter b1");
 			return -1;
@@ -1246,14 +1259,13 @@ static int labpc_ai_cmd(struct comedi_de
 		 * count and address get set correctly */
 		clear_dma_ff(devpriv->dma_chan);
 		set_dma_addr(devpriv->dma_chan,
-			virt_to_bus(devpriv->dma_buffer));
+			     virt_to_bus(devpriv->dma_buffer));
 		/*  set appropriate size of transfer */
 		devpriv->dma_transfer_size = labpc_suggest_transfer_size(*cmd);
 		if (cmd->stop_src == TRIG_COUNT &&
-			devpriv->count * sample_size <
-			devpriv->dma_transfer_size) {
+		    devpriv->count * sample_size < devpriv->dma_transfer_size) {
 			devpriv->dma_transfer_size =
-				devpriv->count * sample_size;
+			    devpriv->count * sample_size;
 		}
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
@@ -1330,12 +1342,12 @@ static irqreturn_t labpc_interrupt(int i
 	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	if (thisboard->register_layout == labpc_1200_layout)
 		devpriv->status2_bits =
-			devpriv->read_byte(dev->iobase + STATUS2_REG);
+		    devpriv->read_byte(dev->iobase + STATUS2_REG);
 
 	if ((devpriv->status1_bits & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |
-				OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
-		&& (devpriv->status2_bits & A1_TC_BIT) == 0
-		&& (devpriv->status2_bits & FNHF_BIT)) {
+				      OVERRUN_BIT | DATA_AVAIL_BIT)) == 0
+	    && (devpriv->status2_bits & A1_TC_BIT) == 0
+	    && (devpriv->status2_bits & FNHF_BIT)) {
 		return IRQ_NONE;
 	}
 
@@ -1351,8 +1363,8 @@ static irqreturn_t labpc_interrupt(int i
 	if (devpriv->current_transfer == isa_dma_transfer) {
 		/*  if a dma terminal count of external stop trigger has occurred */
 		if (devpriv->status1_bits & DMATC_BIT ||
-			(thisboard->register_layout == labpc_1200_layout
-				&& devpriv->status2_bits & A1_TC_BIT)) {
+		    (thisboard->register_layout == labpc_1200_layout
+		     && devpriv->status2_bits & A1_TC_BIT)) {
 			handle_isa_dma(dev);
 		}
 	} else
@@ -1405,7 +1417,7 @@ static int labpc_drain_fifo(struct comed
 	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
 
 	for (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;
-		i++) {
+	     i++) {
 		/*  quit if we have all the data we want */
 		if (async->cmd.stop_src == TRIG_COUNT) {
 			if (devpriv->count == 0)
@@ -1417,7 +1429,7 @@ static int labpc_drain_fifo(struct comed
 		data = (msb << 8) | lsb;
 		cfc_write_to_buffer(dev->read_subdev, data);
 		devpriv->status1_bits =
-			devpriv->read_byte(dev->iobase + STATUS1_REG);
+		    devpriv->read_byte(dev->iobase + STATUS1_REG);
 	}
 	if (i == timeout) {
 		comedi_error(dev, "ai timeout, fifo never empties");
@@ -1502,7 +1514,7 @@ static void labpc_drain_dregs(struct com
 }
 
 static int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan, range;
@@ -1549,7 +1561,7 @@ static int labpc_ai_rinsn(struct comedi_
 		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
 		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
-			dev->iobase + COMMAND6_REG);
+				    dev->iobase + COMMAND6_REG);
 	}
 	/*  setup command4 register */
 	devpriv->command4_bits = 0;
@@ -1570,7 +1582,7 @@ static int labpc_ai_rinsn(struct comedi_
 
 		for (i = 0; i < timeout; i++) {
 			if (devpriv->read_byte(dev->iobase +
-					STATUS1_REG) & DATA_AVAIL_BIT)
+					       STATUS1_REG) & DATA_AVAIL_BIT)
 				break;
 			udelay(1);
 		}
@@ -1588,7 +1600,7 @@ static int labpc_ai_rinsn(struct comedi_
 
 /* analog output insn */
 static int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int channel, range;
 	unsigned long flags;
@@ -1613,7 +1625,7 @@ static int labpc_ao_winsn(struct comedi_
 			devpriv->command6_bits &= ~DAC_UNIP_BIT(channel);
 		/*  write to register */
 		devpriv->write_byte(devpriv->command6_bits,
-			dev->iobase + COMMAND6_REG);
+				    dev->iobase + COMMAND6_REG);
 	}
 	/*  send data */
 	lsb = data[0] & 0xff;
@@ -1629,23 +1641,25 @@ static int labpc_ao_winsn(struct comedi_
 
 /* analog output readback insn */
 static int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_calib_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int labpc_calib_read_insn(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_calib_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int labpc_calib_write_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 
@@ -1653,23 +1667,26 @@ static int labpc_calib_write_insn(struct
 	return 1;
 }
 
-static int labpc_eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int labpc_eeprom_read_insn(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int labpc_eeprom_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int labpc_eeprom_write_insn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int channel = CR_CHAN(insn->chanspec);
 	int ret;
 
 	/*  only allow writes to user area of eeprom */
 	if (channel < 16 || channel > 127) {
-		printk("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");
+		printk
+		    ("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");
 		return -EINVAL;
 	}
 
@@ -1715,7 +1732,7 @@ static void labpc_adc_timing(struct come
 	if (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {
 		/*  pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters) */
 		devpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /
-			(LABPC_TIMER_BASE * max_counter_value) + 1;
+		    (LABPC_TIMER_BASE * max_counter_value) + 1;
 		if (devpriv->divisor_b0 < min_counter_value)
 			devpriv->divisor_b0 = min_counter_value;
 		if (devpriv->divisor_b0 > max_counter_value)
@@ -1728,25 +1745,25 @@ static void labpc_adc_timing(struct come
 		default:
 		case TRIG_ROUND_NEAREST:
 			devpriv->divisor_a0 =
-				(labpc_ai_convert_period(cmd) +
-				(base_period / 2)) / base_period;
+			    (labpc_ai_convert_period(cmd) +
+			     (base_period / 2)) / base_period;
 			devpriv->divisor_b1 =
-				(labpc_ai_scan_period(cmd) +
-				(base_period / 2)) / base_period;
+			    (labpc_ai_scan_period(cmd) +
+			     (base_period / 2)) / base_period;
 			break;
 		case TRIG_ROUND_UP:
 			devpriv->divisor_a0 =
-				(labpc_ai_convert_period(cmd) + (base_period -
-					1)) / base_period;
+			    (labpc_ai_convert_period(cmd) + (base_period -
+							     1)) / base_period;
 			devpriv->divisor_b1 =
-				(labpc_ai_scan_period(cmd) + (base_period -
-					1)) / base_period;
+			    (labpc_ai_scan_period(cmd) + (base_period -
+							  1)) / base_period;
 			break;
 		case TRIG_ROUND_DOWN:
 			devpriv->divisor_a0 =
-				labpc_ai_convert_period(cmd) / base_period;
+			    labpc_ai_convert_period(cmd) / base_period;
 			devpriv->divisor_b1 =
-				labpc_ai_scan_period(cmd) / base_period;
+			    labpc_ai_scan_period(cmd) / base_period;
 			break;
 		}
 		/*  make sure a0 and b1 values are acceptable */
@@ -1760,9 +1777,9 @@ static void labpc_adc_timing(struct come
 			devpriv->divisor_b1 = max_counter_value;
 		/*  write corrected timings to command */
 		labpc_set_ai_convert_period(cmd,
-			base_period * devpriv->divisor_a0);
+					    base_period * devpriv->divisor_a0);
 		labpc_set_ai_scan_period(cmd,
-			base_period * devpriv->divisor_b1);
+					 base_period * devpriv->divisor_b1);
 		/*  if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions */
 	} else if (labpc_ai_scan_period(cmd)) {
 		unsigned int scan_period;
@@ -1770,8 +1787,10 @@ static void labpc_adc_timing(struct come
 		scan_period = labpc_ai_scan_period(cmd);
 		/* calculate cascaded counter values that give desired scan timing */
 		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
-			&(devpriv->divisor_b1), &(devpriv->divisor_b0),
-			&scan_period, cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor_b1),
+					       &(devpriv->divisor_b0),
+					       &scan_period,
+					       cmd->flags & TRIG_ROUND_MASK);
 		labpc_set_ai_scan_period(cmd, scan_period);
 	} else if (labpc_ai_convert_period(cmd)) {
 		unsigned int convert_period;
@@ -1779,14 +1798,16 @@ static void labpc_adc_timing(struct come
 		convert_period = labpc_ai_convert_period(cmd);
 		/* calculate cascaded counter values that give desired conversion timing */
 		i8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,
-			&(devpriv->divisor_a0), &(devpriv->divisor_b0),
-			&convert_period, cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor_a0),
+					       &(devpriv->divisor_b0),
+					       &convert_period,
+					       cmd->flags & TRIG_ROUND_MASK);
 		labpc_set_ai_convert_period(cmd, convert_period);
 	}
 }
 
 static int labpc_dio_mem_callback(int dir, int port, int data,
-	unsigned long iobase)
+				  unsigned long iobase)
 {
 	if (dir) {
 		writeb(data, (void *)(iobase + port));
@@ -1798,7 +1819,7 @@ static int labpc_dio_mem_callback(int di
 
 /* lowlevel write to eeprom/dac */
 static void labpc_serial_out(struct comedi_device *dev, unsigned int value,
-	unsigned int value_width)
+			     unsigned int value_width)
 {
 	int i;
 
@@ -1812,12 +1833,12 @@ static void labpc_serial_out(struct come
 			devpriv->command5_bits &= ~SDATA_BIT;
 		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 		/*  set clock to load bit */
 		devpriv->command5_bits |= SCLOCK_BIT;
 		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 	}
 }
 
@@ -1833,16 +1854,16 @@ static unsigned int labpc_serial_in(stru
 		devpriv->command5_bits |= SCLOCK_BIT;
 		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 		/*  clear clock bit */
 		devpriv->command5_bits &= ~SCLOCK_BIT;
 		udelay(1);
 		devpriv->write_byte(devpriv->command5_bits,
-			dev->iobase + COMMAND5_REG);
+				    dev->iobase + COMMAND5_REG);
 		/*  read bits most significant bit first */
 		udelay(1);
 		devpriv->status2_bits =
-			devpriv->read_byte(dev->iobase + STATUS2_REG);
+		    devpriv->read_byte(dev->iobase + STATUS2_REG);
 		if (devpriv->status2_bits & EEPROM_OUT_BIT) {
 			value |= 1 << (value_width - i);
 		}
@@ -1851,7 +1872,8 @@ static unsigned int labpc_serial_in(stru
 	return value;
 }
 
-static unsigned int labpc_eeprom_read(struct comedi_device *dev, unsigned int address)
+static unsigned int labpc_eeprom_read(struct comedi_device *dev,
+				      unsigned int address)
 {
 	unsigned int value;
 	const int read_instruction = 0x3;	/*  bits to tell eeprom to expect a read */
@@ -1881,7 +1903,7 @@ static unsigned int labpc_eeprom_read(st
 }
 
 static unsigned int labpc_eeprom_write(struct comedi_device *dev,
-	unsigned int address, unsigned int value)
+				       unsigned int address, unsigned int value)
 {
 	const int write_enable_instruction = 0x6;
 	const int write_instruction = 0x2;
@@ -1893,7 +1915,7 @@ static unsigned int labpc_eeprom_write(s
 	/*  make sure there isn't already a write in progress */
 	for (i = 0; i < timeout; i++) {
 		if ((labpc_eeprom_read_status(dev) & write_in_progress_bit) ==
-			0)
+		    0)
 			break;
 	}
 	if (i == timeout) {
@@ -1967,7 +1989,7 @@ static unsigned int labpc_eeprom_read_st
 
 /* writes to 8 bit calibration dacs */
 static void write_caldac(struct comedi_device *dev, unsigned int channel,
-	unsigned int value)
+			 unsigned int value)
 {
 	if (value == devpriv->caldac[channel])
 		return;
@@ -1975,7 +1997,7 @@ static void write_caldac(struct comedi_d
 
 	/*  clear caldac load bit and make sure we don't write to eeprom */
 	devpriv->command5_bits &=
-		~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
+	    ~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;
 	udelay(1);
 	devpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);
 
--- a/drivers/staging/comedi/drivers/ni_labpc_cs.c
+++ b/drivers/staging/comedi/drivers/ni_labpc_cs.c
@@ -60,7 +60,7 @@ NI manuals:
 */
 
 #undef LABPC_DEBUG
-/* #define LABPC_DEBUG */   /*  enable debugging messages */
+			    /* #define LABPC_DEBUG *//*  enable debugging messages */
 
 #include "../comedidev.h"
 
@@ -83,32 +83,32 @@ static int labpc_attach(struct comedi_de
 
 static const struct labpc_board_struct labpc_cs_boards[] = {
 	{
-	.name = "daqcard-1200",
-	.device_id = 0x103,	/*  0x10b is manufacturer id, 0x103 is device id */
-	.ai_speed = 10000,
-	.bustype = pcmcia_bustype,
-	.register_layout = labpc_1200_layout,
-	.has_ao = 1,
-	.ai_range_table = &range_labpc_1200_ai,
-	.ai_range_code = labpc_1200_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_1200_is_unipolar,
-	.ai_scan_up = 0,
-	.memory_mapped_io = 0,
-		},
+	 .name = "daqcard-1200",
+	 .device_id = 0x103,	/*  0x10b is manufacturer id, 0x103 is device id */
+	 .ai_speed = 10000,
+	 .bustype = pcmcia_bustype,
+	 .register_layout = labpc_1200_layout,
+	 .has_ao = 1,
+	 .ai_range_table = &range_labpc_1200_ai,
+	 .ai_range_code = labpc_1200_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
+	 .ai_scan_up = 0,
+	 .memory_mapped_io = 0,
+	 },
 	/* duplicate entry, to support using alternate name */
 	{
-	.name = "ni_labpc_cs",
-	.device_id = 0x103,
-	.ai_speed = 10000,
-	.bustype = pcmcia_bustype,
-	.register_layout = labpc_1200_layout,
-	.has_ao = 1,
-	.ai_range_table = &range_labpc_1200_ai,
-	.ai_range_code = labpc_1200_ai_gain_bits,
-	.ai_range_is_unipolar = labpc_1200_is_unipolar,
-	.ai_scan_up = 0,
-	.memory_mapped_io = 0,
-		},
+	 .name = "ni_labpc_cs",
+	 .device_id = 0x103,
+	 .ai_speed = 10000,
+	 .bustype = pcmcia_bustype,
+	 .register_layout = labpc_1200_layout,
+	 .has_ao = 1,
+	 .ai_range_table = &range_labpc_1200_ai,
+	 .ai_range_code = labpc_1200_ai_gain_bits,
+	 .ai_range_is_unipolar = labpc_1200_is_unipolar,
+	 .ai_scan_up = 0,
+	 .memory_mapped_io = 0,
+	 },
 };
 
 /*
@@ -165,7 +165,7 @@ static int pc_debug = PCMCIA_DEBUG;
 module_param(pc_debug, int, 0644);
 #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args)
 static const char *version =
-	"ni_labpc.c, based on dummy_cs.c 1.31 2001/08/24 12:13:13";
+    "ni_labpc.c, based on dummy_cs.c 1.31 2001/08/24 12:13:13";
 #else
 #define DEBUG(n, args...)
 #endif
@@ -287,7 +287,7 @@ static void labpc_cs_detach(struct pcmci
 	   detach().
 	 */
 	if (link->dev_node) {
-		((struct local_info_t *) link->priv)->stop = 1;
+		((struct local_info_t *)link->priv)->stop = 1;
 		labpc_release(link);
 	}
 
@@ -409,7 +409,7 @@ static void labpc_config(struct pcmcia_d
 
 		if ((cfg->mem.nwin > 0) || (dflt.mem.nwin > 0)) {
 			cistpl_mem_t *mem =
-				(cfg->mem.nwin) ? &cfg->mem : &dflt.mem;
+			    (cfg->mem.nwin) ? &cfg->mem : &dflt.mem;
 			req.Attributes = WIN_DATA_WIDTH_16 | WIN_MEMORY_TYPE_CM;
 			req.Attributes |= WIN_ENABLE;
 			req.Base = mem->win[0].host_addr;
@@ -428,7 +428,7 @@ static void labpc_config(struct pcmcia_d
 		/* If we got this far, we're cool! */
 		break;
 
-	      next_entry:
+next_entry:
 		last_ret = pcmcia_get_next_tuple(link, &tuple);
 		if (last_ret) {
 			cs_error(link, GetNextTuple, last_ret);
@@ -470,23 +470,23 @@ static void labpc_config(struct pcmcia_d
 
 	/* Finally, report what we've done */
 	printk(KERN_INFO "%s: index 0x%02x",
-		dev->node.dev_name, link->conf.ConfigIndex);
+	       dev->node.dev_name, link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %d", link->irq.AssignedIRQ);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-			link->io.BasePort1 + link->io.NumPorts1 - 1);
+		       link->io.BasePort1 + link->io.NumPorts1 - 1);
 	if (link->io.NumPorts2)
 		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
-			link->io.BasePort2 + link->io.NumPorts2 - 1);
+		       link->io.BasePort2 + link->io.NumPorts2 - 1);
 	if (link->win)
 		printk(", mem 0x%06lx-0x%06lx", req.Base,
-			req.Base + req.Size - 1);
+		       req.Base + req.Size - 1);
 	printk("\n");
 
 	return;
 
-      cs_failed:
+cs_failed:
 	labpc_release(link);
 
 }				/* labpc_config */
@@ -545,7 +545,7 @@ struct pcmcia_driver labpc_cs_driver = {
 	.id_table = labpc_cs_ids,
 	.owner = THIS_MODULE,
 	.drv = {
-			.name = dev_info,
+		.name = dev_info,
 		},
 };
 
--- a/drivers/staging/comedi/drivers/ni_labpc.h
+++ b/drivers/staging/comedi/drivers/ni_labpc.h
@@ -30,7 +30,8 @@
 enum labpc_bustype { isa_bustype, pci_bustype, pcmcia_bustype };
 enum labpc_register_layout { labpc_plus_layout, labpc_1200_layout };
 enum transfer_type { fifo_not_empty_transfer, fifo_half_full_transfer,
-		isa_dma_transfer };
+	isa_dma_transfer
+};
 
 struct labpc_board_struct {
 	const char *name;
@@ -75,7 +76,7 @@ struct labpc_private {
 };
 
 int labpc_common_attach(struct comedi_device *dev, unsigned long iobase,
-	unsigned int irq, unsigned int dma);
+			unsigned int irq, unsigned int dma);
 int labpc_common_detach(struct comedi_device *dev);
 
 extern const int labpc_1200_is_unipolar[];
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -77,110 +77,128 @@ static const unsigned old_RTSI_clock_cha
 /* Note: this table must match the ai_gain_* definitions */
 static const short ni_gainlkup[][16] = {
 	[ai_gain_16] = {0, 1, 2, 3, 4, 5, 6, 7,
-		0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
+			0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
 	[ai_gain_8] = {1, 2, 4, 7, 0x101, 0x102, 0x104, 0x107},
 	[ai_gain_14] = {1, 2, 3, 4, 5, 6, 7,
-		0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
+			0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},
 	[ai_gain_4] = {0, 1, 4, 7},
 	[ai_gain_611x] = {0x00a, 0x00b, 0x001, 0x002,
-		0x003, 0x004, 0x005, 0x006},
+			  0x003, 0x004, 0x005, 0x006},
 	[ai_gain_622x] = {0, 1, 4, 5},
 	[ai_gain_628x] = {1, 2, 3, 4, 5, 6, 7},
 	[ai_gain_6143] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
 };
 
 static const struct comedi_lrange range_ni_E_ai = { 16, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1, 1),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.25, 0.25),
-			RANGE(-0.1, 0.1),
-			RANGE(-0.05, 0.05),
-			RANGE(0, 20),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2),
-			RANGE(0, 1),
-			RANGE(0, 0.5),
-			RANGE(0, 0.2),
-			RANGE(0, 0.1),
-	}
+							 RANGE(-10, 10),
+							 RANGE(-5, 5),
+							 RANGE(-2.5, 2.5),
+							 RANGE(-1, 1),
+							 RANGE(-0.5, 0.5),
+							 RANGE(-0.25, 0.25),
+							 RANGE(-0.1, 0.1),
+							 RANGE(-0.05, 0.05),
+							 RANGE(0, 20),
+							 RANGE(0, 10),
+							 RANGE(0, 5),
+							 RANGE(0, 2),
+							 RANGE(0, 1),
+							 RANGE(0, 0.5),
+							 RANGE(0, 0.2),
+							 RANGE(0, 0.1),
+							 }
 };
+
 static const struct comedi_lrange range_ni_E_ai_limited = { 8, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-1, 1),
-			RANGE(-0.1, 0.1),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 1),
-			RANGE(0, 0.1),
-	}
+								RANGE(-10, 10),
+								RANGE(-5, 5),
+								RANGE(-1, 1),
+								RANGE(-0.1,
+								      0.1),
+								RANGE(0, 10),
+								RANGE(0, 5),
+								RANGE(0, 1),
+								RANGE(0, 0.1),
+								}
 };
+
 static const struct comedi_lrange range_ni_E_ai_limited14 = { 14, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2, 2),
-			RANGE(-1, 1),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.2, 0.2),
-			RANGE(-0.1, 0.1),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2),
-			RANGE(0, 1),
-			RANGE(0, 0.5),
-			RANGE(0, 0.2),
-			RANGE(0, 0.1),
-	}
+								   RANGE(-10,
+									 10),
+								   RANGE(-5, 5),
+								   RANGE(-2, 2),
+								   RANGE(-1, 1),
+								   RANGE(-0.5,
+									 0.5),
+								   RANGE(-0.2,
+									 0.2),
+								   RANGE(-0.1,
+									 0.1),
+								   RANGE(0, 10),
+								   RANGE(0, 5),
+								   RANGE(0, 2),
+								   RANGE(0, 1),
+								   RANGE(0,
+									 0.5),
+								   RANGE(0,
+									 0.2),
+								   RANGE(0,
+									 0.1),
+								   }
 };
+
 static const struct comedi_lrange range_ni_E_ai_bipolar4 = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.05, 0.05),
-	}
+								 RANGE(-10, 10),
+								 RANGE(-5, 5),
+								 RANGE(-0.5,
+								       0.5),
+								 RANGE(-0.05,
+								       0.05),
+								 }
 };
+
 static const struct comedi_lrange range_ni_E_ai_611x = { 8, {
-			RANGE(-50, 50),
-			RANGE(-20, 20),
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2, 2),
-			RANGE(-1, 1),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.2, 0.2),
-	}
+							     RANGE(-50, 50),
+							     RANGE(-20, 20),
+							     RANGE(-10, 10),
+							     RANGE(-5, 5),
+							     RANGE(-2, 2),
+							     RANGE(-1, 1),
+							     RANGE(-0.5, 0.5),
+							     RANGE(-0.2, 0.2),
+							     }
 };
+
 static const struct comedi_lrange range_ni_M_ai_622x = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-1, 1),
-			RANGE(-0.2, 0.2),
-	}
+							     RANGE(-10, 10),
+							     RANGE(-5, 5),
+							     RANGE(-1, 1),
+							     RANGE(-0.2, 0.2),
+							     }
 };
+
 static const struct comedi_lrange range_ni_M_ai_628x = { 7, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2, 2),
-			RANGE(-1, 1),
-			RANGE(-0.5, 0.5),
-			RANGE(-0.2, 0.2),
-			RANGE(-0.1, 0.1),
-	}
+							     RANGE(-10, 10),
+							     RANGE(-5, 5),
+							     RANGE(-2, 2),
+							     RANGE(-1, 1),
+							     RANGE(-0.5, 0.5),
+							     RANGE(-0.2, 0.2),
+							     RANGE(-0.1, 0.1),
+							     }
 };
+
 static const struct comedi_lrange range_ni_S_ai_6143 = { 1, {
-			RANGE(-5, +5),
-	}
+							     RANGE(-5, +5),
+							     }
 };
+
 static const struct comedi_lrange range_ni_E_ao_ext = { 4, {
-			RANGE(-10, 10),
-			RANGE(0, 10),
-			RANGE_ext(-1, 1),
-			RANGE_ext(0, 1),
-	}
+							    RANGE(-10, 10),
+							    RANGE(0, 10),
+							    RANGE_ext(-1, 1),
+							    RANGE_ext(0, 1),
+							    }
 };
 
 static const struct comedi_lrange *const ni_range_lkup[] = {
@@ -194,46 +212,64 @@ static const struct comedi_lrange *const
 	[ai_gain_6143] = &range_ni_S_ai_6143
 };
 
-static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_cdio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int ni_dio_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int ni_dio_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int ni_cdio_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
 static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_cdio_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static void handle_cdio_interrupt(struct comedi_device *dev);
 static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
-
-static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned char data_out, unsigned char *data_in);
-static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned char data_out, unsigned char *data_in);
-
-static int ni_calib_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_calib_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  unsigned int trignum);
 
-static int ni_eeprom_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_serial_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int ni_serial_hw_readwrite8(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned char data_out,
+				   unsigned char *data_in);
+static int ni_serial_sw_readwrite8(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned char data_out,
+				   unsigned char *data_in);
+
+static int ni_calib_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int ni_calib_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+
+static int ni_eeprom_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
-
-static int ni_pfi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_pfi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan);
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data);
+
+static int ni_pfi_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int ni_pfi_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static unsigned ni_old_get_pfi_routing(struct comedi_device *dev,
+				       unsigned chan);
 
 static void ni_rtsi_init(struct comedi_device *dev);
-static int ni_rtsi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_rtsi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_rtsi_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int ni_rtsi_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 static void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s);
 static int ni_read_eeprom(struct comedi_device *dev, int addr);
@@ -252,53 +288,62 @@ static void ni_mio_print_status_b(int st
 static int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 #ifndef PCIDMA
 static void ni_handle_fifo_half_full(struct comedi_device *dev);
-static int ni_ao_fifo_half_empty(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_ao_fifo_half_empty(struct comedi_device *dev,
+				 struct comedi_subdevice *s);
 #endif
 static void ni_handle_fifo_dregs(struct comedi_device *dev);
 static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
-static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_chan,
-	unsigned int *list);
+			 unsigned int trignum);
+static void ni_load_channelgain_list(struct comedi_device *dev,
+				     unsigned int n_chan, unsigned int *list);
 static void shutdown_ai_command(struct comedi_device *dev);
 
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
+			 unsigned int trignum);
 
 static int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg);
 
-static int ni_gpct_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_gpct_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int ni_gpct_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ni_gpct_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_gpct_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
+static int ni_gpct_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static void handle_gpct_interrupt(struct comedi_device *dev,
-	unsigned short counter_index);
+				  unsigned short counter_index);
 
 static int init_cs5529(struct comedi_device *dev);
-static int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data);
-static int cs5529_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int cs5529_do_conversion(struct comedi_device *dev,
+				unsigned short *data);
+static int cs5529_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 #ifdef NI_CS5529_DEBUG
 static unsigned int cs5529_config_read(struct comedi_device *dev,
-	unsigned int reg_select_bits);
+				       unsigned int reg_select_bits);
 #endif
 static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
-	unsigned int reg_select_bits);
+				unsigned int reg_select_bits);
 
-static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int ni_6143_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int ni_m_series_pwm_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
+static int ni_6143_pwm_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
 
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
-	unsigned period_ns);
+			       unsigned period_ns);
 static void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status);
 static void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status);
 
@@ -355,14 +400,14 @@ enum timebase_nanoseconds {
 static const int num_adc_stages_611x = 3;
 
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned ai_mite_status);
+			       unsigned ai_mite_status);
 static void handle_b_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned ao_mite_status);
+			       unsigned ao_mite_status);
 static void get_last_sample_611x(struct comedi_device *dev);
 static void get_last_sample_6143(struct comedi_device *dev);
 
 static inline void ni_set_bitfield(struct comedi_device *dev, int reg,
-	unsigned bit_mask, unsigned bit_values)
+				   unsigned bit_mask, unsigned bit_values)
 {
 	unsigned long flags;
 
@@ -372,19 +417,19 @@ static inline void ni_set_bitfield(struc
 		devpriv->int_a_enable_reg &= ~bit_mask;
 		devpriv->int_a_enable_reg |= bit_values & bit_mask;
 		devpriv->stc_writew(dev, devpriv->int_a_enable_reg,
-			Interrupt_A_Enable_Register);
+				    Interrupt_A_Enable_Register);
 		break;
 	case Interrupt_B_Enable_Register:
 		devpriv->int_b_enable_reg &= ~bit_mask;
 		devpriv->int_b_enable_reg |= bit_values & bit_mask;
 		devpriv->stc_writew(dev, devpriv->int_b_enable_reg,
-			Interrupt_B_Enable_Register);
+				    Interrupt_B_Enable_Register);
 		break;
 	case IO_Bidirection_Pin_Register:
 		devpriv->io_bidirection_pin_reg &= ~bit_mask;
 		devpriv->io_bidirection_pin_reg |= bit_values & bit_mask;
 		devpriv->stc_writew(dev, devpriv->io_bidirection_pin_reg,
-			IO_Bidirection_Pin_Register);
+				    IO_Bidirection_Pin_Register);
 		break;
 	case AI_AO_Select:
 		devpriv->ai_ao_select_reg &= ~bit_mask;
@@ -397,8 +442,7 @@ static inline void ni_set_bitfield(struc
 		ni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);
 		break;
 	default:
-		printk("Warning %s() called with invalid register\n",
-			__func__);
+		printk("Warning %s() called with invalid register\n", __func__);
 		printk("reg is %d\n", reg);
 		break;
 	}
@@ -418,8 +462,8 @@ static inline void ni_set_ai_dma_channel
 
 	if (channel >= 0) {
 		bitfield =
-			(ni_stc_dma_channel_select_bitfield(channel) <<
-			AI_DMA_Select_Shift) & AI_DMA_Select_Mask;
+		    (ni_stc_dma_channel_select_bitfield(channel) <<
+		     AI_DMA_Select_Shift) & AI_DMA_Select_Mask;
 	} else {
 		bitfield = 0;
 	}
@@ -433,8 +477,8 @@ static inline void ni_set_ao_dma_channel
 
 	if (channel >= 0) {
 		bitfield =
-			(ni_stc_dma_channel_select_bitfield(channel) <<
-			AO_DMA_Select_Shift) & AO_DMA_Select_Mask;
+		    (ni_stc_dma_channel_select_bitfield(channel) <<
+		     AO_DMA_Select_Shift) & AO_DMA_Select_Mask;
 	} else {
 		bitfield = 0;
 	}
@@ -443,7 +487,8 @@ static inline void ni_set_ao_dma_channel
 
 /* negative mite_channel means no channel */
 static inline void ni_set_gpct_dma_channel(struct comedi_device *dev,
-	unsigned gpct_index, int mite_channel)
+					   unsigned gpct_index,
+					   int mite_channel)
 {
 	unsigned bitfield;
 
@@ -453,11 +498,12 @@ static inline void ni_set_gpct_dma_chann
 		bitfield = 0;
 	}
 	ni_set_bitfield(dev, G0_G1_Select, GPCT_DMA_Select_Mask(gpct_index),
-		bitfield);
+			bitfield);
 }
 
 /* negative mite_channel means no channel */
-static inline void ni_set_cdo_dma_channel(struct comedi_device *dev, int mite_channel)
+static inline void ni_set_cdo_dma_channel(struct comedi_device *dev,
+					  int mite_channel)
 {
 	unsigned long flags;
 
@@ -468,8 +514,8 @@ static inline void ni_set_cdo_dma_channe
 		   under the assumption the cdio dma selection works just like ai/ao/gpct.
 		   Definitely works for dma channels 0 and 1. */
 		devpriv->cdio_dma_select_reg |=
-			(ni_stc_dma_channel_select_bitfield(mite_channel) <<
-			CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
+		    (ni_stc_dma_channel_select_bitfield(mite_channel) <<
+		     CDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;
 	}
 	ni_writeb(devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);
 	mmiowb();
@@ -483,12 +529,11 @@ static int ni_request_ai_mite_channel(st
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->ai_mite_chan);
 	devpriv->ai_mite_chan =
-		mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
+	    mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);
 	if (devpriv->ai_mite_chan == NULL) {
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for analog input.");
+			     "failed to reserve mite dma channel for analog input.");
 		return -EBUSY;
 	}
 	devpriv->ai_mite_chan->dir = COMEDI_INPUT;
@@ -504,12 +549,11 @@ static int ni_request_ao_mite_channel(st
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->ao_mite_chan);
 	devpriv->ao_mite_chan =
-		mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
+	    mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);
 	if (devpriv->ao_mite_chan == NULL) {
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for analog outut.");
+			     "failed to reserve mite dma channel for analog outut.");
 		return -EBUSY;
 	}
 	devpriv->ao_mite_chan->dir = COMEDI_OUTPUT;
@@ -519,7 +563,8 @@ static int ni_request_ao_mite_channel(st
 }
 
 static int ni_request_gpct_mite_channel(struct comedi_device *dev,
-	unsigned gpct_index, enum comedi_io_direction direction)
+					unsigned gpct_index,
+					enum comedi_io_direction direction)
 {
 	unsigned long flags;
 	struct mite_channel *mite_chan;
@@ -528,18 +573,17 @@ static int ni_request_gpct_mite_channel(
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->counter_dev->counters[gpct_index].mite_chan);
 	mite_chan =
-		mite_request_channel(devpriv->mite,
-		devpriv->gpct_mite_ring[gpct_index]);
+	    mite_request_channel(devpriv->mite,
+				 devpriv->gpct_mite_ring[gpct_index]);
 	if (mite_chan == NULL) {
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for counter.");
+			     "failed to reserve mite dma channel for counter.");
 		return -EBUSY;
 	}
 	mite_chan->dir = direction;
 	ni_tio_set_mite_channel(&devpriv->counter_dev->counters[gpct_index],
-		mite_chan);
+				mite_chan);
 	ni_set_gpct_dma_channel(dev, gpct_index, mite_chan->channel);
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
@@ -555,12 +599,11 @@ static int ni_request_cdo_mite_channel(s
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->cdo_mite_chan);
 	devpriv->cdo_mite_chan =
-		mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
+	    mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);
 	if (devpriv->cdo_mite_chan == NULL) {
-		spin_unlock_irqrestore(&devpriv->mite_channel_lock,
-			flags);
+		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev,
-			"failed to reserve mite dma channel for correlated digital outut.");
+			     "failed to reserve mite dma channel for correlated digital outut.");
 		return -EBUSY;
 	}
 	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
@@ -600,7 +643,8 @@ static void ni_release_ao_mite_channel(s
 #endif /*  PCIDMA */
 }
 
-void ni_release_gpct_mite_channel(struct comedi_device *dev, unsigned gpct_index)
+void ni_release_gpct_mite_channel(struct comedi_device *dev,
+				  unsigned gpct_index)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -609,11 +653,12 @@ void ni_release_gpct_mite_channel(struct
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->counter_dev->counters[gpct_index].mite_chan) {
 		struct mite_channel *mite_chan =
-			devpriv->counter_dev->counters[gpct_index].mite_chan;
+		    devpriv->counter_dev->counters[gpct_index].mite_chan;
 
 		ni_set_gpct_dma_channel(dev, gpct_index, -1);
-		ni_tio_set_mite_channel(&devpriv->counter_dev->
-			counters[gpct_index], NULL);
+		ni_tio_set_mite_channel(&devpriv->
+					counter_dev->counters[gpct_index],
+					NULL);
 		mite_release_channel(mite_chan);
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
@@ -638,7 +683,7 @@ static void ni_release_cdo_mite_channel(
 /* e-series boards use the second irq signals to generate dma requests for their counters */
 #ifdef PCIDMA
 static void ni_e_series_enable_second_irq(struct comedi_device *dev,
-	unsigned gpct_index, short enable)
+					  unsigned gpct_index, short enable)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return;
@@ -646,19 +691,19 @@ static void ni_e_series_enable_second_ir
 	case 0:
 		if (enable) {
 			devpriv->stc_writew(dev, G0_Gate_Second_Irq_Enable,
-				Second_IRQ_A_Enable_Register);
+					    Second_IRQ_A_Enable_Register);
 		} else {
 			devpriv->stc_writew(dev, 0,
-				Second_IRQ_A_Enable_Register);
+					    Second_IRQ_A_Enable_Register);
 		}
 		break;
 	case 1:
 		if (enable) {
 			devpriv->stc_writew(dev, G1_Gate_Second_Irq_Enable,
-				Second_IRQ_B_Enable_Register);
+					    Second_IRQ_B_Enable_Register);
 		} else {
 			devpriv->stc_writew(dev, 0,
-				Second_IRQ_B_Enable_Register);
+					    Second_IRQ_B_Enable_Register);
 		}
 		break;
 	default:
@@ -684,11 +729,11 @@ static void ni_clear_ai_fifo(struct come
 			/* the NI example code does 3 convert pulses for 625x boards,
 			   but that appears to be wrong in practice. */
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 #endif
 		}
 	}
@@ -709,7 +754,8 @@ static uint32_t win_in2(struct comedi_de
 }
 
 #define ao_win_out(data, addr) ni_ao_win_outw(dev, data, addr)
-static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data, int addr)
+static inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,
+				  int addr)
 {
 	unsigned long flags;
 
@@ -719,7 +765,8 @@ static inline void ni_ao_win_outw(struct
 	spin_unlock_irqrestore(&devpriv->window_lock, flags);
 }
 
-static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data, int addr)
+static inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,
+				  int addr)
 {
 	unsigned long flags;
 
@@ -751,8 +798,8 @@ static inline unsigned short ni_ao_win_i
 *
 * value should only be 1 or 0.
 */
-static inline void ni_set_bits(struct comedi_device *dev, int reg, unsigned bits,
-	unsigned value)
+static inline void ni_set_bits(struct comedi_device *dev, int reg,
+			       unsigned bits, unsigned value)
 {
 	unsigned bit_values;
 
@@ -792,17 +839,17 @@ static irqreturn_t ni_E_interrupt(int ir
 			ai_mite_status = mite_get_status(devpriv->ai_mite_chan);
 			if (ai_mite_status & CHSR_LINKC)
 				writel(CHOR_CLRLC,
-					devpriv->mite->mite_io_addr +
-					MITE_CHOR(devpriv->ai_mite_chan->
-						channel));
+				       devpriv->mite->mite_io_addr +
+				       MITE_CHOR(devpriv->
+						 ai_mite_chan->channel));
 		}
 		if (devpriv->ao_mite_chan) {
 			ao_mite_status = mite_get_status(devpriv->ao_mite_chan);
 			if (ao_mite_status & CHSR_LINKC)
 				writel(CHOR_CLRLC,
-					mite->mite_io_addr +
-					MITE_CHOR(devpriv->ao_mite_chan->
-						channel));
+				       mite->mite_io_addr +
+				       MITE_CHOR(devpriv->
+						 ao_mite_chan->channel));
 		}
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);
 	}
@@ -833,7 +880,8 @@ static void ni_sync_ai_dma(struct comedi
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 }
 
-static void mite_handle_b_linkc(struct mite_struct *mite, struct comedi_device * dev)
+static void mite_handle_b_linkc(struct mite_struct *mite,
+				struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	unsigned long flags;
@@ -907,9 +955,9 @@ static void shutdown_ai_command(struct c
 
 static void ni_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	if (s->async->
-		events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW | COMEDI_CB_EOA))
-	{
+	if (s->
+	    async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW |
+			     COMEDI_CB_EOA)) {
 		switch (s - dev->subdevices) {
 		case NI_AI_SUBDEV:
 			ni_ai_reset(dev, s);
@@ -932,13 +980,14 @@ static void ni_event(struct comedi_devic
 }
 
 static void handle_gpct_interrupt(struct comedi_device *dev,
-	unsigned short counter_index)
+				  unsigned short counter_index)
 {
 #ifdef PCIDMA
-	struct comedi_subdevice *s = dev->subdevices + NI_GPCT_SUBDEV(counter_index);
+	struct comedi_subdevice *s =
+	    dev->subdevices + NI_GPCT_SUBDEV(counter_index);
 
 	ni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],
-		s);
+				s);
 	if (s->async->events)
 		ni_event(dev, s);
 #endif
@@ -966,7 +1015,7 @@ static void ack_a_interrupt(struct comed
 }
 
 static void handle_a_interrupt(struct comedi_device *dev, unsigned short status,
-	unsigned ai_mite_status)
+			       unsigned ai_mite_status)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
@@ -976,8 +1025,8 @@ static void handle_a_interrupt(struct co
 
 #ifdef DEBUG_INTERRUPT
 	printk
-		("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
-		status, ai_mite_status);
+	    ("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",
+	     status, ai_mite_status);
 	ni_mio_print_status_a(status);
 #endif
 #ifdef PCIDMA
@@ -986,11 +1035,11 @@ static void handle_a_interrupt(struct co
 	}
 
 	if (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
-			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
-			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
+			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
+			       CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
 		printk
-			("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
-			ai_mite_status);
+		    ("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
+		     ai_mite_status);
 		/* mite_print_chsr(ai_mite_status); */
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		/* disable_irq(dev->irq); */
@@ -999,23 +1048,23 @@ static void handle_a_interrupt(struct co
 
 	/* test for all uncommon interrupt events at the same time */
 	if (status & (AI_Overrun_St | AI_Overflow_St | AI_SC_TC_Error_St |
-			AI_SC_TC_St | AI_START1_St)) {
+		      AI_SC_TC_St | AI_START1_St)) {
 		if (status == 0xffff) {
 			printk
-				("ni_mio_common: a_status=0xffff.  Card removed?\n");
+			    ("ni_mio_common: a_status=0xffff.  Card removed?\n");
 			/* we probably aren't even running a command now,
 			 * so it's a good idea to be careful. */
 			if (comedi_get_subdevice_runflags(s) & SRF_RUNNING) {
 				s->async->events |=
-					COMEDI_CB_ERROR | COMEDI_CB_EOA;
+				    COMEDI_CB_ERROR | COMEDI_CB_EOA;
 				ni_event(dev, s);
 			}
 			return;
 		}
 		if (status & (AI_Overrun_St | AI_Overflow_St |
-				AI_SC_TC_Error_St)) {
+			      AI_SC_TC_Error_St)) {
 			printk("ni_mio_common: ai error a_status=%04x\n",
-				status);
+			       status);
 			ni_mio_print_status_a(status);
 
 			shutdown_ai_command(dev);
@@ -1047,7 +1096,7 @@ static void handle_a_interrupt(struct co
 			ni_handle_fifo_half_full(dev);
 			if ((devpriv->stc_readw(dev,
 						AI_Status_1_Register) &
-					AI_FIFO_Half_Full_St) == 0)
+			     AI_FIFO_Half_Full_St) == 0)
 				break;
 		}
 	}
@@ -1063,8 +1112,8 @@ static void handle_a_interrupt(struct co
 	status = devpriv->stc_readw(dev, AI_Status_1_Register);
 	if (status & Interrupt_A_St) {
 		printk
-			("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",
-			status);
+		    ("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",
+		     status);
 	}
 #endif
 }
@@ -1097,14 +1146,14 @@ static void ack_b_interrupt(struct comed
 		devpriv->stc_writew(dev, ack, Interrupt_B_Ack_Register);
 }
 
-static void handle_b_interrupt(struct comedi_device *dev, unsigned short b_status,
-	unsigned ao_mite_status)
+static void handle_b_interrupt(struct comedi_device *dev,
+			       unsigned short b_status, unsigned ao_mite_status)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
 	/* unsigned short ack=0; */
 #ifdef DEBUG_INTERRUPT
 	printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
-		b_status, ao_mite_status);
+	       b_status, ao_mite_status);
 	ni_mio_print_status_b(b_status);
 #endif
 
@@ -1115,11 +1164,11 @@ static void handle_b_interrupt(struct co
 	}
 
 	if (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |
-			CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
-			CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
+			       CHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |
+			       CHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {
 		printk
-			("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
-			ao_mite_status);
+		    ("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
+		     ao_mite_status);
 		/* mite_print_chsr(ao_mite_status); */
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
@@ -1129,14 +1178,15 @@ static void handle_b_interrupt(struct co
 		return;
 	if (b_status & AO_Overrun_St) {
 		printk
-			("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
-			b_status, devpriv->stc_readw(dev,
-				AO_Status_2_Register));
+		    ("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",
+		     b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 
 	if (b_status & AO_BC_TC_St) {
-		MDPRINTK("ni_mio_common: AO BC_TC status=0x%04x status2=0x%04x\n", b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
+		MDPRINTK
+		    ("ni_mio_common: AO BC_TC status=0x%04x status2=0x%04x\n",
+		     b_status, devpriv->stc_readw(dev, AO_Status_2_Register));
 		s->async->events |= COMEDI_CB_EOA;
 	}
 #ifndef PCIDMA
@@ -1147,8 +1197,8 @@ static void handle_b_interrupt(struct co
 		if (!ret) {
 			printk("ni_mio_common: AO buffer underrun\n");
 			ni_set_bits(dev, Interrupt_B_Enable_Register,
-				AO_FIFO_Interrupt_Enable |
-				AO_Error_Interrupt_Enable, 0);
+				    AO_FIFO_Interrupt_Enable |
+				    AO_Error_Interrupt_Enable, 0);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 	}
@@ -1203,7 +1253,8 @@ static void ni_mio_print_status_b(int st
 
 #ifndef PCIDMA
 
-static void ni_ao_fifo_load(struct comedi_device *dev, struct comedi_subdevice *s, int n)
+static void ni_ao_fifo_load(struct comedi_device *dev,
+			    struct comedi_subdevice *s, int n)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1262,7 +1313,8 @@ static void ni_ao_fifo_load(struct comed
  *  RT code, as RT code might purposely be running close to the
  *  metal.  Needs to be fixed eventually.
  */
-static int ni_ao_fifo_half_empty(struct comedi_device *dev, struct comedi_subdevice *s)
+static int ni_ao_fifo_half_empty(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	int n;
 
@@ -1283,7 +1335,8 @@ static int ni_ao_fifo_half_empty(struct 
 	return 1;
 }
 
-static int ni_ao_prep_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static int ni_ao_prep_fifo(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	int n;
 
@@ -1306,7 +1359,8 @@ static int ni_ao_prep_fifo(struct comedi
 	return n;
 }
 
-static void ni_ai_fifo_read(struct comedi_device *dev, struct comedi_subdevice *s, int n)
+static void ni_ai_fifo_read(struct comedi_device *dev,
+			    struct comedi_subdevice *s, int n)
 {
 	struct comedi_async *async = s->async;
 	int i;
@@ -1349,17 +1403,18 @@ static void ni_ai_fifo_read(struct comed
 		}
 	} else {
 		if (n > sizeof(devpriv->ai_fifo_buffer) /
-			sizeof(devpriv->ai_fifo_buffer[0])) {
+		    sizeof(devpriv->ai_fifo_buffer[0])) {
 			comedi_error(dev, "bug! ai_fifo_buffer too small");
 			async->events |= COMEDI_CB_ERROR;
 			return;
 		}
 		for (i = 0; i < n; i++) {
 			devpriv->ai_fifo_buffer[i] =
-				ni_readw(ADC_FIFO_Data_Register);
+			    ni_readw(ADC_FIFO_Data_Register);
 		}
 		cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
-			n * sizeof(devpriv->ai_fifo_buffer[0]));
+					  n *
+					  sizeof(devpriv->ai_fifo_buffer[0]));
 	}
 }
 
@@ -1387,19 +1442,18 @@ static int ni_ai_drain_dma(struct comedi
 		for (i = 0; i < timeout; i++) {
 			if ((devpriv->stc_readw(dev,
 						AI_Status_1_Register) &
-					AI_FIFO_Empty_St)
-				&& mite_bytes_in_transit(devpriv->
-					ai_mite_chan) == 0)
+			     AI_FIFO_Empty_St)
+			    && mite_bytes_in_transit(devpriv->ai_mite_chan) ==
+			    0)
 				break;
 			udelay(5);
 		}
 		if (i == timeout) {
+			printk("ni_mio_common: wait for dma drain timed out\n");
 			printk
-				("ni_mio_common: wait for dma drain timed out\n");
-			printk
-				("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
-				mite_bytes_in_transit(devpriv->ai_mite_chan),
-				devpriv->stc_readw(dev, AI_Status_1_Register));
+			    ("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",
+			     mite_bytes_in_transit(devpriv->ai_mite_chan),
+			     devpriv->stc_readw(dev, AI_Status_1_Register));
 			retval = -1;
 		}
 	}
@@ -1423,8 +1477,8 @@ static void ni_handle_fifo_dregs(struct 
 
 	if (boardtype.reg_type == ni_reg_611x) {
 		while ((devpriv->stc_readw(dev,
-					AI_Status_1_Register) &
-				AI_FIFO_Empty_St) == 0) {
+					   AI_Status_1_Register) &
+			AI_FIFO_Empty_St) == 0) {
 			dl = ni_readl(ADC_FIFO_Data_611x);
 
 			/* This may get the hi/lo data in the wrong order */
@@ -1453,24 +1507,26 @@ static void ni_handle_fifo_dregs(struct 
 
 	} else {
 		fifo_empty =
-			devpriv->stc_readw(dev,
-			AI_Status_1_Register) & AI_FIFO_Empty_St;
+		    devpriv->stc_readw(dev,
+				       AI_Status_1_Register) & AI_FIFO_Empty_St;
 		while (fifo_empty == 0) {
 			for (i = 0;
-				i <
-				sizeof(devpriv->ai_fifo_buffer) /
-				sizeof(devpriv->ai_fifo_buffer[0]); i++) {
+			     i <
+			     sizeof(devpriv->ai_fifo_buffer) /
+			     sizeof(devpriv->ai_fifo_buffer[0]); i++) {
 				fifo_empty =
-					devpriv->stc_readw(dev,
-					AI_Status_1_Register) &
-					AI_FIFO_Empty_St;
+				    devpriv->stc_readw(dev,
+						       AI_Status_1_Register) &
+				    AI_FIFO_Empty_St;
 				if (fifo_empty)
 					break;
 				devpriv->ai_fifo_buffer[i] =
-					ni_readw(ADC_FIFO_Data_Register);
+				    ni_readw(ADC_FIFO_Data_Register);
 			}
 			cfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,
-				i * sizeof(devpriv->ai_fifo_buffer[0]));
+						  i *
+						  sizeof(devpriv->
+							 ai_fifo_buffer[0]));
 		}
 	}
 }
@@ -1513,7 +1569,8 @@ static void get_last_sample_6143(struct 
 }
 
 static void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *data, unsigned int num_bytes, unsigned int chan_index)
+			void *data, unsigned int num_bytes,
+			unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
 	unsigned int i;
@@ -1620,13 +1677,13 @@ static int ni_ai_reset(struct comedi_dev
 	ni_release_ai_mite_channel(dev);
 	/* ai configuration */
 	devpriv->stc_writew(dev, AI_Configuration_Start | AI_Reset,
-		Joint_Reset_Register);
+			    Joint_Reset_Register);
 
 	ni_set_bits(dev, Interrupt_A_Enable_Register,
-		AI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |
-		AI_START2_Interrupt_Enable | AI_START_Interrupt_Enable |
-		AI_STOP_Interrupt_Enable | AI_Error_Interrupt_Enable |
-		AI_FIFO_Interrupt_Enable, 0);
+		    AI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |
+		    AI_START2_Interrupt_Enable | AI_START_Interrupt_Enable |
+		    AI_STOP_Interrupt_Enable | AI_Error_Interrupt_Enable |
+		    AI_FIFO_Interrupt_Enable, 0);
 
 	ni_clear_ai_fifo(dev);
 
@@ -1635,51 +1692,60 @@ static int ni_ai_reset(struct comedi_dev
 
 	devpriv->stc_writew(dev, AI_Disarm, AI_Command_1_Register);	/* reset pulses */
 	devpriv->stc_writew(dev,
-		AI_Start_Stop | AI_Mode_1_Reserved /*| AI_Trigger_Once */ ,
-		AI_Mode_1_Register);
+			    AI_Start_Stop | AI_Mode_1_Reserved
+			    /*| AI_Trigger_Once */ ,
+			    AI_Mode_1_Register);
 	devpriv->stc_writew(dev, 0x0000, AI_Mode_2_Register);
 	/* generate FIFO interrupts on non-empty */
 	devpriv->stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);
 	if (boardtype.reg_type == ni_reg_611x) {
 		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-			AI_SOC_Polarity |
-			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
-		devpriv->stc_writew(dev, AI_SCAN_IN_PROG_Output_Select(3) |
-			AI_EXTMUX_CLK_Output_Select(0) |
-			AI_LOCALMUX_CLK_Output_Select(2) |
-			AI_SC_TC_Output_Select(3) |
-			AI_CONVERT_Output_Select(AI_CONVERT_Output_Enable_High),
-			AI_Output_Control_Register);
+				    AI_SOC_Polarity |
+				    AI_LOCALMUX_CLK_Pulse_Width,
+				    AI_Personal_Register);
+		devpriv->stc_writew(dev,
+				    AI_SCAN_IN_PROG_Output_Select(3) |
+				    AI_EXTMUX_CLK_Output_Select(0) |
+				    AI_LOCALMUX_CLK_Output_Select(2) |
+				    AI_SC_TC_Output_Select(3) |
+				    AI_CONVERT_Output_Select
+				    (AI_CONVERT_Output_Enable_High),
+				    AI_Output_Control_Register);
 	} else if (boardtype.reg_type == ni_reg_6143) {
 		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-			AI_SOC_Polarity |
-			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
-		devpriv->stc_writew(dev, AI_SCAN_IN_PROG_Output_Select(3) |
-			AI_EXTMUX_CLK_Output_Select(0) |
-			AI_LOCALMUX_CLK_Output_Select(2) |
-			AI_SC_TC_Output_Select(3) |
-			AI_CONVERT_Output_Select(AI_CONVERT_Output_Enable_Low),
-			AI_Output_Control_Register);
+				    AI_SOC_Polarity |
+				    AI_LOCALMUX_CLK_Pulse_Width,
+				    AI_Personal_Register);
+		devpriv->stc_writew(dev,
+				    AI_SCAN_IN_PROG_Output_Select(3) |
+				    AI_EXTMUX_CLK_Output_Select(0) |
+				    AI_LOCALMUX_CLK_Output_Select(2) |
+				    AI_SC_TC_Output_Select(3) |
+				    AI_CONVERT_Output_Select
+				    (AI_CONVERT_Output_Enable_Low),
+				    AI_Output_Control_Register);
 	} else {
 		unsigned ai_output_control_bits;
 		devpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |
-			AI_SOC_Polarity |
-			AI_CONVERT_Pulse_Width |
-			AI_LOCALMUX_CLK_Pulse_Width, AI_Personal_Register);
-		ai_output_control_bits = AI_SCAN_IN_PROG_Output_Select(3) |
-			AI_EXTMUX_CLK_Output_Select(0) |
-			AI_LOCALMUX_CLK_Output_Select(2) |
-			AI_SC_TC_Output_Select(3);
+				    AI_SOC_Polarity |
+				    AI_CONVERT_Pulse_Width |
+				    AI_LOCALMUX_CLK_Pulse_Width,
+				    AI_Personal_Register);
+		ai_output_control_bits =
+		    AI_SCAN_IN_PROG_Output_Select(3) |
+		    AI_EXTMUX_CLK_Output_Select(0) |
+		    AI_LOCALMUX_CLK_Output_Select(2) |
+		    AI_SC_TC_Output_Select(3);
 		if (boardtype.reg_type == ni_reg_622x)
 			ai_output_control_bits |=
-				AI_CONVERT_Output_Select
-				(AI_CONVERT_Output_Enable_High);
+			    AI_CONVERT_Output_Select
+			    (AI_CONVERT_Output_Enable_High);
 		else
 			ai_output_control_bits |=
-				AI_CONVERT_Output_Select
-				(AI_CONVERT_Output_Enable_Low);
+			    AI_CONVERT_Output_Select
+			    (AI_CONVERT_Output_Enable_Low);
 		devpriv->stc_writew(dev, ai_output_control_bits,
-			AI_Output_Control_Register);
+				    AI_Output_Control_Register);
 	}
 	/* the following registers should not be changed, because there
 	 * are no backup registers in devpriv.  If you want to change
@@ -1716,8 +1782,9 @@ static int ni_ai_poll(struct comedi_devi
 	return count;
 }
 
-static int ni_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ai_insn_read(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i, n;
 	const unsigned int mask = (1 << boardtype.adbits) - 1;
@@ -1733,31 +1800,31 @@ static int ni_ai_insn_read(struct comedi
 	if (boardtype.reg_type == ni_reg_611x) {
 		for (n = 0; n < num_adc_stages_611x; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			udelay(1);
 		}
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			/* The 611x has screwy 32-bit FIFOs. */
 			d = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (ni_readb(XXX_Status) & 0x80) {
 					d = (ni_readl(ADC_FIFO_Data_611x) >> 16)
-						& 0xffff;
+					    & 0xffff;
 					break;
 				}
 				if (!(devpriv->stc_readw(dev,
-							AI_Status_1_Register) &
-						AI_FIFO_Empty_St)) {
+							 AI_Status_1_Register) &
+				      AI_FIFO_Empty_St)) {
 					d = ni_readl(ADC_FIFO_Data_611x) &
-						0xffff;
+					    0xffff;
 					break;
 				}
 			}
 			if (i == NI_TIMEOUT) {
 				printk
-					("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
+				    ("ni_mio_common: timeout in 611x ni_ai_insn_read\n");
 				return -ETIME;
 			}
 			d += signbits;
@@ -1766,7 +1833,7 @@ static int ni_ai_insn_read(struct comedi
 	} else if (boardtype.reg_type == ni_reg_6143) {
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 
 			/* The 6143 has 32-bit FIFOs. You need to strobe a bit to move a single 16bit stranded sample into the FIFO */
 			dl = 0;
@@ -1779,7 +1846,7 @@ static int ni_ai_insn_read(struct comedi
 			}
 			if (i == NI_TIMEOUT) {
 				printk
-					("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
+				    ("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");
 				return -ETIME;
 			}
 			data[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;
@@ -1787,21 +1854,21 @@ static int ni_ai_insn_read(struct comedi
 	} else {
 		for (n = 0; n < insn->n; n++) {
 			devpriv->stc_writew(dev, AI_CONVERT_Pulse,
-				AI_Command_1_Register);
+					    AI_Command_1_Register);
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (!(devpriv->stc_readw(dev,
-							AI_Status_1_Register) &
-						AI_FIFO_Empty_St))
+							 AI_Status_1_Register) &
+				      AI_FIFO_Empty_St))
 					break;
 			}
 			if (i == NI_TIMEOUT) {
 				printk
-					("ni_mio_common: timeout in ni_ai_insn_read\n");
+				    ("ni_mio_common: timeout in ni_ai_insn_read\n");
 				return -ETIME;
 			}
 			if (boardtype.reg_type & ni_reg_m_series_mask) {
 				data[n] =
-					ni_readl(M_Offset_AI_FIFO_Data) & mask;
+				    ni_readl(M_Offset_AI_FIFO_Data) & mask;
 			} else {
 				d = ni_readw(ADC_FIFO_Data_Register);
 				d += signbits;	/* subtle: needs to be short addition */
@@ -1818,8 +1885,8 @@ void ni_prime_channelgain_list(struct co
 	devpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);
 	for (i = 0; i < NI_TIMEOUT; ++i) {
 		if (!(devpriv->stc_readw(dev,
-					AI_Status_1_Register) &
-				AI_FIFO_Empty_St)) {
+					 AI_Status_1_Register) &
+		      AI_FIFO_Empty_St)) {
 			devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
 			return;
 		}
@@ -1829,7 +1896,8 @@ void ni_prime_channelgain_list(struct co
 }
 
 static void ni_m_series_load_channelgain_list(struct comedi_device *dev,
-	unsigned int n_chan, unsigned int *list)
+					      unsigned int n_chan,
+					      unsigned int *list)
 {
 	unsigned int chan, range, aref;
 	unsigned int i;
@@ -1849,11 +1917,11 @@ static void ni_m_series_load_channelgain
 		bypass_bits = MSeries_AI_Bypass_Config_FIFO_Bit;
 		bypass_bits |= chan;
 		bypass_bits |=
-			(devpriv->
-			ai_calib_source) & (MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
-			MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
-			MSeries_AI_Bypass_Mode_Mux_Mask |
-			MSeries_AO_Bypass_AO_Cal_Sel_Mask);
+		    (devpriv->ai_calib_source) &
+		    (MSeries_AI_Bypass_Cal_Sel_Pos_Mask |
+		     MSeries_AI_Bypass_Cal_Sel_Neg_Mask |
+		     MSeries_AI_Bypass_Mode_Mux_Mask |
+		     MSeries_AO_Bypass_AO_Cal_Sel_Mask);
 		bypass_bits |= MSeries_AI_Bypass_Gain_Bits(range_code);
 		if (dither)
 			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
@@ -1876,22 +1944,22 @@ static void ni_m_series_load_channelgain
 		switch (aref) {
 		case AREF_DIFF:
 			config_bits |=
-				MSeries_AI_Config_Channel_Type_Differential_Bits;
+			    MSeries_AI_Config_Channel_Type_Differential_Bits;
 			break;
 		case AREF_COMMON:
 			config_bits |=
-				MSeries_AI_Config_Channel_Type_Common_Ref_Bits;
+			    MSeries_AI_Config_Channel_Type_Common_Ref_Bits;
 			break;
 		case AREF_GROUND:
 			config_bits |=
-				MSeries_AI_Config_Channel_Type_Ground_Ref_Bits;
+			    MSeries_AI_Config_Channel_Type_Ground_Ref_Bits;
 			break;
 		case AREF_OTHER:
 			break;
 		}
 		config_bits |= MSeries_AI_Config_Channel_Bits(chan);
 		config_bits |=
-			MSeries_AI_Config_Bank_Bits(boardtype.reg_type, chan);
+		    MSeries_AI_Config_Bank_Bits(boardtype.reg_type, chan);
 		config_bits |= MSeries_AI_Config_Gain_Bits(range_code);
 		if (i == n_chan - 1)
 			config_bits |= MSeries_AI_Config_Last_Channel_Bit;
@@ -1933,8 +2001,8 @@ static void ni_m_series_load_channelgain
  *   bits 0-2: channel
  *       valid channels are 0-3
  */
-static void ni_load_channelgain_list(struct comedi_device *dev, unsigned int n_chan,
-	unsigned int *list)
+static void ni_load_channelgain_list(struct comedi_device *dev,
+				     unsigned int n_chan, unsigned int *list)
 {
 	unsigned int chan, range, aref;
 	unsigned int i;
@@ -1947,9 +2015,9 @@ static void ni_load_channelgain_list(str
 		return;
 	}
 	if (n_chan == 1 && (boardtype.reg_type != ni_reg_611x)
-		&& (boardtype.reg_type != ni_reg_6143)) {
+	    && (boardtype.reg_type != ni_reg_6143)) {
 		if (devpriv->changain_state
-			&& devpriv->changain_spec == list[0]) {
+		    && devpriv->changain_spec == list[0]) {
 			/*  ready to go. */
 			return;
 		}
@@ -1964,25 +2032,23 @@ static void ni_load_channelgain_list(str
 	/*  Set up Calibration mode if required */
 	if (boardtype.reg_type == ni_reg_6143) {
 		if ((list[0] & CR_ALT_SOURCE)
-			&& !devpriv->ai_calib_source_enabled) {
+		    && !devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay enable bit */
-			ni_writew(devpriv->
-				ai_calib_source |
-				Calibration_Channel_6143_RelayOn,
-				Calibration_Channel_6143);
+			ni_writew(devpriv->ai_calib_source |
+				  Calibration_Channel_6143_RelayOn,
+				  Calibration_Channel_6143);
 			ni_writew(devpriv->ai_calib_source,
-				Calibration_Channel_6143);
+				  Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 1;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		} else if (!(list[0] & CR_ALT_SOURCE)
-			&& devpriv->ai_calib_source_enabled) {
+			   && devpriv->ai_calib_source_enabled) {
 			/*  Strobe Relay disable bit */
-			ni_writew(devpriv->
-				ai_calib_source |
-				Calibration_Channel_6143_RelayOff,
-				Calibration_Channel_6143);
+			ni_writew(devpriv->ai_calib_source |
+				  Calibration_Channel_6143_RelayOff,
+				  Calibration_Channel_6143);
 			ni_writew(devpriv->ai_calib_source,
-				Calibration_Channel_6143);
+				  Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 0;
 			msleep_interruptible(100);	/*  Allow relays to change */
 		}
@@ -1991,7 +2057,7 @@ static void ni_load_channelgain_list(str
 	offset = 1 << (boardtype.adbits - 1);
 	for (i = 0; i < n_chan; i++) {
 		if ((boardtype.reg_type != ni_reg_6143)
-			&& (list[i] & CR_ALT_SOURCE)) {
+		    && (list[i] & CR_ALT_SOURCE)) {
 			chan = devpriv->ai_calib_source;
 		} else {
 			chan = CR_CHAN(list[i]);
@@ -2011,7 +2077,7 @@ static void ni_load_channelgain_list(str
 		if ((list[i] & CR_ALT_SOURCE)) {
 			if (boardtype.reg_type == ni_reg_611x)
 				ni_writew(CR_CHAN(list[i]) & 0x0003,
-					Calibration_Channel_Select_611x);
+					  Calibration_Channel_Select_611x);
 		} else {
 			if (boardtype.reg_type == ni_reg_611x)
 				aref = AREF_DIFF;
@@ -2048,13 +2114,13 @@ static void ni_load_channelgain_list(str
 
 	/* prime the channel/gain list */
 	if ((boardtype.reg_type != ni_reg_611x)
-		&& (boardtype.reg_type != ni_reg_6143)) {
+	    && (boardtype.reg_type != ni_reg_6143)) {
 		ni_prime_channelgain_list(dev);
 	}
 }
 
 static int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,
-	int round_mode)
+			  int round_mode)
 {
 	int divider;
 	switch (round_mode) {
@@ -2078,7 +2144,7 @@ static unsigned ni_timer_to_ns(const str
 }
 
 static unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,
-	unsigned num_channels)
+					 unsigned num_channels)
 {
 	switch (boardtype.reg_type) {
 	case ni_reg_611x:
@@ -2094,7 +2160,7 @@ static unsigned ni_min_ai_scan_period_ns
 }
 
 static int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			 struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -2119,7 +2185,7 @@ static int ni_ai_cmdtest(struct comedi_d
 	tmp = cmd->convert_src;
 	sources = TRIG_TIMER | TRIG_EXT;
 	if ((boardtype.reg_type == ni_reg_611x)
-		|| (boardtype.reg_type == ni_reg_6143))
+	    || (boardtype.reg_type == ni_reg_6143))
 		sources |= TRIG_NOW;
 	cmd->convert_src &= sources;
 	if (!cmd->convert_src || tmp != cmd->convert_src)
@@ -2142,14 +2208,14 @@ static int ni_ai_cmdtest(struct comedi_d
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->start_src != TRIG_NOW &&
-		cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
+	    cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_OTHER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_OTHER)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -2179,10 +2245,11 @@ static int ni_ai_cmdtest(struct comedi_d
 	}
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg < ni_min_ai_scan_period_ns(dev,
-				cmd->chanlist_len)) {
+								   cmd->
+								   chanlist_len))
+		{
 			cmd->scan_begin_arg =
-				ni_min_ai_scan_period_ns(dev,
-				cmd->chanlist_len);
+			    ni_min_ai_scan_period_ns(dev, cmd->chanlist_len);
 			err++;
 		}
 		if (cmd->scan_begin_arg > devpriv->clock_ns * 0xffffff) {
@@ -2208,7 +2275,7 @@ static int ni_ai_cmdtest(struct comedi_d
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		if ((boardtype.reg_type == ni_reg_611x)
-			|| (boardtype.reg_type == ni_reg_6143)) {
+		    || (boardtype.reg_type == ni_reg_6143)) {
 			if (cmd->convert_arg != 0) {
 				cmd->convert_arg = 0;
 				err++;
@@ -2274,27 +2341,31 @@ static int ni_ai_cmdtest(struct comedi_d
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		cmd->scan_begin_arg =
-			ni_timer_to_ns(dev, ni_ns_to_timer(dev,
-				cmd->scan_begin_arg,
-				cmd->flags & TRIG_ROUND_MASK));
+		    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+						       cmd->scan_begin_arg,
+						       cmd->
+						       flags &
+						       TRIG_ROUND_MASK));
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		if ((boardtype.reg_type != ni_reg_611x)
-			&& (boardtype.reg_type != ni_reg_6143)) {
+		    && (boardtype.reg_type != ni_reg_6143)) {
 			tmp = cmd->convert_arg;
 			cmd->convert_arg =
-				ni_timer_to_ns(dev, ni_ns_to_timer(dev,
-					cmd->convert_arg,
-					cmd->flags & TRIG_ROUND_MASK));
+			    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+							       cmd->convert_arg,
+							       cmd->
+							       flags &
+							       TRIG_ROUND_MASK));
 			if (tmp != cmd->convert_arg)
 				err++;
 			if (cmd->scan_begin_src == TRIG_TIMER &&
-				cmd->scan_begin_arg <
-				cmd->convert_arg * cmd->scan_end_arg) {
+			    cmd->scan_begin_arg <
+			    cmd->convert_arg * cmd->scan_end_arg) {
 				cmd->scan_begin_arg =
-					cmd->convert_arg * cmd->scan_end_arg;
+				    cmd->convert_arg * cmd->scan_end_arg;
 				err++;
 			}
 		}
@@ -2332,27 +2403,28 @@ static int ni_ai_cmd(struct comedi_devic
 	 * interferes with the use of pfi0 */
 	devpriv->an_trig_etc_reg &= ~Analog_Trigger_Enable;
 	devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-		Analog_Trigger_Etc_Register);
+			    Analog_Trigger_Etc_Register);
 
 	switch (cmd->start_src) {
 	case TRIG_INT:
 	case TRIG_NOW:
 		devpriv->stc_writew(dev, AI_START2_Select(0) |
-			AI_START1_Sync | AI_START1_Edge | AI_START1_Select(0),
-			AI_Trigger_Select_Register);
+				    AI_START1_Sync | AI_START1_Edge |
+				    AI_START1_Select(0),
+				    AI_Trigger_Select_Register);
 		break;
 	case TRIG_EXT:
 		{
 			int chan = CR_CHAN(cmd->start_arg);
 			unsigned int bits = AI_START2_Select(0) |
-				AI_START1_Sync | AI_START1_Select(chan + 1);
+			    AI_START1_Sync | AI_START1_Select(chan + 1);
 
 			if (cmd->start_arg & CR_INVERT)
 				bits |= AI_START1_Polarity;
 			if (cmd->start_arg & CR_EDGE)
 				bits |= AI_START1_Edge;
 			devpriv->stc_writew(dev, bits,
-				AI_Trigger_Select_Register);
+					    AI_Trigger_Select_Register);
 			break;
 		}
 	}
@@ -2363,7 +2435,7 @@ static int ni_ai_cmd(struct comedi_devic
 	devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
 
 	if (cmd->chanlist_len == 1 || (boardtype.reg_type == ni_reg_611x)
-		|| (boardtype.reg_type == ni_reg_6143)) {
+	    || (boardtype.reg_type == ni_reg_6143)) {
 		start_stop_select |= AI_STOP_Polarity;
 		start_stop_select |= AI_STOP_Select(31);	/*  logic low */
 		start_stop_select |= AI_STOP_Sync;
@@ -2371,7 +2443,7 @@ static int ni_ai_cmd(struct comedi_devic
 		start_stop_select |= AI_STOP_Select(19);	/*  ai configuration memory */
 	}
 	devpriv->stc_writew(dev, start_stop_select,
-		AI_START_STOP_Select_Register);
+			    AI_START_STOP_Select_Register);
 
 	devpriv->ai_cmd2 = 0;
 	switch (cmd->stop_src) {
@@ -2397,7 +2469,7 @@ static int ni_ai_cmd(struct comedi_devic
 			/*  this is required to get the last sample for chanlist_len > 1, not sure why */
 			if (cmd->chanlist_len > 1)
 				start_stop_select |=
-					AI_STOP_Polarity | AI_STOP_Edge;
+				    AI_STOP_Polarity | AI_STOP_Edge;
 		}
 		break;
 	case TRIG_NONE:
@@ -2433,7 +2505,7 @@ static int ni_ai_cmd(struct comedi_devic
 		 */
 		start_stop_select |= AI_START_Edge | AI_START_Sync;
 		devpriv->stc_writew(dev, start_stop_select,
-			AI_START_STOP_Select_Register);
+				    AI_START_STOP_Select_Register);
 
 		mode2 |= AI_SI_Reload_Mode(0);
 		/* AI_SI_Initial_Load_Source=A */
@@ -2443,7 +2515,7 @@ static int ni_ai_cmd(struct comedi_devic
 
 		/* load SI */
 		timer = ni_ns_to_timer(dev, cmd->scan_begin_arg,
-			TRIG_ROUND_NEAREST);
+				       TRIG_ROUND_NEAREST);
 		devpriv->stc_writel(dev, timer, AI_SI_Load_A_Registers);
 		devpriv->stc_writew(dev, AI_SI_Load, AI_Command_1_Register);
 		break;
@@ -2454,13 +2526,13 @@ static int ni_ai_cmd(struct comedi_devic
 		if (cmd->scan_begin_arg & CR_INVERT)
 			start_stop_select |= AI_START_Polarity;
 		if (cmd->scan_begin_src != cmd->convert_src ||
-			(cmd->scan_begin_arg & ~CR_EDGE) !=
-			(cmd->convert_arg & ~CR_EDGE))
+		    (cmd->scan_begin_arg & ~CR_EDGE) !=
+		    (cmd->convert_arg & ~CR_EDGE))
 			start_stop_select |= AI_START_Sync;
 		start_stop_select |=
-			AI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));
+		    AI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));
 		devpriv->stc_writew(dev, start_stop_select,
-			AI_START_STOP_Select_Register);
+				    AI_START_STOP_Select_Register);
 		break;
 	}
 
@@ -2471,7 +2543,7 @@ static int ni_ai_cmd(struct comedi_devic
 			timer = 1;
 		else
 			timer = ni_ns_to_timer(dev, cmd->convert_arg,
-				TRIG_ROUND_NEAREST);
+					       TRIG_ROUND_NEAREST);
 		devpriv->stc_writew(dev, 1, AI_SI2_Load_A_Register);	/* 0,0 does not work. */
 		devpriv->stc_writew(dev, timer, AI_SI2_Load_B_Register);
 
@@ -2505,14 +2577,14 @@ static int ni_ai_cmd(struct comedi_devic
 
 		/* interrupt on FIFO, errors, SC_TC */
 		interrupt_a_enable |= AI_Error_Interrupt_Enable |
-			AI_SC_TC_Interrupt_Enable;
+		    AI_SC_TC_Interrupt_Enable;
 
 #ifndef PCIDMA
 		interrupt_a_enable |= AI_FIFO_Interrupt_Enable;
 #endif
 
 		if (cmd->flags & TRIG_WAKE_EOS
-			|| (devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
+		    || (devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {
 			/* wake on end-of-scan */
 			devpriv->aimode = AIMODE_SCAN;
 		} else {
@@ -2524,24 +2596,24 @@ static int ni_ai_cmd(struct comedi_devic
 			/*generate FIFO interrupts and DMA requests on half-full */
 #ifdef PCIDMA
 			devpriv->stc_writew(dev, AI_FIFO_Mode_HF_to_E,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 #else
 			devpriv->stc_writew(dev, AI_FIFO_Mode_HF,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 #endif
 			break;
 		case AIMODE_SAMPLE:
 			/*generate FIFO interrupts on non-empty */
 			devpriv->stc_writew(dev, AI_FIFO_Mode_NE,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 			break;
 		case AIMODE_SCAN:
 #ifdef PCIDMA
 			devpriv->stc_writew(dev, AI_FIFO_Mode_NE,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 #else
 			devpriv->stc_writew(dev, AI_FIFO_Mode_HF,
-				AI_Mode_3_Register);
+					    AI_Mode_3_Register);
 #endif
 			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
 			break;
@@ -2552,10 +2624,10 @@ static int ni_ai_cmd(struct comedi_devic
 		devpriv->stc_writew(dev, AI_Error_Interrupt_Ack | AI_STOP_Interrupt_Ack | AI_START_Interrupt_Ack | AI_START2_Interrupt_Ack | AI_START1_Interrupt_Ack | AI_SC_TC_Interrupt_Ack | AI_SC_TC_Error_Confirm, Interrupt_A_Ack_Register);	/* clear interrupts */
 
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			interrupt_a_enable, 1);
+			    interrupt_a_enable, 1);
 
 		MDPRINTK("Interrupt_A_Enable_Register = 0x%04x\n",
-			devpriv->int_a_enable_reg);
+			 devpriv->int_a_enable_reg);
 	} else {
 		/* interrupt on nothing */
 		ni_set_bits(dev, Interrupt_A_Enable_Register, ~0, 0);
@@ -2570,14 +2642,14 @@ static int ni_ai_cmd(struct comedi_devic
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		devpriv->stc_writew(dev,
-			AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
-			AI_Command_1_Register);
+				    AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm |
+				    AI_SC_Arm, AI_Command_1_Register);
 		break;
 	case TRIG_EXT:
 		/* XXX AI_SI_Arm? */
 		devpriv->stc_writew(dev,
-			AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm | AI_SC_Arm,
-			AI_Command_1_Register);
+				    AI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm |
+				    AI_SC_Arm, AI_Command_1_Register);
 		break;
 	}
 
@@ -2594,7 +2666,7 @@ static int ni_ai_cmd(struct comedi_devic
 	case TRIG_NOW:
 		/* AI_START1_Pulse */
 		devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-			AI_Command_2_Register);
+				    AI_Command_2_Register);
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_EXT:
@@ -2611,23 +2683,26 @@ static int ni_ai_cmd(struct comedi_devic
 }
 
 static int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			 unsigned int trignum)
 {
 	if (trignum != 0)
 		return -EINVAL;
 
 	devpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,
-		AI_Command_2_Register);
+			    AI_Command_2_Register);
 	s->async->inttrig = NULL;
 
 	return 1;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-
-static int ni_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ai_config_analog_trig(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data);
+
+static int ni_ai_insn_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n < 1)
 		return -EINVAL;
@@ -2666,7 +2741,7 @@ static int ni_ai_insn_config(struct come
 			devpriv->ai_calib_source = calib_source;
 			if (boardtype.reg_type == ni_reg_611x) {
 				ni_writeb(calib_source_adjust,
-					Cal_Gain_Select_611x);
+					  Cal_Gain_Select_611x);
 			}
 		}
 		return 2;
@@ -2677,8 +2752,10 @@ static int ni_ai_insn_config(struct come
 	return -EINVAL;
 }
 
-static int ni_ai_config_analog_trig(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ai_config_analog_trig(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	unsigned int a, b, modebits;
 	int err = 0;
@@ -2730,8 +2807,7 @@ static int ni_ai_config_analog_trig(stru
 			a = data[4];
 			b = data[3];
 			modebits =
-				((data[1] & 0xf) << 4) | ((data[1] & 0xf0) >>
-				4);
+			    ((data[1] & 0xf) << 4) | ((data[1] & 0xf0) >> 4);
 		}
 		devpriv->atrig_low = a;
 		devpriv->atrig_high = b;
@@ -2776,7 +2852,8 @@ static int ni_ai_config_analog_trig(stru
 
 /* munge data from unsigned to 2's complement for analog output bipolar modes */
 static void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *data, unsigned int num_bytes, unsigned int chan_index)
+			void *data, unsigned int num_bytes,
+			unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
 	unsigned int range;
@@ -2799,8 +2876,9 @@ static void ni_ao_munge(struct comedi_de
 }
 
 static int ni_m_series_ao_config_chanlist(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int chanspec[], unsigned int n_chans,
-	int timed)
+					  struct comedi_subdevice *s,
+					  unsigned int chanspec[],
+					  unsigned int n_chans, int timed)
 {
 	unsigned int range;
 	unsigned int chan;
@@ -2811,7 +2889,8 @@ static int ni_m_series_ao_config_chanlis
 	if (timed) {
 		for (i = 0; i < boardtype.n_aochan; ++i) {
 			devpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;
-			ni_writeb(devpriv->ao_conf[i], M_Offset_AO_Config_Bank(i));
+			ni_writeb(devpriv->ao_conf[i],
+				  M_Offset_AO_Config_Bank(i));
 			ni_writeb(0xf, M_Offset_AO_Waveform_Order(i));
 		}
 	}
@@ -2834,16 +2913,16 @@ static int ni_m_series_ao_config_chanlis
 		case 4000000:
 			conf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;
 			ni_writeb(MSeries_Attenuate_x5_Bit,
-				M_Offset_AO_Reference_Attenuation(chan));
+				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		case 2000000:
 			conf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;
 			ni_writeb(MSeries_Attenuate_x5_Bit,
-				M_Offset_AO_Reference_Attenuation(chan));
+				  M_Offset_AO_Reference_Attenuation(chan));
 			break;
 		default:
 			printk("%s: bug! unhandled ao reference voltage\n",
-				__func__);
+			       __func__);
 			break;
 		}
 		switch (krange->max + krange->min) {
@@ -2855,7 +2934,7 @@ static int ni_m_series_ao_config_chanlis
 			break;
 		default:
 			printk("%s: bug! unhandled ao offset voltage\n",
-				__func__);
+			       __func__);
 			break;
 		}
 		if (timed)
@@ -2867,8 +2946,10 @@ static int ni_m_series_ao_config_chanlis
 	return invert;
 }
 
-static int ni_old_ao_config_chanlist(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int chanspec[], unsigned int n_chans)
+static int ni_old_ao_config_chanlist(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     unsigned int chanspec[],
+				     unsigned int n_chans)
 {
 	unsigned int range;
 	unsigned int chan;
@@ -2902,7 +2983,7 @@ static int ni_old_ao_config_chanlist(str
 		/* analog reference */
 		/* AREF_OTHER connects AO ground to AI ground, i think */
 		conf |= (CR_AREF(chanspec[i]) ==
-			AREF_OTHER) ? AO_Ground_Ref : 0;
+			 AREF_OTHER) ? AO_Ground_Ref : 0;
 
 		ni_writew(conf, AO_Configuration);
 		devpriv->ao_conf[chan] = conf;
@@ -2910,25 +2991,30 @@ static int ni_old_ao_config_chanlist(str
 	return invert;
 }
 
-static int ni_ao_config_chanlist(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int chanspec[], unsigned int n_chans, int timed)
+static int ni_ao_config_chanlist(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 unsigned int chanspec[], unsigned int n_chans,
+				 int timed)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return ni_m_series_ao_config_chanlist(dev, s, chanspec, n_chans,
-			timed);
+						      timed);
 	else
 		return ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);
 }
-static int ni_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+
+static int ni_ao_insn_read(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int ni_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ao_insn_write(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2941,13 +3027,14 @@ static int ni_ao_insn_write(struct comed
 		ni_writew(data[0], M_Offset_DAC_Direct_Data(chan));
 	} else
 		ni_writew(data[0] ^ invert,
-			(chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
+			  (chan) ? DAC1_Direct_Data : DAC0_Direct_Data);
 
 	return 1;
 }
 
-static int ni_ao_insn_write_671x(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ao_insn_write_671x(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int invert;
@@ -2963,16 +3050,17 @@ static int ni_ao_insn_write_671x(struct 
 	return 1;
 }
 
-static int ni_ao_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_ao_insn_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
-		switch (data[1])
-		{
+		switch (data[1]) {
 		case COMEDI_OUTPUT:
 			data[2] = 1 + boardtype.ao_fifo_depth * sizeof(short);
-			if (devpriv->mite) data[2] += devpriv->mite->fifo_size;
+			if (devpriv->mite)
+				data[2] += devpriv->mite->fifo_size;
 			break;
 		case COMEDI_INPUT:
 			data[2] = 0;
@@ -2990,7 +3078,7 @@ static int ni_ao_insn_config(struct come
 }
 
 static int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			 unsigned int trignum)
 {
 	int ret;
 	int interrupt_b_bits;
@@ -3006,7 +3094,7 @@ static int ni_ao_inttrig(struct comedi_d
 	s->async->inttrig = NULL;
 
 	ni_set_bits(dev, Interrupt_B_Enable_Register,
-		AO_FIFO_Interrupt_Enable | AO_Error_Interrupt_Enable, 0);
+		    AO_FIFO_Interrupt_Enable | AO_Error_Interrupt_Enable, 0);
 	interrupt_b_bits = AO_Error_Interrupt_Enable;
 #ifdef PCIDMA
 	devpriv->stc_writew(dev, 1, DAC_FIFO_Clear);
@@ -3027,35 +3115,34 @@ static int ni_ao_inttrig(struct comedi_d
 #endif
 
 	devpriv->stc_writew(dev, devpriv->ao_mode3 | AO_Not_An_UPDATE,
-		AO_Mode_3_Register);
+			    AO_Mode_3_Register);
 	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	/* wait for DACs to be loaded */
 	for (i = 0; i < timeout; i++) {
 		udelay(1);
 		if ((devpriv->stc_readw(dev,
 					Joint_Status_2_Register) &
-				AO_TMRDACWRs_In_Progress_St) == 0)
+		     AO_TMRDACWRs_In_Progress_St) == 0)
 			break;
 	}
 	if (i == timeout) {
 		comedi_error(dev,
-			"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
+			     "timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
 		return -EIO;
 	}
 	/*  stc manual says we are need to clear error interrupt after AO_TMRDACWRs_In_Progress_St clears */
 	devpriv->stc_writew(dev, AO_Error_Interrupt_Ack,
-		Interrupt_B_Ack_Register);
+			    Interrupt_B_Ack_Register);
 
 	ni_set_bits(dev, Interrupt_B_Enable_Register, interrupt_b_bits, 1);
 
 	devpriv->stc_writew(dev,
-		devpriv->
-		ao_cmd1 | AO_UI_Arm | AO_UC_Arm | AO_BC_Arm |
-		AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
-		AO_Command_1_Register);
+			    devpriv->ao_cmd1 | AO_UI_Arm | AO_UC_Arm | AO_BC_Arm
+			    | AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,
+			    AO_Command_1_Register);
 
 	devpriv->stc_writew(dev, devpriv->ao_cmd2 | AO_START1_Pulse,
-		AO_Command_2_Register);
+			    AO_Command_2_Register);
 
 	return 0;
 }
@@ -3104,18 +3191,20 @@ static int ni_ao_cmd(struct comedi_devic
 	case TRIG_INT:
 	case TRIG_NOW:
 		devpriv->ao_trigger_select &=
-			~(AO_START1_Polarity | AO_START1_Select(-1));
+		    ~(AO_START1_Polarity | AO_START1_Select(-1));
 		devpriv->ao_trigger_select |= AO_START1_Edge | AO_START1_Sync;
 		devpriv->stc_writew(dev, devpriv->ao_trigger_select,
-			AO_Trigger_Select_Register);
+				    AO_Trigger_Select_Register);
 		break;
 	case TRIG_EXT:
-                devpriv->ao_trigger_select = AO_START1_Select(CR_CHAN(cmd->start_arg)+1);
+		devpriv->ao_trigger_select =
+		    AO_START1_Select(CR_CHAN(cmd->start_arg) + 1);
 		if (cmd->start_arg & CR_INVERT)
-			devpriv->ao_trigger_select |= AO_START1_Polarity;  /*  0=active high, 1=active low. see daq-stc 3-24 (p186) */
+			devpriv->ao_trigger_select |= AO_START1_Polarity;	/*  0=active high, 1=active low. see daq-stc 3-24 (p186) */
 		if (cmd->start_arg & CR_EDGE)
-			devpriv->ao_trigger_select |= AO_START1_Edge;      /*  0=edge detection disabled, 1=enabled */
-		devpriv->stc_writew(dev, devpriv->ao_trigger_select, AO_Trigger_Select_Register);
+			devpriv->ao_trigger_select |= AO_START1_Edge;	/*  0=edge detection disabled, 1=enabled */
+		devpriv->stc_writew(dev, devpriv->ao_trigger_select,
+				    AO_Trigger_Select_Register);
 		break;
 	default:
 		BUG();
@@ -3137,17 +3226,19 @@ static int ni_ao_cmd(struct comedi_devic
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if (boardtype.reg_type & ni_reg_m_series_mask)
-		{
+		if (boardtype.reg_type & ni_reg_m_series_mask) {
 			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
-			devpriv->stc_writel(dev, cmd->stop_arg - 1, AO_UC_Load_A_Register);
-			devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
-		}else
-		{
-			devpriv->stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);
-			devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
 			devpriv->stc_writel(dev, cmd->stop_arg - 1,
-				AO_UC_Load_A_Register);
+					    AO_UC_Load_A_Register);
+			devpriv->stc_writew(dev, AO_UC_Load,
+					    AO_Command_1_Register);
+		} else {
+			devpriv->stc_writel(dev, cmd->stop_arg,
+					    AO_UC_Load_A_Register);
+			devpriv->stc_writew(dev, AO_UC_Load,
+					    AO_Command_1_Register);
+			devpriv->stc_writel(dev, cmd->stop_arg - 1,
+					    AO_UC_Load_A_Register);
 		}
 		break;
 	case TRIG_NONE:
@@ -3162,21 +3253,21 @@ static int ni_ao_cmd(struct comedi_devic
 	}
 
 	devpriv->ao_mode1 &=
-		~(AO_UI_Source_Select(0x1f) | AO_UI_Source_Polarity |
-		AO_UPDATE_Source_Select(0x1f) | AO_UPDATE_Source_Polarity);
+	    ~(AO_UI_Source_Select(0x1f) | AO_UI_Source_Polarity |
+	      AO_UPDATE_Source_Select(0x1f) | AO_UPDATE_Source_Polarity);
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		devpriv->ao_cmd2 &= ~AO_BC_Gate_Enable;
 		trigvar =
-			ni_ns_to_timer(dev, cmd->scan_begin_arg,
-			TRIG_ROUND_NEAREST);
+		    ni_ns_to_timer(dev, cmd->scan_begin_arg,
+				   TRIG_ROUND_NEAREST);
 		devpriv->stc_writel(dev, 1, AO_UI_Load_A_Register);
 		devpriv->stc_writew(dev, AO_UI_Load, AO_Command_1_Register);
 		devpriv->stc_writel(dev, trigvar, AO_UI_Load_A_Register);
 		break;
 	case TRIG_EXT:
 		devpriv->ao_mode1 |=
-			AO_UPDATE_Source_Select(cmd->scan_begin_arg);
+		    AO_UPDATE_Source_Select(cmd->scan_begin_arg);
 		if (cmd->scan_begin_arg & CR_INVERT)
 			devpriv->ao_mode1 |= AO_UPDATE_Source_Polarity;
 		devpriv->ao_cmd2 |= AO_BC_Gate_Enable;
@@ -3188,34 +3279,34 @@ static int ni_ao_cmd(struct comedi_devic
 	devpriv->stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);
 	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 	devpriv->ao_mode2 &=
-		~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
+	    ~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 
 	if (cmd->scan_end_arg > 1) {
 		devpriv->ao_mode1 |= AO_Multiple_Channels;
 		devpriv->stc_writew(dev,
-			AO_Number_Of_Channels(cmd->scan_end_arg -
-				1) |
-			AO_UPDATE_Output_Select
-			(AO_Update_Output_High_Z),
-			AO_Output_Control_Register);
+				    AO_Number_Of_Channels(cmd->scan_end_arg -
+							  1) |
+				    AO_UPDATE_Output_Select
+				    (AO_Update_Output_High_Z),
+				    AO_Output_Control_Register);
 	} else {
 		unsigned bits;
 		devpriv->ao_mode1 &= ~AO_Multiple_Channels;
 		bits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);
-		if (boardtype.reg_type & (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {
+		if (boardtype.
+		    reg_type & (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {
 			bits |= AO_Number_Of_Channels(0);
 		} else {
-			bits |= AO_Number_Of_Channels(CR_CHAN(cmd->
-					chanlist[0]));
+			bits |=
+			    AO_Number_Of_Channels(CR_CHAN(cmd->chanlist[0]));
 		}
-		devpriv->stc_writew(dev, bits,
-			AO_Output_Control_Register);
+		devpriv->stc_writew(dev, bits, AO_Output_Control_Register);
 	}
 	devpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);
 
 	devpriv->stc_writew(dev, AO_DAC0_Update_Mode | AO_DAC1_Update_Mode,
-		AO_Command_1_Register);
+			    AO_Command_1_Register);
 
 	devpriv->ao_mode3 |= AO_Stop_On_Overrun_Error;
 	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
@@ -3230,7 +3321,7 @@ static int ni_ao_cmd(struct comedi_devic
 	devpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);
 
 	bits = AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
-		AO_TMRDACWR_Pulse_Width;
+	    AO_TMRDACWR_Pulse_Width;
 	if (boardtype.ao_fifo_depth)
 		bits |= AO_FIFO_Enable;
 	else
@@ -3249,9 +3340,9 @@ static int ni_ao_cmd(struct comedi_devic
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->stc_writew(dev, AO_BC_TC_Interrupt_Ack,
-			Interrupt_B_Ack_Register);
+				    Interrupt_B_Ack_Register);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			AO_BC_TC_Interrupt_Enable, 1);
+			    AO_BC_TC_Interrupt_Enable, 1);
 	}
 
 	s->async->inttrig = &ni_ao_inttrig;
@@ -3260,7 +3351,7 @@ static int ni_ao_cmd(struct comedi_devic
 }
 
 static int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			 struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3365,9 +3456,11 @@ static int ni_ao_cmdtest(struct comedi_d
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		cmd->scan_begin_arg =
-			ni_timer_to_ns(dev, ni_ns_to_timer(dev,
-				cmd->scan_begin_arg,
-				cmd->flags & TRIG_ROUND_MASK));
+		    ni_timer_to_ns(dev, ni_ns_to_timer(dev,
+						       cmd->scan_begin_arg,
+						       cmd->
+						       flags &
+						       TRIG_ROUND_MASK));
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -3398,7 +3491,7 @@ static int ni_ao_reset(struct comedi_dev
 	devpriv->stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);
 	devpriv->stc_writew(dev, 0x3f98, Interrupt_B_Ack_Register);
 	devpriv->stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |
-		AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
+			    AO_TMRDACWR_Pulse_Width, AO_Personal_Register);
 	devpriv->stc_writew(dev, 0, AO_Output_Control_Register);
 	devpriv->stc_writew(dev, 0, AO_Start_Select_Register);
 	devpriv->ao_cmd1 = 0;
@@ -3416,12 +3509,11 @@ static int ni_ao_reset(struct comedi_dev
 	devpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);
 	devpriv->ao_trigger_select = 0;
 	devpriv->stc_writew(dev, devpriv->ao_trigger_select,
-		AO_Trigger_Select_Register);
+			    AO_Trigger_Select_Register);
 	if (boardtype.reg_type & ni_reg_6xxx_mask) {
 		unsigned immediate_bits = 0;
 		unsigned i;
-		for (i = 0; i < s->n_chan; ++i)
-		{
+		for (i = 0; i < s->n_chan; ++i) {
 			immediate_bits |= 1 << i;
 		}
 		ao_win_out(immediate_bits, AO_Immediate_671x);
@@ -3434,12 +3526,13 @@ static int ni_ao_reset(struct comedi_dev
 
 /* digital io */
 
-static int ni_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_dio_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	printk("ni_dio_insn_config() chan=%d io=%d\n",
-		CR_CHAN(insn->chanspec), data[0]);
+	       CR_CHAN(insn->chanspec), data[0]);
 #endif
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -3450,9 +3543,9 @@ static int ni_dio_insn_config(struct com
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -3466,8 +3559,9 @@ static int ni_dio_insn_config(struct com
 	return 1;
 }
 
-static int ni_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_dio_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	printk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);
@@ -3478,7 +3572,7 @@ static int ni_dio_insn_bits(struct comed
 		/* Perform check to make sure we're not using the
 		   serial part of the dio */
 		if ((data[0] & (DIO_SDIN | DIO_SDOUT))
-			&& devpriv->serial_interval_ns)
+		    && devpriv->serial_interval_ns)
 			return -EBUSY;
 
 		s->state &= ~data[0];
@@ -3486,7 +3580,7 @@ static int ni_dio_insn_bits(struct comed
 		devpriv->dio_output &= ~DIO_Parallel_Data_Mask;
 		devpriv->dio_output |= DIO_Parallel_Data_Out(s->state);
 		devpriv->stc_writew(dev, devpriv->dio_output,
-			DIO_Output_Register);
+				    DIO_Output_Register);
 	}
 	data[1] = devpriv->stc_readw(dev, DIO_Parallel_Input_Register);
 
@@ -3494,11 +3588,13 @@ static int ni_dio_insn_bits(struct comed
 }
 
 static int ni_m_series_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	printk("ni_m_series_dio_insn_config() chan=%d io=%d\n",
-		CR_CHAN(insn->chanspec), data[0]);
+	       CR_CHAN(insn->chanspec), data[0]);
 #endif
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -3509,9 +3605,9 @@ static int ni_m_series_dio_insn_config(s
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -3523,12 +3619,14 @@ static int ni_m_series_dio_insn_config(s
 	return 1;
 }
 
-static int ni_m_series_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_m_series_dio_insn_bits(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 #ifdef DEBUG_DIO
 	printk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],
-		data[1]);
+	       data[1]);
 #endif
 	if (insn->n != 2)
 		return -EINVAL;
@@ -3542,8 +3640,8 @@ static int ni_m_series_dio_insn_bits(str
 	return 2;
 }
 
-static int ni_cdio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int ni_cdio_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -3606,7 +3704,7 @@ static int ni_cdio_cmdtest(struct comedi
 	if (cmd->scan_begin_src == TRIG_EXT) {
 		tmp = cmd->scan_begin_arg;
 		tmp &= CR_PACK_FLAGS(CDO_Sample_Source_Select_Mask, 0, 0,
-			CR_INVERT);
+				     CR_INVERT);
 		if (tmp != cmd->scan_begin_arg) {
 			err++;
 		}
@@ -3661,8 +3759,8 @@ static int ni_cdio_cmd(struct comedi_dev
 	switch (cmd->scan_begin_src) {
 	case TRIG_EXT:
 		cdo_mode_bits |=
-			CR_CHAN(cmd->
-			scan_begin_arg) & CDO_Sample_Source_Select_Mask;
+		    CR_CHAN(cmd->scan_begin_arg) &
+		    CDO_Sample_Source_Select_Mask;
 		break;
 	default:
 		BUG();
@@ -3677,7 +3775,7 @@ static int ni_cdio_cmd(struct comedi_dev
 		ni_writel(s->io_bits, M_Offset_CDO_Mask_Enable);
 	} else {
 		comedi_error(dev,
-			"attempted to run digital output command with no lines configured as outputs");
+			     "attempted to run digital output command with no lines configured as outputs");
 		return -EIO;
 	}
 	retval = ni_request_cdo_mite_channel(dev);
@@ -3689,7 +3787,7 @@ static int ni_cdio_cmd(struct comedi_dev
 }
 
 static int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			  unsigned int trignum)
 {
 #ifdef PCIDMA
 	unsigned long flags;
@@ -3732,16 +3830,17 @@ static int ni_cdo_inttrig(struct comedi_
 		return -EIO;
 	}
 	ni_writel(CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |
-		CDO_Empty_FIFO_Interrupt_Enable_Set_Bit, M_Offset_CDIO_Command);
+		  CDO_Empty_FIFO_Interrupt_Enable_Set_Bit,
+		  M_Offset_CDIO_Command);
 	return retval;
 }
 
 static int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	ni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |
-		CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
-		CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
-		M_Offset_CDIO_Command);
+		  CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
+		  CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
+		  M_Offset_CDIO_Command);
 /*
 * XXX not sure what interrupt C group does ni_writeb(0,
 * M_Offset_Interrupt_C_Enable);
@@ -3766,11 +3865,11 @@ static void handle_cdio_interrupt(struct
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	if (devpriv->cdo_mite_chan) {
 		unsigned cdo_mite_status =
-			mite_get_status(devpriv->cdo_mite_chan);
+		    mite_get_status(devpriv->cdo_mite_chan);
 		if (cdo_mite_status & CHSR_LINKC) {
 			writel(CHOR_CLRLC,
-				devpriv->mite->mite_io_addr +
-				MITE_CHOR(devpriv->cdo_mite_chan->channel));
+			       devpriv->mite->mite_io_addr +
+			       MITE_CHOR(devpriv->cdo_mite_chan->channel));
 		}
 		mite_sync_output_dma(devpriv->cdo_mite_chan, s->async);
 	}
@@ -3786,14 +3885,15 @@ static void handle_cdio_interrupt(struct
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
 /* printk("cdio fifo empty\n"); */
 		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
-			M_Offset_CDIO_Command);
+			  M_Offset_CDIO_Command);
 /* s->async->events |= COMEDI_CB_EOA; */
 	}
 	ni_event(dev, s);
 }
 
-static int ni_serial_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_serial_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int err = insn->n;
 	unsigned char byte_out, byte_in = 0;
@@ -3813,7 +3913,7 @@ static int ni_serial_insn_config(struct 
 		if (data[1] == SERIAL_DISABLED) {
 			devpriv->serial_hw_mode = 0;
 			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
-				DIO_Software_Serial_Control);
+						  DIO_Software_Serial_Control);
 			data[1] = SERIAL_DISABLED;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_600NS) {
@@ -3827,13 +3927,13 @@ static int ni_serial_insn_config(struct 
 		} else if (data[1] <= SERIAL_1_2US) {
 			devpriv->dio_control &= ~DIO_HW_Serial_Timebase;
 			devpriv->clock_and_fout |= Slow_Internal_Timebase |
-				DIO_Serial_Out_Divide_By_2;
+			    DIO_Serial_Out_Divide_By_2;
 			data[1] = SERIAL_1_2US;
 			devpriv->serial_interval_ns = data[1];
 		} else if (data[1] <= SERIAL_10US) {
 			devpriv->dio_control |= DIO_HW_Serial_Timebase;
 			devpriv->clock_and_fout |= Slow_Internal_Timebase |
-				DIO_Serial_Out_Divide_By_2;
+			    DIO_Serial_Out_Divide_By_2;
 			/* Note: DIO_Serial_Out_Divide_By_2 only affects
 			   600ns/1.2us. If you turn divide_by_2 off with the
 			   slow clock, you will still get 10us, except then
@@ -3842,16 +3942,16 @@ static int ni_serial_insn_config(struct 
 			devpriv->serial_interval_ns = data[1];
 		} else {
 			devpriv->dio_control &= ~(DIO_HW_Serial_Enable |
-				DIO_Software_Serial_Control);
+						  DIO_Software_Serial_Control);
 			devpriv->serial_hw_mode = 0;
 			data[1] = (data[1] / 1000) * 1000;
 			devpriv->serial_interval_ns = data[1];
 		}
 
 		devpriv->stc_writew(dev, devpriv->dio_control,
-			DIO_Control_Register);
+				    DIO_Control_Register);
 		devpriv->stc_writew(dev, devpriv->clock_and_fout,
-			Clock_and_FOUT_Register);
+				    Clock_and_FOUT_Register);
 		return 1;
 
 		break;
@@ -3866,10 +3966,10 @@ static int ni_serial_insn_config(struct 
 
 		if (devpriv->serial_hw_mode) {
 			err = ni_serial_hw_readwrite8(dev, s, byte_out,
-				&byte_in);
+						      &byte_in);
 		} else if (devpriv->serial_interval_ns > 0) {
 			err = ni_serial_sw_readwrite8(dev, s, byte_out,
-				&byte_in);
+						      &byte_in);
 		} else {
 			printk("ni_serial_insn_config: serial disabled!\n");
 			return -EINVAL;
@@ -3886,8 +3986,10 @@ static int ni_serial_insn_config(struct 
 
 }
 
-static int ni_serial_hw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned char data_out, unsigned char *data_in)
+static int ni_serial_hw_readwrite8(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned char data_out,
+				   unsigned char *data_in)
 {
 	unsigned int status1;
 	int err = 0, count = 20;
@@ -3912,14 +4014,14 @@ static int ni_serial_hw_readwrite8(struc
 
 	/* Wait until STC says we're done, but don't loop infinitely. */
 	while ((status1 =
-			devpriv->stc_readw(dev,
-				Joint_Status_1_Register)) &
-		DIO_Serial_IO_In_Progress_St) {
+		devpriv->stc_readw(dev,
+				   Joint_Status_1_Register)) &
+	       DIO_Serial_IO_In_Progress_St) {
 		/* Delay one bit per loop */
 		udelay((devpriv->serial_interval_ns + 999) / 1000);
 		if (--count < 0) {
 			printk
-				("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");
+			    ("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");
 			err = -ETIME;
 			goto Error;
 		}
@@ -3936,14 +4038,16 @@ static int ni_serial_hw_readwrite8(struc
 #endif
 	}
 
-      Error:
+Error:
 	devpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);
 
 	return err;
 }
 
-static int ni_serial_sw_readwrite8(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned char data_out, unsigned char *data_in)
+static int ni_serial_sw_readwrite8(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned char data_out,
+				   unsigned char *data_in)
 {
 	unsigned char mask, input = 0;
 
@@ -3963,25 +4067,26 @@ static int ni_serial_sw_readwrite8(struc
 			devpriv->dio_output |= DIO_SDOUT;
 		}
 		devpriv->stc_writew(dev, devpriv->dio_output,
-			DIO_Output_Register);
+				    DIO_Output_Register);
 
 		/* Assert SDCLK (active low, inverted), wait for half of
 		   the delay, deassert SDCLK, and wait for the other half. */
 		devpriv->dio_control |= DIO_Software_Serial_Control;
 		devpriv->stc_writew(dev, devpriv->dio_control,
-			DIO_Control_Register);
+				    DIO_Control_Register);
 
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		devpriv->dio_control &= ~DIO_Software_Serial_Control;
 		devpriv->stc_writew(dev, devpriv->dio_control,
-			DIO_Control_Register);
+				    DIO_Control_Register);
 
 		udelay((devpriv->serial_interval_ns + 999) / 2000);
 
 		/* Input current bit */
 		if (devpriv->stc_readw(dev,
-				DIO_Parallel_Input_Register) & DIO_SDIN) {
+				       DIO_Parallel_Input_Register) & DIO_SDIN)
+		{
 /*			printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
 			input |= mask;
 		}
@@ -4010,10 +4115,9 @@ static void init_ao_67xx(struct comedi_d
 {
 	int i;
 
-	for (i = 0; i < s->n_chan; i++)
-	{
+	for (i = 0; i < s->n_chan; i++) {
 		ni_ao_win_outw(dev, AO_Channel(i) | 0x0,
-			AO_Configuration_2_67xx);
+			       AO_Configuration_2_67xx);
 	}
 	ao_win_out(0x0, AO_Later_Single_Point_Updates);
 }
@@ -4102,7 +4206,7 @@ static unsigned ni_gpct_to_stc_register(
 		break;
 	default:
 		printk("%s: unhandled register 0x%x in switch.\n",
-			__func__, reg);
+		       __func__, reg);
 		BUG();
 		return 0;
 		break;
@@ -4111,16 +4215,16 @@ static unsigned ni_gpct_to_stc_register(
 }
 
 static void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,
-	enum ni_gpct_register reg)
+				   enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned stc_register;
 	/* bits in the join reset register which are relevant to counters */
 	static const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;
 	static const unsigned gpct_interrupt_a_enable_mask =
-		G0_Gate_Interrupt_Enable | G0_TC_Interrupt_Enable;
+	    G0_Gate_Interrupt_Enable | G0_TC_Interrupt_Enable;
 	static const unsigned gpct_interrupt_b_enable_mask =
-		G1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;
+	    G1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;
 
 	switch (reg) {
 		/* m-series-only registers */
@@ -4162,12 +4266,12 @@ static void ni_gpct_write_register(struc
 	case NITIO_G0_Interrupt_Enable_Reg:
 		BUG_ON(bits & ~gpct_interrupt_a_enable_mask);
 		ni_set_bitfield(dev, Interrupt_A_Enable_Register,
-			gpct_interrupt_a_enable_mask, bits);
+				gpct_interrupt_a_enable_mask, bits);
 		break;
 	case NITIO_G1_Interrupt_Enable_Reg:
 		BUG_ON(bits & ~gpct_interrupt_b_enable_mask);
 		ni_set_bitfield(dev, Interrupt_B_Enable_Register,
-			gpct_interrupt_b_enable_mask, bits);
+				gpct_interrupt_b_enable_mask, bits);
 		break;
 	case NITIO_G01_Joint_Reset_Reg:
 		BUG_ON(bits & ~gpct_joint_reset_mask);
@@ -4179,7 +4283,7 @@ static void ni_gpct_write_register(struc
 }
 
 static unsigned ni_gpct_read_register(struct ni_gpct *counter,
-	enum ni_gpct_register reg)
+				      enum ni_gpct_register reg)
 {
 	struct comedi_device *dev = counter->counter_dev->dev;
 	unsigned stc_register;
@@ -4211,27 +4315,30 @@ static unsigned ni_gpct_read_register(st
 }
 
 static int ni_freq_out_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->clock_and_fout & FOUT_Divider_mask;
 	return 1;
 }
 
 static int ni_freq_out_insn_write(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	devpriv->clock_and_fout &= ~FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-		Clock_and_FOUT_Register);
+			    Clock_and_FOUT_Register);
 	devpriv->clock_and_fout &= ~FOUT_Divider_mask;
 	devpriv->clock_and_fout |= FOUT_Divider(data[0]);
 	devpriv->clock_and_fout |= FOUT_Enable;
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-		Clock_and_FOUT_Register);
+			    Clock_and_FOUT_Register);
 	return insn->n;
 }
 
-static int ni_set_freq_out_clock(struct comedi_device *dev, unsigned int clock_source)
+static int ni_set_freq_out_clock(struct comedi_device *dev,
+				 unsigned int clock_source)
 {
 	switch (clock_source) {
 	case NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:
@@ -4244,12 +4351,13 @@ static int ni_set_freq_out_clock(struct 
 		return -EINVAL;
 	}
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-		Clock_and_FOUT_Register);
+			    Clock_and_FOUT_Register);
 	return 3;
 }
 
-static void ni_get_freq_out_clock(struct comedi_device *dev, unsigned int *clock_source,
-	unsigned int *clock_period_ns)
+static void ni_get_freq_out_clock(struct comedi_device *dev,
+				  unsigned int *clock_source,
+				  unsigned int *clock_period_ns)
 {
 	if (devpriv->clock_and_fout & FOUT_Timebase_Select) {
 		*clock_source = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;
@@ -4260,8 +4368,9 @@ static void ni_get_freq_out_clock(struct
 	}
 }
 
-static int ni_freq_out_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_freq_out_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_CLOCK_SRC:
@@ -4312,7 +4421,7 @@ static int ni_E_init(struct comedi_devic
 	if (boardtype.n_adchan) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags =
-			SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
+		    SDF_READABLE | SDF_DIFF | SDF_DITHER | SDF_CMD_READ;
 		if (boardtype.reg_type != ni_reg_611x)
 			s->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;
 		if (boardtype.adbits > 16)
@@ -4387,7 +4496,7 @@ static int ni_E_init(struct comedi_devic
 	s->n_chan = boardtype.num_p0_dio_channels;
 	if (boardtype.reg_type & ni_reg_m_series_mask) {
 		s->subdev_flags |=
-			SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */ ;
+		    SDF_LSAMPL | SDF_CMD_WRITE /* | SDF_CMD_READ */ ;
 		s->insn_bits = &ni_m_series_dio_insn_bits;
 		s->insn_config = &ni_m_series_dio_insn_config;
 		s->do_cmd = &ni_cdio_cmd;
@@ -4463,7 +4572,7 @@ static int ni_E_init(struct comedi_devic
 		ni_writew(s->state, M_Offset_PFI_DO);
 		for (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {
 			ni_writew(devpriv->pfi_output_select_reg[i],
-				M_Offset_PFI_Output_Select(i + 1));
+				  M_Offset_PFI_Output_Select(i + 1));
 		}
 	} else {
 		s->n_chan = 10;
@@ -4517,15 +4626,17 @@ static int ni_E_init(struct comedi_devic
 		counter_variant = ni_gpct_variant_e_series;
 	}
 	devpriv->counter_dev = ni_gpct_device_construct(dev,
-		&ni_gpct_write_register, &ni_gpct_read_register,
-		counter_variant, NUM_GPCT);
+							&ni_gpct_write_register,
+							&ni_gpct_read_register,
+							counter_variant,
+							NUM_GPCT);
 	/* General purpose counters */
 	for (j = 0; j < NUM_GPCT; ++j) {
 		s = dev->subdevices + NI_GPCT_SUBDEV(j);
 		s->type = COMEDI_SUBD_COUNTER;
 		s->subdev_flags =
-			SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_CMD_READ
-			/* | SDF_CMD_WRITE */ ;
+		    SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_CMD_READ
+		    /* | SDF_CMD_WRITE */ ;
 		s->n_chan = 3;
 		if (boardtype.reg_type & ni_reg_m_series_mask)
 			s->maxdata = 0xffffffff;
@@ -4561,32 +4672,33 @@ static int ni_E_init(struct comedi_devic
 	if ((boardtype.reg_type & ni_reg_6xxx_mask) == 0) {
 		/*  BEAM is this needed for PCI-6143 ?? */
 		devpriv->clock_and_fout =
-			Slow_Internal_Time_Divide_By_2 |
-			Slow_Internal_Timebase |
-			Clock_To_Board_Divide_By_2 |
-			Clock_To_Board |
-			AI_Output_Divide_By_2 | AO_Output_Divide_By_2;
+		    Slow_Internal_Time_Divide_By_2 |
+		    Slow_Internal_Timebase |
+		    Clock_To_Board_Divide_By_2 |
+		    Clock_To_Board |
+		    AI_Output_Divide_By_2 | AO_Output_Divide_By_2;
 	} else {
 		devpriv->clock_and_fout =
-			Slow_Internal_Time_Divide_By_2 |
-			Slow_Internal_Timebase |
-			Clock_To_Board_Divide_By_2 | Clock_To_Board;
+		    Slow_Internal_Time_Divide_By_2 |
+		    Slow_Internal_Timebase |
+		    Clock_To_Board_Divide_By_2 | Clock_To_Board;
 	}
 	devpriv->stc_writew(dev, devpriv->clock_and_fout,
-		Clock_and_FOUT_Register);
+			    Clock_and_FOUT_Register);
 
 	/* analog output configuration */
 	ni_ao_reset(dev, dev->subdevices + NI_AO_SUBDEV);
 
 	if (dev->irq) {
 		devpriv->stc_writew(dev,
-			(IRQ_POLARITY ? Interrupt_Output_Polarity : 0) |
-			(Interrupt_Output_On_3_Pins & 0) | Interrupt_A_Enable |
-			Interrupt_B_Enable |
-			Interrupt_A_Output_Select(interrupt_pin(dev->
-					irq)) |
-			Interrupt_B_Output_Select(interrupt_pin(dev->irq)),
-			Interrupt_Control_Register);
+				    (IRQ_POLARITY ? Interrupt_Output_Polarity :
+				     0) | (Interrupt_Output_On_3_Pins & 0) |
+				    Interrupt_A_Enable | Interrupt_B_Enable |
+				    Interrupt_A_Output_Select(interrupt_pin
+							      (dev->irq)) |
+				    Interrupt_B_Output_Select(interrupt_pin
+							      (dev->irq)),
+				    Interrupt_Control_Register);
 	}
 
 	/* DMA setup */
@@ -4600,7 +4712,7 @@ static int ni_E_init(struct comedi_devic
 		for (channel = 0; channel < boardtype.n_aochan; ++channel) {
 			ni_writeb(0xf, M_Offset_AO_Waveform_Order(channel));
 			ni_writeb(0x0,
-				M_Offset_AO_Reference_Attenuation(channel));
+				  M_Offset_AO_Reference_Attenuation(channel));
 		}
 		ni_writeb(0x0, M_Offset_AO_Calibration);
 	}
@@ -4611,7 +4723,7 @@ static int ni_E_init(struct comedi_devic
 
 static int ni_8255_callback(int dir, int port, int data, unsigned long arg)
 {
-	struct comedi_device *dev = (struct comedi_device *) arg;
+	struct comedi_device *dev = (struct comedi_device *)arg;
 
 	if (dir) {
 		ni_writeb(data, Port_A + 2 * port);
@@ -4625,8 +4737,9 @@ static int ni_8255_callback(int dir, int
 	presents the EEPROM as a subdevice
 */
 
-static int ni_eeprom_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_eeprom_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));
 
@@ -4646,9 +4759,9 @@ static int ni_read_eeprom(struct comedi_
 	ni_writeb(0x04, Serial_Command);
 	for (bit = 0x8000; bit; bit >>= 1) {
 		ni_writeb(0x04 | ((bit & bitstring) ? 0x02 : 0),
-			Serial_Command);
+			  Serial_Command);
 		ni_writeb(0x05 | ((bit & bitstring) ? 0x02 : 0),
-			Serial_Command);
+			  Serial_Command);
 	}
 	bitstring = 0;
 	for (bit = 0x80; bit; bit >>= 1) {
@@ -4662,7 +4775,9 @@ static int ni_read_eeprom(struct comedi_
 }
 
 static int ni_m_series_eeprom_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data)
 {
 	data[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];
 
@@ -4676,8 +4791,9 @@ static int ni_get_pwm_config(struct come
 	return 3;
 }
 
-static int ni_m_series_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_m_series_pwm_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4685,16 +4801,16 @@ static int ni_m_series_pwm_config(struct
 		switch (data[1]) {
 		case TRIG_ROUND_NEAREST:
 			up_count =
-				(data[2] +
-				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			    (data[2] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_DOWN:
 			up_count = data[2] / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_UP:
 			up_count =
-				(data[2] + devpriv->clock_ns -
-				1) / devpriv->clock_ns;
+			    (data[2] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
 			break;
 		default:
 			return -EINVAL;
@@ -4703,30 +4819,30 @@ static int ni_m_series_pwm_config(struct
 		switch (data[3]) {
 		case TRIG_ROUND_NEAREST:
 			down_count =
-				(data[4] +
-				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			    (data[4] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_DOWN:
 			down_count = data[4] / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_UP:
 			down_count =
-				(data[4] + devpriv->clock_ns -
-				1) / devpriv->clock_ns;
+			    (data[4] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
 			break;
 		default:
 			return -EINVAL;
 			break;
 		}
 		if (up_count * devpriv->clock_ns != data[2] ||
-			down_count * devpriv->clock_ns != data[4]) {
+		    down_count * devpriv->clock_ns != data[4]) {
 			data[2] = up_count * devpriv->clock_ns;
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
 		}
 		ni_writel(MSeries_Cal_PWM_High_Time_Bits(up_count) |
-			MSeries_Cal_PWM_Low_Time_Bits(down_count),
-			M_Offset_Cal_PWM);
+			  MSeries_Cal_PWM_Low_Time_Bits(down_count),
+			  M_Offset_Cal_PWM);
 		devpriv->pwm_up_count = up_count;
 		devpriv->pwm_down_count = down_count;
 		return 5;
@@ -4741,8 +4857,9 @@ static int ni_m_series_pwm_config(struct
 	return 0;
 }
 
-static int ni_6143_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_6143_pwm_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned up_count, down_count;
 	switch (data[0]) {
@@ -4750,16 +4867,16 @@ static int ni_6143_pwm_config(struct com
 		switch (data[1]) {
 		case TRIG_ROUND_NEAREST:
 			up_count =
-				(data[2] +
-				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			    (data[2] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_DOWN:
 			up_count = data[2] / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_UP:
 			up_count =
-				(data[2] + devpriv->clock_ns -
-				1) / devpriv->clock_ns;
+			    (data[2] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
 			break;
 		default:
 			return -EINVAL;
@@ -4768,23 +4885,23 @@ static int ni_6143_pwm_config(struct com
 		switch (data[3]) {
 		case TRIG_ROUND_NEAREST:
 			down_count =
-				(data[4] +
-				devpriv->clock_ns / 2) / devpriv->clock_ns;
+			    (data[4] +
+			     devpriv->clock_ns / 2) / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_DOWN:
 			down_count = data[4] / devpriv->clock_ns;
 			break;
 		case TRIG_ROUND_UP:
 			down_count =
-				(data[4] + devpriv->clock_ns -
-				1) / devpriv->clock_ns;
+			    (data[4] + devpriv->clock_ns -
+			     1) / devpriv->clock_ns;
 			break;
 		default:
 			return -EINVAL;
 			break;
 		}
 		if (up_count * devpriv->clock_ns != data[2] ||
-			down_count * devpriv->clock_ns != data[4]) {
+		    down_count * devpriv->clock_ns != data[4]) {
 			data[2] = up_count * devpriv->clock_ns;
 			data[4] = down_count * devpriv->clock_ns;
 			return -EAGAIN;
@@ -4808,16 +4925,18 @@ static void ni_write_caldac(struct comed
 /*
 	calibration subdevice
 */
-static int ni_calib_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_calib_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	ni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);
 
 	return 1;
 }
 
-static int ni_calib_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_calib_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];
 
@@ -4884,7 +5003,7 @@ static void caldac_setup(struct comedi_d
 			type = boardtype.caldac[i];
 			for (j = 0; j < caldacs[type].n_chans; j++) {
 				maxdata_list[chan] =
-					(1 << caldacs[type].n_bits) - 1;
+				    (1 << caldacs[type].n_bits) - 1;
 				chan++;
 			}
 		}
@@ -4948,8 +5067,8 @@ static int pack_mb88341(int addr, int va
 	 */
 	addr++;
 	*bitstring = ((addr & 0x1) << 11) |
-		((addr & 0x2) << 9) |
-		((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
+	    ((addr & 0x2) << 9) |
+	    ((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);
 	return 12;
 }
 
@@ -4993,11 +5112,11 @@ static int GPCT_G_Watch(struct comedi_de
 
 	devpriv->gpct_command[chan] &= ~G_Save_Trace;
 	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
-		G_Command_Register(chan));
+			    G_Command_Register(chan));
 
 	devpriv->gpct_command[chan] |= G_Save_Trace;
 	devpriv->stc_writew(dev, devpriv->gpct_command[chan],
-		G_Command_Register(chan));
+			    G_Command_Register(chan));
 
 	/* This procedure is used because the two registers cannot
 	 * be read atomically. */
@@ -5021,37 +5140,37 @@ static void GPCT_Reset(struct comedi_dev
 	case 0:
 		devpriv->stc_writew(dev, G0_Reset, Joint_Reset_Register);
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			G0_TC_Interrupt_Enable, 0);
+			    G0_TC_Interrupt_Enable, 0);
 		ni_set_bits(dev, Interrupt_A_Enable_Register,
-			G0_Gate_Interrupt_Enable, 0);
+			    G0_Gate_Interrupt_Enable, 0);
 		temp_ack_reg |= G0_Gate_Error_Confirm;
 		temp_ack_reg |= G0_TC_Error_Confirm;
 		temp_ack_reg |= G0_TC_Interrupt_Ack;
 		temp_ack_reg |= G0_Gate_Interrupt_Ack;
 		devpriv->stc_writew(dev, temp_ack_reg,
-			Interrupt_A_Ack_Register);
+				    Interrupt_A_Ack_Register);
 
 		/* problem...this interferes with the other ctr... */
 		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
 		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-			Analog_Trigger_Etc_Register);
+				    Analog_Trigger_Etc_Register);
 		break;
 	case 1:
 		devpriv->stc_writew(dev, G1_Reset, Joint_Reset_Register);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			G1_TC_Interrupt_Enable, 0);
+			    G1_TC_Interrupt_Enable, 0);
 		ni_set_bits(dev, Interrupt_B_Enable_Register,
-			G0_Gate_Interrupt_Enable, 0);
+			    G0_Gate_Interrupt_Enable, 0);
 		temp_ack_reg |= G1_Gate_Error_Confirm;
 		temp_ack_reg |= G1_TC_Error_Confirm;
 		temp_ack_reg |= G1_TC_Interrupt_Ack;
 		temp_ack_reg |= G1_Gate_Interrupt_Ack;
 		devpriv->stc_writew(dev, temp_ack_reg,
-			Interrupt_B_Ack_Register);
+				    Interrupt_B_Ack_Register);
 
 		devpriv->an_trig_etc_reg |= GPFO_1_Output_Enable;
 		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
-			Analog_Trigger_Etc_Register);
+				    Analog_Trigger_Etc_Register);
 		break;
 	};
 
@@ -5062,9 +5181,9 @@ static void GPCT_Reset(struct comedi_dev
 	devpriv->gpct_command[chan] |= G_Synchronized_Gate;
 
 	devpriv->stc_writew(dev, devpriv->gpct_mode[chan],
-		G_Mode_Register(chan));
+			    G_Mode_Register(chan));
 	devpriv->stc_writew(dev, devpriv->gpct_input_select[chan],
-		G_Input_Select_Register(chan));
+			    G_Input_Select_Register(chan));
 	devpriv->stc_writew(dev, 0, G_Autoincrement_Register(chan));
 
 	/* printk("exit GPCT_Reset\n"); */
@@ -5072,22 +5191,25 @@ static void GPCT_Reset(struct comedi_dev
 
 #endif
 
-static int ni_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_gpct_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_insn_config(counter, insn, data);
 }
 
-static int ni_gpct_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_gpct_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_rinsn(counter, insn, data);
 }
 
-static int ni_gpct_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_gpct_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
 	return ni_tio_winsn(counter, insn, data);
@@ -5101,10 +5223,10 @@ static int ni_gpct_cmd(struct comedi_dev
 /* const struct comedi_cmd *cmd = &s->async->cmd; */
 
 	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
-		COMEDI_INPUT);
+					      COMEDI_INPUT);
 	if (retval) {
 		comedi_error(dev,
-			"no dma channel available for use by counter");
+			     "no dma channel available for use by counter");
 		return retval;
 	}
 	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
@@ -5116,8 +5238,8 @@ static int ni_gpct_cmd(struct comedi_dev
 	return retval;
 }
 
-static int ni_gpct_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int ni_gpct_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
@@ -5150,7 +5272,7 @@ static int ni_gpct_cancel(struct comedi_
  */
 
 static int ni_m_series_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+				       unsigned source)
 {
 	unsigned pfi_reg_index;
 	unsigned array_offset;
@@ -5159,16 +5281,16 @@ static int ni_m_series_set_pfi_routing(s
 	pfi_reg_index = 1 + chan / 3;
 	array_offset = pfi_reg_index - 1;
 	devpriv->pfi_output_select_reg[array_offset] &=
-		~MSeries_PFI_Output_Select_Mask(chan);
+	    ~MSeries_PFI_Output_Select_Mask(chan);
 	devpriv->pfi_output_select_reg[array_offset] |=
-		MSeries_PFI_Output_Select_Bits(chan, source);
+	    MSeries_PFI_Output_Select_Bits(chan, source);
 	ni_writew(devpriv->pfi_output_select_reg[array_offset],
-		M_Offset_PFI_Output_Select(pfi_reg_index));
+		  M_Offset_PFI_Output_Select(pfi_reg_index));
 	return 2;
 }
 
 static int ni_old_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+				  unsigned source)
 {
 	/*  pre-m-series boards have fixed signals on pfi pins */
 	if (source != ni_old_get_pfi_routing(dev, chan))
@@ -5177,7 +5299,7 @@ static int ni_old_set_pfi_routing(struct
 }
 
 static int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+			      unsigned source)
 {
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		return ni_m_series_set_pfi_routing(dev, chan, source);
@@ -5185,11 +5307,14 @@ static int ni_set_pfi_routing(struct com
 		return ni_old_set_pfi_routing(dev, chan, source);
 }
 
-static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev, unsigned chan)
+static unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev,
+					    unsigned chan)
 {
 	const unsigned array_offset = chan / 3;
 	return MSeries_PFI_Output_Select_Source(chan,
-		devpriv->pfi_output_select_reg[array_offset]);
+						devpriv->
+						pfi_output_select_reg
+						[array_offset]);
 }
 
 static unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan)
@@ -5242,7 +5367,7 @@ static unsigned ni_get_pfi_routing(struc
 }
 
 static int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,
-	enum ni_pfi_filter_select filter)
+			    enum ni_pfi_filter_select filter)
 {
 	unsigned bits;
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
@@ -5255,8 +5380,9 @@ static int ni_config_filter(struct comed
 	return 0;
 }
 
-static int ni_pfi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_pfi_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	if ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {
 		return -ENOTSUPP;
@@ -5270,8 +5396,9 @@ static int ni_pfi_insn_bits(struct comed
 	return 2;
 }
 
-static int ni_pfi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_pfi_insn_config(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan;
 
@@ -5289,9 +5416,8 @@ static int ni_pfi_insn_config(struct com
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(devpriv->
-			io_bidirection_pin_reg & (1 << chan)) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (devpriv->io_bidirection_pin_reg & (1 << chan)) ?
+		    COMEDI_OUTPUT : COMEDI_INPUT;
 		return 0;
 		break;
 	case INSN_CONFIG_SET_ROUTING:
@@ -5325,23 +5451,26 @@ static void ni_rtsi_init(struct comedi_d
 	}
 	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
-		RTSI_Trig_Output_Bits(0,
-		NI_RTSI_OUTPUT_ADR_START1) | RTSI_Trig_Output_Bits(1,
-		NI_RTSI_OUTPUT_ADR_START2) | RTSI_Trig_Output_Bits(2,
-		NI_RTSI_OUTPUT_SCLKG) | RTSI_Trig_Output_Bits(3,
-		NI_RTSI_OUTPUT_DACUPDN);
+	    RTSI_Trig_Output_Bits(0,
+				  NI_RTSI_OUTPUT_ADR_START1) |
+	    RTSI_Trig_Output_Bits(1,
+				  NI_RTSI_OUTPUT_ADR_START2) |
+	    RTSI_Trig_Output_Bits(2,
+				  NI_RTSI_OUTPUT_SCLKG) |
+	    RTSI_Trig_Output_Bits(3, NI_RTSI_OUTPUT_DACUPDN);
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-		RTSI_Trig_A_Output_Register);
+			    RTSI_Trig_A_Output_Register);
 	devpriv->rtsi_trig_b_output_reg =
-		RTSI_Trig_Output_Bits(4,
-		NI_RTSI_OUTPUT_DA_START1) | RTSI_Trig_Output_Bits(5,
-		NI_RTSI_OUTPUT_G_SRC0) | RTSI_Trig_Output_Bits(6,
-		NI_RTSI_OUTPUT_G_GATE0);
+	    RTSI_Trig_Output_Bits(4,
+				  NI_RTSI_OUTPUT_DA_START1) |
+	    RTSI_Trig_Output_Bits(5,
+				  NI_RTSI_OUTPUT_G_SRC0) |
+	    RTSI_Trig_Output_Bits(6, NI_RTSI_OUTPUT_G_GATE0);
 	if (boardtype.reg_type & ni_reg_m_series_mask)
 		devpriv->rtsi_trig_b_output_reg |=
-			RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
+		    RTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-		RTSI_Trig_B_Output_Register);
+			    RTSI_Trig_B_Output_Register);
 
 /*
 * Sets the source and direction of the 4 on board lines
@@ -5349,8 +5478,9 @@ static void ni_rtsi_init(struct comedi_d
 */
 }
 
-static int ni_rtsi_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_rtsi_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -5363,8 +5493,9 @@ static int ni_rtsi_insn_bits(struct come
 /* Find best multiplier/divider to try and get the PLL running at 80 MHz
  * given an arbitrary frequency input clock */
 static int ni_mseries_get_pll_parameters(unsigned reference_period_ns,
-	unsigned *freq_divider, unsigned *freq_multiplier,
-	unsigned *actual_period_ns)
+					 unsigned *freq_divider,
+					 unsigned *freq_multiplier,
+					 unsigned *actual_period_ns)
 {
 	unsigned div;
 	unsigned best_div = 1;
@@ -5383,9 +5514,9 @@ static int ni_mseries_get_pll_parameters
 	for (div = 1; div <= max_div; ++div) {
 		for (mult = 1; mult <= max_mult; ++mult) {
 			unsigned new_period_ps =
-				(reference_picosec * div) / mult;
+			    (reference_picosec * div) / mult;
 			if (abs(new_period_ps - target_picosec) <
-				abs(best_period_picosec - target_picosec)) {
+			    abs(best_period_picosec - target_picosec)) {
 				best_period_picosec = new_period_ps;
 				best_div = div;
 				best_mult = mult;
@@ -5393,15 +5524,14 @@ static int ni_mseries_get_pll_parameters
 		}
 	}
 	if (best_period_picosec == 0) {
-		printk("%s: bug, failed to find pll parameters\n",
-			__func__);
+		printk("%s: bug, failed to find pll parameters\n", __func__);
 		return -EIO;
 	}
 	*freq_divider = best_div;
 	*freq_multiplier = best_mult;
 	*actual_period_ns =
-		(best_period_picosec * fudge_factor_80_to_20Mhz +
-		(pico_per_nano / 2)) / pico_per_nano;
+	    (best_period_picosec * fudge_factor_80_to_20Mhz +
+	     (pico_per_nano / 2)) / pico_per_nano;
 	return 0;
 }
 
@@ -5413,8 +5543,8 @@ static inline unsigned num_configurable_
 		return 7;
 }
 
-static int ni_mseries_set_pll_master_clock(struct comedi_device *dev, unsigned source,
-	unsigned period_ns)
+static int ni_mseries_set_pll_master_clock(struct comedi_device *dev,
+					   unsigned source, unsigned period_ns)
 {
 	static const unsigned min_period_ns = 50;
 	static const unsigned max_period_ns = 1000;
@@ -5429,34 +5559,36 @@ static int ni_mseries_set_pll_master_clo
 	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
 		printk
-			("%s: you must specify an input clock frequency between %i and %i nanosec "
-			"for the phased-lock loop.\n", __func__,
-			min_period_ns, max_period_ns);
+		    ("%s: you must specify an input clock frequency between %i and %i nanosec "
+		     "for the phased-lock loop.\n", __func__,
+		     min_period_ns, max_period_ns);
 		return -EINVAL;
 	}
 	devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-		RTSI_Trig_Direction_Register);
+			    RTSI_Trig_Direction_Register);
 	pll_control_bits =
-		MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
+	    MSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;
 	devpriv->clock_and_fout2 |=
-		MSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;
+	    MSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;
 	devpriv->clock_and_fout2 &= ~MSeries_PLL_In_Source_Select_Mask;
 	switch (source) {
 	case NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:
 		devpriv->clock_and_fout2 |=
-			MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
+		    MSeries_PLL_In_Source_Select_Star_Trigger_Bits;
 		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
-			&freq_multiplier, &devpriv->clock_ns);
+						       &freq_multiplier,
+						       &devpriv->clock_ns);
 		if (retval < 0)
 			return retval;
 		break;
 	case NI_MIO_PLL_PXI10_CLOCK:
 		/* pxi clock is 10MHz */
 		devpriv->clock_and_fout2 |=
-			MSeries_PLL_In_Source_Select_PXI_Clock10;
+		    MSeries_PLL_In_Source_Select_PXI_Clock10;
 		retval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,
-			&freq_multiplier, &devpriv->clock_ns);
+						       &freq_multiplier,
+						       &devpriv->clock_ns);
 		if (retval < 0)
 			return retval;
 		break;
@@ -5465,20 +5597,22 @@ static int ni_mseries_set_pll_master_clo
 			unsigned rtsi_channel;
 			static const unsigned max_rtsi_channel = 7;
 			for (rtsi_channel = 0; rtsi_channel <= max_rtsi_channel;
-				++rtsi_channel) {
+			     ++rtsi_channel) {
 				if (source ==
-					NI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {
+				    NI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {
 					devpriv->clock_and_fout2 |=
-						MSeries_PLL_In_Source_Select_RTSI_Bits
-						(rtsi_channel);
+					    MSeries_PLL_In_Source_Select_RTSI_Bits
+					    (rtsi_channel);
 					break;
 				}
 			}
 			if (rtsi_channel > max_rtsi_channel)
 				return -EINVAL;
 			retval = ni_mseries_get_pll_parameters(period_ns,
-				&freq_divider, &freq_multiplier,
-				&devpriv->clock_ns);
+							       &freq_divider,
+							       &freq_multiplier,
+							       &devpriv->
+							       clock_ns);
 			if (retval < 0)
 				return retval;
 		}
@@ -5486,8 +5620,8 @@ static int ni_mseries_set_pll_master_clo
 	}
 	ni_writew(devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);
 	pll_control_bits |=
-		MSeries_PLL_Divisor_Bits(freq_divider) |
-		MSeries_PLL_Multiplier_Bits(freq_multiplier);
+	    MSeries_PLL_Divisor_Bits(freq_divider) |
+	    MSeries_PLL_Multiplier_Bits(freq_multiplier);
 
 	/* printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
 	 * freq_divider, freq_multiplier, pll_control_bits); */
@@ -5503,45 +5637,46 @@ static int ni_mseries_set_pll_master_clo
 	}
 	if (i == timeout) {
 		printk
-			("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
-			__func__, source, period_ns);
+		    ("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",
+		     __func__, source, period_ns);
 		return -ETIMEDOUT;
 	}
 	return 3;
 }
 
 static int ni_set_master_clock(struct comedi_device *dev, unsigned source,
-	unsigned period_ns)
+			       unsigned period_ns)
 {
 	if (source == NI_MIO_INTERNAL_CLOCK) {
 		devpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			RTSI_Trig_Direction_Register);
+				    RTSI_Trig_Direction_Register);
 		devpriv->clock_ns = TIMEBASE_1_NS;
 		if (boardtype.reg_type & ni_reg_m_series_mask) {
 			devpriv->clock_and_fout2 &=
-				~(MSeries_Timebase1_Select_Bit |
-				MSeries_Timebase3_Select_Bit);
+			    ~(MSeries_Timebase1_Select_Bit |
+			      MSeries_Timebase3_Select_Bit);
 			ni_writew(devpriv->clock_and_fout2,
-				M_Offset_Clock_and_Fout2);
+				  M_Offset_Clock_and_Fout2);
 			ni_writew(0, M_Offset_PLL_Control);
 		}
 		devpriv->clock_source = source;
 	} else {
 		if (boardtype.reg_type & ni_reg_m_series_mask) {
 			return ni_mseries_set_pll_master_clock(dev, source,
-				period_ns);
+							       period_ns);
 		} else {
 			if (source == NI_MIO_RTSI_CLOCK) {
 				devpriv->rtsi_trig_direction_reg |=
-					Use_RTSI_Clock_Bit;
+				    Use_RTSI_Clock_Bit;
 				devpriv->stc_writew(dev,
-					devpriv->rtsi_trig_direction_reg,
-					RTSI_Trig_Direction_Register);
+						    devpriv->
+						    rtsi_trig_direction_reg,
+						    RTSI_Trig_Direction_Register);
 				if (period_ns == 0) {
 					printk
-						("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
-						__func__);
+					    ("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",
+					     __func__);
 					return -EINVAL;
 				} else {
 					devpriv->clock_ns = period_ns;
@@ -5555,7 +5690,7 @@ static int ni_set_master_clock(struct co
 }
 
 static int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+				       unsigned source)
 {
 	if (chan >= num_configurable_rtsi_channels(dev)) {
 		if (chan == old_RTSI_clock_channel) {
@@ -5563,9 +5698,8 @@ static int ni_valid_rtsi_output_source(s
 				return 1;
 			else {
 				printk
-					("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
-					__func__, chan,
-					old_RTSI_clock_channel);
+				    ("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",
+				     __func__, chan, old_RTSI_clock_channel);
 				return 0;
 			}
 		}
@@ -5596,22 +5730,22 @@ static int ni_valid_rtsi_output_source(s
 }
 
 static int ni_set_rtsi_routing(struct comedi_device *dev, unsigned chan,
-	unsigned source)
+			       unsigned source)
 {
 	if (ni_valid_rtsi_output_source(dev, chan, source) == 0)
 		return -EINVAL;
 	if (chan < 4) {
 		devpriv->rtsi_trig_a_output_reg &= ~RTSI_Trig_Output_Mask(chan);
 		devpriv->rtsi_trig_a_output_reg |=
-			RTSI_Trig_Output_Bits(chan, source);
+		    RTSI_Trig_Output_Bits(chan, source);
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,
-			RTSI_Trig_A_Output_Register);
+				    RTSI_Trig_A_Output_Register);
 	} else if (chan < 8) {
 		devpriv->rtsi_trig_b_output_reg &= ~RTSI_Trig_Output_Mask(chan);
 		devpriv->rtsi_trig_b_output_reg |=
-			RTSI_Trig_Output_Bits(chan, source);
+		    RTSI_Trig_Output_Bits(chan, source);
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
-			RTSI_Trig_B_Output_Register);
+				    RTSI_Trig_B_Output_Register);
 	}
 	return 2;
 }
@@ -5620,10 +5754,10 @@ static unsigned ni_get_rtsi_routing(stru
 {
 	if (chan < 4) {
 		return RTSI_Trig_Output_Source(chan,
-			devpriv->rtsi_trig_a_output_reg);
+					       devpriv->rtsi_trig_a_output_reg);
 	} else if (chan < num_configurable_rtsi_channels(dev)) {
 		return RTSI_Trig_Output_Source(chan,
-			devpriv->rtsi_trig_b_output_reg);
+					       devpriv->rtsi_trig_b_output_reg);
 	} else {
 		if (chan == old_RTSI_clock_channel)
 			return NI_RTSI_OUTPUT_RTSI_OSC;
@@ -5632,53 +5766,54 @@ static unsigned ni_get_rtsi_routing(stru
 	}
 }
 
-static int ni_rtsi_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int ni_rtsi_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			devpriv->rtsi_trig_direction_reg |=
-				RTSI_Output_Bit(chan,
-				(boardtype.reg_type & ni_reg_m_series_mask) !=
-				0);
+			    RTSI_Output_Bit(chan,
+					    (boardtype.
+					     reg_type & ni_reg_m_series_mask) !=
+					    0);
 		} else if (chan == old_RTSI_clock_channel) {
 			devpriv->rtsi_trig_direction_reg |=
-				Drive_RTSI_Clock_Bit;
+			    Drive_RTSI_Clock_Bit;
 		}
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			RTSI_Trig_Direction_Register);
+				    RTSI_Trig_Direction_Register);
 		break;
 	case INSN_CONFIG_DIO_INPUT:
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			devpriv->rtsi_trig_direction_reg &=
-				~RTSI_Output_Bit(chan,
-				(boardtype.reg_type & ni_reg_m_series_mask) !=
-				0);
+			    ~RTSI_Output_Bit(chan,
+					     (boardtype.
+					      reg_type & ni_reg_m_series_mask)
+					     != 0);
 		} else if (chan == old_RTSI_clock_channel) {
 			devpriv->rtsi_trig_direction_reg &=
-				~Drive_RTSI_Clock_Bit;
+			    ~Drive_RTSI_Clock_Bit;
 		}
 		devpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,
-			RTSI_Trig_Direction_Register);
+				    RTSI_Trig_Direction_Register);
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		if (chan < num_configurable_rtsi_channels(dev)) {
 			data[1] =
-				(devpriv->
-				rtsi_trig_direction_reg & RTSI_Output_Bit(chan,
-					(boardtype.
-						reg_type & ni_reg_m_series_mask)
-					!=
-					0)) ? INSN_CONFIG_DIO_OUTPUT :
-				INSN_CONFIG_DIO_INPUT;
+			    (devpriv->rtsi_trig_direction_reg &
+			     RTSI_Output_Bit(chan,
+					     (boardtype.reg_type &
+					      ni_reg_m_series_mask)
+					     != 0)) ? INSN_CONFIG_DIO_OUTPUT :
+			    INSN_CONFIG_DIO_INPUT;
 		} else if (chan == old_RTSI_clock_channel) {
 			data[1] =
-				(devpriv->
-				rtsi_trig_direction_reg & Drive_RTSI_Clock_Bit)
-				? INSN_CONFIG_DIO_OUTPUT :
-				INSN_CONFIG_DIO_INPUT;
+			    (devpriv->rtsi_trig_direction_reg &
+			     Drive_RTSI_Clock_Bit)
+			    ? INSN_CONFIG_DIO_OUTPUT : INSN_CONFIG_DIO_INPUT;
 		}
 		return 2;
 		break;
@@ -5751,12 +5886,12 @@ static void cs5529_command(struct comedi
 
 /* write to cs5529 register */
 static void cs5529_config_write(struct comedi_device *dev, unsigned int value,
-	unsigned int reg_select_bits)
+				unsigned int reg_select_bits)
 {
 	ni_ao_win_outw(dev, ((value >> 16) & 0xff),
-		CAL_ADC_Config_Data_High_Word_67xx);
+		       CAL_ADC_Config_Data_High_Word_67xx);
 	ni_ao_win_outw(dev, (value & 0xffff),
-		CAL_ADC_Config_Data_Low_Word_67xx);
+		       CAL_ADC_Config_Data_Low_Word_67xx);
 	reg_select_bits &= CSCMD_REGISTER_SELECT_MASK;
 	cs5529_command(dev, CSCMD_COMMAND | reg_select_bits);
 	if (cs5529_wait_for_idle(dev))
@@ -5766,7 +5901,7 @@ static void cs5529_config_write(struct c
 #ifdef NI_CS5529_DEBUG
 /* read from cs5529 register */
 static unsigned int cs5529_config_read(struct comedi_device *dev,
-	unsigned int reg_select_bits)
+				       unsigned int reg_select_bits)
 {
 	unsigned int value;
 
@@ -5775,7 +5910,8 @@ static unsigned int cs5529_config_read(s
 	if (cs5529_wait_for_idle(dev))
 		comedi_error(dev, "timeout or signal in cs5529_config_read()");
 	value = (ni_ao_win_inw(dev,
-			CAL_ADC_Config_Data_High_Word_67xx) << 16) & 0xff0000;
+			       CAL_ADC_Config_Data_High_Word_67xx) << 16) &
+	    0xff0000;
 	value |= ni_ao_win_inw(dev, CAL_ADC_Config_Data_Low_Word_67xx) & 0xffff;
 	return value;
 }
@@ -5790,18 +5926,18 @@ static int cs5529_do_conversion(struct c
 	retval = cs5529_wait_for_idle(dev);
 	if (retval) {
 		comedi_error(dev,
-			"timeout or signal in cs5529_do_conversion()");
+			     "timeout or signal in cs5529_do_conversion()");
 		return -ETIME;
 	}
 	status = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);
 	if (status & CSS_OSC_DETECT) {
 		printk
-			("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
+		    ("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");
 		return -EIO;
 	}
 	if (status & CSS_OVERRANGE) {
 		printk
-			("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
+		    ("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");
 	}
 	if (data) {
 		*data = ni_ao_win_inw(dev, CAL_ADC_Data_67xx);
@@ -5811,8 +5947,9 @@ static int cs5529_do_conversion(struct c
 	return 0;
 }
 
-static int cs5529_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cs5529_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n, retval;
 	unsigned short sample;
@@ -5840,29 +5977,28 @@ static int cs5529_ai_insn_read(struct co
 static int init_cs5529(struct comedi_device *dev)
 {
 	unsigned int config_bits =
-		CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;
+	    CSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;
 
 #if 1
 	/* do self-calibration */
 	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET_GAIN,
-		CSCMD_CONFIG_REGISTER);
+			    CSCMD_CONFIG_REGISTER);
 	/* need to force a conversion for calibration to run */
 	cs5529_do_conversion(dev, NULL);
 #else
 	/* force gain calibration to 1 */
 	cs5529_config_write(dev, 0x400000, CSCMD_GAIN_REGISTER);
 	cs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET,
-		CSCMD_CONFIG_REGISTER);
+			    CSCMD_CONFIG_REGISTER);
 	if (cs5529_wait_for_idle(dev))
 		comedi_error(dev, "timeout or signal in init_cs5529()\n");
 #endif
 #ifdef NI_CS5529_DEBUG
 	printk("config: 0x%x\n", cs5529_config_read(dev,
-		CSCMD_CONFIG_REGISTER));
-	printk("gain: 0x%x\n", cs5529_config_read(dev,
-		CSCMD_GAIN_REGISTER));
+						    CSCMD_CONFIG_REGISTER));
+	printk("gain: 0x%x\n", cs5529_config_read(dev, CSCMD_GAIN_REGISTER));
 	printk("offset: 0x%x\n", cs5529_config_read(dev,
-		CSCMD_OFFSET_REGISTER));
+						    CSCMD_OFFSET_REGISTER));
 #endif
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/ni_mio_cs.c
+++ b/drivers/staging/comedi/drivers/ni_mio_cs.c
@@ -82,7 +82,7 @@ static const struct ni_board_struct ni_b
 	 .num_p0_dio_channels = 8,
 	 .has_8255 = 0,
 	 .caldac = {dac8800, dac8043},
-	},
+	 },
 	{.device_id = 0x010c,
 	 .name = "DAQCard-ai-16e-4",
 	 .n_adchan = 16,
@@ -98,7 +98,7 @@ static const struct ni_board_struct ni_b
 	 .num_p0_dio_channels = 8,
 	 .has_8255 = 0,
 	 .caldac = {mb88341},	/* verified */
-	},
+	 },
 	{.device_id = 0x02c4,
 	 .name = "DAQCard-6062E",
 	 .n_adchan = 16,
@@ -116,7 +116,7 @@ static const struct ni_board_struct ni_b
 	 .num_p0_dio_channels = 8,
 	 .has_8255 = 0,
 	 .caldac = {ad8804_debug},	/* verified */
-	},
+	 },
 	{.device_id = 0x075e,
 	 .name = "DAQCard-6024E",	/* specs incorrect! */
 	 .n_adchan = 16,
@@ -134,7 +134,7 @@ static const struct ni_board_struct ni_b
 	 .num_p0_dio_channels = 8,
 	 .has_8255 = 0,
 	 .caldac = {ad8804_debug},
-	},
+	 },
 	{.device_id = 0x0245,
 	 .name = "DAQCard-6036E",	/* specs incorrect! */
 	 .n_adchan = 16,
@@ -152,7 +152,7 @@ static const struct ni_board_struct ni_b
 	 .num_p0_dio_channels = 8,
 	 .has_8255 = 0,
 	 .caldac = {ad8804_debug},
-	},
+	 },
 #if 0
 	{.device_id = 0x0000,	/* unknown */
 	 .name = "DAQCard-6715",
@@ -162,7 +162,7 @@ static const struct ni_board_struct ni_b
 	 .ao_671x = 8192,
 	 .num_p0_dio_channels = 8,
 	 .caldac = {mb88341, mb88341},
-	},
+	 },
 #endif
 	/* N.B. Update ni_mio_cs_ids[] when entries added above. */
 };
@@ -227,7 +227,8 @@ static uint16_t mio_cs_win_in(struct com
 	return ret;
 }
 
-static int mio_cs_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int mio_cs_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int mio_cs_detach(struct comedi_device *dev);
 static struct comedi_driver driver_ni_mio_cs = {
 	.driver_name = "ni_mio_cs",
@@ -238,7 +239,8 @@ static struct comedi_driver driver_ni_mi
 
 #include "ni_mio_common.c"
 
-static int ni_getboardtype(struct comedi_device *dev, struct pcmcia_device *link);
+static int ni_getboardtype(struct comedi_device *dev,
+			   struct pcmcia_device *link);
 
 /* clean up allocated resources */
 /* called when driver is removed */
@@ -266,6 +268,7 @@ static dev_node_t dev_node = {
 	COMEDI_MAJOR, 0,
 	NULL
 };
+
 static int cs_attach(struct pcmcia_device *link)
 {
 	link->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
@@ -340,7 +343,7 @@ static void mio_cs_config(struct pcmcia_
 	tuple.DesiredTuple = CISTPL_MANFID;
 	tuple.Attributes = TUPLE_RETURN_COMMON;
 	if ((pcmcia_get_first_tuple(link, &tuple) == 0) &&
-		(pcmcia_get_tuple_data(link, &tuple) == 0)) {
+	    (pcmcia_get_tuple_data(link, &tuple) == 0)) {
 		manfid = le16_to_cpu(buf[0]);
 		prodid = le16_to_cpu(buf[1]);
 	}
@@ -373,7 +376,7 @@ static void mio_cs_config(struct pcmcia_
 #endif
 	link->io.NumPorts1 = parse.cftable_entry.io.win[0].len;
 	link->io.IOAddrLines =
-		parse.cftable_entry.io.flags & CISTPL_IO_LINES_MASK;
+	    parse.cftable_entry.io.flags & CISTPL_IO_LINES_MASK;
 	link->io.NumPorts2 = 0;
 
 	{
@@ -421,7 +424,7 @@ static int mio_cs_attach(struct comedi_d
 	irq = link->irq.AssignedIRQ;
 
 	printk("comedi%d: %s: DAQCard: io 0x%04lx, irq %u, ",
-		dev->minor, dev->driver->driver_name, dev->iobase, irq);
+	       dev->minor, dev->driver->driver_name, dev->iobase, irq);
 
 #if 0
 	{
@@ -430,7 +433,7 @@ static int mio_cs_attach(struct comedi_d
 		printk(" board fingerprint:");
 		for (i = 0; i < 32; i += 2) {
 			printk(" %04x %02x", inw(dev->iobase + i),
-				inb(dev->iobase + i + 1));
+			       inb(dev->iobase + i + 1));
 		}
 		printk("\n");
 		printk(" board fingerprint (windowed):");
@@ -447,7 +450,7 @@ static int mio_cs_attach(struct comedi_d
 	dev->board_name = boardtype.name;
 
 	ret = request_irq(irq, ni_E_interrupt, NI_E_IRQ_FLAGS,
-				 "ni_mio_cs", dev);
+			  "ni_mio_cs", dev);
 	if (ret < 0) {
 		printk(" irq not available\n");
 		return -EINVAL;
@@ -484,14 +487,15 @@ static int get_prodid(struct comedi_devi
 	tuple.DesiredTuple = CISTPL_MANFID;
 	tuple.Attributes = TUPLE_RETURN_COMMON;
 	if ((pcmcia_get_first_tuple(link, &tuple) == 0) &&
-		(pcmcia_get_tuple_data(link, &tuple) == 0)) {
+	    (pcmcia_get_tuple_data(link, &tuple) == 0)) {
 		prodid = le16_to_cpu(buf[1]);
 	}
 
 	return prodid;
 }
 
-static int ni_getboardtype(struct comedi_device *dev, struct pcmcia_device *link)
+static int ni_getboardtype(struct comedi_device *dev,
+			   struct pcmcia_device *link)
 {
 	int id;
 	int i;
@@ -532,7 +536,7 @@ struct pcmcia_driver ni_mio_cs_driver = 
 	.id_table = ni_mio_cs_ids,
 	.owner = THIS_MODULE,
 	.drv = {
-			.name = dev_info,
+		.name = dev_info,
 		},
 };
 
--- a/drivers/staging/comedi/drivers/ni_pcidio.c
+++ b/drivers/staging/comedi/drivers/ni_pcidio.c
@@ -212,6 +212,7 @@ static inline unsigned primary_DMAChanne
 {
 	return channel & 0x3;
 }
+
 static inline unsigned secondary_DMAChannel_bits(unsigned channel)
 {
 	return (channel << 2) & 0xc;
@@ -290,7 +291,8 @@ enum FPGA_Control_Bits {
 
 static int nidio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int nidio_detach(struct comedi_device *dev);
-static int ni_pcidio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int ni_pcidio_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
 
 static struct comedi_driver driver_pcidio = {
 	.driver_name = "ni_pcidio",
@@ -310,83 +312,84 @@ struct nidio_board {
 
 static const struct nidio_board nidio_boards[] = {
 	{
-	.dev_id = 0x1150,
-	.name = "pci-dio-32hs",
-	.n_8255 = 0,
-	.is_diodaq = 1,
-		},
+	 .dev_id = 0x1150,
+	 .name = "pci-dio-32hs",
+	 .n_8255 = 0,
+	 .is_diodaq = 1,
+	 },
 	{
-	.dev_id = 0x1320,
-	.name = "pxi-6533",
-	.n_8255 = 0,
-	.is_diodaq = 1,
-		},
+	 .dev_id = 0x1320,
+	 .name = "pxi-6533",
+	 .n_8255 = 0,
+	 .is_diodaq = 1,
+	 },
 	{
-	.dev_id = 0x12b0,
-	.name = "pci-6534",
-	.n_8255 = 0,
-	.is_diodaq = 1,
-	.uses_firmware = 1,
-		},
+	 .dev_id = 0x12b0,
+	 .name = "pci-6534",
+	 .n_8255 = 0,
+	 .is_diodaq = 1,
+	 .uses_firmware = 1,
+	 },
 	{
-	.dev_id = 0x0160,
-	.name = "pci-dio-96",
-	.n_8255 = 4,
-	.is_diodaq = 0,
-		},
+	 .dev_id = 0x0160,
+	 .name = "pci-dio-96",
+	 .n_8255 = 4,
+	 .is_diodaq = 0,
+	 },
 	{
-	.dev_id = 0x1630,
-	.name = "pci-dio-96b",
-	.n_8255 = 4,
-	.is_diodaq = 0,
-		},
+	 .dev_id = 0x1630,
+	 .name = "pci-dio-96b",
+	 .n_8255 = 4,
+	 .is_diodaq = 0,
+	 },
 	{
-	.dev_id = 0x13c0,
-	.name = "pxi-6508",
-	.n_8255 = 4,
-	.is_diodaq = 0,
-		},
+	 .dev_id = 0x13c0,
+	 .name = "pxi-6508",
+	 .n_8255 = 4,
+	 .is_diodaq = 0,
+	 },
 	{
-	.dev_id = 0x0400,
-	.name = "pci-6503",
-	.n_8255 = 1,
-	.is_diodaq = 0,
-		},
+	 .dev_id = 0x0400,
+	 .name = "pci-6503",
+	 .n_8255 = 1,
+	 .is_diodaq = 0,
+	 },
 	{
-	.dev_id = 0x1250,
-	.name = "pci-6503b",
-	.n_8255 = 1,
-	.is_diodaq = 0,
-		},
+	 .dev_id = 0x1250,
+	 .name = "pci-6503b",
+	 .n_8255 = 1,
+	 .is_diodaq = 0,
+	 },
 	{
-	.dev_id = 0x17d0,
-	.name = "pci-6503x",
-	.n_8255 = 1,
-	.is_diodaq = 0,
-		},
+	 .dev_id = 0x17d0,
+	 .name = "pci-6503x",
+	 .n_8255 = 1,
+	 .is_diodaq = 0,
+	 },
 	{
-	.dev_id = 0x1800,
-	.name = "pxi-6503",
-	.n_8255 = 1,
-	.is_diodaq = 0,
-		},
+	 .dev_id = 0x1800,
+	 .name = "pxi-6503",
+	 .n_8255 = 1,
+	 .is_diodaq = 0,
+	 },
 };
 
 #define n_nidio_boards (sizeof(nidio_boards)/sizeof(nidio_boards[0]))
 #define this_board ((const struct nidio_board *)dev->board_ptr)
 
 static DEFINE_PCI_DEVICE_TABLE(ni_pcidio_pci_table) = {
-	{PCI_VENDOR_ID_NATINST, 0x1150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x12b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x0160, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1630, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x13c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x0400, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1250, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x17d0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_NATINST, 0x1150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1320, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x12b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x0160, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1630, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x13c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x0400, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1250, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x17d0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, ni_pcidio_pci_table);
@@ -402,14 +405,16 @@ struct nidio96_private {
 };
 #define devpriv ((struct nidio96_private *)dev->private)
 
-static int ni_pcidio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int ni_pcidio_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 static int ni_pcidio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int ni_pcidio_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
+static int ni_pcidio_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int trignum);
 static int nidio_find_device(struct comedi_device *dev, int bus, int slot);
 static int ni_pcidio_ns_to_timer(int *nanosec, int round_mode);
-static int setup_mite_dma(struct comedi_device *dev, struct comedi_subdevice *s);
+static int setup_mite_dma(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 
 #ifdef DEBUG_FLAGS
 static void ni_pcidio_print_flags(unsigned int flags);
@@ -426,16 +431,16 @@ static int ni_pcidio_request_di_mite_cha
 	spin_lock_irqsave(&devpriv->mite_channel_lock, flags);
 	BUG_ON(devpriv->di_mite_chan);
 	devpriv->di_mite_chan =
-		mite_request_channel_in_range(devpriv->mite,
-		devpriv->di_mite_ring, 1, 2);
+	    mite_request_channel_in_range(devpriv->mite,
+					  devpriv->di_mite_ring, 1, 2);
 	if (devpriv->di_mite_chan == NULL) {
 		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 		comedi_error(dev, "failed to reserve mite dma channel.");
 		return -EBUSY;
 	}
 	writeb(primary_DMAChannel_bits(devpriv->di_mite_chan->channel) |
-		secondary_DMAChannel_bits(devpriv->di_mite_chan->channel),
-		devpriv->mite->daq_io_addr + DMA_Line_Control_Group1);
+	       secondary_DMAChannel_bits(devpriv->di_mite_chan->channel),
+	       devpriv->mite->daq_io_addr + DMA_Line_Control_Group1);
 	mmiowb();
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
 	return 0;
@@ -452,8 +457,8 @@ static void ni_pcidio_release_di_mite_ch
 		mite_release_channel(devpriv->di_mite_chan);
 		devpriv->di_mite_chan = NULL;
 		writeb(primary_DMAChannel_bits(0) |
-			secondary_DMAChannel_bits(0),
-			devpriv->mite->daq_io_addr + DMA_Line_Control_Group1);
+		       secondary_DMAChannel_bits(0),
+		       devpriv->mite->daq_io_addr + DMA_Line_Control_Group1);
 		mmiowb();
 	}
 	spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
@@ -471,9 +476,9 @@ static int nidio96_8255_cb(int dir, int 
 
 void ni_pcidio_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	if (s->async->
-		events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))
-	{
+	if (s->
+	    async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |
+			     COMEDI_CB_OVERFLOW)) {
 		ni_pcidio_cancel(dev, s);
 	}
 	comedi_event(dev, s);
@@ -503,7 +508,7 @@ static irqreturn_t nidio_interrupt(int i
 	}
 
 	status = readb(devpriv->mite->daq_io_addr +
-		Interrupt_And_Window_Status);
+		       Interrupt_And_Window_Status);
 	flags = readb(devpriv->mite->daq_io_addr + Group_1_Flags);
 
 	DPRINTK("ni_pcidio_interrupt: status=0x%02x,flags=0x%02x\n",
@@ -525,13 +530,13 @@ static irqreturn_t nidio_interrupt(int i
 	if (m_status & CHSR_INT) {
 		if (m_status & CHSR_LINKC) {
 			writel(CHOR_CLRLC,
-				mite->mite_io_addr +
-				MITE_CHOR(devpriv->di_mite_chan->channel));
+			       mite->mite_io_addr +
+			       MITE_CHOR(devpriv->di_mite_chan->channel));
 			mite_sync_input_dma(devpriv->di_mite_chan, s->async);
 			/* XXX need to byteswap */
 		}
 		if (m_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_DRDY |
-				CHSR_DRQ1 | CHSR_MRDY)) {
+				 CHSR_DRQ1 | CHSR_MRDY)) {
 			DPRINTK("unknown mite interrupt, disabling IRQ\n");
 			async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			disable_irq(dev->irq);
@@ -544,8 +549,8 @@ static irqreturn_t nidio_interrupt(int i
 		if (work > 20) {
 			DPRINTK("too much work in interrupt\n");
 			writeb(0x00,
-				devpriv->mite->daq_io_addr +
-				Master_DMA_And_Interrupt_Control);
+			       devpriv->mite->daq_io_addr +
+			       Master_DMA_And_Interrupt_Control);
 			break;
 		}
 
@@ -558,20 +563,20 @@ static irqreturn_t nidio_interrupt(int i
 				if (work > 100) {
 					DPRINTK("too much work in interrupt\n");
 					writeb(0x00,
-						devpriv->mite->daq_io_addr +
-						Master_DMA_And_Interrupt_Control);
+					       devpriv->mite->daq_io_addr +
+					       Master_DMA_And_Interrupt_Control);
 					goto out;
 				}
 				AuxData =
-					readl(devpriv->mite->daq_io_addr +
-					Group_1_FIFO);
+				    readl(devpriv->mite->daq_io_addr +
+					  Group_1_FIFO);
 				data1 = AuxData & 0xffff;
 				data2 = (AuxData & 0xffff0000) >> 16;
 				comedi_buf_put(async, data1);
 				comedi_buf_put(async, data2);
 				/* DPRINTK("read:%d, %d\n",data1,data2); */
 				flags = readb(devpriv->mite->daq_io_addr +
-					Group_1_Flags);
+					      Group_1_Flags);
 			}
 			/* DPRINTK("buf_int_count: %d\n",async->buf_int_count); */
 			/* DPRINTK("1) IntEn=%d,flags=%d,status=%d\n",IntEn,flags,status); */
@@ -583,8 +588,8 @@ static irqreturn_t nidio_interrupt(int i
 		if (flags & CountExpired) {
 			DPRINTK("CountExpired\n");
 			writeb(ClearExpired,
-				devpriv->mite->daq_io_addr +
-				Group_1_Second_Clear);
+			       devpriv->mite->daq_io_addr +
+			       Group_1_Second_Clear);
 			async->events |= COMEDI_CB_EOA;
 
 			writeb(0x00, devpriv->mite->daq_io_addr + OpMode);
@@ -592,21 +597,21 @@ static irqreturn_t nidio_interrupt(int i
 		} else if (flags & Waited) {
 			DPRINTK("Waited\n");
 			writeb(ClearWaited,
-				devpriv->mite->daq_io_addr +
-				Group_1_First_Clear);
+			       devpriv->mite->daq_io_addr +
+			       Group_1_First_Clear);
 			async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			break;
 		} else if (flags & PrimaryTC) {
 			DPRINTK("PrimaryTC\n");
 			writeb(ClearPrimaryTC,
-				devpriv->mite->daq_io_addr +
-				Group_1_First_Clear);
+			       devpriv->mite->daq_io_addr +
+			       Group_1_First_Clear);
 			async->events |= COMEDI_CB_EOA;
 		} else if (flags & SecondaryTC) {
 			DPRINTK("SecondaryTC\n");
 			writeb(ClearSecondaryTC,
-				devpriv->mite->daq_io_addr +
-				Group_1_First_Clear);
+			       devpriv->mite->daq_io_addr +
+			       Group_1_First_Clear);
 			async->events |= COMEDI_CB_EOA;
 		}
 #if 0
@@ -614,26 +619,26 @@ static irqreturn_t nidio_interrupt(int i
 			printk("ni_pcidio: unknown interrupt\n");
 			async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 			writeb(0x00,
-				devpriv->mite->daq_io_addr +
-				Master_DMA_And_Interrupt_Control);
+			       devpriv->mite->daq_io_addr +
+			       Master_DMA_And_Interrupt_Control);
 		}
 #endif
 		flags = readb(devpriv->mite->daq_io_addr + Group_1_Flags);
 		status = readb(devpriv->mite->daq_io_addr +
-			Interrupt_And_Window_Status);
+			       Interrupt_And_Window_Status);
 		/* DPRINTK("loop end: IntEn=0x%02x,flags=0x%02x,status=0x%02x\n", */
 		/* IntEn,flags,status); */
 		/* ni_pcidio_print_flags(flags); */
 		/* ni_pcidio_print_status(status); */
 	}
 
-      out:
+out:
 	ni_pcidio_event(dev, s);
 #if 0
 	if (!tag) {
 		writeb(0x03,
-			devpriv->mite->daq_io_addr +
-			Master_DMA_And_Interrupt_Control);
+		       devpriv->mite->daq_io_addr +
+		       Master_DMA_And_Interrupt_Control);
 	}
 #endif
 	return IRQ_HANDLED;
@@ -644,6 +649,7 @@ static const char *const flags_strings[]
 	"TransferReady", "CountExpired", "2", "3",
 	"4", "Waited", "PrimaryTC", "SecondaryTC",
 };
+
 static void ni_pcidio_print_flags(unsigned int flags)
 {
 	int i;
@@ -656,10 +662,12 @@ static void ni_pcidio_print_flags(unsign
 	}
 	printk("\n");
 }
+
 static char *status_strings[] = {
 	"DataLeft1", "Reserved1", "Req1", "StopTrig1",
 	"DataLeft2", "Reserved2", "Req2", "StopTrig2",
 };
+
 static void ni_pcidio_print_status(unsigned int flags)
 {
 	int i;
@@ -675,7 +683,7 @@ static void ni_pcidio_print_status(unsig
 #endif
 
 #ifdef unused
-static void debug_int(struct comedi_device * dev)
+static void debug_int(struct comedi_device *dev)
 {
 	int a, b;
 	static int n_int = 0;
@@ -704,8 +712,9 @@ static void debug_int(struct comedi_devi
 }
 #endif
 
-static int ni_pcidio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_pcidio_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 1)
 		return -EINVAL;
@@ -718,9 +727,9 @@ static int ni_pcidio_insn_config(struct 
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
@@ -731,8 +740,9 @@ static int ni_pcidio_insn_config(struct 
 	return 1;
 }
 
-static int ni_pcidio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ni_pcidio_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -746,8 +756,8 @@ static int ni_pcidio_insn_bits(struct co
 	return 2;
 }
 
-static int ni_pcidio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int ni_pcidio_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -788,7 +798,7 @@ static int ni_pcidio_cmdtest(struct come
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_INT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 
 	if (err)
@@ -844,7 +854,7 @@ static int ni_pcidio_cmdtest(struct come
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		ni_pcidio_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				      cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -878,7 +888,7 @@ static int ni_pcidio_ns_to_timer(int *na
 	return divider;
 }
 
-static int ni_pcidio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_pcidio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 
@@ -891,11 +901,11 @@ static int ni_pcidio_cmd(struct comedi_d
 
 		/* set transfer width a 32 bits */
 		writeb(TransferWidth(0) | TransferLength(0),
-			devpriv->mite->daq_io_addr + Transfer_Size_Control);
+		       devpriv->mite->daq_io_addr + Transfer_Size_Control);
 	} else {
 		writeb(0x03, devpriv->mite->daq_io_addr + Data_Path);
 		writeb(TransferWidth(3) | TransferLength(0),
-			devpriv->mite->daq_io_addr + Transfer_Size_Control);
+		       devpriv->mite->daq_io_addr + Transfer_Size_Control);
 	}
 
 	/* protocol configuration */
@@ -909,8 +919,8 @@ static int ni_pcidio_cmd(struct comedi_d
 		writeb(3, devpriv->mite->daq_io_addr + LinePolarities);
 		writeb(0xc0, devpriv->mite->daq_io_addr + AckSer);
 		writel(ni_pcidio_ns_to_timer(&cmd->scan_begin_arg,
-				TRIG_ROUND_NEAREST),
-			devpriv->mite->daq_io_addr + StartDelay);
+					     TRIG_ROUND_NEAREST),
+		       devpriv->mite->daq_io_addr + StartDelay);
 		writeb(1, devpriv->mite->daq_io_addr + ReqDelay);
 		writeb(1, devpriv->mite->daq_io_addr + ReqNotDelay);
 		writeb(1, devpriv->mite->daq_io_addr + AckDelay);
@@ -942,14 +952,14 @@ static int ni_pcidio_cmd(struct comedi_d
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		writel(cmd->stop_arg,
-			devpriv->mite->daq_io_addr + Transfer_Count);
+		       devpriv->mite->daq_io_addr + Transfer_Count);
 	} else {
 		/* XXX */
 	}
 
 #ifdef USE_DMA
 	writeb(ClearPrimaryTC | ClearSecondaryTC,
-		devpriv->mite->daq_io_addr + Group_1_First_Clear);
+	       devpriv->mite->daq_io_addr + Group_1_First_Clear);
 
 	{
 		int retval = setup_mite_dma(dev, s);
@@ -967,7 +977,7 @@ static int ni_pcidio_cmd(struct comedi_d
 
 	writeb(IntEn, devpriv->mite->daq_io_addr + Interrupt_Control);
 	writeb(0x03,
-		devpriv->mite->daq_io_addr + Master_DMA_And_Interrupt_Control);
+	       devpriv->mite->daq_io_addr + Master_DMA_And_Interrupt_Control);
 
 	if (cmd->stop_src == TRIG_NONE) {
 		devpriv->OpModeBits = DataLatching(0) | RunMode(7);
@@ -977,7 +987,7 @@ static int ni_pcidio_cmd(struct comedi_d
 	if (cmd->start_src == TRIG_NOW) {
 		/* start */
 		writeb(devpriv->OpModeBits,
-			devpriv->mite->daq_io_addr + OpMode);
+		       devpriv->mite->daq_io_addr + OpMode);
 		s->async->inttrig = NULL;
 	} else {
 		/* TRIG_INT */
@@ -988,7 +998,7 @@ static int ni_pcidio_cmd(struct comedi_d
 	return 0;
 }
 
-static int setup_mite_dma(struct comedi_device * dev, struct comedi_subdevice * s)
+static int setup_mite_dma(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int retval;
 
@@ -1004,8 +1014,8 @@ static int setup_mite_dma(struct comedi_
 	return 0;
 }
 
-static int ni_pcidio_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
-	unsigned int trignum)
+static int ni_pcidio_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int trignum)
 {
 	if (trignum != 0)
 		return -EINVAL;
@@ -1016,17 +1026,18 @@ static int ni_pcidio_inttrig(struct come
 	return 1;
 }
 
-static int ni_pcidio_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int ni_pcidio_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	writeb(0x00,
-		devpriv->mite->daq_io_addr + Master_DMA_And_Interrupt_Control);
+	       devpriv->mite->daq_io_addr + Master_DMA_And_Interrupt_Control);
 	ni_pcidio_release_di_mite_channel(dev);
 
 	return 0;
 }
 
-static int ni_pcidio_change(struct comedi_device * dev, struct comedi_subdevice * s,
-	unsigned long new_size)
+static int ni_pcidio_change(struct comedi_device *dev,
+			    struct comedi_subdevice *s, unsigned long new_size)
 {
 	int ret;
 
@@ -1039,50 +1050,53 @@ static int ni_pcidio_change(struct comed
 	return 0;
 }
 
-static int pci_6534_load_fpga(struct comedi_device * dev, int fpga_index, u8 * data,
-	int data_len)
+static int pci_6534_load_fpga(struct comedi_device *dev, int fpga_index,
+			      u8 * data, int data_len)
 {
 	static const int timeout = 1000;
 	int i, j;
 	writew(0x80 | fpga_index,
-		devpriv->mite->daq_io_addr + Firmware_Control_Register);
+	       devpriv->mite->daq_io_addr + Firmware_Control_Register);
 	writew(0xc0 | fpga_index,
-		devpriv->mite->daq_io_addr + Firmware_Control_Register);
+	       devpriv->mite->daq_io_addr + Firmware_Control_Register);
 	for (i = 0;
-		(readw(devpriv->mite->daq_io_addr +
-				Firmware_Status_Register) & 0x2) == 0
-		&& i < timeout; ++i) {
+	     (readw(devpriv->mite->daq_io_addr +
+		    Firmware_Status_Register) & 0x2) == 0 && i < timeout; ++i) {
 		udelay(1);
 	}
 	if (i == timeout) {
-		printk("ni_pcidio: failed to load fpga %i, waiting for status 0x2\n", fpga_index);
+		printk
+		    ("ni_pcidio: failed to load fpga %i, waiting for status 0x2\n",
+		     fpga_index);
 		return -EIO;
 	}
 	writew(0x80 | fpga_index,
-		devpriv->mite->daq_io_addr + Firmware_Control_Register);
+	       devpriv->mite->daq_io_addr + Firmware_Control_Register);
 	for (i = 0;
-		readw(devpriv->mite->daq_io_addr + Firmware_Status_Register) !=
-		0x3 && i < timeout; ++i) {
+	     readw(devpriv->mite->daq_io_addr + Firmware_Status_Register) !=
+	     0x3 && i < timeout; ++i) {
 		udelay(1);
 	}
 	if (i == timeout) {
-		printk("ni_pcidio: failed to load fpga %i, waiting for status 0x3\n", fpga_index);
+		printk
+		    ("ni_pcidio: failed to load fpga %i, waiting for status 0x3\n",
+		     fpga_index);
 		return -EIO;
 	}
 	for (j = 0; j + 1 < data_len;) {
 		unsigned int value = data[j++];
 		value |= data[j++] << 8;
 		writew(value,
-			devpriv->mite->daq_io_addr + Firmware_Data_Register);
+		       devpriv->mite->daq_io_addr + Firmware_Data_Register);
 		for (i = 0;
-			(readw(devpriv->mite->daq_io_addr +
-					Firmware_Status_Register) & 0x2) == 0
-			&& i < timeout; ++i) {
+		     (readw(devpriv->mite->daq_io_addr +
+			    Firmware_Status_Register) & 0x2) == 0
+		     && i < timeout; ++i) {
 			udelay(1);
 		}
 		if (i == timeout) {
 			printk("ni_pcidio: failed to load word into fpga %i\n",
-				fpga_index);
+			       fpga_index);
 			return -EIO;
 		}
 		if (need_resched())
@@ -1092,12 +1106,12 @@ static int pci_6534_load_fpga(struct com
 	return 0;
 }
 
-static int pci_6534_reset_fpga(struct comedi_device * dev, int fpga_index)
+static int pci_6534_reset_fpga(struct comedi_device *dev, int fpga_index)
 {
 	return pci_6534_load_fpga(dev, fpga_index, NULL, 0);
 }
 
-static int pci_6534_reset_fpgas(struct comedi_device * dev)
+static int pci_6534_reset_fpgas(struct comedi_device *dev)
 {
 	int ret;
 	int i;
@@ -1111,7 +1125,7 @@ static int pci_6534_reset_fpgas(struct c
 	return ret;
 }
 
-static void pci_6534_init_main_fpga(struct comedi_device * dev)
+static void pci_6534_init_main_fpga(struct comedi_device *dev)
 {
 	writel(0, devpriv->mite->daq_io_addr + FPGA_Control1_Register);
 	writel(0, devpriv->mite->daq_io_addr + FPGA_Control2_Register);
@@ -1121,7 +1135,7 @@ static void pci_6534_init_main_fpga(stru
 	writel(0, devpriv->mite->daq_io_addr + FPGA_SCBMS_Counter_Register);
 }
 
-static int pci_6534_upload_firmware(struct comedi_device * dev, int options[])
+static int pci_6534_upload_firmware(struct comedi_device *dev, int options[])
 {
 	int ret;
 	void *main_fpga_data, *scarab_a_data, *scarab_b_data;
@@ -1151,7 +1165,7 @@ static int pci_6534_upload_firmware(stru
 	return 0;
 }
 
-static int nidio_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int nidio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int i;
@@ -1198,22 +1212,23 @@ static int nidio_attach(struct comedi_de
 	if (!this_board->is_diodaq) {
 		for (i = 0; i < this_board->n_8255; i++) {
 			subdev_8255_init(dev, dev->subdevices + i,
-				nidio96_8255_cb,
-				(unsigned long)(devpriv->mite->daq_io_addr +
-					NIDIO_8255_BASE(i)));
+					 nidio96_8255_cb,
+					 (unsigned long)(devpriv->mite->
+							 daq_io_addr +
+							 NIDIO_8255_BASE(i)));
 		}
 	} else {
 
 		printk(" rev=%d",
-			readb(devpriv->mite->daq_io_addr + Chip_Version));
+		       readb(devpriv->mite->daq_io_addr + Chip_Version));
 
 		s = dev->subdevices + 0;
 
 		dev->read_subdev = s;
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags =
-			SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_PACKED |
-			SDF_CMD_READ;
+		    SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_PACKED |
+		    SDF_CMD_READ;
 		s->n_chan = 32;
 		s->range_table = &range_digital;
 		s->maxdata = 1;
@@ -1232,8 +1247,8 @@ static int nidio_attach(struct comedi_de
 
 		/* disable interrupts on board */
 		writeb(0x00,
-			devpriv->mite->daq_io_addr +
-			Master_DMA_And_Interrupt_Control);
+		       devpriv->mite->daq_io_addr +
+		       Master_DMA_And_Interrupt_Control);
 
 		ret = request_irq(irq, nidio_interrupt, IRQF_SHARED,
 				  "ni_pcidio", dev);
@@ -1248,7 +1263,7 @@ static int nidio_attach(struct comedi_de
 	return 0;
 }
 
-static int nidio_detach(struct comedi_device * dev)
+static int nidio_detach(struct comedi_device *dev)
 {
 	int i;
 
@@ -1272,7 +1287,7 @@ static int nidio_detach(struct comedi_de
 	return 0;
 }
 
-static int nidio_find_device(struct comedi_device * dev, int bus, int slot)
+static int nidio_find_device(struct comedi_device *dev, int bus, int slot)
 {
 	struct mite_struct *mite;
 	int i;
@@ -1282,7 +1297,7 @@ static int nidio_find_device(struct come
 			continue;
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number ||
-				slot != PCI_SLOT(mite->pcidev->devfn))
+			    slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
 		for (i = 0; i < n_nidio_boards; i++) {
--- a/drivers/staging/comedi/drivers/ni_pcimio.c
+++ b/drivers/staging/comedi/drivers/ni_pcimio.c
@@ -130,58 +130,59 @@ Bugs:
 
 /* The following two tables must be in the same order */
 static DEFINE_PCI_DEVICE_TABLE(ni_pci_table) = {
-	{PCI_VENDOR_ID_NATINST, 0x0162, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1170, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1180, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1190, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x11b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x11c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x11d0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1270, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1330, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1340, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1350, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x14e0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x14f0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1580, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x15b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1880, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x1870, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x18b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x18c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2410, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2420, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2430, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2890, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x28c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2a60, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2a70, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2a80, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2ab0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2b80, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2b90, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2c80, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x2ca0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70aa, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70ab, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70ac, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70af, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70b4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70b6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70b7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70b8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70bc, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70bd, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70bf, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x70f2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x710d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x716c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x717f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x71bc, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NATINST, 0x717d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_NATINST, 0x0162, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1170, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1180, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1190, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x11b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x11c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x11d0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1270, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1330, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1340, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1350, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x14e0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x14f0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1580, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x15b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1880, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x1870, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x18b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x18c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2410, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2420, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2430, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2890, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x28c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2a60, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2a70, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2a80, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2ab0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2b80, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2b90, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2c80, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x2ca0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70aa, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70ab, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70ac, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70af, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70b4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70b6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70b7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70b8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70bc, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70bd, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70bf, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x70f2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x710d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x716c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x717f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x71bc, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_NATINST, 0x717d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, ni_pci_table);
@@ -194,1020 +195,1023 @@ MODULE_DEVICE_TABLE(pci, ni_pci_table);
  can not act as it's own OFFSET or REFERENCE.
 */
 static const struct comedi_lrange range_ni_M_628x_ao = { 8, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2, 2),
-			RANGE(-1, 1),
-			RANGE(-5, 15),
-			RANGE(0, 10),
-			RANGE(3, 7),
-			RANGE(4, 6),
-			RANGE_ext(-1, 1)
-	}
+							     RANGE(-10, 10),
+							     RANGE(-5, 5),
+							     RANGE(-2, 2),
+							     RANGE(-1, 1),
+							     RANGE(-5, 15),
+							     RANGE(0, 10),
+							     RANGE(3, 7),
+							     RANGE(4, 6),
+							     RANGE_ext(-1, 1)
+							     }
 };
+
 static const struct comedi_lrange range_ni_M_625x_ao = { 3, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE_ext(-1, 1)
-	}
+							     RANGE(-10, 10),
+							     RANGE(-5, 5),
+							     RANGE_ext(-1, 1)
+							     }
 };
+
 static const struct comedi_lrange range_ni_M_622x_ao = { 1, {
-			RANGE(-10, 10),
-	}
+							     RANGE(-10, 10),
+							     }
 };
 
 static const struct ni_board_struct ni_boards[] = {
 	{
-			.device_id = 0x0162,	/*  NI also says 0x1620.  typo? */
-			.name = "pci-mio-16xe-50",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 2048,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_8,
-			.ai_speed = 50000,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 0,
-			.ao_range_table = &range_bipolar10,
-			.ao_unipolar = 0,
-			.ao_speed = 50000,
-			.num_p0_dio_channels = 8,
-			.caldac = {dac8800, dac8043},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x1170,
-			.name = "pci-mio-16xe-10",	/*  aka pci-6030E */
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_14,
-			.ai_speed = 10000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 10000,
-			.num_p0_dio_channels = 8,
-			.caldac = {dac8800, dac8043, ad8522},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x28c0,
-			.name = "pci-6014",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_4,
-			.ai_speed = 5000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 0,
-			.ao_range_table = &range_bipolar10,
-			.ao_unipolar = 0,
-			.ao_speed = 100000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x11d0,
-			.name = "pxi-6030e",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_14,
-			.ai_speed = 10000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 10000,
-			.num_p0_dio_channels = 8,
-			.caldac = {dac8800, dac8043, ad8522},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x1180,
-			.name = "pci-mio-16e-1",	/* aka pci-6070e */
-			.n_adchan = 16,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_16,
-			.ai_speed = 800,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.caldac = {mb88341},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x1190,
-			.name = "pci-mio-16e-4",	/* aka pci-6040e */
-			.n_adchan = 16,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_16,
-			/*	.Note = there have been reported problems with full speed
-			 * on this board */
-			.ai_speed = 2000,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 512,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},	/*  doc says mb88341 */
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x11c0,
-			.name = "pxi-6040e",
-			.n_adchan = 16,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_16,
-			.ai_speed = 2000,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 512,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.caldac = {mb88341},
-			.has_8255 = 0,
-		},
-
-	{
-			.device_id = 0x1330,
-			.name = "pci-6031e",
-			.n_adchan = 64,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_14,
-			.ai_speed = 10000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 10000,
-			.num_p0_dio_channels = 8,
-			.caldac = {dac8800, dac8043, ad8522},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x1270,
-			.name = "pci-6032e",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_14,
-			.ai_speed = 10000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 8,
-			.caldac = {dac8800, dac8043, ad8522},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x1340,
-			.name = "pci-6033e",
-			.n_adchan = 64,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_14,
-			.ai_speed = 10000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 8,
-			.caldac = {dac8800, dac8043, ad8522},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x1350,
-			.name = "pci-6071e",
-			.n_adchan = 64,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_16,
-			.ai_speed = 800,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x2a60,
-			.name = "pci-6023e",
-			.n_adchan = 16,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_4,
-			.ai_speed = 5000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},	/* manual is wrong */
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x2a70,
-			.name = "pci-6024e",
-			.n_adchan = 16,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_4,
-			.ai_speed = 5000,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 0,
-			.ao_range_table = &range_bipolar10,
-			.ao_unipolar = 0,
-			.ao_speed = 100000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},	/* manual is wrong */
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x2a80,
-			.name = "pci-6025e",
-			.n_adchan = 16,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_4,
-			.ai_speed = 5000,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 0,
-			.ao_range_table = &range_bipolar10,
-			.ao_unipolar = 0,
-			.ao_speed = 100000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},	/* manual is wrong */
-			.has_8255 = 1,
-		},
-	{
-			.device_id = 0x2ab0,
-			.name = "pxi-6025e",
-			.n_adchan = 16,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_4,
-			.ai_speed = 5000,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 0,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 100000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},	/* manual is wrong */
-			.has_8255 = 1,
-		},
-
-	{
-			.device_id = 0x2ca0,
-			.name = "pci-6034e",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_4,
-			.ai_speed = 5000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x2c80,
-			.name = "pci-6035e",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_4,
-			.ai_speed = 5000,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 0,
-			.ao_range_table = &range_bipolar10,
-			.ao_unipolar = 0,
-			.ao_speed = 100000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x18b0,
-			.name = "pci-6052e",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_16,
-			.ai_speed = 3000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_unipolar = 1,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_speed = 3000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug, ad8804_debug, ad8522},	/* manual is wrong */
-		},
+	 .device_id = 0x0162,	/*  NI also says 0x1620.  typo? */
+	 .name = "pci-mio-16xe-50",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 2048,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_8,
+	 .ai_speed = 50000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_speed = 50000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x1170,
+	 .name = "pci-mio-16xe-10",	/*  aka pci-6030E */
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_14,
+	 .ai_speed = 10000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 10000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043, ad8522},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x28c0,
+	 .name = "pci-6014",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_4,
+	 .ai_speed = 5000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_speed = 100000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x11d0,
+	 .name = "pxi-6030e",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_14,
+	 .ai_speed = 10000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 10000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043, ad8522},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x1180,
+	 .name = "pci-mio-16e-1",	/* aka pci-6070e */
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 800,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {mb88341},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x1190,
+	 .name = "pci-mio-16e-4",	/* aka pci-6040e */
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_16,
+	 /*      .Note = there have been reported problems with full speed
+	  * on this board */
+	 .ai_speed = 2000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 512,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},	/*  doc says mb88341 */
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x11c0,
+	 .name = "pxi-6040e",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 2000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 512,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {mb88341},
+	 .has_8255 = 0,
+	 },
+
+	{
+	 .device_id = 0x1330,
+	 .name = "pci-6031e",
+	 .n_adchan = 64,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_14,
+	 .ai_speed = 10000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 10000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043, ad8522},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x1270,
+	 .name = "pci-6032e",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_14,
+	 .ai_speed = 10000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043, ad8522},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x1340,
+	 .name = "pci-6033e",
+	 .n_adchan = 64,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_14,
+	 .ai_speed = 10000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043, ad8522},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x1350,
+	 .name = "pci-6071e",
+	 .n_adchan = 64,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 800,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x2a60,
+	 .name = "pci-6023e",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_4,
+	 .ai_speed = 5000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},	/* manual is wrong */
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x2a70,
+	 .name = "pci-6024e",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_4,
+	 .ai_speed = 5000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_speed = 100000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},	/* manual is wrong */
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x2a80,
+	 .name = "pci-6025e",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_4,
+	 .ai_speed = 5000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_speed = 100000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},	/* manual is wrong */
+	 .has_8255 = 1,
+	 },
+	{
+	 .device_id = 0x2ab0,
+	 .name = "pxi-6025e",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_4,
+	 .ai_speed = 5000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 100000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},	/* manual is wrong */
+	 .has_8255 = 1,
+	 },
+
+	{
+	 .device_id = 0x2ca0,
+	 .name = "pci-6034e",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_4,
+	 .ai_speed = 5000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x2c80,
+	 .name = "pci-6035e",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_4,
+	 .ai_speed = 5000,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_speed = 100000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x18b0,
+	 .name = "pci-6052e",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 3000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_unipolar = 1,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_speed = 3000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug, ad8804_debug, ad8522},	/* manual is wrong */
+	 },
 	{.device_id = 0x14e0,
-			.name = "pci-6110",
-			.n_adchan = 4,
-			.adbits = 12,
-			.ai_fifo_depth = 8192,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_611x,
-			.ai_speed = 200,
-			.n_aochan = 2,
-			.aobits = 16,
-			.reg_type = ni_reg_611x,
-			.ao_range_table = &range_bipolar10,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 2048,
-			.ao_speed = 250,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804, ad8804},
-		},
-	{
-			.device_id = 0x14f0,
-			.name = "pci-6111",
-			.n_adchan = 2,
-			.adbits = 12,
-			.ai_fifo_depth = 8192,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_611x,
-			.ai_speed = 200,
-			.n_aochan = 2,
-			.aobits = 16,
-			.reg_type = ni_reg_611x,
-			.ao_range_table = &range_bipolar10,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 2048,
-			.ao_speed = 250,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804, ad8804},
-		},
+	 .name = "pci-6110",
+	 .n_adchan = 4,
+	 .adbits = 12,
+	 .ai_fifo_depth = 8192,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_611x,
+	 .ai_speed = 200,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .reg_type = ni_reg_611x,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 2048,
+	 .ao_speed = 250,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804, ad8804},
+	 },
+	{
+	 .device_id = 0x14f0,
+	 .name = "pci-6111",
+	 .n_adchan = 2,
+	 .adbits = 12,
+	 .ai_fifo_depth = 8192,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_611x,
+	 .ai_speed = 200,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .reg_type = ni_reg_611x,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 2048,
+	 .ao_speed = 250,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804, ad8804},
+	 },
 #if 0
 	/* The 6115 boards probably need their own driver */
 	{
-			.device_id = 0x2ed0,
-			.name = "pci-6115",
-			.n_adchan = 4,
-			.adbits = 12,
-			.ai_fifo_depth = 8192,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_611x,
-			.ai_speed = 100,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_671x = 1,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 2048,
-			.ao_speed = 250,
-			.num_p0_dio_channels = 8,
-			.reg_611x = 1,
-			.caldac = {ad8804_debug, ad8804_debug, ad8804_debug},	/* XXX */
-		},
+	 .device_id = 0x2ed0,
+	 .name = "pci-6115",
+	 .n_adchan = 4,
+	 .adbits = 12,
+	 .ai_fifo_depth = 8192,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_611x,
+	 .ai_speed = 100,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_671x = 1,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 2048,
+	 .ao_speed = 250,
+	 .num_p0_dio_channels = 8,
+	 .reg_611x = 1,
+	 .caldac = {ad8804_debug, ad8804_debug, ad8804_debug},	/* XXX */
+	 },
 #endif
 #if 0
 	{
-			.device_id = 0x0000,
-			.name = "pxi-6115",
-			.n_adchan = 4,
-			.adbits = 12,
-			.ai_fifo_depth = 8192,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_611x,
-			.ai_speed = 100,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_671x = 1,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 2048,
-			.ao_speed = 250,
-			.reg_611x = 1,
-			.num_p0_dio_channels = 8,
-			caldac = {ad8804_debug, ad8804_debug, ad8804_debug},	/* XXX */
-		},
+	 .device_id = 0x0000,
+	 .name = "pxi-6115",
+	 .n_adchan = 4,
+	 .adbits = 12,
+	 .ai_fifo_depth = 8192,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_611x,
+	 .ai_speed = 100,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_671x = 1,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 2048,
+	 .ao_speed = 250,
+	 .reg_611x = 1,
+	 .num_p0_dio_channels = 8,
+	 caldac = {ad8804_debug, ad8804_debug, ad8804_debug},	/* XXX */
+	 },
 #endif
 	{
-			.device_id = 0x1880,
-			.name = "pci-6711",
-			.n_adchan = 0,	/* no analog input */
-			.n_aochan = 4,
-			.aobits = 12,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 16384,
-			/* data sheet says 8192, but fifo really holds 16384 samples */
-			.ao_range_table = &range_bipolar10,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_6711,
-			.caldac = {ad8804_debug},
-		},
-	{
-			.device_id = 0x2b90,
-			.name = "pxi-6711",
-			.n_adchan = 0,	/* no analog input */
-			.n_aochan = 4,
-			.aobits = 12,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 16384,
-			.ao_range_table = &range_bipolar10,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_6711,
-			.caldac = {ad8804_debug},
-		},
-	{
-			.device_id = 0x1870,
-			.name = "pci-6713",
-			.n_adchan = 0,	/* no analog input */
-			.n_aochan = 8,
-			.aobits = 12,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 16384,
-			.ao_range_table = &range_bipolar10,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_6713,
-			.caldac = {ad8804_debug, ad8804_debug},
-		},
-	{
-			.device_id = 0x2b80,
-			.name = "pxi-6713",
-			.n_adchan = 0,	/* no analog input */
-			.n_aochan = 8,
-			.aobits = 12,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 16384,
-			.ao_range_table = &range_bipolar10,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_6713,
-			.caldac = {ad8804_debug, ad8804_debug},
-		},
-	{
-			.device_id = 0x2430,
-			.name = "pci-6731",
-			.n_adchan = 0,	/* no analog input */
-			.n_aochan = 4,
-			.aobits = 16,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 8192,
-			.ao_range_table = &range_bipolar10,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_6711,
-			.caldac = {ad8804_debug},
-		},
+	 .device_id = 0x1880,
+	 .name = "pci-6711",
+	 .n_adchan = 0,		/* no analog input */
+	 .n_aochan = 4,
+	 .aobits = 12,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 16384,
+	 /* data sheet says 8192, but fifo really holds 16384 samples */
+	 .ao_range_table = &range_bipolar10,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_6711,
+	 .caldac = {ad8804_debug},
+	 },
+	{
+	 .device_id = 0x2b90,
+	 .name = "pxi-6711",
+	 .n_adchan = 0,		/* no analog input */
+	 .n_aochan = 4,
+	 .aobits = 12,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 16384,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_6711,
+	 .caldac = {ad8804_debug},
+	 },
+	{
+	 .device_id = 0x1870,
+	 .name = "pci-6713",
+	 .n_adchan = 0,		/* no analog input */
+	 .n_aochan = 8,
+	 .aobits = 12,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 16384,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_6713,
+	 .caldac = {ad8804_debug, ad8804_debug},
+	 },
+	{
+	 .device_id = 0x2b80,
+	 .name = "pxi-6713",
+	 .n_adchan = 0,		/* no analog input */
+	 .n_aochan = 8,
+	 .aobits = 12,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 16384,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_6713,
+	 .caldac = {ad8804_debug, ad8804_debug},
+	 },
+	{
+	 .device_id = 0x2430,
+	 .name = "pci-6731",
+	 .n_adchan = 0,		/* no analog input */
+	 .n_aochan = 4,
+	 .aobits = 16,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 8192,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_6711,
+	 .caldac = {ad8804_debug},
+	 },
 #if 0				/* need device ids */
 	{
-			.device_id = 0x0,
-			.name = "pxi-6731",
-			.n_adchan = 0,	/* no analog input */
-			.n_aochan = 4,
-			.aobits = 16,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 8192,
-			.ao_range_table = &range_bipolar10,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_6711,
-			.caldac = {ad8804_debug},
-		},
+	 .device_id = 0x0,
+	 .name = "pxi-6731",
+	 .n_adchan = 0,		/* no analog input */
+	 .n_aochan = 4,
+	 .aobits = 16,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 8192,
+	 .ao_range_table = &range_bipolar10,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_6711,
+	 .caldac = {ad8804_debug},
+	 },
 #endif
 	{
-			.device_id = 0x2410,
-			.name = "pci-6733",
-			.n_adchan = 0,	/* no analog input */
-			.n_aochan = 8,
-			.aobits = 16,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 16384,
-			.ao_range_table = &range_bipolar10,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_6713,
-			.caldac = {ad8804_debug, ad8804_debug},
-		},
-	{
-			.device_id = 0x2420,
-			.name = "pxi-6733",
-			.n_adchan = 0,	/* no analog input */
-			.n_aochan = 8,
-			.aobits = 16,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 16384,
-			.ao_range_table = &range_bipolar10,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_6713,
-			.caldac = {ad8804_debug, ad8804_debug},
-		},
-	{
-			.device_id = 0x15b0,
-			.name = "pxi-6071e",
-			.n_adchan = 64,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_16,
-			.ai_speed = 800,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x11b0,
-			.name = "pxi-6070e",
-			.n_adchan = 16,
-			.adbits = 12,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_16,
-			.ai_speed = 800,
-			.n_aochan = 2,
-			.aobits = 12,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 1000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x18c0,
-			.name = "pxi-6052e",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_16,
-			.ai_speed = 3000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_unipolar = 1,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_speed = 3000,
-			.num_p0_dio_channels = 8,
-			.caldac = {mb88341, mb88341, ad8522},
-		},
-	{
-			.device_id = 0x1580,
-			.name = "pxi-6031e",
-			.n_adchan = 64,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_14,
-			.ai_speed = 10000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 2048,
-			.ao_range_table = &range_ni_E_ao_ext,
-			.ao_unipolar = 1,
-			.ao_speed = 10000,
-			.num_p0_dio_channels = 8,
-			.caldac = {dac8800, dac8043, ad8522},
-		},
-	{
-			.device_id = 0x2890,
-			.name = "pci-6036e",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			.alwaysdither = 1,
-			.gainlkup = ai_gain_4,
-			.ai_speed = 5000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 0,
-			.ao_range_table = &range_bipolar10,
-			.ao_unipolar = 0,
-			.ao_speed = 100000,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70b0,
-			.name = "pci-6220",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 512,
-			/*	.FIXME = guess */
-			.gainlkup = ai_gain_622x,
-			.ai_speed = 4000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.num_p0_dio_channels = 8,
-			.reg_type = ni_reg_622x,
-			.ao_unipolar = 0,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70af,
-			.name = "pci-6221",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_622x,
-			.ai_speed = 4000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_622x_ao,
-			.reg_type = ni_reg_622x,
-			.ao_unipolar = 0,
-			.ao_speed = 1200,
-			.num_p0_dio_channels = 8,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x71bc,
-			.name = "pci-6221_37pin",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_622x,
-			.ai_speed = 4000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_622x_ao,
-			.reg_type = ni_reg_622x,
-			.ao_unipolar = 0,
-			.ao_speed = 1200,
-			.num_p0_dio_channels = 8,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70f2,
-			.name = "pci-6224",
-			.n_adchan = 32,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_622x,
-			.ai_speed = 4000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.reg_type = ni_reg_622x,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70f3,
-			.name = "pxi-6224",
-			.n_adchan = 32,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_622x,
-			.ai_speed = 4000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.reg_type = ni_reg_622x,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x716c,
-			.name = "pci-6225",
-			.n_adchan = 80,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_622x,
-			.ai_speed = 4000,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_622x_ao,
-			.reg_type = ni_reg_622x,
-			.ao_unipolar = 0,
-			.ao_speed = 1200,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70aa,
-			.name = "pci-6229",
-			.n_adchan = 32,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_622x,
-			.ai_speed = 4000,
-			.n_aochan = 4,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_622x_ao,
-			.reg_type = ni_reg_622x,
-			.ao_unipolar = 0,
-			.ao_speed = 1200,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70b4,
-			.name = "pci-6250",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 800,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.reg_type = ni_reg_625x,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 8,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70b8,
-			.name = "pci-6251",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 800,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_625x_ao,
-			.reg_type = ni_reg_625x,
-			.ao_unipolar = 0,
-			.ao_speed = 357,
-			.num_p0_dio_channels = 8,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x717d,
-			.name = "pcie-6251",
-			.n_adchan = 16,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 800,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_625x_ao,
-			.reg_type = ni_reg_625x,
-			.ao_unipolar = 0,
-			.ao_speed = 357,
-			.num_p0_dio_channels = 8,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70b7,
-			.name = "pci-6254",
-			.n_adchan = 32,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 800,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.reg_type = ni_reg_625x,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70ab,
-			.name = "pci-6259",
-			.n_adchan = 32,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 800,
-			.n_aochan = 4,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_625x_ao,
-			.reg_type = ni_reg_625x,
-			.ao_unipolar = 0,
-			.ao_speed = 357,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x717f,
-			.name = "pcie-6259",
-			.n_adchan = 32,
-			.adbits = 16,
-			.ai_fifo_depth = 4095,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 800,
-			.n_aochan = 4,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_625x_ao,
-			.reg_type = ni_reg_625x,
-			.ao_unipolar = 0,
-			.ao_speed = 357,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70b6,
-			.name = "pci-6280",
-			.n_adchan = 16,
-			.adbits = 18,
-			.ai_fifo_depth = 2047,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 1600,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 8191,
-			.reg_type = ni_reg_628x,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 8,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70bd,
-			.name = "pci-6281",
-			.n_adchan = 16,
-			.adbits = 18,
-			.ai_fifo_depth = 2047,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 1600,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_628x_ao,
-			.reg_type = ni_reg_628x,
-			.ao_unipolar = 1,
-			.ao_speed = 357,
-			.num_p0_dio_channels = 8,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70bf,
-			.name = "pxi-6281",
-			.n_adchan = 16,
-			.adbits = 18,
-			.ai_fifo_depth = 2047,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 1600,
-			.n_aochan = 2,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_628x_ao,
-			.reg_type = ni_reg_628x,
-			.ao_unipolar = 1,
-			.ao_speed = 357,
-			.num_p0_dio_channels = 8,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70bc,
-			.name = "pci-6284",
-			.n_adchan = 32,
-			.adbits = 18,
-			.ai_fifo_depth = 2047,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 1600,
-			.n_aochan = 0,
-			.aobits = 0,
-			.ao_fifo_depth = 0,
-			.reg_type = ni_reg_628x,
-			.ao_unipolar = 0,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70ac,
-			.name = "pci-6289",
-			.n_adchan = 32,
-			.adbits = 18,
-			.ai_fifo_depth = 2047,
-			.gainlkup = ai_gain_628x,
-			.ai_speed = 1600,
-			.n_aochan = 4,
-			.aobits = 16,
-			.ao_fifo_depth = 8191,
-			.ao_range_table = &range_ni_M_628x_ao,
-			.reg_type = ni_reg_628x,
-			.ao_unipolar = 1,
-			.ao_speed = 357,
-			.num_p0_dio_channels = 32,
-			.caldac = {caldac_none},
-			.has_8255 = 0,
-		},
-	{
-			.device_id = 0x70C0,
-			.name = "pci-6143",
-			.n_adchan = 8,
-			.adbits = 16,
-			.ai_fifo_depth = 1024,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_6143,
-			.ai_speed = 4000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.reg_type = ni_reg_6143,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 0,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug, ad8804_debug},
-		},
-	{
-			.device_id = 0x710D,
-			.name = "pxi-6143",
-			.n_adchan = 8,
-			.adbits = 16,
-			.ai_fifo_depth = 1024,
-			.alwaysdither = 0,
-			.gainlkup = ai_gain_6143,
-			.ai_speed = 4000,
-			.n_aochan = 0,
-			.aobits = 0,
-			.reg_type = ni_reg_6143,
-			.ao_unipolar = 0,
-			.ao_fifo_depth = 0,
-			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug, ad8804_debug},
-		},
+	 .device_id = 0x2410,
+	 .name = "pci-6733",
+	 .n_adchan = 0,		/* no analog input */
+	 .n_aochan = 8,
+	 .aobits = 16,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 16384,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_6713,
+	 .caldac = {ad8804_debug, ad8804_debug},
+	 },
+	{
+	 .device_id = 0x2420,
+	 .name = "pxi-6733",
+	 .n_adchan = 0,		/* no analog input */
+	 .n_aochan = 8,
+	 .aobits = 16,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 16384,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_6713,
+	 .caldac = {ad8804_debug, ad8804_debug},
+	 },
+	{
+	 .device_id = 0x15b0,
+	 .name = "pxi-6071e",
+	 .n_adchan = 64,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 800,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x11b0,
+	 .name = "pxi-6070e",
+	 .n_adchan = 16,
+	 .adbits = 12,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 800,
+	 .n_aochan = 2,
+	 .aobits = 12,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 1000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x18c0,
+	 .name = "pxi-6052e",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_16,
+	 .ai_speed = 3000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_unipolar = 1,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_speed = 3000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {mb88341, mb88341, ad8522},
+	 },
+	{
+	 .device_id = 0x1580,
+	 .name = "pxi-6031e",
+	 .n_adchan = 64,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_14,
+	 .ai_speed = 10000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 2048,
+	 .ao_range_table = &range_ni_E_ao_ext,
+	 .ao_unipolar = 1,
+	 .ao_speed = 10000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {dac8800, dac8043, ad8522},
+	 },
+	{
+	 .device_id = 0x2890,
+	 .name = "pci-6036e",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 .alwaysdither = 1,
+	 .gainlkup = ai_gain_4,
+	 .ai_speed = 5000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 0,
+	 .ao_range_table = &range_bipolar10,
+	 .ao_unipolar = 0,
+	 .ao_speed = 100000,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70b0,
+	 .name = "pci-6220",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 512,
+	 /*      .FIXME = guess */
+	 .gainlkup = ai_gain_622x,
+	 .ai_speed = 4000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .num_p0_dio_channels = 8,
+	 .reg_type = ni_reg_622x,
+	 .ao_unipolar = 0,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70af,
+	 .name = "pci-6221",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_622x,
+	 .ai_speed = 4000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_622x_ao,
+	 .reg_type = ni_reg_622x,
+	 .ao_unipolar = 0,
+	 .ao_speed = 1200,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x71bc,
+	 .name = "pci-6221_37pin",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_622x,
+	 .ai_speed = 4000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_622x_ao,
+	 .reg_type = ni_reg_622x,
+	 .ao_unipolar = 0,
+	 .ao_speed = 1200,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70f2,
+	 .name = "pci-6224",
+	 .n_adchan = 32,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_622x,
+	 .ai_speed = 4000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .reg_type = ni_reg_622x,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70f3,
+	 .name = "pxi-6224",
+	 .n_adchan = 32,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_622x,
+	 .ai_speed = 4000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .reg_type = ni_reg_622x,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x716c,
+	 .name = "pci-6225",
+	 .n_adchan = 80,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_622x,
+	 .ai_speed = 4000,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_622x_ao,
+	 .reg_type = ni_reg_622x,
+	 .ao_unipolar = 0,
+	 .ao_speed = 1200,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70aa,
+	 .name = "pci-6229",
+	 .n_adchan = 32,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_622x,
+	 .ai_speed = 4000,
+	 .n_aochan = 4,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_622x_ao,
+	 .reg_type = ni_reg_622x,
+	 .ao_unipolar = 0,
+	 .ao_speed = 1200,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70b4,
+	 .name = "pci-6250",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 800,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .reg_type = ni_reg_625x,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70b8,
+	 .name = "pci-6251",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 800,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_625x_ao,
+	 .reg_type = ni_reg_625x,
+	 .ao_unipolar = 0,
+	 .ao_speed = 357,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x717d,
+	 .name = "pcie-6251",
+	 .n_adchan = 16,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 800,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_625x_ao,
+	 .reg_type = ni_reg_625x,
+	 .ao_unipolar = 0,
+	 .ao_speed = 357,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70b7,
+	 .name = "pci-6254",
+	 .n_adchan = 32,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 800,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .reg_type = ni_reg_625x,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70ab,
+	 .name = "pci-6259",
+	 .n_adchan = 32,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 800,
+	 .n_aochan = 4,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_625x_ao,
+	 .reg_type = ni_reg_625x,
+	 .ao_unipolar = 0,
+	 .ao_speed = 357,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x717f,
+	 .name = "pcie-6259",
+	 .n_adchan = 32,
+	 .adbits = 16,
+	 .ai_fifo_depth = 4095,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 800,
+	 .n_aochan = 4,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_625x_ao,
+	 .reg_type = ni_reg_625x,
+	 .ao_unipolar = 0,
+	 .ao_speed = 357,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70b6,
+	 .name = "pci-6280",
+	 .n_adchan = 16,
+	 .adbits = 18,
+	 .ai_fifo_depth = 2047,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 1600,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 8191,
+	 .reg_type = ni_reg_628x,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70bd,
+	 .name = "pci-6281",
+	 .n_adchan = 16,
+	 .adbits = 18,
+	 .ai_fifo_depth = 2047,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 1600,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_628x_ao,
+	 .reg_type = ni_reg_628x,
+	 .ao_unipolar = 1,
+	 .ao_speed = 357,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70bf,
+	 .name = "pxi-6281",
+	 .n_adchan = 16,
+	 .adbits = 18,
+	 .ai_fifo_depth = 2047,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 1600,
+	 .n_aochan = 2,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_628x_ao,
+	 .reg_type = ni_reg_628x,
+	 .ao_unipolar = 1,
+	 .ao_speed = 357,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70bc,
+	 .name = "pci-6284",
+	 .n_adchan = 32,
+	 .adbits = 18,
+	 .ai_fifo_depth = 2047,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 1600,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .ao_fifo_depth = 0,
+	 .reg_type = ni_reg_628x,
+	 .ao_unipolar = 0,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70ac,
+	 .name = "pci-6289",
+	 .n_adchan = 32,
+	 .adbits = 18,
+	 .ai_fifo_depth = 2047,
+	 .gainlkup = ai_gain_628x,
+	 .ai_speed = 1600,
+	 .n_aochan = 4,
+	 .aobits = 16,
+	 .ao_fifo_depth = 8191,
+	 .ao_range_table = &range_ni_M_628x_ao,
+	 .reg_type = ni_reg_628x,
+	 .ao_unipolar = 1,
+	 .ao_speed = 357,
+	 .num_p0_dio_channels = 32,
+	 .caldac = {caldac_none},
+	 .has_8255 = 0,
+	 },
+	{
+	 .device_id = 0x70C0,
+	 .name = "pci-6143",
+	 .n_adchan = 8,
+	 .adbits = 16,
+	 .ai_fifo_depth = 1024,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_6143,
+	 .ai_speed = 4000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .reg_type = ni_reg_6143,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug, ad8804_debug},
+	 },
+	{
+	 .device_id = 0x710D,
+	 .name = "pxi-6143",
+	 .n_adchan = 8,
+	 .adbits = 16,
+	 .ai_fifo_depth = 1024,
+	 .alwaysdither = 0,
+	 .gainlkup = ai_gain_6143,
+	 .ai_speed = 4000,
+	 .n_aochan = 0,
+	 .aobits = 0,
+	 .reg_type = ni_reg_6143,
+	 .ao_unipolar = 0,
+	 .ao_fifo_depth = 0,
+	 .num_p0_dio_channels = 8,
+	 .caldac = {ad8804_debug, ad8804_debug},
+	 },
 };
 
 #define n_pcimio_boards ((sizeof(ni_boards)/sizeof(ni_boards[0])))
 
-static int pcimio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcimio_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcimio_detach(struct comedi_device *dev);
 static struct comedi_driver driver_pcimio = {
 	.driver_name = DRV_NAME,
@@ -1219,8 +1223,7 @@ static struct comedi_driver driver_pcimi
 COMEDI_PCI_INITCLEANUP(driver_pcimio, ni_pci_table)
 
 struct ni_private {
-	NI_PRIVATE_COMMON
-};
+NI_PRIVATE_COMMON};
 #define devpriv ((struct ni_private *)dev->private)
 
 /* How we access registers */
@@ -1265,7 +1268,8 @@ static uint16_t e_series_win_in(struct c
 	return ret;
 }
 
-static void m_series_stc_writew(struct comedi_device *dev, uint16_t data, int reg)
+static void m_series_stc_writew(struct comedi_device *dev, uint16_t data,
+				int reg)
 {
 	unsigned offset;
 	switch (reg) {
@@ -1350,8 +1354,8 @@ static void m_series_stc_writew(struct c
 		break;
 	case DIO_Control_Register:
 		printk
-			("%s: FIXME: register 0x%x does not map cleanly on to m-series boards.\n",
-			__func__, reg);
+		    ("%s: FIXME: register 0x%x does not map cleanly on to m-series boards.\n",
+		     __func__, reg);
 		return;
 		break;
 	case G_Autoincrement_Register(0):
@@ -1412,7 +1416,7 @@ static void m_series_stc_writew(struct c
 		   and M_Offset_SCXI_Serial_Data_Out (8 bit) */
 	default:
 		printk("%s: bug! unhandled register=0x%x in switch.\n",
-			__func__, reg);
+		       __func__, reg);
 		BUG();
 		return;
 		break;
@@ -1447,7 +1451,7 @@ static uint16_t m_series_stc_readw(struc
 		break;
 	default:
 		printk("%s: bug! unhandled register=0x%x in switch.\n",
-			__func__, reg);
+		       __func__, reg);
 		BUG();
 		return 0;
 		break;
@@ -1455,7 +1459,8 @@ static uint16_t m_series_stc_readw(struc
 	return ni_readw(offset);
 }
 
-static void m_series_stc_writel(struct comedi_device *dev, uint32_t data, int reg)
+static void m_series_stc_writel(struct comedi_device *dev, uint32_t data,
+				int reg)
 {
 	unsigned offset;
 	switch (reg) {
@@ -1488,7 +1493,7 @@ static void m_series_stc_writel(struct c
 		break;
 	default:
 		printk("%s: bug! unhandled register=0x%x in switch.\n",
-			__func__, reg);
+		       __func__, reg);
 		BUG();
 		return;
 		break;
@@ -1514,7 +1519,7 @@ static uint32_t m_series_stc_readl(struc
 		break;
 	default:
 		printk("%s: bug! unhandled register=0x%x in switch.\n",
-			__func__, reg);
+		       __func__, reg);
 		BUG();
 		return 0;
 		break;
@@ -1530,16 +1535,19 @@ static uint32_t m_series_stc_readl(struc
 #include "ni_mio_common.c"
 
 static int pcimio_find_device(struct comedi_device *dev, int bus, int slot);
-static int pcimio_ai_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size);
-static int pcimio_ao_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size);
-static int pcimio_gpct0_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size);
-static int pcimio_gpct1_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size);
-static int pcimio_dio_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size);
+static int pcimio_ai_change(struct comedi_device *dev,
+			    struct comedi_subdevice *s, unsigned long new_size);
+static int pcimio_ao_change(struct comedi_device *dev,
+			    struct comedi_subdevice *s, unsigned long new_size);
+static int pcimio_gpct0_change(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned long new_size);
+static int pcimio_gpct1_change(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned long new_size);
+static int pcimio_dio_change(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     unsigned long new_size);
 
 static void m_series_init_eeprom_buffer(struct comedi_device *dev)
 {
@@ -1557,13 +1565,14 @@ static void m_series_init_eeprom_buffer(
 	old_iodwcr1_bits = readl(devpriv->mite->mite_io_addr + MITE_IODWCR_1);
 	writel(0x0, devpriv->mite->mite_io_addr + MITE_IODWBSR);
 	writel(((0x80 | window_size) | devpriv->mite->daq_phys_addr),
-		devpriv->mite->mite_io_addr + MITE_IODWBSR_1);
-	writel(0x1 | old_iodwcr1_bits, devpriv->mite->mite_io_addr + MITE_IODWCR_1);
+	       devpriv->mite->mite_io_addr + MITE_IODWBSR_1);
+	writel(0x1 | old_iodwcr1_bits,
+	       devpriv->mite->mite_io_addr + MITE_IODWCR_1);
 	writel(0xf, devpriv->mite->mite_io_addr + 0x30);
 
 	BUG_ON(serial_number_eeprom_length > sizeof(devpriv->serial_number));
 	for (i = 0; i < serial_number_eeprom_length; ++i) {
-		char *byte_ptr = (char*)&devpriv->serial_number + i;
+		char *byte_ptr = (char *)&devpriv->serial_number + i;
 		*byte_ptr = ni_readb(serial_number_eeprom_offset + i);
 	}
 	devpriv->serial_number = be32_to_cpu(devpriv->serial_number);
@@ -1593,7 +1602,7 @@ static void init_6143(struct comedi_devi
 	/*  Strobe Relay disable bit */
 	devpriv->ai_calib_source_enabled = 0;
 	ni_writew(devpriv->ai_calib_source | Calibration_Channel_6143_RelayOff,
-		Calibration_Channel_6143);
+		  Calibration_Channel_6143);
 	ni_writew(devpriv->ai_calib_source, Calibration_Channel_6143);
 }
 
@@ -1710,7 +1719,7 @@ static int pcimio_find_device(struct com
 			continue;
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number ||
-				slot != PCI_SLOT(mite->pcidev->devfn))
+			    slot != PCI_SLOT(mite->pcidev->devfn))
 				continue;
 		}
 
@@ -1728,8 +1737,8 @@ static int pcimio_find_device(struct com
 	return -EIO;
 }
 
-static int pcimio_ai_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size)
+static int pcimio_ai_change(struct comedi_device *dev,
+			    struct comedi_subdevice *s, unsigned long new_size)
 {
 	int ret;
 
@@ -1740,8 +1749,8 @@ static int pcimio_ai_change(struct comed
 	return 0;
 }
 
-static int pcimio_ao_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size)
+static int pcimio_ao_change(struct comedi_device *dev,
+			    struct comedi_subdevice *s, unsigned long new_size)
 {
 	int ret;
 
@@ -1752,8 +1761,9 @@ static int pcimio_ao_change(struct comed
 	return 0;
 }
 
-static int pcimio_gpct0_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size)
+static int pcimio_gpct0_change(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned long new_size)
 {
 	int ret;
 
@@ -1764,8 +1774,9 @@ static int pcimio_gpct0_change(struct co
 	return 0;
 }
 
-static int pcimio_gpct1_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size)
+static int pcimio_gpct1_change(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned long new_size)
 {
 	int ret;
 
@@ -1776,8 +1787,8 @@ static int pcimio_gpct1_change(struct co
 	return 0;
 }
 
-static int pcimio_dio_change(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long new_size)
+static int pcimio_dio_change(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned long new_size)
 {
 	int ret;
 
--- a/drivers/staging/comedi/drivers/ni_stc.h
+++ b/drivers/staging/comedi/drivers/ni_stc.h
@@ -339,8 +339,7 @@ static inline unsigned RTSI_Output_Bit(u
 		max_channel = 6;
 	}
 	if (channel > max_channel) {
-		printk("%s: bug, invalid RTSI_channel=%i\n", __func__,
-			channel);
+		printk("%s: bug, invalid RTSI_channel=%i\n", __func__, channel);
 		return 0;
 	}
 	return 1 << (base_bit_shift + channel);
@@ -369,7 +368,7 @@ enum ai_convert_output_selection {
 	AI_CONVERT_Output_Enable_High = 3
 };
 static unsigned AI_CONVERT_Output_Select(enum ai_convert_output_selection
-	selection)
+					 selection)
 {
 	return selection & 0x3;
 }
@@ -530,10 +529,11 @@ enum RTSI_Trig_B_Output_Bits {
 	RTSI_Sub_Selection_1_Bit = 0x8000	/*  not for m-series */
 };
 static inline unsigned RTSI_Trig_Output_Bits(unsigned rtsi_channel,
-	unsigned source)
+					     unsigned source)
 {
 	return (source & 0xf) << ((rtsi_channel % 4) * 4);
 };
+
 static inline unsigned RTSI_Trig_Output_Mask(unsigned rtsi_channel)
 {
 	return 0xf << ((rtsi_channel % 4) * 4);
@@ -541,7 +541,7 @@ static inline unsigned RTSI_Trig_Output_
 
 /* inverse to RTSI_Trig_Output_Bits() */
 static inline unsigned RTSI_Trig_Output_Source(unsigned rtsi_channel,
-	unsigned bits)
+					       unsigned bits)
 {
 	return (bits >> ((rtsi_channel % 4) * 4)) & 0xf;
 };
@@ -566,7 +566,7 @@ enum ao_update_output_selection {
 	AO_Update_Output_Enable_High = 3
 };
 static unsigned AO_UPDATE_Output_Select(enum ao_update_output_selection
-	selection)
+					selection)
 {
 	return selection & 0x3;
 }
@@ -730,13 +730,15 @@ static inline unsigned ni_stc_dma_channe
 	BUG();
 	return 0;
 }
+
 static inline unsigned GPCT_DMA_Select_Bits(unsigned gpct_index,
-	unsigned mite_channel)
+					    unsigned mite_channel)
 {
 	BUG_ON(gpct_index > 1);
 	return ni_stc_dma_channel_select_bitfield(mite_channel) << (4 *
-		gpct_index);
+								    gpct_index);
 }
+
 static inline unsigned GPCT_DMA_Select_Mask(unsigned gpct_index)
 {
 	BUG_ON(gpct_index > 1);
@@ -839,6 +841,7 @@ static inline unsigned int DACx_Direct_D
 {
 	return channel;
 }
+
 enum AO_Misc_611x_Bits {
 	CLEAR_WG = 1,
 };
@@ -870,10 +873,12 @@ static inline unsigned int CS5529_CONFIG
 {
 	return 1 << (18 + output);
 }
+
 static inline unsigned int CS5529_CONFIG_AOUT(int output)
 {
 	return 1 << (22 + output);
 }
+
 enum cs5529_command_bits {
 	CSCMD_POWER_SAVE = 0x1,
 	CSCMD_REGISTER_SELECT_MASK = 0xe,
@@ -898,8 +903,9 @@ enum cs5529_status_bits {
 */
 
 enum { ai_gain_16 =
-		0, ai_gain_8, ai_gain_14, ai_gain_4, ai_gain_611x, ai_gain_622x,
-		ai_gain_628x, ai_gain_6143 };
+	    0, ai_gain_8, ai_gain_14, ai_gain_4, ai_gain_611x, ai_gain_622x,
+	ai_gain_628x, ai_gain_6143
+};
 enum caldac_enum { caldac_none = 0, mb88341, dac8800, dac8043, ad8522,
 	ad8804, ad8842, ad8804_debug
 };
@@ -1064,18 +1070,22 @@ static inline int M_Offset_AO_Waveform_O
 {
 	return 0xc2 + 0x4 * channel;
 };
+
 static inline int M_Offset_AO_Config_Bank(int channel)
 {
 	return 0xc3 + 0x4 * channel;
 };
+
 static inline int M_Offset_DAC_Direct_Data(int channel)
 {
 	return 0xc0 + 0x4 * channel;
 }
+
 static inline int M_Offset_Gen_PWM(int channel)
 {
 	return 0x44 + 0x2 * channel;
 }
+
 static inline int M_Offset_Static_AI_Control(int i)
 {
 	int offset[] = {
@@ -1090,6 +1100,7 @@ static inline int M_Offset_Static_AI_Con
 	}
 	return offset[i];
 };
+
 static inline int M_Offset_AO_Reference_Attenuation(int channel)
 {
 	int offset[] = {
@@ -1104,11 +1115,12 @@ static inline int M_Offset_AO_Reference_
 	}
 	return offset[channel];
 };
+
 static inline unsigned M_Offset_PFI_Output_Select(unsigned n)
 {
 	if (n < 1 || n > NUM_PFI_OUTPUT_SELECT_REGS) {
 		printk("%s: invalid pfi output select register=%i\n",
-			__func__, n);
+		       __func__, n);
 		return M_Offset_PFI_Output_Select_1;
 	}
 	return M_Offset_PFI_Output_Select_1 + (n - 1) * 2;
@@ -1130,8 +1142,9 @@ static inline unsigned MSeries_AI_Config
 {
 	return channel & 0xf;
 }
+
 static inline unsigned MSeries_AI_Config_Bank_Bits(enum ni_reg_type reg_type,
-	unsigned channel)
+						   unsigned channel)
 {
 	unsigned bits = channel & 0x30;
 	if (reg_type == ni_reg_622x) {
@@ -1140,6 +1153,7 @@ static inline unsigned MSeries_AI_Config
 	}
 	return bits;
 }
+
 static inline unsigned MSeries_AI_Config_Gain_Bits(unsigned range)
 {
 	return (range & 0x7) << 9;
@@ -1159,11 +1173,11 @@ enum MSeries_Clock_and_Fout2_Bits {
 	MSeries_RTSI_10MHz_Bit = 0x80
 };
 static inline unsigned MSeries_PLL_In_Source_Select_RTSI_Bits(unsigned
-	RTSI_channel)
+							      RTSI_channel)
 {
 	if (RTSI_channel > 7) {
 		printk("%s: bug, invalid RTSI_channel=%i\n", __func__,
-			RTSI_channel);
+		       RTSI_channel);
 		return 0;
 	}
 	if (RTSI_channel == 7)
@@ -1183,18 +1197,18 @@ static inline unsigned MSeries_PLL_Divis
 {
 	static const unsigned max_divisor = 0x10;
 	if (divisor < 1 || divisor > max_divisor) {
-		printk("%s: bug, invalid divisor=%i\n", __func__,
-			divisor);
+		printk("%s: bug, invalid divisor=%i\n", __func__, divisor);
 		return 0;
 	}
 	return (divisor & 0xf) << 8;
 }
+
 static inline unsigned MSeries_PLL_Multiplier_Bits(unsigned multiplier)
 {
 	static const unsigned max_multiplier = 0x100;
 	if (multiplier < 1 || multiplier > max_multiplier) {
 		printk("%s: bug, invalid multiplier=%i\n", __func__,
-			multiplier);
+		       multiplier);
 		return 0;
 	}
 	return multiplier & 0xff;
@@ -1217,15 +1231,17 @@ enum MSeries_AI_Config_FIFO_Bypass_Bits 
 	MSeries_AI_Bypass_Config_FIFO_Bit = 0x80000000
 };
 static inline unsigned MSeries_AI_Bypass_Cal_Sel_Pos_Bits(int
-	calibration_source)
+							  calibration_source)
 {
 	return (calibration_source << 7) & MSeries_AI_Bypass_Cal_Sel_Pos_Mask;
 }
+
 static inline unsigned MSeries_AI_Bypass_Cal_Sel_Neg_Bits(int
-	calibration_source)
+							  calibration_source)
 {
 	return (calibration_source << 10) & MSeries_AI_Bypass_Cal_Sel_Pos_Mask;
 }
+
 static inline unsigned MSeries_AI_Bypass_Gain_Bits(int gain)
 {
 	return (gain << 18) & MSeries_AI_Bypass_Gain_Mask;
@@ -1260,15 +1276,16 @@ static inline unsigned MSeries_PFI_Outpu
 {
 	return 0x1f << (channel % 3) * 5;
 };
+
 static inline unsigned MSeries_PFI_Output_Select_Bits(unsigned channel,
-	unsigned source)
+						      unsigned source)
 {
 	return (source & 0x1f) << ((channel % 3) * 5);
 };
 
 /* inverse to MSeries_PFI_Output_Select_Bits */
 static inline unsigned MSeries_PFI_Output_Select_Source(unsigned channel,
-	unsigned bits)
+							unsigned bits)
 {
 	return (bits >> ((channel % 3) * 5)) & 0x1f;
 };
@@ -1285,11 +1302,12 @@ static inline unsigned MSeries_PFI_Filte
 {
 	return 0x3 << (channel * 2);
 }
+
 static inline unsigned MSeries_PFI_Filter_Select_Bits(unsigned channel,
-	unsigned filter)
+						      unsigned filter)
 {
 	return (filter << (channel *
-			2)) & MSeries_PFI_Filter_Select_Mask(channel);
+			   2)) & MSeries_PFI_Filter_Select_Mask(channel);
 }
 
 enum CDIO_DMA_Select_Bits {
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -51,7 +51,7 @@ TODO:
 #include "ni_tio_internal.h"
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
-	unsigned generic_clock_source);
+				       unsigned generic_clock_source);
 static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter);
 
 MODULE_AUTHOR("Comedi <comedi@comedi.org>");
@@ -59,7 +59,8 @@ MODULE_DESCRIPTION("Comedi support for N
 MODULE_LICENSE("GPL");
 
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum
-	ni_gpct_variant variant)
+								   ni_gpct_variant
+								   variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -77,8 +78,10 @@ static inline enum Gi_Counting_Mode_Reg_
 	}
 	return 0;
 }
+
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X2_Bit(enum
-	ni_gpct_variant variant)
+								ni_gpct_variant
+								variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -96,8 +99,10 @@ static inline enum Gi_Counting_Mode_Reg_
 	}
 	return 0;
 }
+
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X8_Bit(enum
-	ni_gpct_variant variant)
+								ni_gpct_variant
+								variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -115,8 +120,10 @@ static inline enum Gi_Counting_Mode_Reg_
 	}
 	return 0;
 }
+
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_HW_Arm_Select_Mask(enum
-	ni_gpct_variant variant)
+								   ni_gpct_variant
+								   variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -151,6 +158,7 @@ static inline unsigned NI_660x_RTSI_Cloc
 	BUG_ON(n > ni_660x_max_rtsi_channel);
 	return 0xb + n;
 }
+
 static const unsigned ni_660x_max_source_pin = 7;
 static inline unsigned NI_660x_Source_Pin_Clock(unsigned n)
 {
@@ -179,6 +187,7 @@ static inline unsigned NI_M_Series_PFI_C
 	else
 		return 0xb + n;
 }
+
 static const unsigned ni_m_series_max_rtsi_channel = 7;
 static inline unsigned NI_M_Series_RTSI_Clock(unsigned n)
 {
@@ -202,6 +211,7 @@ static inline unsigned NI_660x_Gate_Pin_
 	BUG_ON(n > ni_660x_max_gate_pin);
 	return 0x2 + n;
 }
+
 static inline unsigned NI_660x_RTSI_Gate_Select(unsigned n)
 {
 	BUG_ON(n > ni_660x_max_rtsi_channel);
@@ -225,6 +235,7 @@ static inline unsigned NI_M_Series_RTSI_
 		return 0x1b;
 	return 0xb + n;
 }
+
 static inline unsigned NI_M_Series_PFI_Gate_Select(unsigned n)
 {
 	BUG_ON(n > ni_m_series_max_pfi_channel);
@@ -237,6 +248,7 @@ static inline unsigned Gi_Source_Select_
 {
 	return (source << Gi_Source_Select_Shift) & Gi_Source_Select_Mask;
 }
+
 static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
 {
 	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
@@ -256,6 +268,7 @@ static inline unsigned NI_660x_Up_Down_P
 	BUG_ON(n > ni_660x_max_up_down_pin);
 	return 0x2 + n;
 }
+
 static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
 {
 	BUG_ON(n > ni_660x_max_rtsi_channel);
@@ -263,7 +276,7 @@ static inline unsigned NI_660x_RTSI_Seco
 }
 
 static const unsigned int counter_status_mask =
-	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
+    COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
 
 static int __init ni_tio_init_module(void)
 {
@@ -278,17 +291,26 @@ static void __exit ni_tio_cleanup_module
 
 module_exit(ni_tio_cleanup_module);
 
-struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device * dev,
-	void (*write_register) (struct ni_gpct *counter, unsigned bits,
-		enum ni_gpct_register reg),
-	unsigned (*read_register) (struct ni_gpct *counter,
-		enum ni_gpct_register reg), enum ni_gpct_variant variant,
-	unsigned num_counters)
+struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device *dev,
+						void (*write_register) (struct
+									ni_gpct
+									*
+									counter,
+									unsigned
+									bits,
+									enum
+									ni_gpct_register
+									reg),
+						unsigned (*read_register)
+						(struct ni_gpct * counter,
+						 enum ni_gpct_register reg),
+						enum ni_gpct_variant variant,
+						unsigned num_counters)
 {
 	unsigned i;
 
 	struct ni_gpct_device *counter_dev =
-		kzalloc(sizeof(struct ni_gpct_device), GFP_KERNEL);
+	    kzalloc(sizeof(struct ni_gpct_device), GFP_KERNEL);
 	if (counter_dev == NULL)
 		return NULL;
 	counter_dev->dev = dev;
@@ -298,7 +320,7 @@ struct ni_gpct_device *ni_gpct_device_co
 	spin_lock_init(&counter_dev->regs_lock);
 	BUG_ON(num_counters == 0);
 	counter_dev->counters =
-		kzalloc(sizeof(struct ni_gpct) * num_counters, GFP_KERNEL);
+	    kzalloc(sizeof(struct ni_gpct) * num_counters, GFP_KERNEL);
 	if (counter_dev->counters == NULL) {
 		kfree(counter_dev);
 		return NULL;
@@ -320,7 +342,7 @@ void ni_gpct_device_destroy(struct ni_gp
 }
 
 static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
-	*counter_dev)
+						*counter_dev)
 {
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
@@ -340,7 +362,7 @@ static int ni_tio_second_gate_registers_
 static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 {
 	write_register(counter, Gi_Reset_Bit(counter->counter_index),
-		NITIO_Gxx_Joint_Reset_Reg(counter->counter_index));
+		       NITIO_Gxx_Joint_Reset_Reg(counter->counter_index));
 }
 
 void ni_tio_init_counter(struct ni_gpct *counter)
@@ -350,49 +372,59 @@ void ni_tio_init_counter(struct ni_gpct 
 	ni_tio_reset_count_and_disarm(counter);
 	/* initialize counter registers */
 	counter_dev->regs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)] =
-		0x0;
+	    0x0;
 	write_register(counter,
-		counter_dev->regs[NITIO_Gi_Autoincrement_Reg(counter->
-				counter_index)],
-		NITIO_Gi_Autoincrement_Reg(counter->counter_index));
+		       counter_dev->
+		       regs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)],
+		       NITIO_Gi_Autoincrement_Reg(counter->counter_index));
 	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
-		~0, Gi_Synchronize_Gate_Bit);
+			~0, Gi_Synchronize_Gate_Bit);
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index), ~0,
-		0);
+			0);
 	counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] = 0x0;
 	write_register(counter,
-		counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)],
-		NITIO_Gi_LoadA_Reg(counter->counter_index));
+		       counter_dev->
+		       regs[NITIO_Gi_LoadA_Reg(counter->counter_index)],
+		       NITIO_Gi_LoadA_Reg(counter->counter_index));
 	counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] = 0x0;
 	write_register(counter,
-		counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)],
-		NITIO_Gi_LoadB_Reg(counter->counter_index));
+		       counter_dev->
+		       regs[NITIO_Gi_LoadB_Reg(counter->counter_index)],
+		       NITIO_Gi_LoadB_Reg(counter->counter_index));
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index), ~0, 0);
+			NITIO_Gi_Input_Select_Reg(counter->counter_index), ~0,
+			0);
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Counting_Mode_Reg(counter->counter_index), ~0,
-			0);
+				NITIO_Gi_Counting_Mode_Reg(counter->
+							   counter_index), ~0,
+				0);
 	}
 	if (ni_tio_second_gate_registers_present(counter_dev)) {
-		counter_dev->regs[NITIO_Gi_Second_Gate_Reg(counter->
-				counter_index)] = 0x0;
+		counter_dev->
+		    regs[NITIO_Gi_Second_Gate_Reg(counter->counter_index)] =
+		    0x0;
 		write_register(counter,
-			counter_dev->regs[NITIO_Gi_Second_Gate_Reg(counter->
-					counter_index)],
-			NITIO_Gi_Second_Gate_Reg(counter->counter_index));
+			       counter_dev->
+			       regs[NITIO_Gi_Second_Gate_Reg
+				    (counter->counter_index)],
+			       NITIO_Gi_Second_Gate_Reg(counter->
+							counter_index));
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_DMA_Config_Reg(counter->counter_index), ~0, 0x0);
+			NITIO_Gi_DMA_Config_Reg(counter->counter_index), ~0,
+			0x0);
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index), ~0, 0x0);
+			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
+			~0, 0x0);
 }
 
 static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 {
 	unsigned int status = 0;
 	const unsigned bits = read_register(counter,
-		NITIO_Gxx_Status_Reg(counter->counter_index));
+					    NITIO_Gxx_Status_Reg(counter->
+								 counter_index));
 	if (bits & Gi_Armed_Bit(counter->counter_index)) {
 		status |= COMEDI_COUNTER_ARMED;
 		if (bits & Gi_Counting_Bit(counter->counter_index))
@@ -405,16 +437,18 @@ static void ni_tio_set_sync_mode(struct 
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned counting_mode_reg =
-		NITIO_Gi_Counting_Mode_Reg(counter->counter_index);
+	    NITIO_Gi_Counting_Mode_Reg(counter->counter_index);
 	static const uint64_t min_normal_sync_period_ps = 25000;
 	const uint64_t clock_period_ps = ni_tio_clock_period_ps(counter,
-		ni_tio_generic_clock_src_select(counter));
+								ni_tio_generic_clock_src_select
+								(counter));
 
 	if (ni_tio_counting_mode_registers_present(counter_dev) == 0)
 		return;
 
 	switch (ni_tio_get_soft_copy(counter,
-			counting_mode_reg) & Gi_Counting_Mode_Mask) {
+				     counting_mode_reg) & Gi_Counting_Mode_Mask)
+	{
 	case Gi_Counting_Mode_QuadratureX1_Bits:
 	case Gi_Counting_Mode_QuadratureX2_Bits:
 	case Gi_Counting_Mode_QuadratureX4_Bits:
@@ -428,14 +462,14 @@ static void ni_tio_set_sync_mode(struct 
 	   using the alt sync bit in that case, but allow the caller to decide by using the
 	   force_alt_sync parameter. */
 	if (force_alt_sync ||
-		(clock_period_ps
-			&& clock_period_ps < min_normal_sync_period_ps)) {
+	    (clock_period_ps && clock_period_ps < min_normal_sync_period_ps)) {
 		ni_tio_set_bits(counter, counting_mode_reg,
-			Gi_Alternate_Sync_Bit(counter_dev->variant),
-			Gi_Alternate_Sync_Bit(counter_dev->variant));
+				Gi_Alternate_Sync_Bit(counter_dev->variant),
+				Gi_Alternate_Sync_Bit(counter_dev->variant));
 	} else {
 		ni_tio_set_bits(counter, counting_mode_reg,
-			Gi_Alternate_Sync_Bit(counter_dev->variant), 0x0);
+				Gi_Alternate_Sync_Bit(counter_dev->variant),
+				0x0);
 	}
 }
 
@@ -447,10 +481,10 @@ static int ni_tio_set_counter_mode(struc
 	unsigned input_select_bits = 0;
 	/* these bits map directly on to the mode register */
 	static const unsigned mode_reg_direct_mask =
-		NI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |
-		NI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |
-		NI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |
-		NI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;
+	    NI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |
+	    NI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |
+	    NI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |
+	    NI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;
 
 	mode_reg_mask = mode_reg_direct_mask | Gi_Reload_Source_Switching_Bit;
 	mode_reg_values = mode & mode_reg_direct_mask;
@@ -469,29 +503,31 @@ static int ni_tio_set_counter_mode(struc
 		break;
 	}
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
-		mode_reg_mask, mode_reg_values);
+			mode_reg_mask, mode_reg_values);
 
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		unsigned counting_mode_bits = 0;
 		counting_mode_bits |=
-			(mode >> NI_GPCT_COUNTING_MODE_SHIFT) &
-			Gi_Counting_Mode_Mask;
+		    (mode >> NI_GPCT_COUNTING_MODE_SHIFT) &
+		    Gi_Counting_Mode_Mask;
 		counting_mode_bits |=
-			((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT) <<
-			Gi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;
+		    ((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT) <<
+		     Gi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;
 		if (mode & NI_GPCT_INDEX_ENABLE_BIT) {
 			counting_mode_bits |= Gi_Index_Mode_Bit;
 		}
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Counting_Mode_Reg(counter->counter_index),
-			Gi_Counting_Mode_Mask | Gi_Index_Phase_Mask |
-			Gi_Index_Mode_Bit, counting_mode_bits);
+				NITIO_Gi_Counting_Mode_Reg(counter->
+							   counter_index),
+				Gi_Counting_Mode_Mask | Gi_Index_Phase_Mask |
+				Gi_Index_Mode_Bit, counting_mode_bits);
 		ni_tio_set_sync_mode(counter, 0);
 	}
 
 	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
-		Gi_Up_Down_Mask,
-		(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) << Gi_Up_Down_Shift);
+			Gi_Up_Down_Mask,
+			(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) <<
+			Gi_Up_Down_Shift);
 
 	if (mode & NI_GPCT_OR_GATE_BIT) {
 		input_select_bits |= Gi_Or_Gate_Bit;
@@ -500,9 +536,9 @@ static int ni_tio_set_counter_mode(struc
 		input_select_bits |= Gi_Output_Polarity_Bit;
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
-		Gi_Output_Polarity_Bit, input_select_bits);
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
+			Gi_Output_Polarity_Bit, input_select_bits);
 
 	return 0;
 }
@@ -535,32 +571,33 @@ int ni_tio_arm(struct ni_gpct *counter, 
 				if (start_trigger & NI_GPCT_ARM_UNKNOWN) {
 					/* pass-through the least significant bits so we can figure out what select later */
 					unsigned hw_arm_select_bits =
-						(start_trigger <<
-						Gi_HW_Arm_Select_Shift) &
-						Gi_HW_Arm_Select_Mask
-						(counter_dev->variant);
+					    (start_trigger <<
+					     Gi_HW_Arm_Select_Shift) &
+					    Gi_HW_Arm_Select_Mask
+					    (counter_dev->variant);
 
 					counting_mode_bits |=
-						Gi_HW_Arm_Enable_Bit |
-						hw_arm_select_bits;
+					    Gi_HW_Arm_Enable_Bit |
+					    hw_arm_select_bits;
 				} else {
 					return -EINVAL;
 				}
 				break;
 			}
 			ni_tio_set_bits(counter,
-				NITIO_Gi_Counting_Mode_Reg(counter->
-					counter_index),
-				Gi_HW_Arm_Select_Mask(counter_dev->
-					variant) | Gi_HW_Arm_Enable_Bit,
-				counting_mode_bits);
+					NITIO_Gi_Counting_Mode_Reg
+					(counter->counter_index),
+					Gi_HW_Arm_Select_Mask
+					(counter_dev->variant) |
+					Gi_HW_Arm_Enable_Bit,
+					counting_mode_bits);
 		}
 	} else {
 		command_transient_bits |= Gi_Disarm_Bit;
 	}
 	ni_tio_set_bits_transient(counter,
-		NITIO_Gi_Command_Reg(counter->counter_index), 0, 0,
-		command_transient_bits);
+				  NITIO_Gi_Command_Reg(counter->counter_index),
+				  0, 0, command_transient_bits);
 	return 0;
 }
 
@@ -569,7 +606,7 @@ static unsigned ni_660x_source_select_bi
 	unsigned ni_660x_clock;
 	unsigned i;
 	const unsigned clock_select_bits =
-		clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
+	    clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 
 	switch (clock_select_bits) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
@@ -604,7 +641,7 @@ static unsigned ni_660x_source_select_bi
 			break;
 		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
 			if (clock_select_bits ==
-				NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
+			    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
 				ni_660x_clock = NI_660x_Source_Pin_Clock(i);
 				break;
 			}
@@ -623,7 +660,7 @@ static unsigned ni_m_series_source_selec
 	unsigned ni_m_series_clock;
 	unsigned i;
 	const unsigned clock_select_bits =
-		clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
+	    clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	switch (clock_select_bits) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
 		ni_m_series_clock = NI_M_Series_Timebase_1_Clock;
@@ -670,7 +707,7 @@ static unsigned ni_m_series_source_selec
 		if (i <= ni_m_series_max_pfi_channel)
 			break;
 		printk("invalid clock source 0x%lx\n",
-			(unsigned long)clock_source);
+		       (unsigned long)clock_source);
 		BUG();
 		ni_m_series_clock = 0;
 		break;
@@ -679,11 +716,11 @@ static unsigned ni_m_series_source_selec
 };
 
 static void ni_tio_set_source_subselect(struct ni_gpct *counter,
-	unsigned int clock_source)
+					unsigned int clock_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 
 	if (counter_dev->variant != ni_gpct_variant_m_series)
 		return;
@@ -704,11 +741,12 @@ static void ni_tio_set_source_subselect(
 		break;
 	}
 	write_register(counter, counter_dev->regs[second_gate_reg],
-		second_gate_reg);
+		       second_gate_reg);
 }
 
 static int ni_tio_set_clock_src(struct ni_gpct *counter,
-	unsigned int clock_source, unsigned int period_ns)
+				unsigned int clock_source,
+				unsigned int period_ns)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned input_select_bits = 0;
@@ -722,7 +760,7 @@ static int ni_tio_set_clock_src(struct n
 	case ni_gpct_variant_e_series:
 	case ni_gpct_variant_m_series:
 		input_select_bits |=
-			ni_m_series_source_select_bits(clock_source);
+		    ni_m_series_source_select_bits(clock_source);
 		break;
 	default:
 		BUG();
@@ -731,13 +769,13 @@ static int ni_tio_set_clock_src(struct n
 	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
 		input_select_bits |= Gi_Source_Polarity_Bit;
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Source_Select_Mask | Gi_Source_Polarity_Bit,
-		input_select_bits);
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Source_Select_Mask | Gi_Source_Polarity_Bit,
+			input_select_bits);
 	ni_tio_set_source_subselect(counter, clock_source);
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		const unsigned prescaling_mode =
-			clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK;
+		    clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK;
 		unsigned counting_mode_bits = 0;
 
 		switch (prescaling_mode) {
@@ -745,21 +783,22 @@ static int ni_tio_set_clock_src(struct n
 			break;
 		case NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:
 			counting_mode_bits |=
-				Gi_Prescale_X2_Bit(counter_dev->variant);
+			    Gi_Prescale_X2_Bit(counter_dev->variant);
 			break;
 		case NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:
 			counting_mode_bits |=
-				Gi_Prescale_X8_Bit(counter_dev->variant);
+			    Gi_Prescale_X8_Bit(counter_dev->variant);
 			break;
 		default:
 			return -EINVAL;
 			break;
 		}
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Counting_Mode_Reg(counter->counter_index),
-			Gi_Prescale_X2_Bit(counter_dev->
-				variant) | Gi_Prescale_X8_Bit(counter_dev->
-				variant), counting_mode_bits);
+				NITIO_Gi_Counting_Mode_Reg(counter->
+							   counter_index),
+				Gi_Prescale_X2_Bit(counter_dev->variant) |
+				Gi_Prescale_X8_Bit(counter_dev->variant),
+				counting_mode_bits);
 	}
 	counter->clock_period_ps = pico_per_nano * period_ns;
 	ni_tio_set_sync_mode(counter, 0);
@@ -770,12 +809,15 @@ static unsigned ni_tio_clock_src_modifie
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned counting_mode_bits = ni_tio_get_soft_copy(counter,
-		NITIO_Gi_Counting_Mode_Reg(counter->counter_index));
+								 NITIO_Gi_Counting_Mode_Reg
+								 (counter->
+								  counter_index));
 	unsigned bits = 0;
 
 	if (ni_tio_get_soft_copy(counter,
-			NITIO_Gi_Input_Select_Reg(counter->
-				counter_index)) & Gi_Source_Polarity_Bit)
+				 NITIO_Gi_Input_Select_Reg
+				 (counter->counter_index)) &
+	    Gi_Source_Polarity_Bit)
 		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
 	if (counting_mode_bits & Gi_Prescale_X2_Bit(counter_dev->variant))
 		bits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;
@@ -788,13 +830,14 @@ static unsigned ni_m_series_clock_src_se
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 	unsigned clock_source = 0;
 	unsigned i;
 	const unsigned input_select = (ni_tio_get_soft_copy(counter,
-			NITIO_Gi_Input_Select_Reg(counter->
-				counter_index)) & Gi_Source_Select_Mask) >>
-		Gi_Source_Select_Shift;
+							    NITIO_Gi_Input_Select_Reg
+							    (counter->counter_index))
+				       & Gi_Source_Select_Mask) >>
+	    Gi_Source_Select_Shift;
 
 	switch (input_select) {
 	case NI_M_Series_Timebase_1_Clock:
@@ -804,10 +847,10 @@ static unsigned ni_m_series_clock_src_se
 		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
 		break;
 	case NI_M_Series_Timebase_3_Clock:
-		if (counter_dev->
-			regs[second_gate_reg] & Gi_Source_Subselect_Bit)
+		if (counter_dev->regs[second_gate_reg] &
+		    Gi_Source_Subselect_Bit)
 			clock_source =
-				NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
+			    NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
 		else
 			clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
 		break;
@@ -815,8 +858,8 @@ static unsigned ni_m_series_clock_src_se
 		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
 		break;
 	case NI_M_Series_Next_Gate_Clock:
-		if (counter_dev->
-			regs[second_gate_reg] & Gi_Source_Subselect_Bit)
+		if (counter_dev->regs[second_gate_reg] &
+		    Gi_Source_Subselect_Bit)
 			clock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;
 		else
 			clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
@@ -856,9 +899,10 @@ static unsigned ni_660x_clock_src_select
 	unsigned clock_source = 0;
 	unsigned i;
 	const unsigned input_select = (ni_tio_get_soft_copy(counter,
-			NITIO_Gi_Input_Select_Reg(counter->
-				counter_index)) & Gi_Source_Select_Mask) >>
-		Gi_Source_Select_Shift;
+							    NITIO_Gi_Input_Select_Reg
+							    (counter->counter_index))
+				       & Gi_Source_Select_Mask) >>
+	    Gi_Source_Select_Shift;
 
 	switch (input_select) {
 	case NI_660x_Timebase_1_Clock:
@@ -894,7 +938,7 @@ static unsigned ni_660x_clock_src_select
 		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
 			if (input_select == NI_660x_Source_Pin_Clock(i)) {
 				clock_source =
-					NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
+				    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
 				break;
 			}
 		}
@@ -925,7 +969,7 @@ static unsigned ni_tio_generic_clock_src
 }
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
-	unsigned generic_clock_source)
+				       unsigned generic_clock_source)
 {
 	uint64_t clock_period_ps;
 
@@ -965,7 +1009,8 @@ static uint64_t ni_tio_clock_period_ps(c
 }
 
 static void ni_tio_get_clock_src(struct ni_gpct *counter,
-	unsigned int *clock_source, unsigned int *period_ns)
+				 unsigned int *clock_source,
+				 unsigned int *period_ns)
 {
 	static const unsigned pico_per_nano = 1000;
 	uint64_t temp64;
@@ -976,7 +1021,7 @@ static void ni_tio_get_clock_src(struct 
 }
 
 static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
-	unsigned int gate_source)
+					    unsigned int gate_source)
 {
 	const unsigned mode_mask = Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask;
 	unsigned mode_values = 0;
@@ -990,10 +1035,11 @@ static void ni_tio_set_first_gate_modifi
 		mode_values |= Gi_Level_Gating_Bits;
 	}
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
-		mode_mask, mode_values);
+			mode_mask, mode_values);
 }
 
-static int ni_660x_set_first_gate(struct ni_gpct *counter, unsigned int gate_source)
+static int ni_660x_set_first_gate(struct ni_gpct *counter,
+				  unsigned int gate_source)
 {
 	const unsigned selected_gate = CR_CHAN(gate_source);
 	/* bits of selected_gate that may be meaningful to input select register */
@@ -1015,7 +1061,7 @@ static int ni_660x_set_first_gate(struct
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				ni_660x_gate_select =
-					selected_gate & selected_gate_mask;
+				    selected_gate & selected_gate_mask;
 				break;
 			}
 		}
@@ -1024,7 +1070,7 @@ static int ni_660x_set_first_gate(struct
 		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
 			if (selected_gate == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {
 				ni_660x_gate_select =
-					selected_gate & selected_gate_mask;
+				    selected_gate & selected_gate_mask;
 				break;
 			}
 		}
@@ -1034,13 +1080,14 @@ static int ni_660x_set_first_gate(struct
 		break;
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Gate_Select_Mask, Gi_Gate_Select_Bits(ni_660x_gate_select));
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Gate_Select_Mask,
+			Gi_Gate_Select_Bits(ni_660x_gate_select));
 	return 0;
 }
 
 static int ni_m_series_set_first_gate(struct ni_gpct *counter,
-	unsigned int gate_source)
+				      unsigned int gate_source)
 {
 	const unsigned selected_gate = CR_CHAN(gate_source);
 	/* bits of selected_gate that may be meaningful to input select register */
@@ -1063,7 +1110,7 @@ static int ni_m_series_set_first_gate(st
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
 			if (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				ni_m_series_gate_select =
-					selected_gate & selected_gate_mask;
+				    selected_gate & selected_gate_mask;
 				break;
 			}
 		}
@@ -1072,7 +1119,7 @@ static int ni_m_series_set_first_gate(st
 		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
 			if (selected_gate == NI_GPCT_PFI_GATE_SELECT(i)) {
 				ni_m_series_gate_select =
-					selected_gate & selected_gate_mask;
+				    selected_gate & selected_gate_mask;
 				break;
 			}
 		}
@@ -1082,18 +1129,18 @@ static int ni_m_series_set_first_gate(st
 		break;
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Gate_Select_Mask,
-		Gi_Gate_Select_Bits(ni_m_series_gate_select));
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Gate_Select_Mask,
+			Gi_Gate_Select_Bits(ni_m_series_gate_select));
 	return 0;
 }
 
 static int ni_660x_set_second_gate(struct ni_gpct *counter,
-	unsigned int gate_source)
+				   unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 	const unsigned selected_second_gate = CR_CHAN(gate_source);
 	/* bits of second_gate that may be meaningful to second gate register */
 	static const unsigned selected_second_gate_mask = 0x1f;
@@ -1107,18 +1154,18 @@ static int ni_660x_set_second_gate(struc
 	case NI_GPCT_NEXT_OUT_GATE_SELECT:
 	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
 		ni_660x_second_gate_select =
-			selected_second_gate & selected_second_gate_mask;
+		    selected_second_gate & selected_second_gate_mask;
 		break;
 	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
 		ni_660x_second_gate_select =
-			NI_660x_Next_SRC_Second_Gate_Select;
+		    NI_660x_Next_SRC_Second_Gate_Select;
 		break;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (selected_second_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				ni_660x_second_gate_select =
-					selected_second_gate &
-					selected_second_gate_mask;
+				    selected_second_gate &
+				    selected_second_gate_mask;
 				break;
 			}
 		}
@@ -1126,10 +1173,10 @@ static int ni_660x_set_second_gate(struc
 			break;
 		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
 			if (selected_second_gate ==
-				NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {
+			    NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {
 				ni_660x_second_gate_select =
-					selected_second_gate &
-					selected_second_gate_mask;
+				    selected_second_gate &
+				    selected_second_gate_mask;
 				break;
 			}
 		}
@@ -1141,18 +1188,18 @@ static int ni_660x_set_second_gate(struc
 	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
 	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
 	counter_dev->regs[second_gate_reg] |=
-		Gi_Second_Gate_Select_Bits(ni_660x_second_gate_select);
+	    Gi_Second_Gate_Select_Bits(ni_660x_second_gate_select);
 	write_register(counter, counter_dev->regs[second_gate_reg],
-		second_gate_reg);
+		       second_gate_reg);
 	return 0;
 }
 
 static int ni_m_series_set_second_gate(struct ni_gpct *counter,
-	unsigned int gate_source)
+				       unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 	const unsigned selected_second_gate = CR_CHAN(gate_source);
 	/* bits of second_gate that may be meaningful to second gate register */
 	static const unsigned selected_second_gate_mask = 0x1f;
@@ -1163,31 +1210,33 @@ static int ni_m_series_set_second_gate(s
 	switch (selected_second_gate) {
 	default:
 		ni_m_series_second_gate_select =
-			selected_second_gate & selected_second_gate_mask;
+		    selected_second_gate & selected_second_gate_mask;
 		break;
 	};
 	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
 	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
 	counter_dev->regs[second_gate_reg] |=
-		Gi_Second_Gate_Select_Bits(ni_m_series_second_gate_select);
+	    Gi_Second_Gate_Select_Bits(ni_m_series_second_gate_select);
 	write_register(counter, counter_dev->regs[second_gate_reg],
-		second_gate_reg);
+		       second_gate_reg);
 	return 0;
 }
 
 int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
-	unsigned int gate_source)
+			unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 
 	switch (gate_index) {
 	case 0:
 		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
 			ni_tio_set_bits(counter,
-				NITIO_Gi_Mode_Reg(counter->counter_index),
-				Gi_Gating_Mode_Mask, Gi_Gating_Disabled_Bits);
+					NITIO_Gi_Mode_Reg(counter->
+							  counter_index),
+					Gi_Gating_Mode_Mask,
+					Gi_Gating_Disabled_Bits);
 			return 0;
 		}
 		ni_tio_set_first_gate_modifiers(counter, gate_source);
@@ -1209,23 +1258,23 @@ int ni_tio_set_gate_src(struct ni_gpct *
 			return -EINVAL;
 		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
 			counter_dev->regs[second_gate_reg] &=
-				~Gi_Second_Gate_Mode_Bit;
+			    ~Gi_Second_Gate_Mode_Bit;
 			write_register(counter,
-				counter_dev->regs[second_gate_reg],
-				second_gate_reg);
+				       counter_dev->regs[second_gate_reg],
+				       second_gate_reg);
 			return 0;
 		}
 		if (gate_source & CR_INVERT) {
 			counter_dev->regs[second_gate_reg] |=
-				Gi_Second_Gate_Polarity_Bit;
+			    Gi_Second_Gate_Polarity_Bit;
 		} else {
 			counter_dev->regs[second_gate_reg] &=
-				~Gi_Second_Gate_Polarity_Bit;
+			    ~Gi_Second_Gate_Polarity_Bit;
 		}
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_m_series:
 			return ni_m_series_set_second_gate(counter,
-				gate_source);
+							   gate_source);
 			break;
 		case ni_gpct_variant_660x:
 			return ni_660x_set_second_gate(counter, gate_source);
@@ -1243,7 +1292,7 @@ int ni_tio_set_gate_src(struct ni_gpct *
 }
 
 static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
-	unsigned int source)
+				unsigned int source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 
@@ -1280,7 +1329,7 @@ static int ni_tio_set_other_src(struct n
 }
 
 static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
-	ni_660x_gate_select)
+							  ni_660x_gate_select)
 {
 	unsigned i;
 
@@ -1311,7 +1360,7 @@ static unsigned ni_660x_first_gate_to_ge
 			break;
 		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
 			if (ni_660x_gate_select ==
-				NI_660x_Gate_Pin_Gate_Select(i)) {
+			    NI_660x_Gate_Pin_Gate_Select(i)) {
 				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
 				break;
 			}
@@ -1325,7 +1374,7 @@ static unsigned ni_660x_first_gate_to_ge
 };
 
 static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
-	ni_m_series_gate_select)
+							      ni_m_series_gate_select)
 {
 	unsigned i;
 
@@ -1357,7 +1406,7 @@ static unsigned ni_m_series_first_gate_t
 	default:
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
 			if (ni_m_series_gate_select ==
-				NI_M_Series_RTSI_Gate_Select(i)) {
+			    NI_M_Series_RTSI_Gate_Select(i)) {
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 				break;
 			}
@@ -1366,7 +1415,7 @@ static unsigned ni_m_series_first_gate_t
 			break;
 		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
 			if (ni_m_series_gate_select ==
-				NI_M_Series_PFI_Gate_Select(i)) {
+			    NI_M_Series_PFI_Gate_Select(i)) {
 				return NI_GPCT_PFI_GATE_SELECT(i);
 				break;
 			}
@@ -1380,7 +1429,7 @@ static unsigned ni_m_series_first_gate_t
 };
 
 static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
-	ni_660x_gate_select)
+							   ni_660x_gate_select)
 {
 	unsigned i;
 
@@ -1406,7 +1455,7 @@ static unsigned ni_660x_second_gate_to_g
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (ni_660x_gate_select ==
-				NI_660x_RTSI_Second_Gate_Select(i)) {
+			    NI_660x_RTSI_Second_Gate_Select(i)) {
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 				break;
 			}
@@ -1415,7 +1464,7 @@ static unsigned ni_660x_second_gate_to_g
 			break;
 		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
 			if (ni_660x_gate_select ==
-				NI_660x_Up_Down_Pin_Second_Gate_Select(i)) {
+			    NI_660x_Up_Down_Pin_Second_Gate_Select(i)) {
 				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
 				break;
 			}
@@ -1429,7 +1478,7 @@ static unsigned ni_660x_second_gate_to_g
 };
 
 static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
-	ni_m_series_gate_select)
+							       ni_m_series_gate_select)
 {
 	/*FIXME: the second gate sources for the m series are undocumented, so we just return
 	 * the raw bits for now. */
@@ -1442,39 +1491,41 @@ static unsigned ni_m_series_second_gate_
 };
 
 static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
-	unsigned int *gate_source)
+			       unsigned int *gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned mode_bits = ni_tio_get_soft_copy(counter,
-		NITIO_Gi_Mode_Reg(counter->counter_index));
+							NITIO_Gi_Mode_Reg
+							(counter->
+							 counter_index));
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 	unsigned gate_select_bits;
 
 	switch (gate_index) {
 	case 0:
 		if ((mode_bits & Gi_Gating_Mode_Mask) ==
-			Gi_Gating_Disabled_Bits) {
+		    Gi_Gating_Disabled_Bits) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
 		} else {
 			gate_select_bits =
-				(ni_tio_get_soft_copy(counter,
-					NITIO_Gi_Input_Select_Reg(counter->
-						counter_index)) &
-				Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
+			    (ni_tio_get_soft_copy(counter,
+						  NITIO_Gi_Input_Select_Reg
+						  (counter->counter_index)) &
+			     Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
 		}
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 			*gate_source =
-				ni_m_series_first_gate_to_generic_gate_source
-				(gate_select_bits);
+			    ni_m_series_first_gate_to_generic_gate_source
+			    (gate_select_bits);
 			break;
 		case ni_gpct_variant_660x:
 			*gate_source =
-				ni_660x_first_gate_to_generic_gate_source
-				(gate_select_bits);
+			    ni_660x_first_gate_to_generic_gate_source
+			    (gate_select_bits);
 			break;
 		default:
 			BUG();
@@ -1489,36 +1540,35 @@ static int ni_tio_get_gate_src(struct ni
 		break;
 	case 1:
 		if ((mode_bits & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits
-			|| (counter_dev->
-				regs[second_gate_reg] & Gi_Second_Gate_Mode_Bit)
-			== 0) {
+		    || (counter_dev->regs[second_gate_reg] &
+			Gi_Second_Gate_Mode_Bit)
+		    == 0) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
 		} else {
 			gate_select_bits =
-				(counter_dev->
-				regs[second_gate_reg] &
-				Gi_Second_Gate_Select_Mask) >>
-				Gi_Second_Gate_Select_Shift;
+			    (counter_dev->regs[second_gate_reg] &
+			     Gi_Second_Gate_Select_Mask) >>
+			    Gi_Second_Gate_Select_Shift;
 		}
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 			*gate_source =
-				ni_m_series_second_gate_to_generic_gate_source
-				(gate_select_bits);
+			    ni_m_series_second_gate_to_generic_gate_source
+			    (gate_select_bits);
 			break;
 		case ni_gpct_variant_660x:
 			*gate_source =
-				ni_660x_second_gate_to_generic_gate_source
-				(gate_select_bits);
+			    ni_660x_second_gate_to_generic_gate_source
+			    (gate_select_bits);
 			break;
 		default:
 			BUG();
 			break;
 		}
-		if (counter_dev->
-			regs[second_gate_reg] & Gi_Second_Gate_Polarity_Bit) {
+		if (counter_dev->regs[second_gate_reg] &
+		    Gi_Second_Gate_Polarity_Bit) {
 			*gate_source |= CR_INVERT;
 		}
 		/* second gate can't have edge/level mode set independently */
@@ -1534,7 +1584,7 @@ static int ni_tio_get_gate_src(struct ni
 }
 
 int ni_tio_insn_config(struct ni_gpct *counter,
-	struct comedi_insn *insn, unsigned int *data)
+		       struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
@@ -1578,7 +1628,8 @@ int ni_tio_insn_config(struct ni_gpct *c
 	return -EINVAL;
 }
 
-int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned int * data)
+int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
+		 unsigned int *data)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
@@ -1591,26 +1642,27 @@ int ni_tio_rinsn(struct ni_gpct *counter
 	switch (channel) {
 	case 0:
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Command_Reg(counter->counter_index),
-			Gi_Save_Trace_Bit, 0);
+				NITIO_Gi_Command_Reg(counter->counter_index),
+				Gi_Save_Trace_Bit, 0);
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Command_Reg(counter->counter_index),
-			Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
+				NITIO_Gi_Command_Reg(counter->counter_index),
+				Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
 		/* The count doesn't get latched until the next clock edge, so it is possible the count
 		   may change (once) while we are reading.  Since the read of the SW_Save_Reg isn't
 		   atomic (apparently even when it's a 32 bit register according to 660x docs),
 		   we need to read twice and make sure the reading hasn't changed.  If it has,
 		   a third read will be correct since the count value will definitely have latched by then. */
 		first_read =
-			read_register(counter,
-			NITIO_Gi_SW_Save_Reg(counter->counter_index));
+		    read_register(counter,
+				  NITIO_Gi_SW_Save_Reg(counter->counter_index));
 		second_read =
-			read_register(counter,
-			NITIO_Gi_SW_Save_Reg(counter->counter_index));
+		    read_register(counter,
+				  NITIO_Gi_SW_Save_Reg(counter->counter_index));
 		if (first_read != second_read)
 			correct_read =
-				read_register(counter,
-				NITIO_Gi_SW_Save_Reg(counter->counter_index));
+			    read_register(counter,
+					  NITIO_Gi_SW_Save_Reg(counter->
+							       counter_index));
 		else
 			correct_read = first_read;
 		data[0] = correct_read;
@@ -1618,13 +1670,13 @@ int ni_tio_rinsn(struct ni_gpct *counter
 		break;
 	case 1:
 		data[0] =
-			counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->
-				counter_index)];
+		    counter_dev->
+		    regs[NITIO_Gi_LoadA_Reg(counter->counter_index)];
 		break;
 	case 2:
 		data[0] =
-			counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->
-				counter_index)];
+		    counter_dev->
+		    regs[NITIO_Gi_LoadB_Reg(counter->counter_index)];
 		break;
 	};
 	return 0;
@@ -1633,7 +1685,8 @@ int ni_tio_rinsn(struct ni_gpct *counter
 static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 {
 	const unsigned bits = read_register(counter,
-		NITIO_Gxx_Status_Reg(counter->counter_index));
+					    NITIO_Gxx_Status_Reg(counter->
+								 counter_index));
 
 	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index)) {
 		return NITIO_Gi_LoadB_Reg(counter->counter_index);
@@ -1642,7 +1695,8 @@ static unsigned ni_tio_next_load_registe
 	}
 }
 
-int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned int * data)
+int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
+		 unsigned int *data)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
@@ -1657,22 +1711,23 @@ int ni_tio_winsn(struct ni_gpct *counter
 		load_reg = ni_tio_next_load_register(counter);
 		write_register(counter, data[0], load_reg);
 		ni_tio_set_bits_transient(counter,
-			NITIO_Gi_Command_Reg(counter->counter_index), 0, 0,
-			Gi_Load_Bit);
+					  NITIO_Gi_Command_Reg(counter->
+							       counter_index),
+					  0, 0, Gi_Load_Bit);
 		/* restore state of load reg to whatever the user set last set it to */
 		write_register(counter, counter_dev->regs[load_reg], load_reg);
 		break;
 	case 1:
 		counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] =
-			data[0];
+		    data[0];
 		write_register(counter, data[0],
-			NITIO_Gi_LoadA_Reg(counter->counter_index));
+			       NITIO_Gi_LoadA_Reg(counter->counter_index));
 		break;
 	case 2:
 		counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] =
-			data[0];
+		    data[0];
 		write_register(counter, data[0],
-			NITIO_Gi_LoadB_Reg(counter->counter_index));
+			       NITIO_Gi_LoadB_Reg(counter->counter_index));
 		break;
 	default:
 		return -EINVAL;
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -56,7 +56,7 @@ MODULE_DESCRIPTION("Comedi command suppo
 MODULE_LICENSE("GPL");
 
 static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
-	short read_not_write)
+				 short read_not_write)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned input_select_bits = 0;
@@ -69,9 +69,9 @@ static void ni_tio_configure_dma(struct 
 		}
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,
-		input_select_bits);
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,
+			input_select_bits);
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
 		break;
@@ -88,16 +88,18 @@ static void ni_tio_configure_dma(struct 
 				gi_dma_config_bits |= Gi_DMA_Write_Bit;
 			}
 			ni_tio_set_bits(counter,
-				NITIO_Gi_DMA_Config_Reg(counter->counter_index),
-				Gi_DMA_Enable_Bit | Gi_DMA_Int_Bit |
-				Gi_DMA_Write_Bit, gi_dma_config_bits);
+					NITIO_Gi_DMA_Config_Reg(counter->
+								counter_index),
+					Gi_DMA_Enable_Bit | Gi_DMA_Int_Bit |
+					Gi_DMA_Write_Bit, gi_dma_config_bits);
 		}
 		break;
 	}
 }
 
-static int ni_tio_input_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+static int ni_tio_input_inttrig(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned int trignum)
 {
 	unsigned long flags;
 	int retval = 0;
@@ -143,7 +145,7 @@ static int ni_tio_input_cmd(struct ni_gp
 		break;
 	}
 	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
-		Gi_Save_Trace_Bit, 0);
+			Gi_Save_Trace_Bit, 0);
 	ni_tio_configure_dma(counter, 1, 1);
 	switch (cmd->start_src) {
 	case TRIG_NOW:
@@ -169,7 +171,8 @@ static int ni_tio_input_cmd(struct ni_gp
 	return retval;
 }
 
-static int ni_tio_output_cmd(struct ni_gpct *counter, struct comedi_async *async)
+static int ni_tio_output_cmd(struct ni_gpct *counter,
+			     struct comedi_async *async)
 {
 	printk("ni_tio: output commands not yet implemented.\n");
 	return -ENOTSUPP;
@@ -200,9 +203,12 @@ static int ni_tio_cmd_setup(struct ni_gp
 	}
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
-			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index),
-			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index));
+				NITIO_Gi_Interrupt_Enable_Reg(counter->
+							      counter_index),
+				Gi_Gate_Interrupt_Enable_Bit(counter->
+							     counter_index),
+				Gi_Gate_Interrupt_Enable_Bit(counter->
+							     counter_index));
 	}
 	return retval;
 }
@@ -216,7 +222,7 @@ int ni_tio_cmd(struct ni_gpct *counter, 
 	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan == NULL) {
 		printk
-			("ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
+		    ("ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
 		retval = -EIO;
 	} else {
 		retval = ni_tio_cmd_setup(counter, async);
@@ -232,7 +238,7 @@ int ni_tio_cmd(struct ni_gpct *counter, 
 	return retval;
 }
 
-int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd * cmd)
+int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -275,15 +281,15 @@ int ni_tio_cmdtest(struct ni_gpct *count
 	/* step 2: make sure trigger sources are unique... */
 
 	if (cmd->start_src != TRIG_NOW &&
-		cmd->start_src != TRIG_INT &&
-		cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_OTHER)
+	    cmd->start_src != TRIG_INT &&
+	    cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_OTHER)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_OTHER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_OTHER)
 		err++;
 	if (cmd->convert_src != TRIG_OTHER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_NONE)
 		err++;
@@ -350,8 +356,9 @@ int ni_tio_cancel(struct ni_gpct *counte
 	ni_tio_configure_dma(counter, 0, 0);
 
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
-		Gi_Gate_Interrupt_Enable_Bit(counter->counter_index), 0x0);
+			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
+			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index),
+			0x0);
 	return 0;
 }
 
@@ -372,8 +379,8 @@ static int should_ack_gate(struct ni_gpc
 		spin_lock_irqsave(&counter->lock, flags);
 		{
 			if (counter->mite_chan == NULL ||
-				counter->mite_chan->dir != COMEDI_INPUT ||
-				(mite_done(counter->mite_chan))) {
+			    counter->mite_chan->dir != COMEDI_INPUT ||
+			    (mite_done(counter->mite_chan))) {
 				retval = 1;
 			}
 		}
@@ -384,12 +391,17 @@ static int should_ack_gate(struct ni_gpc
 }
 
 void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
-	int *tc_error, int *perm_stale_data, int *stale_data)
+				    int *tc_error, int *perm_stale_data,
+				    int *stale_data)
 {
 	const unsigned short gxx_status = read_register(counter,
-		NITIO_Gxx_Status_Reg(counter->counter_index));
+							NITIO_Gxx_Status_Reg
+							(counter->
+							 counter_index));
 	const unsigned short gi_status = read_register(counter,
-		NITIO_Gi_Status_Reg(counter->counter_index));
+						       NITIO_Gi_Status_Reg
+						       (counter->
+							counter_index));
 	unsigned ack = 0;
 
 	if (gate_error)
@@ -407,7 +419,7 @@ void ni_tio_acknowledge_and_confirm(stru
 			/*660x don't support automatic acknowledgement of gate interrupt via dma read/write
 			   and report bogus gate errors */
 			if (counter->counter_dev->variant !=
-				ni_gpct_variant_660x) {
+			    ni_gpct_variant_660x) {
 				*gate_error = 1;
 			}
 		}
@@ -426,28 +438,30 @@ void ni_tio_acknowledge_and_confirm(stru
 	}
 	if (ack)
 		write_register(counter, ack,
-			NITIO_Gi_Interrupt_Acknowledge_Reg(counter->
-				counter_index));
-	if (ni_tio_get_soft_copy(counter,
-			NITIO_Gi_Mode_Reg(counter->
-				counter_index)) & Gi_Loading_On_Gate_Bit) {
+			       NITIO_Gi_Interrupt_Acknowledge_Reg
+			       (counter->counter_index));
+	if (ni_tio_get_soft_copy
+	    (counter,
+	     NITIO_Gi_Mode_Reg(counter->counter_index)) &
+	    Gi_Loading_On_Gate_Bit) {
 		if (gxx_status & Gi_Stale_Data_Bit(counter->counter_index)) {
 			if (stale_data)
 				*stale_data = 1;
 		}
 		if (read_register(counter,
-				NITIO_Gxx_Joint_Status2_Reg(counter->
-					counter_index)) &
-			Gi_Permanent_Stale_Bit(counter->counter_index)) {
+				  NITIO_Gxx_Joint_Status2_Reg
+				  (counter->counter_index)) &
+		    Gi_Permanent_Stale_Bit(counter->counter_index)) {
 			printk("%s: Gi_Permanent_Stale_Data detected.\n",
-				__FUNCTION__);
+			       __FUNCTION__);
 			if (perm_stale_data)
 				*perm_stale_data = 1;
 		}
 	}
 }
 
-void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice * s)
+void ni_tio_handle_interrupt(struct ni_gpct *counter,
+			     struct comedi_subdevice *s)
 {
 	unsigned gpct_mite_status;
 	unsigned long flags;
@@ -456,7 +470,7 @@ void ni_tio_handle_interrupt(struct ni_g
 	int perm_stale_data;
 
 	ni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,
-		&perm_stale_data, NULL);
+				       &perm_stale_data, NULL);
 	if (gate_error) {
 		printk("%s: Gi_Gate_Error detected.\n", __FUNCTION__);
 		s->async->events |= COMEDI_CB_OVERFLOW;
@@ -468,8 +482,9 @@ void ni_tio_handle_interrupt(struct ni_g
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
 		if (read_register(counter,
-				NITIO_Gi_DMA_Status_Reg(counter->
-					counter_index)) & Gi_DRQ_Error_Bit) {
+				  NITIO_Gi_DMA_Status_Reg
+				  (counter->counter_index)) & Gi_DRQ_Error_Bit)
+		{
 			printk("%s: Gi_DRQ_Error detected.\n", __FUNCTION__);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
@@ -485,15 +500,15 @@ void ni_tio_handle_interrupt(struct ni_g
 	gpct_mite_status = mite_get_status(counter->mite_chan);
 	if (gpct_mite_status & CHSR_LINKC) {
 		writel(CHOR_CLRLC,
-			counter->mite_chan->mite->mite_io_addr +
-			MITE_CHOR(counter->mite_chan->channel));
+		       counter->mite_chan->mite->mite_io_addr +
+		       MITE_CHOR(counter->mite_chan->channel));
 	}
 	mite_sync_input_dma(counter->mite_chan, s->async);
 	spin_unlock_irqrestore(&counter->lock, flags);
 }
 
 void ni_tio_set_mite_channel(struct ni_gpct *counter,
-	struct mite_channel *mite_chan)
+			     struct mite_channel *mite_chan)
 {
 	unsigned long flags;
 
--- a/drivers/staging/comedi/drivers/ni_tio.h
+++ b/drivers/staging/comedi/drivers/ni_tio.h
@@ -120,10 +120,10 @@ struct ni_gpct {
 
 struct ni_gpct_device {
 	struct comedi_device *dev;
-	void (*write_register) (struct ni_gpct *counter, unsigned bits,
-		enum ni_gpct_register reg);
-	unsigned (*read_register) (struct ni_gpct *counter,
-		enum ni_gpct_register reg);
+	void (*write_register) (struct ni_gpct * counter, unsigned bits,
+				enum ni_gpct_register reg);
+	unsigned (*read_register) (struct ni_gpct * counter,
+				   enum ni_gpct_register reg);
 	enum ni_gpct_variant variant;
 	struct ni_gpct *counters;
 	unsigned num_counters;
@@ -131,31 +131,42 @@ struct ni_gpct_device {
 	spinlock_t regs_lock;
 };
 
-extern struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device * dev,
-	void (*write_register) (struct ni_gpct *counter, unsigned bits,
-		enum ni_gpct_register reg),
-	unsigned (*read_register) (struct ni_gpct *counter,
-		enum ni_gpct_register reg), enum ni_gpct_variant variant,
-	unsigned num_counters);
+extern struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device
+						       *dev,
+						       void (*write_register)
+						       (struct ni_gpct *
+							counter, unsigned bits,
+							enum ni_gpct_register
+							reg),
+						       unsigned (*read_register)
+						       (struct ni_gpct *
+							counter,
+							enum ni_gpct_register
+							reg),
+						       enum ni_gpct_variant
+						       variant,
+						       unsigned num_counters);
 extern void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev);
 extern void ni_tio_init_counter(struct ni_gpct *counter);
 extern int ni_tio_rinsn(struct ni_gpct *counter,
-	struct comedi_insn *insn, unsigned int *data);
+			struct comedi_insn *insn, unsigned int *data);
 extern int ni_tio_insn_config(struct ni_gpct *counter,
-	struct comedi_insn *insn, unsigned int *data);
+			      struct comedi_insn *insn, unsigned int *data);
 extern int ni_tio_winsn(struct ni_gpct *counter,
-	struct comedi_insn *insn, unsigned int *data);
+			struct comedi_insn *insn, unsigned int *data);
 extern int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async);
-extern int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd * cmd);
+extern int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd);
 extern int ni_tio_cancel(struct ni_gpct *counter);
 extern void ni_tio_handle_interrupt(struct ni_gpct *counter,
-	struct comedi_subdevice *s);
+				    struct comedi_subdevice *s);
 extern void ni_tio_set_mite_channel(struct ni_gpct *counter,
-	struct mite_channel *mite_chan);
+				    struct mite_channel *mite_chan);
 extern void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
-	int *gate_error, int *tc_error, int *perm_stale_data, int *stale_data);
+					   int *gate_error, int *tc_error,
+					   int *perm_stale_data,
+					   int *stale_data);
 
-static inline struct ni_gpct *subdev_to_counter(struct comedi_subdevice * s)
+static inline struct ni_gpct *subdev_to_counter(struct comedi_subdevice *s)
 {
 	return s->private;
 }
--- a/drivers/staging/comedi/drivers/ni_tio_internal.h
+++ b/drivers/staging/comedi/drivers/ni_tio_internal.h
@@ -27,7 +27,7 @@
 #include "ni_tio.h"
 
 static inline enum ni_gpct_register NITIO_Gi_Autoincrement_Reg(unsigned
-	counter_index)
+							       counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -72,7 +72,7 @@ static inline enum ni_gpct_register NITI
 }
 
 static inline enum ni_gpct_register NITIO_Gi_Counting_Mode_Reg(unsigned
-	counter_index)
+							       counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -95,7 +95,7 @@ static inline enum ni_gpct_register NITI
 }
 
 static inline enum ni_gpct_register NITIO_Gi_Input_Select_Reg(unsigned
-	counter_index)
+							      counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -118,7 +118,7 @@ static inline enum ni_gpct_register NITI
 }
 
 static inline enum ni_gpct_register NITIO_Gxx_Joint_Reset_Reg(unsigned
-	counter_index)
+							      counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -137,7 +137,7 @@ static inline enum ni_gpct_register NITI
 }
 
 static inline enum ni_gpct_register NITIO_Gxx_Joint_Status1_Reg(unsigned
-	counter_index)
+								counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -156,7 +156,7 @@ static inline enum ni_gpct_register NITI
 }
 
 static inline enum ni_gpct_register NITIO_Gxx_Joint_Status2_Reg(unsigned
-	counter_index)
+								counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -363,7 +363,7 @@ static inline enum ni_gpct_register NITI
 }
 
 static inline enum ni_gpct_register NITIO_Gi_Interrupt_Acknowledge_Reg(int
-	counter_index)
+								       counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -408,7 +408,7 @@ static inline enum ni_gpct_register NITI
 }
 
 static inline enum ni_gpct_register NITIO_Gi_Interrupt_Enable_Reg(int
-	counter_index)
+								  counter_index)
 {
 	switch (counter_index) {
 	case 0:
@@ -542,7 +542,7 @@ enum Gi_Second_Gate_Bits {
 static inline unsigned Gi_Second_Gate_Select_Bits(unsigned second_gate_select)
 {
 	return (second_gate_select << Gi_Second_Gate_Select_Shift) &
-		Gi_Second_Gate_Select_Mask;
+	    Gi_Second_Gate_Select_Mask;
 }
 
 enum Gxx_Status_Bits {
@@ -569,31 +569,36 @@ static inline enum Gxx_Status_Bits Gi_Co
 		return G1_Counting_Bit;
 	return G0_Counting_Bit;
 }
+
 static inline enum Gxx_Status_Bits Gi_Armed_Bit(unsigned counter_index)
 {
 	if (counter_index % 2)
 		return G1_Armed_Bit;
 	return G0_Armed_Bit;
 }
+
 static inline enum Gxx_Status_Bits Gi_Next_Load_Source_Bit(unsigned
-	counter_index)
+							   counter_index)
 {
 	if (counter_index % 2)
 		return G1_Next_Load_Source_Bit;
 	return G0_Next_Load_Source_Bit;
 }
+
 static inline enum Gxx_Status_Bits Gi_Stale_Data_Bit(unsigned counter_index)
 {
 	if (counter_index % 2)
 		return G1_Stale_Data_Bit;
 	return G0_Stale_Data_Bit;
 }
+
 static inline enum Gxx_Status_Bits Gi_TC_Error_Bit(unsigned counter_index)
 {
 	if (counter_index % 2)
 		return G1_TC_Error_Bit;
 	return G0_TC_Error_Bit;
 }
+
 static inline enum Gxx_Status_Bits Gi_Gate_Error_Bit(unsigned counter_index)
 {
 	if (counter_index % 2)
@@ -616,7 +621,7 @@ enum Gxx_Joint_Status2_Bits {
 	G1_Permanent_Stale_Bit = 0x8000
 };
 static inline enum Gxx_Joint_Status2_Bits Gi_Permanent_Stale_Bit(unsigned
-	counter_index)
+								 counter_index)
 {
 	if (counter_index % 2)
 		return G1_Permanent_Stale_Bit;
@@ -649,6 +654,7 @@ static inline unsigned Gi_Gate_Error_Con
 		return G1_Gate_Error_Confirm_Bit;
 	return G0_Gate_Error_Confirm_Bit;
 }
+
 static inline unsigned Gi_TC_Error_Confirm_Bit(unsigned counter_index)
 {
 	if (counter_index % 2)
@@ -689,21 +695,22 @@ static inline unsigned Gi_Gate_Interrupt
 }
 
 static inline void write_register(struct ni_gpct *counter, unsigned bits,
-	enum ni_gpct_register reg)
+				  enum ni_gpct_register reg)
 {
 	BUG_ON(reg >= NITIO_Num_Registers);
 	counter->counter_dev->write_register(counter, bits, reg);
 }
 
 static inline unsigned read_register(struct ni_gpct *counter,
-	enum ni_gpct_register reg)
+				     enum ni_gpct_register reg)
 {
 	BUG_ON(reg >= NITIO_Num_Registers);
 	return counter->counter_dev->read_register(counter, reg);
 }
 
-static inline int ni_tio_counting_mode_registers_present(
-	const struct ni_gpct_device *counter_dev)
+static inline int ni_tio_counting_mode_registers_present(const struct
+							 ni_gpct_device
+							 *counter_dev)
 {
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
@@ -721,8 +728,10 @@ static inline int ni_tio_counting_mode_r
 }
 
 static inline void ni_tio_set_bits_transient(struct ni_gpct *counter,
-	enum ni_gpct_register register_index, unsigned bit_mask,
-	unsigned bit_values, unsigned transient_bit_values)
+					     enum ni_gpct_register
+					     register_index, unsigned bit_mask,
+					     unsigned bit_values,
+					     unsigned transient_bit_values)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned long flags;
@@ -732,8 +741,8 @@ static inline void ni_tio_set_bits_trans
 	counter_dev->regs[register_index] &= ~bit_mask;
 	counter_dev->regs[register_index] |= (bit_values & bit_mask);
 	write_register(counter,
-		counter_dev->regs[register_index] | transient_bit_values,
-		register_index);
+		       counter_dev->regs[register_index] | transient_bit_values,
+		       register_index);
 	mmiowb();
 	spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
 }
@@ -742,11 +751,11 @@ static inline void ni_tio_set_bits_trans
 twiddled in interrupt context, or whose software copy may be read in interrupt context.
 */
 static inline void ni_tio_set_bits(struct ni_gpct *counter,
-	enum ni_gpct_register register_index, unsigned bit_mask,
-	unsigned bit_values)
+				   enum ni_gpct_register register_index,
+				   unsigned bit_mask, unsigned bit_values)
 {
 	ni_tio_set_bits_transient(counter, register_index, bit_mask, bit_values,
-		0x0);
+				  0x0);
 }
 
 /* ni_tio_get_soft_copy( ) is for safely reading the software copy of a register
@@ -754,7 +763,8 @@ whose bits might be modified in interrup
 might need to be read in interrupt context.
 */
 static inline unsigned ni_tio_get_soft_copy(const struct ni_gpct *counter,
-	enum ni_gpct_register register_index)
+					    enum ni_gpct_register
+					    register_index)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned long flags;
@@ -769,6 +779,6 @@ static inline unsigned ni_tio_get_soft_c
 
 int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger);
 int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
-	unsigned int gate_source);
+			unsigned int gate_source);
 
 #endif /* _COMEDI_NI_TIO_INTERNAL_H */
--- a/drivers/staging/comedi/drivers/pcl711.c
+++ b/drivers/staging/comedi/drivers/pcl711.c
@@ -89,39 +89,41 @@ supported.
 #define PCL711_DO_HI 14
 
 static const struct comedi_lrange range_pcl711b_ai = { 5, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			BIP_RANGE(0.3125)
-	}
+							   BIP_RANGE(5),
+							   BIP_RANGE(2.5),
+							   BIP_RANGE(1.25),
+							   BIP_RANGE(0.625),
+							   BIP_RANGE(0.3125)
+							   }
 };
+
 static const struct comedi_lrange range_acl8112hg_ai = { 12, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.005),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01),
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01)
-	}
+							      BIP_RANGE(5),
+							      BIP_RANGE(0.5),
+							      BIP_RANGE(0.05),
+							      BIP_RANGE(0.005),
+							      UNI_RANGE(10),
+							      UNI_RANGE(1),
+							      UNI_RANGE(0.1),
+							      UNI_RANGE(0.01),
+							      BIP_RANGE(10),
+							      BIP_RANGE(1),
+							      BIP_RANGE(0.1),
+							      BIP_RANGE(0.01)
+							      }
 };
+
 static const struct comedi_lrange range_acl8112dg_ai = { 9, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-			BIP_RANGE(10)
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     BIP_RANGE(0.625),
+							     UNI_RANGE(10),
+							     UNI_RANGE(5),
+							     UNI_RANGE(2.5),
+							     UNI_RANGE(1.25),
+							     BIP_RANGE(10)
+							     }
 };
 
 /*
@@ -146,7 +148,6 @@ struct pcl711_board {
 	const struct comedi_lrange *ai_range_type;
 };
 
-
 static const struct pcl711_board boardtypes[] = {
 	{"pcl711", 0, 0, 0, 5, 8, 1, 0, &range_bipolar5},
 	{"pcl711b", 1, 0, 0, 5, 8, 1, 7, &range_pcl711b_ai},
@@ -157,7 +158,8 @@ static const struct pcl711_board boardty
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl711_board))
 #define this_board ((const struct pcl711_board *)dev->board_ptr)
 
-static int pcl711_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl711_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl711_detach(struct comedi_device *dev);
 static struct comedi_driver driver_pcl711 = {
 	.driver_name = "pcl711",
@@ -183,7 +185,6 @@ struct pcl711_private {
 	unsigned int divisor2;
 };
 
-
 #define devpriv ((struct pcl711_private *)dev->private)
 
 static irqreturn_t pcl711_interrupt(int irq, void *d)
@@ -246,7 +247,7 @@ static void pcl711_set_changain(struct c
 }
 
 static int pcl711_ai_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int hi, lo;
@@ -275,7 +276,7 @@ static int pcl711_ai_insn(struct comedi_
 		printk("comedi%d: pcl711: A/D timeout\n", dev->minor);
 		return -ETIME;
 
-	      ok:
+ok:
 		lo = inb(dev->iobase + PCL711_AD_LO);
 
 		data[n] = ((hi & 0xf) << 8) | lo;
@@ -284,8 +285,8 @@ static int pcl711_ai_insn(struct comedi_
 	return n;
 }
 
-static int pcl711_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pcl711_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int tmp;
 	int err = 0;
@@ -322,7 +323,7 @@ static int pcl711_ai_cmdtest(struct come
 	/* step 2 */
 
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -374,8 +375,10 @@ static int pcl711_ai_cmdtest(struct come
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&devpriv->divisor1, &devpriv->divisor2,
-			&cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);
+					       &devpriv->divisor1,
+					       &devpriv->divisor2,
+					       &cmd->scan_begin_arg,
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -405,7 +408,8 @@ static int pcl711_ai_cmd(struct comedi_d
 		 */
 
 		i8253_cascade_ns_to_timer(i8253_osc_base, &timer1, &timer2,
-			&cmd->scan_begin_arg, TRIG_ROUND_NEAREST);
+					  &cmd->scan_begin_arg,
+					  TRIG_ROUND_NEAREST);
 
 		outb(0x74, dev->iobase + PCL711_CTRCTL);
 		outb(timer1 & 0xff, dev->iobase + PCL711_CTR1);
@@ -433,16 +437,16 @@ static int pcl711_ai_cmd(struct comedi_d
    analog output
 */
 static int pcl711_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
 
 	for (n = 0; n < insn->n; n++) {
 		outb((data[n] & 0xff),
-			dev->iobase + (chan ? PCL711_DA1_LO : PCL711_DA0_LO));
+		     dev->iobase + (chan ? PCL711_DA1_LO : PCL711_DA0_LO));
 		outb((data[n] >> 8),
-			dev->iobase + (chan ? PCL711_DA1_HI : PCL711_DA0_HI));
+		     dev->iobase + (chan ? PCL711_DA1_HI : PCL711_DA0_HI));
 
 		devpriv->ao_readback[chan] = data[n];
 	}
@@ -450,8 +454,9 @@ static int pcl711_ao_insn(struct comedi_
 	return n;
 }
 
-static int pcl711_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl711_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -465,21 +470,23 @@ static int pcl711_ao_insn_read(struct co
 }
 
 /* Digital port read - Untested on 8112 */
-static int pcl711_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl711_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
 
 	data[1] = inb(dev->iobase + PCL711_DI_LO) |
-		(inb(dev->iobase + PCL711_DI_HI) << 8);
+	    (inb(dev->iobase + PCL711_DI_HI) << 8);
 
 	return 2;
 }
 
 /* Digital port write - Untested on 8112 */
-static int pcl711_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl711_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
--- a/drivers/staging/comedi/drivers/pcl724.c
+++ b/drivers/staging/comedi/drivers/pcl724.c
@@ -56,7 +56,8 @@ See the source for configuration details
 
 /* #define PCL724_IRQ   1  no IRQ support now */
 
-static int pcl724_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl724_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl724_detach(struct comedi_device *dev);
 
 struct pcl724_board {
@@ -70,7 +71,6 @@ struct pcl724_board {
 	char is_pet48;
 };
 
-
 static const struct pcl724_board boardtypes[] = {
 	{"pcl724", 24, 1, 0x00fc, PCL724_SIZE, 0, 0,},
 	{"pcl722", 144, 6, 0x00fc, PCL722_SIZE, 1, 0,},
@@ -108,7 +108,7 @@ static int subdev_8255_cb(int dir, int p
 }
 
 static int subdev_8255mapped_cb(int dir, int port, int data,
-	unsigned long iobase)
+				unsigned long iobase)
 {
 	int movport = SIZE_8255 * (iobase >> 12);
 
@@ -136,10 +136,10 @@ static int pcl724_attach(struct comedi_d
 	iobase = it->options[0];
 	iorange = this_board->io_range;
 	if ((this_board->can_have96) && ((it->options[1] == 1)
-			|| (it->options[1] == 96)))
+					 || (it->options[1] == 96)))
 		iorange = PCL722_96_SIZE;	/*  PCL-724 in 96 DIO configuration */
 	printk("comedi%d: pcl724: board=%s, 0x%03lx ", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 	if (!request_region(iobase, iorange, "pcl724")) {
 		printk("I/O port conflict\n");
 		return -EIO;
@@ -156,14 +156,15 @@ static int pcl724_attach(struct comedi_d
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
 				printk
-					(", IRQ %u is out of allowed range, DISABLING IT",
-					irq);
+				    (", IRQ %u is out of allowed range, DISABLING IT",
+				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (request_irq(irq, interrupt_pcl724, 0, "pcl724", dev)) {
+				if (request_irq
+				    (irq, interrupt_pcl724, 0, "pcl724", dev)) {
 					printk
-						(", unable to allocate IRQ %u, DISABLING IT",
-						irq);
+					    (", unable to allocate IRQ %u, DISABLING IT",
+					     irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
 					printk(", irq=%u", irq);
@@ -179,7 +180,7 @@ static int pcl724_attach(struct comedi_d
 
 	n_subdevices = this_board->numofports;
 	if ((this_board->can_have96) && ((it->options[1] == 1)
-			|| (it->options[1] == 96)))
+					 || (it->options[1] == 96)))
 		n_subdevices = 4;	/*  PCL-724 in 96 DIO configuration */
 
 	ret = alloc_subdevices(dev, n_subdevices);
@@ -189,12 +190,14 @@ static int pcl724_attach(struct comedi_d
 	for (i = 0; i < dev->n_subdevices; i++) {
 		if (this_board->is_pet48) {
 			subdev_8255_init(dev, dev->subdevices + i,
-				subdev_8255mapped_cb,
-				(unsigned long)(dev->iobase + i * 0x1000));
+					 subdev_8255mapped_cb,
+					 (unsigned long)(dev->iobase +
+							 i * 0x1000));
 		} else
 			subdev_8255_init(dev, dev->subdevices + i,
-				subdev_8255_cb,
-				(unsigned long)(dev->iobase + SIZE_8255 * i));
+					 subdev_8255_cb,
+					 (unsigned long)(dev->iobase +
+							 SIZE_8255 * i));
 	};
 
 	return 0;
--- a/drivers/staging/comedi/drivers/pcl725.c
+++ b/drivers/staging/comedi/drivers/pcl725.c
@@ -20,7 +20,8 @@ Devices: [Advantech] PCL-725 (pcl725)
 #define PCL725_DO 0
 #define PCL725_DI 1
 
-static int pcl725_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl725_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl725_detach(struct comedi_device *dev);
 static struct comedi_driver driver_pcl725 = {
 	.driver_name = "pcl725",
@@ -32,7 +33,7 @@ static struct comedi_driver driver_pcl72
 COMEDI_INITCLEANUP(driver_pcl725);
 
 static int pcl725_do_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -49,7 +50,7 @@ static int pcl725_do_insn(struct comedi_
 }
 
 static int pcl725_di_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
--- a/drivers/staging/comedi/drivers/pcl726.c
+++ b/drivers/staging/comedi/drivers/pcl726.c
@@ -111,7 +111,8 @@ static const struct comedi_lrange *const
 	&range_4_20mA, &range_0_20mA
 };
 
-static int pcl726_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl726_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl726_detach(struct comedi_device *dev);
 
 struct pcl726_board {
@@ -129,23 +130,22 @@ struct pcl726_board {
 	const struct comedi_lrange *const *range_type_list;	/*  list of supported ranges */
 };
 
-
 static const struct pcl726_board boardtypes[] = {
 	{"pcl726", 6, 6, 0x0000, PCL726_SIZE, 1,
-			PCL726_DI_HI, PCL726_DI_LO, PCL726_DO_HI, PCL726_DO_LO,
-		&rangelist_726[0],},
+	 PCL726_DI_HI, PCL726_DI_LO, PCL726_DO_HI, PCL726_DO_LO,
+	 &rangelist_726[0],},
 	{"pcl727", 12, 4, 0x0000, PCL727_SIZE, 1,
-			PCL727_DI_HI, PCL727_DI_LO, PCL727_DO_HI, PCL727_DO_LO,
-		&rangelist_727[0],},
+	 PCL727_DI_HI, PCL727_DI_LO, PCL727_DO_HI, PCL727_DO_LO,
+	 &rangelist_727[0],},
 	{"pcl728", 2, 6, 0x0000, PCL728_SIZE, 0,
-			0, 0, 0, 0,
-		&rangelist_728[0],},
+	 0, 0, 0, 0,
+	 &rangelist_728[0],},
 	{"acl6126", 6, 5, 0x96e8, PCL726_SIZE, 1,
-			PCL726_DI_HI, PCL726_DI_LO, PCL726_DO_HI, PCL726_DO_LO,
-		&rangelist_726[0],},
+	 PCL726_DI_HI, PCL726_DI_LO, PCL726_DO_HI, PCL726_DO_LO,
+	 &rangelist_726[0],},
 	{"acl6128", 2, 6, 0x0000, PCL728_SIZE, 0,
-			0, 0, 0, 0,
-		&rangelist_728[0],},
+	 0, 0, 0, 0,
+	 &rangelist_728[0],},
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl726_board))
@@ -173,7 +173,7 @@ struct pcl726_private {
 #define devpriv ((struct pcl726_private *)dev->private)
 
 static int pcl726_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int hi, lo;
 	int n;
@@ -197,8 +197,9 @@ static int pcl726_ao_insn(struct comedi_
 	return n;
 }
 
-static int pcl726_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl726_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int n;
@@ -209,20 +210,22 @@ static int pcl726_ao_insn_read(struct co
 	return n;
 }
 
-static int pcl726_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl726_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
 
 	data[1] = inb(dev->iobase + this_board->di_lo) |
-		(inb(dev->iobase + this_board->di_hi) << 8);
+	    (inb(dev->iobase + this_board->di_hi) << 8);
 
 	return 2;
 }
 
-static int pcl726_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl726_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -254,7 +257,7 @@ static int pcl726_attach(struct comedi_d
 	iobase = it->options[0];
 	iorange = this_board->io_range;
 	printk("comedi%d: pcl726: board=%s, 0x%03lx ", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 	if (!request_region(iobase, iorange, "pcl726")) {
 		printk("I/O port conflict\n");
 		return -EIO;
@@ -281,15 +284,15 @@ static int pcl726_attach(struct comedi_d
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & boardtypes[board].IRQbits) == 0) {
 				printk
-					(", IRQ %d is out of allowed range, DISABLING IT",
-					irq);
+				    (", IRQ %d is out of allowed range, DISABLING IT",
+				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
 				if (request_irq(irq, interrupt_pcl818, 0,
 						"pcl726", dev)) {
 					printk
-						(", unable to allocate IRQ %d, DISABLING IT",
-						irq);
+					    (", unable to allocate IRQ %d, DISABLING IT",
+					     irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
 					printk(", irq=%d", irq);
@@ -322,12 +325,14 @@ static int pcl726_attach(struct comedi_d
 
 		j = it->options[2 + 1];
 		if ((j < 0) || (j >= this_board->num_of_ranges)) {
-			printk("Invalid range for channel %d! Must be 0<=%d<%d\n", i, j, this_board->num_of_ranges - 1);
+			printk
+			    ("Invalid range for channel %d! Must be 0<=%d<%d\n",
+			     i, j, this_board->num_of_ranges - 1);
 			j = 0;
 		}
 		devpriv->rangelist[i] = this_board->range_type_list[j];
 		if (devpriv->rangelist[i]->range[0].min ==
-			-devpriv->rangelist[i]->range[0].max)
+		    -devpriv->rangelist[i]->range[0].max)
 			devpriv->bipolar[i] = 1;	/* bipolar range */
 	}
 
--- a/drivers/staging/comedi/drivers/pcl730.c
+++ b/drivers/staging/comedi/drivers/pcl730.c
@@ -26,7 +26,8 @@ The ACL-7130 card have an 8254 timer/cou
 #define PCL730_DIO_LO	2	/* TTL Digital I/O low byte (D0-D7) */
 #define PCL730_DIO_HI	3	/* TTL Digital I/O high byte (D8-D15) */
 
-static int pcl730_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl730_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl730_detach(struct comedi_device *dev);
 
 struct pcl730_board {
@@ -35,7 +36,6 @@ struct pcl730_board {
 	unsigned int io_range;	/*  len of I/O space */
 };
 
-
 static const struct pcl730_board boardtypes[] = {
 	{"pcl730", PCL730_SIZE,},
 	{"iso730", PCL730_SIZE,},
@@ -58,7 +58,7 @@ static struct comedi_driver driver_pcl73
 COMEDI_INITCLEANUP(driver_pcl730);
 
 static int pcl730_do_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -69,10 +69,10 @@ static int pcl730_do_insn(struct comedi_
 	}
 	if (data[0] & 0x00ff)
 		outb(s->state & 0xff,
-			dev->iobase + ((unsigned long)s->private));
+		     dev->iobase + ((unsigned long)s->private));
 	if (data[0] & 0xff00)
 		outb((s->state >> 8),
-			dev->iobase + ((unsigned long)s->private) + 1);
+		     dev->iobase + ((unsigned long)s->private) + 1);
 
 	data[1] = s->state;
 
@@ -80,13 +80,13 @@ static int pcl730_do_insn(struct comedi_
 }
 
 static int pcl730_di_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
 
 	data[1] = inb(dev->iobase + ((unsigned long)s->private)) |
-		(inb(dev->iobase + ((unsigned long)s->private) + 1) << 8);
+	    (inb(dev->iobase + ((unsigned long)s->private) + 1) << 8);
 
 	return 2;
 }
@@ -100,7 +100,7 @@ static int pcl730_attach(struct comedi_d
 	iobase = it->options[0];
 	iorange = this_board->io_range;
 	printk("comedi%d: pcl730: board=%s 0x%04lx ", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 	if (!request_region(iobase, iorange, "pcl730")) {
 		printk("I/O port conflict\n");
 		return -EIO;
--- a/drivers/staging/comedi/drivers/pcl812.c
+++ b/drivers/staging/comedi/drivers/pcl812.c
@@ -161,139 +161,159 @@ Options for ACL-8113, ISO-813:
 #define MAX_CHANLIST_LEN	256	/* length of scan list */
 
 static const struct comedi_lrange range_pcl812pg_ai = { 5, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			BIP_RANGE(0.3125),
-	}
+							    BIP_RANGE(5),
+							    BIP_RANGE(2.5),
+							    BIP_RANGE(1.25),
+							    BIP_RANGE(0.625),
+							    BIP_RANGE(0.3125),
+							    }
 };
+
 static const struct comedi_lrange range_pcl812pg2_ai = { 5, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-	}
+							     BIP_RANGE(10),
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     BIP_RANGE(0.625),
+							     }
 };
+
 static const struct comedi_lrange range812_bipolar1_25 = { 1, {
-			BIP_RANGE(1.25),
-	}
+							       BIP_RANGE(1.25),
+							       }
 };
+
 static const struct comedi_lrange range812_bipolar0_625 = { 1, {
-			BIP_RANGE(0.625),
-	}
+								BIP_RANGE
+								(0.625),
+								}
 };
+
 static const struct comedi_lrange range812_bipolar0_3125 = { 1, {
-			BIP_RANGE(0.3125),
-	}
+								 BIP_RANGE
+								 (0.3125),
+								 }
 };
+
 static const struct comedi_lrange range_pcl813b_ai = { 4, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-	}
+							   BIP_RANGE(5),
+							   BIP_RANGE(2.5),
+							   BIP_RANGE(1.25),
+							   BIP_RANGE(0.625),
+							   }
 };
+
 static const struct comedi_lrange range_pcl813b2_ai = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							    UNI_RANGE(10),
+							    UNI_RANGE(5),
+							    UNI_RANGE(2.5),
+							    UNI_RANGE(1.25),
+							    }
 };
+
 static const struct comedi_lrange range_iso813_1_ai = { 5, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			BIP_RANGE(0.3125),
-	}
+							    BIP_RANGE(5),
+							    BIP_RANGE(2.5),
+							    BIP_RANGE(1.25),
+							    BIP_RANGE(0.625),
+							    BIP_RANGE(0.3125),
+							    }
 };
+
 static const struct comedi_lrange range_iso813_1_2_ai = { 5, {
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-			UNI_RANGE(0.625),
-	}
+							      UNI_RANGE(10),
+							      UNI_RANGE(5),
+							      UNI_RANGE(2.5),
+							      UNI_RANGE(1.25),
+							      UNI_RANGE(0.625),
+							      }
 };
+
 static const struct comedi_lrange range_iso813_2_ai = { 4, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-	}
+							    BIP_RANGE(5),
+							    BIP_RANGE(2.5),
+							    BIP_RANGE(1.25),
+							    BIP_RANGE(0.625),
+							    }
 };
+
 static const struct comedi_lrange range_iso813_2_2_ai = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							      UNI_RANGE(10),
+							      UNI_RANGE(5),
+							      UNI_RANGE(2.5),
+							      UNI_RANGE(1.25),
+							      }
 };
+
 static const struct comedi_lrange range_acl8113_1_ai = { 4, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     BIP_RANGE(0.625),
+							     }
 };
+
 static const struct comedi_lrange range_acl8113_1_2_ai = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							       UNI_RANGE(10),
+							       UNI_RANGE(5),
+							       UNI_RANGE(2.5),
+							       UNI_RANGE(1.25),
+							       }
 };
+
 static const struct comedi_lrange range_acl8113_2_ai = { 3, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     }
 };
+
 static const struct comedi_lrange range_acl8113_2_2_ai = { 3, {
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-	}
+							       UNI_RANGE(10),
+							       UNI_RANGE(5),
+							       UNI_RANGE(2.5),
+							       }
 };
+
 static const struct comedi_lrange range_acl8112dg_ai = { 9, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-			BIP_RANGE(10),
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     BIP_RANGE(0.625),
+							     UNI_RANGE(10),
+							     UNI_RANGE(5),
+							     UNI_RANGE(2.5),
+							     UNI_RANGE(1.25),
+							     BIP_RANGE(10),
+							     }
 };
+
 static const struct comedi_lrange range_acl8112hg_ai = { 12, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.005),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01),
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01),
-	}
+							      BIP_RANGE(5),
+							      BIP_RANGE(0.5),
+							      BIP_RANGE(0.05),
+							      BIP_RANGE(0.005),
+							      UNI_RANGE(10),
+							      UNI_RANGE(1),
+							      UNI_RANGE(0.1),
+							      UNI_RANGE(0.01),
+							      BIP_RANGE(10),
+							      BIP_RANGE(1),
+							      BIP_RANGE(0.1),
+							      BIP_RANGE(0.01),
+							      }
 };
+
 static const struct comedi_lrange range_a821pgh_ai = { 4, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.005),
-	}
+							   BIP_RANGE(5),
+							   BIP_RANGE(0.5),
+							   BIP_RANGE(0.05),
+							   BIP_RANGE(0.005),
+							   }
 };
 
-static int pcl812_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl812_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl812_detach(struct comedi_device *dev);
 
 struct pcl812_board {
@@ -316,62 +336,61 @@ struct pcl812_board {
 	unsigned char haveMPC508;	/*  1=board use MPC508A multiplexor */
 };
 
-
 static const struct pcl812_board boardtypes[] = {
 	{"pcl812", boardPCL812, 16, 0, 2, 16, 16, 0x0fff,
-			33000, 500, &range_bipolar10, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
+	 33000, 500, &range_bipolar10, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
 	{"pcl812pg", boardPCL812PG, 16, 0, 2, 16, 16, 0x0fff,
-			33000, 500, &range_pcl812pg_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
+	 33000, 500, &range_pcl812pg_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
 	{"acl8112pg", boardPCL812PG, 16, 0, 2, 16, 16, 0x0fff,
-			10000, 500, &range_pcl812pg_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
+	 10000, 500, &range_pcl812pg_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
 	{"acl8112dg", boardACL8112, 16, 8, 2, 16, 16, 0x0fff,
-			10000, 500, &range_acl8112dg_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 1},
+	 10000, 500, &range_acl8112dg_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 1},
 	{"acl8112hg", boardACL8112, 16, 8, 2, 16, 16, 0x0fff,
-			10000, 500, &range_acl8112hg_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 1},
+	 10000, 500, &range_acl8112hg_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 1},
 	{"a821pgl", boardA821, 16, 8, 1, 16, 16, 0x0fff,
-			10000, 500, &range_pcl813b_ai, &range_unipolar5,
-		0x000c, 0x00, PCLx1x_IORANGE, 0},
+	 10000, 500, &range_pcl813b_ai, &range_unipolar5,
+	 0x000c, 0x00, PCLx1x_IORANGE, 0},
 	{"a821pglnda", boardA821, 16, 8, 0, 0, 0, 0x0fff,
-			10000, 500, &range_pcl813b_ai, NULL,
-		0x000c, 0x00, PCLx1x_IORANGE, 0},
+	 10000, 500, &range_pcl813b_ai, NULL,
+	 0x000c, 0x00, PCLx1x_IORANGE, 0},
 	{"a821pgh", boardA821, 16, 8, 1, 16, 16, 0x0fff,
-			10000, 500, &range_a821pgh_ai, &range_unipolar5,
-		0x000c, 0x00, PCLx1x_IORANGE, 0},
+	 10000, 500, &range_a821pgh_ai, &range_unipolar5,
+	 0x000c, 0x00, PCLx1x_IORANGE, 0},
 	{"a822pgl", boardACL8112, 16, 8, 2, 16, 16, 0x0fff,
-			10000, 500, &range_acl8112dg_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
+	 10000, 500, &range_acl8112dg_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
 	{"a822pgh", boardACL8112, 16, 8, 2, 16, 16, 0x0fff,
-			10000, 500, &range_acl8112hg_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
+	 10000, 500, &range_acl8112hg_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
 	{"a823pgl", boardACL8112, 16, 8, 2, 16, 16, 0x0fff,
-			8000, 500, &range_acl8112dg_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
+	 8000, 500, &range_acl8112dg_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
 	{"a823pgh", boardACL8112, 16, 8, 2, 16, 16, 0x0fff,
-			8000, 500, &range_acl8112hg_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
+	 8000, 500, &range_acl8112hg_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
 	{"pcl813", boardPCL813, 32, 0, 0, 0, 0, 0x0fff,
-			0, 0, &range_pcl813b_ai, NULL,
-		0x0000, 0x00, PCLx1x_IORANGE, 0},
+	 0, 0, &range_pcl813b_ai, NULL,
+	 0x0000, 0x00, PCLx1x_IORANGE, 0},
 	{"pcl813b", boardPCL813B, 32, 0, 0, 0, 0, 0x0fff,
-			0, 0, &range_pcl813b_ai, NULL,
-		0x0000, 0x00, PCLx1x_IORANGE, 0},
+	 0, 0, &range_pcl813b_ai, NULL,
+	 0x0000, 0x00, PCLx1x_IORANGE, 0},
 	{"acl8113", boardACL8113, 32, 0, 0, 0, 0, 0x0fff,
-			0, 0, &range_acl8113_1_ai, NULL,
-		0x0000, 0x00, PCLx1x_IORANGE, 0},
+	 0, 0, &range_acl8113_1_ai, NULL,
+	 0x0000, 0x00, PCLx1x_IORANGE, 0},
 	{"iso813", boardISO813, 32, 0, 0, 0, 0, 0x0fff,
-			0, 0, &range_iso813_1_ai, NULL,
-		0x0000, 0x00, PCLx1x_IORANGE, 0},
+	 0, 0, &range_iso813_1_ai, NULL,
+	 0x0000, 0x00, PCLx1x_IORANGE, 0},
 	{"acl8216", boardACL8216, 16, 8, 2, 16, 16, 0xffff,
-			10000, 500, &range_pcl813b2_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 1},
+	 10000, 500, &range_pcl813b2_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 1},
 	{"a826pg", boardACL8216, 16, 8, 2, 16, 16, 0xffff,
-			10000, 500, &range_pcl813b2_ai, &range_unipolar5,
-		0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
+	 10000, 500, &range_pcl813b2_ai, &range_unipolar5,
+	 0xdcfc, 0x0a, PCLx1x_IORANGE, 0},
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl812_board))
@@ -410,7 +429,7 @@ struct pcl812_private {
 	unsigned int ai_n_chan;	/*  how many channels is measured */
 	unsigned int ai_flags;	/*  flaglist */
 	unsigned int ai_data_len;	/*  len of data buffer */
-	short *ai_data;	/*  data buffer */
+	short *ai_data;		/*  data buffer */
 	unsigned int ai_is16b;	/*  =1 we have 16 bit card */
 	unsigned long dmabuf[2];	/*  PTR to DMA buf */
 	unsigned int dmapages[2];	/*  how many pages we have allocated */
@@ -424,22 +443,24 @@ struct pcl812_private {
 	unsigned int ao_readback[2];	/*  data for AO readback */
 };
 
-
 #define devpriv ((struct pcl812_private *)dev->private)
 
 /*
 ==============================================================================
 */
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2);
-static void setup_range_channel(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int rangechan, char wait);
-static int pcl812_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2);
+static void setup_range_channel(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned int rangechan, char wait);
+static int pcl812_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
 /*
 ==============================================================================
 */
-static int pcl812_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl812_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int timeout, hi;
@@ -457,12 +478,12 @@ static int pcl812_ai_insn_read(struct co
 			udelay(1);
 		}
 		printk
-			("comedi%d: pcl812: (%s at 0x%lx) A/D insn read timeout\n",
-			dev->minor, dev->board_name, dev->iobase);
+		    ("comedi%d: pcl812: (%s at 0x%lx) A/D insn read timeout\n",
+		     dev->minor, dev->board_name, dev->iobase);
 		outb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);
 		return -ETIME;
 
-	      conv_finish:
+conv_finish:
 		data[n] = ((hi & 0xf) << 8) | inb(dev->iobase + PCL812_AD_LO);
 	}
 	outb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);
@@ -472,8 +493,9 @@ static int pcl812_ai_insn_read(struct co
 /*
 ==============================================================================
 */
-static int acl8216_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int acl8216_ai_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int timeout;
@@ -490,16 +512,15 @@ static int acl8216_ai_insn_read(struct c
 			udelay(1);
 		}
 		printk
-			("comedi%d: pcl812: (%s at 0x%lx) A/D insn read timeout\n",
-			dev->minor, dev->board_name, dev->iobase);
+		    ("comedi%d: pcl812: (%s at 0x%lx) A/D insn read timeout\n",
+		     dev->minor, dev->board_name, dev->iobase);
 		outb(0, dev->iobase + PCL812_MODE);
 		return -ETIME;
 
-	      conv_finish:
+conv_finish:
 		data[n] =
-			(inb(dev->iobase +
-				PCL812_AD_HI) << 8) | inb(dev->iobase +
-			PCL812_AD_LO);
+		    (inb(dev->iobase +
+			 PCL812_AD_HI) << 8) | inb(dev->iobase + PCL812_AD_LO);
 	}
 	outb(0, dev->iobase + PCL812_MODE);
 	return n;
@@ -508,17 +529,18 @@ static int acl8216_ai_insn_read(struct c
 /*
 ==============================================================================
 */
-static int pcl812_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl812_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
 		outb((data[i] & 0xff),
-			dev->iobase + (chan ? PCL812_DA2_LO : PCL812_DA1_LO));
+		     dev->iobase + (chan ? PCL812_DA2_LO : PCL812_DA1_LO));
 		outb((data[i] >> 8) & 0x0f,
-			dev->iobase + (chan ? PCL812_DA2_HI : PCL812_DA1_HI));
+		     dev->iobase + (chan ? PCL812_DA2_HI : PCL812_DA1_HI));
 		devpriv->ao_readback[chan] = data[i];
 	}
 
@@ -528,8 +550,9 @@ static int pcl812_ao_insn_write(struct c
 /*
 ==============================================================================
 */
-static int pcl812_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl812_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int i;
@@ -544,8 +567,9 @@ static int pcl812_ao_insn_read(struct co
 /*
 ==============================================================================
 */
-static int pcl812_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl812_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -559,8 +583,9 @@ static int pcl812_di_insn_bits(struct co
 /*
 ==============================================================================
 */
-static int pcl812_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl812_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -583,21 +608,21 @@ static int pcl812_do_insn_bits(struct co
 static void pcl812_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
 	printk("pcl812 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
-		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
+	       cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
 	printk("pcl812 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
-		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
+	       cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
 	printk("pcl812 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
-		cmd->scan_end_src);
+	       cmd->scan_end_src);
 	printk("pcl812 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
-		cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
+	       cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 #endif
 
 /*
 ==============================================================================
 */
-static int pcl812_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pcl812_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -641,8 +666,8 @@ static int pcl812_ai_cmdtest(struct come
 #ifdef PCL812_EXTDEBUG
 		pcl812_cmdtest_out(1, cmd);
 		printk
-			("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=1\n",
-			err);
+		    ("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=1\n",
+		     err);
 #endif
 		return 1;
 	}
@@ -683,8 +708,8 @@ static int pcl812_ai_cmdtest(struct come
 #ifdef PCL812_EXTDEBUG
 		pcl812_cmdtest_out(2, cmd);
 		printk
-			("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=2\n",
-			err);
+		    ("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=2\n",
+		     err);
 #endif
 		return 2;
 	}
@@ -741,8 +766,8 @@ static int pcl812_ai_cmdtest(struct come
 #ifdef PCL812_EXTDEBUG
 		pcl812_cmdtest_out(3, cmd);
 		printk
-			("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=3\n",
-			err);
+		    ("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=3\n",
+		     err);
 #endif
 		return 3;
 	}
@@ -752,8 +777,8 @@ static int pcl812_ai_cmdtest(struct come
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -763,8 +788,8 @@ static int pcl812_ai_cmdtest(struct come
 	if (err) {
 #ifdef PCL812_EXTDEBUG
 		printk
-			("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=4\n",
-			err);
+		    ("pcl812 EDBG: BGN: pcl812_ai_cmdtest(...) err=%d ret=4\n",
+		     err);
 #endif
 		return 4;
 	}
@@ -806,15 +831,16 @@ static int pcl812_ai_cmd(struct comedi_d
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		i8253_cascade_ns_to_timer(this_board->i8254_osc_base,
-			&divisor1, &divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor1, &divisor2,
+					  &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 	}
 
 	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	devpriv->ai_n_chan = cmd->chanlist_len;
 	memcpy(devpriv->ai_chanlist, cmd->chanlist,
-		sizeof(unsigned int) * cmd->scan_end_arg);
+	       sizeof(unsigned int) * cmd->scan_end_arg);
 	setup_range_channel(dev, s, devpriv->ai_chanlist[0], 1);	/*  select first channel and range */
 
 	if (devpriv->dma) {	/*  check if we can use DMA transfer */
@@ -851,19 +877,19 @@ static int pcl812_ai_cmd(struct comedi_d
 	if (devpriv->ai_dma) {
 		if (devpriv->ai_eos) {	/*  we use EOS, so adapt DMA buffer to one scan */
 			devpriv->dmabytestomove[0] =
-				devpriv->ai_n_chan * sizeof(short);
+			    devpriv->ai_n_chan * sizeof(short);
 			devpriv->dmabytestomove[1] =
-				devpriv->ai_n_chan * sizeof(short);
+			    devpriv->ai_n_chan * sizeof(short);
 			devpriv->dma_runs_to_end = 1;
 		} else {
 			devpriv->dmabytestomove[0] = devpriv->hwdmasize[0];
 			devpriv->dmabytestomove[1] = devpriv->hwdmasize[1];
 			if (devpriv->ai_data_len < devpriv->hwdmasize[0])
 				devpriv->dmabytestomove[0] =
-					devpriv->ai_data_len;
+				    devpriv->ai_data_len;
 			if (devpriv->ai_data_len < devpriv->hwdmasize[1])
 				devpriv->dmabytestomove[1] =
-					devpriv->ai_data_len;
+				    devpriv->ai_data_len;
 			if (devpriv->ai_neverending) {
 				devpriv->dma_runs_to_end = 1;
 			} else {
@@ -872,7 +898,7 @@ static int pcl812_ai_cmd(struct comedi_d
 				devpriv->last_dma_run = bytes % devpriv->dmabytestomove[0];	/* on last dma transfer must be moved */
 				if (devpriv->dma_runs_to_end == 0)
 					devpriv->dmabytestomove[0] =
-						devpriv->last_dma_run;
+					    devpriv->last_dma_run;
 				devpriv->dma_runs_to_end--;
 			}
 		}
@@ -894,10 +920,10 @@ static int pcl812_ai_cmd(struct comedi_d
 		enable_dma(devpriv->dma);
 #ifdef PCL812_EXTDEBUG
 		printk
-			("pcl812 EDBG:   DMA %d PTR 0x%0x/0x%0x LEN %u/%u EOS %d\n",
-			devpriv->dma, devpriv->hwdmaptr[0],
-			devpriv->hwdmaptr[1], devpriv->dmabytestomove[0],
-			devpriv->dmabytestomove[1], devpriv->ai_eos);
+		    ("pcl812 EDBG:   DMA %d PTR 0x%0x/0x%0x LEN %u/%u EOS %d\n",
+		     devpriv->dma, devpriv->hwdmaptr[0],
+		     devpriv->hwdmaptr[1], devpriv->dmabytestomove[0],
+		     devpriv->dmabytestomove[1], devpriv->ai_eos);
 #endif
 	}
 
@@ -955,8 +981,8 @@ static irqreturn_t interrupt_pcl812_ai_i
 
 	if (err) {
 		printk
-			("comedi%d: pcl812: (%s at 0x%lx) A/D cmd IRQ without DRDY!\n",
-			dev->minor, dev->board_name, dev->iobase);
+		    ("comedi%d: pcl812: (%s at 0x%lx) A/D cmd IRQ without DRDY!\n",
+		     dev->minor, dev->board_name, dev->iobase);
 		pcl812_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
@@ -964,8 +990,8 @@ static irqreturn_t interrupt_pcl812_ai_i
 	}
 
 	comedi_buf_put(s->async,
-		((inb(dev->iobase + PCL812_AD_HI) << 8) | inb(dev->iobase +
-				PCL812_AD_LO)) & mask);
+		       ((inb(dev->iobase + PCL812_AD_HI) << 8) |
+			inb(dev->iobase + PCL812_AD_LO)) & mask);
 
 	outb(0, dev->iobase + PCL812_CLRINT);	/* clear INT request */
 
@@ -985,8 +1011,9 @@ static irqreturn_t interrupt_pcl812_ai_i
 /*
 ==============================================================================
 */
-static void transfer_from_dma_buf(struct comedi_device *dev, struct comedi_subdevice *s,
-	short *ptr, unsigned int bufptr, unsigned int len)
+static void transfer_from_dma_buf(struct comedi_device *dev,
+				  struct comedi_subdevice *s, short *ptr,
+				  unsigned int bufptr, unsigned int len)
 {
 	unsigned int i;
 
@@ -1022,9 +1049,9 @@ static irqreturn_t interrupt_pcl812_ai_d
 #ifdef PCL812_EXTDEBUG
 	printk("pcl812 EDBG: BGN: interrupt_pcl812_ai_dma(...)\n");
 #endif
-	ptr = (short *) devpriv->dmabuf[devpriv->next_dma_buf];
+	ptr = (short *)devpriv->dmabuf[devpriv->next_dma_buf];
 	len = (devpriv->dmabytestomove[devpriv->next_dma_buf] >> 1) -
-		devpriv->ai_poll_ptr;
+	    devpriv->ai_poll_ptr;
 
 	devpriv->next_dma_buf = 1 - devpriv->next_dma_buf;
 	disable_dma(devpriv->dma);
@@ -1033,11 +1060,12 @@ static irqreturn_t interrupt_pcl812_ai_d
 	set_dma_addr(devpriv->dma, devpriv->hwdmaptr[devpriv->next_dma_buf]);
 	if (devpriv->ai_eos) {
 		set_dma_count(devpriv->dma,
-			devpriv->dmabytestomove[devpriv->next_dma_buf]);
+			      devpriv->dmabytestomove[devpriv->next_dma_buf]);
 	} else {
 		if (devpriv->dma_runs_to_end) {
 			set_dma_count(devpriv->dma,
-				devpriv->dmabytestomove[devpriv->next_dma_buf]);
+				      devpriv->dmabytestomove[devpriv->
+							      next_dma_buf]);
 		} else {
 			set_dma_count(devpriv->dma, devpriv->last_dma_run);
 		}
@@ -1111,8 +1139,9 @@ static int pcl812_ai_poll(struct comedi_
 	}
 
 	transfer_from_dma_buf(dev, s,
-		(void *)devpriv->dmabuf[1 - devpriv->next_dma_buf],
-		devpriv->ai_poll_ptr, top2);
+			      (void *)devpriv->dmabuf[1 -
+						      devpriv->next_dma_buf],
+			      devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 
@@ -1124,14 +1153,15 @@ static int pcl812_ai_poll(struct comedi_
 /*
 ==============================================================================
 */
-static void setup_range_channel(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int rangechan, char wait)
+static void setup_range_channel(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned int rangechan, char wait)
 {
 	unsigned char chan_reg = CR_CHAN(rangechan);	/*  normal board */
 	unsigned char gain_reg = CR_RANGE(rangechan) + devpriv->range_correction;	/*  gain index */
 
 	if ((chan_reg == devpriv->old_chan_reg)
-		&& (gain_reg == devpriv->old_gain_reg))
+	    && (gain_reg == devpriv->old_gain_reg))
 		return;		/*  we can return, no change */
 
 	devpriv->old_chan_reg = chan_reg;
@@ -1160,12 +1190,12 @@ static void setup_range_channel(struct c
 /*
 ==============================================================================
 */
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2)
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2)
 {
 #ifdef PCL812_EXTDEBUG
 	printk("pcl812 EDBG: BGN: start_pacer(%d,%u,%u)\n", mode, divisor1,
-		divisor2);
+	       divisor2);
 #endif
 	outb(0xb4, dev->iobase + PCL812_CTRCTL);
 	outb(0x74, dev->iobase + PCL812_CTRCTL);
@@ -1205,7 +1235,8 @@ static void free_resources(struct comedi
 /*
 ==============================================================================
 */
-static int pcl812_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcl812_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 #ifdef PCL812_EXTDEBUG
 	printk("pcl812 EDBG: BGN: pcl812_ai_cancel(...)\n");
@@ -1279,7 +1310,7 @@ static int pcl812_attach(struct comedi_d
 
 	iobase = it->options[0];
 	printk("comedi%d: pcl812:  board=%s, ioport=0x%03lx", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 
 	if (!request_region(iobase, this_board->io_range, "pcl812")) {
 		printk("I/O port conflict\n");
@@ -1300,11 +1331,16 @@ static int pcl812_attach(struct comedi_d
 		irq = it->options[1];
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
-				printk(", IRQ %u is out of allowed range, DISABLING IT", irq);
+				printk
+				    (", IRQ %u is out of allowed range, DISABLING IT",
+				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (request_irq(irq, interrupt_pcl812, 0, "pcl812", dev)) {
-					printk(", unable to allocate IRQ %u, DISABLING IT", irq);
+				if (request_irq
+				    (irq, interrupt_pcl812, 0, "pcl812", dev)) {
+					printk
+					    (", unable to allocate IRQ %u, DISABLING IT",
+					     irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
 					printk(", irq=%u", irq);
@@ -1353,7 +1389,7 @@ static int pcl812_attach(struct comedi_d
 		devpriv->hwdmaptr[1] = virt_to_bus((void *)devpriv->dmabuf[1]);
 		devpriv->hwdmasize[1] = PAGE_SIZE * (1 << pages);
 	}
-      no_dma:
+no_dma:
 
 	n_subdevices = 0;
 	if (this_board->n_aichan > 0)
@@ -1450,7 +1486,9 @@ static int pcl812_attach(struct comedi_d
 			default:
 				s->range_table = &range_bipolar10;
 				break;
-				printk(", incorrect range number %d, changing to 0 (+/-10V)", it->options[4]);
+				printk
+				    (", incorrect range number %d, changing to 0 (+/-10V)",
+				     it->options[4]);
 				break;
 			}
 			break;
@@ -1478,7 +1516,9 @@ static int pcl812_attach(struct comedi_d
 			default:
 				s->range_table = &range_iso813_1_ai;
 				break;
-				printk(", incorrect range number %d, changing to 0 ", it->options[1]);
+				printk
+				    (", incorrect range number %d, changing to 0 ",
+				     it->options[1]);
 				break;
 			}
 			break;
@@ -1501,7 +1541,9 @@ static int pcl812_attach(struct comedi_d
 			default:
 				s->range_table = &range_acl8113_1_ai;
 				break;
-				printk(", incorrect range number %d, changing to 0 ", it->options[1]);
+				printk
+				    (", incorrect range number %d, changing to 0 ",
+				     it->options[1]);
 				break;
 			}
 			break;
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -91,16 +91,17 @@ Configuration Options:
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl816 = { 8, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+						       BIP_RANGE(10),
+						       BIP_RANGE(5),
+						       BIP_RANGE(2.5),
+						       BIP_RANGE(1.25),
+						       UNI_RANGE(10),
+						       UNI_RANGE(5),
+						       UNI_RANGE(2.5),
+						       UNI_RANGE(1.25),
+						       }
 };
+
 struct pcl816_board {
 
 	const char *name;	/*  board name */
@@ -122,33 +123,33 @@ struct pcl816_board {
 	int i8254_osc_base;	/*  1/frequency of on board oscilator in ns */
 };
 
-
 static const struct pcl816_board boardtypes[] = {
 	{"pcl816", 8, 16, 10000, 1, 16, 16, &range_pcl816,
-			&range_pcl816, PCLx1x_RANGE,
-			0x00fc,	/*  IRQ mask */
-			0x0a,	/*  DMA mask */
-			0xffff,	/*  16-bit card */
-			0xffff,	/*  D/A maxdata */
-			1024,
-			1,	/*  ao chan list */
-		100},
+	 &range_pcl816, PCLx1x_RANGE,
+	 0x00fc,		/*  IRQ mask */
+	 0x0a,			/*  DMA mask */
+	 0xffff,		/*  16-bit card */
+	 0xffff,		/*  D/A maxdata */
+	 1024,
+	 1,			/*  ao chan list */
+	 100},
 	{"pcl814b", 8, 16, 10000, 1, 16, 16, &range_pcl816,
-			&range_pcl816, PCLx1x_RANGE,
-			0x00fc,
-			0x0a,
-			0x3fff,	/* 14 bit card */
-			0x3fff,
-			1024,
-			1,
-		100},
+	 &range_pcl816, PCLx1x_RANGE,
+	 0x00fc,
+	 0x0a,
+	 0x3fff,		/* 14 bit card */
+	 0x3fff,
+	 1024,
+	 1,
+	 100},
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl816_board))
 #define devpriv ((struct pcl816_private *)dev->private)
 #define this_board ((const struct pcl816_board *)dev->board_ptr)
 
-static int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl816_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl816_detach(struct comedi_device *dev);
 
 #ifdef unused
@@ -209,29 +210,32 @@ struct pcl816_private {
 #endif
 };
 
-
 /*
 ==============================================================================
 */
 static int check_and_setup_channel_list(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int *chanlist, int chanlen);
-static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2);
+					struct comedi_subdevice *s,
+					unsigned int *chanlist, int chanlen);
+static int pcl816_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2);
 #ifdef unused
 static int set_rtc_irq_bit(unsigned char bit);
 #endif
 
-static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int pcl816_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd);
 static int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 
 /*
 ==============================================================================
    ANALOG INPUT MODE0, 816 cards, slow version
 */
-static int pcl816_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl816_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int timeout;
@@ -253,12 +257,12 @@ static int pcl816_ai_insn_read(struct co
 		timeout = 100;
 		while (timeout--) {
 			if (!(inb(dev->iobase + PCL816_STATUS) &
-					PCL816_STATUS_DRDY_MASK)) {
+			      PCL816_STATUS_DRDY_MASK)) {
 				/*  return read value */
 				data[n] =
-					((inb(dev->iobase +
-							PCL816_AD_HI) << 8) |
-					(inb(dev->iobase + PCL816_AD_LO)));
+				    ((inb(dev->iobase +
+					  PCL816_AD_HI) << 8) |
+				     (inb(dev->iobase + PCL816_AD_LO)));
 
 				outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT (conversion end) flag */
 				break;
@@ -291,7 +295,7 @@ static irqreturn_t interrupt_pcl816_ai_m
 
 	while (timeout--) {
 		if (!(inb(dev->iobase + PCL816_STATUS) &
-				PCL816_STATUS_DRDY_MASK))
+		      PCL816_STATUS_DRDY_MASK))
 			break;
 		udelay(1);
 	}
@@ -334,8 +338,9 @@ static irqreturn_t interrupt_pcl816_ai_m
 ==============================================================================
    analog input dma mode 1 & 3, 816 cards
 */
-static void transfer_from_dma_buf(struct comedi_device *dev, struct comedi_subdevice *s,
-	short *ptr, unsigned int bufptr, unsigned int len)
+static void transfer_from_dma_buf(struct comedi_device *dev,
+				  struct comedi_subdevice *s, short *ptr,
+				  unsigned int bufptr, unsigned int len)
 {
 	int i;
 
@@ -346,7 +351,7 @@ static void transfer_from_dma_buf(struct
 		comedi_buf_put(s->async, ptr[bufptr++]);
 
 		if (++devpriv->ai_act_chanlist_pos >=
-			devpriv->ai_act_chanlist_len) {
+		    devpriv->ai_act_chanlist_len) {
 			devpriv->ai_act_chanlist_pos = 0;
 			devpriv->ai_act_scan++;
 		}
@@ -381,10 +386,11 @@ static irqreturn_t interrupt_pcl816_ai_m
 		dma_flags = claim_dma_lock();
 /* clear_dma_ff (devpriv->dma); */
 		set_dma_addr(devpriv->dma,
-			devpriv->hwdmaptr[devpriv->next_dma_buf]);
+			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
 		if (devpriv->dma_runs_to_end) {
 			set_dma_count(devpriv->dma,
-				devpriv->hwdmasize[devpriv->next_dma_buf]);
+				      devpriv->hwdmasize[devpriv->
+							 next_dma_buf]);
 		} else {
 			set_dma_count(devpriv->dma, devpriv->last_dma_run);
 		}
@@ -395,7 +401,7 @@ static irqreturn_t interrupt_pcl816_ai_m
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 
-	ptr = (short *) devpriv->dmabuf[this_dma_buf];
+	ptr = (short *)devpriv->dmabuf[this_dma_buf];
 
 	len = (devpriv->hwdmasize[0] >> 1) - devpriv->ai_poll_ptr;
 	bufptr = devpriv->ai_poll_ptr;
@@ -430,7 +436,7 @@ static irqreturn_t interrupt_pcl816(int 
 
 	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */
 	if ((!dev->irq) | (!devpriv->irq_free) | (!devpriv->irq_blocked) |
-		(!devpriv->int816_mode)) {
+	    (!devpriv->int816_mode)) {
 		if (devpriv->irq_was_now_closed) {
 			devpriv->irq_was_now_closed = 0;
 			/*  comedi_error(dev,"last IRQ.."); */
@@ -450,26 +456,26 @@ static irqreturn_t interrupt_pcl816(int 
 static void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)
 {
 	printk("pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,
-		cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
+	       cmd->start_src, cmd->scan_begin_src, cmd->convert_src);
 	printk("pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,
-		cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
+	       cmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);
 	printk("pcl816 e=%d stopsrc=%x scanend=%x\n", e, cmd->stop_src,
-		cmd->scan_end_src);
+	       cmd->scan_end_src);
 	printk("pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n", e,
-		cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
+	       cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);
 }
 
 /*
 ==============================================================================
 */
-static int pcl816_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pcl816_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
 
-	DEBUG(printk("pcl816 pcl812_ai_cmdtest\n");
-		pcl816_cmdtest_out(-1, cmd););
+	DEBUG(printk("pcl816 pcl812_ai_cmdtest\n"); pcl816_cmdtest_out(-1, cmd);
+	    );
 
 	/* step 1: make sure trigger sources are trivially valid */
 	tmp = cmd->start_src;
@@ -582,8 +588,9 @@ static int pcl816_ai_cmdtest(struct come
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(this_board->i8254_osc_base,
-			&divisor1, &divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor1, &divisor2,
+					  &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -619,8 +626,8 @@ static int pcl816_ai_cmd(struct comedi_d
 			cmd->convert_arg = this_board->ai_ns_min;
 
 		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (divisor1 == 1) {	/*  PCL816 crash if any divisor is set to 1 */
 			divisor1 = 2;
 			divisor2 /= 2;
@@ -634,7 +641,7 @@ static int pcl816_ai_cmd(struct comedi_d
 	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	if (!check_and_setup_channel_list(dev, s, cmd->chanlist,
-			cmd->chanlist_len))
+					  cmd->chanlist_len))
 		return -EINVAL;
 	udelay(1);
 
@@ -732,8 +739,8 @@ static int pcl816_ai_poll(struct comedi_
 	}
 
 	transfer_from_dma_buf(dev, s,
-		(short *) devpriv->dmabuf[devpriv->next_dma_buf],
-		devpriv->ai_poll_ptr, top2);
+			      (short *)devpriv->dmabuf[devpriv->next_dma_buf],
+			      devpriv->ai_poll_ptr, top2);
 
 	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -745,7 +752,8 @@ static int pcl816_ai_poll(struct comedi_
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl816_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcl816_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 /* DEBUG(printk("pcl816_ai_cancel()\n");) */
 
@@ -781,9 +789,8 @@ static int pcl816_ai_cancel(struct comed
 		}
 	}
 
-	DEBUG(printk("comedi: pcl816_ai_cancel() successful\n");
-		)
-		return 0;
+	DEBUG(printk("comedi: pcl816_ai_cancel() successful\n");)
+	    return 0;
 }
 
 /*
@@ -836,7 +843,7 @@ static void pcl816_reset(struct comedi_d
 */
 static void
 start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2)
+	    unsigned int divisor2)
 {
 	outb(0x32, dev->iobase + PCL816_CTRCTL);
 	outb(0xff, dev->iobase + PCL816_CTR0);
@@ -865,8 +872,9 @@ start_pacer(struct comedi_device *dev, i
  If it's ok, then program scan/gain logic
 */
 static int
-check_and_setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, int chanlen)
+check_and_setup_channel_list(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int *chanlist,
+			     int chanlen)
 {
 	unsigned int chansegment[16];
 	unsigned int i, nowmustbechan, seglen, segpos;
@@ -882,18 +890,17 @@ check_and_setup_channel_list(struct come
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
 			/*  build part of chanlist */
 			DEBUG(printk("%d. %d %d\n", i, CR_CHAN(chanlist[i]),
-					CR_RANGE(chanlist[i]));
-				)
-				if (chanlist[0] == chanlist[i])
+				     CR_RANGE(chanlist[i]));)
+			    if (chanlist[0] == chanlist[i])
 				break;	/*  we detect loop, this must by finish */
 			nowmustbechan =
-				(CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
+			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
 				/*  channel list isn't continous :-( */
 				printk
-					("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
-					dev->minor, i, CR_CHAN(chanlist[i]),
-					nowmustbechan, CR_CHAN(chanlist[0]));
+				    ("comedi%d: pcl816: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+				     dev->minor, i, CR_CHAN(chanlist[i]),
+				     nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;
 			}
 			chansegment[i] = chanlist[i];	/*  well, this is next correct channel in list */
@@ -901,20 +908,19 @@ check_and_setup_channel_list(struct come
 
 		for (i = 0, segpos = 0; i < chanlen; i++) {	/*  check whole chanlist */
 			DEBUG(printk("%d %d=%d %d\n",
-					CR_CHAN(chansegment[i % seglen]),
-					CR_RANGE(chansegment[i % seglen]),
-					CR_CHAN(chanlist[i]),
-					CR_RANGE(chanlist[i]));
-				)
-				if (chanlist[i] != chansegment[i % seglen]) {
+				     CR_CHAN(chansegment[i % seglen]),
+				     CR_RANGE(chansegment[i % seglen]),
+				     CR_CHAN(chanlist[i]),
+				     CR_RANGE(chanlist[i]));)
+			    if (chanlist[i] != chansegment[i % seglen]) {
 				printk
-					("comedi%d: pcl816: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
-					dev->minor, i, CR_CHAN(chansegment[i]),
-					CR_RANGE(chansegment[i]),
-					CR_AREF(chansegment[i]),
-					CR_CHAN(chanlist[i % seglen]),
-					CR_RANGE(chanlist[i % seglen]),
-					CR_AREF(chansegment[i % seglen]));
+				    ("comedi%d: pcl816: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+				     dev->minor, i, CR_CHAN(chansegment[i]),
+				     CR_RANGE(chansegment[i]),
+				     CR_AREF(chansegment[i]),
+				     CR_CHAN(chanlist[i % seglen]),
+				     CR_RANGE(chanlist[i % seglen]),
+				     CR_AREF(chansegment[i % seglen]));
 				return 0;	/*  chan/gain list is strange */
 			}
 		}
@@ -997,7 +1003,7 @@ static void free_resources(struct comedi
 		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
 			if (devpriv->rtc_iobase)
 				release_region(devpriv->rtc_iobase,
-					devpriv->rtc_iosize);
+					       devpriv->rtc_iosize);
 		}
 #endif
 	}
@@ -1027,7 +1033,7 @@ static int pcl816_attach(struct comedi_d
 	/* claim our I/O space */
 	iobase = it->options[0];
 	printk("comedi%d: pcl816:  board=%s, ioport=0x%03lx", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 
 	if (!request_region(iobase, this_board->io_range, "pcl816")) {
 		printk("I/O port conflict\n");
@@ -1055,14 +1061,15 @@ static int pcl816_attach(struct comedi_d
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
 				printk
-					(", IRQ %u is out of allowed range, DISABLING IT",
-					irq);
+				    (", IRQ %u is out of allowed range, DISABLING IT",
+				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (request_irq(irq, interrupt_pcl816, 0, "pcl816", dev)) {
+				if (request_irq
+				    (irq, interrupt_pcl816, 0, "pcl816", dev)) {
 					printk
-						(", unable to allocate IRQ %u, DISABLING IT",
-						irq);
+					    (", unable to allocate IRQ %u, DISABLING IT",
+					     irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
 					printk(", irq=%u", irq);
@@ -1087,7 +1094,7 @@ static int pcl816_attach(struct comedi_d
 	if (it->options[2] > 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
 			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
-					"pcl816 (RTC)"))
+					    "pcl816 (RTC)"))
 				goto no_rtc;
 		}
 		devpriv->rtc_iobase = RTC_PORT(0);
@@ -1095,7 +1102,7 @@ static int pcl816_attach(struct comedi_d
 		RTC_lock++;
 #ifdef UNTESTED_CODE
 		if (!request_irq(RTC_IRQ, interrupt_pcl816_ai_mode13_dma_rtc, 0,
-				"pcl816 DMA (RTC)", dev)) {
+				 "pcl816 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
 			printk(", dma_irq=%u", devpriv->rtc_irq);
@@ -1104,7 +1111,7 @@ static int pcl816_attach(struct comedi_d
 			if (RTC_lock == 0) {
 				if (devpriv->rtc_iobase)
 					release_region(devpriv->rtc_iobase,
-						devpriv->rtc_iosize);
+						       devpriv->rtc_iosize);
 			}
 			devpriv->rtc_iobase = 0;
 			devpriv->rtc_iosize = 0;
@@ -1115,7 +1122,7 @@ static int pcl816_attach(struct comedi_d
 
 	}
 
-      no_rtc:
+no_rtc:
 #endif
 	/* grab our DMA */
 	dma = 0;
@@ -1157,17 +1164,17 @@ static int pcl816_attach(struct comedi_d
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
 				printk
-					(", unable to allocate DMA buffer, FAIL!\n");
+				    (", unable to allocate DMA buffer, FAIL!\n");
 				return -EBUSY;
 			}
 			devpriv->dmapages[1] = pages;
 			devpriv->hwdmaptr[1] =
-				virt_to_bus((void *)devpriv->dmabuf[1]);
+			    virt_to_bus((void *)devpriv->dmabuf[1]);
 			devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 		}
 	}
 
-      no_dma:
+no_dma:
 
 /*  if (this_board->n_aochan > 0)
     subdevs[1] = COMEDI_SUBD_AO;
@@ -1241,9 +1248,8 @@ case COMEDI_SUBD_DO:
  */
 static int pcl816_detach(struct comedi_device *dev)
 {
-	DEBUG(printk("comedi%d: pcl816: remove\n", dev->minor);
-		)
-		free_resources(dev);
+	DEBUG(printk("comedi%d: pcl816: remove\n", dev->minor);)
+	    free_resources(dev);
 #ifdef unused
 	if (devpriv->dma_rtc)
 		RTC_lock--;
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -195,56 +195,58 @@ A word or two about DMA. Driver support 
 #define MAGIC_DMA_WORD 0x5a5a
 
 static const struct comedi_lrange range_pcl818h_ai = { 9, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-			BIP_RANGE(10),
-	}
+							   BIP_RANGE(5),
+							   BIP_RANGE(2.5),
+							   BIP_RANGE(1.25),
+							   BIP_RANGE(0.625),
+							   UNI_RANGE(10),
+							   UNI_RANGE(5),
+							   UNI_RANGE(2.5),
+							   UNI_RANGE(1.25),
+							   BIP_RANGE(10),
+							   }
 };
 
 static const struct comedi_lrange range_pcl818hg_ai = { 10, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.005),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01),
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01),
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(0.5),
+							     BIP_RANGE(0.05),
+							     BIP_RANGE(0.005),
+							     UNI_RANGE(10),
+							     UNI_RANGE(1),
+							     UNI_RANGE(0.1),
+							     UNI_RANGE(0.01),
+							     BIP_RANGE(10),
+							     BIP_RANGE(1),
+							     BIP_RANGE(0.1),
+							     BIP_RANGE(0.01),
+							     }
 };
 
 static const struct comedi_lrange range_pcl818l_l_ai = { 4, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     BIP_RANGE(0.625),
+							     }
 };
 
 static const struct comedi_lrange range_pcl818l_h_ai = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-	}
+							     BIP_RANGE(10),
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     }
 };
 
 static const struct comedi_lrange range718_bipolar1 = { 1, {BIP_RANGE(1),} };
-static const struct comedi_lrange range718_bipolar0_5 = { 1, {BIP_RANGE(0.5),} };
+static const struct comedi_lrange range718_bipolar0_5 =
+    { 1, {BIP_RANGE(0.5),} };
 static const struct comedi_lrange range718_unipolar2 = { 1, {UNI_RANGE(2),} };
 static const struct comedi_lrange range718_unipolar1 = { 1, {BIP_RANGE(1),} };
 
-static int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcl818_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcl818_detach(struct comedi_device *dev);
 
 #ifdef unused
@@ -273,30 +275,29 @@ struct pcl818_board {
 	int is_818;
 };
 
-
 static const struct pcl818_board boardtypes[] = {
 	{"pcl818l", 4, 16, 8, 25000, 1, 16, 16, &range_pcl818l_l_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
 	{"pcl818h", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
 	{"pcl818hd", 9, 16, 8, 10000, 1, 16, 16, &range_pcl818h_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 1, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 1, 1},
 	{"pcl818hg", 12, 16, 8, 10000, 1, 16, 16, &range_pcl818hg_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 1, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 1, 1},
 	{"pcl818", 9, 16, 8, 10000, 2, 16, 16, &range_pcl818h_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 1},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1},
 	{"pcl718", 1, 16, 8, 16000, 2, 16, 16, &range_unipolar5,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 0},
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 0},
 	/* pcm3718 */
 	{"pcm3718", 9, 16, 8, 10000, 0, 16, 16, &range_pcl818h_ai,
-			&range_unipolar5, PCLx1x_RANGE, 0x00fc,
-		0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
+	 &range_unipolar5, PCLx1x_RANGE, 0x00fc,
+	 0x0a, 0xfff, 0xfff, 0, 1 /* XXX ? */ },
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct pcl818_board))
@@ -353,7 +354,7 @@ struct pcl818_private {
 	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_flags;	/*  flaglist */
 	unsigned int ai_data_len;	/*  len of data buffer */
-	short *ai_data;	/*  data buffer */
+	short *ai_data;		/*  data buffer */
 	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
 	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
@@ -361,7 +362,6 @@ struct pcl818_private {
 	unsigned int ao_readback[2];
 };
 
-
 static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */
 	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
 };
@@ -372,14 +372,18 @@ static const unsigned int muxonechan[] =
 /*
 ==============================================================================
 */
-static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen);
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan);
-
-static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2);
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int n_chan,
+			       unsigned int seglen);
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int n_chan);
+
+static int pcl818_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2);
 
 #ifdef unused
 static int set_rtc_irq_bit(unsigned char bit);
@@ -391,8 +395,9 @@ static int rtc_setfreq_irq(int freq);
 ==============================================================================
    ANALOG INPUT MODE0, 818 cards, slow version
 */
-static int pcl818_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int timeout;
@@ -425,9 +430,9 @@ static int pcl818_ai_insn_read(struct co
 		outb(0, dev->iobase + PCL818_CLRINT);
 		return -EIO;
 
-	      conv_finish:
+conv_finish:
 		data[n] = ((inb(dev->iobase + PCL818_AD_HI) << 4) |
-			(inb(dev->iobase + PCL818_AD_LO) >> 4));
+			   (inb(dev->iobase + PCL818_AD_LO) >> 4));
 	}
 
 	return n;
@@ -438,8 +443,9 @@ static int pcl818_ai_insn_read(struct co
    ANALOG OUTPUT MODE0, 818 cards
    only one sample per call is supported
 */
-static int pcl818_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -451,8 +457,9 @@ static int pcl818_ao_insn_read(struct co
 	return n;
 }
 
-static int pcl818_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -460,9 +467,9 @@ static int pcl818_ao_insn_write(struct c
 	for (n = 0; n < insn->n; n++) {
 		devpriv->ao_readback[chan] = data[n];
 		outb((data[n] & 0x000f) << 4, dev->iobase +
-			(chan ? PCL718_DA2_LO : PCL818_DA_LO));
+		     (chan ? PCL718_DA2_LO : PCL818_DA_LO));
 		outb((data[n] & 0x0ff0) >> 4, dev->iobase +
-			(chan ? PCL718_DA2_HI : PCL818_DA_HI));
+		     (chan ? PCL718_DA2_HI : PCL818_DA_HI));
 	}
 
 	return n;
@@ -474,14 +481,15 @@ static int pcl818_ao_insn_write(struct c
 
    only one sample per call is supported
 */
-static int pcl818_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
 
 	data[1] = inb(dev->iobase + PCL818_DI_LO) |
-		(inb(dev->iobase + PCL818_DI_HI) << 8);
+	    (inb(dev->iobase + PCL818_DI_HI) << 8);
 
 	return 2;
 }
@@ -492,8 +500,9 @@ static int pcl818_di_insn_bits(struct co
 
    only one sample per call is supported
 */
-static int pcl818_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl818_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -533,16 +542,16 @@ static irqreturn_t interrupt_pcl818_ai_m
 	comedi_event(dev, s);
 	return IRQ_HANDLED;
 
-      conv_finish:
+conv_finish:
 	low = inb(dev->iobase + PCL818_AD_LO);
 	comedi_buf_put(s->async, ((inb(dev->iobase + PCL818_AD_HI) << 4) | (low >> 4)));	/*  get one sample */
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 		printk
-			("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
-			(low & 0xf),
-			devpriv->act_chanlist[devpriv->act_chanlist_pos]);
+		    ("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
+		     (low & 0xf),
+		     devpriv->act_chanlist[devpriv->act_chanlist_pos]);
 		pcl818_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		comedi_event(dev, s);
@@ -581,10 +590,11 @@ static irqreturn_t interrupt_pcl818_ai_m
 		set_dma_mode(devpriv->dma, DMA_MODE_READ);
 		flags = claim_dma_lock();
 		set_dma_addr(devpriv->dma,
-			devpriv->hwdmaptr[devpriv->next_dma_buf]);
+			     devpriv->hwdmaptr[devpriv->next_dma_buf]);
 		if (devpriv->dma_runs_to_end || devpriv->neverending_ai) {
 			set_dma_count(devpriv->dma,
-				devpriv->hwdmasize[devpriv->next_dma_buf]);
+				      devpriv->hwdmasize[devpriv->
+							 next_dma_buf]);
 		} else {
 			set_dma_count(devpriv->dma, devpriv->last_dma_run);
 		}
@@ -595,7 +605,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 
 	devpriv->dma_runs_to_end--;
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
-	ptr = (short *) devpriv->dmabuf[1 - devpriv->next_dma_buf];
+	ptr = (short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];
 
 	len = devpriv->hwdmasize[0] >> 1;
 	bufptr = 0;
@@ -603,11 +613,10 @@ static irqreturn_t interrupt_pcl818_ai_m
 	for (i = 0; i < len; i++) {
 		if ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 			printk
-				("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
-				(ptr[bufptr] & 0xf),
-				devpriv->act_chanlist[devpriv->
-					act_chanlist_pos],
-				devpriv->act_chanlist_pos);
+			    ("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
+			     (ptr[bufptr] & 0xf),
+			     devpriv->act_chanlist[devpriv->act_chanlist_pos],
+			     devpriv->act_chanlist_pos);
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
@@ -649,7 +658,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 	unsigned long tmp;
 	unsigned int top1, top2, i, bufptr;
 	long ofs_dats;
-	short *dmabuf = (short *) devpriv->dmabuf[0];
+	short *dmabuf = (short *)devpriv->dmabuf[0];
 
 	/* outb(2,0x378); */
 	switch (devpriv->ai_mode) {
@@ -657,7 +666,7 @@ static irqreturn_t interrupt_pcl818_ai_m
 	case INT_TYPE_AI3_DMA_RTC:
 		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);
 		mod_timer(&devpriv->rtc_irq_timer,
-			jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
+			  jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
 
 		for (i = 0; i < 10; i++) {
 			top1 = get_dma_residue(devpriv->dma);
@@ -694,13 +703,13 @@ static irqreturn_t interrupt_pcl818_ai_m
 		for (i = 0; i < ofs_dats; i++) {
 			if ((dmabuf[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 				printk
-					("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
-					(dmabuf[bufptr] & 0xf),
-					devpriv->act_chanlist[devpriv->
-						act_chanlist_pos]);
+				    ("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
+				     (dmabuf[bufptr] & 0xf),
+				     devpriv->
+				     act_chanlist[devpriv->act_chanlist_pos]);
 				pcl818_ai_cancel(dev, s);
 				s->async->events |=
-					COMEDI_CB_EOA | COMEDI_CB_ERROR;
+				    COMEDI_CB_EOA | COMEDI_CB_ERROR;
 				comedi_event(dev, s);
 				return IRQ_HANDLED;
 			}
@@ -776,10 +785,9 @@ static irqreturn_t interrupt_pcl818_ai_m
 		lo = inb(dev->iobase + PCL818_FI_DATALO);
 		if ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {	/*  dropout! */
 			printk
-				("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
-				(lo & 0xf),
-				devpriv->act_chanlist[devpriv->
-					act_chanlist_pos]);
+			    ("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
+			     (lo & 0xf),
+			     devpriv->act_chanlist[devpriv->act_chanlist_pos]);
 			pcl818_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
@@ -822,9 +830,9 @@ static irqreturn_t interrupt_pcl818(int 
 
 	if (devpriv->irq_blocked && devpriv->irq_was_now_closed) {
 		if ((devpriv->neverending_ai || (!devpriv->neverending_ai &&
-						devpriv->ai_act_scan > 0)) &&
-				(devpriv->ai_mode == INT_TYPE_AI1_DMA ||
-				 devpriv->ai_mode == INT_TYPE_AI3_DMA)) {
+						 devpriv->ai_act_scan > 0)) &&
+		    (devpriv->ai_mode == INT_TYPE_AI1_DMA ||
+		     devpriv->ai_mode == INT_TYPE_AI3_DMA)) {
 			/* The cleanup from ai_cancel() has been delayed
 			   until now because the card doesn't seem to like
 			   being reprogrammed while a DMA transfer is in
@@ -863,7 +871,7 @@ static irqreturn_t interrupt_pcl818(int 
 	outb(0, dev->iobase + PCL818_CLRINT);	/* clear INT request */
 
 	if ((!dev->irq) || (!devpriv->irq_free) || (!devpriv->irq_blocked)
-		|| (!devpriv->ai_mode)) {
+	    || (!devpriv->ai_mode)) {
 		comedi_error(dev, "bad IRQ!");
 		return IRQ_NONE;
 	}
@@ -877,7 +885,7 @@ static irqreturn_t interrupt_pcl818(int 
    ANALOG INPUT MODE 1 or 3 DMA , 818 cards
 */
 static void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,
-	struct comedi_subdevice *s)
+				    struct comedi_subdevice *s)
 {
 	unsigned int flags;
 	unsigned int bytes;
@@ -918,7 +926,7 @@ static void pcl818_ai_mode13dma_int(int 
    ANALOG INPUT MODE 1 or 3 DMA rtc, 818 cards
 */
 static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device *dev,
-	struct comedi_subdevice *s)
+				    struct comedi_subdevice *s)
 {
 	unsigned int flags;
 	short *pole;
@@ -931,13 +939,13 @@ static void pcl818_ai_mode13dma_rtc(int 
 	release_dma_lock(flags);
 	enable_dma(devpriv->dma);
 	devpriv->last_top_dma = 0;	/* devpriv->hwdmasize[0]; */
-	pole = (short *) devpriv->dmabuf[0];
+	pole = (short *)devpriv->dmabuf[0];
 	devpriv->dmasamplsize = devpriv->hwdmasize[0] / 2;
 	pole[devpriv->dmasamplsize - 1] = MAGIC_DMA_WORD;
 #ifdef unused
 	devpriv->rtc_freq = rtc_setfreq_irq(2048);
 	devpriv->rtc_irq_timer.expires =
-		jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100;
+	    jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100;
 	devpriv->rtc_irq_timer.data = (unsigned long)dev;
 	devpriv->rtc_irq_timer.function = rtc_dropped_irq;
 
@@ -959,7 +967,7 @@ static void pcl818_ai_mode13dma_rtc(int 
    ANALOG INPUT MODE 1 or 3, 818 cards
 */
 static int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,
-	struct comedi_subdevice *s)
+			      struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int divisor1, divisor2;
@@ -977,11 +985,11 @@ static int pcl818_ai_cmd_mode(int mode, 
 	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
-		devpriv->ai_n_chan);
+				    devpriv->ai_n_chan);
 	if (seglen < 1)
 		return -EINVAL;
 	setup_channel_list(dev, s, devpriv->ai_chanlist,
-		devpriv->ai_n_chan, seglen);
+			   devpriv->ai_n_chan, seglen);
 
 	udelay(1);
 
@@ -998,7 +1006,8 @@ static int pcl818_ai_cmd_mode(int mode, 
 
 	if (mode == 1) {
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg, TRIG_ROUND_NEAREST);
+					  &divisor2, &cmd->convert_arg,
+					  TRIG_ROUND_NEAREST);
 		if (divisor1 == 1) {	/* PCL718/818 crash if any divisor is set to 1 */
 			divisor1 = 2;
 			divisor2 /= 2;
@@ -1034,11 +1043,13 @@ static int pcl818_ai_cmd_mode(int mode, 
 			if (mode == 1) {
 				devpriv->ai_mode = INT_TYPE_AI1_INT;
 				/* Pacer+IRQ */
-				outb(0x83 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
+				outb(0x83 | (dev->irq << 4),
+				     dev->iobase + PCL818_CONTROL);
 			} else {
 				devpriv->ai_mode = INT_TYPE_AI3_INT;
 				/* Ext trig+IRQ */
-				outb(0x82 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);
+				outb(0x82 | (dev->irq << 4),
+				     dev->iobase + PCL818_CONTROL);
 			}
 		} else {
 			/* FIFO */
@@ -1075,8 +1086,8 @@ static int pcl818_ai_cmd_mode(int mode, 
    ANALOG OUTPUT MODE 1 or 3, 818 cards
 */
 #ifdef PCL818_MODE13_AO
-static int pcl818_ao_mode13(int mode, struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_trig *it)
+static int pcl818_ao_mode13(int mode, struct comedi_device *dev,
+			    struct comedi_subdevice *s, comedi_trig * it)
 {
 	int divisor1, divisor2;
 
@@ -1099,7 +1110,8 @@ static int pcl818_ao_mode13(int mode, st
 
 	if (mode == 1) {
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-			&divisor2, &it->trigvar, TRIG_ROUND_NEAREST);
+					  &divisor2, &it->trigvar,
+					  TRIG_ROUND_NEAREST);
 		if (divisor1 == 1) {	/* PCL818 crash if any divisor is set to 1 */
 			divisor1 = 2;
 			divisor2 /= 2;
@@ -1128,8 +1140,8 @@ static int pcl818_ao_mode13(int mode, st
 ==============================================================================
    ANALOG OUTPUT MODE 1, 818 cards
 */
-static int pcl818_ao_mode1(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_trig *it)
+static int pcl818_ao_mode1(struct comedi_device *dev,
+			   struct comedi_subdevice *s, comedi_trig * it)
 {
 	return pcl818_ao_mode13(1, dev, s, it);
 }
@@ -1138,8 +1150,8 @@ static int pcl818_ao_mode1(struct comedi
 ==============================================================================
    ANALOG OUTPUT MODE 3, 818 cards
 */
-static int pcl818_ao_mode3(struct comedi_device *dev, struct comedi_subdevice *s,
-	comedi_trig *it)
+static int pcl818_ao_mode3(struct comedi_device *dev,
+			   struct comedi_subdevice *s, comedi_trig * it)
 {
 	return pcl818_ao_mode13(3, dev, s, it);
 }
@@ -1150,8 +1162,8 @@ static int pcl818_ao_mode3(struct comedi
 ==============================================================================
  Start/stop pacer onboard pacer
 */
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2)
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2)
 {
 	outb(0xb4, dev->iobase + PCL818_CTRCTL);
 	outb(0x74, dev->iobase + PCL818_CTRCTL);
@@ -1170,8 +1182,9 @@ static void start_pacer(struct comedi_de
  Check if channel list from user is builded correctly
  If it's ok, then program scan/gain logic
 */
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan)
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int chansegment[16];
 	unsigned int i, nowmustbechan, seglen, segpos;
@@ -1196,12 +1209,12 @@ static int check_channel_list(struct com
 			if (chanlist[0] == chanlist[i])
 				break;
 			nowmustbechan =
-				(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
+			    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
 				printk
-					("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
-					dev->minor, i, CR_CHAN(chanlist[i]),
-					nowmustbechan, CR_CHAN(chanlist[0]));
+				    ("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+				     dev->minor, i, CR_CHAN(chanlist[i]),
+				     nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;
 			}
 			/*  well, this is next correct channel in list */
@@ -1213,13 +1226,13 @@ static int check_channel_list(struct com
 			/* printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it->chanlist[i]),CR_RANGE(it->chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
 				printk
-					("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
-					dev->minor, i, CR_CHAN(chansegment[i]),
-					CR_RANGE(chansegment[i]),
-					CR_AREF(chansegment[i]),
-					CR_CHAN(chanlist[i % seglen]),
-					CR_RANGE(chanlist[i % seglen]),
-					CR_AREF(chansegment[i % seglen]));
+				    ("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
+				     dev->minor, i, CR_CHAN(chansegment[i]),
+				     CR_RANGE(chansegment[i]),
+				     CR_AREF(chansegment[i]),
+				     CR_CHAN(chanlist[i % seglen]),
+				     CR_RANGE(chanlist[i % seglen]),
+				     CR_AREF(chansegment[i % seglen]));
 				return 0;	/*  chan/gain list is strange */
 			}
 		}
@@ -1230,8 +1243,10 @@ static int check_channel_list(struct com
 	return seglen;
 }
 
-static void setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int *chanlist, unsigned int n_chan, unsigned int seglen)
+static void setup_channel_list(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int *chanlist, unsigned int n_chan,
+			       unsigned int seglen)
 {
 	int i;
 
@@ -1248,7 +1263,8 @@ static void setup_channel_list(struct co
 
 	/* select channel interval to scan */
 	outb(devpriv->act_chanlist[0] | (devpriv->act_chanlist[seglen -
-				1] << 4), dev->iobase + PCL818_MUX);
+							       1] << 4),
+	     dev->iobase + PCL818_MUX);
 }
 
 /*
@@ -1268,7 +1284,7 @@ static int check_single_ended(unsigned i
 ==============================================================================
 */
 static int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+		      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -1386,8 +1402,8 @@ static int ai_cmdtest(struct comedi_devi
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 		if (cmd->convert_arg < this_board->ns_min)
 			cmd->convert_arg = this_board->ns_min;
 		if (tmp != cmd->convert_arg)
@@ -1402,7 +1418,7 @@ static int ai_cmdtest(struct comedi_devi
 
 	if (cmd->chanlist) {
 		if (!check_channel_list(dev, s, cmd->chanlist,
-				cmd->chanlist_len))
+					cmd->chanlist_len))
 			return 5;	/*  incorrect channels list */
 	}
 
@@ -1451,7 +1467,8 @@ static int ai_cmd(struct comedi_device *
 ==============================================================================
  cancel any mode 1-4 AI
 */
-static int pcl818_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcl818_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	if (devpriv->irq_blocked > 0) {
 		printk("pcl818_ai_cancel()\n");
@@ -1467,8 +1484,8 @@ static int pcl818_ai_cancel(struct comed
 		case INT_TYPE_AI1_DMA:
 		case INT_TYPE_AI3_DMA:
 			if (devpriv->neverending_ai ||
-					(!devpriv->neverending_ai &&
-					 devpriv->ai_act_scan > 0)) {
+			    (!devpriv->neverending_ai &&
+			     devpriv->ai_act_scan > 0)) {
 				/* wait for running dma transfer to end, do cleanup in interrupt */
 				goto end;
 			}
@@ -1503,7 +1520,7 @@ static int pcl818_ai_cancel(struct comed
 		}
 	}
 
-      end:
+end:
 	printk("pcl818_ai_cancel() end\n");
 	return 0;
 }
@@ -1612,7 +1629,7 @@ static void rtc_dropped_irq(unsigned lon
 	case INT_TYPE_AI1_DMA_RTC:
 	case INT_TYPE_AI3_DMA_RTC:
 		mod_timer(&devpriv->rtc_irq_timer,
-			jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
+			  jiffies + HZ / devpriv->rtc_freq + 2 * HZ / 100);
 		save_flags(flags);
 		cli();
 		tmp = (CMOS_READ(RTC_INTR_FLAGS) & 0xF0);	/* restart */
@@ -1674,7 +1691,7 @@ static void free_resources(struct comedi
 		if ((devpriv->dma_rtc) && (RTC_lock == 1)) {
 			if (devpriv->rtc_iobase)
 				release_region(devpriv->rtc_iobase,
-					devpriv->rtc_iosize);
+					       devpriv->rtc_iosize);
 		}
 		if (devpriv->dma_rtc)
 			RTC_lock--;
@@ -1710,7 +1727,7 @@ static int pcl818_attach(struct comedi_d
 	/* claim our I/O space */
 	iobase = it->options[0];
 	printk("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
-		dev->minor, this_board->name, iobase);
+	       dev->minor, this_board->name, iobase);
 	devpriv->io_range = this_board->io_range;
 	if ((this_board->fifo) && (it->options[2] == -1)) {	/*  we've board with FIFO and we want to use FIFO */
 		devpriv->io_range = PCLx1xFIFO_RANGE;
@@ -1737,14 +1754,15 @@ static int pcl818_attach(struct comedi_d
 		if (irq) {	/* we want to use IRQ */
 			if (((1 << irq) & this_board->IRQbits) == 0) {
 				printk
-					(", IRQ %u is out of allowed range, DISABLING IT",
-					irq);
+				    (", IRQ %u is out of allowed range, DISABLING IT",
+				     irq);
 				irq = 0;	/* Bad IRQ */
 			} else {
-				if (request_irq(irq, interrupt_pcl818, 0, "pcl818", dev)) {
+				if (request_irq
+				    (irq, interrupt_pcl818, 0, "pcl818", dev)) {
 					printk
-						(", unable to allocate IRQ %u, DISABLING IT",
-						irq);
+					    (", unable to allocate IRQ %u, DISABLING IT",
+					     irq);
 					irq = 0;	/* Can't use IRQ */
 				} else {
 					printk(", irq=%u", irq);
@@ -1769,14 +1787,14 @@ static int pcl818_attach(struct comedi_d
 	if (it->options[2] > 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
 			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
-					"pcl818 (RTC)"))
+					    "pcl818 (RTC)"))
 				goto no_rtc;
 		}
 		devpriv->rtc_iobase = RTC_PORT(0);
 		devpriv->rtc_iosize = RTC_IO_EXTENT;
 		RTC_lock++;
 		if (!request_irq(RTC_IRQ, interrupt_pcl818_ai_mode13_dma_rtc, 0,
-				"pcl818 DMA (RTC)", dev)) {
+				 "pcl818 DMA (RTC)", dev)) {
 			devpriv->dma_rtc = 1;
 			devpriv->rtc_irq = RTC_IRQ;
 			printk(", dma_irq=%u", devpriv->rtc_irq);
@@ -1785,14 +1803,14 @@ static int pcl818_attach(struct comedi_d
 			if (RTC_lock == 0) {
 				if (devpriv->rtc_iobase)
 					release_region(devpriv->rtc_iobase,
-						devpriv->rtc_iosize);
+						       devpriv->rtc_iosize);
 			}
 			devpriv->rtc_iobase = 0;
 			devpriv->rtc_iosize = 0;
 		}
 	}
 
-      no_rtc:
+no_rtc:
 #endif
 	/* grab our DMA */
 	dma = 0;
@@ -1829,17 +1847,17 @@ static int pcl818_attach(struct comedi_d
 			devpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv->dmabuf[1]) {
 				printk
-					(", unable to allocate DMA buffer, FAIL!\n");
+				    (", unable to allocate DMA buffer, FAIL!\n");
 				return -EBUSY;
 			}
 			devpriv->dmapages[1] = pages;
 			devpriv->hwdmaptr[1] =
-				virt_to_bus((void *)devpriv->dmabuf[1]);
+			    virt_to_bus((void *)devpriv->dmabuf[1]);
 			devpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;
 		}
 	}
 
-      no_dma:
+no_dma:
 
 	ret = alloc_subdevices(dev, 4);
 	if (ret < 0)
--- a/drivers/staging/comedi/drivers/pcm3724.c
+++ b/drivers/staging/comedi/drivers/pcm3724.c
@@ -62,7 +62,8 @@ Copy/pasted/hacked from pcm724.c
 #define CR_A_MODE(a)	((a)<<5)
 #define CR_CW		0x80
 
-static int pcm3724_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcm3724_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pcm3724_detach(struct comedi_device *dev);
 
 struct pcm3724_board {
@@ -143,8 +144,8 @@ static int compute_buffer(int config, in
 	return config;
 }
 
-static void do_3724_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	int chanspec)
+static void do_3724_config(struct comedi_device *dev,
+			   struct comedi_subdevice *s, int chanspec)
 {
 	int config;
 	int buffer_config;
@@ -177,14 +178,15 @@ static void do_3724_config(struct comedi
 	outb(config, port_8255_cfg);
 }
 
-static void enable_chan(struct comedi_device *dev, struct comedi_subdevice *s, int chanspec)
+static void enable_chan(struct comedi_device *dev, struct comedi_subdevice *s,
+			int chanspec)
 {
 	unsigned int mask;
 	int gatecfg;
 	struct priv_pcm3724 *priv;
 
 	gatecfg = 0;
-	priv = (struct priv_pcm3724 *) (dev->private);
+	priv = (struct priv_pcm3724 *)(dev->private);
 
 	mask = 1 << CR_CHAN(chanspec);
 	if (s == dev->subdevices) {	/*  subdev 0 */
@@ -215,8 +217,9 @@ static void enable_chan(struct comedi_de
 }
 
 /* overriding the 8255 insn config */
-static int subdev_3724_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int subdev_3724_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int mask;
 	unsigned int bits;
@@ -252,7 +255,8 @@ static int subdev_3724_insn_config(struc
 	return 1;
 }
 
-static int pcm3724_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pcm3724_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	unsigned long iobase;
 	unsigned int iorange;
@@ -265,11 +269,11 @@ static int pcm3724_attach(struct comedi_
 	if (ret < 0)
 		return -ENOMEM;
 
-	((struct priv_pcm3724 *) (dev->private))->dio_1 = 0;
-	((struct priv_pcm3724 *) (dev->private))->dio_2 = 0;
+	((struct priv_pcm3724 *)(dev->private))->dio_1 = 0;
+	((struct priv_pcm3724 *)(dev->private))->dio_2 = 0;
 
 	printk("comedi%d: pcm3724: board=%s, 0x%03lx ", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 	if (!iobase || !request_region(iobase, iorange, "pcm3724")) {
 		printk("I/O port conflict\n");
 		return -EIO;
@@ -287,7 +291,7 @@ static int pcm3724_attach(struct comedi_
 
 	for (i = 0; i < dev->n_subdevices; i++) {
 		subdev_8255_init(dev, dev->subdevices + i, subdev_8255_cb,
-			(unsigned long)(dev->iobase + SIZE_8255 * i));
+				 (unsigned long)(dev->iobase + SIZE_8255 * i));
 		((dev->subdevices) + i)->insn_config = subdev_3724_insn_config;
 	};
 	return 0;
--- a/drivers/staging/comedi/drivers/pcm3730.c
+++ b/drivers/staging/comedi/drivers/pcm3730.c
@@ -28,7 +28,8 @@ Configuration options:
 #define PCM3730_DIB 2
 #define PCM3730_DIC 3
 
-static int pcm3730_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcm3730_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pcm3730_detach(struct comedi_device *dev);
 static struct comedi_driver driver_pcm3730 = {
 	.driver_name = "pcm3730",
@@ -39,8 +40,9 @@ static struct comedi_driver driver_pcm37
 
 COMEDI_INITCLEANUP(driver_pcm3730);
 
-static int pcm3730_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcm3730_do_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -54,8 +56,9 @@ static int pcm3730_do_insn_bits(struct c
 	return 2;
 }
 
-static int pcm3730_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcm3730_di_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -63,7 +66,8 @@ static int pcm3730_di_insn_bits(struct c
 	return 2;
 }
 
-static int pcm3730_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pcm3730_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase;
--- a/drivers/staging/comedi/drivers/pcmad.c
+++ b/drivers/staging/comedi/drivers/pcmad.c
@@ -59,13 +59,13 @@ struct pcmad_board_struct {
 };
 static const struct pcmad_board_struct pcmad_boards[] = {
 	{
-	.name = "pcmad12",
-	.n_ai_bits = 12,
-		},
+	 .name = "pcmad12",
+	 .n_ai_bits = 12,
+	 },
 	{
-	.name = "pcmad16",
-	.n_ai_bits = 16,
-		},
+	 .name = "pcmad16",
+	 .n_ai_bits = 16,
+	 },
 };
 
 #define this_board ((const struct pcmad_board_struct *)(dev->board_ptr))
@@ -93,8 +93,9 @@ COMEDI_INITCLEANUP(driver_pcmad);
 
 #define TIMEOUT	100
 
-static int pcmad_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmad_ai_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan;
--- a/drivers/staging/comedi/drivers/pcmda12.c
+++ b/drivers/staging/comedi/drivers/pcmda12.c
@@ -76,14 +76,14 @@ struct pcmda12_board {
 static const struct comedi_lrange pcmda12_ranges = {
 	3,
 	{
-			UNI_RANGE(5), UNI_RANGE(10), BIP_RANGE(5)
-		}
+	 UNI_RANGE(5), UNI_RANGE(10), BIP_RANGE(5)
+	 }
 };
 
 static const struct pcmda12_board pcmda12_boards[] = {
 	{
-	.name = "pcmda12",
-		},
+	 .name = "pcmda12",
+	 },
 };
 
 /*
@@ -97,7 +97,6 @@ struct pcmda12_private {
 	int simultaneous_xfer_mode;
 };
 
-
 #define devpriv ((struct pcmda12_private *)(dev->private))
 
 /*
@@ -106,7 +105,8 @@ struct pcmda12_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmda12_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcmda12_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pcmda12_detach(struct comedi_device *dev);
 
 static void zero_chans(struct comedi_device *dev);
@@ -140,9 +140,9 @@ static struct comedi_driver driver = {
 };
 
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
 static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+		    struct comedi_insn *insn, unsigned int *data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -150,14 +150,15 @@ static int ao_rinsn(struct comedi_device
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pcmda12_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pcmda12_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase;
 
 	iobase = it->options[0];
 	printk("comedi%d: %s: io: %lx %s ", dev->minor, driver.driver_name,
-		iobase, it->options[1] ? "simultaneous xfer mode enabled" : "");
+	       iobase, it->options[1] ? "simultaneous xfer mode enabled" : "");
 
 	if (!request_region(iobase, IOSIZE, driver.driver_name)) {
 		printk("I/O port conflict\n");
@@ -241,7 +242,7 @@ static void zero_chans(struct comedi_dev
 }
 
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -283,7 +284,7 @@ static int ao_winsn(struct comedi_device
    This is useful for some control applications, I would imagine.
 */
 static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -139,15 +139,16 @@ Configuration Options:
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
 
-typedef int (*comedi_insn_fn_t) (struct comedi_device *, struct comedi_subdevice *,
-	struct comedi_insn *, unsigned int *);
-
-static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-	unsigned int *);
-static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-	unsigned int *);
-static int ao_winsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-	unsigned int *);
+typedef int (*comedi_insn_fn_t) (struct comedi_device *,
+				 struct comedi_subdevice *,
+				 struct comedi_insn *, unsigned int *);
+
+static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *,
+		    struct comedi_insn *, unsigned int *);
+static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *,
+		    struct comedi_insn *, unsigned int *);
+static int ao_winsn(struct comedi_device *, struct comedi_subdevice *,
+		    struct comedi_insn *, unsigned int *);
 
 /*
  * Board descriptions for two imaginary boards.  Describing the
@@ -168,30 +169,30 @@ struct pcmmio_board {
 };
 
 static const struct comedi_lrange ranges_ai =
-	{ 4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0.,
-		10.)}
+    { 4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0.,
+								 10.)}
 };
 
 static const struct comedi_lrange ranges_ao =
-	{ 6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
-	RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
+    { 6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
+	  RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
 };
 
 static const struct pcmmio_board pcmmio_boards[] = {
 	{
-	.name = "pcmmio",
-	.dio_num_asics = 1,
-	.dio_num_ports = 6,
-	.total_iosize = 32,
-	.ai_bits = 16,
-	.ao_bits = 16,
-	.n_ai_chans = 16,
-	.n_ao_chans = 8,
-	.ai_range_table = &ranges_ai,
-	.ao_range_table = &ranges_ao,
-	.ai_rinsn = ai_rinsn,
-	.ao_rinsn = ao_rinsn,
-	.ao_winsn = ao_winsn},
+	 .name = "pcmmio",
+	 .dio_num_asics = 1,
+	 .dio_num_ports = 6,
+	 .total_iosize = 32,
+	 .ai_bits = 16,
+	 .ao_bits = 16,
+	 .n_ai_chans = 16,
+	 .n_ao_chans = 8,
+	 .ai_range_table = &ranges_ai,
+	 .ao_range_table = &ranges_ao,
+	 .ai_rinsn = ai_rinsn,
+	 .ao_rinsn = ao_rinsn,
+	 .ao_winsn = ao_winsn},
 };
 
 /*
@@ -264,7 +265,8 @@ struct pcmmio_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcmmio_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcmmio_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver = {
@@ -295,17 +297,19 @@ static struct comedi_driver driver = {
 	.num_names = ARRAY_SIZE(pcmmio_boards),
 };
 
-static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pcmmio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pcmmio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int pcmmio_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d);
 static void pcmmio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
 static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			  struct comedi_cmd *cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
 static void init_asics(struct comedi_device *dev);	/* sets up/clears ASIC chips to defaults */
@@ -325,7 +329,7 @@ static int pcmmio_attach(struct comedi_d
 {
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
-		thisasic_chanct = 0;
+	    thisasic_chanct = 0;
 	unsigned long iobase;
 	unsigned int irq[MAX_ASICS];
 
@@ -333,12 +337,13 @@ static int pcmmio_attach(struct comedi_d
 	irq[0] = it->options[1];
 
 	printk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
-		iobase);
+	       iobase);
 
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
-			thisboard->total_iosize, driver.driver_name)) {
+				       thisboard->total_iosize,
+				       driver.driver_name)) {
 		printk("I/O port conflict\n");
 		return -EIO;
 	}
@@ -361,7 +366,7 @@ static int pcmmio_attach(struct comedi_d
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		devpriv->asics[asic].num = asic;
 		devpriv->asics[asic].iobase =
-			dev->iobase + 16 + asic * ASIC_IOSIZE;
+		    dev->iobase + 16 + asic * ASIC_IOSIZE;
 		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
 						   this function when we
 						   request_irqs */
@@ -372,7 +377,8 @@ static int pcmmio_attach(struct comedi_d
 	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
 	n_subdevs = n_dio_subdevs + 2;
 	devpriv->sprivs =
-		kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private), GFP_KERNEL);
+	    kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),
+		    GFP_KERNEL);
 	if (!devpriv->sprivs) {
 		printk("cannot allocate subdevice private data structures\n");
 		return -ENOMEM;
@@ -452,11 +458,11 @@ static int pcmmio_attach(struct comedi_d
 				thisasic_chanct = 0;
 			}
 			subpriv->iobases[byte_no] =
-				devpriv->asics[asic].iobase + port;
+			    devpriv->asics[asic].iobase + port;
 
 			if (thisasic_chanct <
-				CHANS_PER_PORT * INTR_PORTS_PER_ASIC
-				&& subpriv->dio.intr.asic < 0) {
+			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
+			    && subpriv->dio.intr.asic < 0) {
 				/* this is an interrupt subdevice, so setup the struct */
 				subpriv->dio.intr.asic = asic;
 				subpriv->dio.intr.active = 0;
@@ -464,13 +470,12 @@ static int pcmmio_attach(struct comedi_d
 				subpriv->dio.intr.first_chan = byte_no * 8;
 				subpriv->dio.intr.asic_chan = thisasic_chanct;
 				subpriv->dio.intr.num_asic_chans =
-					s->n_chan -
-					subpriv->dio.intr.first_chan;
+				    s->n_chan - subpriv->dio.intr.first_chan;
 				s->cancel = pcmmio_cancel;
 				s->do_cmd = pcmmio_cmd;
 				s->do_cmdtest = pcmmio_cmdtest;
 				s->len_chanlist =
-					subpriv->dio.intr.num_asic_chans;
+				    subpriv->dio.intr.num_asic_chans;
 			}
 			thisasic_chanct += CHANS_PER_PORT;
 		}
@@ -489,8 +494,8 @@ static int pcmmio_attach(struct comedi_d
 
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
-			&& request_irq(irq[asic], interrupt_pcmmio,
-				IRQF_SHARED, thisboard->name, dev)) {
+		    && request_irq(irq[asic], interrupt_pcmmio,
+				   IRQF_SHARED, thisboard->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
@@ -550,8 +555,9 @@ static int pcmmio_detach(struct comedi_d
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmmio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -578,20 +584,23 @@ static int pcmmio_dio_insn_bits(struct c
 	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
 		/* address of 8-bit port */
 		unsigned long ioaddr = subpriv->iobases[byte_no],
-			/* bit offset of port in 32-bit doubleword */
-			offset = byte_no * 8;
+		    /* bit offset of port in 32-bit doubleword */
+		    offset = byte_no * 8;
 		/* this 8-bit port's data */
 		unsigned char byte = 0,
-			/* The write mask for this port (if any) */
-			write_mask_byte = (data[0] >> offset) & 0xff,
-			/* The data byte for this port */
-			data_byte = (data[1] >> offset) & 0xff;
+		    /* The write mask for this port (if any) */
+		    write_mask_byte = (data[0] >> offset) & 0xff,
+		    /* The data byte for this port */
+		    data_byte = (data[1] >> offset) & 0xff;
 
 		byte = inb(ioaddr);	/* read all 8-bits for this port */
 
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		printk("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ", byte_no, (unsigned)write_mask_byte, (unsigned)data_byte, offset, ioaddr, (unsigned)byte);
+		printk
+		    ("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ",
+		     byte_no, (unsigned)write_mask_byte, (unsigned)data_byte,
+		     offset, ioaddr, (unsigned)byte);
 #endif
 
 		if (write_mask_byte) {
@@ -624,11 +633,12 @@ static int pcmmio_dio_insn_bits(struct c
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmmio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmmio_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
-		chan % 8;
+	    chan % 8;
 	unsigned long ioaddr;
 	unsigned char byte;
 
@@ -672,8 +682,7 @@ static int pcmmio_dio_insn_config(struct
 	case INSN_CONFIG_DIO_QUERY:
 		/* retreive from shadow register */
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 
@@ -706,7 +715,7 @@ static void init_asics(struct comedi_dev
 			/* now clear all the paged registers */
 			switch_page(dev, asic, page);
 			for (reg = FIRST_PAGED_REG;
-				reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
+			     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
 				outb(0, baseaddr + reg);
 		}
 
@@ -734,7 +743,7 @@ static void switch_page(struct comedi_de
 
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		devpriv->asics[asic].iobase + REG_PAGELOCK);
+	     devpriv->asics[asic].iobase + REG_PAGELOCK);
 }
 
 #ifdef notused
@@ -748,7 +757,7 @@ static void lock_port(struct comedi_devi
 	devpriv->asics[asic].pagelock |= 0x1 << port;
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		devpriv->asics[asic].iobase + REG_PAGELOCK);
+	     devpriv->asics[asic].iobase + REG_PAGELOCK);
 	return;
 }
 
@@ -761,14 +770,14 @@ static void unlock_port(struct comedi_de
 	devpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		devpriv->asics[asic].iobase + REG_PAGELOCK);
+	     devpriv->asics[asic].iobase + REG_PAGELOCK);
 }
 #endif /* notused */
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d)
 {
 	int asic, got1 = 0;
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
@@ -778,124 +787,130 @@ static irqreturn_t interrupt_pcmmio(int 
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
+			spin_lock_irqsave(&devpriv->asics[asic].spinlock,
+					  flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
 			if (int_pend) {
 				int port;
 				for (port = 0; port < INTR_PORTS_PER_ASIC;
-					++port) {
+				     ++port) {
 					if (int_pend & (0x1 << port)) {
 						unsigned char
-							io_lines_with_edges = 0;
+						    io_lines_with_edges = 0;
 						switch_page(dev, asic,
-							PAGE_INT_ID);
+							    PAGE_INT_ID);
 						io_lines_with_edges =
-							inb(iobase +
+						    inb(iobase +
 							REG_INT_ID0 + port);
 
 						if (io_lines_with_edges)
 							/* clear pending interrupt */
 							outb(0, iobase +
-								REG_INT_ID0 +
-								port);
+							     REG_INT_ID0 +
+							     port);
 
 						triggered |=
-							io_lines_with_edges <<
-							port * 8;
+						    io_lines_with_edges <<
+						    port * 8;
 					}
 				}
 
 				++got1;
 			}
 
-			spin_unlock_irqrestore(&devpriv->asics[asic].  spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock,
+					       flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
 				/* TODO here: dispatch io lines to subdevs with commands.. */
-				printk("PCMMIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n", irq, asic, triggered);
+				printk
+				    ("PCMMIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",
+				     irq, asic, triggered);
 				for (s = dev->subdevices + 2;
-					s < dev->subdevices + dev->n_subdevices;
-					++s) {
+				     s < dev->subdevices + dev->n_subdevices;
+				     ++s) {
 					if (subpriv->dio.intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
 						unsigned long flags;
 						unsigned oldevents;
 
-						spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+						spin_lock_irqsave(&subpriv->dio.
+								  intr.spinlock,
+								  flags);
 
 						oldevents = s->async->events;
 
 						if (subpriv->dio.intr.active) {
 							unsigned mytrig =
-								((triggered >>
-									subpriv->
-									dio.
-									intr.
-									asic_chan)
-								& ((0x1 << subpriv->dio.intr.num_asic_chans) - 1)) << subpriv->dio.intr.first_chan;
-							if (mytrig & subpriv->
-								dio.intr.
-								enabled_mask) {
-								unsigned int val =
-									0;
+							    ((triggered >>
+							      subpriv->dio.intr.asic_chan)
+							     &
+							     ((0x1 << subpriv->
+							       dio.intr.
+							       num_asic_chans) -
+							      1)) << subpriv->
+							    dio.intr.first_chan;
+							if (mytrig &
+							    subpriv->dio.
+							    intr.enabled_mask) {
+								unsigned int val
+								    = 0;
 								unsigned int n,
-									ch, len;
+								    ch, len;
 
-								len = s->async->
-									cmd.
-									chanlist_len;
+								len =
+								    s->
+								    async->cmd.chanlist_len;
 								for (n = 0;
-									n < len;
-									n++) {
+								     n < len;
+								     n++) {
 									ch = CR_CHAN(s->async->cmd.chanlist[n]);
 									if (mytrig & (1U << ch)) {
 										val |= (1U << n);
 									}
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((short *) &val)[0])
-									&&
-									comedi_buf_put
-									(s->async, ((short *) &val)[1])) {
+								if (comedi_buf_put(s->async, ((short *)&val)[0])
+								    &&
+								    comedi_buf_put
+								    (s->async,
+								     ((short *)
+								      &val)[1]))
+								{
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */
 									/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 									pcmmio_stop_intr
-										(dev,
-										s);
+									    (dev,
+									     s);
 								}
 
 								/* Check for end of acquisition. */
-								if (!subpriv->
-									dio.
-									intr.
-									continuous)
-								{
+								if (!subpriv->dio.intr.continuous) {
 									/* stop_src == TRIG_COUNT */
 									if (subpriv->dio.intr.stop_count > 0) {
-										subpriv->
-											dio.
-											intr.
-											stop_count--;
+										subpriv->dio.intr.stop_count--;
 										if (subpriv->dio.intr.stop_count == 0) {
 											s->async->events |= COMEDI_CB_EOA;
 											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 											pcmmio_stop_intr
-												(dev,
-												s);
+											    (dev,
+											     s);
 										}
 									}
 								}
 							}
 						}
 
-						spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+						spin_unlock_irqrestore
+						    (&subpriv->dio.intr.
+						     spinlock, flags);
 
 						if (oldevents !=
-							s->async->events) {
+						    s->async->events) {
 							comedi_event(dev, s);
 						}
 
@@ -911,7 +926,8 @@ static irqreturn_t interrupt_pcmmio(int 
 	return IRQ_HANDLED;
 }
 
-static void pcmmio_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pcmmio_stop_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	int nports, firstport, asic, port;
 
@@ -931,7 +947,8 @@ static void pcmmio_stop_intr(struct come
 	}
 }
 
-static int pcmmio_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcmmio_start_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -944,7 +961,7 @@ static int pcmmio_start_intr(struct come
 		struct comedi_cmd *cmd = &s->async->cmd;
 
 		asic = subpriv->dio.intr.asic;
-		if (asic  < 0)
+		if (asic < 0)
 			return 1;	/* not an interrupt
 					   subdev */
 		subpriv->dio.intr.enabled_mask = 0;
@@ -955,12 +972,13 @@ static int pcmmio_start_intr(struct come
 			for (n = 0; n < cmd->chanlist_len; n++) {
 				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
 				pol_bits |= (CR_AREF(cmd->chanlist[n])
-					|| CR_RANGE(cmd->chanlist[n]) ? 1U : 0U)
-					<< CR_CHAN(cmd->chanlist[n]);
+					     || CR_RANGE(cmd->
+							 chanlist[n]) ? 1U : 0U)
+				    << CR_CHAN(cmd->chanlist[n]);
 			}
 		}
 		bits &= ((0x1 << subpriv->dio.intr.num_asic_chans) -
-			1) << subpriv->dio.intr.first_chan;
+			 1) << subpriv->dio.intr.first_chan;
 		subpriv->dio.intr.enabled_mask = bits;
 
 		{		/* the below code configures the board to use a specific IRQ from 0-15. */
@@ -976,16 +994,17 @@ static int pcmmio_start_intr(struct come
 		switch_page(dev, asic, PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
 			unsigned enab =
-				bits >> (subpriv->dio.intr.first_chan + (port -
-					firstport) * 8) & 0xff, pol =
-				pol_bits >> (subpriv->dio.intr.first_chan +
-				(port - firstport) * 8) & 0xff;
+			    bits >> (subpriv->dio.intr.first_chan + (port -
+								     firstport)
+				     * 8) & 0xff, pol =
+			    pol_bits >> (subpriv->dio.intr.first_chan +
+					 (port - firstport) * 8) & 0xff;
 			/* set enab intrs for this subdev.. */
 			outb(enab,
-				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
 			switch_page(dev, asic, PAGE_POL);
 			outb(pol,
-				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
 		}
 	}
 	return 0;
@@ -1008,7 +1027,7 @@ static int pcmmio_cancel(struct comedi_d
  */
 static int
 pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			  unsigned int trignum)
 {
 	unsigned long flags;
 	int event = 0;
@@ -1075,7 +1094,8 @@ static int pcmmio_cmd(struct comedi_devi
 }
 
 static int
-pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
+pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	       struct comedi_cmd *cmd)
 {
 	return comedi_pcm_cmdtest(dev, s, cmd);
 }
@@ -1091,7 +1111,7 @@ static int adc_wait_ready(unsigned long 
 
 /* All this is for AI and AO */
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	unsigned long iobase = subpriv->iobase;
@@ -1110,8 +1130,7 @@ static int ai_rinsn(struct comedi_device
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 		unsigned chan = CR_CHAN(insn->chanspec), range =
-			CR_RANGE(insn->chanspec), aref =
-			CR_AREF(insn->chanspec);
+		    CR_RANGE(insn->chanspec), aref = CR_AREF(insn->chanspec);
 		unsigned char command_byte = 0;
 		unsigned iooffset = 0;
 		short sample, adc_adjust = 0;
@@ -1155,7 +1174,7 @@ static int ai_rinsn(struct comedi_device
 }
 
 static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	for (n = 0; n < insn->n; n++) {
@@ -1185,17 +1204,17 @@ static int wait_dac_ready(unsigned long 
 }
 
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	unsigned iobase = subpriv->iobase, iooffset = 0;
 
 	for (n = 0; n < insn->n; n++) {
 		unsigned chan = CR_CHAN(insn->chanspec), range =
-			CR_RANGE(insn->chanspec);
+		    CR_RANGE(insn->chanspec);
 		if (chan < s->n_chan) {
 			unsigned char command_byte = 0, range_byte =
-				range & ((1 << 4) - 1);
+			    range & ((1 << 4) - 1);
 			if (chan >= 4)
 				chan -= 4, iooffset += 4;
 			/* set the range.. */
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -156,15 +156,15 @@ struct pcmuio_board {
 
 static const struct pcmuio_board pcmuio_boards[] = {
 	{
-	.name = "pcmuio48",
-	.num_asics = 1,
-	.num_ports = 6,
-		},
+	 .name = "pcmuio48",
+	 .num_asics = 1,
+	 .num_ports = 6,
+	 },
 	{
-	.name = "pcmuio96",
-	.num_asics = 2,
-	.num_ports = 12,
-		},
+	 .name = "pcmuio96",
+	 .num_asics = 2,
+	 .num_ports = 12,
+	 },
 };
 
 /*
@@ -223,7 +223,8 @@ struct pcmuio_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcmuio_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcmuio_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver = {
@@ -254,17 +255,19 @@ static struct comedi_driver driver = {
 	.num_names = ARRAY_SIZE(pcmuio_boards),
 };
 
-static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pcmuio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pcmuio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int pcmuio_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d);
 static void pcmuio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
 static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			  struct comedi_cmd *cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
 static void init_asics(struct comedi_device *dev);	/* sets up/clears ASIC chips to defaults */
@@ -292,13 +295,13 @@ static int pcmuio_attach(struct comedi_d
 	irq[1] = it->options[2];
 
 	printk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
-		iobase);
+	       iobase);
 
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
-			thisboard->num_asics * ASIC_IOSIZE,
-			driver.driver_name)) {
+				       thisboard->num_asics * ASIC_IOSIZE,
+				       driver.driver_name)) {
 		printk("I/O port conflict\n");
 		return -EIO;
 	}
@@ -330,7 +333,8 @@ static int pcmuio_attach(struct comedi_d
 	chans_left = CHANS_PER_ASIC * thisboard->num_asics;
 	n_subdevs = CALC_N_SUBDEVS(chans_left);
 	devpriv->sprivs =
-		kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private), GFP_KERNEL);
+	    kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),
+		    GFP_KERNEL);
 	if (!devpriv->sprivs) {
 		printk("cannot allocate subdevice private data structures\n");
 		return -ENOMEM;
@@ -377,11 +381,11 @@ static int pcmuio_attach(struct comedi_d
 				thisasic_chanct = 0;
 			}
 			subpriv->iobases[byte_no] =
-				devpriv->asics[asic].iobase + port;
+			    devpriv->asics[asic].iobase + port;
 
 			if (thisasic_chanct <
-				CHANS_PER_PORT * INTR_PORTS_PER_ASIC
-				&& subpriv->intr.asic < 0) {
+			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
+			    && subpriv->intr.asic < 0) {
 				/* this is an interrupt subdevice, so setup the struct */
 				subpriv->intr.asic = asic;
 				subpriv->intr.active = 0;
@@ -389,7 +393,7 @@ static int pcmuio_attach(struct comedi_d
 				subpriv->intr.first_chan = byte_no * 8;
 				subpriv->intr.asic_chan = thisasic_chanct;
 				subpriv->intr.num_asic_chans =
-					s->n_chan - subpriv->intr.first_chan;
+				    s->n_chan - subpriv->intr.first_chan;
 				dev->read_subdev = s;
 				s->subdev_flags |= SDF_CMD_READ;
 				s->cancel = pcmuio_cancel;
@@ -414,8 +418,8 @@ static int pcmuio_attach(struct comedi_d
 
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
-			&& request_irq(irq[asic], interrupt_pcmuio,
-				IRQF_SHARED, thisboard->name, dev)) {
+		    && request_irq(irq[asic], interrupt_pcmuio,
+				   IRQF_SHARED, thisboard->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
@@ -475,8 +479,9 @@ static int pcmuio_detach(struct comedi_d
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmuio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -503,20 +508,23 @@ static int pcmuio_dio_insn_bits(struct c
 	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
 		/* address of 8-bit port */
 		unsigned long ioaddr = subpriv->iobases[byte_no],
-			/* bit offset of port in 32-bit doubleword */
-			offset = byte_no * 8;
+		    /* bit offset of port in 32-bit doubleword */
+		    offset = byte_no * 8;
 		/* this 8-bit port's data */
 		unsigned char byte = 0,
-			/* The write mask for this port (if any) */
-			write_mask_byte = (data[0] >> offset) & 0xff,
-			/* The data byte for this port */
-			data_byte = (data[1] >> offset) & 0xff;
+		    /* The write mask for this port (if any) */
+		    write_mask_byte = (data[0] >> offset) & 0xff,
+		    /* The data byte for this port */
+		    data_byte = (data[1] >> offset) & 0xff;
 
 		byte = inb(ioaddr);	/* read all 8-bits for this port */
 
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		printk("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ", byte_no, (unsigned)write_mask_byte, (unsigned)data_byte, offset, ioaddr, (unsigned)byte);
+		printk
+		    ("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ",
+		     byte_no, (unsigned)write_mask_byte, (unsigned)data_byte,
+		     offset, ioaddr, (unsigned)byte);
 #endif
 
 		if (write_mask_byte) {
@@ -549,11 +557,12 @@ static int pcmuio_dio_insn_bits(struct c
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmuio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmuio_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
-		chan % 8;
+	    chan % 8;
 	unsigned long ioaddr;
 	unsigned char byte;
 
@@ -597,8 +606,7 @@ static int pcmuio_dio_insn_config(struct
 	case INSN_CONFIG_DIO_QUERY:
 		/* retreive from shadow register */
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 
@@ -631,7 +639,7 @@ static void init_asics(struct comedi_dev
 			/* now clear all the paged registers */
 			switch_page(dev, asic, page);
 			for (reg = FIRST_PAGED_REG;
-				reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
+			     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
 				outb(0, baseaddr + reg);
 		}
 
@@ -659,7 +667,7 @@ static void switch_page(struct comedi_de
 
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
 }
 
 #ifdef notused
@@ -673,7 +681,7 @@ static void lock_port(struct comedi_devi
 	devpriv->asics[asic].pagelock |= 0x1 << port;
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
 }
 
 static void unlock_port(struct comedi_device *dev, int asic, int port)
@@ -685,14 +693,14 @@ static void unlock_port(struct comedi_de
 	devpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
 }
 #endif /* notused */
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d)
 {
 	int asic, got1 = 0;
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
@@ -702,121 +710,130 @@ static irqreturn_t interrupt_pcmuio(int 
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
+			spin_lock_irqsave(&devpriv->asics[asic].spinlock,
+					  flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
 			if (int_pend) {
 				int port;
 				for (port = 0; port < INTR_PORTS_PER_ASIC;
-					++port) {
+				     ++port) {
 					if (int_pend & (0x1 << port)) {
 						unsigned char
-							io_lines_with_edges = 0;
+						    io_lines_with_edges = 0;
 						switch_page(dev, asic,
-							PAGE_INT_ID);
+							    PAGE_INT_ID);
 						io_lines_with_edges =
-							inb(iobase +
+						    inb(iobase +
 							REG_INT_ID0 + port);
 
 						if (io_lines_with_edges)
 							/* clear pending interrupt */
 							outb(0, iobase +
-								REG_INT_ID0 +
-								port);
+							     REG_INT_ID0 +
+							     port);
 
 						triggered |=
-							io_lines_with_edges <<
-							port * 8;
+						    io_lines_with_edges <<
+						    port * 8;
 					}
 				}
 
 				++got1;
 			}
 
-			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock,
+					       flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
 				/* TODO here: dispatch io lines to subdevs with commands.. */
-				printk("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n", irq, asic, triggered);
+				printk
+				    ("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",
+				     irq, asic, triggered);
 				for (s = dev->subdevices;
-					s < dev->subdevices + dev->n_subdevices;
-					++s) {
+				     s < dev->subdevices + dev->n_subdevices;
+				     ++s) {
 					if (subpriv->intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
 						unsigned long flags;
 						unsigned oldevents;
 
-						spin_lock_irqsave (&subpriv->intr.spinlock, flags);
+						spin_lock_irqsave(&subpriv->
+								  intr.spinlock,
+								  flags);
 
 						oldevents = s->async->events;
 
 						if (subpriv->intr.active) {
 							unsigned mytrig =
-								((triggered >>
-									subpriv->
-									intr.
-									asic_chan)
-								& ((0x1 << subpriv->intr.num_asic_chans) - 1)) << subpriv->intr.first_chan;
-							if (mytrig & subpriv->
-								intr.
-								enabled_mask) {
-								unsigned int val =
-									0;
+							    ((triggered >>
+							      subpriv->intr.asic_chan)
+							     &
+							     ((0x1 << subpriv->
+							       intr.
+							       num_asic_chans) -
+							      1)) << subpriv->
+							    intr.first_chan;
+							if (mytrig &
+							    subpriv->intr.enabled_mask)
+							{
+								unsigned int val
+								    = 0;
 								unsigned int n,
-									ch, len;
+								    ch, len;
 
-								len = s->async->
-									cmd.
-									chanlist_len;
+								len =
+								    s->
+								    async->cmd.chanlist_len;
 								for (n = 0;
-									n < len;
-									n++) {
+								     n < len;
+								     n++) {
 									ch = CR_CHAN(s->async->cmd.chanlist[n]);
 									if (mytrig & (1U << ch)) {
 										val |= (1U << n);
 									}
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((short *) &val)[0])
-									&&
-									comedi_buf_put
-									(s->async, ((short *) &val)[1])) {
+								if (comedi_buf_put(s->async, ((short *)&val)[0])
+								    &&
+								    comedi_buf_put
+								    (s->async,
+								     ((short *)
+								      &val)[1]))
+								{
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */
 									/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 									pcmuio_stop_intr
-										(dev,
-										s);
+									    (dev,
+									     s);
 								}
 
 								/* Check for end of acquisition. */
-								if (!subpriv->
-									intr.
-									continuous)
-								{
+								if (!subpriv->intr.continuous) {
 									/* stop_src == TRIG_COUNT */
 									if (subpriv->intr.stop_count > 0) {
-										subpriv->
-											intr.
-											stop_count--;
+										subpriv->intr.stop_count--;
 										if (subpriv->intr.stop_count == 0) {
 											s->async->events |= COMEDI_CB_EOA;
 											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 											pcmuio_stop_intr
-												(dev,
-												s);
+											    (dev,
+											     s);
 										}
 									}
 								}
 							}
 						}
 
-						spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+						spin_unlock_irqrestore
+						    (&subpriv->intr.spinlock,
+						     flags);
 
 						if (oldevents !=
-							s->async->events) {
+						    s->async->events) {
 							comedi_event(dev, s);
 						}
 
@@ -832,7 +849,8 @@ static irqreturn_t interrupt_pcmuio(int 
 	return IRQ_HANDLED;
 }
 
-static void pcmuio_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pcmuio_stop_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	int nports, firstport, asic, port;
 
@@ -852,7 +870,8 @@ static void pcmuio_stop_intr(struct come
 	}
 }
 
-static int pcmuio_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcmuio_start_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -876,27 +895,29 @@ static int pcmuio_start_intr(struct come
 			for (n = 0; n < cmd->chanlist_len; n++) {
 				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
 				pol_bits |= (CR_AREF(cmd->chanlist[n])
-					|| CR_RANGE(cmd->chanlist[n]) ? 1U : 0U)
-					<< CR_CHAN(cmd->chanlist[n]);
+					     || CR_RANGE(cmd->
+							 chanlist[n]) ? 1U : 0U)
+				    << CR_CHAN(cmd->chanlist[n]);
 			}
 		}
 		bits &= ((0x1 << subpriv->intr.num_asic_chans) -
-			1) << subpriv->intr.first_chan;
+			 1) << subpriv->intr.first_chan;
 		subpriv->intr.enabled_mask = bits;
 
 		switch_page(dev, asic, PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
 			unsigned enab =
-				bits >> (subpriv->intr.first_chan + (port -
-					firstport) * 8) & 0xff, pol =
-				pol_bits >> (subpriv->intr.first_chan + (port -
-					firstport) * 8) & 0xff;
+			    bits >> (subpriv->intr.first_chan + (port -
+								 firstport) *
+				     8) & 0xff, pol =
+			    pol_bits >> (subpriv->intr.first_chan +
+					 (port - firstport) * 8) & 0xff;
 			/* set enab intrs for this subdev.. */
 			outb(enab,
-				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
 			switch_page(dev, asic, PAGE_POL);
 			outb(pol,
-				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
 		}
 	}
 	return 0;
@@ -919,7 +940,7 @@ static int pcmuio_cancel(struct comedi_d
  */
 static int
 pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			  unsigned int trignum)
 {
 	unsigned long flags;
 	int event = 0;
@@ -986,7 +1007,8 @@ static int pcmuio_cmd(struct comedi_devi
 }
 
 static int
-pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
+pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	       struct comedi_cmd *cmd)
 {
 	return comedi_pcm_cmdtest(dev, s, cmd);
 }
--- a/drivers/staging/comedi/drivers/plx9080.h
+++ b/drivers/staging/comedi/drivers/plx9080.h
@@ -404,8 +404,8 @@ static inline int plx9080_abort_dma(void
 	}
 	if (i == timeout) {
 		printk
-			("plx9080: cancel() timed out waiting for dma %i done clear\n",
-			channel);
+		    ("plx9080: cancel() timed out waiting for dma %i done clear\n",
+		     channel);
 		return -ETIMEDOUT;
 	}
 	/*  disable and abort channel */
@@ -418,8 +418,8 @@ static inline int plx9080_abort_dma(void
 	}
 	if (i == timeout) {
 		printk
-			("plx9080: cancel() timed out waiting for dma %i done set\n",
-			channel);
+		    ("plx9080: cancel() timed out waiting for dma %i done set\n",
+		     channel);
 		return -ETIMEDOUT;
 	}
 
--- a/drivers/staging/comedi/drivers/poc.c
+++ b/drivers/staging/comedi/drivers/poc.c
@@ -44,14 +44,16 @@ Configuration options:
 static int poc_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int poc_detach(struct comedi_device *dev);
 static int readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 
 static int dac02_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pcl733_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pcl734_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
+static int pcl733_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int pcl734_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 
 struct boarddef_struct {
 	const char *name;
@@ -60,44 +62,44 @@ struct boarddef_struct {
 	int type;
 	int n_chan;
 	int n_bits;
-	int (*winsn) (struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-		unsigned int *);
-	int (*rinsn) (struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-		unsigned int *);
-	int (*insnbits) (struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-		unsigned int *);
+	int (*winsn) (struct comedi_device *, struct comedi_subdevice *,
+		      struct comedi_insn *, unsigned int *);
+	int (*rinsn) (struct comedi_device *, struct comedi_subdevice *,
+		      struct comedi_insn *, unsigned int *);
+	int (*insnbits) (struct comedi_device *, struct comedi_subdevice *,
+			 struct comedi_insn *, unsigned int *);
 	const struct comedi_lrange *range;
 };
 static const struct boarddef_struct boards[] = {
 	{
-	.name = "dac02",
-	.iosize = 8,
-			/*	.setup = dac02_setup, */
-	.type = COMEDI_SUBD_AO,
-	.n_chan = 2,
-	.n_bits = 12,
-	.winsn = dac02_ao_winsn,
-	.rinsn = readback_insn,
-	.range = &range_unknown,
-		},
+	 .name = "dac02",
+	 .iosize = 8,
+	 /*      .setup = dac02_setup, */
+	 .type = COMEDI_SUBD_AO,
+	 .n_chan = 2,
+	 .n_bits = 12,
+	 .winsn = dac02_ao_winsn,
+	 .rinsn = readback_insn,
+	 .range = &range_unknown,
+	 },
 	{
-	.name = "pcl733",
-	.iosize = 4,
-	.type = COMEDI_SUBD_DI,
-	.n_chan = 32,
-	.n_bits = 1,
-	.insnbits = pcl733_insn_bits,
-	.range = &range_digital,
-		},
+	 .name = "pcl733",
+	 .iosize = 4,
+	 .type = COMEDI_SUBD_DI,
+	 .n_chan = 32,
+	 .n_bits = 1,
+	 .insnbits = pcl733_insn_bits,
+	 .range = &range_digital,
+	 },
 	{
-	.name = "pcl734",
-	.iosize = 4,
-	.type = COMEDI_SUBD_DO,
-	.n_chan = 32,
-	.n_bits = 1,
-	.insnbits = pcl734_insn_bits,
-	.range = &range_digital,
-		},
+	 .name = "pcl734",
+	 .iosize = 4,
+	 .type = COMEDI_SUBD_DO,
+	 .n_chan = 32,
+	 .n_bits = 1,
+	 .insnbits = pcl734_insn_bits,
+	 .range = &range_digital,
+	 },
 };
 
 #define n_boards (sizeof(boards)/sizeof(boards[0]))
@@ -121,7 +123,7 @@ static int poc_attach(struct comedi_devi
 
 	iobase = it->options[0];
 	printk("comedi%d: poc: using %s iobase 0x%lx\n", dev->minor,
-		this_board->name, iobase);
+	       this_board->name, iobase);
 
 	dev->board_name = this_board->name;
 
@@ -133,7 +135,9 @@ static int poc_attach(struct comedi_devi
 	iosize = this_board->iosize;
 	/* check if io addresses are available */
 	if (!request_region(iobase, iosize, "dac02")) {
-		printk("I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n", iobase, iobase + iosize - 1);
+		printk
+		    ("I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
+		     iobase, iobase + iosize - 1);
 		return -EIO;
 	}
 	dev->iobase = iobase;
@@ -171,12 +175,12 @@ static int poc_detach(struct comedi_devi
 }
 
 static int readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int chan;
 
 	chan = CR_CHAN(insn->chanspec);
-	data[0] = ((unsigned int *) dev->private)[chan];
+	data[0] = ((unsigned int *)dev->private)[chan];
 
 	return 1;
 }
@@ -186,14 +190,14 @@ static int readback_insn(struct comedi_d
 #define DAC02_MSB(a)	(2 * a + 1)
 
 static int dac02_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int temp;
 	int chan;
 	int output;
 
 	chan = CR_CHAN(insn->chanspec);
-	((unsigned int *) dev->private)[chan] = data[0];
+	((unsigned int *)dev->private)[chan] = data[0];
 	output = data[0];
 #ifdef wrong
 	/*  convert to complementary binary if range is bipolar */
@@ -208,8 +212,9 @@ static int dac02_ao_winsn(struct comedi_
 	return 1;
 }
 
-static int pcl733_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl733_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -222,8 +227,9 @@ static int pcl733_insn_bits(struct comed
 	return 2;
 }
 
-static int pcl734_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcl734_insn_bits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -184,11 +184,11 @@ static struct local_info_t *dev_table[MA
  */
 
 static const struct comedi_lrange range_daqp_ai = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25)
-	}
+							BIP_RANGE(10),
+							BIP_RANGE(5),
+							BIP_RANGE(2.5),
+							BIP_RANGE(1.25)
+							}
 };
 
 static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
@@ -211,7 +211,7 @@ static struct comedi_driver driver_daqp 
 static void daqp_dump(struct comedi_device *dev)
 {
 	printk("DAQP: status %02x; aux status %02x\n",
-		inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
+	       inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
 }
 
 static void hex_dump(char *str, void *ptr, int len)
@@ -236,7 +236,7 @@ static void hex_dump(char *str, void *pt
 
 static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -264,7 +264,7 @@ static int daqp_ai_cancel(struct comedi_
 
 static void daqp_interrupt(int irq, void *dev_id)
 {
-	struct local_info_t *local = (struct local_info_t *) dev_id;
+	struct local_info_t *local = (struct local_info_t *)dev_id;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	int loop_limit = 10000;
@@ -272,7 +272,7 @@ static void daqp_interrupt(int irq, void
 
 	if (local == NULL) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): irq %d for unknown device.\n", irq);
+		       "daqp_interrupt(): irq %d for unknown device.\n", irq);
 		return;
 	}
 
@@ -284,20 +284,20 @@ static void daqp_interrupt(int irq, void
 
 	if (!dev->attached) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): struct comedi_device not yet attached.\n");
+		       "daqp_interrupt(): struct comedi_device not yet attached.\n");
 		return;
 	}
 
 	s = local->s;
 	if (s == NULL) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): NULL comedi_subdevice.\n");
+		       "daqp_interrupt(): NULL comedi_subdevice.\n");
 		return;
 	}
 
-	if ((struct local_info_t *) s->private != local) {
+	if ((struct local_info_t *)s->private != local) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): invalid comedi_subdevice.\n");
+		       "daqp_interrupt(): invalid comedi_subdevice.\n");
 		return;
 	}
 
@@ -311,13 +311,13 @@ static void daqp_interrupt(int irq, void
 	case buffer:
 
 		while (!((status = inb(dev->iobase + DAQP_STATUS))
-				& DAQP_STATUS_FIFO_EMPTY)) {
+			 & DAQP_STATUS_FIFO_EMPTY)) {
 
 			short data;
 
 			if (status & DAQP_STATUS_DATA_LOST) {
 				s->async->events |=
-					COMEDI_CB_EOA | COMEDI_CB_OVERFLOW;
+				    COMEDI_CB_EOA | COMEDI_CB_OVERFLOW;
 				printk("daqp: data lost\n");
 				daqp_ai_cancel(dev, s);
 				break;
@@ -348,7 +348,7 @@ static void daqp_interrupt(int irq, void
 
 		if (loop_limit <= 0) {
 			printk(KERN_WARNING
-				"loop_limit reached in daqp_interrupt()\n");
+			       "loop_limit reached in daqp_interrupt()\n");
 			daqp_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		}
@@ -361,10 +361,11 @@ static void daqp_interrupt(int irq, void
 
 /* One-shot analog data acquisition routine */
 
-static int daqp_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqp_ai_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 	int i;
 	int v;
 	int counter = 10000;
@@ -384,7 +385,7 @@ static int daqp_ai_insn_read(struct come
 	/* Program one scan list entry */
 
 	v = DAQP_SCANLIST_CHANNEL(CR_CHAN(insn->chanspec))
-		| DAQP_SCANLIST_GAIN(CR_RANGE(insn->chanspec));
+	    | DAQP_SCANLIST_GAIN(CR_RANGE(insn->chanspec));
 
 	if (CR_AREF(insn->chanspec) == AREF_DIFF) {
 		v |= DAQP_SCANLIST_DIFFERENTIAL;
@@ -402,7 +403,7 @@ static int daqp_ai_insn_read(struct come
 	/* Set trigger */
 
 	v = DAQP_CONTROL_TRIGGER_ONESHOT | DAQP_CONTROL_TRIGGER_INTERNAL
-		| DAQP_CONTROL_PACER_100kHz | DAQP_CONTROL_EOS_INT_ENABLE;
+	    | DAQP_CONTROL_PACER_100kHz | DAQP_CONTROL_EOS_INT_ENABLE;
 
 	outb(v, dev->iobase + DAQP_CONTROL);
 
@@ -411,7 +412,7 @@ static int daqp_ai_insn_read(struct come
 	 */
 
 	while (--counter
-		&& (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
+	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
 	if (!counter) {
 		printk("daqp: couldn't clear interrupts in status register\n");
 		return -1;
@@ -427,7 +428,7 @@ static int daqp_ai_insn_read(struct come
 
 		/* Start conversion */
 		outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
-			dev->iobase + DAQP_COMMAND);
+		     dev->iobase + DAQP_COMMAND);
 
 		/* Wait for interrupt service routine to unblock semaphore */
 		/* Maybe could use a timeout here, but it's interruptible */
@@ -467,8 +468,8 @@ static int daqp_ns_to_timer(unsigned int
  * the command passes.
  */
 
-static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int daqp_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -507,7 +508,7 @@ static int daqp_ai_cmdtest(struct comedi
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_FOLLOW)
+	    cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;
 	if (cmd->convert_src != TRIG_NOW && cmd->convert_src != TRIG_TIMER)
 		err++;
@@ -528,7 +529,7 @@ static int daqp_ai_cmdtest(struct comedi
 #define MAX_SPEED	10000	/* 100 kHz - in nanoseconds */
 
 	if (cmd->scan_begin_src == TRIG_TIMER
-		&& cmd->scan_begin_arg < MAX_SPEED) {
+	    && cmd->scan_begin_arg < MAX_SPEED) {
 		cmd->scan_begin_arg = MAX_SPEED;
 		err++;
 	}
@@ -539,8 +540,7 @@ static int daqp_ai_cmdtest(struct comedi
 	 */
 
 	if (cmd->scan_begin_src == TRIG_TIMER && cmd->convert_src == TRIG_TIMER
-		&& cmd->scan_begin_arg !=
-		cmd->convert_arg * cmd->scan_end_arg) {
+	    && cmd->scan_begin_arg != cmd->convert_arg * cmd->scan_end_arg) {
 		err++;
 	}
 
@@ -574,7 +574,7 @@ static int daqp_ai_cmdtest(struct comedi
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		daqp_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -582,7 +582,7 @@ static int daqp_ai_cmdtest(struct comedi
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		daqp_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -595,7 +595,7 @@ static int daqp_ai_cmdtest(struct comedi
 
 static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int counter = 100;
 	int scanlist_start_on_every_entry;
@@ -631,14 +631,14 @@ static int daqp_ai_cmd(struct comedi_dev
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		int counter = daqp_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					       cmd->flags & TRIG_ROUND_MASK);
 		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
 		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
 		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
 		scanlist_start_on_every_entry = 1;
 	} else {
 		int counter = daqp_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					       cmd->flags & TRIG_ROUND_MASK);
 		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
 		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
 		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
@@ -654,7 +654,7 @@ static int daqp_ai_cmd(struct comedi_dev
 		/* Program one scan list entry */
 
 		v = DAQP_SCANLIST_CHANNEL(CR_CHAN(chanspec))
-			| DAQP_SCANLIST_GAIN(CR_RANGE(chanspec));
+		    | DAQP_SCANLIST_GAIN(CR_RANGE(chanspec));
 
 		if (CR_AREF(chanspec) == AREF_DIFF) {
 			v |= DAQP_SCANLIST_DIFFERENTIAL;
@@ -765,7 +765,7 @@ static int daqp_ai_cmd(struct comedi_dev
 	/* Set trigger */
 
 	v = DAQP_CONTROL_TRIGGER_CONTINUOUS | DAQP_CONTROL_TRIGGER_INTERNAL
-		| DAQP_CONTROL_PACER_5MHz | DAQP_CONTROL_FIFO_INT_ENABLE;
+	    | DAQP_CONTROL_PACER_5MHz | DAQP_CONTROL_FIFO_INT_ENABLE;
 
 	outb(v, dev->iobase + DAQP_CONTROL);
 
@@ -774,7 +774,7 @@ static int daqp_ai_cmd(struct comedi_dev
 	 */
 
 	while (--counter
-		&& (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
+	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
 	if (!counter) {
 		printk("daqp: couldn't clear interrupts in status register\n");
 		return -1;
@@ -786,17 +786,18 @@ static int daqp_ai_cmd(struct comedi_dev
 
 	/* Start conversion */
 	outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
-		dev->iobase + DAQP_COMMAND);
+	     dev->iobase + DAQP_COMMAND);
 
 	return 0;
 }
 
 /* Single-shot analog output routine */
 
-static int daqp_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqp_ao_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 	int d;
 	unsigned int chan;
 
@@ -820,10 +821,11 @@ static int daqp_ao_insn_write(struct com
 
 /* Digital input routine */
 
-static int daqp_di_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqp_di_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -836,10 +838,11 @@ static int daqp_di_insn_read(struct come
 
 /* Digital output routine */
 
-static int daqp_do_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqp_do_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -866,7 +869,7 @@ static int daqp_attach(struct comedi_dev
 
 	if (it->options[0] < 0 || it->options[0] >= MAX_DEV || !local) {
 		printk("comedi%d: No such daqp device %d\n",
-			dev->minor, it->options[0]);
+		       dev->minor, it->options[0]);
 		return -EIO;
 	}
 
@@ -899,7 +902,7 @@ static int daqp_attach(struct comedi_dev
 					break;
 			i++;
 			if ((i < tuple.TupleDataLen - 4)
-				&& (strncmp(buf + i, "DAQP", 4) == 0)) {
+			    && (strncmp(buf + i, "DAQP", 4) == 0)) {
 				strncpy(local->board_name, buf + i,
 					sizeof(local->board_name));
 			}
@@ -913,7 +916,7 @@ static int daqp_attach(struct comedi_dev
 		return ret;
 
 	printk("comedi%d: attaching daqp%d (io 0x%04lx)\n",
-		dev->minor, it->options[0], dev->iobase);
+	       dev->minor, it->options[0], dev->iobase);
 
 	s = dev->subdevices + 0;
 	dev->read_subdev = s;
@@ -1234,7 +1237,7 @@ static void daqp_cs_config(struct pcmcia
 		/* If we got this far, we're cool! */
 		break;
 
-	      next_entry:
+next_entry:
 		last_ret = pcmcia_get_next_tuple(link, &tuple);
 		if (last_ret) {
 			cs_error(link, GetNextTuple, last_ret);
@@ -1280,20 +1283,20 @@ static void daqp_cs_config(struct pcmcia
 
 	/* Finally, report what we've done */
 	printk(KERN_INFO "%s: index 0x%02x",
-		dev->node.dev_name, link->conf.ConfigIndex);
+	       dev->node.dev_name, link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %u", link->irq.AssignedIRQ);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-			link->io.BasePort1 + link->io.NumPorts1 - 1);
+		       link->io.BasePort1 + link->io.NumPorts1 - 1);
 	if (link->io.NumPorts2)
 		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
-			link->io.BasePort2 + link->io.NumPorts2 - 1);
+		       link->io.BasePort2 + link->io.NumPorts2 - 1);
 	printk("\n");
 
 	return;
 
-      cs_failed:
+cs_failed:
 	daqp_cs_release(link);
 
 }				/* daqp_cs_config */
@@ -1354,7 +1357,7 @@ struct pcmcia_driver daqp_cs_driver = {
 	.id_table = daqp_cs_id_table,
 	.owner = THIS_MODULE,
 	.drv = {
-			.name = dev_info,
+		.name = dev_info,
 		},
 };
 
--- a/drivers/staging/comedi/drivers/rtd520.c
+++ b/drivers/staging/comedi/drivers/rtd520.c
@@ -198,70 +198,100 @@ Configuration options:
   The board has 3 input modes and the gains of 1,2,4,...32 (, 64, 128)
 */
 static const struct comedi_lrange rtd_ai_7520_range = { 18, {
-			/* +-5V input range gain steps */
-			BIP_RANGE(5.0),
-			BIP_RANGE(5.0 / 2),
-			BIP_RANGE(5.0 / 4),
-			BIP_RANGE(5.0 / 8),
-			BIP_RANGE(5.0 / 16),
-			BIP_RANGE(5.0 / 32),
-			/* +-10V input range gain steps */
-			BIP_RANGE(10.0),
-			BIP_RANGE(10.0 / 2),
-			BIP_RANGE(10.0 / 4),
-			BIP_RANGE(10.0 / 8),
-			BIP_RANGE(10.0 / 16),
-			BIP_RANGE(10.0 / 32),
-			/* +10V input range gain steps */
-			UNI_RANGE(10.0),
-			UNI_RANGE(10.0 / 2),
-			UNI_RANGE(10.0 / 4),
-			UNI_RANGE(10.0 / 8),
-			UNI_RANGE(10.0 / 16),
-			UNI_RANGE(10.0 / 32),
+							     /* +-5V input range gain steps */
+							     BIP_RANGE(5.0),
+							     BIP_RANGE(5.0 / 2),
+							     BIP_RANGE(5.0 / 4),
+							     BIP_RANGE(5.0 / 8),
+							     BIP_RANGE(5.0 /
+								       16),
+							     BIP_RANGE(5.0 /
+								       32),
+							     /* +-10V input range gain steps */
+							     BIP_RANGE(10.0),
+							     BIP_RANGE(10.0 /
+								       2),
+							     BIP_RANGE(10.0 /
+								       4),
+							     BIP_RANGE(10.0 /
+								       8),
+							     BIP_RANGE(10.0 /
+								       16),
+							     BIP_RANGE(10.0 /
+								       32),
+							     /* +10V input range gain steps */
+							     UNI_RANGE(10.0),
+							     UNI_RANGE(10.0 /
+								       2),
+							     UNI_RANGE(10.0 /
+								       4),
+							     UNI_RANGE(10.0 /
+								       8),
+							     UNI_RANGE(10.0 /
+								       16),
+							     UNI_RANGE(10.0 /
+								       32),
 
-	}
+							     }
 };
 
 /* PCI4520 has two more gains (6 more entries) */
 static const struct comedi_lrange rtd_ai_4520_range = { 24, {
-			/* +-5V input range gain steps */
-			BIP_RANGE(5.0),
-			BIP_RANGE(5.0 / 2),
-			BIP_RANGE(5.0 / 4),
-			BIP_RANGE(5.0 / 8),
-			BIP_RANGE(5.0 / 16),
-			BIP_RANGE(5.0 / 32),
-			BIP_RANGE(5.0 / 64),
-			BIP_RANGE(5.0 / 128),
-			/* +-10V input range gain steps */
-			BIP_RANGE(10.0),
-			BIP_RANGE(10.0 / 2),
-			BIP_RANGE(10.0 / 4),
-			BIP_RANGE(10.0 / 8),
-			BIP_RANGE(10.0 / 16),
-			BIP_RANGE(10.0 / 32),
-			BIP_RANGE(10.0 / 64),
-			BIP_RANGE(10.0 / 128),
-			/* +10V input range gain steps */
-			UNI_RANGE(10.0),
-			UNI_RANGE(10.0 / 2),
-			UNI_RANGE(10.0 / 4),
-			UNI_RANGE(10.0 / 8),
-			UNI_RANGE(10.0 / 16),
-			UNI_RANGE(10.0 / 32),
-			UNI_RANGE(10.0 / 64),
-			UNI_RANGE(10.0 / 128),
-	}
+							     /* +-5V input range gain steps */
+							     BIP_RANGE(5.0),
+							     BIP_RANGE(5.0 / 2),
+							     BIP_RANGE(5.0 / 4),
+							     BIP_RANGE(5.0 / 8),
+							     BIP_RANGE(5.0 /
+								       16),
+							     BIP_RANGE(5.0 /
+								       32),
+							     BIP_RANGE(5.0 /
+								       64),
+							     BIP_RANGE(5.0 /
+								       128),
+							     /* +-10V input range gain steps */
+							     BIP_RANGE(10.0),
+							     BIP_RANGE(10.0 /
+								       2),
+							     BIP_RANGE(10.0 /
+								       4),
+							     BIP_RANGE(10.0 /
+								       8),
+							     BIP_RANGE(10.0 /
+								       16),
+							     BIP_RANGE(10.0 /
+								       32),
+							     BIP_RANGE(10.0 /
+								       64),
+							     BIP_RANGE(10.0 /
+								       128),
+							     /* +10V input range gain steps */
+							     UNI_RANGE(10.0),
+							     UNI_RANGE(10.0 /
+								       2),
+							     UNI_RANGE(10.0 /
+								       4),
+							     UNI_RANGE(10.0 /
+								       8),
+							     UNI_RANGE(10.0 /
+								       16),
+							     UNI_RANGE(10.0 /
+								       32),
+							     UNI_RANGE(10.0 /
+								       64),
+							     UNI_RANGE(10.0 /
+								       128),
+							     }
 };
 
 /* Table order matches range values */
 static const struct comedi_lrange rtd_ao_range = { 4, {
-			RANGE(0, 5),
-			RANGE(0, 10),
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-	}
+						       RANGE(0, 5),
+						       RANGE(0, 10),
+						       RANGE(-5, 5),
+						       RANGE(-10, 10),
+						       }
 };
 
 /*
@@ -279,29 +309,30 @@ struct rtdBoard {
 
 static const struct rtdBoard rtd520Boards[] = {
 	{
-	.name = "DM7520",
-	.device_id = 0x7520,
-	.aiChans = 16,
-	.aiBits = 12,
-	.aiMaxGain = 32,
-	.range10Start = 6,
-	.rangeUniStart = 12,
-		},
+	 .name = "DM7520",
+	 .device_id = 0x7520,
+	 .aiChans = 16,
+	 .aiBits = 12,
+	 .aiMaxGain = 32,
+	 .range10Start = 6,
+	 .rangeUniStart = 12,
+	 },
 	{
-	.name = "PCI4520",
-	.device_id = 0x4520,
-	.aiChans = 16,
-	.aiBits = 12,
-	.aiMaxGain = 128,
-	.range10Start = 8,
-	.rangeUniStart = 16,
-		},
+	 .name = "PCI4520",
+	 .device_id = 0x4520,
+	 .aiChans = 16,
+	 .aiBits = 12,
+	 .aiMaxGain = 128,
+	 .range10Start = 8,
+	 .rangeUniStart = 16,
+	 },
 };
 
 static DEFINE_PCI_DEVICE_TABLE(rtd520_pci_table) = {
-	{PCI_VENDOR_ID_RTD, 0x7520, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_RTD, 0x4520, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_RTD, 0x7520, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_RTD, 0x4520, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, rtd520_pci_table);
@@ -692,17 +723,19 @@ static struct comedi_driver rtd520Driver
 };
 
 static int rtd_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			struct comedi_insn *insn, unsigned int *data);
 static int rtd_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			struct comedi_insn *insn, unsigned int *data);
 static int rtd_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int rtd_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int rtd_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			struct comedi_insn *insn, unsigned int *data);
+static int rtd_dio_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int rtd_dio_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int rtd_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			  struct comedi_cmd *cmd);
 static int rtd_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int rtd_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 /* static int rtd_ai_poll (struct comedi_device *dev,struct comedi_subdevice *s); */
@@ -747,31 +780,29 @@ static int rtd_attach(struct comedi_devi
 	 * Probe the device to determine what device in the series it is.
 	 */
 	for (pcidev = pci_get_device(PCI_VENDOR_ID_RTD, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_VENDOR_ID_RTD, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_VENDOR_ID_RTD, PCI_ANY_ID, pcidev)) {
 		int i;
 
 		if (it->options[0] || it->options[1]) {
 			if (pcidev->bus->number != it->options[0]
-				|| PCI_SLOT(pcidev->devfn) !=
-				it->options[1]) {
+			    || PCI_SLOT(pcidev->devfn) != it->options[1]) {
 				continue;
 			}
 		}
-		for (i = 0; i < ARRAY_SIZE(rtd520Boards); ++i)
-		{
-			if (pcidev->device == rtd520Boards[i].device_id)
-			{
+		for (i = 0; i < ARRAY_SIZE(rtd520Boards); ++i) {
+			if (pcidev->device == rtd520Boards[i].device_id) {
 				dev->board_ptr = &rtd520Boards[i];
 				break;
 			}
 		}
-		if (dev->board_ptr) break;	/* found one */
+		if (dev->board_ptr)
+			break;	/* found one */
 	}
 	if (!pcidev) {
 		if (it->options[0] && it->options[1]) {
 			printk("No RTD card at bus=%d slot=%d.\n",
-				it->options[0], it->options[1]);
+			       it->options[0], it->options[1]);
 		} else {
 			printk("No RTD card found.\n");
 		}
@@ -813,16 +844,16 @@ static int rtd_attach(struct comedi_devi
 		/*uint32_t epld_version; */
 
 		pci_read_config_word(devpriv->pci_dev, PCI_REVISION_ID,
-			&revision);
+				     &revision);
 		DPRINTK("%s: PCI revision %d.\n", dev->board_name, revision);
 
 		pci_read_config_byte(devpriv->pci_dev,
-			PCI_LATENCY_TIMER, &pci_latency);
+				     PCI_LATENCY_TIMER, &pci_latency);
 		if (pci_latency < 32) {
 			printk("%s: PCI latency changed from %d to %d\n",
-				dev->board_name, pci_latency, 32);
+			       dev->board_name, pci_latency, 32);
 			pci_write_config_byte(devpriv->pci_dev,
-				PCI_LATENCY_TIMER, 32);
+					      PCI_LATENCY_TIMER, 32);
 		} else {
 			DPRINTK("rtd520: PCI latency = %d\n", pci_latency);
 		}
@@ -854,8 +885,7 @@ static int rtd_attach(struct comedi_devi
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags =
-		SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF |
-		SDF_CMD_READ;
+	    SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;
 	s->n_chan = thisboard->aiChans;
 	s->maxdata = (1 << thisboard->aiBits) - 1;
 	if (thisboard->aiMaxGain <= 32) {
@@ -868,7 +898,7 @@ static int rtd_attach(struct comedi_devi
 	s->do_cmd = rtd_ai_cmd;
 	s->do_cmdtest = rtd_ai_cmdtest;
 	s->cancel = rtd_ai_cancel;
-	/* s->poll = rtd_ai_poll; */ /* not ready yet */
+	/* s->poll = rtd_ai_poll; *//* not ready yet */
 
 	s = dev->subdevices + 1;
 	/* analog output subdevice */
@@ -901,7 +931,7 @@ static int rtd_attach(struct comedi_devi
 	/* initialize board, per RTD spec */
 	/* also, initialize shadow registers */
 	RtdResetBoard(dev);
-	udelay(100);	/* needed? */
+	udelay(100);		/* needed? */
 	RtdPlxInterruptWrite(dev, 0);
 	RtdInterruptMask(dev, 0);	/* and sets shadow */
 	RtdInterruptClearMask(dev, ~0);	/* and sets shadow */
@@ -921,11 +951,11 @@ static int rtd_attach(struct comedi_devi
 
 	/* check if our interrupt is available and get it */
 	ret = request_irq(devpriv->pci_dev->irq, rtd_interrupt,
-				 IRQF_SHARED, DRV_NAME, dev);
+			  IRQF_SHARED, DRV_NAME, dev);
 
 	if (ret < 0) {
 		printk("Could not get interrupt! (%u)\n",
-			devpriv->pci_dev->irq);
+		       devpriv->pci_dev->irq);
 		return ret;
 	}
 	dev->irq = devpriv->pci_dev->irq;
@@ -948,9 +978,11 @@ static int rtd_attach(struct comedi_devi
 
 		for (index = 0; index < DMA_CHAIN_COUNT; index++) {
 			devpriv->dma0Buff[index] =
-				pci_alloc_consistent(devpriv->pci_dev,
-				sizeof(u16) * devpriv->fifoLen / 2,
-				&devpriv->dma0BuffPhysAddr[index]);
+			    pci_alloc_consistent(devpriv->pci_dev,
+						 sizeof(u16) *
+						 devpriv->fifoLen / 2,
+						 &devpriv->
+						 dma0BuffPhysAddr[index]);
 			if (devpriv->dma0Buff[index] == NULL) {
 				ret = -ENOMEM;
 				goto rtd_attach_die_error;
@@ -962,21 +994,23 @@ static int rtd_attach(struct comedi_devi
 
 		/* setup DMA descriptor ring (use cpu_to_le32 for byte ordering?) */
 		devpriv->dma0Chain =
-			pci_alloc_consistent(devpriv->pci_dev,
-			sizeof(struct plx_dma_desc) * DMA_CHAIN_COUNT,
-			&devpriv->dma0ChainPhysAddr);
+		    pci_alloc_consistent(devpriv->pci_dev,
+					 sizeof(struct plx_dma_desc) *
+					 DMA_CHAIN_COUNT,
+					 &devpriv->dma0ChainPhysAddr);
 		for (index = 0; index < DMA_CHAIN_COUNT; index++) {
 			devpriv->dma0Chain[index].pci_start_addr =
-				devpriv->dma0BuffPhysAddr[index];
+			    devpriv->dma0BuffPhysAddr[index];
 			devpriv->dma0Chain[index].local_start_addr =
-				DMALADDR_ADC;
+			    DMALADDR_ADC;
 			devpriv->dma0Chain[index].transfer_size =
-				sizeof(u16) * devpriv->fifoLen / 2;
+			    sizeof(u16) * devpriv->fifoLen / 2;
 			devpriv->dma0Chain[index].next =
-				(devpriv->dma0ChainPhysAddr + ((index +
-						1) % (DMA_CHAIN_COUNT))
-				* sizeof(devpriv->dma0Chain[0]))
-				| DMA_TRANSFER_BITS;
+			    (devpriv->dma0ChainPhysAddr + ((index +
+							    1) %
+							   (DMA_CHAIN_COUNT))
+			     * sizeof(devpriv->dma0Chain[0]))
+			    | DMA_TRANSFER_BITS;
 			/*DPRINTK ("ring[%d] @%lx PCI: %x, local: %x, N: 0x%x, next: %x\n",
 			   index,
 			   ((long)devpriv->dma0ChainPhysAddr
@@ -1014,17 +1048,18 @@ static int rtd_attach(struct comedi_devi
 	for (index = 0; index < DMA_CHAIN_COUNT; index++) {
 		if (NULL != devpriv->dma0Buff[index]) {	/* free buffer memory */
 			pci_free_consistent(devpriv->pci_dev,
-				sizeof(u16) * devpriv->fifoLen / 2,
-				devpriv->dma0Buff[index],
-				devpriv->dma0BuffPhysAddr[index]);
+					    sizeof(u16) * devpriv->fifoLen / 2,
+					    devpriv->dma0Buff[index],
+					    devpriv->dma0BuffPhysAddr[index]);
 			devpriv->dma0Buff[index] = NULL;
 		}
 	}
 	if (NULL != devpriv->dma0Chain) {
 		pci_free_consistent(devpriv->pci_dev,
-			sizeof(struct plx_dma_desc)
-			* DMA_CHAIN_COUNT,
-			devpriv->dma0Chain, devpriv->dma0ChainPhysAddr);
+				    sizeof(struct plx_dma_desc)
+				    * DMA_CHAIN_COUNT,
+				    devpriv->dma0Chain,
+				    devpriv->dma0ChainPhysAddr);
 		devpriv->dma0Chain = NULL;
 	}
 #endif /* USE_DMA */
@@ -1032,7 +1067,7 @@ static int rtd_attach(struct comedi_devi
 	if (dev->irq) {
 		/* disable interrupt controller */
 		RtdPlxInterruptWrite(dev, RtdPlxInterruptRead(dev)
-			& ~(ICS_PLIE | ICS_DMA0_E | ICS_DMA1_E));
+				     & ~(ICS_PLIE | ICS_DMA0_E | ICS_DMA1_E));
 		free_irq(dev->irq, dev);
 	}
 
@@ -1070,7 +1105,11 @@ static int rtd_detach(struct comedi_devi
 	DPRINTK("comedi%d: rtd520: removing (%ld ints)\n",
 		dev->minor, (devpriv ? devpriv->intCount : 0L));
 	if (devpriv && devpriv->lcfg) {
-		DPRINTK("(int status 0x%x, overrun status 0x%x, fifo status 0x%x)...\n", 0xffff & RtdInterruptStatus(dev), 0xffff & RtdInterruptOverrunStatus(dev), (0xffff & RtdFifoStatus(dev)) ^ 0x6666);
+		DPRINTK
+		    ("(int status 0x%x, overrun status 0x%x, fifo status 0x%x)...\n",
+		     0xffff & RtdInterruptStatus(dev),
+		     0xffff & RtdInterruptOverrunStatus(dev),
+		     (0xffff & RtdFifoStatus(dev)) ^ 0x6666);
 	}
 
 	if (devpriv) {
@@ -1093,16 +1132,19 @@ static int rtd_detach(struct comedi_devi
 		for (index = 0; index < DMA_CHAIN_COUNT; index++) {
 			if (NULL != devpriv->dma0Buff[index]) {
 				pci_free_consistent(devpriv->pci_dev,
-					sizeof(u16) * devpriv->fifoLen / 2,
-					devpriv->dma0Buff[index],
-					devpriv->dma0BuffPhysAddr[index]);
+						    sizeof(u16) *
+						    devpriv->fifoLen / 2,
+						    devpriv->dma0Buff[index],
+						    devpriv->
+						    dma0BuffPhysAddr[index]);
 				devpriv->dma0Buff[index] = NULL;
 			}
 		}
 		if (NULL != devpriv->dma0Chain) {
 			pci_free_consistent(devpriv->pci_dev,
-				sizeof(struct plx_dma_desc) * DMA_CHAIN_COUNT,
-				devpriv->dma0Chain, devpriv->dma0ChainPhysAddr);
+					    sizeof(struct plx_dma_desc) *
+					    DMA_CHAIN_COUNT, devpriv->dma0Chain,
+					    devpriv->dma0ChainPhysAddr);
 			devpriv->dma0Chain = NULL;
 		}
 #endif /* USE_DMA */
@@ -1111,7 +1153,8 @@ static int rtd_detach(struct comedi_devi
 		if (dev->irq) {
 			/* disable interrupt controller */
 			RtdPlxInterruptWrite(dev, RtdPlxInterruptRead(dev)
-				& ~(ICS_PLIE | ICS_DMA0_E | ICS_DMA1_E));
+					     & ~(ICS_PLIE | ICS_DMA0_E |
+						 ICS_DMA1_E));
 			free_irq(dev->irq, dev);
 		}
 
@@ -1142,7 +1185,7 @@ static int rtd_detach(struct comedi_devi
   Convert a single comedi channel-gain entry to a RTD520 table entry
 */
 static unsigned short rtdConvertChanGain(struct comedi_device *dev,
-	unsigned int comediChan, int chanIndex)
+					 unsigned int comediChan, int chanIndex)
 {				/* index in channel list */
 	unsigned int chan, range, aref;
 	unsigned short r = 0;
@@ -1192,7 +1235,7 @@ static unsigned short rtdConvertChanGain
   Setup the channel-gain table from a comedi list
 */
 static void rtd_load_channelgain_list(struct comedi_device *dev,
-	unsigned int n_chan, unsigned int *list)
+				      unsigned int n_chan, unsigned int *list)
 {
 	if (n_chan > 1) {	/* setup channel gain table */
 		int ii;
@@ -1200,7 +1243,7 @@ static void rtd_load_channelgain_list(st
 		RtdEnableCGT(dev, 1);	/* enable table */
 		for (ii = 0; ii < n_chan; ii++) {
 			RtdWriteCGTable(dev, rtdConvertChanGain(dev, list[ii],
-					ii));
+								ii));
 		}
 	} else {		/* just use the channel gain latch */
 		RtdEnableCGT(dev, 0);	/* disable table, enable latch */
@@ -1232,16 +1275,15 @@ static int rtd520_probe_fifo_depth(struc
 			break;
 		}
 	}
-	if (i == limit)
-	{
+	if (i == limit) {
 		printk("\ncomedi: %s: failed to probe fifo size.\n", DRV_NAME);
 		return -EIO;
 	}
 	RtdAdcClearFifo(dev);
-	if (fifo_size != 0x400 && fifo_size != 0x2000)
-	{
-		printk("\ncomedi: %s: unexpected fifo size of %i, expected 1024 or 8192.\n",
-			DRV_NAME, fifo_size);
+	if (fifo_size != 0x400 && fifo_size != 0x2000) {
+		printk
+		    ("\ncomedi: %s: unexpected fifo size of %i, expected 1024 or 8192.\n",
+		     DRV_NAME, fifo_size);
 		return -EIO;
 	}
 	return fifo_size;
@@ -1256,7 +1298,8 @@ static int rtd520_probe_fifo_depth(struc
   select, delay, then read.
  */
 static int rtd_ai_rinsn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			struct comedi_subdevice *s, struct comedi_insn *insn,
+			unsigned int *data)
 {
 	int n, ii;
 	int stat;
@@ -1283,7 +1326,9 @@ static int rtd_ai_rinsn(struct comedi_de
 			WAIT_QUIETLY;
 		}
 		if (ii >= RTD_ADC_TIMEOUT) {
-			DPRINTK("rtd520: Error: ADC never finished! FifoStatus=0x%x\n", stat ^ 0x6666);
+			DPRINTK
+			    ("rtd520: Error: ADC never finished! FifoStatus=0x%x\n",
+			     stat ^ 0x6666);
 			return -ETIMEDOUT;
 		}
 
@@ -1308,7 +1353,8 @@ static int rtd_ai_rinsn(struct comedi_de
 
   The manual claims that we can do a lword read, but it doesn't work here.
 */
-static int ai_read_n(struct comedi_device *dev, struct comedi_subdevice *s, int count)
+static int ai_read_n(struct comedi_device *dev, struct comedi_subdevice *s,
+		     int count)
 {
 	int ii;
 
@@ -1384,7 +1430,7 @@ void abort_dma(struct comedi_device *dev
 	/* unsigned long flags; */
 
 	dma_cs_addr = (unsigned long)devpriv->lcfg
-		+ ((channel == 0) ? LCFG_DMACSR0 : LCFG_DMACSR1);
+	    + ((channel == 0) ? LCFG_DMACSR0 : LCFG_DMACSR1);
 
 	/*  spinlock for plx dma control/status reg */
 	/* spin_lock_irqsave( &dev->spinlock, flags ); */
@@ -1404,30 +1450,29 @@ void abort_dma(struct comedi_device *dev
 	}
 	if (status & PLX_DMA_DONE_BIT) {
 		printk("rtd520: Timeout waiting for dma %i done clear\n",
-			channel);
+		       channel);
 		goto abortDmaExit;
 	}
 
 	/* disable channel (required) */
 	writeb(0, dma_cs_addr);
-	udelay(1);	/* needed?? */
+	udelay(1);		/* needed?? */
 	/* set abort bit for channel */
 	writeb(PLX_DMA_ABORT_BIT, dma_cs_addr);
 
 	/*  wait for dma done bit to be set */
 	status = readb(dma_cs_addr);
 	for (ii = 0;
-		(status & PLX_DMA_DONE_BIT) == 0 && ii < RTD_DMA_TIMEOUT;
-		ii++) {
+	     (status & PLX_DMA_DONE_BIT) == 0 && ii < RTD_DMA_TIMEOUT; ii++) {
 		status = readb(dma_cs_addr);
 		WAIT_QUIETLY;
 	}
 	if ((status & PLX_DMA_DONE_BIT) == 0) {
 		printk("rtd520: Timeout waiting for dma %i done set\n",
-			channel);
+		       channel);
 	}
 
-      abortDmaExit:
+abortDmaExit:
 	/* spin_unlock_irqrestore( &dev->spinlock, flags ); */
 }
 
@@ -1495,8 +1540,8 @@ static int ai_process_dma(struct comedi_
   The data conversion may someday happen in a "bottom half".
 */
 static irqreturn_t rtd_interrupt(int irq,	/* interrupt number (ignored) */
-	void *d)		/* our data */
-{				/* cpu context (ignored) */
+				 void *d)
+{				/* our data *//* cpu context (ignored) */
 	struct comedi_device *dev = d;	/* must be called "dev" for devpriv */
 	u16 status;
 	u16 fifoStatus;
@@ -1520,20 +1565,22 @@ static irqreturn_t rtd_interrupt(int irq
 
 		if (istatus & ICS_DMA0_A) {
 			if (ai_process_dma(dev, s) < 0) {
-				DPRINTK("rtd520: comedi read buffer overflow (DMA) with %ld to go!\n", devpriv->aiCount);
+				DPRINTK
+				    ("rtd520: comedi read buffer overflow (DMA) with %ld to go!\n",
+				     devpriv->aiCount);
 				RtdDma0Control(dev,
-					(devpriv->
-						dma0Control &
+					       (devpriv->dma0Control &
 						~PLX_DMA_START_BIT)
-					| PLX_CLEAR_DMA_INTR_BIT);
+					       | PLX_CLEAR_DMA_INTR_BIT);
 				goto abortTransfer;
 			}
 
 			/*DPRINTK ("rtd520: DMA transfer: %ld to go, istatus %x\n",
 			   devpriv->aiCount, istatus); */
 			RtdDma0Control(dev,
-				(devpriv->dma0Control & ~PLX_DMA_START_BIT)
-				| PLX_CLEAR_DMA_INTR_BIT);
+				       (devpriv->
+					dma0Control & ~PLX_DMA_START_BIT)
+				       | PLX_CLEAR_DMA_INTR_BIT);
 			if (0 == devpriv->aiCount) {	/* counted down */
 				DPRINTK("rtd520: Samples Done (DMA).\n");
 				goto transferDone;
@@ -1560,7 +1607,9 @@ static irqreturn_t rtd_interrupt(int irq
 			/*DPRINTK("rtd520: Sample int, reading 1/2FIFO.  fifo_status 0x%x\n",
 			   (fifoStatus ^ 0x6666) & 0x7777); */
 			if (ai_read_n(dev, s, devpriv->fifoLen / 2) < 0) {
-				DPRINTK("rtd520: comedi read buffer overflow (1/2FIFO) with %ld to go!\n", devpriv->aiCount);
+				DPRINTK
+				    ("rtd520: comedi read buffer overflow (1/2FIFO) with %ld to go!\n",
+				     devpriv->aiCount);
 				goto abortTransfer;
 			}
 			if (0 == devpriv->aiCount) {	/* counted down */
@@ -1573,24 +1622,32 @@ static irqreturn_t rtd_interrupt(int irq
 			   devpriv->transCount, (fifoStatus ^ 0x6666) & 0x7777); */
 			if (fifoStatus & FS_ADC_NOT_EMPTY) {	/* 1 -> not empty */
 				if (ai_read_n(dev, s, devpriv->transCount) < 0) {
-					DPRINTK("rtd520: comedi read buffer overflow (N) with %ld to go!\n", devpriv->aiCount);
+					DPRINTK
+					    ("rtd520: comedi read buffer overflow (N) with %ld to go!\n",
+					     devpriv->aiCount);
 					goto abortTransfer;
 				}
 				if (0 == devpriv->aiCount) {	/* counted down */
-					DPRINTK("rtd520: Samples Done (N). fifo_status was 0x%x\n", (fifoStatus ^ 0x6666) & 0x7777);
+					DPRINTK
+					    ("rtd520: Samples Done (N). fifo_status was 0x%x\n",
+					     (fifoStatus ^ 0x6666) & 0x7777);
 					goto transferDone;
 				}
 				comedi_event(dev, s);
 			}
 		} else {	/* wait for 1/2 FIFO (old) */
-			DPRINTK("rtd520: Sample int.  Wait for 1/2. fifo_status 0x%x\n", (fifoStatus ^ 0x6666) & 0x7777);
+			DPRINTK
+			    ("rtd520: Sample int.  Wait for 1/2. fifo_status 0x%x\n",
+			     (fifoStatus ^ 0x6666) & 0x7777);
 		}
 	} else {
 		DPRINTK("rtd520: unknown interrupt source!\n");
 	}
 
 	if (0xffff & RtdInterruptOverrunStatus(dev)) {	/* interrupt overrun */
-		DPRINTK("rtd520: Interrupt overrun with %ld to go! over_status=0x%x\n", devpriv->aiCount, 0xffff & RtdInterruptOverrunStatus(dev));
+		DPRINTK
+		    ("rtd520: Interrupt overrun with %ld to go! over_status=0x%x\n",
+		     devpriv->aiCount, 0xffff & RtdInterruptOverrunStatus(dev));
 		goto abortTransfer;
 	}
 
@@ -1599,13 +1656,13 @@ static irqreturn_t rtd_interrupt(int irq
 	RtdInterruptClear(dev);
 	return IRQ_HANDLED;
 
-      abortTransfer:
+abortTransfer:
 	RtdAdcClearFifo(dev);	/* clears full flag */
 	s->async->events |= COMEDI_CB_ERROR;
 	devpriv->aiCount = 0;	/* stop and don't transfer any more */
 	/* fall into transferDone */
 
-      transferDone:
+transferDone:
 	RtdPacerStopSource(dev, 0);	/* stop on SOFTWARE stop */
 	RtdPacerStop(dev);	/* Stop PACER */
 	RtdAdcConversionSource(dev, 0);	/* software trigger only */
@@ -1613,7 +1670,7 @@ static irqreturn_t rtd_interrupt(int irq
 #ifdef USE_DMA
 	if (devpriv->flags & DMA0_ACTIVE) {
 		RtdPlxInterruptWrite(dev,	/* disable any more interrupts */
-			RtdPlxInterruptRead(dev) & ~ICS_DMA0_E);
+				     RtdPlxInterruptRead(dev) & ~ICS_DMA0_E);
 		abort_dma(dev, 0);
 		devpriv->flags &= ~DMA0_ACTIVE;
 		/* if Using DMA, then we should have read everything by now */
@@ -1639,7 +1696,10 @@ static irqreturn_t rtd_interrupt(int irq
 	RtdInterruptClear(dev);
 
 	fifoStatus = RtdFifoStatus(dev);	/* DEBUG */
-	DPRINTK("rtd520: Acquisition complete. %ld ints, intStat=%x, overStat=%x\n", devpriv->intCount, status, 0xffff & RtdInterruptOverrunStatus(dev));
+	DPRINTK
+	    ("rtd520: Acquisition complete. %ld ints, intStat=%x, overStat=%x\n",
+	     devpriv->intCount, status,
+	     0xffff & RtdInterruptOverrunStatus(dev));
 
 	return IRQ_HANDLED;
 }
@@ -1666,7 +1726,7 @@ static int rtd_ai_poll(struct comedi_dev
 */
 
 static int rtd_ai_cmdtest(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd)
+			  struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1710,7 +1770,7 @@ static int rtd_ai_cmdtest(struct comedi_
 	   and mutually compatible */
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT) {
+	    cmd->scan_begin_src != TRIG_EXT) {
 		err++;
 	}
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT) {
@@ -1737,26 +1797,26 @@ static int rtd_ai_cmdtest(struct comedi_
 			if (cmd->scan_begin_arg < RTD_MAX_SPEED_1) {
 				cmd->scan_begin_arg = RTD_MAX_SPEED_1;
 				rtd_ns_to_timer(&cmd->scan_begin_arg,
-					TRIG_ROUND_UP);
+						TRIG_ROUND_UP);
 				err++;
 			}
 			if (cmd->scan_begin_arg > RTD_MIN_SPEED_1) {
 				cmd->scan_begin_arg = RTD_MIN_SPEED_1;
 				rtd_ns_to_timer(&cmd->scan_begin_arg,
-					TRIG_ROUND_DOWN);
+						TRIG_ROUND_DOWN);
 				err++;
 			}
 		} else {
 			if (cmd->scan_begin_arg < RTD_MAX_SPEED) {
 				cmd->scan_begin_arg = RTD_MAX_SPEED;
 				rtd_ns_to_timer(&cmd->scan_begin_arg,
-					TRIG_ROUND_UP);
+						TRIG_ROUND_UP);
 				err++;
 			}
 			if (cmd->scan_begin_arg > RTD_MIN_SPEED) {
 				cmd->scan_begin_arg = RTD_MIN_SPEED;
 				rtd_ns_to_timer(&cmd->scan_begin_arg,
-					TRIG_ROUND_DOWN);
+						TRIG_ROUND_DOWN);
 				err++;
 			}
 		}
@@ -1774,26 +1834,26 @@ static int rtd_ai_cmdtest(struct comedi_
 			if (cmd->convert_arg < RTD_MAX_SPEED_1) {
 				cmd->convert_arg = RTD_MAX_SPEED_1;
 				rtd_ns_to_timer(&cmd->convert_arg,
-					TRIG_ROUND_UP);
+						TRIG_ROUND_UP);
 				err++;
 			}
 			if (cmd->convert_arg > RTD_MIN_SPEED_1) {
 				cmd->convert_arg = RTD_MIN_SPEED_1;
 				rtd_ns_to_timer(&cmd->convert_arg,
-					TRIG_ROUND_DOWN);
+						TRIG_ROUND_DOWN);
 				err++;
 			}
 		} else {
 			if (cmd->convert_arg < RTD_MAX_SPEED) {
 				cmd->convert_arg = RTD_MAX_SPEED;
 				rtd_ns_to_timer(&cmd->convert_arg,
-					TRIG_ROUND_UP);
+						TRIG_ROUND_UP);
 				err++;
 			}
 			if (cmd->convert_arg > RTD_MIN_SPEED) {
 				cmd->convert_arg = RTD_MIN_SPEED;
 				rtd_ns_to_timer(&cmd->convert_arg,
-					TRIG_ROUND_DOWN);
+						TRIG_ROUND_DOWN);
 				err++;
 			}
 		}
@@ -1836,7 +1896,7 @@ static int rtd_ai_cmdtest(struct comedi_
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		rtd_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg) {
 			err++;
 		}
@@ -1844,15 +1904,15 @@ static int rtd_ai_cmdtest(struct comedi_
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		rtd_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg) {
 			err++;
 		}
 		if (cmd->scan_begin_src == TRIG_TIMER
-			&& (cmd->scan_begin_arg
-				< (cmd->convert_arg * cmd->scan_end_arg))) {
+		    && (cmd->scan_begin_arg
+			< (cmd->convert_arg * cmd->scan_end_arg))) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -1883,7 +1943,7 @@ static int rtd_ai_cmd(struct comedi_devi
 #ifdef USE_DMA
 	if (devpriv->flags & DMA0_ACTIVE) {	/* cancel anything running */
 		RtdPlxInterruptWrite(dev,	/* disable any more interrupts */
-			RtdPlxInterruptRead(dev) & ~ICS_DMA0_E);
+				     RtdPlxInterruptRead(dev) & ~ICS_DMA0_E);
 		abort_dma(dev, 0);
 		devpriv->flags &= ~DMA0_ACTIVE;
 		if (RtdPlxInterruptRead(dev) & ICS_DMA0_A) {	/*clear pending int */
@@ -1929,17 +1989,17 @@ static int rtd_ai_cmd(struct comedi_devi
 		} else {
 			/* arrange to transfer data periodically */
 			devpriv->transCount
-				=
-				(TRANS_TARGET_PERIOD * cmd->chanlist_len) /
-				cmd->scan_begin_arg;
+			    =
+			    (TRANS_TARGET_PERIOD * cmd->chanlist_len) /
+			    cmd->scan_begin_arg;
 			if (devpriv->transCount < cmd->chanlist_len) {
 				/* tranfer after each scan (and avoid 0) */
 				devpriv->transCount = cmd->chanlist_len;
 			} else {	/* make a multiple of scan length */
 				devpriv->transCount =
-					(devpriv->transCount +
-					cmd->chanlist_len - 1)
-					/ cmd->chanlist_len;
+				    (devpriv->transCount +
+				     cmd->chanlist_len - 1)
+				    / cmd->chanlist_len;
 				devpriv->transCount *= cmd->chanlist_len;
 			}
 			devpriv->flags |= SEND_EOS;
@@ -1953,7 +2013,10 @@ static int rtd_ai_cmd(struct comedi_devi
 			RtdAboutCounter(dev, devpriv->transCount - 1);
 		}
 
-		DPRINTK("rtd520: scanLen=%d tranferCount=%d fifoLen=%d\n  scanTime(ns)=%d flags=0x%x\n", cmd->chanlist_len, devpriv->transCount, devpriv->fifoLen, cmd->scan_begin_arg, devpriv->flags);
+		DPRINTK
+		    ("rtd520: scanLen=%d tranferCount=%d fifoLen=%d\n  scanTime(ns)=%d flags=0x%x\n",
+		     cmd->chanlist_len, devpriv->transCount, devpriv->fifoLen,
+		     cmd->scan_begin_arg, devpriv->flags);
 	} else {		/* unknown timing, just use 1/2 FIFO */
 		devpriv->transCount = 0;
 		devpriv->flags &= ~SEND_EOS;
@@ -1968,7 +2031,7 @@ static int rtd_ai_cmd(struct comedi_devi
 	case TRIG_COUNT:	/* stop after N scans */
 		devpriv->aiCount = cmd->stop_arg * cmd->chanlist_len;
 		if ((devpriv->transCount > 0)
-			&& (devpriv->transCount > devpriv->aiCount)) {
+		    && (devpriv->transCount > devpriv->aiCount)) {
 			devpriv->transCount = devpriv->aiCount;
 		}
 		break;
@@ -1986,7 +2049,7 @@ static int rtd_ai_cmd(struct comedi_devi
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:	/* periodic scanning */
 		timer = rtd_ns_to_timer(&cmd->scan_begin_arg,
-			TRIG_ROUND_NEAREST);
+					TRIG_ROUND_NEAREST);
 		/* set PACER clock */
 		/*DPRINTK ("rtd520: loading %d into pacer\n", timer); */
 		RtdPacerCounter(dev, timer);
@@ -2007,7 +2070,7 @@ static int rtd_ai_cmd(struct comedi_devi
 	case TRIG_TIMER:	/* periodic */
 		if (cmd->chanlist_len > 1) {	/* only needed for multi-channel */
 			timer = rtd_ns_to_timer(&cmd->convert_arg,
-				TRIG_ROUND_NEAREST);
+						TRIG_ROUND_NEAREST);
 			/* setup BURST clock */
 			/*DPRINTK ("rtd520: loading %d into burst\n", timer); */
 			RtdBurstCounter(dev, timer);
@@ -2042,11 +2105,11 @@ static int rtd_ai_cmd(struct comedi_devi
 		devpriv->dma0Offset = 0;
 		RtdDma0Mode(dev, DMA_MODE_BITS);
 		RtdDma0Next(dev,	/* point to first block */
-			devpriv->dma0Chain[DMA_CHAIN_COUNT - 1].next);
+			    devpriv->dma0Chain[DMA_CHAIN_COUNT - 1].next);
 		RtdDma0Source(dev, DMAS_ADFIFO_HALF_FULL);	/* set DMA trigger source */
 
 		RtdPlxInterruptWrite(dev,	/* enable interrupt */
-			RtdPlxInterruptRead(dev) | ICS_DMA0_E);
+				     RtdPlxInterruptRead(dev) | ICS_DMA0_E);
 		/* Must be 2 steps.  See PLX app note about "Starting a DMA transfer" */
 		RtdDma0Control(dev, PLX_DMA_EN_BIT);	/* enable DMA (clear INTR?) */
 		RtdDma0Control(dev, PLX_DMA_EN_BIT | PLX_DMA_START_BIT);	/*start DMA */
@@ -2079,13 +2142,16 @@ static int rtd_ai_cancel(struct comedi_d
 #ifdef USE_DMA
 	if (devpriv->flags & DMA0_ACTIVE) {
 		RtdPlxInterruptWrite(dev,	/* disable any more interrupts */
-			RtdPlxInterruptRead(dev) & ~ICS_DMA0_E);
+				     RtdPlxInterruptRead(dev) & ~ICS_DMA0_E);
 		abort_dma(dev, 0);
 		devpriv->flags &= ~DMA0_ACTIVE;
 	}
 #endif /* USE_DMA */
 	status = RtdInterruptStatus(dev);
-	DPRINTK("rtd520: Acquisition canceled. %ld ints, intStat=%x, overStat=%x\n", devpriv->intCount, status, 0xffff & RtdInterruptOverrunStatus(dev));
+	DPRINTK
+	    ("rtd520: Acquisition canceled. %ld ints, intStat=%x, overStat=%x\n",
+	     devpriv->intCount, status,
+	     0xffff & RtdInterruptOverrunStatus(dev));
 	return 0;
 }
 
@@ -2096,7 +2162,7 @@ static int rtd_ai_cancel(struct comedi_d
   Note: you have to check if the value is larger than the counter range!
 */
 static int rtd_ns_to_timer_base(unsigned int *nanosec,	/* desired period (in ns) */
-	int round_mode, int base)
+				int round_mode, int base)
 {				/* clock period (in ns) */
 	int divider;
 
@@ -2136,7 +2202,8 @@ static int rtd_ns_to_timer(unsigned int 
   Output one (or more) analog values to a single port as fast as possible.
 */
 static int rtd_ao_winsn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			struct comedi_subdevice *s, struct comedi_insn *insn,
+			unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -2155,14 +2222,16 @@ static int rtd_ao_winsn(struct comedi_de
 		/* VERIFY: comedi range and offset conversions */
 
 		if ((range > 1)	/* bipolar */
-			&& (data[i] < 2048)) {
+		    &&(data[i] < 2048)) {
 			/* offset and sign extend */
 			val = (((int)data[i]) - 2048) << 3;
 		} else {	/* unipolor */
 			val = data[i] << 3;
 		}
 
-		DPRINTK("comedi: rtd520 DAC chan=%d range=%d writing %d as 0x%x\n", chan, range, data[i], val);
+		DPRINTK
+		    ("comedi: rtd520 DAC chan=%d range=%d writing %d as 0x%x\n",
+		     chan, range, data[i], val);
 
 		/* a typical programming sequence */
 		RtdDacFifoPut(dev, chan, val);	/* put the value in */
@@ -2174,12 +2243,14 @@ static int rtd_ao_winsn(struct comedi_de
 			stat = RtdFifoStatus(dev);
 			/* 1 -> not empty */
 			if (stat & ((0 == chan) ? FS_DAC1_NOT_EMPTY :
-					FS_DAC2_NOT_EMPTY))
+				    FS_DAC2_NOT_EMPTY))
 				break;
 			WAIT_QUIETLY;
 		}
 		if (ii >= RTD_DAC_TIMEOUT) {
-			DPRINTK("rtd520: Error: DAC never finished! FifoStatus=0x%x\n", stat ^ 0x6666);
+			DPRINTK
+			    ("rtd520: Error: DAC never finished! FifoStatus=0x%x\n",
+			     stat ^ 0x6666);
 			return -ETIMEDOUT;
 		}
 	}
@@ -2191,7 +2262,8 @@ static int rtd_ao_winsn(struct comedi_de
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int rtd_ao_rinsn(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			struct comedi_subdevice *s, struct comedi_insn *insn,
+			unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -2214,7 +2286,8 @@ static int rtd_ao_rinsn(struct comedi_de
  * comedi core can convert between insn_bits and insn_read/write
  */
 static int rtd_dio_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -2241,7 +2314,8 @@ static int rtd_dio_insn_bits(struct come
   Configure one bit on a IO port as Input or Output (hence the name :-).
 */
 static int rtd_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -2258,8 +2332,7 @@ static int rtd_dio_insn_config(struct co
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
--- a/drivers/staging/comedi/drivers/rti800.c
+++ b/drivers/staging/comedi/drivers/rti800.c
@@ -98,25 +98,38 @@ Configuration options:
 #include "am9513.h"
 
 static const struct comedi_lrange range_rti800_ai_10_bipolar = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.02)
-	}
+								     BIP_RANGE
+								     (10),
+								     BIP_RANGE
+								     (1),
+								     BIP_RANGE
+								     (0.1),
+								     BIP_RANGE
+								     (0.02)
+								     }
 };
+
 static const struct comedi_lrange range_rti800_ai_5_bipolar = { 4, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.01)
-	}
+								    BIP_RANGE
+								    (5),
+								    BIP_RANGE
+								    (0.5),
+								    BIP_RANGE
+								    (0.05),
+								    BIP_RANGE
+								    (0.01)
+								    }
 };
+
 static const struct comedi_lrange range_rti800_ai_unipolar = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.02)
-	}
+								   UNI_RANGE
+								   (10),
+								   UNI_RANGE(1),
+								   UNI_RANGE
+								   (0.1),
+								   UNI_RANGE
+								   (0.02)
+								   }
 };
 
 struct rti800_board {
@@ -132,7 +145,8 @@ static const struct rti800_board boardty
 
 #define this_board ((const struct rti800_board *)dev->board_ptr)
 
-static int rti800_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int rti800_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int rti800_detach(struct comedi_device *dev);
 static struct comedi_driver driver_rti800 = {
 	.driver_name = "rti800",
@@ -181,8 +195,9 @@ static irqreturn_t rti800_interrupt(int 
 /* settling delay times in usec for different gains */
 static const int gaindelay[] = { 10, 20, 40, 80 };
 
-static int rti800_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int rti800_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i, t;
 	int status;
@@ -233,8 +248,9 @@ static int rti800_ai_insn_read(struct co
 	return i;
 }
 
-static int rti800_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int rti800_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -245,8 +261,9 @@ static int rti800_ao_insn_read(struct co
 	return i;
 }
 
-static int rti800_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int rti800_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	int d;
@@ -258,15 +275,16 @@ static int rti800_ao_insn_write(struct c
 			d ^= 0x800;
 		}
 		outb(d & 0xff,
-			dev->iobase + (chan ? RTI800_DAC1LO : RTI800_DAC0LO));
+		     dev->iobase + (chan ? RTI800_DAC1LO : RTI800_DAC0LO));
 		outb(d >> 8,
-			dev->iobase + (chan ? RTI800_DAC1HI : RTI800_DAC0HI));
+		     dev->iobase + (chan ? RTI800_DAC1HI : RTI800_DAC0HI));
 	}
 	return i;
 }
 
-static int rti800_di_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int rti800_di_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -274,8 +292,9 @@ static int rti800_di_insn_bits(struct co
 	return 2;
 }
 
-static int rti800_do_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int rti800_do_insn_bits(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -326,10 +345,10 @@ static int rti800_attach(struct comedi_d
 
 #ifdef DEBUG
 	printk("fingerprint=%x,%x,%x,%x,%x ",
-		inb(dev->iobase + 0),
-		inb(dev->iobase + 1),
-		inb(dev->iobase + 2),
-		inb(dev->iobase + 3), inb(dev->iobase + 4));
+	       inb(dev->iobase + 0),
+	       inb(dev->iobase + 1),
+	       inb(dev->iobase + 2),
+	       inb(dev->iobase + 3), inb(dev->iobase + 4));
 #endif
 
 	outb(0, dev->iobase + RTI800_CSR);
--- a/drivers/staging/comedi/drivers/rti802.c
+++ b/drivers/staging/comedi/drivers/rti802.c
@@ -47,7 +47,8 @@ Configuration Options:
 #define RTI802_DATALOW 1
 #define RTI802_DATAHIGH 2
 
-static int rti802_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int rti802_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int rti802_detach(struct comedi_device *dev);
 static struct comedi_driver driver_rti802 = {
 	.driver_name = "rti802",
@@ -68,8 +69,9 @@ struct rti802_private {
 
 #define devpriv ((struct rti802_private *)dev->private)
 
-static int rti802_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int rti802_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -79,8 +81,9 @@ static int rti802_ao_insn_read(struct co
 	return i;
 }
 
-static int rti802_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int rti802_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int i, d;
 	int chan = CR_CHAN(insn->chanspec);
@@ -113,7 +116,7 @@ static int rti802_attach(struct comedi_d
 	dev->board_name = "rti802";
 
 	if (alloc_subdevices(dev, 1) < 0
-		|| alloc_private(dev, sizeof(struct rti802_private))) {
+	    || alloc_private(dev, sizeof(struct rti802_private))) {
 		return -ENOMEM;
 	}
 
@@ -129,10 +132,10 @@ static int rti802_attach(struct comedi_d
 
 	for (i = 0; i < 8; i++) {
 		devpriv->dac_coding[i] = (it->options[3 + 2 * i])
-			? (dac_straight)
-			: (dac_2comp);
+		    ? (dac_straight)
+		    : (dac_2comp);
 		devpriv->range_type_list[i] = (it->options[2 + 2 * i])
-			? &range_unipolar10 : &range_bipolar10;
+		    ? &range_unipolar10 : &range_bipolar10;
 	}
 
 	printk("\n");
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -169,15 +169,15 @@ struct s526_board {
 
 static const struct s526_board s526_boards[] = {
 	{
-	.name = "s526",
-	.gpct_chans = 4,
-	.gpct_bits = 24,
-	.ad_chans = 8,
-	.ad_bits = 16,
-	.da_chans = 4,
-	.da_bits = 16,
-	.have_dio = 1,
-		}
+	 .name = "s526",
+	 .gpct_chans = 4,
+	 .gpct_bits = 24,
+	 .ad_chans = 8,
+	 .ad_bits = 16,
+	 .da_chans = 4,
+	 .da_bits = 16,
+	 .have_dio = 1,
+	 }
 };
 
 #define ADDR_REG(reg) (dev->iobase + (reg))
@@ -247,24 +247,30 @@ static struct comedi_driver driver_s526 
 	.num_names = ARRAY_SIZE(s526_boards),
 };
 
-static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int s526_gpct_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int s526_gpct_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int s526_gpct_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int s526_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
+static int s526_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int s526_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -424,7 +430,7 @@ static int s526_attach(struct comedi_dev
 
 	n = 0;
 	printk("Mode reg=0x%04x, 0x%04lx\n", cmReg.value, ADDR_CHAN_REG(REG_C0M,
-			n));
+									n));
 	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
 	udelay(1000);
 	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
@@ -455,7 +461,7 @@ static int s526_attach(struct comedi_dev
 
 	for (i = 0; i < S526_NUM_PORTS; i++) {
 		printk("0x%02lx: 0x%04x\n", ADDR_REG(s526_ports[i]),
-			inw(ADDR_REG(s526_ports[i])));
+		       inw(ADDR_REG(s526_ports[i])));
 	}
 	return 1;
 }
@@ -478,8 +484,9 @@ static int s526_detach(struct comedi_dev
 	return 0;
 }
 
-static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_gpct_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i;			/*  counts the Data */
 	int counter_channel = CR_CHAN(insn->chanspec);
@@ -502,8 +509,9 @@ static int s526_gpct_rinsn(struct comedi
 	return i;
 }
 
-static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_gpct_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	int i;
@@ -513,7 +521,7 @@ static int s526_gpct_insn_config(struct 
 
 	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++) {
 		devpriv->s526_gpct_config[subdev_channel].data[i] =
-			insn->data[i];
+		    insn->data[i];
 /* printk("data[%d]=%x\n", i, insn->data[i]); */
 	}
 
@@ -529,32 +537,32 @@ static int s526_gpct_insn_config(struct 
 		 */
 		printk("s526: GPCT_INSN_CONFIG: Configuring Encoder\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
-			PositionMeasurement;
+		    PositionMeasurement;
 
 #if 0
-			/*  Example of Counter Application */
-			/* One-shot (software trigger) */
-			cmReg.reg.coutSource		= 0; /*  out RCAP */
-			cmReg.reg.coutPolarity		= 1; /*  Polarity inverted */
-			cmReg.reg.autoLoadResetRcap	= 0; /*  Auto load disabled */
-			cmReg.reg.hwCtEnableSource	= 3; /*  NOT RCAP */
-			cmReg.reg.ctEnableCtrl		= 2; /*  Hardware */
-			cmReg.reg.clockSource		= 2; /*  Internal */
-			cmReg.reg.countDir		= 1; /*  Down */
-			cmReg.reg.countDirCtrl		= 1; /*  Software */
-			cmReg.reg.outputRegLatchCtrl	= 0; /*  latch on read */
-			cmReg.reg.preloadRegSel		= 0; /*  PR0 */
-			cmReg.reg.reserved		= 0;
+		/*  Example of Counter Application */
+		/* One-shot (software trigger) */
+		cmReg.reg.coutSource = 0;	/*  out RCAP */
+		cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
+		cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
+		cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
+		cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
+		cmReg.reg.clockSource = 2;	/*  Internal */
+		cmReg.reg.countDir = 1;	/*  Down */
+		cmReg.reg.countDirCtrl = 1;	/*  Software */
+		cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
+		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
+		cmReg.reg.reserved = 0;
 
-			outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-			outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
-			outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
 
-			outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));  /*  Reset RCAP (fires one-shot) */
+		outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset RCAP (fires one-shot) */
 
 #endif
 
@@ -604,20 +612,20 @@ static int s526_gpct_insn_config(struct 
 			cmReg.reg.autoLoadResetRcap = 4;	/*  Auto load with INDEX^ */
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register high word */
-		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register low word */
-		value = (short) (insn->data[2] & 0xFFFF);
+		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
-			value = (short) (insn->data[3] & 0xFFFF);
+			value = (short)(insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		/*  Reset the counter if it is software preload */
@@ -638,37 +646,37 @@ static int s526_gpct_insn_config(struct 
 		 */
 		printk("s526: GPCT_INSN_CONFIG: Configuring SPG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
-			SinglePulseGeneration;
+		    SinglePulseGeneration;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register 0 high word */
-		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register 0 low word */
-		value = (short) (insn->data[2] & 0xFFFF);
+		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register 1 high word */
-		value = (short) ((insn->data[3] >> 16) & 0xFFFF);
+		value = (short)((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register 1 low word */
-		value = (short) (insn->data[3] & 0xFFFF);
+		value = (short)(insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
-			value = (short) (insn->data[3] & 0xFFFF);
+			value = (short)(insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -683,37 +691,37 @@ static int s526_gpct_insn_config(struct 
 		 */
 		printk("s526: GPCT_INSN_CONFIG: Configuring PTG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
-			PulseTrainGeneration;
+		    PulseTrainGeneration;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register 0 high word */
-		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register 0 low word */
-		value = (short) (insn->data[2] & 0xFFFF);
+		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register 1 high word */
-		value = (short) ((insn->data[3] >> 16) & 0xFFFF);
+		value = (short)((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register 1 low word */
-		value = (short) (insn->data[3] & 0xFFFF);
+		value = (short)(insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
-			value = (short) (insn->data[3] & 0xFFFF);
+			value = (short)(insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -727,8 +735,9 @@ static int s526_gpct_insn_config(struct 
 	return insn->n;
 }
 
-static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_gpct_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	short value;
@@ -741,14 +750,14 @@ static int s526_gpct_winsn(struct comedi
 	case PositionMeasurement:
 		printk("S526: INSN_WRITE: PM\n");
 		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
-				subdev_channel));
+							     subdev_channel));
 		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 
 	case SinglePulseGeneration:
 		printk("S526: INSN_WRITE: SPG\n");
 		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
-				subdev_channel));
+							     subdev_channel));
 		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 
@@ -762,22 +771,25 @@ static int s526_gpct_winsn(struct comedi
 		printk("S526: INSN_WRITE: PTG\n");
 		if ((insn->data[1] > insn->data[0]) && (insn->data[0] > 0)) {
 			(devpriv->s526_gpct_config[subdev_channel]).data[0] =
-				insn->data[0];
+			    insn->data[0];
 			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
-				insn->data[1];
+			    insn->data[1];
 		} else {
 			printk("%d \t %d\n", insn->data[1], insn->data[2]);
-			printk("s526: INSN_WRITE: PTG: Problem with Pulse params\n");
+			printk
+			    ("s526: INSN_WRITE: PTG: Problem with Pulse params\n");
 			return -EINVAL;
 		}
 
-		value = (short) ((*data >> 16) & 0xFFFF);
+		value = (short)((*data >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
-		value = (short) (*data & 0xFFFF);
+		value = (short)(*data & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 	default:		/*  Impossible */
-		printk("s526: INSN_WRITE: Functionality %d not implemented yet\n", devpriv->s526_gpct_config[subdev_channel].app);
+		printk
+		    ("s526: INSN_WRITE: Functionality %d not implemented yet\n",
+		     devpriv->s526_gpct_config[subdev_channel].app);
 		return -EINVAL;
 		break;
 	}
@@ -786,8 +798,9 @@ static int s526_gpct_winsn(struct comedi
 }
 
 #define ISR_ADC_DONE 0x4
-static int s526_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int result = -EINVAL;
 
@@ -820,7 +833,7 @@ static int s526_ai_insn_config(struct co
  * mode.
  */
 static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -831,7 +844,7 @@ static int s526_ai_rinsn(struct comedi_d
 	/* Set configured delay, enable channel for this channel only,
 	 * select "ADC read" channel, set "ADC start" bit. */
 	value = (devpriv->s526_ai_config & 0x8000) |
-		((1 << 5) << chan) | (chan << 1) | 0x0001;
+	    ((1 << 5) << chan) | (chan << 1) | 0x0001;
 
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
@@ -853,7 +866,7 @@ static int s526_ai_rinsn(struct comedi_d
 			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
 			printk("s526: ADC(0x%04x) timeout\n",
-				inw(ADDR_REG(REG_ISR)));
+			       inw(ADDR_REG(REG_ISR)));
 			return -ETIMEDOUT;
 		}
 
@@ -870,7 +883,7 @@ static int s526_ai_rinsn(struct comedi_d
 }
 
 static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -899,7 +912,7 @@ static int s526_ao_winsn(struct comedi_d
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -915,8 +928,9 @@ static int s526_ao_rinsn(struct comedi_d
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int s526_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -940,8 +954,9 @@ static int s526_dio_insn_bits(struct com
 	return 2;
 }
 
-static int s526_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	short value;
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -96,15 +96,15 @@ struct s626_board {
 
 static const struct s626_board s626_boards[] = {
 	{
-	.name = "s626",
-	.ai_chans = S626_ADC_CHANNELS,
-	.ai_bits = 14,
-	.ao_chans = S626_DAC_CHANNELS,
-	.ao_bits = 13,
-	.dio_chans = S626_DIO_CHANNELS,
-	.dio_banks = S626_DIO_BANKS,
-	.enc_chans = S626_ENCODER_CHANNELS,
-		}
+	 .name = "s626",
+	 .ai_chans = S626_ADC_CHANNELS,
+	 .ai_bits = 14,
+	 .ao_chans = S626_DAC_CHANNELS,
+	 .ao_bits = 13,
+	 .dio_chans = S626_DIO_CHANNELS,
+	 .dio_banks = S626_DIO_BANKS,
+	 .enc_chans = S626_ENCODER_CHANNELS,
+	 }
 };
 
 #define thisboard ((const struct s626_board *)dev->board_ptr)
@@ -112,9 +112,10 @@ static const struct s626_board s626_boar
 #define PCI_DEVICE_ID_S626 0x7146
 
 static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
-	{PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		0},
-	{0}
+	{
+	PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626, PCI_ANY_ID, PCI_ANY_ID,
+		    0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, s626_pci_table);
@@ -145,7 +146,7 @@ struct s626_private {
 	uint16_t CounterIntEnabs;
 	/* Counter interrupt enable  mask for MISC2 register. */
 	uint8_t AdcItems;	/* Number of items in ADC poll  list. */
-	struct bufferDMA RPSBuf;		/* DMA buffer used to hold ADC (RPS1) program. */
+	struct bufferDMA RPSBuf;	/* DMA buffer used to hold ADC (RPS1) program. */
 	struct bufferDMA ANABuf;
 	/* DMA buffer used to receive ADC data and hold DAC data. */
 	uint32_t *pDacWBuf;
@@ -223,37 +224,45 @@ static struct dio_private *dio_private_w
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
 /* ioctl routines */
-static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int s626_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 /* static int s626_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data); */
-static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int s626_ai_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
 static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int s626_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
+static int s626_ai_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s626_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
+static int s626_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int s626_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 static int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan);
 static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int gruop,
-	unsigned int mask);
+			      unsigned int mask);
 static int s626_dio_clear_irq(struct comedi_device *dev);
-static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int s626_enc_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int s626_enc_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int s626_enc_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
-static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd);
-static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum);
+static int s626_ai_load_polllist(uint8_t * ppl, struct comedi_cmd *cmd);
+static int s626_ai_inttrig(struct comedi_device *dev,
+			   struct comedi_subdevice *s, unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d);
 static unsigned int s626_ai_reg_to_uint(int data);
 /* static unsigned int s626_uint_to_reg(struct comedi_subdevice *s, int data); */
@@ -262,10 +271,10 @@ static unsigned int s626_ai_reg_to_uint(
 
 /* internal routines */
 static void s626_dio_init(struct comedi_device *dev);
-static void ResetADC(struct comedi_device *dev, uint8_t *ppl);
+static void ResetADC(struct comedi_device *dev, uint8_t * ppl);
 static void LoadTrimDACs(struct comedi_device *dev);
 static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
-	uint8_t DacData);
+			 uint8_t DacData);
 static uint8_t I2Cread(struct comedi_device *dev, uint8_t addr);
 static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val);
 static void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata);
@@ -275,22 +284,23 @@ static void DEBItransfer(struct comedi_d
 static uint16_t DEBIread(struct comedi_device *dev, uint16_t addr);
 static void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata);
 static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
-	uint16_t wdata);
-static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma, size_t bsize);
+			uint16_t wdata);
+static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
+		      size_t bsize);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
 struct enc_private {
 	/*  Pointers to functions that differ for A and B counters: */
-	uint16_t(*GetEnable) (struct comedi_device *dev, struct enc_private *);	/* Return clock enable. */
-	uint16_t(*GetIntSrc) (struct comedi_device *dev, struct enc_private *);	/* Return interrupt source. */
-	uint16_t(*GetLoadTrig) (struct comedi_device *dev, struct enc_private *);	/* Return preload trigger source. */
-	uint16_t(*GetMode) (struct comedi_device *dev, struct enc_private *);	/* Return standardized operating mode. */
-	void (*PulseIndex) (struct comedi_device *dev, struct enc_private *);	/* Generate soft index strobe. */
-	void (*SetEnable) (struct comedi_device *dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
-	void (*SetIntSrc) (struct comedi_device *dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
-	void (*SetLoadTrig) (struct comedi_device *dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
-	void (*SetMode) (struct comedi_device *dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
-	void (*ResetCapFlags) (struct comedi_device *dev, struct enc_private *);	/* Reset event capture flags. */
+	uint16_t(*GetEnable) (struct comedi_device * dev, struct enc_private *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (struct comedi_device * dev, struct enc_private *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (struct comedi_device * dev, struct enc_private *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (struct comedi_device * dev, struct enc_private *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (struct comedi_device * dev, struct enc_private *);	/* Generate soft index strobe. */
+	void (*SetEnable) (struct comedi_device * dev, struct enc_private *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (struct comedi_device * dev, struct enc_private *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (struct comedi_device * dev, struct enc_private *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (struct comedi_device * dev, struct enc_private *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (struct comedi_device * dev, struct enc_private *);	/* Reset event capture flags. */
 
 	uint16_t MyCRA;		/*    Address of CRA register. */
 	uint16_t MyCRB;		/*    Address of CRB register. */
@@ -302,31 +312,36 @@ struct enc_private {
 #define encpriv ((struct enc_private *)(dev->subdevices+5)->private)
 
 /* counters routines */
-static void s626_timer_load(struct comedi_device *dev, struct enc_private *k, int tick);
+static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
+			    int tick);
 static uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k);
 static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k);
 static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k);
-static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
-	uint16_t DisableIntSrc);
-static void SetMode_B(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
-	uint16_t DisableIntSrc);
-static void SetEnable_A(struct comedi_device *dev, struct enc_private *k, uint16_t enab);
-static void SetEnable_B(struct comedi_device *dev, struct enc_private *k, uint16_t enab);
+static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc);
+static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc);
+static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab);
+static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab);
 static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k);
 static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
-	uint16_t value);
+			   uint16_t value);
 /* static uint16_t GetLatchSource(struct comedi_device *dev, struct enc_private *k ); */
-static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k, uint16_t Trig);
-static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k, uint16_t Trig);
+static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig);
+static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig);
 static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k);
 static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
-	uint16_t IntSource);
+			uint16_t IntSource);
 static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
-	uint16_t IntSource);
+			uint16_t IntSource);
 static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k);
 static uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k);
 /* static void SetClkMult(struct comedi_device *dev, struct enc_private *k, uint16_t value ) ; */
@@ -339,7 +354,8 @@ static uint16_t GetIntSrc_B(struct comed
 /* static uint16_t GetIndexSrc( struct comedi_device *dev,struct enc_private *k );  */
 static void PulseIndex_A(struct comedi_device *dev, struct enc_private *k);
 static void PulseIndex_B(struct comedi_device *dev, struct enc_private *k);
-static void Preload(struct comedi_device *dev, struct enc_private *k, uint32_t value);
+static void Preload(struct comedi_device *dev, struct enc_private *k,
+		    uint32_t value);
 static void CountersInit(struct comedi_device *dev);
 /* end internal routines */
 
@@ -356,101 +372,101 @@ static void CountersInit(struct comedi_d
 /* struct enc_private; */
 static struct enc_private enc_private_data[] = {
 	{
-	.GetEnable = GetEnable_A,
-	.GetIntSrc = GetIntSrc_A,
-	.GetLoadTrig = GetLoadTrig_A,
-	.GetMode = GetMode_A,
-	.PulseIndex = PulseIndex_A,
-	.SetEnable = SetEnable_A,
-	.SetIntSrc = SetIntSrc_A,
-	.SetLoadTrig = SetLoadTrig_A,
-	.SetMode = SetMode_A,
-	.ResetCapFlags = ResetCapFlags_A,
-	.MyCRA = LP_CR0A,
-	.MyCRB = LP_CR0B,
-	.MyLatchLsw = LP_CNTR0ALSW,
-	.MyEventBits = EVBITS(0),
-		},
+	 .GetEnable = GetEnable_A,
+	 .GetIntSrc = GetIntSrc_A,
+	 .GetLoadTrig = GetLoadTrig_A,
+	 .GetMode = GetMode_A,
+	 .PulseIndex = PulseIndex_A,
+	 .SetEnable = SetEnable_A,
+	 .SetIntSrc = SetIntSrc_A,
+	 .SetLoadTrig = SetLoadTrig_A,
+	 .SetMode = SetMode_A,
+	 .ResetCapFlags = ResetCapFlags_A,
+	 .MyCRA = LP_CR0A,
+	 .MyCRB = LP_CR0B,
+	 .MyLatchLsw = LP_CNTR0ALSW,
+	 .MyEventBits = EVBITS(0),
+	 },
 	{
-	.GetEnable = GetEnable_A,
-	.GetIntSrc = GetIntSrc_A,
-	.GetLoadTrig = GetLoadTrig_A,
-	.GetMode = GetMode_A,
-	.PulseIndex = PulseIndex_A,
-	.SetEnable = SetEnable_A,
-	.SetIntSrc = SetIntSrc_A,
-	.SetLoadTrig = SetLoadTrig_A,
-	.SetMode = SetMode_A,
-	.ResetCapFlags = ResetCapFlags_A,
-	.MyCRA = LP_CR1A,
-	.MyCRB = LP_CR1B,
-	.MyLatchLsw = LP_CNTR1ALSW,
-	.MyEventBits = EVBITS(1),
-		},
+	 .GetEnable = GetEnable_A,
+	 .GetIntSrc = GetIntSrc_A,
+	 .GetLoadTrig = GetLoadTrig_A,
+	 .GetMode = GetMode_A,
+	 .PulseIndex = PulseIndex_A,
+	 .SetEnable = SetEnable_A,
+	 .SetIntSrc = SetIntSrc_A,
+	 .SetLoadTrig = SetLoadTrig_A,
+	 .SetMode = SetMode_A,
+	 .ResetCapFlags = ResetCapFlags_A,
+	 .MyCRA = LP_CR1A,
+	 .MyCRB = LP_CR1B,
+	 .MyLatchLsw = LP_CNTR1ALSW,
+	 .MyEventBits = EVBITS(1),
+	 },
 	{
-	.GetEnable = GetEnable_A,
-	.GetIntSrc = GetIntSrc_A,
-	.GetLoadTrig = GetLoadTrig_A,
-	.GetMode = GetMode_A,
-	.PulseIndex = PulseIndex_A,
-	.SetEnable = SetEnable_A,
-	.SetIntSrc = SetIntSrc_A,
-	.SetLoadTrig = SetLoadTrig_A,
-	.SetMode = SetMode_A,
-	.ResetCapFlags = ResetCapFlags_A,
-	.MyCRA = LP_CR2A,
-	.MyCRB = LP_CR2B,
-	.MyLatchLsw = LP_CNTR2ALSW,
-	.MyEventBits = EVBITS(2),
-		},
+	 .GetEnable = GetEnable_A,
+	 .GetIntSrc = GetIntSrc_A,
+	 .GetLoadTrig = GetLoadTrig_A,
+	 .GetMode = GetMode_A,
+	 .PulseIndex = PulseIndex_A,
+	 .SetEnable = SetEnable_A,
+	 .SetIntSrc = SetIntSrc_A,
+	 .SetLoadTrig = SetLoadTrig_A,
+	 .SetMode = SetMode_A,
+	 .ResetCapFlags = ResetCapFlags_A,
+	 .MyCRA = LP_CR2A,
+	 .MyCRB = LP_CR2B,
+	 .MyLatchLsw = LP_CNTR2ALSW,
+	 .MyEventBits = EVBITS(2),
+	 },
 	{
-	.GetEnable = GetEnable_B,
-	.GetIntSrc = GetIntSrc_B,
-	.GetLoadTrig = GetLoadTrig_B,
-	.GetMode = GetMode_B,
-	.PulseIndex = PulseIndex_B,
-	.SetEnable = SetEnable_B,
-	.SetIntSrc = SetIntSrc_B,
-	.SetLoadTrig = SetLoadTrig_B,
-	.SetMode = SetMode_B,
-	.ResetCapFlags = ResetCapFlags_B,
-	.MyCRA = LP_CR0A,
-	.MyCRB = LP_CR0B,
-	.MyLatchLsw = LP_CNTR0BLSW,
-	.MyEventBits = EVBITS(3),
-		},
+	 .GetEnable = GetEnable_B,
+	 .GetIntSrc = GetIntSrc_B,
+	 .GetLoadTrig = GetLoadTrig_B,
+	 .GetMode = GetMode_B,
+	 .PulseIndex = PulseIndex_B,
+	 .SetEnable = SetEnable_B,
+	 .SetIntSrc = SetIntSrc_B,
+	 .SetLoadTrig = SetLoadTrig_B,
+	 .SetMode = SetMode_B,
+	 .ResetCapFlags = ResetCapFlags_B,
+	 .MyCRA = LP_CR0A,
+	 .MyCRB = LP_CR0B,
+	 .MyLatchLsw = LP_CNTR0BLSW,
+	 .MyEventBits = EVBITS(3),
+	 },
 	{
-	.GetEnable = GetEnable_B,
-	.GetIntSrc = GetIntSrc_B,
-	.GetLoadTrig = GetLoadTrig_B,
-	.GetMode = GetMode_B,
-	.PulseIndex = PulseIndex_B,
-	.SetEnable = SetEnable_B,
-	.SetIntSrc = SetIntSrc_B,
-	.SetLoadTrig = SetLoadTrig_B,
-	.SetMode = SetMode_B,
-	.ResetCapFlags = ResetCapFlags_B,
-	.MyCRA = LP_CR1A,
-	.MyCRB = LP_CR1B,
-	.MyLatchLsw = LP_CNTR1BLSW,
-	.MyEventBits = EVBITS(4),
-		},
+	 .GetEnable = GetEnable_B,
+	 .GetIntSrc = GetIntSrc_B,
+	 .GetLoadTrig = GetLoadTrig_B,
+	 .GetMode = GetMode_B,
+	 .PulseIndex = PulseIndex_B,
+	 .SetEnable = SetEnable_B,
+	 .SetIntSrc = SetIntSrc_B,
+	 .SetLoadTrig = SetLoadTrig_B,
+	 .SetMode = SetMode_B,
+	 .ResetCapFlags = ResetCapFlags_B,
+	 .MyCRA = LP_CR1A,
+	 .MyCRB = LP_CR1B,
+	 .MyLatchLsw = LP_CNTR1BLSW,
+	 .MyEventBits = EVBITS(4),
+	 },
 	{
-	.GetEnable = GetEnable_B,
-	.GetIntSrc = GetIntSrc_B,
-	.GetLoadTrig = GetLoadTrig_B,
-	.GetMode = GetMode_B,
-	.PulseIndex = PulseIndex_B,
-	.SetEnable = SetEnable_B,
-	.SetIntSrc = SetIntSrc_B,
-	.SetLoadTrig = SetLoadTrig_B,
-	.SetMode = SetMode_B,
-	.ResetCapFlags = ResetCapFlags_B,
-	.MyCRA = LP_CR2A,
-	.MyCRB = LP_CR2B,
-	.MyLatchLsw = LP_CNTR2BLSW,
-	.MyEventBits = EVBITS(5),
-		},
+	 .GetEnable = GetEnable_B,
+	 .GetIntSrc = GetIntSrc_B,
+	 .GetLoadTrig = GetLoadTrig_B,
+	 .GetMode = GetMode_B,
+	 .PulseIndex = PulseIndex_B,
+	 .SetEnable = SetEnable_B,
+	 .SetIntSrc = SetIntSrc_B,
+	 .SetLoadTrig = SetLoadTrig_B,
+	 .SetMode = SetMode_B,
+	 .ResetCapFlags = ResetCapFlags_B,
+	 .MyCRA = LP_CR2A,
+	 .MyCRB = LP_CR2B,
+	 .MyLatchLsw = LP_CNTR2BLSW,
+	 .MyEventBits = EVBITS(5),
+	 },
 };
 
 /*  enab/disable a function or test status bit(s) that are accessed */
@@ -481,9 +497,9 @@ static struct enc_private enc_private_da
 #define I2C_B0(ATTR, VAL)	(((ATTR) << 2) | ((VAL) <<  8))
 
 static const struct comedi_lrange s626_range_table = { 2, {
-			RANGE(-5, 5),
-			RANGE(-10, 10),
-	}
+							   RANGE(-5, 5),
+							   RANGE(-10, 10),
+							   }
 };
 
 static int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -505,12 +521,12 @@ static int s626_attach(struct comedi_dev
 		return -ENOMEM;
 
 	for (pdev = pci_get_device(PCI_VENDOR_ID_S626, PCI_DEVICE_ID_S626,
-			NULL); pdev != NULL;
-		pdev = pci_get_device(PCI_VENDOR_ID_S626,
-			PCI_DEVICE_ID_S626, pdev)) {
+				   NULL); pdev != NULL;
+	     pdev = pci_get_device(PCI_VENDOR_ID_S626,
+				   PCI_DEVICE_ID_S626, pdev)) {
 		if (it->options[0] || it->options[1]) {
 			if (pdev->bus->number == it->options[0] &&
-				PCI_SLOT(pdev->devfn) == it->options[1]) {
+			    PCI_SLOT(pdev->devfn) == it->options[1]) {
 				/* matches requested bus/slot */
 				break;
 			}
@@ -555,7 +571,7 @@ static int s626_attach(struct comedi_dev
 		devpriv->allocatedBuf = 0;
 
 		devpriv->ANABuf.LogicalBase =
-			pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
+		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
 
 		if (devpriv->ANABuf.LogicalBase == NULL) {
 			printk("s626_attach: DMA Memory mapping error\n");
@@ -564,12 +580,15 @@ static int s626_attach(struct comedi_dev
 
 		devpriv->ANABuf.PhysicalBase = appdma;
 
-		DEBUG("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n", devpriv->ANABuf.LogicalBase, DMABUF_SIZE, (uint32_t) devpriv->ANABuf.PhysicalBase);
+		DEBUG
+		    ("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n",
+		     devpriv->ANABuf.LogicalBase, DMABUF_SIZE,
+		     (uint32_t) devpriv->ANABuf.PhysicalBase);
 
 		devpriv->allocatedBuf++;
 
 		devpriv->RPSBuf.LogicalBase =
-			pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE,  &appdma);
+		    pci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);
 
 		if (devpriv->RPSBuf.LogicalBase == NULL) {
 			printk("s626_attach: DMA Memory mapping error\n");
@@ -578,7 +597,10 @@ static int s626_attach(struct comedi_dev
 
 		devpriv->RPSBuf.PhysicalBase = appdma;
 
-		DEBUG("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n", devpriv->RPSBuf.LogicalBase, DMABUF_SIZE, (uint32_t) devpriv->RPSBuf.PhysicalBase);
+		DEBUG
+		    ("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n",
+		     devpriv->RPSBuf.LogicalBase, DMABUF_SIZE,
+		     (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
 		devpriv->allocatedBuf++;
 
@@ -607,7 +629,7 @@ static int s626_attach(struct comedi_dev
 	}
 
 	DEBUG("s626_attach: -- it opts  %d,%d -- \n",
-		it->options[0], it->options[1]);
+	      it->options[0], it->options[1]);
 
 	s = dev->subdevices + 0;
 	/* analog input subdevice */
@@ -696,20 +718,22 @@ static int s626_attach(struct comedi_dev
 		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
 		/*  Configure DEBI operating mode. */
 		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
-			/*  bits wide. */
-			| (DEBI_TOUT << DEBI_CFG_TOUT_BIT)	/*  Declare DEBI */
-			/*  transfer timeout */
-			/*  interval. */
-			| DEBI_SWAP	/*  Set up byte lane */
-			/*  steering. */
-			| DEBI_CFG_INTEL);	/*  Intel-compatible */
+		       /*  bits wide. */
+		       | (DEBI_TOUT << DEBI_CFG_TOUT_BIT)
+
+		       /*  Declare DEBI */
+		       /*  transfer timeout */
+		       /*  interval. */
+		       |DEBI_SWAP	/*  Set up byte lane */
+		       /*  steering. */
+		       | DEBI_CFG_INTEL);	/*  Intel-compatible */
 		/*  local bus (DEBI */
 		/*  never times out). */
 		DEBUG("s626_attach: %d debi init -- %d\n",
-			DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
-			DEBI_SWAP | DEBI_CFG_INTEL,
-			DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
-			DEBI_CFG_16Q);
+		      DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
+		      DEBI_SWAP | DEBI_CFG_INTEL,
+		      DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
+		      DEBI_CFG_16Q);
 
 		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
 		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
@@ -720,22 +744,22 @@ static int s626_attach(struct comedi_dev
 		/*  Init GPIO so that ADC Start* is negated. */
 		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
 
-    /* IsBoardRevA is a boolean that indicates whether the board is RevA.
-     *
-     * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
-     * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
-     * is used to access the onboard serial EEPROM.  The EEPROM's I2C
-     * DeviceAddress is hardwired to a value that is dependent on the
-     * 626 board revision.  On all board revisions, the EEPROM stores
-     * TrimDAC calibration constants for analog I/O.  On RevB and
-     * higher boards, the DeviceAddress is hardwired to 0 to enable
-     * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
-     * this is the address at which the SAA7146 expects a
-     * configuration EEPROM to reside.  On RevA boards, the EEPROM
-     * device address, which is hardwired to 4, prevents the SAA7146
-     * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
-     * default values, instead.
-     */
+		/* IsBoardRevA is a boolean that indicates whether the board is RevA.
+		 *
+		 * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
+		 * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
+		 * is used to access the onboard serial EEPROM.  The EEPROM's I2C
+		 * DeviceAddress is hardwired to a value that is dependent on the
+		 * 626 board revision.  On all board revisions, the EEPROM stores
+		 * TrimDAC calibration constants for analog I/O.  On RevB and
+		 * higher boards, the DeviceAddress is hardwired to 0 to enable
+		 * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
+		 * this is the address at which the SAA7146 expects a
+		 * configuration EEPROM to reside.  On RevA boards, the EEPROM
+		 * device address, which is hardwired to 4, prevents the SAA7146
+		 * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
+		 * default values, instead.
+		 */
 
 		/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
 		/*  DeviceType (0xA0) */
@@ -750,8 +774,7 @@ static int s626_attach(struct comedi_dev
 		/*  Write I2C control: abort any I2C activity. */
 		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 		/*  Invoke command  upload */
-		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)
-			;
+		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0) ;
 		/*  and wait for upload to complete. */
 
 		/* Per SAA7146 data sheet, write to STATUS reg twice to
@@ -760,8 +783,7 @@ static int s626_attach(struct comedi_dev
 			WR7146(P_I2CSTAT, I2C_CLKSEL);
 			/*  Write I2C control: reset  error flags. */
 			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-				;
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
 			/* and wait for upload to complete. */
 		}
 
@@ -842,8 +864,8 @@ static int s626_attach(struct comedi_dev
 		 * enabled. */
 
 		pPhysBuf =
-			devpriv->ANABuf.PhysicalBase +
-			(DAC_WDMABUF_OS * sizeof(uint32_t));
+		    devpriv->ANABuf.PhysicalBase +
+		    (DAC_WDMABUF_OS * sizeof(uint32_t));
 
 		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
 		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
@@ -851,8 +873,7 @@ static int s626_attach(struct comedi_dev
 		/* Cache Audio2's output DMA buffer logical address.  This is
 		 * where DAC data is buffered for A2 output DMA transfers. */
 		devpriv->pDacWBuf =
-			(uint32_t *) devpriv->ANABuf.LogicalBase +
-			DAC_WDMABUF_OS;
+		    (uint32_t *) devpriv->ANABuf.LogicalBase + DAC_WDMABUF_OS;
 
 		/* Audio2's output channels does not use paging.  The protection
 		 * violation handling bit is set so that the DMAC will
@@ -937,7 +958,8 @@ static int s626_attach(struct comedi_dev
 		 * charger, and reset the watchdog interval selector to zero.
 		 */
 		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
-					LP_RDMISC2) & MISC2_BATT_ENABLE));
+						     LP_RDMISC2) &
+					    MISC2_BATT_ENABLE));
 
 		/*  Initialize the digital I/O subsystem. */
 		s626_dio_init(dev);
@@ -947,7 +969,7 @@ static int s626_attach(struct comedi_dev
 	}
 
 	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,
-		(uint32_t) devpriv->base_addr);
+	      (uint32_t) devpriv->base_addr);
 
 	return 1;
 }
@@ -1030,10 +1052,11 @@ static irqreturn_t s626_irq_handler(int 
 			/* put data into read buffer */
 			/*  comedi_buf_put(s->async, tempdata); */
 			if (cfc_write_to_buffer(s, tempdata) == 0)
-				printk("s626_irq_handler: cfc_write_to_buffer error!\n");
+				printk
+				    ("s626_irq_handler: cfc_write_to_buffer error!\n");
 
 			DEBUG("s626_irq_handler: ai channel %d acquired: %d\n",
-				i, tempdata);
+			      i, tempdata);
 		}
 
 		/* end of scan occurs */
@@ -1055,7 +1078,9 @@ static irqreturn_t s626_irq_handler(int 
 		}
 
 		if (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT) {
-			DEBUG("s626_irq_handler: enable interrupt on dio channel %d\n", cmd->scan_begin_arg);
+			DEBUG
+			    ("s626_irq_handler: enable interrupt on dio channel %d\n",
+			     cmd->scan_begin_arg);
 
 			s626_dio_set_irq(dev, cmd->scan_begin_arg);
 
@@ -1079,102 +1104,120 @@ static irqreturn_t s626_irq_handler(int 
 			irqbit = 0;
 			/* read interrupt type */
 			irqbit = DEBIread(dev,
-				((struct dio_private *) (dev->subdevices + 2 +
-						group)->private)->RDCapFlg);
+					  ((struct dio_private *)(dev->
+								  subdevices +
+								  2 +
+								  group)->
+					   private)->RDCapFlg);
 
 			/* check if interrupt is generated from dio channels */
 			if (irqbit) {
 				s626_dio_reset_irq(dev, group, irqbit);
-				DEBUG("s626_irq_handler: check interrupt on dio group %d %d\n", group, i);
+				DEBUG
+				    ("s626_irq_handler: check interrupt on dio group %d %d\n",
+				     group, i);
 				if (devpriv->ai_cmd_running) {
 					/* check if interrupt is an ai acquisition start trigger */
 					if ((irqbit >> (cmd->start_arg -
-								(16 * group)))
-						== 1
-						&& cmd->start_src == TRIG_EXT) {
-						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->start_arg);
+							(16 * group)))
+					    == 1 && cmd->start_src == TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						     cmd->start_arg);
 
 						/*  Start executing the RPS program. */
 						MC_ENABLE(P_MC1, MC1_ERPS1);
 
-						DEBUG("s626_irq_handler: aquisition start triggered!!!\n");
+						DEBUG
+						    ("s626_irq_handler: aquisition start triggered!!!\n");
 
 						if (cmd->scan_begin_src ==
-							TRIG_EXT) {
-							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d\n", cmd->scan_begin_arg);
+						    TRIG_EXT) {
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d\n",
+							     cmd->
+							     scan_begin_arg);
 
 							s626_dio_set_irq(dev,
-								cmd->
-								scan_begin_arg);
+									 cmd->scan_begin_arg);
 
-							DEBUG("s626_irq_handler: External scan trigger is set!!!\n");
+							DEBUG
+							    ("s626_irq_handler: External scan trigger is set!!!\n");
 						}
 					}
 					if ((irqbit >> (cmd->scan_begin_arg -
-								(16 * group)))
-						== 1
-						&& cmd->scan_begin_src ==
-						TRIG_EXT) {
-						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->scan_begin_arg);
+							(16 * group)))
+					    == 1
+					    && cmd->scan_begin_src ==
+					    TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						     cmd->scan_begin_arg);
 
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-						DEBUG("s626_irq_handler: scan triggered!!! %d\n", devpriv->ai_sample_count);
+						DEBUG
+						    ("s626_irq_handler: scan triggered!!! %d\n",
+						     devpriv->ai_sample_count);
 						if (cmd->convert_src ==
-							TRIG_EXT) {
+						    TRIG_EXT) {
 
-							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d group %d\n", cmd->convert_arg - (16 * group), group);
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
+							     cmd->convert_arg -
+							     (16 * group),
+							     group);
 
-							devpriv->
-								ai_convert_count
-								=
-								cmd->
-								chanlist_len;
+							devpriv->ai_convert_count
+							    = cmd->chanlist_len;
 
 							s626_dio_set_irq(dev,
-								cmd->
-								convert_arg);
+									 cmd->convert_arg);
 
-							DEBUG("s626_irq_handler: External convert trigger is set!!!\n");
+							DEBUG
+							    ("s626_irq_handler: External convert trigger is set!!!\n");
 						}
 
 						if (cmd->convert_src ==
-							TRIG_TIMER) {
+						    TRIG_TIMER) {
 							k = &encpriv[5];
-							devpriv->
-								ai_convert_count
-								=
-								cmd->
-								chanlist_len;
+							devpriv->ai_convert_count
+							    = cmd->chanlist_len;
 							k->SetEnable(dev, k,
-								CLKENAB_ALWAYS);
+								     CLKENAB_ALWAYS);
 						}
 					}
 					if ((irqbit >> (cmd->convert_arg -
-								(16 * group)))
-						== 1
-						&& cmd->convert_src ==
-						TRIG_EXT) {
-						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->convert_arg);
+							(16 * group)))
+					    == 1
+					    && cmd->convert_src == TRIG_EXT) {
+						DEBUG
+						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						     cmd->convert_arg);
 
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
-						DEBUG("s626_irq_handler: adc convert triggered!!!\n");
+						DEBUG
+						    ("s626_irq_handler: adc convert triggered!!!\n");
 
 						devpriv->ai_convert_count--;
 
 						if (devpriv->ai_convert_count >
-							0) {
+						    0) {
 
-							DEBUG("s626_ai_cmd: enable interrupt on dio channel %d group %d\n", cmd->convert_arg - (16 * group), group);
+							DEBUG
+							    ("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",
+							     cmd->convert_arg -
+							     (16 * group),
+							     group);
 
 							s626_dio_set_irq(dev,
-								cmd->
-								convert_arg);
+									 cmd->convert_arg);
 
-							DEBUG("s626_irq_handler: External trigger is set!!!\n");
+							DEBUG
+							    ("s626_irq_handler: External trigger is set!!!\n");
 						}
 					}
 				}
@@ -1187,38 +1230,43 @@ static irqreturn_t s626_irq_handler(int 
 
 		/* check interrupt on counters */
 		DEBUG("s626_irq_handler: check counters interrupt %d\n",
-			irqbit);
+		      irqbit);
 
 		if (irqbit & IRQ_COINT1A) {
-			DEBUG("s626_irq_handler: interrupt on counter 1A overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 1A overflow\n");
 			k = &encpriv[0];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2A) {
-			DEBUG("s626_irq_handler: interrupt on counter 2A overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 2A overflow\n");
 			k = &encpriv[1];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT3A) {
-			DEBUG("s626_irq_handler: interrupt on counter 3A overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 3A overflow\n");
 			k = &encpriv[2];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT1B) {
-			DEBUG("s626_irq_handler: interrupt on counter 1B overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 1B overflow\n");
 			k = &encpriv[3];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2B) {
-			DEBUG("s626_irq_handler: interrupt on counter 2B overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 2B overflow\n");
 			k = &encpriv[4];
 
 			/* clear interrupt capture flag */
@@ -1230,7 +1278,9 @@ static irqreturn_t s626_irq_handler(int 
 					k->SetEnable(dev, k, CLKENAB_INDEX);
 
 				if (cmd->convert_src == TRIG_TIMER) {
-					DEBUG("s626_irq_handler: conver timer trigger!!! %d\n", devpriv->ai_convert_count);
+					DEBUG
+					    ("s626_irq_handler: conver timer trigger!!! %d\n",
+					     devpriv->ai_convert_count);
 
 					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 					MC_ENABLE(P_MC2, MC2_ADC_RPS);
@@ -1238,21 +1288,24 @@ static irqreturn_t s626_irq_handler(int 
 			}
 		}
 		if (irqbit & IRQ_COINT3B) {
-			DEBUG("s626_irq_handler: interrupt on counter 3B overflow\n");
+			DEBUG
+			    ("s626_irq_handler: interrupt on counter 3B overflow\n");
 			k = &encpriv[5];
 
 			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 
 			if (cmd->scan_begin_src == TRIG_TIMER) {
-				DEBUG("s626_irq_handler: scan timer trigger!!!\n");
+				DEBUG
+				    ("s626_irq_handler: scan timer trigger!!!\n");
 
 				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 				MC_ENABLE(P_MC2, MC2_ADC_RPS);
 			}
 
 			if (cmd->convert_src == TRIG_TIMER) {
-				DEBUG("s626_irq_handler: convert timer trigger is set\n");
+				DEBUG
+				    ("s626_irq_handler: convert timer trigger is set\n");
 				k = &encpriv[4];
 				devpriv->ai_convert_count = cmd->chanlist_len;
 				k->SetEnable(dev, k, CLKENAB_ALWAYS);
@@ -1312,7 +1365,7 @@ static int s626_detach(struct comedi_dev
 /*
  * this functions build the RPS program for hardware driven acquistion
  */
-void ResetADC(struct comedi_device *dev, uint8_t *ppl)
+void ResetADC(struct comedi_device *dev, uint8_t * ppl)
 {
 	register uint32_t *pRPS;
 	uint32_t JmpAdrs;
@@ -1366,14 +1419,14 @@ void ResetADC(struct comedi_device *dev,
 	 * forgot to set the EOPL flag in the final slot.
 	 */
 	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {
-	 /* Convert application's poll list item to private board class
-	  * format.  Each app poll list item is an uint8_t with form
-	  * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
-	  * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
-	  */
+		/* Convert application's poll list item to private board class
+		 * format.  Each app poll list item is an uint8_t with form
+		 * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
+		 * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+		 */
 		LocalPPL =
-			(*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
-			GSEL_BIPOLAR10V);
+		    (*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
+				   GSEL_BIPOLAR10V);
 
 		/*  Switch ADC analog gain. */
 		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	/*  Write DEBI command */
@@ -1413,9 +1466,9 @@ void ResetADC(struct comedi_device *dev,
 		 * instruction prefetch pipeline.
 		 */
 		JmpAdrs =
-			(uint32_t) devpriv->RPSBuf.PhysicalBase +
-			(uint32_t) ((unsigned long)pRPS -
-			(unsigned long)devpriv->RPSBuf.LogicalBase);
+		    (uint32_t) devpriv->RPSBuf.PhysicalBase +
+		    (uint32_t) ((unsigned long)pRPS -
+				(unsigned long)devpriv->RPSBuf.LogicalBase);
 		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
 			JmpAdrs += 8;	/*  Repeat to implement time delay: */
 			*pRPS++ = RPS_JUMP;	/*  Jump to next RPS instruction. */
@@ -1445,8 +1498,8 @@ void ResetADC(struct comedi_device *dev,
 		/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
 		*pRPS++ =
-			(uint32_t) devpriv->ANABuf.PhysicalBase +
-			(devpriv->AdcItems << 2);
+		    (uint32_t) devpriv->ANABuf.PhysicalBase +
+		    (devpriv->AdcItems << 2);
 
 		/*  If this slot's EndOfPollList flag is set, all channels have */
 		/*  now been processed. */
@@ -1485,8 +1538,7 @@ void ResetADC(struct comedi_device *dev,
 	/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
 	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	/*  */
 	*pRPS++ =
-		(uint32_t) devpriv->ANABuf.PhysicalBase +
-		(devpriv->AdcItems << 2);
+	    (uint32_t) devpriv->ANABuf.PhysicalBase + (devpriv->AdcItems << 2);
 
 	/*  Indicate ADC scan loop is finished. */
 	/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */
@@ -1504,8 +1556,9 @@ void ResetADC(struct comedi_device *dev,
 }
 
 /* TO COMPLETE, IF NECESSARY */
-static int s626_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
 	return -EINVAL;
@@ -1541,8 +1594,9 @@ static int s626_ai_insn_config(struct co
 /*   return i; */
 /* } */
 
-static int s626_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_ai_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	uint16_t chan = CR_CHAN(insn->chanspec);
 	uint16_t range = CR_RANGE(insn->chanspec);
@@ -1550,7 +1604,7 @@ static int s626_ai_insn_read(struct come
 	uint32_t GpioImage;
 	int n;
 
- /* interrupt call test  */
+	/* interrupt call test  */
 /*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); */
 	/* Writing a logical 1 into any of the RPS_PSR bits causes the
 	 * corresponding interrupt to be generated if enabled
@@ -1592,8 +1646,7 @@ static int s626_ai_insn_read(struct come
 		/*  shift into FB BUFFER 1 register. */
 
 		/*  Wait for ADC done. */
-		while (!(RR7146(P_PSR) & PSR_GPIO2))
-			;
+		while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
 
 		/*  Fetch ADC data. */
 		if (n != 0)
@@ -1625,8 +1678,7 @@ static int s626_ai_insn_read(struct come
 	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
 	/*  Wait for ADC done. */
-	while (!(RR7146(P_PSR) & PSR_GPIO2))
-		;
+	while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
 
 	/*  Fetch ADC data from audio interface's input shift register. */
 
@@ -1639,7 +1691,7 @@ static int s626_ai_insn_read(struct come
 	return n;
 }
 
-static int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)
+static int s626_ai_load_polllist(uint8_t * ppl, struct comedi_cmd *cmd)
 {
 
 	int n;
@@ -1655,8 +1707,8 @@ static int s626_ai_load_polllist(uint8_t
 	return n;
 }
 
-static int s626_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+static int s626_ai_inttrig(struct comedi_device *dev,
+			   struct comedi_subdevice *s, unsigned int trignum)
 {
 	if (trignum != 0)
 		return -EINVAL;
@@ -1686,7 +1738,7 @@ static int s626_ai_cmd(struct comedi_dev
 
 	if (devpriv->ai_cmd_running) {
 		printk("s626_ai_cmd: Another ai_cmd is running %d\n",
-			dev->minor);
+		       dev->minor);
 		return -EBUSY;
 	}
 	/* disable interrupt */
@@ -1712,7 +1764,7 @@ static int s626_ai_cmd(struct comedi_dev
 
 	if (dev->irq == 0) {
 		comedi_error(dev,
-			"s626_ai_cmd: cannot run command without an irq");
+			     "s626_ai_cmd: cannot run command without an irq");
 		return -EIO;
 	}
 
@@ -1727,14 +1779,14 @@ static int s626_ai_cmd(struct comedi_dev
 		/*  set a conter to generate adc trigger at scan_begin_arg interval */
 		k = &encpriv[5];
 		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_ALWAYS);
 
 		DEBUG("s626_ai_cmd: scan trigger timer is set with value %d\n",
-			tick);
+		      tick);
 
 		break;
 	case TRIG_EXT:
@@ -1754,18 +1806,20 @@ static int s626_ai_cmd(struct comedi_dev
 		/*  set a conter to generate adc trigger at convert_arg interval */
 		k = &encpriv[4];
 		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 
 		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_INDEX);
 
-		DEBUG("s626_ai_cmd: convert trigger timer is set with value %d\n", tick);
+		DEBUG
+		    ("s626_ai_cmd: convert trigger timer is set with value %d\n",
+		     tick);
 		break;
 	case TRIG_EXT:
 		/*  set the digital line and interrupt for convert trigger */
 		if (cmd->scan_begin_src != TRIG_EXT
-			&& cmd->start_src == TRIG_EXT)
+		    && cmd->start_src == TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->convert_arg);
 
 		DEBUG("s626_ai_cmd: External convert trigger is set!!!\n");
@@ -1820,8 +1874,8 @@ static int s626_ai_cmd(struct comedi_dev
 	return 0;
 }
 
-static int s626_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int s626_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1868,11 +1922,11 @@ static int s626_ai_cmdtest(struct comedi
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT
-		&& cmd->scan_begin_src != TRIG_FOLLOW)
+	    cmd->scan_begin_src != TRIG_EXT
+	    && cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1965,21 +2019,21 @@ static int s626_ai_cmdtest(struct comedi
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		s626_ns_to_timer((int *)&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		s626_ns_to_timer((int *)&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->scan_end_arg) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -2032,7 +2086,7 @@ static int s626_ns_to_timer(int *nanosec
 }
 
 static int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 
 	int i;
@@ -2051,7 +2105,7 @@ static int s626_ao_winsn(struct comedi_d
 }
 
 static int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -2096,8 +2150,9 @@ static void s626_dio_init(struct comedi_
  * This allows packed reading/writing of the DIO channels.  The comedi
  * core can convert between insn_bits and insn_read/write */
 
-static int s626_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 
 	/* Length of data must be 2 (mask and new data, see below) */
@@ -2105,7 +2160,9 @@ static int s626_dio_insn_bits(struct com
 		return 0;
 
 	if (insn->n != 2) {
-		printk("comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length\n", dev->minor);
+		printk
+		    ("comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length\n",
+		     dev->minor);
 		return -EINVAL;
 	}
 
@@ -2132,16 +2189,17 @@ static int s626_dio_insn_bits(struct com
 	return 2;
 }
 
-static int s626_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->io_bits & (1 << CR_CHAN(insn->
-					chanspec))) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (s->
+		     io_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :
+		    COMEDI_INPUT;
 		return insn->n;
 		break;
 	case COMEDI_INPUT:
@@ -2169,50 +2227,55 @@ static int s626_dio_set_irq(struct comed
 	group = chan / 16;
 	bitmask = 1 << (chan - (16 * group));
 	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
-		chan - (16 * group), group);
+	      chan - (16 * group), group);
 
 	/* set channel to capture positive edge */
 	status = DEBIread(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->RDEdgSel);
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDEdgSel);
 	DEBIwrite(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->WREdgSel, bitmask | status);
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WREdgSel,
+		  bitmask | status);
 
 	/* enable interrupt on selected channel */
 	status = DEBIread(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->RDIntSel);
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDIntSel);
 	DEBIwrite(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->WRIntSel, bitmask | status);
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRIntSel,
+		  bitmask | status);
 
 	/* enable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
 
 	/* enable edge capture on selected channel */
 	status = DEBIread(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->RDCapSel);
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->RDCapSel);
 	DEBIwrite(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->WRCapSel, bitmask | status);
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRCapSel,
+		  bitmask | status);
 
 	return 0;
 }
 
 static int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,
-	unsigned int mask)
+			      unsigned int mask)
 {
-	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
+	DEBUG
+	    ("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n",
+	     mask, group);
 
 	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	/* enable edge capture on selected channel */
 	DEBIwrite(dev,
-		((struct dio_private *) (dev->subdevices + 2 +
-				group)->private)->WRCapSel, mask);
+		  ((struct dio_private *)(dev->subdevices + 2 +
+					  group)->private)->WRCapSel, mask);
 
 	return 0;
 }
@@ -2227,8 +2290,9 @@ static int s626_dio_clear_irq(struct com
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		/* clear pending events and interrupt */
 		DEBIwrite(dev,
-			((struct dio_private *) (dev->subdevices + 2 +
-					group)->private)->WRCapSel, 0xffff);
+			  ((struct dio_private *)(dev->subdevices + 2 +
+						  group)->private)->WRCapSel,
+			  0xffff);
 	}
 
 	return 0;
@@ -2237,17 +2301,18 @@ static int s626_dio_clear_irq(struct com
 /* Now this function initializes the value of the counter (data[0])
    and set the subdevice. To complete with trigger and interrupt
    configuration */
-static int s626_enc_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_enc_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-		/*  index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-		(CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
-		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-		/* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
-		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    /* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);
 	/*   uint16_t DisableIntSrc=TRUE; */
 	/*  uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t valueSrclatch = LATCHSRC_AB_READ;
@@ -2267,15 +2332,16 @@ static int s626_enc_insn_config(struct c
 	return insn->n;
 }
 
-static int s626_enc_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_enc_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 
 	int n;
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_read: encoder read channel %d \n",
-		CR_CHAN(insn->chanspec));
+	      CR_CHAN(insn->chanspec));
 
 	for (n = 0; n < insn->n; n++)
 		data[n] = ReadLatch(dev, k);
@@ -2285,14 +2351,15 @@ static int s626_enc_insn_read(struct com
 	return n;
 }
 
-static int s626_enc_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s626_enc_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
 	struct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_write: encoder write channel %d \n",
-		CR_CHAN(insn->chanspec));
+	      CR_CHAN(insn->chanspec));
 
 	/*  Set the preload register */
 	Preload(dev, k, data[0]);
@@ -2308,16 +2375,17 @@ static int s626_enc_insn_write(struct co
 	return 1;
 }
 
-static void s626_timer_load(struct comedi_device *dev, struct enc_private *k, int tick)
+static void s626_timer_load(struct comedi_device *dev, struct enc_private *k,
+			    int tick)
 {
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-		/*  index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-		(CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
-		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-		(CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
-		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    (CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);
 	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
 	/*   uint16_t enab=CLKENAB_ALWAYS; */
 
@@ -2352,7 +2420,7 @@ static uint8_t trimchan[] = { 10, 9, 8, 
 
 /*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
 static uint8_t trimadrs[] =
-	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
+    { 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
 static void LoadTrimDACs(struct comedi_device *dev)
 {
@@ -2364,7 +2432,7 @@ static void LoadTrimDACs(struct comedi_d
 }
 
 static void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,
-	uint8_t DacData)
+			 uint8_t DacData)
 {
 	uint32_t chan;
 
@@ -2411,22 +2479,26 @@ static uint8_t I2Cread(struct comedi_dev
 	/*  Send EEPROM target address. */
 	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
 			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
-			| I2C_B1(I2C_ATTRSTOP, addr)
+			 | I2C_B1(I2C_ATTRSTOP, addr)
 			 /* Byte1 = EEPROM internal target address. */
-			| I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
+			 | I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not sent. */
 		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread  a\n");
 		return 0;
 	}
 	/*  Execute EEPROM read. */
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	/*  Byte2 = I2C */
-			/*  command: read */
-			/*  from I2C EEPROM */
-			/*  device. */
-			| I2C_B1(I2C_ATTRSTOP, 0)	/*  Byte1 receives */
-			/*  uint8_t from */
-			/*  EEPROM. */
-			| I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)
+
+			 /*  Byte2 = I2C */
+			 /*  command: read */
+			 /*  from I2C EEPROM */
+			 /*  device. */
+			 |I2C_B1(I2C_ATTRSTOP, 0)
+
+			 /*  Byte1 receives */
+			 /*  uint8_t from */
+			 /*  EEPROM. */
+			 |I2C_B0(I2C_ATTRNOP, 0))) {	/*  Byte0 = Not  sent. */
 
 		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread b\n");
@@ -2446,12 +2518,10 @@ static uint32_t I2Chandshake(struct come
 	/*  upload confirmation. */
 
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
-	while (!MC_TEST(P_MC2, MC2_UPLD_IIC))
-		;
+	while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
 
 	/*  Wait until I2C bus transfer is finished or an error occurs. */
-	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
-		;
+	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY) ;
 
 	/*  Return non-zero if I2C error occured. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
@@ -2565,8 +2635,7 @@ static void SendDAC(struct comedi_device
 	 * Done by polling the DMAC enable flag; this flag is automatically
 	 * cleared when the transfer has finished.
 	 */
-	while ((RR7146(P_MC1) & MC1_A2OUT) != 0)
-		;
+	while ((RR7146(P_MC1) & MC1_A2OUT) != 0) ;
 
 	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
@@ -2583,8 +2652,7 @@ static void SendDAC(struct comedi_device
 	 * finished transferring the DAC's data DWORD from the output FIFO
 	 * to the output buffer register.
 	 */
-	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)
-		;
+	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0) ;
 
 	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
 	 * back to slot 0 after executing the EOS in slot 5.  Also,
@@ -2620,8 +2688,7 @@ static void SendDAC(struct comedi_device
 		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
 		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
 		 */
-		 while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)
-			;
+		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
 	}
 	/* Either (1) we were too late setting the slot 0 trap; the TSL
 	 * sequencer restarted slot 0 before we could set the EOS trap flag,
@@ -2637,8 +2704,7 @@ static void SendDAC(struct comedi_device
 	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
 	 * from 0x00 to 0xFF.
 	 */
-	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)
-		;
+	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0) ;
 }
 
 static void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)
@@ -2677,12 +2743,10 @@ static void DEBItransfer(struct comedi_d
 
 	/*  Wait for completion of upload from shadow RAM to DEBI control */
 	/*  register. */
-	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI))
-		;
+	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI)) ;
 
 	/*  Wait until DEBI transfer is done. */
-	while (RR7146(P_PSR) & PSR_DEBI_S)
-		;
+	while (RR7146(P_PSR) & PSR_DEBI_S) ;
 }
 
 /*  Write a value to a gate array register. */
@@ -2702,7 +2766,7 @@ static void DEBIwrite(struct comedi_devi
  * or'd with the masked original.
  */
 static void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,
-	uint16_t wdata)
+			uint16_t wdata)
 {
 
 	/*  Copy target gate array register into P_DEBIAD register. */
@@ -2719,7 +2783,8 @@ static void DEBIreplace(struct comedi_de
 	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
-static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma, size_t bsize)
+static void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,
+		      size_t bsize)
 {
 	void *vbptr;
 	dma_addr_t vpptr;
@@ -2737,7 +2802,7 @@ static void CloseDMAB(struct comedi_devi
 		pdma->PhysicalBase = 0;
 
 		DEBUG("CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x\n",
-			vbptr, bsize, (uint32_t) vpptr);
+		      vbptr, bsize, (uint32_t) vpptr);
 	}
 }
 
@@ -2776,13 +2841,13 @@ static uint32_t ReadLatch(struct comedi_
 static void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
 static void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)
 {
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
 /*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
@@ -2801,26 +2866,25 @@ static uint16_t GetMode_A(struct comedi_
 	/*  Populate the standardized counter setup bit fields.  Note: */
 	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 	setup = ((cra & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcA. */
-		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
-		| ((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
-		| ((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
-		| ((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
-		| ((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
+		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
+		 |((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
+		 |((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
+		 |((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
+		 |((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
 
 	/*  Adjust mode-dependent parameters. */
 	if (cra & (2 << CRABIT_CLKSRC_A))	/*  If Timer mode (ClkSrcA<1> == 1): */
 		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			| ((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
-			| (MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
+			  |((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
+			  |(MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
 
 	else			/*  If Counter mode (ClkSrcA<1> == 0): */
 		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Counter mode. */
-			| ((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
-			| (((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
-				(MULT_X1 << STDBIT_CLKMULT) :
-				((cra >> (CRABIT_CLKMULT_A -
-							STDBIT_CLKMULT)) &
-					STDMSK_CLKMULT)));
+			  |((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
+			  |(((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
+			    (MULT_X1 << STDBIT_CLKMULT) :
+			    ((cra >> (CRABIT_CLKMULT_A -
+				      STDBIT_CLKMULT)) & STDMSK_CLKMULT)));
 
 	/*  Return adjusted counter setup. */
 	return setup;
@@ -2839,27 +2903,27 @@ static uint16_t GetMode_B(struct comedi_
 	/*  Populate the standardized counter setup bit fields.  Note: */
 	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcB. */
-		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
-		| ((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
-		| ((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
-		| ((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
-		| ((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
+		 |((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
+		 |((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
+		 |((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
+		 |((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
+		 |((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
 
 	/*  Adjust mode-dependent parameters. */
 	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	/*  If Extender mode (ClkMultB == MULT_X0): */
 		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	/*    Indicate Extender mode. */
-			| (MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
-			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
 
 	else if (cra & (2 << CRABIT_CLKSRC_B))	/*  If Timer mode (ClkSrcB<1> == 1): */
 		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			| (MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
-			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+			  |(MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			  |((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
 
 	else			/*  If Counter mode (ClkSrcB<1> == 0): */
 		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
-			| ((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
-			| ((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
+			  |((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
+			  |((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
 
 	/*  Return adjusted counter setup. */
 	return setup;
@@ -2872,8 +2936,8 @@ static uint16_t GetMode_B(struct comedi_
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 
-static void SetMode_A(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
-	uint16_t DisableIntSrc)
+static void SetMode_A(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2881,15 +2945,15 @@ static void SetMode_A(struct comedi_devi
 
 	/*  Initialize CRA and CRB images. */
 	cra = ((setup & CRAMSK_LOADSRC_A)	/*  Preload trigger is passed through. */
-		| ((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	       |((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 
 	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	/*  Reset any pending CounterA event captures. */
-		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
+	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
 
 	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-				CRABIT_INTSRC_A));
+						    CRABIT_INTSRC_A));
 
 	/*  Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
@@ -2898,25 +2962,25 @@ static void SetMode_A(struct comedi_devi
 
 	case CLKSRC_TIMER:	/*  Timer Mode: */
 		cra |= ((2 << CRABIT_CLKSRC_A)	/*    ClkSrcA<1> selects system clock */
-			| ((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
-			| (1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
-			| (MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
+			|((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
+			|(1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
+			|(MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
 		break;
 
 	default:		/*  Counter Mode: */
 		cra |= (CLKSRC_COUNTER	/*    Select ENC_C and ENC_D as clock/direction inputs. */
 			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	/*    Clock polarity is passed through. */
-			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
-				(MULT_X1 << CRABIT_CLKMULT_A) :
-				((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
-						STDBIT_CLKMULT))));
+			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
+			  (MULT_X1 << CRABIT_CLKMULT_A) :
+			  ((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
+							STDBIT_CLKMULT))));
 	}
 
 	/*  Force positive index polarity if IndxSrc is software-driven only, */
 	/*  otherwise pass it through. */
 	if (~setup & STDMSK_INDXSRC)
 		cra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -
-				STDBIT_INDXPOL));
+						     STDBIT_INDXPOL));
 
 	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
 	/*  enable mask to indicate the counter interrupt is disabled. */
@@ -2927,11 +2991,11 @@ static void SetMode_A(struct comedi_devi
 	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
 }
 
-static void SetMode_B(struct comedi_device *dev, struct enc_private *k, uint16_t Setup,
-	uint16_t DisableIntSrc)
+static void SetMode_B(struct comedi_device *dev, struct enc_private *k,
+		      uint16_t Setup, uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2941,44 +3005,44 @@ static void SetMode_B(struct comedi_devi
 	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	/*  IndexSrc field is restricted to ENC_X or IndxPol. */
 
 	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	/*  Reset event captures and disable interrupts. */
-		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
-		| ((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
+	       | ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
+	       |((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
 
 	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		crb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
-				CRBBIT_INTSRC_B));
+						    CRBBIT_INTSRC_B));
 
 	/*  Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
 	case CLKSRC_TIMER:	/*  Timer Mode: */
 		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB<1> selects system clock */
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
+			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
 		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB behaves as always-on clock enable. */
-			| (MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
+			|(MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
 		break;
 
 	case CLKSRC_EXTENDER:	/*  Extender Mode: */
 		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB source is OverflowA (same as "timer") */
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
+			|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
 		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB controls IndexB -- always set to active. */
-			| (MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
+			|(MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
 		break;
 
 	default:		/*  Counter Mode: */
 		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	/*    Select ENC_C and ENC_D as clock/direction inputs. */
 		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	/*    ClkPol is passed through. */
-			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
-				(MULT_X1 << CRBBIT_CLKMULT_B) :
-				((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
-						STDBIT_CLKMULT))));
+			|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
+			  (MULT_X1 << CRBBIT_CLKMULT_B) :
+			  ((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
+							STDBIT_CLKMULT))));
 	}
 
 	/*  Force positive index polarity if IndxSrc is software-driven only, */
 	/*  otherwise pass it through. */
 	if (~setup & STDMSK_INDXSRC)
 		crb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -
-				CRBBIT_INDXPOL_B));
+						     CRBBIT_INDXPOL_B));
 
 	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
 	/*  enable mask to indicate the counter interrupt is disabled. */
@@ -2988,25 +3052,27 @@ static void SetMode_B(struct comedi_devi
 	/*  While retaining CounterA and LatchSrc configurations, program the */
 	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA,
-		(uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
+		    (uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
 	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
 /*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
-static void SetEnable_A(struct comedi_device *dev, struct enc_private *k, uint16_t enab)
+static void SetEnable_A(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab)
 {
 	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
-		(uint16_t) (enab << CRBBIT_CLKENAB_A));
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),
+		    (uint16_t) (enab << CRBBIT_CLKENAB_A));
 }
 
-static void SetEnable_B(struct comedi_device *dev, struct enc_private *k, uint16_t enab)
+static void SetEnable_B(struct comedi_device *dev, struct enc_private *k,
+			uint16_t enab)
 {
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
-		(uint16_t) (enab << CRBBIT_CLKENAB_B));
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
+		    (uint16_t) (enab << CRBBIT_CLKENAB_B));
 }
 
 static uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k)
@@ -3024,12 +3090,13 @@ static uint16_t GetEnable_B(struct comed
  * latches B.
  */
 
-static void SetLatchSource(struct comedi_device *dev, struct enc_private *k, uint16_t value)
+static void SetLatchSource(struct comedi_device *dev, struct enc_private *k,
+			   uint16_t value)
 {
 	DEBUG("SetLatchSource: SetLatchSource enter 3550 \n");
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
-		(uint16_t) (value << CRBBIT_LATCHSRC));
+		    (uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),
+		    (uint16_t) (value << CRBBIT_LATCHSRC));
 
 	DEBUG("SetLatchSource: SetLatchSource exit \n");
 }
@@ -3047,17 +3114,19 @@ static void SetLatchSource(struct comedi
  * 2=OverflowA (B counters only), 3=disabled.
  */
 
-static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k, uint16_t Trig)
+static void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
-		(uint16_t) (Trig << CRABIT_LOADSRC_A));
+		    (uint16_t) (Trig << CRABIT_LOADSRC_A));
 }
 
-static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k, uint16_t Trig)
+static void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,
+			  uint16_t Trig)
 {
 	DEBIreplace(dev, k->MyCRB,
-		(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
-		(uint16_t) (Trig << CRBBIT_LOADSRC_B));
+		    (uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
+		    (uint16_t) (Trig << CRBBIT_LOADSRC_B));
 }
 
 static uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k)
@@ -3076,24 +3145,24 @@ static uint16_t GetLoadTrig_B(struct com
  */
 
 static void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,
-	uint16_t IntSource)
+			uint16_t IntSource)
 {
 	/*  Reset any pending counter overflow or index captures. */
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
-		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
+		    CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
 	/*  Program counter interrupt source. */
 	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
-		(uint16_t) (IntSource << CRABIT_INTSRC_A));
+		    (uint16_t) (IntSource << CRABIT_INTSRC_A));
 
 	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
-		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
-		MyEventBits[IntSource];
+	    (devpriv->CounterIntEnabs & ~k->
+	     MyEventBits[3]) | k->MyEventBits[IntSource];
 }
 
 static void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,
-	uint16_t IntSource)
+			uint16_t IntSource)
 {
 	uint16_t crb;
 
@@ -3102,17 +3171,17 @@ static void SetIntSrc_B(struct comedi_de
 
 	/*  Reset any pending counter overflow or index captures. */
 	DEBIwrite(dev, k->MyCRB,
-		(uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
+		  (uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
 	/*  Program counter interrupt source. */
 	DEBIwrite(dev, k->MyCRB,
-		(uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
-				CRBBIT_INTSRC_B)));
+		  (uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
+							  CRBBIT_INTSRC_B)));
 
 	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
-		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
-		MyEventBits[IntSource];
+	    (devpriv->CounterIntEnabs & ~k->
+	     MyEventBits[3]) | k->MyEventBits[IntSource];
 }
 
 static uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k)
@@ -3211,13 +3280,14 @@ static void PulseIndex_B(struct comedi_d
 
 /*  Write value into counter preload register. */
 
-static void Preload(struct comedi_device *dev, struct enc_private *k, uint32_t value)
+static void Preload(struct comedi_device *dev, struct enc_private *k,
+		    uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
 	DEBUG("Preload: preload step 1\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
-		(uint16_t) (value >> 16));
+		  (uint16_t) (value >> 16));
 }
 
 static void CountersInit(struct comedi_device *dev)
@@ -3225,13 +3295,13 @@ static void CountersInit(struct comedi_d
 	int chan;
 	struct enc_private *k;
 	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
-		/*  index. */
-		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
-		(CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
-		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
-		(CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
-		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
-		(CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
+	    /*  index. */
+	    (INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+	    (CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
+	    (CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+	    (CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
+	    (CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+	    (CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
 
 	/*  Disable all counter interrupts and clear any captured counter events. */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -134,17 +134,17 @@
 #define DAC_WDMABUF_OS		ADC_DMABUF_DWORDS
 
 /*  Interrupt enab bit in ISR and IER. */
-#define IRQ_GPIO3		0x00000040  /*  IRQ enable for GPIO3. */
+#define IRQ_GPIO3		0x00000040	/*  IRQ enable for GPIO3. */
 #define IRQ_RPS1                0x10000000
 #define ISR_AFOU		0x00000800
 /* Audio fifo under/overflow  detected. */
 
-#define IRQ_COINT1A             0x0400 /* conter 1A overflow interrupt mask */
-#define IRQ_COINT1B             0x0800 /* conter 1B overflow interrupt mask */
-#define IRQ_COINT2A             0x1000 /* conter 2A overflow interrupt mask */
-#define IRQ_COINT2B             0x2000 /* conter 2B overflow interrupt mask */
-#define IRQ_COINT3A             0x4000 /* conter 3A overflow interrupt mask */
-#define IRQ_COINT3B             0x8000 /* conter 3B overflow interrupt mask */
+#define IRQ_COINT1A             0x0400	/* conter 1A overflow interrupt mask */
+#define IRQ_COINT1B             0x0800	/* conter 1B overflow interrupt mask */
+#define IRQ_COINT2A             0x1000	/* conter 2A overflow interrupt mask */
+#define IRQ_COINT2B             0x2000	/* conter 2B overflow interrupt mask */
+#define IRQ_COINT3A             0x4000	/* conter 3A overflow interrupt mask */
+#define IRQ_COINT3B             0x8000	/* conter 3B overflow interrupt mask */
 
 /*  RPS command codes. */
 #define RPS_CLRSIGNAL		0x00000000	/*  CLEAR SIGNAL */
@@ -438,7 +438,6 @@
 						/*  tri-state. */
 #define EOS		     	0x00000001	/*  End of superframe. */
 
-
 /*  I2C configuration constants. */
 #define I2C_CLKSEL		0x0400
 /* I2C bit rate = PCIclk/480 = 68.75 KHz. */
@@ -729,7 +728,6 @@
 #define STDMSK_CLKMULT		((uint16_t)(3 << STDBIT_CLKMULT))
 #define STDMSK_CLKENAB		((uint16_t)(1 << STDBIT_CLKENAB))
 
-
 /* typedef struct indexCounter */
 /* { */
 /*   unsigned int ao; */
--- a/drivers/staging/comedi/drivers/serial2002.c
+++ b/drivers/staging/comedi/drivers/serial2002.c
@@ -52,7 +52,7 @@ struct serial2002_board {
 
 static const struct serial2002_board serial2002_boards[] = {
 	{
-	.name = "serial2002"}
+	 .name = "serial2002"}
 };
 
 /*
@@ -67,7 +67,6 @@ struct serial2002_range_table_t {
 	struct comedi_krange range;
 };
 
-
 struct serial2002_private {
 
 	int port;		/*  /dev/ttyS<port> */
@@ -82,14 +81,14 @@ struct serial2002_private {
 	struct serial2002_range_table_t in_range[32], out_range[32];
 };
 
-
 /*
  * most drivers define the following macro to make it easy to
  * access the private structure.
  */
 #define devpriv ((struct serial2002_private *)dev->private)
 
-static int serial2002_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int serial2002_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it);
 static int serial2002_detach(struct comedi_device *dev);
 struct comedi_driver driver_serial2002 = {
 	.driver_name = "serial2002",
@@ -101,16 +100,21 @@ struct comedi_driver driver_serial2002 =
 	.num_names = ARRAY_SIZE(serial2002_boards),
 };
 
-static int serial2002_di_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int serial2002_do_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int serial2002_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int serial2002_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int serial2002_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int serial2002_di_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int serial2002_do_winsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int serial2002_ai_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int serial2002_ao_winsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
+static int serial2002_ao_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 struct serial_data {
 	enum { is_invalid, is_digital, is_channel } kind;
@@ -184,28 +188,28 @@ static int tty_read(struct file *f, int 
 
 				mask = f->f_op->poll(f, &table.pt);
 				if (mask & (POLLRDNORM | POLLRDBAND | POLLIN |
-						POLLHUP | POLLERR)) {
+					    POLLHUP | POLLERR)) {
 					break;
 				}
 				do_gettimeofday(&now);
 				elapsed =
-					(1000000 * (now.tv_sec - start.tv_sec) +
-					now.tv_usec - start.tv_usec);
+				    (1000000 * (now.tv_sec - start.tv_sec) +
+				     now.tv_usec - start.tv_usec);
 				if (elapsed > timeout) {
 					break;
 				}
 				set_current_state(TASK_INTERRUPTIBLE);
 				schedule_timeout(((timeout -
-							elapsed) * HZ) / 10000);
+						   elapsed) * HZ) / 10000);
 			}
 			poll_freewait(&table);
 			{
-			  unsigned char ch;
+				unsigned char ch;
 
-			  f->f_pos = 0;
-			  if (f->f_op->read(f, &ch, 1, &f->f_pos) == 1) {
-			    result = ch;
-			  }
+				f->f_pos = 0;
+				if (f->f_op->read(f, &ch, 1, &f->f_pos) == 1) {
+					result = ch;
+				}
 			}
 		} else {
 			/* Device does not support poll, busy wait */
@@ -348,8 +352,7 @@ static struct serial_data serial_read(st
 				}
 			} else {
 				result.value =
-					(result.
-					value << 2) | ((data & 0x60) >> 5);
+				    (result.value << 2) | ((data & 0x60) >> 5);
 				result.kind = is_channel;
 			}
 			result.index = data & 0x1f;
@@ -364,7 +367,7 @@ static void serial_write(struct file *f,
 {
 	if (data.kind == is_digital) {
 		unsigned char ch =
-			((data.value << 5) & 0x20) | (data.index & 0x1f);
+		    ((data.value << 5) & 0x20) | (data.index & 0x1f);
 		tty_write(f, &ch, 1);
 	} else {
 		unsigned char ch[6];
@@ -401,7 +404,7 @@ static void serial_2002_open(struct come
 	devpriv->tty = filp_open(port, 0, O_RDWR);
 	if (IS_ERR(devpriv->tty)) {
 		printk("serial_2002: file open error = %ld\n",
-			PTR_ERR(devpriv->tty));
+		       PTR_ERR(devpriv->tty));
 	} else {
 		struct config_t {
 
@@ -443,7 +446,7 @@ static void serial_2002_open(struct come
 
 			data = serial_read(devpriv->tty, 1000);
 			if (data.kind != is_channel || data.index != 31
-				|| !(data.value & 0xe0)) {
+			    || !(data.value & 0xe0)) {
 				break;
 			} else {
 				int command, channel, kind;
@@ -479,77 +482,92 @@ static void serial_2002_open(struct come
 					cur_config[channel].kind = kind;
 					switch (command) {
 					case 0:{
-							cur_config[channel].
-								bits =
-								(data.
-								value >> 10) &
-								0x3f;
+							cur_config[channel].bits
+							    =
+							    (data.value >> 10) &
+							    0x3f;
 						}
 						break;
 					case 1:{
 							int unit, sign, min;
-							unit = (data.
-								value >> 10) &
-								0x7;
-							sign = (data.
-								value >> 13) &
-								0x1;
-							min = (data.
-								value >> 14) &
-								0xfffff;
+							unit =
+							    (data.value >> 10) &
+							    0x7;
+							sign =
+							    (data.value >> 13) &
+							    0x1;
+							min =
+							    (data.value >> 14) &
+							    0xfffff;
 
 							switch (unit) {
 							case 0:{
-									min = min * 1000000;
+									min =
+									    min
+									    *
+									    1000000;
 								}
 								break;
 							case 1:{
-									min = min * 1000;
+									min =
+									    min
+									    *
+									    1000;
 								}
 								break;
 							case 2:{
-									min = min * 1;
+									min =
+									    min
+									    * 1;
 								}
 								break;
 							}
 							if (sign) {
 								min = -min;
 							}
-							cur_config[channel].
-								min = min;
+							cur_config[channel].min
+							    = min;
 						}
 						break;
 					case 2:{
 							int unit, sign, max;
-							unit = (data.
-								value >> 10) &
-								0x7;
-							sign = (data.
-								value >> 13) &
-								0x1;
-							max = (data.
-								value >> 14) &
-								0xfffff;
+							unit =
+							    (data.value >> 10) &
+							    0x7;
+							sign =
+							    (data.value >> 13) &
+							    0x1;
+							max =
+							    (data.value >> 14) &
+							    0xfffff;
 
 							switch (unit) {
 							case 0:{
-									max = max * 1000000;
+									max =
+									    max
+									    *
+									    1000000;
 								}
 								break;
 							case 1:{
-									max = max * 1000;
+									max =
+									    max
+									    *
+									    1000;
 								}
 								break;
 							case 2:{
-									max = max * 1;
+									max =
+									    max
+									    * 1;
 								}
 								break;
 							}
 							if (sign) {
 								max = -max;
 							}
-							cur_config[channel].
-								max = max;
+							cur_config[channel].max
+							    = max;
 						}
 						break;
 					}
@@ -604,7 +622,8 @@ static void serial_2002_open(struct come
 			}
 			if (c) {
 				struct comedi_subdevice *s;
-				const struct comedi_lrange **range_table_list = NULL;
+				const struct comedi_lrange **range_table_list =
+				    NULL;
 				unsigned int *maxdata_list;
 				int j, chan;
 
@@ -620,17 +639,18 @@ static void serial_2002_open(struct come
 					kfree(s->maxdata_list);
 				}
 				s->maxdata_list = maxdata_list =
-					kmalloc(sizeof(unsigned int) * s->n_chan,
-					GFP_KERNEL);
+				    kmalloc(sizeof(unsigned int) * s->n_chan,
+					    GFP_KERNEL);
 				if (s->range_table_list) {
 					kfree(s->range_table_list);
 				}
 				if (range) {
 					s->range_table = 0;
 					s->range_table_list = range_table_list =
-						kmalloc(sizeof
-						(struct serial2002_range_table_t) *
-						s->n_chan, GFP_KERNEL);
+					    kmalloc(sizeof
+						    (struct
+						     serial2002_range_table_t) *
+						    s->n_chan, GFP_KERNEL);
 				}
 				for (chan = 0, j = 0; j < 32; j++) {
 					if (c[j].kind == kind) {
@@ -640,17 +660,17 @@ static void serial_2002_open(struct come
 						if (range) {
 							range[j].length = 1;
 							range[j].range.min =
-								c[j].min;
+							    c[j].min;
 							range[j].range.max =
-								c[j].max;
+							    c[j].max;
 							range_table_list[chan] =
-								(const struct
-								comedi_lrange *)
-								&range[j];
+							    (const struct
+							     comedi_lrange *)
+							    &range[j];
 						}
 						maxdata_list[chan] =
-							((long long)1 << c[j].
-							bits) - 1;
+						    ((long long)1 << c[j].bits)
+						    - 1;
 						chan++;
 					}
 				}
@@ -666,8 +686,9 @@ static void serial_2002_close(struct com
 	}
 }
 
-static int serial2002_di_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int serial2002_di_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan;
@@ -688,8 +709,9 @@ static int serial2002_di_rinsn(struct co
 	return n;
 }
 
-static int serial2002_do_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int serial2002_do_winsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan;
@@ -706,8 +728,9 @@ static int serial2002_do_winsn(struct co
 	return n;
 }
 
-static int serial2002_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int serial2002_ai_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan;
@@ -728,8 +751,9 @@ static int serial2002_ai_rinsn(struct co
 	return n;
 }
 
-static int serial2002_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int serial2002_ao_winsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan;
@@ -747,8 +771,9 @@ static int serial2002_ao_winsn(struct co
 	return n;
 }
 
-static int serial2002_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int serial2002_ao_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan = CR_CHAN(insn->chanspec);
@@ -760,8 +785,9 @@ static int serial2002_ao_rinsn(struct co
 	return n;
 }
 
-static int serial2002_ei_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int serial2002_ei_rinsn(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	int chan;
@@ -782,7 +808,8 @@ static int serial2002_ei_rinsn(struct co
 	return n;
 }
 
-static int serial2002_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int serial2002_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 
--- a/drivers/staging/comedi/drivers/skel.c
+++ b/drivers/staging/comedi/drivers/skel.c
@@ -97,17 +97,17 @@ struct skel_board {
 
 static const struct skel_board skel_boards[] = {
 	{
-	.name = "skel-100",
-	.ai_chans = 16,
-	.ai_bits = 12,
-	.have_dio = 1,
-		},
+	 .name = "skel-100",
+	 .ai_chans = 16,
+	 .ai_bits = 12,
+	 .have_dio = 1,
+	 },
 	{
-	.name = "skel-200",
-	.ai_chans = 8,
-	.ai_bits = 16,
-	.have_dio = 0,
-		},
+	 .name = "skel-200",
+	 .ai_chans = 8,
+	 .ai_bits = 16,
+	 .have_dio = 0,
+	 },
 };
 
 /* This is used by modprobe to translate PCI IDs to drivers.  Should
@@ -116,9 +116,10 @@ static const struct skel_board skel_boar
  * upstream. */
 #define PCI_VENDOR_ID_SKEL 0xdafe
 static DEFINE_PCI_DEVICE_TABLE(skel_pci_table) = {
-	{PCI_VENDOR_ID_SKEL, 0x0100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_SKEL, 0x0200, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_SKEL, 0x0100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_SKEL, 0x0200, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, skel_pci_table);
@@ -185,17 +186,19 @@ static struct comedi_driver driver_skel 
 };
 
 static int skel_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int skel_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int skel_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int skel_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int skel_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int skel_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			 struct comedi_insn *insn, unsigned int *data);
+static int skel_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int skel_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int skel_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd);
 static int skel_ns_to_timer(unsigned int *ns, int round);
 
 /*
@@ -304,7 +307,7 @@ static int skel_detach(struct comedi_dev
  * mode.
  */
 static int skel_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	unsigned int d;
@@ -351,8 +354,8 @@ static int skel_ai_rinsn(struct comedi_d
 	return n;
 }
 
-static int skel_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int skel_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -398,7 +401,7 @@ static int skel_ai_cmdtest(struct comedi
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
@@ -478,21 +481,21 @@ static int skel_ai_cmdtest(struct comedi
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		skel_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		skel_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->scan_end_arg) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -521,7 +524,7 @@ static int skel_ns_to_timer(unsigned int
 }
 
 static int skel_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -542,7 +545,7 @@ static int skel_ao_winsn(struct comedi_d
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int skel_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -558,8 +561,9 @@ static int skel_ao_rinsn(struct comedi_d
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int skel_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int skel_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -583,8 +587,9 @@ static int skel_dio_insn_bits(struct com
 	return 2;
 }
 
-static int skel_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int skel_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -601,8 +606,7 @@ static int skel_dio_insn_config(struct c
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
--- a/drivers/staging/comedi/drivers/ssv_dnp.c
+++ b/drivers/staging/comedi/drivers/ssv_dnp.c
@@ -61,11 +61,11 @@ struct dnp_board {
 
 static const struct dnp_board dnp_boards[] = {	/* we only support one DNP 'board'   */
 	{			/* variant at the moment             */
-	.name = "dnp-1486",
-	.ai_chans = 16,
-	.ai_bits = 12,
-	.have_dio = 1,
-		},
+	 .name = "dnp-1486",
+	 .ai_chans = 16,
+	 .ai_bits = 12,
+	 .have_dio = 1,
+	 },
 };
 
 /* Useful for shorthand access to the particular board structure ----------- */
@@ -76,7 +76,6 @@ struct dnp_private_data {
 
 };
 
-
 /* Shorthand macro for faster access to the private data ------------------- */
 #define devpriv ((dnp_private *)dev->private)
 
@@ -98,17 +97,19 @@ static struct comedi_driver driver_dnp =
 	.detach = dnp_detach,
 	.board_name = &dnp_boards[0].name,
 	/* only necessary for non-PnP devs   */
-	.offset = sizeof(struct dnp_board),/* like ISA-PnP, PCI or PCMCIA.      */
+	.offset = sizeof(struct dnp_board),	/* like ISA-PnP, PCI or PCMCIA.      */
 	.num_names = ARRAY_SIZE(dnp_boards),
 };
 
 COMEDI_INITCLEANUP(driver_dnp);
 
 static int dnp_dio_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
 
 static int dnp_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data);
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 
 /* ------------------------------------------------------------------------- */
 /* Attach is called by comedi core to configure the driver for a particular  */
@@ -202,7 +203,8 @@ static int dnp_detach(struct comedi_devi
 /* ------------------------------------------------------------------------- */
 
 static int dnp_dio_insn_bits(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 
 	if (insn->n != 2)
@@ -219,18 +221,18 @@ static int dnp_dio_insn_bits(struct come
 
 		outb(PADR, CSCIR);
 		outb((inb(CSCDR)
-				& ~(u8) (data[0] & 0x0000FF))
-			| (u8) (data[1] & 0x0000FF), CSCDR);
+		      & ~(u8) (data[0] & 0x0000FF))
+		     | (u8) (data[1] & 0x0000FF), CSCDR);
 
 		outb(PBDR, CSCIR);
 		outb((inb(CSCDR)
-				& ~(u8) ((data[0] & 0x00FF00) >> 8))
-			| (u8) ((data[1] & 0x00FF00) >> 8), CSCDR);
+		      & ~(u8) ((data[0] & 0x00FF00) >> 8))
+		     | (u8) ((data[1] & 0x00FF00) >> 8), CSCDR);
 
 		outb(PCDR, CSCIR);
 		outb((inb(CSCDR)
-				& ~(u8) ((data[0] & 0x0F0000) >> 12))
-			| (u8) ((data[1] & 0x0F0000) >> 12), CSCDR);
+		      & ~(u8) ((data[0] & 0x0F0000) >> 12))
+		     | (u8) ((data[1] & 0x0F0000) >> 12), CSCDR);
 	}
 
 	/* on return, data[1] contains the value of the digital input lines.       */
@@ -252,7 +254,8 @@ static int dnp_dio_insn_bits(struct come
 /* ------------------------------------------------------------------------- */
 
 static int dnp_dio_insn_config(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 
 	u8 register_buffer;
@@ -265,8 +268,7 @@ static int dnp_dio_insn_config(struct co
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(inb(CSCDR) & (1 << chan)) ? COMEDI_OUTPUT :
-			COMEDI_INPUT;
+		    (inb(CSCDR) & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	default:
--- a/drivers/staging/comedi/drivers/unioxx5.c
+++ b/drivers/staging/comedi/drivers/unioxx5.c
@@ -80,25 +80,29 @@ struct unioxx5_subd_priv {
 	unsigned char usp_prev_cn_val[3];	/* previous channel value */
 };
 
-static int unioxx5_attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static int unioxx5_subdev_write(struct comedi_device *dev, struct comedi_subdevice *subdev,
-	struct comedi_insn *insn, unsigned int *data);
-static int unioxx5_subdev_read(struct comedi_device *dev, struct comedi_subdevice *subdev,
-	struct comedi_insn *insn, unsigned int *data);
-static int unioxx5_insn_config(struct comedi_device *dev, struct comedi_subdevice *subdev,
-	struct comedi_insn *insn, unsigned int *data);
+static int unioxx5_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
+static int unioxx5_subdev_write(struct comedi_device *dev,
+				struct comedi_subdevice *subdev,
+				struct comedi_insn *insn, unsigned int *data);
+static int unioxx5_subdev_read(struct comedi_device *dev,
+			       struct comedi_subdevice *subdev,
+			       struct comedi_insn *insn, unsigned int *data);
+static int unioxx5_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *subdev,
+			       struct comedi_insn *insn, unsigned int *data);
 static int unioxx5_detach(struct comedi_device *dev);
-static int __unioxx5_subdev_init(struct comedi_subdevice *subdev, int subdev_iobase,
-	int minor);
-static int __unioxx5_digital_write(struct unioxx5_subd_priv *usp, unsigned int *data,
-	int channel, int minor);
-static int __unioxx5_digital_read(struct unioxx5_subd_priv *usp, unsigned int *data,
-	int channel, int minor);
+static int __unioxx5_subdev_init(struct comedi_subdevice *subdev,
+				 int subdev_iobase, int minor);
+static int __unioxx5_digital_write(struct unioxx5_subd_priv *usp,
+				   unsigned int *data, int channel, int minor);
+static int __unioxx5_digital_read(struct unioxx5_subd_priv *usp,
+				  unsigned int *data, int channel, int minor);
 /* static void __unioxx5_digital_config(struct unioxx5_subd_priv* usp, int mode); */
-static int __unioxx5_analog_write(struct unioxx5_subd_priv *usp, unsigned int *data,
-	int channel, int minor);
-static int __unioxx5_analog_read(struct unioxx5_subd_priv *usp, unsigned int *data,
-	int channel, int minor);
+static int __unioxx5_analog_write(struct unioxx5_subd_priv *usp,
+				  unsigned int *data, int channel, int minor);
+static int __unioxx5_analog_read(struct unioxx5_subd_priv *usp,
+				 unsigned int *data, int channel, int minor);
 static int __unioxx5_define_chan_offset(int chan_num);
 static void __unioxx5_analog_config(struct unioxx5_subd_priv *usp, int channel);
 
@@ -111,7 +115,8 @@ static struct comedi_driver unioxx5_driv
 
 COMEDI_INITCLEANUP(unioxx5_driver);
 
-static int unioxx5_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int unioxx5_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	int iobase, i, n_subd;
 	int id, num, ba;
@@ -136,7 +141,7 @@ static int unioxx5_attach(struct comedi_
 	/* unioxx5 can has from two to four subdevices */
 	if (n_subd < 2) {
 		printk(KERN_ERR
-			"your card must has at least 2 'g01' subdevices\n");
+		       "your card must has at least 2 'g01' subdevices\n");
 		return -1;
 	}
 
@@ -148,7 +153,7 @@ static int unioxx5_attach(struct comedi_
 	/* initializing each of for same subdevices */
 	for (i = 0; i < n_subd; i++, iobase += UNIOXX5_SUBDEV_ODDS) {
 		if (__unioxx5_subdev_init(&dev->subdevices[i], iobase,
-				dev->minor) < 0)
+					  dev->minor) < 0)
 			return -1;
 	}
 
@@ -156,8 +161,9 @@ static int unioxx5_attach(struct comedi_
 	return 0;
 }
 
-static int unioxx5_subdev_read(struct comedi_device *dev, struct comedi_subdevice *subdev,
-	struct comedi_insn *insn, unsigned int *data)
+static int unioxx5_subdev_read(struct comedi_device *dev,
+			       struct comedi_subdevice *subdev,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	struct unioxx5_subd_priv *usp = subdev->private;
 	int channel, type;
@@ -176,8 +182,9 @@ static int unioxx5_subdev_read(struct co
 	return 1;
 }
 
-static int unioxx5_subdev_write(struct comedi_device *dev, struct comedi_subdevice *subdev,
-	struct comedi_insn *insn, unsigned int *data)
+static int unioxx5_subdev_write(struct comedi_device *dev,
+				struct comedi_subdevice *subdev,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	struct unioxx5_subd_priv *usp = subdev->private;
 	int channel, type;
@@ -197,8 +204,9 @@ static int unioxx5_subdev_write(struct c
 }
 
 /* for digital modules only */
-static int unioxx5_insn_config(struct comedi_device *dev, struct comedi_subdevice *subdev,
-	struct comedi_insn *insn, unsigned int *data)
+static int unioxx5_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *subdev,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int channel_offset, flags, channel = CR_CHAN(insn->chanspec), type;
 	struct unioxx5_subd_priv *usp = subdev->private;
@@ -208,16 +216,16 @@ static int unioxx5_insn_config(struct co
 
 	if (type != MODULE_DIGITAL) {
 		printk(KERN_ERR
-			"comedi%d: channel configuration accessible only for digital modules\n",
-			dev->minor);
+		       "comedi%d: channel configuration accessible only for digital modules\n",
+		       dev->minor);
 		return -1;
 	}
 
 	channel_offset = __unioxx5_define_chan_offset(channel);
 	if (channel_offset < 0) {
 		printk(KERN_ERR
-			"comedi%d: undefined channel %d. channel range is 0 .. 23\n",
-			dev->minor, channel);
+		       "comedi%d: undefined channel %d. channel range is 0 .. 23\n",
+		       dev->minor, channel);
 		return -1;
 	}
 
@@ -265,8 +273,8 @@ static int unioxx5_detach(struct comedi_
 }
 
 /* initializing subdevice with given address */
-static int __unioxx5_subdev_init(struct comedi_subdevice *subdev, int subdev_iobase,
-	int minor)
+static int __unioxx5_subdev_init(struct comedi_subdevice *subdev,
+				 int subdev_iobase, int minor)
 {
 	struct unioxx5_subd_priv *usp;
 	int i, to, ndef_flag = 0;
@@ -276,7 +284,7 @@ static int __unioxx5_subdev_init(struct 
 		return -EIO;
 	}
 
-	usp = (struct unioxx5_subd_priv *) kzalloc(sizeof(*usp), GFP_KERNEL);
+	usp = (struct unioxx5_subd_priv *)kzalloc(sizeof(*usp), GFP_KERNEL);
 
 	if (usp == NULL) {
 		printk(KERN_ERR "comedi%d: erorr! --> out of memory!\n", minor);
@@ -332,8 +340,8 @@ static int __unioxx5_subdev_init(struct 
 	return 0;
 }
 
-static int __unioxx5_digital_write(struct unioxx5_subd_priv *usp, unsigned int *data,
-	int channel, int minor)
+static int __unioxx5_digital_write(struct unioxx5_subd_priv *usp,
+				   unsigned int *data, int channel, int minor)
 {
 	int channel_offset, val;
 	int mask = 1 << (channel & 0x07);
@@ -341,8 +349,8 @@ static int __unioxx5_digital_write(struc
 	channel_offset = __unioxx5_define_chan_offset(channel);
 	if (channel_offset < 0) {
 		printk(KERN_ERR
-			"comedi%d: undefined channel %d. channel range is 0 .. 23\n",
-			minor, channel);
+		       "comedi%d: undefined channel %d. channel range is 0 .. 23\n",
+		       minor, channel);
 		return 0;
 	}
 
@@ -360,16 +368,16 @@ static int __unioxx5_digital_write(struc
 }
 
 /* function for digital reading */
-static int __unioxx5_digital_read(struct unioxx5_subd_priv *usp, unsigned int *data,
-	int channel, int minor)
+static int __unioxx5_digital_read(struct unioxx5_subd_priv *usp,
+				  unsigned int *data, int channel, int minor)
 {
 	int channel_offset, mask = 1 << (channel & 0x07);
 
 	channel_offset = __unioxx5_define_chan_offset(channel);
 	if (channel_offset < 0) {
 		printk(KERN_ERR
-			"comedi%d: undefined channel %d. channel range is 0 .. 23\n",
-			minor, channel);
+		       "comedi%d: undefined channel %d. channel range is 0 .. 23\n",
+		       minor, channel);
 		return 0;
 	}
 
@@ -400,8 +408,8 @@ static void __unioxx5_digital_config(str
 }
 #endif
 
-static int __unioxx5_analog_write(struct unioxx5_subd_priv *usp, unsigned int *data,
-	int channel, int minor)
+static int __unioxx5_analog_write(struct unioxx5_subd_priv *usp,
+				  unsigned int *data, int channel, int minor)
 {
 	int module, i;
 
@@ -411,8 +419,8 @@ static int __unioxx5_analog_write(struct
 	/* defining if given module can work on output */
 	if (!(usp->usp_module_type[module] & MODULE_OUTPUT_MASK)) {
 		printk(KERN_ERR
-			"comedi%d: module in position %d with id 0x%0x is for input only!\n",
-			minor, module, usp->usp_module_type[module]);
+		       "comedi%d: module in position %d with id 0x%0x is for input only!\n",
+		       minor, module, usp->usp_module_type[module]);
 		return 0;
 	}
 
@@ -435,8 +443,8 @@ static int __unioxx5_analog_write(struct
 	return 1;
 }
 
-static int __unioxx5_analog_read(struct unioxx5_subd_priv *usp, unsigned int *data,
-	int channel, int minor)
+static int __unioxx5_analog_read(struct unioxx5_subd_priv *usp,
+				 unsigned int *data, int channel, int minor)
 {
 	int module_no, read_ch;
 	char control;
@@ -447,8 +455,8 @@ static int __unioxx5_analog_read(struct 
 	/* defining if given module can work on input */
 	if (usp->usp_module_type[module_no] & MODULE_OUTPUT_MASK) {
 		printk(KERN_ERR
-			"comedi%d: module in position %d with id 0x%02x is for output only",
-			minor, module_no, usp->usp_module_type[module_no]);
+		       "comedi%d: module in position %d with id 0x%02x is for output only",
+		       minor, module_no, usp->usp_module_type[module_no]);
 		return 0;
 	}
 
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -215,17 +215,23 @@ sampling rate. If you sample two channel
 /**************************************************/
 /* comedi constants */
 static const struct comedi_lrange range_usbdux_ai_range = { 4, {
-			BIP_RANGE(4.096),
-			BIP_RANGE(4.096 / 2),
-			UNI_RANGE(4.096),
-			UNI_RANGE(4.096 / 2)
-	}
+								BIP_RANGE
+								(4.096),
+								BIP_RANGE(4.096
+									  / 2),
+								UNI_RANGE
+								(4.096),
+								UNI_RANGE(4.096
+									  / 2)
+								}
 };
 
 static const struct comedi_lrange range_usbdux_ao_range = { 2, {
-			BIP_RANGE(4.096),
-			UNI_RANGE(4.096),
-	}
+								BIP_RANGE
+								(4.096),
+								UNI_RANGE
+								(4.096),
+								}
 };
 
 /*
@@ -363,7 +369,8 @@ static int usbdux_ai_stop(struct usbduxs
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbdux_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbdux_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub;
 	int res = 0;
@@ -407,7 +414,7 @@ static void usbduxsub_ai_IsocIrq(struct 
 	case 0:
 		/* copy the result in the transfer buffer */
 		memcpy(this_usbduxsub->inBuffer,
-			urb->transfer_buffer, SIZEINBUF);
+		       urb->transfer_buffer, SIZEINBUF);
 		break;
 	case -EILSEQ:
 		/* error in the ISOchronous data */
@@ -510,13 +517,12 @@ static void usbduxsub_ai_IsocIrq(struct 
 		/* transfer data */
 		if (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {
 			err = comedi_buf_put
-				(s->async,
-				 le16_to_cpu(this_usbduxsub->
-					     inBuffer[i]) ^ 0x800);
+			    (s->async,
+			     le16_to_cpu(this_usbduxsub->inBuffer[i]) ^ 0x800);
 		} else {
 			err = comedi_buf_put
-				(s->async,
-				 le16_to_cpu(this_usbduxsub->inBuffer[i]));
+			    (s->async,
+			     le16_to_cpu(this_usbduxsub->inBuffer[i]));
 		}
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
@@ -566,7 +572,8 @@ static int usbdux_ao_stop(struct usbduxs
 }
 
 /* force unlink, is called by comedi */
-static int usbdux_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbdux_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
@@ -659,7 +666,7 @@ static void usbduxsub_ao_IsocIrq(struct 
 		}
 		/* transmit data to the USB bus */
 		((uint8_t *) (urb->transfer_buffer))[0] =
-			s->async->cmd.chanlist_len;
+		    s->async->cmd.chanlist_len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
 			short temp;
 			if (i >= NUMOUTCHANNELS)
@@ -667,7 +674,7 @@ static void usbduxsub_ao_IsocIrq(struct 
 
 			/* pointer to the DA */
 			datap =
-			       (&(((int8_t *)urb->transfer_buffer)[i * 3 + 1]));
+			    (&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));
 			/* get the data from comedi */
 			ret = comedi_buf_get(s->async, &temp);
 			datap[0] = temp;
@@ -783,32 +790,30 @@ static int usbduxsub_stop(struct usbduxs
 }
 
 static int usbduxsub_upload(struct usbduxsub *usbduxsub,
-			    uint8_t *local_transfer_buffer,
+			    uint8_t * local_transfer_buffer,
 			    unsigned int startAddr, unsigned int len)
 {
 	int errcode;
 
 	errcode = usb_control_msg(usbduxsub->usbdev,
-			usb_sndctrlpipe(usbduxsub->usbdev, 0),
-			/* brequest, firmware */
-			USBDUXSUB_FIRMWARE,
-			/* bmRequestType */
-			VENDOR_DIR_OUT,
-			/* value */
-			startAddr,
-			/* index */
-			0x0000,
-			/* our local safe buffer */
-			local_transfer_buffer,
-			/* length */
-			len,
-			/* timeout */
-			EZTIMEOUT);
-	dev_dbg(&usbduxsub->interface->dev,
-		"comedi_: result=%d\n", errcode);
+				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
+				  /* brequest, firmware */
+				  USBDUXSUB_FIRMWARE,
+				  /* bmRequestType */
+				  VENDOR_DIR_OUT,
+				  /* value */
+				  startAddr,
+				  /* index */
+				  0x0000,
+				  /* our local safe buffer */
+				  local_transfer_buffer,
+				  /* length */
+				  len,
+				  /* timeout */
+				  EZTIMEOUT);
+	dev_dbg(&usbduxsub->interface->dev, "comedi_: result=%d\n", errcode);
 	if (errcode < 0) {
-		dev_err(&usbduxsub->interface->dev,
-		"comedi_: upload failed\n");
+		dev_err(&usbduxsub->interface->dev, "comedi_: upload failed\n");
 		return errcode;
 	}
 	return 0;
@@ -817,8 +822,7 @@ static int usbduxsub_upload(struct usbdu
 #define FIRMWARE_MAX_LEN 0x2000
 
 static int firmwareUpload(struct usbduxsub *usbduxsub,
-			  const u8 *firmwareBinary,
-			  int sizeFirmware)
+			  const u8 * firmwareBinary, int sizeFirmware)
 {
 	int ret;
 	uint8_t *fwBuf;
@@ -826,7 +830,7 @@ static int firmwareUpload(struct usbduxs
 	if (!firmwareBinary)
 		return 0;
 
-	if (sizeFirmware>FIRMWARE_MAX_LEN) {
+	if (sizeFirmware > FIRMWARE_MAX_LEN) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: usbdux firmware binary it too large for FX2.\n");
 		return -ENOMEM;
@@ -839,7 +843,7 @@ static int firmwareUpload(struct usbduxs
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
-	memcpy(fwBuf,firmwareBinary,sizeFirmware);
+	memcpy(fwBuf, firmwareBinary, sizeFirmware);
 
 	ret = usbduxsub_stop(usbduxsub);
 	if (ret < 0) {
@@ -925,8 +929,8 @@ static int usbduxsub_submit_OutURBs(stru
 	return 0;
 }
 
-static int usbdux_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd)
+static int usbdux_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0, tmp, i;
 	unsigned int tmpTimer;
@@ -978,8 +982,8 @@ static int usbdux_ai_cmdtest(struct come
 	 * note that mutual compatiblity is not an issue here
 	 */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_TIMER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1021,8 +1025,8 @@ static int usbdux_ai_cmdtest(struct come
 			/* now calc the real sampling rate with all the
 			 * rounding errors */
 			tmpTimer =
-				((unsigned int)(cmd->scan_begin_arg / 125000)) *
-				125000;
+			    ((unsigned int)(cmd->scan_begin_arg / 125000)) *
+			    125000;
 			if (cmd->scan_begin_arg != tmpTimer) {
 				cmd->scan_begin_arg = tmpTimer;
 				err++;
@@ -1038,7 +1042,7 @@ static int usbdux_ai_cmdtest(struct come
 			 * calc the real sampling rate with the rounding errors
 			 */
 			tmpTimer = ((unsigned int)(cmd->scan_begin_arg /
-					1000000)) * 1000000;
+						   1000000)) * 1000000;
 			if (cmd->scan_begin_arg != tmpTimer) {
 				cmd->scan_begin_arg = tmpTimer;
 				err++;
@@ -1097,7 +1101,7 @@ static int send_dux_commands(struct usbd
 	this_usbduxsub->dux_commands[0] = cmd_type;
 #ifdef NOISY_DUX_DEBUGBUG
 	printk(KERN_DEBUG "comedi%d: usbdux: dux_commands: ",
-		this_usbduxsub->comedidev->minor);
+	       this_usbduxsub->comedidev->minor);
 	for (result = 0; result < SIZEOFDUXBUFFER; result++)
 		printk(" %02x", this_usbduxsub->dux_commands[result]);
 	printk("\n");
@@ -1145,8 +1149,8 @@ static int receive_dux_commands(struct u
 	return -EFAULT;
 }
 
-static int usbdux_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			     unsigned int trignum)
+static int usbdux_ai_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1231,7 +1235,7 @@ static int usbdux_ai_cmd(struct comedi_d
 			break;
 		}
 		this_usbduxsub->dux_commands[i + 2] =
-			create_adc_command(chan, range);
+		    create_adc_command(chan, range);
 	}
 
 	dev_dbg(&this_usbduxsub->interface->dev,
@@ -1254,10 +1258,11 @@ static int usbdux_ai_cmd(struct comedi_d
 		/* find a power of 2 for the interval */
 		while ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {
 			this_usbduxsub->ai_interval =
-				(this_usbduxsub->ai_interval) * 2;
+			    (this_usbduxsub->ai_interval) * 2;
 		}
 		this_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *
-			(this_usbduxsub->ai_interval));
+								  (this_usbduxsub->
+								   ai_interval));
 	} else {
 		/* interval always 1ms */
 		this_usbduxsub->ai_interval = 1;
@@ -1305,7 +1310,8 @@ static int usbdux_ai_cmd(struct comedi_d
 }
 
 /* Mode 0 is used to get a single conversion on demand */
-static int usbdux_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -1366,7 +1372,8 @@ static int usbdux_ai_insn_read(struct co
 /************************************/
 /* analog out */
 
-static int usbdux_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -1388,7 +1395,8 @@ static int usbdux_ao_insn_read(struct co
 	return i;
 }
 
-static int usbdux_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	int i, err;
@@ -1423,7 +1431,7 @@ static int usbdux_ao_insn_write(struct c
 		this_usbduxsub->dux_commands[1] = 1;
 		/* one 16 bit value */
 		*((int16_t *) (this_usbduxsub->dux_commands + 2)) =
-			cpu_to_le16(data[i]);
+		    cpu_to_le16(data[i]);
 		this_usbduxsub->outBuffer[chan] = data[i];
 		/* channel number */
 		this_usbduxsub->dux_commands[4] = (chan << 6);
@@ -1438,8 +1446,8 @@ static int usbdux_ao_insn_write(struct c
 	return i;
 }
 
-static int usbdux_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			     unsigned int trignum)
+static int usbdux_ao_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1479,8 +1487,8 @@ static int usbdux_ao_inttrig(struct come
 	return 1;
 }
 
-static int usbdux_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd)
+static int usbdux_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0, tmp;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1552,8 +1560,8 @@ static int usbdux_ao_cmdtest(struct come
 	 * note that mutual compatiblity is not an issue here
 	 */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_TIMER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1690,7 +1698,7 @@ static int usbdux_ao_cmd(struct comedi_d
 		/* high speed also scans everything at once */
 		if (0) {	/* (this_usbduxsub->high_speed) */
 			this_usbduxsub->ao_sample_count =
-				(cmd->stop_arg) * (cmd->scan_end_arg);
+			    (cmd->stop_arg) * (cmd->scan_end_arg);
 		} else {
 			/* there's no scan as the scan has been */
 			/* perf inside the FX2 */
@@ -1726,7 +1734,8 @@ static int usbdux_ao_cmd(struct comedi_d
 	return 0;
 }
 
-static int usbdux_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
@@ -1745,8 +1754,7 @@ static int usbdux_dio_insn_config(struct
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		break;
 	default:
 		return -EINVAL;
@@ -1757,7 +1765,8 @@ static int usbdux_dio_insn_config(struct
 	return insn->n;
 }
 
-static int usbdux_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
 
@@ -1767,7 +1776,6 @@ static int usbdux_dio_insn_bits(struct c
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-
 	if (insn->n != 2)
 		return -EINVAL;
 
@@ -1804,7 +1812,8 @@ static int usbdux_dio_insn_bits(struct c
 }
 
 /* reads the 4 counters, only two are used just now */
-static int usbdux_counter_read(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_counter_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1838,7 +1847,8 @@ static int usbdux_counter_read(struct co
 	return 1;
 }
 
-static int usbdux_counter_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_counter_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1868,7 +1878,8 @@ static int usbdux_counter_write(struct c
 	return 1;
 }
 
-static int usbdux_counter_config(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_counter_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
 	/* nothing to do so far */
@@ -1905,14 +1916,14 @@ static int usbdux_pwm_stop(struct usbdux
 	if (do_unlink)
 		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
 
-
 	this_usbduxsub->pwm_cmd_running = 0;
 
 	return ret;
 }
 
 /* force unlink - is called by comedi */
-static int usbdux_pwm_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbdux_pwm_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
@@ -2010,10 +2021,11 @@ static int usbduxsub_submit_PwmURBs(stru
 
 	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(usbduxsub->urbPwm,
-		usbduxsub->usbdev,
-		usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
-		usbduxsub->urbPwm->transfer_buffer,
-		usbduxsub->sizePwmBuf, usbduxsub_pwm_irq, usbduxsub->comedidev);
+			  usbduxsub->usbdev,
+			  usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
+			  usbduxsub->urbPwm->transfer_buffer,
+			  usbduxsub->sizePwmBuf, usbduxsub_pwm_irq,
+			  usbduxsub->comedidev);
 
 	errFlag = usb_submit_urb(usbduxsub->urbPwm, GFP_ATOMIC);
 	if (errFlag) {
@@ -2025,8 +2037,8 @@ static int usbduxsub_submit_PwmURBs(stru
 	return 0;
 }
 
-static int usbdux_pwm_period(struct comedi_device *dev, struct comedi_subdevice *s,
-			     unsigned int period)
+static int usbdux_pwm_period(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int period)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int fx2delay = 255;
@@ -2037,11 +2049,11 @@ static int usbdux_pwm_period(struct come
 			dev->minor);
 		return -EAGAIN;
 	} else {
-		fx2delay = period / ((int)(6*512*(1.0/0.033))) - 6;
+		fx2delay = period / ((int)(6 * 512 * (1.0 / 0.033))) - 6;
 		if (fx2delay > 255) {
 			dev_err(&this_usbduxsub->interface->dev,
 				"comedi%d: period %d for pwm is too low.\n",
-			       dev->minor, period);
+				dev->minor, period);
 			return -EAGAIN;
 		}
 	}
@@ -2053,7 +2065,8 @@ static int usbdux_pwm_period(struct come
 }
 
 /* is called from insn so there's no need to do all the sanity checks */
-static int usbdux_pwm_start(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbdux_pwm_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	int ret, i;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2085,8 +2098,9 @@ static int usbdux_pwm_start(struct comed
 }
 
 /* generates the bit pattern for PWM with the optional sign bit */
-static int usbdux_pwm_pattern(struct comedi_device *dev, struct comedi_subdevice *s,
-			      int channel, unsigned int value, unsigned int sign)
+static int usbdux_pwm_pattern(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int channel,
+			      unsigned int value, unsigned int sign)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int i, szbuf;
@@ -2126,7 +2140,8 @@ static int usbdux_pwm_pattern(struct com
 	return 1;
 }
 
-static int usbdux_pwm_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_pwm_write(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2147,19 +2162,20 @@ static int usbdux_pwm_write(struct comed
 	 * normal operation
 	 * relay sign 0 by default
 	 */
-	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec),
-				  data[0], 0);
+	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec), data[0], 0);
 }
 
-static int usbdux_pwm_read(struct comedi_device *x1, struct comedi_subdevice *x2,
-			   struct comedi_insn *x3, unsigned int *x4)
+static int usbdux_pwm_read(struct comedi_device *x1,
+			   struct comedi_subdevice *x2, struct comedi_insn *x3,
+			   unsigned int *x4)
 {
 	/* not needed */
 	return -EINVAL;
 };
 
 /* switches on/off PWM */
-static int usbdux_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_pwm_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2249,10 +2265,10 @@ static void tidy_up(struct usbduxsub *us
 		}
 		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
 			if (usbduxsub_tmp->urbOut[i]->transfer_buffer) {
-				kfree(usbduxsub_tmp->urbOut[i]->
-					transfer_buffer);
+				kfree(usbduxsub_tmp->
+				      urbOut[i]->transfer_buffer);
 				usbduxsub_tmp->urbOut[i]->transfer_buffer =
-					NULL;
+				    NULL;
 			}
 			if (usbduxsub_tmp->urbOut[i]) {
 				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
@@ -2310,8 +2326,7 @@ static void usbdux_firmware_request_comp
 
 	if (ret) {
 		dev_err(&usbdev->dev,
-			"Could not upload firmware (err=%d)\n",
-			ret);
+			"Could not upload firmware (err=%d)\n", ret);
 		return;
 	}
 	comedi_usb_auto_config(usbdev, BOARDNAME);
@@ -2365,7 +2380,7 @@ static int usbduxsub_probe(struct usb_in
 
 	/* test if it is high speed (USB 2.0) */
 	usbduxsub[index].high_speed =
-		(usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
+	    (usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
 
 	/* create space for the commands of the DA converter */
 	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
@@ -2429,8 +2444,8 @@ static int usbduxsub_probe(struct usb_in
 		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
 
 	usbduxsub[index].urbIn =
-		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
-		GFP_KERNEL);
+	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
+		    GFP_KERNEL);
 	if (!(usbduxsub[index].urbIn)) {
 		dev_err(dev, "comedi_: usbdux: Could not alloc. urbIn array\n");
 		tidy_up(&(usbduxsub[index]));
@@ -2452,10 +2467,10 @@ static int usbduxsub_probe(struct usb_in
 		/* and ONLY then the urb should be submitted */
 		usbduxsub[index].urbIn[i]->context = NULL;
 		usbduxsub[index].urbIn[i]->pipe =
-			usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
+		    usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
 		usbduxsub[index].urbIn[i]->transfer_flags = URB_ISO_ASAP;
 		usbduxsub[index].urbIn[i]->transfer_buffer =
-			kzalloc(SIZEINBUF, GFP_KERNEL);
+		    kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"could not alloc. transb.\n", index);
@@ -2477,8 +2492,8 @@ static int usbduxsub_probe(struct usb_in
 		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
 
 	usbduxsub[index].urbOut =
-		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
-		GFP_KERNEL);
+	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
+		    GFP_KERNEL);
 	if (!(usbduxsub[index].urbOut)) {
 		dev_err(dev, "comedi_: usbdux: "
 			"Could not alloc. urbOut array\n");
@@ -2501,10 +2516,10 @@ static int usbduxsub_probe(struct usb_in
 		/* and ONLY then the urb should be submitted */
 		usbduxsub[index].urbOut[i]->context = NULL;
 		usbduxsub[index].urbOut[i]->pipe =
-			usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
+		    usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
 		usbduxsub[index].urbOut[i]->transfer_flags = URB_ISO_ASAP;
 		usbduxsub[index].urbOut[i]->transfer_buffer =
-			kzalloc(SIZEOUTBUF, GFP_KERNEL);
+		    kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"could not alloc. transb.\n", index);
@@ -2517,7 +2532,7 @@ static int usbduxsub_probe(struct usb_in
 		usbduxsub[index].urbOut[i]->transfer_buffer_length = SIZEOUTBUF;
 		usbduxsub[index].urbOut[i]->iso_frame_desc[0].offset = 0;
 		usbduxsub[index].urbOut[i]->iso_frame_desc[0].length =
-			SIZEOUTBUF;
+		    SIZEOUTBUF;
 		if (usbduxsub[index].high_speed) {
 			/* uframes */
 			usbduxsub[index].urbOut[i]->interval = 8;
@@ -2540,7 +2555,7 @@ static int usbduxsub_probe(struct usb_in
 			return -ENOMEM;
 		}
 		usbduxsub[index].urbPwm->transfer_buffer =
-			kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
+		    kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
 		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"could not alloc. transb. for pwm\n", index);
@@ -2568,8 +2583,6 @@ static int usbduxsub_probe(struct usb_in
 				      usbduxsub + index,
 				      usbdux_firmware_request_complete_handler);
 
-
-
 	if (ret) {
 		dev_err(dev, "Could not load firmware (err=%d)\n", ret);
 		return ret;
@@ -2592,8 +2605,7 @@ static void usbduxsub_disconnect(struct 
 		return;
 	}
 	if (usbduxsub_tmp->usbdev != udev) {
-		dev_err(&intf->dev,
-			"comedi_: BUG! called with wrong ptr!!!\n");
+		dev_err(&intf->dev, "comedi_: BUG! called with wrong ptr!!!\n");
 		return;
 	}
 	comedi_usb_auto_unconfig(udev);
@@ -2641,7 +2653,7 @@ static int usbdux_attach(struct comedi_d
 
 	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
-		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+	    it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
 		firmwareUpload(udev, comedi_aux_data(it->options, 0),
 			       it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
 	}
@@ -2667,8 +2679,8 @@ static int usbdux_attach(struct comedi_d
 	}
 
 	dev_info(&udev->interface->dev,
-		"comedi%d: usb-device %d is attached to comedi.\n",
-		dev->minor, index);
+		 "comedi%d: usb-device %d is attached to comedi.\n",
+		 dev->minor, index);
 	/* private structure is also simply the usb-structure */
 	dev->private = udev;
 
@@ -2779,14 +2791,14 @@ static int usbdux_detach(struct comedi_d
 
 	if (!dev) {
 		printk(KERN_ERR
-			"comedi?: usbdux: detach without dev variable...\n");
+		       "comedi?: usbdux: detach without dev variable...\n");
 		return -EFAULT;
 	}
 
 	usbduxsub_tmp = dev->private;
 	if (!usbduxsub_tmp) {
 		printk(KERN_ERR
-			"comedi?: usbdux: detach without ptr to usbduxsub[]\n");
+		       "comedi?: usbdux: detach without ptr to usbduxsub[]\n");
 		return -EFAULT;
 	}
 
@@ -2807,16 +2819,16 @@ static int usbdux_detach(struct comedi_d
 
 /* main driver struct */
 static struct comedi_driver driver_usbdux = {
-      .driver_name =	"usbdux",
-      .module =		THIS_MODULE,
-      .attach =		usbdux_attach,
-      .detach =		usbdux_detach,
+	.driver_name = "usbdux",
+	.module = THIS_MODULE,
+	.attach = usbdux_attach,
+	.detach = usbdux_detach,
 };
 
 /* Table with the USB-devices: just now only testing IDs */
 static struct usb_device_id usbduxsub_table[] = {
-	{USB_DEVICE(0x13d8, 0x0001) },
-	{USB_DEVICE(0x13d8, 0x0002) },
+	{USB_DEVICE(0x13d8, 0x0001)},
+	{USB_DEVICE(0x13d8, 0x0002)},
 	{}			/* Terminating entry */
 };
 
@@ -2824,10 +2836,10 @@ MODULE_DEVICE_TABLE(usb, usbduxsub_table
 
 /* The usbduxsub-driver */
 static struct usb_driver usbduxsub_driver = {
-      .name =		BOARDNAME,
-      .probe =		usbduxsub_probe,
-      .disconnect =	usbduxsub_disconnect,
-      .id_table =	usbduxsub_table,
+	.name = BOARDNAME,
+	.probe = usbduxsub_probe,
+	.disconnect = usbduxsub_disconnect,
+	.id_table = usbduxsub_table,
 };
 
 /* Can't use the nice macro as I have also to initialise the USB */
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -50,7 +50,6 @@
 #include "comedi_fc.h"
 #include "../comedidev.h"
 
-
 #define DRIVER_VERSION "v1.0"
 #define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
 #define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
@@ -161,7 +160,7 @@
  * comedi constants
  */
 static const struct comedi_lrange range_usbduxfast_ai_range = {
-	2, { BIP_RANGE(0.75), BIP_RANGE(0.5) }
+	2, {BIP_RANGE(0.75), BIP_RANGE(0.5)}
 };
 
 /*
@@ -171,22 +170,22 @@ static const struct comedi_lrange range_
  * one sub device just now: A/D
  */
 struct usbduxfastsub_s {
-	int attached;			/* is attached? */
-	int probed;			/* is it associated with a subdevice? */
+	int attached;		/* is attached? */
+	int probed;		/* is it associated with a subdevice? */
 	struct usb_device *usbdev;	/* pointer to the usb-device */
-	struct urb *urbIn;		/* BULK-transfer handling: urb */
+	struct urb *urbIn;	/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
-	int16_t *insnBuffer;		/* input buffer for single insn */
-	int ifnum;			/* interface number */
+	int16_t *insnBuffer;	/* input buffer for single insn */
+	int ifnum;		/* interface number */
 	struct usb_interface *interface;	/* interface structure */
 	struct comedi_device *comedidev;	/* comedi device for the interrupt
-					   context */
+						   context */
 	short int ai_cmd_running;	/* asynchronous command is running */
-	short int ai_continous;		/* continous aquisition */
+	short int ai_continous;	/* continous aquisition */
 	long int ai_sample_count;	/* number of samples to aquire */
-	uint8_t *dux_commands;		/* commands */
-	int ignore;			/* counter which ignores the first
-					   buffers */
+	uint8_t *dux_commands;	/* commands */
+	int ignore;		/* counter which ignores the first
+				   buffers */
 	struct semaphore sem;
 };
 
@@ -217,7 +216,7 @@ static int send_dux_commands(struct usbd
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: dux_commands: ",
-		udfs->comedidev->minor);
+	       udfs->comedidev->minor);
 	for (tmp = 0; tmp < SIZEOFDUXBUFFER; tmp++)
 		printk(" %02x", udfs->dux_commands[tmp]);
 	printk("\n");
@@ -228,7 +227,7 @@ static int send_dux_commands(struct usbd
 			   udfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
 		printk(KERN_ERR "comedi%d: could not transmit dux_commands to"
-		      "the usb-device, err=%d\n", udfs->comedidev->minor, tmp);
+		       "the usb-device, err=%d\n", udfs->comedidev->minor, tmp);
 	return tmp;
 }
 
@@ -258,8 +257,7 @@ static int usbduxfastsub_unlink_InURBs(s
  * Is called from within this driver from both the
  * interrupt context and from comedi.
  */
-static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
-	int do_unlink)
+static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs, int do_unlink)
 {
 	int ret = 0;
 
@@ -267,7 +265,6 @@ static int usbduxfast_ai_stop(struct usb
 		printk(KERN_ERR "comedi?: usbduxfast_ai_stop: udfs=NULL!\n");
 		return -EFAULT;
 	}
-
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi: usbduxfast_ai_stop\n");
 #endif
@@ -275,7 +272,7 @@ static int usbduxfast_ai_stop(struct usb
 	udfs->ai_cmd_running = 0;
 
 	if (do_unlink)
-		ret = usbduxfastsub_unlink_InURBs(udfs); /* stop aquistion */
+		ret = usbduxfastsub_unlink_InURBs(udfs);	/* stop aquistion */
 
 	return ret;
 }
@@ -284,7 +281,8 @@ static int usbduxfast_ai_stop(struct usb
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbduxfast_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbduxfast_ai_cancel(struct comedi_device *dev,
+				struct comedi_subdevice *s)
 {
 	struct usbduxfastsub_s *udfs;
 	int ret;
@@ -402,9 +400,9 @@ static void usbduxfastsub_ai_Irq(struct 
 				 * received
 				 */
 				cfc_write_array_to_buffer(s,
-					urb->transfer_buffer,
-					udfs->ai_sample_count
-					* sizeof(uint16_t));
+							  urb->transfer_buffer,
+							  udfs->ai_sample_count
+							  * sizeof(uint16_t));
 				usbduxfast_ai_stop(udfs, 0);
 				/* tell comedi that the acquistion is over */
 				s->async->events |= COMEDI_CB_EOA;
@@ -439,7 +437,7 @@ static void usbduxfastsub_ai_Irq(struct 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
 		printk(KERN_ERR "comedi%d: usbduxfast: urb resubm failed: %d",
-			udfs->comedidev->minor, err);
+		       udfs->comedidev->minor, err);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
 		comedi_event(udfs->comedidev, s);
@@ -454,15 +452,13 @@ static int usbduxfastsub_start(struct us
 
 	/* 7f92 to zero */
 	local_transfer_buffer[0] = 0;
-	ret = usb_control_msg(udfs->usbdev,
-		usb_sndctrlpipe(udfs->usbdev, 0),
-		USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
-		VENDOR_DIR_OUT,		/* bmRequestType */
-		USBDUXFASTSUB_CPUCS,	/* Value */
-		0x0000,			/* Index */
-		local_transfer_buffer,	/* address of the transfer buffer */
-		1,			/* Length */
-		EZTIMEOUT);		/* Timeout */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+			      VENDOR_DIR_OUT,	/* bmRequestType */
+			      USBDUXFASTSUB_CPUCS,	/* Value */
+			      0x0000,	/* Index */
+			      local_transfer_buffer,	/* address of the transfer buffer */
+			      1,	/* Length */
+			      EZTIMEOUT);	/* Timeout */
 	if (ret < 0) {
 		printk("comedi_: usbduxfast_: control msg failed (start)\n");
 		return ret;
@@ -478,15 +474,12 @@ static int usbduxfastsub_stop(struct usb
 
 	/* 7f92 to one */
 	local_transfer_buffer[0] = 1;
-	ret = usb_control_msg(udfs->usbdev,
-		usb_sndctrlpipe(udfs->usbdev, 0),
-		USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
-		VENDOR_DIR_OUT,		/* bmRequestType */
-		USBDUXFASTSUB_CPUCS,	/* Value */
-		0x0000,			/* Index */
-		local_transfer_buffer,
-		1,			/* Length */
-		EZTIMEOUT);		/* Timeout */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+			      VENDOR_DIR_OUT,	/* bmRequestType */
+			      USBDUXFASTSUB_CPUCS,	/* Value */
+			      0x0000,	/* Index */
+			      local_transfer_buffer, 1,	/* Length */
+			      EZTIMEOUT);	/* Timeout */
 	if (ret < 0) {
 		printk(KERN_ERR "comedi_: usbduxfast: control msg failed "
 		       "(stop)\n");
@@ -497,25 +490,23 @@ static int usbduxfastsub_stop(struct usb
 }
 
 static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
-	unsigned char *local_transfer_buffer,
-	unsigned int startAddr, unsigned int len)
+				unsigned char *local_transfer_buffer,
+				unsigned int startAddr, unsigned int len)
 {
 	int ret;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi: usbduxfast: uploading %d bytes", len);
 	printk(KERN_DEBUG " to addr %d, first byte=%d.\n",
-		startAddr, local_transfer_buffer[0]);
+	       startAddr, local_transfer_buffer[0]);
 #endif
-	ret = usb_control_msg(udfs->usbdev,
-		usb_sndctrlpipe(udfs->usbdev, 0),
-		USBDUXFASTSUB_FIRMWARE, /* brequest, firmware */
-		VENDOR_DIR_OUT,		/* bmRequestType */
-		startAddr,		/* value */
-		0x0000,			/* index */
-		local_transfer_buffer,	/* our local safe buffer */
-		len,			/* length */
-		EZTIMEOUT);		/* timeout */
+	ret = usb_control_msg(udfs->usbdev, usb_sndctrlpipe(udfs->usbdev, 0), USBDUXFASTSUB_FIRMWARE,	/* brequest, firmware */
+			      VENDOR_DIR_OUT,	/* bmRequestType */
+			      startAddr,	/* value */
+			      0x0000,	/* index */
+			      local_transfer_buffer,	/* our local safe buffer */
+			      len,	/* length */
+			      EZTIMEOUT);	/* timeout */
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi_: usbduxfast: result=%d\n", ret);
@@ -544,7 +535,7 @@ int usbduxfastsub_submit_InURBs(struct u
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
 	       "0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,
-		udfs->urbIn->dev);
+	       udfs->urbIn->dev);
 #endif
 	ret = usb_submit_urb(udfs->urbIn, GFP_ATOMIC);
 	if (ret) {
@@ -556,7 +547,8 @@ int usbduxfastsub_submit_InURBs(struct u
 }
 
 static int usbduxfast_ai_cmdtest(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_cmd *cmd)
+				 struct comedi_subdevice *s,
+				 struct comedi_cmd *cmd)
 {
 	int err = 0, stop_mask = 0;
 	long int steps, tmp;
@@ -608,16 +600,16 @@ static int usbduxfast_ai_cmdtest(struct 
 	 */
 
 	if (cmd->start_src != TRIG_NOW &&
-		cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)
+	    cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_FOLLOW &&
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
+	    cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
 	/* can't have external stop and start triggers at once */
@@ -698,7 +690,8 @@ static int usbduxfast_ai_cmdtest(struct 
 }
 
 static int usbduxfast_ai_inttrig(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int trignum)
+				 struct comedi_subdevice *s,
+				 unsigned int trignum)
 {
 	int ret;
 	struct usbduxfastsub_s *udfs = dev->private;
@@ -749,7 +742,8 @@ static int usbduxfast_ai_inttrig(struct 
 #define OUTBASE	(1+0x10)
 #define LOGBASE	(1+0x18)
 
-static int usbduxfast_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbduxfast_ai_cmd(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain, rngmask = 0xff;
@@ -797,7 +791,7 @@ static int usbduxfast_ai_cmd(struct come
 				return -EINVAL;
 			}
 			if ((gain != CR_RANGE(cmd->chanlist[i]))
-				&& (cmd->chanlist_len > 3)) {
+			    && (cmd->chanlist_len > 3)) {
 				printk(KERN_ERR "comedi%d: the gain must be"
 				       " the same for all channels.\n",
 				       dev->minor);
@@ -835,7 +829,7 @@ static int usbduxfast_ai_cmd(struct come
 		return -EINVAL;
 	}
 	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
-		&& (cmd->chanlist_len != 16)) {
+	    && (cmd->chanlist_len != 16)) {
 		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: TRIG_EXT only"
 		       " with 1 or 16 channels possible.\n", dev->minor);
 		up(&udfs->sem);
@@ -865,17 +859,17 @@ static int usbduxfast_ai_cmd(struct come
 		/* we loop here until ready has been set */
 		if (cmd->start_src == TRIG_EXT) {
 			/* branch back to state 0 */
-			udfs->dux_commands[LENBASE+0] = 0x01;
+			udfs->dux_commands[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			udfs->dux_commands[OPBASE+0] = 0x01;
-			udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+			udfs->dux_commands[OPBASE + 0] = 0x01;
+			udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
 			/* RDY0 = 0 */
-			udfs->dux_commands[LOGBASE+0] = 0x00;
+			udfs->dux_commands[LOGBASE + 0] = 0x00;
 		} else {	/* we just proceed to state 1 */
-			udfs->dux_commands[LENBASE+0] = 1;
-			udfs->dux_commands[OPBASE+0] = 0;
-			udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE+0] = 0;
+			udfs->dux_commands[LENBASE + 0] = 1;
+			udfs->dux_commands[OPBASE + 0] = 0;
+			udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE + 0] = 0;
 		}
 
 		if (steps < MIN_SAMPLING_PERIOD) {
@@ -888,30 +882,33 @@ static int usbduxfast_ai_cmd(struct come
 				 */
 
 				/* branch back to state 1 */
-				udfs->dux_commands[LENBASE+1] = 0x89;
+				udfs->dux_commands[LENBASE + 1] = 0x89;
 				/* deceision state with data */
-				udfs->dux_commands[OPBASE+1] = 0x03;
-				udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+				udfs->dux_commands[OPBASE + 1] = 0x03;
+				udfs->dux_commands[OUTBASE + 1] =
+				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE+1] = 0xFF;
+				udfs->dux_commands[LOGBASE + 1] = 0xFF;
 			} else {
 				/*
 				 * we loop through two states: data and delay
 				 * max rate is 15MHz
 				 */
-				udfs->dux_commands[LENBASE+1] = steps - 1;
+				udfs->dux_commands[LENBASE + 1] = steps - 1;
 				/* data */
-				udfs->dux_commands[OPBASE+1] = 0x02;
-				udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+				udfs->dux_commands[OPBASE + 1] = 0x02;
+				udfs->dux_commands[OUTBASE + 1] =
+				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE+1] = 0;
+				udfs->dux_commands[LOGBASE + 1] = 0;
 				/* branch back to state 1 */
-				udfs->dux_commands[LENBASE+2] = 0x09;
+				udfs->dux_commands[LENBASE + 2] = 0x09;
 				/* deceision state w/o data */
-				udfs->dux_commands[OPBASE+2] = 0x01;
-				udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
+				udfs->dux_commands[OPBASE + 2] = 0x01;
+				udfs->dux_commands[OUTBASE + 2] =
+				    0xFF & rngmask;
 				/* doesn't matter */
-				udfs->dux_commands[LOGBASE+2] = 0xFF;
+				udfs->dux_commands[LOGBASE + 2] = 0xFF;
 			}
 		} else {
 			/*
@@ -923,26 +920,26 @@ static int usbduxfast_ai_cmd(struct come
 			steps = steps - 1;
 
 			/* do the first part of the delay */
-			udfs->dux_commands[LENBASE+1] = steps / 2;
-			udfs->dux_commands[OPBASE+1] = 0;
-			udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE+1] = 0;
+			udfs->dux_commands[LENBASE + 1] = steps / 2;
+			udfs->dux_commands[OPBASE + 1] = 0;
+			udfs->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE + 1] = 0;
 
 			/* and the second part */
-			udfs->dux_commands[LENBASE+2] = steps - steps / 2;
-			udfs->dux_commands[OPBASE+2] = 0;
-			udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE+2] = 0;
+			udfs->dux_commands[LENBASE + 2] = steps - steps / 2;
+			udfs->dux_commands[OPBASE + 2] = 0;
+			udfs->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE + 2] = 0;
 
 			/* get the data and branch back */
 
 			/* branch back to state 1 */
-			udfs->dux_commands[LENBASE+3] = 0x09;
+			udfs->dux_commands[LENBASE + 3] = 0x09;
 			/* deceision state w data */
-			udfs->dux_commands[OPBASE+3] = 0x03;
-			udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
+			udfs->dux_commands[OPBASE + 3] = 0x03;
+			udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
 			/* doesn't matter */
-			udfs->dux_commands[LOGBASE+3] = 0xFF;
+			udfs->dux_commands[LOGBASE + 3] = 0xFF;
 		}
 		break;
 
@@ -957,11 +954,11 @@ static int usbduxfast_ai_cmd(struct come
 		else
 			rngmask = 0xff;
 
-		udfs->dux_commands[LENBASE+0] = 1;
+		udfs->dux_commands[LENBASE + 0] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE+0] = 0x02;
-		udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+0] = 0;
+		udfs->dux_commands[OPBASE + 0] = 0x02;
+		udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 0] = 0;
 
 		/* we have 1 state with duration 1: state 0 */
 		steps_tmp = steps - 1;
@@ -972,23 +969,23 @@ static int usbduxfast_ai_cmd(struct come
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE+1] = steps_tmp / 2;
-		udfs->dux_commands[OPBASE+1] = 0;
+		udfs->dux_commands[LENBASE + 1] = steps_tmp / 2;
+		udfs->dux_commands[OPBASE + 1] = 0;
 		/* count */
-		udfs->dux_commands[OUTBASE+1] = 0xFE & rngmask;
-		udfs->dux_commands[LOGBASE+1] = 0;
+		udfs->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
+		udfs->dux_commands[LOGBASE + 1] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE+2] = steps_tmp - steps_tmp / 2;
-		udfs->dux_commands[OPBASE+2] = 0;
-		udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+2] = 0;
+		udfs->dux_commands[LENBASE + 2] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[OPBASE + 2] = 0;
+		udfs->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 2] = 0;
 
-		udfs->dux_commands[LENBASE+3] = 1;
+		udfs->dux_commands[LENBASE + 3] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE+3] = 0x02;
-		udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+3] = 0;
+		udfs->dux_commands[OPBASE + 3] = 0x02;
+		udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 3] = 0;
 
 		/*
 		 * we have 2 states with duration 1: step 6 and
@@ -1002,22 +999,22 @@ static int usbduxfast_ai_cmd(struct come
 			rngmask = 0xff;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE+4] = steps_tmp / 2;
-		udfs->dux_commands[OPBASE+4] = 0;
+		udfs->dux_commands[LENBASE + 4] = steps_tmp / 2;
+		udfs->dux_commands[OPBASE + 4] = 0;
 		/* reset */
-		udfs->dux_commands[OUTBASE+4] = (0xFF - 0x02) & rngmask;
-		udfs->dux_commands[LOGBASE+4] = 0;
+		udfs->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;
+		udfs->dux_commands[LOGBASE + 4] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE+5] = steps_tmp - steps_tmp / 2;
-		udfs->dux_commands[OPBASE+5] = 0;
-		udfs->dux_commands[OUTBASE+5] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+5] = 0;
-
-		udfs->dux_commands[LENBASE+6] = 1;
-		udfs->dux_commands[OPBASE+6] = 0;
-		udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+6] = 0;
+		udfs->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[OPBASE + 5] = 0;
+		udfs->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 5] = 0;
+
+		udfs->dux_commands[LENBASE + 6] = 1;
+		udfs->dux_commands[OPBASE + 6] = 0;
+		udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 6] = 0;
 		break;
 
 	case 3:
@@ -1033,12 +1030,12 @@ static int usbduxfast_ai_cmd(struct come
 			 * commit data to the FIFO and do the first part
 			 * of the delay
 			 */
-			udfs->dux_commands[LENBASE+j*2] = steps / 2;
+			udfs->dux_commands[LENBASE + j * 2] = steps / 2;
 			/* data */
-			udfs->dux_commands[OPBASE+j*2] = 0x02;
+			udfs->dux_commands[OPBASE + j * 2] = 0x02;
 			/* no change */
-			udfs->dux_commands[OUTBASE+j*2] = 0xFF & rngmask;
-			udfs->dux_commands[LOGBASE+j*2] = 0;
+			udfs->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE + j * 2] = 0;
 
 			if (CR_RANGE(cmd->chanlist[j + 1]) > 0)
 				rngmask = 0xff - 0x04;
@@ -1046,23 +1043,25 @@ static int usbduxfast_ai_cmd(struct come
 				rngmask = 0xff;
 
 			/* do the second part of the delay */
-			udfs->dux_commands[LENBASE+j*2+1] = steps - steps / 2;
+			udfs->dux_commands[LENBASE + j * 2 + 1] =
+			    steps - steps / 2;
 			/* no data */
-			udfs->dux_commands[OPBASE+j*2+1] = 0;
+			udfs->dux_commands[OPBASE + j * 2 + 1] = 0;
 			/* count */
-			udfs->dux_commands[OUTBASE+j*2+1] = 0xFE & rngmask;
-			udfs->dux_commands[LOGBASE+j*2+1] = 0;
+			udfs->dux_commands[OUTBASE + j * 2 + 1] =
+			    0xFE & rngmask;
+			udfs->dux_commands[LOGBASE + j * 2 + 1] = 0;
 		}
 
 		/* 2 steps with duration 1: the idele step and step 6: */
 		steps_tmp = steps - 2;
 
 		/* commit data to the FIFO and do the first part of the delay */
-		udfs->dux_commands[LENBASE+4] = steps_tmp / 2;
+		udfs->dux_commands[LENBASE + 4] = steps_tmp / 2;
 		/* data */
-		udfs->dux_commands[OPBASE+4] = 0x02;
-		udfs->dux_commands[OUTBASE+4] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+4] = 0;
+		udfs->dux_commands[OPBASE + 4] = 0x02;
+		udfs->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 4] = 0;
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
@@ -1070,17 +1069,17 @@ static int usbduxfast_ai_cmd(struct come
 			rngmask = 0xff;
 
 		/* do the second part of the delay */
-		udfs->dux_commands[LENBASE+5] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[LENBASE + 5] = steps_tmp - steps_tmp / 2;
 		/* no data */
-		udfs->dux_commands[OPBASE+5] = 0;
+		udfs->dux_commands[OPBASE + 5] = 0;
 		/* reset */
-		udfs->dux_commands[OUTBASE+5] = (0xFF - 0x02) & rngmask;
-		udfs->dux_commands[LOGBASE+5] = 0;
+		udfs->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;
+		udfs->dux_commands[LOGBASE + 5] = 0;
 
-		udfs->dux_commands[LENBASE+6] = 1;
-		udfs->dux_commands[OPBASE+6] = 0;
-		udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+6] = 0;
+		udfs->dux_commands[LENBASE + 6] = 1;
+		udfs->dux_commands[OPBASE + 6] = 0;
+		udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 6] = 0;
 
 	case 16:
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
@@ -1094,55 +1093,57 @@ static int usbduxfast_ai_cmd(struct come
 			 */
 
 			/* branch back to state 0 */
-			udfs->dux_commands[LENBASE+0] = 0x01;
+			udfs->dux_commands[LENBASE + 0] = 0x01;
 			/* deceision state w/o data */
-			udfs->dux_commands[OPBASE+0] = 0x01;
+			udfs->dux_commands[OPBASE + 0] = 0x01;
 			/* reset */
-			udfs->dux_commands[OUTBASE+0] = (0xFF-0x02) & rngmask;
+			udfs->dux_commands[OUTBASE + 0] =
+			    (0xFF - 0x02) & rngmask;
 			/* RDY0 = 0 */
-			udfs->dux_commands[LOGBASE+0] = 0x00;
+			udfs->dux_commands[LOGBASE + 0] = 0x00;
 		} else {
 			/*
 			 * we just proceed to state 1
 			 */
 
 			/* 30us reset pulse */
-			udfs->dux_commands[LENBASE+0] = 255;
-			udfs->dux_commands[OPBASE+0] = 0;
+			udfs->dux_commands[LENBASE + 0] = 255;
+			udfs->dux_commands[OPBASE + 0] = 0;
 			/* reset */
-			udfs->dux_commands[OUTBASE+0] = (0xFF-0x02) & rngmask;
-			udfs->dux_commands[LOGBASE+0] = 0;
+			udfs->dux_commands[OUTBASE + 0] =
+			    (0xFF - 0x02) & rngmask;
+			udfs->dux_commands[LOGBASE + 0] = 0;
 		}
 
 		/* commit data to the FIFO */
-		udfs->dux_commands[LENBASE+1] = 1;
+		udfs->dux_commands[LENBASE + 1] = 1;
 		/* data */
-		udfs->dux_commands[OPBASE+1] = 0x02;
-		udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+1] = 0;
+		udfs->dux_commands[OPBASE + 1] = 0x02;
+		udfs->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 1] = 0;
 
 		/* we have 2 states with duration 1 */
 		steps = steps - 2;
 
 		/* do the first part of the delay */
-		udfs->dux_commands[LENBASE+2] = steps / 2;
-		udfs->dux_commands[OPBASE+2] = 0;
-		udfs->dux_commands[OUTBASE+2] = 0xFE & rngmask;
-		udfs->dux_commands[LOGBASE+2] = 0;
+		udfs->dux_commands[LENBASE + 2] = steps / 2;
+		udfs->dux_commands[OPBASE + 2] = 0;
+		udfs->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
+		udfs->dux_commands[LOGBASE + 2] = 0;
 
 		/* and the second part */
-		udfs->dux_commands[LENBASE+3] = steps - steps / 2;
-		udfs->dux_commands[OPBASE+3] = 0;
-		udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
-		udfs->dux_commands[LOGBASE+3] = 0;
+		udfs->dux_commands[LENBASE + 3] = steps - steps / 2;
+		udfs->dux_commands[OPBASE + 3] = 0;
+		udfs->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE + 3] = 0;
 
 		/* branch back to state 1 */
-		udfs->dux_commands[LENBASE+4] = 0x09;
+		udfs->dux_commands[LENBASE + 4] = 0x09;
 		/* deceision state w/o data */
-		udfs->dux_commands[OPBASE+4] = 0x01;
-		udfs->dux_commands[OUTBASE+4] = 0xFF & rngmask;
+		udfs->dux_commands[OPBASE + 4] = 0x01;
+		udfs->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
 		/* doesn't matter */
-		udfs->dux_commands[LOGBASE+4] = 0xFF;
+		udfs->dux_commands[LOGBASE + 4] = 0xFF;
 
 		break;
 
@@ -1166,7 +1167,7 @@ static int usbduxfast_ai_cmd(struct come
 		return result;
 	}
 	if (cmd->stop_src == TRIG_COUNT) {
-		udfs->ai_sample_count =	cmd->stop_arg * cmd->scan_end_arg;
+		udfs->ai_sample_count = cmd->stop_arg * cmd->scan_end_arg;
 		if (udfs->ai_sample_count < 1) {
 			printk(KERN_ERR "comedi%d: "
 			       "(cmd->stop_arg)*(cmd->scan_end_arg)<1, "
@@ -1209,7 +1210,8 @@ static int usbduxfast_ai_cmd(struct come
  * Mode 0 is used to get a single conversion on demand.
  */
 static int usbduxfast_ai_insn_read(struct comedi_device *dev,
-	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int i, j, n, actual_length;
 	int chan, range, rngmask;
@@ -1248,43 +1250,43 @@ static int usbduxfast_ai_insn_read(struc
 		rngmask = 0xff;
 
 	/* commit data to the FIFO */
-	udfs->dux_commands[LENBASE+0] = 1;
+	udfs->dux_commands[LENBASE + 0] = 1;
 	/* data */
-	udfs->dux_commands[OPBASE+0] = 0x02;
-	udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE+0] = 0;
+	udfs->dux_commands[OPBASE + 0] = 0x02;
+	udfs->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE + 0] = 0;
 
 	/* do the first part of the delay */
-	udfs->dux_commands[LENBASE+1] = 12;
-	udfs->dux_commands[OPBASE+1] = 0;
-	udfs->dux_commands[OUTBASE+1] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE+1] = 0;
-
-	udfs->dux_commands[LENBASE+2] = 1;
-	udfs->dux_commands[OPBASE+2] = 0;
-	udfs->dux_commands[OUTBASE+2] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE+2] = 0;
-
-	udfs->dux_commands[LENBASE+3] = 1;
-	udfs->dux_commands[OPBASE+3] = 0;
-	udfs->dux_commands[OUTBASE+3] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE+3] = 0;
-
-	udfs->dux_commands[LENBASE+4] = 1;
-	udfs->dux_commands[OPBASE+4] = 0;
-	udfs->dux_commands[OUTBASE+4] = 0xFE & rngmask;
-	udfs->dux_commands[LOGBASE+4] = 0;
+	udfs->dux_commands[LENBASE + 1] = 12;
+	udfs->dux_commands[OPBASE + 1] = 0;
+	udfs->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE + 1] = 0;
+
+	udfs->dux_commands[LENBASE + 2] = 1;
+	udfs->dux_commands[OPBASE + 2] = 0;
+	udfs->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE + 2] = 0;
+
+	udfs->dux_commands[LENBASE + 3] = 1;
+	udfs->dux_commands[OPBASE + 3] = 0;
+	udfs->dux_commands[OUTBASE + 3] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE + 3] = 0;
+
+	udfs->dux_commands[LENBASE + 4] = 1;
+	udfs->dux_commands[OPBASE + 4] = 0;
+	udfs->dux_commands[OUTBASE + 4] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE + 4] = 0;
 
 	/* second part */
-	udfs->dux_commands[LENBASE+5] = 12;
-	udfs->dux_commands[OPBASE+5] = 0;
-	udfs->dux_commands[OUTBASE+5] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE+5] = 0;
-
-	udfs->dux_commands[LENBASE+6] = 1;
-	udfs->dux_commands[OPBASE+6] = 0;
-	udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
-	udfs->dux_commands[LOGBASE+0] = 0;
+	udfs->dux_commands[LENBASE + 5] = 12;
+	udfs->dux_commands[OPBASE + 5] = 0;
+	udfs->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE + 5] = 0;
+
+	udfs->dux_commands[LENBASE + 6] = 1;
+	udfs->dux_commands[OPBASE + 6] = 0;
+	udfs->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE + 0] = 0;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
@@ -1310,7 +1312,7 @@ static int usbduxfast_ai_insn_read(struc
 				   &actual_length, 10000);
 		if (err < 0) {
 			printk(KERN_ERR "comedi%d: insn timeout. No data.\n",
-				dev->minor);
+			       dev->minor);
 			up(&udfs->sem);
 			return err;
 		}
@@ -1323,7 +1325,7 @@ static int usbduxfast_ai_insn_read(struc
 				   &actual_length, 10000);
 		if (err < 0) {
 			printk(KERN_ERR "comedi%d: insn data error: %d\n",
-				dev->minor, err);
+			       dev->minor, err);
 			up(&udfs->sem);
 			return err;
 		}
@@ -1346,8 +1348,7 @@ static int usbduxfast_ai_insn_read(struc
 #define FIRMWARE_MAX_LEN 0x2000
 
 static int firmwareUpload(struct usbduxfastsub_s *usbduxfastsub,
-			  const u8 *firmwareBinary,
-			  int sizeFirmware)
+			  const u8 * firmwareBinary, int sizeFirmware)
 {
 	int ret;
 	uint8_t *fwBuf;
@@ -1355,7 +1356,7 @@ static int firmwareUpload(struct usbduxf
 	if (!firmwareBinary)
 		return 0;
 
-	if (sizeFirmware>FIRMWARE_MAX_LEN) {
+	if (sizeFirmware > FIRMWARE_MAX_LEN) {
 		dev_err(&usbduxfastsub->interface->dev,
 			"comedi_: usbduxfast firmware binary it too large for FX2.\n");
 		return -ENOMEM;
@@ -1368,7 +1369,7 @@ static int firmwareUpload(struct usbduxf
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
-	memcpy(fwBuf,firmwareBinary,sizeFirmware);
+	memcpy(fwBuf, firmwareBinary, sizeFirmware);
 
 	ret = usbduxfastsub_stop(usbduxfastsub);
 	if (ret < 0) {
@@ -1396,8 +1397,6 @@ static int firmwareUpload(struct usbduxf
 	return 0;
 }
 
-
-
 static void tidy_up(struct usbduxfastsub_s *udfs)
 {
 #ifdef CONFIG_COMEDI_DEBUG
@@ -1433,8 +1432,8 @@ static void tidy_up(struct usbduxfastsub
 	udfs->ai_cmd_running = 0;
 }
 
-static void usbduxfast_firmware_request_complete_handler(const struct firmware *fw,
-							 void *context)
+static void usbduxfast_firmware_request_complete_handler(const struct firmware
+							 *fw, void *context)
 {
 	struct usbduxfastsub_s *usbduxfastsub_tmp = context;
 	struct usb_device *usbdev = usbduxfastsub_tmp->usbdev;
@@ -1451,8 +1450,7 @@ static void usbduxfast_firmware_request_
 
 	if (ret) {
 		dev_err(&usbdev->dev,
-			"Could not upload firmware (err=%d)\n",
-			ret);
+			"Could not upload firmware (err=%d)\n", ret);
 		return;
 	}
 
@@ -1463,7 +1461,7 @@ static void usbduxfast_firmware_request_
  * allocate memory for the urbs and initialise them
  */
 static int usbduxfastsub_probe(struct usb_interface *uinterf,
-	const struct usb_device_id *id)
+			       const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	int i;
@@ -1539,7 +1537,7 @@ static int usbduxfastsub_probe(struct us
 	}
 	/* setting to alternate setting 1: enabling bulk ep */
 	i = usb_set_interface(usbduxfastsub[index].usbdev,
-		usbduxfastsub[index].ifnum, 1);
+			      usbduxfastsub[index].ifnum, 1);
 	if (i < 0) {
 		printk(KERN_ERR "comedi_: usbduxfast%d: could not switch to "
 		       "alternate setting 1.\n", index);
@@ -1575,8 +1573,7 @@ static int usbduxfastsub_probe(struct us
 				      usbduxfast_firmware_request_complete_handler);
 
 	if (ret) {
-		dev_err(&udev->dev, "could not load firmware (err=%d)\n",
-			ret);
+		dev_err(&udev->dev, "could not load firmware (err=%d)\n", ret);
 		return ret;
 	}
 
@@ -1618,7 +1615,8 @@ static void usbduxfastsub_disconnect(str
 /*
  * is called when comedi-config is called
  */
-static int usbduxfast_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int usbduxfast_attach(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
 {
 	int ret;
 	int index;
@@ -1725,7 +1723,6 @@ static int usbduxfast_detach(struct come
 		       "variable...\n");
 		return -EFAULT;
 	}
-
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: detach usb device\n",
 	       dev->minor);
@@ -1760,10 +1757,10 @@ static int usbduxfast_detach(struct come
  * main driver struct
  */
 static struct comedi_driver driver_usbduxfast = {
-	.driver_name	= "usbduxfast",
-	.module		= THIS_MODULE,
-	.attach		= usbduxfast_attach,
-	.detach		= usbduxfast_detach
+	.driver_name = "usbduxfast",
+	.module = THIS_MODULE,
+	.attach = usbduxfast_attach,
+	.detach = usbduxfast_detach
 };
 
 /*
@@ -1771,9 +1768,9 @@ static struct comedi_driver driver_usbdu
  */
 static struct usb_device_id usbduxfastsub_table[] = {
 	/* { USB_DEVICE(0x4b4, 0x8613) }, testing */
-	{ USB_DEVICE(0x13d8, 0x0010) },	/* real ID */
-	{ USB_DEVICE(0x13d8, 0x0011) },	/* real ID */
-	{ }			/* Terminating entry */
+	{USB_DEVICE(0x13d8, 0x0010)},	/* real ID */
+	{USB_DEVICE(0x13d8, 0x0011)},	/* real ID */
+	{}			/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(usb, usbduxfastsub_table);
@@ -1783,12 +1780,12 @@ MODULE_DEVICE_TABLE(usb, usbduxfastsub_t
  */
 static struct usb_driver usbduxfastsub_driver = {
 #ifdef COMEDI_HAVE_USB_DRIVER_OWNER
-	.owner		= THIS_MODULE,
+	.owner = THIS_MODULE,
 #endif
-	.name		= BOARDNAME,
-	.probe		= usbduxfastsub_probe,
-	.disconnect	= usbduxfastsub_disconnect,
-	.id_table	= usbduxfastsub_table
+	.name = BOARDNAME,
+	.probe = usbduxfastsub_probe,
+	.disconnect = usbduxfastsub_disconnect,
+	.id_table = usbduxfastsub_table
 };
 
 /*
--- a/drivers/staging/comedi/drivers/vmk80xx.c
+++ b/drivers/staging/comedi/drivers/vmk80xx.c
@@ -76,19 +76,19 @@ enum {
 };
 
 static struct usb_device_id vmk80xx_id_table[] = {
-	{ USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055 },
-	{ USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055 },
-	{ USB_DEVICE(0x10cf, 0x5502), .driver_info = DEVICE_VMK8055 },
-	{ USB_DEVICE(0x10cf, 0x5503), .driver_info = DEVICE_VMK8055 },
-	{ USB_DEVICE(0x10cf, 0x8061), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8062), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8063), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8064), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8065), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8066), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8067), .driver_info = DEVICE_VMK8061 },
-	{ USB_DEVICE(0x10cf, 0x8068), .driver_info = DEVICE_VMK8061 },
-	{ } /* terminating entry */
+	{USB_DEVICE(0x10cf, 0x5500),.driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5501),.driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5502),.driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x5503),.driver_info = DEVICE_VMK8055},
+	{USB_DEVICE(0x10cf, 0x8061),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8062),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8063),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8064),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8065),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8066),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8067),.driver_info = DEVICE_VMK8061},
+	{USB_DEVICE(0x10cf, 0x8068),.driver_info = DEVICE_VMK8061},
+	{}			/* terminating entry */
 };
 
 MODULE_DEVICE_TABLE(usb, vmk80xx_id_table);
@@ -120,19 +120,19 @@ MODULE_DEVICE_TABLE(usb, vmk80xx_id_tabl
 #define VMK8055_CMD_WRT_AD      0x05
 
 #define VMK8061_CMD_RD_AI       0x00
-#define VMK8061_CMR_RD_ALL_AI   0x01    /* !non-active! */
+#define VMK8061_CMR_RD_ALL_AI   0x01	/* !non-active! */
 #define VMK8061_CMD_SET_AO      0x02
-#define VMK8061_CMD_SET_ALL_AO  0x03    /* !non-active! */
+#define VMK8061_CMD_SET_ALL_AO  0x03	/* !non-active! */
 #define VMK8061_CMD_OUT_PWM     0x04
 #define VMK8061_CMD_RD_DI       0x05
-#define VMK8061_CMD_DO          0x06    /* !non-active! */
+#define VMK8061_CMD_DO          0x06	/* !non-active! */
 #define VMK8061_CMD_CLR_DO      0x07
 #define VMK8061_CMD_SET_DO      0x08
-#define VMK8061_CMD_RD_CNT      0x09    /* TODO: completely pointless? */
-#define VMK8061_CMD_RST_CNT     0x0a    /* TODO: completely pointless? */
-#define VMK8061_CMD_RD_VERSION  0x0b    /* internal usage */
-#define VMK8061_CMD_RD_JMP_STAT 0x0c    /* TODO: not implemented yet */
-#define VMK8061_CMD_RD_PWR_STAT 0x0d    /* internal usage */
+#define VMK8061_CMD_RD_CNT      0x09	/* TODO: completely pointless? */
+#define VMK8061_CMD_RST_CNT     0x0a	/* TODO: completely pointless? */
+#define VMK8061_CMD_RD_VERSION  0x0b	/* internal usage */
+#define VMK8061_CMD_RD_JMP_STAT 0x0c	/* TODO: not implemented yet */
+#define VMK8061_CMD_RD_PWR_STAT 0x0d	/* internal usage */
 #define VMK8061_CMD_RD_DO       0x0e
 #define VMK8061_CMD_RD_AO       0x0f
 #define VMK8061_CMD_RD_PWM      0x10
@@ -153,15 +153,15 @@ MODULE_DEVICE_TABLE(usb, vmk80xx_id_tabl
 #undef CONFIG_VMK80XX_DEBUG
 
 #ifdef CONFIG_VMK80XX_DEBUG
- static int dbgvm = 1;
+static int dbgvm = 1;
 #else
- static int dbgvm;
+static int dbgvm;
 #endif
 
 #ifdef CONFIG_COMEDI_DEBUG
- static int dbgcm = 1;
+static int dbgcm = 1;
 #else
- static int dbgcm;
+static int dbgcm;
 #endif
 
 #define dbgvm(fmt, arg...)                     \
@@ -182,33 +182,33 @@ enum vmk80xx_model {
 };
 
 struct firmware_version {
-	unsigned char ic3_vers[32]; /* USB-Controller */
-	unsigned char ic6_vers[32]; /* CPU */
+	unsigned char ic3_vers[32];	/* USB-Controller */
+	unsigned char ic6_vers[32];	/* CPU */
 };
 
 static const struct comedi_lrange vmk8055_range = {
-	1, { UNI_RANGE(5) }
+	1, {UNI_RANGE(5)}
 };
 
 static const struct comedi_lrange vmk8061_range = {
-	2, { UNI_RANGE(5), UNI_RANGE(10) }
+	2, {UNI_RANGE(5), UNI_RANGE(10)}
 };
 
 struct vmk80xx_board {
 	const char *name;
 	enum vmk80xx_model model;
 	const struct comedi_lrange *range;
-	__u8   ai_chans;
+	__u8 ai_chans;
 	__le16 ai_bits;
-	__u8   ao_chans;
+	__u8 ao_chans;
 	__le16 ao_bits;
-	__u8   di_chans;
+	__u8 di_chans;
 	__le16 di_bits;
-	__u8   do_chans;
+	__u8 do_chans;
 	__le16 do_bits;
-	__u8   cnt_chans;
+	__u8 cnt_chans;
 	__le16 cnt_bits;
-	__u8   pwm_chans;
+	__u8 pwm_chans;
 	__le16 pwm_bits;
 };
 
@@ -253,8 +253,7 @@ static void vmk80xx_tx_callback(struct u
 	dbgvm("vmk80xx: %s\n", __func__);
 
 	if (stat && !(stat == -ENOENT
-		 ||   stat == -ECONNRESET
-		 ||   stat == -ESHUTDOWN))
+		      || stat == -ECONNRESET || stat == -ESHUTDOWN))
 		dbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",
 		      __func__, stat);
 
@@ -319,10 +318,8 @@ static int vmk80xx_check_data_link(struc
 	/* Check that IC6 (PIC16F871) is powered and
 	 * running and the data link between IC3 and
 	 * IC6 is working properly */
-	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL,
-		     dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, rx, 2, NULL,
-		     HZ * 10);
+	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);
+	usb_bulk_msg(dev->udev, rx_pipe, rx, 2, NULL, HZ * 10);
 
 	return (int)rx[1];
 }
@@ -342,16 +339,14 @@ static void vmk80xx_read_eeprom(struct v
 
 	/* Read the firmware version info of IC3 and
 	 * IC6 from the internal EEPROM of the IC */
-	usb_bulk_msg(dev->udev, tx_pipe, tx,  1, NULL,
-		     dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, rx, 64, &cnt,
-		     HZ * 10);
+	usb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);
+	usb_bulk_msg(dev->udev, rx_pipe, rx, 64, &cnt, HZ * 10);
 
 	rx[cnt] = '\0';
 
 	if (flag & IC3_VERSION)
-		strncpy(dev->fw.ic3_vers, rx +  1, 24);
-	else /* IC6_VERSION */
+		strncpy(dev->fw.ic3_vers, rx + 1, 24);
+	else			/* IC6_VERSION */
 		strncpy(dev->fw.ic6_vers, rx + 25, 24);
 }
 
@@ -397,7 +392,7 @@ static void vmk80xx_build_int_urb(struct
 	unsigned int pipe;
 	unsigned char *buf;
 	size_t size;
-	void (*callback)(struct urb *);
+	void (*callback) (struct urb *);
 	int ival;
 
 	dbgvm("vmk80xx: %s\n", __func__);
@@ -409,7 +404,7 @@ static void vmk80xx_build_int_urb(struct
 		size = le16_to_cpu(dev->ep_rx->wMaxPacketSize);
 		callback = vmk80xx_rx_callback;
 		ival = dev->ep_rx->bInterval;
-	} else { /* URB_SND_FLAG */
+	} else {		/* URB_SND_FLAG */
 		tx_addr = dev->ep_tx->bEndpointAddress;
 		pipe = usb_sndintpipe(dev->udev, tx_addr);
 		buf = dev->usb_tx_buf;
@@ -418,8 +413,7 @@ static void vmk80xx_build_int_urb(struct
 		ival = dev->ep_tx->bInterval;
 	}
 
-	usb_fill_int_urb(urb, dev->udev, pipe, buf,
-			 size, callback, dev, ival);
+	usb_fill_int_urb(urb, dev->udev, pipe, buf, size, callback, dev, ival);
 }
 
 static void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)
@@ -444,8 +438,7 @@ static void vmk80xx_do_bulk_msg(struct v
 
 	usb_bulk_msg(dev->udev, tx_pipe, dev->usb_tx_buf,
 		     size, NULL, dev->ep_tx->bInterval);
-	usb_bulk_msg(dev->udev, rx_pipe, dev->usb_rx_buf,
-		     size, NULL, HZ * 10);
+	usb_bulk_msg(dev->udev, rx_pipe, dev->usb_rx_buf, size, NULL, HZ * 10);
 
 	clear_bit(TRANS_OUT_BUSY, &dev->flags);
 	clear_bit(TRANS_IN_BUSY, &dev->flags);
@@ -464,7 +457,8 @@ static int vmk80xx_read_packet(struct vm
 	/* Only useful for interrupt transfers */
 	if (test_bit(TRANS_IN_BUSY, &dev->flags))
 		if (wait_event_interruptible(dev->read_wait,
-			!test_bit(TRANS_IN_BUSY, &dev->flags)))
+					     !test_bit(TRANS_IN_BUSY,
+						       &dev->flags)))
 			return -ERESTART;
 
 	if (dev->board.model == VMK8061_MODEL) {
@@ -510,7 +504,8 @@ static int vmk80xx_write_packet(struct v
 
 	if (test_bit(TRANS_OUT_BUSY, &dev->flags))
 		if (wait_event_interruptible(dev->write_wait,
-			!test_bit(TRANS_OUT_BUSY, &dev->flags)))
+					     !test_bit(TRANS_OUT_BUSY,
+						       &dev->flags)))
 			return -ERESTART;
 
 	if (dev->board.model == VMK8061_MODEL) {
@@ -607,7 +602,7 @@ static int vmk80xx_ai_rinsn(struct comed
 
 		/* VMK8061_MODEL */
 		data[n] = dev->usb_rx_buf[reg[0]] + 256 *
-			  dev->usb_rx_buf[reg[1]];
+		    dev->usb_rx_buf[reg[1]];
 	}
 
 	up(&dev->limit_sem);
@@ -638,7 +633,7 @@ static int vmk80xx_ao_winsn(struct comed
 		else
 			reg = VMK8055_AO2_REG;
 		break;
-	default: /* NOTE: avoid compiler warnings */
+	default:		/* NOTE: avoid compiler warnings */
 		cmd = VMK8061_CMD_SET_AO;
 		reg = VMK8061_AO_REG;
 		dev->usb_tx_buf[VMK8061_CH_REG] = chan;
@@ -680,7 +675,7 @@ static int vmk80xx_ao_rinsn(struct comed
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		data[n] = dev->usb_rx_buf[reg+chan];
+		data[n] = dev->usb_rx_buf[reg + chan];
 	}
 
 	up(&dev->limit_sem);
@@ -855,8 +850,8 @@ static int vmk80xx_cnt_rinsn(struct come
 		}
 
 		/* VMK8061_MODEL */
-		data[n] = dev->usb_rx_buf[reg[0]*(chan+1)+1]
-		  + 256 * dev->usb_rx_buf[reg[1]*2+2];
+		data[n] = dev->usb_rx_buf[reg[0] * (chan + 1) + 1]
+		    + 256 * dev->usb_rx_buf[reg[1] * 2 + 2];
 	}
 
 	up(&dev->limit_sem);
@@ -941,7 +936,7 @@ static int vmk80xx_cnt_winsn(struct come
 		if (((val + 1) * val) < debtime * 1000 / 115)
 			val += 1;
 
-		dev->usb_tx_buf[6+chan] = val;
+		dev->usb_tx_buf[6 + chan] = val;
 
 		if (vmk80xx_write_packet(dev, cmd))
 			break;
@@ -975,8 +970,7 @@ static int vmk80xx_pwm_rinsn(struct come
 		if (vmk80xx_read_packet(dev))
 			break;
 
-		data[n] = dev->usb_rx_buf[reg[0]] + 4 *
-			  dev->usb_rx_buf[reg[1]];
+		data[n] = dev->usb_rx_buf[reg[0]] + 4 * dev->usb_rx_buf[reg[1]];
 	}
 
 	up(&dev->limit_sem);
@@ -1309,8 +1303,7 @@ vmk80xx_probe(struct usb_interface *intf
 
 	if (dev->board.model == VMK8061_MODEL) {
 		vmk80xx_read_eeprom(dev, IC3_VERSION);
-		printk(KERN_INFO "comedi#: vmk80xx: %s\n",
-		       dev->fw.ic3_vers);
+		printk(KERN_INFO "comedi#: vmk80xx: %s\n", dev->fw.ic3_vers);
 
 		if (vmk80xx_check_data_link(dev)) {
 			vmk80xx_read_eeprom(dev, IC6_VERSION);
@@ -1368,17 +1361,17 @@ static void vmk80xx_disconnect(struct us
 /* TODO: Add support for suspend, resume, pre_reset,
  * post_reset and flush */
 static struct usb_driver vmk80xx_driver = {
-	.name       = "vmk80xx",
-	.probe      = vmk80xx_probe,
+	.name = "vmk80xx",
+	.probe = vmk80xx_probe,
 	.disconnect = vmk80xx_disconnect,
-	.id_table   = vmk80xx_id_table
+	.id_table = vmk80xx_id_table
 };
 
 static struct comedi_driver driver_vmk80xx = {
-	.module      = THIS_MODULE,
+	.module = THIS_MODULE,
 	.driver_name = "vmk80xx",
-	.attach      = vmk80xx_attach,
-	.detach      = vmk80xx_detach
+	.attach = vmk80xx_attach,
+	.detach = vmk80xx_detach
 };
 
 static int __init vmk80xx_init(void)
--- a/drivers/staging/comedi/kcomedilib/data.c
+++ b/drivers/staging/comedi/kcomedilib/data.c
@@ -29,7 +29,7 @@
 #include <linux/delay.h>
 
 int comedi_data_write(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int range, unsigned int aref, unsigned int data)
+		      unsigned int range, unsigned int aref, unsigned int data)
 {
 	struct comedi_insn insn;
 
@@ -44,7 +44,7 @@ int comedi_data_write(void *dev, unsigne
 }
 
 int comedi_data_read(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int range, unsigned int aref, unsigned int *data)
+		     unsigned int range, unsigned int aref, unsigned int *data)
 {
 	struct comedi_insn insn;
 
@@ -59,7 +59,8 @@ int comedi_data_read(void *dev, unsigned
 }
 
 int comedi_data_read_hint(void *dev, unsigned int subdev,
-	unsigned int chan, unsigned int range, unsigned int aref)
+			  unsigned int chan, unsigned int range,
+			  unsigned int aref)
 {
 	struct comedi_insn insn;
 	unsigned int dummy_data;
@@ -75,8 +76,9 @@ int comedi_data_read_hint(void *dev, uns
 }
 
 int comedi_data_read_delayed(void *dev, unsigned int subdev,
-	unsigned int chan, unsigned int range, unsigned int aref,
-	unsigned int *data, unsigned int nano_sec)
+			     unsigned int chan, unsigned int range,
+			     unsigned int aref, unsigned int *data,
+			     unsigned int nano_sec)
 {
 	int retval;
 
--- a/drivers/staging/comedi/kcomedilib/dio.c
+++ b/drivers/staging/comedi/kcomedilib/dio.c
@@ -27,7 +27,7 @@
 #include <linux/string.h>
 
 int comedi_dio_config(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int io)
+		      unsigned int io)
 {
 	struct comedi_insn insn;
 
@@ -42,7 +42,7 @@ int comedi_dio_config(void *dev, unsigne
 }
 
 int comedi_dio_read(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int *val)
+		    unsigned int *val)
 {
 	struct comedi_insn insn;
 
@@ -57,7 +57,7 @@ int comedi_dio_read(void *dev, unsigned 
 }
 
 int comedi_dio_write(void *dev, unsigned int subdev, unsigned int chan,
-	unsigned int val)
+		     unsigned int val)
 {
 	struct comedi_insn insn;
 
@@ -72,7 +72,7 @@ int comedi_dio_write(void *dev, unsigned
 }
 
 int comedi_dio_bitfield(void *dev, unsigned int subdev, unsigned int mask,
-	unsigned int *bits)
+			unsigned int *bits)
 {
 	struct comedi_insn insn;
 	unsigned int data[2];
--- a/drivers/staging/comedi/kcomedilib/get.c
+++ b/drivers/staging/comedi/kcomedilib/get.c
@@ -28,7 +28,7 @@
 
 int comedi_get_n_subdevices(void *d)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	return dev->n_subdevices;
 }
@@ -38,23 +38,23 @@ int comedi_get_version_code(void *d)
 	return COMEDI_VERSION_CODE;
 }
 
-const char *comedi_get_driver_name(void * d)
+const char *comedi_get_driver_name(void *d)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	return dev->driver->driver_name;
 }
 
-const char *comedi_get_board_name(void * d)
+const char *comedi_get_board_name(void *d)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	return dev->board_name;
 }
 
 int comedi_get_subdevice_type(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 
 	return s->type;
@@ -62,7 +62,7 @@ int comedi_get_subdevice_type(void *d, u
 
 unsigned int comedi_get_subdevice_flags(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 
 	return s->subdev_flags;
@@ -70,7 +70,7 @@ unsigned int comedi_get_subdevice_flags(
 
 int comedi_find_subdevice_by_type(void *d, int type, unsigned int subd)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	if (subd > dev->n_subdevices)
 		return -ENODEV;
@@ -84,7 +84,7 @@ int comedi_find_subdevice_by_type(void *
 
 int comedi_get_n_channels(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 
 	return s->n_chan;
@@ -92,16 +92,16 @@ int comedi_get_n_channels(void *d, unsig
 
 int comedi_get_len_chanlist(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 
 	return s->len_chanlist;
 }
 
 unsigned int comedi_get_maxdata(void *d, unsigned int subdevice,
-	unsigned int chan)
+				unsigned int chan)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 
 	if (s->maxdata_list)
@@ -111,10 +111,9 @@ unsigned int comedi_get_maxdata(void *d,
 }
 
 #ifdef KCOMEDILIB_DEPRECATED
-int comedi_get_rangetype(void *d, unsigned int subdevice,
-	unsigned int chan)
+int comedi_get_rangetype(void *d, unsigned int subdevice, unsigned int chan)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	int ret;
 
@@ -132,7 +131,7 @@ int comedi_get_rangetype(void *d, unsign
 
 int comedi_get_n_ranges(void *d, unsigned int subdevice, unsigned int chan)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	int ret;
 
@@ -149,9 +148,9 @@ int comedi_get_n_ranges(void *d, unsigne
  * ALPHA (non-portable)
 */
 int comedi_get_krange(void *d, unsigned int subdevice, unsigned int chan,
-	unsigned int range, struct comedi_krange *krange)
+		      unsigned int range, struct comedi_krange *krange)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	const struct comedi_lrange *lr;
 
@@ -173,7 +172,7 @@ int comedi_get_krange(void *d, unsigned 
 */
 unsigned int comedi_get_buf_head_pos(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	struct comedi_async *async;
 
@@ -186,7 +185,7 @@ unsigned int comedi_get_buf_head_pos(voi
 
 int comedi_get_buffer_contents(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	struct comedi_async *async;
 	unsigned int num_bytes;
@@ -204,9 +203,9 @@ int comedi_get_buffer_contents(void *d, 
  * ALPHA
 */
 int comedi_set_user_int_count(void *d, unsigned int subdevice,
-	unsigned int buf_user_count)
+			      unsigned int buf_user_count)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	struct comedi_async *async;
 	int num_bytes;
@@ -225,9 +224,9 @@ int comedi_set_user_int_count(void *d, u
 }
 
 int comedi_mark_buffer_read(void *d, unsigned int subdevice,
-	unsigned int num_bytes)
+			    unsigned int num_bytes)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	struct comedi_async *async;
 
@@ -244,9 +243,9 @@ int comedi_mark_buffer_read(void *d, uns
 }
 
 int comedi_mark_buffer_written(void *d, unsigned int subdevice,
-	unsigned int num_bytes)
+			       unsigned int num_bytes)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	struct comedi_async *async;
 	int bytes_written;
@@ -265,7 +264,7 @@ int comedi_mark_buffer_written(void *d, 
 
 int comedi_get_buffer_size(void *d, unsigned int subdev)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdev;
 	struct comedi_async *async;
 
@@ -280,7 +279,7 @@ int comedi_get_buffer_size(void *d, unsi
 
 int comedi_get_buffer_offset(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices + subdevice;
 	struct comedi_async *async;
 
--- a/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
+++ b/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
@@ -67,7 +67,7 @@ void *comedi_open(const char *filename)
 	if (!try_module_get(dev->driver->module))
 		return NULL;
 
-	return (void *) dev;
+	return (void *)dev;
 }
 
 void *comedi_open_old(unsigned int minor)
@@ -86,12 +86,12 @@ void *comedi_open_old(unsigned int minor
 	if (dev == NULL || !dev->attached)
 		return NULL;
 
-	return (void *) dev;
+	return (void *)dev;
 }
 
 int comedi_close(void *d)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	module_put(dev->driver->module);
 
@@ -115,7 +115,7 @@ char *comedi_strerror(int err)
 
 int comedi_fileno(void *d)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	/* return something random */
 	return dev->minor;
@@ -123,7 +123,7 @@ int comedi_fileno(void *d)
 
 int comedi_command(void *d, struct comedi_cmd *cmd)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 	unsigned runflags;
@@ -159,7 +159,7 @@ int comedi_command(void *d, struct comed
 
 int comedi_command_test(void *d, struct comedi_cmd *cmd)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 
 	if (cmd->subdev >= dev->n_subdevices)
@@ -181,7 +181,7 @@ int comedi_command_test(void *d, struct 
  */
 int comedi_do_insn(void *d, struct comedi_insn *insn)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 	int ret = 0;
 
@@ -214,7 +214,7 @@ int comedi_do_insn(void *d, struct comed
 			}
 			if (insn->subdev >= dev->n_subdevices) {
 				printk("%d not usable subdevice\n",
-					insn->subdev);
+				       insn->subdev);
 				ret = -EINVAL;
 				break;
 			}
@@ -296,7 +296,7 @@ int comedi_do_insn(void *d, struct comed
 		goto error;
 	}
 #endif
-      error:
+error:
 
 	return ret;
 }
@@ -322,7 +322,7 @@ int comedi_do_insn(void *d, struct comed
 */
 int comedi_lock(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 	unsigned long flags;
 	int ret = 0;
@@ -365,7 +365,7 @@ int comedi_lock(void *d, unsigned int su
 */
 int comedi_unlock(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 	unsigned long flags;
 	struct comedi_async *async;
@@ -417,7 +417,7 @@ int comedi_unlock(void *d, unsigned int 
 */
 int comedi_cancel(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 	int ret = 0;
 
@@ -456,9 +456,10 @@ int comedi_cancel(void *d, unsigned int 
    registration of callback functions
  */
 int comedi_register_callback(void *d, unsigned int subdevice,
-	unsigned int mask, int (*cb) (unsigned int, void *), void *arg)
+			     unsigned int mask, int (*cb) (unsigned int,
+							   void *), void *arg)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 	struct comedi_async *async;
 
@@ -494,7 +495,7 @@ int comedi_register_callback(void *d, un
 
 int comedi_poll(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->subdevices;
 	struct comedi_async *async;
 
@@ -521,7 +522,7 @@ int comedi_poll(void *d, unsigned int su
 /* WARNING: not portable */
 int comedi_map(void *d, unsigned int subdevice, void *ptr)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 
 	if (subdevice >= dev->n_subdevices)
@@ -543,7 +544,7 @@ int comedi_map(void *d, unsigned int sub
 /* WARNING: not portable */
 int comedi_unmap(void *d, unsigned int subdevice)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s;
 
 	if (subdevice >= dev->n_subdevices)
--- a/drivers/staging/comedi/proc.c
+++ b/drivers/staging/comedi/proc.c
@@ -34,12 +34,12 @@
 /* #include <linux/string.h> */
 
 int comedi_read_procmem(char *buf, char **start, off_t offset, int len,
-	int *eof, void *data);
+			int *eof, void *data);
 
 extern struct comedi_driver *comedi_drivers;
 
 int comedi_read_procmem(char *buf, char **start, off_t offset, int len,
-	int *eof, void *data)
+			int *eof, void *data)
 {
 	int i;
 	int devices_q = 0;
@@ -47,12 +47,13 @@ int comedi_read_procmem(char *buf, char 
 	struct comedi_driver *driv;
 
 	l += sprintf(buf + l,
-		"comedi version " COMEDI_RELEASE "\n"
-		"format string: %s\n",
-		"\"%2d: %-20s %-20s %4d\",i,driver_name,board_name,n_subdevices");
+		     "comedi version " COMEDI_RELEASE "\n"
+		     "format string: %s\n",
+		     "\"%2d: %-20s %-20s %4d\",i,driver_name,board_name,n_subdevices");
 
 	for (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {
-		struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(i);
+		struct comedi_device_file_info *dev_file_info =
+		    comedi_get_device_file_info(i);
 		struct comedi_device *dev;
 
 		if (dev_file_info == NULL)
@@ -62,9 +63,9 @@ int comedi_read_procmem(char *buf, char 
 		if (dev->attached) {
 			devices_q = 1;
 			l += sprintf(buf + l, "%2d: %-20s %-20s %4d\n",
-				i,
-				dev->driver->driver_name,
-				dev->board_name, dev->n_subdevices);
+				     i,
+				     dev->driver->driver_name,
+				     dev->board_name, dev->n_subdevices);
 		}
 	}
 	if (!devices_q)
@@ -74,8 +75,8 @@ int comedi_read_procmem(char *buf, char 
 		l += sprintf(buf + l, "%s:\n", driv->driver_name);
 		for (i = 0; i < driv->num_names; i++) {
 			l += sprintf(buf + l, " %s\n",
-				*(char **)((char *)driv->board_name +
-					i * driv->offset));
+				     *(char **)((char *)driv->board_name +
+						i * driv->offset));
 		}
 		if (!driv->num_names)
 			l += sprintf(buf + l, " %s\n", driv->driver_name);
--- a/drivers/staging/comedi/range.c
+++ b/drivers/staging/comedi/range.c
@@ -78,7 +78,7 @@ int do_rangeinfo_ioctl(struct comedi_dev
 	}
 
 	if (copy_to_user(it.range_ptr, lr->range,
-			sizeof(struct comedi_krange) * lr->length))
+			 sizeof(struct comedi_krange) * lr->length))
 		return -EFAULT;
 
 	return 0;
@@ -128,11 +128,12 @@ int check_chanlist(struct comedi_subdevi
 	if (s->range_table) {
 		for (i = 0; i < n; i++)
 			if (CR_CHAN(chanlist[i]) >= s->n_chan ||
-				CR_RANGE(chanlist[i]) >= s->range_table->length
-				|| aref_invalid(s, chanlist[i])) {
-				printk("bad chanlist[%d]=0x%08x n_chan=%d range length=%d\n",
-					i, chanlist[i], s->n_chan,
-					s->range_table->length);
+			    CR_RANGE(chanlist[i]) >= s->range_table->length
+			    || aref_invalid(s, chanlist[i])) {
+				printk
+				    ("bad chanlist[%d]=0x%08x n_chan=%d range length=%d\n",
+				     i, chanlist[i], s->n_chan,
+				     s->range_table->length);
 #if 0
 				for (i = 0; i < n; i++)
 					printk("[%d]=0x%08x\n", i, chanlist[i]);
@@ -143,11 +144,11 @@ int check_chanlist(struct comedi_subdevi
 		for (i = 0; i < n; i++) {
 			chan = CR_CHAN(chanlist[i]);
 			if (chan >= s->n_chan ||
-				CR_RANGE(chanlist[i]) >=
-				s->range_table_list[chan]->length
-				|| aref_invalid(s, chanlist[i])) {
+			    CR_RANGE(chanlist[i]) >=
+			    s->range_table_list[chan]->length
+			    || aref_invalid(s, chanlist[i])) {
 				printk("bad chanlist[%d]=0x%08x\n", i,
-					chanlist[i]);
+				       chanlist[i]);
 				return -EINVAL;
 			}
 		}
