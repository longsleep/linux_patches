From 77a21ee35930507edd014a97365a3bfadb14d607 Mon Sep 17 00:00:00 2001
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Sun, 26 Apr 2009 16:06:14 +0200
Subject: [PATCH 089/102] Staging: rt2870: remove dead code

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2870/ap.h                    |   12 
 drivers/staging/rt2870/chlist.h                |   43 -
 drivers/staging/rt2870/common/2870_rtmp_init.c |   22 
 drivers/staging/rt2870/common/action.c         |   10 
 drivers/staging/rt2870/common/ba_action.c      |   46 -
 drivers/staging/rt2870/common/cmm_data.c       |  113 ----
 drivers/staging/rt2870/common/cmm_info.c       |  322 -----------
 drivers/staging/rt2870/common/cmm_sanity.c     |   31 -
 drivers/staging/rt2870/common/cmm_wpa.c        |   10 
 drivers/staging/rt2870/common/dfs.c            |   12 
 drivers/staging/rt2870/common/eeprom.c         |   10 
 drivers/staging/rt2870/common/mlme.c           |  113 ----
 drivers/staging/rt2870/common/rtmp_init.c      |  195 -------
 drivers/staging/rt2870/common/rtmp_tkip.c      |    3 
 drivers/staging/rt2870/common/rtmp_wep.c       |    9 
 drivers/staging/rt2870/common/rtusb_bulk.c     |  684 -------------------------
 drivers/staging/rt2870/common/rtusb_data.c     |   13 
 drivers/staging/rt2870/common/rtusb_io.c       |   31 -
 drivers/staging/rt2870/mlme.h                  |   24 
 drivers/staging/rt2870/oid.h                   |   23 
 drivers/staging/rt2870/rt2870.h                |   39 -
 drivers/staging/rt2870/rt28xx.h                |   46 -
 drivers/staging/rt2870/rt_linux.c              |   40 -
 drivers/staging/rt2870/rt_linux.h              |   32 -
 drivers/staging/rt2870/rt_main_dev.c           |  132 ----
 drivers/staging/rt2870/rt_profile.c            |   42 -
 drivers/staging/rt2870/rtmp.h                  |  138 -----
 drivers/staging/rt2870/rtmp_def.h              |   18 
 drivers/staging/rt2870/sta/connect.c           |   10 
 drivers/staging/rt2870/sta/rtmp_data.c         |    4 
 drivers/staging/rt2870/sta/sync.c              |    1 
 drivers/staging/rt2870/sta/wpa.c               |   13 
 drivers/staging/rt2870/sta_ioctl.c             |   19 
 33 files changed, 11 insertions(+), 2249 deletions(-)

--- a/drivers/staging/rt2870/ap.h
+++ b/drivers/staging/rt2870/ap.h
@@ -163,18 +163,6 @@ USHORT APBuildAssociation(
 	IN UCHAR		 HtCapabilityLen,
     OUT USHORT *pAid);
 
-/*
-VOID	RTMPAddClientSec(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR	BssIdx,
-	IN UCHAR		 KeyIdx,
-	IN UCHAR		 CipherAlg,
-	IN PUCHAR		 pKey,
-	IN PUCHAR		 pTxMic,
-	IN PUCHAR		 pRxMic,
-	IN MAC_TABLE_ENTRY *pEntry);
-*/
-
 // ap_auth.c
 
 void APAuthStateMachineInit(
--- a/drivers/staging/rt2870/chlist.h
+++ b/drivers/staging/rt2870/chlist.h
@@ -1195,49 +1195,6 @@ static inline VOID N_ChannelCheck(
 				pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
 				//pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_NONE;	// We didn't set the ExtCh as NONE due to it'll set in RTMPSetHT()
 			}
-#if 0
-			switch (pAd->CommonCfg.CountryRegion  & 0x7f)
-			{
-				case REGION_0_BG_BAND:	// 1 -11
-				case REGION_1_BG_BAND:	// 1 - 13
-				case REGION_5_BG_BAND:	// 1 - 14
-					if (Channel <= 4)
-					{
-						pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_ABOVE;
-					}
-					else if (Channel >= 8)
-					{
-						if ((ChannelNum - Channel) < 4)
-							pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_BELOW;
-					}
-					break;
-
-				case REGION_2_BG_BAND:	// 10 - 11
-				case REGION_3_BG_BAND:	// 10 - 13
-				case REGION_4_BG_BAND:	// 14
-					pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
-					break;
-
-				case REGION_6_BG_BAND:	// 3 - 9
-					if (Channel <= 5)
-						pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_ABOVE;
-					else if (Channel == 6)
-						pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
-					else if (Channel >= 7)
-						pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_BELOW;
-					break;
-
-				case REGION_7_BG_BAND:  // 5 - 13
-					if (Channel <= 8)
-						pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_ABOVE;
-					else if (Channel >= 10)
-						pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_BELOW;
-					break;
-
-				default:	// Error. should never happen
-					break;
-			}
-#endif
 		}
 	}
 
--- a/drivers/staging/rt2870/common/2870_rtmp_init.c
+++ b/drivers/staging/rt2870/common/2870_rtmp_init.c
@@ -266,27 +266,6 @@ NDIS_STATUS	NICInitTransmit(
 		//
 		// MGMT_RING_SIZE
 		//
-#if 0
-		for(i=0; i<MGMT_RING_SIZE; i++) // 8
-		{
-			PTX_CONTEXT	pMLMEContext = &(pAd->MLMEContext[i]);
-
-
-			NdisZeroMemory(pMLMEContext, sizeof(TX_CONTEXT));
-
-			//Allocate URB
-			LM_USB_ALLOC(pObj, pMLMEContext, PTX_BUFFER, sizeof(TX_BUFFER), Status,
-							("<-- ERROR in Alloc TX MLMEContext[%d] urb!! \n", i),
-							out2,
-							("<-- ERROR in Alloc TX MLMEContext[%d] TX_BUFFER !! \n", i),
-							out2);
-
-			pMLMEContext->pAd = pAd;
-			pMLMEContext->pIrp = NULL;
-			pMLMEContext->InUse = FALSE;
-			pMLMEContext->IRPPending = FALSE;
-		}
-#else
 		// Allocate MGMT ring descriptor's memory
 		pAd->MgmtDescRing.AllocSize = MGMT_RING_SIZE * sizeof(TX_CONTEXT);
 		RTMPAllocateMemory(&pAd->MgmtDescRing.AllocVa, pAd->MgmtDescRing.AllocSize);
@@ -336,7 +315,6 @@ NDIS_STATUS	NICInitTransmit(
 		pAd->MgmtRing.TxSwFreeIdx = MGMT_RING_SIZE;
 		pAd->MgmtRing.TxCpuIdx = 0;
 		pAd->MgmtRing.TxDmaIdx = 0;
-#endif
 
 		//
 		// BEACON_RING_SIZE
--- a/drivers/staging/rt2870/common/action.c
+++ b/drivers/staging/rt2870/common/action.c
@@ -466,11 +466,6 @@ VOID ORIBATimerTimeout(
 {
 	MAC_TABLE_ENTRY	*pEntry;
 	INT			i, total;
-//	FRAME_BAR			FrameBar;
-//	ULONG			FrameLen;
-//	NDIS_STATUS 	NStatus;
-//	PUCHAR			pOutBuffer = NULL;
-//	USHORT			Sequence;
 	UCHAR			TID;
 
 	total = pAd->MacTab.Size * NUM_OF_TID;
@@ -535,10 +530,9 @@ VOID SendRefreshBAR(
 			MakeOutgoingFrame(pOutBuffer,				&FrameLen,
 							  sizeof(FRAME_BAR),	  &FrameBar,
 							  END_OF_ARGS);
-			//if (!(CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET)))
+
 			if (1)	// Now we always send BAR.
 			{
-				//MiniportMMRequestUnlock(pAd, 0, pOutBuffer, FrameLen);
 				MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 			}
 			MlmeFreeMemory(pAd, pOutBuffer);
@@ -568,8 +562,6 @@ VOID BarHeaderInit(
 	IN PUCHAR pDA,
 	IN PUCHAR pSA)
 {
-//	USHORT	Duration;
-
 	NdisZeroMemory(pCntlBar, sizeof(FRAME_BAR));
 	pCntlBar->FC.Type = BTYPE_CNTL;
 	pCntlBar->FC.SubType = SUBTYPE_BLOCK_ACK_REQ;
--- a/drivers/staging/rt2870/common/ba_action.c
+++ b/drivers/staging/rt2870/common/ba_action.c
@@ -462,19 +462,6 @@ void ba_flush_reordering_timeout_mpdus(
     		}
 
 	}
-#if 0
-	else if (
-			 (RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(MAX_REORDERING_PACKET_TIMEOUT))) &&
-			  (pBAEntry->list.qlen > 1))
-			)
-		{
-		DBGPRINT(RT_DEBUG_TRACE,("timeout[%d] (%lx-%lx = %d > %d): %x\n ", pBAEntry->list.qlen, Now32, (pBAEntry->LastIndSeqAtTimer),
-			   (int)((long) Now32 - (long)(pBAEntry->LastIndSeqAtTimer)), MAX_REORDERING_PACKET_TIMEOUT,
-			   pBAEntry->LastIndSeq));
-		ba_refresh_reordering_mpdus(pAd, pBAEntry);
-			pBAEntry->LastIndSeqAtTimer = Now32;
-				}
-#endif
 }
 
 
@@ -688,10 +675,6 @@ BOOLEAN BARecSessionAdd(
 			RTMPInitTimer(pAd, &pBAEntry->RECBATimer, GET_TIMER_FUNCTION(BARecSessionIdleTimeout), pBAEntry, TRUE);
 		}
 
-#if 0	// for debugging
-		RTMPSetTimer(&pBAEntry->RECBATimer, REC_BA_SESSION_IDLE_TIMEOUT);
-#endif
-
 		// Set Bitmap flag.
 		pEntry->RXBAbitmap |= (1<<TID);
 		pEntry->BARecWcidArray[TID] = Idx;
@@ -1552,13 +1535,9 @@ static VOID ba_enqueue_reordering_packet
 	}
 	else
 	{
-#if 0
-		DBGPRINT(RT_DEBUG_ERROR,  ("!!! (%d:%d) Can't allocate reordering mpdu blk\n",
-								   blk_count, pBAEntry->list.qlen));
-#else
 		DBGPRINT(RT_DEBUG_ERROR,  ("!!! (%d) Can't allocate reordering mpdu blk\n",
 								   pBAEntry->list.qlen));
-#endif
+
 		/*
 		 * flush all pending reordering mpdus
 		 * and receving mpdu to upper layer
@@ -1606,29 +1585,11 @@ VOID Indicate_AMPDU_Packet(
 
 	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU) &&  (pRxBlk->DataSize > MAX_RX_PKT_LEN))
 	{
-#if 0 // sample take off, no use
-		static int err_size;
-
-		err_size++;
-		if (err_size > 20) {
-			 printk("AMPDU DataSize = %d\n", pRxBlk->DataSize);
-			 hex_dump("802.11 Header", (UCHAR *)pRxBlk->pHeader, 24);
-			 hex_dump("Payload", pRxBlk->pData, 64);
-			 err_size = 0;
-		}
-#endif
 		// release packet
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
 		return;
 	}
 
-
-#if 0 // test
-	/* Rec BA Session had been torn down */
-	INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
-	return;
-#endif
-
 	if (Wcid < MAX_LEN_OF_MAC_TABLE)
 	{
 		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
@@ -1723,10 +1684,6 @@ VOID Indicate_AMPDU_Packet(
 	//
 	else
 	{
-#if 0
-		ba_refresh_reordering_mpdus(pAd, pBAEntry);
-		INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
-#else
 		LONG WinStartSeq, TmpSeq;
 
 
@@ -1748,6 +1705,5 @@ VOID Indicate_AMPDU_Packet(
 		{
 			pBAEntry->LastIndSeq = TmpSeq;
 		}
-#endif
 	}
 }
--- a/drivers/staging/rt2870/common/cmm_data.c
+++ b/drivers/staging/rt2870/common/cmm_data.c
@@ -67,7 +67,6 @@ UCHAR	 RxwiMCSToOfdmRate[12] = {
 char*   MCSToMbps[] = {"1Mbps","2Mbps","5.5Mbps","11Mbps","06Mbps","09Mbps","12Mbps","18Mbps","24Mbps","36Mbps","48Mbps","54Mbps","MM-0","MM-1","MM-2","MM-3","MM-4","MM-5","MM-6","MM-7","MM-8","MM-9","MM-10","MM-11","MM-12","MM-13","MM-14","MM-15","MM-32","ee1","ee2","ee3"};
 
 UCHAR default_cwmin[]={CW_MIN_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1, CW_MIN_IN_BITS-2};
-//UCHAR default_cwmax[]={CW_MAX_IN_BITS, CW_MAX_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1};
 UCHAR default_sta_aifsn[]={3,7,2,2};
 
 UCHAR MapUserPriorityToAccessCategory[8] = {QID_AC_BE, QID_AC_BK, QID_AC_BK, QID_AC_BE, QID_AC_VI, QID_AC_VI, QID_AC_VO, QID_AC_VO};
@@ -233,17 +232,11 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
-	// Make sure MGMT ring resource won't be used by other threads
-// sample, for IRQ LOCK -> SEM LOCK
-//	IrqState = pAd->irq_disabled;
-//	if (!IrqState)
 		RTMP_SEM_LOCK(&pAd->MgmtRingLock);
 
 
 	if (pSrcBufVA == NULL)
 	{
-		// The buffer shouldn't be NULL
-//		if (!IrqState)
 			RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 		return NDIS_STATUS_FAILURE;
 	}
@@ -318,9 +311,6 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	}
 	else // BTYPE_MGMT or BTYPE_DATA(must be NULL frame)
 	{
-		//pAd->Sequence++;
-		//pHeader_802_11->Sequence = pAd->Sequence;
-
 		if (pHeader_802_11->Addr1[0] & 0x01) // MULTICAST, BROADCAST
 		{
 			bAckRequired = FALSE;
@@ -348,8 +338,7 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 		&& (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
 	{
 		DBGPRINT(RT_DEBUG_ERROR,("MlmeHardTransmit --> radar detect not in normal mode !!!\n"));
-//		if (!IrqState)
-			RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
+		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 		return (NDIS_STATUS_FAILURE);
 	}
 
@@ -362,7 +351,6 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	// Initialize TX Descriptor
 	// For inter-frame gap, the number is for this frame and next frame
 	// For MLME rate, we will fix as 2Mb to match other vendor's implement
-//	pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
 
 // management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not.
 	if (pMacEntry == NULL)
@@ -384,8 +372,7 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	HAL_KickOutMgmtTx(pAd, QueIdx, pPacket, pSrcBufVA, SrcBufLen);
 
 	// Make sure to release MGMT ring resource
-//	if (!IrqState)
-		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
+	RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 	return NDIS_STATUS_SUCCESS;
 }
 
@@ -408,51 +395,6 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 					RTMP_IRQ_UNLOCK((lock), IrqFlags);	\
 			}while(0)
 
-
-#if 0
-static VOID dumpTxBlk(TX_BLK *pTxBlk)
-{
-	NDIS_PACKET *pPacket;
-	int i, frameNum;
-	PQUEUE_ENTRY	pQEntry;
-
-	printk("Dump TX_BLK Structure:\n");
-	printk("\tTxFrameType=%d!\n", pTxBlk->TxFrameType);
-	printk("\tTotalFrameLen=%d\n", pTxBlk->TotalFrameLen);
-	printk("\tTotalFrameNum=%ld!\n", pTxBlk->TxPacketList.Number);
-	printk("\tTotalFragNum=%d!\n", pTxBlk->TotalFragNum);
-	printk("\tpPacketList=\n");
-
-	frameNum = pTxBlk->TxPacketList.Number;
-
-	for(i=0; i < frameNum; i++)
-	{	int j;
-		UCHAR	*pBuf;
-
-		pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
-		pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-		if (pPacket)
-		{
-			pBuf = GET_OS_PKT_DATAPTR(pPacket);
-			printk("\t\t[%d]:ptr=0x%x, Len=%d!\n", i, (UINT32)(GET_OS_PKT_DATAPTR(pPacket)), GET_OS_PKT_LEN(pPacket));
-			printk("\t\t");
-			for (j =0 ; j < GET_OS_PKT_LEN(pPacket); j++)
-			{
-				printk("%02x ", (pBuf[j] & 0xff));
-				if (j == 16)
-					break;
-			}
-			InsertTailQueue(&pTxBlk->TxPacketList, PACKET_TO_QUEUE_ENTRY(pPacket));
-		}
-	}
-	printk("\tWcid=%d!\n", pTxBlk->Wcid);
-	printk("\tapidx=%d!\n", pTxBlk->apidx);
-	printk("----EndOfDump\n");
-
-}
-#endif
-
-
 /*
 	========================================================================
 	Tx Path design algorithm:
@@ -813,7 +755,6 @@ VOID RTMPDeQueuePacket(
 
 			pTxBlk = &TxBlk;
 			NdisZeroMemory((PUCHAR)pTxBlk, sizeof(TX_BLK));
-			//InitializeQueueHeader(&pTxBlk->TxPacketList);		// Didn't need it because we already memzero it.
 			pTxBlk->QueIdx = QueIdx;
 
 			pPacket = QUEUE_ENTRY_TO_PKT(pEntry);
@@ -880,14 +821,6 @@ VOID RTMPDeQueuePacket(
 
 			// Do HardTransmit now.
 			Status = STAHardTransmit(pAd, pTxBlk, QueIdx);
-
-#if 0	// We should not break if HardTransmit failed. Well, at least now we should not!
-			if (Status != NDIS_STATUS_SUCCESS)
-			{
-				DBGPRINT(RT_DEBUG_TRACE /*RT_DEBUG_INFO*/,("RTMPHardTransmit return failed!!!\n"));
-				break;
-			}
-#endif
 		}
 
 		RT28XX_STOP_DEQUEUE(pAd, QueIdx, IrqFlags);
@@ -1129,11 +1062,6 @@ VOID RTMPWriteTxWI_Data(
 		BASize = pAd->BATable.BAOriEntry[RABAOriIdx].BAWinSize;
 	}
 
-#if 0 // 3*3
-	if (BASize > 7)
-		BASize = 7;
-#endif
-
 	pTxWI->TxBF = pTransmit->field.TxBF;
 	pTxWI->BAWinSize = BASize;
 	pTxWI->ShortGI = pTransmit->field.ShortGI;
@@ -1187,7 +1115,7 @@ VOID RTMPWriteTxWI_Cache(
 	IN	OUT PTXWI_STRUC		pTxWI,
 	IN	TX_BLK				*pTxBlk)
 {
-	PHTTRANSMIT_SETTING	/*pTxHTPhyMode,*/ pTransmit;
+	PHTTRANSMIT_SETTING	pTransmit;
 	PMAC_TABLE_ENTRY	pMacEntry;
 
 	//
@@ -1288,8 +1216,6 @@ VOID RTMPWriteTxDescriptor(
 
 	pTxD->WIV	= (bWIV) ? 1: 0;
 	pTxD->QSEL= (QueueSEL);
-	//RT2860c??  fixed using EDCA queue for test...  We doubt Queue1 has problem.  2006-09-26 Jan
-	//pTxD->QSEL= FIFO_EDCA;
 	if (pAd->bGenOneHCCA == TRUE)
 		pTxD->QSEL= FIFO_HCCA;
 	pTxD->DMADONE = 0;
@@ -1388,11 +1314,7 @@ PQUEUE_HEADER	RTMPCheckTxSwQueue(
 	IN	PRTMP_ADAPTER	pAd,
 	OUT PUCHAR			pQueIdx)
 {
-
 	ULONG	Number;
-	// 2004-11-15 to be removed. test aggregation only
-//	if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)) && (*pNumber < 2))
-//		 return NULL;
 
 	Number = pAd->TxSwQueue[QID_AC_BK].Number
 			 + pAd->TxSwQueue[QID_AC_BE].Number
@@ -1463,14 +1385,11 @@ VOID	RTMPSuspendMsduTransmission(
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66, &pAd->BbpTuning.R66CurrentValue);
 
 	// set BBP_R66 to 0x30/0x40 when scanning (AsicSwitchChannel will set R66 according to channel when scanning)
-	//RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, (0x26 + GET_LNA_GAIN(pAd)));
 	RTMPSetAGCInitValue(pAd, BW_20);
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-	//RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x000f0000);		// abort all TX rings
 }
 
-
 /*
 	========================================================================
 
@@ -1492,19 +1411,12 @@ VOID	RTMPSuspendMsduTransmission(
 VOID RTMPResumeMsduTransmission(
 	IN	PRTMP_ADAPTER	pAd)
 {
-//    UCHAR			IrqState;
-
 	DBGPRINT(RT_DEBUG_TRACE,("SCAN done, resume MSDU transmission ...\n"));
 
 
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, pAd->BbpTuning.R66CurrentValue);
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-// sample, for IRQ LOCK to SEM LOCK
-//    IrqState = pAd->irq_disabled;
-//	if (IrqState)
-//		RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-//    else
 	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
 }
 
@@ -1533,9 +1445,7 @@ UINT deaggregate_AMSDU_announce(
 
 		nMSDU++;
 
-		//hex_dump("subheader", pData, 64);
 		pAMSDUsubheader = (PHEADER_802_3)pData;
-		//pData += LENGTH_802_3;
 		PayloadSize = pAMSDUsubheader->Octet[1] + (pAMSDUsubheader->Octet[0]<<8);
 		SubFrameSize = PayloadSize + LENGTH_802_3;
 
@@ -1545,8 +1455,6 @@ UINT deaggregate_AMSDU_announce(
 			break;
 		}
 
-		//printk("%d subframe: Size = %d\n",  nMSDU, PayloadSize);
-
 		pPayload = pData + LENGTH_802_3;
 		pDA = pData;
 		pSA = pData + MAC_ADDR_LEN;
@@ -1792,8 +1700,6 @@ BOOLEAN MacTableDeleteEntry(
 	USHORT HashIdx;
 	MAC_TABLE_ENTRY *pEntry, *pPrevEntry, *pProbeEntry;
 	BOOLEAN Cancelled;
-	//USHORT	offset;	// unused variable
-	//UCHAR	j;			// unused variable
 
 	if (wcid >= MAX_LEN_OF_MAC_TABLE)
 		return FALSE;
@@ -1801,7 +1707,6 @@ BOOLEAN MacTableDeleteEntry(
 	NdisAcquireSpinLock(&pAd->MacTabLock);
 
 	HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
-	//pEntry = pAd->MacTab.Hash[HashIdx];
 	pEntry = &pAd->MacTab.Content[wcid];
 
 	if (pEntry && (pEntry->ValidAsCLI || pEntry->ValidAsApCli || pEntry->ValidAsWDS || pEntry->ValidAsMesh
@@ -2209,18 +2114,6 @@ VOID Indicate_Legacy_Packet(
 
 	if (pRxBlk->DataSize > MAX_RX_PKT_LEN)
 	{
-#if 0 // sample take off, for multiple card design
-		static int err_size;
-
-		err_size++;
-		if (err_size > 20)
-		{
-			 printk("Legacy DataSize = %d\n", pRxBlk->DataSize);
-			 hex_dump("802.3 Header", Header802_3, LENGTH_802_3);
-			 hex_dump("Payload", pRxBlk->pData, 64);
-			 err_size = 0;
-		}
-#endif
 
 		// release packet
 		RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
--- a/drivers/staging/rt2870/common/cmm_info.c
+++ b/drivers/staging/rt2870/common/cmm_info.c
@@ -783,9 +783,6 @@ INT	Set_ResetStatCounter_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			arg)
 {
-	//UCHAR           i;
-	//MAC_TABLE_ENTRY *pEntry;
-
 	DBGPRINT(RT_DEBUG_TRACE, ("==>Set_ResetStatCounter_Proc\n"));
 
 	// add the most up-to-date h/w raw counters into software counters
@@ -795,316 +792,9 @@ INT	Set_ResetStatCounter_Proc(
 	NdisZeroMemory(&pAd->Counters8023, sizeof(COUNTER_802_3));
 	NdisZeroMemory(&pAd->RalinkCounters, sizeof(COUNTER_RALINK));
 
-	// Reset HotSpot counter
-#if 0 // ToDo.
-	for (i = 0; i < MAX_LEN_OF_MAC_TABLE; i++)
-	{
-		pEntry = &pAd->MacTab.Content[i];
-
-		if ((pEntry->Valid == FALSE) || (pEntry->Sst != SST_ASSOC))
-			continue;
-
-		pEntry->HSCounter.LastDataPacketTime = 0;
-		pEntry->HSCounter.TotalRxByteCount= 0;
-		pEntry->HSCounter.TotalTxByteCount= 0;
-	}
-#endif
-
-
 	return TRUE;
 }
 
-/*
-	========================================================================
-
-	Routine Description:
-		Add WPA key process.
-		In Adhoc WPANONE, bPairwise = 0;  KeyIdx = 0;
-
-	Arguments:
-		pAd 					Pointer to our adapter
-		pBuf							Pointer to the where the key stored
-
-	Return Value:
-		NDIS_SUCCESS					Add key successfully
-
-	IRQL = DISPATCH_LEVEL
-
-	Note:
-
-	========================================================================
-*/
-#if 0 // remove by AlbertY
-NDIS_STATUS RTMPWPAAddKeyProc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PVOID			pBuf)
-{
-	PNDIS_802_11_KEY	pKey;
-	ULONG				KeyIdx;
-//	NDIS_STATUS 		Status;
-//	ULONG 	offset;	// unused variable, snowpin 2006.07.13
-
-	PUCHAR		pTxMic, pRxMic;
-	BOOLEAN 	bTxKey; 		// Set the key as transmit key
-	BOOLEAN 	bPairwise;		// Indicate the key is pairwise key
-	BOOLEAN 	bKeyRSC;		// indicate the receive  SC set by KeyRSC value.
-								// Otherwise, it will set by the NIC.
-	BOOLEAN 	bAuthenticator; // indicate key is set by authenticator.
-	UCHAR		apidx = BSS0;
-
-	pKey = (PNDIS_802_11_KEY) pBuf;
-	KeyIdx = pKey->KeyIndex & 0xff;
-	// Bit 31 of Add-key, Tx Key
-	bTxKey		   = (pKey->KeyIndex & 0x80000000) ? TRUE : FALSE;
-	// Bit 30 of Add-key PairwiseKey
-	bPairwise	   = (pKey->KeyIndex & 0x40000000) ? TRUE : FALSE;
-	// Bit 29 of Add-key KeyRSC
-	bKeyRSC 	   = (pKey->KeyIndex & 0x20000000) ? TRUE : FALSE;
-	// Bit 28 of Add-key Authenticator
-	bAuthenticator = (pKey->KeyIndex & 0x10000000) ? TRUE : FALSE;
-
-	DBGPRINT(RT_DEBUG_TRACE,("RTMPWPAAddKeyProc==>pKey->KeyIndex = %x. bPairwise= %d\n", pKey->KeyIndex, bPairwise));
-	// 1. Check Group / Pairwise Key
-	if (bPairwise)	// Pairwise Key
-	{
-		// 1. KeyIdx must be 0, otherwise, return NDIS_STATUS_INVALID_DATA
-		if (KeyIdx != 0)
-			return(NDIS_STATUS_INVALID_DATA);
-
-		// 2. Check bTx, it must be true, otherwise, return NDIS_STATUS_INVALID_DATA
-		if (bTxKey == FALSE)
-			return(NDIS_STATUS_INVALID_DATA);
-
-		// 3. If BSSID is all 0xff, return NDIS_STATUS_INVALID_DATA
-		if (MAC_ADDR_EQUAL(pKey->BSSID, BROADCAST_ADDR))
-			return(NDIS_STATUS_INVALID_DATA);
-
-		// 3.1 Check Pairwise key length for TKIP key. For AES, it's always 128 bits
-		//if ((pAdapter->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && (pKey->KeyLength != LEN_TKIP_KEY))
-		if ((pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled) && (pKey->KeyLength != LEN_TKIP_KEY))
-			return(NDIS_STATUS_INVALID_DATA);
-
-		pAd->SharedKey[apidx][KeyIdx].Type = PAIRWISE_KEY;
-
-		if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA2)
-		{
-			// Send media specific event to start PMKID caching
-			RTMPIndicateWPA2Status(pAd);
-		}
-	}
-	else
-	{
-		// 1. Check BSSID, if not current BSSID or Bcast, return NDIS_STATUS_INVALID_DATA
-		if ((! MAC_ADDR_EQUAL(pKey->BSSID, BROADCAST_ADDR)) &&
-			(! MAC_ADDR_EQUAL(pKey->BSSID, pAd->ApCfg.MBSSID[apidx].Bssid)))
-			return(NDIS_STATUS_INVALID_DATA);
-
-		// 2. Check Key index for supported Group Key
-		if (KeyIdx >= GROUP_KEY_NUM)
-			return(NDIS_STATUS_INVALID_DATA);
-
-		// 3. Set as default Tx Key if bTxKey is TRUE
-		if (bTxKey == TRUE)
-			pAd->ApCfg.MBSSID[apidx].DefaultKeyId = (UCHAR) KeyIdx;
-
-		pAd->SharedKey[apidx][KeyIdx].Type = GROUP_KEY;
-	}
-
-	// 4. Select RxMic / TxMic based on Supp / Authenticator
-	if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPANone)
-	{
-		// for WPA-None Tx, Rx MIC is the same
-		pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
-		pRxMic = pTxMic;
-	}
-	else if (bAuthenticator == TRUE)
-	{
-		pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
-		pRxMic = (PUCHAR) (&pKey->KeyMaterial) + 24;
-	}
-	else
-	{
-		pRxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
-		pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 24;
-	}
-
-	// 6. Check RxTsc
-	if (bKeyRSC == TRUE)
-	{
-		NdisMoveMemory(pAd->SharedKey[apidx][KeyIdx].RxTsc, &pKey->KeyRSC, 6);
-		NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].PairwiseKey.RxTsc, &pKey->KeyRSC, 6);
-	}
-	else
-	{
-		NdisZeroMemory(pAd->SharedKey[apidx][KeyIdx].RxTsc, 6);
-	}
-
-	// 7. Copy information into Pairwise Key structure.
-	// pKey->KeyLength will include TxMic and RxMic, therefore, we use 16 bytes hardcoded.
-	pAd->SharedKey[apidx][KeyIdx].KeyLen = (UCHAR) pKey->KeyLength;
-	pAd->MacTab.Content[BSSID_WCID].PairwiseKey.KeyLen = (UCHAR)pKey->KeyLength;
-	NdisMoveMemory(pAd->SharedKey[BSS0][KeyIdx].Key, &pKey->KeyMaterial, 16);
-	NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].PairwiseKey.Key, &pKey->KeyMaterial, 16);
-	if (pKey->KeyLength == LEN_TKIP_KEY)
-	{
-		// Only Key lenth equal to TKIP key have these
-		NdisMoveMemory(pAd->SharedKey[apidx][KeyIdx].RxMic, pRxMic, 8);
-		NdisMoveMemory(pAd->SharedKey[apidx][KeyIdx].TxMic, pTxMic, 8);
-		NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].PairwiseKey.RxMic, pRxMic, 8);
-		NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].PairwiseKey.TxMic, pTxMic, 8);
-	}
-
-	COPY_MAC_ADDR(pAd->SharedKey[BSS0][KeyIdx].BssId, pKey->BSSID);
-
-	// Init TxTsc to one based on WiFi WPA specs
-	pAd->SharedKey[apidx][KeyIdx].TxTsc[0] = 1;
-	pAd->SharedKey[apidx][KeyIdx].TxTsc[1] = 0;
-	pAd->SharedKey[apidx][KeyIdx].TxTsc[2] = 0;
-	pAd->SharedKey[apidx][KeyIdx].TxTsc[3] = 0;
-	pAd->SharedKey[apidx][KeyIdx].TxTsc[4] = 0;
-	pAd->SharedKey[apidx][KeyIdx].TxTsc[5] = 0;
-	// 4. Init TxTsc to one based on WiFi WPA specs
-	pAd->MacTab.Content[BSSID_WCID].PairwiseKey.TxTsc[0] = 1;
-	pAd->MacTab.Content[BSSID_WCID].PairwiseKey.TxTsc[1] = 0;
-	pAd->MacTab.Content[BSSID_WCID].PairwiseKey.TxTsc[2] = 0;
-	pAd->MacTab.Content[BSSID_WCID].PairwiseKey.TxTsc[3] = 0;
-	pAd->MacTab.Content[BSSID_WCID].PairwiseKey.TxTsc[4] = 0;
-	pAd->MacTab.Content[BSSID_WCID].PairwiseKey.TxTsc[5] = 0;
-
-	if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption3Enabled)
-	{
-		pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_AES;
-		pAd->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = CIPHER_AES;
-	}
-	else if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption2Enabled)
-	{
-		pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_TKIP;
-		pAd->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = CIPHER_TKIP;
-	}
-	else if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption1Enabled)
-	{
-		if (pAd->SharedKey[apidx][KeyIdx].KeyLen == 5)
-		{
-			pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_WEP64;
-			pAd->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = CIPHER_WEP64;
-		}
-		else if (pAd->SharedKey[apidx][KeyIdx].KeyLen == 13)
-		{
-			pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_WEP128;
-			pAd->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = CIPHER_WEP128;
-		}
-		else
-		{
-			pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_NONE;
-			pAd->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = CIPHER_NONE;
-		}
-	}
-	else
-	{
-		pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_NONE;
-		pAd->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = CIPHER_NONE;
-	}
-
-	if ((pAd->OpMode == OPMODE_STA))  // Pairwise Key. Add BSSID to WCTable
-	{
-		pAd->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
-		pAd->MacTab.Content[BSSID_WCID].PairwiseKey.KeyLen = pAd->SharedKey[BSS0][KeyIdx].KeyLen;
-	}
-
-	if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA2) ||
-		(pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA2PSK))
-	{
-		//
-		// On WPA2, Update Group Key Cipher.
-		//
-		if (!bPairwise)
-		{
-			if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
-				pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_AES;
-			else if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
-				pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_TKIP;
-		}
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE, ("pAd->SharedKey[%d][%d].CipherAlg = %d\n", apidx, KeyIdx, pAd->SharedKey[apidx][KeyIdx].CipherAlg));
-
-#if 0
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("%s Key #%d", CipherName[pAd->SharedKey[apidx][KeyIdx].CipherAlg],KeyIdx));
-	for (i = 0; i < 16; i++)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("%02x:", pAd->SharedKey[apidx][KeyIdx].Key[i]));
-	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("\n	  Rx MIC Key = "));
-	for (i = 0; i < 8; i++)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("%02x:", pAd->SharedKey[apidx][KeyIdx].RxMic[i]));
-	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("\n	  Tx MIC Key = "));
-	for (i = 0; i < 8; i++)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("%02x:", pAd->SharedKey[apidx][KeyIdx].TxMic[i]));
-	}
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("\n	  RxTSC = "));
-	for (i = 0; i < 6; i++)
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("%02x:", pAd->SharedKey[apidx][KeyIdx].RxTsc[i]));
-	}
-#endif
-	DBGPRINT_RAW(RT_DEBUG_TRACE, ("\n pKey-> BSSID:%02x:%02x:%02x:%02x:%02x:%02x \n",
-		pKey->BSSID[0],pKey->BSSID[1],pKey->BSSID[2],pKey->BSSID[3],pKey->BSSID[4],pKey->BSSID[5]));
-
-	if ((bTxKey) && (pAd->OpMode == OPMODE_STA))  // Pairwise Key. Add BSSID to WCTable
-		RTMPAddBSSIDCipher(pAd, BSSID_WCID, pKey, pAd->SharedKey[BSS0][KeyIdx].CipherAlg);
-
-
-	// No matter pairwise key or what leyidx is, always has a copy at on-chip SharedKeytable.
-	AsicAddSharedKeyEntry(pAd,
-						  apidx,
-						  (UCHAR)KeyIdx,
-						  pAd->SharedKey[apidx][KeyIdx].CipherAlg,
-						  pAd->SharedKey[apidx][KeyIdx].Key,
-						  pAd->SharedKey[apidx][KeyIdx].TxMic,
-						  pAd->SharedKey[apidx][KeyIdx].RxMic);
-
-	// The WCID key specified in used at Tx. For STA, always use pairwise key.
-
-	// ad-hoc mode need to specify WAP Group key with WCID index=BSS0Mcast_WCID. Let's always set this key here.
-/*	if (bPairwise == FALSE)
-	{
-		offset = MAC_IVEIV_TABLE_BASE + (BSS0Mcast_WCID * HW_IVEIV_ENTRY_SIZE);
-		NdisZeroMemory(IVEIV, 8);
-		// 1. IV/EIV
-		// Specify key index to find shared key.
-		if ((pAd->SharedKey[BSS0][KeyIdx].CipherAlg==CIPHER_TKIP) ||
-			(pAd->SharedKey[BSS0][KeyIdx].CipherAlg==CIPHER_AES))
-		IVEIV[3] = 0x20;		// Eiv bit on. keyid always 0 for pairwise key
-		IVEIV[3] |= (KeyIdx<< 6);	// groupkey index is not 0
-		for (i=0; i<8; i++)
-		{
-			RTMP_IO_WRITE8(pAd, offset+i, IVEIV[i]);
-		}
-
-		// 2. WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:use share key, BSSIdx is 0
-		WCIDAttri = (pAd->SharedKey[BSS0][KeyIdx].CipherAlg<<1)|PAIRWISEKEYTABLE;
-		offset = MAC_WCID_ATTRIBUTE_BASE + (BSS0Mcast_WCID* HW_WCID_ATTRI_SIZE);
-		RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
-
-	}
-
-*/
-
-   if (pAd->SharedKey[apidx][KeyIdx].Type == GROUP_KEY)
-	{
-		// 802.1x port control
-		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-		DBGPRINT(RT_DEBUG_TRACE,("!!WPA_802_1X_PORT_SECURED!!\n"));
-
-	}
-
-	return (NDIS_STATUS_SUCCESS);
-}
-#endif
-
 BOOLEAN RTMPCheckStrPrintAble(
     IN  CHAR *pInPutStr,
     IN  UCHAR strLen)
@@ -1425,11 +1115,6 @@ VOID	RTMPSetPhyMode(
 	INT i;
 	// the selected phymode must be supported by the RF IC encoded in E2PROM
 
-	// if no change, do nothing
-	/* bug fix
-	if (pAd->CommonCfg.PhyMode == phymode)
-		return;
-    */
 	pAd->CommonCfg.PhyMode = (UCHAR)phymode;
 
 	DBGPRINT(RT_DEBUG_TRACE,("RTMPSetPhyMode : PhyMode=%d, channel=%d \n", pAd->CommonCfg.PhyMode, pAd->CommonCfg.Channel));
@@ -2206,11 +1891,6 @@ VOID RTMPIoctlGetMacTable(
 
 			// the connected time per entry
 			MacTab.Entry[MacTab.Num].ConnectedTime = pAd->MacTab.Content[i].StaConnectTime;
-#if 0 // ToDo
-			MacTab.Entry[MacTab.Num].HSCounter.LastDataPacketTime = pAd->MacTab.Content[i].HSCounter.LastDataPacketTime;
-			MacTab.Entry[MacTab.Num].HSCounter.TotalRxByteCount = pAd->MacTab.Content[i].HSCounter.TotalRxByteCount;
-			MacTab.Entry[MacTab.Num].HSCounter.TotalTxByteCount = pAd->MacTab.Content[i].HSCounter.TotalTxByteCount;
-#endif
 			MacTab.Entry[MacTab.Num].TxRate.field.MCS = pAd->MacTab.Content[i].HTPhyMode.field.MCS;
 			MacTab.Entry[MacTab.Num].TxRate.field.BW = pAd->MacTab.Content[i].HTPhyMode.field.BW;
 			MacTab.Entry[MacTab.Num].TxRate.field.ShortGI = pAd->MacTab.Content[i].HTPhyMode.field.ShortGI;
@@ -2277,7 +1957,6 @@ INT	Set_BASetup_Proc(
 		=>The six 2 digit hex-decimal number previous are the Mac address,
 		=>The seventh decimal number is the tid value.
 */
-	//printk("\n%s\n", arg);
 
 	if(strlen(arg) < 19)  //Mac address acceptable format 01:02:03:04:05:06 length 17 plus the "-" and tid value in decimal format.
 		return FALSE;
@@ -2351,7 +2030,6 @@ INT	Set_BAOriTearDown_Proc(
 	INT i;
     MAC_TABLE_ENTRY *pEntry;
 
-    //printk("\n%s\n", arg);
 /*
 	The BAOriTearDown inupt string format should be xx:xx:xx:xx:xx:xx-d,
 		=>The six 2 digit hex-decimal number previous are the Mac address,
--- a/drivers/staging/rt2870/common/cmm_sanity.c
+++ b/drivers/staging/rt2870/common/cmm_sanity.c
@@ -81,14 +81,6 @@ BOOLEAN MlmeAddBAReqSanity(
         return FALSE;
     }
 
-	/*
-    if ((pInfo->BaBufSize > MAX_RX_REORDERBUF) || (pInfo->BaBufSize < 2))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("MlmeAddBAReqSanity fail - Rx Reordering buffer too big or too small\n"));
-        return FALSE;
-    }
-	*/
-
     if ((pInfo->pAddr[0]&0x01) == 0x01)
     {
         DBGPRINT(RT_DEBUG_TRACE, ("MlmeAddBAReqSanity fail - broadcast address not support BA\n"));
@@ -185,7 +177,6 @@ BOOLEAN PeerAddBARspActionSanity(
     IN VOID *pMsg,
     IN ULONG MsgLen)
 {
-	//PFRAME_802_11 pFrame = (PFRAME_802_11)pMsg;
 	PFRAME_ADDBA_RSP pAddFrame;
 
 	pAddFrame = (PFRAME_ADDBA_RSP)(pMsg);
@@ -341,8 +332,6 @@ BOOLEAN PeerBeaconAndProbeRspSanity(
     COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
     COPY_MAC_ADDR(pBssid, pFrame->Hdr.Addr3);
 
-//	hex_dump("Beacon", Msg, MsgLen);
-
     Ptr = pFrame->Octet;
     Length += LENGTH_802_11;
 
@@ -556,26 +545,6 @@ BOOLEAN PeerBeaconAndProbeRspSanity(
             // Wifi WMM use the same IE vale, need to parse that too
             // case IE_WPA:
             case IE_VENDOR_SPECIFIC:
-                // Check Broadcom/Atheros 802.11n OUI version, for HT Capability IE.
-                // This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
-                /*if (NdisEqualMemory(pEid->Octet, BROADCOM_OUI, 3) && (pEid->Len >= 4))
-                {
-                	if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 30))
-            		{
-				{
-					NdisMoveMemory(pHtCapability, &pEid->Octet[4], sizeof(HT_CAPABILITY_IE));
-					*pHtCapabilityLen = SIZE_HT_CAP_IE;	// Nnow we only support 26 bytes.
-				}
-         		}
-                	if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 26))
-            		{
-				{
-					NdisMoveMemory(AddHtInfo, &pEid->Octet[4], sizeof(ADD_HT_INFO_IE));
-					*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;	// Nnow we only support 26 bytes.
-				}
-         		}
-                }
-				*/
                 // Check the OUI version, filter out non-standard usage
                 if (NdisEqualMemory(pEid->Octet, RALINK_OUI, 3) && (pEid->Len == 7))
                 {
--- a/drivers/staging/rt2870/common/cmm_wpa.c
+++ b/drivers/staging/rt2870/common/cmm_wpa.c
@@ -1248,16 +1248,6 @@ VOID	ConstructEapolMsg(
 	*(USHORT *)(&pMsg->KeyDesc.KeyInfo) = cpu2le16(*(USHORT *)(&pMsg->KeyDesc.KeyInfo));
 
 	// Fill in Key Length
-#if 0
-	if (bWPA2)
-	{
-		// In WPA2 mode, the field indicates the length of pairwise key cipher,
-		// so only pairwise_msg_1 and pairwise_msg_3 need to fill.
-		if ((MsgType == EAPOL_PAIR_MSG_1) || (MsgType == EAPOL_PAIR_MSG_3))
-			pMsg->KeyDesc.KeyLength[1] = ((WepStatus == Ndis802_11Encryption2Enabled) ? LEN_TKIP_KEY : LEN_AES_KEY);
-	}
-	else if (!bWPA2)
-#endif
 	{
 		if (MsgType >= EAPOL_GROUP_MSG_1)
 		{
--- a/drivers/staging/rt2870/common/dfs.c
+++ b/drivers/staging/rt2870/common/dfs.c
@@ -80,18 +80,6 @@ VOID BbpRadarDetectionStart(
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, 124, 0x28);
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, 125, 0xff);
 
-#if 0
-	// toggle Rx enable bit for radar detection.
-	// it's Andy's recommand.
-	{
-		UINT32 Value;
-	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
-	Value |= (0x1 << 3);
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
-	Value &= ~(0x1 << 3);
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
-	}
-#endif
 	RadarPeriod = ((UINT)RdIdleTimeTable[pAd->CommonCfg.RadarDetect.RDDurRegion][0] + (UINT)pAd->CommonCfg.RadarDetect.DfsSessionTime) < 250 ?
 			(RdIdleTimeTable[pAd->CommonCfg.RadarDetect.RDDurRegion][0] + pAd->CommonCfg.RadarDetect.DfsSessionTime) : 250;
 
--- a/drivers/staging/rt2870/common/eeprom.c
+++ b/drivers/staging/rt2870/common/eeprom.c
@@ -36,16 +36,6 @@
 */
 #include "../rt_config.h"
 
-#if 0
-#define EEPROM_SIZE								0x200
-#define NVRAM_OFFSET			0x30000
-#define RF_OFFSET				0x40000
-
-static UCHAR init_flag = 0;
-static PUCHAR nv_ee_start = 0;
-
-static UCHAR EeBuffer[EEPROM_SIZE];
-#endif
 // IRQL = PASSIVE_LEVEL
 VOID RaiseClock(
     IN	PRTMP_ADAPTER	pAd,
--- a/drivers/staging/rt2870/common/mlme.c
+++ b/drivers/staging/rt2870/common/mlme.c
@@ -243,19 +243,11 @@ UCHAR RateSwitchTable11BGN3S[] = { // 3*
     0x02, 0x21,  2, 20, 50,
     0x03, 0x21,  3, 20, 50,
     0x04, 0x21,  4, 15, 50,
-#if 1
     0x05, 0x20, 20, 15, 30,
     0x06, 0x20, 21,  8, 20,
     0x07, 0x20, 22,  8, 20,
     0x08, 0x20, 23,  8, 25,
     0x09, 0x22, 23,  8, 25,
-#else // for RT2860 2*3 test
-    0x05, 0x20, 12, 15, 30,
-    0x06, 0x20, 13,  8, 20,
-    0x07, 0x20, 14,  8, 20,
-    0x08, 0x20, 15,  8, 25,
-    0x09, 0x22, 15,  8, 25,
-#endif
 };
 
 UCHAR RateSwitchTable11BGN2SForABand[] = {
@@ -822,8 +814,6 @@ VOID MlmePeriodicExec(
 			rx_Total = 0;
 		}
 
-		//ORIBATimerTimeout(pAd);
-
 		// Media status changed, report to NDIS
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE))
 		{
@@ -854,13 +844,6 @@ VOID MlmePeriodicExec(
    		// Need statistics after read counter. So put after NICUpdateRawCounters
 		ORIBATimerTimeout(pAd);
 
-		// if MGMT RING is full more than twice within 1 second, we consider there's
-		// a hardware problem stucking the TX path. In this case, try a hardware reset
-		// to recover the system
-	//	if (pAd->RalinkCounters.MgmtRingFullCount >= 2)
-	//		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HARDWARE_ERROR);
-	//	else
-	//		pAd->RalinkCounters.MgmtRingFullCount = 0;
 
 		// The time period for checking antenna is according to traffic
 		if (pAd->Mlme.bEnableAutoAntennaCheck)
@@ -978,8 +961,6 @@ VOID STAMlmePeriodicExec(
 			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - No BEACON. restore R66 to the low bound(%d) \n", (0x2E + GET_LNA_GAIN(pAd))));
 		}
 
-        //if ((pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
-        //    (pAd->RalinkCounters.OneSecTxRetryOkCount == 0))
         {
     		if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable)
     		{
@@ -1015,7 +996,6 @@ VOID STAMlmePeriodicExec(
                 wireless_send_event(pAd->net_dev, SIOCGIWAP, &wrqu, NULL);
             }
 
-			// RTMPPatchMacBbpBug(pAd);
 			MlmeAutoReconnectLastSSID(pAd);
 		}
 		else if (CQI_IS_BAD(pAd->Mlme.ChannelQuality))
@@ -1295,8 +1275,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-		//if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
-		//	((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
 		if ((pEntry->RateLen == 12) && (pEntry->HTCapability.MCSSet[0] == 0xff) &&
 			((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1)))
 		{// 11BGN 1S AP
@@ -1307,8 +1285,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
-		//	(pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
 		if ((pEntry->RateLen == 12) && (pEntry->HTCapability.MCSSet[0] == 0xff) &&
 			(pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2))
 		{// 11BGN 2S AP
@@ -1329,7 +1305,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-		//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
 		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1)))
 		{// 11N 1S AP
 			*ppTable = RateSwitchTable11N1S;
@@ -1339,7 +1314,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-		//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
 		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2))
 		{// 11N 2S AP
 			if (pAd->LatchRfRegs.Channel <= 14)
@@ -2003,7 +1977,6 @@ VOID MlmeDynamicTxRateSwitching(
 				{
 					MCS14 = idx;
 				}
-				//else if ((pCurrTxRate->CurrMCS == MCS_15)/* && (pCurrTxRate->ShortGI == GI_800)*/)	//we hope to use ShortGI as initial rate
 				else if ((pCurrTxRate->CurrMCS == MCS_15) && (pCurrTxRate->ShortGI == GI_800))	//we hope to use ShortGI as initial rate, however Atheros's chip has bugs when short GI
 				{
 					MCS15 = idx;
@@ -2074,7 +2047,6 @@ VOID MlmeDynamicTxRateSwitching(
 			else
 				TxRateIdx = MCS0;
 		}
-//		else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand) || (pTable == RateSwitchTable))
 		else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand)) // 3*3
 			{// N mode with 2 stream
 				if (MCS15 && (Rssi >= (-70+RssiOffset)))
@@ -2137,7 +2109,6 @@ VOID MlmeDynamicTxRateSwitching(
 					TxRateIdx = MCS0;
 			}
 
-	//		if (TxRateIdx != pAd->CommonCfg.TxRateIndex)
 			{
 				pEntry->CurrTxRateIndex = TxRateIdx;
 				pNextTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(pEntry->CurrTxRateIndex+1)*5];
@@ -2378,14 +2349,6 @@ VOID StaQuickResponeForRateUpExec(
 			pAd->WlanCounters.RetryCount.u.LowPart += StaTx1.field.TxRetransmit;
 			pAd->WlanCounters.FailedCount.u.LowPart += TxStaCnt0.field.TxFailCount;
 
-#if 0 // test by Gary.
-			// if no traffic in the past 1-sec period, don't change TX rate,
-			// but clear all bad history. because the bad history may affect the next
-			// Chariot throughput test
-			TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +
-						 pAd->RalinkCounters.OneSecTxRetryOkCount +
-						 pAd->RalinkCounters.OneSecTxFailCount;
-#endif
 			if (TxTotalCnt)
 				TxErrorRatio = ((TxRetransmit + TxFailCount) * 100) / TxTotalCnt;
 		}
@@ -2538,10 +2501,7 @@ VOID MlmeCheckPsmChange(
 	if (INFRA_ON(pAd) &&
 		(PowerMode != Ndis802_11PowerModeCAM) &&
 		(pAd->StaCfg.Psm == PWR_ACTIVE) &&
-//		(! RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-		(pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) /*&&
-		(pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
-		(pAd->RalinkCounters.OneSecTxRetryOkCount == 0)*/)
+		(pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE))
 	{
 		NdisGetSystemUpTime(&pAd->Mlme.LastSendNULLpsmTime);
 		pAd->RalinkCounters.RxCountSinceLastNULL = 0;
@@ -2734,28 +2694,20 @@ VOID MlmeUpdateTxRates(
 	// specified; otherwise disabled
 	if (num <= 1)
 	{
-		//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= FALSE;
 		*auto_rate_cur_p = FALSE;
 	}
 	else
 	{
-		//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= TRUE;
 		*auto_rate_cur_p = TRUE;
 	}
 
 #if 1
 	if (HtMcs != MCS_AUTO)
 	{
-		//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= FALSE;
 		*auto_rate_cur_p = FALSE;
 	}
 	else
 	{
-		//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= TRUE;
 		*auto_rate_cur_p = TRUE;
 	}
 #endif
@@ -2824,9 +2776,6 @@ VOID MlmeUpdateTxRates(
 
 	RTMP_IO_WRITE32(pAd, LEGACY_BASIC_RATE, BasicRateBitmap);
 
-	// bug fix
-	// pAd->CommonCfg.BasicRateBitmap = BasicRateBitmap;
-
 	// calculate the exptected ACK rate for each TX rate. This info is used to caculate
 	// the DURATION field of outgoing uniicast DATA/MGMT frame
 	for (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
@@ -2844,14 +2793,6 @@ VOID MlmeUpdateTxRates(
 		pAd->CommonCfg.MaxTxRate = MaxDesire;
 
 	pAd->CommonCfg.MinTxRate = MinSupport;
-	// 2003-07-31 john - 2500 doesn't have good sensitivity at high OFDM rates. to increase the success
-	// ratio of initial DHCP packet exchange, TX rate starts from a lower rate depending
-	// on average RSSI
-	//	 1. RSSI >= -70db, start at 54 Mbps (short distance)
-	//	 2. -70 > RSSI >= -75, start at 24 Mbps (mid distance)
-	//	 3. -75 > RSSI, start at 11 Mbps (long distance)
-	//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)/* &&
-	//	OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)*/)
 	if (*auto_rate_cur_p)
 	{
 		short dbm = 0;
@@ -2920,11 +2861,7 @@ VOID MlmeUpdateTxRates(
 				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
 				pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
 
-//#ifdef	WIFI_TEST
 				pAd->CommonCfg.RtsRate = RATE_11;
-//#else
-//				pAd->CommonCfg.RtsRate = RATE_1;
-//#endif
 				break;
 			case PHY_11G:
 			case PHY_11A:
@@ -4278,8 +4215,6 @@ VOID MgtMacHeaderInit(
 
 	pHdr80211->FC.Type = BTYPE_MGMT;
 	pHdr80211->FC.SubType = SubType;
-//	if (SubType == SUBTYPE_ACK)	// sample, no use, it will conflict with ACTION frame sub type
-//		pHdr80211->FC.Type = BTYPE_CNTL;
 	pHdr80211->FC.ToDs = ToDs;
 	COPY_MAC_ADDR(pHdr80211->Addr1, pDA);
 
@@ -5122,9 +5057,7 @@ VOID 	AsicUpdateProtect(
 	// Config ASIC RTS threshold register
 	RTMP_IO_READ32(pAd, TX_RTS_CFG, &MacReg);
 	MacReg &= 0xFF0000FF;
-#if 0
-	MacReg |= (pAd->CommonCfg.RtsThreshold << 8);
-#else
+
 	// If the user want disable RtsThreshold and enbale Amsdu/Ralink-Aggregation, set the RtsThreshold as 4096
         if ((
 			(pAd->CommonCfg.BACapability.field.AmsduEnable) ||
@@ -5137,7 +5070,6 @@ VOID 	AsicUpdateProtect(
         {
 			MacReg |= (pAd->CommonCfg.RtsThreshold << 8);
         }
-#endif
 
 	RTMP_IO_WRITE32(pAd, TX_RTS_CFG, MacReg);
 
@@ -5831,10 +5763,7 @@ VOID AsicAdjustTxPower(
 						break;
 				}
 				// The index is the step we should decrease, idx = 0 means there is nothing to compensate
-//				if (R3 > (ULONG) (TxAgcStep * (idx-1)))
-					*pTxAgcCompensate = -(TxAgcStep * (idx-1));
-//				else
-//					*pTxAgcCompensate = -((UCHAR)R3);
+				*pTxAgcCompensate = -(TxAgcStep * (idx-1));
 
 				DeltaPwr += (*pTxAgcCompensate);
 				DBGPRINT(RT_DEBUG_TRACE, ("-- Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = -%d\n",
@@ -6116,11 +6045,6 @@ VOID AsicDisableRDG(
 	RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
 
 	Data  &= 0xFFFFFF00;
-	//Data  |= 0x20;
-#ifndef WIFI_TEST
-	//if ( pAd->CommonCfg.bEnableTxBurst )
-	//	Data |= 0x60; // for performance issue not set the TXOP to 0
-#endif
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_DYNAMIC_BE_TXOP_ACTIVE)
 		&& (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
 	)
@@ -6177,7 +6101,6 @@ VOID AsicEnableBssSync(
 	DBGPRINT(RT_DEBUG_TRACE, ("--->AsicEnableBssSync(INFRA mode)\n"));
 
 	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-//	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, 0x00000000);
 
 	{
 		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
@@ -6223,8 +6146,6 @@ VOID AsicEnableIbssSync(
 	ptr = (PUCHAR)&pAd->BeaconTxWI;
 	for (i=0; i<TXWI_SIZE; i+=2)  // 16-byte TXWI field
 	{
-		//UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
-		//RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + i, longptr);
 		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + i, ptr, 2);
 		ptr += 2;
 	}
@@ -6233,19 +6154,11 @@ VOID AsicEnableIbssSync(
 	ptr = pAd->BeaconBuf;
 	for (i=0; i< pAd->BeaconTxWI.MPDUtotalByteCount; i+=2)
 	{
-		//UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
-		//RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr);
 		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, ptr, 2);
 		ptr +=2;
 	}
 #endif // RT2870 //
 
-	//
-	// For Wi-Fi faily generated beacons between participating stations.
-	// Set TBTT phase adaptive adjustment step to 8us (default 16us)
-	// don't change settings 2006-5- by Jerry
-	//RTMP_IO_WRITE32(pAd, TBTT_SYNC_CFG, 0x00001010);
-
 	// start sending BEACON
 	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
 	csr9.field.bTsfTicking = 1;
@@ -6293,7 +6206,6 @@ VOID AsicSetEdcaParm(
 		//========================================================
 		//      MAC Register has a copy .
 		//========================================================
-//#ifndef WIFI_TEST
 		if( pAd->CommonCfg.bEnableTxBurst )
 		{
 			// For CWC test, change txop from 0x30 to 0x20 in TxBurst mode
@@ -6301,9 +6213,6 @@ VOID AsicSetEdcaParm(
 		}
 		else
 			Ac0Cfg.field.AcTxop = 0;	// QID_AC_BE
-//#else
-//		Ac0Cfg.field.AcTxop = 0;	// QID_AC_BE
-//#endif
 		Ac0Cfg.field.Cwmin = CW_MIN_IN_BITS;
 		Ac0Cfg.field.Cwmax = CW_MAX_IN_BITS;
 		Ac0Cfg.field.Aifsn = 2;
@@ -6807,18 +6716,14 @@ VOID AsicAddKeyEntry(
 	IN BOOLEAN		bTxKey)
 {
 	ULONG	offset;
-//	ULONG   WCIDAttri = 0;
 	UCHAR	IV4 = 0;
 	PUCHAR		pKey = pCipherKey->Key;
-//	ULONG		KeyLen = pCipherKey->KeyLen;
 	PUCHAR		pTxMic = pCipherKey->TxMic;
 	PUCHAR		pRxMic = pCipherKey->RxMic;
 	PUCHAR		pTxtsc = pCipherKey->TxTsc;
 	UCHAR		CipherAlg = pCipherKey->CipherAlg;
 	SHAREDKEY_MODE_STRUC csr1;
 
-//	ASSERT(KeyLen <= MAX_LEN_OF_PEER_KEY);
-
 	DBGPRINT(RT_DEBUG_TRACE, ("==> AsicAddKeyEntry\n"));
 	//
 	// 1.) decide key table offset
@@ -7561,18 +7466,6 @@ VOID APSDPeriodicExec(
 
 	pAd->CommonCfg.TriggerTimerCount++;
 
-// Driver should not send trigger frame, it should be send by application layer
-/*
-	if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable
-		&& (pAd->CommonCfg.bNeedSendTriggerFrame ||
-		(((pAd->CommonCfg.TriggerTimerCount%20) == 19) && (!pAd->CommonCfg.bAPSDAC_BE || !pAd->CommonCfg.bAPSDAC_BK || !pAd->CommonCfg.bAPSDAC_VI || !pAd->CommonCfg.bAPSDAC_VO))))
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("Sending trigger frame and enter service period when support APSD\n"));
-		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
-		pAd->CommonCfg.bNeedSendTriggerFrame = FALSE;
-		pAd->CommonCfg.TriggerTimerCount = 0;
-		pAd->CommonCfg.bInServicePeriod = TRUE;
-	}*/
 }
 
 /*
--- a/drivers/staging/rt2870/common/rtmp_init.c
+++ b/drivers/staging/rt2870/common/rtmp_init.c
@@ -176,12 +176,10 @@ RTMP_REG_PAIR	MACRegTable[] =	{
 	{TX_SW_CFG0,		0x0}, 		// Gary,2008-05-21 for CWC test
 	{TX_SW_CFG1,		0x80606}, // Gary,2006-08-23
 	{TX_LINK_CFG,		0x1020},		// Gary,2006-08-23
-	//{TX_TIMEOUT_CFG,	0x00182090},	// CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT
 	{TX_TIMEOUT_CFG,	0x000a2090},	// CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT , Modify for 2860E ,2007-08-01
 	{MAX_LEN_CFG,		MAX_AGGREGATION_SIZE | 0x00001000},	// 0x3018, MAX frame length. Max PSDU = 16kbytes.
 	{LED_CFG,		0x7f031e46}, // Gary, 2006-08-23
 	{PBF_MAX_PCNT,			0x1F3FBF9F}, 	//0x1F3f7f9f},		//Jan, 2006/04/20
-	//{TX_RTY_CFG,			0x6bb80408},	// Jan, 2006/11/16
 	{TX_RTY_CFG,			0x47d01f0f},	// Jan, 2006/11/16, Set TxWI->ACK =0 in Probe Rsp Modify for 2860E ,2007-08-03
 	{AUTO_RSP_CFG,			0x00000013},	// Initial Auto_Responder, because QA will turn off Auto-Responder
 	{CCK_PROT_CFG,			0x05740003 /*0x01740003*/},	// Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled.
@@ -196,11 +194,7 @@ RTMP_REG_PAIR	MACRegTable[] =	{
 	{MM20_PROT_CFG,			0x01744004},
 	{TXOP_CTRL_CFG,			0x0000583f, /*0x0000243f*/ /*0x000024bf*/},	//Extension channel backoff.
 	{TX_RTS_CFG,			0x00092b20},
-//#ifdef WIFI_TEST
 	{EXP_ACK_TIME,			0x002400ca},	// default value
-//#else
-//	{EXP_ACK_TIME,			0x005400ca},	// suggested by Gray @ 20070323 for 11n intel-sta throughput
-//#endif // end - WIFI_TEST //
 	{TXOP_HLDR_ET, 			0x00000002},
 
 	/* Jerry comments 2008/01/16: we use SIFS = 10us in CCK defaultly, but it seems that 10us
@@ -877,8 +871,6 @@ VOID	RTMPReadChannelPwr(
 	// 0. 11b/g, ch1 - ch 14
 	for (i = 0; i < 7; i++)
 	{
-//		Power.word = RTMP_EEPROM_READ16(pAd, EEPROM_G_TX_PWR_OFFSET + i * 2);
-//		Power2.word = RTMP_EEPROM_READ16(pAd, EEPROM_G_TX2_PWR_OFFSET + i * 2);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX_PWR_OFFSET + i * 2, Power.word);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX2_PWR_OFFSET + i * 2, Power2.word);
 		pAd->TxPower[i * 2].Channel = i * 2 + 1;
@@ -926,8 +918,6 @@ VOID	RTMPReadChannelPwr(
 	// 1.2 Fill up power
 	for (i = 0; i < 6; i++)
 	{
-//		Power.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + i * 2);
-//		Power2.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + i * 2);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + i * 2, Power.word);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + i * 2, Power2.word);
 
@@ -968,8 +958,6 @@ VOID	RTMPReadChannelPwr(
 	// 2.2 Fill up power
 	for (i = 0; i < 8; i++)
 	{
-//		Power.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2);
-//		Power2.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2, Power.word);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2, Power2.word);
 
@@ -1010,8 +998,6 @@ VOID	RTMPReadChannelPwr(
 	// 3.2 Fill up power
 	for (i = 0; i < 4; i++)
 	{
-//		Power.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2);
-//		Power2.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2, Power.word);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2, Power2.word);
 
@@ -1337,20 +1323,6 @@ VOID	NICReadEEPROMParameters(
 
 
 	{
-#if 0
-		USHORT  Addr01,Addr23,Addr45 ;
-
-		Addr01=RTMP_EEPROM_READ16(pAd, 0x04);
-		Addr23=RTMP_EEPROM_READ16(pAd, 0x06);
-		Addr45=RTMP_EEPROM_READ16(pAd, 0x08);
-
-		pAd->PermanentAddress[0] = (UCHAR)(Addr01 & 0xff);
-		pAd->PermanentAddress[1] = (UCHAR)(Addr01 >> 8);
-		pAd->PermanentAddress[2] = (UCHAR)(Addr23 & 0xff);
-		pAd->PermanentAddress[3] = (UCHAR)(Addr23 >> 8);
-		pAd->PermanentAddress[4] = (UCHAR)(Addr45 & 0xff);
-		pAd->PermanentAddress[5] = (UCHAR)(Addr45 >> 8);
-#endif
 		//more conveninet to test mbssid, so ap's bssid &0xf1
 		if (pAd->PermanentAddress[0] == 0xff)
 			pAd->PermanentAddress[0] = RandomByte(pAd)&0xf8;
@@ -1751,7 +1723,6 @@ VOID	NICInitAsicFromEEPROM(
 			{
 				pAd->StaCfg.bHwRadio = FALSE;
 				pAd->StaCfg.bRadio = FALSE;
-//				RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818);
 				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 			}
 		}
@@ -1771,7 +1742,6 @@ VOID	NICInitAsicFromEEPROM(
 	// Turn off patching for cardbus controller
 	if (NicConfig2.field.CardbusAcceleration == 1)
 	{
-//		pAd->bTest1 = TRUE;
 	}
 
 	if (NicConfig2.field.DynamicTxAgcControl == 1)
@@ -1840,7 +1810,6 @@ NDIS_STATUS	NICInitializeAdapter(
 {
 	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
 	WPDMA_GLO_CFG_STRUC	GloCfg;
-//	INT_MASK_CSR_STRUC		IntMask;
 	ULONG	i =0, j=0;
 	AC_TXOP_CSR0_STRUC	csr0;
 
@@ -2129,10 +2098,6 @@ NDIS_STATUS	NICInitializeAsic(
 		}
 	}
 
-	// assert HOST ready bit
-//  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x0); // 2004-09-14 asked by Mark
-//  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x4);
-
 	// It isn't necessary to clear this space when not hard reset.
 	if (bHardReset == TRUE)
 	{
@@ -2194,9 +2159,6 @@ VOID	NICIssueReset(
 	UINT32	Value = 0;
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICIssueReset\n"));
 
-	// Abort Tx, prevent ASIC from writing to Host memory
-	//RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x001f0000);
-
 	// Disable Rx, register value supposed will remain after reset
 	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
 	Value &= (0xfffffff3);
@@ -2280,10 +2242,6 @@ VOID NICUpdateFifoStaCounters(
 				if (pEntry->FIFOCount >= 1)
 				{
 					DBGPRINT(RT_DEBUG_TRACE, ("#"));
-#if 0
-					SendRefreshBAR(pAd, pEntry);
-					pEntry->NoBADataCountDown = 64;
-#else
 					pEntry->NoBADataCountDown = 64;
 
 					if(pEntry->PsMode == PWR_ACTIVE)
@@ -2304,10 +2262,7 @@ VOID NICUpdateFifoStaCounters(
 						pEntry->FIFOCount = 0;
 						pEntry->ContinueTxFailCnt = 0;
 					}
-#endif
-					//pEntry->FIFOCount = 0;
 				}
-				//pEntry->bSendBAR = TRUE;
 			}
 			else
 			{
@@ -2431,7 +2386,6 @@ VOID NICUpdateRawCounters(
 	// Update RX Overflow counter
 	pAd->Counters8023.RxNoBuffer += (RxStaCnt2.field.RxFifoOverflowCount);
 
-	//pAd->RalinkCounters.RxCount = 0;
 #ifdef RT2870
 	if (pAd->RalinkCounters.RxCount != pAd->watchDogRxCnt)
 	{
@@ -2448,8 +2402,6 @@ VOID NICUpdateRawCounters(
 #endif // RT2870 //
 
 
-	//if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) ||
-	//	(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) && (pAd->MacTab.Size != 1)))
 	if (!pAd->bUpdateBcnCntDone)
 	{
 	// Update BEACON sent count
@@ -2465,21 +2417,6 @@ VOID NICUpdateRawCounters(
 	pAd->WlanCounters.FailedCount.u.LowPart += TxStaCnt0.field.TxFailCount;
 	}
 
-#if 0
-	Retry = StaTx1.field.TxRetransmit;
-	Fail = TxStaCnt0.field.TxFailCount;
-	TxErrorRatio = 0;
-	OneSecTransmitCount = pAd->WlanCounters.TransmittedFragmentCount.u.LowPart- pAd->WlanCounters.LastTransmittedFragmentCount.u.LowPart;
-	if ((OneSecTransmitCount+Retry + Fail) > 0)
-		TxErrorRatio = (( Retry + Fail) *100) / (OneSecTransmitCount+Retry + Fail);
-
-	if ((OneSecTransmitCount+Retry + Fail) > 0)
-		TxErrorRatio = (( Retry + Fail) *100) / (OneSecTransmitCount+Retry + Fail);
-	DBGPRINT(RT_DEBUG_INFO, ("TX ERROR Rate = %ld %%, Retry = %ld, Fail = %ld, Total = %ld  \n",TxErrorRatio, Retry, Fail, (OneSecTransmitCount+Retry + Fail)));
-	pAd->WlanCounters.LastTransmittedFragmentCount.u.LowPart = pAd->WlanCounters.TransmittedFragmentCount.u.LowPart;
-#endif
-
-	//if (pAd->bStaFifoTest == TRUE)
 	{
 		RTMP_IO_READ32(pAd, TX_AGG_CNT, &TxAggCnt.word);
 		RTMP_IO_READ32(pAd, TX_AGG_CNT0, &TxAggCnt0.word);
@@ -2593,7 +2530,7 @@ VOID NICUpdateRawCounters(
 			pDiag->TxFailCnt[ArrayCurIdx] = 0;
 			pDiag->RxDataCnt[ArrayCurIdx] = 0;
 			pDiag->RxCrcErrCnt[ArrayCurIdx]  = 0;
-//			for (i = 9; i < 16; i++)
+
 			for (i = 9; i < 24; i++) // 3*3
 			{
 				pDiag->TxDescCnt[ArrayCurIdx][i] = 0;
@@ -2732,24 +2669,7 @@ NDIS_STATUS NICLoadFirmware(
 
 #endif // RT2870 //
 
-#if 0
-	/* enable Host program ram write selection */
-	RT28XX_FIRMUD_INIT(pAd);
-
-	for(i=0; i<FileLength; i+=4)
-	{
-		firm = pFirmwareImage[i] +
-			   (pFirmwareImage[i+3] << 24) +
-			   (pFirmwareImage[i+2] << 16) +
-			   (pFirmwareImage[i+1] << 8);
-
-		RTMP_IO_WRITE32(pAd, FIRMWARE_IMAGE_BASE + i, firm);
-	} /* End of for */
-
-	RT28XX_FIRMUD_END(pAd);
-#else
 	RT28XX_WRITE_FIRMWARE(pAd, pFirmwareImage, FileLength);
-#endif
 
 	/* check if MCU is ready */
 	Index = 0;
@@ -2769,13 +2689,9 @@ NDIS_STATUS NICLoadFirmware(
 		DBGPRINT(RT_DEBUG_ERROR, ("NICLoadFirmware: MCU is not ready\n\n\n"));
 	} /* End of if */
 
-#if 0
-    DBGPRINT(RT_DEBUG_TRACE,
-			 ("<=== %s (src=%s, status=%d)\n", __func__, src, Status));
-#else
     DBGPRINT(RT_DEBUG_TRACE,
 			 ("<=== %s (status=%d)\n", __func__, Status));
-#endif
+
     return Status;
 } /* End of NICLoadFirmware */
 
@@ -2804,81 +2720,6 @@ NDIS_STATUS NICLoadFirmware(
 NDIS_STATUS NICLoadRateSwitchingParams(
 	IN PRTMP_ADAPTER pAd)
 {
-#if 0
-	NDIS_STATUS Status;
-
-	NDIS_HANDLE FileHandle;
-	UINT FileLength = 0, i, j;
-	PUCHAR pFirmwareImage;
-	NDIS_STRING FileName;
-	NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1, -1);
-
-	DBGPRINT(RT_DEBUG_TRACE,("===> NICLoadRateSwitchingParams \n"));
-	pAd->CommonCfg.TxRateTableSize = 0;
-
-	if ((pAd->DeviceID == NIC2860_PCI_DEVICE_ID) || (pAd->DeviceID == NIC2860_PCIe_DEVICE_ID))
-	{
-		NdisInitializeString(&FileName,"rate.bin");
-		DBGPRINT(RT_DEBUG_TRACE, ("NICLoadRateSwitchingParams: load file - rate.bin for tx rate switch \n"));
-	}
-	else
-	{
-		DBGPRINT_ERR(("NICLoadRateSwitchingParams: wrong DeviceID = 0x%04x, can't find Tx rate switch parameters file\n", pAd->DeviceID));
-		return NDIS_STATUS_SUCCESS;
-	}
-	NdisOpenFile(&Status, &FileHandle, &FileLength, &FileName, HighestAcceptableMax);
-	NdisFreeString(FileName);
-
-	if (Status != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("NICLoadRateSwitchingParams: NdisOpenFile() failed, used RateSwitchTable instead\n"));
-		return NDIS_STATUS_SUCCESS;
-	}
-
-	if ((FileLength == 0) || (FileLength > (MAX_STEP_OF_TX_RATE_SWITCH+1)*16))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("NICLoadRateSwitchingParams: file size is not reasonable, used RateSwitchTable instead\n"));
-
-		NdisCloseFile(FileHandle);
-		return NDIS_STATUS_SUCCESS;
-	}
-	else
-	{
-		//
-		// NDIS_STATUS_SUCCESS means
-		// The handle at FileHandle is valid for a subsequent call to NdisMapFile.
-		//
-		NdisMapFile(&Status, &pFirmwareImage, FileHandle);
-		DBGPRINT(RT_DEBUG_TRACE, ("NdisMapFile FileLength=%d\n", FileLength));
-	}
-
-	for (i=0, j=0; i<FileLength; i++)
-	{
-		if ((i%16) <= 4)	// trim reserved field
-		{
-			if (i%16 == 1)	// deal with DEC and HEX, only row0 is Hex, others are Dec
-			{
-				RateSwitchTable[j] = *(pFirmwareImage + i);
-			}
-			else
-			{
-				RateSwitchTable[j] = (*(pFirmwareImage + i)>>4) * 10 + (*(pFirmwareImage + i) & 0x0F);
-			}
-
-			j++;
-		}
-	}
-
-	pAd->CommonCfg.TxRateTableSize = RateSwitchTable[0];		// backup table size
-
-	if (Status == NDIS_STATUS_SUCCESS)
-	{
-		NdisUnmapFile(FileHandle);
-		NdisCloseFile(FileHandle);
-	}
-
-	DBGPRINT(RT_DEBUG_TRACE,("<=== NICLoadRateSwitchingParams(Valid TxRateTable item number=%d)\n", pAd->CommonCfg.TxRateTableSize));
-#endif
 	return NDIS_STATUS_SUCCESS;
 }
 
@@ -3087,7 +2928,6 @@ VOID	RTMPMoveMemory(
 VOID	UserCfgInit(
 	IN	PRTMP_ADAPTER pAd)
 {
-//	EDCA_PARM DefaultEdcaParm;
     UINT key_index, bss_index;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> UserCfgInit\n"));
@@ -3331,17 +3171,11 @@ VOID	UserCfgInit(
 	pAd->Bbp94 = BBPR94_DEFAULT;
 	pAd->BbpForCCK = FALSE;
 
-	// Default is FALSE for test bit 1
-	//pAd->bTest1 = FALSE;
-
 	// initialize MAC table and allocate spin lock
 	NdisZeroMemory(&pAd->MacTab, sizeof(MAC_TABLE));
 	InitializeQueueHeader(&pAd->MacTab.McastPsQueue);
 	NdisAllocateSpinLock(&pAd->MacTabLock);
 
-	//RTMPInitTimer(pAd, &pAd->RECBATimer, RECBATimerTimeout, pAd, TRUE);
-	//RTMPSetTimer(&pAd->RECBATimer, REORDER_EXEC_INTV);
-
 	pAd->CommonCfg.bWiFiTest = FALSE;
 
 
@@ -3757,35 +3591,10 @@ VOID RTMPSetSignalLED(
 VOID RTMPEnableRxTx(
 	IN PRTMP_ADAPTER	pAd)
 {
-//	WPDMA_GLO_CFG_STRUC	GloCfg;
-//	ULONG	i = 0;
-
 	DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPEnableRxTx\n"));
 
-#if 0
-	// Enable Rx DMA.
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x4);
-	do
-	{
-		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
-		if ((GloCfg.field.TxDMABusy == 0)  && (GloCfg.field.RxDMABusy == 0))
-			break;
-
-		DBGPRINT(RT_DEBUG_TRACE, ("==>  DMABusy\n"));
-		RTMPusecDelay(1000);
-		i++;
-	}while ( i <200);
-
-	RTMPusecDelay(50);
-	RT28XX_DMA_WRITE_INIT(GloCfg);
-	DBGPRINT(RT_DEBUG_TRACE, ("<== WRITE DMA offset 0x208 = 0x%x\n", GloCfg.word));
-	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
-
-	RT28XX_DMA_POST_WRITE(pAd);
-#else
 	// Enable Rx DMA.
 	RT28XXDMAEnable(pAd);
-#endif
 
 	// enable RX of MAC block
 	if (pAd->OpMode == OPMODE_AP)
--- a/drivers/staging/rt2870/common/rtmp_tkip.c
+++ b/drivers/staging/rt2870/common/rtmp_tkip.c
@@ -464,7 +464,6 @@ VOID	RTMPInitTkipEngine(
 	tkipIv.IV16.field.rc2 = *pTSC;
 	tkipIv.IV16.field.CONTROL.field.ExtIV = 1;  // 0: non-extended IV, 1: an extended IV
 	tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
-//	tkipIv.IV32 = *(PULONG)(pTSC + 2);
 	NdisMoveMemory(&tkipIv.IV32, (pTSC + 2), 4);   // Copy IV
 
 	*pIV16 = tkipIv.IV16.word;
@@ -1211,11 +1210,9 @@ BOOLEAN RTMPSoftDecryptTKIP(
 	if (!NdisEqualMemory(MIC, TrailMIC, 8))
 	{
 		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptTKIP, WEP Data MIC Error !\n"));	 //MIC error.
-		//RTMPReportMicError(pAd, &pWpaKey[KeyID]);	// marked by AlbertY @ 20060630
 		return (FALSE);
 	}
 
-	//DBGPRINT(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP Decript done!!\n");
 	return TRUE;
 }
 
--- a/drivers/staging/rt2870/common/rtmp_wep.c
+++ b/drivers/staging/rt2870/common/rtmp_wep.c
@@ -106,15 +106,6 @@ UINT FCSTAB_32[256] =
 };
 
 /*
-UCHAR   WEPKEY[] = {
-		//IV
-		0x00, 0x11, 0x22,
-		//WEP KEY
-		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC
-	};
- */
-
-/*
 	========================================================================
 
 	Routine	Description:
--- a/drivers/staging/rt2870/common/rtusb_bulk.c
+++ b/drivers/staging/rt2870/common/rtusb_bulk.c
@@ -448,115 +448,6 @@ VOID	RTUSBBulkOutDataPacket(
 
 VOID RTUSBBulkOutDataPacketComplete(purbb_t pUrb, struct pt_regs *pt_regs)
 {
-#if 0 // sample, IRQ LOCK
-	PRTMP_ADAPTER		pAd;
-	POS_COOKIE			pObj;
-	PHT_TX_CONTEXT		pHTTXContext;
-	UCHAR				BulkOutPipeId;
-	NTSTATUS			Status;
-	unsigned long		IrqFlags;
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutDataPacketComplete\n"));
-
-	pHTTXContext	= (PHT_TX_CONTEXT)pUrb->context;
-	pAd			= pHTTXContext->pAd;
-	pObj 		= (POS_COOKIE) pAd->OS_Cookie;
-	Status		= pUrb->status;
-
-	// Store BulkOut PipeId
-	BulkOutPipeId = pHTTXContext->BulkOutPipeId;
-	pAd->BulkOutDataOneSecCount++;
-
-	//DBGPRINT(RT_DEBUG_LOUD, ("Done-B(%d):I=0x%lx, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", BulkOutPipeId, in_interrupt(), pHTTXContext->CurWritePosition,
-	//		pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-	pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-	pHTTXContext->IRPPending = FALSE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-
-	if (Status == USB_ST_NOERROR)
-	{
-		pAd->BulkOutComplete++;
-
-		pAd->Counters8023.GoodTransmits++;
-		//RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-		FREE_HTTX_RING(pAd, BulkOutPipeId, pHTTXContext);
-		//RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-
-
-	}
-	else	// STATUS_OTHER
-	{
-		PUCHAR	pBuf;
-
-		pAd->BulkOutCompleteOther++;
-
-		pBuf = &pHTTXContext->TransferBuffer->WirelessPacket[pHTTXContext->NextBulkOutPosition];
-
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("BulkOutDataPacket failed: ReasonCode=%d!\n", Status));
-		DBGPRINT_RAW(RT_DEBUG_ERROR, (">>BulkOut Req=0x%lx, Complete=0x%lx, Other=0x%lx\n", pAd->BulkOutReq, pAd->BulkOutComplete, pAd->BulkOutCompleteOther));
-		DBGPRINT_RAW(RT_DEBUG_ERROR, (">>BulkOut Header:%x %x %x %x %x %x %x %x\n", pBuf[0], pBuf[1], pBuf[2], pBuf[3], pBuf[4], pBuf[5], pBuf[6], pBuf[7]));
-		//DBGPRINT_RAW(RT_DEBUG_ERROR, (">>BulkOutCompleteCancel=0x%x, BulkOutCompleteOther=0x%x\n", pAd->BulkOutCompleteCancel, pAd->BulkOutCompleteOther));
-
-		if (!RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-									fRTMP_ADAPTER_HALT_IN_PROGRESS |
-									fRTMP_ADAPTER_NIC_NOT_EXIST |
-									fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid = BulkOutPipeId;
-		}
-	}
-
-	//
-	// bInUse = TRUE, means some process are filling TX data, after that must turn on bWaitingBulkOut
-	// bWaitingBulkOut = TRUE, means the TX data are waiting for bulk out.
-	//
-	//RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-	if ((pHTTXContext->ENextBulkOutPosition != pHTTXContext->CurWritePosition) &&
-		(pHTTXContext->ENextBulkOutPosition != (pHTTXContext->CurWritePosition+8)) &&
-		!RTUSB_TEST_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId)))
-	{
-		// Indicate There is data avaliable
-		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
-	}
-	//RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-
-	// Always call Bulk routine, even reset bulk.
-	// The protection of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
-
-
-	//DBGPRINT(RT_DEBUG_LOUD,("Done-A(%d):I=0x%lx, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d\n", BulkOutPipeId, in_interrupt(),
-	//		pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
-
-	switch (BulkOutPipeId)
-	{
-		case 0:
-				pObj->ac0_dma_done_task.data = (unsigned long)pAd;
-				tasklet_hi_schedule(&pObj->ac0_dma_done_task);
-				break;
-		case 1:
-				pObj->ac1_dma_done_task.data = (unsigned long)pAd;
-				tasklet_hi_schedule(&pObj->ac1_dma_done_task);
-				break;
-		case 2:
-				pObj->ac2_dma_done_task.data = (unsigned long)pAd;
-				tasklet_hi_schedule(&pObj->ac2_dma_done_task);
-				break;
-		case 3:
-				pObj->ac3_dma_done_task.data = (unsigned long)pAd;
-				tasklet_hi_schedule(&pObj->ac3_dma_done_task);
-				break;
-		case 4:
-				pObj->hcca_dma_done_task.data = (unsigned long)pAd;
-				tasklet_hi_schedule(&pObj->hcca_dma_done_task);
-				break;
-	}
-#else
-
-{
 	PHT_TX_CONTEXT	pHTTXContext;
 	PRTMP_ADAPTER	pAd;
 	POS_COOKIE 		pObj;
@@ -595,10 +486,6 @@ VOID RTUSBBulkOutDataPacketComplete(purb
 				break;
 	}
 }
-#endif
-
-
-}
 
 
 /*
@@ -664,9 +551,6 @@ VOID RTUSBBulkOutNullFrameComplete(purbb
 	PRTMP_ADAPTER		pAd;
 	PTX_CONTEXT			pNullContext;
 	NTSTATUS			Status;
-#if 0 // sample, IRQ LOCK
-	unsigned long		IrqFlags;
-#endif
 	POS_COOKIE			pObj;
 
 
@@ -674,169 +558,10 @@ VOID RTUSBBulkOutNullFrameComplete(purbb
 	pAd 			= pNullContext->pAd;
 	Status 			= pUrb->status;
 
-#if 0 // sample, IRQ LOCK
-	// Reset Null frame context flags
-	pNullContext->IRPPending 	= FALSE;
-	pNullContext->InUse 		= FALSE;
-
-	if (Status == USB_ST_NOERROR)
-	{
-		// Don't worry about the queue is empty or not, this function will check itself
-		//RTMPUSBDeQueuePacket(pAd, 0);
-		RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	}
-	else	// STATUS_OTHER
-	{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out Null Frame Failed\n"));
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-	}
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
-	pAd->BulkOutPending[0] = FALSE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
-
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
-#else
-
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 	pObj->null_frame_complete_task.data = (unsigned long)pUrb;
 	tasklet_hi_schedule(&pObj->null_frame_complete_task);
-#endif
-
-}
-
-#if 0	// For RT2870, RTS frame not used now, but maybe will use it latter.
-/*
-	========================================================================
-
-	Routine Description:
-
-	Arguments:
-
-	Return Value:
-
-	Note: RTS frame use BulkOutPipeId = 0
-
-	========================================================================
-*/
-VOID	RTUSBBulkOutRTSFrame(
-	IN	PRTMP_ADAPTER	pAd)
-{
-	PTX_CONTEXT		pRTSContext = &(pAd->RTSContext);
-	PURB			pUrb;
-	int				ret = 0;
-	unsigned long	IrqFlags;
-	UCHAR			PipeID=0;
-
-	if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_4))
-		PipeID= 3;
-	else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_3))
-		PipeID= 2;
-	else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_2))
-		PipeID= 1;
-	else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL))
-		PipeID= 0;
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[PipeID], IrqFlags);
-	if ((pAd->BulkOutPending[PipeID] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX))
-	{
-		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[PipeID], IrqFlags);
-		return;
-	}
-	pAd->BulkOutPending[PipeID] = TRUE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[PipeID], IrqFlags);
-
-	// Increase Total transmit byte counter
-	pAd->RalinkCounters.TransmittedByteCount +=  pRTSContext->BulkOutSize;
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutRTSFrame \n"));
-
-	// Clear RTS frame bulk flag
-	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_RTS);
-
-	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pRTSContext, PipeID, (usb_complete_t)RTUSBBulkOutRTSFrameComplete);
-	pRTSContext->IRPPending = TRUE;
-
-	pUrb = pRTSContext->pUrb;
-	if((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("RTUSBBulkOutRTSFrame: Submit Tx URB failed %d\n", ret));
-		return;
-	}
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, ("<---RTUSBBulkOutRTSFrame \n"));
-
-}
-
-// RTS frame use BulkOutPipeId = 0
-VOID RTUSBBulkOutRTSFrameComplete(purbb_t pUrb, struct pt_regs *pt_regs)
-{
-	PRTMP_ADAPTER	pAd;
-	PTX_CONTEXT		pRTSContext;
-	NTSTATUS		Status;
-#if 0 // sample, IRQ LOCK
-	unsigned long	IrqFlags;
-#endif
-	POS_COOKIE		pObj;
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutRTSFrameComplete\n"));
-
-	pRTSContext	= (PTX_CONTEXT)pUrb->context;
-	pAd			= pRTSContext->pAd;
-	Status		= pUrb->status;
-
-#if 0 // sample, IRQ LOCK
-	// Reset RTS frame context flags
-	pRTSContext->IRPPending = FALSE;
-	pRTSContext->InUse		= FALSE;
-
-	if (Status == USB_ST_NOERROR)
-	{
-		// Don't worry about the queue is empty or not, this function will check itself
-		//RTMPUSBDeQueuePacket(pAd, pRTSContext->BulkOutPipeId);
-		RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	}
-	else	// STATUS_OTHER
-	{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out RTS Frame Failed\n"));
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-	}
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId], IrqFlags);
-	pAd->BulkOutPending[pRTSContext->BulkOutPipeId] = FALSE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[pRTSContext->BulkOutPipeId], IrqFlags);
-
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
-#else
-
-	pObj = (POS_COOKIE) pAd->OS_Cookie;
-	pObj->rts_frame_complete_task.data = (unsigned long)pUrb;
-	tasklet_hi_schedule(&pObj->rts_frame_complete_task);
-#endif
-
-	DBGPRINT_RAW(RT_DEBUG_INFO, ("<---RTUSBBulkOutRTSFrameComplete\n"));
-
 }
-#endif
 
 /*
 	========================================================================
@@ -895,25 +620,6 @@ VOID	RTUSBBulkOutMLMEPacket(
 	// Clear MLME bulk flag
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
 
-
-	//DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutMLMEPacket\n"));
-#if 0 // for debug
-{
-	printk("MLME-Out, C=%d!, D=%d, F=%d!\n", pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx);
-
-	//TODO: Need to remove it when formal release
-	PTXINFO_STRUC pTxInfo;
-
-	pTxInfo = (PTXINFO_STRUC)pMLMEContext->TransferBuffer;
-	if (pTxInfo->QSEL != FIFO_EDCA)
-	{
-			printk("%s(): ====> pTxInfo->QueueSel(%d)!= FIFO_EDCA!!!!\n", __func__, pTxInfo->QSEL);
-			printk("\tMLME_Index=%d!\n", Index);
-			hex_dump("Wrong QSel Pkt:", (PUCHAR)pMLMEContext->TransferBuffer, pTxInfo->USBDMATxPktLen);
-	}
-}
-#endif
-
 	// Init Tx context descriptor
 	RTUSBInitTxDesc(pAd, pMLMEContext, MGMTPIPEIDX, (usb_complete_t)RTUSBBulkOutMLMEPacketComplete);
 
@@ -947,11 +653,6 @@ VOID RTUSBBulkOutMLMEPacketComplete(purb
 	NTSTATUS			Status;
 	POS_COOKIE 			pObj;
 	int					index;
-#if 0 // sample, IRQ LOCK
-	unsigned long		IrqFlags;
-	PNDIS_PACKET		pPacket;
-#endif
-
 
 	//DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutMLMEPacketComplete\n"));
 	pMLMEContext	= (PTX_CONTEXT)pUrb->context;
@@ -960,82 +661,8 @@ VOID RTUSBBulkOutMLMEPacketComplete(purb
 	Status			= pUrb->status;
 	index 			= pMLMEContext->SelfIdx;
 
-
-#if 0 // sample, IRQ LOCK
-	ASSERT((pAd->MgmtRing.TxDmaIdx == index));
-	//printk("MLME-Done-B: C=%d, D=%d, F=%d, Self=%d!\n", pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx, pMLMEContext->SelfIdx);
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-
-
-	if (Status != USB_ST_NOERROR)
-	{
-		//Bulk-Out fail status handle
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out MLME Failed, Status=%d!\n", Status));
-			// TODO: How to handle about the MLMEBulkOut failed issue. Need to resend the mgmt pkt?
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
-		}
-	}
-	pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-
-	RTMP_IRQ_LOCK(&pAd->MLMEBulkOutLock, IrqFlags);
-	// Reset MLME context flags
-	pMLMEContext->IRPPending = FALSE;
-	pMLMEContext->InUse = FALSE;
-	pMLMEContext->bWaitingBulkOut = FALSE;
-	pMLMEContext->BulkOutSize = 0;
-
-	pPacket = pAd->MgmtRing.Cell[index].pNdisPacket;
-	pAd->MgmtRing.Cell[index].pNdisPacket = NULL;
-
-	// Increase MgmtRing Index
-	INC_RING_INDEX(pAd->MgmtRing.TxDmaIdx, MGMT_RING_SIZE);
-	pAd->MgmtRing.TxSwFreeIdx++;
-
-	RTMP_IRQ_UNLOCK(&pAd->MLMEBulkOutLock, IrqFlags);
-
-	// No-matter success or fail, we free the mgmt packet.
-	if (pPacket)
-		RTMPFreeNdisPacket(pAd, pPacket);
-
-#if 0
-	//Bulk-Out fail status handle
-	if (Status != USB_ST_NOERROR)
-	{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out MLME Failed, Status=%d!\n", Status));
-			// TODO: How to handle about the MLMEBulkOut failed issue. Need to reset the endpoint?
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
-		}
-	}
-#endif
-
-	//printk("MLME-Done-A: C=%d, D=%d, F=%d!\n", pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx);
-
-	pObj->mgmt_dma_done_task.data = (unsigned long)pAd;
-	tasklet_hi_schedule(&pObj->mgmt_dma_done_task);
-
-	//DBGPRINT_RAW(RT_DEBUG_INFO, ("<---RTUSBBulkOutMLMEPacketComplete\n"));
-//	printk("<---RTUSBBulkOutMLMEPacketComplete, Cpu=%d, Dma=%d, SwIdx=%d!\n",
-//				pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx);
-
-#else
-
 	pObj->mgmt_dma_done_task.data = (unsigned long)pUrb;
 	tasklet_hi_schedule(&pObj->mgmt_dma_done_task);
-#endif
 }
 
 
@@ -1099,9 +726,6 @@ VOID RTUSBBulkOutPsPollComplete(purbb_t 
 	PRTMP_ADAPTER		pAd;
 	PTX_CONTEXT			pPsPollContext;
 	NTSTATUS			Status;
-#if 0 // sample, IRQ LOCK
-	unsigned long		IrqFlags;
-#endif
 	POS_COOKIE			pObj;
 
 
@@ -1109,251 +733,11 @@ VOID RTUSBBulkOutPsPollComplete(purbb_t 
 	pAd = pPsPollContext->pAd;
 	Status = pUrb->status;
 
-#if 0 // sample, IRQ LOCK
-	// Reset PsPoll context flags
-	pPsPollContext->IRPPending	= FALSE;
-	pPsPollContext->InUse		= FALSE;
-
-	if (Status == USB_ST_NOERROR)
-	{
-		// Don't worry about the queue is empty or not, this function will check itself
-		RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	}
-	else // STATUS_OTHER
-	{
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out PSPoll Failed\n"));
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-	}
-
-	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
-	pAd->BulkOutPending[0] = FALSE;
-	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
-
-	// Always call Bulk routine, even reset bulk.
-	// The protectioon of rest bulk should be in BulkOut routine
-	RTUSBKickBulkOut(pAd);
-#else
-
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 	pObj->pspoll_frame_complete_task.data = (unsigned long)pUrb;
 	tasklet_hi_schedule(&pObj->pspoll_frame_complete_task);
-#endif
 }
 
-
-#if 0
-/*
-	========================================================================
-
-	Routine Description:
-	USB_RxPacket initializes a URB and uses the Rx IRP to submit it
-	to USB. It checks if an Rx Descriptor is available and passes the
-	the coresponding buffer to be filled. If no descriptor is available
-	fails the request. When setting the completion routine we pass our
-	Adapter Object as Context.
-
-	Arguments:
-
-	Return Value:
-		TRUE			found matched tuple cache
-		FALSE			no matched found
-
-	Note:
-
-	========================================================================
-*/
-VOID	RTUSBBulkReceive(
-	IN	PRTMP_ADAPTER	pAd)
-{
-	PRX_CONTEXT		pRxContext;
-	PURB			pUrb;
-	int				ret = 0;
-	unsigned long	IrqFlags;
-
-
-	/* device had been closed */
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
-		return;
-
-	RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-
-	// Last is time point between 2 separate URB.
-	if (pAd->NextRxBulkInPosition == 0)
-	{
-		//pAd->NextRxBulkInIndex = (pAd->NextRxBulkInIndex + 1) % (RX_RING_SIZE);
-		INC_RING_INDEX(pAd->NextRxBulkInIndex, RX_RING_SIZE);
-	}
-	else if ((pAd->NextRxBulkInPosition&0x1ff) != 0)
-	{
-		//pAd->NextRxBulkInIndex = (pAd->NextRxBulkInIndex + 1) % (RX_RING_SIZE);
-		INC_RING_INDEX(pAd->NextRxBulkInIndex, RX_RING_SIZE);
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("pAd->NextRxBulkInPosition = 0x%lx.  End of URB.\n", pAd->NextRxBulkInPosition ));
-		pAd->NextRxBulkInPosition = 0;
-	}
-
-	if (pAd->NextRxBulkInPosition == MAX_RXBULK_SIZE)
-		pAd->NextRxBulkInPosition = 0;
-
-	pRxContext = &(pAd->RxContext[pAd->NextRxBulkInIndex]);
-
-	// TODO: Why need to check if pRxContext->InUsed == TRUE?
-	//if ((pRxContext->InUse == TRUE) || (pRxContext->Readable == TRUE))
-	if ((pRxContext->InUse == FALSE) && (pRxContext->Readable == TRUE))
-	{
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("pRxContext[%d] InUse = %d.pRxContext->Readable = %d.  Return.\n", pAd->NextRxBulkInIndex,pRxContext->InUse, pRxContext->Readable ));
-		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-
-		// read RxContext, Since not
-		STARxDoneInterruptHandle(pAd, TRUE);
-
-		//return;
-	}
-	pRxContext->InUse = TRUE;
-	pRxContext->IRPPending= TRUE;
-
-	RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-
-	// Init Rx context descriptor
-	NdisZeroMemory(pRxContext->TransferBuffer, BUFFER_SIZE);
-	RTUSBInitRxDesc(pAd, pRxContext);
-
-	pUrb = pRxContext->pUrb;
-	if ((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("RTUSBBulkReceive: Submit Rx URB failed %d\n", ret));
-		return;
-	}
-	else // success
-	{
-		NdisInterlockedIncrement(&pAd->PendingRx);
-		pAd->BulkInReq++;
-	}
-
-	// read RxContext, Since not
-	STARxDoneInterruptHandle(pAd, FALSE);
-}
-
-/*
-	========================================================================
-
-	Routine Description:
-		This routine process Rx Irp and call rx complete function.
-
-	Arguments:
-		DeviceObject	Pointer to the device object for next lower
-						device. DeviceObject passed in here belongs to
-						the next lower driver in the stack because we
-						were invoked via IoCallDriver in USB_RxPacket
-						AND it is not OUR device object
-	  Irp				Ptr to completed IRP
-	  Context			Ptr to our Adapter object (context specified
-						in IoSetCompletionRoutine
-
-	Return Value:
-		Always returns STATUS_MORE_PROCESSING_REQUIRED
-
-	Note:
-		Always returns STATUS_MORE_PROCESSING_REQUIRED
-	========================================================================
-*/
-VOID RTUSBBulkRxComplete(purbb_t pUrb, struct pt_regs *pt_regs)
-{
-#if 0
-	PRX_CONTEXT			pRxContext;
-	PRTMP_ADAPTER		pAd;
-	NTSTATUS			Status;
-//	POS_COOKIE			pObj;
-
-	pRxContext	= (PRX_CONTEXT)pUrb->context;
-	pAd 		= pRxContext->pAd;
-//	pObj		= (POS_COOKIE) pAd->OS_Cookie;
-
-
-	Status = pUrb->status;
-	//pRxContext->pIrp = NULL;
-
-	pRxContext->InUse = FALSE;
-	pRxContext->IRPPending = FALSE;
-
-	if (Status == USB_ST_NOERROR)
-	{
-		pAd->BulkInComplete++;
-		pRxContext->Readable = TRUE;
-		pAd->NextRxBulkInPosition = 0;
-
-	}
-	else	 // STATUS_OTHER
-	{
-		pAd->BulkInCompleteFail++;
-		// Still read this packet although it may comtain wrong bytes.
-		pRxContext->Readable = FALSE;
-		// Parsing all packets. because after reset, the index will reset to all zero.
-
-		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-		{
-
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk In Failed. Status = %d\n", Status));
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("==>NextRxBulkInIndex=0x%x, NextRxBulkInReadIndex=0x%x, TransferBufferLength= 0x%x\n",
-				pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex, pRxContext->pUrb->actual_length));
-
-			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_IN, NULL, 0);
-		}
-		//pUrb = NULL;
-	}
-
-	if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET)) &&
-//		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) &&
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) &&
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-	{
-		RTUSBBulkReceive(pAd);
-#if 0
-#if 1
-		STARxDoneInterruptHandle(pAd, FALSE);
-#else
-		pObj->rx_bh.data = (unsigned long)pUrb;
-		tasklet_schedule(&pObj->rx_bh);
-#endif
-#endif
-	}
-
-	// Call RxPacket to process packet and return the status
-	NdisInterlockedDecrement(&pAd->PendingRx);
-#else
-
-
-	// use a receive tasklet to handle received packets;
-	// or sometimes hardware IRQ will be disabled here, so we can not
-	// use spin_lock_bh()/spin_unlock_bh() after IRQ is disabled. :<
-	PRX_CONTEXT		pRxContext;
-	PRTMP_ADAPTER	pAd;
-	POS_COOKIE 		pObj;
-
-
-	pRxContext	= (PRX_CONTEXT)pUrb->context;
-	pAd 		= pRxContext->pAd;
-	pObj 		= (POS_COOKIE) pAd->OS_Cookie;
-
-	pObj->rx_done_task.data = (unsigned long)pUrb;
-	tasklet_hi_schedule(&pObj->rx_done_task);
-#endif
-}
-
-#else
-
 VOID DoBulkIn(IN RTMP_ADAPTER *pAd)
 {
 	PRX_CONTEXT		pRxContext;
@@ -1392,14 +776,6 @@ VOID DoBulkIn(IN RTMP_ADAPTER *pAd)
 	}
 	else
 	{	// success
-#if 0
-		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-		pRxContext->IRPPending = TRUE;
-		//NdisInterlockedIncrement(&pAd->PendingRx);
-		pAd->PendingRx++;
-		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-		pAd->BulkInReq++;
-#endif
 		ASSERT((pRxContext->InUse == pRxContext->IRPPending));
 		//printk("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n", pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex);
 	}
@@ -1527,8 +903,6 @@ VOID RTUSBBulkRxComplete(purbb_t pUrb, s
 
 }
 
-#endif
-
 
 
 /*
@@ -1551,46 +925,6 @@ VOID	RTUSBKickBulkOut(
 	if (!RTMP_TEST_FLAG(pAd ,fRTMP_ADAPTER_NEED_STOP_TX)
 		)
 	{
-#if 0	// not used now in RT28xx, but may used latter.
-		// 1. Data Fragment has highest priority
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_FRAG))
-		{
-			if (((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
-				(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				))
-			{
-				RTUSBBulkOutDataPacket(pAd, 0, pAd->NextBulkOutIndex[0]);
-			}
-		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_FRAG_2))
-		{
-			if (((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
-				(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				))
-			{
-				RTUSBBulkOutDataPacket(pAd, 1, pAd->NextBulkOutIndex[1]);
-			}
-		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_FRAG_3))
-		{
-			if (((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
-				(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				))
-			{
-				RTUSBBulkOutDataPacket(pAd, 2, pAd->NextBulkOutIndex[2]);
-			}
-		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_FRAG_4))
-		{
-			if (((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
-				(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				))
-			{
-				RTUSBBulkOutDataPacket(pAd, 3, pAd->NextBulkOutIndex[3]);
-			}
-		}
-#endif
-
 		// 2. PS-Poll frame is next
 		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL))
 		{
@@ -1711,24 +1045,6 @@ VOID	RTUSBCleanUpMLMEBulkOutQueue(
 	IN	PRTMP_ADAPTER	pAd)
 {
 	DBGPRINT(RT_DEBUG_TRACE, ("--->CleanUpMLMEBulkOutQueue\n"));
-
-#if 0	// Do nothing!
-	NdisAcquireSpinLock(&pAd->MLMEBulkOutLock);
-	while (pAd->PrioRingTxCnt > 0)
-	{
-		pAd->MLMEContext[pAd->PrioRingFirstIndex].InUse = FALSE;
-
-		pAd->PrioRingFirstIndex++;
-		if (pAd->PrioRingFirstIndex >= MGMT_RING_SIZE)
-		{
-			pAd->PrioRingFirstIndex = 0;
-		}
-
-		pAd->PrioRingTxCnt--;
-	}
-	NdisReleaseSpinLock(&pAd->MLMEBulkOutLock);
-#endif
-
 	DBGPRINT(RT_DEBUG_TRACE, ("<---CleanUpMLMEBulkOutQueue\n"));
 }
 
--- a/drivers/staging/rt2870/common/rtusb_data.c
+++ b/drivers/staging/rt2870/common/rtusb_data.c
@@ -135,24 +135,11 @@ BOOLEAN	RTUSBNeedQueueBackForAgg(
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
 	if ((pHTTXContext->IRPPending == TRUE)  /*&& (pAd->TxSwQueue[BulkOutPipeId].Number == 0) */)
 	{
-#if 0
-		if ((pHTTXContext->CurWritePosition <= 8) &&
-			(pHTTXContext->NextBulkOutPosition > 8 && (pHTTXContext->NextBulkOutPosition+MAX_AGGREGATION_SIZE) < MAX_TXBULK_LIMIT))
-		{
-			needQueBack = TRUE;
-		}
-		else if ((pHTTXContext->CurWritePosition < pHTTXContext->NextBulkOutPosition) &&
-				 ((pHTTXContext->NextBulkOutPosition + MAX_AGGREGATION_SIZE) < MAX_TXBULK_LIMIT))
-		{
-			needQueBack = TRUE;
-		}
-#else
 		if ((pHTTXContext->CurWritePosition < pHTTXContext->ENextBulkOutPosition) &&
 			(((pHTTXContext->ENextBulkOutPosition+MAX_AGGREGATION_SIZE) < MAX_TXBULK_LIMIT) || (pHTTXContext->CurWritePosition > MAX_AGGREGATION_SIZE)))
 		{
 			needQueBack = TRUE;
 		}
-#endif
 		else if ((pHTTXContext->CurWritePosition > pHTTXContext->ENextBulkOutPosition) &&
 				 ((pHTTXContext->ENextBulkOutPosition + MAX_AGGREGATION_SIZE) < pHTTXContext->CurWritePosition))
 		{
--- a/drivers/staging/rt2870/common/rtusb_io.c
+++ b/drivers/staging/rt2870/common/rtusb_io.c
@@ -1222,28 +1222,6 @@ NTSTATUS    RTUSB_VendorRequest(
 			if ((TransferBuffer!= NULL) && (TransferBufferLength > 0))
 				hex_dump("Failed TransferBuffer value", TransferBuffer, TransferBufferLength);
         }
-
-#if 0
-        // retry
-		if (ret < 0) {
-			int temp_i=0;
-			DBGPRINT(RT_DEBUG_ERROR, ("USBVendorRequest failed ret=%d, \n",ret));
-			ret = 0;
-			do
-			{
-				if( RequestType == DEVICE_VENDOR_REQUEST_OUT)
-					ret=usb_control_msg(pObj->pUsb_Dev, usb_sndctrlpipe( pObj->pUsb_Dev, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
-				else if(RequestType == DEVICE_VENDOR_REQUEST_IN)
-					ret=usb_control_msg(pObj->pUsb_Dev, usb_rcvctrlpipe( pObj->pUsb_Dev, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
-				temp_i++;
-			} while( (ret < 0) && (temp_i <= 1) );
-
-			if( ret >= 0)
-				return ret;
-
-		}
-#endif
-
 	}
 	return ret;
 }
@@ -1621,15 +1599,6 @@ VOID CMDHandler(
 								}
 								else
 								{	// success
-#if 0
-									RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-									pRxContext->IRPPending = TRUE;
-									//NdisInterlockedIncrement(&pAd->PendingRx);
-									pAd->PendingRx++;
-									RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-									pAd->BulkInReq++;
-#endif
-									//printk("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n", pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex);
 									DBGPRINT_RAW(RT_DEBUG_TRACE, ("CMDTHREAD_RESET_BULK_IN: Submit Rx URB Done, status=%d!\n", pUrb->status));
 									ASSERT((pRxContext->InUse == pRxContext->IRPPending));
 								}
--- a/drivers/staging/rt2870/mlme.h
+++ b/drivers/staging/rt2870/mlme.h
@@ -39,8 +39,6 @@
 #ifndef __MLME_H__
 #define __MLME_H__
 
-//extern UCHAR BROADCAST_ADDR[];
-
 // maximum supported capability information -
 // ESS, IBSS, Privacy, Short Preamble, Spectrum mgmt, Short Slot
 #define SUPPORTED_CAPABILITY_INFO   0x0533
@@ -51,7 +49,6 @@
 #define LEAD_TIME                   5
 #define MLME_TASK_EXEC_MULTIPLE       10  /*5*/       // MLME_TASK_EXEC_MULTIPLE * MLME_TASK_EXEC_INTV = 1 sec
 #define REORDER_EXEC_INTV         	100       // 0.1 sec
-//#define TBTT_PRELOAD_TIME         384        // usec. LomgPreamble + 24-byte at 1Mbps
 
 // The definition of Radar detection duration region
 #define CE		0
@@ -106,13 +103,6 @@
 #define TX_WEIGHTING                     30
 #define RX_WEIGHTING                     20
 
-//#define PEER_KEY_NOT_USED                0
-//#define PEER_KEY_64_BIT                  64
-//#define PEER_KEY_128_BIT                 128
-
-//#define PEER_KEY_64BIT_LEN               8
-//#define PEER_KEY_128BIT_LEN              16
-
 #define BSS_NOT_FOUND                    0xFFFFFFFF
 
 #define MAX_LEN_OF_MLME_QUEUE            40 //10
@@ -125,7 +115,6 @@
 #define	SCAN_CISCO_CHANNEL_LOAD			 23		// Single channel passive scan for channel load collection
 #define FAST_SCAN_ACTIVE                 24		// scan with probe request, and wait beacon and probe response
 
-//#define BSS_TABLE_EMPTY(x)             ((x).BssNr == 0)
 #define MAC_ADDR_IS_GROUP(Addr)       (((Addr[0]) & 0x01))
 #define MAC_ADDR_HASH(Addr)            (Addr[0] ^ Addr[1] ^ Addr[2] ^ Addr[3] ^ Addr[4] ^ Addr[5])
 #define MAC_ADDR_HASH_INDEX(Addr)      (MAC_ADDR_HASH(Addr) % HASH_TABLE_SIZE)
@@ -157,8 +146,6 @@
 
 #define CAP_GENERATE(ess,ibss,priv,s_pre,s_slot,spectrum)  (((ess) ? 0x0001 : 0x0000) | ((ibss) ? 0x0002 : 0x0000) | ((priv) ? 0x0010 : 0x0000) | ((s_pre) ? 0x0020 : 0x0000) | ((s_slot) ? 0x0400 : 0x0000) | ((spectrum) ? 0x0100 : 0x0000))
 
-//#define STA_QOS_CAPABILITY               0 // 1-byte. see 802.11e d9.0 for bit definition
-
 #define ERP_IS_NON_ERP_PRESENT(x)        (((x) & 0x01) != 0)    // 802.11g
 #define ERP_IS_USE_PROTECTION(x)         (((x) & 0x02) != 0)    // 802.11g
 #define ERP_IS_USE_BARKER_PREAMBLE(x)    (((x) & 0x04) != 0)    // 802.11g
@@ -401,12 +388,6 @@ typedef struct {
 //This structure substracts ralink supports from all 802.11n-related features.
 //Features not listed here but contained in 802.11n spec are not supported in rt2860.
 typedef struct {
-#if 0	// move to
-	BOOLEAN			bHtEnable;	 // If we should use ht rate.
-	BOOLEAN			bPreNHt;	 // If we should use ht rate.
-	//Substract from HT Capability IE
-	UCHAR			MCSSet[16];	//only supoort MCS=0-15,32 ,
-#endif
 	USHORT	ChannelWidth:1;
 	USHORT	MimoPs:2;//mimo power safe MMPS_
 	USHORT	GF:1;	//green field
@@ -1099,11 +1080,6 @@ typedef struct PACKED _RTMP_TX_RATE_SWIT
 #define TBTT_PRELOAD_TIME       384        // usec. LomgPreamble + 24-byte at 1Mbps
 #define DEFAULT_DTIM_PERIOD     1
 
-// weighting factor to calculate Channel quality, total should be 100%
-//#define RSSI_WEIGHTING                   0
-//#define TX_WEIGHTING                     40
-//#define RX_WEIGHTING                     60
-
 #define MAC_TABLE_AGEOUT_TIME			300			// unit: sec
 #define MAC_TABLE_ASSOC_TIMEOUT			5			// unit: sec
 #define MAC_TABLE_FULL(Tab)				((Tab).size == MAX_LEN_OF_MAC_TABLE)
--- a/drivers/staging/rt2870/oid.h
+++ b/drivers/staging/rt2870/oid.h
@@ -585,19 +585,6 @@ typedef struct _NDIS_802_11_AUTHENTICATI
     NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
 } NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
 
-/*
-typedef struct _NDIS_802_11_TEST
-{
-    ULONG Length;
-    ULONG Type;
-    union
-    {
-        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
-        NDIS_802_11_RSSI RssiTrigger;
-    };
-} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
- */
-
 // 802.11 Media stream constraints, associated with OID_802_11_MEDIA_STREAM_MODE
 typedef enum _NDIS_802_11_MEDIA_STREAM_MODE
 {
@@ -691,7 +678,6 @@ typedef union  _HTTRANSMIT_SETTING {
 	USHORT		BW:1;	//channel bandwidth 20MHz or 40 MHz
 	USHORT		ShortGI:1;
 	USHORT		STBC:2;	//SPACE
-//	USHORT		rsv:3;
 	USHORT		rsv:2;
 	USHORT		TxBF:1;
 	USHORT		MODE:2;	// Use definition MODE_xxx.
@@ -779,15 +765,6 @@ typedef struct _RT_802_11_HARDWARE_REGIS
     ULONG   Data;               // R/W data buffer
 } RT_802_11_HARDWARE_REGISTER, *PRT_802_11_HARDWARE_REGISTER;
 
-// structure to tune BBP R17 "RX AGC VGC init"
-//typedef struct _RT_802_11_RX_AGC_VGC_TUNING {
-//    UCHAR   FalseCcaLowerThreshold;  // 0-255, def 10
-//    UCHAR   FalseCcaUpperThreshold;  // 0-255, def 100
-//    UCHAR   VgcDelta;                // R17 +-= VgcDelta whenever flase CCA over UpprThreshold
-//                                     // or lower than LowerThresholdupper threshold
-//    UCHAR   VgcUpperBound;           // max value of R17
-//} RT_802_11_RX_AGC_VGC_TUNING, *PRT_802_11_RX_AGC_VGC_TUNING;
-
 typedef struct _RT_802_11_AP_CONFIG {
     ULONG   EnableTxBurst;      // 0-disable, 1-enable
     ULONG   EnableTurboRate;    // 0-disable, 1-enable 72/100mbps turbo rate
--- a/drivers/staging/rt2870/rt2870.h
+++ b/drivers/staging/rt2870/rt2870.h
@@ -219,19 +219,8 @@ typedef	struct	_MGMT_STRUC	{
 
 
 /* ----------------- Frimware Related MACRO ----------------- */
-#if 0
-#define RT28XX_FIRMUD_INIT(pAd)		\
-	{	UINT32	MacReg;				\
-		RTUSBReadMACRegister(pAd, MAC_CSR0, &MacReg); }
-
-#define RT28XX_FIRMUD_END(pAd)	\
-	RTUSBWriteMACRegister(pAd, 0x7014, 0xffffffff);	\
-	RTUSBWriteMACRegister(pAd, 0x701c, 0xffffffff);	\
-	RTUSBFirmwareRun(pAd);
-#else
 #define RT28XX_WRITE_FIRMWARE(_pAd, _pFwImage, _FwLen)		\
 	RTUSBFirmwareWrite(_pAd, _pFwImage, _FwLen)
-#endif
 
 /* ----------------- TX Related MACRO ----------------- */
 #define RT28XX_START_DEQUEUE(pAd, QueIdx, irqFlags)				\
@@ -316,13 +305,6 @@ extern UCHAR EpToQueue[6];
 /* ----------------- RX Related MACRO ----------------- */
 //#define RT28XX_RX_ERROR_CHECK				RTMPCheckRxWI
 
-#if 0
-#define RT28XX_RCV_INIT(pAd)					\
-	pAd->TransferBufferLength = 0;				\
-	pAd->ReadPosition = 0;						\
-	pAd->pCurrRxContext = NULL;
-#endif
-
 #define RT28XX_RV_ALL_BUF_END(bBulkReceive)		\
 	/* We return STATUS_MORE_PROCESSING_REQUIRED so that the completion */	\
 	/* routine (IofCompleteRequest) will stop working on the irp. */		\
@@ -330,27 +312,6 @@ extern UCHAR EpToQueue[6];
 
 
 /* ----------------- ASIC Related MACRO ----------------- */
-#if 0
-#define RT28XX_DMA_WRITE_INIT(GloCfg)			\
-	{	GloCfg.field.EnTXWriteBackDDONE = 1;	\
-		GloCfg.field.EnableRxDMA = 1;			\
-		GloCfg.field.EnableTxDMA = 1; }
-
-#define RT28XX_DMA_POST_WRITE(_pAd)				\
-	do{	USB_DMA_CFG_STRUC	UsbCfg;				\
-		UsbCfg.word = 0;						\
-		/* for last packet, PBF might use more than limited, so minus 2 to prevent from error */ \
-		UsbCfg.field.RxBulkAggLmt = (MAX_RXBULK_SIZE /1024)-3;	\
-		UsbCfg.field.phyclear = 0;								\
-		/* usb version is 1.1,do not use bulk in aggregation */	\
-		if (_pAd->BulkInMaxPacketSize == 512)					\
-			UsbCfg.field.RxBulkAggEn = 1;						\
-		UsbCfg.field.RxBulkEn = 1;								\
-		UsbCfg.field.TxBulkEn = 1;								\
-		UsbCfg.field.RxBulkAggTOut = 0x80; /* 2006-10-18 */		\
-		RTUSBWriteMACRegister(_pAd, USB_DMA_CFG, UsbCfg.word); 	\
-	}while(0)
-#endif
 
 // reset MAC of a station entry to 0xFFFFFFFFFFFF
 #define RT28XX_STA_ENTRY_MAC_RESET(pAd, Wcid)					\
--- a/drivers/staging/rt2870/rt28xx.h
+++ b/drivers/staging/rt2870/rt28xx.h
@@ -963,21 +963,6 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 #define HW_DEBUG_SETTING_BASE   0x77f0  // 0x77f0~0x77ff total 16 bytes
 #define HW_DEBUG_SETTING_BASE2   0x7770  // 0x77f0~0x77ff total 16 bytes
 
-#if 0
-// on-chip BEACON frame space - base address = 0x7800
-#define HW_BEACON_MAX_SIZE      0x0800 /* unit: byte */
-#define HW_BEACON_BASE0         0x7800
-#define HW_BEACON_BASE1         0x7900
-#define HW_BEACON_BASE2         0x7a00
-#define HW_BEACON_BASE3         0x7b00
-#define HW_BEACON_BASE4         0x7c00
-#define HW_BEACON_BASE5         0x7d00
-#define HW_BEACON_BASE6         0x7e00
-#define HW_BEACON_BASE7         0x7f00
-/* 1. HW_BEACON_OFFSET/64B must be 0;
-   2. BCN_OFFSET0 must also be changed in NICInitializeAsic();
-   3. max 0x0800 for 8 beacon frames; */
-#else
 // In order to support maximum 8 MBSS and its maximum length is 512 for each beacon
 // Three section discontinue memory segments will be used.
 // 1. The original region for BCN 0~3
@@ -994,7 +979,6 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 #define HW_BEACON_BASE5         0x7400
 #define HW_BEACON_BASE6         0x5DC0
 #define HW_BEACON_BASE7         0x5BC0
-#endif
 
 #define HW_BEACON_MAX_COUNT     8
 #define HW_BEACON_OFFSET		0x0200
@@ -1029,11 +1013,6 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 #define MAX_FIRMWARE_IMAGE_SIZE 0x1000    // 4kbyte
 #endif // RT2870 //
 
-// TODO: ????? old RT2560 registers. to keep them or remove them?
-//#define MCAST0                  0x0178  // multicast filter register 0
-//#define MCAST1                  0x017c  // multicast filter register 1
-
-
 // ================================================================
 // Tx /	Rx / Mgmt ring descriptor definition
 // ================================================================
@@ -1047,18 +1026,7 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 #define PID_DATA_AMPDU	 	0x04
 #define PID_DATA_NO_ACK    	0x08
 #define PID_DATA_NOT_NORM_ACK	 	0x03
-#if 0
-#define PTYPE_DATA_REQUIRE_ACK  0x00 // b7-6:00, b5-0: 0~59 is MAC table index (AID?), 60~63 is WDS index
-#define PTYPE_NULL_AT_HIGH_RATE 0x04 // b7-6:01, b5-0: 0~59 is MAC table index (AID?), 60~63 is WDS index
-#define PTYPE_RESERVED          0x08 // b7-6:10
-#define PTYPE_SPECIAL           0x0c // b7-6:11
-
-// when b3-2=11 (PTYPE_SPECIAL), b1-0 coube be ...
-#define PSUBTYPE_DATA_NO_ACK    0x00
-#define PSUBTYPE_MGMT           0x01
-#define PSUBTYPE_OTHER_CNTL     0x02
-#define PSUBTYPE_RTS            0x03
-#endif
+
 // value domain of pTxD->HostQId (4-bit: 0~15)
 #define QID_AC_BK               1   // meet ACI definition in 802.11e
 #define QID_AC_BE               0   // meet ACI definition in 802.11e
@@ -1167,11 +1135,6 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 
 #define BBPR94_DEFAULT              0x06 // Add 1 value will gain 1db
 
-//#define PHY_TR_SWITCH_TIME          5  // usec
-
-//#define BBP_R17_LOW_SENSIBILITY     0x50
-//#define BBP_R17_MID_SENSIBILITY     0x41
-//#define BBP_R17_DYNAMIC_UP_BOUND    0x40
 #define RSSI_FOR_VERY_LOW_SENSIBILITY -35
 #define RSSI_FOR_LOW_SENSIBILITY      -58
 #define RSSI_FOR_MID_LOW_SENSIBILITY  -80
@@ -1211,12 +1174,6 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 #define EEPROM_TXPOWER_BYRATE_40MHZ_5G		0x10a	// 40MHZ 5G tx power.
 #define EEPROM_A_TX_PWR_OFFSET      0x78
 #define EEPROM_A_TX2_PWR_OFFSET      0xa6
-//#define EEPROM_Japan_TX_PWR_OFFSET      0x90 // 802.11j
-//#define EEPROM_Japan_TX2_PWR_OFFSET      0xbe
-//#define EEPROM_TSSI_REF_OFFSET	0x54
-//#define EEPROM_TSSI_DELTA_OFFSET	0x24
-//#define EEPROM_CCK_TX_PWR_OFFSET  0x62
-//#define EEPROM_CALIBRATE_OFFSET	0x7c
 #define EEPROM_VERSION_OFFSET       0x02
 #define	EEPROM_FREQ_OFFSET			0x3a
 #define EEPROM_TXPOWER_BYRATE 	0xde	// 20MHZ power.
@@ -1320,7 +1277,6 @@ typedef	struct	PACKED _TXWI_STRUC {
 	UINT32		ShortGI:1;
 	UINT32		STBC:2;	// 1: STBC support MCS =0-7,   2,3 : RESERVE
 	UINT32		Ifs:1;	//
-//	UINT32		rsv2:2;	//channel bandwidth 20MHz or 40 MHz
 	UINT32		rsv2:1;
 	UINT32		TxBF:1;	// 3*3
 	UINT32		PHYMODE:2;
--- a/drivers/staging/rt2870/rt_linux.c
+++ b/drivers/staging/rt2870/rt_linux.c
@@ -30,7 +30,6 @@
 ULONG	RTDebugLevel = RT_DEBUG_ERROR;
 
 BUILD_TIMER_FUNCTION(MlmePeriodicExec);
-//BUILD_TIMER_FUNCTION(MlmeRssiReportExec);
 BUILD_TIMER_FUNCTION(AsicRxAntEvalTimeout);
 BUILD_TIMER_FUNCTION(APSDPeriodicExec);
 BUILD_TIMER_FUNCTION(AsicRfTuningExec);
@@ -515,17 +514,6 @@ PNDIS_PACKET DuplicatePacket(
 		pRetPacket = OSPKT_TO_RTPKT(skb);
 	}
 
-#if 0
-	if ((skb = __dev_alloc_skb(DataSize + 2+32, MEM_ALLOC_FLAG)) != NULL)
-	{
-		skb_reserve(skb, 2+32);
-		NdisMoveMemory(skb->tail, pData, DataSize);
-		skb_put(skb, DataSize);
-		skb->dev = get_netdev_from_bssid(pAd, FromWhichBSSID);
-		pRetPacket = OSPKT_TO_RTPKT(skb);
-	}
-#endif
-
 	return pRetPacket;
 
 }
@@ -580,31 +568,6 @@ PNDIS_PACKET duplicate_pkt_with_TKIP_MIC
 	}
 
 	return OSPKT_TO_RTPKT(skb);
-
-#if 0
-	if ((data = skb_put(skb, TKIP_TX_MIC_SIZE)) != NULL)
-	{	// If we can extend it, well, copy it first.
-		NdisMoveMemory(data, pAd->PrivateInfo.Tx.MIC, TKIP_TX_MIC_SIZE);
-	}
-	else
-	{
-		// Otherwise, copy the packet.
-		newskb = skb_copy_expand(skb, skb_headroom(skb), TKIP_TX_MIC_SIZE, GFP_ATOMIC);
-		dev_kfree_skb_any(skb);
-		if (newskb == NULL)
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("Extend Tx.MIC to packet failed!, dropping packet\n"));
-			return NULL;
-		}
-		skb = newskb;
-
-		NdisMoveMemory(skb->tail, pAd->PrivateInfo.Tx.MIC, TKIP_TX_MIC_SIZE);
-		skb_put(skb, TKIP_TX_MIC_SIZE);
-	}
-
-	return OSPKT_TO_RTPKT(skb);
-#endif
-
 }
 
 
@@ -700,9 +663,6 @@ void announce_802_3_packet(
 #else
 	pRxPkt->protocol = eth_type_trans(pRxPkt, pRxPkt->dev);
 
-//#ifdef CONFIG_5VT_ENHANCE
-//	*(int*)(pRxPkt->cb) = BRIDGE_TAG;
-//#endif
 	netif_rx(pRxPkt);
 #endif // IKANOS_VX_1X0 //
 }
--- a/drivers/staging/rt2870/rt_linux.h
+++ b/drivers/staging/rt2870/rt_linux.h
@@ -200,9 +200,6 @@ typedef char				NDIS_PACKET;
 typedef PNDIS_PACKET		* PPNDIS_PACKET;
 typedef	dma_addr_t			NDIS_PHYSICAL_ADDRESS;
 typedef	dma_addr_t			* PNDIS_PHYSICAL_ADDRESS;
-//typedef struct timer_list	RALINK_TIMER_STRUCT;
-//typedef struct timer_list	* PRALINK_TIMER_STRUCT;
-//typedef struct os_lock		NDIS_SPIN_LOCK;
 typedef spinlock_t			NDIS_SPIN_LOCK;
 typedef struct timer_list	NDIS_MINIPORT_TIMER;
 typedef void				* NDIS_HANDLE;
@@ -300,8 +297,6 @@ typedef struct _RT2870_TIMER_ENTRY_
 typedef struct _RT2870_TIMER_QUEUE_
 {
 	unsigned int		status;
-	//wait_queue_head_t 	timerWaitQ;
-	//atomic_t			count;
 	UCHAR				*pTimerQPoll;
 	RT2870_TIMER_ENTRY	*pQPollFreeList;
 	RT2870_TIMER_ENTRY 	*pQHead;
@@ -373,20 +368,6 @@ extern ULONG    RTDebugLevel;
 	spin_unlock_bh((spinlock_t *)(__lock));				\
 }
 
-#if 0 // sample, IRQ LOCK
-#define RTMP_IRQ_LOCK(__lock, __irqflags)					\
-{													\
-	spin_lock_irqsave((spinlock_t *)__lock, __irqflags);	\
-	pAd->irq_disabled |= 1; \
-}
-
-#define RTMP_IRQ_UNLOCK(__lock, __irqflag)						\
-{														\
-	pAd->irq_disabled &= 0; \
-	spin_unlock_irqrestore((spinlock_t *)(__lock), ((unsigned long)__irqflag));	\
-}
-#else
-
 // sample, use semaphore lock to replace IRQ lock, 2007/11/15
 #define RTMP_IRQ_LOCK(__lock, __irqflags)			\
 {													\
@@ -410,7 +391,6 @@ extern ULONG    RTDebugLevel;
 {													\
 	spin_unlock_irqrestore((spinlock_t *)(__lock), ((unsigned long)__irqflag));	\
 }
-#endif
 
 
 
@@ -598,7 +578,6 @@ void RTMP_GetCurrentSystemTime(LARGE_INT
 //   check DDK NDIS_PACKET data structure and find out only MiniportReservedEx[0..7] can be used by our driver without
 //   ambiguity. Fields after pPacket->MiniportReservedEx[8] may be used by other wrapper layer thus crashes the driver
 //
-//#define RTMP_GET_PACKET_MR(_p)			(RTPKT_TO_OSPKT(_p))
 
 // User Priority
 #define RTMP_SET_PACKET_UP(_p, _prio)			(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+0] = _prio)
@@ -640,16 +619,7 @@ void RTMP_GetCurrentSystemTime(LARGE_INT
 #define RTMP_SET_PACKET_MOREDATA(_p, _morebit)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+7] = _morebit)
 #define RTMP_GET_PACKET_MOREDATA(_p)				(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+7])
 
-//#define RTMP_SET_PACKET_NET_DEVICE_MBSSID(_p, _bss)	(RTPKT_TO_OSPKT(_p)->cb[8] = _bss)
-//#define RTMP_GET_PACKET_NET_DEVICE_MBSSID(_p)		(RTPKT_TO_OSPKT(_p)->cb[8])
-
-
 
-
-#if 0
-//#define RTMP_SET_PACKET_DHCP(_p, _flg)   	(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] = _flg)
-//#define RTMP_GET_PACKET_DHCP(_p)         	(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11])
-#else
 //
 //	Sepcific Pakcet Type definition
 //
@@ -729,8 +699,6 @@ void RTMP_GetCurrentSystemTime(LARGE_INT
 
 #define RTMP_GET_PACKET_IPV4(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & RTMP_PACKET_SPECIFIC_IPV4)
 
-#endif
-
 
 // If this flag is set, it indicates that this EAPoL frame MUST be clear.
 #define RTMP_SET_PACKET_CLEAR_EAP_FRAME(_p, _flg)   (RTPKT_TO_OSPKT(_p)->cb[CB_OFF+12] = _flg)
--- a/drivers/staging/rt2870/rt_main_dev.c
+++ b/drivers/staging/rt2870/rt_main_dev.c
@@ -68,7 +68,6 @@ static int rt28xx_init(IN struct net_dev
 INT rt28xx_send_packets(IN struct sk_buff *skb_p, IN struct net_device *net_dev);
 
 static void CfgInitHook(PRTMP_ADAPTER pAd);
-//static BOOLEAN RT28XXAvailRANameAssign(IN CHAR *name_p);
 
 extern	const struct iw_handler_def rt28xx_iw_handler_def;
 
@@ -288,9 +287,6 @@ int rt28xx_close(IN PNET_DEV dev)
 	remove_wait_queue (&unlink_wakeup, &wait);
 #endif // RT2870 //
 
-	//RTUSBCleanUpMLMEWaitQueue(pAd);	/*not used in RT28xx*/
-
-
 #ifdef RT2870
 	// We need clear timerQ related structure before exits of the timer thread.
 	RT2870_TimerQ_Exit(pAd);
@@ -400,9 +396,6 @@ static int rt28xx_init(IN struct net_dev
 	if (Status != NDIS_STATUS_SUCCESS)
 		goto err1;
 
-//	COPY_MAC_ADDR(pAd->ApCfg.MBSSID[apidx].Bssid, netif->hwaddr);
-//	pAd->bForcePrintTX = TRUE;
-
 	CfgInitHook(pAd);
 
 	NdisAllocateSpinLock(&pAd->MacTabLock);
@@ -442,7 +435,6 @@ static int rt28xx_init(IN struct net_dev
 
 
    	//Init Ba Capability parameters.
-//	RT28XX_BA_INIT(pAd);
 	pAd->CommonCfg.DesiredHtPhy.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
 	pAd->CommonCfg.DesiredHtPhy.AmsduEnable = (USHORT)pAd->CommonCfg.BACapability.field.AmsduEnable;
 	pAd->CommonCfg.DesiredHtPhy.AmsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
@@ -452,13 +444,6 @@ static int rt28xx_init(IN struct net_dev
 	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
 	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
 
-	// after reading Registry, we now know if in AP mode or STA mode
-
-	// Load 8051 firmware; crash when FW image not existent
-	// Status = NICLoadFirmware(pAd);
-	// if (Status != NDIS_STATUS_SUCCESS)
-	//    break;
-
 	printk("2. Phy Mode = %d\n", pAd->CommonCfg.PhyMode);
 
 	// We should read EEPROM for all cases.  rt2860b
@@ -490,15 +475,6 @@ static int rt28xx_init(IN struct net_dev
 	NICInitRT30xxRFRegisters(pAd);
 #endif // RT2870 //
 
-#if 0
-	// Patch cardbus controller if EEPROM said so.
-	if (pAd->bTest1 == FALSE)
-		RTMPPatchCardBus(pAd);
-#endif
-
-
-//		APInitialize(pAd);
-
 #ifdef IKANOS_VX_1X0
 	VR_IKANOS_FP_Init(pAd->ApCfg.BssidNum, pAd->PermanentAddress);
 #endif // IKANOS_VX_1X0 //
@@ -519,16 +495,13 @@ static int rt28xx_init(IN struct net_dev
 		//
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE))
 		{
-//			NdisMDeregisterInterrupt(&pAd->Interrupt);
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
 		}
-//		RTMPFreeAdapter(pAd); // we will free it in disconnect()
 	}
 	else if (pAd)
 	{
 		// Microsoft HCT require driver send a disconnect event after driver initialization.
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-//		pAd->IndicateMediaState = NdisMediaStateDisconnected;
 		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);
 
 		DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_DISCONNECT Event B!\n"));
@@ -561,7 +534,6 @@ err3:
 	MlmeHalt(pAd);
 err2:
 	RTMPFreeTxRxRingMemory(pAd);
-//	RTMPFreeAdapter(pAd);
 err1:
 	os_free_mem(pAd, pAd->mpdu_blk_pool.mem); // free BA pool
 	RT28XX_IRQ_RELEASE(net_dev);
@@ -647,34 +619,6 @@ int rt28xx_open(IN PNET_DEV dev)
 	printk("0x1300 = %08x\n", reg);
 	}
 
-	{
-//	u32 reg;
-//	u8  byte;
-//	u16 tmp;
-
-//	RTMP_IO_READ32(pAd, XIFS_TIME_CFG, &reg);
-
-//	tmp = 0x0805;
-//	reg  = (reg & 0xffff0000) | tmp;
-//	RTMP_IO_WRITE32(pAd, XIFS_TIME_CFG, reg);
-
-	}
-
-#if 0
-	/*
-	 * debugging helper
-	 * 		show the size of main table in Adapter structure
-	 *		MacTab  -- 185K
-	 *		BATable -- 137K
-	 * 		Total 	-- 385K  !!!!! (5/26/2006)
-	 */
-	printk("sizeof(pAd->MacTab) = %ld\n", sizeof(pAd->MacTab));
-	printk("sizeof(pAd->AccessControlList) = %ld\n", sizeof(pAd->AccessControlList));
-	printk("sizeof(pAd->ApCfg) = %ld\n", sizeof(pAd->ApCfg));
-	printk("sizeof(pAd->BATable) = %ld\n", sizeof(pAd->BATable));
-	BUG();
-#endif
-
 	return (retval);
 
 err:
@@ -704,10 +648,6 @@ static NDIS_STATUS rt_ieee80211_if_setup
 	CHAR    slot_name[IFNAMSIZ];
 	struct net_device   *device;
 
-
-	//ether_setup(dev);
-//	dev->set_multicast_list = ieee80211_set_multicast_list;
-//	dev->change_mtu = ieee80211_change_mtu;
 #if WIRELESS_EXT >= 12
 	if (pAd->OpMode == OPMODE_STA)
 	{
@@ -718,8 +658,6 @@ static NDIS_STATUS rt_ieee80211_if_setup
 #if WIRELESS_EXT < 21
 		dev->get_wireless_stats = rt28xx_get_wireless_stats;
 #endif
-//	dev->uninit = ieee80211_if_reinit;
-//	dev->destructor = ieee80211_if_free;
 	dev->priv_flags = INT_MAIN;
 	dev->netdev_ops = &rt2870_netdev_ops;
 	// find available device name
@@ -786,10 +724,6 @@ INT __devinit   rt28xx_probe(
 
     DBGPRINT(RT_DEBUG_TRACE, ("STA Driver version-%s\n", STA_DRIVER_VERSION));
 
-	// Check chipset vendor/product ID
-//	if (RT28XXChipsetCheck(_dev_p) == FALSE)
-//		goto err_out;
-
     net_dev = alloc_etherdev(sizeof(PRTMP_ADAPTER));
     if (net_dev == NULL)
     {
@@ -798,10 +732,6 @@ INT __devinit   rt28xx_probe(
         goto err_out;
     }
 
-// sample
-//	if (rt_ieee80211_if_setup(net_dev) != NDIS_STATUS_SUCCESS)
-//		goto err_out;
-
 	netif_stop_queue(net_dev);
 
 /* for supporting Network Manager */
@@ -825,9 +755,6 @@ INT __devinit   rt28xx_probe(
 
     pAd->StaCfg.OriDevType = net_dev->type;
 
-	// Find and assign a free interface name, raxx
-//	RT28XXAvailRANameAssign(net_dev->name);
-
 	// Post config
 	if (RT28XXProbePostConfig(_dev_p, pAd, 0) == FALSE)
 		goto err_out_unmap;
@@ -909,16 +836,7 @@ int rt28xx_packet_xmit(struct sk_buff *s
 		goto done;
 	}
 
-#if 0
-//	if ((pkt->data[0] & 0x1) == 0)
-	{
-		//hex_dump(__func__, pkt->data, pkt->len);
-		printk("pPacket = %x\n", pPacket);
-	}
-#endif
-
 	RTMP_SET_PACKET_5VT(pPacket, 0);
-//	MiniportMMRequest(pAd, pkt->data, pkt->len);
 #ifdef CONFIG_5VT_ENHANCE
     if (*(int*)(skb->cb) == BRIDGE_TAG) {
 		RTMP_SET_PACKET_5VT(pPacket, 1);
@@ -976,56 +894,6 @@ void CfgInitHook(PRTMP_ADAPTER pAd)
 	pAd->bBroadComHT = TRUE;
 } /* End of CfgInitHook */
 
-
-#if 0	// Not used now, should keep it in our source tree??
-/*
-========================================================================
-Routine Description:
-    Find and assign a free interface name (raxx).
-
-Arguments:
-    *name_p				the interface name pointer
-
-Return Value:
-	TRUE				OK
-	FALSE				FAIL
-
-Note:
-========================================================================
-*/
-static BOOLEAN RT28XXAvailRANameAssign(
-	IN CHAR			*name_p)
-{
-    CHAR				slot_name[IFNAMSIZ];
-    struct net_device	*device;
-	UINT32				if_id;
-
-
-    for(if_id=0; if_id<8; if_id++)
-    {
-        sprintf(slot_name, "ra%d", if_id);
-
-        for(device=dev_base; device!=NULL; device=device->next)
-        {
-            if (strncmp(device->name, slot_name, 4) == 0)
-                break;
-        }
-
-        if (device == NULL)
-			break;
-    }
-
-    if (if_id == 8)
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("No available slot name\n"));
-        return FALSE;
-    }
-
-    sprintf(name_p, "ra%d", if_id);
-	return TRUE;
-} /* End of RT28XXAvailRANameAssign */
-#endif
-
 #if WIRELESS_EXT >= 12
 // This function will be called when query /proc
 struct iw_statistics *rt28xx_get_wireless_stats(
--- a/drivers/staging/rt2870/rtmp_def.h
+++ b/drivers/staging/rt2870/rtmp_def.h
@@ -54,8 +54,6 @@
 #define NIC_TAG             ((ULONG)'0682')
 #define NIC_DBG_STRING      ("**RT28xx**")
 
-//#define PACKED
-
 #define RALINK_2883_VERSION		((UINT32)0x28830300)
 #define RALINK_2880E_VERSION	((UINT32)0x28720200)
 #define RALINK_3070_VERSION		((UINT32)0x30700200)
@@ -179,16 +177,6 @@
 #define fRTMP_ADAPTER_MEDIA_STATE_CHANGE    0x20000000
 #define fRTMP_ADAPTER_IDLE_RADIO_OFF        0x40000000
 
-// Lock bit for accessing different ring buffers
-//#define fRTMP_ADAPTER_TX_RING_BUSY        0x80000000
-//#define fRTMP_ADAPTER_MGMT_RING_BUSY      0x40000000
-//#define fRTMP_ADAPTER_ATIM_RING_BUSY      0x20000000
-//#define fRTMP_ADAPTER_RX_RING_BUSY        0x10000000
-
-// Lock bit for accessing different queue
-//#define   fRTMP_ADAPTER_TX_QUEUE_BUSY     0x08000000
-//#define   fRTMP_ADAPTER_MGMT_QUEUE_BUSY   0x04000000
-
 //
 //  STA operation status flags
 //
@@ -198,7 +186,6 @@
 #define fOP_STATUS_SHORT_SLOT_INUSED        0x00000008
 #define fOP_STATUS_SHORT_PREAMBLE_INUSED    0x00000010
 #define fOP_STATUS_RECEIVE_DTIM             0x00000020
-//#define fOP_STATUS_TX_RATE_SWITCH_ENABLED   0x00000040
 #define fOP_STATUS_MEDIA_STATE_CONNECTED    0x00000080
 #define fOP_STATUS_WMM_INUSED               0x00000100
 #define fOP_STATUS_AGGREGATION_INUSED       0x00000200
@@ -238,7 +225,6 @@
 //
 //  STA configuration flags
 //
-//#define fSTA_CFG_ENABLE_TX_BURST          0x00000001
 
 // 802.11n Operating Mode Definition. 0-3 also used in ASICUPdateProtect switch case
 #define HT_NO_PROTECT	0
@@ -433,14 +419,10 @@
 #define PWR_ACTIVE                      0
 #define PWR_SAVE                        1
 #define PWR_MMPS                        2			//MIMO power save
-//#define PWR_UNKNOWN                   2
 
 // Auth and Assoc mode related definitions
 #define AUTH_MODE_OPEN                  0x00
 #define AUTH_MODE_KEY                   0x01
-//#define AUTH_MODE_AUTO_SWITCH         0x03
-//#define AUTH_MODE_DEAUTH              0x04
-//#define AUTH_MODE_UPLAYER             0x05 // reserved for 802.11i use
 
 // BSS Type definitions
 #define BSS_ADHOC                       0  // = Ndis802_11IBSS
--- a/drivers/staging/rt2870/rtmp.h
+++ b/drivers/staging/rt2870/rtmp.h
@@ -45,8 +45,6 @@
 
 #include "aironet.h"
 
-//#define DBG		1
-
 //#define DBG_DIAGNOSE		1
 
 #define VIRTUAL_IF_INC(__pAd) ((__pAd)->VirtualIfCnt++)
@@ -142,7 +140,6 @@ typedef struct _RX_CONTEXT
 	PURB				pUrb;
 	//These 2 Boolean shouldn't both be 1 at the same time.
 	ULONG				BulkInOffset;	// number of packets waiting for reordering .
-//	BOOLEAN				ReorderInUse;	// At least one packet in this buffer are in reordering buffer and wait for receive indication
 	BOOLEAN				bRxHandling;	// Notify this packet is being process now.
 	BOOLEAN				InUse;			// USB Hardware Occupied. Wait for USB HW to put packet.
 	BOOLEAN				Readable;		// Receive Complete back. OK for driver to indicate receiving packet.
@@ -579,8 +576,6 @@ typedef struct  _QUEUE_HEADER   {
 //
 // Common fragment list structure -  Identical to the scatter gather frag list structure
 //
-//#define RTMP_SCATTER_GATHER_ELEMENT         SCATTER_GATHER_ELEMENT
-//#define PRTMP_SCATTER_GATHER_ELEMENT        PSCATTER_GATHER_ELEMENT
 #define NIC_MAX_PHYS_BUF_COUNT              8
 
 typedef struct _RTMP_SCATTER_GATHER_ELEMENT {
@@ -1290,21 +1285,14 @@ typedef struct _BA_REC_ENTRY {
 	UCHAR   Wcid;
 	UCHAR   TID;
 	UCHAR   BAWinSize;	// 7.3.1.14. each buffer is capable of holding a max AMSDU or MSDU.
-	//UCHAR	NumOfRxPkt;
-	//UCHAR    Curindidx; // the head in the RX reordering buffer
 	USHORT		LastIndSeq;
-//	USHORT		LastIndSeqAtTimer;
 	USHORT		TimeOutValue;
 	RALINK_TIMER_STRUCT RECBATimer;
 	ULONG		LastIndSeqAtTimer;
 	ULONG		nDropPacket;
 	ULONG		rcvSeq;
 	REC_BLOCKACK_STATUS  REC_BA_Status;
-//	UCHAR	RxBufIdxUsed;
-	// corresponding virtual address for RX reordering packet storage.
-	//RTMP_REORDERDMABUF MAP_RXBuf[MAX_RX_REORDERBUF];
 	NDIS_SPIN_LOCK          RxReRingLock;                 // Rx Ring spinlock
-//	struct _BA_REC_ENTRY *pNext;
 	PVOID	pAdapter;
 	struct reordering_list	list;
 } BA_REC_ENTRY, *PBA_REC_ENTRY;
@@ -1382,8 +1370,6 @@ typedef	struct	_IOT_STRUC	{
 // This is the registry setting for 802.11n transmit setting.  Used in advanced page.
 typedef union _REG_TRANSMIT_SETTING {
  struct {
-         //UINT32  PhyMode:4;
-         //UINT32  MCS:7;                 // MCS
 		 UINT32  rsv0:10;
 		 UINT32  TxBF:1;
          UINT32  BW:1; //channel bandwidth 20MHz or 40 MHz
@@ -1481,7 +1467,6 @@ typedef struct _MULTISSID_STRUCT {
 	DESIRED_TRANSMIT_SETTING        	DesiredTransmitSetting; // Desired transmit setting. this is for reading registry setting only. not useful.
 	BOOLEAN								bAutoTxRateSwitch;
 
-	//CIPHER_KEY                          SharedKey[SHARE_KEY_NUM]; // ref pAd->SharedKey[BSS][4]
 	UCHAR                               DefaultKeyId;
 
 	UCHAR								TxRate;       // RATE_1, RATE_2, RATE_5_5, RATE_11, ...
@@ -1489,8 +1474,6 @@ typedef struct _MULTISSID_STRUCT {
 	UCHAR								DesiredRatesIndex;
 	UCHAR     							MaxTxRate;            // RATE_1, RATE_2, RATE_5_5, RATE_11
 
-//	ULONG           					TimBitmap;      // bit0 for broadcast, 1 for AID1, 2 for AID2, ...so on
-//    ULONG           					TimBitmap2;     // b0 for AID32, b1 for AID33, ... and so on
 	UCHAR								TimBitmaps[WLAN_MAX_NUM_OF_TIM];
 
     // WPA
@@ -1587,23 +1570,6 @@ typedef struct _COMMON_CONFIG {
 	UCHAR       Channel;
 	UCHAR       CentralChannel;    	// Central Channel when using 40MHz is indicating. not real channel.
 
-#if 0	// move to STA_ADMIN_CONFIG
-	UCHAR       DefaultKeyId;
-
-	NDIS_802_11_PRIVACY_FILTER          PrivacyFilter;  // PrivacyFilter enum for 802.1X
-	NDIS_802_11_AUTHENTICATION_MODE     AuthMode;       // This should match to whatever microsoft defined
-	NDIS_802_11_WEP_STATUS              WepStatus;
-	NDIS_802_11_WEP_STATUS				OrigWepStatus;	// Original wep status set from OID
-
-	// Add to support different cipher suite for WPA2/WPA mode
-	NDIS_802_11_ENCRYPTION_STATUS		GroupCipher;		// Multicast cipher suite
-	NDIS_802_11_ENCRYPTION_STATUS		PairCipher;			// Unicast cipher suite
-	BOOLEAN								bMixCipher;			// Indicate current Pair & Group use different cipher suites
-	USHORT								RsnCapability;
-
-	NDIS_802_11_WEP_STATUS              GroupKeyWepStatus;
-#endif
-
 	UCHAR       SupRate[MAX_LEN_OF_SUPPORTED_RATES];
 	UCHAR       SupRateLen;
 	UCHAR       ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
@@ -1625,15 +1591,11 @@ typedef struct _COMMON_CONFIG {
 	ULONG		TriggerTimerCount;
 	UCHAR		MaxSPLength;
 	UCHAR		BBPCurrentBW;	// BW_10, 	BW_20, BW_40
-	// move to MULTISSID_STRUCT for MBSS
-	//HTTRANSMIT_SETTING	HTPhyMode, MaxHTPhyMode, MinHTPhyMode;// For transmit phy setting in TXWI.
 	REG_TRANSMIT_SETTING        RegTransmitSetting; //registry transmit setting. this is for reading registry setting only. not useful.
-	//UCHAR       FixedTxMode;              // Fixed Tx Mode (CCK, OFDM), for HT fixed tx mode (GF, MIX) , refer to RegTransmitSetting.field.HTMode
 	UCHAR       TxRate;                 // Same value to fill in TXD. TxRate is 6-bit
 	UCHAR       MaxTxRate;              // RATE_1, RATE_2, RATE_5_5, RATE_11
 	UCHAR       TxRateIndex;            // Tx rate index in RateSwitchTable
 	UCHAR       TxRateTableSize;        // Valid Tx rate table size in RateSwitchTable
-	//BOOLEAN		bAutoTxRateSwitch;
 	UCHAR       MinTxRate;              // RATE_1, RATE_2, RATE_5_5, RATE_11
 	UCHAR       RtsRate;                // RATE_xxx
 	HTTRANSMIT_SETTING	MlmeTransmit;   // MGMT frame PHY rate setting when operatin at Ht rate.
@@ -2066,7 +2028,6 @@ typedef struct _MAC_TABLE_ENTRY {
 	UCHAR           CurrTxRateIndex;
 	// to record the each TX rate's quality. 0 is best, the bigger the worse.
 	USHORT          TxQuality[MAX_STEP_OF_TX_RATE_SWITCH];
-//	USHORT          OneSecTxOkCount;
 	UINT32			OneSecTxNoRetryOkCount;
 	UINT32          OneSecTxRetryOkCount;
 	UINT32          OneSecTxFailCount;
@@ -2235,29 +2196,20 @@ typedef struct _APCLI_STRUCT {
 	UCHAR		PSK[100];				// reserve PSK key material
 	UCHAR       PSKLen;
 	UCHAR       PMK[32];                // WPA PSK mode PMK
-	//UCHAR       PTK[64];                // WPA PSK mode PTK
 	UCHAR		GTK[32];				// GTK from authenticator
 
-	//CIPHER_KEY		PairwiseKey;
 	CIPHER_KEY      SharedKey[SHARE_KEY_NUM];
 	UCHAR           DefaultKeyId;
 
-	// WPA 802.1x port control, WPA_802_1X_PORT_SECURED, WPA_802_1X_PORT_NOT_SECURED
-	//UCHAR       PortSecured;
-
 	// store RSN_IE built by driver
 	UCHAR		RSN_IE[MAX_LEN_OF_RSNIE];  // The content saved here should be convert to little-endian format.
 	UCHAR		RSNIE_Len;
 
 	// For WPA countermeasures
 	ULONG       LastMicErrorTime;   // record last MIC error time
-	//ULONG       MicErrCnt;          // Should be 0, 1, 2, then reset to zero (after disassoiciation).
 	BOOLEAN                 bBlockAssoc; // Block associate attempt for 60 seconds after counter measure occurred.
 
 	// For WPA-PSK supplicant state
-	//WPA_STATE   	WpaState;           // Default is SS_NOTUSE
-	//UCHAR       	ReplayCounter[8];
-	//UCHAR       	ANonce[32];         // ANonce for WPA-PSK from authenticator
 	UCHAR       	SNonce[32];         // SNonce for WPA-PSK
 	UCHAR			GNonce[32];			// GNonce for WPA-PSK from authenticator
 
@@ -2310,15 +2262,12 @@ typedef struct _RtmpDiagStrcut_
 	// Tx Related Count
 	USHORT			TxDataCnt[DIAGNOSE_TIME];
 	USHORT			TxFailCnt[DIAGNOSE_TIME];
-//	USHORT			TxDescCnt[DIAGNOSE_TIME][16];		// TxDesc queue length in scale of 0~14, >=15
 	USHORT			TxDescCnt[DIAGNOSE_TIME][24]; // 3*3	// TxDesc queue length in scale of 0~14, >=15
-//	USHORT			TxMcsCnt[DIAGNOSE_TIME][16];			// TxDate MCS Count in range from 0 to 15, step in 1.
 	USHORT			TxMcsCnt[DIAGNOSE_TIME][24]; // 3*3
 	USHORT			TxSWQueCnt[DIAGNOSE_TIME][9];		// TxSwQueue length in scale of 0, 1, 2, 3, 4, 5, 6, 7, >=8
 
 	USHORT			TxAggCnt[DIAGNOSE_TIME];
 	USHORT			TxNonAggCnt[DIAGNOSE_TIME];
-//	USHORT			TxAMPDUCnt[DIAGNOSE_TIME][16];		// 10 sec, TxDMA APMDU Aggregation count in range from 0 to 15, in setp of 1.
 	USHORT			TxAMPDUCnt[DIAGNOSE_TIME][24]; // 3*3 // 10 sec, TxDMA APMDU Aggregation count in range from 0 to 15, in setp of 1.
 	USHORT			TxRalinkCnt[DIAGNOSE_TIME];			// TxRalink Aggregation Count in 1 sec scale.
 	USHORT			TxAMSDUCnt[DIAGNOSE_TIME];			// TxAMSUD Aggregation Count in 1 sec scale.
@@ -2326,7 +2275,6 @@ typedef struct _RtmpDiagStrcut_
 	// Rx Related Count
 	USHORT			RxDataCnt[DIAGNOSE_TIME];			// Rx Total Data count.
 	USHORT			RxCrcErrCnt[DIAGNOSE_TIME];
-//	USHORT			RxMcsCnt[DIAGNOSE_TIME][16];		// Rx MCS Count in range from 0 to 15, step in 1.
 	USHORT			RxMcsCnt[DIAGNOSE_TIME][24]; // 3*3
 }RtmpDiagStruct;
 #endif // DBG_DIAGNOSE //
@@ -2661,7 +2609,6 @@ typedef struct _RTMP_ADAPTER
 	// ----------------------------
 	// DEBUG paramerts
 	// ----------------------------
-	//ULONG		DebugSetting[4];
 	BOOLEAN		bBanAllBaSetup;
 	BOOLEAN		bPromiscuous;
 
@@ -2771,7 +2718,6 @@ typedef struct  _CISCO_IAPP_CONTENT_
 
 typedef struct _RX_BLK_
 {
-//	RXD_STRUC		RxD; // sample
 	RT28XX_RXD_STRUC	RxD;
 	PRXWI_STRUC			pRxWI;
 	PHEADER_802_11		pHeader;
@@ -2859,7 +2805,6 @@ typedef struct _TX_BLK_
 #define fTX_bAckRequired       	0x0002	// the packet need ack response
 #define fTX_bPiggyBack     		0x0004	// Legacy device use Piggback or not
 #define fTX_bHTRate         	0x0008	// allow to use HT rate
-//#define fTX_bForceLowRate       0x0010	// force to use Low Rate
 #define fTX_bForceNonQoS       	0x0010	// force to transmit frame without WMM-QoS in HT mode
 #define fTX_bAllowFrag       	0x0020	// allow to fragment the packet, A-MPDU, A-MSDU, A-Ralink is not allowed to fragment
 #define fTX_bMoreData			0x0040	// there are more data packets in PowerSave Queue
@@ -3022,13 +2967,6 @@ VOID NICUpdateFifoStaCounters(
 VOID NICUpdateRawCounters(
 	IN  PRTMP_ADAPTER   pAd);
 
-#if 0
-ULONG RTMPEqualMemory(
-	IN  PVOID   pSrc1,
-	IN  PVOID   pSrc2,
-	IN  ULONG   Length);
-#endif
-
 ULONG	RTMPNotAllZero(
 	IN	PVOID	pSrc1,
 	IN	ULONG	Length);
@@ -3277,12 +3215,6 @@ BOOLEAN PeerIsAggreOn(
     IN  ULONG          TxRate,
     IN  PMAC_TABLE_ENTRY pMacEntry);
 
-#if 0	// It's not be used
-HTTRANSMIT_SETTING  *GetTxMode(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk);
-#endif
-
 NDIS_STATUS Sniff2BytesFromNdisBuffer(
 	IN  PNDIS_BUFFER    pFirstBuffer,
 	IN  UCHAR           DesiredOffset,
@@ -3600,12 +3532,6 @@ VOID AsicSetBssid(
 VOID AsicSetMcastWC(
 	IN PRTMP_ADAPTER pAd);
 
-#if 0	// removed by AlbertY
-VOID AsicSetBssidWC(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pBssid);
-#endif
-
 VOID AsicDelWcidTab(
 	IN PRTMP_ADAPTER pAd,
 	IN UCHAR	Wcid);
@@ -3633,17 +3559,6 @@ VOID AsicSetSlotTime(
 	IN PRTMP_ADAPTER pAd,
 	IN BOOLEAN bUseShortSlotTime);
 
-#if 0
-VOID AsicAddWcidCipherEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 WCID,
-	IN UCHAR		 BssIndex,
-	IN UCHAR		 KeyTable,
-	IN UCHAR		 CipherAlg,
-	IN PUCHAR		 pAddr,
-	IN CIPHER_KEY		 *pCipherKey);
-#endif
-
 VOID AsicAddSharedKeyEntry(
 	IN PRTMP_ADAPTER pAd,
 	IN UCHAR         BssIndex,
@@ -4472,12 +4387,6 @@ UCHAR ChannelSanity(
 NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(
 	IN PBSS_ENTRY pBss);
 
-#if 0	// It's omitted
-NDIS_STATUS	RTMPWepKeySanity(
-	IN	PRTMP_ADAPTER	pAdapter,
-	IN	PVOID			pBuf);
-#endif
-
 BOOLEAN MlmeDelBAReqSanity(
     IN PRTMP_ADAPTER pAd,
     IN VOID *Msg,
@@ -4784,12 +4693,6 @@ BOOLEAN RTMPSoftDecryptAES(
 	IN ULONG	DataByteCnt,
 	IN PCIPHER_KEY	pWpaKey);
 
-#if 0	// removed by AlbertY
-NDIS_STATUS RTMPWPAAddKeyProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PVOID           pBuf);
-#endif
-
 //
 // Prototypes of function definition in cmm_info.c
 //
@@ -5210,30 +5113,12 @@ VOID RTMPHandleSTAKey(
     IN MAC_TABLE_ENTRY  *pEntry,
     IN MLME_QUEUE_ELEM  *Elem);
 
-#if 0 // merge into PeerPairMsg4Action
-VOID Wpa1PeerPairMsg4Action(
-	IN PRTMP_ADAPTER pAd,
-	IN MAC_TABLE_ENTRY  *pEntry,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID Wpa2PeerPairMsg4Action(
-	IN  PRTMP_ADAPTER    pAd,
-	IN  PMAC_TABLE_ENTRY pEntry,
-	IN  MLME_QUEUE_ELEM  *Elem);
-#endif // 0 //
-
 VOID PeerGroupMsg2Action(
 	IN  PRTMP_ADAPTER    pAd,
 	IN  PMAC_TABLE_ENTRY pEntry,
 	IN  VOID             *Msg,
 	IN  UINT             MsgLen);
 
-#if 0	// replaced by WPAStart2WayGroupHS
-NDIS_STATUS APWpaHardTransmit(
-	IN  PRTMP_ADAPTER    pAd,
-	IN  PMAC_TABLE_ENTRY pEntry);
-#endif // 0 //
-
 VOID PairDisAssocAction(
 	IN  PRTMP_ADAPTER    pAd,
 	IN  PMAC_TABLE_ENTRY pEntry,
@@ -5321,9 +5206,6 @@ VOID	RTMPSendTriggerFrame(
 	IN	BOOLEAN			bQosNull);
 
 
-//typedef void (*TIMER_FUNCTION)(unsigned long);
-
-
 /* timeout -- ms */
 VOID RTMP_SetPeriodicTimer(
 	IN	NDIS_MINIPORT_TIMER *pTimer,
@@ -6428,18 +6310,6 @@ NDIS_STATUS RTMPWPAAddKeyProc(
 VOID AsicRxAntEvalAction(
 	IN PRTMP_ADAPTER pAd);
 
-#if 0 // Mark because not used in RT28xx.
-NTSTATUS RTUSBRxPacket(
-	IN	PRTMP_ADAPTER  pAd,
-	IN    BOOLEAN          bBulkReceive);
-
-VOID RTUSBDequeueMLMEPacket(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID RTUSBCleanUpMLMEWaitQueue(
-	IN	PRTMP_ADAPTER	pAd);
-#endif
-
 void append_pkt(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			pHeader802_3,
@@ -6468,14 +6338,6 @@ VOID RTUSBMlmeHardTransmit(
 INT MlmeThread(
 	IN PVOID Context);
 
-#if 0
-VOID    RTUSBResumeMsduTransmission(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID    RTUSBSuspendMsduTransmission(
-	IN	PRTMP_ADAPTER	pAd);
-#endif
-
 //
 // Function Prototype in rtusb_data.c
 //
--- a/drivers/staging/rt2870/rt_profile.c
+++ b/drivers/staging/rt2870/rt_profile.c
@@ -1121,14 +1121,10 @@ NDIS_STATUS	RTMPReadParametersHook(
 					//TxBurst
 					if(RTMPGetKeyParameter("TxBurst", tmpbuf, 10, buffer))
 					{
-//#ifdef WIFI_TEST
-//						pAd->CommonCfg.bEnableTxBurst = FALSE;
-//#else
 						if(simple_strtol(tmpbuf, 0, 10) != 0)  //Enable
 							pAd->CommonCfg.bEnableTxBurst = TRUE;
 						else //Disable
 							pAd->CommonCfg.bEnableTxBurst = FALSE;
-//#endif
 						DBGPRINT(RT_DEBUG_TRACE, ("TxBurst=%d\n", pAd->CommonCfg.bEnableTxBurst));
 					}
 
@@ -1296,7 +1292,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 							pAd->StaCfg.OrigWepStatus 	= pAd->StaCfg.WepStatus;
 							pAd->StaCfg.bMixCipher 		= FALSE;
 
-							//RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
 							DBGPRINT(RT_DEBUG_TRACE, ("%s::(EncrypType=%d)\n", __func__, pAd->StaCfg.WepStatus));
 						}
 					}
@@ -1342,21 +1337,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 								}
 								else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
 								{
-	/*
-									NdisZeroMemory(&pAd->SharedKey[BSS0][0], sizeof(CIPHER_KEY));
-									pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
-									NdisMoveMemory(pAd->SharedKey[BSS0][0].Key, pAd->StaCfg.PMK, LEN_TKIP_EK);
-									NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic, &pAd->StaCfg.PMK[16], LEN_TKIP_RXMICK);
-									NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic, &pAd->StaCfg.PMK[16], LEN_TKIP_TXMICK);
-
-									// Decide its ChiperAlg
-									if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
-										pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
-									else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
-										pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
-									else
-										pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_NONE;
-	*/
 									pAd->StaCfg.WpaState = SS_NOTUSE;
 								}
 
@@ -1368,23 +1348,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 					//DefaultKeyID, KeyType, KeyStr
 					rtmp_read_key_parms_from_file(pAd, tmpbuf, buffer);
 
-
-					//HSCounter
-					/*if(RTMPGetKeyParameter("HSCounter", tmpbuf, 10, buffer))
-					{
-						switch (simple_strtol(tmpbuf, 0, 10))
-						{
-							case 1: //Enable
-								pAd->CommonCfg.bEnableHSCounter = TRUE;
-								break;
-							case 0: //Disable
-							default:
-								pAd->CommonCfg.bEnableHSCounter = FALSE;
-								break;
-						}
-						DBGPRINT(RT_DEBUG_TRACE, "HSCounter=%d\n", pAd->CommonCfg.bEnableHSCounter);
-					}*/
-
 					HTParametersHook(pAd, tmpbuf, buffer);
 
 					{
@@ -1489,10 +1452,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 	}
 
 	set_fs(orgfs);
-#if 0
-	current->fsuid = orgfsuid;
-	current->fsgid = orgfsgid;
-#endif
 
 	kfree(buffer);
 	kfree(tmpbuf);
@@ -1816,7 +1775,6 @@ static void	HTParametersHook(
 		{
 			Value = simple_strtol(pValueStr, 0, 10);
 
-//			if ((Value >= 0 && Value <= 15) || (Value == 32))
 			if ((Value >= 0 && Value <= 23) || (Value == 32)) // 3*3
 		{
 				pAd->StaCfg.DesiredTransmitSetting.field.MCS  = Value;
--- a/drivers/staging/rt2870/sta/connect.c
+++ b/drivers/staging/rt2870/sta/connect.c
@@ -533,13 +533,6 @@ VOID CntlOidRTBssidProc(
 	pAd->MlmeAux.SsidBssTab.BssNr = 1;
 	NdisMoveMemory(&pAd->MlmeAux.SsidBssTab.BssEntry[0], &pAd->ScanTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
 
-	//pAd->MlmeAux.AutoReconnectSsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
-	//NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->ScanTab.BssEntry[BssIdx].Ssid, pAd->ScanTab.BssEntry[BssIdx].SsidLen);
-
-	// Add SSID into MlmeAux for site surey joining hidden SSID
-	//pAd->MlmeAux.SsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
-	//NdisMoveMemory(pAd->MlmeAux.Ssid, pAd->ScanTab.BssEntry[BssIdx].Ssid, pAd->MlmeAux.SsidLen);
-
 	// 2002-11-26 skip the following checking. i.e. if user wants to re-connect to same AP
 	//   we just follow normal procedure. The reason of user doing this may because he/she changed
 	//   AP to another channel, but we still received BEACON from it thus don't claim Link Down.
@@ -1917,9 +1910,6 @@ VOID LinkDown(
 	// Update extra information to link is up
 	pAd->ExtraInfo = GENERAL_LINK_DOWN;
 
-    //pAd->StaCfg.AdhocBOnlyJoined = FALSE;
-	//pAd->StaCfg.AdhocBGJoined = FALSE;
-	//pAd->StaCfg.Adhoc20NJoined = FALSE;
     pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
 
 	// Reset the Current AP's IP address
--- a/drivers/staging/rt2870/sta_ioctl.c
+++ b/drivers/staging/rt2870/sta_ioctl.c
@@ -336,7 +336,6 @@ VOID RTMPAddKey(
             if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
             {
                 // set 802.1x port control
-	            //pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAd);
 
                 // Indicate Connected for GUI
@@ -386,7 +385,6 @@ VOID RTMPAddKey(
         							  NULL);
 
             // set 802.1x port control
-	        //pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 			STA_PORT_SECURED(pAd);
 
             // Indicate Connected for GUI
@@ -1608,7 +1606,6 @@ int rt_ioctl_siwencode(struct net_device
 	else if ((erq->length == 0) &&
              (erq->flags & IW_ENCODE_RESTRICTED || erq->flags & IW_ENCODE_OPEN))
 	{
-	    //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 		STA_PORT_SECURED(pAdapter);
 		pAdapter->StaCfg.PairCipher = Ndis802_11WEPEnabled;
 		pAdapter->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
@@ -2234,7 +2231,6 @@ int rt_ioctl_siwauth(struct net_device *
             }
             else if (param->value == 0)
             {
-                //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAdapter);
             }
             DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_KEY_MGMT - param->value = %d!\n", __func__, param->value));
@@ -2242,14 +2238,6 @@ int rt_ioctl_siwauth(struct net_device *
     	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
             break;
     	case IW_AUTH_PRIVACY_INVOKED:
-            /*if (param->value == 0)
-			{
-                pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-                pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
-                pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-                pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
-        	    pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
-            }*/
             DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_PRIVACY_INVOKED - param->value = %d!\n", __func__, param->value));
     		break;
     	case IW_AUTH_DROP_UNENCRYPTED:
@@ -2257,7 +2245,6 @@ int rt_ioctl_siwauth(struct net_device *
                 pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
 			else
 			{
-                //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAdapter);
 			}
             DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_WPA_VERSION - param->value = %d!\n", __func__, param->value));
@@ -2445,7 +2432,6 @@ int rt_ioctl_siwencodeext(struct net_dev
                         fnSetCipherKey(pAdapter, keyIdx, CIPHER_TKIP, FALSE, ext);
                         if (pAdapter->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
                         {
-                            //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
                             STA_PORT_SECURED(pAdapter);
                         }
 		}
@@ -2454,7 +2440,6 @@ int rt_ioctl_siwencodeext(struct net_dev
                         fnSetCipherKey(pAdapter, keyIdx, CIPHER_TKIP, TRUE, ext);
 
                         // set 802.1x port control
-            	        //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
             	        STA_PORT_SECURED(pAdapter);
                     }
                 }
@@ -2466,7 +2451,6 @@ int rt_ioctl_siwencodeext(struct net_dev
 		{
                     fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES, FALSE, ext);
                     if (pAdapter->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
-                    	//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
                     	STA_PORT_SECURED(pAdapter);
                 }
                 else if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
@@ -2474,7 +2458,6 @@ int rt_ioctl_siwencodeext(struct net_dev
                     fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES, TRUE, ext);
 
                     // set 802.1x port control
-        	        //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
         	        STA_PORT_SECURED(pAdapter);
                 }
                 break;
@@ -2723,7 +2706,6 @@ rt_private_ioctl_bbp(struct net_device *
 	CHAR				*this_char;
 	CHAR				*value = NULL;
 	UCHAR				regBBP = 0;
-//	CHAR				arg[255]={0};
 	UINT32				bbpId;
 	UINT32				bbpValue;
 	BOOLEAN				bIsPrintAllBBP = FALSE;
@@ -2918,7 +2900,6 @@ int rt_ioctl_giwrate(struct net_device *
 
     if (ht_setting.field.MODE >= MODE_HTMIX)
     {
-//    	rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS);
     	rate_index = 12 + ((UCHAR)ht_setting.field.BW *24) + ((UCHAR)ht_setting.field.ShortGI *48) + ((UCHAR)ht_setting.field.MCS);
     }
     else
--- a/drivers/staging/rt2870/sta/rtmp_data.c
+++ b/drivers/staging/rt2870/sta/rtmp_data.c
@@ -63,7 +63,6 @@ VOID STARxEAPOLFrameIndicate(
 				int     idx = 0;
 
 				DBGPRINT_RAW(RT_DEBUG_TRACE, ("Receive EAP-SUCCESS Packet\n"));
-				//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAd);
 
                 if (pAd->StaCfg.IEEE8021x_required_keys == FALSE)
@@ -864,7 +863,6 @@ NDIS_STATUS STASendPacket(
 	UINT			SrcBufLen;
 	UINT			AllowFragSize;
 	UCHAR			NumberOfFrag;
-//	UCHAR			RTSRequired;
 	UCHAR			QueIdx, UserPriority;
 	MAC_TABLE_ENTRY *pEntry = NULL;
 	unsigned int 	IrqFlags;
@@ -1078,7 +1076,6 @@ NDIS_STATUS STASendPacket(
     if ((pAd->CommonCfg.BACapability.field.AutoBA == TRUE)&&
         IS_HT_STA(pEntry))
 	{
-	    //PMAC_TABLE_ENTRY pMacEntry = &pAd->MacTab.Content[BSSID_WCID];
 		if (((pEntry->TXBAbitmap & (1<<UserPriority)) == 0) &&
             ((pEntry->BADeclineBitmap & (1<<UserPriority)) == 0) &&
             (pEntry->PortSecured == WPA_802_1X_PORT_SECURED)
@@ -1133,7 +1130,6 @@ NDIS_STATUS RTMPFreeTXDRequest(
 	IN		UCHAR			NumberRequired,
 	IN		PUCHAR			FreeNumberIs)
 {
-	//ULONG		FreeNumber = 0;
 	NDIS_STATUS 	Status = NDIS_STATUS_FAILURE;
 	unsigned long   IrqFlags;
 	HT_TX_CONTEXT	*pHTTXContext;
--- a/drivers/staging/rt2870/sta/sync.c
+++ b/drivers/staging/rt2870/sta/sync.c
@@ -546,7 +546,6 @@ VOID PeerBeaconAtScanAction(
 	UCHAR			NewExtChannelOffset = 0xff;
 
 
-	// NdisFillMemory(Ssid, MAX_LEN_OF_SSID, 0x00);
 	pFrame = (PFRAME_802_11) Elem->Msg;
 	// Init Variable IE structure
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
--- a/drivers/staging/rt2870/sta/wpa.c
+++ b/drivers/staging/rt2870/sta/wpa.c
@@ -1214,7 +1214,6 @@ VOID    Wpa2PairMsg3Action(
 	RTMPToWirelessSta(pAd, Header802_3, LENGTH_802_3, (PUCHAR)&Packet, Packet.Body_Len[1] + 4, TRUE);
 
 	// set 802.1x port control
-	//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 	STA_PORT_SECURED(pAd);
 
     // Indicate Connected for GUI
@@ -1410,7 +1409,6 @@ VOID	WpaGroupMsg1Action(
 							  NULL);
 
 	// set 802.1x port control
-	//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 	STA_PORT_SECURED(pAd);
 
     // Indicate Connected for GUI
@@ -1897,17 +1895,6 @@ VOID	RTMPReportMicError(
 			pAd->StaCfg.LastMicErrorTime = Now;
 			// Violate MIC error counts, MIC countermeasures kicks in
 			pAd->StaCfg.MicErrCnt++;
-			// We shall block all reception
-			// We shall clean all Tx ring and disassoicate from AP after next EAPOL frame
-			//
-			// No necessary to clean all Tx ring, on RTMPHardTransmit will stop sending non-802.1X EAPOL packets
-			// if pAd->StaCfg.MicErrCnt greater than 2.
-			//
-			// RTMPRingCleanUp(pAd, QID_AC_BK);
-			// RTMPRingCleanUp(pAd, QID_AC_BE);
-			// RTMPRingCleanUp(pAd, QID_AC_VI);
-			// RTMPRingCleanUp(pAd, QID_AC_VO);
-			// RTMPRingCleanUp(pAd, QID_HCCA);
 		}
 	}
 	else
