From alan@linux.intel.com  Wed Jan 27 15:38:50 2010
From: Alan Cox <alan@linux.intel.com>
Date: Mon, 18 Jan 2010 15:32:55 +0000
Subject: Staging: et131x: Clean up rxdma_csr
To: greg@kroah.com
Message-ID: <20100118153255.6884.92831.stgit@localhost.localdomain>


This is another set of flags as typedef that can be cleaned up.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/et131x/et1310_address_map.h |   58 +++++++++-------------------
 drivers/staging/et131x/et1310_rx.c          |   46 ++++++++++------------
 2 files changed, 41 insertions(+), 63 deletions(-)

--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -292,45 +292,25 @@ typedef struct _TXDMA_t {		/* Location: 
 /*
  * structure for control status reg in rxdma address map
  * Located at address 0x2000
+ *
+ * CSR
+ * 0: halt
+ * 1-3: tc
+ * 4: fbr_big_endian
+ * 5: psr_big_endian
+ * 6: pkt_big_endian
+ * 7: dma_big_endian
+ * 8-9: fbr0_size
+ * 10: fbr0_enable
+ * 11-12: fbr1_size
+ * 13: fbr1_enable
+ * 14: unused
+ * 15: pkt_drop_disable
+ * 16: pkt_done_flush
+ * 17: halt_status
+ * 18-31: unused
  */
-typedef union _RXDMA_CSR_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 unused2:14;		/* bits 18-31 */
-		u32 halt_status:1;	/* bit 17 */
-		u32 pkt_done_flush:1;	/* bit 16 */
-		u32 pkt_drop_disable:1;	/* bit 15 */
-		u32 unused1:1;		/* bit 14 */
-		u32 fbr1_enable:1;	/* bit 13 */
-		u32 fbr1_size:2;	/* bits 11-12 */
-		u32 fbr0_enable:1;	/* bit 10 */
-		u32 fbr0_size:2;	/* bits 8-9 */
-		u32 dma_big_endian:1;	/* bit 7 */
-		u32 pkt_big_endian:1;	/* bit 6 */
-		u32 psr_big_endian:1;	/* bit 5 */
-		u32 fbr_big_endian:1;	/* bit 4 */
-		u32 tc:3;		/* bits 1-3 */
-		u32 halt:1;		/* bit 0 */
-#else
-		u32 halt:1;		/* bit 0 */
-		u32 tc:3;		/* bits 1-3 */
-		u32 fbr_big_endian:1;	/* bit 4 */
-		u32 psr_big_endian:1;	/* bit 5 */
-		u32 pkt_big_endian:1;	/* bit 6 */
-		u32 dma_big_endian:1;	/* bit 7 */
-		u32 fbr0_size:2;	/* bits 8-9 */
-		u32 fbr0_enable:1;	/* bit 10 */
-		u32 fbr1_size:2;	/* bits 11-12 */
-		u32 fbr1_enable:1;	/* bit 13 */
-		u32 unused1:1;		/* bit 14 */
-		u32 pkt_drop_disable:1;	/* bit 15 */
-		u32 pkt_done_flush:1;	/* bit 16 */
-		u32 halt_status:1;	/* bit 17 */
-		u32 unused2:14;		/* bits 18-31 */
-#endif
-	} bits;
-} RXDMA_CSR_t, *PRXDMA_CSR_t;
+
 
 /*
  * structure for dma writeback lo reg in rxdma address map
@@ -521,7 +501,7 @@ typedef union _RXDMA_CSR_t {
  * Located at address 0x2000
  */
 typedef struct _RXDMA_t {				/* Location: */
-	RXDMA_CSR_t csr;				/*  0x2000 */
+	u32 csr;					/*  0x2000 */
 	u32 dma_wb_base_lo;				/*  0x2004 */
 	u32 dma_wb_base_hi;				/*  0x2008 */
 	u32 num_pkt_done;				/*  0x200C */
--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -720,18 +720,17 @@ void SetRxDmaTimer(struct et131x_adapter
  */
 void et131x_rx_dma_disable(struct et131x_adapter *etdev)
 {
-	RXDMA_CSR_t csr;
-
+        u32 csr;
 	/* Setup the receive dma configuration register */
-	writel(0x00002001, &etdev->regs->rxdma.csr.value);
-	csr.value = readl(&etdev->regs->rxdma.csr.value);
-	if (csr.bits.halt_status != 1) {
+	writel(0x00002001, &etdev->regs->rxdma.csr);
+	csr = readl(&etdev->regs->rxdma.csr);
+	if ((csr & 0x00020000) != 1) {	/* Check halt status (bit 17) */
 		udelay(5);
-		csr.value = readl(&etdev->regs->rxdma.csr.value);
-		if (csr.bits.halt_status != 1)
+		csr = readl(&etdev->regs->rxdma.csr);
+		if ((csr & 0x00020000) != 1)
 			dev_err(&etdev->pdev->dev,
-				"RX Dma failed to enter halt state. CSR 0x%08x\n",
-				csr.value);
+			"RX Dma failed to enter halt state. CSR 0x%08x\n",
+				csr);
 	}
 }
 
@@ -742,34 +741,33 @@ void et131x_rx_dma_disable(struct et131x
 void et131x_rx_dma_enable(struct et131x_adapter *etdev)
 {
 	/* Setup the receive dma configuration register for normal operation */
-	RXDMA_CSR_t csr = { 0 };
+	u32 csr =  0x2000;	/* FBR1 enable */
 
-	csr.bits.fbr1_enable = 1;
 	if (etdev->RxRing.Fbr1BufferSize == 4096)
-		csr.bits.fbr1_size = 1;
+		csr |= 0x0800;
 	else if (etdev->RxRing.Fbr1BufferSize == 8192)
-		csr.bits.fbr1_size = 2;
+		csr |= 0x1000;
 	else if (etdev->RxRing.Fbr1BufferSize == 16384)
-		csr.bits.fbr1_size = 3;
+		csr |= 0x1800;
 #ifdef USE_FBR0
-	csr.bits.fbr0_enable = 1;
+        csr |= 0x0400;		/* FBR0 enable */
 	if (etdev->RxRing.Fbr0BufferSize == 256)
-		csr.bits.fbr0_size = 1;
+	        csr |= 0x0100;
 	else if (etdev->RxRing.Fbr0BufferSize == 512)
-		csr.bits.fbr0_size = 2;
+		csr |= 0x0200;
 	else if (etdev->RxRing.Fbr0BufferSize == 1024)
-		csr.bits.fbr0_size = 3;
+		csr |= 0x0300;
 #endif
-	writel(csr.value, &etdev->regs->rxdma.csr.value);
+	writel(csr, &etdev->regs->rxdma.csr);
 
-	csr.value = readl(&etdev->regs->rxdma.csr.value);
-	if (csr.bits.halt_status != 0) {
+	csr = readl(&etdev->regs->rxdma.csr);
+	if ((csr & 0x00020000) != 0) {
 		udelay(5);
-		csr.value = readl(&etdev->regs->rxdma.csr.value);
-		if (csr.bits.halt_status != 0) {
+		csr = readl(&etdev->regs->rxdma.csr);
+        	if ((csr & 0x00020000) != 0) {
 			dev_err(&etdev->pdev->dev,
 			    "RX Dma failed to exit halt state.  CSR 0x%08x\n",
-				csr.value);
+				csr);
 		}
 	}
 }
