From alan@linux.intel.com  Mon Oct 26 14:48:45 2009
From: Alan Cox <alan@linux.intel.com>
Date: Tue, 06 Oct 2009 15:47:55 +0100
Subject: Staging: et131x: PHY loopback cannot be set (and isn't useful for us anyway)
To: greg@kroah.com
Message-ID: <20091006144753.8604.69096.stgit@localhost.localdomain>


Remove the stuff that falls out from this always being zero.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/staging/et131x/et1310_mac.c     |    9 +---
 drivers/staging/et131x/et1310_phy.c     |   10 +----
 drivers/staging/et131x/et1310_rx.c      |   49 +++++++++++-------------
 drivers/staging/et131x/et1310_tx.c      |   15 ++-----
 drivers/staging/et131x/et131x_adapter.h |    2 -
 drivers/staging/et131x/et131x_initpci.c |   64 +++++++++++---------------------
 6 files changed, 54 insertions(+), 95 deletions(-)

--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -221,13 +221,8 @@ void ConfigMACRegs2(struct et131x_adapte
 	 */
 	cfg2.bits.len_check = 0x1;
 
-	if (etdev->RegistryPhyLoopbk == false) {
-		cfg2.bits.pad_crc = 0x1;
-		cfg2.bits.crc_enable = 0x1;
-	} else {
-		cfg2.bits.pad_crc = 0;
-		cfg2.bits.crc_enable = 0;
-	}
+	cfg2.bits.pad_crc = 0x1;
+	cfg2.bits.crc_enable = 0x1;
 
 	/* 1 - full duplex, 0 - half-duplex */
 	cfg2.bits.full_duplex = etdev->duplex_mode;
--- a/drivers/staging/et131x/et1310_phy.c
+++ b/drivers/staging/et131x/et1310_phy.c
@@ -469,9 +469,7 @@ void et131x_Mii_check(struct et131x_adap
 
 			spin_unlock_irqrestore(&etdev->Lock, flags);
 
-			/* Don't indicate state if we're in loopback mode */
-			if (etdev->RegistryPhyLoopbk == false)
-				netif_carrier_on(etdev->netdev);
+			netif_carrier_on(etdev->netdev);
 		} else {
 			dev_warn(&etdev->pdev->dev,
 			    "Link down - cable problem ?\n");
@@ -504,11 +502,7 @@ void et131x_Mii_check(struct et131x_adap
 				spin_unlock_irqrestore(&etdev->Lock,
 						       flags);
 
-				/* Only indicate state if we're in loopback
-				 * mode
-				 */
-				if (etdev->RegistryPhyLoopbk == false)
-					netif_carrier_off(etdev->netdev);
+				netif_carrier_off(etdev->netdev);
 			}
 
 			etdev->linkspeed = 0;
--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -807,40 +807,35 @@ void et131x_rx_dma_disable(struct et131x
  */
 void et131x_rx_dma_enable(struct et131x_adapter *etdev)
 {
-	if (etdev->RegistryPhyLoopbk)
-		/* RxDMA is disabled for loopback operation. */
-		writel(0x1, &etdev->regs->rxdma.csr.value);
-	else {
 	/* Setup the receive dma configuration register for normal operation */
-		RXDMA_CSR_t csr = { 0 };
+	RXDMA_CSR_t csr = { 0 };
 
-		csr.bits.fbr1_enable = 1;
-		if (etdev->RxRing.Fbr1BufferSize == 4096)
-			csr.bits.fbr1_size = 1;
-		else if (etdev->RxRing.Fbr1BufferSize == 8192)
-			csr.bits.fbr1_size = 2;
-		else if (etdev->RxRing.Fbr1BufferSize == 16384)
-			csr.bits.fbr1_size = 3;
+	csr.bits.fbr1_enable = 1;
+	if (etdev->RxRing.Fbr1BufferSize == 4096)
+		csr.bits.fbr1_size = 1;
+	else if (etdev->RxRing.Fbr1BufferSize == 8192)
+		csr.bits.fbr1_size = 2;
+	else if (etdev->RxRing.Fbr1BufferSize == 16384)
+		csr.bits.fbr1_size = 3;
 #ifdef USE_FBR0
-		csr.bits.fbr0_enable = 1;
-		if (etdev->RxRing.Fbr0BufferSize == 256)
-			csr.bits.fbr0_size = 1;
-		else if (etdev->RxRing.Fbr0BufferSize == 512)
-			csr.bits.fbr0_size = 2;
-		else if (etdev->RxRing.Fbr0BufferSize == 1024)
-			csr.bits.fbr0_size = 3;
+	csr.bits.fbr0_enable = 1;
+	if (etdev->RxRing.Fbr0BufferSize == 256)
+		csr.bits.fbr0_size = 1;
+	else if (etdev->RxRing.Fbr0BufferSize == 512)
+		csr.bits.fbr0_size = 2;
+	else if (etdev->RxRing.Fbr0BufferSize == 1024)
+		csr.bits.fbr0_size = 3;
 #endif
-		writel(csr.value, &etdev->regs->rxdma.csr.value);
+	writel(csr.value, &etdev->regs->rxdma.csr.value);
 
+	csr.value = readl(&etdev->regs->rxdma.csr.value);
+	if (csr.bits.halt_status != 0) {
+		udelay(5);
 		csr.value = readl(&etdev->regs->rxdma.csr.value);
 		if (csr.bits.halt_status != 0) {
-			udelay(5);
-			csr.value = readl(&etdev->regs->rxdma.csr.value);
-			if (csr.bits.halt_status != 0) {
-				dev_err(&etdev->pdev->dev,
-					"RX Dma failed to exit halt state.  CSR 0x%08x\n",
-					csr.value);
-			}
+			dev_err(&etdev->pdev->dev,
+			    "RX Dma failed to exit halt state.  CSR 0x%08x\n",
+				csr.value);
 		}
 	}
 }
--- a/drivers/staging/et131x/et1310_tx.c
+++ b/drivers/staging/et131x/et1310_tx.c
@@ -279,16 +279,11 @@ void et131x_tx_dma_disable(struct et131x
  */
 void et131x_tx_dma_enable(struct et131x_adapter *etdev)
 {
-	u32 csr = ET_TXDMA_SNGL_EPKT;
-	if (etdev->RegistryPhyLoopbk)
-		/* TxDMA is disabled for loopback operation. */
-		csr |= ET_TXDMA_CSR_HALT;
-	else
-		/* Setup the transmit dma configuration register for normal
-		 * operation
-		 */
-		csr |= PARM_DMA_CACHE_DEF << ET_TXDMA_CACHE_SHIFT;
-	writel(csr, &etdev->regs->txdma.csr);
+	/* Setup the transmit dma configuration register for normal
+	 * operation
+	 */
+	writel(ET_TXDMA_SNGL_EPKT|(PARM_DMA_CACHE_DEF << ET_TXDMA_CACHE_SHIFT),
+					&etdev->regs->txdma.csr);
 }
 
 /**
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -234,8 +234,6 @@ struct et131x_adapter {
 	u32 RegistryRxMemEnd;	/* Size of internal rx memory */
 	u32 RegistryJumboPacket;	/* Max supported ethernet packet size */
 
-	/* Validation helpers */
-	u8 RegistryPhyLoopbk;	/* Enable Phy loopback */
 
 	/* Derived from the registry: */
 	u8 AiForceDpx;		/* duplex setting */
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -329,52 +329,34 @@ void ConfigGlobalRegs(struct et131x_adap
 {
 	struct _GLOBAL_t __iomem *regs = &etdev->regs->global;
 
-	if (etdev->RegistryPhyLoopbk == false) {
-		if (etdev->RegistryJumboPacket < 2048) {
-			/* Tx / RxDMA and Tx/Rx MAC interfaces have a 1k word
-			 * block of RAM that the driver can split between Tx
-			 * and Rx as it desires.  Our default is to split it
-			 * 50/50:
-			 */
-			writel(0, &regs->rxq_start_addr);
-			writel(PARM_RX_MEM_END_DEF, &regs->rxq_end_addr);
-			writel(PARM_RX_MEM_END_DEF + 1, &regs->txq_start_addr);
-			writel(INTERNAL_MEM_SIZE - 1, &regs->txq_end_addr);
-		} else if (etdev->RegistryJumboPacket < 8192) {
-			/* For jumbo packets > 2k but < 8k, split 50-50. */
-			writel(0, &regs->rxq_start_addr);
-			writel(INTERNAL_MEM_RX_OFFSET, &regs->rxq_end_addr);
-			writel(INTERNAL_MEM_RX_OFFSET + 1, &regs->txq_start_addr);
-			writel(INTERNAL_MEM_SIZE - 1, &regs->txq_end_addr);
-		} else {
-			/* 9216 is the only packet size greater than 8k that
-			 * is available. The Tx buffer has to be big enough
-			 * for one whole packet on the Tx side. We'll make
-			 * the Tx 9408, and give the rest to Rx
-			 */
-			writel(0x0000, &regs->rxq_start_addr);
-			writel(0x01b3, &regs->rxq_end_addr);
-			writel(0x01b4, &regs->txq_start_addr);
-			writel(INTERNAL_MEM_SIZE - 1,&regs->txq_end_addr);
-		}
+	writel(0, &regs->rxq_start_addr);
+	writel(INTERNAL_MEM_SIZE - 1, &regs->txq_end_addr);
 
-		/* Initialize the loopback register. Disable all loopbacks. */
-		writel(0, &regs->loopback);
+	if (etdev->RegistryJumboPacket < 2048) {
+		/* Tx / RxDMA and Tx/Rx MAC interfaces have a 1k word
+		 * block of RAM that the driver can split between Tx
+		 * and Rx as it desires.  Our default is to split it
+		 * 50/50:
+		 */
+		writel(PARM_RX_MEM_END_DEF, &regs->rxq_end_addr);
+		writel(PARM_RX_MEM_END_DEF + 1, &regs->txq_start_addr);
+	} else if (etdev->RegistryJumboPacket < 8192) {
+		/* For jumbo packets > 2k but < 8k, split 50-50. */
+		writel(INTERNAL_MEM_RX_OFFSET, &regs->rxq_end_addr);
+		writel(INTERNAL_MEM_RX_OFFSET + 1, &regs->txq_start_addr);
 	} else {
-		/* For PHY Line loopback, the memory is configured as if Tx
-		 * and Rx both have all the memory.  This is because the
-		 * RxMAC will write data into the space, and the TxMAC will
-		 * read it out.
+		/* 9216 is the only packet size greater than 8k that
+		 * is available. The Tx buffer has to be big enough
+		 * for one whole packet on the Tx side. We'll make
+		 * the Tx 9408, and give the rest to Rx
 		 */
-		writel(0, &regs->rxq_start_addr);
-		writel(INTERNAL_MEM_SIZE - 1, &regs->rxq_end_addr);
-		writel(0, &regs->txq_start_addr);
-		writel(INTERNAL_MEM_SIZE - 1, &regs->txq_end_addr);
-
-		/* Initialize the loopback register (MAC loopback). */
-		writel(ET_LOOP_MAC, &regs->loopback);
+		writel(0x01b3, &regs->rxq_end_addr);
+		writel(0x01b4, &regs->txq_start_addr);
 	}
 
+	/* Initialize the loopback register. Disable all loopbacks. */
+	writel(0, &regs->loopback);
+
 	/* MSI Register */
 	writel(0, &regs->msi_config);
 
