From e76bb52c009615cdfa81e3cace8d4cf45a0912fb Mon Sep 17 00:00:00 2001
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Sun, 26 Apr 2009 16:06:02 +0200
Subject: [PATCH 080/102] Staging: rt2870: remove DOT11_N_SUPPORT ifdefs

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2870/2870_main_dev.c     |    2 
 drivers/staging/rt2870/Makefile            |    1 
 drivers/staging/rt2870/ap.h                |    2 
 drivers/staging/rt2870/chlist.h            |    8 --
 drivers/staging/rt2870/common/action.c     |    8 --
 drivers/staging/rt2870/common/ba_action.c  |    5 -
 drivers/staging/rt2870/common/cmm_data.c   |   40 ------------
 drivers/staging/rt2870/common/cmm_info.c   |   32 ----------
 drivers/staging/rt2870/common/cmm_sanity.c |    2 
 drivers/staging/rt2870/common/cmm_sync.c   |    9 --
 drivers/staging/rt2870/common/mlme.c       |   92 ++---------------------------
 drivers/staging/rt2870/common/rtmp_init.c  |   15 ----
 drivers/staging/rt2870/common/spectrum.c   |    4 -
 drivers/staging/rt2870/oid.h               |    2 
 drivers/staging/rt2870/rt_linux.c          |    2 
 drivers/staging/rt2870/rt_main_dev.c       |   15 ----
 drivers/staging/rt2870/rt_profile.c        |    9 --
 drivers/staging/rt2870/rtmp.h              |   66 --------------------
 drivers/staging/rt2870/rtmp_def.h          |   10 ---
 drivers/staging/rt2870/sta/assoc.c         |   15 ----
 drivers/staging/rt2870/sta/connect.c       |   41 ++----------
 drivers/staging/rt2870/sta/rtmp_data.c     |   22 ------
 drivers/staging/rt2870/sta/sanity.c        |    2 
 drivers/staging/rt2870/sta/sync.c          |   29 +--------
 drivers/staging/rt2870/sta_ioctl.c         |   46 --------------
 25 files changed, 34 insertions(+), 445 deletions(-)

--- a/drivers/staging/rt2870/2870_main_dev.c
+++ b/drivers/staging/rt2870/2870_main_dev.c
@@ -709,7 +709,6 @@ VOID RT2870_WatchDog(IN RTMP_ADAPTER *pA
 		}
 	}
 
-#ifdef DOT11_N_SUPPORT
 	// For Sigma debug, dump the ba_reordering sequence.
 	if((needDumpSeq == TRUE) && (pAd->CommonCfg.bDisableReordering == 0))
 	{
@@ -737,7 +736,6 @@ VOID RT2870_WatchDog(IN RTMP_ADAPTER *pA
 			NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
 		}
 	}
-#endif // DOT11_N_SUPPORT //
 }
 
 /*
--- a/drivers/staging/rt2870/ap.h
+++ b/drivers/staging/rt2870/ap.h
@@ -419,10 +419,8 @@ VOID ApLogEvent(
     IN PUCHAR           pAddr,
     IN USHORT           Event);
 
-#ifdef DOT11_N_SUPPORT
 VOID APUpdateOperationMode(
     IN PRTMP_ADAPTER pAd);
-#endif // DOT11_N_SUPPORT //
 
 VOID APUpdateCapabilityAndErpIe(
 	IN PRTMP_ADAPTER pAd);
--- a/drivers/staging/rt2870/chlist.h
+++ b/drivers/staging/rt2870/chlist.h
@@ -957,16 +957,12 @@ static inline VOID ChBandCheck(
 	switch(PhyMode)
 	{
 		case PHY_11A:
-#ifdef DOT11_N_SUPPORT
 		case PHY_11AN_MIXED:
-#endif // DOT11_N_SUPPORT //
 			*pChType = BAND_5G;
 			break;
 		case PHY_11ABG_MIXED:
-#ifdef DOT11_N_SUPPORT
 		case PHY_11AGN_MIXED:
 		case PHY_11ABGN_MIXED:
-#endif // DOT11_N_SUPPORT //
 			*pChType = BAND_BOTH;
 			break;
 
@@ -1114,8 +1110,6 @@ static inline VOID BuildBeaconChList(
 	}
 }
 
-
-#ifdef DOT11_N_SUPPORT
 static inline BOOLEAN IsValidChannel(
 	IN PRTMP_ADAPTER pAd,
 	IN UCHAR channel)
@@ -1273,8 +1267,6 @@ static inline VOID N_SetCenCh(
 		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
 	}
 }
-#endif // DOT11_N_SUPPORT //
-
 
 static inline UINT8 GetCuntryMaxTxPwr(
 	IN PRTMP_ADAPTER pAd,
--- a/drivers/staging/rt2870/common/action.c
+++ b/drivers/staging/rt2870/common/action.c
@@ -73,13 +73,11 @@ VOID ActionStateMachineInit(
 
 	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_DLS_CATE, (STATE_MACHINE_FUNC)ReservedAction);
 
-#ifdef DOT11_N_SUPPORT
 	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_BA_CATE, (STATE_MACHINE_FUNC)PeerBAAction);
 	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_HT_CATE, (STATE_MACHINE_FUNC)PeerHTAction);
 	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_ADD_BA_CATE, (STATE_MACHINE_FUNC)MlmeADDBAAction);
 	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_ORI_DELBA_CATE, (STATE_MACHINE_FUNC)MlmeDELBAAction);
 	StateMachineSetAction(S, ACT_IDLE, MT2_MLME_REC_DELBA_CATE, (STATE_MACHINE_FUNC)MlmeDELBAAction);
-#endif // DOT11_N_SUPPORT //
 
 	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_PUBLIC_CATE, (STATE_MACHINE_FUNC)PeerPublicAction);
 	StateMachineSetAction(S, ACT_IDLE, MT2_PEER_RM_CATE, (STATE_MACHINE_FUNC)PeerRMAction);
@@ -89,7 +87,6 @@ VOID ActionStateMachineInit(
 	StateMachineSetAction(S, ACT_IDLE, MT2_ACT_INVALID, (STATE_MACHINE_FUNC)MlmeInvalidAction);
 }
 
-#ifdef DOT11_N_SUPPORT
 VOID MlmeADDBAAction(
     IN PRTMP_ADAPTER pAd,
     IN MLME_QUEUE_ELEM *Elem)
@@ -254,7 +251,6 @@ VOID MlmeDELBAAction(
 		DBGPRINT(RT_DEBUG_TRACE, ("BA - MlmeDELBAAction() . 3 DELBA sent. Initiator(%d)\n", pInfo->Initiator));
     	}
 }
-#endif // DOT11_N_SUPPORT //
 
 VOID MlmeQOSAction(
     IN PRTMP_ADAPTER pAd,
@@ -282,7 +278,6 @@ VOID PeerQOSAction(
 {
 }
 
-#ifdef DOT11_N_SUPPORT
 VOID PeerBAAction(
 	IN PRTMP_ADAPTER pAd,
 	IN MLME_QUEUE_ELEM *Elem)
@@ -302,7 +297,6 @@ VOID PeerBAAction(
 			break;
 	}
 }
-#endif // DOT11_N_SUPPORT //
 
 VOID PeerPublicAction(
 	IN PRTMP_ADAPTER pAd,
@@ -337,7 +331,6 @@ VOID PeerRMAction(
 	return;
 }
 
-#ifdef DOT11_N_SUPPORT
 static VOID respond_ht_information_exchange_action(
 	IN PRTMP_ADAPTER pAd,
 	IN MLME_QUEUE_ELEM *Elem)
@@ -557,7 +550,6 @@ VOID SendRefreshBAR(
 		}
 	}
 }
-#endif // DOT11_N_SUPPORT //
 
 VOID ActHeaderInit(
     IN	PRTMP_ADAPTER	pAd,
--- a/drivers/staging/rt2870/common/ba_action.c
+++ b/drivers/staging/rt2870/common/ba_action.c
@@ -26,8 +26,6 @@
  */
 
 
-#ifdef DOT11_N_SUPPORT
-
 #include "../rt_config.h"
 
 
@@ -1764,6 +1762,3 @@ VOID Indicate_AMPDU_Packet(
 #endif
 	}
 }
-
-#endif // DOT11_N_SUPPORT //
-
--- a/drivers/staging/rt2870/common/cmm_data.c
+++ b/drivers/staging/rt2870/common/cmm_data.c
@@ -281,9 +281,7 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	{
 		// Fixed W52 with Activity scan issue in ABG_MIXED and ABGN_MIXED mode.
 		if (pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED
-#ifdef DOT11_N_SUPPORT
 			|| pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED
-#endif // DOT11_N_SUPPORT //
 		)
 		{
 			if (pAd->LatchRfRegs.Channel > 14)
@@ -511,9 +509,7 @@ static UCHAR TxPktClassification(
 	UCHAR			TxFrameType = TX_UNKOWN_FRAME;
 	UCHAR			Wcid;
 	MAC_TABLE_ENTRY	*pMacEntry = NULL;
-#ifdef DOT11_N_SUPPORT
 	BOOLEAN			bHTRate = FALSE;
-#endif // DOT11_N_SUPPORT //
 
 	Wcid = RTMP_GET_PACKET_WCID(pPacket);
 	if (Wcid == MCAST_WCID)
@@ -527,7 +523,6 @@ static UCHAR TxPktClassification(
 	{	// It's a specific packet need to force low rate, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame
 		TxFrameType = TX_LEGACY_FRAME;
 	}
-#ifdef DOT11_N_SUPPORT
 	else if (IS_HT_RATE(pMacEntry))
 	{	// it's a 11n capable packet
 
@@ -547,7 +542,6 @@ static UCHAR TxPktClassification(
 		else
 			TxFrameType = TX_LEGACY_FRAME;
 	}
-#endif // DOT11_N_SUPPORT //
 	else
 	{	// it's a legacy b/g packet.
 		if ((CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE) && pAd->CommonCfg.bAggregationCapable) &&
@@ -649,7 +643,7 @@ BOOLEAN RTMP_FillTxBlkInfo(
                 ((pAd->OpMode == OPMODE_AP) && (pMacEntry->MaxHTPhyMode.field.MODE == MODE_CCK) && (pMacEntry->MaxHTPhyMode.field.MCS == RATE_1)))
 			{	// Specific packet, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame, need force low rate.
 				pTxBlk->pTransmit = &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
-#ifdef DOT11_N_SUPPORT
+
 				// Modify the WMM bit for ICV issue. If we have a packet with EOSP field need to set as 1, how to handle it???
 				if (IS_HT_STA(pTxBlk->pMacEntry) &&
 					(CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_RALINK_CHIPSET)) &&
@@ -658,16 +652,13 @@ BOOLEAN RTMP_FillTxBlkInfo(
 					TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bWMM);
 					TX_BLK_SET_FLAG(pTxBlk, fTX_bForceNonQoS);
 				}
-#endif // DOT11_N_SUPPORT //
 			}
 
-#ifdef DOT11_N_SUPPORT
 			if ( (IS_HT_RATE(pMacEntry) == FALSE) &&
 				(CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE)))
 			{	// Currently piggy-back only support when peer is operate in b/g mode.
 				TX_BLK_SET_FLAG(pTxBlk, fTX_bPiggyBack);
 			}
-#endif // DOT11_N_SUPPORT //
 
 			if (RTMP_GET_PACKET_MOREDATA(pPacket))
 			{
@@ -1048,7 +1039,6 @@ VOID RTMPWriteTxWI(
 
 	pTxWI->NSEQ = NSeq;
 	// John tune the performace with Intel Client in 20 MHz performance
-#ifdef DOT11_N_SUPPORT
 	BASize = pAd->CommonCfg.TxBASize;
 
 	if( BASize >7 )
@@ -1056,7 +1046,6 @@ VOID RTMPWriteTxWI(
 	pTxWI->BAWinSize = BASize;
 	pTxWI->ShortGI = pTransmit->field.ShortGI;
 	pTxWI->STBC = pTransmit->field.STBC;
-#endif // DOT11_N_SUPPORT //
 
 	pTxWI->WirelessCliID = WCID;
 	pTxWI->MPDUtotalByteCount = Length;
@@ -1069,7 +1058,6 @@ VOID RTMPWriteTxWI(
 	pTxWI->PHYMODE = pTransmit->field.MODE;
 	pTxWI->CFACK = CfAck;
 
-#ifdef DOT11_N_SUPPORT
 	if (pMac)
 	{
 		if (pAd->CommonCfg.bMIMOPSEnable)
@@ -1099,7 +1087,6 @@ VOID RTMPWriteTxWI(
 			pTxWI->MpduDensity = pMac->MpduDensity;
 		}
 	}
-#endif // DOT11_N_SUPPORT //
 
 	pTxWI->PacketId = pTxWI->MCS;
 	NdisMoveMemory(pOutTxWI, &TxWI, sizeof(TXWI_STRUC));
@@ -1113,10 +1100,7 @@ VOID RTMPWriteTxWI_Data(
 {
 	HTTRANSMIT_SETTING	*pTransmit;
 	PMAC_TABLE_ENTRY	pMacEntry;
-#ifdef DOT11_N_SUPPORT
 	UCHAR				BASize;
-#endif // DOT11_N_SUPPORT //
-
 
 	ASSERT(pTxWI);
 
@@ -1142,7 +1126,6 @@ VOID RTMPWriteTxWI_Data(
 
 	// If CCK or OFDM, BW must be 20
 	pTxWI->BW = (pTransmit->field.MODE <= MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
-#ifdef DOT11_N_SUPPORT
 	pTxWI->AMPDU	= ((pTxBlk->TxFrameType == TX_AMPDU_FRAME) ? TRUE : FALSE);
 
 	// John tune the performace with Intel Client in 20 MHz performance
@@ -1164,12 +1147,10 @@ VOID RTMPWriteTxWI_Data(
 	pTxWI->BAWinSize = BASize;
 	pTxWI->ShortGI = pTransmit->field.ShortGI;
 	pTxWI->STBC = pTransmit->field.STBC;
-#endif // DOT11_N_SUPPORT //
 
 	pTxWI->MCS = pTransmit->field.MCS;
 	pTxWI->PHYMODE = pTransmit->field.MODE;
 
-#ifdef DOT11_N_SUPPORT
 	if (pMacEntry)
 	{
 		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC) && (pTransmit->field.MCS > 7))
@@ -1196,7 +1177,6 @@ VOID RTMPWriteTxWI_Data(
 			pTxWI->MpduDensity = pMacEntry->MpduDensity;
 		}
 	}
-#endif // DOT11_N_SUPPORT //
 
 #ifdef DBG_DIAGNOSE
 		if (pTxBlk->QueIdx== 0)
@@ -1241,7 +1221,6 @@ VOID RTMPWriteTxWI_Cache(
 		pTxWI->PacketId = pTransmit->field.MCS;
 	}
 
-#ifdef DOT11_N_SUPPORT
 	pTxWI->AMPDU = ((pMacEntry->NoBADataCountDown == 0) ? TRUE: FALSE);
 	pTxWI->MIMOps = 0;
 
@@ -1263,7 +1242,6 @@ VOID RTMPWriteTxWI_Cache(
 			}
 		}
 	}
-#endif // DOT11_N_SUPPORT //
 
 #ifdef DBG_DIAGNOSE
 	if (pTxBlk->QueIdx== 0)
@@ -1380,12 +1358,10 @@ BOOLEAN PeerIsAggreOn(
 
 	if (pMacEntry != NULL && CLIENT_STATUS_TEST_FLAG(pMacEntry, AFlags))
 	{
-#ifdef DOT11_N_SUPPORT
 		if (pMacEntry->HTPhyMode.field.MODE >= MODE_HTMIX)
 		{
 			return TRUE;
 		}
-#endif // DOT11_N_SUPPORT //
 
 #ifdef AGGREGATION_SUPPORT
 		if (TxRate >= RATE_6 && pAd->CommonCfg.bAggregationCapable && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE))))
@@ -1852,11 +1828,8 @@ BOOLEAN MacTableDeleteEntry(
 			// Delete this entry from ASIC on-chip WCID Table
 			RT28XX_STA_ENTRY_MAC_RESET(pAd, wcid);
 
-#ifdef DOT11_N_SUPPORT
 			// free resources of BA
 			BASessionTearDownALL(pAd, pEntry->Aid);
-#endif // DOT11_N_SUPPORT //
-
 
 			pPrevEntry = NULL;
 			pProbeEntry = pAd->MacTab.Hash[HashIdx];
@@ -1910,9 +1883,7 @@ BOOLEAN MacTableDeleteEntry(
 	//Reset operating mode when no Sta.
 	if (pAd->MacTab.Size == 0)
 	{
-#ifdef DOT11_N_SUPPORT
 		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 0;
-#endif // DOT11_N_SUPPORT //
 		AsicUpdateProtect(pAd, 0 /*pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode*/, (ALLN_SETPROTECT), TRUE, 0 /*pAd->MacTab.fAnyStationNonGF*/);
 	}
 
@@ -1939,11 +1910,8 @@ VOID MacTableReset(
 	{
 		if (pAd->MacTab.Content[i].ValidAsCLI == TRUE)
 	   {
-
-#ifdef DOT11_N_SUPPORT
 			// free resources of BA
 			BASessionTearDownALL(pAd, i);
-#endif // DOT11_N_SUPPORT //
 
 			pAd->MacTab.Content[i].ValidAsCLI = FALSE;
 
@@ -2279,7 +2247,6 @@ VOID Indicate_Legacy_Packet(
 	STATS_INC_RX_PACKETS(pAd, FromWhichBSSID);
 
 #ifdef RT2870
-#ifdef DOT11_N_SUPPORT
 	if (pAd->CommonCfg.bDisableReordering == 0)
 	{
 		PBA_REC_ENTRY		pBAEntry;
@@ -2309,7 +2276,6 @@ VOID Indicate_Legacy_Packet(
 			}
 		}
 	}
-#endif // DOT11_N_SUPPORT //
 #endif // RT2870 //
 
 	wlan_802_11_to_802_3_packet(pAd, pRxBlk, Header802_3, FromWhichBSSID);
@@ -2328,22 +2294,18 @@ VOID CmmRxnonRalinkFrameIndicate(
 	IN	RX_BLK			*pRxBlk,
 	IN	UCHAR			FromWhichBSSID)
 {
-#ifdef DOT11_N_SUPPORT
 	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU) && (pAd->CommonCfg.bDisableReordering == 0))
 	{
 		Indicate_AMPDU_Packet(pAd, pRxBlk, FromWhichBSSID);
 	}
 	else
-#endif // DOT11_N_SUPPORT //
 	{
-#ifdef DOT11_N_SUPPORT
 		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU))
 		{
 			// handle A-MSDU
 			Indicate_AMSDU_Packet(pAd, pRxBlk, FromWhichBSSID);
 		}
 		else
-#endif // DOT11_N_SUPPORT //
 		{
 			Indicate_Legacy_Packet(pAd, pRxBlk, FromWhichBSSID);
 		}
--- a/drivers/staging/rt2870/common/cmm_info.c
+++ b/drivers/staging/rt2870/common/cmm_info.c
@@ -63,7 +63,6 @@ INT	Show_FragThreshold_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	OUT	PUCHAR			pBuf);
 
-#ifdef DOT11_N_SUPPORT
 INT	Show_HtBw_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	OUT	PUCHAR			pBuf);
@@ -103,7 +102,6 @@ INT	Show_HtAmsdu_Proc(
 INT	Show_HtAutoBa_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	OUT	PUCHAR			pBuf);
-#endif // DOT11_N_SUPPORT //
 
 INT	Show_CountryRegion_Proc(
 	IN	PRTMP_ADAPTER	pAd,
@@ -182,7 +180,6 @@ static struct {
 	{"BGProtection",			Show_BGProtection_Proc},
 	{"RTSThreshold",			Show_RTSThreshold_Proc},
 	{"FragThreshold",			Show_FragThreshold_Proc},
-#ifdef DOT11_N_SUPPORT
 	{"HtBw",					Show_HtBw_Proc},
 	{"HtMcs",					Show_HtMcs_Proc},
 	{"HtGi",					Show_HtGi_Proc},
@@ -193,7 +190,6 @@ static struct {
 	{"HtRdg",		        	Show_HtRdg_Proc},
 	{"HtAmsdu",		        	Show_HtAmsdu_Proc},
 	{"HtAutoBa",		        Show_HtAutoBa_Proc},
-#endif // DOT11_N_SUPPORT //
 	{"CountryRegion",			Show_CountryRegion_Proc},
 	{"CountryRegionABand",		Show_CountryRegionABand_Proc},
 	{"CountryCode",				Show_CountryCode_Proc},
@@ -344,14 +340,12 @@ INT	Set_WirelessMode_Proc(
 	{
 		INT MaxPhyMode = PHY_11G;
 
-#ifdef DOT11_N_SUPPORT
 		MaxPhyMode = PHY_11N_5G;
-#endif // DOT11_N_SUPPORT //
 
 		if (WirelessMode <= MaxPhyMode)
 		{
 			RTMPSetPhyMode(pAd, WirelessMode);
-#ifdef DOT11_N_SUPPORT
+
 			if (WirelessMode >= PHY_11ABGN_MIXED)
 			{
 				pAd->CommonCfg.BACapability.field.AutoBA = TRUE;
@@ -362,7 +356,7 @@ INT	Set_WirelessMode_Proc(
 				pAd->CommonCfg.BACapability.field.AutoBA = FALSE;
 				pAd->CommonCfg.REGBACapability.field.AutoBA = FALSE;
 			}
-#endif // DOT11_N_SUPPORT //
+
 			// Set AdhocMode rates
 			if (pAd->StaCfg.BssType == BSS_ADHOC)
 			{
@@ -380,9 +374,7 @@ INT	Set_WirelessMode_Proc(
 	// it is needed to set SSID to take effect
 	if (success == TRUE)
 	{
-#ifdef DOT11_N_SUPPORT
 		SetCommonHT(pAd);
-#endif // DOT11_N_SUPPORT //
 		DBGPRINT(RT_DEBUG_TRACE, ("Set_WirelessMode_Proc::(=%ld)\n", WirelessMode));
 	}
 	else
@@ -419,7 +411,6 @@ INT	Set_Channel_Proc(
 
 			if (MONITOR_ON(pAd))
 			{
-#ifdef DOT11_N_SUPPORT
 				N_ChannelCheck(pAd);
 				if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED &&
 					pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
@@ -431,7 +422,6 @@ INT	Set_Channel_Proc(
 								pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
 				}
 				else
-#endif // DOT11_N_SUPPORT //
 				{
 					AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
 					AsicLockChannel(pAd, pAd->CommonCfg.Channel);
@@ -1489,12 +1479,10 @@ VOID	RTMPSetPhyMode(
 		case PHY_11G:
 		case PHY_11BG_MIXED:
 		case PHY_11ABG_MIXED:
-#ifdef DOT11_N_SUPPORT
 		case PHY_11N_2_4G:
 		case PHY_11ABGN_MIXED:
 		case PHY_11BGN_MIXED:
 		case PHY_11GN_MIXED:
-#endif // DOT11_N_SUPPORT //
 			pAd->CommonCfg.SupRate[0]  = 0x82;	  // 1 mbps, in units of 0.5 Mbps, basic rate
 			pAd->CommonCfg.SupRate[1]  = 0x84;	  // 2 mbps, in units of 0.5 Mbps, basic rate
 			pAd->CommonCfg.SupRate[2]  = 0x8B;	  // 5.5 mbps, in units of 0.5 Mbps, basic rate
@@ -1524,11 +1512,9 @@ VOID	RTMPSetPhyMode(
 			break;
 
 		case PHY_11A:
-#ifdef DOT11_N_SUPPORT
 		case PHY_11AN_MIXED:
 		case PHY_11AGN_MIXED:
 		case PHY_11N_5G:
-#endif // DOT11_N_SUPPORT //
 			pAd->CommonCfg.SupRate[0]  = 0x8C;	  // 6 mbps, in units of 0.5 Mbps, basic rate
 			pAd->CommonCfg.SupRate[1]  = 0x12;	  // 9 mbps, in units of 0.5 Mbps
 			pAd->CommonCfg.SupRate[2]  = 0x98;	  // 12 mbps, in units of 0.5 Mbps, basic rate
@@ -1558,8 +1544,6 @@ VOID	RTMPSetPhyMode(
 	pAd->CommonCfg.BandState = UNKNOWN_BAND;
 }
 
-
-#ifdef DOT11_N_SUPPORT
 /*
 	========================================================================
 	Routine Description:
@@ -1947,7 +1931,6 @@ VOID	RTMPUpdateHTIE(
 
         DBGPRINT(RT_DEBUG_TRACE,("RTMPUpdateHTIE <== \n"));
 }
-#endif // DOT11_N_SUPPORT //
 
 /*
 	========================================================================
@@ -2229,9 +2212,7 @@ VOID RTMPIoctlGetMacTable(
 			COPY_MAC_ADDR(MacTab.Entry[MacTab.Num].Addr, &pAd->MacTab.Content[i].Addr);
 			MacTab.Entry[MacTab.Num].Aid = (UCHAR)pAd->MacTab.Content[i].Aid;
 			MacTab.Entry[MacTab.Num].Psm = pAd->MacTab.Content[i].PsMode;
-#ifdef DOT11_N_SUPPORT
 			MacTab.Entry[MacTab.Num].MimoPs = pAd->MacTab.Content[i].MmpsMode;
-#endif // DOT11_N_SUPPORT //
 
 			// Fill in RSSI per entry
 			MacTab.Entry[MacTab.Num].AvgRssi0 = pAd->MacTab.Content[i].RssiSample.AvgRssi0;
@@ -2297,7 +2278,6 @@ VOID RTMPIoctlGetMacTable(
 	kfree(msg);
 }
 
-#ifdef DOT11_N_SUPPORT
 INT	Set_BASetup_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			arg)
@@ -2982,10 +2962,7 @@ INT	Set_HtMimoPs_Proc(
 
 	return TRUE;
 }
-#endif // DOT11_N_SUPPORT //
-
 
-#ifdef DOT11_N_SUPPORT
 INT	SetCommonHT(
 	IN	PRTMP_ADAPTER	pAd)
 {
@@ -3007,7 +2984,6 @@ INT	SetCommonHT(
 
 	return TRUE;
 }
-#endif // DOT11_N_SUPPORT //
 
 INT	Set_FixedTxMode_Proc(
 	IN	PRTMP_ADAPTER	pAd,
@@ -3138,7 +3114,6 @@ INT	Show_WirelessMode_Proc(
 		case PHY_11G:
 			sprintf(pBuf, "\t11G");
 			break;
-#ifdef DOT11_N_SUPPORT
 		case PHY_11ABGN_MIXED:
 			sprintf(pBuf, "\t11A/B/G/N");
 			break;
@@ -3160,7 +3135,6 @@ INT	Show_WirelessMode_Proc(
 		case PHY_11N_5G:
 			sprintf(pBuf, "\t11N only with 5G");
 			break;
-#endif // DOT11_N_SUPPORT //
 		default:
 			sprintf(pBuf, "\tUnknow Value(%d)", pAd->CommonCfg.PhyMode);
 			break;
@@ -3254,7 +3228,6 @@ INT	Show_FragThreshold_Proc(
 	return 0;
 }
 
-#ifdef DOT11_N_SUPPORT
 INT	Show_HtBw_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	OUT	PUCHAR			pBuf)
@@ -3376,7 +3349,6 @@ INT	Show_HtAutoBa_Proc(
 	sprintf(pBuf, "\t%s", pAd->CommonCfg.BACapability.field.AutoBA ? "TRUE":"FALSE");
 	return 0;
 }
-#endif // DOT11_N_SUPPORT //
 
 INT	Show_CountryRegion_Proc(
 	IN	PRTMP_ADAPTER	pAd,
--- a/drivers/staging/rt2870/common/cmm_sanity.c
+++ b/drivers/staging/rt2870/common/cmm_sanity.c
@@ -588,7 +588,6 @@ BOOLEAN PeerBeaconAndProbeRspSanity(
         			else
         				*pRalinkIe = 0xf0000000; // Set to non-zero value (can't set bit0-2) to represent this is Ralink Chip. So at linkup, we will set ralinkchip flag.
                 }
-#ifdef DOT11_N_SUPPORT
 		// This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
 
                 // Other vendors had production before IE_HT_CAP value is assigned. To backward support those old-firmware AP,
@@ -607,7 +606,6 @@ BOOLEAN PeerBeaconAndProbeRspSanity(
                         *AddHtInfoLen = SIZE_ADD_HT_INFO_IE;
                     }
                 }
-#endif // DOT11_N_SUPPORT //
                 else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))
                 {
                     // Copy to pVIE which will report to microsoft bssid list.
--- a/drivers/staging/rt2870/common/cmm_sync.c
+++ b/drivers/staging/rt2870/common/cmm_sync.c
@@ -95,9 +95,7 @@ VOID BuildChannelList(
 
 	// if not 11a-only mode, channel list starts from 2.4Ghz band
 	if ((pAd->CommonCfg.PhyMode != PHY_11A)
-#ifdef DOT11_N_SUPPORT
 		&& (pAd->CommonCfg.PhyMode != PHY_11AN_MIXED) && (pAd->CommonCfg.PhyMode != PHY_11N_5G)
-#endif // DOT11_N_SUPPORT //
 	)
 	{
 		switch (pAd->CommonCfg.CountryRegion  & 0x7f)
@@ -146,10 +144,8 @@ VOID BuildChannelList(
 	}
 
 	if ((pAd->CommonCfg.PhyMode == PHY_11A) || (pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED)
-#ifdef DOT11_N_SUPPORT
 		|| (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) || (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED)
 		|| (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED) || (pAd->CommonCfg.PhyMode == PHY_11N_5G)
-#endif // DOT11_N_SUPPORT //
 	)
 	{
 		switch (pAd->CommonCfg.CountryRegionForABand & 0x7f)
@@ -506,9 +502,7 @@ VOID ScanNextChannel(
 		else // must be SCAN_PASSIVE or SCAN_ACTIVE
 		{
 			if ((pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED)
-#ifdef DOT11_N_SUPPORT
 				|| (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) || (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED)
-#endif // DOT11_N_SUPPORT //
 			)
 			{
 				if (pAd->MlmeAux.Channel > 14)
@@ -567,7 +561,6 @@ VOID ScanNextChannel(
 				FrameLen += Tmp;
 			}
 
-#ifdef DOT11_N_SUPPORT
 			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
 			{
 				ULONG	Tmp;
@@ -597,8 +590,6 @@ VOID ScanNextChannel(
 				}
 				FrameLen += Tmp;
 			}
-#endif // DOT11_N_SUPPORT //
-
 
 			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 			MlmeFreeMemory(pAd, pOutBuffer);
--- a/drivers/staging/rt2870/common/mlme.c
+++ b/drivers/staging/rt2870/common/mlme.c
@@ -50,9 +50,7 @@ UCHAR	Ccx2QosInfo[] = {0x00, 0x40, 0x96,
 UCHAR   RALINK_OUI[]  = {0x00, 0x0c, 0x43};
 UCHAR   BROADCOM_OUI[]  = {0x00, 0x90, 0x4c};
 UCHAR   WPS_OUI[] = {0x00, 0x50, 0xf2, 0x04};
-#ifdef DOT11_N_SUPPORT
 UCHAR	PRE_N_HT_OUI[]	= {0x00, 0x90, 0x4c};
-#endif // DOT11_N_SUPPORT //
 
 UCHAR RateSwitchTable[] = {
 // Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
@@ -128,7 +126,6 @@ UCHAR RateSwitchTable11G[] = {
     0x07, 0x10,  7, 10, 13,
 };
 
-#ifdef DOT11_N_SUPPORT
 UCHAR RateSwitchTable11N1S[] = {
 // Item No.   Mode   Curr-MCS   TrainUp   TrainDown		// Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
     0x09, 0x00,  0,  0,  0,						// Initial used item after association
@@ -293,7 +290,6 @@ UCHAR RateSwitchTable11BGN3SForABand[] =
     0x0a, 0x20, 23,  8, 25,
     0x0b, 0x22, 23,  8, 25,
 };
-#endif // DOT11_N_SUPPORT //
 
 PUCHAR ReasonString[] = {
 	/* 0  */	 "Reserved",
@@ -340,11 +336,9 @@ USHORT RateIdTo500Kbps[] = { 2, 4, 11, 2
 UCHAR  SsidIe	 = IE_SSID;
 UCHAR  SupRateIe = IE_SUPP_RATES;
 UCHAR  ExtRateIe = IE_EXT_SUPP_RATES;
-#ifdef DOT11_N_SUPPORT
 UCHAR  HtCapIe = IE_HT_CAP;
 UCHAR  AddHtInfoIe = IE_ADD_HT;
 UCHAR  NewExtChanIe = IE_SECONDARY_CH_OFFSET;
-#endif // DOT11_N_SUPPORT //
 UCHAR  ErpIe	 = IE_ERP;
 UCHAR  DsIe 	 = IE_DS_PARM;
 UCHAR  TimIe	 = IE_TIM;
@@ -861,10 +855,8 @@ VOID MlmePeriodicExec(
 		RT2870_WatchDog(pAd);
 #endif // RT2870 //
 
-#ifdef DOT11_N_SUPPORT
    		// Need statistics after read counter. So put after NICUpdateRawCounters
 		ORIBATimerTimeout(pAd);
-#endif // DOT11_N_SUPPORT //
 
 		// if MGMT RING is full more than twice within 1 second, we consider there's
 		// a hardware problem stucking the TX path. In this case, try a hardware reset
@@ -1135,7 +1127,6 @@ VOID STAMlmePeriodicExec(
 
 SKIP_AUTO_SCAN_CONN:
 
-#ifdef DOT11_N_SUPPORT
     if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap !=0) && (pAd->MacTab.fAnyBASession == FALSE))
 	{
 		pAd->MacTab.fAnyBASession = TRUE;
@@ -1146,7 +1137,6 @@ SKIP_AUTO_SCAN_CONN:
 		pAd->MacTab.fAnyBASession = FALSE;
 		AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode,  ALLN_SETPROTECT, FALSE, FALSE);
 	}
-#endif // DOT11_N_SUPPORT //
 
 	return;
 }
@@ -1256,7 +1246,6 @@ VOID MlmeSelectTxRateTable(
 
 		if ((pAd->OpMode == OPMODE_STA) && ADHOC_ON(pAd))
 		{
-#ifdef DOT11_N_SUPPORT
 			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) &&
 				(pEntry->HTCapability.MCSSet[0] == 0xff) &&
 				((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
@@ -1286,11 +1275,8 @@ VOID MlmeSelectTxRateTable(
 
 			}
 			else
-#endif // DOT11_N_SUPPORT //
 				if ((pEntry->RateLen == 4)
-#ifdef DOT11_N_SUPPORT
 					&& (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)
-#endif // DOT11_N_SUPPORT //
 					)
 			{
 				*ppTable = RateSwitchTable11B;
@@ -1315,7 +1301,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-#ifdef DOT11_N_SUPPORT
 		//if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
 		//	((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
 		if ((pEntry->RateLen == 12) && (pEntry->HTCapability.MCSSet[0] == 0xff) &&
@@ -1378,12 +1363,10 @@ VOID MlmeSelectTxRateTable(
 
 			break;
 		}
-#endif // DOT11_N_SUPPORT //
+
 		//else if ((pAd->StaActive.SupRateLen == 4) && (pAd->StaActive.ExtRateLen == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
 		if ((pEntry->RateLen == 4)
-#ifdef DOT11_N_SUPPORT
 			&& (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)
-#endif // DOT11_N_SUPPORT //
 			)
 		{// B only AP
 			*ppTable = RateSwitchTable11B;
@@ -1395,9 +1378,7 @@ VOID MlmeSelectTxRateTable(
 
 		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen > 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
 		if ((pEntry->RateLen > 8)
-#ifdef DOT11_N_SUPPORT
 			&& (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)
-#endif // DOT11_N_SUPPORT //
 			)
 		{// B/G  mixed AP
 			*ppTable = RateSwitchTable11BG;
@@ -1409,9 +1390,7 @@ VOID MlmeSelectTxRateTable(
 
 		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
 		if ((pEntry->RateLen == 8)
-#ifdef DOT11_N_SUPPORT
 			&& (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)
-#endif // DOT11_N_SUPPORT //
 			)
 		{// G only AP
 			*ppTable = RateSwitchTable11G;
@@ -1420,15 +1399,11 @@ VOID MlmeSelectTxRateTable(
 
 			break;
 		}
-#ifdef DOT11_N_SUPPORT
-#endif // DOT11_N_SUPPORT //
 
 		IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
 		{
-#ifdef DOT11_N_SUPPORT
 			//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
 			if ((pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0))
-#endif // DOT11_N_SUPPORT //
 			{	// Legacy mode
 				if (pAd->CommonCfg.MaxTxRate <= RATE_11)
 				{
@@ -1451,7 +1426,7 @@ VOID MlmeSelectTxRateTable(
 				}
 				break;
 			}
-#ifdef DOT11_N_SUPPORT
+
 			if (pAd->LatchRfRegs.Channel <= 14)
 			{
 				if (pAd->CommonCfg.TxStream == 1)
@@ -1486,7 +1461,7 @@ VOID MlmeSelectTxRateTable(
 					DBGPRINT_RAW(RT_DEBUG_ERROR,("DRS: unkown mode,default use 11N 2S AP \n"));
 				}
 			}
-#endif // DOT11_N_SUPPORT //
+
 			DBGPRINT_RAW(RT_DEBUG_ERROR,("DRS: unkown mode (SupRateLen=%d, ExtRateLen=%d, MCSSet[0]=0x%x, MCSSet[1]=0x%x)\n",
 				pAd->StaActive.SupRateLen, pAd->StaActive.ExtRateLen, pAd->StaActive.SupportedPhyInfo.MCSSet[0], pAd->StaActive.SupportedPhyInfo.MCSSet[1]));
 		}
@@ -1710,13 +1685,11 @@ VOID MlmeSetTxRate(
 {
 	UCHAR	MaxMode = MODE_OFDM;
 
-#ifdef DOT11_N_SUPPORT
 	MaxMode = MODE_HTGREENFIELD;
 
 	if (pTxRate->STBC && (pAd->StaCfg.MaxHTPhyMode.field.STBC) && (pAd->Antenna.field.TxPath == 2))
 		pAd->StaCfg.HTPhyMode.field.STBC = STBC_USE;
 	else
-#endif // DOT11_N_SUPPORT //
 		pAd->StaCfg.HTPhyMode.field.STBC = STBC_NONE;
 
 	if (pTxRate->CurrMCS < MCS_AUTO)
@@ -1746,14 +1719,11 @@ VOID MlmeSetTxRate(
 		if (pTxRate->Mode <= MaxMode)
 			pAd->StaCfg.HTPhyMode.field.MODE = pTxRate->Mode;
 
-#ifdef DOT11_N_SUPPORT
 		if (pTxRate->ShortGI && (pAd->StaCfg.MaxHTPhyMode.field.ShortGI))
 			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_400;
 		else
-#endif // DOT11_N_SUPPORT //
 			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
 
-#ifdef DOT11_N_SUPPORT
 		// Reexam each bandwidth's SGI support.
 		if (pAd->StaCfg.HTPhyMode.field.ShortGI == GI_400)
 		{
@@ -1797,17 +1767,15 @@ VOID MlmeSetTxRate(
 		{
 			AsicUpdateProtect(pAd, HT_RTSCTS_6M, ALLN_SETPROTECT, TRUE, (BOOLEAN)pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent);
 		}
-#endif // DOT11_N_SUPPORT //
 
 		pEntry->HTPhyMode.field.STBC	= pAd->StaCfg.HTPhyMode.field.STBC;
 		pEntry->HTPhyMode.field.ShortGI	= pAd->StaCfg.HTPhyMode.field.ShortGI;
 		pEntry->HTPhyMode.field.MCS		= pAd->StaCfg.HTPhyMode.field.MCS;
 		pEntry->HTPhyMode.field.MODE	= pAd->StaCfg.HTPhyMode.field.MODE;
-#ifdef DOT11_N_SUPPORT
+
 		if ((pAd->StaCfg.MaxHTPhyMode.field.MODE == MODE_HTGREENFIELD) &&
 		    pAd->WIFItestbed.bGreenField)
 		    pEntry->HTPhyMode.field.MODE = MODE_HTGREENFIELD;
-#endif // DOT11_N_SUPPORT //
 	}
 
 	pAd->LastTxRate = (USHORT)(pEntry->HTPhyMode.word);
@@ -1959,14 +1927,12 @@ VOID MlmeDynamicTxRateSwitching(
 
 		pCurrTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(CurrRateIdx+1)*5];
 
-#ifdef DOT11_N_SUPPORT
 		if ((Rssi > -65) && (pCurrTxRate->Mode >= MODE_HTMIX))
 		{
 			TrainUp		= (pCurrTxRate->TrainUp + (pCurrTxRate->TrainUp >> 1));
 			TrainDown	= (pCurrTxRate->TrainDown + (pCurrTxRate->TrainDown >> 1));
 		}
 		else
-#endif // DOT11_N_SUPPORT //
 		{
 			TrainUp		= pCurrTxRate->TrainUp;
 			TrainDown	= pCurrTxRate->TrainDown;
@@ -2090,7 +2056,7 @@ VOID MlmeDynamicTxRateSwitching(
 					RssiOffset = 8;
 				}
 			}
-#ifdef DOT11_N_SUPPORT
+
 			/*if (MCS15)*/
 			if ((pTable == RateSwitchTable11BGN3S) ||
 				(pTable == RateSwitchTable11N3S) ||
@@ -2157,7 +2123,6 @@ VOID MlmeDynamicTxRateSwitching(
 					TxRateIdx = MCS0;
 			}
 			else
-#endif // DOT11_N_SUPPORT //
 			{// Legacy mode
 				if (MCS7 && (Rssi > -70))
 					TxRateIdx = MCS7;
@@ -2391,14 +2356,12 @@ VOID StaQuickResponeForRateUpExec(
 
 		pCurrTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(CurrRateIdx+1)*5];
 
-#ifdef DOT11_N_SUPPORT
 		if ((Rssi > -65) && (pCurrTxRate->Mode >= MODE_HTMIX))
 		{
 			TrainUp		= (pCurrTxRate->TrainUp + (pCurrTxRate->TrainUp >> 1));
 			TrainDown	= (pCurrTxRate->TrainDown + (pCurrTxRate->TrainDown >> 1));
 		}
 		else
-#endif // DOT11_N_SUPPORT //
 		{
 			TrainUp		= pCurrTxRate->TrainUp;
 			TrainDown	= pCurrTxRate->TrainDown;
@@ -2961,9 +2924,7 @@ VOID MlmeUpdateTxRates(
 		{
 			case PHY_11BG_MIXED:
 			case PHY_11B:
-#ifdef DOT11_N_SUPPORT
 			case PHY_11BGN_MIXED:
-#endif // DOT11_N_SUPPORT //
 				pAd->CommonCfg.MlmeRate = RATE_1;
 				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
 				pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
@@ -2976,22 +2937,18 @@ VOID MlmeUpdateTxRates(
 				break;
 			case PHY_11G:
 			case PHY_11A:
-#ifdef DOT11_N_SUPPORT
 			case PHY_11AGN_MIXED:
 			case PHY_11GN_MIXED:
 			case PHY_11N_2_4G:
 			case PHY_11AN_MIXED:
 			case PHY_11N_5G:
-#endif // DOT11_N_SUPPORT //
 				pAd->CommonCfg.MlmeRate = RATE_6;
 				pAd->CommonCfg.RtsRate = RATE_6;
 				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
 				pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
 				break;
 			case PHY_11ABG_MIXED:
-#ifdef DOT11_N_SUPPORT
 			case PHY_11ABGN_MIXED:
-#endif // DOT11_N_SUPPORT //
 				if (pAd->CommonCfg.Channel <= 14)
 				{
 					pAd->CommonCfg.MlmeRate = RATE_1;
@@ -3034,7 +2991,6 @@ VOID MlmeUpdateTxRates(
 			 pAd->CommonCfg.MlmeTransmit.word, pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word ,pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word ,pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word ));
 }
 
-#ifdef DOT11_N_SUPPORT
 /*
 	==========================================================================
 	Description:
@@ -3185,7 +3141,6 @@ VOID MlmeUpdateHtTxRates(
 		pHtPhy->field.BW, pHtPhy->field.ShortGI, pHtPhy->field.MODE));
 	DBGPRINT(RT_DEBUG_TRACE,("MlmeUpdateHtTxRates<=== \n"));
 }
-#endif // DOT11_N_SUPPORT //
 
 // IRQL = DISPATCH_LEVEL
 VOID MlmeRadioOff(
@@ -3230,7 +3185,6 @@ VOID BssTableInit(
 	}
 }
 
-#ifdef DOT11_N_SUPPORT
 VOID BATableInit(
 	IN PRTMP_ADAPTER pAd,
     IN BA_TABLE *Tab)
@@ -3250,7 +3204,6 @@ VOID BATableInit(
 		Tab->BAOriEntry[i].ORI_BA_Status = Originator_NONE;
 	}
 }
-#endif // DOT11_N_SUPPORT //
 
 /*! \brief search the BSS table by SSID
  *	\param p_tab pointer to the bss table
@@ -3360,7 +3313,6 @@ VOID BssTableDeleteEntry(
 	}
 }
 
-#ifdef DOT11_N_SUPPORT
 /*
 	========================================================================
 	Routine Description:
@@ -3392,7 +3344,6 @@ VOID BATableDeleteORIEntry(
 		NdisReleaseSpinLock(&pAd->BATabLock);
 	}
 }
-#endif // DOT11_N_SUPPORT //
 
 /*! \brief
  *	\param
@@ -3509,7 +3460,7 @@ VOID BssEntrySet(
 
 	pBss->AddHtInfoLen = 0;
 	pBss->HtCapabilityLen = 0;
-#ifdef DOT11_N_SUPPORT
+
 	if (HtCapabilityLen> 0)
 	{
 		pBss->HtCapabilityLen = HtCapabilityLen;
@@ -3529,7 +3480,6 @@ VOID BssEntrySet(
 				}
 		}
 	}
-#endif // DOT11_N_SUPPORT //
 
 	BssCipherParse(pBss);
 
@@ -3720,7 +3670,7 @@ VOID BssTableSsidSort(
 			(SSID_EQUAL(Ssid, SsidLen, pInBss->Ssid, pInBss->SsidLen) || bIsHiddenApIncluded))
 		{
 			BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
-#ifdef DOT11_N_SUPPORT
+
 			// 2.4G/5G N only mode
 			if ((pInBss->HtCapabilityLen == 0) &&
 				((pAd->CommonCfg.PhyMode == PHY_11N_2_4G) || (pAd->CommonCfg.PhyMode == PHY_11N_5G)))
@@ -3728,7 +3678,6 @@ VOID BssTableSsidSort(
 				DBGPRINT(RT_DEBUG_TRACE,("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
 				continue;
 			}
-#endif // DOT11_N_SUPPORT //
 
 			// New for WPA2
 			// Check the Authmode first
@@ -3801,7 +3750,6 @@ VOID BssTableSsidSort(
 			if (SsidLen == 0)
 				continue;
 
-#ifdef DOT11_N_SUPPORT
 			// If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region
 			// If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead,
 			if ((pInBss->CentralChannel != pInBss->Channel) &&
@@ -3821,7 +3769,6 @@ VOID BssTableSsidSort(
 					}
 				}
 			}
-#endif // DOT11_N_SUPPORT //
 
 			// copy matching BSS from InTab to OutTab
 			NdisMoveMemory(pOutBss, pInBss, sizeof(BSS_ENTRY));
@@ -3832,8 +3779,6 @@ VOID BssTableSsidSort(
 		{
 			BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
 
-
-#ifdef DOT11_N_SUPPORT
 			// 2.4G/5G N only mode
 			if ((pInBss->HtCapabilityLen == 0) &&
 				((pAd->CommonCfg.PhyMode == PHY_11N_2_4G) || (pAd->CommonCfg.PhyMode == PHY_11N_5G)))
@@ -3841,7 +3786,6 @@ VOID BssTableSsidSort(
 				DBGPRINT(RT_DEBUG_TRACE,("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
 				continue;
 			}
-#endif // DOT11_N_SUPPORT //
 
 			// New for WPA2
 			// Check the Authmode first
@@ -3897,7 +3841,6 @@ VOID BssTableSsidSort(
 			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus)
 					continue;
 
-#ifdef DOT11_N_SUPPORT
 			// If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region
 			// If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead,
 			if ((pInBss->CentralChannel != pInBss->Channel) &&
@@ -3910,7 +3853,6 @@ VOID BssTableSsidSort(
 					pAd->CommonCfg.RegTransmitSetting.field.BW = BW_40;
 				}
 			}
-#endif // DOT11_N_SUPPORT //
 
 			// copy matching BSS from InTab to OutTab
 			NdisMoveMemory(pOutBss, pInBss, sizeof(BSS_ENTRY));
@@ -5076,7 +5018,6 @@ VOID AsicUpdateAutoFallBackTable(
 					}
 				}
 				break;
-#ifdef DOT11_N_SUPPORT
 			case 2:		//HT-MIX
 			case 3:		//HT-GF
 				{
@@ -5138,7 +5079,6 @@ VOID AsicUpdateAutoFallBackTable(
 					}
 				}
 				break;
-#endif // DOT11_N_SUPPORT //
 		}
 
 		pNextTxRate = pCurrTxRate;
@@ -5180,7 +5120,6 @@ VOID 	AsicUpdateProtect(
 	UCHAR			i;
 	UINT32 MacReg = 0;
 
-#ifdef DOT11_N_SUPPORT
 	if (!(pAd->CommonCfg.bHTProtect) && (OperationMode != 8))
 	{
 		return;
@@ -5194,7 +5133,6 @@ VOID 	AsicUpdateProtect(
 		SetMask = ALLN_SETPROTECT;
 		OperationMode = 8;
 	}
-#endif // DOT11_N_SUPPORT //
 
 	// Config ASIC RTS threshold register
 	RTMP_IO_READ32(pAd, TX_RTS_CFG, &MacReg);
@@ -5204,9 +5142,7 @@ VOID 	AsicUpdateProtect(
 #else
 	// If the user want disable RtsThreshold and enbale Amsdu/Ralink-Aggregation, set the RtsThreshold as 4096
         if ((
-#ifdef DOT11_N_SUPPORT
 			(pAd->CommonCfg.BACapability.field.AmsduEnable) ||
-#endif // DOT11_N_SUPPORT //
 			(pAd->CommonCfg.bAggregationCapable == TRUE))
             && pAd->CommonCfg.RtsThreshold == MAX_RTS_THRESHOLD)
         {
@@ -5255,7 +5191,6 @@ VOID 	AsicUpdateProtect(
 		Protect[1] = ProtCfg.word;
 	}
 
-#ifdef DOT11_N_SUPPORT
 	// Decide HT frame protection.
 	if ((SetMask & ALLN_SETPROTECT) != 0)
 	{
@@ -5386,7 +5321,6 @@ VOID 	AsicUpdateProtect(
 				break;
 		}
 	}
-#endif // DOT11_N_SUPPORT //
 
 	offset = CCK_PROT_CFG;
 	for (i = 0;i < 6;i++)
@@ -6203,9 +6137,7 @@ VOID AsicDisableRDG(
 	//	Data |= 0x60; // for performance issue not set the TXOP to 0
 #endif
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_DYNAMIC_BE_TXOP_ACTIVE)
-#ifdef DOT11_N_SUPPORT
 		&& (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
-#endif // DOT11_N_SUPPORT //
 	)
 	{
 		// For CWC test, change txop from 0x30 to 0x20 in TxBurst mode
@@ -6643,9 +6575,7 @@ VOID 	AsicSetSlotTime(
 	{
 		// force using short SLOT time for FAE to demo performance when TxBurst is ON
 		if (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)))
-#ifdef DOT11_N_SUPPORT
 			|| ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE) && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE))
-#endif // DOT11_N_SUPPORT //
 			)
 		{
 			// In this case, we will think it is doing Wi-Fi test
@@ -7185,7 +7115,6 @@ VOID	RTMPCheckRates(
 	NdisMoveMemory(SupRate, NewRate, NewRateLen);
 }
 
-#ifdef DOT11_N_SUPPORT
 BOOLEAN RTMPCheckChannel(
 	IN PRTMP_ADAPTER pAd,
 	IN UCHAR		CentralChannel,
@@ -7331,7 +7260,6 @@ BOOLEAN 	RTMPCheckHt(
 	COPY_AP_HTSETTINGS_FROM_BEACON(pAd, pHtCapability);
 	return TRUE;
 }
-#endif // DOT11_N_SUPPORT //
 
 /*
 	========================================================================
@@ -7364,10 +7292,8 @@ VOID RTMPUpdateMlmeRate(
 			MinimumRate = RATE_1;
 			break;
 		case PHY_11BG_MIXED:
-#ifdef DOT11_N_SUPPORT
 		case PHY_11ABGN_MIXED:
 		case PHY_11BGN_MIXED:
-#endif // DOT11_N_SUPPORT //
 			if ((pAd->MlmeAux.SupRateLen == 4) &&
 				(pAd->MlmeAux.ExtRateLen == 0))
 				// B only AP
@@ -7381,13 +7307,11 @@ VOID RTMPUpdateMlmeRate(
 				MinimumRate = RATE_6;
 			break;
 		case PHY_11A:
-#ifdef DOT11_N_SUPPORT
 		case PHY_11N_2_4G:	// rt2860 need to check mlmerate for 802.11n
 		case PHY_11GN_MIXED:
 		case PHY_11AGN_MIXED:
 		case PHY_11AN_MIXED:
 		case PHY_11N_5G:
-#endif // DOT11_N_SUPPORT //
 			ProperMlmeRate = RATE_24;
 			MinimumRate = RATE_6;
 			break;
@@ -7982,13 +7906,11 @@ VOID RTMPSetAGCInitValue(
 			R66 = (UCHAR)(0x32 + (GET_LNA_GAIN(pAd)*5)/3);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
 		}
-#ifdef DOT11_N_SUPPORT
 		else
 		{
 			R66 = (UCHAR)(0x3A + (GET_LNA_GAIN(pAd)*5)/3);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
 		}
-#endif // DOT11_N_SUPPORT //
 	}
 
 }
--- a/drivers/staging/rt2870/common/rtmp_init.c
+++ b/drivers/staging/rt2870/common/rtmp_init.c
@@ -1504,13 +1504,11 @@ VOID	NICReadEEPROMParameters(
 		if ((pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED) ||
 			(pAd->CommonCfg.PhyMode == PHY_11A))
 			pAd->CommonCfg.PhyMode = PHY_11BG_MIXED;
-#ifdef DOT11_N_SUPPORT
 		else if ((pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED)	||
 				 (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED) 	||
 				 (pAd->CommonCfg.PhyMode == PHY_11AGN_MIXED) 	||
 				 (pAd->CommonCfg.PhyMode == PHY_11N_5G))
 			pAd->CommonCfg.PhyMode = PHY_11BGN_MIXED;
-#endif // DOT11_N_SUPPORT //
 	}
 
 	// Read TSSI reference and TSSI boundary for temperature compensation. This is ugly
@@ -1601,9 +1599,7 @@ VOID	NICReadEEPROMParameters(
 		TmpPhy = pAd->CommonCfg.PhyMode;
 		pAd->CommonCfg.PhyMode = 0xff;
 		RTMPSetPhyMode(pAd, TmpPhy);
-#ifdef DOT11_N_SUPPORT
 		SetCommonHT(pAd);
-#endif // DOT11_N_SUPPORT //
 	}
 
 	//
@@ -2275,10 +2271,8 @@ VOID NICUpdateFifoStaCounters(
 
 			pEntry->DebugFIFOCount++;
 
-#ifdef DOT11_N_SUPPORT
 			if (StaFifo.field.TxBF) // 3*3
 				pEntry->TxBFCount++;
-#endif // DOT11_N_SUPPORT //
 
 #ifdef UAPSD_AP_SUPPORT
 			UAPSD_SP_AUE_Handle(pAd, pEntry, StaFifo.field.TxSuccess);
@@ -2296,19 +2290,15 @@ VOID NICUpdateFifoStaCounters(
 					SendRefreshBAR(pAd, pEntry);
 					pEntry->NoBADataCountDown = 64;
 #else
-#ifdef DOT11_N_SUPPORT
 					pEntry->NoBADataCountDown = 64;
-#endif // DOT11_N_SUPPORT //
 
 					if(pEntry->PsMode == PWR_ACTIVE)
 					{
-#ifdef DOT11_N_SUPPORT
 						int tid;
 						for (tid=0; tid<NUM_OF_TID; tid++)
 						{
 							BAOriSessionTearDown(pAd, pEntry->Aid,  tid, FALSE, FALSE);
 						}
-#endif // DOT11_N_SUPPORT //
 
 						// Update the continuous transmission counter except PS mode
 						pEntry->ContinueTxFailCnt++;
@@ -2327,7 +2317,6 @@ VOID NICUpdateFifoStaCounters(
 			}
 			else
 			{
-#ifdef DOT11_N_SUPPORT
 				if ((pEntry->PsMode != PWR_SAVE) && (pEntry->NoBADataCountDown > 0))
 				{
 					pEntry->NoBADataCountDown--;
@@ -2336,7 +2325,7 @@ VOID NICUpdateFifoStaCounters(
 						DBGPRINT(RT_DEBUG_TRACE, ("@\n"));
 					}
 				}
-#endif // DOT11_N_SUPPORT //
+
 				pEntry->FIFOCount = 0;
 				pEntry->OneSecTxNoRetryOkCount++;
 				// update NoDataIdleCount when sucessful send packet to STA.
@@ -3191,7 +3180,6 @@ VOID	UserCfgInit(
 
 	NdisZeroMemory(&pAd->BeaconTxWI, sizeof(pAd->BeaconTxWI));
 
-#ifdef DOT11_N_SUPPORT
 	NdisZeroMemory(&pAd->CommonCfg.HtCapability, sizeof(pAd->CommonCfg.HtCapability));
 	pAd->HTCEnable = FALSE;
 	pAd->bBroadComHT = FALSE;
@@ -3217,7 +3205,6 @@ VOID	UserCfgInit(
 	pAd->CommonCfg.TxBASize = 7;
 
 	pAd->CommonCfg.REGBACapability.word = pAd->CommonCfg.BACapability.word;
-#endif // DOT11_N_SUPPORT //
 
 	//pAd->CommonCfg.HTPhyMode.field.BW = BW_20;
 	//pAd->CommonCfg.HTPhyMode.field.MCS = MCS_AUTO;
--- a/drivers/staging/rt2870/common/spectrum.c
+++ b/drivers/staging/rt2870/common/spectrum.c
@@ -1068,9 +1068,9 @@ static VOID StartDFSProcedure(
 {
 	// start DFS procedure
 	pAd->CommonCfg.Channel = Channel;
-#ifdef DOT11_N_SUPPORT
+
 	N_ChannelCheck(pAd);
-#endif // DOT11_N_SUPPORT //
+
 	pAd->CommonCfg.RadarDetect.RDMode = RD_SWITCHING_MODE;
 	pAd->CommonCfg.RadarDetect.CSCount = 0;
 }
--- a/drivers/staging/rt2870/Makefile
+++ b/drivers/staging/rt2870/Makefile
@@ -4,7 +4,6 @@ obj-$(CONFIG_RT2870)	+= rt2870sta.o
 EXTRA_CFLAGS += -DLINUX -DAGGREGATION_SUPPORT -DPIGGYBACK_SUPPORT -DWMM_SUPPORT
 EXTRA_CFLAGS += -DRT2870
 EXTRA_CFLAGS += -DDBG
-EXTRA_CFLAGS += -DDOT11_N_SUPPORT
 
 rt2870sta-objs :=		\
 	common/md5.o		\
--- a/drivers/staging/rt2870/oid.h
+++ b/drivers/staging/rt2870/oid.h
@@ -712,7 +712,6 @@ typedef enum _RT_802_11_PHY_MODE {
 	PHY_11A,
 	PHY_11ABG_MIXED,
 	PHY_11G,
-#ifdef DOT11_N_SUPPORT
 	PHY_11ABGN_MIXED,	// both band   5
 	PHY_11N_2_4G,		// 11n-only with 2.4G band   	6
 	PHY_11GN_MIXED,	// 2.4G band      7
@@ -720,7 +719,6 @@ typedef enum _RT_802_11_PHY_MODE {
 	PHY_11BGN_MIXED,	// if check 802.11b.      9
 	PHY_11AGN_MIXED,	// if check 802.11b.      10
 	PHY_11N_5G,			// 11n-only with 5G band		11
-#endif // DOT11_N_SUPPORT //
 } RT_802_11_PHY_MODE;
 
 // put all proprietery for-query objects here to reduce # of Query_OID
--- a/drivers/staging/rt2870/rt_linux.c
+++ b/drivers/staging/rt2870/rt_linux.c
@@ -983,13 +983,11 @@ void send_monitor_packets(
 	ph->noise.len = 4;
 	ph->noise.data = 0;
 
-#ifdef DOT11_N_SUPPORT
     if (pRxBlk->pRxWI->PHYMODE >= MODE_HTMIX)
     {
     	rate_index = 16 + ((UCHAR)pRxBlk->pRxWI->BW *16) + ((UCHAR)pRxBlk->pRxWI->ShortGI *32) + ((UCHAR)pRxBlk->pRxWI->MCS);
     }
     else
-#endif // DOT11_N_SUPPORT //
 	if (pRxBlk->pRxWI->PHYMODE == MODE_OFDM)
     	rate_index = (UCHAR)(pRxBlk->pRxWI->MCS) + 4;
     else
--- a/drivers/staging/rt2870/rt_main_dev.c
+++ b/drivers/staging/rt2870/rt_main_dev.c
@@ -54,10 +54,8 @@ MODULE_PARM_DESC (mac, "rt28xx: wireless
 /*---------------------------------------------------------------------*/
 /* Prototypes of Functions Used                                        */
 /*---------------------------------------------------------------------*/
-#ifdef DOT11_N_SUPPORT
 extern BOOLEAN ba_reordering_resource_init(PRTMP_ADAPTER pAd, int num);
 extern void ba_reordering_resource_release(PRTMP_ADAPTER pAd);
-#endif // DOT11_N_SUPPORT //
 extern NDIS_STATUS NICLoadRateSwitchingParams(IN PRTMP_ADAPTER pAd);
 
 
@@ -323,10 +321,8 @@ int rt28xx_close(IN PNET_DEV dev)
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
 
-#ifdef DOT11_N_SUPPORT
 	// Free BA reorder resource
 	ba_reordering_resource_release(pAd);
-#endif // DOT11_N_SUPPORT //
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_START_UP);
 
@@ -341,10 +337,8 @@ static int rt28xx_init(IN struct net_dev
 	NDIS_STATUS				Status;
 	UINT32 		MacCsr0 = 0;
 
-#ifdef DOT11_N_SUPPORT
 	// Allocate BA Reordering memory
 	ba_reordering_resource_init(pAd, MAX_REORDERING_MPDU_NUM);
-#endif // DOT11_N_SUPPORT //
 
 	// Make sure MAC gets ready.
 	index = 0;
@@ -454,7 +448,6 @@ static int rt28xx_init(IN struct net_dev
 
    	//Init Ba Capability parameters.
 //	RT28XX_BA_INIT(pAd);
-#ifdef DOT11_N_SUPPORT
 	pAd->CommonCfg.DesiredHtPhy.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
 	pAd->CommonCfg.DesiredHtPhy.AmsduEnable = (USHORT)pAd->CommonCfg.BACapability.field.AmsduEnable;
 	pAd->CommonCfg.DesiredHtPhy.AmsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
@@ -463,7 +456,6 @@ static int rt28xx_init(IN struct net_dev
 	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs = (USHORT)pAd->CommonCfg.BACapability.field.MMPSmode;
 	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
 	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
-#endif // DOT11_N_SUPPORT //
 
 	// after reading Registry, we now know if in AP mode or STA mode
 
@@ -485,9 +477,7 @@ static int rt28xx_init(IN struct net_dev
 	TmpPhy = pAd->CommonCfg.PhyMode;
 	pAd->CommonCfg.PhyMode = 0xff;
 	RTMPSetPhyMode(pAd, TmpPhy);
-#ifdef DOT11_N_SUPPORT
 	SetCommonHT(pAd);
-#endif // DOT11_N_SUPPORT //
 
 	// No valid channels.
 	if (pAd->ChannelListNum == 0)
@@ -496,11 +486,9 @@ static int rt28xx_init(IN struct net_dev
 		goto err4;
 	}
 
-#ifdef DOT11_N_SUPPORT
 	printk("MCS Set = %02x %02x %02x %02x %02x\n", pAd->CommonCfg.HtCapability.MCSSet[0],
            pAd->CommonCfg.HtCapability.MCSSet[1], pAd->CommonCfg.HtCapability.MCSSet[2],
            pAd->CommonCfg.HtCapability.MCSSet[3], pAd->CommonCfg.HtCapability.MCSSet[4]);
-#endif // DOT11_N_SUPPORT //
 
 #ifdef RT2870
     //Init RT30xx RFRegisters after read RFIC type from EEPROM
@@ -580,10 +568,7 @@ err2:
 	RTMPFreeTxRxRingMemory(pAd);
 //	RTMPFreeAdapter(pAd);
 err1:
-
-#ifdef DOT11_N_SUPPORT
 	os_free_mem(pAd, pAd->mpdu_blk_pool.mem); // free BA pool
-#endif // DOT11_N_SUPPORT //
 	RT28XX_IRQ_RELEASE(net_dev);
 
 	// shall not set ml_priv to NULL here because the ml_priv didn't been free yet.
--- a/drivers/staging/rt2870/rtmp_def.h
+++ b/drivers/staging/rt2870/rtmp_def.h
@@ -1010,10 +1010,9 @@
 // Preamble MODE in TxD
 #define MODE_CCK	0
 #define MODE_OFDM   1
-#ifdef DOT11_N_SUPPORT
 #define MODE_HTMIX	2
 #define MODE_HTGREENFIELD	3
-#endif // DOT11_N_SUPPORT //
+
 // MCS for CCK.  BW.SGI.STBC are reserved
 #define MCS_LONGP_RATE_1                      0	 // long preamble CCK 1Mbps
 #define MCS_LONGP_RATE_2                      1	// long preamble CCK 1Mbps
@@ -1060,12 +1059,10 @@
 #define MCS_32		32
 #define MCS_AUTO		33
 
-#ifdef DOT11_N_SUPPORT
 // OID_HTPHYMODE
 // MODE
 #define HTMODE_MM	0
 #define HTMODE_GF	1
-#endif // DOT11_N_SUPPORT //
 
 // Fixed Tx MODE - HT, CCK or OFDM
 #define FIXED_TXMODE_HT		0
@@ -1077,15 +1074,12 @@
 #define BW_BOTH		BAND_WIDTH_BOTH
 #define BW_10		BAND_WIDTH_10	// 802.11j has 10MHz. This definition is for internal usage. doesn't fill in the IE or other field.
 
-#ifdef DOT11_N_SUPPORT
 // SHORTGI
 #define GI_400		GAP_INTERVAL_400	// only support in HT mode
 #define GI_BOTH		GAP_INTERVAL_BOTH
-#endif // DOT11_N_SUPPORT //
 #define GI_800		GAP_INTERVAL_800
 // STBC
 #define STBC_NONE	0
-#ifdef DOT11_N_SUPPORT
 #define STBC_USE	1	// limited use in rt2860b phy
 #define RXSTBC_ONE	1	// rx support of one spatial stream
 #define RXSTBC_TWO	2	// rx support of 1 and 2 spatial stream
@@ -1107,8 +1101,6 @@
 #define	AMSDU_0	0
 #define	AMSDU_1		1
 
-#endif // DOT11_N_SUPPORT //
-
 // MCS use 7 bits
 #define TXRATEMIMO		0x80
 #define TXRATEMCS		0x7F
--- a/drivers/staging/rt2870/rtmp.h
+++ b/drivers/staging/rt2870/rtmp.h
@@ -234,11 +234,9 @@ extern UCHAR  SsidIe;
 extern UCHAR  SupRateIe;
 extern UCHAR  ExtRateIe;
 
-#ifdef DOT11_N_SUPPORT
 extern UCHAR  HtCapIe;
 extern UCHAR  AddHtInfoIe;
 extern UCHAR  NewExtChanIe;
-#endif // DOT11_N_SUPPORT //
 
 extern UCHAR  ErpIe;
 extern UCHAR  DsIe;
@@ -263,7 +261,6 @@ extern UCHAR  RateSwitchTable11B[];
 extern UCHAR  RateSwitchTable11G[];
 extern UCHAR  RateSwitchTable11BG[];
 
-#ifdef DOT11_N_SUPPORT
 extern UCHAR  RateSwitchTable11BGN1S[];
 extern UCHAR  RateSwitchTable11BGN2S[];
 extern UCHAR  RateSwitchTable11BGN2SForABand[];
@@ -272,11 +269,9 @@ extern UCHAR  RateSwitchTable11N2S[];
 extern UCHAR  RateSwitchTable11N2SForABand[];
 
 extern UCHAR  PRE_N_HT_OUI[];
-#endif // DOT11_N_SUPPORT //
 
 #define	MAXSEQ		(0xFFF)
 
-#ifdef DOT11_N_SUPPORT
 struct reordering_mpdu
 {
 	struct reordering_mpdu	*next;
@@ -297,7 +292,6 @@ struct reordering_mpdu_pool
 	NDIS_SPIN_LOCK			lock;
 	struct reordering_list 	freelist;
 };
-#endif // DOT11_N_SUPPORT //
 
 typedef struct 	_RSSI_SAMPLE {
 	CHAR			LastRssi0;             // last received RSSI
@@ -438,7 +432,6 @@ typedef struct  _QUEUE_HEADER   {
     }                                                   \
 }
 
-#ifdef DOT11_N_SUPPORT
 // StaActive.SupportedHtPhy.MCSSet is copied from AP beacon.  Don't need to update here.
 #define COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(_pAd)                                 \
 {                                                                                       \
@@ -462,7 +455,6 @@ typedef struct  _QUEUE_HEADER   {
 	_pAd->MacTab.Content[BSSID_WCID].MmpsMode= (UCHAR)(_pHtCapability->HtCapInfo.MimoPs);	\
 	_pAd->MacTab.Content[BSSID_WCID].MaxRAmpduFactor = (UCHAR)(_pHtCapability->HtCapParm.MaxRAmpduFactor);	\
 }
-#endif // DOT11_N_SUPPORT //
 
 //
 // BBP & RF are using indirect access. Before write any value into it.
@@ -1290,7 +1282,6 @@ typedef enum _ORI_BLOCKACK_STATUS
     Originator_Done
 } ORI_BLOCKACK_STATUS, *PORI_BLOCKACK_STATUS;
 
-#ifdef DOT11_N_SUPPORT
 typedef struct _BA_ORI_ENTRY{
 	UCHAR   Wcid;
 	UCHAR   TID;
@@ -1376,7 +1367,6 @@ typedef	union	_BACAP_STRUC	{
 	}	field;
 	UINT32			word;
 } BACAP_STRUC, *PBACAP_STRUC;
-#endif // DOT11_N_SUPPORT //
 
 //This structure is for all 802.11n card InterOptibilityTest action. Reset all Num every n second.  (Details see MLMEPeriodic)
 typedef	struct	_IOT_STRUC	{
@@ -1666,10 +1656,9 @@ typedef struct _COMMON_CONFIG {
 	ULONG       TxPowerPercentage;      // 0~100 %
 	ULONG       TxPowerDefault;         // keep for TxPowerPercentage
 
-#ifdef DOT11_N_SUPPORT
 	BACAP_STRUC        BACapability; //   NO USE = 0XFF  ;  IMMED_BA =1  ;  DELAY_BA=0
 	BACAP_STRUC        REGBACapability; //   NO USE = 0XFF  ;  IMMED_BA =1  ;  DELAY_BA=0
-#endif // DOT11_N_SUPPORT //
+
 	IOT_STRUC		IOTestParm;	// 802.11n InterOpbility Test Parameter;
 	ULONG       TxPreamble;             // Rt802_11PreambleLong, Rt802_11PreambleShort, Rt802_11PreambleAuto
 	BOOLEAN     bUseZeroToDisableFragment;     // Microsoft use 0 as disable
@@ -1681,9 +1670,8 @@ typedef struct _COMMON_CONFIG {
 	BOOLEAN     bIEEE80211H;			// 1: enable IEEE802.11h spec.
 	ULONG		DisableOLBCDetect;		// 0: enable OLBC detect; 1 disable OLBC detect
 
-#ifdef DOT11_N_SUPPORT
 	BOOLEAN				bRdg;
-#endif // DOT11_N_SUPPORT //
+
 	BOOLEAN             bWmmCapable;        // 0:disable WMM, 1:enable WMM
 	QOS_CAPABILITY_PARM APQosCapability;    // QOS capability of the current associated AP
 	EDCA_PARM           APEdcaParm;         // EDCA parameters of the current associated AP
@@ -1702,7 +1690,6 @@ typedef struct _COMMON_CONFIG {
 	// IEEE802.11H--DFS.
 	RADAR_DETECT_STRUCT	RadarDetect;
 
-#ifdef DOT11_N_SUPPORT
 	// HT
 	UCHAR			BASize;		// USer desired BAWindowSize. Should not exceed our max capability
 	//RT_HT_CAPABILITY	SupportedHtPhy;
@@ -1723,7 +1710,6 @@ typedef struct _COMMON_CONFIG {
 	ULONG					LastRcvBSSWidthTriggerEventsTime;
 
 	UCHAR					TxBASize;
-#endif // DOT11_N_SUPPORT //
 
 	// Enable wireless event
 	BOOLEAN				bWirelessEvent;
@@ -2069,14 +2055,11 @@ typedef struct _MAC_TABLE_ENTRY {
 
 	UINT32			StaConnectTime;		// the live time of this station since associated with AP
 
-
-#ifdef DOT11_N_SUPPORT
 	BOOLEAN			bSendBAR;
 	USHORT			NoBADataCountDown;
 
 	UINT32   		CachedBuf[16];		// UINT (4 bytes) for alignment
 	UINT			TxBFCount; // 3*3
-#endif // DOT11_N_SUPPORT //
 	UINT			FIFOCount;
 	UINT			DebugFIFOCount;
 	UINT			DebugTxCount;
@@ -2114,10 +2097,8 @@ typedef struct _MAC_TABLE_ENTRY {
 	// see fOP_STATUS_xxx in RTMP_DEF.C for detail bit definition. fCLIENT_STATUS_AMSDU_INUSED
 	ULONG           ClientStatusFlags;
 
-	// TODO: Shall we move that to DOT11_N_SUPPORT???
 	HTTRANSMIT_SETTING	HTPhyMode, MaxHTPhyMode, MinHTPhyMode;// For transmit phy setting in TXWI.
 
-#ifdef DOT11_N_SUPPORT
 	// HT EWC MIMO-N used parameters
 	USHORT		RXBAbitmap;	// fill to on-chip  RXWI_BA_BITMASK in 8.1.3RX attribute entry format
 	USHORT		TXBAbitmap;	// This bitmap as originator, only keep in software used to mark AMPDU bit in TXWI
@@ -2134,7 +2115,6 @@ typedef struct _MAC_TABLE_ENTRY {
 	UCHAR		MmpsMode;	// MIMO power save more.
 
 	HT_CAPABILITY_IE		HTCapability;
-#endif // DOT11_N_SUPPORT //
 
 	BOOLEAN		bAutoTxRateSwitch;
 
@@ -2163,16 +2143,13 @@ typedef struct _MAC_TABLE {
 	BOOLEAN         fAnyStationBadAtheros;	// Check if any Station is atheros 802.11n Chip.  We need to use RTS/CTS with Atheros 802,.11n chip.
 	BOOLEAN			fAnyTxOPForceDisable;	// Check if it is necessary to disable BE TxOP
 	BOOLEAN			fAllStationAsRalink; 	// Check if all stations are ralink-chipset
-#ifdef DOT11_N_SUPPORT
 	BOOLEAN         fAnyStationIsLegacy;	// Check if I use legacy rate to transmit to my BSS Station/
 	BOOLEAN         fAnyStationNonGF;		// Check if any Station can't support GF.
 	BOOLEAN         fAnyStation20Only;		// Check if any Station can't support GF.
 	BOOLEAN			fAnyStationMIMOPSDynamic; // Check if any Station is MIMO Dynamic
 	BOOLEAN         fAnyBASession;   // Check if there is BA session.  Force turn on RTS/CTS
-#endif // DOT11_N_SUPPORT //
 } MAC_TABLE, *PMAC_TABLE;
 
-#ifdef DOT11_N_SUPPORT
 #define IS_HT_STA(_pMacEntry)	\
 	(_pMacEntry->MaxHTPhyMode.field.MODE >= MODE_HTMIX)
 
@@ -2181,7 +2158,6 @@ typedef struct _MAC_TABLE {
 
 #define PEER_IS_HT_RATE(_pMacEntry)	\
 	(_pMacEntry->HTPhyMode.field.MODE >= MODE_HTMIX)
-#endif // DOT11_N_SUPPORT //
 
 typedef struct _WDS_ENTRY {
 	BOOLEAN         Valid;
@@ -2628,9 +2604,8 @@ typedef struct _RTMP_ADAPTER
 	MAC_TABLE                 MacTab;     // ASIC on-chip WCID entry table.  At TX, ASIC always use key according to this on-chip table.
 	NDIS_SPIN_LOCK          MacTabLock;
 
-#ifdef DOT11_N_SUPPORT
 	BA_TABLE			BATable;
-#endif // DOT11_N_SUPPORT //
+
 	NDIS_SPIN_LOCK          BATabLock;
 	RALINK_TIMER_STRUCT RECBATimer;
 
@@ -2729,9 +2704,7 @@ typedef struct _RTMP_ADAPTER
 
     struct wificonf			WIFItestbed;
 
-#ifdef DOT11_N_SUPPORT
 	struct reordering_mpdu_pool mpdu_blk_pool;
-#endif // DOT11_N_SUPPORT //
 
 	ULONG					OneSecondnonBEpackets;		// record non BE packets per second
 
@@ -3173,7 +3146,6 @@ VOID MlmeQOSAction(
     IN PRTMP_ADAPTER pAd,
     IN MLME_QUEUE_ELEM *Elem);
 
-#ifdef DOT11_N_SUPPORT
 VOID PeerAddBAReqAction(
 	IN PRTMP_ADAPTER pAd,
 	IN MLME_QUEUE_ELEM *Elem);
@@ -3189,7 +3161,6 @@ VOID PeerDelBAAction(
 VOID PeerBAAction(
     IN PRTMP_ADAPTER pAd,
     IN MLME_QUEUE_ELEM *Elem);
-#endif // DOT11_N_SUPPORT //
 
 VOID SendPSMPAction(
 	IN PRTMP_ADAPTER	pAd,
@@ -3212,17 +3183,14 @@ VOID PeerBSSTranAction(
 	IN PRTMP_ADAPTER pAd,
 	IN MLME_QUEUE_ELEM *Elem);
 
-#ifdef DOT11_N_SUPPORT
 VOID PeerHTAction(
 	IN PRTMP_ADAPTER pAd,
 	IN MLME_QUEUE_ELEM *Elem);
-#endif // DOT11_N_SUPPORT //
 
 VOID PeerQOSAction(
     IN PRTMP_ADAPTER pAd,
     IN MLME_QUEUE_ELEM *Elem);
 
-#ifdef DOT11_N_SUPPORT
 VOID RECBATimerTimeout(
     IN PVOID SystemSpecific1,
     IN PVOID FunctionContext,
@@ -3235,7 +3203,6 @@ VOID ORIBATimerTimeout(
 VOID SendRefreshBAR(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	MAC_TABLE_ENTRY	*pEntry);
-#endif // DOT11_N_SUPPORT //
 
 VOID ActHeaderInit(
     IN	PRTMP_ADAPTER	pAd,
@@ -3268,7 +3235,6 @@ BOOLEAN QosBADataParse(
 	IN USHORT Datasize,
 	IN UINT   CurRxIndex);
 
-#ifdef DOT11_N_SUPPORT
 BOOLEAN CntlEnqueueForRecv(
     IN	PRTMP_ADAPTER	pAd,
 	IN ULONG Wcid,
@@ -3277,7 +3243,6 @@ BOOLEAN CntlEnqueueForRecv(
 
 VOID BaAutoManSwitch(
 	IN	PRTMP_ADAPTER	pAd);
-#endif // DOT11_N_SUPPORT //
 
 VOID HTIOTCheck(
 	IN	PRTMP_ADAPTER	pAd,
@@ -3770,11 +3735,9 @@ VOID MlmeRadioOn(
 VOID BssTableInit(
 	IN BSS_TABLE *Tab);
 
-#ifdef DOT11_N_SUPPORT
 VOID BATableInit(
 	IN PRTMP_ADAPTER pAd,
     IN BA_TABLE *Tab);
-#endif // DOT11_N_SUPPORT //
 
 ULONG BssTableSearch(
 	IN BSS_TABLE *Tab,
@@ -3800,7 +3763,6 @@ VOID BssTableDeleteEntry(
 	IN      PUCHAR pBssid,
 	IN      UCHAR Channel);
 
-#ifdef DOT11_N_SUPPORT
 VOID BATableDeleteORIEntry(
 	IN OUT	PRTMP_ADAPTER pAd,
 	IN		BA_ORI_ENTRY	*pBAORIEntry);
@@ -3821,7 +3783,6 @@ VOID BATableTearRECEntry(
 	IN		UCHAR TID,
 	IN		UCHAR WCID,
 	IN		BOOLEAN ALL);
-#endif // DOT11_N_SUPPORT //
 
 VOID  BssEntrySet(
 	IN  PRTMP_ADAPTER   pAd,
@@ -3883,7 +3844,6 @@ ULONG  BssTableSetEntry(
 	IN USHORT LengthVIE,
 	IN PNDIS_802_11_VARIABLE_IEs pVIE);
 
-#ifdef DOT11_N_SUPPORT
 VOID BATableInsertEntry(
     IN	PRTMP_ADAPTER	pAd,
 	IN USHORT Aid,
@@ -3893,7 +3853,6 @@ VOID BATableInsertEntry(
 	IN UCHAR BAWinSize,
 	IN UCHAR OriginatorStatus,
     IN BOOLEAN IsRecipient);
-#endif // DOT11_N_SUPPORT //
 
 VOID BssTableSsidSort(
 	IN  PRTMP_ADAPTER   pAd,
@@ -4632,11 +4591,9 @@ VOID MlmeUpdateTxRates(
 	IN 	BOOLEAN		 	bLinkUp,
 	IN	UCHAR			apidx);
 
-#ifdef DOT11_N_SUPPORT
 VOID MlmeUpdateHtTxRates(
 	IN PRTMP_ADAPTER 		pAd,
 	IN	UCHAR				apidx);
-#endif // DOT11_N_SUPPORT //
 
 VOID    RTMPCheckRates(
 	IN      PRTMP_ADAPTER   pAd,
@@ -4899,7 +4856,6 @@ VOID    RTMPAddBSSIDCipher(
     IN  PNDIS_802_11_KEY    pKey,
     IN  UCHAR   CipherAlg);
 
-#ifdef DOT11_N_SUPPORT
 VOID	RTMPSetHT(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	OID_SET_HT_PHYMODE *pHTPhyMode);
@@ -4907,7 +4863,6 @@ VOID	RTMPSetHT(
 VOID	RTMPSetIndividualHT(
 	IN	PRTMP_ADAPTER		pAd,
 	IN	UCHAR				apidx);
-#endif // DOT11_N_SUPPORT //
 
 VOID RTMPSendWirelessEvent(
 	IN	PRTMP_ADAPTER	pAd,
@@ -5568,7 +5523,6 @@ UCHAR VLAN_8023_Header_Copy(
 	OUT PUCHAR			pData,
 	IN	UCHAR			FromWhichBSSID);
 
-#ifdef DOT11_N_SUPPORT
 void ba_flush_reordering_timeout_mpdus(
 	IN PRTMP_ADAPTER	pAd,
 	IN PBA_REC_ENTRY	pBAEntry,
@@ -5586,7 +5540,6 @@ VOID BAOriSessionSetUp(
 VOID BASessionTearDownALL(
 	IN OUT	PRTMP_ADAPTER pAd,
 	IN		UCHAR Wcid);
-#endif // DOT11_N_SUPPORT //
 
 BOOLEAN OS_Need_Clone_Packet(void);
 
@@ -5734,7 +5687,6 @@ INT	Set_ResetStatCounter_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			arg);
 
-#ifdef DOT11_N_SUPPORT
 INT	Set_BASetup_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			arg);
@@ -5835,19 +5787,16 @@ INT	Set_HtMIMOPSmode_Proc(
 INT	Set_HtTxBASize_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			arg);
-#endif // DOT11_N_SUPPORT //
 
 //Dls ,	kathy
 VOID RTMPSendDLSTearDownFrame(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			pDA);
 
-#ifdef DOT11_N_SUPPORT
 //Block ACK
 VOID QueryBATABLE(
 	IN  PRTMP_ADAPTER pAd,
 	OUT PQUERYBA_TABLE pBAT);
-#endif // DOT11_N_SUPPORT //
 
 INT	    WpaCheckEapCode(
 	IN  PRTMP_ADAPTER   	pAd,
@@ -5865,15 +5814,12 @@ VOID    SendAssocIEsToWpaSupplicant(
 int wext_notify_event_assoc(
 	IN  RTMP_ADAPTER *pAd);
 
-#ifdef DOT11_N_SUPPORT
 VOID Handle_BSS_Width_Trigger_Events(
 	IN PRTMP_ADAPTER pAd);
 
 void build_ext_channel_switch_ie(
 	IN PRTMP_ADAPTER pAd,
 	IN HT_EXT_CHANNEL_SWITCH_ANNOUNCEMENT_IE *pIE);
-#endif // DOT11_N_SUPPORT //
-
 
 BOOLEAN APRxDoneInterruptHandle(
 	IN	PRTMP_ADAPTER	pAd);
@@ -5882,7 +5828,6 @@ BOOLEAN STARxDoneInterruptHandle(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	BOOLEAN			argc);
 
-#ifdef DOT11_N_SUPPORT
 // AMPDU packet indication
 VOID Indicate_AMPDU_Packet(
 	IN	PRTMP_ADAPTER	pAd,
@@ -5894,7 +5839,6 @@ VOID Indicate_AMSDU_Packet(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RX_BLK			*pRxBlk,
 	IN	UCHAR			FromWhichBSSID);
-#endif // DOT11_N_SUPPORT //
 
 // Normal legacy Rx packet indication
 VOID Indicate_Legacy_Packet(
@@ -6142,13 +6086,11 @@ static inline char* GetPhyMode(
 
 		case MODE_OFDM:
 			return "OFDM";
-#ifdef DOT11_N_SUPPORT
 		case MODE_HTMIX:
 			return "HTMIX";
 
 		case MODE_HTGREENFIELD:
 			return "GREEN";
-#endif // DOT11_N_SUPPORT //
 		default:
 			return "N/A";
 	}
@@ -6165,10 +6107,8 @@ static inline char* GetBW(
 
 		case BW_20:
 			return "20M";
-#ifdef DOT11_N_SUPPORT
 		case BW_40:
 			return "40M";
-#endif // DOT11_N_SUPPORT //
 		default:
 			return "N/A";
 	}
--- a/drivers/staging/rt2870/rt_profile.c
+++ b/drivers/staging/rt2870/rt_profile.c
@@ -27,12 +27,10 @@
 
 #include "rt_config.h"
 
-#ifdef DOT11_N_SUPPORT
 static void HTParametersHook(
 	IN	PRTMP_ADAPTER pAd,
 	IN	CHAR		  *pValueStr,
 	IN	CHAR		  *pInput);
-#endif // DOT11_N_SUPPORT //
 
 #define ETH_MAC_ADDR_STR_LEN 17  // in format of xx:xx:xx:xx:xx:xx
 
@@ -1009,9 +1007,7 @@ NDIS_STATUS	RTMPReadParametersHook(
 					{
 						int value  = 0, maxPhyMode = PHY_11G;
 
-#ifdef DOT11_N_SUPPORT
 						maxPhyMode = PHY_11N_5G;
-#endif // DOT11_N_SUPPORT //
 
 						value = simple_strtol(tmpbuf, 0, 10);
 
@@ -1399,9 +1395,7 @@ NDIS_STATUS	RTMPReadParametersHook(
 						DBGPRINT(RT_DEBUG_TRACE, "HSCounter=%d\n", pAd->CommonCfg.bEnableHSCounter);
 					}*/
 
-#ifdef DOT11_N_SUPPORT
 					HTParametersHook(pAd, tmpbuf, buffer);
-#endif // DOT11_N_SUPPORT //
 
 					IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
 					{
@@ -1517,7 +1511,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 	return (NDIS_STATUS_SUCCESS);
 }
 
-#ifdef DOT11_N_SUPPORT
 static void	HTParametersHook(
 	IN	PRTMP_ADAPTER pAd,
 	IN	CHAR		  *pValueStr,
@@ -1925,5 +1918,3 @@ static void	HTParametersHook(
 	}
 
 }
-#endif // DOT11_N_SUPPORT //
-
--- a/drivers/staging/rt2870/sta/assoc.c
+++ b/drivers/staging/rt2870/sta/assoc.c
@@ -341,7 +341,6 @@ VOID MlmeAssocReqAction(
 			FrameLen += tmp;
 		}
 
-#ifdef DOT11_N_SUPPORT
 		// HT
 		if ((pAd->MlmeAux.HtCapabilityLen > 0) && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
 		{
@@ -368,7 +367,6 @@ VOID MlmeAssocReqAction(
 			}
 			FrameLen += TmpLen;
 		}
-#endif // DOT11_N_SUPPORT //
 
 		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION
 		// Case I: (Aggregation + Piggy-Back)
@@ -676,7 +674,6 @@ VOID MlmeReassocReqAction(
 			FrameLen += tmp;
 		}
 
-#ifdef DOT11_N_SUPPORT
 		// HT
 		if ((pAd->MlmeAux.HtCapabilityLen > 0) && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
 		{
@@ -703,7 +700,6 @@ VOID MlmeReassocReqAction(
 			}
 			FrameLen += TmpLen;
 		}
-#endif // DOT11_N_SUPPORT //
 
 		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION
 		// Case I: (Aggregation + Piggy-Back)
@@ -882,9 +878,7 @@ VOID PeerAssocRspAction(
 		if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid))
 		{
 			DBGPRINT(RT_DEBUG_TRACE, ("PeerAssocRspAction():ASSOC - receive ASSOC_RSP to me (status=%d)\n", Status));
-#ifdef DOT11_N_SUPPORT
 			DBGPRINT(RT_DEBUG_TRACE, ("PeerAssocRspAction():MacTable [%d].AMsduSize = %d. ClientStatusFlags = 0x%lx \n",Elem->Wcid, pAd->MacTab.Content[BSSID_WCID].AMsduSize, pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
-#endif // DOT11_N_SUPPORT //
 			RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &TimerCancelled);
 			if(Status == MLME_SUCCESS)
 			{
@@ -1035,7 +1029,7 @@ VOID AssocPostProc(
 	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pAddr2);
 	pAd->MlmeAux.Aid = Aid;
 	pAd->MlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
-#ifdef DOT11_N_SUPPORT
+
 	// Some HT AP might lost WMM IE. We add WMM ourselves. beacuase HT requires QoS on.
 	if ((HtCapabilityLen > 0) && (pEdcaParm->bValid == FALSE))
 	{
@@ -1061,7 +1055,6 @@ VOID AssocPostProc(
 		pEdcaParm->Txop[3]  = 48;
 
 	}
-#endif // DOT11_N_SUPPORT //
 
 	NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
 
@@ -1075,7 +1068,6 @@ VOID AssocPostProc(
 	NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
 	RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
 
-#ifdef DOT11_N_SUPPORT
 	if (HtCapabilityLen > 0)
 	{
 		RTMPCheckHt(pAd, BSSID_WCID, pHtCapability, pAddHtInfo);
@@ -1084,7 +1076,6 @@ VOID AssocPostProc(
 
 	DBGPRINT(RT_DEBUG_TRACE, ("AssocPostProc===>    (Mmps=%d, AmsduSize=%d, )\n",
 		pAd->MacTab.Content[BSSID_WCID].MmpsMode, pAd->MacTab.Content[BSSID_WCID].AMsduSize));
-#endif // DOT11_N_SUPPORT //
 
 	// Set New WPA information
 	Idx = BssTableSearch(&pAd->ScanTab, pAddr2, pAd->MlmeAux.Channel);
@@ -1535,11 +1526,9 @@ BOOLEAN StaAddMacTableEntry(
     if ((pAd->CommonCfg.PhyMode == PHY_11G) && (MaxSupportedRate < RATE_FIRST_OFDM_RATE))
         return FALSE;
 
-#ifdef DOT11_N_SUPPORT
 	// 11n only
 	if (((pAd->CommonCfg.PhyMode == PHY_11N_2_4G) || (pAd->CommonCfg.PhyMode == PHY_11N_5G))&& (HtCapabilityLen == 0))
 		return FALSE;
-#endif // DOT11_N_SUPPORT //
 
 	if (!pEntry)
         return FALSE;
@@ -1585,7 +1574,6 @@ BOOLEAN StaAddMacTableEntry(
 		CLIENT_STATUS_CLEAR_FLAG(pEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE);
 	}
 
-#ifdef DOT11_N_SUPPORT
 	// If this Entry supports 802.11n, upgrade to HT rate.
 	if ((HtCapabilityLen != 0) && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
 	{
@@ -1684,7 +1672,6 @@ BOOLEAN StaAddMacTableEntry(
 	}
 
 	NdisMoveMemory(&pEntry->HTCapability, pHtCapability, sizeof(HT_CAPABILITY_IE));
-#endif // DOT11_N_SUPPORT //
 
 	pEntry->HTPhyMode.word = pEntry->MaxHTPhyMode.word;
 	pEntry->CurrTxRate = pEntry->MaxSupportedRate;
--- a/drivers/staging/rt2870/sta/connect.c
+++ b/drivers/staging/rt2870/sta/connect.c
@@ -816,7 +816,7 @@ VOID CntlWaitStartProc(
 				DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Channel=%d, Start adhoc on W53(52,56,60,64) Channels are not accepted\n", pAd->CommonCfg.Channel));
 				return;
 			}
-#ifdef DOT11_N_SUPPORT
+
 			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
 			{
 				N_ChannelCheck(pAd);
@@ -840,7 +840,6 @@ VOID CntlWaitStartProc(
 				}
 			}
 			else
-#endif // DOT11_N_SUPPORT //
 			{
 				pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
 			}
@@ -1127,9 +1126,8 @@ VOID LinkUp(
 
 	COPY_SETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
 
-#ifdef DOT11_N_SUPPORT
 	COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
-#endif // DOT11_N_SUPPORT //
+
 	// It's quite difficult to tell if a newly added KEY is WEP or CKIP until a new BSS
 	// is formed (either ASSOC/RE-ASSOC done or IBSS started. LinkUP should be a safe place
 	// to examine if cipher algorithm switching is required.
@@ -1142,10 +1140,8 @@ VOID LinkUp(
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_ADHOC_ON);
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
 
-#ifdef DOT11_N_SUPPORT
 		if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
 			AdhocTurnOnQos(pAd);
-#endif // DOT11_N_SUPPORT //
 
 		DBGPRINT(RT_DEBUG_TRACE, ("!!!Adhoc LINK UP !!! \n" ));
 	}
@@ -1164,7 +1160,6 @@ VOID LinkUp(
 	Value |= pAd->CommonCfg.RegTransmitSetting.field.TxBF;
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, Value);
 
-#ifdef DOT11_N_SUPPORT
 	// Change to AP channel
     if ((pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel) && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
 	{
@@ -1228,7 +1223,6 @@ VOID LinkUp(
 	    DBGPRINT(RT_DEBUG_TRACE, ("!!! 40MHz Upper LINK UP !!! Control Channel at UpperCentral = %d \n", pAd->CommonCfg.CentralChannel ));
     }
     else
-#endif // DOT11_N_SUPPORT //
     {
 	    pAd->CommonCfg.BBPCurrentBW = BW_20;
 		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
@@ -1267,9 +1261,7 @@ VOID LinkUp(
 	DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !!! (BssType=%d, AID=%d, ssid=%s, Channel=%d, CentralChannel = %d)\n",
 		BssType, pAd->StaActive.Aid, pAd->CommonCfg.Ssid, pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
 
-#ifdef DOT11_N_SUPPORT
 	DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !!! (Density =%d, )\n", pAd->MacTab.Content[BSSID_WCID].MpduDensity));
-#endif // DOT11_N_SUPPORT //
 
 		AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
 
@@ -1279,7 +1271,6 @@ VOID LinkUp(
 	// Call this for RTS protectionfor legacy rate, we will always enable RTS threshold, but normally it will not hit
 	AsicUpdateProtect(pAd, 0, (OFDMSETPROTECT | CCKSETPROTECT), TRUE, FALSE);
 
-#ifdef DOT11_N_SUPPORT
 	if ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE))
 	{
 		// Update HT protectionfor based on AP's operating mode.
@@ -1290,7 +1281,6 @@ VOID LinkUp(
     	else
    			AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode,  ALLN_SETPROTECT, FALSE, FALSE);
 	}
-#endif // DOT11_N_SUPPORT //
 
 	NdisZeroMemory(&pAd->DrsCounters, sizeof(COUNTER_DRS));
 
@@ -1538,10 +1528,8 @@ VOID LinkUp(
 			pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
 
 		MlmeUpdateTxRates(pAd, TRUE, BSS0);
-#ifdef DOT11_N_SUPPORT
 		MlmeUpdateHtTxRates(pAd, BSS0);
 		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !! (StaActive.bHtEnable =%d, )\n", pAd->StaActive.SupportedPhyInfo.bHtEnable));
-#endif // DOT11_N_SUPPORT //
 
 		if (pAd->CommonCfg.bAggregationCapable)
 		{
@@ -1561,12 +1549,11 @@ VOID LinkUp(
 
 		if (pAd->MlmeAux.APRalinkIe != 0x0)
 		{
-#ifdef DOT11_N_SUPPORT
 			if (CLIENT_STATUS_TEST_FLAG(&pAd->MacTab.Content[BSSID_WCID], fCLIENT_STATUS_RDG_CAPABLE))
 			{
 				AsicEnableRDG(pAd);
 			}
-#endif // DOT11_N_SUPPORT //
+
 			OPSTATUS_SET_FLAG(pAd, fCLIENT_STATUS_RALINK_CHIPSET);
 			CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[BSSID_WCID], fCLIENT_STATUS_RALINK_CHIPSET);
 		}
@@ -1577,9 +1564,7 @@ VOID LinkUp(
 		}
 	}
 
-#ifdef DOT11_N_SUPPORT
 	DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_CONNECT Event B!.BACapability = %x. ClientStatusFlags = %lx\n", pAd->CommonCfg.BACapability.word, pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
-#endif // DOT11_N_SUPPORT //
 
 	// Set LED
 	RTMPSetLED(pAd, LED_LINK_UP);
@@ -1604,13 +1589,13 @@ VOID LinkUp(
 	if (pAd->StaCfg.bAutoTxRateSwitch == FALSE)
 	{
 		pEntry->bAutoTxRateSwitch = FALSE;
-#ifdef DOT11_N_SUPPORT
+
 		if (pEntry->HTPhyMode.field.MCS == 32)
 			pEntry->HTPhyMode.field.ShortGI = GI_800;
 
 		if ((pEntry->HTPhyMode.field.MCS > MCS_7) || (pEntry->HTPhyMode.field.MCS == 32))
 			pEntry->HTPhyMode.field.STBC = STBC_NONE;
-#endif // DOT11_N_SUPPORT //
+
 		// If the legacy mode is set, overwrite the transmit setting of this entry.
 		if (pEntry->HTPhyMode.field.MODE <= MODE_OFDM)
 			RTMPUpdateLegacyTxSetting((UCHAR)pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode, pEntry);
@@ -1639,7 +1624,6 @@ VOID LinkUp(
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, Value);
 	}
 
-#ifdef DOT11_N_SUPPORT
 	if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
 	{
 	}
@@ -1649,7 +1633,6 @@ VOID LinkUp(
 	    // Because our Init value is 1 at MACRegTable.
 		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, 0x0fff);
 	}
-#endif // DOT11_N_SUPPORT //
 
 	// Patch for Marvel AP to gain high throughput
 	// Need to set as following,
@@ -1661,7 +1644,6 @@ VOID LinkUp(
 	// Txop can only be modified when RDG is off, WMM is disable and TxBurst is enable
 	//
 	// if 1. Legacy AP WMM on,  or 2. 11n AP, AMPDU disable.  Force turn off burst no matter what bEnableTxBurst is.
-#ifdef DOT11_N_SUPPORT
 	if (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)))
 		|| ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE) && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE)))
 	{
@@ -1673,7 +1655,6 @@ VOID LinkUp(
 		DBGPRINT(RT_DEBUG_TRACE, ("Txburst 1\n"));
 	}
 	else
-#endif // DOT11_N_SUPPORT //
 	if (pAd->CommonCfg.bEnableTxBurst)
 	{
 		RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
@@ -1695,7 +1676,6 @@ VOID LinkUp(
 		DBGPRINT(RT_DEBUG_TRACE, ("Txburst 3\n"));
 	}
 
-#ifdef DOT11_N_SUPPORT
 	// Re-check to turn on TX burst or not.
 	if ((pAd->CommonCfg.IOTestParm.bLastAtheros == TRUE) && ((STA_WEP_ON(pAd))||(STA_TKIP_ON(pAd))))
 	{
@@ -1715,7 +1695,6 @@ VOID LinkUp(
 	{
 		pAd->CommonCfg.IOTestParm.bNextDisableRxBA = FALSE;
 	}
-#endif // DOT11_N_SUPPORT //
 
 	pAd->CommonCfg.IOTestParm.bLastAtheros = FALSE;
 	COPY_MAC_ADDR(pAd->CommonCfg.LastBssid, pAd->CommonCfg.Bssid);
@@ -1883,12 +1862,11 @@ VOID LinkDown(
 		NdisZeroMemory(pAd->CommonCfg.Ssid, MAX_LEN_OF_SSID);
 		pAd->CommonCfg.SsidLen = 0;
 	}
-#ifdef DOT11_N_SUPPORT
+
 	NdisZeroMemory(&pAd->MlmeAux.HtCapability, sizeof(HT_CAPABILITY_IE));
 	NdisZeroMemory(&pAd->MlmeAux.AddHtInfo, sizeof(ADD_HT_INFO_IE));
 	pAd->MlmeAux.HtCapabilityLen = 0;
 	pAd->MlmeAux.NewExtChannelOffset = 0xff;
-#endif // DOT11_N_SUPPORT //
 
 	// Reset WPA-PSK state. Only reset when supplicant enabled
 	if (pAd->StaCfg.WpaState != SS_NOTUSE)
@@ -1970,7 +1948,6 @@ VOID LinkDown(
 	pAd->CommonCfg.MlmeRate = pAd->CommonCfg.BasicMlmeRate;
 	pAd->CommonCfg.RtsRate = pAd->CommonCfg.BasicMlmeRate;
 
-#ifdef DOT11_N_SUPPORT
 	//
 	// After Link down, reset piggy-back setting in ASIC. Disable RDG.
 	//
@@ -1981,7 +1958,7 @@ VOID LinkDown(
 		ByteValue &= (~0x18);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, ByteValue);
 	}
-#endif // DOT11_N_SUPPORT //
+
 	// Reset DAC
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &ByteValue);
 	ByteValue &= (~0x18);
@@ -1994,9 +1971,7 @@ VOID LinkDown(
 	RTMPSetPiggyBack(pAd,FALSE);
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_PIGGYBACK_INUSED);
 
-#ifdef DOT11_N_SUPPORT
 	pAd->CommonCfg.BACapability.word = pAd->CommonCfg.REGBACapability.word;
-#endif // DOT11_N_SUPPORT //
 
 	// Restore all settings in the following.
 	AsicUpdateProtect(pAd, 0, (ALLN_SETPROTECT|CCKSETPROTECT|OFDMSETPROTECT), TRUE, FALSE);
@@ -2420,7 +2395,6 @@ ULONG MakeIbssBeacon(
 		FrameLen += tmp;
 	}
 
-#ifdef DOT11_N_SUPPORT
 	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
 	{
 		ULONG TmpLen;
@@ -2441,7 +2415,6 @@ ULONG MakeIbssBeacon(
 
 		FrameLen += TmpLen;
 	}
-#endif // DOT11_N_SUPPORT //
 
 	//beacon use reserved WCID 0xff
     if (pAd->CommonCfg.Channel > 14)
--- a/drivers/staging/rt2870/sta_ioctl.c
+++ b/drivers/staging/rt2870/sta_ioctl.c
@@ -190,11 +190,9 @@ INT Set_FragTest_Proc(
     IN  PRTMP_ADAPTER   pAdapter,
     IN  PUCHAR          arg);
 
-#ifdef DOT11_N_SUPPORT
 INT Set_TGnWifiTest_Proc(
     IN  PRTMP_ADAPTER   pAd,
     IN  PUCHAR          arg);
-#endif // DOT11_N_SUPPORT //
 
 INT Set_LongRetryLimit_Proc(
 	IN	PRTMP_ADAPTER	pAdapter,
@@ -224,7 +222,6 @@ static struct {
 	{"BGProtection",				Set_BGProtection_Proc},
 	{"RTSThreshold",				Set_RTSThreshold_Proc},
 	{"FragThreshold",				Set_FragThreshold_Proc},
-#ifdef DOT11_N_SUPPORT
 	{"HtBw",		                Set_HtBw_Proc},
 	{"HtMcs",		                Set_HtMcs_Proc},
 	{"HtGi",		                Set_HtGi_Proc},
@@ -238,8 +235,6 @@ static struct {
 	{"HtBaDecline",					Set_BADecline_Proc},
 	{"HtProtect",		        	Set_HtProtect_Proc},
 	{"HtMimoPs",		        	Set_HtMimoPs_Proc},
-#endif // DOT11_N_SUPPORT //
-
 #ifdef AGGREGATION_SUPPORT
 	{"PktAggregate",				Set_PktAggregate_Proc},
 #endif
@@ -264,10 +259,8 @@ static struct {
 #endif
     {"WpaSupport",                  Set_Wpa_Support},
 	{"FixedTxMode",                 Set_FixedTxMode_Proc},
-#ifdef DOT11_N_SUPPORT
     {"TGnWifiTest",                 Set_TGnWifiTest_Proc},
     {"ForceGF",		        		Set_ForceGF_Proc},
-#endif // DOT11_N_SUPPORT //
 	{"LongRetry",	        		Set_LongRetryLimit_Proc},
 	{"ShortRetry",	        		Set_ShortRetryLimit_Proc},
 	{NULL,}
@@ -1888,7 +1881,6 @@ rt_private_get_statistics(struct net_dev
     return Status;
 }
 
-#ifdef DOT11_N_SUPPORT
 void	getBaInfo(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			pOutBuf)
@@ -1935,7 +1927,6 @@ void	getBaInfo(
 
 	return;
 }
-#endif // DOT11_N_SUPPORT //
 
 static int
 rt_private_show(struct net_device *dev, struct iw_request_info *info,
@@ -1981,12 +1972,10 @@ rt_private_show(struct net_device *dev, 
         case SHOW_CONN_STATUS:
             if (MONITOR_ON(pAd))
             {
-#ifdef DOT11_N_SUPPORT
                 if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED &&
                     pAd->CommonCfg.RegTransmitSetting.field.BW)
                     sprintf(extra, "Monitor Mode(CentralChannel %d)\n", pAd->CommonCfg.CentralChannel);
                 else
-#endif // DOT11_N_SUPPORT //
                     sprintf(extra, "Monitor Mode(Channel %d)\n", pAd->CommonCfg.Channel);
             }
             else
@@ -2020,12 +2009,10 @@ rt_private_show(struct net_device *dev, 
             sprintf(extra, "Driver version-%s, %s %s\n", STA_DRIVER_VERSION, __DATE__, __TIME__ );
             wrq->length = strlen(extra) + 1; // 1: size of '\0'
             break;
-#ifdef DOT11_N_SUPPORT
         case SHOW_BA_INFO:
             getBaInfo(pAd, extra);
             wrq->length = strlen(extra) + 1; // 1: size of '\0'
             break;
-#endif // DOT11_N_SUPPORT //
 		case SHOW_DESC_INFO:
 			{
 				Show_DescInfo_Proc(pAd, NULL);
@@ -2868,9 +2855,7 @@ int rt_ioctl_siwrate(struct net_device *
 		    (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <= MODE_OFDM))
 			RTMPSetDesiredRates(pAd, -1);
 
-#ifdef DOT11_N_SUPPORT
 		SetCommonHT(pAd);
-#endif // DOT11_N_SUPPORT //
     }
     else
     {
@@ -2883,9 +2868,7 @@ int rt_ioctl_siwrate(struct net_device *
             else
             {
                 pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
-#ifdef DOT11_N_SUPPORT
                 SetCommonHT(pAd);
-#endif // DOT11_N_SUPPORT //
             }
             DBGPRINT(RT_DEBUG_TRACE, ("rt_ioctl_siwrate::(HtMcs=%d)\n",pAd->StaCfg.DesiredTransmitSetting.field.MCS));
         }
@@ -2933,14 +2916,12 @@ int rt_ioctl_giwrate(struct net_device *
     else
         ht_setting.word = pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word;
 
-#ifdef DOT11_N_SUPPORT
     if (ht_setting.field.MODE >= MODE_HTMIX)
     {
 //    	rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS);
     	rate_index = 12 + ((UCHAR)ht_setting.field.BW *24) + ((UCHAR)ht_setting.field.ShortGI *48) + ((UCHAR)ht_setting.field.MCS);
     }
     else
-#endif // DOT11_N_SUPPORT //
     if (ht_setting.field.MODE == MODE_OFDM)
     	rate_index = (UCHAR)(ht_setting.field.MCS) + 4;
     else if (ht_setting.field.MODE == MODE_CCK)
@@ -3105,18 +3086,13 @@ INT RTMPSetInformation(
     ULONG                               PowerTemp;
     BOOLEAN                             RadioState;
     BOOLEAN                             StateMachineTouched = FALSE;
-#ifdef DOT11_N_SUPPORT
 	OID_SET_HT_PHYMODE					HT_PhyMode;	//11n ,kathy
-#endif // DOT11_N_SUPPORT //
     PNDIS_802_11_PMKID                  pPmkId = NULL;
     BOOLEAN				                IEEE8021xState = FALSE;
     BOOLEAN				                IEEE8021x_required_keys = FALSE;
     UCHAR                               wpa_supplicant_enable = 0;
 
-#ifdef DOT11_N_SUPPORT
 	MaxPhyMode = PHY_11N_5G;
-#endif // DOT11_N_SUPPORT //
-
 
 	DBGPRINT(RT_DEBUG_TRACE, ("-->RTMPSetInformation(),	0x%08x\n", cmd&0x7FFF));
     switch(cmd & 0x7FFF) {
@@ -3136,9 +3112,7 @@ INT RTMPSetInformation(
 				pAdapter->CommonCfg.PhyMode = 0xff;
 				// Build all corresponding channel information
 				RTMPSetPhyMode(pAdapter, TmpPhy);
-#ifdef DOT11_N_SUPPORT
 				SetCommonHT(pAdapter);
-#endif // DOT11_N_SUPPORT //
 				DBGPRINT(RT_DEBUG_TRACE, ("Set::RT_OID_802_11_COUNTRY_REGION (A:%d  B/G:%d)\n", pAdapter->CommonCfg.CountryRegionForABand,
 				    pAdapter->CommonCfg.CountryRegion));
             }
@@ -3316,9 +3290,7 @@ INT RTMPSetInformation(
 				if (PhyMode <= MaxPhyMode)
 				{
                 	RTMPSetPhyMode(pAdapter, PhyMode);
-#ifdef DOT11_N_SUPPORT
 					SetCommonHT(pAdapter);
-#endif // DOT11_N_SUPPORT //
 				}
                 DBGPRINT(RT_DEBUG_TRACE, ("Set::RT_OID_802_11_PHY_MODE (=%d)\n", PhyMode));
             }
@@ -3596,10 +3568,10 @@ INT RTMPSetInformation(
 					RTMPSetPhyMode(pAdapter, PHY_11A);
 				else
 					Status = -EINVAL;
-#ifdef DOT11_N_SUPPORT
+
 				if (Status == NDIS_STATUS_SUCCESS)
 					SetCommonHT(pAdapter);
-#endif // DOT11_N_SUPPORT //
+
                 DBGPRINT(RT_DEBUG_TRACE, ("Set::OID_802_11_NETWORK_TYPE_IN_USE (=%d)\n",NetType));
 		    }
 			break;
@@ -3743,7 +3715,6 @@ INT RTMPSetInformation(
                 pAdapter->bConfigChanged = TRUE;
             }
             break;
-#ifdef DOT11_N_SUPPORT
 		case RT_OID_802_11_SET_HT_PHYMODE:
 			if (wrq->u.data.length	!= sizeof(OID_SET_HT_PHYMODE))
 				Status = -EINVAL;
@@ -3762,7 +3733,6 @@ INT RTMPSetInformation(
 				pAdapter->StaCfg.HTPhyMode.field.MCS, pAdapter->StaCfg.HTPhyMode.field.BW, pAdapter->StaCfg.HTPhyMode.field.ShortGI,
 				pAdapter->StaCfg.HTPhyMode.field.STBC));
 			break;
-#endif // DOT11_N_SUPPORT //
 		case RT_OID_802_11_SET_APSD_SETTING:
 			if (wrq->u.data.length != sizeof(ULONG))
 				Status = -EINVAL;
@@ -3845,8 +3815,6 @@ INT RTMPSetInformation(
 				StateMachineTouched	= TRUE;
 			}
 			break;
-
-#ifdef DOT11_N_SUPPORT
 		case RT_OID_802_11_SET_IMME_BA_CAP:
 				if (wrq->u.data.length != sizeof(OID_BACAP_STRUC))
 					Status = -EINVAL;
@@ -4001,8 +3969,6 @@ INT RTMPSetInformation(
 				}
             }
             break;
-#endif // DOT11_N_SUPPORT //
-
         // For WPA_SUPPLICANT to set static wep key
     	case OID_802_11_ADD_WEP:
     	    pWepKey = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG);
@@ -5342,19 +5308,14 @@ INT Set_NetworkType_Proc(
 		DBGPRINT(RT_DEBUG_TRACE, ("fOP_STATUS_MEDIA_STATE_CONNECTED \n"));
         if (pAdapter->CommonCfg.CentralChannel == 0)
         {
-#ifdef DOT11_N_SUPPORT
             if (pAdapter->CommonCfg.PhyMode == PHY_11AN_MIXED)
                 pAdapter->CommonCfg.CentralChannel = 36;
             else
-#endif // DOT11_N_SUPPORT //
                 pAdapter->CommonCfg.CentralChannel = 6;
         }
-#ifdef DOT11_N_SUPPORT
         else
             N_ChannelCheck(pAdapter);
-#endif // DOT11_N_SUPPORT //
 
-#ifdef DOT11_N_SUPPORT
 	if (pAdapter->CommonCfg.PhyMode >= PHY_11ABGN_MIXED &&
             pAdapter->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
             pAdapter->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
@@ -5405,7 +5366,6 @@ INT Set_NetworkType_Proc(
                                        pAdapter->CommonCfg.CentralChannel));
 		}
 		else
-#endif // DOT11_N_SUPPORT //
 		{
 			// 20MHz
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4, &bbpValue);
@@ -6426,9 +6386,7 @@ INT	Show_Adhoc_MacTable_Proc(
 
 	sprintf(extra, "\n");
 
-#ifdef DOT11_N_SUPPORT
 	sprintf(extra + strlen(extra), "HT Operating Mode : %d\n", pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode);
-#endif // DOT11_N_SUPPORT //
 
 	sprintf(extra + strlen(extra), "\n%-19s%-4s%-4s%-7s%-7s%-7s%-10s%-6s%-6s%-6s%-6s\n",
 			"MAC", "AID", "BSS", "RSSI0", "RSSI1", "RSSI2", "PhMd", "BW", "MCS", "SGI", "STBC");
--- a/drivers/staging/rt2870/sta/rtmp_data.c
+++ b/drivers/staging/rt2870/sta/rtmp_data.c
@@ -182,13 +182,12 @@ VOID STARxDataFrameAnnounce(
 	else
 	{
 		RX_BLK_SET_FLAG(pRxBlk, fRX_EAP);
-#ifdef DOT11_N_SUPPORT
+
 		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU) && (pAd->CommonCfg.bDisableReordering == 0))
 		{
 			Indicate_AMPDU_Packet(pAd, pRxBlk, FromWhichBSSID);
 		}
 		else
-#endif // DOT11_N_SUPPORT //
 		{
 			// Determin the destination of the EAP frame
 			//  to WPA state machine or upper layer
@@ -439,12 +438,10 @@ VOID STAHandleRxDataFrame(
 		else
 #endif
 		{
-#ifdef DOT11_N_SUPPORT
 			RX_BLK_SET_FLAG(pRxBlk, fRX_HTC);
 			// skip HTC contorl field
 			pRxBlk->pData += 4;
 			pRxBlk->DataSize -= 4;
-#endif // DOT11_N_SUPPORT //
 		}
 	}
 
@@ -457,13 +454,10 @@ VOID STAHandleRxDataFrame(
 		pRxBlk->pData += 2;
 	}
 
-#ifdef DOT11_N_SUPPORT
 	if (pRxD->BA)
 	{
 		RX_BLK_SET_FLAG(pRxBlk, fRX_AMPDU);
 	}
-#endif // DOT11_N_SUPPORT //
-
 
 	//
 	// Case I  Process Broadcast & Multicast data frame
@@ -592,21 +586,17 @@ VOID STAHandleRxControlFrame(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RX_BLK			*pRxBlk)
 {
-#ifdef DOT11_N_SUPPORT
 	PRXWI_STRUC		pRxWI = pRxBlk->pRxWI;
-#endif // DOT11_N_SUPPORT //
 	PHEADER_802_11	pHeader = pRxBlk->pHeader;
 	PNDIS_PACKET	pRxPacket = pRxBlk->pRxPacket;
 
 	switch (pHeader->FC.SubType)
 	{
 		case SUBTYPE_BLOCK_ACK_REQ:
-#ifdef DOT11_N_SUPPORT
 			{
 				CntlEnqueueForRecv(pAd, pRxWI->WirelessCliID, (pRxWI->MPDUtotalByteCount), (PFRAME_BA_REQ)pHeader);
 			}
 			break;
-#endif // DOT11_N_SUPPORT //
 		case SUBTYPE_BLOCK_ACK:
 		case SUBTYPE_ACK:
 		default:
@@ -983,10 +973,8 @@ NDIS_STATUS STASendPacket(
 		NumberOfFrag = 1;	// Aggregation overwhelms fragmentation
 	else if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_AMSDU_INUSED))
 		NumberOfFrag = 1;	// Aggregation overwhelms fragmentation
-#ifdef DOT11_N_SUPPORT
 	else if ((pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTMIX) || (pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTGREENFIELD))
 		NumberOfFrag = 1;	// MIMO RATE overwhelms fragmentation
-#endif // DOT11_N_SUPPORT //
 	else
 	{
 		// The calculated "NumberOfFrag" is a rough estimation because of various
@@ -1087,7 +1075,6 @@ NDIS_STATUS STASendPacket(
 	}
 	RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
 
-#ifdef DOT11_N_SUPPORT
     if ((pAd->CommonCfg.BACapability.field.AutoBA == TRUE)&&
         IS_HT_STA(pEntry))
 	{
@@ -1106,7 +1093,6 @@ NDIS_STATUS STASendPacket(
 			BAOriSessionSetUp(pAd, pEntry, 0, 0, 10, FALSE);
 		}
 	}
-#endif // DOT11_N_SUPPORT //
 
 	pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++; // TODO: for debug only. to be removed
 	return NDIS_STATUS_SUCCESS;
@@ -1426,7 +1412,6 @@ VOID STABuildCommon802_11Header(
     	pHeader_802_11->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
 }
 
-#ifdef DOT11_N_SUPPORT
 VOID STABuildCache802_11Header(
 	IN RTMP_ADAPTER		*pAd,
 	IN TX_BLK			*pTxBlk,
@@ -1468,7 +1453,6 @@ VOID STABuildCache802_11Header(
 	else
     	pHeader80211->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
 }
-#endif // DOT11_N_SUPPORT //
 
 static inline PUCHAR STA_Build_ARalink_Frame_Header(
 	IN RTMP_ADAPTER *pAd,
@@ -1528,7 +1512,6 @@ static inline PUCHAR STA_Build_ARalink_F
 
 }
 
-#ifdef DOT11_N_SUPPORT
 static inline PUCHAR STA_Build_AMSDU_Frame_Header(
 	IN RTMP_ADAPTER *pAd,
 	IN TX_BLK		*pTxBlk)
@@ -1850,7 +1833,6 @@ VOID STA_AMSDU_Frame_Tx(
 	//
 	HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 }
-#endif // DOT11_N_SUPPORT //
 
 VOID STA_Legacy_Frame_Tx(
 	IN	PRTMP_ADAPTER	pAd,
@@ -2361,14 +2343,12 @@ NDIS_STATUS STAHardTransmit(
 
 	switch (pTxBlk->TxFrameType)
 	{
-#ifdef DOT11_N_SUPPORT
 		case TX_AMPDU_FRAME:
 				STA_AMPDU_Frame_Tx(pAd, pTxBlk);
 			break;
 		case TX_AMSDU_FRAME:
 				STA_AMSDU_Frame_Tx(pAd, pTxBlk);
 			break;
-#endif // DOT11_N_SUPPORT //
 		case TX_LEGACY_FRAME:
 				STA_Legacy_Frame_Tx(pAd, pTxBlk);
 			break;
--- a/drivers/staging/rt2870/sta/sanity.c
+++ b/drivers/staging/rt2870/sta/sanity.c
@@ -184,7 +184,6 @@ BOOLEAN PeerAssocRspSanity(
 			}
 
 		break;
-#ifdef DOT11_N_SUPPORT
             case IE_ADD_HT:
             case IE_ADD_HT2:
 			if (pEid->Len >= sizeof(ADD_HT_INFO_IE))
@@ -213,7 +212,6 @@ BOOLEAN PeerAssocRspSanity(
 			{
 				DBGPRINT(RT_DEBUG_WARN, ("PeerAssocRspSanity - wrong IE_SECONDARY_CH_OFFSET. \n"));
 			}
-#endif // DOT11_N_SUPPORT //
 		break;
             case IE_AIRONET_CKIP:
                 // 0. Check Aironet IE length, it must be larger or equal to 28
--- a/drivers/staging/rt2870/sta/sync.c
+++ b/drivers/staging/rt2870/sta/sync.c
@@ -108,7 +108,6 @@ VOID BeaconTimeout(
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
 		return;
 
-#ifdef DOT11_N_SUPPORT
 	if ((pAd->CommonCfg.BBPCurrentBW == BW_40)
 		)
 	{
@@ -121,7 +120,6 @@ VOID BeaconTimeout(
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
 		DBGPRINT(RT_DEBUG_TRACE, ("SYNC - End of SCAN, restore to 40MHz channel %d, Total BSS[%02d]\n",pAd->CommonCfg.CentralChannel, pAd->ScanTab.BssNr));
 	}
-#endif // DOT11_N_SUPPORT //
 
 	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_BEACON_TIMEOUT, 0, NULL);
 	RT28XX_MLME_HANDLER(pAd);
@@ -475,7 +473,7 @@ VOID MlmeStartReqAction(
 		pAd->MlmeAux.ExtRateLen = pAd->CommonCfg.ExtRateLen;
 		NdisMoveMemory(pAd->MlmeAux.ExtRate, pAd->CommonCfg.ExtRate, MAX_LEN_OF_SUPPORTED_RATES);
 		RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
-#ifdef DOT11_N_SUPPORT
+
 		if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
 		{
 			RTMPUpdateHTIE(&pAd->CommonCfg.DesiredHtPhy, &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0], &pAd->MlmeAux.HtCapability, &pAd->MlmeAux.AddHtInfo);
@@ -484,7 +482,6 @@ VOID MlmeStartReqAction(
 			DBGPRINT(RT_DEBUG_TRACE, ("SYNC -pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE\n"));
 		}
 		else
-#endif // DOT11_N_SUPPORT //
 		{
 			pAd->MlmeAux.HtCapabilityLen = 0;
 			pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
@@ -554,10 +551,9 @@ VOID PeerBeaconAtScanAction(
 	// Init Variable IE structure
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
-#ifdef DOT11_N_SUPPORT
+
     RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
 	RTMPZeroMemory(&AddHtInfo, sizeof(ADD_HT_INFO_IE));
-#endif // DOT11_N_SUPPORT //
 
 	if (PeerBeaconAndProbeRspSanity(pAd,
 								Elem->Msg,
@@ -608,11 +604,9 @@ VOID PeerBeaconAtScanAction(
 
 		Rssi = RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0), ConvertToRssi(pAd, Elem->Rssi1, RSSI_1), ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
 
-
-#ifdef DOT11_N_SUPPORT
 		if ((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
 			HtCapabilityLen = SIZE_HT_CAP_IE;
-#endif // DOT11_N_SUPPORT //
+
 		if ((pAd->StaCfg.CCXReqType != MSRN_TYPE_UNUSED) && (Channel == pAd->StaCfg.CCXScanChannel))
 		{
 			Idx = BssTableSetEntry(pAd, &pAd->StaCfg.CCXBssTab, Bssid, Ssid, SsidLen, BssType, BeaconPeriod,
@@ -682,9 +676,7 @@ VOID PeerBeaconAtJoinAction(
 	UCHAR				HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
 	UCHAR			AddHtInfoLen;
 	UCHAR			NewExtChannelOffset = 0xff;
-#ifdef DOT11_N_SUPPORT
 	UCHAR			CentralChannel;
-#endif // DOT11_N_SUPPORT //
 
 	// Init Variable IE structure
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
@@ -800,7 +792,7 @@ VOID PeerBeaconAtJoinAction(
 			RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
 
             NdisZeroMemory(pAd->StaActive.SupportedPhyInfo.MCSSet, 16);
-#ifdef DOT11_N_SUPPORT
+
 			pAd->MlmeAux.NewExtChannelOffset = NewExtChannelOffset;
 			pAd->MlmeAux.HtCapabilityLen = HtCapabilityLen;
 
@@ -845,7 +837,6 @@ VOID PeerBeaconAtJoinAction(
 
 			}
 			else
-#endif // DOT11_N_SUPPORT //
 			{
    				// To prevent error, let legacy AP must have same CentralChannel and Channel.
 				if ((HtCapabilityLen == 0) && (PreNHtCapabilityLen == 0))
@@ -860,9 +851,7 @@ VOID PeerBeaconAtJoinAction(
 
 			// copy QOS related information
 			if ((pAd->CommonCfg.bWmmCapable)
-#ifdef DOT11_N_SUPPORT
 				 || (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-#endif // DOT11_N_SUPPORT //
 				)
 			{
 				NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, &EdcaParm, sizeof(EDCA_PARM));
@@ -1003,14 +992,12 @@ VOID PeerBeacon(
 		if (pAd->Mlme.CntlMachine.CurrState == CNTL_WAIT_DISASSOC)
 			return;
 
-#ifdef DOT11_N_SUPPORT
 		// Copy Control channel for this BSSID.
 		if (AddHtInfoLen != 0)
 			Channel = AddHtInfo.ControlChan;
 
 		if ((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
 			HtCapabilityLen = SIZE_HT_CAP_IE;
-#endif // DOT11_N_SUPPORT //
 
 		//
 		// Housekeeping "SsidBssTab" table for later-on ROAMing usage.
@@ -1248,7 +1235,6 @@ VOID PeerBeacon(
 					DBGPRINT(RT_DEBUG_WARN, ("SYNC - AP changed B/G protection to %d\n", bUseBGProtection));
 				}
 
-#ifdef DOT11_N_SUPPORT
 				// check Ht protection mode. and adhere to the Non-GF device indication by AP.
 				if ((AddHtInfoLen != 0) &&
 					((AddHtInfo.AddHtInfo2.OperaionMode != pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode) ||
@@ -1265,7 +1251,6 @@ VOID PeerBeacon(
 
 					DBGPRINT(RT_DEBUG_TRACE, ("SYNC - AP changed N OperaionMode to %d\n", pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode));
 				}
-#endif // DOT11_N_SUPPORT //
 
 				if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED) &&
 					ERP_IS_USE_BARKER_PREAMBLE(Erp))
@@ -1360,9 +1345,7 @@ VOID PeerProbeReqAction(
 	UCHAR         Addr2[MAC_ADDR_LEN];
 	CHAR          Ssid[MAX_LEN_OF_SSID];
 	UCHAR         SsidLen;
-#ifdef DOT11_N_SUPPORT
 	UCHAR		  HtLen, AddHtLen, NewExtLen;
-#endif // DOT11_N_SUPPORT //
 	HEADER_802_11 ProbeRspHdr;
 	NDIS_STATUS   NStatus;
 	PUCHAR        pOutBuffer = NULL;
@@ -1435,7 +1418,7 @@ VOID PeerProbeReqAction(
 						  			END_OF_ARGS);
 				FrameLen += tmp;
 			}
-#ifdef DOT11_N_SUPPORT
+
 			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
 			{
 				ULONG TmpLen;
@@ -1468,7 +1451,7 @@ VOID PeerProbeReqAction(
 				}
 				FrameLen += TmpLen;
 			}
-#endif // DOT11_N_SUPPORT //
+
 			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 			MlmeFreeMemory(pAd, pOutBuffer);
 		}
