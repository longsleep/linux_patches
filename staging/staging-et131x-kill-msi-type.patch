From alan@linux.intel.com  Thu Aug 27 14:30:52 2009
From: Alan Cox <alan@linux.intel.com>
Date: Thu, 27 Aug 2009 11:02:34 +0100
Subject: Staging: et131x: kill MSI type
To: greg@kroah.com
Message-ID: <20090827100230.23892.61391.stgit@localhost.localdomain>


Kill off the MSI structure

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_address_map.h |   24 +++-------------
 drivers/staging/et131x/et131x_initpci.c     |   42 ++++++++++++++--------------
 2 files changed, 26 insertions(+), 40 deletions(-)


--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -132,25 +132,11 @@
  */
 
 /*
- * structure for MSI Configuration reg in global address map
- * located at address 0x0030
+ * MSI Configuration reg at address 0x0030
  */
-typedef union _MSI_CONFIG_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 unused1:13;	/* bits 19-31 */
-		u32 msi_tc:3;	/* bits 16-18 */
-		u32 unused2:11;	/* bits 5-15 */
-		u32 msi_vector:5;	/* bits 0-4 */
-#else
-		u32 msi_vector:5;	/* bits 0-4 */
-		u32 unused2:11;	/* bits 5-15 */
-		u32 msi_tc:3;	/* bits 16-18 */
-		u32 unused1:13;	/* bits 19-31 */
-#endif
-	} bits;
-} MSI_CONFIG_t, *PMSI_CONFIG_t;
+
+#define ET_MSI_VECTOR	0x0000001F
+#define ET_MSI_TC	0x00070000
 
 /*
  * structure for Loopback reg in global address map
@@ -188,7 +174,7 @@ typedef struct _GLOBAL_t {			/* Location
 	u32 int_status_alias;			/*  0x0024 */
 	u32 sw_reset;				/*  0x0028 */
 	u32 slv_timer;				/*  0x002C */
-	MSI_CONFIG_t msi_config;		/*  0x0030 */
+	u32 msi_config;				/*  0x0030 */
 	LOOPBACK_t loopback;			/*  0x0034 */
 	u32 watchdog_timer;			/*  0x0038 */
 } GLOBAL_t, *PGLOBAL_t;
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -539,7 +539,7 @@ void et131x_link_detection_handler(unsig
  */
 void ConfigGlobalRegs(struct et131x_adapter *etdev)
 {
-	struct _GLOBAL_t __iomem *pGbl = &etdev->regs->global;
+	struct _GLOBAL_t __iomem *regs = &etdev->regs->global;
 
 	DBG_ENTER(et131x_dbginfo);
 
@@ -550,52 +550,52 @@ void ConfigGlobalRegs(struct et131x_adap
 			 * and Rx as it desires.  Our default is to split it
 			 * 50/50:
 			 */
-			writel(0, &pGbl->rxq_start_addr);
-			writel(PARM_RX_MEM_END_DEF, &pGbl->rxq_end_addr);
-			writel(PARM_RX_MEM_END_DEF + 1, &pGbl->txq_start_addr);
-			writel(INTERNAL_MEM_SIZE - 1, &pGbl->txq_end_addr);
+			writel(0, &regs->rxq_start_addr);
+			writel(PARM_RX_MEM_END_DEF, &regs->rxq_end_addr);
+			writel(PARM_RX_MEM_END_DEF + 1, &regs->txq_start_addr);
+			writel(INTERNAL_MEM_SIZE - 1, &regs->txq_end_addr);
 		} else if (etdev->RegistryJumboPacket < 8192) {
 			/* For jumbo packets > 2k but < 8k, split 50-50. */
-			writel(0, &pGbl->rxq_start_addr);
-			writel(INTERNAL_MEM_RX_OFFSET, &pGbl->rxq_end_addr);
-			writel(INTERNAL_MEM_RX_OFFSET + 1, &pGbl->txq_start_addr);
-			writel(INTERNAL_MEM_SIZE - 1, &pGbl->txq_end_addr);
+			writel(0, &regs->rxq_start_addr);
+			writel(INTERNAL_MEM_RX_OFFSET, &regs->rxq_end_addr);
+			writel(INTERNAL_MEM_RX_OFFSET + 1, &regs->txq_start_addr);
+			writel(INTERNAL_MEM_SIZE - 1, &regs->txq_end_addr);
 		} else {
 			/* 9216 is the only packet size greater than 8k that
 			 * is available. The Tx buffer has to be big enough
 			 * for one whole packet on the Tx side. We'll make
 			 * the Tx 9408, and give the rest to Rx
 			 */
-			writel(0x0000, &pGbl->rxq_start_addr);
-			writel(0x01b3, &pGbl->rxq_end_addr);
-			writel(0x01b4, &pGbl->txq_start_addr);
-			writel(INTERNAL_MEM_SIZE - 1,&pGbl->txq_end_addr);
+			writel(0x0000, &regs->rxq_start_addr);
+			writel(0x01b3, &regs->rxq_end_addr);
+			writel(0x01b4, &regs->txq_start_addr);
+			writel(INTERNAL_MEM_SIZE - 1,&regs->txq_end_addr);
 		}
 
 		/* Initialize the loopback register. Disable all loopbacks. */
-		writel(0, &pGbl->loopback.value);
+		writel(0, &regs->loopback.value);
 	} else {
 		/* For PHY Line loopback, the memory is configured as if Tx
 		 * and Rx both have all the memory.  This is because the
 		 * RxMAC will write data into the space, and the TxMAC will
 		 * read it out.
 		 */
-		writel(0, &pGbl->rxq_start_addr);
-		writel(INTERNAL_MEM_SIZE - 1, &pGbl->rxq_end_addr);
-		writel(0, &pGbl->txq_start_addr);
-		writel(INTERNAL_MEM_SIZE - 1, &pGbl->txq_end_addr);
+		writel(0, &regs->rxq_start_addr);
+		writel(INTERNAL_MEM_SIZE - 1, &regs->rxq_end_addr);
+		writel(0, &regs->txq_start_addr);
+		writel(INTERNAL_MEM_SIZE - 1, &regs->txq_end_addr);
 
 		/* Initialize the loopback register (MAC loopback). */
-		writel(1, &pGbl->loopback);
+		writel(1, &regs->loopback);
 	}
 
 	/* MSI Register */
-	writel(0, &pGbl->msi_config.value);
+	writel(0, &regs->msi_config);
 
 	/* By default, disable the watchdog timer.  It will be enabled when
 	 * a packet is queued.
 	 */
-	writel(0, &pGbl->watchdog_timer);
+	writel(0, &regs->watchdog_timer);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
