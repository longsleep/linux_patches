From foo@baz Wed Aug 12 16:36:38 PDT 2009
Date: Wed, 12 Aug 2009 16:36:38 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Staging: rtl8192e: remove #if 0 sections

This removes a lot of code that is never built in to the driver.

The size of the built code after this patch is identical to before it.

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/rtl8192e/r8192E_core.c     |  236 -----------------------------
 drivers/staging/rtl8192e/r8192E_dm.c       |  171 ---------------------
 drivers/staging/rtl8192e/r8192E_wx.c       |   45 -----
 drivers/staging/rtl8192e/r819xE_cmdpkt.c   |   16 -
 drivers/staging/rtl8192e/r819xE_firmware.c |  219 --------------------------
 5 files changed, 2 insertions(+), 685 deletions(-)

--- a/drivers/staging/rtl8192e/r8192E_core.c
+++ b/drivers/staging/rtl8192e/r8192E_core.c
@@ -115,10 +115,6 @@ static struct pci_device_id rtl8192_pci_
 };
 
 static char* ifname = "wlan%d";
-#if 0
-static int hwseqnum = 0;
-static int hwwep = 0;
-#endif
 static int hwwep = 1; //default use hw. set 0 to use software security
 static int channels = 0x3fff;
 
@@ -130,19 +126,6 @@ MODULE_DEVICE_TABLE(pci, rtl8192_pci_id_
 //MODULE_AUTHOR("Andrea Merello <andreamrl@tiscali.it>");
 MODULE_DESCRIPTION("Linux driver for Realtek RTL819x WiFi cards");
 
-#if 0
-MODULE_PARM(ifname,"s");
-MODULE_PARM_DESC(devname," Net interface name, wlan%d=default");
-
-MODULE_PARM(hwseqnum,"i");
-MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
-
-MODULE_PARM(hwwep,"i");
-MODULE_PARM_DESC(hwwep," Try to use hardware WEP support. Still broken and not available on all cards");
-
-MODULE_PARM(channels,"i");
-MODULE_PARM_DESC(channels," Channel bitmask for specific locales. NYI");
-#endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
 module_param(ifname, charp, S_IRUGO|S_IWUSR );
@@ -515,99 +498,6 @@ static int proc_get_registers(char *page
 }
 
 
-#if 0
-static int proc_get_cck_reg(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-//	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	int len = 0;
-	int i,n;
-
-	int max = 0x5F;
-
-	/* This dump the current register page */
-	for(n=0;n<=max;)
-	{
-		//printk( "\nD: %2x> ", n);
-		len += snprintf(page + len, count - len,
-			"\nD:  %2x > ",n);
-
-		for(i=0;i<16 && n<=max;i++,n++)
-		len += snprintf(page + len, count - len,
-			"%2x ",read_phy_cck(dev,n));
-
-		//	printk("%2x ",read_nic_byte(dev,n));
-	}
-	len += snprintf(page + len, count - len,"\n");
-
-
-	*eof = 1;
-	return len;
-}
-
-#endif
-
-#if 0
-static int proc_get_ofdm_reg(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-
-	struct net_device *dev = data;
-//	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	int len = 0;
-	int i,n;
-
-	//int max=0xff;
-	int max = 0x40;
-
-	/* This dump the current register page */
-	for(n=0;n<=max;)
-	{
-		//printk( "\nD: %2x> ", n);
-		len += snprintf(page + len, count - len,
-			"\nD:  %2x > ",n);
-
-		for(i=0;i<16 && n<=max;i++,n++)
-		len += snprintf(page + len, count - len,
-			"%2x ",read_phy_ofdm(dev,n));
-
-		//	printk("%2x ",read_nic_byte(dev,n));
-	}
-	len += snprintf(page + len, count - len,"\n");
-
-
-
-	*eof = 1;
-	return len;
-}
-
-#endif
-
-#if 0
-static int proc_get_stats_hw(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	int len = 0;
-
-	len += snprintf(page + len, count - len,
-		"NIC int: %lu\n"
-		"Total int: %lu\n",
-		priv->stats.ints,
-		priv->stats.shints);
-
-	*eof = 1;
-	return len;
-}
-#endif
 
 static int proc_get_stats_tx(char *page, char **start,
 			  off_t offset, int count,
@@ -770,16 +660,6 @@ static void rtl8192_proc_init_one(struct
 		      dev->name);
 		return;
 	}
-	#if 0
-	e = create_proc_read_entry("stats-hw", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_hw, dev);
-
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8192/%s/stats-hw\n",
-		      dev->name);
-	}
-	#endif
 	e = create_proc_read_entry("stats-rx", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_rx, dev);
 
@@ -798,17 +678,6 @@ static void rtl8192_proc_init_one(struct
 		      "/proc/net/rtl8192/%s/stats-tx\n",
 		      dev->name);
 	}
-	#if 0
-	e = create_proc_read_entry("stats-ieee", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_ieee, dev);
-
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8192/%s/stats-ieee\n",
-		      dev->name);
-	}
-
-	#endif
 
 	e = create_proc_read_entry("stats-ap", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_ap, dev);
@@ -826,23 +695,6 @@ static void rtl8192_proc_init_one(struct
 		      "/proc/net/rtl8192/%s/registers\n",
 		      dev->name);
 	}
-#if 0
-	e = create_proc_read_entry("cck-registers", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_cck_reg, dev);
-	if (!e) {
-		RT_TRACE(COMP_ERR, "Unable to initialize "
-		      "/proc/net/rtl8192/%s/cck-registers\n",
-		      dev->name);
-	}
-
-	e = create_proc_read_entry("ofdm-registers", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_ofdm_reg, dev);
-	if (!e) {
-		RT_TRACE(COMP_ERR, "Unable to initialize "
-		      "/proc/net/rtl8192/%s/ofdm-registers\n",
-		      dev->name);
-	}
-#endif
 }
 /****************************************************************************
    -----------------------------MISC STUFF-------------------------
@@ -1002,19 +854,6 @@ void rtl8192_tx_enable(struct net_device
     ieee80211_reset_queue(priv->ieee80211);
 }
 
-#if 0
-void rtl8192_beacon_tx_enable(struct net_device *dev)
-{
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	u32 reg;
-
-	reg = read_nic_dword(priv->ieee80211->dev,INTA_MASK);
-
-	/* enable Beacon realted interrupt signal */
-	reg |= (IMR_BcnInt | IMR_BcnInt | IMR_TBDOK | IMR_TBDER);
-	write_nic_byte(dev,reg);
-}
-#endif
 
 static void rtl8192_free_rx_ring(struct net_device *dev)
 {
@@ -1111,20 +950,6 @@ inline u16 rtl8192_rate2rate(short rate)
 
 
 
-#if 0
-void rtl8192_tx_queues_stop(struct net_device *dev)
-{
-	//struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	u8 dma_poll_mask = (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_HIPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_NORMPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_BEACON_SHIFT);
-
-	rtl8192_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,dma_poll_mask);
-	rtl8192_set_mode(dev,EPROM_CMD_NORMAL);
-}
-#endif
 
 static void rtl8192_data_hard_stop(struct net_device *dev)
 {
@@ -2378,13 +2203,6 @@ short rtl8192_is_tx_queue_empty(struct n
 	}
 	return 1;
 }
-#if 0
-void rtl8192_rq_tx_ack(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	priv->ieee80211->ack_tx_to_ieee = 1;
-}
-#endif
 static void rtl8192_hw_sleep_down(struct net_device *dev)
 {
 	RT_TRACE(COMP_POWER, "%s()============>come to sleep down\n", __FUNCTION__);
@@ -2857,13 +2675,6 @@ static void rtl8192_read_eeprom_info(str
 		// when auto load failed,  the last address byte set to be a random one.
 		// added by david woo.2007/11/7
 		memcpy(dev->dev_addr, bMac_Tmp_Addr, 6);
-		#if 0
-		for(i = 0; i < 6; i++)
-		{
-			Adapter->PermanentAddress[i] = sMacAddr[i];
-			PlatformEFIOWrite1Byte(Adapter, IDR0+i, sMacAddr[i]);
-		}
-		#endif
 	}
 
 	RT_TRACE(COMP_INIT, "Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
@@ -3883,23 +3694,6 @@ void rtl8192_prepare_beacon(struct r8192
 	//spin_unlock_irqrestore (&priv->tx_lock, flags);
 }
 
-#if 0
-void rtl8192_beacon_tx_enable(struct net_device *dev)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-#ifdef CONFIG_RTL8185B
-	priv->dma_poll_stop_mask &= ~(TPPOLLSTOP_BQ);MgntQuery_MgntFrameTxRateMgntQuery_MgntFrameTxRate
-	write_nic_byte(dev,TPPollStop, priv->dma_poll_mask);
-#else
-	priv->dma_poll_mask &=~(1<<TX_DMA_STOP_BEACON_SHIFT);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
-#endif
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-}
-#endif
-
 
 /* this configures registers for beacon tx and enables it via
  * rtl8192_beacon_tx_enable(). rtl8192_beacon_tx_disable() might
@@ -3955,14 +3749,6 @@ void rtl8192_start_beacon(struct net_dev
 /***************************************************************************
     -------------------------------NET STUFF---------------------------
 ***************************************************************************/
-#if 0
-static struct net_device_stats *rtl8192_stats(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-
-	return &priv->ieee80211->stats;
-}
-#endif
 
 
 
@@ -4064,13 +3850,6 @@ TxCheckStuck(struct net_device *dev)
 				continue;
 			}
 			txring->nStuckCount++;
-			#if 0
-			if(txring->nStuckCount > ResetThreshold)
-			{
-				RT_TRACE( COMP_RESET, "<== TxCheckStuck()\n" );
-				return RESET_TYPE_NORMAL;
-			}
-			#endif
 			bCheckFwTxCnt = TRUE;
 		}
 	}
@@ -4144,12 +3923,6 @@ static bool HalRxCheckStuck8190Pci(struc
 			//DbgPrint("RSSI <= %d, check this time \n", VeryLowRSSI);
 		}
 	}
-#if 0
-	if (rx_chk_cnt < 2)
-		return bStuck;
-	else
-		rx_chk_cnt = 0;
-#endif
 	if(priv->RxCounter==RegRxCounter)
 		bStuck = TRUE;
 
@@ -4506,10 +4279,6 @@ void InactivePsWorkItemCallback(struct n
 	//
 	// To solve CAM values miss in RF OFF, rewrite CAM values after RF ON. By Bruce, 2007-09-20.
 	//
-#if 0
-	if(pPSC->eInactivePowerState == eRfOn)
-		CamRestoreAllEntry(dev);
-#endif
 	pPSC->bSwRfProcessing = FALSE;
 	RT_TRACE(COMP_POWER, "InactivePsWorkItemCallback() <--------- \n");
 }
@@ -4868,11 +4637,6 @@ void rtl8192_commit(struct net_device *d
 	_rtl8192_up(dev);
 }
 
-/*
-void rtl8192_restart(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-*/
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8192_restart(struct work_struct *work)
 {
--- a/drivers/staging/rtl8192e/r8192E_dm.c
+++ b/drivers/staging/rtl8192e/r8192E_dm.c
@@ -95,9 +95,6 @@ extern	void	dm_rf_pathcheck_workitemcall
 extern	void	dm_rf_pathcheck_workitemcallback(struct net_device *dev);
 #endif
 extern	void dm_fsync_timer_callback(unsigned long data);
-#if 0
-extern	bool	dm_check_lbus_status(struct net_device *dev);
-#endif
 extern	void dm_check_fsync(struct net_device *dev);
 extern	void	dm_shadow_init(struct net_device *dev);
 extern	void dm_initialize_txpower_tracking(struct net_device *dev);
@@ -946,33 +943,6 @@ static void dm_TXPowerTrackingCallback_T
 		return;
 	}
 
-	//==========================
-	// this is only for test, should be masked
-#if 0
-{
-	//UINT32	eRFPath;
-	//UINT32	start_rf, end_rf;
-	UINT32	curr_addr;
-	//UINT32	reg_addr;
-	//UINT32	reg_addr_end;
-	UINT32	reg_value;
-	//start_rf 		= RF90_PATH_A;
-	//end_rf 			= RF90_PATH_B;//RF90_PATH_MAX;
-	//reg_addr 		= 0x0;
-	//reg_addr_end 	= 0x2F;
-
-		for (curr_addr = 0; curr_addr < 0x2d; curr_addr++)
-		{
-			reg_value = PHY_QueryRFReg(	Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A,
-										curr_addr, bMaskDWord);
-		}
-
-	pHalData->TXPowercount = 0;
-	return;
-}
-#endif
-	//==========================
-
 	// read and filter out unreasonable value
 	tmpRegA = rtl8192_phy_QueryRFReg(dev, RF90_PATH_A, 0x12, 0x078);	// 0x12: RF Reg[10:7]
 	RT_TRACE(COMP_POWER_TRACKING, "Readback ThermalMeterA = %d \n", tmpRegA);
@@ -1648,19 +1618,7 @@ static void dm_CheckTXPowerTracking_Ther
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	static u8 	TM_Trigger=0;
-#if 0
-	u1Byte					i;
-	u4Byte tmpRegA;
-	for(i=0; i<50; i++)
-	{
-		tmpRegA = PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x12, 0x078);	// 0x12: RF Reg[10:7]
-		PHY_SetRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);
-		//delay_us(100);
-		PHY_SetRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);
-		//delay_us(100);
-	}
-	DbgPrint("Trigger and readback ThermalMeter, write RF reg0x2 = 0x4d to 0x4f for 50 times\n");
-#else
+
 	//DbgPrint("dm_CheckTXPowerTracking() \n");
 	if(!priv->btxpower_tracking)
 		return;
@@ -1699,8 +1657,7 @@ static void dm_CheckTXPowerTracking_Ther
 			#endif
 		TM_Trigger = 0;
 		}
-#endif
-	}
+}
 #endif
 
 static void dm_check_txpower_tracking(struct net_device *dev)
@@ -1908,14 +1865,6 @@ void dm_restore_dynamic_mechanism_state(
 			//cosa PlatformEFIOWrite4Byte(Adapter, RATR0, ((pu4Byte)(val))[0]);
 			write_nic_dword(dev, RATR0, ratr_value);
 			write_nic_byte(dev, UFWP, 1);
-#if 0		// Disable old code.
-			u1Byte index;
-			u4Byte input_value;
-			index = (u1Byte)((((pu4Byte)(val))[0]) >> 28);
-			input_value = (((pu4Byte)(val))[0]) & 0x0fffffff;
-			// TODO: Correct it. Emily 2007.01.11
-			PlatformEFIOWrite4Byte(Adapter, RATR0+index*4, input_value);
-#endif
 	}
 	//Resore TX Power Tracking Index
 	if(priv->btxpower_trackingInit && priv->btxpower_tracking){
@@ -2895,78 +2844,6 @@ static void dm_ctstoself(struct net_devi
 }
 
 
-#if 0
-/*-----------------------------------------------------------------------------
- * Function:	dm_rf_operation_test_callback()
- *
- * Overview:	Only for RF operation test now.
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *	05/29/2008	amy		Create Version 0 porting from windows code.
- *
- *---------------------------------------------------------------------------*/
-void dm_rf_operation_test_callback(unsigned long dev)
-{
-//	struct r8192_priv *priv = ieee80211_priv((struct net_device *)dev);
-	u8 erfpath;
-
-
-	for(erfpath=0; erfpath<4; erfpath++)
-	{
-		//DbgPrint("Set RF-%d\n\r", eRFPath);
-		//PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x2c, bMask12Bits, 0x3d7);
-		udelay(100);
-	}
-
-	{
-		//PlatformSetPeriodicTimer(Adapter, &pHalData->RfTest1Timer, 500);
-	}
-
-	// For test
-	{
-		//u8 i;
-		//PlatformSetPeriodicTimer(Adapter, &pHalData->RfTest1Timer, 500);
-#if 0
-		for(i=0; i<50; i++)
-		{
-			// Write Test
-			PHY_SetRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);
-			//delay_us(100);
-			PHY_SetRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);
-			//delay_us(100);
-			PHY_SetRFReg(Adapter, RF90_PATH_C, 0x02, bMask12Bits, 0x4d);
-			//delay_us(100);
-			PHY_SetRFReg(Adapter, RF90_PATH_C, 0x02, bMask12Bits, 0x4f);
-			//delay_us(100);
-
-#if 0
-			// Read test
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x12, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x12, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x21, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x21, bMask12Bits);
-			//delay_us(100);
-#endif
-		}
-#endif
-	}
-
-}	/* DM_RfOperationTestCallBack */
-#endif
 
 /*-----------------------------------------------------------------------------
  * Function:	dm_check_rfctrl_gpio()
@@ -3889,50 +3766,6 @@ void dm_check_fsync(struct net_device *d
 	}
 }
 
-#if 0
-/*-----------------------------------------------------------------------------
- * Function:	DM_CheckLBusStatus()
- *
- * Overview:	For 9x series, we must make sure LBUS is active for IO.
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *	02/22/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-extern	s1Byte	DM_CheckLBusStatus(IN	PADAPTER	Adapter)
-{
-	PMGNT_INFO	pMgntInfo=&Adapter->MgntInfo;
-
-#if (HAL_CODE_BASE & RTL819X)
-
-#if (HAL_CODE_BASE == RTL8192)
-
-#if( DEV_BUS_TYPE==PCI_INTERFACE)
-	//return (pMgntInfo->bLbusEnable);	// For debug only
-	return TRUE;
-#endif
-
-#if( DEV_BUS_TYPE==USB_INTERFACE)
-	return TRUE;
-#endif
-
-#endif	// #if (HAL_CODE_BASE == RTL8192)
-
-#if (HAL_CODE_BASE == RTL8190)
-	return TRUE;
-#endif	// #if (HAL_CODE_BASE == RTL8190)
-
-#endif	// #if (HAL_CODE_BASE & RTL819X)
-}	/* DM_CheckLBusStatus */
-
-#endif
 
 /*-----------------------------------------------------------------------------
  * Function:	dm_shadow_init()
--- a/drivers/staging/rtl8192e/r8192E_wx.c
+++ b/drivers/staging/rtl8192e/r8192E_wx.c
@@ -43,40 +43,6 @@ static int r8192_wx_get_freq(struct net_
 }
 
 
-#if 0
-
-static int r8192_wx_set_beaconinterval(struct net_device *dev, struct iw_request_info *aa,
-			  union iwreq_data *wrqu, char *b)
-{
-	int *parms = (int *)b;
-	int bi = parms[0];
-
-	struct r8192_priv *priv = ieee80211_priv(dev);
-
-	down(&priv->wx_sem);
-	DMESG("setting beacon interval to %x",bi);
-
-	priv->ieee80211->beacon_interval=bi;
-	rtl8180_commit(dev);
-	up(&priv->wx_sem);
-
-	return 0;
-}
-
-
-static int r8192_wx_set_forceassociate(struct net_device *dev, struct iw_request_info *aa,
-			  union iwreq_data *wrqu, char *extra)
-{
-	struct r8192_priv *priv=ieee80211_priv(dev);
-	int *parms = (int *)extra;
-
-	priv->ieee80211->force_associate = (parms[0] > 0);
-
-
-	return 0;
-}
-
-#endif
 static int r8192_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
@@ -1037,17 +1003,6 @@ exit:
 }
 
 #if (WIRELESS_EXT >= 18)
-#if 0
-static int r8192_wx_get_enc_ext(struct net_device *dev,
-                                        struct iw_request_info *info,
-                                        union iwreq_data *wrqu, char *extra)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	int ret = 0;
-	ret = ieee80211_wx_get_encode_ext(priv->ieee80211, info, wrqu, extra);
-	return ret;
-}
-#endif
 static int r8192_wx_set_enc_ext(struct net_device *dev,
                                         struct iw_request_info *info,
                                         union iwreq_data *wrqu, char *extra)
--- a/drivers/staging/rtl8192e/r819xE_cmdpkt.c
+++ b/drivers/staging/rtl8192e/r819xE_cmdpkt.c
@@ -148,22 +148,6 @@ RT_STATUS cmpk_message_handle_tx(
             code_virtual_address += frag_length;
             frag_offset += frag_length;
 
-#if 0
-            {
-                int k;
-                printk("------------tx cmd------------\n");
-                for(k = 0; k<i; k++)
-                    printk(" 0x%x",((u8*)buf)[k]);
-                printk("\n");
-            }
-            {
-                int m;
-                printk("-------------cmd desc----------\n");
-                for(m=0;m<32;m++)
-                    printk(" 0x%x",((u8*)pdesc)[m]);
-                printk("\n");
-            }
-#endif
         }while(frag_offset < buffer_len);
 
 Failed:
--- a/drivers/staging/rtl8192e/r819xE_firmware.c
+++ b/drivers/staging/rtl8192e/r819xE_firmware.c
@@ -98,13 +98,6 @@ static bool fw_download_code(struct net_
 	}while(frag_offset < buffer_len);
 
 	return rt_status;
-
-#if 0
-cmdsend_downloadcode_fail:
-	rt_status = false;
-	RT_TRACE(COMP_ERR, "CmdSendDownloadCode fail !!\n");
-	return rt_status;
-#endif
 }
 
 //-----------------------------------------------------------------------------
@@ -406,215 +399,3 @@ download_firmware_fail:
 	return rt_status;
 
 }
-
-#if 0
-/*
- * Procedure:   (1)  Transform firmware code from little endian to big endian if required.
- *	        (2)  Number of bytes in Firmware downloading should be multiple
- *	   	     of 4 bytes. If length is not multiple of 4 bytes, appending of zeros is required
- *
- */
-void CmdAppendZeroAndEndianTransform(
-	u1Byte	*pDst,
-	u1Byte	*pSrc,
-	u2Byte   	*pLength)
-{
-
-	u2Byte	ulAppendBytes = 0, i;
-	u2Byte	ulLength = *pLength;
-
-//test only
-	//memset(pDst, 0xcc, 12);
-
-
-	/* Transform from little endian to big endian */
-//#if DEV_BUS_TYPE==PCI_INTERFACE
-#if 0
-	for( i=0 ; i<(*pLength) ; i+=4)
-	{
-		if((i+3) < (*pLength))	pDst[i+0] = pSrc[i+3];
-		if((i+2) < (*pLength))	pDst[i+1] = pSrc[i+2];
-		if((i+1) < (*pLength))	pDst[i+2] = pSrc[i+1];
-		if((i+0) < (*pLength))	pDst[i+3] = pSrc[i+0];
-	}
-#else
-	pDst += USB_HWDESC_HEADER_LEN;
-	ulLength -= USB_HWDESC_HEADER_LEN;
-
-	for( i=0 ; i<ulLength ; i+=4) {
-		if((i+3) < ulLength)	pDst[i+0] = pSrc[i+3];
-		if((i+2) < ulLength)	pDst[i+1] = pSrc[i+2];
-		if((i+1) < ulLength)	pDst[i+2] = pSrc[i+1];
-		if((i+0) < ulLength)	pDst[i+3] = pSrc[i+0];
-
-	}
-#endif
-
-	//1(2) Append Zero
-	if(  ((*pLength) % 4)  >0)
-	{
-		ulAppendBytes = 4-((*pLength) % 4);
-
-		for(i=0 ; i<ulAppendBytes; i++)
-			pDst[  4*((*pLength)/4)  + i ] = 0x0;
-
-		*pLength += ulAppendBytes;
-	}
-}
-#endif
-
-#if 0
-RT_STATUS
-CmdSendPacket(
-	PADAPTER				Adapter,
-	PRT_TCB					pTcb,
-	PRT_TX_LOCAL_BUFFER 			pBuf,
-	u4Byte					BufferLen,
-	u4Byte					PacketType,
-	BOOLEAN					bLastInitPacket
-	)
-{
-	s2Byte		i;
-	u1Byte		QueueID;
-	u2Byte		firstDesc,curDesc = 0;
-	u2Byte		FragIndex=0, FragBufferIndex=0;
-
-	RT_STATUS	rtStatus = RT_STATUS_SUCCESS;
-
-	CmdInitTCB(Adapter, pTcb, pBuf, BufferLen);
-
-
-	if(CmdCheckFragment(Adapter, pTcb, pBuf))
-		CmdFragmentTCB(Adapter, pTcb);
-	else
-		pTcb->FragLength[0] = (u2Byte)pTcb->BufferList[0].Length;
-
-	QueueID=pTcb->SpecifiedQueueID;
-#if DEV_BUS_TYPE!=USB_INTERFACE
-	firstDesc=curDesc=Adapter->NextTxDescToFill[QueueID];
-#endif
-
-#if DEV_BUS_TYPE!=USB_INTERFACE
-	if(VacancyTxDescNum(Adapter, QueueID) > pTcb->BufferCount)
-#else
-	if(PlatformIsTxQueueAvailable(Adapter, QueueID, pTcb->BufferCount) &&
-		RTIsListEmpty(&Adapter->TcbWaitQueue[QueueID]))
-#endif
-	{
-		pTcb->nDescUsed=0;
-
-		for(i=0 ; i<pTcb->BufferCount ; i++)
-		{
-			Adapter->HalFunc.TxFillCmdDescHandler(
-				Adapter,
-				pTcb,
-				QueueID,							//QueueIndex
-				curDesc,							//index
-				FragBufferIndex==0,						//bFirstSeg
-				FragBufferIndex==(pTcb->FragBufCount[FragIndex]-1),		//bLastSeg
-				pTcb->BufferList[i].VirtualAddress,				//VirtualAddress
-				pTcb->BufferList[i].PhysicalAddressLow,				//PhyAddressLow
-				pTcb->BufferList[i].Length,					//BufferLen
-				i!=0,								//bSetOwnBit
-				(i==(pTcb->BufferCount-1)) && bLastInitPacket,			//bLastInitPacket
-				PacketType,							//DescPacketType
-				pTcb->FragLength[FragIndex]					//PktLen
-				);
-
-			if(FragBufferIndex==(pTcb->FragBufCount[FragIndex]-1))
-			{ // Last segment of the fragment.
-				pTcb->nFragSent++;
-			}
-
-			FragBufferIndex++;
-			if(FragBufferIndex==pTcb->FragBufCount[FragIndex])
-			{
-				FragIndex++;
-				FragBufferIndex=0;
-			}
-
-#if DEV_BUS_TYPE!=USB_INTERFACE
-			curDesc=(curDesc+1)%Adapter->NumTxDesc[QueueID];
-#endif
-			pTcb->nDescUsed++;
-		}
-
-#if DEV_BUS_TYPE!=USB_INTERFACE
-		RTInsertTailList(&Adapter->TcbBusyQueue[QueueID], &pTcb->List);
-		IncrementTxDescToFill(Adapter, QueueID, pTcb->nDescUsed);
-		Adapter->HalFunc.SetTxDescOWNHandler(Adapter, QueueID, firstDesc);
-		// TODO: should call poll use QueueID
-		Adapter->HalFunc.TxPollingHandler(Adapter, TXCMD_QUEUE);
-#endif
-	}
-	else
-#if DEV_BUS_TYPE!=USB_INTERFACE
-		goto CmdSendPacket_Fail;
-#else
-	{
-		pTcb->bLastInitPacket = bLastInitPacket;
-		RTInsertTailList(&Adapter->TcbWaitQueue[pTcb->SpecifiedQueueID], &pTcb->List);
-	}
-#endif
-
-	return rtStatus;
-
-#if DEV_BUS_TYPE!=USB_INTERFACE
-CmdSendPacket_Fail:
-	rtStatus = RT_STATUS_FAILURE;
-	return rtStatus;
-#endif
-
-}
-#endif
-
-
-
-
-#if 0
-RT_STATUS
-FWSendNullPacket(
-	IN	PADAPTER		Adapter,
-	IN	u4Byte			Length
-)
-{
-	RT_STATUS	rtStatus = RT_STATUS_SUCCESS;
-
-
-	PRT_TCB					pTcb;
-	PRT_TX_LOCAL_BUFFER 	pBuf;
-	BOOLEAN					bLastInitPacket = FALSE;
-
-	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
-
-#if DEV_BUS_TYPE==USB_INTERFACE
-	Length += USB_HWDESC_HEADER_LEN;
-#endif
-
-	//Get TCB and local buffer from common pool. (It is shared by CmdQ, MgntQ, and USB coalesce DataQ)
-	if(MgntGetBuffer(Adapter, &pTcb, &pBuf))
-	{
-		PlatformZeroMemory(pBuf->Buffer.VirtualAddress, Length);
-		rtStatus = CmdSendPacket(Adapter, pTcb, pBuf, Length, DESC_PACKET_TYPE_INIT, bLastInitPacket);	//0 : always set LastInitPacket to zero
-//#if HAL_CODE_BASE != RTL8190HW
-//		// TODO: for test only
-//		ReturnTCB(Adapter, pTcb, RT_STATUS_SUCCESS);
-//#endif
-		if(rtStatus == RT_STATUS_FAILURE)
-			goto CmdSendNullPacket_Fail;
-	}else
-		goto CmdSendNullPacket_Fail;
-
-	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
-	return rtStatus;
-
-
-CmdSendNullPacket_Fail:
-	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
-	rtStatus = RT_STATUS_FAILURE;
-	RT_ASSERT(rtStatus == RT_STATUS_SUCCESS, ("CmdSendDownloadCode fail !!\n"));
-	return rtStatus;
-}
-#endif
-
-
