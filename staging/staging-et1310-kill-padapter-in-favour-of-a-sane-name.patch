From alan@linux.intel.com  Thu Aug 20 14:38:49 2009
From: Alan Cox <alan@linux.intel.com>
Date: Wed, 19 Aug 2009 18:21:44 +0100
Subject: Staging: et1310: kill pAdapter in favour of a sane name
To: greg@kroah.com, linux-kernel@vger.kernel.org
Message-ID: <20090819172144.21152.84146.stgit@localhost.localdomain>


Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_eeprom.c  |   14 -
 drivers/staging/et131x/et1310_jagcore.c |   20 -
 drivers/staging/et131x/et1310_mac.c     |  218 +++++++--------
 drivers/staging/et131x/et1310_phy.c     |  370 +++++++++++++-------------
 drivers/staging/et131x/et1310_pm.c      |   46 +--
 drivers/staging/et131x/et1310_rx.c      |  202 +++++++-------
 drivers/staging/et131x/et1310_tx.c      |  442 ++++++++++++++++----------------
 drivers/staging/et131x/et131x_config.c  |   88 +++---
 drivers/staging/et131x/et131x_debug.c   |   20 -
 drivers/staging/et131x/et131x_initpci.c |   82 ++---
 drivers/staging/et131x/et131x_isr.c     |   44 +--
 drivers/staging/et131x/et131x_netdev.c  |   38 +-
 12 files changed, 792 insertions(+), 792 deletions(-)


--- a/drivers/staging/et131x/et1310_eeprom.c
+++ b/drivers/staging/et131x/et1310_eeprom.c
@@ -143,7 +143,7 @@
 
 /**
  * EepromWriteByte - Write a byte to the ET1310's EEPROM
- * @pAdapter: pointer to our private adapter structure
+ * @etdev: pointer to our private adapter structure
  * @unAddress: the address to write
  * @bData: the value to write
  * @unEepronId: the ID of the EEPROM
@@ -151,11 +151,11 @@
  *
  * Returns SUCCESS or FAILURE
  */
-int32_t EepromWriteByte(struct et131x_adapter *pAdapter, uint32_t unAddress,
+int32_t EepromWriteByte(struct et131x_adapter *etdev, uint32_t unAddress,
 			uint8_t bData, uint32_t unEepromId,
 			uint32_t unAddressingMode)
 {
-	struct pci_dev *pdev = pAdapter->pdev;
+	struct pci_dev *pdev = etdev->pdev;
 	int32_t nIndex;
 	int32_t nRetries;
 	int32_t nError = false;
@@ -292,7 +292,7 @@ int32_t EepromWriteByte(struct et131x_ad
 		 *	   so we do a blind write for load bug.
 		 */
 		if (bStatus & LBCIF_STATUS_GENERAL_ERROR
-		    && pAdapter->RevisionID == 0) {
+		    && etdev->RevisionID == 0) {
 			break;
 		}
 
@@ -349,7 +349,7 @@ int32_t EepromWriteByte(struct et131x_ad
 
 /**
  * EepromReadByte - Read a byte from the ET1310's EEPROM
- * @pAdapter: pointer to our private adapter structure
+ * @etdev: pointer to our private adapter structure
  * @unAddress: the address from which to read
  * @pbData: a pointer to a byte in which to store the value of the read
  * @unEepronId: the ID of the EEPROM
@@ -357,11 +357,11 @@ int32_t EepromWriteByte(struct et131x_ad
  *
  * Returns SUCCESS or FAILURE
  */
-int32_t EepromReadByte(struct et131x_adapter *pAdapter, uint32_t unAddress,
+int32_t EepromReadByte(struct et131x_adapter *etdev, uint32_t unAddress,
 		       uint8_t *pbData, uint32_t unEepromId,
 		       uint32_t unAddressingMode)
 {
-	struct pci_dev *pdev = pAdapter->pdev;
+	struct pci_dev *pdev = etdev->pdev;
 	int32_t nIndex;
 	int32_t nError = 0;
 	uint8_t bControl;
--- a/drivers/staging/et131x/et1310_jagcore.c
+++ b/drivers/staging/et131x/et1310_jagcore.c
@@ -99,27 +99,27 @@ extern dbg_info_t *et131x_dbginfo;
  * ConfigGlobalRegs - Used to configure the global registers on the JAGCore
  * @pAdpater: pointer to our adapter structure
  */
-void ConfigGlobalRegs(struct et131x_adapter *pAdapter)
+void ConfigGlobalRegs(struct et131x_adapter *etdev)
 {
-	struct _GLOBAL_t __iomem *pGbl = &pAdapter->CSRAddress->global;
+	struct _GLOBAL_t __iomem *pGbl = &etdev->CSRAddress->global;
 
 	DBG_ENTER(et131x_dbginfo);
 
-	if (pAdapter->RegistryPhyLoopbk == false) {
-		if (pAdapter->RegistryJumboPacket < 2048) {
+	if (etdev->RegistryPhyLoopbk == false) {
+		if (etdev->RegistryJumboPacket < 2048) {
 			/* Tx / RxDMA and Tx/Rx MAC interfaces have a 1k word
 			 * block of RAM that the driver can split between Tx
 			 * and Rx as it desires.  Our default is to split it
 			 * 50/50:
 			 */
 			writel(0, &pGbl->rxq_start_addr.value);
-			writel(pAdapter->RegistryRxMemEnd,
+			writel(etdev->RegistryRxMemEnd,
 			       &pGbl->rxq_end_addr.value);
-			writel(pAdapter->RegistryRxMemEnd + 1,
+			writel(etdev->RegistryRxMemEnd + 1,
 			       &pGbl->txq_start_addr.value);
 			writel(INTERNAL_MEM_SIZE - 1,
 			       &pGbl->txq_end_addr.value);
-		} else if (pAdapter->RegistryJumboPacket < 8192) {
+		} else if (etdev->RegistryJumboPacket < 8192) {
 			/* For jumbo packets > 2k but < 8k, split 50-50. */
 			writel(0, &pGbl->rxq_start_addr.value);
 			writel(INTERNAL_MEM_RX_OFFSET,
@@ -171,9 +171,9 @@ void ConfigGlobalRegs(struct et131x_adap
 
 /**
  * ConfigMMCRegs - Used to configure the main memory registers in the JAGCore
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  */
-void ConfigMMCRegs(struct et131x_adapter *pAdapter)
+void ConfigMMCRegs(struct et131x_adapter *etdev)
 {
 	MMC_CTRL_t mmc_ctrl = { 0 };
 
@@ -188,7 +188,7 @@ void ConfigMMCRegs(struct et131x_adapter
 	mmc_ctrl.bits.arb_disable = 0x0;
 	mmc_ctrl.bits.mmc_enable = 0x1;
 
-	writel(mmc_ctrl.value, &pAdapter->CSRAddress->mmc.mmc_ctrl.value);
+	writel(mmc_ctrl.value, &etdev->CSRAddress->mmc.mmc_ctrl.value);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -101,9 +101,9 @@ extern dbg_info_t *et131x_dbginfo;
  * ConfigMacRegs1 - Initialize the first part of MAC regs
  * @pAdpater: pointer to our adapter structure
  */
-void ConfigMACRegs1(struct et131x_adapter *pAdapter)
+void ConfigMACRegs1(struct et131x_adapter *etdev)
 {
-	struct _MAC_t __iomem *pMac = &pAdapter->CSRAddress->mac;
+	struct _MAC_t __iomem *pMac = &etdev->CSRAddress->mac;
 	MAC_STATION_ADDR1_t station1;
 	MAC_STATION_ADDR2_t station2;
 	MAC_IPG_t ipg;
@@ -151,12 +151,12 @@ void ConfigMACRegs1(struct et131x_adapte
 	 * station address is used for generating and checking pause control
 	 * packets.
 	 */
-	station2.bits.Octet1 = pAdapter->CurrentAddress[0];
-	station2.bits.Octet2 = pAdapter->CurrentAddress[1];
-	station1.bits.Octet3 = pAdapter->CurrentAddress[2];
-	station1.bits.Octet4 = pAdapter->CurrentAddress[3];
-	station1.bits.Octet5 = pAdapter->CurrentAddress[4];
-	station1.bits.Octet6 = pAdapter->CurrentAddress[5];
+	station2.bits.Octet1 = etdev->CurrentAddress[0];
+	station2.bits.Octet2 = etdev->CurrentAddress[1];
+	station1.bits.Octet3 = etdev->CurrentAddress[2];
+	station1.bits.Octet4 = etdev->CurrentAddress[3];
+	station1.bits.Octet5 = etdev->CurrentAddress[4];
+	station1.bits.Octet6 = etdev->CurrentAddress[5];
 	writel(station1.value, &pMac->station_addr_1.value);
 	writel(station2.value, &pMac->station_addr_2.value);
 
@@ -167,7 +167,7 @@ void ConfigMACRegs1(struct et131x_adapte
 	 * Packets larger than (RegistryJumboPacket) that do not contain a
 	 * VLAN ID will be dropped by the Rx function.
 	 */
-	writel(pAdapter->RegistryJumboPacket + 4, &pMac->max_fm_len.value);
+	writel(etdev->RegistryJumboPacket + 4, &pMac->max_fm_len.value);
 
 	/* clear out MAC config reset */
 	writel(0, &pMac->cfg1.value);
@@ -179,10 +179,10 @@ void ConfigMACRegs1(struct et131x_adapte
  * ConfigMacRegs2 - Initialize the second part of MAC regs
  * @pAdpater: pointer to our adapter structure
  */
-void ConfigMACRegs2(struct et131x_adapter *pAdapter)
+void ConfigMACRegs2(struct et131x_adapter *etdev)
 {
 	int32_t delay = 0;
-	struct _MAC_t __iomem *pMac = &pAdapter->CSRAddress->mac;
+	struct _MAC_t __iomem *pMac = &etdev->CSRAddress->mac;
 	MAC_CFG1_t cfg1;
 	MAC_CFG2_t cfg2;
 	MAC_IF_CTRL_t ifctrl;
@@ -190,12 +190,12 @@ void ConfigMACRegs2(struct et131x_adapte
 
 	DBG_ENTER(et131x_dbginfo);
 
-	ctl.value = readl(&pAdapter->CSRAddress->txmac.ctl.value);
+	ctl.value = readl(&etdev->CSRAddress->txmac.ctl.value);
 	cfg1.value = readl(&pMac->cfg1.value);
 	cfg2.value = readl(&pMac->cfg2.value);
 	ifctrl.value = readl(&pMac->if_ctrl.value);
 
-	if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
 		cfg2.bits.if_mode = 0x2;
 		ifctrl.bits.phy_mode = 0x0;
 	} else {
@@ -210,8 +210,8 @@ void ConfigMACRegs2(struct et131x_adapte
 	/* Set up flow control */
 	cfg1.bits.tx_flow = 0x1;
 
-	if ((pAdapter->FlowControl == RxOnly) ||
-	    (pAdapter->FlowControl == Both)) {
+	if ((etdev->FlowControl == RxOnly) ||
+	    (etdev->FlowControl == Both)) {
 		cfg1.bits.rx_flow = 0x1;
 	} else {
 		cfg1.bits.rx_flow = 0x0;
@@ -232,7 +232,7 @@ void ConfigMACRegs2(struct et131x_adapte
 	 */
 	cfg2.bits.len_check = 0x1;
 
-	if (pAdapter->RegistryPhyLoopbk == false) {
+	if (etdev->RegistryPhyLoopbk == false) {
 		cfg2.bits.pad_crc = 0x1;
 		cfg2.bits.crc_enable = 0x1;
 	} else {
@@ -241,8 +241,8 @@ void ConfigMACRegs2(struct et131x_adapte
 	}
 
 	/* 1 - full duplex, 0 - half-duplex */
-	cfg2.bits.full_duplex = pAdapter->uiDuplexMode;
-	ifctrl.bits.ghd_mode = !pAdapter->uiDuplexMode;
+	cfg2.bits.full_duplex = etdev->uiDuplexMode;
+	ifctrl.bits.ghd_mode = !etdev->uiDuplexMode;
 
 	writel(ifctrl.value, &pMac->if_ctrl.value);
 	writel(cfg2.value, &pMac->cfg2.value);
@@ -262,19 +262,19 @@ void ConfigMACRegs2(struct et131x_adapte
 
 	DBG_TRACE(et131x_dbginfo,
 		"Speed %d, Dup %d, CFG1 0x%08x, CFG2 0x%08x, if_ctrl 0x%08x\n",
-		pAdapter->uiLinkSpeed, pAdapter->uiDuplexMode,
+		etdev->uiLinkSpeed, etdev->uiDuplexMode,
 		readl(&pMac->cfg1.value), readl(&pMac->cfg2.value),
 		readl(&pMac->if_ctrl.value));
 
 	/* Enable TXMAC */
 	ctl.bits.txmac_en = 0x1;
 	ctl.bits.fc_disable = 0x1;
-	writel(ctl.value, &pAdapter->CSRAddress->txmac.ctl.value);
+	writel(ctl.value, &etdev->CSRAddress->txmac.ctl.value);
 
 	/* Ready to start the RXDMA/TXDMA engine */
-	if (!MP_TEST_FLAG(pAdapter, fMP_ADAPTER_LOWER_POWER)) {
-		et131x_rx_dma_enable(pAdapter);
-		et131x_tx_dma_enable(pAdapter);
+	if (!MP_TEST_FLAG(etdev, fMP_ADAPTER_LOWER_POWER)) {
+		et131x_rx_dma_enable(etdev);
+		et131x_tx_dma_enable(etdev);
 	} else {
 		DBG_WARNING(et131x_dbginfo,
 			    "Didn't enable Rx/Tx due to low-power mode\n");
@@ -283,9 +283,9 @@ void ConfigMACRegs2(struct et131x_adapte
 	DBG_LEAVE(et131x_dbginfo);
 }
 
-void ConfigRxMacRegs(struct et131x_adapter *pAdapter)
+void ConfigRxMacRegs(struct et131x_adapter *etdev)
 {
-	struct _RXMAC_t __iomem *pRxMac = &pAdapter->CSRAddress->rxmac;
+	struct _RXMAC_t __iomem *pRxMac = &etdev->CSRAddress->rxmac;
 	RXMAC_WOL_SA_LO_t sa_lo;
 	RXMAC_WOL_SA_HI_t sa_hi;
 	RXMAC_PF_CTRL_t pf_ctrl = { 0 };
@@ -330,22 +330,22 @@ void ConfigRxMacRegs(struct et131x_adapt
 	writel(0, &pRxMac->mask4_word3);
 
 	/* Lets setup the WOL Source Address */
-	sa_lo.bits.sa3 = pAdapter->CurrentAddress[2];
-	sa_lo.bits.sa4 = pAdapter->CurrentAddress[3];
-	sa_lo.bits.sa5 = pAdapter->CurrentAddress[4];
-	sa_lo.bits.sa6 = pAdapter->CurrentAddress[5];
+	sa_lo.bits.sa3 = etdev->CurrentAddress[2];
+	sa_lo.bits.sa4 = etdev->CurrentAddress[3];
+	sa_lo.bits.sa5 = etdev->CurrentAddress[4];
+	sa_lo.bits.sa6 = etdev->CurrentAddress[5];
 	writel(sa_lo.value, &pRxMac->sa_lo.value);
 
-	sa_hi.bits.sa1 = pAdapter->CurrentAddress[0];
-	sa_hi.bits.sa2 = pAdapter->CurrentAddress[1];
+	sa_hi.bits.sa1 = etdev->CurrentAddress[0];
+	sa_hi.bits.sa2 = etdev->CurrentAddress[1];
 	writel(sa_hi.value, &pRxMac->sa_hi.value);
 
 	/* Disable all Packet Filtering */
 	writel(0, &pRxMac->pf_ctrl.value);
 
 	/* Let's initialize the Unicast Packet filtering address */
-	if (pAdapter->PacketFilter & ET131X_PACKET_TYPE_DIRECTED) {
-		SetupDeviceForUnicast(pAdapter);
+	if (etdev->PacketFilter & ET131X_PACKET_TYPE_DIRECTED) {
+		SetupDeviceForUnicast(etdev);
 		pf_ctrl.bits.filter_uni_en = 1;
 	} else {
 		writel(0, &pRxMac->uni_pf_addr1.value);
@@ -354,18 +354,18 @@ void ConfigRxMacRegs(struct et131x_adapt
 	}
 
 	/* Let's initialize the Multicast hash */
-	if (pAdapter->PacketFilter & ET131X_PACKET_TYPE_ALL_MULTICAST) {
+	if (etdev->PacketFilter & ET131X_PACKET_TYPE_ALL_MULTICAST) {
 		pf_ctrl.bits.filter_multi_en = 0;
 	} else {
 		pf_ctrl.bits.filter_multi_en = 1;
-		SetupDeviceForMulticast(pAdapter);
+		SetupDeviceForMulticast(etdev);
 	}
 
 	/* Runt packet filtering.  Didn't work in version A silicon. */
 	pf_ctrl.bits.min_pkt_size = NIC_MIN_PACKET_SIZE + 4;
 	pf_ctrl.bits.filter_frag_en = 1;
 
-	if (pAdapter->RegistryJumboPacket > 8192) {
+	if (etdev->RegistryJumboPacket > 8192) {
 		RXMAC_MCIF_CTRL_MAX_SEG_t mcif_ctrl_max_seg;
 
 		/* In order to transmit jumbo packets greater than 8k, the
@@ -408,7 +408,7 @@ void ConfigRxMacRegs(struct et131x_adapt
 	 * bit 16: Receive frame truncated.
 	 * bit 17: Drop packet enable
 	 */
-	if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_100MBPS)
+	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_100MBPS)
 		writel(0x30038, &pRxMac->mif_ctrl.value);
 	else
 		writel(0x30030, &pRxMac->mif_ctrl.value);
@@ -425,9 +425,9 @@ void ConfigRxMacRegs(struct et131x_adapt
 	DBG_LEAVE(et131x_dbginfo);
 }
 
-void ConfigTxMacRegs(struct et131x_adapter *pAdapter)
+void ConfigTxMacRegs(struct et131x_adapter *etdev)
 {
-	struct _TXMAC_t __iomem *pTxMac = &pAdapter->CSRAddress->txmac;
+	struct _TXMAC_t __iomem *pTxMac = &etdev->CSRAddress->txmac;
 	TXMAC_CF_PARAM_t Local;
 
 	DBG_ENTER(et131x_dbginfo);
@@ -436,7 +436,7 @@ void ConfigTxMacRegs(struct et131x_adapt
 	 * cfpt - control frame pause timer set to 64 (0x40)
 	 * cfep - control frame extended pause timer set to 0x0
 	 */
-	if (pAdapter->FlowControl == None) {
+	if (etdev->FlowControl == None) {
 		writel(0, &pTxMac->cf_param.value);
 	} else {
 		Local.bits.cfpt = 0x40;
@@ -447,10 +447,10 @@ void ConfigTxMacRegs(struct et131x_adapt
 	DBG_LEAVE(et131x_dbginfo);
 }
 
-void ConfigMacStatRegs(struct et131x_adapter *pAdapter)
+void ConfigMacStatRegs(struct et131x_adapter *etdev)
 {
 	struct _MAC_STAT_t __iomem *pDevMacStat =
-		&pAdapter->CSRAddress->macStat;
+		&etdev->CSRAddress->macStat;
 
 	DBG_ENTER(et131x_dbginfo);
 
@@ -538,50 +538,50 @@ void ConfigMacStatRegs(struct et131x_ada
 	DBG_LEAVE(et131x_dbginfo);
 }
 
-void ConfigFlowControl(struct et131x_adapter *pAdapter)
+void ConfigFlowControl(struct et131x_adapter *etdev)
 {
-	if (pAdapter->uiDuplexMode == 0) {
-		pAdapter->FlowControl = None;
+	if (etdev->uiDuplexMode == 0) {
+		etdev->FlowControl = None;
 	} else {
 		char RemotePause, RemoteAsyncPause;
 
-		ET1310_PhyAccessMiBit(pAdapter,
+		ET1310_PhyAccessMiBit(etdev,
 				      TRUEPHY_BIT_READ, 5, 10, &RemotePause);
-		ET1310_PhyAccessMiBit(pAdapter,
+		ET1310_PhyAccessMiBit(etdev,
 				      TRUEPHY_BIT_READ, 5, 11,
 				      &RemoteAsyncPause);
 
 		if ((RemotePause == TRUEPHY_BIT_SET) &&
 		    (RemoteAsyncPause == TRUEPHY_BIT_SET)) {
-			pAdapter->FlowControl = pAdapter->RegistryFlowControl;
+			etdev->FlowControl = etdev->RegistryFlowControl;
 		} else if ((RemotePause == TRUEPHY_BIT_SET) &&
 			   (RemoteAsyncPause == TRUEPHY_BIT_CLEAR)) {
-			if (pAdapter->RegistryFlowControl == Both)
-				pAdapter->FlowControl = Both;
+			if (etdev->RegistryFlowControl == Both)
+				etdev->FlowControl = Both;
 			else
-				pAdapter->FlowControl = None;
+				etdev->FlowControl = None;
 		} else if ((RemotePause == TRUEPHY_BIT_CLEAR) &&
 			   (RemoteAsyncPause == TRUEPHY_BIT_CLEAR)) {
-			pAdapter->FlowControl = None;
+			etdev->FlowControl = None;
 		} else {/* if (RemotePause == TRUEPHY_CLEAR_BIT &&
 			       RemoteAsyncPause == TRUEPHY_SET_BIT) */
-			if (pAdapter->RegistryFlowControl == Both)
-				pAdapter->FlowControl = RxOnly;
+			if (etdev->RegistryFlowControl == Both)
+				etdev->FlowControl = RxOnly;
 			else
-				pAdapter->FlowControl = None;
+				etdev->FlowControl = None;
 		}
 	}
 }
 
 /**
  * UpdateMacStatHostCounters - Update the local copy of the statistics
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  */
-void UpdateMacStatHostCounters(struct et131x_adapter *pAdapter)
+void UpdateMacStatHostCounters(struct et131x_adapter *etdev)
 {
-	struct _ce_stats_t *stats = &pAdapter->Stats;
+	struct _ce_stats_t *stats = &etdev->Stats;
 	struct _MAC_STAT_t __iomem *pDevMacStat =
-		&pAdapter->CSRAddress->macStat;
+		&etdev->CSRAddress->macStat;
 
 	stats->collisions += readl(&pDevMacStat->TNcl);
 	stats->first_collision += readl(&pDevMacStat->TScl);
@@ -603,13 +603,13 @@ void UpdateMacStatHostCounters(struct et
 
 /**
  * HandleMacStatInterrupt
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  *
  * One of the MACSTAT counters has wrapped.  Update the local copy of
  * the statistics held in the adapter structure, checking the "wrap"
  * bit for each counter.
  */
-void HandleMacStatInterrupt(struct et131x_adapter *pAdapter)
+void HandleMacStatInterrupt(struct et131x_adapter *etdev)
 {
 	MAC_STAT_REG_1_t Carry1;
 	MAC_STAT_REG_2_t Carry2;
@@ -619,11 +619,11 @@ void HandleMacStatInterrupt(struct et131
 	/* Read the interrupt bits from the register(s).  These are Clear On
 	 * Write.
 	 */
-	Carry1.value = readl(&pAdapter->CSRAddress->macStat.Carry1.value);
-	Carry2.value = readl(&pAdapter->CSRAddress->macStat.Carry2.value);
+	Carry1.value = readl(&etdev->CSRAddress->macStat.Carry1.value);
+	Carry2.value = readl(&etdev->CSRAddress->macStat.Carry2.value);
 
-	writel(Carry1.value, &pAdapter->CSRAddress->macStat.Carry1.value);
-	writel(Carry2.value, &pAdapter->CSRAddress->macStat.Carry2.value);
+	writel(Carry1.value, &etdev->CSRAddress->macStat.Carry1.value);
+	writel(Carry2.value, &etdev->CSRAddress->macStat.Carry2.value);
 
 	/* We need to do update the host copy of all the MAC_STAT counters.
 	 * For each counter, check it's overflow bit.  If the overflow bit is
@@ -632,40 +632,40 @@ void HandleMacStatInterrupt(struct et131
 	 * block indicates that one of the counters has wrapped.
 	 */
 	if (Carry1.bits.rfcs)
-		pAdapter->Stats.code_violations += COUNTER_WRAP_16_BIT;
+		etdev->Stats.code_violations += COUNTER_WRAP_16_BIT;
 	if (Carry1.bits.raln)
-		pAdapter->Stats.alignment_err += COUNTER_WRAP_12_BIT;
+		etdev->Stats.alignment_err += COUNTER_WRAP_12_BIT;
 	if (Carry1.bits.rflr)
-		pAdapter->Stats.length_err += COUNTER_WRAP_16_BIT;
+		etdev->Stats.length_err += COUNTER_WRAP_16_BIT;
 	if (Carry1.bits.rfrg)
-		pAdapter->Stats.other_errors += COUNTER_WRAP_16_BIT;
+		etdev->Stats.other_errors += COUNTER_WRAP_16_BIT;
 	if (Carry1.bits.rcde)
-		pAdapter->Stats.crc_err += COUNTER_WRAP_16_BIT;
+		etdev->Stats.crc_err += COUNTER_WRAP_16_BIT;
 	if (Carry1.bits.rovr)
-		pAdapter->Stats.rx_ov_flow += COUNTER_WRAP_16_BIT;
+		etdev->Stats.rx_ov_flow += COUNTER_WRAP_16_BIT;
 	if (Carry1.bits.rdrp)
-		pAdapter->Stats.norcvbuf += COUNTER_WRAP_16_BIT;
+		etdev->Stats.norcvbuf += COUNTER_WRAP_16_BIT;
 	if (Carry2.bits.tovr)
-		pAdapter->Stats.max_pkt_error += COUNTER_WRAP_12_BIT;
+		etdev->Stats.max_pkt_error += COUNTER_WRAP_12_BIT;
 	if (Carry2.bits.tund)
-		pAdapter->Stats.tx_uflo += COUNTER_WRAP_12_BIT;
+		etdev->Stats.tx_uflo += COUNTER_WRAP_12_BIT;
 	if (Carry2.bits.tscl)
-		pAdapter->Stats.first_collision += COUNTER_WRAP_12_BIT;
+		etdev->Stats.first_collision += COUNTER_WRAP_12_BIT;
 	if (Carry2.bits.tdfr)
-		pAdapter->Stats.tx_deferred += COUNTER_WRAP_12_BIT;
+		etdev->Stats.tx_deferred += COUNTER_WRAP_12_BIT;
 	if (Carry2.bits.tmcl)
-		pAdapter->Stats.excessive_collisions += COUNTER_WRAP_12_BIT;
+		etdev->Stats.excessive_collisions += COUNTER_WRAP_12_BIT;
 	if (Carry2.bits.tlcl)
-		pAdapter->Stats.late_collisions += COUNTER_WRAP_12_BIT;
+		etdev->Stats.late_collisions += COUNTER_WRAP_12_BIT;
 	if (Carry2.bits.tncl)
-		pAdapter->Stats.collisions += COUNTER_WRAP_12_BIT;
+		etdev->Stats.collisions += COUNTER_WRAP_12_BIT;
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
-void SetupDeviceForMulticast(struct et131x_adapter *pAdapter)
+void SetupDeviceForMulticast(struct et131x_adapter *etdev)
 {
-	struct _RXMAC_t __iomem *rxmac = &pAdapter->CSRAddress->rxmac;
+	struct _RXMAC_t __iomem *rxmac = &etdev->CSRAddress->rxmac;
 	uint32_t nIndex;
 	uint32_t result;
 	uint32_t hash1 = 0;
@@ -681,24 +681,24 @@ void SetupDeviceForMulticast(struct et13
 	 * specified) then we should pass NO multi-cast addresses to the
 	 * driver.
 	 */
-	if (pAdapter->PacketFilter & ET131X_PACKET_TYPE_MULTICAST) {
+	if (etdev->PacketFilter & ET131X_PACKET_TYPE_MULTICAST) {
 		DBG_VERBOSE(et131x_dbginfo,
 			    "MULTICAST flag is set, MCCount: %d\n",
-			    pAdapter->MCAddressCount);
+			    etdev->MCAddressCount);
 
 		/* Loop through our multicast array and set up the device */
-		for (nIndex = 0; nIndex < pAdapter->MCAddressCount; nIndex++) {
+		for (nIndex = 0; nIndex < etdev->MCAddressCount; nIndex++) {
 			DBG_VERBOSE(et131x_dbginfo,
 			    "MCList[%d]: %02x:%02x:%02x:%02x:%02x:%02x\n",
 			    nIndex,
-			    pAdapter->MCList[nIndex][0],
-			    pAdapter->MCList[nIndex][1],
-			    pAdapter->MCList[nIndex][2],
-			    pAdapter->MCList[nIndex][3],
-			    pAdapter->MCList[nIndex][4],
-			    pAdapter->MCList[nIndex][5]);
+			    etdev->MCList[nIndex][0],
+			    etdev->MCList[nIndex][1],
+			    etdev->MCList[nIndex][2],
+			    etdev->MCList[nIndex][3],
+			    etdev->MCList[nIndex][4],
+			    etdev->MCList[nIndex][5]);
 
-			result = ether_crc(6, pAdapter->MCList[nIndex]);
+			result = ether_crc(6, etdev->MCList[nIndex]);
 
 			result = (result & 0x3F800000) >> 23;
 
@@ -718,7 +718,7 @@ void SetupDeviceForMulticast(struct et13
 	}
 
 	/* Write out the new hash to the device */
-	pm_csr.value = readl(&pAdapter->CSRAddress->global.pm_csr.value);
+	pm_csr.value = readl(&etdev->CSRAddress->global.pm_csr.value);
 	if (pm_csr.bits.pm_phy_sw_coma == 0) {
 		writel(hash1, &rxmac->multi_hash1);
 		writel(hash2, &rxmac->multi_hash2);
@@ -729,9 +729,9 @@ void SetupDeviceForMulticast(struct et13
 	DBG_LEAVE(et131x_dbginfo);
 }
 
-void SetupDeviceForUnicast(struct et131x_adapter *pAdapter)
+void SetupDeviceForUnicast(struct et131x_adapter *etdev)
 {
-	struct _RXMAC_t __iomem *rxmac = &pAdapter->CSRAddress->rxmac;
+	struct _RXMAC_t __iomem *rxmac = &etdev->CSRAddress->rxmac;
 	RXMAC_UNI_PF_ADDR1_t uni_pf1;
 	RXMAC_UNI_PF_ADDR2_t uni_pf2;
 	RXMAC_UNI_PF_ADDR3_t uni_pf3;
@@ -748,22 +748,22 @@ void SetupDeviceForUnicast(struct et131x
 	 * Set up unicast packet filter reg 3 to be the octets 2 - 5 of the
 	 * MAC address for first address
 	 */
-	uni_pf3.bits.addr1_1 = pAdapter->CurrentAddress[0];
-	uni_pf3.bits.addr1_2 = pAdapter->CurrentAddress[1];
-	uni_pf3.bits.addr2_1 = pAdapter->CurrentAddress[0];
-	uni_pf3.bits.addr2_2 = pAdapter->CurrentAddress[1];
-
-	uni_pf2.bits.addr2_3 = pAdapter->CurrentAddress[2];
-	uni_pf2.bits.addr2_4 = pAdapter->CurrentAddress[3];
-	uni_pf2.bits.addr2_5 = pAdapter->CurrentAddress[4];
-	uni_pf2.bits.addr2_6 = pAdapter->CurrentAddress[5];
-
-	uni_pf1.bits.addr1_3 = pAdapter->CurrentAddress[2];
-	uni_pf1.bits.addr1_4 = pAdapter->CurrentAddress[3];
-	uni_pf1.bits.addr1_5 = pAdapter->CurrentAddress[4];
-	uni_pf1.bits.addr1_6 = pAdapter->CurrentAddress[5];
+	uni_pf3.bits.addr1_1 = etdev->CurrentAddress[0];
+	uni_pf3.bits.addr1_2 = etdev->CurrentAddress[1];
+	uni_pf3.bits.addr2_1 = etdev->CurrentAddress[0];
+	uni_pf3.bits.addr2_2 = etdev->CurrentAddress[1];
+
+	uni_pf2.bits.addr2_3 = etdev->CurrentAddress[2];
+	uni_pf2.bits.addr2_4 = etdev->CurrentAddress[3];
+	uni_pf2.bits.addr2_5 = etdev->CurrentAddress[4];
+	uni_pf2.bits.addr2_6 = etdev->CurrentAddress[5];
+
+	uni_pf1.bits.addr1_3 = etdev->CurrentAddress[2];
+	uni_pf1.bits.addr1_4 = etdev->CurrentAddress[3];
+	uni_pf1.bits.addr1_5 = etdev->CurrentAddress[4];
+	uni_pf1.bits.addr1_6 = etdev->CurrentAddress[5];
 
-	pm_csr.value = readl(&pAdapter->CSRAddress->global.pm_csr.value);
+	pm_csr.value = readl(&etdev->CSRAddress->global.pm_csr.value);
 	if (pm_csr.bits.pm_phy_sw_coma == 0) {
 		writel(uni_pf1.value, &rxmac->uni_pf_addr1.value);
 		writel(uni_pf2.value, &rxmac->uni_pf_addr2.value);
--- a/drivers/staging/et131x/et1310_phy.c
+++ b/drivers/staging/et131x/et1310_phy.c
@@ -474,7 +474,7 @@ static int et131x_xcvr_init(struct et131
 	}
 }
 
-void et131x_Mii_check(struct et131x_adapter *pAdapter,
+void et131x_Mii_check(struct et131x_adapter *etdev,
 		      MI_BMSR_t bmsr, MI_BMSR_t bmsr_ints)
 {
 	uint8_t ucLinkStatus;
@@ -490,37 +490,37 @@ void et131x_Mii_check(struct et131x_adap
 
 	if (bmsr_ints.bits.link_status) {
 		if (bmsr.bits.link_status) {
-			pAdapter->PoMgmt.TransPhyComaModeOnBoot = 20;
+			etdev->PoMgmt.TransPhyComaModeOnBoot = 20;
 
 			/* Update our state variables and indicate the
 			 * connected state
 			 */
-			spin_lock_irqsave(&pAdapter->Lock, lockflags);
+			spin_lock_irqsave(&etdev->Lock, lockflags);
 
-			pAdapter->MediaState = NETIF_STATUS_MEDIA_CONNECT;
-			MP_CLEAR_FLAG(pAdapter, fMP_ADAPTER_LINK_DETECTION);
+			etdev->MediaState = NETIF_STATUS_MEDIA_CONNECT;
+			MP_CLEAR_FLAG(etdev, fMP_ADAPTER_LINK_DETECTION);
 
-			spin_unlock_irqrestore(&pAdapter->Lock, lockflags);
+			spin_unlock_irqrestore(&etdev->Lock, lockflags);
 
 			/* Don't indicate state if we're in loopback mode */
-			if (pAdapter->RegistryPhyLoopbk == false)
-				netif_carrier_on(pAdapter->netdev);
+			if (etdev->RegistryPhyLoopbk == false)
+				netif_carrier_on(etdev->netdev);
 		} else {
 			DBG_WARNING(et131x_dbginfo,
 				    "Link down cable problem\n");
 
-			if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_10MBPS) {
+			if (etdev->uiLinkSpeed == TRUEPHY_SPEED_10MBPS) {
 				/* NOTE - Is there a way to query this without
 				 * TruePHY?
-				 * && TRU_QueryCoreType(pAdapter->hTruePhy, 0) == EMI_TRUEPHY_A13O) {
+				 * && TRU_QueryCoreType(etdev->hTruePhy, 0) == EMI_TRUEPHY_A13O) {
 				 */
 				uint16_t Register18;
 
-				MiRead(pAdapter, 0x12, &Register18);
-				MiWrite(pAdapter, 0x12, Register18 | 0x4);
-				MiWrite(pAdapter, 0x10, Register18 | 0x8402);
-				MiWrite(pAdapter, 0x11, Register18 | 511);
-				MiWrite(pAdapter, 0x12, Register18);
+				MiRead(etdev, 0x12, &Register18);
+				MiWrite(etdev, 0x12, Register18 | 0x4);
+				MiWrite(etdev, 0x10, Register18 | 0x8402);
+				MiWrite(etdev, 0x11, Register18 | 511);
+				MiWrite(etdev, 0x12, Register18);
 			}
 
 			/* For the first N seconds of life, we are in "link
@@ -530,33 +530,33 @@ void et131x_Mii_check(struct et131x_adap
 			 * in the LinkDetectionDPC).
 			 */
 			if ((MP_IS_FLAG_CLEAR
-			     (pAdapter, fMP_ADAPTER_LINK_DETECTION))
-			    || (pAdapter->MediaState ==
+			     (etdev, fMP_ADAPTER_LINK_DETECTION))
+			    || (etdev->MediaState ==
 				NETIF_STATUS_MEDIA_DISCONNECT)) {
-				spin_lock_irqsave(&pAdapter->Lock, lockflags);
-				pAdapter->MediaState =
+				spin_lock_irqsave(&etdev->Lock, lockflags);
+				etdev->MediaState =
 				    NETIF_STATUS_MEDIA_DISCONNECT;
-				spin_unlock_irqrestore(&pAdapter->Lock,
+				spin_unlock_irqrestore(&etdev->Lock,
 						       lockflags);
 
 				/* Only indicate state if we're in loopback
 				 * mode
 				 */
-				if (pAdapter->RegistryPhyLoopbk == false)
-					netif_carrier_off(pAdapter->netdev);
+				if (etdev->RegistryPhyLoopbk == false)
+					netif_carrier_off(etdev->netdev);
 			}
 
-			pAdapter->uiLinkSpeed = 0;
-			pAdapter->uiDuplexMode = 0;
+			etdev->uiLinkSpeed = 0;
+			etdev->uiDuplexMode = 0;
 
 			/* Free the packets being actively sent & stopped */
-			et131x_free_busy_send_packets(pAdapter);
+			et131x_free_busy_send_packets(etdev);
 
 			/* Re-initialize the send structures */
-			et131x_init_send(pAdapter);
+			et131x_init_send(etdev);
 
 			/* Reset the RFD list and re-start RU */
-			et131x_reset_recv(pAdapter);
+			et131x_reset_recv(etdev);
 
 			/*
 			 * Bring the device back to the state it was during
@@ -564,61 +564,61 @@ void et131x_Mii_check(struct et131x_adap
 			 * way, when we get the auto-neg complete interrupt,
 			 * we can complete init by calling ConfigMacREGS2.
 			 */
-			et131x_soft_reset(pAdapter);
+			et131x_soft_reset(etdev);
 
 			/* Setup ET1310 as per the documentation */
-			et131x_adapter_setup(pAdapter);
+			et131x_adapter_setup(etdev);
 
 			/* Setup the PHY into coma mode until the cable is
 			 * plugged back in
 			 */
-			if (pAdapter->RegistryPhyComa == 1)
-				EnablePhyComa(pAdapter);
+			if (etdev->RegistryPhyComa == 1)
+				EnablePhyComa(etdev);
 		}
 	}
 
 	if (bmsr_ints.bits.auto_neg_complete ||
-	    (pAdapter->AiForceDpx == 3 && bmsr_ints.bits.link_status)) {
-		if (bmsr.bits.auto_neg_complete || pAdapter->AiForceDpx == 3) {
-			ET1310_PhyLinkStatus(pAdapter,
+	    (etdev->AiForceDpx == 3 && bmsr_ints.bits.link_status)) {
+		if (bmsr.bits.auto_neg_complete || etdev->AiForceDpx == 3) {
+			ET1310_PhyLinkStatus(etdev,
 					     &ucLinkStatus, &uiAutoNegStatus,
 					     &uiSpeed, &uiDuplex, &uiMdiMdix,
 					     &uiMasterSlave, &uiPolarity);
 
-			pAdapter->uiLinkSpeed = uiSpeed;
-			pAdapter->uiDuplexMode = uiDuplex;
+			etdev->uiLinkSpeed = uiSpeed;
+			etdev->uiDuplexMode = uiDuplex;
 
 			DBG_TRACE(et131x_dbginfo,
-				"pAdapter->uiLinkSpeed 0x%04x, pAdapter->uiDuplex 0x%08x\n",
-				pAdapter->uiLinkSpeed,
-				pAdapter->uiDuplexMode);
+				"etdev->uiLinkSpeed 0x%04x, etdev->uiDuplex 0x%08x\n",
+				etdev->uiLinkSpeed,
+				etdev->uiDuplexMode);
 
-			pAdapter->PoMgmt.TransPhyComaModeOnBoot = 20;
+			etdev->PoMgmt.TransPhyComaModeOnBoot = 20;
 
-			if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_10MBPS) {
+			if (etdev->uiLinkSpeed == TRUEPHY_SPEED_10MBPS) {
 				/*
 				 * NOTE - Is there a way to query this without
 				 * TruePHY?
-				 * && TRU_QueryCoreType(pAdapter->hTruePhy, 0)== EMI_TRUEPHY_A13O) {
+				 * && TRU_QueryCoreType(etdev->hTruePhy, 0)== EMI_TRUEPHY_A13O) {
 				 */
 				uint16_t Register18;
 
-				MiRead(pAdapter, 0x12, &Register18);
-				MiWrite(pAdapter, 0x12, Register18 | 0x4);
-				MiWrite(pAdapter, 0x10, Register18 | 0x8402);
-				MiWrite(pAdapter, 0x11, Register18 | 511);
-				MiWrite(pAdapter, 0x12, Register18);
+				MiRead(etdev, 0x12, &Register18);
+				MiWrite(etdev, 0x12, Register18 | 0x4);
+				MiWrite(etdev, 0x10, Register18 | 0x8402);
+				MiWrite(etdev, 0x11, Register18 | 511);
+				MiWrite(etdev, 0x12, Register18);
 			}
 
-			ConfigFlowControl(pAdapter);
+			ConfigFlowControl(etdev);
 
-			if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS &&
-					pAdapter->RegistryJumboPacket > 2048)
-				ET1310_PhyAndOrReg(pAdapter, 0x16, 0xcfff,
+			if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS &&
+					etdev->RegistryJumboPacket > 2048)
+				ET1310_PhyAndOrReg(etdev, 0x16, 0xcfff,
 								   0x2000);
 
-			SetRxDmaTimer(pAdapter);
-			ConfigMACRegs2(pAdapter);
+			SetRxDmaTimer(etdev);
+			ConfigMACRegs2(etdev);
 		}
 	}
 
@@ -627,230 +627,230 @@ void et131x_Mii_check(struct et131x_adap
 
 /**
  * TPAL_SetPhy10HalfDuplex - Force the phy into 10 Base T Half Duplex mode.
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  *
  * Also sets the MAC so it is syncd up properly
  */
-void TPAL_SetPhy10HalfDuplex(struct et131x_adapter *pAdapter)
+void TPAL_SetPhy10HalfDuplex(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/* First we need to turn off all other advertisement */
-	ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
-	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise100BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* Set our advertise values accordingly */
-	ET1310_PhyAdvertise10BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_HALF);
+	ET1310_PhyAdvertise10BaseT(etdev, TRUEPHY_ADV_DUPLEX_HALF);
 
 	/* Power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * TPAL_SetPhy10FullDuplex - Force the phy into 10 Base T Full Duplex mode.
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  *
  * Also sets the MAC so it is syncd up properly
  */
-void TPAL_SetPhy10FullDuplex(struct et131x_adapter *pAdapter)
+void TPAL_SetPhy10FullDuplex(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/* First we need to turn off all other advertisement */
-	ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
-	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise100BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* Set our advertise values accordingly */
-	ET1310_PhyAdvertise10BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_FULL);
+	ET1310_PhyAdvertise10BaseT(etdev, TRUEPHY_ADV_DUPLEX_FULL);
 
 	/* Power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * TPAL_SetPhy10Force - Force Base-T FD mode WITHOUT using autonegotiation
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  */
-void TPAL_SetPhy10Force(struct et131x_adapter *pAdapter)
+void TPAL_SetPhy10Force(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/* Disable autoneg */
-	ET1310_PhyAutoNeg(pAdapter, false);
+	ET1310_PhyAutoNeg(etdev, false);
 
 	/* Disable all advertisement */
-	ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
-	ET1310_PhyAdvertise10BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
-	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise10BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise100BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* Force 10 Mbps */
-	ET1310_PhySpeedSelect(pAdapter, TRUEPHY_SPEED_10MBPS);
+	ET1310_PhySpeedSelect(etdev, TRUEPHY_SPEED_10MBPS);
 
 	/* Force Full duplex */
-	ET1310_PhyDuplexMode(pAdapter, TRUEPHY_DUPLEX_FULL);
+	ET1310_PhyDuplexMode(etdev, TRUEPHY_DUPLEX_FULL);
 
 	/* Power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * TPAL_SetPhy100HalfDuplex - Force 100 Base T Half Duplex mode.
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  *
  * Also sets the MAC so it is syncd up properly.
  */
-void TPAL_SetPhy100HalfDuplex(struct et131x_adapter *pAdapter)
+void TPAL_SetPhy100HalfDuplex(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/* first we need to turn off all other advertisement */
-	ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
-	ET1310_PhyAdvertise10BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise10BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* Set our advertise values accordingly */
-	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_HALF);
+	ET1310_PhyAdvertise100BaseT(etdev, TRUEPHY_ADV_DUPLEX_HALF);
 
 	/* Set speed */
-	ET1310_PhySpeedSelect(pAdapter, TRUEPHY_SPEED_100MBPS);
+	ET1310_PhySpeedSelect(etdev, TRUEPHY_SPEED_100MBPS);
 
 	/* Power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * TPAL_SetPhy100FullDuplex - Force 100 Base T Full Duplex mode.
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  *
  * Also sets the MAC so it is syncd up properly
  */
-void TPAL_SetPhy100FullDuplex(struct et131x_adapter *pAdapter)
+void TPAL_SetPhy100FullDuplex(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/* First we need to turn off all other advertisement */
-	ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
-	ET1310_PhyAdvertise10BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise10BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* Set our advertise values accordingly */
-	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_FULL);
+	ET1310_PhyAdvertise100BaseT(etdev, TRUEPHY_ADV_DUPLEX_FULL);
 
 	/* Power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * TPAL_SetPhy100Force - Force 100 BaseT FD mode WITHOUT using autonegotiation
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  */
-void TPAL_SetPhy100Force(struct et131x_adapter *pAdapter)
+void TPAL_SetPhy100Force(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/* Disable autoneg */
-	ET1310_PhyAutoNeg(pAdapter, false);
+	ET1310_PhyAutoNeg(etdev, false);
 
 	/* Disable all advertisement */
-	ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
-	ET1310_PhyAdvertise10BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
-	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise10BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise100BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* Force 100 Mbps */
-	ET1310_PhySpeedSelect(pAdapter, TRUEPHY_SPEED_100MBPS);
+	ET1310_PhySpeedSelect(etdev, TRUEPHY_SPEED_100MBPS);
 
 	/* Force Full duplex */
-	ET1310_PhyDuplexMode(pAdapter, TRUEPHY_DUPLEX_FULL);
+	ET1310_PhyDuplexMode(etdev, TRUEPHY_DUPLEX_FULL);
 
 	/* Power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * TPAL_SetPhy1000FullDuplex - Force 1000 Base T Full Duplex mode
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  *
  * Also sets the MAC so it is syncd up properly.
  */
-void TPAL_SetPhy1000FullDuplex(struct et131x_adapter *pAdapter)
+void TPAL_SetPhy1000FullDuplex(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/* first we need to turn off all other advertisement */
-	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise100BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
-	ET1310_PhyAdvertise10BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+	ET1310_PhyAdvertise10BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* set our advertise values accordingly */
-	ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_FULL);
+	ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_FULL);
 
 	/* power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * TPAL_SetPhyAutoNeg - Set phy to autonegotiation mode.
- * @pAdapter: pointer to the adapter structure
+ * @etdev: pointer to the adapter structure
  */
-void TPAL_SetPhyAutoNeg(struct et131x_adapter *pAdapter)
+void TPAL_SetPhyAutoNeg(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/* Turn on advertisement of all capabilities */
-	ET1310_PhyAdvertise10BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_BOTH);
+	ET1310_PhyAdvertise10BaseT(etdev, TRUEPHY_ADV_DUPLEX_BOTH);
 
-	ET1310_PhyAdvertise100BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_BOTH);
+	ET1310_PhyAdvertise100BaseT(etdev, TRUEPHY_ADV_DUPLEX_BOTH);
 
-	if (pAdapter->DeviceID != ET131X_PCI_DEVICE_ID_FAST)
-		ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_FULL);
+	if (etdev->DeviceID != ET131X_PCI_DEVICE_ID_FAST)
+		ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_FULL);
 	else
-		ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+		ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* Make sure auto-neg is ON (it is disabled in FORCE modes) */
-	ET1310_PhyAutoNeg(pAdapter, true);
+	ET1310_PhyAutoNeg(etdev, true);
 
 	/* Power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
@@ -903,135 +903,135 @@ static const uint16_t ConfigPhy[25][2] =
 };
 
 /* condensed version of the phy initialization routine */
-void ET1310_PhyInit(struct et131x_adapter *pAdapter)
+void ET1310_PhyInit(struct et131x_adapter *etdev)
 {
 	uint16_t usData, usIndex;
 
-	if (pAdapter == NULL)
+	if (etdev == NULL)
 		return;
 
 	/* get the identity (again ?) */
-	MiRead(pAdapter, PHY_ID_1, &usData);
-	MiRead(pAdapter, PHY_ID_2, &usData);
+	MiRead(etdev, PHY_ID_1, &usData);
+	MiRead(etdev, PHY_ID_2, &usData);
 
 	/* what does this do/achieve ? */
-	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
-	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG,	0x0006);
+	MiRead(etdev, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
+	MiWrite(etdev, PHY_MPHY_CONTROL_REG,	0x0006);
 
 	/* read modem register 0402, should I do something with the return
 	   data ? */
-	MiWrite(pAdapter, PHY_INDEX_REG, 0x0402);
-	MiRead(pAdapter, PHY_DATA_REG, &usData);
+	MiWrite(etdev, PHY_INDEX_REG, 0x0402);
+	MiRead(etdev, PHY_DATA_REG, &usData);
 
 	/* what does this do/achieve ? */
-	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0002);
+	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0002);
 
 	/* get the identity (again ?) */
-	MiRead(pAdapter, PHY_ID_1, &usData);
-	MiRead(pAdapter, PHY_ID_2, &usData);
+	MiRead(etdev, PHY_ID_1, &usData);
+	MiRead(etdev, PHY_ID_2, &usData);
 
 	/* what does this achieve ? */
-	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
-	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0006);
+	MiRead(etdev, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
+	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0006);
 
 	/* read modem register 0402, should I do something with
 	   the return data? */
-	MiWrite(pAdapter, PHY_INDEX_REG, 0x0402);
-	MiRead(pAdapter, PHY_DATA_REG, &usData);
+	MiWrite(etdev, PHY_INDEX_REG, 0x0402);
+	MiRead(etdev, PHY_DATA_REG, &usData);
 
-	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0002);
+	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0002);
 
 	/* what does this achieve (should return 0x1040) */
-	MiRead(pAdapter, PHY_CONTROL, &usData);
-	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
-	MiWrite(pAdapter, PHY_CONTROL, 0x1840);
+	MiRead(etdev, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
+	MiWrite(etdev, PHY_CONTROL, 0x1840);
 
-	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0007);
+	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0007);
 
 	/* here the writing of the array starts.... */
 	usIndex = 0;
 	while (ConfigPhy[usIndex][0] != 0x0000) {
 		/* write value */
-		MiWrite(pAdapter, PHY_INDEX_REG, ConfigPhy[usIndex][0]);
-		MiWrite(pAdapter, PHY_DATA_REG, ConfigPhy[usIndex][1]);
+		MiWrite(etdev, PHY_INDEX_REG, ConfigPhy[usIndex][0]);
+		MiWrite(etdev, PHY_DATA_REG, ConfigPhy[usIndex][1]);
 
 		/* read it back */
-		MiWrite(pAdapter, PHY_INDEX_REG, ConfigPhy[usIndex][0]);
-		MiRead(pAdapter, PHY_DATA_REG, &usData);
+		MiWrite(etdev, PHY_INDEX_REG, ConfigPhy[usIndex][0]);
+		MiRead(etdev, PHY_DATA_REG, &usData);
 
 		/* do a check on the value read back ? */
 		usIndex++;
 	}
 	/* here the writing of the array ends... */
 
-	MiRead(pAdapter, PHY_CONTROL, &usData);		/* 0x1840 */
-	MiRead(pAdapter, PHY_MPHY_CONTROL_REG, &usData);/* should read 0007 */
-	MiWrite(pAdapter, PHY_CONTROL, 0x1040);
-	MiWrite(pAdapter, PHY_MPHY_CONTROL_REG, 0x0002);
+	MiRead(etdev, PHY_CONTROL, &usData);		/* 0x1840 */
+	MiRead(etdev, PHY_MPHY_CONTROL_REG, &usData);/* should read 0007 */
+	MiWrite(etdev, PHY_CONTROL, 0x1040);
+	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0002);
 }
 
-void ET1310_PhyReset(struct et131x_adapter *pAdapter)
+void ET1310_PhyReset(struct et131x_adapter *etdev)
 {
-	MiWrite(pAdapter, PHY_CONTROL, 0x8000);
+	MiWrite(etdev, PHY_CONTROL, 0x8000);
 }
 
-void ET1310_PhyPowerDown(struct et131x_adapter *pAdapter, bool down)
+void ET1310_PhyPowerDown(struct et131x_adapter *etdev, bool down)
 {
 	uint16_t usData;
 
-	MiRead(pAdapter, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_CONTROL, &usData);
 
 	if (down == false) {
 		/* Power UP */
 		usData &= ~0x0800;
-		MiWrite(pAdapter, PHY_CONTROL, usData);
+		MiWrite(etdev, PHY_CONTROL, usData);
 	} else {
 		/* Power DOWN */
 		usData |= 0x0800;
-		MiWrite(pAdapter, PHY_CONTROL, usData);
+		MiWrite(etdev, PHY_CONTROL, usData);
 	}
 }
 
-void ET1310_PhyAutoNeg(struct et131x_adapter *pAdapter, bool enable)
+void ET1310_PhyAutoNeg(struct et131x_adapter *etdev, bool enable)
 {
 	uint16_t usData;
 
-	MiRead(pAdapter, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_CONTROL, &usData);
 
 	if (enable == true) {
 		/* Autonegotiation ON */
 		usData |= 0x1000;
-		MiWrite(pAdapter, PHY_CONTROL, usData);
+		MiWrite(etdev, PHY_CONTROL, usData);
 	} else {
 		/* Autonegotiation OFF */
 		usData &= ~0x1000;
-		MiWrite(pAdapter, PHY_CONTROL, usData);
+		MiWrite(etdev, PHY_CONTROL, usData);
 	}
 }
 
-void ET1310_PhyDuplexMode(struct et131x_adapter *pAdapter, uint16_t duplex)
+void ET1310_PhyDuplexMode(struct et131x_adapter *etdev, uint16_t duplex)
 {
 	uint16_t usData;
 
-	MiRead(pAdapter, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_CONTROL, &usData);
 
 	if (duplex == TRUEPHY_DUPLEX_FULL) {
 		/* Set Full Duplex */
 		usData |= 0x100;
-		MiWrite(pAdapter, PHY_CONTROL, usData);
+		MiWrite(etdev, PHY_CONTROL, usData);
 	} else {
 		/* Set Half Duplex */
 		usData &= ~0x100;
-		MiWrite(pAdapter, PHY_CONTROL, usData);
+		MiWrite(etdev, PHY_CONTROL, usData);
 	}
 }
 
-void ET1310_PhySpeedSelect(struct et131x_adapter *pAdapter, uint16_t speed)
+void ET1310_PhySpeedSelect(struct et131x_adapter *etdev, uint16_t speed)
 {
 	uint16_t usData;
 
 	/* Read the PHY control register */
-	MiRead(pAdapter, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_CONTROL, &usData);
 
 	/* Clear all Speed settings (Bits 6, 13) */
 	usData &= ~0x2040;
@@ -1054,16 +1054,16 @@ void ET1310_PhySpeedSelect(struct et131x
 	}
 
 	/* Write back the new speed */
-	MiWrite(pAdapter, PHY_CONTROL, usData);
+	MiWrite(etdev, PHY_CONTROL, usData);
 }
 
-void ET1310_PhyAdvertise1000BaseT(struct et131x_adapter *pAdapter,
+void ET1310_PhyAdvertise1000BaseT(struct et131x_adapter *etdev,
 				  uint16_t duplex)
 {
 	uint16_t usData;
 
 	/* Read the PHY 1000 Base-T Control Register */
-	MiRead(pAdapter, PHY_1000_CONTROL, &usData);
+	MiRead(etdev, PHY_1000_CONTROL, &usData);
 
 	/* Clear Bits 8,9 */
 	usData &= ~0x0300;
@@ -1090,16 +1090,16 @@ void ET1310_PhyAdvertise1000BaseT(struct
 	}
 
 	/* Write back advertisement */
-	MiWrite(pAdapter, PHY_1000_CONTROL, usData);
+	MiWrite(etdev, PHY_1000_CONTROL, usData);
 }
 
-void ET1310_PhyAdvertise100BaseT(struct et131x_adapter *pAdapter,
+void ET1310_PhyAdvertise100BaseT(struct et131x_adapter *etdev,
 				 uint16_t duplex)
 {
 	uint16_t usData;
 
 	/* Read the Autonegotiation Register (10/100) */
-	MiRead(pAdapter, PHY_AUTO_ADVERTISEMENT, &usData);
+	MiRead(etdev, PHY_AUTO_ADVERTISEMENT, &usData);
 
 	/* Clear bits 7,8 */
 	usData &= ~0x0180;
@@ -1127,16 +1127,16 @@ void ET1310_PhyAdvertise100BaseT(struct 
 	}
 
 	/* Write back advertisement */
-	MiWrite(pAdapter, PHY_AUTO_ADVERTISEMENT, usData);
+	MiWrite(etdev, PHY_AUTO_ADVERTISEMENT, usData);
 }
 
-void ET1310_PhyAdvertise10BaseT(struct et131x_adapter *pAdapter,
+void ET1310_PhyAdvertise10BaseT(struct et131x_adapter *etdev,
 				uint16_t duplex)
 {
 	uint16_t usData;
 
 	/* Read the Autonegotiation Register (10/100) */
-	MiRead(pAdapter, PHY_AUTO_ADVERTISEMENT, &usData);
+	MiRead(etdev, PHY_AUTO_ADVERTISEMENT, &usData);
 
 	/* Clear bits 5,6 */
 	usData &= ~0x0060;
@@ -1164,10 +1164,10 @@ void ET1310_PhyAdvertise10BaseT(struct e
 	}
 
 	/* Write back advertisement */
-	MiWrite(pAdapter, PHY_AUTO_ADVERTISEMENT, usData);
+	MiWrite(etdev, PHY_AUTO_ADVERTISEMENT, usData);
 }
 
-void ET1310_PhyLinkStatus(struct et131x_adapter *pAdapter,
+void ET1310_PhyLinkStatus(struct et131x_adapter *etdev,
 			  uint8_t *ucLinkStatus,
 			  uint32_t *uiAutoNeg,
 			  uint32_t *uiLinkSpeed,
@@ -1180,10 +1180,10 @@ void ET1310_PhyLinkStatus(struct et131x_
 	uint16_t usVmiPhyStatus = 0;
 	uint16_t usControl = 0;
 
-	MiRead(pAdapter, PHY_STATUS, &usMiStatus);
-	MiRead(pAdapter, PHY_1000_STATUS, &us1000BaseT);
-	MiRead(pAdapter, PHY_PHY_STATUS, &usVmiPhyStatus);
-	MiRead(pAdapter, PHY_CONTROL, &usControl);
+	MiRead(etdev, PHY_STATUS, &usMiStatus);
+	MiRead(etdev, PHY_1000_STATUS, &us1000BaseT);
+	MiRead(etdev, PHY_PHY_STATUS, &usVmiPhyStatus);
+	MiRead(etdev, PHY_CONTROL, &usControl);
 
 	if (ucLinkStatus) {
 		*ucLinkStatus =
@@ -1221,13 +1221,13 @@ void ET1310_PhyLinkStatus(struct et131x_
 	}
 }
 
-void ET1310_PhyAndOrReg(struct et131x_adapter *pAdapter,
+void ET1310_PhyAndOrReg(struct et131x_adapter *etdev,
 			uint16_t regnum, uint16_t andMask, uint16_t orMask)
 {
 	uint16_t reg;
 
 	/* Read the requested register */
-	MiRead(pAdapter, regnum, &reg);
+	MiRead(etdev, regnum, &reg);
 
 	/* Apply the AND mask */
 	reg &= andMask;
@@ -1236,10 +1236,10 @@ void ET1310_PhyAndOrReg(struct et131x_ad
 	reg |= orMask;
 
 	/* Write the value back to the register */
-	MiWrite(pAdapter, regnum, reg);
+	MiWrite(etdev, regnum, reg);
 }
 
-void ET1310_PhyAccessMiBit(struct et131x_adapter *pAdapter, uint16_t action,
+void ET1310_PhyAccessMiBit(struct et131x_adapter *etdev, uint16_t action,
 			   uint16_t regnum, uint16_t bitnum, uint8_t *value)
 {
 	uint16_t reg;
@@ -1249,7 +1249,7 @@ void ET1310_PhyAccessMiBit(struct et131x
 	mask = 0x0001 << bitnum;
 
 	/* Read the requested register */
-	MiRead(pAdapter, regnum, &reg);
+	MiRead(etdev, regnum, &reg);
 
 	switch (action) {
 	case TRUEPHY_BIT_READ:
@@ -1259,12 +1259,12 @@ void ET1310_PhyAccessMiBit(struct et131x
 
 	case TRUEPHY_BIT_SET:
 		reg |= mask;
-		MiWrite(pAdapter, regnum, reg);
+		MiWrite(etdev, regnum, reg);
 		break;
 
 	case TRUEPHY_BIT_CLEAR:
 		reg &= ~mask;
-		MiWrite(pAdapter, regnum, reg);
+		MiWrite(etdev, regnum, reg);
 		break;
 
 	default:
--- a/drivers/staging/et131x/et1310_pm.c
+++ b/drivers/staging/et131x/et1310_pm.c
@@ -99,7 +99,7 @@ extern dbg_info_t *et131x_dbginfo;
 
 /**
  * EnablePhyComa - called when network cable is unplugged
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  *
  * driver receive an phy status change interrupt while in D0 and check that
  * phy_status is down.
@@ -117,7 +117,7 @@ extern dbg_info_t *et131x_dbginfo;
  *       indicating linkup status, call the MPDisablePhyComa routine to
  *             restore JAGCore and gigE PHY
  */
-void EnablePhyComa(struct et131x_adapter *pAdapter)
+void EnablePhyComa(struct et131x_adapter *etdev)
 {
 	unsigned long lockflags;
 	PM_CSR_t GlobalPmCSR;
@@ -125,81 +125,81 @@ void EnablePhyComa(struct et131x_adapter
 
 	DBG_ENTER(et131x_dbginfo);
 
-	GlobalPmCSR.value = readl(&pAdapter->CSRAddress->global.pm_csr.value);
+	GlobalPmCSR.value = readl(&etdev->CSRAddress->global.pm_csr.value);
 
 	/* Save the GbE PHY speed and duplex modes. Need to restore this
 	 * when cable is plugged back in
 	 */
-	pAdapter->PoMgmt.PowerDownSpeed = pAdapter->AiForceSpeed;
-	pAdapter->PoMgmt.PowerDownDuplex = pAdapter->AiForceDpx;
+	etdev->PoMgmt.PowerDownSpeed = etdev->AiForceSpeed;
+	etdev->PoMgmt.PowerDownDuplex = etdev->AiForceDpx;
 
 	/* Stop sending packets. */
-	spin_lock_irqsave(&pAdapter->SendHWLock, lockflags);
-	MP_SET_FLAG(pAdapter, fMP_ADAPTER_LOWER_POWER);
-	spin_unlock_irqrestore(&pAdapter->SendHWLock, lockflags);
+	spin_lock_irqsave(&etdev->SendHWLock, lockflags);
+	MP_SET_FLAG(etdev, fMP_ADAPTER_LOWER_POWER);
+	spin_unlock_irqrestore(&etdev->SendHWLock, lockflags);
 
 	/* Wait for outstanding Receive packets */
-	while ((MP_GET_RCV_REF(pAdapter) != 0) && (LoopCounter-- > 0))
+	while ((MP_GET_RCV_REF(etdev) != 0) && (LoopCounter-- > 0))
 		mdelay(2);
 
 	/* Gate off JAGCore 3 clock domains */
 	GlobalPmCSR.bits.pm_sysclk_gate = 0;
 	GlobalPmCSR.bits.pm_txclk_gate = 0;
 	GlobalPmCSR.bits.pm_rxclk_gate = 0;
-	writel(GlobalPmCSR.value, &pAdapter->CSRAddress->global.pm_csr.value);
+	writel(GlobalPmCSR.value, &etdev->CSRAddress->global.pm_csr.value);
 
 	/* Program gigE PHY in to Coma mode */
 	GlobalPmCSR.bits.pm_phy_sw_coma = 1;
-	writel(GlobalPmCSR.value, &pAdapter->CSRAddress->global.pm_csr.value);
+	writel(GlobalPmCSR.value, &etdev->CSRAddress->global.pm_csr.value);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * DisablePhyComa - Disable the Phy Coma Mode
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  */
-void DisablePhyComa(struct et131x_adapter *pAdapter)
+void DisablePhyComa(struct et131x_adapter *etdev)
 {
 	PM_CSR_t GlobalPmCSR;
 
 	DBG_ENTER(et131x_dbginfo);
 
-	GlobalPmCSR.value = readl(&pAdapter->CSRAddress->global.pm_csr.value);
+	GlobalPmCSR.value = readl(&etdev->CSRAddress->global.pm_csr.value);
 
 	/* Disable phy_sw_coma register and re-enable JAGCore clocks */
 	GlobalPmCSR.bits.pm_sysclk_gate = 1;
 	GlobalPmCSR.bits.pm_txclk_gate = 1;
 	GlobalPmCSR.bits.pm_rxclk_gate = 1;
 	GlobalPmCSR.bits.pm_phy_sw_coma = 0;
-	writel(GlobalPmCSR.value, &pAdapter->CSRAddress->global.pm_csr.value);
+	writel(GlobalPmCSR.value, &etdev->CSRAddress->global.pm_csr.value);
 
 	/* Restore the GbE PHY speed and duplex modes;
 	 * Reset JAGCore; re-configure and initialize JAGCore and gigE PHY
 	 */
-	pAdapter->AiForceSpeed = pAdapter->PoMgmt.PowerDownSpeed;
-	pAdapter->AiForceDpx = pAdapter->PoMgmt.PowerDownDuplex;
+	etdev->AiForceSpeed = etdev->PoMgmt.PowerDownSpeed;
+	etdev->AiForceDpx = etdev->PoMgmt.PowerDownDuplex;
 
 	/* Re-initialize the send structures */
-	et131x_init_send(pAdapter);
+	et131x_init_send(etdev);
 
 	/* Reset the RFD list and re-start RU  */
-	et131x_reset_recv(pAdapter);
+	et131x_reset_recv(etdev);
 
 	/* Bring the device back to the state it was during init prior to
 	 * autonegotiation being complete.  This way, when we get the auto-neg
 	 * complete interrupt, we can complete init by calling ConfigMacREGS2.
 	 */
-	et131x_soft_reset(pAdapter);
+	et131x_soft_reset(etdev);
 
 	/* setup et1310 as per the documentation ?? */
-	et131x_adapter_setup(pAdapter);
+	et131x_adapter_setup(etdev);
 
 	/* Allow Tx to restart */
-	MP_CLEAR_FLAG(pAdapter, fMP_ADAPTER_LOWER_POWER);
+	MP_CLEAR_FLAG(etdev, fMP_ADAPTER_LOWER_POWER);
 
 	/* Need to re-enable Rx. */
-	et131x_rx_dma_enable(pAdapter);
+	et131x_rx_dma_enable(etdev);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -99,7 +99,7 @@ extern dbg_info_t *et131x_dbginfo;
 #endif /* CONFIG_ET131X_DEBUG */
 
 
-void nic_return_rfd(struct et131x_adapter *pAdapter, PMP_RFD pMpRfd);
+void nic_return_rfd(struct et131x_adapter *etdev, PMP_RFD pMpRfd);
 
 /**
  * et131x_rx_dma_memory_alloc
@@ -676,12 +676,12 @@ void et131x_rfd_resources_free(struct et
 
 /**
  * ConfigRxDmaRegs - Start of Rx_DMA init sequence
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  */
-void ConfigRxDmaRegs(struct et131x_adapter *pAdapter)
+void ConfigRxDmaRegs(struct et131x_adapter *etdev)
 {
-	struct _RXDMA_t __iomem *pRxDma = &pAdapter->CSRAddress->rxdma;
-	struct _rx_ring_t *pRxLocal = &pAdapter->RxRing;
+	struct _RXDMA_t __iomem *pRxDma = &etdev->CSRAddress->rxdma;
+	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
 	PFBR_DESC_t pFbrEntry;
 	uint32_t iEntry;
 	RXDMA_PSR_NUM_DES_t psr_num_des;
@@ -690,7 +690,7 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Halt RXDMA to perform the reconfigure.  */
-	et131x_rx_dma_disable(pAdapter);
+	et131x_rx_dma_disable(etdev);
 
 	/* Load the completion writeback physical address
 	 *
@@ -718,7 +718,7 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	writel((psr_num_des.bits.psr_ndes * LO_MARK_PERCENT_FOR_PSR) / 100,
 	       &pRxDma->psr_min_des.value);
 
-	spin_lock_irqsave(&pAdapter->RcvLock, lockflags);
+	spin_lock_irqsave(&etdev->RcvLock, lockflags);
 
 	/* These local variables track the PSR in the adapter structure */
 	pRxLocal->local_psr_full.bits.psr_full = 0;
@@ -792,52 +792,52 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	 * For version B silicon, this value gets updated once autoneg is
 	 *complete.
 	 */
-	writel(pAdapter->RegistryRxNumBuffers, &pRxDma->num_pkt_done.value);
+	writel(etdev->RegistryRxNumBuffers, &pRxDma->num_pkt_done.value);
 
 	/* The "time_done" is not working correctly to coalesce interrupts
 	 * after a given time period, but rather is giving us an interrupt
 	 * regardless of whether we have received packets.
 	 * This value gets updated once autoneg is complete.
 	 */
-	writel(pAdapter->RegistryRxTimeInterval, &pRxDma->max_pkt_time.value);
+	writel(etdev->RegistryRxTimeInterval, &pRxDma->max_pkt_time.value);
 
-	spin_unlock_irqrestore(&pAdapter->RcvLock, lockflags);
+	spin_unlock_irqrestore(&etdev->RcvLock, lockflags);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * SetRxDmaTimer - Set the heartbeat timer according to line rate.
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  */
-void SetRxDmaTimer(struct et131x_adapter *pAdapter)
+void SetRxDmaTimer(struct et131x_adapter *etdev)
 {
 	/* For version B silicon, we do not use the RxDMA timer for 10 and 100
 	 * Mbits/s line rates. We do not enable and RxDMA interrupt coalescing.
 	 */
-	if ((pAdapter->uiLinkSpeed == TRUEPHY_SPEED_100MBPS) ||
-	    (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_10MBPS)) {
-		writel(0, &pAdapter->CSRAddress->rxdma.max_pkt_time.value);
-		writel(1, &pAdapter->CSRAddress->rxdma.num_pkt_done.value);
+	if ((etdev->uiLinkSpeed == TRUEPHY_SPEED_100MBPS) ||
+	    (etdev->uiLinkSpeed == TRUEPHY_SPEED_10MBPS)) {
+		writel(0, &etdev->CSRAddress->rxdma.max_pkt_time.value);
+		writel(1, &etdev->CSRAddress->rxdma.num_pkt_done.value);
 	}
 }
 
 /**
  * et131x_rx_dma_disable - Stop of Rx_DMA on the ET1310
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  */
-void et131x_rx_dma_disable(struct et131x_adapter *pAdapter)
+void et131x_rx_dma_disable(struct et131x_adapter *etdev)
 {
 	RXDMA_CSR_t csr;
 
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Setup the receive dma configuration register */
-	writel(0x00002001, &pAdapter->CSRAddress->rxdma.csr.value);
-	csr.value = readl(&pAdapter->CSRAddress->rxdma.csr.value);
+	writel(0x00002001, &etdev->CSRAddress->rxdma.csr.value);
+	csr.value = readl(&etdev->CSRAddress->rxdma.csr.value);
 	if (csr.bits.halt_status != 1) {
 		udelay(5);
-		csr.value = readl(&pAdapter->CSRAddress->rxdma.csr.value);
+		csr.value = readl(&etdev->CSRAddress->rxdma.csr.value);
 		if (csr.bits.halt_status != 1)
 			DBG_ERROR(et131x_dbginfo,
 				"RX Dma failed to enter halt state. CSR 0x%08x\n",
@@ -849,41 +849,41 @@ void et131x_rx_dma_disable(struct et131x
 
 /**
  * et131x_rx_dma_enable - re-start of Rx_DMA on the ET1310.
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  */
-void et131x_rx_dma_enable(struct et131x_adapter *pAdapter)
+void et131x_rx_dma_enable(struct et131x_adapter *etdev)
 {
 	DBG_RX_ENTER(et131x_dbginfo);
 
-	if (pAdapter->RegistryPhyLoopbk)
+	if (etdev->RegistryPhyLoopbk)
 		/* RxDMA is disabled for loopback operation. */
-		writel(0x1, &pAdapter->CSRAddress->rxdma.csr.value);
+		writel(0x1, &etdev->CSRAddress->rxdma.csr.value);
 	else {
 	/* Setup the receive dma configuration register for normal operation */
 		RXDMA_CSR_t csr = { 0 };
 
 		csr.bits.fbr1_enable = 1;
-		if (pAdapter->RxRing.Fbr1BufferSize == 4096)
+		if (etdev->RxRing.Fbr1BufferSize == 4096)
 			csr.bits.fbr1_size = 1;
-		else if (pAdapter->RxRing.Fbr1BufferSize == 8192)
+		else if (etdev->RxRing.Fbr1BufferSize == 8192)
 			csr.bits.fbr1_size = 2;
-		else if (pAdapter->RxRing.Fbr1BufferSize == 16384)
+		else if (etdev->RxRing.Fbr1BufferSize == 16384)
 			csr.bits.fbr1_size = 3;
 #ifdef USE_FBR0
 		csr.bits.fbr0_enable = 1;
-		if (pAdapter->RxRing.Fbr0BufferSize == 256)
+		if (etdev->RxRing.Fbr0BufferSize == 256)
 			csr.bits.fbr0_size = 1;
-		else if (pAdapter->RxRing.Fbr0BufferSize == 512)
+		else if (etdev->RxRing.Fbr0BufferSize == 512)
 			csr.bits.fbr0_size = 2;
-		else if (pAdapter->RxRing.Fbr0BufferSize == 1024)
+		else if (etdev->RxRing.Fbr0BufferSize == 1024)
 			csr.bits.fbr0_size = 3;
 #endif
-		writel(csr.value, &pAdapter->CSRAddress->rxdma.csr.value);
+		writel(csr.value, &etdev->CSRAddress->rxdma.csr.value);
 
-		csr.value = readl(&pAdapter->CSRAddress->rxdma.csr.value);
+		csr.value = readl(&etdev->CSRAddress->rxdma.csr.value);
 		if (csr.bits.halt_status != 0) {
 			udelay(5);
-			csr.value = readl(&pAdapter->CSRAddress->rxdma.csr.value);
+			csr.value = readl(&etdev->CSRAddress->rxdma.csr.value);
 			if (csr.bits.halt_status != 0) {
 				DBG_ERROR(et131x_dbginfo,
 					"RX Dma failed to exit halt state.  CSR 0x%08x\n",
@@ -897,7 +897,7 @@ void et131x_rx_dma_enable(struct et131x_
 
 /**
  * nic_rx_pkts - Checks the hardware for available packets
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Returns pMpRfd, a pointer to our MPRFD.
  *
@@ -906,9 +906,9 @@ void et131x_rx_dma_enable(struct et131x_
  * the packet to it, puts the RFD in the RecvPendList, and also returns
  * the pointer to the RFD.
  */
-PMP_RFD nic_rx_pkts(struct et131x_adapter *pAdapter)
+PMP_RFD nic_rx_pkts(struct et131x_adapter *etdev)
 {
-	struct _rx_ring_t *pRxLocal = &pAdapter->RxRing;
+	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
 	PRX_STATUS_BLOCK_t pRxStatusBlock;
 	PPKT_STAT_DESC_t pPSREntry;
 	PMP_RFD pMpRfd;
@@ -978,7 +978,7 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 	}
 
 	writel(pRxLocal->local_psr_full.value,
-	       &pAdapter->CSRAddress->rxdma.psr_full_offset.value);
+	       &etdev->CSRAddress->rxdma.psr_full_offset.value);
 
 #ifndef USE_FBR0
 	if (ringIndex != 1) {
@@ -1013,7 +1013,7 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 	}
 
 	/* Get and fill the RFD. */
-	spin_lock_irqsave(&pAdapter->RcvLock, lockflags);
+	spin_lock_irqsave(&etdev->RcvLock, lockflags);
 
 	pMpRfd = NULL;
 	element = pRxLocal->RecvList.next;
@@ -1023,14 +1023,14 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 		DBG_RX(et131x_dbginfo,
 		       "NULL RFD returned from RecvList via list_entry()\n");
 		DBG_RX_LEAVE(et131x_dbginfo);
-		spin_unlock_irqrestore(&pAdapter->RcvLock, lockflags);
+		spin_unlock_irqrestore(&etdev->RcvLock, lockflags);
 		return NULL;
 	}
 
 	list_del(&pMpRfd->list_node);
 	pRxLocal->nReadyRecv--;
 
-	spin_unlock_irqrestore(&pAdapter->RcvLock, lockflags);
+	spin_unlock_irqrestore(&etdev->RcvLock, lockflags);
 
 	pMpRfd->iBufferIndex = bufferIndex;
 	pMpRfd->iRingIndex = ringIndex;
@@ -1041,19 +1041,19 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 	 * also counted here.
 	 */
 	if (localLen < (NIC_MIN_PACKET_SIZE + 4)) {
-		pAdapter->Stats.other_errors++;
+		etdev->Stats.other_errors++;
 		localLen = 0;
 	}
 
 	if (localLen) {
-		if (pAdapter->ReplicaPhyLoopbk == 1) {
+		if (etdev->ReplicaPhyLoopbk == 1) {
 			pBufVa = pRxLocal->Fbr[ringIndex]->Va[bufferIndex];
 
-			if (memcmp(&pBufVa[6], &pAdapter->CurrentAddress[0],
+			if (memcmp(&pBufVa[6], &etdev->CurrentAddress[0],
 				   ETH_ALEN) == 0) {
 				if (memcmp(&pBufVa[42], "Replica packet",
 					   ETH_HLEN)) {
-					pAdapter->ReplicaPhyLoopbkPF = 1;
+					etdev->ReplicaPhyLoopbkPF = 1;
 				}
 			}
 			DBG_WARNING(et131x_dbginfo,
@@ -1063,12 +1063,12 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 
 			DBG_WARNING(et131x_dbginfo,
 				    "CurrentAddr:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
-				    pAdapter->CurrentAddress[0],
-				    pAdapter->CurrentAddress[1],
-				    pAdapter->CurrentAddress[2],
-				    pAdapter->CurrentAddress[3],
-				    pAdapter->CurrentAddress[4],
-				    pAdapter->CurrentAddress[5]);
+				    etdev->CurrentAddress[0],
+				    etdev->CurrentAddress[1],
+				    etdev->CurrentAddress[2],
+				    etdev->CurrentAddress[3],
+				    etdev->CurrentAddress[4],
+				    etdev->CurrentAddress[5]);
 		}
 
 		/* Determine if this is a multicast packet coming in */
@@ -1081,9 +1081,9 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 			 * filters. Generally filter is 0x2b when in
 			 * promiscuous mode.
 			 */
-			if ((pAdapter->PacketFilter & ET131X_PACKET_TYPE_MULTICAST)
-			    && !(pAdapter->PacketFilter & ET131X_PACKET_TYPE_PROMISCUOUS)
-			    && !(pAdapter->PacketFilter & ET131X_PACKET_TYPE_ALL_MULTICAST)) {
+			if ((etdev->PacketFilter & ET131X_PACKET_TYPE_MULTICAST)
+			    && !(etdev->PacketFilter & ET131X_PACKET_TYPE_PROMISCUOUS)
+			    && !(etdev->PacketFilter & ET131X_PACKET_TYPE_ALL_MULTICAST)) {
 				pBufVa = pRxLocal->Fbr[ringIndex]->
 						Va[bufferIndex];
 
@@ -1092,20 +1092,20 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 				 * matches one in our list.
 				 */
 				for (nIndex = 0;
-				     nIndex < pAdapter->MCAddressCount;
+				     nIndex < etdev->MCAddressCount;
 				     nIndex++) {
 					if (pBufVa[0] ==
-					    pAdapter->MCList[nIndex][0]
+					    etdev->MCList[nIndex][0]
 					    && pBufVa[1] ==
-					    pAdapter->MCList[nIndex][1]
+					    etdev->MCList[nIndex][1]
 					    && pBufVa[2] ==
-					    pAdapter->MCList[nIndex][2]
+					    etdev->MCList[nIndex][2]
 					    && pBufVa[3] ==
-					    pAdapter->MCList[nIndex][3]
+					    etdev->MCList[nIndex][3]
 					    && pBufVa[4] ==
-					    pAdapter->MCList[nIndex][4]
+					    etdev->MCList[nIndex][4]
 					    && pBufVa[5] ==
-					    pAdapter->MCList[nIndex][5]) {
+					    etdev->MCList[nIndex][5]) {
 						break;
 					}
 				}
@@ -1118,21 +1118,21 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 				 * so we free our RFD when we return
 				 * from this function.
 				 */
-				if (nIndex == pAdapter->MCAddressCount)
+				if (nIndex == etdev->MCAddressCount)
 					localLen = 0;
 			}
 
 			if (localLen > 0)
-				pAdapter->Stats.multircv++;
+				etdev->Stats.multircv++;
 		} else if (Word0.value & ALCATEL_BROADCAST_PKT)
-			pAdapter->Stats.brdcstrcv++;
+			etdev->Stats.brdcstrcv++;
 		else
 			/* Not sure what this counter measures in
 			 * promiscuous mode. Perhaps we should check
 			 * the MAC address to see if it is directed
 			 * to us in promiscuous mode.
 			 */
-			pAdapter->Stats.unircv++;
+			etdev->Stats.unircv++;
 	}
 
 	if (localLen > 0) {
@@ -1149,14 +1149,14 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 			return NULL;
 		}
 
-		pAdapter->net_stats.rx_bytes += pMpRfd->PacketSize;
+		etdev->net_stats.rx_bytes += pMpRfd->PacketSize;
 
 		memcpy(skb_put(skb, pMpRfd->PacketSize),
 		       pRxLocal->Fbr[ringIndex]->Va[bufferIndex],
 		       pMpRfd->PacketSize);
 
-		skb->dev = pAdapter->netdev;
-		skb->protocol = eth_type_trans(skb, pAdapter->netdev);
+		skb->dev = etdev->netdev;
+		skb->protocol = eth_type_trans(skb, etdev->netdev);
 		skb->ip_summed = CHECKSUM_NONE;
 
 		netif_rx(skb);
@@ -1164,7 +1164,7 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 		pMpRfd->PacketSize = 0;
 	}
 
-	nic_return_rfd(pAdapter, pMpRfd);
+	nic_return_rfd(etdev, pMpRfd);
 
 	DBG_RX(et131x_dbginfo, "(1)\n");
 	DBG_RX_LEAVE(et131x_dbginfo);
@@ -1173,28 +1173,28 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 
 /**
  * et131x_reset_recv - Reset the receive list
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Assumption, Rcv spinlock has been acquired.
  */
-void et131x_reset_recv(struct et131x_adapter *pAdapter)
+void et131x_reset_recv(struct et131x_adapter *etdev)
 {
 	PMP_RFD pMpRfd;
 	struct list_head *element;
 
 	DBG_ENTER(et131x_dbginfo);
 
-	DBG_ASSERT(!list_empty(&pAdapter->RxRing.RecvList));
+	DBG_ASSERT(!list_empty(&etdev->RxRing.RecvList));
 
 	/* Take all the RFD's from the pending list, and stick them on the
 	 * RecvList.
 	 */
-	while (!list_empty(&pAdapter->RxRing.RecvPendingList)) {
-		element = pAdapter->RxRing.RecvPendingList.next;
+	while (!list_empty(&etdev->RxRing.RecvPendingList)) {
+		element = etdev->RxRing.RecvPendingList.next;
 
 		pMpRfd = (PMP_RFD) list_entry(element, MP_RFD, list_node);
 
-		list_move_tail(&pMpRfd->list_node, &pAdapter->RxRing.RecvList);
+		list_move_tail(&pMpRfd->list_node, &etdev->RxRing.RecvList);
 	}
 
 	DBG_LEAVE(et131x_dbginfo);
@@ -1202,11 +1202,11 @@ void et131x_reset_recv(struct et131x_ada
 
 /**
  * et131x_handle_recv_interrupt - Interrupt handler for receive processing
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Assumption, Rcv spinlock has been acquired.
  */
-void et131x_handle_recv_interrupt(struct et131x_adapter *pAdapter)
+void et131x_handle_recv_interrupt(struct et131x_adapter *etdev)
 {
 	PMP_RFD pMpRfd = NULL;
 	struct sk_buff *PacketArray[NUM_PACKETS_HANDLED];
@@ -1222,14 +1222,14 @@ void et131x_handle_recv_interrupt(struct
 
 	/* Process up to available RFD's */
 	while (PacketArrayCount < PacketsToHandle) {
-		if (list_empty(&pAdapter->RxRing.RecvList)) {
-			DBG_ASSERT(pAdapter->RxRing.nReadyRecv == 0);
+		if (list_empty(&etdev->RxRing.RecvList)) {
+			DBG_ASSERT(etdev->RxRing.nReadyRecv == 0);
 			DBG_ERROR(et131x_dbginfo, "NO RFD's !!!!!!!!!!!!!\n");
 			TempUnfinishedRec = true;
 			break;
 		}
 
-		pMpRfd = nic_rx_pkts(pAdapter);
+		pMpRfd = nic_rx_pkts(etdev);
 
 		if (pMpRfd == NULL)
 			break;
@@ -1240,18 +1240,18 @@ void et131x_handle_recv_interrupt(struct
 		 * If length is zero, return the RFD in order to advance the
 		 * Free buffer ring.
 		 */
-		if ((!pAdapter->PacketFilter) ||
-		    (pAdapter->PoMgmt.PowerState != NdisDeviceStateD0) ||
-		    (!MP_LINK_DETECTED(pAdapter)) ||
+		if ((!etdev->PacketFilter) ||
+		    (etdev->PoMgmt.PowerState != NdisDeviceStateD0) ||
+		    (!MP_LINK_DETECTED(etdev)) ||
 		    (pMpRfd->PacketSize == 0)) {
 			continue;
 		}
 
 		/* Increment the number of packets we received */
-		pAdapter->Stats.ipackets++;
+		etdev->Stats.ipackets++;
 
 		/* Set the status on the packet, either resources or success */
-		if (pAdapter->RxRing.nReadyRecv >= RFD_LOW_WATER_MARK) {
+		if (etdev->RxRing.nReadyRecv >= RFD_LOW_WATER_MARK) {
 			/* Put this RFD on the pending list
 			 *
 			 * NOTE: nic_rx_pkts() above is already returning the
@@ -1260,13 +1260,13 @@ void et131x_handle_recv_interrupt(struct
 			 * Besides, we don't really need (at this point) the
 			 * pending list anyway.
 			 */
-			/* spin_lock_irqsave( &pAdapter->RcvPendLock, lockflags );
-			 * list_add_tail( &pMpRfd->list_node, &pAdapter->RxRing.RecvPendingList );
-			 * spin_unlock_irqrestore( &pAdapter->RcvPendLock, lockflags );
+			/* spin_lock_irqsave( &etdev->RcvPendLock, lockflags );
+			 * list_add_tail( &pMpRfd->list_node, &etdev->RxRing.RecvPendingList );
+			 * spin_unlock_irqrestore( &etdev->RcvPendLock, lockflags );
 			 */
 
 			/* Update the number of outstanding Recvs */
-			/* MP_INC_RCV_REF( pAdapter ); */
+			/* MP_INC_RCV_REF( etdev ); */
 		} else {
 			RFDFreeArray[PacketFreeCount] = pMpRfd;
 			PacketFreeCount++;
@@ -1280,12 +1280,12 @@ void et131x_handle_recv_interrupt(struct
 	}
 
 	if ((PacketArrayCount == NUM_PACKETS_HANDLED) || TempUnfinishedRec) {
-		pAdapter->RxRing.UnfinishedReceives = true;
-		writel(pAdapter->RegistryTxTimeInterval * NANO_IN_A_MICRO,
-		       &pAdapter->CSRAddress->global.watchdog_timer);
+		etdev->RxRing.UnfinishedReceives = true;
+		writel(etdev->RegistryTxTimeInterval * NANO_IN_A_MICRO,
+		       &etdev->CSRAddress->global.watchdog_timer);
 	} else {
 		/* Watchdog timer will disable itself if appropriate. */
-		pAdapter->RxRing.UnfinishedReceives = false;
+		etdev->RxRing.UnfinishedReceives = false;
 	}
 
 	DBG_RX_LEAVE(et131x_dbginfo);
@@ -1293,13 +1293,13 @@ void et131x_handle_recv_interrupt(struct
 
 /**
  * NICReturnRFD - Recycle a RFD and put it back onto the receive list
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  * @pMpRfd: pointer to the RFD
  */
-void nic_return_rfd(struct et131x_adapter *pAdapter, PMP_RFD pMpRfd)
+void nic_return_rfd(struct et131x_adapter *etdev, PMP_RFD pMpRfd)
 {
-	struct _rx_ring_t *pRxLocal = &pAdapter->RxRing;
-	struct _RXDMA_t __iomem *pRxDma = &pAdapter->CSRAddress->rxdma;
+	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
+	struct _RXDMA_t __iomem *pRxDma = &etdev->CSRAddress->rxdma;
 	uint16_t bi = pMpRfd->iBufferIndex;
 	uint8_t ri = pMpRfd->iRingIndex;
 	unsigned long lockflags;
@@ -1314,7 +1314,7 @@ void nic_return_rfd(struct et131x_adapte
 	    (ri == 0 && bi < pRxLocal->Fbr0NumEntries) ||
 #endif
 	    (ri == 1 && bi < pRxLocal->Fbr1NumEntries)) {
-		spin_lock_irqsave(&pAdapter->FbrLock, lockflags);
+		spin_lock_irqsave(&etdev->FbrLock, lockflags);
 
 		if (ri == 1) {
 			PFBR_DESC_t pNextDesc =
@@ -1362,7 +1362,7 @@ void nic_return_rfd(struct et131x_adapte
 			       &pRxDma->fbr0_full_offset.value);
 		}
 #endif
-		spin_unlock_irqrestore(&pAdapter->FbrLock, lockflags);
+		spin_unlock_irqrestore(&etdev->FbrLock, lockflags);
 	} else {
 		DBG_ERROR(et131x_dbginfo,
 			  "NICReturnRFD illegal Buffer Index returned\n");
@@ -1371,10 +1371,10 @@ void nic_return_rfd(struct et131x_adapte
 	/* The processing on this RFD is done, so put it back on the tail of
 	 * our list
 	 */
-	spin_lock_irqsave(&pAdapter->RcvLock, lockflags);
+	spin_lock_irqsave(&etdev->RcvLock, lockflags);
 	list_add_tail(&pMpRfd->list_node, &pRxLocal->RecvList);
 	pRxLocal->nReadyRecv++;
-	spin_unlock_irqrestore(&pAdapter->RcvLock, lockflags);
+	spin_unlock_irqrestore(&etdev->RcvLock, lockflags);
 
 	DBG_ASSERT(pRxLocal->nReadyRecv <= pRxLocal->NumRfd);
 	DBG_RX_LEAVE(et131x_dbginfo);
--- a/drivers/staging/et131x/et1310_tx.c
+++ b/drivers/staging/et131x/et1310_tx.c
@@ -99,13 +99,13 @@
 extern dbg_info_t *et131x_dbginfo;
 #endif /* CONFIG_ET131X_DEBUG */
 
-static void et131x_update_tcb_list(struct et131x_adapter *pAdapter);
-static void et131x_check_send_wait_list(struct et131x_adapter *pAdapter);
-static inline void et131x_free_send_packet(struct et131x_adapter *pAdapter,
+static void et131x_update_tcb_list(struct et131x_adapter *etdev);
+static void et131x_check_send_wait_list(struct et131x_adapter *etdev);
+static inline void et131x_free_send_packet(struct et131x_adapter *etdev,
 					   PMP_TCB pMpTcb);
 static int et131x_send_packet(struct sk_buff *skb,
-			      struct et131x_adapter *pAdapter);
-static int nic_send_packet(struct et131x_adapter *pAdapter, PMP_TCB pMpTcb);
+			      struct et131x_adapter *etdev);
+static int nic_send_packet(struct et131x_adapter *etdev, PMP_TCB pMpTcb);
 
 /**
  * et131x_tx_dma_memory_alloc
@@ -247,16 +247,16 @@ void et131x_tx_dma_memory_free(struct et
  * ConfigTxDmaRegs - Set up the tx dma section of the JAGCore.
  * @adapter: pointer to our private adapter structure
  */
-void ConfigTxDmaRegs(struct et131x_adapter *pAdapter)
+void ConfigTxDmaRegs(struct et131x_adapter *etdev)
 {
-	struct _TXDMA_t __iomem *pTxDma = &pAdapter->CSRAddress->txdma;
+	struct _TXDMA_t __iomem *pTxDma = &etdev->CSRAddress->txdma;
 
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Load the hardware with the start of the transmit descriptor ring. */
-	writel((uint32_t) (pAdapter->TxRing.pTxDescRingAdjustedPa >> 32),
+	writel((uint32_t) (etdev->TxRing.pTxDescRingAdjustedPa >> 32),
 	       &pTxDma->pr_base_hi);
-	writel((uint32_t) pAdapter->TxRing.pTxDescRingAdjustedPa,
+	writel((uint32_t) etdev->TxRing.pTxDescRingAdjustedPa,
 	       &pTxDma->pr_base_lo);
 
 	/* Initialise the transmit DMA engine */
@@ -270,43 +270,43 @@ void ConfigTxDmaRegs(struct et131x_adapt
 	 * storing the adjusted address.
 	 */
 	writel(0, &pTxDma->dma_wb_base_hi);
-	writel(pAdapter->TxRing.pTxStatusPa, &pTxDma->dma_wb_base_lo);
+	writel(etdev->TxRing.pTxStatusPa, &pTxDma->dma_wb_base_lo);
 
-	memset(pAdapter->TxRing.pTxStatusVa, 0, sizeof(TX_STATUS_BLOCK_t));
+	memset(etdev->TxRing.pTxStatusVa, 0, sizeof(TX_STATUS_BLOCK_t));
 
 	writel(0, &pTxDma->service_request.value);
-	pAdapter->TxRing.txDmaReadyToSend.value = 0;
+	etdev->TxRing.txDmaReadyToSend.value = 0;
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * et131x_tx_dma_disable - Stop of Tx_DMA on the ET1310
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  */
-void et131x_tx_dma_disable(struct et131x_adapter *pAdapter)
+void et131x_tx_dma_disable(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Setup the tramsmit dma configuration register */
-	writel(0x101, &pAdapter->CSRAddress->txdma.csr.value);
+	writel(0x101, &etdev->CSRAddress->txdma.csr.value);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * et131x_tx_dma_enable - re-start of Tx_DMA on the ET1310.
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  *
  * Mainly used after a return to the D0 (full-power) state from a lower state.
  */
-void et131x_tx_dma_enable(struct et131x_adapter *pAdapter)
+void et131x_tx_dma_enable(struct et131x_adapter *etdev)
 {
 	DBG_ENTER(et131x_dbginfo);
 
-	if (pAdapter->RegistryPhyLoopbk) {
+	if (etdev->RegistryPhyLoopbk) {
 		/* TxDMA is disabled for loopback operation. */
-		writel(0x101, &pAdapter->CSRAddress->txdma.csr.value);
+		writel(0x101, &etdev->CSRAddress->txdma.csr.value);
 	} else {
 		TXDMA_CSR_t csr = { 0 };
 
@@ -315,8 +315,8 @@ void et131x_tx_dma_enable(struct et131x_
 		 */
 		csr.bits.sngl_epkt_mode = 1;
 		csr.bits.halt = 0;
-		csr.bits.cache_thrshld = pAdapter->RegistryDMACache;
-		writel(csr.value, &pAdapter->CSRAddress->txdma.csr.value);
+		csr.bits.cache_thrshld = etdev->RegistryDMACache;
+		writel(csr.value, &etdev->CSRAddress->txdma.csr.value);
 	}
 
 	DBG_LEAVE(et131x_dbginfo);
@@ -377,11 +377,11 @@ void et131x_init_send(struct et131x_adap
 int et131x_send_packets(struct sk_buff *skb, struct net_device *netdev)
 {
 	int status = 0;
-	struct et131x_adapter *pAdapter = NULL;
+	struct et131x_adapter *etdev = NULL;
 
 	DBG_TX_ENTER(et131x_dbginfo);
 
-	pAdapter = netdev_priv(netdev);
+	etdev = netdev_priv(netdev);
 
 	/* Send these packets
 	 *
@@ -390,8 +390,8 @@ int et131x_send_packets(struct sk_buff *
 	 */
 
 	/* Queue is not empty or TCB is not available */
-	if (!list_empty(&pAdapter->TxRing.SendWaitQueue) ||
-	    MP_TCB_RESOURCES_NOT_AVAILABLE(pAdapter)) {
+	if (!list_empty(&etdev->TxRing.SendWaitQueue) ||
+	    MP_TCB_RESOURCES_NOT_AVAILABLE(etdev)) {
 		/* NOTE: If there's an error on send, no need to queue the
 		 * packet under Linux; if we just send an error up to the
 		 * netif layer, it will resend the skb to us.
@@ -403,10 +403,10 @@ int et131x_send_packets(struct sk_buff *
 		 * netif layer think we're good and drop the packet
 		 */
 		/*
-		 * if( MP_SHOULD_FAIL_SEND( pAdapter ) ||
-		 *  pAdapter->DriverNoPhyAccess )
+		 * if( MP_SHOULD_FAIL_SEND( etdev ) ||
+		 *  etdev->DriverNoPhyAccess )
 		 */
-		if (MP_SHOULD_FAIL_SEND(pAdapter) || pAdapter->DriverNoPhyAccess
+		if (MP_SHOULD_FAIL_SEND(etdev) || etdev->DriverNoPhyAccess
 		    || !netif_carrier_ok(netdev)) {
 			DBG_VERBOSE(et131x_dbginfo,
 				"Can't Tx, Link is DOWN; drop the packet\n");
@@ -414,9 +414,9 @@ int et131x_send_packets(struct sk_buff *
 			dev_kfree_skb_any(skb);
 			skb = NULL;
 
-			pAdapter->net_stats.tx_dropped++;
+			etdev->net_stats.tx_dropped++;
 		} else {
-			status = et131x_send_packet(skb, pAdapter);
+			status = et131x_send_packet(skb, etdev);
 
 			if (status == -ENOMEM) {
 
@@ -437,7 +437,7 @@ int et131x_send_packets(struct sk_buff *
 				dev_kfree_skb_any(skb);
 				skb = NULL;
 
-				pAdapter->net_stats.tx_dropped++;
+				etdev->net_stats.tx_dropped++;
 			}
 		}
 	}
@@ -449,14 +449,14 @@ int et131x_send_packets(struct sk_buff *
 /**
  * et131x_send_packet - Do the work to send a packet
  * @skb: the packet(s) to send
- * @pAdapter: a pointer to the device's private adapter structure
+ * @etdev: a pointer to the device's private adapter structure
  *
  * Return 0 in almost all cases; non-zero value in extreme hard failure only.
  *
  * Assumption: Send spinlock has been acquired
  */
 static int et131x_send_packet(struct sk_buff *skb,
-			      struct et131x_adapter *pAdapter)
+			      struct et131x_adapter *etdev)
 {
 	int status = 0;
 	PMP_TCB pMpTcb = NULL;
@@ -482,24 +482,24 @@ static int et131x_send_packet(struct sk_
 	}
 
 	/* Get a TCB for this packet */
-	spin_lock_irqsave(&pAdapter->TCBReadyQLock, lockflags);
+	spin_lock_irqsave(&etdev->TCBReadyQLock, lockflags);
 
-	pMpTcb = pAdapter->TxRing.TCBReadyQueueHead;
+	pMpTcb = etdev->TxRing.TCBReadyQueueHead;
 
 	if (pMpTcb == NULL) {
-		spin_unlock_irqrestore(&pAdapter->TCBReadyQLock, lockflags);
+		spin_unlock_irqrestore(&etdev->TCBReadyQLock, lockflags);
 
 		DBG_WARNING(et131x_dbginfo, "Can't obtain a TCB\n");
 		DBG_TX_LEAVE(et131x_dbginfo);
 		return -ENOMEM;
 	}
 
-	pAdapter->TxRing.TCBReadyQueueHead = pMpTcb->Next;
+	etdev->TxRing.TCBReadyQueueHead = pMpTcb->Next;
 
-	if (pAdapter->TxRing.TCBReadyQueueHead == NULL)
-		pAdapter->TxRing.TCBReadyQueueTail = NULL;
+	if (etdev->TxRing.TCBReadyQueueHead == NULL)
+		etdev->TxRing.TCBReadyQueueTail = NULL;
 
-	spin_unlock_irqrestore(&pAdapter->TCBReadyQLock, lockflags);
+	spin_unlock_irqrestore(&etdev->TCBReadyQLock, lockflags);
 
 	pMpTcb->PacketLength = skb->len;
 	pMpTcb->Packet = skb;
@@ -519,27 +519,27 @@ static int et131x_send_packet(struct sk_
 
 	/* Call the NIC specific send handler. */
 	if (status == 0)
-		status = nic_send_packet(pAdapter, pMpTcb);
+		status = nic_send_packet(etdev, pMpTcb);
 
 	if (status != 0) {
-		spin_lock_irqsave(&pAdapter->TCBReadyQLock, lockflags);
+		spin_lock_irqsave(&etdev->TCBReadyQLock, lockflags);
 
-		if (pAdapter->TxRing.TCBReadyQueueTail) {
-			pAdapter->TxRing.TCBReadyQueueTail->Next = pMpTcb;
+		if (etdev->TxRing.TCBReadyQueueTail) {
+			etdev->TxRing.TCBReadyQueueTail->Next = pMpTcb;
 		} else {
 			/* Apparently ready Q is empty. */
-			pAdapter->TxRing.TCBReadyQueueHead = pMpTcb;
+			etdev->TxRing.TCBReadyQueueHead = pMpTcb;
 		}
 
-		pAdapter->TxRing.TCBReadyQueueTail = pMpTcb;
+		etdev->TxRing.TCBReadyQueueTail = pMpTcb;
 
-		spin_unlock_irqrestore(&pAdapter->TCBReadyQLock, lockflags);
+		spin_unlock_irqrestore(&etdev->TCBReadyQLock, lockflags);
 
 		DBG_TX_LEAVE(et131x_dbginfo);
 		return status;
 	}
 
-	DBG_ASSERT(pAdapter->TxRing.nBusySend <= NUM_TCB);
+	DBG_ASSERT(etdev->TxRing.nBusySend <= NUM_TCB);
 
 	DBG_TX_LEAVE(et131x_dbginfo);
 	return 0;
@@ -547,12 +547,12 @@ static int et131x_send_packet(struct sk_
 
 /**
  * nic_send_packet - NIC specific send handler for version B silicon.
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  * @pMpTcb: pointer to MP_TCB
  *
  * Returns 0 or errno.
  */
-static int nic_send_packet(struct et131x_adapter *pAdapter, PMP_TCB pMpTcb)
+static int nic_send_packet(struct et131x_adapter *etdev, PMP_TCB pMpTcb)
 {
 	uint32_t loopIndex;
 	TX_DESC_ENTRY_t CurDesc[24];
@@ -600,7 +600,7 @@ static int nic_send_packet(struct et131x
 				       "filling desc entry %d, "
 				       "TCB: 0x%p\n",
 				       (pPacket->len - pPacket->data_len),
-				       pAdapter->TxRing.txDmaReadyToSend.bits.
+				       etdev->TxRing.txDmaReadyToSend.bits.
 				       val, pMpTcb);
 
 				CurDesc[FragmentNumber].DataBufferPtrHigh = 0;
@@ -618,7 +618,7 @@ static int nic_send_packet(struct et131x
 				 * subsystem)
 				 */
 				CurDesc[FragmentNumber++].DataBufferPtrLow =
-				    pci_map_single(pAdapter->pdev,
+				    pci_map_single(etdev->pdev,
 						   pPacket->data,
 						   pPacket->len -
 						   pPacket->data_len,
@@ -629,7 +629,7 @@ static int nic_send_packet(struct et131x
 				       "filling desc entry %d, "
 				       "TCB: 0x%p\n",
 				       (pPacket->len - pPacket->data_len),
-				       pAdapter->TxRing.txDmaReadyToSend.bits.
+				       etdev->TxRing.txDmaReadyToSend.bits.
 				       val, pMpTcb);
 
 				CurDesc[FragmentNumber].DataBufferPtrHigh = 0;
@@ -647,7 +647,7 @@ static int nic_send_packet(struct et131x
 				 * subsystem)
 				 */
 				CurDesc[FragmentNumber++].DataBufferPtrLow =
-				    pci_map_single(pAdapter->pdev,
+				    pci_map_single(etdev->pdev,
 						   pPacket->data,
 						   ((pPacket->len -
 						     pPacket->data_len) / 2),
@@ -667,7 +667,7 @@ static int nic_send_packet(struct et131x
 				 * subsystem)
 				 */
 				CurDesc[FragmentNumber++].DataBufferPtrLow =
-				    pci_map_single(pAdapter->pdev,
+				    pci_map_single(etdev->pdev,
 						   pPacket->data +
 						   ((pPacket->len -
 						     pPacket->data_len) / 2),
@@ -681,7 +681,7 @@ static int nic_send_packet(struct et131x
 			       "filling desc entry %d\n"
 			       "TCB: 0x%p\n",
 			       pFragList[loopIndex].size,
-			       pAdapter->TxRing.txDmaReadyToSend.bits.val,
+			       etdev->TxRing.txDmaReadyToSend.bits.val,
 			       pMpTcb);
 
 			CurDesc[FragmentNumber].DataBufferPtrHigh = 0;
@@ -696,7 +696,7 @@ static int nic_send_packet(struct et131x
 			 * addressable (as defined by the pci/dma subsystem)
 			 */
 			CurDesc[FragmentNumber++].DataBufferPtrLow =
-			    pci_map_page(pAdapter->pdev,
+			    pci_map_page(etdev->pdev,
 					 pFragList[loopIndex - 1].page,
 					 pFragList[loopIndex - 1].page_offset,
 					 pFragList[loopIndex - 1].size,
@@ -709,11 +709,11 @@ static int nic_send_packet(struct et131x
 		return -EIO;
 	}
 
-	if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
-		if (++pAdapter->TxRing.TxPacketsSinceLastinterrupt ==
-		    pAdapter->RegistryTxNumBuffers) {
+	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+		if (++etdev->TxRing.TxPacketsSinceLastinterrupt ==
+		    etdev->RegistryTxNumBuffers) {
 			CurDesc[FragmentNumber - 1].word3.value = 0x5;
-			pAdapter->TxRing.TxPacketsSinceLastinterrupt = 0;
+			etdev->TxRing.TxPacketsSinceLastinterrupt = 0;
 		} else {
 			CurDesc[FragmentNumber - 1].word3.value = 0x1;
 		}
@@ -723,13 +723,13 @@ static int nic_send_packet(struct et131x
 
 	CurDesc[0].word3.bits.f = 1;
 
-	pMpTcb->WrIndexStart = pAdapter->TxRing.txDmaReadyToSend;
+	pMpTcb->WrIndexStart = etdev->TxRing.txDmaReadyToSend;
 	pMpTcb->PacketStaleCount = 0;
 
-	spin_lock_irqsave(&pAdapter->SendHWLock, lockflags1);
+	spin_lock_irqsave(&etdev->SendHWLock, lockflags1);
 
 	iThisCopy =
-	    NUM_DESC_PER_RING_TX - pAdapter->TxRing.txDmaReadyToSend.bits.val;
+	    NUM_DESC_PER_RING_TX - etdev->TxRing.txDmaReadyToSend.bits.val;
 
 	if (iThisCopy >= FragmentNumber) {
 		iRemainder = 0;
@@ -738,67 +738,67 @@ static int nic_send_packet(struct et131x
 		iRemainder = FragmentNumber - iThisCopy;
 	}
 
-	memcpy(pAdapter->TxRing.pTxDescRingVa +
-	       pAdapter->TxRing.txDmaReadyToSend.bits.val, CurDesc,
+	memcpy(etdev->TxRing.pTxDescRingVa +
+	       etdev->TxRing.txDmaReadyToSend.bits.val, CurDesc,
 	       sizeof(TX_DESC_ENTRY_t) * iThisCopy);
 
-	pAdapter->TxRing.txDmaReadyToSend.bits.val += iThisCopy;
+	etdev->TxRing.txDmaReadyToSend.bits.val += iThisCopy;
 
-	if ((pAdapter->TxRing.txDmaReadyToSend.bits.val == 0) ||
-	    (pAdapter->TxRing.txDmaReadyToSend.bits.val ==
+	if ((etdev->TxRing.txDmaReadyToSend.bits.val == 0) ||
+	    (etdev->TxRing.txDmaReadyToSend.bits.val ==
 	     NUM_DESC_PER_RING_TX)) {
-		if (pAdapter->TxRing.txDmaReadyToSend.bits.wrap)
-			pAdapter->TxRing.txDmaReadyToSend.value = 0;
+		if (etdev->TxRing.txDmaReadyToSend.bits.wrap)
+			etdev->TxRing.txDmaReadyToSend.value = 0;
 		else
-			pAdapter->TxRing.txDmaReadyToSend.value = 0x400;
+			etdev->TxRing.txDmaReadyToSend.value = 0x400;
 	}
 
 	if (iRemainder) {
-		memcpy(pAdapter->TxRing.pTxDescRingVa,
+		memcpy(etdev->TxRing.pTxDescRingVa,
 		       CurDesc + iThisCopy,
 		       sizeof(TX_DESC_ENTRY_t) * iRemainder);
 
-		pAdapter->TxRing.txDmaReadyToSend.bits.val += iRemainder;
+		etdev->TxRing.txDmaReadyToSend.bits.val += iRemainder;
 	}
 
-	if (pAdapter->TxRing.txDmaReadyToSend.bits.val == 0) {
-		if (pAdapter->TxRing.txDmaReadyToSend.value)
+	if (etdev->TxRing.txDmaReadyToSend.bits.val == 0) {
+		if (etdev->TxRing.txDmaReadyToSend.value)
 			pMpTcb->WrIndex.value = NUM_DESC_PER_RING_TX - 1;
 		else
 			pMpTcb->WrIndex.value =
 			    0x400 | (NUM_DESC_PER_RING_TX - 1);
 	} else
 		pMpTcb->WrIndex.value =
-		    pAdapter->TxRing.txDmaReadyToSend.value - 1;
+		    etdev->TxRing.txDmaReadyToSend.value - 1;
 
-	spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags2);
+	spin_lock_irqsave(&etdev->TCBSendQLock, lockflags2);
 
-	if (pAdapter->TxRing.CurrSendTail)
-		pAdapter->TxRing.CurrSendTail->Next = pMpTcb;
+	if (etdev->TxRing.CurrSendTail)
+		etdev->TxRing.CurrSendTail->Next = pMpTcb;
 	else
-		pAdapter->TxRing.CurrSendHead = pMpTcb;
+		etdev->TxRing.CurrSendHead = pMpTcb;
 
-	pAdapter->TxRing.CurrSendTail = pMpTcb;
+	etdev->TxRing.CurrSendTail = pMpTcb;
 
 	DBG_ASSERT(pMpTcb->Next == NULL);
 
-	pAdapter->TxRing.nBusySend++;
+	etdev->TxRing.nBusySend++;
 
-	spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags2);
+	spin_unlock_irqrestore(&etdev->TCBSendQLock, lockflags2);
 
 	/* Write the new write pointer back to the device. */
-	writel(pAdapter->TxRing.txDmaReadyToSend.value,
-	       &pAdapter->CSRAddress->txdma.service_request.value);
+	writel(etdev->TxRing.txDmaReadyToSend.value,
+	       &etdev->CSRAddress->txdma.service_request.value);
 
 	/* For Gig only, we use Tx Interrupt coalescing.  Enable the software
 	 * timer to wake us up if this packet isn't followed by N more.
 	 */
-	if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
-		writel(pAdapter->RegistryTxTimeInterval * NANO_IN_A_MICRO,
-		       &pAdapter->CSRAddress->global.watchdog_timer);
+	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+		writel(etdev->RegistryTxTimeInterval * NANO_IN_A_MICRO,
+		       &etdev->CSRAddress->global.watchdog_timer);
 	}
 
-	spin_unlock_irqrestore(&pAdapter->SendHWLock, lockflags1);
+	spin_unlock_irqrestore(&etdev->SendHWLock, lockflags1);
 
 	DBG_TX_LEAVE(et131x_dbginfo);
 	return 0;
@@ -812,7 +812,7 @@ static int nic_send_packet(struct et131x
 
 /**
  * NICSendPacket - NIC specific send handler.
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  * @pMpTcb: pointer to MP_TCB
  *
  * Returns 0 on succes, errno on failure.
@@ -820,7 +820,7 @@ static int nic_send_packet(struct et131x
  * This version of the send routine is designed for version A silicon.
  * Assumption - Send spinlock has been acquired.
  */
-static int nic_send_packet(struct et131x_adapter *pAdapter, PMP_TCB pMpTcb)
+static int nic_send_packet(struct et131x_adapter *etdev, PMP_TCB pMpTcb)
 {
 	uint32_t loopIndex, fragIndex, loopEnd;
 	uint32_t iSplitFirstElement = 0;
@@ -837,7 +837,7 @@ static int nic_send_packet(struct et131x
 	DBG_TX_ENTER(et131x_dbginfo);
 
 	ServiceComplete.value =
-		readl(&pAdapter->CSRAddress->txdma.NewServiceComplete.value);
+		readl(&etdev->CSRAddress->txdma.NewServiceComplete.value);
 
 	/*
 	 * Attempt to fix TWO hardware bugs:
@@ -856,7 +856,7 @@ static int nic_send_packet(struct et131x
 	DBG_TX(et131x_dbginfo,
 	       "pMpTcb->PacketLength: %d\n", pMpTcb->PacketLength);
 
-	if ((pAdapter->uiDuplexMode == 0)
+	if ((etdev->uiDuplexMode == 0)
 	    && (pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE)) {
 		DBG_TX(et131x_dbginfo,
 		       "HALF DUPLEX mode AND len < MIN_PKT_SIZE\n");
@@ -875,28 +875,28 @@ static int nic_send_packet(struct et131x
 		SegmentSize = (pPacket->len - pPacket->data_len) / 2;
 	}
 
-	spin_lock_irqsave(&pAdapter->SendHWLock, lockflags1);
+	spin_lock_irqsave(&etdev->SendHWLock, lockflags1);
 
-	if (pAdapter->TxRing.txDmaReadyToSend.bits.serv_req_wrap ==
+	if (etdev->TxRing.txDmaReadyToSend.bits.serv_req_wrap ==
 	    ServiceComplete.bits.serv_cpl_wrap) {
 		/* The ring hasn't wrapped.  Slots available should be
 		 * (RING_SIZE) -  the difference between the two pointers.
 		 */
 		SlotsAvailable = NUM_DESC_PER_RING_TX -
-		    (pAdapter->TxRing.txDmaReadyToSend.bits.serv_req -
+		    (etdev->TxRing.txDmaReadyToSend.bits.serv_req -
 		     ServiceComplete.bits.serv_cpl);
 	} else {
 		/* The ring has wrapped.  Slots available should be the
 		 * difference between the two pointers.
 		 */
 		SlotsAvailable = ServiceComplete.bits.serv_cpl -
-		    pAdapter->TxRing.txDmaReadyToSend.bits.serv_req;
+		    etdev->TxRing.txDmaReadyToSend.bits.serv_req;
 	}
 
 	if ((FragListCount + iSplitFirstElement) > SlotsAvailable) {
 		DBG_WARNING(et131x_dbginfo,
 			    "Not Enough Space in Tx Desc Ring\n");
-		spin_unlock_irqrestore(&pAdapter->SendHWLock, lockflags1);
+		spin_unlock_irqrestore(&etdev->SendHWLock, lockflags1);
 		return -ENOMEM;
 	}
 
@@ -926,7 +926,7 @@ static int nic_send_packet(struct et131x
 		       "Packet Length %d,"
 		       "filling desc entry %d\n",
 		       pPacket->len,
-		       pAdapter->TxRing.txDmaReadyToSend.bits.serv_req);
+		       etdev->TxRing.txDmaReadyToSend.bits.serv_req);
 
 		/*
 		 * NOTE - Should we do a paranoia check here to make sure the fragment
@@ -962,7 +962,7 @@ static int nic_send_packet(struct et131x
 						    length_in_bytes =
 						    SegmentSize;
 						CurDesc.DataBufferPtrLow =
-						    pci_map_single(pAdapter->
+						    pci_map_single(etdev->
 								   pdev,
 								   pPacket->
 								   data,
@@ -990,7 +990,7 @@ static int nic_send_packet(struct et131x
 						      pPacket->data_len) -
 						     SegmentSize);
 						CurDesc.DataBufferPtrLow =
-						    pci_map_single(pAdapter->
+						    pci_map_single(etdev->
 								   pdev,
 								   (pPacket->
 								    data +
@@ -1014,7 +1014,7 @@ static int nic_send_packet(struct et131x
 					    pPacket->len - pPacket->data_len;
 
 					CurDesc.DataBufferPtrLow =
-					    pci_map_single(pAdapter->pdev,
+					    pci_map_single(etdev->pdev,
 							   pPacket->data,
 							   (pPacket->len -
 							    pPacket->data_len),
@@ -1028,7 +1028,7 @@ static int nic_send_packet(struct et131x
 				CurDesc.word2.bits.length_in_bytes =
 				    pFragList[fragIndex - 1].size;
 				CurDesc.DataBufferPtrLow =
-				    pci_map_page(pAdapter->pdev,
+				    pci_map_page(etdev->pdev,
 						 pFragList[fragIndex - 1].page,
 						 pFragList[fragIndex -
 							   1].page_offset,
@@ -1050,23 +1050,23 @@ static int nic_send_packet(struct et131x
 				CurDesc.word3.bits.f = 1;
 
 				pMpTcb->WrIndexStart =
-				    pAdapter->TxRing.txDmaReadyToSend;
+				    etdev->TxRing.txDmaReadyToSend;
 			}
 
 			if ((loopIndex == (loopEnd - 1)) &&
-			    (pAdapter->uiDuplexMode ||
+			    (etdev->uiDuplexMode ||
 			     (pMpTcb->PacketLength >= NIC_MIN_PACKET_SIZE))) {
 				/* This is the Last descriptor of the packet */
 				DBG_TX(et131x_dbginfo,
 				       "THIS is our LAST descriptor\n");
 
-				if (pAdapter->uiLinkSpeed ==
+				if (etdev->uiLinkSpeed ==
 				    TRUEPHY_SPEED_1000MBPS) {
-					if (++pAdapter->TxRing.
+					if (++etdev->TxRing.
 					    TxPacketsSinceLastinterrupt >=
-					    pAdapter->RegistryTxNumBuffers) {
+					    etdev->RegistryTxNumBuffers) {
 						CurDesc.word3.value = 0x5;
-						pAdapter->TxRing.
+						etdev->TxRing.
 						    TxPacketsSinceLastinterrupt
 						    = 0;
 					} else {
@@ -1080,7 +1080,7 @@ static int nic_send_packet(struct et131x
 				 * of packet
 				 */
 				pMpTcb->WrIndex =
-				    pAdapter->TxRing.txDmaReadyToSend;
+				    etdev->TxRing.txDmaReadyToSend;
 				pMpTcb->PacketStaleCount = 0;
 			}
 
@@ -1088,13 +1088,13 @@ static int nic_send_packet(struct et131x
 			 * descriptor ring at the next free entry.  Advance
 			 * the "next free entry" variable
 			 */
-			memcpy(pAdapter->TxRing.pTxDescRingVa +
-			       pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+			memcpy(etdev->TxRing.pTxDescRingVa +
+			       etdev->TxRing.txDmaReadyToSend.bits.serv_req,
 			       &CurDesc, sizeof(TX_DESC_ENTRY_t));
 
 			CurDescPostCopy =
-			    pAdapter->TxRing.pTxDescRingVa +
-			    pAdapter->TxRing.txDmaReadyToSend.bits.serv_req;
+			    etdev->TxRing.pTxDescRingVa +
+			    etdev->TxRing.txDmaReadyToSend.bits.serv_req;
 
 			DBG_TX(et131x_dbginfo,
 			       "CURRENT DESCRIPTOR\n"
@@ -1109,32 +1109,32 @@ static int nic_send_packet(struct et131x
 			       CurDescPostCopy->word2.value,
 			       CurDescPostCopy->word3.value);
 
-			if (++pAdapter->TxRing.txDmaReadyToSend.bits.serv_req >=
+			if (++etdev->TxRing.txDmaReadyToSend.bits.serv_req >=
 			    NUM_DESC_PER_RING_TX) {
-				if (pAdapter->TxRing.txDmaReadyToSend.bits.
+				if (etdev->TxRing.txDmaReadyToSend.bits.
 				    serv_req_wrap) {
-					pAdapter->TxRing.txDmaReadyToSend.
+					etdev->TxRing.txDmaReadyToSend.
 					    value = 0;
 				} else {
-					pAdapter->TxRing.txDmaReadyToSend.
+					etdev->TxRing.txDmaReadyToSend.
 					    value = 0x400;
 				}
 			}
 		}
 	}
 
-	if (pAdapter->uiDuplexMode == 0 &&
+	if (etdev->uiDuplexMode == 0 &&
 	    pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE) {
 		/* NOTE - Same 32/64-bit issue as above... */
 		CurDesc.DataBufferPtrHigh = 0x0;
-		CurDesc.DataBufferPtrLow = pAdapter->TxRing.pTxDummyBlkPa;
+		CurDesc.DataBufferPtrLow = etdev->TxRing.pTxDummyBlkPa;
 		CurDesc.word2.value = 0;
 
-		if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
-			if (++pAdapter->TxRing.TxPacketsSinceLastinterrupt >=
-			    pAdapter->RegistryTxNumBuffers) {
+		if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+			if (++etdev->TxRing.TxPacketsSinceLastinterrupt >=
+			    etdev->RegistryTxNumBuffers) {
 				CurDesc.word3.value = 0x5;
-				pAdapter->TxRing.TxPacketsSinceLastinterrupt =
+				etdev->TxRing.TxPacketsSinceLastinterrupt =
 				    0;
 			} else {
 				CurDesc.word3.value = 0x1;
@@ -1146,15 +1146,15 @@ static int nic_send_packet(struct et131x
 		CurDesc.word2.bits.length_in_bytes =
 		    NIC_MIN_PACKET_SIZE - pMpTcb->PacketLength;
 
-		pMpTcb->WrIndex = pAdapter->TxRing.txDmaReadyToSend;
+		pMpTcb->WrIndex = etdev->TxRing.txDmaReadyToSend;
 
-		memcpy(pAdapter->TxRing.pTxDescRingVa +
-		       pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+		memcpy(etdev->TxRing.pTxDescRingVa +
+		       etdev->TxRing.txDmaReadyToSend.bits.serv_req,
 		       &CurDesc, sizeof(TX_DESC_ENTRY_t));
 
 		CurDescPostCopy =
-		    pAdapter->TxRing.pTxDescRingVa +
-		    pAdapter->TxRing.txDmaReadyToSend.bits.serv_req;
+		    etdev->TxRing.pTxDescRingVa +
+		    etdev->TxRing.txDmaReadyToSend.bits.serv_req;
 
 		DBG_TX(et131x_dbginfo,
 		       "CURRENT DESCRIPTOR\n"
@@ -1169,54 +1169,54 @@ static int nic_send_packet(struct et131x
 		       CurDescPostCopy->word2.value,
 		       CurDescPostCopy->word3.value);
 
-		if (++pAdapter->TxRing.txDmaReadyToSend.bits.serv_req >=
+		if (++etdev->TxRing.txDmaReadyToSend.bits.serv_req >=
 		    NUM_DESC_PER_RING_TX) {
-			if (pAdapter->TxRing.txDmaReadyToSend.bits.
+			if (etdev->TxRing.txDmaReadyToSend.bits.
 			    serv_req_wrap) {
-				pAdapter->TxRing.txDmaReadyToSend.value = 0;
+				etdev->TxRing.txDmaReadyToSend.value = 0;
 			} else {
-				pAdapter->TxRing.txDmaReadyToSend.value = 0x400;
+				etdev->TxRing.txDmaReadyToSend.value = 0x400;
 			}
 		}
 
 		DBG_TX(et131x_dbginfo, "Padding descriptor %d by %d bytes\n",
-		       /* pAdapter->TxRing.txDmaReadyToSend.value, */
-		       pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+		       /* etdev->TxRing.txDmaReadyToSend.value, */
+		       etdev->TxRing.txDmaReadyToSend.bits.serv_req,
 		       NIC_MIN_PACKET_SIZE - pMpTcb->PacketLength);
 	}
 
-	spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags2);
+	spin_lock_irqsave(&etdev->TCBSendQLock, lockflags2);
 
-	if (pAdapter->TxRing.CurrSendTail)
-		pAdapter->TxRing.CurrSendTail->Next = pMpTcb;
+	if (etdev->TxRing.CurrSendTail)
+		etdev->TxRing.CurrSendTail->Next = pMpTcb;
 	else
-		pAdapter->TxRing.CurrSendHead = pMpTcb;
+		etdev->TxRing.CurrSendHead = pMpTcb;
 
-	pAdapter->TxRing.CurrSendTail = pMpTcb;
+	etdev->TxRing.CurrSendTail = pMpTcb;
 
 	DBG_ASSERT(pMpTcb->Next == NULL);
 
-	pAdapter->TxRing.nBusySend++;
+	etdev->TxRing.nBusySend++;
 
-	spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags2);
+	spin_unlock_irqrestore(&etdev->TCBSendQLock, lockflags2);
 
 	/* Write the new write pointer back to the device. */
-	writel(pAdapter->TxRing.txDmaReadyToSend.value,
-	       &pAdapter->CSRAddress->txdma.service_request.value);
+	writel(etdev->TxRing.txDmaReadyToSend.value,
+	       &etdev->CSRAddress->txdma.service_request.value);
 
 #ifdef CONFIG_ET131X_DEBUG
-	DumpDeviceBlock(DBG_TX_ON, pAdapter, 1);
+	DumpDeviceBlock(DBG_TX_ON, etdev, 1);
 #endif
 
 	/* For Gig only, we use Tx Interrupt coalescing.  Enable the software
 	 * timer to wake us up if this packet isn't followed by N more.
 	 */
-	if (pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
-		writel(pAdapter->RegistryTxTimeInterval * NANO_IN_A_MICRO,
-		       &pAdapter->CSRAddress->global.watchdog_timer);
+	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+		writel(etdev->RegistryTxTimeInterval * NANO_IN_A_MICRO,
+		       &etdev->CSRAddress->global.watchdog_timer);
 	}
 
-	spin_unlock_irqrestore(&pAdapter->SendHWLock, lockflags1);
+	spin_unlock_irqrestore(&etdev->SendHWLock, lockflags1);
 
 	DBG_TX_LEAVE(et131x_dbginfo);
 	return 0;
@@ -1226,24 +1226,24 @@ static int nic_send_packet(struct et131x
 
 /**
  * et131x_free_send_packet - Recycle a MP_TCB, complete the packet if necessary
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  * @pMpTcb: pointer to MP_TCB
  *
  * Assumption - Send spinlock has been acquired
  */
-inline void et131x_free_send_packet(struct et131x_adapter *pAdapter,
+inline void et131x_free_send_packet(struct et131x_adapter *etdev,
 							PMP_TCB pMpTcb)
 {
 	unsigned long lockflags;
 	TX_DESC_ENTRY_t *desc = NULL;
-	struct net_device_stats *stats = &pAdapter->net_stats;
+	struct net_device_stats *stats = &etdev->net_stats;
 
 	if (MP_TEST_FLAG(pMpTcb, fMP_DEST_BROAD))
-		atomic_inc(&pAdapter->Stats.brdcstxmt);
+		atomic_inc(&etdev->Stats.brdcstxmt);
 	else if (MP_TEST_FLAG(pMpTcb, fMP_DEST_MULTI))
-		atomic_inc(&pAdapter->Stats.multixmt);
+		atomic_inc(&etdev->Stats.multixmt);
 	else
-		atomic_inc(&pAdapter->Stats.unixmt);
+		atomic_inc(&etdev->Stats.unixmt);
 
 	if (pMpTcb->Packet) {
 		stats->tx_bytes += pMpTcb->Packet->len;
@@ -1271,7 +1271,7 @@ inline void et131x_free_send_packet(stru
 
 		do {
 			desc =
-			    (TX_DESC_ENTRY_t *) (pAdapter->TxRing.
+			    (TX_DESC_ENTRY_t *) (etdev->TxRing.
 						 pTxDescRingVa +
 						 pMpTcb->WrIndexStart.bits.val);
 
@@ -1288,7 +1288,7 @@ inline void et131x_free_send_packet(stru
 			       desc->word2.value,
 			       desc->word3.value);
 
-			pci_unmap_single(pAdapter->pdev,
+			pci_unmap_single(etdev->pdev,
 					 desc->DataBufferPtrLow,
 					 desc->word2.value, PCI_DMA_TODEVICE);
 
@@ -1299,7 +1299,7 @@ inline void et131x_free_send_packet(stru
 				else
 					pMpTcb->WrIndexStart.value = 0x400;
 			}
-		} while (desc != (pAdapter->TxRing.pTxDescRingVa +
+		} while (desc != (etdev->TxRing.pTxDescRingVa +
 				pMpTcb->WrIndex.bits.val));
 
 		DBG_TX(et131x_dbginfo,
@@ -1311,31 +1311,31 @@ inline void et131x_free_send_packet(stru
 	memset(pMpTcb, 0, sizeof(MP_TCB));
 
 	/* Add the TCB to the Ready Q */
-	spin_lock_irqsave(&pAdapter->TCBReadyQLock, lockflags);
+	spin_lock_irqsave(&etdev->TCBReadyQLock, lockflags);
 
-	pAdapter->Stats.opackets++;
+	etdev->Stats.opackets++;
 
-	if (pAdapter->TxRing.TCBReadyQueueTail) {
-		pAdapter->TxRing.TCBReadyQueueTail->Next = pMpTcb;
+	if (etdev->TxRing.TCBReadyQueueTail) {
+		etdev->TxRing.TCBReadyQueueTail->Next = pMpTcb;
 	} else {
 		/* Apparently ready Q is empty. */
-		pAdapter->TxRing.TCBReadyQueueHead = pMpTcb;
+		etdev->TxRing.TCBReadyQueueHead = pMpTcb;
 	}
 
-	pAdapter->TxRing.TCBReadyQueueTail = pMpTcb;
+	etdev->TxRing.TCBReadyQueueTail = pMpTcb;
 
-	spin_unlock_irqrestore(&pAdapter->TCBReadyQLock, lockflags);
+	spin_unlock_irqrestore(&etdev->TCBReadyQLock, lockflags);
 
-	DBG_ASSERT(pAdapter->TxRing.nBusySend >= 0);
+	DBG_ASSERT(etdev->TxRing.nBusySend >= 0);
 }
 
 /**
  * et131x_free_busy_send_packets - Free and complete the stopped active sends
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Assumption - Send spinlock has been acquired
  */
-void et131x_free_busy_send_packets(struct et131x_adapter *pAdapter)
+void et131x_free_busy_send_packets(struct et131x_adapter *etdev)
 {
 	PMP_TCB pMpTcb;
 	struct list_head *pEntry;
@@ -1344,42 +1344,42 @@ void et131x_free_busy_send_packets(struc
 
 	DBG_ENTER(et131x_dbginfo);
 
-	while (!list_empty(&pAdapter->TxRing.SendWaitQueue)) {
-		spin_lock_irqsave(&pAdapter->SendWaitLock, lockflags);
+	while (!list_empty(&etdev->TxRing.SendWaitQueue)) {
+		spin_lock_irqsave(&etdev->SendWaitLock, lockflags);
 
-		pAdapter->TxRing.nWaitSend--;
-		spin_unlock_irqrestore(&pAdapter->SendWaitLock, lockflags);
+		etdev->TxRing.nWaitSend--;
+		spin_unlock_irqrestore(&etdev->SendWaitLock, lockflags);
 
-		pEntry = pAdapter->TxRing.SendWaitQueue.next;
+		pEntry = etdev->TxRing.SendWaitQueue.next;
 	}
 
-	pAdapter->TxRing.nWaitSend = 0;
+	etdev->TxRing.nWaitSend = 0;
 
 	/* Any packets being sent? Check the first TCB on the send list */
-	spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags);
+	spin_lock_irqsave(&etdev->TCBSendQLock, lockflags);
 
-	pMpTcb = pAdapter->TxRing.CurrSendHead;
+	pMpTcb = etdev->TxRing.CurrSendHead;
 
 	while ((pMpTcb != NULL) && (FreeCounter < NUM_TCB)) {
 		PMP_TCB pNext = pMpTcb->Next;
 
-		pAdapter->TxRing.CurrSendHead = pNext;
+		etdev->TxRing.CurrSendHead = pNext;
 
 		if (pNext == NULL)
-			pAdapter->TxRing.CurrSendTail = NULL;
+			etdev->TxRing.CurrSendTail = NULL;
 
-		pAdapter->TxRing.nBusySend--;
+		etdev->TxRing.nBusySend--;
 
-		spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
+		spin_unlock_irqrestore(&etdev->TCBSendQLock, lockflags);
 
 		DBG_VERBOSE(et131x_dbginfo, "pMpTcb = 0x%p\n", pMpTcb);
 
 		FreeCounter++;
-		MP_FREE_SEND_PACKET_FUN(pAdapter, pMpTcb);
+		MP_FREE_SEND_PACKET_FUN(etdev, pMpTcb);
 
-		spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags);
+		spin_lock_irqsave(&etdev->TCBSendQLock, lockflags);
 
-		pMpTcb = pAdapter->TxRing.CurrSendHead;
+		pMpTcb = etdev->TxRing.CurrSendHead;
 	}
 
 	if (FreeCounter == NUM_TCB) {
@@ -1388,125 +1388,125 @@ void et131x_free_busy_send_packets(struc
 		BUG();
 	}
 
-	spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
+	spin_unlock_irqrestore(&etdev->TCBSendQLock, lockflags);
 
-	pAdapter->TxRing.nBusySend = 0;
+	etdev->TxRing.nBusySend = 0;
 
 	DBG_LEAVE(et131x_dbginfo);
 }
 
 /**
  * et131x_handle_send_interrupt - Interrupt handler for sending processing
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Re-claim the send resources, complete sends and get more to send from
  * the send wait queue.
  *
  * Assumption - Send spinlock has been acquired
  */
-void et131x_handle_send_interrupt(struct et131x_adapter *pAdapter)
+void et131x_handle_send_interrupt(struct et131x_adapter *etdev)
 {
 	DBG_TX_ENTER(et131x_dbginfo);
 
 	/* Mark as completed any packets which have been sent by the device. */
-	et131x_update_tcb_list(pAdapter);
+	et131x_update_tcb_list(etdev);
 
 	/* If we queued any transmits because we didn't have any TCBs earlier,
 	 * dequeue and send those packets now, as long as we have free TCBs.
 	 */
-	et131x_check_send_wait_list(pAdapter);
+	et131x_check_send_wait_list(etdev);
 
 	DBG_TX_LEAVE(et131x_dbginfo);
 }
 
 /**
  * et131x_update_tcb_list - Helper routine for Send Interrupt handler
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Re-claims the send resources and completes sends.  Can also be called as
  * part of the NIC send routine when the "ServiceComplete" indication has
  * wrapped.
  */
-static void et131x_update_tcb_list(struct et131x_adapter *pAdapter)
+static void et131x_update_tcb_list(struct et131x_adapter *etdev)
 {
 	unsigned long lockflags;
 	DMA10W_t ServiceComplete;
 	PMP_TCB pMpTcb;
 
 	ServiceComplete.value =
-	    readl(&pAdapter->CSRAddress->txdma.NewServiceComplete.value);
+	    readl(&etdev->CSRAddress->txdma.NewServiceComplete.value);
 
 	/* Has the ring wrapped?  Process any descriptors that do not have
 	 * the same "wrap" indicator as the current completion indicator
 	 */
-	spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags);
+	spin_lock_irqsave(&etdev->TCBSendQLock, lockflags);
 
-	pMpTcb = pAdapter->TxRing.CurrSendHead;
+	pMpTcb = etdev->TxRing.CurrSendHead;
 	while (pMpTcb &&
 	       ServiceComplete.bits.wrap != pMpTcb->WrIndex.bits.wrap  &&
 	       ServiceComplete.bits.val < pMpTcb->WrIndex.bits.val) {
-		pAdapter->TxRing.nBusySend--;
-		pAdapter->TxRing.CurrSendHead = pMpTcb->Next;
+		etdev->TxRing.nBusySend--;
+		etdev->TxRing.CurrSendHead = pMpTcb->Next;
 		if (pMpTcb->Next == NULL)
-			pAdapter->TxRing.CurrSendTail = NULL;
+			etdev->TxRing.CurrSendTail = NULL;
 
-		spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
-		MP_FREE_SEND_PACKET_FUN(pAdapter, pMpTcb);
-		spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags);
+		spin_unlock_irqrestore(&etdev->TCBSendQLock, lockflags);
+		MP_FREE_SEND_PACKET_FUN(etdev, pMpTcb);
+		spin_lock_irqsave(&etdev->TCBSendQLock, lockflags);
 
 		/* Goto the next packet */
-		pMpTcb = pAdapter->TxRing.CurrSendHead;
+		pMpTcb = etdev->TxRing.CurrSendHead;
 	}
 	while (pMpTcb &&
 	       ServiceComplete.bits.wrap == pMpTcb->WrIndex.bits.wrap &&
 	       ServiceComplete.bits.val > pMpTcb->WrIndex.bits.val) {
-		pAdapter->TxRing.nBusySend--;
-		pAdapter->TxRing.CurrSendHead = pMpTcb->Next;
+		etdev->TxRing.nBusySend--;
+		etdev->TxRing.CurrSendHead = pMpTcb->Next;
 		if (pMpTcb->Next == NULL)
-			pAdapter->TxRing.CurrSendTail = NULL;
+			etdev->TxRing.CurrSendTail = NULL;
 
-		spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
-		MP_FREE_SEND_PACKET_FUN(pAdapter, pMpTcb);
-		spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags);
+		spin_unlock_irqrestore(&etdev->TCBSendQLock, lockflags);
+		MP_FREE_SEND_PACKET_FUN(etdev, pMpTcb);
+		spin_lock_irqsave(&etdev->TCBSendQLock, lockflags);
 
 		/* Goto the next packet */
-		pMpTcb = pAdapter->TxRing.CurrSendHead;
+		pMpTcb = etdev->TxRing.CurrSendHead;
 	}
 
 	/* Wake up the queue when we hit a low-water mark */
-	if (pAdapter->TxRing.nBusySend <= (NUM_TCB / 3))
-		netif_wake_queue(pAdapter->netdev);
+	if (etdev->TxRing.nBusySend <= (NUM_TCB / 3))
+		netif_wake_queue(etdev->netdev);
 
-	spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
+	spin_unlock_irqrestore(&etdev->TCBSendQLock, lockflags);
 }
 
 /**
  * et131x_check_send_wait_list - Helper routine for the interrupt handler
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Takes packets from the send wait queue and posts them to the device (if
  * room available).
  */
-static void et131x_check_send_wait_list(struct et131x_adapter *pAdapter)
+static void et131x_check_send_wait_list(struct et131x_adapter *etdev)
 {
 	unsigned long lockflags;
 
-	spin_lock_irqsave(&pAdapter->SendWaitLock, lockflags);
+	spin_lock_irqsave(&etdev->SendWaitLock, lockflags);
 
-	while (!list_empty(&pAdapter->TxRing.SendWaitQueue) &&
-				MP_TCB_RESOURCES_AVAILABLE(pAdapter)) {
+	while (!list_empty(&etdev->TxRing.SendWaitQueue) &&
+				MP_TCB_RESOURCES_AVAILABLE(etdev)) {
 		struct list_head *pEntry;
 
 		DBG_VERBOSE(et131x_dbginfo, "Tx packets on the wait queue\n");
 
-		pEntry = pAdapter->TxRing.SendWaitQueue.next;
+		pEntry = etdev->TxRing.SendWaitQueue.next;
 
-		pAdapter->TxRing.nWaitSend--;
+		etdev->TxRing.nWaitSend--;
 
 		DBG_WARNING(et131x_dbginfo,
 		    "MpHandleSendInterrupt - sent a queued pkt. Waiting %d\n",
-				pAdapter->TxRing.nWaitSend);
+				etdev->TxRing.nWaitSend);
 	}
 
-	spin_unlock_irqrestore(&pAdapter->SendWaitLock, lockflags);
+	spin_unlock_irqrestore(&etdev->SendWaitLock, lockflags);
 }
--- a/drivers/staging/et131x/et131x_config.c
+++ b/drivers/staging/et131x/et131x_config.c
@@ -202,12 +202,12 @@ MODULE_PARM_DESC(et131x_speed_set,
 
 /**
  * et131x_config_parse
- * @pAdapter: pointer to the private adapter struct
+ * @etdev: pointer to the private adapter struct
  *
  * Parses a configuration from some location (module parameters, for example)
  * into the private adapter struct
  */
-void et131x_config_parse(struct et131x_adapter *pAdapter)
+void et131x_config_parse(struct et131x_adapter *etdev)
 {
 	uint8_t macAddrDef[] = PARM_MAC_ADDRESS_DEF;
 
@@ -237,85 +237,85 @@ void et131x_config_parse(struct et131x_a
 	if (et131x_speed_set != PARM_SPEED_DUPLEX_DEF) {
 		DBG_VERBOSE(et131x_dbginfo, "Speed set manually to : %d \n",
 			    et131x_speed_set);
-		pAdapter->SpeedDuplex = et131x_speed_set;
+		etdev->SpeedDuplex = et131x_speed_set;
 	} else {
-		pAdapter->SpeedDuplex = PARM_SPEED_DUPLEX_DEF;
+		etdev->SpeedDuplex = PARM_SPEED_DUPLEX_DEF;
 	}
 
-	/*  pAdapter->SpeedDuplex            = PARM_SPEED_DUPLEX_DEF; */
+	/*  etdev->SpeedDuplex            = PARM_SPEED_DUPLEX_DEF; */
 
-	pAdapter->RegistryVlanTag = PARM_VLAN_TAG_DEF;
-	pAdapter->RegistryFlowControl = PARM_FLOW_CTL_DEF;
-	pAdapter->RegistryWOLLink = PARM_WOL_LINK_DEF;
-	pAdapter->RegistryWOLMatch = PARM_WOL_MATCH_DEF;
-	pAdapter->RegistryJumboPacket = PARM_JUMBO_PKT_DEF;
-	pAdapter->RegistryPhyComa = PARM_PHY_COMA_DEF;
-	pAdapter->RegistryRxNumBuffers = PARM_RX_NUM_BUFS_DEF;
-	pAdapter->RegistryRxTimeInterval = PARM_RX_TIME_INT_DEF;
-	pAdapter->RegistryTxNumBuffers = PARM_TX_NUM_BUFS_DEF;
-	pAdapter->RegistryTxTimeInterval = PARM_TX_TIME_INT_DEF;
-	pAdapter->RegistryRxMemEnd = PARM_RX_MEM_END_DEF;
-	pAdapter->RegistryMACStat = PARM_MAC_STAT_DEF;
-	pAdapter->RegistrySCGain = PARM_SC_GAIN_DEF;
-	pAdapter->RegistryPMWOL = PARM_PM_WOL_DEF;
+	etdev->RegistryVlanTag = PARM_VLAN_TAG_DEF;
+	etdev->RegistryFlowControl = PARM_FLOW_CTL_DEF;
+	etdev->RegistryWOLLink = PARM_WOL_LINK_DEF;
+	etdev->RegistryWOLMatch = PARM_WOL_MATCH_DEF;
+	etdev->RegistryJumboPacket = PARM_JUMBO_PKT_DEF;
+	etdev->RegistryPhyComa = PARM_PHY_COMA_DEF;
+	etdev->RegistryRxNumBuffers = PARM_RX_NUM_BUFS_DEF;
+	etdev->RegistryRxTimeInterval = PARM_RX_TIME_INT_DEF;
+	etdev->RegistryTxNumBuffers = PARM_TX_NUM_BUFS_DEF;
+	etdev->RegistryTxTimeInterval = PARM_TX_TIME_INT_DEF;
+	etdev->RegistryRxMemEnd = PARM_RX_MEM_END_DEF;
+	etdev->RegistryMACStat = PARM_MAC_STAT_DEF;
+	etdev->RegistrySCGain = PARM_SC_GAIN_DEF;
+	etdev->RegistryPMWOL = PARM_PM_WOL_DEF;
 
 	if (et131x_nmi_disable != PARM_NMI_DISABLE_DEF)
-		pAdapter->RegistryNMIDisable = et131x_nmi_disable;
+		etdev->RegistryNMIDisable = et131x_nmi_disable;
 	else
-		pAdapter->RegistryNMIDisable = PARM_NMI_DISABLE_DEF;
+		etdev->RegistryNMIDisable = PARM_NMI_DISABLE_DEF;
 
-	pAdapter->RegistryDMACache = PARM_DMA_CACHE_DEF;
-	pAdapter->RegistryPhyLoopbk = PARM_PHY_LOOPBK_DEF;
+	etdev->RegistryDMACache = PARM_DMA_CACHE_DEF;
+	etdev->RegistryPhyLoopbk = PARM_PHY_LOOPBK_DEF;
 
 	/* Set the MAC address to a default */
-	memcpy(pAdapter->CurrentAddress, macAddrDef, ETH_ALEN);
-	pAdapter->bOverrideAddress = false;
+	memcpy(etdev->CurrentAddress, macAddrDef, ETH_ALEN);
+	etdev->bOverrideAddress = false;
 
 	DBG_TRACE(et131x_dbginfo,
 		  "Default MAC Address  : %02x:%02x:%02x:%02x:%02x:%02x\n",
-		  pAdapter->CurrentAddress[0], pAdapter->CurrentAddress[1],
-		  pAdapter->CurrentAddress[2], pAdapter->CurrentAddress[3],
-		  pAdapter->CurrentAddress[4], pAdapter->CurrentAddress[5]);
+		  etdev->CurrentAddress[0], etdev->CurrentAddress[1],
+		  etdev->CurrentAddress[2], etdev->CurrentAddress[3],
+		  etdev->CurrentAddress[4], etdev->CurrentAddress[5]);
 
 	/* Decode SpeedDuplex
 	 *
 	 * Set up as if we are auto negotiating always and then change if we
 	 * go into force mode
 	 */
-	pAdapter->AiForceSpeed = 0;	/* Auto speed */
-	pAdapter->AiForceDpx = 0;	/* Auto FDX */
+	etdev->AiForceSpeed = 0;	/* Auto speed */
+	etdev->AiForceDpx = 0;	/* Auto FDX */
 
 	/* If we are the 10/100 device, and gigabit is somehow requested then
 	 * knock it down to 100 full.
 	 */
-	if (pAdapter->DeviceID == ET131X_PCI_DEVICE_ID_FAST &&
-	    pAdapter->SpeedDuplex == 5)
-		pAdapter->SpeedDuplex = 4;
+	if (etdev->DeviceID == ET131X_PCI_DEVICE_ID_FAST &&
+	    etdev->SpeedDuplex == 5)
+		etdev->SpeedDuplex = 4;
 
-	switch (pAdapter->SpeedDuplex) {
+	switch (etdev->SpeedDuplex) {
 	case 1:		/* 10Mb   Half-Duplex */
-		pAdapter->AiForceSpeed = 10;
-		pAdapter->AiForceDpx = 1;
+		etdev->AiForceSpeed = 10;
+		etdev->AiForceDpx = 1;
 		break;
 
 	case 2:		/* 10Mb   Full-Duplex */
-		pAdapter->AiForceSpeed = 10;
-		pAdapter->AiForceDpx = 2;
+		etdev->AiForceSpeed = 10;
+		etdev->AiForceDpx = 2;
 		break;
 
 	case 3:		/* 100Mb  Half-Duplex */
-		pAdapter->AiForceSpeed = 100;
-		pAdapter->AiForceDpx = 1;
+		etdev->AiForceSpeed = 100;
+		etdev->AiForceDpx = 1;
 		break;
 
 	case 4:		/* 100Mb  Full-Duplex */
-		pAdapter->AiForceSpeed = 100;
-		pAdapter->AiForceDpx = 2;
+		etdev->AiForceSpeed = 100;
+		etdev->AiForceDpx = 2;
 		break;
 
 	case 5:		/* 1000Mb Full-Duplex */
-		pAdapter->AiForceSpeed = 1000;
-		pAdapter->AiForceDpx = 2;
+		etdev->AiForceSpeed = 1000;
+		etdev->AiForceDpx = 2;
 		break;
 	}
 
--- a/drivers/staging/et131x/et131x_debug.c
+++ b/drivers/staging/et131x/et131x_debug.c
@@ -106,11 +106,11 @@ extern dbg_info_t *et131x_dbginfo;
 
 /**
  * DumpTxQueueContents - Dump out the tx queue and the shadow pointers
- * @pAdapter: pointer to our adapter structure
+ * @etdev: pointer to our adapter structure
  */
-void DumpTxQueueContents(int dbgLvl, struct et131x_adapter *pAdapter)
+void DumpTxQueueContents(int dbgLvl, struct et131x_adapter *etdev)
 {
-	MMC_t __iomem *mmc = &pAdapter->CSRAddress->mmc;
+	MMC_t __iomem *mmc = &etdev->CSRAddress->mmc;
 	uint32_t TxQueueAddr;
 
 	if (DBG_FLAGS(et131x_dbginfo) & dbgLvl) {
@@ -134,24 +134,24 @@ void DumpTxQueueContents(int dbgLvl, str
 		}
 
 		DBG_PRINT("Shadow Pointers 0x%08x\n",
-			  readl(&pAdapter->CSRAddress->txmac.shadow_ptr.value));
+			  readl(&etdev->CSRAddress->txmac.shadow_ptr.value));
 	}
 }
 
 /**
  * DumpDeviceBlock
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Dumps the first 64 regs of each block of the et-1310 (each block is
  * mapped to a new page, each page is 4096 bytes).
  */
 #define NUM_BLOCKS 8
-void DumpDeviceBlock(int dbgLvl, struct et131x_adapter *pAdapter,
+void DumpDeviceBlock(int dbgLvl, struct et131x_adapter *etdev,
 		     uint32_t Block)
 {
 	uint32_t Address1, Address2;
 	uint32_t __iomem *BigDevicePointer =
-		(uint32_t __iomem *) pAdapter->CSRAddress;
+		(uint32_t __iomem *) etdev->CSRAddress;
 	const char *BlockNames[NUM_BLOCKS] = {
 		"Global", "Tx DMA", "Rx DMA", "Tx MAC",
 		"Rx MAC", "MAC", "MAC Stat", "MMC"
@@ -179,17 +179,17 @@ void DumpDeviceBlock(int dbgLvl, struct 
 
 /**
  * DumpDeviceReg
- * @pAdapter: pointer to our adapter
+ * @etdev: pointer to our adapter
  *
  * Dumps the first 64 regs of each block of the et-1310 (each block is
  * mapped to a new page, each page is 4096 bytes).
  */
-void DumpDeviceReg(int dbgLvl, struct et131x_adapter *pAdapter)
+void DumpDeviceReg(int dbgLvl, struct et131x_adapter *etdev)
 {
 	uint32_t Address1, Address2;
 	uint32_t Block;
 	uint32_t __iomem *BigDevicePointer =
-		(uint32_t __iomem *) pAdapter->CSRAddress;
+		(uint32_t __iomem *) etdev->CSRAddress;
 	uint32_t __iomem *Pointer;
 	const char *BlockNames[NUM_BLOCKS] = {
 		"Global", "Tx DMA", "Rx DMA", "Tx MAC",
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -447,40 +447,40 @@ int et131x_find_adapter(struct et131x_ad
  */
 void et131x_error_timer_handler(unsigned long data)
 {
-	struct et131x_adapter *pAdapter = (struct et131x_adapter *) data;
+	struct et131x_adapter *etdev = (struct et131x_adapter *) data;
 	PM_CSR_t pm_csr;
 
-	pm_csr.value = readl(&pAdapter->CSRAddress->global.pm_csr.value);
+	pm_csr.value = readl(&etdev->CSRAddress->global.pm_csr.value);
 
 	if (pm_csr.bits.pm_phy_sw_coma == 0) {
-		if (pAdapter->RegistryMACStat)
-			UpdateMacStatHostCounters(pAdapter);
+		if (etdev->RegistryMACStat)
+			UpdateMacStatHostCounters(etdev);
 	} else
 		DBG_VERBOSE(et131x_dbginfo,
 			    "No interrupts, in PHY coma, pm_csr = 0x%x\n",
 			    pm_csr.value);
 
-	if (!pAdapter->Bmsr.bits.link_status &&
-	    pAdapter->RegistryPhyComa &&
-	    pAdapter->PoMgmt.TransPhyComaModeOnBoot < 11) {
-		pAdapter->PoMgmt.TransPhyComaModeOnBoot++;
+	if (!etdev->Bmsr.bits.link_status &&
+	    etdev->RegistryPhyComa &&
+	    etdev->PoMgmt.TransPhyComaModeOnBoot < 11) {
+		etdev->PoMgmt.TransPhyComaModeOnBoot++;
 	}
 
-	if (pAdapter->PoMgmt.TransPhyComaModeOnBoot == 10) {
-		if (!pAdapter->Bmsr.bits.link_status
-		    && pAdapter->RegistryPhyComa) {
+	if (etdev->PoMgmt.TransPhyComaModeOnBoot == 10) {
+		if (!etdev->Bmsr.bits.link_status
+		    && etdev->RegistryPhyComa) {
 			if (pm_csr.bits.pm_phy_sw_coma == 0) {
 				/* NOTE - This was originally a 'sync with
 				 *  interrupt'. How to do that under Linux?
 				 */
-				et131x_enable_interrupts(pAdapter);
-				EnablePhyComa(pAdapter);
+				et131x_enable_interrupts(etdev);
+				EnablePhyComa(etdev);
 			}
 		}
 	}
 
 	/* This is a periodic timer, so reschedule */
-	mod_timer(&pAdapter->ErrorTimer, jiffies +
+	mod_timer(&etdev->ErrorTimer, jiffies +
 					  TX_ERROR_PERIOD * HZ / 1000);
 }
 
@@ -491,23 +491,23 @@ void et131x_error_timer_handler(unsigned
  */
 void et131x_link_detection_handler(unsigned long data)
 {
-	struct et131x_adapter *pAdapter = (struct et131x_adapter *) data;
+	struct et131x_adapter *etdev = (struct et131x_adapter *) data;
 	unsigned long lockflags;
 
 	/* Let everyone know that we have run */
-	pAdapter->bLinkTimerActive = false;
+	etdev->bLinkTimerActive = false;
 
-	if (pAdapter->MediaState == 0) {
-		spin_lock_irqsave(&pAdapter->Lock, lockflags);
+	if (etdev->MediaState == 0) {
+		spin_lock_irqsave(&etdev->Lock, lockflags);
 
-		pAdapter->MediaState = NETIF_STATUS_MEDIA_DISCONNECT;
-		MP_CLEAR_FLAG(pAdapter, fMP_ADAPTER_LINK_DETECTION);
+		etdev->MediaState = NETIF_STATUS_MEDIA_DISCONNECT;
+		MP_CLEAR_FLAG(etdev, fMP_ADAPTER_LINK_DETECTION);
 
-		spin_unlock_irqrestore(&pAdapter->Lock, lockflags);
+		spin_unlock_irqrestore(&etdev->Lock, lockflags);
 
-		netif_carrier_off(pAdapter->netdev);
+		netif_carrier_off(etdev->netdev);
 
-		pAdapter->bSetPending = false;
+		etdev->bSetPending = false;
 	}
 }
 
@@ -517,54 +517,54 @@ void et131x_link_detection_handler(unsig
  *
  * Returns 0 on success, errno on failure (as defined in errno.h)
  */
-int et131x_adapter_setup(struct et131x_adapter *pAdapter)
+int et131x_adapter_setup(struct et131x_adapter *etdev)
 {
 	int status = 0;
 
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Configure the JAGCore */
-	ConfigGlobalRegs(pAdapter);
+	ConfigGlobalRegs(etdev);
 
-	ConfigMACRegs1(pAdapter);
-	ConfigMMCRegs(pAdapter);
+	ConfigMACRegs1(etdev);
+	ConfigMMCRegs(etdev);
 
-	ConfigRxMacRegs(pAdapter);
-	ConfigTxMacRegs(pAdapter);
+	ConfigRxMacRegs(etdev);
+	ConfigTxMacRegs(etdev);
 
-	ConfigRxDmaRegs(pAdapter);
-	ConfigTxDmaRegs(pAdapter);
+	ConfigRxDmaRegs(etdev);
+	ConfigTxDmaRegs(etdev);
 
-	ConfigMacStatRegs(pAdapter);
+	ConfigMacStatRegs(etdev);
 
 	/* Move the following code to Timer function?? */
-	status = et131x_xcvr_find(pAdapter);
+	status = et131x_xcvr_find(etdev);
 
 	if (status != 0)
 		DBG_WARNING(et131x_dbginfo, "Could not find the xcvr\n");
 
 	/* Prepare the TRUEPHY library. */
-	ET1310_PhyInit(pAdapter);
+	ET1310_PhyInit(etdev);
 
 	/* Reset the phy now so changes take place */
-	ET1310_PhyReset(pAdapter);
+	ET1310_PhyReset(etdev);
 
 	/* Power down PHY */
-	ET1310_PhyPowerDown(pAdapter, 1);
+	ET1310_PhyPowerDown(etdev, 1);
 
 	/*
 	 * We need to turn off 1000 base half dulplex, the mac does not
 	 * support it. For the 10/100 part, turn off all gig advertisement
 	 */
-	if (pAdapter->DeviceID != ET131X_PCI_DEVICE_ID_FAST)
-		ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_FULL);
+	if (etdev->DeviceID != ET131X_PCI_DEVICE_ID_FAST)
+		ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_FULL);
 	else
-		ET1310_PhyAdvertise1000BaseT(pAdapter, TRUEPHY_ADV_DUPLEX_NONE);
+		ET1310_PhyAdvertise1000BaseT(etdev, TRUEPHY_ADV_DUPLEX_NONE);
 
 	/* Power up PHY */
-	ET1310_PhyPowerDown(pAdapter, 0);
+	ET1310_PhyPowerDown(etdev, 0);
 
-	et131x_setphy_normal(pAdapter);
+	et131x_setphy_normal(etdev);
 
 	DBG_LEAVE(et131x_dbginfo);
 	return status;
--- a/drivers/staging/et131x/et131x_isr.c
+++ b/drivers/staging/et131x/et131x_isr.c
@@ -211,10 +211,10 @@ out:
  */
 void et131x_isr_handler(struct work_struct *work)
 {
-	struct et131x_adapter *pAdapter =
+	struct et131x_adapter *etdev =
 		container_of(work, struct et131x_adapter, task);
-	INTERRUPT_t GlobStatus = pAdapter->Stats.InterruptStatus;
-	ADDRESS_MAP_t __iomem *iomem = pAdapter->CSRAddress;
+	INTERRUPT_t GlobStatus = etdev->Stats.InterruptStatus;
+	ADDRESS_MAP_t __iomem *iomem = etdev->CSRAddress;
 
 	/*
 	 * These first two are by far the most common.  Once handled, we clear
@@ -224,13 +224,13 @@ void et131x_isr_handler(struct work_stru
 	/* Handle all the completed Transmit interrupts */
 	if (GlobStatus.bits.txdma_isr) {
 		DBG_TX(et131x_dbginfo, "TXDMA_ISR interrupt\n");
-		et131x_handle_send_interrupt(pAdapter);
+		et131x_handle_send_interrupt(etdev);
 	}
 
 	/* Handle all the completed Receives interrupts */
 	if (GlobStatus.bits.rxdma_xfr_done) {
 		DBG_RX(et131x_dbginfo, "RXDMA_XFR_DONE interrupt\n");
-		et131x_handle_recv_interrupt(pAdapter);
+		et131x_handle_recv_interrupt(etdev);
 	}
 
 	GlobStatus.value &= 0xffffffd7;
@@ -272,8 +272,8 @@ void et131x_isr_handler(struct work_stru
 			/* If the user has flow control on, then we will
 			 * send a pause packet, otherwise just exit
 			 */
-			if (pAdapter->FlowControl == TxOnly ||
-			    pAdapter->FlowControl == Both) {
+			if (etdev->FlowControl == TxOnly ||
+			    etdev->FlowControl == Both) {
 				PM_CSR_t pm_csr;
 
 				/* Tell the device to send a pause packet via
@@ -330,11 +330,11 @@ void et131x_isr_handler(struct work_stru
 			 */
 			/* TRAP();*/
 
-			pAdapter->TxMacTest.value =
+			etdev->TxMacTest.value =
 				readl(&iomem->txmac.tx_test.value);
 			DBG_WARNING(et131x_dbginfo,
 				    "RxDMA_ERR interrupt, error %x\n",
-				    pAdapter->TxMacTest.value);
+				    etdev->TxMacTest.value);
 		}
 
 		/* Handle the Wake on LAN Event */
@@ -370,23 +370,23 @@ void et131x_isr_handler(struct work_stru
 				DBG_VERBOSE(et131x_dbginfo,
 					    "Device is in COMA mode, "
 					    "need to wake up\n");
-				DisablePhyComa(pAdapter);
+				DisablePhyComa(etdev);
 			}
 
 			/* Read the PHY ISR to clear the reason for the
 			 * interrupt.
 			 */
-			MiRead(pAdapter, (uint8_t) offsetof(MI_REGS_t, isr),
+			MiRead(etdev, (uint8_t) offsetof(MI_REGS_t, isr),
 			       &myIsr.value);
 
-			if (!pAdapter->ReplicaPhyLoopbk) {
-				MiRead(pAdapter,
+			if (!etdev->ReplicaPhyLoopbk) {
+				MiRead(etdev,
 				       (uint8_t) offsetof(MI_REGS_t, bmsr),
 				       &BmsrData.value);
 
 				BmsrInts.value =
-				    pAdapter->Bmsr.value ^ BmsrData.value;
-				pAdapter->Bmsr.value = BmsrData.value;
+				    etdev->Bmsr.value ^ BmsrData.value;
+				etdev->Bmsr.value = BmsrData.value;
 
 				DBG_VERBOSE(et131x_dbginfo,
 					    "Bmsr.value = 0x%04x,"
@@ -394,13 +394,13 @@ void et131x_isr_handler(struct work_stru
 					    BmsrData.value, BmsrInts.value);
 
 				/* Do all the cable in / cable out stuff */
-				et131x_Mii_check(pAdapter, BmsrData, BmsrInts);
+				et131x_Mii_check(etdev, BmsrData, BmsrInts);
 			}
 		}
 
 		/* Let's move on to the TxMac */
 		if (GlobStatus.bits.txmac_interrupt) {
-			pAdapter->TxRing.TxMacErr.value =
+			etdev->TxRing.TxMacErr.value =
 				readl(&iomem->txmac.err.value);
 
 			/*
@@ -415,7 +415,7 @@ void et131x_isr_handler(struct work_stru
 			 */
 			DBG_WARNING(et131x_dbginfo,
 				    "TXMAC interrupt, error 0x%08x\n",
-				    pAdapter->TxRing.TxMacErr.value);
+				    etdev->TxRing.TxMacErr.value);
 
 			/* If we are debugging, we want to see this error,
 			 * otherwise we just want the device to be reset and
@@ -432,7 +432,7 @@ void et131x_isr_handler(struct work_stru
 			 * set the flag to cause us to reset so we can solve
 			 * this issue.
 			 */
-			/* MP_SET_FLAG( pAdapter,
+			/* MP_SET_FLAG( etdev,
 						fMP_ADAPTER_HARDWARE_ERROR); */
 
 			DBG_WARNING(et131x_dbginfo,
@@ -461,7 +461,7 @@ void et131x_isr_handler(struct work_stru
 			 * counter(s).
 			 */
 			DBG_VERBOSE(et131x_dbginfo, "MAC_STAT interrupt\n");
-			HandleMacStatInterrupt(pAdapter);
+			HandleMacStatInterrupt(etdev);
 		}
 
 		/* Handle SLV Timeout Interrupt */
@@ -479,6 +479,6 @@ void et131x_isr_handler(struct work_stru
 		}
 	}
 
-	if (pAdapter->PoMgmt.PowerState == NdisDeviceStateD0)
-		et131x_enable_interrupts(pAdapter);
+	if (etdev->PoMgmt.PowerState == NdisDeviceStateD0)
+		et131x_enable_interrupts(etdev);
 }
--- a/drivers/staging/et131x/et131x_netdev.c
+++ b/drivers/staging/et131x/et131x_netdev.c
@@ -308,7 +308,7 @@ int et131x_close(struct net_device *netd
 int et131x_ioctl_mii(struct net_device *netdev, struct ifreq *reqbuf, int cmd)
 {
 	int status = 0;
-	struct et131x_adapter *pAdapter = netdev_priv(netdev);
+	struct et131x_adapter *etdev = netdev_priv(netdev);
 	struct mii_ioctl_data *data = if_mii(reqbuf);
 
 	DBG_ENTER(et131x_dbginfo);
@@ -316,7 +316,7 @@ int et131x_ioctl_mii(struct net_device *
 	switch (cmd) {
 	case SIOCGMIIPHY:
 		DBG_VERBOSE(et131x_dbginfo, "SIOCGMIIPHY\n");
-		data->phy_id = pAdapter->Stats.xcvr_addr;
+		data->phy_id = etdev->Stats.xcvr_addr;
 		break;
 
 	case SIOCGMIIREG:
@@ -324,7 +324,7 @@ int et131x_ioctl_mii(struct net_device *
 		if (!capable(CAP_NET_ADMIN)) {
 			status = -EPERM;
 		} else {
-			status = MiRead(pAdapter,
+			status = MiRead(etdev,
 					data->reg_num, &data->val_out);
 		}
 		break;
@@ -334,7 +334,7 @@ int et131x_ioctl_mii(struct net_device *
 		if (!capable(CAP_NET_ADMIN)) {
 			status = -EPERM;
 		} else {
-			status = MiWrite(pAdapter, data->reg_num,
+			status = MiWrite(etdev, data->reg_num,
 					 data->val_in);
 		}
 		break;
@@ -608,14 +608,14 @@ int et131x_tx(struct sk_buff *skb, struc
  */
 void et131x_tx_timeout(struct net_device *netdev)
 {
-	struct et131x_adapter *pAdapter = netdev_priv(netdev);
+	struct et131x_adapter *etdev = netdev_priv(netdev);
 	PMP_TCB pMpTcb;
 	unsigned long lockflags;
 
 	DBG_WARNING(et131x_dbginfo, "TX TIMEOUT\n");
 
 	/* Just skip this part if the adapter is doing link detection */
-	if (MP_TEST_FLAG(pAdapter, fMP_ADAPTER_LINK_DETECTION)) {
+	if (MP_TEST_FLAG(etdev, fMP_ADAPTER_LINK_DETECTION)) {
 		DBG_ERROR(et131x_dbginfo, "Still doing link detection\n");
 		return;
 	}
@@ -623,21 +623,21 @@ void et131x_tx_timeout(struct net_device
 	/* Any nonrecoverable hardware error?
 	 * Checks adapter->flags for any failure in phy reading
 	 */
-	if (MP_TEST_FLAG(pAdapter, fMP_ADAPTER_NON_RECOVER_ERROR)) {
+	if (MP_TEST_FLAG(etdev, fMP_ADAPTER_NON_RECOVER_ERROR)) {
 		DBG_WARNING(et131x_dbginfo, "Non recoverable error - remove\n");
 		return;
 	}
 
 	/* Hardware failure? */
-	if (MP_TEST_FLAG(pAdapter, fMP_ADAPTER_HARDWARE_ERROR)) {
+	if (MP_TEST_FLAG(etdev, fMP_ADAPTER_HARDWARE_ERROR)) {
 		DBG_WARNING(et131x_dbginfo, "hardware error - reset\n");
 		return;
 	}
 
 	/* Is send stuck? */
-	spin_lock_irqsave(&pAdapter->TCBSendQLock, lockflags);
+	spin_lock_irqsave(&etdev->TCBSendQLock, lockflags);
 
-	pMpTcb = pAdapter->TxRing.CurrSendHead;
+	pMpTcb = etdev->TxRing.CurrSendHead;
 
 	if (pMpTcb != NULL) {
 		pMpTcb->Count++;
@@ -645,21 +645,21 @@ void et131x_tx_timeout(struct net_device
 		if (pMpTcb->Count > NIC_SEND_HANG_THRESHOLD) {
 #ifdef CONFIG_ET131X_DEBUG
 			TX_STATUS_BLOCK_t txDmaComplete =
-			    *(pAdapter->TxRing.pTxStatusVa);
+			    *(etdev->TxRing.pTxStatusVa);
 			PTX_DESC_ENTRY_t pDesc =
-			    pAdapter->TxRing.pTxDescRingVa +
+			    etdev->TxRing.pTxDescRingVa +
 			    pMpTcb->WrIndex.bits.val;
 #endif
 			TX_DESC_ENTRY_t StuckDescriptors[10];
 
 			if (pMpTcb->WrIndex.bits.val > 7) {
 				memcpy(StuckDescriptors,
-				       pAdapter->TxRing.pTxDescRingVa +
+				       etdev->TxRing.pTxDescRingVa +
 				       pMpTcb->WrIndex.bits.val - 6,
 				       sizeof(TX_DESC_ENTRY_t) * 10);
 			}
 
-			spin_unlock_irqrestore(&pAdapter->TCBSendQLock,
+			spin_unlock_irqrestore(&etdev->TCBSendQLock,
 					       lockflags);
 
 			DBG_WARNING(et131x_dbginfo,
@@ -677,10 +677,10 @@ void et131x_tx_timeout(struct net_device
 				    "WbStatus 0x%08x\n", txDmaComplete.value);
 
 #ifdef CONFIG_ET131X_DEBUG
-			DumpDeviceBlock(DBG_WARNING_ON, pAdapter, 0);
-			DumpDeviceBlock(DBG_WARNING_ON, pAdapter, 1);
-			DumpDeviceBlock(DBG_WARNING_ON, pAdapter, 3);
-			DumpDeviceBlock(DBG_WARNING_ON, pAdapter, 5);
+			DumpDeviceBlock(DBG_WARNING_ON, etdev, 0);
+			DumpDeviceBlock(DBG_WARNING_ON, etdev, 1);
+			DumpDeviceBlock(DBG_WARNING_ON, etdev, 3);
+			DumpDeviceBlock(DBG_WARNING_ON, etdev, 5);
 #endif
 			et131x_close(netdev);
 			et131x_open(netdev);
@@ -689,7 +689,7 @@ void et131x_tx_timeout(struct net_device
 		}
 	}
 
-	spin_unlock_irqrestore(&pAdapter->TCBSendQLock, lockflags);
+	spin_unlock_irqrestore(&etdev->TCBSendQLock, lockflags);
 }
 
 /**
