From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Subject: Staging: rt28x0: run *.h files through Lindent

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2860/ap.h             |   48 
 drivers/staging/rt2860/chip/mac_pci.h   |  149 
 drivers/staging/rt2860/chip/mac_usb.h   |  250 -
 drivers/staging/rt2860/chip/rt2860.h    |    6 
 drivers/staging/rt2860/chip/rt2870.h    |    3 
 drivers/staging/rt2860/chip/rt3070.h    |    1 
 drivers/staging/rt2860/chip/rt3090.h    |    6 
 drivers/staging/rt2860/chip/rt30xx.h    |    1 
 drivers/staging/rt2860/chip/rtmp_mac.h  | 1670 +++----
 drivers/staging/rt2860/chip/rtmp_phy.h  |   46 
 drivers/staging/rt2860/chlist.h         |   43 
 drivers/staging/rt2860/common/action.h  |   27 
 drivers/staging/rt2860/crypt_hmac.h     |   22 
 drivers/staging/rt2860/crypt_md5.h      |   34 
 drivers/staging/rt2860/crypt_sha2.h     |   34 
 drivers/staging/rt2860/dfs.h            |    4 
 drivers/staging/rt2860/eeprom.h         |   25 
 drivers/staging/rt2860/iface/rtmp_pci.h |    3 
 drivers/staging/rt2860/iface/rtmp_usb.h |   18 
 drivers/staging/rt2860/mlme.h           | 1237 ++---
 drivers/staging/rt2860/oid.h            |  869 +--
 drivers/staging/rt2860/rt_config.h      |    3 
 drivers/staging/rt2860/rt_linux.h       |  153 
 drivers/staging/rt2860/rtmp.h           | 7205 +++++++++++++-------------------
 drivers/staging/rt2860/rtmp_chip.h      |  174 
 drivers/staging/rt2860/rtmp_ckipmic.h   |   57 
 drivers/staging/rt2860/rtmp_def.h       |  362 -
 drivers/staging/rt2860/rtmp_dot11.h     |  108 
 drivers/staging/rt2860/rtmp_iface.h     |   51 
 drivers/staging/rt2860/rtmp_mcu.h       |   16 
 drivers/staging/rt2860/rtmp_os.h        |   50 
 drivers/staging/rt2860/rtmp_timer.h     |   63 
 drivers/staging/rt2860/rtmp_type.h      |  123 
 drivers/staging/rt2860/rtusb_io.h       |   52 
 drivers/staging/rt2860/spectrum.h       |  148 
 drivers/staging/rt2860/spectrum_def.h   |   79 
 drivers/staging/rt2860/wpa.h            |  353 -
 37 files changed, 5904 insertions(+), 7589 deletions(-)

--- a/drivers/staging/rt2860/ap.h
+++ b/drivers/staging/rt2860/ap.h
@@ -41,40 +41,26 @@
 #define __AP_H__
 
 // ap_wpa.c
-VOID WpaStateMachineInit(
-    IN  PRTMP_ADAPTER   pAd,
-    IN  STATE_MACHINE *Sm,
-    OUT STATE_MACHINE_FUNC Trans[]);
+VOID WpaStateMachineInit(IN PRTMP_ADAPTER pAd,
+			 IN STATE_MACHINE * Sm, OUT STATE_MACHINE_FUNC Trans[]);
 
 #ifdef RTMP_MAC_USB
-VOID BeaconUpdateExec(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3);
+VOID BeaconUpdateExec(IN PVOID SystemSpecific1,
+		      IN PVOID FunctionContext,
+		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
 #endif // RTMP_MAC_USB //
 
-VOID RTMPSetPiggyBack(
-	IN PRTMP_ADAPTER	pAd,
-	IN BOOLEAN			bPiggyBack);
-
-VOID MacTableReset(
-    IN  PRTMP_ADAPTER   pAd);
-
-MAC_TABLE_ENTRY *MacTableInsertEntry(
-    IN  PRTMP_ADAPTER   pAd,
-    IN  PUCHAR          pAddr,
-	IN	UCHAR			apidx,
-	IN BOOLEAN	CleanAll);
-
-BOOLEAN MacTableDeleteEntry(
-    IN  PRTMP_ADAPTER   pAd,
-	IN USHORT wcid,
-    IN  PUCHAR          pAddr);
-
-MAC_TABLE_ENTRY *MacTableLookup(
-    IN  PRTMP_ADAPTER   pAd,
-    IN  PUCHAR          pAddr);
+VOID RTMPSetPiggyBack(IN PRTMP_ADAPTER pAd, IN BOOLEAN bPiggyBack);
 
-#endif  // __AP_H__
+VOID MacTableReset(IN PRTMP_ADAPTER pAd);
 
+MAC_TABLE_ENTRY *MacTableInsertEntry(IN PRTMP_ADAPTER pAd,
+				     IN PUCHAR pAddr,
+				     IN UCHAR apidx, IN BOOLEAN CleanAll);
+
+BOOLEAN MacTableDeleteEntry(IN PRTMP_ADAPTER pAd,
+			    IN USHORT wcid, IN PUCHAR pAddr);
+
+MAC_TABLE_ENTRY *MacTableLookup(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr);
+
+#endif // __AP_H__
--- a/drivers/staging/rt2860/chip/mac_pci.h
+++ b/drivers/staging/rt2860/chip/mac_pci.h
@@ -43,7 +43,6 @@
 #include "../rtmp_iface.h"
 #include "../rtmp_dot11.h"
 
-
 //
 // Device ID & Vendor ID related definitions,
 // NOTE: you should not add the new VendorID/DeviceID here unless you not sure it belongs to what chip.
@@ -61,10 +60,6 @@
 #define PCI_CLASS_BRIDGE_PCI		0x0604
 #endif
 
-
-
-
-
 #define TXINFO_SIZE						0
 #define RTMP_PKT_TAIL_PADDING			0
 #define fRTMP_ADAPTER_NEED_STOP_TX	0
@@ -72,86 +67,83 @@
 #define AUX_CTRL           0x10c
 
 //
-// TX descriptor format, Tx	ring, Mgmt Ring
+// TX descriptor format, Tx     ring, Mgmt Ring
 //
-typedef	struct	PACKED _TXD_STRUC {
-	// Word	0
-	UINT32		SDPtr0;
-	// Word	1
-	UINT32		SDLen1:14;
-	UINT32		LastSec1:1;
-	UINT32		Burst:1;
-	UINT32		SDLen0:14;
-	UINT32		LastSec0:1;
-	UINT32		DMADONE:1;
+typedef struct PACKED _TXD_STRUC {
+	// Word 0
+	UINT32 SDPtr0;
+	// Word 1
+	UINT32 SDLen1:14;
+	UINT32 LastSec1:1;
+	UINT32 Burst:1;
+	UINT32 SDLen0:14;
+	UINT32 LastSec0:1;
+	UINT32 DMADONE:1;
 	//Word2
-	UINT32		SDPtr1;
+	UINT32 SDPtr1;
 	//Word3
-	UINT32		rsv2:24;
-	UINT32		WIV:1;	// Wireless Info Valid. 1 if Driver already fill WI,  o if DMA needs to copy WI to correctposition
-	UINT32		QSEL:2;	// select on-chip FIFO ID for 2nd-stage output scheduler.0:MGMT, 1:HCCA 2:EDCA
-	UINT32		rsv:2;
-	UINT32		TCO:1;	//
-	UINT32		UCO:1;	//
-	UINT32		ICO:1;	//
-}	TXD_STRUC, *PTXD_STRUC;
-
+	UINT32 rsv2:24;
+	UINT32 WIV:1;		// Wireless Info Valid. 1 if Driver already fill WI,  o if DMA needs to copy WI to correctposition
+	UINT32 QSEL:2;		// select on-chip FIFO ID for 2nd-stage output scheduler.0:MGMT, 1:HCCA 2:EDCA
+	UINT32 rsv:2;
+	UINT32 TCO:1;		//
+	UINT32 UCO:1;		//
+	UINT32 ICO:1;		//
+} TXD_STRUC, *PTXD_STRUC;
 
 //
 // Rx descriptor format, Rx Ring
 //
-typedef	struct	PACKED _RXD_STRUC{
-	// Word	0
-	UINT32		SDP0;
-	// Word	1
-	UINT32		SDL1:14;
-	UINT32		Rsv:2;
-	UINT32		SDL0:14;
-	UINT32		LS0:1;
-	UINT32		DDONE:1;
-	// Word	2
-	UINT32		SDP1;
-	// Word	3
-	UINT32		BA:1;
-	UINT32		DATA:1;
-	UINT32		NULLDATA:1;
-	UINT32		FRAG:1;
-	UINT32		U2M:1;              // 1: this RX frame is unicast to me
-	UINT32		Mcast:1;            // 1: this is a multicast frame
-	UINT32		Bcast:1;            // 1: this is a broadcast frame
-	UINT32		MyBss:1;	// 1: this frame belongs to the same BSSID
-	UINT32		Crc:1;              // 1: CRC error
-	UINT32		CipherErr:2;        // 0: decryption okay, 1:ICV error, 2:MIC error, 3:KEY not valid
-	UINT32		AMSDU:1;		// rx with 802.3 header, not 802.11 header.
-	UINT32		HTC:1;
-	UINT32		RSSI:1;
-	UINT32		L2PAD:1;
-	UINT32		AMPDU:1;
-	UINT32		Decrypted:1;	// this frame is being decrypted.
-	UINT32		PlcpSignal:1;		// To be moved
-	UINT32		PlcpRssil:1;// To be moved
-	UINT32		Rsv1:13;
-}	RXD_STRUC, *PRXD_STRUC, RT28XX_RXD_STRUC, *PRT28XX_RXD_STRUC;
+typedef struct PACKED _RXD_STRUC {
+	// Word 0
+	UINT32 SDP0;
+	// Word 1
+	UINT32 SDL1:14;
+	UINT32 Rsv:2;
+	UINT32 SDL0:14;
+	UINT32 LS0:1;
+	UINT32 DDONE:1;
+	// Word 2
+	UINT32 SDP1;
+	// Word 3
+	UINT32 BA:1;
+	UINT32 DATA:1;
+	UINT32 NULLDATA:1;
+	UINT32 FRAG:1;
+	UINT32 U2M:1;		// 1: this RX frame is unicast to me
+	UINT32 Mcast:1;		// 1: this is a multicast frame
+	UINT32 Bcast:1;		// 1: this is a broadcast frame
+	UINT32 MyBss:1;		// 1: this frame belongs to the same BSSID
+	UINT32 Crc:1;		// 1: CRC error
+	UINT32 CipherErr:2;	// 0: decryption okay, 1:ICV error, 2:MIC error, 3:KEY not valid
+	UINT32 AMSDU:1;		// rx with 802.3 header, not 802.11 header.
+	UINT32 HTC:1;
+	UINT32 RSSI:1;
+	UINT32 L2PAD:1;
+	UINT32 AMPDU:1;
+	UINT32 Decrypted:1;	// this frame is being decrypted.
+	UINT32 PlcpSignal:1;	// To be moved
+	UINT32 PlcpRssil:1;	// To be moved
+	UINT32 Rsv1:13;
+} RXD_STRUC, *PRXD_STRUC, RT28XX_RXD_STRUC, *PRT28XX_RXD_STRUC;
 
 typedef union _TX_ATTENUATION_CTRL_STRUC {
-	struct
-	{
-		ULONG	RF_ISOLATION_ENABLE:1;
-		ULONG	Reserve2:7;
-		ULONG	PCIE_PHY_TX_ATTEN_VALUE:3;
-		ULONG	PCIE_PHY_TX_ATTEN_EN:1;
-		ULONG	Reserve1:20;
+	struct {
+		ULONG RF_ISOLATION_ENABLE:1;
+		ULONG Reserve2:7;
+		ULONG PCIE_PHY_TX_ATTEN_VALUE:3;
+		ULONG PCIE_PHY_TX_ATTEN_EN:1;
+		ULONG Reserve1:20;
 	} field;
 
-	ULONG	word;
+	ULONG word;
 } TX_ATTENUATION_CTRL_STRUC, *PTX_ATTENUATION_CTRL_STRUC;
 
 /* ----------------- EEPROM Related MACRO ----------------- */
 
 // 8051 firmware image for RT2860 - base address = 0x4000
 #define FIRMWARE_IMAGE_BASE     0x2000
-#define MAX_FIRMWARE_IMAGE_SIZE 0x2000    // 8kbyte
-
+#define MAX_FIRMWARE_IMAGE_SIZE 0x2000	// 8kbyte
 
 /* ----------------- Frimware Related MACRO ----------------- */
 #define RTMP_WRITE_FIRMWARE(_pAd, _pFwImage, _FwLen)			\
@@ -175,14 +167,12 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 		RTMP_IO_WRITE32(_pAd, H2M_MAILBOX_CSR, 0);		\
 	}while(0)
 
-
 /* ----------------- TX Related MACRO ----------------- */
 #define RTMP_START_DEQUEUE(pAd, QueIdx, irqFlags)		do{}while(0)
 #define RTMP_STOP_DEQUEUE(pAd, QueIdx, irqFlags)		do{}while(0)
 
-
 #define RTMP_HAS_ENOUGH_FREE_DESC(pAd, pTxBlk, freeNum, pPacket) \
-		((freeNum) >= (ULONG)(pTxBlk->TotalFragNum + RTMP_GET_PACKET_FRAGMENTS(pPacket) + 3)) /* rough estimate we will use 3 more descriptor. */
+		((freeNum) >= (ULONG)(pTxBlk->TotalFragNum + RTMP_GET_PACKET_FRAGMENTS(pPacket) + 3))	/* rough estimate we will use 3 more descriptor. */
 #define RTMP_RELEASE_DESC_RESOURCE(pAd, QueIdx)	\
 		do{}while(0)
 
@@ -190,12 +180,11 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 		(((freeNum != (TX_RING_SIZE-1)) && (pAd->TxSwQueue[QueIdx].Number == 0)) || (freeNum<3))
 		//(((freeNum) != (TX_RING_SIZE-1)) && (pAd->TxSwQueue[QueIdx].Number == 1 /*0*/))
 
-
 #define HAL_KickOutMgmtTx(_pAd, _QueIdx, _pPacket, _pSrcBufVA, _SrcBufLen)	\
 			RtmpPCIMgmtKickOut(_pAd, _QueIdx, _pPacket, _pSrcBufVA, _SrcBufLen)
 
 #define HAL_WriteSubTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)	\
-		/* RtmpPCI_WriteSubTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)*/
+				/* RtmpPCI_WriteSubTxResource(pAd, pTxBlk, bIsLast, pFreeNumber) */
 
 #define HAL_WriteTxResource(pAd, pTxBlk,bIsLast, pFreeNumber)	\
 			RtmpPCI_WriteSingleTxResource(pAd, pTxBlk, bIsLast, pFreeNumber)
@@ -210,7 +199,7 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 			RtmpPCI_FinalWriteTxResource(_pAd, _pTxBlk, _TotalMPDUSize, _FirstTxIdx)
 
 #define HAL_LastTxIdx(_pAd, _QueIdx,_LastTxIdx) \
-			/*RtmpPCIDataLastTxIdx(_pAd, _QueIdx,_LastTxIdx)*/
+				/*RtmpPCIDataLastTxIdx(_pAd, _QueIdx,_LastTxIdx) */
 
 #define HAL_KickOutTx(_pAd, _pTxBlk, _QueIdx)	\
 			RTMP_IO_WRITE32((_pAd), TX_CTX_IDX0+((_QueIdx)*0x10), (_pAd)->TxRing[(_QueIdx)].TxCpuIdx)
@@ -225,17 +214,14 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 			 :	\
 			(_pAd->TxRing[_QueIdx].TxSwFreeIdx + TX_RING_SIZE - _pAd->TxRing[_QueIdx].TxCpuIdx - 1);
 
-
 #define GET_MGMTRING_FREENO(_pAd) \
 	(_pAd->MgmtRing.TxSwFreeIdx > _pAd->MgmtRing.TxCpuIdx)	? \
 			(_pAd->MgmtRing.TxSwFreeIdx - _pAd->MgmtRing.TxCpuIdx - 1) \
 			 :	\
 			(_pAd->MgmtRing.TxSwFreeIdx + MGMT_RING_SIZE - _pAd->MgmtRing.TxCpuIdx - 1);
 
-
 /* ----------------- RX Related MACRO ----------------- */
 
-
 /* ----------------- ASIC Related MACRO ----------------- */
 // reset MAC of a station entry to 0x000000000000
 #define RTMP_STA_ENTRY_MAC_RESET(pAd, Wcid)	\
@@ -272,7 +258,6 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 						  pAd->SharedKey[apidx][KeyID].CipherAlg,		\
 						  pEntry); }
 
-
 // Insert the BA bitmap to ASIC for the Wcid entry
 #define RTMP_ADD_BA_SESSION_TO_ASIC(_pAd, _Aid, _TID)	\
 		do{					\
@@ -283,9 +268,8 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 			RTMP_IO_WRITE32((_pAd), _Offset, _Value);\
 		}while(0)
 
-
 // Remove the BA bitmap from ASIC for the Wcid entry
-//		bitmap field starts at 0x10000 in ASIC WCID table
+//              bitmap field starts at 0x10000 in ASIC WCID table
 #define RTMP_DEL_BA_SESSION_FROM_ASIC(_pAd, _Wcid, _TID)				\
 		do{								\
 			UINT32	_Value = 0, _Offset;				\
@@ -295,7 +279,6 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 			RTMP_IO_WRITE32((_pAd), _Offset, _Value);			\
 		}while(0)
 
-
 /* ----------------- Interface Related MACRO ----------------- */
 
 //
@@ -314,7 +297,6 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 		RTMP_SET_FLAG((_pAd), fRTMP_ADAPTER_INTERRUPT_ACTIVE);	\
 	}while(0)
 
-
 #define RTMP_IRQ_INIT(pAd)	\
 	{	pAd->int_enable_reg = ((DELAYINTMASK) |		\
 					(RxINT|TxDataInt|TxMgmtInt)) & ~(0x03);	\
@@ -326,7 +308,6 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 		RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, 0xffffffff);\
 		RTMP_ASIC_INTERRUPT_ENABLE(pAd); }
 
-
 /* ----------------- MLME Related MACRO ----------------- */
 #define RTMP_MLME_HANDLER(pAd)			MlmeHandler(pAd)
 
@@ -344,7 +325,6 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 /* ----------------- Power Save Related MACRO ----------------- */
 #define RTMP_PS_POLL_ENQUEUE(pAd)				EnqueuePsPoll(pAd)
 
-
 // For RTMPPCIePowerLinkCtrlRestore () function
 #define RESTORE_HALT		1
 #define RESTORE_WAKEUP		2
@@ -358,7 +338,6 @@ typedef union _TX_ATTENUATION_CTRL_STRUC
 #define CID2MASK		0x00ff0000
 #define CID3MASK		0xff000000
 
-
 #define RTMP_STA_FORCE_WAKEUP(pAd, bFromTx) \
     RT28xxPciStaAsicForceWakeup(pAd, bFromTx);
 
--- a/drivers/staging/rt2860/chip/mac_usb.h
+++ b/drivers/staging/rt2860/chip/mac_usb.h
@@ -43,13 +43,12 @@
 #include "../rtmp_iface.h"
 #include "../rtmp_dot11.h"
 
-
 #define USB_CYC_CFG				0x02a4
 
 #define BEACON_RING_SIZE		2
 #define MGMTPIPEIDX				0	// EP6 is highest priority
 
-#define RTMP_PKT_TAIL_PADDING	11 // 3(max 4 byte padding) + 4 (last packet padding) + 4 (MaxBulkOutsize align padding)
+#define RTMP_PKT_TAIL_PADDING	11	// 3(max 4 byte padding) + 4 (last packet padding) + 4 (MaxBulkOutsize align padding)
 
 #define fRTMP_ADAPTER_NEED_STOP_TX		\
 		(fRTMP_ADAPTER_NIC_NOT_EXIST | fRTMP_ADAPTER_HALT_IN_PROGRESS |	\
@@ -62,157 +61,146 @@
 #define RXINFO_SIZE				4
 #define RT2870_RXDMALEN_FIELD_SIZE	4
 
-typedef	struct	PACKED _RXINFO_STRUC {
-	UINT32		BA:1;
-	UINT32		DATA:1;
-	UINT32		NULLDATA:1;
-	UINT32		FRAG:1;
-	UINT32		U2M:1;              // 1: this RX frame is unicast to me
-	UINT32		Mcast:1;            // 1: this is a multicast frame
-	UINT32		Bcast:1;            // 1: this is a broadcast frame
-	UINT32		MyBss:1;	// 1: this frame belongs to the same BSSID
-	UINT32		Crc:1;              // 1: CRC error
-	UINT32		CipherErr:2;        // 0: decryption okay, 1:ICV error, 2:MIC error, 3:KEY not valid
-	UINT32		AMSDU:1;		// rx with 802.3 header, not 802.11 header.
-	UINT32		HTC:1;
-	UINT32		RSSI:1;
-	UINT32		L2PAD:1;
-	UINT32		AMPDU:1;		// To be moved
-	UINT32		Decrypted:1;
-	UINT32		PlcpRssil:1;
-	UINT32		CipherAlg:1;
-	UINT32		LastAMSDU:1;
-	UINT32		PlcpSignal:12;
-}	RXINFO_STRUC, *PRXINFO_STRUC, RT28XX_RXD_STRUC, *PRT28XX_RXD_STRUC;
-
+typedef struct PACKED _RXINFO_STRUC {
+	UINT32 BA:1;
+	UINT32 DATA:1;
+	UINT32 NULLDATA:1;
+	UINT32 FRAG:1;
+	UINT32 U2M:1;		// 1: this RX frame is unicast to me
+	UINT32 Mcast:1;		// 1: this is a multicast frame
+	UINT32 Bcast:1;		// 1: this is a broadcast frame
+	UINT32 MyBss:1;		// 1: this frame belongs to the same BSSID
+	UINT32 Crc:1;		// 1: CRC error
+	UINT32 CipherErr:2;	// 0: decryption okay, 1:ICV error, 2:MIC error, 3:KEY not valid
+	UINT32 AMSDU:1;		// rx with 802.3 header, not 802.11 header.
+	UINT32 HTC:1;
+	UINT32 RSSI:1;
+	UINT32 L2PAD:1;
+	UINT32 AMPDU:1;		// To be moved
+	UINT32 Decrypted:1;
+	UINT32 PlcpRssil:1;
+	UINT32 CipherAlg:1;
+	UINT32 LastAMSDU:1;
+	UINT32 PlcpSignal:12;
+} RXINFO_STRUC, *PRXINFO_STRUC, RT28XX_RXD_STRUC, *PRT28XX_RXD_STRUC;
 
 //
 // TXINFO
 //
 #define TXINFO_SIZE				4
 
-typedef	struct	_TXINFO_STRUC {
-	// Word	0
-	UINT32		USBDMATxPktLen:16;	//used ONLY in USB bulk Aggregation,  Total byte counts of all sub-frame.
-	UINT32		rsv:8;
-	UINT32		WIV:1;	// Wireless Info Valid. 1 if Driver already fill WI,  o if DMA needs to copy WI to correctposition
-	UINT32		QSEL:2;	// select on-chip FIFO ID for 2nd-stage output scheduler.0:MGMT, 1:HCCA 2:EDCA
-	UINT32		SwUseLastRound:1; // Software use.
-	UINT32		rsv2:2;  // Software use.
-	UINT32		USBDMANextVLD:1;	//used ONLY in USB bulk Aggregation, NextValid
-	UINT32		USBDMATxburst:1;//used ONLY in USB bulk Aggre. Force USB DMA transmit frame from current selected endpoint
-}	TXINFO_STRUC, *PTXINFO_STRUC;
-
+typedef struct _TXINFO_STRUC {
+	// Word 0
+	UINT32 USBDMATxPktLen:16;	//used ONLY in USB bulk Aggregation,  Total byte counts of all sub-frame.
+	UINT32 rsv:8;
+	UINT32 WIV:1;		// Wireless Info Valid. 1 if Driver already fill WI,  o if DMA needs to copy WI to correctposition
+	UINT32 QSEL:2;		// select on-chip FIFO ID for 2nd-stage output scheduler.0:MGMT, 1:HCCA 2:EDCA
+	UINT32 SwUseLastRound:1;	// Software use.
+	UINT32 rsv2:2;		// Software use.
+	UINT32 USBDMANextVLD:1;	//used ONLY in USB bulk Aggregation, NextValid
+	UINT32 USBDMATxburst:1;	//used ONLY in USB bulk Aggre. Force USB DMA transmit frame from current selected endpoint
+} TXINFO_STRUC, *PTXINFO_STRUC;
 
 //
 // Management ring buffer format
 //
-typedef	struct	_MGMT_STRUC	{
-	BOOLEAN		Valid;
-	PUCHAR		pBuffer;
-	ULONG		Length;
-}	MGMT_STRUC, *PMGMT_STRUC;
-
+typedef struct _MGMT_STRUC {
+	BOOLEAN Valid;
+	PUCHAR pBuffer;
+	ULONG Length;
+} MGMT_STRUC, *PMGMT_STRUC;
 
 ////////////////////////////////////////////////////////////////////////////
 // The TX_BUFFER structure forms the transmitted USB packet to the device
 ////////////////////////////////////////////////////////////////////////////
-typedef struct __TX_BUFFER{
-	union{
-		UCHAR			WirelessPacket[TX_BUFFER_NORMSIZE];
-		HEADER_802_11	NullFrame;
-		PSPOLL_FRAME	PsPollPacket;
-		RTS_FRAME		RTSFrame;
-	}field;
-	UCHAR			Aggregation[4];  //Buffer for save Aggregation size.
+typedef struct __TX_BUFFER {
+	union {
+		UCHAR WirelessPacket[TX_BUFFER_NORMSIZE];
+		HEADER_802_11 NullFrame;
+		PSPOLL_FRAME PsPollPacket;
+		RTS_FRAME RTSFrame;
+	} field;
+	UCHAR Aggregation[4];	//Buffer for save Aggregation size.
 } TX_BUFFER, *PTX_BUFFER;
 
-typedef struct __HTTX_BUFFER{
-	union{
-		UCHAR			WirelessPacket[MAX_TXBULK_SIZE];
-		HEADER_802_11	NullFrame;
-		PSPOLL_FRAME	PsPollPacket;
-		RTS_FRAME		RTSFrame;
-	}field;
-	UCHAR			Aggregation[4];  //Buffer for save Aggregation size.
+typedef struct __HTTX_BUFFER {
+	union {
+		UCHAR WirelessPacket[MAX_TXBULK_SIZE];
+		HEADER_802_11 NullFrame;
+		PSPOLL_FRAME PsPollPacket;
+		RTS_FRAME RTSFrame;
+	} field;
+	UCHAR Aggregation[4];	//Buffer for save Aggregation size.
 } HTTX_BUFFER, *PHTTX_BUFFER;
 
-
 // used to track driver-generated write irps
-typedef struct _TX_CONTEXT
-{
-	PVOID			pAd;		//Initialized in MiniportInitialize
-	PURB			pUrb;			//Initialized in MiniportInitialize
-	PIRP			pIrp;			//used to cancel pending bulk out.
-									//Initialized in MiniportInitialize
-	PTX_BUFFER		TransferBuffer;	//Initialized in MiniportInitialize
-	ULONG			BulkOutSize;
-	UCHAR			BulkOutPipeId;
-	UCHAR			SelfIdx;
-	BOOLEAN			InUse;
-	BOOLEAN			bWaitingBulkOut; // at least one packet is in this TxContext, ready for making IRP anytime.
-	BOOLEAN			bFullForBulkOut; // all tx buffer are full , so waiting for tx bulkout.
-	BOOLEAN			IRPPending;
-	BOOLEAN			LastOne;
-	BOOLEAN			bAggregatible;
-	UCHAR			Header_802_3[LENGTH_802_3];
-	UCHAR			Rsv[2];
-	ULONG			DataOffset;
-	UINT			TxRate;
-	dma_addr_t		data_dma;		// urb dma on linux
-
-}	TX_CONTEXT, *PTX_CONTEXT, **PPTX_CONTEXT;
+typedef struct _TX_CONTEXT {
+	PVOID pAd;		//Initialized in MiniportInitialize
+	PURB pUrb;		//Initialized in MiniportInitialize
+	PIRP pIrp;		//used to cancel pending bulk out.
+	//Initialized in MiniportInitialize
+	PTX_BUFFER TransferBuffer;	//Initialized in MiniportInitialize
+	ULONG BulkOutSize;
+	UCHAR BulkOutPipeId;
+	UCHAR SelfIdx;
+	BOOLEAN InUse;
+	BOOLEAN bWaitingBulkOut;	// at least one packet is in this TxContext, ready for making IRP anytime.
+	BOOLEAN bFullForBulkOut;	// all tx buffer are full , so waiting for tx bulkout.
+	BOOLEAN IRPPending;
+	BOOLEAN LastOne;
+	BOOLEAN bAggregatible;
+	UCHAR Header_802_3[LENGTH_802_3];
+	UCHAR Rsv[2];
+	ULONG DataOffset;
+	UINT TxRate;
+	dma_addr_t data_dma;	// urb dma on linux
 
+} TX_CONTEXT, *PTX_CONTEXT, **PPTX_CONTEXT;
 
 // used to track driver-generated write irps
-typedef struct _HT_TX_CONTEXT
-{
-	PVOID			pAd;		//Initialized in MiniportInitialize
-	PURB			pUrb;			//Initialized in MiniportInitialize
-	PIRP			pIrp;			//used to cancel pending bulk out.
-									//Initialized in MiniportInitialize
-	PHTTX_BUFFER	TransferBuffer;	//Initialized in MiniportInitialize
-	ULONG			BulkOutSize;	// Indicate the total bulk-out size in bytes in one bulk-transmission
-	UCHAR			BulkOutPipeId;
-	BOOLEAN			IRPPending;
-	BOOLEAN			LastOne;
-	BOOLEAN			bCurWriting;
-	BOOLEAN			bRingEmpty;
-	BOOLEAN			bCopySavePad;
-	UCHAR			SavedPad[8];
-	UCHAR			Header_802_3[LENGTH_802_3];
-	ULONG			CurWritePosition;		// Indicate the buffer offset which packet will be inserted start from.
-	ULONG			CurWriteRealPos;		// Indicate the buffer offset which packet now are writing to.
-	ULONG			NextBulkOutPosition;	// Indicate the buffer start offset of a bulk-transmission
-	ULONG			ENextBulkOutPosition;	// Indicate the buffer end offset of a bulk-transmission
-	UINT			TxRate;
-	dma_addr_t		data_dma;		// urb dma on linux
-}	HT_TX_CONTEXT, *PHT_TX_CONTEXT, **PPHT_TX_CONTEXT;
-
+typedef struct _HT_TX_CONTEXT {
+	PVOID pAd;		//Initialized in MiniportInitialize
+	PURB pUrb;		//Initialized in MiniportInitialize
+	PIRP pIrp;		//used to cancel pending bulk out.
+	//Initialized in MiniportInitialize
+	PHTTX_BUFFER TransferBuffer;	//Initialized in MiniportInitialize
+	ULONG BulkOutSize;	// Indicate the total bulk-out size in bytes in one bulk-transmission
+	UCHAR BulkOutPipeId;
+	BOOLEAN IRPPending;
+	BOOLEAN LastOne;
+	BOOLEAN bCurWriting;
+	BOOLEAN bRingEmpty;
+	BOOLEAN bCopySavePad;
+	UCHAR SavedPad[8];
+	UCHAR Header_802_3[LENGTH_802_3];
+	ULONG CurWritePosition;	// Indicate the buffer offset which packet will be inserted start from.
+	ULONG CurWriteRealPos;	// Indicate the buffer offset which packet now are writing to.
+	ULONG NextBulkOutPosition;	// Indicate the buffer start offset of a bulk-transmission
+	ULONG ENextBulkOutPosition;	// Indicate the buffer end offset of a bulk-transmission
+	UINT TxRate;
+	dma_addr_t data_dma;	// urb dma on linux
+} HT_TX_CONTEXT, *PHT_TX_CONTEXT, **PPHT_TX_CONTEXT;
 
 //
 // Structure to keep track of receive packets and buffers to indicate
 // receive data to the protocol.
 //
-typedef struct _RX_CONTEXT
-{
-	PUCHAR				TransferBuffer;
-	PVOID				pAd;
-	PIRP				pIrp;//used to cancel pending bulk in.
-	PURB				pUrb;
+typedef struct _RX_CONTEXT {
+	PUCHAR TransferBuffer;
+	PVOID pAd;
+	PIRP pIrp;		//used to cancel pending bulk in.
+	PURB pUrb;
 	//These 2 Boolean shouldn't both be 1 at the same time.
-	ULONG				BulkInOffset;	// number of packets waiting for reordering .
-//	BOOLEAN				ReorderInUse;	// At least one packet in this buffer are in reordering buffer and wait for receive indication
-	BOOLEAN				bRxHandling;	// Notify this packet is being process now.
-	BOOLEAN				InUse;			// USB Hardware Occupied. Wait for USB HW to put packet.
-	BOOLEAN				Readable;		// Receive Complete back. OK for driver to indicate receiving packet.
-	BOOLEAN				IRPPending;		// TODO: To be removed
-	atomic_t			IrpLock;
-	NDIS_SPIN_LOCK		RxContextLock;
-	dma_addr_t			data_dma;		// urb dma on linux
-}	RX_CONTEXT, *PRX_CONTEXT;
-
-
+	ULONG BulkInOffset;	// number of packets waiting for reordering .
+//      BOOLEAN                         ReorderInUse;   // At least one packet in this buffer are in reordering buffer and wait for receive indication
+	BOOLEAN bRxHandling;	// Notify this packet is being process now.
+	BOOLEAN InUse;		// USB Hardware Occupied. Wait for USB HW to put packet.
+	BOOLEAN Readable;	// Receive Complete back. OK for driver to indicate receiving packet.
+	BOOLEAN IRPPending;	// TODO: To be removed
+	atomic_t IrpLock;
+	NDIS_SPIN_LOCK RxContextLock;
+	dma_addr_t data_dma;	// urb dma on linux
+} RX_CONTEXT, *PRX_CONTEXT;
 
 /******************************************************************************
 
@@ -221,13 +209,11 @@ typedef struct _RX_CONTEXT
 ******************************************************************************/
 // 8051 firmware image for usb - use last-half base address = 0x3000
 #define FIRMWARE_IMAGE_BASE			0x3000
-#define MAX_FIRMWARE_IMAGE_SIZE		0x1000    // 4kbyte
+#define MAX_FIRMWARE_IMAGE_SIZE		0x1000	// 4kbyte
 
 #define RTMP_WRITE_FIRMWARE(_pAd, _pFwImage, _FwLen)		\
 	RTUSBFirmwareWrite(_pAd, _pFwImage, _FwLen)
 
-
-
 /******************************************************************************
 
 	USB TX Related MACRO
@@ -281,7 +267,7 @@ typedef struct _RX_CONTEXT
 			RtmpUSB_FinalWriteTxResource(pAd, pTxBlk, totalMPDUSize, TxIdx)
 
 #define HAL_LastTxIdx(pAd, QueIdx,TxIdx) \
-			/*RtmpUSBDataLastTxIdx(pAd, QueIdx,TxIdx)*/
+				/*RtmpUSBDataLastTxIdx(pAd, QueIdx,TxIdx) */
 
 #define HAL_KickOutTx(pAd, pTxBlk, QueIdx)	\
 			RtmpUSBDataKickOut(pAd, pTxBlk, QueIdx)
@@ -292,20 +278,17 @@ typedef struct _RX_CONTEXT
 #define HAL_KickOutNullFrameTx(_pAd, _QueIdx, _pNullFrame, _frameLen)	\
 			RtmpUSBNullFrameKickOut(_pAd, _QueIdx, _pNullFrame, _frameLen)
 
-#define GET_TXRING_FREENO(_pAd, _QueIdx)	(_QueIdx) //(_pAd->TxRing[_QueIdx].TxSwFreeIdx)
+#define GET_TXRING_FREENO(_pAd, _QueIdx)	(_QueIdx)	//(_pAd->TxRing[_QueIdx].TxSwFreeIdx)
 #define GET_MGMTRING_FREENO(_pAd)			(_pAd->MgmtRing.TxSwFreeIdx)
 
-
 /* ----------------- RX Related MACRO ----------------- */
 
-
 /*
   *	Device Hardware Interface Related MACRO
   */
 #define RTMP_IRQ_INIT(pAd)				do{}while(0)
 #define RTMP_IRQ_ENABLE(pAd)			do{}while(0)
 
-
 /*
   *	MLME Related MACRO
   */
@@ -330,7 +313,6 @@ typedef struct _RX_CONTEXT
 		RTUSBMlmeUp(_pAd);									\
 	}
 
-
 /*
   *	Power Save Related MACRO
   */
--- a/drivers/staging/rt2860/chip/rt2860.h
+++ b/drivers/staging/rt2860/chip/rt2860.h
@@ -43,14 +43,12 @@
 //
 #define NIC2860_PCI_DEVICE_ID	0x0601
 #define NIC2860_PCIe_DEVICE_ID	0x0681
-#define NIC2760_PCI_DEVICE_ID	0x0701		// 1T/2R Cardbus ???
-#define NIC2790_PCIe_DEVICE_ID  0x0781		// 1T/2R miniCard
-
+#define NIC2760_PCI_DEVICE_ID	0x0701	// 1T/2R Cardbus ???
+#define NIC2790_PCIe_DEVICE_ID  0x0781	// 1T/2R miniCard
 
 #define VEN_AWT_PCIe_DEVICE_ID	0x1059
 #define VEN_AWT_PCI_VENDOR_ID		0x1A3B
 
 #define EDIMAX_PCI_VENDOR_ID		0x1432
 
-
 #endif //__RT2860_H__ //
--- a/drivers/staging/rt2860/chip/rt2870.h
+++ b/drivers/staging/rt2860/chip/rt2870.h
@@ -40,8 +40,7 @@
 #include "../rtmp_type.h"
 #include "mac_usb.h"
 
-
-//#define RTMP_CHIP_NAME		"RT2870"
+//#define RTMP_CHIP_NAME                "RT2870"
 
 #endif // RT2870 //
 #endif //__RT2870_H__ //
--- a/drivers/staging/rt2860/chip/rt3070.h
+++ b/drivers/staging/rt2860/chip/rt3070.h
@@ -39,7 +39,6 @@
 
 #ifdef RT3070
 
-
 #ifndef RTMP_USB_SUPPORT
 #error "For RT3070, you should define the compile flag -DRTMP_USB_SUPPORT"
 #endif
--- a/drivers/staging/rt2860/chip/rt3090.h
+++ b/drivers/staging/rt2860/chip/rt3090.h
@@ -63,9 +63,9 @@
 //
 // Device ID & Vendor ID, these values should match EEPROM value
 //
-#define NIC3090_PCIe_DEVICE_ID  0x3090		// 1T/1R miniCard
-#define NIC3091_PCIe_DEVICE_ID  0x3091		// 1T/2R miniCard
-#define NIC3092_PCIe_DEVICE_ID  0x3092		// 2T/2R miniCard
+#define NIC3090_PCIe_DEVICE_ID  0x3090	// 1T/1R miniCard
+#define NIC3091_PCIe_DEVICE_ID  0x3091	// 1T/2R miniCard
+#define NIC3092_PCIe_DEVICE_ID  0x3092	// 2T/2R miniCard
 
 #endif // RT3090 //
 
--- a/drivers/staging/rt2860/chip/rt30xx.h
+++ b/drivers/staging/rt2860/chip/rt30xx.h
@@ -39,7 +39,6 @@
 
 #ifdef RT30xx
 
-
 extern REG_PAIR RT30xx_RFRegTable[];
 extern UCHAR NUM_RF_REG_PARMS;
 
--- a/drivers/staging/rt2860/chip/rtmp_mac.h
+++ b/drivers/staging/rt2860/chip/rtmp_mac.h
@@ -38,8 +38,6 @@
 #ifndef __RTMP_MAC_H__
 #define __RTMP_MAC_H__
 
-
-
 // =================================================================================
 // TX / RX ring descriptor format
 // =================================================================================
@@ -50,89 +48,85 @@
 #define FIFO_HCCA                 1
 #define FIFO_EDCA                 2
 
-
 //
 // TXD Wireless Information format for Tx ring and Mgmt Ring
 //
 //txop : for txop mode
 // 0:txop for the MPDU frame will be handles by ASIC by register
 // 1/2/3:the MPDU frame is send after PIFS/backoff/SIFS
-typedef	struct	PACKED _TXWI_STRUC {
-	// Word	0
+typedef struct PACKED _TXWI_STRUC {
+	// Word 0
 	// ex: 00 03 00 40 means txop = 3, PHYMODE = 1
-	UINT32		FRAG:1;		// 1 to inform TKIP engine this is a fragment.
-	UINT32		MIMOps:1;	// the remote peer is in dynamic MIMO-PS mode
-	UINT32		CFACK:1;
-	UINT32		TS:1;
-
-	UINT32		AMPDU:1;
-	UINT32		MpduDensity:3;
-	UINT32		txop:2;	//FOR "THIS" frame. 0:HT TXOP rule , 1:PIFS TX ,2:Backoff, 3:sifs only when previous frame exchange is successful.
-	UINT32		rsv:6;
-
-	UINT32		MCS:7;
-	UINT32		BW:1;	//channel bandwidth 20MHz or 40 MHz
-	UINT32		ShortGI:1;
-	UINT32		STBC:2;	// 1: STBC support MCS =0-7,   2,3 : RESERVE
-	UINT32		Ifs:1;	//
-//	UINT32		rsv2:2;	//channel bandwidth 20MHz or 40 MHz
-	UINT32		rsv2:1;
-	UINT32		TxBF:1;	// 3*3
-	UINT32		PHYMODE:2;
+	UINT32 FRAG:1;		// 1 to inform TKIP engine this is a fragment.
+	UINT32 MIMOps:1;	// the remote peer is in dynamic MIMO-PS mode
+	UINT32 CFACK:1;
+	UINT32 TS:1;
+
+	UINT32 AMPDU:1;
+	UINT32 MpduDensity:3;
+	UINT32 txop:2;		//FOR "THIS" frame. 0:HT TXOP rule , 1:PIFS TX ,2:Backoff, 3:sifs only when previous frame exchange is successful.
+	UINT32 rsv:6;
+
+	UINT32 MCS:7;
+	UINT32 BW:1;		//channel bandwidth 20MHz or 40 MHz
+	UINT32 ShortGI:1;
+	UINT32 STBC:2;		// 1: STBC support MCS =0-7,   2,3 : RESERVE
+	UINT32 Ifs:1;		//
+//      UINT32          rsv2:2; //channel bandwidth 20MHz or 40 MHz
+	UINT32 rsv2:1;
+	UINT32 TxBF:1;		// 3*3
+	UINT32 PHYMODE:2;
 	// Word1
 	// ex:  1c ff 38 00 means ACK=0, BAWinSize=7, MPDUtotalByteCount = 0x38
-	UINT32		ACK:1;
-	UINT32		NSEQ:1;
-	UINT32		BAWinSize:6;
-	UINT32		WirelessCliID:8;
-	UINT32		MPDUtotalByteCount:12;
-	UINT32		PacketId:4;
+	UINT32 ACK:1;
+	UINT32 NSEQ:1;
+	UINT32 BAWinSize:6;
+	UINT32 WirelessCliID:8;
+	UINT32 MPDUtotalByteCount:12;
+	UINT32 PacketId:4;
 	//Word2
-	UINT32		IV;
+	UINT32 IV;
 	//Word3
-	UINT32		EIV;
-}	TXWI_STRUC, *PTXWI_STRUC;
-
+	UINT32 EIV;
+} TXWI_STRUC, *PTXWI_STRUC;
 
 //
 // RXWI wireless information format, in PBF. invisible in driver.
 //
-typedef	struct	PACKED _RXWI_STRUC {
-	// Word	0
-	UINT32		WirelessCliID:8;
-	UINT32		KeyIndex:2;
-	UINT32		BSSID:3;
-	UINT32		UDF:3;
-	UINT32		MPDUtotalByteCount:12;
-	UINT32		TID:4;
-	// Word	1
-	UINT32		FRAG:4;
-	UINT32		SEQUENCE:12;
-	UINT32		MCS:7;
-	UINT32		BW:1;
-	UINT32		ShortGI:1;
-	UINT32		STBC:2;
-	UINT32		rsv:3;
-	UINT32		PHYMODE:2;              // 1: this RX frame is unicast to me
+typedef struct PACKED _RXWI_STRUC {
+	// Word 0
+	UINT32 WirelessCliID:8;
+	UINT32 KeyIndex:2;
+	UINT32 BSSID:3;
+	UINT32 UDF:3;
+	UINT32 MPDUtotalByteCount:12;
+	UINT32 TID:4;
+	// Word 1
+	UINT32 FRAG:4;
+	UINT32 SEQUENCE:12;
+	UINT32 MCS:7;
+	UINT32 BW:1;
+	UINT32 ShortGI:1;
+	UINT32 STBC:2;
+	UINT32 rsv:3;
+	UINT32 PHYMODE:2;	// 1: this RX frame is unicast to me
 	//Word2
-	UINT32		RSSI0:8;
-	UINT32		RSSI1:8;
-	UINT32		RSSI2:8;
-	UINT32		rsv1:8;
+	UINT32 RSSI0:8;
+	UINT32 RSSI1:8;
+	UINT32 RSSI2:8;
+	UINT32 rsv1:8;
 	//Word3
-	UINT32		SNR0:8;
-	UINT32		SNR1:8;
-	UINT32		FOFFSET:8;	// RT35xx
-	UINT32		rsv2:8;
-	/*UINT32		rsv2:16;*/
-}	RXWI_STRUC, *PRXWI_STRUC;
-
+	UINT32 SNR0:8;
+	UINT32 SNR1:8;
+	UINT32 FOFFSET:8;	// RT35xx
+	UINT32 rsv2:8;
+	/*UINT32                rsv2:16; */
+} RXWI_STRUC, *PRXWI_STRUC;
 
 // =================================================================================
 // Register format
 // =================================================================================
 
-
 //
 // SCH/DMA registers - base address 0x0200
 //
@@ -140,163 +134,161 @@ typedef	struct	PACKED _RXWI_STRUC {
 //
 #define DMA_CSR0		0x200
 #define INT_SOURCE_CSR		0x200
-typedef	union	_INT_SOURCE_CSR_STRUC	{
-	struct	{
-		UINT32		RxDelayINT:1;
-		UINT32		TxDelayINT:1;
-		UINT32		RxDone:1;
-		UINT32		Ac0DmaDone:1;//4
-		UINT32		Ac1DmaDone:1;
-		UINT32		Ac2DmaDone:1;
-		UINT32		Ac3DmaDone:1;
-		UINT32		HccaDmaDone:1; // bit7
-		UINT32		MgmtDmaDone:1;
-		UINT32		MCUCommandINT:1;//bit 9
-		UINT32		RxTxCoherent:1;
-		UINT32		TBTTInt:1;
-		UINT32		PreTBTT:1;
-		UINT32		TXFifoStatusInt:1;//FIFO Statistics is full, sw should read 0x171c
-		UINT32		AutoWakeup:1;//bit14
-		UINT32		GPTimer:1;
-		UINT32		RxCoherent:1;//bit16
-		UINT32		TxCoherent:1;
-		UINT32		:14;
-	}	field;
-	UINT32			word;
+typedef union _INT_SOURCE_CSR_STRUC {
+	struct {
+		UINT32 RxDelayINT:1;
+		UINT32 TxDelayINT:1;
+		UINT32 RxDone:1;
+		UINT32 Ac0DmaDone:1;	//4
+		UINT32 Ac1DmaDone:1;
+		UINT32 Ac2DmaDone:1;
+		UINT32 Ac3DmaDone:1;
+		UINT32 HccaDmaDone:1;	// bit7
+		UINT32 MgmtDmaDone:1;
+		UINT32 MCUCommandINT:1;	//bit 9
+		UINT32 RxTxCoherent:1;
+		UINT32 TBTTInt:1;
+		UINT32 PreTBTT:1;
+		UINT32 TXFifoStatusInt:1;	//FIFO Statistics is full, sw should read 0x171c
+		UINT32 AutoWakeup:1;	//bit14
+		UINT32 GPTimer:1;
+		UINT32 RxCoherent:1;	//bit16
+		UINT32 TxCoherent:1;
+		 UINT32:14;
+	} field;
+	UINT32 word;
 } INT_SOURCE_CSR_STRUC, *PINT_SOURCE_CSR_STRUC;
 
 //
 // INT_MASK_CSR:   Interrupt MASK register.   1: the interrupt is mask OFF
 //
 #define INT_MASK_CSR        0x204
-typedef	union	_INT_MASK_CSR_STRUC	{
-	struct	{
-		UINT32		RXDelay_INT_MSK:1;
-		UINT32		TxDelay:1;
-		UINT32		RxDone:1;
-		UINT32		Ac0DmaDone:1;
-		UINT32		Ac1DmaDone:1;
-		UINT32		Ac2DmaDone:1;
-		UINT32		Ac3DmaDone:1;
-		UINT32		HccaDmaDone:1;
-		UINT32		MgmtDmaDone:1;
-		UINT32		MCUCommandINT:1;
-		UINT32		:20;
-		UINT32		RxCoherent:1;
-		UINT32		TxCoherent:1;
-	}	field;
-	UINT32			word;
+typedef union _INT_MASK_CSR_STRUC {
+	struct {
+		UINT32 RXDelay_INT_MSK:1;
+		UINT32 TxDelay:1;
+		UINT32 RxDone:1;
+		UINT32 Ac0DmaDone:1;
+		UINT32 Ac1DmaDone:1;
+		UINT32 Ac2DmaDone:1;
+		UINT32 Ac3DmaDone:1;
+		UINT32 HccaDmaDone:1;
+		UINT32 MgmtDmaDone:1;
+		UINT32 MCUCommandINT:1;
+		 UINT32:20;
+		UINT32 RxCoherent:1;
+		UINT32 TxCoherent:1;
+	} field;
+	UINT32 word;
 } INT_MASK_CSR_STRUC, *PINT_MASK_CSR_STRUC;
 
 #define WPDMA_GLO_CFG	0x208
-typedef	union	_WPDMA_GLO_CFG_STRUC	{
-	struct	{
-		UINT32		EnableTxDMA:1;
-		UINT32		TxDMABusy:1;
-		UINT32		EnableRxDMA:1;
-		UINT32		RxDMABusy:1;
-		UINT32		WPDMABurstSIZE:2;
-		UINT32		EnTXWriteBackDDONE:1;
-		UINT32		BigEndian:1;
-		UINT32		RXHdrScater:8;
-		UINT32		HDR_SEG_LEN:16;
-	}	field;
-	UINT32			word;
+typedef union _WPDMA_GLO_CFG_STRUC {
+	struct {
+		UINT32 EnableTxDMA:1;
+		UINT32 TxDMABusy:1;
+		UINT32 EnableRxDMA:1;
+		UINT32 RxDMABusy:1;
+		UINT32 WPDMABurstSIZE:2;
+		UINT32 EnTXWriteBackDDONE:1;
+		UINT32 BigEndian:1;
+		UINT32 RXHdrScater:8;
+		UINT32 HDR_SEG_LEN:16;
+	} field;
+	UINT32 word;
 } WPDMA_GLO_CFG_STRUC, *PWPDMA_GLO_CFG_STRUC;
 
 #define WPDMA_RST_IDX	0x20c
-typedef	union	_WPDMA_RST_IDX_STRUC	{
-	struct	{
-		UINT32		RST_DTX_IDX0:1;
-		UINT32		RST_DTX_IDX1:1;
-		UINT32		RST_DTX_IDX2:1;
-		UINT32		RST_DTX_IDX3:1;
-		UINT32		RST_DTX_IDX4:1;
-		UINT32		RST_DTX_IDX5:1;
-		UINT32		rsv:10;
-		UINT32		RST_DRX_IDX0:1;
-		UINT32		:15;
-	}	field;
-	UINT32			word;
+typedef union _WPDMA_RST_IDX_STRUC {
+	struct {
+		UINT32 RST_DTX_IDX0:1;
+		UINT32 RST_DTX_IDX1:1;
+		UINT32 RST_DTX_IDX2:1;
+		UINT32 RST_DTX_IDX3:1;
+		UINT32 RST_DTX_IDX4:1;
+		UINT32 RST_DTX_IDX5:1;
+		UINT32 rsv:10;
+		UINT32 RST_DRX_IDX0:1;
+		 UINT32:15;
+	} field;
+	UINT32 word;
 } WPDMA_RST_IDX_STRUC, *PWPDMA_RST_IDX_STRUC;
 #define DELAY_INT_CFG  0x0210
-typedef	union	_DELAY_INT_CFG_STRUC	{
-	struct	{
-		UINT32		RXMAX_PTIME:8;
-		UINT32		RXMAX_PINT:7;
-		UINT32		RXDLY_INT_EN:1;
-		UINT32		TXMAX_PTIME:8;
-		UINT32		TXMAX_PINT:7;
-		UINT32		TXDLY_INT_EN:1;
-	}	field;
-	UINT32			word;
+typedef union _DELAY_INT_CFG_STRUC {
+	struct {
+		UINT32 RXMAX_PTIME:8;
+		UINT32 RXMAX_PINT:7;
+		UINT32 RXDLY_INT_EN:1;
+		UINT32 TXMAX_PTIME:8;
+		UINT32 TXMAX_PINT:7;
+		UINT32 TXDLY_INT_EN:1;
+	} field;
+	UINT32 word;
 } DELAY_INT_CFG_STRUC, *PDELAY_INT_CFG_STRUC;
 #define WMM_AIFSN_CFG   0x0214
-typedef	union	_AIFSN_CSR_STRUC	{
-	struct	{
-	    UINT32   Aifsn0:4;       // for AC_BE
-	    UINT32   Aifsn1:4;       // for AC_BK
-	    UINT32   Aifsn2:4;       // for AC_VI
-	    UINT32   Aifsn3:4;       // for AC_VO
-	    UINT32   Rsv:16;
-	}	field;
-	UINT32			word;
-}	AIFSN_CSR_STRUC, *PAIFSN_CSR_STRUC;
+typedef union _AIFSN_CSR_STRUC {
+	struct {
+		UINT32 Aifsn0:4;	// for AC_BE
+		UINT32 Aifsn1:4;	// for AC_BK
+		UINT32 Aifsn2:4;	// for AC_VI
+		UINT32 Aifsn3:4;	// for AC_VO
+		UINT32 Rsv:16;
+	} field;
+	UINT32 word;
+} AIFSN_CSR_STRUC, *PAIFSN_CSR_STRUC;
 //
 // CWMIN_CSR: CWmin for each EDCA AC
 //
 #define WMM_CWMIN_CFG   0x0218
-typedef	union	_CWMIN_CSR_STRUC	{
-	struct	{
-	    UINT32   Cwmin0:4;       // for AC_BE
-	    UINT32   Cwmin1:4;       // for AC_BK
-	    UINT32   Cwmin2:4;       // for AC_VI
-	    UINT32   Cwmin3:4;       // for AC_VO
-	    UINT32   Rsv:16;
-	}	field;
-	UINT32			word;
-}	CWMIN_CSR_STRUC, *PCWMIN_CSR_STRUC;
+typedef union _CWMIN_CSR_STRUC {
+	struct {
+		UINT32 Cwmin0:4;	// for AC_BE
+		UINT32 Cwmin1:4;	// for AC_BK
+		UINT32 Cwmin2:4;	// for AC_VI
+		UINT32 Cwmin3:4;	// for AC_VO
+		UINT32 Rsv:16;
+	} field;
+	UINT32 word;
+} CWMIN_CSR_STRUC, *PCWMIN_CSR_STRUC;
 
 //
 // CWMAX_CSR: CWmin for each EDCA AC
 //
 #define WMM_CWMAX_CFG   0x021c
-typedef	union	_CWMAX_CSR_STRUC	{
-	struct	{
-	    UINT32   Cwmax0:4;       // for AC_BE
-	    UINT32   Cwmax1:4;       // for AC_BK
-	    UINT32   Cwmax2:4;       // for AC_VI
-	    UINT32   Cwmax3:4;       // for AC_VO
-	    UINT32   Rsv:16;
-	}	field;
-	UINT32			word;
-}	CWMAX_CSR_STRUC, *PCWMAX_CSR_STRUC;
-
+typedef union _CWMAX_CSR_STRUC {
+	struct {
+		UINT32 Cwmax0:4;	// for AC_BE
+		UINT32 Cwmax1:4;	// for AC_BK
+		UINT32 Cwmax2:4;	// for AC_VI
+		UINT32 Cwmax3:4;	// for AC_VO
+		UINT32 Rsv:16;
+	} field;
+	UINT32 word;
+} CWMAX_CSR_STRUC, *PCWMAX_CSR_STRUC;
 
 //
 // AC_TXOP_CSR0: AC_BK/AC_BE TXOP register
 //
 #define WMM_TXOP0_CFG    0x0220
-typedef	union	_AC_TXOP_CSR0_STRUC	{
-	struct	{
-	    USHORT  Ac0Txop;        // for AC_BK, in unit of 32us
-	    USHORT  Ac1Txop;        // for AC_BE, in unit of 32us
-	}	field;
-	UINT32			word;
-}	AC_TXOP_CSR0_STRUC, *PAC_TXOP_CSR0_STRUC;
+typedef union _AC_TXOP_CSR0_STRUC {
+	struct {
+		USHORT Ac0Txop;	// for AC_BK, in unit of 32us
+		USHORT Ac1Txop;	// for AC_BE, in unit of 32us
+	} field;
+	UINT32 word;
+} AC_TXOP_CSR0_STRUC, *PAC_TXOP_CSR0_STRUC;
 
 //
 // AC_TXOP_CSR1: AC_VO/AC_VI TXOP register
 //
 #define WMM_TXOP1_CFG    0x0224
-typedef	union	_AC_TXOP_CSR1_STRUC	{
-	struct	{
-	    USHORT  Ac2Txop;        // for AC_VI, in unit of 32us
-	    USHORT  Ac3Txop;        // for AC_VO, in unit of 32us
-	}	field;
-	UINT32			word;
-}	AC_TXOP_CSR1_STRUC, *PAC_TXOP_CSR1_STRUC;
-
+typedef union _AC_TXOP_CSR1_STRUC {
+	struct {
+		USHORT Ac2Txop;	// for AC_VI, in unit of 32us
+		USHORT Ac3Txop;	// for AC_VO, in unit of 32us
+	} field;
+	UINT32 word;
+} AC_TXOP_CSR1_STRUC, *PAC_TXOP_CSR1_STRUC;
 
 #define RINGREG_DIFF			0x10
 #define GPIO_CTRL_CFG    0x0228	//MAC_CSR13
@@ -305,23 +297,23 @@ typedef	union	_AC_TXOP_CSR1_STRUC	{
 #define TX_MAX_CNT0      0x0234
 #define TX_CTX_IDX0       0x0238
 #define TX_DTX_IDX0      0x023c
-#define TX_BASE_PTR1     0x0240		//AC_BE base address
+#define TX_BASE_PTR1     0x0240	//AC_BE base address
 #define TX_MAX_CNT1      0x0244
 #define TX_CTX_IDX1       0x0248
 #define TX_DTX_IDX1      0x024c
-#define TX_BASE_PTR2     0x0250		//AC_VI base address
+#define TX_BASE_PTR2     0x0250	//AC_VI base address
 #define TX_MAX_CNT2      0x0254
 #define TX_CTX_IDX2       0x0258
 #define TX_DTX_IDX2      0x025c
-#define TX_BASE_PTR3     0x0260		//AC_VO base address
+#define TX_BASE_PTR3     0x0260	//AC_VO base address
 #define TX_MAX_CNT3      0x0264
 #define TX_CTX_IDX3       0x0268
 #define TX_DTX_IDX3      0x026c
-#define TX_BASE_PTR4     0x0270		//HCCA base address
+#define TX_BASE_PTR4     0x0270	//HCCA base address
 #define TX_MAX_CNT4      0x0274
 #define TX_CTX_IDX4       0x0278
 #define TX_DTX_IDX4      0x027c
-#define TX_BASE_PTR5     0x0280		//MGMT base address
+#define TX_BASE_PTR5     0x0280	//MGMT base address
 #define  TX_MAX_CNT5     0x0284
 #define TX_CTX_IDX5       0x0288
 #define TX_DTX_IDX5      0x028c
@@ -333,26 +325,24 @@ typedef	union	_AC_TXOP_CSR1_STRUC	{
 #define RX_CRX_IDX       0x0298
 #define RX_DRX_IDX      0x029c
 
-
 #define USB_DMA_CFG      0x02a0
-typedef	union	_USB_DMA_CFG_STRUC	{
-	struct	{
-	    UINT32  RxBulkAggTOut:8;        //Rx Bulk Aggregation TimeOut  in unit of 33ns
-	    UINT32  RxBulkAggLmt:8;        //Rx Bulk Aggregation Limit  in unit of 256 bytes
-	    UINT32  phyclear:1;			//phy watch dog enable. write 1
-	    UINT32  rsv:2;
-	    UINT32  TxClear:1;        //Clear USB DMA TX path
-	    UINT32  TxopHalt:1;        //Halt TXOP count down when TX buffer is full.
-	    UINT32  RxBulkAggEn:1;        //Enable Rx Bulk Aggregation
-	    UINT32  RxBulkEn:1;        //Enable USB DMA Rx
-	    UINT32  TxBulkEn:1;        //Enable USB DMA Tx
-	    UINT32  EpoutValid:6;        //OUT endpoint data valid
-	    UINT32  RxBusy:1;        //USB DMA RX FSM busy
-	    UINT32  TxBusy:1;		//USB DMA TX FSM busy
-	}	field;
-	UINT32			word;
-}	USB_DMA_CFG_STRUC, *PUSB_DMA_CFG_STRUC;
-
+typedef union _USB_DMA_CFG_STRUC {
+	struct {
+		UINT32 RxBulkAggTOut:8;	//Rx Bulk Aggregation TimeOut  in unit of 33ns
+		UINT32 RxBulkAggLmt:8;	//Rx Bulk Aggregation Limit  in unit of 256 bytes
+		UINT32 phyclear:1;	//phy watch dog enable. write 1
+		UINT32 rsv:2;
+		UINT32 TxClear:1;	//Clear USB DMA TX path
+		UINT32 TxopHalt:1;	//Halt TXOP count down when TX buffer is full.
+		UINT32 RxBulkAggEn:1;	//Enable Rx Bulk Aggregation
+		UINT32 RxBulkEn:1;	//Enable USB DMA Rx
+		UINT32 TxBulkEn:1;	//Enable USB DMA Tx
+		UINT32 EpoutValid:6;	//OUT endpoint data valid
+		UINT32 RxBusy:1;	//USB DMA RX FSM busy
+		UINT32 TxBusy:1;	//USB DMA TX FSM busy
+	} field;
+	UINT32 word;
+} USB_DMA_CFG_STRUC, *PUSB_DMA_CFG_STRUC;
 
 //
 //  3  PBF  registers
@@ -385,7 +375,6 @@ typedef	union	_USB_DMA_CFG_STRUC	{
 #define LDO_CFG0				0x05d4
 #define GPIO_SWITCH				0x05dc
 
-
 //
 //  4  MAC  registers
 //
@@ -393,143 +382,143 @@ typedef	union	_USB_DMA_CFG_STRUC	{
 //  4.1 MAC SYSTEM  configuration registers (offset:0x1000)
 //
 #define MAC_CSR0            0x1000
-typedef	union	_ASIC_VER_ID_STRUC	{
-	struct	{
-	    USHORT  ASICRev;        // reversion  : 0
-	    USHORT  ASICVer;        // version : 2860
-	}	field;
-	UINT32			word;
-}	ASIC_VER_ID_STRUC, *PASIC_VER_ID_STRUC;
-#define MAC_SYS_CTRL            0x1004		//MAC_CSR1
-#define MAC_ADDR_DW0				0x1008		// MAC ADDR DW0
-#define MAC_ADDR_DW1			 0x100c		// MAC ADDR DW1
+typedef union _ASIC_VER_ID_STRUC {
+	struct {
+		USHORT ASICRev;	// reversion  : 0
+		USHORT ASICVer;	// version : 2860
+	} field;
+	UINT32 word;
+} ASIC_VER_ID_STRUC, *PASIC_VER_ID_STRUC;
+#define MAC_SYS_CTRL            0x1004	//MAC_CSR1
+#define MAC_ADDR_DW0				0x1008	// MAC ADDR DW0
+#define MAC_ADDR_DW1			 0x100c	// MAC ADDR DW1
 //
 // MAC_CSR2: STA MAC register 0
 //
-typedef	union	_MAC_DW0_STRUC	{
-	struct	{
-		UCHAR		Byte0;		// MAC address byte 0
-		UCHAR		Byte1;		// MAC address byte 1
-		UCHAR		Byte2;		// MAC address byte 2
-		UCHAR		Byte3;		// MAC address byte 3
-	}	field;
-	UINT32			word;
-}	MAC_DW0_STRUC, *PMAC_DW0_STRUC;
+typedef union _MAC_DW0_STRUC {
+	struct {
+		UCHAR Byte0;	// MAC address byte 0
+		UCHAR Byte1;	// MAC address byte 1
+		UCHAR Byte2;	// MAC address byte 2
+		UCHAR Byte3;	// MAC address byte 3
+	} field;
+	UINT32 word;
+} MAC_DW0_STRUC, *PMAC_DW0_STRUC;
 
 //
 // MAC_CSR3: STA MAC register 1
 //
-typedef	union	_MAC_DW1_STRUC	{
-	struct	{
-		UCHAR		Byte4;		// MAC address byte 4
-		UCHAR		Byte5;		// MAC address byte 5
-		UCHAR		U2MeMask;
-		UCHAR		Rsvd1;
-	}	field;
-	UINT32			word;
-}	MAC_DW1_STRUC, *PMAC_DW1_STRUC;
+typedef union _MAC_DW1_STRUC {
+	struct {
+		UCHAR Byte4;	// MAC address byte 4
+		UCHAR Byte5;	// MAC address byte 5
+		UCHAR U2MeMask;
+		UCHAR Rsvd1;
+	} field;
+	UINT32 word;
+} MAC_DW1_STRUC, *PMAC_DW1_STRUC;
 
-#define MAC_BSSID_DW0				0x1010		// MAC BSSID DW0
-#define MAC_BSSID_DW1				0x1014		// MAC BSSID DW1
+#define MAC_BSSID_DW0				0x1010	// MAC BSSID DW0
+#define MAC_BSSID_DW1				0x1014	// MAC BSSID DW1
 
 //
 // MAC_CSR5: BSSID register 1
 //
-typedef	union	_MAC_CSR5_STRUC	{
-	struct	{
-		UCHAR		Byte4;		 // BSSID byte 4
-		UCHAR		Byte5;		 // BSSID byte 5
-		USHORT		BssIdMask:2; // 0: one BSSID, 10: 4 BSSID,  01: 2 BSSID , 11: 8BSSID
-		USHORT		MBssBcnNum:3;
-		USHORT		Rsvd:11;
-	}	field;
-	UINT32			word;
-}	MAC_CSR5_STRUC, *PMAC_CSR5_STRUC;
+typedef union _MAC_CSR5_STRUC {
+	struct {
+		UCHAR Byte4;	// BSSID byte 4
+		UCHAR Byte5;	// BSSID byte 5
+		USHORT BssIdMask:2;	// 0: one BSSID, 10: 4 BSSID,  01: 2 BSSID , 11: 8BSSID
+		USHORT MBssBcnNum:3;
+		USHORT Rsvd:11;
+	} field;
+	UINT32 word;
+} MAC_CSR5_STRUC, *PMAC_CSR5_STRUC;
 
-#define MAX_LEN_CFG              0x1018		// rt2860b max 16k bytes. bit12:13 Maximum PSDU length (power factor) 0:2^13, 1:2^14, 2:2^15, 3:2^16
-#define BBP_CSR_CFG			0x101c		//
+#define MAX_LEN_CFG              0x1018	// rt2860b max 16k bytes. bit12:13 Maximum PSDU length (power factor) 0:2^13, 1:2^14, 2:2^15, 3:2^16
+#define BBP_CSR_CFG			0x101c	//
 //
 // BBP_CSR_CFG: BBP serial control register
 //
-typedef	union	_BBP_CSR_CFG_STRUC	{
-	struct	{
-		UINT32		Value:8;			// Register	value to program into BBP
-		UINT32		RegNum:8;			// Selected	BBP	register
-		UINT32		fRead:1;		    // 0: Write	BBP, 1:	Read BBP
-		UINT32		Busy:1;				// 1: ASIC is busy execute BBP programming.
-		UINT32		BBP_PAR_DUR:1;		     // 0: 4 MAC clock cycles  1: 8 MAC clock cycles
-		UINT32		BBP_RW_MODE:1;		// 0: use serial mode  1:parallel
-		UINT32		:12;
-	}	field;
-	UINT32			word;
-}	BBP_CSR_CFG_STRUC, *PBBP_CSR_CFG_STRUC;
+typedef union _BBP_CSR_CFG_STRUC {
+	struct {
+		UINT32 Value:8;	// Register     value to program into BBP
+		UINT32 RegNum:8;	// Selected     BBP     register
+		UINT32 fRead:1;	// 0: Write BBP, 1: Read BBP
+		UINT32 Busy:1;	// 1: ASIC is busy execute BBP programming.
+		UINT32 BBP_PAR_DUR:1;	// 0: 4 MAC clock cycles  1: 8 MAC clock cycles
+		UINT32 BBP_RW_MODE:1;	// 0: use serial mode  1:parallel
+		 UINT32:12;
+	} field;
+	UINT32 word;
+} BBP_CSR_CFG_STRUC, *PBBP_CSR_CFG_STRUC;
 #define RF_CSR_CFG0			0x1020
 //
 // RF_CSR_CFG: RF control register
 //
-typedef	union	_RF_CSR_CFG0_STRUC	{
-	struct	{
-		UINT32		RegIdAndContent:24;			// Register	value to program into BBP
-		UINT32		bitwidth:5;			// Selected	BBP	register
-		UINT32		StandbyMode:1;		    // 0: high when stand by 1:	low when standby
-		UINT32		Sel:1;				// 0:RF_LE0 activate  1:RF_LE1 activate
-		UINT32		Busy:1;		    // 0: idle 1: 8busy
-	}	field;
-	UINT32			word;
-}	RF_CSR_CFG0_STRUC, *PRF_CSR_CFG0_STRUC;
+typedef union _RF_CSR_CFG0_STRUC {
+	struct {
+		UINT32 RegIdAndContent:24;	// Register     value to program into BBP
+		UINT32 bitwidth:5;	// Selected     BBP     register
+		UINT32 StandbyMode:1;	// 0: high when stand by 1: low when standby
+		UINT32 Sel:1;	// 0:RF_LE0 activate  1:RF_LE1 activate
+		UINT32 Busy:1;	// 0: idle 1: 8busy
+	} field;
+	UINT32 word;
+} RF_CSR_CFG0_STRUC, *PRF_CSR_CFG0_STRUC;
 #define RF_CSR_CFG1			0x1024
-typedef	union	_RF_CSR_CFG1_STRUC	{
-	struct	{
-		UINT32		RegIdAndContent:24;			// Register	value to program into BBP
-		UINT32		RFGap:5;			// Gap between BB_CONTROL_RF and RF_LE. 0: 3 system clock cycle (37.5usec) 1: 5 system clock cycle (62.5usec)
-		UINT32		rsv:7;		    // 0: idle 1: 8busy
-	}	field;
-	UINT32			word;
-}	RF_CSR_CFG1_STRUC, *PRF_CSR_CFG1_STRUC;
-#define RF_CSR_CFG2			0x1028		//
-typedef	union	_RF_CSR_CFG2_STRUC	{
-	struct	{
-		UINT32		RegIdAndContent:24;			// Register	value to program into BBP
-		UINT32		rsv:8;		    // 0: idle 1: 8busy
-	}	field;
-	UINT32			word;
-}	RF_CSR_CFG2_STRUC, *PRF_CSR_CFG2_STRUC;
-#define LED_CFG				0x102c		//  MAC_CSR14
-typedef	union	_LED_CFG_STRUC	{
-	struct	{
-		UINT32		OnPeriod:8;			// blinking on period unit 1ms
-		UINT32		OffPeriod:8;			// blinking off period unit 1ms
-		UINT32		SlowBlinkPeriod:6;			// slow blinking period. unit:1ms
-		UINT32		rsv:2;
-		UINT32		RLedMode:2;			// red Led Mode    0: off1: blinking upon TX2: periodic slow blinking3: always on
-		UINT32		GLedMode:2;			// green Led Mode
-		UINT32		YLedMode:2;			// yellow Led Mode
-		UINT32		LedPolar:1;			// Led Polarity.  0: active low1: active high
-		UINT32		:1;
-	}	field;
-	UINT32			word;
-}	LED_CFG_STRUC, *PLED_CFG_STRUC;
+typedef union _RF_CSR_CFG1_STRUC {
+	struct {
+		UINT32 RegIdAndContent:24;	// Register     value to program into BBP
+		UINT32 RFGap:5;	// Gap between BB_CONTROL_RF and RF_LE. 0: 3 system clock cycle (37.5usec) 1: 5 system clock cycle (62.5usec)
+		UINT32 rsv:7;	// 0: idle 1: 8busy
+	} field;
+	UINT32 word;
+} RF_CSR_CFG1_STRUC, *PRF_CSR_CFG1_STRUC;
+#define RF_CSR_CFG2			0x1028	//
+typedef union _RF_CSR_CFG2_STRUC {
+	struct {
+		UINT32 RegIdAndContent:24;	// Register     value to program into BBP
+		UINT32 rsv:8;	// 0: idle 1: 8busy
+	} field;
+	UINT32 word;
+} RF_CSR_CFG2_STRUC, *PRF_CSR_CFG2_STRUC;
+#define LED_CFG				0x102c	//  MAC_CSR14
+typedef union _LED_CFG_STRUC {
+	struct {
+		UINT32 OnPeriod:8;	// blinking on period unit 1ms
+		UINT32 OffPeriod:8;	// blinking off period unit 1ms
+		UINT32 SlowBlinkPeriod:6;	// slow blinking period. unit:1ms
+		UINT32 rsv:2;
+		UINT32 RLedMode:2;	// red Led Mode    0: off1: blinking upon TX2: periodic slow blinking3: always on
+		UINT32 GLedMode:2;	// green Led Mode
+		UINT32 YLedMode:2;	// yellow Led Mode
+		UINT32 LedPolar:1;	// Led Polarity.  0: active low1: active high
+		 UINT32:1;
+	} field;
+	UINT32 word;
+} LED_CFG_STRUC, *PLED_CFG_STRUC;
 //
 //  4.2 MAC TIMING  configuration registers (offset:0x1100)
 //
-#define XIFS_TIME_CFG             0x1100		 // MAC_CSR8  MAC_CSR9
-typedef	union	_IFS_SLOT_CFG_STRUC	{
-	struct	{
-	    UINT32  CckmSifsTime:8;        //  unit 1us. Applied after CCK RX/TX
-	    UINT32  OfdmSifsTime:8;        //  unit 1us. Applied after OFDM RX/TX
-	    UINT32  OfdmXifsTime:4;        //OFDM SIFS. unit 1us. Applied after OFDM RX when MAC doesn't reference BBP signal BBRXEND
-	    UINT32  EIFS:9;        //  unit 1us
-	    UINT32  BBRxendEnable:1;        //  reference RXEND signal to begin XIFS defer
-	    UINT32  rsv:2;
-	}	field;
-	UINT32			word;
-}	IFS_SLOT_CFG_STRUC, *PIFS_SLOT_CFG_STRUC;
-
-#define BKOFF_SLOT_CFG             0x1104		 //  mac_csr9 last 8 bits
-#define NAV_TIME_CFG             0x1108		 // NAV  (MAC_CSR15)
-#define CH_TIME_CFG             0x110C			// Count as channel busy
-#define PBF_LIFE_TIMER             0x1110		 //TX/RX MPDU timestamp timer (free run)Unit: 1us
-#define BCN_TIME_CFG             0x1114		 // TXRX_CSR9
+#define XIFS_TIME_CFG             0x1100	// MAC_CSR8  MAC_CSR9
+typedef union _IFS_SLOT_CFG_STRUC {
+	struct {
+		UINT32 CckmSifsTime:8;	//  unit 1us. Applied after CCK RX/TX
+		UINT32 OfdmSifsTime:8;	//  unit 1us. Applied after OFDM RX/TX
+		UINT32 OfdmXifsTime:4;	//OFDM SIFS. unit 1us. Applied after OFDM RX when MAC doesn't reference BBP signal BBRXEND
+		UINT32 EIFS:9;	//  unit 1us
+		UINT32 BBRxendEnable:1;	//  reference RXEND signal to begin XIFS defer
+		UINT32 rsv:2;
+	} field;
+	UINT32 word;
+} IFS_SLOT_CFG_STRUC, *PIFS_SLOT_CFG_STRUC;
+
+#define BKOFF_SLOT_CFG             0x1104	//  mac_csr9 last 8 bits
+#define NAV_TIME_CFG             0x1108	// NAV  (MAC_CSR15)
+#define CH_TIME_CFG             0x110C	// Count as channel busy
+#define PBF_LIFE_TIMER             0x1110	//TX/RX MPDU timestamp timer (free run)Unit: 1us
+#define BCN_TIME_CFG             0x1114	// TXRX_CSR9
 
 #define BCN_OFFSET0				0x042C
 #define BCN_OFFSET1				0x0430
@@ -537,62 +526,62 @@ typedef	union	_IFS_SLOT_CFG_STRUC	{
 //
 // BCN_TIME_CFG : Synchronization control register
 //
-typedef	union	_BCN_TIME_CFG_STRUC	{
-	struct	{
-		UINT32       BeaconInterval:16;  // in unit of 1/16 TU
-		UINT32		bTsfTicking:1;		// Enable TSF auto counting
-		UINT32		TsfSyncMode:2;		// Enable TSF sync, 00: disable, 01: infra mode, 10: ad-hoc mode
-        UINT32       bTBTTEnable:1;
-		UINT32		bBeaconGen:1;		// Enable beacon generator
-        UINT32       :3;
-		UINT32		TxTimestampCompensate:8;
-	}	field;
-	UINT32			word;
-}	BCN_TIME_CFG_STRUC, *PBCN_TIME_CFG_STRUC;
-#define TBTT_SYNC_CFG            0x1118			// txrx_csr10
-#define TSF_TIMER_DW0             0x111C		// Local TSF timer lsb 32 bits. Read-only
-#define TSF_TIMER_DW1             0x1120		// msb 32 bits. Read-only.
-#define TBTT_TIMER		0x1124			// TImer remains till next TBTT. Read-only.  TXRX_CSR14
-#define INT_TIMER_CFG			0x1128			//
-#define INT_TIMER_EN			0x112c			//  GP-timer and pre-tbtt Int enable
-#define CH_IDLE_STA			0x1130			//  channel idle time
-#define CH_BUSY_STA			0x1134			//  channle busy time
+typedef union _BCN_TIME_CFG_STRUC {
+	struct {
+		UINT32 BeaconInterval:16;	// in unit of 1/16 TU
+		UINT32 bTsfTicking:1;	// Enable TSF auto counting
+		UINT32 TsfSyncMode:2;	// Enable TSF sync, 00: disable, 01: infra mode, 10: ad-hoc mode
+		UINT32 bTBTTEnable:1;
+		UINT32 bBeaconGen:1;	// Enable beacon generator
+		 UINT32:3;
+		UINT32 TxTimestampCompensate:8;
+	} field;
+	UINT32 word;
+} BCN_TIME_CFG_STRUC, *PBCN_TIME_CFG_STRUC;
+#define TBTT_SYNC_CFG            0x1118	// txrx_csr10
+#define TSF_TIMER_DW0             0x111C	// Local TSF timer lsb 32 bits. Read-only
+#define TSF_TIMER_DW1             0x1120	// msb 32 bits. Read-only.
+#define TBTT_TIMER		0x1124	// TImer remains till next TBTT. Read-only.  TXRX_CSR14
+#define INT_TIMER_CFG			0x1128	//
+#define INT_TIMER_EN			0x112c	//  GP-timer and pre-tbtt Int enable
+#define CH_IDLE_STA			0x1130	//  channel idle time
+#define CH_BUSY_STA			0x1134	//  channle busy time
 //
 //  4.2 MAC POWER  configuration registers (offset:0x1200)
 //
-#define MAC_STATUS_CFG             0x1200		 // old MAC_CSR12
-#define PWR_PIN_CFG             0x1204		 // old MAC_CSR12
-#define AUTO_WAKEUP_CFG             0x1208		 // old MAC_CSR10
+#define MAC_STATUS_CFG             0x1200	// old MAC_CSR12
+#define PWR_PIN_CFG             0x1204	// old MAC_CSR12
+#define AUTO_WAKEUP_CFG             0x1208	// old MAC_CSR10
 //
 // AUTO_WAKEUP_CFG: Manual power control / status register
 //
-typedef	union	_AUTO_WAKEUP_STRUC	{
-	struct	{
-		UINT32       AutoLeadTime:8;
-		UINT32       NumofSleepingTbtt:7;          // ForceWake has high privilege than PutToSleep when both set
-		UINT32		EnableAutoWakeup:1;	// 0:sleep, 1:awake
-		UINT32		:16;
-	}	field;
-	UINT32			word;
-}	AUTO_WAKEUP_STRUC, *PAUTO_WAKEUP_STRUC;
+typedef union _AUTO_WAKEUP_STRUC {
+	struct {
+		UINT32 AutoLeadTime:8;
+		UINT32 NumofSleepingTbtt:7;	// ForceWake has high privilege than PutToSleep when both set
+		UINT32 EnableAutoWakeup:1;	// 0:sleep, 1:awake
+		 UINT32:16;
+	} field;
+	UINT32 word;
+} AUTO_WAKEUP_STRUC, *PAUTO_WAKEUP_STRUC;
 //
 //  4.3 MAC TX  configuration registers (offset:0x1300)
 //
 
-#define EDCA_AC0_CFG	0x1300		//AC_TXOP_CSR0 0x3474
+#define EDCA_AC0_CFG	0x1300	//AC_TXOP_CSR0 0x3474
 #define EDCA_AC1_CFG	0x1304
 #define EDCA_AC2_CFG	0x1308
 #define EDCA_AC3_CFG	0x130c
-typedef	union	_EDCA_AC_CFG_STRUC	{
-	struct	{
-	    UINT32  AcTxop:8;        //  in unit of 32us
-	    UINT32  Aifsn:4;        // # of slot time
-	    UINT32  Cwmin:4;        //
-	    UINT32  Cwmax:4;        //unit power of 2
-	    UINT32  :12;       //
-	}	field;
-	UINT32			word;
-}	EDCA_AC_CFG_STRUC, *PEDCA_AC_CFG_STRUC;
+typedef union _EDCA_AC_CFG_STRUC {
+	struct {
+		UINT32 AcTxop:8;	//  in unit of 32us
+		UINT32 Aifsn:4;	// # of slot time
+		UINT32 Cwmin:4;	//
+		UINT32 Cwmax:4;	//unit power of 2
+		 UINT32:12;	//
+	} field;
+	UINT32 word;
+} EDCA_AC_CFG_STRUC, *PEDCA_AC_CFG_STRUC;
 
 #define EDCA_TID_AC_MAP	0x1310
 #define TX_PWR_CFG_0	0x1314
@@ -601,7 +590,7 @@ typedef	union	_EDCA_AC_CFG_STRUC	{
 #define TX_PWR_CFG_3	0x1320
 #define TX_PWR_CFG_4	0x1324
 #define TX_PIN_CFG		0x1328
-#define TX_BAND_CFG	0x132c		// 0x1 use upper 20MHz. 0 juse lower 20MHz
+#define TX_BAND_CFG	0x132c	// 0x1 use upper 20MHz. 0 juse lower 20MHz
 #define TX_SW_CFG0		0x1330
 #define TX_SW_CFG1		0x1334
 #define TX_SW_CFG2		0x1338
@@ -609,163 +598,162 @@ typedef	union	_EDCA_AC_CFG_STRUC	{
 #define TXOP_CTRL_CFG		0x1340
 #define TX_RTS_CFG		0x1344
 
-typedef	union	_TX_RTS_CFG_STRUC	{
-	struct	{
-	    UINT32       AutoRtsRetryLimit:8;
-	    UINT32       RtsThres:16;    // unit:byte
-	    UINT32       RtsFbkEn:1;    // enable rts rate fallback
-	    UINT32       rsv:7;     // 1: HT non-STBC control frame enable
-	}	field;
-	UINT32			word;
-}	TX_RTS_CFG_STRUC, *PTX_RTS_CFG_STRUC;
+typedef union _TX_RTS_CFG_STRUC {
+	struct {
+		UINT32 AutoRtsRetryLimit:8;
+		UINT32 RtsThres:16;	// unit:byte
+		UINT32 RtsFbkEn:1;	// enable rts rate fallback
+		UINT32 rsv:7;	// 1: HT non-STBC control frame enable
+	} field;
+	UINT32 word;
+} TX_RTS_CFG_STRUC, *PTX_RTS_CFG_STRUC;
 #define TX_TIMEOUT_CFG	0x1348
-typedef	union	_TX_TIMEOUT_CFG_STRUC	{
-	struct	{
-	    UINT32       rsv:4;
-	    UINT32       MpduLifeTime:4;    //  expiration time = 2^(9+MPDU LIFE TIME)  us
-	    UINT32       RxAckTimeout:8;	// unit:slot. Used for TX precedure
-	    UINT32       TxopTimeout:8;	//TXOP timeout value for TXOP truncation.  It is recommended that (SLOT_TIME) > (TX_OP_TIMEOUT) > (RX_ACK_TIMEOUT)
-	    UINT32       rsv2:8;     // 1: HT non-STBC control frame enable
-	}	field;
-	UINT32			word;
-}	TX_TIMEOUT_CFG_STRUC, *PTX_TIMEOUT_CFG_STRUC;
+typedef union _TX_TIMEOUT_CFG_STRUC {
+	struct {
+		UINT32 rsv:4;
+		UINT32 MpduLifeTime:4;	//  expiration time = 2^(9+MPDU LIFE TIME)  us
+		UINT32 RxAckTimeout:8;	// unit:slot. Used for TX precedure
+		UINT32 TxopTimeout:8;	//TXOP timeout value for TXOP truncation.  It is recommended that (SLOT_TIME) > (TX_OP_TIMEOUT) > (RX_ACK_TIMEOUT)
+		UINT32 rsv2:8;	// 1: HT non-STBC control frame enable
+	} field;
+	UINT32 word;
+} TX_TIMEOUT_CFG_STRUC, *PTX_TIMEOUT_CFG_STRUC;
 #define TX_RTY_CFG	0x134c
-typedef	union PACKED _TX_RTY_CFG_STRUC	{
-	struct	{
-	    UINT32       ShortRtyLimit:8;	//  short retry limit
-	    UINT32       LongRtyLimit:8;	//long retry limit
-	    UINT32       LongRtyThre:12;	// Long retry threshoold
-	    UINT32       NonAggRtyMode:1;	// Non-Aggregate MPDU retry mode.  0:expired by retry limit, 1: expired by mpdu life timer
-	    UINT32       AggRtyMode:1;	// Aggregate MPDU retry mode.  0:expired by retry limit, 1: expired by mpdu life timer
-	    UINT32       TxautoFBEnable:1;    // Tx retry PHY rate auto fallback enable
-	    UINT32       rsv:1;     // 1: HT non-STBC control frame enable
-	}	field;
-	UINT32			word;
-}	TX_RTY_CFG_STRUC, *PTX_RTY_CFG_STRUC;
+typedef union PACKED _TX_RTY_CFG_STRUC {
+	struct {
+		UINT32 ShortRtyLimit:8;	//  short retry limit
+		UINT32 LongRtyLimit:8;	//long retry limit
+		UINT32 LongRtyThre:12;	// Long retry threshoold
+		UINT32 NonAggRtyMode:1;	// Non-Aggregate MPDU retry mode.  0:expired by retry limit, 1: expired by mpdu life timer
+		UINT32 AggRtyMode:1;	// Aggregate MPDU retry mode.  0:expired by retry limit, 1: expired by mpdu life timer
+		UINT32 TxautoFBEnable:1;	// Tx retry PHY rate auto fallback enable
+		UINT32 rsv:1;	// 1: HT non-STBC control frame enable
+	} field;
+	UINT32 word;
+} TX_RTY_CFG_STRUC, *PTX_RTY_CFG_STRUC;
 #define TX_LINK_CFG	0x1350
-typedef	union	PACKED _TX_LINK_CFG_STRUC	{
+typedef union PACKED _TX_LINK_CFG_STRUC {
 	struct PACKED {
-	    UINT32       RemoteMFBLifeTime:8;	//remote MFB life time. unit : 32us
-	    UINT32       MFBEnable:1;	//  TX apply remote MFB 1:enable
-	    UINT32       RemoteUMFSEnable:1;	//  remote unsolicit  MFB enable.  0: not apply remote remote unsolicit (MFS=7)
-	    UINT32       TxMRQEn:1;	//  MCS request TX enable
-	    UINT32       TxRDGEn:1;	// RDG TX enable
-	    UINT32       TxCFAckEn:1;	//   Piggyback CF-ACK enable
-	    UINT32       rsv:3;	//
-	    UINT32       RemotMFB:8;    //  remote MCS feedback
-	    UINT32       RemotMFS:8;	//remote MCS feedback sequence number
-	}	field;
-	UINT32			word;
-}	TX_LINK_CFG_STRUC, *PTX_LINK_CFG_STRUC;
+		UINT32 RemoteMFBLifeTime:8;	//remote MFB life time. unit : 32us
+		UINT32 MFBEnable:1;	//  TX apply remote MFB 1:enable
+		UINT32 RemoteUMFSEnable:1;	//  remote unsolicit  MFB enable.  0: not apply remote remote unsolicit (MFS=7)
+		UINT32 TxMRQEn:1;	//  MCS request TX enable
+		UINT32 TxRDGEn:1;	// RDG TX enable
+		UINT32 TxCFAckEn:1;	//   Piggyback CF-ACK enable
+		UINT32 rsv:3;	//
+		UINT32 RemotMFB:8;	//  remote MCS feedback
+		UINT32 RemotMFS:8;	//remote MCS feedback sequence number
+	} field;
+	UINT32 word;
+} TX_LINK_CFG_STRUC, *PTX_LINK_CFG_STRUC;
 #define HT_FBK_CFG0	0x1354
-typedef	union PACKED _HT_FBK_CFG0_STRUC	{
-	struct	{
-	    UINT32       HTMCS0FBK:4;
-	    UINT32       HTMCS1FBK:4;
-	    UINT32       HTMCS2FBK:4;
-	    UINT32       HTMCS3FBK:4;
-	    UINT32       HTMCS4FBK:4;
-	    UINT32       HTMCS5FBK:4;
-	    UINT32       HTMCS6FBK:4;
-	    UINT32       HTMCS7FBK:4;
-	}	field;
-	UINT32			word;
-}	HT_FBK_CFG0_STRUC, *PHT_FBK_CFG0_STRUC;
+typedef union PACKED _HT_FBK_CFG0_STRUC {
+	struct {
+		UINT32 HTMCS0FBK:4;
+		UINT32 HTMCS1FBK:4;
+		UINT32 HTMCS2FBK:4;
+		UINT32 HTMCS3FBK:4;
+		UINT32 HTMCS4FBK:4;
+		UINT32 HTMCS5FBK:4;
+		UINT32 HTMCS6FBK:4;
+		UINT32 HTMCS7FBK:4;
+	} field;
+	UINT32 word;
+} HT_FBK_CFG0_STRUC, *PHT_FBK_CFG0_STRUC;
 #define HT_FBK_CFG1	0x1358
-typedef	union	_HT_FBK_CFG1_STRUC	{
-	struct	{
-	    UINT32       HTMCS8FBK:4;
-	    UINT32       HTMCS9FBK:4;
-	    UINT32       HTMCS10FBK:4;
-	    UINT32       HTMCS11FBK:4;
-	    UINT32       HTMCS12FBK:4;
-	    UINT32       HTMCS13FBK:4;
-	    UINT32       HTMCS14FBK:4;
-	    UINT32       HTMCS15FBK:4;
-	}	field;
-	UINT32			word;
-}	HT_FBK_CFG1_STRUC, *PHT_FBK_CFG1_STRUC;
+typedef union _HT_FBK_CFG1_STRUC {
+	struct {
+		UINT32 HTMCS8FBK:4;
+		UINT32 HTMCS9FBK:4;
+		UINT32 HTMCS10FBK:4;
+		UINT32 HTMCS11FBK:4;
+		UINT32 HTMCS12FBK:4;
+		UINT32 HTMCS13FBK:4;
+		UINT32 HTMCS14FBK:4;
+		UINT32 HTMCS15FBK:4;
+	} field;
+	UINT32 word;
+} HT_FBK_CFG1_STRUC, *PHT_FBK_CFG1_STRUC;
 #define LG_FBK_CFG0	0x135c
-typedef	union	_LG_FBK_CFG0_STRUC	{
-	struct	{
-	    UINT32       OFDMMCS0FBK:4;	//initial value is 0
-	    UINT32       OFDMMCS1FBK:4;	//initial value is 0
-	    UINT32       OFDMMCS2FBK:4;	//initial value is 1
-	    UINT32       OFDMMCS3FBK:4;	//initial value is 2
-	    UINT32       OFDMMCS4FBK:4;	//initial value is 3
-	    UINT32       OFDMMCS5FBK:4;	//initial value is 4
-	    UINT32       OFDMMCS6FBK:4;	//initial value is 5
-	    UINT32       OFDMMCS7FBK:4;	//initial value is 6
-	}	field;
-	UINT32			word;
-}	LG_FBK_CFG0_STRUC, *PLG_FBK_CFG0_STRUC;
+typedef union _LG_FBK_CFG0_STRUC {
+	struct {
+		UINT32 OFDMMCS0FBK:4;	//initial value is 0
+		UINT32 OFDMMCS1FBK:4;	//initial value is 0
+		UINT32 OFDMMCS2FBK:4;	//initial value is 1
+		UINT32 OFDMMCS3FBK:4;	//initial value is 2
+		UINT32 OFDMMCS4FBK:4;	//initial value is 3
+		UINT32 OFDMMCS5FBK:4;	//initial value is 4
+		UINT32 OFDMMCS6FBK:4;	//initial value is 5
+		UINT32 OFDMMCS7FBK:4;	//initial value is 6
+	} field;
+	UINT32 word;
+} LG_FBK_CFG0_STRUC, *PLG_FBK_CFG0_STRUC;
 #define LG_FBK_CFG1		0x1360
-typedef	union	_LG_FBK_CFG1_STRUC	{
-	struct	{
-	    UINT32       CCKMCS0FBK:4;	//initial value is 0
-	    UINT32       CCKMCS1FBK:4;	//initial value is 0
-	    UINT32       CCKMCS2FBK:4;	//initial value is 1
-	    UINT32       CCKMCS3FBK:4;	//initial value is 2
-	    UINT32       rsv:16;
-	}	field;
-	UINT32			word;
-}	LG_FBK_CFG1_STRUC, *PLG_FBK_CFG1_STRUC;
-
+typedef union _LG_FBK_CFG1_STRUC {
+	struct {
+		UINT32 CCKMCS0FBK:4;	//initial value is 0
+		UINT32 CCKMCS1FBK:4;	//initial value is 0
+		UINT32 CCKMCS2FBK:4;	//initial value is 1
+		UINT32 CCKMCS3FBK:4;	//initial value is 2
+		UINT32 rsv:16;
+	} field;
+	UINT32 word;
+} LG_FBK_CFG1_STRUC, *PLG_FBK_CFG1_STRUC;
 
 //=======================================================
 //================ Protection Paramater================================
 //=======================================================
-#define CCK_PROT_CFG	0x1364		//CCK Protection
+#define CCK_PROT_CFG	0x1364	//CCK Protection
 #define ASIC_SHORTNAV		1
 #define ASIC_LONGNAV		2
 #define ASIC_RTS		1
 #define ASIC_CTS		2
-typedef	union	_PROT_CFG_STRUC	{
-	struct	{
-	    UINT32       ProtectRate:16;	//Protection control frame rate for CCK TX(RTS/CTS/CFEnd).
-	    UINT32       ProtectCtrl:2;	//Protection control frame type for CCK TX. 1:RTS/CTS, 2:CTS-to-self, 0:None, 3:rsv
-	    UINT32       ProtectNav:2;	//TXOP protection type for CCK TX. 0:None, 1:ShortNAVprotect,  2:LongNAVProtect, 3:rsv
-	    UINT32       TxopAllowCck:1;	//CCK TXOP allowance.0:disallow.
-	    UINT32       TxopAllowOfdm:1;	//CCK TXOP allowance.0:disallow.
-	    UINT32       TxopAllowMM20:1;	//CCK TXOP allowance. 0:disallow.
-	    UINT32       TxopAllowMM40:1;	//CCK TXOP allowance.0:disallow.
-	    UINT32       TxopAllowGF20:1;	//CCK TXOP allowance.0:disallow.
-	    UINT32       TxopAllowGF40:1;	//CCK TXOP allowance.0:disallow.
-	    UINT32       RTSThEn:1;	//RTS threshold enable on CCK TX
-	    UINT32       rsv:5;
-	}	field;
-	UINT32			word;
-}	PROT_CFG_STRUC, *PPROT_CFG_STRUC;
-
-#define OFDM_PROT_CFG	0x1368		//OFDM Protection
-#define MM20_PROT_CFG	0x136C		//MM20 Protection
-#define MM40_PROT_CFG	0x1370		//MM40 Protection
-#define GF20_PROT_CFG	0x1374		//GF20 Protection
-#define GF40_PROT_CFG	0x1378		//GR40 Protection
-#define EXP_CTS_TIME	0x137C		//
-#define EXP_ACK_TIME	0x1380		//
+typedef union _PROT_CFG_STRUC {
+	struct {
+		UINT32 ProtectRate:16;	//Protection control frame rate for CCK TX(RTS/CTS/CFEnd).
+		UINT32 ProtectCtrl:2;	//Protection control frame type for CCK TX. 1:RTS/CTS, 2:CTS-to-self, 0:None, 3:rsv
+		UINT32 ProtectNav:2;	//TXOP protection type for CCK TX. 0:None, 1:ShortNAVprotect,  2:LongNAVProtect, 3:rsv
+		UINT32 TxopAllowCck:1;	//CCK TXOP allowance.0:disallow.
+		UINT32 TxopAllowOfdm:1;	//CCK TXOP allowance.0:disallow.
+		UINT32 TxopAllowMM20:1;	//CCK TXOP allowance. 0:disallow.
+		UINT32 TxopAllowMM40:1;	//CCK TXOP allowance.0:disallow.
+		UINT32 TxopAllowGF20:1;	//CCK TXOP allowance.0:disallow.
+		UINT32 TxopAllowGF40:1;	//CCK TXOP allowance.0:disallow.
+		UINT32 RTSThEn:1;	//RTS threshold enable on CCK TX
+		UINT32 rsv:5;
+	} field;
+	UINT32 word;
+} PROT_CFG_STRUC, *PPROT_CFG_STRUC;
+
+#define OFDM_PROT_CFG	0x1368	//OFDM Protection
+#define MM20_PROT_CFG	0x136C	//MM20 Protection
+#define MM40_PROT_CFG	0x1370	//MM40 Protection
+#define GF20_PROT_CFG	0x1374	//GF20 Protection
+#define GF40_PROT_CFG	0x1378	//GR40 Protection
+#define EXP_CTS_TIME	0x137C	//
+#define EXP_ACK_TIME	0x1380	//
 
 //
 //  4.4 MAC RX configuration registers (offset:0x1400)
 //
-#define RX_FILTR_CFG	0x1400			//TXRX_CSR0
-#define AUTO_RSP_CFG	0x1404			//TXRX_CSR4
+#define RX_FILTR_CFG	0x1400	//TXRX_CSR0
+#define AUTO_RSP_CFG	0x1404	//TXRX_CSR4
 //
 // TXRX_CSR4: Auto-Responder/
 //
 typedef union _AUTO_RSP_CFG_STRUC {
- struct {
-     UINT32       AutoResponderEnable:1;
-     UINT32       BACAckPolicyEnable:1;    // 0:long, 1:short preamble
-     UINT32       CTS40MMode:1;  // Response CTS 40MHz duplicate mode
-     UINT32       CTS40MRef:1;  // Response CTS 40MHz duplicate mode
-     UINT32       AutoResponderPreamble:1;    // 0:long, 1:short preamble
-     UINT32       rsv:1;   // Power bit value in conrtrol frame
-     UINT32       DualCTSEn:1;   // Power bit value in conrtrol frame
-     UINT32       AckCtsPsmBit:1;   // Power bit value in conrtrol frame
-     UINT32        :24;
- } field;
- UINT32   word;
+	struct {
+		UINT32 AutoResponderEnable:1;
+		UINT32 BACAckPolicyEnable:1;	// 0:long, 1:short preamble
+		UINT32 CTS40MMode:1;	// Response CTS 40MHz duplicate mode
+		UINT32 CTS40MRef:1;	// Response CTS 40MHz duplicate mode
+		UINT32 AutoResponderPreamble:1;	// 0:long, 1:short preamble
+		UINT32 rsv:1;	// Power bit value in conrtrol frame
+		UINT32 DualCTSEn:1;	// Power bit value in conrtrol frame
+		UINT32 AckCtsPsmBit:1;	// Power bit value in conrtrol frame
+		 UINT32:24;
+	} field;
+	UINT32 word;
 } AUTO_RSP_CFG_STRUC, *PAUTO_RSP_CFG_STRUC;
 
 #define LEGACY_BASIC_RATE	0x1408	//  TXRX_CSR5           0x3054
@@ -777,9 +765,9 @@ typedef union _AUTO_RSP_CFG_STRUC {
 //
 //  4.5 MAC Security configuration (offset:0x1500)
 //
-#define TX_SEC_CNT0		0x1500		//
-#define RX_SEC_CNT0		0x1504		//
-#define CCMP_FC_MUTE		0x1508		//
+#define TX_SEC_CNT0		0x1500	//
+#define RX_SEC_CNT0		0x1504	//
+#define CCMP_FC_MUTE		0x1508	//
 //
 //  4.6 HCCA/PSMP (offset:0x1600)
 //
@@ -792,179 +780,179 @@ typedef union _AUTO_RSP_CFG_STRUC {
 //
 //  4.7 MAC Statistis registers (offset:0x1700)
 //
-#define RX_STA_CNT0		0x1700		//
-#define RX_STA_CNT1		0x1704		//
-#define RX_STA_CNT2		0x1708		//
+#define RX_STA_CNT0		0x1700	//
+#define RX_STA_CNT1		0x1704	//
+#define RX_STA_CNT2		0x1708	//
 
 //
 // RX_STA_CNT0_STRUC: RX PLCP error count & RX CRC error count
 //
-typedef	union	_RX_STA_CNT0_STRUC	{
-	struct	{
-	    USHORT  CrcErr;
-	    USHORT  PhyErr;
-	}	field;
-	UINT32			word;
-}	RX_STA_CNT0_STRUC, *PRX_STA_CNT0_STRUC;
+typedef union _RX_STA_CNT0_STRUC {
+	struct {
+		USHORT CrcErr;
+		USHORT PhyErr;
+	} field;
+	UINT32 word;
+} RX_STA_CNT0_STRUC, *PRX_STA_CNT0_STRUC;
 
 //
 // RX_STA_CNT1_STRUC: RX False CCA count & RX LONG frame count
 //
-typedef	union	_RX_STA_CNT1_STRUC	{
-	struct	{
-	    USHORT  FalseCca;
-	    USHORT  PlcpErr;
-	}	field;
-	UINT32			word;
-}	RX_STA_CNT1_STRUC, *PRX_STA_CNT1_STRUC;
+typedef union _RX_STA_CNT1_STRUC {
+	struct {
+		USHORT FalseCca;
+		USHORT PlcpErr;
+	} field;
+	UINT32 word;
+} RX_STA_CNT1_STRUC, *PRX_STA_CNT1_STRUC;
 
 //
 // RX_STA_CNT2_STRUC:
 //
-typedef	union	_RX_STA_CNT2_STRUC	{
-	struct	{
-	    USHORT  RxDupliCount;
-	    USHORT  RxFifoOverflowCount;
-	}	field;
-	UINT32			word;
-}	RX_STA_CNT2_STRUC, *PRX_STA_CNT2_STRUC;
-#define TX_STA_CNT0		0x170C		//
+typedef union _RX_STA_CNT2_STRUC {
+	struct {
+		USHORT RxDupliCount;
+		USHORT RxFifoOverflowCount;
+	} field;
+	UINT32 word;
+} RX_STA_CNT2_STRUC, *PRX_STA_CNT2_STRUC;
+#define TX_STA_CNT0		0x170C	//
 //
 // STA_CSR3: TX Beacon count
 //
-typedef	union	_TX_STA_CNT0_STRUC	{
-	struct	{
-	    USHORT  TxFailCount;
-	    USHORT  TxBeaconCount;
-	}	field;
-	UINT32			word;
-}	TX_STA_CNT0_STRUC, *PTX_STA_CNT0_STRUC;
-#define TX_STA_CNT1		0x1710		//
+typedef union _TX_STA_CNT0_STRUC {
+	struct {
+		USHORT TxFailCount;
+		USHORT TxBeaconCount;
+	} field;
+	UINT32 word;
+} TX_STA_CNT0_STRUC, *PTX_STA_CNT0_STRUC;
+#define TX_STA_CNT1		0x1710	//
 //
 // TX_STA_CNT1: TX tx count
 //
-typedef	union	_TX_STA_CNT1_STRUC	{
-	struct	{
-	    USHORT  TxSuccess;
-	    USHORT  TxRetransmit;
-	}	field;
-	UINT32			word;
-}	TX_STA_CNT1_STRUC, *PTX_STA_CNT1_STRUC;
-#define TX_STA_CNT2		0x1714		//
+typedef union _TX_STA_CNT1_STRUC {
+	struct {
+		USHORT TxSuccess;
+		USHORT TxRetransmit;
+	} field;
+	UINT32 word;
+} TX_STA_CNT1_STRUC, *PTX_STA_CNT1_STRUC;
+#define TX_STA_CNT2		0x1714	//
 //
 // TX_STA_CNT2: TX tx count
 //
-typedef	union	_TX_STA_CNT2_STRUC	{
-	struct	{
-	    USHORT  TxZeroLenCount;
-	    USHORT  TxUnderFlowCount;
-	}	field;
-	UINT32			word;
-}	TX_STA_CNT2_STRUC, *PTX_STA_CNT2_STRUC;
-#define TX_STA_FIFO		0x1718		//
+typedef union _TX_STA_CNT2_STRUC {
+	struct {
+		USHORT TxZeroLenCount;
+		USHORT TxUnderFlowCount;
+	} field;
+	UINT32 word;
+} TX_STA_CNT2_STRUC, *PTX_STA_CNT2_STRUC;
+#define TX_STA_FIFO		0x1718	//
 //
 // TX_STA_FIFO_STRUC: TX Result for specific PID status fifo register
 //
-typedef	union PACKED _TX_STA_FIFO_STRUC	{
-	struct	{
-		UINT32		bValid:1;   // 1:This register contains a valid TX result
-		UINT32		PidType:4;
-		UINT32		TxSuccess:1;   // Tx No retry success
-		UINT32		TxAggre:1;    // Tx Retry Success
-		UINT32		TxAckRequired:1;    // Tx fail
-		UINT32		wcid:8;		//wireless client index
-//		UINT32		SuccessRate:16;	//include MCS, mode ,shortGI, BW settingSame format as TXWI Word 0 Bit 31-16.
-		UINT32		SuccessRate:13;	//include MCS, mode ,shortGI, BW settingSame format as TXWI Word 0 Bit 31-16.
-		UINT32		TxBF:1;
-		UINT32		Reserve:2;
-	}	field;
-	UINT32			word;
-}	TX_STA_FIFO_STRUC, *PTX_STA_FIFO_STRUC;
+typedef union PACKED _TX_STA_FIFO_STRUC {
+	struct {
+		UINT32 bValid:1;	// 1:This register contains a valid TX result
+		UINT32 PidType:4;
+		UINT32 TxSuccess:1;	// Tx No retry success
+		UINT32 TxAggre:1;	// Tx Retry Success
+		UINT32 TxAckRequired:1;	// Tx fail
+		UINT32 wcid:8;	//wireless client index
+//              UINT32          SuccessRate:16; //include MCS, mode ,shortGI, BW settingSame format as TXWI Word 0 Bit 31-16.
+		UINT32 SuccessRate:13;	//include MCS, mode ,shortGI, BW settingSame format as TXWI Word 0 Bit 31-16.
+		UINT32 TxBF:1;
+		UINT32 Reserve:2;
+	} field;
+	UINT32 word;
+} TX_STA_FIFO_STRUC, *PTX_STA_FIFO_STRUC;
 // Debug counter
 #define TX_AGG_CNT	0x171c
-typedef	union	_TX_AGG_CNT_STRUC	{
-	struct	{
-	    USHORT  NonAggTxCount;
-	    USHORT  AggTxCount;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT_STRUC, *PTX_AGG_CNT_STRUC;
+typedef union _TX_AGG_CNT_STRUC {
+	struct {
+		USHORT NonAggTxCount;
+		USHORT AggTxCount;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT_STRUC, *PTX_AGG_CNT_STRUC;
 // Debug counter
 #define TX_AGG_CNT0	0x1720
-typedef	union	_TX_AGG_CNT0_STRUC	{
-	struct	{
-	    USHORT  AggSize1Count;
-	    USHORT  AggSize2Count;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT0_STRUC, *PTX_AGG_CNT0_STRUC;
+typedef union _TX_AGG_CNT0_STRUC {
+	struct {
+		USHORT AggSize1Count;
+		USHORT AggSize2Count;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT0_STRUC, *PTX_AGG_CNT0_STRUC;
 // Debug counter
 #define TX_AGG_CNT1	0x1724
-typedef	union	_TX_AGG_CNT1_STRUC	{
-	struct	{
-	    USHORT  AggSize3Count;
-	    USHORT  AggSize4Count;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT1_STRUC, *PTX_AGG_CNT1_STRUC;
+typedef union _TX_AGG_CNT1_STRUC {
+	struct {
+		USHORT AggSize3Count;
+		USHORT AggSize4Count;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT1_STRUC, *PTX_AGG_CNT1_STRUC;
 #define TX_AGG_CNT2	0x1728
-typedef	union	_TX_AGG_CNT2_STRUC	{
-	struct	{
-	    USHORT  AggSize5Count;
-	    USHORT  AggSize6Count;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT2_STRUC, *PTX_AGG_CNT2_STRUC;
+typedef union _TX_AGG_CNT2_STRUC {
+	struct {
+		USHORT AggSize5Count;
+		USHORT AggSize6Count;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT2_STRUC, *PTX_AGG_CNT2_STRUC;
 // Debug counter
 #define TX_AGG_CNT3	0x172c
-typedef	union	_TX_AGG_CNT3_STRUC	{
-	struct	{
-	    USHORT  AggSize7Count;
-	    USHORT  AggSize8Count;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT3_STRUC, *PTX_AGG_CNT3_STRUC;
+typedef union _TX_AGG_CNT3_STRUC {
+	struct {
+		USHORT AggSize7Count;
+		USHORT AggSize8Count;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT3_STRUC, *PTX_AGG_CNT3_STRUC;
 // Debug counter
 #define TX_AGG_CNT4	0x1730
-typedef	union	_TX_AGG_CNT4_STRUC	{
-	struct	{
-	    USHORT  AggSize9Count;
-	    USHORT  AggSize10Count;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT4_STRUC, *PTX_AGG_CNT4_STRUC;
+typedef union _TX_AGG_CNT4_STRUC {
+	struct {
+		USHORT AggSize9Count;
+		USHORT AggSize10Count;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT4_STRUC, *PTX_AGG_CNT4_STRUC;
 #define TX_AGG_CNT5	0x1734
-typedef	union	_TX_AGG_CNT5_STRUC	{
-	struct	{
-	    USHORT  AggSize11Count;
-	    USHORT  AggSize12Count;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT5_STRUC, *PTX_AGG_CNT5_STRUC;
+typedef union _TX_AGG_CNT5_STRUC {
+	struct {
+		USHORT AggSize11Count;
+		USHORT AggSize12Count;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT5_STRUC, *PTX_AGG_CNT5_STRUC;
 #define TX_AGG_CNT6		0x1738
-typedef	union	_TX_AGG_CNT6_STRUC	{
-	struct	{
-	    USHORT  AggSize13Count;
-	    USHORT  AggSize14Count;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT6_STRUC, *PTX_AGG_CNT6_STRUC;
+typedef union _TX_AGG_CNT6_STRUC {
+	struct {
+		USHORT AggSize13Count;
+		USHORT AggSize14Count;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT6_STRUC, *PTX_AGG_CNT6_STRUC;
 #define TX_AGG_CNT7		0x173c
-typedef	union	_TX_AGG_CNT7_STRUC	{
-	struct	{
-	    USHORT  AggSize15Count;
-	    USHORT  AggSize16Count;
-	}	field;
-	UINT32			word;
-}	TX_AGG_CNT7_STRUC, *PTX_AGG_CNT7_STRUC;
+typedef union _TX_AGG_CNT7_STRUC {
+	struct {
+		USHORT AggSize15Count;
+		USHORT AggSize16Count;
+	} field;
+	UINT32 word;
+} TX_AGG_CNT7_STRUC, *PTX_AGG_CNT7_STRUC;
 #define MPDU_DENSITY_CNT		0x1740
-typedef	union	_MPDU_DEN_CNT_STRUC	{
-	struct	{
-	    USHORT  TXZeroDelCount;	//TX zero length delimiter count
-	    USHORT  RXZeroDelCount;	//RX zero length delimiter count
-	}	field;
-	UINT32			word;
-}	MPDU_DEN_CNT_STRUC, *PMPDU_DEN_CNT_STRUC;
+typedef union _MPDU_DEN_CNT_STRUC {
+	struct {
+		USHORT TXZeroDelCount;	//TX zero length delimiter count
+		USHORT RXZeroDelCount;	//RX zero length delimiter count
+	} field;
+	UINT32 word;
+} MPDU_DEN_CNT_STRUC, *PMPDU_DEN_CNT_STRUC;
 //
 // TXRX control registers - base address 0x3000
 //
@@ -974,80 +962,77 @@ typedef	union	_MPDU_DEN_CNT_STRUC	{
 //
 // Security key table memory, base address = 0x1000
 //
-#define MAC_WCID_BASE		0x1800 //8-bytes(use only 6-bytes) * 256 entry =
+#define MAC_WCID_BASE		0x1800	//8-bytes(use only 6-bytes) * 256 entry =
 #define HW_WCID_ENTRY_SIZE   8
-#define PAIRWISE_KEY_TABLE_BASE     0x4000      // 32-byte * 256-entry =  -byte
+#define PAIRWISE_KEY_TABLE_BASE     0x4000	// 32-byte * 256-entry =  -byte
 #define HW_KEY_ENTRY_SIZE           0x20
-#define PAIRWISE_IVEIV_TABLE_BASE     0x6000      // 8-byte * 256-entry =  -byte
-#define MAC_IVEIV_TABLE_BASE     0x6000      // 8-byte * 256-entry =  -byte
+#define PAIRWISE_IVEIV_TABLE_BASE     0x6000	// 8-byte * 256-entry =  -byte
+#define MAC_IVEIV_TABLE_BASE     0x6000	// 8-byte * 256-entry =  -byte
 #define HW_IVEIV_ENTRY_SIZE   8
-#define MAC_WCID_ATTRIBUTE_BASE     0x6800      // 4-byte * 256-entry =  -byte
+#define MAC_WCID_ATTRIBUTE_BASE     0x6800	// 4-byte * 256-entry =  -byte
 #define HW_WCID_ATTRI_SIZE   4
 #define WCID_RESERVED			0x6bfc
-#define SHARED_KEY_TABLE_BASE       0x6c00      // 32-byte * 16-entry = 512-byte
-#define SHARED_KEY_MODE_BASE       0x7000      // 32-byte * 16-entry = 512-byte
+#define SHARED_KEY_TABLE_BASE       0x6c00	// 32-byte * 16-entry = 512-byte
+#define SHARED_KEY_MODE_BASE       0x7000	// 32-byte * 16-entry = 512-byte
 #define HW_SHARED_KEY_MODE_SIZE   4
 #define SHAREDKEYTABLE			0
 #define PAIRWISEKEYTABLE			1
 
-
-typedef	union	_SHAREDKEY_MODE_STRUC	{
-	struct	{
-		UINT32       Bss0Key0CipherAlg:3;
-		UINT32       :1;
-		UINT32       Bss0Key1CipherAlg:3;
-		UINT32       :1;
-		UINT32       Bss0Key2CipherAlg:3;
-		UINT32       :1;
-		UINT32       Bss0Key3CipherAlg:3;
-		UINT32       :1;
-		UINT32       Bss1Key0CipherAlg:3;
-		UINT32       :1;
-		UINT32       Bss1Key1CipherAlg:3;
-		UINT32       :1;
-		UINT32       Bss1Key2CipherAlg:3;
-		UINT32       :1;
-		UINT32       Bss1Key3CipherAlg:3;
-		UINT32       :1;
-	}	field;
-	UINT32			word;
-}	SHAREDKEY_MODE_STRUC, *PSHAREDKEY_MODE_STRUC;
+typedef union _SHAREDKEY_MODE_STRUC {
+	struct {
+		UINT32 Bss0Key0CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss0Key1CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss0Key2CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss0Key3CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss1Key0CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss1Key1CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss1Key2CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss1Key3CipherAlg:3;
+		 UINT32:1;
+	} field;
+	UINT32 word;
+} SHAREDKEY_MODE_STRUC, *PSHAREDKEY_MODE_STRUC;
 // 64-entry for pairwise key table
-typedef struct _HW_WCID_ENTRY {  // 8-byte per entry
-    UCHAR   Address[6];
-    UCHAR   Rsv[2];
+typedef struct _HW_WCID_ENTRY {	// 8-byte per entry
+	UCHAR Address[6];
+	UCHAR Rsv[2];
 } HW_WCID_ENTRY, PHW_WCID_ENTRY;
 
-
 // =================================================================================
 // WCID  format
 // =================================================================================
-//7.1	WCID  ENTRY  format  : 8bytes
-typedef	struct	_WCID_ENTRY_STRUC {
-	UCHAR		RXBABitmap7;    // bit0 for TID8, bit7 for TID 15
-	UCHAR		RXBABitmap0;    // bit0 for TID0, bit7 for TID 7
-	UCHAR		MAC[6];	// 0 for shared key table.  1 for pairwise key table
-}	WCID_ENTRY_STRUC, *PWCID_ENTRY_STRUC;
+//7.1   WCID  ENTRY  format  : 8bytes
+typedef struct _WCID_ENTRY_STRUC {
+	UCHAR RXBABitmap7;	// bit0 for TID8, bit7 for TID 15
+	UCHAR RXBABitmap0;	// bit0 for TID0, bit7 for TID 7
+	UCHAR MAC[6];		// 0 for shared key table.  1 for pairwise key table
+} WCID_ENTRY_STRUC, *PWCID_ENTRY_STRUC;
 
-//8.1.1	SECURITY  KEY  format  : 8DW
+//8.1.1 SECURITY  KEY  format  : 8DW
 // 32-byte per entry, total 16-entry for shared key table, 64-entry for pairwise key table
-typedef struct _HW_KEY_ENTRY {          // 32-byte per entry
-    UCHAR   Key[16];
-    UCHAR   TxMic[8];
-    UCHAR   RxMic[8];
+typedef struct _HW_KEY_ENTRY {	// 32-byte per entry
+	UCHAR Key[16];
+	UCHAR TxMic[8];
+	UCHAR RxMic[8];
 } HW_KEY_ENTRY, *PHW_KEY_ENTRY;
 
-//8.1.2	IV/EIV  format  : 2DW
-
-//8.1.3	RX attribute entry format  : 1DW
-typedef	struct	_MAC_ATTRIBUTE_STRUC {
-	UINT32		KeyTab:1;	// 0 for shared key table.  1 for pairwise key table
-	UINT32		PairKeyMode:3;
-	UINT32		BSSIDIdx:3; //multipleBSS index for the WCID
-	UINT32		RXWIUDF:3;
-	UINT32		rsv:22;
-}	MAC_ATTRIBUTE_STRUC, *PMAC_ATTRIBUTE_STRUC;
+//8.1.2 IV/EIV  format  : 2DW
 
+//8.1.3 RX attribute entry format  : 1DW
+typedef struct _MAC_ATTRIBUTE_STRUC {
+	UINT32 KeyTab:1;	// 0 for shared key table.  1 for pairwise key table
+	UINT32 PairKeyMode:3;
+	UINT32 BSSIDIdx:3;	//multipleBSS index for the WCID
+	UINT32 RXWIUDF:3;
+	UINT32 rsv:22;
+} MAC_ATTRIBUTE_STRUC, *PMAC_ATTRIBUTE_STRUC;
 
 // =================================================================================
 // HOST-MCU communication data structure
@@ -1056,192 +1041,181 @@ typedef	struct	_MAC_ATTRIBUTE_STRUC {
 //
 // H2M_MAILBOX_CSR: Host-to-MCU Mailbox
 //
-typedef union  _H2M_MAILBOX_STRUC {
-    struct {
-        UINT32       LowByte:8;
-        UINT32       HighByte:8;
-        UINT32       CmdToken:8;
-        UINT32       Owner:8;
-    }   field;
-    UINT32           word;
+typedef union _H2M_MAILBOX_STRUC {
+	struct {
+		UINT32 LowByte:8;
+		UINT32 HighByte:8;
+		UINT32 CmdToken:8;
+		UINT32 Owner:8;
+	} field;
+	UINT32 word;
 } H2M_MAILBOX_STRUC, *PH2M_MAILBOX_STRUC;
 
 //
 // M2H_CMD_DONE_CSR: MCU-to-Host command complete indication
 //
 typedef union _M2H_CMD_DONE_STRUC {
-    struct  {
-        UINT32       CmdToken0;
-        UINT32       CmdToken1;
-        UINT32       CmdToken2;
-        UINT32       CmdToken3;
-    } field;
-    UINT32           word;
+	struct {
+		UINT32 CmdToken0;
+		UINT32 CmdToken1;
+		UINT32 CmdToken2;
+		UINT32 CmdToken3;
+	} field;
+	UINT32 word;
 } M2H_CMD_DONE_STRUC, *PM2H_CMD_DONE_STRUC;
 
-
 //NAV_TIME_CFG :NAV
-typedef	union	_NAV_TIME_CFG_STRUC	{
-	struct	{
-		UCHAR		Sifs;               // in unit of 1-us
-		UCHAR       SlotTime;    // in unit of 1-us
-		USHORT		Eifs:9;               // in unit of 1-us
-		USHORT		ZeroSifs:1;               // Applied zero SIFS timer after OFDM RX 0: disable
-		USHORT		rsv:6;
-	}	field;
-	UINT32			word;
-}	NAV_TIME_CFG_STRUC, *PNAV_TIME_CFG_STRUC;
-
+typedef union _NAV_TIME_CFG_STRUC {
+	struct {
+		UCHAR Sifs;	// in unit of 1-us
+		UCHAR SlotTime;	// in unit of 1-us
+		USHORT Eifs:9;	// in unit of 1-us
+		USHORT ZeroSifs:1;	// Applied zero SIFS timer after OFDM RX 0: disable
+		USHORT rsv:6;
+	} field;
+	UINT32 word;
+} NAV_TIME_CFG_STRUC, *PNAV_TIME_CFG_STRUC;
 
 //
 // RX_FILTR_CFG:  /RX configuration register
 //
-typedef	union	_RX_FILTR_CFG_STRUC	{
-	struct	{
-		UINT32		DropCRCErr:1;		// Drop CRC error
-		UINT32		DropPhyErr:1;		// Drop physical error
-		UINT32		DropNotToMe:1;		// Drop not to me unicast frame
-		UINT32		DropNotMyBSSID:1;			// Drop fram ToDs bit is true
-
-		UINT32		DropVerErr:1;	    // Drop version error frame
-		UINT32		DropMcast:1;		// Drop multicast frames
-		UINT32		DropBcast:1;		// Drop broadcast frames
-		UINT32		DropDuplicate:1;		// Drop duplicate frame
-
-		UINT32		DropCFEndAck:1;		// Drop Ps-Poll
-		UINT32		DropCFEnd:1;		// Drop Ps-Poll
-		UINT32		DropAck:1;		// Drop Ps-Poll
-		UINT32		DropCts:1;		// Drop Ps-Poll
-
-		UINT32		DropRts:1;		// Drop Ps-Poll
-		UINT32		DropPsPoll:1;		// Drop Ps-Poll
-		UINT32		DropBA:1;		//
-		UINT32		DropBAR:1;       //
-
-		UINT32		DropRsvCntlType:1;
-		UINT32		:15;
-	}	field;
-	UINT32			word;
-}	RX_FILTR_CFG_STRUC, *PRX_FILTR_CFG_STRUC;
-
-
-
+typedef union _RX_FILTR_CFG_STRUC {
+	struct {
+		UINT32 DropCRCErr:1;	// Drop CRC error
+		UINT32 DropPhyErr:1;	// Drop physical error
+		UINT32 DropNotToMe:1;	// Drop not to me unicast frame
+		UINT32 DropNotMyBSSID:1;	// Drop fram ToDs bit is true
+
+		UINT32 DropVerErr:1;	// Drop version error frame
+		UINT32 DropMcast:1;	// Drop multicast frames
+		UINT32 DropBcast:1;	// Drop broadcast frames
+		UINT32 DropDuplicate:1;	// Drop duplicate frame
+
+		UINT32 DropCFEndAck:1;	// Drop Ps-Poll
+		UINT32 DropCFEnd:1;	// Drop Ps-Poll
+		UINT32 DropAck:1;	// Drop Ps-Poll
+		UINT32 DropCts:1;	// Drop Ps-Poll
+
+		UINT32 DropRts:1;	// Drop Ps-Poll
+		UINT32 DropPsPoll:1;	// Drop Ps-Poll
+		UINT32 DropBA:1;	//
+		UINT32 DropBAR:1;	//
+
+		UINT32 DropRsvCntlType:1;
+		 UINT32:15;
+	} field;
+	UINT32 word;
+} RX_FILTR_CFG_STRUC, *PRX_FILTR_CFG_STRUC;
 
 //
 // PHY_CSR4: RF serial control register
 //
-typedef	union	_PHY_CSR4_STRUC	{
-	struct	{
-		UINT32		RFRegValue:24;		// Register	value (include register	id)	serial out to RF/IF	chip.
-		UINT32		NumberOfBits:5;		// Number of bits used in RFRegValue (I:20,	RFMD:22)
-		UINT32		IFSelect:1;			// 1: select IF	to program,	0: select RF to	program
-		UINT32		PLL_LD:1;			// RF PLL_LD status
-		UINT32		Busy:1;				// 1: ASIC is busy execute RF programming.
-	}	field;
-	UINT32			word;
-}	PHY_CSR4_STRUC, *PPHY_CSR4_STRUC;
-
+typedef union _PHY_CSR4_STRUC {
+	struct {
+		UINT32 RFRegValue:24;	// Register     value (include register id)     serial out to RF/IF     chip.
+		UINT32 NumberOfBits:5;	// Number of bits used in RFRegValue (I:20,     RFMD:22)
+		UINT32 IFSelect:1;	// 1: select IF to program,     0: select RF to program
+		UINT32 PLL_LD:1;	// RF PLL_LD status
+		UINT32 Busy:1;	// 1: ASIC is busy execute RF programming.
+	} field;
+	UINT32 word;
+} PHY_CSR4_STRUC, *PPHY_CSR4_STRUC;
 
 //
 // SEC_CSR5: shared key table security mode register
 //
-typedef	union	_SEC_CSR5_STRUC	{
-	struct	{
-        UINT32       Bss2Key0CipherAlg:3;
-        UINT32       :1;
-        UINT32       Bss2Key1CipherAlg:3;
-        UINT32       :1;
-        UINT32       Bss2Key2CipherAlg:3;
-        UINT32       :1;
-        UINT32       Bss2Key3CipherAlg:3;
-        UINT32       :1;
-        UINT32       Bss3Key0CipherAlg:3;
-        UINT32       :1;
-        UINT32       Bss3Key1CipherAlg:3;
-        UINT32       :1;
-        UINT32       Bss3Key2CipherAlg:3;
-        UINT32       :1;
-        UINT32       Bss3Key3CipherAlg:3;
-        UINT32       :1;
-	}	field;
-	UINT32			word;
-}	SEC_CSR5_STRUC, *PSEC_CSR5_STRUC;
-
+typedef union _SEC_CSR5_STRUC {
+	struct {
+		UINT32 Bss2Key0CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss2Key1CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss2Key2CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss2Key3CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss3Key0CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss3Key1CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss3Key2CipherAlg:3;
+		 UINT32:1;
+		UINT32 Bss3Key3CipherAlg:3;
+		 UINT32:1;
+	} field;
+	UINT32 word;
+} SEC_CSR5_STRUC, *PSEC_CSR5_STRUC;
 
 //
 // HOST_CMD_CSR: For HOST to interrupt embedded processor
 //
-typedef	union	_HOST_CMD_CSR_STRUC	{
-	struct	{
-	    UINT32   HostCommand:8;
-	    UINT32   Rsv:24;
-	}	field;
-	UINT32			word;
-}	HOST_CMD_CSR_STRUC, *PHOST_CMD_CSR_STRUC;
-
+typedef union _HOST_CMD_CSR_STRUC {
+	struct {
+		UINT32 HostCommand:8;
+		UINT32 Rsv:24;
+	} field;
+	UINT32 word;
+} HOST_CMD_CSR_STRUC, *PHOST_CMD_CSR_STRUC;
 
 //
 // AIFSN_CSR: AIFSN for each EDCA AC
 //
 
-
-
 //
 // E2PROM_CSR: EEPROM control register
 //
-typedef	union	_E2PROM_CSR_STRUC	{
-	struct	{
-		UINT32		Reload:1;		// Reload EEPROM content, write one to reload, self-cleared.
-		UINT32		EepromSK:1;
-		UINT32		EepromCS:1;
-		UINT32		EepromDI:1;
-		UINT32		EepromDO:1;
-		UINT32		Type:1;			// 1: 93C46, 0:93C66
-		UINT32       LoadStatus:1;   // 1:loading, 0:done
-		UINT32		Rsvd:25;
-	}	field;
-	UINT32			word;
-}	E2PROM_CSR_STRUC, *PE2PROM_CSR_STRUC;
+typedef union _E2PROM_CSR_STRUC {
+	struct {
+		UINT32 Reload:1;	// Reload EEPROM content, write one to reload, self-cleared.
+		UINT32 EepromSK:1;
+		UINT32 EepromCS:1;
+		UINT32 EepromDI:1;
+		UINT32 EepromDO:1;
+		UINT32 Type:1;	// 1: 93C46, 0:93C66
+		UINT32 LoadStatus:1;	// 1:loading, 0:done
+		UINT32 Rsvd:25;
+	} field;
+	UINT32 word;
+} E2PROM_CSR_STRUC, *PE2PROM_CSR_STRUC;
 
 //
 // QOS_CSR0: TXOP holder address0 register
 //
-typedef	union	_QOS_CSR0_STRUC	{
-	struct	{
-		UCHAR		Byte0;		// MAC address byte 0
-		UCHAR		Byte1;		// MAC address byte 1
-		UCHAR		Byte2;		// MAC address byte 2
-		UCHAR		Byte3;		// MAC address byte 3
-	}	field;
-	UINT32			word;
-}	QOS_CSR0_STRUC, *PQOS_CSR0_STRUC;
+typedef union _QOS_CSR0_STRUC {
+	struct {
+		UCHAR Byte0;	// MAC address byte 0
+		UCHAR Byte1;	// MAC address byte 1
+		UCHAR Byte2;	// MAC address byte 2
+		UCHAR Byte3;	// MAC address byte 3
+	} field;
+	UINT32 word;
+} QOS_CSR0_STRUC, *PQOS_CSR0_STRUC;
 
 //
 // QOS_CSR1: TXOP holder address1 register
 //
-typedef	union	_QOS_CSR1_STRUC	{
-	struct	{
-		UCHAR		Byte4;		// MAC address byte 4
-		UCHAR		Byte5;		// MAC address byte 5
-		UCHAR		Rsvd0;
-		UCHAR		Rsvd1;
-	}	field;
-	UINT32			word;
-}	QOS_CSR1_STRUC, *PQOS_CSR1_STRUC;
+typedef union _QOS_CSR1_STRUC {
+	struct {
+		UCHAR Byte4;	// MAC address byte 4
+		UCHAR Byte5;	// MAC address byte 5
+		UCHAR Rsvd0;
+		UCHAR Rsvd1;
+	} field;
+	UINT32 word;
+} QOS_CSR1_STRUC, *PQOS_CSR1_STRUC;
 
 #define	RF_CSR_CFG	0x500
-typedef	union	_RF_CSR_CFG_STRUC	{
-	struct	{
-		UINT	RF_CSR_DATA:8;			// DATA
-		UINT	TESTCSR_RFACC_REGNUM:5;	// RF register ID
-		UINT	Rsvd2:3;				// Reserved
-		UINT	RF_CSR_WR:1;			// 0: read  1: write
-		UINT	RF_CSR_KICK:1;			// kick RF register read/write
-		UINT	Rsvd1:14;				// Reserved
-	}	field;
-	UINT	word;
-}	RF_CSR_CFG_STRUC, *PRF_CSR_CFG_STRUC;
-
+typedef union _RF_CSR_CFG_STRUC {
+	struct {
+		UINT RF_CSR_DATA:8;	// DATA
+		UINT TESTCSR_RFACC_REGNUM:5;	// RF register ID
+		UINT Rsvd2:3;	// Reserved
+		UINT RF_CSR_WR:1;	// 0: read  1: write
+		UINT RF_CSR_KICK:1;	// kick RF register read/write
+		UINT Rsvd1:14;	// Reserved
+	} field;
+	UINT word;
+} RF_CSR_CFG_STRUC, *PRF_CSR_CFG_STRUC;
 
 //
 // Other on-chip shared memory space, base = 0x2000
@@ -1258,17 +1232,17 @@ typedef	union	_RF_CSR_CFG_STRUC	{
 
 // 2004-11-08 john - since NULL frame won't be that long (256 byte). We steal 16 tail bytes
 // to save debugging settings
-#define HW_DEBUG_SETTING_BASE   0x77f0  // 0x77f0~0x77ff total 16 bytes
-#define HW_DEBUG_SETTING_BASE2   0x7770  // 0x77f0~0x77ff total 16 bytes
+#define HW_DEBUG_SETTING_BASE   0x77f0	// 0x77f0~0x77ff total 16 bytes
+#define HW_DEBUG_SETTING_BASE2   0x7770	// 0x77f0~0x77ff total 16 bytes
 
 // In order to support maximum 8 MBSS and its maximum length is 512 for each beacon
 // Three section discontinue memory segments will be used.
 // 1. The original region for BCN 0~3
 // 2. Extract memory from FCE table for BCN 4~5
 // 3. Extract memory from Pair-wise key table for BCN 6~7
-//	  It occupied those memory of wcid 238~253 for BCN 6
-//						      and wcid 222~237 for BCN 7
-#define HW_BEACON_MAX_SIZE      0x1000 /* unit: byte */
+//        It occupied those memory of wcid 238~253 for BCN 6
+//                                                    and wcid 222~237 for BCN 7
+#define HW_BEACON_MAX_SIZE      0x1000	/* unit: byte */
 #define HW_BEACON_BASE0         0x7800
 #define HW_BEACON_BASE1         0x7A00
 #define HW_BEACON_BASE2         0x7C00
@@ -1290,11 +1264,11 @@ typedef	union	_RF_CSR_CFG_STRUC	{
 #define H2M_INT_SRC             0x7024
 #define H2M_BBP_AGENT           0x7028
 #define M2H_CMD_DONE_CSR        0x000c
-#define MCU_TXOP_ARRAY_BASE     0x000c   // TODO: to be provided by Albert
-#define MCU_TXOP_ENTRY_SIZE     32       // TODO: to be provided by Albert
-#define MAX_NUM_OF_TXOP_ENTRY   16       // TODO: must be same with 8051 firmware
-#define MCU_MBOX_VERSION        0x01     // TODO: to be confirmed by Albert
-#define MCU_MBOX_VERSION_OFFSET 5        // TODO: to be provided by Albert
+#define MCU_TXOP_ARRAY_BASE     0x000c	// TODO: to be provided by Albert
+#define MCU_TXOP_ENTRY_SIZE     32	// TODO: to be provided by Albert
+#define MAX_NUM_OF_TXOP_ENTRY   16	// TODO: must be same with 8051 firmware
+#define MCU_MBOX_VERSION        0x01	// TODO: to be confirmed by Albert
+#define MCU_MBOX_VERSION_OFFSET 5	// TODO: to be provided by Albert
 
 //
 // Host DMA registers - base address 0x200 .  TX0-3=EDCAQid0-3, TX4=HCCA, TX5=MGMT,
@@ -1305,10 +1279,8 @@ typedef	union	_RF_CSR_CFG_STRUC	{
 #define E2PROM_CSR          0x0004
 #define IO_CNTL_CSR         0x77d0
 
-
-
 // ================================================================
-// Tx /	Rx / Mgmt ring descriptor definition
+// Tx / Rx / Mgmt ring descriptor definition
 // ================================================================
 
 // the following PID values are used to mark outgoing frame type in TXD->PID so that
@@ -1321,8 +1293,8 @@ typedef	union	_RF_CSR_CFG_STRUC	{
 #define PID_DATA_NO_ACK		0x08
 #define PID_DATA_NOT_NORM_ACK		0x03
 // value domain of pTxD->HostQId (4-bit: 0~15)
-#define QID_AC_BK               1   // meet ACI definition in 802.11e
-#define QID_AC_BE               0   // meet ACI definition in 802.11e
+#define QID_AC_BK               1	// meet ACI definition in 802.11e
+#define QID_AC_BE               0	// meet ACI definition in 802.11e
 #define QID_AC_VI               2
 #define QID_AC_VO               3
 #define QID_HCCA                4
--- a/drivers/staging/rt2860/chip/rtmp_phy.h
+++ b/drivers/staging/rt2860/chip/rtmp_phy.h
@@ -38,7 +38,6 @@
 #ifndef __RTMP_PHY_H__
 #define __RTMP_PHY_H__
 
-
 /*
 	RF sections
 */
@@ -75,31 +74,30 @@
 #define RF_R30			30
 #define RF_R31			31
 
-
 // value domain of pAd->RfIcType
-#define RFIC_2820                   1       // 2.4G 2T3R
-#define RFIC_2850                   2       // 2.4G/5G 2T3R
-#define RFIC_2720                   3       // 2.4G 1T2R
-#define RFIC_2750                   4       // 2.4G/5G 1T2R
-#define RFIC_3020                   5       // 2.4G 1T1R
-#define RFIC_2020                   6       // 2.4G B/G
-#define RFIC_3021                   7       // 2.4G 1T2R
-#define RFIC_3022                   8       // 2.4G 2T2R
-#define RFIC_3052                   9       // 2.4G/5G 2T2R
+#define RFIC_2820                   1	// 2.4G 2T3R
+#define RFIC_2850                   2	// 2.4G/5G 2T3R
+#define RFIC_2720                   3	// 2.4G 1T2R
+#define RFIC_2750                   4	// 2.4G/5G 1T2R
+#define RFIC_3020                   5	// 2.4G 1T1R
+#define RFIC_2020                   6	// 2.4G B/G
+#define RFIC_3021                   7	// 2.4G 1T2R
+#define RFIC_3022                   8	// 2.4G 2T2R
+#define RFIC_3052                   9	// 2.4G/5G 2T2R
 
 /*
 	BBP sections
 */
-#define BBP_R0			0  // version
-#define BBP_R1			1  // TSSI
-#define BBP_R2			2  // TX configure
+#define BBP_R0			0	// version
+#define BBP_R1			1	// TSSI
+#define BBP_R2			2	// TX configure
 #define BBP_R3			3
 #define BBP_R4			4
 #define BBP_R5			5
 #define BBP_R6			6
-#define BBP_R14			14 // RX configure
+#define BBP_R14			14	// RX configure
 #define BBP_R16			16
-#define BBP_R17			17 // RX sensibility
+#define BBP_R17			17	// RX sensibility
 #define BBP_R18			18
 #define BBP_R21			21
 #define BBP_R22			22
@@ -108,12 +106,12 @@
 #define BBP_R26			26
 #define BBP_R27			27
 #define BBP_R31			31
-#define BBP_R49			49 //TSSI
+#define BBP_R49			49	//TSSI
 #define BBP_R50			50
 #define BBP_R51			51
 #define BBP_R52			52
 #define BBP_R55			55
-#define BBP_R62			62 // Rx SQ0 Threshold HIGH
+#define BBP_R62			62	// Rx SQ0 Threshold HIGH
 #define BBP_R63			63
 #define BBP_R64			64
 #define BBP_R65			65
@@ -121,7 +119,7 @@
 #define BBP_R67			67
 #define BBP_R68			68
 #define BBP_R69			69
-#define BBP_R70			70 // Rx AGC SQ CCK Xcorr threshold
+#define BBP_R70			70	// Rx AGC SQ CCK Xcorr threshold
 #define BBP_R73			73
 #define BBP_R75			75
 #define BBP_R77			77
@@ -135,7 +133,7 @@
 #define BBP_R86			86
 #define BBP_R91			91
 #define BBP_R92			92
-#define BBP_R94			94 // Tx Gain Control
+#define BBP_R94			94	// Tx Gain Control
 #define BBP_R103		103
 #define BBP_R105		105
 #define BBP_R106		106
@@ -151,16 +149,16 @@
 #define BBP_R122		122
 #define BBP_R123		123
 #ifdef RT30xx
-#define BBP_R138		138 // add by johnli, RF power sequence setup, ADC dynamic on/off control
+#define BBP_R138		138	// add by johnli, RF power sequence setup, ADC dynamic on/off control
 #endif // RT30xx //
 
-#define BBPR94_DEFAULT	0x06 // Add 1 value will gain 1db
+#define BBPR94_DEFAULT	0x06	// Add 1 value will gain 1db
 
 //
 // BBP & RF are using indirect access. Before write any value into it.
 // We have to make sure there is no outstanding command pending via checking busy bit.
 //
-#define MAX_BUSY_COUNT  100         // Number of retry before failing access BBP & RF indirect register
+#define MAX_BUSY_COUNT  100	// Number of retry before failing access BBP & RF indirect register
 
 //#define PHY_TR_SWITCH_TIME          5  // usec
 
@@ -416,7 +414,6 @@
 		}														\
 	}while(0)
 
-
 /*
 	This marco used for the BBP write operation which didn't need via MCU.
 */
@@ -539,7 +536,6 @@
 		RTMP_IO_WRITE32(_pAd, 0x1210, _macData);				\
 	}while(0)
 
-
 #define RTMP_ASIC_MMPS_ENABLE(_pAd)							\
 	do{															\
 		UINT32 _macData; \
--- a/drivers/staging/rt2860/chlist.h
+++ b/drivers/staging/rt2860/chlist.h
@@ -41,7 +41,6 @@
 #include "rtmp_type.h"
 #include "rtmp_def.h"
 
-
 #define ODOR			0
 #define IDOR			1
 #define BOTH			2
@@ -53,28 +52,27 @@
 typedef struct _CH_DESP {
 	UCHAR FirstChannel;
 	UCHAR NumOfCh;
-	CHAR MaxTxPwr;			// dBm
-	UCHAR Geography;			// 0:out door, 1:in door, 2:both
-	BOOLEAN DfsReq;			// Dfs require, 0: No, 1: yes.
+	CHAR MaxTxPwr;		// dBm
+	UCHAR Geography;	// 0:out door, 1:in door, 2:both
+	BOOLEAN DfsReq;		// Dfs require, 0: No, 1: yes.
 } CH_DESP, *PCH_DESP;
 
 typedef struct _CH_REGION {
 	UCHAR CountReg[3];
-	UCHAR DfsType;			// 0: CE, 1: FCC, 2: JAP, 3:JAP_W53, JAP_W56
+	UCHAR DfsType;		// 0: CE, 1: FCC, 2: JAP, 3:JAP_W53, JAP_W56
 	CH_DESP ChDesp[10];
 } CH_REGION, *PCH_REGION;
 
 extern CH_REGION ChRegion[];
 
-typedef struct _CH_FREQ_MAP_{
-	UINT16		channel;
-	UINT16		freqKHz;
-}CH_FREQ_MAP;
+typedef struct _CH_FREQ_MAP_ {
+	UINT16 channel;
+	UINT16 freqKHz;
+} CH_FREQ_MAP;
 
 extern CH_FREQ_MAP CH_HZ_ID_MAP[];
 extern int CH_HZ_ID_MAP_NUM;
 
-
 #define     MAP_CHANNEL_ID_TO_KHZ(_ch, _khz)					\
 		do{													\
 			int _chIdx;											\
@@ -105,24 +103,15 @@ extern int CH_HZ_ID_MAP_NUM;
 				(_ch) = 1;											\
 		}while(0)
 
+VOID BuildChannelListEx(IN PRTMP_ADAPTER pAd);
 
-VOID BuildChannelListEx(
-	IN PRTMP_ADAPTER pAd);
+VOID BuildBeaconChList(IN PRTMP_ADAPTER pAd,
+		       OUT PUCHAR pBuf, OUT PULONG pBufLen);
 
-VOID BuildBeaconChList(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pBuf,
-	OUT	PULONG pBufLen);
-
-VOID N_ChannelCheck(
-	IN PRTMP_ADAPTER pAd);
-
-VOID N_SetCenCh(
-	IN PRTMP_ADAPTER pAd);
-
-UINT8 GetCuntryMaxTxPwr(
-	IN PRTMP_ADAPTER pAd,
-	IN UINT8 channel);
+VOID N_ChannelCheck(IN PRTMP_ADAPTER pAd);
 
-#endif // __CHLIST_H__
+VOID N_SetCenCh(IN PRTMP_ADAPTER pAd);
 
+UINT8 GetCuntryMaxTxPwr(IN PRTMP_ADAPTER pAd, IN UINT8 channel);
+
+#endif // __CHLIST_H__
--- a/drivers/staging/rt2860/common/action.h
+++ b/drivers/staging/rt2860/common/action.h
@@ -39,23 +39,18 @@
 #ifndef	__ACTION_H__
 #define	__ACTION_H__
 
-typedef struct PACKED __HT_INFO_OCTET
-{
-	UCHAR	Request:1;
-	UCHAR	Forty_MHz_Intolerant:1;
-	UCHAR 	STA_Channel_Width:1;
-	UCHAR	Reserved:5;
+typedef struct PACKED __HT_INFO_OCTET {
+	UCHAR Request:1;
+	UCHAR Forty_MHz_Intolerant:1;
+	UCHAR STA_Channel_Width:1;
+	UCHAR Reserved:5;
 } HT_INFORMATION_OCTET;
 
-
-typedef struct PACKED __FRAME_HT_INFO
-{
-	HEADER_802_11   		Hdr;
-	UCHAR					Category;
-	UCHAR					Action;
-	HT_INFORMATION_OCTET	HT_Info;
-}   FRAME_HT_INFO, *PFRAME_HT_INFO;
+typedef struct PACKED __FRAME_HT_INFO {
+	HEADER_802_11 Hdr;
+	UCHAR Category;
+	UCHAR Action;
+	HT_INFORMATION_OCTET HT_Info;
+} FRAME_HT_INFO, *PFRAME_HT_INFO;
 
 #endif /* __ACTION_H__ */
-
-
--- a/drivers/staging/rt2860/crypt_hmac.h
+++ b/drivers/staging/rt2860/crypt_hmac.h
@@ -48,24 +48,18 @@
 
 #ifdef SHA1_SUPPORT
 #define HMAC_SHA1_SUPPORT
-VOID HMAC_SHA1 (
-    IN  const UINT8 Key[],
-    IN  UINT KeyLen,
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen,
-    OUT UINT8 MAC[],
-    IN  UINT MACLen);
+VOID HMAC_SHA1(IN const UINT8 Key[],
+	       IN UINT KeyLen,
+	       IN const UINT8 Message[],
+	       IN UINT MessageLen, OUT UINT8 MAC[], IN UINT MACLen);
 #endif /* SHA1_SUPPORT */
 
 #ifdef MD5_SUPPORT
 #define HMAC_MD5_SUPPORT
-VOID HMAC_MD5 (
-    IN  const UINT8 Key[],
-    IN  UINT KeyLen,
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen,
-    OUT UINT8 MAC[],
-    IN  UINT MACLen);
+VOID HMAC_MD5(IN const UINT8 Key[],
+	      IN UINT KeyLen,
+	      IN const UINT8 Message[],
+	      IN UINT MessageLen, OUT UINT8 MAC[], IN UINT MACLen);
 #endif /* MD5_SUPPORT */
 
 #endif /* __CRYPT_HMAC_H__ */
--- a/drivers/staging/rt2860/crypt_md5.h
+++ b/drivers/staging/rt2860/crypt_md5.h
@@ -51,30 +51,22 @@
 #define MD5_SUPPORT
 
 #ifdef MD5_SUPPORT
-#define MD5_BLOCK_SIZE    64 /* 512 bits = 64 bytes */
-#define MD5_DIGEST_SIZE   16 /* 128 bits = 16 bytes */
+#define MD5_BLOCK_SIZE    64	/* 512 bits = 64 bytes */
+#define MD5_DIGEST_SIZE   16	/* 128 bits = 16 bytes */
 typedef struct {
-    UINT32 HashValue[4];
-    UINT64 MessageLen;
-    UINT8  Block[MD5_BLOCK_SIZE];
-    UINT   BlockLen;
+	UINT32 HashValue[4];
+	UINT64 MessageLen;
+	UINT8 Block[MD5_BLOCK_SIZE];
+	UINT BlockLen;
 } MD5_CTX_STRUC, *PMD5_CTX_STRUC;
 
-VOID MD5_Init (
-    IN  MD5_CTX_STRUC *pMD5_CTX);
-VOID MD5_Hash (
-    IN  MD5_CTX_STRUC *pMD5_CTX);
-VOID MD5_Append (
-    IN  MD5_CTX_STRUC *pMD5_CTX,
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen);
-VOID MD5_End (
-    IN  MD5_CTX_STRUC *pMD5_CTX,
-    OUT UINT8 DigestMessage[]);
-VOID RT_MD5 (
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen,
-    OUT UINT8 DigestMessage[]);
+VOID MD5_Init(IN MD5_CTX_STRUC * pMD5_CTX);
+VOID MD5_Hash(IN MD5_CTX_STRUC * pMD5_CTX);
+VOID MD5_Append(IN MD5_CTX_STRUC * pMD5_CTX,
+		IN const UINT8 Message[], IN UINT MessageLen);
+VOID MD5_End(IN MD5_CTX_STRUC * pMD5_CTX, OUT UINT8 DigestMessage[]);
+VOID RT_MD5(IN const UINT8 Message[],
+	    IN UINT MessageLen, OUT UINT8 DigestMessage[]);
 #endif /* MD5_SUPPORT */
 
 #endif /* __CRYPT_MD5_H__ */
--- a/drivers/staging/rt2860/crypt_sha2.h
+++ b/drivers/staging/rt2860/crypt_sha2.h
@@ -52,30 +52,22 @@
 #define SHA1_SUPPORT
 
 #ifdef SHA1_SUPPORT
-#define SHA1_BLOCK_SIZE    64 /* 512 bits = 64 bytes */
-#define SHA1_DIGEST_SIZE   20 /* 160 bits = 20 bytes */
+#define SHA1_BLOCK_SIZE    64	/* 512 bits = 64 bytes */
+#define SHA1_DIGEST_SIZE   20	/* 160 bits = 20 bytes */
 typedef struct _SHA1_CTX_STRUC {
-    UINT32 HashValue[5];  /* 5 = (SHA1_DIGEST_SIZE / 32) */
-    UINT64 MessageLen;    /* total size */
-    UINT8  Block[SHA1_BLOCK_SIZE];
-    UINT   BlockLen;
+	UINT32 HashValue[5];	/* 5 = (SHA1_DIGEST_SIZE / 32) */
+	UINT64 MessageLen;	/* total size */
+	UINT8 Block[SHA1_BLOCK_SIZE];
+	UINT BlockLen;
 } SHA1_CTX_STRUC, *PSHA1_CTX_STRUC;
 
-VOID RT_SHA1_Init (
-    IN  SHA1_CTX_STRUC *pSHA_CTX);
-VOID SHA1_Hash (
-    IN  SHA1_CTX_STRUC *pSHA_CTX);
-VOID SHA1_Append (
-    IN  SHA1_CTX_STRUC *pSHA_CTX,
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen);
-VOID SHA1_End (
-    IN  SHA1_CTX_STRUC *pSHA_CTX,
-    OUT UINT8 DigestMessage[]);
-VOID RT_SHA1 (
-    IN  const UINT8 Message[],
-    IN  UINT MessageLen,
-    OUT UINT8 DigestMessage[]);
+VOID RT_SHA1_Init(IN SHA1_CTX_STRUC * pSHA_CTX);
+VOID SHA1_Hash(IN SHA1_CTX_STRUC * pSHA_CTX);
+VOID SHA1_Append(IN SHA1_CTX_STRUC * pSHA_CTX,
+		 IN const UINT8 Message[], IN UINT MessageLen);
+VOID SHA1_End(IN SHA1_CTX_STRUC * pSHA_CTX, OUT UINT8 DigestMessage[]);
+VOID RT_SHA1(IN const UINT8 Message[],
+	     IN UINT MessageLen, OUT UINT8 DigestMessage[]);
 #endif /* SHA1_SUPPORT */
 
 #endif /* __CRYPT_SHA2_H__ */
--- a/drivers/staging/rt2860/dfs.h
+++ b/drivers/staging/rt2860/dfs.h
@@ -36,6 +36,4 @@
     Fonchi    03-12-2007      created
 */
 
-BOOLEAN RadarChannelCheck(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			Ch);
+BOOLEAN RadarChannelCheck(IN PRTMP_ADAPTER pAd, IN UCHAR Ch);
--- a/drivers/staging/rt2860/eeprom.h
+++ b/drivers/staging/rt2860/eeprom.h
@@ -24,7 +24,6 @@
  *                                                                       *
  *************************************************************************
 
-
 	Module Name:
 	eeprom.h
 
@@ -38,41 +37,31 @@
 #ifndef __EEPROM_H__
 #define __EEPROM_H__
 
-
-
 #ifdef RTMP_PCI_SUPPORT
 /*************************************************************************
   *	Public function declarations for prom-based chipset
   ************************************************************************/
-int rtmp_ee_prom_read16(
-	IN PRTMP_ADAPTER	pAd,
-	IN USHORT			Offset,
-	OUT USHORT			*pValue);
+int rtmp_ee_prom_read16(IN PRTMP_ADAPTER pAd,
+			IN USHORT Offset, OUT USHORT * pValue);
 #endif // RTMP_PCI_SUPPORT //
 #ifdef RTMP_USB_SUPPORT
 /*************************************************************************
   *	Public function declarations for usb-based prom chipset
   ************************************************************************/
-NTSTATUS RTUSBReadEEPROM16(
-	IN PRTMP_ADAPTER	pAd,
-	IN	USHORT			offset,
-	OUT	PUSHORT			pData);
+NTSTATUS RTUSBReadEEPROM16(IN PRTMP_ADAPTER pAd,
+			   IN USHORT offset, OUT PUSHORT pData);
 #endif // RTMP_USB_SUPPORT //
 
 #ifdef RT30xx
 #ifdef RTMP_EFUSE_SUPPORT
-int rtmp_ee_efuse_read16(
-	IN RTMP_ADAPTER *pAd,
-	IN USHORT Offset,
-	OUT USHORT *pValue);
+int rtmp_ee_efuse_read16(IN RTMP_ADAPTER * pAd,
+			 IN USHORT Offset, OUT USHORT * pValue);
 #endif // RTMP_EFUSE_SUPPORT //
 #endif // RT30xx //
 
 /*************************************************************************
   *	Public function declarations for prom operation callback functions setting
   ************************************************************************/
-INT RtmpChipOpsEepromHook(
-	IN RTMP_ADAPTER *pAd,
-	IN INT			infType);
+INT RtmpChipOpsEepromHook(IN RTMP_ADAPTER * pAd, IN INT infType);
 
 #endif // __EEPROM_H__ //
--- a/drivers/staging/rt2860/iface/rtmp_pci.h
+++ b/drivers/staging/rt2860/iface/rtmp_pci.h
@@ -31,7 +31,6 @@
 #define RT28XX_HANDLE_DEV_ASSIGN(handle, dev_p)				\
 	((POS_COOKIE)handle)->pci_dev = dev_p;
 
-
 #ifdef LINUX
 // set driver data
 #define RT28XX_DRVDATA_SET(_a)			pci_set_drvdata(_a, net_dev);
@@ -64,7 +63,6 @@
 							pci_resource_len(dev_p, 0)); }	\
 	if (net_dev->irq) pci_release_regions(dev_p); }
 
-
 #define PCI_REG_READ_WORD(pci_dev, offset, Configuration)   \
     if (pci_read_config_word(pci_dev, offset, &reg16) == 0)     \
         Configuration = le2cpu16(reg16);                        \
@@ -77,5 +75,4 @@
 
 #endif // LINUX //
 
-
 #endif // __RTMP_PCI_H__ //
--- a/drivers/staging/rt2860/iface/rtmp_usb.h
+++ b/drivers/staging/rt2860/iface/rtmp_usb.h
@@ -28,28 +28,24 @@
 #ifndef __RTMP_USB_H__
 #define __RTMP_USB_H__
 
-
 #include "../rtusb_io.h"
 
-
 #ifdef LINUX
 #include <linux/usb.h>
 
-typedef struct usb_device	* PUSB_DEV;
+typedef struct usb_device *PUSB_DEV;
 typedef struct urb *purbb_t;
 typedef struct usb_ctrlrequest devctrlrequest;
 #endif // LINUX //
 
 extern UCHAR EpToQueue[6];
 
-
 #define RXBULKAGGRE_ZISE			12
 #define MAX_TXBULK_LIMIT			(LOCAL_TXBUF_SIZE*(BULKAGGRE_ZISE-1))
 #define MAX_TXBULK_SIZE			(LOCAL_TXBUF_SIZE*BULKAGGRE_ZISE)
 #define MAX_RXBULK_SIZE			(LOCAL_TXBUF_SIZE*RXBULKAGGRE_ZISE)
 #define MAX_MLME_HANDLER_MEMORY 20
 
-
 // Flags for Bulkflags control for bulk out data
 //
 #define	fRTUSB_BULK_OUT_DATA_NULL				0x00000001
@@ -69,7 +65,6 @@ extern UCHAR EpToQueue[6];
 
 // TODO:move to ./ate/include/iface/ate_usb.h
 
-
 #define FREE_HTTX_RING(_pCookie, _pipeId, _txContext)			\
 {										\
 	if ((_txContext)->ENextBulkOutPosition == (_txContext)->CurWritePosition)	\
@@ -79,8 +74,6 @@ extern UCHAR EpToQueue[6];
 	/*NdisInterlockedDecrement(&(_p)->TxCount); */\
 }
 
-
-
 /******************************************************************************
 
 	USB Bulk operation related definitions
@@ -100,7 +93,7 @@ extern UCHAR EpToQueue[6];
 // unlink urb
 #define RTUSB_UNLINK_URB(pUrb)		usb_kill_urb(pUrb)
 
-extern void dump_urb(struct urb* purb);
+extern void dump_urb(struct urb *purb);
 
 #define InterlockedIncrement		atomic_inc
 #define NdisInterlockedIncrement	atomic_inc
@@ -110,12 +103,8 @@ extern void dump_urb(struct urb* purb);
 
 #endif // LINUX //
 
-
-
 #define NT_SUCCESS(status)			(((status) >=0) ? (TRUE):(FALSE))
 
-
-
 #define USBD_TRANSFER_DIRECTION_OUT		0
 #define USBD_TRANSFER_DIRECTION_IN		0
 #define USBD_SHORT_TRANSFER_OK			0
@@ -131,7 +120,6 @@ extern void dump_urb(struct urb* purb);
 #define CONTROL_TIMEOUT_JIFFIES ( (100 * OS_HZ) / 1000)
 #define UNLINK_TIMEOUT_MS		3
 
-
 VOID RTUSBBulkOutDataPacketComplete(purbb_t purb, struct pt_regs *pt_regs);
 VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb, struct pt_regs *pt_regs);
 VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb, struct pt_regs *pt_regs);
@@ -139,7 +127,6 @@ VOID RTUSBBulkOutRTSFrameComplete(purbb_
 VOID RTUSBBulkOutPsPollComplete(purbb_t pUrb, struct pt_regs *pt_regs);
 VOID RTUSBBulkRxComplete(purbb_t pUrb, struct pt_regs *pt_regs);
 
-
 #ifdef KTHREAD_SUPPORT
 #define RTUSBMlmeUp(pAd) \
 	do{								    \
@@ -196,5 +183,4 @@ VOID RTUSBBulkRxComplete(purbb_t pUrb, s
 #define RTMP_IRQ_REQUEST(net_dev)		do{}while(0)
 #define RTMP_IRQ_RELEASE(net_dev)		do{}while(0)
 
-
 #endif // __RTMP_USB_H__ //
--- a/drivers/staging/rt2860/mlme.h
+++ b/drivers/staging/rt2860/mlme.h
@@ -41,18 +41,16 @@
 
 #include "rtmp_dot11.h"
 
-
-
 // maximum supported capability information -
 // ESS, IBSS, Privacy, Short Preamble, Spectrum mgmt, Short Slot
 #define SUPPORTED_CAPABILITY_INFO   0x0533
 
 #define END_OF_ARGS                 -1
 #define LFSR_MASK                   0x80000057
-#define MLME_TASK_EXEC_INTV         100/*200*/       //
+#define MLME_TASK_EXEC_INTV         100/*200*/	//
 #define LEAD_TIME                   5
-#define MLME_TASK_EXEC_MULTIPLE       10  /*5*/       // MLME_TASK_EXEC_MULTIPLE * MLME_TASK_EXEC_INTV = 1 sec
-#define REORDER_EXEC_INTV         	100       // 0.1 sec
+#define MLME_TASK_EXEC_MULTIPLE       10  /*5*/	// MLME_TASK_EXEC_MULTIPLE * MLME_TASK_EXEC_INTV = 1 sec
+#define REORDER_EXEC_INTV         	100	// 0.1 sec
 
 // The definition of Radar detection duration region
 #define CE		0
@@ -62,34 +60,32 @@
 #define JAP_W56	4
 #define MAX_RD_REGION 5
 
-#define BEACON_LOST_TIME            4 * OS_HZ    // 2048 msec = 2 sec
-
-#define DLS_TIMEOUT                 1200      // unit: msec
-#define AUTH_TIMEOUT                300       // unit: msec
-#define ASSOC_TIMEOUT               300       // unit: msec
-#define JOIN_TIMEOUT                2000        // unit: msec
-#define SHORT_CHANNEL_TIME          90        // unit: msec
-#define MIN_CHANNEL_TIME            110        // unit: msec, for dual band scan
-#define MAX_CHANNEL_TIME            140       // unit: msec, for single band scan
-#define	FAST_ACTIVE_SCAN_TIME	    30 		  // Active scan waiting for probe response time
-#define CW_MIN_IN_BITS              4         // actual CwMin = 2^CW_MIN_IN_BITS - 1
-#define LINK_DOWN_TIMEOUT           20000      // unit: msec
-#define AUTO_WAKEUP_TIMEOUT			70			//unit: msec
+#define BEACON_LOST_TIME            4 * OS_HZ	// 2048 msec = 2 sec
 
+#define DLS_TIMEOUT                 1200	// unit: msec
+#define AUTH_TIMEOUT                300	// unit: msec
+#define ASSOC_TIMEOUT               300	// unit: msec
+#define JOIN_TIMEOUT                2000	// unit: msec
+#define SHORT_CHANNEL_TIME          90	// unit: msec
+#define MIN_CHANNEL_TIME            110	// unit: msec, for dual band scan
+#define MAX_CHANNEL_TIME            140	// unit: msec, for single band scan
+#define	FAST_ACTIVE_SCAN_TIME	    30	// Active scan waiting for probe response time
+#define CW_MIN_IN_BITS              4	// actual CwMin = 2^CW_MIN_IN_BITS - 1
+#define LINK_DOWN_TIMEOUT           20000	// unit: msec
+#define AUTO_WAKEUP_TIMEOUT			70	//unit: msec
 
-#define CW_MAX_IN_BITS              10        // actual CwMax = 2^CW_MAX_IN_BITS - 1
-
+#define CW_MAX_IN_BITS              10	// actual CwMax = 2^CW_MAX_IN_BITS - 1
 
 // Note: RSSI_TO_DBM_OFFSET has been changed to variable for new RF (2004-0720).
 // SHould not refer to this constant anymore
 //#define RSSI_TO_DBM_OFFSET          120 // for RT2530 RSSI-115 = dBm
-#define RSSI_FOR_MID_TX_POWER       -55  // -55 db is considered mid-distance
-#define RSSI_FOR_LOW_TX_POWER       -45  // -45 db is considered very short distance and
-                                        // eligible to use a lower TX power
+#define RSSI_FOR_MID_TX_POWER       -55	// -55 db is considered mid-distance
+#define RSSI_FOR_LOW_TX_POWER       -45	// -45 db is considered very short distance and
+					// eligible to use a lower TX power
 #define RSSI_FOR_LOWEST_TX_POWER    -30
 //#define MID_TX_POWER_DELTA          0   // 0 db from full TX power upon mid-distance to AP
-#define LOW_TX_POWER_DELTA          6    // -3 db from full TX power upon very short distance. 1 grade is 0.5 db
-#define LOWEST_TX_POWER_DELTA       16   // -8 db from full TX power upon shortest distance. 1 grade is 0.5 db
+#define LOW_TX_POWER_DELTA          6	// -3 db from full TX power upon very short distance. 1 grade is 0.5 db
+#define LOWEST_TX_POWER_DELTA       16	// -8 db from full TX power upon shortest distance. 1 grade is 0.5 db
 
 #define RSSI_TRIGGERED_UPON_BELOW_THRESHOLD     0
 #define RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD   1
@@ -99,7 +95,7 @@
 // Channel Quality Indication
 #define CQI_IS_GOOD(cqi)            ((cqi) >= 50)
 //#define CQI_IS_FAIR(cqi)          (((cqi) >= 20) && ((cqi) < 50))
-#define CQI_IS_POOR(cqi)            (cqi < 50)  //(((cqi) >= 5) && ((cqi) < 20))
+#define CQI_IS_POOR(cqi)            (cqi < 50)	//(((cqi) >= 5) && ((cqi) < 20))
 #define CQI_IS_BAD(cqi)             (cqi < 5)
 #define CQI_IS_DEAD(cqi)            (cqi == 0)
 
@@ -110,15 +106,15 @@
 
 #define BSS_NOT_FOUND                    0xFFFFFFFF
 
-#define MAX_LEN_OF_MLME_QUEUE            40 //10
+#define MAX_LEN_OF_MLME_QUEUE            40	//10
 
-#define SCAN_PASSIVE                     18		// scan with no probe request, only wait beacon and probe response
-#define SCAN_ACTIVE                      19		// scan with probe request, and wait beacon and probe response
-#define	SCAN_CISCO_PASSIVE				 20		// Single channel passive scan
-#define	SCAN_CISCO_ACTIVE				 21		// Single channel active scan
-#define	SCAN_CISCO_NOISE				 22		// Single channel passive scan for noise histogram collection
-#define	SCAN_CISCO_CHANNEL_LOAD			 23		// Single channel passive scan for channel load collection
-#define FAST_SCAN_ACTIVE                 24		// scan with probe request, and wait beacon and probe response
+#define SCAN_PASSIVE                     18	// scan with no probe request, only wait beacon and probe response
+#define SCAN_ACTIVE                      19	// scan with probe request, and wait beacon and probe response
+#define	SCAN_CISCO_PASSIVE				 20	// Single channel passive scan
+#define	SCAN_CISCO_ACTIVE				 21	// Single channel active scan
+#define	SCAN_CISCO_NOISE				 22	// Single channel passive scan for noise histogram collection
+#define	SCAN_CISCO_CHANNEL_LOAD			 23	// Single channel passive scan for channel load collection
+#define FAST_SCAN_ACTIVE                 24	// scan with probe request, and wait beacon and probe response
 
 #define MAC_ADDR_IS_GROUP(Addr)       (((Addr[0]) & 0x01))
 #define MAC_ADDR_HASH(Addr)            (Addr[0] ^ Addr[1] ^ Addr[2] ^ Addr[3] ^ Addr[4] ^ Addr[5])
@@ -141,21 +137,21 @@
 #define CAP_IS_SHORT_PREAMBLE_ON(x)      (((x) & 0x0020) != 0)
 #define CAP_IS_PBCC_ON(x)                (((x) & 0x0040) != 0)
 #define CAP_IS_AGILITY_ON(x)             (((x) & 0x0080) != 0)
-#define CAP_IS_SPECTRUM_MGMT(x)          (((x) & 0x0100) != 0)  // 802.11e d9
-#define CAP_IS_QOS(x)                    (((x) & 0x0200) != 0)  // 802.11e d9
+#define CAP_IS_SPECTRUM_MGMT(x)          (((x) & 0x0100) != 0)	// 802.11e d9
+#define CAP_IS_QOS(x)                    (((x) & 0x0200) != 0)	// 802.11e d9
 #define CAP_IS_SHORT_SLOT(x)             (((x) & 0x0400) != 0)
-#define CAP_IS_APSD(x)                   (((x) & 0x0800) != 0)  // 802.11e d9
-#define CAP_IS_IMMED_BA(x)               (((x) & 0x1000) != 0)  // 802.11e d9
+#define CAP_IS_APSD(x)                   (((x) & 0x0800) != 0)	// 802.11e d9
+#define CAP_IS_IMMED_BA(x)               (((x) & 0x1000) != 0)	// 802.11e d9
 #define CAP_IS_DSSS_OFDM(x)              (((x) & 0x2000) != 0)
-#define CAP_IS_DELAY_BA(x)               (((x) & 0x4000) != 0)  // 802.11e d9
+#define CAP_IS_DELAY_BA(x)               (((x) & 0x4000) != 0)	// 802.11e d9
 
 #define CAP_GENERATE(ess,ibss,priv,s_pre,s_slot,spectrum)  (((ess) ? 0x0001 : 0x0000) | ((ibss) ? 0x0002 : 0x0000) | ((priv) ? 0x0010 : 0x0000) | ((s_pre) ? 0x0020 : 0x0000) | ((s_slot) ? 0x0400 : 0x0000) | ((spectrum) ? 0x0100 : 0x0000))
 
-#define ERP_IS_NON_ERP_PRESENT(x)        (((x) & 0x01) != 0)    // 802.11g
-#define ERP_IS_USE_PROTECTION(x)         (((x) & 0x02) != 0)    // 802.11g
-#define ERP_IS_USE_BARKER_PREAMBLE(x)    (((x) & 0x04) != 0)    // 802.11g
+#define ERP_IS_NON_ERP_PRESENT(x)        (((x) & 0x01) != 0)	// 802.11g
+#define ERP_IS_USE_PROTECTION(x)         (((x) & 0x02) != 0)	// 802.11g
+#define ERP_IS_USE_BARKER_PREAMBLE(x)    (((x) & 0x04) != 0)	// 802.11g
 
-#define DRS_TX_QUALITY_WORST_BOUND       8// 3  // just test by gary
+#define DRS_TX_QUALITY_WORST_BOUND       8	// 3  // just test by gary
 #define DRS_PENALTY                      8
 
 #define BA_NOTUSE 	2
@@ -192,500 +188,485 @@ if (((__pEntry)) != NULL) \
 //
 //  HT Capability INFO field in HT Cap IE .
 typedef struct PACKED {
-	USHORT	AdvCoding:1;
-	USHORT	ChannelWidth:1;
-	USHORT	MimoPs:2;//momi power safe
-	USHORT	GF:1;	//green field
-	USHORT	ShortGIfor20:1;
-	USHORT	ShortGIfor40:1;	//for40MHz
-	USHORT	TxSTBC:1;
-	USHORT	RxSTBC:2;
-	USHORT	DelayedBA:1;	//rt2860c not support
-	USHORT	AMsduSize:1;	// only support as zero
-	USHORT	CCKmodein40:1;
-	USHORT	PSMP:1;
-	USHORT	Forty_Mhz_Intolerant:1;
-	USHORT	LSIGTxopProSup:1;
+	USHORT AdvCoding:1;
+	USHORT ChannelWidth:1;
+	USHORT MimoPs:2;	//momi power safe
+	USHORT GF:1;		//green field
+	USHORT ShortGIfor20:1;
+	USHORT ShortGIfor40:1;	//for40MHz
+	USHORT TxSTBC:1;
+	USHORT RxSTBC:2;
+	USHORT DelayedBA:1;	//rt2860c not support
+	USHORT AMsduSize:1;	// only support as zero
+	USHORT CCKmodein40:1;
+	USHORT PSMP:1;
+	USHORT Forty_Mhz_Intolerant:1;
+	USHORT LSIGTxopProSup:1;
 } HT_CAP_INFO, *PHT_CAP_INFO;
 
 //  HT Capability INFO field in HT Cap IE .
 typedef struct PACKED {
-	UCHAR	MaxRAmpduFactor:2;
-	UCHAR	MpduDensity:3;
-	UCHAR	rsv:3;//momi power safe
+	UCHAR MaxRAmpduFactor:2;
+	UCHAR MpduDensity:3;
+	UCHAR rsv:3;		//momi power safe
 } HT_CAP_PARM, *PHT_CAP_PARM;
 
 //  HT Capability INFO field in HT Cap IE .
 typedef struct PACKED {
-	UCHAR	MCSSet[10];
-	UCHAR	SupRate[2];  // unit : 1Mbps
-	UCHAR	TxMCSSetDefined:1;
-	UCHAR	TxRxNotEqual:1;
-	UCHAR	TxStream:2;
-	UCHAR	MpduDensity:1;
-	UCHAR	rsv:3;
-	UCHAR	rsv3[3];
+	UCHAR MCSSet[10];
+	UCHAR SupRate[2];	// unit : 1Mbps
+	UCHAR TxMCSSetDefined:1;
+	UCHAR TxRxNotEqual:1;
+	UCHAR TxStream:2;
+	UCHAR MpduDensity:1;
+	UCHAR rsv:3;
+	UCHAR rsv3[3];
 } HT_MCS_SET, *PHT_MCS_SET;
 
 //  HT Capability INFO field in HT Cap IE .
 typedef struct PACKED {
-	USHORT	Pco:1;
-	USHORT	TranTime:2;
-	USHORT	rsv:5;//momi power safe
-	USHORT	MCSFeedback:2;	//0:no MCS feedback, 2:unsolicited MCS feedback, 3:Full MCS feedback,  1:rsv.
-	USHORT	PlusHTC:1;	//+HTC control field support
-	USHORT	RDGSupport:1;	//reverse Direction Grant  support
-	USHORT	rsv2:4;
+	USHORT Pco:1;
+	USHORT TranTime:2;
+	USHORT rsv:5;		//momi power safe
+	USHORT MCSFeedback:2;	//0:no MCS feedback, 2:unsolicited MCS feedback, 3:Full MCS feedback,  1:rsv.
+	USHORT PlusHTC:1;	//+HTC control field support
+	USHORT RDGSupport:1;	//reverse Direction Grant  support
+	USHORT rsv2:4;
 } EXT_HT_CAP_INFO, *PEXT_HT_CAP_INFO;
 
 //  HT Beamforming field in HT Cap IE .
-typedef struct PACKED _HT_BF_CAP{
-	ULONG	TxBFRecCapable:1;
-	ULONG	RxSoundCapable:1;
-	ULONG	TxSoundCapable:1;
-	ULONG	RxNDPCapable:1;
-	ULONG	TxNDPCapable:1;
-	ULONG	ImpTxBFCapable:1;
-	ULONG	Calibration:2;
-	ULONG	ExpCSICapable:1;
-	ULONG	ExpNoComSteerCapable:1;
-	ULONG	ExpComSteerCapable:1;
-	ULONG	ExpCSIFbk:2;
-	ULONG	ExpNoComBF:2;
-	ULONG	ExpComBF:2;
-	ULONG	MinGrouping:2;
-	ULONG	CSIBFAntSup:2;
-	ULONG	NoComSteerBFAntSup:2;
-	ULONG	ComSteerBFAntSup:2;
-	ULONG	CSIRowBFSup:2;
-	ULONG	ChanEstimation:2;
-	ULONG	rsv:3;
+typedef struct PACKED _HT_BF_CAP {
+	ULONG TxBFRecCapable:1;
+	ULONG RxSoundCapable:1;
+	ULONG TxSoundCapable:1;
+	ULONG RxNDPCapable:1;
+	ULONG TxNDPCapable:1;
+	ULONG ImpTxBFCapable:1;
+	ULONG Calibration:2;
+	ULONG ExpCSICapable:1;
+	ULONG ExpNoComSteerCapable:1;
+	ULONG ExpComSteerCapable:1;
+	ULONG ExpCSIFbk:2;
+	ULONG ExpNoComBF:2;
+	ULONG ExpComBF:2;
+	ULONG MinGrouping:2;
+	ULONG CSIBFAntSup:2;
+	ULONG NoComSteerBFAntSup:2;
+	ULONG ComSteerBFAntSup:2;
+	ULONG CSIRowBFSup:2;
+	ULONG ChanEstimation:2;
+	ULONG rsv:3;
 } HT_BF_CAP, *PHT_BF_CAP;
 
 //  HT antenna selection field in HT Cap IE .
-typedef struct PACKED _HT_AS_CAP{
-	UCHAR	AntSelect:1;
-	UCHAR	ExpCSIFbkTxASEL:1;
-	UCHAR	AntIndFbkTxASEL:1;
-	UCHAR	ExpCSIFbk:1;
-	UCHAR	AntIndFbk:1;
-	UCHAR	RxASel:1;
-	UCHAR	TxSoundPPDU:1;
-	UCHAR	rsv:1;
+typedef struct PACKED _HT_AS_CAP {
+	UCHAR AntSelect:1;
+	UCHAR ExpCSIFbkTxASEL:1;
+	UCHAR AntIndFbkTxASEL:1;
+	UCHAR ExpCSIFbk:1;
+	UCHAR AntIndFbk:1;
+	UCHAR RxASel:1;
+	UCHAR TxSoundPPDU:1;
+	UCHAR rsv:1;
 } HT_AS_CAP, *PHT_AS_CAP;
 
 // Draft 1.0 set IE length 26, but is extensible..
 #define SIZE_HT_CAP_IE		26
 // The structure for HT Capability IE.
-typedef struct PACKED _HT_CAPABILITY_IE{
-	HT_CAP_INFO		HtCapInfo;
-	HT_CAP_PARM		HtCapParm;
-//	HT_MCS_SET		HtMCSSet;
-	UCHAR			MCSSet[16];
-	EXT_HT_CAP_INFO	ExtHtCapInfo;
-	HT_BF_CAP		TxBFCap;	// beamforming cap. rt2860c not support beamforming.
-	HT_AS_CAP		ASCap;	//antenna selection.
+typedef struct PACKED _HT_CAPABILITY_IE {
+	HT_CAP_INFO HtCapInfo;
+	HT_CAP_PARM HtCapParm;
+//      HT_MCS_SET              HtMCSSet;
+	UCHAR MCSSet[16];
+	EXT_HT_CAP_INFO ExtHtCapInfo;
+	HT_BF_CAP TxBFCap;	// beamforming cap. rt2860c not support beamforming.
+	HT_AS_CAP ASCap;	//antenna selection.
 } HT_CAPABILITY_IE, *PHT_CAPABILITY_IE;
 
-
 // 802.11n draft3 related structure definitions.
 // 7.3.2.60
 #define dot11OBSSScanPassiveDwell							20	// in TU. min amount of time that the STA continously scans each channel when performing an active OBSS scan.
 #define dot11OBSSScanActiveDwell							10	// in TU.min amount of time that the STA continously scans each channel when performing an passive OBSS scan.
-#define dot11BSSWidthTriggerScanInterval					300  // in sec. max interval between scan operations to be performed to detect BSS channel width trigger events.
+#define dot11BSSWidthTriggerScanInterval					300	// in sec. max interval between scan operations to be performed to detect BSS channel width trigger events.
 #define dot11OBSSScanPassiveTotalPerChannel					200	// in TU. min total amount of time that the STA scans each channel when performing a passive OBSS scan.
 #define dot11OBSSScanActiveTotalPerChannel					20	//in TU. min total amount of time that the STA scans each channel when performing a active OBSS scan
 #define dot11BSSWidthChannelTransactionDelayFactor			5	// min ratio between the delay time in performing a switch from 20MHz BSS to 20/40 BSS operation and the maximum
-																//	interval between overlapping BSS scan operations.
+																//      interval between overlapping BSS scan operations.
 #define dot11BSSScanActivityThreshold						25	// in %%, max total time that a STA may be active on the medium during a period of
-																//	(dot11BSSWidthChannelTransactionDelayFactor * dot11BSSWidthTriggerScanInterval) seconds without
-																//	being obligated to perform OBSS Scan operations. default is 25(== 0.25%)
-
-typedef struct PACKED _OVERLAP_BSS_SCAN_IE{
-	USHORT		ScanPassiveDwell;
-	USHORT		ScanActiveDwell;
-	USHORT		TriggerScanInt;				// Trigger scan interval
-	USHORT		PassiveTalPerChannel;		// passive total per channel
-	USHORT		ActiveTalPerChannel;		// active total per channel
-	USHORT		DelayFactor;				// BSS width channel transition delay factor
-	USHORT		ScanActThre;				// Scan Activity threshold
-}OVERLAP_BSS_SCAN_IE, *POVERLAP_BSS_SCAN_IE;
+																//      (dot11BSSWidthChannelTransactionDelayFactor * dot11BSSWidthTriggerScanInterval) seconds without
+																//      being obligated to perform OBSS Scan operations. default is 25(== 0.25%)
 
+typedef struct PACKED _OVERLAP_BSS_SCAN_IE {
+	USHORT ScanPassiveDwell;
+	USHORT ScanActiveDwell;
+	USHORT TriggerScanInt;	// Trigger scan interval
+	USHORT PassiveTalPerChannel;	// passive total per channel
+	USHORT ActiveTalPerChannel;	// active total per channel
+	USHORT DelayFactor;	// BSS width channel transition delay factor
+	USHORT ScanActThre;	// Scan Activity threshold
+} OVERLAP_BSS_SCAN_IE, *POVERLAP_BSS_SCAN_IE;
 
 //  7.3.2.56. 20/40 Coexistence element used in  Element ID = 72 = IE_2040_BSS_COEXIST
-typedef union PACKED _BSS_2040_COEXIST_IE{
- struct PACKED {
-	UCHAR	InfoReq:1;
-	UCHAR	Intolerant40:1;			// Inter-BSS. set 1 when prohibits a receiving BSS from operating as a 20/40 Mhz BSS.
-	UCHAR	BSS20WidthReq:1;		// Intra-BSS set 1 when prohibits a receiving AP from operating its BSS as a 20/40MHz BSS.
-	UCHAR	rsv:5;
-    } field;
- UCHAR   word;
+typedef union PACKED _BSS_2040_COEXIST_IE {
+	struct PACKED {
+		UCHAR InfoReq:1;
+		UCHAR Intolerant40:1;	// Inter-BSS. set 1 when prohibits a receiving BSS from operating as a 20/40 Mhz BSS.
+		UCHAR BSS20WidthReq:1;	// Intra-BSS set 1 when prohibits a receiving AP from operating its BSS as a 20/40MHz BSS.
+		UCHAR rsv:5;
+	} field;
+	UCHAR word;
 } BSS_2040_COEXIST_IE, *PBSS_2040_COEXIST_IE;
 
-
-typedef struct  _TRIGGER_EVENTA{
-	BOOLEAN			bValid;
-	UCHAR	BSSID[6];
-	UCHAR	RegClass;	// Regulatory Class
-	USHORT	Channel;
-	ULONG	CDCounter;   // Maintain a seperate count down counter for each Event A.
+typedef struct _TRIGGER_EVENTA {
+	BOOLEAN bValid;
+	UCHAR BSSID[6];
+	UCHAR RegClass;		// Regulatory Class
+	USHORT Channel;
+	ULONG CDCounter;	// Maintain a seperate count down counter for each Event A.
 } TRIGGER_EVENTA, *PTRIGGER_EVENTA;
 
 // 20/40 trigger event table
 // If one Event A delete or created, or if Event B is detected or not detected, STA should send 2040BSSCoexistence to AP.
 #define MAX_TRIGGER_EVENT		64
-typedef struct  _TRIGGER_EVENT_TAB{
-	UCHAR	EventANo;
-	TRIGGER_EVENTA	EventA[MAX_TRIGGER_EVENT];
-	ULONG			EventBCountDown;	// Count down counter for Event B.
+typedef struct _TRIGGER_EVENT_TAB {
+	UCHAR EventANo;
+	TRIGGER_EVENTA EventA[MAX_TRIGGER_EVENT];
+	ULONG EventBCountDown;	// Count down counter for Event B.
 } TRIGGER_EVENT_TAB, *PTRIGGER_EVENT_TAB;
 
 // 7.3.27 20/40 Bss Coexistence Mgmt capability used in extended capabilities information IE( ID = 127 = IE_EXT_CAPABILITY).
-//	This is the first octet and was defined in 802.11n D3.03 and 802.11yD9.0
-typedef struct PACKED _EXT_CAP_INFO_ELEMENT{
-	UCHAR	BssCoexistMgmtSupport:1;
-	UCHAR	rsv:1;
-	UCHAR	ExtendChannelSwitch:1;
-	UCHAR	rsv2:5;
-}EXT_CAP_INFO_ELEMENT, *PEXT_CAP_INFO_ELEMENT;
-
+//      This is the first octet and was defined in 802.11n D3.03 and 802.11yD9.0
+typedef struct PACKED _EXT_CAP_INFO_ELEMENT {
+	UCHAR BssCoexistMgmtSupport:1;
+	UCHAR rsv:1;
+	UCHAR ExtendChannelSwitch:1;
+	UCHAR rsv2:5;
+} EXT_CAP_INFO_ELEMENT, *PEXT_CAP_INFO_ELEMENT;
 
 // 802.11n 7.3.2.61
-typedef struct PACKED _BSS_2040_COEXIST_ELEMENT{
-	UCHAR					ElementID;		// ID = IE_2040_BSS_COEXIST = 72
-	UCHAR					Len;
-	BSS_2040_COEXIST_IE		BssCoexistIe;
-}BSS_2040_COEXIST_ELEMENT, *PBSS_2040_COEXIST_ELEMENT;
-
+typedef struct PACKED _BSS_2040_COEXIST_ELEMENT {
+	UCHAR ElementID;	// ID = IE_2040_BSS_COEXIST = 72
+	UCHAR Len;
+	BSS_2040_COEXIST_IE BssCoexistIe;
+} BSS_2040_COEXIST_ELEMENT, *PBSS_2040_COEXIST_ELEMENT;
 
 //802.11n 7.3.2.59
-typedef struct PACKED _BSS_2040_INTOLERANT_CH_REPORT{
-	UCHAR				ElementID;		// ID = IE_2040_BSS_INTOLERANT_REPORT = 73
-	UCHAR				Len;
-	UCHAR				RegulatoryClass;
-	UCHAR				ChList[0];
-}BSS_2040_INTOLERANT_CH_REPORT, *PBSS_2040_INTOLERANT_CH_REPORT;
-
+typedef struct PACKED _BSS_2040_INTOLERANT_CH_REPORT {
+	UCHAR ElementID;	// ID = IE_2040_BSS_INTOLERANT_REPORT = 73
+	UCHAR Len;
+	UCHAR RegulatoryClass;
+	UCHAR ChList[0];
+} BSS_2040_INTOLERANT_CH_REPORT, *PBSS_2040_INTOLERANT_CH_REPORT;
 
 // The structure for channel switch annoucement IE. This is in 802.11n D3.03
-typedef struct PACKED _CHA_SWITCH_ANNOUNCE_IE{
-	UCHAR			SwitchMode;	//channel switch mode
-	UCHAR			NewChannel;	//
-	UCHAR			SwitchCount;	//
+typedef struct PACKED _CHA_SWITCH_ANNOUNCE_IE {
+	UCHAR SwitchMode;	//channel switch mode
+	UCHAR NewChannel;	//
+	UCHAR SwitchCount;	//
 } CHA_SWITCH_ANNOUNCE_IE, *PCHA_SWITCH_ANNOUNCE_IE;
 
-
 // The structure for channel switch annoucement IE. This is in 802.11n D3.03
-typedef struct PACKED _SEC_CHA_OFFSET_IE{
-	UCHAR			SecondaryChannelOffset;	 // 1: Secondary above, 3: Secondary below, 0: no Secondary
+typedef struct PACKED _SEC_CHA_OFFSET_IE {
+	UCHAR SecondaryChannelOffset;	// 1: Secondary above, 3: Secondary below, 0: no Secondary
 } SEC_CHA_OFFSET_IE, *PSEC_CHA_OFFSET_IE;
 
-
 // This structure is extracted from struct RT_HT_CAPABILITY
 typedef struct {
-	BOOLEAN			bHtEnable;	 // If we should use ht rate.
-	BOOLEAN			bPreNHt;	 // If we should use ht rate.
+	BOOLEAN bHtEnable;	// If we should use ht rate.
+	BOOLEAN bPreNHt;	// If we should use ht rate.
 	//Substract from HT Capability IE
-	UCHAR			MCSSet[16];
+	UCHAR MCSSet[16];
 } RT_HT_PHY_INFO, *PRT_HT_PHY_INFO;
 
 //This structure substracts ralink supports from all 802.11n-related features.
 //Features not listed here but contained in 802.11n spec are not supported in rt2860.
 typedef struct {
-	USHORT	ChannelWidth:1;
-	USHORT	MimoPs:2;//mimo power safe MMPS_
-	USHORT	GF:1;	//green field
-	USHORT	ShortGIfor20:1;
-	USHORT	ShortGIfor40:1;	//for40MHz
-	USHORT	TxSTBC:1;
-	USHORT	RxSTBC:2;	// 2 bits
-	USHORT	AmsduEnable:1;	// Enable to transmit A-MSDU. Suggest disable. We should use A-MPDU to gain best benifit of 802.11n
-	USHORT	AmsduSize:1;	// Max receiving A-MSDU size
-	USHORT	rsv:5;
+	USHORT ChannelWidth:1;
+	USHORT MimoPs:2;	//mimo power safe MMPS_
+	USHORT GF:1;		//green field
+	USHORT ShortGIfor20:1;
+	USHORT ShortGIfor40:1;	//for40MHz
+	USHORT TxSTBC:1;
+	USHORT RxSTBC:2;	// 2 bits
+	USHORT AmsduEnable:1;	// Enable to transmit A-MSDU. Suggest disable. We should use A-MPDU to gain best benifit of 802.11n
+	USHORT AmsduSize:1;	// Max receiving A-MSDU size
+	USHORT rsv:5;
 
 	//Substract from Addiont HT INFO IE
-	UCHAR	MaxRAmpduFactor:2;
-	UCHAR	MpduDensity:3;
-	UCHAR	ExtChanOffset:2;	// Please not the difference with following 	UCHAR	NewExtChannelOffset; from 802.11n
-	UCHAR	RecomWidth:1;
-
-	USHORT	OperaionMode:2;
-	USHORT	NonGfPresent:1;
-	USHORT	rsv3:1;
-	USHORT	OBSS_NonHTExist:1;
-	USHORT	rsv2:11;
+	UCHAR MaxRAmpduFactor:2;
+	UCHAR MpduDensity:3;
+	UCHAR ExtChanOffset:2;	// Please not the difference with following     UCHAR   NewExtChannelOffset; from 802.11n
+	UCHAR RecomWidth:1;
+
+	USHORT OperaionMode:2;
+	USHORT NonGfPresent:1;
+	USHORT rsv3:1;
+	USHORT OBSS_NonHTExist:1;
+	USHORT rsv2:11;
 
 	// New Extension Channel Offset IE
-	UCHAR	NewExtChannelOffset;
+	UCHAR NewExtChannelOffset;
 	// Extension Capability IE = 127
-	UCHAR	BSSCoexist2040;
+	UCHAR BSSCoexist2040;
 } RT_HT_CAPABILITY, *PRT_HT_CAPABILITY;
 
 //   field in Addtional HT Information IE .
 typedef struct PACKED {
-	UCHAR	ExtChanOffset:2;
-	UCHAR	RecomWidth:1;
-	UCHAR	RifsMode:1;
-	UCHAR	S_PSMPSup:1;	 //Indicate support for scheduled PSMP
-	UCHAR	SerInterGranu:3;	 //service interval granularity
+	UCHAR ExtChanOffset:2;
+	UCHAR RecomWidth:1;
+	UCHAR RifsMode:1;
+	UCHAR S_PSMPSup:1;	//Indicate support for scheduled PSMP
+	UCHAR SerInterGranu:3;	//service interval granularity
 } ADD_HTINFO, *PADD_HTINFO;
 
-typedef struct PACKED{
-	USHORT	OperaionMode:2;
-	USHORT	NonGfPresent:1;
-	USHORT	rsv:1;
-	USHORT	OBSS_NonHTExist:1;
-	USHORT	rsv2:11;
+typedef struct PACKED {
+	USHORT OperaionMode:2;
+	USHORT NonGfPresent:1;
+	USHORT rsv:1;
+	USHORT OBSS_NonHTExist:1;
+	USHORT rsv2:11;
 } ADD_HTINFO2, *PADD_HTINFO2;
 
-
 // TODO: Need sync with spec about the definition of StbcMcs. In Draft 3.03, it's reserved.
-typedef struct PACKED{
-	USHORT	StbcMcs:6;
-	USHORT	DualBeacon:1;
-	USHORT	DualCTSProtect:1;
-	USHORT	STBCBeacon:1;
-	USHORT	LsigTxopProt:1;	// L-SIG TXOP protection full support
-	USHORT	PcoActive:1;
-	USHORT	PcoPhase:1;
-	USHORT	rsv:4;
+typedef struct PACKED {
+	USHORT StbcMcs:6;
+	USHORT DualBeacon:1;
+	USHORT DualCTSProtect:1;
+	USHORT STBCBeacon:1;
+	USHORT LsigTxopProt:1;	// L-SIG TXOP protection full support
+	USHORT PcoActive:1;
+	USHORT PcoPhase:1;
+	USHORT rsv:4;
 } ADD_HTINFO3, *PADD_HTINFO3;
 
 #define SIZE_ADD_HT_INFO_IE		22
-typedef struct  PACKED{
-	UCHAR				ControlChan;
-	ADD_HTINFO			AddHtInfo;
-	ADD_HTINFO2			AddHtInfo2;
-	ADD_HTINFO3			AddHtInfo3;
-	UCHAR				MCSSet[16];		// Basic MCS set
+typedef struct PACKED {
+	UCHAR ControlChan;
+	ADD_HTINFO AddHtInfo;
+	ADD_HTINFO2 AddHtInfo2;
+	ADD_HTINFO3 AddHtInfo3;
+	UCHAR MCSSet[16];	// Basic MCS set
 } ADD_HT_INFO_IE, *PADD_HT_INFO_IE;
 
-typedef struct  PACKED{
-	UCHAR				NewExtChanOffset;
+typedef struct PACKED {
+	UCHAR NewExtChanOffset;
 } NEW_EXT_CHAN_IE, *PNEW_EXT_CHAN_IE;
 
 typedef struct PACKED _FRAME_802_11 {
-    HEADER_802_11   Hdr;
-    UCHAR            Octet[1];
-}   FRAME_802_11, *PFRAME_802_11;
+	HEADER_802_11 Hdr;
+	UCHAR Octet[1];
+} FRAME_802_11, *PFRAME_802_11;
 
 // QoSNull embedding of management action. When HT Control MA field set to 1.
 typedef struct PACKED _MA_BODY {
-    UCHAR            Category;
-    UCHAR            Action;
-    UCHAR            Octet[1];
-}   MA_BODY, *PMA_BODY;
-
-typedef	struct	PACKED _HEADER_802_3	{
-    UCHAR           DAAddr1[MAC_ADDR_LEN];
-    UCHAR           SAAddr2[MAC_ADDR_LEN];
-    UCHAR           Octet[2];
-}	HEADER_802_3, *PHEADER_802_3;
+	UCHAR Category;
+	UCHAR Action;
+	UCHAR Octet[1];
+} MA_BODY, *PMA_BODY;
+
+typedef struct PACKED _HEADER_802_3 {
+	UCHAR DAAddr1[MAC_ADDR_LEN];
+	UCHAR SAAddr2[MAC_ADDR_LEN];
+	UCHAR Octet[2];
+} HEADER_802_3, *PHEADER_802_3;
 ////Block ACK related format
-// 2-byte BA Parameter  field  in 	DELBA frames to terminate an already set up bA
-typedef struct PACKED{
-    USHORT      Rsv:11;	// always set to 0
-    USHORT      Initiator:1;	// 1: originator    0:recipient
-    USHORT      TID:4;	// value of TC os TS
+// 2-byte BA Parameter  field  in       DELBA frames to terminate an already set up bA
+typedef struct PACKED {
+	USHORT Rsv:11;		// always set to 0
+	USHORT Initiator:1;	// 1: originator    0:recipient
+	USHORT TID:4;		// value of TC os TS
 } DELBA_PARM, *PDELBA_PARM;
 
 // 2-byte BA Parameter Set field  in ADDBA frames to signal parm for setting up a BA
 typedef struct PACKED {
-    USHORT      AMSDUSupported:1;	// 0: not permitted		1: permitted
-    USHORT      BAPolicy:1;	// 1: immediately BA    0:delayed BA
-    USHORT      TID:4;	// value of TC os TS
-    USHORT      BufSize:10;	// number of buffe of size 2304 octetsr
+	USHORT AMSDUSupported:1;	// 0: not permitted             1: permitted
+	USHORT BAPolicy:1;	// 1: immediately BA    0:delayed BA
+	USHORT TID:4;		// value of TC os TS
+	USHORT BufSize:10;	// number of buffe of size 2304 octetsr
 } BA_PARM, *PBA_PARM;
 
 // 2-byte BA Starting Seq CONTROL field
 typedef union PACKED {
-    struct PACKED {
-    USHORT      FragNum:4;	// always set to 0
-	USHORT      StartSeq:12;   // sequence number of the 1st MSDU for which this BAR is sent
-    }   field;
-    USHORT           word;
+	struct PACKED {
+		USHORT FragNum:4;	// always set to 0
+		USHORT StartSeq:12;	// sequence number of the 1st MSDU for which this BAR is sent
+	} field;
+	USHORT word;
 } BASEQ_CONTROL, *PBASEQ_CONTROL;
 
 //BAControl and BARControl are the same
 // 2-byte BA CONTROL field in BA frame
 typedef struct PACKED {
-    USHORT      ACKPolicy:1; // only related to N-Delayed BA. But not support in RT2860b. 0:NormalACK  1:No ACK
-    USHORT      MTID:1;		//EWC V1.24
-    USHORT      Compressed:1;
-    USHORT      Rsv:9;
-    USHORT      TID:4;
+	USHORT ACKPolicy:1;	// only related to N-Delayed BA. But not support in RT2860b. 0:NormalACK  1:No ACK
+	USHORT MTID:1;		//EWC V1.24
+	USHORT Compressed:1;
+	USHORT Rsv:9;
+	USHORT TID:4;
 } BA_CONTROL, *PBA_CONTROL;
 
 // 2-byte BAR CONTROL field in BAR frame
 typedef struct PACKED {
-    USHORT      ACKPolicy:1; // 0:normal ack,  1:no ack.
-    USHORT      MTID:1;		//if this bit1, use  FRAME_MTBA_REQ,  if 0, use FRAME_BA_REQ
-    USHORT      Compressed:1;
-    USHORT      Rsv1:9;
-    USHORT      TID:4;
+	USHORT ACKPolicy:1;	// 0:normal ack,  1:no ack.
+	USHORT MTID:1;		//if this bit1, use  FRAME_MTBA_REQ,  if 0, use FRAME_BA_REQ
+	USHORT Compressed:1;
+	USHORT Rsv1:9;
+	USHORT TID:4;
 } BAR_CONTROL, *PBAR_CONTROL;
 
 // BARControl in MTBAR frame
 typedef struct PACKED {
-    USHORT      ACKPolicy:1;
-    USHORT      MTID:1;
-    USHORT      Compressed:1;
-    USHORT      Rsv1:9;
-    USHORT      NumTID:4;
+	USHORT ACKPolicy:1;
+	USHORT MTID:1;
+	USHORT Compressed:1;
+	USHORT Rsv1:9;
+	USHORT NumTID:4;
 } MTBAR_CONTROL, *PMTBAR_CONTROL;
 
 typedef struct PACKED {
-    USHORT      Rsv1:12;
-    USHORT      TID:4;
+	USHORT Rsv1:12;
+	USHORT TID:4;
 } PER_TID_INFO, *PPER_TID_INFO;
 
 typedef struct {
-	PER_TID_INFO      PerTID;
-	BASEQ_CONTROL 	 BAStartingSeq;
+	PER_TID_INFO PerTID;
+	BASEQ_CONTROL BAStartingSeq;
 } EACH_TID, *PEACH_TID;
 
-
 // BAREQ AND MTBAREQ have the same subtype BAR, 802.11n BAR use compressed bitmap.
 typedef struct PACKED _FRAME_BA_REQ {
-	FRAME_CONTROL   FC;
-	USHORT          Duration;
-	UCHAR           Addr1[MAC_ADDR_LEN];
-	UCHAR           Addr2[MAC_ADDR_LEN];
-	BAR_CONTROL  BARControl;
-	BASEQ_CONTROL 	 BAStartingSeq;
-}   FRAME_BA_REQ, *PFRAME_BA_REQ;
+	FRAME_CONTROL FC;
+	USHORT Duration;
+	UCHAR Addr1[MAC_ADDR_LEN];
+	UCHAR Addr2[MAC_ADDR_LEN];
+	BAR_CONTROL BARControl;
+	BASEQ_CONTROL BAStartingSeq;
+} FRAME_BA_REQ, *PFRAME_BA_REQ;
 
 typedef struct PACKED _FRAME_MTBA_REQ {
-	FRAME_CONTROL   FC;
-	USHORT          Duration;
-	UCHAR           Addr1[MAC_ADDR_LEN];
-	UCHAR           Addr2[MAC_ADDR_LEN];
-	MTBAR_CONTROL  MTBARControl;
-	PER_TID_INFO	PerTIDInfo;
-	BASEQ_CONTROL 	 BAStartingSeq;
-}   FRAME_MTBA_REQ, *PFRAME_MTBA_REQ;
+	FRAME_CONTROL FC;
+	USHORT Duration;
+	UCHAR Addr1[MAC_ADDR_LEN];
+	UCHAR Addr2[MAC_ADDR_LEN];
+	MTBAR_CONTROL MTBARControl;
+	PER_TID_INFO PerTIDInfo;
+	BASEQ_CONTROL BAStartingSeq;
+} FRAME_MTBA_REQ, *PFRAME_MTBA_REQ;
 
 // Compressed format is mandantory in HT STA
 typedef struct PACKED _FRAME_MTBA {
-	FRAME_CONTROL   FC;
-	USHORT          Duration;
-	UCHAR           Addr1[MAC_ADDR_LEN];
-	UCHAR           Addr2[MAC_ADDR_LEN];
-	BA_CONTROL  BAControl;
-	BASEQ_CONTROL 	 BAStartingSeq;
-	UCHAR		BitMap[8];
-}   FRAME_MTBA, *PFRAME_MTBA;
+	FRAME_CONTROL FC;
+	USHORT Duration;
+	UCHAR Addr1[MAC_ADDR_LEN];
+	UCHAR Addr2[MAC_ADDR_LEN];
+	BA_CONTROL BAControl;
+	BASEQ_CONTROL BAStartingSeq;
+	UCHAR BitMap[8];
+} FRAME_MTBA, *PFRAME_MTBA;
 
 typedef struct PACKED _FRAME_PSMP_ACTION {
-	HEADER_802_11   Hdr;
-	UCHAR	Category;
-	UCHAR	Action;
-	UCHAR	Psmp;	// 7.3.1.25
-}   FRAME_PSMP_ACTION, *PFRAME_PSMP_ACTION;
+	HEADER_802_11 Hdr;
+	UCHAR Category;
+	UCHAR Action;
+	UCHAR Psmp;		// 7.3.1.25
+} FRAME_PSMP_ACTION, *PFRAME_PSMP_ACTION;
 
 typedef struct PACKED _FRAME_ACTION_HDR {
-	HEADER_802_11   Hdr;
-	UCHAR	Category;
-	UCHAR	Action;
-}   FRAME_ACTION_HDR, *PFRAME_ACTION_HDR;
+	HEADER_802_11 Hdr;
+	UCHAR Category;
+	UCHAR Action;
+} FRAME_ACTION_HDR, *PFRAME_ACTION_HDR;
 
 //Action Frame
 //Action Frame  Category:Spectrum,  Action:Channel Switch. 7.3.2.20
 typedef struct PACKED _CHAN_SWITCH_ANNOUNCE {
-	UCHAR					ElementID;	// ID = IE_CHANNEL_SWITCH_ANNOUNCEMENT = 37
-	UCHAR					Len;
-	CHA_SWITCH_ANNOUNCE_IE	CSAnnounceIe;
-}   CHAN_SWITCH_ANNOUNCE, *PCHAN_SWITCH_ANNOUNCE;
-
+	UCHAR ElementID;	// ID = IE_CHANNEL_SWITCH_ANNOUNCEMENT = 37
+	UCHAR Len;
+	CHA_SWITCH_ANNOUNCE_IE CSAnnounceIe;
+} CHAN_SWITCH_ANNOUNCE, *PCHAN_SWITCH_ANNOUNCE;
 
 //802.11n : 7.3.2.20a
 typedef struct PACKED _SECOND_CHAN_OFFSET {
-	UCHAR				ElementID;		// ID = IE_SECONDARY_CH_OFFSET = 62
-	UCHAR				Len;
-	SEC_CHA_OFFSET_IE	SecChOffsetIe;
-}   SECOND_CHAN_OFFSET, *PSECOND_CHAN_OFFSET;
-
+	UCHAR ElementID;	// ID = IE_SECONDARY_CH_OFFSET = 62
+	UCHAR Len;
+	SEC_CHA_OFFSET_IE SecChOffsetIe;
+} SECOND_CHAN_OFFSET, *PSECOND_CHAN_OFFSET;
 
 typedef struct PACKED _FRAME_SPETRUM_CS {
-	HEADER_802_11   Hdr;
-	UCHAR	Category;
-	UCHAR	Action;
-	CHAN_SWITCH_ANNOUNCE	CSAnnounce;
-	SECOND_CHAN_OFFSET		SecondChannel;
-}   FRAME_SPETRUM_CS, *PFRAME_SPETRUM_CS;
-
+	HEADER_802_11 Hdr;
+	UCHAR Category;
+	UCHAR Action;
+	CHAN_SWITCH_ANNOUNCE CSAnnounce;
+	SECOND_CHAN_OFFSET SecondChannel;
+} FRAME_SPETRUM_CS, *PFRAME_SPETRUM_CS;
 
 typedef struct PACKED _FRAME_ADDBA_REQ {
-	HEADER_802_11   Hdr;
-	UCHAR	Category;
-	UCHAR	Action;
-	UCHAR	Token;	// 1
-	BA_PARM		BaParm;	      //  2 - 10
-	USHORT		TimeOutValue;	// 0 - 0
-	BASEQ_CONTROL	BaStartSeq; // 0-0
-}   FRAME_ADDBA_REQ, *PFRAME_ADDBA_REQ;
+	HEADER_802_11 Hdr;
+	UCHAR Category;
+	UCHAR Action;
+	UCHAR Token;		// 1
+	BA_PARM BaParm;		//  2 - 10
+	USHORT TimeOutValue;	// 0 - 0
+	BASEQ_CONTROL BaStartSeq;	// 0-0
+} FRAME_ADDBA_REQ, *PFRAME_ADDBA_REQ;
 
 typedef struct PACKED _FRAME_ADDBA_RSP {
-	HEADER_802_11   Hdr;
-	UCHAR	Category;
-	UCHAR	Action;
-	UCHAR	Token;
-	USHORT	StatusCode;
-	BA_PARM		BaParm; //0 - 2
-	USHORT		TimeOutValue;
-}   FRAME_ADDBA_RSP, *PFRAME_ADDBA_RSP;
+	HEADER_802_11 Hdr;
+	UCHAR Category;
+	UCHAR Action;
+	UCHAR Token;
+	USHORT StatusCode;
+	BA_PARM BaParm;		//0 - 2
+	USHORT TimeOutValue;
+} FRAME_ADDBA_RSP, *PFRAME_ADDBA_RSP;
 
 typedef struct PACKED _FRAME_DELBA_REQ {
-	HEADER_802_11   Hdr;
-	UCHAR	Category;
-	UCHAR	Action;
-	DELBA_PARM		DelbaParm;
-	USHORT	ReasonCode;
-}   FRAME_DELBA_REQ, *PFRAME_DELBA_REQ;
-
+	HEADER_802_11 Hdr;
+	UCHAR Category;
+	UCHAR Action;
+	DELBA_PARM DelbaParm;
+	USHORT ReasonCode;
+} FRAME_DELBA_REQ, *PFRAME_DELBA_REQ;
 
 //7.2.1.7
 typedef struct PACKED _FRAME_BAR {
-	FRAME_CONTROL   FC;
-	USHORT          Duration;
-	UCHAR           Addr1[MAC_ADDR_LEN];
-	UCHAR           Addr2[MAC_ADDR_LEN];
-	BAR_CONTROL		BarControl;
-	BASEQ_CONTROL	StartingSeq;
-}   FRAME_BAR, *PFRAME_BAR;
+	FRAME_CONTROL FC;
+	USHORT Duration;
+	UCHAR Addr1[MAC_ADDR_LEN];
+	UCHAR Addr2[MAC_ADDR_LEN];
+	BAR_CONTROL BarControl;
+	BASEQ_CONTROL StartingSeq;
+} FRAME_BAR, *PFRAME_BAR;
 
 //7.2.1.7
 typedef struct PACKED _FRAME_BA {
-	FRAME_CONTROL   FC;
-	USHORT          Duration;
-	UCHAR           Addr1[MAC_ADDR_LEN];
-	UCHAR           Addr2[MAC_ADDR_LEN];
-	BAR_CONTROL		BarControl;
-	BASEQ_CONTROL	StartingSeq;
-	UCHAR		bitmask[8];
-}   FRAME_BA, *PFRAME_BA;
-
+	FRAME_CONTROL FC;
+	USHORT Duration;
+	UCHAR Addr1[MAC_ADDR_LEN];
+	UCHAR Addr2[MAC_ADDR_LEN];
+	BAR_CONTROL BarControl;
+	BASEQ_CONTROL StartingSeq;
+	UCHAR bitmask[8];
+} FRAME_BA, *PFRAME_BA;
 
 // Radio Measuement Request Frame Format
 typedef struct PACKED _FRAME_RM_REQ_ACTION {
-	HEADER_802_11   Hdr;
-	UCHAR	Category;
-	UCHAR	Action;
-	UCHAR	Token;
-	USHORT	Repetition;
-	UCHAR   data[0];
-}   FRAME_RM_REQ_ACTION, *PFRAME_RM_REQ_ACTION;
-
-typedef struct PACKED {
-	UCHAR		ID;
-	UCHAR		Length;
-	UCHAR		ChannelSwitchMode;
-	UCHAR		NewRegClass;
-	UCHAR		NewChannelNum;
-	UCHAR		ChannelSwitchCount;
-} HT_EXT_CHANNEL_SWITCH_ANNOUNCEMENT_IE, *PHT_EXT_CHANNEL_SWITCH_ANNOUNCEMENT_IE;
-
+	HEADER_802_11 Hdr;
+	UCHAR Category;
+	UCHAR Action;
+	UCHAR Token;
+	USHORT Repetition;
+	UCHAR data[0];
+} FRAME_RM_REQ_ACTION, *PFRAME_RM_REQ_ACTION;
+
+typedef struct PACKED {
+	UCHAR ID;
+	UCHAR Length;
+	UCHAR ChannelSwitchMode;
+	UCHAR NewRegClass;
+	UCHAR NewChannelNum;
+	UCHAR ChannelSwitchCount;
+} HT_EXT_CHANNEL_SWITCH_ANNOUNCEMENT_IE,
+    *PHT_EXT_CHANNEL_SWITCH_ANNOUNCEMENT_IE;
 
 //
 // _Limit must be the 2**n - 1
@@ -701,183 +682,181 @@ typedef struct PACKED {
 // Contention-free parameter (without ID and Length)
 //
 typedef struct PACKED {
-    BOOLEAN     bValid;         // 1: variable contains valid value
-    UCHAR       CfpCount;
-    UCHAR       CfpPeriod;
-    USHORT      CfpMaxDuration;
-    USHORT      CfpDurRemaining;
+	BOOLEAN bValid;		// 1: variable contains valid value
+	UCHAR CfpCount;
+	UCHAR CfpPeriod;
+	USHORT CfpMaxDuration;
+	USHORT CfpDurRemaining;
 } CF_PARM, *PCF_PARM;
 
-typedef	struct	_CIPHER_SUITE	{
-	NDIS_802_11_ENCRYPTION_STATUS	PairCipher;		// Unicast cipher 1, this one has more secured cipher suite
-	NDIS_802_11_ENCRYPTION_STATUS	PairCipherAux;	// Unicast cipher 2 if AP announce two unicast cipher suite
-	NDIS_802_11_ENCRYPTION_STATUS	GroupCipher;	// Group cipher
-	USHORT							RsnCapability;	// RSN capability from beacon
-	BOOLEAN							bMixMode;		// Indicate Pair & Group cipher might be different
-}	CIPHER_SUITE, *PCIPHER_SUITE;
+typedef struct _CIPHER_SUITE {
+	NDIS_802_11_ENCRYPTION_STATUS PairCipher;	// Unicast cipher 1, this one has more secured cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS PairCipherAux;	// Unicast cipher 2 if AP announce two unicast cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS GroupCipher;	// Group cipher
+	USHORT RsnCapability;	// RSN capability from beacon
+	BOOLEAN bMixMode;	// Indicate Pair & Group cipher might be different
+} CIPHER_SUITE, *PCIPHER_SUITE;
 
 // EDCA configuration from AP's BEACON/ProbeRsp
 typedef struct {
-    BOOLEAN     bValid;         // 1: variable contains valid value
-    BOOLEAN     bAdd;         // 1: variable contains valid value
-    BOOLEAN     bQAck;
-    BOOLEAN     bQueueRequest;
-    BOOLEAN     bTxopRequest;
-    BOOLEAN     bAPSDCapable;
+	BOOLEAN bValid;		// 1: variable contains valid value
+	BOOLEAN bAdd;		// 1: variable contains valid value
+	BOOLEAN bQAck;
+	BOOLEAN bQueueRequest;
+	BOOLEAN bTxopRequest;
+	BOOLEAN bAPSDCapable;
 //  BOOLEAN     bMoreDataAck;
-    UCHAR       EdcaUpdateCount;
-    UCHAR       Aifsn[4];       // 0:AC_BK, 1:AC_BE, 2:AC_VI, 3:AC_VO
-    UCHAR       Cwmin[4];
-    UCHAR       Cwmax[4];
-    USHORT      Txop[4];      // in unit of 32-us
-    BOOLEAN     bACM[4];      // 1: Admission Control of AC_BK is mandattory
+	UCHAR EdcaUpdateCount;
+	UCHAR Aifsn[4];		// 0:AC_BK, 1:AC_BE, 2:AC_VI, 3:AC_VO
+	UCHAR Cwmin[4];
+	UCHAR Cwmax[4];
+	USHORT Txop[4];		// in unit of 32-us
+	BOOLEAN bACM[4];	// 1: Admission Control of AC_BK is mandattory
 } EDCA_PARM, *PEDCA_PARM;
 
 // QBSS LOAD information from QAP's BEACON/ProbeRsp
 typedef struct {
-    BOOLEAN     bValid;                     // 1: variable contains valid value
-    USHORT      StaNum;
-    UCHAR       ChannelUtilization;
-    USHORT      RemainingAdmissionControl;  // in unit of 32-us
+	BOOLEAN bValid;		// 1: variable contains valid value
+	USHORT StaNum;
+	UCHAR ChannelUtilization;
+	USHORT RemainingAdmissionControl;	// in unit of 32-us
 } QBSS_LOAD_PARM, *PQBSS_LOAD_PARM;
 
 // QBSS Info field in QSTA's assoc req
 typedef struct PACKED {
-    UCHAR		UAPSD_AC_VO:1;
-	UCHAR		UAPSD_AC_VI:1;
-	UCHAR		UAPSD_AC_BK:1;
-	UCHAR		UAPSD_AC_BE:1;
-	UCHAR		Rsv1:1;
-	UCHAR		MaxSPLength:2;
-	UCHAR		Rsv2:1;
+	UCHAR UAPSD_AC_VO:1;
+	UCHAR UAPSD_AC_VI:1;
+	UCHAR UAPSD_AC_BK:1;
+	UCHAR UAPSD_AC_BE:1;
+	UCHAR Rsv1:1;
+	UCHAR MaxSPLength:2;
+	UCHAR Rsv2:1;
 } QBSS_STA_INFO_PARM, *PQBSS_STA_INFO_PARM;
 
 // QBSS Info field in QAP's Beacon/ProbeRsp
 typedef struct PACKED {
-    UCHAR		ParamSetCount:4;
-	UCHAR		Rsv:3;
-	UCHAR		UAPSD:1;
+	UCHAR ParamSetCount:4;
+	UCHAR Rsv:3;
+	UCHAR UAPSD:1;
 } QBSS_AP_INFO_PARM, *PQBSS_AP_INFO_PARM;
 
 // QOS Capability reported in QAP's BEACON/ProbeRsp
 // QOS Capability sent out in QSTA's AssociateReq/ReAssociateReq
 typedef struct {
-    BOOLEAN     bValid;                     // 1: variable contains valid value
-    BOOLEAN     bQAck;
-    BOOLEAN     bQueueRequest;
-    BOOLEAN     bTxopRequest;
+	BOOLEAN bValid;		// 1: variable contains valid value
+	BOOLEAN bQAck;
+	BOOLEAN bQueueRequest;
+	BOOLEAN bTxopRequest;
 //  BOOLEAN     bMoreDataAck;
-    UCHAR       EdcaUpdateCount;
+	UCHAR EdcaUpdateCount;
 } QOS_CAPABILITY_PARM, *PQOS_CAPABILITY_PARM;
 
 typedef struct {
-    UCHAR       IELen;
-    UCHAR       IE[MAX_CUSTOM_LEN];
+	UCHAR IELen;
+	UCHAR IE[MAX_CUSTOM_LEN];
 } WPA_IE_;
 
 typedef struct {
-    UCHAR   Bssid[MAC_ADDR_LEN];
-    UCHAR   Channel;
-	UCHAR   CentralChannel;	//Store the wide-band central channel for 40MHz.  .used in 40MHz AP. Or this is the same as Channel.
-    UCHAR   BssType;
-    USHORT  AtimWin;
-    USHORT  BeaconPeriod;
-
-    UCHAR   SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-    UCHAR   SupRateLen;
-    UCHAR   ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-    UCHAR   ExtRateLen;
+	UCHAR Bssid[MAC_ADDR_LEN];
+	UCHAR Channel;
+	UCHAR CentralChannel;	//Store the wide-band central channel for 40MHz.  .used in 40MHz AP. Or this is the same as Channel.
+	UCHAR BssType;
+	USHORT AtimWin;
+	USHORT BeaconPeriod;
+
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR SupRateLen;
+	UCHAR ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR ExtRateLen;
 	HT_CAPABILITY_IE HtCapability;
-	UCHAR			HtCapabilityLen;
+	UCHAR HtCapabilityLen;
 	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
-	UCHAR			AddHtInfoLen;
-	UCHAR			NewExtChanOffset;
-	CHAR    Rssi;
-    UCHAR   Privacy;			// Indicate security function ON/OFF. Don't mess up with auth mode.
-	UCHAR	Hidden;
-
-    USHORT  DtimPeriod;
-    USHORT  CapabilityInfo;
-
-    USHORT  CfpCount;
-    USHORT  CfpPeriod;
-    USHORT  CfpMaxDuration;
-    USHORT  CfpDurRemaining;
-    UCHAR   SsidLen;
-    CHAR    Ssid[MAX_LEN_OF_SSID];
+	UCHAR AddHtInfoLen;
+	UCHAR NewExtChanOffset;
+	CHAR Rssi;
+	UCHAR Privacy;		// Indicate security function ON/OFF. Don't mess up with auth mode.
+	UCHAR Hidden;
+
+	USHORT DtimPeriod;
+	USHORT CapabilityInfo;
+
+	USHORT CfpCount;
+	USHORT CfpPeriod;
+	USHORT CfpMaxDuration;
+	USHORT CfpDurRemaining;
+	UCHAR SsidLen;
+	CHAR Ssid[MAX_LEN_OF_SSID];
 
-    ULONG   LastBeaconRxTime; // OS's timestamp
+	ULONG LastBeaconRxTime;	// OS's timestamp
 
-	BOOLEAN	bSES;
+	BOOLEAN bSES;
 
 	// New for WPA2
-	CIPHER_SUITE					WPA;			// AP announced WPA cipher suite
-	CIPHER_SUITE					WPA2;			// AP announced WPA2 cipher suite
+	CIPHER_SUITE WPA;	// AP announced WPA cipher suite
+	CIPHER_SUITE WPA2;	// AP announced WPA2 cipher suite
 
 	// New for microsoft WPA support
-	NDIS_802_11_FIXED_IEs	FixIEs;
-	NDIS_802_11_AUTHENTICATION_MODE	AuthModeAux;	// Addition mode for WPA2 / WPA capable AP
-	NDIS_802_11_AUTHENTICATION_MODE	AuthMode;
-	NDIS_802_11_WEP_STATUS	WepStatus;				// Unicast Encryption Algorithm extract from VAR_IE
-	USHORT					VarIELen;				// Length of next VIE include EID & Length
-	UCHAR					VarIEs[MAX_VIE_LEN];
+	NDIS_802_11_FIXED_IEs FixIEs;
+	NDIS_802_11_AUTHENTICATION_MODE AuthModeAux;	// Addition mode for WPA2 / WPA capable AP
+	NDIS_802_11_AUTHENTICATION_MODE AuthMode;
+	NDIS_802_11_WEP_STATUS WepStatus;	// Unicast Encryption Algorithm extract from VAR_IE
+	USHORT VarIELen;	// Length of next VIE include EID & Length
+	UCHAR VarIEs[MAX_VIE_LEN];
 
 	// CCX Ckip information
-    UCHAR   CkipFlag;
+	UCHAR CkipFlag;
 
 	// CCX 2 TSF
-	UCHAR	PTSF[4];		// Parent TSF
-	UCHAR	TTSF[8];		// Target TSF
+	UCHAR PTSF[4];		// Parent TSF
+	UCHAR TTSF[8];		// Target TSF
 
-    // 802.11e d9, and WMM
-	EDCA_PARM           EdcaParm;
+	// 802.11e d9, and WMM
+	EDCA_PARM EdcaParm;
 	QOS_CAPABILITY_PARM QosCapability;
-	QBSS_LOAD_PARM      QbssLoad;
-    WPA_IE_     WpaIE;
-    WPA_IE_     RsnIE;
+	QBSS_LOAD_PARM QbssLoad;
+	WPA_IE_ WpaIE;
+	WPA_IE_ RsnIE;
 } BSS_ENTRY, *PBSS_ENTRY;
 
 typedef struct {
-    UCHAR           BssNr;
-    UCHAR           BssOverlapNr;
-    BSS_ENTRY       BssEntry[MAX_LEN_OF_BSS_TABLE];
+	UCHAR BssNr;
+	UCHAR BssOverlapNr;
+	BSS_ENTRY BssEntry[MAX_LEN_OF_BSS_TABLE];
 } BSS_TABLE, *PBSS_TABLE;
 
-
 typedef struct _MLME_QUEUE_ELEM {
-    ULONG             Machine;
-    ULONG             MsgType;
-    ULONG             MsgLen;
-    UCHAR             Msg[MGMT_DMA_BUFFER_SIZE];
-    LARGE_INTEGER     TimeStamp;
-    UCHAR             Rssi0;
-    UCHAR             Rssi1;
-    UCHAR             Rssi2;
-    UCHAR             Signal;
-    UCHAR             Channel;
-    UCHAR             Wcid;
-    BOOLEAN           Occupied;
+	ULONG Machine;
+	ULONG MsgType;
+	ULONG MsgLen;
+	UCHAR Msg[MGMT_DMA_BUFFER_SIZE];
+	LARGE_INTEGER TimeStamp;
+	UCHAR Rssi0;
+	UCHAR Rssi1;
+	UCHAR Rssi2;
+	UCHAR Signal;
+	UCHAR Channel;
+	UCHAR Wcid;
+	BOOLEAN Occupied;
 } MLME_QUEUE_ELEM, *PMLME_QUEUE_ELEM;
 
 typedef struct _MLME_QUEUE {
-    ULONG             Num;
-    ULONG             Head;
-    ULONG             Tail;
-    NDIS_SPIN_LOCK   Lock;
-    MLME_QUEUE_ELEM  Entry[MAX_LEN_OF_MLME_QUEUE];
+	ULONG Num;
+	ULONG Head;
+	ULONG Tail;
+	NDIS_SPIN_LOCK Lock;
+	MLME_QUEUE_ELEM Entry[MAX_LEN_OF_MLME_QUEUE];
 } MLME_QUEUE, *PMLME_QUEUE;
 
-typedef VOID (*STATE_MACHINE_FUNC)(VOID *Adaptor, MLME_QUEUE_ELEM *Elem);
+typedef VOID(*STATE_MACHINE_FUNC) (VOID * Adaptor, MLME_QUEUE_ELEM * Elem);
 
 typedef struct _STATE_MACHINE {
-    ULONG                           Base;
-    ULONG                           NrState;
-    ULONG                           NrMsg;
-    ULONG                           CurrState;
-    STATE_MACHINE_FUNC             *TransFunc;
+	ULONG Base;
+	ULONG NrState;
+	ULONG NrMsg;
+	ULONG CurrState;
+	STATE_MACHINE_FUNC *TransFunc;
 } STATE_MACHINE, *PSTATE_MACHINE;
 
-
 // MLME AUX data structure that hold temporarliy settings during a connection attempt.
 // Once this attemp succeeds, all settings will be copy to pAd->StaActive.
 // A connection attempt (user set OID, roaming, CCX fast roaming,..) consists of
@@ -885,191 +864,189 @@ typedef struct _STATE_MACHINE {
 // separate this under-trial settings away from pAd->StaActive so that once
 // this new attempt failed, driver can auto-recover back to the active settings.
 typedef struct _MLME_AUX {
-    UCHAR               BssType;
-    UCHAR               Ssid[MAX_LEN_OF_SSID];
-    UCHAR               SsidLen;
-    UCHAR               Bssid[MAC_ADDR_LEN];
-	UCHAR				AutoReconnectSsid[MAX_LEN_OF_SSID];
-	UCHAR				AutoReconnectSsidLen;
-    USHORT              Alg;
-    UCHAR               ScanType;
-    UCHAR               Channel;
-	UCHAR               CentralChannel;
-    USHORT              Aid;
-    USHORT              CapabilityInfo;
-    USHORT              BeaconPeriod;
-    USHORT              CfpMaxDuration;
-    USHORT              CfpPeriod;
-    USHORT              AtimWin;
+	UCHAR BssType;
+	UCHAR Ssid[MAX_LEN_OF_SSID];
+	UCHAR SsidLen;
+	UCHAR Bssid[MAC_ADDR_LEN];
+	UCHAR AutoReconnectSsid[MAX_LEN_OF_SSID];
+	UCHAR AutoReconnectSsidLen;
+	USHORT Alg;
+	UCHAR ScanType;
+	UCHAR Channel;
+	UCHAR CentralChannel;
+	USHORT Aid;
+	USHORT CapabilityInfo;
+	USHORT BeaconPeriod;
+	USHORT CfpMaxDuration;
+	USHORT CfpPeriod;
+	USHORT AtimWin;
 
 	// Copy supported rate from desired AP's beacon. We are trying to match
 	// AP's supported and extended rate settings.
-	UCHAR		        SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR		        ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR		        SupRateLen;
-	UCHAR		        ExtRateLen;
-	HT_CAPABILITY_IE		HtCapability;
-	UCHAR		        	HtCapabilityLen;
-	ADD_HT_INFO_IE		AddHtInfo;	// AP might use this additional ht info IE
-	UCHAR			NewExtChannelOffset;
-	//RT_HT_CAPABILITY	SupportedHtPhy;
-
-    // new for QOS
-    QOS_CAPABILITY_PARM APQosCapability;    // QOS capability of the current associated AP
-    EDCA_PARM           APEdcaParm;         // EDCA parameters of the current associated AP
-    QBSS_LOAD_PARM      APQbssLoad;         // QBSS load of the current associated AP
-
-    // new to keep Ralink specific feature
-    ULONG               APRalinkIe;
-
-    BSS_TABLE           SsidBssTab;     // AP list for the same SSID
-    BSS_TABLE           RoamTab;        // AP list eligible for roaming
-    ULONG               BssIdx;
-    ULONG               RoamIdx;
-
-	BOOLEAN				CurrReqIsFromNdis;
-
-    RALINK_TIMER_STRUCT BeaconTimer, ScanTimer;
-    RALINK_TIMER_STRUCT AuthTimer;
-    RALINK_TIMER_STRUCT AssocTimer, ReassocTimer, DisassocTimer;
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR SupRateLen;
+	UCHAR ExtRateLen;
+	HT_CAPABILITY_IE HtCapability;
+	UCHAR HtCapabilityLen;
+	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	UCHAR NewExtChannelOffset;
+	//RT_HT_CAPABILITY      SupportedHtPhy;
+
+	// new for QOS
+	QOS_CAPABILITY_PARM APQosCapability;	// QOS capability of the current associated AP
+	EDCA_PARM APEdcaParm;	// EDCA parameters of the current associated AP
+	QBSS_LOAD_PARM APQbssLoad;	// QBSS load of the current associated AP
+
+	// new to keep Ralink specific feature
+	ULONG APRalinkIe;
+
+	BSS_TABLE SsidBssTab;	// AP list for the same SSID
+	BSS_TABLE RoamTab;	// AP list eligible for roaming
+	ULONG BssIdx;
+	ULONG RoamIdx;
+
+	BOOLEAN CurrReqIsFromNdis;
+
+	RALINK_TIMER_STRUCT BeaconTimer, ScanTimer;
+	RALINK_TIMER_STRUCT AuthTimer;
+	RALINK_TIMER_STRUCT AssocTimer, ReassocTimer, DisassocTimer;
 } MLME_AUX, *PMLME_AUX;
 
-typedef struct _MLME_ADDBA_REQ_STRUCT{
-	UCHAR   Wcid;	//
-	UCHAR   pAddr[MAC_ADDR_LEN];
-	UCHAR   BaBufSize;
-	USHORT	TimeOutValue;
-	UCHAR   TID;
-	UCHAR   Token;
-	USHORT	BaStartSeq;
+typedef struct _MLME_ADDBA_REQ_STRUCT {
+	UCHAR Wcid;		//
+	UCHAR pAddr[MAC_ADDR_LEN];
+	UCHAR BaBufSize;
+	USHORT TimeOutValue;
+	UCHAR TID;
+	UCHAR Token;
+	USHORT BaStartSeq;
 } MLME_ADDBA_REQ_STRUCT, *PMLME_ADDBA_REQ_STRUCT;
 
-
-typedef struct _MLME_DELBA_REQ_STRUCT{
-	UCHAR   Wcid;	//
-	UCHAR     Addr[MAC_ADDR_LEN];
-	UCHAR   TID;
-	UCHAR	Initiator;
+typedef struct _MLME_DELBA_REQ_STRUCT {
+	UCHAR Wcid;		//
+	UCHAR Addr[MAC_ADDR_LEN];
+	UCHAR TID;
+	UCHAR Initiator;
 } MLME_DELBA_REQ_STRUCT, *PMLME_DELBA_REQ_STRUCT;
 
 // assoc struct is equal to reassoc
-typedef struct _MLME_ASSOC_REQ_STRUCT{
-    UCHAR     Addr[MAC_ADDR_LEN];
-    USHORT    CapabilityInfo;
-    USHORT    ListenIntv;
-    ULONG     Timeout;
-} MLME_ASSOC_REQ_STRUCT, *PMLME_ASSOC_REQ_STRUCT, MLME_REASSOC_REQ_STRUCT, *PMLME_REASSOC_REQ_STRUCT;
-
-typedef struct _MLME_DISASSOC_REQ_STRUCT{
-    UCHAR     Addr[MAC_ADDR_LEN];
-    USHORT    Reason;
+typedef struct _MLME_ASSOC_REQ_STRUCT {
+	UCHAR Addr[MAC_ADDR_LEN];
+	USHORT CapabilityInfo;
+	USHORT ListenIntv;
+	ULONG Timeout;
+} MLME_ASSOC_REQ_STRUCT, *PMLME_ASSOC_REQ_STRUCT, MLME_REASSOC_REQ_STRUCT,
+    *PMLME_REASSOC_REQ_STRUCT;
+
+typedef struct _MLME_DISASSOC_REQ_STRUCT {
+	UCHAR Addr[MAC_ADDR_LEN];
+	USHORT Reason;
 } MLME_DISASSOC_REQ_STRUCT, *PMLME_DISASSOC_REQ_STRUCT;
 
 typedef struct _MLME_AUTH_REQ_STRUCT {
-    UCHAR        Addr[MAC_ADDR_LEN];
-    USHORT       Alg;
-    ULONG        Timeout;
+	UCHAR Addr[MAC_ADDR_LEN];
+	USHORT Alg;
+	ULONG Timeout;
 } MLME_AUTH_REQ_STRUCT, *PMLME_AUTH_REQ_STRUCT;
 
 typedef struct _MLME_DEAUTH_REQ_STRUCT {
-    UCHAR        Addr[MAC_ADDR_LEN];
-    USHORT       Reason;
+	UCHAR Addr[MAC_ADDR_LEN];
+	USHORT Reason;
 } MLME_DEAUTH_REQ_STRUCT, *PMLME_DEAUTH_REQ_STRUCT;
 
 typedef struct {
-    ULONG      BssIdx;
+	ULONG BssIdx;
 } MLME_JOIN_REQ_STRUCT;
 
 typedef struct _MLME_SCAN_REQ_STRUCT {
-    UCHAR      Bssid[MAC_ADDR_LEN];
-    UCHAR      BssType;
-    UCHAR      ScanType;
-    UCHAR      SsidLen;
-    CHAR       Ssid[MAX_LEN_OF_SSID];
+	UCHAR Bssid[MAC_ADDR_LEN];
+	UCHAR BssType;
+	UCHAR ScanType;
+	UCHAR SsidLen;
+	CHAR Ssid[MAX_LEN_OF_SSID];
 } MLME_SCAN_REQ_STRUCT, *PMLME_SCAN_REQ_STRUCT;
 
 typedef struct _MLME_START_REQ_STRUCT {
-    CHAR        Ssid[MAX_LEN_OF_SSID];
-    UCHAR       SsidLen;
+	CHAR Ssid[MAX_LEN_OF_SSID];
+	UCHAR SsidLen;
 } MLME_START_REQ_STRUCT, *PMLME_START_REQ_STRUCT;
 
 typedef struct PACKED {
-    UCHAR   Eid;
-    UCHAR   Len;
-    UCHAR   Octet[1];
-} EID_STRUCT,*PEID_STRUCT, BEACON_EID_STRUCT, *PBEACON_EID_STRUCT;
-
-typedef struct PACKED _RTMP_TX_RATE_SWITCH
-{
-	UCHAR   ItemNo;
-	UCHAR	STBC:1;
-	UCHAR	ShortGI:1;
-	UCHAR	BW:1;
-	UCHAR	Rsv1:1;
-	UCHAR	Mode:2;
-	UCHAR	Rsv2:2;
-	UCHAR   CurrMCS;
-	UCHAR   TrainUp;
-	UCHAR   TrainDown;
+	UCHAR Eid;
+	UCHAR Len;
+	UCHAR Octet[1];
+} EID_STRUCT, *PEID_STRUCT, BEACON_EID_STRUCT, *PBEACON_EID_STRUCT;
+
+typedef struct PACKED _RTMP_TX_RATE_SWITCH {
+	UCHAR ItemNo;
+	UCHAR STBC:1;
+	UCHAR ShortGI:1;
+	UCHAR BW:1;
+	UCHAR Rsv1:1;
+	UCHAR Mode:2;
+	UCHAR Rsv2:2;
+	UCHAR CurrMCS;
+	UCHAR TrainUp;
+	UCHAR TrainDown;
 } RRTMP_TX_RATE_SWITCH, *PRTMP_TX_RATE_SWITCH;
 
 // ========================== AP mlme.h ===============================
-#define TBTT_PRELOAD_TIME       384        // usec. LomgPreamble + 24-byte at 1Mbps
+#define TBTT_PRELOAD_TIME       384	// usec. LomgPreamble + 24-byte at 1Mbps
 #define DEFAULT_DTIM_PERIOD     1
 
-#define MAC_TABLE_AGEOUT_TIME			300			// unit: sec
-#define MAC_TABLE_ASSOC_TIMEOUT			5			// unit: sec
+#define MAC_TABLE_AGEOUT_TIME			300	// unit: sec
+#define MAC_TABLE_ASSOC_TIMEOUT			5	// unit: sec
 #define MAC_TABLE_FULL(Tab)				((Tab).size == MAX_LEN_OF_MAC_TABLE)
 
 // AP shall drop the sta if contine Tx fail count reach it.
-#define MAC_ENTRY_LIFE_CHECK_CNT		20			// packet cnt.
+#define MAC_ENTRY_LIFE_CHECK_CNT		20	// packet cnt.
 
 // Value domain of pMacEntry->Sst
 typedef enum _Sst {
-    SST_NOT_AUTH,   // 0: equivalent to IEEE 802.11/1999 state 1
-    SST_AUTH,       // 1: equivalent to IEEE 802.11/1999 state 2
-    SST_ASSOC       // 2: equivalent to IEEE 802.11/1999 state 3
+	SST_NOT_AUTH,		// 0: equivalent to IEEE 802.11/1999 state 1
+	SST_AUTH,		// 1: equivalent to IEEE 802.11/1999 state 2
+	SST_ASSOC		// 2: equivalent to IEEE 802.11/1999 state 3
 } SST;
 
 // value domain of pMacEntry->AuthState
 typedef enum _AuthState {
-    AS_NOT_AUTH,
-    AS_AUTH_OPEN,       // STA has been authenticated using OPEN SYSTEM
-    AS_AUTH_KEY,        // STA has been authenticated using SHARED KEY
-    AS_AUTHENTICATING   // STA is waiting for AUTH seq#3 using SHARED KEY
+	AS_NOT_AUTH,
+	AS_AUTH_OPEN,		// STA has been authenticated using OPEN SYSTEM
+	AS_AUTH_KEY,		// STA has been authenticated using SHARED KEY
+	AS_AUTHENTICATING	// STA is waiting for AUTH seq#3 using SHARED KEY
 } AUTH_STATE;
 
 //for-wpa value domain of pMacEntry->WpaState  802.1i D3   p.114
 typedef enum _ApWpaState {
-    AS_NOTUSE,              // 0
-    AS_DISCONNECT,          // 1
-    AS_DISCONNECTED,        // 2
-    AS_INITIALIZE,          // 3
-    AS_AUTHENTICATION,      // 4
-    AS_AUTHENTICATION2,     // 5
-    AS_INITPMK,             // 6
-    AS_INITPSK,             // 7
-    AS_PTKSTART,            // 8
-    AS_PTKINIT_NEGOTIATING, // 9
-    AS_PTKINITDONE,         // 10
-    AS_UPDATEKEYS,          // 11
-    AS_INTEGRITY_FAILURE,   // 12
-    AS_KEYUPDATE,           // 13
+	AS_NOTUSE,		// 0
+	AS_DISCONNECT,		// 1
+	AS_DISCONNECTED,	// 2
+	AS_INITIALIZE,		// 3
+	AS_AUTHENTICATION,	// 4
+	AS_AUTHENTICATION2,	// 5
+	AS_INITPMK,		// 6
+	AS_INITPSK,		// 7
+	AS_PTKSTART,		// 8
+	AS_PTKINIT_NEGOTIATING,	// 9
+	AS_PTKINITDONE,		// 10
+	AS_UPDATEKEYS,		// 11
+	AS_INTEGRITY_FAILURE,	// 12
+	AS_KEYUPDATE,		// 13
 } AP_WPA_STATE;
 
 // for-wpa value domain of pMacEntry->WpaState  802.1i D3   p.114
 typedef enum _GTKState {
-    REKEY_NEGOTIATING,
-    REKEY_ESTABLISHED,
-    KEYERROR,
+	REKEY_NEGOTIATING,
+	REKEY_ESTABLISHED,
+	KEYERROR,
 } GTK_STATE;
 
 //  for-wpa  value domain of pMacEntry->WpaState  802.1i D3   p.114
 typedef enum _WpaGTKState {
-    SETKEYS,
-    SETKEYS_DONE,
+	SETKEYS,
+	SETKEYS_DONE,
 } WPA_GTK_STATE;
 // ====================== end of AP mlme.h ============================
 
-
-#endif	// MLME_H__
+#endif // MLME_H__
--- a/drivers/staging/rt2860/oid.h
+++ b/drivers/staging/rt2860/oid.h
@@ -48,12 +48,12 @@
 //
 // IEEE 802.11 Structures and definitions
 //
-#define MAX_TX_POWER_LEVEL              100   /* mW */
-#define MAX_RSSI_TRIGGER                -10    /* dBm */
-#define MIN_RSSI_TRIGGER                -200   /* dBm */
-#define MAX_FRAG_THRESHOLD              2346  /* byte count */
-#define MIN_FRAG_THRESHOLD              256   /* byte count */
-#define MAX_RTS_THRESHOLD               2347  /* byte count */
+#define MAX_TX_POWER_LEVEL              100	/* mW */
+#define MAX_RSSI_TRIGGER                -10	/* dBm */
+#define MIN_RSSI_TRIGGER                -200	/* dBm */
+#define MAX_FRAG_THRESHOLD              2346	/* byte count */
+#define MIN_FRAG_THRESHOLD              256	/* byte count */
+#define MAX_RTS_THRESHOLD               2347	/* byte count */
 
 // new types for Media Specific Indications
 // Extension channel offset
@@ -78,15 +78,14 @@
 #define NDIS_802_11_LENGTH_RATES        8
 #define NDIS_802_11_LENGTH_RATES_EX     16
 #define MAC_ADDR_LENGTH                 6
-//#define MAX_NUM_OF_CHS					49 // 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL terminationc
-#define MAX_NUM_OF_CHS				54      // 14 channels @2.4G +  12@UNII(lower/middle) + 16@HiperLAN2 + 11@UNII(upper) + 0 @Japan + 1 as NULL termination
-#define MAX_NUMBER_OF_EVENT				10  // entry # in EVENT table
-#define MAX_NUMBER_OF_MAC				32 // if MAX_MBSSID_NUM is 8, this value can't be larger than 211
+//#define MAX_NUM_OF_CHS                                        49 // 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL terminationc
+#define MAX_NUM_OF_CHS				54	// 14 channels @2.4G +  12@UNII(lower/middle) + 16@HiperLAN2 + 11@UNII(upper) + 0 @Japan + 1 as NULL termination
+#define MAX_NUMBER_OF_EVENT				10	// entry # in EVENT table
+#define MAX_NUMBER_OF_MAC				32	// if MAX_MBSSID_NUM is 8, this value can't be larger than 211
 #define MAX_NUMBER_OF_ACL				64
-#define MAX_LENGTH_OF_SUPPORT_RATES		12    // 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
+#define MAX_LENGTH_OF_SUPPORT_RATES		12	// 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
 #define MAX_NUMBER_OF_DLS_ENTRY			4
 
-
 #define RT_QUERY_SIGNAL_CONTEXT				0x0402
 #define RT_SET_IAPP_PID                 	0x0404
 #define RT_SET_APD_PID						0x0405
@@ -129,19 +128,17 @@
 #define RT_OID_DRIVER_DEVICE_NAME                   0x0645
 #define RT_OID_QUERY_MULTIPLE_CARD_SUPPORT          0x0647
 
-typedef enum _NDIS_802_11_STATUS_TYPE
-{
-    Ndis802_11StatusType_Authentication,
-    Ndis802_11StatusType_MediaStreamMode,
-    Ndis802_11StatusType_PMKID_CandidateList,
-    Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+typedef enum _NDIS_802_11_STATUS_TYPE {
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusTypeMax	// not a real type, defined as an upper bound
 } NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
 
-typedef UCHAR   NDIS_802_11_MAC_ADDRESS[6];
+typedef UCHAR NDIS_802_11_MAC_ADDRESS[6];
 
-typedef struct _NDIS_802_11_STATUS_INDICATION
-{
-    NDIS_802_11_STATUS_TYPE StatusType;
+typedef struct _NDIS_802_11_STATUS_INDICATION {
+	NDIS_802_11_STATUS_TYPE StatusType;
 } NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
 
 // mask for authentication/integrity fields
@@ -152,313 +149,283 @@ typedef struct _NDIS_802_11_STATUS_INDIC
 #define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR     0x06
 #define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR        0x0E
 
-typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
-{
-    ULONG Length;            // Length of structure
-    NDIS_802_11_MAC_ADDRESS Bssid;
-    ULONG Flags;
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST {
+	ULONG Length;		// Length of structure
+	NDIS_802_11_MAC_ADDRESS Bssid;
+	ULONG Flags;
 } NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
 
 //Added new types for PMKID Candidate lists.
 typedef struct _PMKID_CANDIDATE {
-    NDIS_802_11_MAC_ADDRESS BSSID;
-    ULONG Flags;
+	NDIS_802_11_MAC_ADDRESS BSSID;
+	ULONG Flags;
 } PMKID_CANDIDATE, *PPMKID_CANDIDATE;
 
-typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST
-{
-    ULONG Version;       // Version of the structure
-    ULONG NumCandidates; // No. of pmkid candidates
-    PMKID_CANDIDATE CandidateList[1];
+typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST {
+	ULONG Version;		// Version of the structure
+	ULONG NumCandidates;	// No. of pmkid candidates
+	PMKID_CANDIDATE CandidateList[1];
 } NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;
 
 //Flags for PMKID Candidate list structure
 #define NDIS_802_11_PMKID_CANDIDATE_PREAUTH_ENABLED	0x01
 
 // Added new types for OFDM 5G and 2.4G
-typedef enum _NDIS_802_11_NETWORK_TYPE
-{
-   Ndis802_11FH,
-   Ndis802_11DS,
-    Ndis802_11OFDM5,
-    Ndis802_11OFDM24,
-   Ndis802_11Automode,
-    Ndis802_11OFDM5_N,
-    Ndis802_11OFDM24_N,
-    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
+typedef enum _NDIS_802_11_NETWORK_TYPE {
+	Ndis802_11FH,
+	Ndis802_11DS,
+	Ndis802_11OFDM5,
+	Ndis802_11OFDM24,
+	Ndis802_11Automode,
+	Ndis802_11OFDM5_N,
+	Ndis802_11OFDM24_N,
+	Ndis802_11NetworkTypeMax	// not a real type, defined as an upper bound
 } NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
 
-typedef struct _NDIS_802_11_NETWORK_TYPE_LIST
-{
-    UINT                       NumberOfItems;  // in list below, at least 1
-   NDIS_802_11_NETWORK_TYPE    NetworkType [1];
+typedef struct _NDIS_802_11_NETWORK_TYPE_LIST {
+	UINT NumberOfItems;	// in list below, at least 1
+	NDIS_802_11_NETWORK_TYPE NetworkType[1];
 } NDIS_802_11_NETWORK_TYPE_LIST, *PNDIS_802_11_NETWORK_TYPE_LIST;
 
-typedef enum _NDIS_802_11_POWER_MODE
-{
-    Ndis802_11PowerModeCAM,
-    Ndis802_11PowerModeMAX_PSP,
-    Ndis802_11PowerModeFast_PSP,
-    Ndis802_11PowerModeLegacy_PSP,
-    Ndis802_11PowerModeMax      // not a real mode, defined as an upper bound
+typedef enum _NDIS_802_11_POWER_MODE {
+	Ndis802_11PowerModeCAM,
+	Ndis802_11PowerModeMAX_PSP,
+	Ndis802_11PowerModeFast_PSP,
+	Ndis802_11PowerModeLegacy_PSP,
+	Ndis802_11PowerModeMax	// not a real mode, defined as an upper bound
 } NDIS_802_11_POWER_MODE, *PNDIS_802_11_POWER_MODE;
 
-typedef ULONG   NDIS_802_11_TX_POWER_LEVEL; // in milliwatts
+typedef ULONG NDIS_802_11_TX_POWER_LEVEL;	// in milliwatts
 
 //
 // Received Signal Strength Indication
 //
-typedef LONG    NDIS_802_11_RSSI;           // in dBm
+typedef LONG NDIS_802_11_RSSI;	// in dBm
 
-typedef struct _NDIS_802_11_CONFIGURATION_FH
-{
-   ULONG           Length;            // Length of structure
-   ULONG           HopPattern;        // As defined by 802.11, MSB set
-   ULONG           HopSet;            // to one if non-802.11
-   ULONG           DwellTime;         // units are Kusec
+typedef struct _NDIS_802_11_CONFIGURATION_FH {
+	ULONG Length;		// Length of structure
+	ULONG HopPattern;	// As defined by 802.11, MSB set
+	ULONG HopSet;		// to one if non-802.11
+	ULONG DwellTime;	// units are Kusec
 } NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
 
-typedef struct _NDIS_802_11_CONFIGURATION
-{
-   ULONG                           Length;             // Length of structure
-   ULONG                           BeaconPeriod;       // units are Kusec
-   ULONG                           ATIMWindow;         // units are Kusec
-   ULONG                           DSConfig;           // Frequency, units are kHz
-   NDIS_802_11_CONFIGURATION_FH    FHConfig;
+typedef struct _NDIS_802_11_CONFIGURATION {
+	ULONG Length;		// Length of structure
+	ULONG BeaconPeriod;	// units are Kusec
+	ULONG ATIMWindow;	// units are Kusec
+	ULONG DSConfig;		// Frequency, units are kHz
+	NDIS_802_11_CONFIGURATION_FH FHConfig;
 } NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
 
-typedef struct _NDIS_802_11_STATISTICS
-{
-   ULONG           Length;             // Length of structure
-   LARGE_INTEGER   TransmittedFragmentCount;
-   LARGE_INTEGER   MulticastTransmittedFrameCount;
-   LARGE_INTEGER   FailedCount;
-   LARGE_INTEGER   RetryCount;
-   LARGE_INTEGER   MultipleRetryCount;
-   LARGE_INTEGER   RTSSuccessCount;
-   LARGE_INTEGER   RTSFailureCount;
-   LARGE_INTEGER   ACKFailureCount;
-   LARGE_INTEGER   FrameDuplicateCount;
-   LARGE_INTEGER   ReceivedFragmentCount;
-   LARGE_INTEGER   MulticastReceivedFrameCount;
-   LARGE_INTEGER   FCSErrorCount;
-   LARGE_INTEGER   TKIPLocalMICFailures;
-   LARGE_INTEGER   TKIPRemoteMICErrors;
-   LARGE_INTEGER   TKIPICVErrors;
-   LARGE_INTEGER   TKIPCounterMeasuresInvoked;
-   LARGE_INTEGER   TKIPReplays;
-   LARGE_INTEGER   CCMPFormatErrors;
-   LARGE_INTEGER   CCMPReplays;
-   LARGE_INTEGER   CCMPDecryptErrors;
-   LARGE_INTEGER   FourWayHandshakeFailures;
+typedef struct _NDIS_802_11_STATISTICS {
+	ULONG Length;		// Length of structure
+	LARGE_INTEGER TransmittedFragmentCount;
+	LARGE_INTEGER MulticastTransmittedFrameCount;
+	LARGE_INTEGER FailedCount;
+	LARGE_INTEGER RetryCount;
+	LARGE_INTEGER MultipleRetryCount;
+	LARGE_INTEGER RTSSuccessCount;
+	LARGE_INTEGER RTSFailureCount;
+	LARGE_INTEGER ACKFailureCount;
+	LARGE_INTEGER FrameDuplicateCount;
+	LARGE_INTEGER ReceivedFragmentCount;
+	LARGE_INTEGER MulticastReceivedFrameCount;
+	LARGE_INTEGER FCSErrorCount;
+	LARGE_INTEGER TKIPLocalMICFailures;
+	LARGE_INTEGER TKIPRemoteMICErrors;
+	LARGE_INTEGER TKIPICVErrors;
+	LARGE_INTEGER TKIPCounterMeasuresInvoked;
+	LARGE_INTEGER TKIPReplays;
+	LARGE_INTEGER CCMPFormatErrors;
+	LARGE_INTEGER CCMPReplays;
+	LARGE_INTEGER CCMPDecryptErrors;
+	LARGE_INTEGER FourWayHandshakeFailures;
 } NDIS_802_11_STATISTICS, *PNDIS_802_11_STATISTICS;
 
-typedef  ULONG  NDIS_802_11_KEY_INDEX;
-typedef ULONGLONG   NDIS_802_11_KEY_RSC;
+typedef ULONG NDIS_802_11_KEY_INDEX;
+typedef ULONGLONG NDIS_802_11_KEY_RSC;
 
-#define MAX_RADIUS_SRV_NUM			2	  // 802.1x failover number
+#define MAX_RADIUS_SRV_NUM			2	// 802.1x failover number
 
 typedef struct PACKED _RADIUS_SRV_INFO {
-	UINT32			radius_ip;
-	UINT32			radius_port;
-	UCHAR			radius_key[64];
-	UCHAR			radius_key_len;
+	UINT32 radius_ip;
+	UINT32 radius_port;
+	UCHAR radius_key[64];
+	UCHAR radius_key_len;
 } RADIUS_SRV_INFO, *PRADIUS_SRV_INFO;
 
-typedef struct PACKED _RADIUS_KEY_INFO
-{
-	UCHAR			radius_srv_num;
-	RADIUS_SRV_INFO	radius_srv_info[MAX_RADIUS_SRV_NUM];
-	UCHAR			ieee8021xWEP;		 // dynamic WEP
-    UCHAR           key_index;
-    UCHAR           key_length;          // length of key in bytes
-    UCHAR           key_material[13];
+typedef struct PACKED _RADIUS_KEY_INFO {
+	UCHAR radius_srv_num;
+	RADIUS_SRV_INFO radius_srv_info[MAX_RADIUS_SRV_NUM];
+	UCHAR ieee8021xWEP;	// dynamic WEP
+	UCHAR key_index;
+	UCHAR key_length;	// length of key in bytes
+	UCHAR key_material[13];
 } RADIUS_KEY_INFO, *PRADIUS_KEY_INFO;
 
 // It's used by 802.1x daemon to require relative configuration
-typedef struct PACKED _RADIUS_CONF
-{
-    UINT32          Length;             // Length of this structure
-    UCHAR			mbss_num;			// indicate multiple BSS number
-	UINT32			own_ip_addr;
-	UINT32			retry_interval;
-	UINT32			session_timeout_interval;
-	UCHAR			EAPifname[8][IFNAMSIZ];
-	UCHAR			EAPifname_len[8];
-	UCHAR			PreAuthifname[8][IFNAMSIZ];
-	UCHAR			PreAuthifname_len[8];
-	RADIUS_KEY_INFO	RadiusInfo[8];
+typedef struct PACKED _RADIUS_CONF {
+	UINT32 Length;		// Length of this structure
+	UCHAR mbss_num;		// indicate multiple BSS number
+	UINT32 own_ip_addr;
+	UINT32 retry_interval;
+	UINT32 session_timeout_interval;
+	UCHAR EAPifname[8][IFNAMSIZ];
+	UCHAR EAPifname_len[8];
+	UCHAR PreAuthifname[8][IFNAMSIZ];
+	UCHAR PreAuthifname_len[8];
+	RADIUS_KEY_INFO RadiusInfo[8];
 } RADIUS_CONF, *PRADIUS_CONF;
 
-
-
 // Key mapping keys require a BSSID
-typedef struct _NDIS_802_11_KEY
-{
-    UINT           Length;             // Length of this structure
-    UINT           KeyIndex;
-    UINT           KeyLength;          // length of key in bytes
-    NDIS_802_11_MAC_ADDRESS BSSID;
-    NDIS_802_11_KEY_RSC KeyRSC;
-    UCHAR           KeyMaterial[1];     // variable length depending on above field
+typedef struct _NDIS_802_11_KEY {
+	UINT Length;		// Length of this structure
+	UINT KeyIndex;
+	UINT KeyLength;		// length of key in bytes
+	NDIS_802_11_MAC_ADDRESS BSSID;
+	NDIS_802_11_KEY_RSC KeyRSC;
+	UCHAR KeyMaterial[1];	// variable length depending on above field
 } NDIS_802_11_KEY, *PNDIS_802_11_KEY;
 
-typedef struct _NDIS_802_11_PASSPHRASE
-{
-    UINT           KeyLength;          // length of key in bytes
-    NDIS_802_11_MAC_ADDRESS BSSID;
-    UCHAR           KeyMaterial[1];     // variable length depending on above field
+typedef struct _NDIS_802_11_PASSPHRASE {
+	UINT KeyLength;		// length of key in bytes
+	NDIS_802_11_MAC_ADDRESS BSSID;
+	UCHAR KeyMaterial[1];	// variable length depending on above field
 } NDIS_802_11_PASSPHRASE, *PNDIS_802_11_PASSPHRASE;
 
-typedef struct _NDIS_802_11_REMOVE_KEY
-{
-    UINT           Length;             // Length of this structure
-    UINT           KeyIndex;
-    NDIS_802_11_MAC_ADDRESS BSSID;
+typedef struct _NDIS_802_11_REMOVE_KEY {
+	UINT Length;		// Length of this structure
+	UINT KeyIndex;
+	NDIS_802_11_MAC_ADDRESS BSSID;
 } NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
 
-typedef struct _NDIS_802_11_WEP
-{
-   UINT     Length;        // Length of this structure
-   UINT     KeyIndex;           // 0 is the per-client key, 1-N are the
-                                        // global keys
-   UINT     KeyLength;     // length of key in bytes
-   UCHAR     KeyMaterial[1];// variable length depending on above field
+typedef struct _NDIS_802_11_WEP {
+	UINT Length;		// Length of this structure
+	UINT KeyIndex;		// 0 is the per-client key, 1-N are the
+	// global keys
+	UINT KeyLength;		// length of key in bytes
+	UCHAR KeyMaterial[1];	// variable length depending on above field
 } NDIS_802_11_WEP, *PNDIS_802_11_WEP;
 
-
-typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
-{
-   Ndis802_11IBSS,
-   Ndis802_11Infrastructure,
-   Ndis802_11AutoUnknown,
-   Ndis802_11Monitor,
-   Ndis802_11InfrastructureMax     // Not a real value, defined as upper bound
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE {
+	Ndis802_11IBSS,
+	Ndis802_11Infrastructure,
+	Ndis802_11AutoUnknown,
+	Ndis802_11Monitor,
+	Ndis802_11InfrastructureMax	// Not a real value, defined as upper bound
 } NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
 
 // Add new authentication modes
-typedef enum _NDIS_802_11_AUTHENTICATION_MODE
-{
-   Ndis802_11AuthModeOpen,
-   Ndis802_11AuthModeShared,
-   Ndis802_11AuthModeAutoSwitch,
-    Ndis802_11AuthModeWPA,
-    Ndis802_11AuthModeWPAPSK,
-    Ndis802_11AuthModeWPANone,
-   Ndis802_11AuthModeWPA2,
-   Ndis802_11AuthModeWPA2PSK,
-   	Ndis802_11AuthModeWPA1WPA2,
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE {
+	Ndis802_11AuthModeOpen,
+	Ndis802_11AuthModeShared,
+	Ndis802_11AuthModeAutoSwitch,
+	Ndis802_11AuthModeWPA,
+	Ndis802_11AuthModeWPAPSK,
+	Ndis802_11AuthModeWPANone,
+	Ndis802_11AuthModeWPA2,
+	Ndis802_11AuthModeWPA2PSK,
+	Ndis802_11AuthModeWPA1WPA2,
 	Ndis802_11AuthModeWPA1PSKWPA2PSK,
-   Ndis802_11AuthModeMax           // Not a real mode, defined as upper bound
+	Ndis802_11AuthModeMax	// Not a real mode, defined as upper bound
 } NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
 
-typedef UCHAR   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
-typedef UCHAR   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
+typedef UCHAR NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];	// Set of 8 data rates
+typedef UCHAR NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];	// Set of 16 data rates
 
-typedef struct PACKED _NDIS_802_11_SSID
-{
-    UINT   SsidLength;         // length of SSID field below, in bytes;
-                                // this can be zero.
-    UCHAR   Ssid[NDIS_802_11_LENGTH_SSID];           // SSID information field
+typedef struct PACKED _NDIS_802_11_SSID {
+	UINT SsidLength;	// length of SSID field below, in bytes;
+	// this can be zero.
+	UCHAR Ssid[NDIS_802_11_LENGTH_SSID];	// SSID information field
 } NDIS_802_11_SSID, *PNDIS_802_11_SSID;
 
-
-typedef struct PACKED _NDIS_WLAN_BSSID
-{
-   ULONG                               Length;     // Length of this structure
-   NDIS_802_11_MAC_ADDRESS             MacAddress; // BSSID
-   UCHAR                               Reserved[2];
-   NDIS_802_11_SSID                    Ssid;       // SSID
-   ULONG                               Privacy;    // WEP encryption requirement
-   NDIS_802_11_RSSI                    Rssi;       // receive signal strength in dBm
-   NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
-   NDIS_802_11_CONFIGURATION           Configuration;
-   NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
-   NDIS_802_11_RATES                   SupportedRates;
+typedef struct PACKED _NDIS_WLAN_BSSID {
+	ULONG Length;		// Length of this structure
+	NDIS_802_11_MAC_ADDRESS MacAddress;	// BSSID
+	UCHAR Reserved[2];
+	NDIS_802_11_SSID Ssid;	// SSID
+	ULONG Privacy;		// WEP encryption requirement
+	NDIS_802_11_RSSI Rssi;	// receive signal strength in dBm
+	NDIS_802_11_NETWORK_TYPE NetworkTypeInUse;
+	NDIS_802_11_CONFIGURATION Configuration;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
+	NDIS_802_11_RATES SupportedRates;
 } NDIS_WLAN_BSSID, *PNDIS_WLAN_BSSID;
 
-typedef struct PACKED _NDIS_802_11_BSSID_LIST
-{
-   UINT           NumberOfItems;      // in list below, at least 1
-   NDIS_WLAN_BSSID Bssid[1];
+typedef struct PACKED _NDIS_802_11_BSSID_LIST {
+	UINT NumberOfItems;	// in list below, at least 1
+	NDIS_WLAN_BSSID Bssid[1];
 } NDIS_802_11_BSSID_LIST, *PNDIS_802_11_BSSID_LIST;
 
 // Added Capabilities, IELength and IEs for each BSSID
-typedef struct PACKED _NDIS_WLAN_BSSID_EX
-{
-    ULONG                               Length;             // Length of this structure
-    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
-    UCHAR                               Reserved[2];
-    NDIS_802_11_SSID                    Ssid;               // SSID
-    UINT                                Privacy;            // WEP encryption requirement
-    NDIS_802_11_RSSI                    Rssi;               // receive signal
-                                                            // strength in dBm
-    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
-    NDIS_802_11_CONFIGURATION           Configuration;
-    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
-    NDIS_802_11_RATES_EX                SupportedRates;
-    ULONG                               IELength;
-    UCHAR                               IEs[1];
+typedef struct PACKED _NDIS_WLAN_BSSID_EX {
+	ULONG Length;		// Length of this structure
+	NDIS_802_11_MAC_ADDRESS MacAddress;	// BSSID
+	UCHAR Reserved[2];
+	NDIS_802_11_SSID Ssid;	// SSID
+	UINT Privacy;		// WEP encryption requirement
+	NDIS_802_11_RSSI Rssi;	// receive signal
+	// strength in dBm
+	NDIS_802_11_NETWORK_TYPE NetworkTypeInUse;
+	NDIS_802_11_CONFIGURATION Configuration;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
+	NDIS_802_11_RATES_EX SupportedRates;
+	ULONG IELength;
+	UCHAR IEs[1];
 } NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;
 
-typedef struct PACKED _NDIS_802_11_BSSID_LIST_EX
-{
-    UINT                   NumberOfItems;      // in list below, at least 1
-    NDIS_WLAN_BSSID_EX      Bssid[1];
+typedef struct PACKED _NDIS_802_11_BSSID_LIST_EX {
+	UINT NumberOfItems;	// in list below, at least 1
+	NDIS_WLAN_BSSID_EX Bssid[1];
 } NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;
 
-typedef struct PACKED _NDIS_802_11_FIXED_IEs
-{
-    UCHAR Timestamp[8];
-    USHORT BeaconInterval;
-    USHORT Capabilities;
+typedef struct PACKED _NDIS_802_11_FIXED_IEs {
+	UCHAR Timestamp[8];
+	USHORT BeaconInterval;
+	USHORT Capabilities;
 } NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
 
-typedef struct _NDIS_802_11_VARIABLE_IEs
-{
-    UCHAR ElementID;
-    UCHAR Length;    // Number of bytes in data field
-    UCHAR data[1];
+typedef struct _NDIS_802_11_VARIABLE_IEs {
+	UCHAR ElementID;
+	UCHAR Length;		// Number of bytes in data field
+	UCHAR data[1];
 } NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
 
-typedef  ULONG   NDIS_802_11_FRAGMENTATION_THRESHOLD;
+typedef ULONG NDIS_802_11_FRAGMENTATION_THRESHOLD;
 
-typedef  ULONG   NDIS_802_11_RTS_THRESHOLD;
+typedef ULONG NDIS_802_11_RTS_THRESHOLD;
 
-typedef  ULONG   NDIS_802_11_ANTENNA;
+typedef ULONG NDIS_802_11_ANTENNA;
 
-typedef enum _NDIS_802_11_PRIVACY_FILTER
-{
-   Ndis802_11PrivFilterAcceptAll,
-   Ndis802_11PrivFilter8021xWEP
+typedef enum _NDIS_802_11_PRIVACY_FILTER {
+	Ndis802_11PrivFilterAcceptAll,
+	Ndis802_11PrivFilter8021xWEP
 } NDIS_802_11_PRIVACY_FILTER, *PNDIS_802_11_PRIVACY_FILTER;
 
 // Added new encryption types
 // Also aliased typedef to new name
-typedef enum _NDIS_802_11_WEP_STATUS
-{
-   Ndis802_11WEPEnabled,
-    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
-   Ndis802_11WEPDisabled,
-    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
-   Ndis802_11WEPKeyAbsent,
-    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
-   Ndis802_11WEPNotSupported,
-    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
-    Ndis802_11Encryption2Enabled,
-    Ndis802_11Encryption2KeyAbsent,
-    Ndis802_11Encryption3Enabled,
-    Ndis802_11Encryption3KeyAbsent,
-    Ndis802_11Encryption4Enabled,	// TKIP or AES mix
-    Ndis802_11Encryption4KeyAbsent,
-    Ndis802_11GroupWEP40Enabled,
+typedef enum _NDIS_802_11_WEP_STATUS {
+	Ndis802_11WEPEnabled,
+	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+	Ndis802_11WEPDisabled,
+	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+	Ndis802_11WEPKeyAbsent,
+	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+	Ndis802_11WEPNotSupported,
+	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+	Ndis802_11Encryption2Enabled,
+	Ndis802_11Encryption2KeyAbsent,
+	Ndis802_11Encryption3Enabled,
+	Ndis802_11Encryption3KeyAbsent,
+	Ndis802_11Encryption4Enabled,	// TKIP or AES mix
+	Ndis802_11Encryption4KeyAbsent,
+	Ndis802_11GroupWEP40Enabled,
 	Ndis802_11GroupWEP104Enabled,
 } NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
-  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+    NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
 
-typedef enum _NDIS_802_11_RELOAD_DEFAULTS
-{
-   Ndis802_11ReloadWEPKeys
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS {
+	Ndis802_11ReloadWEPKeys
 } NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
 
 #define NDIS_802_11_AI_REQFI_CAPABILITIES      1
@@ -469,122 +436,110 @@ typedef enum _NDIS_802_11_RELOAD_DEFAULT
 #define NDIS_802_11_AI_RESFI_STATUSCODE        2
 #define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
 
-typedef struct _NDIS_802_11_AI_REQFI
-{
-    USHORT Capabilities;
-    USHORT ListenInterval;
-    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+typedef struct _NDIS_802_11_AI_REQFI {
+	USHORT Capabilities;
+	USHORT ListenInterval;
+	NDIS_802_11_MAC_ADDRESS CurrentAPAddress;
 } NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
 
-typedef struct _NDIS_802_11_AI_RESFI
-{
-    USHORT Capabilities;
-    USHORT StatusCode;
-    USHORT AssociationId;
+typedef struct _NDIS_802_11_AI_RESFI {
+	USHORT Capabilities;
+	USHORT StatusCode;
+	USHORT AssociationId;
 } NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
 
-typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
-{
-    ULONG                   Length;
-    USHORT                  AvailableRequestFixedIEs;
-    NDIS_802_11_AI_REQFI    RequestFixedIEs;
-    ULONG                   RequestIELength;
-    ULONG                   OffsetRequestIEs;
-    USHORT                  AvailableResponseFixedIEs;
-    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
-    ULONG                   ResponseIELength;
-    ULONG                   OffsetResponseIEs;
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION {
+	ULONG Length;
+	USHORT AvailableRequestFixedIEs;
+	NDIS_802_11_AI_REQFI RequestFixedIEs;
+	ULONG RequestIELength;
+	ULONG OffsetRequestIEs;
+	USHORT AvailableResponseFixedIEs;
+	NDIS_802_11_AI_RESFI ResponseFixedIEs;
+	ULONG ResponseIELength;
+	ULONG OffsetResponseIEs;
 } NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
 
-typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
-{
-    NDIS_802_11_STATUS_INDICATION       Status;
-    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT {
+	NDIS_802_11_STATUS_INDICATION Status;
+	NDIS_802_11_AUTHENTICATION_REQUEST Request[1];
 } NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
 
 // 802.11 Media stream constraints, associated with OID_802_11_MEDIA_STREAM_MODE
-typedef enum _NDIS_802_11_MEDIA_STREAM_MODE
-{
-    Ndis802_11MediaStreamOff,
-    Ndis802_11MediaStreamOn,
+typedef enum _NDIS_802_11_MEDIA_STREAM_MODE {
+	Ndis802_11MediaStreamOff,
+	Ndis802_11MediaStreamOn,
 } NDIS_802_11_MEDIA_STREAM_MODE, *PNDIS_802_11_MEDIA_STREAM_MODE;
 
 // PMKID Structures
-typedef UCHAR   NDIS_802_11_PMKID_VALUE[16];
+typedef UCHAR NDIS_802_11_PMKID_VALUE[16];
 
-typedef struct _BSSID_INFO
-{
-    NDIS_802_11_MAC_ADDRESS BSSID;
-    NDIS_802_11_PMKID_VALUE PMKID;
+typedef struct _BSSID_INFO {
+	NDIS_802_11_MAC_ADDRESS BSSID;
+	NDIS_802_11_PMKID_VALUE PMKID;
 } BSSID_INFO, *PBSSID_INFO;
 
-typedef struct _NDIS_802_11_PMKID
-{
-    UINT    Length;
-    UINT    BSSIDInfoCount;
-    BSSID_INFO BSSIDInfo[1];
+typedef struct _NDIS_802_11_PMKID {
+	UINT Length;
+	UINT BSSIDInfoCount;
+	BSSID_INFO BSSIDInfo[1];
 } NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;
 
-typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION
-{
-    NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
-    NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
-} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
-
-typedef struct _NDIS_802_11_CAPABILITY
-{
-     ULONG Length;
-     ULONG Version;
-     ULONG NoOfPMKIDs;
-     ULONG NoOfAuthEncryptPairsSupported;
-     NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
+typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION {
+	NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
+	NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
+} NDIS_802_11_AUTHENTICATION_ENCRYPTION,
+    *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
+
+typedef struct _NDIS_802_11_CAPABILITY {
+	ULONG Length;
+	ULONG Version;
+	ULONG NoOfPMKIDs;
+	ULONG NoOfAuthEncryptPairsSupported;
+	NDIS_802_11_AUTHENTICATION_ENCRYPTION
+	    AuthenticationEncryptionSupported[1];
 } NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;
 
-#define RT_PRIV_IOCTL							(SIOCIWFIRSTPRIV + 0x01) // Sync. with AP for wsc upnp daemon
+#define RT_PRIV_IOCTL							(SIOCIWFIRSTPRIV + 0x01)	// Sync. with AP for wsc upnp daemon
 #define RTPRIV_IOCTL_SET							(SIOCIWFIRSTPRIV + 0x02)
 
 #define RTPRIV_IOCTL_STATISTICS                     (SIOCIWFIRSTPRIV + 0x09)
 #define RTPRIV_IOCTL_ADD_PMKID_CACHE                (SIOCIWFIRSTPRIV + 0x0A)
 #define RTPRIV_IOCTL_RADIUS_DATA                    (SIOCIWFIRSTPRIV + 0x0C)
 #define RTPRIV_IOCTL_GSITESURVEY					(SIOCIWFIRSTPRIV + 0x0D)
-#define RT_PRIV_IOCTL_EXT							(SIOCIWFIRSTPRIV + 0x0E) // Sync. with RT61 (for wpa_supplicant)
+#define RT_PRIV_IOCTL_EXT							(SIOCIWFIRSTPRIV + 0x0E)	// Sync. with RT61 (for wpa_supplicant)
 #define RTPRIV_IOCTL_GET_MAC_TABLE					(SIOCIWFIRSTPRIV + 0x0F)
 
 #define RTPRIV_IOCTL_SHOW							(SIOCIWFIRSTPRIV + 0x11)
 enum {
-    SHOW_CONN_STATUS = 4,
-    SHOW_DRVIER_VERION = 5,
-    SHOW_BA_INFO = 6,
+	SHOW_CONN_STATUS = 4,
+	SHOW_DRVIER_VERION = 5,
+	SHOW_BA_INFO = 6,
 	SHOW_DESC_INFO = 7,
 #ifdef RTMP_MAC_USB
 	SHOW_RXBULK_INFO = 8,
 	SHOW_TXBULK_INFO = 9,
 #endif // RTMP_MAC_USB //
-    RAIO_OFF = 10,
-    RAIO_ON = 11,
+	RAIO_OFF = 10,
+	RAIO_ON = 11,
 	SHOW_CFG_VALUE = 20,
 	SHOW_ADHOC_ENTRY_INFO = 21,
 };
 
-
-
-
-
-
 #define OID_802_11_BUILD_CHANNEL_EX				0x0714
 #define OID_802_11_GET_CH_LIST					0x0715
 #define OID_802_11_GET_COUNTRY_CODE				0x0716
 #define OID_802_11_GET_CHANNEL_GEOGRAPHY		0x0717
 
-#define RT_OID_WSC_SET_PASSPHRASE                   0x0740 // passphrase for wpa(2)-psk
+#define RT_OID_WSC_SET_PASSPHRASE                   0x0740	// passphrase for wpa(2)-psk
 #define RT_OID_WSC_DRIVER_AUTO_CONNECT              0x0741
 #define RT_OID_WSC_QUERY_DEFAULT_PROFILE            0x0742
 #define RT_OID_WSC_SET_CONN_BY_PROFILE_INDEX        0x0743
 #define RT_OID_WSC_SET_ACTION                       0x0744
 #define RT_OID_WSC_SET_SSID                         0x0745
 #define RT_OID_WSC_SET_PIN_CODE                     0x0746
-#define RT_OID_WSC_SET_MODE                         0x0747 // PIN or PBC
-#define RT_OID_WSC_SET_CONF_MODE                    0x0748 // Enrollee or Registrar
+#define RT_OID_WSC_SET_MODE                         0x0747	// PIN or PBC
+#define RT_OID_WSC_SET_CONF_MODE                    0x0748	// Enrollee or Registrar
 #define RT_OID_WSC_SET_PROFILE                      0x0749
 #define	RT_OID_WSC_CONFIG_STATUS					0x074F
 #define RT_OID_802_11_WSC_QUERY_PROFILE				0x0750
@@ -604,24 +559,24 @@ enum {
 #define OID_MH_802_1X_SUPPORTED               0xFFEDC100
 
 // MIMO Tx parameter, ShortGI, MCS, STBC, etc.  these are fields in TXWI. Don't change this definition!!!
-typedef union  _HTTRANSMIT_SETTING {
-	struct	{
-	USHORT   	MCS:7;                 // MCS
-	USHORT		BW:1;	//channel bandwidth 20MHz or 40 MHz
-	USHORT		ShortGI:1;
-	USHORT		STBC:2;	//SPACE
-//	USHORT		rsv:3;
-	USHORT		rsv:2;
-	USHORT		TxBF:1;
-	USHORT		MODE:2;	// Use definition MODE_xxx.
-	}	field;
-	USHORT		word;
- } HTTRANSMIT_SETTING, *PHTTRANSMIT_SETTING;
+typedef union _HTTRANSMIT_SETTING {
+	struct {
+		USHORT MCS:7;	// MCS
+		USHORT BW:1;	//channel bandwidth 20MHz or 40 MHz
+		USHORT ShortGI:1;
+		USHORT STBC:2;	//SPACE
+//      USHORT          rsv:3;
+		USHORT rsv:2;
+		USHORT TxBF:1;
+		USHORT MODE:2;	// Use definition MODE_xxx.
+	} field;
+	USHORT word;
+} HTTRANSMIT_SETTING, *PHTTRANSMIT_SETTING;
 
 typedef enum _RT_802_11_PREAMBLE {
-    Rt802_11PreambleLong,
-    Rt802_11PreambleShort,
-    Rt802_11PreambleAuto
+	Rt802_11PreambleLong,
+	Rt802_11PreambleShort,
+	Rt802_11PreambleAuto
 } RT_802_11_PREAMBLE, *PRT_802_11_PREAMBLE;
 
 typedef enum _RT_802_11_PHY_MODE {
@@ -631,200 +586,194 @@ typedef enum _RT_802_11_PHY_MODE {
 	PHY_11ABG_MIXED,
 	PHY_11G,
 	PHY_11ABGN_MIXED,	// both band   5
-	PHY_11N_2_4G,		// 11n-only with 2.4G band   	6
-	PHY_11GN_MIXED,	// 2.4G band      7
-	PHY_11AN_MIXED,	// 5G  band       8
+	PHY_11N_2_4G,		// 11n-only with 2.4G band      6
+	PHY_11GN_MIXED,		// 2.4G band      7
+	PHY_11AN_MIXED,		// 5G  band       8
 	PHY_11BGN_MIXED,	// if check 802.11b.      9
 	PHY_11AGN_MIXED,	// if check 802.11b.      10
-	PHY_11N_5G,			// 11n-only with 5G band		11
+	PHY_11N_5G,		// 11n-only with 5G band                11
 } RT_802_11_PHY_MODE;
 
 // put all proprietery for-query objects here to reduce # of Query_OID
 typedef struct _RT_802_11_LINK_STATUS {
-    ULONG   CurrTxRate;         // in units of 0.5Mbps
-    ULONG   ChannelQuality;     // 0..100 %
-    ULONG   TxByteCount;        // both ok and fail
-    ULONG   RxByteCount;        // both ok and fail
-    ULONG	CentralChannel;		// 40MHz central channel number
+	ULONG CurrTxRate;	// in units of 0.5Mbps
+	ULONG ChannelQuality;	// 0..100 %
+	ULONG TxByteCount;	// both ok and fail
+	ULONG RxByteCount;	// both ok and fail
+	ULONG CentralChannel;	// 40MHz central channel number
 } RT_802_11_LINK_STATUS, *PRT_802_11_LINK_STATUS;
 
 typedef struct _RT_802_11_EVENT_LOG {
-    LARGE_INTEGER   SystemTime;  // timestammp via NdisGetCurrentSystemTime()
-    UCHAR           Addr[MAC_ADDR_LENGTH];
-    USHORT          Event;       // EVENT_xxx
+	LARGE_INTEGER SystemTime;	// timestammp via NdisGetCurrentSystemTime()
+	UCHAR Addr[MAC_ADDR_LENGTH];
+	USHORT Event;		// EVENT_xxx
 } RT_802_11_EVENT_LOG, *PRT_802_11_EVENT_LOG;
 
 typedef struct _RT_802_11_EVENT_TABLE {
-    ULONG       Num;
-    ULONG       Rsv;     // to align Log[] at LARGE_INEGER boundary
-    RT_802_11_EVENT_LOG   Log[MAX_NUMBER_OF_EVENT];
+	ULONG Num;
+	ULONG Rsv;		// to align Log[] at LARGE_INEGER boundary
+	RT_802_11_EVENT_LOG Log[MAX_NUMBER_OF_EVENT];
 } RT_802_11_EVENT_TABLE, PRT_802_11_EVENT_TABLE;
 
 // MIMO Tx parameter, ShortGI, MCS, STBC, etc.  these are fields in TXWI. Don't change this definition!!!
-typedef union  _MACHTTRANSMIT_SETTING {
-	struct	{
-	USHORT   	MCS:7;                 // MCS
-	USHORT		BW:1;	//channel bandwidth 20MHz or 40 MHz
-	USHORT		ShortGI:1;
-	USHORT		STBC:2;	//SPACE
-	USHORT		rsv:3;
-	USHORT		MODE:2;	// Use definition MODE_xxx.
-	}	field;
-	USHORT		word;
- } MACHTTRANSMIT_SETTING, *PMACHTTRANSMIT_SETTING;
+typedef union _MACHTTRANSMIT_SETTING {
+	struct {
+		USHORT MCS:7;	// MCS
+		USHORT BW:1;	//channel bandwidth 20MHz or 40 MHz
+		USHORT ShortGI:1;
+		USHORT STBC:2;	//SPACE
+		USHORT rsv:3;
+		USHORT MODE:2;	// Use definition MODE_xxx.
+	} field;
+	USHORT word;
+} MACHTTRANSMIT_SETTING, *PMACHTTRANSMIT_SETTING;
 
 typedef struct _RT_802_11_MAC_ENTRY {
-    UCHAR       Addr[MAC_ADDR_LENGTH];
-    UCHAR       Aid;
-    UCHAR       Psm;     // 0:PWR_ACTIVE, 1:PWR_SAVE
-    UCHAR		MimoPs;  // 0:MMPS_STATIC, 1:MMPS_DYNAMIC, 3:MMPS_Enabled
-    CHAR		AvgRssi0;
-	CHAR		AvgRssi1;
-	CHAR		AvgRssi2;
-	UINT32		ConnectedTime;
-    MACHTTRANSMIT_SETTING	TxRate;
+	UCHAR Addr[MAC_ADDR_LENGTH];
+	UCHAR Aid;
+	UCHAR Psm;		// 0:PWR_ACTIVE, 1:PWR_SAVE
+	UCHAR MimoPs;		// 0:MMPS_STATIC, 1:MMPS_DYNAMIC, 3:MMPS_Enabled
+	CHAR AvgRssi0;
+	CHAR AvgRssi1;
+	CHAR AvgRssi2;
+	UINT32 ConnectedTime;
+	MACHTTRANSMIT_SETTING TxRate;
 } RT_802_11_MAC_ENTRY, *PRT_802_11_MAC_ENTRY;
 
 typedef struct _RT_802_11_MAC_TABLE {
-    ULONG       Num;
-    RT_802_11_MAC_ENTRY Entry[MAX_NUMBER_OF_MAC];
+	ULONG Num;
+	RT_802_11_MAC_ENTRY Entry[MAX_NUMBER_OF_MAC];
 } RT_802_11_MAC_TABLE, *PRT_802_11_MAC_TABLE;
 
 // structure for query/set hardware register - MAC, BBP, RF register
 typedef struct _RT_802_11_HARDWARE_REGISTER {
-    ULONG   HardwareType;       // 0:MAC, 1:BBP, 2:RF register, 3:EEPROM
-    ULONG   Offset;             // Q/S register offset addr
-    ULONG   Data;               // R/W data buffer
+	ULONG HardwareType;	// 0:MAC, 1:BBP, 2:RF register, 3:EEPROM
+	ULONG Offset;		// Q/S register offset addr
+	ULONG Data;		// R/W data buffer
 } RT_802_11_HARDWARE_REGISTER, *PRT_802_11_HARDWARE_REGISTER;
 
 typedef struct _RT_802_11_AP_CONFIG {
-    ULONG   EnableTxBurst;      // 0-disable, 1-enable
-    ULONG   EnableTurboRate;    // 0-disable, 1-enable 72/100mbps turbo rate
-    ULONG   IsolateInterStaTraffic;     // 0-disable, 1-enable isolation
-    ULONG   HideSsid;           // 0-disable, 1-enable hiding
-    ULONG   UseBGProtection;    // 0-AUTO, 1-always ON, 2-always OFF
-    ULONG   UseShortSlotTime;   // 0-no use, 1-use 9-us short slot time
-    ULONG   Rsv1;               // must be 0
-    ULONG   SystemErrorBitmap;  // ignore upon SET, return system error upon QUERY
+	ULONG EnableTxBurst;	// 0-disable, 1-enable
+	ULONG EnableTurboRate;	// 0-disable, 1-enable 72/100mbps turbo rate
+	ULONG IsolateInterStaTraffic;	// 0-disable, 1-enable isolation
+	ULONG HideSsid;		// 0-disable, 1-enable hiding
+	ULONG UseBGProtection;	// 0-AUTO, 1-always ON, 2-always OFF
+	ULONG UseShortSlotTime;	// 0-no use, 1-use 9-us short slot time
+	ULONG Rsv1;		// must be 0
+	ULONG SystemErrorBitmap;	// ignore upon SET, return system error upon QUERY
 } RT_802_11_AP_CONFIG, *PRT_802_11_AP_CONFIG;
 
 // structure to query/set STA_CONFIG
 typedef struct _RT_802_11_STA_CONFIG {
-    ULONG   EnableTxBurst;      // 0-disable, 1-enable
-    ULONG   EnableTurboRate;    // 0-disable, 1-enable 72/100mbps turbo rate
-    ULONG   UseBGProtection;    // 0-AUTO, 1-always ON, 2-always OFF
-    ULONG   UseShortSlotTime;   // 0-no use, 1-use 9-us short slot time when applicable
-    ULONG   AdhocMode; 			// 0-11b rates only (WIFI spec), 1 - b/g mixed, 2 - g only
-    ULONG   HwRadioStatus;      // 0-OFF, 1-ON, default is 1, Read-Only
-    ULONG   Rsv1;               // must be 0
-    ULONG   SystemErrorBitmap;  // ignore upon SET, return system error upon QUERY
+	ULONG EnableTxBurst;	// 0-disable, 1-enable
+	ULONG EnableTurboRate;	// 0-disable, 1-enable 72/100mbps turbo rate
+	ULONG UseBGProtection;	// 0-AUTO, 1-always ON, 2-always OFF
+	ULONG UseShortSlotTime;	// 0-no use, 1-use 9-us short slot time when applicable
+	ULONG AdhocMode;	// 0-11b rates only (WIFI spec), 1 - b/g mixed, 2 - g only
+	ULONG HwRadioStatus;	// 0-OFF, 1-ON, default is 1, Read-Only
+	ULONG Rsv1;		// must be 0
+	ULONG SystemErrorBitmap;	// ignore upon SET, return system error upon QUERY
 } RT_802_11_STA_CONFIG, *PRT_802_11_STA_CONFIG;
 
 //
 //  For OID Query or Set about BA structure
 //
-typedef	struct	_OID_BACAP_STRUC	{
-		UCHAR		RxBAWinLimit;
-		UCHAR		TxBAWinLimit;
-		UCHAR		Policy;	// 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use. other value invalid
-		UCHAR		MpduDensity;	// 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use. other value invalid
-		UCHAR       	AmsduEnable;	//Enable AMSDU transmisstion
-		UCHAR       	AmsduSize;	// 0:3839, 1:7935 bytes. UINT  MSDUSizeToBytes[]	= { 3839, 7935};
-		UCHAR       	MMPSmode;	// MIMO power save more, 0:static, 1:dynamic, 2:rsv, 3:mimo enable
-		BOOLEAN		AutoBA;	// Auto BA will automatically
+typedef struct _OID_BACAP_STRUC {
+	UCHAR RxBAWinLimit;
+	UCHAR TxBAWinLimit;
+	UCHAR Policy;		// 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use. other value invalid
+	UCHAR MpduDensity;	// 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use. other value invalid
+	UCHAR AmsduEnable;	//Enable AMSDU transmisstion
+	UCHAR AmsduSize;	// 0:3839, 1:7935 bytes. UINT  MSDUSizeToBytes[]        = { 3839, 7935};
+	UCHAR MMPSmode;		// MIMO power save more, 0:static, 1:dynamic, 2:rsv, 3:mimo enable
+	BOOLEAN AutoBA;		// Auto BA will automatically
 } OID_BACAP_STRUC, *POID_BACAP_STRUC;
 
 typedef struct _RT_802_11_ACL_ENTRY {
-    UCHAR   Addr[MAC_ADDR_LENGTH];
-    USHORT  Rsv;
+	UCHAR Addr[MAC_ADDR_LENGTH];
+	USHORT Rsv;
 } RT_802_11_ACL_ENTRY, *PRT_802_11_ACL_ENTRY;
 
 typedef struct PACKED _RT_802_11_ACL {
-    ULONG   Policy;             // 0-disable, 1-positive list, 2-negative list
-    ULONG   Num;
-    RT_802_11_ACL_ENTRY Entry[MAX_NUMBER_OF_ACL];
+	ULONG Policy;		// 0-disable, 1-positive list, 2-negative list
+	ULONG Num;
+	RT_802_11_ACL_ENTRY Entry[MAX_NUMBER_OF_ACL];
 } RT_802_11_ACL, *PRT_802_11_ACL;
 
 typedef struct _RT_802_11_WDS {
-    ULONG						Num;
-    NDIS_802_11_MAC_ADDRESS		Entry[24/*MAX_NUM_OF_WDS_LINK*/];
-	ULONG						KeyLength;
-	UCHAR						KeyMaterial[32];
+	ULONG Num;
+	NDIS_802_11_MAC_ADDRESS Entry[24 /*MAX_NUM_OF_WDS_LINK */ ];
+	ULONG KeyLength;
+	UCHAR KeyMaterial[32];
 } RT_802_11_WDS, *PRT_802_11_WDS;
 
 typedef struct _RT_802_11_TX_RATES_ {
-    UCHAR       SupRateLen;
-    UCHAR       SupRate[MAX_LENGTH_OF_SUPPORT_RATES];
-    UCHAR       ExtRateLen;
-    UCHAR       ExtRate[MAX_LENGTH_OF_SUPPORT_RATES];
+	UCHAR SupRateLen;
+	UCHAR SupRate[MAX_LENGTH_OF_SUPPORT_RATES];
+	UCHAR ExtRateLen;
+	UCHAR ExtRate[MAX_LENGTH_OF_SUPPORT_RATES];
 } RT_802_11_TX_RATES, *PRT_802_11_TX_RATES;
 
-
 // Definition of extra information code
-#define	GENERAL_LINK_UP			0x0			// Link is Up
-#define	GENERAL_LINK_DOWN		0x1			// Link is Down
-#define	HW_RADIO_OFF			0x2			// Hardware radio off
-#define	SW_RADIO_OFF			0x3			// Software radio off
-#define	AUTH_FAIL				0x4			// Open authentication fail
-#define	AUTH_FAIL_KEYS			0x5			// Shared authentication fail
-#define	ASSOC_FAIL				0x6			// Association failed
-#define	EAP_MIC_FAILURE			0x7			// Deauthencation because MIC failure
-#define	EAP_4WAY_TIMEOUT		0x8			// Deauthencation on 4-way handshake timeout
-#define	EAP_GROUP_KEY_TIMEOUT	0x9			// Deauthencation on group key handshake timeout
-#define	EAP_SUCCESS				0xa			// EAP succeed
-#define	DETECT_RADAR_SIGNAL		0xb         // Radar signal occur in current channel
-#define EXTRA_INFO_MAX			0xb			// Indicate Last OID
+#define	GENERAL_LINK_UP			0x0	// Link is Up
+#define	GENERAL_LINK_DOWN		0x1	// Link is Down
+#define	HW_RADIO_OFF			0x2	// Hardware radio off
+#define	SW_RADIO_OFF			0x3	// Software radio off
+#define	AUTH_FAIL				0x4	// Open authentication fail
+#define	AUTH_FAIL_KEYS			0x5	// Shared authentication fail
+#define	ASSOC_FAIL				0x6	// Association failed
+#define	EAP_MIC_FAILURE			0x7	// Deauthencation because MIC failure
+#define	EAP_4WAY_TIMEOUT		0x8	// Deauthencation on 4-way handshake timeout
+#define	EAP_GROUP_KEY_TIMEOUT	0x9	// Deauthencation on group key handshake timeout
+#define	EAP_SUCCESS				0xa	// EAP succeed
+#define	DETECT_RADAR_SIGNAL		0xb	// Radar signal occur in current channel
+#define EXTRA_INFO_MAX			0xb	// Indicate Last OID
 
 #define EXTRA_INFO_CLEAR		0xffffffff
 
 // This is OID setting structure. So only GF or MM as Mode. This is valid when our wirelss mode has 802.11n in use.
 typedef struct {
-	RT_802_11_PHY_MODE		PhyMode; 	//
-	UCHAR		TransmitNo;
-	UCHAR		HtMode; 	//HTMODE_GF or HTMODE_MM
-	UCHAR		ExtOffset;	//extension channel above or below
-	UCHAR		MCS;
-	UCHAR   	BW;
-	UCHAR		STBC;
-	UCHAR		SHORTGI;
-	UCHAR		rsv;
+	RT_802_11_PHY_MODE PhyMode;	//
+	UCHAR TransmitNo;
+	UCHAR HtMode;		//HTMODE_GF or HTMODE_MM
+	UCHAR ExtOffset;	//extension channel above or below
+	UCHAR MCS;
+	UCHAR BW;
+	UCHAR STBC;
+	UCHAR SHORTGI;
+	UCHAR rsv;
 } OID_SET_HT_PHYMODE, *POID_SET_HT_PHYMODE;
 
 #define MAX_CUSTOM_LEN 128
 
-typedef enum _RT_802_11_D_CLIENT_MODE
-{
-   Rt802_11_D_None,
-   Rt802_11_D_Flexible,
-   Rt802_11_D_Strict,
+typedef enum _RT_802_11_D_CLIENT_MODE {
+	Rt802_11_D_None,
+	Rt802_11_D_Flexible,
+	Rt802_11_D_Strict,
 } RT_802_11_D_CLIENT_MODE, *PRT_802_11_D_CLIENT_MODE;
 
-typedef struct _RT_CHANNEL_LIST_INFO
-{
-	UCHAR ChannelList[MAX_NUM_OF_CHS];   // list all supported channels for site survey
-	UCHAR ChannelListNum; // number of channel in ChannelList[]
+typedef struct _RT_CHANNEL_LIST_INFO {
+	UCHAR ChannelList[MAX_NUM_OF_CHS];	// list all supported channels for site survey
+	UCHAR ChannelListNum;	// number of channel in ChannelList[]
 } RT_CHANNEL_LIST_INFO, *PRT_CHANNEL_LIST_INFO;
 
 // WSC configured credential
-typedef	struct	_WSC_CREDENTIAL
-{
-	NDIS_802_11_SSID	SSID;				// mandatory
-	USHORT				AuthType;			// mandatory, 1: open, 2: wpa-psk, 4: shared, 8:wpa, 0x10: wpa2, 0x20: wpa2-psk
-	USHORT				EncrType;			// mandatory, 1: none, 2: wep, 4: tkip, 8: aes
-	UCHAR				Key[64];			// mandatory, Maximum 64 byte
-	USHORT				KeyLength;
-	UCHAR				MacAddr[6];			// mandatory, AP MAC address
-	UCHAR				KeyIndex;			// optional, default is 1
-	UCHAR				Rsvd[3];			// Make alignment
-}	WSC_CREDENTIAL, *PWSC_CREDENTIAL;
+typedef struct _WSC_CREDENTIAL {
+	NDIS_802_11_SSID SSID;	// mandatory
+	USHORT AuthType;	// mandatory, 1: open, 2: wpa-psk, 4: shared, 8:wpa, 0x10: wpa2, 0x20: wpa2-psk
+	USHORT EncrType;	// mandatory, 1: none, 2: wep, 4: tkip, 8: aes
+	UCHAR Key[64];		// mandatory, Maximum 64 byte
+	USHORT KeyLength;
+	UCHAR MacAddr[6];	// mandatory, AP MAC address
+	UCHAR KeyIndex;		// optional, default is 1
+	UCHAR Rsvd[3];		// Make alignment
+} WSC_CREDENTIAL, *PWSC_CREDENTIAL;
 
 // WSC configured profiles
-typedef	struct	_WSC_PROFILE
-{
-	UINT			ProfileCnt;
-	UINT			ApplyProfileIdx;  // add by johnli, fix WPS test plan 5.1.1
-	WSC_CREDENTIAL	Profile[8];				// Support up to 8 profiles
-}	WSC_PROFILE, *PWSC_PROFILE;
+typedef struct _WSC_PROFILE {
+	UINT ProfileCnt;
+	UINT ApplyProfileIdx;	// add by johnli, fix WPS test plan 5.1.1
+	WSC_CREDENTIAL Profile[8];	// Support up to 8 profiles
+} WSC_PROFILE, *PWSC_PROFILE;
 
 #endif // _OID_H_
-
--- a/drivers/staging/rt2860/rt_config.h
+++ b/drivers/staging/rt2860/rt_config.h
@@ -68,5 +68,4 @@
 #include "igmp_snoop.h"
 #endif // IGMP_SNOOP_SUPPORT //
 
-#endif	// __RT_CONFIG_H__
-
+#endif // __RT_CONFIG_H__
--- a/drivers/staging/rt2860/rt_linux.h
+++ b/drivers/staging/rt2860/rt_linux.h
@@ -79,7 +79,6 @@
  *	Profile related sections
  ***********************************************************************************/
 
-
 #ifdef RTMP_MAC_PCI
 #define STA_PROFILE_PATH			"/etc/Wireless/RT2860STA/RT2860STA.dat"
 #define STA_DRIVER_VERSION			"2.1.0.0"
@@ -90,8 +89,7 @@
 // RT3070 version: 2.1.1.0
 #endif // RTMP_MAC_USB //
 
-extern	const struct iw_handler_def rt28xx_iw_handler_def;
-
+extern const struct iw_handler_def rt28xx_iw_handler_def;
 
 /***********************************************************************************
  *	Compiler related definitions
@@ -103,23 +101,23 @@ extern	const struct iw_handler_def rt28x
 #define INOUT
 #define NDIS_STATUS		INT
 
-
 /***********************************************************************************
  *	OS Specific definitions and data structures
  ***********************************************************************************/
-typedef struct pci_dev		* PPCI_DEV;
-typedef struct net_device	* PNET_DEV;
-typedef void				* PNDIS_PACKET;
-typedef char				NDIS_PACKET;
-typedef PNDIS_PACKET		* PPNDIS_PACKET;
-typedef	dma_addr_t			NDIS_PHYSICAL_ADDRESS;
-typedef	dma_addr_t			* PNDIS_PHYSICAL_ADDRESS;
-typedef void				* NDIS_HANDLE;
-typedef char				* PNDIS_BUFFER;
-typedef	struct pid *	RTMP_OS_PID;
-typedef struct semaphore	RTMP_OS_SEM;
+typedef struct pci_dev *PPCI_DEV;
+typedef struct net_device *PNET_DEV;
+typedef void *PNDIS_PACKET;
+typedef char NDIS_PACKET;
+typedef PNDIS_PACKET *PPNDIS_PACKET;
+typedef dma_addr_t NDIS_PHYSICAL_ADDRESS;
+typedef dma_addr_t *PNDIS_PHYSICAL_ADDRESS;
+typedef void *NDIS_HANDLE;
+typedef char *PNDIS_BUFFER;
+typedef struct pid *RTMP_OS_PID;
+typedef struct semaphore RTMP_OS_SEM;
 
-typedef int (*HARD_START_XMIT_FUNC)(struct sk_buff *skb, struct net_device *net_dev);
+typedef int (*HARD_START_XMIT_FUNC) (struct sk_buff * skb,
+				     struct net_device * net_dev);
 
 #ifdef RTMP_MAC_PCI
 #ifndef PCI_DEVICE
@@ -142,11 +140,8 @@ typedef int (*HARD_START_XMIT_FUNC)(stru
 #define RTMP_DEC_REF(_A)		0
 #define RTMP_GET_REF(_A)		0
 
-
 // This function will be called when query /proc
-struct iw_statistics *rt28xx_get_wireless_stats(
-    IN struct net_device *net_dev);
-
+struct iw_statistics *rt28xx_get_wireless_stats(IN struct net_device *net_dev);
 
 /***********************************************************************************
  *	Network related constant definitions
@@ -178,18 +173,16 @@ struct iw_statistics *rt28xx_get_wireles
 #define STATS_INC_RX_DROPPED(_pAd, _dev)
 #define STATS_INC_TX_DROPPED(_pAd, _dev)
 
-
 /***********************************************************************************
  *	Ralink Specific network related constant definitions
  ***********************************************************************************/
-#define MIN_NET_DEVICE_FOR_AID			0x00		//0x00~0x3f
-#define MIN_NET_DEVICE_FOR_MBSSID		0x00		//0x00,0x10,0x20,0x30
-#define MIN_NET_DEVICE_FOR_WDS			0x10		//0x40,0x50,0x60,0x70
+#define MIN_NET_DEVICE_FOR_AID			0x00	//0x00~0x3f
+#define MIN_NET_DEVICE_FOR_MBSSID		0x00	//0x00,0x10,0x20,0x30
+#define MIN_NET_DEVICE_FOR_WDS			0x10	//0x40,0x50,0x60,0x70
 #define MIN_NET_DEVICE_FOR_APCLI		0x20
 #define MIN_NET_DEVICE_FOR_MESH			0x30
 #define MIN_NET_DEVICE_FOR_DLS			0x40
-#define NET_DEVICE_REAL_IDX_MASK		0x0f		// for each operation mode, we maximum support 15 entities.
-
+#define NET_DEVICE_REAL_IDX_MASK		0x0f	// for each operation mode, we maximum support 15 entities.
 
 #define NDIS_PACKET_TYPE_DIRECTED		0
 #define NDIS_PACKET_TYPE_MULTICAST		1
@@ -197,36 +190,32 @@ struct iw_statistics *rt28xx_get_wireles
 #define NDIS_PACKET_TYPE_ALL_MULTICAST	3
 #define NDIS_PACKET_TYPE_PROMISCUOUS	4
 
-
 /***********************************************************************************
  *	OS signaling related constant definitions
  ***********************************************************************************/
 
-
 /***********************************************************************************
  *	OS file operation related data structure definitions
  ***********************************************************************************/
-typedef struct file* RTMP_OS_FD;
+typedef struct file *RTMP_OS_FD;
 
-typedef struct _RTMP_OS_FS_INFO_
-{
-	int				fsuid;
-	int				fsgid;
-	mm_segment_t	fs;
-}RTMP_OS_FS_INFO;
+typedef struct _RTMP_OS_FS_INFO_ {
+	int fsuid;
+	int fsgid;
+	mm_segment_t fs;
+} RTMP_OS_FS_INFO;
 
 #define IS_FILE_OPEN_ERR(_fd)	IS_ERR((_fd))
 
-
 /***********************************************************************************
  *	OS semaphore related data structure and definitions
  ***********************************************************************************/
-struct os_lock  {
-	spinlock_t		lock;
-	unsigned long	flags;
+struct os_lock {
+	spinlock_t lock;
+	unsigned long flags;
 };
 
-typedef spinlock_t			NDIS_SPIN_LOCK;
+typedef spinlock_t NDIS_SPIN_LOCK;
 
 //
 //  spin_lock enhanced for Nested spin lock
@@ -239,7 +228,6 @@ typedef spinlock_t			NDIS_SPIN_LOCK;
 #define NdisFreeSpinLock(lock)          \
 	do{}while(0)
 
-
 #define RTMP_SEM_LOCK(__lock)					\
 {												\
 	spin_lock_bh((spinlock_t *)(__lock));		\
@@ -250,7 +238,6 @@ typedef spinlock_t			NDIS_SPIN_LOCK;
 	spin_unlock_bh((spinlock_t *)(__lock));		\
 }
 
-
 // sample, use semaphore lock to replace IRQ lock, 2007/11/15
 #define RTMP_IRQ_LOCK(__lock, __irqflags)			\
 {													\
@@ -343,7 +330,7 @@ do { \
 /***********************************************************************************
  *	OS Memory Access related data structure and definitions
  ***********************************************************************************/
-#define MEM_ALLOC_FLAG      (GFP_ATOMIC) //(GFP_DMA | GFP_ATOMIC)
+#define MEM_ALLOC_FLAG      (GFP_ATOMIC)	//(GFP_DMA | GFP_ATOMIC)
 
 #define NdisMoveMemory(Destination, Source, Length) memmove(Destination, Source, Length)
 #define NdisCopyMemory(Destination, Source, Length) memcpy(Destination, Source, Length)
@@ -358,32 +345,29 @@ do { \
 
 #define COPY_MAC_ADDR(Addr1, Addr2)             memcpy((Addr1), (Addr2), MAC_ADDR_LEN)
 
-
 /***********************************************************************************
  *	OS task related data structure and definitions
  ***********************************************************************************/
 #define RTMP_OS_MGMT_TASK_FLAGS	CLONE_VM
 
-typedef	struct pid *	THREAD_PID;
+typedef struct pid *THREAD_PID;
 #define	THREAD_PID_INIT_VALUE	NULL
 #define	GET_PID(_v)	find_get_pid((_v))
 #define	GET_PID_NUMBER(_v)	pid_nr((_v))
 #define CHECK_PID_LEGALITY(_pid)	if (pid_nr((_pid)) > 0)
 #define KILL_THREAD_PID(_A, _B, _C)	kill_pid((_A), (_B), (_C))
 
-typedef struct tasklet_struct  RTMP_NET_TASK_STRUCT;
-typedef struct tasklet_struct  *PRTMP_NET_TASK_STRUCT;
-
+typedef struct tasklet_struct RTMP_NET_TASK_STRUCT;
+typedef struct tasklet_struct *PRTMP_NET_TASK_STRUCT;
 
 /***********************************************************************************
  * Timer related definitions and data structures.
  **********************************************************************************/
 #define OS_HZ			HZ
 
-typedef struct timer_list	NDIS_MINIPORT_TIMER;
-typedef struct timer_list	RTMP_OS_TIMER;
-typedef void (*TIMER_FUNCTION)(unsigned long);
-
+typedef struct timer_list NDIS_MINIPORT_TIMER;
+typedef struct timer_list RTMP_OS_TIMER;
+typedef void (*TIMER_FUNCTION) (unsigned long);
 
 #define OS_WAIT(_time) \
 {	int _i; \
@@ -406,26 +390,25 @@ typedef void (*TIMER_FUNCTION)(unsigned 
 
 #define ONE_TICK 1
 
-static inline void NdisGetSystemUpTime(ULONG *time)
+static inline void NdisGetSystemUpTime(ULONG * time)
 {
 	*time = jiffies;
 }
 
-
 /***********************************************************************************
  *	OS specific cookie data structure binding to RTMP_ADAPTER
  ***********************************************************************************/
 
 struct os_cookie {
 #ifdef RTMP_MAC_PCI
-	struct pci_dev			*pci_dev;
-	struct pci_dev			*parent_pci_dev;
-	USHORT                  DeviceID;
-	dma_addr_t				pAd_pa;
-#endif // RTMP_MAC_PCI //
+	struct pci_dev *pci_dev;
+	struct pci_dev *parent_pci_dev;
+	USHORT DeviceID;
+	dma_addr_t pAd_pa;
+#endif				// RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
-	struct usb_device		*pUsb_Dev;
-#endif // RTMP_MAC_USB //
+	struct usb_device *pUsb_Dev;
+#endif				// RTMP_MAC_USB //
 
 	RTMP_NET_TASK_STRUCT rx_done_task;
 	RTMP_NET_TASK_STRUCT mgmt_dma_done_task;
@@ -436,21 +419,19 @@ struct os_cookie {
 	RTMP_NET_TASK_STRUCT tbtt_task;
 #ifdef RTMP_MAC_PCI
 	RTMP_NET_TASK_STRUCT fifo_statistic_full_task;
-#endif // RTMP_MAC_PCI //
+#endif				// RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
 	RTMP_NET_TASK_STRUCT null_frame_complete_task;
 	RTMP_NET_TASK_STRUCT rts_frame_complete_task;
 	RTMP_NET_TASK_STRUCT pspoll_frame_complete_task;
-#endif // RTMP_MAC_USB //
+#endif				// RTMP_MAC_USB //
 
-	unsigned long			apd_pid; //802.1x daemon pid
-	INT						ioctl_if_type;
-	INT					ioctl_if;
+	unsigned long apd_pid;	//802.1x daemon pid
+	INT ioctl_if_type;
+	INT ioctl_if;
 };
 
-typedef struct os_cookie	* POS_COOKIE;
-
-
+typedef struct os_cookie *POS_COOKIE;
 
 /***********************************************************************************
  *	OS debugging and printing related definitions and data structure
@@ -459,7 +440,7 @@ typedef struct os_cookie	* POS_COOKIE;
 	addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]
 
 #ifdef DBG
-extern ULONG    RTDebugLevel;
+extern ULONG RTDebugLevel;
 
 #define DBGPRINT_RAW(Level, Fmt)    \
 do{                                   \
@@ -471,7 +452,6 @@ do{                                   \
 
 #define DBGPRINT(Level, Fmt)    DBGPRINT_RAW(Level, Fmt)
 
-
 #define DBGPRINT_ERR(Fmt)           \
 {                                   \
     printk("ERROR!!! ");          \
@@ -483,7 +463,6 @@ do{                                   \
 	printk Fmt;					\
 }
 
-
 #else
 #define DBGPRINT(Level, Fmt)
 #define DBGPRINT_RAW(Level, Fmt)
@@ -495,18 +474,18 @@ do{                                   \
 
 void hex_dump(char *str, unsigned char *pSrcBufVA, unsigned int SrcBufLen);
 
-
 /*********************************************************************************************************
 	The following code are not revised, temporary put it here.
   *********************************************************************************************************/
 
-
 /***********************************************************************************
  * Device DMA Access related definitions and data structures.
  **********************************************************************************/
 #ifdef RTMP_MAC_PCI
-dma_addr_t linux_pci_map_single(void *handle, void *ptr, size_t size, int sd_idx, int direction);
-void linux_pci_unmap_single(void *handle, dma_addr_t dma_addr, size_t size, int direction);
+dma_addr_t linux_pci_map_single(void *handle, void *ptr, size_t size,
+				int sd_idx, int direction);
+void linux_pci_unmap_single(void *handle, dma_addr_t dma_addr, size_t size,
+			    int direction);
 
 #define PCI_MAP_SINGLE(_handle, _ptr, _size, _sd_idx, _dir) \
 	linux_pci_map_single(_handle, _ptr, _size, _sd_idx, _dir)
@@ -562,8 +541,6 @@ void linux_pci_unmap_single(void *handle
 
 #define NdisMIndicateStatus(_w, _x, _y, _z)
 
-
-
 /***********************************************************************************
  * Device Register I/O Access related definitions and data structures.
  **********************************************************************************/
@@ -729,7 +706,6 @@ void linux_pci_unmap_single(void *handle
 #define GET_OS_PKT_NEXT(_pkt) \
 		(RTPKT_TO_OSPKT(_pkt)->next)
 
-
 #define OS_PKT_CLONED(_pkt)		skb_cloned(RTPKT_TO_OSPKT(_pkt))
 
 #define OS_NTOHS(_Val) \
@@ -783,9 +759,8 @@ void linux_pci_unmap_single(void *handle
 #define RTMP_SET_PACKET_MOREDATA(_p, _morebit)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+7] = _morebit)
 #define RTMP_GET_PACKET_MOREDATA(_p)				(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+7])
 
-
 //
-//	Sepcific Pakcet Type definition
+//      Sepcific Pakcet Type definition
 //
 #define RTMP_PACKET_SPECIFIC_CB_OFFSET	11
 
@@ -863,13 +838,10 @@ void linux_pci_unmap_single(void *handle
 
 #define RTMP_GET_PACKET_IPV4(_p)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+11] & RTMP_PACKET_SPECIFIC_IPV4)
 
-
 // If this flag is set, it indicates that this EAPoL frame MUST be clear.
 #define RTMP_SET_PACKET_CLEAR_EAP_FRAME(_p, _flg)   (RTPKT_TO_OSPKT(_p)->cb[CB_OFF+12] = _flg)
 #define RTMP_GET_PACKET_CLEAR_EAP_FRAME(_p)         (RTPKT_TO_OSPKT(_p)->cb[CB_OFF+12])
 
-
-
 /* use bit3 of cb[CB_OFF+16] */
 
 #define RTMP_SET_PACKET_5VT(_p, _flg)   (RTPKT_TO_OSPKT(_p)->cb[CB_OFF+22] = _flg)
@@ -877,12 +849,10 @@ void linux_pci_unmap_single(void *handle
 
 /* Max skb->cb = 48B = [CB_OFF+38] */
 
-
-
 /***********************************************************************************
  *	Other function prototypes definitions
  ***********************************************************************************/
-void RTMP_GetCurrentSystemTime(LARGE_INTEGER *time);
+void RTMP_GetCurrentSystemTime(LARGE_INTEGER * time);
 int rt28xx_packet_xmit(struct sk_buff *skb);
 
 #ifdef RTMP_MAC_PCI
@@ -892,13 +862,10 @@ int rt28xx_packet_xmit(struct sk_buff *s
 IRQ_HANDLE_TYPE rt2860_interrupt(int irq, void *dev_instance);
 #endif // RTMP_MAC_PCI //
 
-INT rt28xx_sta_ioctl(
-	IN	PNET_DEV		net_dev,
-	IN	OUT	struct ifreq	*rq,
-	IN	INT			cmd);
+INT rt28xx_sta_ioctl(IN PNET_DEV net_dev, IN OUT struct ifreq *rq, IN INT cmd);
 
-extern int ra_mtd_write(int num, loff_t to, size_t len, const u_char *buf);
-extern int ra_mtd_read(int num, loff_t from, size_t len, u_char *buf);
+extern int ra_mtd_write(int num, loff_t to, size_t len, const u_char * buf);
+extern int ra_mtd_read(int num, loff_t from, size_t len, u_char * buf);
 
 #define GET_PAD_FROM_NET_DEV(_pAd, _net_dev)	(_pAd) = (PRTMP_ADAPTER)(_net_dev)->ml_priv;
 
--- a/drivers/staging/rt2860/rtmp_chip.h
+++ b/drivers/staging/rt2860/rtmp_chip.h
@@ -73,7 +73,7 @@
 #define IS_RT2070(_pAd)		(((_pAd)->RfIcType == RFIC_2020) || ((_pAd)->EFuseTag == 0x27))
 
 #define IS_RT30xx(_pAd)		(((_pAd)->MACVersion & 0xfff00000) == 0x30700000||IS_RT3090A(_pAd))
-//#define IS_RT305X(_pAd)		((_pAd)->MACVersion == 0x28720200)
+//#define IS_RT305X(_pAd)               ((_pAd)->MACVersion == 0x28720200)
 
 /* RT3572, 3592, 3562, 3062 share the same MAC version */
 #define IS_RT3572(_pAd)		(((_pAd)->MACVersion & 0xffff0000) == 0x35720000)
@@ -103,15 +103,12 @@
 
 #define RETRY_LIMIT		10
 
-
-
 // ------------------------------------------------------
-// BBP & RF	definition
+// BBP & RF     definition
 // ------------------------------------------------------
 #define	BUSY		                1
 #define	IDLE		                0
 
-
 //-------------------------------------------------------------------------
 // EEPROM definition
 //-------------------------------------------------------------------------
@@ -126,11 +123,11 @@
 #define EEPROM_EWDS_OPCODE          0x10
 #define EEPROM_EWEN_OPCODE          0x13
 
-#define NUM_EEPROM_BBP_PARMS		19			// Include NIC Config 0, 1, CR, TX ALC step, BBPs
+#define NUM_EEPROM_BBP_PARMS		19	// Include NIC Config 0, 1, CR, TX ALC step, BBPs
 #define NUM_EEPROM_TX_G_PARMS		7
-#define EEPROM_NIC1_OFFSET          0x34		// The address is from NIC config 0, not BBP register ID
-#define EEPROM_NIC2_OFFSET          0x36		// The address is from NIC config 0, not BBP register ID
-#define EEPROM_BBP_BASE_OFFSET		0xf0		// The address is from NIC config 0, not BBP register ID
+#define EEPROM_NIC1_OFFSET          0x34	// The address is from NIC config 0, not BBP register ID
+#define EEPROM_NIC2_OFFSET          0x36	// The address is from NIC config 0, not BBP register ID
+#define EEPROM_BBP_BASE_OFFSET		0xf0	// The address is from NIC config 0, not BBP register ID
 #define EEPROM_G_TX_PWR_OFFSET		0x52
 #define EEPROM_G_TX2_PWR_OFFSET		0x60
 #define EEPROM_LED1_OFFSET			0x3c
@@ -150,24 +147,22 @@
 #define EEPROM_A_TX2_PWR_OFFSET      0xa6
 //#define EEPROM_Japan_TX_PWR_OFFSET      0x90 // 802.11j
 //#define EEPROM_Japan_TX2_PWR_OFFSET      0xbe
-//#define EEPROM_TSSI_REF_OFFSET	0x54
-//#define EEPROM_TSSI_DELTA_OFFSET	0x24
+//#define EEPROM_TSSI_REF_OFFSET        0x54
+//#define EEPROM_TSSI_DELTA_OFFSET      0x24
 //#define EEPROM_CCK_TX_PWR_OFFSET  0x62
-//#define EEPROM_CALIBRATE_OFFSET	0x7c
+//#define EEPROM_CALIBRATE_OFFSET       0x7c
 #define EEPROM_VERSION_OFFSET       0x02
 #define EEPROM_FREQ_OFFSET			0x3a
 #define EEPROM_TXPOWER_BYRATE	0xde	// 20MHZ power.
 #define EEPROM_TXPOWER_DELTA		0x50	// 20MHZ AND 40 MHZ use different power. This is delta in 40MHZ.
 #define VALID_EEPROM_VERSION        1
 
-
 /*
   *   EEPROM operation related marcos
   */
 #define RT28xx_EEPROM_READ16(_pAd, _offset, _value)			\
 	(_pAd)->chipOps.eeread((RTMP_ADAPTER *)(_pAd), (USHORT)(_offset), (PUSHORT)&(_value))
 
-
 // -------------------------------------------------------------------
 //  E2PROM data layout
 // -------------------------------------------------------------------
@@ -175,90 +170,89 @@
 //
 // MCU_LEDCS: MCU LED Control Setting.
 //
-typedef union  _MCU_LEDCS_STRUC {
-	struct	{
-		UCHAR		LedMode:7;
-		UCHAR		Polarity:1;
+typedef union _MCU_LEDCS_STRUC {
+	struct {
+		UCHAR LedMode:7;
+		UCHAR Polarity:1;
 	} field;
-	UCHAR				word;
+	UCHAR word;
 } MCU_LEDCS_STRUC, *PMCU_LEDCS_STRUC;
 
-
 //
 // EEPROM antenna select format
 //
-typedef	union	_EEPROM_ANTENNA_STRUC	{
-	struct	{
-		USHORT		RxPath:4;	// 1: 1R, 2: 2R, 3: 3R
-		USHORT		TxPath:4;	// 1: 1T, 2: 2T
-		USHORT      RfIcType:4;             // see E2PROM document
-		USHORT      Rsv:4;
-	}	field;
-	USHORT			word;
-}	EEPROM_ANTENNA_STRUC, *PEEPROM_ANTENNA_STRUC;
-
-typedef	union _EEPROM_NIC_CINFIG2_STRUC	{
-	struct {
-		USHORT		HardwareRadioControl:1;	// 1:enable, 0:disable
-		USHORT		DynamicTxAgcControl:1;			//
-		USHORT		ExternalLNAForG:1;				//
-		USHORT		ExternalLNAForA:1;			// external LNA enable for 2.4G
-		USHORT		CardbusAcceleration:1;	// !!! NOTE: 0 - enable, 1 - disable
-		USHORT		BW40MSidebandForG:1;
-		USHORT		BW40MSidebandForA:1;
-		USHORT		EnableWPSPBC:1;                 // WPS PBC Control bit
-		USHORT		BW40MAvailForG:1;			// 0:enable, 1:disable
-		USHORT		BW40MAvailForA:1;			// 0:enable, 1:disable
-		USHORT		Rsv1:1;					// must be 0
-		USHORT		AntDiversity:1;			// Antenna diversity
-		USHORT		Rsv2:3;					// must be 0
-		USHORT		DACTestBit:1;			// control if driver should patch the DAC issue
-	}	field;
-	USHORT			word;
-}	EEPROM_NIC_CONFIG2_STRUC, *PEEPROM_NIC_CONFIG2_STRUC;
+typedef union _EEPROM_ANTENNA_STRUC {
+	struct {
+		USHORT RxPath:4;	// 1: 1R, 2: 2R, 3: 3R
+		USHORT TxPath:4;	// 1: 1T, 2: 2T
+		USHORT RfIcType:4;	// see E2PROM document
+		USHORT Rsv:4;
+	} field;
+	USHORT word;
+} EEPROM_ANTENNA_STRUC, *PEEPROM_ANTENNA_STRUC;
+
+typedef union _EEPROM_NIC_CINFIG2_STRUC {
+	struct {
+		USHORT HardwareRadioControl:1;	// 1:enable, 0:disable
+		USHORT DynamicTxAgcControl:1;	//
+		USHORT ExternalLNAForG:1;	//
+		USHORT ExternalLNAForA:1;	// external LNA enable for 2.4G
+		USHORT CardbusAcceleration:1;	// !!! NOTE: 0 - enable, 1 - disable
+		USHORT BW40MSidebandForG:1;
+		USHORT BW40MSidebandForA:1;
+		USHORT EnableWPSPBC:1;	// WPS PBC Control bit
+		USHORT BW40MAvailForG:1;	// 0:enable, 1:disable
+		USHORT BW40MAvailForA:1;	// 0:enable, 1:disable
+		USHORT Rsv1:1;	// must be 0
+		USHORT AntDiversity:1;	// Antenna diversity
+		USHORT Rsv2:3;	// must be 0
+		USHORT DACTestBit:1;	// control if driver should patch the DAC issue
+	} field;
+	USHORT word;
+} EEPROM_NIC_CONFIG2_STRUC, *PEEPROM_NIC_CONFIG2_STRUC;
 
 //
 // TX_PWR Value valid range 0xFA(-6) ~ 0x24(36)
 //
-typedef	union	_EEPROM_TX_PWR_STRUC	{
-	struct	{
-		CHAR	Byte0;				// Low Byte
-		CHAR	Byte1;				// High Byte
-	}	field;
-	USHORT	word;
-}	EEPROM_TX_PWR_STRUC, *PEEPROM_TX_PWR_STRUC;
-
-typedef	union	_EEPROM_VERSION_STRUC	{
-	struct	{
-		UCHAR	FaeReleaseNumber;	// Low Byte
-		UCHAR	Version;			// High Byte
-	}	field;
-	USHORT	word;
-}	EEPROM_VERSION_STRUC, *PEEPROM_VERSION_STRUC;
-
-typedef	union	_EEPROM_LED_STRUC	{
-	struct	{
-		USHORT	PolarityRDY_G:1;		// Polarity RDY_G setting.
-		USHORT	PolarityRDY_A:1;		// Polarity RDY_A setting.
-		USHORT	PolarityACT:1;		// Polarity ACT setting.
-		USHORT	PolarityGPIO_0:1;	// Polarity GPIO#0 setting.
-		USHORT	PolarityGPIO_1:1;	// Polarity GPIO#1 setting.
-		USHORT	PolarityGPIO_2:1;	// Polarity GPIO#2 setting.
-		USHORT	PolarityGPIO_3:1;	// Polarity GPIO#3 setting.
-		USHORT	PolarityGPIO_4:1;	// Polarity GPIO#4 setting.
-		USHORT	LedMode:5;			// Led mode.
-		USHORT	Rsvd:3;				// Reserved
-	}	field;
-	USHORT	word;
-}	EEPROM_LED_STRUC, *PEEPROM_LED_STRUC;
-
-typedef	union	_EEPROM_TXPOWER_DELTA_STRUC	{
-	struct	{
-		UCHAR	DeltaValue:6;	// Tx Power dalta value (MAX=4)
-		UCHAR	Type:1;			// 1: plus the delta value, 0: minus the delta value
-		UCHAR	TxPowerEnable:1;// Enable
-	}	field;
-	UCHAR	value;
-}	EEPROM_TXPOWER_DELTA_STRUC, *PEEPROM_TXPOWER_DELTA_STRUC;
+typedef union _EEPROM_TX_PWR_STRUC {
+	struct {
+		CHAR Byte0;	// Low Byte
+		CHAR Byte1;	// High Byte
+	} field;
+	USHORT word;
+} EEPROM_TX_PWR_STRUC, *PEEPROM_TX_PWR_STRUC;
+
+typedef union _EEPROM_VERSION_STRUC {
+	struct {
+		UCHAR FaeReleaseNumber;	// Low Byte
+		UCHAR Version;	// High Byte
+	} field;
+	USHORT word;
+} EEPROM_VERSION_STRUC, *PEEPROM_VERSION_STRUC;
+
+typedef union _EEPROM_LED_STRUC {
+	struct {
+		USHORT PolarityRDY_G:1;	// Polarity RDY_G setting.
+		USHORT PolarityRDY_A:1;	// Polarity RDY_A setting.
+		USHORT PolarityACT:1;	// Polarity ACT setting.
+		USHORT PolarityGPIO_0:1;	// Polarity GPIO#0 setting.
+		USHORT PolarityGPIO_1:1;	// Polarity GPIO#1 setting.
+		USHORT PolarityGPIO_2:1;	// Polarity GPIO#2 setting.
+		USHORT PolarityGPIO_3:1;	// Polarity GPIO#3 setting.
+		USHORT PolarityGPIO_4:1;	// Polarity GPIO#4 setting.
+		USHORT LedMode:5;	// Led mode.
+		USHORT Rsvd:3;	// Reserved
+	} field;
+	USHORT word;
+} EEPROM_LED_STRUC, *PEEPROM_LED_STRUC;
+
+typedef union _EEPROM_TXPOWER_DELTA_STRUC {
+	struct {
+		UCHAR DeltaValue:6;	// Tx Power dalta value (MAX=4)
+		UCHAR Type:1;	// 1: plus the delta value, 0: minus the delta value
+		UCHAR TxPowerEnable:1;	// Enable
+	} field;
+	UCHAR value;
+} EEPROM_TXPOWER_DELTA_STRUC, *PEEPROM_TXPOWER_DELTA_STRUC;
 
-#endif	// __RTMP_CHIP_H__ //
+#endif // __RTMP_CHIP_H__ //
--- a/drivers/staging/rt2860/rtmp_ckipmic.h
+++ b/drivers/staging/rt2860/rtmp_ckipmic.h
@@ -37,42 +37,27 @@
 #ifndef	__RTMP_CKIPMIC_H__
 #define	__RTMP_CKIPMIC_H__
 
-typedef	struct	_MIC_CONTEXT	{
+typedef struct _MIC_CONTEXT {
 	/* --- MMH context                            */
-	UCHAR		CK[16];				/* the key                                    */
-	UCHAR		coefficient[16];	/* current aes counter mode coefficients      */
-	ULONGLONG	accum;				/* accumulated mic, reduced to u32 in final() */
-	UINT		position;			/* current position (byte offset) in message  */
-	UCHAR		part[4];			/* for conversion of message to u32 for mmh   */
-}	MIC_CONTEXT, *PMIC_CONTEXT;
-
-VOID xor_128(
-    IN  PUCHAR              a,
-    IN  PUCHAR              b,
-    OUT PUCHAR              out);
-
-UCHAR RTMPCkipSbox(
-    IN  UCHAR               a);
-
-VOID xor_32(
-    IN  PUCHAR              a,
-    IN  PUCHAR              b,
-    OUT PUCHAR              out);
-
-VOID next_key(
-    IN  PUCHAR              key,
-    IN  INT                 round);
-
-VOID byte_sub(
-    IN  PUCHAR              in,
-    OUT PUCHAR              out);
-
-VOID shift_row(
-    IN  PUCHAR              in,
-    OUT PUCHAR              out);
-
-VOID mix_column(
-    IN  PUCHAR              in,
-    OUT PUCHAR              out);
+	UCHAR CK[16];		/* the key                                    */
+	UCHAR coefficient[16];	/* current aes counter mode coefficients      */
+	ULONGLONG accum;	/* accumulated mic, reduced to u32 in final() */
+	UINT position;		/* current position (byte offset) in message  */
+	UCHAR part[4];		/* for conversion of message to u32 for mmh   */
+} MIC_CONTEXT, *PMIC_CONTEXT;
+
+VOID xor_128(IN PUCHAR a, IN PUCHAR b, OUT PUCHAR out);
+
+UCHAR RTMPCkipSbox(IN UCHAR a);
+
+VOID xor_32(IN PUCHAR a, IN PUCHAR b, OUT PUCHAR out);
+
+VOID next_key(IN PUCHAR key, IN INT round);
+
+VOID byte_sub(IN PUCHAR in, OUT PUCHAR out);
+
+VOID shift_row(IN PUCHAR in, OUT PUCHAR out);
+
+VOID mix_column(IN PUCHAR in, OUT PUCHAR out);
 
 #endif //__RTMP_CKIPMIC_H__
--- a/drivers/staging/rt2860/rtmp_def.h
+++ b/drivers/staging/rt2860/rtmp_def.h
@@ -55,9 +55,9 @@
 #define NIC_DBG_STRING      ("**RT28xx**")
 
 #ifdef RTMP_MAC_USB
-#define TX_RING_SIZE            8 // 1
+#define TX_RING_SIZE            8	// 1
 #define PRIO_RING_SIZE          8
-#define MGMT_RING_SIZE		32 // PRIO_RING_SIZE
+#define MGMT_RING_SIZE		32	// PRIO_RING_SIZE
 #define RX_RING_SIZE            8
 #define MAX_TX_PROCESS          4
 #define LOCAL_TXBUF_SIZE        2048
@@ -76,29 +76,29 @@
 //
 
 #ifdef RTMP_MAC_PCI
-#define TX_RING_SIZE            64 //64
+#define TX_RING_SIZE            64	//64
 #define MGMT_RING_SIZE          128
-#define RX_RING_SIZE            128 //64
-#define MAX_TX_PROCESS          TX_RING_SIZE //8
+#define RX_RING_SIZE            128	//64
+#define MAX_TX_PROCESS          TX_RING_SIZE	//8
 #define MAX_DMA_DONE_PROCESS    TX_RING_SIZE
-#define MAX_TX_DONE_PROCESS     TX_RING_SIZE //8
+#define MAX_TX_DONE_PROCESS     TX_RING_SIZE	//8
 #define LOCAL_TXBUF_SIZE        2
 #endif // RTMP_MAC_PCI //
 
-#define MAX_RX_PROCESS          128 //64 //32
+#define MAX_RX_PROCESS          128	//64 //32
 #define NUM_OF_LOCAL_TXBUF      2
 #define TXD_SIZE                16
 #define TXWI_SIZE               16
 #define RXD_SIZE               	16
 #define RXWI_SIZE             	16
 // TXINFO_SIZE + TXWI_SIZE + 802.11 Header Size + AMSDU sub frame header
-#define TX_DMA_1ST_BUFFER_SIZE  96    // only the 1st physical buffer is pre-allocated
-#define MGMT_DMA_BUFFER_SIZE    1536 //2048
-#define RX_BUFFER_AGGRESIZE     3840 //3904 //3968 //4096 //2048 //4096
-#define RX_BUFFER_NORMSIZE      3840 //3904 //3968 //4096 //2048 //4096
+#define TX_DMA_1ST_BUFFER_SIZE  96	// only the 1st physical buffer is pre-allocated
+#define MGMT_DMA_BUFFER_SIZE    1536	//2048
+#define RX_BUFFER_AGGRESIZE     3840	//3904 //3968 //4096 //2048 //4096
+#define RX_BUFFER_NORMSIZE      3840	//3904 //3968 //4096 //2048 //4096
 #define TX_BUFFER_NORMSIZE		RX_BUFFER_NORMSIZE
-#define MAX_FRAME_SIZE          2346                    // Maximum 802.11 frame size
-#define MAX_AGGREGATION_SIZE    3840 //3904 //3968 //4096
+#define MAX_FRAME_SIZE          2346	// Maximum 802.11 frame size
+#define MAX_AGGREGATION_SIZE    3840	//3904 //3968 //4096
 #define MAX_NUM_OF_TUPLE_CACHE  2
 #define MAX_MCAST_LIST_SIZE     32
 #define MAX_LEN_OF_VENDOR_DESC  64
@@ -107,7 +107,6 @@
 
 #define MAX_RX_PROCESS_CNT	(RX_RING_SIZE)
 
-
 /*
 	WMM Note: If memory of your system is not much, please reduce the definition;
 	or when you do WMM test, the queue for low priority AC will be full, i.e.
@@ -127,12 +126,11 @@
 	clConfig.clNum = RX_RING_SIZE * 4;
 */
 // TODO: For VxWorks the size is 256. Shall we cahnge the value as 256 for all OS?????
-#define MAX_PACKETS_IN_QUEUE				(512) //(512)    // to pass WMM A5-WPAPSK
+#define MAX_PACKETS_IN_QUEUE				(512)	//(512)    // to pass WMM A5-WPAPSK
 
 #define MAX_PACKETS_IN_MCAST_PS_QUEUE		32
 #define MAX_PACKETS_IN_PS_QUEUE				128	//32
-#define WMM_NUM_OF_AC                       4  /* AC0, AC1, AC2, and AC3 */
-
+#define WMM_NUM_OF_AC                       4	/* AC0, AC1, AC2, and AC3 */
 
 #ifdef RTMP_EFUSE_SUPPORT
 //2008/09/11:KH add to support efuse<--
@@ -189,8 +187,8 @@
 #define fOP_STATUS_MEDIA_STATE_CONNECTED    0x00000080
 #define fOP_STATUS_WMM_INUSED               0x00000100
 #define fOP_STATUS_AGGREGATION_INUSED       0x00000200
-#define fOP_STATUS_DOZE                     0x00000400  // debug purpose
-#define fOP_STATUS_PIGGYBACK_INUSED         0x00000800  // piggy-back, and aggregation
+#define fOP_STATUS_DOZE                     0x00000400	// debug purpose
+#define fOP_STATUS_PIGGYBACK_INUSED         0x00000800	// piggy-back, and aggregation
 #define fOP_STATUS_APSD_INUSED				0x00001000
 #define fOP_STATUS_TX_AMSDU_INUSED			0x00002000
 #define fOP_STATUS_MAX_RETRY_ENABLED		0x00004000
@@ -229,9 +227,9 @@
 //
 //  AP's client table operation status flags
 //
-#define fCLIENT_STATUS_WMM_CAPABLE          0x00000001  // CLIENT can parse QOS DATA frame
-#define fCLIENT_STATUS_AGGREGATION_CAPABLE  0x00000002  // CLIENT can receive Ralink's proprietary TX aggregation frame
-#define fCLIENT_STATUS_PIGGYBACK_CAPABLE    0x00000004  // CLIENT support piggy-back
+#define fCLIENT_STATUS_WMM_CAPABLE          0x00000001	// CLIENT can parse QOS DATA frame
+#define fCLIENT_STATUS_AGGREGATION_CAPABLE  0x00000002	// CLIENT can receive Ralink's proprietary TX aggregation frame
+#define fCLIENT_STATUS_PIGGYBACK_CAPABLE    0x00000004	// CLIENT support piggy-back
 #define fCLIENT_STATUS_AMSDU_INUSED			0x00000008
 #define fCLIENT_STATUS_SGI20_CAPABLE		0x00000010
 #define fCLIENT_STATUS_SGI40_CAPABLE		0x00000020
@@ -240,7 +238,7 @@
 #define fCLIENT_STATUS_HTC_CAPABLE			0x00000100
 #define fCLIENT_STATUS_RDG_CAPABLE			0x00000200
 #define fCLIENT_STATUS_MCSFEEDBACK_CAPABLE  0x00000400
-#define fCLIENT_STATUS_APSD_CAPABLE         0x00000800  /* UAPSD STATION */
+#define fCLIENT_STATUS_APSD_CAPABLE         0x00000800	/* UAPSD STATION */
 
 #define fCLIENT_STATUS_RALINK_CHIPSET		0x00100000
 //
@@ -303,10 +301,9 @@
 #define ERRLOG_NO_INTERRUPT_RESOURCE    0x00000604L
 #define ERRLOG_NO_MEMORY_RESOURCE       0x00000605L
 
-
 // WDS definition
 #define	MAX_WDS_ENTRY               4
-#define WDS_PAIRWISE_KEY_OFFSET     60    // WDS links uses pairwise key#60 ~ 63 in ASIC pairwise key table
+#define WDS_PAIRWISE_KEY_OFFSET     60	// WDS links uses pairwise key#60 ~ 63 in ASIC pairwise key table
 
 #define	WDS_DISABLE_MODE            0
 #define	WDS_RESTRICT_MODE           1
@@ -314,7 +311,6 @@
 #define	WDS_REPEATER_MODE           3
 #define	WDS_LAZY_MODE               4
 
-
 #define MAX_MESH_NUM				0
 
 #define MAX_APCLI_NUM				0
@@ -336,12 +332,11 @@
 #define MAIN_MBSSID                 0
 #define FIRST_MBSSID                1
 
-
 #define MAX_BEACON_SIZE				512
 // If the MAX_MBSSID_NUM is larger than 6,
 // it shall reserve some WCID space(wcid 222~253) for beacon frames.
-// -	these wcid 238~253 are reserved for beacon#6(ra6).
-// -	these wcid 222~237 are reserved for beacon#7(ra7).
+// -    these wcid 238~253 are reserved for beacon#6(ra6).
+// -    these wcid 222~237 are reserved for beacon#7(ra7).
 #if defined(MAX_MBSSID_NUM) && (MAX_MBSSID_NUM == 8)
 #define HW_RESERVED_WCID	222
 #elif defined(MAX_MBSSID_NUM) && (MAX_MBSSID_NUM == 7)
@@ -368,7 +363,6 @@
 
 #define IsGroupKeyWCID(__wcid) (((__wcid) < LAST_SPECIFIC_WCID) && ((__wcid) >= (LAST_SPECIFIC_WCID - (MAX_MBSSID_NUM))))
 
-
 // definition to support multiple BSSID
 #define BSS0                            0
 #define BSS1                            1
@@ -379,20 +373,19 @@
 #define BSS6                            6
 #define BSS7                            7
 
-
 //============================================================
 // Length definitions
 #define PEER_KEY_NO                     2
 #define MAC_ADDR_LEN                    6
 #define TIMESTAMP_LEN                   8
-#define MAX_LEN_OF_SUPPORTED_RATES      MAX_LENGTH_OF_SUPPORT_RATES // 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
-#define MAX_LEN_OF_KEY                  32      // 32 octets == 256 bits, Redefine for WPA
-#define MAX_NUM_OF_CHANNELS             MAX_NUM_OF_CHS      // 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL termination
-#define MAX_NUM_OF_11JCHANNELS             20      // 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL termination
+#define MAX_LEN_OF_SUPPORTED_RATES      MAX_LENGTH_OF_SUPPORT_RATES	// 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
+#define MAX_LEN_OF_KEY                  32	// 32 octets == 256 bits, Redefine for WPA
+#define MAX_NUM_OF_CHANNELS             MAX_NUM_OF_CHS	// 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL termination
+#define MAX_NUM_OF_11JCHANNELS             20	// 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 7 @Japan + 1 as NULL termination
 #define MAX_LEN_OF_SSID                 32
 #define CIPHER_TEXT_LEN                 128
 #define HASH_TABLE_SIZE                 256
-#define MAX_VIE_LEN                     1024   // New for WPA cipher suite variable IE sizes.
+#define MAX_VIE_LEN                     1024	// New for WPA cipher suite variable IE sizes.
 #define MAX_SUPPORT_MCS             32
 #define MAX_NUM_OF_BBP_LATCH             140
 
@@ -413,7 +406,7 @@
 
 #define MAX_NUM_OF_ACL_LIST				MAX_NUMBER_OF_ACL
 
-#define MAX_LEN_OF_MAC_TABLE            MAX_NUMBER_OF_MAC // if MAX_MBSSID_NUM is 8, this value can't be larger than 211
+#define MAX_LEN_OF_MAC_TABLE            MAX_NUMBER_OF_MAC	// if MAX_MBSSID_NUM is 8, this value can't be larger than 211
 
 #if MAX_LEN_OF_MAC_TABLE>MAX_AVAILABLE_CLIENT_WCID
 #error MAX_LEN_OF_MAC_TABLE can not be larger than MAX_AVAILABLE_CLIENT_WCID!!!!
@@ -426,37 +419,36 @@
 
 #define NUM_OF_TID			8
 #define MAX_AID_BA                    4
-#define MAX_LEN_OF_BA_REC_TABLE          ((NUM_OF_TID * MAX_LEN_OF_MAC_TABLE)/2)//   (NUM_OF_TID*MAX_AID_BA + 32)	 //Block ACK recipient
-#define MAX_LEN_OF_BA_ORI_TABLE          ((NUM_OF_TID * MAX_LEN_OF_MAC_TABLE)/2)//   (NUM_OF_TID*MAX_AID_BA + 32)   // Block ACK originator
+#define MAX_LEN_OF_BA_REC_TABLE          ((NUM_OF_TID * MAX_LEN_OF_MAC_TABLE)/2)	//   (NUM_OF_TID*MAX_AID_BA + 32)        //Block ACK recipient
+#define MAX_LEN_OF_BA_ORI_TABLE          ((NUM_OF_TID * MAX_LEN_OF_MAC_TABLE)/2)	//   (NUM_OF_TID*MAX_AID_BA + 32)   // Block ACK originator
 #define MAX_LEN_OF_BSS_TABLE             64
 #define MAX_REORDERING_MPDU_NUM			 512
 
 // key related definitions
 #define SHARE_KEY_NUM                   4
-#define MAX_LEN_OF_SHARE_KEY            16    // byte count
-#define MAX_LEN_OF_PEER_KEY             16    // byte count
-#define PAIRWISE_KEY_NUM                64    // in MAC ASIC pairwise key table
+#define MAX_LEN_OF_SHARE_KEY            16	// byte count
+#define MAX_LEN_OF_PEER_KEY             16	// byte count
+#define PAIRWISE_KEY_NUM                64	// in MAC ASIC pairwise key table
 #define GROUP_KEY_NUM                   4
 #define PMK_LEN                         32
-#define WDS_PAIRWISE_KEY_OFFSET         60    // WDS links uses pairwise key#60 ~ 63 in ASIC pairwise key table
-#define	PMKID_NO                        4     // Number of PMKID saved supported
+#define WDS_PAIRWISE_KEY_OFFSET         60	// WDS links uses pairwise key#60 ~ 63 in ASIC pairwise key table
+#define	PMKID_NO                        4	// Number of PMKID saved supported
 #define MAX_LEN_OF_MLME_BUFFER          2048
 
 // power status related definitions
 #define PWR_ACTIVE                      0
 #define PWR_SAVE                        1
-#define PWR_MMPS                        2			//MIMO power save
+#define PWR_MMPS                        2	//MIMO power save
 
 // Auth and Assoc mode related definitions
 #define AUTH_MODE_OPEN                  0x00
 #define AUTH_MODE_KEY                   0x01
 
 // BSS Type definitions
-#define BSS_ADHOC                       0  // = Ndis802_11IBSS
-#define BSS_INFRA                       1  // = Ndis802_11Infrastructure
-#define BSS_ANY                         2  // = Ndis802_11AutoUnknown
-#define BSS_MONITOR			            3  // = Ndis802_11Monitor
-
+#define BSS_ADHOC                       0	// = Ndis802_11IBSS
+#define BSS_INFRA                       1	// = Ndis802_11Infrastructure
+#define BSS_ANY                         2	// = Ndis802_11AutoUnknown
+#define BSS_MONITOR			            3	// = Ndis802_11Monitor
 
 // Reason code definitions
 #define REASON_RESERVED                 0
@@ -533,65 +525,63 @@
 #define IE_CF_PARM                      4
 #define IE_TIM                          5
 #define IE_IBSS_PARM                    6
-#define IE_COUNTRY                      7     // 802.11d
-#define IE_802_11D_REQUEST              10    // 802.11d
-#define IE_QBSS_LOAD                    11    // 802.11e d9
-#define IE_EDCA_PARAMETER               12    // 802.11e d9
-#define IE_TSPEC                        13    // 802.11e d9
-#define IE_TCLAS                        14    // 802.11e d9
-#define IE_SCHEDULE                     15    // 802.11e d9
+#define IE_COUNTRY                      7	// 802.11d
+#define IE_802_11D_REQUEST              10	// 802.11d
+#define IE_QBSS_LOAD                    11	// 802.11e d9
+#define IE_EDCA_PARAMETER               12	// 802.11e d9
+#define IE_TSPEC                        13	// 802.11e d9
+#define IE_TCLAS                        14	// 802.11e d9
+#define IE_SCHEDULE                     15	// 802.11e d9
 #define IE_CHALLENGE_TEXT               16
-#define IE_POWER_CONSTRAINT             32    // 802.11h d3.3
-#define IE_POWER_CAPABILITY             33    // 802.11h d3.3
-#define IE_TPC_REQUEST                  34    // 802.11h d3.3
-#define IE_TPC_REPORT                   35    // 802.11h d3.3
-#define IE_SUPP_CHANNELS                36    // 802.11h d3.3
-#define IE_CHANNEL_SWITCH_ANNOUNCEMENT  37    // 802.11h d3.3
-#define IE_MEASUREMENT_REQUEST          38    // 802.11h d3.3
-#define IE_MEASUREMENT_REPORT           39    // 802.11h d3.3
-#define IE_QUIET                        40    // 802.11h d3.3
-#define IE_IBSS_DFS                     41    // 802.11h d3.3
-#define IE_ERP                          42    // 802.11g
-#define IE_TS_DELAY                     43    // 802.11e d9
-#define IE_TCLAS_PROCESSING             44    // 802.11e d9
-#define IE_QOS_CAPABILITY               46    // 802.11e d6
-#define IE_HT_CAP                       45    // 802.11n d1. HT CAPABILITY. ELEMENT ID TBD
-#define IE_AP_CHANNEL_REPORT			51    // 802.11k d6
-#define IE_HT_CAP2                         52    // 802.11n d1. HT CAPABILITY. ELEMENT ID TBD
-#define IE_RSN                          48    // 802.11i d3.0
-#define IE_WPA2                         48    // WPA2
-#define IE_EXT_SUPP_RATES               50    // 802.11g
-#define IE_SUPP_REG_CLASS               59    // 802.11y. Supported regulatory classes.
+#define IE_POWER_CONSTRAINT             32	// 802.11h d3.3
+#define IE_POWER_CAPABILITY             33	// 802.11h d3.3
+#define IE_TPC_REQUEST                  34	// 802.11h d3.3
+#define IE_TPC_REPORT                   35	// 802.11h d3.3
+#define IE_SUPP_CHANNELS                36	// 802.11h d3.3
+#define IE_CHANNEL_SWITCH_ANNOUNCEMENT  37	// 802.11h d3.3
+#define IE_MEASUREMENT_REQUEST          38	// 802.11h d3.3
+#define IE_MEASUREMENT_REPORT           39	// 802.11h d3.3
+#define IE_QUIET                        40	// 802.11h d3.3
+#define IE_IBSS_DFS                     41	// 802.11h d3.3
+#define IE_ERP                          42	// 802.11g
+#define IE_TS_DELAY                     43	// 802.11e d9
+#define IE_TCLAS_PROCESSING             44	// 802.11e d9
+#define IE_QOS_CAPABILITY               46	// 802.11e d6
+#define IE_HT_CAP                       45	// 802.11n d1. HT CAPABILITY. ELEMENT ID TBD
+#define IE_AP_CHANNEL_REPORT			51	// 802.11k d6
+#define IE_HT_CAP2                         52	// 802.11n d1. HT CAPABILITY. ELEMENT ID TBD
+#define IE_RSN                          48	// 802.11i d3.0
+#define IE_WPA2                         48	// WPA2
+#define IE_EXT_SUPP_RATES               50	// 802.11g
+#define IE_SUPP_REG_CLASS               59	// 802.11y. Supported regulatory classes.
 #define IE_EXT_CHANNEL_SWITCH_ANNOUNCEMENT	60	// 802.11n
-#define IE_ADD_HT                         61    // 802.11n d1. ADDITIONAL HT CAPABILITY. ELEMENT ID TBD
-#define IE_ADD_HT2                        53    // 802.11n d1. ADDITIONAL HT CAPABILITY. ELEMENT ID TBD
-
+#define IE_ADD_HT                         61	// 802.11n d1. ADDITIONAL HT CAPABILITY. ELEMENT ID TBD
+#define IE_ADD_HT2                        53	// 802.11n d1. ADDITIONAL HT CAPABILITY. ELEMENT ID TBD
 
 // For 802.11n D3.03
 //#define IE_NEW_EXT_CHA_OFFSET             62    // 802.11n d1. New extension channel offset elemet
-#define IE_SECONDARY_CH_OFFSET		62	// 802.11n D3.03	Secondary Channel Offset element
-#define IE_WAPI							68		// WAPI information element
-#define IE_2040_BSS_COEXIST               72    // 802.11n D3.0.3
-#define IE_2040_BSS_INTOLERANT_REPORT     73    // 802.11n D3.03
-#define IE_OVERLAPBSS_SCAN_PARM           74    // 802.11n D3.03
-#define IE_EXT_CAPABILITY                127   // 802.11n D3.03
-
-
-#define IE_WPA                          221   // WPA
-#define IE_VENDOR_SPECIFIC              221   // Wifi WMM (WME)
-
-#define OUI_BROADCOM_HT              51   //
-#define OUI_BROADCOM_HTADD              52   //
-#define OUI_PREN_HT_CAP              51   //
-#define OUI_PREN_ADD_HT              52   //
+#define IE_SECONDARY_CH_OFFSET		62	// 802.11n D3.03        Secondary Channel Offset element
+#define IE_WAPI							68	// WAPI information element
+#define IE_2040_BSS_COEXIST               72	// 802.11n D3.0.3
+#define IE_2040_BSS_INTOLERANT_REPORT     73	// 802.11n D3.03
+#define IE_OVERLAPBSS_SCAN_PARM           74	// 802.11n D3.03
+#define IE_EXT_CAPABILITY                127	// 802.11n D3.03
+
+#define IE_WPA                          221	// WPA
+#define IE_VENDOR_SPECIFIC              221	// Wifi WMM (WME)
+
+#define OUI_BROADCOM_HT              51	//
+#define OUI_BROADCOM_HTADD              52	//
+#define OUI_PREN_HT_CAP              51	//
+#define OUI_PREN_ADD_HT              52	//
 
 // CCX information
-#define IE_AIRONET_CKIP                 133   // CCX1.0 ID 85H for CKIP
-#define IE_AP_TX_POWER                  150   // CCX 2.0 for AP transmit power
-#define IE_MEASUREMENT_CAPABILITY       221   // CCX 2.0
+#define IE_AIRONET_CKIP                 133	// CCX1.0 ID 85H for CKIP
+#define IE_AP_TX_POWER                  150	// CCX 2.0 for AP transmit power
+#define IE_MEASUREMENT_CAPABILITY       221	// CCX 2.0
 #define IE_CCX_V2                       221
-#define IE_AIRONET_IPADDRESS            149   // CCX ID 95H for IP Address
-#define IE_AIRONET_CCKMREASSOC          156   // CCX ID 9CH for CCKM Reassociation Request element
+#define IE_AIRONET_IPADDRESS            149	// CCX ID 95H for IP Address
+#define IE_AIRONET_CCKMREASSOC          156	// CCX ID 9CH for CCKM Reassociation Request element
 #define CKIP_NEGOTIATION_LENGTH         30
 #define AIRONET_IPADDRESS_LENGTH        10
 #define AIRONET_CCKMREASSOC_LENGTH      24
@@ -619,11 +609,8 @@
 #define WSC_STATE_MACHINE            17
 #define WSC_UPNP_STATE_MACHINE		    18
 
-
 #define WPA_STATE_MACHINE			23
 
-
-
 //
 // STA's CONTROL/CONNECT state machine: states, events, total function #
 //
@@ -700,10 +687,9 @@
 #define MT2_PEER_PUBLIC_CATE             4
 #define MT2_PEER_RM_CATE             5
 /* "FT_CATEGORY_BSS_TRANSITION equal to 6" is defined file of "dot11r_ft.h" */
-#define MT2_PEER_HT_CATE             7	//	7.4.7
+#define MT2_PEER_HT_CATE             7	//      7.4.7
 #define MAX_PEER_CATE_MSG                   7
 
-
 #define MT2_MLME_ADD_BA_CATE             8
 #define MT2_MLME_ORI_DELBA_CATE             9
 #define MT2_MLME_REC_DELBA_CATE             10
@@ -721,7 +707,6 @@
 #define CATEGORY_RM			5
 #define CATEGORY_HT			7
 
-
 // DLS Action frame definition
 #define ACTION_DLS_REQUEST			0
 #define ACTION_DLS_RESPONSE			1
@@ -734,7 +719,6 @@
 #define SPEC_TPCRP	3
 #define SPEC_CHANNEL_SWITCH	4
 
-
 //BA  Action field value
 #define ADDBA_REQ	0
 #define ADDBA_RESP	1
@@ -748,10 +732,9 @@
 #define ACTION_EXT_CH_SWITCH_ANNOUNCE		4	// 11y D9.0
 #define ACTION_DSE_MEASUREMENT_REQ			5	// 11y D9.0
 #define ACTION_DSE_MEASUREMENT_REPORT		6	// 11y D9.0
-#define ACTION_MEASUREMENT_PILOT_ACTION		7  	// 11y D9.0
+#define ACTION_MEASUREMENT_PILOT_ACTION		7	// 11y D9.0
 #define ACTION_DSE_POWER_CONSTRAINT			8	// 11y D9.0
 
-
 //HT  Action field value
 #define NOTIFY_BW_ACTION				0
 #define SMPS_ACTION						1
@@ -798,7 +781,7 @@
 //
 // STA's SYNC state machine: states, events, total function #
 //
-#define SYNC_IDLE                       0  // merge NO_BSS,IBSS_IDLE,IBSS_ACTIVE and BSS in to 1 state
+#define SYNC_IDLE                       0	// merge NO_BSS,IBSS_IDLE,IBSS_ACTIVE and BSS in to 1 state
 #define JOIN_WAIT_BEACON                1
 #define SCAN_LISTEN                     2
 #define MAX_SYNC_STATE                  3
@@ -907,8 +890,6 @@
 
 #define WPA_FUNC_SIZE                (MAX_WPA_PTK_STATE * MAX_WPA_MSG)
 
-
-
 // =============================================================================
 
 // value domain of 802.11 header FC.Tyte, which is b3..b2 of the 1st-byte of MAC header
@@ -961,10 +942,10 @@
 #define SUBTYPE_QOS_CFACK_CFPOLL    15
 
 // ACK policy of QOS Control field bit 6:5
-#define NORMAL_ACK                  0x00  // b6:5 = 00
-#define NO_ACK                      0x20  // b6:5 = 01
-#define NO_EXPLICIT_ACK             0x40  // b6:5 = 10
-#define BLOCK_ACK                   0x60  // b6:5 = 11
+#define NORMAL_ACK                  0x00	// b6:5 = 00
+#define NO_ACK                      0x20	// b6:5 = 01
+#define NO_EXPLICIT_ACK             0x40	// b6:5 = 10
+#define BLOCK_ACK                   0x60	// b6:5 = 11
 
 //
 // rtmp_data.c use these definition
@@ -982,7 +963,7 @@
 #define LENGTH_CRC                  4
 #define MAX_SEQ_NUMBER              0x0fff
 #define LENGTH_802_3_NO_TYPE		12
-#define LENGTH_802_1Q				4 /* VLAN related */
+#define LENGTH_802_1Q				4	/* VLAN related */
 
 // STA_CSR4.field.TxResult
 #define TX_RESULT_SUCCESS           0
@@ -999,23 +980,23 @@
 #define MODE_HTGREENFIELD	3
 
 // MCS for CCK.  BW.SGI.STBC are reserved
-#define MCS_LONGP_RATE_1                      0	 // long preamble CCK 1Mbps
+#define MCS_LONGP_RATE_1                      0	// long preamble CCK 1Mbps
 #define MCS_LONGP_RATE_2                      1	// long preamble CCK 1Mbps
 #define MCS_LONGP_RATE_5_5                    2
 #define MCS_LONGP_RATE_11                     3
-#define MCS_SHORTP_RATE_1                      4	 // long preamble CCK 1Mbps. short is forbidden in 1Mbps
+#define MCS_SHORTP_RATE_1                      4	// long preamble CCK 1Mbps. short is forbidden in 1Mbps
 #define MCS_SHORTP_RATE_2                      5	// short preamble CCK 2Mbps
 #define MCS_SHORTP_RATE_5_5                    6
 #define MCS_SHORTP_RATE_11                     7
 // To send duplicate legacy OFDM. set BW=BW_40.  SGI.STBC are reserved
-#define MCS_RATE_6                      0   // legacy OFDM
-#define MCS_RATE_9                      1   // OFDM
-#define MCS_RATE_12                     2   // OFDM
-#define MCS_RATE_18                     3   // OFDM
-#define MCS_RATE_24                     4  // OFDM
-#define MCS_RATE_36                     5   // OFDM
-#define MCS_RATE_48                     6  // OFDM
-#define MCS_RATE_54                     7 // OFDM
+#define MCS_RATE_6                      0	// legacy OFDM
+#define MCS_RATE_9                      1	// OFDM
+#define MCS_RATE_12                     2	// OFDM
+#define MCS_RATE_18                     3	// OFDM
+#define MCS_RATE_24                     4	// OFDM
+#define MCS_RATE_36                     5	// OFDM
+#define MCS_RATE_48                     6	// OFDM
+#define MCS_RATE_54                     7	// OFDM
 // HT
 #define MCS_0		0	// 1S
 #define MCS_1		1
@@ -1070,7 +1051,7 @@
 #define RXSTBC_TWO	2	// rx support of 1 and 2 spatial stream
 #define RXSTBC_THR	3	// rx support of 1~3 spatial stream
 // MCS FEEDBACK
-#define MCSFBK_NONE	0  // not support mcs feedback /
+#define MCSFBK_NONE	0	// not support mcs feedback /
 #define MCSFBK_RSV	1	// reserved
 #define MCSFBK_UNSOLICIT	2	// only support unsolict mcs feedback
 #define MCSFBK_MRQ	3	// response to both MRQ and unsolict mcs feedback
@@ -1081,7 +1062,6 @@
 #define   MMPS_RSV		2
 #define MMPS_ENABLE		3
 
-
 // A-MSDU size
 #define	AMSDU_0	0
 #define	AMSDU_1		1
@@ -1094,28 +1074,28 @@
 #define RATE_2                      1
 #define RATE_5_5                    2
 #define RATE_11                     3
-#define RATE_6                      4   // OFDM
-#define RATE_9                      5   // OFDM
-#define RATE_12                     6   // OFDM
-#define RATE_18                     7   // OFDM
-#define RATE_24                     8   // OFDM
-#define RATE_36                     9   // OFDM
-#define RATE_48                     10  // OFDM
-#define RATE_54                     11  // OFDM
+#define RATE_6                      4	// OFDM
+#define RATE_9                      5	// OFDM
+#define RATE_12                     6	// OFDM
+#define RATE_18                     7	// OFDM
+#define RATE_24                     8	// OFDM
+#define RATE_36                     9	// OFDM
+#define RATE_48                     10	// OFDM
+#define RATE_54                     11	// OFDM
 #define RATE_FIRST_OFDM_RATE        RATE_6
 #define RATE_LAST_OFDM_RATE        	RATE_54
-#define RATE_6_5                    12  // HT mix
-#define RATE_13                     13  // HT mix
-#define RATE_19_5                   14  // HT mix
-#define RATE_26                     15  // HT mix
-#define RATE_39                     16  // HT mix
-#define RATE_52                     17  // HT mix
-#define RATE_58_5                   18  // HT mix
-#define RATE_65                     19  // HT mix
-#define RATE_78                     20  // HT mix
-#define RATE_104                    21  // HT mix
-#define RATE_117                    22  // HT mix
-#define RATE_130                    23  // HT mix
+#define RATE_6_5                    12	// HT mix
+#define RATE_13                     13	// HT mix
+#define RATE_19_5                   14	// HT mix
+#define RATE_26                     15	// HT mix
+#define RATE_39                     16	// HT mix
+#define RATE_52                     17	// HT mix
+#define RATE_58_5                   18	// HT mix
+#define RATE_65                     19	// HT mix
+#define RATE_78                     20	// HT mix
+#define RATE_104                    21	// HT mix
+#define RATE_117                    22	// HT mix
+#define RATE_130                    23	// HT mix
 //#define RATE_AUTO_SWITCH            255 // for StaCfg.FixedTxRate only
 #define HTRATE_0                      12
 #define RATE_FIRST_MM_RATE        HTRATE_0
@@ -1134,34 +1114,34 @@
 
 // Country Region definition
 #define REGION_MINIMUM_BG_BAND            0
-#define REGION_0_BG_BAND                  0       // 1-11
-#define REGION_1_BG_BAND                  1       // 1-13
-#define REGION_2_BG_BAND                  2       // 10-11
-#define REGION_3_BG_BAND                  3       // 10-13
-#define REGION_4_BG_BAND                  4       // 14
-#define REGION_5_BG_BAND                  5       // 1-14
-#define REGION_6_BG_BAND                  6       // 3-9
-#define REGION_7_BG_BAND                  7       // 5-13
-#define REGION_31_BG_BAND                 31       // 5-13
+#define REGION_0_BG_BAND                  0	// 1-11
+#define REGION_1_BG_BAND                  1	// 1-13
+#define REGION_2_BG_BAND                  2	// 10-11
+#define REGION_3_BG_BAND                  3	// 10-13
+#define REGION_4_BG_BAND                  4	// 14
+#define REGION_5_BG_BAND                  5	// 1-14
+#define REGION_6_BG_BAND                  6	// 3-9
+#define REGION_7_BG_BAND                  7	// 5-13
+#define REGION_31_BG_BAND                 31	// 5-13
 #define REGION_MAXIMUM_BG_BAND            7
 
 #define REGION_MINIMUM_A_BAND             0
-#define REGION_0_A_BAND                   0       // 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165
-#define REGION_1_A_BAND                   1       // 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140
-#define REGION_2_A_BAND                   2       // 36, 40, 44, 48, 52, 56, 60, 64
-#define REGION_3_A_BAND                   3       // 52, 56, 60, 64, 149, 153, 157, 161
-#define REGION_4_A_BAND                   4       // 149, 153, 157, 161, 165
-#define REGION_5_A_BAND                   5       // 149, 153, 157, 161
-#define REGION_6_A_BAND                   6       // 36, 40, 44, 48
-#define REGION_7_A_BAND                   7       // 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165, 169, 173
-#define REGION_8_A_BAND                   8       // 52, 56, 60, 64
-#define REGION_9_A_BAND                   9       // 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 132, 136, 140, 149, 153, 157, 161, 165
-#define REGION_10_A_BAND                  10	  // 36, 40, 44, 48, 149, 153, 157, 161, 165
-#define REGION_11_A_BAND                  11	  // 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 149, 153, 157, 161
-#define REGION_12_A_BAND                  12       // 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140
-#define REGION_13_A_BAND                  13       // 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161
-#define REGION_14_A_BAND                  14       // 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 136, 140, 149, 153, 157, 161, 165
-#define REGION_15_A_BAND                  15       // 149, 153, 157, 161, 165, 169, 173
+#define REGION_0_A_BAND                   0	// 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165
+#define REGION_1_A_BAND                   1	// 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140
+#define REGION_2_A_BAND                   2	// 36, 40, 44, 48, 52, 56, 60, 64
+#define REGION_3_A_BAND                   3	// 52, 56, 60, 64, 149, 153, 157, 161
+#define REGION_4_A_BAND                   4	// 149, 153, 157, 161, 165
+#define REGION_5_A_BAND                   5	// 149, 153, 157, 161
+#define REGION_6_A_BAND                   6	// 36, 40, 44, 48
+#define REGION_7_A_BAND                   7	// 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165, 169, 173
+#define REGION_8_A_BAND                   8	// 52, 56, 60, 64
+#define REGION_9_A_BAND                   9	// 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 132, 136, 140, 149, 153, 157, 161, 165
+#define REGION_10_A_BAND                  10	// 36, 40, 44, 48, 149, 153, 157, 161, 165
+#define REGION_11_A_BAND                  11	// 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 149, 153, 157, 161
+#define REGION_12_A_BAND                  12	// 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140
+#define REGION_13_A_BAND                  13	// 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161
+#define REGION_14_A_BAND                  14	// 36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 136, 140, 149, 153, 157, 161, 165
+#define REGION_15_A_BAND                  15	// 149, 153, 157, 161, 165, 169, 173
 #define REGION_MAXIMUM_A_BAND             15
 
 // pTxD->CipherAlg
@@ -1172,10 +1152,9 @@
 #define CIPHER_AES                  4
 #define CIPHER_CKIP64               5
 #define CIPHER_CKIP128              6
-#define CIPHER_TKIP_NO_MIC          7       // MIC appended by driver: not a valid value in hardware key table
+#define CIPHER_TKIP_NO_MIC          7	// MIC appended by driver: not a valid value in hardware key table
 #define CIPHER_SMS4					8
 
-
 // LED Status.
 #define LED_LINK_DOWN               0
 #define LED_LINK_UP                 1
@@ -1189,11 +1168,11 @@
 // value domain of pAd->LedCntl.LedMode and E2PROM
 #define LED_MODE_DEFAULT            0
 #define LED_MODE_TWO_LED			1
-//#define LED_MODE_SIGNAL_STREGTH		8  // EEPROM define =8
-#define LED_MODE_SIGNAL_STREGTH		0x40 // EEPROM define = 64
+//#define LED_MODE_SIGNAL_STREGTH               8  // EEPROM define =8
+#define LED_MODE_SIGNAL_STREGTH		0x40	// EEPROM define = 64
 
 // RC4 init value, used fro WEP & TKIP
-#define PPPINITFCS32                0xffffffff   /* Initial FCS value */
+#define PPPINITFCS32                0xffffffff	/* Initial FCS value */
 
 // value domain of pAd->StaCfg.PortSecured. 802.1X controlled port definition
 #define WPA_802_1X_PORT_SECURED     1
@@ -1205,7 +1184,6 @@
 //definition of DRS
 #define MAX_STEP_OF_TX_RATE_SWITCH	32
 
-
 // pre-allocated free NDIS PACKET/BUFFER poll for internal usage
 #define MAX_NUM_OF_FREE_NDIS_PACKET 128
 
@@ -1223,7 +1201,7 @@
 #define DEFAULT_RF_TX_POWER         5
 
 #define MAX_INI_BUFFER_SIZE			4096
-#define MAX_PARAM_BUFFER_SIZE		(2048) // enough for ACL (18*64)
+#define MAX_PARAM_BUFFER_SIZE		(2048)	// enough for ACL (18*64)
 											//18 : the length of Mac address acceptable format "01:02:03:04:05:06;")
 											//64 : MAX_NUM_OF_ACL_LIST
 // definition of pAd->OpMode
@@ -1233,10 +1211,10 @@
 
 // ========================= AP rtmp_def.h ===========================
 // value domain for pAd->EventTab.Log[].Event
-#define EVENT_RESET_ACCESS_POINT    0 // Log = "hh:mm:ss   Restart Access Point"
-#define EVENT_ASSOCIATED            1 // Log = "hh:mm:ss   STA 00:01:02:03:04:05 associated"
-#define EVENT_DISASSOCIATED         2 // Log = "hh:mm:ss   STA 00:01:02:03:04:05 left this BSS"
-#define EVENT_AGED_OUT              3 // Log = "hh:mm:ss   STA 00:01:02:03:04:05 was aged-out and removed from this BSS"
+#define EVENT_RESET_ACCESS_POINT    0	// Log = "hh:mm:ss   Restart Access Point"
+#define EVENT_ASSOCIATED            1	// Log = "hh:mm:ss   STA 00:01:02:03:04:05 associated"
+#define EVENT_DISASSOCIATED         2	// Log = "hh:mm:ss   STA 00:01:02:03:04:05 left this BSS"
+#define EVENT_AGED_OUT              3	// Log = "hh:mm:ss   STA 00:01:02:03:04:05 was aged-out and removed from this BSS"
 #define EVENT_COUNTER_M             4
 #define EVENT_INVALID_PSK           5
 #define EVENT_MAX_EVENT_TYPE        6
@@ -1262,7 +1240,6 @@
 // MBSSID definition
 #define ENTRY_NOT_FOUND             0xFF
 
-
 /* After Linux 2.6.9,
  * VLAN module use Private (from user) interface flags (netdevice->priv_flags).
  * #define IFF_802_1Q_VLAN 0x1         --    802.1Q VLAN device.  in if.h
@@ -1282,13 +1259,10 @@
 #define INF_APCLI_DEV_NAME		"apcli"
 #define INF_MESH_DEV_NAME		"mesh"
 
-
 // WEP Key TYPE
 #define WEP_HEXADECIMAL_TYPE    0
 #define WEP_ASCII_TYPE          1
 
-
-
 // WIRELESS EVENTS definition
 /* Max number of char in custom event, refer to wireless_tools.28/wireless.20.h */
 #define IW_CUSTOM_MAX_LEN				  			255	/* In bytes */
@@ -1375,7 +1349,6 @@
 #define GUI_IDLE_POWER_SAVE		3
 // --
 
-
 // definition for WpaSupport flag
 #define WPA_SUPPLICANT_DISABLE				0
 #define WPA_SUPPLICANT_ENABLE				1
@@ -1418,10 +1391,8 @@
 #define cpu2be16(x) SWAP16((x))
 #define be2cpu16(x) SWAP16((x))
 
-
 #define ABS(_x, _y) ((_x) > (_y)) ? ((_x) -(_y)) : ((_y) -(_x))
 
-
 #define A2Dec(_X, _p)				\
 {									\
 	UCHAR *p;						\
@@ -1435,7 +1406,6 @@
 	}												\
 }
 
-
 #define A2Hex(_X, _p)				\
 do{									\
 	char *__p;						\
@@ -1453,6 +1423,4 @@ do{									\
 	}												\
 }while(0)
 
-#endif  // __RTMP_DEF_H__
-
-
+#endif // __RTMP_DEF_H__
--- a/drivers/staging/rt2860/rtmp_dot11.h
+++ b/drivers/staging/rt2860/rtmp_dot11.h
@@ -30,73 +30,71 @@
 
 #include "rtmp_type.h"
 
-
 // 4-byte HTC field.  maybe included in any frame except non-QOS data frame.  The Order bit must set 1.
 typedef struct PACKED {
-    UINT32		MA:1;	//management action payload exist in (QoS Null+HTC)
-    UINT32		TRQ:1;	//sounding request
-    UINT32		MRQ:1;	//MCS feedback. Request for a MCS feedback
-    UINT32		MRSorASI:3;	// MRQ Sequence identifier. unchanged during entire procedure. 0x000-0x110.
-    UINT32		MFS:3;	//SET to the received value of MRS. 0x111 for unsolicited MFB.
-    UINT32		MFBorASC:7;	//Link adaptation feedback containing recommended MCS. 0x7f for no feedback or not available
-    UINT32		CalPos:2;	// calibration position
-    UINT32		CalSeq:2;  //calibration sequence
-    UINT32		FBKReq:2;	//feedback request
-    UINT32		CSISTEERING:2;	//CSI/ STEERING
-    UINT32		ZLFAnnouce:1;	// ZLF announcement
-    UINT32		rsv:5;  //calibration sequence
-    UINT32		ACConstraint:1;	//feedback request
-    UINT32		RDG:1;	//RDG / More PPDU
+	UINT32 MA:1;		//management action payload exist in (QoS Null+HTC)
+	UINT32 TRQ:1;		//sounding request
+	UINT32 MRQ:1;		//MCS feedback. Request for a MCS feedback
+	UINT32 MRSorASI:3;	// MRQ Sequence identifier. unchanged during entire procedure. 0x000-0x110.
+	UINT32 MFS:3;		//SET to the received value of MRS. 0x111 for unsolicited MFB.
+	UINT32 MFBorASC:7;	//Link adaptation feedback containing recommended MCS. 0x7f for no feedback or not available
+	UINT32 CalPos:2;	// calibration position
+	UINT32 CalSeq:2;	//calibration sequence
+	UINT32 FBKReq:2;	//feedback request
+	UINT32 CSISTEERING:2;	//CSI/ STEERING
+	UINT32 ZLFAnnouce:1;	// ZLF announcement
+	UINT32 rsv:5;		//calibration sequence
+	UINT32 ACConstraint:1;	//feedback request
+	UINT32 RDG:1;		//RDG / More PPDU
 } HT_CONTROL, *PHT_CONTROL;
 
 // 2-byte QOS CONTROL field
 typedef struct PACKED {
-    USHORT      TID:4;
-    USHORT      EOSP:1;
-    USHORT      AckPolicy:2;  //0: normal ACK 1:No ACK 2:scheduled under MTBA/PSMP  3: BA
-    USHORT      AMsduPresent:1;
-    USHORT      Txop_QueueSize:8;
+	USHORT TID:4;
+	USHORT EOSP:1;
+	USHORT AckPolicy:2;	//0: normal ACK 1:No ACK 2:scheduled under MTBA/PSMP  3: BA
+	USHORT AMsduPresent:1;
+	USHORT Txop_QueueSize:8;
 } QOS_CONTROL, *PQOS_CONTROL;
 
-
 // 2-byte Frame control field
-typedef	struct	PACKED {
-	USHORT		Ver:2;				// Protocol version
-	USHORT		Type:2;				// MSDU type
-	USHORT		SubType:4;			// MSDU subtype
-	USHORT		ToDs:1;				// To DS indication
-	USHORT		FrDs:1;				// From DS indication
-	USHORT		MoreFrag:1;			// More fragment bit
-	USHORT		Retry:1;			// Retry status bit
-	USHORT		PwrMgmt:1;			// Power management bit
-	USHORT		MoreData:1;			// More data bit
-	USHORT		Wep:1;				// Wep data
-	USHORT		Order:1;			// Strict order expected
+typedef struct PACKED {
+	USHORT Ver:2;		// Protocol version
+	USHORT Type:2;		// MSDU type
+	USHORT SubType:4;	// MSDU subtype
+	USHORT ToDs:1;		// To DS indication
+	USHORT FrDs:1;		// From DS indication
+	USHORT MoreFrag:1;	// More fragment bit
+	USHORT Retry:1;		// Retry status bit
+	USHORT PwrMgmt:1;	// Power management bit
+	USHORT MoreData:1;	// More data bit
+	USHORT Wep:1;		// Wep data
+	USHORT Order:1;		// Strict order expected
 } FRAME_CONTROL, *PFRAME_CONTROL;
 
-typedef	struct	PACKED _HEADER_802_11	{
-    FRAME_CONTROL   FC;
-    USHORT          Duration;
-    UCHAR           Addr1[MAC_ADDR_LEN];
-    UCHAR           Addr2[MAC_ADDR_LEN];
-	UCHAR			Addr3[MAC_ADDR_LEN];
-	USHORT			Frag:4;
-	USHORT			Sequence:12;
-	UCHAR			Octet[0];
-}	HEADER_802_11, *PHEADER_802_11;
+typedef struct PACKED _HEADER_802_11 {
+	FRAME_CONTROL FC;
+	USHORT Duration;
+	UCHAR Addr1[MAC_ADDR_LEN];
+	UCHAR Addr2[MAC_ADDR_LEN];
+	UCHAR Addr3[MAC_ADDR_LEN];
+	USHORT Frag:4;
+	USHORT Sequence:12;
+	UCHAR Octet[0];
+} HEADER_802_11, *PHEADER_802_11;
 
 typedef struct PACKED _PSPOLL_FRAME {
-    FRAME_CONTROL   FC;
-    USHORT          Aid;
-    UCHAR           Bssid[MAC_ADDR_LEN];
-    UCHAR           Ta[MAC_ADDR_LEN];
-}   PSPOLL_FRAME, *PPSPOLL_FRAME;
-
-typedef	struct	PACKED _RTS_FRAME	{
-    FRAME_CONTROL   FC;
-    USHORT          Duration;
-    UCHAR           Addr1[MAC_ADDR_LEN];
-    UCHAR           Addr2[MAC_ADDR_LEN];
-}RTS_FRAME, *PRTS_FRAME;
+	FRAME_CONTROL FC;
+	USHORT Aid;
+	UCHAR Bssid[MAC_ADDR_LEN];
+	UCHAR Ta[MAC_ADDR_LEN];
+} PSPOLL_FRAME, *PPSPOLL_FRAME;
+
+typedef struct PACKED _RTS_FRAME {
+	FRAME_CONTROL FC;
+	USHORT Duration;
+	UCHAR Addr1[MAC_ADDR_LEN];
+	UCHAR Addr2[MAC_ADDR_LEN];
+} RTS_FRAME, *PRTS_FRAME;
 
 #endif // __DOT11_BASE_H__ //
--- a/drivers/staging/rt2860/rtmp.h
+++ b/drivers/staging/rt2860/rtmp.h
@@ -44,17 +44,14 @@
 #include "rtmp_dot11.h"
 #include "rtmp_chip.h"
 
-
-typedef struct _RTMP_ADAPTER		RTMP_ADAPTER;
-typedef struct _RTMP_ADAPTER		*PRTMP_ADAPTER;
+typedef struct _RTMP_ADAPTER RTMP_ADAPTER;
+typedef struct _RTMP_ADAPTER *PRTMP_ADAPTER;
 
 typedef struct _RTMP_CHIP_OP_ RTMP_CHIP_OP;
 
+//#define DBG           1
 
-//#define DBG		1
-
-//#define DBG_DIAGNOSE		1
-
+//#define DBG_DIAGNOSE          1
 
 //+++Add by shiang for merge MiniportMMRequest() and MiniportDataMMRequest() into one function
 #define MAX_DATAMM_RETRY	3
@@ -63,17 +60,17 @@ typedef struct _RTMP_CHIP_OP_ RTMP_CHIP_
 
 #define	MAXSEQ		(0xFFF)
 
-extern  unsigned char   SNAP_AIRONET[];
-extern  unsigned char   CISCO_OUI[];
-extern  UCHAR	BaSizeArray[4];
+extern unsigned char SNAP_AIRONET[];
+extern unsigned char CISCO_OUI[];
+extern UCHAR BaSizeArray[4];
 
 extern UCHAR BROADCAST_ADDR[MAC_ADDR_LEN];
 extern UCHAR ZERO_MAC_ADDR[MAC_ADDR_LEN];
 extern ULONG BIT32[32];
 extern UCHAR BIT8[8];
-extern char* CipherName[];
-extern char* MCSToMbps[];
-extern UCHAR	 RxwiMCSToOfdmRate[12];
+extern char *CipherName[];
+extern char *MCSToMbps[];
+extern UCHAR RxwiMCSToOfdmRate[12];
 extern UCHAR SNAP_802_1H[6];
 extern UCHAR SNAP_BRIDGE_TUNNEL[6];
 extern UCHAR SNAP_AIRONET[8];
@@ -82,9 +79,9 @@ extern UCHAR EAPOL_LLC_SNAP[8];
 extern UCHAR EAPOL[2];
 extern UCHAR IPX[2];
 extern UCHAR APPLE_TALK[2];
-extern UCHAR RateIdToPlcpSignal[12]; // see IEEE802.11a-1999 p.14
-extern UCHAR	 OfdmRateToRxwiMCS[];
-extern UCHAR OfdmSignalToRateId[16] ;
+extern UCHAR RateIdToPlcpSignal[12];	// see IEEE802.11a-1999 p.14
+extern UCHAR OfdmRateToRxwiMCS[];
+extern UCHAR OfdmSignalToRateId[16];
 extern UCHAR default_cwmin[4];
 extern UCHAR default_cwmax[4];
 extern UCHAR default_sta_aifsn[4];
@@ -92,92 +89,88 @@ extern UCHAR MapUserPriorityToAccessCate
 
 extern USHORT RateUpPER[];
 extern USHORT RateDownPER[];
-extern UCHAR  Phy11BNextRateDownward[];
-extern UCHAR  Phy11BNextRateUpward[];
-extern UCHAR  Phy11BGNextRateDownward[];
-extern UCHAR  Phy11BGNextRateUpward[];
-extern UCHAR  Phy11ANextRateDownward[];
-extern UCHAR  Phy11ANextRateUpward[];
-extern CHAR   RssiSafeLevelForTxRate[];
-extern UCHAR  RateIdToMbps[];
+extern UCHAR Phy11BNextRateDownward[];
+extern UCHAR Phy11BNextRateUpward[];
+extern UCHAR Phy11BGNextRateDownward[];
+extern UCHAR Phy11BGNextRateUpward[];
+extern UCHAR Phy11ANextRateDownward[];
+extern UCHAR Phy11ANextRateUpward[];
+extern CHAR RssiSafeLevelForTxRate[];
+extern UCHAR RateIdToMbps[];
 extern USHORT RateIdTo500Kbps[];
 
-extern UCHAR  CipherSuiteWpaNoneTkip[];
-extern UCHAR  CipherSuiteWpaNoneTkipLen;
-
-extern UCHAR  CipherSuiteWpaNoneAes[];
-extern UCHAR  CipherSuiteWpaNoneAesLen;
+extern UCHAR CipherSuiteWpaNoneTkip[];
+extern UCHAR CipherSuiteWpaNoneTkipLen;
 
-extern UCHAR  SsidIe;
-extern UCHAR  SupRateIe;
-extern UCHAR  ExtRateIe;
-
-extern UCHAR  HtCapIe;
-extern UCHAR  AddHtInfoIe;
-extern UCHAR  NewExtChanIe;
-
-extern UCHAR  ErpIe;
-extern UCHAR  DsIe;
-extern UCHAR  TimIe;
-extern UCHAR  WpaIe;
-extern UCHAR  Wpa2Ie;
-extern UCHAR  IbssIe;
-extern UCHAR  Ccx2Ie;
-extern UCHAR  WapiIe;
-
-extern UCHAR  WPA_OUI[];
-extern UCHAR  RSN_OUI[];
-extern UCHAR  WAPI_OUI[];
-extern UCHAR  WME_INFO_ELEM[];
-extern UCHAR  WME_PARM_ELEM[];
-extern UCHAR  Ccx2QosInfo[];
-extern UCHAR  Ccx2IeInfo[];
-extern UCHAR  RALINK_OUI[];
-extern UCHAR  PowerConstraintIE[];
-
-
-extern UCHAR  RateSwitchTable[];
-extern UCHAR  RateSwitchTable11B[];
-extern UCHAR  RateSwitchTable11G[];
-extern UCHAR  RateSwitchTable11BG[];
-
-extern UCHAR  RateSwitchTable11BGN1S[];
-extern UCHAR  RateSwitchTable11BGN2S[];
-extern UCHAR  RateSwitchTable11BGN2SForABand[];
-extern UCHAR  RateSwitchTable11N1S[];
-extern UCHAR  RateSwitchTable11N2S[];
-extern UCHAR  RateSwitchTable11N2SForABand[];
-
-extern UCHAR  PRE_N_HT_OUI[];
+extern UCHAR CipherSuiteWpaNoneAes[];
+extern UCHAR CipherSuiteWpaNoneAesLen;
 
-
-
-
-typedef struct 	_RSSI_SAMPLE {
-	CHAR			LastRssi0;             // last received RSSI
-	CHAR			LastRssi1;             // last received RSSI
-	CHAR			LastRssi2;             // last received RSSI
-	CHAR			AvgRssi0;
-	CHAR			AvgRssi1;
-	CHAR			AvgRssi2;
-	SHORT			AvgRssi0X8;
-	SHORT			AvgRssi1X8;
-	SHORT			AvgRssi2X8;
+extern UCHAR SsidIe;
+extern UCHAR SupRateIe;
+extern UCHAR ExtRateIe;
+
+extern UCHAR HtCapIe;
+extern UCHAR AddHtInfoIe;
+extern UCHAR NewExtChanIe;
+
+extern UCHAR ErpIe;
+extern UCHAR DsIe;
+extern UCHAR TimIe;
+extern UCHAR WpaIe;
+extern UCHAR Wpa2Ie;
+extern UCHAR IbssIe;
+extern UCHAR Ccx2Ie;
+extern UCHAR WapiIe;
+
+extern UCHAR WPA_OUI[];
+extern UCHAR RSN_OUI[];
+extern UCHAR WAPI_OUI[];
+extern UCHAR WME_INFO_ELEM[];
+extern UCHAR WME_PARM_ELEM[];
+extern UCHAR Ccx2QosInfo[];
+extern UCHAR Ccx2IeInfo[];
+extern UCHAR RALINK_OUI[];
+extern UCHAR PowerConstraintIE[];
+
+extern UCHAR RateSwitchTable[];
+extern UCHAR RateSwitchTable11B[];
+extern UCHAR RateSwitchTable11G[];
+extern UCHAR RateSwitchTable11BG[];
+
+extern UCHAR RateSwitchTable11BGN1S[];
+extern UCHAR RateSwitchTable11BGN2S[];
+extern UCHAR RateSwitchTable11BGN2SForABand[];
+extern UCHAR RateSwitchTable11N1S[];
+extern UCHAR RateSwitchTable11N2S[];
+extern UCHAR RateSwitchTable11N2SForABand[];
+
+extern UCHAR PRE_N_HT_OUI[];
+
+typedef struct _RSSI_SAMPLE {
+	CHAR LastRssi0;		// last received RSSI
+	CHAR LastRssi1;		// last received RSSI
+	CHAR LastRssi2;		// last received RSSI
+	CHAR AvgRssi0;
+	CHAR AvgRssi1;
+	CHAR AvgRssi2;
+	SHORT AvgRssi0X8;
+	SHORT AvgRssi1X8;
+	SHORT AvgRssi2X8;
 } RSSI_SAMPLE;
 
 //
 //  Queue structure and macros
 //
-typedef struct  _QUEUE_ENTRY    {
-	struct _QUEUE_ENTRY     *Next;
-}   QUEUE_ENTRY, *PQUEUE_ENTRY;
+typedef struct _QUEUE_ENTRY {
+	struct _QUEUE_ENTRY *Next;
+} QUEUE_ENTRY, *PQUEUE_ENTRY;
 
 // Queue structure
-typedef struct  _QUEUE_HEADER   {
-	PQUEUE_ENTRY    Head;
-	PQUEUE_ENTRY    Tail;
-	ULONG           Number;
-}   QUEUE_HEADER, *PQUEUE_HEADER;
+typedef struct _QUEUE_HEADER {
+	PQUEUE_ENTRY Head;
+	PQUEUE_ENTRY Tail;
+	ULONG Number;
+} QUEUE_HEADER, *PQUEUE_HEADER;
 
 #define InitializeQueueHeader(QueueHeader)              \
 {                                                       \
@@ -231,8 +224,6 @@ typedef struct  _QUEUE_HEADER   {
 	(QueueHeader)->Number++;											\
 }
 
-
-
 //
 //  Macros for flag and ref count operations
 //
@@ -270,13 +261,11 @@ typedef struct  _QUEUE_HEADER   {
 #define CKIP_KP_ON(_p)				((((_p)->StaCfg.CkipFlag) & 0x10) && ((_p)->StaCfg.bCkipCmicOn == TRUE))
 #define CKIP_CMIC_ON(_p)			((((_p)->StaCfg.CkipFlag) & 0x08) && ((_p)->StaCfg.bCkipCmicOn == TRUE))
 
-
 #define INC_RING_INDEX(_idx, _RingSize)    \
 {                                          \
     (_idx) = (_idx+1) % (_RingSize);       \
 }
 
-
 // StaActive.SupportedHtPhy.MCSSet is copied from AP beacon.  Don't need to update here.
 #define COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(_pAd)                                 \
 {                                                                                       \
@@ -315,7 +304,6 @@ typedef struct  _QUEUE_HEADER   {
 //              ULONG Value)
 //
 
-
 //
 // Common fragment list structure -  Identical to the scatter gather frag list structure
 //
@@ -324,16 +312,15 @@ typedef struct  _QUEUE_HEADER   {
 #define NIC_MAX_PHYS_BUF_COUNT              8
 
 typedef struct _RTMP_SCATTER_GATHER_ELEMENT {
-    PVOID		Address;
-    ULONG		Length;
-    PULONG		Reserved;
+	PVOID Address;
+	ULONG Length;
+	PULONG Reserved;
 } RTMP_SCATTER_GATHER_ELEMENT, *PRTMP_SCATTER_GATHER_ELEMENT;
 
-
 typedef struct _RTMP_SCATTER_GATHER_LIST {
-    ULONG  NumberOfElements;
-    PULONG Reserved;
-    RTMP_SCATTER_GATHER_ELEMENT Elements[NIC_MAX_PHYS_BUF_COUNT];
+	ULONG NumberOfElements;
+	PULONG Reserved;
+	RTMP_SCATTER_GATHER_ELEMENT Elements[NIC_MAX_PHYS_BUF_COUNT];
 } RTMP_SCATTER_GATHER_LIST, *PRTMP_SCATTER_GATHER_LIST;
 
 //
@@ -396,7 +383,6 @@ typedef struct _RTMP_SCATTER_GATHER_LIST
 	}															\
 }
 
-
 #define MAKE_802_3_HEADER(_p, _pMac1, _pMac2, _pType)                   \
 {                                                                       \
     NdisMoveMemory(_p, _pMac1, MAC_ADDR_LEN);                           \
@@ -444,7 +430,6 @@ typedef struct _RTMP_SCATTER_GATHER_LIST
     }                                                                   \
 }
 
-
 // Enqueue this frame to MLME engine
 // We need to enqueue the whole frame because MLME need to pass data type
 // information from 802.11 header
@@ -487,20 +472,16 @@ typedef struct _RTMP_SCATTER_GATHER_LIST
 	STA_EXTRA_SETTING(_pAd); \
 }
 
-
-
 //
 //  Data buffer for DMA operation, the buffer must be contiguous physical memory
 //  Both DMA to / from CPU use the same structure.
 //
-typedef struct  _RTMP_DMABUF
-{
-	ULONG                   AllocSize;
-	PVOID                   AllocVa;            // TxBuf virtual address
-	NDIS_PHYSICAL_ADDRESS   AllocPa;            // TxBuf physical address
+typedef struct _RTMP_DMABUF {
+	ULONG AllocSize;
+	PVOID AllocVa;		// TxBuf virtual address
+	NDIS_PHYSICAL_ADDRESS AllocPa;	// TxBuf physical address
 } RTMP_DMABUF, *PRTMP_DMABUF;
 
-
 //
 // Control block (Descriptor) for all ring descriptor DMA operation, buffer must be
 // contiguous physical memory. NDIS_PACKET stored the binding Rx packet descriptor
@@ -509,206 +490,195 @@ typedef struct  _RTMP_DMABUF
 // to describe the packet buffer. For Tx, NDIS_PACKET stored the tx packet descriptor
 // which driver should ACK upper layer when the tx is physically done or failed.
 //
-typedef struct _RTMP_DMACB
-{
-	ULONG                   AllocSize;          // Control block size
-	PVOID                   AllocVa;            // Control block virtual address
-	NDIS_PHYSICAL_ADDRESS   AllocPa;            // Control block physical address
+typedef struct _RTMP_DMACB {
+	ULONG AllocSize;	// Control block size
+	PVOID AllocVa;		// Control block virtual address
+	NDIS_PHYSICAL_ADDRESS AllocPa;	// Control block physical address
 	PNDIS_PACKET pNdisPacket;
 	PNDIS_PACKET pNextNdisPacket;
 
-	RTMP_DMABUF             DmaBuf;             // Associated DMA buffer structure
+	RTMP_DMABUF DmaBuf;	// Associated DMA buffer structure
 } RTMP_DMACB, *PRTMP_DMACB;
 
-
-typedef struct _RTMP_TX_RING
-{
-	RTMP_DMACB  Cell[TX_RING_SIZE];
-	UINT32		TxCpuIdx;
-	UINT32		TxDmaIdx;
-	UINT32		TxSwFreeIdx; 	// software next free tx index
+typedef struct _RTMP_TX_RING {
+	RTMP_DMACB Cell[TX_RING_SIZE];
+	UINT32 TxCpuIdx;
+	UINT32 TxDmaIdx;
+	UINT32 TxSwFreeIdx;	// software next free tx index
 } RTMP_TX_RING, *PRTMP_TX_RING;
 
-typedef struct _RTMP_RX_RING
-{
-	RTMP_DMACB  Cell[RX_RING_SIZE];
-	UINT32		RxCpuIdx;
-	UINT32		RxDmaIdx;
-	INT32		RxSwReadIdx; 	// software next read index
+typedef struct _RTMP_RX_RING {
+	RTMP_DMACB Cell[RX_RING_SIZE];
+	UINT32 RxCpuIdx;
+	UINT32 RxDmaIdx;
+	INT32 RxSwReadIdx;	// software next read index
 } RTMP_RX_RING, *PRTMP_RX_RING;
 
-typedef struct _RTMP_MGMT_RING
-{
-	RTMP_DMACB  Cell[MGMT_RING_SIZE];
-	UINT32		TxCpuIdx;
-	UINT32		TxDmaIdx;
-	UINT32		TxSwFreeIdx; // software next free tx index
+typedef struct _RTMP_MGMT_RING {
+	RTMP_DMACB Cell[MGMT_RING_SIZE];
+	UINT32 TxCpuIdx;
+	UINT32 TxDmaIdx;
+	UINT32 TxSwFreeIdx;	// software next free tx index
 } RTMP_MGMT_RING, *PRTMP_MGMT_RING;
 
 //
 //  Statistic counter structure
 //
-typedef struct _COUNTER_802_3
-{
+typedef struct _COUNTER_802_3 {
 	// General Stats
-	ULONG       GoodTransmits;
-	ULONG       GoodReceives;
-	ULONG       TxErrors;
-	ULONG       RxErrors;
-	ULONG       RxNoBuffer;
+	ULONG GoodTransmits;
+	ULONG GoodReceives;
+	ULONG TxErrors;
+	ULONG RxErrors;
+	ULONG RxNoBuffer;
 
 	// Ethernet Stats
-	ULONG       RcvAlignmentErrors;
-	ULONG       OneCollision;
-	ULONG       MoreCollisions;
+	ULONG RcvAlignmentErrors;
+	ULONG OneCollision;
+	ULONG MoreCollisions;
 
 } COUNTER_802_3, *PCOUNTER_802_3;
 
 typedef struct _COUNTER_802_11 {
-	ULONG           Length;
-	LARGE_INTEGER   LastTransmittedFragmentCount;
-	LARGE_INTEGER   TransmittedFragmentCount;
-	LARGE_INTEGER   MulticastTransmittedFrameCount;
-	LARGE_INTEGER   FailedCount;
-	LARGE_INTEGER   RetryCount;
-	LARGE_INTEGER   MultipleRetryCount;
-	LARGE_INTEGER   RTSSuccessCount;
-	LARGE_INTEGER   RTSFailureCount;
-	LARGE_INTEGER   ACKFailureCount;
-	LARGE_INTEGER   FrameDuplicateCount;
-	LARGE_INTEGER   ReceivedFragmentCount;
-	LARGE_INTEGER   MulticastReceivedFrameCount;
-	LARGE_INTEGER   FCSErrorCount;
+	ULONG Length;
+	LARGE_INTEGER LastTransmittedFragmentCount;
+	LARGE_INTEGER TransmittedFragmentCount;
+	LARGE_INTEGER MulticastTransmittedFrameCount;
+	LARGE_INTEGER FailedCount;
+	LARGE_INTEGER RetryCount;
+	LARGE_INTEGER MultipleRetryCount;
+	LARGE_INTEGER RTSSuccessCount;
+	LARGE_INTEGER RTSFailureCount;
+	LARGE_INTEGER ACKFailureCount;
+	LARGE_INTEGER FrameDuplicateCount;
+	LARGE_INTEGER ReceivedFragmentCount;
+	LARGE_INTEGER MulticastReceivedFrameCount;
+	LARGE_INTEGER FCSErrorCount;
 } COUNTER_802_11, *PCOUNTER_802_11;
 
 typedef struct _COUNTER_RALINK {
-	ULONG           TransmittedByteCount;   // both successful and failure, used to calculate TX throughput
-	ULONG           ReceivedByteCount;      // both CRC okay and CRC error, used to calculate RX throughput
-	ULONG           BeenDisassociatedCount;
-	ULONG           BadCQIAutoRecoveryCount;
-	ULONG           PoorCQIRoamingCount;
-	ULONG           MgmtRingFullCount;
-	ULONG           RxCountSinceLastNULL;
-	ULONG           RxCount;
-	ULONG           RxRingErrCount;
-	ULONG           KickTxCount;
-	ULONG           TxRingErrCount;
-	LARGE_INTEGER   RealFcsErrCount;
-	ULONG           PendingNdisPacketCount;
-
-	ULONG           OneSecOsTxCount[NUM_OF_TX_RING];
-	ULONG           OneSecDmaDoneCount[NUM_OF_TX_RING];
-	UINT32          OneSecTxDoneCount;
-	ULONG           OneSecRxCount;
-	UINT32          OneSecTxAggregationCount;
-	UINT32          OneSecRxAggregationCount;
-	UINT32          OneSecReceivedByteCount;
-	UINT32   		OneSecFrameDuplicateCount;
-
-	UINT32          OneSecTransmittedByteCount;   // both successful and failure, used to calculate TX throughput
-	UINT32          OneSecTxNoRetryOkCount;
-	UINT32          OneSecTxRetryOkCount;
-	UINT32          OneSecTxFailCount;
-	UINT32          OneSecFalseCCACnt;      // CCA error count, for debug purpose, might move to global counter
-	UINT32          OneSecRxOkCnt;          // RX without error
-	UINT32          OneSecRxOkDataCnt;      // unicast-to-me DATA frame count
-	UINT32          OneSecRxFcsErrCnt;      // CRC error
-	UINT32          OneSecBeaconSentCnt;
-	UINT32          LastOneSecTotalTxCount; // OneSecTxNoRetryOkCount + OneSecTxRetryOkCount + OneSecTxFailCount
-	UINT32          LastOneSecRxOkDataCnt;  // OneSecRxOkDataCnt
-	ULONG		DuplicateRcv;
-	ULONG		TxAggCount;
-	ULONG		TxNonAggCount;
-	ULONG		TxAgg1MPDUCount;
-	ULONG		TxAgg2MPDUCount;
-	ULONG		TxAgg3MPDUCount;
-	ULONG		TxAgg4MPDUCount;
-	ULONG		TxAgg5MPDUCount;
-	ULONG		TxAgg6MPDUCount;
-	ULONG		TxAgg7MPDUCount;
-	ULONG		TxAgg8MPDUCount;
-	ULONG		TxAgg9MPDUCount;
-	ULONG		TxAgg10MPDUCount;
-	ULONG		TxAgg11MPDUCount;
-	ULONG		TxAgg12MPDUCount;
-	ULONG		TxAgg13MPDUCount;
-	ULONG		TxAgg14MPDUCount;
-	ULONG		TxAgg15MPDUCount;
-	ULONG		TxAgg16MPDUCount;
-
-	LARGE_INTEGER       TransmittedOctetsInAMSDU;
-	LARGE_INTEGER       TransmittedAMSDUCount;
-	LARGE_INTEGER       ReceivedOctesInAMSDUCount;
-	LARGE_INTEGER       ReceivedAMSDUCount;
-	LARGE_INTEGER       TransmittedAMPDUCount;
-	LARGE_INTEGER       TransmittedMPDUsInAMPDUCount;
-	LARGE_INTEGER       TransmittedOctetsInAMPDUCount;
-	LARGE_INTEGER       MPDUInReceivedAMPDUCount;
+	ULONG TransmittedByteCount;	// both successful and failure, used to calculate TX throughput
+	ULONG ReceivedByteCount;	// both CRC okay and CRC error, used to calculate RX throughput
+	ULONG BeenDisassociatedCount;
+	ULONG BadCQIAutoRecoveryCount;
+	ULONG PoorCQIRoamingCount;
+	ULONG MgmtRingFullCount;
+	ULONG RxCountSinceLastNULL;
+	ULONG RxCount;
+	ULONG RxRingErrCount;
+	ULONG KickTxCount;
+	ULONG TxRingErrCount;
+	LARGE_INTEGER RealFcsErrCount;
+	ULONG PendingNdisPacketCount;
+
+	ULONG OneSecOsTxCount[NUM_OF_TX_RING];
+	ULONG OneSecDmaDoneCount[NUM_OF_TX_RING];
+	UINT32 OneSecTxDoneCount;
+	ULONG OneSecRxCount;
+	UINT32 OneSecTxAggregationCount;
+	UINT32 OneSecRxAggregationCount;
+	UINT32 OneSecReceivedByteCount;
+	UINT32 OneSecFrameDuplicateCount;
+
+	UINT32 OneSecTransmittedByteCount;	// both successful and failure, used to calculate TX throughput
+	UINT32 OneSecTxNoRetryOkCount;
+	UINT32 OneSecTxRetryOkCount;
+	UINT32 OneSecTxFailCount;
+	UINT32 OneSecFalseCCACnt;	// CCA error count, for debug purpose, might move to global counter
+	UINT32 OneSecRxOkCnt;	// RX without error
+	UINT32 OneSecRxOkDataCnt;	// unicast-to-me DATA frame count
+	UINT32 OneSecRxFcsErrCnt;	// CRC error
+	UINT32 OneSecBeaconSentCnt;
+	UINT32 LastOneSecTotalTxCount;	// OneSecTxNoRetryOkCount + OneSecTxRetryOkCount + OneSecTxFailCount
+	UINT32 LastOneSecRxOkDataCnt;	// OneSecRxOkDataCnt
+	ULONG DuplicateRcv;
+	ULONG TxAggCount;
+	ULONG TxNonAggCount;
+	ULONG TxAgg1MPDUCount;
+	ULONG TxAgg2MPDUCount;
+	ULONG TxAgg3MPDUCount;
+	ULONG TxAgg4MPDUCount;
+	ULONG TxAgg5MPDUCount;
+	ULONG TxAgg6MPDUCount;
+	ULONG TxAgg7MPDUCount;
+	ULONG TxAgg8MPDUCount;
+	ULONG TxAgg9MPDUCount;
+	ULONG TxAgg10MPDUCount;
+	ULONG TxAgg11MPDUCount;
+	ULONG TxAgg12MPDUCount;
+	ULONG TxAgg13MPDUCount;
+	ULONG TxAgg14MPDUCount;
+	ULONG TxAgg15MPDUCount;
+	ULONG TxAgg16MPDUCount;
+
+	LARGE_INTEGER TransmittedOctetsInAMSDU;
+	LARGE_INTEGER TransmittedAMSDUCount;
+	LARGE_INTEGER ReceivedOctesInAMSDUCount;
+	LARGE_INTEGER ReceivedAMSDUCount;
+	LARGE_INTEGER TransmittedAMPDUCount;
+	LARGE_INTEGER TransmittedMPDUsInAMPDUCount;
+	LARGE_INTEGER TransmittedOctetsInAMPDUCount;
+	LARGE_INTEGER MPDUInReceivedAMPDUCount;
 } COUNTER_RALINK, *PCOUNTER_RALINK;
 
-
 typedef struct _COUNTER_DRS {
 	// to record the each TX rate's quality. 0 is best, the bigger the worse.
-	USHORT          TxQuality[MAX_STEP_OF_TX_RATE_SWITCH];
-	UCHAR           PER[MAX_STEP_OF_TX_RATE_SWITCH];
-	UCHAR           TxRateUpPenalty;      // extra # of second penalty due to last unstable condition
-	ULONG           CurrTxRateStableTime; // # of second in current TX rate
-	BOOLEAN         fNoisyEnvironment;
-	BOOLEAN         fLastSecAccordingRSSI;
-	UCHAR           LastSecTxRateChangeAction; // 0: no change, 1:rate UP, 2:rate down
-	UCHAR			LastTimeTxRateChangeAction; //Keep last time value of LastSecTxRateChangeAction
-	ULONG			LastTxOkCount;
+	USHORT TxQuality[MAX_STEP_OF_TX_RATE_SWITCH];
+	UCHAR PER[MAX_STEP_OF_TX_RATE_SWITCH];
+	UCHAR TxRateUpPenalty;	// extra # of second penalty due to last unstable condition
+	ULONG CurrTxRateStableTime;	// # of second in current TX rate
+	BOOLEAN fNoisyEnvironment;
+	BOOLEAN fLastSecAccordingRSSI;
+	UCHAR LastSecTxRateChangeAction;	// 0: no change, 1:rate UP, 2:rate down
+	UCHAR LastTimeTxRateChangeAction;	//Keep last time value of LastSecTxRateChangeAction
+	ULONG LastTxOkCount;
 } COUNTER_DRS, *PCOUNTER_DRS;
 
-
-
-
 /***************************************************************************
   *	security key related data structure
   **************************************************************************/
 typedef struct _CIPHER_KEY {
-	UCHAR   Key[16];            // right now we implement 4 keys, 128 bits max
-	UCHAR   RxMic[8];			// make alignment
-	UCHAR   TxMic[8];
-	UCHAR   TxTsc[6];           // 48bit TSC value
-	UCHAR   RxTsc[6];           // 48bit TSC value
-	UCHAR   CipherAlg;          // 0-none, 1:WEP64, 2:WEP128, 3:TKIP, 4:AES, 5:CKIP64, 6:CKIP128
-	UCHAR   KeyLen;
-	UCHAR   BssId[6];
-            // Key length for each key, 0: entry is invalid
-	UCHAR   Type;               // Indicate Pairwise/Group when reporting MIC error
+	UCHAR Key[16];		// right now we implement 4 keys, 128 bits max
+	UCHAR RxMic[8];		// make alignment
+	UCHAR TxMic[8];
+	UCHAR TxTsc[6];		// 48bit TSC value
+	UCHAR RxTsc[6];		// 48bit TSC value
+	UCHAR CipherAlg;	// 0-none, 1:WEP64, 2:WEP128, 3:TKIP, 4:AES, 5:CKIP64, 6:CKIP128
+	UCHAR KeyLen;
+	UCHAR BssId[6];
+	// Key length for each key, 0: entry is invalid
+	UCHAR Type;		// Indicate Pairwise/Group when reporting MIC error
 } CIPHER_KEY, *PCIPHER_KEY;
 
-
 // structure to define WPA Group Key Rekey Interval
 typedef struct PACKED _RT_802_11_WPA_REKEY {
-	ULONG ReKeyMethod;          // mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based
-	ULONG ReKeyInterval;        // time-based: seconds, packet-based: kilo-packets
-} RT_WPA_REKEY,*PRT_WPA_REKEY, RT_802_11_WPA_REKEY, *PRT_802_11_WPA_REKEY;
+	ULONG ReKeyMethod;	// mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based
+	ULONG ReKeyInterval;	// time-based: seconds, packet-based: kilo-packets
+} RT_WPA_REKEY, *PRT_WPA_REKEY, RT_802_11_WPA_REKEY, *PRT_802_11_WPA_REKEY;
 
 #ifdef RTMP_MAC_USB
 /***************************************************************************
   *	RTUSB I/O related data structure
   **************************************************************************/
-typedef struct   _RT_SET_ASIC_WCID {
-	ULONG WCID;          // mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based
-	ULONG SetTid;        // time-based: seconds, packet-based: kilo-packets
-	ULONG DeleteTid;        // time-based: seconds, packet-based: kilo-packets
+typedef struct _RT_SET_ASIC_WCID {
+	ULONG WCID;		// mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based
+	ULONG SetTid;		// time-based: seconds, packet-based: kilo-packets
+	ULONG DeleteTid;	// time-based: seconds, packet-based: kilo-packets
 	UCHAR Addr[MAC_ADDR_LEN];	// avoid in interrupt when write key
-} RT_SET_ASIC_WCID,*PRT_SET_ASIC_WCID;
+} RT_SET_ASIC_WCID, *PRT_SET_ASIC_WCID;
 
-typedef struct   _RT_SET_ASIC_WCID_ATTRI {
-	ULONG	WCID;          // mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based
-	ULONG	Cipher;        // ASIC Cipher definition
-	UCHAR	Addr[ETH_LENGTH_OF_ADDRESS];
-} RT_SET_ASIC_WCID_ATTRI,*PRT_SET_ASIC_WCID_ATTRI;
+typedef struct _RT_SET_ASIC_WCID_ATTRI {
+	ULONG WCID;		// mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based
+	ULONG Cipher;		// ASIC Cipher definition
+	UCHAR Addr[ETH_LENGTH_OF_ADDRESS];
+} RT_SET_ASIC_WCID_ATTRI, *PRT_SET_ASIC_WCID_ATTRI;
 
 // for USB interface, avoid in interrupt when write key
-typedef struct   RT_ADD_PAIRWISE_KEY_ENTRY {
-        UCHAR			MacAddr[6];
-        USHORT               MacTabMatchWCID;        // ASIC
-        CIPHER_KEY         CipherKey;
-} RT_ADD_PAIRWISE_KEY_ENTRY,*PRT_ADD_PAIRWISE_KEY_ENTRY;
+typedef struct RT_ADD_PAIRWISE_KEY_ENTRY {
+	UCHAR MacAddr[6];
+	USHORT MacTabMatchWCID;	// ASIC
+	CIPHER_KEY CipherKey;
+} RT_ADD_PAIRWISE_KEY_ENTRY, *PRT_ADD_PAIRWISE_KEY_ENTRY;
 
 // Cipher suite type for mixed mode group cipher, P802.11i-2004
 typedef enum _RT_802_11_CIPHER_SUITE_TYPE {
@@ -722,176 +692,168 @@ typedef enum _RT_802_11_CIPHER_SUITE_TYP
 #endif // RTMP_MAC_USB //
 
 typedef struct {
-	UCHAR        Addr[MAC_ADDR_LEN];
-	UCHAR        ErrorCode[2];  //00 01-Invalid authentication type
-								//00 02-Authentication timeout
-								//00 03-Challenge from AP failed
-								//00 04-Challenge to AP failed
-	BOOLEAN      Reported;
+	UCHAR Addr[MAC_ADDR_LEN];
+	UCHAR ErrorCode[2];	//00 01-Invalid authentication type
+	//00 02-Authentication timeout
+	//00 03-Challenge from AP failed
+	//00 04-Challenge to AP failed
+	BOOLEAN Reported;
 } ROGUEAP_ENTRY, *PROGUEAP_ENTRY;
 
 typedef struct {
-	UCHAR               RogueApNr;
-	ROGUEAP_ENTRY       RogueApEntry[MAX_LEN_OF_BSS_TABLE];
+	UCHAR RogueApNr;
+	ROGUEAP_ENTRY RogueApEntry[MAX_LEN_OF_BSS_TABLE];
 } ROGUEAP_TABLE, *PROGUEAP_TABLE;
 
 //
 // Cisco IAPP format
 //
-typedef struct  _CISCO_IAPP_CONTENT_
-{
-	USHORT     Length;        //IAPP Length
-	UCHAR      MessageType;      //IAPP type
-	UCHAR      FunctionCode;     //IAPP function type
-	UCHAR      DestinaionMAC[MAC_ADDR_LEN];
-	UCHAR      SourceMAC[MAC_ADDR_LEN];
-	USHORT     Tag;           //Tag(element IE) - Adjacent AP report
-	USHORT     TagLength;     //Length of element not including 4 byte header
-	UCHAR      OUI[4];           //0x00, 0x40, 0x96, 0x00
-	UCHAR      PreviousAP[MAC_ADDR_LEN];       //MAC Address of access point
-	USHORT     Channel;
-	USHORT     SsidLen;
-	UCHAR      Ssid[MAX_LEN_OF_SSID];
-	USHORT     Seconds;          //Seconds that the client has been disassociated.
+typedef struct _CISCO_IAPP_CONTENT_ {
+	USHORT Length;		//IAPP Length
+	UCHAR MessageType;	//IAPP type
+	UCHAR FunctionCode;	//IAPP function type
+	UCHAR DestinaionMAC[MAC_ADDR_LEN];
+	UCHAR SourceMAC[MAC_ADDR_LEN];
+	USHORT Tag;		//Tag(element IE) - Adjacent AP report
+	USHORT TagLength;	//Length of element not including 4 byte header
+	UCHAR OUI[4];		//0x00, 0x40, 0x96, 0x00
+	UCHAR PreviousAP[MAC_ADDR_LEN];	//MAC Address of access point
+	USHORT Channel;
+	USHORT SsidLen;
+	UCHAR Ssid[MAX_LEN_OF_SSID];
+	USHORT Seconds;		//Seconds that the client has been disassociated.
 } CISCO_IAPP_CONTENT, *PCISCO_IAPP_CONTENT;
 
-
 /*
   *	Fragment Frame structure
   */
-typedef struct  _FRAGMENT_FRAME {
-	PNDIS_PACKET    pFragPacket;
-	ULONG       RxSize;
-	USHORT      Sequence;
-	USHORT      LastFrag;
-	ULONG       Flags;          // Some extra frame information. bit 0: LLC presented
+typedef struct _FRAGMENT_FRAME {
+	PNDIS_PACKET pFragPacket;
+	ULONG RxSize;
+	USHORT Sequence;
+	USHORT LastFrag;
+	ULONG Flags;		// Some extra frame information. bit 0: LLC presented
 } FRAGMENT_FRAME, *PFRAGMENT_FRAME;
 
-
 //
 // Packet information for NdisQueryPacket
 //
-typedef struct  _PACKET_INFO    {
-	UINT            PhysicalBufferCount;    // Physical breaks of buffer descripor chained
-	UINT            BufferCount ;           // Number of Buffer descriptor chained
-	UINT            TotalPacketLength ;     // Self explained
-	PNDIS_BUFFER    pFirstBuffer;           // Pointer to first buffer descriptor
+typedef struct _PACKET_INFO {
+	UINT PhysicalBufferCount;	// Physical breaks of buffer descripor chained
+	UINT BufferCount;	// Number of Buffer descriptor chained
+	UINT TotalPacketLength;	// Self explained
+	PNDIS_BUFFER pFirstBuffer;	// Pointer to first buffer descriptor
 } PACKET_INFO, *PPACKET_INFO;
 
-
 //
 //  Arcfour Structure Added by PaulWu
 //
-typedef struct  _ARCFOUR
-{
-	UINT            X;
-	UINT            Y;
-	UCHAR           STATE[256];
+typedef struct _ARCFOUR {
+	UINT X;
+	UINT Y;
+	UCHAR STATE[256];
 } ARCFOURCONTEXT, *PARCFOURCONTEXT;
 
-
 //
 // Tkip Key structure which RC4 key & MIC calculation
 //
-typedef struct  _TKIP_KEY_INFO  {
-	UINT        nBytesInM;  // # bytes in M for MICKEY
-	ULONG       IV16;
-	ULONG       IV32;
-	ULONG       K0;         // for MICKEY Low
-	ULONG       K1;         // for MICKEY Hig
-	ULONG       L;          // Current state for MICKEY
-	ULONG       R;          // Current state for MICKEY
-	ULONG       M;          // Message accumulator for MICKEY
-	UCHAR       RC4KEY[16];
-	UCHAR       MIC[8];
+typedef struct _TKIP_KEY_INFO {
+	UINT nBytesInM;		// # bytes in M for MICKEY
+	ULONG IV16;
+	ULONG IV32;
+	ULONG K0;		// for MICKEY Low
+	ULONG K1;		// for MICKEY Hig
+	ULONG L;		// Current state for MICKEY
+	ULONG R;		// Current state for MICKEY
+	ULONG M;		// Message accumulator for MICKEY
+	UCHAR RC4KEY[16];
+	UCHAR MIC[8];
 } TKIP_KEY_INFO, *PTKIP_KEY_INFO;
 
 //
 // Private / Misc data, counters for driver internal use
 //
-typedef struct  __PRIVATE_STRUC {
-	UINT       SystemResetCnt;         // System reset counter
-	UINT       TxRingFullCnt;          // Tx ring full occurrance number
-	UINT       PhyRxErrCnt;            // PHY Rx error count, for debug purpose, might move to global counter
+typedef struct __PRIVATE_STRUC {
+	UINT SystemResetCnt;	// System reset counter
+	UINT TxRingFullCnt;	// Tx ring full occurrance number
+	UINT PhyRxErrCnt;	// PHY Rx error count, for debug purpose, might move to global counter
 	// Variables for WEP encryption / decryption in rtmp_wep.c
-	UINT       FCSCRC32;
-	ARCFOURCONTEXT  WEPCONTEXT;
+	UINT FCSCRC32;
+	ARCFOURCONTEXT WEPCONTEXT;
 	// Tkip stuff
-	TKIP_KEY_INFO   Tx;
-	TKIP_KEY_INFO   Rx;
+	TKIP_KEY_INFO Tx;
+	TKIP_KEY_INFO Rx;
 } PRIVATE_STRUC, *PPRIVATE_STRUC;
 
-
 /***************************************************************************
   *	Channel and BBP related data structures
   **************************************************************************/
 // structure to tune BBP R66 (BBP TUNING)
 typedef struct _BBP_R66_TUNING {
-	BOOLEAN     bEnable;
-	USHORT      FalseCcaLowerThreshold;  // default 100
-	USHORT      FalseCcaUpperThreshold;  // default 512
-	UCHAR       R66Delta;
-	UCHAR       R66CurrentValue;
-	BOOLEAN		R66LowerUpperSelect; //Before LinkUp, Used LowerBound or UpperBound as R66 value.
+	BOOLEAN bEnable;
+	USHORT FalseCcaLowerThreshold;	// default 100
+	USHORT FalseCcaUpperThreshold;	// default 512
+	UCHAR R66Delta;
+	UCHAR R66CurrentValue;
+	BOOLEAN R66LowerUpperSelect;	//Before LinkUp, Used LowerBound or UpperBound as R66 value.
 } BBP_R66_TUNING, *PBBP_R66_TUNING;
 
 // structure to store channel TX power
 typedef struct _CHANNEL_TX_POWER {
-	USHORT     RemainingTimeForUse;		//unit: sec
-	UCHAR      Channel;
-	CHAR       Power;
-	CHAR       Power2;
-	UCHAR      MaxTxPwr;
-	UCHAR      DfsReq;
+	USHORT RemainingTimeForUse;	//unit: sec
+	UCHAR Channel;
+	CHAR Power;
+	CHAR Power2;
+	UCHAR MaxTxPwr;
+	UCHAR DfsReq;
 } CHANNEL_TX_POWER, *PCHANNEL_TX_POWER;
 
 // structure to store 802.11j channel TX power
 typedef struct _CHANNEL_11J_TX_POWER {
-	UCHAR      Channel;
-	UCHAR      BW;	// BW_10 or BW_20
-	CHAR       Power;
-	CHAR       Power2;
-	USHORT     RemainingTimeForUse;		//unit: sec
+	UCHAR Channel;
+	UCHAR BW;		// BW_10 or BW_20
+	CHAR Power;
+	CHAR Power2;
+	USHORT RemainingTimeForUse;	//unit: sec
 } CHANNEL_11J_TX_POWER, *PCHANNEL_11J_TX_POWER;
 
 typedef struct _SOFT_RX_ANT_DIVERSITY_STRUCT {
-	UCHAR     EvaluatePeriod;		 // 0:not evalute status, 1: evaluate status, 2: switching status
-	UCHAR     EvaluateStableCnt;
-	UCHAR     Pair1PrimaryRxAnt;     // 0:Ant-E1, 1:Ant-E2
-	UCHAR     Pair1SecondaryRxAnt;   // 0:Ant-E1, 1:Ant-E2
-	UCHAR     Pair2PrimaryRxAnt;     // 0:Ant-E3, 1:Ant-E4
-	UCHAR     Pair2SecondaryRxAnt;   // 0:Ant-E3, 1:Ant-E4
-	SHORT     Pair1AvgRssi[2];       // AvgRssi[0]:E1, AvgRssi[1]:E2
-	SHORT     Pair2AvgRssi[2];       // AvgRssi[0]:E3, AvgRssi[1]:E4
-	SHORT     Pair1LastAvgRssi;      //
-	SHORT     Pair2LastAvgRssi;      //
-	ULONG     RcvPktNumWhenEvaluate;
-	BOOLEAN   FirstPktArrivedWhenEvaluate;
-	RALINK_TIMER_STRUCT    RxAntDiversityTimer;
+	UCHAR EvaluatePeriod;	// 0:not evalute status, 1: evaluate status, 2: switching status
+	UCHAR EvaluateStableCnt;
+	UCHAR Pair1PrimaryRxAnt;	// 0:Ant-E1, 1:Ant-E2
+	UCHAR Pair1SecondaryRxAnt;	// 0:Ant-E1, 1:Ant-E2
+	UCHAR Pair2PrimaryRxAnt;	// 0:Ant-E3, 1:Ant-E4
+	UCHAR Pair2SecondaryRxAnt;	// 0:Ant-E3, 1:Ant-E4
+	SHORT Pair1AvgRssi[2];	// AvgRssi[0]:E1, AvgRssi[1]:E2
+	SHORT Pair2AvgRssi[2];	// AvgRssi[0]:E3, AvgRssi[1]:E4
+	SHORT Pair1LastAvgRssi;	//
+	SHORT Pair2LastAvgRssi;	//
+	ULONG RcvPktNumWhenEvaluate;
+	BOOLEAN FirstPktArrivedWhenEvaluate;
+	RALINK_TIMER_STRUCT RxAntDiversityTimer;
 } SOFT_RX_ANT_DIVERSITY, *PSOFT_RX_ANT_DIVERSITY;
 
-
 /***************************************************************************
   *	structure for radar detection and channel switch
   **************************************************************************/
 typedef struct _RADAR_DETECT_STRUCT {
-    //BOOLEAN		IEEE80211H;			// 0: disable, 1: enable IEEE802.11h
-	UCHAR		CSCount;			//Channel switch counter
-	UCHAR		CSPeriod;			//Channel switch period (beacon count)
-	UCHAR		RDCount;			//Radar detection counter
-	UCHAR		RDMode;				//Radar Detection mode
-	UCHAR		RDDurRegion;		//Radar detection duration region
-	UCHAR		BBPR16;
-	UCHAR		BBPR17;
-	UCHAR		BBPR18;
-	UCHAR		BBPR21;
-	UCHAR		BBPR22;
-	UCHAR		BBPR64;
-	ULONG		InServiceMonitorCount; // unit: sec
-	UINT8		DfsSessionTime;
-	BOOLEAN		bFastDfs;
-	UINT8		ChMovingTime;
-	UINT8		LongPulseRadarTh;
+	//BOOLEAN           IEEE80211H;                     // 0: disable, 1: enable IEEE802.11h
+	UCHAR CSCount;		//Channel switch counter
+	UCHAR CSPeriod;		//Channel switch period (beacon count)
+	UCHAR RDCount;		//Radar detection counter
+	UCHAR RDMode;		//Radar Detection mode
+	UCHAR RDDurRegion;	//Radar detection duration region
+	UCHAR BBPR16;
+	UCHAR BBPR17;
+	UCHAR BBPR18;
+	UCHAR BBPR21;
+	UCHAR BBPR22;
+	UCHAR BBPR64;
+	ULONG InServiceMonitorCount;	// unit: sec
+	UINT8 DfsSessionTime;
+	BOOLEAN bFastDfs;
+	UINT8 ChMovingTime;
+	UINT8 LongPulseRadarTh;
 } RADAR_DETECT_STRUCT, *PRADAR_DETECT_STRUCT;
 
 typedef enum _ABGBAND_STATE_ {
@@ -902,17 +864,17 @@ typedef enum _ABGBAND_STATE_ {
 
 #ifdef RTMP_MAC_PCI
 // Power save method control
-typedef	union	_PS_CONTROL	{
-	struct	{
-		ULONG		EnablePSinIdle:1;			// Enable radio off when not connect to AP. radio on only when sitesurvey,
-		ULONG		EnableNewPS:1;		// Enable new  Chip power save fucntion . New method can only be applied in chip version after 2872. and PCIe.
-		ULONG		rt30xxPowerMode:2;			// Power Level Mode for rt30xx chip
-		ULONG		rt30xxFollowHostASPM:1;			// Card Follows Host's setting for rt30xx chip.
-		ULONG		rt30xxForceASPMTest:1;			// Force enable L1 for rt30xx chip. This has higher priority than rt30xxFollowHostASPM Mode.
-		ULONG		rsv:26;			// Radio Measurement Enable
-	}	field;
-	ULONG			word;
-}	PS_CONTROL, *PPS_CONTROL;
+typedef union _PS_CONTROL {
+	struct {
+		ULONG EnablePSinIdle:1;	// Enable radio off when not connect to AP. radio on only when sitesurvey,
+		ULONG EnableNewPS:1;	// Enable new  Chip power save fucntion . New method can only be applied in chip version after 2872. and PCIe.
+		ULONG rt30xxPowerMode:2;	// Power Level Mode for rt30xx chip
+		ULONG rt30xxFollowHostASPM:1;	// Card Follows Host's setting for rt30xx chip.
+		ULONG rt30xxForceASPMTest:1;	// Force enable L1 for rt30xx chip. This has higher priority than rt30xxFollowHostASPM Mode.
+		ULONG rsv:26;	// Radio Measurement Enable
+	} field;
+	ULONG word;
+} PS_CONTROL, *PPS_CONTROL;
 #endif // RTMP_MAC_PCI //
 
 /***************************************************************************
@@ -920,208 +882,193 @@ typedef	union	_PS_CONTROL	{
   **************************************************************************/
 typedef struct _MLME_STRUCT {
 	// STA state machines
-	STATE_MACHINE           CntlMachine;
-	STATE_MACHINE           AssocMachine;
-	STATE_MACHINE           AuthMachine;
-	STATE_MACHINE           AuthRspMachine;
-	STATE_MACHINE           SyncMachine;
-	STATE_MACHINE           WpaPskMachine;
-	STATE_MACHINE           LeapMachine;
-	STATE_MACHINE_FUNC      AssocFunc[ASSOC_FUNC_SIZE];
-	STATE_MACHINE_FUNC      AuthFunc[AUTH_FUNC_SIZE];
-	STATE_MACHINE_FUNC      AuthRspFunc[AUTH_RSP_FUNC_SIZE];
-	STATE_MACHINE_FUNC      SyncFunc[SYNC_FUNC_SIZE];
-	STATE_MACHINE_FUNC      ActFunc[ACT_FUNC_SIZE];
+	STATE_MACHINE CntlMachine;
+	STATE_MACHINE AssocMachine;
+	STATE_MACHINE AuthMachine;
+	STATE_MACHINE AuthRspMachine;
+	STATE_MACHINE SyncMachine;
+	STATE_MACHINE WpaPskMachine;
+	STATE_MACHINE LeapMachine;
+	STATE_MACHINE_FUNC AssocFunc[ASSOC_FUNC_SIZE];
+	STATE_MACHINE_FUNC AuthFunc[AUTH_FUNC_SIZE];
+	STATE_MACHINE_FUNC AuthRspFunc[AUTH_RSP_FUNC_SIZE];
+	STATE_MACHINE_FUNC SyncFunc[SYNC_FUNC_SIZE];
+	STATE_MACHINE_FUNC ActFunc[ACT_FUNC_SIZE];
 	// Action
-	STATE_MACHINE           ActMachine;
-
-
-
+	STATE_MACHINE ActMachine;
 
 	// common WPA state machine
-	STATE_MACHINE           WpaMachine;
-	STATE_MACHINE_FUNC      WpaFunc[WPA_FUNC_SIZE];
-
-
-
-	ULONG                   ChannelQuality;  // 0..100, Channel Quality Indication for Roaming
-	ULONG                   Now32;           // latch the value of NdisGetSystemUpTime()
-	ULONG                   LastSendNULLpsmTime;
+	STATE_MACHINE WpaMachine;
+	STATE_MACHINE_FUNC WpaFunc[WPA_FUNC_SIZE];
 
-	BOOLEAN                 bRunning;
-	NDIS_SPIN_LOCK          TaskLock;
-	MLME_QUEUE              Queue;
-
-	UINT                    ShiftReg;
-
-	RALINK_TIMER_STRUCT     PeriodicTimer;
-	RALINK_TIMER_STRUCT     APSDPeriodicTimer;
-	RALINK_TIMER_STRUCT     LinkDownTimer;
-	RALINK_TIMER_STRUCT     LinkUpTimer;
+	ULONG ChannelQuality;	// 0..100, Channel Quality Indication for Roaming
+	ULONG Now32;		// latch the value of NdisGetSystemUpTime()
+	ULONG LastSendNULLpsmTime;
+
+	BOOLEAN bRunning;
+	NDIS_SPIN_LOCK TaskLock;
+	MLME_QUEUE Queue;
+
+	UINT ShiftReg;
+
+	RALINK_TIMER_STRUCT PeriodicTimer;
+	RALINK_TIMER_STRUCT APSDPeriodicTimer;
+	RALINK_TIMER_STRUCT LinkDownTimer;
+	RALINK_TIMER_STRUCT LinkUpTimer;
 #ifdef RTMP_MAC_PCI
-    UCHAR                   bPsPollTimerRunning;
-    RALINK_TIMER_STRUCT     PsPollTimer;
-	RALINK_TIMER_STRUCT     RadioOnOffTimer;
-#endif // RTMP_MAC_PCI //
-	ULONG                   PeriodicRound;
-	ULONG                   OneSecPeriodicRound;
-
-	UCHAR					RealRxPath;
-	BOOLEAN					bLowThroughput;
-	BOOLEAN					bEnableAutoAntennaCheck;
-	RALINK_TIMER_STRUCT		RxAntEvalTimer;
+	UCHAR bPsPollTimerRunning;
+	RALINK_TIMER_STRUCT PsPollTimer;
+	RALINK_TIMER_STRUCT RadioOnOffTimer;
+#endif				// RTMP_MAC_PCI //
+	ULONG PeriodicRound;
+	ULONG OneSecPeriodicRound;
+
+	UCHAR RealRxPath;
+	BOOLEAN bLowThroughput;
+	BOOLEAN bEnableAutoAntennaCheck;
+	RALINK_TIMER_STRUCT RxAntEvalTimer;
 
 #ifdef RT30xx
 	UCHAR CaliBW40RfR24;
 	UCHAR CaliBW20RfR24;
-#endif // RT30xx //
+#endif				// RT30xx //
 
 #ifdef RTMP_MAC_USB
-	RALINK_TIMER_STRUCT	AutoWakeupTimer;
-	BOOLEAN					AutoWakeupTimerRunning;
-#endif // RTMP_MAC_USB //
+	RALINK_TIMER_STRUCT AutoWakeupTimer;
+	BOOLEAN AutoWakeupTimerRunning;
+#endif				// RTMP_MAC_USB //
 } MLME_STRUCT, *PMLME_STRUCT;
 
-
 /***************************************************************************
   *	802.11 N related data structures
   **************************************************************************/
-struct reordering_mpdu
-{
-	struct reordering_mpdu	*next;
-	PNDIS_PACKET			pPacket;		/* coverted to 802.3 frame */
-	int						Sequence;		/* sequence number of MPDU */
-	BOOLEAN					bAMSDU;
+struct reordering_mpdu {
+	struct reordering_mpdu *next;
+	PNDIS_PACKET pPacket;	/* coverted to 802.3 frame */
+	int Sequence;		/* sequence number of MPDU */
+	BOOLEAN bAMSDU;
 };
 
-struct reordering_list
-{
+struct reordering_list {
 	struct reordering_mpdu *next;
-	int	qlen;
+	int qlen;
 };
 
-struct reordering_mpdu_pool
-{
-	PVOID					mem;
-	NDIS_SPIN_LOCK			lock;
-	struct reordering_list	freelist;
+struct reordering_mpdu_pool {
+	PVOID mem;
+	NDIS_SPIN_LOCK lock;
+	struct reordering_list freelist;
 };
 
-typedef enum _REC_BLOCKACK_STATUS
-{
-    Recipient_NONE=0,
+typedef enum _REC_BLOCKACK_STATUS {
+	Recipient_NONE = 0,
 	Recipient_USED,
 	Recipient_HandleRes,
-    Recipient_Accept
+	Recipient_Accept
 } REC_BLOCKACK_STATUS, *PREC_BLOCKACK_STATUS;
 
-typedef enum _ORI_BLOCKACK_STATUS
-{
-    Originator_NONE=0,
+typedef enum _ORI_BLOCKACK_STATUS {
+	Originator_NONE = 0,
 	Originator_USED,
-    Originator_WaitRes,
-    Originator_Done
+	Originator_WaitRes,
+	Originator_Done
 } ORI_BLOCKACK_STATUS, *PORI_BLOCKACK_STATUS;
 
-typedef struct _BA_ORI_ENTRY{
-	UCHAR   Wcid;
-	UCHAR   TID;
-	UCHAR   BAWinSize;
-	UCHAR   Token;
+typedef struct _BA_ORI_ENTRY {
+	UCHAR Wcid;
+	UCHAR TID;
+	UCHAR BAWinSize;
+	UCHAR Token;
 // Sequence is to fill every outgoing QoS DATA frame's sequence field in 802.11 header.
-	USHORT	Sequence;
-	USHORT	TimeOutValue;
-	ORI_BLOCKACK_STATUS  ORI_BA_Status;
+	USHORT Sequence;
+	USHORT TimeOutValue;
+	ORI_BLOCKACK_STATUS ORI_BA_Status;
 	RALINK_TIMER_STRUCT ORIBATimer;
-	PVOID	pAdapter;
+	PVOID pAdapter;
 } BA_ORI_ENTRY, *PBA_ORI_ENTRY;
 
 typedef struct _BA_REC_ENTRY {
-	UCHAR   Wcid;
-	UCHAR   TID;
-	UCHAR   BAWinSize;	// 7.3.1.14. each buffer is capable of holding a max AMSDU or MSDU.
-	//UCHAR	NumOfRxPkt;
+	UCHAR Wcid;
+	UCHAR TID;
+	UCHAR BAWinSize;	// 7.3.1.14. each buffer is capable of holding a max AMSDU or MSDU.
+	//UCHAR NumOfRxPkt;
 	//UCHAR    Curindidx; // the head in the RX reordering buffer
-	USHORT		LastIndSeq;
-//	USHORT		LastIndSeqAtTimer;
-	USHORT		TimeOutValue;
+	USHORT LastIndSeq;
+//      USHORT          LastIndSeqAtTimer;
+	USHORT TimeOutValue;
 	RALINK_TIMER_STRUCT RECBATimer;
-	ULONG		LastIndSeqAtTimer;
-	ULONG		nDropPacket;
-	ULONG		rcvSeq;
-	REC_BLOCKACK_STATUS  REC_BA_Status;
-//	UCHAR	RxBufIdxUsed;
+	ULONG LastIndSeqAtTimer;
+	ULONG nDropPacket;
+	ULONG rcvSeq;
+	REC_BLOCKACK_STATUS REC_BA_Status;
+//      UCHAR   RxBufIdxUsed;
 	// corresponding virtual address for RX reordering packet storage.
 	//RTMP_REORDERDMABUF MAP_RXBuf[MAX_RX_REORDERBUF];
-	NDIS_SPIN_LOCK          RxReRingLock;                 // Rx Ring spinlock
-//	struct _BA_REC_ENTRY *pNext;
-	PVOID	pAdapter;
-	struct reordering_list	list;
+	NDIS_SPIN_LOCK RxReRingLock;	// Rx Ring spinlock
+//      struct _BA_REC_ENTRY *pNext;
+	PVOID pAdapter;
+	struct reordering_list list;
 } BA_REC_ENTRY, *PBA_REC_ENTRY;
 
-
 typedef struct {
-	ULONG		numAsRecipient;		// I am recipient of numAsRecipient clients. These client are in the BARecEntry[]
-	ULONG		numAsOriginator;	// I am originator of 	numAsOriginator clients. These clients are in the BAOriEntry[]
-	ULONG		numDoneOriginator;	// count Done Originator sessions
-	BA_ORI_ENTRY       BAOriEntry[MAX_LEN_OF_BA_ORI_TABLE];
-	BA_REC_ENTRY       BARecEntry[MAX_LEN_OF_BA_REC_TABLE];
+	ULONG numAsRecipient;	// I am recipient of numAsRecipient clients. These client are in the BARecEntry[]
+	ULONG numAsOriginator;	// I am originator of   numAsOriginator clients. These clients are in the BAOriEntry[]
+	ULONG numDoneOriginator;	// count Done Originator sessions
+	BA_ORI_ENTRY BAOriEntry[MAX_LEN_OF_BA_ORI_TABLE];
+	BA_REC_ENTRY BARecEntry[MAX_LEN_OF_BA_REC_TABLE];
 } BA_TABLE, *PBA_TABLE;
 
 //For QureyBATableOID use;
-typedef struct  PACKED _OID_BA_REC_ENTRY{
-	UCHAR   MACAddr[MAC_ADDR_LEN];
-	UCHAR   BaBitmap;   // if (BaBitmap&(1<<TID)), this session with{MACAddr, TID}exists, so read BufSize[TID] for BufferSize
-	UCHAR   rsv;
-	UCHAR   BufSize[8];
-	REC_BLOCKACK_STATUS	REC_BA_Status[8];
+typedef struct PACKED _OID_BA_REC_ENTRY {
+	UCHAR MACAddr[MAC_ADDR_LEN];
+	UCHAR BaBitmap;		// if (BaBitmap&(1<<TID)), this session with{MACAddr, TID}exists, so read BufSize[TID] for BufferSize
+	UCHAR rsv;
+	UCHAR BufSize[8];
+	REC_BLOCKACK_STATUS REC_BA_Status[8];
 } OID_BA_REC_ENTRY, *POID_BA_REC_ENTRY;
 
 //For QureyBATableOID use;
-typedef struct  PACKED _OID_BA_ORI_ENTRY{
-	UCHAR   MACAddr[MAC_ADDR_LEN];
-	UCHAR   BaBitmap;  // if (BaBitmap&(1<<TID)), this session with{MACAddr, TID}exists, so read BufSize[TID] for BufferSize, read ORI_BA_Status[TID] for status
-	UCHAR   rsv;
-	UCHAR   BufSize[8];
-	ORI_BLOCKACK_STATUS  ORI_BA_Status[8];
+typedef struct PACKED _OID_BA_ORI_ENTRY {
+	UCHAR MACAddr[MAC_ADDR_LEN];
+	UCHAR BaBitmap;		// if (BaBitmap&(1<<TID)), this session with{MACAddr, TID}exists, so read BufSize[TID] for BufferSize, read ORI_BA_Status[TID] for status
+	UCHAR rsv;
+	UCHAR BufSize[8];
+	ORI_BLOCKACK_STATUS ORI_BA_Status[8];
 } OID_BA_ORI_ENTRY, *POID_BA_ORI_ENTRY;
 
-typedef struct _QUERYBA_TABLE{
-	OID_BA_ORI_ENTRY       BAOriEntry[32];
-	OID_BA_REC_ENTRY       BARecEntry[32];
-	UCHAR   OriNum;// Number of below BAOriEntry
-	UCHAR   RecNum;// Number of below BARecEntry
+typedef struct _QUERYBA_TABLE {
+	OID_BA_ORI_ENTRY BAOriEntry[32];
+	OID_BA_REC_ENTRY BARecEntry[32];
+	UCHAR OriNum;		// Number of below BAOriEntry
+	UCHAR RecNum;		// Number of below BARecEntry
 } QUERYBA_TABLE, *PQUERYBA_TABLE;
 
-typedef	union	_BACAP_STRUC	{
-	struct	{
-		UINT32		RxBAWinLimit:8;
-		UINT32		TxBAWinLimit:8;
-		UINT32		AutoBA:1;	// automatically BA
-		UINT32		Policy:2;	// 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use
-		UINT32		MpduDensity:3;
-		UINT32       	AmsduEnable:1;	//Enable AMSDU transmisstion
-		UINT32       	AmsduSize:1;	// 0:3839, 1:7935 bytes. UINT  MSDUSizeToBytes[]	= { 3839, 7935};
-		UINT32       	MMPSmode:2;	// MIMO power save more, 0:static, 1:dynamic, 2:rsv, 3:mimo enable
-		UINT32       	bHtAdhoc:1;			// adhoc can use ht rate.
-		UINT32       	b2040CoexistScanSup:1;		//As Sta, support do 2040 coexistence scan for AP. As Ap, support monitor trigger event to check if can use BW 40MHz.
-		UINT32       	:4;
-	}	field;
-	UINT32			word;
+typedef union _BACAP_STRUC {
+	struct {
+		UINT32 RxBAWinLimit:8;
+		UINT32 TxBAWinLimit:8;
+		UINT32 AutoBA:1;	// automatically BA
+		UINT32 Policy:2;	// 0: DELAY_BA 1:IMMED_BA  (//BA Policy subfiled value in ADDBA frame)   2:BA-not use
+		UINT32 MpduDensity:3;
+		UINT32 AmsduEnable:1;	//Enable AMSDU transmisstion
+		UINT32 AmsduSize:1;	// 0:3839, 1:7935 bytes. UINT  MSDUSizeToBytes[]        = { 3839, 7935};
+		UINT32 MMPSmode:2;	// MIMO power save more, 0:static, 1:dynamic, 2:rsv, 3:mimo enable
+		UINT32 bHtAdhoc:1;	// adhoc can use ht rate.
+		UINT32 b2040CoexistScanSup:1;	//As Sta, support do 2040 coexistence scan for AP. As Ap, support monitor trigger event to check if can use BW 40MHz.
+		 UINT32:4;
+	} field;
+	UINT32 word;
 } BACAP_STRUC, *PBACAP_STRUC;
 
-
 typedef struct {
-	BOOLEAN		IsRecipient;
-	UCHAR   MACAddr[MAC_ADDR_LEN];
-	UCHAR   TID;
-	UCHAR   nMSDU;
-	USHORT   TimeOut;
-	BOOLEAN bAllTid;  // If True, delete all TID for BA sessions with this MACaddr.
+	BOOLEAN IsRecipient;
+	UCHAR MACAddr[MAC_ADDR_LEN];
+	UCHAR TID;
+	UCHAR nMSDU;
+	USHORT TimeOut;
+	BOOLEAN bAllTid;	// If True, delete all TID for BA sessions with this MACaddr.
 } OID_ADD_BA_ENTRY, *POID_ADD_BA_ENTRY;
 
-
-
 #define IS_HT_STA(_pMacEntry)	\
 	(_pMacEntry->MaxHTPhyMode.field.MODE >= MODE_HTMIX)
 
@@ -1131,78 +1078,75 @@ typedef struct {
 #define PEER_IS_HT_RATE(_pMacEntry)	\
 	(_pMacEntry->HTPhyMode.field.MODE >= MODE_HTMIX)
 
-
-
 //This structure is for all 802.11n card InterOptibilityTest action. Reset all Num every n second.  (Details see MLMEPeriodic)
-typedef	struct	_IOT_STRUC	{
-	UCHAR			Threshold[2];
-	UCHAR			ReorderTimeOutNum[MAX_LEN_OF_BA_REC_TABLE];	// compare with threshold[0]
-	UCHAR			RefreshNum[MAX_LEN_OF_BA_REC_TABLE];	// compare with threshold[1]
-	ULONG			OneSecInWindowCount;
-	ULONG			OneSecFrameDuplicateCount;
-	ULONG			OneSecOutWindowCount;
-	UCHAR			DelOriAct;
-	UCHAR			DelRecAct;
-	UCHAR			RTSShortProt;
-	UCHAR			RTSLongProt;
-	BOOLEAN			bRTSLongProtOn;
-	BOOLEAN			bLastAtheros;
-    BOOLEAN			bCurrentAtheros;
-    BOOLEAN         bNowAtherosBurstOn;
-	BOOLEAN			bNextDisableRxBA;
-    BOOLEAN			bToggle;
+typedef struct _IOT_STRUC {
+	UCHAR Threshold[2];
+	UCHAR ReorderTimeOutNum[MAX_LEN_OF_BA_REC_TABLE];	// compare with threshold[0]
+	UCHAR RefreshNum[MAX_LEN_OF_BA_REC_TABLE];	// compare with threshold[1]
+	ULONG OneSecInWindowCount;
+	ULONG OneSecFrameDuplicateCount;
+	ULONG OneSecOutWindowCount;
+	UCHAR DelOriAct;
+	UCHAR DelRecAct;
+	UCHAR RTSShortProt;
+	UCHAR RTSLongProt;
+	BOOLEAN bRTSLongProtOn;
+	BOOLEAN bLastAtheros;
+	BOOLEAN bCurrentAtheros;
+	BOOLEAN bNowAtherosBurstOn;
+	BOOLEAN bNextDisableRxBA;
+	BOOLEAN bToggle;
 } IOT_STRUC, *PIOT_STRUC;
 
 // This is the registry setting for 802.11n transmit setting.  Used in advanced page.
 typedef union _REG_TRANSMIT_SETTING {
- struct {
-         //UINT32  PhyMode:4;
-         //UINT32  MCS:7;                 // MCS
-		 UINT32  rsv0:10;
-		 UINT32  TxBF:1;
-         UINT32  BW:1; //channel bandwidth 20MHz or 40 MHz
-         UINT32  ShortGI:1;
-         UINT32  STBC:1; //SPACE
-         UINT32  TRANSNO:2;
-         UINT32  HTMODE:1;
-         UINT32  EXTCHA:2;
-         UINT32  rsv:13;
-    } field;
- UINT32   word;
+	struct {
+		//UINT32  PhyMode:4;
+		//UINT32  MCS:7;                 // MCS
+		UINT32 rsv0:10;
+		UINT32 TxBF:1;
+		UINT32 BW:1;	//channel bandwidth 20MHz or 40 MHz
+		UINT32 ShortGI:1;
+		UINT32 STBC:1;	//SPACE
+		UINT32 TRANSNO:2;
+		UINT32 HTMODE:1;
+		UINT32 EXTCHA:2;
+		UINT32 rsv:13;
+	} field;
+	UINT32 word;
 } REG_TRANSMIT_SETTING, *PREG_TRANSMIT_SETTING;
 
-typedef union  _DESIRED_TRANSMIT_SETTING {
-	struct	{
-			USHORT   	MCS:7;                 	// MCS
-			USHORT		PhyMode:4;
-			USHORT	 	FixedTxMode:2;			// If MCS isn't AUTO, fix rate in CCK, OFDM or HT mode.
-			USHORT		rsv:3;
-	}	field;
-	USHORT		word;
- } DESIRED_TRANSMIT_SETTING, *PDESIRED_TRANSMIT_SETTING;
+typedef union _DESIRED_TRANSMIT_SETTING {
+	struct {
+		USHORT MCS:7;	// MCS
+		USHORT PhyMode:4;
+		USHORT FixedTxMode:2;	// If MCS isn't AUTO, fix rate in CCK, OFDM or HT mode.
+		USHORT rsv:3;
+	} field;
+	USHORT word;
+} DESIRED_TRANSMIT_SETTING, *PDESIRED_TRANSMIT_SETTING;
 
 #ifdef RTMP_MAC_USB
 /***************************************************************************
   *	USB-based chip Beacon related data structures
   **************************************************************************/
 #define BEACON_BITMAP_MASK		0xff
-typedef struct _BEACON_SYNC_STRUCT_
-{
-	UCHAR				BeaconBuf[HW_BEACON_MAX_COUNT][HW_BEACON_OFFSET];
-	UCHAR					BeaconTxWI[HW_BEACON_MAX_COUNT][TXWI_SIZE];
-	ULONG					TimIELocationInBeacon[HW_BEACON_MAX_COUNT];
-	ULONG					CapabilityInfoLocationInBeacon[HW_BEACON_MAX_COUNT];
-	BOOLEAN					EnableBeacon;		// trigger to enable beacon transmission.
-	UCHAR					BeaconBitMap;		// NOTE: If the MAX_MBSSID_NUM is larger than 8, this parameter need to change.
-	UCHAR					DtimBitOn;			// NOTE: If the MAX_MBSSID_NUM is larger than 8, this parameter need to change.
-}BEACON_SYNC_STRUCT;
+typedef struct _BEACON_SYNC_STRUCT_ {
+	UCHAR BeaconBuf[HW_BEACON_MAX_COUNT][HW_BEACON_OFFSET];
+	UCHAR BeaconTxWI[HW_BEACON_MAX_COUNT][TXWI_SIZE];
+	ULONG TimIELocationInBeacon[HW_BEACON_MAX_COUNT];
+	ULONG CapabilityInfoLocationInBeacon[HW_BEACON_MAX_COUNT];
+	BOOLEAN EnableBeacon;	// trigger to enable beacon transmission.
+	UCHAR BeaconBitMap;	// NOTE: If the MAX_MBSSID_NUM is larger than 8, this parameter need to change.
+	UCHAR DtimBitOn;	// NOTE: If the MAX_MBSSID_NUM is larger than 8, this parameter need to change.
+} BEACON_SYNC_STRUCT;
 #endif // RTMP_MAC_USB //
 
 /***************************************************************************
   *	Multiple SSID related data structures
   **************************************************************************/
-#define WLAN_MAX_NUM_OF_TIM			((MAX_LEN_OF_MAC_TABLE >> 3) + 1) /* /8 + 1 */
-#define WLAN_CT_TIM_BCMC_OFFSET		0 /* unit: 32B */
+#define WLAN_MAX_NUM_OF_TIM			((MAX_LEN_OF_MAC_TABLE >> 3) + 1)	/* /8 + 1 */
+#define WLAN_CT_TIM_BCMC_OFFSET		0	/* unit: 32B */
 
 /* clear bcmc TIM bit */
 #define WLAN_MR_TIM_BCMC_CLEAR(apidx) \
@@ -1224,183 +1168,181 @@ typedef struct _BEACON_SYNC_STRUCT_
 		UCHAR bit_offset = wcid & 0x7; \
 		ad_p->ApCfg.MBSSID[apidx].TimBitmaps[tim_offset] |= BIT8[bit_offset]; }
 
-
 // configuration common to OPMODE_AP as well as OPMODE_STA
 typedef struct _COMMON_CONFIG {
 
-	BOOLEAN		bCountryFlag;
-	UCHAR		CountryCode[3];
-	UCHAR		Geography;
-	UCHAR       CountryRegion;      // Enum of country region, 0:FCC, 1:IC, 2:ETSI, 3:SPAIN, 4:France, 5:MKK, 6:MKK1, 7:Israel
-	UCHAR       CountryRegionForABand;	// Enum of country region for A band
-	UCHAR       PhyMode;            // PHY_11A, PHY_11B, PHY_11BG_MIXED, PHY_ABG_MIXED
-	USHORT      Dsifs;              // in units of usec
-	ULONG       PacketFilter;       // Packet filter for receiving
-	UINT8		RegulatoryClass;
-
-	CHAR        Ssid[MAX_LEN_OF_SSID]; // NOT NULL-terminated
-	UCHAR       SsidLen;               // the actual ssid length in used
-	UCHAR       LastSsidLen;               // the actual ssid length in used
-	CHAR        LastSsid[MAX_LEN_OF_SSID]; // NOT NULL-terminated
-	UCHAR		LastBssid[MAC_ADDR_LEN];
-
-	UCHAR       Bssid[MAC_ADDR_LEN];
-	USHORT      BeaconPeriod;
-	UCHAR       Channel;
-	UCHAR       CentralChannel;    	// Central Channel when using 40MHz is indicating. not real channel.
-
-	UCHAR       SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR       SupRateLen;
-	UCHAR       ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR       ExtRateLen;
-	UCHAR       DesireRate[MAX_LEN_OF_SUPPORTED_RATES];      // OID_802_11_DESIRED_RATES
-	UCHAR       MaxDesiredRate;
-	UCHAR       ExpectedACKRate[MAX_LEN_OF_SUPPORTED_RATES];
-
-	ULONG       BasicRateBitmap;        // backup basic ratebitmap
-
-	BOOLEAN		bAPSDCapable;
-	BOOLEAN		bInServicePeriod;
-	BOOLEAN		bAPSDAC_BE;
-	BOOLEAN		bAPSDAC_BK;
-	BOOLEAN		bAPSDAC_VI;
-	BOOLEAN		bAPSDAC_VO;
+	BOOLEAN bCountryFlag;
+	UCHAR CountryCode[3];
+	UCHAR Geography;
+	UCHAR CountryRegion;	// Enum of country region, 0:FCC, 1:IC, 2:ETSI, 3:SPAIN, 4:France, 5:MKK, 6:MKK1, 7:Israel
+	UCHAR CountryRegionForABand;	// Enum of country region for A band
+	UCHAR PhyMode;		// PHY_11A, PHY_11B, PHY_11BG_MIXED, PHY_ABG_MIXED
+	USHORT Dsifs;		// in units of usec
+	ULONG PacketFilter;	// Packet filter for receiving
+	UINT8 RegulatoryClass;
+
+	CHAR Ssid[MAX_LEN_OF_SSID];	// NOT NULL-terminated
+	UCHAR SsidLen;		// the actual ssid length in used
+	UCHAR LastSsidLen;	// the actual ssid length in used
+	CHAR LastSsid[MAX_LEN_OF_SSID];	// NOT NULL-terminated
+	UCHAR LastBssid[MAC_ADDR_LEN];
+
+	UCHAR Bssid[MAC_ADDR_LEN];
+	USHORT BeaconPeriod;
+	UCHAR Channel;
+	UCHAR CentralChannel;	// Central Channel when using 40MHz is indicating. not real channel.
+
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR SupRateLen;
+	UCHAR ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR ExtRateLen;
+	UCHAR DesireRate[MAX_LEN_OF_SUPPORTED_RATES];	// OID_802_11_DESIRED_RATES
+	UCHAR MaxDesiredRate;
+	UCHAR ExpectedACKRate[MAX_LEN_OF_SUPPORTED_RATES];
+
+	ULONG BasicRateBitmap;	// backup basic ratebitmap
+
+	BOOLEAN bAPSDCapable;
+	BOOLEAN bInServicePeriod;
+	BOOLEAN bAPSDAC_BE;
+	BOOLEAN bAPSDAC_BK;
+	BOOLEAN bAPSDAC_VI;
+	BOOLEAN bAPSDAC_VO;
 
 	/* because TSPEC can modify the APSD flag, we need to keep the APSD flag
-		requested in association stage from the station;
-		we need to recover the APSD flag after the TSPEC is deleted. */
-	BOOLEAN		bACMAPSDBackup[4]; /* for delivery-enabled & trigger-enabled both */
-	BOOLEAN		bACMAPSDTr[4]; /* no use */
-
-	BOOLEAN		bNeedSendTriggerFrame;
-	BOOLEAN		bAPSDForcePowerSave;	// Force power save mode, should only use in APSD-STAUT
-	ULONG		TriggerTimerCount;
-	UCHAR		MaxSPLength;
-	UCHAR		BBPCurrentBW;	// BW_10, 	BW_20, BW_40
+	   requested in association stage from the station;
+	   we need to recover the APSD flag after the TSPEC is deleted. */
+	BOOLEAN bACMAPSDBackup[4];	/* for delivery-enabled & trigger-enabled both */
+	BOOLEAN bACMAPSDTr[4];	/* no use */
+
+	BOOLEAN bNeedSendTriggerFrame;
+	BOOLEAN bAPSDForcePowerSave;	// Force power save mode, should only use in APSD-STAUT
+	ULONG TriggerTimerCount;
+	UCHAR MaxSPLength;
+	UCHAR BBPCurrentBW;	// BW_10,       BW_20, BW_40
 	// move to MULTISSID_STRUCT for MBSS
-	//HTTRANSMIT_SETTING	HTPhyMode, MaxHTPhyMode, MinHTPhyMode;// For transmit phy setting in TXWI.
-	REG_TRANSMIT_SETTING        RegTransmitSetting; //registry transmit setting. this is for reading registry setting only. not useful.
+	//HTTRANSMIT_SETTING    HTPhyMode, MaxHTPhyMode, MinHTPhyMode;// For transmit phy setting in TXWI.
+	REG_TRANSMIT_SETTING RegTransmitSetting;	//registry transmit setting. this is for reading registry setting only. not useful.
 	//UCHAR       FixedTxMode;              // Fixed Tx Mode (CCK, OFDM), for HT fixed tx mode (GF, MIX) , refer to RegTransmitSetting.field.HTMode
-	UCHAR       TxRate;                 // Same value to fill in TXD. TxRate is 6-bit
-	UCHAR       MaxTxRate;              // RATE_1, RATE_2, RATE_5_5, RATE_11
-	UCHAR       TxRateIndex;            // Tx rate index in RateSwitchTable
-	UCHAR       TxRateTableSize;        // Valid Tx rate table size in RateSwitchTable
-	//BOOLEAN		bAutoTxRateSwitch;
-	UCHAR       MinTxRate;              // RATE_1, RATE_2, RATE_5_5, RATE_11
-	UCHAR       RtsRate;                // RATE_xxx
-	HTTRANSMIT_SETTING	MlmeTransmit;   // MGMT frame PHY rate setting when operatin at Ht rate.
-	UCHAR       MlmeRate;               // RATE_xxx, used to send MLME frames
-	UCHAR       BasicMlmeRate;          // Default Rate for sending MLME frames
-
-	USHORT      RtsThreshold;           // in unit of BYTE
-	USHORT      FragmentThreshold;      // in unit of BYTE
-
-	UCHAR       TxPower;                // in unit of mW
-	ULONG       TxPowerPercentage;      // 0~100 %
-	ULONG       TxPowerDefault;         // keep for TxPowerPercentage
-	UINT8		PwrConstraint;
-
-	BACAP_STRUC        BACapability; //   NO USE = 0XFF  ;  IMMED_BA =1  ;  DELAY_BA=0
-	BACAP_STRUC        REGBACapability; //   NO USE = 0XFF  ;  IMMED_BA =1  ;  DELAY_BA=0
-
-	IOT_STRUC		IOTestParm;	// 802.11n InterOpbility Test Parameter;
-	ULONG       TxPreamble;             // Rt802_11PreambleLong, Rt802_11PreambleShort, Rt802_11PreambleAuto
-	BOOLEAN     bUseZeroToDisableFragment;     // Microsoft use 0 as disable
-	ULONG       UseBGProtection;        // 0: auto, 1: always use, 2: always not use
-	BOOLEAN     bUseShortSlotTime;      // 0: disable, 1 - use short slot (9us)
-	BOOLEAN     bEnableTxBurst;         // 1: enble TX PACKET BURST (when BA is established or AP is not a legacy WMM AP), 0: disable TX PACKET BURST
-	BOOLEAN     bAggregationCapable;      // 1: enable TX aggregation when the peer supports it
-	BOOLEAN     bPiggyBackCapable;		// 1: enable TX piggy-back according MAC's version
-	BOOLEAN     bIEEE80211H;			// 1: enable IEEE802.11h spec.
-	ULONG		DisableOLBCDetect;		// 0: enable OLBC detect; 1 disable OLBC detect
-
-	BOOLEAN				bRdg;
-
-	BOOLEAN             bWmmCapable;        // 0:disable WMM, 1:enable WMM
-	QOS_CAPABILITY_PARM APQosCapability;    // QOS capability of the current associated AP
-	EDCA_PARM           APEdcaParm;         // EDCA parameters of the current associated AP
-	QBSS_LOAD_PARM      APQbssLoad;         // QBSS load of the current associated AP
-	UCHAR               AckPolicy[4];       // ACK policy of the specified AC. see ACK_xxx
-	BOOLEAN				bDLSCapable;		// 0:disable DLS, 1:enable DLS
+	UCHAR TxRate;		// Same value to fill in TXD. TxRate is 6-bit
+	UCHAR MaxTxRate;	// RATE_1, RATE_2, RATE_5_5, RATE_11
+	UCHAR TxRateIndex;	// Tx rate index in RateSwitchTable
+	UCHAR TxRateTableSize;	// Valid Tx rate table size in RateSwitchTable
+	//BOOLEAN               bAutoTxRateSwitch;
+	UCHAR MinTxRate;	// RATE_1, RATE_2, RATE_5_5, RATE_11
+	UCHAR RtsRate;		// RATE_xxx
+	HTTRANSMIT_SETTING MlmeTransmit;	// MGMT frame PHY rate setting when operatin at Ht rate.
+	UCHAR MlmeRate;		// RATE_xxx, used to send MLME frames
+	UCHAR BasicMlmeRate;	// Default Rate for sending MLME frames
+
+	USHORT RtsThreshold;	// in unit of BYTE
+	USHORT FragmentThreshold;	// in unit of BYTE
+
+	UCHAR TxPower;		// in unit of mW
+	ULONG TxPowerPercentage;	// 0~100 %
+	ULONG TxPowerDefault;	// keep for TxPowerPercentage
+	UINT8 PwrConstraint;
+
+	BACAP_STRUC BACapability;	//   NO USE = 0XFF  ;  IMMED_BA =1  ;  DELAY_BA=0
+	BACAP_STRUC REGBACapability;	//   NO USE = 0XFF  ;  IMMED_BA =1  ;  DELAY_BA=0
+
+	IOT_STRUC IOTestParm;	// 802.11n InterOpbility Test Parameter;
+	ULONG TxPreamble;	// Rt802_11PreambleLong, Rt802_11PreambleShort, Rt802_11PreambleAuto
+	BOOLEAN bUseZeroToDisableFragment;	// Microsoft use 0 as disable
+	ULONG UseBGProtection;	// 0: auto, 1: always use, 2: always not use
+	BOOLEAN bUseShortSlotTime;	// 0: disable, 1 - use short slot (9us)
+	BOOLEAN bEnableTxBurst;	// 1: enble TX PACKET BURST (when BA is established or AP is not a legacy WMM AP), 0: disable TX PACKET BURST
+	BOOLEAN bAggregationCapable;	// 1: enable TX aggregation when the peer supports it
+	BOOLEAN bPiggyBackCapable;	// 1: enable TX piggy-back according MAC's version
+	BOOLEAN bIEEE80211H;	// 1: enable IEEE802.11h spec.
+	ULONG DisableOLBCDetect;	// 0: enable OLBC detect; 1 disable OLBC detect
+
+	BOOLEAN bRdg;
+
+	BOOLEAN bWmmCapable;	// 0:disable WMM, 1:enable WMM
+	QOS_CAPABILITY_PARM APQosCapability;	// QOS capability of the current associated AP
+	EDCA_PARM APEdcaParm;	// EDCA parameters of the current associated AP
+	QBSS_LOAD_PARM APQbssLoad;	// QBSS load of the current associated AP
+	UCHAR AckPolicy[4];	// ACK policy of the specified AC. see ACK_xxx
+	BOOLEAN bDLSCapable;	// 0:disable DLS, 1:enable DLS
 	// a bitmap of BOOLEAN flags. each bit represent an operation status of a particular
 	// BOOLEAN control, either ON or OFF. These flags should always be accessed via
 	// OPSTATUS_TEST_FLAG(), OPSTATUS_SET_FLAG(), OP_STATUS_CLEAR_FLAG() macros.
 	// see fOP_STATUS_xxx in RTMP_DEF.C for detail bit definition
-	ULONG               OpStatusFlags;
+	ULONG OpStatusFlags;
 
-	BOOLEAN				NdisRadioStateOff; //For HCT 12.0, set this flag to TRUE instead of called MlmeRadioOff.
-	ABGBAND_STATE		BandState;		// For setting BBP used on B/G or A mode.
+	BOOLEAN NdisRadioStateOff;	//For HCT 12.0, set this flag to TRUE instead of called MlmeRadioOff.
+	ABGBAND_STATE BandState;	// For setting BBP used on B/G or A mode.
 
 	// IEEE802.11H--DFS.
-	RADAR_DETECT_STRUCT	RadarDetect;
+	RADAR_DETECT_STRUCT RadarDetect;
 
 	// HT
-	UCHAR			BASize;		// USer desired BAWindowSize. Should not exceed our max capability
-	//RT_HT_CAPABILITY	SupportedHtPhy;
-	RT_HT_CAPABILITY	DesiredHtPhy;
-	HT_CAPABILITY_IE		HtCapability;
-	ADD_HT_INFO_IE		AddHTInfo;	// Useful as AP.
+	UCHAR BASize;		// USer desired BAWindowSize. Should not exceed our max capability
+	//RT_HT_CAPABILITY      SupportedHtPhy;
+	RT_HT_CAPABILITY DesiredHtPhy;
+	HT_CAPABILITY_IE HtCapability;
+	ADD_HT_INFO_IE AddHTInfo;	// Useful as AP.
 	//This IE is used with channel switch announcement element when changing to a new 40MHz.
 	//This IE is included in channel switch ammouncement frames 7.4.1.5, beacons, probe Rsp.
-	NEW_EXT_CHAN_IE	NewExtChanOffset;	//7.3.2.20A, 1 if extension channel is above the control channel, 3 if below, 0 if not present
+	NEW_EXT_CHAN_IE NewExtChanOffset;	//7.3.2.20A, 1 if extension channel is above the control channel, 3 if below, 0 if not present
 
-    BOOLEAN                 bHTProtect;
-    BOOLEAN                 bMIMOPSEnable;
-    BOOLEAN					bBADecline;
+	BOOLEAN bHTProtect;
+	BOOLEAN bMIMOPSEnable;
+	BOOLEAN bBADecline;
 //2008/11/05: KH add to support Antenna power-saving of AP<--
-	BOOLEAN					bGreenAPEnable;
+	BOOLEAN bGreenAPEnable;
 //2008/11/05: KH add to support Antenna power-saving of AP-->
-	BOOLEAN					bDisableReordering;
-	BOOLEAN					bForty_Mhz_Intolerant;
-	BOOLEAN					bExtChannelSwitchAnnouncement;
-	BOOLEAN					bRcvBSSWidthTriggerEvents;
-	ULONG					LastRcvBSSWidthTriggerEventsTime;
+	BOOLEAN bDisableReordering;
+	BOOLEAN bForty_Mhz_Intolerant;
+	BOOLEAN bExtChannelSwitchAnnouncement;
+	BOOLEAN bRcvBSSWidthTriggerEvents;
+	ULONG LastRcvBSSWidthTriggerEventsTime;
 
-	UCHAR					TxBASize;
+	UCHAR TxBASize;
 
 	// Enable wireless event
-	BOOLEAN				bWirelessEvent;
-	BOOLEAN				bWiFiTest;				// Enable this parameter for WiFi test
+	BOOLEAN bWirelessEvent;
+	BOOLEAN bWiFiTest;	// Enable this parameter for WiFi test
 
 	// Tx & Rx Stream number selection
-	UCHAR				TxStream;
-	UCHAR				RxStream;
+	UCHAR TxStream;
+	UCHAR RxStream;
 
-	BOOLEAN     		bHardwareRadio;     // Hardware controlled Radio enabled
+	BOOLEAN bHardwareRadio;	// Hardware controlled Radio enabled
 
 #ifdef RTMP_MAC_USB
-	BOOLEAN     		bMultipleIRP;       // Multiple Bulk IN flag
-	UCHAR       		NumOfBulkInIRP;     // if bMultipleIRP == TRUE, NumOfBulkInIRP will be 4 otherwise be 1
- 	RT_HT_CAPABILITY	SupportedHtPhy;
-	ULONG				MaxPktOneTxBulk;
-	UCHAR				TxBulkFactor;
-	UCHAR				RxBulkFactor;
-
-	BOOLEAN				IsUpdateBeacon;
-	BEACON_SYNC_STRUCT	*pBeaconSync;
-	RALINK_TIMER_STRUCT	BeaconUpdateTimer;
-	UINT32				BeaconAdjust;
-	UINT32				BeaconFactor;
-	UINT32				BeaconRemain;
-#endif // RTMP_MAC_USB //
+	BOOLEAN bMultipleIRP;	// Multiple Bulk IN flag
+	UCHAR NumOfBulkInIRP;	// if bMultipleIRP == TRUE, NumOfBulkInIRP will be 4 otherwise be 1
+	RT_HT_CAPABILITY SupportedHtPhy;
+	ULONG MaxPktOneTxBulk;
+	UCHAR TxBulkFactor;
+	UCHAR RxBulkFactor;
+
+	BOOLEAN IsUpdateBeacon;
+	BEACON_SYNC_STRUCT *pBeaconSync;
+	RALINK_TIMER_STRUCT BeaconUpdateTimer;
+	UINT32 BeaconAdjust;
+	UINT32 BeaconFactor;
+	UINT32 BeaconRemain;
+#endif				// RTMP_MAC_USB //
 
- 	NDIS_SPIN_LOCK			MeasureReqTabLock;
-	PMEASURE_REQ_TAB		pMeasureReqTab;
+	NDIS_SPIN_LOCK MeasureReqTabLock;
+	PMEASURE_REQ_TAB pMeasureReqTab;
 
-	NDIS_SPIN_LOCK			TpcReqTabLock;
-	PTPC_REQ_TAB			pTpcReqTab;
+	NDIS_SPIN_LOCK TpcReqTabLock;
+	PTPC_REQ_TAB pTpcReqTab;
 
-	BOOLEAN				PSPXlink;  // 0: Disable. 1: Enable
+	BOOLEAN PSPXlink;	// 0: Disable. 1: Enable
 
 #if defined(RT305x)||defined(RT30xx)
 	// request by Gary, for High Power issue
-	UCHAR	HighPowerPatchDisabled;
+	UCHAR HighPowerPatchDisabled;
 #endif
 
-	BOOLEAN		HT_DisallowTKIP;		/* Restrict the encryption type in 11n HT mode */
+	BOOLEAN HT_DisallowTKIP;	/* Restrict the encryption type in 11n HT mode */
 } COMMON_CONFIG, *PCOMMON_CONFIG;
 
-
 /* Modified by Wu Xi-Kun 4/21/2006 */
 // STA configuration and status
 typedef struct _STA_ADMIN_CONFIG {
@@ -1410,165 +1352,161 @@ typedef struct _STA_ADMIN_CONFIG {
 	//   settings in ACTIVE BSS after negotiation/compromize with the BSS holder (either
 	//   AP or IBSS holder).
 	//   Once initialized, user configuration can only be changed via OID_xxx
-	UCHAR       BssType;              // BSS_INFRA or BSS_ADHOC
-	USHORT      AtimWin;          // used when starting a new IBSS
+	UCHAR BssType;		// BSS_INFRA or BSS_ADHOC
+	USHORT AtimWin;		// used when starting a new IBSS
 
 	// GROUP 2 -
 	//   User configuration loaded from Registry, E2PROM or OID_xxx. These settings describe
 	//   the user intended configuration, and should be always applied to the final
 	//   settings in ACTIVE BSS without compromising with the BSS holder.
 	//   Once initialized, user configuration can only be changed via OID_xxx
-	UCHAR       RssiTrigger;
-	UCHAR       RssiTriggerMode;      // RSSI_TRIGGERED_UPON_BELOW_THRESHOLD or RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD
-	USHORT      DefaultListenCount;   // default listen count;
-	ULONG       WindowsPowerMode;           // Power mode for AC power
-	ULONG       WindowsBatteryPowerMode;    // Power mode for battery if exists
-	BOOLEAN     bWindowsACCAMEnable;        // Enable CAM power mode when AC on
-	BOOLEAN     bAutoReconnect;         // Set to TRUE when setting OID_802_11_SSID with no matching BSSID
-	ULONG       WindowsPowerProfile;    // Windows power profile, for NDIS5.1 PnP
+	UCHAR RssiTrigger;
+	UCHAR RssiTriggerMode;	// RSSI_TRIGGERED_UPON_BELOW_THRESHOLD or RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD
+	USHORT DefaultListenCount;	// default listen count;
+	ULONG WindowsPowerMode;	// Power mode for AC power
+	ULONG WindowsBatteryPowerMode;	// Power mode for battery if exists
+	BOOLEAN bWindowsACCAMEnable;	// Enable CAM power mode when AC on
+	BOOLEAN bAutoReconnect;	// Set to TRUE when setting OID_802_11_SSID with no matching BSSID
+	ULONG WindowsPowerProfile;	// Windows power profile, for NDIS5.1 PnP
 
 	// MIB:ieee802dot11.dot11smt(1).dot11StationConfigTable(1)
-	USHORT      Psm;                  // power management mode   (PWR_ACTIVE|PWR_SAVE)
-	USHORT      DisassocReason;
-	UCHAR       DisassocSta[MAC_ADDR_LEN];
-	USHORT      DeauthReason;
-	UCHAR       DeauthSta[MAC_ADDR_LEN];
-	USHORT      AuthFailReason;
-	UCHAR       AuthFailSta[MAC_ADDR_LEN];
-
-	NDIS_802_11_PRIVACY_FILTER          PrivacyFilter;  // PrivacyFilter enum for 802.1X
-	NDIS_802_11_AUTHENTICATION_MODE     AuthMode;       // This should match to whatever microsoft defined
-	NDIS_802_11_WEP_STATUS              WepStatus;
-	NDIS_802_11_WEP_STATUS				OrigWepStatus;	// Original wep status set from OID
+	USHORT Psm;		// power management mode   (PWR_ACTIVE|PWR_SAVE)
+	USHORT DisassocReason;
+	UCHAR DisassocSta[MAC_ADDR_LEN];
+	USHORT DeauthReason;
+	UCHAR DeauthSta[MAC_ADDR_LEN];
+	USHORT AuthFailReason;
+	UCHAR AuthFailSta[MAC_ADDR_LEN];
+
+	NDIS_802_11_PRIVACY_FILTER PrivacyFilter;	// PrivacyFilter enum for 802.1X
+	NDIS_802_11_AUTHENTICATION_MODE AuthMode;	// This should match to whatever microsoft defined
+	NDIS_802_11_WEP_STATUS WepStatus;
+	NDIS_802_11_WEP_STATUS OrigWepStatus;	// Original wep status set from OID
 
 	// Add to support different cipher suite for WPA2/WPA mode
-	NDIS_802_11_ENCRYPTION_STATUS		GroupCipher;		// Multicast cipher suite
-	NDIS_802_11_ENCRYPTION_STATUS		PairCipher;			// Unicast cipher suite
-	BOOLEAN								bMixCipher;			// Indicate current Pair & Group use different cipher suites
-	USHORT								RsnCapability;
-
-	NDIS_802_11_WEP_STATUS              GroupKeyWepStatus;
-
-	UCHAR		WpaPassPhrase[64];		// WPA PSK pass phrase
-	UINT		WpaPassPhraseLen;		// the length of WPA PSK pass phrase
-	UCHAR		PMK[32];                // WPA PSK mode PMK
-	UCHAR       PTK[64];                // WPA PSK mode PTK
-	UCHAR		GTK[32];				// GTK from authenticator
-	BSSID_INFO	SavedPMK[PMKID_NO];
-	UINT		SavedPMKNum;			// Saved PMKID number
-
-	UCHAR		DefaultKeyId;
+	NDIS_802_11_ENCRYPTION_STATUS GroupCipher;	// Multicast cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS PairCipher;	// Unicast cipher suite
+	BOOLEAN bMixCipher;	// Indicate current Pair & Group use different cipher suites
+	USHORT RsnCapability;
+
+	NDIS_802_11_WEP_STATUS GroupKeyWepStatus;
+
+	UCHAR WpaPassPhrase[64];	// WPA PSK pass phrase
+	UINT WpaPassPhraseLen;	// the length of WPA PSK pass phrase
+	UCHAR PMK[32];		// WPA PSK mode PMK
+	UCHAR PTK[64];		// WPA PSK mode PTK
+	UCHAR GTK[32];		// GTK from authenticator
+	BSSID_INFO SavedPMK[PMKID_NO];
+	UINT SavedPMKNum;	// Saved PMKID number
 
+	UCHAR DefaultKeyId;
 
 	// WPA 802.1x port control, WPA_802_1X_PORT_SECURED, WPA_802_1X_PORT_NOT_SECURED
-	UCHAR       PortSecured;
+	UCHAR PortSecured;
 
 	// For WPA countermeasures
-	ULONG       LastMicErrorTime;   // record last MIC error time
-	ULONG       MicErrCnt;          // Should be 0, 1, 2, then reset to zero (after disassoiciation).
-	BOOLEAN     bBlockAssoc;        // Block associate attempt for 60 seconds after counter measure occurred.
+	ULONG LastMicErrorTime;	// record last MIC error time
+	ULONG MicErrCnt;	// Should be 0, 1, 2, then reset to zero (after disassoiciation).
+	BOOLEAN bBlockAssoc;	// Block associate attempt for 60 seconds after counter measure occurred.
 	// For WPA-PSK supplicant state
-	WPA_STATE   WpaState;           // Default is SS_NOTUSE and handled by microsoft 802.1x
-	UCHAR       ReplayCounter[8];
-	UCHAR       ANonce[32];         // ANonce for WPA-PSK from aurhenticator
-	UCHAR       SNonce[32];         // SNonce for WPA-PSK
+	WPA_STATE WpaState;	// Default is SS_NOTUSE and handled by microsoft 802.1x
+	UCHAR ReplayCounter[8];
+	UCHAR ANonce[32];	// ANonce for WPA-PSK from aurhenticator
+	UCHAR SNonce[32];	// SNonce for WPA-PSK
 
-	UCHAR       LastSNR0;             // last received BEACON's SNR
-	UCHAR       LastSNR1;            // last received BEACON's SNR for 2nd  antenna
+	UCHAR LastSNR0;		// last received BEACON's SNR
+	UCHAR LastSNR1;		// last received BEACON's SNR for 2nd  antenna
 	RSSI_SAMPLE RssiSample;
-	ULONG       NumOfAvgRssiSample;
+	ULONG NumOfAvgRssiSample;
 
-	ULONG       LastBeaconRxTime;     // OS's timestamp of the last BEACON RX time
-	ULONG       Last11bBeaconRxTime;  // OS's timestamp of the last 11B BEACON RX time
-	ULONG		Last11gBeaconRxTime;	// OS's timestamp of the last 11G BEACON RX time
-	ULONG		Last20NBeaconRxTime;	// OS's timestamp of the last 20MHz N BEACON RX time
-
-	ULONG       LastScanTime;       // Record last scan time for issue BSSID_SCAN_LIST
-	ULONG       ScanCnt;            // Scan counts since most recent SSID, BSSID, SCAN OID request
-	BOOLEAN     bSwRadio;           // Software controlled Radio On/Off, TRUE: On
-	BOOLEAN     bHwRadio;           // Hardware controlled Radio On/Off, TRUE: On
-	BOOLEAN     bRadio;             // Radio state, And of Sw & Hw radio state
-	BOOLEAN     bHardwareRadio;     // Hardware controlled Radio enabled
-	BOOLEAN     bShowHiddenSSID;    // Show all known SSID in SSID list get operation
+	ULONG LastBeaconRxTime;	// OS's timestamp of the last BEACON RX time
+	ULONG Last11bBeaconRxTime;	// OS's timestamp of the last 11B BEACON RX time
+	ULONG Last11gBeaconRxTime;	// OS's timestamp of the last 11G BEACON RX time
+	ULONG Last20NBeaconRxTime;	// OS's timestamp of the last 20MHz N BEACON RX time
+
+	ULONG LastScanTime;	// Record last scan time for issue BSSID_SCAN_LIST
+	ULONG ScanCnt;		// Scan counts since most recent SSID, BSSID, SCAN OID request
+	BOOLEAN bSwRadio;	// Software controlled Radio On/Off, TRUE: On
+	BOOLEAN bHwRadio;	// Hardware controlled Radio On/Off, TRUE: On
+	BOOLEAN bRadio;		// Radio state, And of Sw & Hw radio state
+	BOOLEAN bHardwareRadio;	// Hardware controlled Radio enabled
+	BOOLEAN bShowHiddenSSID;	// Show all known SSID in SSID list get operation
 
 	// New for WPA, windows want us to keep association information and
 	// Fixed IEs from last association response
-	NDIS_802_11_ASSOCIATION_INFORMATION     AssocInfo;
-	USHORT       ReqVarIELen;                // Length of next VIE include EID & Length
-	UCHAR       ReqVarIEs[MAX_VIE_LEN];		// The content saved here should be little-endian format.
-	USHORT       ResVarIELen;                // Length of next VIE include EID & Length
-	UCHAR       ResVarIEs[MAX_VIE_LEN];
-
-	UCHAR       RSNIE_Len;
-	UCHAR       RSN_IE[MAX_LEN_OF_RSNIE];	// The content saved here should be little-endian format.
-
-	ULONG               CLBusyBytes;                // Save the total bytes received durning channel load scan time
-	USHORT              RPIDensity[8];              // Array for RPI density collection
-
-	UCHAR               RMReqCnt;                   // Number of measurement request saved.
-	UCHAR               CurrentRMReqIdx;            // Number of measurement request saved.
-	BOOLEAN             ParallelReq;                // Parallel measurement, only one request performed,
-													// It must be the same channel with maximum duration
-	USHORT              ParallelDuration;           // Maximum duration for parallel measurement
-	UCHAR               ParallelChannel;            // Only one channel with parallel measurement
-	USHORT              IAPPToken;                  // IAPP dialog token
+	NDIS_802_11_ASSOCIATION_INFORMATION AssocInfo;
+	USHORT ReqVarIELen;	// Length of next VIE include EID & Length
+	UCHAR ReqVarIEs[MAX_VIE_LEN];	// The content saved here should be little-endian format.
+	USHORT ResVarIELen;	// Length of next VIE include EID & Length
+	UCHAR ResVarIEs[MAX_VIE_LEN];
+
+	UCHAR RSNIE_Len;
+	UCHAR RSN_IE[MAX_LEN_OF_RSNIE];	// The content saved here should be little-endian format.
+
+	ULONG CLBusyBytes;	// Save the total bytes received durning channel load scan time
+	USHORT RPIDensity[8];	// Array for RPI density collection
+
+	UCHAR RMReqCnt;		// Number of measurement request saved.
+	UCHAR CurrentRMReqIdx;	// Number of measurement request saved.
+	BOOLEAN ParallelReq;	// Parallel measurement, only one request performed,
+	// It must be the same channel with maximum duration
+	USHORT ParallelDuration;	// Maximum duration for parallel measurement
+	UCHAR ParallelChannel;	// Only one channel with parallel measurement
+	USHORT IAPPToken;	// IAPP dialog token
 	// Hack for channel load and noise histogram parameters
-	UCHAR               NHFactor;                   // Parameter for Noise histogram
-	UCHAR               CLFactor;                   // Parameter for channel load
+	UCHAR NHFactor;		// Parameter for Noise histogram
+	UCHAR CLFactor;		// Parameter for channel load
 
-	RALINK_TIMER_STRUCT	StaQuickResponeForRateUpTimer;
-	BOOLEAN				StaQuickResponeForRateUpTimerRunning;
+	RALINK_TIMER_STRUCT StaQuickResponeForRateUpTimer;
+	BOOLEAN StaQuickResponeForRateUpTimerRunning;
 
-	UCHAR           	DtimCount;      // 0.. DtimPeriod-1
-	UCHAR           	DtimPeriod;     // default = 3
+	UCHAR DtimCount;	// 0.. DtimPeriod-1
+	UCHAR DtimPeriod;	// default = 3
 
 	////////////////////////////////////////////////////////////////////////////////////////
 	// This is only for WHQL test.
-	BOOLEAN				WhqlTest;
+	BOOLEAN WhqlTest;
 	////////////////////////////////////////////////////////////////////////////////////////
 
-    RALINK_TIMER_STRUCT WpaDisassocAndBlockAssocTimer;
-    // Fast Roaming
-	BOOLEAN		        bAutoRoaming;       // 0:disable auto roaming by RSSI, 1:enable auto roaming by RSSI
-	CHAR		        dBmToRoam;          // the condition to roam when receiving Rssi less than this value. It's negative value.
-
-    BOOLEAN             IEEE8021X;
-    BOOLEAN             IEEE8021x_required_keys;
-    CIPHER_KEY	        DesireSharedKey[4];	// Record user desired WEP keys
-    UCHAR               DesireSharedKeyId;
-
-    // 0: driver ignores wpa_supplicant
-    // 1: wpa_supplicant initiates scanning and AP selection
-    // 2: driver takes care of scanning, AP selection, and IEEE 802.11 association parameters
-    UCHAR               WpaSupplicantUP;
-	UCHAR				WpaSupplicantScanCount;
-	BOOLEAN				bRSN_IE_FromWpaSupplicant;
-
-    CHAR                dev_name[16];
-    USHORT              OriDevType;
-
-    BOOLEAN             bTGnWifiTest;
-	BOOLEAN			    bScanReqIsFromWebUI;
-
-	HTTRANSMIT_SETTING				HTPhyMode, MaxHTPhyMode, MinHTPhyMode;// For transmit phy setting in TXWI.
-	DESIRED_TRANSMIT_SETTING       	DesiredTransmitSetting;
-	RT_HT_PHY_INFO					DesiredHtPhyInfo;
-	BOOLEAN							bAutoTxRateSwitch;
+	RALINK_TIMER_STRUCT WpaDisassocAndBlockAssocTimer;
+	// Fast Roaming
+	BOOLEAN bAutoRoaming;	// 0:disable auto roaming by RSSI, 1:enable auto roaming by RSSI
+	CHAR dBmToRoam;		// the condition to roam when receiving Rssi less than this value. It's negative value.
+
+	BOOLEAN IEEE8021X;
+	BOOLEAN IEEE8021x_required_keys;
+	CIPHER_KEY DesireSharedKey[4];	// Record user desired WEP keys
+	UCHAR DesireSharedKeyId;
+
+	// 0: driver ignores wpa_supplicant
+	// 1: wpa_supplicant initiates scanning and AP selection
+	// 2: driver takes care of scanning, AP selection, and IEEE 802.11 association parameters
+	UCHAR WpaSupplicantUP;
+	UCHAR WpaSupplicantScanCount;
+	BOOLEAN bRSN_IE_FromWpaSupplicant;
+
+	CHAR dev_name[16];
+	USHORT OriDevType;
+
+	BOOLEAN bTGnWifiTest;
+	BOOLEAN bScanReqIsFromWebUI;
+
+	HTTRANSMIT_SETTING HTPhyMode, MaxHTPhyMode, MinHTPhyMode;	// For transmit phy setting in TXWI.
+	DESIRED_TRANSMIT_SETTING DesiredTransmitSetting;
+	RT_HT_PHY_INFO DesiredHtPhyInfo;
+	BOOLEAN bAutoTxRateSwitch;
 
 #ifdef RTMP_MAC_PCI
-    UCHAR       BBPR3;
+	UCHAR BBPR3;
 	// PS Control has 2 meanings for advanced power save function.
 	// 1. EnablePSinIdle : When no connection, always radio off except need to do site survey.
 	// 2. EnableNewPS  : will save more current in sleep or radio off mode.
-	PS_CONTROL				PSControl;
-#endif // RTMP_MAC_PCI //
-
-
-
+	PS_CONTROL PSControl;
+#endif				// RTMP_MAC_PCI //
 
-	BOOLEAN				bAutoConnectByBssid;
-	ULONG				BeaconLostTime;	// seconds
-	BOOLEAN			bForceTxBurst;          // 1: force enble TX PACKET BURST, 0: disable
+	BOOLEAN bAutoConnectByBssid;
+	ULONG BeaconLostTime;	// seconds
+	BOOLEAN bForceTxBurst;	// 1: force enble TX PACKET BURST, 0: disable
 } STA_ADMIN_CONFIG, *PSTA_ADMIN_CONFIG;
 
 // This data structure keep the current active BSS/IBSS's configuration that this STA
@@ -1578,680 +1516,637 @@ typedef struct _STA_ADMIN_CONFIG {
 // Normally, after SCAN or failed roaming attempts, we need to recover back to
 // the current active settings.
 typedef struct _STA_ACTIVE_CONFIG {
-	USHORT      Aid;
-	USHORT      AtimWin;                // in kusec; IBSS parameter set element
-	USHORT      CapabilityInfo;
-	USHORT      CfpMaxDuration;
-	USHORT      CfpPeriod;
+	USHORT Aid;
+	USHORT AtimWin;		// in kusec; IBSS parameter set element
+	USHORT CapabilityInfo;
+	USHORT CfpMaxDuration;
+	USHORT CfpPeriod;
 
 	// Copy supported rate from desired AP's beacon. We are trying to match
 	// AP's supported and extended rate settings.
-	UCHAR       SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR       ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR       SupRateLen;
-	UCHAR       ExtRateLen;
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR SupRateLen;
+	UCHAR ExtRateLen;
 	// Copy supported ht from desired AP's beacon. We are trying to match
-	RT_HT_PHY_INFO		SupportedPhyInfo;
-	RT_HT_CAPABILITY	SupportedHtPhy;
+	RT_HT_PHY_INFO SupportedPhyInfo;
+	RT_HT_CAPABILITY SupportedHtPhy;
 } STA_ACTIVE_CONFIG, *PSTA_ACTIVE_CONFIG;
 
-
-
-
-
-
 typedef struct _MAC_TABLE_ENTRY {
 	//Choose 1 from ValidAsWDS and ValidAsCLI  to validize.
-	BOOLEAN		ValidAsCLI;		// Sta mode, set this TRUE after Linkup,too.
-	BOOLEAN		ValidAsWDS;	// This is WDS Entry. only for AP mode.
-	BOOLEAN		ValidAsApCli;   //This is a AP-Client entry, only for AP mode which enable AP-Client functions.
-	BOOLEAN		ValidAsMesh;
-	BOOLEAN		ValidAsDls;	// This is DLS Entry. only for STA mode.
-	BOOLEAN		isCached;
-	BOOLEAN		bIAmBadAtheros;	// Flag if this is Atheros chip that has IOT problem.  We need to turn on RTS/CTS protection.
+	BOOLEAN ValidAsCLI;	// Sta mode, set this TRUE after Linkup,too.
+	BOOLEAN ValidAsWDS;	// This is WDS Entry. only for AP mode.
+	BOOLEAN ValidAsApCli;	//This is a AP-Client entry, only for AP mode which enable AP-Client functions.
+	BOOLEAN ValidAsMesh;
+	BOOLEAN ValidAsDls;	// This is DLS Entry. only for STA mode.
+	BOOLEAN isCached;
+	BOOLEAN bIAmBadAtheros;	// Flag if this is Atheros chip that has IOT problem.  We need to turn on RTS/CTS protection.
 
-	UCHAR         	EnqueueEapolStartTimerRunning;  // Enqueue EAPoL-Start for triggering EAP SM
+	UCHAR EnqueueEapolStartTimerRunning;	// Enqueue EAPoL-Start for triggering EAP SM
 	//jan for wpa
 	// record which entry revoke MIC Failure , if it leaves the BSS itself, AP won't update aMICFailTime MIB
-	UCHAR           CMTimerRunning;
-	UCHAR           apidx;			// MBSS number
-	UCHAR           RSNIE_Len;
-	UCHAR           RSN_IE[MAX_LEN_OF_RSNIE];
-	UCHAR           ANonce[LEN_KEY_DESC_NONCE];
-	UCHAR           SNonce[LEN_KEY_DESC_NONCE];
-	UCHAR           R_Counter[LEN_KEY_DESC_REPLAY];
-	UCHAR           PTK[64];
-	UCHAR           ReTryCounter;
-	RALINK_TIMER_STRUCT                 RetryTimer;
-	RALINK_TIMER_STRUCT					EnqueueStartForPSKTimer;	// A timer which enqueue EAPoL-Start for triggering PSK SM
-	NDIS_802_11_AUTHENTICATION_MODE     AuthMode;   // This should match to whatever microsoft defined
-	NDIS_802_11_WEP_STATUS              WepStatus;
-	NDIS_802_11_WEP_STATUS              GroupKeyWepStatus;
-	AP_WPA_STATE    WpaState;
-	GTK_STATE       GTKState;
-	USHORT          PortSecured;
-	NDIS_802_11_PRIVACY_FILTER  PrivacyFilter;      // PrivacyFilter enum for 802.1X
-	CIPHER_KEY      PairwiseKey;
-	PVOID           pAd;
-    INT				PMKID_CacheIdx;
-    UCHAR			PMKID[LEN_PMKID];
-
-
-	UCHAR           Addr[MAC_ADDR_LEN];
-	UCHAR           PsMode;
-	SST             Sst;
-	AUTH_STATE      AuthState; // for SHARED KEY authentication state machine used only
-	BOOLEAN			IsReassocSta;	// Indicate whether this is a reassociation procedure
-	USHORT          Aid;
-	USHORT          CapabilityInfo;
-	UCHAR           LastRssi;
-	ULONG           NoDataIdleCount;
-	UINT16			StationKeepAliveCount; // unit: second
-	ULONG           PsQIdleCount;
-	QUEUE_HEADER    PsQueue;
-
-	UINT32			StaConnectTime;		// the live time of this station since associated with AP
-
-	BOOLEAN			bSendBAR;
-	USHORT			NoBADataCountDown;
-
-	UINT32   		CachedBuf[16];		// UINT (4 bytes) for alignment
-	UINT			TxBFCount; // 3*3
-	UINT			FIFOCount;
-	UINT			DebugFIFOCount;
-	UINT			DebugTxCount;
-    BOOLEAN			bDlsInit;
-
+	UCHAR CMTimerRunning;
+	UCHAR apidx;		// MBSS number
+	UCHAR RSNIE_Len;
+	UCHAR RSN_IE[MAX_LEN_OF_RSNIE];
+	UCHAR ANonce[LEN_KEY_DESC_NONCE];
+	UCHAR SNonce[LEN_KEY_DESC_NONCE];
+	UCHAR R_Counter[LEN_KEY_DESC_REPLAY];
+	UCHAR PTK[64];
+	UCHAR ReTryCounter;
+	RALINK_TIMER_STRUCT RetryTimer;
+	RALINK_TIMER_STRUCT EnqueueStartForPSKTimer;	// A timer which enqueue EAPoL-Start for triggering PSK SM
+	NDIS_802_11_AUTHENTICATION_MODE AuthMode;	// This should match to whatever microsoft defined
+	NDIS_802_11_WEP_STATUS WepStatus;
+	NDIS_802_11_WEP_STATUS GroupKeyWepStatus;
+	AP_WPA_STATE WpaState;
+	GTK_STATE GTKState;
+	USHORT PortSecured;
+	NDIS_802_11_PRIVACY_FILTER PrivacyFilter;	// PrivacyFilter enum for 802.1X
+	CIPHER_KEY PairwiseKey;
+	PVOID pAd;
+	INT PMKID_CacheIdx;
+	UCHAR PMKID[LEN_PMKID];
+
+	UCHAR Addr[MAC_ADDR_LEN];
+	UCHAR PsMode;
+	SST Sst;
+	AUTH_STATE AuthState;	// for SHARED KEY authentication state machine used only
+	BOOLEAN IsReassocSta;	// Indicate whether this is a reassociation procedure
+	USHORT Aid;
+	USHORT CapabilityInfo;
+	UCHAR LastRssi;
+	ULONG NoDataIdleCount;
+	UINT16 StationKeepAliveCount;	// unit: second
+	ULONG PsQIdleCount;
+	QUEUE_HEADER PsQueue;
+
+	UINT32 StaConnectTime;	// the live time of this station since associated with AP
+
+	BOOLEAN bSendBAR;
+	USHORT NoBADataCountDown;
+
+	UINT32 CachedBuf[16];	// UINT (4 bytes) for alignment
+	UINT TxBFCount;		// 3*3
+	UINT FIFOCount;
+	UINT DebugFIFOCount;
+	UINT DebugTxCount;
+	BOOLEAN bDlsInit;
 
 //====================================================
 //WDS entry needs these
 // if ValidAsWDS==TRUE, MatchWDSTabIdx is the index in WdsTab.MacTab
-	UINT			MatchWDSTabIdx;
-	UCHAR           MaxSupportedRate;
-	UCHAR           CurrTxRate;
-	UCHAR           CurrTxRateIndex;
+	UINT MatchWDSTabIdx;
+	UCHAR MaxSupportedRate;
+	UCHAR CurrTxRate;
+	UCHAR CurrTxRateIndex;
 	// to record the each TX rate's quality. 0 is best, the bigger the worse.
-	USHORT          TxQuality[MAX_STEP_OF_TX_RATE_SWITCH];
-//	USHORT          OneSecTxOkCount;
-	UINT32			OneSecTxNoRetryOkCount;
-	UINT32          OneSecTxRetryOkCount;
-	UINT32          OneSecTxFailCount;
-	UINT32			ContinueTxFailCnt;
-	UINT32          CurrTxRateStableTime; // # of second in current TX rate
-	UCHAR           TxRateUpPenalty;      // extra # of second penalty due to last unstable condition
+	USHORT TxQuality[MAX_STEP_OF_TX_RATE_SWITCH];
+//      USHORT          OneSecTxOkCount;
+	UINT32 OneSecTxNoRetryOkCount;
+	UINT32 OneSecTxRetryOkCount;
+	UINT32 OneSecTxFailCount;
+	UINT32 ContinueTxFailCnt;
+	UINT32 CurrTxRateStableTime;	// # of second in current TX rate
+	UCHAR TxRateUpPenalty;	// extra # of second penalty due to last unstable condition
 //====================================================
 
-	BOOLEAN         fNoisyEnvironment;
-	BOOLEAN			fLastSecAccordingRSSI;
-	UCHAR           LastSecTxRateChangeAction; // 0: no change, 1:rate UP, 2:rate down
-	CHAR			LastTimeTxRateChangeAction; //Keep last time value of LastSecTxRateChangeAction
-	ULONG			LastTxOkCount;
-	UCHAR           PER[MAX_STEP_OF_TX_RATE_SWITCH];
+	BOOLEAN fNoisyEnvironment;
+	BOOLEAN fLastSecAccordingRSSI;
+	UCHAR LastSecTxRateChangeAction;	// 0: no change, 1:rate UP, 2:rate down
+	CHAR LastTimeTxRateChangeAction;	//Keep last time value of LastSecTxRateChangeAction
+	ULONG LastTxOkCount;
+	UCHAR PER[MAX_STEP_OF_TX_RATE_SWITCH];
 
 	// a bitmap of BOOLEAN flags. each bit represent an operation status of a particular
 	// BOOLEAN control, either ON or OFF. These flags should always be accessed via
 	// CLIENT_STATUS_TEST_FLAG(), CLIENT_STATUS_SET_FLAG(), CLIENT_STATUS_CLEAR_FLAG() macros.
 	// see fOP_STATUS_xxx in RTMP_DEF.C for detail bit definition. fCLIENT_STATUS_AMSDU_INUSED
-	ULONG           ClientStatusFlags;
+	ULONG ClientStatusFlags;
 
-	HTTRANSMIT_SETTING	HTPhyMode, MaxHTPhyMode, MinHTPhyMode;// For transmit phy setting in TXWI.
+	HTTRANSMIT_SETTING HTPhyMode, MaxHTPhyMode, MinHTPhyMode;	// For transmit phy setting in TXWI.
 
 	// HT EWC MIMO-N used parameters
-	USHORT		RXBAbitmap;	// fill to on-chip  RXWI_BA_BITMASK in 8.1.3RX attribute entry format
-	USHORT		TXBAbitmap;	// This bitmap as originator, only keep in software used to mark AMPDU bit in TXWI
-	USHORT		TXAutoBAbitmap;
-	USHORT		BADeclineBitmap;
-	USHORT		BARecWcidArray[NUM_OF_TID];	// The mapping wcid of recipient session. if RXBAbitmap bit is masked
-	USHORT		BAOriWcidArray[NUM_OF_TID]; // The mapping wcid of originator session. if TXBAbitmap bit is masked
-	USHORT		BAOriSequence[NUM_OF_TID]; // The mapping wcid of originator session. if TXBAbitmap bit is masked
+	USHORT RXBAbitmap;	// fill to on-chip  RXWI_BA_BITMASK in 8.1.3RX attribute entry format
+	USHORT TXBAbitmap;	// This bitmap as originator, only keep in software used to mark AMPDU bit in TXWI
+	USHORT TXAutoBAbitmap;
+	USHORT BADeclineBitmap;
+	USHORT BARecWcidArray[NUM_OF_TID];	// The mapping wcid of recipient session. if RXBAbitmap bit is masked
+	USHORT BAOriWcidArray[NUM_OF_TID];	// The mapping wcid of originator session. if TXBAbitmap bit is masked
+	USHORT BAOriSequence[NUM_OF_TID];	// The mapping wcid of originator session. if TXBAbitmap bit is masked
 
 	// 802.11n features.
-	UCHAR		MpduDensity;
-	UCHAR		MaxRAmpduFactor;
-	UCHAR		AMsduSize;
-	UCHAR		MmpsMode;	// MIMO power save more.
+	UCHAR MpduDensity;
+	UCHAR MaxRAmpduFactor;
+	UCHAR AMsduSize;
+	UCHAR MmpsMode;		// MIMO power save more.
 
-	HT_CAPABILITY_IE		HTCapability;
+	HT_CAPABILITY_IE HTCapability;
 
-	BOOLEAN		bAutoTxRateSwitch;
+	BOOLEAN bAutoTxRateSwitch;
 
-	UCHAR       RateLen;
+	UCHAR RateLen;
 	struct _MAC_TABLE_ENTRY *pNext;
-    USHORT      TxSeq[NUM_OF_TID];
-	USHORT		NonQosDataSeq;
+	USHORT TxSeq[NUM_OF_TID];
+	USHORT NonQosDataSeq;
 
-	RSSI_SAMPLE	RssiSample;
+	RSSI_SAMPLE RssiSample;
 
-	UINT32			TXMCSExpected[16];
-	UINT32			TXMCSSuccessful[16];
-	UINT32			TXMCSFailed[16];
-	UINT32			TXMCSAutoFallBack[16][16];
+	UINT32 TXMCSExpected[16];
+	UINT32 TXMCSSuccessful[16];
+	UINT32 TXMCSFailed[16];
+	UINT32 TXMCSAutoFallBack[16][16];
 
-	ULONG   		LastBeaconRxTime;
+	ULONG LastBeaconRxTime;
 
 	ULONG AssocDeadLine;
 } MAC_TABLE_ENTRY, *PMAC_TABLE_ENTRY;
 
 typedef struct _MAC_TABLE {
-	USHORT			Size;
+	USHORT Size;
 	MAC_TABLE_ENTRY *Hash[HASH_TABLE_SIZE];
 	MAC_TABLE_ENTRY Content[MAX_LEN_OF_MAC_TABLE];
-	QUEUE_HEADER    McastPsQueue;
-	ULONG           PsQIdleCount;
-	BOOLEAN         fAnyStationInPsm;
-	BOOLEAN         fAnyStationBadAtheros;	// Check if any Station is atheros 802.11n Chip.  We need to use RTS/CTS with Atheros 802,.11n chip.
-	BOOLEAN			fAnyTxOPForceDisable;	// Check if it is necessary to disable BE TxOP
-	BOOLEAN			fAllStationAsRalink; 	// Check if all stations are ralink-chipset
-	BOOLEAN         fAnyStationIsLegacy;	// Check if I use legacy rate to transmit to my BSS Station/
-	BOOLEAN         fAnyStationNonGF;		// Check if any Station can't support GF.
-	BOOLEAN         fAnyStation20Only;		// Check if any Station can't support GF.
-	BOOLEAN			fAnyStationMIMOPSDynamic; // Check if any Station is MIMO Dynamic
-	BOOLEAN         fAnyBASession;   // Check if there is BA session.  Force turn on RTS/CTS
+	QUEUE_HEADER McastPsQueue;
+	ULONG PsQIdleCount;
+	BOOLEAN fAnyStationInPsm;
+	BOOLEAN fAnyStationBadAtheros;	// Check if any Station is atheros 802.11n Chip.  We need to use RTS/CTS with Atheros 802,.11n chip.
+	BOOLEAN fAnyTxOPForceDisable;	// Check if it is necessary to disable BE TxOP
+	BOOLEAN fAllStationAsRalink;	// Check if all stations are ralink-chipset
+	BOOLEAN fAnyStationIsLegacy;	// Check if I use legacy rate to transmit to my BSS Station/
+	BOOLEAN fAnyStationNonGF;	// Check if any Station can't support GF.
+	BOOLEAN fAnyStation20Only;	// Check if any Station can't support GF.
+	BOOLEAN fAnyStationMIMOPSDynamic;	// Check if any Station is MIMO Dynamic
+	BOOLEAN fAnyBASession;	// Check if there is BA session.  Force turn on RTS/CTS
 //2008/10/28: KH add to support Antenna power-saving of AP<--
 //2008/10/28: KH add to support Antenna power-saving of AP-->
 } MAC_TABLE, *PMAC_TABLE;
 
-
-
-
-
-
-struct wificonf
-{
-	BOOLEAN	bShortGI;
+struct wificonf {
+	BOOLEAN bShortGI;
 	BOOLEAN bGreenField;
 };
 
+typedef struct _RTMP_DEV_INFO_ {
+	UCHAR chipName[16];
+	RTMP_INF_TYPE infType;
+} RTMP_DEV_INFO;
 
-typedef struct _RTMP_DEV_INFO_
-{
-	UCHAR			chipName[16];
-	RTMP_INF_TYPE	infType;
-}RTMP_DEV_INFO;
-
-
-
-
-struct _RTMP_CHIP_OP_
-{
+struct _RTMP_CHIP_OP_ {
 	/*  Calibration access related callback functions */
-	int (*eeinit)(RTMP_ADAPTER *pAd);										/* int (*eeinit)(RTMP_ADAPTER *pAd); */
-	int (*eeread)(RTMP_ADAPTER *pAd, USHORT offset, PUSHORT pValue);				/* int (*eeread)(RTMP_ADAPTER *pAd, int offset, PUSHORT pValue); */
+	int (*eeinit) (RTMP_ADAPTER * pAd);	/* int (*eeinit)(RTMP_ADAPTER *pAd); */
+	int (*eeread) (RTMP_ADAPTER * pAd, USHORT offset, PUSHORT pValue);	/* int (*eeread)(RTMP_ADAPTER *pAd, int offset, PUSHORT pValue); */
 
 	/* MCU related callback functions */
-	int (*loadFirmware)(RTMP_ADAPTER *pAd);								/* int (*loadFirmware)(RTMP_ADAPTER *pAd); */
-	int (*eraseFirmware)(RTMP_ADAPTER *pAd);								/* int (*eraseFirmware)(RTMP_ADAPTER *pAd); */
-	int (*sendCommandToMcu)(RTMP_ADAPTER *pAd, UCHAR cmd, UCHAR token, UCHAR arg0, UCHAR arg1);;	/* int (*sendCommandToMcu)(RTMP_ADAPTER *pAd, UCHAR cmd, UCHAR token, UCHAR arg0, UCHAR arg1); */
+	int (*loadFirmware) (RTMP_ADAPTER * pAd);	/* int (*loadFirmware)(RTMP_ADAPTER *pAd); */
+	int (*eraseFirmware) (RTMP_ADAPTER * pAd);	/* int (*eraseFirmware)(RTMP_ADAPTER *pAd); */
+	int (*sendCommandToMcu) (RTMP_ADAPTER * pAd, UCHAR cmd, UCHAR token, UCHAR arg0, UCHAR arg1);;	/* int (*sendCommandToMcu)(RTMP_ADAPTER *pAd, UCHAR cmd, UCHAR token, UCHAR arg0, UCHAR arg1); */
 
 	/* RF access related callback functions */
 	REG_PAIR *pRFRegTable;
-	void (*AsicRfInit)(RTMP_ADAPTER *pAd);
-	void (*AsicRfTurnOn)(RTMP_ADAPTER *pAd);
-	void (*AsicRfTurnOff)(RTMP_ADAPTER *pAd);
-	void (*AsicReverseRfFromSleepMode)(RTMP_ADAPTER *pAd);
-	void (*AsicHaltAction)(RTMP_ADAPTER *pAd);
+	void (*AsicRfInit) (RTMP_ADAPTER * pAd);
+	void (*AsicRfTurnOn) (RTMP_ADAPTER * pAd);
+	void (*AsicRfTurnOff) (RTMP_ADAPTER * pAd);
+	void (*AsicReverseRfFromSleepMode) (RTMP_ADAPTER * pAd);
+	void (*AsicHaltAction) (RTMP_ADAPTER * pAd);
 };
 
-
 //
 //  The miniport adapter structure
 //
-struct _RTMP_ADAPTER
-{
-	PVOID					OS_Cookie;	// save specific structure relative to OS
-	PNET_DEV				net_dev;
-	ULONG					VirtualIfCnt;
+struct _RTMP_ADAPTER {
+	PVOID OS_Cookie;	// save specific structure relative to OS
+	PNET_DEV net_dev;
+	ULONG VirtualIfCnt;
 
-	RTMP_CHIP_OP			chipOps;
-	USHORT					ThisTbttNumToNextWakeUp;
+	RTMP_CHIP_OP chipOps;
+	USHORT ThisTbttNumToNextWakeUp;
 
 #ifdef RTMP_MAC_PCI
 /*****************************************************************************************/
 /*      PCI related parameters																  */
 /*****************************************************************************************/
-	PUCHAR                  CSRBaseAddress;     // PCI MMIO Base Address, all access will use
-	unsigned int			irq_num;
-
-    USHORT		            LnkCtrlBitMask;
-    USHORT		            RLnkCtrlConfiguration;
-    USHORT                  RLnkCtrlOffset;
-    USHORT		            HostLnkCtrlConfiguration;
-    USHORT                  HostLnkCtrlOffset;
-	USHORT		            PCIePowerSaveLevel;
-	ULONG				Rt3xxHostLinkCtrl;	// USed for 3090F chip
-	ULONG				Rt3xxRalinkLinkCtrl;	// USed for 3090F chip
-	USHORT				DeviceID;           // Read from PCI config
-	ULONG				AccessBBPFailCount;
-   	BOOLEAN					bPCIclkOff;						// flag that indicate if the PICE power status in Configuration SPace..
-	BOOLEAN					bPCIclkOffDisableTx;			//
-
-	BOOLEAN					brt30xxBanMcuCmd;	//when = 0xff means all commands are ok to set .
-	BOOLEAN					b3090ESpecialChip;	//3090E special chip that write EEPROM 0x24=0x9280.
-	ULONG					CheckDmaBusyCount;  // Check Interrupt Status Register Count.
-
-	UINT					int_enable_reg;
-	UINT					int_disable_mask;
-	UINT					int_pending;
-
-
-	RTMP_DMABUF             TxBufSpace[NUM_OF_TX_RING]; // Shared memory of all 1st pre-allocated TxBuf associated with each TXD
-	RTMP_DMABUF             RxDescRing;                 // Shared memory for RX descriptors
-	RTMP_DMABUF             TxDescRing[NUM_OF_TX_RING]; 	// Shared memory for Tx descriptors
-	RTMP_TX_RING            TxRing[NUM_OF_TX_RING];     	// AC0~4 + HCCA
-#endif // RTMP_MAC_PCI //
+	PUCHAR CSRBaseAddress;	// PCI MMIO Base Address, all access will use
+	unsigned int irq_num;
 
+	USHORT LnkCtrlBitMask;
+	USHORT RLnkCtrlConfiguration;
+	USHORT RLnkCtrlOffset;
+	USHORT HostLnkCtrlConfiguration;
+	USHORT HostLnkCtrlOffset;
+	USHORT PCIePowerSaveLevel;
+	ULONG Rt3xxHostLinkCtrl;	// USed for 3090F chip
+	ULONG Rt3xxRalinkLinkCtrl;	// USed for 3090F chip
+	USHORT DeviceID;	// Read from PCI config
+	ULONG AccessBBPFailCount;
+	BOOLEAN bPCIclkOff;	// flag that indicate if the PICE power status in Configuration SPace..
+	BOOLEAN bPCIclkOffDisableTx;	//
+
+	BOOLEAN brt30xxBanMcuCmd;	//when = 0xff means all commands are ok to set .
+	BOOLEAN b3090ESpecialChip;	//3090E special chip that write EEPROM 0x24=0x9280.
+	ULONG CheckDmaBusyCount;	// Check Interrupt Status Register Count.
+
+	UINT int_enable_reg;
+	UINT int_disable_mask;
+	UINT int_pending;
+
+	RTMP_DMABUF TxBufSpace[NUM_OF_TX_RING];	// Shared memory of all 1st pre-allocated TxBuf associated with each TXD
+	RTMP_DMABUF RxDescRing;	// Shared memory for RX descriptors
+	RTMP_DMABUF TxDescRing[NUM_OF_TX_RING];	// Shared memory for Tx descriptors
+	RTMP_TX_RING TxRing[NUM_OF_TX_RING];	// AC0~4 + HCCA
+#endif				// RTMP_MAC_PCI //
 
-	NDIS_SPIN_LOCK          irq_lock;
-	UCHAR                   irq_disabled;
+	NDIS_SPIN_LOCK irq_lock;
+	UCHAR irq_disabled;
 
 #ifdef RTMP_MAC_USB
 /*****************************************************************************************/
 /*      USB related parameters                                                           */
 /*****************************************************************************************/
-	struct usb_config_descriptor		*config;
-	UINT								BulkInEpAddr;		// bulk-in endpoint address
-	UINT								BulkOutEpAddr[6];	// bulk-out endpoint address
-
-	UINT								NumberOfPipes;
-	USHORT								BulkOutMaxPacketSize;
-	USHORT								BulkInMaxPacketSize;
+	struct usb_config_descriptor *config;
+	UINT BulkInEpAddr;	// bulk-in endpoint address
+	UINT BulkOutEpAddr[6];	// bulk-out endpoint address
+
+	UINT NumberOfPipes;
+	USHORT BulkOutMaxPacketSize;
+	USHORT BulkInMaxPacketSize;
 
 	//======Control Flags
-	LONG                    	PendingIoCount;
-	ULONG						BulkFlags;
-	BOOLEAN                     bUsbTxBulkAggre;	// Flags for bulk out data priority
+	LONG PendingIoCount;
+	ULONG BulkFlags;
+	BOOLEAN bUsbTxBulkAggre;	// Flags for bulk out data priority
 
 	//======Cmd Thread
-	CmdQ					CmdQ;
-	NDIS_SPIN_LOCK			CmdQLock;				// CmdQLock spinlock
-	RTMP_OS_TASK			cmdQTask;
+	CmdQ CmdQ;
+	NDIS_SPIN_LOCK CmdQLock;	// CmdQLock spinlock
+	RTMP_OS_TASK cmdQTask;
 
 	//======Semaphores (event)
-	RTMP_OS_SEM			UsbVendorReq_semaphore;
-	PVOID					UsbVendorReqBuf;
-	wait_queue_head_t			*wait;
-#endif // RTMP_MAC_USB //
+	RTMP_OS_SEM UsbVendorReq_semaphore;
+	PVOID UsbVendorReqBuf;
+	wait_queue_head_t *wait;
+#endif				// RTMP_MAC_USB //
 
 /*****************************************************************************************/
 /*      RBUS related parameters																  */
 /*****************************************************************************************/
 
-
 /*****************************************************************************************/
 /*      Both PCI/USB related parameters														  */
 /*****************************************************************************************/
-	//RTMP_DEV_INFO			chipInfo;
-	RTMP_INF_TYPE			infType;
+	//RTMP_DEV_INFO                 chipInfo;
+	RTMP_INF_TYPE infType;
 
 /*****************************************************************************************/
 /*      Driver Mgmt related parameters														  */
 /*****************************************************************************************/
-	RTMP_OS_TASK			mlmeTask;
+	RTMP_OS_TASK mlmeTask;
 #ifdef RTMP_TIMER_TASK_SUPPORT
 	// If you want use timer task to handle the timer related jobs, enable this.
-	RTMP_TIMER_TASK_QUEUE	TimerQ;
-	NDIS_SPIN_LOCK			TimerQLock;
-	RTMP_OS_TASK			timerTask;
-#endif // RTMP_TIMER_TASK_SUPPORT //
-
+	RTMP_TIMER_TASK_QUEUE TimerQ;
+	NDIS_SPIN_LOCK TimerQLock;
+	RTMP_OS_TASK timerTask;
+#endif				// RTMP_TIMER_TASK_SUPPORT //
 
 /*****************************************************************************************/
 /*      Tx related parameters                                                           */
 /*****************************************************************************************/
-	BOOLEAN                 DeQueueRunning[NUM_OF_TX_RING];  // for ensuring RTUSBDeQueuePacket get call once
-	NDIS_SPIN_LOCK          DeQueueLock[NUM_OF_TX_RING];
+	BOOLEAN DeQueueRunning[NUM_OF_TX_RING];	// for ensuring RTUSBDeQueuePacket get call once
+	NDIS_SPIN_LOCK DeQueueLock[NUM_OF_TX_RING];
 
 #ifdef RTMP_MAC_USB
 	// Data related context and AC specified, 4 AC supported
-	NDIS_SPIN_LOCK			BulkOutLock[6];			// BulkOut spinlock for 4 ACs
-	NDIS_SPIN_LOCK			MLMEBulkOutLock;	// MLME BulkOut lock
+	NDIS_SPIN_LOCK BulkOutLock[6];	// BulkOut spinlock for 4 ACs
+	NDIS_SPIN_LOCK MLMEBulkOutLock;	// MLME BulkOut lock
 
-	HT_TX_CONTEXT			TxContext[NUM_OF_TX_RING];
-	NDIS_SPIN_LOCK			TxContextQueueLock[NUM_OF_TX_RING];		// TxContextQueue spinlock
+	HT_TX_CONTEXT TxContext[NUM_OF_TX_RING];
+	NDIS_SPIN_LOCK TxContextQueueLock[NUM_OF_TX_RING];	// TxContextQueue spinlock
 
 	// 4 sets of Bulk Out index and pending flag
-	UCHAR					NextBulkOutIndex[4];	// only used for 4 EDCA bulkout pipe
+	UCHAR NextBulkOutIndex[4];	// only used for 4 EDCA bulkout pipe
 
-	BOOLEAN					BulkOutPending[6];	// used for total 6 bulkout pipe
-	UCHAR					bulkResetPipeid;
-	BOOLEAN					MgmtBulkPending;
-	ULONG					bulkResetReq[6];
-#endif // RTMP_MAC_USB //
+	BOOLEAN BulkOutPending[6];	// used for total 6 bulkout pipe
+	UCHAR bulkResetPipeid;
+	BOOLEAN MgmtBulkPending;
+	ULONG bulkResetReq[6];
+#endif				// RTMP_MAC_USB //
 
 	// resource for software backlog queues
-	QUEUE_HEADER            TxSwQueue[NUM_OF_TX_RING];  // 4 AC + 1 HCCA
-	NDIS_SPIN_LOCK          TxSwQueueLock[NUM_OF_TX_RING];	// TxSwQueue spinlock
-
-	RTMP_DMABUF             MgmtDescRing;               	// Shared memory for MGMT descriptors
-	RTMP_MGMT_RING          MgmtRing;
-	NDIS_SPIN_LOCK          MgmtRingLock;               	// Prio Ring spinlock
+	QUEUE_HEADER TxSwQueue[NUM_OF_TX_RING];	// 4 AC + 1 HCCA
+	NDIS_SPIN_LOCK TxSwQueueLock[NUM_OF_TX_RING];	// TxSwQueue spinlock
 
+	RTMP_DMABUF MgmtDescRing;	// Shared memory for MGMT descriptors
+	RTMP_MGMT_RING MgmtRing;
+	NDIS_SPIN_LOCK MgmtRingLock;	// Prio Ring spinlock
 
 /*****************************************************************************************/
 /*      Rx related parameters                                                           */
 /*****************************************************************************************/
 
 #ifdef RTMP_MAC_PCI
-	RTMP_RX_RING            RxRing;
-	NDIS_SPIN_LOCK          RxRingLock;                 // Rx Ring spinlock
+	RTMP_RX_RING RxRing;
+	NDIS_SPIN_LOCK RxRingLock;	// Rx Ring spinlock
 #ifdef RT3090
-	NDIS_SPIN_LOCK          McuCmdLock;              //MCU Command Queue spinlock
-#endif // RT3090 //
-#endif // RTMP_MAC_PCI //
+	NDIS_SPIN_LOCK McuCmdLock;	//MCU Command Queue spinlock
+#endif				// RT3090 //
+#endif				// RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
-	RX_CONTEXT				RxContext[RX_RING_SIZE];  // 1 for redundant multiple IRP bulk in.
-	NDIS_SPIN_LOCK			BulkInLock;				// BulkIn spinlock for 4 ACs
-	UCHAR					PendingRx;				// The Maximum pending Rx value should be	RX_RING_SIZE.
-	UCHAR					NextRxBulkInIndex;		// Indicate the current RxContext Index which hold by Host controller.
-	UCHAR					NextRxBulkInReadIndex;	// Indicate the current RxContext Index which driver can read & process it.
-	ULONG					NextRxBulkInPosition;   // Want to contatenate 2 URB buffer while 1st is bulkin failed URB. This Position is 1st URB TransferLength.
-	ULONG					TransferBufferLength;	// current length of the packet buffer
-	ULONG					ReadPosition;			// current read position in a packet buffer
-#endif // RTMP_MAC_USB //
+	RX_CONTEXT RxContext[RX_RING_SIZE];	// 1 for redundant multiple IRP bulk in.
+	NDIS_SPIN_LOCK BulkInLock;	// BulkIn spinlock for 4 ACs
+	UCHAR PendingRx;	// The Maximum pending Rx value should be       RX_RING_SIZE.
+	UCHAR NextRxBulkInIndex;	// Indicate the current RxContext Index which hold by Host controller.
+	UCHAR NextRxBulkInReadIndex;	// Indicate the current RxContext Index which driver can read & process it.
+	ULONG NextRxBulkInPosition;	// Want to contatenate 2 URB buffer while 1st is bulkin failed URB. This Position is 1st URB TransferLength.
+	ULONG TransferBufferLength;	// current length of the packet buffer
+	ULONG ReadPosition;	// current read position in a packet buffer
+#endif				// RTMP_MAC_USB //
 
 /*****************************************************************************************/
 /*      ASIC related parameters                                                          */
 /*****************************************************************************************/
-	UINT32               	MACVersion;      	// MAC version. Record rt2860C(0x28600100) or rt2860D (0x28600101)..
+	UINT32 MACVersion;	// MAC version. Record rt2860C(0x28600100) or rt2860D (0x28600101)..
 
 	// ---------------------------
 	// E2PROM
 	// ---------------------------
-	ULONG                   EepromVersion;          // byte 0: version, byte 1: revision, byte 2~3: unused
-	ULONG				FirmwareVersion;        // byte 0: Minor version, byte 1: Major version, otherwise unused.
-	USHORT                  EEPROMDefaultValue[NUM_EEPROM_BBP_PARMS];
-	UCHAR				EEPROMAddressNum;       // 93c46=6  93c66=8
-	BOOLEAN                 EepromAccess;
-	UCHAR				EFuseTag;
-
+	ULONG EepromVersion;	// byte 0: version, byte 1: revision, byte 2~3: unused
+	ULONG FirmwareVersion;	// byte 0: Minor version, byte 1: Major version, otherwise unused.
+	USHORT EEPROMDefaultValue[NUM_EEPROM_BBP_PARMS];
+	UCHAR EEPROMAddressNum;	// 93c46=6  93c66=8
+	BOOLEAN EepromAccess;
+	UCHAR EFuseTag;
 
 	// ---------------------------
 	// BBP Control
 	// ---------------------------
-	UCHAR                   BbpWriteLatch[140];     // record last BBP register value written via BBP_IO_WRITE/BBP_IO_WRITE_VY_REG_ID
-	CHAR					BbpRssiToDbmDelta;		// change from UCHAR to CHAR for high power
-	BBP_R66_TUNING          BbpTuning;
+	UCHAR BbpWriteLatch[140];	// record last BBP register value written via BBP_IO_WRITE/BBP_IO_WRITE_VY_REG_ID
+	CHAR BbpRssiToDbmDelta;	// change from UCHAR to CHAR for high power
+	BBP_R66_TUNING BbpTuning;
 
 	// ----------------------------
 	// RFIC control
 	// ----------------------------
-	UCHAR                   RfIcType;       // RFIC_xxx
-	ULONG                   RfFreqOffset;   // Frequency offset for channel switching
-	RTMP_RF_REGS            LatchRfRegs;    // latch th latest RF programming value since RF IC doesn't support READ
+	UCHAR RfIcType;		// RFIC_xxx
+	ULONG RfFreqOffset;	// Frequency offset for channel switching
+	RTMP_RF_REGS LatchRfRegs;	// latch th latest RF programming value since RF IC doesn't support READ
 
-	EEPROM_ANTENNA_STRUC    Antenna;                            // Since ANtenna definition is different for a & g. We need to save it for future reference.
-	EEPROM_NIC_CONFIG2_STRUC    NicConfig2;
+	EEPROM_ANTENNA_STRUC Antenna;	// Since ANtenna definition is different for a & g. We need to save it for future reference.
+	EEPROM_NIC_CONFIG2_STRUC NicConfig2;
 
 	// This soft Rx Antenna Diversity mechanism is used only when user set
 	// RX Antenna = DIVERSITY ON
-	SOFT_RX_ANT_DIVERSITY   RxAnt;
+	SOFT_RX_ANT_DIVERSITY RxAnt;
 
-	UCHAR                   RFProgSeq;
-	CHANNEL_TX_POWER        TxPower[MAX_NUM_OF_CHANNELS];       // Store Tx power value for all channels.
-	CHANNEL_TX_POWER        ChannelList[MAX_NUM_OF_CHANNELS];   // list all supported channels for site survey
-	CHANNEL_11J_TX_POWER    TxPower11J[MAX_NUM_OF_11JCHANNELS];       // 802.11j channel and bw
-	CHANNEL_11J_TX_POWER    ChannelList11J[MAX_NUM_OF_11JCHANNELS];   // list all supported channels for site survey
-
-	UCHAR                   ChannelListNum;                     // number of channel in ChannelList[]
-	UCHAR					Bbp94;
-	BOOLEAN					BbpForCCK;
-	ULONG		Tx20MPwrCfgABand[5];
-	ULONG		Tx20MPwrCfgGBand[5];
-	ULONG		Tx40MPwrCfgABand[5];
-	ULONG		Tx40MPwrCfgGBand[5];
-
-	BOOLEAN     bAutoTxAgcA;                // Enable driver auto Tx Agc control
-	UCHAR	    TssiRefA;					// Store Tssi reference value as 25 temperature.
-	UCHAR	    TssiPlusBoundaryA[5];		// Tssi boundary for increase Tx power to compensate.
-	UCHAR	    TssiMinusBoundaryA[5];		// Tssi boundary for decrease Tx power to compensate.
-	UCHAR	    TxAgcStepA;					// Store Tx TSSI delta increment / decrement value
-	CHAR		TxAgcCompensateA;			// Store the compensation (TxAgcStep * (idx-1))
-
-	BOOLEAN     bAutoTxAgcG;                // Enable driver auto Tx Agc control
-	UCHAR	    TssiRefG;					// Store Tssi reference value as 25 temperature.
-	UCHAR	    TssiPlusBoundaryG[5];		// Tssi boundary for increase Tx power to compensate.
-	UCHAR	    TssiMinusBoundaryG[5];		// Tssi boundary for decrease Tx power to compensate.
-	UCHAR	    TxAgcStepG;					// Store Tx TSSI delta increment / decrement value
-	CHAR		TxAgcCompensateG;			// Store the compensation (TxAgcStep * (idx-1))
-
-	CHAR		BGRssiOffset0;				// Store B/G RSSI#0 Offset value on EEPROM 0x46h
-	CHAR		BGRssiOffset1;				// Store B/G RSSI#1 Offset value
-	CHAR		BGRssiOffset2;				// Store B/G RSSI#2 Offset value
-
-	CHAR		ARssiOffset0;				// Store A RSSI#0 Offset value on EEPROM 0x4Ah
-	CHAR		ARssiOffset1;				// Store A RSSI#1 Offset value
-	CHAR		ARssiOffset2;				// Store A RSSI#2 Offset value
-
-	CHAR		BLNAGain;					// Store B/G external LNA#0 value on EEPROM 0x44h
-	CHAR		ALNAGain0;					// Store A external LNA#0 value for ch36~64
-	CHAR		ALNAGain1;					// Store A external LNA#1 value for ch100~128
-	CHAR		ALNAGain2;					// Store A external LNA#2 value for ch132~165
+	UCHAR RFProgSeq;
+	CHANNEL_TX_POWER TxPower[MAX_NUM_OF_CHANNELS];	// Store Tx power value for all channels.
+	CHANNEL_TX_POWER ChannelList[MAX_NUM_OF_CHANNELS];	// list all supported channels for site survey
+	CHANNEL_11J_TX_POWER TxPower11J[MAX_NUM_OF_11JCHANNELS];	// 802.11j channel and bw
+	CHANNEL_11J_TX_POWER ChannelList11J[MAX_NUM_OF_11JCHANNELS];	// list all supported channels for site survey
+
+	UCHAR ChannelListNum;	// number of channel in ChannelList[]
+	UCHAR Bbp94;
+	BOOLEAN BbpForCCK;
+	ULONG Tx20MPwrCfgABand[5];
+	ULONG Tx20MPwrCfgGBand[5];
+	ULONG Tx40MPwrCfgABand[5];
+	ULONG Tx40MPwrCfgGBand[5];
+
+	BOOLEAN bAutoTxAgcA;	// Enable driver auto Tx Agc control
+	UCHAR TssiRefA;		// Store Tssi reference value as 25 temperature.
+	UCHAR TssiPlusBoundaryA[5];	// Tssi boundary for increase Tx power to compensate.
+	UCHAR TssiMinusBoundaryA[5];	// Tssi boundary for decrease Tx power to compensate.
+	UCHAR TxAgcStepA;	// Store Tx TSSI delta increment / decrement value
+	CHAR TxAgcCompensateA;	// Store the compensation (TxAgcStep * (idx-1))
+
+	BOOLEAN bAutoTxAgcG;	// Enable driver auto Tx Agc control
+	UCHAR TssiRefG;		// Store Tssi reference value as 25 temperature.
+	UCHAR TssiPlusBoundaryG[5];	// Tssi boundary for increase Tx power to compensate.
+	UCHAR TssiMinusBoundaryG[5];	// Tssi boundary for decrease Tx power to compensate.
+	UCHAR TxAgcStepG;	// Store Tx TSSI delta increment / decrement value
+	CHAR TxAgcCompensateG;	// Store the compensation (TxAgcStep * (idx-1))
+
+	CHAR BGRssiOffset0;	// Store B/G RSSI#0 Offset value on EEPROM 0x46h
+	CHAR BGRssiOffset1;	// Store B/G RSSI#1 Offset value
+	CHAR BGRssiOffset2;	// Store B/G RSSI#2 Offset value
+
+	CHAR ARssiOffset0;	// Store A RSSI#0 Offset value on EEPROM 0x4Ah
+	CHAR ARssiOffset1;	// Store A RSSI#1 Offset value
+	CHAR ARssiOffset2;	// Store A RSSI#2 Offset value
+
+	CHAR BLNAGain;		// Store B/G external LNA#0 value on EEPROM 0x44h
+	CHAR ALNAGain0;		// Store A external LNA#0 value for ch36~64
+	CHAR ALNAGain1;		// Store A external LNA#1 value for ch100~128
+	CHAR ALNAGain2;		// Store A external LNA#2 value for ch132~165
 #ifdef RT30xx
 	// for 3572
-	UCHAR		Bbp25;
-	UCHAR		Bbp26;
+	UCHAR Bbp25;
+	UCHAR Bbp26;
 
-	UCHAR		TxMixerGain24G;				// Tx mixer gain value from EEPROM to improve Tx EVM / Tx DAC, 2.4G
-	UCHAR		TxMixerGain5G;
-#endif // RT30xx //
+	UCHAR TxMixerGain24G;	// Tx mixer gain value from EEPROM to improve Tx EVM / Tx DAC, 2.4G
+	UCHAR TxMixerGain5G;
+#endif				// RT30xx //
 	// ----------------------------
 	// LED control
 	// ----------------------------
-	MCU_LEDCS_STRUC		LedCntl;
-	USHORT				Led1;	// read from EEPROM 0x3c
-	USHORT				Led2;	// EEPROM 0x3e
-	USHORT				Led3;	// EEPROM 0x40
-	UCHAR				LedIndicatorStrength;
-	UCHAR				RssiSingalstrengthOffet;
-    BOOLEAN				bLedOnScanning;
-	UCHAR				LedStatus;
+	MCU_LEDCS_STRUC LedCntl;
+	USHORT Led1;		// read from EEPROM 0x3c
+	USHORT Led2;		// EEPROM 0x3e
+	USHORT Led3;		// EEPROM 0x40
+	UCHAR LedIndicatorStrength;
+	UCHAR RssiSingalstrengthOffet;
+	BOOLEAN bLedOnScanning;
+	UCHAR LedStatus;
 
 /*****************************************************************************************/
 /*      802.11 related parameters                                                        */
 /*****************************************************************************************/
 	// outgoing BEACON frame buffer and corresponding TXD
-	TXWI_STRUC              	BeaconTxWI;
-	PUCHAR						BeaconBuf;
-	USHORT						BeaconOffset[HW_BEACON_MAX_COUNT];
+	TXWI_STRUC BeaconTxWI;
+	PUCHAR BeaconBuf;
+	USHORT BeaconOffset[HW_BEACON_MAX_COUNT];
 
 	// pre-build PS-POLL and NULL frame upon link up. for efficiency purpose.
-	PSPOLL_FRAME            	PsPollFrame;
-	HEADER_802_11           	NullFrame;
+	PSPOLL_FRAME PsPollFrame;
+	HEADER_802_11 NullFrame;
 
 #ifdef RTMP_MAC_USB
-	TX_CONTEXT				BeaconContext[BEACON_RING_SIZE];
-	TX_CONTEXT				NullContext;
-	TX_CONTEXT				PsPollContext;
-	TX_CONTEXT				RTSContext;
-#endif // RTMP_MAC_USB //
+	TX_CONTEXT BeaconContext[BEACON_RING_SIZE];
+	TX_CONTEXT NullContext;
+	TX_CONTEXT PsPollContext;
+	TX_CONTEXT RTSContext;
+#endif				// RTMP_MAC_USB //
 
 //=========AP===========
 
-
 //=======STA===========
 	// -----------------------------------------------
 	// STA specific configuration & operation status
 	// used only when pAd->OpMode == OPMODE_STA
 	// -----------------------------------------------
-	STA_ADMIN_CONFIG        StaCfg;           // user desired settings
-	STA_ACTIVE_CONFIG       StaActive;         // valid only when ADHOC_ON(pAd) || INFRA_ON(pAd)
-	CHAR                    nickname[IW_ESSID_MAX_SIZE+1]; // nickname, only used in the iwconfig i/f
-	NDIS_MEDIA_STATE        PreMediaState;
+	STA_ADMIN_CONFIG StaCfg;	// user desired settings
+	STA_ACTIVE_CONFIG StaActive;	// valid only when ADHOC_ON(pAd) || INFRA_ON(pAd)
+	CHAR nickname[IW_ESSID_MAX_SIZE + 1];	// nickname, only used in the iwconfig i/f
+	NDIS_MEDIA_STATE PreMediaState;
 
 //=======Common===========
 	// OP mode: either AP or STA
-	UCHAR                   OpMode;                     // OPMODE_STA, OPMODE_AP
-
-	NDIS_MEDIA_STATE        IndicateMediaState;			// Base on Indication state, default is NdisMediaStateDisConnected
+	UCHAR OpMode;		// OPMODE_STA, OPMODE_AP
 
+	NDIS_MEDIA_STATE IndicateMediaState;	// Base on Indication state, default is NdisMediaStateDisConnected
 
 	/* MAT related parameters */
 
 	// configuration: read from Registry & E2PROM
-	BOOLEAN                 bLocalAdminMAC;             // Use user changed MAC
-	UCHAR                   PermanentAddress[MAC_ADDR_LEN];    // Factory default MAC address
-	UCHAR                   CurrentAddress[MAC_ADDR_LEN];      // User changed MAC address
+	BOOLEAN bLocalAdminMAC;	// Use user changed MAC
+	UCHAR PermanentAddress[MAC_ADDR_LEN];	// Factory default MAC address
+	UCHAR CurrentAddress[MAC_ADDR_LEN];	// User changed MAC address
 
 	// ------------------------------------------------------
 	// common configuration to both OPMODE_STA and OPMODE_AP
 	// ------------------------------------------------------
-	COMMON_CONFIG           CommonCfg;
-	MLME_STRUCT             Mlme;
+	COMMON_CONFIG CommonCfg;
+	MLME_STRUCT Mlme;
 
 	// AP needs those vaiables for site survey feature.
-	MLME_AUX                MlmeAux;           // temporary settings used during MLME state machine
-	BSS_TABLE               ScanTab;           // store the latest SCAN result
+	MLME_AUX MlmeAux;	// temporary settings used during MLME state machine
+	BSS_TABLE ScanTab;	// store the latest SCAN result
 
 	//About MacTab, the sta driver will use #0 and #1 for multicast and AP.
-	MAC_TABLE                 MacTab;     // ASIC on-chip WCID entry table.  At TX, ASIC always use key according to this on-chip table.
-	NDIS_SPIN_LOCK          MacTabLock;
+	MAC_TABLE MacTab;	// ASIC on-chip WCID entry table.  At TX, ASIC always use key according to this on-chip table.
+	NDIS_SPIN_LOCK MacTabLock;
 
-	BA_TABLE			BATable;
+	BA_TABLE BATable;
 
-	NDIS_SPIN_LOCK          BATabLock;
+	NDIS_SPIN_LOCK BATabLock;
 	RALINK_TIMER_STRUCT RECBATimer;
 
 	// encryption/decryption KEY tables
-	CIPHER_KEY              SharedKey[MAX_MBSSID_NUM][4]; // STA always use SharedKey[BSS0][0..3]
+	CIPHER_KEY SharedKey[MAX_MBSSID_NUM][4];	// STA always use SharedKey[BSS0][0..3]
 
-		// RX re-assembly buffer for fragmentation
-	FRAGMENT_FRAME          FragFrame;                  // Frame storage for fragment frame
+	// RX re-assembly buffer for fragmentation
+	FRAGMENT_FRAME FragFrame;	// Frame storage for fragment frame
 
 	// various Counters
-	COUNTER_802_3           Counters8023;               // 802.3 counters
-	COUNTER_802_11          WlanCounters;               // 802.11 MIB counters
-	COUNTER_RALINK          RalinkCounters;             // Ralink propriety counters
-	COUNTER_DRS             DrsCounters;                // counters for Dynamic TX Rate Switching
-	PRIVATE_STRUC           PrivateInfo;                // Private information & counters
+	COUNTER_802_3 Counters8023;	// 802.3 counters
+	COUNTER_802_11 WlanCounters;	// 802.11 MIB counters
+	COUNTER_RALINK RalinkCounters;	// Ralink propriety counters
+	COUNTER_DRS DrsCounters;	// counters for Dynamic TX Rate Switching
+	PRIVATE_STRUC PrivateInfo;	// Private information & counters
 
 	// flags, see fRTMP_ADAPTER_xxx flags
-	ULONG                   Flags;                      // Represent current device status
-	ULONG                   PSFlags;                    // Power Save operation flag.
+	ULONG Flags;		// Represent current device status
+	ULONG PSFlags;		// Power Save operation flag.
 
 	// current TX sequence #
-	USHORT                  Sequence;
+	USHORT Sequence;
 
 	// Control disconnect / connect event generation
 	//+++Didn't used anymore
-	ULONG                   LinkDownTime;
+	ULONG LinkDownTime;
 	//---
-	ULONG                   LastRxRate;
-	ULONG                   LastTxRate;
+	ULONG LastRxRate;
+	ULONG LastTxRate;
 	//+++Used only for Station
-	BOOLEAN                 bConfigChanged;         // Config Change flag for the same SSID setting
+	BOOLEAN bConfigChanged;	// Config Change flag for the same SSID setting
 	//---
 
-	ULONG                   ExtraInfo;              // Extra information for displaying status
-	ULONG                   SystemErrorBitmap;      // b0: E2PROM version error
+	ULONG ExtraInfo;	// Extra information for displaying status
+	ULONG SystemErrorBitmap;	// b0: E2PROM version error
 
 	//+++Didn't used anymore
-	ULONG                   MacIcVersion;           // MAC/BBP serial interface issue solved after ver.D
+	ULONG MacIcVersion;	// MAC/BBP serial interface issue solved after ver.D
 	//---
 
 	// ---------------------------
 	// System event log
 	// ---------------------------
-	RT_802_11_EVENT_TABLE   EventTab;
-
+	RT_802_11_EVENT_TABLE EventTab;
 
-	BOOLEAN		HTCEnable;
+	BOOLEAN HTCEnable;
 
 	/*****************************************************************************************/
 	/*      Statistic related parameters                                                     */
 	/*****************************************************************************************/
 #ifdef RTMP_MAC_USB
-	ULONG						BulkOutDataOneSecCount;
-	ULONG						BulkInDataOneSecCount;
-	ULONG						BulkLastOneSecCount; // BulkOutDataOneSecCount + BulkInDataOneSecCount
-	ULONG						watchDogRxCnt;
-	ULONG						watchDogRxOverFlowCnt;
-	ULONG						watchDogTxPendingCnt[NUM_OF_TX_RING];
-	INT							TransferedLength[NUM_OF_TX_RING];
-#endif // RTMP_MAC_USB //
+	ULONG BulkOutDataOneSecCount;
+	ULONG BulkInDataOneSecCount;
+	ULONG BulkLastOneSecCount;	// BulkOutDataOneSecCount + BulkInDataOneSecCount
+	ULONG watchDogRxCnt;
+	ULONG watchDogRxOverFlowCnt;
+	ULONG watchDogTxPendingCnt[NUM_OF_TX_RING];
+	INT TransferedLength[NUM_OF_TX_RING];
+#endif				// RTMP_MAC_USB //
 
-	BOOLEAN						bUpdateBcnCntDone;
-	ULONG						watchDogMacDeadlock;	// prevent MAC/BBP into deadlock condition
+	BOOLEAN bUpdateBcnCntDone;
+	ULONG watchDogMacDeadlock;	// prevent MAC/BBP into deadlock condition
 	// ----------------------------
 	// DEBUG paramerts
 	// ----------------------------
-	//ULONG		DebugSetting[4];
-	BOOLEAN		bBanAllBaSetup;
-	BOOLEAN		bPromiscuous;
+	//ULONG         DebugSetting[4];
+	BOOLEAN bBanAllBaSetup;
+	BOOLEAN bPromiscuous;
 
 	// ----------------------------
 	// rt2860c emulation-use Parameters
 	// ----------------------------
-	//ULONG		rtsaccu[30];
-	//ULONG		ctsaccu[30];
-	//ULONG		cfendaccu[30];
-	//ULONG		bacontent[16];
-	//ULONG		rxint[RX_RING_SIZE+1];
-	//UCHAR		rcvba[60];
-	BOOLEAN		bLinkAdapt;
-	BOOLEAN		bForcePrintTX;
-	BOOLEAN		bForcePrintRX;
-	//BOOLEAN		bDisablescanning;		//defined in RT2870 USB
-	BOOLEAN		bStaFifoTest;
-	BOOLEAN		bProtectionTest;
-	BOOLEAN		bBroadComHT;
+	//ULONG         rtsaccu[30];
+	//ULONG         ctsaccu[30];
+	//ULONG         cfendaccu[30];
+	//ULONG         bacontent[16];
+	//ULONG         rxint[RX_RING_SIZE+1];
+	//UCHAR         rcvba[60];
+	BOOLEAN bLinkAdapt;
+	BOOLEAN bForcePrintTX;
+	BOOLEAN bForcePrintRX;
+	//BOOLEAN               bDisablescanning;               //defined in RT2870 USB
+	BOOLEAN bStaFifoTest;
+	BOOLEAN bProtectionTest;
+	BOOLEAN bBroadComHT;
 	//+++Following add from RT2870 USB.
-	ULONG		BulkOutReq;
-	ULONG		BulkOutComplete;
-	ULONG		BulkOutCompleteOther;
-	ULONG		BulkOutCompleteCancel;	// seems not use now?
-	ULONG		BulkInReq;
-	ULONG		BulkInComplete;
-	ULONG		BulkInCompleteFail;
+	ULONG BulkOutReq;
+	ULONG BulkOutComplete;
+	ULONG BulkOutCompleteOther;
+	ULONG BulkOutCompleteCancel;	// seems not use now?
+	ULONG BulkInReq;
+	ULONG BulkInComplete;
+	ULONG BulkInCompleteFail;
 	//---
 
-    struct wificonf			WIFItestbed;
+	struct wificonf WIFItestbed;
 
 	struct reordering_mpdu_pool mpdu_blk_pool;
 
-	ULONG					OneSecondnonBEpackets;		// record non BE packets per second
+	ULONG OneSecondnonBEpackets;	// record non BE packets per second
 
 #ifdef LINUX
-    struct iw_statistics    iw_stats;
-
-	struct net_device_stats	stats;
-#endif // LINUX //
-
-
-
+	struct iw_statistics iw_stats;
 
+	struct net_device_stats stats;
+#endif				// LINUX //
 
-	ULONG					TbttTickCount;
+	ULONG TbttTickCount;
 #ifdef PCI_MSI_SUPPORT
-	BOOLEAN					HaveMsi;
-#endif // PCI_MSI_SUPPORT //
+	BOOLEAN HaveMsi;
+#endif				// PCI_MSI_SUPPORT //
 
-
-	UCHAR					is_on;
+	UCHAR is_on;
 
 #define TIME_BASE			(1000000/OS_HZ)
 #define TIME_ONE_SECOND		(1000000/TIME_BASE)
-	UCHAR					flg_be_adjust;
-	ULONG					be_adjust_last_time;
-
-
-
+	UCHAR flg_be_adjust;
+	ULONG be_adjust_last_time;
 
-
-
-
-	UINT8					FlgCtsEnabled;
-	UINT8					PM_FlgSuspend;
+	UINT8 FlgCtsEnabled;
+	UINT8 PM_FlgSuspend;
 
 #ifdef RT30xx
 #ifdef RTMP_EFUSE_SUPPORT
-	BOOLEAN		bUseEfuse;
-	UCHAR		EEPROMImage[1024];
-#endif // RTMP_EFUSE_SUPPORT //
-#endif // RT30xx //
+	BOOLEAN bUseEfuse;
+	UCHAR EEPROMImage[1024];
+#endif				// RTMP_EFUSE_SUPPORT //
+#endif				// RT30xx //
 };
 
-
-
 #define DELAYINTMASK		0x0003fffb
 #define INTMASK				0x0003fffb
 #define IndMask				0x0003fffc
@@ -2262,34 +2157,30 @@ struct _RTMP_ADAPTER
 #define RxCoherent			0x00010000	// rx coherent
 #define McuCommand			0x00000200	// mcu
 #define PreTBTTInt			0x00001000	// Pre-TBTT interrupt
-#define TBTTInt				0x00000800		// TBTT interrupt
-#define GPTimeOutInt			0x00008000		// GPtimeout interrupt
-#define AutoWakeupInt		0x00004000		// AutoWakeupInt interrupt
+#define TBTTInt				0x00000800	// TBTT interrupt
+#define GPTimeOutInt			0x00008000	// GPtimeout interrupt
+#define AutoWakeupInt		0x00004000	// AutoWakeupInt interrupt
 #define FifoStaFullInt			0x00002000	//  fifo statistics full interrupt
 
-
 /***************************************************************************
   *	Rx Path software control block related data structures
   **************************************************************************/
-typedef struct _RX_BLK_
-{
-//	RXD_STRUC		RxD; // sample
-	RT28XX_RXD_STRUC	RxD;
-	PRXWI_STRUC			pRxWI;
-	PHEADER_802_11		pHeader;
-	PNDIS_PACKET		pRxPacket;
-	UCHAR				*pData;
-	USHORT				DataSize;
-	USHORT				Flags;
-	UCHAR				UserPriority;	// for calculate TKIP MIC using
+typedef struct _RX_BLK_ {
+//      RXD_STRUC               RxD; // sample
+	RT28XX_RXD_STRUC RxD;
+	PRXWI_STRUC pRxWI;
+	PHEADER_802_11 pHeader;
+	PNDIS_PACKET pRxPacket;
+	UCHAR *pData;
+	USHORT DataSize;
+	USHORT Flags;
+	UCHAR UserPriority;	// for calculate TKIP MIC using
 } RX_BLK;
 
-
 #define RX_BLK_SET_FLAG(_pRxBlk, _flag)		(_pRxBlk->Flags |= _flag)
 #define RX_BLK_TEST_FLAG(_pRxBlk, _flag)	(_pRxBlk->Flags & _flag)
 #define RX_BLK_CLEAR_FLAG(_pRxBlk, _flag)	(_pRxBlk->Flags &= ~(_flag))
 
-
 #define fRX_WDS			0x0001
 #define fRX_AMSDU       0x0002
 #define fRX_ARALINK     0x0004
@@ -2308,7 +2199,6 @@ typedef struct _RX_BLK_
 #define LENGTH_ARALINK_SUBFRAMEHEAD	14
 #define LENGTH_ARALINK_HEADER_FIELD	 2
 
-
 /***************************************************************************
   *	Tx Path software control block related data structures
   **************************************************************************/
@@ -2320,50 +2210,45 @@ typedef struct _RX_BLK_
 #define TX_RALINK_FRAME			0x10
 #define TX_FRAG_FRAME			0x20
 
-
-//	Currently the sizeof(TX_BLK) is 148 bytes.
-typedef struct _TX_BLK_
-{
-	UCHAR				QueIdx;
-	UCHAR				TxFrameType;				// Indicate the Transmission type of the all frames in one batch
-	UCHAR				TotalFrameNum;				// Total frame number want to send-out in one batch
-	USHORT				TotalFragNum;				// Total frame fragments required in one batch
-	USHORT				TotalFrameLen;				// Total length of all frames want to send-out in one batch
-
-	QUEUE_HEADER		TxPacketList;
-	MAC_TABLE_ENTRY		*pMacEntry;					// NULL: packet with 802.11 RA field is multicast/broadcast address
-	HTTRANSMIT_SETTING	*pTransmit;
+//      Currently the sizeof(TX_BLK) is 148 bytes.
+typedef struct _TX_BLK_ {
+	UCHAR QueIdx;
+	UCHAR TxFrameType;	// Indicate the Transmission type of the all frames in one batch
+	UCHAR TotalFrameNum;	// Total frame number want to send-out in one batch
+	USHORT TotalFragNum;	// Total frame fragments required in one batch
+	USHORT TotalFrameLen;	// Total length of all frames want to send-out in one batch
+
+	QUEUE_HEADER TxPacketList;
+	MAC_TABLE_ENTRY *pMacEntry;	// NULL: packet with 802.11 RA field is multicast/broadcast address
+	HTTRANSMIT_SETTING *pTransmit;
 
 	// Following structure used for the characteristics of a specific packet.
-	PNDIS_PACKET		pPacket;
-	PUCHAR				pSrcBufHeader;				// Reference to the head of sk_buff->data
-	PUCHAR				pSrcBufData;				// Reference to the sk_buff->data, will changed depends on hanlding progresss
-	UINT				SrcBufLen;					// Length of packet payload which not including Layer 2 header
-	PUCHAR				pExtraLlcSnapEncap;			// NULL means no extra LLC/SNAP is required
-	UCHAR				HeaderBuf[128];				// TempBuffer for TX_INFO + TX_WI + 802.11 Header + padding + AMSDU SubHeader + LLC/SNAP
+	PNDIS_PACKET pPacket;
+	PUCHAR pSrcBufHeader;	// Reference to the head of sk_buff->data
+	PUCHAR pSrcBufData;	// Reference to the sk_buff->data, will changed depends on hanlding progresss
+	UINT SrcBufLen;		// Length of packet payload which not including Layer 2 header
+	PUCHAR pExtraLlcSnapEncap;	// NULL means no extra LLC/SNAP is required
+	UCHAR HeaderBuf[128];	// TempBuffer for TX_INFO + TX_WI + 802.11 Header + padding + AMSDU SubHeader + LLC/SNAP
 	//RT2870 2.1.0.0 uses only 80 bytes
 	//RT3070 2.1.1.0 uses only 96 bytes
 	//RT3090 2.1.0.0 uses only 96 bytes
-	UCHAR				MpduHeaderLen;				// 802.11 header length NOT including the padding
-	UCHAR				HdrPadLen;					// recording Header Padding Length;
-	UCHAR				apidx;						// The interface associated to this packet
-	UCHAR				Wcid;						// The MAC entry associated to this packet
-	UCHAR				UserPriority;				// priority class of packet
-	UCHAR				FrameGap;					// what kind of IFS this packet use
-	UCHAR				MpduReqNum;					// number of fragments of this frame
-	UCHAR				TxRate;						// TODO: Obsoleted? Should change to MCS?
-	UCHAR				CipherAlg;					// cipher alogrithm
-	PCIPHER_KEY			pKey;
-
-
+	UCHAR MpduHeaderLen;	// 802.11 header length NOT including the padding
+	UCHAR HdrPadLen;	// recording Header Padding Length;
+	UCHAR apidx;		// The interface associated to this packet
+	UCHAR Wcid;		// The MAC entry associated to this packet
+	UCHAR UserPriority;	// priority class of packet
+	UCHAR FrameGap;		// what kind of IFS this packet use
+	UCHAR MpduReqNum;	// number of fragments of this frame
+	UCHAR TxRate;		// TODO: Obsoleted? Should change to MCS?
+	UCHAR CipherAlg;	// cipher alogrithm
+	PCIPHER_KEY pKey;
 
-	USHORT				Flags;						//See following definitions for detail.
+	USHORT Flags;		//See following definitions for detail.
 
 	//YOU SHOULD NOT TOUCH IT! Following parameters are used for hardware-depended layer.
-	ULONG				Priv;						// Hardware specific value saved in here.
+	ULONG Priv;		// Hardware specific value saved in here.
 } TX_BLK, *PTX_BLK;
 
-
 #define fTX_bRtsRequired		0x0001	// Indicate if need send RTS frame for protection. Not used in RT2860/RT2870.
 #define fTX_bAckRequired       	0x0002	// the packet need ack response
 #define fTX_bPiggyBack     		0x0004	// Legacy device use Piggback or not
@@ -2378,18 +2263,12 @@ typedef struct _TX_BLK_
 #define TX_BLK_TEST_FLAG(_pTxBlk, _flag)	(((_pTxBlk->Flags & _flag) == _flag) ? 1 : 0)
 #define TX_BLK_CLEAR_FLAG(_pTxBlk, _flag)	(_pTxBlk->Flags &= ~(_flag))
 
-
-
-
-
-
 /***************************************************************************
   *	Other static inline function definitions
   **************************************************************************/
-static inline VOID ConvertMulticastIP2MAC(
-	IN PUCHAR pIpAddr,
-	IN PUCHAR *ppMacAddr,
-	IN UINT16 ProtoType)
+static inline VOID ConvertMulticastIP2MAC(IN PUCHAR pIpAddr,
+					  IN PUCHAR * ppMacAddr,
+					  IN UINT16 ProtoType)
 {
 	if (pIpAddr == NULL)
 		return;
@@ -2397,2435 +2276,1588 @@ static inline VOID ConvertMulticastIP2MA
 	if (ppMacAddr == NULL || *ppMacAddr == NULL)
 		return;
 
-	switch (ProtoType)
-	{
-		case ETH_P_IPV6:
-//			memset(*ppMacAddr, 0, ETH_LENGTH_OF_ADDRESS);
-			*(*ppMacAddr) = 0x33;
-			*(*ppMacAddr + 1) = 0x33;
-			*(*ppMacAddr + 2) = pIpAddr[12];
-			*(*ppMacAddr + 3) = pIpAddr[13];
-			*(*ppMacAddr + 4) = pIpAddr[14];
-			*(*ppMacAddr + 5) = pIpAddr[15];
-			break;
-
-		case ETH_P_IP:
-		default:
-//			memset(*ppMacAddr, 0, ETH_LENGTH_OF_ADDRESS);
-			*(*ppMacAddr) = 0x01;
-			*(*ppMacAddr + 1) = 0x00;
-			*(*ppMacAddr + 2) = 0x5e;
-			*(*ppMacAddr + 3) = pIpAddr[1] & 0x7f;
-			*(*ppMacAddr + 4) = pIpAddr[2];
-			*(*ppMacAddr + 5) = pIpAddr[3];
-			break;
+	switch (ProtoType) {
+	case ETH_P_IPV6:
+//                      memset(*ppMacAddr, 0, ETH_LENGTH_OF_ADDRESS);
+		*(*ppMacAddr) = 0x33;
+		*(*ppMacAddr + 1) = 0x33;
+		*(*ppMacAddr + 2) = pIpAddr[12];
+		*(*ppMacAddr + 3) = pIpAddr[13];
+		*(*ppMacAddr + 4) = pIpAddr[14];
+		*(*ppMacAddr + 5) = pIpAddr[15];
+		break;
+
+	case ETH_P_IP:
+	default:
+//                      memset(*ppMacAddr, 0, ETH_LENGTH_OF_ADDRESS);
+		*(*ppMacAddr) = 0x01;
+		*(*ppMacAddr + 1) = 0x00;
+		*(*ppMacAddr + 2) = 0x5e;
+		*(*ppMacAddr + 3) = pIpAddr[1] & 0x7f;
+		*(*ppMacAddr + 4) = pIpAddr[2];
+		*(*ppMacAddr + 5) = pIpAddr[3];
+		break;
 	}
 
 	return;
 }
 
-
 char *GetPhyMode(int Mode);
-char* GetBW(int BW);
+char *GetBW(int BW);
 
 //
 //  Private routines in rtmp_init.c
 //
-NDIS_STATUS RTMPAllocAdapterBlock(
-	IN PVOID			handle,
-	OUT PRTMP_ADAPTER   *ppAdapter);
-
-NDIS_STATUS RTMPAllocTxRxRingMemory(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID RTMPFreeAdapter(
-	IN  PRTMP_ADAPTER   pAd);
-
-NDIS_STATUS NICReadRegParameters(
-	IN  PRTMP_ADAPTER       pAd,
-	IN  NDIS_HANDLE         WrapperConfigurationContext);
+NDIS_STATUS RTMPAllocAdapterBlock(IN PVOID handle,
+				  OUT PRTMP_ADAPTER * ppAdapter);
 
-#ifdef RTMP_RF_RW_SUPPORT
-VOID NICInitRFRegisters(
-	IN PRTMP_ADAPTER pAd);
+NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd);
 
-VOID RtmpChipOpsRFHook(
-	IN RTMP_ADAPTER *pAd);
+VOID RTMPFreeAdapter(IN PRTMP_ADAPTER pAd);
 
-NDIS_STATUS	RT30xxWriteRFRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			regID,
-	IN	UCHAR			value);
-
-NDIS_STATUS	RT30xxReadRFRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			regID,
-	IN	PUCHAR			pValue);
-#endif // RTMP_RF_RW_SUPPORT //
+NDIS_STATUS NICReadRegParameters(IN PRTMP_ADAPTER pAd,
+				 IN NDIS_HANDLE WrapperConfigurationContext);
 
-VOID NICReadEEPROMParameters(
-	IN  PRTMP_ADAPTER       pAd,
-	IN	PUCHAR				mac_addr);
+#ifdef RTMP_RF_RW_SUPPORT
+VOID NICInitRFRegisters(IN PRTMP_ADAPTER pAd);
 
-VOID NICInitAsicFromEEPROM(
-	IN  PRTMP_ADAPTER       pAd);
+VOID RtmpChipOpsRFHook(IN RTMP_ADAPTER * pAd);
 
+NDIS_STATUS RT30xxWriteRFRegister(IN PRTMP_ADAPTER pAd,
+				  IN UCHAR regID, IN UCHAR value);
 
-NDIS_STATUS NICInitializeAdapter(
-	IN  PRTMP_ADAPTER   pAd,
-	IN   BOOLEAN    bHardReset);
+NDIS_STATUS RT30xxReadRFRegister(IN PRTMP_ADAPTER pAd,
+				 IN UCHAR regID, IN PUCHAR pValue);
+#endif // RTMP_RF_RW_SUPPORT //
 
-NDIS_STATUS NICInitializeAsic(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  BOOLEAN		bHardReset);
+VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr);
 
-VOID NICIssueReset(
-	IN  PRTMP_ADAPTER   pAd);
+VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd);
 
-VOID RTMPRingCleanUp(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR           RingType);
+NDIS_STATUS NICInitializeAdapter(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset);
 
-VOID UserCfgInit(
-	IN  PRTMP_ADAPTER   pAd);
+NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset);
 
-VOID NICResetFromError(
-	IN  PRTMP_ADAPTER   pAd);
+VOID NICIssueReset(IN PRTMP_ADAPTER pAd);
 
-NDIS_STATUS NICLoadFirmware(
-	IN PRTMP_ADAPTER pAd);
+VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType);
 
-VOID NICEraseFirmware(
-	IN  PRTMP_ADAPTER   pAd);
+VOID UserCfgInit(IN PRTMP_ADAPTER pAd);
 
-NDIS_STATUS NICLoadRateSwitchingParams(
-	IN PRTMP_ADAPTER pAd);
+VOID NICResetFromError(IN PRTMP_ADAPTER pAd);
 
-BOOLEAN NICCheckForHang(
-	IN  PRTMP_ADAPTER   pAd);
+NDIS_STATUS NICLoadFirmware(IN PRTMP_ADAPTER pAd);
 
-VOID NICUpdateFifoStaCounters(
-	IN PRTMP_ADAPTER pAd);
+VOID NICEraseFirmware(IN PRTMP_ADAPTER pAd);
 
-VOID NICUpdateRawCounters(
-	IN  PRTMP_ADAPTER   pAd);
+NDIS_STATUS NICLoadRateSwitchingParams(IN PRTMP_ADAPTER pAd);
 
-VOID RTMPZeroMemory(
-	IN  PVOID   pSrc,
-	IN  ULONG   Length);
+BOOLEAN NICCheckForHang(IN PRTMP_ADAPTER pAd);
 
-ULONG RTMPCompareMemory(
-	IN  PVOID   pSrc1,
-	IN  PVOID   pSrc2,
-	IN  ULONG   Length);
+VOID NICUpdateFifoStaCounters(IN PRTMP_ADAPTER pAd);
 
-VOID RTMPMoveMemory(
-	OUT PVOID   pDest,
-	IN  PVOID   pSrc,
-	IN  ULONG   Length);
+VOID NICUpdateRawCounters(IN PRTMP_ADAPTER pAd);
 
-VOID AtoH(
-	PSTRING	src,
-	PUCHAR dest,
-	int		destlen);
+VOID RTMPZeroMemory(IN PVOID pSrc, IN ULONG Length);
 
-UCHAR BtoH(
-	char ch);
+ULONG RTMPCompareMemory(IN PVOID pSrc1, IN PVOID pSrc2, IN ULONG Length);
 
-VOID RTMPPatchMacBbpBug(
-	IN  PRTMP_ADAPTER   pAd);
+VOID RTMPMoveMemory(OUT PVOID pDest, IN PVOID pSrc, IN ULONG Length);
 
-VOID RTMPInitTimer(
-	IN  PRTMP_ADAPTER           pAd,
-	IN  PRALINK_TIMER_STRUCT    pTimer,
-	IN  PVOID                   pTimerFunc,
-	IN	PVOID					pData,
-	IN  BOOLEAN                 Repeat);
+VOID AtoH(PSTRING src, PUCHAR dest, int destlen);
 
-VOID RTMPSetTimer(
-	IN  PRALINK_TIMER_STRUCT    pTimer,
-	IN  ULONG                   Value);
+UCHAR BtoH(char ch);
 
+VOID RTMPPatchMacBbpBug(IN PRTMP_ADAPTER pAd);
 
-VOID RTMPModTimer(
-	IN	PRALINK_TIMER_STRUCT	pTimer,
-	IN	ULONG					Value);
+VOID RTMPInitTimer(IN PRTMP_ADAPTER pAd,
+		   IN PRALINK_TIMER_STRUCT pTimer,
+		   IN PVOID pTimerFunc, IN PVOID pData, IN BOOLEAN Repeat);
 
-VOID RTMPCancelTimer(
-	IN  PRALINK_TIMER_STRUCT    pTimer,
-	OUT BOOLEAN                 *pCancelled);
+VOID RTMPSetTimer(IN PRALINK_TIMER_STRUCT pTimer, IN ULONG Value);
 
-VOID RTMPSetLED(
-	IN PRTMP_ADAPTER 	pAd,
-	IN UCHAR			Status);
+VOID RTMPModTimer(IN PRALINK_TIMER_STRUCT pTimer, IN ULONG Value);
 
-VOID RTMPSetSignalLED(
-	IN PRTMP_ADAPTER 	pAd,
-	IN NDIS_802_11_RSSI Dbm);
+VOID RTMPCancelTimer(IN PRALINK_TIMER_STRUCT pTimer, OUT BOOLEAN * pCancelled);
 
-VOID RTMPEnableRxTx(
-	IN PRTMP_ADAPTER	pAd);
+VOID RTMPSetLED(IN PRTMP_ADAPTER pAd, IN UCHAR Status);
 
-//
-// prototype in action.c
-//
-VOID ActionStateMachineInit(
-    IN	PRTMP_ADAPTER	pAd,
-    IN  STATE_MACHINE *S,
-    OUT STATE_MACHINE_FUNC Trans[]);
-
-VOID MlmeADDBAAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-VOID MlmeDELBAAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-VOID MlmeDLSAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-VOID MlmeInvalidAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-VOID MlmeQOSAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerAddBAReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerAddBARspAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerDelBAAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerBAAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-VOID SendPSMPAction(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			Wcid,
-	IN UCHAR			Psmp);
-
-VOID PeerRMAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerPublicAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerHTAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerQOSAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
-
-VOID RECBATimerTimeout(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3);
-
-VOID ORIBATimerTimeout(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID SendRefreshBAR(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	MAC_TABLE_ENTRY	*pEntry);
-
-
-VOID ActHeaderInit(
-    IN	PRTMP_ADAPTER	pAd,
-    IN OUT PHEADER_802_11 pHdr80211,
-    IN PUCHAR Addr1,
-    IN PUCHAR Addr2,
-    IN PUCHAR Addr3);
-
-VOID BarHeaderInit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN OUT PFRAME_BAR pCntlBar,
-	IN PUCHAR pDA,
-	IN PUCHAR pSA);
-
-VOID InsertActField(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN UINT8 Category,
-	IN UINT8 ActCode);
-
-BOOLEAN CntlEnqueueForRecv(
-    IN	PRTMP_ADAPTER	pAd,
-	IN ULONG Wcid,
-    IN ULONG MsgLen,
-	IN PFRAME_BA_REQ pMsg);
+VOID RTMPSetSignalLED(IN PRTMP_ADAPTER pAd, IN NDIS_802_11_RSSI Dbm);
+
+VOID RTMPEnableRxTx(IN PRTMP_ADAPTER pAd);
 
 //
-// Private routines in rtmp_data.c
+// prototype in action.c
 //
-BOOLEAN RTMPHandleRxDoneInterrupt(
-	IN  PRTMP_ADAPTER   pAd);
+VOID ActionStateMachineInit(IN PRTMP_ADAPTER pAd,
+			    IN STATE_MACHINE * S,
+			    OUT STATE_MACHINE_FUNC Trans[]);
 
-BOOLEAN RTMPHandleTxRingDmaDoneInterrupt(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  INT_SOURCE_CSR_STRUC TxRingBitmap);
-
-VOID RTMPHandleMgmtRingDmaDoneInterrupt(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID RTMPHandleTBTTInterrupt(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID RTMPHandlePreTBTTInterrupt(
-	IN  PRTMP_ADAPTER   pAd);
-
-void RTMPHandleTwakeupInterrupt(
-	IN PRTMP_ADAPTER pAd);
-
-VOID	RTMPHandleRxCoherentInterrupt(
-	IN	PRTMP_ADAPTER	pAd);
-
-BOOLEAN TxFrameIsAggregatible(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pPrevAddr1,
-	IN  PUCHAR          p8023hdr);
-
-BOOLEAN PeerIsAggreOn(
-    IN  PRTMP_ADAPTER   pAd,
-    IN  ULONG          TxRate,
-    IN  PMAC_TABLE_ENTRY pMacEntry);
-
-
-NDIS_STATUS Sniff2BytesFromNdisBuffer(
-	IN  PNDIS_BUFFER    pFirstBuffer,
-	IN  UCHAR           DesiredOffset,
-	OUT PUCHAR          pByte0,
-	OUT PUCHAR          pByte1);
-
-NDIS_STATUS STASendPacket(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PNDIS_PACKET    pPacket);
-
-VOID STASendPackets(
-	IN  NDIS_HANDLE     MiniportAdapterContext,
-	IN  PPNDIS_PACKET   ppPacketArray,
-	IN  UINT            NumberOfPackets);
-
-VOID RTMPDeQueuePacket(
-	IN  PRTMP_ADAPTER   pAd,
-   	IN	BOOLEAN			bIntContext,
-	IN  UCHAR			QueIdx,
-	IN	UCHAR			Max_Tx_Packets);
-
-NDIS_STATUS	RTMPHardTransmit(
-	IN PRTMP_ADAPTER	pAd,
-	IN PNDIS_PACKET		pPacket,
-	IN  UCHAR			QueIdx,
-	OUT	PULONG			pFreeTXDLeft);
-
-NDIS_STATUS	STAHardTransmit(
-	IN PRTMP_ADAPTER	pAd,
-	IN TX_BLK			*pTxBlk,
-	IN  UCHAR			QueIdx);
-
-VOID STARxEAPOLFrameIndicate(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	MAC_TABLE_ENTRY	*pEntry,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID);
-
-NDIS_STATUS RTMPFreeTXDRequest(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR           RingType,
-	IN  UCHAR           NumberRequired,
-	IN 	PUCHAR          FreeNumberIs);
-
-NDIS_STATUS MlmeHardTransmit(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR	QueIdx,
-	IN  PNDIS_PACKET    pPacket);
-
-NDIS_STATUS MlmeHardTransmitMgmtRing(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR	QueIdx,
-	IN  PNDIS_PACKET    pPacket);
+VOID MlmeADDBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-#ifdef RTMP_MAC_PCI
-NDIS_STATUS MlmeHardTransmitTxRing(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR	QueIdx,
-	IN  PNDIS_PACKET    pPacket);
-
-NDIS_STATUS MlmeDataHardTransmit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR	QueIdx,
-	IN	PNDIS_PACKET	pPacket);
-
-VOID RTMPWriteTxDescriptor(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PTXD_STRUC		pTxD,
-	IN	BOOLEAN			bWIV,
-	IN	UCHAR			QSEL);
-#endif // RTMP_MAC_PCI //
+VOID MlmeDELBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-USHORT  RTMPCalcDuration(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR           Rate,
-	IN  ULONG           Size);
-
-VOID RTMPWriteTxWI(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PTXWI_STRUC		pTxWI,
-	IN  BOOLEAN    		FRAG,
-	IN  BOOLEAN    		CFACK,
-	IN  BOOLEAN    		InsTimestamp,
-	IN	BOOLEAN			AMPDU,
-	IN	BOOLEAN			Ack,
-	IN	BOOLEAN			NSeq,		// HW new a sequence.
-	IN	UCHAR			BASize,
-	IN	UCHAR			WCID,
-	IN	ULONG			Length,
-	IN  UCHAR      		PID,
-	IN	UCHAR			TID,
-	IN	UCHAR			TxRate,
-	IN	UCHAR			Txopmode,
-	IN	BOOLEAN			CfAck,
-	IN	HTTRANSMIT_SETTING	*pTransmit);
-
-
-VOID RTMPWriteTxWI_Data(
-	IN	PRTMP_ADAPTER		pAd,
-	IN	OUT PTXWI_STRUC		pTxWI,
-	IN	TX_BLK				*pTxBlk);
-
-
-VOID RTMPWriteTxWI_Cache(
-	IN	PRTMP_ADAPTER		pAd,
-	IN	OUT PTXWI_STRUC		pTxWI,
-	IN	TX_BLK				*pTxBlk);
-
-VOID RTMPSuspendMsduTransmission(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID RTMPResumeMsduTransmission(
-	IN  PRTMP_ADAPTER   pAd);
-
-NDIS_STATUS MiniportMMRequest(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	UCHAR			QueIdx,
-	IN	PUCHAR			pData,
-	IN  UINT            Length);
+VOID MlmeDLSAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-//+++mark by shiang, now this function merge to MiniportMMRequest()
-//---mark by shiang, now this function merge to MiniportMMRequest()
+VOID MlmeInvalidAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-VOID RTMPSendNullFrame(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR           TxRate,
-	IN	BOOLEAN			bQosNull);
-
-VOID RTMPSendDisassociationFrame(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID RTMPSendRTSFrame(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pDA,
-	IN	unsigned int	NextMpduSize,
-	IN  UCHAR           TxRate,
-	IN  UCHAR           RTSRate,
-	IN  USHORT          AckDuration,
-	IN  UCHAR           QueIdx,
-	IN  UCHAR			FrameGap);
-
-PQUEUE_HEADER   RTMPCheckTxSwQueue(
-	IN  PRTMP_ADAPTER   pAd,
-	OUT UCHAR           *QueIdx);
-
-VOID RTMPReportMicError(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PCIPHER_KEY     pWpaKey);
-
-VOID	WpaMicFailureReportFrame(
-	IN  PRTMP_ADAPTER    pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID    WpaDisassocApAndBlockAssoc(
-    IN  PVOID SystemSpecific1,
-    IN  PVOID FunctionContext,
-    IN  PVOID SystemSpecific2,
-    IN  PVOID SystemSpecific3);
-
-VOID WpaStaPairwiseKeySetting(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID WpaStaGroupKeySetting(
-	IN	PRTMP_ADAPTER	pAd);
-
-NDIS_STATUS RTMPCloneNdisPacket(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	BOOLEAN    pInsAMSDUHdr,
-	IN  PNDIS_PACKET    pInPacket,
-	OUT PNDIS_PACKET   *ppOutPacket);
-
-NDIS_STATUS RTMPAllocateNdisPacket(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PNDIS_PACKET    *pPacket,
-	IN  PUCHAR          pHeader,
-	IN  UINT            HeaderLen,
-	IN  PUCHAR          pData,
-	IN  UINT            DataLen);
-
-VOID RTMPFreeNdisPacket(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PNDIS_PACKET    pPacket);
-
-BOOLEAN RTMPFreeTXDUponTxDmaDone(
-	IN PRTMP_ADAPTER    pAd,
-	IN UCHAR            QueIdx);
-
-BOOLEAN RTMPCheckDHCPFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket);
-
-
-BOOLEAN RTMPCheckEtherType(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket);
+VOID MlmeQOSAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
+VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-//
-// Private routines in rtmp_wep.c
-//
-VOID RTMPInitWepEngine(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pKey,
-	IN  UCHAR           KeyId,
-	IN  UCHAR           KeyLen,
-	IN  PUCHAR          pDest);
-
-VOID RTMPEncryptData(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pSrc,
-	IN  PUCHAR          pDest,
-	IN  UINT            Len);
-
-BOOLEAN	RTMPSoftDecryptWEP(
-	IN PRTMP_ADAPTER 	pAd,
-	IN PUCHAR			pData,
-	IN ULONG			DataByteCnt,
-	IN PCIPHER_KEY		pGroupKey);
-
-VOID RTMPSetICV(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pDest);
-
-VOID ARCFOUR_INIT(
-	IN  PARCFOURCONTEXT Ctx,
-	IN  PUCHAR          pKey,
-	IN  UINT            KeyLen);
-
-UCHAR   ARCFOUR_BYTE(
-	IN  PARCFOURCONTEXT     Ctx);
-
-VOID ARCFOUR_DECRYPT(
-	IN  PARCFOURCONTEXT Ctx,
-	IN  PUCHAR          pDest,
-	IN  PUCHAR          pSrc,
-	IN  UINT            Len);
-
-VOID ARCFOUR_ENCRYPT(
-	IN  PARCFOURCONTEXT Ctx,
-	IN  PUCHAR          pDest,
-	IN  PUCHAR          pSrc,
-	IN  UINT            Len);
-
-VOID WPAARCFOUR_ENCRYPT(
-	IN  PARCFOURCONTEXT Ctx,
-	IN  PUCHAR          pDest,
-	IN  PUCHAR          pSrc,
-	IN  UINT            Len);
-
-UINT RTMP_CALC_FCS32(
-	IN  UINT   Fcs,
-	IN  PUCHAR  Cp,
-	IN  INT     Len);
+VOID PeerAddBARspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-//
-// MLME routines
-//
+VOID PeerDelBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-// Asic/RF/BBP related functions
+VOID PeerBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-VOID AsicAdjustTxPower(
-	IN PRTMP_ADAPTER pAd);
+VOID SendPSMPAction(IN PRTMP_ADAPTER pAd, IN UCHAR Wcid, IN UCHAR Psmp);
 
-VOID 	AsicUpdateProtect(
-	IN		PRTMP_ADAPTER	pAd,
-	IN 		USHORT			OperaionMode,
-	IN 		UCHAR			SetMask,
-	IN		BOOLEAN			bDisableBGProtect,
-	IN		BOOLEAN			bNonGFExist);
-
-VOID AsicSwitchChannel(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	UCHAR			Channel,
-	IN	BOOLEAN			bScan);
-
-VOID AsicLockChannel(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR Channel) ;
-
-VOID AsicRfTuningExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID AsicResetBBPAgent(
-	IN PRTMP_ADAPTER pAd);
-
-VOID AsicSleepThenAutoWakeup(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  USHORT TbttNumToNextWakeUp);
-
-VOID AsicForceSleep(
-	IN PRTMP_ADAPTER pAd);
-
-VOID AsicForceWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN BOOLEAN    bFromTx);
-
-VOID AsicSetBssid(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR pBssid);
-
-VOID AsicSetMcastWC(
-	IN PRTMP_ADAPTER pAd);
-
-VOID AsicDelWcidTab(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR	Wcid);
-
-VOID AsicEnableRDG(
-	IN PRTMP_ADAPTER pAd);
-
-VOID AsicDisableRDG(
-	IN PRTMP_ADAPTER pAd);
-
-VOID AsicDisableSync(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID AsicEnableBssSync(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID AsicEnableIbssSync(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID AsicSetEdcaParm(
-	IN PRTMP_ADAPTER pAd,
-	IN PEDCA_PARM    pEdcaParm);
-
-VOID AsicSetSlotTime(
-	IN PRTMP_ADAPTER pAd,
-	IN BOOLEAN bUseShortSlotTime);
-
-VOID AsicAddSharedKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR         BssIndex,
-	IN UCHAR         KeyIdx,
-	IN UCHAR         CipherAlg,
-	IN PUCHAR        pKey,
-	IN PUCHAR        pTxMic,
-	IN PUCHAR        pRxMic);
-
-VOID AsicRemoveSharedKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR         BssIndex,
-	IN UCHAR         KeyIdx);
-
-VOID AsicUpdateWCIDAttribute(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT		WCID,
-	IN UCHAR		BssIndex,
-	IN UCHAR        CipherAlg,
-	IN BOOLEAN		bUsePairewiseKeyTable);
-
-VOID AsicUpdateWCIDIVEIV(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT		WCID,
-	IN ULONG        uIV,
-	IN ULONG        uEIV);
-
-VOID AsicUpdateRxWCIDTable(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT		WCID,
-	IN PUCHAR        pAddr);
-
-VOID AsicAddKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT		WCID,
-	IN UCHAR		BssIndex,
-	IN UCHAR		KeyIdx,
-	IN PCIPHER_KEY	pCipherKey,
-	IN BOOLEAN		bUsePairewiseKeyTable,
-	IN BOOLEAN		bTxKey);
-
-VOID AsicAddPairwiseKeyEntry(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR        pAddr,
-	IN UCHAR		WCID,
-	IN CIPHER_KEY		 *pCipherKey);
-
-VOID AsicRemovePairwiseKeyEntry(
-	IN PRTMP_ADAPTER  pAd,
-	IN UCHAR		 BssIdx,
-	IN UCHAR		 Wcid);
-
-BOOLEAN AsicSendCommandToMcu(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR         Command,
-	IN UCHAR         Token,
-	IN UCHAR         Arg0,
-	IN UCHAR         Arg1);
+VOID PeerRMAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
+VOID PeerPublicAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-#ifdef RTMP_MAC_PCI
-BOOLEAN AsicCheckCommanOk(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 Command);
-#endif // RTMP_MAC_PCI //
+VOID PeerHTAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-VOID MacAddrRandomBssid(
-	IN  PRTMP_ADAPTER   pAd,
-	OUT PUCHAR pAddr);
-
-VOID MgtMacHeaderInit(
-	IN  PRTMP_ADAPTER     pAd,
-	IN OUT PHEADER_802_11 pHdr80211,
-	IN UCHAR SubType,
-	IN UCHAR ToDs,
-	IN PUCHAR pDA,
-	IN PUCHAR pBssid);
-
-VOID MlmeRadioOff(
-	IN PRTMP_ADAPTER pAd);
-
-VOID MlmeRadioOn(
-	IN PRTMP_ADAPTER pAd);
-
-
-VOID BssTableInit(
-	IN BSS_TABLE *Tab);
-
-VOID BATableInit(
-	IN PRTMP_ADAPTER pAd,
-    IN BA_TABLE *Tab);
-
-ULONG BssTableSearch(
-	IN BSS_TABLE *Tab,
-	IN PUCHAR pBssid,
-	IN UCHAR Channel);
-
-ULONG BssSsidTableSearch(
-	IN BSS_TABLE *Tab,
-	IN PUCHAR    pBssid,
-	IN PUCHAR    pSsid,
-	IN UCHAR     SsidLen,
-	IN UCHAR     Channel);
-
-ULONG BssTableSearchWithSSID(
-	IN BSS_TABLE *Tab,
-	IN PUCHAR    Bssid,
-	IN PUCHAR    pSsid,
-	IN UCHAR     SsidLen,
-	IN UCHAR     Channel);
-
-ULONG BssSsidTableSearchBySSID(
-	IN BSS_TABLE *Tab,
-	IN PUCHAR	 pSsid,
-	IN UCHAR	 SsidLen);
-
-VOID BssTableDeleteEntry(
-	IN OUT  PBSS_TABLE pTab,
-	IN      PUCHAR pBssid,
-	IN      UCHAR Channel);
-
-VOID BATableDeleteORIEntry(
-	IN OUT	PRTMP_ADAPTER pAd,
-	IN		BA_ORI_ENTRY	*pBAORIEntry);
-
-VOID  BssEntrySet(
-	IN  PRTMP_ADAPTER   pAd,
-	OUT PBSS_ENTRY pBss,
-	IN PUCHAR pBssid,
-	IN CHAR Ssid[],
-	IN UCHAR SsidLen,
-	IN UCHAR BssType,
-	IN USHORT BeaconPeriod,
-	IN PCF_PARM CfParm,
-	IN USHORT AtimWin,
-	IN USHORT CapabilityInfo,
-	IN UCHAR SupRate[],
-	IN UCHAR SupRateLen,
-	IN UCHAR ExtRate[],
-	IN UCHAR ExtRateLen,
-	IN HT_CAPABILITY_IE *pHtCapability,
-	IN ADD_HT_INFO_IE *pAddHtInfo,	// AP might use this additional ht info IE
-	IN UCHAR			HtCapabilityLen,
-	IN UCHAR			AddHtInfoLen,
-	IN UCHAR			NewExtChanOffset,
-	IN UCHAR Channel,
-	IN CHAR Rssi,
-	IN LARGE_INTEGER TimeStamp,
-	IN UCHAR CkipFlag,
-	IN PEDCA_PARM pEdcaParm,
-	IN PQOS_CAPABILITY_PARM pQosCapability,
-	IN PQBSS_LOAD_PARM pQbssLoad,
-	IN USHORT LengthVIE,
-	IN PNDIS_802_11_VARIABLE_IEs pVIE);
-
-ULONG  BssTableSetEntry(
-	IN  PRTMP_ADAPTER   pAd,
-	OUT PBSS_TABLE pTab,
-	IN PUCHAR pBssid,
-	IN CHAR Ssid[],
-	IN UCHAR SsidLen,
-	IN UCHAR BssType,
-	IN USHORT BeaconPeriod,
-	IN CF_PARM *CfParm,
-	IN USHORT AtimWin,
-	IN USHORT CapabilityInfo,
-	IN UCHAR SupRate[],
-	IN UCHAR SupRateLen,
-	IN UCHAR ExtRate[],
-	IN UCHAR ExtRateLen,
-	IN HT_CAPABILITY_IE *pHtCapability,
-	IN ADD_HT_INFO_IE *pAddHtInfo,	// AP might use this additional ht info IE
-	IN UCHAR			HtCapabilityLen,
-	IN UCHAR			AddHtInfoLen,
-	IN UCHAR			NewExtChanOffset,
-	IN UCHAR Channel,
-	IN CHAR Rssi,
-	IN LARGE_INTEGER TimeStamp,
-	IN UCHAR CkipFlag,
-	IN PEDCA_PARM pEdcaParm,
-	IN PQOS_CAPABILITY_PARM pQosCapability,
-	IN PQBSS_LOAD_PARM pQbssLoad,
-	IN USHORT LengthVIE,
-	IN PNDIS_802_11_VARIABLE_IEs pVIE);
-
-VOID BATableInsertEntry(
-    IN	PRTMP_ADAPTER	pAd,
-	IN USHORT Aid,
-    IN USHORT		TimeOutValue,
-	IN USHORT		StartingSeq,
-    IN UCHAR TID,
-	IN UCHAR BAWinSize,
-	IN UCHAR OriginatorStatus,
-    IN BOOLEAN IsRecipient);
-
-VOID BssTableSsidSort(
-	IN  PRTMP_ADAPTER   pAd,
-	OUT BSS_TABLE *OutTab,
-	IN  CHAR Ssid[],
-	IN  UCHAR SsidLen);
-
-VOID  BssTableSortByRssi(
-	IN OUT BSS_TABLE *OutTab);
-
-VOID BssCipherParse(
-	IN OUT  PBSS_ENTRY  pBss);
-
-NDIS_STATUS  MlmeQueueInit(
-	IN MLME_QUEUE *Queue);
-
-VOID  MlmeQueueDestroy(
-	IN MLME_QUEUE *Queue);
-
-BOOLEAN MlmeEnqueue(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG Machine,
-	IN ULONG MsgType,
-	IN ULONG MsgLen,
-	IN VOID *Msg);
-
-BOOLEAN MlmeEnqueueForRecv(
-	IN  PRTMP_ADAPTER   pAd,
-	IN ULONG Wcid,
-	IN ULONG TimeStampHigh,
-	IN ULONG TimeStampLow,
-	IN UCHAR Rssi0,
-	IN UCHAR Rssi1,
-	IN UCHAR Rssi2,
-	IN ULONG MsgLen,
-	IN PVOID Msg,
-	IN UCHAR Signal);
-
-
-BOOLEAN MlmeDequeue(
-	IN MLME_QUEUE *Queue,
-	OUT MLME_QUEUE_ELEM **Elem);
-
-VOID    MlmeRestartStateMachine(
-	IN  PRTMP_ADAPTER   pAd);
-
-BOOLEAN  MlmeQueueEmpty(
-	IN MLME_QUEUE *Queue);
-
-BOOLEAN  MlmeQueueFull(
-	IN MLME_QUEUE *Queue);
-
-BOOLEAN  MsgTypeSubst(
-	IN PRTMP_ADAPTER pAd,
-	IN PFRAME_802_11 pFrame,
-	OUT INT *Machine,
-	OUT INT *MsgType);
-
-VOID StateMachineInit(
-	IN STATE_MACHINE *Sm,
-	IN STATE_MACHINE_FUNC Trans[],
-	IN ULONG StNr,
-	IN ULONG MsgNr,
-	IN STATE_MACHINE_FUNC DefFunc,
-	IN ULONG InitState,
-	IN ULONG Base);
-
-VOID StateMachineSetAction(
-	IN STATE_MACHINE *S,
-	IN ULONG St,
-	ULONG Msg,
-	IN STATE_MACHINE_FUNC F);
-
-VOID StateMachinePerformAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN STATE_MACHINE *S,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID Drop(
-	IN  PRTMP_ADAPTER   pAd,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID AssocStateMachineInit(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  STATE_MACHINE *Sm,
-	OUT STATE_MACHINE_FUNC Trans[]);
-
-VOID ReassocTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID AssocTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID DisassocTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
+VOID PeerQOSAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
-//----------------------------------------------
-VOID MlmeAssocReqAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID MlmeReassocReqAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID MlmeDisassocReqAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerAssocRspAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerReassocRspAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerDisassocAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID DisassocTimeoutAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID AssocTimeoutAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID  ReassocTimeoutAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID  Cls3errAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR pAddr);
-
-VOID  InvalidStateWhenAssoc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID  InvalidStateWhenReassoc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID InvalidStateWhenDisassociate(
-	IN  PRTMP_ADAPTER pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
+VOID RECBATimerTimeout(IN PVOID SystemSpecific1,
+		       IN PVOID FunctionContext,
+		       IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
 
-#ifdef RTMP_MAC_USB
-VOID MlmeCntlConfirm(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG MsgType,
-	IN USHORT Msg);
-#endif // RTMP_MAC_USB //
+VOID ORIBATimerTimeout(IN PRTMP_ADAPTER pAd);
 
-VOID  ComposePsPoll(
-	IN  PRTMP_ADAPTER   pAd);
+VOID SendRefreshBAR(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry);
 
-VOID  ComposeNullFrame(
-	IN  PRTMP_ADAPTER pAd);
+VOID ActHeaderInit(IN PRTMP_ADAPTER pAd,
+		   IN OUT PHEADER_802_11 pHdr80211,
+		   IN PUCHAR Addr1, IN PUCHAR Addr2, IN PUCHAR Addr3);
 
-VOID  AssocPostProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR pAddr2,
-	IN  USHORT CapabilityInfo,
-	IN  USHORT Aid,
-	IN  UCHAR SupRate[],
-	IN  UCHAR SupRateLen,
-	IN  UCHAR ExtRate[],
-	IN  UCHAR ExtRateLen,
-	IN PEDCA_PARM pEdcaParm,
-	IN HT_CAPABILITY_IE		*pHtCapability,
-	IN  UCHAR HtCapabilityLen,
-	IN ADD_HT_INFO_IE		*pAddHtInfo);
-
-VOID AuthStateMachineInit(
-	IN  PRTMP_ADAPTER   pAd,
-	IN PSTATE_MACHINE sm,
-	OUT STATE_MACHINE_FUNC Trans[]);
-
-VOID AuthTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID MlmeAuthReqAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerAuthRspAtSeq2Action(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerAuthRspAtSeq4Action(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID AuthTimeoutAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID Cls2errAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR pAddr);
-
-VOID MlmeDeauthReqAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID InvalidStateWhenAuth(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
+VOID BarHeaderInit(IN PRTMP_ADAPTER pAd,
+		   IN OUT PFRAME_BAR pCntlBar, IN PUCHAR pDA, IN PUCHAR pSA);
 
-//=============================================
+VOID InsertActField(IN PRTMP_ADAPTER pAd,
+		    OUT PUCHAR pFrameBuf,
+		    OUT PULONG pFrameLen, IN UINT8 Category, IN UINT8 ActCode);
 
-VOID AuthRspStateMachineInit(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PSTATE_MACHINE Sm,
-	IN  STATE_MACHINE_FUNC Trans[]);
-
-VOID PeerDeauthAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerAuthSimpleRspGenAndSend(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PHEADER_802_11  pHdr80211,
-	IN  USHORT Alg,
-	IN  USHORT Seq,
-	IN  USHORT Reason,
-	IN  USHORT Status);
+BOOLEAN CntlEnqueueForRecv(IN PRTMP_ADAPTER pAd,
+			   IN ULONG Wcid,
+			   IN ULONG MsgLen, IN PFRAME_BA_REQ pMsg);
 
 //
-// Private routines in dls.c
+// Private routines in rtmp_data.c
 //
+BOOLEAN RTMPHandleRxDoneInterrupt(IN PRTMP_ADAPTER pAd);
 
-//========================================
+BOOLEAN RTMPHandleTxRingDmaDoneInterrupt(IN PRTMP_ADAPTER pAd,
+					 IN INT_SOURCE_CSR_STRUC TxRingBitmap);
 
-VOID SyncStateMachineInit(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  STATE_MACHINE *Sm,
-	OUT STATE_MACHINE_FUNC Trans[]);
-
-VOID BeaconTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID ScanTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID InvalidStateWhenScan(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID InvalidStateWhenJoin(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID InvalidStateWhenStart(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
+VOID RTMPHandleMgmtRingDmaDoneInterrupt(IN PRTMP_ADAPTER pAd);
 
-VOID EnqueueProbeRequest(
-	IN PRTMP_ADAPTER pAd);
+VOID RTMPHandleTBTTInterrupt(IN PRTMP_ADAPTER pAd);
 
-BOOLEAN ScanRunning(
-		IN PRTMP_ADAPTER pAd);
-//=========================================
+VOID RTMPHandlePreTBTTInterrupt(IN PRTMP_ADAPTER pAd);
 
-VOID MlmeCntlInit(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  STATE_MACHINE *S,
-	OUT STATE_MACHINE_FUNC Trans[]);
-
-VOID MlmeCntlMachinePerformAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  STATE_MACHINE *S,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlIdleProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlOidScanProc(
-	IN  PRTMP_ADAPTER pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlOidSsidProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM * Elem);
-
-VOID CntlOidRTBssidProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM * Elem);
-
-VOID CntlMlmeRoamingProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM * Elem);
-
-VOID CntlWaitDisassocProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlWaitJoinProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlWaitReassocProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlWaitStartProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlWaitAuthProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlWaitAuthProc2(
-	IN  PRTMP_ADAPTER pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID CntlWaitAssocProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID LinkUp(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR BssType);
-
-VOID LinkDown(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  BOOLEAN         IsReqFromAP);
-
-VOID IterateOnBssTab(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID IterateOnBssTab2(
-	IN  PRTMP_ADAPTER   pAd);;
-
-VOID JoinParmFill(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  OUT MLME_JOIN_REQ_STRUCT *JoinReq,
-	IN  ULONG BssIdx);
-
-VOID AssocParmFill(
-	IN  PRTMP_ADAPTER   pAd,
-	IN OUT MLME_ASSOC_REQ_STRUCT *AssocReq,
-	IN  PUCHAR pAddr,
-	IN  USHORT CapabilityInfo,
-	IN  ULONG Timeout,
-	IN  USHORT ListenIntv);
-
-VOID ScanParmFill(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  OUT MLME_SCAN_REQ_STRUCT *ScanReq,
-	IN  STRING Ssid[],
-	IN  UCHAR SsidLen,
-	IN  UCHAR BssType,
-	IN  UCHAR ScanType);
-
-VOID DisassocParmFill(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  OUT MLME_DISASSOC_REQ_STRUCT *DisassocReq,
-	IN  PUCHAR pAddr,
-	IN  USHORT Reason);
-
-VOID StartParmFill(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  OUT MLME_START_REQ_STRUCT *StartReq,
-	IN  CHAR Ssid[],
-	IN  UCHAR SsidLen);
-
-VOID AuthParmFill(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  OUT MLME_AUTH_REQ_STRUCT *AuthReq,
-	IN  PUCHAR pAddr,
-	IN  USHORT Alg);
-
-VOID EnqueuePsPoll(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID EnqueueBeaconFrame(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID MlmeJoinReqAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID MlmeScanReqAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID MlmeStartReqAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID ScanTimeoutAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID BeaconTimeoutAtJoinAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerBeaconAtScanAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerBeaconAtJoinAction(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerBeacon(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID PeerProbeReqAction(
-	IN  PRTMP_ADAPTER pAd,
-	IN  MLME_QUEUE_ELEM *Elem);
-
-VOID ScanNextChannel(
-	IN  PRTMP_ADAPTER   pAd);
-
-ULONG MakeIbssBeacon(
-	IN  PRTMP_ADAPTER   pAd);
-
-BOOLEAN MlmeScanReqSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	OUT UCHAR *BssType,
-	OUT CHAR ssid[],
-	OUT UCHAR *SsidLen,
-	OUT UCHAR *ScanType);
-
-BOOLEAN PeerBeaconAndProbeRspSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	IN  UCHAR MsgChannel,
-	OUT PUCHAR pAddr2,
-	OUT PUCHAR pBssid,
-	OUT CHAR Ssid[],
-	OUT UCHAR *pSsidLen,
-	OUT UCHAR *pBssType,
-	OUT USHORT *pBeaconPeriod,
-	OUT UCHAR *pChannel,
-	OUT UCHAR *pNewChannel,
-	OUT LARGE_INTEGER *pTimestamp,
-	OUT CF_PARM *pCfParm,
-	OUT USHORT *pAtimWin,
-	OUT USHORT *pCapabilityInfo,
-	OUT UCHAR *pErp,
-	OUT UCHAR *pDtimCount,
-	OUT UCHAR *pDtimPeriod,
-	OUT UCHAR *pBcastFlag,
-	OUT UCHAR *pMessageToMe,
-	OUT UCHAR SupRate[],
-	OUT UCHAR *pSupRateLen,
-	OUT UCHAR ExtRate[],
-	OUT UCHAR *pExtRateLen,
-	OUT	UCHAR *pCkipFlag,
-	OUT	UCHAR *pAironetCellPowerLimit,
-	OUT PEDCA_PARM       pEdcaParm,
-	OUT PQBSS_LOAD_PARM  pQbssLoad,
-	OUT PQOS_CAPABILITY_PARM pQosCapability,
-	OUT ULONG *pRalinkIe,
-	OUT UCHAR		 *pHtCapabilityLen,
-	OUT UCHAR		 *pPreNHtCapabilityLen,
-	OUT HT_CAPABILITY_IE *pHtCapability,
-	OUT UCHAR		 *AddHtInfoLen,
-	OUT ADD_HT_INFO_IE *AddHtInfo,
-	OUT UCHAR *NewExtChannel,
-	OUT USHORT *LengthVIE,
-	OUT PNDIS_802_11_VARIABLE_IEs pVIE);
-
-BOOLEAN PeerAddBAReqActionSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *pMsg,
-    IN ULONG MsgLen,
-	OUT PUCHAR pAddr2);
-
-BOOLEAN PeerAddBARspActionSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *pMsg,
-    IN ULONG MsgLen);
-
-BOOLEAN PeerDelBAActionSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN UCHAR Wcid,
-    IN VOID *pMsg,
-    IN ULONG MsgLen);
-
-BOOLEAN MlmeAssocReqSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	OUT PUCHAR pApAddr,
-	OUT USHORT *CapabilityInfo,
-	OUT ULONG *Timeout,
-	OUT USHORT *ListenIntv);
-
-BOOLEAN MlmeAuthReqSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	OUT PUCHAR pAddr,
-	OUT ULONG *Timeout,
-	OUT USHORT *Alg);
-
-BOOLEAN MlmeStartReqSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	OUT CHAR Ssid[],
-	OUT UCHAR *Ssidlen);
-
-BOOLEAN PeerAuthSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	OUT PUCHAR pAddr,
-	OUT USHORT *Alg,
-	OUT USHORT *Seq,
-	OUT USHORT *Status,
-	OUT CHAR ChlgText[]);
-
-BOOLEAN PeerAssocRspSanity(
-	IN  PRTMP_ADAPTER   pAd,
-    IN VOID *pMsg,
-	IN  ULONG MsgLen,
-	OUT PUCHAR pAddr2,
-	OUT USHORT *pCapabilityInfo,
-	OUT USHORT *pStatus,
-	OUT USHORT *pAid,
-	OUT UCHAR SupRate[],
-	OUT UCHAR *pSupRateLen,
-	OUT UCHAR ExtRate[],
-	OUT UCHAR *pExtRateLen,
-    OUT HT_CAPABILITY_IE		*pHtCapability,
-    OUT ADD_HT_INFO_IE		*pAddHtInfo,	// AP might use this additional ht info IE
-    OUT UCHAR			*pHtCapabilityLen,
-    OUT UCHAR			*pAddHtInfoLen,
-    OUT UCHAR			*pNewExtChannelOffset,
-	OUT PEDCA_PARM pEdcaParm,
-	OUT UCHAR *pCkipFlag);
-
-BOOLEAN PeerDisassocSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	OUT PUCHAR pAddr2,
-	OUT USHORT *Reason);
-
-BOOLEAN PeerWpaMessageSanity(
-    IN	PRTMP_ADAPTER		pAd,
-    IN	PEAPOL_PACKET		pMsg,
-    IN	ULONG				MsgLen,
-    IN	UCHAR				MsgType,
-    IN	MAC_TABLE_ENTRY		*pEntry);
-
-BOOLEAN PeerDeauthSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	OUT PUCHAR pAddr2,
-	OUT USHORT *Reason);
-
-BOOLEAN PeerProbeReqSanity(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  VOID *Msg,
-	IN  ULONG MsgLen,
-	OUT PUCHAR pAddr2,
-	OUT CHAR Ssid[],
-	OUT UCHAR *pSsidLen);
-
-BOOLEAN GetTimBit(
-	IN  CHAR *Ptr,
-	IN  USHORT Aid,
-	OUT UCHAR *TimLen,
-	OUT UCHAR *BcastFlag,
-	OUT UCHAR *DtimCount,
-	OUT UCHAR *DtimPeriod,
-	OUT UCHAR *MessageToMe);
-
-UCHAR ChannelSanity(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR channel);
-
-NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(
-	IN PBSS_ENTRY pBss);
-
-BOOLEAN MlmeDelBAReqSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen);
-
-BOOLEAN MlmeAddBAReqSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pAddr2);
-
-ULONG MakeOutgoingFrame(
-	OUT UCHAR *Buffer,
-	OUT ULONG *Length, ...);
-
-VOID  LfsrInit(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  ULONG Seed);
-
-UCHAR RandomByte(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID AsicUpdateAutoFallBackTable(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pTxRate);
-
-VOID  MlmePeriodicExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID LinkDownExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID STAMlmePeriodicExec(
-	PRTMP_ADAPTER pAd);
-
-VOID MlmeAutoScan(
-	IN PRTMP_ADAPTER pAd);
-
-VOID MlmeAutoReconnectLastSSID(
-	IN PRTMP_ADAPTER pAd);
-
-BOOLEAN MlmeValidateSSID(
-	IN PUCHAR pSsid,
-	IN UCHAR  SsidLen);
-
-VOID MlmeCheckForRoaming(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG    Now32);
-
-BOOLEAN MlmeCheckForFastRoaming(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID MlmeDynamicTxRateSwitching(
-	IN PRTMP_ADAPTER pAd);
-
-VOID MlmeSetTxRate(
-	IN PRTMP_ADAPTER		pAd,
-	IN PMAC_TABLE_ENTRY		pEntry,
-	IN PRTMP_TX_RATE_SWITCH	pTxRate);
-
-VOID MlmeSelectTxRateTable(
-	IN PRTMP_ADAPTER		pAd,
-	IN PMAC_TABLE_ENTRY		pEntry,
-	IN PUCHAR				*ppTable,
-	IN PUCHAR				pTableSize,
-	IN PUCHAR				pInitTxRateIdx);
-
-VOID MlmeCalculateChannelQuality(
-	IN PRTMP_ADAPTER pAd,
-	IN PMAC_TABLE_ENTRY pMacEntry,
-	IN ULONG Now);
-
-VOID MlmeCheckPsmChange(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG    Now32);
-
-VOID MlmeSetPsmBit(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT psm);
-
-VOID MlmeSetTxPreamble(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT TxPreamble);
-
-VOID UpdateBasicRateBitmap(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID MlmeUpdateTxRates(
-	IN PRTMP_ADAPTER 	pAd,
-	IN 	BOOLEAN		 	bLinkUp,
-	IN	UCHAR			apidx);
-
-VOID MlmeUpdateHtTxRates(
-	IN PRTMP_ADAPTER 		pAd,
-	IN	UCHAR				apidx);
-
-VOID    RTMPCheckRates(
-	IN      PRTMP_ADAPTER   pAd,
-	IN OUT  UCHAR           SupRate[],
-	IN OUT  UCHAR           *SupRateLen);
-
-BOOLEAN RTMPCheckChannel(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		CentralChannel,
-	IN UCHAR		Channel);
-
-BOOLEAN 	RTMPCheckHt(
-	IN		PRTMP_ADAPTER	pAd,
-	IN		UCHAR	Wcid,
-	IN OUT	HT_CAPABILITY_IE			*pHtCapability,
-	IN OUT	ADD_HT_INFO_IE			*pAddHtInfo);
-
-VOID StaQuickResponeForRateUpExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID RTMPUpdateMlmeRate(
-	IN PRTMP_ADAPTER	pAd);
-
-CHAR RTMPMaxRssi(
-	IN PRTMP_ADAPTER	pAd,
-	IN CHAR				Rssi0,
-	IN CHAR				Rssi1,
-	IN CHAR				Rssi2);
+void RTMPHandleTwakeupInterrupt(IN PRTMP_ADAPTER pAd);
 
-#ifdef RT30xx
-VOID AsicSetRxAnt(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			Ant);
+VOID RTMPHandleRxCoherentInterrupt(IN PRTMP_ADAPTER pAd);
 
-VOID RTMPFilterCalibration(
-	IN PRTMP_ADAPTER	pAd);
+BOOLEAN TxFrameIsAggregatible(IN PRTMP_ADAPTER pAd,
+			      IN PUCHAR pPrevAddr1, IN PUCHAR p8023hdr);
 
-#ifdef RTMP_EFUSE_SUPPORT
-//2008/09/11:KH add to support efuse<--
-INT set_eFuseGetFreeBlockCount_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg);
-
-INT set_eFusedump_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg);
-
-VOID eFusePhysicalReadRegisters(
-	IN PRTMP_ADAPTER    pAd,
-	IN	USHORT Offset,
-	IN	USHORT Length,
-	OUT	USHORT* pData);
+BOOLEAN PeerIsAggreOn(IN PRTMP_ADAPTER pAd,
+		      IN ULONG TxRate, IN PMAC_TABLE_ENTRY pMacEntry);
 
-int RtmpEfuseSupportCheck(
-	IN RTMP_ADAPTER *pAd);
+NDIS_STATUS Sniff2BytesFromNdisBuffer(IN PNDIS_BUFFER pFirstBuffer,
+				      IN UCHAR DesiredOffset,
+				      OUT PUCHAR pByte0, OUT PUCHAR pByte1);
 
-VOID eFuseGetFreeBlockCount(IN PRTMP_ADAPTER pAd,
-	PUINT EfuseFreeBlock);
+NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket);
 
-INT eFuse_init(
-	IN PRTMP_ADAPTER pAd);
-//2008/09/11:KH add to support efuse-->
-#endif // RTMP_EFUSE_SUPPORT //
+VOID STASendPackets(IN NDIS_HANDLE MiniportAdapterContext,
+		    IN PPNDIS_PACKET ppPacketArray, IN UINT NumberOfPackets);
 
-// add by johnli, RF power sequence setup
-VOID RT30xxLoadRFNormalModeSetup(
-	IN PRTMP_ADAPTER	pAd);
+VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd,
+		       IN BOOLEAN bIntContext,
+		       IN UCHAR QueIdx, IN UCHAR Max_Tx_Packets);
 
-VOID RT30xxLoadRFSleepModeSetup(
-	IN PRTMP_ADAPTER	pAd);
+NDIS_STATUS RTMPHardTransmit(IN PRTMP_ADAPTER pAd,
+			     IN PNDIS_PACKET pPacket,
+			     IN UCHAR QueIdx, OUT PULONG pFreeTXDLeft);
 
-VOID RT30xxReverseRFSleepModeSetup(
-	IN PRTMP_ADAPTER	pAd);
-// end johnli
+NDIS_STATUS STAHardTransmit(IN PRTMP_ADAPTER pAd,
+			    IN TX_BLK * pTxBlk, IN UCHAR QueIdx);
 
-#ifdef RT3070
-VOID NICInitRT3070RFRegisters(
-	IN RTMP_ADAPTER *pAd);
-#endif // RT3070 //
-#ifdef RT3090
-VOID NICInitRT3090RFRegisters(
-	IN RTMP_ADAPTER *pAd);
-#endif // RT3090 //
+VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
+			     IN MAC_TABLE_ENTRY * pEntry,
+			     IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID);
 
-VOID RT30xxHaltAction(
-	IN PRTMP_ADAPTER	pAd);
+NDIS_STATUS RTMPFreeTXDRequest(IN PRTMP_ADAPTER pAd,
+			       IN UCHAR RingType,
+			       IN UCHAR NumberRequired, IN PUCHAR FreeNumberIs);
 
-VOID RT30xxSetRxAnt(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			Ant);
-#endif // RT30xx //
+NDIS_STATUS MlmeHardTransmit(IN PRTMP_ADAPTER pAd,
+			     IN UCHAR QueIdx, IN PNDIS_PACKET pPacket);
 
-VOID AsicEvaluateRxAnt(
-	IN PRTMP_ADAPTER	pAd);
+NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
+				     IN UCHAR QueIdx, IN PNDIS_PACKET pPacket);
 
-VOID AsicRxAntEvalTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
+#ifdef RTMP_MAC_PCI
+NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
+				   IN UCHAR QueIdx, IN PNDIS_PACKET pPacket);
 
-VOID APSDPeriodicExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
+NDIS_STATUS MlmeDataHardTransmit(IN PRTMP_ADAPTER pAd,
+				 IN UCHAR QueIdx, IN PNDIS_PACKET pPacket);
 
-BOOLEAN RTMPCheckEntryEnableAutoRateSwitch(
-	IN PRTMP_ADAPTER    pAd,
-	IN PMAC_TABLE_ENTRY	pEntry);
+VOID RTMPWriteTxDescriptor(IN PRTMP_ADAPTER pAd,
+			   IN PTXD_STRUC pTxD, IN BOOLEAN bWIV, IN UCHAR QSEL);
+#endif // RTMP_MAC_PCI //
 
-UCHAR RTMPStaFixedTxMode(
-	IN PRTMP_ADAPTER    pAd,
-	IN PMAC_TABLE_ENTRY	pEntry);
+USHORT RTMPCalcDuration(IN PRTMP_ADAPTER pAd, IN UCHAR Rate, IN ULONG Size);
 
-VOID RTMPUpdateLegacyTxSetting(
-		UCHAR				fixed_tx_mode,
-		PMAC_TABLE_ENTRY	pEntry);
+VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pTxWI, IN BOOLEAN FRAG, IN BOOLEAN CFACK, IN BOOLEAN InsTimestamp, IN BOOLEAN AMPDU, IN BOOLEAN Ack, IN BOOLEAN NSeq,	// HW new a sequence.
+		   IN UCHAR BASize,
+		   IN UCHAR WCID,
+		   IN ULONG Length,
+		   IN UCHAR PID,
+		   IN UCHAR TID,
+		   IN UCHAR TxRate,
+		   IN UCHAR Txopmode,
+		   IN BOOLEAN CfAck, IN HTTRANSMIT_SETTING * pTransmit);
+
+VOID RTMPWriteTxWI_Data(IN PRTMP_ADAPTER pAd,
+			IN OUT PTXWI_STRUC pTxWI, IN TX_BLK * pTxBlk);
+
+VOID RTMPWriteTxWI_Cache(IN PRTMP_ADAPTER pAd,
+			 IN OUT PTXWI_STRUC pTxWI, IN TX_BLK * pTxBlk);
 
-BOOLEAN RTMPAutoRateSwitchCheck(
-	IN PRTMP_ADAPTER    pAd);
+VOID RTMPSuspendMsduTransmission(IN PRTMP_ADAPTER pAd);
 
-NDIS_STATUS MlmeInit(
-	IN  PRTMP_ADAPTER   pAd);
+VOID RTMPResumeMsduTransmission(IN PRTMP_ADAPTER pAd);
 
-VOID MlmeHandler(
-	IN  PRTMP_ADAPTER   pAd);
+NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR QueIdx, IN PUCHAR pData, IN UINT Length);
 
-VOID MlmeHalt(
-	IN  PRTMP_ADAPTER   pAd);
+//+++mark by shiang, now this function merge to MiniportMMRequest()
+//---mark by shiang, now this function merge to MiniportMMRequest()
 
-VOID MlmeResetRalinkCounters(
-	IN  PRTMP_ADAPTER   pAd);
+VOID RTMPSendNullFrame(IN PRTMP_ADAPTER pAd,
+		       IN UCHAR TxRate, IN BOOLEAN bQosNull);
 
-VOID BuildChannelList(
-	IN PRTMP_ADAPTER pAd);
+VOID RTMPSendDisassociationFrame(IN PRTMP_ADAPTER pAd);
 
-UCHAR FirstChannel(
-	IN  PRTMP_ADAPTER   pAd);
+VOID RTMPSendRTSFrame(IN PRTMP_ADAPTER pAd,
+		      IN PUCHAR pDA,
+		      IN unsigned int NextMpduSize,
+		      IN UCHAR TxRate,
+		      IN UCHAR RTSRate,
+		      IN USHORT AckDuration,
+		      IN UCHAR QueIdx, IN UCHAR FrameGap);
 
-UCHAR NextChannel(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR channel);
+PQUEUE_HEADER RTMPCheckTxSwQueue(IN PRTMP_ADAPTER pAd, OUT UCHAR * QueIdx);
 
-VOID ChangeToCellPowerLimit(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR         AironetCellPowerLimit);
+VOID RTMPReportMicError(IN PRTMP_ADAPTER pAd, IN PCIPHER_KEY pWpaKey);
 
-//
-// Prototypes of function definition in rtmp_tkip.c
-//
-VOID    RTMPInitTkipEngine(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pTKey,
-	IN  UCHAR           KeyId,
-	IN  PUCHAR          pTA,
-	IN  PUCHAR          pMICKey,
-	IN  PUCHAR          pTSC,
-	OUT PULONG          pIV16,
-	OUT PULONG          pIV32);
-
-VOID    RTMPInitMICEngine(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pKey,
-	IN  PUCHAR          pDA,
-	IN  PUCHAR          pSA,
-	IN  UCHAR           UserPriority,
-	IN  PUCHAR          pMICKey);
-
-BOOLEAN RTMPTkipCompareMICValue(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pSrc,
-	IN  PUCHAR          pDA,
-	IN  PUCHAR          pSA,
-	IN  PUCHAR          pMICKey,
-	IN	UCHAR			UserPriority,
-	IN  UINT            Len);
-
-VOID    RTMPCalculateMICValue(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PNDIS_PACKET    pPacket,
-	IN  PUCHAR          pEncap,
-	IN  PCIPHER_KEY     pKey,
-	IN	UCHAR			apidx);
-
-VOID    RTMPTkipAppendByte(
-	IN  PTKIP_KEY_INFO  pTkip,
-	IN  UCHAR           uChar);
-
-VOID    RTMPTkipAppend(
-	IN  PTKIP_KEY_INFO  pTkip,
-	IN  PUCHAR          pSrc,
-	IN  UINT            nBytes);
-
-VOID    RTMPTkipGetMIC(
-	IN  PTKIP_KEY_INFO  pTkip);
-
-BOOLEAN RTMPSoftDecryptTKIP(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR	pData,
-	IN ULONG	DataByteCnt,
-	IN UCHAR    UserPriority,
-	IN PCIPHER_KEY	pWpaKey);
-
-BOOLEAN RTMPSoftDecryptAES(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR	pData,
-	IN ULONG	DataByteCnt,
-	IN PCIPHER_KEY	pWpaKey);
+VOID WpaMicFailureReportFrame(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
+VOID WpaDisassocApAndBlockAssoc(IN PVOID SystemSpecific1,
+				IN PVOID FunctionContext,
+				IN PVOID SystemSpecific2,
+				IN PVOID SystemSpecific3);
 
+VOID WpaStaPairwiseKeySetting(IN PRTMP_ADAPTER pAd);
 
-//
-// Prototypes of function definition in cmm_info.c
-//
-INT RT_CfgSetCountryRegion(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg,
-	IN INT				band);
-
-INT RT_CfgSetWirelessMode(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg);
-
-INT RT_CfgSetShortSlot(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg);
-
-INT	RT_CfgSetWepKey(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			keyString,
-	IN	CIPHER_KEY		*pSharedKey,
-	IN	INT				keyIdx);
-
-INT RT_CfgSetWPAPSKKey(
-	IN RTMP_ADAPTER	*pAd,
-	IN PSTRING		keyString,
-	IN UCHAR		*pHashStr,
-	IN INT			hashStrLen,
-	OUT PUCHAR		pPMKBuf);
+VOID WpaStaGroupKeySetting(IN PRTMP_ADAPTER pAd);
 
+NDIS_STATUS RTMPCloneNdisPacket(IN PRTMP_ADAPTER pAd,
+				IN BOOLEAN pInsAMSDUHdr,
+				IN PNDIS_PACKET pInPacket,
+				OUT PNDIS_PACKET * ppOutPacket);
 
+NDIS_STATUS RTMPAllocateNdisPacket(IN PRTMP_ADAPTER pAd,
+				   IN PNDIS_PACKET * pPacket,
+				   IN PUCHAR pHeader,
+				   IN UINT HeaderLen,
+				   IN PUCHAR pData, IN UINT DataLen);
 
-//
-// Prototypes of function definition in cmm_info.c
-//
-VOID    RTMPWPARemoveAllKeys(
-	IN  PRTMP_ADAPTER   pAd);
+VOID RTMPFreeNdisPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket);
 
-VOID    RTMPSetPhyMode(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  ULONG phymode);
-
-VOID	RTMPUpdateHTIE(
-	IN	RT_HT_CAPABILITY	*pRtHt,
-	IN		UCHAR				*pMcsSet,
-	OUT		HT_CAPABILITY_IE *pHtCapability,
-	OUT		ADD_HT_INFO_IE		*pAddHtInfo);
-
-VOID	RTMPAddWcidAttributeEntry(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			BssIdx,
-	IN 	UCHAR		 	KeyIdx,
-	IN 	UCHAR		 	CipherAlg,
-	IN 	MAC_TABLE_ENTRY *pEntry);
-
-PSTRING GetEncryptType(
-	CHAR enc);
-
-PSTRING GetAuthMode(
-	CHAR auth);
-
-VOID	RTMPSetHT(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	OID_SET_HT_PHYMODE *pHTPhyMode);
-
-VOID	RTMPSetIndividualHT(
-	IN	PRTMP_ADAPTER		pAd,
-	IN	UCHAR				apidx);
-
-VOID RTMPSendWirelessEvent(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Event_flag,
-	IN	PUCHAR 			pAddr,
-	IN  UCHAR			BssIdx,
-	IN	CHAR			Rssi);
-
-CHAR    ConvertToRssi(
-    IN  PRTMP_ADAPTER   pAd,
-	IN CHAR				Rssi,
-	IN UCHAR    RssiNumber);
+BOOLEAN RTMPFreeTXDUponTxDmaDone(IN PRTMP_ADAPTER pAd, IN UCHAR QueIdx);
 
-/*===================================
-	Function prototype in cmm_wpa.c
-  =================================== */
-VOID    RTMPToWirelessSta(
-	IN  PRTMP_ADAPTER   pAd,
-    IN  PMAC_TABLE_ENTRY	pEntry,
-	IN  PUCHAR          pHeader802_3,
-    IN  UINT            HdrLen,
-	IN  PUCHAR          pData,
-    IN  UINT            DataLen,
-    IN	BOOLEAN				bClearFrame);
-
-VOID WpaDerivePTK(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UCHAR   *PMK,
-	IN  UCHAR   *ANonce,
-	IN  UCHAR   *AA,
-	IN  UCHAR   *SNonce,
-	IN  UCHAR   *SA,
-	OUT UCHAR   *output,
-	IN  UINT    len);
-
-VOID    GenRandom(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	UCHAR			*macAddr,
-	OUT	UCHAR			*random);
-
-BOOLEAN RTMPCheckWPAframe(
-	IN  PRTMP_ADAPTER       pAd,
-	IN PMAC_TABLE_ENTRY	pEntry,
-	IN PUCHAR			pData,
-	IN ULONG			DataByteCount,
-	IN UCHAR			FromWhichBSSID);
-
-VOID AES_GTK_KEY_UNWRAP(
-	IN  UCHAR   *key,
-	OUT UCHAR   *plaintext,
-	IN	UINT32	c_len,
-	IN  UCHAR   *ciphertext);
-
-BOOLEAN RTMPParseEapolKeyData(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PUCHAR          pKeyData,
-	IN  UCHAR           KeyDataLen,
-	IN	UCHAR			GroupKeyIndex,
-	IN	UCHAR			MsgType,
-	IN	BOOLEAN			bWPA2,
-	IN  MAC_TABLE_ENTRY *pEntry);
-
-VOID	ConstructEapolMsg(
-	IN	PMAC_TABLE_ENTRY	pEntry,
-    IN	UCHAR				GroupKeyWepStatus,
-    IN	UCHAR				MsgType,
-    IN	UCHAR				DefaultKeyIdx,
-	IN	UCHAR				*KeyNonce,
-	IN	UCHAR				*TxRSC,
-	IN	UCHAR				*GTK,
-	IN	UCHAR				*RSNIE,
-	IN	UCHAR				RSNIE_Len,
-    OUT PEAPOL_PACKET       pMsg);
-
-NDIS_STATUS	RTMPSoftDecryptBroadCastData(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	RX_BLK							*pRxBlk,
-	IN  NDIS_802_11_ENCRYPTION_STATUS	GroupCipher,
-	IN  PCIPHER_KEY						pShard_key);
-
-VOID RTMPMakeRSNIE(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  UINT            AuthMode,
-	IN  UINT            WepStatus,
-	IN	UCHAR			apidx);
+BOOLEAN RTMPCheckDHCPFrame(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket);
+
+BOOLEAN RTMPCheckEtherType(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket);
 
 //
-// function prototype in ap_wpa.c
+// Private routines in rtmp_wep.c
 //
-VOID RTMPGetTxTscFromAsic(
-	IN  PRTMP_ADAPTER   pAd,
-	IN	UCHAR			apidx,
-	OUT	PUCHAR			pTxTsc);
-
-VOID APInstallPairwiseKey(
-	PRTMP_ADAPTER		pAd,
-	PMAC_TABLE_ENTRY	pEntry);
-
-UINT	APValidateRSNIE(
-	IN  PRTMP_ADAPTER   pAd,
-	IN PMAC_TABLE_ENTRY pEntry,
-	IN PUCHAR			pRsnIe,
-	IN UCHAR			rsnie_len);
-
-VOID HandleCounterMeasure(
-	IN  PRTMP_ADAPTER   pAd,
-	IN MAC_TABLE_ENTRY  *pEntry);
-
-VOID WPAStart4WayHS(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MAC_TABLE_ENTRY *pEntry,
-	IN	ULONG			TimeInterval);
-
-VOID WPAStart2WayGroupHS(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  MAC_TABLE_ENTRY *pEntry);
-
-VOID PeerPairMsg1Action(
-	IN PRTMP_ADAPTER pAd,
-	IN MAC_TABLE_ENTRY  *pEntry,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerPairMsg2Action(
-	IN  PRTMP_ADAPTER   pAd,
-	IN MAC_TABLE_ENTRY  *pEntry,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerPairMsg3Action(
-	IN  PRTMP_ADAPTER       pAd,
-	IN MAC_TABLE_ENTRY  *pEntry,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerPairMsg4Action(
-	IN PRTMP_ADAPTER pAd,
-	IN MAC_TABLE_ENTRY  *pEntry,
-	IN MLME_QUEUE_ELEM *Elem);
-
-VOID PeerGroupMsg1Action(
-	IN PRTMP_ADAPTER  pAd,
-	IN  PMAC_TABLE_ENTRY pEntry,
-    IN  MLME_QUEUE_ELEM  *Elem);
-
-VOID PeerGroupMsg2Action(
-	IN PRTMP_ADAPTER pAd,
-	IN PMAC_TABLE_ENTRY	pEntry,
-	IN  VOID             *Msg,
-	IN  UINT             MsgLen);
-
-VOID WpaDeriveGTK(
-	IN  UCHAR   *PMK,
-	IN  UCHAR   *GNonce,
-	IN  UCHAR   *AA,
-	OUT UCHAR   *output,
-	IN  UINT    len);
-
-VOID AES_GTK_KEY_WRAP(
-	IN UCHAR *key,
-	IN UCHAR *plaintext,
-	IN UINT32 p_len,
-	OUT UCHAR *ciphertext);
+VOID RTMPInitWepEngine(IN PRTMP_ADAPTER pAd,
+		       IN PUCHAR pKey,
+		       IN UCHAR KeyId, IN UCHAR KeyLen, IN PUCHAR pDest);
 
-//typedef void (*TIMER_FUNCTION)(unsigned long);
+VOID RTMPEncryptData(IN PRTMP_ADAPTER pAd,
+		     IN PUCHAR pSrc, IN PUCHAR pDest, IN UINT Len);
 
+BOOLEAN RTMPSoftDecryptWEP(IN PRTMP_ADAPTER pAd,
+			   IN PUCHAR pData,
+			   IN ULONG DataByteCnt, IN PCIPHER_KEY pGroupKey);
 
-/* timeout -- ms */
-VOID RTMP_SetPeriodicTimer(
-	IN	NDIS_MINIPORT_TIMER *pTimer,
-	IN	unsigned long timeout);
-
-VOID RTMP_OS_Init_Timer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	NDIS_MINIPORT_TIMER *pTimer,
-	IN	TIMER_FUNCTION function,
-	IN	PVOID data);
-
-VOID RTMP_OS_Add_Timer(
-	IN	NDIS_MINIPORT_TIMER	*pTimer,
-	IN	unsigned long timeout);
-
-VOID RTMP_OS_Mod_Timer(
-	IN	NDIS_MINIPORT_TIMER	*pTimer,
-	IN	unsigned long timeout);
-
-
-VOID RTMP_OS_Del_Timer(
-	IN	NDIS_MINIPORT_TIMER	*pTimer,
-	OUT	BOOLEAN				 *pCancelled);
-
-
-VOID RTMP_OS_Release_Packet(
-	IN	PRTMP_ADAPTER pAd,
-	IN	PQUEUE_ENTRY  pEntry);
-
-VOID RTMPusecDelay(
-	IN	ULONG	usec);
-
-NDIS_STATUS os_alloc_mem(
-	IN	RTMP_ADAPTER *pAd,
-	OUT	UCHAR **mem,
-	IN	ULONG  size);
-
-NDIS_STATUS os_free_mem(
-	IN	PRTMP_ADAPTER pAd,
-	IN	PVOID mem);
-
-
-void RTMP_AllocateSharedMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
-
-VOID RTMPFreeTxRxRingMemory(
-    IN  PRTMP_ADAPTER   pAd);
-
-NDIS_STATUS AdapterBlockAllocateMemory(
-	IN PVOID	handle,
-	OUT	PVOID	*ppAd);
-
-void RTMP_AllocateTxDescMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	UINT	Index,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
-
-void RTMP_AllocateFirstTxBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	UINT	Index,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
-
-void RTMP_FreeFirstTxBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	IN	PVOID	VirtualAddress,
-	IN	NDIS_PHYSICAL_ADDRESS PhysicalAddress);
-
-void RTMP_AllocateMgmtDescMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
-
-void RTMP_AllocateRxDescMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
-
-void RTMP_FreeDescMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	PVOID	VirtualAddress,
-	IN	NDIS_PHYSICAL_ADDRESS PhysicalAddress);
-
-PNDIS_PACKET RtmpOSNetPktAlloc(
-	IN RTMP_ADAPTER *pAd,
-	IN int size);
-
-PNDIS_PACKET RTMP_AllocateRxPacketBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
-
-PNDIS_PACKET RTMP_AllocateTxPacketBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress);
-
-PNDIS_PACKET RTMP_AllocateFragPacketBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length);
-
-void RTMP_QueryPacketInfo(
-	IN  PNDIS_PACKET pPacket,
-	OUT PACKET_INFO  *pPacketInfo,
-	OUT PUCHAR		 *pSrcBufVA,
-	OUT	UINT		 *pSrcBufLen);
-
-void RTMP_QueryNextPacketInfo(
-	IN  PNDIS_PACKET *ppPacket,
-	OUT PACKET_INFO  *pPacketInfo,
-	OUT PUCHAR		 *pSrcBufVA,
-	OUT	UINT		 *pSrcBufLen);
-
-
-BOOLEAN RTMP_FillTxBlkInfo(
-	IN RTMP_ADAPTER *pAd,
-	IN TX_BLK *pTxBlk);
+VOID RTMPSetICV(IN PRTMP_ADAPTER pAd, IN PUCHAR pDest);
 
+VOID ARCFOUR_INIT(IN PARCFOURCONTEXT Ctx, IN PUCHAR pKey, IN UINT KeyLen);
 
-PRTMP_SCATTER_GATHER_LIST
-rt_get_sg_list_from_packet(PNDIS_PACKET pPacket, RTMP_SCATTER_GATHER_LIST *sg);
+UCHAR ARCFOUR_BYTE(IN PARCFOURCONTEXT Ctx);
 
+VOID ARCFOUR_DECRYPT(IN PARCFOURCONTEXT Ctx,
+		     IN PUCHAR pDest, IN PUCHAR pSrc, IN UINT Len);
 
- void announce_802_3_packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket);
+VOID ARCFOUR_ENCRYPT(IN PARCFOURCONTEXT Ctx,
+		     IN PUCHAR pDest, IN PUCHAR pSrc, IN UINT Len);
 
+VOID WPAARCFOUR_ENCRYPT(IN PARCFOURCONTEXT Ctx,
+			IN PUCHAR pDest, IN PUCHAR pSrc, IN UINT Len);
 
-UINT BA_Reorder_AMSDU_Annnounce(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket);
+UINT RTMP_CALC_FCS32(IN UINT Fcs, IN PUCHAR Cp, IN INT Len);
 
-PNET_DEV get_netdev_from_bssid(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			FromWhichBSSID);
+//
+// MLME routines
+//
 
+// Asic/RF/BBP related functions
 
-PNDIS_PACKET duplicate_pkt(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pHeader802_3,
-    IN  UINT            HdrLen,
-	IN	PUCHAR			pData,
-	IN	ULONG			DataSize,
-	IN	UCHAR			FromWhichBSSID);
+VOID AsicAdjustTxPower(IN PRTMP_ADAPTER pAd);
 
+VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
+		       IN USHORT OperaionMode,
+		       IN UCHAR SetMask,
+		       IN BOOLEAN bDisableBGProtect, IN BOOLEAN bNonGFExist);
 
-PNDIS_PACKET duplicate_pkt_with_TKIP_MIC(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pOldPkt);
+VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd,
+		       IN UCHAR Channel, IN BOOLEAN bScan);
 
-void ba_flush_reordering_timeout_mpdus(
-	IN PRTMP_ADAPTER	pAd,
-	IN PBA_REC_ENTRY	pBAEntry,
-	IN ULONG			Now32);
+VOID AsicLockChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel);
 
+VOID AsicRfTuningExec(IN PVOID SystemSpecific1,
+		      IN PVOID FunctionContext,
+		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
 
-VOID BAOriSessionSetUp(
-			IN PRTMP_ADAPTER    pAd,
-			IN MAC_TABLE_ENTRY	*pEntry,
-			IN UCHAR			TID,
-			IN USHORT			TimeOut,
-			IN ULONG			DelayTime,
-			IN BOOLEAN		isForced);
+VOID AsicResetBBPAgent(IN PRTMP_ADAPTER pAd);
 
-VOID BASessionTearDownALL(
-	IN OUT	PRTMP_ADAPTER pAd,
-	IN		UCHAR Wcid);
+VOID AsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
+			     IN USHORT TbttNumToNextWakeUp);
 
-BOOLEAN OS_Need_Clone_Packet(void);
+VOID AsicForceSleep(IN PRTMP_ADAPTER pAd);
 
+VOID AsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx);
 
-VOID build_tx_packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	PUCHAR	pFrame,
-	IN	ULONG	FrameLen);
-
-
-VOID BAOriSessionTearDown(
-	IN OUT	PRTMP_ADAPTER	pAd,
-	IN		UCHAR			Wcid,
-	IN		UCHAR			TID,
-	IN		BOOLEAN			bPassive,
-	IN		BOOLEAN			bForceSend);
-
-VOID BARecSessionTearDown(
-	IN OUT	PRTMP_ADAPTER	pAd,
-	IN		UCHAR			Wcid,
-	IN		UCHAR			TID,
-	IN		BOOLEAN			bPassive);
+VOID AsicSetBssid(IN PRTMP_ADAPTER pAd, IN PUCHAR pBssid);
 
-BOOLEAN ba_reordering_resource_init(PRTMP_ADAPTER pAd, int num);
-void ba_reordering_resource_release(PRTMP_ADAPTER pAd);
+VOID AsicSetMcastWC(IN PRTMP_ADAPTER pAd);
 
-PSTRING rstrtok(
-	IN PSTRING s,
-	IN const PSTRING ct);
+VOID AsicDelWcidTab(IN PRTMP_ADAPTER pAd, IN UCHAR Wcid);
 
-////////// common ioctl functions //////////
-INT	SetCommonHT(
-	IN	PRTMP_ADAPTER	pAd);
+VOID AsicEnableRDG(IN PRTMP_ADAPTER pAd);
 
-INT	    WpaCheckEapCode(
-	IN  PRTMP_ADAPTER   	pAd,
-	IN  PUCHAR				pFrame,
-	IN  USHORT				FrameLen,
-	IN  USHORT				OffSet);
-
-VOID    WpaSendMicFailureToWpaSupplicant(
-    IN  PRTMP_ADAPTER       pAd,
-    IN  BOOLEAN             bUnicast);
-
-int wext_notify_event_assoc(
-	IN  RTMP_ADAPTER *pAd);
-
-BOOLEAN STARxDoneInterruptHandle(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	BOOLEAN			argc);
+VOID AsicDisableRDG(IN PRTMP_ADAPTER pAd);
 
-// AMPDU packet indication
-VOID Indicate_AMPDU_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID);
+VOID AsicDisableSync(IN PRTMP_ADAPTER pAd);
 
-// AMSDU packet indication
-VOID Indicate_AMSDU_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID);
+VOID AsicEnableBssSync(IN PRTMP_ADAPTER pAd);
 
-// Normal legacy Rx packet indication
-VOID Indicate_Legacy_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID);
-
-VOID Indicate_EAPOL_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID);
-
-void  update_os_packet_info(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID);
-
-void wlan_802_11_to_802_3_packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	PUCHAR			pHeader802_3,
-	IN  UCHAR			FromWhichBSSID);
+VOID AsicEnableIbssSync(IN PRTMP_ADAPTER pAd);
 
-// remove LLC and get 802_3 Header
-#define  RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(_pRxBlk, _pHeader802_3)	\
-{																				\
-	PUCHAR _pRemovedLLCSNAP = NULL, _pDA, _pSA;                                 \
-																				\
-	if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_MESH))                                    \
-	{                                                                           \
-		_pDA = _pRxBlk->pHeader->Addr3;                                         \
-		_pSA = (PUCHAR)_pRxBlk->pHeader + sizeof(HEADER_802_11);                \
-	}                                                                           \
-	else                                                                        \
-	{                                                                           \
-		if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_INFRA))                              	\
-		{                                                                       \
-			_pDA = _pRxBlk->pHeader->Addr1;                                     \
-		if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_DLS))									\
-			_pSA = _pRxBlk->pHeader->Addr2;										\
-		else																	\
-			_pSA = _pRxBlk->pHeader->Addr3;                                     \
-		}                                                                       \
-		else                                                                    \
-		{                                                                       \
-			_pDA = _pRxBlk->pHeader->Addr1;                                     \
-			_pSA = _pRxBlk->pHeader->Addr2;                                     \
-		}                                                                       \
-	}                                                                           \
-																				\
-	CONVERT_TO_802_3(_pHeader802_3, _pDA, _pSA, _pRxBlk->pData, 				\
-		_pRxBlk->DataSize, _pRemovedLLCSNAP);                                   \
-}
+VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm);
 
-VOID Sta_Announce_or_Forward_802_3_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	UCHAR			FromWhichBSSID);
+VOID AsicSetSlotTime(IN PRTMP_ADAPTER pAd, IN BOOLEAN bUseShortSlotTime);
 
-#define ANNOUNCE_OR_FORWARD_802_3_PACKET(_pAd, _pPacket, _FromWhichBSS)\
-			Sta_Announce_or_Forward_802_3_Packet(_pAd, _pPacket, _FromWhichBSS);
-			//announce_802_3_packet(_pAd, _pPacket);
+VOID AsicAddSharedKeyEntry(IN PRTMP_ADAPTER pAd,
+			   IN UCHAR BssIndex,
+			   IN UCHAR KeyIdx,
+			   IN UCHAR CipherAlg,
+			   IN PUCHAR pKey, IN PUCHAR pTxMic, IN PUCHAR pRxMic);
 
-PNDIS_PACKET DuplicatePacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	UCHAR			FromWhichBSSID);
+VOID AsicRemoveSharedKeyEntry(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR BssIndex, IN UCHAR KeyIdx);
 
+VOID AsicUpdateWCIDAttribute(IN PRTMP_ADAPTER pAd,
+			     IN USHORT WCID,
+			     IN UCHAR BssIndex,
+			     IN UCHAR CipherAlg,
+			     IN BOOLEAN bUsePairewiseKeyTable);
 
-PNDIS_PACKET ClonePacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	PUCHAR			pData,
-	IN	ULONG			DataSize);
+VOID AsicUpdateWCIDIVEIV(IN PRTMP_ADAPTER pAd,
+			 IN USHORT WCID, IN ULONG uIV, IN ULONG uEIV);
 
+VOID AsicUpdateRxWCIDTable(IN PRTMP_ADAPTER pAd,
+			   IN USHORT WCID, IN PUCHAR pAddr);
 
-// Normal, AMPDU or AMSDU
-VOID CmmRxnonRalinkFrameIndicate(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID);
-
-VOID CmmRxRalinkFrameIndicate(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	MAC_TABLE_ENTRY	*pEntry,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID);
-
-VOID Update_Rssi_Sample(
-	IN PRTMP_ADAPTER	pAd,
-	IN RSSI_SAMPLE		*pRssi,
-	IN PRXWI_STRUC		pRxWI);
-
-PNDIS_PACKET GetPacketFromRxRing(
-	IN	PRTMP_ADAPTER	pAd,
-	OUT		PRT28XX_RXD_STRUC		pSaveRxD,
-	OUT		BOOLEAN			*pbReschedule,
-	IN OUT	UINT32			*pRxPending);
-
-PNDIS_PACKET RTMPDeFragmentDataFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk);
+VOID AsicAddKeyEntry(IN PRTMP_ADAPTER pAd,
+		     IN USHORT WCID,
+		     IN UCHAR BssIndex,
+		     IN UCHAR KeyIdx,
+		     IN PCIPHER_KEY pCipherKey,
+		     IN BOOLEAN bUsePairewiseKeyTable, IN BOOLEAN bTxKey);
 
-enum {
-	DIDmsg_lnxind_wlansniffrm		= 0x00000044,
-	DIDmsg_lnxind_wlansniffrm_hosttime	= 0x00010044,
-	DIDmsg_lnxind_wlansniffrm_mactime	= 0x00020044,
-	DIDmsg_lnxind_wlansniffrm_channel	= 0x00030044,
-	DIDmsg_lnxind_wlansniffrm_rssi		= 0x00040044,
-	DIDmsg_lnxind_wlansniffrm_sq		= 0x00050044,
-	DIDmsg_lnxind_wlansniffrm_signal	= 0x00060044,
-	DIDmsg_lnxind_wlansniffrm_noise		= 0x00070044,
-	DIDmsg_lnxind_wlansniffrm_rate		= 0x00080044,
-	DIDmsg_lnxind_wlansniffrm_istx		= 0x00090044,
-	DIDmsg_lnxind_wlansniffrm_frmlen	= 0x000A0044
-};
-enum {
-	P80211ENUM_msgitem_status_no_value	= 0x00
+VOID AsicAddPairwiseKeyEntry(IN PRTMP_ADAPTER pAd,
+			     IN PUCHAR pAddr,
+			     IN UCHAR WCID, IN CIPHER_KEY * pCipherKey);
+
+VOID AsicRemovePairwiseKeyEntry(IN PRTMP_ADAPTER pAd,
+				IN UCHAR BssIdx, IN UCHAR Wcid);
+
+BOOLEAN AsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
+			     IN UCHAR Command,
+			     IN UCHAR Token, IN UCHAR Arg0, IN UCHAR Arg1);
+
+#ifdef RTMP_MAC_PCI
+BOOLEAN AsicCheckCommanOk(IN PRTMP_ADAPTER pAd, IN UCHAR Command);
+#endif // RTMP_MAC_PCI //
+
+VOID MacAddrRandomBssid(IN PRTMP_ADAPTER pAd, OUT PUCHAR pAddr);
+
+VOID MgtMacHeaderInit(IN PRTMP_ADAPTER pAd,
+		      IN OUT PHEADER_802_11 pHdr80211,
+		      IN UCHAR SubType,
+		      IN UCHAR ToDs, IN PUCHAR pDA, IN PUCHAR pBssid);
+
+VOID MlmeRadioOff(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeRadioOn(IN PRTMP_ADAPTER pAd);
+
+VOID BssTableInit(IN BSS_TABLE * Tab);
+
+VOID BATableInit(IN PRTMP_ADAPTER pAd, IN BA_TABLE * Tab);
+
+ULONG BssTableSearch(IN BSS_TABLE * Tab, IN PUCHAR pBssid, IN UCHAR Channel);
+
+ULONG BssSsidTableSearch(IN BSS_TABLE * Tab,
+			 IN PUCHAR pBssid,
+			 IN PUCHAR pSsid, IN UCHAR SsidLen, IN UCHAR Channel);
+
+ULONG BssTableSearchWithSSID(IN BSS_TABLE * Tab,
+			     IN PUCHAR Bssid,
+			     IN PUCHAR pSsid,
+			     IN UCHAR SsidLen, IN UCHAR Channel);
+
+ULONG BssSsidTableSearchBySSID(IN BSS_TABLE * Tab,
+			       IN PUCHAR pSsid, IN UCHAR SsidLen);
+
+VOID BssTableDeleteEntry(IN OUT PBSS_TABLE pTab,
+			 IN PUCHAR pBssid, IN UCHAR Channel);
+
+VOID BATableDeleteORIEntry(IN OUT PRTMP_ADAPTER pAd,
+			   IN BA_ORI_ENTRY * pBAORIEntry);
+
+VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT PBSS_ENTRY pBss, IN PUCHAR pBssid, IN CHAR Ssid[], IN UCHAR SsidLen, IN UCHAR BssType, IN USHORT BeaconPeriod, IN PCF_PARM CfParm, IN USHORT AtimWin, IN USHORT CapabilityInfo, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN HT_CAPABILITY_IE * pHtCapability, IN ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+		 IN UCHAR HtCapabilityLen,
+		 IN UCHAR AddHtInfoLen,
+		 IN UCHAR NewExtChanOffset,
+		 IN UCHAR Channel,
+		 IN CHAR Rssi,
+		 IN LARGE_INTEGER TimeStamp,
+		 IN UCHAR CkipFlag,
+		 IN PEDCA_PARM pEdcaParm,
+		 IN PQOS_CAPABILITY_PARM pQosCapability,
+		 IN PQBSS_LOAD_PARM pQbssLoad,
+		 IN USHORT LengthVIE, IN PNDIS_802_11_VARIABLE_IEs pVIE);
+
+ULONG BssTableSetEntry(IN PRTMP_ADAPTER pAd, OUT PBSS_TABLE pTab, IN PUCHAR pBssid, IN CHAR Ssid[], IN UCHAR SsidLen, IN UCHAR BssType, IN USHORT BeaconPeriod, IN CF_PARM * CfParm, IN USHORT AtimWin, IN USHORT CapabilityInfo, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN HT_CAPABILITY_IE * pHtCapability, IN ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+		       IN UCHAR HtCapabilityLen,
+		       IN UCHAR AddHtInfoLen,
+		       IN UCHAR NewExtChanOffset,
+		       IN UCHAR Channel,
+		       IN CHAR Rssi,
+		       IN LARGE_INTEGER TimeStamp,
+		       IN UCHAR CkipFlag,
+		       IN PEDCA_PARM pEdcaParm,
+		       IN PQOS_CAPABILITY_PARM pQosCapability,
+		       IN PQBSS_LOAD_PARM pQbssLoad,
+		       IN USHORT LengthVIE, IN PNDIS_802_11_VARIABLE_IEs pVIE);
+
+VOID BATableInsertEntry(IN PRTMP_ADAPTER pAd,
+			IN USHORT Aid,
+			IN USHORT TimeOutValue,
+			IN USHORT StartingSeq,
+			IN UCHAR TID,
+			IN UCHAR BAWinSize,
+			IN UCHAR OriginatorStatus, IN BOOLEAN IsRecipient);
+
+VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
+		      OUT BSS_TABLE * OutTab, IN CHAR Ssid[], IN UCHAR SsidLen);
+
+VOID BssTableSortByRssi(IN OUT BSS_TABLE * OutTab);
+
+VOID BssCipherParse(IN OUT PBSS_ENTRY pBss);
+
+NDIS_STATUS MlmeQueueInit(IN MLME_QUEUE * Queue);
+
+VOID MlmeQueueDestroy(IN MLME_QUEUE * Queue);
+
+BOOLEAN MlmeEnqueue(IN PRTMP_ADAPTER pAd,
+		    IN ULONG Machine,
+		    IN ULONG MsgType, IN ULONG MsgLen, IN VOID * Msg);
+
+BOOLEAN MlmeEnqueueForRecv(IN PRTMP_ADAPTER pAd,
+			   IN ULONG Wcid,
+			   IN ULONG TimeStampHigh,
+			   IN ULONG TimeStampLow,
+			   IN UCHAR Rssi0,
+			   IN UCHAR Rssi1,
+			   IN UCHAR Rssi2,
+			   IN ULONG MsgLen, IN PVOID Msg, IN UCHAR Signal);
+
+BOOLEAN MlmeDequeue(IN MLME_QUEUE * Queue, OUT MLME_QUEUE_ELEM ** Elem);
+
+VOID MlmeRestartStateMachine(IN PRTMP_ADAPTER pAd);
+
+BOOLEAN MlmeQueueEmpty(IN MLME_QUEUE * Queue);
+
+BOOLEAN MlmeQueueFull(IN MLME_QUEUE * Queue);
+
+BOOLEAN MsgTypeSubst(IN PRTMP_ADAPTER pAd,
+		     IN PFRAME_802_11 pFrame,
+		     OUT INT * Machine, OUT INT * MsgType);
+
+VOID StateMachineInit(IN STATE_MACHINE * Sm,
+		      IN STATE_MACHINE_FUNC Trans[],
+		      IN ULONG StNr,
+		      IN ULONG MsgNr,
+		      IN STATE_MACHINE_FUNC DefFunc,
+		      IN ULONG InitState, IN ULONG Base);
+
+VOID StateMachineSetAction(IN STATE_MACHINE * S,
+			   IN ULONG St, ULONG Msg, IN STATE_MACHINE_FUNC F);
+
+VOID StateMachinePerformAction(IN PRTMP_ADAPTER pAd,
+			       IN STATE_MACHINE * S, IN MLME_QUEUE_ELEM * Elem);
+
+VOID Drop(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID AssocStateMachineInit(IN PRTMP_ADAPTER pAd,
+			   IN STATE_MACHINE * Sm,
+			   OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID ReassocTimeout(IN PVOID SystemSpecific1,
+		    IN PVOID FunctionContext,
+		    IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID AssocTimeout(IN PVOID SystemSpecific1,
+		  IN PVOID FunctionContext,
+		  IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID DisassocTimeout(IN PVOID SystemSpecific1,
+		     IN PVOID FunctionContext,
+		     IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+//----------------------------------------------
+VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID MlmeReassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID MlmeDisassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerAssocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerReassocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerDisassocAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID DisassocTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID AssocTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID ReassocTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID Cls3errAction(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr);
+
+VOID InvalidStateWhenAssoc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID InvalidStateWhenReassoc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID InvalidStateWhenDisassociate(IN PRTMP_ADAPTER pAd,
+				  IN MLME_QUEUE_ELEM * Elem);
+
+#ifdef RTMP_MAC_USB
+VOID MlmeCntlConfirm(IN PRTMP_ADAPTER pAd, IN ULONG MsgType, IN USHORT Msg);
+#endif // RTMP_MAC_USB //
+
+VOID ComposePsPoll(IN PRTMP_ADAPTER pAd);
+
+VOID ComposeNullFrame(IN PRTMP_ADAPTER pAd);
+
+VOID AssocPostProc(IN PRTMP_ADAPTER pAd,
+		   IN PUCHAR pAddr2,
+		   IN USHORT CapabilityInfo,
+		   IN USHORT Aid,
+		   IN UCHAR SupRate[],
+		   IN UCHAR SupRateLen,
+		   IN UCHAR ExtRate[],
+		   IN UCHAR ExtRateLen,
+		   IN PEDCA_PARM pEdcaParm,
+		   IN HT_CAPABILITY_IE * pHtCapability,
+		   IN UCHAR HtCapabilityLen, IN ADD_HT_INFO_IE * pAddHtInfo);
+
+VOID AuthStateMachineInit(IN PRTMP_ADAPTER pAd,
+			  IN PSTATE_MACHINE sm, OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID AuthTimeout(IN PVOID SystemSpecific1,
+		 IN PVOID FunctionContext,
+		 IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID MlmeAuthReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerAuthRspAtSeq2Action(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerAuthRspAtSeq4Action(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID AuthTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID Cls2errAction(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr);
+
+VOID MlmeDeauthReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID InvalidStateWhenAuth(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+//=============================================
+
+VOID AuthRspStateMachineInit(IN PRTMP_ADAPTER pAd,
+			     IN PSTATE_MACHINE Sm,
+			     IN STATE_MACHINE_FUNC Trans[]);
+
+VOID PeerDeauthAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerAuthSimpleRspGenAndSend(IN PRTMP_ADAPTER pAd,
+				 IN PHEADER_802_11 pHdr80211,
+				 IN USHORT Alg,
+				 IN USHORT Seq,
+				 IN USHORT Reason, IN USHORT Status);
+
+//
+// Private routines in dls.c
+//
+
+//========================================
+
+VOID SyncStateMachineInit(IN PRTMP_ADAPTER pAd,
+			  IN STATE_MACHINE * Sm,
+			  OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID BeaconTimeout(IN PVOID SystemSpecific1,
+		   IN PVOID FunctionContext,
+		   IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID ScanTimeout(IN PVOID SystemSpecific1,
+		 IN PVOID FunctionContext,
+		 IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID InvalidStateWhenScan(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID InvalidStateWhenJoin(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID InvalidStateWhenStart(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID EnqueueProbeRequest(IN PRTMP_ADAPTER pAd);
+
+BOOLEAN ScanRunning(IN PRTMP_ADAPTER pAd);
+//=========================================
+
+VOID MlmeCntlInit(IN PRTMP_ADAPTER pAd,
+		  IN STATE_MACHINE * S, OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID MlmeCntlMachinePerformAction(IN PRTMP_ADAPTER pAd,
+				  IN STATE_MACHINE * S,
+				  IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlIdleProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlOidScanProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlMlmeRoamingProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlWaitDisassocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlWaitJoinProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlWaitReassocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlWaitStartProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlWaitAuthProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlWaitAuthProc2(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID CntlWaitAssocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType);
+
+VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP);
+
+VOID IterateOnBssTab(IN PRTMP_ADAPTER pAd);
+
+VOID IterateOnBssTab2(IN PRTMP_ADAPTER pAd);;
+
+VOID JoinParmFill(IN PRTMP_ADAPTER pAd,
+		  IN OUT MLME_JOIN_REQ_STRUCT * JoinReq, IN ULONG BssIdx);
+
+VOID AssocParmFill(IN PRTMP_ADAPTER pAd,
+		   IN OUT MLME_ASSOC_REQ_STRUCT * AssocReq,
+		   IN PUCHAR pAddr,
+		   IN USHORT CapabilityInfo,
+		   IN ULONG Timeout, IN USHORT ListenIntv);
+
+VOID ScanParmFill(IN PRTMP_ADAPTER pAd,
+		  IN OUT MLME_SCAN_REQ_STRUCT * ScanReq,
+		  IN STRING Ssid[],
+		  IN UCHAR SsidLen, IN UCHAR BssType, IN UCHAR ScanType);
+
+VOID DisassocParmFill(IN PRTMP_ADAPTER pAd,
+		      IN OUT MLME_DISASSOC_REQ_STRUCT * DisassocReq,
+		      IN PUCHAR pAddr, IN USHORT Reason);
+
+VOID StartParmFill(IN PRTMP_ADAPTER pAd,
+		   IN OUT MLME_START_REQ_STRUCT * StartReq,
+		   IN CHAR Ssid[], IN UCHAR SsidLen);
+
+VOID AuthParmFill(IN PRTMP_ADAPTER pAd,
+		  IN OUT MLME_AUTH_REQ_STRUCT * AuthReq,
+		  IN PUCHAR pAddr, IN USHORT Alg);
+
+VOID EnqueuePsPoll(IN PRTMP_ADAPTER pAd);
+
+VOID EnqueueBeaconFrame(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeJoinReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID MlmeScanReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID MlmeStartReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID ScanTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID BeaconTimeoutAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerBeaconAtScanAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerProbeReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
+
+VOID ScanNextChannel(IN PRTMP_ADAPTER pAd);
+
+ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd);
+
+BOOLEAN MlmeScanReqSanity(IN PRTMP_ADAPTER pAd,
+			  IN VOID * Msg,
+			  IN ULONG MsgLen,
+			  OUT UCHAR * BssType,
+			  OUT CHAR ssid[],
+			  OUT UCHAR * SsidLen, OUT UCHAR * ScanType);
+
+BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd,
+				    IN VOID * Msg,
+				    IN ULONG MsgLen,
+				    IN UCHAR MsgChannel,
+				    OUT PUCHAR pAddr2,
+				    OUT PUCHAR pBssid,
+				    OUT CHAR Ssid[],
+				    OUT UCHAR * pSsidLen,
+				    OUT UCHAR * pBssType,
+				    OUT USHORT * pBeaconPeriod,
+				    OUT UCHAR * pChannel,
+				    OUT UCHAR * pNewChannel,
+				    OUT LARGE_INTEGER * pTimestamp,
+				    OUT CF_PARM * pCfParm,
+				    OUT USHORT * pAtimWin,
+				    OUT USHORT * pCapabilityInfo,
+				    OUT UCHAR * pErp,
+				    OUT UCHAR * pDtimCount,
+				    OUT UCHAR * pDtimPeriod,
+				    OUT UCHAR * pBcastFlag,
+				    OUT UCHAR * pMessageToMe,
+				    OUT UCHAR SupRate[],
+				    OUT UCHAR * pSupRateLen,
+				    OUT UCHAR ExtRate[],
+				    OUT UCHAR * pExtRateLen,
+				    OUT UCHAR * pCkipFlag,
+				    OUT UCHAR * pAironetCellPowerLimit,
+				    OUT PEDCA_PARM pEdcaParm,
+				    OUT PQBSS_LOAD_PARM pQbssLoad,
+				    OUT PQOS_CAPABILITY_PARM pQosCapability,
+				    OUT ULONG * pRalinkIe,
+				    OUT UCHAR * pHtCapabilityLen,
+				    OUT UCHAR * pPreNHtCapabilityLen,
+				    OUT HT_CAPABILITY_IE * pHtCapability,
+				    OUT UCHAR * AddHtInfoLen,
+				    OUT ADD_HT_INFO_IE * AddHtInfo,
+				    OUT UCHAR * NewExtChannel,
+				    OUT USHORT * LengthVIE,
+				    OUT PNDIS_802_11_VARIABLE_IEs pVIE);
+
+BOOLEAN PeerAddBAReqActionSanity(IN PRTMP_ADAPTER pAd,
+				 IN VOID * pMsg,
+				 IN ULONG MsgLen, OUT PUCHAR pAddr2);
+
+BOOLEAN PeerAddBARspActionSanity(IN PRTMP_ADAPTER pAd,
+				 IN VOID * pMsg, IN ULONG MsgLen);
+
+BOOLEAN PeerDelBAActionSanity(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR Wcid, IN VOID * pMsg, IN ULONG MsgLen);
+
+BOOLEAN MlmeAssocReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg,
+			   IN ULONG MsgLen,
+			   OUT PUCHAR pApAddr,
+			   OUT USHORT * CapabilityInfo,
+			   OUT ULONG * Timeout, OUT USHORT * ListenIntv);
+
+BOOLEAN MlmeAuthReqSanity(IN PRTMP_ADAPTER pAd,
+			  IN VOID * Msg,
+			  IN ULONG MsgLen,
+			  OUT PUCHAR pAddr,
+			  OUT ULONG * Timeout, OUT USHORT * Alg);
+
+BOOLEAN MlmeStartReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg,
+			   IN ULONG MsgLen,
+			   OUT CHAR Ssid[], OUT UCHAR * Ssidlen);
+
+BOOLEAN PeerAuthSanity(IN PRTMP_ADAPTER pAd,
+		       IN VOID * Msg,
+		       IN ULONG MsgLen,
+		       OUT PUCHAR pAddr,
+		       OUT USHORT * Alg,
+		       OUT USHORT * Seq,
+		       OUT USHORT * Status, OUT CHAR ChlgText[]);
+
+BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen, OUT PUCHAR pAddr2, OUT USHORT * pCapabilityInfo, OUT USHORT * pStatus, OUT USHORT * pAid, OUT UCHAR SupRate[], OUT UCHAR * pSupRateLen, OUT UCHAR ExtRate[], OUT UCHAR * pExtRateLen, OUT HT_CAPABILITY_IE * pHtCapability, OUT ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+			   OUT UCHAR * pHtCapabilityLen,
+			   OUT UCHAR * pAddHtInfoLen,
+			   OUT UCHAR * pNewExtChannelOffset,
+			   OUT PEDCA_PARM pEdcaParm, OUT UCHAR * pCkipFlag);
+
+BOOLEAN PeerDisassocSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg,
+			   IN ULONG MsgLen,
+			   OUT PUCHAR pAddr2, OUT USHORT * Reason);
+
+BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
+			     IN PEAPOL_PACKET pMsg,
+			     IN ULONG MsgLen,
+			     IN UCHAR MsgType, IN MAC_TABLE_ENTRY * pEntry);
+
+BOOLEAN PeerDeauthSanity(IN PRTMP_ADAPTER pAd,
+			 IN VOID * Msg,
+			 IN ULONG MsgLen,
+			 OUT PUCHAR pAddr2, OUT USHORT * Reason);
+
+BOOLEAN PeerProbeReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg,
+			   IN ULONG MsgLen,
+			   OUT PUCHAR pAddr2,
+			   OUT CHAR Ssid[], OUT UCHAR * pSsidLen);
+
+BOOLEAN GetTimBit(IN CHAR * Ptr,
+		  IN USHORT Aid,
+		  OUT UCHAR * TimLen,
+		  OUT UCHAR * BcastFlag,
+		  OUT UCHAR * DtimCount,
+		  OUT UCHAR * DtimPeriod, OUT UCHAR * MessageToMe);
+
+UCHAR ChannelSanity(IN PRTMP_ADAPTER pAd, IN UCHAR channel);
+
+NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(IN PBSS_ENTRY pBss);
+
+BOOLEAN MlmeDelBAReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg, IN ULONG MsgLen);
+
+BOOLEAN MlmeAddBAReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg, IN ULONG MsgLen, OUT PUCHAR pAddr2);
+
+ULONG MakeOutgoingFrame(OUT UCHAR * Buffer, OUT ULONG * Length, ...);
+
+VOID LfsrInit(IN PRTMP_ADAPTER pAd, IN ULONG Seed);
+
+UCHAR RandomByte(IN PRTMP_ADAPTER pAd);
+
+VOID AsicUpdateAutoFallBackTable(IN PRTMP_ADAPTER pAd, IN PUCHAR pTxRate);
+
+VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
+		      IN PVOID FunctionContext,
+		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID LinkDownExec(IN PVOID SystemSpecific1,
+		  IN PVOID FunctionContext,
+		  IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd);
+
+VOID MlmeAutoScan(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeAutoReconnectLastSSID(IN PRTMP_ADAPTER pAd);
+
+BOOLEAN MlmeValidateSSID(IN PUCHAR pSsid, IN UCHAR SsidLen);
+
+VOID MlmeCheckForRoaming(IN PRTMP_ADAPTER pAd, IN ULONG Now32);
+
+BOOLEAN MlmeCheckForFastRoaming(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeSetTxRate(IN PRTMP_ADAPTER pAd,
+		   IN PMAC_TABLE_ENTRY pEntry, IN PRTMP_TX_RATE_SWITCH pTxRate);
+
+VOID MlmeSelectTxRateTable(IN PRTMP_ADAPTER pAd,
+			   IN PMAC_TABLE_ENTRY pEntry,
+			   IN PUCHAR * ppTable,
+			   IN PUCHAR pTableSize, IN PUCHAR pInitTxRateIdx);
+
+VOID MlmeCalculateChannelQuality(IN PRTMP_ADAPTER pAd,
+				 IN PMAC_TABLE_ENTRY pMacEntry, IN ULONG Now);
+
+VOID MlmeCheckPsmChange(IN PRTMP_ADAPTER pAd, IN ULONG Now32);
+
+VOID MlmeSetPsmBit(IN PRTMP_ADAPTER pAd, IN USHORT psm);
+
+VOID MlmeSetTxPreamble(IN PRTMP_ADAPTER pAd, IN USHORT TxPreamble);
+
+VOID UpdateBasicRateBitmap(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd,
+		       IN BOOLEAN bLinkUp, IN UCHAR apidx);
+
+VOID MlmeUpdateHtTxRates(IN PRTMP_ADAPTER pAd, IN UCHAR apidx);
+
+VOID RTMPCheckRates(IN PRTMP_ADAPTER pAd,
+		    IN OUT UCHAR SupRate[], IN OUT UCHAR * SupRateLen);
+
+BOOLEAN RTMPCheckChannel(IN PRTMP_ADAPTER pAd,
+			 IN UCHAR CentralChannel, IN UCHAR Channel);
+
+BOOLEAN RTMPCheckHt(IN PRTMP_ADAPTER pAd,
+		    IN UCHAR Wcid,
+		    IN OUT HT_CAPABILITY_IE * pHtCapability,
+		    IN OUT ADD_HT_INFO_IE * pAddHtInfo);
+
+VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
+				  IN PVOID FunctionContext,
+				  IN PVOID SystemSpecific2,
+				  IN PVOID SystemSpecific3);
+
+VOID RTMPUpdateMlmeRate(IN PRTMP_ADAPTER pAd);
+
+CHAR RTMPMaxRssi(IN PRTMP_ADAPTER pAd,
+		 IN CHAR Rssi0, IN CHAR Rssi1, IN CHAR Rssi2);
+
+#ifdef RT30xx
+VOID AsicSetRxAnt(IN PRTMP_ADAPTER pAd, IN UCHAR Ant);
+
+VOID RTMPFilterCalibration(IN PRTMP_ADAPTER pAd);
+
+#ifdef RTMP_EFUSE_SUPPORT
+//2008/09/11:KH add to support efuse<--
+INT set_eFuseGetFreeBlockCount_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg);
+
+INT set_eFusedump_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg);
+
+VOID eFusePhysicalReadRegisters(IN PRTMP_ADAPTER pAd,
+				IN USHORT Offset,
+				IN USHORT Length, OUT USHORT * pData);
+
+int RtmpEfuseSupportCheck(IN RTMP_ADAPTER * pAd);
+
+VOID eFuseGetFreeBlockCount(IN PRTMP_ADAPTER pAd, PUINT EfuseFreeBlock);
+
+INT eFuse_init(IN PRTMP_ADAPTER pAd);
+//2008/09/11:KH add to support efuse-->
+#endif // RTMP_EFUSE_SUPPORT //
+
+// add by johnli, RF power sequence setup
+VOID RT30xxLoadRFNormalModeSetup(IN PRTMP_ADAPTER pAd);
+
+VOID RT30xxLoadRFSleepModeSetup(IN PRTMP_ADAPTER pAd);
+
+VOID RT30xxReverseRFSleepModeSetup(IN PRTMP_ADAPTER pAd);
+// end johnli
+
+#ifdef RT3070
+VOID NICInitRT3070RFRegisters(IN RTMP_ADAPTER * pAd);
+#endif // RT3070 //
+#ifdef RT3090
+VOID NICInitRT3090RFRegisters(IN RTMP_ADAPTER * pAd);
+#endif // RT3090 //
+
+VOID RT30xxHaltAction(IN PRTMP_ADAPTER pAd);
+
+VOID RT30xxSetRxAnt(IN PRTMP_ADAPTER pAd, IN UCHAR Ant);
+#endif // RT30xx //
+
+VOID AsicEvaluateRxAnt(IN PRTMP_ADAPTER pAd);
+
+VOID AsicRxAntEvalTimeout(IN PVOID SystemSpecific1,
+			  IN PVOID FunctionContext,
+			  IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID APSDPeriodicExec(IN PVOID SystemSpecific1,
+		      IN PVOID FunctionContext,
+		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+BOOLEAN RTMPCheckEntryEnableAutoRateSwitch(IN PRTMP_ADAPTER pAd,
+					   IN PMAC_TABLE_ENTRY pEntry);
+
+UCHAR RTMPStaFixedTxMode(IN PRTMP_ADAPTER pAd, IN PMAC_TABLE_ENTRY pEntry);
+
+VOID RTMPUpdateLegacyTxSetting(UCHAR fixed_tx_mode, PMAC_TABLE_ENTRY pEntry);
+
+BOOLEAN RTMPAutoRateSwitchCheck(IN PRTMP_ADAPTER pAd);
+
+NDIS_STATUS MlmeInit(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeHandler(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeHalt(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeResetRalinkCounters(IN PRTMP_ADAPTER pAd);
+
+VOID BuildChannelList(IN PRTMP_ADAPTER pAd);
+
+UCHAR FirstChannel(IN PRTMP_ADAPTER pAd);
+
+UCHAR NextChannel(IN PRTMP_ADAPTER pAd, IN UCHAR channel);
+
+VOID ChangeToCellPowerLimit(IN PRTMP_ADAPTER pAd,
+			    IN UCHAR AironetCellPowerLimit);
+
+//
+// Prototypes of function definition in rtmp_tkip.c
+//
+VOID RTMPInitTkipEngine(IN PRTMP_ADAPTER pAd,
+			IN PUCHAR pTKey,
+			IN UCHAR KeyId,
+			IN PUCHAR pTA,
+			IN PUCHAR pMICKey,
+			IN PUCHAR pTSC, OUT PULONG pIV16, OUT PULONG pIV32);
+
+VOID RTMPInitMICEngine(IN PRTMP_ADAPTER pAd,
+		       IN PUCHAR pKey,
+		       IN PUCHAR pDA,
+		       IN PUCHAR pSA, IN UCHAR UserPriority, IN PUCHAR pMICKey);
+
+BOOLEAN RTMPTkipCompareMICValue(IN PRTMP_ADAPTER pAd,
+				IN PUCHAR pSrc,
+				IN PUCHAR pDA,
+				IN PUCHAR pSA,
+				IN PUCHAR pMICKey,
+				IN UCHAR UserPriority, IN UINT Len);
+
+VOID RTMPCalculateMICValue(IN PRTMP_ADAPTER pAd,
+			   IN PNDIS_PACKET pPacket,
+			   IN PUCHAR pEncap,
+			   IN PCIPHER_KEY pKey, IN UCHAR apidx);
+
+VOID RTMPTkipAppendByte(IN PTKIP_KEY_INFO pTkip, IN UCHAR uChar);
+
+VOID RTMPTkipAppend(IN PTKIP_KEY_INFO pTkip, IN PUCHAR pSrc, IN UINT nBytes);
+
+VOID RTMPTkipGetMIC(IN PTKIP_KEY_INFO pTkip);
+
+BOOLEAN RTMPSoftDecryptTKIP(IN PRTMP_ADAPTER pAd,
+			    IN PUCHAR pData,
+			    IN ULONG DataByteCnt,
+			    IN UCHAR UserPriority, IN PCIPHER_KEY pWpaKey);
+
+BOOLEAN RTMPSoftDecryptAES(IN PRTMP_ADAPTER pAd,
+			   IN PUCHAR pData,
+			   IN ULONG DataByteCnt, IN PCIPHER_KEY pWpaKey);
+
+//
+// Prototypes of function definition in cmm_info.c
+//
+INT RT_CfgSetCountryRegion(IN PRTMP_ADAPTER pAd, IN PSTRING arg, IN INT band);
+
+INT RT_CfgSetWirelessMode(IN PRTMP_ADAPTER pAd, IN PSTRING arg);
+
+INT RT_CfgSetShortSlot(IN PRTMP_ADAPTER pAd, IN PSTRING arg);
+
+INT RT_CfgSetWepKey(IN PRTMP_ADAPTER pAd,
+		    IN PSTRING keyString,
+		    IN CIPHER_KEY * pSharedKey, IN INT keyIdx);
+
+INT RT_CfgSetWPAPSKKey(IN RTMP_ADAPTER * pAd,
+		       IN PSTRING keyString,
+		       IN UCHAR * pHashStr,
+		       IN INT hashStrLen, OUT PUCHAR pPMKBuf);
+
+//
+// Prototypes of function definition in cmm_info.c
+//
+VOID RTMPWPARemoveAllKeys(IN PRTMP_ADAPTER pAd);
+
+VOID RTMPSetPhyMode(IN PRTMP_ADAPTER pAd, IN ULONG phymode);
+
+VOID RTMPUpdateHTIE(IN RT_HT_CAPABILITY * pRtHt,
+		    IN UCHAR * pMcsSet,
+		    OUT HT_CAPABILITY_IE * pHtCapability,
+		    OUT ADD_HT_INFO_IE * pAddHtInfo);
+
+VOID RTMPAddWcidAttributeEntry(IN PRTMP_ADAPTER pAd,
+			       IN UCHAR BssIdx,
+			       IN UCHAR KeyIdx,
+			       IN UCHAR CipherAlg, IN MAC_TABLE_ENTRY * pEntry);
+
+PSTRING GetEncryptType(CHAR enc);
+
+PSTRING GetAuthMode(CHAR auth);
+
+VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode);
+
+VOID RTMPSetIndividualHT(IN PRTMP_ADAPTER pAd, IN UCHAR apidx);
+
+VOID RTMPSendWirelessEvent(IN PRTMP_ADAPTER pAd,
+			   IN USHORT Event_flag,
+			   IN PUCHAR pAddr, IN UCHAR BssIdx, IN CHAR Rssi);
+
+CHAR ConvertToRssi(IN PRTMP_ADAPTER pAd, IN CHAR Rssi, IN UCHAR RssiNumber);
+
+/*===================================
+	Function prototype in cmm_wpa.c
+  =================================== */
+VOID RTMPToWirelessSta(IN PRTMP_ADAPTER pAd,
+		       IN PMAC_TABLE_ENTRY pEntry,
+		       IN PUCHAR pHeader802_3,
+		       IN UINT HdrLen,
+		       IN PUCHAR pData,
+		       IN UINT DataLen, IN BOOLEAN bClearFrame);
+
+VOID WpaDerivePTK(IN PRTMP_ADAPTER pAd,
+		  IN UCHAR * PMK,
+		  IN UCHAR * ANonce,
+		  IN UCHAR * AA,
+		  IN UCHAR * SNonce,
+		  IN UCHAR * SA, OUT UCHAR * output, IN UINT len);
+
+VOID GenRandom(IN PRTMP_ADAPTER pAd, IN UCHAR * macAddr, OUT UCHAR * random);
+
+BOOLEAN RTMPCheckWPAframe(IN PRTMP_ADAPTER pAd,
+			  IN PMAC_TABLE_ENTRY pEntry,
+			  IN PUCHAR pData,
+			  IN ULONG DataByteCount, IN UCHAR FromWhichBSSID);
+
+VOID AES_GTK_KEY_UNWRAP(IN UCHAR * key,
+			OUT UCHAR * plaintext,
+			IN UINT32 c_len, IN UCHAR * ciphertext);
+
+BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
+			      IN PUCHAR pKeyData,
+			      IN UCHAR KeyDataLen,
+			      IN UCHAR GroupKeyIndex,
+			      IN UCHAR MsgType,
+			      IN BOOLEAN bWPA2, IN MAC_TABLE_ENTRY * pEntry);
+
+VOID ConstructEapolMsg(IN PMAC_TABLE_ENTRY pEntry,
+		       IN UCHAR GroupKeyWepStatus,
+		       IN UCHAR MsgType,
+		       IN UCHAR DefaultKeyIdx,
+		       IN UCHAR * KeyNonce,
+		       IN UCHAR * TxRSC,
+		       IN UCHAR * GTK,
+		       IN UCHAR * RSNIE,
+		       IN UCHAR RSNIE_Len, OUT PEAPOL_PACKET pMsg);
+
+NDIS_STATUS RTMPSoftDecryptBroadCastData(IN PRTMP_ADAPTER pAd,
+					 IN RX_BLK * pRxBlk,
+					 IN NDIS_802_11_ENCRYPTION_STATUS
+					 GroupCipher,
+					 IN PCIPHER_KEY pShard_key);
+
+VOID RTMPMakeRSNIE(IN PRTMP_ADAPTER pAd,
+		   IN UINT AuthMode, IN UINT WepStatus, IN UCHAR apidx);
+
+//
+// function prototype in ap_wpa.c
+//
+VOID RTMPGetTxTscFromAsic(IN PRTMP_ADAPTER pAd,
+			  IN UCHAR apidx, OUT PUCHAR pTxTsc);
+
+VOID APInstallPairwiseKey(PRTMP_ADAPTER pAd, PMAC_TABLE_ENTRY pEntry);
+
+UINT APValidateRSNIE(IN PRTMP_ADAPTER pAd,
+		     IN PMAC_TABLE_ENTRY pEntry,
+		     IN PUCHAR pRsnIe, IN UCHAR rsnie_len);
+
+VOID HandleCounterMeasure(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry);
+
+VOID WPAStart4WayHS(IN PRTMP_ADAPTER pAd,
+		    IN MAC_TABLE_ENTRY * pEntry, IN ULONG TimeInterval);
+
+VOID WPAStart2WayGroupHS(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry);
+
+VOID PeerPairMsg1Action(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerPairMsg2Action(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerPairMsg4Action(IN PRTMP_ADAPTER pAd,
+			IN MAC_TABLE_ENTRY * pEntry, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerGroupMsg1Action(IN PRTMP_ADAPTER pAd,
+			 IN PMAC_TABLE_ENTRY pEntry, IN MLME_QUEUE_ELEM * Elem);
+
+VOID PeerGroupMsg2Action(IN PRTMP_ADAPTER pAd,
+			 IN PMAC_TABLE_ENTRY pEntry,
+			 IN VOID * Msg, IN UINT MsgLen);
+
+VOID WpaDeriveGTK(IN UCHAR * PMK,
+		  IN UCHAR * GNonce,
+		  IN UCHAR * AA, OUT UCHAR * output, IN UINT len);
+
+VOID AES_GTK_KEY_WRAP(IN UCHAR * key,
+		      IN UCHAR * plaintext,
+		      IN UINT32 p_len, OUT UCHAR * ciphertext);
+
+//typedef void (*TIMER_FUNCTION)(unsigned long);
+
+/* timeout -- ms */
+VOID RTMP_SetPeriodicTimer(IN NDIS_MINIPORT_TIMER * pTimer,
+			   IN unsigned long timeout);
+
+VOID RTMP_OS_Init_Timer(IN PRTMP_ADAPTER pAd,
+			IN NDIS_MINIPORT_TIMER * pTimer,
+			IN TIMER_FUNCTION function, IN PVOID data);
+
+VOID RTMP_OS_Add_Timer(IN NDIS_MINIPORT_TIMER * pTimer,
+		       IN unsigned long timeout);
+
+VOID RTMP_OS_Mod_Timer(IN NDIS_MINIPORT_TIMER * pTimer,
+		       IN unsigned long timeout);
+
+VOID RTMP_OS_Del_Timer(IN NDIS_MINIPORT_TIMER * pTimer,
+		       OUT BOOLEAN * pCancelled);
+
+VOID RTMP_OS_Release_Packet(IN PRTMP_ADAPTER pAd, IN PQUEUE_ENTRY pEntry);
+
+VOID RTMPusecDelay(IN ULONG usec);
+
+NDIS_STATUS os_alloc_mem(IN RTMP_ADAPTER * pAd,
+			 OUT UCHAR ** mem, IN ULONG size);
+
+NDIS_STATUS os_free_mem(IN PRTMP_ADAPTER pAd, IN PVOID mem);
+
+void RTMP_AllocateSharedMemory(IN PRTMP_ADAPTER pAd,
+			       IN ULONG Length,
+			       IN BOOLEAN Cached,
+			       OUT PVOID * VirtualAddress,
+			       OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
+
+VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd);
+
+NDIS_STATUS AdapterBlockAllocateMemory(IN PVOID handle, OUT PVOID * ppAd);
+
+void RTMP_AllocateTxDescMemory(IN PRTMP_ADAPTER pAd,
+			       IN UINT Index,
+			       IN ULONG Length,
+			       IN BOOLEAN Cached,
+			       OUT PVOID * VirtualAddress,
+			       OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
+
+void RTMP_AllocateFirstTxBuffer(IN PRTMP_ADAPTER pAd,
+				IN UINT Index,
+				IN ULONG Length,
+				IN BOOLEAN Cached,
+				OUT PVOID * VirtualAddress,
+				OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
+
+void RTMP_FreeFirstTxBuffer(IN PRTMP_ADAPTER pAd,
+			    IN ULONG Length,
+			    IN BOOLEAN Cached,
+			    IN PVOID VirtualAddress,
+			    IN NDIS_PHYSICAL_ADDRESS PhysicalAddress);
+
+void RTMP_AllocateMgmtDescMemory(IN PRTMP_ADAPTER pAd,
+				 IN ULONG Length,
+				 IN BOOLEAN Cached,
+				 OUT PVOID * VirtualAddress,
+				 OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
+
+void RTMP_AllocateRxDescMemory(IN PRTMP_ADAPTER pAd,
+			       IN ULONG Length,
+			       IN BOOLEAN Cached,
+			       OUT PVOID * VirtualAddress,
+			       OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress);
+
+void RTMP_FreeDescMemory(IN PRTMP_ADAPTER pAd,
+			 IN ULONG Length,
+			 IN PVOID VirtualAddress,
+			 IN NDIS_PHYSICAL_ADDRESS PhysicalAddress);
+
+PNDIS_PACKET RtmpOSNetPktAlloc(IN RTMP_ADAPTER * pAd, IN int size);
+
+PNDIS_PACKET RTMP_AllocateRxPacketBuffer(IN PRTMP_ADAPTER pAd,
+					 IN ULONG Length,
+					 IN BOOLEAN Cached,
+					 OUT PVOID * VirtualAddress,
+					 OUT PNDIS_PHYSICAL_ADDRESS
+					 PhysicalAddress);
+
+PNDIS_PACKET RTMP_AllocateTxPacketBuffer(IN PRTMP_ADAPTER pAd,
+					 IN ULONG Length,
+					 IN BOOLEAN Cached,
+					 OUT PVOID * VirtualAddress);
+
+PNDIS_PACKET RTMP_AllocateFragPacketBuffer(IN PRTMP_ADAPTER pAd,
+					   IN ULONG Length);
+
+void RTMP_QueryPacketInfo(IN PNDIS_PACKET pPacket,
+			  OUT PACKET_INFO * pPacketInfo,
+			  OUT PUCHAR * pSrcBufVA, OUT UINT * pSrcBufLen);
+
+void RTMP_QueryNextPacketInfo(IN PNDIS_PACKET * ppPacket,
+			      OUT PACKET_INFO * pPacketInfo,
+			      OUT PUCHAR * pSrcBufVA, OUT UINT * pSrcBufLen);
+
+BOOLEAN RTMP_FillTxBlkInfo(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk);
+
+PRTMP_SCATTER_GATHER_LIST
+rt_get_sg_list_from_packet(PNDIS_PACKET pPacket, RTMP_SCATTER_GATHER_LIST * sg);
+
+void announce_802_3_packet(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket);
+
+UINT BA_Reorder_AMSDU_Annnounce(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket);
+
+PNET_DEV get_netdev_from_bssid(IN PRTMP_ADAPTER pAd, IN UCHAR FromWhichBSSID);
+
+PNDIS_PACKET duplicate_pkt(IN PRTMP_ADAPTER pAd,
+			   IN PUCHAR pHeader802_3,
+			   IN UINT HdrLen,
+			   IN PUCHAR pData,
+			   IN ULONG DataSize, IN UCHAR FromWhichBSSID);
+
+PNDIS_PACKET duplicate_pkt_with_TKIP_MIC(IN PRTMP_ADAPTER pAd,
+					 IN PNDIS_PACKET pOldPkt);
+
+void ba_flush_reordering_timeout_mpdus(IN PRTMP_ADAPTER pAd,
+				       IN PBA_REC_ENTRY pBAEntry,
+				       IN ULONG Now32);
+
+VOID BAOriSessionSetUp(IN PRTMP_ADAPTER pAd,
+		       IN MAC_TABLE_ENTRY * pEntry,
+		       IN UCHAR TID,
+		       IN USHORT TimeOut,
+		       IN ULONG DelayTime, IN BOOLEAN isForced);
+
+VOID BASessionTearDownALL(IN OUT PRTMP_ADAPTER pAd, IN UCHAR Wcid);
+
+BOOLEAN OS_Need_Clone_Packet(void);
+
+VOID build_tx_packet(IN PRTMP_ADAPTER pAd,
+		     IN PNDIS_PACKET pPacket,
+		     IN PUCHAR pFrame, IN ULONG FrameLen);
+
+VOID BAOriSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
+			  IN UCHAR Wcid,
+			  IN UCHAR TID,
+			  IN BOOLEAN bPassive, IN BOOLEAN bForceSend);
+
+VOID BARecSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
+			  IN UCHAR Wcid, IN UCHAR TID, IN BOOLEAN bPassive);
+
+BOOLEAN ba_reordering_resource_init(PRTMP_ADAPTER pAd, int num);
+void ba_reordering_resource_release(PRTMP_ADAPTER pAd);
+
+PSTRING rstrtok(IN PSTRING s, IN const PSTRING ct);
+
+////////// common ioctl functions //////////
+INT SetCommonHT(IN PRTMP_ADAPTER pAd);
+
+INT WpaCheckEapCode(IN PRTMP_ADAPTER pAd,
+		    IN PUCHAR pFrame, IN USHORT FrameLen, IN USHORT OffSet);
+
+VOID WpaSendMicFailureToWpaSupplicant(IN PRTMP_ADAPTER pAd,
+				      IN BOOLEAN bUnicast);
+
+int wext_notify_event_assoc(IN RTMP_ADAPTER * pAd);
+
+BOOLEAN STARxDoneInterruptHandle(IN PRTMP_ADAPTER pAd, IN BOOLEAN argc);
+
+// AMPDU packet indication
+VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
+			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID);
+
+// AMSDU packet indication
+VOID Indicate_AMSDU_Packet(IN PRTMP_ADAPTER pAd,
+			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID);
+
+// Normal legacy Rx packet indication
+VOID Indicate_Legacy_Packet(IN PRTMP_ADAPTER pAd,
+			    IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID);
+
+VOID Indicate_EAPOL_Packet(IN PRTMP_ADAPTER pAd,
+			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID);
+
+void update_os_packet_info(IN PRTMP_ADAPTER pAd,
+			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID);
+
+void wlan_802_11_to_802_3_packet(IN PRTMP_ADAPTER pAd,
+				 IN RX_BLK * pRxBlk,
+				 IN PUCHAR pHeader802_3,
+				 IN UCHAR FromWhichBSSID);
+
+// remove LLC and get 802_3 Header
+#define  RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(_pRxBlk, _pHeader802_3)	\
+{																				\
+	PUCHAR _pRemovedLLCSNAP = NULL, _pDA, _pSA;                                 \
+																				\
+	if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_MESH))                                    \
+	{                                                                           \
+		_pDA = _pRxBlk->pHeader->Addr3;                                         \
+		_pSA = (PUCHAR)_pRxBlk->pHeader + sizeof(HEADER_802_11);                \
+	}                                                                           \
+	else                                                                        \
+	{                                                                           \
+		if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_INFRA))                              	\
+		{                                                                       \
+			_pDA = _pRxBlk->pHeader->Addr1;                                     \
+		if (RX_BLK_TEST_FLAG(_pRxBlk, fRX_DLS))									\
+			_pSA = _pRxBlk->pHeader->Addr2;										\
+		else																	\
+			_pSA = _pRxBlk->pHeader->Addr3;                                     \
+		}                                                                       \
+		else                                                                    \
+		{                                                                       \
+			_pDA = _pRxBlk->pHeader->Addr1;                                     \
+			_pSA = _pRxBlk->pHeader->Addr2;                                     \
+		}                                                                       \
+	}                                                                           \
+																				\
+	CONVERT_TO_802_3(_pHeader802_3, _pDA, _pSA, _pRxBlk->pData, 				\
+		_pRxBlk->DataSize, _pRemovedLLCSNAP);                                   \
+}
+
+VOID Sta_Announce_or_Forward_802_3_Packet(IN PRTMP_ADAPTER pAd,
+					  IN PNDIS_PACKET pPacket,
+					  IN UCHAR FromWhichBSSID);
+
+#define ANNOUNCE_OR_FORWARD_802_3_PACKET(_pAd, _pPacket, _FromWhichBSS)\
+			Sta_Announce_or_Forward_802_3_Packet(_pAd, _pPacket, _FromWhichBSS);
+			//announce_802_3_packet(_pAd, _pPacket);
+
+PNDIS_PACKET DuplicatePacket(IN PRTMP_ADAPTER pAd,
+			     IN PNDIS_PACKET pPacket, IN UCHAR FromWhichBSSID);
+
+PNDIS_PACKET ClonePacket(IN PRTMP_ADAPTER pAd,
+			 IN PNDIS_PACKET pPacket,
+			 IN PUCHAR pData, IN ULONG DataSize);
+
+// Normal, AMPDU or AMSDU
+VOID CmmRxnonRalinkFrameIndicate(IN PRTMP_ADAPTER pAd,
+				 IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID);
+
+VOID CmmRxRalinkFrameIndicate(IN PRTMP_ADAPTER pAd,
+			      IN MAC_TABLE_ENTRY * pEntry,
+			      IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID);
+
+VOID Update_Rssi_Sample(IN PRTMP_ADAPTER pAd,
+			IN RSSI_SAMPLE * pRssi, IN PRXWI_STRUC pRxWI);
+
+PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
+				 OUT PRT28XX_RXD_STRUC pSaveRxD,
+				 OUT BOOLEAN * pbReschedule,
+				 IN OUT UINT32 * pRxPending);
+
+PNDIS_PACKET RTMPDeFragmentDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk);
+
+enum {
+	DIDmsg_lnxind_wlansniffrm = 0x00000044,
+	DIDmsg_lnxind_wlansniffrm_hosttime = 0x00010044,
+	DIDmsg_lnxind_wlansniffrm_mactime = 0x00020044,
+	DIDmsg_lnxind_wlansniffrm_channel = 0x00030044,
+	DIDmsg_lnxind_wlansniffrm_rssi = 0x00040044,
+	DIDmsg_lnxind_wlansniffrm_sq = 0x00050044,
+	DIDmsg_lnxind_wlansniffrm_signal = 0x00060044,
+	DIDmsg_lnxind_wlansniffrm_noise = 0x00070044,
+	DIDmsg_lnxind_wlansniffrm_rate = 0x00080044,
+	DIDmsg_lnxind_wlansniffrm_istx = 0x00090044,
+	DIDmsg_lnxind_wlansniffrm_frmlen = 0x000A0044
 };
 enum {
-	P80211ENUM_truth_false			= 0x00,
-	P80211ENUM_truth_true			= 0x01
+	P80211ENUM_msgitem_status_no_value = 0x00
+};
+enum {
+	P80211ENUM_truth_false = 0x00,
+	P80211ENUM_truth_true = 0x01
 };
 
 /* Definition from madwifi */
 typedef struct {
-        UINT32 did;
-        UINT16 status;
-        UINT16 len;
-        UINT32 data;
+	UINT32 did;
+	UINT16 status;
+	UINT16 len;
+	UINT32 data;
 } p80211item_uint32_t;
 
 typedef struct {
-        UINT32 msgcode;
-        UINT32 msglen;
+	UINT32 msgcode;
+	UINT32 msglen;
 #define WLAN_DEVNAMELEN_MAX 16
-        UINT8 devname[WLAN_DEVNAMELEN_MAX];
-        p80211item_uint32_t hosttime;
-        p80211item_uint32_t mactime;
-        p80211item_uint32_t channel;
-        p80211item_uint32_t rssi;
-        p80211item_uint32_t sq;
-        p80211item_uint32_t signal;
-        p80211item_uint32_t noise;
-        p80211item_uint32_t rate;
-        p80211item_uint32_t istx;
-        p80211item_uint32_t frmlen;
+	UINT8 devname[WLAN_DEVNAMELEN_MAX];
+	p80211item_uint32_t hosttime;
+	p80211item_uint32_t mactime;
+	p80211item_uint32_t channel;
+	p80211item_uint32_t rssi;
+	p80211item_uint32_t sq;
+	p80211item_uint32_t signal;
+	p80211item_uint32_t noise;
+	p80211item_uint32_t rate;
+	p80211item_uint32_t istx;
+	p80211item_uint32_t frmlen;
 } wlan_ng_prism2_header;
 
 /* The radio capture header precedes the 802.11 header. */
 typedef struct PACKED _ieee80211_radiotap_header {
-    UINT8	it_version;	/* Version 0. Only increases
+	UINT8 it_version;	/* Version 0. Only increases
 				 * for drastic changes,
 				 * introduction of compatible
 				 * new fields does not count.
 				 */
-    UINT8	it_pad;
-    UINT16     it_len;         /* length of the whole
+	UINT8 it_pad;
+	UINT16 it_len;		/* length of the whole
 				 * header in bytes, including
 				 * it_version, it_pad,
 				 * it_len, and data fields.
 				 */
-    UINT32   it_present;	/* A bitmap telling which
-					 * fields are present. Set bit 31
-					 * (0x80000000) to extend the
-					 * bitmap by another 32 bits.
-					 * Additional extensions are made
-					 * by setting bit 31.
-					 */
-}ieee80211_radiotap_header ;
+	UINT32 it_present;	/* A bitmap telling which
+				 * fields are present. Set bit 31
+				 * (0x80000000) to extend the
+				 * bitmap by another 32 bits.
+				 * Additional extensions are made
+				 * by setting bit 31.
+				 */
+} ieee80211_radiotap_header;
 
 enum ieee80211_radiotap_type {
-    IEEE80211_RADIOTAP_TSFT = 0,
-    IEEE80211_RADIOTAP_FLAGS = 1,
-    IEEE80211_RADIOTAP_RATE = 2,
-    IEEE80211_RADIOTAP_CHANNEL = 3,
-    IEEE80211_RADIOTAP_FHSS = 4,
-    IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
-    IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
-    IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
-    IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
-    IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
-    IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
-    IEEE80211_RADIOTAP_ANTENNA = 11,
-    IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
-    IEEE80211_RADIOTAP_DB_ANTNOISE = 13
+	IEEE80211_RADIOTAP_TSFT = 0,
+	IEEE80211_RADIOTAP_FLAGS = 1,
+	IEEE80211_RADIOTAP_RATE = 2,
+	IEEE80211_RADIOTAP_CHANNEL = 3,
+	IEEE80211_RADIOTAP_FHSS = 4,
+	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
+	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
+	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
+	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
+	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
+	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
+	IEEE80211_RADIOTAP_ANTENNA = 11,
+	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
+	IEEE80211_RADIOTAP_DB_ANTNOISE = 13
 };
 
 #define WLAN_RADIOTAP_PRESENT (			\
@@ -4842,623 +3874,411 @@ typedef struct _wlan_radiotap_header {
 } wlan_radiotap_header;
 /* Definition from madwifi */
 
-void send_monitor_packets(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk);
-
+void send_monitor_packets(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk);
 
-VOID    RTMPSetDesiredRates(
-    IN  PRTMP_ADAPTER   pAdapter,
-    IN  LONG            Rates);
+VOID RTMPSetDesiredRates(IN PRTMP_ADAPTER pAdapter, IN LONG Rates);
 
-INT	Set_FixedTxMode_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg);
+INT Set_FixedTxMode_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg);
 
-BOOLEAN RT28XXChipsetCheck(
-	IN void *_dev_p);
+BOOLEAN RT28XXChipsetCheck(IN void *_dev_p);
 
+VOID RT28XXDMADisable(IN RTMP_ADAPTER * pAd);
 
-VOID RT28XXDMADisable(
-	IN RTMP_ADAPTER 		*pAd);
+VOID RT28XXDMAEnable(IN RTMP_ADAPTER * pAd);
 
-VOID RT28XXDMAEnable(
-	IN RTMP_ADAPTER 		*pAd);
+VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
+			       IN INT apidx,
+			       IN ULONG BeaconLen, IN ULONG UpdatePos);
 
-VOID RT28xx_UpdateBeaconToAsic(
-	IN RTMP_ADAPTER * pAd,
-	IN INT apidx,
-	IN ULONG BeaconLen,
-	IN ULONG UpdatePos);
+int rt28xx_init(IN PRTMP_ADAPTER pAd,
+		IN PSTRING pDefaultMac, IN PSTRING pHostName);
 
-int rt28xx_init(
-	IN		PRTMP_ADAPTER	pAd,
-	IN PSTRING pDefaultMac,
-	IN PSTRING pHostName);
+NDIS_STATUS RtmpNetTaskInit(IN RTMP_ADAPTER * pAd);
 
-NDIS_STATUS RtmpNetTaskInit(
-	IN RTMP_ADAPTER *pAd);
+VOID RtmpNetTaskExit(IN PRTMP_ADAPTER pAd);
 
-VOID RtmpNetTaskExit(
-	IN PRTMP_ADAPTER pAd);
+NDIS_STATUS RtmpMgmtTaskInit(IN RTMP_ADAPTER * pAd);
 
-NDIS_STATUS RtmpMgmtTaskInit(
-	IN RTMP_ADAPTER *pAd);
-
-VOID RtmpMgmtTaskExit(
-	IN RTMP_ADAPTER *pAd);
+VOID RtmpMgmtTaskExit(IN RTMP_ADAPTER * pAd);
 
 void tbtt_tasklet(unsigned long data);
 
+PNET_DEV RtmpPhyNetDevInit(IN RTMP_ADAPTER * pAd,
+			   IN RTMP_OS_NETDEV_OP_HOOK * pNetHook);
 
-PNET_DEV RtmpPhyNetDevInit(
-	IN RTMP_ADAPTER *pAd,
-	IN RTMP_OS_NETDEV_OP_HOOK *pNetHook);
-
-BOOLEAN RtmpPhyNetDevExit(
-	IN RTMP_ADAPTER *pAd,
-	IN PNET_DEV net_dev);
-
-INT RtmpRaDevCtrlInit(
-	IN RTMP_ADAPTER *pAd,
-	IN RTMP_INF_TYPE infType);
+BOOLEAN RtmpPhyNetDevExit(IN RTMP_ADAPTER * pAd, IN PNET_DEV net_dev);
 
-BOOLEAN RtmpRaDevCtrlExit(
-	IN RTMP_ADAPTER *pAd);
+INT RtmpRaDevCtrlInit(IN RTMP_ADAPTER * pAd, IN RTMP_INF_TYPE infType);
 
+BOOLEAN RtmpRaDevCtrlExit(IN RTMP_ADAPTER * pAd);
 
 #ifdef RTMP_MAC_PCI
 //
 // Function Prototype in cmm_data_pci.c
 //
-USHORT RtmpPCI_WriteTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber);
-
-USHORT RtmpPCI_WriteSingleTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber);
-
-USHORT RtmpPCI_WriteMultiTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			frameNum,
-	OUT	USHORT			*FreeNumber);
-
-USHORT	RtmpPCI_WriteFragTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			fragNum,
-	OUT	USHORT			*FreeNumber);
-
-USHORT RtmpPCI_WriteSubTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber);
-
-VOID RtmpPCI_FinalWriteTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	USHORT			totalMPDUSize,
-	IN	USHORT			FirstTxIdx);
-
-VOID RtmpPCIDataLastTxIdx(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			QueIdx,
-	IN	USHORT			LastTxIdx);
-
-VOID RtmpPCIDataKickOut(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			QueIdx);
-
-
-int RtmpPCIMgmtKickOut(
-	IN RTMP_ADAPTER 	*pAd,
-	IN UCHAR 			QueIdx,
-	IN PNDIS_PACKET		pPacket,
-	IN PUCHAR			pSrcBufVA,
-	IN UINT 			SrcBufLen);
-
-
-NDIS_STATUS RTMPCheckRxError(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PHEADER_802_11  pHeader,
-	IN	PRXWI_STRUC	pRxWI,
-	IN  PRT28XX_RXD_STRUC      pRxD);
-
-BOOLEAN RT28xxPciAsicRadioOff(
-	IN PRTMP_ADAPTER    pAd,
-	IN UCHAR            Level,
-	IN USHORT           TbttNumToNextWakeUp);
-
-BOOLEAN RT28xxPciAsicRadioOn(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR     Level);
-
-VOID RTMPInitPCIeLinkCtrlValue(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID RTMPFindHostPCIDev(
-    IN	PRTMP_ADAPTER	pAd);
-
-VOID RTMPPCIeLinkCtrlValueRestore(
-	IN	PRTMP_ADAPTER	pAd,
-	IN   UCHAR		Level);
-
-VOID RTMPPCIeLinkCtrlSetting(
-	IN	PRTMP_ADAPTER	pAd,
-	IN 	USHORT		Max);
-
-VOID RTMPrt3xSetPCIePowerLinkCtrl(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID PsPollWakeExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID  RadioOnExec(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID RT28xxPciStaAsicForceWakeup(
-	IN	PRTMP_ADAPTER	pAd,
-	IN BOOLEAN       bFromTx);
-
-VOID RT28xxPciStaAsicSleepThenAutoWakeup(
-	IN	PRTMP_ADAPTER	pAd,
-	IN USHORT TbttNumToNextWakeUp);
+USHORT RtmpPCI_WriteTxResource(IN PRTMP_ADAPTER pAd,
+			       IN TX_BLK * pTxBlk,
+			       IN BOOLEAN bIsLast, OUT USHORT * FreeNumber);
+
+USHORT RtmpPCI_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
+				     IN TX_BLK * pTxBlk,
+				     IN BOOLEAN bIsLast,
+				     OUT USHORT * FreeNumber);
+
+USHORT RtmpPCI_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
+				    IN TX_BLK * pTxBlk,
+				    IN UCHAR frameNum, OUT USHORT * FreeNumber);
+
+USHORT RtmpPCI_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
+				   IN TX_BLK * pTxBlk,
+				   IN UCHAR fragNum, OUT USHORT * FreeNumber);
+
+USHORT RtmpPCI_WriteSubTxResource(IN PRTMP_ADAPTER pAd,
+				  IN TX_BLK * pTxBlk,
+				  IN BOOLEAN bIsLast, OUT USHORT * FreeNumber);
+
+VOID RtmpPCI_FinalWriteTxResource(IN PRTMP_ADAPTER pAd,
+				  IN TX_BLK * pTxBlk,
+				  IN USHORT totalMPDUSize,
+				  IN USHORT FirstTxIdx);
+
+VOID RtmpPCIDataLastTxIdx(IN PRTMP_ADAPTER pAd,
+			  IN UCHAR QueIdx, IN USHORT LastTxIdx);
+
+VOID RtmpPCIDataKickOut(IN PRTMP_ADAPTER pAd,
+			IN TX_BLK * pTxBlk, IN UCHAR QueIdx);
+
+int RtmpPCIMgmtKickOut(IN RTMP_ADAPTER * pAd,
+		       IN UCHAR QueIdx,
+		       IN PNDIS_PACKET pPacket,
+		       IN PUCHAR pSrcBufVA, IN UINT SrcBufLen);
+
+NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
+			     IN PHEADER_802_11 pHeader,
+			     IN PRXWI_STRUC pRxWI, IN PRT28XX_RXD_STRUC pRxD);
 
+BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR Level, IN USHORT TbttNumToNextWakeUp);
 
-VOID RT28xxPciMlmeRadioOn(
-	IN PRTMP_ADAPTER 	pAd);
+BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level);
 
-VOID RT28xxPciMlmeRadioOFF(
-	IN PRTMP_ADAPTER 	pAd);
+VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_ADAPTER pAd);
+
+VOID RTMPFindHostPCIDev(IN PRTMP_ADAPTER pAd);
+
+VOID RTMPPCIeLinkCtrlValueRestore(IN PRTMP_ADAPTER pAd, IN UCHAR Level);
+
+VOID RTMPPCIeLinkCtrlSetting(IN PRTMP_ADAPTER pAd, IN USHORT Max);
+
+VOID RTMPrt3xSetPCIePowerLinkCtrl(IN PRTMP_ADAPTER pAd);
+
+VOID PsPollWakeExec(IN PVOID SystemSpecific1,
+		    IN PVOID FunctionContext,
+		    IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID RadioOnExec(IN PVOID SystemSpecific1,
+		 IN PVOID FunctionContext,
+		 IN PVOID SystemSpecific2, IN PVOID SystemSpecific3);
+
+VOID RT28xxPciStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx);
+
+VOID RT28xxPciStaAsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
+					 IN USHORT TbttNumToNextWakeUp);
+
+VOID RT28xxPciMlmeRadioOn(IN PRTMP_ADAPTER pAd);
+
+VOID RT28xxPciMlmeRadioOFF(IN PRTMP_ADAPTER pAd);
 #endif // RTMP_MAC_PCI //
 
 #ifdef RTMP_MAC_USB
 //
 // Function Prototype in rtusb_bulk.c
 //
-VOID	RTUSBInitTxDesc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PTX_CONTEXT		pTxContext,
-	IN	UCHAR			BulkOutPipeId,
-	IN	usb_complete_t	Func);
+VOID RTUSBInitTxDesc(IN PRTMP_ADAPTER pAd,
+		     IN PTX_CONTEXT pTxContext,
+		     IN UCHAR BulkOutPipeId, IN usb_complete_t Func);
 
-VOID	RTUSBInitHTTxDesc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PHT_TX_CONTEXT	pTxContext,
-	IN	UCHAR			BulkOutPipeId,
-	IN	ULONG			BulkOutSize,
-	IN	usb_complete_t	Func);
+VOID RTUSBInitHTTxDesc(IN PRTMP_ADAPTER pAd,
+		       IN PHT_TX_CONTEXT pTxContext,
+		       IN UCHAR BulkOutPipeId,
+		       IN ULONG BulkOutSize, IN usb_complete_t Func);
 
-VOID	RTUSBInitRxDesc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PRX_CONTEXT		pRxContext);
+VOID RTUSBInitRxDesc(IN PRTMP_ADAPTER pAd, IN PRX_CONTEXT pRxContext);
 
-VOID RTUSBCleanUpDataBulkOutQueue(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBCleanUpDataBulkOutQueue(IN PRTMP_ADAPTER pAd);
 
-VOID RTUSBCancelPendingBulkOutIRP(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBCancelPendingBulkOutIRP(IN PRTMP_ADAPTER pAd);
 
-VOID RTUSBBulkOutDataPacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			BulkOutPipeId,
-	IN	UCHAR			Index);
+VOID RTUSBBulkOutDataPacket(IN PRTMP_ADAPTER pAd,
+			    IN UCHAR BulkOutPipeId, IN UCHAR Index);
 
-VOID RTUSBBulkOutNullFrame(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBBulkOutNullFrame(IN PRTMP_ADAPTER pAd);
 
-VOID RTUSBBulkOutRTSFrame(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBBulkOutRTSFrame(IN PRTMP_ADAPTER pAd);
 
-VOID RTUSBCancelPendingBulkInIRP(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBCancelPendingBulkInIRP(IN PRTMP_ADAPTER pAd);
 
-VOID RTUSBCancelPendingIRPs(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBCancelPendingIRPs(IN PRTMP_ADAPTER pAd);
 
-VOID RTUSBBulkOutMLMEPacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Index);
+VOID RTUSBBulkOutMLMEPacket(IN PRTMP_ADAPTER pAd, IN UCHAR Index);
 
-VOID RTUSBBulkOutPsPoll(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBBulkOutPsPoll(IN PRTMP_ADAPTER pAd);
 
-VOID RTUSBCleanUpMLMEBulkOutQueue(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBCleanUpMLMEBulkOutQueue(IN PRTMP_ADAPTER pAd);
 
-VOID RTUSBKickBulkOut(
-	IN	PRTMP_ADAPTER pAd);
+VOID RTUSBKickBulkOut(IN PRTMP_ADAPTER pAd);
 
-VOID	RTUSBBulkReceive(
-	IN	PRTMP_ADAPTER	pAd);
+VOID RTUSBBulkReceive(IN PRTMP_ADAPTER pAd);
 
-VOID DoBulkIn(
-	IN RTMP_ADAPTER *pAd);
+VOID DoBulkIn(IN RTMP_ADAPTER * pAd);
 
-VOID RTUSBInitRxDesc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN  PRX_CONTEXT		pRxContext);
+VOID RTUSBInitRxDesc(IN PRTMP_ADAPTER pAd, IN PRX_CONTEXT pRxContext);
 
-VOID RTUSBBulkRxHandle(
-	IN unsigned long data);
+VOID RTUSBBulkRxHandle(IN unsigned long data);
 
 //
 // Function Prototype in rtusb_io.c
 //
-NTSTATUS RTUSBMultiRead(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	OUT	PUCHAR			pData,
-	IN	USHORT			length);
-
-NTSTATUS RTUSBMultiWrite(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	IN	PUCHAR			pData,
-	IN	USHORT			length);
-
-NTSTATUS RTUSBMultiWrite_OneByte(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	IN	PUCHAR			pData);
-
-NTSTATUS RTUSBReadBBPRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Id,
-	IN	PUCHAR			pValue);
-
-NTSTATUS RTUSBWriteBBPRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Id,
-	IN	UCHAR			Value);
-
-NTSTATUS RTUSBWriteRFRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UINT32			Value);
-
-NTSTATUS RTUSB_VendorRequest(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UINT32			TransferFlags,
-	IN	UCHAR			ReservedBits,
-	IN	UCHAR			Request,
-	IN	USHORT			Value,
-	IN	USHORT			Index,
-	IN	PVOID			TransferBuffer,
-	IN	UINT32			TransferBufferLength);
-
-NTSTATUS RTUSBReadEEPROM(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	OUT	PUCHAR			pData,
-	IN	USHORT			length);
-
-NTSTATUS RTUSBWriteEEPROM(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	IN	PUCHAR			pData,
-	IN	USHORT			length);
-
-VOID RTUSBPutToSleep(
-	IN	PRTMP_ADAPTER	pAd);
-
-NTSTATUS RTUSBWakeUp(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID RTUSBInitializeCmdQ(
-	IN	PCmdQ	cmdq);
-
-NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	NDIS_OID		Oid,
-	IN	BOOLEAN			SetInformation,
-	IN	PVOID			pInformationBuffer,
-	IN	UINT32			InformationBufferLength);
-
-NDIS_STATUS RTUSBEnqueueInternalCmd(
-	IN	PRTMP_ADAPTER	pAd,
-	IN NDIS_OID			Oid,
-	IN PVOID			pInformationBuffer,
-	IN UINT32			InformationBufferLength);
-
-VOID RTUSBDequeueCmd(
-	IN	PCmdQ		cmdq,
-	OUT	PCmdQElmt	*pcmdqelmt);
-
-INT RTUSBCmdThread(
-	IN OUT PVOID Context);
-
-VOID RTUSBBssBeaconExit(
-	IN RTMP_ADAPTER *pAd);
-
-VOID RTUSBBssBeaconStop(
-	IN RTMP_ADAPTER *pAd);
-
-VOID RTUSBBssBeaconStart(
-	IN RTMP_ADAPTER * pAd);
-
-VOID RTUSBBssBeaconInit(
-	IN RTMP_ADAPTER *pAd);
-
-VOID RTUSBWatchDog(
-	IN RTMP_ADAPTER *pAd);
-
-NTSTATUS RTUSBWriteMACRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	IN	UINT32			Value);
-
-NTSTATUS RTUSBReadMACRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	OUT	PUINT32			pValue);
-
-NTSTATUS RTUSBSingleWrite(
-	IN 	RTMP_ADAPTER 	*pAd,
-	IN	USHORT			Offset,
-	IN	USHORT			Value);
-
-NTSTATUS RTUSBFirmwareWrite(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR		pFwImage,
-	IN ULONG		FwLen);
-
-NTSTATUS	RTUSBVenderReset(
-	IN	PRTMP_ADAPTER	pAd);
-
-NDIS_STATUS RTUSBSetHardWareRegister(
-	IN	PRTMP_ADAPTER	pAdapter,
-	IN	PVOID			pBuf);
-
-NDIS_STATUS RTUSBQueryHardWareRegister(
-	IN	PRTMP_ADAPTER	pAdapter,
-	IN	PVOID			pBuf);
-
-VOID CMDHandler(
-	IN PRTMP_ADAPTER pAd);
-
-NDIS_STATUS	RTUSBWriteHWMACAddress(
-	IN	PRTMP_ADAPTER		pAdapter);
-
-VOID MacTableInitialize(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID MlmeSetPsm(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT psm);
-
-NDIS_STATUS RTMPWPAAddKeyProc(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  PVOID           pBuf);
-
-VOID AsicRxAntEvalAction(
-	IN PRTMP_ADAPTER pAd);
-
-void append_pkt(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR		pHeader802_3,
-	IN	UINT		HdrLen,
-	IN	PUCHAR		pData,
-	IN	ULONG		DataSize,
-	OUT  PNDIS_PACKET	*ppPacket);
-
-UINT deaggregate_AMSDU_announce(
-	IN	PRTMP_ADAPTER	pAd,
-	PNDIS_PACKET		pPacket,
-	IN	PUCHAR			pData,
-	IN	ULONG			DataSize);
-
-NDIS_STATUS	RTMPCheckRxError(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PHEADER_802_11	pHeader,
-	IN	PRXWI_STRUC	pRxWI,
-	IN	PRT28XX_RXD_STRUC	pRxINFO);
-
-VOID RTUSBMlmeHardTransmit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PMGMT_STRUC		pMgmt);
+NTSTATUS RTUSBMultiRead(IN PRTMP_ADAPTER pAd,
+			IN USHORT Offset, OUT PUCHAR pData, IN USHORT length);
+
+NTSTATUS RTUSBMultiWrite(IN PRTMP_ADAPTER pAd,
+			 IN USHORT Offset, IN PUCHAR pData, IN USHORT length);
+
+NTSTATUS RTUSBMultiWrite_OneByte(IN PRTMP_ADAPTER pAd,
+				 IN USHORT Offset, IN PUCHAR pData);
+
+NTSTATUS RTUSBReadBBPRegister(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR Id, IN PUCHAR pValue);
+
+NTSTATUS RTUSBWriteBBPRegister(IN PRTMP_ADAPTER pAd,
+			       IN UCHAR Id, IN UCHAR Value);
+
+NTSTATUS RTUSBWriteRFRegister(IN PRTMP_ADAPTER pAd, IN UINT32 Value);
+
+NTSTATUS RTUSB_VendorRequest(IN PRTMP_ADAPTER pAd,
+			     IN UINT32 TransferFlags,
+			     IN UCHAR ReservedBits,
+			     IN UCHAR Request,
+			     IN USHORT Value,
+			     IN USHORT Index,
+			     IN PVOID TransferBuffer,
+			     IN UINT32 TransferBufferLength);
+
+NTSTATUS RTUSBReadEEPROM(IN PRTMP_ADAPTER pAd,
+			 IN USHORT Offset, OUT PUCHAR pData, IN USHORT length);
+
+NTSTATUS RTUSBWriteEEPROM(IN PRTMP_ADAPTER pAd,
+			  IN USHORT Offset, IN PUCHAR pData, IN USHORT length);
+
+VOID RTUSBPutToSleep(IN PRTMP_ADAPTER pAd);
+
+NTSTATUS RTUSBWakeUp(IN PRTMP_ADAPTER pAd);
+
+VOID RTUSBInitializeCmdQ(IN PCmdQ cmdq);
+
+NDIS_STATUS RTUSBEnqueueCmdFromNdis(IN PRTMP_ADAPTER pAd,
+				    IN NDIS_OID Oid,
+				    IN BOOLEAN SetInformation,
+				    IN PVOID pInformationBuffer,
+				    IN UINT32 InformationBufferLength);
+
+NDIS_STATUS RTUSBEnqueueInternalCmd(IN PRTMP_ADAPTER pAd,
+				    IN NDIS_OID Oid,
+				    IN PVOID pInformationBuffer,
+				    IN UINT32 InformationBufferLength);
+
+VOID RTUSBDequeueCmd(IN PCmdQ cmdq, OUT PCmdQElmt * pcmdqelmt);
+
+INT RTUSBCmdThread(IN OUT PVOID Context);
+
+VOID RTUSBBssBeaconExit(IN RTMP_ADAPTER * pAd);
+
+VOID RTUSBBssBeaconStop(IN RTMP_ADAPTER * pAd);
 
-INT MlmeThread(
-	IN PVOID Context);
+VOID RTUSBBssBeaconStart(IN RTMP_ADAPTER * pAd);
+
+VOID RTUSBBssBeaconInit(IN RTMP_ADAPTER * pAd);
+
+VOID RTUSBWatchDog(IN RTMP_ADAPTER * pAd);
+
+NTSTATUS RTUSBWriteMACRegister(IN PRTMP_ADAPTER pAd,
+			       IN USHORT Offset, IN UINT32 Value);
+
+NTSTATUS RTUSBReadMACRegister(IN PRTMP_ADAPTER pAd,
+			      IN USHORT Offset, OUT PUINT32 pValue);
+
+NTSTATUS RTUSBSingleWrite(IN RTMP_ADAPTER * pAd,
+			  IN USHORT Offset, IN USHORT Value);
+
+NTSTATUS RTUSBFirmwareWrite(IN PRTMP_ADAPTER pAd,
+			    IN PUCHAR pFwImage, IN ULONG FwLen);
+
+NTSTATUS RTUSBVenderReset(IN PRTMP_ADAPTER pAd);
+
+NDIS_STATUS RTUSBSetHardWareRegister(IN PRTMP_ADAPTER pAdapter, IN PVOID pBuf);
+
+NDIS_STATUS RTUSBQueryHardWareRegister(IN PRTMP_ADAPTER pAdapter,
+				       IN PVOID pBuf);
+
+VOID CMDHandler(IN PRTMP_ADAPTER pAd);
+
+NDIS_STATUS RTUSBWriteHWMACAddress(IN PRTMP_ADAPTER pAdapter);
+
+VOID MacTableInitialize(IN PRTMP_ADAPTER pAd);
+
+VOID MlmeSetPsm(IN PRTMP_ADAPTER pAd, IN USHORT psm);
+
+NDIS_STATUS RTMPWPAAddKeyProc(IN PRTMP_ADAPTER pAd, IN PVOID pBuf);
+
+VOID AsicRxAntEvalAction(IN PRTMP_ADAPTER pAd);
+
+void append_pkt(IN PRTMP_ADAPTER pAd,
+		IN PUCHAR pHeader802_3,
+		IN UINT HdrLen,
+		IN PUCHAR pData,
+		IN ULONG DataSize, OUT PNDIS_PACKET * ppPacket);
+
+UINT deaggregate_AMSDU_announce(IN PRTMP_ADAPTER pAd,
+				PNDIS_PACKET pPacket,
+				IN PUCHAR pData, IN ULONG DataSize);
+
+NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
+			     IN PHEADER_802_11 pHeader,
+			     IN PRXWI_STRUC pRxWI,
+			     IN PRT28XX_RXD_STRUC pRxINFO);
+
+VOID RTUSBMlmeHardTransmit(IN PRTMP_ADAPTER pAd, IN PMGMT_STRUC pMgmt);
+
+INT MlmeThread(IN PVOID Context);
 
 //
 // Function Prototype in rtusb_data.c
 //
-NDIS_STATUS	RTUSBFreeDescriptorRequest(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			BulkOutPipeId,
-	IN	UINT32			NumberRequired);
-
-
-BOOLEAN	RTUSBNeedQueueBackForAgg(
-	IN RTMP_ADAPTER *pAd,
-	IN UCHAR		BulkOutPipeId);
-
-
-VOID RTMPWriteTxInfo(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PTXINFO_STRUC 	pTxInfo,
-	IN	  USHORT		USBDMApktLen,
-	IN	  BOOLEAN		bWiv,
-	IN	  UCHAR			QueueSel,
-	IN	  UCHAR			NextValid,
-	IN	  UCHAR			TxBurst);
+NDIS_STATUS RTUSBFreeDescriptorRequest(IN PRTMP_ADAPTER pAd,
+				       IN UCHAR BulkOutPipeId,
+				       IN UINT32 NumberRequired);
+
+BOOLEAN RTUSBNeedQueueBackForAgg(IN RTMP_ADAPTER * pAd, IN UCHAR BulkOutPipeId);
+
+VOID RTMPWriteTxInfo(IN PRTMP_ADAPTER pAd,
+		     IN PTXINFO_STRUC pTxInfo,
+		     IN USHORT USBDMApktLen,
+		     IN BOOLEAN bWiv,
+		     IN UCHAR QueueSel, IN UCHAR NextValid, IN UCHAR TxBurst);
 
 //
 // Function Prototype in cmm_data_usb.c
 //
-USHORT RtmpUSB_WriteSubTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber);
-
-USHORT RtmpUSB_WriteSingleTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	BOOLEAN			bIsLast,
-	OUT	USHORT			*FreeNumber);
-
-USHORT	RtmpUSB_WriteFragTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			fragNum,
-	OUT	USHORT			*FreeNumber);
-
-USHORT RtmpUSB_WriteMultiTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			frameNum,
-	OUT	USHORT			*FreeNumber);
-
-VOID RtmpUSB_FinalWriteTxResource(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	USHORT			totalMPDUSize,
-	IN	USHORT			TxIdx);
-
-VOID RtmpUSBDataLastTxIdx(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			QueIdx,
-	IN	USHORT			TxIdx);
-
-VOID RtmpUSBDataKickOut(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk,
-	IN	UCHAR			QueIdx);
-
-
-int RtmpUSBMgmtKickOut(
-	IN RTMP_ADAPTER 	*pAd,
-	IN UCHAR 			QueIdx,
-	IN PNDIS_PACKET		pPacket,
-	IN PUCHAR			pSrcBufVA,
-	IN UINT 			SrcBufLen);
-
-VOID RtmpUSBNullFrameKickOut(
-	IN RTMP_ADAPTER *pAd,
-	IN UCHAR		QueIdx,
-	IN UCHAR		*pNullFrame,
-	IN UINT32		frameLen);
-
-VOID RtmpUsbStaAsicForceWakeupTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3);
-
-VOID RT28xxUsbStaAsicForceWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN BOOLEAN       bFromTx);
-
-VOID RT28xxUsbStaAsicSleepThenAutoWakeup(
-	IN PRTMP_ADAPTER pAd,
-	IN USHORT TbttNumToNextWakeUp);
+USHORT RtmpUSB_WriteSubTxResource(IN PRTMP_ADAPTER pAd,
+				  IN TX_BLK * pTxBlk,
+				  IN BOOLEAN bIsLast, OUT USHORT * FreeNumber);
 
-VOID RT28xxUsbMlmeRadioOn(
-	IN PRTMP_ADAPTER pAd);
+USHORT RtmpUSB_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
+				     IN TX_BLK * pTxBlk,
+				     IN BOOLEAN bIsLast,
+				     OUT USHORT * FreeNumber);
 
-VOID RT28xxUsbMlmeRadioOFF(
-	IN PRTMP_ADAPTER pAd);
-#endif // RTMP_MAC_USB //
+USHORT RtmpUSB_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
+				   IN TX_BLK * pTxBlk,
+				   IN UCHAR fragNum, OUT USHORT * FreeNumber);
+
+USHORT RtmpUSB_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
+				    IN TX_BLK * pTxBlk,
+				    IN UCHAR frameNum, OUT USHORT * FreeNumber);
+
+VOID RtmpUSB_FinalWriteTxResource(IN PRTMP_ADAPTER pAd,
+				  IN TX_BLK * pTxBlk,
+				  IN USHORT totalMPDUSize, IN USHORT TxIdx);
+
+VOID RtmpUSBDataLastTxIdx(IN PRTMP_ADAPTER pAd,
+			  IN UCHAR QueIdx, IN USHORT TxIdx);
+
+VOID RtmpUSBDataKickOut(IN PRTMP_ADAPTER pAd,
+			IN TX_BLK * pTxBlk, IN UCHAR QueIdx);
+
+int RtmpUSBMgmtKickOut(IN RTMP_ADAPTER * pAd,
+		       IN UCHAR QueIdx,
+		       IN PNDIS_PACKET pPacket,
+		       IN PUCHAR pSrcBufVA, IN UINT SrcBufLen);
+
+VOID RtmpUSBNullFrameKickOut(IN RTMP_ADAPTER * pAd,
+			     IN UCHAR QueIdx,
+			     IN UCHAR * pNullFrame, IN UINT32 frameLen);
 
-VOID AsicTurnOffRFClk(
-	IN PRTMP_ADAPTER    pAd,
-	IN	UCHAR           Channel);
-
-VOID AsicTurnOnRFClk(
-	IN PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Channel);
+VOID RtmpUsbStaAsicForceWakeupTimeout(IN PVOID SystemSpecific1,
+				      IN PVOID FunctionContext,
+				      IN PVOID SystemSpecific2,
+				      IN PVOID SystemSpecific3);
 
+VOID RT28xxUsbStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx);
 
+VOID RT28xxUsbStaAsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
+					 IN USHORT TbttNumToNextWakeUp);
+
+VOID RT28xxUsbMlmeRadioOn(IN PRTMP_ADAPTER pAd);
+
+VOID RT28xxUsbMlmeRadioOFF(IN PRTMP_ADAPTER pAd);
+#endif // RTMP_MAC_USB //
+
+VOID AsicTurnOffRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel);
+
+VOID AsicTurnOnRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel);
 
 #ifdef RTMP_TIMER_TASK_SUPPORT
-INT RtmpTimerQThread(
-	IN OUT PVOID Context);
+INT RtmpTimerQThread(IN OUT PVOID Context);
+
+RTMP_TIMER_TASK_ENTRY *RtmpTimerQInsert(IN RTMP_ADAPTER * pAd,
+					IN RALINK_TIMER_STRUCT * pTimer);
 
-RTMP_TIMER_TASK_ENTRY *RtmpTimerQInsert(
-	IN RTMP_ADAPTER *pAd,
-	IN RALINK_TIMER_STRUCT *pTimer);
-
-BOOLEAN RtmpTimerQRemove(
-	IN RTMP_ADAPTER *pAd,
-	IN RALINK_TIMER_STRUCT *pTimer);
+BOOLEAN RtmpTimerQRemove(IN RTMP_ADAPTER * pAd,
+			 IN RALINK_TIMER_STRUCT * pTimer);
 
-void RtmpTimerQExit(
-	IN RTMP_ADAPTER *pAd);
+void RtmpTimerQExit(IN RTMP_ADAPTER * pAd);
 
-void RtmpTimerQInit(
-	IN RTMP_ADAPTER *pAd);
+void RtmpTimerQInit(IN RTMP_ADAPTER * pAd);
 #endif // RTMP_TIMER_TASK_SUPPORT //
 
-VOID AsicStaBbpTuning(
-	IN PRTMP_ADAPTER pAd);
+VOID AsicStaBbpTuning(IN PRTMP_ADAPTER pAd);
+
+BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
+			    IN PMAC_TABLE_ENTRY pEntry,
+			    IN UCHAR MaxSupportedRateIn500Kbps,
+			    IN HT_CAPABILITY_IE * pHtCapability,
+			    IN UCHAR HtCapabilityLen,
+			    IN ADD_HT_INFO_IE * pAddHtInfo,
+			    IN UCHAR AddHtInfoLen, IN USHORT CapabilityInfo);
+
+BOOLEAN AUTH_ReqSend(IN PRTMP_ADAPTER pAd,
+		     IN PMLME_QUEUE_ELEM pElem,
+		     IN PRALINK_TIMER_STRUCT pAuthTimer,
+		     IN PSTRING pSMName,
+		     IN USHORT SeqNo,
+		     IN PUCHAR pNewElement, IN ULONG ElementLen);
 
-BOOLEAN StaAddMacTableEntry(
-	IN  PRTMP_ADAPTER		pAd,
-	IN  PMAC_TABLE_ENTRY	pEntry,
-	IN  UCHAR				MaxSupportedRateIn500Kbps,
-	IN  HT_CAPABILITY_IE	*pHtCapability,
-	IN  UCHAR				HtCapabilityLen,
-	IN  ADD_HT_INFO_IE		*pAddHtInfo,
-	IN  UCHAR				AddHtInfoLen,
-	IN  USHORT        		CapabilityInfo);
-
-
-BOOLEAN	AUTH_ReqSend(
-	IN  PRTMP_ADAPTER		pAd,
-	IN  PMLME_QUEUE_ELEM	pElem,
-	IN  PRALINK_TIMER_STRUCT pAuthTimer,
-	IN  PSTRING				pSMName,
-	IN  USHORT				SeqNo,
-	IN  PUCHAR				pNewElement,
-	IN  ULONG				ElementLen);
-
-void RTMP_IndicateMediaState(
-	IN	PRTMP_ADAPTER	pAd);
-
-VOID ReSyncBeaconTime(
-	IN  PRTMP_ADAPTER   pAd);
-
-VOID RTMPSetAGCInitValue(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			BandWidth);
+void RTMP_IndicateMediaState(IN PRTMP_ADAPTER pAd);
+
+VOID ReSyncBeaconTime(IN PRTMP_ADAPTER pAd);
+
+VOID RTMPSetAGCInitValue(IN PRTMP_ADAPTER pAd, IN UCHAR BandWidth);
 
 int rt28xx_close(IN PNET_DEV dev);
 int rt28xx_open(IN PNET_DEV dev);
 
-
 #define VIRTUAL_IF_INC(__pAd) ((__pAd)->VirtualIfCnt++)
 #define VIRTUAL_IF_DEC(__pAd) ((__pAd)->VirtualIfCnt--)
 #define VIRTUAL_IF_NUM(__pAd) ((__pAd)->VirtualIfCnt)
 
-
 #ifdef LINUX
 __inline INT VIRTUAL_IF_UP(PRTMP_ADAPTER pAd)
 {
-	if (VIRTUAL_IF_NUM(pAd) == 0)
-	{
-		if (rt28xx_open(pAd->net_dev) != 0)
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("rt28xx_open return fail!\n"));
+	if (VIRTUAL_IF_NUM(pAd) == 0) {
+		if (rt28xx_open(pAd->net_dev) != 0) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("rt28xx_open return fail!\n"));
 			return -1;
-	}
-	}
-	else
-	{
+		}
+	} else {
 	}
 	VIRTUAL_IF_INC(pAd);
 	return 0;
@@ -5473,101 +4293,64 @@ __inline VOID VIRTUAL_IF_DOWN(PRTMP_ADAP
 }
 #endif // LINUX //
 
-
 /*
 	OS Related funciton prototype definitions.
 	TODO: Maybe we need to move these function prototypes to other proper place.
 */
-int RtmpOSWrielessEventSend(
-	IN RTMP_ADAPTER *pAd,
-	IN UINT32		eventType,
-	IN INT			flags,
-	IN PUCHAR		pSrcMac,
-	IN PUCHAR		pData,
-	IN UINT32		dataLen);
-
-int RtmpOSNetDevAddrSet(
-	IN PNET_DEV pNetDev,
-	IN PUCHAR	pMacAddr);
-
-int RtmpOSNetDevAttach(
-	IN PNET_DEV pNetDev,
-	IN RTMP_OS_NETDEV_OP_HOOK *pDevOpHook);
-
-void RtmpOSNetDevClose(
-	IN PNET_DEV pNetDev);
-
-void RtmpOSNetDevDetach(
-	IN PNET_DEV pNetDev);
-
-INT RtmpOSNetDevAlloc(
-	IN PNET_DEV *pNewNetDev,
-	IN UINT32	privDataSize);
-
-void RtmpOSNetDevFree(
-	IN PNET_DEV pNetDev);
-
-PNET_DEV RtmpOSNetDevGetByName(
-	IN PNET_DEV pNetDev,
-	IN PSTRING	pDevName);
-
-void RtmpOSNetDeviceRefPut(
-	IN PNET_DEV pNetDev);
-
-PNET_DEV RtmpOSNetDevCreate(
-	IN RTMP_ADAPTER *pAd,
-	IN INT			devType,
-	IN INT			devNum,
-	IN INT			privMemSize,
-	IN PSTRING		pNamePrefix);
+int RtmpOSWrielessEventSend(IN RTMP_ADAPTER * pAd,
+			    IN UINT32 eventType,
+			    IN INT flags,
+			    IN PUCHAR pSrcMac,
+			    IN PUCHAR pData, IN UINT32 dataLen);
+
+int RtmpOSNetDevAddrSet(IN PNET_DEV pNetDev, IN PUCHAR pMacAddr);
+
+int RtmpOSNetDevAttach(IN PNET_DEV pNetDev,
+		       IN RTMP_OS_NETDEV_OP_HOOK * pDevOpHook);
+
+void RtmpOSNetDevClose(IN PNET_DEV pNetDev);
+
+void RtmpOSNetDevDetach(IN PNET_DEV pNetDev);
+
+INT RtmpOSNetDevAlloc(IN PNET_DEV * pNewNetDev, IN UINT32 privDataSize);
+
+void RtmpOSNetDevFree(IN PNET_DEV pNetDev);
+
+PNET_DEV RtmpOSNetDevGetByName(IN PNET_DEV pNetDev, IN PSTRING pDevName);
+
+void RtmpOSNetDeviceRefPut(IN PNET_DEV pNetDev);
+
+PNET_DEV RtmpOSNetDevCreate(IN RTMP_ADAPTER * pAd,
+			    IN INT devType,
+			    IN INT devNum,
+			    IN INT privMemSize, IN PSTRING pNamePrefix);
 
 /*
 	Task operation related function prototypes
 */
-void RtmpOSTaskCustomize(
-	IN RTMP_OS_TASK *pTask);
+void RtmpOSTaskCustomize(IN RTMP_OS_TASK * pTask);
 
-INT RtmpOSTaskNotifyToExit(
-	IN RTMP_OS_TASK *pTask);
+INT RtmpOSTaskNotifyToExit(IN RTMP_OS_TASK * pTask);
 
-NDIS_STATUS RtmpOSTaskKill(
-	IN RTMP_OS_TASK *pTask);
+NDIS_STATUS RtmpOSTaskKill(IN RTMP_OS_TASK * pTask);
 
-NDIS_STATUS RtmpOSTaskInit(
-	IN RTMP_OS_TASK *pTask,
-	PSTRING			 pTaskName,
-	VOID			 *pPriv);
-
-NDIS_STATUS RtmpOSTaskAttach(
-	IN RTMP_OS_TASK *pTask,
-	IN int (*fn)(void *),
-	IN void *arg);
+NDIS_STATUS RtmpOSTaskInit(IN RTMP_OS_TASK * pTask,
+			   PSTRING pTaskName, VOID * pPriv);
 
+NDIS_STATUS RtmpOSTaskAttach(IN RTMP_OS_TASK * pTask,
+			     IN int (*fn) (void *), IN void *arg);
 
 /*
 	File operation related function prototypes
 */
-RTMP_OS_FD RtmpOSFileOpen(
-	IN char *pPath,
-	IN int flag,
-	IN int mode);
-
-int RtmpOSFileClose(
-	IN RTMP_OS_FD osfd);
-
-void RtmpOSFileSeek(
-	IN RTMP_OS_FD osfd,
-	IN int offset);
-
-int RtmpOSFileRead(
-	IN RTMP_OS_FD osfd,
-	IN char *pDataPtr,
-	IN int readLen);
-
-int RtmpOSFileWrite(
-	IN RTMP_OS_FD osfd,
-	IN char *pDataPtr,
-	IN int writeLen);
+RTMP_OS_FD RtmpOSFileOpen(IN char *pPath, IN int flag, IN int mode);
+
+int RtmpOSFileClose(IN RTMP_OS_FD osfd);
+
+void RtmpOSFileSeek(IN RTMP_OS_FD osfd, IN int offset);
+
+int RtmpOSFileRead(IN RTMP_OS_FD osfd, IN char *pDataPtr, IN int readLen);
 
-#endif  // __RTMP_H__
+int RtmpOSFileWrite(IN RTMP_OS_FD osfd, IN char *pDataPtr, IN int writeLen);
 
+#endif // __RTMP_H__
--- a/drivers/staging/rt2860/rtmp_iface.h
+++ b/drivers/staging/rt2860/rtmp_iface.h
@@ -37,7 +37,6 @@
 #ifndef __RTMP_IFACE_H__
 #define __RTMP_IFACE_H__
 
-
 #ifdef RTMP_PCI_SUPPORT
 #include "iface/rtmp_pci.h"
 #endif // RTMP_PCI_SUPPORT //
@@ -45,40 +44,32 @@
 #include "iface/rtmp_usb.h"
 #endif // RTMP_USB_SUPPORT //
 
-typedef struct _INF_PCI_CONFIG_
-{
-	unsigned long	CSRBaseAddress;     // PCI MMIO Base Address, all access will use
-	unsigned int	irq_num;
-}INF_PCI_CONFIG;
-
-
-typedef struct _INF_USB_CONFIG_
-{
-	UINT8                BulkInEpAddr;		// bulk-in endpoint address
-	UINT8                BulkOutEpAddr[6];	// bulk-out endpoint address
-}INF_USB_CONFIG;
-
+typedef struct _INF_PCI_CONFIG_ {
+	unsigned long CSRBaseAddress;	// PCI MMIO Base Address, all access will use
+	unsigned int irq_num;
+} INF_PCI_CONFIG;
+
+typedef struct _INF_USB_CONFIG_ {
+	UINT8 BulkInEpAddr;	// bulk-in endpoint address
+	UINT8 BulkOutEpAddr[6];	// bulk-out endpoint address
+} INF_USB_CONFIG;
+
+typedef struct _INF_RBUS_CONFIG_ {
+	unsigned long csr_addr;
+	unsigned int irq;
+} INF_RBUS_CONFIG;
 
-typedef struct _INF_RBUS_CONFIG_
-{
-	unsigned long		csr_addr;
-	unsigned int		irq;
-}INF_RBUS_CONFIG;
-
-
-typedef enum _RTMP_INF_TYPE_
-{
+typedef enum _RTMP_INF_TYPE_ {
 	RTMP_DEV_INF_UNKNOWN = 0,
 	RTMP_DEV_INF_PCI = 1,
 	RTMP_DEV_INF_USB = 2,
 	RTMP_DEV_INF_RBUS = 4,
-}RTMP_INF_TYPE;
-
+} RTMP_INF_TYPE;
 
-typedef union _RTMP_INF_CONFIG_{
-	struct _INF_PCI_CONFIG_			pciConfig;
-	struct _INF_USB_CONFIG_			usbConfig;
-	struct _INF_RBUS_CONFIG_		rbusConfig;
-}RTMP_INF_CONFIG;
+typedef union _RTMP_INF_CONFIG_ {
+	struct _INF_PCI_CONFIG_ pciConfig;
+	struct _INF_USB_CONFIG_ usbConfig;
+	struct _INF_RBUS_CONFIG_ rbusConfig;
+} RTMP_INF_CONFIG;
 
 #endif // __RTMP_IFACE_H__ //
--- a/drivers/staging/rt2860/rtmp_mcu.h
+++ b/drivers/staging/rt2860/rtmp_mcu.h
@@ -38,18 +38,12 @@
 #ifndef __RTMP_MCU_H__
 #define __RTMP_MCU_H__
 
+INT RtmpAsicEraseFirmware(IN PRTMP_ADAPTER pAd);
 
-INT RtmpAsicEraseFirmware(
-	IN PRTMP_ADAPTER pAd);
+NDIS_STATUS RtmpAsicLoadFirmware(IN PRTMP_ADAPTER pAd);
 
-NDIS_STATUS RtmpAsicLoadFirmware(
-	IN PRTMP_ADAPTER pAd);
-
-INT RtmpAsicSendCommandToMcu(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR		 Command,
-	IN UCHAR		 Token,
-	IN UCHAR		 Arg0,
-	IN UCHAR		 Arg1);
+INT RtmpAsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
+			     IN UCHAR Command,
+			     IN UCHAR Token, IN UCHAR Arg0, IN UCHAR Arg1);
 
 #endif // __RTMP_MCU_H__ //
--- a/drivers/staging/rt2860/rtmp_os.h
+++ b/drivers/staging/rt2860/rtmp_os.h
@@ -34,7 +34,6 @@
     ---------    ----------    ----------------------------------------------
  */
 
-
 #ifndef __RTMP_OS_H__
 #define __RTMP_OS_H__
 
@@ -42,8 +41,6 @@
 #include "rt_linux.h"
 #endif // LINUX //
 
-
-
 /*
 	This data structure mainly strip some callback function defined in
 	"struct net_device" in kernel source "include/linux/netdevice.h".
@@ -51,46 +48,41 @@
 	The definition of this data structure may various depends on different
 	OS. Use it carefully.
 */
-typedef struct _RTMP_OS_NETDEV_OP_HOOK_
-{
+typedef struct _RTMP_OS_NETDEV_OP_HOOK_ {
 	const struct net_device_ops *netdev_ops;
-	void			*priv;
-	int			priv_flags;
+	void *priv;
+	int priv_flags;
 	unsigned char devAddr[6];
-	unsigned char	devName[16];
-	unsigned char	needProtcted;
-}RTMP_OS_NETDEV_OP_HOOK, *PRTMP_OS_NETDEV_OP_HOOK;
+	unsigned char devName[16];
+	unsigned char needProtcted;
+} RTMP_OS_NETDEV_OP_HOOK, *PRTMP_OS_NETDEV_OP_HOOK;
 
-
-typedef enum _RTMP_TASK_STATUS_
-{
+typedef enum _RTMP_TASK_STATUS_ {
 	RTMP_TASK_STAT_UNKNOWN = 0,
 	RTMP_TASK_STAT_INITED = 1,
 	RTMP_TASK_STAT_RUNNING = 2,
 	RTMP_TASK_STAT_STOPED = 4,
-}RTMP_TASK_STATUS;
+} RTMP_TASK_STATUS;
 #define RTMP_TASK_CAN_DO_INSERT		(RTMP_TASK_STAT_INITED |RTMP_TASK_STAT_RUNNING)
 
 #define RTMP_OS_TASK_NAME_LEN	16
-typedef struct _RTMP_OS_TASK_
-{
-	char					taskName[RTMP_OS_TASK_NAME_LEN];
-	void					*priv;
-	//unsigned long		taskFlags;
-	RTMP_TASK_STATUS	taskStatus;
+typedef struct _RTMP_OS_TASK_ {
+	char taskName[RTMP_OS_TASK_NAME_LEN];
+	void *priv;
+	//unsigned long         taskFlags;
+	RTMP_TASK_STATUS taskStatus;
 #ifndef KTHREAD_SUPPORT
-	RTMP_OS_SEM			taskSema;
-	RTMP_OS_PID			taskPID;
-	struct completion		taskComplete;
+	RTMP_OS_SEM taskSema;
+	RTMP_OS_PID taskPID;
+	struct completion taskComplete;
 #endif
-	unsigned char			task_killed;
+	unsigned char task_killed;
 #ifdef KTHREAD_SUPPORT
-	struct task_struct	*kthread_task;
-	wait_queue_head_t		kthread_q;
-	BOOLEAN					kthread_running;
+	struct task_struct *kthread_task;
+	wait_queue_head_t kthread_q;
+	BOOLEAN kthread_running;
 #endif
-}RTMP_OS_TASK;
-
+} RTMP_OS_TASK;
 
 int RtmpOSIRQRequest(IN PNET_DEV pNetDev);
 int RtmpOSIRQRelease(IN PNET_DEV pNetDev);
--- a/drivers/staging/rt2860/rtmp_timer.h
+++ b/drivers/staging/rt2860/rtmp_timer.h
@@ -43,59 +43,52 @@
 
 #include "rtmp_os.h"
 
-
 #define DECLARE_TIMER_FUNCTION(_func)			\
 	void rtmp_timer_##_func(unsigned long data)
 
 #define GET_TIMER_FUNCTION(_func)				\
 	rtmp_timer_##_func
 
-
 /* ----------------- Timer Related MARCO ---------------*/
 // In some os or chipset, we have a lot of timer functions and will read/write register,
 //   it's not allowed in Linux USB sub-system to do it ( because of sleep issue when
 //  submit to ctrl pipe). So we need a wrapper function to take care it.
 
 #ifdef RTMP_TIMER_TASK_SUPPORT
-typedef VOID (*RTMP_TIMER_TASK_HANDLE)(
-	IN  PVOID   SystemSpecific1,
-	IN  PVOID   FunctionContext,
-	IN  PVOID   SystemSpecific2,
-	IN  PVOID   SystemSpecific3);
+typedef VOID(*RTMP_TIMER_TASK_HANDLE) (IN PVOID SystemSpecific1,
+				       IN PVOID FunctionContext,
+				       IN PVOID SystemSpecific2,
+				       IN PVOID SystemSpecific3);
 #endif // RTMP_TIMER_TASK_SUPPORT //
 
-typedef struct  _RALINK_TIMER_STRUCT    {
-	RTMP_OS_TIMER		TimerObj;       // Ndis Timer object
-	BOOLEAN				Valid;			// Set to True when call RTMPInitTimer
-	BOOLEAN				State;          // True if timer cancelled
-	BOOLEAN				PeriodicType;	// True if timer is periodic timer
-	BOOLEAN				Repeat;         // True if periodic timer
-	ULONG				TimerValue;     // Timer value in milliseconds
-	ULONG				cookie;			// os specific object
+typedef struct _RALINK_TIMER_STRUCT {
+	RTMP_OS_TIMER TimerObj;	// Ndis Timer object
+	BOOLEAN Valid;		// Set to True when call RTMPInitTimer
+	BOOLEAN State;		// True if timer cancelled
+	BOOLEAN PeriodicType;	// True if timer is periodic timer
+	BOOLEAN Repeat;		// True if periodic timer
+	ULONG TimerValue;	// Timer value in milliseconds
+	ULONG cookie;		// os specific object
 #ifdef RTMP_TIMER_TASK_SUPPORT
-	RTMP_TIMER_TASK_HANDLE	handle;
-	void					*pAd;
-#endif // RTMP_TIMER_TASK_SUPPORT //
-}RALINK_TIMER_STRUCT, *PRALINK_TIMER_STRUCT;
-
+	RTMP_TIMER_TASK_HANDLE handle;
+	void *pAd;
+#endif				// RTMP_TIMER_TASK_SUPPORT //
+} RALINK_TIMER_STRUCT, *PRALINK_TIMER_STRUCT;
 
 #ifdef RTMP_TIMER_TASK_SUPPORT
-typedef struct _RTMP_TIMER_TASK_ENTRY_
-{
-	RALINK_TIMER_STRUCT			*pRaTimer;
-	struct _RTMP_TIMER_TASK_ENTRY_	*pNext;
-}RTMP_TIMER_TASK_ENTRY;
-
+typedef struct _RTMP_TIMER_TASK_ENTRY_ {
+	RALINK_TIMER_STRUCT *pRaTimer;
+	struct _RTMP_TIMER_TASK_ENTRY_ *pNext;
+} RTMP_TIMER_TASK_ENTRY;
 
 #define TIMER_QUEUE_SIZE_MAX	128
-typedef struct _RTMP_TIMER_TASK_QUEUE_
-{
-	unsigned int				status;
-	unsigned char				*pTimerQPoll;
-	RTMP_TIMER_TASK_ENTRY	*pQPollFreeList;
-	RTMP_TIMER_TASK_ENTRY	*pQHead;
-	RTMP_TIMER_TASK_ENTRY	*pQTail;
-}RTMP_TIMER_TASK_QUEUE;
+typedef struct _RTMP_TIMER_TASK_QUEUE_ {
+	unsigned int status;
+	unsigned char *pTimerQPoll;
+	RTMP_TIMER_TASK_ENTRY *pQPollFreeList;
+	RTMP_TIMER_TASK_ENTRY *pQHead;
+	RTMP_TIMER_TASK_ENTRY *pQTail;
+} RTMP_TIMER_TASK_QUEUE;
 
 #define BUILD_TIMER_FUNCTION(_func)										\
 void rtmp_timer_##_func(unsigned long data)										\
@@ -122,7 +115,6 @@ void rtmp_timer_##_func(unsigned long da
 }
 #endif // RTMP_TIMER_TASK_SUPPORT //
 
-
 DECLARE_TIMER_FUNCTION(MlmePeriodicExec);
 DECLARE_TIMER_FUNCTION(MlmeRssiReportExec);
 DECLARE_TIMER_FUNCTION(AsicRxAntEvalTimeout);
@@ -152,5 +144,4 @@ DECLARE_TIMER_FUNCTION(RtmpUsbStaAsicFor
 DECLARE_TIMER_FUNCTION(LedCtrlMain);
 #endif
 
-
 #endif // __RTMP_TIMER_H__ //
--- a/drivers/staging/rt2860/rtmp_type.h
+++ b/drivers/staging/rt2860/rtmp_type.h
@@ -38,110 +38,101 @@
 #ifndef __RTMP_TYPE_H__
 #define __RTMP_TYPE_H__
 
-
 #define PACKED  __attribute__ ((packed))
 
 #ifdef LINUX
 // Put platform dependent declaration here
 // For example, linux type definition
-typedef unsigned char		UINT8;
-typedef unsigned short		UINT16;
-typedef unsigned int		UINT32;
-typedef unsigned long long	UINT64;
-typedef int					INT32;
-typedef long long 			INT64;
+typedef unsigned char UINT8;
+typedef unsigned short UINT16;
+typedef unsigned int UINT32;
+typedef unsigned long long UINT64;
+typedef int INT32;
+typedef long long INT64;
 #endif // LINUX //
 
-typedef unsigned char *			PUINT8;
-typedef unsigned short *		PUINT16;
-typedef unsigned int *			PUINT32;
-typedef unsigned long long *	PUINT64;
-typedef int	*					PINT32;
-typedef long long * 			PINT64;
+typedef unsigned char *PUINT8;
+typedef unsigned short *PUINT16;
+typedef unsigned int *PUINT32;
+typedef unsigned long long *PUINT64;
+typedef int *PINT32;
+typedef long long *PINT64;
 
 // modified for fixing compile warning on Sigma 8634 platform
-typedef char					STRING;
-typedef signed char			CHAR;
-
-typedef signed short		SHORT;
-typedef signed int			INT;
-typedef signed long			LONG;
-typedef signed long long	LONGLONG;
+typedef char STRING;
+typedef signed char CHAR;
 
+typedef signed short SHORT;
+typedef signed int INT;
+typedef signed long LONG;
+typedef signed long long LONGLONG;
 
 #ifdef LINUX
-typedef unsigned char		UCHAR;
-typedef unsigned short		USHORT;
-typedef unsigned int		UINT;
-typedef unsigned long		ULONG;
+typedef unsigned char UCHAR;
+typedef unsigned short USHORT;
+typedef unsigned int UINT;
+typedef unsigned long ULONG;
 #endif // LINUX //
-typedef unsigned long long	ULONGLONG;
+typedef unsigned long long ULONGLONG;
 
-typedef unsigned char		BOOLEAN;
+typedef unsigned char BOOLEAN;
 #ifdef LINUX
-typedef void				VOID;
+typedef void VOID;
 #endif // LINUX //
 
-typedef char *				PSTRING;
-typedef VOID *				PVOID;
-typedef CHAR *				PCHAR;
-typedef UCHAR * 			PUCHAR;
-typedef USHORT *			PUSHORT;
-typedef LONG *				PLONG;
-typedef ULONG *				PULONG;
-typedef UINT *				PUINT;
+typedef char *PSTRING;
+typedef VOID *PVOID;
+typedef CHAR *PCHAR;
+typedef UCHAR *PUCHAR;
+typedef USHORT *PUSHORT;
+typedef LONG *PLONG;
+typedef ULONG *PULONG;
+typedef UINT *PUINT;
 
-typedef unsigned int	NDIS_MEDIA_STATE;
+typedef unsigned int NDIS_MEDIA_STATE;
 
 typedef union _LARGE_INTEGER {
-    struct {
-        UINT LowPart;
-        INT32 HighPart;
-    } u;
-    INT64 QuadPart;
+	struct {
+		UINT LowPart;
+		INT32 HighPart;
+	} u;
+	INT64 QuadPart;
 } LARGE_INTEGER;
 
-
 //
 // Register set pair for initialzation register set definition
 //
-typedef struct  _RTMP_REG_PAIR
-{
-	ULONG   Register;
-	ULONG   Value;
+typedef struct _RTMP_REG_PAIR {
+	ULONG Register;
+	ULONG Value;
 } RTMP_REG_PAIR, *PRTMP_REG_PAIR;
 
-typedef struct  _REG_PAIR
-{
-	UCHAR   Register;
-	UCHAR   Value;
+typedef struct _REG_PAIR {
+	UCHAR Register;
+	UCHAR Value;
 } REG_PAIR, *PREG_PAIR;
 
 //
 // Register set pair for initialzation register set definition
 //
-typedef struct  _RTMP_RF_REGS
-{
-	UCHAR   Channel;
-	ULONG   R1;
-	ULONG   R2;
-	ULONG   R3;
-	ULONG   R4;
+typedef struct _RTMP_RF_REGS {
+	UCHAR Channel;
+	ULONG R1;
+	ULONG R2;
+	ULONG R3;
+	ULONG R4;
 } RTMP_RF_REGS, *PRTMP_RF_REGS;
 
 typedef struct _FREQUENCY_ITEM {
-	UCHAR	Channel;
-	UCHAR	N;
-	UCHAR	R;
-	UCHAR	K;
+	UCHAR Channel;
+	UCHAR N;
+	UCHAR R;
+	UCHAR K;
 } FREQUENCY_ITEM, *PFREQUENCY_ITEM;
 
-
-typedef int				NTSTATUS;
-
+typedef int NTSTATUS;
 
 #define STATUS_SUCCESS				0x00
 #define STATUS_UNSUCCESSFUL		0x01
 
-#endif  // __RTMP_TYPE_H__ //
-
+#endif // __RTMP_TYPE_H__ //
--- a/drivers/staging/rt2860/rtusb_io.h
+++ b/drivers/staging/rt2860/rtusb_io.h
@@ -25,7 +25,6 @@
  *************************************************************************
 */
 
-
 #ifndef __RTUSB_IO_H__
 #define __RTUSB_IO_H__
 
@@ -60,8 +59,8 @@
 #define CMDTHREAD_SET_ASIC_WCID                     0x0D730226	// cmd
 #define CMDTHREAD_SET_ASIC_WCID_CIPHER              0x0D730227	// cmd
 #define CMDTHREAD_QKERIODIC_EXECUT                  0x0D73023D	// cmd
-#define RT_CMD_SET_KEY_TABLE                        0x0D730228  // cmd
-#define RT_CMD_SET_RX_WCID_TABLE                    0x0D730229  // cmd
+#define RT_CMD_SET_KEY_TABLE                        0x0D730228	// cmd
+#define RT_CMD_SET_RX_WCID_TABLE                    0x0D730229	// cmd
 #define CMDTHREAD_SET_CLIENT_MAC_ENTRY              0x0D73023E	// cmd
 #define CMDTHREAD_SET_GROUP_KEY						0x0D73023F	// cmd
 #define CMDTHREAD_SET_PAIRWISE_KEY					0x0D730240	// cmd
@@ -75,34 +74,31 @@
 #define CMDTHREAD_UPDATE_PROTECT					0x0D790103	// cmd
 // end johnli
 
-
 //CMDTHREAD_MULTI_READ_MAC
 //CMDTHREAD_MULTI_WRITE_MAC
 //CMDTHREAD_VENDOR_EEPROM_READ
 //CMDTHREAD_VENDOR_EEPROM_WRITE
-typedef	struct	_CMDHandler_TLV	{
-	USHORT		Offset;
-	USHORT		Length;
-	UCHAR		DataFirst;
-}	CMDHandler_TLV, *PCMDHandler_TLV;
-
-
-typedef	struct _CmdQElmt	{
-	UINT				command;
-	PVOID				buffer;
-	ULONG				bufferlength;
-	BOOLEAN				CmdFromNdis;
-	BOOLEAN				SetOperation;
-	struct _CmdQElmt	*next;
-}	CmdQElmt, *PCmdQElmt;
-
-typedef	struct	_CmdQ	{
-	UINT		size;
-	CmdQElmt	*head;
-	CmdQElmt	*tail;
-	UINT32		CmdQState;
-}CmdQ, *PCmdQ;
-
+typedef struct _CMDHandler_TLV {
+	USHORT Offset;
+	USHORT Length;
+	UCHAR DataFirst;
+} CMDHandler_TLV, *PCMDHandler_TLV;
+
+typedef struct _CmdQElmt {
+	UINT command;
+	PVOID buffer;
+	ULONG bufferlength;
+	BOOLEAN CmdFromNdis;
+	BOOLEAN SetOperation;
+	struct _CmdQElmt *next;
+} CmdQElmt, *PCmdQElmt;
+
+typedef struct _CmdQ {
+	UINT size;
+	CmdQElmt *head;
+	CmdQElmt *tail;
+	UINT32 CmdQState;
+} CmdQ, *PCmdQ;
 
 #define EnqueueCmd(cmdq, cmdqelmt)		\
 {										\
@@ -115,7 +111,6 @@ typedef	struct	_CmdQ	{
 	cmdq->size++;						\
 }
 
-
 /******************************************************************************
 
 	USB Cmd to ASIC Related MACRO
@@ -185,5 +180,4 @@ typedef	struct	_CmdQ	{
 			RTUSBEnqueueInternalCmd((_pAd), CMDTHREAD_SET_ASIC_WCID, &SetAsicWcid, sizeof(RT_SET_ASIC_WCID));	\
 		}while(0)
 
-
 #endif // __RTUSB_IO_H__ //
--- a/drivers/staging/rt2860/spectrum_def.h
+++ b/drivers/staging/rt2860/spectrum_def.h
@@ -39,69 +39,59 @@
 #ifndef __SPECTRUM_DEF_H__
 #define __SPECTRUM_DEF_H__
 
-
 #define MAX_MEASURE_REQ_TAB_SIZE		32
 #define MAX_HASH_MEASURE_REQ_TAB_SIZE	MAX_MEASURE_REQ_TAB_SIZE
 
 #define MAX_TPC_REQ_TAB_SIZE			32
 #define MAX_HASH_TPC_REQ_TAB_SIZE		MAX_TPC_REQ_TAB_SIZE
 
-#define MIN_RCV_PWR				100		/* Negative value ((dBm) */
+#define MIN_RCV_PWR				100	/* Negative value ((dBm) */
 
-#define TPC_REQ_AGE_OUT			500		/* ms */
-#define MQ_REQ_AGE_OUT			500		/* ms */
+#define TPC_REQ_AGE_OUT			500	/* ms */
+#define MQ_REQ_AGE_OUT			500	/* ms */
 
 #define TPC_DIALOGTOKEN_HASH_INDEX(_DialogToken)	((_DialogToken) % MAX_HASH_TPC_REQ_TAB_SIZE)
 #define MQ_DIALOGTOKEN_HASH_INDEX(_DialogToken)		((_DialogToken) % MAX_MEASURE_REQ_TAB_SIZE)
 
-typedef struct _MEASURE_REQ_ENTRY
-{
+typedef struct _MEASURE_REQ_ENTRY {
 	struct _MEASURE_REQ_ENTRY *pNext;
 	ULONG lastTime;
-	BOOLEAN	Valid;
+	BOOLEAN Valid;
 	UINT8 DialogToken;
 	UINT8 MeasureDialogToken[3];	// 0:basic measure, 1: CCA measure, 2: RPI_Histogram measure.
 } MEASURE_REQ_ENTRY, *PMEASURE_REQ_ENTRY;
 
-typedef struct _MEASURE_REQ_TAB
-{
+typedef struct _MEASURE_REQ_TAB {
 	UCHAR Size;
 	PMEASURE_REQ_ENTRY Hash[MAX_HASH_MEASURE_REQ_TAB_SIZE];
 	MEASURE_REQ_ENTRY Content[MAX_MEASURE_REQ_TAB_SIZE];
 } MEASURE_REQ_TAB, *PMEASURE_REQ_TAB;
 
-typedef struct _TPC_REQ_ENTRY
-{
+typedef struct _TPC_REQ_ENTRY {
 	struct _TPC_REQ_ENTRY *pNext;
 	ULONG lastTime;
 	BOOLEAN Valid;
 	UINT8 DialogToken;
 } TPC_REQ_ENTRY, *PTPC_REQ_ENTRY;
 
-typedef struct _TPC_REQ_TAB
-{
+typedef struct _TPC_REQ_TAB {
 	UCHAR Size;
 	PTPC_REQ_ENTRY Hash[MAX_HASH_TPC_REQ_TAB_SIZE];
 	TPC_REQ_ENTRY Content[MAX_TPC_REQ_TAB_SIZE];
 } TPC_REQ_TAB, *PTPC_REQ_TAB;
 
-
 /* The regulatory information */
-typedef struct _DOT11_CHANNEL_SET
-{
+typedef struct _DOT11_CHANNEL_SET {
 	UCHAR NumberOfChannels;
 	UINT8 MaxTxPwr;
 	UCHAR ChannelList[16];
 } DOT11_CHANNEL_SET, *PDOT11_CHANNEL_SET;
 
-typedef struct _DOT11_REGULATORY_INFORMATION
-{
+typedef struct _DOT11_REGULATORY_INFORMATION {
 	UCHAR RegulatoryClass;
 	DOT11_CHANNEL_SET ChannelSet;
 } DOT11_REGULATORY_INFORMATION, *PDOT11_REGULATORY_INFORMATION;
 
-
-
 #define RM_TPC_REQ				0
 #define RM_MEASURE_REQ			1
 
@@ -111,53 +101,44 @@ typedef struct _DOT11_REGULATORY_INFORMA
 #define RM_CH_LOAD				3
 #define RM_NOISE_HISTOGRAM		4
 
-
-typedef struct PACKED _TPC_REPORT_INFO
-{
+typedef struct PACKED _TPC_REPORT_INFO {
 	UINT8 TxPwr;
 	UINT8 LinkMargin;
 } TPC_REPORT_INFO, *PTPC_REPORT_INFO;
 
-typedef struct PACKED _CH_SW_ANN_INFO
-{
+typedef struct PACKED _CH_SW_ANN_INFO {
 	UINT8 ChSwMode;
 	UINT8 Channel;
 	UINT8 ChSwCnt;
 } CH_SW_ANN_INFO, *PCH_SW_ANN_INFO;
 
-typedef union PACKED _MEASURE_REQ_MODE
-{
-	struct PACKED
-	{
+typedef union PACKED _MEASURE_REQ_MODE {
+	struct PACKED {
 		UINT8 Parallel:1;
 		UINT8 Enable:1;
 		UINT8 Request:1;
 		UINT8 Report:1;
 		UINT8 DurationMandatory:1;
-		UINT8 :3;
+		 UINT8:3;
 	} field;
 	UINT8 word;
 } MEASURE_REQ_MODE, *PMEASURE_REQ_MODE;
 
-typedef struct PACKED _MEASURE_REQ
-{
+typedef struct PACKED _MEASURE_REQ {
 	UINT8 ChNum;
 	UINT64 MeasureStartTime;
 	UINT16 MeasureDuration;
 } MEASURE_REQ, *PMEASURE_REQ;
 
-typedef struct PACKED _MEASURE_REQ_INFO
-{
+typedef struct PACKED _MEASURE_REQ_INFO {
 	UINT8 Token;
 	MEASURE_REQ_MODE ReqMode;
 	UINT8 ReqType;
 	UINT8 Oct[0];
 } MEASURE_REQ_INFO, *PMEASURE_REQ_INFO;
 
-typedef union PACKED _MEASURE_BASIC_REPORT_MAP
-{
-	struct PACKED
-	{
+typedef union PACKED _MEASURE_BASIC_REPORT_MAP {
+	struct PACKED {
 		UINT8 BSS:1;
 
 		UINT8 OfdmPreamble:1;
@@ -169,34 +150,29 @@ typedef union PACKED _MEASURE_BASIC_REPO
 	UINT8 word;
 } MEASURE_BASIC_REPORT_MAP, *PMEASURE_BASIC_REPORT_MAP;
 
-typedef struct PACKED _MEASURE_BASIC_REPORT
-{
+typedef struct PACKED _MEASURE_BASIC_REPORT {
 	UINT8 ChNum;
 	UINT64 MeasureStartTime;
 	UINT16 MeasureDuration;
 	MEASURE_BASIC_REPORT_MAP Map;
 } MEASURE_BASIC_REPORT, *PMEASURE_BASIC_REPORT;
 
-typedef struct PACKED _MEASURE_CCA_REPORT
-{
+typedef struct PACKED _MEASURE_CCA_REPORT {
 	UINT8 ChNum;
 	UINT64 MeasureStartTime;
 	UINT16 MeasureDuration;
 	UINT8 CCA_Busy_Fraction;
 } MEASURE_CCA_REPORT, *PMEASURE_CCA_REPORT;
 
-typedef struct PACKED _MEASURE_RPI_REPORT
-{
+typedef struct PACKED _MEASURE_RPI_REPORT {
 	UINT8 ChNum;
 	UINT64 MeasureStartTime;
 	UINT16 MeasureDuration;
 	UINT8 RPI_Density[8];
 } MEASURE_RPI_REPORT, *PMEASURE_RPI_REPORT;
 
-typedef union PACKED _MEASURE_REPORT_MODE
-{
-	struct PACKED
-	{
+typedef union PACKED _MEASURE_REPORT_MODE {
+	struct PACKED {
 		UINT8 Late:1;
 		UINT8 Incapable:1;
 		UINT8 Refused:1;
@@ -205,16 +181,14 @@ typedef union PACKED _MEASURE_REPORT_MOD
 	UINT8 word;
 } MEASURE_REPORT_MODE, *PMEASURE_REPORT_MODE;
 
-typedef struct PACKED _MEASURE_REPORT_INFO
-{
+typedef struct PACKED _MEASURE_REPORT_INFO {
 	UINT8 Token;
 	UINT8 ReportMode;
 	UINT8 ReportType;
 	UINT8 Octect[0];
 } MEASURE_REPORT_INFO, *PMEASURE_REPORT_INFO;
 
-typedef struct PACKED _QUIET_INFO
-{
+typedef struct PACKED _QUIET_INFO {
 	UINT8 QuietCnt;
 	UINT8 QuietPeriod;
 	UINT16 QuietDuration;
@@ -222,4 +196,3 @@ typedef struct PACKED _QUIET_INFO
 } QUIET_INFO, *PQUIET_INFO;
 
 #endif // __SPECTRUM_DEF_H__ //
-
--- a/drivers/staging/rt2860/spectrum.h
+++ b/drivers/staging/rt2860/spectrum.h
@@ -31,10 +31,7 @@
 #include "rtmp_type.h"
 #include "spectrum_def.h"
 
-
-CHAR RTMP_GetTxPwr(
-	IN PRTMP_ADAPTER pAd,
-	IN HTTRANSMIT_SETTING HTTxMode);
+CHAR RTMP_GetTxPwr(IN PRTMP_ADAPTER pAd, IN HTTRANSMIT_SETTING HTTxMode);
 
 /*
 	==========================================================================
@@ -48,17 +45,16 @@ CHAR RTMP_GetTxPwr(
 	Return	: None.
 	==========================================================================
  */
-VOID MakeMeasurementReqFrame(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pOutBuffer,
-	OUT PULONG pFrameLen,
-	IN UINT8 TotalLen,
-	IN UINT8 Category,
-	IN UINT8 Action,
-	IN UINT8 MeasureToken,
-	IN UINT8 MeasureReqMode,
-	IN UINT8 MeasureReqType,
-	IN UINT8 NumOfRepetitions);
+VOID MakeMeasurementReqFrame(IN PRTMP_ADAPTER pAd,
+			     OUT PUCHAR pOutBuffer,
+			     OUT PULONG pFrameLen,
+			     IN UINT8 TotalLen,
+			     IN UINT8 Category,
+			     IN UINT8 Action,
+			     IN UINT8 MeasureToken,
+			     IN UINT8 MeasureReqMode,
+			     IN UINT8 MeasureReqType,
+			     IN UINT8 NumOfRepetitions);
 
 /*
 	==========================================================================
@@ -72,15 +68,13 @@ VOID MakeMeasurementReqFrame(
 	Return	: None.
 	==========================================================================
  */
-VOID EnqueueMeasurementRep(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pDA,
-	IN UINT8 DialogToken,
-	IN UINT8 MeasureToken,
-	IN UINT8 MeasureReqMode,
-	IN UINT8 MeasureReqType,
-	IN UINT8 ReportInfoLen,
-	IN PUINT8 pReportInfo);
+VOID EnqueueMeasurementRep(IN PRTMP_ADAPTER pAd,
+			   IN PUCHAR pDA,
+			   IN UINT8 DialogToken,
+			   IN UINT8 MeasureToken,
+			   IN UINT8 MeasureReqMode,
+			   IN UINT8 MeasureReqType,
+			   IN UINT8 ReportInfoLen, IN PUINT8 pReportInfo);
 
 /*
 	==========================================================================
@@ -94,10 +88,7 @@ VOID EnqueueMeasurementRep(
 	Return	: None.
 	==========================================================================
  */
-VOID EnqueueTPCReq(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pDA,
-	IN UCHAR DialogToken);
+VOID EnqueueTPCReq(IN PRTMP_ADAPTER pAd, IN PUCHAR pDA, IN UCHAR DialogToken);
 
 /*
 	==========================================================================
@@ -111,12 +102,9 @@ VOID EnqueueTPCReq(
 	Return	: None.
 	==========================================================================
  */
-VOID EnqueueTPCRep(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pDA,
-	IN UINT8 DialogToken,
-	IN UINT8 TxPwr,
-	IN UINT8 LinkMargin);
+VOID EnqueueTPCRep(IN PRTMP_ADAPTER pAd,
+		   IN PUCHAR pDA,
+		   IN UINT8 DialogToken, IN UINT8 TxPwr, IN UINT8 LinkMargin);
 
 /*
 	==========================================================================
@@ -132,11 +120,8 @@ VOID EnqueueTPCRep(
 	Return	: None.
 	==========================================================================
  */
-VOID EnqueueChSwAnn(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pDA,
-	IN UINT8 ChSwMode,
-	IN UINT8 NewCh);
+VOID EnqueueChSwAnn(IN PRTMP_ADAPTER pAd,
+		    IN PUCHAR pDA, IN UINT8 ChSwMode, IN UINT8 NewCh);
 
 /*
 	==========================================================================
@@ -150,9 +135,7 @@ VOID EnqueueChSwAnn(
 	Return	: None.
 	==========================================================================
  */
-VOID PeerSpectrumAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem);
+VOID PeerSpectrumAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem);
 
 /*
 	==========================================================================
@@ -163,73 +146,44 @@ VOID PeerSpectrumAction(
 	Return	: None.
 	==========================================================================
  */
-INT Set_MeasureReq_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg);
-
-INT Set_TpcReq_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg);
+INT Set_MeasureReq_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg);
 
-INT Set_PwrConstraint(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg);
+INT Set_TpcReq_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg);
 
+INT Set_PwrConstraint(IN PRTMP_ADAPTER pAd, IN PSTRING arg);
 
-VOID MeasureReqTabInit(
-	IN PRTMP_ADAPTER pAd);
+VOID MeasureReqTabInit(IN PRTMP_ADAPTER pAd);
 
-VOID MeasureReqTabExit(
-	IN PRTMP_ADAPTER pAd);
+VOID MeasureReqTabExit(IN PRTMP_ADAPTER pAd);
 
-PMEASURE_REQ_ENTRY MeasureReqLookUp(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken);
+PMEASURE_REQ_ENTRY MeasureReqLookUp(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken);
 
-PMEASURE_REQ_ENTRY MeasureReqInsert(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken);
+PMEASURE_REQ_ENTRY MeasureReqInsert(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken);
 
-VOID MeasureReqDelete(
-	IN PRTMP_ADAPTER	pAd,
-	IN UINT8			DialogToken);
+VOID MeasureReqDelete(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken);
 
-VOID InsertChannelRepIE(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN PSTRING pCountry,
-	IN UINT8 RegulatoryClass);
+VOID InsertChannelRepIE(IN PRTMP_ADAPTER pAd,
+			OUT PUCHAR pFrameBuf,
+			OUT PULONG pFrameLen,
+			IN PSTRING pCountry, IN UINT8 RegulatoryClass);
 
-VOID InsertTpcReportIE(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN UINT8 TxPwr,
-	IN UINT8 LinkMargin);
+VOID InsertTpcReportIE(IN PRTMP_ADAPTER pAd,
+		       OUT PUCHAR pFrameBuf,
+		       OUT PULONG pFrameLen,
+		       IN UINT8 TxPwr, IN UINT8 LinkMargin);
 
-VOID InsertDialogToken(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN UINT8 DialogToken);
+VOID InsertDialogToken(IN PRTMP_ADAPTER pAd,
+		       OUT PUCHAR pFrameBuf,
+		       OUT PULONG pFrameLen, IN UINT8 DialogToken);
 
-VOID TpcReqTabInit(
-	IN PRTMP_ADAPTER pAd);
+VOID TpcReqTabInit(IN PRTMP_ADAPTER pAd);
 
-VOID TpcReqTabExit(
-	IN PRTMP_ADAPTER pAd);
+VOID TpcReqTabExit(IN PRTMP_ADAPTER pAd);
 
-VOID NotifyChSwAnnToPeerAPs(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pRA,
-	IN PUCHAR pTA,
-	IN UINT8 ChSwMode,
-	IN UINT8 Channel);
+VOID NotifyChSwAnnToPeerAPs(IN PRTMP_ADAPTER pAd,
+			    IN PUCHAR pRA,
+			    IN PUCHAR pTA, IN UINT8 ChSwMode, IN UINT8 Channel);
 
-VOID RguClass_BuildBcnChList(
-	IN PRTMP_ADAPTER pAd,
-	OUT PUCHAR pBuf,
-	OUT	PULONG pBufLen);
+VOID RguClass_BuildBcnChList(IN PRTMP_ADAPTER pAd,
+			     OUT PUCHAR pBuf, OUT PULONG pBufLen);
 #endif // __SPECTRUM_H__ //
-
--- a/drivers/staging/rt2860/wpa.h
+++ b/drivers/staging/rt2860/wpa.h
@@ -126,12 +126,12 @@
 
 //#ifdef CONFIG_AP_SUPPORT
 // WPA mechanism retry timer interval
-#define PEER_MSG1_RETRY_EXEC_INTV           1000			// 1 sec
-#define PEER_MSG3_RETRY_EXEC_INTV           3000			// 3 sec
-#define GROUP_KEY_UPDATE_EXEC_INTV          1000				// 1 sec
-#define PEER_GROUP_KEY_UPDATE_INIV			2000				// 2 sec
+#define PEER_MSG1_RETRY_EXEC_INTV           1000	// 1 sec
+#define PEER_MSG3_RETRY_EXEC_INTV           3000	// 3 sec
+#define GROUP_KEY_UPDATE_EXEC_INTV          1000	// 1 sec
+#define PEER_GROUP_KEY_UPDATE_INIV			2000	// 2 sec
 
-#define ENQUEUE_EAPOL_START_TIMER			200					// 200 ms
+#define ENQUEUE_EAPOL_START_TIMER			200	// 200 ms
 
 // group rekey interval
 #define TIME_REKEY                          0
@@ -147,7 +147,6 @@
 #define AKM_SUITE					2
 #define PMKID_LIST					3
 
-
 #define EAPOL_START_DISABLE					0
 #define EAPOL_START_PSK						1
 #define EAPOL_START_1X						2
@@ -181,7 +180,6 @@
 
 #define	CONV_ARRARY_TO_UINT16(_V)	((_V[0]<<8) | (_V[1]))
 
-
 #define	ADD_ONE_To_64BIT_VAR(_V)		\
 {										\
 	UCHAR	cnt = LEN_KEY_DESC_REPLAY;	\
@@ -197,224 +195,199 @@
 #define IS_WPA_CAPABILITY(a)       (((a) >= Ndis802_11AuthModeWPA) && ((a) <= Ndis802_11AuthModeWPA1PSKWPA2PSK))
 
 // EAPOL Key Information definition within Key descriptor format
-typedef	struct PACKED _KEY_INFO
-{
-	UCHAR	KeyMic:1;
-	UCHAR	Secure:1;
-	UCHAR	Error:1;
-	UCHAR	Request:1;
-	UCHAR	EKD_DL:1;       // EKD for AP; DL for STA
-	UCHAR	Rsvd:3;
-	UCHAR	KeyDescVer:3;
-	UCHAR	KeyType:1;
-	UCHAR	KeyIndex:2;
-	UCHAR	Install:1;
-	UCHAR	KeyAck:1;
-}	KEY_INFO, *PKEY_INFO;
+typedef struct PACKED _KEY_INFO {
+	UCHAR KeyMic:1;
+	UCHAR Secure:1;
+	UCHAR Error:1;
+	UCHAR Request:1;
+	UCHAR EKD_DL:1;		// EKD for AP; DL for STA
+	UCHAR Rsvd:3;
+	UCHAR KeyDescVer:3;
+	UCHAR KeyType:1;
+	UCHAR KeyIndex:2;
+	UCHAR Install:1;
+	UCHAR KeyAck:1;
+} KEY_INFO, *PKEY_INFO;
 
 // EAPOL Key descriptor format
-typedef	struct PACKED _KEY_DESCRIPTER
-{
-	UCHAR		Type;
-	KEY_INFO	KeyInfo;
-	UCHAR		KeyLength[2];
-	UCHAR		ReplayCounter[LEN_KEY_DESC_REPLAY];
-	UCHAR		KeyNonce[LEN_KEY_DESC_NONCE];
-	UCHAR		KeyIv[LEN_KEY_DESC_IV];
-	UCHAR		KeyRsc[LEN_KEY_DESC_RSC];
-	UCHAR		KeyId[LEN_KEY_DESC_ID];
-	UCHAR		KeyMic[LEN_KEY_DESC_MIC];
-	UCHAR		KeyDataLen[2];
-	UCHAR		KeyData[MAX_LEN_OF_RSNIE];
-}	KEY_DESCRIPTER, *PKEY_DESCRIPTER;
-
-typedef	struct PACKED _EAPOL_PACKET
-{
-	UCHAR	 			ProVer;
-	UCHAR	 			ProType;
-	UCHAR	 			Body_Len[2];
-	KEY_DESCRIPTER		KeyDesc;
-}	EAPOL_PACKET, *PEAPOL_PACKET;
+typedef struct PACKED _KEY_DESCRIPTER {
+	UCHAR Type;
+	KEY_INFO KeyInfo;
+	UCHAR KeyLength[2];
+	UCHAR ReplayCounter[LEN_KEY_DESC_REPLAY];
+	UCHAR KeyNonce[LEN_KEY_DESC_NONCE];
+	UCHAR KeyIv[LEN_KEY_DESC_IV];
+	UCHAR KeyRsc[LEN_KEY_DESC_RSC];
+	UCHAR KeyId[LEN_KEY_DESC_ID];
+	UCHAR KeyMic[LEN_KEY_DESC_MIC];
+	UCHAR KeyDataLen[2];
+	UCHAR KeyData[MAX_LEN_OF_RSNIE];
+} KEY_DESCRIPTER, *PKEY_DESCRIPTER;
+
+typedef struct PACKED _EAPOL_PACKET {
+	UCHAR ProVer;
+	UCHAR ProType;
+	UCHAR Body_Len[2];
+	KEY_DESCRIPTER KeyDesc;
+} EAPOL_PACKET, *PEAPOL_PACKET;
 
 //802.11i D10 page 83
-typedef struct PACKED _GTK_ENCAP
-{
-    UCHAR               Kid:2;
-    UCHAR               tx:1;
-    UCHAR               rsv:5;
-    UCHAR               rsv1;
-    UCHAR               GTK[TKIP_GTK_LENGTH];
-}   GTK_ENCAP, *PGTK_ENCAP;
-
-typedef struct PACKED _KDE_ENCAP
-{
-    UCHAR               Type;
-    UCHAR               Len;
-    UCHAR               OUI[3];
-    UCHAR               DataType;
-    GTK_ENCAP      GTKEncap;
-}   KDE_ENCAP, *PKDE_ENCAP;
+typedef struct PACKED _GTK_ENCAP {
+	UCHAR Kid:2;
+	UCHAR tx:1;
+	UCHAR rsv:5;
+	UCHAR rsv1;
+	UCHAR GTK[TKIP_GTK_LENGTH];
+} GTK_ENCAP, *PGTK_ENCAP;
+
+typedef struct PACKED _KDE_ENCAP {
+	UCHAR Type;
+	UCHAR Len;
+	UCHAR OUI[3];
+	UCHAR DataType;
+	GTK_ENCAP GTKEncap;
+} KDE_ENCAP, *PKDE_ENCAP;
 
 // For WPA1
 typedef struct PACKED _RSNIE {
-    UCHAR   oui[4];
-    USHORT  version;
-    UCHAR   mcast[4];
-    USHORT  ucount;
-    struct PACKED {
-        UCHAR oui[4];
-    }ucast[1];
+	UCHAR oui[4];
+	USHORT version;
+	UCHAR mcast[4];
+	USHORT ucount;
+	struct PACKED {
+		UCHAR oui[4];
+	} ucast[1];
 } RSNIE, *PRSNIE;
 
 // For WPA2
 typedef struct PACKED _RSNIE2 {
-    USHORT  version;
-    UCHAR   mcast[4];
-    USHORT  ucount;
-    struct PACKED {
-        UCHAR oui[4];
-    }ucast[1];
+	USHORT version;
+	UCHAR mcast[4];
+	USHORT ucount;
+	struct PACKED {
+		UCHAR oui[4];
+	} ucast[1];
 } RSNIE2, *PRSNIE2;
 
 // AKM Suite
 typedef struct PACKED _RSNIE_AUTH {
-    USHORT acount;
-    struct PACKED {
-        UCHAR oui[4];
-    }auth[1];
-} RSNIE_AUTH,*PRSNIE_AUTH;
-
-typedef	union PACKED _RSN_CAPABILITIES	{
-	struct	PACKED {
-        USHORT		PreAuth:1;
-		USHORT		No_Pairwise:1;
-		USHORT		PTKSA_R_Counter:2;
-		USHORT		GTKSA_R_Counter:2;
-		USHORT		Rsvd:10;
-	}	field;
-	USHORT			word;
-}	RSN_CAPABILITIES, *PRSN_CAPABILITIES;
+	USHORT acount;
+	struct PACKED {
+		UCHAR oui[4];
+	} auth[1];
+} RSNIE_AUTH, *PRSNIE_AUTH;
+
+typedef union PACKED _RSN_CAPABILITIES {
+	struct PACKED {
+		USHORT PreAuth:1;
+		USHORT No_Pairwise:1;
+		USHORT PTKSA_R_Counter:2;
+		USHORT GTKSA_R_Counter:2;
+		USHORT Rsvd:10;
+	} field;
+	USHORT word;
+} RSN_CAPABILITIES, *PRSN_CAPABILITIES;
 
 typedef struct PACKED _EAP_HDR {
-    UCHAR   ProVer;
-    UCHAR   ProType;
-    UCHAR   Body_Len[2];
-    UCHAR   code;
-    UCHAR   identifier;
-    UCHAR   length[2]; // including code and identifier, followed by length-2 octets of data
+	UCHAR ProVer;
+	UCHAR ProType;
+	UCHAR Body_Len[2];
+	UCHAR code;
+	UCHAR identifier;
+	UCHAR length[2];	// including code and identifier, followed by length-2 octets of data
 } EAP_HDR, *PEAP_HDR;
 
 // For supplicant state machine states. 802.11i Draft 4.1, p. 97
 // We simplified it
-typedef	enum	_WpaState
-{
-	SS_NOTUSE,				// 0
-	SS_START,				// 1
-	SS_WAIT_MSG_3,			// 2
-	SS_WAIT_GROUP,			// 3
-	SS_FINISH,  			// 4
-	SS_KEYUPDATE,			// 5
-}	WPA_STATE;
+typedef enum _WpaState {
+	SS_NOTUSE,		// 0
+	SS_START,		// 1
+	SS_WAIT_MSG_3,		// 2
+	SS_WAIT_GROUP,		// 3
+	SS_FINISH,		// 4
+	SS_KEYUPDATE,		// 5
+} WPA_STATE;
 
 //
-//	The definition of the cipher combination
+//      The definition of the cipher combination
 //
-// 	 bit3	bit2  bit1   bit0
-//	+------------+------------+
-// 	|	  WPA	 |	   WPA2   |
-//	+------+-----+------+-----+
-//	| TKIP | AES | TKIP | AES |
-//	|	0  |  1  |   1  |  0  | -> 0x06
-//	|	0  |  1  |   1  |  1  | -> 0x07
-//	|	1  |  0  |   0  |  1  | -> 0x09
-//	|	1  |  0  |   1  |  1  | -> 0x0B
-//	|	1  |  1  |   0  |  1  | -> 0x0D
-//	|	1  |  1  |   1  |  0  | -> 0x0E
-//	|	1  |  1  |   1  |  1  |	-> 0x0F
-//	+------+-----+------+-----+
+//       bit3   bit2  bit1   bit0
+//      +------------+------------+
+//      |         WPA    |         WPA2   |
+//      +------+-----+------+-----+
+//      | TKIP | AES | TKIP | AES |
+//      |       0  |  1  |   1  |  0  | -> 0x06
+//      |       0  |  1  |   1  |  1  | -> 0x07
+//      |       1  |  0  |   0  |  1  | -> 0x09
+//      |       1  |  0  |   1  |  1  | -> 0x0B
+//      |       1  |  1  |   0  |  1  | -> 0x0D
+//      |       1  |  1  |   1  |  0  | -> 0x0E
+//      |       1  |  1  |   1  |  1  | -> 0x0F
+//      +------+-----+------+-----+
 //
-typedef	enum	_WpaMixPairCipher
-{
-	MIX_CIPHER_NOTUSE 			= 0x00,
-	WPA_NONE_WPA2_TKIPAES		= 0x03,		// WPA2-TKIPAES
-	WPA_AES_WPA2_TKIP 			= 0x06,
-	WPA_AES_WPA2_TKIPAES		= 0x07,
-	WPA_TKIP_WPA2_AES			= 0x09,
-	WPA_TKIP_WPA2_TKIPAES		= 0x0B,
-	WPA_TKIPAES_WPA2_NONE		= 0x0C,		// WPA-TKIPAES
-	WPA_TKIPAES_WPA2_AES		= 0x0D,
-	WPA_TKIPAES_WPA2_TKIP		= 0x0E,
-	WPA_TKIPAES_WPA2_TKIPAES	= 0x0F,
-}	WPA_MIX_PAIR_CIPHER;
-
-typedef struct PACKED _RSN_IE_HEADER_STRUCT	{
-	UCHAR		Eid;
-	UCHAR		Length;
-	USHORT		Version;	// Little endian format
-}	RSN_IE_HEADER_STRUCT, *PRSN_IE_HEADER_STRUCT;
+typedef enum _WpaMixPairCipher {
+	MIX_CIPHER_NOTUSE = 0x00,
+	WPA_NONE_WPA2_TKIPAES = 0x03,	// WPA2-TKIPAES
+	WPA_AES_WPA2_TKIP = 0x06,
+	WPA_AES_WPA2_TKIPAES = 0x07,
+	WPA_TKIP_WPA2_AES = 0x09,
+	WPA_TKIP_WPA2_TKIPAES = 0x0B,
+	WPA_TKIPAES_WPA2_NONE = 0x0C,	// WPA-TKIPAES
+	WPA_TKIPAES_WPA2_AES = 0x0D,
+	WPA_TKIPAES_WPA2_TKIP = 0x0E,
+	WPA_TKIPAES_WPA2_TKIPAES = 0x0F,
+} WPA_MIX_PAIR_CIPHER;
+
+typedef struct PACKED _RSN_IE_HEADER_STRUCT {
+	UCHAR Eid;
+	UCHAR Length;
+	USHORT Version;		// Little endian format
+} RSN_IE_HEADER_STRUCT, *PRSN_IE_HEADER_STRUCT;
 
 // Cipher suite selector types
-typedef struct PACKED _CIPHER_SUITE_STRUCT	{
-	UCHAR		Oui[3];
-	UCHAR		Type;
-}	CIPHER_SUITE_STRUCT, *PCIPHER_SUITE_STRUCT;
+typedef struct PACKED _CIPHER_SUITE_STRUCT {
+	UCHAR Oui[3];
+	UCHAR Type;
+} CIPHER_SUITE_STRUCT, *PCIPHER_SUITE_STRUCT;
 
 // Authentication and Key Management suite selector
-typedef struct PACKED _AKM_SUITE_STRUCT	{
-	UCHAR		Oui[3];
-	UCHAR		Type;
-}	AKM_SUITE_STRUCT, *PAKM_SUITE_STRUCT;
+typedef struct PACKED _AKM_SUITE_STRUCT {
+	UCHAR Oui[3];
+	UCHAR Type;
+} AKM_SUITE_STRUCT, *PAKM_SUITE_STRUCT;
 
 // RSN capability
-typedef struct	PACKED _RSN_CAPABILITY	{
-	USHORT		Rsv:10;
-	USHORT		GTKSAReplayCnt:2;
-	USHORT		PTKSAReplayCnt:2;
-	USHORT		NoPairwise:1;
-	USHORT		PreAuth:1;
-}	RSN_CAPABILITY, *PRSN_CAPABILITY;
-
+typedef struct PACKED _RSN_CAPABILITY {
+	USHORT Rsv:10;
+	USHORT GTKSAReplayCnt:2;
+	USHORT PTKSAReplayCnt:2;
+	USHORT NoPairwise:1;
+	USHORT PreAuth:1;
+} RSN_CAPABILITY, *PRSN_CAPABILITY;
 
 /*========================================
 	The prototype is defined in cmm_wpa.c
   ========================================*/
-BOOLEAN WpaMsgTypeSubst(
-	IN  UCHAR   EAPType,
-	OUT INT		*MsgType);
-
-VOID    PRF(
-	IN  UCHAR   *key,
-	IN  INT     key_len,
-	IN  UCHAR   *prefix,
-	IN  INT     prefix_len,
-	IN  UCHAR   *data,
-	IN  INT     data_len,
-	OUT UCHAR   *output,
-	IN  INT     len);
-
-int PasswordHash(
-	char *password,
-	unsigned char *ssid,
-	int ssidlength,
-	unsigned char *output);
-
-PUINT8	GetSuiteFromRSNIE(
-		IN	PUINT8	rsnie,
-		IN	UINT	rsnie_len,
-		IN	UINT8	type,
-		OUT	UINT8	*count);
-
-VOID WpaShowAllsuite(
-	IN	PUINT8	rsnie,
-	IN	UINT	rsnie_len);
-
-VOID RTMPInsertRSNIE(
-	IN PUCHAR pFrameBuf,
-	OUT PULONG pFrameLen,
-	IN PUINT8 rsnie_ptr,
-	IN UINT8  rsnie_len,
-	IN PUINT8 pmkid_ptr,
-	IN UINT8  pmkid_len);
+BOOLEAN WpaMsgTypeSubst(IN UCHAR EAPType, OUT INT * MsgType);
 
+VOID PRF(IN UCHAR * key,
+	 IN INT key_len,
+	 IN UCHAR * prefix,
+	 IN INT prefix_len,
+	 IN UCHAR * data, IN INT data_len, OUT UCHAR * output, IN INT len);
+
+int PasswordHash(char *password,
+		 unsigned char *ssid, int ssidlength, unsigned char *output);
+
+PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
+			 IN UINT rsnie_len, IN UINT8 type, OUT UINT8 * count);
+
+VOID WpaShowAllsuite(IN PUINT8 rsnie, IN UINT rsnie_len);
+
+VOID RTMPInsertRSNIE(IN PUCHAR pFrameBuf,
+		     OUT PULONG pFrameLen,
+		     IN PUINT8 rsnie_ptr,
+		     IN UINT8 rsnie_len,
+		     IN PUINT8 pmkid_ptr, IN UINT8 pmkid_len);
 
 #endif
