From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Subject: Staging: rt28x0: run *.c files through Lindent

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2860/chips/rt3070.c      |   74 
 drivers/staging/rt2860/chips/rt3090.c      |   32 
 drivers/staging/rt2860/chips/rt30xx.c      |  273 +-
 drivers/staging/rt2860/pci_main_dev.c      | 1014 ++++----
 drivers/staging/rt2860/rt_linux.c          | 1073 ++++-----
 drivers/staging/rt2860/rt_main_dev.c       |  409 +--
 drivers/staging/rt2860/rt_pci_rbus.c       |  505 +---
 drivers/staging/rt2860/rt_usb.c            |  659 ++---
 drivers/staging/rt2860/sta_ioctl.c         | 3433 +++++++++++++++--------------
 drivers/staging/rt2860/usb_main_dev.c      |  703 ++---
 drivers/staging/rt2870/common/rtusb_bulk.c |  900 +++----
 drivers/staging/rt2870/common/rtusb_data.c |  179 -
 drivers/staging/rt2870/common/rtusb_io.c   | 2382 +++++++++++---------
 13 files changed, 5958 insertions(+), 5678 deletions(-)

--- a/drivers/staging/rt2860/chips/rt3070.c
+++ b/drivers/staging/rt2860/chips/rt3070.c
@@ -39,12 +39,10 @@
 
 #include "../rt_config.h"
 
-
 #ifndef RTMP_RF_RW_SUPPORT
 #error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
 #endif // RTMP_RF_RW_SUPPORT //
 
-
 VOID NICInitRT3070RFRegisters(IN PRTMP_ADAPTER pAd)
 {
 	INT i;
@@ -52,61 +50,55 @@ VOID NICInitRT3070RFRegisters(IN PRTMP_A
 
 	// Driver must read EEPROM to get RfIcType before initial RF registers
 	// Initialize RF register to default value
-	if (IS_RT3070(pAd) || IS_RT3071(pAd))
-	{
+	if (IS_RT3070(pAd) || IS_RT3071(pAd)) {
 		// Init RF calibration
 		// Driver should toggle RF R30 bit7 before init RF registers
 		UINT32 RfReg = 0;
 		UINT32 data;
 
-		RT30xxReadRFRegister(pAd, RF_R30, (PUCHAR)&RfReg);
+		RT30xxReadRFRegister(pAd, RF_R30, (PUCHAR) & RfReg);
 		RfReg |= 0x80;
-		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR)RfReg);
+		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR) RfReg);
 		RTMPusecDelay(1000);
 		RfReg &= 0x7F;
-		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR)RfReg);
+		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR) RfReg);
 
 		// Initialize RF register to default value
-		for (i = 0; i < NUM_RF_REG_PARMS; i++)
-		{
-			RT30xxWriteRFRegister(pAd, RT30xx_RFRegTable[i].Register, RT30xx_RFRegTable[i].Value);
+		for (i = 0; i < NUM_RF_REG_PARMS; i++) {
+			RT30xxWriteRFRegister(pAd,
+					      RT30xx_RFRegTable[i].Register,
+					      RT30xx_RFRegTable[i].Value);
 		}
 
 		// add by johnli
-		if (IS_RT3070(pAd))
-		{
+		if (IS_RT3070(pAd)) {
 			//
 			// The DAC issue(LDO_CFG0) has been fixed in RT3070(F).
 			// The voltage raising patch is no longer needed for RT3070(F)
 			//
-			if ((pAd->MACVersion & 0xffff) < 0x0201)
-			{
+			if ((pAd->MACVersion & 0xffff) < 0x0201) {
 				//  Update MAC 0x05D4 from 01xxxxxx to 0Dxxxxxx (voltage 1.2V to 1.35V) for RT3070 to improve yield rate
 				RTUSBReadMACRegister(pAd, LDO_CFG0, &data);
 				data = ((data & 0xF0FFFFFF) | 0x0D000000);
 				RTUSBWriteMACRegister(pAd, LDO_CFG0, data);
 			}
-		}
-		else if (IS_RT3071(pAd))
-		{
+		} else if (IS_RT3071(pAd)) {
 			// Driver should set RF R6 bit6 on before init RF registers
-			RT30xxReadRFRegister(pAd, RF_R06, (PUCHAR)&RfReg);
+			RT30xxReadRFRegister(pAd, RF_R06, (PUCHAR) & RfReg);
 			RfReg |= 0x40;
-			RT30xxWriteRFRegister(pAd, RF_R06, (UCHAR)RfReg);
+			RT30xxWriteRFRegister(pAd, RF_R06, (UCHAR) RfReg);
 
 			// init R31
 			RT30xxWriteRFRegister(pAd, RF_R31, 0x14);
 
 			// RT3071 version E has fixed this issue
-			if ((pAd->NicConfig2.field.DACTestBit == 1) && ((pAd->MACVersion & 0xffff) < 0x0211))
-			{
+			if ((pAd->NicConfig2.field.DACTestBit == 1)
+			    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
 				// patch tx EVM issue temporarily
 				RTUSBReadMACRegister(pAd, LDO_CFG0, &data);
 				data = ((data & 0xE0FFFFFF) | 0x0D000000);
 				RTUSBWriteMACRegister(pAd, LDO_CFG0, data);
-			}
-			else
-			{
+			} else {
 				RTMP_IO_READ32(pAd, LDO_CFG0, &data);
 				data = ((data & 0xE0FFFFFF) | 0x01000000);
 				RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
@@ -117,8 +109,7 @@ VOID NICInitRT3070RFRegisters(IN PRTMP_A
 			data &= ~(0x20);
 			RTUSBWriteMACRegister(pAd, GPIO_SWITCH, data);
 		}
-
-                //For RF filter Calibration
+		//For RF filter Calibration
 		RTMPFilterCalibration(pAd);
 
 		// Initialize RF R27 register, set RF R27 must be behind RTMPFilterCalibration()
@@ -126,15 +117,12 @@ VOID NICInitRT3070RFRegisters(IN PRTMP_A
 		// TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F).
 		// Raising RF voltage is no longer needed for RT3070(F)
 		//
-		if ((IS_RT3070(pAd)) && ((pAd->MACVersion & 0xffff) < 0x0201))
-		{
+		if ((IS_RT3070(pAd)) && ((pAd->MACVersion & 0xffff) < 0x0201)) {
 			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
-		}
-		else if ((IS_RT3071(pAd)) && ((pAd->MACVersion & 0xffff) < 0x0211))
-		{
+		} else if ((IS_RT3071(pAd))
+			   && ((pAd->MACVersion & 0xffff) < 0x0211)) {
 			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
 		}
-
 		// set led open drain enable
 		RTUSBReadMACRegister(pAd, OPT_14, &data);
 		data |= 0x01;
@@ -145,29 +133,25 @@ VOID NICInitRT3070RFRegisters(IN PRTMP_A
 		RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
 		RFValue &= (~0x08);
 		// to fix rx long range issue
-		if (pAd->NicConfig2.field.ExternalLNAForG == 0)
-		{
-			if ((IS_RT3071(pAd) && ((pAd->MACVersion & 0xffff) >= 0x0211)) || IS_RT3070(pAd))
-			{
+		if (pAd->NicConfig2.field.ExternalLNAForG == 0) {
+			if ((IS_RT3071(pAd)
+			     && ((pAd->MACVersion & 0xffff) >= 0x0211))
+			    || IS_RT3070(pAd)) {
 				RFValue |= 0x20;
 			}
 		}
 		// set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h
-		if (pAd->TxMixerGain24G >= 1)
-		{
-			RFValue &= (~0x7);  // clean bit [2:0]
+		if (pAd->TxMixerGain24G >= 1) {
+			RFValue &= (~0x7);	// clean bit [2:0]
 			RFValue |= pAd->TxMixerGain24G;
 		}
 		RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
 
-		if (IS_RT3071(pAd))
-		{
+		if (IS_RT3071(pAd)) {
 			// add by johnli, RF power sequence setup, load RF normal operation-mode setup
 			RT30xxLoadRFNormalModeSetup(pAd);
-		}
-		else if (IS_RT3070(pAd))
-		{
-			/* add by johnli, reset RF_R27 when interface down & up to fix throughput problem*/
+		} else if (IS_RT3070(pAd)) {
+			/* add by johnli, reset RF_R27 when interface down & up to fix throughput problem */
 			// LDORF_VC, RF R27 register Bit 2 to 0
 			RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
 			// TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F).
--- a/drivers/staging/rt2860/chips/rt3090.c
+++ b/drivers/staging/rt2860/chips/rt3090.c
@@ -39,44 +39,39 @@
 
 #include "../rt_config.h"
 
-
 #ifndef RTMP_RF_RW_SUPPORT
 #error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
 #endif // RTMP_RF_RW_SUPPORT //
 
-
 VOID NICInitRT3090RFRegisters(IN PRTMP_ADAPTER pAd)
 {
-		INT i;
+	INT i;
 	// Driver must read EEPROM to get RfIcType before initial RF registers
 	// Initialize RF register to default value
-	if (IS_RT3090(pAd))
-	{
+	if (IS_RT3090(pAd)) {
 		// Init RF calibration
 		// Driver should toggle RF R30 bit7 before init RF registers
 		UINT32 RfReg = 0, data;
 
-		RT30xxReadRFRegister(pAd, RF_R30, (PUCHAR)&RfReg);
+		RT30xxReadRFRegister(pAd, RF_R30, (PUCHAR) & RfReg);
 		RfReg |= 0x80;
-		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR)RfReg);
+		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR) RfReg);
 		RTMPusecDelay(1000);
 		RfReg &= 0x7F;
-		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR)RfReg);
+		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR) RfReg);
 
 		// init R24, R31
 		RT30xxWriteRFRegister(pAd, RF_R24, 0x0F);
 		RT30xxWriteRFRegister(pAd, RF_R31, 0x0F);
 
 		// RT309x version E has fixed this issue
-		if ((pAd->NicConfig2.field.DACTestBit == 1) && ((pAd->MACVersion & 0xffff) < 0x0211))
-		{
+		if ((pAd->NicConfig2.field.DACTestBit == 1)
+		    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
 			// patch tx EVM issue temporarily
 			RTMP_IO_READ32(pAd, LDO_CFG0, &data);
 			data = ((data & 0xE0FFFFFF) | 0x0D000000);
 			RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
-		}
-		else
-		{
+		} else {
 			RTMP_IO_READ32(pAd, LDO_CFG0, &data);
 			data = ((data & 0xE0FFFFFF) | 0x01000000);
 			RTMP_IO_WRITE32(pAd, LDO_CFG0, data);
@@ -88,15 +83,16 @@ VOID NICInitRT3090RFRegisters(IN PRTMP_A
 		RTMP_IO_WRITE32(pAd, GPIO_SWITCH, data);
 
 		// Initialize RF register to default value
-		for (i = 0; i < NUM_RF_REG_PARMS; i++)
-		{
-			RT30xxWriteRFRegister(pAd, RT30xx_RFRegTable[i].Register, RT30xx_RFRegTable[i].Value);
+		for (i = 0; i < NUM_RF_REG_PARMS; i++) {
+			RT30xxWriteRFRegister(pAd,
+					      RT30xx_RFRegTable[i].Register,
+					      RT30xx_RFRegTable[i].Value);
 		}
 
 		// Driver should set RF R6 bit6 on before calibration
-		RT30xxReadRFRegister(pAd, RF_R06, (PUCHAR)&RfReg);
+		RT30xxReadRFRegister(pAd, RF_R06, (PUCHAR) & RfReg);
 		RfReg |= 0x40;
-		RT30xxWriteRFRegister(pAd, RF_R06, (UCHAR)RfReg);
+		RT30xxWriteRFRegister(pAd, RF_R06, (UCHAR) RfReg);
 
 		//For RF filter Calibration
 		RTMPFilterCalibration(pAd);
--- a/drivers/staging/rt2860/chips/rt30xx.c
+++ b/drivers/staging/rt2860/chips/rt30xx.c
@@ -35,73 +35,82 @@
 	--------    ----------    ----------------------------------------------
 */
 
-
 #ifdef RT30xx
 
-
 #ifndef RTMP_RF_RW_SUPPORT
 #error "You Should Enable compile flag RTMP_RF_RW_SUPPORT for this chip"
 #endif // RTMP_RF_RW_SUPPORT //
 
 #include "../rt_config.h"
 
-
 //
 // RF register initialization set
 //
-REG_PAIR   RT30xx_RFRegTable[] = {
-        {RF_R04,          0x40},
-        {RF_R05,          0x03},
-        {RF_R06,          0x02},
-        {RF_R07,          0x70},
-        {RF_R09,          0x0F},
-        {RF_R10,          0x41},
-        {RF_R11,          0x21},
-        {RF_R12,          0x7B},
-        {RF_R14,          0x90},
-        {RF_R15,          0x58},
-        {RF_R16,          0xB3},
-        {RF_R17,          0x92},
-        {RF_R18,          0x2C},
-        {RF_R19,          0x02},
-        {RF_R20,          0xBA},
-        {RF_R21,          0xDB},
-        {RF_R24,          0x16},
-        {RF_R25,          0x01},
-        {RF_R29,          0x1F},
+REG_PAIR RT30xx_RFRegTable[] = {
+	{RF_R04, 0x40}
+	,
+	{RF_R05, 0x03}
+	,
+	{RF_R06, 0x02}
+	,
+	{RF_R07, 0x70}
+	,
+	{RF_R09, 0x0F}
+	,
+	{RF_R10, 0x41}
+	,
+	{RF_R11, 0x21}
+	,
+	{RF_R12, 0x7B}
+	,
+	{RF_R14, 0x90}
+	,
+	{RF_R15, 0x58}
+	,
+	{RF_R16, 0xB3}
+	,
+	{RF_R17, 0x92}
+	,
+	{RF_R18, 0x2C}
+	,
+	{RF_R19, 0x02}
+	,
+	{RF_R20, 0xBA}
+	,
+	{RF_R21, 0xDB}
+	,
+	{RF_R24, 0x16}
+	,
+	{RF_R25, 0x01}
+	,
+	{RF_R29, 0x1F}
+	,
 };
 
 UCHAR NUM_RF_REG_PARMS = (sizeof(RT30xx_RFRegTable) / sizeof(REG_PAIR));
 
-
-
 // Antenna divesity use GPIO3 and EESK pin for control
 // Antenna and EEPROM access are both using EESK pin,
 // Therefor we should avoid accessing EESK at the same time
 // Then restore antenna after EEPROM access
 // The original name of this function is AsicSetRxAnt(), now change to
 //VOID AsicSetRxAnt(
-VOID RT30xxSetRxAnt(
-	IN PRTMP_ADAPTER	pAd,
-	IN UCHAR			Ant)
+VOID RT30xxSetRxAnt(IN PRTMP_ADAPTER pAd, IN UCHAR Ant)
 {
-	UINT32	Value;
+	UINT32 Value;
 #ifdef RTMP_MAC_PCI
-	UINT32	x;
+	UINT32 x;
 #endif
 
 	if ((pAd->EepromAccess) ||
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS))	||
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))	||
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) ||
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-	{
+	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
+	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
+	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) ||
+	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
 		return;
 	}
-
 	// the antenna selection is through firmware and MAC register(GPIO3)
-	if (Ant == 0)
-	{
+	if (Ant == 0) {
 		// Main antenna
 #ifdef RTMP_MAC_PCI
 		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
@@ -114,10 +123,9 @@ VOID RT30xxSetRxAnt(
 		RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &Value);
 		Value &= ~(0x0808);
 		RTMP_IO_WRITE32(pAd, GPIO_CTRL_CFG, Value);
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("AsicSetRxAnt, switch to main antenna\n"));
-	}
-	else
-	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE,
+			     ("AsicSetRxAnt, switch to main antenna\n"));
+	} else {
 		// Aux antenna
 #ifdef RTMP_MAC_PCI
 		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
@@ -130,11 +138,11 @@ VOID RT30xxSetRxAnt(
 		Value &= ~(0x0808);
 		Value |= 0x08;
 		RTMP_IO_WRITE32(pAd, GPIO_CTRL_CFG, Value);
-		DBGPRINT_RAW(RT_DEBUG_TRACE, ("AsicSetRxAnt, switch to aux antenna\n"));
+		DBGPRINT_RAW(RT_DEBUG_TRACE,
+			     ("AsicSetRxAnt, switch to aux antenna\n"));
 	}
 }
 
-
 /*
 	========================================================================
 
@@ -151,46 +159,43 @@ VOID RT30xxSetRxAnt(
 
 	========================================================================
 */
-VOID RTMPFilterCalibration(
-	IN PRTMP_ADAPTER pAd)
+VOID RTMPFilterCalibration(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR	R55x = 0, value, FilterTarget = 0x1E, BBPValue=0;
-	UINT	loop = 0, count = 0, loopcnt = 0, ReTry = 0;
-	UCHAR	RF_R24_Value = 0;
+	UCHAR R55x = 0, value, FilterTarget = 0x1E, BBPValue = 0;
+	UINT loop = 0, count = 0, loopcnt = 0, ReTry = 0;
+	UCHAR RF_R24_Value = 0;
 
 	// Give bbp filter initial value
 	pAd->Mlme.CaliBW20RfR24 = 0x1F;
-	pAd->Mlme.CaliBW40RfR24 = 0x2F; //Bit[5] must be 1 for BW 40
+	pAd->Mlme.CaliBW40RfR24 = 0x2F;	//Bit[5] must be 1 for BW 40
 
-	do
-	{
+	do {
 		if (loop == 1)	//BandWidth = 40 MHz
 		{
 			// Write 0x27 to RF_R24 to program filter
 			RF_R24_Value = 0x27;
 			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
-			if (IS_RT3090(pAd) || IS_RT3572(pAd)|| IS_RT3390(pAd))
+			if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 				FilterTarget = 0x15;
 			else
 				FilterTarget = 0x19;
 
 			// when calibrate BW40, BBP mask must set to BW40.
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-			BBPValue&= (~0x18);
-			BBPValue|= (0x10);
+			BBPValue &= (~0x18);
+			BBPValue |= (0x10);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
 
 			// set to BW40
 			RT30xxReadRFRegister(pAd, RF_R31, &value);
 			value |= 0x20;
 			RT30xxWriteRFRegister(pAd, RF_R31, value);
-		}
-		else			//BandWidth = 20 MHz
+		} else		//BandWidth = 20 MHz
 		{
 			// Write 0x07 to RF_R24 to program filter
 			RF_R24_Value = 0x07;
 			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
-			if (IS_RT3090(pAd) || IS_RT3572(pAd)|| IS_RT3390(pAd))
+			if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 				FilterTarget = 0x13;
 			else
 				FilterTarget = 0x16;
@@ -209,8 +214,7 @@ VOID RTMPFilterCalibration(
 		// Write 0x00 to BBP_R24 to set power & frequency of passband test tone
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R24, 0);
 
-		do
-		{
+		do {
 			// Write 0x90 to BBP_R25 to transmit test tone
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R25, 0x90);
 
@@ -224,8 +228,7 @@ VOID RTMPFilterCalibration(
 		// Write 0x06 to BBP_R24 to set power & frequency of stopband test tone
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R24, 0x06);
 
-		while(TRUE)
-		{
+		while (TRUE) {
 			// Write 0x90 to BBP_R25 to transmit test tone
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R25, 0x90);
 
@@ -233,59 +236,47 @@ VOID RTMPFilterCalibration(
 			RTMPusecDelay(1000);
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R55, &value);
 			value &= 0xFF;
-			if ((R55x - value) < FilterTarget)
-			{
-				RF_R24_Value ++;
-			}
-			else if ((R55x - value) == FilterTarget)
-			{
-				RF_R24_Value ++;
-				count ++;
-			}
-			else
-			{
+			if ((R55x - value) < FilterTarget) {
+				RF_R24_Value++;
+			} else if ((R55x - value) == FilterTarget) {
+				RF_R24_Value++;
+				count++;
+			} else {
 				break;
 			}
 
 			// prevent infinite loop cause driver hang.
-			if (loopcnt++ > 100)
-			{
-				DBGPRINT(RT_DEBUG_ERROR, ("RTMPFilterCalibration - can't find a valid value, loopcnt=%d stop calibrating", loopcnt));
+			if (loopcnt++ > 100) {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("RTMPFilterCalibration - can't find a valid value, loopcnt=%d stop calibrating",
+					  loopcnt));
 				break;
 			}
-
 			// Write RF_R24 to program filter
 			RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
 		}
 
-		if (count > 0)
-		{
+		if (count > 0) {
 			RF_R24_Value = RF_R24_Value - ((count) ? (1) : (0));
 		}
-
 		// Store for future usage
-		if (loopcnt < 100)
-		{
-			if (loop++ == 0)
-			{
+		if (loopcnt < 100) {
+			if (loop++ == 0) {
 				//BandWidth = 20 MHz
-				pAd->Mlme.CaliBW20RfR24 = (UCHAR)RF_R24_Value;
-			}
-			else
-			{
+				pAd->Mlme.CaliBW20RfR24 = (UCHAR) RF_R24_Value;
+			} else {
 				//BandWidth = 40 MHz
-				pAd->Mlme.CaliBW40RfR24 = (UCHAR)RF_R24_Value;
+				pAd->Mlme.CaliBW40RfR24 = (UCHAR) RF_R24_Value;
 				break;
 			}
-		}
-		else
+		} else
 			break;
 
 		RT30xxWriteRFRegister(pAd, RF_R24, RF_R24_Value);
 
 		// reset count
 		count = 0;
-	} while(TRUE);
+	} while (TRUE);
 
 	//
 	// Set back to initial state
@@ -298,13 +289,14 @@ VOID RTMPFilterCalibration(
 
 	// set BBP back to BW20
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
-	BBPValue&= (~0x18);
+	BBPValue &= (~0x18);
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPFilterCalibration - CaliBW20RfR24=0x%x, CaliBW40RfR24=0x%x\n", pAd->Mlme.CaliBW20RfR24, pAd->Mlme.CaliBW40RfR24));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPFilterCalibration - CaliBW20RfR24=0x%x, CaliBW40RfR24=0x%x\n",
+		  pAd->Mlme.CaliBW20RfR24, pAd->Mlme.CaliBW40RfR24));
 }
 
-
 // add by johnli, RF power sequence setup
 /*
 	==========================================================================
@@ -314,8 +306,7 @@ VOID RTMPFilterCalibration(
 
 	==========================================================================
  */
-VOID RT30xxLoadRFNormalModeSetup(
-	IN PRTMP_ADAPTER	pAd)
+VOID RT30xxLoadRFNormalModeSetup(IN PRTMP_ADAPTER pAd)
 {
 	UCHAR RFValue;
 
@@ -330,22 +321,22 @@ VOID RT30xxLoadRFNormalModeSetup(
 	RT30xxWriteRFRegister(pAd, RF_R15, RFValue);
 
 	/* move to NICInitRT30xxRFRegisters
-	// TX_LO1_en, RF R17 register Bit 3 to 0
-	RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
-	RFValue &= (~0x08);
-	// to fix rx long range issue
-	if (((pAd->MACVersion & 0xffff) >= 0x0211) && (pAd->NicConfig2.field.ExternalLNAForG == 0))
-	{
-		RFValue |= 0x20;
-	}
-	// set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h
-	if (pAd->TxMixerGain24G >= 2)
-	{
-		RFValue &= (~0x7);  // clean bit [2:0]
-		RFValue |= pAd->TxMixerGain24G;
-	}
-	RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
-	*/
+	   // TX_LO1_en, RF R17 register Bit 3 to 0
+	   RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
+	   RFValue &= (~0x08);
+	   // to fix rx long range issue
+	   if (((pAd->MACVersion & 0xffff) >= 0x0211) && (pAd->NicConfig2.field.ExternalLNAForG == 0))
+	   {
+	   RFValue |= 0x20;
+	   }
+	   // set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h
+	   if (pAd->TxMixerGain24G >= 2)
+	   {
+	   RFValue &= (~0x7);  // clean bit [2:0]
+	   RFValue |= pAd->TxMixerGain24G;
+	   }
+	   RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
+	 */
 
 	// RX_LO1_en, RF R20 register Bit 3 to 0
 	RT30xxReadRFRegister(pAd, RF_R20, &RFValue);
@@ -357,7 +348,7 @@ VOID RT30xxLoadRFNormalModeSetup(
 	RFValue &= (~0x08);
 	RT30xxWriteRFRegister(pAd, RF_R21, RFValue);
 
-	/* add by johnli, reset RF_R27 when interface down & up to fix throughput problem*/
+	/* add by johnli, reset RF_R27 when interface down & up to fix throughput problem */
 	// LDORF_VC, RF R27 register Bit 2 to 0
 	RT30xxReadRFRegister(pAd, RF_R27, &RFValue);
 	// TX to RX IQ glitch(RF_R27) has been fixed in RT3070(F).
@@ -381,15 +372,13 @@ VOID RT30xxLoadRFNormalModeSetup(
 
 	==========================================================================
  */
-VOID RT30xxLoadRFSleepModeSetup(
-	IN PRTMP_ADAPTER	pAd)
+VOID RT30xxLoadRFSleepModeSetup(IN PRTMP_ADAPTER pAd)
 {
 	UCHAR RFValue;
 	UINT32 MACValue;
 
-
 #ifdef RTMP_MAC_USB
-	if(!IS_RT3572(pAd))
+	if (!IS_RT3572(pAd))
 #endif // RTMP_MAC_USB //
 	{
 		// RF_BLOCK_en. RF R1 register Bit 0 to 0
@@ -414,9 +403,8 @@ VOID RT30xxLoadRFSleepModeSetup(
 	}
 
 	if (IS_RT3090(pAd) ||	// IS_RT3090 including RT309x and RT3071/72
-		IS_RT3572(pAd) ||
-		(IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201)))
-	{
+	    IS_RT3572(pAd) ||
+	    (IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201))) {
 #ifdef RTMP_MAC_USB
 		if (!IS_RT3572(pAd))
 #endif // RTMP_MAC_USB //
@@ -440,14 +428,13 @@ VOID RT30xxLoadRFSleepModeSetup(
 
 	==========================================================================
  */
-VOID RT30xxReverseRFSleepModeSetup(
-	IN PRTMP_ADAPTER	pAd)
+VOID RT30xxReverseRFSleepModeSetup(IN PRTMP_ADAPTER pAd)
 {
 	UCHAR RFValue;
 	UINT32 MACValue;
 
 #ifdef RTMP_MAC_USB
-	if(!IS_RT3572(pAd))
+	if (!IS_RT3572(pAd))
 #endif // RTMP_MAC_USB //
 	{
 		// RF_BLOCK_en, RF R1 register Bit 0 to 1
@@ -472,10 +459,9 @@ VOID RT30xxReverseRFSleepModeSetup(
 	}
 
 	if (IS_RT3090(pAd) ||	// IS_RT3090 including RT309x and RT3071/72
-		IS_RT3572(pAd) ||
-		IS_RT3390(pAd) ||
-		(IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201)))
-	{
+	    IS_RT3572(pAd) ||
+	    IS_RT3390(pAd) ||
+	    (IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201))) {
 #ifdef RTMP_MAC_USB
 		if (!IS_RT3572(pAd))
 #endif // RTMP_MAC_USB //
@@ -487,48 +473,41 @@ VOID RT30xxReverseRFSleepModeSetup(
 				RFValue = (RFValue & (~0x77));
 			RT30xxWriteRFRegister(pAd, RF_R27, RFValue);
 		}
-
 		// RT3071 version E has fixed this issue
-		if ((pAd->NicConfig2.field.DACTestBit == 1) && ((pAd->MACVersion & 0xffff) < 0x0211))
-		{
+		if ((pAd->NicConfig2.field.DACTestBit == 1)
+		    && ((pAd->MACVersion & 0xffff) < 0x0211)) {
 			// patch tx EVM issue temporarily
 			RTMP_IO_READ32(pAd, LDO_CFG0, &MACValue);
 			MACValue = ((MACValue & 0xE0FFFFFF) | 0x0D000000);
 			RTMP_IO_WRITE32(pAd, LDO_CFG0, MACValue);
-		}
-		else
-		{
+		} else {
 			RTMP_IO_READ32(pAd, LDO_CFG0, &MACValue);
 			MACValue = ((MACValue & 0xE0FFFFFF) | 0x01000000);
 			RTMP_IO_WRITE32(pAd, LDO_CFG0, MACValue);
 		}
 	}
 
-	if(IS_RT3572(pAd))
+	if (IS_RT3572(pAd))
 		RT30xxWriteRFRegister(pAd, RF_R08, 0x80);
 }
+
 // end johnli
 
-VOID RT30xxHaltAction(
-	IN PRTMP_ADAPTER	pAd)
+VOID RT30xxHaltAction(IN PRTMP_ADAPTER pAd)
 {
-	UINT32		TxPinCfg = 0x00050F0F;
+	UINT32 TxPinCfg = 0x00050F0F;
 
 	//
 	// Turn off LNA_PE or TRSW_POL
 	//
-	if (IS_RT3070(pAd) || IS_RT3071(pAd) || IS_RT3572(pAd))
-	{
+	if (IS_RT3070(pAd) || IS_RT3071(pAd) || IS_RT3572(pAd)) {
 		if ((IS_RT3071(pAd) || IS_RT3572(pAd))
 #ifdef RTMP_EFUSE_SUPPORT
-			&& (pAd->bUseEfuse)
+		    && (pAd->bUseEfuse)
 #endif // RTMP_EFUSE_SUPPORT //
-			)
-		{
-			TxPinCfg &= 0xFFFBF0F0; // bit18 off
-		}
-		else
-		{
+		    ) {
+			TxPinCfg &= 0xFFFBF0F0;	// bit18 off
+		} else {
 			TxPinCfg &= 0xFFFFF0F0;
 		}
 
--- a/drivers/staging/rt2860/pci_main_dev.c
+++ b/drivers/staging/rt2860/pci_main_dev.c
@@ -53,13 +53,13 @@ extern int rt28xx_close(IN struct net_de
 extern int rt28xx_open(struct net_device *net_dev);
 
 static VOID __devexit rt2860_remove_one(struct pci_dev *pci_dev);
-static INT __devinit rt2860_probe(struct pci_dev *pci_dev, const struct pci_device_id  *ent);
+static INT __devinit rt2860_probe(struct pci_dev *pci_dev,
+				  const struct pci_device_id *ent);
 static void __exit rt2860_cleanup_module(void);
 static int __init rt2860_init_module(void);
 
- static VOID RTMPInitPCIeDevice(
-    IN  struct pci_dev   *pci_dev,
-    IN PRTMP_ADAPTER     pAd);
+static VOID RTMPInitPCIeDevice(IN struct pci_dev *pci_dev,
+			       IN PRTMP_ADAPTER pAd);
 
 #ifdef CONFIG_PM
 static int rt2860_suspend(struct pci_dev *pci_dev, pm_message_t state);
@@ -69,10 +69,9 @@ static int rt2860_resume(struct pci_dev 
 //
 // Ralink PCI device table, include all supported chipsets
 //
-static struct pci_device_id rt2860_pci_tbl[] __devinitdata =
-{
+static struct pci_device_id rt2860_pci_tbl[] __devinitdata = {
 #ifdef RT2860
-	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2860_PCI_DEVICE_ID)},		//RT28602.4G
+	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2860_PCI_DEVICE_ID)},	//RT28602.4G
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2860_PCIe_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2760_PCI_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC2790_PCIe_DEVICE_ID)},
@@ -95,7 +94,7 @@ static struct pci_device_id rt2860_pci_t
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3391_PCIe_DEVICE_ID)},
 	{PCI_DEVICE(NIC_PCI_VENDOR_ID, NIC3392_PCIe_DEVICE_ID)},
 #endif // RT3390 //
-    {0,}		// terminate list
+	{0,}			// terminate list
 };
 
 MODULE_DEVICE_TABLE(pci, rt2860_pci_tbl);
@@ -103,23 +102,20 @@ MODULE_DEVICE_TABLE(pci, rt2860_pci_tbl)
 MODULE_VERSION(STA_DRIVER_VERSION);
 #endif
 
-
 //
 // Our PCI driver structure
 //
-static struct pci_driver rt2860_driver =
-{
-    name:       "rt2860",
-    id_table:   rt2860_pci_tbl,
-    probe:      rt2860_probe,
-    remove:     __devexit_p(rt2860_remove_one),
+static struct pci_driver rt2860_driver = {
+name:	"rt2860",
+id_table:rt2860_pci_tbl,
+probe:	rt2860_probe,
+remove:__devexit_p(rt2860_remove_one),
 #ifdef CONFIG_PM
-	suspend:	rt2860_suspend,
-	resume:		rt2860_resume,
+suspend:rt2860_suspend,
+resume:rt2860_resume,
 #endif
 };
 
-
 /***************************************************************************
  *
  *	PCI device initialization related procedures.
@@ -127,37 +123,29 @@ static struct pci_driver rt2860_driver =
  ***************************************************************************/
 #ifdef CONFIG_PM
 
-VOID RT2860RejectPendingPackets(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RT2860RejectPendingPackets(IN PRTMP_ADAPTER pAd)
 {
 	// clear PS packets
 	// clear TxSw packets
 }
 
-static int rt2860_suspend(
-	struct pci_dev *pci_dev,
-	pm_message_t state)
+static int rt2860_suspend(struct pci_dev *pci_dev, pm_message_t state)
 {
 	struct net_device *net_dev = pci_get_drvdata(pci_dev);
-	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)NULL;
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) NULL;
 	INT32 retval = 0;
 
-
 	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_suspend()\n"));
 
-	if (net_dev == NULL)
-	{
+	if (net_dev == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR, ("net_dev == NULL!\n"));
-	}
-	else
-	{
+	} else {
 		GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
 		/* we can not use IFF_UP because ra0 down but ra1 up */
 		/* and 1 suspend/resume function for 1 module, not for each interface */
 		/* so Linux will call suspend/resume function once */
-		if (VIRTUAL_IF_NUM(pAd) > 0)
-		{
+		if (VIRTUAL_IF_NUM(pAd) > 0) {
 			// avoid users do suspend after interface is down
 
 			// stop interface
@@ -172,7 +160,7 @@ static int rt2860_suspend(
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
 			// take down the device
-			rt28xx_close((PNET_DEV)net_dev);
+			rt28xx_close((PNET_DEV) net_dev);
 
 			RT_MOD_DEC_USE_COUNT();
 		}
@@ -193,14 +181,12 @@ static int rt2860_suspend(
 	return retval;
 }
 
-static int rt2860_resume(
-	struct pci_dev *pci_dev)
+static int rt2860_resume(struct pci_dev *pci_dev)
 {
 	struct net_device *net_dev = pci_get_drvdata(pci_dev);
-	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)NULL;
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) NULL;
 	INT32 retval;
 
-
 	// set the power state of a PCI device
 	// PCI has 4 power states, DO (normal) ~ D3(less power)
 	// in include/linux/pci.h, you can find that
@@ -217,38 +203,32 @@ static int rt2860_resume(
 	pci_restore_state(pci_dev);
 
 	// initialize device before it's used by a driver
-	if (pci_enable_device(pci_dev))
-	{
+	if (pci_enable_device(pci_dev)) {
 		printk("pci enable fail!\n");
 		return 0;
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_resume()\n"));
 
-	if (net_dev == NULL)
-	{
+	if (net_dev == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR, ("net_dev == NULL!\n"));
-	}
-	else
+	} else
 		GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-	if (pAd != NULL)
-	{
+	if (pAd != NULL) {
 		/* we can not use IFF_UP because ra0 down but ra1 up */
 		/* and 1 suspend/resume function for 1 module, not for each interface */
 		/* so Linux will call suspend/resume function once */
-		if (VIRTUAL_IF_NUM(pAd) > 0)
-		{
+		if (VIRTUAL_IF_NUM(pAd) > 0) {
 			// mark device as attached from system and restart if needed
 			netif_device_attach(net_dev);
 
-			if (rt28xx_open((PNET_DEV)net_dev) != 0)
-			{
+			if (rt28xx_open((PNET_DEV) net_dev) != 0) {
 				// open fail
-				DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2860_resume()\n"));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("<=== rt2860_resume()\n"));
 				return 0;
 			}
-
 			// increase MODULE use count
 			RT_MOD_INC_USE_COUNT();
 
@@ -266,113 +246,111 @@ static int rt2860_resume(
 }
 #endif // CONFIG_PM //
 
-
 static INT __init rt2860_init_module(VOID)
 {
 	return pci_register_driver(&rt2860_driver);
 }
 
-
 //
 // Driver module unload function
 //
 static VOID __exit rt2860_cleanup_module(VOID)
 {
-    pci_unregister_driver(&rt2860_driver);
+	pci_unregister_driver(&rt2860_driver);
 }
 
 module_init(rt2860_init_module);
 module_exit(rt2860_cleanup_module);
 
-
 //
 // PCI device probe & initialization function
 //
-static INT __devinit   rt2860_probe(
-    IN  struct pci_dev              *pci_dev,
-    IN  const struct pci_device_id  *pci_id)
+static INT __devinit rt2860_probe(IN struct pci_dev *pci_dev,
+				  IN const struct pci_device_id *pci_id)
 {
-	PRTMP_ADAPTER		pAd = (PRTMP_ADAPTER)NULL;
-	struct  net_device		*net_dev;
-	PVOID				handle;
-	PSTRING				print_name;
-	ULONG				csr_addr;
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) NULL;
+	struct net_device *net_dev;
+	PVOID handle;
+	PSTRING print_name;
+	ULONG csr_addr;
 	INT rv = 0;
-	RTMP_OS_NETDEV_OP_HOOK	netDevHook;
+	RTMP_OS_NETDEV_OP_HOOK netDevHook;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_probe\n"));
 
 //PCIDevInit==============================================
 	// wake up and enable device
-	if ((rv = pci_enable_device(pci_dev))!= 0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("Enable PCI device failed, errno=%d!\n", rv));
+	if ((rv = pci_enable_device(pci_dev)) != 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("Enable PCI device failed, errno=%d!\n", rv));
 		return rv;
 	}
 
-	print_name = (PSTRING)pci_name(pci_dev);
+	print_name = (PSTRING) pci_name(pci_dev);
 
-	if ((rv = pci_request_regions(pci_dev, print_name)) != 0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("Request PCI resource failed, errno=%d!\n", rv));
+	if ((rv = pci_request_regions(pci_dev, print_name)) != 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("Request PCI resource failed, errno=%d!\n", rv));
 		goto err_out;
 	}
-
 	// map physical address to virtual address for accessing register
-	csr_addr = (unsigned long) ioremap(pci_resource_start(pci_dev, 0), pci_resource_len(pci_dev, 0));
-	if (!csr_addr)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("ioremap failed for device %s, region 0x%lX @ 0x%lX\n",
-					print_name, (ULONG)pci_resource_len(pci_dev, 0), (ULONG)pci_resource_start(pci_dev, 0)));
+	csr_addr =
+	    (unsigned long)ioremap(pci_resource_start(pci_dev, 0),
+				   pci_resource_len(pci_dev, 0));
+	if (!csr_addr) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("ioremap failed for device %s, region 0x%lX @ 0x%lX\n",
+			  print_name, (ULONG) pci_resource_len(pci_dev, 0),
+			  (ULONG) pci_resource_start(pci_dev, 0)));
 		goto err_out_free_res;
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("%s: at 0x%lx, VA 0x%lx, IRQ %d. \n",  print_name,
-					(ULONG)pci_resource_start(pci_dev, 0), (ULONG)csr_addr, pci_dev->irq));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s: at 0x%lx, VA 0x%lx, IRQ %d. \n", print_name,
+			  (ULONG) pci_resource_start(pci_dev, 0),
+			  (ULONG) csr_addr, pci_dev->irq));
 	}
 
 	// Set DMA master
 	pci_set_master(pci_dev);
 
-
 //RtmpDevInit==============================================
 	// Allocate RTMP_ADAPTER adapter structure
 	handle = kmalloc(sizeof(struct os_cookie), GFP_KERNEL);
-	if (handle == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s(): Allocate memory for os handle failed!\n", __func__));
+	if (handle == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s(): Allocate memory for os handle failed!\n",
+			  __func__));
 		goto err_out_iounmap;
 	}
 
-	((POS_COOKIE)handle)->pci_dev = pci_dev;
+	((POS_COOKIE) handle)->pci_dev = pci_dev;
 
 	rv = RTMPAllocAdapterBlock(handle, &pAd);	//shiang: we may need the pci_dev for allocate structure of "RTMP_ADAPTER"
 	if (rv != NDIS_STATUS_SUCCESS)
 		goto err_out_iounmap;
 	// Here are the RTMP_ADAPTER structure with pci-bus specific parameters.
-	pAd->CSRBaseAddress = (PUCHAR)csr_addr;
-	DBGPRINT(RT_DEBUG_ERROR, ("pAd->CSRBaseAddress =0x%lx, csr_addr=0x%lx!\n", (ULONG)pAd->CSRBaseAddress, csr_addr));
+	pAd->CSRBaseAddress = (PUCHAR) csr_addr;
+	DBGPRINT(RT_DEBUG_ERROR,
+		 ("pAd->CSRBaseAddress =0x%lx, csr_addr=0x%lx!\n",
+		  (ULONG) pAd->CSRBaseAddress, csr_addr));
 	RtmpRaDevCtrlInit(pAd, RTMP_DEV_INF_PCI);
 
-
 //NetDevInit==============================================
 	net_dev = RtmpPhyNetDevInit(pAd, &netDevHook);
 	if (net_dev == NULL)
 		goto err_out_free_radev;
 
 	// Here are the net_device structure with pci-bus specific parameters.
-	net_dev->irq = pci_dev->irq;		// Interrupt IRQ number
-	net_dev->base_addr = csr_addr;		// Save CSR virtual address and irq to device structure
+	net_dev->irq = pci_dev->irq;	// Interrupt IRQ number
+	net_dev->base_addr = csr_addr;	// Save CSR virtual address and irq to device structure
 	pci_set_drvdata(pci_dev, net_dev);	// Set driver data
 
 /* for supporting Network Manager */
 	/* Set the sysfs physical device reference for the network logical device
-	  * if set prior to registration will cause a symlink during initialization.
+	 * if set prior to registration will cause a symlink during initialization.
 	 */
 	SET_NETDEV_DEV(net_dev, &(pci_dev->dev));
 
-
 //All done, it's time to register the net device to linux kernel.
 	// Register this device
 	rv = RtmpOSNetDevAttach(net_dev, &netDevHook);
@@ -384,20 +362,20 @@ static INT __devinit   rt2860_probe(
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt2860_probe\n"));
 
-	return 0; // probe ok
-
+	return 0;		// probe ok
 
 	/* --------------------------- ERROR HANDLE --------------------------- */
 err_out_free_netdev:
 	RtmpOSNetDevFree(net_dev);
 
 err_out_free_radev:
-	/* free RTMP_ADAPTER strcuture and os_cookie*/
+	/* free RTMP_ADAPTER strcuture and os_cookie */
 	RTMPFreeAdapter(pAd);
 
 err_out_iounmap:
 	iounmap((void *)(csr_addr));
-	release_mem_region(pci_resource_start(pci_dev, 0), pci_resource_len(pci_dev, 0));
+	release_mem_region(pci_resource_start(pci_dev, 0),
+			   pci_resource_len(pci_dev, 0));
 
 err_out_free_res:
 	pci_release_regions(pci_dev);
@@ -405,25 +383,23 @@ err_out_free_res:
 err_out:
 	pci_disable_device(pci_dev);
 
-	DBGPRINT(RT_DEBUG_ERROR, ("<=== rt2860_probe failed with rv = %d!\n", rv));
+	DBGPRINT(RT_DEBUG_ERROR,
+		 ("<=== rt2860_probe failed with rv = %d!\n", rv));
 
-	return -ENODEV; /* probe fail */
+	return -ENODEV;		/* probe fail */
 }
 
-
-static VOID __devexit rt2860_remove_one(
-    IN  struct pci_dev  *pci_dev)
+static VOID __devexit rt2860_remove_one(IN struct pci_dev *pci_dev)
 {
-	PNET_DEV	net_dev = pci_get_drvdata(pci_dev);
-	RTMP_ADAPTER	*pAd = NULL;
-	ULONG			csr_addr = net_dev->base_addr; // pAd->CSRBaseAddress;
+	PNET_DEV net_dev = pci_get_drvdata(pci_dev);
+	RTMP_ADAPTER *pAd = NULL;
+	ULONG csr_addr = net_dev->base_addr;	// pAd->CSRBaseAddress;
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-    DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_remove_one\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2860_remove_one\n"));
 
-	if (pAd != NULL)
-	{
+	if (pAd != NULL) {
 		// Unregister/Free all allocated net_device.
 		RtmpPhyNetDevExit(pAd, net_dev);
 
@@ -431,14 +407,13 @@ static VOID __devexit rt2860_remove_one(
 		iounmap((char *)(csr_addr));
 
 		// release memory region
-		release_mem_region(pci_resource_start(pci_dev, 0), pci_resource_len(pci_dev, 0));
+		release_mem_region(pci_resource_start(pci_dev, 0),
+				   pci_resource_len(pci_dev, 0));
 
 		// Free RTMP_ADAPTER related structures.
 		RtmpRaDevCtrlExit(pAd);
 
-	}
-	else
-	{
+	} else {
 		// Unregister network device
 		RtmpOSNetDevDetach(net_dev);
 
@@ -446,7 +421,8 @@ static VOID __devexit rt2860_remove_one(
 		iounmap((char *)(net_dev->base_addr));
 
 		// release memory region
-		release_mem_region(pci_resource_start(pci_dev, 0), pci_resource_len(pci_dev, 0));
+		release_mem_region(pci_resource_start(pci_dev, 0),
+				   pci_resource_len(pci_dev, 0));
 	}
 
 	// Free the root net_device
@@ -454,7 +430,6 @@ static VOID __devexit rt2860_remove_one(
 
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -470,24 +445,20 @@ Return Value:
 Note:
 ========================================================================
 */
-BOOLEAN RT28XXChipsetCheck(
-	IN void *_dev_p)
+BOOLEAN RT28XXChipsetCheck(IN void *_dev_p)
 {
 	/* always TRUE */
 	return TRUE;
 }
 
-
 /***************************************************************************
  *
  *	PCIe device initialization related procedures.
  *
  ***************************************************************************/
- static VOID RTMPInitPCIeDevice(
-    IN  struct pci_dev   *pci_dev,
-    IN PRTMP_ADAPTER     pAd)
+static VOID RTMPInitPCIeDevice(IN struct pci_dev *pci_dev, IN PRTMP_ADAPTER pAd)
 {
-	USHORT  device_id;
+	USHORT device_id;
 	POS_COOKIE pObj;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
@@ -496,20 +467,18 @@ BOOLEAN RT28XXChipsetCheck(
 	pObj->DeviceID = device_id;
 	if (
 #ifdef RT2860
-		(device_id == NIC2860_PCIe_DEVICE_ID) ||
-		(device_id == NIC2790_PCIe_DEVICE_ID) ||
-		(device_id == VEN_AWT_PCIe_DEVICE_ID) ||
+		   (device_id == NIC2860_PCIe_DEVICE_ID) ||
+		   (device_id == NIC2790_PCIe_DEVICE_ID) ||
+		   (device_id == VEN_AWT_PCIe_DEVICE_ID) ||
 #endif
 #ifdef RT3090
-		(device_id == NIC3090_PCIe_DEVICE_ID) ||
-		(device_id == NIC3091_PCIe_DEVICE_ID) ||
-		(device_id == NIC3092_PCIe_DEVICE_ID) ||
+		   (device_id == NIC3090_PCIe_DEVICE_ID) ||
+		   (device_id == NIC3091_PCIe_DEVICE_ID) ||
+		   (device_id == NIC3092_PCIe_DEVICE_ID) ||
 #endif // RT3090 //
-		 0)
-	{
-		UINT32 MacCsr0 = 0, Index= 0;
-		do
-		{
+		   0) {
+		UINT32 MacCsr0 = 0, Index = 0;
+		do {
 			RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
 
 			if ((MacCsr0 != 0x00) && (MacCsr0 != 0xFFFFFFFF))
@@ -520,21 +489,18 @@ BOOLEAN RT28XXChipsetCheck(
 
 		// Support advanced power save after 2892/2790.
 		// MAC version at offset 0x1000 is 0x2872XXXX/0x2870XXXX(PCIe, USB, SDIO).
-		if ((MacCsr0&0xffff0000) != 0x28600000)
-		{
+		if ((MacCsr0 & 0xffff0000) != 0x28600000) {
 			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_PCIE_DEVICE);
 		}
 	}
 }
 
-
-VOID RTMPInitPCIeLinkCtrlValue(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPInitPCIeLinkCtrlValue(IN PRTMP_ADAPTER pAd)
 {
-    INT     pos;
-    USHORT	reg16, data2, PCIePowerSaveLevel, Configuration;
+	INT pos;
+	USHORT reg16, data2, PCIePowerSaveLevel, Configuration;
 	UINT32 MacValue;
-    BOOLEAN	bFindIntel = FALSE;
+	BOOLEAN bFindIntel = FALSE;
 	POS_COOKIE pObj;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
@@ -542,79 +508,83 @@ VOID RTMPInitPCIeLinkCtrlValue(
 	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
 		return;
 
-    DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
+	DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
 	// Init EEPROM, and save settings
-	if (!(IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)))
-	{
+	if (!(IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
 		RT28xx_EEPROM_READ16(pAd, 0x22, PCIePowerSaveLevel);
 		pAd->PCIePowerSaveLevel = PCIePowerSaveLevel & 0xff;
 
 		pAd->LnkCtrlBitMask = 0;
-		if ((PCIePowerSaveLevel&0xff) == 0xff)
-		{
+		if ((PCIePowerSaveLevel & 0xff) == 0xff) {
 			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_PCIE_DEVICE);
-			DBGPRINT(RT_DEBUG_TRACE, ("====> PCIePowerSaveLevel = 0x%x.\n", PCIePowerSaveLevel));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("====> PCIePowerSaveLevel = 0x%x.\n",
+				  PCIePowerSaveLevel));
 			return;
-		}
-	else
-	{
-		PCIePowerSaveLevel &= 0x3;
-		RT28xx_EEPROM_READ16(pAd, 0x24, data2);
+		} else {
+			PCIePowerSaveLevel &= 0x3;
+			RT28xx_EEPROM_READ16(pAd, 0x24, data2);
 
-		if( !(((data2&0xff00) == 0x9200) && ((data2&0x80) !=0)) )
-		{
-			if (PCIePowerSaveLevel > 1 )
-				PCIePowerSaveLevel = 1;
-		}
+			if (!
+			    (((data2 & 0xff00) == 0x9200)
+			     && ((data2 & 0x80) != 0))) {
+				if (PCIePowerSaveLevel > 1)
+					PCIePowerSaveLevel = 1;
+			}
 
-		DBGPRINT(RT_DEBUG_TRACE, ("====> Write 0x83 = 0x%x.\n", PCIePowerSaveLevel));
-		AsicSendCommandToMcu(pAd, 0x83, 0xff, (UCHAR)PCIePowerSaveLevel, 0x00);
-		RT28xx_EEPROM_READ16(pAd, 0x22, PCIePowerSaveLevel);
-		PCIePowerSaveLevel &= 0xff;
-		PCIePowerSaveLevel = PCIePowerSaveLevel >> 6;
-		switch(PCIePowerSaveLevel)
-		{
-				case 0:	// Only support L0
-					pAd->LnkCtrlBitMask = 0;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("====> Write 0x83 = 0x%x.\n",
+				  PCIePowerSaveLevel));
+			AsicSendCommandToMcu(pAd, 0x83, 0xff,
+					     (UCHAR) PCIePowerSaveLevel, 0x00);
+			RT28xx_EEPROM_READ16(pAd, 0x22, PCIePowerSaveLevel);
+			PCIePowerSaveLevel &= 0xff;
+			PCIePowerSaveLevel = PCIePowerSaveLevel >> 6;
+			switch (PCIePowerSaveLevel) {
+			case 0:	// Only support L0
+				pAd->LnkCtrlBitMask = 0;
 				break;
-				case 1:	// Only enable L0s
-					pAd->LnkCtrlBitMask = 1;
+			case 1:	// Only enable L0s
+				pAd->LnkCtrlBitMask = 1;
 				break;
-				case 2:	// enable L1, L0s
-					pAd->LnkCtrlBitMask = 3;
+			case 2:	// enable L1, L0s
+				pAd->LnkCtrlBitMask = 3;
 				break;
-				case 3:	// sync with host clk and enable L1, L0s
+			case 3:	// sync with host clk and enable L1, L0s
 				pAd->LnkCtrlBitMask = 0x103;
 				break;
-		}
+			}
 			RT28xx_EEPROM_READ16(pAd, 0x24, data2);
-			if ((PCIePowerSaveLevel&0xff) != 0xff)
-			{
+			if ((PCIePowerSaveLevel & 0xff) != 0xff) {
 				PCIePowerSaveLevel &= 0x3;
 
-				if( !(((data2&0xff00) == 0x9200) && ((data2&0x80) !=0)) )
-				{
-					if (PCIePowerSaveLevel > 1 )
+				if (!
+				    (((data2 & 0xff00) == 0x9200)
+				     && ((data2 & 0x80) != 0))) {
+					if (PCIePowerSaveLevel > 1)
 						PCIePowerSaveLevel = 1;
 				}
 
-				DBGPRINT(RT_DEBUG_TRACE, ("====> rt28xx Write 0x83 Command = 0x%x.\n", PCIePowerSaveLevel));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("====> rt28xx Write 0x83 Command = 0x%x.\n",
+					  PCIePowerSaveLevel));
 
-				AsicSendCommandToMcu(pAd, 0x83, 0xff, (UCHAR)PCIePowerSaveLevel, 0x00);
+				AsicSendCommandToMcu(pAd, 0x83, 0xff,
+						     (UCHAR) PCIePowerSaveLevel,
+						     0x00);
 			}
-		DBGPRINT(RT_DEBUG_TRACE, ("====> LnkCtrlBitMask = 0x%x.\n", pAd->LnkCtrlBitMask));
-	}
-	}
-	else if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
-	{
-		UCHAR	LinkCtrlSetting = 0;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("====> LnkCtrlBitMask = 0x%x.\n",
+				  pAd->LnkCtrlBitMask));
+		}
+	} else if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
+		UCHAR LinkCtrlSetting = 0;
 
 		// Check 3090E special setting chip.
-			RT28xx_EEPROM_READ16(pAd, 0x24, data2);
-		if ((data2 == 0x9280) && ((pAd->MACVersion&0xffff) == 0x0211))
-		{
+		RT28xx_EEPROM_READ16(pAd, 0x24, data2);
+		if ((data2 == 0x9280) && ((pAd->MACVersion & 0xffff) == 0x0211)) {
 			pAd->b3090ESpecialChip = TRUE;
-			DBGPRINT_RAW(RT_DEBUG_ERROR,("Special 3090E chip \n"));
+			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Special 3090E chip \n"));
 		}
 
 		RTMP_IO_READ32(pAd, AUX_CTRL, &MacValue);
@@ -622,130 +592,148 @@ VOID RTMPInitPCIeLinkCtrlValue(
 		//Force PCIE 125MHz CLK to toggle
 		MacValue |= 0x402;
 		RTMP_IO_WRITE32(pAd, AUX_CTRL, MacValue);
-		DBGPRINT_RAW(RT_DEBUG_ERROR,(" AUX_CTRL = 0x%32x\n", MacValue));
-
-
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     (" AUX_CTRL = 0x%32x\n", MacValue));
 
 		// for RT30xx F and after, PCIe infterface, and for power solution 3
 		if ((IS_VERSION_AFTER_F(pAd))
-			&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode >= 2)
-			&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode <= 3))
-		{
+		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode >= 2)
+		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode <= 3)) {
 			RTMP_IO_READ32(pAd, AUX_CTRL, &MacValue);
-			DBGPRINT_RAW(RT_DEBUG_ERROR,(" Read AUX_CTRL = 0x%x\n", MacValue));
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     (" Read AUX_CTRL = 0x%x\n", MacValue));
 			// turn on bit 12.
 			//enable 32KHz clock mode for power saving
 			MacValue |= 0x1000;
-			if (MacValue != 0xffffffff)
-			{
+			if (MacValue != 0xffffffff) {
 				RTMP_IO_WRITE32(pAd, AUX_CTRL, MacValue);
-				DBGPRINT_RAW(RT_DEBUG_ERROR,(" Write AUX_CTRL = 0x%x\n", MacValue));
+				DBGPRINT_RAW(RT_DEBUG_ERROR,
+					     (" Write AUX_CTRL = 0x%x\n",
+					      MacValue));
 				// 1. if use PCIePowerSetting is 2 or 3, need to program OSC_CTRL to 0x3ff11.
 				MacValue = 0x3ff11;
 				RTMP_IO_WRITE32(pAd, OSC_CTRL, MacValue);
-				DBGPRINT_RAW(RT_DEBUG_ERROR,(" OSC_CTRL = 0x%x\n", MacValue));
+				DBGPRINT_RAW(RT_DEBUG_ERROR,
+					     (" OSC_CTRL = 0x%x\n", MacValue));
 				// 2. Write PCI register Clk ref bit
 				RTMPrt3xSetPCIePowerLinkCtrl(pAd);
-			}
-			else
-			{
+			} else {
 				// Error read Aux_Ctrl value.  Force to use solution 1
-				DBGPRINT(RT_DEBUG_ERROR,(" Error Value in AUX_CTRL = 0x%x\n", MacValue));
+				DBGPRINT(RT_DEBUG_ERROR,
+					 (" Error Value in AUX_CTRL = 0x%x\n",
+					  MacValue));
 				pAd->StaCfg.PSControl.field.rt30xxPowerMode = 1;
-				DBGPRINT(RT_DEBUG_ERROR,(" Force to use power solution1 \n"));
+				DBGPRINT(RT_DEBUG_ERROR,
+					 (" Force to use power solution1 \n"));
 			}
 		}
 		// 1. read setting from inf file.
 
-		PCIePowerSaveLevel = (USHORT)pAd->StaCfg.PSControl.field.rt30xxPowerMode;
-		DBGPRINT(RT_DEBUG_ERROR, ("====> rt30xx Read PowerLevelMode =  0x%x.\n", PCIePowerSaveLevel));
+		PCIePowerSaveLevel =
+		    (USHORT) pAd->StaCfg.PSControl.field.rt30xxPowerMode;
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("====> rt30xx Read PowerLevelMode =  0x%x.\n",
+			  PCIePowerSaveLevel));
 		// 2. Check EnableNewPS.
 		if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
 			PCIePowerSaveLevel = 1;
 
-		if (IS_VERSION_BEFORE_F(pAd) && (pAd->b3090ESpecialChip == FALSE))
-		{
+		if (IS_VERSION_BEFORE_F(pAd)
+		    && (pAd->b3090ESpecialChip == FALSE)) {
 			// Chip Version E only allow 1, So force set 1.
 			PCIePowerSaveLevel &= 0x1;
-			pAd->PCIePowerSaveLevel = (USHORT)PCIePowerSaveLevel;
-			DBGPRINT(RT_DEBUG_TRACE, ("====> rt30xx E Write 0x83 Command = 0x%x.\n", PCIePowerSaveLevel));
-
-			AsicSendCommandToMcu(pAd, 0x83, 0xff, (UCHAR)PCIePowerSaveLevel, 0x00);
-		}
-		else
-		{
+			pAd->PCIePowerSaveLevel = (USHORT) PCIePowerSaveLevel;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("====> rt30xx E Write 0x83 Command = 0x%x.\n",
+				  PCIePowerSaveLevel));
+
+			AsicSendCommandToMcu(pAd, 0x83, 0xff,
+					     (UCHAR) PCIePowerSaveLevel, 0x00);
+		} else {
 			// Chip Version F and after only allow 1 or 2 or 3. This might be modified after new chip version come out.
-			if (!((PCIePowerSaveLevel == 1) || (PCIePowerSaveLevel == 3)))
+			if (!
+			    ((PCIePowerSaveLevel == 1)
+			     || (PCIePowerSaveLevel == 3)))
 				PCIePowerSaveLevel = 1;
-			DBGPRINT(RT_DEBUG_ERROR, ("====> rt30xx F Write 0x83 Command = 0x%x.\n", PCIePowerSaveLevel));
-			pAd->PCIePowerSaveLevel = (USHORT)PCIePowerSaveLevel;
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("====> rt30xx F Write 0x83 Command = 0x%x.\n",
+				  PCIePowerSaveLevel));
+			pAd->PCIePowerSaveLevel = (USHORT) PCIePowerSaveLevel;
 			// for 3090F , we need to add high-byte arg for 0x83 command to indicate the link control setting in
 			// PCI Configuration Space. Because firmware can't read PCI Configuration Space
-			if ((pAd->Rt3xxRalinkLinkCtrl & 0x2) && (pAd->Rt3xxHostLinkCtrl & 0x2))
-			{
+			if ((pAd->Rt3xxRalinkLinkCtrl & 0x2)
+			    && (pAd->Rt3xxHostLinkCtrl & 0x2)) {
 				LinkCtrlSetting = 1;
 			}
-			DBGPRINT(RT_DEBUG_TRACE, ("====> rt30xxF LinkCtrlSetting = 0x%x.\n", LinkCtrlSetting));
-			AsicSendCommandToMcu(pAd, 0x83, 0xff, (UCHAR)PCIePowerSaveLevel, LinkCtrlSetting);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("====> rt30xxF LinkCtrlSetting = 0x%x.\n",
+				  LinkCtrlSetting));
+			AsicSendCommandToMcu(pAd, 0x83, 0xff,
+					     (UCHAR) PCIePowerSaveLevel,
+					     LinkCtrlSetting);
 		}
 	}
-
-    // Find Ralink PCIe Device's Express Capability Offset
+	// Find Ralink PCIe Device's Express Capability Offset
 	pos = pci_find_capability(pObj->pci_dev, PCI_CAP_ID_EXP);
 
-    if (pos != 0)
-    {
-        // Ralink PCIe Device's Link Control Register Offset
-        pAd->RLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
-	pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset, &reg16);
-        Configuration = le2cpu16(reg16);
-        DBGPRINT(RT_DEBUG_TRACE, ("Read (Ralink PCIe Link Control Register) offset 0x%x = 0x%x\n",
-                                    pAd->RLnkCtrlOffset, Configuration));
-        pAd->RLnkCtrlConfiguration = (Configuration & 0x103);
-        Configuration &= 0xfefc;
-        Configuration |= (0x0);
+	if (pos != 0) {
+		// Ralink PCIe Device's Link Control Register Offset
+		pAd->RLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
+		pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
+				     &reg16);
+		Configuration = le2cpu16(reg16);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Read (Ralink PCIe Link Control Register) offset 0x%x = 0x%x\n",
+			  pAd->RLnkCtrlOffset, Configuration));
+		pAd->RLnkCtrlConfiguration = (Configuration & 0x103);
+		Configuration &= 0xfefc;
+		Configuration |= (0x0);
 #ifdef RT2860
 		if ((pObj->DeviceID == NIC2860_PCIe_DEVICE_ID)
-			||(pObj->DeviceID == NIC2790_PCIe_DEVICE_ID))
-		{
+		    || (pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)) {
 			reg16 = cpu2le16(Configuration);
-			pci_write_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset, reg16);
-			DBGPRINT(RT_DEBUG_TRACE, ("Write (Ralink PCIe Link Control Register)  offset 0x%x = 0x%x\n",
-                                    pos + PCI_EXP_LNKCTL, Configuration));
+			pci_write_config_word(pObj->pci_dev,
+					      pAd->RLnkCtrlOffset, reg16);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Write (Ralink PCIe Link Control Register)  offset 0x%x = 0x%x\n",
+				  pos + PCI_EXP_LNKCTL, Configuration));
 		}
 #endif // RT2860 //
 
-        RTMPFindHostPCIDev(pAd);
-        if (pObj->parent_pci_dev)
-        {
-		USHORT  vendor_id;
-
-		pci_read_config_word(pObj->parent_pci_dev, PCI_VENDOR_ID, &vendor_id);
-		vendor_id = le2cpu16(vendor_id);
-		if (vendor_id == PCIBUS_INTEL_VENDOR)
-                 {
-			bFindIntel = TRUE;
-                        RTMP_SET_PSFLAG(pAd, fRTMP_PS_TOGGLE_L1);
-                 }
-
-		// Find PCI-to-PCI Bridge Express Capability Offset
-		pos = pci_find_capability(pObj->parent_pci_dev, PCI_CAP_ID_EXP);
-
-		if (pos != 0)
-		{
-			BOOLEAN		bChange = FALSE;
-			// PCI-to-PCI Bridge Link Control Register Offset
-			pAd->HostLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
-			pci_read_config_word(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, &reg16);
-			Configuration = le2cpu16(reg16);
-			DBGPRINT(RT_DEBUG_TRACE, ("Read (Host PCI-to-PCI Bridge Link Control Register) offset 0x%x = 0x%x\n",
-			                            pAd->HostLnkCtrlOffset, Configuration));
-			pAd->HostLnkCtrlConfiguration = (Configuration & 0x103);
-			Configuration &= 0xfefc;
-			Configuration |= (0x0);
+		RTMPFindHostPCIDev(pAd);
+		if (pObj->parent_pci_dev) {
+			USHORT vendor_id;
+
+			pci_read_config_word(pObj->parent_pci_dev,
+					     PCI_VENDOR_ID, &vendor_id);
+			vendor_id = le2cpu16(vendor_id);
+			if (vendor_id == PCIBUS_INTEL_VENDOR) {
+				bFindIntel = TRUE;
+				RTMP_SET_PSFLAG(pAd, fRTMP_PS_TOGGLE_L1);
+			}
+			// Find PCI-to-PCI Bridge Express Capability Offset
+			pos =
+			    pci_find_capability(pObj->parent_pci_dev,
+						PCI_CAP_ID_EXP);
+
+			if (pos != 0) {
+				BOOLEAN bChange = FALSE;
+				// PCI-to-PCI Bridge Link Control Register Offset
+				pAd->HostLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
+				pci_read_config_word(pObj->parent_pci_dev,
+						     pAd->HostLnkCtrlOffset,
+						     &reg16);
+				Configuration = le2cpu16(reg16);
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("Read (Host PCI-to-PCI Bridge Link Control Register) offset 0x%x = 0x%x\n",
+					  pAd->HostLnkCtrlOffset,
+					  Configuration));
+				pAd->HostLnkCtrlConfiguration =
+				    (Configuration & 0x103);
+				Configuration &= 0xfefc;
+				Configuration |= (0x0);
 
-			switch (pObj->DeviceID)
-			{
+				switch (pObj->DeviceID) {
 #ifdef RT2860
 				case NIC2860_PCIe_DEVICE_ID:
 				case NIC2790_PCIe_DEVICE_ID:
@@ -757,98 +745,104 @@ VOID RTMPInitPCIeLinkCtrlValue(
 				case NIC3091_PCIe_DEVICE_ID:
 				case NIC3092_PCIe_DEVICE_ID:
 					if (bFindIntel == FALSE)
-					bChange = TRUE;
+						bChange = TRUE;
 					break;
 #endif // RT3090 //
 				default:
 					break;
-			}
+				}
 
-			if (bChange)
-			{
-				reg16 = cpu2le16(Configuration);
-				pci_write_config_word(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, reg16);
-				DBGPRINT(RT_DEBUG_TRACE, ("Write (Host PCI-to-PCI Bridge Link Control Register) offset 0x%x = 0x%x\n",
-						pAd->HostLnkCtrlOffset, Configuration));
+				if (bChange) {
+					reg16 = cpu2le16(Configuration);
+					pci_write_config_word(pObj->
+							      parent_pci_dev,
+							      pAd->
+							      HostLnkCtrlOffset,
+							      reg16);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("Write (Host PCI-to-PCI Bridge Link Control Register) offset 0x%x = 0x%x\n",
+						  pAd->HostLnkCtrlOffset,
+						  Configuration));
+				}
+			} else {
+				pAd->HostLnkCtrlOffset = 0;
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("%s: cannot find PCI-to-PCI Bridge PCI Express Capability!\n",
+					  __func__));
 			}
 		}
-		else
-		{
-			pAd->HostLnkCtrlOffset = 0;
-			DBGPRINT(RT_DEBUG_ERROR, ("%s: cannot find PCI-to-PCI Bridge PCI Express Capability!\n", __func__));
-		}
-        }
-    }
-    else
-    {
-        pAd->RLnkCtrlOffset = 0;
-        pAd->HostLnkCtrlOffset = 0;
-        DBGPRINT(RT_DEBUG_ERROR, ("%s: cannot find Ralink PCIe Device's PCI Express Capability!\n", __func__));
-    }
-
-    if (bFindIntel == FALSE)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("Doesn't find Intel PCI host controller. \n"));
+	} else {
+		pAd->RLnkCtrlOffset = 0;
+		pAd->HostLnkCtrlOffset = 0;
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s: cannot find Ralink PCIe Device's PCI Express Capability!\n",
+			  __func__));
+	}
+
+	if (bFindIntel == FALSE) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Doesn't find Intel PCI host controller. \n"));
 		// Doesn't switch L0, L1, So set PCIePowerSaveLevel to 0xff
 		pAd->PCIePowerSaveLevel = 0xff;
 		if ((pAd->RLnkCtrlOffset != 0)
 #ifdef RT3090
-			&& ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
-				||(pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
-				||(pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
+		    && ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
+			|| (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
+			|| (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
 #endif // RT3090 //
-		)
-		{
-			pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset, &reg16);
+		    ) {
+			pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
+					     &reg16);
 			Configuration = le2cpu16(reg16);
-			DBGPRINT(RT_DEBUG_TRACE, ("Read (Ralink 30xx PCIe Link Control Register) offset 0x%x = 0x%x\n",
-			                        pAd->RLnkCtrlOffset, Configuration));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Read (Ralink 30xx PCIe Link Control Register) offset 0x%x = 0x%x\n",
+				  pAd->RLnkCtrlOffset, Configuration));
 			pAd->RLnkCtrlConfiguration = (Configuration & 0x103);
 			Configuration &= 0xfefc;
 			Configuration |= (0x0);
 			reg16 = cpu2le16(Configuration);
-			pci_write_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset, reg16);
-			DBGPRINT(RT_DEBUG_TRACE, ("Write (Ralink PCIe Link Control Register)  offset 0x%x = 0x%x\n",
-			                        pos + PCI_EXP_LNKCTL, Configuration));
+			pci_write_config_word(pObj->pci_dev,
+					      pAd->RLnkCtrlOffset, reg16);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Write (Ralink PCIe Link Control Register)  offset 0x%x = 0x%x\n",
+				  pos + PCI_EXP_LNKCTL, Configuration));
 		}
 	}
 }
 
-VOID RTMPFindHostPCIDev(
-    IN	PRTMP_ADAPTER	pAd)
+VOID RTMPFindHostPCIDev(IN PRTMP_ADAPTER pAd)
 {
-    USHORT  reg16;
-    UCHAR   reg8;
-	UINT	DevFn;
-    PPCI_DEV    pPci_dev;
-	POS_COOKIE	pObj;
+	USHORT reg16;
+	UCHAR reg8;
+	UINT DevFn;
+	PPCI_DEV pPci_dev;
+	POS_COOKIE pObj;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
 		return;
 
-    DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
+	DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
 
-    pObj->parent_pci_dev = NULL;
-    if (pObj->pci_dev->bus->parent)
-    {
-        for (DevFn = 0; DevFn < 255; DevFn++)
-        {
-            pPci_dev = pci_get_slot(pObj->pci_dev->bus->parent, DevFn);
-            if (pPci_dev)
-            {
-                pci_read_config_word(pPci_dev, PCI_CLASS_DEVICE, &reg16);
-                reg16 = le2cpu16(reg16);
-                pci_read_config_byte(pPci_dev, PCI_CB_CARD_BUS, &reg8);
-                if ((reg16 == PCI_CLASS_BRIDGE_PCI) &&
-                    (reg8 == pObj->pci_dev->bus->number))
-                {
-                    pObj->parent_pci_dev = pPci_dev;
-                }
-            }
-        }
-    }
+	pObj->parent_pci_dev = NULL;
+	if (pObj->pci_dev->bus->parent) {
+		for (DevFn = 0; DevFn < 255; DevFn++) {
+			pPci_dev =
+			    pci_get_slot(pObj->pci_dev->bus->parent, DevFn);
+			if (pPci_dev) {
+				pci_read_config_word(pPci_dev, PCI_CLASS_DEVICE,
+						     &reg16);
+				reg16 = le2cpu16(reg16);
+				pci_read_config_byte(pPci_dev, PCI_CB_CARD_BUS,
+						     &reg8);
+				if ((reg16 == PCI_CLASS_BRIDGE_PCI)
+				    && (reg8 == pObj->pci_dev->bus->number)) {
+					pObj->parent_pci_dev = pPci_dev;
+				}
+			}
+		}
+	}
 }
 
 /*
@@ -862,13 +856,11 @@ VOID RTMPFindHostPCIDev(
 
 	========================================================================
 */
-VOID RTMPPCIeLinkCtrlValueRestore(
-	IN	PRTMP_ADAPTER	pAd,
-	IN   UCHAR		Level)
+VOID RTMPPCIeLinkCtrlValueRestore(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 {
-	USHORT  PCIePowerSaveLevel, reg16;
-	USHORT	Configuration;
-	POS_COOKIE	pObj;
+	USHORT PCIePowerSaveLevel, reg16;
+	USHORT Configuration;
+	POS_COOKIE pObj;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
@@ -877,7 +869,7 @@ VOID RTMPPCIeLinkCtrlValueRestore(
 
 #ifdef RT2860
 	if (!((pObj->DeviceID == NIC2860_PCIe_DEVICE_ID)
-		||(pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)))
+	      || (pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)))
 		return;
 #endif // RT2860 //
 	// Check PSControl Configuration
@@ -889,60 +881,62 @@ VOID RTMPPCIeLinkCtrlValueRestore(
 
 #ifdef RT3090
 	if ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
-		||(pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
-		||(pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
+	    || (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
+	    || (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
 		return;
 #endif // RT3090 //
 
 	DBGPRINT(RT_DEBUG_TRACE, ("%s.===>\n", __func__));
 	PCIePowerSaveLevel = pAd->PCIePowerSaveLevel;
-	if ((PCIePowerSaveLevel&0xff) == 0xff)
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("return  \n"));
+	if ((PCIePowerSaveLevel & 0xff) == 0xff) {
+		DBGPRINT(RT_DEBUG_TRACE, ("return  \n"));
 		return;
 	}
 
-	if (pObj->parent_pci_dev && (pAd->HostLnkCtrlOffset != 0))
-    {
-        PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, Configuration);
-        if ((Configuration != 0) &&
-            (Configuration != 0xFFFF))
-        {
-		Configuration &= 0xfefc;
-		// If call from interface down, restore to orginial setting.
-		if (Level == RESTORE_CLOSE)
-		{
-			Configuration |= pAd->HostLnkCtrlConfiguration;
-		}
-		else
-			Configuration |= 0x0;
-            PCI_REG_WIRTE_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, Configuration);
-		DBGPRINT(RT_DEBUG_TRACE, ("Restore PCI host : offset 0x%x = 0x%x\n", pAd->HostLnkCtrlOffset, Configuration));
-        }
-        else
-            DBGPRINT(RT_DEBUG_ERROR, ("Restore PCI host : PCI_REG_READ_WORD failed (Configuration = 0x%x)\n", Configuration));
-    }
-
-    if (pObj->pci_dev && (pAd->RLnkCtrlOffset != 0))
-    {
-        PCI_REG_READ_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset, Configuration);
-        if ((Configuration != 0) &&
-            (Configuration != 0xFFFF))
-        {
-		Configuration &= 0xfefc;
+	if (pObj->parent_pci_dev && (pAd->HostLnkCtrlOffset != 0)) {
+		PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset,
+				  Configuration);
+		if ((Configuration != 0) && (Configuration != 0xFFFF)) {
+			Configuration &= 0xfefc;
+			// If call from interface down, restore to orginial setting.
+			if (Level == RESTORE_CLOSE) {
+				Configuration |= pAd->HostLnkCtrlConfiguration;
+			} else
+				Configuration |= 0x0;
+			PCI_REG_WIRTE_WORD(pObj->parent_pci_dev,
+					   pAd->HostLnkCtrlOffset,
+					   Configuration);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Restore PCI host : offset 0x%x = 0x%x\n",
+				  pAd->HostLnkCtrlOffset, Configuration));
+		} else
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Restore PCI host : PCI_REG_READ_WORD failed (Configuration = 0x%x)\n",
+				  Configuration));
+	}
+
+	if (pObj->pci_dev && (pAd->RLnkCtrlOffset != 0)) {
+		PCI_REG_READ_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset,
+				  Configuration);
+		if ((Configuration != 0) && (Configuration != 0xFFFF)) {
+			Configuration &= 0xfefc;
 			// If call from interface down, restore to orginial setting.
 			if (Level == RESTORE_CLOSE)
-		Configuration |= pAd->RLnkCtrlConfiguration;
+				Configuration |= pAd->RLnkCtrlConfiguration;
 			else
 				Configuration |= 0x0;
-            PCI_REG_WIRTE_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset, Configuration);
-		DBGPRINT(RT_DEBUG_TRACE, ("Restore Ralink : offset 0x%x = 0x%x\n", pAd->RLnkCtrlOffset, Configuration));
-        }
-        else
-            DBGPRINT(RT_DEBUG_ERROR, ("Restore Ralink : PCI_REG_READ_WORD failed (Configuration = 0x%x)\n", Configuration));
+			PCI_REG_WIRTE_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset,
+					   Configuration);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Restore Ralink : offset 0x%x = 0x%x\n",
+				  pAd->RLnkCtrlOffset, Configuration));
+		} else
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Restore Ralink : PCI_REG_READ_WORD failed (Configuration = 0x%x)\n",
+				  Configuration));
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("%s <===\n", __func__));
+	DBGPRINT(RT_DEBUG_TRACE, ("%s <===\n", __func__));
 }
 
 /*
@@ -956,13 +950,11 @@ VOID RTMPPCIeLinkCtrlValueRestore(
 
 	========================================================================
 */
-VOID RTMPPCIeLinkCtrlSetting(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT		Max)
+VOID RTMPPCIeLinkCtrlSetting(IN PRTMP_ADAPTER pAd, IN USHORT Max)
 {
-	USHORT  PCIePowerSaveLevel, reg16;
-	USHORT	Configuration;
-	POS_COOKIE	pObj;
+	USHORT PCIePowerSaveLevel, reg16;
+	USHORT Configuration;
+	POS_COOKIE pObj;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
@@ -971,7 +963,7 @@ VOID RTMPPCIeLinkCtrlSetting(
 
 #ifdef RT2860
 	if (!((pObj->DeviceID == NIC2860_PCIe_DEVICE_ID)
-		||(pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)))
+	      || (pObj->DeviceID == NIC2790_PCIe_DEVICE_ID)))
 		return;
 #endif // RT2860 //
 	// Check PSControl Configuration
@@ -983,94 +975,97 @@ VOID RTMPPCIeLinkCtrlSetting(
 
 #ifdef RT3090
 	if ((pObj->DeviceID == NIC3090_PCIe_DEVICE_ID)
-		||(pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
-		||(pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
+	    || (pObj->DeviceID == NIC3091_PCIe_DEVICE_ID)
+	    || (pObj->DeviceID == NIC3092_PCIe_DEVICE_ID))
 		return;
 #endif // RT3090 //
-	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP))
-	{
-		DBGPRINT(RT_DEBUG_INFO, ("RTMPPCIePowerLinkCtrl return on fRTMP_PS_CAN_GO_SLEEP flag\n"));
+	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP)) {
+		DBGPRINT(RT_DEBUG_INFO,
+			 ("RTMPPCIePowerLinkCtrl return on fRTMP_PS_CAN_GO_SLEEP flag\n"));
 		return;
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("%s===>\n", __func__));
+	DBGPRINT(RT_DEBUG_TRACE, ("%s===>\n", __func__));
 	PCIePowerSaveLevel = pAd->PCIePowerSaveLevel;
-	if ((PCIePowerSaveLevel&0xff) == 0xff)
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("return  \n"));
+	if ((PCIePowerSaveLevel & 0xff) == 0xff) {
+		DBGPRINT(RT_DEBUG_TRACE, ("return  \n"));
 		return;
 	}
-	PCIePowerSaveLevel = PCIePowerSaveLevel>>6;
+	PCIePowerSaveLevel = PCIePowerSaveLevel >> 6;
 
-    // Skip non-exist deice right away
-	if (pObj->parent_pci_dev && (pAd->HostLnkCtrlOffset != 0))
-	{
-        PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, Configuration);
-		switch (PCIePowerSaveLevel)
-		{
-			case 0:
-				// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00
-				Configuration &= 0xfefc;
-				break;
-			case 1:
-				// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01
-				Configuration &= 0xfefc;
-				Configuration |= 0x1;
-				break;
-			case 2:
-				//  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11
-				Configuration &= 0xfefc;
-				Configuration |= 0x3;
-				break;
-			case 3:
-				// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1
-				Configuration &= 0xfefc;
-				Configuration |= 0x103;
-				break;
+	// Skip non-exist deice right away
+	if (pObj->parent_pci_dev && (pAd->HostLnkCtrlOffset != 0)) {
+		PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset,
+				  Configuration);
+		switch (PCIePowerSaveLevel) {
+		case 0:
+			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00
+			Configuration &= 0xfefc;
+			break;
+		case 1:
+			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01
+			Configuration &= 0xfefc;
+			Configuration |= 0x1;
+			break;
+		case 2:
+			//  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11
+			Configuration &= 0xfefc;
+			Configuration |= 0x3;
+			break;
+		case 3:
+			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1
+			Configuration &= 0xfefc;
+			Configuration |= 0x103;
+			break;
 		}
-        PCI_REG_WIRTE_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, Configuration);
-		DBGPRINT(RT_DEBUG_TRACE, ("Write PCI host offset 0x%x = 0x%x\n", pAd->HostLnkCtrlOffset, Configuration));
+		PCI_REG_WIRTE_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset,
+				   Configuration);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Write PCI host offset 0x%x = 0x%x\n",
+			  pAd->HostLnkCtrlOffset, Configuration));
 	}
 
-	if (pObj->pci_dev && (pAd->RLnkCtrlOffset != 0))
-	{
+	if (pObj->pci_dev && (pAd->RLnkCtrlOffset != 0)) {
 		// first 2892 chip not allow to frequently set mode 3. will cause hang problem.
 		if (PCIePowerSaveLevel > Max)
 			PCIePowerSaveLevel = Max;
 
-        PCI_REG_READ_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset, Configuration);
-		switch (PCIePowerSaveLevel)
-		{
-			case 0:
-				// No PCI power safe
-				// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00 .
-				Configuration &= 0xfefc;
-				break;
-			case 1:
-				//  L0
-				// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01 .
-				Configuration &= 0xfefc;
-				Configuration |= 0x1;
-				break;
-			case 2:
-				// L0 and L1
-				//  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11
-				Configuration &= 0xfefc;
-				Configuration |= 0x3;
-				break;
-			case 3:
-				// L0 , L1 and clock management.
-				// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1
-				Configuration &= 0xfefc;
-				Configuration |= 0x103;
-		              pAd->bPCIclkOff = TRUE;
-				break;
+		PCI_REG_READ_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset,
+				  Configuration);
+		switch (PCIePowerSaveLevel) {
+		case 0:
+			// No PCI power safe
+			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 00 .
+			Configuration &= 0xfefc;
+			break;
+		case 1:
+			//  L0
+			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 01 .
+			Configuration &= 0xfefc;
+			Configuration |= 0x1;
+			break;
+		case 2:
+			// L0 and L1
+			//  Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11
+			Configuration &= 0xfefc;
+			Configuration |= 0x3;
+			break;
+		case 3:
+			// L0 , L1 and clock management.
+			// Set b0 and b1 of LinkControl (both 2892 and PCIe bridge) to 11 and bit 8 of LinkControl of 2892 to 1
+			Configuration &= 0xfefc;
+			Configuration |= 0x103;
+			pAd->bPCIclkOff = TRUE;
+			break;
 		}
-        PCI_REG_WIRTE_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset, Configuration);
-		DBGPRINT(RT_DEBUG_TRACE, ("Write Ralink device : offset 0x%x = 0x%x\n", pAd->RLnkCtrlOffset, Configuration));
+		PCI_REG_WIRTE_WORD(pObj->pci_dev, pAd->RLnkCtrlOffset,
+				   Configuration);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Write Ralink device : offset 0x%x = 0x%x\n",
+			  pAd->RLnkCtrlOffset, Configuration));
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE,("RTMPPCIePowerLinkCtrl <==============\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("RTMPPCIePowerLinkCtrl <==============\n"));
 }
 
 /*
@@ -1081,15 +1076,14 @@ VOID RTMPPCIeLinkCtrlSetting(
 
 	========================================================================
 */
-VOID RTMPrt3xSetPCIePowerLinkCtrl(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPrt3xSetPCIePowerLinkCtrl(IN PRTMP_ADAPTER pAd)
 {
 
-	ULONG	HostConfiguration = 0;
-	ULONG	Configuration;
-	POS_COOKIE	pObj;
-	INT     pos;
-	USHORT	reg16;
+	ULONG HostConfiguration = 0;
+	ULONG Configuration;
+	POS_COOKIE pObj;
+	INT pos;
+	USHORT reg16;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
@@ -1101,28 +1095,28 @@ VOID RTMPrt3xSetPCIePowerLinkCtrl(
 	if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
 		return;
 	RTMPFindHostPCIDev(pAd);
-        if (pObj->parent_pci_dev)
-        {
+	if (pObj->parent_pci_dev) {
 		// Find PCI-to-PCI Bridge Express Capability Offset
 		pos = pci_find_capability(pObj->parent_pci_dev, PCI_CAP_ID_EXP);
 
-		if (pos != 0)
-		{
+		if (pos != 0) {
 			pAd->HostLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
 		}
-	// If configurared to turn on L1.
-	HostConfiguration = 0;
-		if (pAd->StaCfg.PSControl.field.rt30xxForceASPMTest == 1)
-		{
-						DBGPRINT(RT_DEBUG_TRACE, ("Enter,PSM : Force ASPM \n"));
+		// If configurared to turn on L1.
+		HostConfiguration = 0;
+		if (pAd->StaCfg.PSControl.field.rt30xxForceASPMTest == 1) {
+			DBGPRINT(RT_DEBUG_TRACE, ("Enter,PSM : Force ASPM \n"));
 
 			// Skip non-exist deice right away
-			if ((pAd->HostLnkCtrlOffset != 0))
-			{
-			 PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, HostConfiguration);
+			if ((pAd->HostLnkCtrlOffset != 0)) {
+				PCI_REG_READ_WORD(pObj->parent_pci_dev,
+						  pAd->HostLnkCtrlOffset,
+						  HostConfiguration);
 				// Prepare Configuration to write to Host
 				HostConfiguration |= 0x3;
-				PCI_REG_WIRTE_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, HostConfiguration);
+				PCI_REG_WIRTE_WORD(pObj->parent_pci_dev,
+						   pAd->HostLnkCtrlOffset,
+						   HostConfiguration);
 				pAd->Rt3xxHostLinkCtrl = HostConfiguration;
 				// Because in rt30xxForceASPMTest Mode, Force turn on L0s, L1.
 				// Fix HostConfiguration bit0:1 = 0x3 for later use.
@@ -1132,14 +1126,14 @@ VOID RTMPrt3xSetPCIePowerLinkCtrl(
 					  "Host device L1/L0s Value =  0x%lx\n",
 					  HostConfiguration));
 			}
-		}
-		else if (pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM == 1)
-		{
+		} else if (pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM ==
+			   1) {
 
 			// Skip non-exist deice right away
-			if ((pAd->HostLnkCtrlOffset != 0))
-			{
-			 PCI_REG_READ_WORD(pObj->parent_pci_dev, pAd->HostLnkCtrlOffset, HostConfiguration);
+			if ((pAd->HostLnkCtrlOffset != 0)) {
+				PCI_REG_READ_WORD(pObj->parent_pci_dev,
+						  pAd->HostLnkCtrlOffset,
+						  HostConfiguration);
 				pAd->Rt3xxHostLinkCtrl = HostConfiguration;
 				HostConfiguration &= 0x3;
 				DBGPRINT(RT_DEBUG_TRACE,
@@ -1148,49 +1142,49 @@ VOID RTMPrt3xSetPCIePowerLinkCtrl(
 					  HostConfiguration));
 			}
 		}
-        }
+	}
 	// Prepare to write Ralink setting.
 	// Find Ralink PCIe Device's Express Capability Offset
 	pos = pci_find_capability(pObj->pci_dev, PCI_CAP_ID_EXP);
 
-    if (pos != 0)
-    {
-        // Ralink PCIe Device's Link Control Register Offset
-       pAd->RLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
-	pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset, &reg16);
-        Configuration = le2cpu16(reg16);
+	if (pos != 0) {
+		// Ralink PCIe Device's Link Control Register Offset
+		pAd->RLnkCtrlOffset = pos + PCI_EXP_LNKCTL;
+		pci_read_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
+				     &reg16);
+		Configuration = le2cpu16(reg16);
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("Read (Ralink PCIe Link Control Register) "
 			  "offset 0x%x = 0x%lx\n",
 			  pAd->RLnkCtrlOffset, Configuration));
 		Configuration |= 0x100;
 		if ((pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM == 1)
-			|| (pAd->StaCfg.PSControl.field.rt30xxForceASPMTest == 1))
-		{
-			switch(HostConfiguration)
-			{
-				case 0:
-					Configuration &= 0xffffffc;
-					break;
-				case 1:
-					Configuration &= 0xffffffc;
-					Configuration |= 0x1;
-					break;
-				case 2:
-					Configuration &= 0xffffffc;
-					Configuration |= 0x2;
-					break;
-				case 3:
-					Configuration |= 0x3;
-					break;
+		    || (pAd->StaCfg.PSControl.field.rt30xxForceASPMTest == 1)) {
+			switch (HostConfiguration) {
+			case 0:
+				Configuration &= 0xffffffc;
+				break;
+			case 1:
+				Configuration &= 0xffffffc;
+				Configuration |= 0x1;
+				break;
+			case 2:
+				Configuration &= 0xffffffc;
+				Configuration |= 0x2;
+				break;
+			case 3:
+				Configuration |= 0x3;
+				break;
 			}
 		}
 		reg16 = cpu2le16(Configuration);
-		pci_write_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset, reg16);
+		pci_write_config_word(pObj->pci_dev, pAd->RLnkCtrlOffset,
+				      reg16);
 		pAd->Rt3xxRalinkLinkCtrl = Configuration;
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("PSM :Write Ralink device L1/L0s Value =  0x%lx\n",
 			  Configuration));
 	}
-	DBGPRINT(RT_DEBUG_INFO,("PSM :RTMPrt3xSetPCIePowerLinkCtrl <==============\n"));
+	DBGPRINT(RT_DEBUG_INFO,
+		 ("PSM :RTMPrt3xSetPCIePowerLinkCtrl <==============\n"));
 }
--- a/drivers/staging/rt2860/rt_linux.c
+++ b/drivers/staging/rt2860/rt_linux.c
@@ -28,128 +28,114 @@
 #include <linux/sched.h>
 #include "rt_config.h"
 
-ULONG	RTDebugLevel = RT_DEBUG_ERROR;
-
+ULONG RTDebugLevel = RT_DEBUG_ERROR;
 
 // for wireless system event message
 char const *pWirelessSysEventText[IW_SYS_EVENT_TYPE_NUM] = {
 	// system status event
-    "had associated successfully",							/* IW_ASSOC_EVENT_FLAG */
-    "had disassociated",									/* IW_DISASSOC_EVENT_FLAG */
-    "had deauthenticated",									/* IW_DEAUTH_EVENT_FLAG */
-    "had been aged-out and disassociated",					/* IW_AGEOUT_EVENT_FLAG */
-    "occurred CounterMeasures attack",						/* IW_COUNTER_MEASURES_EVENT_FLAG */
-    "occurred replay counter different in Key Handshaking",	/* IW_REPLAY_COUNTER_DIFF_EVENT_FLAG */
-    "occurred RSNIE different in Key Handshaking",			/* IW_RSNIE_DIFF_EVENT_FLAG */
-    "occurred MIC different in Key Handshaking",			/* IW_MIC_DIFF_EVENT_FLAG */
-    "occurred ICV error in RX",								/* IW_ICV_ERROR_EVENT_FLAG */
-    "occurred MIC error in RX",								/* IW_MIC_ERROR_EVENT_FLAG */
-	"Group Key Handshaking timeout",						/* IW_GROUP_HS_TIMEOUT_EVENT_FLAG */
-	"Pairwise Key Handshaking timeout",						/* IW_PAIRWISE_HS_TIMEOUT_EVENT_FLAG */
-	"RSN IE sanity check failure",							/* IW_RSNIE_SANITY_FAIL_EVENT_FLAG */
-	"set key done in WPA/WPAPSK",							/* IW_SET_KEY_DONE_WPA1_EVENT_FLAG */
-	"set key done in WPA2/WPA2PSK",                         /* IW_SET_KEY_DONE_WPA2_EVENT_FLAG */
-	"connects with our wireless client",                    /* IW_STA_LINKUP_EVENT_FLAG */
-	"disconnects with our wireless client",                 /* IW_STA_LINKDOWN_EVENT_FLAG */
-	"scan completed"										/* IW_SCAN_COMPLETED_EVENT_FLAG */
-	"scan terminate!! Busy!! Enqueue fail!!"				/* IW_SCAN_ENQUEUE_FAIL_EVENT_FLAG */
-	};
+	"had associated successfully",	/* IW_ASSOC_EVENT_FLAG */
+	"had disassociated",	/* IW_DISASSOC_EVENT_FLAG */
+	"had deauthenticated",	/* IW_DEAUTH_EVENT_FLAG */
+	"had been aged-out and disassociated",	/* IW_AGEOUT_EVENT_FLAG */
+	"occurred CounterMeasures attack",	/* IW_COUNTER_MEASURES_EVENT_FLAG */
+	"occurred replay counter different in Key Handshaking",	/* IW_REPLAY_COUNTER_DIFF_EVENT_FLAG */
+	"occurred RSNIE different in Key Handshaking",	/* IW_RSNIE_DIFF_EVENT_FLAG */
+	"occurred MIC different in Key Handshaking",	/* IW_MIC_DIFF_EVENT_FLAG */
+	"occurred ICV error in RX",	/* IW_ICV_ERROR_EVENT_FLAG */
+	"occurred MIC error in RX",	/* IW_MIC_ERROR_EVENT_FLAG */
+	"Group Key Handshaking timeout",	/* IW_GROUP_HS_TIMEOUT_EVENT_FLAG */
+	"Pairwise Key Handshaking timeout",	/* IW_PAIRWISE_HS_TIMEOUT_EVENT_FLAG */
+	"RSN IE sanity check failure",	/* IW_RSNIE_SANITY_FAIL_EVENT_FLAG */
+	"set key done in WPA/WPAPSK",	/* IW_SET_KEY_DONE_WPA1_EVENT_FLAG */
+	"set key done in WPA2/WPA2PSK",	/* IW_SET_KEY_DONE_WPA2_EVENT_FLAG */
+	"connects with our wireless client",	/* IW_STA_LINKUP_EVENT_FLAG */
+	"disconnects with our wireless client",	/* IW_STA_LINKDOWN_EVENT_FLAG */
+	"scan completed"	/* IW_SCAN_COMPLETED_EVENT_FLAG */
+	    "scan terminate!! Busy!! Enqueue fail!!"	/* IW_SCAN_ENQUEUE_FAIL_EVENT_FLAG */
+};
 
 // for wireless IDS_spoof_attack event message
 char const *pWirelessSpoofEventText[IW_SPOOF_EVENT_TYPE_NUM] = {
-    "detected conflict SSID",								/* IW_CONFLICT_SSID_EVENT_FLAG */
-    "detected spoofed association response",				/* IW_SPOOF_ASSOC_RESP_EVENT_FLAG */
-    "detected spoofed reassociation responses",				/* IW_SPOOF_REASSOC_RESP_EVENT_FLAG */
-    "detected spoofed probe response",						/* IW_SPOOF_PROBE_RESP_EVENT_FLAG */
-    "detected spoofed beacon",								/* IW_SPOOF_BEACON_EVENT_FLAG */
-    "detected spoofed disassociation",						/* IW_SPOOF_DISASSOC_EVENT_FLAG */
-    "detected spoofed authentication",						/* IW_SPOOF_AUTH_EVENT_FLAG */
-    "detected spoofed deauthentication",					/* IW_SPOOF_DEAUTH_EVENT_FLAG */
-    "detected spoofed unknown management frame",			/* IW_SPOOF_UNKNOWN_MGMT_EVENT_FLAG */
-	"detected replay attack"								/* IW_REPLAY_ATTACK_EVENT_FLAG */
-	};
+	"detected conflict SSID",	/* IW_CONFLICT_SSID_EVENT_FLAG */
+	"detected spoofed association response",	/* IW_SPOOF_ASSOC_RESP_EVENT_FLAG */
+	"detected spoofed reassociation responses",	/* IW_SPOOF_REASSOC_RESP_EVENT_FLAG */
+	"detected spoofed probe response",	/* IW_SPOOF_PROBE_RESP_EVENT_FLAG */
+	"detected spoofed beacon",	/* IW_SPOOF_BEACON_EVENT_FLAG */
+	"detected spoofed disassociation",	/* IW_SPOOF_DISASSOC_EVENT_FLAG */
+	"detected spoofed authentication",	/* IW_SPOOF_AUTH_EVENT_FLAG */
+	"detected spoofed deauthentication",	/* IW_SPOOF_DEAUTH_EVENT_FLAG */
+	"detected spoofed unknown management frame",	/* IW_SPOOF_UNKNOWN_MGMT_EVENT_FLAG */
+	"detected replay attack"	/* IW_REPLAY_ATTACK_EVENT_FLAG */
+};
 
 // for wireless IDS_flooding_attack event message
 char const *pWirelessFloodEventText[IW_FLOOD_EVENT_TYPE_NUM] = {
-	"detected authentication flooding",						/* IW_FLOOD_AUTH_EVENT_FLAG */
-    "detected association request flooding",				/* IW_FLOOD_ASSOC_REQ_EVENT_FLAG */
-    "detected reassociation request flooding",				/* IW_FLOOD_REASSOC_REQ_EVENT_FLAG */
-    "detected probe request flooding",						/* IW_FLOOD_PROBE_REQ_EVENT_FLAG */
-    "detected disassociation flooding",						/* IW_FLOOD_DISASSOC_EVENT_FLAG */
-    "detected deauthentication flooding",					/* IW_FLOOD_DEAUTH_EVENT_FLAG */
-    "detected 802.1x eap-request flooding"					/* IW_FLOOD_EAP_REQ_EVENT_FLAG */
-	};
+	"detected authentication flooding",	/* IW_FLOOD_AUTH_EVENT_FLAG */
+	"detected association request flooding",	/* IW_FLOOD_ASSOC_REQ_EVENT_FLAG */
+	"detected reassociation request flooding",	/* IW_FLOOD_REASSOC_REQ_EVENT_FLAG */
+	"detected probe request flooding",	/* IW_FLOOD_PROBE_REQ_EVENT_FLAG */
+	"detected disassociation flooding",	/* IW_FLOOD_DISASSOC_EVENT_FLAG */
+	"detected deauthentication flooding",	/* IW_FLOOD_DEAUTH_EVENT_FLAG */
+	"detected 802.1x eap-request flooding"	/* IW_FLOOD_EAP_REQ_EVENT_FLAG */
+};
 
 /* timeout -- ms */
-VOID RTMP_SetPeriodicTimer(
-	IN	NDIS_MINIPORT_TIMER *pTimer,
-	IN	unsigned long timeout)
+VOID RTMP_SetPeriodicTimer(IN NDIS_MINIPORT_TIMER * pTimer,
+			   IN unsigned long timeout)
 {
-	timeout = ((timeout*OS_HZ) / 1000);
+	timeout = ((timeout * OS_HZ) / 1000);
 	pTimer->expires = jiffies + timeout;
 	add_timer(pTimer);
 }
 
 /* convert NdisMInitializeTimer --> RTMP_OS_Init_Timer */
-VOID RTMP_OS_Init_Timer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	NDIS_MINIPORT_TIMER *pTimer,
-	IN	TIMER_FUNCTION function,
-	IN	PVOID data)
+VOID RTMP_OS_Init_Timer(IN PRTMP_ADAPTER pAd,
+			IN NDIS_MINIPORT_TIMER * pTimer,
+			IN TIMER_FUNCTION function, IN PVOID data)
 {
 	init_timer(pTimer);
-    pTimer->data = (unsigned long)data;
-    pTimer->function = function;
+	pTimer->data = (unsigned long)data;
+	pTimer->function = function;
 }
 
-
-VOID RTMP_OS_Add_Timer(
-	IN	NDIS_MINIPORT_TIMER		*pTimer,
-	IN	unsigned long timeout)
+VOID RTMP_OS_Add_Timer(IN NDIS_MINIPORT_TIMER * pTimer,
+		       IN unsigned long timeout)
 {
 	if (timer_pending(pTimer))
 		return;
 
-	timeout = ((timeout*OS_HZ) / 1000);
+	timeout = ((timeout * OS_HZ) / 1000);
 	pTimer->expires = jiffies + timeout;
 	add_timer(pTimer);
 }
 
-VOID RTMP_OS_Mod_Timer(
-	IN	NDIS_MINIPORT_TIMER		*pTimer,
-	IN	unsigned long timeout)
+VOID RTMP_OS_Mod_Timer(IN NDIS_MINIPORT_TIMER * pTimer,
+		       IN unsigned long timeout)
 {
-	timeout = ((timeout*OS_HZ) / 1000);
+	timeout = ((timeout * OS_HZ) / 1000);
 	mod_timer(pTimer, jiffies + timeout);
 }
 
-VOID RTMP_OS_Del_Timer(
-	IN	NDIS_MINIPORT_TIMER		*pTimer,
-	OUT	BOOLEAN					*pCancelled)
+VOID RTMP_OS_Del_Timer(IN NDIS_MINIPORT_TIMER * pTimer,
+		       OUT BOOLEAN * pCancelled)
 {
-	if (timer_pending(pTimer))
-	{
+	if (timer_pending(pTimer)) {
 		*pCancelled = del_timer_sync(pTimer);
-	}
-	else
-	{
+	} else {
 		*pCancelled = TRUE;
 	}
 
 }
 
-VOID RTMP_OS_Release_Packet(
-	IN	PRTMP_ADAPTER pAd,
-	IN	PQUEUE_ENTRY  pEntry)
+VOID RTMP_OS_Release_Packet(IN PRTMP_ADAPTER pAd, IN PQUEUE_ENTRY pEntry)
 {
 	//RTMPFreeNdisPacket(pAd, (struct sk_buff *)pEntry);
 }
 
 // Unify all delay routine by using udelay
-VOID RTMPusecDelay(
-	IN	ULONG	usec)
+VOID RTMPusecDelay(IN ULONG usec)
 {
-	ULONG	i;
+	ULONG i;
 
 	for (i = 0; i < (usec / 50); i++)
 		udelay(50);
@@ -158,16 +144,13 @@ VOID RTMPusecDelay(
 		udelay(usec % 50);
 }
 
-void RTMP_GetCurrentSystemTime(LARGE_INTEGER *time)
+void RTMP_GetCurrentSystemTime(LARGE_INTEGER * time)
 {
 	time->u.LowPart = jiffies;
 }
 
 // pAd MUST allow to be NULL
-NDIS_STATUS os_alloc_mem(
-	IN	RTMP_ADAPTER *pAd,
-	OUT	UCHAR **mem,
-	IN	ULONG  size)
+NDIS_STATUS os_alloc_mem(IN RTMP_ADAPTER * pAd, OUT UCHAR ** mem, IN ULONG size)
 {
 	*mem = (PUCHAR) kmalloc(size, GFP_ATOMIC);
 	if (*mem)
@@ -177,9 +160,7 @@ NDIS_STATUS os_alloc_mem(
 }
 
 // pAd MUST allow to be NULL
-NDIS_STATUS os_free_mem(
-	IN	PRTMP_ADAPTER pAd,
-	IN	PVOID mem)
+NDIS_STATUS os_free_mem(IN PRTMP_ADAPTER pAd, IN PVOID mem)
 {
 
 	ASSERT(mem);
@@ -187,80 +168,64 @@ NDIS_STATUS os_free_mem(
 	return (NDIS_STATUS_SUCCESS);
 }
 
-
-
-
-PNDIS_PACKET RtmpOSNetPktAlloc(
-	IN RTMP_ADAPTER *pAd,
-	IN int size)
+PNDIS_PACKET RtmpOSNetPktAlloc(IN RTMP_ADAPTER * pAd, IN int size)
 {
 	struct sk_buff *skb;
-	/* Add 2 more bytes for ip header alignment*/
-	skb = dev_alloc_skb(size+2);
+	/* Add 2 more bytes for ip header alignment */
+	skb = dev_alloc_skb(size + 2);
 
-	return ((PNDIS_PACKET)skb);
+	return ((PNDIS_PACKET) skb);
 }
 
-
-PNDIS_PACKET RTMP_AllocateFragPacketBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length)
+PNDIS_PACKET RTMP_AllocateFragPacketBuffer(IN PRTMP_ADAPTER pAd,
+					   IN ULONG Length)
 {
 	struct sk_buff *pkt;
 
 	pkt = dev_alloc_skb(Length);
 
-	if (pkt == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("can't allocate frag rx %ld size packet\n",Length));
+	if (pkt == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("can't allocate frag rx %ld size packet\n", Length));
 	}
 
-	if (pkt)
-	{
+	if (pkt) {
 		RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pkt), PKTSRC_NDIS);
 	}
 
 	return (PNDIS_PACKET) pkt;
 }
 
-
-PNDIS_PACKET RTMP_AllocateTxPacketBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress)
+PNDIS_PACKET RTMP_AllocateTxPacketBuffer(IN PRTMP_ADAPTER pAd,
+					 IN ULONG Length,
+					 IN BOOLEAN Cached,
+					 OUT PVOID * VirtualAddress)
 {
 	struct sk_buff *pkt;
 
 	pkt = dev_alloc_skb(Length);
 
-	if (pkt == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("can't allocate tx %ld size packet\n",Length));
+	if (pkt == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("can't allocate tx %ld size packet\n", Length));
 	}
 
-	if (pkt)
-	{
+	if (pkt) {
 		RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pkt), PKTSRC_NDIS);
 		*VirtualAddress = (PVOID) pkt->data;
-	}
-	else
-	{
+	} else {
 		*VirtualAddress = (PVOID) NULL;
 	}
 
 	return (PNDIS_PACKET) pkt;
 }
 
-
-VOID build_tx_packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	PUCHAR	pFrame,
-	IN	ULONG	FrameLen)
+VOID build_tx_packet(IN PRTMP_ADAPTER pAd,
+		     IN PNDIS_PACKET pPacket,
+		     IN PUCHAR pFrame, IN ULONG FrameLen)
 {
 
-	struct sk_buff	*pTxPkt;
+	struct sk_buff *pTxPkt;
 
 	ASSERT(pPacket);
 	pTxPkt = RTPKT_TO_OSPKT(pPacket);
@@ -268,40 +233,36 @@ VOID build_tx_packet(
 	NdisMoveMemory(skb_put(pTxPkt, FrameLen), pFrame, FrameLen);
 }
 
-VOID	RTMPFreeAdapter(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPFreeAdapter(IN PRTMP_ADAPTER pAd)
 {
-    POS_COOKIE os_cookie;
+	POS_COOKIE os_cookie;
 	int index;
 
-	os_cookie=(POS_COOKIE)pAd->OS_Cookie;
+	os_cookie = (POS_COOKIE) pAd->OS_Cookie;
 
 	if (pAd->BeaconBuf)
-	kfree(pAd->BeaconBuf);
-
+		kfree(pAd->BeaconBuf);
 
 	NdisFreeSpinLock(&pAd->MgmtRingLock);
 
 #ifdef RTMP_MAC_PCI
 	NdisFreeSpinLock(&pAd->RxRingLock);
 #ifdef RT3090
-NdisFreeSpinLock(&pAd->McuCmdLock);
+	NdisFreeSpinLock(&pAd->McuCmdLock);
 #endif // RT3090 //
 #endif // RTMP_MAC_PCI //
 
-	for (index =0 ; index < NUM_OF_TX_RING; index++)
-	{
-    	NdisFreeSpinLock(&pAd->TxSwQueueLock[index]);
+	for (index = 0; index < NUM_OF_TX_RING; index++) {
+		NdisFreeSpinLock(&pAd->TxSwQueueLock[index]);
 		NdisFreeSpinLock(&pAd->DeQueueLock[index]);
 		pAd->DeQueueRunning[index] = FALSE;
 	}
 
 	NdisFreeSpinLock(&pAd->irq_lock);
 
-
-	vfree(pAd); // pci_free_consistent(os_cookie->pci_dev,sizeof(RTMP_ADAPTER),pAd,os_cookie->pAd_pa);
+	vfree(pAd);		// pci_free_consistent(os_cookie->pci_dev,sizeof(RTMP_ADAPTER),pAd,os_cookie->pAd_pa);
 	if (os_cookie)
-	kfree(os_cookie);
+		kfree(os_cookie);
 }
 
 BOOLEAN OS_Need_Clone_Packet(void)
@@ -309,8 +270,6 @@ BOOLEAN OS_Need_Clone_Packet(void)
 	return (FALSE);
 }
 
-
-
 /*
 	========================================================================
 
@@ -333,11 +292,10 @@ BOOLEAN OS_Need_Clone_Packet(void)
 
 	========================================================================
 */
-NDIS_STATUS RTMPCloneNdisPacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	BOOLEAN			pInsAMSDUHdr,
-	IN	PNDIS_PACKET	pInPacket,
-	OUT PNDIS_PACKET   *ppOutPacket)
+NDIS_STATUS RTMPCloneNdisPacket(IN PRTMP_ADAPTER pAd,
+				IN BOOLEAN pInsAMSDUHdr,
+				IN PNDIS_PACKET pInPacket,
+				OUT PNDIS_PACKET * ppOutPacket)
 {
 
 	struct sk_buff *pkt;
@@ -348,16 +306,15 @@ NDIS_STATUS RTMPCloneNdisPacket(
 	// 1. Allocate a packet
 	pkt = dev_alloc_skb(2048);
 
-	if (pkt == NULL)
-	{
+	if (pkt == NULL) {
 		return NDIS_STATUS_FAILURE;
 	}
 
- 	skb_put(pkt, GET_OS_PKT_LEN(pInPacket));
-	NdisMoveMemory(pkt->data, GET_OS_PKT_DATAPTR(pInPacket), GET_OS_PKT_LEN(pInPacket));
+	skb_put(pkt, GET_OS_PKT_LEN(pInPacket));
+	NdisMoveMemory(pkt->data, GET_OS_PKT_DATAPTR(pInPacket),
+		       GET_OS_PKT_LEN(pInPacket));
 	*ppOutPacket = OSPKT_TO_RTPKT(pkt);
 
-
 	RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pkt), PKTSRC_NDIS);
 
 	printk("###Clone###\n");
@@ -365,42 +322,40 @@ NDIS_STATUS RTMPCloneNdisPacket(
 	return NDIS_STATUS_SUCCESS;
 }
 
-
 // the allocated NDIS PACKET must be freed via RTMPFreeNdisPacket()
-NDIS_STATUS RTMPAllocateNdisPacket(
-	IN	PRTMP_ADAPTER	pAd,
-	OUT PNDIS_PACKET   *ppPacket,
-	IN	PUCHAR			pHeader,
-	IN	UINT			HeaderLen,
-	IN	PUCHAR			pData,
-	IN	UINT			DataLen)
+NDIS_STATUS RTMPAllocateNdisPacket(IN PRTMP_ADAPTER pAd,
+				   OUT PNDIS_PACKET * ppPacket,
+				   IN PUCHAR pHeader,
+				   IN UINT HeaderLen,
+				   IN PUCHAR pData, IN UINT DataLen)
 {
-	PNDIS_PACKET	pPacket;
+	PNDIS_PACKET pPacket;
 	ASSERT(pData);
 	ASSERT(DataLen);
 
 	// 1. Allocate a packet
-	pPacket = (PNDIS_PACKET *) dev_alloc_skb(HeaderLen + DataLen + RTMP_PKT_TAIL_PADDING);
-	if (pPacket == NULL)
- 	{
+	pPacket =
+	    (PNDIS_PACKET *) dev_alloc_skb(HeaderLen + DataLen +
+					   RTMP_PKT_TAIL_PADDING);
+	if (pPacket == NULL) {
 		*ppPacket = NULL;
 #ifdef DEBUG
 		printk("RTMPAllocateNdisPacket Fail\n\n");
 #endif
 		return NDIS_STATUS_FAILURE;
 	}
-
 	// 2. clone the frame content
 	if (HeaderLen > 0)
 		NdisMoveMemory(GET_OS_PKT_DATAPTR(pPacket), pHeader, HeaderLen);
 	if (DataLen > 0)
-		NdisMoveMemory(GET_OS_PKT_DATAPTR(pPacket) + HeaderLen, pData, DataLen);
+		NdisMoveMemory(GET_OS_PKT_DATAPTR(pPacket) + HeaderLen, pData,
+			       DataLen);
 
 	// 3. update length of packet
- 	skb_put(GET_OS_PKT_TYPE(pPacket), HeaderLen+DataLen);
+	skb_put(GET_OS_PKT_TYPE(pPacket), HeaderLen + DataLen);
 
 	RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
-//	printk("%s : pPacket = %p, len = %d\n", __func__, pPacket, GET_OS_PKT_LEN(pPacket));
+//      printk("%s : pPacket = %p, len = %d\n", __func__, pPacket, GET_OS_PKT_LEN(pPacket));
 	*ppPacket = pPacket;
 	return NDIS_STATUS_SUCCESS;
 }
@@ -412,38 +367,30 @@ NDIS_STATUS RTMPAllocateNdisPacket(
 	corresponding NDIS_BUFFER and allocated memory.
   ========================================================================
 */
-VOID RTMPFreeNdisPacket(
-	IN PRTMP_ADAPTER pAd,
-	IN PNDIS_PACKET  pPacket)
+VOID RTMPFreeNdisPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 {
 	dev_kfree_skb_any(RTPKT_TO_OSPKT(pPacket));
 }
 
-
 // IRQL = DISPATCH_LEVEL
 // NOTE: we do have an assumption here, that Byte0 and Byte1 always reasid at the same
-//			 scatter gather buffer
-NDIS_STATUS Sniff2BytesFromNdisBuffer(
-	IN	PNDIS_BUFFER	pFirstBuffer,
-	IN	UCHAR			DesiredOffset,
-	OUT PUCHAR			pByte0,
-	OUT PUCHAR			pByte1)
+//                       scatter gather buffer
+NDIS_STATUS Sniff2BytesFromNdisBuffer(IN PNDIS_BUFFER pFirstBuffer,
+				      IN UCHAR DesiredOffset,
+				      OUT PUCHAR pByte0, OUT PUCHAR pByte1)
 {
-    *pByte0 = *(PUCHAR)(pFirstBuffer + DesiredOffset);
-    *pByte1 = *(PUCHAR)(pFirstBuffer + DesiredOffset + 1);
+	*pByte0 = *(PUCHAR) (pFirstBuffer + DesiredOffset);
+	*pByte1 = *(PUCHAR) (pFirstBuffer + DesiredOffset + 1);
 
 	return NDIS_STATUS_SUCCESS;
 }
 
-
-void RTMP_QueryPacketInfo(
-	IN  PNDIS_PACKET pPacket,
-	OUT PACKET_INFO  *pPacketInfo,
-	OUT PUCHAR		 *pSrcBufVA,
-	OUT	UINT		 *pSrcBufLen)
+void RTMP_QueryPacketInfo(IN PNDIS_PACKET pPacket,
+			  OUT PACKET_INFO * pPacketInfo,
+			  OUT PUCHAR * pSrcBufVA, OUT UINT * pSrcBufLen)
 {
 	pPacketInfo->BufferCount = 1;
-	pPacketInfo->pFirstBuffer = (PNDIS_BUFFER)GET_OS_PKT_DATAPTR(pPacket);
+	pPacketInfo->pFirstBuffer = (PNDIS_BUFFER) GET_OS_PKT_DATAPTR(pPacket);
 	pPacketInfo->PhysicalBufferCount = 1;
 	pPacketInfo->TotalPacketLength = GET_OS_PKT_LEN(pPacket);
 
@@ -451,30 +398,26 @@ void RTMP_QueryPacketInfo(
 	*pSrcBufLen = GET_OS_PKT_LEN(pPacket);
 }
 
-void RTMP_QueryNextPacketInfo(
-	IN  PNDIS_PACKET *ppPacket,
-	OUT PACKET_INFO  *pPacketInfo,
-	OUT PUCHAR		 *pSrcBufVA,
-	OUT	UINT		 *pSrcBufLen)
+void RTMP_QueryNextPacketInfo(IN PNDIS_PACKET * ppPacket,
+			      OUT PACKET_INFO * pPacketInfo,
+			      OUT PUCHAR * pSrcBufVA, OUT UINT * pSrcBufLen)
 {
 	PNDIS_PACKET pPacket = NULL;
 
 	if (*ppPacket)
 		pPacket = GET_OS_PKT_NEXT(*ppPacket);
 
-	if (pPacket)
-	{
+	if (pPacket) {
 		pPacketInfo->BufferCount = 1;
-		pPacketInfo->pFirstBuffer = (PNDIS_BUFFER)GET_OS_PKT_DATAPTR(pPacket);
+		pPacketInfo->pFirstBuffer =
+		    (PNDIS_BUFFER) GET_OS_PKT_DATAPTR(pPacket);
 		pPacketInfo->PhysicalBufferCount = 1;
 		pPacketInfo->TotalPacketLength = GET_OS_PKT_LEN(pPacket);
 
 		*pSrcBufVA = GET_OS_PKT_DATAPTR(pPacket);
 		*pSrcBufLen = GET_OS_PKT_LEN(pPacket);
 		*ppPacket = GET_OS_PKT_NEXT(pPacket);
-	}
-	else
-	{
+	} else {
 		pPacketInfo->BufferCount = 0;
 		pPacketInfo->pFirstBuffer = NULL;
 		pPacketInfo->PhysicalBufferCount = 0;
@@ -486,24 +429,19 @@ void RTMP_QueryNextPacketInfo(
 	}
 }
 
-
-PNDIS_PACKET DuplicatePacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	UCHAR			FromWhichBSSID)
-{
-	struct sk_buff	*skb;
-	PNDIS_PACKET	pRetPacket = NULL;
-	USHORT			DataSize;
-	UCHAR			*pData;
+PNDIS_PACKET DuplicatePacket(IN PRTMP_ADAPTER pAd,
+			     IN PNDIS_PACKET pPacket, IN UCHAR FromWhichBSSID)
+{
+	struct sk_buff *skb;
+	PNDIS_PACKET pRetPacket = NULL;
+	USHORT DataSize;
+	UCHAR *pData;
 
 	DataSize = (USHORT) GET_OS_PKT_LEN(pPacket);
 	pData = (PUCHAR) GET_OS_PKT_DATAPTR(pPacket);
 
-
 	skb = skb_clone(RTPKT_TO_OSPKT(pPacket), MEM_ALLOC_FLAG);
-	if (skb)
-	{
+	if (skb) {
 		skb->dev = get_netdev_from_bssid(pAd, FromWhichBSSID);
 		pRetPacket = OSPKT_TO_RTPKT(skb);
 	}
@@ -512,20 +450,17 @@ PNDIS_PACKET DuplicatePacket(
 
 }
 
-PNDIS_PACKET duplicate_pkt(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pHeader802_3,
-    IN  UINT            HdrLen,
-	IN	PUCHAR			pData,
-	IN	ULONG			DataSize,
-	IN	UCHAR			FromWhichBSSID)
+PNDIS_PACKET duplicate_pkt(IN PRTMP_ADAPTER pAd,
+			   IN PUCHAR pHeader802_3,
+			   IN UINT HdrLen,
+			   IN PUCHAR pData,
+			   IN ULONG DataSize, IN UCHAR FromWhichBSSID)
 {
-	struct sk_buff	*skb;
-	PNDIS_PACKET	pPacket = NULL;
-
+	struct sk_buff *skb;
+	PNDIS_PACKET pPacket = NULL;
 
-	if ((skb = __dev_alloc_skb(HdrLen + DataSize + 2, MEM_ALLOC_FLAG)) != NULL)
-	{
+	if ((skb =
+	     __dev_alloc_skb(HdrLen + DataSize + 2, MEM_ALLOC_FLAG)) != NULL) {
 		skb_reserve(skb, 2);
 		NdisMoveMemory(skb->tail, pHeader802_3, HdrLen);
 		skb_put(skb, HdrLen);
@@ -538,24 +473,22 @@ PNDIS_PACKET duplicate_pkt(
 	return pPacket;
 }
 
-
 #define TKIP_TX_MIC_SIZE		8
-PNDIS_PACKET duplicate_pkt_with_TKIP_MIC(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket)
+PNDIS_PACKET duplicate_pkt_with_TKIP_MIC(IN PRTMP_ADAPTER pAd,
+					 IN PNDIS_PACKET pPacket)
 {
-	struct sk_buff	*skb, *newskb;
-
+	struct sk_buff *skb, *newskb;
 
 	skb = RTPKT_TO_OSPKT(pPacket);
-	if (skb_tailroom(skb) < TKIP_TX_MIC_SIZE)
-	{
+	if (skb_tailroom(skb) < TKIP_TX_MIC_SIZE) {
 		// alloc a new skb and copy the packet
-		newskb = skb_copy_expand(skb, skb_headroom(skb), TKIP_TX_MIC_SIZE, GFP_ATOMIC);
+		newskb =
+		    skb_copy_expand(skb, skb_headroom(skb), TKIP_TX_MIC_SIZE,
+				    GFP_ATOMIC);
 		dev_kfree_skb_any(skb);
-		if (newskb == NULL)
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("Extend Tx.MIC for packet failed!, dropping packet!\n"));
+		if (newskb == NULL) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Extend Tx.MIC for packet failed!, dropping packet!\n"));
 			return NULL;
 		}
 		skb = newskb;
@@ -564,17 +497,12 @@ PNDIS_PACKET duplicate_pkt_with_TKIP_MIC
 	return OSPKT_TO_RTPKT(skb);
 }
 
-
-
-
-PNDIS_PACKET ClonePacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	PUCHAR			pData,
-	IN	ULONG			DataSize)
+PNDIS_PACKET ClonePacket(IN PRTMP_ADAPTER pAd,
+			 IN PNDIS_PACKET pPacket,
+			 IN PUCHAR pData, IN ULONG DataSize)
 {
-	struct sk_buff	*pRxPkt;
-	struct sk_buff	*pClonedPkt;
+	struct sk_buff *pRxPkt;
+	struct sk_buff *pClonedPkt;
 
 	ASSERT(pPacket);
 	pRxPkt = RTPKT_TO_OSPKT(pPacket);
@@ -582,13 +510,12 @@ PNDIS_PACKET ClonePacket(
 	// clone the packet
 	pClonedPkt = skb_clone(pRxPkt, MEM_ALLOC_FLAG);
 
-	if (pClonedPkt)
-	{
-    	// set the correct dataptr and data len
-    	pClonedPkt->dev = pRxPkt->dev;
-    	pClonedPkt->data = pData;
-    	pClonedPkt->len = DataSize;
-    	pClonedPkt->tail = pClonedPkt->data + pClonedPkt->len;
+	if (pClonedPkt) {
+		// set the correct dataptr and data len
+		pClonedPkt->dev = pRxPkt->dev;
+		pClonedPkt->data = pData;
+		pClonedPkt->len = DataSize;
+		pClonedPkt->tail = pClonedPkt->data + pClonedPkt->len;
 		ASSERT(DataSize < 1530);
 	}
 	return pClonedPkt;
@@ -597,12 +524,10 @@ PNDIS_PACKET ClonePacket(
 //
 // change OS packet DataPtr and DataLen
 //
-void  update_os_packet_info(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN  UCHAR			FromWhichBSSID)
+void update_os_packet_info(IN PRTMP_ADAPTER pAd,
+			   IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
-	struct sk_buff	*pOSPkt;
+	struct sk_buff *pOSPkt;
 
 	ASSERT(pRxBlk->pRxPacket);
 	pOSPkt = RTPKT_TO_OSPKT(pRxBlk->pRxPacket);
@@ -613,14 +538,12 @@ void  update_os_packet_info(
 	pOSPkt->tail = pOSPkt->data + pOSPkt->len;
 }
 
-
-void wlan_802_11_to_802_3_packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk,
-	IN	PUCHAR			pHeader802_3,
-	IN  UCHAR			FromWhichBSSID)
+void wlan_802_11_to_802_3_packet(IN PRTMP_ADAPTER pAd,
+				 IN RX_BLK * pRxBlk,
+				 IN PUCHAR pHeader802_3,
+				 IN UCHAR FromWhichBSSID)
 {
-	struct sk_buff	*pOSPkt;
+	struct sk_buff *pOSPkt;
 
 	ASSERT(pRxBlk->pRxPacket);
 	ASSERT(pHeader802_3);
@@ -637,34 +560,30 @@ void wlan_802_11_to_802_3_packet(
 	//
 	//
 
-	NdisMoveMemory(skb_push(pOSPkt, LENGTH_802_3), pHeader802_3, LENGTH_802_3);
-	}
-
-
+	NdisMoveMemory(skb_push(pOSPkt, LENGTH_802_3), pHeader802_3,
+		       LENGTH_802_3);
+}
 
-void announce_802_3_packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket)
+void announce_802_3_packet(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 {
 
-	struct sk_buff	*pRxPkt;
+	struct sk_buff *pRxPkt;
 
 	ASSERT(pPacket);
 
 	pRxPkt = RTPKT_TO_OSPKT(pPacket);
 
-    /* Push up the protocol stack */
+	/* Push up the protocol stack */
 	pRxPkt->protocol = eth_type_trans(pRxPkt, pRxPkt->dev);
 
 	netif_rx(pRxPkt);
 }
 
-
 PRTMP_SCATTER_GATHER_LIST
-rt_get_sg_list_from_packet(PNDIS_PACKET pPacket, RTMP_SCATTER_GATHER_LIST *sg)
+rt_get_sg_list_from_packet(PNDIS_PACKET pPacket, RTMP_SCATTER_GATHER_LIST * sg)
 {
 	sg->NumberOfElements = 1;
-	sg->Elements[0].Address =  GET_OS_PKT_DATAPTR(pPacket);
+	sg->Elements[0].Address = GET_OS_PKT_DATAPTR(pPacket);
 	sg->Elements[0].Length = GET_OS_PKT_LEN(pPacket);
 	return (sg);
 }
@@ -678,13 +597,13 @@ void hex_dump(char *str, unsigned char *
 		return;
 
 	pt = pSrcBufVA;
-	printk("%s: %p, len = %d\n",str,  pSrcBufVA, SrcBufLen);
-	for (x=0; x<SrcBufLen; x++)
-	{
+	printk("%s: %p, len = %d\n", str, pSrcBufVA, SrcBufLen);
+	for (x = 0; x < SrcBufLen; x++) {
 		if (x % 16 == 0)
 			printk("0x%04x : ", x);
 		printk("%02x ", ((unsigned char)pt[x]));
-		if (x%16 == 15) printk("\n");
+		if (x % 16 == 15)
+			printk("\n");
 	}
 	printk("\n");
 }
@@ -709,181 +628,197 @@ void hex_dump(char *str, unsigned char *
 
 	========================================================================
 */
-VOID RTMPSendWirelessEvent(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Event_flag,
-	IN	PUCHAR 			pAddr,
-	IN	UCHAR			BssIdx,
-	IN	CHAR			Rssi)
+VOID RTMPSendWirelessEvent(IN PRTMP_ADAPTER pAd,
+			   IN USHORT Event_flag,
+			   IN PUCHAR pAddr, IN UCHAR BssIdx, IN CHAR Rssi)
 {
 
-	//union		iwreq_data      wrqu;
-	PSTRING	pBuf = NULL, pBufPtr = NULL;
-	USHORT	event, type, BufLen;
-	UCHAR	event_table_len = 0;
+	//union         iwreq_data      wrqu;
+	PSTRING pBuf = NULL, pBufPtr = NULL;
+	USHORT event, type, BufLen;
+	UCHAR event_table_len = 0;
 
 	type = Event_flag & 0xFF00;
 	event = Event_flag & 0x00FF;
 
-	switch (type)
-	{
-		case IW_SYS_EVENT_FLAG_START:
-			event_table_len = IW_SYS_EVENT_TYPE_NUM;
-			break;
+	switch (type) {
+	case IW_SYS_EVENT_FLAG_START:
+		event_table_len = IW_SYS_EVENT_TYPE_NUM;
+		break;
 
-		case IW_SPOOF_EVENT_FLAG_START:
-			event_table_len = IW_SPOOF_EVENT_TYPE_NUM;
-			break;
+	case IW_SPOOF_EVENT_FLAG_START:
+		event_table_len = IW_SPOOF_EVENT_TYPE_NUM;
+		break;
 
-		case IW_FLOOD_EVENT_FLAG_START:
-			event_table_len = IW_FLOOD_EVENT_TYPE_NUM;
-			break;
+	case IW_FLOOD_EVENT_FLAG_START:
+		event_table_len = IW_FLOOD_EVENT_TYPE_NUM;
+		break;
 	}
 
-	if (event_table_len == 0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s : The type(%0x02x) is not valid.\n", __func__, type));
+	if (event_table_len == 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s : The type(%0x02x) is not valid.\n", __func__,
+			  type));
 		return;
 	}
 
-	if (event >= event_table_len)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s : The event(%0x02x) is not valid.\n", __func__, event));
+	if (event >= event_table_len) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s : The event(%0x02x) is not valid.\n", __func__,
+			  event));
 		return;
 	}
-
 	//Allocate memory and copy the msg.
-	if((pBuf = kmalloc(IW_CUSTOM_MAX_LEN, GFP_ATOMIC)) != NULL)
-	{
+	if ((pBuf = kmalloc(IW_CUSTOM_MAX_LEN, GFP_ATOMIC)) != NULL) {
 		//Prepare the payload
 		memset(pBuf, 0, IW_CUSTOM_MAX_LEN);
 
 		pBufPtr = pBuf;
 
 		if (pAddr)
-			pBufPtr += sprintf(pBufPtr, "(RT2860) STA(%02x:%02x:%02x:%02x:%02x:%02x) ", PRINT_MAC(pAddr));
+			pBufPtr +=
+			    sprintf(pBufPtr,
+				    "(RT2860) STA(%02x:%02x:%02x:%02x:%02x:%02x) ",
+				    PRINT_MAC(pAddr));
 		else if (BssIdx < MAX_MBSSID_NUM)
-			pBufPtr += sprintf(pBufPtr, "(RT2860) BSS(wlan%d) ", BssIdx);
+			pBufPtr +=
+			    sprintf(pBufPtr, "(RT2860) BSS(wlan%d) ", BssIdx);
 		else
 			pBufPtr += sprintf(pBufPtr, "(RT2860) ");
 
 		if (type == IW_SYS_EVENT_FLAG_START)
-			pBufPtr += sprintf(pBufPtr, "%s", pWirelessSysEventText[event]);
+			pBufPtr +=
+			    sprintf(pBufPtr, "%s",
+				    pWirelessSysEventText[event]);
 		else if (type == IW_SPOOF_EVENT_FLAG_START)
-			pBufPtr += sprintf(pBufPtr, "%s (RSSI=%d)", pWirelessSpoofEventText[event], Rssi);
+			pBufPtr +=
+			    sprintf(pBufPtr, "%s (RSSI=%d)",
+				    pWirelessSpoofEventText[event], Rssi);
 		else if (type == IW_FLOOD_EVENT_FLAG_START)
-			pBufPtr += sprintf(pBufPtr, "%s", pWirelessFloodEventText[event]);
+			pBufPtr +=
+			    sprintf(pBufPtr, "%s",
+				    pWirelessFloodEventText[event]);
 		else
 			pBufPtr += sprintf(pBufPtr, "%s", "unknown event");
 
 		pBufPtr[pBufPtr - pBuf] = '\0';
 		BufLen = pBufPtr - pBuf;
 
-		RtmpOSWrielessEventSend(pAd, IWEVCUSTOM, Event_flag, NULL, (PUCHAR)pBuf, BufLen);
+		RtmpOSWrielessEventSend(pAd, IWEVCUSTOM, Event_flag, NULL,
+					(PUCHAR) pBuf, BufLen);
 		//DBGPRINT(RT_DEBUG_TRACE, ("%s : %s\n", __func__, pBuf));
 
 		kfree(pBuf);
-	}
-	else
-		DBGPRINT(RT_DEBUG_ERROR, ("%s : Can't allocate memory for wireless event.\n", __func__));
+	} else
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s : Can't allocate memory for wireless event.\n",
+			  __func__));
 }
 
-void send_monitor_packets(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk)
+void send_monitor_packets(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 {
-    struct sk_buff	*pOSPkt;
-    wlan_ng_prism2_header *ph;
-    int rate_index = 0;
-    USHORT header_len = 0;
-    UCHAR temp_header[40] = {0};
-
-    u_int32_t ralinkrate[256] = {2,4,11,22, 12,18,24,36,48,72,96,  108,   109, 110, 111, 112, 13, 26, 39, 52,78,104, 117, 130, 26, 52, 78,104, 156, 208, 234, 260, 27, 54,81,108,162, 216, 243, 270, // Last 38
-	54, 108, 162, 216, 324, 432, 486, 540,  14, 29, 43, 57, 87, 115, 130, 144, 29, 59,87,115, 173, 230,260, 288, 30, 60,90,120,180,240,270,300,60,120,180,240,360,480,540,600, 0,1,2,3,4,5,6,7,8,9,10,
-	11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80};
-
+	struct sk_buff *pOSPkt;
+	wlan_ng_prism2_header *ph;
+	int rate_index = 0;
+	USHORT header_len = 0;
+	UCHAR temp_header[40] = { 0 };
+
+	u_int32_t ralinkrate[256] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 109, 110, 111, 112, 13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260, 27, 54, 81, 108, 162, 216, 243, 270,	// Last 38
+		54, 108, 162, 216, 324, 432, 486, 540, 14, 29, 43, 57, 87, 115,
+		    130, 144, 29, 59, 87, 115, 173, 230, 260, 288, 30, 60, 90,
+		    120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540,
+		    600, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+		11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
+		    27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+		    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
+		    57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
+		    72, 73, 74, 75, 76, 77, 78, 79, 80
+	};
 
-    ASSERT(pRxBlk->pRxPacket);
-    if (pRxBlk->DataSize < 10)
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("%s : Size is too small! (%d)\n", __func__, pRxBlk->DataSize));
+	ASSERT(pRxBlk->pRxPacket);
+	if (pRxBlk->DataSize < 10) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s : Size is too small! (%d)\n", __func__,
+			  pRxBlk->DataSize));
 		goto err_free_sk_buff;
-    }
+	}
 
-    if (pRxBlk->DataSize + sizeof(wlan_ng_prism2_header) > RX_BUFFER_AGGRESIZE)
-    {
-        DBGPRINT(RT_DEBUG_ERROR, ("%s : Size is too large! (%zu)\n", __func__, pRxBlk->DataSize + sizeof(wlan_ng_prism2_header)));
+	if (pRxBlk->DataSize + sizeof(wlan_ng_prism2_header) >
+	    RX_BUFFER_AGGRESIZE) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s : Size is too large! (%zu)\n", __func__,
+			  pRxBlk->DataSize + sizeof(wlan_ng_prism2_header)));
 		goto err_free_sk_buff;
-    }
+	}
 
-    pOSPkt = RTPKT_TO_OSPKT(pRxBlk->pRxPacket);
+	pOSPkt = RTPKT_TO_OSPKT(pRxBlk->pRxPacket);
 	pOSPkt->dev = get_netdev_from_bssid(pAd, BSS0);
-    if (pRxBlk->pHeader->FC.Type == BTYPE_DATA)
-    {
-        pRxBlk->DataSize -= LENGTH_802_11;
-        if ((pRxBlk->pHeader->FC.ToDs == 1) &&
-            (pRxBlk->pHeader->FC.FrDs == 1))
-            header_len = LENGTH_802_11_WITH_ADDR4;
-        else
-            header_len = LENGTH_802_11;
-
-        // QOS
-    	if (pRxBlk->pHeader->FC.SubType & 0x08)
-    	{
-    	    header_len += 2;
-    		// Data skip QOS contorl field
-    		pRxBlk->DataSize -=2;
-    	}
-
-    	// Order bit: A-Ralink or HTC+
-    	if (pRxBlk->pHeader->FC.Order)
-    	{
-    	    header_len += 4;
+	if (pRxBlk->pHeader->FC.Type == BTYPE_DATA) {
+		pRxBlk->DataSize -= LENGTH_802_11;
+		if ((pRxBlk->pHeader->FC.ToDs == 1) &&
+		    (pRxBlk->pHeader->FC.FrDs == 1))
+			header_len = LENGTH_802_11_WITH_ADDR4;
+		else
+			header_len = LENGTH_802_11;
+
+		// QOS
+		if (pRxBlk->pHeader->FC.SubType & 0x08) {
+			header_len += 2;
+			// Data skip QOS contorl field
+			pRxBlk->DataSize -= 2;
+		}
+		// Order bit: A-Ralink or HTC+
+		if (pRxBlk->pHeader->FC.Order) {
+			header_len += 4;
 			// Data skip HTC contorl field
 			pRxBlk->DataSize -= 4;
-    	}
-
-        // Copy Header
-        if (header_len <= 40)
-            NdisMoveMemory(temp_header, pRxBlk->pData, header_len);
-
-        // skip HW padding
-    	if (pRxBlk->RxD.L2PAD)
-    	    pRxBlk->pData += (header_len + 2);
-        else
-            pRxBlk->pData += header_len;
-    } //end if
-
+		}
+		// Copy Header
+		if (header_len <= 40)
+			NdisMoveMemory(temp_header, pRxBlk->pData, header_len);
+
+		// skip HW padding
+		if (pRxBlk->RxD.L2PAD)
+			pRxBlk->pData += (header_len + 2);
+		else
+			pRxBlk->pData += header_len;
+	}			//end if
 
 	if (pRxBlk->DataSize < pOSPkt->len) {
-        skb_trim(pOSPkt,pRxBlk->DataSize);
-    } else {
-        skb_put(pOSPkt,(pRxBlk->DataSize - pOSPkt->len));
-    } //end if
-
-    if ((pRxBlk->pData - pOSPkt->data) > 0) {
-	    skb_put(pOSPkt,(pRxBlk->pData - pOSPkt->data));
-	    skb_pull(pOSPkt,(pRxBlk->pData - pOSPkt->data));
-    } //end if
-
-    if (skb_headroom(pOSPkt) < (sizeof(wlan_ng_prism2_header)+ header_len)) {
-        if (pskb_expand_head(pOSPkt, (sizeof(wlan_ng_prism2_header) + header_len), 0, GFP_ATOMIC)) {
-	        DBGPRINT(RT_DEBUG_ERROR, ("%s : Reallocate header size of sk_buff fail!\n", __func__));
+		skb_trim(pOSPkt, pRxBlk->DataSize);
+	} else {
+		skb_put(pOSPkt, (pRxBlk->DataSize - pOSPkt->len));
+	}			//end if
+
+	if ((pRxBlk->pData - pOSPkt->data) > 0) {
+		skb_put(pOSPkt, (pRxBlk->pData - pOSPkt->data));
+		skb_pull(pOSPkt, (pRxBlk->pData - pOSPkt->data));
+	}			//end if
+
+	if (skb_headroom(pOSPkt) < (sizeof(wlan_ng_prism2_header) + header_len)) {
+		if (pskb_expand_head
+		    (pOSPkt, (sizeof(wlan_ng_prism2_header) + header_len), 0,
+		     GFP_ATOMIC)) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s : Reallocate header size of sk_buff fail!\n",
+				  __func__));
 			goto err_free_sk_buff;
-	    } //end if
-    } //end if
+		}		//end if
+	}			//end if
 
-    if (header_len > 0)
-        NdisMoveMemory(skb_push(pOSPkt, header_len), temp_header, header_len);
+	if (header_len > 0)
+		NdisMoveMemory(skb_push(pOSPkt, header_len), temp_header,
+			       header_len);
 
-    ph = (wlan_ng_prism2_header *) skb_push(pOSPkt, sizeof(wlan_ng_prism2_header));
+	ph = (wlan_ng_prism2_header *) skb_push(pOSPkt,
+						sizeof(wlan_ng_prism2_header));
 	NdisZeroMemory(ph, sizeof(wlan_ng_prism2_header));
 
-    ph->msgcode		    = DIDmsg_lnxind_wlansniffrm;
-	ph->msglen		    = sizeof(wlan_ng_prism2_header);
+	ph->msgcode = DIDmsg_lnxind_wlansniffrm;
+	ph->msglen = sizeof(wlan_ng_prism2_header);
 	strcpy((PSTRING) ph->devname, (PSTRING) pAd->net_dev->name);
 
-    ph->hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
+	ph->hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
 	ph->hosttime.status = 0;
 	ph->hosttime.len = 4;
 	ph->hosttime.data = jiffies;
@@ -893,63 +828,71 @@ void send_monitor_packets(
 	ph->mactime.len = 0;
 	ph->mactime.data = 0;
 
-    ph->istx.did = DIDmsg_lnxind_wlansniffrm_istx;
+	ph->istx.did = DIDmsg_lnxind_wlansniffrm_istx;
 	ph->istx.status = 0;
 	ph->istx.len = 0;
 	ph->istx.data = 0;
 
-    ph->channel.did = DIDmsg_lnxind_wlansniffrm_channel;
+	ph->channel.did = DIDmsg_lnxind_wlansniffrm_channel;
 	ph->channel.status = 0;
 	ph->channel.len = 4;
 
-    ph->channel.data = (u_int32_t)pAd->CommonCfg.Channel;
+	ph->channel.data = (u_int32_t) pAd->CommonCfg.Channel;
 
-    ph->rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
+	ph->rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
 	ph->rssi.status = 0;
 	ph->rssi.len = 4;
-    ph->rssi.data = (u_int32_t)RTMPMaxRssi(pAd, ConvertToRssi(pAd, pRxBlk->pRxWI->RSSI0, RSSI_0), ConvertToRssi(pAd, pRxBlk->pRxWI->RSSI1, RSSI_1), ConvertToRssi(pAd, pRxBlk->pRxWI->RSSI2, RSSI_2));;
+	ph->rssi.data =
+	    (u_int32_t) RTMPMaxRssi(pAd,
+				    ConvertToRssi(pAd, pRxBlk->pRxWI->RSSI0,
+						  RSSI_0), ConvertToRssi(pAd,
+									 pRxBlk->
+									 pRxWI->
+									 RSSI1,
+									 RSSI_1),
+				    ConvertToRssi(pAd, pRxBlk->pRxWI->RSSI2,
+						  RSSI_2));;
 
 	ph->signal.did = DIDmsg_lnxind_wlansniffrm_signal;
 	ph->signal.status = 0;
 	ph->signal.len = 4;
-	ph->signal.data = 0; //rssi + noise;
+	ph->signal.data = 0;	//rssi + noise;
 
 	ph->noise.did = DIDmsg_lnxind_wlansniffrm_noise;
 	ph->noise.status = 0;
 	ph->noise.len = 4;
 	ph->noise.data = 0;
 
-    if (pRxBlk->pRxWI->PHYMODE >= MODE_HTMIX)
-    {
-    	rate_index = 16 + ((UCHAR)pRxBlk->pRxWI->BW *16) + ((UCHAR)pRxBlk->pRxWI->ShortGI *32) + ((UCHAR)pRxBlk->pRxWI->MCS);
-    }
-    else
-	if (pRxBlk->pRxWI->PHYMODE == MODE_OFDM)
-    	rate_index = (UCHAR)(pRxBlk->pRxWI->MCS) + 4;
-    else
-    	rate_index = (UCHAR)(pRxBlk->pRxWI->MCS);
-    if (rate_index < 0)
-        rate_index = 0;
-    if (rate_index > 255)
-        rate_index = 255;
+	if (pRxBlk->pRxWI->PHYMODE >= MODE_HTMIX) {
+		rate_index =
+		    16 + ((UCHAR) pRxBlk->pRxWI->BW * 16) +
+		    ((UCHAR) pRxBlk->pRxWI->ShortGI * 32) +
+		    ((UCHAR) pRxBlk->pRxWI->MCS);
+	} else if (pRxBlk->pRxWI->PHYMODE == MODE_OFDM)
+		rate_index = (UCHAR) (pRxBlk->pRxWI->MCS) + 4;
+	else
+		rate_index = (UCHAR) (pRxBlk->pRxWI->MCS);
+	if (rate_index < 0)
+		rate_index = 0;
+	if (rate_index > 255)
+		rate_index = 255;
 
 	ph->rate.did = DIDmsg_lnxind_wlansniffrm_rate;
 	ph->rate.status = 0;
 	ph->rate.len = 4;
-    ph->rate.data = ralinkrate[rate_index];
+	ph->rate.data = ralinkrate[rate_index];
 
 	ph->frmlen.did = DIDmsg_lnxind_wlansniffrm_frmlen;
-    ph->frmlen.status = 0;
+	ph->frmlen.status = 0;
 	ph->frmlen.len = 4;
-	ph->frmlen.data	= (u_int32_t)pRxBlk->DataSize;
+	ph->frmlen.data = (u_int32_t) pRxBlk->DataSize;
 
+	pOSPkt->pkt_type = PACKET_OTHERHOST;
+	pOSPkt->protocol = eth_type_trans(pOSPkt, pOSPkt->dev);
+	pOSPkt->ip_summed = CHECKSUM_NONE;
+	netif_rx(pOSPkt);
 
-    pOSPkt->pkt_type = PACKET_OTHERHOST;
-    pOSPkt->protocol = eth_type_trans(pOSPkt, pOSPkt->dev);
-    pOSPkt->ip_summed = CHECKSUM_NONE;
-    netif_rx(pOSPkt);
-
-    return;
+	return;
 
 err_free_sk_buff:
 	RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
@@ -957,7 +900,6 @@ err_free_sk_buff:
 
 }
 
-
 /*******************************************************************************
 
 	Device IRQ related functions.
@@ -974,11 +916,12 @@ int RtmpOSIRQRequest(IN PNET_DEV pNetDev
 
 	ASSERT(pAd);
 
-	if (pAd->infType == RTMP_DEV_INF_PCI)
-	{
-		POS_COOKIE _pObj = (POS_COOKIE)(pAd->OS_Cookie);
+	if (pAd->infType == RTMP_DEV_INF_PCI) {
+		POS_COOKIE _pObj = (POS_COOKIE) (pAd->OS_Cookie);
 		RTMP_MSI_ENABLE(pAd);
-		retval = request_irq(_pObj->pci_dev->irq,  rt2860_interrupt, SA_SHIRQ, (net_dev)->name, (net_dev));
+		retval =
+		    request_irq(_pObj->pci_dev->irq, rt2860_interrupt, SA_SHIRQ,
+				(net_dev)->name, (net_dev));
 		if (retval != 0)
 			printk("RT2860: request_irq  ERROR(%d)\n", retval);
 	}
@@ -999,36 +942,34 @@ int RtmpOSIRQRelease(IN PNET_DEV pNetDev
 	ASSERT(pAd);
 
 #ifdef RTMP_PCI_SUPPORT
-	if (pAd->infType == RTMP_DEV_INF_PCI)
-	{
-		POS_COOKIE pObj = (POS_COOKIE)(pAd->OS_Cookie);
+	if (pAd->infType == RTMP_DEV_INF_PCI) {
+		POS_COOKIE pObj = (POS_COOKIE) (pAd->OS_Cookie);
 		synchronize_irq(pObj->pci_dev->irq);
 		free_irq(pObj->pci_dev->irq, (net_dev));
 		RTMP_MSI_DISABLE(pAd);
 	}
 #endif // RTMP_PCI_SUPPORT //
 
-
 	return 0;
 }
 
-
 /*******************************************************************************
 
 	File open/close related functions.
 
  *******************************************************************************/
-RTMP_OS_FD RtmpOSFileOpen(char *pPath,  int flag, int mode)
+RTMP_OS_FD RtmpOSFileOpen(char *pPath, int flag, int mode)
 {
-	struct file	*filePtr;
+	struct file *filePtr;
 
 	filePtr = filp_open(pPath, flag, 0);
-	if (IS_ERR(filePtr))
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("%s(): Error %ld opening %s\n", __func__, -PTR_ERR(filePtr), pPath));
+	if (IS_ERR(filePtr)) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("%s(): Error %ld opening %s\n", __func__,
+			  -PTR_ERR(filePtr), pPath));
 	}
 
-	return (RTMP_OS_FD)filePtr;
+	return (RTMP_OS_FD) filePtr;
 }
 
 int RtmpOSFileClose(RTMP_OS_FD osfd)
@@ -1037,31 +978,26 @@ int RtmpOSFileClose(RTMP_OS_FD osfd)
 	return 0;
 }
 
-
 void RtmpOSFileSeek(RTMP_OS_FD osfd, int offset)
 {
 	osfd->f_pos = offset;
 }
 
-
 int RtmpOSFileRead(RTMP_OS_FD osfd, char *pDataPtr, int readLen)
 {
 	// The object must have a read method
-	if (osfd->f_op && osfd->f_op->read)
-	{
-		return osfd->f_op->read(osfd,  pDataPtr, readLen, &osfd->f_pos);
-	}
-	else
-	{
+	if (osfd->f_op && osfd->f_op->read) {
+		return osfd->f_op->read(osfd, pDataPtr, readLen, &osfd->f_pos);
+	} else {
 		DBGPRINT(RT_DEBUG_ERROR, ("no file read method\n"));
 		return -1;
 	}
 }
 
-
 int RtmpOSFileWrite(RTMP_OS_FD osfd, char *pDataPtr, int writeLen)
 {
-	return osfd->f_op->write(osfd, pDataPtr, (size_t)writeLen, &osfd->f_pos);
+	return osfd->f_op->write(osfd, pDataPtr, (size_t) writeLen,
+				 &osfd->f_pos);
 }
 
 /*******************************************************************************
@@ -1069,35 +1005,32 @@ int RtmpOSFileWrite(RTMP_OS_FD osfd, cha
 	Task create/management/kill related functions.
 
  *******************************************************************************/
-NDIS_STATUS RtmpOSTaskKill(
-	IN RTMP_OS_TASK *pTask)
+NDIS_STATUS RtmpOSTaskKill(IN RTMP_OS_TASK * pTask)
 {
 	RTMP_ADAPTER *pAd;
 	int ret = NDIS_STATUS_FAILURE;
 
-	pAd = (RTMP_ADAPTER *)pTask->priv;
+	pAd = (RTMP_ADAPTER *) pTask->priv;
 
 #ifdef KTHREAD_SUPPORT
-	if (pTask->kthread_task)
-	{
+	if (pTask->kthread_task) {
 		kthread_stop(pTask->kthread_task);
 		ret = NDIS_STATUS_SUCCESS;
 	}
 #else
-	CHECK_PID_LEGALITY(pTask->taskPID)
-	{
-		printk("Terminate the task(%s) with pid(%d)!\n", pTask->taskName, GET_PID_NUMBER(pTask->taskPID));
+	CHECK_PID_LEGALITY(pTask->taskPID) {
+		printk("Terminate the task(%s) with pid(%d)!\n",
+		       pTask->taskName, GET_PID_NUMBER(pTask->taskPID));
 		mb();
 		pTask->task_killed = 1;
 		mb();
 		ret = KILL_THREAD_PID(pTask->taskPID, SIGTERM, 1);
-		if (ret)
-		{
-			printk(KERN_WARNING "kill task(%s) with pid(%d) failed(retVal=%d)!\n",
-				pTask->taskName, GET_PID_NUMBER(pTask->taskPID), ret);
-		}
-		else
-		{
+		if (ret) {
+			printk(KERN_WARNING
+			       "kill task(%s) with pid(%d) failed(retVal=%d)!\n",
+			       pTask->taskName, GET_PID_NUMBER(pTask->taskPID),
+			       ret);
+		} else {
 			wait_for_completion(&pTask->taskComplete);
 			pTask->taskPID = THREAD_PID_INIT_VALUE;
 			pTask->task_killed = 0;
@@ -1110,9 +1043,7 @@ NDIS_STATUS RtmpOSTaskKill(
 
 }
 
-
-INT RtmpOSTaskNotifyToExit(
-	IN RTMP_OS_TASK *pTask)
+INT RtmpOSTaskNotifyToExit(IN RTMP_OS_TASK * pTask)
 {
 
 #ifndef KTHREAD_SUPPORT
@@ -1122,14 +1053,12 @@ INT RtmpOSTaskNotifyToExit(
 	return 0;
 }
 
-
-void RtmpOSTaskCustomize(
-	IN RTMP_OS_TASK *pTask)
+void RtmpOSTaskCustomize(IN RTMP_OS_TASK * pTask)
 {
 
 #ifndef KTHREAD_SUPPORT
 
-	daemonize((PSTRING)&pTask->taskName[0]/*"%s",pAd->net_dev->name*/);
+	daemonize((PSTRING) & pTask->taskName[0] /*"%s",pAd->net_dev->name */ );
 
 	allow_signal(SIGTERM);
 	allow_signal(SIGKILL);
@@ -1141,11 +1070,8 @@ void RtmpOSTaskCustomize(
 #endif
 }
 
-
-NDIS_STATUS RtmpOSTaskAttach(
-	IN RTMP_OS_TASK *pTask,
-	IN int (*fn)(void *),
-	IN void *arg)
+NDIS_STATUS RtmpOSTaskAttach(IN RTMP_OS_TASK * pTask,
+			     IN int (*fn) (void *), IN void *arg)
 {
 	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
 
@@ -1157,13 +1083,11 @@ NDIS_STATUS RtmpOSTaskAttach(
 		status = NDIS_STATUS_FAILURE;
 #else
 	pid_number = kernel_thread(fn, arg, RTMP_OS_MGMT_TASK_FLAGS);
-	if (pid_number < 0)
-	{
-		DBGPRINT (RT_DEBUG_ERROR, ("Attach task(%s) failed!\n", pTask->taskName));
+	if (pid_number < 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("Attach task(%s) failed!\n", pTask->taskName));
 		status = NDIS_STATUS_FAILURE;
-	}
-	else
-	{
+	} else {
 		pTask->taskPID = GET_PID(pid_number);
 
 		// Wait for the thread to start
@@ -1174,22 +1098,21 @@ NDIS_STATUS RtmpOSTaskAttach(
 	return status;
 }
 
-
-NDIS_STATUS RtmpOSTaskInit(
-	IN RTMP_OS_TASK *pTask,
-	IN PSTRING		pTaskName,
-	IN VOID			*pPriv)
+NDIS_STATUS RtmpOSTaskInit(IN RTMP_OS_TASK * pTask,
+			   IN PSTRING pTaskName, IN VOID * pPriv)
 {
 	int len;
 
 	ASSERT(pTask);
 
 #ifndef KTHREAD_SUPPORT
-	NdisZeroMemory((PUCHAR)(pTask), sizeof(RTMP_OS_TASK));
+	NdisZeroMemory((PUCHAR) (pTask), sizeof(RTMP_OS_TASK));
 #endif
 
 	len = strlen(pTaskName);
-	len = len > (RTMP_OS_TASK_NAME_LEN -1) ? (RTMP_OS_TASK_NAME_LEN-1) : len;
+	len =
+	    len >
+	    (RTMP_OS_TASK_NAME_LEN - 1) ? (RTMP_OS_TASK_NAME_LEN - 1) : len;
 	NdisMoveMemory(&pTask->taskName[0], pTaskName, len);
 	pTask->priv = pPriv;
 
@@ -1197,58 +1120,51 @@ NDIS_STATUS RtmpOSTaskInit(
 	RTMP_SEM_EVENT_INIT_LOCKED(&(pTask->taskSema));
 	pTask->taskPID = THREAD_PID_INIT_VALUE;
 
-	init_completion (&pTask->taskComplete);
+	init_completion(&pTask->taskComplete);
 #endif
 
 	return NDIS_STATUS_SUCCESS;
 }
 
-
-void RTMP_IndicateMediaState(
-	IN	PRTMP_ADAPTER	pAd)
+void RTMP_IndicateMediaState(IN PRTMP_ADAPTER pAd)
 {
-	if (pAd->CommonCfg.bWirelessEvent)
-	{
-		if (pAd->IndicateMediaState == NdisMediaStateConnected)
-		{
-			RTMPSendWirelessEvent(pAd, IW_STA_LINKUP_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
-		}
-		else
-		{
-			RTMPSendWirelessEvent(pAd, IW_STA_LINKDOWN_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+	if (pAd->CommonCfg.bWirelessEvent) {
+		if (pAd->IndicateMediaState == NdisMediaStateConnected) {
+			RTMPSendWirelessEvent(pAd, IW_STA_LINKUP_EVENT_FLAG,
+					      pAd->MacTab.Content[BSSID_WCID].
+					      Addr, BSS0, 0);
+		} else {
+			RTMPSendWirelessEvent(pAd, IW_STA_LINKDOWN_EVENT_FLAG,
+					      pAd->MacTab.Content[BSSID_WCID].
+					      Addr, BSS0, 0);
 		}
 	}
 }
 
-int RtmpOSWrielessEventSend(
-	IN RTMP_ADAPTER *pAd,
-	IN UINT32		eventType,
-	IN INT			flags,
-	IN PUCHAR		pSrcMac,
-	IN PUCHAR		pData,
-	IN UINT32		dataLen)
+int RtmpOSWrielessEventSend(IN RTMP_ADAPTER * pAd,
+			    IN UINT32 eventType,
+			    IN INT flags,
+			    IN PUCHAR pSrcMac,
+			    IN PUCHAR pData, IN UINT32 dataLen)
 {
-	union iwreq_data    wrqu;
+	union iwreq_data wrqu;
 
-       memset(&wrqu, 0, sizeof(wrqu));
+	memset(&wrqu, 0, sizeof(wrqu));
 
-	if (flags>-1)
-	       wrqu.data.flags = flags;
+	if (flags > -1)
+		wrqu.data.flags = flags;
 
 	if (pSrcMac)
 		memcpy(wrqu.ap_addr.sa_data, pSrcMac, MAC_ADDR_LEN);
 
-	if ((pData!= NULL) && (dataLen > 0))
+	if ((pData != NULL) && (dataLen > 0))
 		wrqu.data.length = dataLen;
 
-       wireless_send_event(pAd->net_dev, eventType, &wrqu, (char *)pData);
+	wireless_send_event(pAd->net_dev, eventType, &wrqu, (char *)pData);
 	return 0;
 }
 
-
-int RtmpOSNetDevAddrSet(
-	IN PNET_DEV pNetDev,
-	IN PUCHAR	pMacAddr)
+int RtmpOSNetDevAddrSet(IN PNET_DEV pNetDev, IN PUCHAR pMacAddr)
 {
 	struct net_device *net_dev;
 	RTMP_ADAPTER *pAd;
@@ -1259,7 +1175,8 @@ int RtmpOSNetDevAddrSet(
 	// work-around for the SuSE due to it has it's own interface name management system.
 	{
 		NdisZeroMemory(pAd->StaCfg.dev_name, 16);
-		NdisMoveMemory(pAd->StaCfg.dev_name, net_dev->name, strlen(net_dev->name));
+		NdisMoveMemory(pAd->StaCfg.dev_name, net_dev->name,
+			       strlen(net_dev->name));
 	}
 
 	NdisMoveMemory(net_dev->dev_addr, pMacAddr, 6);
@@ -1267,29 +1184,23 @@ int RtmpOSNetDevAddrSet(
 	return 0;
 }
 
-
-
 /*
   *	Assign the network dev name for created Ralink WiFi interface.
   */
-static int RtmpOSNetDevRequestName(
-	IN RTMP_ADAPTER *pAd,
-	IN PNET_DEV dev,
-	IN PSTRING pPrefixStr,
-	IN INT	devIdx)
-{
-	PNET_DEV		existNetDev;
-	STRING		suffixName[IFNAMSIZ];
-	STRING		desiredName[IFNAMSIZ];
-	int	ifNameIdx, prefixLen, slotNameLen;
+static int RtmpOSNetDevRequestName(IN RTMP_ADAPTER * pAd,
+				   IN PNET_DEV dev,
+				   IN PSTRING pPrefixStr, IN INT devIdx)
+{
+	PNET_DEV existNetDev;
+	STRING suffixName[IFNAMSIZ];
+	STRING desiredName[IFNAMSIZ];
+	int ifNameIdx, prefixLen, slotNameLen;
 	int Status;
 
-
 	prefixLen = strlen(pPrefixStr);
 	ASSERT((prefixLen < IFNAMSIZ));
 
-	for (ifNameIdx = devIdx; ifNameIdx < 32; ifNameIdx++)
-	{
+	for (ifNameIdx = devIdx; ifNameIdx < 32; ifNameIdx++) {
 		memset(suffixName, 0, IFNAMSIZ);
 		memset(desiredName, 0, IFNAMSIZ);
 		strncpy(&desiredName[0], pPrefixStr, prefixLen);
@@ -1307,29 +1218,24 @@ static int RtmpOSNetDevRequestName(
 			RtmpOSNetDeviceRefPut(existNetDev);
 	}
 
-	if(ifNameIdx < 32)
-	{
+	if (ifNameIdx < 32) {
 		strcpy(&dev->name[0], &desiredName[0]);
 		Status = NDIS_STATUS_SUCCESS;
-	}
-	else
-	{
+	} else {
 		DBGPRINT(RT_DEBUG_ERROR,
-					("Cannot request DevName with preifx(%s) and in range(0~32) as suffix from OS!\n", pPrefixStr));
+			 ("Cannot request DevName with preifx(%s) and in range(0~32) as suffix from OS!\n",
+			  pPrefixStr));
 		Status = NDIS_STATUS_FAILURE;
 	}
 
 	return Status;
 }
 
-
-void RtmpOSNetDevClose(
-	IN PNET_DEV pNetDev)
+void RtmpOSNetDevClose(IN PNET_DEV pNetDev)
 {
 	dev_close(pNetDev);
 }
 
-
 void RtmpOSNetDevFree(PNET_DEV pNetDev)
 {
 	ASSERT(pNetDev);
@@ -1337,15 +1243,14 @@ void RtmpOSNetDevFree(PNET_DEV pNetDev)
 	free_netdev(pNetDev);
 }
 
-
-INT RtmpOSNetDevAlloc(
-	IN PNET_DEV *new_dev_p,
-	IN UINT32	privDataSize)
+INT RtmpOSNetDevAlloc(IN PNET_DEV * new_dev_p, IN UINT32 privDataSize)
 {
 	// assign it as null first.
 	*new_dev_p = NULL;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("Allocate a net device with private data size=%d!\n", privDataSize));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Allocate a net device with private data size=%d!\n",
+		  privDataSize));
 	*new_dev_p = alloc_etherdev(privDataSize);
 	if (*new_dev_p)
 		return NDIS_STATUS_SUCCESS;
@@ -1353,32 +1258,27 @@ INT RtmpOSNetDevAlloc(
 		return NDIS_STATUS_FAILURE;
 }
 
-
 PNET_DEV RtmpOSNetDevGetByName(PNET_DEV pNetDev, PSTRING pDevName)
 {
-	PNET_DEV	pTargetNetDev = NULL;
+	PNET_DEV pTargetNetDev = NULL;
 
 	pTargetNetDev = dev_get_by_name(dev_net(pNetDev), pDevName);
 
 	return pTargetNetDev;
 }
 
-
 void RtmpOSNetDeviceRefPut(PNET_DEV pNetDev)
 {
 	/*
-		every time dev_get_by_name is called, and it has returned a valid struct
-		net_device*, dev_put should be called afterwards, because otherwise the
-		machine hangs when the device is unregistered (since dev->refcnt > 1).
-	*/
-	if(pNetDev)
+	   every time dev_get_by_name is called, and it has returned a valid struct
+	   net_device*, dev_put should be called afterwards, because otherwise the
+	   machine hangs when the device is unregistered (since dev->refcnt > 1).
+	 */
+	if (pNetDev)
 		dev_put(pNetDev);
 }
 
-
-INT RtmpOSNetDevDestory(
-	IN RTMP_ADAPTER *pAd,
-	IN PNET_DEV		pNetDev)
+INT RtmpOSNetDevDestory(IN RTMP_ADAPTER * pAd, IN PNET_DEV pNetDev)
 {
 
 	// TODO: Need to fix this
@@ -1386,23 +1286,19 @@ INT RtmpOSNetDevDestory(
 	return 0;
 }
 
-
 void RtmpOSNetDevDetach(PNET_DEV pNetDev)
 {
 	unregister_netdev(pNetDev);
 }
 
-
-int RtmpOSNetDevAttach(
-	IN PNET_DEV pNetDev,
-	IN RTMP_OS_NETDEV_OP_HOOK *pDevOpHook)
+int RtmpOSNetDevAttach(IN PNET_DEV pNetDev,
+		       IN RTMP_OS_NETDEV_OP_HOOK * pDevOpHook)
 {
 	int ret, rtnl_locked = FALSE;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("RtmpOSNetDevAttach()--->\n"));
 	// If we need hook some callback function to the net device structrue, now do it.
-	if (pDevOpHook)
-	{
+	if (pDevOpHook) {
 		PRTMP_ADAPTER pAd = NULL;
 
 		GET_PAD_FROM_NET_DEV(pAd, pNetDev);
@@ -1412,15 +1308,13 @@ int RtmpOSNetDevAttach(
 		/* OS specific flags, here we used to indicate if we are virtual interface */
 		pNetDev->priv_flags = pDevOpHook->priv_flags;
 
-
-		if (pAd->OpMode == OPMODE_STA)
-		{
+		if (pAd->OpMode == OPMODE_STA) {
 			pNetDev->wireless_handlers = &rt28xx_iw_handler_def;
 		}
 
-
 		// copy the net device mac address to the net_device structure.
-		NdisMoveMemory(pNetDev->dev_addr, &pDevOpHook->devAddr[0], MAC_ADDR_LEN);
+		NdisMoveMemory(pNetDev->dev_addr, &pDevOpHook->devAddr[0],
+			       MAC_ADDR_LEN);
 
 		rtnl_locked = pDevOpHook->needProtcted;
 	}
@@ -1437,41 +1331,38 @@ int RtmpOSNetDevAttach(
 		return NDIS_STATUS_FAILURE;
 }
 
-
-PNET_DEV RtmpOSNetDevCreate(
-	IN RTMP_ADAPTER *pAd,
-	IN INT			devType,
-	IN INT			devNum,
-	IN INT			privMemSize,
-	IN PSTRING		pNamePrefix)
+PNET_DEV RtmpOSNetDevCreate(IN RTMP_ADAPTER * pAd,
+			    IN INT devType,
+			    IN INT devNum,
+			    IN INT privMemSize, IN PSTRING pNamePrefix)
 {
 	struct net_device *pNetDev = NULL;
 	int status;
 
-
 	/* allocate a new network device */
-	status = RtmpOSNetDevAlloc(&pNetDev, 0 /*privMemSize*/);
-	if (status != NDIS_STATUS_SUCCESS)
-	{
+	status = RtmpOSNetDevAlloc(&pNetDev, 0 /*privMemSize */ );
+	if (status != NDIS_STATUS_SUCCESS) {
 		/* allocation fail, exit */
-		DBGPRINT(RT_DEBUG_ERROR, ("Allocate network device fail (%s)...\n", pNamePrefix));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("Allocate network device fail (%s)...\n",
+			  pNamePrefix));
 		return NULL;
 	}
 
-
 	/* find a available interface name, max 32 interfaces */
 	status = RtmpOSNetDevRequestName(pAd, pNetDev, pNamePrefix, devNum);
-	if (status != NDIS_STATUS_SUCCESS)
-	{
+	if (status != NDIS_STATUS_SUCCESS) {
 		/* error! no any available ra name can be used! */
-		DBGPRINT(RT_DEBUG_ERROR, ("Assign interface name (%s with suffix 0~32) failed...\n", pNamePrefix));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("Assign interface name (%s with suffix 0~32) failed...\n",
+			  pNamePrefix));
 		RtmpOSNetDevFree(pNetDev);
 
 		return NULL;
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("The name of the new %s interface is %s...\n", pNamePrefix, pNetDev->name));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("The name of the new %s interface is %s...\n",
+			  pNamePrefix, pNetDev->name));
 	}
 
 	return pNetDev;
--- a/drivers/staging/rt2860/rt_main_dev.c
+++ b/drivers/staging/rt2860/rt_main_dev.c
@@ -37,17 +37,14 @@
 
 #include "rt_config.h"
 
-
-
 /*---------------------------------------------------------------------*/
 /* Private Variables Used                                              */
 /*---------------------------------------------------------------------*/
 
-PSTRING mac = "";		   // default 00:00:00:00:00:00
-PSTRING hostname = "";		   // default CMPC
-module_param (mac, charp, 0);
-MODULE_PARM_DESC (mac, "rt28xx: wireless mac addr");
-
+PSTRING mac = "";		// default 00:00:00:00:00:00
+PSTRING hostname = "";		// default CMPC
+module_param(mac, charp, 0);
+MODULE_PARM_DESC(mac, "rt28xx: wireless mac addr");
 
 /*---------------------------------------------------------------------*/
 /* Prototypes of Functions Used                                        */
@@ -58,11 +55,11 @@ int rt28xx_close(IN struct net_device *n
 int rt28xx_open(struct net_device *net_dev);
 
 // private function prototype
-static INT rt28xx_send_packets(IN struct sk_buff *skb_p, IN struct net_device *net_dev);
-
+static INT rt28xx_send_packets(IN struct sk_buff *skb_p,
+			       IN struct net_device *net_dev);
 
-static struct net_device_stats *RT28xx_get_ether_stats(
-    IN  struct net_device *net_dev);
+static struct net_device_stats *RT28xx_get_ether_stats(IN struct net_device
+						       *net_dev);
 
 /*
 ========================================================================
@@ -86,57 +83,66 @@ Note:
 */
 int MainVirtualIF_close(IN struct net_device *net_dev)
 {
-    RTMP_ADAPTER *pAd = NULL;
+	RTMP_ADAPTER *pAd = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
 	// Sanity check for pAd
 	if (pAd == NULL)
-		return 0; // close ok
+		return 0;	// close ok
 
 	netif_carrier_off(pAd->net_dev);
 	netif_stop_queue(pAd->net_dev);
 
 	{
-		BOOLEAN			Cancelled;
+		BOOLEAN Cancelled;
 
 		if (INFRA_ON(pAd) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-		{
-			MLME_DISASSOC_REQ_STRUCT	DisReq;
-			MLME_QUEUE_ELEM *MsgElem = (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM), MEM_ALLOC_FLAG);
-
-			if (MsgElem)
-			{
-			COPY_MAC_ADDR(DisReq.Addr, pAd->CommonCfg.Bssid);
-			DisReq.Reason =  REASON_DEAUTH_STA_LEAVING;
-
-			MsgElem->Machine = ASSOC_STATE_MACHINE;
-			MsgElem->MsgType = MT2_MLME_DISASSOC_REQ;
-			MsgElem->MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
-			NdisMoveMemory(MsgElem->Msg, &DisReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
-
-			// Prevent to connect AP again in STAMlmePeriodicExec
-			pAd->MlmeAux.AutoReconnectSsidLen= 32;
-			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
-
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
-			MlmeDisassocReqAction(pAd, MsgElem);
-			kfree(MsgElem);
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
+			MLME_DISASSOC_REQ_STRUCT DisReq;
+			MLME_QUEUE_ELEM *MsgElem =
+			    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
+							MEM_ALLOC_FLAG);
+
+			if (MsgElem) {
+				COPY_MAC_ADDR(DisReq.Addr,
+					      pAd->CommonCfg.Bssid);
+				DisReq.Reason = REASON_DEAUTH_STA_LEAVING;
+
+				MsgElem->Machine = ASSOC_STATE_MACHINE;
+				MsgElem->MsgType = MT2_MLME_DISASSOC_REQ;
+				MsgElem->MsgLen =
+				    sizeof(MLME_DISASSOC_REQ_STRUCT);
+				NdisMoveMemory(MsgElem->Msg, &DisReq,
+					       sizeof
+					       (MLME_DISASSOC_REQ_STRUCT));
+
+				// Prevent to connect AP again in STAMlmePeriodicExec
+				pAd->MlmeAux.AutoReconnectSsidLen = 32;
+				NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid,
+					       pAd->MlmeAux.
+					       AutoReconnectSsidLen);
+
+				pAd->Mlme.CntlMachine.CurrState =
+				    CNTL_WAIT_OID_DISASSOC;
+				MlmeDisassocReqAction(pAd, MsgElem);
+				kfree(MsgElem);
 			}
 
 			RTMPusecDelay(1000);
 		}
 
-		RTMPCancelTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer, &Cancelled);
-		RTMPCancelTimer(&pAd->StaCfg.WpaDisassocAndBlockAssocTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer,
+				&Cancelled);
+		RTMPCancelTimer(&pAd->StaCfg.WpaDisassocAndBlockAssocTimer,
+				&Cancelled);
 	}
 
 	VIRTUAL_IF_DOWN(pAd);
 
 	RT_MOD_DEC_USE_COUNT();
 
-	return 0; // close ok
+	return 0;		// close ok
 }
 
 /*
@@ -161,13 +167,13 @@ Note:
 */
 int MainVirtualIF_open(IN struct net_device *net_dev)
 {
-    RTMP_ADAPTER *pAd = NULL;
+	RTMP_ADAPTER *pAd = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
 	// Sanity check for pAd
 	if (pAd == NULL)
-		return 0; // close ok
+		return 0;	// close ok
 
 	if (VIRTUAL_IF_UP(pAd) != 0)
 		return -1;
@@ -204,10 +210,10 @@ Note:
 */
 int rt28xx_close(IN PNET_DEV dev)
 {
-	struct net_device * net_dev = (struct net_device *)dev;
-    RTMP_ADAPTER	*pAd = NULL;
-	BOOLEAN			Cancelled;
-	UINT32			i = 0;
+	struct net_device *net_dev = (struct net_device *)dev;
+	RTMP_ADAPTER *pAd = NULL;
+	BOOLEAN Cancelled;
+	UINT32 i = 0;
 
 #ifdef RTMP_MAC_USB
 	DECLARE_WAIT_QUEUE_HEAD(unlink_wakeup);
@@ -216,12 +222,12 @@ int rt28xx_close(IN PNET_DEV dev)
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-    DBGPRINT(RT_DEBUG_TRACE, ("===> rt28xx_close\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("===> rt28xx_close\n"));
 
 	Cancelled = FALSE;
 	// Sanity check for pAd
 	if (pAd == NULL)
-		return 0; // close ok
+		return 0;	// close ok
 
 	{
 #ifdef RTMP_MAC_PCI
@@ -230,13 +236,11 @@ int rt28xx_close(IN PNET_DEV dev)
 
 		// If dirver doesn't wake up firmware here,
 		// NICLoadFirmware will hang forever when interface is up again.
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-        {
-		    AsicForceWakeup(pAd, TRUE);
-        }
-
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
+			AsicForceWakeup(pAd, TRUE);
+		}
 #ifdef RTMP_MAC_USB
-	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
+		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
 #endif // RTMP_MAC_USB //
 
 		MlmeRadioOff(pAd);
@@ -247,30 +251,28 @@ int rt28xx_close(IN PNET_DEV dev)
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
 
-	for (i = 0 ; i < NUM_OF_TX_RING; i++)
-	{
-		while (pAd->DeQueueRunning[i] == TRUE)
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("Waiting for TxQueue[%d] done..........\n", i));
+	for (i = 0; i < NUM_OF_TX_RING; i++) {
+		while (pAd->DeQueueRunning[i] == TRUE) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Waiting for TxQueue[%d] done..........\n",
+				  i));
 			RTMPusecDelay(1000);
 		}
 	}
 
 #ifdef RTMP_MAC_USB
 	// ensure there are no more active urbs.
-	add_wait_queue (&unlink_wakeup, &wait);
+	add_wait_queue(&unlink_wakeup, &wait);
 	pAd->wait = &unlink_wakeup;
 
 	// maybe wait for deletions to finish.
 	i = 0;
 	//while((i < 25) && atomic_read(&pAd->PendingRx) > 0)
-	while(i < 25)
-	{
+	while (i < 25) {
 		unsigned long IrqFlags;
 
 		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-		if (pAd->PendingRx == 0)
-		{
+		if (pAd->PendingRx == 0) {
 			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 			break;
 		}
@@ -280,7 +282,7 @@ int rt28xx_close(IN PNET_DEV dev)
 		i++;
 	}
 	pAd->wait = NULL;
-	remove_wait_queue (&unlink_wakeup, &wait);
+	remove_wait_queue(&unlink_wakeup, &wait);
 #endif // RTMP_MAC_USB //
 
 	// Stop Mlme state machine
@@ -293,42 +295,37 @@ int rt28xx_close(IN PNET_DEV dev)
 		MacTableReset(pAd);
 	}
 
-
 	MeasureReqTabExit(pAd);
 	TpcReqTabExit(pAd);
 
-
 	// Close kernel threads
 	RtmpMgmtTaskExit(pAd);
 
 #ifdef RTMP_MAC_PCI
 	{
-			BOOLEAN brc;
-			//	ULONG			Value;
-
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE))
-	{
-				RTMP_ASIC_INTERRUPT_DISABLE(pAd);
-	}
-
-			// Receive packets to clear DMA index after disable interrupt.
-			//RTMPHandleRxDoneInterrupt(pAd);
-			// put to radio off to save power when driver unload.  After radiooff, can't write /read register.  So need to finish all
-			// register access before Radio off.
+		BOOLEAN brc;
+		//      ULONG                   Value;
 
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE)) {
+			RTMP_ASIC_INTERRUPT_DISABLE(pAd);
+		}
+		// Receive packets to clear DMA index after disable interrupt.
+		//RTMPHandleRxDoneInterrupt(pAd);
+		// put to radio off to save power when driver unload.  After radiooff, can't write /read register.  So need to finish all
+		// register access before Radio off.
 
-			brc=RT28xxPciAsicRadioOff(pAd, RTMP_HALT, 0);
+		brc = RT28xxPciAsicRadioOff(pAd, RTMP_HALT, 0);
 
 //In  solution 3 of 3090F, the bPCIclkOff will be set to TRUE after calling RT28xxPciAsicRadioOff
-			pAd->bPCIclkOff = FALSE;
+		pAd->bPCIclkOff = FALSE;
 
-			if (brc==FALSE)
-	{
-				DBGPRINT(RT_DEBUG_ERROR,("%s call RT28xxPciAsicRadioOff fail !!\n", __func__));
-	}
+		if (brc == FALSE) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s call RT28xxPciAsicRadioOff fail !!\n",
+				  __func__));
+		}
 	}
 
-
 /*
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE))
 	{
@@ -341,15 +338,13 @@ int rt28xx_close(IN PNET_DEV dev)
 #endif // RTMP_MAC_PCI //
 
 	// Free IRQ
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-		{
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 #ifdef RTMP_MAC_PCI
 		// Deregister interrupt function
 		RtmpOSIRQRelease(net_dev);
 #endif // RTMP_MAC_PCI //
-			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
-		}
-
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
+	}
 	// Free Ring or USB buffers
 	RTMPFreeTxRxRingMemory(pAd);
 
@@ -358,7 +353,6 @@ int rt28xx_close(IN PNET_DEV dev)
 	// Free BA reorder resource
 	ba_reordering_resource_release(pAd);
 
-
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_START_UP);
 
 /*+++Modify by woody to solve the bulk fail+++*/
@@ -366,9 +360,8 @@ int rt28xx_close(IN PNET_DEV dev)
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<=== rt28xx_close\n"));
-	return 0; // close ok
-} /* End of rt28xx_close */
-
+	return 0;		// close ok
+}				/* End of rt28xx_close */
 
 /*
 ========================================================================
@@ -387,7 +380,7 @@ Note:
 */
 int rt28xx_open(IN PNET_DEV dev)
 {
-	struct net_device * net_dev = (struct net_device *)dev;
+	struct net_device *net_dev = (struct net_device *)dev;
 	PRTMP_ADAPTER pAd = NULL;
 	int retval = 0;
 	//POS_COOKIE pObj;
@@ -395,24 +388,21 @@ int rt28xx_open(IN PNET_DEV dev)
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
 	// Sanity check for pAd
-	if (pAd == NULL)
-	{
+	if (pAd == NULL) {
 		/* if 1st open fail, pAd will be free;
 		   So the net_dev->ml_priv will be NULL in 2rd open */
 		return -1;
 	}
 
-	if (net_dev->priv_flags == INT_MAIN)
-	{
+	if (net_dev->priv_flags == INT_MAIN) {
 		if (pAd->OpMode == OPMODE_STA)
-			net_dev->wireless_handlers = (struct iw_handler_def *) &rt28xx_iw_handler_def;
+			net_dev->wireless_handlers =
+			    (struct iw_handler_def *)&rt28xx_iw_handler_def;
 	}
-
 	// Request interrupt service routine for PCI device
 	// register the interrupt routine with the os
 	RtmpOSIRQRequest(net_dev);
 
-
 	// Init IRQ parameters stored in pAd
 	RTMP_IRQ_INIT(pAd);
 
@@ -420,7 +410,6 @@ int rt28xx_open(IN PNET_DEV dev)
 	if (rt28xx_init(pAd, mac, hostname) == FALSE)
 		goto err;
 
-
 	// Enable Interrupt
 	RTMP_IRQ_ENABLE(pAd);
 
@@ -429,25 +418,25 @@ int rt28xx_open(IN PNET_DEV dev)
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_START_UP);
 
 	{
-	UINT32 reg = 0;
-	RTMP_IO_READ32(pAd, 0x1300, &reg);  // clear garbage interrupts
-	printk("0x1300 = %08x\n", reg);
+		UINT32 reg = 0;
+		RTMP_IO_READ32(pAd, 0x1300, &reg);	// clear garbage interrupts
+		printk("0x1300 = %08x\n", reg);
 	}
 
 	{
-//	u32 reg;
-//	UINT8  byte;
-//	u16 tmp;
-
-//	RTMP_IO_READ32(pAd, XIFS_TIME_CFG, &reg);
-
-//	tmp = 0x0805;
-//	reg  = (reg & 0xffff0000) | tmp;
-//	RTMP_IO_WRITE32(pAd, XIFS_TIME_CFG, reg);
+//      u32 reg;
+//      UINT8  byte;
+//      u16 tmp;
+
+//      RTMP_IO_READ32(pAd, XIFS_TIME_CFG, &reg);
+
+//      tmp = 0x0805;
+//      reg  = (reg & 0xffff0000) | tmp;
+//      RTMP_IO_WRITE32(pAd, XIFS_TIME_CFG, reg);
 
 	}
 #ifdef RTMP_MAC_PCI
-        RTMPInitPCIeLinkCtrlValue(pAd);
+	RTMPInitPCIeLinkCtrlValue(pAd);
 #endif // RTMP_MAC_PCI //
 
 	return (retval);
@@ -457,39 +446,41 @@ err:
 	RtmpOSIRQRelease(net_dev);
 //---Add by shiang, move from rt28xx_init() to here.
 	return (-1);
-} /* End of rt28xx_open */
+}				/* End of rt28xx_open */
 
 static const struct net_device_ops rt2860_netdev_ops = {
-	.ndo_open		= MainVirtualIF_open,
-	.ndo_stop		= MainVirtualIF_close,
-	.ndo_do_ioctl		= rt28xx_sta_ioctl,
-	.ndo_get_stats		= RT28xx_get_ether_stats,
-	.ndo_validate_addr	= NULL,
-	.ndo_set_mac_address	= eth_mac_addr,
-	.ndo_change_mtu		= eth_change_mtu,
-	.ndo_start_xmit		= rt28xx_send_packets,
+	.ndo_open = MainVirtualIF_open,
+	.ndo_stop = MainVirtualIF_close,
+	.ndo_do_ioctl = rt28xx_sta_ioctl,
+	.ndo_get_stats = RT28xx_get_ether_stats,
+	.ndo_validate_addr = NULL,
+	.ndo_set_mac_address = eth_mac_addr,
+	.ndo_change_mtu = eth_change_mtu,
+	.ndo_start_xmit = rt28xx_send_packets,
 };
 
-PNET_DEV RtmpPhyNetDevInit(
-	IN RTMP_ADAPTER *pAd,
-	IN RTMP_OS_NETDEV_OP_HOOK *pNetDevHook)
-{
-	struct net_device	*net_dev = NULL;
-//	NDIS_STATUS		Status;
-
-	net_dev = RtmpOSNetDevCreate(pAd, INT_MAIN, 0, sizeof(PRTMP_ADAPTER), INF_MAIN_DEV_NAME);
-    if (net_dev == NULL)
-    {
-		printk("RtmpPhyNetDevInit(): creation failed for main physical net device!\n");
+PNET_DEV RtmpPhyNetDevInit(IN RTMP_ADAPTER * pAd,
+			   IN RTMP_OS_NETDEV_OP_HOOK * pNetDevHook)
+{
+	struct net_device *net_dev = NULL;
+//      NDIS_STATUS             Status;
+
+	net_dev =
+	    RtmpOSNetDevCreate(pAd, INT_MAIN, 0, sizeof(PRTMP_ADAPTER),
+			       INF_MAIN_DEV_NAME);
+	if (net_dev == NULL) {
+		printk
+		    ("RtmpPhyNetDevInit(): creation failed for main physical net device!\n");
 		return NULL;
-    }
+	}
 
-	NdisZeroMemory((unsigned char *)pNetDevHook, sizeof(RTMP_OS_NETDEV_OP_HOOK));
+	NdisZeroMemory((unsigned char *)pNetDevHook,
+		       sizeof(RTMP_OS_NETDEV_OP_HOOK));
 	pNetDevHook->netdev_ops = &rt2860_netdev_ops;
 	pNetDevHook->priv_flags = INT_MAIN;
 	pNetDevHook->needProtcted = FALSE;
 
-	net_dev->ml_priv = (PVOID)pAd;
+	net_dev->ml_priv = (PVOID) pAd;
 	pAd->net_dev = net_dev;
 
 	netif_stop_queue(net_dev);
@@ -498,7 +489,6 @@ PNET_DEV RtmpPhyNetDevInit(
 
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -529,16 +519,14 @@ int rt28xx_packet_xmit(struct sk_buff *s
 
 	{
 		// Drop send request since we are in monitor mode
-		if (MONITOR_ON(pAd))
-		{
+		if (MONITOR_ON(pAd)) {
 			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 			goto done;
 		}
 	}
 
-        // EapolStart size is 18
-	if (skb->len < 14)
-	{
+	// EapolStart size is 18
+	if (skb->len < 14) {
 		//printk("bad packet size: %d\n", pkt->len);
 		hex_dump("bad packet", skb->data, skb->len);
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
@@ -546,7 +534,7 @@ int rt28xx_packet_xmit(struct sk_buff *s
 	}
 
 	RTMP_SET_PACKET_5VT(pPacket, 0);
-	STASendPackets((NDIS_HANDLE)pAd, (PPNDIS_PACKET) &pPacket, 1);
+	STASendPackets((NDIS_HANDLE) pAd, (PPNDIS_PACKET) & pPacket, 1);
 
 	status = NETDEV_TX_OK;
 done:
@@ -554,7 +542,6 @@ done:
 	return status;
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -571,30 +558,27 @@ Return Value:
 Note:
 ========================================================================
 */
-static int rt28xx_send_packets(
-	IN struct sk_buff 		*skb_p,
-	IN struct net_device 	*net_dev)
+static int rt28xx_send_packets(IN struct sk_buff *skb_p,
+			       IN struct net_device *net_dev)
 {
 	RTMP_ADAPTER *pAd = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-	if (!(net_dev->flags & IFF_UP))
-	{
-		RELEASE_NDIS_PACKET(pAd, (PNDIS_PACKET)skb_p, NDIS_STATUS_FAILURE);
+	if (!(net_dev->flags & IFF_UP)) {
+		RELEASE_NDIS_PACKET(pAd, (PNDIS_PACKET) skb_p,
+				    NDIS_STATUS_FAILURE);
 		return NETDEV_TX_OK;
 	}
 
-	NdisZeroMemory((PUCHAR)&skb_p->cb[CB_OFF], 15);
+	NdisZeroMemory((PUCHAR) & skb_p->cb[CB_OFF], 15);
 	RTMP_SET_PACKET_NET_DEVICE_MBSSID(skb_p, MAIN_MBSSID);
 
 	return rt28xx_packet_xmit(skb_p);
 }
 
-
 // This function will be called when query /proc
-struct iw_statistics *rt28xx_get_wireless_stats(
-    IN struct net_device *net_dev)
+struct iw_statistics *rt28xx_get_wireless_stats(IN struct net_device *net_dev)
 {
 	PRTMP_ADAPTER pAd = NULL;
 
@@ -602,42 +586,41 @@ struct iw_statistics *rt28xx_get_wireles
 
 	DBGPRINT(RT_DEBUG_TRACE, ("rt28xx_get_wireless_stats --->\n"));
 
-	pAd->iw_stats.status = 0; // Status - device dependent for now
+	pAd->iw_stats.status = 0;	// Status - device dependent for now
 
 	// link quality
 	if (pAd->OpMode == OPMODE_STA)
-	pAd->iw_stats.qual.qual = ((pAd->Mlme.ChannelQuality * 12)/10 + 10);
+		pAd->iw_stats.qual.qual =
+		    ((pAd->Mlme.ChannelQuality * 12) / 10 + 10);
 
-	if(pAd->iw_stats.qual.qual > 100)
+	if (pAd->iw_stats.qual.qual > 100)
 		pAd->iw_stats.qual.qual = 100;
 
-	if (pAd->OpMode == OPMODE_STA)
-	{
+	if (pAd->OpMode == OPMODE_STA) {
 		pAd->iw_stats.qual.level =
-			RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0,
-							pAd->StaCfg.RssiSample.LastRssi1,
-							pAd->StaCfg.RssiSample.LastRssi2);
+		    RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0,
+				pAd->StaCfg.RssiSample.LastRssi1,
+				pAd->StaCfg.RssiSample.LastRssi2);
 	}
 
-	pAd->iw_stats.qual.noise = pAd->BbpWriteLatch[66]; // noise level (dBm)
+	pAd->iw_stats.qual.noise = pAd->BbpWriteLatch[66];	// noise level (dBm)
 
 	pAd->iw_stats.qual.noise += 256 - 143;
-	pAd->iw_stats.qual.updated = 1;     // Flags to know if updated
+	pAd->iw_stats.qual.updated = 1;	// Flags to know if updated
 #ifdef IW_QUAL_DBM
 	pAd->iw_stats.qual.updated |= IW_QUAL_DBM;	// Level + Noise are dBm
 #endif // IW_QUAL_DBM //
 
-	pAd->iw_stats.discard.nwid = 0;     // Rx : Wrong nwid/essid
-	pAd->iw_stats.miss.beacon = 0;      // Missed beacons/superframe
+	pAd->iw_stats.discard.nwid = 0;	// Rx : Wrong nwid/essid
+	pAd->iw_stats.miss.beacon = 0;	// Missed beacons/superframe
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<--- rt28xx_get_wireless_stats\n"));
 	return &pAd->iw_stats;
 }
 
-
 void tbtt_tasklet(unsigned long data)
 {
-//#define MAX_TX_IN_TBTT		(16)
+//#define MAX_TX_IN_TBTT                (16)
 
 }
 
@@ -657,19 +640,20 @@ void tbtt_tasklet(unsigned long data)
 
     ========================================================================
 */
-static struct net_device_stats *RT28xx_get_ether_stats(
-    IN  struct net_device *net_dev)
+static struct net_device_stats *RT28xx_get_ether_stats(IN struct net_device
+						       *net_dev)
 {
-    RTMP_ADAPTER *pAd = NULL;
+	RTMP_ADAPTER *pAd = NULL;
 
 	if (net_dev)
 		GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
-	if (pAd)
-	{
+	if (pAd) {
 
-		pAd->stats.rx_packets = pAd->WlanCounters.ReceivedFragmentCount.QuadPart;
-		pAd->stats.tx_packets = pAd->WlanCounters.TransmittedFragmentCount.QuadPart;
+		pAd->stats.rx_packets =
+		    pAd->WlanCounters.ReceivedFragmentCount.QuadPart;
+		pAd->stats.tx_packets =
+		    pAd->WlanCounters.TransmittedFragmentCount.QuadPart;
 
 		pAd->stats.rx_bytes = pAd->RalinkCounters.ReceivedByteCount;
 		pAd->stats.tx_bytes = pAd->RalinkCounters.TransmittedByteCount;
@@ -680,45 +664,40 @@ static struct net_device_stats *RT28xx_g
 		pAd->stats.rx_dropped = 0;
 		pAd->stats.tx_dropped = 0;
 
-	    pAd->stats.multicast = pAd->WlanCounters.MulticastReceivedFrameCount.QuadPart;   // multicast packets received
-	    pAd->stats.collisions = pAd->Counters8023.OneCollision + pAd->Counters8023.MoreCollisions;  // Collision packets
+		pAd->stats.multicast = pAd->WlanCounters.MulticastReceivedFrameCount.QuadPart;	// multicast packets received
+		pAd->stats.collisions = pAd->Counters8023.OneCollision + pAd->Counters8023.MoreCollisions;	// Collision packets
 
-	    pAd->stats.rx_length_errors = 0;
-	    pAd->stats.rx_over_errors = pAd->Counters8023.RxNoBuffer;                   // receiver ring buff overflow
-	    pAd->stats.rx_crc_errors = 0;//pAd->WlanCounters.FCSErrorCount;     // recved pkt with crc error
-	    pAd->stats.rx_frame_errors = pAd->Counters8023.RcvAlignmentErrors;          // recv'd frame alignment error
-	    pAd->stats.rx_fifo_errors = pAd->Counters8023.RxNoBuffer;                   // recv'r fifo overrun
-	    pAd->stats.rx_missed_errors = 0;                                            // receiver missed packet
-
-	    // detailed tx_errors
-	    pAd->stats.tx_aborted_errors = 0;
-	    pAd->stats.tx_carrier_errors = 0;
-	    pAd->stats.tx_fifo_errors = 0;
-	    pAd->stats.tx_heartbeat_errors = 0;
-	    pAd->stats.tx_window_errors = 0;
-
-	    // for cslip etc
-	    pAd->stats.rx_compressed = 0;
-	    pAd->stats.tx_compressed = 0;
+		pAd->stats.rx_length_errors = 0;
+		pAd->stats.rx_over_errors = pAd->Counters8023.RxNoBuffer;	// receiver ring buff overflow
+		pAd->stats.rx_crc_errors = 0;	//pAd->WlanCounters.FCSErrorCount;     // recved pkt with crc error
+		pAd->stats.rx_frame_errors = pAd->Counters8023.RcvAlignmentErrors;	// recv'd frame alignment error
+		pAd->stats.rx_fifo_errors = pAd->Counters8023.RxNoBuffer;	// recv'r fifo overrun
+		pAd->stats.rx_missed_errors = 0;	// receiver missed packet
+
+		// detailed tx_errors
+		pAd->stats.tx_aborted_errors = 0;
+		pAd->stats.tx_carrier_errors = 0;
+		pAd->stats.tx_fifo_errors = 0;
+		pAd->stats.tx_heartbeat_errors = 0;
+		pAd->stats.tx_window_errors = 0;
+
+		// for cslip etc
+		pAd->stats.rx_compressed = 0;
+		pAd->stats.tx_compressed = 0;
 
 		return &pAd->stats;
-	}
-	else
-    	return NULL;
+	} else
+		return NULL;
 }
 
-
-BOOLEAN RtmpPhyNetDevExit(
-	IN RTMP_ADAPTER *pAd,
-	IN PNET_DEV net_dev)
+BOOLEAN RtmpPhyNetDevExit(IN RTMP_ADAPTER * pAd, IN PNET_DEV net_dev)
 {
 
-
-
 	// Unregister network device
-	if (net_dev != NULL)
-	{
-		printk("RtmpOSNetDevDetach(): RtmpOSNetDeviceDetach(), dev->name=%s!\n", net_dev->name);
+	if (net_dev != NULL) {
+		printk
+		    ("RtmpOSNetDevDetach(): RtmpOSNetDeviceDetach(), dev->name=%s!\n",
+		     net_dev->name);
 		RtmpOSNetDevDetach(net_dev);
 	}
 
@@ -726,7 +705,6 @@ BOOLEAN RtmpPhyNetDevExit(
 
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -743,17 +721,14 @@ Return Value:
 Note:
 ========================================================================
 */
-NDIS_STATUS AdapterBlockAllocateMemory(
-	IN PVOID	handle,
-	OUT	PVOID	*ppAd)
+NDIS_STATUS AdapterBlockAllocateMemory(IN PVOID handle, OUT PVOID * ppAd)
 {
 
-	*ppAd = (PVOID)vmalloc(sizeof(RTMP_ADAPTER)); //pci_alloc_consistent(pci_dev, sizeof(RTMP_ADAPTER), phy_addr);
+	*ppAd = (PVOID) vmalloc(sizeof(RTMP_ADAPTER));	//pci_alloc_consistent(pci_dev, sizeof(RTMP_ADAPTER), phy_addr);
 
-	if (*ppAd)
-	{
+	if (*ppAd) {
 		NdisZeroMemory(*ppAd, sizeof(RTMP_ADAPTER));
-		((PRTMP_ADAPTER)*ppAd)->OS_Cookie = handle;
+		((PRTMP_ADAPTER) * ppAd)->OS_Cookie = handle;
 		return (NDIS_STATUS_SUCCESS);
 	} else {
 		return (NDIS_STATUS_FAILURE);
--- a/drivers/staging/rt2860/rt_pci_rbus.c
+++ b/drivers/staging/rt2860/rt_pci_rbus.c
@@ -48,31 +48,28 @@ static void ac2_dma_done_tasklet(unsigne
 static void ac3_dma_done_tasklet(unsigned long data);
 static void fifo_statistic_full_tasklet(unsigned long data);
 
-
-
 /*---------------------------------------------------------------------*/
 /* Symbol & Macro Definitions                                          */
 /*---------------------------------------------------------------------*/
-#define RT2860_INT_RX_DLY				(1<<0)		// bit 0
-#define RT2860_INT_TX_DLY				(1<<1)		// bit 1
-#define RT2860_INT_RX_DONE				(1<<2)		// bit 2
-#define RT2860_INT_AC0_DMA_DONE			(1<<3)		// bit 3
-#define RT2860_INT_AC1_DMA_DONE			(1<<4)		// bit 4
-#define RT2860_INT_AC2_DMA_DONE			(1<<5)		// bit 5
-#define RT2860_INT_AC3_DMA_DONE			(1<<6)		// bit 6
-#define RT2860_INT_HCCA_DMA_DONE		(1<<7)		// bit 7
-#define RT2860_INT_MGMT_DONE			(1<<8)		// bit 8
+#define RT2860_INT_RX_DLY				(1<<0)	// bit 0
+#define RT2860_INT_TX_DLY				(1<<1)	// bit 1
+#define RT2860_INT_RX_DONE				(1<<2)	// bit 2
+#define RT2860_INT_AC0_DMA_DONE			(1<<3)	// bit 3
+#define RT2860_INT_AC1_DMA_DONE			(1<<4)	// bit 4
+#define RT2860_INT_AC2_DMA_DONE			(1<<5)	// bit 5
+#define RT2860_INT_AC3_DMA_DONE			(1<<6)	// bit 6
+#define RT2860_INT_HCCA_DMA_DONE		(1<<7)	// bit 7
+#define RT2860_INT_MGMT_DONE			(1<<8)	// bit 8
 
 #define INT_RX			RT2860_INT_RX_DONE
 
-#define INT_AC0_DLY		(RT2860_INT_AC0_DMA_DONE) //| RT2860_INT_TX_DLY)
-#define INT_AC1_DLY		(RT2860_INT_AC1_DMA_DONE) //| RT2860_INT_TX_DLY)
-#define INT_AC2_DLY		(RT2860_INT_AC2_DMA_DONE) //| RT2860_INT_TX_DLY)
-#define INT_AC3_DLY		(RT2860_INT_AC3_DMA_DONE) //| RT2860_INT_TX_DLY)
-#define INT_HCCA_DLY	(RT2860_INT_HCCA_DMA_DONE) //| RT2860_INT_TX_DLY)
+#define INT_AC0_DLY		(RT2860_INT_AC0_DMA_DONE)	//| RT2860_INT_TX_DLY)
+#define INT_AC1_DLY		(RT2860_INT_AC1_DMA_DONE)	//| RT2860_INT_TX_DLY)
+#define INT_AC2_DLY		(RT2860_INT_AC2_DMA_DONE)	//| RT2860_INT_TX_DLY)
+#define INT_AC3_DLY		(RT2860_INT_AC3_DMA_DONE)	//| RT2860_INT_TX_DLY)
+#define INT_HCCA_DLY	(RT2860_INT_HCCA_DMA_DONE)	//| RT2860_INT_TX_DLY)
 #define INT_MGMT_DLY	RT2860_INT_MGMT_DONE
 
-
 /***************************************************************************
   *
   *	Interface-depended memory allocation/Free related procedures.
@@ -80,92 +77,90 @@ static void fifo_statistic_full_tasklet(
   *
   **************************************************************************/
 // Function for TxDesc Memory allocation.
-void RTMP_AllocateTxDescMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	UINT	Index,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
-{
-	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
-
-	*VirtualAddress = (PVOID)pci_alloc_consistent(pObj->pci_dev,sizeof(char)*Length, PhysicalAddress);
+void RTMP_AllocateTxDescMemory(IN PRTMP_ADAPTER pAd,
+			       IN UINT Index,
+			       IN ULONG Length,
+			       IN BOOLEAN Cached,
+			       OUT PVOID * VirtualAddress,
+			       OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
+{
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+
+	*VirtualAddress =
+	    (PVOID) pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
+					 PhysicalAddress);
 
 }
 
-
 // Function for MgmtDesc Memory allocation.
-void RTMP_AllocateMgmtDescMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
-{
-	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
-
-	*VirtualAddress = (PVOID)pci_alloc_consistent(pObj->pci_dev,sizeof(char)*Length, PhysicalAddress);
+void RTMP_AllocateMgmtDescMemory(IN PRTMP_ADAPTER pAd,
+				 IN ULONG Length,
+				 IN BOOLEAN Cached,
+				 OUT PVOID * VirtualAddress,
+				 OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
+{
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+
+	*VirtualAddress =
+	    (PVOID) pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
+					 PhysicalAddress);
 
 }
 
-
 // Function for RxDesc Memory allocation.
-void RTMP_AllocateRxDescMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
-{
-	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
-
-	*VirtualAddress = (PVOID)pci_alloc_consistent(pObj->pci_dev,sizeof(char)*Length, PhysicalAddress);
+void RTMP_AllocateRxDescMemory(IN PRTMP_ADAPTER pAd,
+			       IN ULONG Length,
+			       IN BOOLEAN Cached,
+			       OUT PVOID * VirtualAddress,
+			       OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
+{
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+
+	*VirtualAddress =
+	    (PVOID) pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
+					 PhysicalAddress);
 
 }
 
-
 // Function for free allocated Desc Memory.
-void RTMP_FreeDescMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	PVOID	VirtualAddress,
-	IN	NDIS_PHYSICAL_ADDRESS PhysicalAddress)
+void RTMP_FreeDescMemory(IN PRTMP_ADAPTER pAd,
+			 IN ULONG Length,
+			 IN PVOID VirtualAddress,
+			 IN NDIS_PHYSICAL_ADDRESS PhysicalAddress)
 {
-	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-	pci_free_consistent(pObj->pci_dev, Length, VirtualAddress, PhysicalAddress);
+	pci_free_consistent(pObj->pci_dev, Length, VirtualAddress,
+			    PhysicalAddress);
 }
 
-
 // Function for TxData DMA Memory allocation.
-void RTMP_AllocateFirstTxBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	UINT	Index,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
-{
-	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
-
-	*VirtualAddress = (PVOID)pci_alloc_consistent(pObj->pci_dev,sizeof(char)*Length, PhysicalAddress);
-}
-
-
-void RTMP_FreeFirstTxBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	IN	PVOID	VirtualAddress,
-	IN	NDIS_PHYSICAL_ADDRESS PhysicalAddress)
+void RTMP_AllocateFirstTxBuffer(IN PRTMP_ADAPTER pAd,
+				IN UINT Index,
+				IN ULONG Length,
+				IN BOOLEAN Cached,
+				OUT PVOID * VirtualAddress,
+				OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
+{
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+
+	*VirtualAddress =
+	    (PVOID) pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
+					 PhysicalAddress);
+}
+
+void RTMP_FreeFirstTxBuffer(IN PRTMP_ADAPTER pAd,
+			    IN ULONG Length,
+			    IN BOOLEAN Cached,
+			    IN PVOID VirtualAddress,
+			    IN NDIS_PHYSICAL_ADDRESS PhysicalAddress)
 {
-	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-	pci_free_consistent(pObj->pci_dev, Length, VirtualAddress, PhysicalAddress);
+	pci_free_consistent(pObj->pci_dev, Length, VirtualAddress,
+			    PhysicalAddress);
 }
 
-
 /*
  * FUNCTION: Allocate a common buffer for DMA
  * ARGUMENTS:
@@ -175,19 +170,19 @@ void RTMP_FreeFirstTxBuffer(
  *     VirtualAddress:  Pointer to memory is returned here
  *     PhysicalAddress:  Physical address corresponding to virtual address
  */
-void RTMP_AllocateSharedMemory(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
-{
-	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
-
-	*VirtualAddress = (PVOID)pci_alloc_consistent(pObj->pci_dev,sizeof(char)*Length, PhysicalAddress);
+void RTMP_AllocateSharedMemory(IN PRTMP_ADAPTER pAd,
+			       IN ULONG Length,
+			       IN BOOLEAN Cached,
+			       OUT PVOID * VirtualAddress,
+			       OUT PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
+{
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+
+	*VirtualAddress =
+	    (PVOID) pci_alloc_consistent(pObj->pci_dev, sizeof(char) * Length,
+					 PhysicalAddress);
 }
 
-
 /*
  * FUNCTION: Allocate a packet buffer for DMA
  * ARGUMENTS:
@@ -199,25 +194,28 @@ void RTMP_AllocateSharedMemory(
  * Notes:
  *     Cached is ignored: always cached memory
  */
-PNDIS_PACKET RTMP_AllocateRxPacketBuffer(
-	IN	PRTMP_ADAPTER pAd,
-	IN	ULONG	Length,
-	IN	BOOLEAN	Cached,
-	OUT	PVOID	*VirtualAddress,
-	OUT	PNDIS_PHYSICAL_ADDRESS PhysicalAddress)
+PNDIS_PACKET RTMP_AllocateRxPacketBuffer(IN PRTMP_ADAPTER pAd,
+					 IN ULONG Length,
+					 IN BOOLEAN Cached,
+					 OUT PVOID * VirtualAddress,
+					 OUT PNDIS_PHYSICAL_ADDRESS
+					 PhysicalAddress)
 {
 	struct sk_buff *pkt;
 
 	pkt = dev_alloc_skb(Length);
 
 	if (pkt == NULL) {
-		DBGPRINT(RT_DEBUG_ERROR, ("can't allocate rx %ld size packet\n",Length));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("can't allocate rx %ld size packet\n", Length));
 	}
 
 	if (pkt) {
 		RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pkt), PKTSRC_NDIS);
 		*VirtualAddress = (PVOID) pkt->data;
-		*PhysicalAddress = PCI_MAP_SINGLE(pAd, *VirtualAddress, Length,  -1, PCI_DMA_FROMDEVICE);
+		*PhysicalAddress =
+		    PCI_MAP_SINGLE(pAd, *VirtualAddress, Length, -1,
+				   PCI_DMA_FROMDEVICE);
 	} else {
 		*VirtualAddress = (PVOID) NULL;
 		*PhysicalAddress = (NDIS_PHYSICAL_ADDRESS) NULL;
@@ -226,36 +224,40 @@ PNDIS_PACKET RTMP_AllocateRxPacketBuffer
 	return (PNDIS_PACKET) pkt;
 }
 
-
-VOID Invalid_Remaining_Packet(
-	IN	PRTMP_ADAPTER pAd,
-	IN	 ULONG VirtualAddress)
+VOID Invalid_Remaining_Packet(IN PRTMP_ADAPTER pAd, IN ULONG VirtualAddress)
 {
 	NDIS_PHYSICAL_ADDRESS PhysicalAddress;
 
-	PhysicalAddress = PCI_MAP_SINGLE(pAd, (void *)(VirtualAddress+1600), RX_BUFFER_NORMSIZE-1600, -1, PCI_DMA_FROMDEVICE);
+	PhysicalAddress =
+	    PCI_MAP_SINGLE(pAd, (void *)(VirtualAddress + 1600),
+			   RX_BUFFER_NORMSIZE - 1600, -1, PCI_DMA_FROMDEVICE);
 }
 
-NDIS_STATUS RtmpNetTaskInit(IN RTMP_ADAPTER *pAd)
+NDIS_STATUS RtmpNetTaskInit(IN RTMP_ADAPTER * pAd)
 {
 	POS_COOKIE pObj;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	tasklet_init(&pObj->rx_done_task, rx_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->mgmt_dma_done_task, mgmt_dma_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->ac0_dma_done_task, ac0_dma_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->ac1_dma_done_task, ac1_dma_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->ac2_dma_done_task, ac2_dma_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->ac3_dma_done_task, ac3_dma_done_tasklet, (unsigned long)pAd);
+	tasklet_init(&pObj->mgmt_dma_done_task, mgmt_dma_done_tasklet,
+		     (unsigned long)pAd);
+	tasklet_init(&pObj->ac0_dma_done_task, ac0_dma_done_tasklet,
+		     (unsigned long)pAd);
+	tasklet_init(&pObj->ac1_dma_done_task, ac1_dma_done_tasklet,
+		     (unsigned long)pAd);
+	tasklet_init(&pObj->ac2_dma_done_task, ac2_dma_done_tasklet,
+		     (unsigned long)pAd);
+	tasklet_init(&pObj->ac3_dma_done_task, ac3_dma_done_tasklet,
+		     (unsigned long)pAd);
 	tasklet_init(&pObj->tbtt_task, tbtt_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->fifo_statistic_full_task, fifo_statistic_full_tasklet, (unsigned long)pAd);
+	tasklet_init(&pObj->fifo_statistic_full_task,
+		     fifo_statistic_full_tasklet, (unsigned long)pAd);
 
 	return NDIS_STATUS_SUCCESS;
 }
 
-
-void RtmpNetTaskExit(IN RTMP_ADAPTER *pAd)
+void RtmpNetTaskExit(IN RTMP_ADAPTER * pAd)
 {
 	POS_COOKIE pObj;
 
@@ -271,15 +273,12 @@ void RtmpNetTaskExit(IN RTMP_ADAPTER *pA
 	tasklet_kill(&pObj->fifo_statistic_full_task);
 }
 
-
-NDIS_STATUS RtmpMgmtTaskInit(IN RTMP_ADAPTER *pAd)
+NDIS_STATUS RtmpMgmtTaskInit(IN RTMP_ADAPTER * pAd)
 {
 
-
 	return NDIS_STATUS_SUCCESS;
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -294,15 +293,12 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID RtmpMgmtTaskExit(
-	IN RTMP_ADAPTER *pAd)
+VOID RtmpMgmtTaskExit(IN RTMP_ADAPTER * pAd)
 {
 
-
 	return;
 }
 
-
 static inline void rt2860_int_enable(PRTMP_ADAPTER pAd, unsigned int mode)
 {
 	u32 regValue;
@@ -311,31 +307,28 @@ static inline void rt2860_int_enable(PRT
 	regValue = pAd->int_enable_reg & ~(pAd->int_disable_mask);
 	//if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 	{
-		RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);     // 1:enable
+		RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);	// 1:enable
 	}
 	//else
-	//	DBGPRINT(RT_DEBUG_TRACE, ("fOP_STATUS_DOZE !\n"));
+	//      DBGPRINT(RT_DEBUG_TRACE, ("fOP_STATUS_DOZE !\n"));
 
 	if (regValue != 0)
 		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE);
 }
 
-
 static inline void rt2860_int_disable(PRTMP_ADAPTER pAd, unsigned int mode)
 {
 	u32 regValue;
 
 	pAd->int_disable_mask |= mode;
-	regValue =	pAd->int_enable_reg & ~(pAd->int_disable_mask);
-	RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);     // 0: disable
+	regValue = pAd->int_enable_reg & ~(pAd->int_disable_mask);
+	RTMP_IO_WRITE32(pAd, INT_MASK_CSR, regValue);	// 0: disable
 
-	if (regValue == 0)
-	{
+	if (regValue == 0) {
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE);
 	}
 }
 
-
 /***************************************************************************
   *
   *	tasklet related procedures.
@@ -345,17 +338,18 @@ static void mgmt_dma_done_tasklet(unsign
 {
 	unsigned long flags;
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) data;
-    INT_SOURCE_CSR_STRUC	IntSource;
+	INT_SOURCE_CSR_STRUC IntSource;
 	POS_COOKIE pObj;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
-    pObj = (POS_COOKIE) pAd->OS_Cookie;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-//	printk("mgmt_dma_done_process\n");
+//      printk("mgmt_dma_done_process\n");
 	IntSource.word = 0;
 	IntSource.field.MgmtDmaDone = 1;
 	pAd->int_pending &= ~INT_MGMT_DLY;
@@ -368,8 +362,7 @@ static void mgmt_dma_done_tasklet(unsign
 	/*
 	 * double check to avoid lose of interrupts
 	 */
-	if (pAd->int_pending & INT_MGMT_DLY)
-	{
+	if (pAd->int_pending & INT_MGMT_DLY) {
 		tasklet_hi_schedule(&pObj->mgmt_dma_done_task);
 		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 		return;
@@ -380,30 +373,29 @@ static void mgmt_dma_done_tasklet(unsign
 	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 }
 
-
 static void rx_done_tasklet(unsigned long data)
 {
 	unsigned long flags;
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) data;
-	BOOLEAN	bReschedule = 0;
+	BOOLEAN bReschedule = 0;
 	POS_COOKIE pObj;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
-    pObj = (POS_COOKIE) pAd->OS_Cookie;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	pAd->int_pending &= ~(INT_RX);
-		bReschedule = STARxDoneInterruptHandle(pAd, 0);
+	bReschedule = STARxDoneInterruptHandle(pAd, 0);
 
 	RTMP_INT_LOCK(&pAd->irq_lock, flags);
 	/*
 	 * double check to avoid rotting packet
 	 */
-	if (pAd->int_pending & INT_RX || bReschedule)
-	{
+	if (pAd->int_pending & INT_RX || bReschedule) {
 		tasklet_hi_schedule(&pObj->rx_done_task);
 		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 		return;
@@ -415,7 +407,6 @@ static void rx_done_tasklet(unsigned lon
 
 }
 
-
 void fifo_statistic_full_tasklet(unsigned long data)
 {
 	unsigned long flags;
@@ -424,10 +415,11 @@ void fifo_statistic_full_tasklet(unsigne
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
-    pObj = (POS_COOKIE) pAd->OS_Cookie;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	pAd->int_pending &= ~(FifoStaFullInt);
 	NICUpdateFifoStaCounters(pAd);
@@ -436,8 +428,7 @@ void fifo_statistic_full_tasklet(unsigne
 	/*
 	 * double check to avoid rotting packet
 	 */
-	if (pAd->int_pending & FifoStaFullInt)
-	{
+	if (pAd->int_pending & FifoStaFullInt) {
 		tasklet_hi_schedule(&pObj->fifo_statistic_full_task);
 		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 		return;
@@ -454,18 +445,19 @@ static void ac3_dma_done_tasklet(unsigne
 {
 	unsigned long flags;
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) data;
-    INT_SOURCE_CSR_STRUC	IntSource;
+	INT_SOURCE_CSR_STRUC IntSource;
 	POS_COOKIE pObj;
 	BOOLEAN bReschedule = 0;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
-    pObj = (POS_COOKIE) pAd->OS_Cookie;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-//	printk("ac0_dma_done_process\n");
+//      printk("ac0_dma_done_process\n");
 	IntSource.word = 0;
 	IntSource.field.Ac3DmaDone = 1;
 	pAd->int_pending &= ~INT_AC3_DLY;
@@ -476,8 +468,7 @@ static void ac3_dma_done_tasklet(unsigne
 	/*
 	 * double check to avoid lose of interrupts
 	 */
-	if ((pAd->int_pending & INT_AC3_DLY) || bReschedule)
-	{
+	if ((pAd->int_pending & INT_AC3_DLY) || bReschedule) {
 		tasklet_hi_schedule(&pObj->ac3_dma_done_task);
 		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 		return;
@@ -488,21 +479,21 @@ static void ac3_dma_done_tasklet(unsigne
 	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 }
 
-
 static void ac2_dma_done_tasklet(unsigned long data)
 {
 	unsigned long flags;
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) data;
-    INT_SOURCE_CSR_STRUC	IntSource;
+	INT_SOURCE_CSR_STRUC IntSource;
 	POS_COOKIE pObj;
 	BOOLEAN bReschedule = 0;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
-    pObj = (POS_COOKIE) pAd->OS_Cookie;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	IntSource.word = 0;
 	IntSource.field.Ac2DmaDone = 1;
@@ -515,8 +506,7 @@ static void ac2_dma_done_tasklet(unsigne
 	/*
 	 * double check to avoid lose of interrupts
 	 */
-	if ((pAd->int_pending & INT_AC2_DLY) || bReschedule)
-	{
+	if ((pAd->int_pending & INT_AC2_DLY) || bReschedule) {
 		tasklet_hi_schedule(&pObj->ac2_dma_done_task);
 		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 		return;
@@ -527,23 +517,23 @@ static void ac2_dma_done_tasklet(unsigne
 	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 }
 
-
 static void ac1_dma_done_tasklet(unsigned long data)
 {
 	unsigned long flags;
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) data;
-    INT_SOURCE_CSR_STRUC	IntSource;
+	INT_SOURCE_CSR_STRUC IntSource;
 	POS_COOKIE pObj;
 	BOOLEAN bReschedule = 0;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
-    pObj = (POS_COOKIE) pAd->OS_Cookie;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-//	printk("ac0_dma_done_process\n");
+//      printk("ac0_dma_done_process\n");
 	IntSource.word = 0;
 	IntSource.field.Ac1DmaDone = 1;
 	pAd->int_pending &= ~INT_AC1_DLY;
@@ -554,8 +544,7 @@ static void ac1_dma_done_tasklet(unsigne
 	/*
 	 * double check to avoid lose of interrupts
 	 */
-	if ((pAd->int_pending & INT_AC1_DLY) || bReschedule)
-	{
+	if ((pAd->int_pending & INT_AC1_DLY) || bReschedule) {
 		tasklet_hi_schedule(&pObj->ac1_dma_done_task);
 		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 		return;
@@ -566,36 +555,35 @@ static void ac1_dma_done_tasklet(unsigne
 	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 }
 
-
 static void ac0_dma_done_tasklet(unsigned long data)
 {
 	unsigned long flags;
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) data;
-	INT_SOURCE_CSR_STRUC	IntSource;
+	INT_SOURCE_CSR_STRUC IntSource;
 	POS_COOKIE pObj;
 	BOOLEAN bReschedule = 0;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-//	printk("ac0_dma_done_process\n");
+//      printk("ac0_dma_done_process\n");
 	IntSource.word = 0;
 	IntSource.field.Ac0DmaDone = 1;
 	pAd->int_pending &= ~INT_AC0_DLY;
 
-//	RTMPHandleMgmtRingDmaDoneInterrupt(pAd);
+//      RTMPHandleMgmtRingDmaDoneInterrupt(pAd);
 	bReschedule = RTMPHandleTxRingDmaDoneInterrupt(pAd, IntSource);
 
 	RTMP_INT_LOCK(&pAd->irq_lock, flags);
 	/*
 	 * double check to avoid lose of interrupts
 	 */
-	if ((pAd->int_pending & INT_AC0_DLY) || bReschedule)
-	{
+	if ((pAd->int_pending & INT_AC0_DLY) || bReschedule) {
 		tasklet_hi_schedule(&pObj->ac0_dma_done_task);
 		RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 		return;
@@ -606,9 +594,6 @@ static void ac0_dma_done_tasklet(unsigne
 	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 }
 
-
-
-
 /***************************************************************************
   *
   *	interrupt handler related procedures.
@@ -618,27 +603,25 @@ int print_int_count;
 
 IRQ_HANDLE_TYPE rt2860_interrupt(int irq, void *dev_instance)
 {
-	struct net_device *net_dev = (struct net_device *) dev_instance;
+	struct net_device *net_dev = (struct net_device *)dev_instance;
 	PRTMP_ADAPTER pAd = NULL;
-	INT_SOURCE_CSR_STRUC	IntSource;
+	INT_SOURCE_CSR_STRUC IntSource;
 	POS_COOKIE pObj;
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-
 	/* Note 03312008: we can not return here before
-		RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IntSource.word);
-		RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word);
-		Or kernel will panic after ifconfig ra0 down sometimes */
-
+	   RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IntSource.word);
+	   RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word);
+	   Or kernel will panic after ifconfig ra0 down sometimes */
 
 	//
 	// Inital the Interrupt source.
 	//
 	IntSource.word = 0x00000000L;
-//	McuIntSource.word = 0x00000000L;
+//      McuIntSource.word = 0x00000000L;
 
 	//
 	// Get the interrupt sources & saved to local variable
@@ -655,25 +638,26 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 	//
 	// RT2661 => when ASIC is sleeping, MAC register cannot be read and written.
 	// RT2860 => when ASIC is sleeping, MAC register can be read and written.
-//	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
+//      if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 	{
 		RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IntSource.word);
-		RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word); // write 1 to clear
+		RTMP_IO_WRITE32(pAd, INT_SOURCE_CSR, IntSource.word);	// write 1 to clear
 	}
-//	else
-//		DBGPRINT(RT_DEBUG_TRACE, (">>>fOP_STATUS_DOZE<<<\n"));
+//      else
+//              DBGPRINT(RT_DEBUG_TRACE, (">>>fOP_STATUS_DOZE<<<\n"));
 
-//	RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IsrAfterClear);
-//	RTMP_IO_READ32(pAd, MCU_INT_SOURCE_CSR, &McuIsrAfterClear);
-//	DBGPRINT(RT_DEBUG_INFO, ("====> RTMPHandleInterrupt(ISR=%08x,Mcu ISR=%08x, After clear ISR=%08x, MCU ISR=%08x)\n",
-//			IntSource.word, McuIntSource.word, IsrAfterClear, McuIsrAfterClear));
+//      RTMP_IO_READ32(pAd, INT_SOURCE_CSR, &IsrAfterClear);
+//      RTMP_IO_READ32(pAd, MCU_INT_SOURCE_CSR, &McuIsrAfterClear);
+//      DBGPRINT(RT_DEBUG_INFO, ("====> RTMPHandleInterrupt(ISR=%08x,Mcu ISR=%08x, After clear ISR=%08x, MCU ISR=%08x)\n",
+//                      IntSource.word, McuIntSource.word, IsrAfterClear, McuIsrAfterClear));
 
 	// Do nothing if Reset in progress
-	if (RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |fRTMP_ADAPTER_HALT_IN_PROGRESS)))
-	{
-        return  IRQ_HANDLED;
+	if (RTMP_TEST_FLAG
+	    (pAd,
+	     (fRTMP_ADAPTER_RESET_IN_PROGRESS |
+	      fRTMP_ADAPTER_HALT_IN_PROGRESS))) {
+		return IRQ_HANDLED;
 	}
-
 	//
 	// Handle interrupt, walk through all bits
 	// Should start from highest priority interrupt
@@ -684,7 +668,6 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 
 #endif
 
-
 	pAd->bPCIclkOff = FALSE;
 
 	// If required spinlock, each interrupt service routine has to acquire
@@ -692,28 +675,25 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 	//
 
 	// Do nothing if NIC doesn't exist
-	if (IntSource.word == 0xffffffff)
-	{
-		RTMP_SET_FLAG(pAd, (fRTMP_ADAPTER_NIC_NOT_EXIST | fRTMP_ADAPTER_HALT_IN_PROGRESS));
-        return  IRQ_HANDLED;
+	if (IntSource.word == 0xffffffff) {
+		RTMP_SET_FLAG(pAd,
+			      (fRTMP_ADAPTER_NIC_NOT_EXIST |
+			       fRTMP_ADAPTER_HALT_IN_PROGRESS));
+		return IRQ_HANDLED;
 	}
 
-	if (IntSource.word & TxCoherent)
-	{
+	if (IntSource.word & TxCoherent) {
 		DBGPRINT(RT_DEBUG_ERROR, (">>>TxCoherent<<<\n"));
 		RTMPHandleRxCoherentInterrupt(pAd);
 	}
 
-	if (IntSource.word & RxCoherent)
-	{
+	if (IntSource.word & RxCoherent) {
 		DBGPRINT(RT_DEBUG_ERROR, (">>>RxCoherent<<<\n"));
 		RTMPHandleRxCoherentInterrupt(pAd);
 	}
 
-	if (IntSource.word & FifoStaFullInt)
-	{
-		if ((pAd->int_disable_mask & FifoStaFullInt) == 0)
-		{
+	if (IntSource.word & FifoStaFullInt) {
+		if ((pAd->int_disable_mask & FifoStaFullInt) == 0) {
 			/* mask FifoStaFullInt */
 			rt2860_int_disable(pAd, FifoStaFullInt);
 			tasklet_hi_schedule(&pObj->fifo_statistic_full_task);
@@ -721,20 +701,16 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 		pAd->int_pending |= FifoStaFullInt;
 	}
 
-	if (IntSource.word & INT_MGMT_DLY)
-	{
-		if ((pAd->int_disable_mask & INT_MGMT_DLY) ==0 )
-		{
+	if (IntSource.word & INT_MGMT_DLY) {
+		if ((pAd->int_disable_mask & INT_MGMT_DLY) == 0) {
 			rt2860_int_disable(pAd, INT_MGMT_DLY);
 			tasklet_hi_schedule(&pObj->mgmt_dma_done_task);
 		}
-		pAd->int_pending |= INT_MGMT_DLY ;
+		pAd->int_pending |= INT_MGMT_DLY;
 	}
 
-	if (IntSource.word & INT_RX)
-	{
-		if ((pAd->int_disable_mask & INT_RX) == 0)
-		{
+	if (IntSource.word & INT_RX) {
+		if ((pAd->int_disable_mask & INT_RX) == 0) {
 
 			/* mask RxINT */
 			rt2860_int_disable(pAd, INT_RX);
@@ -743,11 +719,9 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 		pAd->int_pending |= INT_RX;
 	}
 
-	if (IntSource.word & INT_AC3_DLY)
-	{
+	if (IntSource.word & INT_AC3_DLY) {
 
-		if ((pAd->int_disable_mask & INT_AC3_DLY) == 0)
-		{
+		if ((pAd->int_disable_mask & INT_AC3_DLY) == 0) {
 			/* mask TxDataInt */
 			rt2860_int_disable(pAd, INT_AC3_DLY);
 			tasklet_hi_schedule(&pObj->ac3_dma_done_task);
@@ -755,11 +729,9 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 		pAd->int_pending |= INT_AC3_DLY;
 	}
 
-	if (IntSource.word & INT_AC2_DLY)
-	{
+	if (IntSource.word & INT_AC2_DLY) {
 
-		if ((pAd->int_disable_mask & INT_AC2_DLY) == 0)
-		{
+		if ((pAd->int_disable_mask & INT_AC2_DLY) == 0) {
 			/* mask TxDataInt */
 			rt2860_int_disable(pAd, INT_AC2_DLY);
 			tasklet_hi_schedule(&pObj->ac2_dma_done_task);
@@ -767,13 +739,11 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 		pAd->int_pending |= INT_AC2_DLY;
 	}
 
-	if (IntSource.word & INT_AC1_DLY)
-	{
+	if (IntSource.word & INT_AC1_DLY) {
 
 		pAd->int_pending |= INT_AC1_DLY;
 
-		if ((pAd->int_disable_mask & INT_AC1_DLY) == 0)
-		{
+		if ((pAd->int_disable_mask & INT_AC1_DLY) == 0) {
 			/* mask TxDataInt */
 			rt2860_int_disable(pAd, INT_AC1_DLY);
 			tasklet_hi_schedule(&pObj->ac1_dma_done_task);
@@ -781,8 +751,7 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 
 	}
 
-	if (IntSource.word & INT_AC0_DLY)
-	{
+	if (IntSource.word & INT_AC0_DLY) {
 
 /*
 		if (IntSource.word & 0x2) {
@@ -793,8 +762,7 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 */
 		pAd->int_pending |= INT_AC0_DLY;
 
-		if ((pAd->int_disable_mask & INT_AC0_DLY) == 0)
-		{
+		if ((pAd->int_disable_mask & INT_AC0_DLY) == 0) {
 			/* mask TxDataInt */
 			rt2860_int_disable(pAd, INT_AC0_DLY);
 			tasklet_hi_schedule(&pObj->ac0_dma_done_task);
@@ -802,14 +770,11 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 
 	}
 
-
-	if (IntSource.word & PreTBTTInt)
-	{
+	if (IntSource.word & PreTBTTInt) {
 		RTMPHandlePreTBTTInterrupt(pAd);
 	}
 
-	if (IntSource.word & TBTTInt)
-	{
+	if (IntSource.word & TBTTInt) {
 		RTMPHandleTBTTInterrupt(pAd);
 	}
 
@@ -818,57 +783,57 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq
 			RTMPHandleTwakeupInterrupt(pAd);
 	}
 
-	return  IRQ_HANDLED;
+	return IRQ_HANDLED;
 }
 
 /*
  * invaild or writeback cache
  * and convert virtual address to physical address
  */
-dma_addr_t linux_pci_map_single(void *handle, void *ptr, size_t size, int sd_idx, int direction)
+dma_addr_t linux_pci_map_single(void *handle, void *ptr, size_t size,
+				int sd_idx, int direction)
 {
 	PRTMP_ADAPTER pAd;
 	POS_COOKIE pObj;
 
 	/*
-		------ Porting Information ------
-		> For Tx Alloc:
-			mgmt packets => sd_idx = 0
-			SwIdx: pAd->MgmtRing.TxCpuIdx
-			pTxD : pAd->MgmtRing.Cell[SwIdx].AllocVa;
-
-			data packets => sd_idx = 1
-			TxIdx : pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx
-			QueIdx: pTxBlk->QueIdx
-			pTxD  : pAd->TxRing[pTxBlk->QueIdx].Cell[TxIdx].AllocVa;
-
-		> For Rx Alloc:
-			sd_idx = -1
-	*/
+	   ------ Porting Information ------
+	   > For Tx Alloc:
+	   mgmt packets => sd_idx = 0
+	   SwIdx: pAd->MgmtRing.TxCpuIdx
+	   pTxD : pAd->MgmtRing.Cell[SwIdx].AllocVa;
+
+	   data packets => sd_idx = 1
+	   TxIdx : pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx
+	   QueIdx: pTxBlk->QueIdx
+	   pTxD  : pAd->TxRing[pTxBlk->QueIdx].Cell[TxIdx].AllocVa;
 
-	pAd = (PRTMP_ADAPTER)handle;
-	pObj = (POS_COOKIE)pAd->OS_Cookie;
+	   > For Rx Alloc:
+	   sd_idx = -1
+	 */
 
-	if (sd_idx == 1)
-	{
-		PTX_BLK		pTxBlk;
-		pTxBlk = (PTX_BLK)ptr;
-		return pci_map_single(pObj->pci_dev, pTxBlk->pSrcBufData, pTxBlk->SrcBufLen, direction);
-	}
-	else
-	{
+	pAd = (PRTMP_ADAPTER) handle;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
+
+	if (sd_idx == 1) {
+		PTX_BLK pTxBlk;
+		pTxBlk = (PTX_BLK) ptr;
+		return pci_map_single(pObj->pci_dev, pTxBlk->pSrcBufData,
+				      pTxBlk->SrcBufLen, direction);
+	} else {
 		return pci_map_single(pObj->pci_dev, ptr, size, direction);
 	}
 
 }
 
-void linux_pci_unmap_single(void *handle, dma_addr_t dma_addr, size_t size, int direction)
+void linux_pci_unmap_single(void *handle, dma_addr_t dma_addr, size_t size,
+			    int direction)
 {
 	PRTMP_ADAPTER pAd;
 	POS_COOKIE pObj;
 
-	pAd=(PRTMP_ADAPTER)handle;
-	pObj = (POS_COOKIE)pAd->OS_Cookie;
+	pAd = (PRTMP_ADAPTER) handle;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	pci_unmap_single(pObj->pci_dev, dma_addr, size, direction);
 
--- a/drivers/staging/rt2860/rt_usb.c
+++ b/drivers/staging/rt2860/rt_usb.c
@@ -38,7 +38,7 @@
 
 #include "rt_config.h"
 
- void dump_urb(struct urb* purb)
+void dump_urb(struct urb *purb)
 {
 	printk("urb                  :0x%08lx\n", (unsigned long)purb);
 	printk("\tdev                   :0x%08lx\n", (unsigned long)purb->dev);
@@ -46,16 +46,20 @@
 	printk("\tpipe                  :0x%08x\n", purb->pipe);
 	printk("\tstatus                :%d\n", purb->status);
 	printk("\ttransfer_flags        :0x%08x\n", purb->transfer_flags);
-	printk("\ttransfer_buffer       :0x%08lx\n", (unsigned long)purb->transfer_buffer);
+	printk("\ttransfer_buffer       :0x%08lx\n",
+	       (unsigned long)purb->transfer_buffer);
 	printk("\ttransfer_buffer_length:%d\n", purb->transfer_buffer_length);
 	printk("\tactual_length         :%d\n", purb->actual_length);
-	printk("\tsetup_packet          :0x%08lx\n", (unsigned long)purb->setup_packet);
+	printk("\tsetup_packet          :0x%08lx\n",
+	       (unsigned long)purb->setup_packet);
 	printk("\tstart_frame           :%d\n", purb->start_frame);
 	printk("\tnumber_of_packets     :%d\n", purb->number_of_packets);
 	printk("\tinterval              :%d\n", purb->interval);
 	printk("\terror_count           :%d\n", purb->error_count);
-	printk("\tcontext               :0x%08lx\n", (unsigned long)purb->context);
-	printk("\tcomplete              :0x%08lx\n\n", (unsigned long)purb->complete);
+	printk("\tcontext               :0x%08lx\n",
+	       (unsigned long)purb->context);
+	printk("\tcomplete              :0x%08lx\n\n",
+	       (unsigned long)purb->complete);
 }
 
 /*
@@ -73,23 +77,22 @@ Return Value:
 Note:
 ========================================================================
 */
-NDIS_STATUS	 RtmpMgmtTaskInit(
-	IN RTMP_ADAPTER *pAd)
+NDIS_STATUS RtmpMgmtTaskInit(IN RTMP_ADAPTER * pAd)
 {
 	RTMP_OS_TASK *pTask;
 	NDIS_STATUS status;
 
 	/*
-		Creat TimerQ Thread, We need init timerQ related structure before create the timer thread.
-	*/
+	   Creat TimerQ Thread, We need init timerQ related structure before create the timer thread.
+	 */
 	RtmpTimerQInit(pAd);
 
 	pTask = &pAd->timerTask;
 	RtmpOSTaskInit(pTask, "RtmpTimerTask", pAd);
 	status = RtmpOSTaskAttach(pTask, RtmpTimerQThread, pTask);
-	if (status == NDIS_STATUS_FAILURE)
-	{
-		printk (KERN_WARNING "%s: unable to start RtmpTimerQThread\n", RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
+	if (status == NDIS_STATUS_FAILURE) {
+		printk(KERN_WARNING "%s: unable to start RtmpTimerQThread\n",
+		       RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
 		return NDIS_STATUS_FAILURE;
 	}
 
@@ -97,9 +100,9 @@ NDIS_STATUS	 RtmpMgmtTaskInit(
 	pTask = &pAd->mlmeTask;
 	RtmpOSTaskInit(pTask, "RtmpMlmeTask", pAd);
 	status = RtmpOSTaskAttach(pTask, MlmeThread, pTask);
-	if (status == NDIS_STATUS_FAILURE)
-	{
-		printk (KERN_WARNING "%s: unable to start MlmeThread\n", RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
+	if (status == NDIS_STATUS_FAILURE) {
+		printk(KERN_WARNING "%s: unable to start MlmeThread\n",
+		       RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
 		return NDIS_STATUS_FAILURE;
 	}
 
@@ -107,18 +110,15 @@ NDIS_STATUS	 RtmpMgmtTaskInit(
 	pTask = &pAd->cmdQTask;
 	RtmpOSTaskInit(pTask, "RtmpCmdQTask", pAd);
 	status = RtmpOSTaskAttach(pTask, RTUSBCmdThread, pTask);
-	if (status == NDIS_STATUS_FAILURE)
-	{
-		printk (KERN_WARNING "%s: unable to start RTUSBCmdThread\n", RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
+	if (status == NDIS_STATUS_FAILURE) {
+		printk(KERN_WARNING "%s: unable to start RTUSBCmdThread\n",
+		       RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
 		return NDIS_STATUS_FAILURE;
 	}
 
-
 	return NDIS_STATUS_SUCCESS;
 }
 
-
-
 /*
 ========================================================================
 Routine Description:
@@ -133,11 +133,10 @@ Return Value:
 Note:
 ========================================================================
 */
-VOID RtmpMgmtTaskExit(
-	IN RTMP_ADAPTER *pAd)
+VOID RtmpMgmtTaskExit(IN RTMP_ADAPTER * pAd)
 {
-	INT			ret;
-	RTMP_OS_TASK	*pTask;
+	INT ret;
+	RTMP_OS_TASK *pTask;
 
 	// Sleep 50 milliseconds so pending io might finish normally
 	RTMPusecDelay(50000);
@@ -153,10 +152,11 @@ VOID RtmpMgmtTaskExit(
 	/* Terminate Mlme Thread */
 	pTask = &pAd->mlmeTask;
 	ret = RtmpOSTaskKill(pTask);
-	if (ret == NDIS_STATUS_FAILURE)
-	{
+	if (ret == NDIS_STATUS_FAILURE) {
 		DBGPRINT(RT_DEBUG_ERROR, ("%s: kill task(%s) failed!\n",
-					RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev), pTask->taskName));
+					  RTMP_OS_NETDEV_GET_DEVNAME(pAd->
+								     net_dev),
+					  pTask->taskName));
 	}
 
 	/* Terminate cmdQ thread */
@@ -174,10 +174,11 @@ VOID RtmpMgmtTaskExit(
 		mb();
 		//RTUSBCMDUp(pAd);
 		ret = RtmpOSTaskKill(pTask);
-		if (ret == NDIS_STATUS_FAILURE)
-		{
+		if (ret == NDIS_STATUS_FAILURE) {
 			DBGPRINT(RT_DEBUG_ERROR, ("%s: kill task(%s) failed!\n",
-					RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev), pTask->taskName));
+						  RTMP_OS_NETDEV_GET_DEVNAME
+						  (pAd->net_dev),
+						  pTask->taskName));
 		}
 		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_UNKNOWN;
 	}
@@ -185,47 +186,44 @@ VOID RtmpMgmtTaskExit(
 	/* Terminate timer thread */
 	pTask = &pAd->timerTask;
 	ret = RtmpOSTaskKill(pTask);
-	if (ret == NDIS_STATUS_FAILURE)
-	{
+	if (ret == NDIS_STATUS_FAILURE) {
 		DBGPRINT(RT_DEBUG_ERROR, ("%s: kill task(%s) failed!\n",
-					RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev), pTask->taskName));
+					  RTMP_OS_NETDEV_GET_DEVNAME(pAd->
+								     net_dev),
+					  pTask->taskName));
 	}
 
-
 }
 
-
 static void rtusb_dataout_complete(unsigned long data)
 {
-	PRTMP_ADAPTER		pAd;
-	purbb_t				pUrb;
-	POS_COOKIE			pObj;
-	PHT_TX_CONTEXT		pHTTXContext;
-	UCHAR				BulkOutPipeId;
-	NTSTATUS			Status;
-	unsigned long		IrqFlags;
-
-
-	pUrb			= (purbb_t)data;
-	pHTTXContext	= (PHT_TX_CONTEXT)pUrb->context;
-	pAd				= pHTTXContext->pAd;
-	pObj			= (POS_COOKIE) pAd->OS_Cookie;
-	Status			= pUrb->status;
+	PRTMP_ADAPTER pAd;
+	purbb_t pUrb;
+	POS_COOKIE pObj;
+	PHT_TX_CONTEXT pHTTXContext;
+	UCHAR BulkOutPipeId;
+	NTSTATUS Status;
+	unsigned long IrqFlags;
+
+	pUrb = (purbb_t) data;
+	pHTTXContext = (PHT_TX_CONTEXT) pUrb->context;
+	pAd = pHTTXContext->pAd;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
+	Status = pUrb->status;
 
 	// Store BulkOut PipeId
 	BulkOutPipeId = pHTTXContext->BulkOutPipeId;
 	pAd->BulkOutDataOneSecCount++;
 
 	//DBGPRINT(RT_DEBUG_LOUD, ("Done-B(%d):I=0x%lx, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", BulkOutPipeId, in_interrupt(), pHTTXContext->CurWritePosition,
-	//		pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
+	//              pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
 
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 	pAd->BulkOutPending[BulkOutPipeId] = FALSE;
 	pHTTXContext->IRPPending = FALSE;
 	pAd->watchDogTxPendingCnt[BulkOutPipeId] = 0;
 
-	if (Status == USB_ST_NOERROR)
-	{
+	if (Status == USB_ST_NOERROR) {
 		pAd->BulkOutComplete++;
 
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
@@ -235,30 +233,37 @@ static void rtusb_dataout_complete(unsig
 		FREE_HTTX_RING(pAd, BulkOutPipeId, pHTTXContext);
 		//RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
 
-
-	}
-	else	// STATUS_OTHER
+	} else			// STATUS_OTHER
 	{
-		PUCHAR	pBuf;
+		PUCHAR pBuf;
 
 		pAd->BulkOutCompleteOther++;
 
-		pBuf = &pHTTXContext->TransferBuffer->field.WirelessPacket[pHTTXContext->NextBulkOutPosition];
+		pBuf =
+		    &pHTTXContext->TransferBuffer->field.
+		    WirelessPacket[pHTTXContext->NextBulkOutPosition];
 
 		if (!RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-									fRTMP_ADAPTER_HALT_IN_PROGRESS |
-									fRTMP_ADAPTER_NIC_NOT_EXIST |
-									fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
+					  fRTMP_ADAPTER_HALT_IN_PROGRESS |
+					  fRTMP_ADAPTER_NIC_NOT_EXIST |
+					  fRTMP_ADAPTER_BULKOUT_RESET))) {
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
 			pAd->bulkResetPipeid = BulkOutPipeId;
 			pAd->bulkResetReq[BulkOutPipeId] = pAd->BulkOutReq;
 		}
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("BulkOutDataPacket failed: ReasonCode=%d!\n", Status));
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("\t>>BulkOut Req=0x%lx, Complete=0x%lx, Other=0x%lx\n", pAd->BulkOutReq, pAd->BulkOutComplete, pAd->BulkOutCompleteOther));
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("\t>>BulkOut Header:%x %x %x %x %x %x %x %x\n", pBuf[0], pBuf[1], pBuf[2], pBuf[3], pBuf[4], pBuf[5], pBuf[6], pBuf[7]));
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     ("BulkOutDataPacket failed: ReasonCode=%d!\n",
+			      Status));
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     ("\t>>BulkOut Req=0x%lx, Complete=0x%lx, Other=0x%lx\n",
+			      pAd->BulkOutReq, pAd->BulkOutComplete,
+			      pAd->BulkOutCompleteOther));
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     ("\t>>BulkOut Header:%x %x %x %x %x %x %x %x\n",
+			      pBuf[0], pBuf[1], pBuf[2], pBuf[3], pBuf[4],
+			      pBuf[5], pBuf[6], pBuf[7]));
 		//DBGPRINT_RAW(RT_DEBUG_ERROR, (">>BulkOutCompleteCancel=0x%x, BulkOutCompleteOther=0x%x\n", pAd->BulkOutCompleteCancel, pAd->BulkOutCompleteOther));
 
 	}
@@ -268,12 +273,17 @@ static void rtusb_dataout_complete(unsig
 	// bWaitingBulkOut = TRUE, means the TX data are waiting for bulk out.
 	//
 	//RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-	if ((pHTTXContext->ENextBulkOutPosition != pHTTXContext->CurWritePosition) &&
-		(pHTTXContext->ENextBulkOutPosition != (pHTTXContext->CurWritePosition+8)) &&
-		!RTUSB_TEST_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId)))
-	{
+	if ((pHTTXContext->ENextBulkOutPosition !=
+	     pHTTXContext->CurWritePosition)
+	    && (pHTTXContext->ENextBulkOutPosition !=
+		(pHTTXContext->CurWritePosition + 8))
+	    && !RTUSB_TEST_BULK_FLAG(pAd,
+				     (fRTUSB_BULK_OUT_DATA_FRAG <<
+				      BulkOutPipeId))) {
 		// Indicate There is data avaliable
-		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
+		RTUSB_SET_BULK_FLAG(pAd,
+				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
+				     BulkOutPipeId));
 	}
 	//RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
 
@@ -282,49 +292,46 @@ static void rtusb_dataout_complete(unsig
 	RTUSBKickBulkOut(pAd);
 }
 
-
 static void rtusb_null_frame_done_tasklet(unsigned long data)
 {
-	PRTMP_ADAPTER	pAd;
-	PTX_CONTEXT		pNullContext;
-	purbb_t			pUrb;
-	NTSTATUS		Status;
-	unsigned long	irqFlag;
-
-
-	pUrb			= (purbb_t)data;
-	pNullContext	= (PTX_CONTEXT)pUrb->context;
-	pAd			= pNullContext->pAd;
-	Status			= pUrb->status;
+	PRTMP_ADAPTER pAd;
+	PTX_CONTEXT pNullContext;
+	purbb_t pUrb;
+	NTSTATUS Status;
+	unsigned long irqFlag;
+
+	pUrb = (purbb_t) data;
+	pNullContext = (PTX_CONTEXT) pUrb->context;
+	pAd = pNullContext->pAd;
+	Status = pUrb->status;
 
 	// Reset Null frame context flags
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], irqFlag);
-	pNullContext->IRPPending	= FALSE;
-	pNullContext->InUse		= FALSE;
+	pNullContext->IRPPending = FALSE;
+	pNullContext->InUse = FALSE;
 	pAd->BulkOutPending[0] = FALSE;
 	pAd->watchDogTxPendingCnt[0] = 0;
 
-	if (Status == USB_ST_NOERROR)
-	{
+	if (Status == USB_ST_NOERROR) {
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
 
 		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	}
-	else	// STATUS_OTHER
+	} else			// STATUS_OTHER
 	{
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out Null Frame Failed, ReasonCode=%d!\n", Status));
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))) {
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("Bulk Out Null Frame Failed, ReasonCode=%d!\n",
+				      Status));
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
+			pAd->bulkResetPipeid =
+			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
 			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-		else
-		{
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
+						NULL, 0);
+		} else {
 			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
 		}
 	}
@@ -334,46 +341,42 @@ static void rtusb_null_frame_done_taskle
 	RTUSBKickBulkOut(pAd);
 }
 
-
 static void rtusb_rts_frame_done_tasklet(unsigned long data)
 {
-	PRTMP_ADAPTER	pAd;
-	PTX_CONTEXT		pRTSContext;
-	purbb_t			pUrb;
-	NTSTATUS		Status;
-	unsigned long	irqFlag;
-
-
-	pUrb		= (purbb_t)data;
-	pRTSContext	= (PTX_CONTEXT)pUrb->context;
-	pAd			= pRTSContext->pAd;
-	Status		= pUrb->status;
+	PRTMP_ADAPTER pAd;
+	PTX_CONTEXT pRTSContext;
+	purbb_t pUrb;
+	NTSTATUS Status;
+	unsigned long irqFlag;
+
+	pUrb = (purbb_t) data;
+	pRTSContext = (PTX_CONTEXT) pUrb->context;
+	pAd = pRTSContext->pAd;
+	Status = pUrb->status;
 
 	// Reset RTS frame context flags
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], irqFlag);
 	pRTSContext->IRPPending = FALSE;
-	pRTSContext->InUse		= FALSE;
+	pRTSContext->InUse = FALSE;
 
-	if (Status == USB_ST_NOERROR)
-	{
+	if (Status == USB_ST_NOERROR) {
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
 		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	}
-	else	// STATUS_OTHER
+	} else			// STATUS_OTHER
 	{
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out RTS Frame Failed\n"));
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))) {
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("Bulk Out RTS Frame Failed\n"));
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
+			pAd->bulkResetPipeid =
+			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
 			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-		else
-		{
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
+						NULL, 0);
+		} else {
 			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
 		}
 	}
@@ -386,44 +389,40 @@ static void rtusb_rts_frame_done_tasklet
 	// The protectioon of rest bulk should be in BulkOut routine
 	RTUSBKickBulkOut(pAd);
 
-
 }
 
-
 static void rtusb_pspoll_frame_done_tasklet(unsigned long data)
 {
-	PRTMP_ADAPTER	pAd;
-	PTX_CONTEXT		pPsPollContext;
-	purbb_t			pUrb;
-	NTSTATUS		Status;
-
-
-
-	pUrb			= (purbb_t)data;
-	pPsPollContext	= (PTX_CONTEXT)pUrb->context;
-	pAd				= pPsPollContext->pAd;
-	Status			= pUrb->status;
+	PRTMP_ADAPTER pAd;
+	PTX_CONTEXT pPsPollContext;
+	purbb_t pUrb;
+	NTSTATUS Status;
+
+	pUrb = (purbb_t) data;
+	pPsPollContext = (PTX_CONTEXT) pUrb->context;
+	pAd = pPsPollContext->pAd;
+	Status = pUrb->status;
 
 	// Reset PsPoll context flags
-	pPsPollContext->IRPPending	= FALSE;
-	pPsPollContext->InUse		= FALSE;
+	pPsPollContext->IRPPending = FALSE;
+	pPsPollContext->InUse = FALSE;
 	pAd->watchDogTxPendingCnt[0] = 0;
 
-	if (Status == USB_ST_NOERROR)
-	{
+	if (Status == USB_ST_NOERROR) {
 		RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-	}
-	else // STATUS_OTHER
+	} else			// STATUS_OTHER
 	{
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out PSPoll Failed\n"));
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))) {
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("Bulk Out PSPoll Failed\n"));
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
+			pAd->bulkResetPipeid =
+			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
+						NULL, 0);
 		}
 	}
 
@@ -437,7 +436,6 @@ static void rtusb_pspoll_frame_done_task
 
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -454,18 +452,17 @@ Note:
 */
 static void rx_done_tasklet(unsigned long data)
 {
-	purbb_t				pUrb;
-	PRX_CONTEXT			pRxContext;
-	PRTMP_ADAPTER		pAd;
-	NTSTATUS			Status;
-	unsigned int		IrqFlags;
-
-	pUrb		= (purbb_t)data;
-	pRxContext	= (PRX_CONTEXT)pUrb->context;
-	pAd		= pRxContext->pAd;
+	purbb_t pUrb;
+	PRX_CONTEXT pRxContext;
+	PRTMP_ADAPTER pAd;
+	NTSTATUS Status;
+	unsigned int IrqFlags;
+
+	pUrb = (purbb_t) data;
+	pRxContext = (PRX_CONTEXT) pUrb->context;
+	pAd = pRxContext->pAd;
 	Status = pUrb->status;
 
-
 	RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
 	pRxContext->InUse = FALSE;
 	pRxContext->IRPPending = FALSE;
@@ -473,8 +470,7 @@ static void rx_done_tasklet(unsigned lon
 	//NdisInterlockedDecrement(&pAd->PendingRx);
 	pAd->PendingRx--;
 
-	if (Status == USB_ST_NOERROR)
-	{
+	if (Status == USB_ST_NOERROR) {
 		pAd->BulkInComplete++;
 		pAd->NextRxBulkInPosition = 0;
 		if (pRxContext->BulkInOffset)	// As jan's comment, it may bulk-in success but size is zero.
@@ -483,8 +479,7 @@ static void rx_done_tasklet(unsigned lon
 			INC_RING_INDEX(pAd->NextRxBulkInIndex, RX_RING_SIZE);
 		}
 		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-	}
-	else	 // STATUS_OTHER
+	} else			// STATUS_OTHER
 	{
 		pAd->BulkInCompleteFail++;
 		// Still read this packet although it may comtain wrong bytes.
@@ -493,16 +488,19 @@ static void rx_done_tasklet(unsigned lon
 
 		// Parsing all packets. because after reset, the index will reset to all zero.
 		if ((!RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-									fRTMP_ADAPTER_BULKIN_RESET |
-									fRTMP_ADAPTER_HALT_IN_PROGRESS |
-									fRTMP_ADAPTER_NIC_NOT_EXIST))))
-		{
-
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk In Failed. Status=%d, BIIdx=0x%x, BIRIdx=0x%x, actual_length= 0x%x\n",
-							Status, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex, pRxContext->pUrb->actual_length));
+					   fRTMP_ADAPTER_BULKIN_RESET |
+					   fRTMP_ADAPTER_HALT_IN_PROGRESS |
+					   fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
+
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("Bulk In Failed. Status=%d, BIIdx=0x%x, BIRIdx=0x%x, actual_length= 0x%x\n",
+				      Status, pAd->NextRxBulkInIndex,
+				      pAd->NextRxBulkInReadIndex,
+				      pRxContext->pUrb->actual_length));
 
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_IN, NULL, 0);
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_IN,
+						NULL, 0);
 		}
 	}
 
@@ -510,46 +508,43 @@ static void rx_done_tasklet(unsigned lon
 
 	RTUSBBulkReceive(pAd);
 
-
 	return;
 
 }
 
-
 static void rtusb_mgmt_dma_done_tasklet(unsigned long data)
 {
-	PRTMP_ADAPTER	pAd;
-	PTX_CONTEXT		pMLMEContext;
-	int				index;
-	PNDIS_PACKET	pPacket;
-	purbb_t			pUrb;
-	NTSTATUS		Status;
-	unsigned long	IrqFlags;
-
-
-	pUrb			= (purbb_t)data;
-	pMLMEContext	= (PTX_CONTEXT)pUrb->context;
-	pAd			= pMLMEContext->pAd;
-	Status			= pUrb->status;
-	index			= pMLMEContext->SelfIdx;
+	PRTMP_ADAPTER pAd;
+	PTX_CONTEXT pMLMEContext;
+	int index;
+	PNDIS_PACKET pPacket;
+	purbb_t pUrb;
+	NTSTATUS Status;
+	unsigned long IrqFlags;
+
+	pUrb = (purbb_t) data;
+	pMLMEContext = (PTX_CONTEXT) pUrb->context;
+	pAd = pMLMEContext->pAd;
+	Status = pUrb->status;
+	index = pMLMEContext->SelfIdx;
 
 	ASSERT((pAd->MgmtRing.TxDmaIdx == index));
 
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
 
-
-	if (Status != USB_ST_NOERROR)
-	{
+	if (Status != USB_ST_NOERROR) {
 		//Bulk-Out fail status handle
 		if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
-			(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR, ("Bulk Out MLME Failed, Status=%d!\n", Status));
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&
+		    (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))) {
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("Bulk Out MLME Failed, Status=%d!\n",
+				      Status));
 			// TODO: How to handle about the MLMEBulkOut failed issue. Need to resend the mgmt pkt?
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
+			pAd->bulkResetPipeid =
+			    (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
 		}
 	}
 
@@ -576,163 +571,141 @@ static void rtusb_mgmt_dma_done_tasklet(
 		RTMPFreeNdisPacket(pAd, pPacket);
 
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-								fRTMP_ADAPTER_HALT_IN_PROGRESS |
-								fRTMP_ADAPTER_NIC_NOT_EXIST))))
-	{
+				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
+				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
 		// do nothing and return directly.
-	}
-	else
-	{
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET) &&
-			((pAd->bulkResetPipeid & BULKOUT_MGMT_RESET_FLAG) == BULKOUT_MGMT_RESET_FLAG))
-		{	// For Mgmt Bulk-Out failed, ignore it now.
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-		else
-		{
+	} else {
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET) && ((pAd->bulkResetPipeid & BULKOUT_MGMT_RESET_FLAG) == BULKOUT_MGMT_RESET_FLAG)) {	// For Mgmt Bulk-Out failed, ignore it now.
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
+						NULL, 0);
+		} else {
 
 			// Always call Bulk routine, even reset bulk.
 			// The protectioon of rest bulk should be in BulkOut routine
-			if (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE /* pMLMEContext->bWaitingBulkOut == TRUE */)
-			{
+			if (pAd->MgmtRing.TxSwFreeIdx <
+			    MGMT_RING_SIZE
+			    /* pMLMEContext->bWaitingBulkOut == TRUE */ ) {
 				RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
 			}
-				RTUSBKickBulkOut(pAd);
-			}
+			RTUSBKickBulkOut(pAd);
 		}
-
+	}
 
 }
 
 static void rtusb_ac3_dma_done_tasklet(unsigned long data)
 {
-	PRTMP_ADAPTER		pAd;
-	PHT_TX_CONTEXT		pHTTXContext;
-	UCHAR				BulkOutPipeId = 3;
-	purbb_t				pUrb;
-
-
-	pUrb			= (purbb_t)data;
-	pHTTXContext	= (PHT_TX_CONTEXT)pUrb->context;
-	pAd				= pHTTXContext->pAd;
+	PRTMP_ADAPTER pAd;
+	PHT_TX_CONTEXT pHTTXContext;
+	UCHAR BulkOutPipeId = 3;
+	purbb_t pUrb;
+
+	pUrb = (purbb_t) data;
+	pHTTXContext = (PHT_TX_CONTEXT) pUrb->context;
+	pAd = pHTTXContext->pAd;
 
 	rtusb_dataout_complete((unsigned long)pUrb);
 
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-								fRTMP_ADAPTER_HALT_IN_PROGRESS |
-								fRTMP_ADAPTER_NIC_NOT_EXIST))))
-	{
+				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
+				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
 		// do nothing and return directly.
-	}
-	else
-	{
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))
-		{
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-		else
-		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+	} else {
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
+						NULL, 0);
+		} else {
+			pHTTXContext = &pAd->TxContext[BulkOutPipeId];
 			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) &&
-				/*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
-				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
-				(pHTTXContext->bCurWriting == FALSE))
-			{
-				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId, MAX_TX_PROCESS);
+			    /*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
+			    (pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
+			    (pHTTXContext->bCurWriting == FALSE)) {
+				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId,
+						  MAX_TX_PROCESS);
 			}
 
-			RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL<<3);
+			RTUSB_SET_BULK_FLAG(pAd,
+					    fRTUSB_BULK_OUT_DATA_NORMAL << 3);
 			RTUSBKickBulkOut(pAd);
 		}
 	}
 
-
 	return;
 }
 
-
 static void rtusb_ac2_dma_done_tasklet(unsigned long data)
 {
-	PRTMP_ADAPTER		pAd;
-	PHT_TX_CONTEXT		pHTTXContext;
-	UCHAR				BulkOutPipeId = 2;
-	purbb_t				pUrb;
-
-
-	pUrb			= (purbb_t)data;
-	pHTTXContext	= (PHT_TX_CONTEXT)pUrb->context;
-	pAd				= pHTTXContext->pAd;
+	PRTMP_ADAPTER pAd;
+	PHT_TX_CONTEXT pHTTXContext;
+	UCHAR BulkOutPipeId = 2;
+	purbb_t pUrb;
+
+	pUrb = (purbb_t) data;
+	pHTTXContext = (PHT_TX_CONTEXT) pUrb->context;
+	pAd = pHTTXContext->pAd;
 
 	rtusb_dataout_complete((unsigned long)pUrb);
 
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-								fRTMP_ADAPTER_HALT_IN_PROGRESS |
-								fRTMP_ADAPTER_NIC_NOT_EXIST))))
-	{
+				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
+				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
 		// do nothing and return directly.
-	}
-	else
-	{
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))
-		{
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-		else
-		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+	} else {
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
+						NULL, 0);
+		} else {
+			pHTTXContext = &pAd->TxContext[BulkOutPipeId];
 			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) &&
-				/*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
-				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
-				(pHTTXContext->bCurWriting == FALSE))
-			{
-				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId, MAX_TX_PROCESS);
+			    /*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
+			    (pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
+			    (pHTTXContext->bCurWriting == FALSE)) {
+				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId,
+						  MAX_TX_PROCESS);
 			}
 
-			RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL<<2);
+			RTUSB_SET_BULK_FLAG(pAd,
+					    fRTUSB_BULK_OUT_DATA_NORMAL << 2);
 			RTUSBKickBulkOut(pAd);
 		}
 	}
 
-
 	return;
 }
 
-
 static void rtusb_ac1_dma_done_tasklet(unsigned long data)
 {
-	PRTMP_ADAPTER		pAd;
-	PHT_TX_CONTEXT		pHTTXContext;
-	UCHAR				BulkOutPipeId = 1;
-	purbb_t				pUrb;
-
-
-	pUrb			= (purbb_t)data;
-	pHTTXContext	= (PHT_TX_CONTEXT)pUrb->context;
-	pAd				= pHTTXContext->pAd;
+	PRTMP_ADAPTER pAd;
+	PHT_TX_CONTEXT pHTTXContext;
+	UCHAR BulkOutPipeId = 1;
+	purbb_t pUrb;
+
+	pUrb = (purbb_t) data;
+	pHTTXContext = (PHT_TX_CONTEXT) pUrb->context;
+	pAd = pHTTXContext->pAd;
 
 	rtusb_dataout_complete((unsigned long)pUrb);
 
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-								fRTMP_ADAPTER_HALT_IN_PROGRESS |
-								fRTMP_ADAPTER_NIC_NOT_EXIST))))
-	{
+				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
+				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
 		// do nothing and return directly.
-	}
-	else
-	{
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))
-		{
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-		else
-		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+	} else {
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
+						NULL, 0);
+		} else {
+			pHTTXContext = &pAd->TxContext[BulkOutPipeId];
 			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) &&
-				/*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
-				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
-				(pHTTXContext->bCurWriting == FALSE))
-			{
-				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId, MAX_TX_PROCESS);
+			    /*((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
+			    (pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
+			    (pHTTXContext->bCurWriting == FALSE)) {
+				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId,
+						  MAX_TX_PROCESS);
 			}
 
-			RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL<<1);
+			RTUSB_SET_BULK_FLAG(pAd,
+					    fRTUSB_BULK_OUT_DATA_NORMAL << 1);
 			RTUSBKickBulkOut(pAd);
 		}
 	}
@@ -740,41 +713,35 @@ static void rtusb_ac1_dma_done_tasklet(u
 
 }
 
-
 static void rtusb_ac0_dma_done_tasklet(unsigned long data)
 {
-	PRTMP_ADAPTER		pAd;
-	PHT_TX_CONTEXT		pHTTXContext;
-	UCHAR				BulkOutPipeId = 0;
-	purbb_t				pUrb;
-
-
-	pUrb			= (purbb_t)data;
-	pHTTXContext	= (PHT_TX_CONTEXT)pUrb->context;
-	pAd				= pHTTXContext->pAd;
+	PRTMP_ADAPTER pAd;
+	PHT_TX_CONTEXT pHTTXContext;
+	UCHAR BulkOutPipeId = 0;
+	purbb_t pUrb;
+
+	pUrb = (purbb_t) data;
+	pHTTXContext = (PHT_TX_CONTEXT) pUrb->context;
+	pAd = pHTTXContext->pAd;
 
 	rtusb_dataout_complete((unsigned long)pUrb);
 
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-								fRTMP_ADAPTER_HALT_IN_PROGRESS |
-								fRTMP_ADAPTER_NIC_NOT_EXIST))))
-	{
+				  fRTMP_ADAPTER_HALT_IN_PROGRESS |
+				  fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
 		// do nothing and return directly.
-	}
-	else
-	{
-		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET))
-		{
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT, NULL, 0);
-		}
-		else
-		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+	} else {
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET)) {
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_OUT,
+						NULL, 0);
+		} else {
+			pHTTXContext = &pAd->TxContext[BulkOutPipeId];
 			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) &&
-				/*  ((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
-				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
-				(pHTTXContext->bCurWriting == FALSE))
-			{
-				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId, MAX_TX_PROCESS);
+			    /*  ((pHTTXContext->CurWritePosition > (pHTTXContext->NextBulkOutPosition + 0x6000)) || (pHTTXContext->NextBulkOutPosition > pHTTXContext->CurWritePosition + 0x6000)) && */
+			    (pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
+			    (pHTTXContext->bCurWriting == FALSE)) {
+				RTMPDeQueuePacket(pAd, FALSE, BulkOutPipeId,
+						  MAX_TX_PROCESS);
 			}
 
 			RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL);
@@ -782,34 +749,38 @@ static void rtusb_ac0_dma_done_tasklet(u
 		}
 	}
 
-
 	return;
 
 }
 
-
-NDIS_STATUS RtmpNetTaskInit(
-	IN RTMP_ADAPTER *pAd)
+NDIS_STATUS RtmpNetTaskInit(IN RTMP_ADAPTER * pAd)
 {
 	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	// Create receive tasklet
-	tasklet_init(&pObj->rx_done_task, rx_done_tasklet, (ULONG)pAd);
-	tasklet_init(&pObj->mgmt_dma_done_task, rtusb_mgmt_dma_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->ac0_dma_done_task, rtusb_ac0_dma_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->ac1_dma_done_task, rtusb_ac1_dma_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->ac2_dma_done_task, rtusb_ac2_dma_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->ac3_dma_done_task, rtusb_ac3_dma_done_tasklet, (unsigned long)pAd);
+	tasklet_init(&pObj->rx_done_task, rx_done_tasklet, (ULONG) pAd);
+	tasklet_init(&pObj->mgmt_dma_done_task, rtusb_mgmt_dma_done_tasklet,
+		     (unsigned long)pAd);
+	tasklet_init(&pObj->ac0_dma_done_task, rtusb_ac0_dma_done_tasklet,
+		     (unsigned long)pAd);
+	tasklet_init(&pObj->ac1_dma_done_task, rtusb_ac1_dma_done_tasklet,
+		     (unsigned long)pAd);
+	tasklet_init(&pObj->ac2_dma_done_task, rtusb_ac2_dma_done_tasklet,
+		     (unsigned long)pAd);
+	tasklet_init(&pObj->ac3_dma_done_task, rtusb_ac3_dma_done_tasklet,
+		     (unsigned long)pAd);
 	tasklet_init(&pObj->tbtt_task, tbtt_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->null_frame_complete_task, rtusb_null_frame_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->rts_frame_complete_task, rtusb_rts_frame_done_tasklet, (unsigned long)pAd);
-	tasklet_init(&pObj->pspoll_frame_complete_task, rtusb_pspoll_frame_done_tasklet, (unsigned long)pAd);
+	tasklet_init(&pObj->null_frame_complete_task,
+		     rtusb_null_frame_done_tasklet, (unsigned long)pAd);
+	tasklet_init(&pObj->rts_frame_complete_task,
+		     rtusb_rts_frame_done_tasklet, (unsigned long)pAd);
+	tasklet_init(&pObj->pspoll_frame_complete_task,
+		     rtusb_pspoll_frame_done_tasklet, (unsigned long)pAd);
 
 	return NDIS_STATUS_SUCCESS;
 }
 
-
-void RtmpNetTaskExit(IN RTMP_ADAPTER *pAd)
+void RtmpNetTaskExit(IN RTMP_ADAPTER * pAd)
 {
 	POS_COOKIE pObj;
 
--- a/drivers/staging/rt2860/sta_ioctl.c
+++ b/drivers/staging/rt2860/sta_ioctl.c
@@ -40,7 +40,7 @@
 #include	"rt_config.h"
 
 #ifdef DBG
-extern ULONG    RTDebugLevel;
+extern ULONG RTDebugLevel;
 #endif
 
 #define NR_WEP_KEYS 				4
@@ -49,235 +49,296 @@ extern ULONG    RTDebugLevel;
 
 #define GROUP_KEY_NO                4
 
-extern UCHAR    CipherWpa2Template[];
+extern UCHAR CipherWpa2Template[];
 
-typedef struct PACKED _RT_VERSION_INFO{
-    UCHAR       DriverVersionW;
-    UCHAR       DriverVersionX;
-    UCHAR       DriverVersionY;
-    UCHAR       DriverVersionZ;
-    UINT        DriverBuildYear;
-    UINT        DriverBuildMonth;
-    UINT        DriverBuildDay;
+typedef struct PACKED _RT_VERSION_INFO {
+	UCHAR DriverVersionW;
+	UCHAR DriverVersionX;
+	UCHAR DriverVersionY;
+	UCHAR DriverVersionZ;
+	UINT DriverBuildYear;
+	UINT DriverBuildMonth;
+	UINT DriverBuildDay;
 } RT_VERSION_INFO, *PRT_VERSION_INFO;
 
-static __s32 ralinkrate[] =
-	{2,  4,   11,  22, // CCK
-	12, 18,   24,  36, 48, 72, 96, 108, // OFDM
-	13, 26,   39,  52,  78, 104, 117, 130, 26,  52,  78, 104, 156, 208, 234, 260, // 20MHz, 800ns GI, MCS: 0 ~ 15
-	39, 78,  117, 156, 234, 312, 351, 390,										  // 20MHz, 800ns GI, MCS: 16 ~ 23
-	27, 54,   81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540, // 40MHz, 800ns GI, MCS: 0 ~ 15
-	81, 162, 243, 324, 486, 648, 729, 810,										  // 40MHz, 800ns GI, MCS: 16 ~ 23
-	14, 29,   43,  57,  87, 115, 130, 144, 29, 59,   87, 115, 173, 230, 260, 288, // 20MHz, 400ns GI, MCS: 0 ~ 15
-	43, 87,  130, 173, 260, 317, 390, 433,										  // 20MHz, 400ns GI, MCS: 16 ~ 23
-	30, 60,   90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600, // 40MHz, 400ns GI, MCS: 0 ~ 15
-	90, 180, 270, 360, 540, 720, 810, 900};
+static __s32 ralinkrate[] = { 2, 4, 11, 22,	// CCK
+	12, 18, 24, 36, 48, 72, 96, 108,	// OFDM
+	13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260,	// 20MHz, 800ns GI, MCS: 0 ~ 15
+	39, 78, 117, 156, 234, 312, 351, 390,	// 20MHz, 800ns GI, MCS: 16 ~ 23
+	27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,	// 40MHz, 800ns GI, MCS: 0 ~ 15
+	81, 162, 243, 324, 486, 648, 729, 810,	// 40MHz, 800ns GI, MCS: 16 ~ 23
+	14, 29, 43, 57, 87, 115, 130, 144, 29, 59, 87, 115, 173, 230, 260, 288,	// 20MHz, 400ns GI, MCS: 0 ~ 15
+	43, 87, 130, 173, 260, 317, 390, 433,	// 20MHz, 400ns GI, MCS: 16 ~ 23
+	30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,	// 40MHz, 400ns GI, MCS: 0 ~ 15
+	90, 180, 270, 360, 540, 720, 810, 900
+};
 
-INT Set_SSID_Proc(
-    IN  PRTMP_ADAPTER   pAdapter,
-    IN  PSTRING          arg);
+INT Set_SSID_Proc(IN PRTMP_ADAPTER pAdapter, IN PSTRING arg);
 
-INT Set_NetworkType_Proc(
-    IN  PRTMP_ADAPTER   pAdapter,
-    IN  PSTRING          arg);
+INT Set_NetworkType_Proc(IN PRTMP_ADAPTER pAdapter, IN PSTRING arg);
 
-VOID RTMPAddKey(
-	IN	PRTMP_ADAPTER	    pAd,
-	IN	PNDIS_802_11_KEY    pKey)
+VOID RTMPAddKey(IN PRTMP_ADAPTER pAd, IN PNDIS_802_11_KEY pKey)
 {
-	ULONG				KeyIdx;
-	MAC_TABLE_ENTRY  	*pEntry;
+	ULONG KeyIdx;
+	MAC_TABLE_ENTRY *pEntry;
 
-    DBGPRINT(RT_DEBUG_TRACE, ("RTMPAddKey ------>\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("RTMPAddKey ------>\n"));
+
+	if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
+		if (pKey->KeyIndex & 0x80000000) {
+			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
+				NdisZeroMemory(pAd->StaCfg.PMK, 32);
+				NdisMoveMemory(pAd->StaCfg.PMK,
+					       pKey->KeyMaterial,
+					       pKey->KeyLength);
+				goto end;
+			}
+			// Update PTK
+			NdisZeroMemory(&pAd->SharedKey[BSS0][0],
+				       sizeof(CIPHER_KEY));
+			pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
+			NdisMoveMemory(pAd->SharedKey[BSS0][0].Key,
+				       pKey->KeyMaterial, LEN_TKIP_EK);
+
+			if (pAd->StaCfg.PairCipher ==
+			    Ndis802_11Encryption2Enabled) {
+				NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic,
+					       pKey->KeyMaterial + LEN_TKIP_EK,
+					       LEN_TKIP_TXMICK);
+				NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic,
+					       pKey->KeyMaterial + LEN_TKIP_EK +
+					       LEN_TKIP_TXMICK,
+					       LEN_TKIP_RXMICK);
+			} else {
+				NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic,
+					       pKey->KeyMaterial + LEN_TKIP_EK,
+					       LEN_TKIP_TXMICK);
+				NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic,
+					       pKey->KeyMaterial + LEN_TKIP_EK +
+					       LEN_TKIP_TXMICK,
+					       LEN_TKIP_RXMICK);
+			}
+
+			// Decide its ChiperAlg
+			if (pAd->StaCfg.PairCipher ==
+			    Ndis802_11Encryption2Enabled)
+				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
+			else if (pAd->StaCfg.PairCipher ==
+				 Ndis802_11Encryption3Enabled)
+				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
+			else
+				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_NONE;
 
-	if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
-	{
-		if (pKey->KeyIndex & 0x80000000)
-		{
-		    if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
-            {
-                NdisZeroMemory(pAd->StaCfg.PMK, 32);
-                NdisMoveMemory(pAd->StaCfg.PMK, pKey->KeyMaterial, pKey->KeyLength);
-                goto end;
-            }
-		    // Update PTK
-		    NdisZeroMemory(&pAd->SharedKey[BSS0][0], sizeof(CIPHER_KEY));
-            pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
-            NdisMoveMemory(pAd->SharedKey[BSS0][0].Key, pKey->KeyMaterial, LEN_TKIP_EK);
-
-            if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
-            {
-                NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic, pKey->KeyMaterial + LEN_TKIP_EK, LEN_TKIP_TXMICK);
-                NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic, pKey->KeyMaterial + LEN_TKIP_EK + LEN_TKIP_TXMICK, LEN_TKIP_RXMICK);
-            }
-            else
-            {
-            	NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic, pKey->KeyMaterial + LEN_TKIP_EK, LEN_TKIP_TXMICK);
-                NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic, pKey->KeyMaterial + LEN_TKIP_EK + LEN_TKIP_TXMICK, LEN_TKIP_RXMICK);
-            }
-
-            // Decide its ChiperAlg
-        	if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
-        		pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
-        	else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
-        		pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
-        	else
-        		pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_NONE;
-
-            // Update these related information to MAC_TABLE_ENTRY
-        	pEntry = &pAd->MacTab.Content[BSSID_WCID];
-            NdisMoveMemory(pEntry->PairwiseKey.Key, pAd->SharedKey[BSS0][0].Key, LEN_TKIP_EK);
-        	NdisMoveMemory(pEntry->PairwiseKey.RxMic, pAd->SharedKey[BSS0][0].RxMic, LEN_TKIP_RXMICK);
-        	NdisMoveMemory(pEntry->PairwiseKey.TxMic, pAd->SharedKey[BSS0][0].TxMic, LEN_TKIP_TXMICK);
-        	pEntry->PairwiseKey.CipherAlg = pAd->SharedKey[BSS0][0].CipherAlg;
-
-        	// Update pairwise key information to ASIC Shared Key Table
-        	AsicAddSharedKeyEntry(pAd,
-        						  BSS0,
-        						  0,
-        						  pAd->SharedKey[BSS0][0].CipherAlg,
-        						  pAd->SharedKey[BSS0][0].Key,
-        						  pAd->SharedKey[BSS0][0].TxMic,
-        						  pAd->SharedKey[BSS0][0].RxMic);
-
-        	// Update ASIC WCID attribute table and IVEIV table
-        	RTMPAddWcidAttributeEntry(pAd,
-        							  BSS0,
-        							  0,
-        							  pAd->SharedKey[BSS0][0].CipherAlg,
-        							  pEntry);
-
-            if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
-            {
-                // set 802.1x port control
-	            //pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+			// Update these related information to MAC_TABLE_ENTRY
+			pEntry = &pAd->MacTab.Content[BSSID_WCID];
+			NdisMoveMemory(pEntry->PairwiseKey.Key,
+				       pAd->SharedKey[BSS0][0].Key,
+				       LEN_TKIP_EK);
+			NdisMoveMemory(pEntry->PairwiseKey.RxMic,
+				       pAd->SharedKey[BSS0][0].RxMic,
+				       LEN_TKIP_RXMICK);
+			NdisMoveMemory(pEntry->PairwiseKey.TxMic,
+				       pAd->SharedKey[BSS0][0].TxMic,
+				       LEN_TKIP_TXMICK);
+			pEntry->PairwiseKey.CipherAlg =
+			    pAd->SharedKey[BSS0][0].CipherAlg;
+
+			// Update pairwise key information to ASIC Shared Key Table
+			AsicAddSharedKeyEntry(pAd,
+					      BSS0,
+					      0,
+					      pAd->SharedKey[BSS0][0].CipherAlg,
+					      pAd->SharedKey[BSS0][0].Key,
+					      pAd->SharedKey[BSS0][0].TxMic,
+					      pAd->SharedKey[BSS0][0].RxMic);
+
+			// Update ASIC WCID attribute table and IVEIV table
+			RTMPAddWcidAttributeEntry(pAd,
+						  BSS0,
+						  0,
+						  pAd->SharedKey[BSS0][0].
+						  CipherAlg, pEntry);
+
+			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2) {
+				// set 802.1x port control
+				//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAd);
 
-                // Indicate Connected for GUI
-                pAd->IndicateMediaState = NdisMediaStateConnected;
-            }
-		}
-        else
-        {
-            // Update GTK
-            pAd->StaCfg.DefaultKeyId = (pKey->KeyIndex & 0xFF);
-            NdisZeroMemory(&pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId], sizeof(CIPHER_KEY));
-            pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen = LEN_TKIP_EK;
-            NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].Key, pKey->KeyMaterial, LEN_TKIP_EK);
-
-            if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
-            {
-                NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].RxMic, pKey->KeyMaterial + LEN_TKIP_EK, LEN_TKIP_TXMICK);
-                NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].TxMic, pKey->KeyMaterial + LEN_TKIP_EK + LEN_TKIP_TXMICK, LEN_TKIP_RXMICK);
-            }
-            else
-            {
-            	NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].TxMic, pKey->KeyMaterial + LEN_TKIP_EK, LEN_TKIP_TXMICK);
-                NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].RxMic, pKey->KeyMaterial + LEN_TKIP_EK + LEN_TKIP_TXMICK, LEN_TKIP_RXMICK);
-            }
-
-            // Update Shared Key CipherAlg
-    		pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg = CIPHER_NONE;
-    		if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
-    			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg = CIPHER_TKIP;
-    		else if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
-    			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg = CIPHER_AES;
-
-            // Update group key information to ASIC Shared Key Table
-        	AsicAddSharedKeyEntry(pAd,
-        						  BSS0,
-        						  pAd->StaCfg.DefaultKeyId,
-        						  pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg,
-        						  pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].Key,
-        						  pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].TxMic,
-        						  pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].RxMic);
-
-        	// Update ASIC WCID attribute table and IVEIV table
-        	RTMPAddWcidAttributeEntry(pAd,
-        							  BSS0,
-        							  pAd->StaCfg.DefaultKeyId,
-        							  pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg,
-        							  NULL);
+				// Indicate Connected for GUI
+				pAd->IndicateMediaState =
+				    NdisMediaStateConnected;
+			}
+		} else {
+			// Update GTK
+			pAd->StaCfg.DefaultKeyId = (pKey->KeyIndex & 0xFF);
+			NdisZeroMemory(&pAd->
+				       SharedKey[BSS0][pAd->StaCfg.
+						       DefaultKeyId],
+				       sizeof(CIPHER_KEY));
+			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen =
+			    LEN_TKIP_EK;
+			NdisMoveMemory(pAd->
+				       SharedKey[BSS0][pAd->StaCfg.
+						       DefaultKeyId].Key,
+				       pKey->KeyMaterial, LEN_TKIP_EK);
+
+			if (pAd->StaCfg.GroupCipher ==
+			    Ndis802_11Encryption2Enabled) {
+				NdisMoveMemory(pAd->
+					       SharedKey[BSS0][pAd->StaCfg.
+							       DefaultKeyId].
+					       RxMic,
+					       pKey->KeyMaterial + LEN_TKIP_EK,
+					       LEN_TKIP_TXMICK);
+				NdisMoveMemory(pAd->
+					       SharedKey[BSS0][pAd->StaCfg.
+							       DefaultKeyId].
+					       TxMic,
+					       pKey->KeyMaterial + LEN_TKIP_EK +
+					       LEN_TKIP_TXMICK,
+					       LEN_TKIP_RXMICK);
+			} else {
+				NdisMoveMemory(pAd->
+					       SharedKey[BSS0][pAd->StaCfg.
+							       DefaultKeyId].
+					       TxMic,
+					       pKey->KeyMaterial + LEN_TKIP_EK,
+					       LEN_TKIP_TXMICK);
+				NdisMoveMemory(pAd->
+					       SharedKey[BSS0][pAd->StaCfg.
+							       DefaultKeyId].
+					       RxMic,
+					       pKey->KeyMaterial + LEN_TKIP_EK +
+					       LEN_TKIP_TXMICK,
+					       LEN_TKIP_RXMICK);
+			}
+
+			// Update Shared Key CipherAlg
+			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].
+			    CipherAlg = CIPHER_NONE;
+			if (pAd->StaCfg.GroupCipher ==
+			    Ndis802_11Encryption2Enabled)
+				pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].
+				    CipherAlg = CIPHER_TKIP;
+			else if (pAd->StaCfg.GroupCipher ==
+				 Ndis802_11Encryption3Enabled)
+				pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].
+				    CipherAlg = CIPHER_AES;
+
+			// Update group key information to ASIC Shared Key Table
+			AsicAddSharedKeyEntry(pAd,
+					      BSS0,
+					      pAd->StaCfg.DefaultKeyId,
+					      pAd->SharedKey[BSS0][pAd->StaCfg.
+								   DefaultKeyId].
+					      CipherAlg,
+					      pAd->SharedKey[BSS0][pAd->StaCfg.
+								   DefaultKeyId].
+					      Key,
+					      pAd->SharedKey[BSS0][pAd->StaCfg.
+								   DefaultKeyId].
+					      TxMic,
+					      pAd->SharedKey[BSS0][pAd->StaCfg.
+								   DefaultKeyId].
+					      RxMic);
 
-            // set 802.1x port control
-	        //pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+			// Update ASIC WCID attribute table and IVEIV table
+			RTMPAddWcidAttributeEntry(pAd,
+						  BSS0,
+						  pAd->StaCfg.DefaultKeyId,
+						  pAd->SharedKey[BSS0][pAd->
+								       StaCfg.
+								       DefaultKeyId].
+						  CipherAlg, NULL);
+
+			// set 802.1x port control
+			//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 			STA_PORT_SECURED(pAd);
 
-            // Indicate Connected for GUI
-            pAd->IndicateMediaState = NdisMediaStateConnected;
-        }
-	}
-	else	// dynamic WEP from wpa_supplicant
+			// Indicate Connected for GUI
+			pAd->IndicateMediaState = NdisMediaStateConnected;
+		}
+	} else			// dynamic WEP from wpa_supplicant
 	{
-		UCHAR	CipherAlg;
-    	PUCHAR	Key;
+		UCHAR CipherAlg;
+		PUCHAR Key;
 
-		if(pKey->KeyLength == 32)
+		if (pKey->KeyLength == 32)
 			goto end;
 
 		KeyIdx = pKey->KeyIndex & 0x0fffffff;
 
-		if (KeyIdx < 4)
-		{
+		if (KeyIdx < 4) {
 			// it is a default shared key, for Pairwise key setting
-			if (pKey->KeyIndex & 0x80000000)
-			{
+			if (pKey->KeyIndex & 0x80000000) {
 				pEntry = MacTableLookup(pAd, pKey->BSSID);
 
-				if (pEntry)
-				{
-					DBGPRINT(RT_DEBUG_TRACE, ("RTMPAddKey: Set Pair-wise Key\n"));
+				if (pEntry) {
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("RTMPAddKey: Set Pair-wise Key\n"));
 
 					// set key material and key length
- 					pEntry->PairwiseKey.KeyLen = (UCHAR)pKey->KeyLength;
-					NdisMoveMemory(pEntry->PairwiseKey.Key, &pKey->KeyMaterial, pKey->KeyLength);
+					pEntry->PairwiseKey.KeyLen =
+					    (UCHAR) pKey->KeyLength;
+					NdisMoveMemory(pEntry->PairwiseKey.Key,
+						       &pKey->KeyMaterial,
+						       pKey->KeyLength);
 
 					// set Cipher type
 					if (pKey->KeyLength == 5)
-						pEntry->PairwiseKey.CipherAlg = CIPHER_WEP64;
+						pEntry->PairwiseKey.CipherAlg =
+						    CIPHER_WEP64;
 					else
-						pEntry->PairwiseKey.CipherAlg = CIPHER_WEP128;
+						pEntry->PairwiseKey.CipherAlg =
+						    CIPHER_WEP128;
 
 					// Add Pair-wise key to Asic
-					AsicAddPairwiseKeyEntry(
-						pAd,
-						pEntry->Addr,
-						(UCHAR)pEntry->Aid,
-                		&pEntry->PairwiseKey);
+					AsicAddPairwiseKeyEntry(pAd,
+								pEntry->Addr,
+								(UCHAR) pEntry->
+								Aid,
+								&pEntry->
+								PairwiseKey);
 
 					// update WCID attribute table and IVEIV table for this entry
-					RTMPAddWcidAttributeEntry(
-						pAd,
-						BSS0,
-						KeyIdx, // The value may be not zero
-						pEntry->PairwiseKey.CipherAlg,
-						pEntry);
+					RTMPAddWcidAttributeEntry(pAd, BSS0, KeyIdx,	// The value may be not zero
+								  pEntry->
+								  PairwiseKey.
+								  CipherAlg,
+								  pEntry);
 
 				}
-			}
-			else
-            {
+			} else {
 				// Default key for tx (shared key)
 				pAd->StaCfg.DefaultKeyId = (UCHAR) KeyIdx;
 
 				// set key material and key length
-				pAd->SharedKey[BSS0][KeyIdx].KeyLen = (UCHAR) pKey->KeyLength;
-				NdisMoveMemory(pAd->SharedKey[BSS0][KeyIdx].Key, &pKey->KeyMaterial, pKey->KeyLength);
+				pAd->SharedKey[BSS0][KeyIdx].KeyLen =
+				    (UCHAR) pKey->KeyLength;
+				NdisMoveMemory(pAd->SharedKey[BSS0][KeyIdx].Key,
+					       &pKey->KeyMaterial,
+					       pKey->KeyLength);
 
 				// Set Ciper type
 				if (pKey->KeyLength == 5)
-					pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CIPHER_WEP64;
+					pAd->SharedKey[BSS0][KeyIdx].CipherAlg =
+					    CIPHER_WEP64;
 				else
-					pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CIPHER_WEP128;
+					pAd->SharedKey[BSS0][KeyIdx].CipherAlg =
+					    CIPHER_WEP128;
 
-    			CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
-    			Key = pAd->SharedKey[BSS0][KeyIdx].Key;
+				CipherAlg =
+				    pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
+				Key = pAd->SharedKey[BSS0][KeyIdx].Key;
 
 				// Set Group key material to Asic
-    			AsicAddSharedKeyEntry(pAd, BSS0, KeyIdx, CipherAlg, Key, NULL, NULL);
+				AsicAddSharedKeyEntry(pAd, BSS0, KeyIdx,
+						      CipherAlg, Key, NULL,
+						      NULL);
 
 				// Update WCID attribute table and IVEIV table for this group key table
-				RTMPAddWcidAttributeEntry(pAd, BSS0, KeyIdx, CipherAlg, NULL);
+				RTMPAddWcidAttributeEntry(pAd, BSS0, KeyIdx,
+							  CipherAlg, NULL);
 
 			}
 		}
@@ -286,12 +347,12 @@ end:
 	return;
 }
 
-char * rtstrchr(const char * s, int c)
+char *rtstrchr(const char *s, int c)
 {
-    for(; *s != (char) c; ++s)
-        if (*s == '\0')
-            return NULL;
-    return (char *) s;
+	for (; *s != (char)c; ++s)
+		if (*s == '\0')
+			return NULL;
+	return (char *)s;
 }
 
 /*
@@ -300,8 +361,7 @@ This is required for LinEX2004/kernel2.6
 
 int
 rt_ioctl_giwname(struct net_device *dev,
-		   struct iw_request_info *info,
-		   char *name, char *extra)
+		 struct iw_request_info *info, char *name, char *extra)
 {
 	strncpy(name, "Ralink STA", IFNAMSIZ);
 	// RT2870 2.1.0.0 uses "RT2870 Wireless"
@@ -310,89 +370,87 @@ rt_ioctl_giwname(struct net_device *dev,
 }
 
 int rt_ioctl_siwfreq(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_freq *freq, char *extra)
+		     struct iw_request_info *info,
+		     struct iw_freq *freq, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
-	int 	chan = -1;
+	int chan = -1;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-    //check if the interface is down
-    if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-        return -ENETDOWN;
-    }
-
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
 	if (freq->e > 1)
 		return -EINVAL;
 
-	if((freq->e == 0) && (freq->m <= 1000))
+	if ((freq->e == 0) && (freq->m <= 1000))
 		chan = freq->m;	// Setting by channel number
 	else
-		MAP_KHZ_TO_CHANNEL_ID( (freq->m /100) , chan); // Setting by frequency - search the table , like 2.412G, 2.422G,
+		MAP_KHZ_TO_CHANNEL_ID((freq->m / 100), chan);	// Setting by frequency - search the table , like 2.412G, 2.422G,
 
-    if (ChannelSanity(pAdapter, chan) == TRUE)
-    {
-	pAdapter->CommonCfg.Channel = chan;
-	DBGPRINT(RT_DEBUG_ERROR, ("==>rt_ioctl_siwfreq::SIOCSIWFREQ[cmd=0x%x] (Channel=%d)\n", SIOCSIWFREQ, pAdapter->CommonCfg.Channel));
-    }
-    else
-        return -EINVAL;
+	if (ChannelSanity(pAdapter, chan) == TRUE) {
+		pAdapter->CommonCfg.Channel = chan;
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("==>rt_ioctl_siwfreq::SIOCSIWFREQ[cmd=0x%x] (Channel=%d)\n",
+			  SIOCSIWFREQ, pAdapter->CommonCfg.Channel));
+	} else
+		return -EINVAL;
 
 	return 0;
 }
+
 int rt_ioctl_giwfreq(struct net_device *dev,
-		   struct iw_request_info *info,
-		   struct iw_freq *freq, char *extra)
+		     struct iw_request_info *info,
+		     struct iw_freq *freq, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 	UCHAR ch;
-	ULONG	m = 2412000;
+	ULONG m = 2412000;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-		ch = pAdapter->CommonCfg.Channel;
+	ch = pAdapter->CommonCfg.Channel;
 
-	DBGPRINT(RT_DEBUG_TRACE,("==>rt_ioctl_giwfreq  %d\n", ch));
+	DBGPRINT(RT_DEBUG_TRACE, ("==>rt_ioctl_giwfreq  %d\n", ch));
 
-    MAP_CHANNEL_ID_TO_KHZ(ch, m);
+	MAP_CHANNEL_ID_TO_KHZ(ch, m);
 	freq->m = m * 100;
 	freq->e = 1;
 	return 0;
 }
 
 int rt_ioctl_siwmode(struct net_device *dev,
-		   struct iw_request_info *info,
-		   __u32 *mode, char *extra)
+		     struct iw_request_info *info, __u32 * mode, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-    if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    {
-    	DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-       	return -ENETDOWN;
-    }
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
-	switch (*mode)
-	{
-		case IW_MODE_ADHOC:
-			Set_NetworkType_Proc(pAdapter, "Adhoc");
-			break;
-		case IW_MODE_INFRA:
-			Set_NetworkType_Proc(pAdapter, "Infra");
-			break;
-        case IW_MODE_MONITOR:
-			Set_NetworkType_Proc(pAdapter, "Monitor");
-			break;
-		default:
-			DBGPRINT(RT_DEBUG_TRACE, ("===>rt_ioctl_siwmode::SIOCSIWMODE (unknown %d)\n", *mode));
-			return -EINVAL;
+	switch (*mode) {
+	case IW_MODE_ADHOC:
+		Set_NetworkType_Proc(pAdapter, "Adhoc");
+		break;
+	case IW_MODE_INFRA:
+		Set_NetworkType_Proc(pAdapter, "Infra");
+		break;
+	case IW_MODE_MONITOR:
+		Set_NetworkType_Proc(pAdapter, "Monitor");
+		break;
+	default:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("===>rt_ioctl_siwmode::SIOCSIWMODE (unknown %d)\n",
+			  *mode));
+		return -EINVAL;
 	}
 
 	// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
@@ -402,8 +460,7 @@ int rt_ioctl_siwmode(struct net_device *
 }
 
 int rt_ioctl_giwmode(struct net_device *dev,
-		   struct iw_request_info *info,
-		   __u32 *mode, char *extra)
+		     struct iw_request_info *info, __u32 * mode, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
@@ -411,63 +468,57 @@ int rt_ioctl_giwmode(struct net_device *
 
 	if (ADHOC_ON(pAdapter))
 		*mode = IW_MODE_ADHOC;
-    else if (INFRA_ON(pAdapter))
+	else if (INFRA_ON(pAdapter))
 		*mode = IW_MODE_INFRA;
-    else if (MONITOR_ON(pAdapter))
-    {
-        *mode = IW_MODE_MONITOR;
-    }
-    else
-        *mode = IW_MODE_AUTO;
+	else if (MONITOR_ON(pAdapter)) {
+		*mode = IW_MODE_MONITOR;
+	} else
+		*mode = IW_MODE_AUTO;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==>rt_ioctl_giwmode(mode=%d)\n", *mode));
 	return 0;
 }
 
 int rt_ioctl_siwsens(struct net_device *dev,
-		   struct iw_request_info *info,
-		   char *name, char *extra)
+		     struct iw_request_info *info, char *name, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-    	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    	{
-        	DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-        	return -ENETDOWN;
-    	}
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
 	return 0;
 }
 
 int rt_ioctl_giwsens(struct net_device *dev,
-		   struct iw_request_info *info,
-		   char *name, char *extra)
+		     struct iw_request_info *info, char *name, char *extra)
 {
 	return 0;
 }
 
 int rt_ioctl_giwrange(struct net_device *dev,
-		   struct iw_request_info *info,
-		   struct iw_point *data, char *extra)
+		      struct iw_request_info *info,
+		      struct iw_point *data, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
-	struct iw_range *range = (struct iw_range *) extra;
+	struct iw_range *range = (struct iw_range *)extra;
 	u16 val;
 	int i;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	DBGPRINT(RT_DEBUG_TRACE ,("===>rt_ioctl_giwrange\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("===>rt_ioctl_giwrange\n"));
 	data->length = sizeof(struct iw_range);
 	memset(range, 0, sizeof(struct iw_range));
 
 	range->txpower_capa = IW_TXPOW_DBM;
 
-	if (INFRA_ON(pAdapter)||ADHOC_ON(pAdapter))
-	{
+	if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter)) {
 		range->min_pmp = 1 * 1024;
 		range->max_pmp = 65535 * 1024;
 		range->min_pmt = 1 * 1024;
@@ -475,7 +526,7 @@ int rt_ioctl_giwrange(struct net_device 
 		range->pmp_flags = IW_POWER_PERIOD;
 		range->pmt_flags = IW_POWER_TIMEOUT;
 		range->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT |
-			IW_POWER_UNICAST_R | IW_POWER_ALL_R;
+		    IW_POWER_UNICAST_R | IW_POWER_ALL_R;
 	}
 
 	range->we_version_compiled = WIRELESS_EXT;
@@ -486,15 +537,14 @@ int rt_ioctl_giwrange(struct net_device 
 	range->min_retry = 0;
 	range->max_retry = 255;
 
-	range->num_channels =  pAdapter->ChannelListNum;
+	range->num_channels = pAdapter->ChannelListNum;
 
 	val = 0;
-	for (i = 1; i <= range->num_channels; i++)
-	{
+	for (i = 1; i <= range->num_channels; i++) {
 		u32 m = 2412000;
-		range->freq[val].i = pAdapter->ChannelList[i-1].Channel;
-		MAP_CHANNEL_ID_TO_KHZ(pAdapter->ChannelList[i-1].Channel, m);
-		range->freq[val].m = m * 100; /* OS_HZ */
+		range->freq[val].i = pAdapter->ChannelList[i - 1].Channel;
+		MAP_CHANNEL_ID_TO_KHZ(pAdapter->ChannelList[i - 1].Channel, m);
+		range->freq[val].m = m * 100;	/* OS_HZ */
 
 		range->freq[val].e = 1;
 		val++;
@@ -503,11 +553,11 @@ int rt_ioctl_giwrange(struct net_device 
 	}
 	range->num_frequency = val;
 
-	range->max_qual.qual = 100; /* what is correct max? This was not
-					* documented exactly. At least
-					* 69 has been observed. */
-	range->max_qual.level = 0; /* dB */
-	range->max_qual.noise = 0; /* dB */
+	range->max_qual.qual = 100;	/* what is correct max? This was not
+					 * documented exactly. At least
+					 * 69 has been observed. */
+	range->max_qual.level = 0;	/* dB */
+	range->max_qual.noise = 0;	/* dB */
 
 	/* What would be suitable values for "average/typical" qual? */
 	range->avg_qual.qual = 20;
@@ -527,74 +577,68 @@ int rt_ioctl_giwrange(struct net_device 
 
 	/* IW_ENC_CAPA_* bit field */
 	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
-					IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
+	    IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
 
 	return 0;
 }
 
 int rt_ioctl_siwap(struct net_device *dev,
-		      struct iw_request_info *info,
-		      struct sockaddr *ap_addr, char *extra)
+		   struct iw_request_info *info,
+		   struct sockaddr *ap_addr, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
-    NDIS_802_11_MAC_ADDRESS Bssid;
+	NDIS_802_11_MAC_ADDRESS Bssid;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-	{
-       	DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-       	return -ENETDOWN;
-    }
-
-	if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
-    {
-        RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
-        DBGPRINT(RT_DEBUG_TRACE, ("!!! MLME busy, reset MLME state machine !!!\n"));
-    }
-
-    // tell CNTL state machine to call NdisMSetInformationComplete() after completing
-    // this request, because this request is initiated by NDIS.
-    pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
-	// Prevent to connect AP again in STAMlmePeriodicExec
-	pAdapter->MlmeAux.AutoReconnectSsidLen= 32;
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
-    memset(Bssid, 0, MAC_ADDR_LEN);
-    memcpy(Bssid, ap_addr->sa_data, MAC_ADDR_LEN);
-    MlmeEnqueue(pAdapter,
-                MLME_CNTL_STATE_MACHINE,
-                OID_802_11_BSSID,
-                sizeof(NDIS_802_11_MAC_ADDRESS),
-                (VOID *)&Bssid);
+	if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) {
+		RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("!!! MLME busy, reset MLME state machine !!!\n"));
+	}
+	// tell CNTL state machine to call NdisMSetInformationComplete() after completing
+	// this request, because this request is initiated by NDIS.
+	pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
+	// Prevent to connect AP again in STAMlmePeriodicExec
+	pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
 
-    DBGPRINT(RT_DEBUG_TRACE, ("IOCTL::SIOCSIWAP %02x:%02x:%02x:%02x:%02x:%02x\n",
-        Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5]));
+	memset(Bssid, 0, MAC_ADDR_LEN);
+	memcpy(Bssid, ap_addr->sa_data, MAC_ADDR_LEN);
+	MlmeEnqueue(pAdapter,
+		    MLME_CNTL_STATE_MACHINE,
+		    OID_802_11_BSSID,
+		    sizeof(NDIS_802_11_MAC_ADDRESS), (VOID *) & Bssid);
+
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("IOCTL::SIOCSIWAP %02x:%02x:%02x:%02x:%02x:%02x\n", Bssid[0],
+		  Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5]));
 
 	return 0;
 }
 
 int rt_ioctl_giwap(struct net_device *dev,
-		      struct iw_request_info *info,
-		      struct sockaddr *ap_addr, char *extra)
+		   struct iw_request_info *info,
+		   struct sockaddr *ap_addr, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
-	{
+	if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter)) {
 		ap_addr->sa_family = ARPHRD_ETHER;
 		memcpy(ap_addr->sa_data, &pAdapter->CommonCfg.Bssid, ETH_ALEN);
 	}
-    // Add for RT2870
-    else if (pAdapter->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)
-    {
-        ap_addr->sa_family = ARPHRD_ETHER;
-        memcpy(ap_addr->sa_data, &pAdapter->MlmeAux.Bssid, ETH_ALEN);
-    }
-	else
-	{
+	// Add for RT2870
+	else if (pAdapter->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) {
+		ap_addr->sa_family = ARPHRD_ETHER;
+		memcpy(ap_addr->sa_data, &pAdapter->MlmeAux.Bssid, ETH_ALEN);
+	} else {
 		DBGPRINT(RT_DEBUG_TRACE, ("IOCTL::SIOCGIWAP(=EMPTY)\n"));
 		return -ENOTCONN;
 	}
@@ -619,32 +663,31 @@ int rt_ioctl_giwap(struct net_device *de
  *     drivers for compatibility
  */
 static void set_quality(PRTMP_ADAPTER pAdapter,
-                        struct iw_quality *iq,
-                        signed char rssi)
+			struct iw_quality *iq, signed char rssi)
 {
 	__u8 ChannelQuality;
 
 	// Normalize Rssi
 	if (rssi >= -50)
 		ChannelQuality = 100;
-	else if (rssi >= -80) // between -50 ~ -80dbm
-		ChannelQuality = (__u8)(24 + ((rssi + 80) * 26)/10);
-	else if (rssi >= -90)   // between -80 ~ -90dbm
-        ChannelQuality = (__u8)((rssi + 90) * 26)/10;
+	else if (rssi >= -80)	// between -50 ~ -80dbm
+		ChannelQuality = (__u8) (24 + ((rssi + 80) * 26) / 10);
+	else if (rssi >= -90)	// between -80 ~ -90dbm
+		ChannelQuality = (__u8) ((rssi + 90) * 26) / 10;
 	else
 		ChannelQuality = 0;
 
-    iq->qual = (__u8)ChannelQuality;
+	iq->qual = (__u8) ChannelQuality;
 
-    iq->level = (__u8)(rssi);
-    iq->noise = (pAdapter->BbpWriteLatch[66] > pAdapter->BbpTuning.FalseCcaUpperThreshold) ? ((__u8)pAdapter->BbpTuning.FalseCcaUpperThreshold) : ((__u8) pAdapter->BbpWriteLatch[66]); 	// noise level (dBm)
-    iq->noise += 256 - 143;
-    iq->updated = pAdapter->iw_stats.qual.updated;
+	iq->level = (__u8) (rssi);
+	iq->noise = (pAdapter->BbpWriteLatch[66] > pAdapter->BbpTuning.FalseCcaUpperThreshold) ? ((__u8) pAdapter->BbpTuning.FalseCcaUpperThreshold) : ((__u8) pAdapter->BbpWriteLatch[66]);	// noise level (dBm)
+	iq->noise += 256 - 143;
+	iq->updated = pAdapter->iw_stats.qual.updated;
 }
 
 int rt_ioctl_iwaplist(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_point *data, char *extra)
+		      struct iw_request_info *info,
+		      struct iw_point *data, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
@@ -654,91 +697,90 @@ int rt_ioctl_iwaplist(struct net_device 
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-   	//check if the interface is down
-    if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    {
-       	DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		data->length = 0;
 		return 0;
-        //return -ENETDOWN;
+		//return -ENETDOWN;
 	}
 
-	for (i = 0; i <IW_MAX_AP ; i++)
-	{
-		if (i >=  pAdapter->ScanTab.BssNr)
+	for (i = 0; i < IW_MAX_AP; i++) {
+		if (i >= pAdapter->ScanTab.BssNr)
 			break;
 		addr[i].sa_family = ARPHRD_ETHER;
-			memcpy(addr[i].sa_data, &pAdapter->ScanTab.BssEntry[i].Bssid, MAC_ADDR_LEN);
-		set_quality(pAdapter, &qual[i], pAdapter->ScanTab.BssEntry[i].Rssi);
+		memcpy(addr[i].sa_data, &pAdapter->ScanTab.BssEntry[i].Bssid,
+		       MAC_ADDR_LEN);
+		set_quality(pAdapter, &qual[i],
+			    pAdapter->ScanTab.BssEntry[i].Rssi);
 	}
 	data->length = i;
-	memcpy(extra, &addr, i*sizeof(addr[0]));
-	data->flags = 1;		/* signal quality present (sort of) */
-	memcpy(extra + i*sizeof(addr[0]), &qual, i*sizeof(qual[i]));
+	memcpy(extra, &addr, i * sizeof(addr[0]));
+	data->flags = 1;	/* signal quality present (sort of) */
+	memcpy(extra + i * sizeof(addr[0]), &qual, i * sizeof(qual[i]));
 
 	return 0;
 }
 
 int rt_ioctl_siwscan(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_point *data, char *extra)
+		     struct iw_request_info *info,
+		     struct iw_point *data, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
-	ULONG								Now;
+	ULONG Now;
 	int Status = NDIS_STATUS_SUCCESS;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-	{
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
 		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
 		return -ENETDOWN;
 	}
 
-	if (MONITOR_ON(pAdapter))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("!!! Driver is in Monitor Mode now !!!\n"));
-        return -EINVAL;
-    }
-
+	if (MONITOR_ON(pAdapter)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("!!! Driver is in Monitor Mode now !!!\n"));
+		return -EINVAL;
+	}
 
-	if (pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE)
-	{
+	if (pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE) {
 		pAdapter->StaCfg.WpaSupplicantScanCount++;
 	}
 
-    pAdapter->StaCfg.bScanReqIsFromWebUI = TRUE;
+	pAdapter->StaCfg.bScanReqIsFromWebUI = TRUE;
 	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
 		return NDIS_STATUS_SUCCESS;
-	do{
+	do {
 		Now = jiffies;
 
-		if ((pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE) &&
-			(pAdapter->StaCfg.WpaSupplicantScanCount > 3))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("!!! WpaSupplicantScanCount > 3\n"));
+		if ((pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE)
+		    && (pAdapter->StaCfg.WpaSupplicantScanCount > 3)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("!!! WpaSupplicantScanCount > 3\n"));
 			Status = NDIS_STATUS_SUCCESS;
 			break;
 		}
 
-		if ((OPSTATUS_TEST_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED)) &&
-			((pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-			(pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) &&
-			(pAdapter->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("!!! Link UP, Port Not Secured! ignore this set::OID_802_11_BSSID_LIST_SCAN\n"));
+		if ((OPSTATUS_TEST_FLAG
+		     (pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED))
+		    && ((pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
+			|| (pAdapter->StaCfg.AuthMode ==
+			    Ndis802_11AuthModeWPAPSK))
+		    && (pAdapter->StaCfg.PortSecured ==
+			WPA_802_1X_PORT_NOT_SECURED)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("!!! Link UP, Port Not Secured! ignore this set::OID_802_11_BSSID_LIST_SCAN\n"));
 			Status = NDIS_STATUS_SUCCESS;
 			break;
 		}
 
-		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
-		{
+		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) {
 			RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
-			DBGPRINT(RT_DEBUG_TRACE, ("!!! MLME busy, reset MLME state machine !!!\n"));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("!!! MLME busy, reset MLME state machine !!!\n"));
 		}
-
 		// tell CNTL state machine to call NdisMSetInformationComplete() after completing
 		// this request, because this request is initiated by NDIS.
 		pAdapter->MlmeAux.CurrReqIsFromNdis = FALSE;
@@ -747,148 +789,151 @@ int rt_ioctl_siwscan(struct net_device *
 		pAdapter->StaCfg.LastScanTime = Now;
 
 		MlmeEnqueue(pAdapter,
-			MLME_CNTL_STATE_MACHINE,
-			OID_802_11_BSSID_LIST_SCAN,
-			0,
-			NULL);
+			    MLME_CNTL_STATE_MACHINE,
+			    OID_802_11_BSSID_LIST_SCAN, 0, NULL);
 
 		Status = NDIS_STATUS_SUCCESS;
 		RTMP_MLME_HANDLER(pAdapter);
-	}while(0);
+	} while (0);
 	return NDIS_STATUS_SUCCESS;
 }
 
 int rt_ioctl_giwscan(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_point *data, char *extra)
+		     struct iw_request_info *info,
+		     struct iw_point *data, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
-	int i=0;
+	int i = 0;
 	PSTRING current_ev = extra, previous_ev = extra;
 	PSTRING end_buf;
 	PSTRING current_val;
-	STRING custom[MAX_CUSTOM_LEN] = {0};
+	STRING custom[MAX_CUSTOM_LEN] = { 0 };
 	struct iw_event iwe;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-    {
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
 		/*
 		 * Still scanning, indicate the caller should try again.
 		 */
 		return -EAGAIN;
 	}
 
-	if (pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE)
-	{
+	if (pAdapter->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE) {
 		pAdapter->StaCfg.WpaSupplicantScanCount = 0;
 	}
 
-	if (pAdapter->ScanTab.BssNr == 0)
-	{
+	if (pAdapter->ScanTab.BssNr == 0) {
 		data->length = 0;
 		return 0;
 	}
 
-    if (data->length > 0)
-        end_buf = extra + data->length;
-    else
-        end_buf = extra + IW_SCAN_MAX_DATA;
+	if (data->length > 0)
+		end_buf = extra + data->length;
+	else
+		end_buf = extra + IW_SCAN_MAX_DATA;
 
-	for (i = 0; i < pAdapter->ScanTab.BssNr; i++)
-	{
-		if (current_ev >= end_buf)
-        {
+	for (i = 0; i < pAdapter->ScanTab.BssNr; i++) {
+		if (current_ev >= end_buf) {
 			return -E2BIG;
-        }
-
+		}
 		//MAC address
 		//================================
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWAP;
 		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
-		memcpy(iwe.u.ap_addr.sa_data, &pAdapter->ScanTab.BssEntry[i].Bssid, ETH_ALEN);
+		memcpy(iwe.u.ap_addr.sa_data,
+		       &pAdapter->ScanTab.BssEntry[i].Bssid, ETH_ALEN);
 
-        previous_ev = current_ev;
-		current_ev = iwe_stream_add_event(info, current_ev,end_buf, &iwe, IW_EV_ADDR_LEN);
-        if (current_ev == previous_ev)
-		return -E2BIG;
+		previous_ev = current_ev;
+		current_ev =
+		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+					 IW_EV_ADDR_LEN);
+		if (current_ev == previous_ev)
+			return -E2BIG;
 
 		/*
-		Protocol:
-			it will show scanned AP's WirelessMode .
-			it might be
-					802.11a
-					802.11a/n
-					802.11g/n
-					802.11b/g/n
-					802.11g
-					802.11b/g
-		*/
+		   Protocol:
+		   it will show scanned AP's WirelessMode .
+		   it might be
+		   802.11a
+		   802.11a/n
+		   802.11g/n
+		   802.11b/g/n
+		   802.11g
+		   802.11b/g
+		 */
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWNAME;
 
-
-	{
-		PBSS_ENTRY pBssEntry=&pAdapter->ScanTab.BssEntry[i];
-		BOOLEAN isGonly=FALSE;
-		int rateCnt=0;
-
-		if (pBssEntry->Channel>14)
 		{
-			if (pBssEntry->HtCapabilityLen!=0)
-				strcpy(iwe.u.name,"802.11a/n");
-			else
-				strcpy(iwe.u.name,"802.11a");
-		}
-		else
-		{
-			/*
-				if one of non B mode rate is set supported rate . it mean G only.
-			*/
-			for (rateCnt=0;rateCnt<pBssEntry->SupRateLen;rateCnt++)
-			{
+			PBSS_ENTRY pBssEntry = &pAdapter->ScanTab.BssEntry[i];
+			BOOLEAN isGonly = FALSE;
+			int rateCnt = 0;
+
+			if (pBssEntry->Channel > 14) {
+				if (pBssEntry->HtCapabilityLen != 0)
+					strcpy(iwe.u.name, "802.11a/n");
+				else
+					strcpy(iwe.u.name, "802.11a");
+			} else {
 				/*
-					6Mbps(140) 9Mbps(146) and >=12Mbps(152) are supported rate , it mean G only.
-				*/
-				if (pBssEntry->SupRate[rateCnt]==140 || pBssEntry->SupRate[rateCnt]==146 || pBssEntry->SupRate[rateCnt]>=152)
-					isGonly=TRUE;
-			}
-
-			for (rateCnt=0;rateCnt<pBssEntry->ExtRateLen;rateCnt++)
-			{
-				if (pBssEntry->ExtRate[rateCnt]==140 || pBssEntry->ExtRate[rateCnt]==146 || pBssEntry->ExtRate[rateCnt]>=152)
-					isGonly=TRUE;
-			}
+				   if one of non B mode rate is set supported rate . it mean G only.
+				 */
+				for (rateCnt = 0;
+				     rateCnt < pBssEntry->SupRateLen;
+				     rateCnt++) {
+					/*
+					   6Mbps(140) 9Mbps(146) and >=12Mbps(152) are supported rate , it mean G only.
+					 */
+					if (pBssEntry->SupRate[rateCnt] == 140
+					    || pBssEntry->SupRate[rateCnt] ==
+					    146
+					    || pBssEntry->SupRate[rateCnt] >=
+					    152)
+						isGonly = TRUE;
+				}
 
+				for (rateCnt = 0;
+				     rateCnt < pBssEntry->ExtRateLen;
+				     rateCnt++) {
+					if (pBssEntry->ExtRate[rateCnt] == 140
+					    || pBssEntry->ExtRate[rateCnt] ==
+					    146
+					    || pBssEntry->ExtRate[rateCnt] >=
+					    152)
+						isGonly = TRUE;
+				}
 
-			if (pBssEntry->HtCapabilityLen!=0)
-			{
-				if (isGonly==TRUE)
-					strcpy(iwe.u.name,"802.11g/n");
-				else
-					strcpy(iwe.u.name,"802.11b/g/n");
-			}
-			else
-			{
-				if (isGonly==TRUE)
-					strcpy(iwe.u.name,"802.11g");
-				else
-				{
-					if (pBssEntry->SupRateLen==4 && pBssEntry->ExtRateLen==0)
-						strcpy(iwe.u.name,"802.11b");
+				if (pBssEntry->HtCapabilityLen != 0) {
+					if (isGonly == TRUE)
+						strcpy(iwe.u.name, "802.11g/n");
 					else
-						strcpy(iwe.u.name,"802.11b/g");
+						strcpy(iwe.u.name,
+						       "802.11b/g/n");
+				} else {
+					if (isGonly == TRUE)
+						strcpy(iwe.u.name, "802.11g");
+					else {
+						if (pBssEntry->SupRateLen == 4
+						    && pBssEntry->ExtRateLen ==
+						    0)
+							strcpy(iwe.u.name,
+							       "802.11b");
+						else
+							strcpy(iwe.u.name,
+							       "802.11b/g");
+					}
 				}
 			}
 		}
-	}
 
 		previous_ev = current_ev;
-		current_ev = iwe_stream_add_event(info, current_ev,end_buf, &iwe, IW_EV_ADDR_LEN);
-        if (current_ev == previous_ev)
-		return -E2BIG;
+		current_ev =
+		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+					 IW_EV_ADDR_LEN);
+		if (current_ev == previous_ev)
+			return -E2BIG;
 
 		//ESSID
 		//================================
@@ -897,33 +942,34 @@ int rt_ioctl_giwscan(struct net_device *
 		iwe.u.data.length = pAdapter->ScanTab.BssEntry[i].SsidLen;
 		iwe.u.data.flags = 1;
 
-        previous_ev = current_ev;
-		current_ev = iwe_stream_add_point(info, current_ev,end_buf, &iwe, (PSTRING) pAdapter->ScanTab.BssEntry[i].Ssid);
-        if (current_ev == previous_ev)
-		return -E2BIG;
+		previous_ev = current_ev;
+		current_ev =
+		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+					 (PSTRING) pAdapter->ScanTab.
+					 BssEntry[i].Ssid);
+		if (current_ev == previous_ev)
+			return -E2BIG;
 
 		//Network Type
 		//================================
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWMODE;
-		if (pAdapter->ScanTab.BssEntry[i].BssType == Ndis802_11IBSS)
-		{
+		if (pAdapter->ScanTab.BssEntry[i].BssType == Ndis802_11IBSS) {
 			iwe.u.mode = IW_MODE_ADHOC;
-		}
-		else if (pAdapter->ScanTab.BssEntry[i].BssType == Ndis802_11Infrastructure)
-		{
+		} else if (pAdapter->ScanTab.BssEntry[i].BssType ==
+			   Ndis802_11Infrastructure) {
 			iwe.u.mode = IW_MODE_INFRA;
-		}
-		else
-		{
+		} else {
 			iwe.u.mode = IW_MODE_AUTO;
 		}
 		iwe.len = IW_EV_UINT_LEN;
 
-        previous_ev = current_ev;
-		current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe,  IW_EV_UINT_LEN);
-        if (current_ev == previous_ev)
-		return -E2BIG;
+		previous_ev = current_ev;
+		current_ev =
+		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+					 IW_EV_UINT_LEN);
+		if (current_ev == previous_ev)
+			return -E2BIG;
 
 		//Channel and Frequency
 		//================================
@@ -937,190 +983,217 @@ int rt_ioctl_giwscan(struct net_device *
 		iwe.u.freq.i = 0;
 
 		previous_ev = current_ev;
-		current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
-        if (current_ev == previous_ev)
-		return -E2BIG;
-
-        //Add quality statistics
-        //================================
-        memset(&iwe, 0, sizeof(iwe));
-    	iwe.cmd = IWEVQUAL;
-    	iwe.u.qual.level = 0;
-    	iwe.u.qual.noise = 0;
-        set_quality(pAdapter, &iwe.u.qual, pAdapter->ScanTab.BssEntry[i].Rssi);
-    	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
-        if (current_ev == previous_ev)
-		return -E2BIG;
+		current_ev =
+		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+					 IW_EV_FREQ_LEN);
+		if (current_ev == previous_ev)
+			return -E2BIG;
+
+		//Add quality statistics
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVQUAL;
+		iwe.u.qual.level = 0;
+		iwe.u.qual.noise = 0;
+		set_quality(pAdapter, &iwe.u.qual,
+			    pAdapter->ScanTab.BssEntry[i].Rssi);
+		current_ev =
+		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+					 IW_EV_QUAL_LEN);
+		if (current_ev == previous_ev)
+			return -E2BIG;
 
 		//Encyption key
 		//================================
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = SIOCGIWENCODE;
-		if (CAP_IS_PRIVACY_ON (pAdapter->ScanTab.BssEntry[i].CapabilityInfo ))
-			iwe.u.data.flags =IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+		if (CAP_IS_PRIVACY_ON
+		    (pAdapter->ScanTab.BssEntry[i].CapabilityInfo))
+			iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
 		else
 			iwe.u.data.flags = IW_ENCODE_DISABLED;
 
-        previous_ev = current_ev;
-        current_ev = iwe_stream_add_point(info, current_ev, end_buf,&iwe, (char *)pAdapter->SharedKey[BSS0][(iwe.u.data.flags & IW_ENCODE_INDEX)-1].Key);
-        if (current_ev == previous_ev)
-		return -E2BIG;
+		previous_ev = current_ev;
+		current_ev =
+		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+					 (char *)pAdapter->
+					 SharedKey[BSS0][(iwe.u.data.
+							  flags &
+							  IW_ENCODE_INDEX) -
+							 1].Key);
+		if (current_ev == previous_ev)
+			return -E2BIG;
 
 		//Bit Rate
 		//================================
-		if (pAdapter->ScanTab.BssEntry[i].SupRateLen)
-        {
-            UCHAR tmpRate = pAdapter->ScanTab.BssEntry[i].SupRate[pAdapter->ScanTab.BssEntry[i].SupRateLen-1];
+		if (pAdapter->ScanTab.BssEntry[i].SupRateLen) {
+			UCHAR tmpRate =
+			    pAdapter->ScanTab.BssEntry[i].SupRate[pAdapter->
+								  ScanTab.
+								  BssEntry[i].
+								  SupRateLen -
+								  1];
 			memset(&iwe, 0, sizeof(iwe));
 			iwe.cmd = SIOCGIWRATE;
-    		current_val = current_ev + IW_EV_LCP_LEN;
-            if (tmpRate == 0x82)
-                iwe.u.bitrate.value =  1 * 1000000;
-            else if (tmpRate == 0x84)
-                iwe.u.bitrate.value =  2 * 1000000;
-            else if (tmpRate == 0x8B)
-                iwe.u.bitrate.value =  5.5 * 1000000;
-            else if (tmpRate == 0x96)
-                iwe.u.bitrate.value =  11 * 1000000;
-            else
-    		    iwe.u.bitrate.value =  (tmpRate/2) * 1000000;
-
-			if (tmpRate == 0x6c && pAdapter->ScanTab.BssEntry[i].HtCapabilityLen > 0)
-			{
-				int rate_count = sizeof(ralinkrate)/sizeof(__s32);
-				HT_CAP_INFO capInfo = pAdapter->ScanTab.BssEntry[i].HtCapability.HtCapInfo;
-				int shortGI = capInfo.ChannelWidth ? capInfo.ShortGIfor40 : capInfo.ShortGIfor20;
-				int maxMCS = pAdapter->ScanTab.BssEntry[i].HtCapability.MCSSet[1] ?  15 : 7;
-				int rate_index = 12 + ((UCHAR)capInfo.ChannelWidth * 24) + ((UCHAR)shortGI *48) + ((UCHAR)maxMCS);
+			current_val = current_ev + IW_EV_LCP_LEN;
+			if (tmpRate == 0x82)
+				iwe.u.bitrate.value = 1 * 1000000;
+			else if (tmpRate == 0x84)
+				iwe.u.bitrate.value = 2 * 1000000;
+			else if (tmpRate == 0x8B)
+				iwe.u.bitrate.value = 5.5 * 1000000;
+			else if (tmpRate == 0x96)
+				iwe.u.bitrate.value = 11 * 1000000;
+			else
+				iwe.u.bitrate.value = (tmpRate / 2) * 1000000;
+
+			if (tmpRate == 0x6c
+			    && pAdapter->ScanTab.BssEntry[i].HtCapabilityLen >
+			    0) {
+				int rate_count =
+				    sizeof(ralinkrate) / sizeof(__s32);
+				HT_CAP_INFO capInfo =
+				    pAdapter->ScanTab.BssEntry[i].HtCapability.
+				    HtCapInfo;
+				int shortGI =
+				    capInfo.ChannelWidth ? capInfo.
+				    ShortGIfor40 : capInfo.ShortGIfor20;
+				int maxMCS =
+				    pAdapter->ScanTab.BssEntry[i].HtCapability.
+				    MCSSet[1] ? 15 : 7;
+				int rate_index =
+				    12 + ((UCHAR) capInfo.ChannelWidth * 24) +
+				    ((UCHAR) shortGI * 48) + ((UCHAR) maxMCS);
 				if (rate_index < 0)
 					rate_index = 0;
 				if (rate_index > rate_count)
 					rate_index = rate_count;
-				iwe.u.bitrate.value	=  ralinkrate[rate_index] * 500000;
+				iwe.u.bitrate.value =
+				    ralinkrate[rate_index] * 500000;
 			}
 
 			iwe.u.bitrate.disabled = 0;
 			current_val = iwe_stream_add_value(info, current_ev,
-				current_val, end_buf, &iwe,
-    			IW_EV_PARAM_LEN);
-
-        	if((current_val-current_ev)>IW_EV_LCP_LEN)
-            	current_ev = current_val;
-        	else
-			return -E2BIG;
-        }
+							   current_val, end_buf,
+							   &iwe,
+							   IW_EV_PARAM_LEN);
 
+			if ((current_val - current_ev) > IW_EV_LCP_LEN)
+				current_ev = current_val;
+			else
+				return -E2BIG;
+		}
 		//WPA IE
-		if (pAdapter->ScanTab.BssEntry[i].WpaIE.IELen > 0)
-		{
+		if (pAdapter->ScanTab.BssEntry[i].WpaIE.IELen > 0) {
 			memset(&iwe, 0, sizeof(iwe));
 			memset(&custom[0], 0, MAX_CUSTOM_LEN);
-			memcpy(custom, &(pAdapter->ScanTab.BssEntry[i].WpaIE.IE[0]),
-						   pAdapter->ScanTab.BssEntry[i].WpaIE.IELen);
+			memcpy(custom,
+			       &(pAdapter->ScanTab.BssEntry[i].WpaIE.IE[0]),
+			       pAdapter->ScanTab.BssEntry[i].WpaIE.IELen);
 			iwe.cmd = IWEVGENIE;
-			iwe.u.data.length = pAdapter->ScanTab.BssEntry[i].WpaIE.IELen;
-			current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, custom);
+			iwe.u.data.length =
+			    pAdapter->ScanTab.BssEntry[i].WpaIE.IELen;
+			current_ev =
+			    iwe_stream_add_point(info, current_ev, end_buf,
+						 &iwe, custom);
 			if (current_ev == previous_ev)
 				return -E2BIG;
 		}
-
 		//WPA2 IE
-        if (pAdapter->ScanTab.BssEntry[i].RsnIE.IELen > 0)
-        {
-        	memset(&iwe, 0, sizeof(iwe));
+		if (pAdapter->ScanTab.BssEntry[i].RsnIE.IELen > 0) {
+			memset(&iwe, 0, sizeof(iwe));
 			memset(&custom[0], 0, MAX_CUSTOM_LEN);
-			memcpy(custom, &(pAdapter->ScanTab.BssEntry[i].RsnIE.IE[0]),
-						   pAdapter->ScanTab.BssEntry[i].RsnIE.IELen);
+			memcpy(custom,
+			       &(pAdapter->ScanTab.BssEntry[i].RsnIE.IE[0]),
+			       pAdapter->ScanTab.BssEntry[i].RsnIE.IELen);
 			iwe.cmd = IWEVGENIE;
-			iwe.u.data.length = pAdapter->ScanTab.BssEntry[i].RsnIE.IELen;
-			current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, custom);
+			iwe.u.data.length =
+			    pAdapter->ScanTab.BssEntry[i].RsnIE.IELen;
+			current_ev =
+			    iwe_stream_add_point(info, current_ev, end_buf,
+						 &iwe, custom);
 			if (current_ev == previous_ev)
 				return -E2BIG;
-        }
+		}
 	}
 
 	data->length = current_ev - extra;
-    pAdapter->StaCfg.bScanReqIsFromWebUI = FALSE;
-	DBGPRINT(RT_DEBUG_ERROR ,("===>rt_ioctl_giwscan. %d(%d) BSS returned, data->length = %d\n",i , pAdapter->ScanTab.BssNr, data->length));
+	pAdapter->StaCfg.bScanReqIsFromWebUI = FALSE;
+	DBGPRINT(RT_DEBUG_ERROR,
+		 ("===>rt_ioctl_giwscan. %d(%d) BSS returned, data->length = %d\n",
+		  i, pAdapter->ScanTab.BssNr, data->length));
 	return 0;
 }
 
 int rt_ioctl_siwessid(struct net_device *dev,
-			 struct iw_request_info *info,
-			 struct iw_point *data, char *essid)
+		      struct iw_request_info *info,
+		      struct iw_point *data, char *essid)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-    if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    {
-       	DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-       	return -ENETDOWN;
-    }
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
-	if (data->flags)
-	{
-		PSTRING	pSsidString = NULL;
+	if (data->flags) {
+		PSTRING pSsidString = NULL;
 
 		// Includes null character.
 		if (data->length > (IW_ESSID_MAX_SIZE + 1))
 			return -E2BIG;
 
-		pSsidString = kmalloc(MAX_LEN_OF_SSID+1, MEM_ALLOC_FLAG);
-		if (pSsidString)
-		{
-			NdisZeroMemory(pSsidString, MAX_LEN_OF_SSID+1);
+		pSsidString = kmalloc(MAX_LEN_OF_SSID + 1, MEM_ALLOC_FLAG);
+		if (pSsidString) {
+			NdisZeroMemory(pSsidString, MAX_LEN_OF_SSID + 1);
 			NdisMoveMemory(pSsidString, essid, data->length);
 			if (Set_SSID_Proc(pAdapter, pSsidString) == FALSE)
 				return -EINVAL;
-		}
-		else
+		} else
 			return -ENOMEM;
-	}
-	else
-	{
+	} else {
 		// ANY ssid
 		if (Set_SSID_Proc(pAdapter, "") == FALSE)
 			return -EINVAL;
-    }
+	}
 	return 0;
 }
 
 int rt_ioctl_giwessid(struct net_device *dev,
-			 struct iw_request_info *info,
-			 struct iw_point *data, char *essid)
+		      struct iw_request_info *info,
+		      struct iw_point *data, char *essid)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	data->flags = 1;
-    if (MONITOR_ON(pAdapter))
-    {
-        data->length  = 0;
-        return 0;
-    }
+	if (MONITOR_ON(pAdapter)) {
+		data->length = 0;
+		return 0;
+	}
 
-	if (OPSTATUS_TEST_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED))
-	{
-		DBGPRINT(RT_DEBUG_TRACE ,("MediaState is connected\n"));
+	if (OPSTATUS_TEST_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("MediaState is connected\n"));
 		data->length = pAdapter->CommonCfg.SsidLen;
-		memcpy(essid, pAdapter->CommonCfg.Ssid, pAdapter->CommonCfg.SsidLen);
+		memcpy(essid, pAdapter->CommonCfg.Ssid,
+		       pAdapter->CommonCfg.SsidLen);
 	}
 #ifdef RTMP_MAC_USB
-    // Add for RT2870
-    else if (pAdapter->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)
-    {
-        data->length = pAdapter->CommonCfg.SsidLen;
-		memcpy(essid, pAdapter->CommonCfg.Ssid, pAdapter->CommonCfg.SsidLen);
+	// Add for RT2870
+	else if (pAdapter->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) {
+		data->length = pAdapter->CommonCfg.SsidLen;
+		memcpy(essid, pAdapter->CommonCfg.Ssid,
+		       pAdapter->CommonCfg.SsidLen);
 	}
 #endif // RTMP_MAC_USB //
-	else
-	{//the ANY ssid was specified
-		data->length  = 0;
-		DBGPRINT(RT_DEBUG_TRACE ,("MediaState is not connected, ess\n"));
+	else {			//the ANY ssid was specified
+		data->length = 0;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MediaState is not connected, ess\n"));
 	}
 
 	return 0;
@@ -1128,19 +1201,18 @@ int rt_ioctl_giwessid(struct net_device 
 }
 
 int rt_ioctl_siwnickn(struct net_device *dev,
-			 struct iw_request_info *info,
-			 struct iw_point *data, char *nickname)
+		      struct iw_request_info *info,
+		      struct iw_point *data, char *nickname)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-    //check if the interface is down
-    if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    {
-        DBGPRINT(RT_DEBUG_TRACE ,("INFO::Network is down!\n"));
-        return -ENETDOWN;
-    }
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
 	if (data->length > IW_ESSID_MAX_SIZE)
 		return -EINVAL;
@@ -1148,13 +1220,12 @@ int rt_ioctl_siwnickn(struct net_device 
 	memset(pAdapter->nickname, 0, IW_ESSID_MAX_SIZE + 1);
 	memcpy(pAdapter->nickname, nickname, data->length);
 
-
 	return 0;
 }
 
 int rt_ioctl_giwnickn(struct net_device *dev,
-			 struct iw_request_info *info,
-			 struct iw_point *data, char *nickname)
+		      struct iw_request_info *info,
+		      struct iw_point *data, char *nickname)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
@@ -1163,34 +1234,33 @@ int rt_ioctl_giwnickn(struct net_device 
 	if (data->length > strlen((PSTRING) pAdapter->nickname) + 1)
 		data->length = strlen((PSTRING) pAdapter->nickname) + 1;
 	if (data->length > 0) {
-		memcpy(nickname, pAdapter->nickname, data->length-1);
-		nickname[data->length-1] = '\0';
+		memcpy(nickname, pAdapter->nickname, data->length - 1);
+		nickname[data->length - 1] = '\0';
 	}
 	return 0;
 }
 
 int rt_ioctl_siwrts(struct net_device *dev,
-		       struct iw_request_info *info,
-		       struct iw_param *rts, char *extra)
+		    struct iw_request_info *info,
+		    struct iw_param *rts, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 	u16 val;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-    //check if the interface is down
-    if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-        return -ENETDOWN;
-    }
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
 	if (rts->disabled)
 		val = MAX_RTS_THRESHOLD;
 	else if (rts->value < 0 || rts->value > MAX_RTS_THRESHOLD)
 		return -EINVAL;
 	else if (rts->value == 0)
-	    val = MAX_RTS_THRESHOLD;
+		val = MAX_RTS_THRESHOLD;
 	else
 		val = rts->value;
 
@@ -1201,19 +1271,18 @@ int rt_ioctl_siwrts(struct net_device *d
 }
 
 int rt_ioctl_giwrts(struct net_device *dev,
-		       struct iw_request_info *info,
-		       struct iw_param *rts, char *extra)
+		    struct iw_request_info *info,
+		    struct iw_param *rts, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-    	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    	{
-      		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-        	return -ENETDOWN;
-    	}
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
 	rts->value = pAdapter->CommonCfg.RtsThreshold;
 	rts->disabled = (rts->value == MAX_RTS_THRESHOLD);
@@ -1223,8 +1292,8 @@ int rt_ioctl_giwrts(struct net_device *d
 }
 
 int rt_ioctl_siwfrag(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_param *frag, char *extra)
+		     struct iw_request_info *info,
+		     struct iw_param *frag, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 	u16 val;
@@ -1232,18 +1301,18 @@ int rt_ioctl_siwfrag(struct net_device *
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-    	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    	{
-      		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-        	return -ENETDOWN;
-    	}
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
 	if (frag->disabled)
 		val = MAX_FRAG_THRESHOLD;
-	else if (frag->value >= MIN_FRAG_THRESHOLD && frag->value <= MAX_FRAG_THRESHOLD)
-		val = __cpu_to_le16(frag->value & ~0x1); /* even numbers only */
+	else if (frag->value >= MIN_FRAG_THRESHOLD
+		 && frag->value <= MAX_FRAG_THRESHOLD)
+		val = __cpu_to_le16(frag->value & ~0x1);	/* even numbers only */
 	else if (frag->value == 0)
-	    val = MAX_FRAG_THRESHOLD;
+		val = MAX_FRAG_THRESHOLD;
 	else
 		return -EINVAL;
 
@@ -1252,19 +1321,18 @@ int rt_ioctl_siwfrag(struct net_device *
 }
 
 int rt_ioctl_giwfrag(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_param *frag, char *extra)
+		     struct iw_request_info *info,
+		     struct iw_param *frag, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-    	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    	{
-      		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-        	return -ENETDOWN;
-    	}
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
 	frag->value = pAdapter->CommonCfg.FragmentThreshold;
 	frag->disabled = (frag->value == MAX_FRAG_THRESHOLD);
@@ -1276,113 +1344,111 @@ int rt_ioctl_giwfrag(struct net_device *
 #define MAX_WEP_KEY_SIZE 13
 #define MIN_WEP_KEY_SIZE 5
 int rt_ioctl_siwencode(struct net_device *dev,
-			  struct iw_request_info *info,
-			  struct iw_point *erq, char *extra)
+		       struct iw_request_info *info,
+		       struct iw_point *erq, char *extra)
 {
 	PRTMP_ADAPTER pAdapter = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-    	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    	{
-      		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-        	return -ENETDOWN;
-    	}
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
-	if ((erq->length == 0) &&
-        (erq->flags & IW_ENCODE_DISABLED))
-	{
+	if ((erq->length == 0) && (erq->flags & IW_ENCODE_DISABLED)) {
 		pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
 		pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
 		pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
-        pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-        pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-        goto done;
-	}
-	else if (erq->flags & IW_ENCODE_RESTRICTED || erq->flags & IW_ENCODE_OPEN)
-	{
-	    //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+		pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
+		pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+		goto done;
+	} else if (erq->flags & IW_ENCODE_RESTRICTED
+		   || erq->flags & IW_ENCODE_OPEN) {
+		//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 		STA_PORT_SECURED(pAdapter);
 		pAdapter->StaCfg.PairCipher = Ndis802_11WEPEnabled;
 		pAdapter->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
 		pAdapter->StaCfg.WepStatus = Ndis802_11WEPEnabled;
-        pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
+		pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
 		if (erq->flags & IW_ENCODE_RESTRICTED)
 			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeShared;
-    	else
+		else
 			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
 	}
 
-    if (erq->length > 0)
-	{
+	if (erq->length > 0) {
 		int keyIdx = (erq->flags & IW_ENCODE_INDEX) - 1;
 		/* Check the size of the key */
-		if (erq->length > MAX_WEP_KEY_SIZE)
-		{
+		if (erq->length > MAX_WEP_KEY_SIZE) {
 			return -EINVAL;
 		}
 		/* Check key index */
-		if ((keyIdx < 0) || (keyIdx >= NR_WEP_KEYS))
-        {
-            DBGPRINT(RT_DEBUG_TRACE ,("==>rt_ioctl_siwencode::Wrong keyIdx=%d! Using default key instead (%d)\n",
-                                        keyIdx, pAdapter->StaCfg.DefaultKeyId));
+		if ((keyIdx < 0) || (keyIdx >= NR_WEP_KEYS)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("==>rt_ioctl_siwencode::Wrong keyIdx=%d! Using default key instead (%d)\n",
+				  keyIdx, pAdapter->StaCfg.DefaultKeyId));
 
-            //Using default key
+			//Using default key
 			keyIdx = pAdapter->StaCfg.DefaultKeyId;
-        }
-		else
+		} else
 			pAdapter->StaCfg.DefaultKeyId = keyIdx;
 
-        NdisZeroMemory(pAdapter->SharedKey[BSS0][keyIdx].Key,  16);
+		NdisZeroMemory(pAdapter->SharedKey[BSS0][keyIdx].Key, 16);
 
-		if (erq->length == MAX_WEP_KEY_SIZE)
-        {
-			pAdapter->SharedKey[BSS0][keyIdx].KeyLen = MAX_WEP_KEY_SIZE;
-            pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_WEP128;
-		}
-		else if (erq->length == MIN_WEP_KEY_SIZE)
-        {
-            pAdapter->SharedKey[BSS0][keyIdx].KeyLen = MIN_WEP_KEY_SIZE;
-            pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_WEP64;
-		}
-		else
+		if (erq->length == MAX_WEP_KEY_SIZE) {
+			pAdapter->SharedKey[BSS0][keyIdx].KeyLen =
+			    MAX_WEP_KEY_SIZE;
+			pAdapter->SharedKey[BSS0][keyIdx].CipherAlg =
+			    CIPHER_WEP128;
+		} else if (erq->length == MIN_WEP_KEY_SIZE) {
+			pAdapter->SharedKey[BSS0][keyIdx].KeyLen =
+			    MIN_WEP_KEY_SIZE;
+			pAdapter->SharedKey[BSS0][keyIdx].CipherAlg =
+			    CIPHER_WEP64;
+		} else
 			/* Disable the key */
 			pAdapter->SharedKey[BSS0][keyIdx].KeyLen = 0;
 
 		/* Check if the key is not marked as invalid */
-		if(!(erq->flags & IW_ENCODE_NOKEY))
-		{
+		if (!(erq->flags & IW_ENCODE_NOKEY)) {
 			/* Copy the key in the driver */
-			NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key, extra, erq->length);
-        }
-	}
-    else
-			{
+			NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key,
+				       extra, erq->length);
+		}
+	} else {
 		/* Do we want to just set the transmit key index ? */
 		int index = (erq->flags & IW_ENCODE_INDEX) - 1;
-		if ((index >= 0) && (index < 4))
-        {
+		if ((index >= 0) && (index < 4)) {
 			pAdapter->StaCfg.DefaultKeyId = index;
-            }
-        else
+		} else
 			/* Don't complain if only change the mode */
-			if (!(erq->flags & IW_ENCODE_MODE))
-				return -EINVAL;
-		}
+		if (!(erq->flags & IW_ENCODE_MODE))
+			return -EINVAL;
+	}
 
 done:
-    DBGPRINT(RT_DEBUG_TRACE ,("==>rt_ioctl_siwencode::erq->flags=%x\n",erq->flags));
-	DBGPRINT(RT_DEBUG_TRACE ,("==>rt_ioctl_siwencode::AuthMode=%x\n",pAdapter->StaCfg.AuthMode));
-	DBGPRINT(RT_DEBUG_TRACE ,("==>rt_ioctl_siwencode::DefaultKeyId=%x, KeyLen = %d\n",pAdapter->StaCfg.DefaultKeyId , pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].KeyLen));
-	DBGPRINT(RT_DEBUG_TRACE ,("==>rt_ioctl_siwencode::WepStatus=%x\n",pAdapter->StaCfg.WepStatus));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("==>rt_ioctl_siwencode::erq->flags=%x\n", erq->flags));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("==>rt_ioctl_siwencode::AuthMode=%x\n",
+		  pAdapter->StaCfg.AuthMode));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("==>rt_ioctl_siwencode::DefaultKeyId=%x, KeyLen = %d\n",
+		  pAdapter->StaCfg.DefaultKeyId,
+		  pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].
+		  KeyLen));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("==>rt_ioctl_siwencode::WepStatus=%x\n",
+		  pAdapter->StaCfg.WepStatus));
 	return 0;
 }
 
 int
 rt_ioctl_giwencode(struct net_device *dev,
-			  struct iw_request_info *info,
-			  struct iw_point *erq, char *key)
+		   struct iw_request_info *info,
+		   struct iw_point *erq, char *key)
 {
 	int kid;
 	PRTMP_ADAPTER pAdapter = NULL;
@@ -1390,49 +1456,49 @@ rt_ioctl_giwencode(struct net_device *de
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
 	//check if the interface is down
-	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-	{
-  		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-    	return -ENETDOWN;
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
 	}
 
 	kid = erq->flags & IW_ENCODE_INDEX;
-	DBGPRINT(RT_DEBUG_TRACE, ("===>rt_ioctl_giwencode %d\n", erq->flags & IW_ENCODE_INDEX));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("===>rt_ioctl_giwencode %d\n", erq->flags & IW_ENCODE_INDEX));
 
-	if (pAdapter->StaCfg.WepStatus == Ndis802_11WEPDisabled)
-	{
+	if (pAdapter->StaCfg.WepStatus == Ndis802_11WEPDisabled) {
 		erq->length = 0;
 		erq->flags = IW_ENCODE_DISABLED;
-	}
-	else if ((kid > 0) && (kid <=4))
-	{
+	} else if ((kid > 0) && (kid <= 4)) {
 		// copy wep key
-		erq->flags = kid ;			/* NB: base 1 */
-		if (erq->length > pAdapter->SharedKey[BSS0][kid-1].KeyLen)
-			erq->length = pAdapter->SharedKey[BSS0][kid-1].KeyLen;
-		memcpy(key, pAdapter->SharedKey[BSS0][kid-1].Key, erq->length);
+		erq->flags = kid;	/* NB: base 1 */
+		if (erq->length > pAdapter->SharedKey[BSS0][kid - 1].KeyLen)
+			erq->length = pAdapter->SharedKey[BSS0][kid - 1].KeyLen;
+		memcpy(key, pAdapter->SharedKey[BSS0][kid - 1].Key,
+		       erq->length);
 		//if ((kid == pAdapter->PortCfg.DefaultKeyId))
-		//erq->flags |= IW_ENCODE_ENABLED;	/* XXX */
+		//erq->flags |= IW_ENCODE_ENABLED;      /* XXX */
 		if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared)
-			erq->flags |= IW_ENCODE_RESTRICTED;		/* XXX */
+			erq->flags |= IW_ENCODE_RESTRICTED;	/* XXX */
 		else
-			erq->flags |= IW_ENCODE_OPEN;		/* XXX */
+			erq->flags |= IW_ENCODE_OPEN;	/* XXX */
 
-	}
-	else if (kid == 0)
-	{
+	} else if (kid == 0) {
 		if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared)
-			erq->flags |= IW_ENCODE_RESTRICTED;		/* XXX */
+			erq->flags |= IW_ENCODE_RESTRICTED;	/* XXX */
 		else
-			erq->flags |= IW_ENCODE_OPEN;		/* XXX */
-		erq->length = pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].KeyLen;
-		memcpy(key, pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].Key, erq->length);
+			erq->flags |= IW_ENCODE_OPEN;	/* XXX */
+		erq->length =
+		    pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].
+		    KeyLen;
+		memcpy(key,
+		       pAdapter->SharedKey[BSS0][pAdapter->StaCfg.DefaultKeyId].
+		       Key, erq->length);
 		// copy default key ID
 		if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared)
-			erq->flags |= IW_ENCODE_RESTRICTED;		/* XXX */
+			erq->flags |= IW_ENCODE_RESTRICTED;	/* XXX */
 		else
-			erq->flags |= IW_ENCODE_OPEN;		/* XXX */
-		erq->flags = pAdapter->StaCfg.DefaultKeyId + 1;			/* NB: base 1 */
+			erq->flags |= IW_ENCODE_OPEN;	/* XXX */
+		erq->flags = pAdapter->StaCfg.DefaultKeyId + 1;	/* NB: base 1 */
 		erq->flags |= IW_ENCODE_ENABLED;	/* XXX */
 	}
 
@@ -1440,63 +1506,71 @@ rt_ioctl_giwencode(struct net_device *de
 
 }
 
-void	getBaInfo(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			pOutBuf)
+void getBaInfo(IN PRTMP_ADAPTER pAd, IN PSTRING pOutBuf)
 {
 	INT i, j;
 	BA_ORI_ENTRY *pOriBAEntry;
 	BA_REC_ENTRY *pRecBAEntry;
 
-	for (i=0; i<MAX_LEN_OF_MAC_TABLE; i++)
-	{
+	for (i = 0; i < MAX_LEN_OF_MAC_TABLE; i++) {
 		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
-		if (((pEntry->ValidAsCLI || pEntry->ValidAsApCli) && (pEntry->Sst == SST_ASSOC))
-			|| (pEntry->ValidAsWDS) || (pEntry->ValidAsMesh))
-		{
-			sprintf(pOutBuf + strlen(pOutBuf), "\n%02X:%02X:%02X:%02X:%02X:%02X (Aid = %d) (AP) -\n",
-				pEntry->Addr[0], pEntry->Addr[1], pEntry->Addr[2],
-				pEntry->Addr[3], pEntry->Addr[4], pEntry->Addr[5], pEntry->Aid);
+		if (((pEntry->ValidAsCLI || pEntry->ValidAsApCli)
+		     && (pEntry->Sst == SST_ASSOC))
+		    || (pEntry->ValidAsWDS) || (pEntry->ValidAsMesh)) {
+			sprintf(pOutBuf + strlen(pOutBuf),
+				"\n%02X:%02X:%02X:%02X:%02X:%02X (Aid = %d) (AP) -\n",
+				pEntry->Addr[0], pEntry->Addr[1],
+				pEntry->Addr[2], pEntry->Addr[3],
+				pEntry->Addr[4], pEntry->Addr[5], pEntry->Aid);
 
 			sprintf(pOutBuf, "%s[Recipient]\n", pOutBuf);
-			for (j=0; j < NUM_OF_TID; j++)
-			{
-				if (pEntry->BARecWcidArray[j] != 0)
-				{
-					pRecBAEntry =&pAd->BATable.BARecEntry[pEntry->BARecWcidArray[j]];
-					sprintf(pOutBuf + strlen(pOutBuf), "TID=%d, BAWinSize=%d, LastIndSeq=%d, ReorderingPkts=%d\n", j, pRecBAEntry->BAWinSize, pRecBAEntry->LastIndSeq, pRecBAEntry->list.qlen);
+			for (j = 0; j < NUM_OF_TID; j++) {
+				if (pEntry->BARecWcidArray[j] != 0) {
+					pRecBAEntry =
+					    &pAd->BATable.BARecEntry[pEntry->
+								     BARecWcidArray
+								     [j]];
+					sprintf(pOutBuf + strlen(pOutBuf),
+						"TID=%d, BAWinSize=%d, LastIndSeq=%d, ReorderingPkts=%d\n",
+						j, pRecBAEntry->BAWinSize,
+						pRecBAEntry->LastIndSeq,
+						pRecBAEntry->list.qlen);
 				}
 			}
 			sprintf(pOutBuf, "%s\n", pOutBuf);
 
 			sprintf(pOutBuf, "%s[Originator]\n", pOutBuf);
-			for (j=0; j < NUM_OF_TID; j++)
-			{
-				if (pEntry->BAOriWcidArray[j] != 0)
-				{
-					pOriBAEntry =&pAd->BATable.BAOriEntry[pEntry->BAOriWcidArray[j]];
-					sprintf(pOutBuf + strlen(pOutBuf), "TID=%d, BAWinSize=%d, StartSeq=%d, CurTxSeq=%d\n", j, pOriBAEntry->BAWinSize, pOriBAEntry->Sequence, pEntry->TxSeq[j]);
+			for (j = 0; j < NUM_OF_TID; j++) {
+				if (pEntry->BAOriWcidArray[j] != 0) {
+					pOriBAEntry =
+					    &pAd->BATable.BAOriEntry[pEntry->
+								     BAOriWcidArray
+								     [j]];
+					sprintf(pOutBuf + strlen(pOutBuf),
+						"TID=%d, BAWinSize=%d, StartSeq=%d, CurTxSeq=%d\n",
+						j, pOriBAEntry->BAWinSize,
+						pOriBAEntry->Sequence,
+						pEntry->TxSeq[j]);
 				}
 			}
 			sprintf(pOutBuf, "%s\n\n", pOutBuf);
 		}
-        if (strlen(pOutBuf) > (IW_PRIV_SIZE_MASK - 30))
-                break;
+		if (strlen(pOutBuf) > (IW_PRIV_SIZE_MASK - 30))
+			break;
 	}
 
 	return;
 }
 
 int rt_ioctl_siwmlme(struct net_device *dev,
-			   struct iw_request_info *info,
-			   union iwreq_data *wrqu,
-			   char *extra)
+		     struct iw_request_info *info,
+		     union iwreq_data *wrqu, char *extra)
 {
-	PRTMP_ADAPTER   pAd = NULL;
+	PRTMP_ADAPTER pAd = NULL;
 	struct iw_mlme *pMlme = (struct iw_mlme *)wrqu->data.pointer;
-	MLME_QUEUE_ELEM				MsgElem;
-	MLME_DISASSOC_REQ_STRUCT	DisAssocReq;
-	MLME_DEAUTH_REQ_STRUCT      DeAuthReq;
+	MLME_QUEUE_ELEM MsgElem;
+	MLME_DISASSOC_REQ_STRUCT DisAssocReq;
+	MLME_DEAUTH_REQ_STRUCT DeAuthReq;
 
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
@@ -1505,405 +1579,444 @@ int rt_ioctl_siwmlme(struct net_device *
 	if (pMlme == NULL)
 		return -EINVAL;
 
-	switch(pMlme->cmd)
-	{
+	switch (pMlme->cmd) {
 #ifdef IW_MLME_DEAUTH
-		case IW_MLME_DEAUTH:
-			DBGPRINT(RT_DEBUG_TRACE, ("====> %s - IW_MLME_DEAUTH\n", __func__));
-			COPY_MAC_ADDR(DeAuthReq.Addr, pAd->CommonCfg.Bssid);
-			DeAuthReq.Reason = pMlme->reason_code;
-			MsgElem.MsgLen = sizeof(MLME_DEAUTH_REQ_STRUCT);
-			NdisMoveMemory(MsgElem.Msg, &DeAuthReq, sizeof(MLME_DEAUTH_REQ_STRUCT));
-			MlmeDeauthReqAction(pAd, &MsgElem);
-			if (INFRA_ON(pAd))
-			{
-			    LinkDown(pAd, FALSE);
-			    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-			}
-			break;
+	case IW_MLME_DEAUTH:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("====> %s - IW_MLME_DEAUTH\n", __func__));
+		COPY_MAC_ADDR(DeAuthReq.Addr, pAd->CommonCfg.Bssid);
+		DeAuthReq.Reason = pMlme->reason_code;
+		MsgElem.MsgLen = sizeof(MLME_DEAUTH_REQ_STRUCT);
+		NdisMoveMemory(MsgElem.Msg, &DeAuthReq,
+			       sizeof(MLME_DEAUTH_REQ_STRUCT));
+		MlmeDeauthReqAction(pAd, &MsgElem);
+		if (INFRA_ON(pAd)) {
+			LinkDown(pAd, FALSE);
+			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+		}
+		break;
 #endif // IW_MLME_DEAUTH //
 #ifdef IW_MLME_DISASSOC
-		case IW_MLME_DISASSOC:
-			DBGPRINT(RT_DEBUG_TRACE, ("====> %s - IW_MLME_DISASSOC\n", __func__));
-			COPY_MAC_ADDR(DisAssocReq.Addr, pAd->CommonCfg.Bssid);
-			DisAssocReq.Reason =  pMlme->reason_code;
-
-			MsgElem.Machine = ASSOC_STATE_MACHINE;
-			MsgElem.MsgType = MT2_MLME_DISASSOC_REQ;
-			MsgElem.MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
-			NdisMoveMemory(MsgElem.Msg, &DisAssocReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
+	case IW_MLME_DISASSOC:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("====> %s - IW_MLME_DISASSOC\n", __func__));
+		COPY_MAC_ADDR(DisAssocReq.Addr, pAd->CommonCfg.Bssid);
+		DisAssocReq.Reason = pMlme->reason_code;
+
+		MsgElem.Machine = ASSOC_STATE_MACHINE;
+		MsgElem.MsgType = MT2_MLME_DISASSOC_REQ;
+		MsgElem.MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
+		NdisMoveMemory(MsgElem.Msg, &DisAssocReq,
+			       sizeof(MLME_DISASSOC_REQ_STRUCT));
 
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
-			MlmeDisassocReqAction(pAd, &MsgElem);
-			break;
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
+		MlmeDisassocReqAction(pAd, &MsgElem);
+		break;
 #endif // IW_MLME_DISASSOC //
-		default:
-			DBGPRINT(RT_DEBUG_TRACE, ("====> %s - Unknow Command\n", __func__));
-			break;
+	default:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("====> %s - Unknow Command\n", __func__));
+		break;
 	}
 
 	return 0;
 }
 
 int rt_ioctl_siwauth(struct net_device *dev,
-			  struct iw_request_info *info,
-			  union iwreq_data *wrqu, char *extra)
+		     struct iw_request_info *info,
+		     union iwreq_data *wrqu, char *extra)
 {
-	PRTMP_ADAPTER   pAdapter = NULL;
+	PRTMP_ADAPTER pAdapter = NULL;
 	struct iw_param *param = &wrqu->param;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-    //check if the interface is down
-	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-	{
-  		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-    	return -ENETDOWN;
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
 	}
 	switch (param->flags & IW_AUTH_INDEX) {
-    	case IW_AUTH_WPA_VERSION:
-            if (param->value == IW_AUTH_WPA_VERSION_WPA)
-            {
-                pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
-				if (pAdapter->StaCfg.BssType == BSS_ADHOC)
-					pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPANone;
-            }
-            else if (param->value == IW_AUTH_WPA_VERSION_WPA2)
-                pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;
-
-            DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_WPA_VERSION - param->value = %d!\n", __func__, param->value));
-            break;
-    	case IW_AUTH_CIPHER_PAIRWISE:
-            if (param->value == IW_AUTH_CIPHER_NONE)
-            {
-                pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
-                pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-                pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
-            }
-            else if (param->value == IW_AUTH_CIPHER_WEP40 ||
-                     param->value == IW_AUTH_CIPHER_WEP104)
-            {
-                pAdapter->StaCfg.WepStatus = Ndis802_11WEPEnabled;
-                pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-                pAdapter->StaCfg.PairCipher = Ndis802_11WEPEnabled;
-                pAdapter->StaCfg.IEEE8021X = FALSE;
-            }
-            else if (param->value == IW_AUTH_CIPHER_TKIP)
-            {
-                pAdapter->StaCfg.WepStatus = Ndis802_11Encryption2Enabled;
-                pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-                pAdapter->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
-            }
-            else if (param->value == IW_AUTH_CIPHER_CCMP)
-            {
-                pAdapter->StaCfg.WepStatus = Ndis802_11Encryption3Enabled;
-                pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-                pAdapter->StaCfg.PairCipher = Ndis802_11Encryption3Enabled;
-            }
-            DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_CIPHER_PAIRWISE - param->value = %d!\n", __func__, param->value));
-            break;
-    	case IW_AUTH_CIPHER_GROUP:
-            if (param->value == IW_AUTH_CIPHER_NONE)
-            {
-                pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
-            }
-            else if (param->value == IW_AUTH_CIPHER_WEP40 ||
-                     param->value == IW_AUTH_CIPHER_WEP104)
-            {
-                pAdapter->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
-            }
-            else if (param->value == IW_AUTH_CIPHER_TKIP)
-            {
-                pAdapter->StaCfg.GroupCipher = Ndis802_11Encryption2Enabled;
-            }
-            else if (param->value == IW_AUTH_CIPHER_CCMP)
-            {
-                pAdapter->StaCfg.GroupCipher = Ndis802_11Encryption3Enabled;
-            }
-            DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_CIPHER_GROUP - param->value = %d!\n", __func__, param->value));
-            break;
-    	case IW_AUTH_KEY_MGMT:
-            if (param->value == IW_AUTH_KEY_MGMT_802_1X)
-            {
-                if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
-                {
-                    pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPA;
-                    pAdapter->StaCfg.IEEE8021X = FALSE;
-                }
-                else if (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-                {
-                    pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPA2;
-                    pAdapter->StaCfg.IEEE8021X = FALSE;
-                }
-                else
-                    // WEP 1x
-                    pAdapter->StaCfg.IEEE8021X = TRUE;
-            }
-            else if (param->value == 0)
-            {
-                //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-				STA_PORT_SECURED(pAdapter);
-            }
-            DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_KEY_MGMT - param->value = %d!\n", __func__, param->value));
-            break;
-    	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
-            break;
-    	case IW_AUTH_PRIVACY_INVOKED:
-            /*if (param->value == 0)
-			{
-                pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-                pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
-                pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-                pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
-		    pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
-            }*/
-            DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_PRIVACY_INVOKED - param->value = %d!\n", __func__, param->value));
-    		break;
-    	case IW_AUTH_DROP_UNENCRYPTED:
-            if (param->value != 0)
-                pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
-			else
-			{
-                //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-				STA_PORT_SECURED(pAdapter);
-			}
-            DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_WPA_VERSION - param->value = %d!\n", __func__, param->value));
-    		break;
-    	case IW_AUTH_80211_AUTH_ALG:
-			if (param->value & IW_AUTH_ALG_SHARED_KEY)
-            {
-				pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeShared;
-			}
-            else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)
-            {
-				pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-			}
-            else
-				return -EINVAL;
-            DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_80211_AUTH_ALG - param->value = %d!\n", __func__, param->value));
-			break;
-    	case IW_AUTH_WPA_ENABLED:
-    		DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_WPA_ENABLED - Driver supports WPA!(param->value = %d)\n", __func__, param->value));
-    		break;
-    	default:
-    		return -EOPNOTSUPP;
-}
+	case IW_AUTH_WPA_VERSION:
+		if (param->value == IW_AUTH_WPA_VERSION_WPA) {
+			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+			if (pAdapter->StaCfg.BssType == BSS_ADHOC)
+				pAdapter->StaCfg.AuthMode =
+				    Ndis802_11AuthModeWPANone;
+		} else if (param->value == IW_AUTH_WPA_VERSION_WPA2)
+			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;
+
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::IW_AUTH_WPA_VERSION - param->value = %d!\n",
+			  __func__, param->value));
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+		if (param->value == IW_AUTH_CIPHER_NONE) {
+			pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
+			pAdapter->StaCfg.OrigWepStatus =
+			    pAdapter->StaCfg.WepStatus;
+			pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
+		} else if (param->value == IW_AUTH_CIPHER_WEP40 ||
+			   param->value == IW_AUTH_CIPHER_WEP104) {
+			pAdapter->StaCfg.WepStatus = Ndis802_11WEPEnabled;
+			pAdapter->StaCfg.OrigWepStatus =
+			    pAdapter->StaCfg.WepStatus;
+			pAdapter->StaCfg.PairCipher = Ndis802_11WEPEnabled;
+			pAdapter->StaCfg.IEEE8021X = FALSE;
+		} else if (param->value == IW_AUTH_CIPHER_TKIP) {
+			pAdapter->StaCfg.WepStatus =
+			    Ndis802_11Encryption2Enabled;
+			pAdapter->StaCfg.OrigWepStatus =
+			    pAdapter->StaCfg.WepStatus;
+			pAdapter->StaCfg.PairCipher =
+			    Ndis802_11Encryption2Enabled;
+		} else if (param->value == IW_AUTH_CIPHER_CCMP) {
+			pAdapter->StaCfg.WepStatus =
+			    Ndis802_11Encryption3Enabled;
+			pAdapter->StaCfg.OrigWepStatus =
+			    pAdapter->StaCfg.WepStatus;
+			pAdapter->StaCfg.PairCipher =
+			    Ndis802_11Encryption3Enabled;
+		}
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::IW_AUTH_CIPHER_PAIRWISE - param->value = %d!\n",
+			  __func__, param->value));
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+		if (param->value == IW_AUTH_CIPHER_NONE) {
+			pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
+		} else if (param->value == IW_AUTH_CIPHER_WEP40 ||
+			   param->value == IW_AUTH_CIPHER_WEP104) {
+			pAdapter->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
+		} else if (param->value == IW_AUTH_CIPHER_TKIP) {
+			pAdapter->StaCfg.GroupCipher =
+			    Ndis802_11Encryption2Enabled;
+		} else if (param->value == IW_AUTH_CIPHER_CCMP) {
+			pAdapter->StaCfg.GroupCipher =
+			    Ndis802_11Encryption3Enabled;
+		}
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::IW_AUTH_CIPHER_GROUP - param->value = %d!\n",
+			  __func__, param->value));
+		break;
+	case IW_AUTH_KEY_MGMT:
+		if (param->value == IW_AUTH_KEY_MGMT_802_1X) {
+			if (pAdapter->StaCfg.AuthMode ==
+			    Ndis802_11AuthModeWPAPSK) {
+				pAdapter->StaCfg.AuthMode =
+				    Ndis802_11AuthModeWPA;
+				pAdapter->StaCfg.IEEE8021X = FALSE;
+			} else if (pAdapter->StaCfg.AuthMode ==
+				   Ndis802_11AuthModeWPA2PSK) {
+				pAdapter->StaCfg.AuthMode =
+				    Ndis802_11AuthModeWPA2;
+				pAdapter->StaCfg.IEEE8021X = FALSE;
+			} else
+				// WEP 1x
+				pAdapter->StaCfg.IEEE8021X = TRUE;
+		} else if (param->value == 0) {
+			//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+			STA_PORT_SECURED(pAdapter);
+		}
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::IW_AUTH_KEY_MGMT - param->value = %d!\n",
+			  __func__, param->value));
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		break;
+	case IW_AUTH_PRIVACY_INVOKED:
+		/*if (param->value == 0)
+		   {
+		   pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+		   pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
+		   pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
+		   pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
+		   pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
+		   } */
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::IW_AUTH_PRIVACY_INVOKED - param->value = %d!\n",
+			  __func__, param->value));
+		break;
+	case IW_AUTH_DROP_UNENCRYPTED:
+		if (param->value != 0)
+			pAdapter->StaCfg.PortSecured =
+			    WPA_802_1X_PORT_NOT_SECURED;
+		else {
+			//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+			STA_PORT_SECURED(pAdapter);
+		}
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::IW_AUTH_WPA_VERSION - param->value = %d!\n",
+			  __func__, param->value));
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+		if (param->value & IW_AUTH_ALG_SHARED_KEY) {
+			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeShared;
+		} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+		} else
+			return -EINVAL;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::IW_AUTH_80211_AUTH_ALG - param->value = %d!\n",
+			  __func__, param->value));
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::IW_AUTH_WPA_ENABLED - Driver supports WPA!(param->value = %d)\n",
+			  __func__, param->value));
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
 
 	return 0;
 }
 
 int rt_ioctl_giwauth(struct net_device *dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *wrqu, char *extra)
+		     struct iw_request_info *info,
+		     union iwreq_data *wrqu, char *extra)
 {
-	PRTMP_ADAPTER   pAdapter = NULL;
+	PRTMP_ADAPTER pAdapter = NULL;
 	struct iw_param *param = &wrqu->param;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-    //check if the interface is down
-	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    {
-  		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-    	return -ENETDOWN;
-    }
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
+	}
 
 	switch (param->flags & IW_AUTH_INDEX) {
 	case IW_AUTH_DROP_UNENCRYPTED:
-        param->value = (pAdapter->StaCfg.WepStatus == Ndis802_11WEPDisabled) ? 0 : 1;
+		param->value =
+		    (pAdapter->StaCfg.WepStatus ==
+		     Ndis802_11WEPDisabled) ? 0 : 1;
 		break;
 
 	case IW_AUTH_80211_AUTH_ALG:
-        param->value = (pAdapter->StaCfg.AuthMode == Ndis802_11AuthModeShared) ? IW_AUTH_ALG_SHARED_KEY : IW_AUTH_ALG_OPEN_SYSTEM;
+		param->value =
+		    (pAdapter->StaCfg.AuthMode ==
+		     Ndis802_11AuthModeShared) ? IW_AUTH_ALG_SHARED_KEY :
+		    IW_AUTH_ALG_OPEN_SYSTEM;
 		break;
 
 	case IW_AUTH_WPA_ENABLED:
-		param->value = (pAdapter->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) ? 1 : 0;
+		param->value =
+		    (pAdapter->StaCfg.AuthMode >=
+		     Ndis802_11AuthModeWPA) ? 1 : 0;
 		break;
 
 	default:
 		return -EOPNOTSUPP;
 	}
-    DBGPRINT(RT_DEBUG_TRACE, ("rt_ioctl_giwauth::param->value = %d!\n", param->value));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("rt_ioctl_giwauth::param->value = %d!\n", param->value));
 	return 0;
 }
 
-void fnSetCipherKey(
-    IN  PRTMP_ADAPTER   pAdapter,
-    IN  INT             keyIdx,
-    IN  UCHAR           CipherAlg,
-    IN  BOOLEAN         bGTK,
-    IN  struct iw_encode_ext *ext)
-{
-    NdisZeroMemory(&pAdapter->SharedKey[BSS0][keyIdx], sizeof(CIPHER_KEY));
-    pAdapter->SharedKey[BSS0][keyIdx].KeyLen = LEN_TKIP_EK;
-    NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key, ext->key, LEN_TKIP_EK);
-    NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].TxMic, ext->key + LEN_TKIP_EK, LEN_TKIP_TXMICK);
-    NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].RxMic, ext->key + LEN_TKIP_EK + LEN_TKIP_TXMICK, LEN_TKIP_RXMICK);
-    pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CipherAlg;
+void fnSetCipherKey(IN PRTMP_ADAPTER pAdapter,
+		    IN INT keyIdx,
+		    IN UCHAR CipherAlg,
+		    IN BOOLEAN bGTK, IN struct iw_encode_ext *ext)
+{
+	NdisZeroMemory(&pAdapter->SharedKey[BSS0][keyIdx], sizeof(CIPHER_KEY));
+	pAdapter->SharedKey[BSS0][keyIdx].KeyLen = LEN_TKIP_EK;
+	NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key, ext->key,
+		       LEN_TKIP_EK);
+	NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].TxMic,
+		       ext->key + LEN_TKIP_EK, LEN_TKIP_TXMICK);
+	NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].RxMic,
+		       ext->key + LEN_TKIP_EK + LEN_TKIP_TXMICK,
+		       LEN_TKIP_RXMICK);
+	pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CipherAlg;
 
-    // Update group key information to ASIC Shared Key Table
+	// Update group key information to ASIC Shared Key Table
 	AsicAddSharedKeyEntry(pAdapter,
-						  BSS0,
-						  keyIdx,
-						  pAdapter->SharedKey[BSS0][keyIdx].CipherAlg,
-						  pAdapter->SharedKey[BSS0][keyIdx].Key,
-						  pAdapter->SharedKey[BSS0][keyIdx].TxMic,
-						  pAdapter->SharedKey[BSS0][keyIdx].RxMic);
-
-    if (bGTK)
-        // Update ASIC WCID attribute table and IVEIV table
-    	RTMPAddWcidAttributeEntry(pAdapter,
-    							  BSS0,
-    							  keyIdx,
-    							  pAdapter->SharedKey[BSS0][keyIdx].CipherAlg,
-    							  NULL);
-    else
-        // Update ASIC WCID attribute table and IVEIV table
-    	RTMPAddWcidAttributeEntry(pAdapter,
-    							  BSS0,
-    							  keyIdx,
-    							  pAdapter->SharedKey[BSS0][keyIdx].CipherAlg,
-    							  &pAdapter->MacTab.Content[BSSID_WCID]);
+			      BSS0,
+			      keyIdx,
+			      pAdapter->SharedKey[BSS0][keyIdx].CipherAlg,
+			      pAdapter->SharedKey[BSS0][keyIdx].Key,
+			      pAdapter->SharedKey[BSS0][keyIdx].TxMic,
+			      pAdapter->SharedKey[BSS0][keyIdx].RxMic);
+
+	if (bGTK)
+		// Update ASIC WCID attribute table and IVEIV table
+		RTMPAddWcidAttributeEntry(pAdapter,
+					  BSS0,
+					  keyIdx,
+					  pAdapter->SharedKey[BSS0][keyIdx].
+					  CipherAlg, NULL);
+	else
+		// Update ASIC WCID attribute table and IVEIV table
+		RTMPAddWcidAttributeEntry(pAdapter,
+					  BSS0,
+					  keyIdx,
+					  pAdapter->SharedKey[BSS0][keyIdx].
+					  CipherAlg,
+					  &pAdapter->MacTab.
+					  Content[BSSID_WCID]);
 }
 
 int rt_ioctl_siwencodeext(struct net_device *dev,
-			   struct iw_request_info *info,
-			   union iwreq_data *wrqu,
-			   char *extra)
-			{
-	PRTMP_ADAPTER   pAdapter = NULL;
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
+{
+	PRTMP_ADAPTER pAdapter = NULL;
 	struct iw_point *encoding = &wrqu->encoding;
 	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
-    int keyIdx, alg = ext->alg;
+	int keyIdx, alg = ext->alg;
 
 	GET_PAD_FROM_NET_DEV(pAdapter, dev);
 
-    //check if the interface is down
-	if(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-	{
-  		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-    	return -ENETDOWN;
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
 	}
 
-    if (encoding->flags & IW_ENCODE_DISABLED)
-	{
-        keyIdx = (encoding->flags & IW_ENCODE_INDEX) - 1;
-        // set BSSID wcid entry of the Pair-wise Key table as no-security mode
-	    AsicRemovePairwiseKeyEntry(pAdapter, BSS0, BSSID_WCID);
-        pAdapter->SharedKey[BSS0][keyIdx].KeyLen = 0;
+	if (encoding->flags & IW_ENCODE_DISABLED) {
+		keyIdx = (encoding->flags & IW_ENCODE_INDEX) - 1;
+		// set BSSID wcid entry of the Pair-wise Key table as no-security mode
+		AsicRemovePairwiseKeyEntry(pAdapter, BSS0, BSSID_WCID);
+		pAdapter->SharedKey[BSS0][keyIdx].KeyLen = 0;
 		pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_NONE;
-		AsicRemoveSharedKeyEntry(pAdapter, 0, (UCHAR)keyIdx);
-        NdisZeroMemory(&pAdapter->SharedKey[BSS0][keyIdx], sizeof(CIPHER_KEY));
-        DBGPRINT(RT_DEBUG_TRACE, ("%s::Remove all keys!(encoding->flags = %x)\n", __func__, encoding->flags));
-    }
-					else
-    {
-        // Get Key Index and convet to our own defined key index
-    	keyIdx = (encoding->flags & IW_ENCODE_INDEX) - 1;
-    	if((keyIdx < 0) || (keyIdx >= NR_WEP_KEYS))
-    		return -EINVAL;
-
-        if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)
-        {
-            pAdapter->StaCfg.DefaultKeyId = keyIdx;
-            DBGPRINT(RT_DEBUG_TRACE, ("%s::DefaultKeyId = %d\n", __func__, pAdapter->StaCfg.DefaultKeyId));
-        }
-
-        switch (alg) {
-    		case IW_ENCODE_ALG_NONE:
-                DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_ENCODE_ALG_NONE\n", __func__));
-    			break;
-    		case IW_ENCODE_ALG_WEP:
-                DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_ENCODE_ALG_WEP - ext->key_len = %d, keyIdx = %d\n", __func__, ext->key_len, keyIdx));
-    			if (ext->key_len == MAX_WEP_KEY_SIZE)
-                {
-        			pAdapter->SharedKey[BSS0][keyIdx].KeyLen = MAX_WEP_KEY_SIZE;
-                    pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_WEP128;
-				}
-        		else if (ext->key_len == MIN_WEP_KEY_SIZE)
-                {
-                    pAdapter->SharedKey[BSS0][keyIdx].KeyLen = MIN_WEP_KEY_SIZE;
-                    pAdapter->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_WEP64;
-			}
-        		else
-                    return -EINVAL;
+		AsicRemoveSharedKeyEntry(pAdapter, 0, (UCHAR) keyIdx);
+		NdisZeroMemory(&pAdapter->SharedKey[BSS0][keyIdx],
+			       sizeof(CIPHER_KEY));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s::Remove all keys!(encoding->flags = %x)\n",
+			  __func__, encoding->flags));
+	} else {
+		// Get Key Index and convet to our own defined key index
+		keyIdx = (encoding->flags & IW_ENCODE_INDEX) - 1;
+		if ((keyIdx < 0) || (keyIdx >= NR_WEP_KEYS))
+			return -EINVAL;
 
-                NdisZeroMemory(pAdapter->SharedKey[BSS0][keyIdx].Key,  16);
-			    NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key, ext->key, ext->key_len);
-				if (pAdapter->StaCfg.GroupCipher == Ndis802_11GroupWEP40Enabled ||
-					pAdapter->StaCfg.GroupCipher == Ndis802_11GroupWEP104Enabled)
-				{
-					// Set Group key material to Asic
-					AsicAddSharedKeyEntry(pAdapter, BSS0, keyIdx, pAdapter->SharedKey[BSS0][keyIdx].CipherAlg, pAdapter->SharedKey[BSS0][keyIdx].Key, NULL, NULL);
+		if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+			pAdapter->StaCfg.DefaultKeyId = keyIdx;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("%s::DefaultKeyId = %d\n", __func__,
+				  pAdapter->StaCfg.DefaultKeyId));
+		}
+
+		switch (alg) {
+		case IW_ENCODE_ALG_NONE:
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("%s::IW_ENCODE_ALG_NONE\n", __func__));
+			break;
+		case IW_ENCODE_ALG_WEP:
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("%s::IW_ENCODE_ALG_WEP - ext->key_len = %d, keyIdx = %d\n",
+				  __func__, ext->key_len, keyIdx));
+			if (ext->key_len == MAX_WEP_KEY_SIZE) {
+				pAdapter->SharedKey[BSS0][keyIdx].KeyLen =
+				    MAX_WEP_KEY_SIZE;
+				pAdapter->SharedKey[BSS0][keyIdx].CipherAlg =
+				    CIPHER_WEP128;
+			} else if (ext->key_len == MIN_WEP_KEY_SIZE) {
+				pAdapter->SharedKey[BSS0][keyIdx].KeyLen =
+				    MIN_WEP_KEY_SIZE;
+				pAdapter->SharedKey[BSS0][keyIdx].CipherAlg =
+				    CIPHER_WEP64;
+			} else
+				return -EINVAL;
 
-					// Update WCID attribute table and IVEIV table for this group key table
-					RTMPAddWcidAttributeEntry(pAdapter, BSS0, keyIdx, pAdapter->SharedKey[BSS0][keyIdx].CipherAlg, NULL);
+			NdisZeroMemory(pAdapter->SharedKey[BSS0][keyIdx].Key,
+				       16);
+			NdisMoveMemory(pAdapter->SharedKey[BSS0][keyIdx].Key,
+				       ext->key, ext->key_len);
+			if (pAdapter->StaCfg.GroupCipher ==
+			    Ndis802_11GroupWEP40Enabled
+			    || pAdapter->StaCfg.GroupCipher ==
+			    Ndis802_11GroupWEP104Enabled) {
+				// Set Group key material to Asic
+				AsicAddSharedKeyEntry(pAdapter, BSS0, keyIdx,
+						      pAdapter->
+						      SharedKey[BSS0][keyIdx].
+						      CipherAlg,
+						      pAdapter->
+						      SharedKey[BSS0][keyIdx].
+						      Key, NULL, NULL);
 
-					STA_PORT_SECURED(pAdapter);
+				// Update WCID attribute table and IVEIV table for this group key table
+				RTMPAddWcidAttributeEntry(pAdapter, BSS0,
+							  keyIdx,
+							  pAdapter->
+							  SharedKey[BSS0]
+							  [keyIdx].CipherAlg,
+							  NULL);
 
-    				// Indicate Connected for GUI
-    				pAdapter->IndicateMediaState = NdisMediaStateConnected;
+				STA_PORT_SECURED(pAdapter);
+
+				// Indicate Connected for GUI
+				pAdapter->IndicateMediaState =
+				    NdisMediaStateConnected;
+			}
+			break;
+		case IW_ENCODE_ALG_TKIP:
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("%s::IW_ENCODE_ALG_TKIP - keyIdx = %d, ext->key_len = %d\n",
+				  __func__, keyIdx, ext->key_len));
+			if (ext->key_len == 32) {
+				if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+					fnSetCipherKey(pAdapter, keyIdx,
+						       CIPHER_TKIP, FALSE, ext);
+					if (pAdapter->StaCfg.AuthMode >=
+					    Ndis802_11AuthModeWPA2) {
+						//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+						STA_PORT_SECURED(pAdapter);
+						pAdapter->IndicateMediaState =
+						    NdisMediaStateConnected;
+					}
+				} else if (ext->
+					   ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+				{
+					fnSetCipherKey(pAdapter, keyIdx,
+						       CIPHER_TKIP, TRUE, ext);
+
+					// set 802.1x port control
+					//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+					STA_PORT_SECURED(pAdapter);
+					pAdapter->IndicateMediaState =
+					    NdisMediaStateConnected;
 				}
-    			break;
-            case IW_ENCODE_ALG_TKIP:
-                DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_ENCODE_ALG_TKIP - keyIdx = %d, ext->key_len = %d\n", __func__, keyIdx, ext->key_len));
-                if (ext->key_len == 32)
-                {
-                    if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)
-                    {
-                        fnSetCipherKey(pAdapter, keyIdx, CIPHER_TKIP, FALSE, ext);
-                        if (pAdapter->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
-                        {
-                            //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-                            STA_PORT_SECURED(pAdapter);
-			    pAdapter->IndicateMediaState = NdisMediaStateConnected;
-                        }
-		}
-                    else if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
-                    {
-                        fnSetCipherKey(pAdapter, keyIdx, CIPHER_TKIP, TRUE, ext);
-
-                        // set 802.1x port control
-		        //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-            	        STA_PORT_SECURED(pAdapter);
-			pAdapter->IndicateMediaState = NdisMediaStateConnected;
-                    }
-                }
-                else
-                    return -EINVAL;
-                break;
-            case IW_ENCODE_ALG_CCMP:
-                if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)
-		{
-                    fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES, FALSE, ext);
-                    if (pAdapter->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
-			//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-                    	STA_PORT_SECURED(pAdapter);
-			pAdapter->IndicateMediaState = NdisMediaStateConnected;
-                }
-                else if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
-                {
-                    fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES, TRUE, ext);
-
-                    // set 802.1x port control
-		        //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-        	        STA_PORT_SECURED(pAdapter);
-			pAdapter->IndicateMediaState = NdisMediaStateConnected;
-                }
-                break;
-    		default:
-    			return -EINVAL;
+			} else
+				return -EINVAL;
+			break;
+		case IW_ENCODE_ALG_CCMP:
+			if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+				fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES,
+					       FALSE, ext);
+				if (pAdapter->StaCfg.AuthMode >=
+				    Ndis802_11AuthModeWPA2)
+					//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+					STA_PORT_SECURED(pAdapter);
+				pAdapter->IndicateMediaState =
+				    NdisMediaStateConnected;
+			} else if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+				fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES,
+					       TRUE, ext);
+
+				// set 802.1x port control
+				//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+				STA_PORT_SECURED(pAdapter);
+				pAdapter->IndicateMediaState =
+				    NdisMediaStateConnected;
+			}
+			break;
+		default:
+			return -EINVAL;
 		}
-    }
+	}
 
-    return 0;
+	return 0;
 }
 
 int
 rt_ioctl_giwencodeext(struct net_device *dev,
-			  struct iw_request_info *info,
-			  union iwreq_data *wrqu, char *extra)
+		      struct iw_request_info *info,
+		      union iwreq_data *wrqu, char *extra)
 {
 	PRTMP_ADAPTER pAd = NULL;
 	PCHAR pKey = NULL;
@@ -1913,72 +2026,65 @@ rt_ioctl_giwencodeext(struct net_device 
 
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
-	DBGPRINT(RT_DEBUG_TRACE ,("===> rt_ioctl_giwencodeext\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("===> rt_ioctl_giwencodeext\n"));
 
 	max_key_len = encoding->length - sizeof(*ext);
 	if (max_key_len < 0)
 		return -EINVAL;
 
 	idx = encoding->flags & IW_ENCODE_INDEX;
-	if (idx)
-	{
+	if (idx) {
 		if (idx < 1 || idx > 4)
 			return -EINVAL;
 		idx--;
 
 		if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
-			(pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled))
-		{
-			if (idx != pAd->StaCfg.DefaultKeyId)
-			{
+		    (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled)) {
+			if (idx != pAd->StaCfg.DefaultKeyId) {
 				ext->key_len = 0;
 				return 0;
 			}
 		}
-	}
-	else
+	} else
 		idx = pAd->StaCfg.DefaultKeyId;
 
 	encoding->flags = idx + 1;
 	memset(ext, 0, sizeof(*ext));
 
 	ext->key_len = 0;
-	switch(pAd->StaCfg.WepStatus) {
-		case Ndis802_11WEPDisabled:
-			ext->alg = IW_ENCODE_ALG_NONE;
-			encoding->flags |= IW_ENCODE_DISABLED;
-			break;
-		case Ndis802_11WEPEnabled:
-			ext->alg = IW_ENCODE_ALG_WEP;
-			if (pAd->SharedKey[BSS0][idx].KeyLen > max_key_len)
-				return -E2BIG;
-			else
-			{
-				ext->key_len = pAd->SharedKey[BSS0][idx].KeyLen;
-				pKey = (PCHAR)&(pAd->SharedKey[BSS0][idx].Key[0]);
-			}
-			break;
-		case Ndis802_11Encryption2Enabled:
-		case Ndis802_11Encryption3Enabled:
-			if (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
-				ext->alg = IW_ENCODE_ALG_TKIP;
-			else
-				ext->alg = IW_ENCODE_ALG_CCMP;
+	switch (pAd->StaCfg.WepStatus) {
+	case Ndis802_11WEPDisabled:
+		ext->alg = IW_ENCODE_ALG_NONE;
+		encoding->flags |= IW_ENCODE_DISABLED;
+		break;
+	case Ndis802_11WEPEnabled:
+		ext->alg = IW_ENCODE_ALG_WEP;
+		if (pAd->SharedKey[BSS0][idx].KeyLen > max_key_len)
+			return -E2BIG;
+		else {
+			ext->key_len = pAd->SharedKey[BSS0][idx].KeyLen;
+			pKey = (PCHAR) & (pAd->SharedKey[BSS0][idx].Key[0]);
+		}
+		break;
+	case Ndis802_11Encryption2Enabled:
+	case Ndis802_11Encryption3Enabled:
+		if (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
+			ext->alg = IW_ENCODE_ALG_TKIP;
+		else
+			ext->alg = IW_ENCODE_ALG_CCMP;
 
-			if (max_key_len < 32)
-				return -E2BIG;
-			else
-			{
-				ext->key_len = 32;
-				pKey = (PCHAR)&pAd->StaCfg.PMK[0];
-			}
-			break;
-		default:
-			return -EINVAL;
+		if (max_key_len < 32)
+			return -E2BIG;
+		else {
+			ext->key_len = 32;
+			pKey = (PCHAR) & pAd->StaCfg.PMK[0];
+		}
+		break;
+	default:
+		return -EINVAL;
 	}
 
-	if (ext->key_len && pKey)
-	{
+	if (ext->key_len && pKey) {
 		encoding->flags |= IW_ENCODE_ENABLED;
 		memcpy(ext->key, pKey, ext->key_len);
 	}
@@ -1987,27 +2093,25 @@ rt_ioctl_giwencodeext(struct net_device 
 }
 
 int rt_ioctl_siwgenie(struct net_device *dev,
-			  struct iw_request_info *info,
-			  union iwreq_data *wrqu, char *extra)
+		      struct iw_request_info *info,
+		      union iwreq_data *wrqu, char *extra)
 {
-	PRTMP_ADAPTER   pAd = NULL;
+	PRTMP_ADAPTER pAd = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
-	DBGPRINT(RT_DEBUG_TRACE ,("===> rt_ioctl_siwgenie\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("===> rt_ioctl_siwgenie\n"));
 	pAd->StaCfg.bRSN_IE_FromWpaSupplicant = FALSE;
 	if (wrqu->data.length > MAX_LEN_OF_RSNIE ||
 	    (wrqu->data.length && extra == NULL))
 		return -EINVAL;
 
-	if (wrqu->data.length)
-	{
+	if (wrqu->data.length) {
 		pAd->StaCfg.RSNIE_Len = wrqu->data.length;
-		NdisMoveMemory(&pAd->StaCfg.RSN_IE[0], extra, pAd->StaCfg.RSNIE_Len);
+		NdisMoveMemory(&pAd->StaCfg.RSN_IE[0], extra,
+			       pAd->StaCfg.RSNIE_Len);
 		pAd->StaCfg.bRSN_IE_FromWpaSupplicant = TRUE;
-	}
-	else
-	{
+	} else {
 		pAd->StaCfg.RSNIE_Len = 0;
 		NdisZeroMemory(&pAd->StaCfg.RSN_IE[0], MAX_LEN_OF_RSNIE);
 	}
@@ -2016,188 +2120,212 @@ int rt_ioctl_siwgenie(struct net_device 
 }
 
 int rt_ioctl_giwgenie(struct net_device *dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *wrqu, char *extra)
+		      struct iw_request_info *info,
+		      union iwreq_data *wrqu, char *extra)
 {
-	PRTMP_ADAPTER   pAd = NULL;
+	PRTMP_ADAPTER pAd = NULL;
 
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
 	if ((pAd->StaCfg.RSNIE_Len == 0) ||
-		(pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA))
-	{
+	    (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)) {
 		wrqu->data.length = 0;
 		return 0;
 	}
 
-	if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE)
-	{
-	if (wrqu->data.length < pAd->StaCfg.RSNIE_Len)
-		return -E2BIG;
+	if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE) {
+		if (wrqu->data.length < pAd->StaCfg.RSNIE_Len)
+			return -E2BIG;
 
-	wrqu->data.length = pAd->StaCfg.RSNIE_Len;
-	memcpy(extra, &pAd->StaCfg.RSN_IE[0], pAd->StaCfg.RSNIE_Len);
-	}
-	else
-	{
+		wrqu->data.length = pAd->StaCfg.RSNIE_Len;
+		memcpy(extra, &pAd->StaCfg.RSN_IE[0], pAd->StaCfg.RSNIE_Len);
+	} else {
 		UCHAR RSNIe = IE_WPA;
 
-		if (wrqu->data.length < (pAd->StaCfg.RSNIE_Len + 2)) // ID, Len
+		if (wrqu->data.length < (pAd->StaCfg.RSNIE_Len + 2))	// ID, Len
 			return -E2BIG;
 		wrqu->data.length = pAd->StaCfg.RSNIE_Len + 2;
 
 		if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
-            (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2))
+		    (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2))
 			RSNIe = IE_RSN;
 
 		extra[0] = (char)RSNIe;
 		extra[1] = pAd->StaCfg.RSNIE_Len;
-		memcpy(extra+2, &pAd->StaCfg.RSN_IE[0], pAd->StaCfg.RSNIE_Len);
+		memcpy(extra + 2, &pAd->StaCfg.RSN_IE[0],
+		       pAd->StaCfg.RSNIE_Len);
 	}
 
 	return 0;
 }
 
 int rt_ioctl_siwpmksa(struct net_device *dev,
-			   struct iw_request_info *info,
-			   union iwreq_data *wrqu,
-			   char *extra)
+		      struct iw_request_info *info,
+		      union iwreq_data *wrqu, char *extra)
 {
-	PRTMP_ADAPTER   pAd = NULL;
+	PRTMP_ADAPTER pAd = NULL;
 	struct iw_pmksa *pPmksa = (struct iw_pmksa *)wrqu->data.pointer;
-	INT	CachedIdx = 0, idx = 0;
+	INT CachedIdx = 0, idx = 0;
 
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
 	if (pPmksa == NULL)
 		return -EINVAL;
 
-	DBGPRINT(RT_DEBUG_TRACE ,("===> rt_ioctl_siwpmksa\n"));
-	switch(pPmksa->cmd)
-	{
-		case IW_PMKSA_FLUSH:
-			NdisZeroMemory(pAd->StaCfg.SavedPMK, sizeof(BSSID_INFO)*PMKID_NO);
-			DBGPRINT(RT_DEBUG_TRACE ,("rt_ioctl_siwpmksa - IW_PMKSA_FLUSH\n"));
-			break;
-		case IW_PMKSA_REMOVE:
-			for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum; CachedIdx++)
-			{
-		        // compare the BSSID
-		        if (NdisEqualMemory(pPmksa->bssid.sa_data, pAd->StaCfg.SavedPMK[CachedIdx].BSSID, MAC_ADDR_LEN))
-		        {
-		        	NdisZeroMemory(pAd->StaCfg.SavedPMK[CachedIdx].BSSID, MAC_ADDR_LEN);
-					NdisZeroMemory(pAd->StaCfg.SavedPMK[CachedIdx].PMKID, 16);
-					for (idx = CachedIdx; idx < (pAd->StaCfg.SavedPMKNum - 1); idx++)
-					{
-						NdisMoveMemory(&pAd->StaCfg.SavedPMK[idx].BSSID[0], &pAd->StaCfg.SavedPMK[idx+1].BSSID[0], MAC_ADDR_LEN);
-						NdisMoveMemory(&pAd->StaCfg.SavedPMK[idx].PMKID[0], &pAd->StaCfg.SavedPMK[idx+1].PMKID[0], 16);
-					}
-					pAd->StaCfg.SavedPMKNum--;
-			        break;
-		        }
-	        }
-
-			DBGPRINT(RT_DEBUG_TRACE ,("rt_ioctl_siwpmksa - IW_PMKSA_REMOVE\n"));
-			break;
-		case IW_PMKSA_ADD:
-			for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum; CachedIdx++)
-			{
-		        // compare the BSSID
-		        if (NdisEqualMemory(pPmksa->bssid.sa_data, pAd->StaCfg.SavedPMK[CachedIdx].BSSID, MAC_ADDR_LEN))
-			        break;
-	        }
-
-	        // Found, replace it
-	        if (CachedIdx < PMKID_NO)
-	        {
-		        DBGPRINT(RT_DEBUG_OFF, ("Update PMKID, idx = %d\n", CachedIdx));
-		        NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].BSSID[0], pPmksa->bssid.sa_data, MAC_ADDR_LEN);
-				NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].PMKID[0], pPmksa->pmkid, 16);
-		        pAd->StaCfg.SavedPMKNum++;
-	        }
-	        // Not found, replace the last one
-	        else
-	        {
-		        // Randomly replace one
-		        CachedIdx = (pPmksa->bssid.sa_data[5] % PMKID_NO);
-		        DBGPRINT(RT_DEBUG_OFF, ("Update PMKID, idx = %d\n", CachedIdx));
-		        NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].BSSID[0], pPmksa->bssid.sa_data, MAC_ADDR_LEN);
-				NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].PMKID[0], pPmksa->pmkid, 16);
-	        }
+	DBGPRINT(RT_DEBUG_TRACE, ("===> rt_ioctl_siwpmksa\n"));
+	switch (pPmksa->cmd) {
+	case IW_PMKSA_FLUSH:
+		NdisZeroMemory(pAd->StaCfg.SavedPMK,
+			       sizeof(BSSID_INFO) * PMKID_NO);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("rt_ioctl_siwpmksa - IW_PMKSA_FLUSH\n"));
+		break;
+	case IW_PMKSA_REMOVE:
+		for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum;
+		     CachedIdx++) {
+			// compare the BSSID
+			if (NdisEqualMemory
+			    (pPmksa->bssid.sa_data,
+			     pAd->StaCfg.SavedPMK[CachedIdx].BSSID,
+			     MAC_ADDR_LEN)) {
+				NdisZeroMemory(pAd->StaCfg.SavedPMK[CachedIdx].
+					       BSSID, MAC_ADDR_LEN);
+				NdisZeroMemory(pAd->StaCfg.SavedPMK[CachedIdx].
+					       PMKID, 16);
+				for (idx = CachedIdx;
+				     idx < (pAd->StaCfg.SavedPMKNum - 1);
+				     idx++) {
+					NdisMoveMemory(&pAd->StaCfg.
+						       SavedPMK[idx].BSSID[0],
+						       &pAd->StaCfg.
+						       SavedPMK[idx +
+								1].BSSID[0],
+						       MAC_ADDR_LEN);
+					NdisMoveMemory(&pAd->StaCfg.
+						       SavedPMK[idx].PMKID[0],
+						       &pAd->StaCfg.
+						       SavedPMK[idx +
+								1].PMKID[0],
+						       16);
+				}
+				pAd->StaCfg.SavedPMKNum--;
+				break;
+			}
+		}
 
-			DBGPRINT(RT_DEBUG_TRACE ,("rt_ioctl_siwpmksa - IW_PMKSA_ADD\n"));
-			break;
-		default:
-			DBGPRINT(RT_DEBUG_TRACE ,("rt_ioctl_siwpmksa - Unknow Command!!\n"));
-			break;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("rt_ioctl_siwpmksa - IW_PMKSA_REMOVE\n"));
+		break;
+	case IW_PMKSA_ADD:
+		for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum;
+		     CachedIdx++) {
+			// compare the BSSID
+			if (NdisEqualMemory
+			    (pPmksa->bssid.sa_data,
+			     pAd->StaCfg.SavedPMK[CachedIdx].BSSID,
+			     MAC_ADDR_LEN))
+				break;
+		}
+
+		// Found, replace it
+		if (CachedIdx < PMKID_NO) {
+			DBGPRINT(RT_DEBUG_OFF,
+				 ("Update PMKID, idx = %d\n", CachedIdx));
+			NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].
+				       BSSID[0], pPmksa->bssid.sa_data,
+				       MAC_ADDR_LEN);
+			NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].
+				       PMKID[0], pPmksa->pmkid, 16);
+			pAd->StaCfg.SavedPMKNum++;
+		}
+		// Not found, replace the last one
+		else {
+			// Randomly replace one
+			CachedIdx = (pPmksa->bssid.sa_data[5] % PMKID_NO);
+			DBGPRINT(RT_DEBUG_OFF,
+				 ("Update PMKID, idx = %d\n", CachedIdx));
+			NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].
+				       BSSID[0], pPmksa->bssid.sa_data,
+				       MAC_ADDR_LEN);
+			NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].
+				       PMKID[0], pPmksa->pmkid, 16);
+		}
+
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("rt_ioctl_siwpmksa - IW_PMKSA_ADD\n"));
+		break;
+	default:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("rt_ioctl_siwpmksa - Unknow Command!!\n"));
+		break;
 	}
 
 	return 0;
 }
 
 int rt_ioctl_siwrate(struct net_device *dev,
-			struct iw_request_info *info,
-			union iwreq_data *wrqu, char *extra)
+		     struct iw_request_info *info,
+		     union iwreq_data *wrqu, char *extra)
 {
-    PRTMP_ADAPTER   pAd = NULL;
-    UINT32          rate = wrqu->bitrate.value, fixed = wrqu->bitrate.fixed;
+	PRTMP_ADAPTER pAd = NULL;
+	UINT32 rate = wrqu->bitrate.value, fixed = wrqu->bitrate.fixed;
 
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
-    //check if the interface is down
-	if(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-	{
-  		DBGPRINT(RT_DEBUG_TRACE, ("rt_ioctl_siwrate::Network is down!\n"));
-    	return -ENETDOWN;
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("rt_ioctl_siwrate::Network is down!\n"));
+		return -ENETDOWN;
 	}
 
-    DBGPRINT(RT_DEBUG_TRACE, ("rt_ioctl_siwrate::(rate = %d, fixed = %d)\n", rate, fixed));
-    /* rate = -1 => auto rate
-       rate = X, fixed = 1 => (fixed rate X)
-    */
-    if (rate == -1)
-    {
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("rt_ioctl_siwrate::(rate = %d, fixed = %d)\n", rate, fixed));
+	/* rate = -1 => auto rate
+	   rate = X, fixed = 1 => (fixed rate X)
+	 */
+	if (rate == -1) {
 		//Auto Rate
 		pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
 		pAd->StaCfg.bAutoTxRateSwitch = TRUE;
 		if ((pAd->CommonCfg.PhyMode <= PHY_11G) ||
-		    (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <= MODE_OFDM))
+		    (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <=
+		     MODE_OFDM))
 			RTMPSetDesiredRates(pAd, -1);
 
 		SetCommonHT(pAd);
-    }
-    else
-    {
-        if (fixed)
-        {
-        	pAd->StaCfg.bAutoTxRateSwitch = FALSE;
-            if ((pAd->CommonCfg.PhyMode <= PHY_11G) ||
-                (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <= MODE_OFDM))
-                RTMPSetDesiredRates(pAd, rate);
-            else
-            {
-                pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
-                SetCommonHT(pAd);
-            }
-            DBGPRINT(RT_DEBUG_TRACE, ("rt_ioctl_siwrate::(HtMcs=%d)\n",pAd->StaCfg.DesiredTransmitSetting.field.MCS));
-        }
-        else
-        {
-            // TODO: rate = X, fixed = 0 => (rates <= X)
-            return -EOPNOTSUPP;
-        }
-    }
+	} else {
+		if (fixed) {
+			pAd->StaCfg.bAutoTxRateSwitch = FALSE;
+			if ((pAd->CommonCfg.PhyMode <= PHY_11G) ||
+			    (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.
+			     MODE <= MODE_OFDM))
+				RTMPSetDesiredRates(pAd, rate);
+			else {
+				pAd->StaCfg.DesiredTransmitSetting.field.MCS =
+				    MCS_AUTO;
+				SetCommonHT(pAd);
+			}
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("rt_ioctl_siwrate::(HtMcs=%d)\n",
+				  pAd->StaCfg.DesiredTransmitSetting.field.
+				  MCS));
+		} else {
+			// TODO: rate = X, fixed = 0 => (rates <= X)
+			return -EOPNOTSUPP;
+		}
+	}
 
-    return 0;
+	return 0;
 }
 
 int rt_ioctl_giwrate(struct net_device *dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *wrqu, char *extra)
+		     struct iw_request_info *info,
+		     union iwreq_data *wrqu, char *extra)
 {
-    PRTMP_ADAPTER   pAd = NULL;
-    int rate_index = 0, rate_count = 0;
-    HTTRANSMIT_SETTING ht_setting;
+	PRTMP_ADAPTER pAd = NULL;
+	int rate_index = 0, rate_count = 0;
+	HTTRANSMIT_SETTING ht_setting;
 /* Remove to global variable
     __s32 ralinkrate[] =
 	{2,  4,   11,  22, // CCK
@@ -2213,289 +2341,292 @@ int rt_ioctl_giwrate(struct net_device *
 */
 	GET_PAD_FROM_NET_DEV(pAd, dev);
 
-    rate_count = sizeof(ralinkrate)/sizeof(__s32);
-    //check if the interface is down
-	if(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-	{
-  		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-    	return -ENETDOWN;
+	rate_count = sizeof(ralinkrate) / sizeof(__s32);
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+		return -ENETDOWN;
 	}
 
-    if ((pAd->StaCfg.bAutoTxRateSwitch == FALSE) &&
-        (INFRA_ON(pAd)) &&
-        ((pAd->CommonCfg.PhyMode <= PHY_11G) || (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <= MODE_OFDM)))
-        ht_setting.word = pAd->StaCfg.HTPhyMode.word;
-    else
-        ht_setting.word = pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word;
-
-    if (ht_setting.field.MODE >= MODE_HTMIX)
-    {
-//	rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS);
-    	rate_index = 12 + ((UCHAR)ht_setting.field.BW *24) + ((UCHAR)ht_setting.field.ShortGI *48) + ((UCHAR)ht_setting.field.MCS);
-    }
-    else
-    if (ht_setting.field.MODE == MODE_OFDM)
-    	rate_index = (UCHAR)(ht_setting.field.MCS) + 4;
-    else if (ht_setting.field.MODE == MODE_CCK)
-    	rate_index = (UCHAR)(ht_setting.field.MCS);
-
-    if (rate_index < 0)
-        rate_index = 0;
-
-    if (rate_index > rate_count)
-        rate_index = rate_count;
-
-    wrqu->bitrate.value = ralinkrate[rate_index] * 500000;
-    wrqu->bitrate.disabled = 0;
-
-    return 0;
-}
-
-static const iw_handler rt_handler[] =
-{
-	(iw_handler) NULL,			            /* SIOCSIWCOMMIT */
-	(iw_handler) rt_ioctl_giwname,			/* SIOCGIWNAME   */
-	(iw_handler) NULL,			            /* SIOCSIWNWID   */
-	(iw_handler) NULL,			            /* SIOCGIWNWID   */
-	(iw_handler) rt_ioctl_siwfreq,		    /* SIOCSIWFREQ   */
-	(iw_handler) rt_ioctl_giwfreq,		    /* SIOCGIWFREQ   */
-	(iw_handler) rt_ioctl_siwmode,		    /* SIOCSIWMODE   */
-	(iw_handler) rt_ioctl_giwmode,		    /* SIOCGIWMODE   */
-	(iw_handler) NULL,		                /* SIOCSIWSENS   */
-	(iw_handler) NULL,		                /* SIOCGIWSENS   */
-	(iw_handler) NULL /* not used */,		/* SIOCSIWRANGE  */
-	(iw_handler) rt_ioctl_giwrange,		    /* SIOCGIWRANGE  */
-	(iw_handler) NULL /* not used */,		/* SIOCSIWPRIV   */
-	(iw_handler) NULL /* kernel code */,    /* SIOCGIWPRIV   */
-	(iw_handler) NULL /* not used */,		/* SIOCSIWSTATS  */
-	(iw_handler) rt28xx_get_wireless_stats /* kernel code */,    /* SIOCGIWSTATS  */
-	(iw_handler) NULL,		                /* SIOCSIWSPY    */
-	(iw_handler) NULL,		                /* SIOCGIWSPY    */
-	(iw_handler) NULL,				        /* SIOCSIWTHRSPY */
-	(iw_handler) NULL,				        /* SIOCGIWTHRSPY */
-	(iw_handler) rt_ioctl_siwap,            /* SIOCSIWAP     */
-	(iw_handler) rt_ioctl_giwap,		    /* SIOCGIWAP     */
-	(iw_handler) rt_ioctl_siwmlme,	        /* SIOCSIWMLME   */
-	(iw_handler) rt_ioctl_iwaplist,		    /* SIOCGIWAPLIST */
-	(iw_handler) rt_ioctl_siwscan,		    /* SIOCSIWSCAN   */
-	(iw_handler) rt_ioctl_giwscan,		    /* SIOCGIWSCAN   */
-	(iw_handler) rt_ioctl_siwessid,		    /* SIOCSIWESSID  */
-	(iw_handler) rt_ioctl_giwessid,		    /* SIOCGIWESSID  */
-	(iw_handler) rt_ioctl_siwnickn,		    /* SIOCSIWNICKN  */
-	(iw_handler) rt_ioctl_giwnickn,		    /* SIOCGIWNICKN  */
-	(iw_handler) NULL,				        /* -- hole --    */
-	(iw_handler) NULL,				        /* -- hole --    */
-	(iw_handler) rt_ioctl_siwrate,          /* SIOCSIWRATE   */
-	(iw_handler) rt_ioctl_giwrate,          /* SIOCGIWRATE   */
-	(iw_handler) rt_ioctl_siwrts,		    /* SIOCSIWRTS    */
-	(iw_handler) rt_ioctl_giwrts,		    /* SIOCGIWRTS    */
-	(iw_handler) rt_ioctl_siwfrag,		    /* SIOCSIWFRAG   */
-	(iw_handler) rt_ioctl_giwfrag,		    /* SIOCGIWFRAG   */
-	(iw_handler) NULL,		                /* SIOCSIWTXPOW  */
-	(iw_handler) NULL,		                /* SIOCGIWTXPOW  */
-	(iw_handler) NULL,		                /* SIOCSIWRETRY  */
-	(iw_handler) NULL,		                /* SIOCGIWRETRY  */
-	(iw_handler) rt_ioctl_siwencode,		/* SIOCSIWENCODE */
-	(iw_handler) rt_ioctl_giwencode,		/* SIOCGIWENCODE */
-	(iw_handler) NULL,		                /* SIOCSIWPOWER  */
-	(iw_handler) NULL,		                /* SIOCGIWPOWER  */
-	(iw_handler) NULL,						/* -- hole -- */
-	(iw_handler) NULL,						/* -- hole -- */
-    (iw_handler) rt_ioctl_siwgenie,         /* SIOCSIWGENIE  */
-	(iw_handler) rt_ioctl_giwgenie,         /* SIOCGIWGENIE  */
-	(iw_handler) rt_ioctl_siwauth,		    /* SIOCSIWAUTH   */
-	(iw_handler) rt_ioctl_giwauth,		    /* SIOCGIWAUTH   */
-	(iw_handler) rt_ioctl_siwencodeext,	    /* SIOCSIWENCODEEXT */
-	(iw_handler) rt_ioctl_giwencodeext,		/* SIOCGIWENCODEEXT */
-	(iw_handler) rt_ioctl_siwpmksa,         /* SIOCSIWPMKSA  */
+	if ((pAd->StaCfg.bAutoTxRateSwitch == FALSE) &&
+	    (INFRA_ON(pAd)) &&
+	    ((pAd->CommonCfg.PhyMode <= PHY_11G)
+	     || (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <=
+		 MODE_OFDM)))
+		ht_setting.word = pAd->StaCfg.HTPhyMode.word;
+	else
+		ht_setting.word =
+		    pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word;
+
+	if (ht_setting.field.MODE >= MODE_HTMIX) {
+//      rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS);
+		rate_index =
+		    12 + ((UCHAR) ht_setting.field.BW * 24) +
+		    ((UCHAR) ht_setting.field.ShortGI * 48) +
+		    ((UCHAR) ht_setting.field.MCS);
+	} else if (ht_setting.field.MODE == MODE_OFDM)
+		rate_index = (UCHAR) (ht_setting.field.MCS) + 4;
+	else if (ht_setting.field.MODE == MODE_CCK)
+		rate_index = (UCHAR) (ht_setting.field.MCS);
+
+	if (rate_index < 0)
+		rate_index = 0;
+
+	if (rate_index > rate_count)
+		rate_index = rate_count;
+
+	wrqu->bitrate.value = ralinkrate[rate_index] * 500000;
+	wrqu->bitrate.disabled = 0;
+
+	return 0;
+}
+
+static const iw_handler rt_handler[] = {
+	(iw_handler) NULL,	/* SIOCSIWCOMMIT */
+	(iw_handler) rt_ioctl_giwname,	/* SIOCGIWNAME   */
+	(iw_handler) NULL,	/* SIOCSIWNWID   */
+	(iw_handler) NULL,	/* SIOCGIWNWID   */
+	(iw_handler) rt_ioctl_siwfreq,	/* SIOCSIWFREQ   */
+	(iw_handler) rt_ioctl_giwfreq,	/* SIOCGIWFREQ   */
+	(iw_handler) rt_ioctl_siwmode,	/* SIOCSIWMODE   */
+	(iw_handler) rt_ioctl_giwmode,	/* SIOCGIWMODE   */
+	(iw_handler) NULL,	/* SIOCSIWSENS   */
+	(iw_handler) NULL,	/* SIOCGIWSENS   */
+	(iw_handler) NULL /* not used */ ,	/* SIOCSIWRANGE  */
+	(iw_handler) rt_ioctl_giwrange,	/* SIOCGIWRANGE  */
+	(iw_handler) NULL /* not used */ ,	/* SIOCSIWPRIV   */
+	(iw_handler) NULL /* kernel code */ ,	/* SIOCGIWPRIV   */
+	(iw_handler) NULL /* not used */ ,	/* SIOCSIWSTATS  */
+	(iw_handler) rt28xx_get_wireless_stats /* kernel code */ ,	/* SIOCGIWSTATS  */
+	(iw_handler) NULL,	/* SIOCSIWSPY    */
+	(iw_handler) NULL,	/* SIOCGIWSPY    */
+	(iw_handler) NULL,	/* SIOCSIWTHRSPY */
+	(iw_handler) NULL,	/* SIOCGIWTHRSPY */
+	(iw_handler) rt_ioctl_siwap,	/* SIOCSIWAP     */
+	(iw_handler) rt_ioctl_giwap,	/* SIOCGIWAP     */
+	(iw_handler) rt_ioctl_siwmlme,	/* SIOCSIWMLME   */
+	(iw_handler) rt_ioctl_iwaplist,	/* SIOCGIWAPLIST */
+	(iw_handler) rt_ioctl_siwscan,	/* SIOCSIWSCAN   */
+	(iw_handler) rt_ioctl_giwscan,	/* SIOCGIWSCAN   */
+	(iw_handler) rt_ioctl_siwessid,	/* SIOCSIWESSID  */
+	(iw_handler) rt_ioctl_giwessid,	/* SIOCGIWESSID  */
+	(iw_handler) rt_ioctl_siwnickn,	/* SIOCSIWNICKN  */
+	(iw_handler) rt_ioctl_giwnickn,	/* SIOCGIWNICKN  */
+	(iw_handler) NULL,	/* -- hole --    */
+	(iw_handler) NULL,	/* -- hole --    */
+	(iw_handler) rt_ioctl_siwrate,	/* SIOCSIWRATE   */
+	(iw_handler) rt_ioctl_giwrate,	/* SIOCGIWRATE   */
+	(iw_handler) rt_ioctl_siwrts,	/* SIOCSIWRTS    */
+	(iw_handler) rt_ioctl_giwrts,	/* SIOCGIWRTS    */
+	(iw_handler) rt_ioctl_siwfrag,	/* SIOCSIWFRAG   */
+	(iw_handler) rt_ioctl_giwfrag,	/* SIOCGIWFRAG   */
+	(iw_handler) NULL,	/* SIOCSIWTXPOW  */
+	(iw_handler) NULL,	/* SIOCGIWTXPOW  */
+	(iw_handler) NULL,	/* SIOCSIWRETRY  */
+	(iw_handler) NULL,	/* SIOCGIWRETRY  */
+	(iw_handler) rt_ioctl_siwencode,	/* SIOCSIWENCODE */
+	(iw_handler) rt_ioctl_giwencode,	/* SIOCGIWENCODE */
+	(iw_handler) NULL,	/* SIOCSIWPOWER  */
+	(iw_handler) NULL,	/* SIOCGIWPOWER  */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) rt_ioctl_siwgenie,	/* SIOCSIWGENIE  */
+	(iw_handler) rt_ioctl_giwgenie,	/* SIOCGIWGENIE  */
+	(iw_handler) rt_ioctl_siwauth,	/* SIOCSIWAUTH   */
+	(iw_handler) rt_ioctl_giwauth,	/* SIOCGIWAUTH   */
+	(iw_handler) rt_ioctl_siwencodeext,	/* SIOCSIWENCODEEXT */
+	(iw_handler) rt_ioctl_giwencodeext,	/* SIOCGIWENCODEEXT */
+	(iw_handler) rt_ioctl_siwpmksa,	/* SIOCSIWPMKSA  */
 };
 
-const struct iw_handler_def rt28xx_iw_handler_def =
-{
-	.standard	= (iw_handler *) rt_handler,
-	.num_standard	= sizeof(rt_handler) / sizeof(iw_handler),
+const struct iw_handler_def rt28xx_iw_handler_def = {
+	.standard = (iw_handler *) rt_handler,
+	.num_standard = sizeof(rt_handler) / sizeof(iw_handler),
 #if IW_HANDLER_VERSION >= 7
-    .get_wireless_stats = rt28xx_get_wireless_stats,
+	.get_wireless_stats = rt28xx_get_wireless_stats,
 #endif
 };
 
-INT rt28xx_sta_ioctl(
-	IN	struct net_device	*net_dev,
-	IN	OUT	struct ifreq	*rq,
-	IN	INT					cmd)
-{
-	POS_COOKIE			pObj;
-	RTMP_ADAPTER        *pAd = NULL;
-	struct iwreq        *wrq = (struct iwreq *) rq;
-	BOOLEAN				StateMachineTouched = FALSE;
-	INT					Status = NDIS_STATUS_SUCCESS;
+INT rt28xx_sta_ioctl(IN struct net_device *net_dev,
+		     IN OUT struct ifreq *rq, IN INT cmd)
+{
+	POS_COOKIE pObj;
+	RTMP_ADAPTER *pAd = NULL;
+	struct iwreq *wrq = (struct iwreq *)rq;
+	BOOLEAN StateMachineTouched = FALSE;
+	INT Status = NDIS_STATUS_SUCCESS;
 
 	GET_PAD_FROM_NET_DEV(pAd, net_dev);
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-    //check if the interface is down
-    if(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE))
-    {
-        {
-            DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
-		    return -ENETDOWN;
-        }
-    }
+	//check if the interface is down
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
+		{
+			DBGPRINT(RT_DEBUG_TRACE, ("INFO::Network is down!\n"));
+			return -ENETDOWN;
+		}
+	}
 
-	{	// determine this ioctl command is comming from which interface.
+	{			// determine this ioctl command is comming from which interface.
 		pObj->ioctl_if_type = INT_MAIN;
 		pObj->ioctl_if = MAIN_MBSSID;
 	}
 
-	switch(cmd)
-	{
-        case SIOCGIFHWADDR:
-			DBGPRINT(RT_DEBUG_TRACE, ("IOCTL::SIOCGIFHWADDR\n"));
-			memcpy(wrq->u.name, pAd->CurrentAddress, ETH_ALEN);
-			break;
-		case SIOCGIWNAME:
-        {
-        	char *name=&wrq->u.name[0];
-        	rt_ioctl_giwname(net_dev, NULL, name, NULL);
+	switch (cmd) {
+	case SIOCGIFHWADDR:
+		DBGPRINT(RT_DEBUG_TRACE, ("IOCTL::SIOCGIFHWADDR\n"));
+		memcpy(wrq->u.name, pAd->CurrentAddress, ETH_ALEN);
+		break;
+	case SIOCGIWNAME:
+		{
+			char *name = &wrq->u.name[0];
+			rt_ioctl_giwname(net_dev, NULL, name, NULL);
 			break;
 		}
-		case SIOCGIWESSID:  //Get ESSID
-        {
-        	struct iw_point *essid=&wrq->u.essid;
-        	rt_ioctl_giwessid(net_dev, NULL, essid, essid->pointer);
+	case SIOCGIWESSID:	//Get ESSID
+		{
+			struct iw_point *essid = &wrq->u.essid;
+			rt_ioctl_giwessid(net_dev, NULL, essid, essid->pointer);
 			break;
 		}
-		case SIOCSIWESSID:  //Set ESSID
-        {
-        	struct iw_point	*essid=&wrq->u.essid;
-        	rt_ioctl_siwessid(net_dev, NULL, essid, essid->pointer);
+	case SIOCSIWESSID:	//Set ESSID
+		{
+			struct iw_point *essid = &wrq->u.essid;
+			rt_ioctl_siwessid(net_dev, NULL, essid, essid->pointer);
 			break;
 		}
-		case SIOCSIWNWID:   // set network id (the cell)
-		case SIOCGIWNWID:   // get network id
-			Status = -EOPNOTSUPP;
-			break;
-		case SIOCSIWFREQ:   //set channel/frequency (Hz)
-        {
-        	struct iw_freq *freq=&wrq->u.freq;
-        	rt_ioctl_siwfreq(net_dev, NULL, freq, NULL);
+	case SIOCSIWNWID:	// set network id (the cell)
+	case SIOCGIWNWID:	// get network id
+		Status = -EOPNOTSUPP;
+		break;
+	case SIOCSIWFREQ:	//set channel/frequency (Hz)
+		{
+			struct iw_freq *freq = &wrq->u.freq;
+			rt_ioctl_siwfreq(net_dev, NULL, freq, NULL);
 			break;
 		}
-		case SIOCGIWFREQ:   // get channel/frequency (Hz)
-        {
-        	struct iw_freq *freq=&wrq->u.freq;
-        	rt_ioctl_giwfreq(net_dev, NULL, freq, NULL);
+	case SIOCGIWFREQ:	// get channel/frequency (Hz)
+		{
+			struct iw_freq *freq = &wrq->u.freq;
+			rt_ioctl_giwfreq(net_dev, NULL, freq, NULL);
 			break;
 		}
-		case SIOCSIWNICKN: //set node name/nickname
-        {
-		//struct iw_point *data=&wrq->u.data;
-		//rt_ioctl_siwnickn(net_dev, NULL, data, NULL);
+	case SIOCSIWNICKN:	//set node name/nickname
+		{
+			//struct iw_point *data=&wrq->u.data;
+			//rt_ioctl_siwnickn(net_dev, NULL, data, NULL);
 			break;
 		}
-		case SIOCGIWNICKN: //get node name/nickname
-        {
-			struct iw_point	*erq = NULL;
-		erq = &wrq->u.data;
-            erq->length = strlen((PSTRING) pAd->nickname);
-            Status = copy_to_user(erq->pointer, pAd->nickname, erq->length);
+	case SIOCGIWNICKN:	//get node name/nickname
+		{
+			struct iw_point *erq = NULL;
+			erq = &wrq->u.data;
+			erq->length = strlen((PSTRING) pAd->nickname);
+			Status =
+			    copy_to_user(erq->pointer, pAd->nickname,
+					 erq->length);
 			break;
 		}
-		case SIOCGIWRATE:   //get default bit rate (bps)
-		    rt_ioctl_giwrate(net_dev, NULL, &wrq->u, NULL);
-            break;
-	    case SIOCSIWRATE:  //set default bit rate (bps)
-	        rt_ioctl_siwrate(net_dev, NULL, &wrq->u, NULL);
-            break;
-        case SIOCGIWRTS:  // get RTS/CTS threshold (bytes)
-        {
-        	struct iw_param *rts=&wrq->u.rts;
-        	rt_ioctl_giwrts(net_dev, NULL, rts, NULL);
+	case SIOCGIWRATE:	//get default bit rate (bps)
+		rt_ioctl_giwrate(net_dev, NULL, &wrq->u, NULL);
+		break;
+	case SIOCSIWRATE:	//set default bit rate (bps)
+		rt_ioctl_siwrate(net_dev, NULL, &wrq->u, NULL);
+		break;
+	case SIOCGIWRTS:	// get RTS/CTS threshold (bytes)
+		{
+			struct iw_param *rts = &wrq->u.rts;
+			rt_ioctl_giwrts(net_dev, NULL, rts, NULL);
 			break;
 		}
-        case SIOCSIWRTS:  //set RTS/CTS threshold (bytes)
-        {
-        	struct iw_param *rts=&wrq->u.rts;
-        	rt_ioctl_siwrts(net_dev, NULL, rts, NULL);
+	case SIOCSIWRTS:	//set RTS/CTS threshold (bytes)
+		{
+			struct iw_param *rts = &wrq->u.rts;
+			rt_ioctl_siwrts(net_dev, NULL, rts, NULL);
 			break;
 		}
-        case SIOCGIWFRAG:  //get fragmentation thr (bytes)
-        {
-        	struct iw_param *frag=&wrq->u.frag;
-        	rt_ioctl_giwfrag(net_dev, NULL, frag, NULL);
+	case SIOCGIWFRAG:	//get fragmentation thr (bytes)
+		{
+			struct iw_param *frag = &wrq->u.frag;
+			rt_ioctl_giwfrag(net_dev, NULL, frag, NULL);
 			break;
 		}
-        case SIOCSIWFRAG:  //set fragmentation thr (bytes)
-        {
-        	struct iw_param *frag=&wrq->u.frag;
-        	rt_ioctl_siwfrag(net_dev, NULL, frag, NULL);
+	case SIOCSIWFRAG:	//set fragmentation thr (bytes)
+		{
+			struct iw_param *frag = &wrq->u.frag;
+			rt_ioctl_siwfrag(net_dev, NULL, frag, NULL);
 			break;
 		}
-        case SIOCGIWENCODE:  //get encoding token & mode
-        {
-        	struct iw_point *erq=&wrq->u.encoding;
-		if(erq)
-        		rt_ioctl_giwencode(net_dev, NULL, erq, erq->pointer);
+	case SIOCGIWENCODE:	//get encoding token & mode
+		{
+			struct iw_point *erq = &wrq->u.encoding;
+			if (erq)
+				rt_ioctl_giwencode(net_dev, NULL, erq,
+						   erq->pointer);
 			break;
 		}
-        case SIOCSIWENCODE:  //set encoding token & mode
-        {
-        	struct iw_point *erq=&wrq->u.encoding;
-		if(erq)
-        		rt_ioctl_siwencode(net_dev, NULL, erq, erq->pointer);
+	case SIOCSIWENCODE:	//set encoding token & mode
+		{
+			struct iw_point *erq = &wrq->u.encoding;
+			if (erq)
+				rt_ioctl_siwencode(net_dev, NULL, erq,
+						   erq->pointer);
 			break;
 		}
-		case SIOCGIWAP:     //get access point MAC addresses
-        {
-        	struct sockaddr *ap_addr=&wrq->u.ap_addr;
-        	rt_ioctl_giwap(net_dev, NULL, ap_addr, ap_addr->sa_data);
+	case SIOCGIWAP:	//get access point MAC addresses
+		{
+			struct sockaddr *ap_addr = &wrq->u.ap_addr;
+			rt_ioctl_giwap(net_dev, NULL, ap_addr,
+				       ap_addr->sa_data);
 			break;
 		}
-	    case SIOCSIWAP:  //set access point MAC addresses
-        {
-        	struct sockaddr *ap_addr=&wrq->u.ap_addr;
-        	rt_ioctl_siwap(net_dev, NULL, ap_addr, ap_addr->sa_data);
+	case SIOCSIWAP:	//set access point MAC addresses
+		{
+			struct sockaddr *ap_addr = &wrq->u.ap_addr;
+			rt_ioctl_siwap(net_dev, NULL, ap_addr,
+				       ap_addr->sa_data);
 			break;
 		}
-		case SIOCGIWMODE:   //get operation mode
-        {
-        	__u32 *mode=&wrq->u.mode;
-        	rt_ioctl_giwmode(net_dev, NULL, mode, NULL);
+	case SIOCGIWMODE:	//get operation mode
+		{
+			__u32 *mode = &wrq->u.mode;
+			rt_ioctl_giwmode(net_dev, NULL, mode, NULL);
 			break;
 		}
-		case SIOCSIWMODE:   //set operation mode
-        {
-        	__u32 *mode=&wrq->u.mode;
-        	rt_ioctl_siwmode(net_dev, NULL, mode, NULL);
+	case SIOCSIWMODE:	//set operation mode
+		{
+			__u32 *mode = &wrq->u.mode;
+			rt_ioctl_siwmode(net_dev, NULL, mode, NULL);
 			break;
 		}
-		case SIOCGIWSENS:   //get sensitivity (dBm)
-		case SIOCSIWSENS:	//set sensitivity (dBm)
-		case SIOCGIWPOWER:  //get Power Management settings
-		case SIOCSIWPOWER:  //set Power Management settings
-		case SIOCGIWTXPOW:  //get transmit power (dBm)
-		case SIOCSIWTXPOW:  //set transmit power (dBm)
-		case SIOCGIWRANGE:	//Get range of parameters
-		case SIOCGIWRETRY:	//get retry limits and lifetime
-		case SIOCSIWRETRY:	//set retry limits and lifetime
-		case RT_PRIV_IOCTL:
-		case RT_PRIV_IOCTL_EXT:
-		case RTPRIV_IOCTL_SET:
-		case RTPRIV_IOCTL_GSITESURVEY:
-		case SIOCGIWPRIV:
-			Status = -EOPNOTSUPP;
-			break;
-        case SIOCETHTOOL:
-                break;
-		default:
-			DBGPRINT(RT_DEBUG_ERROR, ("IOCTL::unknown IOCTL's cmd = 0x%08x\n", cmd));
-			Status = -EOPNOTSUPP;
-			break;
+	case SIOCGIWSENS:	//get sensitivity (dBm)
+	case SIOCSIWSENS:	//set sensitivity (dBm)
+	case SIOCGIWPOWER:	//get Power Management settings
+	case SIOCSIWPOWER:	//set Power Management settings
+	case SIOCGIWTXPOW:	//get transmit power (dBm)
+	case SIOCSIWTXPOW:	//set transmit power (dBm)
+	case SIOCGIWRANGE:	//Get range of parameters
+	case SIOCGIWRETRY:	//get retry limits and lifetime
+	case SIOCSIWRETRY:	//set retry limits and lifetime
+	case RT_PRIV_IOCTL:
+	case RT_PRIV_IOCTL_EXT:
+	case RTPRIV_IOCTL_SET:
+	case RTPRIV_IOCTL_GSITESURVEY:
+	case SIOCGIWPRIV:
+		Status = -EOPNOTSUPP;
+		break;
+	case SIOCETHTOOL:
+		break;
+	default:
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("IOCTL::unknown IOCTL's cmd = 0x%08x\n", cmd));
+		Status = -EOPNOTSUPP;
+		break;
 	}
 
-    if(StateMachineTouched) // Upper layer sent a MLME-related operations
-	RTMP_MLME_HANDLER(pAd);
+	if (StateMachineTouched)	// Upper layer sent a MLME-related operations
+		RTMP_MLME_HANDLER(pAd);
 
 	return Status;
 }
@@ -2508,77 +2639,75 @@ INT rt28xx_sta_ioctl(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
 */
-INT Set_SSID_Proc(
-    IN  PRTMP_ADAPTER   pAdapter,
-    IN  PSTRING          arg)
-{
-    NDIS_802_11_SSID                    Ssid, *pSsid=NULL;
-    BOOLEAN                             StateMachineTouched = FALSE;
-    int                                 success = TRUE;
-
-    if( strlen(arg) <= MAX_LEN_OF_SSID)
-    {
-        NdisZeroMemory(&Ssid, sizeof(NDIS_802_11_SSID));
-        if (strlen(arg) != 0)
-        {
-            NdisMoveMemory(Ssid.Ssid, arg, strlen(arg));
-            Ssid.SsidLength = strlen(arg);
-        }
-        else   //ANY ssid
-        {
-            Ssid.SsidLength = 0;
-		    memcpy(Ssid.Ssid, "", 0);
+INT Set_SSID_Proc(IN PRTMP_ADAPTER pAdapter, IN PSTRING arg)
+{
+	NDIS_802_11_SSID Ssid, *pSsid = NULL;
+	BOOLEAN StateMachineTouched = FALSE;
+	int success = TRUE;
+
+	if (strlen(arg) <= MAX_LEN_OF_SSID) {
+		NdisZeroMemory(&Ssid, sizeof(NDIS_802_11_SSID));
+		if (strlen(arg) != 0) {
+			NdisMoveMemory(Ssid.Ssid, arg, strlen(arg));
+			Ssid.SsidLength = strlen(arg);
+		} else		//ANY ssid
+		{
+			Ssid.SsidLength = 0;
+			memcpy(Ssid.Ssid, "", 0);
 			pAdapter->StaCfg.BssType = BSS_INFRA;
 			pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-	        pAdapter->StaCfg.WepStatus  = Ndis802_11EncryptionDisabled;
+			pAdapter->StaCfg.WepStatus =
+			    Ndis802_11EncryptionDisabled;
 		}
-        pSsid = &Ssid;
+		pSsid = &Ssid;
 
-        if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
-        {
-            RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
-            DBGPRINT(RT_DEBUG_TRACE, ("!!! MLME busy, reset MLME state machine !!!\n"));
-        }
+		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) {
+			RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("!!! MLME busy, reset MLME state machine !!!\n"));
+		}
 
 		if ((pAdapter->StaCfg.WpaPassPhraseLen >= 8) &&
-			(pAdapter->StaCfg.WpaPassPhraseLen <= 64))
-		{
-			STRING passphrase_str[65] = {0};
+		    (pAdapter->StaCfg.WpaPassPhraseLen <= 64)) {
+			STRING passphrase_str[65] = { 0 };
 			UCHAR keyMaterial[40];
 
-			RTMPMoveMemory(passphrase_str, pAdapter->StaCfg.WpaPassPhrase, pAdapter->StaCfg.WpaPassPhraseLen);
+			RTMPMoveMemory(passphrase_str,
+				       pAdapter->StaCfg.WpaPassPhrase,
+				       pAdapter->StaCfg.WpaPassPhraseLen);
 			RTMPZeroMemory(pAdapter->StaCfg.PMK, 32);
-			if (pAdapter->StaCfg.WpaPassPhraseLen == 64)
-			{
-			    AtoH((PSTRING) pAdapter->StaCfg.WpaPassPhrase, pAdapter->StaCfg.PMK, 32);
-			}
-			else
-			{
-			    PasswordHash((PSTRING) pAdapter->StaCfg.WpaPassPhrase, Ssid.Ssid, Ssid.SsidLength, keyMaterial);
-			    NdisMoveMemory(pAdapter->StaCfg.PMK, keyMaterial, 32);
+			if (pAdapter->StaCfg.WpaPassPhraseLen == 64) {
+				AtoH((PSTRING) pAdapter->StaCfg.WpaPassPhrase,
+				     pAdapter->StaCfg.PMK, 32);
+			} else {
+				PasswordHash((PSTRING) pAdapter->StaCfg.
+					     WpaPassPhrase, Ssid.Ssid,
+					     Ssid.SsidLength, keyMaterial);
+				NdisMoveMemory(pAdapter->StaCfg.PMK,
+					       keyMaterial, 32);
 			}
 		}
 
-        pAdapter->MlmeAux.CurrReqIsFromNdis = TRUE;
-        pAdapter->StaCfg.bScanReqIsFromWebUI = FALSE;
+		pAdapter->MlmeAux.CurrReqIsFromNdis = TRUE;
+		pAdapter->StaCfg.bScanReqIsFromWebUI = FALSE;
 		pAdapter->bConfigChanged = TRUE;
 
-        MlmeEnqueue(pAdapter,
-                    MLME_CNTL_STATE_MACHINE,
-                    OID_802_11_SSID,
-                    sizeof(NDIS_802_11_SSID),
-                    (VOID *)pSsid);
-
-        StateMachineTouched = TRUE;
-        DBGPRINT(RT_DEBUG_TRACE, ("Set_SSID_Proc::(Len=%d,Ssid=%s)\n", Ssid.SsidLength, Ssid.Ssid));
-    }
-    else
-        success = FALSE;
+		MlmeEnqueue(pAdapter,
+			    MLME_CNTL_STATE_MACHINE,
+			    OID_802_11_SSID,
+			    sizeof(NDIS_802_11_SSID), (VOID *) pSsid);
+
+		StateMachineTouched = TRUE;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Set_SSID_Proc::(Len=%d,Ssid=%s)\n", Ssid.SsidLength,
+			  Ssid.Ssid));
+	} else
+		success = FALSE;
 
-    if (StateMachineTouched) // Upper layer sent a MLME-related operations
-	RTMP_MLME_HANDLER(pAdapter);
+	if (StateMachineTouched)	// Upper layer sent a MLME-related operations
+		RTMP_MLME_HANDLER(pAdapter);
 
-    return success;
+	return success;
 }
 
 /*
@@ -2589,156 +2718,176 @@ INT Set_SSID_Proc(
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
 */
-INT Set_NetworkType_Proc(
-    IN  PRTMP_ADAPTER   pAdapter,
-    IN  PSTRING          arg)
+INT Set_NetworkType_Proc(IN PRTMP_ADAPTER pAdapter, IN PSTRING arg)
 {
-    UINT32	Value = 0;
+	UINT32 Value = 0;
 
-    if (strcmp(arg, "Adhoc") == 0)
-	{
-		if (pAdapter->StaCfg.BssType != BSS_ADHOC)
-		{
+	if (strcmp(arg, "Adhoc") == 0) {
+		if (pAdapter->StaCfg.BssType != BSS_ADHOC) {
 			// Config has changed
 			pAdapter->bConfigChanged = TRUE;
-            if (MONITOR_ON(pAdapter))
-            {
-                RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG, STANORMAL);
-                RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value);
+			if (MONITOR_ON(pAdapter)) {
+				RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG,
+						STANORMAL);
+				RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value);
 				Value &= (~0x80);
 				RTMP_IO_WRITE32(pAdapter, MAC_SYS_CTRL, Value);
-                OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED);
-                pAdapter->StaCfg.bAutoReconnect = TRUE;
-                LinkDown(pAdapter, FALSE);
-            }
-			if (INFRA_ON(pAdapter))
-			{
+				OPSTATUS_CLEAR_FLAG(pAdapter,
+						    fOP_STATUS_MEDIA_STATE_CONNECTED);
+				pAdapter->StaCfg.bAutoReconnect = TRUE;
+				LinkDown(pAdapter, FALSE);
+			}
+			if (INFRA_ON(pAdapter)) {
 				//BOOLEAN Cancelled;
 				// Set the AutoReconnectSsid to prevent it reconnect to old SSID
 				// Since calling this indicate user don't want to connect to that SSID anymore.
-				pAdapter->MlmeAux.AutoReconnectSsidLen= 32;
-				NdisZeroMemory(pAdapter->MlmeAux.AutoReconnectSsid, pAdapter->MlmeAux.AutoReconnectSsidLen);
+				pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
+				NdisZeroMemory(pAdapter->MlmeAux.
+					       AutoReconnectSsid,
+					       pAdapter->MlmeAux.
+					       AutoReconnectSsidLen);
 
 				LinkDown(pAdapter, FALSE);
 
-				DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_DISCONNECT Event BB!\n"));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("NDIS_STATUS_MEDIA_DISCONNECT Event BB!\n"));
 			}
 		}
 		pAdapter->StaCfg.BssType = BSS_ADHOC;
-        pAdapter->net_dev->type = pAdapter->StaCfg.OriDevType;
-		DBGPRINT(RT_DEBUG_TRACE, ("===>Set_NetworkType_Proc::(AD-HOC)\n"));
-	}
-    else if (strcmp(arg, "Infra") == 0)
-	{
-		if (pAdapter->StaCfg.BssType != BSS_INFRA)
-		{
+		pAdapter->net_dev->type = pAdapter->StaCfg.OriDevType;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("===>Set_NetworkType_Proc::(AD-HOC)\n"));
+	} else if (strcmp(arg, "Infra") == 0) {
+		if (pAdapter->StaCfg.BssType != BSS_INFRA) {
 			// Config has changed
 			pAdapter->bConfigChanged = TRUE;
-            if (MONITOR_ON(pAdapter))
-            {
-                RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG, STANORMAL);
-                RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value);
+			if (MONITOR_ON(pAdapter)) {
+				RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG,
+						STANORMAL);
+				RTMP_IO_READ32(pAdapter, MAC_SYS_CTRL, &Value);
 				Value &= (~0x80);
 				RTMP_IO_WRITE32(pAdapter, MAC_SYS_CTRL, Value);
-                OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED);
-                pAdapter->StaCfg.bAutoReconnect = TRUE;
-                LinkDown(pAdapter, FALSE);
-            }
-			if (ADHOC_ON(pAdapter))
-			{
+				OPSTATUS_CLEAR_FLAG(pAdapter,
+						    fOP_STATUS_MEDIA_STATE_CONNECTED);
+				pAdapter->StaCfg.bAutoReconnect = TRUE;
+				LinkDown(pAdapter, FALSE);
+			}
+			if (ADHOC_ON(pAdapter)) {
 				// Set the AutoReconnectSsid to prevent it reconnect to old SSID
 				// Since calling this indicate user don't want to connect to that SSID anymore.
-				pAdapter->MlmeAux.AutoReconnectSsidLen= 32;
-				NdisZeroMemory(pAdapter->MlmeAux.AutoReconnectSsid, pAdapter->MlmeAux.AutoReconnectSsidLen);
+				pAdapter->MlmeAux.AutoReconnectSsidLen = 32;
+				NdisZeroMemory(pAdapter->MlmeAux.
+					       AutoReconnectSsid,
+					       pAdapter->MlmeAux.
+					       AutoReconnectSsidLen);
 
 				LinkDown(pAdapter, FALSE);
 			}
 		}
 		pAdapter->StaCfg.BssType = BSS_INFRA;
-        pAdapter->net_dev->type = pAdapter->StaCfg.OriDevType;
-		DBGPRINT(RT_DEBUG_TRACE, ("===>Set_NetworkType_Proc::(INFRA)\n"));
-	}
-    else if (strcmp(arg, "Monitor") == 0)
-    {
-		UCHAR	bbpValue = 0;
+		pAdapter->net_dev->type = pAdapter->StaCfg.OriDevType;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("===>Set_NetworkType_Proc::(INFRA)\n"));
+	} else if (strcmp(arg, "Monitor") == 0) {
+		UCHAR bbpValue = 0;
 		BCN_TIME_CFG_STRUC csr;
 		OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_INFRA_ON);
-        OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_ADHOC_ON);
+		OPSTATUS_CLEAR_FLAG(pAdapter, fOP_STATUS_ADHOC_ON);
 		OPSTATUS_SET_FLAG(pAdapter, fOP_STATUS_MEDIA_STATE_CONNECTED);
 		// disable all periodic state machine
 		pAdapter->StaCfg.bAutoReconnect = FALSE;
 		// reset all mlme state machine
-			RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
-		DBGPRINT(RT_DEBUG_TRACE, ("fOP_STATUS_MEDIA_STATE_CONNECTED \n"));
-        if (pAdapter->CommonCfg.CentralChannel == 0)
-        {
-            if (pAdapter->CommonCfg.PhyMode == PHY_11AN_MIXED)
-                pAdapter->CommonCfg.CentralChannel = 36;
-            else
-                pAdapter->CommonCfg.CentralChannel = 6;
-        }
-        else
-            N_ChannelCheck(pAdapter);
-
-	if (pAdapter->CommonCfg.PhyMode >= PHY_11ABGN_MIXED &&
-            pAdapter->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
-            pAdapter->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
-		{
+		RTMP_MLME_RESET_STATE_MACHINE(pAdapter);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("fOP_STATUS_MEDIA_STATE_CONNECTED \n"));
+		if (pAdapter->CommonCfg.CentralChannel == 0) {
+			if (pAdapter->CommonCfg.PhyMode == PHY_11AN_MIXED)
+				pAdapter->CommonCfg.CentralChannel = 36;
+			else
+				pAdapter->CommonCfg.CentralChannel = 6;
+		} else
+			N_ChannelCheck(pAdapter);
+
+		if (pAdapter->CommonCfg.PhyMode >= PHY_11ABGN_MIXED &&
+		    pAdapter->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
+		    pAdapter->CommonCfg.RegTransmitSetting.field.EXTCHA ==
+		    EXTCHA_ABOVE) {
 			// 40MHz ,control channel at lower
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4, &bbpValue);
+			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
+						    &bbpValue);
 			bbpValue &= (~0x18);
 			bbpValue |= 0x10;
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4, bbpValue);
+			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4,
+						     bbpValue);
 			pAdapter->CommonCfg.BBPCurrentBW = BW_40;
 			//  RX : control channel at lower
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R3, &bbpValue);
+			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R3,
+						    &bbpValue);
 			bbpValue &= (~0x20);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R3, bbpValue);
+			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R3,
+						     bbpValue);
 
 			RTMP_IO_READ32(pAdapter, TX_BAND_CFG, &Value);
 			Value &= 0xfffffffe;
 			RTMP_IO_WRITE32(pAdapter, TX_BAND_CFG, Value);
-			pAdapter->CommonCfg.CentralChannel = pAdapter->CommonCfg.Channel + 2;
-            AsicSwitchChannel(pAdapter, pAdapter->CommonCfg.CentralChannel, FALSE);
-		    AsicLockChannel(pAdapter, pAdapter->CommonCfg.CentralChannel);
-            DBGPRINT(RT_DEBUG_TRACE, ("BW_40 ,control_channel(%d), CentralChannel(%d) \n",
-                                       pAdapter->CommonCfg.Channel,
-                                       pAdapter->CommonCfg.CentralChannel));
-		}
-		else if (pAdapter->CommonCfg.PhyMode >= PHY_11ABGN_MIXED &&
-                 pAdapter->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
-                 pAdapter->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_BELOW)
-		{
+			pAdapter->CommonCfg.CentralChannel =
+			    pAdapter->CommonCfg.Channel + 2;
+			AsicSwitchChannel(pAdapter,
+					  pAdapter->CommonCfg.CentralChannel,
+					  FALSE);
+			AsicLockChannel(pAdapter,
+					pAdapter->CommonCfg.CentralChannel);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BW_40 ,control_channel(%d), CentralChannel(%d) \n",
+				  pAdapter->CommonCfg.Channel,
+				  pAdapter->CommonCfg.CentralChannel));
+		} else if (pAdapter->CommonCfg.PhyMode >= PHY_11ABGN_MIXED
+			   && pAdapter->CommonCfg.RegTransmitSetting.field.BW ==
+			   BW_40
+			   && pAdapter->CommonCfg.RegTransmitSetting.field.
+			   EXTCHA == EXTCHA_BELOW) {
 			// 40MHz ,control channel at upper
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4, &bbpValue);
+			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
+						    &bbpValue);
 			bbpValue &= (~0x18);
 			bbpValue |= 0x10;
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4, bbpValue);
+			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4,
+						     bbpValue);
 			pAdapter->CommonCfg.BBPCurrentBW = BW_40;
 			RTMP_IO_READ32(pAdapter, TX_BAND_CFG, &Value);
 			Value |= 0x1;
 			RTMP_IO_WRITE32(pAdapter, TX_BAND_CFG, Value);
 
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R3, &bbpValue);
+			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R3,
+						    &bbpValue);
 			bbpValue |= (0x20);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R3, bbpValue);
-			pAdapter->CommonCfg.CentralChannel = pAdapter->CommonCfg.Channel - 2;
-            AsicSwitchChannel(pAdapter, pAdapter->CommonCfg.CentralChannel, FALSE);
-		    AsicLockChannel(pAdapter, pAdapter->CommonCfg.CentralChannel);
-            DBGPRINT(RT_DEBUG_TRACE, ("BW_40 ,control_channel(%d), CentralChannel(%d) \n",
-                                       pAdapter->CommonCfg.Channel,
-                                       pAdapter->CommonCfg.CentralChannel));
-		}
-		else
-		{
+			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R3,
+						     bbpValue);
+			pAdapter->CommonCfg.CentralChannel =
+			    pAdapter->CommonCfg.Channel - 2;
+			AsicSwitchChannel(pAdapter,
+					  pAdapter->CommonCfg.CentralChannel,
+					  FALSE);
+			AsicLockChannel(pAdapter,
+					pAdapter->CommonCfg.CentralChannel);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BW_40 ,control_channel(%d), CentralChannel(%d) \n",
+				  pAdapter->CommonCfg.Channel,
+				  pAdapter->CommonCfg.CentralChannel));
+		} else {
 			// 20MHz
-			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4, &bbpValue);
+			RTMP_BBP_IO_READ8_BY_REG_ID(pAdapter, BBP_R4,
+						    &bbpValue);
 			bbpValue &= (~0x18);
-			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4, bbpValue);
+			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAdapter, BBP_R4,
+						     bbpValue);
 			pAdapter->CommonCfg.BBPCurrentBW = BW_20;
-			AsicSwitchChannel(pAdapter, pAdapter->CommonCfg.Channel, FALSE);
+			AsicSwitchChannel(pAdapter, pAdapter->CommonCfg.Channel,
+					  FALSE);
 			AsicLockChannel(pAdapter, pAdapter->CommonCfg.Channel);
-			DBGPRINT(RT_DEBUG_TRACE, ("BW_20, Channel(%d)\n", pAdapter->CommonCfg.Channel));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("BW_20, Channel(%d)\n",
+				  pAdapter->CommonCfg.Channel));
 		}
 		// Enable Rx with promiscuous reception
 		RTMP_IO_WRITE32(pAdapter, RX_FILTR_CFG, 0x3);
@@ -2754,14 +2903,16 @@ INT Set_NetworkType_Proc(
 		RTMP_IO_WRITE32(pAdapter, BCN_TIME_CFG, csr.word);
 
 		pAdapter->StaCfg.BssType = BSS_MONITOR;
-        pAdapter->net_dev->type = ARPHRD_IEEE80211_PRISM; //ARPHRD_IEEE80211; // IEEE80211
-		DBGPRINT(RT_DEBUG_TRACE, ("===>Set_NetworkType_Proc::(MONITOR)\n"));
-    }
-
-    // Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
-    pAdapter->StaCfg.WpaState = SS_NOTUSE;
+		pAdapter->net_dev->type = ARPHRD_IEEE80211_PRISM;	//ARPHRD_IEEE80211; // IEEE80211
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("===>Set_NetworkType_Proc::(MONITOR)\n"));
+	}
+	// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+	pAdapter->StaCfg.WpaState = SS_NOTUSE;
 
-    DBGPRINT(RT_DEBUG_TRACE, ("Set_NetworkType_Proc::(NetworkType=%d)\n", pAdapter->StaCfg.BssType));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("Set_NetworkType_Proc::(NetworkType=%d)\n",
+		  pAdapter->StaCfg.BssType));
 
-    return TRUE;
+	return TRUE;
 }
--- a/drivers/staging/rt2860/usb_main_dev.c
+++ b/drivers/staging/rt2860/usb_main_dev.c
@@ -26,7 +26,6 @@
 
 #include "rt_config.h"
 
-
 // Following information will be show when you run 'modinfo'
 // *** If you have a solution for the bug in current version of driver, please mail to me.
 // Otherwise post to forum in ralinktech's web site(www.ralinktech.com) and let all users help you. ***
@@ -37,141 +36,135 @@ MODULE_LICENSE("GPL");
 MODULE_VERSION(STA_DRIVER_VERSION);
 #endif
 
-
 /* module table */
 struct usb_device_id rtusb_usb_id[] = {
 #ifdef RT2870
-	{USB_DEVICE(0x148F,0x2770)}, /* Ralink */
-	{USB_DEVICE(0x148F,0x2870)}, /* Ralink */
-	{USB_DEVICE(0x07B8,0x2870)}, /* AboCom */
-	{USB_DEVICE(0x07B8,0x2770)}, /* AboCom */
-	{USB_DEVICE(0x0DF6,0x0039)}, /* Sitecom 2770 */
-	{USB_DEVICE(0x083A,0x7512)}, /* Arcadyan 2770 */
-	{USB_DEVICE(0x0789,0x0162)}, /* Logitec 2870 */
-	{USB_DEVICE(0x0789,0x0163)}, /* Logitec 2870 */
-	{USB_DEVICE(0x0789,0x0164)}, /* Logitec 2870 */
-	{USB_DEVICE(0x177f,0x0302)}, /* lsusb */
-	{USB_DEVICE(0x0B05,0x1731)}, /* Asus */
-	{USB_DEVICE(0x0B05,0x1732)}, /* Asus */
-	{USB_DEVICE(0x0B05,0x1742)}, /* Asus */
-	{USB_DEVICE(0x0DF6,0x0017)}, /* Sitecom */
-	{USB_DEVICE(0x0DF6,0x002B)}, /* Sitecom */
-	{USB_DEVICE(0x0DF6,0x002C)}, /* Sitecom */
-	{USB_DEVICE(0x0DF6,0x002D)}, /* Sitecom */
-	{USB_DEVICE(0x14B2,0x3C06)}, /* Conceptronic */
-	{USB_DEVICE(0x14B2,0x3C28)}, /* Conceptronic */
-	{USB_DEVICE(0x2019,0xED06)}, /* Planex Communications, Inc. */
-	{USB_DEVICE(0x07D1,0x3C09)}, /* D-Link */
-	{USB_DEVICE(0x07D1,0x3C11)}, /* D-Link */
-	{USB_DEVICE(0x14B2,0x3C07)}, /* AL */
-	{USB_DEVICE(0x050D,0x8053)}, /* Belkin */
-	{USB_DEVICE(0x14B2,0x3C23)}, /* Airlink */
-	{USB_DEVICE(0x14B2,0x3C27)}, /* Airlink */
-	{USB_DEVICE(0x07AA,0x002F)}, /* Corega */
-	{USB_DEVICE(0x07AA,0x003C)}, /* Corega */
-	{USB_DEVICE(0x07AA,0x003F)}, /* Corega */
-	{USB_DEVICE(0x1044,0x800B)}, /* Gigabyte */
-	{USB_DEVICE(0x15A9,0x0006)}, /* Sparklan */
-	{USB_DEVICE(0x083A,0xB522)}, /* SMC */
-	{USB_DEVICE(0x083A,0xA618)}, /* SMC */
-	{USB_DEVICE(0x083A,0x8522)}, /* Arcadyan */
-	{USB_DEVICE(0x083A,0x7522)}, /* Arcadyan */
-	{USB_DEVICE(0x0CDE,0x0022)}, /* ZCOM */
-	{USB_DEVICE(0x0586,0x3416)}, /* Zyxel */
-	{USB_DEVICE(0x0CDE,0x0025)}, /* Zyxel */
-	{USB_DEVICE(0x1740,0x9701)}, /* EnGenius */
-	{USB_DEVICE(0x1740,0x9702)}, /* EnGenius */
-	{USB_DEVICE(0x0471,0x200f)}, /* Philips */
-	{USB_DEVICE(0x14B2,0x3C25)}, /* Draytek */
-	{USB_DEVICE(0x13D3,0x3247)}, /* AzureWave */
-	{USB_DEVICE(0x083A,0x6618)}, /* Accton */
-	{USB_DEVICE(0x15c5,0x0008)}, /* Amit */
-	{USB_DEVICE(0x0E66,0x0001)}, /* Hawking */
-	{USB_DEVICE(0x0E66,0x0003)}, /* Hawking */
-	{USB_DEVICE(0x129B,0x1828)}, /* Siemens */
-	{USB_DEVICE(0x157E,0x300E)},	/* U-Media */
-	{USB_DEVICE(0x050d,0x805c)},
-	{USB_DEVICE(0x050d,0x815c)},
-	{USB_DEVICE(0x1482,0x3C09)}, /* Abocom*/
-	{USB_DEVICE(0x14B2,0x3C09)}, /* Alpha */
-	{USB_DEVICE(0x04E8,0x2018)}, /* samsung */
-	{USB_DEVICE(0x5A57,0x0280)}, /* Zinwell */
-	{USB_DEVICE(0x5A57,0x0282)}, /* Zinwell */
-	{USB_DEVICE(0x7392,0x7718)},
-	{USB_DEVICE(0x7392,0x7717)},
-	{USB_DEVICE(0x1737,0x0070)}, /* Linksys WUSB100 */
-	{USB_DEVICE(0x1737,0x0071)}, /* Linksys WUSB600N */
-	{USB_DEVICE(0x0411,0x00e8)}, /* Buffalo WLI-UC-G300N*/
-	{USB_DEVICE(0x050d,0x815c)}, /* Belkin F5D8053 */
+	{USB_DEVICE(0x148F, 0x2770)},	/* Ralink */
+	{USB_DEVICE(0x148F, 0x2870)},	/* Ralink */
+	{USB_DEVICE(0x07B8, 0x2870)},	/* AboCom */
+	{USB_DEVICE(0x07B8, 0x2770)},	/* AboCom */
+	{USB_DEVICE(0x0DF6, 0x0039)},	/* Sitecom 2770 */
+	{USB_DEVICE(0x083A, 0x7512)},	/* Arcadyan 2770 */
+	{USB_DEVICE(0x0789, 0x0162)},	/* Logitec 2870 */
+	{USB_DEVICE(0x0789, 0x0163)},	/* Logitec 2870 */
+	{USB_DEVICE(0x0789, 0x0164)},	/* Logitec 2870 */
+	{USB_DEVICE(0x177f, 0x0302)},	/* lsusb */
+	{USB_DEVICE(0x0B05, 0x1731)},	/* Asus */
+	{USB_DEVICE(0x0B05, 0x1732)},	/* Asus */
+	{USB_DEVICE(0x0B05, 0x1742)},	/* Asus */
+	{USB_DEVICE(0x0DF6, 0x0017)},	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x002B)},	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x002C)},	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x002D)},	/* Sitecom */
+	{USB_DEVICE(0x14B2, 0x3C06)},	/* Conceptronic */
+	{USB_DEVICE(0x14B2, 0x3C28)},	/* Conceptronic */
+	{USB_DEVICE(0x2019, 0xED06)},	/* Planex Communications, Inc. */
+	{USB_DEVICE(0x07D1, 0x3C09)},	/* D-Link */
+	{USB_DEVICE(0x07D1, 0x3C11)},	/* D-Link */
+	{USB_DEVICE(0x14B2, 0x3C07)},	/* AL */
+	{USB_DEVICE(0x050D, 0x8053)},	/* Belkin */
+	{USB_DEVICE(0x14B2, 0x3C23)},	/* Airlink */
+	{USB_DEVICE(0x14B2, 0x3C27)},	/* Airlink */
+	{USB_DEVICE(0x07AA, 0x002F)},	/* Corega */
+	{USB_DEVICE(0x07AA, 0x003C)},	/* Corega */
+	{USB_DEVICE(0x07AA, 0x003F)},	/* Corega */
+	{USB_DEVICE(0x1044, 0x800B)},	/* Gigabyte */
+	{USB_DEVICE(0x15A9, 0x0006)},	/* Sparklan */
+	{USB_DEVICE(0x083A, 0xB522)},	/* SMC */
+	{USB_DEVICE(0x083A, 0xA618)},	/* SMC */
+	{USB_DEVICE(0x083A, 0x8522)},	/* Arcadyan */
+	{USB_DEVICE(0x083A, 0x7522)},	/* Arcadyan */
+	{USB_DEVICE(0x0CDE, 0x0022)},	/* ZCOM */
+	{USB_DEVICE(0x0586, 0x3416)},	/* Zyxel */
+	{USB_DEVICE(0x0CDE, 0x0025)},	/* Zyxel */
+	{USB_DEVICE(0x1740, 0x9701)},	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9702)},	/* EnGenius */
+	{USB_DEVICE(0x0471, 0x200f)},	/* Philips */
+	{USB_DEVICE(0x14B2, 0x3C25)},	/* Draytek */
+	{USB_DEVICE(0x13D3, 0x3247)},	/* AzureWave */
+	{USB_DEVICE(0x083A, 0x6618)},	/* Accton */
+	{USB_DEVICE(0x15c5, 0x0008)},	/* Amit */
+	{USB_DEVICE(0x0E66, 0x0001)},	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0003)},	/* Hawking */
+	{USB_DEVICE(0x129B, 0x1828)},	/* Siemens */
+	{USB_DEVICE(0x157E, 0x300E)},	/* U-Media */
+	{USB_DEVICE(0x050d, 0x805c)},
+	{USB_DEVICE(0x050d, 0x815c)},
+	{USB_DEVICE(0x1482, 0x3C09)},	/* Abocom */
+	{USB_DEVICE(0x14B2, 0x3C09)},	/* Alpha */
+	{USB_DEVICE(0x04E8, 0x2018)},	/* samsung */
+	{USB_DEVICE(0x5A57, 0x0280)},	/* Zinwell */
+	{USB_DEVICE(0x5A57, 0x0282)},	/* Zinwell */
+	{USB_DEVICE(0x7392, 0x7718)},
+	{USB_DEVICE(0x7392, 0x7717)},
+	{USB_DEVICE(0x1737, 0x0070)},	/* Linksys WUSB100 */
+	{USB_DEVICE(0x1737, 0x0071)},	/* Linksys WUSB600N */
+	{USB_DEVICE(0x0411, 0x00e8)},	/* Buffalo WLI-UC-G300N */
+	{USB_DEVICE(0x050d, 0x815c)},	/* Belkin F5D8053 */
 #endif // RT2870 //
 #ifdef RT3070
-	{USB_DEVICE(0x148F,0x3070)}, /* Ralink 3070 */
-	{USB_DEVICE(0x148F,0x3071)}, /* Ralink 3071 */
-	{USB_DEVICE(0x148F,0x3072)}, /* Ralink 3072 */
-	{USB_DEVICE(0x0DB0,0x3820)}, /* Ralink 3070 */
-	{USB_DEVICE(0x0DF6,0x003E)}, /* Sitecom 3070 */
-	{USB_DEVICE(0x0DF6,0x0042)}, /* Sitecom 3072 */
-	{USB_DEVICE(0x14B2,0x3C12)}, /* AL 3070 */
-	{USB_DEVICE(0x18C5,0x0012)}, /* Corega 3070 */
-	{USB_DEVICE(0x083A,0x7511)}, /* Arcadyan 3070 */
-	{USB_DEVICE(0x1740,0x9703)}, /* EnGenius 3070 */
-	{USB_DEVICE(0x1740,0x9705)}, /* EnGenius 3071 */
-	{USB_DEVICE(0x1740,0x9706)}, /* EnGenius 3072 */
-	{USB_DEVICE(0x13D3,0x3273)}, /* AzureWave 3070*/
-	{USB_DEVICE(0x1044,0x800D)}, /* Gigabyte GN-WB32L 3070 */
-	{USB_DEVICE(0x2019,0xAB25)}, /* Planex Communications, Inc. RT3070 */
-	{USB_DEVICE(0x07B8,0x3070)}, /* AboCom 3070 */
-	{USB_DEVICE(0x07B8,0x3071)}, /* AboCom 3071 */
-	{USB_DEVICE(0x07B8,0x3072)}, /* Abocom 3072 */
-	{USB_DEVICE(0x7392,0x7711)}, /* Edimax 3070 */
-	{USB_DEVICE(0x1A32,0x0304)}, /* Quanta 3070 */
-	{USB_DEVICE(0x1EDA,0x2310)}, /* AirTies 3070 */
-	{USB_DEVICE(0x07D1,0x3C0A)}, /* D-Link 3072 */
-	{USB_DEVICE(0x07D1,0x3C0D)}, /* D-Link 3070 */
-	{USB_DEVICE(0x07D1,0x3C0E)}, /* D-Link 3070 */
-	{USB_DEVICE(0x07D1,0x3C0F)}, /* D-Link 3070 */
-	{USB_DEVICE(0x1D4D,0x000C)}, /* Pegatron Corporation 3070 */
-	{USB_DEVICE(0x1D4D,0x000E)}, /* Pegatron Corporation 3070 */
-	{USB_DEVICE(0x5A57,0x5257)}, /* Zinwell 3070 */
-	{USB_DEVICE(0x5A57,0x0283)}, /* Zinwell 3072 */
-	{USB_DEVICE(0x04BB,0x0945)}, /* I-O DATA 3072 */
-	{USB_DEVICE(0x203D,0x1480)}, /* Encore 3070 */
+	{USB_DEVICE(0x148F, 0x3070)},	/* Ralink 3070 */
+	{USB_DEVICE(0x148F, 0x3071)},	/* Ralink 3071 */
+	{USB_DEVICE(0x148F, 0x3072)},	/* Ralink 3072 */
+	{USB_DEVICE(0x0DB0, 0x3820)},	/* Ralink 3070 */
+	{USB_DEVICE(0x0DF6, 0x003E)},	/* Sitecom 3070 */
+	{USB_DEVICE(0x0DF6, 0x0042)},	/* Sitecom 3072 */
+	{USB_DEVICE(0x14B2, 0x3C12)},	/* AL 3070 */
+	{USB_DEVICE(0x18C5, 0x0012)},	/* Corega 3070 */
+	{USB_DEVICE(0x083A, 0x7511)},	/* Arcadyan 3070 */
+	{USB_DEVICE(0x1740, 0x9703)},	/* EnGenius 3070 */
+	{USB_DEVICE(0x1740, 0x9705)},	/* EnGenius 3071 */
+	{USB_DEVICE(0x1740, 0x9706)},	/* EnGenius 3072 */
+	{USB_DEVICE(0x13D3, 0x3273)},	/* AzureWave 3070 */
+	{USB_DEVICE(0x1044, 0x800D)},	/* Gigabyte GN-WB32L 3070 */
+	{USB_DEVICE(0x2019, 0xAB25)},	/* Planex Communications, Inc. RT3070 */
+	{USB_DEVICE(0x07B8, 0x3070)},	/* AboCom 3070 */
+	{USB_DEVICE(0x07B8, 0x3071)},	/* AboCom 3071 */
+	{USB_DEVICE(0x07B8, 0x3072)},	/* Abocom 3072 */
+	{USB_DEVICE(0x7392, 0x7711)},	/* Edimax 3070 */
+	{USB_DEVICE(0x1A32, 0x0304)},	/* Quanta 3070 */
+	{USB_DEVICE(0x1EDA, 0x2310)},	/* AirTies 3070 */
+	{USB_DEVICE(0x07D1, 0x3C0A)},	/* D-Link 3072 */
+	{USB_DEVICE(0x07D1, 0x3C0D)},	/* D-Link 3070 */
+	{USB_DEVICE(0x07D1, 0x3C0E)},	/* D-Link 3070 */
+	{USB_DEVICE(0x07D1, 0x3C0F)},	/* D-Link 3070 */
+	{USB_DEVICE(0x1D4D, 0x000C)},	/* Pegatron Corporation 3070 */
+	{USB_DEVICE(0x1D4D, 0x000E)},	/* Pegatron Corporation 3070 */
+	{USB_DEVICE(0x5A57, 0x5257)},	/* Zinwell 3070 */
+	{USB_DEVICE(0x5A57, 0x0283)},	/* Zinwell 3072 */
+	{USB_DEVICE(0x04BB, 0x0945)},	/* I-O DATA 3072 */
+	{USB_DEVICE(0x203D, 0x1480)},	/* Encore 3070 */
 #endif // RT3070 //
-	{ USB_DEVICE(0x0DF6, 0x003F) }, /* Sitecom WL-608 */
-	{ USB_DEVICE(0x1737, 0x0077) }, /* Linksys WUSB54GC-EU v3 */
-	{ USB_DEVICE(0x2001, 0x3C09) }, /* D-Link */
-	{ USB_DEVICE(0x2001, 0x3C0A) }, /* D-Link 3072*/
-	{ USB_DEVICE(0x2019, 0xED14) }, /* Planex Communications, Inc. */
-	{ }/* Terminating entry */
+	{USB_DEVICE(0x0DF6, 0x003F)},	/* Sitecom WL-608 */
+	{USB_DEVICE(0x1737, 0x0077)},	/* Linksys WUSB54GC-EU v3 */
+	{USB_DEVICE(0x2001, 0x3C09)},	/* D-Link */
+	{USB_DEVICE(0x2001, 0x3C0A)},	/* D-Link 3072 */
+	{USB_DEVICE(0x2019, 0xED14)},	/* Planex Communications, Inc. */
+	{}			/* Terminating entry */
 };
 
-INT const rtusb_usb_id_len = sizeof(rtusb_usb_id) / sizeof(struct usb_device_id);
+INT const rtusb_usb_id_len =
+    sizeof(rtusb_usb_id) / sizeof(struct usb_device_id);
 
 MODULE_DEVICE_TABLE(usb, rtusb_usb_id);
 
-static void rt2870_disconnect(
-	IN struct usb_device *dev,
-	IN PRTMP_ADAPTER pAd);
-
-static int __devinit rt2870_probe(
-	IN struct usb_interface *intf,
-	IN struct usb_device *usb_dev,
-	IN const struct usb_device_id *dev_id,
-	IN RTMP_ADAPTER **ppAd);
+static void rt2870_disconnect(IN struct usb_device *dev, IN PRTMP_ADAPTER pAd);
+
+static int __devinit rt2870_probe(IN struct usb_interface *intf,
+				  IN struct usb_device *usb_dev,
+				  IN const struct usb_device_id *dev_id,
+				  IN RTMP_ADAPTER ** ppAd);
 
 #ifndef PF_NOFREEZE
 #define PF_NOFREEZE  0
 #endif
 
-
 extern int rt28xx_close(IN struct net_device *net_dev);
 extern int rt28xx_open(struct net_device *net_dev);
 
-static BOOLEAN USBDevConfigInit(
-	IN struct usb_device	*dev,
-	IN struct usb_interface *intf,
-	IN RTMP_ADAPTER *pAd);
-
+static BOOLEAN USBDevConfigInit(IN struct usb_device *dev,
+				IN struct usb_interface *intf,
+				IN RTMP_ADAPTER * pAd);
 
 /*
 ========================================================================
@@ -188,27 +181,23 @@ Return Value:
 Note:
 ========================================================================
 */
-BOOLEAN RT28XXChipsetCheck(
-	IN void *_dev_p)
+BOOLEAN RT28XXChipsetCheck(IN void *_dev_p)
 {
 	struct usb_interface *intf = (struct usb_interface *)_dev_p;
 	struct usb_device *dev_p = interface_to_usbdev(intf);
 	UINT32 i;
 
-
-	for(i=0; i<rtusb_usb_id_len; i++)
-	{
+	for (i = 0; i < rtusb_usb_id_len; i++) {
 		if (dev_p->descriptor.idVendor == rtusb_usb_id[i].idVendor &&
-			dev_p->descriptor.idProduct == rtusb_usb_id[i].idProduct)
-		{
+		    dev_p->descriptor.idProduct == rtusb_usb_id[i].idProduct) {
 			printk("rt2870: idVendor = 0x%x, idProduct = 0x%x\n",
-					dev_p->descriptor.idVendor, dev_p->descriptor.idProduct);
+			       dev_p->descriptor.idVendor,
+			       dev_p->descriptor.idProduct);
 			break;
 		}
 	}
 
-	if (i == rtusb_usb_id_len)
-	{
+	if (i == rtusb_usb_id_len) {
 		printk("rt2870: Error! Device Descriptor not matching!\n");
 		return FALSE;
 	}
@@ -227,61 +216,76 @@ static int rt2870_suspend(struct usb_int
 static int rt2870_resume(struct usb_interface *intf);
 #endif // CONFIG_PM //
 
-static int rtusb_probe (struct usb_interface *intf,
-						const struct usb_device_id *id);
+static int rtusb_probe(struct usb_interface *intf,
+		       const struct usb_device_id *id);
 static void rtusb_disconnect(struct usb_interface *intf);
 
-static BOOLEAN USBDevConfigInit(
-	IN struct usb_device	*dev,
-	IN struct usb_interface *intf,
-	IN RTMP_ADAPTER		*pAd)
+static BOOLEAN USBDevConfigInit(IN struct usb_device *dev,
+				IN struct usb_interface *intf,
+				IN RTMP_ADAPTER * pAd)
 {
 	struct usb_host_interface *iface_desc;
 	ULONG BulkOutIdx;
 	UINT32 i;
 
-
 	/* get the active interface descriptor */
 	iface_desc = intf->cur_altsetting;
 
 	/* get # of enpoints  */
 	pAd->NumberOfPipes = iface_desc->desc.bNumEndpoints;
-	DBGPRINT(RT_DEBUG_TRACE, ("NumEndpoints=%d\n", iface_desc->desc.bNumEndpoints));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("NumEndpoints=%d\n", iface_desc->desc.bNumEndpoints));
 
 	/* Configure Pipes */
 	BulkOutIdx = 0;
 
-	for(i=0; i<pAd->NumberOfPipes; i++)
-	{
+	for (i = 0; i < pAd->NumberOfPipes; i++) {
 		if ((iface_desc->endpoint[i].desc.bmAttributes ==
-				USB_ENDPOINT_XFER_BULK) &&
-			((iface_desc->endpoint[i].desc.bEndpointAddress &
-				USB_ENDPOINT_DIR_MASK) == USB_DIR_IN))
-		{
-			pAd->BulkInEpAddr = iface_desc->endpoint[i].desc.bEndpointAddress;
-			pAd->BulkInMaxPacketSize = le2cpu16(iface_desc->endpoint[i].desc.wMaxPacketSize);
-
-			DBGPRINT_RAW(RT_DEBUG_TRACE, ("BULK IN MaxPacketSize = %d\n", pAd->BulkInMaxPacketSize));
-			DBGPRINT_RAW(RT_DEBUG_TRACE, ("EP address = 0x%2x\n", iface_desc->endpoint[i].desc.bEndpointAddress));
-		}
-		else if ((iface_desc->endpoint[i].desc.bmAttributes ==
-					USB_ENDPOINT_XFER_BULK) &&
-				((iface_desc->endpoint[i].desc.bEndpointAddress &
-					USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT))
-		{
+		     USB_ENDPOINT_XFER_BULK) &&
+		    ((iface_desc->endpoint[i].desc.bEndpointAddress &
+		      USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)) {
+			pAd->BulkInEpAddr =
+			    iface_desc->endpoint[i].desc.bEndpointAddress;
+			pAd->BulkInMaxPacketSize =
+			    le2cpu16(iface_desc->endpoint[i].desc.
+				     wMaxPacketSize);
+
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("BULK IN MaxPacketSize = %d\n",
+				      pAd->BulkInMaxPacketSize));
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("EP address = 0x%2x\n",
+				      iface_desc->endpoint[i].desc.
+				      bEndpointAddress));
+		} else
+		    if ((iface_desc->endpoint[i].desc.bmAttributes ==
+			 USB_ENDPOINT_XFER_BULK)
+			&&
+			((iface_desc->endpoint[i].desc.
+			  bEndpointAddress & USB_ENDPOINT_DIR_MASK) ==
+			 USB_DIR_OUT)) {
 			// there are 6 bulk out EP. EP6 highest priority.
 			// EP1-4 is EDCA.  EP5 is HCCA.
-			pAd->BulkOutEpAddr[BulkOutIdx++] = iface_desc->endpoint[i].desc.bEndpointAddress;
-			pAd->BulkOutMaxPacketSize = le2cpu16(iface_desc->endpoint[i].desc.wMaxPacketSize);
-
-			DBGPRINT_RAW(RT_DEBUG_TRACE, ("BULK OUT MaxPacketSize = %d\n", pAd->BulkOutMaxPacketSize));
-			DBGPRINT_RAW(RT_DEBUG_TRACE, ("EP address = 0x%2x  \n", iface_desc->endpoint[i].desc.bEndpointAddress));
+			pAd->BulkOutEpAddr[BulkOutIdx++] =
+			    iface_desc->endpoint[i].desc.bEndpointAddress;
+			pAd->BulkOutMaxPacketSize =
+			    le2cpu16(iface_desc->endpoint[i].desc.
+				     wMaxPacketSize);
+
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("BULK OUT MaxPacketSize = %d\n",
+				      pAd->BulkOutMaxPacketSize));
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("EP address = 0x%2x  \n",
+				      iface_desc->endpoint[i].desc.
+				      bEndpointAddress));
 		}
 	}
 
-	if (!(pAd->BulkInEpAddr && pAd->BulkOutEpAddr[0]))
-	{
-		printk("%s: Could not find both bulk-in and bulk-out endpoints\n", __FUNCTION__);
+	if (!(pAd->BulkInEpAddr && pAd->BulkOutEpAddr[0])) {
+		printk
+		    ("%s: Could not find both bulk-in and bulk-out endpoints\n",
+		     __FUNCTION__);
 		return FALSE;
 	}
 
@@ -292,10 +296,8 @@ static BOOLEAN USBDevConfigInit(
 
 }
 
-
-
-static int rtusb_probe (struct usb_interface *intf,
-						const struct usb_device_id *id)
+static int rtusb_probe(struct usb_interface *intf,
+		       const struct usb_device_id *id)
 {
 	RTMP_ADAPTER *pAd;
 	struct usb_device *dev;
@@ -311,12 +313,10 @@ static int rtusb_probe (struct usb_inter
 	return rv;
 }
 
-
 static void rtusb_disconnect(struct usb_interface *intf)
 {
-	struct usb_device   *dev = interface_to_usbdev(intf);
-	PRTMP_ADAPTER       pAd;
-
+	struct usb_device *dev = interface_to_usbdev(intf);
+	PRTMP_ADAPTER pAd;
 
 	pAd = usb_get_intfdata(intf);
 	usb_set_intfdata(intf, NULL);
@@ -324,36 +324,31 @@ static void rtusb_disconnect(struct usb_
 	rt2870_disconnect(dev, pAd);
 }
 
-
 struct usb_driver rtusb_driver = {
-	.name="rt2870",
-	.probe=rtusb_probe,
-	.disconnect=rtusb_disconnect,
-	.id_table=rtusb_usb_id,
+	.name = "rt2870",
+	.probe = rtusb_probe,
+	.disconnect = rtusb_disconnect,
+	.id_table = rtusb_usb_id,
 
 #ifdef CONFIG_PM
-	suspend:	rt2870_suspend,
-	resume:		rt2870_resume,
+suspend:rt2870_suspend,
+resume:rt2870_resume,
 #endif
-	};
+};
 
 #ifdef CONFIG_PM
 
-VOID RT2870RejectPendingPackets(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RT2870RejectPendingPackets(IN PRTMP_ADAPTER pAd)
 {
 	// clear PS packets
 	// clear TxSw packets
 }
 
-static int rt2870_suspend(
-	struct usb_interface *intf,
-	pm_message_t state)
+static int rt2870_suspend(struct usb_interface *intf, pm_message_t state)
 {
 	struct net_device *net_dev;
 	PRTMP_ADAPTER pAd = usb_get_intfdata(intf);
 
-
 	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2870_suspend()\n"));
 	net_dev = pAd->net_dev;
 	netif_device_detach(net_dev);
@@ -367,13 +362,11 @@ static int rt2870_suspend(
 	return 0;
 }
 
-static int rt2870_resume(
-	struct usb_interface *intf)
+static int rt2870_resume(struct usb_interface *intf)
 {
 	struct net_device *net_dev;
 	PRTMP_ADAPTER pAd = usb_get_intfdata(intf);
 
-
 	DBGPRINT(RT_DEBUG_TRACE, ("===> rt2870_resume()\n"));
 
 	pAd->PM_FlgSuspend = 0;
@@ -405,9 +398,6 @@ VOID __exit rtusb_exit(void)
 module_init(rtusb_init);
 module_exit(rtusb_exit);
 
-
-
-
 /*---------------------------------------------------------------------	*/
 /* function declarations												*/
 /*---------------------------------------------------------------------	*/
@@ -426,35 +416,32 @@ Return Value:
 Note:
 ========================================================================
 */
-INT MlmeThread(
-	IN void *Context)
+INT MlmeThread(IN void *Context)
 {
 	RTMP_ADAPTER *pAd;
 	RTMP_OS_TASK *pTask;
 	int status;
 	status = 0;
 
-	pTask = (RTMP_OS_TASK *)Context;
-	pAd = (PRTMP_ADAPTER)pTask->priv;
+	pTask = (RTMP_OS_TASK *) Context;
+	pAd = (PRTMP_ADAPTER) pTask->priv;
 
 	RtmpOSTaskCustomize(pTask);
 
-	while(!pTask->task_killed)
-	{
+	while (!pTask->task_killed) {
 #ifdef KTHREAD_SUPPORT
 		RTMP_WAIT_EVENT_INTERRUPTIBLE(pAd, pTask);
 #else
 		RTMP_SEM_EVENT_WAIT(&(pTask->taskSema), status);
 
 		/* unlock the device pointers */
-		if (status != 0)
-		{
+		if (status != 0) {
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
 			break;
 		}
 #endif
 
-		/* lock the device pointers , need to check if required*/
+		/* lock the device pointers , need to check if required */
 		//down(&(pAd->usbdev_semaphore));
 
 		if (!pAd->PM_FlgSuspend)
@@ -475,16 +462,15 @@ INT MlmeThread(
 	 * This is important in preemption kernels, which transfer the flow
 	 * of execution immediately upon a complete().
 	 */
-	DBGPRINT(RT_DEBUG_TRACE,( "<---%s\n",__FUNCTION__));
+	DBGPRINT(RT_DEBUG_TRACE, ("<---%s\n", __FUNCTION__));
 #ifndef KTHREAD_SUPPORT
 	pTask->taskPID = THREAD_PID_INIT_VALUE;
-	complete_and_exit (&pTask->taskComplete, 0);
+	complete_and_exit(&pTask->taskComplete, 0);
 #endif
 	return 0;
 
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -499,16 +485,15 @@ Return Value:
 Note:
 ========================================================================
 */
-INT RTUSBCmdThread(
-	IN void * Context)
+INT RTUSBCmdThread(IN void *Context)
 {
 	RTMP_ADAPTER *pAd;
 	RTMP_OS_TASK *pTask;
 	int status;
 	status = 0;
 
-	pTask = (RTMP_OS_TASK *)Context;
-	pAd = (PRTMP_ADAPTER)pTask->priv;
+	pTask = (RTMP_OS_TASK *) Context;
+	pAd = (PRTMP_ADAPTER) pTask->priv;
 
 	RtmpOSTaskCustomize(pTask);
 
@@ -516,16 +501,14 @@ INT RTUSBCmdThread(
 	pAd->CmdQ.CmdQState = RTMP_TASK_STAT_RUNNING;
 	NdisReleaseSpinLock(&pAd->CmdQLock);
 
-	while (pAd && pAd->CmdQ.CmdQState == RTMP_TASK_STAT_RUNNING)
-	{
+	while (pAd && pAd->CmdQ.CmdQState == RTMP_TASK_STAT_RUNNING) {
 #ifdef KTHREAD_SUPPORT
 		RTMP_WAIT_EVENT_INTERRUPTIBLE(pAd, pTask);
 #else
 		/* lock the device pointers */
 		RTMP_SEM_EVENT_WAIT(&(pTask->taskSema), status);
 
-		if (status != 0)
-		{
+		if (status != 0) {
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
 			break;
 		}
@@ -538,28 +521,25 @@ INT RTUSBCmdThread(
 			CMDHandler(pAd);
 	}
 
-	if (pAd && !pAd->PM_FlgSuspend)
-	{	// Clear the CmdQElements.
-		CmdQElmt	*pCmdQElmt = NULL;
+	if (pAd && !pAd->PM_FlgSuspend) {	// Clear the CmdQElements.
+		CmdQElmt *pCmdQElmt = NULL;
 
 		NdisAcquireSpinLock(&pAd->CmdQLock);
 		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_STOPED;
-		while(pAd->CmdQ.size)
-		{
+		while (pAd->CmdQ.size) {
 			RTUSBDequeueCmd(&pAd->CmdQ, &pCmdQElmt);
-			if (pCmdQElmt)
-			{
-				if (pCmdQElmt->CmdFromNdis == TRUE)
-				{
+			if (pCmdQElmt) {
+				if (pCmdQElmt->CmdFromNdis == TRUE) {
 					if (pCmdQElmt->buffer != NULL)
-						os_free_mem(pAd, pCmdQElmt->buffer);
-					os_free_mem(pAd, (PUCHAR)pCmdQElmt);
-				}
-				else
-				{
-					if ((pCmdQElmt->buffer != NULL) && (pCmdQElmt->bufferlength != 0))
-						os_free_mem(pAd, pCmdQElmt->buffer);
-					os_free_mem(pAd, (PUCHAR)pCmdQElmt);
+						os_free_mem(pAd,
+							    pCmdQElmt->buffer);
+					os_free_mem(pAd, (PUCHAR) pCmdQElmt);
+				} else {
+					if ((pCmdQElmt->buffer != NULL)
+					    && (pCmdQElmt->bufferlength != 0))
+						os_free_mem(pAd,
+							    pCmdQElmt->buffer);
+					os_free_mem(pAd, (PUCHAR) pCmdQElmt);
 				}
 			}
 		}
@@ -580,52 +560,54 @@ INT RTUSBCmdThread(
 	 * This is important in preemption kernels, which transfer the flow
 	 * of execution immediately upon a complete().
 	 */
-	DBGPRINT(RT_DEBUG_TRACE,( "<---RTUSBCmdThread\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("<---RTUSBCmdThread\n"));
 
 #ifndef KTHREAD_SUPPORT
 	pTask->taskPID = THREAD_PID_INIT_VALUE;
-	complete_and_exit (&pTask->taskComplete, 0);
+	complete_and_exit(&pTask->taskComplete, 0);
 #endif
 	return 0;
 
 }
 
-
-VOID RTUSBWatchDog(IN RTMP_ADAPTER *pAd)
+VOID RTUSBWatchDog(IN RTMP_ADAPTER * pAd)
 {
-	PHT_TX_CONTEXT		pHTTXContext;
-	int					idx;
-	ULONG				irqFlags;
-	PURB				pUrb;
-	BOOLEAN				needDumpSeq = FALSE;
-	UINT32			MACValue;
-	UINT32		TxRxQ_Pcnt;
+	PHT_TX_CONTEXT pHTTXContext;
+	int idx;
+	ULONG irqFlags;
+	PURB pUrb;
+	BOOLEAN needDumpSeq = FALSE;
+	UINT32 MACValue;
+	UINT32 TxRxQ_Pcnt;
 
 	idx = 0;
 	RTMP_IO_READ32(pAd, TXRXQ_PCNT, &MACValue);
-	if ((MACValue & 0xff) !=0 )
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("TX QUEUE 0 Not EMPTY(Value=0x%0x). !!!!!!!!!!!!!!!\n", MACValue));
+	if ((MACValue & 0xff) != 0) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("TX QUEUE 0 Not EMPTY(Value=0x%0x). !!!!!!!!!!!!!!!\n",
+			  MACValue));
 		RTMP_IO_WRITE32(pAd, PBF_CFG, 0xf40012);
-		while((MACValue &0xff) != 0 && (idx++ < 10))
-		{
-		        RTMP_IO_READ32(pAd, TXRXQ_PCNT, &MACValue);
-		        RTMPusecDelay(1);
+		while ((MACValue & 0xff) != 0 && (idx++ < 10)) {
+			RTMP_IO_READ32(pAd, TXRXQ_PCNT, &MACValue);
+			RTMPusecDelay(1);
 		}
 		RTMP_IO_WRITE32(pAd, PBF_CFG, 0xf40006);
 	}
 
-	if (pAd->watchDogRxOverFlowCnt >= 2)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("Maybe the Rx Bulk-In hanged! Cancel the pending Rx bulks request!\n"));
-		if ((!RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS |
-									fRTMP_ADAPTER_BULKIN_RESET |
-									fRTMP_ADAPTER_HALT_IN_PROGRESS |
-									fRTMP_ADAPTER_NIC_NOT_EXIST))))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("Call CMDTHREAD_RESET_BULK_IN to cancel the pending Rx Bulk!\n"));
+	if (pAd->watchDogRxOverFlowCnt >= 2) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("Maybe the Rx Bulk-In hanged! Cancel the pending Rx bulks request!\n"));
+		if ((!RTMP_TEST_FLAG
+		     (pAd,
+		      (fRTMP_ADAPTER_RESET_IN_PROGRESS |
+		       fRTMP_ADAPTER_BULKIN_RESET |
+		       fRTMP_ADAPTER_HALT_IN_PROGRESS |
+		       fRTMP_ADAPTER_NIC_NOT_EXIST)))) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("Call CMDTHREAD_RESET_BULK_IN to cancel the pending Rx Bulk!\n"));
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
-			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_IN, NULL, 0);
+			RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_RESET_BULK_IN,
+						NULL, 0);
 			needDumpSeq = TRUE;
 		}
 		pAd->watchDogRxOverFlowCnt = 0;
@@ -633,126 +615,139 @@ VOID RTUSBWatchDog(IN RTMP_ADAPTER *pAd)
 
 	RTUSBReadMACRegister(pAd, 0x438, &TxRxQ_Pcnt);
 
-	for (idx = 0; idx < NUM_OF_TX_RING; idx++)
-	{
+	for (idx = 0; idx < NUM_OF_TX_RING; idx++) {
 		pUrb = NULL;
 
 		RTMP_IRQ_LOCK(&pAd->BulkOutLock[idx], irqFlags);
-		if ((pAd->BulkOutPending[idx] == TRUE) && pAd->watchDogTxPendingCnt)
-		{
-			INT actual_length=0,transfer_buffer_length=0;
-			BOOLEAN isDataPacket=FALSE;
+		if ((pAd->BulkOutPending[idx] == TRUE)
+		    && pAd->watchDogTxPendingCnt) {
+			INT actual_length = 0, transfer_buffer_length = 0;
+			BOOLEAN isDataPacket = FALSE;
 			pAd->watchDogTxPendingCnt[idx]++;
 
 			if ((pAd->watchDogTxPendingCnt[idx] > 2) &&
-				 (!RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS | fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST | fRTMP_ADAPTER_BULKOUT_RESET)))
-				)
-			{
+			    (!RTMP_TEST_FLAG
+			     (pAd,
+			      (fRTMP_ADAPTER_RESET_IN_PROGRESS |
+			       fRTMP_ADAPTER_HALT_IN_PROGRESS |
+			       fRTMP_ADAPTER_NIC_NOT_EXIST |
+			       fRTMP_ADAPTER_BULKOUT_RESET)))
+			    ) {
 				// FIXME: Following code just support single bulk out. If you wanna support multiple bulk out. Modify it!
-				pHTTXContext = (PHT_TX_CONTEXT)(&pAd->TxContext[idx]);
-				if (pHTTXContext->IRPPending)
-				{	// Check TxContext.
+				pHTTXContext =
+				    (PHT_TX_CONTEXT) (&pAd->TxContext[idx]);
+				if (pHTTXContext->IRPPending) {	// Check TxContext.
 					pUrb = pHTTXContext->pUrb;
 
-					actual_length=pUrb->actual_length;
-					transfer_buffer_length=pUrb->transfer_buffer_length;
-					isDataPacket=TRUE;
-				}
-				else if (idx == MGMTPIPEIDX)
-				{
-					PTX_CONTEXT pMLMEContext, pNULLContext, pPsPollContext;
+					actual_length = pUrb->actual_length;
+					transfer_buffer_length =
+					    pUrb->transfer_buffer_length;
+					isDataPacket = TRUE;
+				} else if (idx == MGMTPIPEIDX) {
+					PTX_CONTEXT pMLMEContext, pNULLContext,
+					    pPsPollContext;
 
 					//Check MgmtContext.
-					pMLMEContext = (PTX_CONTEXT)(pAd->MgmtRing.Cell[pAd->MgmtRing.TxDmaIdx].AllocVa);
-					pPsPollContext = (PTX_CONTEXT)(&pAd->PsPollContext);
-					pNULLContext = (PTX_CONTEXT)(&pAd->NullContext);
-
-					if (pMLMEContext->IRPPending)
-					{
-						ASSERT(pMLMEContext->IRPPending);
+					pMLMEContext =
+					    (PTX_CONTEXT) (pAd->MgmtRing.
+							   Cell[pAd->MgmtRing.
+								TxDmaIdx].
+							   AllocVa);
+					pPsPollContext =
+					    (PTX_CONTEXT) (&pAd->PsPollContext);
+					pNULLContext =
+					    (PTX_CONTEXT) (&pAd->NullContext);
+
+					if (pMLMEContext->IRPPending) {
+						ASSERT(pMLMEContext->
+						       IRPPending);
 						pUrb = pMLMEContext->pUrb;
-					}
-					else if (pNULLContext->IRPPending)
-					{
-						ASSERT(pNULLContext->IRPPending);
+					} else if (pNULLContext->IRPPending) {
+						ASSERT(pNULLContext->
+						       IRPPending);
 						pUrb = pNULLContext->pUrb;
-					}
-					else if (pPsPollContext->IRPPending)
-					{
-						ASSERT(pPsPollContext->IRPPending);
+					} else if (pPsPollContext->IRPPending) {
+						ASSERT(pPsPollContext->
+						       IRPPending);
 						pUrb = pPsPollContext->pUrb;
 					}
 				}
 
-				RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx], irqFlags);
+				RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx],
+						irqFlags);
 
 				printk(KERN_INFO "%d:%lu LTL=%d , TL=%d L:%d\n",
 				       idx, pAd->watchDogTxPendingCnt[idx],
 				       pAd->TransferedLength[idx],
 				       actual_length, transfer_buffer_length);
 
-				if (pUrb)
-				{
+				if (pUrb) {
 					if ((isDataPacket
-					&& pAd->TransferedLength[idx]==actual_length
-					&& pAd->TransferedLength[idx]<transfer_buffer_length
-					&& actual_length!=0
-//					&& TxRxQ_Pcnt==0
-					&& pAd->watchDogTxPendingCnt[idx]>3)
-					|| isDataPacket==FALSE || pAd->watchDogTxPendingCnt[idx]>6)
-					{
-						DBGPRINT(RT_DEBUG_TRACE, ("Maybe the Tx Bulk-Out hanged! Cancel the pending Tx bulks request of idx(%d)!\n", idx));
-					DBGPRINT(RT_DEBUG_TRACE, ("Unlink the pending URB!\n"));
-					// unlink it now
-					RTUSB_UNLINK_URB(pUrb);
-					// Sleep 200 microseconds to give cancellation time to work
+					     && pAd->TransferedLength[idx] ==
+					     actual_length
+					     && pAd->TransferedLength[idx] <
+					     transfer_buffer_length
+					     && actual_length != 0
+//                                      && TxRxQ_Pcnt==0
+					     && pAd->watchDogTxPendingCnt[idx] >
+					     3)
+					    || isDataPacket == FALSE
+					    || pAd->watchDogTxPendingCnt[idx] >
+					    6) {
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("Maybe the Tx Bulk-Out hanged! Cancel the pending Tx bulks request of idx(%d)!\n",
+							  idx));
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("Unlink the pending URB!\n"));
+						// unlink it now
+						RTUSB_UNLINK_URB(pUrb);
+						// Sleep 200 microseconds to give cancellation time to work
 						//RTMPusecDelay(200);
-					needDumpSeq = TRUE;
+						needDumpSeq = TRUE;
 					}
+				} else {
+					DBGPRINT(RT_DEBUG_ERROR,
+						 ("Unkonw bulkOut URB maybe hanged!!!!!!!!!!!!\n"));
 				}
-				else
-				{
-					DBGPRINT(RT_DEBUG_ERROR, ("Unkonw bulkOut URB maybe hanged!!!!!!!!!!!!\n"));
-				}
-			}
-			else
-			{
-				RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx], irqFlags);
+			} else {
+				RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx],
+						irqFlags);
 			}
 
-			if (isDataPacket==TRUE)
-				pAd->TransferedLength[idx]=actual_length;
-		}
-		else
-		{
+			if (isDataPacket == TRUE)
+				pAd->TransferedLength[idx] = actual_length;
+		} else {
 			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx], irqFlags);
 		}
 	}
 
 	// For Sigma debug, dump the ba_reordering sequence.
-	if((needDumpSeq == TRUE) && (pAd->CommonCfg.bDisableReordering == 0))
-	{
-		USHORT				Idx;
-		PBA_REC_ENTRY		pBAEntry = NULL;
-		UCHAR				count = 0;
+	if ((needDumpSeq == TRUE) && (pAd->CommonCfg.bDisableReordering == 0)) {
+		USHORT Idx;
+		PBA_REC_ENTRY pBAEntry = NULL;
+		UCHAR count = 0;
 		struct reordering_mpdu *mpdu_blk;
 
 		Idx = pAd->MacTab.Content[BSSID_WCID].BARecWcidArray[0];
 
 		pBAEntry = &pAd->BATable.BARecEntry[Idx];
-		if((pBAEntry->list.qlen > 0) && (pBAEntry->list.next != NULL))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("NICUpdateRawCounters():The Queueing pkt in reordering buffer:\n"));
+		if ((pBAEntry->list.qlen > 0) && (pBAEntry->list.next != NULL)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("NICUpdateRawCounters():The Queueing pkt in reordering buffer:\n"));
 			NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
 			mpdu_blk = pBAEntry->list.next;
-			while (mpdu_blk)
-			{
-				DBGPRINT(RT_DEBUG_TRACE, ("\t%d:Seq-%d, bAMSDU-%d!\n", count, mpdu_blk->Sequence, mpdu_blk->bAMSDU));
+			while (mpdu_blk) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("\t%d:Seq-%d, bAMSDU-%d!\n", count,
+					  mpdu_blk->Sequence,
+					  mpdu_blk->bAMSDU));
 				mpdu_blk = mpdu_blk->next;
 				count++;
 			}
 
-			DBGPRINT(RT_DEBUG_TRACE, ("\npBAEntry->LastIndSeq=%d!\n", pBAEntry->LastIndSeq));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("\npBAEntry->LastIndSeq=%d!\n",
+				  pBAEntry->LastIndSeq));
 			NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
 		}
 	}
@@ -775,10 +770,10 @@ Note:
 */
 static void rt2870_disconnect(struct usb_device *dev, PRTMP_ADAPTER pAd)
 {
-	DBGPRINT(RT_DEBUG_ERROR, ("rtusb_disconnect: unregister usbnet usb-%s-%s\n",
-				dev->bus->bus_name, dev->devpath));
-	if (!pAd)
-	{
+	DBGPRINT(RT_DEBUG_ERROR,
+		 ("rtusb_disconnect: unregister usbnet usb-%s-%s\n",
+		  dev->bus->bus_name, dev->devpath));
+	if (!pAd) {
 		usb_put_dev(dev);
 		printk("rtusb_disconnect: pAd == NULL!\n");
 		return;
@@ -788,7 +783,6 @@ static void rt2870_disconnect(struct usb
 	// for debug, wait to show some messages to /proc system
 	udelay(1);
 
-
 	RtmpPhyNetDevExit(pAd, pAd->net_dev);
 
 	// FIXME: Shall we need following delay and flush the schedule??
@@ -808,43 +802,38 @@ static void rt2870_disconnect(struct usb
 	DBGPRINT(RT_DEBUG_ERROR, (" RTUSB disconnect successfully\n"));
 }
 
-
-static int __devinit rt2870_probe(
-	IN struct usb_interface *intf,
-	IN struct usb_device *usb_dev,
-	IN const struct usb_device_id *dev_id,
-	IN RTMP_ADAPTER **ppAd)
-{
-	struct  net_device		*net_dev = NULL;
-	RTMP_ADAPTER		*pAd = (RTMP_ADAPTER *) NULL;
-	INT				status, rv;
-	PVOID				handle;
-	RTMP_OS_NETDEV_OP_HOOK	netDevHook;
-
+static int __devinit rt2870_probe(IN struct usb_interface *intf,
+				  IN struct usb_device *usb_dev,
+				  IN const struct usb_device_id *dev_id,
+				  IN RTMP_ADAPTER ** ppAd)
+{
+	struct net_device *net_dev = NULL;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) NULL;
+	INT status, rv;
+	PVOID handle;
+	RTMP_OS_NETDEV_OP_HOOK netDevHook;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===>rt2870_probe()!\n"));
 
 	// Check chipset vendor/product ID
 	//if (RT28XXChipsetCheck(_dev_p) == FALSE)
-	//	goto err_out;
+	//      goto err_out;
 
 //RtmpDevInit=============================================
 	// Allocate RTMP_ADAPTER adapter structure
 	handle = kmalloc(sizeof(struct os_cookie), GFP_KERNEL);
-	if (handle == NULL)
-	{
-		printk("rt2870_probe(): Allocate memory for os handle failed!\n");
+	if (handle == NULL) {
+		printk
+		    ("rt2870_probe(): Allocate memory for os handle failed!\n");
 		return -ENOMEM;
 	}
-	((POS_COOKIE)handle)->pUsb_Dev = usb_dev;
+	((POS_COOKIE) handle)->pUsb_Dev = usb_dev;
 
 	rv = RTMPAllocAdapterBlock(handle, &pAd);
-	if (rv != NDIS_STATUS_SUCCESS)
-	{
+	if (rv != NDIS_STATUS_SUCCESS) {
 		kfree(handle);
 		goto err_out;
 	}
-
 //USBDevInit==============================================
 	if (USBDevConfigInit(usb_dev, intf, pAd) == FALSE)
 		goto err_out_free_radev;
@@ -858,12 +847,12 @@ static int __devinit rt2870_probe(
 
 	// Here are the net_device structure with usb specific parameters.
 	/* for supporting Network Manager.
-	  * Set the sysfs physical device reference for the network logical device if set prior to registration will
-	  * cause a symlink during initialization.
+	 * Set the sysfs physical device reference for the network logical device if set prior to registration will
+	 * cause a symlink during initialization.
 	 */
 	SET_NETDEV_DEV(net_dev, &(usb_dev->dev));
 
-    pAd->StaCfg.OriDevType = net_dev->type;
+	pAd->StaCfg.OriDevType = net_dev->type;
 
 //All done, it's time to register the net device to linux kernel.
 	// Register this device
--- a/drivers/staging/rt2870/common/rtusb_bulk.c
+++ b/drivers/staging/rt2870/common/rtusb_bulk.c
@@ -39,35 +39,32 @@
 
 #ifdef RTMP_MAC_USB
 
-
 #include "../rt_config.h"
 // Match total 6 bulkout endpoint to corresponding queue.
-UCHAR	EpToQueue[6]={FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_MGMT};
+UCHAR EpToQueue[6] =
+    { FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_EDCA, FIFO_MGMT };
 
 //static BOOLEAN SingleBulkOut = FALSE;
 
-void RTUSB_FILL_BULK_URB (struct urb *pUrb,
-	struct usb_device *pUsb_Dev,
-	unsigned int bulkpipe,
-	void *pTransferBuf,
-	int BufSize,
-	usb_complete_t Complete,
-	void *pContext)
+void RTUSB_FILL_BULK_URB(struct urb *pUrb,
+			 struct usb_device *pUsb_Dev,
+			 unsigned int bulkpipe,
+			 void *pTransferBuf,
+			 int BufSize, usb_complete_t Complete, void *pContext)
 {
 
-	usb_fill_bulk_urb(pUrb, pUsb_Dev, bulkpipe, pTransferBuf, BufSize, (usb_complete_t)Complete, pContext);
+	usb_fill_bulk_urb(pUrb, pUsb_Dev, bulkpipe, pTransferBuf, BufSize,
+			  (usb_complete_t) Complete, pContext);
 
 }
 
-VOID	RTUSBInitTxDesc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PTX_CONTEXT		pTxContext,
-	IN	UCHAR			BulkOutPipeId,
-	IN	usb_complete_t	Func)
+VOID RTUSBInitTxDesc(IN PRTMP_ADAPTER pAd,
+		     IN PTX_CONTEXT pTxContext,
+		     IN UCHAR BulkOutPipeId, IN usb_complete_t Func)
 {
-	PURB				pUrb;
-	PUCHAR				pSrc = NULL;
-	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
+	PURB pUrb;
+	PUCHAR pSrc = NULL;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	pUrb = pTxContext->pUrb;
 	ASSERT(pUrb);
@@ -75,44 +72,38 @@ VOID	RTUSBInitTxDesc(
 	// Store BulkOut PipeId
 	pTxContext->BulkOutPipeId = BulkOutPipeId;
 
-	if (pTxContext->bAggregatible)
-	{
+	if (pTxContext->bAggregatible) {
 		pSrc = &pTxContext->TransferBuffer->Aggregation[2];
+	} else {
+		pSrc =
+		    (PUCHAR) pTxContext->TransferBuffer->field.WirelessPacket;
 	}
-	else
-	{
-		pSrc = (PUCHAR) pTxContext->TransferBuffer->field.WirelessPacket;
-	}
-
 
 	//Initialize a tx bulk urb
 	RTUSB_FILL_BULK_URB(pUrb,
-						pObj->pUsb_Dev,
-						usb_sndbulkpipe(pObj->pUsb_Dev, pAd->BulkOutEpAddr[BulkOutPipeId]),
-						pSrc,
-						pTxContext->BulkOutSize,
-						Func,
-						pTxContext);
+			    pObj->pUsb_Dev,
+			    usb_sndbulkpipe(pObj->pUsb_Dev,
+					    pAd->BulkOutEpAddr[BulkOutPipeId]),
+			    pSrc, pTxContext->BulkOutSize, Func, pTxContext);
 
 	if (pTxContext->bAggregatible)
-		pUrb->transfer_dma	= (pTxContext->data_dma + TX_BUFFER_NORMSIZE + 2);
+		pUrb->transfer_dma =
+		    (pTxContext->data_dma + TX_BUFFER_NORMSIZE + 2);
 	else
-		pUrb->transfer_dma	= pTxContext->data_dma;
+		pUrb->transfer_dma = pTxContext->data_dma;
 
 	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 }
 
-VOID	RTUSBInitHTTxDesc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PHT_TX_CONTEXT	pTxContext,
-	IN	UCHAR			BulkOutPipeId,
-	IN	ULONG			BulkOutSize,
-	IN	usb_complete_t	Func)
-{
-	PURB				pUrb;
-	PUCHAR				pSrc = NULL;
-	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
+VOID RTUSBInitHTTxDesc(IN PRTMP_ADAPTER pAd,
+		       IN PHT_TX_CONTEXT pTxContext,
+		       IN UCHAR BulkOutPipeId,
+		       IN ULONG BulkOutSize, IN usb_complete_t Func)
+{
+	PURB pUrb;
+	PUCHAR pSrc = NULL;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	pUrb = pTxContext->pUrb;
 	ASSERT(pUrb);
@@ -120,53 +111,50 @@ VOID	RTUSBInitHTTxDesc(
 	// Store BulkOut PipeId
 	pTxContext->BulkOutPipeId = BulkOutPipeId;
 
-	pSrc = &pTxContext->TransferBuffer->field.WirelessPacket[pTxContext->NextBulkOutPosition];
-
+	pSrc =
+	    &pTxContext->TransferBuffer->field.WirelessPacket[pTxContext->
+							      NextBulkOutPosition];
 
 	//Initialize a tx bulk urb
 	RTUSB_FILL_BULK_URB(pUrb,
-						pObj->pUsb_Dev,
-						usb_sndbulkpipe(pObj->pUsb_Dev, pAd->BulkOutEpAddr[BulkOutPipeId]),
-						pSrc,
-						BulkOutSize,
-						Func,
-						pTxContext);
+			    pObj->pUsb_Dev,
+			    usb_sndbulkpipe(pObj->pUsb_Dev,
+					    pAd->BulkOutEpAddr[BulkOutPipeId]),
+			    pSrc, BulkOutSize, Func, pTxContext);
 
-	pUrb->transfer_dma	= (pTxContext->data_dma + pTxContext->NextBulkOutPosition);
+	pUrb->transfer_dma =
+	    (pTxContext->data_dma + pTxContext->NextBulkOutPosition);
 	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 }
 
-VOID	RTUSBInitRxDesc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PRX_CONTEXT		pRxContext)
-{
-	PURB				pUrb;
-	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
-	ULONG				RX_bulk_size;
-
+VOID RTUSBInitRxDesc(IN PRTMP_ADAPTER pAd, IN PRX_CONTEXT pRxContext)
+{
+	PURB pUrb;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+	ULONG RX_bulk_size;
 
 	pUrb = pRxContext->pUrb;
 	ASSERT(pUrb);
 
-	if ( pAd->BulkInMaxPacketSize == 64)
+	if (pAd->BulkInMaxPacketSize == 64)
 		RX_bulk_size = 4096;
 	else
 		RX_bulk_size = MAX_RXBULK_SIZE;
 
 	//Initialize a rx bulk urb
 	RTUSB_FILL_BULK_URB(pUrb,
-						pObj->pUsb_Dev,
-						usb_rcvbulkpipe(pObj->pUsb_Dev, pAd->BulkInEpAddr),
-						&(pRxContext->TransferBuffer[pAd->NextRxBulkInPosition]),
-						RX_bulk_size - (pAd->NextRxBulkInPosition),
-						(usb_complete_t)RTUSBBulkRxComplete,
-						(void *)pRxContext);
+			    pObj->pUsb_Dev,
+			    usb_rcvbulkpipe(pObj->pUsb_Dev, pAd->BulkInEpAddr),
+			    &(pRxContext->
+			      TransferBuffer[pAd->NextRxBulkInPosition]),
+			    RX_bulk_size - (pAd->NextRxBulkInPosition),
+			    (usb_complete_t) RTUSBBulkRxComplete,
+			    (void *)pRxContext);
 
-	pUrb->transfer_dma	= pRxContext->data_dma + pAd->NextRxBulkInPosition;
+	pUrb->transfer_dma = pRxContext->data_dma + pAd->NextRxBulkInPosition;
 	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
-
 }
 
 /*
@@ -191,179 +179,215 @@ VOID	RTUSBInitRxDesc(
 		if(1 /*!(in_interrupt() & 0xffff0000)*/)	\
 			RTMP_IRQ_UNLOCK((pLock), IrqFlags);
 
+VOID RTUSBBulkOutDataPacket(IN PRTMP_ADAPTER pAd,
+			    IN UCHAR BulkOutPipeId, IN UCHAR Index)
+{
 
-VOID	RTUSBBulkOutDataPacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			BulkOutPipeId,
-	IN	UCHAR			Index)
-{
-
-	PHT_TX_CONTEXT	pHTTXContext;
-	PURB			pUrb;
-	int				ret = 0;
-	PTXINFO_STRUC	pTxInfo, pLastTxInfo = NULL;
-	PTXWI_STRUC             pTxWI;
-	ULONG			TmpBulkEndPos, ThisBulkSize;
-	unsigned long	IrqFlags = 0, IrqFlags2 = 0;
-	PUCHAR			pWirelessPkt, pAppendant;
-	BOOLEAN			bTxQLastRound = FALSE;
-	UCHAR			allzero[4]= {0x0,0x0,0x0,0x0};
+	PHT_TX_CONTEXT pHTTXContext;
+	PURB pUrb;
+	int ret = 0;
+	PTXINFO_STRUC pTxInfo, pLastTxInfo = NULL;
+	PTXWI_STRUC pTxWI;
+	ULONG TmpBulkEndPos, ThisBulkSize;
+	unsigned long IrqFlags = 0, IrqFlags2 = 0;
+	PUCHAR pWirelessPkt, pAppendant;
+	BOOLEAN bTxQLastRound = FALSE;
+	UCHAR allzero[4] = { 0x0, 0x0, 0x0, 0x0 };
 
 	BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
-	if ((pAd->BulkOutPending[BulkOutPipeId] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX))
-	{
+	if ((pAd->BulkOutPending[BulkOutPipeId] == TRUE)
+	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)) {
 		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 		return;
 	}
 	pAd->BulkOutPending[BulkOutPipeId] = TRUE;
 
 	if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
-		)
-	{
+	    ) {
 		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
 		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 		return;
 	}
 	BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 
-
 	pHTTXContext = &(pAd->TxContext[BulkOutPipeId]);
 
 	BULK_OUT_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
-	if ((pHTTXContext->ENextBulkOutPosition == pHTTXContext->CurWritePosition)
-		|| ((pHTTXContext->ENextBulkOutPosition-8) == pHTTXContext->CurWritePosition))
-	{
-		BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
+	if ((pHTTXContext->ENextBulkOutPosition ==
+	     pHTTXContext->CurWritePosition)
+	    || ((pHTTXContext->ENextBulkOutPosition - 8) ==
+		pHTTXContext->CurWritePosition)) {
+		BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId],
+				IrqFlags2);
 
 		BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
 
 		// Clear Data flag
-		RTUSB_CLEAR_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
-		RTUSB_CLEAR_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
+		RTUSB_CLEAR_BULK_FLAG(pAd,
+				      (fRTUSB_BULK_OUT_DATA_FRAG <<
+				       BulkOutPipeId));
+		RTUSB_CLEAR_BULK_FLAG(pAd,
+				      (fRTUSB_BULK_OUT_DATA_NORMAL <<
+				       BulkOutPipeId));
 
 		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 		return;
 	}
-
 	// Clear Data flag
-	RTUSB_CLEAR_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
-	RTUSB_CLEAR_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
+	RTUSB_CLEAR_BULK_FLAG(pAd,
+			      (fRTUSB_BULK_OUT_DATA_FRAG << BulkOutPipeId));
+	RTUSB_CLEAR_BULK_FLAG(pAd,
+			      (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
 
 	//DBGPRINT(RT_DEBUG_TRACE,("BulkOut-B:I=0x%lx, CWPos=%ld, CWRPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", in_interrupt(),
-	//							pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition,
-	//							pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
+	//                                                      pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition,
+	//                                                      pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
 	pHTTXContext->NextBulkOutPosition = pHTTXContext->ENextBulkOutPosition;
 	ThisBulkSize = 0;
 	TmpBulkEndPos = pHTTXContext->NextBulkOutPosition;
 	pWirelessPkt = &pHTTXContext->TransferBuffer->field.WirelessPacket[0];
 
-	if ((pHTTXContext->bCopySavePad == TRUE))
-	{
-		if (RTMPEqualMemory(pHTTXContext->SavedPad, allzero,4))
-		{
-			DBGPRINT_RAW(RT_DEBUG_ERROR,("e1, allzero : %x  %x  %x  %x  %x  %x  %x  %x \n",
-				pHTTXContext->SavedPad[0], pHTTXContext->SavedPad[1], pHTTXContext->SavedPad[2],pHTTXContext->SavedPad[3]
-				,pHTTXContext->SavedPad[4], pHTTXContext->SavedPad[5], pHTTXContext->SavedPad[6],pHTTXContext->SavedPad[7]));
+	if ((pHTTXContext->bCopySavePad == TRUE)) {
+		if (RTMPEqualMemory(pHTTXContext->SavedPad, allzero, 4)) {
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("e1, allzero : %x  %x  %x  %x  %x  %x  %x  %x \n",
+				      pHTTXContext->SavedPad[0],
+				      pHTTXContext->SavedPad[1],
+				      pHTTXContext->SavedPad[2],
+				      pHTTXContext->SavedPad[3]
+				      , pHTTXContext->SavedPad[4],
+				      pHTTXContext->SavedPad[5],
+				      pHTTXContext->SavedPad[6],
+				      pHTTXContext->SavedPad[7]));
 		}
-		NdisMoveMemory(&pWirelessPkt[TmpBulkEndPos], pHTTXContext->SavedPad, 8);
+		NdisMoveMemory(&pWirelessPkt[TmpBulkEndPos],
+			       pHTTXContext->SavedPad, 8);
 		pHTTXContext->bCopySavePad = FALSE;
 		if (pAd->bForcePrintTX == TRUE)
-			DBGPRINT(RT_DEBUG_TRACE,("RTUSBBulkOutDataPacket --> COPY PAD. CurWrite = %ld, NextBulk = %ld.   ENextBulk = %ld.\n",   pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("RTUSBBulkOutDataPacket --> COPY PAD. CurWrite = %ld, NextBulk = %ld.   ENextBulk = %ld.\n",
+				  pHTTXContext->CurWritePosition,
+				  pHTTXContext->NextBulkOutPosition,
+				  pHTTXContext->ENextBulkOutPosition));
 	}
 
-	do
-	{
-		pTxInfo = (PTXINFO_STRUC)&pWirelessPkt[TmpBulkEndPos];
-		pTxWI = (PTXWI_STRUC)&pWirelessPkt[TmpBulkEndPos + TXINFO_SIZE];
+	do {
+		pTxInfo = (PTXINFO_STRUC) & pWirelessPkt[TmpBulkEndPos];
+		pTxWI =
+		    (PTXWI_STRUC) & pWirelessPkt[TmpBulkEndPos + TXINFO_SIZE];
 
 		if (pAd->bForcePrintTX == TRUE)
-			DBGPRINT(RT_DEBUG_TRACE, ("RTUSBBulkOutDataPacket AMPDU = %d.\n",   pTxWI->AMPDU));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("RTUSBBulkOutDataPacket AMPDU = %d.\n",
+				  pTxWI->AMPDU));
 
 		// add by Iverson, limit BulkOut size to 4k to pass WMM b mode 2T1R test items
 		//if ((ThisBulkSize != 0)  && (pTxWI->AMPDU == 0))
-		if ((ThisBulkSize != 0) && (pTxWI->PHYMODE == MODE_CCK))
-		{
-			if (((ThisBulkSize&0xffff8000) != 0) || ((ThisBulkSize&0x1000) == 0x1000))
-			{
+		if ((ThisBulkSize != 0) && (pTxWI->PHYMODE == MODE_CCK)) {
+			if (((ThisBulkSize & 0xffff8000) != 0)
+			    || ((ThisBulkSize & 0x1000) == 0x1000)) {
 				// Limit BulkOut size to about 4k bytes.
-				pHTTXContext->ENextBulkOutPosition = TmpBulkEndPos;
+				pHTTXContext->ENextBulkOutPosition =
+				    TmpBulkEndPos;
 				break;
-			}
-			else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize&0xfffff800) != 0) ) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0))*/)
-			{
+			} else
+			    if (((pAd->BulkOutMaxPacketSize < 512)
+				 && ((ThisBulkSize & 0xfffff800) !=
+				     0))
+				/*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */
+				) {
 				// For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size.
 				// For performence in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04.
-				pHTTXContext->ENextBulkOutPosition = TmpBulkEndPos;
+				pHTTXContext->ENextBulkOutPosition =
+				    TmpBulkEndPos;
 				break;
 			}
 		}
 		// end Iverson
-		else
-		{
-			if (((ThisBulkSize&0xffff8000) != 0) || ((ThisBulkSize&0x6000) == 0x6000))
-			{	// Limit BulkOut size to about 24k bytes.
-				pHTTXContext->ENextBulkOutPosition = TmpBulkEndPos;
+		else {
+			if (((ThisBulkSize & 0xffff8000) != 0) || ((ThisBulkSize & 0x6000) == 0x6000)) {	// Limit BulkOut size to about 24k bytes.
+				pHTTXContext->ENextBulkOutPosition =
+				    TmpBulkEndPos;
 				break;
-			}
-			else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize&0xfffff800) != 0) ) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0))*/)
-			{	// For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size.
+			} else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize & 0xfffff800) != 0)) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */ ) {	// For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size.
 				// For performence in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04.
-				pHTTXContext->ENextBulkOutPosition = TmpBulkEndPos;
+				pHTTXContext->ENextBulkOutPosition =
+				    TmpBulkEndPos;
 				break;
 			}
 		}
 
-		if (TmpBulkEndPos == pHTTXContext->CurWritePosition)
-		{
+		if (TmpBulkEndPos == pHTTXContext->CurWritePosition) {
 			pHTTXContext->ENextBulkOutPosition = TmpBulkEndPos;
 			break;
 		}
 
-		if (pTxInfo->QSEL != FIFO_EDCA)
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("%s(): ====> pTxInfo->QueueSel(%d)!= FIFO_EDCA!!!!\n",
-										__FUNCTION__, pTxInfo->QSEL));
-			DBGPRINT(RT_DEBUG_ERROR, ("\tCWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n",
-										pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition,
-										pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
-			hex_dump("Wrong QSel Pkt:", (PUCHAR)&pWirelessPkt[TmpBulkEndPos], (pHTTXContext->CurWritePosition - pHTTXContext->NextBulkOutPosition));
-		}
-
-		if (pTxInfo->USBDMATxPktLen <= 8)
-		{
-			BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
-			DBGPRINT(RT_DEBUG_ERROR /*RT_DEBUG_TRACE*/,("e2, USBDMATxPktLen==0, Size=%ld, bCSPad=%d, CWPos=%ld, NBPos=%ld, CWRPos=%ld!\n",
-					pHTTXContext->BulkOutSize, pHTTXContext->bCopySavePad, pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition, pHTTXContext->CurWriteRealPos));
+		if (pTxInfo->QSEL != FIFO_EDCA) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("%s(): ====> pTxInfo->QueueSel(%d)!= FIFO_EDCA!!!!\n",
+				  __FUNCTION__, pTxInfo->QSEL));
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("\tCWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n",
+				  pHTTXContext->CurWritePosition,
+				  pHTTXContext->NextBulkOutPosition,
+				  pHTTXContext->ENextBulkOutPosition,
+				  pHTTXContext->bCopySavePad));
+			hex_dump("Wrong QSel Pkt:",
+				 (PUCHAR) & pWirelessPkt[TmpBulkEndPos],
+				 (pHTTXContext->CurWritePosition -
+				  pHTTXContext->NextBulkOutPosition));
+		}
+
+		if (pTxInfo->USBDMATxPktLen <= 8) {
+			BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId],
+					IrqFlags2);
+			DBGPRINT(RT_DEBUG_ERROR /*RT_DEBUG_TRACE */ ,
+				 ("e2, USBDMATxPktLen==0, Size=%ld, bCSPad=%d, CWPos=%ld, NBPos=%ld, CWRPos=%ld!\n",
+				  pHTTXContext->BulkOutSize,
+				  pHTTXContext->bCopySavePad,
+				  pHTTXContext->CurWritePosition,
+				  pHTTXContext->NextBulkOutPosition,
+				  pHTTXContext->CurWriteRealPos));
 			{
-				DBGPRINT_RAW(RT_DEBUG_ERROR /*RT_DEBUG_TRACE*/,("%x  %x  %x  %x  %x  %x  %x  %x \n",
-					pHTTXContext->SavedPad[0], pHTTXContext->SavedPad[1], pHTTXContext->SavedPad[2],pHTTXContext->SavedPad[3]
-					,pHTTXContext->SavedPad[4], pHTTXContext->SavedPad[5], pHTTXContext->SavedPad[6],pHTTXContext->SavedPad[7]));
+				DBGPRINT_RAW(RT_DEBUG_ERROR /*RT_DEBUG_TRACE */
+					     ,
+					     ("%x  %x  %x  %x  %x  %x  %x  %x \n",
+					      pHTTXContext->SavedPad[0],
+					      pHTTXContext->SavedPad[1],
+					      pHTTXContext->SavedPad[2],
+					      pHTTXContext->SavedPad[3]
+					      , pHTTXContext->SavedPad[4],
+					      pHTTXContext->SavedPad[5],
+					      pHTTXContext->SavedPad[6],
+					      pHTTXContext->SavedPad[7]));
 			}
 			pAd->bForcePrintTX = TRUE;
-			BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+			BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId],
+				      IrqFlags);
 			pAd->BulkOutPending[BulkOutPipeId] = FALSE;
-			BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+			BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId],
+					IrqFlags);
 			//DBGPRINT(RT_DEBUG_LOUD,("Out:pTxInfo->USBDMATxPktLen=%d!\n", pTxInfo->USBDMATxPktLen));
 			return;
 		}
-
-			// Increase Total transmit byte counter
-		pAd->RalinkCounters.OneSecTransmittedByteCount +=  pTxWI->MPDUtotalByteCount;
-		pAd->RalinkCounters.TransmittedByteCount +=  pTxWI->MPDUtotalByteCount;
+		// Increase Total transmit byte counter
+		pAd->RalinkCounters.OneSecTransmittedByteCount +=
+		    pTxWI->MPDUtotalByteCount;
+		pAd->RalinkCounters.TransmittedByteCount +=
+		    pTxWI->MPDUtotalByteCount;
 
 		pLastTxInfo = pTxInfo;
 
 		// Make sure we use EDCA QUEUE.
 		pTxInfo->QSEL = FIFO_EDCA;
-		ThisBulkSize += (pTxInfo->USBDMATxPktLen+4);
-		TmpBulkEndPos += (pTxInfo->USBDMATxPktLen+4);
+		ThisBulkSize += (pTxInfo->USBDMATxPktLen + 4);
+		TmpBulkEndPos += (pTxInfo->USBDMATxPktLen + 4);
 
 		if (TmpBulkEndPos != pHTTXContext->CurWritePosition)
 			pTxInfo->USBDMANextVLD = 1;
 
-		if (pTxInfo->SwUseLastRound == 1)
-		{
+		if (pTxInfo->SwUseLastRound == 1) {
 			if (pHTTXContext->CurWritePosition == 8)
 				pTxInfo->USBDMANextVLD = 0;
 			pTxInfo->SwUseLastRound = 0;
@@ -371,73 +395,90 @@ VOID	RTUSBBulkOutDataPacket(
 			bTxQLastRound = TRUE;
 			pHTTXContext->ENextBulkOutPosition = 8;
 
-
 			break;
 		}
 
-
-	}while (TRUE);
+	} while (TRUE);
 
 	// adjust the pTxInfo->USBDMANextVLD value of last pTxInfo.
-	if (pLastTxInfo)
-	{
+	if (pLastTxInfo) {
 		pLastTxInfo->USBDMANextVLD = 0;
 	}
 
 	/*
-		We need to copy SavedPad when following condition matched!
-			1. Not the last round of the TxQueue and
-			2. any match of following cases:
-				(1). The End Position of this bulk out is reach to the Currenct Write position and
-						the TxInfo and related header already write to the CurWritePosition.
-			   		=>(ENextBulkOutPosition == CurWritePosition) && (CurWriteRealPos > CurWritePosition)
-
-				(2). The EndPosition of the bulk out is not reach to the Current Write Position.
-					=>(ENextBulkOutPosition != CurWritePosition)
-	*/
+	   We need to copy SavedPad when following condition matched!
+	   1. Not the last round of the TxQueue and
+	   2. any match of following cases:
+	   (1). The End Position of this bulk out is reach to the Currenct Write position and
+	   the TxInfo and related header already write to the CurWritePosition.
+	   =>(ENextBulkOutPosition == CurWritePosition) && (CurWriteRealPos > CurWritePosition)
+
+	   (2). The EndPosition of the bulk out is not reach to the Current Write Position.
+	   =>(ENextBulkOutPosition != CurWritePosition)
+	 */
 	if ((bTxQLastRound == FALSE) &&
-		 (((pHTTXContext->ENextBulkOutPosition == pHTTXContext->CurWritePosition) && (pHTTXContext->CurWriteRealPos > pHTTXContext->CurWritePosition)) ||
-		  (pHTTXContext->ENextBulkOutPosition != pHTTXContext->CurWritePosition))
-		)
-	{
-		NdisMoveMemory(pHTTXContext->SavedPad, &pWirelessPkt[pHTTXContext->ENextBulkOutPosition], 8);
+	    (((pHTTXContext->ENextBulkOutPosition ==
+	       pHTTXContext->CurWritePosition)
+	      && (pHTTXContext->CurWriteRealPos >
+		  pHTTXContext->CurWritePosition))
+	     || (pHTTXContext->ENextBulkOutPosition !=
+		 pHTTXContext->CurWritePosition))
+	    ) {
+		NdisMoveMemory(pHTTXContext->SavedPad,
+			       &pWirelessPkt[pHTTXContext->
+					     ENextBulkOutPosition], 8);
 		pHTTXContext->bCopySavePad = TRUE;
-		if (RTMPEqualMemory(pHTTXContext->SavedPad, allzero,4))
-		{
-			PUCHAR	pBuf = &pHTTXContext->SavedPad[0];
-			DBGPRINT_RAW(RT_DEBUG_ERROR,("WARNING-Zero-3:%02x%02x%02x%02x%02x%02x%02x%02x,CWPos=%ld, CWRPos=%ld, bCW=%d, NBPos=%ld, TBPos=%ld, TBSize=%ld\n",
-				pBuf[0], pBuf[1], pBuf[2],pBuf[3],pBuf[4], pBuf[5], pBuf[6],pBuf[7], pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos,
-				pHTTXContext->bCurWriting, pHTTXContext->NextBulkOutPosition, TmpBulkEndPos, ThisBulkSize));
+		if (RTMPEqualMemory(pHTTXContext->SavedPad, allzero, 4)) {
+			PUCHAR pBuf = &pHTTXContext->SavedPad[0];
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("WARNING-Zero-3:%02x%02x%02x%02x%02x%02x%02x%02x,CWPos=%ld, CWRPos=%ld, bCW=%d, NBPos=%ld, TBPos=%ld, TBSize=%ld\n",
+				      pBuf[0], pBuf[1], pBuf[2], pBuf[3],
+				      pBuf[4], pBuf[5], pBuf[6], pBuf[7],
+				      pHTTXContext->CurWritePosition,
+				      pHTTXContext->CurWriteRealPos,
+				      pHTTXContext->bCurWriting,
+				      pHTTXContext->NextBulkOutPosition,
+				      TmpBulkEndPos, ThisBulkSize));
 
 			pBuf = &pWirelessPkt[pHTTXContext->CurWritePosition];
-			DBGPRINT_RAW(RT_DEBUG_ERROR,("\tCWPos=%02x%02x%02x%02x%02x%02x%02x%02x\n", pBuf[0], pBuf[1], pBuf[2],pBuf[3],pBuf[4], pBuf[5], pBuf[6],pBuf[7]));
+			DBGPRINT_RAW(RT_DEBUG_ERROR,
+				     ("\tCWPos=%02x%02x%02x%02x%02x%02x%02x%02x\n",
+				      pBuf[0], pBuf[1], pBuf[2], pBuf[3],
+				      pBuf[4], pBuf[5], pBuf[6], pBuf[7]));
 		}
 		//DBGPRINT(RT_DEBUG_LOUD,("ENPos==CWPos=%ld, CWRPos=%ld, bCSPad=%d!\n", pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->bCopySavePad));
 	}
 
 	if (pAd->bForcePrintTX == TRUE)
-		DBGPRINT(RT_DEBUG_TRACE,("BulkOut-A:Size=%ld, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n", ThisBulkSize, pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("BulkOut-A:Size=%ld, CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d!\n",
+			  ThisBulkSize, pHTTXContext->CurWritePosition,
+			  pHTTXContext->NextBulkOutPosition,
+			  pHTTXContext->ENextBulkOutPosition,
+			  pHTTXContext->bCopySavePad));
 	//DBGPRINT(RT_DEBUG_LOUD,("BulkOut-A:Size=%ld, CWPos=%ld, CWRPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d, bLRound=%d!\n", ThisBulkSize, pHTTXContext->CurWritePosition, pHTTXContext->CurWriteRealPos, pHTTXContext->NextBulkOutPosition, pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad, bTxQLastRound));
 
-		// USB DMA engine requires to pad extra 4 bytes. This pad doesn't count into real bulkoutsize.
+	// USB DMA engine requires to pad extra 4 bytes. This pad doesn't count into real bulkoutsize.
 	pAppendant = &pWirelessPkt[TmpBulkEndPos];
 	NdisZeroMemory(pAppendant, 8);
+	ThisBulkSize += 4;
+	pHTTXContext->LastOne = TRUE;
+	if ((ThisBulkSize % pAd->BulkOutMaxPacketSize) == 0)
 		ThisBulkSize += 4;
-		pHTTXContext->LastOne = TRUE;
-		if ((ThisBulkSize % pAd->BulkOutMaxPacketSize) == 0)
-			ThisBulkSize += 4;
 	pHTTXContext->BulkOutSize = ThisBulkSize;
 
 	pAd->watchDogTxPendingCnt[BulkOutPipeId] = 1;
 	BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
 
 	// Init Tx context descriptor
-	RTUSBInitHTTxDesc(pAd, pHTTXContext, BulkOutPipeId, ThisBulkSize, (usb_complete_t)RTUSBBulkOutDataPacketComplete);
+	RTUSBInitHTTxDesc(pAd, pHTTXContext, BulkOutPipeId, ThisBulkSize,
+			  (usb_complete_t) RTUSBBulkOutDataPacketComplete);
 
 	pUrb = pHTTXContext->pUrb;
-	if((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("RTUSBBulkOutDataPacket: Submit Tx URB failed %d\n", ret));
+	if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTUSBBulkOutDataPacket: Submit Tx URB failed %d\n",
+			  ret));
 
 		BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
 		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
@@ -454,47 +495,42 @@ VOID	RTUSBBulkOutDataPacket(
 
 }
 
-
-VOID RTUSBBulkOutDataPacketComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+VOID RTUSBBulkOutDataPacketComplete(purbb_t pUrb, struct pt_regs * pt_regs)
 {
-	PHT_TX_CONTEXT	pHTTXContext;
-	PRTMP_ADAPTER	pAd;
-	POS_COOKIE 		pObj;
-	UCHAR			BulkOutPipeId;
+	PHT_TX_CONTEXT pHTTXContext;
+	PRTMP_ADAPTER pAd;
+	POS_COOKIE pObj;
+	UCHAR BulkOutPipeId;
 
-
-	pHTTXContext	= (PHT_TX_CONTEXT)pUrb->context;
-	pAd 			= pHTTXContext->pAd;
-	pObj 			= (POS_COOKIE) pAd->OS_Cookie;
+	pHTTXContext = (PHT_TX_CONTEXT) pUrb->context;
+	pAd = pHTTXContext->pAd;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	// Store BulkOut PipeId
-	BulkOutPipeId	= pHTTXContext->BulkOutPipeId;
+	BulkOutPipeId = pHTTXContext->BulkOutPipeId;
 	pAd->BulkOutDataOneSecCount++;
 
-	switch (BulkOutPipeId)
-	{
-		case 0:
-				pObj->ac0_dma_done_task.data = (unsigned long)pUrb;
-				tasklet_hi_schedule(&pObj->ac0_dma_done_task);
-				break;
-		case 1:
-				pObj->ac1_dma_done_task.data = (unsigned long)pUrb;
-				tasklet_hi_schedule(&pObj->ac1_dma_done_task);
-				break;
-		case 2:
-				pObj->ac2_dma_done_task.data = (unsigned long)pUrb;
-				tasklet_hi_schedule(&pObj->ac2_dma_done_task);
-				break;
-		case 3:
-				pObj->ac3_dma_done_task.data = (unsigned long)pUrb;
-				tasklet_hi_schedule(&pObj->ac3_dma_done_task);
-				break;
+	switch (BulkOutPipeId) {
+	case 0:
+		pObj->ac0_dma_done_task.data = (unsigned long)pUrb;
+		tasklet_hi_schedule(&pObj->ac0_dma_done_task);
+		break;
+	case 1:
+		pObj->ac1_dma_done_task.data = (unsigned long)pUrb;
+		tasklet_hi_schedule(&pObj->ac1_dma_done_task);
+		break;
+	case 2:
+		pObj->ac2_dma_done_task.data = (unsigned long)pUrb;
+		tasklet_hi_schedule(&pObj->ac2_dma_done_task);
+		break;
+	case 3:
+		pObj->ac3_dma_done_task.data = (unsigned long)pUrb;
+		tasklet_hi_schedule(&pObj->ac3_dma_done_task);
+		break;
 	}
 
-
 }
 
-
 /*
 	========================================================================
 
@@ -508,17 +544,16 @@ VOID RTUSBBulkOutDataPacketComplete(purb
 
 	========================================================================
 */
-VOID	RTUSBBulkOutNullFrame(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBBulkOutNullFrame(IN PRTMP_ADAPTER pAd)
 {
-	PTX_CONTEXT		pNullContext = &(pAd->NullContext);
-	PURB			pUrb;
-	int				ret = 0;
-	unsigned long	IrqFlags;
+	PTX_CONTEXT pNullContext = &(pAd->NullContext);
+	PURB pUrb;
+	int ret = 0;
+	unsigned long IrqFlags;
 
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
-	if ((pAd->BulkOutPending[0] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX))
-	{
+	if ((pAd->BulkOutPending[0] == TRUE)
+	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)) {
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
 		return;
 	}
@@ -528,42 +563,42 @@ VOID	RTUSBBulkOutNullFrame(
 	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
 
 	// Increase Total transmit byte counter
-	pAd->RalinkCounters.TransmittedByteCount +=  pNullContext->BulkOutSize;
-
+	pAd->RalinkCounters.TransmittedByteCount += pNullContext->BulkOutSize;
 
 	// Clear Null frame bulk flag
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
 
 	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pNullContext, 0, (usb_complete_t)RTUSBBulkOutNullFrameComplete);
+	RTUSBInitTxDesc(pAd, pNullContext, 0,
+			(usb_complete_t) RTUSBBulkOutNullFrameComplete);
 
 	pUrb = pNullContext->pUrb;
-	if((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
-	{
+	if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {
 		RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
 		pAd->BulkOutPending[0] = FALSE;
 		pAd->watchDogTxPendingCnt[0] = 0;
 		pNullContext->IRPPending = FALSE;
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
 
-		DBGPRINT(RT_DEBUG_ERROR, ("RTUSBBulkOutNullFrame: Submit Tx URB failed %d\n", ret));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTUSBBulkOutNullFrame: Submit Tx URB failed %d\n",
+			  ret));
 		return;
 	}
 
 }
 
 // NULL frame use BulkOutPipeId = 0
-VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb, struct pt_regs * pt_regs)
 {
-	PRTMP_ADAPTER		pAd;
-	PTX_CONTEXT			pNullContext;
-	NTSTATUS			Status;
-	POS_COOKIE			pObj;
-
+	PRTMP_ADAPTER pAd;
+	PTX_CONTEXT pNullContext;
+	NTSTATUS Status;
+	POS_COOKIE pObj;
 
-	pNullContext	= (PTX_CONTEXT)pUrb->context;
-	pAd 			= pNullContext->pAd;
-	Status 			= pUrb->status;
+	pNullContext = (PTX_CONTEXT) pUrb->context;
+	pAd = pNullContext->pAd;
+	Status = pUrb->status;
 
 	pObj = (POS_COOKIE) pAd->OS_Cookie;
 	pObj->null_frame_complete_task.data = (unsigned long)pUrb;
@@ -583,23 +618,20 @@ VOID RTUSBBulkOutNullFrameComplete(purbb
 
 	========================================================================
 */
-VOID	RTUSBBulkOutMLMEPacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Index)
-{
-	PTX_CONTEXT		pMLMEContext;
-	PURB			pUrb;
-	int				ret = 0;
-	unsigned long	IrqFlags;
+VOID RTUSBBulkOutMLMEPacket(IN PRTMP_ADAPTER pAd, IN UCHAR Index)
+{
+	PTX_CONTEXT pMLMEContext;
+	PURB pUrb;
+	int ret = 0;
+	unsigned long IrqFlags;
 
-	pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[pAd->MgmtRing.TxDmaIdx].AllocVa;
+	pMLMEContext =
+	    (PTX_CONTEXT) pAd->MgmtRing.Cell[pAd->MgmtRing.TxDmaIdx].AllocVa;
 	pUrb = pMLMEContext->pUrb;
 
 	if ((pAd->MgmtRing.TxSwFreeIdx >= MGMT_RING_SIZE) ||
-		(pMLMEContext->InUse == FALSE) ||
-		(pMLMEContext->bWaitingBulkOut == FALSE))
-	{
-
+	    (pMLMEContext->InUse == FALSE) ||
+	    (pMLMEContext->bWaitingBulkOut == FALSE)) {
 
 		// Clear MLME bulk flag
 		RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
@@ -607,10 +639,9 @@ VOID	RTUSBBulkOutMLMEPacket(
 		return;
 	}
 
-
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
-	if ((pAd->BulkOutPending[MGMTPIPEIDX] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX))
-	{
+	if ((pAd->BulkOutPending[MGMTPIPEIDX] == TRUE)
+	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)) {
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
 		return;
 	}
@@ -622,22 +653,24 @@ VOID	RTUSBBulkOutMLMEPacket(
 	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
 
 	// Increase Total transmit byte counter
-	pAd->RalinkCounters.TransmittedByteCount +=  pMLMEContext->BulkOutSize;
+	pAd->RalinkCounters.TransmittedByteCount += pMLMEContext->BulkOutSize;
 
 	// Clear MLME bulk flag
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
 
 	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pMLMEContext, MGMTPIPEIDX, (usb_complete_t)RTUSBBulkOutMLMEPacketComplete);
+	RTUSBInitTxDesc(pAd, pMLMEContext, MGMTPIPEIDX,
+			(usb_complete_t) RTUSBBulkOutMLMEPacketComplete);
 
 	//For mgmt urb buffer, because we use sk_buff, so we need to notify the USB controller do dma mapping.
-	pUrb->transfer_dma	= 0;
+	pUrb->transfer_dma = 0;
 	pUrb->transfer_flags &= (~URB_NO_TRANSFER_DMA_MAP);
 
 	pUrb = pMLMEContext->pUrb;
-	if((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("RTUSBBulkOutMLMEPacket: Submit MLME URB failed %d\n", ret));
+	if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTUSBBulkOutMLMEPacket: Submit MLME URB failed %d\n",
+			  ret));
 		RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
 		pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
 		pAd->watchDogTxPendingCnt[MGMTPIPEIDX] = 0;
@@ -647,32 +680,29 @@ VOID	RTUSBBulkOutMLMEPacket(
 
 		return;
 	}
-
 	//DBGPRINT_RAW(RT_DEBUG_INFO, ("<---RTUSBBulkOutMLMEPacket \n"));
-//	printk("<---RTUSBBulkOutMLMEPacket,Cpu=%d!, Dma=%d, SwIdx=%d!\n", pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx);
+//      printk("<---RTUSBBulkOutMLMEPacket,Cpu=%d!, Dma=%d, SwIdx=%d!\n", pAd->MgmtRing.TxCpuIdx, pAd->MgmtRing.TxDmaIdx, pAd->MgmtRing.TxSwFreeIdx);
 }
 
-
-VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb, struct pt_regs * pt_regs)
 {
-	PTX_CONTEXT			pMLMEContext;
-	PRTMP_ADAPTER		pAd;
-	NTSTATUS			Status;
-	POS_COOKIE 			pObj;
-	int					index;
+	PTX_CONTEXT pMLMEContext;
+	PRTMP_ADAPTER pAd;
+	NTSTATUS Status;
+	POS_COOKIE pObj;
+	int index;
 
 	//DBGPRINT_RAW(RT_DEBUG_INFO, ("--->RTUSBBulkOutMLMEPacketComplete\n"));
-	pMLMEContext	= (PTX_CONTEXT)pUrb->context;
-	pAd 			= pMLMEContext->pAd;
-	pObj 			= (POS_COOKIE)pAd->OS_Cookie;
-	Status			= pUrb->status;
-	index 			= pMLMEContext->SelfIdx;
+	pMLMEContext = (PTX_CONTEXT) pUrb->context;
+	pAd = pMLMEContext->pAd;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
+	Status = pUrb->status;
+	index = pMLMEContext->SelfIdx;
 
 	pObj->mgmt_dma_done_task.data = (unsigned long)pUrb;
 	tasklet_hi_schedule(&pObj->mgmt_dma_done_task);
 }
 
-
 /*
 	========================================================================
 
@@ -686,17 +716,16 @@ VOID RTUSBBulkOutMLMEPacketComplete(purb
 
 	========================================================================
 */
-VOID	RTUSBBulkOutPsPoll(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBBulkOutPsPoll(IN PRTMP_ADAPTER pAd)
 {
-	PTX_CONTEXT		pPsPollContext = &(pAd->PsPollContext);
-	PURB			pUrb;
-	int				ret = 0;
-	unsigned long	IrqFlags;
+	PTX_CONTEXT pPsPollContext = &(pAd->PsPollContext);
+	PURB pUrb;
+	int ret = 0;
+	unsigned long IrqFlags;
 
 	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
-	if ((pAd->BulkOutPending[0] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX))
-	{
+	if ((pAd->BulkOutPending[0] == TRUE)
+	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)) {
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
 		return;
 	}
@@ -705,38 +734,38 @@ VOID	RTUSBBulkOutPsPoll(
 	pPsPollContext->IRPPending = TRUE;
 	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
 
-
 	// Clear PS-Poll bulk flag
 	RTUSB_CLEAR_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL);
 
 	// Init Tx context descriptor
-	RTUSBInitTxDesc(pAd, pPsPollContext, MGMTPIPEIDX, (usb_complete_t)RTUSBBulkOutPsPollComplete);
+	RTUSBInitTxDesc(pAd, pPsPollContext, MGMTPIPEIDX,
+			(usb_complete_t) RTUSBBulkOutPsPollComplete);
 
 	pUrb = pPsPollContext->pUrb;
-	if((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
-	{
+	if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {
 		RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
 		pAd->BulkOutPending[0] = FALSE;
 		pAd->watchDogTxPendingCnt[0] = 0;
 		pPsPollContext->IRPPending = FALSE;
 		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
 
-		DBGPRINT(RT_DEBUG_ERROR, ("RTUSBBulkOutPsPoll: Submit Tx URB failed %d\n", ret));
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTUSBBulkOutPsPoll: Submit Tx URB failed %d\n",
+			  ret));
 		return;
 	}
 
 }
 
 // PS-Poll frame use BulkOutPipeId = 0
-VOID RTUSBBulkOutPsPollComplete(purbb_t pUrb,struct pt_regs *pt_regs)
+VOID RTUSBBulkOutPsPollComplete(purbb_t pUrb, struct pt_regs * pt_regs)
 {
-	PRTMP_ADAPTER		pAd;
-	PTX_CONTEXT			pPsPollContext;
-	NTSTATUS			Status;
-	POS_COOKIE			pObj;
-
+	PRTMP_ADAPTER pAd;
+	PTX_CONTEXT pPsPollContext;
+	NTSTATUS Status;
+	POS_COOKIE pObj;
 
-	pPsPollContext= (PTX_CONTEXT)pUrb->context;
+	pPsPollContext = (PTX_CONTEXT) pUrb->context;
 	pAd = pPsPollContext->pAd;
 	Status = pUrb->status;
 
@@ -745,17 +774,17 @@ VOID RTUSBBulkOutPsPollComplete(purbb_t 
 	tasklet_hi_schedule(&pObj->pspoll_frame_complete_task);
 }
 
-VOID DoBulkIn(IN RTMP_ADAPTER *pAd)
+VOID DoBulkIn(IN RTMP_ADAPTER * pAd)
 {
-	PRX_CONTEXT		pRxContext;
-	PURB			pUrb;
-	int				ret = 0;
-	unsigned long	IrqFlags;
+	PRX_CONTEXT pRxContext;
+	PURB pUrb;
+	int ret = 0;
+	unsigned long IrqFlags;
 
 	RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
 	pRxContext = &(pAd->RxContext[pAd->NextRxBulkInIndex]);
-	if ((pAd->PendingRx > 0) || (pRxContext->Readable == TRUE) || (pRxContext->InUse == TRUE))
-	{
+	if ((pAd->PendingRx > 0) || (pRxContext->Readable == TRUE)
+	    || (pRxContext->InUse == TRUE)) {
 		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 		return;
 	}
@@ -770,8 +799,7 @@ VOID DoBulkIn(IN RTMP_ADAPTER *pAd)
 	RTUSBInitRxDesc(pAd, pRxContext);
 
 	pUrb = pRxContext->pUrb;
-	if ((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
-	{	// fail
+	if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {	// fail
 
 		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
 		pRxContext->InUse = FALSE;
@@ -779,16 +807,14 @@ VOID DoBulkIn(IN RTMP_ADAPTER *pAd)
 		pAd->PendingRx--;
 		pAd->BulkInReq--;
 		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-		DBGPRINT(RT_DEBUG_ERROR, ("RTUSBBulkReceive: Submit Rx URB failed %d\n", ret));
-	}
-	else
-	{	// success
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTUSBBulkReceive: Submit Rx URB failed %d\n", ret));
+	} else {		// success
 		ASSERT((pRxContext->InUse == pRxContext->IRPPending));
 		//printk("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n", pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex);
 	}
 }
 
-
 /*
 	========================================================================
 
@@ -819,25 +845,22 @@ VOID DoBulkIn(IN RTMP_ADAPTER *pAd)
 		 fRTMP_ADAPTER_RADIO_OFF | fRTMP_ADAPTER_RESET_IN_PROGRESS | \
 		 fRTMP_ADAPTER_REMOVE_IN_PROGRESS)
 
-VOID	RTUSBBulkReceive(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBBulkReceive(IN PRTMP_ADAPTER pAd)
 {
-	PRX_CONTEXT		pRxContext;
-	unsigned long	IrqFlags;
-
+	PRX_CONTEXT pRxContext;
+	unsigned long IrqFlags;
 
 	/* sanity check */
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_HANDLE_RX))
 		return;
 
-	while(1)
-	{
+	while (1) {
 
 		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
 		pRxContext = &(pAd->RxContext[pAd->NextRxBulkInReadIndex]);
-		if (((pRxContext->InUse == FALSE) && (pRxContext->Readable == TRUE)) &&
-			(pRxContext->bRxHandling == FALSE))
-		{
+		if (((pRxContext->InUse == FALSE)
+		     && (pRxContext->Readable == TRUE))
+		    && (pRxContext->bRxHandling == FALSE)) {
 			pRxContext->bRxHandling = TRUE;
 			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 
@@ -851,12 +874,11 @@ VOID	RTUSBBulkReceive(
 			pRxContext->bRxHandling = FALSE;
 			pAd->ReadPosition = 0;
 			pAd->TransferBufferLength = 0;
-			INC_RING_INDEX(pAd->NextRxBulkInReadIndex, RX_RING_SIZE);
+			INC_RING_INDEX(pAd->NextRxBulkInReadIndex,
+				       RX_RING_SIZE);
 			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 
-		}
-		else
-		{
+		} else {
 			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 			break;
 		}
@@ -867,7 +889,6 @@ VOID	RTUSBBulkReceive(
 
 }
 
-
 /*
 	========================================================================
 
@@ -896,22 +917,19 @@ VOID RTUSBBulkRxComplete(purbb_t pUrb, s
 	// use a receive tasklet to handle received packets;
 	// or sometimes hardware IRQ will be disabled here, so we can not
 	// use spin_lock_bh()/spin_unlock_bh() after IRQ is disabled. :<
-	PRX_CONTEXT		pRxContext;
-	PRTMP_ADAPTER	pAd;
-	POS_COOKIE 		pObj;
+	PRX_CONTEXT pRxContext;
+	PRTMP_ADAPTER pAd;
+	POS_COOKIE pObj;
 
-
-	pRxContext	= (PRX_CONTEXT)pUrb->context;
-	pAd 		= pRxContext->pAd;
-	pObj 		= (POS_COOKIE) pAd->OS_Cookie;
+	pRxContext = (PRX_CONTEXT) pUrb->context;
+	pAd = pRxContext->pAd;
+	pObj = (POS_COOKIE) pAd->OS_Cookie;
 
 	pObj->rx_done_task.data = (unsigned long)pUrb;
 	tasklet_hi_schedule(&pObj->rx_done_task);
 
 }
 
-
-
 /*
 	========================================================================
 
@@ -925,76 +943,78 @@ VOID RTUSBBulkRxComplete(purbb_t pUrb, s
 
 	========================================================================
 */
-VOID	RTUSBKickBulkOut(
-	IN	PRTMP_ADAPTER pAd)
+VOID RTUSBKickBulkOut(IN PRTMP_ADAPTER pAd)
 {
 	// BulkIn Reset will reset whole USB PHY. So we need to make sure fRTMP_ADAPTER_BULKIN_RESET not flaged.
-	if (!RTMP_TEST_FLAG(pAd ,fRTMP_ADAPTER_NEED_STOP_TX)
-		)
-	{
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)
+	    ) {
 		// 2. PS-Poll frame is next
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL))
-		{
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL)) {
 			RTUSBBulkOutPsPoll(pAd);
 		}
-
 		// 5. Mlme frame is next
 		else if ((RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME)) ||
-				 (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE))
-		{
+			 (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE)) {
 			RTUSBBulkOutMLMEPacket(pAd, pAd->MgmtRing.TxDmaIdx);
 		}
-
 		// 6. Data frame normal is next
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL))
-		{
-			if (((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
-				(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				))
-			{
-				RTUSBBulkOutDataPacket(pAd, 0, pAd->NextBulkOutIndex[0]);
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL)) {
+			if (((!RTMP_TEST_FLAG
+			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+			     ||
+			     (!OPSTATUS_TEST_FLAG
+			      (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+			    )) {
+				RTUSBBulkOutDataPacket(pAd, 0,
+						       pAd->
+						       NextBulkOutIndex[0]);
 			}
 		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_2))
-		{
-			if (((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
-				(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				))
-			{
-				RTUSBBulkOutDataPacket(pAd, 1, pAd->NextBulkOutIndex[1]);
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_2)) {
+			if (((!RTMP_TEST_FLAG
+			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+			     ||
+			     (!OPSTATUS_TEST_FLAG
+			      (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+			    )) {
+				RTUSBBulkOutDataPacket(pAd, 1,
+						       pAd->
+						       NextBulkOutIndex[1]);
 			}
 		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_3))
-		{
-			if (((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
-				(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				))
-			{
-				RTUSBBulkOutDataPacket(pAd, 2, pAd->NextBulkOutIndex[2]);
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_3)) {
+			if (((!RTMP_TEST_FLAG
+			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+			     ||
+			     (!OPSTATUS_TEST_FLAG
+			      (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+			    )) {
+				RTUSBBulkOutDataPacket(pAd, 2,
+						       pAd->
+						       NextBulkOutIndex[2]);
 			}
 		}
-		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_4))
-		{
-			if (((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
-				(!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				))
-			{
-				RTUSBBulkOutDataPacket(pAd, 3, pAd->NextBulkOutIndex[3]);
+		if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NORMAL_4)) {
+			if (((!RTMP_TEST_FLAG
+			      (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+			     ||
+			     (!OPSTATUS_TEST_FLAG
+			      (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
+			    )) {
+				RTUSBBulkOutDataPacket(pAd, 3,
+						       pAd->
+						       NextBulkOutIndex[3]);
 			}
 		}
-
 		// 7. Null frame is the last
-		else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL))
-		{
-			if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
-			{
+		else if (RTUSB_TEST_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL)) {
+			if (!RTMP_TEST_FLAG
+			    (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) {
 				RTUSBBulkOutNullFrame(pAd);
 			}
 		}
-
 		// 8. No data avaliable
-		else
-		{
+		else {
 
 		}
 	}
@@ -1013,16 +1033,14 @@ VOID	RTUSBKickBulkOut(
 
 	========================================================================
 */
-VOID	RTUSBCleanUpDataBulkOutQueue(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBCleanUpDataBulkOutQueue(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR			Idx;
-	PHT_TX_CONTEXT	pTxContext;
+	UCHAR Idx;
+	PHT_TX_CONTEXT pTxContext;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--->CleanUpDataBulkOutQueue\n"));
 
-	for (Idx = 0; Idx < 4; Idx++)
-	{
+	for (Idx = 0; Idx < 4; Idx++) {
 		pTxContext = &pAd->TxContext[Idx];
 
 		pTxContext->CurWritePosition = pTxContext->NextBulkOutPosition;
@@ -1048,14 +1066,12 @@ VOID	RTUSBCleanUpDataBulkOutQueue(
 
 	========================================================================
 */
-VOID	RTUSBCleanUpMLMEBulkOutQueue(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBCleanUpMLMEBulkOutQueue(IN PRTMP_ADAPTER pAd)
 {
 	DBGPRINT(RT_DEBUG_TRACE, ("--->CleanUpMLMEBulkOutQueue\n"));
 	DBGPRINT(RT_DEBUG_TRACE, ("<---CleanUpMLMEBulkOutQueue\n"));
 }
 
-
 /*
 	========================================================================
 
@@ -1065,13 +1081,11 @@ VOID	RTUSBCleanUpMLMEBulkOutQueue(
 
 	Return Value:
 
-
 	Note:
 
 	========================================================================
 */
-VOID	RTUSBCancelPendingIRPs(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBCancelPendingIRPs(IN PRTMP_ADAPTER pAd)
 {
 	RTUSBCancelPendingBulkInIRP(pAd);
 	RTUSBCancelPendingBulkOutIRP(pAd);
@@ -1090,18 +1104,15 @@ VOID	RTUSBCancelPendingIRPs(
 
 	========================================================================
 */
-VOID	RTUSBCancelPendingBulkInIRP(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBCancelPendingBulkInIRP(IN PRTMP_ADAPTER pAd)
 {
-	PRX_CONTEXT		pRxContext;
-	UINT			i;
+	PRX_CONTEXT pRxContext;
+	UINT i;
 
 	DBGPRINT_RAW(RT_DEBUG_TRACE, ("--->RTUSBCancelPendingBulkInIRP\n"));
-	for ( i = 0; i < (RX_RING_SIZE); i++)
-	{
+	for (i = 0; i < (RX_RING_SIZE); i++) {
 		pRxContext = &(pAd->RxContext[i]);
-		if(pRxContext->IRPPending == TRUE)
-		{
+		if (pRxContext->IRPPending == TRUE) {
 			RTUSB_UNLINK_URB(pRxContext->pUrb);
 			pRxContext->IRPPending = FALSE;
 			pRxContext->InUse = FALSE;
@@ -1112,7 +1123,6 @@ VOID	RTUSBCancelPendingBulkInIRP(
 	DBGPRINT_RAW(RT_DEBUG_TRACE, ("<---RTUSBCancelPendingBulkInIRP\n"));
 }
 
-
 /*
 	========================================================================
 
@@ -1126,34 +1136,30 @@ VOID	RTUSBCancelPendingBulkInIRP(
 
 	========================================================================
 */
-VOID	RTUSBCancelPendingBulkOutIRP(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBCancelPendingBulkOutIRP(IN PRTMP_ADAPTER pAd)
 {
-	PHT_TX_CONTEXT		pHTTXContext;
-	PTX_CONTEXT			pMLMEContext;
-	PTX_CONTEXT			pBeaconContext;
-	PTX_CONTEXT			pNullContext;
-	PTX_CONTEXT			pPsPollContext;
-	PTX_CONTEXT			pRTSContext;
-	UINT				i, Idx;
-//	unsigned int 		IrqFlags;
-//	NDIS_SPIN_LOCK		*pLock;
-//	BOOLEAN				*pPending;
+	PHT_TX_CONTEXT pHTTXContext;
+	PTX_CONTEXT pMLMEContext;
+	PTX_CONTEXT pBeaconContext;
+	PTX_CONTEXT pNullContext;
+	PTX_CONTEXT pPsPollContext;
+	PTX_CONTEXT pRTSContext;
+	UINT i, Idx;
+//      unsigned int            IrqFlags;
+//      NDIS_SPIN_LOCK          *pLock;
+//      BOOLEAN                         *pPending;
 
+//      pLock = &pAd->BulkOutLock[MGMTPIPEIDX];
+//      pPending = &pAd->BulkOutPending[MGMTPIPEIDX];
 
-//	pLock = &pAd->BulkOutLock[MGMTPIPEIDX];
-//	pPending = &pAd->BulkOutPending[MGMTPIPEIDX];
-
-	for (Idx = 0; Idx < 4; Idx++)
-	{
+	for (Idx = 0; Idx < 4; Idx++) {
 		pHTTXContext = &(pAd->TxContext[Idx]);
 
-		if (pHTTXContext->IRPPending == TRUE)
-		{
+		if (pHTTXContext->IRPPending == TRUE) {
 
 			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
 			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
-			//	when the last IRP on the list has been	cancelled; that's how we exit this loop
+			//      when the last IRP on the list has been  cancelled; that's how we exit this loop
 			//
 
 			RTUSB_UNLINK_URB(pHTTXContext->pUrb);
@@ -1166,15 +1172,13 @@ VOID	RTUSBCancelPendingBulkOutIRP(
 	}
 
 	//RTMP_IRQ_LOCK(pLock, IrqFlags);
-	for (i = 0; i < MGMT_RING_SIZE; i++)
-	{
-		pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[i].AllocVa;
-		if(pMLMEContext && (pMLMEContext->IRPPending == TRUE))
-		{
+	for (i = 0; i < MGMT_RING_SIZE; i++) {
+		pMLMEContext = (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
+		if (pMLMEContext && (pMLMEContext->IRPPending == TRUE)) {
 
 			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
 			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
-			//	when the last IRP on the list has been	cancelled; that's how we exit this loop
+			//      when the last IRP on the list has been  cancelled; that's how we exit this loop
 			//
 
 			RTUSB_UNLINK_URB(pMLMEContext->pUrb);
@@ -1187,17 +1191,14 @@ VOID	RTUSBCancelPendingBulkOutIRP(
 	pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
 	//RTMP_IRQ_UNLOCK(pLock, IrqFlags);
 
-
-	for (i = 0; i < BEACON_RING_SIZE; i++)
-	{
+	for (i = 0; i < BEACON_RING_SIZE; i++) {
 		pBeaconContext = &(pAd->BeaconContext[i]);
 
-		if(pBeaconContext->IRPPending == TRUE)
-		{
+		if (pBeaconContext->IRPPending == TRUE) {
 
 			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
 			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
-			//	when the last IRP on the list has been	cancelled; that's how we exit this loop
+			//      when the last IRP on the list has been  cancelled; that's how we exit this loop
 			//
 
 			RTUSB_UNLINK_URB(pBeaconContext->pUrb);
@@ -1219,8 +1220,7 @@ VOID	RTUSBCancelPendingBulkOutIRP(
 	if (pPsPollContext->IRPPending == TRUE)
 		RTUSB_UNLINK_URB(pPsPollContext->pUrb);
 
-	for (Idx = 0; Idx < 4; Idx++)
-	{
+	for (Idx = 0; Idx < 4; Idx++) {
 		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx]);
 		pAd->BulkOutPending[Idx] = FALSE;
 		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx]);
--- a/drivers/staging/rt2870/common/rtusb_data.c
+++ b/drivers/staging/rt2870/common/rtusb_data.c
@@ -39,40 +39,33 @@
 
 #ifdef RTMP_MAC_USB
 
-
 #include "../rt_config.h"
 
-extern  UCHAR Phy11BGNextRateUpward[]; // defined in mlme.c
-extern UCHAR	EpToQueue[];
+extern UCHAR Phy11BGNextRateUpward[];	// defined in mlme.c
+extern UCHAR EpToQueue[];
 
-VOID REPORT_AMSDU_FRAMES_TO_LLC(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pData,
-	IN	ULONG			DataSize)
-{
-	PNDIS_PACKET	pPacket;
-	UINT			nMSDU;
-	struct			sk_buff *pSkb;
+VOID REPORT_AMSDU_FRAMES_TO_LLC(IN PRTMP_ADAPTER pAd,
+				IN PUCHAR pData, IN ULONG DataSize)
+{
+	PNDIS_PACKET pPacket;
+	UINT nMSDU;
+	struct sk_buff *pSkb;
 
 	nMSDU = 0;
 	/* allocate a rx packet */
 	pSkb = dev_alloc_skb(RX_BUFFER_AGGRESIZE);
-	pPacket = (PNDIS_PACKET)OSPKT_TO_RTPKT(pSkb);
-	if (pSkb)
-	{
+	pPacket = (PNDIS_PACKET) OSPKT_TO_RTPKT(pSkb);
+	if (pSkb) {
 
 		/* convert 802.11 to 802.3 packet */
 		pSkb->dev = get_netdev_from_bssid(pAd, BSS0);
 		RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
 		deaggregate_AMSDU_announce(pAd, pPacket, pData, DataSize);
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("Can't allocate skb\n"));
+	} else {
+		DBGPRINT(RT_DEBUG_ERROR, ("Can't allocate skb\n"));
 	}
 }
 
-
 /*
 	========================================================================
 
@@ -92,50 +85,53 @@ VOID REPORT_AMSDU_FRAMES_TO_LLC(
 
 	========================================================================
 */
-NDIS_STATUS	RTUSBFreeDescriptorRequest(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			BulkOutPipeId,
-	IN	UINT32			NumberRequired)
-{
-//	UCHAR			FreeNumber = 0;
-//	UINT			Index;
-	NDIS_STATUS		Status = NDIS_STATUS_FAILURE;
-	unsigned long   IrqFlags;
-	HT_TX_CONTEXT	*pHTTXContext;
-
+NDIS_STATUS RTUSBFreeDescriptorRequest(IN PRTMP_ADAPTER pAd,
+				       IN UCHAR BulkOutPipeId,
+				       IN UINT32 NumberRequired)
+{
+//      UCHAR                   FreeNumber = 0;
+//      UINT                    Index;
+	NDIS_STATUS Status = NDIS_STATUS_FAILURE;
+	unsigned long IrqFlags;
+	HT_TX_CONTEXT *pHTTXContext;
 
 	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-	if ((pHTTXContext->CurWritePosition < pHTTXContext->NextBulkOutPosition) && ((pHTTXContext->CurWritePosition + NumberRequired + LOCAL_TXBUF_SIZE) > pHTTXContext->NextBulkOutPosition))
-	{
-
-		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
-	}
-	else if ((pHTTXContext->CurWritePosition == 8) && (pHTTXContext->NextBulkOutPosition < (NumberRequired + LOCAL_TXBUF_SIZE)))
-	{
-		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
-	}
-	else if (pHTTXContext->bCurWriting == TRUE)
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("RTUSBFreeD c3 --> QueIdx=%d, CWPos=%ld, NBOutPos=%ld!\n", BulkOutPipeId, pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition));
-		RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << BulkOutPipeId));
-	}
-	else
-	{
+	if ((pHTTXContext->CurWritePosition < pHTTXContext->NextBulkOutPosition)
+	    &&
+	    ((pHTTXContext->CurWritePosition + NumberRequired +
+	      LOCAL_TXBUF_SIZE) > pHTTXContext->NextBulkOutPosition)) {
+
+		RTUSB_SET_BULK_FLAG(pAd,
+				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
+				     BulkOutPipeId));
+	} else if ((pHTTXContext->CurWritePosition == 8)
+		   && (pHTTXContext->NextBulkOutPosition <
+		       (NumberRequired + LOCAL_TXBUF_SIZE))) {
+		RTUSB_SET_BULK_FLAG(pAd,
+				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
+				     BulkOutPipeId));
+	} else if (pHTTXContext->bCurWriting == TRUE) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTUSBFreeD c3 --> QueIdx=%d, CWPos=%ld, NBOutPos=%ld!\n",
+			  BulkOutPipeId, pHTTXContext->CurWritePosition,
+			  pHTTXContext->NextBulkOutPosition));
+		RTUSB_SET_BULK_FLAG(pAd,
+				    (fRTUSB_BULK_OUT_DATA_NORMAL <<
+				     BulkOutPipeId));
+	} else {
 		Status = NDIS_STATUS_SUCCESS;
 	}
 	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
 
-
 	return (Status);
 }
 
-NDIS_STATUS RTUSBFreeDescriptorRelease(
-	IN RTMP_ADAPTER *pAd,
-	IN UCHAR		BulkOutPipeId)
+NDIS_STATUS RTUSBFreeDescriptorRelease(IN RTMP_ADAPTER * pAd,
+				       IN UCHAR BulkOutPipeId)
 {
-	unsigned long   IrqFlags;
-	HT_TX_CONTEXT	*pHTTXContext;
+	unsigned long IrqFlags;
+	HT_TX_CONTEXT *pHTTXContext;
 
 	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
@@ -145,28 +141,32 @@ NDIS_STATUS RTUSBFreeDescriptorRelease(
 	return (NDIS_STATUS_SUCCESS);
 }
 
-
-BOOLEAN	RTUSBNeedQueueBackForAgg(
-	IN RTMP_ADAPTER *pAd,
-	IN UCHAR		BulkOutPipeId)
-{
-	unsigned long   IrqFlags;
-	HT_TX_CONTEXT	*pHTTXContext;
-	BOOLEAN			needQueBack = FALSE;
+BOOLEAN RTUSBNeedQueueBackForAgg(IN RTMP_ADAPTER * pAd, IN UCHAR BulkOutPipeId)
+{
+	unsigned long IrqFlags;
+	HT_TX_CONTEXT *pHTTXContext;
+	BOOLEAN needQueBack = FALSE;
 
 	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
 
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
-	if ((pHTTXContext->IRPPending == TRUE)  /*&& (pAd->TxSwQueue[BulkOutPipeId].Number == 0) */)
-	{
-		if ((pHTTXContext->CurWritePosition < pHTTXContext->ENextBulkOutPosition) &&
-			(((pHTTXContext->ENextBulkOutPosition+MAX_AGGREGATION_SIZE) < MAX_TXBULK_LIMIT) || (pHTTXContext->CurWritePosition > MAX_AGGREGATION_SIZE)))
-		{
+	if ((pHTTXContext->IRPPending ==
+	     TRUE) /*&& (pAd->TxSwQueue[BulkOutPipeId].Number == 0) */ ) {
+		if ((pHTTXContext->CurWritePosition <
+		     pHTTXContext->ENextBulkOutPosition)
+		    &&
+		    (((pHTTXContext->ENextBulkOutPosition +
+		       MAX_AGGREGATION_SIZE) < MAX_TXBULK_LIMIT)
+		     || (pHTTXContext->CurWritePosition >
+			 MAX_AGGREGATION_SIZE))) {
 			needQueBack = TRUE;
-		}
-		else if ((pHTTXContext->CurWritePosition > pHTTXContext->ENextBulkOutPosition) &&
-				 ((pHTTXContext->ENextBulkOutPosition + MAX_AGGREGATION_SIZE) < pHTTXContext->CurWritePosition))
-		{
+		} else
+		    if ((pHTTXContext->CurWritePosition >
+			 pHTTXContext->ENextBulkOutPosition)
+			&&
+			((pHTTXContext->ENextBulkOutPosition +
+			  MAX_AGGREGATION_SIZE) <
+			 pHTTXContext->CurWritePosition)) {
 			needQueBack = TRUE;
 		}
 	}
@@ -176,7 +176,6 @@ BOOLEAN	RTUSBNeedQueueBackForAgg(
 
 }
 
-
 /*
 	========================================================================
 
@@ -192,21 +191,17 @@ BOOLEAN	RTUSBNeedQueueBackForAgg(
 
 	========================================================================
 */
-VOID	RTUSBRejectPendingPackets(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBRejectPendingPackets(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR			Index;
-	PQUEUE_ENTRY	pEntry;
-	PNDIS_PACKET	pPacket;
-	PQUEUE_HEADER	pQueue;
-
+	UCHAR Index;
+	PQUEUE_ENTRY pEntry;
+	PNDIS_PACKET pPacket;
+	PQUEUE_HEADER pQueue;
 
-	for (Index = 0; Index < 4; Index++)
-	{
+	for (Index = 0; Index < 4; Index++) {
 		NdisAcquireSpinLock(&pAd->TxSwQueueLock[Index]);
-		while (pAd->TxSwQueue[Index].Head != NULL)
-		{
-			pQueue = (PQUEUE_HEADER) &(pAd->TxSwQueue[Index]);
+		while (pAd->TxSwQueue[Index].Head != NULL) {
+			pQueue = (PQUEUE_HEADER) & (pAd->TxSwQueue[Index]);
 			pEntry = RemoveHeadQueue(pQueue);
 			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
 			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
@@ -217,7 +212,6 @@ VOID	RTUSBRejectPendingPackets(
 
 }
 
-
 /*
 	========================================================================
 
@@ -246,21 +240,18 @@ VOID	RTUSBRejectPendingPackets(
 	========================================================================
 */
 
-
-VOID RTMPWriteTxInfo(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PTXINFO_STRUC 	pTxInfo,
-	IN	  USHORT		USBDMApktLen,
-	IN	  BOOLEAN		bWiv,
-	IN	  UCHAR			QueueSel,
-	IN	  UCHAR			NextValid,
-	IN	  UCHAR			TxBurst)
+VOID RTMPWriteTxInfo(IN PRTMP_ADAPTER pAd,
+		     IN PTXINFO_STRUC pTxInfo,
+		     IN USHORT USBDMApktLen,
+		     IN BOOLEAN bWiv,
+		     IN UCHAR QueueSel, IN UCHAR NextValid, IN UCHAR TxBurst)
 {
 	pTxInfo->USBDMATxPktLen = USBDMApktLen;
 	pTxInfo->QSEL = QueueSel;
 	if (QueueSel != FIFO_EDCA)
-		DBGPRINT(RT_DEBUG_TRACE, ("====> QueueSel != FIFO_EDCA<============\n"));
-	pTxInfo->USBDMANextVLD = FALSE; //NextValid;  // Need to check with Jan about this.
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("====> QueueSel != FIFO_EDCA<============\n"));
+	pTxInfo->USBDMANextVLD = FALSE;	//NextValid;  // Need to check with Jan about this.
 	pTxInfo->USBDMATxburst = TxBurst;
 	pTxInfo->WIV = bWiv;
 	pTxInfo->SwUseLastRound = 0;
--- a/drivers/staging/rt2870/common/rtusb_io.c
+++ b/drivers/staging/rt2870/common/rtusb_io.c
@@ -38,10 +38,8 @@
 
 #ifdef RTMP_MAC_USB
 
-
 #include "../rt_config.h"
 
-
 /*
 	========================================================================
 
@@ -58,26 +56,18 @@
 	========================================================================
 */
 
-static NTSTATUS	RTUSBFirmwareRun(
-	IN	PRTMP_ADAPTER	pAd)
+static NTSTATUS RTUSBFirmwareRun(IN PRTMP_ADAPTER pAd)
 {
-	NTSTATUS	Status;
+	NTSTATUS Status;
 
-	Status = RTUSB_VendorRequest(
-		pAd,
-		USBD_TRANSFER_DIRECTION_OUT,
-		DEVICE_VENDOR_REQUEST_OUT,
-		0x01,
-		0x8,
-		0,
-		NULL,
-		0);
+	Status = RTUSB_VendorRequest(pAd,
+				     USBD_TRANSFER_DIRECTION_OUT,
+				     DEVICE_VENDOR_REQUEST_OUT,
+				     0x01, 0x8, 0, NULL, 0);
 
 	return Status;
 }
 
-
-
 /*
 	========================================================================
 
@@ -93,19 +83,16 @@ static NTSTATUS	RTUSBFirmwareRun(
 
 	========================================================================
 */
-NTSTATUS RTUSBFirmwareWrite(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR		pFwImage,
-	IN ULONG		FwLen)
-{
-	UINT32		MacReg;
-	NTSTATUS 	Status;
-//	ULONG 		i;
-	USHORT		writeLen;
+NTSTATUS RTUSBFirmwareWrite(IN PRTMP_ADAPTER pAd,
+			    IN PUCHAR pFwImage, IN ULONG FwLen)
+{
+	UINT32 MacReg;
+	NTSTATUS Status;
+//      ULONG           i;
+	USHORT writeLen;
 
 	Status = RTUSBReadMACRegister(pAd, MAC_CSR0, &MacReg);
 
-
 	writeLen = FwLen;
 	RTUSBMultiWrite(pAd, FIRMWARE_IMAGE_BASE, pFwImage, writeLen);
 
@@ -115,32 +102,26 @@ NTSTATUS RTUSBFirmwareWrite(
 
 	//2008/11/28:KH add to fix the dead rf frequency offset bug<--
 	RTMPusecDelay(10000);
-	RTUSBWriteMACRegister(pAd,H2M_MAILBOX_CSR,0);
-	AsicSendCommandToMcu(pAd, 0x72, 0x00, 0x00, 0x00); //reset rf by MCU supported by new firmware
+	RTUSBWriteMACRegister(pAd, H2M_MAILBOX_CSR, 0);
+	AsicSendCommandToMcu(pAd, 0x72, 0x00, 0x00, 0x00);	//reset rf by MCU supported by new firmware
 	//2008/11/28:KH add to fix the dead rf frequency offset bug-->
 
 	return Status;
 }
 
-
-NTSTATUS	RTUSBVenderReset(
-	IN	PRTMP_ADAPTER	pAd)
+NTSTATUS RTUSBVenderReset(IN PRTMP_ADAPTER pAd)
 {
-	NTSTATUS	Status;
+	NTSTATUS Status;
 	DBGPRINT_RAW(RT_DEBUG_ERROR, ("-->RTUSBVenderReset\n"));
-	Status = RTUSB_VendorRequest(
-		pAd,
-		USBD_TRANSFER_DIRECTION_OUT,
-		DEVICE_VENDOR_REQUEST_OUT,
-		0x01,
-		0x1,
-		0,
-		NULL,
-		0);
+	Status = RTUSB_VendorRequest(pAd,
+				     USBD_TRANSFER_DIRECTION_OUT,
+				     DEVICE_VENDOR_REQUEST_OUT,
+				     0x01, 0x1, 0, NULL, 0);
 
 	DBGPRINT_RAW(RT_DEBUG_ERROR, ("<--RTUSBVenderReset\n"));
 	return Status;
 }
+
 /*
 	========================================================================
 
@@ -156,23 +137,16 @@ NTSTATUS	RTUSBVenderReset(
 
 	========================================================================
 */
-NTSTATUS	RTUSBMultiRead(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	OUT	PUCHAR			pData,
-	IN	USHORT			length)
-{
-	NTSTATUS	Status;
-
-	Status = RTUSB_VendorRequest(
-		pAd,
-		(USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK),
-		DEVICE_VENDOR_REQUEST_IN,
-		0x7,
-		0,
-		Offset,
-		pData,
-		length);
+NTSTATUS RTUSBMultiRead(IN PRTMP_ADAPTER pAd,
+			IN USHORT Offset, OUT PUCHAR pData, IN USHORT length)
+{
+	NTSTATUS Status;
+
+	Status = RTUSB_VendorRequest(pAd,
+				     (USBD_TRANSFER_DIRECTION_IN |
+				      USBD_SHORT_TRANSFER_OK),
+				     DEVICE_VENDOR_REQUEST_IN, 0x7, 0, Offset,
+				     pData, length);
 
 	return Status;
 }
@@ -192,77 +166,56 @@ NTSTATUS	RTUSBMultiRead(
 
 	========================================================================
 */
-NTSTATUS	RTUSBMultiWrite_OneByte(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	IN	PUCHAR			pData)
+NTSTATUS RTUSBMultiWrite_OneByte(IN PRTMP_ADAPTER pAd,
+				 IN USHORT Offset, IN PUCHAR pData)
 {
-	NTSTATUS	Status;
+	NTSTATUS Status;
 
 	// TODO: In 2870, use this funciton carefully cause it's not stable.
-	Status = RTUSB_VendorRequest(
-		pAd,
-		USBD_TRANSFER_DIRECTION_OUT,
-		DEVICE_VENDOR_REQUEST_OUT,
-		0x6,
-		0,
-		Offset,
-		pData,
-		1);
+	Status = RTUSB_VendorRequest(pAd,
+				     USBD_TRANSFER_DIRECTION_OUT,
+				     DEVICE_VENDOR_REQUEST_OUT,
+				     0x6, 0, Offset, pData, 1);
 
 	return Status;
 }
 
-NTSTATUS	RTUSBMultiWrite(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	IN	PUCHAR			pData,
-	IN	USHORT			length)
-{
-	NTSTATUS	Status;
-
-
-        USHORT          index = 0,Value;
-        PUCHAR          pSrc = pData;
-        USHORT          resude = 0;
-
-        resude = length % 2;
-		length  += resude;
-		do
-		{
-			Value =(USHORT)( *pSrc  | (*(pSrc + 1) << 8));
-		Status = RTUSBSingleWrite(pAd,Offset + index,Value);
-            index +=2;
-            length -= 2;
-            pSrc = pSrc + 2;
-        }while(length > 0);
+NTSTATUS RTUSBMultiWrite(IN PRTMP_ADAPTER pAd,
+			 IN USHORT Offset, IN PUCHAR pData, IN USHORT length)
+{
+	NTSTATUS Status;
+
+	USHORT index = 0, Value;
+	PUCHAR pSrc = pData;
+	USHORT resude = 0;
+
+	resude = length % 2;
+	length += resude;
+	do {
+		Value = (USHORT) (*pSrc | (*(pSrc + 1) << 8));
+		Status = RTUSBSingleWrite(pAd, Offset + index, Value);
+		index += 2;
+		length -= 2;
+		pSrc = pSrc + 2;
+	} while (length > 0);
 
 	return Status;
 }
 
+NTSTATUS RTUSBSingleWrite(IN RTMP_ADAPTER * pAd,
+			  IN USHORT Offset, IN USHORT Value)
+{
+	NTSTATUS Status;
 
-NTSTATUS RTUSBSingleWrite(
-	IN 	RTMP_ADAPTER 	*pAd,
-	IN	USHORT			Offset,
-	IN	USHORT			Value)
-{
-	NTSTATUS	Status;
-
-	Status = RTUSB_VendorRequest(
-		pAd,
-		USBD_TRANSFER_DIRECTION_OUT,
-		DEVICE_VENDOR_REQUEST_OUT,
-		0x2,
-		Value,
-		Offset,
-		NULL,
-		0);
+	Status = RTUSB_VendorRequest(pAd,
+				     USBD_TRANSFER_DIRECTION_OUT,
+				     DEVICE_VENDOR_REQUEST_OUT,
+				     0x2, Value, Offset, NULL, 0);
 
 	return Status;
 
 }
 
-
 /*
 	========================================================================
 
@@ -278,26 +231,19 @@ NTSTATUS RTUSBSingleWrite(
 
 	========================================================================
 */
-NTSTATUS	RTUSBReadMACRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	OUT	PUINT32			pValue)
-{
-	NTSTATUS	Status = 0;
-	UINT32		localVal;
-
-	Status = RTUSB_VendorRequest(
-		pAd,
-		(USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK),
-		DEVICE_VENDOR_REQUEST_IN,
-		0x7,
-		0,
-		Offset,
-		&localVal,
-		4);
+NTSTATUS RTUSBReadMACRegister(IN PRTMP_ADAPTER pAd,
+			      IN USHORT Offset, OUT PUINT32 pValue)
+{
+	NTSTATUS Status = 0;
+	UINT32 localVal;
 
-	*pValue = le2cpu32(localVal);
+	Status = RTUSB_VendorRequest(pAd,
+				     (USBD_TRANSFER_DIRECTION_IN |
+				      USBD_SHORT_TRANSFER_OK),
+				     DEVICE_VENDOR_REQUEST_IN, 0x7, 0, Offset,
+				     &localVal, 4);
 
+	*pValue = le2cpu32(localVal);
 
 	if (Status < 0)
 		*pValue = 0xffffffff;
@@ -305,7 +251,6 @@ NTSTATUS	RTUSBReadMACRegister(
 	return Status;
 }
 
-
 /*
 	========================================================================
 
@@ -321,24 +266,22 @@ NTSTATUS	RTUSBReadMACRegister(
 
 	========================================================================
 */
-NTSTATUS	RTUSBWriteMACRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	IN	UINT32			Value)
+NTSTATUS RTUSBWriteMACRegister(IN PRTMP_ADAPTER pAd,
+			       IN USHORT Offset, IN UINT32 Value)
 {
-	NTSTATUS	Status;
-	UINT32		localVal;
+	NTSTATUS Status;
+	UINT32 localVal;
 
 	localVal = Value;
 
-	Status = RTUSBSingleWrite(pAd, Offset, (USHORT)(localVal & 0xffff));
-	Status = RTUSBSingleWrite(pAd, Offset + 2, (USHORT)((localVal & 0xffff0000) >> 16));
+	Status = RTUSBSingleWrite(pAd, Offset, (USHORT) (localVal & 0xffff));
+	Status =
+	    RTUSBSingleWrite(pAd, Offset + 2,
+			     (USHORT) ((localVal & 0xffff0000) >> 16));
 
 	return Status;
 }
 
-
-
 /*
 	========================================================================
 
@@ -354,78 +297,77 @@ NTSTATUS	RTUSBWriteMACRegister(
 
 	========================================================================
 */
-NTSTATUS	RTUSBReadBBPRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Id,
-	IN	PUCHAR			pValue)
-{
-	BBP_CSR_CFG_STRUC	BbpCsr;
-	UINT			i = 0;
-	NTSTATUS		status;
+NTSTATUS RTUSBReadBBPRegister(IN PRTMP_ADAPTER pAd,
+			      IN UCHAR Id, IN PUCHAR pValue)
+{
+	BBP_CSR_CFG_STRUC BbpCsr;
+	UINT i = 0;
+	NTSTATUS status;
 
 	// Verify the busy condition
-	do
-	{
+	do {
 		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
-		if(status >= 0)
-		{
-		if (!(BbpCsr.field.Busy == BUSY))
-			break;
+		if (status >= 0) {
+			if (!(BbpCsr.field.Busy == BUSY))
+				break;
 		}
-		DBGPRINT(RT_DEBUG_TRACE, ("RTUSBReadBBPRegister(BBP_CSR_CFG_1):retry count=%d!\n", i));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTUSBReadBBPRegister(BBP_CSR_CFG_1):retry count=%d!\n",
+			  i));
 		i++;
-	}while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+	} while ((i < RETRY_LIMIT)
+		 && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
 
-	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-	{
+	if ((i == RETRY_LIMIT)
+	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
 		//
 		// Read failed then Return Default value.
 		//
 		*pValue = pAd->BbpWriteLatch[Id];
 
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Retry count exhausted or device removed!!!\n"));
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     ("Retry count exhausted or device removed!!!\n"));
 		return STATUS_UNSUCCESSFUL;
 	}
-
 	// Prepare for write material
-	BbpCsr.word 				= 0;
-	BbpCsr.field.fRead			= 1;
-	BbpCsr.field.Busy			= 1;
-	BbpCsr.field.RegNum 		= Id;
+	BbpCsr.word = 0;
+	BbpCsr.field.fRead = 1;
+	BbpCsr.field.Busy = 1;
+	BbpCsr.field.RegNum = Id;
 	RTUSBWriteMACRegister(pAd, BBP_CSR_CFG, BbpCsr.word);
 
 	i = 0;
 	// Verify the busy condition
-	do
-	{
+	do {
 		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
-		if (status >= 0)
-		{
-		if (!(BbpCsr.field.Busy == BUSY))
-		{
-			*pValue = (UCHAR)BbpCsr.field.Value;
-			break;
-		}
+		if (status >= 0) {
+			if (!(BbpCsr.field.Busy == BUSY)) {
+				*pValue = (UCHAR) BbpCsr.field.Value;
+				break;
+			}
 		}
-		DBGPRINT(RT_DEBUG_TRACE, ("RTUSBReadBBPRegister(BBP_CSR_CFG_2):retry count=%d!\n", i));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTUSBReadBBPRegister(BBP_CSR_CFG_2):retry count=%d!\n",
+			  i));
 		i++;
-	}while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+	} while ((i < RETRY_LIMIT)
+		 && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
 
-	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-	{
+	if ((i == RETRY_LIMIT)
+	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
 		//
 		// Read failed then Return Default value.
 		//
 		*pValue = pAd->BbpWriteLatch[Id];
 
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Retry count exhausted or device removed!!!\n"));
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     ("Retry count exhausted or device removed!!!\n"));
 		return STATUS_UNSUCCESSFUL;
 	}
 
 	return STATUS_SUCCESS;
 }
 
-
 /*
 	========================================================================
 
@@ -441,46 +383,46 @@ NTSTATUS	RTUSBReadBBPRegister(
 
 	========================================================================
 */
-NTSTATUS	RTUSBWriteBBPRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			Id,
-	IN	UCHAR			Value)
-{
-	BBP_CSR_CFG_STRUC	BbpCsr;
-	UINT			i = 0;
-	NTSTATUS		status;
+NTSTATUS RTUSBWriteBBPRegister(IN PRTMP_ADAPTER pAd,
+			       IN UCHAR Id, IN UCHAR Value)
+{
+	BBP_CSR_CFG_STRUC BbpCsr;
+	UINT i = 0;
+	NTSTATUS status;
 	// Verify the busy condition
-	do
-	{
+	do {
 		status = RTUSBReadMACRegister(pAd, BBP_CSR_CFG, &BbpCsr.word);
-		if (status >= 0)
-		{
-		if (!(BbpCsr.field.Busy == BUSY))
-			break;
+		if (status >= 0) {
+			if (!(BbpCsr.field.Busy == BUSY))
+				break;
 		}
-		DBGPRINT(RT_DEBUG_TRACE, ("RTUSBWriteBBPRegister(BBP_CSR_CFG):retry count=%d!\n", i));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTUSBWriteBBPRegister(BBP_CSR_CFG):retry count=%d!\n",
+			  i));
 		i++;
 	}
-	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+	while ((i < RETRY_LIMIT)
+	       && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
 
-	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Retry count exhausted or device removed!!!\n"));
+	if ((i == RETRY_LIMIT)
+	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     ("Retry count exhausted or device removed!!!\n"));
 		return STATUS_UNSUCCESSFUL;
 	}
-
 	// Prepare for write material
-	BbpCsr.word 				= 0;
-	BbpCsr.field.fRead			= 0;
-	BbpCsr.field.Value			= Value;
-	BbpCsr.field.Busy			= 1;
-	BbpCsr.field.RegNum 		= Id;
+	BbpCsr.word = 0;
+	BbpCsr.field.fRead = 0;
+	BbpCsr.field.Value = Value;
+	BbpCsr.field.Busy = 1;
+	BbpCsr.field.RegNum = Id;
 	RTUSBWriteMACRegister(pAd, BBP_CSR_CFG, BbpCsr.word);
 
 	pAd->BbpWriteLatch[Id] = Value;
 
 	return STATUS_SUCCESS;
 }
+
 /*
 	========================================================================
 
@@ -496,31 +438,31 @@ NTSTATUS	RTUSBWriteBBPRegister(
 
 	========================================================================
 */
-NTSTATUS	RTUSBWriteRFRegister(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UINT32			Value)
-{
-	PHY_CSR4_STRUC	PhyCsr4;
-	UINT			i = 0;
-	NTSTATUS		status;
+NTSTATUS RTUSBWriteRFRegister(IN PRTMP_ADAPTER pAd, IN UINT32 Value)
+{
+	PHY_CSR4_STRUC PhyCsr4;
+	UINT i = 0;
+	NTSTATUS status;
 
 	NdisZeroMemory(&PhyCsr4, sizeof(PHY_CSR4_STRUC));
-	do
-	{
+	do {
 		status = RTUSBReadMACRegister(pAd, RF_CSR_CFG0, &PhyCsr4.word);
-		if (status >= 0)
-		{
-		if (!(PhyCsr4.field.Busy))
-			break;
+		if (status >= 0) {
+			if (!(PhyCsr4.field.Busy))
+				break;
 		}
-		DBGPRINT(RT_DEBUG_TRACE, ("RTUSBWriteRFRegister(RF_CSR_CFG0):retry count=%d!\n", i));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("RTUSBWriteRFRegister(RF_CSR_CFG0):retry count=%d!\n",
+			  i));
 		i++;
 	}
-	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
+	while ((i < RETRY_LIMIT)
+	       && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)));
 
-	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Retry count exhausted or device removed!!!\n"));
+	if ((i == RETRY_LIMIT)
+	    || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) {
+		DBGPRINT_RAW(RT_DEBUG_ERROR,
+			     ("Retry count exhausted or device removed!!!\n"));
 		return STATUS_UNSUCCESSFUL;
 	}
 
@@ -529,7 +471,6 @@ NTSTATUS	RTUSBWriteRFRegister(
 	return STATUS_SUCCESS;
 }
 
-
 /*
 	========================================================================
 
@@ -545,23 +486,16 @@ NTSTATUS	RTUSBWriteRFRegister(
 
 	========================================================================
 */
-NTSTATUS	RTUSBReadEEPROM(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	OUT	PUCHAR			pData,
-	IN	USHORT			length)
-{
-	NTSTATUS	Status = STATUS_SUCCESS;
-
-	Status = RTUSB_VendorRequest(
-		pAd,
-		(USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK),
-		DEVICE_VENDOR_REQUEST_IN,
-		0x9,
-		0,
-		Offset,
-		pData,
-		length);
+NTSTATUS RTUSBReadEEPROM(IN PRTMP_ADAPTER pAd,
+			 IN USHORT Offset, OUT PUCHAR pData, IN USHORT length)
+{
+	NTSTATUS Status = STATUS_SUCCESS;
+
+	Status = RTUSB_VendorRequest(pAd,
+				     (USBD_TRANSFER_DIRECTION_IN |
+				      USBD_SHORT_TRANSFER_OK),
+				     DEVICE_VENDOR_REQUEST_IN, 0x9, 0, Offset,
+				     pData, length);
 
 	return Status;
 }
@@ -581,37 +515,26 @@ NTSTATUS	RTUSBReadEEPROM(
 
 	========================================================================
 */
-NTSTATUS	RTUSBWriteEEPROM(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			Offset,
-	IN	PUCHAR			pData,
-	IN	USHORT			length)
-{
-	NTSTATUS	Status = STATUS_SUCCESS;
-
-	Status = RTUSB_VendorRequest(
-		pAd,
-		USBD_TRANSFER_DIRECTION_OUT,
-		DEVICE_VENDOR_REQUEST_OUT,
-		0x8,
-		0,
-		Offset,
-		pData,
-		length);
+NTSTATUS RTUSBWriteEEPROM(IN PRTMP_ADAPTER pAd,
+			  IN USHORT Offset, IN PUCHAR pData, IN USHORT length)
+{
+	NTSTATUS Status = STATUS_SUCCESS;
+
+	Status = RTUSB_VendorRequest(pAd,
+				     USBD_TRANSFER_DIRECTION_OUT,
+				     DEVICE_VENDOR_REQUEST_OUT,
+				     0x8, 0, Offset, pData, length);
 
 	return Status;
 }
 
-
-NTSTATUS RTUSBReadEEPROM16(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	USHORT			offset,
-	OUT	PUSHORT			pData)
+NTSTATUS RTUSBReadEEPROM16(IN PRTMP_ADAPTER pAd,
+			   IN USHORT offset, OUT PUSHORT pData)
 {
 	NTSTATUS status;
-	USHORT  localData;
+	USHORT localData;
 
-	status = RTUSBReadEEPROM(pAd, offset, (PUCHAR)(&localData), 2);
+	status = RTUSBReadEEPROM(pAd, offset, (PUCHAR) (&localData), 2);
 	if (status == STATUS_SUCCESS)
 		*pData = le2cpu16(localData);
 
@@ -634,13 +557,12 @@ NTSTATUS RTUSBReadEEPROM16(
 
 	========================================================================
 */
-VOID RTUSBPutToSleep(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTUSBPutToSleep(IN PRTMP_ADAPTER pAd)
 {
-	UINT32		value;
+	UINT32 value;
 
 	// Timeout 0x40 x 50us
-	value = (SLEEPCID<<16)+(OWNERMCU<<24)+ (0x40<<8)+1;
+	value = (SLEEPCID << 16) + (OWNERMCU << 24) + (0x40 << 8) + 1;
 	RTUSBWriteMACRegister(pAd, 0x7010, value);
 	RTUSBWriteMACRegister(pAd, 0x404, 0x30);
 	//RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS);
@@ -663,20 +585,14 @@ VOID RTUSBPutToSleep(
 
 	========================================================================
 */
-NTSTATUS RTUSBWakeUp(
-	IN	PRTMP_ADAPTER	pAd)
+NTSTATUS RTUSBWakeUp(IN PRTMP_ADAPTER pAd)
 {
-	NTSTATUS	Status;
+	NTSTATUS Status;
 
-	Status = RTUSB_VendorRequest(
-		pAd,
-		USBD_TRANSFER_DIRECTION_OUT,
-		DEVICE_VENDOR_REQUEST_OUT,
-		0x01,
-		0x09,
-		0,
-		NULL,
-		0);
+	Status = RTUSB_VendorRequest(pAd,
+				     USBD_TRANSFER_DIRECTION_OUT,
+				     DEVICE_VENDOR_REQUEST_OUT,
+				     0x01, 0x09, 0, NULL, 0);
 
 	return Status;
 }
@@ -696,8 +612,7 @@ NTSTATUS RTUSBWakeUp(
 
 	========================================================================
 */
-VOID	RTUSBInitializeCmdQ(
-	IN	PCmdQ	cmdq)
+VOID RTUSBInitializeCmdQ(IN PCmdQ cmdq)
 {
 	cmdq->head = NULL;
 	cmdq->tail = NULL;
@@ -720,48 +635,45 @@ VOID	RTUSBInitializeCmdQ(
 
 	========================================================================
 */
-NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	NDIS_OID		Oid,
-	IN	BOOLEAN			SetInformation,
-	IN	PVOID			pInformationBuffer,
-	IN	UINT32			InformationBufferLength)
-{
-	NDIS_STATUS	status;
-	PCmdQElmt	cmdqelmt = NULL;
-	RTMP_OS_TASK	*pTask = &pAd->cmdQTask;
+NDIS_STATUS RTUSBEnqueueCmdFromNdis(IN PRTMP_ADAPTER pAd,
+				    IN NDIS_OID Oid,
+				    IN BOOLEAN SetInformation,
+				    IN PVOID pInformationBuffer,
+				    IN UINT32 InformationBufferLength)
+{
+	NDIS_STATUS status;
+	PCmdQElmt cmdqelmt = NULL;
+	RTMP_OS_TASK *pTask = &pAd->cmdQTask;
 
 #ifdef KTHREAD_SUPPORT
 	if (pTask->kthread_task == NULL)
 #else
-	CHECK_PID_LEGALITY(pTask->taskPID)
-	{
+	CHECK_PID_LEGALITY(pTask->taskPID) {
 	}
 	else
 #endif
-		return (NDIS_STATUS_RESOURCES);
+	return (NDIS_STATUS_RESOURCES);
 
-	status = os_alloc_mem(pAd, (PUCHAR *)(&cmdqelmt), sizeof(CmdQElmt));
+	status = os_alloc_mem(pAd, (PUCHAR *) (&cmdqelmt), sizeof(CmdQElmt));
 	if ((status != NDIS_STATUS_SUCCESS) || (cmdqelmt == NULL))
 		return (NDIS_STATUS_RESOURCES);
 
-		cmdqelmt->buffer = NULL;
-		if (pInformationBuffer != NULL)
-		{
-			status = os_alloc_mem(pAd, (PUCHAR *)&cmdqelmt->buffer, InformationBufferLength);
-			if ((status != NDIS_STATUS_SUCCESS) || (cmdqelmt->buffer == NULL))
-			{
-				kfree(cmdqelmt);
-				return (NDIS_STATUS_RESOURCES);
-			}
-			else
-			{
-				NdisMoveMemory(cmdqelmt->buffer, pInformationBuffer, InformationBufferLength);
-				cmdqelmt->bufferlength = InformationBufferLength;
-			}
+	cmdqelmt->buffer = NULL;
+	if (pInformationBuffer != NULL) {
+		status =
+		    os_alloc_mem(pAd, (PUCHAR *) & cmdqelmt->buffer,
+				 InformationBufferLength);
+		if ((status != NDIS_STATUS_SUCCESS)
+		    || (cmdqelmt->buffer == NULL)) {
+			kfree(cmdqelmt);
+			return (NDIS_STATUS_RESOURCES);
+		} else {
+			NdisMoveMemory(cmdqelmt->buffer, pInformationBuffer,
+				       InformationBufferLength);
+			cmdqelmt->bufferlength = InformationBufferLength;
 		}
-		else
-			cmdqelmt->bufferlength = 0;
+	} else
+		cmdqelmt->bufferlength = 0;
 
 	cmdqelmt->command = Oid;
 	cmdqelmt->CmdFromNdis = TRUE;
@@ -771,28 +683,22 @@ NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
 		cmdqelmt->SetOperation = FALSE;
 
 	NdisAcquireSpinLock(&pAd->CmdQLock);
-	if (pAd->CmdQ.CmdQState & RTMP_TASK_CAN_DO_INSERT)
-	{
+	if (pAd->CmdQ.CmdQState & RTMP_TASK_CAN_DO_INSERT) {
 		EnqueueCmd((&pAd->CmdQ), cmdqelmt);
 		status = NDIS_STATUS_SUCCESS;
-	}
-	else
-	{
+	} else {
 		status = NDIS_STATUS_FAILURE;
 	}
 	NdisReleaseSpinLock(&pAd->CmdQLock);
 
-	if (status == NDIS_STATUS_FAILURE)
-	{
+	if (status == NDIS_STATUS_FAILURE) {
 		if (cmdqelmt->buffer)
 			os_free_mem(pAd, cmdqelmt->buffer);
 		os_free_mem(pAd, cmdqelmt);
-	}
-	else
-	RTUSBCMDUp(pAd);
-
+	} else
+		RTUSBCMDUp(pAd);
 
-    return(NDIS_STATUS_SUCCESS);
+	return (NDIS_STATUS_SUCCESS);
 }
 
 /*
@@ -810,37 +716,33 @@ NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
 
 	========================================================================
 */
-NDIS_STATUS RTUSBEnqueueInternalCmd(
-	IN PRTMP_ADAPTER	pAd,
-	IN NDIS_OID			Oid,
-	IN PVOID			pInformationBuffer,
-	IN UINT32			InformationBufferLength)
+NDIS_STATUS RTUSBEnqueueInternalCmd(IN PRTMP_ADAPTER pAd,
+				    IN NDIS_OID Oid,
+				    IN PVOID pInformationBuffer,
+				    IN UINT32 InformationBufferLength)
 {
-	NDIS_STATUS	status;
-	PCmdQElmt	cmdqelmt = NULL;
+	NDIS_STATUS status;
+	PCmdQElmt cmdqelmt = NULL;
 
-
-	status = os_alloc_mem(pAd, (PUCHAR *)&cmdqelmt, sizeof(CmdQElmt));
+	status = os_alloc_mem(pAd, (PUCHAR *) & cmdqelmt, sizeof(CmdQElmt));
 	if ((status != NDIS_STATUS_SUCCESS) || (cmdqelmt == NULL))
 		return (NDIS_STATUS_RESOURCES);
 	NdisZeroMemory(cmdqelmt, sizeof(CmdQElmt));
 
-	if(InformationBufferLength > 0)
-	{
-		status = os_alloc_mem(pAd, (PUCHAR *)&cmdqelmt->buffer, InformationBufferLength);
-		if ((status != NDIS_STATUS_SUCCESS) || (cmdqelmt->buffer == NULL))
-		{
+	if (InformationBufferLength > 0) {
+		status =
+		    os_alloc_mem(pAd, (PUCHAR *) & cmdqelmt->buffer,
+				 InformationBufferLength);
+		if ((status != NDIS_STATUS_SUCCESS)
+		    || (cmdqelmt->buffer == NULL)) {
 			os_free_mem(pAd, cmdqelmt);
 			return (NDIS_STATUS_RESOURCES);
-		}
-		else
-		{
-			NdisMoveMemory(cmdqelmt->buffer, pInformationBuffer, InformationBufferLength);
+		} else {
+			NdisMoveMemory(cmdqelmt->buffer, pInformationBuffer,
+				       InformationBufferLength);
 			cmdqelmt->bufferlength = InformationBufferLength;
 		}
-	}
-	else
-	{
+	} else {
 		cmdqelmt->buffer = NULL;
 		cmdqelmt->bufferlength = 0;
 	}
@@ -848,30 +750,24 @@ NDIS_STATUS RTUSBEnqueueInternalCmd(
 	cmdqelmt->command = Oid;
 	cmdqelmt->CmdFromNdis = FALSE;
 
-	if (cmdqelmt != NULL)
-	{
+	if (cmdqelmt != NULL) {
 		NdisAcquireSpinLock(&pAd->CmdQLock);
-		if (pAd->CmdQ.CmdQState & RTMP_TASK_CAN_DO_INSERT)
-		{
+		if (pAd->CmdQ.CmdQState & RTMP_TASK_CAN_DO_INSERT) {
 			EnqueueCmd((&pAd->CmdQ), cmdqelmt);
 			status = NDIS_STATUS_SUCCESS;
-		}
-		else
-		{
+		} else {
 			status = NDIS_STATUS_FAILURE;
 		}
 		NdisReleaseSpinLock(&pAd->CmdQLock);
 
-		if (status == NDIS_STATUS_FAILURE)
-		{
+		if (status == NDIS_STATUS_FAILURE) {
 			if (cmdqelmt->buffer)
 				os_free_mem(pAd, cmdqelmt->buffer);
 			os_free_mem(pAd, cmdqelmt);
-		}
-		else
-		RTUSBCMDUp(pAd);
+		} else
+			RTUSBCMDUp(pAd);
 	}
-	return(NDIS_STATUS_SUCCESS);
+	return (NDIS_STATUS_SUCCESS);
 }
 
 /*
@@ -889,14 +785,11 @@ NDIS_STATUS RTUSBEnqueueInternalCmd(
 
 	========================================================================
 */
-VOID	RTUSBDequeueCmd(
-	IN	PCmdQ		cmdq,
-	OUT	PCmdQElmt	*pcmdqelmt)
+VOID RTUSBDequeueCmd(IN PCmdQ cmdq, OUT PCmdQElmt * pcmdqelmt)
 {
 	*pcmdqelmt = cmdq->head;
 
-	if (*pcmdqelmt != NULL)
-	{
+	if (*pcmdqelmt != NULL) {
 		cmdq->head = cmdq->head->next;
 		cmdq->size--;
 		if (cmdq->size == 0)
@@ -930,7 +823,6 @@ VOID	RTUSBDequeueCmd(
 	  method can wait for it to complete.  Since you don't have a handle on
 	  the URB used, you can't cancel the request.
 
-
 	Routine Description:
 
 	Arguments:
@@ -941,81 +833,102 @@ VOID	RTUSBDequeueCmd(
 
 	========================================================================
 */
-NTSTATUS    RTUSB_VendorRequest(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UINT32			TransferFlags,
-	IN	UCHAR			RequestType,
-	IN	UCHAR			Request,
-	IN	USHORT			Value,
-	IN	USHORT			Index,
-	IN	PVOID			TransferBuffer,
-	IN	UINT32			TransferBufferLength)
+NTSTATUS RTUSB_VendorRequest(IN PRTMP_ADAPTER pAd,
+			     IN UINT32 TransferFlags,
+			     IN UCHAR RequestType,
+			     IN UCHAR Request,
+			     IN USHORT Value,
+			     IN USHORT Index,
+			     IN PVOID TransferBuffer,
+			     IN UINT32 TransferBufferLength)
 {
-	int				ret = 0;
-	POS_COOKIE		pObj = (POS_COOKIE) pAd->OS_Cookie;
+	int ret = 0;
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
-	{
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
 		DBGPRINT(RT_DEBUG_ERROR, ("device disconnected\n"));
 		return -1;
-	}
-	else if (in_interrupt())
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("in_interrupt, RTUSB_VendorRequest Request%02x Value%04x Offset%04x\n",Request,Value,Index));
+	} else if (in_interrupt()) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("in_interrupt, RTUSB_VendorRequest Request%02x Value%04x Offset%04x\n",
+			  Request, Value, Index));
 
 		return -1;
-	}
-	else
-	{
+	} else {
 #define MAX_RETRY_COUNT  10
 
 		int retryCount = 0;
-		void	*tmpBuf = TransferBuffer;
+		void *tmpBuf = TransferBuffer;
 
 		ret = down_interruptible(&(pAd->UsbVendorReq_semaphore));
-		if (pAd->UsbVendorReqBuf)
-		{
-			ASSERT(TransferBufferLength <MAX_PARAM_BUFFER_SIZE);
+		if (pAd->UsbVendorReqBuf) {
+			ASSERT(TransferBufferLength < MAX_PARAM_BUFFER_SIZE);
 
 			tmpBuf = (void *)pAd->UsbVendorReqBuf;
-			NdisZeroMemory(pAd->UsbVendorReqBuf, TransferBufferLength);
+			NdisZeroMemory(pAd->UsbVendorReqBuf,
+				       TransferBufferLength);
 
 			if (RequestType == DEVICE_VENDOR_REQUEST_OUT)
-			 NdisMoveMemory(tmpBuf, TransferBuffer, TransferBufferLength);
+				NdisMoveMemory(tmpBuf, TransferBuffer,
+					       TransferBufferLength);
 		}
 
 		do {
-		if( RequestType == DEVICE_VENDOR_REQUEST_OUT)
-			ret=usb_control_msg(pObj->pUsb_Dev, usb_sndctrlpipe( pObj->pUsb_Dev, 0 ), Request, RequestType, Value,Index, tmpBuf, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
-		else if(RequestType == DEVICE_VENDOR_REQUEST_IN)
-			ret=usb_control_msg(pObj->pUsb_Dev, usb_rcvctrlpipe( pObj->pUsb_Dev, 0 ), Request, RequestType, Value,Index, tmpBuf, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
-		else
-		{
-			DBGPRINT(RT_DEBUG_ERROR, ("vendor request direction is failed\n"));
-			ret = -1;
-		}
+			if (RequestType == DEVICE_VENDOR_REQUEST_OUT)
+				ret =
+				    usb_control_msg(pObj->pUsb_Dev,
+						    usb_sndctrlpipe(pObj->
+								    pUsb_Dev,
+								    0), Request,
+						    RequestType, Value, Index,
+						    tmpBuf,
+						    TransferBufferLength,
+						    CONTROL_TIMEOUT_JIFFIES);
+			else if (RequestType == DEVICE_VENDOR_REQUEST_IN)
+				ret =
+				    usb_control_msg(pObj->pUsb_Dev,
+						    usb_rcvctrlpipe(pObj->
+								    pUsb_Dev,
+								    0), Request,
+						    RequestType, Value, Index,
+						    tmpBuf,
+						    TransferBufferLength,
+						    CONTROL_TIMEOUT_JIFFIES);
+			else {
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("vendor request direction is failed\n"));
+				ret = -1;
+			}
 
 			retryCount++;
 			if (ret < 0) {
 				DBGPRINT(RT_DEBUG_OFF, ("#\n"));
 				RTMPusecDelay(5000);
 			}
-		} while((ret < 0) && (retryCount < MAX_RETRY_COUNT));
+		} while ((ret < 0) && (retryCount < MAX_RETRY_COUNT));
 
-		if ((pAd->UsbVendorReqBuf) && (RequestType == DEVICE_VENDOR_REQUEST_IN))
-			NdisMoveMemory(TransferBuffer, tmpBuf, TransferBufferLength);
+		if ((pAd->UsbVendorReqBuf)
+		    && (RequestType == DEVICE_VENDOR_REQUEST_IN))
+			NdisMoveMemory(TransferBuffer, tmpBuf,
+				       TransferBufferLength);
 		up(&(pAd->UsbVendorReq_semaphore));
 
-        if (ret < 0) {
-			DBGPRINT(RT_DEBUG_ERROR, ("RTUSB_VendorRequest failed(%d),TxFlags=0x%x, ReqType=%s, Req=0x%x, Index=0x%x\n",
-						ret, TransferFlags, (RequestType == DEVICE_VENDOR_REQUEST_OUT ? "OUT" : "IN"), Request, Index));
+		if (ret < 0) {
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("RTUSB_VendorRequest failed(%d),TxFlags=0x%x, ReqType=%s, Req=0x%x, Index=0x%x\n",
+				  ret, TransferFlags,
+				  (RequestType ==
+				   DEVICE_VENDOR_REQUEST_OUT ? "OUT" : "IN"),
+				  Request, Index));
 			if (Request == 0x2)
-				DBGPRINT(RT_DEBUG_ERROR, ("\tRequest Value=0x%04x!\n", Value));
-
-			if ((TransferBuffer!= NULL) && (TransferBufferLength > 0))
-				hex_dump("Failed TransferBuffer value", TransferBuffer, TransferBufferLength);
-        }
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("\tRequest Value=0x%04x!\n", Value));
 
+			if ((TransferBuffer != NULL)
+			    && (TransferBufferLength > 0))
+				hex_dump("Failed TransferBuffer value",
+					 TransferBuffer, TransferBufferLength);
+		}
 
 	}
 
@@ -1041,28 +954,25 @@ NTSTATUS    RTUSB_VendorRequest(
 
 	========================================================================
 */
-NTSTATUS	RTUSB_ResetDevice(
-	IN	PRTMP_ADAPTER	pAd)
+NTSTATUS RTUSB_ResetDevice(IN PRTMP_ADAPTER pAd)
 {
-	NTSTATUS		Status = TRUE;
+	NTSTATUS Status = TRUE;
 
 	DBGPRINT_RAW(RT_DEBUG_TRACE, ("--->USB_ResetDevice\n"));
 	//RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
 	return Status;
 }
 
-VOID CMDHandler(
-    IN PRTMP_ADAPTER pAd)
+VOID CMDHandler(IN PRTMP_ADAPTER pAd)
 {
-	PCmdQElmt		cmdqelmt;
-	PUCHAR			pData;
-	NDIS_STATUS		NdisStatus = NDIS_STATUS_SUCCESS;
-//	ULONG			Now = 0;
-	NTSTATUS		ntStatus;
-//	unsigned long	IrqFlags;
+	PCmdQElmt cmdqelmt;
+	PUCHAR pData;
+	NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
+//      ULONG                   Now = 0;
+	NTSTATUS ntStatus;
+//      unsigned long   IrqFlags;
 
-	while (pAd && pAd->CmdQ.size > 0)
-	{
+	while (pAd && pAd->CmdQ.size > 0) {
 		NdisStatus = NDIS_STATUS_SUCCESS;
 
 		NdisAcquireSpinLock(&pAd->CmdQLock);
@@ -1074,645 +984,1129 @@ VOID CMDHandler(
 
 		pData = cmdqelmt->buffer;
 
-		if(!(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
-		{
-			switch (cmdqelmt->command)
-			{
-				case CMDTHREAD_CHECK_GPIO:
-					{
-						UINT32 data;
+		if (!
+		    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)
+		     || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))) {
+			switch (cmdqelmt->command) {
+			case CMDTHREAD_CHECK_GPIO:
+				{
+					UINT32 data;
 
-						{
-							// Read GPIO pin2 as Hardware controlled radio state
-
-							RTUSBReadMACRegister( pAd, GPIO_CTRL_CFG, &data);
-
-							if (data & 0x04)
-							{
-								pAd->StaCfg.bHwRadio = TRUE;
-							}
-							else
-							{
-								pAd->StaCfg.bHwRadio = FALSE;
-							}
+					{
+						// Read GPIO pin2 as Hardware controlled radio state
 
-							if(pAd->StaCfg.bRadio != (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio))
-							{
-								pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio);
-								if(pAd->StaCfg.bRadio == TRUE)
-								{
-									DBGPRINT_RAW(RT_DEBUG_ERROR, ("!!! Radio On !!!\n"));
-
-									MlmeRadioOn(pAd);
-									// Update extra information
-									pAd->ExtraInfo = EXTRA_INFO_CLEAR;
-								}
-								else
-								{
-									DBGPRINT_RAW(RT_DEBUG_ERROR, ("!!! Radio Off !!!\n"));
+						RTUSBReadMACRegister(pAd,
+								     GPIO_CTRL_CFG,
+								     &data);
+
+						if (data & 0x04) {
+							pAd->StaCfg.bHwRadio =
+							    TRUE;
+						} else {
+							pAd->StaCfg.bHwRadio =
+							    FALSE;
+						}
 
-									MlmeRadioOff(pAd);
-									// Update extra information
-									pAd->ExtraInfo = HW_RADIO_OFF;
-								}
+						if (pAd->StaCfg.bRadio !=
+						    (pAd->StaCfg.bHwRadio
+						     && pAd->StaCfg.bSwRadio)) {
+							pAd->StaCfg.bRadio =
+							    (pAd->StaCfg.
+							     bHwRadio
+							     && pAd->StaCfg.
+							     bSwRadio);
+							if (pAd->StaCfg.
+							    bRadio == TRUE) {
+								DBGPRINT_RAW
+								    (RT_DEBUG_ERROR,
+								     ("!!! Radio On !!!\n"));
+
+								MlmeRadioOn
+								    (pAd);
+								// Update extra information
+								pAd->ExtraInfo =
+								    EXTRA_INFO_CLEAR;
+							} else {
+								DBGPRINT_RAW
+								    (RT_DEBUG_ERROR,
+								     ("!!! Radio Off !!!\n"));
+
+								MlmeRadioOff
+								    (pAd);
+								// Update extra information
+								pAd->ExtraInfo =
+								    HW_RADIO_OFF;
 							}
 						}
 					}
-					break;
+				}
+				break;
 
-				case CMDTHREAD_QKERIODIC_EXECUT:
-					{
-						StaQuickResponeForRateUpExec(NULL, pAd, NULL, NULL);
-					}
-					break;
-
-				case CMDTHREAD_RESET_BULK_OUT:
-					{
-						UINT32		MACValue;
-						UCHAR		Index;
-						int			ret=0;
-						PHT_TX_CONTEXT	pHTTXContext;
-//						RTMP_TX_RING *pTxRing;
-						unsigned long IrqFlags;
-
-						DBGPRINT_RAW(RT_DEBUG_TRACE, ("CmdThread : CMDTHREAD_RESET_BULK_OUT(ResetPipeid=0x%0x)===>\n", pAd->bulkResetPipeid));
-						// All transfers must be aborted or cancelled before attempting to reset the pipe.
-						//RTUSBCancelPendingBulkOutIRP(pAd);
-						// Wait 10ms to let previous packet that are already in HW FIFO to clear. by MAXLEE 12-25-2007
-						Index = 0;
-						do
-						{
-							RTUSBReadMACRegister(pAd, TXRXQ_PCNT, &MACValue);
-							if ((MACValue & 0xf00000/*0x800000*/) == 0)
-								break;
-							Index++;
-							RTMPusecDelay(10000);
-						}while(Index < 100);
-						MACValue = 0;
-						RTUSBReadMACRegister(pAd, USB_DMA_CFG, &MACValue);
-						// To prevent Read Register error, we 2nd check the validity.
-						if ((MACValue & 0xc00000) == 0)
-							RTUSBReadMACRegister(pAd, USB_DMA_CFG, &MACValue);
-						// To prevent Read Register error, we 3rd check the validity.
-						if ((MACValue & 0xc00000) == 0)
-							RTUSBReadMACRegister(pAd, USB_DMA_CFG, &MACValue);
-						MACValue |= 0x80000;
-						RTUSBWriteMACRegister(pAd, USB_DMA_CFG, MACValue);
-
-						// Wait 1ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007
-						RTMPusecDelay(1000);
-
-						MACValue &= (~0x80000);
-						RTUSBWriteMACRegister(pAd, USB_DMA_CFG, MACValue);
-						DBGPRINT_RAW(RT_DEBUG_TRACE, ("\tSet 0x2a0 bit19. Clear USB DMA TX path\n"));
+			case CMDTHREAD_QKERIODIC_EXECUT:
+				{
+					StaQuickResponeForRateUpExec(NULL, pAd,
+								     NULL,
+								     NULL);
+				}
+				break;
+
+			case CMDTHREAD_RESET_BULK_OUT:
+				{
+					UINT32 MACValue;
+					UCHAR Index;
+					int ret = 0;
+					PHT_TX_CONTEXT pHTTXContext;
+//                                              RTMP_TX_RING *pTxRing;
+					unsigned long IrqFlags;
+
+					DBGPRINT_RAW(RT_DEBUG_TRACE,
+						     ("CmdThread : CMDTHREAD_RESET_BULK_OUT(ResetPipeid=0x%0x)===>\n",
+						      pAd->bulkResetPipeid));
+					// All transfers must be aborted or cancelled before attempting to reset the pipe.
+					//RTUSBCancelPendingBulkOutIRP(pAd);
+					// Wait 10ms to let previous packet that are already in HW FIFO to clear. by MAXLEE 12-25-2007
+					Index = 0;
+					do {
+						RTUSBReadMACRegister(pAd,
+								     TXRXQ_PCNT,
+								     &MACValue);
+						if ((MACValue & 0xf00000
+						     /*0x800000 */ ) == 0)
+							break;
+						Index++;
+						RTMPusecDelay(10000);
+					} while (Index < 100);
+					MACValue = 0;
+					RTUSBReadMACRegister(pAd, USB_DMA_CFG,
+							     &MACValue);
+					// To prevent Read Register error, we 2nd check the validity.
+					if ((MACValue & 0xc00000) == 0)
+						RTUSBReadMACRegister(pAd,
+								     USB_DMA_CFG,
+								     &MACValue);
+					// To prevent Read Register error, we 3rd check the validity.
+					if ((MACValue & 0xc00000) == 0)
+						RTUSBReadMACRegister(pAd,
+								     USB_DMA_CFG,
+								     &MACValue);
+					MACValue |= 0x80000;
+					RTUSBWriteMACRegister(pAd, USB_DMA_CFG,
+							      MACValue);
+
+					// Wait 1ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007
+					RTMPusecDelay(1000);
+
+					MACValue &= (~0x80000);
+					RTUSBWriteMACRegister(pAd, USB_DMA_CFG,
+							      MACValue);
+					DBGPRINT_RAW(RT_DEBUG_TRACE,
+						     ("\tSet 0x2a0 bit19. Clear USB DMA TX path\n"));
+
+					// Wait 5ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007
+					//RTMPusecDelay(5000);
+
+					if ((pAd->
+					     bulkResetPipeid &
+					     BULKOUT_MGMT_RESET_FLAG) ==
+					    BULKOUT_MGMT_RESET_FLAG) {
+						RTMP_CLEAR_FLAG(pAd,
+								fRTMP_ADAPTER_BULKOUT_RESET);
+						if (pAd->MgmtRing.TxSwFreeIdx <
+						    MGMT_RING_SIZE
+						    /* pMLMEContext->bWaitingBulkOut == TRUE */
+						    ) {
+							RTUSB_SET_BULK_FLAG(pAd,
+									    fRTUSB_BULK_OUT_MLME);
+						}
+						RTUSBKickBulkOut(pAd);
 
-						// Wait 5ms to prevent next URB to bulkout before HW reset. by MAXLEE 12-25-2007
-						//RTMPusecDelay(5000);
+						DBGPRINT_RAW(RT_DEBUG_TRACE,
+							     ("\tTX MGMT RECOVER Done!\n"));
+					} else {
+						pHTTXContext =
+						    &(pAd->
+						      TxContext[pAd->
+								bulkResetPipeid]);
+						//NdisAcquireSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
+						RTMP_INT_LOCK(&pAd->
+							      BulkOutLock[pAd->
+									  bulkResetPipeid],
+							      IrqFlags);
+						if (pAd->
+						    BulkOutPending[pAd->
+								   bulkResetPipeid]
+						    == FALSE) {
+							pAd->
+							    BulkOutPending[pAd->
+									   bulkResetPipeid]
+							    = TRUE;
+							pHTTXContext->
+							    IRPPending = TRUE;
+							pAd->
+							    watchDogTxPendingCnt
+							    [pAd->
+							     bulkResetPipeid] =
+							    1;
 
-						if ((pAd->bulkResetPipeid & BULKOUT_MGMT_RESET_FLAG) == BULKOUT_MGMT_RESET_FLAG)
-						{
-							RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-							if (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE /* pMLMEContext->bWaitingBulkOut == TRUE */)
-							{
-								RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
-							}
-							RTUSBKickBulkOut(pAd);
+							// no matter what, clean the flag
+							RTMP_CLEAR_FLAG(pAd,
+									fRTMP_ADAPTER_BULKOUT_RESET);
 
-							DBGPRINT_RAW(RT_DEBUG_TRACE, ("\tTX MGMT RECOVER Done!\n"));
-						}
-						else
-						{
-							pHTTXContext = &(pAd->TxContext[pAd->bulkResetPipeid]);
-							//NdisAcquireSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
-							RTMP_INT_LOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
-							if ( pAd->BulkOutPending[pAd->bulkResetPipeid] == FALSE)
+							//NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
+							RTMP_INT_UNLOCK(&pAd->
+									BulkOutLock
+									[pAd->
+									 bulkResetPipeid],
+									IrqFlags);
 							{
-								pAd->BulkOutPending[pAd->bulkResetPipeid] = TRUE;
-								pHTTXContext->IRPPending = TRUE;
-								pAd->watchDogTxPendingCnt[pAd->bulkResetPipeid] = 1;
-
-								// no matter what, clean the flag
-								RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-
-								//NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
-								RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
-								{
-								RTUSBInitHTTxDesc(pAd, pHTTXContext, pAd->bulkResetPipeid, pHTTXContext->BulkOutSize, (usb_complete_t)RTUSBBulkOutDataPacketComplete);
-
-								if((ret = RTUSB_SUBMIT_URB(pHTTXContext->pUrb))!=0)
-								{
-										RTMP_INT_LOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
-									pAd->BulkOutPending[pAd->bulkResetPipeid] = FALSE;
-									pHTTXContext->IRPPending = FALSE;
-										pAd->watchDogTxPendingCnt[pAd->bulkResetPipeid] = 0;
-										RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
-
-										DBGPRINT(RT_DEBUG_ERROR, ("CmdThread : CMDTHREAD_RESET_BULK_OUT: Submit Tx URB failed %d\n", ret));
-								}
-									else
-									{
-										RTMP_IRQ_LOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
-										DBGPRINT_RAW(RT_DEBUG_TRACE,("\tCMDTHREAD_RESET_BULK_OUT: TxContext[%d]:CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d, pending=%d!\n",
-												pAd->bulkResetPipeid, pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition,
-															pHTTXContext->ENextBulkOutPosition, pHTTXContext->bCopySavePad, pAd->BulkOutPending[pAd->bulkResetPipeid]));
-										DBGPRINT_RAW(RT_DEBUG_TRACE,("\t\tBulkOut Req=0x%lx, Complete=0x%lx, Other=0x%lx\n",
-															pAd->BulkOutReq, pAd->BulkOutComplete, pAd->BulkOutCompleteOther));
-										RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
-										DBGPRINT_RAW(RT_DEBUG_TRACE, ("\tCMDTHREAD_RESET_BULK_OUT: Submit Tx DATA URB for failed BulkReq(0x%lx) Done, status=%d!\n", pAd->bulkResetReq[pAd->bulkResetPipeid], pHTTXContext->pUrb->status));
+								RTUSBInitHTTxDesc
+								    (pAd,
+								     pHTTXContext,
+								     pAd->
+								     bulkResetPipeid,
+								     pHTTXContext->
+								     BulkOutSize,
+								     (usb_complete_t)
+								     RTUSBBulkOutDataPacketComplete);
+
+								if ((ret =
+								     RTUSB_SUBMIT_URB
+								     (pHTTXContext->
+								      pUrb)) !=
+								    0) {
+									RTMP_INT_LOCK
+									    (&pAd->
+									     BulkOutLock
+									     [pAd->
+									      bulkResetPipeid],
+									     IrqFlags);
+									pAd->
+									    BulkOutPending
+									    [pAd->
+									     bulkResetPipeid]
+									    =
+									    FALSE;
+									pHTTXContext->
+									    IRPPending
+									    =
+									    FALSE;
+									pAd->
+									    watchDogTxPendingCnt
+									    [pAd->
+									     bulkResetPipeid]
+									    = 0;
+									RTMP_INT_UNLOCK
+									    (&pAd->
+									     BulkOutLock
+									     [pAd->
+									      bulkResetPipeid],
+									     IrqFlags);
+
+									DBGPRINT
+									    (RT_DEBUG_ERROR,
+									     ("CmdThread : CMDTHREAD_RESET_BULK_OUT: Submit Tx URB failed %d\n",
+									      ret));
+								} else {
+									RTMP_IRQ_LOCK
+									    (&pAd->
+									     BulkOutLock
+									     [pAd->
+									      bulkResetPipeid],
+									     IrqFlags);
+									DBGPRINT_RAW
+									    (RT_DEBUG_TRACE,
+									     ("\tCMDTHREAD_RESET_BULK_OUT: TxContext[%d]:CWPos=%ld, NBPos=%ld, ENBPos=%ld, bCopy=%d, pending=%d!\n",
+									      pAd->
+									      bulkResetPipeid,
+									      pHTTXContext->
+									      CurWritePosition,
+									      pHTTXContext->
+									      NextBulkOutPosition,
+									      pHTTXContext->
+									      ENextBulkOutPosition,
+									      pHTTXContext->
+									      bCopySavePad,
+									      pAd->
+									      BulkOutPending
+									      [pAd->
+									       bulkResetPipeid]));
+									DBGPRINT_RAW
+									    (RT_DEBUG_TRACE,
+									     ("\t\tBulkOut Req=0x%lx, Complete=0x%lx, Other=0x%lx\n",
+									      pAd->
+									      BulkOutReq,
+									      pAd->
+									      BulkOutComplete,
+									      pAd->
+									      BulkOutCompleteOther));
+									RTMP_IRQ_UNLOCK
+									    (&pAd->
+									     BulkOutLock
+									     [pAd->
+									      bulkResetPipeid],
+									     IrqFlags);
+									DBGPRINT_RAW
+									    (RT_DEBUG_TRACE,
+									     ("\tCMDTHREAD_RESET_BULK_OUT: Submit Tx DATA URB for failed BulkReq(0x%lx) Done, status=%d!\n",
+									      pAd->
+									      bulkResetReq
+									      [pAd->
+									       bulkResetPipeid],
+									      pHTTXContext->
+									      pUrb->
+									      status));
 
-									}
 								}
 							}
-							else
-							{
-								//NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
-								//RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
-
-								DBGPRINT_RAW(RT_DEBUG_ERROR, ("CmdThread : TX DATA RECOVER FAIL for BulkReq(0x%lx) because BulkOutPending[%d] is TRUE!\n", pAd->bulkResetReq[pAd->bulkResetPipeid], pAd->bulkResetPipeid));
-								if (pAd->bulkResetPipeid == 0)
-								{
-									UCHAR	pendingContext = 0;
-									PHT_TX_CONTEXT pHTTXContext = (PHT_TX_CONTEXT)(&pAd->TxContext[pAd->bulkResetPipeid ]);
-									PTX_CONTEXT pMLMEContext = (PTX_CONTEXT)(pAd->MgmtRing.Cell[pAd->MgmtRing.TxDmaIdx].AllocVa);
-									PTX_CONTEXT pNULLContext = (PTX_CONTEXT)(&pAd->PsPollContext);
-									PTX_CONTEXT pPsPollContext = (PTX_CONTEXT)(&pAd->NullContext);
-
-									if (pHTTXContext->IRPPending)
-										pendingContext |= 1;
-									else if (pMLMEContext->IRPPending)
-										pendingContext |= 2;
-									else if (pNULLContext->IRPPending)
-										pendingContext |= 4;
-									else if (pPsPollContext->IRPPending)
-										pendingContext |= 8;
-									else
-										pendingContext = 0;
-
-									DBGPRINT_RAW(RT_DEBUG_ERROR, ("\tTX Occupied by %d!\n", pendingContext));
-								}
-
-							// no matter what, clean the flag
-							RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BULKOUT_RESET);
-
-								RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+						} else {
+							//NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);
+							//RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+
+							DBGPRINT_RAW
+							    (RT_DEBUG_ERROR,
+							     ("CmdThread : TX DATA RECOVER FAIL for BulkReq(0x%lx) because BulkOutPending[%d] is TRUE!\n",
+							      pAd->
+							      bulkResetReq[pAd->
+									   bulkResetPipeid],
+							      pAd->
+							      bulkResetPipeid));
+							if (pAd->
+							    bulkResetPipeid ==
+							    0) {
+								UCHAR
+								    pendingContext
+								    = 0;
+								PHT_TX_CONTEXT
+								    pHTTXContext
+								    =
+								    (PHT_TX_CONTEXT)
+								    (&pAd->
+								     TxContext
+								     [pAd->
+								      bulkResetPipeid]);
+								PTX_CONTEXT
+								    pMLMEContext
+								    =
+								    (PTX_CONTEXT)
+								    (pAd->
+								     MgmtRing.
+								     Cell[pAd->
+									  MgmtRing.
+									  TxDmaIdx].
+								     AllocVa);
+								PTX_CONTEXT
+								    pNULLContext
+								    =
+								    (PTX_CONTEXT)
+								    (&pAd->
+								     PsPollContext);
+								PTX_CONTEXT
+								    pPsPollContext
+								    =
+								    (PTX_CONTEXT)
+								    (&pAd->
+								     NullContext);
+
+								if (pHTTXContext->IRPPending)
+									pendingContext
+									    |=
+									    1;
+								else if
+								    (pMLMEContext->
+								     IRPPending)
+									pendingContext
+									    |=
+									    2;
+								else if
+								    (pNULLContext->
+								     IRPPending)
+									pendingContext
+									    |=
+									    4;
+								else if
+								    (pPsPollContext->
+								     IRPPending)
+									pendingContext
+									    |=
+									    8;
+								else
+									pendingContext
+									    = 0;
 
-								RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << pAd->bulkResetPipeid));
+								DBGPRINT_RAW
+								    (RT_DEBUG_ERROR,
+								     ("\tTX Occupied by %d!\n",
+								      pendingContext));
 							}
+							// no matter what, clean the flag
+							RTMP_CLEAR_FLAG(pAd,
+									fRTMP_ADAPTER_BULKOUT_RESET);
 
-							RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-							//RTUSBKickBulkOut(pAd);
+							RTMP_INT_UNLOCK(&pAd->
+									BulkOutLock
+									[pAd->
+									 bulkResetPipeid],
+									IrqFlags);
+
+							RTUSB_SET_BULK_FLAG(pAd,
+									    (fRTUSB_BULK_OUT_DATA_NORMAL
+									     <<
+									     pAd->
+									     bulkResetPipeid));
 						}
 
+						RTMPDeQueuePacket(pAd, FALSE,
+								  NUM_OF_TX_RING,
+								  MAX_TX_PROCESS);
+						//RTUSBKickBulkOut(pAd);
 					}
-					/*
-						// Don't cancel BULKIN.
-						while ((atomic_read(&pAd->PendingRx) > 0) &&
-								(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-						{
-							if (atomic_read(&pAd->PendingRx) > 0)
-							{
-								DBGPRINT_RAW(RT_DEBUG_ERROR, ("BulkIn IRP Pending!!cancel it!\n"));
-								RTUSBCancelPendingBulkInIRP(pAd);
-							}
-							RTMPusecDelay(100000);
-						}
-
-						if ((atomic_read(&pAd->PendingRx) == 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
-						{
-							UCHAR	i;
-							RTUSBRxPacket(pAd);
-							pAd->NextRxBulkInReadIndex = 0;	// Next Rx Read index
-							pAd->NextRxBulkInIndex		= 0;	// Rx Bulk pointer
-							for (i = 0; i < (RX_RING_SIZE); i++)
-							{
-								PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
 
-								pRxContext->pAd	= pAd;
-								pRxContext->InUse		= FALSE;
-								pRxContext->IRPPending	= FALSE;
-								pRxContext->Readable	= FALSE;
-								pRxContext->ReorderInUse = FALSE;
+				}
+				/*
+				   // Don't cancel BULKIN.
+				   while ((atomic_read(&pAd->PendingRx) > 0) &&
+				   (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+				   {
+				   if (atomic_read(&pAd->PendingRx) > 0)
+				   {
+				   DBGPRINT_RAW(RT_DEBUG_ERROR, ("BulkIn IRP Pending!!cancel it!\n"));
+				   RTUSBCancelPendingBulkInIRP(pAd);
+				   }
+				   RTMPusecDelay(100000);
+				   }
+
+				   if ((atomic_read(&pAd->PendingRx) == 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
+				   {
+				   UCHAR        i;
+				   RTUSBRxPacket(pAd);
+				   pAd->NextRxBulkInReadIndex = 0;      // Next Rx Read index
+				   pAd->NextRxBulkInIndex               = 0;    // Rx Bulk pointer
+				   for (i = 0; i < (RX_RING_SIZE); i++)
+				   {
+				   PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+
+				   pRxContext->pAd      = pAd;
+				   pRxContext->InUse            = FALSE;
+				   pRxContext->IRPPending       = FALSE;
+				   pRxContext->Readable = FALSE;
+				   pRxContext->ReorderInUse = FALSE;
+
+				   }
+				   RTUSBBulkReceive(pAd);
+				   DBGPRINT_RAW(RT_DEBUG_ERROR, ("RTUSBBulkReceive\n"));
+				   } */
+				DBGPRINT_RAW(RT_DEBUG_TRACE,
+					     ("CmdThread : CMDTHREAD_RESET_BULK_OUT<===\n"));
+				break;
+
+			case CMDTHREAD_RESET_BULK_IN:
+				DBGPRINT_RAW(RT_DEBUG_TRACE,
+					     ("CmdThread : CMDTHREAD_RESET_BULK_IN === >\n"));
+
+				// All transfers must be aborted or cancelled before attempting to reset the pipe.
+				{
+					UINT32 MACValue;
 
-							}
-							RTUSBBulkReceive(pAd);
-							DBGPRINT_RAW(RT_DEBUG_ERROR, ("RTUSBBulkReceive\n"));
-						}*/
-					DBGPRINT_RAW(RT_DEBUG_TRACE, ("CmdThread : CMDTHREAD_RESET_BULK_OUT<===\n"));
-    	   			break;
-
-				case CMDTHREAD_RESET_BULK_IN:
-					DBGPRINT_RAW(RT_DEBUG_TRACE, ("CmdThread : CMDTHREAD_RESET_BULK_IN === >\n"));
-
-					// All transfers must be aborted or cancelled before attempting to reset the pipe.
 					{
-						UINT32		MACValue;
-
-						{
 						//while ((atomic_read(&pAd->PendingRx) > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
-						if((pAd->PendingRx > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+						if ((pAd->PendingRx > 0)
+						    &&
+						    (!RTMP_TEST_FLAG
+						     (pAd,
+						      fRTMP_ADAPTER_NIC_NOT_EXIST)))
 						{
-							DBGPRINT_RAW(RT_DEBUG_ERROR, ("BulkIn IRP Pending!!!\n"));
-							RTUSBCancelPendingBulkInIRP(pAd);
+							DBGPRINT_RAW
+							    (RT_DEBUG_ERROR,
+							     ("BulkIn IRP Pending!!!\n"));
+							RTUSBCancelPendingBulkInIRP
+							    (pAd);
 							RTMPusecDelay(100000);
 							pAd->PendingRx = 0;
 						}
-						}
-
-						// Wait 10ms before reading register.
-						RTMPusecDelay(10000);
-						ntStatus = RTUSBReadMACRegister(pAd, MAC_CSR0, &MACValue);
-
-						if ((NT_SUCCESS(ntStatus) == TRUE) &&
-							(!(RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS | fRTMP_ADAPTER_RADIO_OFF |
-													fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST)))))
-						{
-							UCHAR	i;
-
-							if (RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_RESET_IN_PROGRESS | fRTMP_ADAPTER_RADIO_OFF |
-														fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST)))
-								break;
-							pAd->NextRxBulkInPosition = pAd->RxContext[pAd->NextRxBulkInIndex].BulkInOffset;
-							DBGPRINT(RT_DEBUG_TRACE, ("BULK_IN_RESET: NBIIdx=0x%x,NBIRIdx=0x%x, BIRPos=0x%lx. BIReq=x%lx, BIComplete=0x%lx, BICFail0x%lx\n",
-									pAd->NextRxBulkInIndex,  pAd->NextRxBulkInReadIndex, pAd->NextRxBulkInPosition, pAd->BulkInReq, pAd->BulkInComplete, pAd->BulkInCompleteFail));
-							for (i = 0; i < RX_RING_SIZE; i++)
-							{
- 								DBGPRINT(RT_DEBUG_TRACE, ("\tRxContext[%d]: IRPPending=%d, InUse=%d, Readable=%d!\n"
-									, i, pAd->RxContext[i].IRPPending, pAd->RxContext[i].InUse, pAd->RxContext[i].Readable));
-							}
- 							/*
-
-							DBGPRINT_RAW(RT_DEBUG_ERROR, ("==========================================\n"));
+					}
 
-							pAd->NextRxBulkInReadIndex = 0;	// Next Rx Read index
-							pAd->NextRxBulkInIndex		= 0;	// Rx Bulk pointer
-							for (i = 0; i < (RX_RING_SIZE); i++)
-							{
-								PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+					// Wait 10ms before reading register.
+					RTMPusecDelay(10000);
+					ntStatus =
+					    RTUSBReadMACRegister(pAd, MAC_CSR0,
+								 &MACValue);
+
+					if ((NT_SUCCESS(ntStatus) == TRUE) &&
+					    (!(RTMP_TEST_FLAG
+					       (pAd,
+						(fRTMP_ADAPTER_RESET_IN_PROGRESS
+						 | fRTMP_ADAPTER_RADIO_OFF |
+						 fRTMP_ADAPTER_HALT_IN_PROGRESS
+						 |
+						 fRTMP_ADAPTER_NIC_NOT_EXIST)))))
+					{
+						UCHAR i;
 
-								pRxContext->pAd	= pAd;
-								pRxContext->InUse		= FALSE;
-								pRxContext->IRPPending	= FALSE;
-								pRxContext->Readable	= FALSE;
-								pRxContext->ReorderInUse = FALSE;
-
-							}*/
-							RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BULKIN_RESET);
-							for (i = 0; i < pAd->CommonCfg.NumOfBulkInIRP; i++)
-							{
-								//RTUSBBulkReceive(pAd);
-								PRX_CONTEXT		pRxContext;
-								PURB			pUrb;
-								int				ret = 0;
-								unsigned long	IrqFlags;
+						if (RTMP_TEST_FLAG
+						    (pAd,
+						     (fRTMP_ADAPTER_RESET_IN_PROGRESS
+						      | fRTMP_ADAPTER_RADIO_OFF
+						      |
+						      fRTMP_ADAPTER_HALT_IN_PROGRESS
+						      |
+						      fRTMP_ADAPTER_NIC_NOT_EXIST)))
+							break;
+						pAd->NextRxBulkInPosition =
+						    pAd->RxContext[pAd->
+								   NextRxBulkInIndex].
+						    BulkInOffset;
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("BULK_IN_RESET: NBIIdx=0x%x,NBIRIdx=0x%x, BIRPos=0x%lx. BIReq=x%lx, BIComplete=0x%lx, BICFail0x%lx\n",
+							  pAd->
+							  NextRxBulkInIndex,
+							  pAd->
+							  NextRxBulkInReadIndex,
+							  pAd->
+							  NextRxBulkInPosition,
+							  pAd->BulkInReq,
+							  pAd->BulkInComplete,
+							  pAd->
+							  BulkInCompleteFail));
+						for (i = 0; i < RX_RING_SIZE;
+						     i++) {
+							DBGPRINT(RT_DEBUG_TRACE,
+								 ("\tRxContext[%d]: IRPPending=%d, InUse=%d, Readable=%d!\n",
+								  i,
+								  pAd->
+								  RxContext[i].
+								  IRPPending,
+								  pAd->
+								  RxContext[i].
+								  InUse,
+								  pAd->
+								  RxContext[i].
+								  Readable));
+						}
+						/*
 
+						   DBGPRINT_RAW(RT_DEBUG_ERROR, ("==========================================\n"));
 
-								RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-								pRxContext = &(pAd->RxContext[pAd->NextRxBulkInIndex]);
-								if ((pAd->PendingRx > 0) || (pRxContext->Readable == TRUE) || (pRxContext->InUse == TRUE))
-								{
-									RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-									break;
-								}
-								pRxContext->InUse = TRUE;
-								pRxContext->IRPPending = TRUE;
-								pAd->PendingRx++;
-								pAd->BulkInReq++;
-								RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-
-								// Init Rx context descriptor
-								RTUSBInitRxDesc(pAd, pRxContext);
-								pUrb = pRxContext->pUrb;
-								if ((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
-								{	// fail
-
-									RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
-									pRxContext->InUse = FALSE;
-									pRxContext->IRPPending = FALSE;
-									pAd->PendingRx--;
-									pAd->BulkInReq--;
-									RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
-									DBGPRINT(RT_DEBUG_ERROR, ("CMDTHREAD_RESET_BULK_IN: Submit Rx URB failed(%d), status=%d\n", ret, pUrb->status));
-								}
-								else
-								{	// success
-									//DBGPRINT(RT_DEBUG_TRACE, ("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n",
-									//							pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex));
-									DBGPRINT_RAW(RT_DEBUG_TRACE, ("CMDTHREAD_RESET_BULK_IN: Submit Rx URB Done, status=%d!\n", pUrb->status));
-									ASSERT((pRxContext->InUse == pRxContext->IRPPending));
-								}
+						   pAd->NextRxBulkInReadIndex = 0;      // Next Rx Read index
+						   pAd->NextRxBulkInIndex               = 0;    // Rx Bulk pointer
+						   for (i = 0; i < (RX_RING_SIZE); i++)
+						   {
+						   PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+
+						   pRxContext->pAd      = pAd;
+						   pRxContext->InUse            = FALSE;
+						   pRxContext->IRPPending       = FALSE;
+						   pRxContext->Readable = FALSE;
+						   pRxContext->ReorderInUse = FALSE;
+
+						   } */
+						RTMP_CLEAR_FLAG(pAd,
+								fRTMP_ADAPTER_BULKIN_RESET);
+						for (i = 0;
+						     i <
+						     pAd->CommonCfg.
+						     NumOfBulkInIRP; i++) {
+							//RTUSBBulkReceive(pAd);
+							PRX_CONTEXT pRxContext;
+							PURB pUrb;
+							int ret = 0;
+							unsigned long IrqFlags;
+
+							RTMP_IRQ_LOCK(&pAd->
+								      BulkInLock,
+								      IrqFlags);
+							pRxContext =
+							    &(pAd->
+							      RxContext[pAd->
+									NextRxBulkInIndex]);
+							if ((pAd->PendingRx > 0)
+							    || (pRxContext->
+								Readable ==
+								TRUE)
+							    || (pRxContext->
+								InUse ==
+								TRUE)) {
+								RTMP_IRQ_UNLOCK
+								    (&pAd->
+								     BulkInLock,
+								     IrqFlags);
+								break;
 							}
-
-						}
-						else
-						{
-							// Card must be removed
-							if (NT_SUCCESS(ntStatus) != TRUE)
-							{
-							RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST);
-								DBGPRINT_RAW(RT_DEBUG_ERROR, ("CMDTHREAD_RESET_BULK_IN: Read Register Failed!Card must be removed!!\n\n"));
+							pRxContext->InUse =
+							    TRUE;
+							pRxContext->IRPPending =
+							    TRUE;
+							pAd->PendingRx++;
+							pAd->BulkInReq++;
+							RTMP_IRQ_UNLOCK(&pAd->
+									BulkInLock,
+									IrqFlags);
+
+							// Init Rx context descriptor
+							RTUSBInitRxDesc(pAd,
+									pRxContext);
+							pUrb = pRxContext->pUrb;
+							if ((ret = RTUSB_SUBMIT_URB(pUrb)) != 0) {	// fail
+
+								RTMP_IRQ_LOCK
+								    (&pAd->
+								     BulkInLock,
+								     IrqFlags);
+								pRxContext->
+								    InUse =
+								    FALSE;
+								pRxContext->
+								    IRPPending =
+								    FALSE;
+								pAd->
+								    PendingRx--;
+								pAd->
+								    BulkInReq--;
+								RTMP_IRQ_UNLOCK
+								    (&pAd->
+								     BulkInLock,
+								     IrqFlags);
+								DBGPRINT
+								    (RT_DEBUG_ERROR,
+								     ("CMDTHREAD_RESET_BULK_IN: Submit Rx URB failed(%d), status=%d\n",
+								      ret,
+								      pUrb->
+								      status));
+							} else {	// success
+								//DBGPRINT(RT_DEBUG_TRACE, ("BIDone, Pend=%d,BIIdx=%d,BIRIdx=%d!\n",
+								//                                                      pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex));
+								DBGPRINT_RAW
+								    (RT_DEBUG_TRACE,
+								     ("CMDTHREAD_RESET_BULK_IN: Submit Rx URB Done, status=%d!\n",
+								      pUrb->
+								      status));
+								ASSERT((pRxContext->InUse == pRxContext->IRPPending));
 							}
-							else
-							{
-								DBGPRINT_RAW(RT_DEBUG_ERROR, ("CMDTHREAD_RESET_BULK_IN: Cannot do bulk in because flags(0x%lx) on !\n", pAd->Flags));
 						}
-					}
-					}
-					DBGPRINT_RAW(RT_DEBUG_TRACE, ("CmdThread : CMDTHREAD_RESET_BULK_IN <===\n"));
-					break;
-
-				case CMDTHREAD_SET_ASIC_WCID:
-					{
-						RT_SET_ASIC_WCID	SetAsicWcid;
-						USHORT		offset;
-						UINT32		MACValue, MACRValue = 0;
-						SetAsicWcid = *((PRT_SET_ASIC_WCID)(pData));
-
-						if (SetAsicWcid.WCID >= MAX_LEN_OF_MAC_TABLE)
-							return;
-
-						offset = MAC_WCID_BASE + ((UCHAR)SetAsicWcid.WCID)*HW_WCID_ENTRY_SIZE;
-
-						DBGPRINT_RAW(RT_DEBUG_TRACE, ("CmdThread : CMDTHREAD_SET_ASIC_WCID : WCID = %ld, SetTid  = %lx, DeleteTid = %lx.\n", SetAsicWcid.WCID, SetAsicWcid.SetTid, SetAsicWcid.DeleteTid));
-						MACValue = (pAd->MacTab.Content[SetAsicWcid.WCID].Addr[3]<<24)+(pAd->MacTab.Content[SetAsicWcid.WCID].Addr[2]<<16)+(pAd->MacTab.Content[SetAsicWcid.WCID].Addr[1]<<8)+(pAd->MacTab.Content[SetAsicWcid.WCID].Addr[0]);
-						DBGPRINT_RAW(RT_DEBUG_TRACE, ("1-MACValue= %x,\n", MACValue));
-						RTUSBWriteMACRegister(pAd, offset, MACValue);
-						// Read bitmask
-						RTUSBReadMACRegister(pAd, offset+4, &MACRValue);
-						if ( SetAsicWcid.DeleteTid != 0xffffffff)
-							MACRValue &= (~SetAsicWcid.DeleteTid);
-						if (SetAsicWcid.SetTid != 0xffffffff)
-							MACRValue |= (SetAsicWcid.SetTid);
-						MACRValue &= 0xffff0000;
-
-						MACValue = (pAd->MacTab.Content[SetAsicWcid.WCID].Addr[5]<<8)+pAd->MacTab.Content[SetAsicWcid.WCID].Addr[4];
-						MACValue |= MACRValue;
-						RTUSBWriteMACRegister(pAd, offset+4, MACValue);
-
-						DBGPRINT_RAW(RT_DEBUG_TRACE, ("2-MACValue= %x,\n", MACValue));
-					}
-					break;
-
-				case CMDTHREAD_SET_ASIC_WCID_CIPHER:
-					{
-						RT_SET_ASIC_WCID_ATTRI	SetAsicWcidAttri;
-						USHORT		offset;
-						UINT32		MACRValue = 0;
-						SHAREDKEY_MODE_STRUC csr1;
-						SetAsicWcidAttri = *((PRT_SET_ASIC_WCID_ATTRI)(pData));
-
-						if (SetAsicWcidAttri.WCID >= MAX_LEN_OF_MAC_TABLE)
-							return;
-
-						offset = MAC_WCID_ATTRIBUTE_BASE + ((UCHAR)SetAsicWcidAttri.WCID)*HW_WCID_ATTRI_SIZE;
-
-						DBGPRINT_RAW(RT_DEBUG_TRACE, ("Cmd : CMDTHREAD_SET_ASIC_WCID_CIPHER : WCID = %ld, Cipher = %lx.\n", SetAsicWcidAttri.WCID, SetAsicWcidAttri.Cipher));
-						// Read bitmask
-						RTUSBReadMACRegister(pAd, offset, &MACRValue);
-						MACRValue = 0;
-						MACRValue |= (((UCHAR)SetAsicWcidAttri.Cipher) << 1);
-
-						RTUSBWriteMACRegister(pAd, offset, MACRValue);
-						DBGPRINT_RAW(RT_DEBUG_TRACE, ("2-offset = %x , MACValue= %x,\n", offset, MACRValue));
-
-						offset = PAIRWISE_IVEIV_TABLE_BASE + ((UCHAR)SetAsicWcidAttri.WCID)*HW_IVEIV_ENTRY_SIZE;
-						MACRValue = 0;
-						if ( (SetAsicWcidAttri.Cipher <= CIPHER_WEP128))
-							MACRValue |= ( pAd->StaCfg.DefaultKeyId << 30);
-						else
-							MACRValue |= (0x20000000);
-						RTUSBWriteMACRegister(pAd, offset, MACRValue);
-						DBGPRINT_RAW(RT_DEBUG_TRACE, ("2-offset = %x , MACValue= %x,\n", offset, MACRValue));
 
-						//
-						// Update cipher algorithm. WSTA always use BSS0
-						//
-						// for adhoc mode only ,because wep status slow than add key, when use zero config
-						if (pAd->StaCfg.BssType == BSS_ADHOC )
-						{
-							offset = MAC_WCID_ATTRIBUTE_BASE;
-
-							RTUSBReadMACRegister(pAd, offset, &MACRValue);
-							MACRValue &= (~0xe);
-							MACRValue |= (((UCHAR)SetAsicWcidAttri.Cipher) << 1);
-
-							RTUSBWriteMACRegister(pAd, offset, MACRValue);
-
-							//Update group key cipher,,because wep status slow than add key, when use zero config
-							RTUSBReadMACRegister(pAd, SHARED_KEY_MODE_BASE+4*(0/2), &csr1.word);
-
-							csr1.field.Bss0Key0CipherAlg = SetAsicWcidAttri.Cipher;
-							csr1.field.Bss0Key1CipherAlg = SetAsicWcidAttri.Cipher;
-
-							RTUSBWriteMACRegister(pAd, SHARED_KEY_MODE_BASE+4*(0/2), csr1.word);
+					} else {
+						// Card must be removed
+						if (NT_SUCCESS(ntStatus) !=
+						    TRUE) {
+							RTMP_SET_FLAG(pAd,
+								      fRTMP_ADAPTER_NIC_NOT_EXIST);
+							DBGPRINT_RAW
+							    (RT_DEBUG_ERROR,
+							     ("CMDTHREAD_RESET_BULK_IN: Read Register Failed!Card must be removed!!\n\n"));
+						} else {
+							DBGPRINT_RAW
+							    (RT_DEBUG_ERROR,
+							     ("CMDTHREAD_RESET_BULK_IN: Cannot do bulk in because flags(0x%lx) on !\n",
+							      pAd->Flags));
 						}
 					}
-					break;
-
-//Benson modified for USB interface, avoid in interrupt when write key, 20080724 -->
-				case RT_CMD_SET_KEY_TABLE: //General call for AsicAddPairwiseKeyEntry()
-					{
-						RT_ADD_PAIRWISE_KEY_ENTRY KeyInfo;
-						KeyInfo  = *((PRT_ADD_PAIRWISE_KEY_ENTRY)(pData));
-						AsicAddPairwiseKeyEntry(pAd,
-												KeyInfo.MacAddr,
-												(UCHAR)KeyInfo.MacTabMatchWCID,
-												&KeyInfo.CipherKey);
+				}
+				DBGPRINT_RAW(RT_DEBUG_TRACE,
+					     ("CmdThread : CMDTHREAD_RESET_BULK_IN <===\n"));
+				break;
+
+			case CMDTHREAD_SET_ASIC_WCID:
+				{
+					RT_SET_ASIC_WCID SetAsicWcid;
+					USHORT offset;
+					UINT32 MACValue, MACRValue = 0;
+					SetAsicWcid =
+					    *((PRT_SET_ASIC_WCID) (pData));
+
+					if (SetAsicWcid.WCID >=
+					    MAX_LEN_OF_MAC_TABLE)
+						return;
+
+					offset =
+					    MAC_WCID_BASE +
+					    ((UCHAR) SetAsicWcid.WCID) *
+					    HW_WCID_ENTRY_SIZE;
+
+					DBGPRINT_RAW(RT_DEBUG_TRACE,
+						     ("CmdThread : CMDTHREAD_SET_ASIC_WCID : WCID = %ld, SetTid  = %lx, DeleteTid = %lx.\n",
+						      SetAsicWcid.WCID,
+						      SetAsicWcid.SetTid,
+						      SetAsicWcid.DeleteTid));
+					MACValue =
+					    (pAd->MacTab.
+					     Content[SetAsicWcid.WCID].
+					     Addr[3] << 24) +
+					    (pAd->MacTab.
+					     Content[SetAsicWcid.WCID].
+					     Addr[2] << 16) +
+					    (pAd->MacTab.
+					     Content[SetAsicWcid.WCID].
+					     Addr[1] << 8) +
+					    (pAd->MacTab.
+					     Content[SetAsicWcid.WCID].Addr[0]);
+					DBGPRINT_RAW(RT_DEBUG_TRACE,
+						     ("1-MACValue= %x,\n",
+						      MACValue));
+					RTUSBWriteMACRegister(pAd, offset,
+							      MACValue);
+					// Read bitmask
+					RTUSBReadMACRegister(pAd, offset + 4,
+							     &MACRValue);
+					if (SetAsicWcid.DeleteTid != 0xffffffff)
+						MACRValue &=
+						    (~SetAsicWcid.DeleteTid);
+					if (SetAsicWcid.SetTid != 0xffffffff)
+						MACRValue |=
+						    (SetAsicWcid.SetTid);
+					MACRValue &= 0xffff0000;
+
+					MACValue =
+					    (pAd->MacTab.
+					     Content[SetAsicWcid.WCID].
+					     Addr[5] << 8) +
+					    pAd->MacTab.Content[SetAsicWcid.
+								WCID].Addr[4];
+					MACValue |= MACRValue;
+					RTUSBWriteMACRegister(pAd, offset + 4,
+							      MACValue);
+
+					DBGPRINT_RAW(RT_DEBUG_TRACE,
+						     ("2-MACValue= %x,\n",
+						      MACValue));
+				}
+				break;
+
+			case CMDTHREAD_SET_ASIC_WCID_CIPHER:
+				{
+					RT_SET_ASIC_WCID_ATTRI SetAsicWcidAttri;
+					USHORT offset;
+					UINT32 MACRValue = 0;
+					SHAREDKEY_MODE_STRUC csr1;
+					SetAsicWcidAttri =
+					    *((PRT_SET_ASIC_WCID_ATTRI)
+					      (pData));
+
+					if (SetAsicWcidAttri.WCID >=
+					    MAX_LEN_OF_MAC_TABLE)
+						return;
+
+					offset =
+					    MAC_WCID_ATTRIBUTE_BASE +
+					    ((UCHAR) SetAsicWcidAttri.WCID) *
+					    HW_WCID_ATTRI_SIZE;
+
+					DBGPRINT_RAW(RT_DEBUG_TRACE,
+						     ("Cmd : CMDTHREAD_SET_ASIC_WCID_CIPHER : WCID = %ld, Cipher = %lx.\n",
+						      SetAsicWcidAttri.WCID,
+						      SetAsicWcidAttri.Cipher));
+					// Read bitmask
+					RTUSBReadMACRegister(pAd, offset,
+							     &MACRValue);
+					MACRValue = 0;
+					MACRValue |=
+					    (((UCHAR) SetAsicWcidAttri.
+					      Cipher) << 1);
+
+					RTUSBWriteMACRegister(pAd, offset,
+							      MACRValue);
+					DBGPRINT_RAW(RT_DEBUG_TRACE,
+						     ("2-offset = %x , MACValue= %x,\n",
+						      offset, MACRValue));
+
+					offset =
+					    PAIRWISE_IVEIV_TABLE_BASE +
+					    ((UCHAR) SetAsicWcidAttri.WCID) *
+					    HW_IVEIV_ENTRY_SIZE;
+					MACRValue = 0;
+					if ((SetAsicWcidAttri.Cipher <=
+					     CIPHER_WEP128))
+						MACRValue |=
+						    (pAd->StaCfg.
+						     DefaultKeyId << 30);
+					else
+						MACRValue |= (0x20000000);
+					RTUSBWriteMACRegister(pAd, offset,
+							      MACRValue);
+					DBGPRINT_RAW(RT_DEBUG_TRACE,
+						     ("2-offset = %x , MACValue= %x,\n",
+						      offset, MACRValue));
+
+					//
+					// Update cipher algorithm. WSTA always use BSS0
+					//
+					// for adhoc mode only ,because wep status slow than add key, when use zero config
+					if (pAd->StaCfg.BssType == BSS_ADHOC) {
+						offset =
+						    MAC_WCID_ATTRIBUTE_BASE;
+
+						RTUSBReadMACRegister(pAd,
+								     offset,
+								     &MACRValue);
+						MACRValue &= (~0xe);
+						MACRValue |=
+						    (((UCHAR) SetAsicWcidAttri.
+						      Cipher) << 1);
+
+						RTUSBWriteMACRegister(pAd,
+								      offset,
+								      MACRValue);
+
+						//Update group key cipher,,because wep status slow than add key, when use zero config
+						RTUSBReadMACRegister(pAd,
+								     SHARED_KEY_MODE_BASE
+								     +
+								     4 * (0 /
+									  2),
+								     &csr1.
+								     word);
+
+						csr1.field.Bss0Key0CipherAlg =
+						    SetAsicWcidAttri.Cipher;
+						csr1.field.Bss0Key1CipherAlg =
+						    SetAsicWcidAttri.Cipher;
+
+						RTUSBWriteMACRegister(pAd,
+								      SHARED_KEY_MODE_BASE
+								      +
+								      4 * (0 /
+									   2),
+								      csr1.
+								      word);
 					}
-					break;
-
-				case RT_CMD_SET_RX_WCID_TABLE: //General call for RTMPAddWcidAttributeEntry()
-					{
-						PMAC_TABLE_ENTRY pEntry ;
-						UCHAR KeyIdx = 0;
-						UCHAR CipherAlg = CIPHER_NONE;
-						UCHAR ApIdx = BSS0;
+				}
+				break;
 
-						pEntry = (PMAC_TABLE_ENTRY)(pData);
-
-
-
-						RTMPAddWcidAttributeEntry(
-										  pAd,
-										  ApIdx,
-										  KeyIdx,
-										  CipherAlg,
-													pEntry);
-					}
-					break;
+//Benson modified for USB interface, avoid in interrupt when write key, 20080724 -->
+			case RT_CMD_SET_KEY_TABLE:	//General call for AsicAddPairwiseKeyEntry()
+				{
+					RT_ADD_PAIRWISE_KEY_ENTRY KeyInfo;
+					KeyInfo =
+					    *((PRT_ADD_PAIRWISE_KEY_ENTRY)
+					      (pData));
+					AsicAddPairwiseKeyEntry(pAd,
+								KeyInfo.MacAddr,
+								(UCHAR) KeyInfo.
+								MacTabMatchWCID,
+								&KeyInfo.
+								CipherKey);
+				}
+				break;
+
+			case RT_CMD_SET_RX_WCID_TABLE:	//General call for RTMPAddWcidAttributeEntry()
+				{
+					PMAC_TABLE_ENTRY pEntry;
+					UCHAR KeyIdx = 0;
+					UCHAR CipherAlg = CIPHER_NONE;
+					UCHAR ApIdx = BSS0;
+
+					pEntry = (PMAC_TABLE_ENTRY) (pData);
+
+					RTMPAddWcidAttributeEntry(pAd,
+								  ApIdx,
+								  KeyIdx,
+								  CipherAlg,
+								  pEntry);
+				}
+				break;
 //Benson modified for USB interface, avoid in interrupt when write key, 20080724 <--
 
-				case CMDTHREAD_SET_CLIENT_MAC_ENTRY:
-					{
-						MAC_TABLE_ENTRY *pEntry;
-						pEntry = (MAC_TABLE_ENTRY *)pData;
+			case CMDTHREAD_SET_CLIENT_MAC_ENTRY:
+				{
+					MAC_TABLE_ENTRY *pEntry;
+					pEntry = (MAC_TABLE_ENTRY *) pData;
 
+					{
+						AsicRemovePairwiseKeyEntry(pAd,
+									   pEntry->
+									   apidx,
+									   (UCHAR)
+									   pEntry->
+									   Aid);
+						if ((pEntry->AuthMode <=
+						     Ndis802_11AuthModeAutoSwitch)
+						    && (pEntry->WepStatus ==
+							Ndis802_11Encryption1Enabled))
 						{
-							AsicRemovePairwiseKeyEntry(pAd, pEntry->apidx, (UCHAR)pEntry->Aid);
-							if ((pEntry->AuthMode <= Ndis802_11AuthModeAutoSwitch) && (pEntry->WepStatus == Ndis802_11Encryption1Enabled))
-							{
-								UINT32 uIV = 1;
-								PUCHAR  ptr;
+							UINT32 uIV = 1;
+							PUCHAR ptr;
 
-								ptr = (PUCHAR) &uIV;
-								*(ptr + 3) = (pAd->StaCfg.DefaultKeyId << 6);
-								AsicUpdateWCIDIVEIV(pAd, pEntry->Aid, uIV, 0);
-								AsicUpdateWCIDAttribute(pAd, pEntry->Aid, BSS0, pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg, FALSE);
-							}
-							else if (pEntry->AuthMode == Ndis802_11AuthModeWPANone)
-							{
-								UINT32 uIV = 1;
-								PUCHAR  ptr;
+							ptr = (PUCHAR) & uIV;
+							*(ptr + 3) =
+							    (pAd->StaCfg.
+							     DefaultKeyId << 6);
+							AsicUpdateWCIDIVEIV(pAd,
+									    pEntry->
+									    Aid,
+									    uIV,
+									    0);
+							AsicUpdateWCIDAttribute
+							    (pAd, pEntry->Aid,
+							     BSS0,
+							     pAd->
+							     SharedKey[BSS0]
+							     [pAd->StaCfg.
+							      DefaultKeyId].
+							     CipherAlg, FALSE);
+						} else if (pEntry->AuthMode ==
+							   Ndis802_11AuthModeWPANone)
+						{
+							UINT32 uIV = 1;
+							PUCHAR ptr;
 
-								ptr = (PUCHAR) &uIV;
-								*(ptr + 3) = (pAd->StaCfg.DefaultKeyId << 6);
-								AsicUpdateWCIDIVEIV(pAd, pEntry->Aid, uIV, 0);
-								AsicUpdateWCIDAttribute(pAd, pEntry->Aid, BSS0, pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg, FALSE);
-							}
-							else
-							{
-								//
-								// Other case, disable engine.
-								// Don't worry WPA key, we will add WPA Key after 4-Way handshaking.
-								//
-								USHORT   offset;
-								offset = MAC_WCID_ATTRIBUTE_BASE + (pEntry->Aid * HW_WCID_ATTRI_SIZE);
-								// RX_PKEY_MODE:0 for no security; RX_KEY_TAB:0 for shared key table; BSS_IDX:0
-								RTUSBWriteMACRegister(pAd, offset, 0);
-							}
+							ptr = (PUCHAR) & uIV;
+							*(ptr + 3) =
+							    (pAd->StaCfg.
+							     DefaultKeyId << 6);
+							AsicUpdateWCIDIVEIV(pAd,
+									    pEntry->
+									    Aid,
+									    uIV,
+									    0);
+							AsicUpdateWCIDAttribute
+							    (pAd, pEntry->Aid,
+							     BSS0,
+							     pAd->
+							     SharedKey[BSS0]
+							     [pAd->StaCfg.
+							      DefaultKeyId].
+							     CipherAlg, FALSE);
+						} else {
+							//
+							// Other case, disable engine.
+							// Don't worry WPA key, we will add WPA Key after 4-Way handshaking.
+							//
+							USHORT offset;
+							offset =
+							    MAC_WCID_ATTRIBUTE_BASE
+							    +
+							    (pEntry->Aid *
+							     HW_WCID_ATTRI_SIZE);
+							// RX_PKEY_MODE:0 for no security; RX_KEY_TAB:0 for shared key table; BSS_IDX:0
+							RTUSBWriteMACRegister
+							    (pAd, offset, 0);
 						}
-
-						AsicUpdateRxWCIDTable(pAd, pEntry->Aid, pEntry->Addr);
-						DBGPRINT(RT_DEBUG_TRACE, ("UpdateRxWCIDTable(): Aid=%d, Addr=%02x:%02x:%02x:%02x:%02x:%02x!\n", pEntry->Aid,
-								pEntry->Addr[0], pEntry->Addr[1], pEntry->Addr[2], pEntry->Addr[3], pEntry->Addr[4], pEntry->Addr[5]));
 					}
-					break;
+
+					AsicUpdateRxWCIDTable(pAd, pEntry->Aid,
+							      pEntry->Addr);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("UpdateRxWCIDTable(): Aid=%d, Addr=%02x:%02x:%02x:%02x:%02x:%02x!\n",
+						  pEntry->Aid, pEntry->Addr[0],
+						  pEntry->Addr[1],
+						  pEntry->Addr[2],
+						  pEntry->Addr[3],
+						  pEntry->Addr[4],
+						  pEntry->Addr[5]));
+				}
+				break;
 
 // add by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet
-				case CMDTHREAD_UPDATE_PROTECT:
-					{
-						AsicUpdateProtect(pAd, 0, (ALLN_SETPROTECT), TRUE, 0);
-					}
-					break;
+			case CMDTHREAD_UPDATE_PROTECT:
+				{
+					AsicUpdateProtect(pAd, 0,
+							  (ALLN_SETPROTECT),
+							  TRUE, 0);
+				}
+				break;
 // end johnli
 
-				case OID_802_11_ADD_WEP:
-					{
-						UINT	i;
-						UINT32	KeyIdx;
-						PNDIS_802_11_WEP	pWepKey;
-
-						DBGPRINT(RT_DEBUG_TRACE, ("CmdThread::OID_802_11_ADD_WEP  \n"));
+			case OID_802_11_ADD_WEP:
+				{
+					UINT i;
+					UINT32 KeyIdx;
+					PNDIS_802_11_WEP pWepKey;
+
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("CmdThread::OID_802_11_ADD_WEP  \n"));
+
+					pWepKey = (PNDIS_802_11_WEP) pData;
+					KeyIdx = pWepKey->KeyIndex & 0x0fffffff;
+
+					// it is a shared key
+					if ((KeyIdx >= 4)
+					    || ((pWepKey->KeyLength != 5)
+						&& (pWepKey->KeyLength !=
+						    13))) {
+						NdisStatus =
+						    NDIS_STATUS_INVALID_DATA;
+						DBGPRINT(RT_DEBUG_ERROR,
+							 ("CmdThread::OID_802_11_ADD_WEP, INVALID_DATA!!\n"));
+					} else {
+						UCHAR CipherAlg;
+						pAd->SharedKey[BSS0][KeyIdx].
+						    KeyLen =
+						    (UCHAR) pWepKey->KeyLength;
+						NdisMoveMemory(pAd->
+							       SharedKey[BSS0]
+							       [KeyIdx].Key,
+							       &pWepKey->
+							       KeyMaterial,
+							       pWepKey->
+							       KeyLength);
+						CipherAlg =
+						    (pAd->
+						     SharedKey[BSS0][KeyIdx].
+						     KeyLen ==
+						     5) ? CIPHER_WEP64 :
+						    CIPHER_WEP128;
 
-						pWepKey = (PNDIS_802_11_WEP)pData;
-						KeyIdx = pWepKey->KeyIndex & 0x0fffffff;
+						//
+						// Change the WEP cipher to CKIP cipher if CKIP KP on.
+						// Funk UI or Meetinghouse UI will add ckip key from this path.
+						//
 
-						// it is a shared key
-						if ((KeyIdx >= 4) || ((pWepKey->KeyLength != 5) && (pWepKey->KeyLength != 13)))
-						{
-							NdisStatus = NDIS_STATUS_INVALID_DATA;
-							DBGPRINT(RT_DEBUG_ERROR, ("CmdThread::OID_802_11_ADD_WEP, INVALID_DATA!!\n"));
+						if (pAd->OpMode == OPMODE_STA) {
+							pAd->MacTab.
+							    Content[BSSID_WCID].
+							    PairwiseKey.
+							    CipherAlg =
+							    pAd->
+							    SharedKey[BSS0]
+							    [KeyIdx].CipherAlg;
+							pAd->MacTab.
+							    Content[BSSID_WCID].
+							    PairwiseKey.KeyLen =
+							    pAd->
+							    SharedKey[BSS0]
+							    [KeyIdx].KeyLen;
 						}
-						else
-						{
-							UCHAR CipherAlg;
-							pAd->SharedKey[BSS0][KeyIdx].KeyLen = (UCHAR) pWepKey->KeyLength;
-							NdisMoveMemory(pAd->SharedKey[BSS0][KeyIdx].Key, &pWepKey->KeyMaterial, pWepKey->KeyLength);
-							CipherAlg = (pAd->SharedKey[BSS0][KeyIdx].KeyLen == 5)? CIPHER_WEP64 : CIPHER_WEP128;
-
-							//
-							// Change the WEP cipher to CKIP cipher if CKIP KP on.
-							// Funk UI or Meetinghouse UI will add ckip key from this path.
-							//
-
-							if (pAd->OpMode == OPMODE_STA)
-						 	{
-								pAd->MacTab.Content[BSSID_WCID].PairwiseKey.CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
-								pAd->MacTab.Content[BSSID_WCID].PairwiseKey.KeyLen = pAd->SharedKey[BSS0][KeyIdx].KeyLen;
-						 	}
-							pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CipherAlg;
-							if (pWepKey->KeyIndex & 0x80000000)
-							{
-								// Default key for tx (shared key)
-								UCHAR	IVEIV[8];
-								UINT32	WCIDAttri, Value;
-								USHORT	offset, offset2;
-								NdisZeroMemory(IVEIV, 8);
-								pAd->StaCfg.DefaultKeyId = (UCHAR) KeyIdx;
-								// Add BSSID to WCTable. because this is Tx wep key.
-								// WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:1=PAIRWISE KEY, BSSIdx is 0
-								WCIDAttri = (CipherAlg<<1)|SHAREDKEYTABLE;
-
-								offset = MAC_WCID_ATTRIBUTE_BASE + (BSSID_WCID* HW_WCID_ATTRI_SIZE);
-								RTUSBWriteMACRegister(pAd, offset, WCIDAttri);
-								// 1. IV/EIV
-								// Specify key index to find shared key.
-								IVEIV[3] = (UCHAR)(KeyIdx<< 6);	//WEP Eiv bit off. groupkey index is not 0
-								offset = PAIRWISE_IVEIV_TABLE_BASE + (BSS0Mcast_WCID * HW_IVEIV_ENTRY_SIZE);
-								offset2 = PAIRWISE_IVEIV_TABLE_BASE + (BSSID_WCID* HW_IVEIV_ENTRY_SIZE);
-								for (i=0; i<8;)
-								{
-									Value = IVEIV[i];
-									Value += (IVEIV[i+1]<<8);
-									Value += (IVEIV[i+2]<<16);
-									Value += (IVEIV[i+3]<<24);
-									RTUSBWriteMACRegister(pAd, offset+i, Value);
-									RTUSBWriteMACRegister(pAd, offset2+i, Value);
-									i+=4;
-								}
+						pAd->SharedKey[BSS0][KeyIdx].
+						    CipherAlg = CipherAlg;
+						if (pWepKey->
+						    KeyIndex & 0x80000000) {
+							// Default key for tx (shared key)
+							UCHAR IVEIV[8];
+							UINT32 WCIDAttri, Value;
+							USHORT offset, offset2;
+							NdisZeroMemory(IVEIV,
+								       8);
+							pAd->StaCfg.
+							    DefaultKeyId =
+							    (UCHAR) KeyIdx;
+							// Add BSSID to WCTable. because this is Tx wep key.
+							// WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:1=PAIRWISE KEY, BSSIdx is 0
+							WCIDAttri =
+							    (CipherAlg << 1) |
+							    SHAREDKEYTABLE;
+
+							offset =
+							    MAC_WCID_ATTRIBUTE_BASE
+							    +
+							    (BSSID_WCID *
+							     HW_WCID_ATTRI_SIZE);
+							RTUSBWriteMACRegister
+							    (pAd, offset,
+							     WCIDAttri);
+							// 1. IV/EIV
+							// Specify key index to find shared key.
+							IVEIV[3] = (UCHAR) (KeyIdx << 6);	//WEP Eiv bit off. groupkey index is not 0
+							offset =
+							    PAIRWISE_IVEIV_TABLE_BASE
+							    +
+							    (BSS0Mcast_WCID *
+							     HW_IVEIV_ENTRY_SIZE);
+							offset2 =
+							    PAIRWISE_IVEIV_TABLE_BASE
+							    +
+							    (BSSID_WCID *
+							     HW_IVEIV_ENTRY_SIZE);
+							for (i = 0; i < 8;) {
+								Value =
+								    IVEIV[i];
+								Value +=
+								    (IVEIV
+								     [i +
+								      1] << 8);
+								Value +=
+								    (IVEIV
+								     [i +
+								      2] << 16);
+								Value +=
+								    (IVEIV
+								     [i +
+								      3] << 24);
+								RTUSBWriteMACRegister
+								    (pAd,
+								     offset + i,
+								     Value);
+								RTUSBWriteMACRegister
+								    (pAd,
+								     offset2 +
+								     i, Value);
+								i += 4;
+							}
 
-								// 2. WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:use share key, BSSIdx is 0
-								WCIDAttri = (pAd->SharedKey[BSS0][KeyIdx].CipherAlg<<1)|SHAREDKEYTABLE;
-								offset = MAC_WCID_ATTRIBUTE_BASE + (BSS0Mcast_WCID* HW_WCID_ATTRI_SIZE);
-							        DBGPRINT(RT_DEBUG_TRACE, ("BSS0Mcast_WCID : offset = %x, WCIDAttri = %x\n", offset, WCIDAttri));
-								RTUSBWriteMACRegister(pAd, offset, WCIDAttri);
+							// 2. WCID Attribute UDF:3, BSSIdx:3, Alg:3, Keytable:use share key, BSSIdx is 0
+							WCIDAttri =
+							    (pAd->
+							     SharedKey[BSS0]
+							     [KeyIdx].
+							     CipherAlg << 1) |
+							    SHAREDKEYTABLE;
+							offset =
+							    MAC_WCID_ATTRIBUTE_BASE
+							    +
+							    (BSS0Mcast_WCID *
+							     HW_WCID_ATTRI_SIZE);
+							DBGPRINT(RT_DEBUG_TRACE,
+								 ("BSS0Mcast_WCID : offset = %x, WCIDAttri = %x\n",
+								  offset,
+								  WCIDAttri));
+							RTUSBWriteMACRegister
+							    (pAd, offset,
+							     WCIDAttri);
 
-							}
-							AsicAddSharedKeyEntry(pAd, BSS0, (UCHAR)KeyIdx, CipherAlg, pWepKey->KeyMaterial, NULL, NULL);
-							DBGPRINT(RT_DEBUG_TRACE, ("CmdThread::OID_802_11_ADD_WEP (KeyIdx=%d, Len=%d-byte)\n", KeyIdx, pWepKey->KeyLength));
 						}
+						AsicAddSharedKeyEntry(pAd, BSS0,
+								      (UCHAR)
+								      KeyIdx,
+								      CipherAlg,
+								      pWepKey->
+								      KeyMaterial,
+								      NULL,
+								      NULL);
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("CmdThread::OID_802_11_ADD_WEP (KeyIdx=%d, Len=%d-byte)\n",
+							  KeyIdx,
+							  pWepKey->KeyLength));
 					}
-					break;
-
-				case CMDTHREAD_802_11_COUNTER_MEASURE:
-					break;
-
-				case CMDTHREAD_SET_GROUP_KEY:
-						WpaStaGroupKeySetting(pAd);
-					break;
+				}
+				break;
 
-				case CMDTHREAD_SET_PAIRWISE_KEY:
-						WpaStaPairwiseKeySetting(pAd);
-					break;
+			case CMDTHREAD_802_11_COUNTER_MEASURE:
+				break;
 
-				case CMDTHREAD_SET_PSM_BIT:
-					{
-						USHORT *pPsm = (USHORT *)pData;
-						MlmeSetPsmBit(pAd, *pPsm);
-					}
-					break;
-				case CMDTHREAD_FORCE_WAKE_UP:
-						AsicForceWakeup(pAd, TRUE);
-					break;
-
-				default:
-					DBGPRINT(RT_DEBUG_ERROR, ("--> Control Thread !! ERROR !! Unknown(cmdqelmt->command=0x%x) !! \n", cmdqelmt->command));
-					break;
+			case CMDTHREAD_SET_GROUP_KEY:
+				WpaStaGroupKeySetting(pAd);
+				break;
+
+			case CMDTHREAD_SET_PAIRWISE_KEY:
+				WpaStaPairwiseKeySetting(pAd);
+				break;
+
+			case CMDTHREAD_SET_PSM_BIT:
+				{
+					USHORT *pPsm = (USHORT *) pData;
+					MlmeSetPsmBit(pAd, *pPsm);
+				}
+				break;
+			case CMDTHREAD_FORCE_WAKE_UP:
+				AsicForceWakeup(pAd, TRUE);
+				break;
+
+			default:
+				DBGPRINT(RT_DEBUG_ERROR,
+					 ("--> Control Thread !! ERROR !! Unknown(cmdqelmt->command=0x%x) !! \n",
+					  cmdqelmt->command));
+				break;
 			}
 		}
 
-		if (cmdqelmt->CmdFromNdis == TRUE)
-		{
-				if (cmdqelmt->buffer != NULL)
+		if (cmdqelmt->CmdFromNdis == TRUE) {
+			if (cmdqelmt->buffer != NULL)
 				os_free_mem(pAd, cmdqelmt->buffer);
 			os_free_mem(pAd, cmdqelmt);
-		}
-		else
-		{
-			if ((cmdqelmt->buffer != NULL) && (cmdqelmt->bufferlength != 0))
+		} else {
+			if ((cmdqelmt->buffer != NULL)
+			    && (cmdqelmt->bufferlength != 0))
 				os_free_mem(pAd, cmdqelmt->buffer);
 			os_free_mem(pAd, cmdqelmt);
 		}
-	}	/* end of while */
+	}			/* end of while */
 }
 
 #endif // RTMP_MAC_USB //
