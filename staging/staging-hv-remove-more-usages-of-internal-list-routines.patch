From wfp5p@virginia.edu  Mon Sep 14 14:21:55 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Fri, 11 Sep 2009 21:46:44 -0400
Subject: Staging: hv: remove more usages of internal list routines
To: greg@kroah.com
Cc: hjanssen@microsoft.com
Message-ID: <1252720006-22052-3-git-send-email-wfp5p@virginia.edu>


The hv driver has it's own linked list routines.  This removes them
from more places in hv.

Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Cc: Hank Janssen <hjanssen@microsoft.com>
Cc: Haiyang Zhang <haiyangz@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/hv/Channel.c      |   34 +++++++++++++------------
 drivers/staging/hv/ChannelMgmt.c  |   50 +++++++++++++++-----------------------
 drivers/staging/hv/ChannelMgmt.h  |    8 +++---
 drivers/staging/hv/Connection.c   |   20 ++++++---------
 drivers/staging/hv/VmbusPrivate.h |    8 +++---
 5 files changed, 55 insertions(+), 65 deletions(-)

--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -247,8 +247,8 @@ int VmbusChannelOpen(struct vmbus_channe
 		memcpy(openMsg->UserData, UserData, UserDataLen);
 
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
-	INSERT_TAIL_LIST(&gVmbusConnection.ChannelMsgList,
-			 &openInfo->MsgListEntry);
+	list_add_tail(&openInfo->MsgListEntry,
+		      &gVmbusConnection.ChannelMsgList);
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_DBG(VMBUS, "Sending channel open msg...");
@@ -271,7 +271,7 @@ int VmbusChannelOpen(struct vmbus_channe
 
 Cleanup:
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
-	REMOVE_ENTRY_LIST(&openInfo->MsgListEntry);
+	list_del(&openInfo->MsgListEntry);
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	kfree(openInfo->WaitEvent);
@@ -362,7 +362,7 @@ static int VmbusChannelCreateGpadlHeader
 			  sizeof(struct gpa_range) + pfnCount * sizeof(u64);
 		msgHeader =  kzalloc(msgSize, GFP_KERNEL);
 
-		INITIALIZE_LIST_HEAD(&msgHeader->SubMsgList);
+		INIT_LIST_HEAD(&msgHeader->SubMsgList);
 		msgHeader->MessageSize = msgSize;
 
 		gpaHeader = (struct vmbus_channel_gpadl_header *)msgHeader->Msg;
@@ -411,8 +411,8 @@ static int VmbusChannelCreateGpadlHeader
 				gpadlBody->Pfn[i] = pfn + pfnSum + i;
 
 			/* add to msg header */
-			INSERT_TAIL_LIST(&msgHeader->SubMsgList,
-					 &msgBody->MsgListEntry);
+			list_add_tail(&msgBody->MsgListEntry,
+				      &msgHeader->SubMsgList);
 			pfnSum += pfnCurr;
 			pfnLeft -= pfnCurr;
 		}
@@ -457,8 +457,7 @@ int VmbusChannelEstablishGpadl(struct vm
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_msginfo *subMsgInfo;
 	u32 msgCount;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	u32 nextGpadlHandle;
 	unsigned long flags;
 	int ret;
@@ -481,10 +480,10 @@ int VmbusChannelEstablishGpadl(struct vm
 	DumpGpadlHeader(gpadlMsg);
 
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
-	INSERT_TAIL_LIST(&gVmbusConnection.ChannelMsgList,
-			 &msgInfo->MsgListEntry);
-	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
+	list_add_tail(&msgInfo->MsgListEntry,
+		      &gVmbusConnection.ChannelMsgList);
 
+	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 	DPRINT_DBG(VMBUS, "buffer %p, size %d msg cnt %d",
 		   Kbuffer, Size, msgCount);
 
@@ -499,7 +498,9 @@ int VmbusChannelEstablishGpadl(struct vm
 	}
 
 	if (msgCount > 1) {
-		ITERATE_LIST_ENTRIES(anchor, curr, &msgInfo->SubMsgList) {
+		list_for_each(curr, &msgInfo->SubMsgList) {
+
+			/* FIXME: should this use list_entry() instead ? */
 			subMsgInfo = (struct vmbus_channel_msginfo *)curr;
 			gpadlBody =
 			     (struct vmbus_channel_gpadl_body *)subMsgInfo->Msg;
@@ -532,7 +533,7 @@ int VmbusChannelEstablishGpadl(struct vm
 
 Cleanup:
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
-	REMOVE_ENTRY_LIST(&msgInfo->MsgListEntry);
+	list_del(&msgInfo->MsgListEntry);
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	kfree(msgInfo->WaitEvent);
@@ -570,7 +571,8 @@ int VmbusChannelTeardownGpadl(struct vmb
 	msg->Gpadl = GpadlHandle;
 
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
-	INSERT_TAIL_LIST(&gVmbusConnection.ChannelMsgList, &info->MsgListEntry);
+	list_add_tail(&info->MsgListEntry,
+		      &gVmbusConnection.ChannelMsgList);
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	ret = VmbusPostMessage(msg,
@@ -584,7 +586,7 @@ int VmbusChannelTeardownGpadl(struct vmb
 
 	/* Received a torndown response */
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
-	REMOVE_ENTRY_LIST(&info->MsgListEntry);
+	list_del(&info->MsgListEntry);
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	kfree(info->WaitEvent);
@@ -651,7 +653,7 @@ void VmbusChannelClose(struct vmbus_chan
 
 	if (Channel->State == CHANNEL_OPEN_STATE) {
 		spin_lock_irqsave(&gVmbusConnection.channel_lock, flags);
-		REMOVE_ENTRY_LIST(&Channel->ListEntry);
+		list_del(&Channel->ListEntry);
 		spin_unlock_irqrestore(&gVmbusConnection.channel_lock, flags);
 
 		FreeVmbusChannel(Channel);
--- a/drivers/staging/hv/ChannelMgmt.c
+++ b/drivers/staging/hv/ChannelMgmt.c
@@ -20,6 +20,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/list.h>
 #include "osd.h"
 #include "logging.h"
 #include "VmbusPrivate.h"
@@ -136,8 +137,6 @@ static void VmbusChannelProcessOffer(voi
 {
 	struct vmbus_channel *newChannel = context;
 	struct vmbus_channel *channel;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
 	bool fNew = true;
 	int ret;
 	unsigned long flags;
@@ -147,10 +146,7 @@ static void VmbusChannelProcessOffer(voi
 	/* Make sure this is a new offer */
 	spin_lock_irqsave(&gVmbusConnection.channel_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelList) {
-		channel = CONTAINING_RECORD(curr, struct vmbus_channel,
-					    ListEntry);
-
+	list_for_each_entry(channel, &gVmbusConnection.ChannelList, ListEntry) {
 		if (!memcmp(&channel->OfferMsg.Offer.InterfaceType,
 			    &newChannel->OfferMsg.Offer.InterfaceType,
 			    sizeof(struct hv_guid)) &&
@@ -163,8 +159,8 @@ static void VmbusChannelProcessOffer(voi
 	}
 
 	if (fNew)
-		INSERT_TAIL_LIST(&gVmbusConnection.ChannelList,
-				 &newChannel->ListEntry);
+		list_add_tail(&newChannel->ListEntry,
+			      &gVmbusConnection.ChannelList);
 
 	spin_unlock_irqrestore(&gVmbusConnection.channel_lock, flags);
 
@@ -201,7 +197,7 @@ static void VmbusChannelProcessOffer(voi
 			   newChannel->OfferMsg.ChildRelId);
 
 		spin_lock_irqsave(&gVmbusConnection.channel_lock, flags);
-		REMOVE_ENTRY_LIST(&newChannel->ListEntry);
+		list_del(&newChannel->ListEntry);
 		spin_unlock_irqrestore(&gVmbusConnection.channel_lock, flags);
 
 		FreeVmbusChannel(newChannel);
@@ -360,8 +356,7 @@ static void VmbusChannelOnOffersDelivere
 static void VmbusChannelOnOpenResult(struct vmbus_channel_message_header *hdr)
 {
 	struct vmbus_channel_open_result *result;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_message_header *requestHeader;
 	struct vmbus_channel_open_channel *openMsg;
@@ -377,7 +372,8 @@ static void VmbusChannelOnOpenResult(str
 	 */
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelMsgList) {
+	list_for_each(curr, &gVmbusConnection.ChannelMsgList) {
+/* FIXME: this should probably use list_entry() instead */
 		msgInfo = (struct vmbus_channel_msginfo *)curr;
 		requestHeader = (struct vmbus_channel_message_header *)msgInfo->Msg;
 
@@ -408,8 +404,7 @@ static void VmbusChannelOnOpenResult(str
 static void VmbusChannelOnGpadlCreated(struct vmbus_channel_message_header *hdr)
 {
 	struct vmbus_channel_gpadl_created *gpadlCreated;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_message_header *requestHeader;
 	struct vmbus_channel_gpadl_header *gpadlHeader;
@@ -427,7 +422,8 @@ static void VmbusChannelOnGpadlCreated(s
 	 */
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelMsgList) {
+	list_for_each(curr, &gVmbusConnection.ChannelMsgList) {
+/* FIXME: this should probably use list_entry() instead */
 		msgInfo = (struct vmbus_channel_msginfo *)curr;
 		requestHeader = (struct vmbus_channel_message_header *)msgInfo->Msg;
 
@@ -461,8 +457,7 @@ static void VmbusChannelOnGpadlTorndown(
 			struct vmbus_channel_message_header *hdr)
 {
 	struct vmbus_channel_gpadl_torndown *gpadlTorndown;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_message_header *requestHeader;
 	struct vmbus_channel_gpadl_teardown *gpadlTeardown;
@@ -477,7 +472,8 @@ static void VmbusChannelOnGpadlTorndown(
 	 */
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelMsgList) {
+	list_for_each(curr, &gVmbusConnection.ChannelMsgList) {
+/* FIXME: this should probably use list_entry() instead */
 		msgInfo = (struct vmbus_channel_msginfo *)curr;
 		requestHeader = (struct vmbus_channel_message_header *)msgInfo->Msg;
 
@@ -508,8 +504,7 @@ static void VmbusChannelOnGpadlTorndown(
 static void VmbusChannelOnVersionResponse(
 		struct vmbus_channel_message_header *hdr)
 {
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
+	struct list_head *curr;
 	struct vmbus_channel_msginfo *msgInfo;
 	struct vmbus_channel_message_header *requestHeader;
 	struct vmbus_channel_initiate_contact *initiate;
@@ -521,7 +516,8 @@ static void VmbusChannelOnVersionRespons
 	versionResponse = (struct vmbus_channel_version_response *)hdr;
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
-	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelMsgList) {
+	list_for_each(curr, &gVmbusConnection.ChannelMsgList) {
+/* FIXME: this should probably use list_entry() instead */
 		msgInfo = (struct vmbus_channel_msginfo *)curr;
 		requestHeader = (struct vmbus_channel_message_header *)msgInfo->Msg;
 
@@ -659,23 +655,19 @@ Cleanup:
  */
 void VmbusChannelReleaseUnattachedChannels(void)
 {
-	LIST_ENTRY *entry;
-	struct vmbus_channel *channel;
+	struct vmbus_channel *channel, *pos;
 	struct vmbus_channel *start = NULL;
 	unsigned long flags;
 
 	spin_lock_irqsave(&gVmbusConnection.channel_lock, flags);
 
-	while (!IsListEmpty(&gVmbusConnection.ChannelList)) {
-		entry = TOP_LIST_ENTRY(&gVmbusConnection.ChannelList);
-		channel = CONTAINING_RECORD(entry, struct vmbus_channel,
-					    ListEntry);
-
+	list_for_each_entry_safe(channel, pos, &gVmbusConnection.ChannelList,
+				 ListEntry) {
 		if (channel == start)
 			break;
 
 		if (!channel->DeviceObject->Driver) {
-			REMOVE_ENTRY_LIST(&channel->ListEntry);
+			list_del(&channel->ListEntry);
 			DPRINT_INFO(VMBUS,
 				    "Releasing unattached device object %p",
 				    channel->DeviceObject);
--- a/drivers/staging/hv/ChannelMgmt.h
+++ b/drivers/staging/hv/ChannelMgmt.h
@@ -25,7 +25,7 @@
 #ifndef _CHANNEL_MGMT_H_
 #define _CHANNEL_MGMT_H_
 
-#include "List.h"
+#include <linux/list.h>
 #include "RingBuffer.h"
 #include "VmbusChannelInterface.h"
 #include "VmbusPacketFormat.h"
@@ -225,7 +225,7 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel {
-	LIST_ENTRY ListEntry;
+	struct list_head ListEntry;
 
 	struct hv_device *DeviceObject;
 
@@ -281,10 +281,10 @@ struct vmbus_channel_debug_info {
  */
 struct vmbus_channel_msginfo {
 	/* Bookkeeping stuff */
-	LIST_ENTRY MsgListEntry;
+	struct list_head MsgListEntry;
 
 	/* So far, this is only used to handle gpadl body message */
-	LIST_ENTRY SubMsgList;
+	struct list_head SubMsgList;
 
 	/* Synchronize the request/response if needed */
 	struct osd_waitevent *WaitEvent;
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -57,10 +57,10 @@ int VmbusConnect(void)
 		goto Cleanup;
 	}
 
-	INITIALIZE_LIST_HEAD(&gVmbusConnection.ChannelMsgList);
+	INIT_LIST_HEAD(&gVmbusConnection.ChannelMsgList);
 	spin_lock_init(&gVmbusConnection.channelmsg_lock);
 
-	INITIALIZE_LIST_HEAD(&gVmbusConnection.ChannelList);
+	INIT_LIST_HEAD(&gVmbusConnection.ChannelList);
 	spin_lock_init(&gVmbusConnection.channel_lock);
 
 	/*
@@ -112,8 +112,9 @@ int VmbusConnect(void)
 	 * receive the response before returning from this routine
 	 */
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
-	INSERT_TAIL_LIST(&gVmbusConnection.ChannelMsgList,
-			 &msgInfo->MsgListEntry);
+	list_add_tail(&msgInfo->MsgListEntry,
+		      &gVmbusConnection.ChannelMsgList);
+
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
 
 	DPRINT_DBG(VMBUS, "Vmbus connection - interrupt pfn %llx, "
@@ -124,14 +125,14 @@ int VmbusConnect(void)
 	ret = VmbusPostMessage(msg,
 			       sizeof(struct vmbus_channel_initiate_contact));
 	if (ret != 0) {
-		REMOVE_ENTRY_LIST(&msgInfo->MsgListEntry);
+		list_del(&msgInfo->MsgListEntry);
 		goto Cleanup;
 	}
 
 	/* Wait for the connection response */
 	osd_WaitEventWait(msgInfo->WaitEvent);
 
-	REMOVE_ENTRY_LIST(&msgInfo->MsgListEntry);
+	list_del(&msgInfo->MsgListEntry);
 
 	/* Check if successful */
 	if (msgInfo->Response.VersionResponse.VersionSupported) {
@@ -223,15 +224,10 @@ struct vmbus_channel *GetChannelFromRelI
 {
 	struct vmbus_channel *channel;
 	struct vmbus_channel *foundChannel  = NULL;
-	LIST_ENTRY *anchor;
-	LIST_ENTRY *curr;
 	unsigned long flags;
 
 	spin_lock_irqsave(&gVmbusConnection.channel_lock, flags);
-	ITERATE_LIST_ENTRIES(anchor, curr, &gVmbusConnection.ChannelList) {
-		channel = CONTAINING_RECORD(curr, struct vmbus_channel,
-					    ListEntry);
-
+	list_for_each_entry(channel, &gVmbusConnection.ChannelList, ListEntry) {
 		if (channel->OfferMsg.ChildRelId == relId) {
 			foundChannel = channel;
 			break;
--- a/drivers/staging/hv/VmbusPrivate.h
+++ b/drivers/staging/hv/VmbusPrivate.h
@@ -31,7 +31,7 @@
 #include "ChannelMgmt.h"
 #include "ChannelInterface.h"
 #include "RingBuffer.h"
-#include "List.h"
+#include <linux/list.h>
 
 
 /*
@@ -76,11 +76,11 @@ struct VMBUS_CONNECTION {
 	 * is child->parent notification
 	 */
 	void *MonitorPages;
-	LIST_ENTRY ChannelMsgList;
+	struct list_head ChannelMsgList;
 	spinlock_t channelmsg_lock;
 
 	/* List of channels */
-	LIST_ENTRY ChannelList;
+	struct list_head ChannelList;
 	spinlock_t channel_lock;
 
 	struct workqueue_struct *WorkQueue;
@@ -89,7 +89,7 @@ struct VMBUS_CONNECTION {
 
 struct VMBUS_MSGINFO {
 	/* Bookkeeping stuff */
-	LIST_ENTRY MsgListEntry;
+	struct list_head MsgListEntry;
 
 	/* Synchronize the request/response if needed */
 	struct osd_waitevent *WaitEvent;
