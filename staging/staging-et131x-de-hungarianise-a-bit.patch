From alan@linux.intel.com  Thu Aug 27 14:25:55 2009
From: Alan Cox <alan@linux.intel.com>
Date: Thu, 27 Aug 2009 11:00:36 +0100
Subject: Staging: et131x: de-hungarianise a bit
To: greg@kroah.com
Message-ID: <20090827100029.23892.49067.stgit@localhost.localdomain>


bOverrideAddress is write only so kill it rather than fix it

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_eeprom.c  |  192 ++++++++++++-------------
 drivers/staging/et131x/et1310_mac.c     |   12 -
 drivers/staging/et131x/et1310_phy.c     |  244 ++++++++++++++++----------------
 drivers/staging/et131x/et1310_phy.h     |   12 -
 drivers/staging/et131x/et1310_rx.c      |  136 ++++++++---------
 drivers/staging/et131x/et1310_tx.c      |   92 ++++++------
 drivers/staging/et131x/et131x_adapter.h |   18 --
 drivers/staging/et131x/et131x_initpci.c |   70 ++++-----
 8 files changed, 380 insertions(+), 396 deletions(-)


--- a/drivers/staging/et131x/et1310_eeprom.c
+++ b/drivers/staging/et131x/et1310_eeprom.c
@@ -137,34 +137,34 @@
  * Define macros that allow individual register values to be extracted from a
  * DWORD1 register grouping
  */
-#define EXTRACT_DATA_REGISTER(x)    (uint8_t)(x & 0xFF)
-#define EXTRACT_STATUS_REGISTER(x)  (uint8_t)((x >> 16) & 0xFF)
-#define EXTRACT_CONTROL_REG(x)      (uint8_t)((x >> 8) & 0xFF)
+#define EXTRACT_DATA_REGISTER(x)    (u8)(x & 0xFF)
+#define EXTRACT_STATUS_REGISTER(x)  (u8)((x >> 16) & 0xFF)
+#define EXTRACT_CONTROL_REG(x)      (u8)((x >> 8) & 0xFF)
 
 /**
  * EepromWriteByte - Write a byte to the ET1310's EEPROM
  * @etdev: pointer to our private adapter structure
- * @unAddress: the address to write
- * @bData: the value to write
- * @unEepronId: the ID of the EEPROM
- * @unAddressingMode: how the EEPROM is to be accessed
+ * @addr: the address to write
+ * @data: the value to write
+ * @eeprom_id: the ID of the EEPROM
+ * @addrmode: how the EEPROM is to be accessed
  *
  * Returns SUCCESS or FAILURE
  */
-int32_t EepromWriteByte(struct et131x_adapter *etdev, uint32_t unAddress,
-			uint8_t bData, uint32_t unEepromId,
-			uint32_t unAddressingMode)
+int EepromWriteByte(struct et131x_adapter *etdev, u32 addr,
+			u8 data, u32 eeprom_id,
+			u32 addrmode)
 {
 	struct pci_dev *pdev = etdev->pdev;
-	int32_t nIndex;
-	int32_t nRetries;
-	int32_t nError = false;
-	int32_t nI2CWriteActive = 0;
-	int32_t nWriteSuccessful = 0;
-	uint8_t bControl;
-	uint8_t bStatus = 0;
-	uint32_t unDword1 = 0;
-	uint32_t unData = 0;
+	int index;
+	int retries;
+	int err = 0;
+	int i2c_wack = 0;
+	int writeok = 0;
+	u8 control;
+	u8 status = 0;
+	u32 dword1 = 0;
+	u32 val = 0;
 
 	/*
 	 * The following excerpt is from "Serial EEPROM HW Design
@@ -215,89 +215,89 @@ int32_t EepromWriteByte(struct et131x_ad
 	 */
 
 	/* Step 1: */
-	for (nIndex = 0; nIndex < MAX_NUM_REGISTER_POLLS; nIndex++) {
+	for (index = 0; index < MAX_NUM_REGISTER_POLLS; index++) {
 		/* Read registers grouped in DWORD1 */
 		if (pci_read_config_dword(pdev, LBCIF_DWORD1_GROUP_OFFSET,
-					  &unDword1)) {
-			nError = 1;
+					  &dword1)) {
+			err = 1;
 			break;
 		}
 
-		bStatus = EXTRACT_STATUS_REGISTER(unDword1);
+		status = EXTRACT_STATUS_REGISTER(dword1);
 
-		if (bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
-			bStatus & LBCIF_STATUS_I2C_IDLE)
+		if (status & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
+			status & LBCIF_STATUS_I2C_IDLE)
 			/* bits 1:0 are equal to 1 */
 			break;
 	}
 
-	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS))
+	if (err || (index >= MAX_NUM_REGISTER_POLLS))
 		return FAILURE;
 
 	/* Step 2: */
-	bControl = 0;
-	bControl |= LBCIF_CONTROL_LBCIF_ENABLE | LBCIF_CONTROL_I2C_WRITE;
+	control = 0;
+	control |= LBCIF_CONTROL_LBCIF_ENABLE | LBCIF_CONTROL_I2C_WRITE;
 
-	if (unAddressingMode == DUAL_BYTE)
-		bControl |= LBCIF_CONTROL_TWO_BYTE_ADDR;
+	if (addrmode == DUAL_BYTE)
+		control |= LBCIF_CONTROL_TWO_BYTE_ADDR;
 
 	if (pci_write_config_byte(pdev, LBCIF_CONTROL_REGISTER_OFFSET,
-				  bControl)) {
+				  control)) {
 		return FAILURE;
 	}
 
-	nI2CWriteActive = 1;
+	i2c_wack = 1;
 
 	/* Prepare EEPROM address for Step 3 */
-	unAddress |= (unAddressingMode == DUAL_BYTE) ?
-	    (unEepromId << 16) : (unEepromId << 8);
+	addr |= (addrmode == DUAL_BYTE) ?
+	    (eeprom_id << 16) : (eeprom_id << 8);
 
-	for (nRetries = 0; nRetries < MAX_NUM_WRITE_RETRIES; nRetries++) {
+	for (retries = 0; retries < MAX_NUM_WRITE_RETRIES; retries++) {
 		/* Step 3:*/
 		if (pci_write_config_dword(pdev, LBCIF_ADDRESS_REGISTER_OFFSET,
-					   unAddress)) {
+					   addr)) {
 			break;
 		}
 
 		/* Step 4: */
 		if (pci_write_config_byte(pdev, LBCIF_DATA_REGISTER_OFFSET,
-					  bData)) {
+					  data)) {
 			break;
 		}
 
 		/* Step 5: */
-		for (nIndex = 0; nIndex < MAX_NUM_REGISTER_POLLS; nIndex++) {
+		for (index = 0; index < MAX_NUM_REGISTER_POLLS; index++) {
 			/* Read registers grouped in DWORD1 */
 			if (pci_read_config_dword(pdev,
 						  LBCIF_DWORD1_GROUP_OFFSET,
-						  &unDword1)) {
-				nError = 1;
+						  &dword1)) {
+				err = 1;
 				break;
 			}
 
-			bStatus = EXTRACT_STATUS_REGISTER(unDword1);
+			status = EXTRACT_STATUS_REGISTER(dword1);
 
-			if (bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
-				bStatus & LBCIF_STATUS_I2C_IDLE) {
+			if (status & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
+				status & LBCIF_STATUS_I2C_IDLE) {
 				/* I2C write complete */
 				break;
 			}
 		}
 
-		if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS))
+		if (err || (index >= MAX_NUM_REGISTER_POLLS))
 			break;
 
 		/*
 		 * Step 6: Don't break here if we are revision 1, this is
 		 *	   so we do a blind write for load bug.
 		 */
-		if (bStatus & LBCIF_STATUS_GENERAL_ERROR
+		if (status & LBCIF_STATUS_GENERAL_ERROR
 		    && etdev->pdev->revision == 0) {
 			break;
 		}
 
 		/* Step 7 */
-		if (bStatus & LBCIF_STATUS_ACK_ERROR) {
+		if (status & LBCIF_STATUS_ACK_ERROR) {
 			/*
 			 * This could be due to an actual hardware failure
 			 * or the EEPROM may still be in its internal write
@@ -308,19 +308,19 @@ int32_t EepromWriteByte(struct et131x_ad
 			continue;
 		}
 
-		nWriteSuccessful = 1;
+		writeok = 1;
 		break;
 	}
 
 	/* Step 8: */
 	udelay(10);
-	nIndex = 0;
-	while (nI2CWriteActive) {
-		bControl &= ~LBCIF_CONTROL_I2C_WRITE;
+	index = 0;
+	while (i2c_wack) {
+		control &= ~LBCIF_CONTROL_I2C_WRITE;
 
 		if (pci_write_config_byte(pdev, LBCIF_CONTROL_REGISTER_OFFSET,
-					  bControl)) {
-			nWriteSuccessful = 0;
+					  control)) {
+			writeok = 0;
 		}
 
 		/* Do read until internal ACK_ERROR goes away meaning write
@@ -329,44 +329,44 @@ int32_t EepromWriteByte(struct et131x_ad
 		do {
 			pci_write_config_dword(pdev,
 					       LBCIF_ADDRESS_REGISTER_OFFSET,
-					       unAddress);
+					       addr);
 			do {
 				pci_read_config_dword(pdev,
-					LBCIF_DATA_REGISTER_OFFSET, &unData);
-			} while ((unData & 0x00010000) == 0);
-		} while (unData & 0x00040000);
+					LBCIF_DATA_REGISTER_OFFSET, &val);
+			} while ((val & 0x00010000) == 0);
+		} while (val & 0x00040000);
 
-		bControl = EXTRACT_CONTROL_REG(unData);
+		control = EXTRACT_CONTROL_REG(val);
 
-		if (bControl != 0xC0 || nIndex == 10000)
+		if (control != 0xC0 || index == 10000)
 			break;
 
-		nIndex++;
+		index++;
 	}
 
-	return nWriteSuccessful ? SUCCESS : FAILURE;
+	return writeok ? SUCCESS : FAILURE;
 }
 
 /**
  * EepromReadByte - Read a byte from the ET1310's EEPROM
  * @etdev: pointer to our private adapter structure
- * @unAddress: the address from which to read
- * @pbData: a pointer to a byte in which to store the value of the read
- * @unEepronId: the ID of the EEPROM
- * @unAddressingMode: how the EEPROM is to be accessed
+ * @addr: the address from which to read
+ * @pdata: a pointer to a byte in which to store the value of the read
+ * @eeprom_id: the ID of the EEPROM
+ * @addrmode: how the EEPROM is to be accessed
  *
  * Returns SUCCESS or FAILURE
  */
-int32_t EepromReadByte(struct et131x_adapter *etdev, uint32_t unAddress,
-		       uint8_t *pbData, uint32_t unEepromId,
-		       uint32_t unAddressingMode)
+int EepromReadByte(struct et131x_adapter *etdev, u32 addr,
+		       u8 *pdata, u32 eeprom_id,
+		       u32 addrmode)
 {
 	struct pci_dev *pdev = etdev->pdev;
-	int32_t nIndex;
-	int32_t nError = 0;
-	uint8_t bControl;
-	uint8_t bStatus = 0;
-	uint32_t unDword1 = 0;
+	int index;
+	int err = 0;
+	u8 control;
+	u8 status = 0;
+	u32 dword1 = 0;
 
 	/*
 	 * The following excerpt is from "Serial EEPROM HW Design
@@ -403,70 +403,70 @@ int32_t EepromReadByte(struct et131x_ada
 	 */
 
 	/* Step 1: */
-	for (nIndex = 0; nIndex < MAX_NUM_REGISTER_POLLS; nIndex++) {
+	for (index = 0; index < MAX_NUM_REGISTER_POLLS; index++) {
 		/* Read registers grouped in DWORD1 */
 		if (pci_read_config_dword(pdev, LBCIF_DWORD1_GROUP_OFFSET,
-					  &unDword1)) {
-			nError = 1;
+					  &dword1)) {
+			err = 1;
 			break;
 		}
 
-		bStatus = EXTRACT_STATUS_REGISTER(unDword1);
+		status = EXTRACT_STATUS_REGISTER(dword1);
 
-		if (bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
-		    bStatus & LBCIF_STATUS_I2C_IDLE) {
+		if (status & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
+		    status & LBCIF_STATUS_I2C_IDLE) {
 			/* bits 1:0 are equal to 1 */
 			break;
 		}
 	}
 
-	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS))
+	if (err || (index >= MAX_NUM_REGISTER_POLLS))
 		return FAILURE;
 
 	/* Step 2: */
-	bControl = 0;
-	bControl |= LBCIF_CONTROL_LBCIF_ENABLE;
+	control = 0;
+	control |= LBCIF_CONTROL_LBCIF_ENABLE;
 
-	if (unAddressingMode == DUAL_BYTE)
-		bControl |= LBCIF_CONTROL_TWO_BYTE_ADDR;
+	if (addrmode == DUAL_BYTE)
+		control |= LBCIF_CONTROL_TWO_BYTE_ADDR;
 
 	if (pci_write_config_byte(pdev, LBCIF_CONTROL_REGISTER_OFFSET,
-				  bControl)) {
+				  control)) {
 		return FAILURE;
 	}
 
 	/* Step 3: */
-	unAddress |= (unAddressingMode == DUAL_BYTE) ?
-	    (unEepromId << 16) : (unEepromId << 8);
+	addr |= (addrmode == DUAL_BYTE) ?
+	    (eeprom_id << 16) : (eeprom_id << 8);
 
 	if (pci_write_config_dword(pdev, LBCIF_ADDRESS_REGISTER_OFFSET,
-				   unAddress)) {
+				   addr)) {
 		return FAILURE;
 	}
 
 	/* Step 4: */
-	for (nIndex = 0; nIndex < MAX_NUM_REGISTER_POLLS; nIndex++) {
+	for (index = 0; index < MAX_NUM_REGISTER_POLLS; index++) {
 		/* Read registers grouped in DWORD1 */
 		if (pci_read_config_dword(pdev, LBCIF_DWORD1_GROUP_OFFSET,
-					  &unDword1)) {
-			nError = 1;
+					  &dword1)) {
+			err = 1;
 			break;
 		}
 
-		bStatus = EXTRACT_STATUS_REGISTER(unDword1);
+		status = EXTRACT_STATUS_REGISTER(dword1);
 
-		if (bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL
-		    && bStatus & LBCIF_STATUS_I2C_IDLE) {
+		if (status & LBCIF_STATUS_PHY_QUEUE_AVAIL
+		    && status & LBCIF_STATUS_I2C_IDLE) {
 			/* I2C read complete */
 			break;
 		}
 	}
 
-	if (nError || (nIndex >= MAX_NUM_REGISTER_POLLS))
+	if (err || (index >= MAX_NUM_REGISTER_POLLS))
 		return FAILURE;
 
 	/* Step 6: */
-	*pbData = EXTRACT_DATA_REGISTER(unDword1);
+	*pdata = EXTRACT_DATA_REGISTER(dword1);
 
-	return (bStatus & LBCIF_STATUS_ACK_ERROR) ? FAILURE : SUCCESS;
+	return (status & LBCIF_STATUS_ACK_ERROR) ? FAILURE : SUCCESS;
 }
--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -195,7 +195,7 @@ void ConfigMACRegs2(struct et131x_adapte
 	cfg2.value = readl(&pMac->cfg2.value);
 	ifctrl.value = readl(&pMac->if_ctrl.value);
 
-	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+	if (etdev->linkspeed == TRUEPHY_SPEED_1000MBPS) {
 		cfg2.bits.if_mode = 0x2;
 		ifctrl.bits.phy_mode = 0x0;
 	} else {
@@ -241,8 +241,8 @@ void ConfigMACRegs2(struct et131x_adapte
 	}
 
 	/* 1 - full duplex, 0 - half-duplex */
-	cfg2.bits.full_duplex = etdev->uiDuplexMode;
-	ifctrl.bits.ghd_mode = !etdev->uiDuplexMode;
+	cfg2.bits.full_duplex = etdev->duplex_mode;
+	ifctrl.bits.ghd_mode = !etdev->duplex_mode;
 
 	writel(ifctrl.value, &pMac->if_ctrl.value);
 	writel(cfg2.value, &pMac->cfg2.value);
@@ -262,7 +262,7 @@ void ConfigMACRegs2(struct et131x_adapte
 
 	DBG_TRACE(et131x_dbginfo,
 		"Speed %d, Dup %d, CFG1 0x%08x, CFG2 0x%08x, if_ctrl 0x%08x\n",
-		etdev->uiLinkSpeed, etdev->uiDuplexMode,
+		etdev->linkspeed, etdev->duplex_mode,
 		readl(&pMac->cfg1.value), readl(&pMac->cfg2.value),
 		readl(&pMac->if_ctrl.value));
 
@@ -408,7 +408,7 @@ void ConfigRxMacRegs(struct et131x_adapt
 	 * bit 16: Receive frame truncated.
 	 * bit 17: Drop packet enable
 	 */
-	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_100MBPS)
+	if (etdev->linkspeed == TRUEPHY_SPEED_100MBPS)
 		writel(0x30038, &pRxMac->mif_ctrl.value);
 	else
 		writel(0x30030, &pRxMac->mif_ctrl.value);
@@ -540,7 +540,7 @@ void ConfigMacStatRegs(struct et131x_ada
 
 void ConfigFlowControl(struct et131x_adapter *etdev)
 {
-	if (etdev->uiDuplexMode == 0) {
+	if (etdev->duplex_mode == 0) {
 		etdev->FlowControl = None;
 	} else {
 		char RemotePause, RemoteAsyncPause;
--- a/drivers/staging/et131x/et1310_phy.c
+++ b/drivers/staging/et131x/et1310_phy.c
@@ -477,13 +477,13 @@ static int et131x_xcvr_init(struct et131
 void et131x_Mii_check(struct et131x_adapter *etdev,
 		      MI_BMSR_t bmsr, MI_BMSR_t bmsr_ints)
 {
-	uint8_t ucLinkStatus;
-	uint32_t uiAutoNegStatus;
-	uint32_t uiSpeed;
-	uint32_t uiDuplex;
-	uint32_t uiMdiMdix;
-	uint32_t uiMasterSlave;
-	uint32_t uiPolarity;
+	uint8_t link_status;
+	uint32_t autoneg_status;
+	uint32_t speed;
+	uint32_t duplex;
+	uint32_t mdi_mdix;
+	uint32_t masterslave;
+	uint32_t polarity;
 	unsigned long flags;
 
 	DBG_ENTER(et131x_dbginfo);
@@ -509,7 +509,7 @@ void et131x_Mii_check(struct et131x_adap
 			DBG_WARNING(et131x_dbginfo,
 				    "Link down cable problem\n");
 
-			if (etdev->uiLinkSpeed == TRUEPHY_SPEED_10MBPS) {
+			if (etdev->linkspeed == TRUEPHY_SPEED_10MBPS) {
 				/* NOTE - Is there a way to query this without
 				 * TruePHY?
 				 * && TRU_QueryCoreType(etdev->hTruePhy, 0) == EMI_TRUEPHY_A13O) {
@@ -546,8 +546,8 @@ void et131x_Mii_check(struct et131x_adap
 					netif_carrier_off(etdev->netdev);
 			}
 
-			etdev->uiLinkSpeed = 0;
-			etdev->uiDuplexMode = 0;
+			etdev->linkspeed = 0;
+			etdev->duplexMode = 0;
 
 			/* Free the packets being actively sent & stopped */
 			et131x_free_busy_send_packets(etdev);
@@ -581,21 +581,21 @@ void et131x_Mii_check(struct et131x_adap
 	    (etdev->AiForceDpx == 3 && bmsr_ints.bits.link_status)) {
 		if (bmsr.bits.auto_neg_complete || etdev->AiForceDpx == 3) {
 			ET1310_PhyLinkStatus(etdev,
-					     &ucLinkStatus, &uiAutoNegStatus,
-					     &uiSpeed, &uiDuplex, &uiMdiMdix,
-					     &uiMasterSlave, &uiPolarity);
+					     &link_status, &autoneg_status,
+					     &speed, &duplex, &mdi_mdix,
+					     &masterslave, &polarity);
 
-			etdev->uiLinkSpeed = uiSpeed;
-			etdev->uiDuplexMode = uiDuplex;
+			etdev->linkspeed = speed;
+			etdev->duplex_mode = duplex;
 
 			DBG_TRACE(et131x_dbginfo,
-				"etdev->uiLinkSpeed 0x%04x, etdev->uiDuplex 0x%08x\n",
-				etdev->uiLinkSpeed,
-				etdev->uiDuplexMode);
+				"etdev->linkspeed 0x%04x, etdev->duplex_mode 0x%08x\n",
+				etdev->linkspeed,
+				etdev->duplex_mode);
 
 			etdev->PoMgmt.TransPhyComaModeOnBoot = 20;
 
-			if (etdev->uiLinkSpeed == TRUEPHY_SPEED_10MBPS) {
+			if (etdev->linkspeed == TRUEPHY_SPEED_10MBPS) {
 				/*
 				 * NOTE - Is there a way to query this without
 				 * TruePHY?
@@ -612,7 +612,7 @@ void et131x_Mii_check(struct et131x_adap
 
 			ConfigFlowControl(etdev);
 
-			if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS &&
+			if (etdev->linkspeed == TRUEPHY_SPEED_1000MBPS &&
 					etdev->RegistryJumboPacket > 2048)
 				ET1310_PhyAndOrReg(etdev, 0x16, 0xcfff,
 								   0x2000);
@@ -905,67 +905,67 @@ static const uint16_t ConfigPhy[25][2] =
 /* condensed version of the phy initialization routine */
 void ET1310_PhyInit(struct et131x_adapter *etdev)
 {
-	uint16_t usData, usIndex;
+	uint16_t data, index;
 
 	if (etdev == NULL)
 		return;
 
 	/* get the identity (again ?) */
-	MiRead(etdev, PHY_ID_1, &usData);
-	MiRead(etdev, PHY_ID_2, &usData);
+	MiRead(etdev, PHY_ID_1, &data);
+	MiRead(etdev, PHY_ID_2, &data);
 
 	/* what does this do/achieve ? */
-	MiRead(etdev, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
+	MiRead(etdev, PHY_MPHY_CONTROL_REG, &data); /* should read 0002 */
 	MiWrite(etdev, PHY_MPHY_CONTROL_REG,	0x0006);
 
 	/* read modem register 0402, should I do something with the return
 	   data ? */
 	MiWrite(etdev, PHY_INDEX_REG, 0x0402);
-	MiRead(etdev, PHY_DATA_REG, &usData);
+	MiRead(etdev, PHY_DATA_REG, &data);
 
 	/* what does this do/achieve ? */
 	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0002);
 
 	/* get the identity (again ?) */
-	MiRead(etdev, PHY_ID_1, &usData);
-	MiRead(etdev, PHY_ID_2, &usData);
+	MiRead(etdev, PHY_ID_1, &data);
+	MiRead(etdev, PHY_ID_2, &data);
 
 	/* what does this achieve ? */
-	MiRead(etdev, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
+	MiRead(etdev, PHY_MPHY_CONTROL_REG, &data); /* should read 0002 */
 	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0006);
 
 	/* read modem register 0402, should I do something with
 	   the return data? */
 	MiWrite(etdev, PHY_INDEX_REG, 0x0402);
-	MiRead(etdev, PHY_DATA_REG, &usData);
+	MiRead(etdev, PHY_DATA_REG, &data);
 
 	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0002);
 
 	/* what does this achieve (should return 0x1040) */
-	MiRead(etdev, PHY_CONTROL, &usData);
-	MiRead(etdev, PHY_MPHY_CONTROL_REG, &usData); /* should read 0002 */
+	MiRead(etdev, PHY_CONTROL, &data);
+	MiRead(etdev, PHY_MPHY_CONTROL_REG, &data); /* should read 0002 */
 	MiWrite(etdev, PHY_CONTROL, 0x1840);
 
 	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0007);
 
 	/* here the writing of the array starts.... */
-	usIndex = 0;
-	while (ConfigPhy[usIndex][0] != 0x0000) {
+	index = 0;
+	while (ConfigPhy[index][0] != 0x0000) {
 		/* write value */
-		MiWrite(etdev, PHY_INDEX_REG, ConfigPhy[usIndex][0]);
-		MiWrite(etdev, PHY_DATA_REG, ConfigPhy[usIndex][1]);
+		MiWrite(etdev, PHY_INDEX_REG, ConfigPhy[index][0]);
+		MiWrite(etdev, PHY_DATA_REG, ConfigPhy[index][1]);
 
 		/* read it back */
-		MiWrite(etdev, PHY_INDEX_REG, ConfigPhy[usIndex][0]);
-		MiRead(etdev, PHY_DATA_REG, &usData);
+		MiWrite(etdev, PHY_INDEX_REG, ConfigPhy[index][0]);
+		MiRead(etdev, PHY_DATA_REG, &data);
 
 		/* do a check on the value read back ? */
-		usIndex++;
+		index++;
 	}
 	/* here the writing of the array ends... */
 
-	MiRead(etdev, PHY_CONTROL, &usData);		/* 0x1840 */
-	MiRead(etdev, PHY_MPHY_CONTROL_REG, &usData);/* should read 0007 */
+	MiRead(etdev, PHY_CONTROL, &data);		/* 0x1840 */
+	MiRead(etdev, PHY_MPHY_CONTROL_REG, &data);/* should read 0007 */
 	MiWrite(etdev, PHY_CONTROL, 0x1040);
 	MiWrite(etdev, PHY_MPHY_CONTROL_REG, 0x0002);
 }
@@ -977,64 +977,64 @@ void ET1310_PhyReset(struct et131x_adapt
 
 void ET1310_PhyPowerDown(struct et131x_adapter *etdev, bool down)
 {
-	uint16_t usData;
+	uint16_t data;
 
-	MiRead(etdev, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_CONTROL, &data);
 
 	if (down == false) {
 		/* Power UP */
-		usData &= ~0x0800;
-		MiWrite(etdev, PHY_CONTROL, usData);
+		data &= ~0x0800;
+		MiWrite(etdev, PHY_CONTROL, data);
 	} else {
 		/* Power DOWN */
-		usData |= 0x0800;
-		MiWrite(etdev, PHY_CONTROL, usData);
+		data |= 0x0800;
+		MiWrite(etdev, PHY_CONTROL, data);
 	}
 }
 
 void ET1310_PhyAutoNeg(struct et131x_adapter *etdev, bool enable)
 {
-	uint16_t usData;
+	uint16_t data;
 
-	MiRead(etdev, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_CONTROL, &data);
 
 	if (enable == true) {
 		/* Autonegotiation ON */
-		usData |= 0x1000;
-		MiWrite(etdev, PHY_CONTROL, usData);
+		data |= 0x1000;
+		MiWrite(etdev, PHY_CONTROL, data);
 	} else {
 		/* Autonegotiation OFF */
-		usData &= ~0x1000;
-		MiWrite(etdev, PHY_CONTROL, usData);
+		data &= ~0x1000;
+		MiWrite(etdev, PHY_CONTROL, data);
 	}
 }
 
 void ET1310_PhyDuplexMode(struct et131x_adapter *etdev, uint16_t duplex)
 {
-	uint16_t usData;
+	uint16_t data;
 
-	MiRead(etdev, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_CONTROL, &data);
 
 	if (duplex == TRUEPHY_DUPLEX_FULL) {
 		/* Set Full Duplex */
-		usData |= 0x100;
-		MiWrite(etdev, PHY_CONTROL, usData);
+		data |= 0x100;
+		MiWrite(etdev, PHY_CONTROL, data);
 	} else {
 		/* Set Half Duplex */
-		usData &= ~0x100;
-		MiWrite(etdev, PHY_CONTROL, usData);
+		data &= ~0x100;
+		MiWrite(etdev, PHY_CONTROL, data);
 	}
 }
 
 void ET1310_PhySpeedSelect(struct et131x_adapter *etdev, uint16_t speed)
 {
-	uint16_t usData;
+	uint16_t data;
 
 	/* Read the PHY control register */
-	MiRead(etdev, PHY_CONTROL, &usData);
+	MiRead(etdev, PHY_CONTROL, &data);
 
 	/* Clear all Speed settings (Bits 6, 13) */
-	usData &= ~0x2040;
+	data &= ~0x2040;
 
 	/* Reset the speed bits based on user selection */
 	switch (speed) {
@@ -1044,29 +1044,29 @@ void ET1310_PhySpeedSelect(struct et131x
 
 	case TRUEPHY_SPEED_100MBPS:
 		/* 100M == Set bit 13 */
-		usData |= 0x2000;
+		data |= 0x2000;
 		break;
 
 	case TRUEPHY_SPEED_1000MBPS:
 	default:
-		usData |= 0x0040;
+		data |= 0x0040;
 		break;
 	}
 
 	/* Write back the new speed */
-	MiWrite(etdev, PHY_CONTROL, usData);
+	MiWrite(etdev, PHY_CONTROL, data);
 }
 
 void ET1310_PhyAdvertise1000BaseT(struct et131x_adapter *etdev,
 				  uint16_t duplex)
 {
-	uint16_t usData;
+	uint16_t data;
 
 	/* Read the PHY 1000 Base-T Control Register */
-	MiRead(etdev, PHY_1000_CONTROL, &usData);
+	MiRead(etdev, PHY_1000_CONTROL, &data);
 
 	/* Clear Bits 8,9 */
-	usData &= ~0x0300;
+	data &= ~0x0300;
 
 	switch (duplex) {
 	case TRUEPHY_ADV_DUPLEX_NONE:
@@ -1075,34 +1075,34 @@ void ET1310_PhyAdvertise1000BaseT(struct
 
 	case TRUEPHY_ADV_DUPLEX_FULL:
 		/* Set Bit 9 */
-		usData |= 0x0200;
+		data |= 0x0200;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_HALF:
 		/* Set Bit 8 */
-		usData |= 0x0100;
+		data |= 0x0100;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_BOTH:
 	default:
-		usData |= 0x0300;
+		data |= 0x0300;
 		break;
 	}
 
 	/* Write back advertisement */
-	MiWrite(etdev, PHY_1000_CONTROL, usData);
+	MiWrite(etdev, PHY_1000_CONTROL, data);
 }
 
 void ET1310_PhyAdvertise100BaseT(struct et131x_adapter *etdev,
 				 uint16_t duplex)
 {
-	uint16_t usData;
+	uint16_t data;
 
 	/* Read the Autonegotiation Register (10/100) */
-	MiRead(etdev, PHY_AUTO_ADVERTISEMENT, &usData);
+	MiRead(etdev, PHY_AUTO_ADVERTISEMENT, &data);
 
 	/* Clear bits 7,8 */
-	usData &= ~0x0180;
+	data &= ~0x0180;
 
 	switch (duplex) {
 	case TRUEPHY_ADV_DUPLEX_NONE:
@@ -1111,35 +1111,35 @@ void ET1310_PhyAdvertise100BaseT(struct 
 
 	case TRUEPHY_ADV_DUPLEX_FULL:
 		/* Set Bit 8 */
-		usData |= 0x0100;
+		data |= 0x0100;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_HALF:
 		/* Set Bit 7 */
-		usData |= 0x0080;
+		data |= 0x0080;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_BOTH:
 	default:
 		/* Set Bits 7,8 */
-		usData |= 0x0180;
+		data |= 0x0180;
 		break;
 	}
 
 	/* Write back advertisement */
-	MiWrite(etdev, PHY_AUTO_ADVERTISEMENT, usData);
+	MiWrite(etdev, PHY_AUTO_ADVERTISEMENT, data);
 }
 
 void ET1310_PhyAdvertise10BaseT(struct et131x_adapter *etdev,
 				uint16_t duplex)
 {
-	uint16_t usData;
+	uint16_t data;
 
 	/* Read the Autonegotiation Register (10/100) */
-	MiRead(etdev, PHY_AUTO_ADVERTISEMENT, &usData);
+	MiRead(etdev, PHY_AUTO_ADVERTISEMENT, &data);
 
 	/* Clear bits 5,6 */
-	usData &= ~0x0060;
+	data &= ~0x0060;
 
 	switch (duplex) {
 	case TRUEPHY_ADV_DUPLEX_NONE:
@@ -1148,75 +1148,75 @@ void ET1310_PhyAdvertise10BaseT(struct e
 
 	case TRUEPHY_ADV_DUPLEX_FULL:
 		/* Set Bit 6 */
-		usData |= 0x0040;
+		data |= 0x0040;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_HALF:
 		/* Set Bit 5 */
-		usData |= 0x0020;
+		data |= 0x0020;
 		break;
 
 	case TRUEPHY_ADV_DUPLEX_BOTH:
 	default:
 		/* Set Bits 5,6 */
-		usData |= 0x0060;
+		data |= 0x0060;
 		break;
 	}
 
 	/* Write back advertisement */
-	MiWrite(etdev, PHY_AUTO_ADVERTISEMENT, usData);
+	MiWrite(etdev, PHY_AUTO_ADVERTISEMENT, data);
 }
 
 void ET1310_PhyLinkStatus(struct et131x_adapter *etdev,
-			  uint8_t *ucLinkStatus,
-			  uint32_t *uiAutoNeg,
-			  uint32_t *uiLinkSpeed,
-			  uint32_t *uiDuplexMode,
-			  uint32_t *uiMdiMdix,
-			  uint32_t *uiMasterSlave, uint32_t *uiPolarity)
-{
-	uint16_t usMiStatus = 0;
-	uint16_t us1000BaseT = 0;
-	uint16_t usVmiPhyStatus = 0;
-	uint16_t usControl = 0;
-
-	MiRead(etdev, PHY_STATUS, &usMiStatus);
-	MiRead(etdev, PHY_1000_STATUS, &us1000BaseT);
-	MiRead(etdev, PHY_PHY_STATUS, &usVmiPhyStatus);
-	MiRead(etdev, PHY_CONTROL, &usControl);
-
-	if (ucLinkStatus) {
-		*ucLinkStatus =
-		    (unsigned char)((usVmiPhyStatus & 0x0040) ? 1 : 0);
-	}
-
-	if (uiAutoNeg) {
-		*uiAutoNeg =
-		    (usControl & 0x1000) ? ((usVmiPhyStatus & 0x0020) ?
+			  uint8_t *link_status,
+			  uint32_t *autoneg,
+			  uint32_t *linkspeed,
+			  uint32_t *duplex_mode,
+			  uint32_t *mdi_mdix,
+			  uint32_t *masterslave, uint32_t *polarity)
+{
+	uint16_t mistatus = 0;
+	uint16_t is1000BaseT = 0;
+	uint16_t vmi_phystatus = 0;
+	uint16_t control = 0;
+
+	MiRead(etdev, PHY_STATUS, &mistatus);
+	MiRead(etdev, PHY_1000_STATUS, &is1000BaseT);
+	MiRead(etdev, PHY_PHY_STATUS, &vmi_phystatus);
+	MiRead(etdev, PHY_CONTROL, &control);
+
+	if (link_status) {
+		*link_status =
+		    (unsigned char)((vmi_phystatus & 0x0040) ? 1 : 0);
+	}
+
+	if (autoneg) {
+		*autoneg =
+		    (control & 0x1000) ? ((vmi_phystatus & 0x0020) ?
 					    TRUEPHY_ANEG_COMPLETE :
 					    TRUEPHY_ANEG_NOT_COMPLETE) :
 		    TRUEPHY_ANEG_DISABLED;
 	}
 
-	if (uiLinkSpeed)
-		*uiLinkSpeed = (usVmiPhyStatus & 0x0300) >> 8;
+	if (linkspeed)
+		*linkspeed = (vmi_phystatus & 0x0300) >> 8;
 
-	if (uiDuplexMode)
-		*uiDuplexMode = (usVmiPhyStatus & 0x0080) >> 7;
+	if (duplex_mode)
+		*duplex_mode = (vmi_phystatus & 0x0080) >> 7;
 
-	if (uiMdiMdix)
+	if (mdi_mdix)
 		/* NOTE: Need to complete this */
-		*uiMdiMdix = 0;
+		*mdi_mdix = 0;
 
-	if (uiMasterSlave) {
-		*uiMasterSlave =
-		    (us1000BaseT & 0x4000) ? TRUEPHY_CFG_MASTER :
+	if (masterslave) {
+		*masterslave =
+		    (is1000BaseT & 0x4000) ? TRUEPHY_CFG_MASTER :
 		    TRUEPHY_CFG_SLAVE;
 	}
 
-	if (uiPolarity) {
-		*uiPolarity =
-		    (usVmiPhyStatus & 0x0400) ? TRUEPHY_POLARITY_INVERTED :
+	if (polarity) {
+		*polarity =
+		    (vmi_phystatus & 0x0400) ? TRUEPHY_POLARITY_INVERTED :
 		    TRUEPHY_POLARITY_NORMAL;
 	}
 }
--- a/drivers/staging/et131x/et1310_phy.h
+++ b/drivers/staging/et131x/et1310_phy.h
@@ -895,12 +895,12 @@ void ET1310_PhyAdvertise100BaseT(struct 
 void ET1310_PhyAdvertise10BaseT(struct et131x_adapter *adapter,
 				u16 duplex);
 void ET1310_PhyLinkStatus(struct et131x_adapter *adapter,
-			  u8 *ucLinkStatus,
-			  u32 *uiAutoNeg,
-			  u32 *uiLinkSpeed,
-			  u32 *uiDuplexMode,
-			  u32 *uiMdiMdix,
-			  u32 *uiMasterSlave, u32 *uiPolarity);
+			  u8 *Link_status,
+			  u32 *autoneg,
+			  u32 *linkspeed,
+			  u32 *duplex_mode,
+			  u32 *mdi_mdix,
+			  u32 *masterslave, u32 *polarity);
 void ET1310_PhyAndOrReg(struct et131x_adapter *adapter,
 			u16 regnum, u16 andMask, u16 orMask);
 void ET1310_PhyAccessMiBit(struct et131x_adapter *adapter,
--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -680,10 +680,10 @@ void et131x_rfd_resources_free(struct et
  */
 void ConfigRxDmaRegs(struct et131x_adapter *etdev)
 {
-	struct _RXDMA_t __iomem *pRxDma = &etdev->regs->rxdma;
+	struct _RXDMA_t __iomem *rx_dma = &etdev->regs->rxdma;
 	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
-	PFBR_DESC_t pFbrEntry;
-	uint32_t iEntry;
+	PFBR_DESC_t fbr_entry;
+	uint32_t entry;
 	RXDMA_PSR_NUM_DES_t psr_num_des;
 	unsigned long flags;
 
@@ -700,8 +700,8 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	 * before storing the adjusted address.
 	 */
 	writel((uint32_t) (pRxLocal->RxStatusRealPA >> 32),
-	       &pRxDma->dma_wb_base_hi);
-	writel((uint32_t) pRxLocal->RxStatusRealPA, &pRxDma->dma_wb_base_lo);
+	       &rx_dma->dma_wb_base_hi);
+	writel((uint32_t) pRxLocal->RxStatusRealPA, &rx_dma->dma_wb_base_lo);
 
 	memset(pRxLocal->pRxStatusVa, 0, sizeof(RX_STATUS_BLOCK_t));
 
@@ -709,14 +709,14 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	 * 1310's registers
 	 */
 	writel((uint32_t) (pRxLocal->pPSRingRealPa >> 32),
-	       &pRxDma->psr_base_hi);
-	writel((uint32_t) pRxLocal->pPSRingRealPa, &pRxDma->psr_base_lo);
-	writel(pRxLocal->PsrNumEntries - 1, &pRxDma->psr_num_des.value);
-	writel(0, &pRxDma->psr_full_offset.value);
+	       &rx_dma->psr_base_hi);
+	writel((uint32_t) pRxLocal->pPSRingRealPa, &rx_dma->psr_base_lo);
+	writel(pRxLocal->PsrNumEntries - 1, &rx_dma->psr_num_des.value);
+	writel(0, &rx_dma->psr_full_offset.value);
 
-	psr_num_des.value = readl(&pRxDma->psr_num_des.value);
+	psr_num_des.value = readl(&rx_dma->psr_num_des.value);
 	writel((psr_num_des.bits.psr_ndes * LO_MARK_PERCENT_FOR_PSR) / 100,
-	       &pRxDma->psr_min_des.value);
+	       &rx_dma->psr_min_des.value);
 
 	spin_lock_irqsave(&etdev->RcvLock, flags);
 
@@ -725,27 +725,27 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	pRxLocal->local_psr_full.bits.psr_full_wrap = 0;
 
 	/* Now's the best time to initialize FBR1 contents */
-	pFbrEntry = (PFBR_DESC_t) pRxLocal->pFbr1RingVa;
-	for (iEntry = 0; iEntry < pRxLocal->Fbr1NumEntries; iEntry++) {
-		pFbrEntry->addr_hi = pRxLocal->Fbr[1]->PAHigh[iEntry];
-		pFbrEntry->addr_lo = pRxLocal->Fbr[1]->PALow[iEntry];
-		pFbrEntry->word2.bits.bi = iEntry;
-		pFbrEntry++;
+	fbr_entry = (PFBR_DESC_t) pRxLocal->pFbr1RingVa;
+	for (entry = 0; entry < pRxLocal->Fbr1NumEntries; entry++) {
+		fbr_entry->addr_hi = pRxLocal->Fbr[1]->PAHigh[entry];
+		fbr_entry->addr_lo = pRxLocal->Fbr[1]->PALow[entry];
+		fbr_entry->word2.bits.bi = entry;
+		fbr_entry++;
 	}
 
 	/* Set the address and parameters of Free buffer ring 1 (and 0 if
 	 * required) into the 1310's registers
 	 */
-	writel((uint32_t) (pRxLocal->Fbr1Realpa >> 32), &pRxDma->fbr1_base_hi);
-	writel((uint32_t) pRxLocal->Fbr1Realpa, &pRxDma->fbr1_base_lo);
-	writel(pRxLocal->Fbr1NumEntries - 1, &pRxDma->fbr1_num_des.value);
+	writel((uint32_t) (pRxLocal->Fbr1Realpa >> 32), &rx_dma->fbr1_base_hi);
+	writel((uint32_t) pRxLocal->Fbr1Realpa, &rx_dma->fbr1_base_lo);
+	writel(pRxLocal->Fbr1NumEntries - 1, &rx_dma->fbr1_num_des.value);
 
 	{
 		DMA10W_t fbr1_full = { 0 };
 
 		fbr1_full.bits.val = 0;
 		fbr1_full.bits.wrap = 1;
-		writel(fbr1_full.value, &pRxDma->fbr1_full_offset.value);
+		writel(fbr1_full.value, &rx_dma->fbr1_full_offset.value);
 	}
 
 	/* This variable tracks the free buffer ring 1 full position, so it
@@ -754,28 +754,28 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	pRxLocal->local_Fbr1_full.bits.val = 0;
 	pRxLocal->local_Fbr1_full.bits.wrap = 1;
 	writel(((pRxLocal->Fbr1NumEntries * LO_MARK_PERCENT_FOR_RX) / 100) - 1,
-	       &pRxDma->fbr1_min_des.value);
+	       &rx_dma->fbr1_min_des.value);
 
 #ifdef USE_FBR0
 	/* Now's the best time to initialize FBR0 contents */
-	pFbrEntry = (PFBR_DESC_t) pRxLocal->pFbr0RingVa;
-	for (iEntry = 0; iEntry < pRxLocal->Fbr0NumEntries; iEntry++) {
-		pFbrEntry->addr_hi = pRxLocal->Fbr[0]->PAHigh[iEntry];
-		pFbrEntry->addr_lo = pRxLocal->Fbr[0]->PALow[iEntry];
-		pFbrEntry->word2.bits.bi = iEntry;
-		pFbrEntry++;
+	fbr_entry = (PFBR_DESC_t) pRxLocal->pFbr0RingVa;
+	for (entry = 0; entry < pRxLocal->Fbr0NumEntries; entry++) {
+		fbr_entry->addr_hi = pRxLocal->Fbr[0]->PAHigh[entry];
+		fbr_entry->addr_lo = pRxLocal->Fbr[0]->PALow[entry];
+		fbr_entry->word2.bits.bi = entry;
+		fbr_entry++;
 	}
 
-	writel((uint32_t) (pRxLocal->Fbr0Realpa >> 32), &pRxDma->fbr0_base_hi);
-	writel((uint32_t) pRxLocal->Fbr0Realpa, &pRxDma->fbr0_base_lo);
-	writel(pRxLocal->Fbr0NumEntries - 1, &pRxDma->fbr0_num_des.value);
+	writel((uint32_t) (pRxLocal->Fbr0Realpa >> 32), &rx_dma->fbr0_base_hi);
+	writel((uint32_t) pRxLocal->Fbr0Realpa, &rx_dma->fbr0_base_lo);
+	writel(pRxLocal->Fbr0NumEntries - 1, &rx_dma->fbr0_num_des.value);
 
 	{
 		DMA10W_t fbr0_full = { 0 };
 
 		fbr0_full.bits.val = 0;
 		fbr0_full.bits.wrap = 1;
-		writel(fbr0_full.value, &pRxDma->fbr0_full_offset.value);
+		writel(fbr0_full.value, &rx_dma->fbr0_full_offset.value);
 	}
 
 	/* This variable tracks the free buffer ring 0 full position, so it
@@ -784,7 +784,7 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	pRxLocal->local_Fbr0_full.bits.val = 0;
 	pRxLocal->local_Fbr0_full.bits.wrap = 1;
 	writel(((pRxLocal->Fbr0NumEntries * LO_MARK_PERCENT_FOR_RX) / 100) - 1,
-	       &pRxDma->fbr0_min_des.value);
+	       &rx_dma->fbr0_min_des.value);
 #endif
 
 	/* Program the number of packets we will receive before generating an
@@ -792,14 +792,14 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	 * For version B silicon, this value gets updated once autoneg is
 	 *complete.
 	 */
-	writel(PARM_RX_NUM_BUFS_DEF, &pRxDma->num_pkt_done.value);
+	writel(PARM_RX_NUM_BUFS_DEF, &rx_dma->num_pkt_done.value);
 
 	/* The "time_done" is not working correctly to coalesce interrupts
 	 * after a given time period, but rather is giving us an interrupt
 	 * regardless of whether we have received packets.
 	 * This value gets updated once autoneg is complete.
 	 */
-	writel(PARM_RX_TIME_INT_DEF, &pRxDma->max_pkt_time.value);
+	writel(PARM_RX_TIME_INT_DEF, &rx_dma->max_pkt_time.value);
 
 	spin_unlock_irqrestore(&etdev->RcvLock, flags);
 
@@ -815,8 +815,8 @@ void SetRxDmaTimer(struct et131x_adapter
 	/* For version B silicon, we do not use the RxDMA timer for 10 and 100
 	 * Mbits/s line rates. We do not enable and RxDMA interrupt coalescing.
 	 */
-	if ((etdev->uiLinkSpeed == TRUEPHY_SPEED_100MBPS) ||
-	    (etdev->uiLinkSpeed == TRUEPHY_SPEED_10MBPS)) {
+	if ((etdev->linkspeed == TRUEPHY_SPEED_100MBPS) ||
+	    (etdev->linkspeed == TRUEPHY_SPEED_10MBPS)) {
 		writel(0, &etdev->regs->rxdma.max_pkt_time.value);
 		writel(1, &etdev->regs->rxdma.num_pkt_done.value);
 	}
@@ -1032,8 +1032,8 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 
 	spin_unlock_irqrestore(&etdev->RcvLock, flags);
 
-	pMpRfd->iBufferIndex = bufferIndex;
-	pMpRfd->iRingIndex = ringIndex;
+	pMpRfd->bufferindex = bufferIndex;
+	pMpRfd->ringindex = ringIndex;
 
 	/* In V1 silicon, there is a bug which screws up filtering of
 	 * runt packets.  Therefore runt packet filtering is disabled
@@ -1289,10 +1289,10 @@ void et131x_handle_recv_interrupt(struct
  */
 void nic_return_rfd(struct et131x_adapter *etdev, PMP_RFD pMpRfd)
 {
-	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
-	struct _RXDMA_t __iomem *pRxDma = &etdev->regs->rxdma;
-	uint16_t bi = pMpRfd->iBufferIndex;
-	uint8_t ri = pMpRfd->iRingIndex;
+	struct _rx_ring_t *rx_local = &etdev->RxRing;
+	struct _RXDMA_t __iomem *rx_dma = &etdev->regs->rxdma;
+	uint16_t bi = pMpRfd->bufferindex;
+	uint8_t ri = pMpRfd->ringindex;
 	unsigned long flags;
 
 	DBG_RX_ENTER(et131x_dbginfo);
@@ -1302,55 +1302,55 @@ void nic_return_rfd(struct et131x_adapte
 	 */
 	if (
 #ifdef USE_FBR0
-	    (ri == 0 && bi < pRxLocal->Fbr0NumEntries) ||
+	    (ri == 0 && bi < rx_local->Fbr0NumEntries) ||
 #endif
-	    (ri == 1 && bi < pRxLocal->Fbr1NumEntries)) {
+	    (ri == 1 && bi < rx_local->Fbr1NumEntries)) {
 		spin_lock_irqsave(&etdev->FbrLock, flags);
 
 		if (ri == 1) {
 			PFBR_DESC_t pNextDesc =
-			    (PFBR_DESC_t) (pRxLocal->pFbr1RingVa) +
-			    pRxLocal->local_Fbr1_full.bits.val;
+			    (PFBR_DESC_t) (rx_local->pFbr1RingVa) +
+			    rx_local->local_Fbr1_full.bits.val;
 
 			/* Handle the Free Buffer Ring advancement here. Write
 			 * the PA / Buffer Index for the returned buffer into
 			 * the oldest (next to be freed)FBR entry
 			 */
-			pNextDesc->addr_hi = pRxLocal->Fbr[1]->PAHigh[bi];
-			pNextDesc->addr_lo = pRxLocal->Fbr[1]->PALow[bi];
+			pNextDesc->addr_hi = rx_local->Fbr[1]->PAHigh[bi];
+			pNextDesc->addr_lo = rx_local->Fbr[1]->PALow[bi];
 			pNextDesc->word2.value = bi;
 
-			if (++pRxLocal->local_Fbr1_full.bits.val >
-			    (pRxLocal->Fbr1NumEntries - 1)) {
-				pRxLocal->local_Fbr1_full.bits.val = 0;
-				pRxLocal->local_Fbr1_full.bits.wrap ^= 1;
+			if (++rx_local->local_Fbr1_full.bits.val >
+			    (rx_local->Fbr1NumEntries - 1)) {
+				rx_local->local_Fbr1_full.bits.val = 0;
+				rx_local->local_Fbr1_full.bits.wrap ^= 1;
 			}
 
-			writel(pRxLocal->local_Fbr1_full.value,
-			       &pRxDma->fbr1_full_offset.value);
+			writel(rx_local->local_Fbr1_full.value,
+			       &rx_dma->fbr1_full_offset.value);
 		}
 #ifdef USE_FBR0
 		else {
 			PFBR_DESC_t pNextDesc =
-			    (PFBR_DESC_t) pRxLocal->pFbr0RingVa +
-			    pRxLocal->local_Fbr0_full.bits.val;
+			    (PFBR_DESC_t) rx_local->pFbr0RingVa +
+			    rx_local->local_Fbr0_full.bits.val;
 
 			/* Handle the Free Buffer Ring advancement here. Write
 			 * the PA / Buffer Index for the returned buffer into
 			 * the oldest (next to be freed) FBR entry
 			 */
-			pNextDesc->addr_hi = pRxLocal->Fbr[0]->PAHigh[bi];
-			pNextDesc->addr_lo = pRxLocal->Fbr[0]->PALow[bi];
+			pNextDesc->addr_hi = rx_local->Fbr[0]->PAHigh[bi];
+			pNextDesc->addr_lo = rx_local->Fbr[0]->PALow[bi];
 			pNextDesc->word2.value = bi;
 
-			if (++pRxLocal->local_Fbr0_full.bits.val >
-			    (pRxLocal->Fbr0NumEntries - 1)) {
-				pRxLocal->local_Fbr0_full.bits.val = 0;
-				pRxLocal->local_Fbr0_full.bits.wrap ^= 1;
+			if (++rx_local->local_Fbr0_full.bits.val >
+			    (rx_local->Fbr0NumEntries - 1)) {
+				rx_local->local_Fbr0_full.bits.val = 0;
+				rx_local->local_Fbr0_full.bits.wrap ^= 1;
 			}
 
-			writel(pRxLocal->local_Fbr0_full.value,
-			       &pRxDma->fbr0_full_offset.value);
+			writel(rx_local->local_Fbr0_full.value,
+			       &rx_dma->fbr0_full_offset.value);
 		}
 #endif
 		spin_unlock_irqrestore(&etdev->FbrLock, flags);
@@ -1363,10 +1363,10 @@ void nic_return_rfd(struct et131x_adapte
 	 * our list
 	 */
 	spin_lock_irqsave(&etdev->RcvLock, flags);
-	list_add_tail(&pMpRfd->list_node, &pRxLocal->RecvList);
-	pRxLocal->nReadyRecv++;
+	list_add_tail(&pMpRfd->list_node, &rx_local->RecvList);
+	rx_local->nReadyRecv++;
 	spin_unlock_irqrestore(&etdev->RcvLock, flags);
 
-	DBG_ASSERT(pRxLocal->nReadyRecv <= pRxLocal->NumRfd);
+	DBG_ASSERT(rx_local->nReadyRecv <= rx_local->NumRfd);
 	DBG_RX_LEAVE(et131x_dbginfo);
 }
--- a/drivers/staging/et131x/et1310_tx.c
+++ b/drivers/staging/et131x/et1310_tx.c
@@ -246,22 +246,22 @@ void et131x_tx_dma_memory_free(struct et
 
 /**
  * ConfigTxDmaRegs - Set up the tx dma section of the JAGCore.
- * @adapter: pointer to our private adapter structure
+ * @etdev: pointer to our private adapter structure
  */
 void ConfigTxDmaRegs(struct et131x_adapter *etdev)
 {
-	struct _TXDMA_t __iomem *pTxDma = &etdev->regs->txdma;
+	struct _TXDMA_t __iomem *txdma = &etdev->regs->txdma;
 
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Load the hardware with the start of the transmit descriptor ring. */
 	writel((uint32_t) (etdev->TxRing.pTxDescRingAdjustedPa >> 32),
-	       &pTxDma->pr_base_hi);
+	       &txdma->pr_base_hi);
 	writel((uint32_t) etdev->TxRing.pTxDescRingAdjustedPa,
-	       &pTxDma->pr_base_lo);
+	       &txdma->pr_base_lo);
 
 	/* Initialise the transmit DMA engine */
-	writel(NUM_DESC_PER_RING_TX - 1, &pTxDma->pr_num_des.value);
+	writel(NUM_DESC_PER_RING_TX - 1, &txdma->pr_num_des.value);
 
 	/* Load the completion writeback physical address
 	 *
@@ -270,12 +270,12 @@ void ConfigTxDmaRegs(struct et131x_adapt
 	 * are ever returned, make sure the high part is retrieved here before
 	 * storing the adjusted address.
 	 */
-	writel(0, &pTxDma->dma_wb_base_hi);
-	writel(etdev->TxRing.pTxStatusPa, &pTxDma->dma_wb_base_lo);
+	writel(0, &txdma->dma_wb_base_hi);
+	writel(etdev->TxRing.pTxStatusPa, &txdma->dma_wb_base_lo);
 
 	memset(etdev->TxRing.pTxStatusVa, 0, sizeof(TX_STATUS_BLOCK_t));
 
-	writel(0, &pTxDma->service_request.value);
+	writel(0, &txdma->service_request.value);
 	etdev->TxRing.txDmaReadyToSend.value = 0;
 
 	DBG_LEAVE(et131x_dbginfo);
@@ -461,7 +461,7 @@ static int et131x_send_packet(struct sk_
 {
 	int status = 0;
 	PMP_TCB pMpTcb = NULL;
-	uint16_t *pShBufVa;
+	uint16_t *shbufva;
 	unsigned long flags;
 
 	DBG_TX_ENTER(et131x_dbginfo);
@@ -506,12 +506,12 @@ static int et131x_send_packet(struct sk_
 	pMpTcb->Packet = skb;
 
 	if ((skb->data != NULL) && ((skb->len - skb->data_len) >= 6)) {
-		pShBufVa = (uint16_t *) skb->data;
+		shbufva = (uint16_t *) skb->data;
 
-		if ((pShBufVa[0] == 0xffff) &&
-		    (pShBufVa[1] == 0xffff) && (pShBufVa[2] == 0xffff)) {
+		if ((shbufva[0] == 0xffff) &&
+		    (shbufva[1] == 0xffff) && (shbufva[2] == 0xffff)) {
 			MP_SET_FLAG(pMpTcb, fMP_DEST_BROAD);
-		} else if ((pShBufVa[0] & 0x3) == 0x0001) {
+		} else if ((shbufva[0] & 0x3) == 0x0001) {
 			MP_SET_FLAG(pMpTcb, fMP_DEST_MULTI);
 		}
 	}
@@ -558,7 +558,7 @@ static int nic_send_packet(struct et131x
 	uint32_t loopIndex;
 	TX_DESC_ENTRY_t CurDesc[24];
 	uint32_t FragmentNumber = 0;
-	uint32_t iThisCopy, iRemainder;
+	uint32_t thiscopy, remainder;
 	struct sk_buff *pPacket = pMpTcb->Packet;
 	uint32_t FragListCount = skb_shinfo(pPacket)->nr_frags + 1;
 	struct skb_frag_struct *pFragList = &skb_shinfo(pPacket)->frags[0];
@@ -710,7 +710,7 @@ static int nic_send_packet(struct et131x
 		return -EIO;
 	}
 
-	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+	if (etdev->linkspeed == TRUEPHY_SPEED_1000MBPS) {
 		if (++etdev->TxRing.TxPacketsSinceLastinterrupt ==
 		    PARM_TX_NUM_BUFS_DEF) {
 			CurDesc[FragmentNumber - 1].word3.value = 0x5;
@@ -729,21 +729,21 @@ static int nic_send_packet(struct et131x
 
 	spin_lock_irqsave(&etdev->SendHWLock, flags);
 
-	iThisCopy =
+	thiscopy =
 	    NUM_DESC_PER_RING_TX - etdev->TxRing.txDmaReadyToSend.bits.val;
 
-	if (iThisCopy >= FragmentNumber) {
-		iRemainder = 0;
-		iThisCopy = FragmentNumber;
+	if (thiscopy >= FragmentNumber) {
+		remainder = 0;
+		thiscopy = FragmentNumber;
 	} else {
-		iRemainder = FragmentNumber - iThisCopy;
+		remainder = FragmentNumber - thiscopy;
 	}
 
 	memcpy(etdev->TxRing.pTxDescRingVa +
 	       etdev->TxRing.txDmaReadyToSend.bits.val, CurDesc,
-	       sizeof(TX_DESC_ENTRY_t) * iThisCopy);
+	       sizeof(TX_DESC_ENTRY_t) * thiscopy);
 
-	etdev->TxRing.txDmaReadyToSend.bits.val += iThisCopy;
+	etdev->TxRing.txDmaReadyToSend.bits.val += thiscopy;
 
 	if ((etdev->TxRing.txDmaReadyToSend.bits.val == 0) ||
 	    (etdev->TxRing.txDmaReadyToSend.bits.val ==
@@ -754,12 +754,12 @@ static int nic_send_packet(struct et131x
 			etdev->TxRing.txDmaReadyToSend.value = 0x400;
 	}
 
-	if (iRemainder) {
+	if (remainder) {
 		memcpy(etdev->TxRing.pTxDescRingVa,
-		       CurDesc + iThisCopy,
-		       sizeof(TX_DESC_ENTRY_t) * iRemainder);
+		       CurDesc + thiscopy,
+		       sizeof(TX_DESC_ENTRY_t) * remainder);
 
-		etdev->TxRing.txDmaReadyToSend.bits.val += iRemainder;
+		etdev->TxRing.txDmaReadyToSend.bits.val += remainder;
 	}
 
 	if (etdev->TxRing.txDmaReadyToSend.bits.val == 0) {
@@ -794,7 +794,7 @@ static int nic_send_packet(struct et131x
 	/* For Gig only, we use Tx Interrupt coalescing.  Enable the software
 	 * timer to wake us up if this packet isn't followed by N more.
 	 */
-	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+	if (etdev->linkspeed == TRUEPHY_SPEED_1000MBPS) {
 		writel(PARM_TX_TIME_INT_DEF * NANO_IN_A_MICRO,
 		       &etdev->regs->global.watchdog_timer);
 	}
@@ -824,7 +824,7 @@ static int nic_send_packet(struct et131x
 static int nic_send_packet(struct et131x_adapter *etdev, PMP_TCB pMpTcb)
 {
 	uint32_t loopIndex, fragIndex, loopEnd;
-	uint32_t iSplitFirstElement = 0;
+	uint32_t splitfirstelem = 0;
 	uint32_t SegmentSize = 0;
 	TX_DESC_ENTRY_t CurDesc;
 	TX_DESC_ENTRY_t *CurDescPostCopy = NULL;
@@ -857,21 +857,21 @@ static int nic_send_packet(struct et131x
 	DBG_TX(et131x_dbginfo,
 	       "pMpTcb->PacketLength: %d\n", pMpTcb->PacketLength);
 
-	if ((etdev->uiDuplexMode == 0)
+	if ((etdev->duplex_mode == 0)
 	    && (pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE)) {
 		DBG_TX(et131x_dbginfo,
 		       "HALF DUPLEX mode AND len < MIN_PKT_SIZE\n");
 		if ((FragListCount & 0x1) == 0) {
 			DBG_TX(et131x_dbginfo,
 			       "Even number of descs, split 1st elem\n");
-			iSplitFirstElement = 1;
+			splitfirstelem = 1;
 			/* SegmentSize = pFragList[0].size / 2; */
 			SegmentSize = (pPacket->len - pPacket->data_len) / 2;
 		}
 	} else if (FragListCount & 0x1) {
 		DBG_TX(et131x_dbginfo, "Odd number of descs, split 1st elem\n");
 
-		iSplitFirstElement = 1;
+		splitfirstelem = 1;
 		/* SegmentSize = pFragList[0].size / 2; */
 		SegmentSize = (pPacket->len - pPacket->data_len) / 2;
 	}
@@ -894,26 +894,26 @@ static int nic_send_packet(struct et131x
 		    etdev->TxRing.txDmaReadyToSend.bits.serv_req;
 	}
 
-	if ((FragListCount + iSplitFirstElement) > SlotsAvailable) {
+	if ((FragListCount + splitfirstelem) > SlotsAvailable) {
 		DBG_WARNING(et131x_dbginfo,
 			    "Not Enough Space in Tx Desc Ring\n");
 		spin_unlock_irqrestore(&etdev->SendHWLock, flags);
 		return -ENOMEM;
 	}
 
-	loopEnd = (FragListCount) + iSplitFirstElement;
+	loopEnd = (FragListCount) + splitfirstelem;
 	fragIndex = 0;
 
 	DBG_TX(et131x_dbginfo,
 	       "TCB           : 0x%p\n"
 	       "Packet (SKB)  : 0x%p\t Packet->len: %d\t Packet->data_len: %d\n"
-	       "FragListCount : %d\t iSplitFirstElement: %d\t loopEnd:%d\n",
+	       "FragListCount : %d\t splitfirstelem: %d\t loopEnd:%d\n",
 	       pMpTcb,
 	       pPacket, pPacket->len, pPacket->data_len,
-	       FragListCount, iSplitFirstElement, loopEnd);
+	       FragListCount, splitfirstelem, loopEnd);
 
 	for (loopIndex = 0; loopIndex < loopEnd; loopIndex++) {
-		if (loopIndex > iSplitFirstElement)
+		if (loopIndex > splitfirstelem)
 			fragIndex++;
 
 		DBG_TX(et131x_dbginfo,
@@ -945,7 +945,7 @@ static int nic_send_packet(struct et131x
 			CurDesc.word3.value = 0;
 
 			if (fragIndex == 0) {
-				if (iSplitFirstElement) {
+				if (splitfirstelem) {
 					DBG_TX(et131x_dbginfo,
 					       "Split first element: YES\n");
 
@@ -1055,13 +1055,13 @@ static int nic_send_packet(struct et131x
 			}
 
 			if ((loopIndex == (loopEnd - 1)) &&
-			    (etdev->uiDuplexMode ||
+			    (etdev->duplex_mode ||
 			     (pMpTcb->PacketLength >= NIC_MIN_PACKET_SIZE))) {
 				/* This is the Last descriptor of the packet */
 				DBG_TX(et131x_dbginfo,
 				       "THIS is our LAST descriptor\n");
 
-				if (etdev->uiLinkSpeed ==
+				if (etdev->linkspeed ==
 				    TRUEPHY_SPEED_1000MBPS) {
 					if (++etdev->TxRing.
 					    TxPacketsSinceLastinterrupt >=
@@ -1124,14 +1124,14 @@ static int nic_send_packet(struct et131x
 		}
 	}
 
-	if (etdev->uiDuplexMode == 0 &&
+	if (etdev->duplex_mode == 0 &&
 	    pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE) {
 		/* NOTE - Same 32/64-bit issue as above... */
 		CurDesc.DataBufferPtrHigh = 0x0;
 		CurDesc.DataBufferPtrLow = etdev->TxRing.pTxDummyBlkPa;
 		CurDesc.word2.value = 0;
 
-		if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+		if (etdev->linkspeed == TRUEPHY_SPEED_1000MBPS) {
 			if (++etdev->TxRing.TxPacketsSinceLastinterrupt >=
 			    PARM_TX_NUM_BUFS_DEF) {
 				CurDesc.word3.value = 0x5;
@@ -1212,7 +1212,7 @@ static int nic_send_packet(struct et131x
 	/* For Gig only, we use Tx Interrupt coalescing.  Enable the software
 	 * timer to wake us up if this packet isn't followed by N more.
 	 */
-	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
+	if (etdev->linkspeed == TRUEPHY_SPEED_1000MBPS) {
 		writel(PARM_TX_TIME_INT_DEF * NANO_IN_A_MICRO,
 		       &etdev->regs->global.watchdog_timer);
 	}
@@ -1339,7 +1339,7 @@ inline void et131x_free_send_packet(stru
 void et131x_free_busy_send_packets(struct et131x_adapter *etdev)
 {
 	PMP_TCB pMpTcb;
-	struct list_head *pEntry;
+	struct list_head *entry;
 	unsigned long flags;
 	uint32_t FreeCounter = 0;
 
@@ -1351,7 +1351,7 @@ void et131x_free_busy_send_packets(struc
 		etdev->TxRing.nWaitSend--;
 		spin_unlock_irqrestore(&etdev->SendWaitLock, flags);
 
-		pEntry = etdev->TxRing.SendWaitQueue.next;
+		entry = etdev->TxRing.SendWaitQueue.next;
 	}
 
 	etdev->TxRing.nWaitSend = 0;
@@ -1496,11 +1496,11 @@ static void et131x_check_send_wait_list(
 
 	while (!list_empty(&etdev->TxRing.SendWaitQueue) &&
 				MP_TCB_RESOURCES_AVAILABLE(etdev)) {
-		struct list_head *pEntry;
+		struct list_head *entry;
 
 		DBG_VERBOSE(et131x_dbginfo, "Tx packets on the wait queue\n");
 
-		pEntry = etdev->TxRing.SendWaitQueue.next;
+		entry = etdev->TxRing.SendWaitQueue.next;
 
 		etdev->TxRing.nWaitSend--;
 
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -133,8 +133,8 @@ typedef struct _MP_RFD {
 	struct list_head list_node;
 	struct sk_buff *Packet;
 	u32 PacketSize;	/* total size of receive frame */
-	u16 iBufferIndex;
-	u8 iRingIndex;
+	u16 bufferindex;
+	u8 ringindex;
 } MP_RFD, *PMP_RFD;
 
 /* Enum for Flow Control */
@@ -214,8 +214,7 @@ struct et131x_adapter {
 	/* Configuration  */
 	u8 PermanentAddress[ETH_ALEN];
 	u8 CurrentAddress[ETH_ALEN];
-	bool bOverrideAddress;
-	bool bEepromPresent;
+	bool has_eeprom;
 	u8 eepromData[2];
 
 	/* Spinlocks */
@@ -234,11 +233,8 @@ struct et131x_adapter {
 
 	/* Packet Filter and look ahead size */
 	u32 PacketFilter;
-	u32 ulLookAhead;
-	u32 uiLinkSpeed;
-	u32 uiDuplexMode;
-	u32 uiAutoNegStatus;
-	u8 ucLinkStatus;
+	u32 linkspeed;
+	u32 duplex_mode;
 
 	/* multicast list */
 	u32 MCAddressCount;
@@ -275,11 +271,7 @@ struct et131x_adapter {
 	u8 DriverNoPhyAccess;
 
 	/* Minimize init-time */
-	bool bQueryPending;
-	bool bSetPending;
-	bool bResetPending;
 	struct timer_list ErrorTimer;
-	bool bLinkTimerActive;
 	MP_POWER_MGMT PoMgmt;
 	INTERRUPT_t CachedMaskValue;
 
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -330,14 +330,14 @@ int et131x_find_adapter(struct et131x_ad
 			return -EIO;
 		} else if (rev == 0x01) {
 			int32_t nLoop;
-			uint8_t ucTemp[4] = { 0xFE, 0x13, 0x10, 0xFF };
+			uint8_t temp[4] = { 0xFE, 0x13, 0x10, 0xFF };
 
 			/* Re-write the first 4 bytes if we have an eeprom
 			 * present and the revision id is 1, this fixes the
 			 * corruption seen with 1310 B Silicon
 			 */
 			for (nLoop = 0; nLoop < 3; nLoop++) {
-				EepromWriteByte(adapter, nLoop, ucTemp[nLoop],
+				EepromWriteByte(adapter, nLoop, temp[nLoop],
 						0, SINGLE_BYTE);
 			}
 		}
@@ -351,14 +351,14 @@ int et131x_find_adapter(struct et131x_ad
 		 * information that normally would come from the eeprom, like
 		 * MAC Address
 		 */
-		adapter->bEepromPresent = false;
+		adapter->has_eeprom = 0;
 
 		DBG_LEAVE(et131x_dbginfo);
 		return -EIO;
 	} else {
 		DBG_TRACE(et131x_dbginfo, "EEPROM Status Code - 0x%04x\n",
 			  eepromStat);
-		adapter->bEepromPresent = true;
+		adapter->has_eeprom = 1;
 	}
 
 	/* Read the EEPROM for information regarding LED behavior. Refer to
@@ -445,7 +445,7 @@ int et131x_find_adapter(struct et131x_ad
 	/* Get MAC address from config space if an eeprom exists, otherwise
 	 * the MAC address there will not be valid
 	 */
-	if (adapter->bEepromPresent) {
+	if (adapter->has_eeprom) {
 		int i;
 
 		for (i = 0; i < ETH_ALEN; i++) {
@@ -520,9 +520,6 @@ void et131x_link_detection_handler(unsig
 	struct et131x_adapter *etdev = (struct et131x_adapter *) data;
 	unsigned long flags;
 
-	/* Let everyone know that we have run */
-	etdev->bLinkTimerActive = false;
-
 	if (etdev->MediaState == 0) {
 		spin_lock_irqsave(&etdev->Lock, flags);
 
@@ -532,8 +529,6 @@ void et131x_link_detection_handler(unsig
 		spin_unlock_irqrestore(&etdev->Lock, flags);
 
 		netif_carrier_off(etdev->netdev);
-
-		etdev->bSetPending = false;
 	}
 }
 
@@ -608,35 +603,32 @@ void et131x_setup_hardware_properties(st
 	 * EEPROM then we need to generate the last octet and set it on the
 	 * device
 	 */
-	if (!adapter->bOverrideAddress) {
-		if (adapter->PermanentAddress[0] == 0x00 &&
-		    adapter->PermanentAddress[1] == 0x00 &&
-		    adapter->PermanentAddress[2] == 0x00 &&
-		    adapter->PermanentAddress[3] == 0x00 &&
-		    adapter->PermanentAddress[4] == 0x00 &&
-		    adapter->PermanentAddress[5] == 0x00) {
-			/*
-			 * We need to randomly generate the last octet so we
-			 * decrease our chances of setting the mac address to
-			 * same as another one of our cards in the system
-			 */
-			get_random_bytes(&adapter->CurrentAddress[5], 1);
-
-			/*
-			 * We have the default value in the register we are
-			 * working with so we need to copy the current
-			 * address into the permanent address
-			 */
-			memcpy(adapter->PermanentAddress,
-			       adapter->CurrentAddress, ETH_ALEN);
-		} else {
-			/* We do not have an override address, so set the
-			 * current address to the permanent address and add
-			 * it to the device
-			 */
-			memcpy(adapter->CurrentAddress,
-			       adapter->PermanentAddress, ETH_ALEN);
-		}
+	if (adapter->PermanentAddress[0] == 0x00 &&
+	    adapter->PermanentAddress[1] == 0x00 &&
+	    adapter->PermanentAddress[2] == 0x00 &&
+	    adapter->PermanentAddress[3] == 0x00 &&
+	    adapter->PermanentAddress[4] == 0x00 &&
+	    adapter->PermanentAddress[5] == 0x00) {
+		/*
+		 * We need to randomly generate the last octet so we
+		 * decrease our chances of setting the mac address to
+		 * same as another one of our cards in the system
+		 */
+		get_random_bytes(&adapter->CurrentAddress[5], 1);
+		/*
+		 * We have the default value in the register we are
+		 * working with so we need to copy the current
+		 * address into the permanent address
+		 */
+		memcpy(adapter->PermanentAddress,
+			adapter->CurrentAddress, ETH_ALEN);
+	} else {
+		/* We do not have an override address, so set the
+		 * current address to the permanent address and add
+		 * it to the device
+		 */
+		memcpy(adapter->CurrentAddress,
+		       adapter->PermanentAddress, ETH_ALEN);
 	}
 
 	DBG_LEAVE(et131x_dbginfo);
