From mithlesh@linsyssoft.com  Tue Oct 27 11:22:55 2009
From: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date: Mon, 26 Oct 2009 21:22:55 -0700 (PDT)
Subject: Staging: otus : checkpatch.pl cleanup for some more .c files
To: Greg Kroah-Hartman <gregkh@suse.de>
Cc: devel@linuxdriverproject.org, Luis.Rodriguez@Atheros.com
Message-ID: <alpine.LFD.2.00.0910262122240.5305@localhost.localdomain>
Status: RO
X-Status: A
Content-Length: 41209
Lines: 1387


Second lot of checkpatch.pl error and warning fixes for .c files of
otus driver in staging tree.
(Externs would be removed in a seperate patch)

Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/otus/usbdrv.c   |   35 +---
 drivers/staging/otus/wrap_buf.c |   20 +-
 drivers/staging/otus/wrap_ev.c  |  348 ++++++++++++++++++++--------------------
 drivers/staging/otus/wrap_mis.c |   59 +++---
 drivers/staging/otus/wrap_pkt.c |  194 ++++++++++------------
 drivers/staging/otus/wrap_sec.c |  137 +++++++--------
 drivers/staging/otus/wrap_usb.c |  205 +++++++++++------------
 7 files changed, 495 insertions(+), 503 deletions(-)

--- a/drivers/staging/otus/usbdrv.c
+++ b/drivers/staging/otus/usbdrv.c
@@ -111,7 +111,7 @@ extern u8_t zfLnxCreateThread(zdev_t *de
 
 /* Definition of Wireless Extension */
 
-//wireless extension helper functions
+/* wireless extension helper functions */
 extern int usbdrv_ioctl_setessid(struct net_device *dev, struct iw_point *erq);
 extern int usbdrv_ioctl_setrts(struct net_device *dev, struct iw_param *rrq);
 /* Wireless Extension Handler functions */
@@ -282,8 +282,8 @@ static struct iw_handler_def p80211wext_
 };
 
 /* WDS */
-//struct zsWdsStruct wds[ZM_WDS_PORT_NUMBER];
-//void zfInitWdsStruct(void);
+/* struct zsWdsStruct wds[ZM_WDS_PORT_NUMBER]; */
+/* void zfInitWdsStruct(void);	*/
 
 /* VAP */
 struct zsVapStruct vap[ZM_VAP_PORT_NUMBER];
@@ -314,13 +314,11 @@ irqreturn_t usbdrv_intr(int irq, void *d
         return IRQ_NONE;
 
     /* the device is closed, don't continue or else bad things may happen. */
-    if (!netif_running(dev)) {
+    if (!netif_running(dev))
         return IRQ_NONE;
-    }
 
-    if (macp->driver_isolated) {
+    if (macp->driver_isolated)
         return IRQ_NONE;
-    }
 
 #if (WLAN_HOSTIF == WLAN_PCI)
     //zfiIsrPci(dev);
@@ -340,9 +338,11 @@ int usbdrv_open(struct net_device *dev)
 
     printk("Enter open()\n");
 
-//#ifndef CONFIG_SMP
-//    read_lock(&(macp->isolate_lock));
-//#endif
+/*
+ * #ifndef CONFIG_SMP
+ *   read_lock(&(macp->isolate_lock));
+ * #endif
+ */
     if (macp->driver_isolated) {
         rc = -EBUSY;
         goto exit;
@@ -393,11 +393,11 @@ int usbdrv_open(struct net_device *dev)
     dev->dev_addr[4] = addr[4];
     dev->dev_addr[5] = addr[5];
 #endif
-    //zfwMacAddressNotify() will be called to setup dev->dev_addr[]
+    /* zfwMacAddressNotify() will be called to setup dev->dev_addr[] */
 
     zfLnxCreateThread(dev);
 
-    mod_timer(&(macp->hbTimer10ms), jiffies + (1*HZ)/100);   //10 ms
+    mod_timer(&(macp->hbTimer10ms), jiffies + (1*HZ)/100);   /* 10 ms */
 
     netif_carrier_on(dev);
 
@@ -425,15 +425,15 @@ int usbdrv_open(struct net_device *dev)
 
     #if ZM_SHARE_AUTH == 1
     zfiWlanSetAuthenticationMode(dev, 1);
-    #endif //#if ZM_SHARE_AUTH == 1
-  #endif //#if ZM_WEP_MOME == 1
+    #endif /* #if ZM_SHARE_AUTH == 1 */
+  #endif /* #if ZM_WEP_MOME == 1 */
 
 #elif ZM_PIBSS_MODE == 1
     zfiWlanSetWlanMode(dev, ZM_MODE_PSEUDO);
 #else
     zfiWlanSetWlanMode(dev, ZM_MODE_INFRASTRUCTURE);
 #endif
-    //zfiWlanSetChannel(dev, ZM_CHANNEL, FALSE);
+    /* zfiWlanSetChannel(dev, ZM_CHANNEL, FALSE); */
     zfiWlanSetFrequency(dev, 2462000, FALSE);
     zfiWlanSetRtsThreshold(dev, 32767);
     zfiWlanSetFragThreshold(dev, 0);
@@ -720,7 +720,7 @@ void zfLnxInitVapStruct(void)
 {
     u16_t i;
 
-    for (i=0; i<ZM_VAP_PORT_NUMBER; i++)
+    for (i = 0; i < ZM_VAP_PORT_NUMBER; i++)
     {
         vap[i].dev = NULL;
         vap[i].openFlag = 0;
@@ -1128,8 +1128,7 @@ u8_t zfLnxClearStructs(struct net_device
 
     printk(KERN_ERR "TxQCnt: %d\n", TxQCnt);
 
-    for(ii = 0; ii < TxQCnt; ii++)
-    {
+    for (ii = 0; ii < TxQCnt; ii++) {
         UsbTxQ_t *TxQ = zfLnxGetUsbTxBuffer(dev);
 
         printk(KERN_ERR "dev_kfree_skb_any\n");
--- a/drivers/staging/otus/wrap_buf.c
+++ b/drivers/staging/otus/wrap_buf.c
@@ -34,9 +34,9 @@
 
 
 /* Called to allocate buffer, must return a continue buffer space */
-zbuf_t* zfwBufAllocate(zdev_t* dev, u16_t len)
+zbuf_t *zfwBufAllocate(zdev_t *dev, u16_t len)
 {
-    zbuf_t* buf;
+    zbuf_t *buf;
 
     /* Allocate SKB for packet*/
     buf = dev_alloc_skb(len);
@@ -46,15 +46,15 @@ zbuf_t* zfwBufAllocate(zdev_t* dev, u16_
 
 
 /* Called to free buffer, replace below 3 functions */
-void zfwBufFree(zdev_t* dev, zbuf_t* buf, u16_t status)
+void zfwBufFree(zdev_t *dev, zbuf_t *buf, u16_t status)
 {
     dev_kfree_skb_any(buf);
 }
 
 /* Called to adjust buffer size and head pointer */
-u16_t zfwBufRemoveHead(zdev_t* dev, zbuf_t* buf, u16_t size)
+u16_t zfwBufRemoveHead(zdev_t *dev, zbuf_t *buf, u16_t size)
 {
-    //zm_assert(buf->len > size);
+    /* zm_assert(buf->len > size); */
 
     buf->data += size;
     buf->len -= size;
@@ -68,7 +68,7 @@ u16_t zfwBufRemoveHead(zdev_t* dev, zbuf
 /* Used to chain Rx buffer to form a frame. if the prepared Rx buffer  */
 /* is greater than an ethernet frame(1518+32 byte), then this function    */
 /* will only be called with head=NULL.                                 */
-u16_t zfwBufChain(zdev_t* dev, zbuf_t** head, zbuf_t* tail)
+u16_t zfwBufChain(zdev_t *dev, zbuf_t **head, zbuf_t *tail)
 {
 
     *head = tail;
@@ -77,7 +77,7 @@ u16_t zfwBufChain(zdev_t* dev, zbuf_t** 
 
 
 /* Called when doing infra-bss forwarding */
-u16_t zfwBufCopy(zdev_t* dev, zbuf_t* dst, zbuf_t* src)
+u16_t zfwBufCopy(zdev_t *dev, zbuf_t *dst, zbuf_t *src)
 {
     memcpy(dst->data, src->data, src->len);
     dst->tail = dst->data;
@@ -87,7 +87,7 @@ u16_t zfwBufCopy(zdev_t* dev, zbuf_t* ds
 
 
 /* Called to adjust buffer size and tail pointer */
-u16_t zfwBufSetSize(zdev_t* dev, zbuf_t* buf, u16_t size)
+u16_t zfwBufSetSize(zdev_t *dev, zbuf_t *buf, u16_t size)
 {
 #ifdef NET_SKBUFF_DATA_USES_OFFSET
     buf->tail = 0;
@@ -101,11 +101,11 @@ u16_t zfwBufSetSize(zdev_t* dev, zbuf_t*
     return 0;
 }
 
-u16_t zfwBufGetSize(zdev_t* dev, zbuf_t* buf)
+u16_t zfwBufGetSize(zdev_t *dev, zbuf_t *buf)
 {
     return buf->len;
 }
 
-void zfwCopyBufContext(zdev_t* dev, zbuf_t* source, zbuf_t* dst)
+void zfwCopyBufContext(zdev_t *dev, zbuf_t *source, zbuf_t *dst)
 {
 }
--- a/drivers/staging/otus/wrap_ev.c
+++ b/drivers/staging/otus/wrap_ev.c
@@ -32,202 +32,214 @@
 
 
 /***** Management *****/
-u16_t zfLnxAuthNotify(zdev_t* dev, u16_t* macAddr)
+u16_t zfLnxAuthNotify(zdev_t *dev, u16_t *macAddr)
 {
-    return 0;
+	return 0;
 }
 
-u16_t zfLnxAsocNotify(zdev_t* dev, u16_t* macAddr, u8_t* body, u16_t bodySize, u16_t port)
+u16_t zfLnxAsocNotify(zdev_t *dev, u16_t *macAddr, u8_t *body, u16_t bodySize,
+			 u16_t port)
 {
-//#ifdef ZM_HOSTAPD_SUPPORT
-    struct usbdrv_private *macp = dev->ml_priv;
-    union iwreq_data wreq;
-    u8_t *addr = (u8_t *) macAddr;
-    u16_t i, j;
-
-    memset(&wreq, 0, sizeof(wreq));
-    memcpy(wreq.addr.sa_data, macAddr, ETH_ALEN);
-    wreq.addr.sa_family = ARPHRD_ETHER;
-    printk(KERN_DEBUG "join_event of MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
-            addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
-
-    for(i = 0; i < ZM_OAL_MAX_STA_SUPPORT; i++)
-    {
-        for(j = 0; j < IEEE80211_ADDR_LEN; j++)
-        {
-            if ((macp->stawpaie[i].wpa_macaddr[j] != 0) &&
-                (macp->stawpaie[i].wpa_macaddr[j] != addr[j]))
-                break;
-        }
-        if (j == 6)
-            break;
-    }
-    if (i < ZM_OAL_MAX_STA_SUPPORT)
-    {
-        //printk("zfwAsocNotify - store wpa ie in macp, index = %d\n", i);
-        memcpy(macp->stawpaie[i].wpa_macaddr, macAddr, IEEE80211_ADDR_LEN);
-        memcpy(macp->stawpaie[i].wpa_ie, body, bodySize);
-    }
-    //if(macp->cardSetting.BssType == INFRASTRUCTURE_BSS) {
-    //            //wireless_send_event(macp->device, SIOCGIWSCAN, &wreq, NULL);
-    //    wireless_send_event(macp->device, SIOCGIWAP, &wreq, NULL);
-    //}
-    //else if(macp->cardSetting.BssType == AP_BSS) {
-//        if (port == 0)
-//        {
-            wireless_send_event(dev, IWEVREGISTERED, &wreq, NULL);
-//        }
-//        else
-//        {
-//            /* Check whether the VAP device is valid */
-//            if (vap[port].dev != NULL)
-//            {
-//                wireless_send_event(vap[port].dev, IWEVREGISTERED, &wreq, NULL);
-//            }
-//            else
-//            {
-//                printk(KERN_ERR "Can' find a valid VAP device, port: %d\n", port);
-//            }
-//        }
-    //}
-//#endif
+/* #ifdef ZM_HOSTAPD_SUPPORT	*/
+	struct usbdrv_private *macp = dev->ml_priv;
+	union iwreq_data wreq;
+	u8_t *addr = (u8_t *) macAddr;
+	u16_t i, j;
+
+	memset(&wreq, 0, sizeof(wreq));
+	memcpy(wreq.addr.sa_data, macAddr, ETH_ALEN);
+	wreq.addr.sa_family = ARPHRD_ETHER;
+	printk(KERN_DEBUG "join_event of MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+
+	for (i = 0; i < ZM_OAL_MAX_STA_SUPPORT; i++) {
+		for (j = 0; j < IEEE80211_ADDR_LEN; j++) {
+			if ((macp->stawpaie[i].wpa_macaddr[j] != 0) &&
+				(macp->stawpaie[i].wpa_macaddr[j] != addr[j]))
+				break;
+		}
+		if (j == 6)
+			break;
+	}
+	if (i < ZM_OAL_MAX_STA_SUPPORT) {
+		/*
+		 * printk("zfwAsocNotify - store wpa ie in macp,
+		 * 	index = %d\n", i);
+		 */
+		memcpy(macp->stawpaie[i].wpa_macaddr, macAddr,
+			IEEE80211_ADDR_LEN);
+		memcpy(macp->stawpaie[i].wpa_ie, body, bodySize);
+	}
+	/*
+	 * if(macp->cardSetting.BssType == INFRASTRUCTURE_BSS) {
+	 * wireless_send_event(macp->device, SIOCGIWSCAN, &wreq, NULL);
+	 *	wireless_send_event(macp->device, SIOCGIWAP, &wreq, NULL);
+	 * }
+	 * else if(macp->cardSetting.BssType == AP_BSS) {
+	 *	if (port == 0)
+	 *	{
+	 */
+			wireless_send_event(dev, IWEVREGISTERED, &wreq, NULL);
+	/*
+	 *	}
+	 *	else
+	 *	{
+	 *		 Check whether the VAP device is valid
+	 *		if (vap[port].dev != NULL)
+	 *		{
+	 *			wireless_send_event(vap[port].dev,
+	 *					IWEVREGISTERED, &wreq, NULL);
+	 *		}
+	 *		else
+	 *		{
+	 *			printk(KERN_ERR "Can' find a valid VAP device,
+	 *				 port: %d\n", port);
+	 *		}
+	 *	}
+	 * }
+	 */
+/* #endif	*/
 
-    return 0;
+	return 0;
 }
 
 
 /* Notification that a STA is disassociated from AP */
 /* AP mode only */
-u16_t zfLnxDisAsocNotify(zdev_t* dev, u8_t* macAddr, u16_t port)
+u16_t zfLnxDisAsocNotify(zdev_t *dev, u8_t *macAddr, u16_t port)
 {
-    union iwreq_data wreq;
-    u8_t *addr = (u8_t *) macAddr;
+	union iwreq_data wreq;
+	u8_t *addr = (u8_t *) macAddr;
 
-    memset(&wreq, 0, sizeof(wreq));
-    memcpy(wreq.addr.sa_data, macAddr, ETH_ALEN);
-    wreq.addr.sa_family = ARPHRD_ETHER;
-    printk(KERN_DEBUG "zfwDisAsocNotify(), MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
-            addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+	memset(&wreq, 0, sizeof(wreq));
+	memcpy(wreq.addr.sa_data, macAddr, ETH_ALEN);
+	wreq.addr.sa_family = ARPHRD_ETHER;
+	printk(KERN_DEBUG "zfwDisAsocNotify(), MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
 
 
-    return 0;
+	return 0;
 }
 
 /* Notification that a STA is connect to AP */
 /* AP mode only */
-u16_t zfLnxApConnectNotify(zdev_t* dev, u8_t* macAddr, u16_t port)
+u16_t zfLnxApConnectNotify(zdev_t *dev, u8_t *macAddr, u16_t port)
 {
-    union iwreq_data wreq;
-    u8_t *addr = (u8_t *) macAddr;
+	union iwreq_data wreq;
+	u8_t *addr = (u8_t *) macAddr;
 
-    memset(&wreq, 0, sizeof(wreq));
-    memcpy(wreq.addr.sa_data, macAddr, ETH_ALEN);
-    wreq.addr.sa_family = ARPHRD_ETHER;
-    printk(KERN_DEBUG "zfwApConnectNotify(), MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
-            addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+	memset(&wreq, 0, sizeof(wreq));
+	memcpy(wreq.addr.sa_data, macAddr, ETH_ALEN);
+	wreq.addr.sa_family = ARPHRD_ETHER;
+	printk(KERN_DEBUG "zfwApConnectNotify(), MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
 
 
-    return 0;
+	return 0;
 }
 
 
 
-void zfLnxConnectNotify(zdev_t* dev, u16_t status, u16_t* bssid)
+void zfLnxConnectNotify(zdev_t *dev, u16_t status, u16_t *bssid)
 {
-    union iwreq_data wreq;
-    u8_t *addr = (u8_t *) bssid;
-    struct usbdrv_private *macp = dev->ml_priv;
+	union iwreq_data wreq;
+	u8_t *addr = (u8_t *) bssid;
+	struct usbdrv_private *macp = dev->ml_priv;
 
-    if (bssid != NULL)
-    {
-        memset(&wreq, 0, sizeof(wreq));
-        if (status == ZM_STATUS_MEDIA_CONNECT)
-            memcpy(wreq.addr.sa_data, bssid, ETH_ALEN);
-        wreq.addr.sa_family = ARPHRD_ETHER;
+	if (bssid != NULL) {
+		memset(&wreq, 0, sizeof(wreq));
+		if (status == ZM_STATUS_MEDIA_CONNECT)
+			memcpy(wreq.addr.sa_data, bssid, ETH_ALEN);
+		wreq.addr.sa_family = ARPHRD_ETHER;
 
-        if (status == ZM_STATUS_MEDIA_CONNECT)
-        {
+		if (status == ZM_STATUS_MEDIA_CONNECT) {
 #ifdef ZM_CONFIG_BIG_ENDIAN
-            printk(KERN_DEBUG "Connected to AP, MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
-                    addr[1], addr[0], addr[3], addr[2], addr[5], addr[4]);
+			printk(KERN_DEBUG "Connected to AP, MAC:"
+				"%02x:%02x:%02x:%02x:%02x:%02x\n",
+				addr[1], addr[0], addr[3], addr[2],
+				addr[5], addr[4]);
 #else
-            printk(KERN_DEBUG "Connected to AP, MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
-                    addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+			printk(KERN_DEBUG "Connected to AP, MAC:"
+				 "%02x:%02x:%02x:%02x:%02x:%02x\n",
+				addr[0], addr[1], addr[2], addr[3],
+				addr[4], addr[5]);
 #endif
 
-            netif_start_queue(dev);
-        }
-        else if ((status == ZM_STATUS_MEDIA_DISCONNECT) ||
-                 (status == ZM_STATUS_MEDIA_DISABLED) ||
-                 (status == ZM_STATUS_MEDIA_CONNECTION_DISABLED) ||
-	         (status == ZM_STATUS_MEDIA_CONNECTION_RESET) ||
-	         (status == ZM_STATUS_MEDIA_RESET) ||
-	         (status == ZM_STATUS_MEDIA_DISCONNECT_DEAUTH) ||
-	         (status == ZM_STATUS_MEDIA_DISCONNECT_DISASOC) ||
-	         (status == ZM_STATUS_MEDIA_DISCONNECT_BEACON_MISS) ||
-                 (status == ZM_STATUS_MEDIA_DISCONNECT_NOT_FOUND) ||
-	         (status == ZM_STATUS_MEDIA_DISCONNECT_TIMEOUT))
-        {
-            printk(KERN_DEBUG "Disconnection Notify\n");
+			netif_start_queue(dev);
+		} else if ((status == ZM_STATUS_MEDIA_DISCONNECT) ||
+			    (status == ZM_STATUS_MEDIA_DISABLED) ||
+			    (status == ZM_STATUS_MEDIA_CONNECTION_DISABLED) ||
+			    (status == ZM_STATUS_MEDIA_CONNECTION_RESET) ||
+			    (status == ZM_STATUS_MEDIA_RESET) ||
+			    (status == ZM_STATUS_MEDIA_DISCONNECT_DEAUTH) ||
+			    (status == ZM_STATUS_MEDIA_DISCONNECT_DISASOC) ||
+			   (status == ZM_STATUS_MEDIA_DISCONNECT_BEACON_MISS) ||
+			    (status == ZM_STATUS_MEDIA_DISCONNECT_NOT_FOUND) ||
+			    (status == ZM_STATUS_MEDIA_DISCONNECT_TIMEOUT)) {
+			printk(KERN_DEBUG "Disconnection Notify\n");
 
-            netif_stop_queue(dev);
-        }
+			netif_stop_queue(dev);
+		}
 
 	/* Save the connected status */
 	macp->adapterState = status;
 
-        if(zfiWlanQueryWlanMode(dev) == ZM_MODE_INFRASTRUCTURE) {
-        //            //wireless_send_event(dev, SIOCGIWSCAN, &wreq, NULL);
-            wireless_send_event(dev, SIOCGIWAP, &wreq, NULL);
-        }
-        else if(zfiWlanQueryWlanMode(dev) == ZM_MODE_AP) {
-            //if (port == 0)
-            //{
-                wireless_send_event(dev, IWEVREGISTERED, &wreq, NULL);
-            //}
-            //else
-            //{
-            //    /* Check whether the VAP device is valid */
-            //    if (vap[port].dev != NULL)
-            //    {
-            //        wireless_send_event(vap[port].dev, IWEVREGISTERED, &wreq, NULL);
-            //    }
-            //    else
-            //    {
-            //        printk(KERN_ERR "Can' find a valid VAP device, port: %d\n", port);
-            //    }
-            //}
-        }
-    }
-    //return 0;
-}
-
-void zfLnxScanNotify(zdev_t* dev, struct zsScanResult* result)
-{
-    return;
+		if (zfiWlanQueryWlanMode(dev) == ZM_MODE_INFRASTRUCTURE) {
+			/*wireless_send_event(dev, SIOCGIWSCAN, &wreq, NULL);*/
+			wireless_send_event(dev, SIOCGIWAP, &wreq, NULL);
+		} else if (zfiWlanQueryWlanMode(dev) == ZM_MODE_AP) {
+			/*
+			 * if (port == 0)
+			 * {
+			 *	wireless_send_event(dev, IWEVREGISTERED,
+			 *				 &wreq, NULL);
+			 * }
+			 * else
+			 * {
+			 *	Check whether the VAP device is valid
+			 *	if (vap[port].dev != NULL)
+			 *	{
+			 *		wireless_send_event(vap[port].dev,
+		 *				 IWEVREGISTERED, &wreq, NULL);
+			 *	}
+			 *	else
+			 *	{
+			 *		printk(KERN_ERR "Can' find a valid VAP"
+			 *			" device, port: %d\n", port);
+			 *	}
+			 * }
+			*/
+		}
+	}
+	/* return 0;	*/
 }
 
-void zfLnxStatisticsNotify(zdev_t* dev, struct zsStastics* result)
+void zfLnxScanNotify(zdev_t *dev, struct zsScanResult *result)
 {
-    return;
+	return;
 }
 
-//void zfwMicFailureNotify(zdev_t* dev, u8_t* message, u16_t event)
-void zfLnxMicFailureNotify(zdev_t* dev, u16_t* addr, u16_t status)
+void zfLnxStatisticsNotify(zdev_t *dev, struct zsStastics *result)
+{
+	return;
+}
+
+/* void zfwMicFailureNotify(zdev_t *dev, u8_t *message, u16_t event) */
+void zfLnxMicFailureNotify(zdev_t *dev, u16_t *addr, u16_t status)
 {
 	static const char *tag = "MLME-MICHAELMICFAILURE.indication";
 	union iwreq_data wrqu;
 	char buf[128];
 
 	/* TODO: needed parameters: count, type, src address */
-	//snprintf(buf, sizeof(buf), "%s(%scast addr=%s)", tag,
-	//    (status == ZM_MIC_GROUP_ERROR) ?  "broad" : "uni",
-	//    ether_sprintf((u8_t *)addr));
+	/*
+	 * snprintf(buf, sizeof(buf), "%s(%scast addr=%s)", tag,
+	 *	(status == ZM_MIC_GROUP_ERROR) ?  "broad" : "uni",
+	 *	ether_sprintf((u8_t *)addr));
+	 */
 
 	if (zfiWlanQueryWlanMode(dev) == ZM_MODE_INFRASTRUCTURE)
-	{
 		strcpy(buf, tag);
-	}
 
 	memset(&wrqu, 0, sizeof(wrqu));
 	wrqu.data.length = strlen(buf);
@@ -235,42 +247,46 @@ void zfLnxMicFailureNotify(zdev_t* dev, 
 }
 
 
-void zfLnxApMicFailureNotify(zdev_t* dev, u8_t* addr, zbuf_t* buf)
+void zfLnxApMicFailureNotify(zdev_t *dev, u8_t *addr, zbuf_t *buf)
 {
-    union iwreq_data wreq;
+	union iwreq_data wreq;
 
-    memset(&wreq, 0, sizeof(wreq));
-    memcpy(wreq.addr.sa_data, addr, ETH_ALEN);
-    wreq.addr.sa_family = ARPHRD_ETHER;
-    printk(KERN_DEBUG "zfwApMicFailureNotify(), MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
-            addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+	memset(&wreq, 0, sizeof(wreq));
+	memcpy(wreq.addr.sa_data, addr, ETH_ALEN);
+	wreq.addr.sa_family = ARPHRD_ETHER;
+	printk(KERN_DEBUG "zfwApMicFailureNotify(), "
+			"MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
 
-    return;
+	return;
 }
-
-// status = 0  => partner lost
-//        = 1  => partner alive
-//void zfwIbssPartnerNotify(zdev_t* dev, u8_t status)
-void zfLnxIbssPartnerNotify(zdev_t* dev, u16_t status, struct zsPartnerNotifyEvent *event)
+/*
+ * status = 0  => partner lost
+ *		= 1  => partner alive
+ * void zfwIbssPartnerNotify(zdev_t* dev, u8_t status)
+ */
+void zfLnxIbssPartnerNotify(zdev_t *dev, u16_t status,
+				struct zsPartnerNotifyEvent *event)
 {
 }
 
-void zfLnxMacAddressNotify(zdev_t* dev, u8_t* addr)
+void zfLnxMacAddressNotify(zdev_t *dev, u8_t *addr)
 {
-    dev->dev_addr[0] = addr[0];
-    dev->dev_addr[1] = addr[1];
-    dev->dev_addr[2] = addr[2];
-    dev->dev_addr[3] = addr[3];
-    dev->dev_addr[4] = addr[4];
-    dev->dev_addr[5] = addr[5];
+	dev->dev_addr[0] = addr[0];
+	dev->dev_addr[1] = addr[1];
+	dev->dev_addr[2] = addr[2];
+	dev->dev_addr[3] = addr[3];
+	dev->dev_addr[4] = addr[4];
+	dev->dev_addr[5] = addr[5];
 }
 
-void zfLnxSendCompleteIndication(zdev_t* dev, zbuf_t* buf)
+void zfLnxSendCompleteIndication(zdev_t *dev, zbuf_t *buf)
 {
 }
 
 
-void zfLnxRestoreBufData(zdev_t* dev, zbuf_t* buf) {
+void zfLnxRestoreBufData(zdev_t *dev, zbuf_t *buf)
+{
 
 }
 /* Leave an empty line below to remove warning message on some compiler */
--- a/drivers/staging/otus/wrap_mis.c
+++ b/drivers/staging/otus/wrap_mis.c
@@ -30,76 +30,73 @@
 #include <linux/netlink.h>
 #include <net/iw_handler.h>
 
-//extern struct zsWdsStruct wds[ZM_WDS_PORT_NUMBER];
+/* extern struct zsWdsStruct wds[ZM_WDS_PORT_NUMBER];	*/
 extern struct zsVapStruct vap[ZM_VAP_PORT_NUMBER];
-extern u16_t zfLnxGetVapId(zdev_t* dev);
+extern u16_t zfLnxGetVapId(zdev_t *dev);
 
 /* Simply return 0xffff if VAP function is not supported */
-u16_t zfwGetVapId(zdev_t* dev)
+u16_t zfwGetVapId(zdev_t *dev)
 {
-    return zfLnxGetVapId(dev);
+	return zfLnxGetVapId(dev);
 }
 
-void zfwSleep(zdev_t* dev, u32_t ms)
+void zfwSleep(zdev_t *dev, u32_t ms)
 {
-    if (in_interrupt() == 0)
-    {
-        mdelay(ms);
-    }
-    else
-    {
-        int ii;
-        int iter = 100000 * ms;
+	if (in_interrupt() == 0)
+		mdelay(ms);
+	else {
+		int ii;
+		int iter = 100000 * ms;
 
-        for (ii = 0; ii < iter; ii++)
-        {
-
-        }
-    }
+		for (ii = 0; ii < iter; ii++) {
+		}
+	}
 }
 
 #ifdef ZM_HALPLUS_LOCK
-asmlinkage struct zsWlanDev *zfwGetWlanDev(zdev_t* dev)
+asmlinkage struct zsWlanDev *zfwGetWlanDev(zdev_t *dev)
 {
 	struct usbdrv_private *macp = dev->ml_priv;
 	return macp->wd;
 }
 
-asmlinkage void zfwEnterCriticalSection(zdev_t* dev)
+asmlinkage void zfwEnterCriticalSection(zdev_t *dev)
 {
 	struct usbdrv_private *macp = dev->ml_priv;
 	spin_lock_irqsave(&macp->cs_lock, macp->hal_irqFlag);
 }
 
-asmlinkage void zfwLeaveCriticalSection(zdev_t* dev)
+asmlinkage void zfwLeaveCriticalSection(zdev_t *dev)
 {
 	struct usbdrv_private *macp = dev->ml_priv;
 	spin_unlock_irqrestore(&macp->cs_lock, macp->hal_irqFlag);
 }
 
-asmlinkage u8_t zfwBufReadByte(zdev_t* dev, zbuf_t* buf, u16_t offset)
+asmlinkage u8_t zfwBufReadByte(zdev_t *dev, zbuf_t *buf, u16_t offset)
 {
-    return *(u8_t*)((u8_t*)buf->data+offset);
+	return *(u8_t *)((u8_t *)buf->data+offset);
 }
 
-asmlinkage u16_t zfwBufReadHalfWord(zdev_t* dev, zbuf_t* buf, u16_t offset)
+asmlinkage u16_t zfwBufReadHalfWord(zdev_t *dev, zbuf_t *buf, u16_t offset)
 {
-    return zmw_cpu_to_le16(*(u16_t*)((u8_t*)buf->data+offset));
+	return zmw_cpu_to_le16(*(u16_t *)((u8_t *)buf->data+offset));
 }
 
-asmlinkage void zfwBufWriteByte(zdev_t* dev, zbuf_t* buf, u16_t offset, u8_t value)
+asmlinkage void zfwBufWriteByte(zdev_t *dev, zbuf_t *buf, u16_t offset,
+				u8_t value)
 {
-    *(u8_t*)((u8_t*)buf->data+offset) = value;
+	*(u8_t *)((u8_t *)buf->data+offset) = value;
 }
 
-asmlinkage void zfwBufWriteHalfWord(zdev_t* dev, zbuf_t* buf, u16_t offset, u16_t value)
+asmlinkage void zfwBufWriteHalfWord(zdev_t *dev, zbuf_t *buf, u16_t offset,
+					u16_t value)
 {
-    *(u16_t*)((u8_t*)buf->data+offset) = zmw_cpu_to_le16(value);
+	*(u16_t *)((u8_t *)buf->data+offset) = zmw_cpu_to_le16(value);
 }
 
-asmlinkage u8_t *zfwGetBuffer(zdev_t* dev, zbuf_t* buf)
+asmlinkage u8_t *zfwGetBuffer(zdev_t *dev, zbuf_t *buf)
 {
-    return (u8_t*)(buf->data);
+	return (u8_t *)(buf->data);
 }
 #endif
 
--- a/drivers/staging/otus/wrap_pkt.c
+++ b/drivers/staging/otus/wrap_pkt.c
@@ -31,136 +31,122 @@
 #include <net/iw_handler.h>
 
 
-//extern struct zsWdsStruct wds[ZM_WDS_PORT_NUMBER];
+/* extern struct zsWdsStruct wds[ZM_WDS_PORT_NUMBER]; 	*/
 extern struct zsVapStruct vap[ZM_VAP_PORT_NUMBER];
 
 
 /***** Rx *****/
-void zfLnxRecv80211(zdev_t* dev, zbuf_t* buf, struct zsAdditionInfo* addInfo)
+void zfLnxRecv80211(zdev_t *dev, zbuf_t *buf, struct zsAdditionInfo *addInfo)
 {
-    u16_t frameType;
-    u16_t frameCtrl;
-    u16_t frameSubtype;
-    zbuf_t *skb1;
-    struct usbdrv_private *macp = dev->ml_priv;
-
-    //frameCtrl = zmw_buf_readb(dev, buf, 0);
-    frameCtrl = *(u8_t*)((u8_t*)buf->data);
-    frameType = frameCtrl & 0xf;
-    frameSubtype = frameCtrl & 0xf0;
-
-    if ((frameType == 0x0) && (macp->forwardMgmt))
-    {
-        switch (frameSubtype)
-        {
-                /* Beacon */
-            case 0x80 :
-                /* Probe response */
-            case 0x50 :
-                skb1 = skb_copy(buf, GFP_ATOMIC);
-                if(skb1 != NULL)
-                {
-                    skb1->dev = dev;
-                    skb1->mac_header = skb1->data;
-	            skb1->ip_summed = CHECKSUM_NONE;
-	            skb1->pkt_type = PACKET_OTHERHOST;
-	            skb1->protocol = __constant_htons(0x0019);  /* ETH_P_80211_RAW */
-    	            netif_rx(skb1);
-	            }
-                break;
-            default:
-                break;
-        }
-    }
+	u16_t frameType;
+	u16_t frameCtrl;
+	u16_t frameSubtype;
+	zbuf_t *skb1;
+	struct usbdrv_private *macp = dev->ml_priv;
+
+	/* frameCtrl = zmw_buf_readb(dev, buf, 0);	*/
+	frameCtrl = *(u8_t *)((u8_t *)buf->data);
+	frameType = frameCtrl & 0xf;
+	frameSubtype = frameCtrl & 0xf0;
+
+	if ((frameType == 0x0) && (macp->forwardMgmt)) {
+		switch (frameSubtype) {
+			/* Beacon */
+		case 0x80:
+			/* Probe response */
+		case 0x50:
+			skb1 = skb_copy(buf, GFP_ATOMIC);
+			if (skb1 != NULL) {
+				skb1->dev = dev;
+				skb1->mac_header = skb1->data;
+				skb1->ip_summed = CHECKSUM_NONE;
+				skb1->pkt_type = PACKET_OTHERHOST;
+				/* ETH_P_80211_RAW */
+				skb1->protocol = __constant_htons(0x0019);
+				netif_rx(skb1);
+			}
+			break;
+		default:
+			break;
+		}
+	}
 
-    zfiRecv80211(dev, buf, addInfo);
-    return;
+	zfiRecv80211(dev, buf, addInfo);
+	return;
 }
 
 #define ZM_AVOID_UDP_LARGE_PACKET_FAIL
-void zfLnxRecvEth(zdev_t* dev, zbuf_t* buf, u16_t port)
+void zfLnxRecvEth(zdev_t *dev, zbuf_t *buf, u16_t port)
 {
-    struct usbdrv_private *macp = dev->ml_priv;
+	struct usbdrv_private *macp = dev->ml_priv;
 #ifdef ZM_AVOID_UDP_LARGE_PACKET_FAIL
-    zbuf_t *new_buf;
+	zbuf_t *new_buf;
 
-    //new_buf = dev_alloc_skb(2048);
-    new_buf = dev_alloc_skb(buf->len);
+	/* new_buf = dev_alloc_skb(2048);	*/
+	new_buf = dev_alloc_skb(buf->len);
 
 #ifdef NET_SKBUFF_DATA_USES_OFFSET
-    new_buf->tail = 0;
-    new_buf->len = 0;
+	new_buf->tail = 0;
+	new_buf->len = 0;
 #else
-    new_buf->tail = new_buf->data;
-    new_buf->len = 0;
+	new_buf->tail = new_buf->data;
+	new_buf->len = 0;
 #endif
 
-    skb_put(new_buf, buf->len);
-    memcpy(new_buf->data, buf->data, buf->len);
+	skb_put(new_buf, buf->len);
+	memcpy(new_buf->data, buf->data, buf->len);
 
-    /* Free buffer */
-    dev_kfree_skb_any(buf);
+	/* Free buffer */
+	dev_kfree_skb_any(buf);
 
-    if (port == 0)
-    {
-        new_buf->dev = dev;
-        new_buf->protocol = eth_type_trans(new_buf, dev);
-    }
-    else
-    {
-        /* VAP */
-        if (vap[0].dev != NULL)
-        {
-            new_buf->dev = vap[0].dev;
-            new_buf->protocol = eth_type_trans(new_buf, vap[0].dev);
-        }
-        else
-        {
-            new_buf->dev = dev;
-            new_buf->protocol = eth_type_trans(new_buf, dev);
-        }
-    }
+	if (port == 0) {
+		new_buf->dev = dev;
+		new_buf->protocol = eth_type_trans(new_buf, dev);
+	} else {
+		/* VAP */
+		if (vap[0].dev != NULL) {
+			new_buf->dev = vap[0].dev;
+			new_buf->protocol = eth_type_trans(new_buf, vap[0].dev);
+		} else {
+			new_buf->dev = dev;
+			new_buf->protocol = eth_type_trans(new_buf, dev);
+		}
+	}
 
-    new_buf->ip_summed = CHECKSUM_NONE;
-    dev->last_rx = jiffies;
+	new_buf->ip_summed = CHECKSUM_NONE;
+	dev->last_rx = jiffies;
 
-    switch(netif_rx(new_buf))
+	switch (netif_rx(new_buf))
 #else
-    if (port == 0)
-    {
-        buf->dev = dev;
-        buf->protocol = eth_type_trans(buf, dev);
-    }
-    else
-    {
-        /* VAP */
-        if (vap[0].dev != NULL)
-        {
-            buf->dev = vap[0].dev;
-            buf->protocol = eth_type_trans(buf, vap[0].dev);
-        }
-        else
-        {
-            buf->dev = dev;
-            buf->protocol = eth_type_trans(buf, dev);
-        }
-    }
+	if (port == 0) {
+		buf->dev = dev;
+		buf->protocol = eth_type_trans(buf, dev);
+	} else {
+		/* VAP */
+		if (vap[0].dev != NULL) {
+			buf->dev = vap[0].dev;
+			buf->protocol = eth_type_trans(buf, vap[0].dev);
+		} else {
+			buf->dev = dev;
+			buf->protocol = eth_type_trans(buf, dev);
+		}
+	}
 
-    buf->ip_summed = CHECKSUM_NONE;
-    dev->last_rx = jiffies;
+	buf->ip_summed = CHECKSUM_NONE;
+	dev->last_rx = jiffies;
 
-    switch(netif_rx(buf))
+	switch (netif_rx(buf))
 #endif
-    {
-    case NET_RX_DROP:
-        break;
-    default:
-            macp->drv_stats.net_stats.rx_packets++;
-            macp->drv_stats.net_stats.rx_bytes += buf->len;
-        break;
-    }
+	{
+	case NET_RX_DROP:
+		break;
+	default:
+			macp->drv_stats.net_stats.rx_packets++;
+			macp->drv_stats.net_stats.rx_bytes += buf->len;
+		break;
+	}
 
-    return;
+	return;
 }
 
 /* Leave an empty line below to remove warning message on some compiler */
--- a/drivers/staging/otus/wrap_sec.c
+++ b/drivers/staging/otus/wrap_sec.c
@@ -33,92 +33,93 @@
 #ifdef ZM_ENABLE_CENC
 extern int zfLnxCencSendMsg(struct sock *netlink_sk, u_int8_t *msg, int len);
 
-u16_t zfLnxCencAsocNotify(zdev_t* dev, u16_t* macAddr, u8_t* body, u16_t bodySize, u16_t port)
+u16_t zfLnxCencAsocNotify(zdev_t *dev, u16_t *macAddr, u8_t *body,
+				u16_t bodySize, u16_t port)
 {
-    struct usbdrv_private *macp = (struct usbdrv_private *)dev->priv;
-    struct zydas_cenc_sta_info cenc_info;
-    //struct sock *netlink_sk;
-    u8_t ie_len;
-    int ii;
-
-    /* Create NETLINK socket */
-    //netlink_sk = netlink_kernel_create(NETLINK_USERSOCK, NULL);
-
-    if (macp->netlink_sk == NULL)
-    {
-        printk(KERN_ERR "NETLINK Socket is NULL\n");
-        return -1;
-    }
-
-    memset(&cenc_info, 0, sizeof(cenc_info));
-
-    //memcpy(cenc_info.gsn, vap->iv_cencmsk_keys.wk_txiv, ZM_CENC_IV_LEN);
-    zfiWlanQueryGSN(dev, cenc_info.gsn, port);
-    cenc_info.datalen += ZM_CENC_IV_LEN;
-    ie_len = body[1] + 2;
-    memcpy(cenc_info.wie, body, ie_len);
-    cenc_info.datalen += ie_len;
-
-    memcpy(cenc_info.sta_mac, macAddr, 6);
-    cenc_info.msg_type = ZM_CENC_WAI_REQUEST;
-    cenc_info.datalen += 6 + 2;
-
-    printk(KERN_ERR "===== zfwCencSendMsg, bodySize: %d =====\n", bodySize);
-
-    for(ii = 0; ii < bodySize; ii++)
-    {
-        printk(KERN_ERR "%02x ", body[ii]);
-
-        if ((ii & 0xf) == 0xf)
-        {
-            printk(KERN_ERR "\n");
-        }
-    }
+	struct usbdrv_private *macp = (struct usbdrv_private *)dev->priv;
+	struct zydas_cenc_sta_info cenc_info;
+	/* struct sock *netlink_sk;	*/
+	u8_t ie_len;
+	int ii;
+
+	/* Create NETLINK socket */
+	/*netlink_sk = netlink_kernel_create(NETLINK_USERSOCK, NULL);	*/
+
+	if (macp->netlink_sk == NULL) {
+		printk(KERN_ERR "NETLINK Socket is NULL\n");
+		return -1;
+	}
+
+	memset(&cenc_info, 0, sizeof(cenc_info));
+
+	/* memcpy(cenc_info.gsn, vap->iv_cencmsk_keys.wk_txiv,
+	 *  	ZM_CENC_IV_LEN);
+	 */
+	zfiWlanQueryGSN(dev, cenc_info.gsn, port);
+	cenc_info.datalen += ZM_CENC_IV_LEN;
+	ie_len = body[1] + 2;
+	memcpy(cenc_info.wie, body, ie_len);
+	cenc_info.datalen += ie_len;
+
+	memcpy(cenc_info.sta_mac, macAddr, 6);
+	cenc_info.msg_type = ZM_CENC_WAI_REQUEST;
+	cenc_info.datalen += 6 + 2;
+
+	printk(KERN_ERR "===== zfwCencSendMsg, bodySize: %d =====\n", bodySize);
+
+	for (ii = 0; ii < bodySize; ii++) {
+		printk(KERN_ERR "%02x ", body[ii]);
+
+		if ((ii & 0xf) == 0xf)
+			printk(KERN_ERR "\n");
+	}
 
-    zfLnxCencSendMsg(macp->netlink_sk, (u8_t *)&cenc_info, cenc_info.datalen+4);
+	zfLnxCencSendMsg(macp->netlink_sk, (u8_t *)&cenc_info,
+			 cenc_info.datalen+4);
 
-    /* Close NETLINK socket */
-    //sock_release(netlink_sk);
+	/* Close NETLINK socket */
+	/* sock_release(netlink_sk);	*/
 
-    return 0;
+	return 0;
 }
-#endif //ZM_ENABLE_CENC
+#endif /* ZM_ENABLE_CENC	*/
 
-u8_t zfwCencHandleBeaconProbrespon(zdev_t* dev, u8_t *pWIEc,
-        u8_t *pPeerSSIDc, u8_t *pPeerAddrc)
+u8_t zfwCencHandleBeaconProbrespon(zdev_t *dev, u8_t *pWIEc,
+		u8_t *pPeerSSIDc, u8_t *pPeerAddrc)
 {
-    return 0;
+	return 0;
 }
 
-u8_t zfwGetPktEncExemptionActionType(zdev_t* dev, zbuf_t* buf)
+u8_t zfwGetPktEncExemptionActionType(zdev_t *dev, zbuf_t *buf)
 {
-    return ZM_ENCRYPTION_EXEMPT_NO_EXEMPTION;
+	return ZM_ENCRYPTION_EXEMPT_NO_EXEMPTION;
 }
 
-void copyToIntTxBuffer(zdev_t* dev, zbuf_t* buf, u8_t* src,
-                         u16_t offset, u16_t length)
+void copyToIntTxBuffer(zdev_t *dev, zbuf_t *buf, u8_t *src,
+						 u16_t offset, u16_t length)
 {
-    u16_t i;
+	u16_t i;
 
-    for(i=0; i<length;i++)
-    {
-        //zmw_tx_buf_writeb(dev, buf, offset+i, src[i]);
-        *(u8_t*)((u8_t*)buf->data+offset+i) = src[i];
-    }
+	for (i = 0; i < length; i++) {
+		/* zmw_tx_buf_writeb(dev, buf, offset+i, src[i]);	*/
+		*(u8_t *)((u8_t *)buf->data+offset+i) = src[i];
+	}
 }
 
-u16_t zfwStaAddIeWpaRsn(zdev_t* dev, zbuf_t* buf, u16_t offset, u8_t frameType)
+u16_t zfwStaAddIeWpaRsn(zdev_t *dev, zbuf_t *buf, u16_t offset, u8_t frameType)
 {
-    struct usbdrv_private *macp = dev->ml_priv;
-    //zm_msg1_mm(ZM_LV_0, "CWY - add wpaie content Length : ", macp->supIe[1]);
-    if (macp->supIe[1] != 0)
-    {
-        copyToIntTxBuffer(dev, buf, macp->supIe, offset, macp->supIe[1]+2);
-        //memcpy(buf->data[offset], macp->supIe, macp->supIe[1]+2);
-        offset += (macp->supIe[1]+2);
-    }
+	struct usbdrv_private *macp = dev->ml_priv;
+	/* zm_msg1_mm(ZM_LV_0, "CWY - add wpaie content Length : "
+	 * 		, macp->supIe[1]);
+	 */
+	if (macp->supIe[1] != 0) {
+		copyToIntTxBuffer(dev, buf, macp->supIe, offset,
+					 macp->supIe[1]+2);
+		/* memcpy(buf->data[offset], macp->supIe, macp->supIe[1]+2);*/
+		offset += (macp->supIe[1]+2);
+	}
 
-    return offset;
+	return offset;
 }
 
 /* Leave an empty line below to remove warning message on some compiler */
--- a/drivers/staging/otus/wrap_usb.c
+++ b/drivers/staging/otus/wrap_usb.c
@@ -30,159 +30,152 @@
 #include <linux/netlink.h>
 #include <net/iw_handler.h>
 
-extern void zfLnxInitUsbTxQ(zdev_t* dev);
-extern void zfLnxInitUsbRxQ(zdev_t* dev);
+extern void zfLnxInitUsbTxQ(zdev_t *dev);
+extern void zfLnxInitUsbRxQ(zdev_t *dev);
 extern u32_t zfLnxSubmitRegInUrb(zdev_t *dev);
-u32_t zfLnxUsbOut(zdev_t* dev, u8_t *hdr, u16_t hdrlen, u8_t *snap, u16_t snapLen,
-        u8_t *tail, u16_t tailLen, zbuf_t *buf, u16_t offset);
-u32_t zfLnxUsbWriteReg(zdev_t* dev, u32_t* cmd, u16_t cmdLen);
+u32_t zfLnxUsbOut(zdev_t *dev, u8_t *hdr, u16_t hdrlen, u8_t *snap,
+		u16_t snapLen, u8_t *tail, u16_t tailLen, zbuf_t *buf,
+		u16_t offset);
+u32_t zfLnxUsbWriteReg(zdev_t *dev, u32_t *cmd, u16_t cmdLen);
 
-void zfwUsbRegisterCallBack(zdev_t* dev, struct zfCbUsbFuncTbl *zfUsbFunc) {
-    struct usbdrv_private *macp = dev->ml_priv;
+void zfwUsbRegisterCallBack(zdev_t *dev, struct zfCbUsbFuncTbl *zfUsbFunc)
+{
+	struct usbdrv_private *macp = dev->ml_priv;
 
-    macp->usbCbFunctions.zfcbUsbRecv = zfUsbFunc->zfcbUsbRecv;
-    macp->usbCbFunctions.zfcbUsbRegIn = zfUsbFunc->zfcbUsbRegIn;
-    macp->usbCbFunctions.zfcbUsbOutComplete = zfUsbFunc->zfcbUsbOutComplete;
+	macp->usbCbFunctions.zfcbUsbRecv = zfUsbFunc->zfcbUsbRecv;
+	macp->usbCbFunctions.zfcbUsbRegIn = zfUsbFunc->zfcbUsbRegIn;
+	macp->usbCbFunctions.zfcbUsbOutComplete = zfUsbFunc->zfcbUsbOutComplete;
 
-    return;
+	return;
 }
 
-u32_t zfwUsbGetFreeTxQSize(zdev_t* dev)
+u32_t zfwUsbGetFreeTxQSize(zdev_t *dev)
 {
-    struct usbdrv_private *macp = dev->ml_priv;
-    u32_t        freeTxQSize;
-    unsigned long irqFlag;
-    //zmw_declare_for_critical_section();
+	struct usbdrv_private *macp = dev->ml_priv;
+	u32_t		freeTxQSize;
+	unsigned long irqFlag;
+	/* zmw_declare_for_critical_section();	*/
 
-    //zmw_enter_critical_section(dev);
-    spin_lock_irqsave(&macp->cs_lock, irqFlag);
+	/* zmw_enter_critical_section(dev);	*/
+	spin_lock_irqsave(&macp->cs_lock, irqFlag);
 
-    freeTxQSize = ZM_MAX_TX_BUF_NUM - macp->TxBufCnt;
+	freeTxQSize = ZM_MAX_TX_BUF_NUM - macp->TxBufCnt;
 
-    //zmw_leave_critical_section(dev);
-    spin_unlock_irqrestore(&macp->cs_lock, irqFlag);
+	/* zmw_leave_critical_section(dev);	*/
+	spin_unlock_irqrestore(&macp->cs_lock, irqFlag);
 
-    return freeTxQSize;
+	return freeTxQSize;
 }
 
-u32_t zfwUsbGetMaxTxQSize(zdev_t* dev)
+u32_t zfwUsbGetMaxTxQSize(zdev_t *dev)
 {
-    return ZM_MAX_TX_BUF_NUM;
+	return ZM_MAX_TX_BUF_NUM;
 }
 
 u32_t zfwUsbEnableIntEpt(zdev_t *dev, u8_t endpt)
 {
-    /* Initialize USB TxQ */
-    zfLnxInitUsbTxQ(dev);
+	/* Initialize USB TxQ */
+	zfLnxInitUsbTxQ(dev);
 
-    /* Initialize USB RxQ */
-    zfLnxInitUsbRxQ(dev);
+	/* Initialize USB RxQ */
+	zfLnxInitUsbRxQ(dev);
 
-    /* Initialize USB Register In URB */
-    //zfwUsbSubmitRegIn(dev);
-    /* Initialize USB Register In URB */
-    zfLnxSubmitRegInUrb(dev);
+	/* Initialize USB Register In URB */
+	/* zfwUsbSubmitRegIn(dev);	*/
+	/* Initialize USB Register In URB */
+	zfLnxSubmitRegInUrb(dev);
 
-    return 0;
+	return 0;
 }
 
-int zfwUsbEnableRxEpt(zdev_t* dev, u8_t endpt)
+int zfwUsbEnableRxEpt(zdev_t *dev, u8_t endpt)
 {
-    return 0;
+	return 0;
 }
 
-u32_t zfwUsbSubmitControl(zdev_t* dev, u8_t req, u16_t value, u16_t index, void *data, u32_t size)
+u32_t zfwUsbSubmitControl(zdev_t *dev, u8_t req, u16_t value, u16_t index,
+			 void *data, u32_t size)
 {
-    int result = 0;
-    u32_t ret = 0;
-    struct usbdrv_private *macp = dev->ml_priv;
-    u8_t* buf;
+	int result = 0;
+	u32_t ret = 0;
+	struct usbdrv_private *macp = dev->ml_priv;
+	u8_t *buf;
 
-    if (size > 0)
-    {
-        buf = kmalloc(size, GFP_KERNEL);
-        memcpy(buf, (u8_t*)data, size);
-    }
-    else
-    {
-        buf = NULL;
-    }
+	if (size > 0) {
+		buf = kmalloc(size, GFP_KERNEL);
+		memcpy(buf, (u8_t *)data, size);
+	} else
+		buf = NULL;
 
 #if 0
-    printk(KERN_ERR "req = 0x%02x\n", req);
-    printk(KERN_ERR "value = 0x%04x\n", value);
-    printk(KERN_ERR "index = 0x%04x\n", index);
-    printk(KERN_ERR "data = 0x%lx\n", (u32_t) data);
-    printk(KERN_ERR "size = %ld\n", size);
+	printk(KERN_ERR "req = 0x%02x\n", req);
+	printk(KERN_ERR "value = 0x%04x\n", value);
+	printk(KERN_ERR "index = 0x%04x\n", index);
+	printk(KERN_ERR "data = 0x%lx\n", (u32_t) data);
+	printk(KERN_ERR "size = %ld\n", size);
 #endif
 
-    result = usb_control_msg(macp->udev, usb_sndctrlpipe(macp->udev, 0),
-            req, USB_DIR_OUT | 0x40, value, index, buf, size, HZ);
+	result = usb_control_msg(macp->udev, usb_sndctrlpipe(macp->udev, 0),
+			req, USB_DIR_OUT | 0x40, value, index, buf, size, HZ);
 
-    if (result < 0)
-    {
-        printk("zfwUsbSubmitControl() failed, result=0x%x\n", result);
-        ret = 1;
-    }
-    kfree(buf);
+	if (result < 0) {
+		printk(KERN_ERR "zfwUsbSubmitControl() failed, result = 0x%x\n",
+			result);
+		ret = 1;
+	}
+	kfree(buf);
 
-    return ret;
+	return ret;
 }
 
-void zfwUsbCmd(zdev_t* dev, u8_t endpt, u32_t* cmd, u16_t cmdLen)
+void zfwUsbCmd(zdev_t *dev, u8_t endpt, u32_t *cmd, u16_t cmdLen)
 {
-    struct usbdrv_private *macp = dev->ml_priv;
-    u32_t ret;
+	struct usbdrv_private *macp = dev->ml_priv;
+	u32_t ret;
 
-    //MPUsbCommand(dev, endpt, cmd, cmdLen);
-    ret = zfLnxUsbWriteReg(dev, cmd, cmdLen);
+	/* MPUsbCommand(dev, endpt, cmd, cmdLen);	*/
+	ret = zfLnxUsbWriteReg(dev, cmd, cmdLen);
 
-    /* if zfLnxUsbWriteReg() return error, free and allocate urb, resend again */
-    if (ret != 0)
-    {
-        usb_free_urb(macp->RegOutUrb);
-        macp->RegOutUrb = usb_alloc_urb(0, GFP_ATOMIC);
-        ret = zfLnxUsbWriteReg(dev, cmd, cmdLen);
-    }
+	/*
+	 * if zfLnxUsbWriteReg() return error, free and allocate urb,
+	 * resend again
+	 */
+	if (ret != 0) {
+		usb_free_urb(macp->RegOutUrb);
+		macp->RegOutUrb = usb_alloc_urb(0, GFP_ATOMIC);
+		ret = zfLnxUsbWriteReg(dev, cmd, cmdLen);
+	}
 }
 
-u32_t zfwUsbSend(zdev_t* dev, u8_t endpt, u8_t *hdr, u16_t hdrlen, u8_t *snap, u16_t snapLen,
-                u8_t *tail, u16_t tailLen, zbuf_t *buf, u16_t offset)
+u32_t zfwUsbSend(zdev_t *dev, u8_t endpt, u8_t *hdr, u16_t hdrlen, u8_t *snap,
+			u16_t snapLen,	u8_t *tail, u16_t tailLen,
+			zbuf_t *buf, u16_t offset)
 {
-    u32_t status;
+	u32_t status;
 
 #ifdef ZM_CONFIG_BIG_ENDIAN
-    u32_t ii = 0;
-    u16_t *pc = NULL;
+	u32_t ii = 0;
+	u16_t *pc = NULL;
 
-    pc = (u16_t *)hdr;
-    for(ii=0; ii<(hdrlen>>1); ii++)
-    {
-        pc[ii] = cpu_to_le16(pc[ii]);
-    }
-
-    pc = (u16_t *)snap;
-    for(ii=0; ii<(snapLen>>1); ii++)
-    {
-        pc[ii] = cpu_to_le16(pc[ii]);
-    }
-
-    pc = (u16_t *)tail;
-    for(ii=0; ii<(tailLen>>1); ii++)
-    {
-        pc[ii] = cpu_to_le16(pc[ii]);
-    }
+	pc = (u16_t *)hdr;
+	for (ii = 0; ii < (hdrlen >> 1); ii++)
+		pc[ii] = cpu_to_le16(pc[ii]);
+
+	pc = (u16_t *)snap;
+	for (ii = 0; ii < (snapLen >> 1); ii++)
+		pc[ii] = cpu_to_le16(pc[ii]);
+
+	pc = (u16_t *)tail;
+	for (ii = 0; ii < (tailLen>>1); ii++)
+		pc[ii] = cpu_to_le16(pc[ii]);
 #endif
 
-    status = zfLnxUsbOut(dev, hdr, hdrlen, snap, snapLen, tail, tailLen, buf, offset);
-    if ( status == 0 )
-    {
-        return 0;
-    }
-    else
-    {
-        return 1;
-    }
+	status = zfLnxUsbOut(dev, hdr, hdrlen, snap, snapLen, tail, tailLen,
+				buf, offset);
+	if (status == 0)
+		return 0;
+	else
+		return 1;
 }
 
 /* Leave an empty line below to remove warning message on some compiler */
