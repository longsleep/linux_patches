From 54d5413204184b766c9c6ec3049619b27df439f8 Mon Sep 17 00:00:00 2001
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Sun, 26 Apr 2009 16:04:23 +0200
Subject: [PATCH 003/102] Staging: rt3070: remove kernel version compatibility wrappers

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt3070/2870_main_dev.c     |  139 -----------------------------
 drivers/staging/rt3070/common/rtusb_bulk.c |   12 --
 drivers/staging/rt3070/rt2870.h            |   24 -----
 drivers/staging/rt3070/rt_ate.h            |    4 
 drivers/staging/rt3070/rt_linux.c          |   23 ----
 drivers/staging/rt3070/rt_linux.h          |   10 --
 drivers/staging/rt3070/rt_main_dev.c       |  112 +----------------------
 drivers/staging/rt3070/sta_ioctl.c         |    4 
 8 files changed, 8 insertions(+), 320 deletions(-)

--- a/drivers/staging/rt3070/2870_main_dev.c
+++ b/drivers/staging/rt3070/2870_main_dev.c
@@ -83,26 +83,6 @@ MODULE_DEVICE_TABLE(usb, rtusb_usb_id);
 #endif
 
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-
-/**************************************************************************/
-/**************************************************************************/
-//tested for kernel 2.4 series
-/**************************************************************************/
-/**************************************************************************/
-static void *rtusb_probe(struct usb_device *dev, UINT interface,
-						const struct usb_device_id *id_table);
-static void rtusb_disconnect(struct usb_device *dev, void *ptr);
-
-struct usb_driver rtusb_driver = {
-		name:"rt2870",
-		probe:rtusb_probe,
-		disconnect:rtusb_disconnect,
-		id_table:rtusb_usb_id,
-	};
-
-#else
-
 #ifdef CONFIG_PM
 static int rt2870_suspend(struct usb_interface *intf, pm_message_t state);
 static int rt2870_resume(struct usb_interface *intf);
@@ -118,9 +98,6 @@ static int rtusb_probe (struct usb_inter
 static void rtusb_disconnect(struct usb_interface *intf);
 
 struct usb_driver rtusb_driver = {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
-	.owner = THIS_MODULE,
-#endif
 	.name="rt2870",
 	.probe=rtusb_probe,
 	.disconnect=rtusb_disconnect,
@@ -182,7 +159,6 @@ static int rt2870_resume(
 	return 0;
 }
 #endif // CONFIG_PM //
-#endif // LINUX_VERSION_CODE //
 
 
 // Init driver module
@@ -811,14 +787,7 @@ static void _rtusb_disconnect(struct usb
 			MC_CardUsed[pAd->MC_RowID] = 0; // not clear MAC address
 #endif // MULTIPLE_CARD_SUPPORT //
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-		while(MOD_IN_USE > 0)
-		{
-			MOD_DEC_USE_COUNT;
-		}
-#else
 		usb_put_dev(dev);
-#endif // LINUX_VERSION_CODE //
 
 		printk("rtusb_disconnect: pAd == NULL!\n");
 		return;
@@ -840,31 +809,17 @@ static void _rtusb_disconnect(struct usb
 		unregister_netdev (pAd->net_dev);
 	}
 	udelay(1);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-#else
 	flush_scheduled_work();
-#endif // LINUX_VERSION_CODE //
 	udelay(1);
 
 	// free net_device memory
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-	kfree(net_dev);
-#else
 	free_netdev(net_dev);
-#endif // LINUX_VERSION_CODE //
 
 	// free adapter memory
 	RTMPFreeAdapter(pAd);
 
 	// release a use of the usb device structure
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-	while(MOD_IN_USE > 0)
-	{
-		MOD_DEC_USE_COUNT;
-	}
-#else
 	usb_put_dev(dev);
-#endif // LINUX_VERSION_CODE //
 	udelay(1);
 
 	DBGPRINT(RT_DEBUG_ERROR, (" RTUSB disconnect successfully\n"));
@@ -887,22 +842,6 @@ Return Value:
 Note:
 ========================================================================
 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-static void *rtusb_probe(struct usb_device *dev, UINT interface,
-						const struct usb_device_id *id)
-{
-	PRTMP_ADAPTER pAd;
-	rt28xx_probe((void *)dev, (void *)id, interface, &pAd);
-	return (void *)pAd;
-}
-
-//Disconnect function is called within exit routine
-static void rtusb_disconnect(struct usb_device *dev, void *ptr)
-{
-	_rtusb_disconnect(dev, ((PRTMP_ADAPTER)ptr));
-}
-
-#else	/* kernel 2.6 series */
 static int rtusb_probe (struct usb_interface *intf,
 						const struct usb_device_id *id)
 {
@@ -922,7 +861,6 @@ static void rtusb_disconnect(struct usb_
 
 	_rtusb_disconnect(dev, pAd);
 }
-#endif // LINUX_VERSION_CODE //
 
 
 /*
@@ -1062,12 +1000,8 @@ Note:
 BOOLEAN RT28XXChipsetCheck(
 	IN void *_dev_p)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-	struct usb_device *dev_p = (struct usb_device *)_dev_p;
-#else
 	struct usb_interface *intf = (struct usb_interface *)_dev_p;
 	struct usb_device *dev_p = interface_to_usbdev(intf);
-#endif // LINUX_VERSION_CODE //
 	UINT32 i;
 
 
@@ -1114,19 +1048,11 @@ BOOLEAN RT28XXNetDevInit(
 	IN struct  net_device	*net_dev,
 	IN RTMP_ADAPTER 		*pAd)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-	struct usb_device *dev_p = (struct usb_device *)_dev_p;
-#else
 	struct usb_interface *intf = (struct usb_interface *)_dev_p;
 	struct usb_device *dev_p = interface_to_usbdev(intf);
-#endif // LINUX_VERSION_CODE //
 
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-	pAd->config = dev_p->config;
-#else
 	pAd->config = &dev_p->config->desc;
-#endif // LINUX_VERSION_CODE //
 	return TRUE;
 }
 
@@ -1147,70 +1073,6 @@ Return Value:
 Note:
 ========================================================================
 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-BOOLEAN RT28XXProbePostConfig(
-	IN void 				*_dev_p,
-	IN RTMP_ADAPTER 		*pAd,
-	IN INT32				interface)
-{
-	struct usb_device *dev_p = (struct usb_device *)_dev_p;
-	struct usb_interface *intf;
-	struct usb_interface_descriptor *iface_desc;
-	struct usb_endpoint_descriptor *endpoint;
-	ULONG BulkOutIdx;
-	UINT32 i;
-
-
-	/* get the active interface descriptor */
-	intf = &dev_p->actconfig->interface[interface];
-	iface_desc = &intf->altsetting[0];
-
-	/* get # of enpoints */
-	pAd->NumberOfPipes = iface_desc->bNumEndpoints;
-	DBGPRINT(RT_DEBUG_TRACE, ("NumEndpoints=%d\n", iface_desc->bNumEndpoints));
-
-	/* Configure Pipes */
-	endpoint = &iface_desc->endpoint[0];
-	BulkOutIdx = 0;
-
-	for(i=0; i<pAd->NumberOfPipes; i++)
-	{
-		if ((endpoint[i].bmAttributes == USB_ENDPOINT_XFER_BULK) &&
-			((endpoint[i].bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN))
-		{
-			pAd->BulkInEpAddr = endpoint[i].bEndpointAddress;
-			pAd->BulkInMaxPacketSize = endpoint[i].wMaxPacketSize;
-
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				("BULK IN MaximumPacketSize = %d\n", pAd->BulkInMaxPacketSize));
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				("EP address = 0x%2x  \n", endpoint[i].bEndpointAddress));
-		}
-		else if ((endpoint[i].bmAttributes == USB_ENDPOINT_XFER_BULK) &&
-				((endpoint[i].bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT))
-		{
-			// There are 6 bulk out EP. EP6 highest priority.
-			// EP1-4 is EDCA.  EP5 is HCCA.
-			pAd->BulkOutEpAddr[BulkOutIdx++] = endpoint[i].bEndpointAddress;
-			pAd->BulkOutMaxPacketSize = endpoint[i].wMaxPacketSize;
-
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				("BULK OUT MaximumPacketSize = %d\n", pAd->BulkOutMaxPacketSize));
-			DBGPRINT_RAW(RT_DEBUG_TRACE,
-				("EP address = 0x%2x  \n", endpoint[i].bEndpointAddress));
-		}
-	}
-
-	if (!(pAd->BulkInEpAddr && pAd->BulkOutEpAddr[0]))
-	{
-		printk("Could not find both bulk-in and bulk-out endpoints\n");
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-#else
 BOOLEAN RT28XXProbePostConfig(
 	IN void 				*_dev_p,
 	IN RTMP_ADAPTER 		*pAd,
@@ -1273,7 +1135,6 @@ BOOLEAN RT28XXProbePostConfig(
 
 	return TRUE;
 }
-#endif // LINUX_VERSION_CODE //
 
 
 /*
--- a/drivers/staging/rt3070/common/rtusb_bulk.c
+++ b/drivers/staging/rt3070/common/rtusb_bulk.c
@@ -52,11 +52,7 @@ void RTUSB_FILL_BULK_URB (struct urb *pU
 	void *pContext)
 {
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	usb_fill_bulk_urb(pUrb, pUsb_Dev, bulkpipe, pTransferBuf, BufSize, (usb_complete_t)Complete, pContext);
-#else
-	FILL_BULK_URB(pUrb, pUsb_Dev, bulkpipe, pTransferBuf, BufSize, Complete, pContext);
-#endif
 
 }
 
@@ -95,14 +91,12 @@ VOID	RTUSBInitTxDesc(
 						Func,
 						pTxContext);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	if (pTxContext->bAggregatible)
 		pUrb->transfer_dma	= (pTxContext->data_dma + TX_BUFFER_NORMSIZE + 2);
 	else
 		pUrb->transfer_dma	= pTxContext->data_dma;
 
 	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-#endif
 
 }
 
@@ -135,10 +129,8 @@ VOID	RTUSBInitHTTxDesc(
 						Func,
 						pTxContext);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	pUrb->transfer_dma	= (pTxContext->data_dma + pTxContext->NextBulkOutPosition);
 	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-#endif
 
 }
 
@@ -168,10 +160,8 @@ VOID	RTUSBInitRxDesc(
 						(usb_complete_t)RTUSBBulkRxComplete,
 						(void *)pRxContext);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	pUrb->transfer_dma	= pRxContext->data_dma + pAd->NextRxBulkInPosition;
 	pUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-#endif
 
 
 }
@@ -744,11 +734,9 @@ VOID	RTUSBBulkOutMLMEPacket(
 	// Init Tx context descriptor
 	RTUSBInitTxDesc(pAd, pMLMEContext, MGMTPIPEIDX, (usb_complete_t)RTUSBBulkOutMLMEPacketComplete);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	//For mgmt urb buffer, because we use sk_buff, so we need to notify the USB controller do dma mapping.
 	pUrb->transfer_dma	= 0;
 	pUrb->transfer_flags &= (~URB_NO_TRANSFER_DMA_MAP);
-#endif
 
 	pUrb = pMLMEContext->pUrb;
 	if((ret = RTUSB_SUBMIT_URB(pUrb))!=0)
--- a/drivers/staging/rt3070/rt2870.h
+++ b/drivers/staging/rt3070/rt2870.h
@@ -33,7 +33,6 @@
 
 /* rtmp_def.h */
 //
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 #define BULKAGGRE_ZISE          100
 #define RT28XX_DRVDATA_SET(_a)                                             usb_set_intfdata(_a, pAd);
 #define RT28XX_PUT_DEVICE                                                  usb_put_dev
@@ -41,15 +40,6 @@
 #define RTUSB_SUBMIT_URB(pUrb)                                             usb_submit_urb(pUrb, GFP_ATOMIC)
 #define	RTUSB_URB_ALLOC_BUFFER(pUsb_Dev, BufSize, pDma_addr)               usb_buffer_alloc(pUsb_Dev, BufSize, GFP_ATOMIC, pDma_addr)
 #define	RTUSB_URB_FREE_BUFFER(pUsb_Dev, BufSize, pTransferBuf, Dma_addr)   usb_buffer_free(pUsb_Dev, BufSize, pTransferBuf, Dma_addr)
-#else
-#define BULKAGGRE_ZISE          60
-#define RT28XX_DRVDATA_SET(_a)
-#define RT28XX_PUT_DEVICE(dev_p)
-#define RTUSB_ALLOC_URB(iso)                                               usb_alloc_urb(iso)
-#define RTUSB_SUBMIT_URB(pUrb)                                             usb_submit_urb(pUrb)
-#define RTUSB_URB_ALLOC_BUFFER(pUsb_Dev, BufSize, pDma_addr)               kmalloc(BufSize, GFP_ATOMIC)
-#define	RTUSB_URB_FREE_BUFFER(pUsb_Dev, BufSize, pTransferBuf, Dma_addr)   kfree(pTransferBuf)
-#endif
 
 #define RXBULKAGGRE_ZISE        12
 #define MAX_TXBULK_LIMIT        (LOCAL_TXBUF_SIZE*(BULKAGGRE_ZISE-1))
@@ -542,23 +532,9 @@ typedef struct usb_ctrlrequest devctrlre
 #define UNLINK_TIMEOUT_MS		3
 
 /* unlink urb	*/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,7)
 #define RTUSB_UNLINK_URB(pUrb)		usb_kill_urb(pUrb)
-#else
-#define RTUSB_UNLINK_URB(pUrb)		usb_unlink_urb(pUrb)
-#endif
 
 // Prototypes of completion funuc.
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#define RTUSBBulkOutDataPacketComplete(purb, pt_regs)    RTUSBBulkOutDataPacketComplete(purb)
-#define RTUSBBulkOutMLMEPacketComplete(pUrb, pt_regs)    RTUSBBulkOutMLMEPacketComplete(pUrb)
-#define RTUSBBulkOutNullFrameComplete(pUrb, pt_regs)     RTUSBBulkOutNullFrameComplete(pUrb)
-#define RTUSBBulkOutRTSFrameComplete(pUrb, pt_regs)      RTUSBBulkOutRTSFrameComplete(pUrb)
-#define RTUSBBulkOutPsPollComplete(pUrb, pt_regs)        RTUSBBulkOutPsPollComplete(pUrb)
-#define RTUSBBulkRxComplete(pUrb, pt_regs)               RTUSBBulkRxComplete(pUrb)
-#endif
-
-
 VOID RTUSBBulkOutDataPacketComplete(purbb_t purb, struct pt_regs *pt_regs);
 VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb, struct pt_regs *pt_regs);
 VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb, struct pt_regs *pt_regs);
--- a/drivers/staging/rt3070/rt_ate.h
+++ b/drivers/staging/rt3070/rt_ate.h
@@ -92,10 +92,6 @@ do{   int (*org_remote_display)(char *) 
 			RTMP_IRQ_UNLOCK((pLock), IrqFlags);
 
 // Prototypes of completion funuc.
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#define ATE_RTUSBBulkOutDataPacketComplete(purb, pt_regs)    ATE_RTUSBBulkOutDataPacketComplete(purb)
-#endif
-
 VOID ATE_RTUSBBulkOutDataPacketComplete(
 	IN purbb_t purb,
 	OUT struct pt_regs *pt_regs);
--- a/drivers/staging/rt3070/rt_linux.c
+++ b/drivers/staging/rt3070/rt_linux.c
@@ -1014,35 +1014,14 @@ err_free_sk_buff:
 
 void rtmp_os_thread_init(PUCHAR pThreadName, PVOID pNotify)
 {
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	daemonize(pThreadName /*"%s",pAd->net_dev->name*/);
 
 	allow_signal(SIGTERM);
 	allow_signal(SIGKILL);
 	current->flags |= PF_NOFREEZE;
-#else
-	unsigned long flags;
-
-	daemonize();
-	reparent_to_init();
-	strcpy(current->comm, pThreadName);
-
-	siginitsetinv(&current->blocked, sigmask(SIGTERM) | sigmask(SIGKILL));
 
-	/* Allow interception of SIGKILL only
-	 * Don't allow other signals to interrupt the transmission */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
-	spin_lock_irqsave(&current->sigmask_lock, flags);
-	flush_signals(current);
-	recalc_sigpending(current);
-	spin_unlock_irqrestore(&current->sigmask_lock, flags);
-#endif
-#endif
-
-    /* signal that we've started the thread */
+	/* signal that we've started the thread */
 	complete(pNotify);
-
 }
 
 void RTMP_IndicateMediaState(
--- a/drivers/staging/rt3070/rt_linux.h
+++ b/drivers/staging/rt3070/rt_linux.h
@@ -103,8 +103,6 @@ typedef int (*HARD_START_XMIT_FUNC)(stru
 #endif // CONFIG_STA_SUPPORT //
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-
 #define RTMP_TIME_AFTER(a,b)		\
 	(typecheck(unsigned long, (unsigned long)a) && \
 	 typecheck(unsigned long, (unsigned long)b) && \
@@ -115,11 +113,7 @@ typedef int (*HARD_START_XMIT_FUNC)(stru
 	 typecheck(unsigned long, (unsigned long)b) && \
 	 ((long)(a) - (long)(b) >= 0))
 #define RTMP_TIME_BEFORE(a,b)	RTMP_TIME_AFTER_EQ(b,a)
-#else
-#define RTMP_TIME_AFTER(a,b) time_after(a, b)
-#endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 #define RT_MOD_INC_USE_COUNT() \
 	if (!try_module_get(THIS_MODULE)) \
 	{ \
@@ -128,10 +122,6 @@ typedef int (*HARD_START_XMIT_FUNC)(stru
 	}
 
 #define RT_MOD_DEC_USE_COUNT() module_put(THIS_MODULE);
-#else
-#define RT_MOD_INC_USE_COUNT()	MOD_INC_USE_COUNT;
-#define RT_MOD_DEC_USE_COUNT() MOD_DEC_USE_COUNT;
-#endif
 
 #define OS_HZ			HZ
 
--- a/drivers/staging/rt3070/rt_main_dev.c
+++ b/drivers/staging/rt3070/rt_main_dev.c
@@ -58,11 +58,7 @@ UINT32 CW_MAX_IN_BITS;
 
 char *mac = "";		   // default 00:00:00:00:00:00
 char *hostname = "";		   // default CMPC
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,12)
-MODULE_PARM (mac, "s");
-#else
 module_param (mac, charp, 0);
-#endif
 MODULE_PARM_DESC (mac, "rt28xx: wireless mac addr");
 
 
@@ -84,13 +80,6 @@ INT __devinit rt28xx_probe(IN void *_dev
 static int rt28xx_init(IN struct net_device *net_dev);
 INT rt28xx_send_packets(IN struct sk_buff *skb_p, IN struct net_device *net_dev);
 
-#if LINUX_VERSION_CODE <= 0x20402	// Red Hat 7.1
-struct net_device *alloc_netdev(
-	int sizeof_priv,
-	const char *mask,
-	void (*setup)(struct net_device *));
-#endif // LINUX_VERSION_CODE //
-
 static void CfgInitHook(PRTMP_ADAPTER pAd);
 //static BOOLEAN RT28XXAvailRANameAssign(IN CHAR *name_p);
 
@@ -362,11 +351,7 @@ int rt28xx_close(IN PNET_DEV dev)
 		}
 		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
 		msleep(UNLINK_TIMEOUT_MS);	//Time in millisecond
-#else
-		RTMPusecDelay(UNLINK_TIMEOUT_MS*1000);	//Time in microsecond
-#endif
 		i++;
 	}
 	pAd->wait = NULL;
@@ -910,25 +895,11 @@ static NDIS_STATUS rt_ieee80211_if_setup
 #endif // MULTIPLE_CARD_SUPPORT //
 		sprintf(slot_name, "ra%d", i);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
-        device = dev_get_by_name(dev_net(dev), slot_name);
-#else
-        device = dev_get_by_name(dev->nd_net, slot_name);
-#endif
-#else
-		device = dev_get_by_name(slot_name);
-#endif
-		if (device != NULL) dev_put(device);
-#else
-		for (device = dev_base; device != NULL; device = device->next)
-		{
-			if (strncmp(device->name, slot_name, 4) == 0)
-				break;
-		}
-#endif
-		if(device == NULL)
+		device = dev_get_by_name(dev_net(dev), slot_name);
+		if (device != NULL)
+			dev_put(device);
+
+		if (device == NULL)
 			break;
 	}
 
@@ -1346,14 +1317,10 @@ INT __devinit   rt28xx_probe(
     INT                 status;
 	PVOID				handle;
 #ifdef RT2870
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
-	struct usb_device *dev_p = (struct usb_device *)_dev_p;
-#else
 	struct usb_interface *intf = (struct usb_interface *)_dev_p;
 	struct usb_device *dev_p = interface_to_usbdev(intf);
 
 	dev_p = usb_get_dev(dev_p);
-#endif // LINUX_VERSION_CODE //
 #endif // RT2870 //
 
 
@@ -1365,22 +1332,11 @@ INT __devinit   rt28xx_probe(
 //	if (RT28XXChipsetCheck(_dev_p) == FALSE)
 //		goto err_out;
 
-#if LINUX_VERSION_CODE <= 0x20402       // Red Hat 7.1
-    net_dev = alloc_netdev(sizeof(PRTMP_ADAPTER), "eth%d", ether_setup);
-#else
     net_dev = alloc_etherdev(sizeof(PRTMP_ADAPTER));
-#endif
     if (net_dev == NULL)
     {
         printk("alloc_netdev failed\n");
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
-		module_put(THIS_MODULE);
-#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
-#else
-		MOD_DEC_USE_COUNT;
-#endif
         goto err_out;
     }
 
@@ -1388,19 +1344,13 @@ INT __devinit   rt28xx_probe(
 //	if (rt_ieee80211_if_setup(net_dev) != NDIS_STATUS_SUCCESS)
 //		goto err_out;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-    SET_MODULE_OWNER(net_dev);
-#endif
-
 	netif_stop_queue(net_dev);
 #ifdef NATIVE_WPA_SUPPLICANT_SUPPORT
 /* for supporting Network Manager */
 /* Set the sysfs physical device reference for the network logical device
  * if set prior to registration will cause a symlink during initialization.
  */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
     SET_NETDEV_DEV(net_dev, &(dev_p->dev));
-#endif
 #endif // NATIVE_WPA_SUPPLICANT_SUPPORT //
 
 	// Allocate RTMP_ADAPTER miniport adapter structure
@@ -1424,13 +1374,8 @@ INT __devinit   rt28xx_probe(
 //	RT28XXAvailRANameAssign(net_dev->name);
 
 	// Post config
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if (RT28XXProbePostConfig(_dev_p, pAd, argc) == FALSE)
-		goto err_out_unmap;
-#else
 	if (RT28XXProbePostConfig(_dev_p, pAd, 0) == FALSE)
 		goto err_out_unmap;
-#endif // LINUX_VERSION_CODE //
 
 #ifdef CONFIG_STA_SUPPORT
 	pAd->OpMode = OPMODE_STA;
@@ -1475,20 +1420,12 @@ err_out_unmap:
 	RT28XX_UNMAP();
 
 err_out_free_netdev:
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-    free_netdev(net_dev);
-#else
-	kfree(net_dev);
-#endif
+	free_netdev(net_dev);
 
 err_out:
 	RT28XX_PUT_DEVICE(dev_p);
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	return (LONG)NULL;
-#else
-    return -ENODEV; /* probe fail */
-#endif // LINUX_VERSION_CODE //
+	return -ENODEV; /* probe fail */
 } /* End of rt28xx_probe */
 
 
@@ -1609,41 +1546,6 @@ INT rt28xx_send_packets(
 
 
 
-#if LINUX_VERSION_CODE <= 0x20402	// Red Hat 7.1
-//static struct net_device *alloc_netdev(int sizeof_priv, const char *mask, void (*setup)(struct net_device *)) //sample
-struct net_device *alloc_netdev(
-	int sizeof_priv,
-	const char *mask,
-	void (*setup)(struct net_device *))
-{
-    struct net_device	*dev;
-    INT					alloc_size;
-
-
-    /* ensure 32-byte alignment of the private area */
-    alloc_size = sizeof (*dev) + sizeof_priv + 31;
-
-    dev = (struct net_device *) kmalloc(alloc_size, GFP_KERNEL);
-    if (dev == NULL)
-    {
-        DBGPRINT(RT_DEBUG_ERROR,
-				("alloc_netdev: Unable to allocate device memory.\n"));
-        return NULL;
-    }
-
-    memset(dev, 0, alloc_size);
-
-    if (sizeof_priv)
-        dev->ml_priv = (void *) (((long)(dev + 1) + 31) & ~31);
-
-    setup(dev);
-    strcpy(dev->name, mask);
-
-    return dev;
-}
-#endif // LINUX_VERSION_CODE //
-
-
 void CfgInitHook(PRTMP_ADAPTER pAd)
 {
 	pAd->bBroadComHT = TRUE;
--- a/drivers/staging/rt3070/sta_ioctl.c
+++ b/drivers/staging/rt3070/sta_ioctl.c
@@ -677,11 +677,9 @@ int rt_ioctl_siwmode(struct net_device *
 		case IW_MODE_INFRA:
 			Set_NetworkType_Proc(pAdapter, "Infra");
 			break;
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20))
         case IW_MODE_MONITOR:
 			Set_NetworkType_Proc(pAdapter, "Monitor");
 			break;
-#endif
 		default:
 			DBGPRINT(RT_DEBUG_TRACE, ("===>rt_ioctl_siwmode::SIOCSIWMODE (unknown %d)\n", *mode));
 			return -EINVAL;
@@ -703,12 +701,10 @@ int rt_ioctl_giwmode(struct net_device *
 		*mode = IW_MODE_ADHOC;
     else if (INFRA_ON(pAdapter))
 		*mode = IW_MODE_INFRA;
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20))
     else if (MONITOR_ON(pAdapter))
     {
         *mode = IW_MODE_MONITOR;
     }
-#endif
     else
         *mode = IW_MODE_AUTO;
 
