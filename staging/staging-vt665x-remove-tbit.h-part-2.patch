From lieb@canonical.com  Mon Aug 17 12:55:26 2009
From: Jim Lieb <lieb@canonical.com>
Date: Wed, 12 Aug 2009 14:54:16 -0700
Subject: Staging: vt665x: remove tbit.h part 2
To: Greg KH <greg@kroah.com>, Forest Bond <forest@alittletooquiet.net>, Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Cc: jim.lieb@canonical.com, Jim Lieb <lieb@canonical.com>
Message-ID: <1250114056-13843-15-git-send-email-lieb@canonical.com>


Remove use of tbit macros adn remove header file.

Signed-off-by: Jim Lieb <lieb@canonical.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/vt6655/baseband.c    |    9 +--
 drivers/staging/vt6655/bssdb.c       |   19 +++---
 drivers/staging/vt6655/card.c        |    7 +-
 drivers/staging/vt6655/device_main.c |   23 +++----
 drivers/staging/vt6655/dpc.c         |   11 +--
 drivers/staging/vt6655/key.c         |    1 
 drivers/staging/vt6655/mac.c         |   75 ++++++++++++-------------
 drivers/staging/vt6655/mib.c         |  101 +++++++++++++++++------------------
 drivers/staging/vt6655/michael.c     |    1 
 drivers/staging/vt6655/power.c       |    2 
 drivers/staging/vt6655/rf.c          |    3 -
 drivers/staging/vt6655/rxtx.c        |    1 
 drivers/staging/vt6655/srom.c        |   15 ++---
 drivers/staging/vt6655/tbit.h        |   73 -------------------------
 drivers/staging/vt6655/tcrc.c        |    1 
 drivers/staging/vt6655/tether.c      |    3 -
 drivers/staging/vt6655/tkip.c        |    1 
 drivers/staging/vt6655/vntwifi.c     |    3 -
 drivers/staging/vt6655/wmgr.c        |    1 
 19 files changed, 129 insertions(+), 221 deletions(-)
 delete mode 100644 drivers/staging/vt6655/tbit.h

--- a/drivers/staging/vt6655/baseband.c
+++ b/drivers/staging/vt6655/baseband.c
@@ -50,7 +50,6 @@
  */
 
 #include "tmacro.h"
-#include "tbit.h"
 #include "tether.h"
 #include "mac.h"
 #include "baseband.h"
@@ -2029,7 +2028,7 @@ BOOL BBbReadEmbeded (DWORD_PTR dwIoBase,
     // W_MAX_TIMEOUT is the timeout period
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_BBREGCTL, &byValue);
-        if (BITbIsBitOn(byValue, BBREGCTL_DONE))
+        if (byValue & BBREGCTL_DONE)
             break;
     }
 
@@ -2074,7 +2073,7 @@ BOOL BBbWriteEmbeded (DWORD_PTR dwIoBase
     // W_MAX_TIMEOUT is the timeout period
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_BBREGCTL, &byValue);
-        if (BITbIsBitOn(byValue, BBREGCTL_DONE))
+        if (byValue & BBREGCTL_DONE)
             break;
     }
 
@@ -2106,7 +2105,7 @@ BOOL BBbIsRegBitsOn (DWORD_PTR dwIoBase,
     BYTE byOrgData;
 
     BBbReadEmbeded(dwIoBase, byBBAddr, &byOrgData);
-    return BITbIsAllBitsOn(byOrgData, byTestBits);
+    return (byOrgData & byTestBits) == byTestBits;
 }
 
 
@@ -2129,7 +2128,7 @@ BOOL BBbIsRegBitsOff (DWORD_PTR dwIoBase
     BYTE byOrgData;
 
     BBbReadEmbeded(dwIoBase, byBBAddr, &byOrgData);
-    return BITbIsAllBitsOff(byOrgData, byTestBits);
+    return (byOrgData & byTestBits) == 0;
 }
 
 /*
--- a/drivers/staging/vt6655/bssdb.c
+++ b/drivers/staging/vt6655/bssdb.c
@@ -39,7 +39,6 @@
  *
  */
 
-#include "tbit.h"
 #include "ttype.h"
 #include "tmacro.h"
 #include "tether.h"
@@ -1035,14 +1034,14 @@ BSSvSecondCallBack(
  //2008-4-14 <add> by chester for led issue
 #ifdef FOR_LED_ON_NOTEBOOK
 MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
-if (((BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA)&&(pDevice->bHWRadioOff == FALSE))||(BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA)&&(pDevice->bHWRadioOff == TRUE)))&&(cc==FALSE)){
+if ((( !(pDevice->byGPIO & GPIO0_DATA)&&(pDevice->bHWRadioOff == FALSE))||((pDevice->byGPIO & GPIO0_DATA)&&(pDevice->bHWRadioOff == TRUE)))&&(cc==FALSE)){
 cc=TRUE;
 }
 else if(cc==TRUE){
 
 if(pDevice->bHWRadioOff == TRUE){
-            if (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA))
-//||(BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOn(pDevice->byRadioCtl, EEP_RADIOCTL_INV)))
+            if ( !(pDevice->byGPIO & GPIO0_DATA))
+//||( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV)))
 {if(status==1) goto start;
 status=1;
 CARDbRadioPowerOff(pDevice);
@@ -1053,15 +1052,15 @@ CARDbRadioPowerOff(pDevice);
                 pDevice->bLinkPass = FALSE;
 
 }
-  if (BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA))
-//||(BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOn(pDevice->byRadioCtl, EEP_RADIOCTL_INV)))
+  if (pDevice->byGPIO &GPIO0_DATA)
+//||( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV)))
 {if(status==2) goto start;
 status=2;
 CARDbRadioPowerOn(pDevice);
 } }
 else{
-            if (BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA))
-//||(BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOn(pDevice->byRadioCtl, EEP_RADIOCTL_INV)))
+            if (pDevice->byGPIO & GPIO0_DATA)
+//||( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV)))
 {if(status==3) goto start;
 status=3;
 CARDbRadioPowerOff(pDevice);
@@ -1072,8 +1071,8 @@ CARDbRadioPowerOff(pDevice);
                 pDevice->bLinkPass = FALSE;
 
 }
-  if (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA))
-//||(BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOn(pDevice->byRadioCtl, EEP_RADIOCTL_INV)))
+  if ( !(pDevice->byGPIO & GPIO0_DATA))
+//||( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV)))
 {if(status==4) goto start;
 status=4;
 CARDbRadioPowerOn(pDevice);
--- a/drivers/staging/vt6655/card.c
+++ b/drivers/staging/vt6655/card.c
@@ -47,7 +47,6 @@
 
 #include "tmacro.h"
 #include "card.h"
-#include "tbit.h"
 #include "baseband.h"
 #include "mac.h"
 #include "desc.h"
@@ -2374,7 +2373,7 @@ CARDbyAutoChannelSelect(
                 }
                 if (sChannelTbl[ii].byMAP == 0) {
                     return ((BYTE) ii);
-                } else if (BITbIsBitOff(sChannelTbl[ii].byMAP, 0x08)) {
+                } else if ( !(sChannelTbl[ii].byMAP & 0x08)) {
                     byOptionChannel = (BYTE) ii;
                 }
             }
@@ -2385,7 +2384,7 @@ CARDbyAutoChannelSelect(
             if (sChannelTbl[ii].bValid == TRUE) {
                 if (sChannelTbl[ii].byMAP == 0) {
                     aiWeight[ii] += 100;
-                } else if (BITbIsBitOn(sChannelTbl[ii].byMAP, 0x01)) {
+                } else if (sChannelTbl[ii].byMAP & 0x01) {
                     if (ii > 3) {
                         aiWeight[ii-3] -= 10;
                     }
@@ -2973,7 +2972,7 @@ BOOL CARDbGetCurrentTSF (DWORD_PTR dwIoB
     MACvRegBitsOn(dwIoBase, MAC_REG_TFTCTL, TFTCTL_TSFCNTRRD);
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_TFTCTL, &byData);
-        if (BITbIsBitOff(byData, TFTCTL_TSFCNTRRD))
+        if ( !(byData & TFTCTL_TSFCNTRRD))
             break;
     }
     if (ww == W_MAX_TIMEOUT)
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -62,7 +62,6 @@
 
 #include "device.h"
 #include "card.h"
-#include "tbit.h"
 #include "baseband.h"
 #include "mac.h"
 #include "tether.h"
@@ -789,8 +788,8 @@ else
             MACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);
 //2008-4-14 <add> by chester for led issue
  #ifdef FOR_LED_ON_NOTEBOOK
-if (BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA)){pDevice->bHWRadioOff = TRUE;}
-if (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA)){pDevice->bHWRadioOff = FALSE;}
+if (pDevice->byGPIO & GPIO0_DATA){pDevice->bHWRadioOff = TRUE;}
+if ( !(pDevice->byGPIO & GPIO0_DATA)){pDevice->bHWRadioOff = FALSE;}
 
             }
         if ( (pDevice->bRadioControlOff == TRUE)) {
@@ -798,8 +797,8 @@ if (BITbIsBitOff(pDevice->byGPIO,GPIO0_D
         }
 else  CARDbRadioPowerOn(pDevice);
 #else
-            if ((BITbIsBitOn(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOff(pDevice->byRadioCtl, EEP_RADIOCTL_INV)) ||
-                (BITbIsBitOff(pDevice->byGPIO,GPIO0_DATA) && BITbIsBitOn(pDevice->byRadioCtl, EEP_RADIOCTL_INV))) {
+            if (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||
+                ( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {
                 pDevice->bHWRadioOff = TRUE;
             }
         }
@@ -1703,7 +1702,7 @@ static int device_tx_srv(PSDevice pDevic
                          uFIFOHeaderSize
                          );
 
-                if (BITbIsBitOff(byTsr1, TSR1_TERR)) {
+                if ( !(byTsr1 & TSR1_TERR)) {
                     if (byTsr0 != 0) {
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",
                            (INT)uIdx, byTsr1, byTsr0);
@@ -1735,7 +1734,7 @@ static int device_tx_srv(PSDevice pDevic
 	            }
             }
 
-            if (BITbIsBitOn(byTsr1, TSR1_TERR)) {
+            if (byTsr1 & TSR1_TERR) {
             if ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",
                           (INT)uIdx, byTsr1, byTsr0);
@@ -2691,7 +2690,7 @@ static  irqreturn_t  device_intr(int irq
     /*
       // 2008-05-21 <mark> by Richardtai, we can't read RSSI here, because no packet bound with RSSI
 
-    	if ((BITbIsBitOn(pDevice->dwIsr, ISR_RXDMA0)) &&
+    	if ((pDevice->dwIsr & ISR_RXDMA0) &&
         (pDevice->byLocalID != REV_ID_VT3253_B0) &&
         (pDevice->bBSSIDFilter == TRUE)) {
         // update RSSI
@@ -2732,7 +2731,7 @@ static  irqreturn_t  device_intr(int irq
 
         if (pDevice->byLocalID > REV_ID_VT3253_B1) {
 
-            if (BITbIsBitOn(pDevice->dwIsr, ISR_MEASURESTART)) {
+            if (pDevice->dwIsr & ISR_MEASURESTART) {
                 // 802.11h measure start
                 pDevice->byOrgChannel = pDevice->byCurrentCh;
                 VNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byOrgRCR));
@@ -2764,7 +2763,7 @@ static  irqreturn_t  device_intr(int irq
                     MACvSelectPage0(pDevice->PortOffset);
                 }
             }
-            if (BITbIsBitOn(pDevice->dwIsr, ISR_MEASUREEND)) {
+            if (pDevice->dwIsr & ISR_MEASUREEND) {
                 // 802.11h measure end
                 pDevice->bMeasureInProgress = FALSE;
                 VNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byOrgRCR);
@@ -2783,7 +2782,7 @@ static  irqreturn_t  device_intr(int irq
                 MACvSelectPage1(pDevice->PortOffset);
                 MACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);
                 MACvSelectPage0(pDevice->PortOffset);
-                if (BITbIsBitOn(byData, MSRCTL_FINISH)) {
+                if (byData & MSRCTL_FINISH) {
                     // measure success
                     s_vCompleteCurrentMeasure(pDevice, 0);
                 } else {
@@ -2791,7 +2790,7 @@ static  irqreturn_t  device_intr(int irq
                     s_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_LATE);
                 }
             }
-            if (BITbIsBitOn(pDevice->dwIsr, ISR_QUIETSTART)) {
+            if (pDevice->dwIsr & ISR_QUIETSTART) {
                 do {
                     ;
                 } while (CARDbStartQuiet(pDevice) == FALSE);
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -50,7 +50,6 @@
 #include "tcrc.h"
 #include "wctl.h"
 #include "wroute.h"
-#include "tbit.h"
 #include "hostap.h"
 #include "rf.h"
 #include "iowpa.h"
@@ -441,7 +440,7 @@ device_receive_frame (
         dwDuration = (FrameSize << 4);
         dwDuration /= acbyRxRate[*pbyRxRate%MAX_RATE];
         if (*pbyRxRate <= RATE_11M) {
-            if (BITbIsBitOn(*pbyRxSts, 0x01)) {
+            if (*pbyRxSts & 0x01) {
                 // long preamble
                 dwDuration += 192;
             } else {
@@ -572,7 +571,7 @@ device_receive_frame (
     //remove the CRC length
     FrameSize -= U_CRC_LEN;
 
-    if ((BITbIsAllBitsOff(*pbyRsr, (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
+    if (( !(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI))) && // unicast address
         (IS_FRAGMENT_PKT((skb->data+4)))
         ) {
         // defragment
@@ -661,7 +660,7 @@ device_receive_frame (
     else {
         if (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {
             //In AP mode, hw only check addr1(BSSID or RA) if equal to local MAC.
-            if (BITbIsBitOff(*pbyRsr, RSR_BSSIDOK)) {
+            if ( !(*pbyRsr & RSR_BSSIDOK)) {
                 if (bDeFragRx) {
                     if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
                         DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
@@ -674,7 +673,7 @@ device_receive_frame (
         else {
             // discard DATA packet while not associate || BSSID error
             if ((pDevice->bLinkPass == FALSE) ||
-                BITbIsBitOff(*pbyRsr, RSR_BSSIDOK)) {
+                !(*pbyRsr & RSR_BSSIDOK)) {
                 if (bDeFragRx) {
                     if (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {
                         DBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",
@@ -712,7 +711,7 @@ device_receive_frame (
 
     if (pDevice->bEnablePSMode) {
         if (IS_FC_MOREDATA((skb->data+4))) {
-            if (BITbIsBitOn(*pbyRsr, RSR_ADDROK)) {
+            if (*pbyRsr & RSR_ADDROK) {
                 //PSbSendPSPOLL((PSDevice)pDevice);
             }
         }
--- a/drivers/staging/vt6655/key.c
+++ b/drivers/staging/vt6655/key.c
@@ -37,7 +37,6 @@
  */
 
 #include "tmacro.h"
-#include "tbit.h"
 #include "key.h"
 #include "mac.h"
 
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -69,7 +69,6 @@
  */
 
 #include "tmacro.h"
-#include "tbit.h"
 #include "tether.h"
 #include "mac.h"
 
@@ -146,7 +145,7 @@ BOOL MACbIsRegBitsOn (DWORD_PTR dwIoBase
     BYTE byData;
 
     VNSvInPortB(dwIoBase + byRegOfs, &byData);
-    return BITbIsAllBitsOn(byData, byTestBits);
+    return (byData & byTestBits) == byTestBits;
 }
 
 /*
@@ -169,7 +168,7 @@ BOOL MACbIsRegBitsOff (DWORD_PTR dwIoBas
     BYTE byData;
 
     VNSvInPortB(dwIoBase + byRegOfs, &byData);
-    return BITbIsAllBitsOff(byData, byTestBits);
+    return !(byData & byTestBits);
 }
 
 /*
@@ -565,7 +564,7 @@ BOOL MACbIsInLoopbackMode (DWORD_PTR dwI
     BYTE byOrgValue;
 
     VNSvInPortB(dwIoBase + MAC_REG_TEST, &byOrgValue);
-    if (BITbIsAnyBitsOn(byOrgValue, (TEST_LBINT | TEST_LBEXT)))
+    if (byOrgValue & (TEST_LBINT | TEST_LBEXT))
         return TRUE;
     return FALSE;
 }
@@ -592,7 +591,7 @@ void MACvSetPacketFilter (DWORD_PTR dwIo
     // if only in DIRECTED mode, multicast-address will set to zero,
     // but if other mode exist (e.g. PROMISCUOUS), multicast-address
     // will be open
-    if (BITbIsBitOn(wFilterType, PKT_TYPE_DIRECTED)) {
+    if (wFilterType & PKT_TYPE_DIRECTED) {
         // set multicast address to accept none
         MACvSelectPage1(dwIoBase);
         VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0L);
@@ -600,7 +599,7 @@ void MACvSetPacketFilter (DWORD_PTR dwIo
         MACvSelectPage0(dwIoBase);
     }
 
-    if (BITbIsAnyBitsOn(wFilterType, PKT_TYPE_PROMISCUOUS | PKT_TYPE_ALL_MULTICAST)) {
+    if (wFilterType & (PKT_TYPE_PROMISCUOUS | PKT_TYPE_ALL_MULTICAST)) {
         // set multicast address to accept all
         MACvSelectPage1(dwIoBase);
         VNSvOutPortD(dwIoBase + MAC_REG_MAR0, 0xFFFFFFFFL);
@@ -608,20 +607,20 @@ void MACvSetPacketFilter (DWORD_PTR dwIo
         MACvSelectPage0(dwIoBase);
     }
 
-    if (BITbIsBitOn(wFilterType, PKT_TYPE_PROMISCUOUS)) {
+    if (wFilterType & PKT_TYPE_PROMISCUOUS) {
 
         byNewRCR |= (RCR_RXALLTYPE | RCR_UNICAST | RCR_MULTICAST | RCR_BROADCAST);
 
         byNewRCR &= ~RCR_BSSID;
     }
 
-    if (BITbIsAnyBitsOn(wFilterType, (PKT_TYPE_ALL_MULTICAST | PKT_TYPE_MULTICAST)))
+    if (wFilterType & (PKT_TYPE_ALL_MULTICAST | PKT_TYPE_MULTICAST))
         byNewRCR |= RCR_MULTICAST;
 
-    if (BITbIsBitOn(wFilterType, PKT_TYPE_BROADCAST))
+    if (wFilterType & PKT_TYPE_BROADCAST)
         byNewRCR |= RCR_BROADCAST;
 
-    if (BITbIsBitOn(wFilterType, PKT_TYPE_ERROR_CRC))
+    if (wFilterType & PKT_TYPE_ERROR_CRC)
         byNewRCR |= RCR_ERRCRC;
 
     VNSvInPortB(dwIoBase + MAC_REG_RCR,  &byOldRCR);
@@ -785,7 +784,7 @@ BOOL MACbSoftwareReset (DWORD_PTR dwIoBa
 
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if (BITbIsBitOff(byData, HOSTCR_SOFTRST))
+        if ( !(byData & HOSTCR_SOFTRST))
             break;
     }
     if (ww == W_MAX_TIMEOUT)
@@ -853,7 +852,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     VNSvOutPortD(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_CLRRUN);
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL0, &dwData);
-        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+        if (!(dwData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -863,7 +862,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_RXDMACTL1, &dwData);
-        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+        if ( !(dwData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -877,7 +876,7 @@ BOOL MACbSafeRxOff (DWORD_PTR dwIoBase)
     // W_MAX_TIMEOUT is the timeout period
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if (BITbIsAllBitsOff(byData, HOSTCR_RXONST))
+        if ( !(byData & HOSTCR_RXONST))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -916,7 +915,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
 
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_TXDMACTL0, &dwData);
-        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+        if ( !(dwData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -926,7 +925,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_AC0DMACTL, &dwData);
-        if (BITbIsAllBitsOff(dwData, DMACTL_RUN))
+        if ( !(dwData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -941,7 +940,7 @@ BOOL MACbSafeTxOff (DWORD_PTR dwIoBase)
     // W_MAX_TIMEOUT is the timeout period
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_HOSTCR, &byData);
-        if (BITbIsAllBitsOff(byData, HOSTCR_TXONST))
+        if ( !(byData & HOSTCR_TXONST))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1049,7 +1048,7 @@ void MACvInitialize (DWORD_PTR dwIoBase)
     //while (TRUE) {
     //    U8 u8Data;
     //    VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &u8Data);
-    //    if (BITbIsBitOff(u8Data, I2MCSR_AUTOLD))
+    //    if ( !(u8Data & I2MCSR_AUTOLD))
     //        break;
     //}
 
@@ -1087,19 +1086,19 @@ BYTE    byData;
 BYTE    byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byOrgDMACtl);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0+2, DMACTL_RUN);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL0, &byData);
-        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+        if ( !(byData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x13);
     }
     VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR0, dwCurrDescAddr);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL0, DMACTL_RUN);
     }
 }
@@ -1125,19 +1124,19 @@ BYTE    byData;
 BYTE    byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byOrgDMACtl);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1+2, DMACTL_RUN);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_RXDMACTL1, &byData);
-        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+        if ( !(byData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x14);
     }
     VNSvOutPortD(dwIoBase + MAC_REG_RXDMAPTR1, dwCurrDescAddr);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_RXDMACTL1, DMACTL_RUN);
     }
 }
@@ -1163,19 +1162,19 @@ BYTE    byData;
 BYTE    byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byOrgDMACtl);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
-        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+        if ( !(byData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
         DBG_PORT80(0x25);
     }
     VNSvOutPortD(dwIoBase + MAC_REG_TXDMAPTR0, dwCurrDescAddr);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0, DMACTL_RUN);
     }
 }
@@ -1202,12 +1201,12 @@ BYTE    byData;
 BYTE    byOrgDMACtl;
 
     VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byOrgDMACtl);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
     }
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
-        if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+        if (!(byData & DMACTL_RUN))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1215,7 +1214,7 @@ BYTE    byOrgDMACtl;
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" DBG_PORT80(0x26)\n");
     }
     VNSvOutPortD(dwIoBase + MAC_REG_AC0DMAPTR, dwCurrDescAddr);
-    if (BITbIsAllBitsOn(byOrgDMACtl, DMACTL_RUN)) {
+    if (byOrgDMACtl & DMACTL_RUN) {
         VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL, DMACTL_RUN);
     }
 }
@@ -1257,7 +1256,7 @@ UINT uu,ii;
         for (uu = 0; uu < uDelay; uu++) {
             VNSvInPortB(dwIoBase + MAC_REG_TMCTL0, &byValue);
             if ((byValue == 0) ||
-                (BITbIsAllBitsOn(byValue, TMCTL_TSUSP))) {
+                (byValue & TMCTL_TSUSP)) {
                 VNSvOutPortB(dwIoBase + MAC_REG_TMCTL0, 0);
                 return;
             }
@@ -1329,14 +1328,14 @@ UINT ww = 0;
         VNSvOutPortB(dwIoBase + MAC_REG_TXDMACTL0+2, DMACTL_RUN);
         for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
             VNSvInPortB(dwIoBase + MAC_REG_TXDMACTL0, &byData);
-            if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+            if ( !(byData & DMACTL_RUN))
                 break;
         }
     } else if (idx == TYPE_AC0DMA) {
         VNSvOutPortB(dwIoBase + MAC_REG_AC0DMACTL+2, DMACTL_RUN);
         for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
             VNSvInPortB(dwIoBase + MAC_REG_AC0DMACTL, &byData);
-            if (BITbIsAllBitsOff(byData, DMACTL_RUN))
+            if ( !(byData & DMACTL_RUN))
                 break;
         }
     }
@@ -1354,14 +1353,14 @@ void MACvClearBusSusInd (DWORD_PTR dwIoB
     UINT ww;
     // check if BcnSusInd enabled
     VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-    if(BITbIsBitOff(dwOrgValue, EnCFG_BcnSusInd))
+    if( !(dwOrgValue & EnCFG_BcnSusInd))
         return;
     //Set BcnSusClr
     dwOrgValue = dwOrgValue | EnCFG_BcnSusClr;
     VNSvOutPortD(dwIoBase + MAC_REG_ENCFG, dwOrgValue);
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-        if(BITbIsBitOff(dwOrgValue, EnCFG_BcnSusInd))
+        if( !(dwOrgValue & EnCFG_BcnSusInd))
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1383,7 +1382,7 @@ void MACvEnableBusSusEn (DWORD_PTR dwIoB
     VNSvOutPortB(dwIoBase + MAC_REG_ENCFG, byOrgValue);
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_ENCFG , &dwOrgValue);
-        if(BITbIsBitOn(dwOrgValue, EnCFG_BcnSusInd))
+        if(dwOrgValue & EnCFG_BcnSusInd)
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1406,7 +1405,7 @@ BOOL MACbFlushSYNCFifo (DWORD_PTR dwIoBa
     // Check if SyncFlushOK
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_MACCR , &byOrgValue);
-        if(BITbIsBitOn(byOrgValue, MACCR_SYNCFLUSHOK))
+        if(byOrgValue & MACCR_SYNCFLUSHOK)
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
@@ -1430,7 +1429,7 @@ BOOL MACbPSWakeup (DWORD_PTR dwIoBase)
     // Check if SyncFlushOK
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortB(dwIoBase + MAC_REG_PSCTL , &byOrgValue);
-        if(BITbIsBitOn(byOrgValue, PSCTL_WAKEDONE))
+        if(byOrgValue & PSCTL_WAKEDONE)
             break;
     }
     if (ww == W_MAX_TIMEOUT) {
--- a/drivers/staging/vt6655/mib.c
+++ b/drivers/staging/vt6655/mib.c
@@ -39,7 +39,6 @@
 
 #include "upc.h"
 #include "mac.h"
-#include "tbit.h"
 #include "tether.h"
 #include "mib.h"
 #include "wctl.h"
@@ -104,58 +103,58 @@ void STAvUpdateIsrStatCounter (PSStatCou
     }
 
 //Added by Kyle
-    if (BITbIsBitOn(dwIsr, ISR_TXDMA0))               // ISR, bit0
+    if (dwIsr & ISR_TXDMA0)               // ISR, bit0
         pStatistic->ISRStat.dwIsrTx0OK++;             // TXDMA0 successful
 
-    if (BITbIsBitOn(dwIsr, ISR_AC0DMA))               // ISR, bit1
+    if (dwIsr & ISR_AC0DMA)               // ISR, bit1
         pStatistic->ISRStat.dwIsrAC0TxOK++;           // AC0DMA successful
 
-    if (BITbIsBitOn(dwIsr, ISR_BNTX))                 // ISR, bit2
+    if (dwIsr & ISR_BNTX)                 // ISR, bit2
         pStatistic->ISRStat.dwIsrBeaconTxOK++;        // BeaconTx successful
 
-    if (BITbIsBitOn(dwIsr, ISR_RXDMA0))               // ISR, bit3
+    if (dwIsr & ISR_RXDMA0)               // ISR, bit3
         pStatistic->ISRStat.dwIsrRx0OK++;             // Rx0 successful
 
-    if (BITbIsBitOn(dwIsr, ISR_TBTT))                 // ISR, bit4
+    if (dwIsr & ISR_TBTT)                 // ISR, bit4
         pStatistic->ISRStat.dwIsrTBTTInt++;           // TBTT successful
 
-    if (BITbIsBitOn(dwIsr, ISR_SOFTTIMER))            // ISR, bit6
+    if (dwIsr & ISR_SOFTTIMER)            // ISR, bit6
         pStatistic->ISRStat.dwIsrSTIMERInt++;
 
-    if (BITbIsBitOn(dwIsr, ISR_WATCHDOG))             // ISR, bit7
+    if (dwIsr & ISR_WATCHDOG)             // ISR, bit7
         pStatistic->ISRStat.dwIsrWatchDog++;
 
-    if (BITbIsBitOn(dwIsr, ISR_FETALERR))             // ISR, bit8
+    if (dwIsr & ISR_FETALERR)             // ISR, bit8
         pStatistic->ISRStat.dwIsrUnrecoverableError++;
 
-    if (BITbIsBitOn(dwIsr, ISR_SOFTINT))              // ISR, bit9
+    if (dwIsr & ISR_SOFTINT)              // ISR, bit9
         pStatistic->ISRStat.dwIsrSoftInterrupt++;     // software interrupt
 
-    if (BITbIsBitOn(dwIsr, ISR_MIBNEARFULL))          // ISR, bit10
+    if (dwIsr & ISR_MIBNEARFULL)          // ISR, bit10
         pStatistic->ISRStat.dwIsrMIBNearfull++;
 
-    if (BITbIsBitOn(dwIsr, ISR_RXNOBUF))              // ISR, bit11
+    if (dwIsr & ISR_RXNOBUF)              // ISR, bit11
         pStatistic->ISRStat.dwIsrRxNoBuf++;           // Rx No Buff
 
-    if (BITbIsBitOn(dwIsr, ISR_RXDMA1))               // ISR, bit12
+    if (dwIsr & ISR_RXDMA1)               // ISR, bit12
         pStatistic->ISRStat.dwIsrRx1OK++;             // Rx1 successful
 
-//    if (BITbIsBitOn(dwIsr, ISR_ATIMTX))               // ISR, bit13
+//    if (dwIsr & ISR_ATIMTX)               // ISR, bit13
 //        pStatistic->ISRStat.dwIsrATIMTxOK++;          // ATIMTX successful
 
-//    if (BITbIsBitOn(dwIsr, ISR_SYNCTX))               // ISR, bit14
+//    if (dwIsr & ISR_SYNCTX)               // ISR, bit14
 //        pStatistic->ISRStat.dwIsrSYNCTxOK++;          // SYNCTX successful
 
-//    if (BITbIsBitOn(dwIsr, ISR_CFPEND))               // ISR, bit18
+//    if (dwIsr & ISR_CFPEND)               // ISR, bit18
 //        pStatistic->ISRStat.dwIsrCFPEnd++;
 
-//    if (BITbIsBitOn(dwIsr, ISR_ATIMEND))              // ISR, bit19
+//    if (dwIsr & ISR_ATIMEND)              // ISR, bit19
 //        pStatistic->ISRStat.dwIsrATIMEnd++;
 
-//    if (BITbIsBitOn(dwIsr, ISR_SYNCFLUSHOK))          // ISR, bit20
+//    if (dwIsr & ISR_SYNCFLUSHOK)          // ISR, bit20
 //        pStatistic->ISRStat.dwIsrSYNCFlushOK++;
 
-    if (BITbIsBitOn(dwIsr, ISR_SOFTTIMER1))           // ISR, bit21
+    if (dwIsr & ISR_SOFTTIMER1)           // ISR, bit21
         pStatistic->ISRStat.dwIsrSTIMER1Int++;
 
 }
@@ -184,20 +183,20 @@ void STAvUpdateRDStatCounter (PSStatCoun
     //need change
     PS802_11Header pHeader = (PS802_11Header)pbyBuffer;
 
-    if (BITbIsBitOn(byRSR, RSR_ADDROK))
+    if (byRSR & RSR_ADDROK)
         pStatistic->dwRsrADDROk++;
-    if (BITbIsBitOn(byRSR, RSR_CRCOK)) {
+    if (byRSR & RSR_CRCOK) {
         pStatistic->dwRsrCRCOk++;
 
         pStatistic->ullRsrOK++;
 
         if (cbFrameLength >= U_ETHER_ADDR_LEN) {
             // update counters in case that successful transmit
-            if (BITbIsBitOn(byRSR, RSR_ADDRBROAD)) {
+            if (byRSR & RSR_ADDRBROAD) {
                 pStatistic->ullRxBroadcastFrames++;
                 pStatistic->ullRxBroadcastBytes += (ULONGLONG)cbFrameLength;
             }
-            else if (BITbIsBitOn(byRSR, RSR_ADDRMULTI)) {
+            else if (byRSR & RSR_ADDRMULTI) {
                 pStatistic->ullRxMulticastFrames++;
                 pStatistic->ullRxMulticastBytes += (ULONGLONG)cbFrameLength;
             }
@@ -210,84 +209,84 @@ void STAvUpdateRDStatCounter (PSStatCoun
 
     if(byRxRate==22) {
         pStatistic->CustomStat.ullRsr11M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr11MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"11M: ALL[%d], OK[%d]:[%02x]\n", (INT)pStatistic->CustomStat.ullRsr11M, (INT)pStatistic->CustomStat.ullRsr11MCRCOk, byRSR);
     }
     else if(byRxRate==11) {
         pStatistic->CustomStat.ullRsr5M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr5MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" 5M: ALL[%d], OK[%d]:[%02x]\n", (INT)pStatistic->CustomStat.ullRsr5M, (INT)pStatistic->CustomStat.ullRsr5MCRCOk, byRSR);
     }
     else if(byRxRate==4) {
         pStatistic->CustomStat.ullRsr2M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr2MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" 2M: ALL[%d], OK[%d]:[%02x]\n", (INT)pStatistic->CustomStat.ullRsr2M, (INT)pStatistic->CustomStat.ullRsr2MCRCOk, byRSR);
     }
     else if(byRxRate==2){
         pStatistic->CustomStat.ullRsr1M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr1MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" 1M: ALL[%d], OK[%d]:[%02x]\n", (INT)pStatistic->CustomStat.ullRsr1M, (INT)pStatistic->CustomStat.ullRsr1MCRCOk, byRSR);
     }
     else if(byRxRate==12){
         pStatistic->CustomStat.ullRsr6M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr6MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" 6M: ALL[%d], OK[%d]\n", (INT)pStatistic->CustomStat.ullRsr6M, (INT)pStatistic->CustomStat.ullRsr6MCRCOk);
     }
     else if(byRxRate==18){
         pStatistic->CustomStat.ullRsr9M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr9MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" 9M: ALL[%d], OK[%d]\n", (INT)pStatistic->CustomStat.ullRsr9M, (INT)pStatistic->CustomStat.ullRsr9MCRCOk);
     }
     else if(byRxRate==24){
         pStatistic->CustomStat.ullRsr12M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr12MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"12M: ALL[%d], OK[%d]\n", (INT)pStatistic->CustomStat.ullRsr12M, (INT)pStatistic->CustomStat.ullRsr12MCRCOk);
     }
     else if(byRxRate==36){
         pStatistic->CustomStat.ullRsr18M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr18MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"18M: ALL[%d], OK[%d]\n", (INT)pStatistic->CustomStat.ullRsr18M, (INT)pStatistic->CustomStat.ullRsr18MCRCOk);
     }
     else if(byRxRate==48){
         pStatistic->CustomStat.ullRsr24M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr24MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"24M: ALL[%d], OK[%d]\n", (INT)pStatistic->CustomStat.ullRsr24M, (INT)pStatistic->CustomStat.ullRsr24MCRCOk);
     }
     else if(byRxRate==72){
         pStatistic->CustomStat.ullRsr36M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr36MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"36M: ALL[%d], OK[%d]\n", (INT)pStatistic->CustomStat.ullRsr36M, (INT)pStatistic->CustomStat.ullRsr36MCRCOk);
     }
     else if(byRxRate==96){
         pStatistic->CustomStat.ullRsr48M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr48MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"48M: ALL[%d], OK[%d]\n", (INT)pStatistic->CustomStat.ullRsr48M, (INT)pStatistic->CustomStat.ullRsr48MCRCOk);
     }
     else if(byRxRate==108){
         pStatistic->CustomStat.ullRsr54M++;
-        if(BITbIsBitOn(byRSR, RSR_CRCOK)) {
+        if(byRSR & RSR_CRCOK) {
             pStatistic->CustomStat.ullRsr54MCRCOk++;
         }
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"54M: ALL[%d], OK[%d]\n", (INT)pStatistic->CustomStat.ullRsr54M, (INT)pStatistic->CustomStat.ullRsr54MCRCOk);
@@ -296,27 +295,27 @@ void STAvUpdateRDStatCounter (PSStatCoun
     	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Unknown: Total[%d], CRCOK[%d]\n", (INT)pStatistic->dwRsrRxPacket+1, (INT)pStatistic->dwRsrCRCOk);
     }
 
-    if (BITbIsBitOn(byRSR, RSR_BSSIDOK))
+    if (byRSR & RSR_BSSIDOK)
         pStatistic->dwRsrBSSIDOk++;
 
-    if (BITbIsBitOn(byRSR, RSR_BCNSSIDOK))
+    if (byRSR & RSR_BCNSSIDOK)
         pStatistic->dwRsrBCNSSIDOk++;
-    if (BITbIsBitOn(byRSR, RSR_IVLDLEN))  //invalid len (> 2312 byte)
+    if (byRSR & RSR_IVLDLEN)  //invalid len (> 2312 byte)
         pStatistic->dwRsrLENErr++;
-    if (BITbIsBitOn(byRSR, RSR_IVLDTYP))  //invalid packet type
+    if (byRSR & RSR_IVLDTYP)  //invalid packet type
         pStatistic->dwRsrTYPErr++;
-    if (BITbIsBitOn(byRSR, (RSR_IVLDTYP | RSR_IVLDLEN)))
+    if (byRSR & (RSR_IVLDTYP | RSR_IVLDLEN))
         pStatistic->dwRsrErr++;
 
-    if (BITbIsBitOn(byNewRSR, NEWRSR_DECRYPTOK))
+    if (byNewRSR & NEWRSR_DECRYPTOK)
         pStatistic->dwNewRsrDECRYPTOK++;
-    if (BITbIsBitOn(byNewRSR, NEWRSR_CFPIND))
+    if (byNewRSR & NEWRSR_CFPIND)
         pStatistic->dwNewRsrCFP++;
-    if (BITbIsBitOn(byNewRSR, NEWRSR_HWUTSF))
+    if (byNewRSR & NEWRSR_HWUTSF)
         pStatistic->dwNewRsrUTSF++;
-    if (BITbIsBitOn(byNewRSR, NEWRSR_BCNHITAID))
+    if (byNewRSR & NEWRSR_BCNHITAID)
         pStatistic->dwNewRsrHITAID++;
-    if (BITbIsBitOn(byNewRSR, NEWRSR_BCNHITAID0))
+    if (byNewRSR & NEWRSR_BCNHITAID0)
         pStatistic->dwNewRsrHITAID0++;
 
     // increase rx packet count
@@ -332,9 +331,9 @@ void STAvUpdateRDStatCounter (PSStatCoun
         pStatistic->dwRsrRxControl++;
     }
 
-    if (BITbIsBitOn(byRSR, RSR_ADDRBROAD))
+    if (byRSR & RSR_ADDRBROAD)
         pStatistic->dwRsrBroadcast++;
-    else if (BITbIsBitOn(byRSR, RSR_ADDRMULTI))
+    else if (byRSR & RSR_ADDRMULTI)
         pStatistic->dwRsrMulticast++;
     else
         pStatistic->dwRsrDirected++;
@@ -486,13 +485,13 @@ STAvUpdateTDStatCounter (
         }
     }
     else {
-        if (BITbIsBitOn(byTSR1, TSR1_TERR))
+        if (byTSR1 & TSR1_TERR)
             pStatistic->dwTsrErr[uIdx]++;
-        if (BITbIsBitOn(byTSR1, TSR1_RETRYTMO))
+        if (byTSR1 & TSR1_RETRYTMO)
             pStatistic->dwTsrRetryTimeout[uIdx]++;
-        if (BITbIsBitOn(byTSR1, TSR1_TMO))
+        if (byTSR1 & TSR1_TMO)
             pStatistic->dwTsrTransmitTimeout[uIdx]++;
-        if (BITbIsBitOn(byTSR1, ACK_DATA))
+        if (byTSR1 & ACK_DATA)
             pStatistic->dwTsrACKData[uIdx]++;
     }
 
--- a/drivers/staging/vt6655/michael.c
+++ b/drivers/staging/vt6655/michael.c
@@ -40,7 +40,6 @@
  */
 
 #include "tmacro.h"
-#include "tbit.h"
 #include "michael.h"
 
 /*---------------------  Static Definitions -------------------------*/
--- a/drivers/staging/vt6655/power.c
+++ b/drivers/staging/vt6655/power.c
@@ -38,13 +38,11 @@
  */
 
 #include "ttype.h"
-#include "tbit.h"
 #include "mac.h"
 #include "device.h"
 #include "wmgr.h"
 #include "power.h"
 #include "wcmd.h"
-#include "tbit.h"
 #include "rxtx.h"
 #include "card.h"
 
--- a/drivers/staging/vt6655/rf.c
+++ b/drivers/staging/vt6655/rf.c
@@ -34,7 +34,6 @@
 
 #include "mac.h"
 #include "srom.h"
-#include "tbit.h"
 #include "rf.h"
 #include "baseband.h"
 
@@ -633,7 +632,7 @@ BOOL IFRFbWriteEmbeded (DWORD_PTR dwIoBa
     // W_MAX_TIMEOUT is the timeout period
     for (ww = 0; ww < W_MAX_TIMEOUT; ww++) {
         VNSvInPortD(dwIoBase + MAC_REG_IFREGCTL, &dwValue);
-        if (BITbIsBitOn(dwValue, IFREGCTL_DONE))
+        if (dwValue & IFREGCTL_DONE)
             break;
     }
 
--- a/drivers/staging/vt6655/rxtx.c
+++ b/drivers/staging/vt6655/rxtx.c
@@ -60,7 +60,6 @@
 #include "tcrc.h"
 #include "wctl.h"
 #include "wroute.h"
-#include "tbit.h"
 #include "hostap.h"
 #include "rf.h"
 
--- a/drivers/staging/vt6655/srom.c
+++ b/drivers/staging/vt6655/srom.c
@@ -44,7 +44,6 @@
 
 #include "upc.h"
 #include "tmacro.h"
-#include "tbit.h"
 #include "tether.h"
 #include "mac.h"
 #include "srom.h"
@@ -97,12 +96,12 @@ BYTE SROMbyReadEmbedded(DWORD_PTR dwIoBa
         // wait DONE be set
         for (wDelay = 0; wDelay < W_MAX_TIMEOUT; wDelay++) {
             VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &byWait);
-            if (BITbIsAnyBitsOn(byWait, (I2MCSR_DONE | I2MCSR_NACK)))
+            if (byWait & (I2MCSR_DONE | I2MCSR_NACK))
                 break;
             PCAvDelayByIO(CB_DELAY_LOOP_WAIT);
         }
         if ((wDelay < W_MAX_TIMEOUT) &&
-             (BITbIsBitOff(byWait, I2MCSR_NACK))) {
+             ( !(byWait & I2MCSR_NACK))) {
             break;
         }
     }
@@ -146,13 +145,13 @@ BOOL SROMbWriteEmbedded (DWORD_PTR dwIoB
         // wait DONE be set
         for (wDelay = 0; wDelay < W_MAX_TIMEOUT; wDelay++) {
             VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &byWait);
-            if (BITbIsAnyBitsOn(byWait, (I2MCSR_DONE | I2MCSR_NACK)))
+            if (byWait & (I2MCSR_DONE | I2MCSR_NACK))
                 break;
             PCAvDelayByIO(CB_DELAY_LOOP_WAIT);
         }
 
         if ((wDelay < W_MAX_TIMEOUT) &&
-             (BITbIsBitOff(byWait, I2MCSR_NACK))) {
+             ( !(byWait & I2MCSR_NACK))) {
             break;
         }
     }
@@ -228,7 +227,7 @@ BOOL SROMbIsRegBitsOn (DWORD_PTR dwIoBas
     BYTE    byOrgData;
 
     byOrgData = SROMbyReadEmbedded(dwIoBase, byContntOffset);
-    return BITbIsAllBitsOn(byOrgData, byTestBits);
+    return (byOrgData & byTestBits) == byTestBits;
 }
 
 
@@ -251,7 +250,7 @@ BOOL SROMbIsRegBitsOff (DWORD_PTR dwIoBa
     BYTE    byOrgData;
 
     byOrgData = SROMbyReadEmbedded(dwIoBase, byContntOffset);
-    return BITbIsAllBitsOff(byOrgData, byTestBits);
+    return !(byOrgData & byTestBits);
 }
 
 
@@ -407,7 +406,7 @@ BOOL SROMbAutoLoad (DWORD_PTR dwIoBase)
     for (ii = 0; ii < EEP_MAX_CONTEXT_SIZE; ii++) {
         MACvTimer0MicroSDelay(dwIoBase, CB_EEPROM_READBYTE_WAIT);
         VNSvInPortB(dwIoBase + MAC_REG_I2MCSR, &byWait);
-        if (BITbIsBitOff(byWait, I2MCSR_AUTOLD))
+        if ( !(byWait & I2MCSR_AUTOLD))
             break;
     }
 
--- a/drivers/staging/vt6655/tbit.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *
- * File: tbit.h
- *
- * Purpose: Bit routines
- *
- * Author: Tevin Chen
- *
- * Date: May 21, 1996
- *
- */
-
-#ifndef __TBIT_H__
-#define __TBIT_H__
-
-#include "ttype.h"
-
-/*---------------------  Export Definitions -------------------------*/
-
-/*---------------------  Export Types  ------------------------------*/
-
-/*---------------------  Export Macros ------------------------------*/
-
-// test single bit on
-#define BITbIsBitOn(tData, tTestBit)                \
-    (((tData) & (tTestBit)) != 0)
-
-// test single bit off
-#define BITbIsBitOff(tData, tTestBit)               \
-    (((tData) & (tTestBit)) == 0)
-
-
-#define BITbIsAllBitsOn(tData, tTestBit)            \
-    (((tData) & (tTestBit)) == (tTestBit))
-
-#define BITbIsAllBitsOff(tData, tTestBit)           \
-    (((tData) & (tTestBit)) == 0)
-
-#define BITbIsAnyBitsOn(tData, tTestBit)            \
-    (((tData) & (tTestBit)) != 0)
-
-#define BITbIsAnyBitsOff(tData, tTestBit)           \
-    (((tData) & (tTestBit)) != (tTestBit))
-
-/*---------------------  Export Classes  ----------------------------*/
-
-/*---------------------  Export Variables  --------------------------*/
-
-/*---------------------  Export Functions  --------------------------*/
-
-
-
-#endif // __TBIT_H__
-
-
-
--- a/drivers/staging/vt6655/tcrc.c
+++ b/drivers/staging/vt6655/tcrc.c
@@ -33,7 +33,6 @@
  *
  */
 
-#include "tbit.h"
 #include "tcrc.h"
 
 /*---------------------  Static Definitions -------------------------*/
--- a/drivers/staging/vt6655/tether.c
+++ b/drivers/staging/vt6655/tether.c
@@ -34,7 +34,6 @@
 
 #include "device.h"
 #include "tmacro.h"
-#include "tbit.h"
 #include "tcrc.h"
 #include "tether.h"
 
@@ -74,7 +73,7 @@ BYTE ETHbyGetHashIndexByCrc32 (PBYTE pby
     // reverse most bit to least bit
     for (ii = 0; ii < (sizeof(byTmpHash) * 8); ii++) {
         byHash <<= 1;
-        if (BITbIsBitOn(byTmpHash, 0x01))
+        if (byTmpHash & 0x01)
             byHash |= 1;
         byTmpHash >>= 1;
     }
--- a/drivers/staging/vt6655/tkip.c
+++ b/drivers/staging/vt6655/tkip.c
@@ -33,7 +33,6 @@
  */
 
 #include "tmacro.h"
-#include "tbit.h"
 #include "tkip.h"
 
 /*---------------------  Static Definitions -------------------------*/
--- a/drivers/staging/vt6655/vntwifi.c
+++ b/drivers/staging/vt6655/vntwifi.c
@@ -32,7 +32,6 @@
  */
 
 #include "vntwifi.h"
-#include "tbit.h"
 #include "IEEE11h.h"
 #include "country.h"
 #include "device.h"
@@ -691,7 +690,7 @@ VNTWIFIwGetMaxSupportRate(
     PSMgmtObject    pMgmt = (PSMgmtObject) pMgmtObject;
 
     for(wRate = RATE_54M; wRate > RATE_1M; wRate--) {
-        if (BITbIsBitOn(pMgmt->sNodeDBTable[0].wSuppRate, (1<<wRate))) {
+        if (pMgmt->sNodeDBTable[0].wSuppRate & (1<<wRate)) {
             return (wRate);
         }
     }
--- a/drivers/staging/vt6655/wmgr.c
+++ b/drivers/staging/vt6655/wmgr.c
@@ -62,7 +62,6 @@
  */
 
 #include "tmacro.h"
-#include "tbit.h"
 #include "desc.h"
 #include "device.h"
 #include "card.h"
