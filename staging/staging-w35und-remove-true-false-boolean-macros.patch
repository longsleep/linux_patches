From penberg@cs.helsinki.fi  Mon Oct 27 14:23:05 2008
From: Pekka J Enberg <penberg@cs.helsinki.fi>
Date: Mon, 27 Oct 2008 22:46:39 +0200 (EET)
Subject: Staging: w35und: remove true/false boolean macros
To: greg@kroah.com
Cc: pavel@suse.cz, linux-kernel@vger.kernel.org
Message-ID: <Pine.LNX.4.64.0810272245380.7561@melkki.cs.Helsinki.FI>

From: Pekka Enberg <penberg@cs.helsinki.fi>

Use the kernel built-in true and false boolean values instead of duplicating
them in the driver code.

Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
Cc: Pavel Machek <pavel@suse.cz>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/winbond/linux/common.h    |   17 -------
 drivers/staging/winbond/linux/wb35reg.c   |   70 +++++++++++++++---------------
 drivers/staging/winbond/linux/wb35rx.c    |    2 
 drivers/staging/winbond/linux/wb35tx.c    |   14 +++---
 drivers/staging/winbond/mds.c             |   31 ++++++-------
 drivers/staging/winbond/mlmetxrx.c        |   16 +++---
 drivers/staging/winbond/mto.c             |   12 ++---
 drivers/staging/winbond/phy_calibration.c |    6 +-
 drivers/staging/winbond/wbhal.c           |   14 +++---
 drivers/staging/winbond/wblinux.c         |   20 ++++----
 10 files changed, 92 insertions(+), 110 deletions(-)

--- a/drivers/staging/winbond/linux/common.h
+++ b/drivers/staging/winbond/linux/common.h
@@ -45,23 +45,6 @@
 #define	FAILURE     0
 
 
-#ifndef true
-#define true        1
-#endif
-
-#ifndef false
-#define false       0
-#endif
-
-// PD43 20021108
-#ifndef TRUE
-#define TRUE        1
-#endif
-
-#ifndef FALSE
-#define FALSE       0
-#endif
-
 #define STATUS_MEDIA_CONNECT 1
 #define STATUS_MEDIA_DISCONNECT 0
 
--- a/drivers/staging/winbond/linux/wb35reg.c
+++ b/drivers/staging/winbond/linux/wb35reg.c
@@ -2,8 +2,8 @@
 
 extern void phy_calibration_winbond(hw_data_t *phw_data, u32 frequency);
 
-// TRUE  : read command process successfully
-// FALSE : register not support
+// true  : read command process successfully
+// false : register not support
 // RegisterNo : start base
 // pRegisterData : data point
 // NumberOfData : number of register data
@@ -21,7 +21,7 @@ Wb35Reg_BurstWrite(phw_data_t pHwData, u
 
 	// Module shutdown
 	if (pHwData->SurpriseRemove)
-		return FALSE;
+		return false;
 
 	// Trying to use burst write function if use new hardware
 	UrbSize = sizeof(struct wb35_reg_queue) + DataSize + sizeof(struct usb_ctrlrequest);
@@ -58,15 +58,15 @@ Wb35Reg_BurstWrite(phw_data_t pHwData, u
 		// Start EP0VM
 		Wb35Reg_EP0VM_start(pHwData);
 
-		return TRUE;
+		return true;
 	} else {
 		if (urb)
 			usb_free_urb(urb);
 		if (reg_queue)
 			kfree(reg_queue);
-		return FALSE;
+		return false;
 	}
-   return FALSE;
+   return false;
 }
 
 void
@@ -112,8 +112,8 @@ Wb35Reg_Update(phw_data_t pHwData,  u16 
 	}
 }
 
-// TRUE  : read command process successfully
-// FALSE : register not support
+// true  : read command process successfully
+// false : register not support
 unsigned char
 Wb35Reg_WriteSync(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue )
 {
@@ -122,7 +122,7 @@ Wb35Reg_WriteSync(  phw_data_t pHwData, 
 
 	// Module shutdown
 	if (pHwData->SurpriseRemove)
-		return FALSE;
+		return false;
 
 	RegisterValue = cpu_to_le32(RegisterValue);
 
@@ -150,14 +150,14 @@ Wb35Reg_WriteSync(  phw_data_t pHwData, 
 		#endif
 
 		pHwData->SurpriseRemove = 1; // 20060704.2
-		return FALSE;
+		return false;
 	}
 
-	return TRUE;
+	return true;
 }
 
-// TRUE  : read command process successfully
-// FALSE : register not support
+// true  : read command process successfully
+// false : register not support
 unsigned char
 Wb35Reg_Write(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue )
 {
@@ -170,7 +170,7 @@ Wb35Reg_Write(  phw_data_t pHwData,  u16
 
 	// Module shutdown
 	if (pHwData->SurpriseRemove)
-		return FALSE;
+		return false;
 
 	// update the register by send urb request------------------------------------
 	UrbSize = sizeof(struct wb35_reg_queue) + sizeof(struct usb_ctrlrequest);
@@ -180,7 +180,7 @@ Wb35Reg_Write(  phw_data_t pHwData,  u16
 		reg_queue->DIRECT = 1;// burst write register
 		reg_queue->INDEX = RegisterNo;
 		reg_queue->VALUE = cpu_to_le32(RegisterValue);
-		reg_queue->RESERVED_VALID = FALSE;
+		reg_queue->RESERVED_VALID = false;
 		dr = (struct usb_ctrlrequest *)((u8 *)reg_queue + sizeof(struct wb35_reg_queue));
 		dr->bRequestType = USB_TYPE_VENDOR|USB_DIR_OUT |USB_RECIP_DEVICE;
 		dr->bRequest = 0x03; // USB or vendor-defined request code, burst mode
@@ -205,19 +205,19 @@ Wb35Reg_Write(  phw_data_t pHwData,  u16
 		// Start EP0VM
 		Wb35Reg_EP0VM_start(pHwData);
 
-		return TRUE;
+		return true;
 	} else {
 		if (urb)
 			usb_free_urb(urb);
 		kfree(reg_queue);
-		return FALSE;
+		return false;
 	}
 }
 
 //This command will be executed with a user defined value. When it completes,
 //this value is useful. For example, hal_set_current_channel will use it.
-// TRUE  : read command process successfully
-// FALSE : register not support
+// true  : read command process successfully
+// false : register not support
 unsigned char
 Wb35Reg_WriteWithCallbackValue( phw_data_t pHwData, u16 RegisterNo, u32 RegisterValue,
 				s8 *pValue, s8 Len)
@@ -230,7 +230,7 @@ Wb35Reg_WriteWithCallbackValue( phw_data
 
 	// Module shutdown
 	if (pHwData->SurpriseRemove)
-		return FALSE;
+		return false;
 
 	// update the register by send urb request------------------------------------
 	UrbSize = sizeof(struct wb35_reg_queue) + sizeof(struct usb_ctrlrequest);
@@ -242,7 +242,7 @@ Wb35Reg_WriteWithCallbackValue( phw_data
 		reg_queue->VALUE = cpu_to_le32(RegisterValue);
 		//NOTE : Users must guarantee the size of value will not exceed the buffer size.
 		memcpy(reg_queue->RESERVED, pValue, Len);
-		reg_queue->RESERVED_VALID = TRUE;
+		reg_queue->RESERVED_VALID = true;
 		dr = (struct usb_ctrlrequest *)((u8 *)reg_queue + sizeof(struct wb35_reg_queue));
 		dr->bRequestType = USB_TYPE_VENDOR|USB_DIR_OUT |USB_RECIP_DEVICE;
 		dr->bRequest = 0x03; // USB or vendor-defined request code, burst mode
@@ -265,17 +265,17 @@ Wb35Reg_WriteWithCallbackValue( phw_data
 
 		// Start EP0VM
 		Wb35Reg_EP0VM_start(pHwData);
-		return TRUE;
+		return true;
 	} else {
 		if (urb)
 			usb_free_urb(urb);
 		kfree(reg_queue);
-		return FALSE;
+		return false;
 	}
 }
 
-// TRUE  : read command process successfully
-// FALSE : register not support
+// true  : read command process successfully
+// false : register not support
 // pRegisterValue : It must be a resident buffer due to asynchronous read register.
 unsigned char
 Wb35Reg_ReadSync(  phw_data_t pHwData,  u16 RegisterNo,   u32 * pRegisterValue )
@@ -286,7 +286,7 @@ Wb35Reg_ReadSync(  phw_data_t pHwData,  
 
 	// Module shutdown
 	if (pHwData->SurpriseRemove)
-		return FALSE;
+		return false;
 
 	// Read the register by send usb message------------------------------------
 
@@ -317,14 +317,14 @@ Wb35Reg_ReadSync(  phw_data_t pHwData,  
 		#endif
 
 		pHwData->SurpriseRemove = 1; // 20060704.2
-		return FALSE;
+		return false;
 	}
 
-	return TRUE;
+	return true;
 }
 
-// TRUE  : read command process successfully
-// FALSE : register not support
+// true  : read command process successfully
+// false : register not support
 // pRegisterValue : It must be a resident buffer due to asynchronous read register.
 unsigned char
 Wb35Reg_Read(phw_data_t pHwData, u16 RegisterNo,  u32 * pRegisterValue )
@@ -337,7 +337,7 @@ Wb35Reg_Read(phw_data_t pHwData, u16 Reg
 
 	// Module shutdown
 	if (pHwData->SurpriseRemove)
-		return FALSE;
+		return false;
 
 	// update the variable by send Urb to read register ------------------------------------
 	UrbSize = sizeof(struct wb35_reg_queue) + sizeof(struct usb_ctrlrequest);
@@ -371,12 +371,12 @@ Wb35Reg_Read(phw_data_t pHwData, u16 Reg
 		// Start EP0VM
 		Wb35Reg_EP0VM_start( pHwData );
 
-		return TRUE;
+		return true;
 	} else {
 		if (urb)
 			usb_free_urb( urb );
 		kfree(reg_queue);
-		return FALSE;
+		return false;
 	}
 }
 
@@ -629,9 +629,9 @@ unsigned char Wb35Reg_initial(phw_data_t
 	Dxx_initial(pHwData);
 
 	if (pHwData->SurpriseRemove)
-		return FALSE;
+		return false;
 	else
-		return TRUE; // Initial fail
+		return true; // Initial fail
 }
 
 //===================================================================================
--- a/drivers/staging/winbond/linux/wb35rx.c
+++ b/drivers/staging/winbond/linux/wb35rx.c
@@ -326,7 +326,7 @@ u16 Wb35Rx_indicate(phw_data_t pHwData)
 
 		// Reclaim resource
 		pWb35Rx->RxOwner[ RxBufferId ] = 1;
-	} while(TRUE);
+	} while (true);
 
 	return stmp2;
 }
--- a/drivers/staging/winbond/linux/wb35tx.c
+++ b/drivers/staging/winbond/linux/wb35tx.c
@@ -17,7 +17,7 @@ Wb35Tx_get_tx_buffer(phw_data_t pHwData,
 	PWB35TX pWb35Tx = &pHwData->Wb35Tx;
 
 	*pBuffer = pWb35Tx->TxBuffer[0];
-	return TRUE;
+	return true;
 }
 
 void Wb35Tx_start(phw_data_t pHwData)
@@ -136,16 +136,16 @@ unsigned char Wb35Tx_initial(phw_data_t 
 
 	pWb35Tx->Tx4Urb = usb_alloc_urb(0, GFP_ATOMIC);
 	if (!pWb35Tx->Tx4Urb)
-		return FALSE;
+		return false;
 
 	pWb35Tx->Tx2Urb = usb_alloc_urb(0, GFP_ATOMIC);
 	if (!pWb35Tx->Tx2Urb)
 	{
 		usb_free_urb( pWb35Tx->Tx4Urb );
-		return FALSE;
+		return false;
 	}
 
-	return TRUE;
+	return true;
 }
 
 //======================================================
@@ -193,12 +193,12 @@ void Wb35Tx_destroy(phw_data_t pHwData)
 void Wb35Tx_CurrentTime(phw_data_t pHwData, u32 TimeCount)
 {
 	PWB35TX pWb35Tx = &pHwData->Wb35Tx;
-	unsigned char Trigger = FALSE;
+	unsigned char Trigger = false;
 
 	if (pWb35Tx->TxTimer > TimeCount)
-		Trigger = TRUE;
+		Trigger = true;
 	else if (TimeCount > (pWb35Tx->TxTimer+500))
-		Trigger = TRUE;
+		Trigger = true;
 
 	if (Trigger) {
 		pWb35Tx->TxTimer = TimeCount;
--- a/drivers/staging/winbond/mds.c
+++ b/drivers/staging/winbond/mds.c
@@ -18,7 +18,7 @@ Mds_initial(struct wb35_adapter * adapte
 {
 	PMDS pMds = &adapter->Mds;
 
-	pMds->TxPause = FALSE;
+	pMds->TxPause = false;
 	pMds->TxRTSThreshold = DEFAULT_RTSThreshold;
 	pMds->TxFragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD;
 
@@ -43,7 +43,7 @@ Mds_Tx(struct wb35_adapter * adapter)
 	u8		*XmitBufAddress;
 	u16		XmitBufSize, PacketSize, stmp, CurrentSize, FragmentThreshold;
 	u8		FillIndex, TxDesIndex, FragmentCount, FillCount;
-	unsigned char	BufferFilled = FALSE, MICAdd = 0;
+	unsigned char	BufferFilled = false, MICAdd = 0;
 
 
 	if (pMds->TxPause)
@@ -87,7 +87,7 @@ Mds_Tx(struct wb35_adapter * adapter)
 			//
 			// Start transmitting
 			//
-			BufferFilled = TRUE;
+			BufferFilled = true;
 
 			/* Leaves first u8 intact */
 			memset((u8 *)pTxDes + 1, 0, sizeof(DESCRIPTOR) - 1);
@@ -130,10 +130,10 @@ Mds_Tx(struct wb35_adapter * adapter)
 #ifdef _IBSS_BEACON_SEQ_STICK_
 			if ((XmitBufAddress[ DOT_11_DA_OFFSET+8 ] & 0xfc) != MAC_SUBTYPE_MNGMNT_PROBE_REQUEST) // +8 for USB hdr
 #endif
-				pMds->TxToggle = TRUE;
+				pMds->TxToggle = true;
 
 			// Get packet to transmit completed, 1:TESTSTA 2:MLME 3: Ndis data
-			MLME_SendComplete(adapter, 0, TRUE);
+			MLME_SendComplete(adapter, 0, true);
 
 			// Software TSC count 20060214
 			pMds->TxTsc++;
@@ -141,7 +141,7 @@ Mds_Tx(struct wb35_adapter * adapter)
 				pMds->TxTsc_2++;
 
 			FillCount++; // 20060928
-		} while (HAL_USB_MODE_BURST(pHwData)); // End of multiple MSDU copy loop. FALSE = single TRUE = multiple sending
+		} while (HAL_USB_MODE_BURST(pHwData)); // End of multiple MSDU copy loop. false = single true = multiple sending
 
 		// Move to the next one, if necessary
 		if (BufferFilled) {
@@ -156,14 +156,14 @@ Mds_Tx(struct wb35_adapter * adapter)
 
 			pMds->TxFillIndex++;
 			pMds->TxFillIndex %= MAX_USB_TX_BUFFER_NUMBER;
-			BufferFilled = FALSE;
+			BufferFilled = false;
 		} else
 			break;
 
 		if (!PacketSize) // No more pk for transmitting
 			break;
 
-	} while(TRUE);
+	} while(true);
 
 	//
 	// Start to send by lower module
@@ -181,7 +181,7 @@ Mds_SendComplete(struct wb35_adapter * a
 	PMDS	pMds = &adapter->Mds;
 	phw_data_t	pHwData = &adapter->sHwData;
 	u8	PacketId = (u8)pT02->T02_Tx_PktID;
-	unsigned char	SendOK = TRUE;
+	unsigned char	SendOK = true;
 	u8	RetryCount, TxRate;
 
 	if (pT02->T02_IgnoreResult) // Don't care the result
@@ -192,7 +192,7 @@ Mds_SendComplete(struct wb35_adapter * a
 		TxRate = pMds->TxRate[ PacketId ][ 0 ];
 		RetryCount = (u8)pT02->T02_MPDU_Cnt;
 		if (pT02->value & FLAG_ERROR_TX_MASK) {
-			SendOK = FALSE;
+			SendOK = false;
 
 			if (pT02->T02_transmit_abort || pT02->T02_out_of_MaxTxMSDULiftTime) {
 				//retry error
@@ -435,11 +435,10 @@ Mds_DurationSet(  struct wb35_adapter * 
 	PT01_DESCRIPTOR	pT01;
 	u16	Duration, NextBodyLen, OffsetSize;
 	u8	Rate, i;
-	unsigned char	CTS_on = FALSE, RTS_on = FALSE;
+	unsigned char	CTS_on = false, RTS_on = false;
 	PT00_DESCRIPTOR pNextT00;
 	u16 BodyLen = 0;
-	unsigned char boGroupAddr = FALSE;
-
+	unsigned char boGroupAddr = false;
 
 	OffsetSize = pDes->FragmentThreshold + 32 + 3;
 	OffsetSize &= ~0x03;
@@ -452,7 +451,7 @@ Mds_DurationSet(  struct wb35_adapter * 
 	pNextT00 = (PT00_DESCRIPTOR)(buffer+OffsetSize);
 
 	if( buffer[ DOT_11_DA_OFFSET+8 ] & 0x1 ) // +8 for USB hdr
-		boGroupAddr = TRUE;
+		boGroupAddr = true;
 
 	//========================================
 	// Set RTS/CTS mechanism
@@ -467,13 +466,13 @@ Mds_DurationSet(  struct wb35_adapter * 
 		BodyLen += 4;	//CRC
 
 		if( BodyLen >= CURRENT_RTS_THRESHOLD )
-			RTS_on = TRUE; // Using RTS
+			RTS_on = true; // Using RTS
 		else
 		{
 			if( pT01->T01_modulation_type ) // Is using OFDM
 			{
 				if( CURRENT_PROTECT_MECHANISM ) // Is using protect
-					CTS_on = TRUE; // Using CTS
+					CTS_on = true; // Using CTS
 			}
 		}
 	}
--- a/drivers/staging/winbond/mlmetxrx.c
+++ b/drivers/staging/winbond/mlmetxrx.c
@@ -23,16 +23,16 @@ void MLMEResetTxRx(struct wb35_adapter *
 
 	// Reset the interface between MDS and MLME
 	for (i = 0; i < MAX_NUM_TX_MMPDU; i++)
-		adapter->sMlmeFrame.TxMMPDUInUse[i] = FALSE;
+		adapter->sMlmeFrame.TxMMPDUInUse[i] = false;
 	for (i = 0; i < MAX_NUM_RX_MMPDU; i++)
-		adapter->sMlmeFrame.SaveRxBufSlotInUse[i] = FALSE;
+		adapter->sMlmeFrame.SaveRxBufSlotInUse[i] = false;
 
 	adapter->sMlmeFrame.wNumRxMMPDUInMLME   = 0;
 	adapter->sMlmeFrame.wNumRxMMPDUDiscarded = 0;
 	adapter->sMlmeFrame.wNumRxMMPDU          = 0;
 	adapter->sMlmeFrame.wNumTxMMPDUDiscarded = 0;
 	adapter->sMlmeFrame.wNumTxMMPDU          = 0;
-	adapter->sLocalPara.boCCAbusy    = FALSE;
+	adapter->sLocalPara.boCCAbusy    = false;
 	adapter->sLocalPara.iPowerSaveMode     = PWR_ACTIVE;     // Power active
 }
 
@@ -59,13 +59,13 @@ u8 *MLMEGetMMPDUBuffer(struct wb35_adapt
 	u8 *returnVal;
 
 	for (i = 0; i< MAX_NUM_TX_MMPDU; i++) {
-		if (adapter->sMlmeFrame.TxMMPDUInUse[i] == FALSE)
+		if (adapter->sMlmeFrame.TxMMPDUInUse[i] == false)
 			break;
 	}
 	if (i >= MAX_NUM_TX_MMPDU) return NULL;
 
 	returnVal = (u8 *)&(adapter->sMlmeFrame.TxMMPDU[i]);
-	adapter->sMlmeFrame.TxMMPDUInUse[i] = TRUE;
+	adapter->sMlmeFrame.TxMMPDUInUse[i] = true;
 
 	return returnVal;
 }
@@ -77,7 +77,7 @@ u8 MLMESendFrame(struct wb35_adapter * a
 {
 	if (adapter->sMlmeFrame.IsInUsed != PACKET_FREE_TO_USE) {
 		adapter->sMlmeFrame.wNumTxMMPDUDiscarded++;
-		return FALSE;
+		return false;
 	}
 	adapter->sMlmeFrame.IsInUsed = PACKET_COME_FROM_MLME;
 
@@ -93,7 +93,7 @@ u8 MLMESendFrame(struct wb35_adapter * a
 
 	// Transmit NDIS packet
 	Mds_Tx(adapter);
-	return TRUE;
+	return true;
 }
 
 void
@@ -123,7 +123,7 @@ void MLMEfreeMMPDUBuffer(struct wb35_ada
 			break;
 	}
 	if (adapter->sMlmeFrame.TxMMPDUInUse[i])
-		adapter->sMlmeFrame.TxMMPDUInUse[i] = FALSE;
+		adapter->sMlmeFrame.TxMMPDUInUse[i] = false;
 	else  {
 		// Something wrong
 		// PD43 Add debug code here???
--- a/drivers/staging/winbond/mto.c
+++ b/drivers/staging/winbond/mto.c
@@ -208,7 +208,7 @@ static int TotalTxPktRetry = 0;
 static int TxPktPerAnt[3] = {0,0,0};
 static int RXRSSIANT[3] ={-70,-70,-70};
 static int TxPktRetryPerAnt[3] = {0,0,0};
-//static int TxDominateFlag=FALSE;
+//static int TxDominateFlag=false;
 static u8 old_antenna[4]={1 ,0 ,1 ,0};
 static int retryrate_rec[MTO_MAX_DATA_RATE_LEVELS];//this record the retry rate at different data rate
 
@@ -236,7 +236,7 @@ static RSSI2RATE RSSI2RateTbl[RSSI2RATE_
 static u8 untogglecount;
 static u8 last_rate_ant; //this is used for antenna backoff-hh
 
-u8	boSparseTxTraffic = FALSE;
+u8	boSparseTxTraffic = false;
 
 void MTO_Init(MTO_FUNC_INPUT);
 void AntennaToggleInitiator(MTO_FUNC_INPUT);
@@ -569,9 +569,9 @@ unsigned char TxDominate(int index)
 	tmp = TxPktPerAnt[index] + DTO_Rx_Info[0][index];
 
 	if(Divide(TxPktPerAnt[index]*100, tmp) > 40)
-		return TRUE;
+		return true;
 	else
-		return FALSE;
+		return false;
 }
 
 unsigned char CmpTxRetryRate(int index1, int index2)
@@ -584,9 +584,9 @@ unsigned char CmpTxRetryRate(int index1,
 	#endif
 
 	if(tx_retry_rate1 > tx_retry_rate2)
-		return TRUE;
+		return true;
 	else
-		return FALSE;
+		return false;
 }
 
 void GetFreshAntennaData(MTO_FUNC_INPUT)
--- a/drivers/staging/winbond/phy_calibration.c
+++ b/drivers/staging/winbond/phy_calibration.c
@@ -1682,7 +1682,7 @@ unsigned char adjust_TXVGA_for_iq_mag(hw
 		msleep(30); // 20060612.1.a
 
 		if( !hw_get_dxx_reg(phw_data, REG_MODE_CTRL, &reg_mode_ctrl) ) // 20060718.1 modify
-			return FALSE;
+			return false;
 
 		PHY_DEBUG(("[CAL]    MODE_CTRL (read) = 0x%08X\n", reg_mode_ctrl));
 
@@ -1727,9 +1727,9 @@ unsigned char adjust_TXVGA_for_iq_mag(hw
 	}
 
 	if( iq_mag_0_tx>=700 && iq_mag_0_tx<=1750 )
-		return TRUE;
+		return true;
 	else
-		return FALSE;
+		return false;
 }
 
 
--- a/drivers/staging/winbond/wbhal.c
+++ b/drivers/staging/winbond/wbhal.c
@@ -56,19 +56,19 @@ u8 hal_init_hardware(phw_data_t pHwData,
 				// Try to make sure the EEPROM contain
 				SoftwareSet >>= 8;
 				if( SoftwareSet != 0x82 )
-					return FALSE;
+					return false;
 				#endif
 
 				Wb35Rx_start( pHwData );
 				Wb35Tx_EP2VM_start( pHwData );
 
-				return TRUE;
+				return true;
 			}
 		}
 	}
 
 	pHwData->SurpriseRemove = 1;
-	return FALSE;
+	return false;
 }
 
 
@@ -312,7 +312,7 @@ u8 hal_get_accept_beacon(  phw_data_t pH
 unsigned char hal_reset_hardware( phw_data_t pHwData, void* ppa )
 {
 	// Not implement yet
-	return TRUE;
+	return true;
 }
 
 void hal_stop(  phw_data_t pHwData )
@@ -335,9 +335,9 @@ unsigned char hal_idle(phw_data_t pHwDat
 	PWBUSB	pWbUsb = &pHwData->WbUsb;
 
 	if( !pHwData->SurpriseRemove && ( pWbUsb->DetectCount || reg->EP0vm_state!=VM_STOP ) )
-		return FALSE;
+		return false;
 
-	return TRUE;
+	return true;
 }
 //---------------------------------------------------------------------------------------------------
 void hal_set_cwmin(  phw_data_t pHwData,  u8	cwin_min )
@@ -868,6 +868,6 @@ unsigned char hal_set_LED(phw_data_t pHw
 	pHwData->LED_Blinking = 0;
 	pHwData->LED_control = Mode;
 	OS_TIMER_SET( &pHwData->LEDTimer, 10 ); // 20060623
-	return TRUE;
+	return true;
 }
 
--- a/drivers/staging/winbond/wblinux.c
+++ b/drivers/staging/winbond/wblinux.c
@@ -49,7 +49,7 @@ WBLINUX_Initial(struct wb35_adapter * ad
 {
 	spin_lock_init( &adapter->SpinLock );
 	spin_lock_init( &adapter->AtomicSpinLock );
-	return TRUE;
+	return true;
 }
 
 void
@@ -114,7 +114,7 @@ void
 WbWlanHalt(struct wb35_adapter *adapter)
 {
 	//---------------------
-	adapter->sLocalPara.ShutDowned = TRUE;
+	adapter->sLocalPara.ShutDowned = true;
 
 	Mds_Destroy(adapter);
 
@@ -153,7 +153,7 @@ WbWLanInitialize(struct wb35_adapter *ad
 	hal_set_phy_type( &adapter->sHwData, RF_WB_242_1 );
 	adapter->sLocalPara.MTUsize = MAX_ETHERNET_PACKET_SIZE;
 	psLOCAL->bPreambleMode = AUTO_MODE;
-	adapter->sLocalPara.RadioOffStatus.boSwRadioOff = FALSE;
+	adapter->sLocalPara.RadioOffStatus.boSwRadioOff = false;
 	pHwData = &adapter->sHwData;
 	hal_set_phy_type( pHwData, RF_DECIDE_BY_INF );
 
@@ -168,11 +168,11 @@ WbWLanInitialize(struct wb35_adapter *ad
 	}
 
 	// Initial Software variable
-	adapter->sLocalPara.ShutDowned = FALSE;
+	adapter->sLocalPara.ShutDowned = false;
 
 	//added by ws for wep key error detection
-	adapter->sLocalPara.bWepKeyError= FALSE;
-	adapter->sLocalPara.bToSelfPacketReceived = FALSE;
+	adapter->sLocalPara.bWepKeyError= false;
+	adapter->sLocalPara.bToSelfPacketReceived = false;
 	adapter->sLocalPara.WepKeyDetectTimerCount= 2 * 100; /// 2 seconds
 
 	// Initial USB hal
@@ -192,9 +192,9 @@ WbWLanInitialize(struct wb35_adapter *ad
 	}
 
 	// Get Software setting flag from hal
-	adapter->sLocalPara.boAntennaDiversity = FALSE;
+	adapter->sLocalPara.boAntennaDiversity = false;
 	if (hal_software_set(pHwData) & 0x00000001)
-		adapter->sLocalPara.boAntennaDiversity = TRUE;
+		adapter->sLocalPara.boAntennaDiversity = true;
 
 	//
 	// For TS module
@@ -245,7 +245,7 @@ WbWLanInitialize(struct wb35_adapter *ad
 	hal_driver_init_OK(pHwData) = 1; // Notify hal that the driver is ready now.
 	//set a tx power for reference.....
 //	sme_set_tx_power_level(adapter, 12);	FIXME?
-	return TRUE;
+	return true;
 
 error:
 	switch (InitStep) {
@@ -258,7 +258,7 @@ error:
 	case 0: break;
 	}
 
-	return FALSE;
+	return false;
 }
 
 void WBLINUX_ConnectStatus(struct wb35_adapter * adapter, u32 flag)
