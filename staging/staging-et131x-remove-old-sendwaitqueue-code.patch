From alan@linux.intel.com  Mon Oct 26 14:56:27 2009
From: Alan Cox <alan@linux.intel.com>
Date: Tue, 06 Oct 2009 15:49:21 +0100
Subject: Staging: et131x: Remove old SendWaitQueue code
To: greg@kroah.com
Message-ID: <20091006144918.8604.14957.stgit@localhost.localdomain>


The Linux driver doesn't keep a pending queue as the old one did. so we can
remove all the code related to it.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/et131x/et1310_tx.c      |   52 ++------------------------------
 drivers/staging/et131x/et1310_tx.h      |    4 --
 drivers/staging/et131x/et131x_adapter.h |    1 
 drivers/staging/et131x/et131x_initpci.c |    1 
 4 files changed, 4 insertions(+), 54 deletions(-)

--- a/drivers/staging/et131x/et1310_tx.c
+++ b/drivers/staging/et131x/et1310_tx.c
@@ -95,7 +95,6 @@
 
 
 static void et131x_update_tcb_list(struct et131x_adapter *etdev);
-static void et131x_check_send_wait_list(struct et131x_adapter *etdev);
 static inline void et131x_free_send_packet(struct et131x_adapter *etdev,
 					   struct tcb *tcb);
 static int et131x_send_packet(struct sk_buff *skb,
@@ -310,8 +309,6 @@ void et131x_init_send(struct et131x_adap
 	/* Curr send queue should now be empty */
 	tx_ring->CurrSendHead = NULL;
 	tx_ring->CurrSendTail = NULL;
-
-	INIT_LIST_HEAD(&adapter->tx_ring.SendWaitQueue);
 }
 
 /**
@@ -334,9 +331,8 @@ int et131x_send_packets(struct sk_buff *
 	 * to Tx, so the PacketCount and it's array used makes no sense here
 	 */
 
-	/* Queue is not empty or TCB is not available */
-	if (!list_empty(&etdev->tx_ring.SendWaitQueue) ||
-	    MP_TCB_RESOURCES_NOT_AVAILABLE(etdev)) {
+	/* TCB is not available */
+	if (MP_TCB_RESOURCES_NOT_AVAILABLE(etdev)) {
 		/* NOTE: If there's an error on send, no need to queue the
 		 * packet under Linux; if we just send an error up to the
 		 * netif layer, it will resend the skb to us.
@@ -392,7 +388,7 @@ static int et131x_send_packet(struct sk_
 {
 	int status = 0;
 	struct tcb *tcb = NULL;
-	uint16_t *shbufva;
+	u16 *shbufva;
 	unsigned long flags;
 
 	/* All packets must have at least a MAC address and a protocol type */
@@ -420,7 +416,7 @@ static int et131x_send_packet(struct sk_
 	tcb->Packet = skb;
 
 	if ((skb->data != NULL) && ((skb->len - skb->data_len) >= 6)) {
-		shbufva = (uint16_t *) skb->data;
+		shbufva = (u16 *) skb->data;
 
 		if ((shbufva[0] == 0xffff) &&
 		    (shbufva[1] == 0xffff) && (shbufva[2] == 0xffff)) {
@@ -755,17 +751,6 @@ void et131x_free_busy_send_packets(struc
 	unsigned long flags;
 	u32 freed = 0;
 
-	while (!list_empty(&etdev->tx_ring.SendWaitQueue)) {
-		spin_lock_irqsave(&etdev->SendWaitLock, flags);
-
-		etdev->tx_ring.nWaitSend--;
-		spin_unlock_irqrestore(&etdev->SendWaitLock, flags);
-
-		entry = etdev->tx_ring.SendWaitQueue.next;
-	}
-
-	etdev->tx_ring.nWaitSend = 0;
-
 	/* Any packets being sent? Check the first TCB on the send list */
 	spin_lock_irqsave(&etdev->TCBSendQLock, flags);
 
@@ -811,11 +796,6 @@ void et131x_handle_send_interrupt(struct
 {
 	/* Mark as completed any packets which have been sent by the device. */
 	et131x_update_tcb_list(etdev);
-
-	/* If we queued any transmits because we didn't have any TCBs earlier,
-	 * dequeue and send those packets now, as long as we have free TCBs.
-	 */
-	et131x_check_send_wait_list(etdev);
 }
 
 /**
@@ -881,27 +861,3 @@ static void et131x_update_tcb_list(struc
 	spin_unlock_irqrestore(&etdev->TCBSendQLock, flags);
 }
 
-/**
- * et131x_check_send_wait_list - Helper routine for the interrupt handler
- * @etdev: pointer to our adapter
- *
- * Takes packets from the send wait queue and posts them to the device (if
- * room available).
- */
-static void et131x_check_send_wait_list(struct et131x_adapter *etdev)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&etdev->SendWaitLock, flags);
-
-	while (!list_empty(&etdev->tx_ring.SendWaitQueue) &&
-				MP_TCB_RESOURCES_AVAILABLE(etdev)) {
-		struct list_head *entry;
-
-		entry = etdev->tx_ring.SendWaitQueue.next;
-
-		etdev->tx_ring.nWaitSend--;
-	}
-
-	spin_unlock_irqrestore(&etdev->SendWaitLock, flags);
-}
--- a/drivers/staging/et131x/et1310_tx.h
+++ b/drivers/staging/et131x/et1310_tx.h
@@ -155,10 +155,6 @@ struct tx_ring {
 	struct tcb *CurrSendTail;
 	int nBusySend;
 
-	/* List of packets (not TCBs) that were queued for lack of resources */
-	struct list_head SendWaitQueue;
-	int nWaitSend;
-
 	/* The actual descriptor ring */
 	struct tx_desc *tx_desc_ring;
 	dma_addr_t tx_desc_ring_pa;
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -203,7 +203,6 @@ struct et131x_adapter {
 	spinlock_t TCBSendQLock;
 	spinlock_t TCBReadyQLock;
 	spinlock_t SendHWLock;
-	spinlock_t SendWaitLock;
 
 	spinlock_t RcvLock;
 	spinlock_t RcvPendLock;
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -555,7 +555,6 @@ static struct et131x_adapter *et131x_ada
 	spin_lock_init(&etdev->TCBSendQLock);
 	spin_lock_init(&etdev->TCBReadyQLock);
 	spin_lock_init(&etdev->SendHWLock);
-	spin_lock_init(&etdev->SendWaitLock);
 	spin_lock_init(&etdev->RcvLock);
 	spin_lock_init(&etdev->RcvPendLock);
 	spin_lock_init(&etdev->FbrLock);
