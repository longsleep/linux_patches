From 50626ba62379de1e1c92abe1e630138bfd096fd0 Mon Sep 17 00:00:00 2001
From: Hank Janssen <hjanssen@microsoft.com>
Date: Mon, 13 Jul 2009 15:15:47 -0700
Subject: Staging: hv: add the Hyper-V api header files

From: Hank Janssen <hjanssen@microsoft.com>

These are the header files for the API to talk to the Hyper-V
core.

Signed-off-by: Hank Janssen <hjanssen@microsoft.com>
Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/hv/include/ChannelMessages.h       |  312 +++++++
 drivers/staging/hv/include/HvHalApi.h              |   32 
 drivers/staging/hv/include/HvHcApi.h               |   60 +
 drivers/staging/hv/include/HvPtApi.h               |   86 ++
 drivers/staging/hv/include/HvStatus.h              |  718 ++++++++++++++++++
 drivers/staging/hv/include/HvSynicApi.h            |  490 ++++++++++++
 drivers/staging/hv/include/HvTypes.h               |   31 
 drivers/staging/hv/include/HvVpApi.h               |   51 +
 drivers/staging/hv/include/List.h                  |  269 ++++++
 drivers/staging/hv/include/VmbusChannelInterface.h |  131 +++
 drivers/staging/hv/include/VmbusPacketFormat.h     |  322 ++++++++
 drivers/staging/hv/include/nvspprotocol.h          |  306 +++++++
 drivers/staging/hv/include/rndis.h                 |  836 +++++++++++++++++++++
 drivers/staging/hv/include/vstorage.h              |  309 +++++++
 14 files changed, 3953 insertions(+)
 create mode 100644 drivers/staging/hv/include/ChannelMessages.h
 create mode 100644 drivers/staging/hv/include/HvHalApi.h
 create mode 100644 drivers/staging/hv/include/HvHcApi.h
 create mode 100644 drivers/staging/hv/include/HvPtApi.h
 create mode 100644 drivers/staging/hv/include/HvStatus.h
 create mode 100644 drivers/staging/hv/include/HvSynicApi.h
 create mode 100644 drivers/staging/hv/include/HvTypes.h
 create mode 100644 drivers/staging/hv/include/HvVpApi.h
 create mode 100644 drivers/staging/hv/include/List.h
 create mode 100644 drivers/staging/hv/include/VmbusChannelInterface.h
 create mode 100644 drivers/staging/hv/include/VmbusPacketFormat.h
 create mode 100644 drivers/staging/hv/include/nvspprotocol.h
 create mode 100644 drivers/staging/hv/include/rndis.h
 create mode 100644 drivers/staging/hv/include/vstorage.h

--- /dev/null
+++ b/drivers/staging/hv/include/ChannelMessages.h
@@ -0,0 +1,312 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+
+#include <VmbusPacketFormat.h>
+
+#define C_ASSERT(x)
+typedef UINT32 NTSTATUS;
+
+#pragma pack(push,1)
+
+//
+// Version 1 messages
+//
+
+typedef enum _VMBUS_CHANNEL_MESSAGE_TYPE
+{
+    ChannelMessageInvalid                   =  0,
+    ChannelMessageOfferChannel              =  1,
+    ChannelMessageRescindChannelOffer       =  2,
+    ChannelMessageRequestOffers             =  3,
+    ChannelMessageAllOffersDelivered        =  4,
+    ChannelMessageOpenChannel               =  5,
+    ChannelMessageOpenChannelResult         =  6,
+    ChannelMessageCloseChannel              =  7,
+    ChannelMessageGpadlHeader               =  8,
+    ChannelMessageGpadlBody                 =  9,
+    ChannelMessageGpadlCreated              = 10,
+    ChannelMessageGpadlTeardown             = 11,
+    ChannelMessageGpadlTorndown             = 12,
+    ChannelMessageRelIdReleased             = 13,
+    ChannelMessageInitiateContact           = 14,
+    ChannelMessageVersionResponse           = 15,
+    ChannelMessageUnload                    = 16,
+#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD
+    ChannelMessageViewRangeAdd              = 17,
+    ChannelMessageViewRangeRemove           = 18,
+#endif
+    ChannelMessageCount
+} VMBUS_CHANNEL_MESSAGE_TYPE, *PVMBUS_CHANNEL_MESSAGE_TYPE;
+
+// begin_wpp config
+// CUSTOM_TYPE(ChannelMessageType, ItemEnum(_VMBUS_CHANNEL_MESSAGE_TYPE));
+// end_wpp
+
+typedef struct _VMBUS_CHANNEL_MESSAGE_HEADER
+{
+    VMBUS_CHANNEL_MESSAGE_TYPE  MessageType;
+    UINT32                      Padding;
+} VMBUS_CHANNEL_MESSAGE_HEADER, *PVMBUS_CHANNEL_MESSAGE_HEADER;
+
+// Query VMBus Version parameters
+typedef struct _VMBUS_CHANNEL_QUERY_VMBUS_VERSION
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32 Version;
+} VMBUS_CHANNEL_QUERY_VMBUS_VERSION, *PVMBUS_CHANNEL_QUERY_VMBUS_VERSION;
+
+// VMBus Version Supported parameters
+typedef struct _VMBUS_CHANNEL_VERSION_SUPPORTED
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    BOOLEAN VersionSupported;
+} VMBUS_CHANNEL_VERSION_SUPPORTED, *PVMBUS_CHANNEL_VERSION_SUPPORTED;
+
+// Offer Channel parameters
+typedef struct _VMBUS_CHANNEL_OFFER_CHANNEL
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    VMBUS_CHANNEL_OFFER Offer;
+    UINT32  ChildRelId;
+    UINT8   MonitorId;
+    BOOLEAN MonitorAllocated;
+} VMBUS_CHANNEL_OFFER_CHANNEL, *PVMBUS_CHANNEL_OFFER_CHANNEL;
+
+//
+// Make sure VMBUS_CHANNEL_OFFER_CHANNEL fits into Synic message.
+//
+C_ASSERT(sizeof(VMBUS_CHANNEL_OFFER_CHANNEL) <= MAXIMUM_SYNIC_MESSAGE_BYTES);
+
+// Rescind Offer parameters
+typedef struct _VMBUS_CHANNEL_RESCIND_OFFER
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32          ChildRelId;
+} VMBUS_CHANNEL_RESCIND_OFFER, *PVMBUS_CHANNEL_RESCIND_OFFER;
+
+// Request Offer -- no parameters, SynIC message contains the partition ID
+// Set Snoop -- no parameters, SynIC message contains the partition ID
+// Clear Snoop -- no parameters, SynIC message contains the partition ID
+// All Offers Delivered -- no parameters, SynIC message contains the partition ID
+// Flush Client -- no parameters, SynIC message contains the partition ID
+
+// Open Channel parameters
+typedef struct _VMBUS_CHANNEL_OPEN_CHANNEL
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+
+    //
+    // Identifies the specific VMBus channel that is being opened.
+    //
+    UINT32          ChildRelId;
+
+    //
+    // ID making a particular open request at a channel offer unique.
+    //
+    UINT32          OpenId;
+
+    //
+    // GPADL for the channel's ring buffer.
+    //
+    GPADL_HANDLE    RingBufferGpadlHandle;
+
+    //
+    // GPADL for the channel's server context save area.
+    //
+    GPADL_HANDLE    ServerContextAreaGpadlHandle;
+
+    //
+    // The upstream ring buffer begins at offset zero in the memory described
+    // by RingBufferGpadlHandle. The downstream ring buffer follows it at this
+    // offset (in pages).
+    //
+    UINT32          DownstreamRingBufferPageOffset;
+
+    //
+    // User-specific data to be passed along to the server endpoint.
+    //
+    UCHAR           UserData[MAX_USER_DEFINED_BYTES];
+
+} VMBUS_CHANNEL_OPEN_CHANNEL, *PVMBUS_CHANNEL_OPEN_CHANNEL;
+
+// Reopen Channel parameters;
+typedef VMBUS_CHANNEL_OPEN_CHANNEL VMBUS_CHANNEL_REOPEN_CHANNEL, *PVMBUS_CHANNEL_REOPEN_CHANNEL;
+
+// Open Channel Result parameters
+typedef struct _VMBUS_CHANNEL_OPEN_RESULT
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32      ChildRelId;
+    UINT32      OpenId;
+    NTSTATUS    Status;
+} VMBUS_CHANNEL_OPEN_RESULT, *PVMBUS_CHANNEL_OPEN_RESULT;
+
+// Close channel parameters;
+typedef struct _VMBUS_CHANNEL_CLOSE_CHANNEL
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32      ChildRelId;
+} VMBUS_CHANNEL_CLOSE_CHANNEL, *PVMBUS_CHANNEL_CLOSE_CHANNEL;
+
+// Channel Message GPADL
+#define GPADL_TYPE_RING_BUFFER          1
+#define GPADL_TYPE_SERVER_SAVE_AREA     2
+#define GPADL_TYPE_TRANSACTION          8
+
+//
+// The number of PFNs in a GPADL message is defined by the number of pages
+// that would be spanned by ByteCount and ByteOffset.  If the implied number
+// of PFNs won't fit in this packet, there will be a follow-up packet that
+// contains more.
+//
+
+typedef struct _VMBUS_CHANNEL_GPADL_HEADER
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32      ChildRelId;
+    UINT32      Gpadl;
+    UINT16      RangeBufLen;
+    UINT16      RangeCount;
+    GPA_RANGE   Range[0];
+} VMBUS_CHANNEL_GPADL_HEADER, *PVMBUS_CHANNEL_GPADL_HEADER;
+
+
+//
+// This is the followup packet that contains more PFNs.
+//
+
+typedef struct _VMBUS_CHANNEL_GPADL_BODY
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32              MessageNumber;
+    UINT32              Gpadl;
+    UINT64              Pfn[0];
+} VMBUS_CHANNEL_GPADL_BODY, *PVMBUS_CHANNEL_GPADL_BODY;
+
+
+typedef struct _VMBUS_CHANNEL_GPADL_CREATED
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32              ChildRelId;
+    UINT32              Gpadl;
+    UINT32              CreationStatus;
+} VMBUS_CHANNEL_GPADL_CREATED, *PVMBUS_CHANNEL_GPADL_CREATED;
+
+typedef struct _VMBUS_CHANNEL_GPADL_TEARDOWN
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32              ChildRelId;
+    UINT32              Gpadl;
+} VMBUS_CHANNEL_GPADL_TEARDOWN, *PVMBUS_CHANNEL_GPADL_TEARDOWN;
+
+typedef struct _VMBUS_CHANNEL_GPADL_TORNDOWN
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32              Gpadl;
+} VMBUS_CHANNEL_GPADL_TORNDOWN, *PVMBUS_CHANNEL_GPADL_TORNDOWN;
+
+#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD
+typedef struct _VMBUS_CHANNEL_VIEW_RANGE_ADD
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    PHYSICAL_ADDRESS    ViewRangeBase;
+    UINT64              ViewRangeLength;
+    UINT32              ChildRelId;
+} VMBUS_CHANNEL_VIEW_RANGE_ADD, *PVMBUS_CHANNEL_VIEW_RANGE_ADD;
+
+typedef struct _VMBUS_CHANNEL_VIEW_RANGE_REMOVE
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    PHYSICAL_ADDRESS    ViewRangeBase;
+    UINT32              ChildRelId;
+} VMBUS_CHANNEL_VIEW_RANGE_REMOVE, *PVMBUS_CHANNEL_VIEW_RANGE_REMOVE;
+#endif
+
+typedef struct _VMBUS_CHANNEL_RELID_RELEASED
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32              ChildRelId;
+} VMBUS_CHANNEL_RELID_RELEASED, *PVMBUS_CHANNEL_RELID_RELEASED;
+
+typedef struct _VMBUS_CHANNEL_INITIATE_CONTACT
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    UINT32              VMBusVersionRequested;
+    UINT32              Padding2;
+    UINT64              InterruptPage;
+    UINT64              MonitorPage1;
+    UINT64              MonitorPage2;
+} VMBUS_CHANNEL_INITIATE_CONTACT, *PVMBUS_CHANNEL_INITIATE_CONTACT;
+
+typedef struct _VMBUS_CHANNEL_VERSION_RESPONSE
+{
+    VMBUS_CHANNEL_MESSAGE_HEADER Header;
+    BOOLEAN     VersionSupported;
+} VMBUS_CHANNEL_VERSION_RESPONSE, *PVMBUS_CHANNEL_VERSION_RESPONSE;
+
+typedef VMBUS_CHANNEL_MESSAGE_HEADER VMBUS_CHANNEL_UNLOAD, *PVMBUS_CHANNEL_UNLOAD;
+
+//
+// Kind of a table to use the preprocessor to get us the right type for a
+// specified message ID. Used with ChAllocateSendMessage()
+//
+#define ChannelMessageQueryVmbusVersion_TYPE    VMBUS_CHANNEL_MESSAGE_HEADER
+#define ChannelMessageVmbusVersionSupported_TYPE VMBUS_CHANNEL_VERSION_SUPPORTED
+#define ChannelMessageOfferChannel_TYPE         VMBUS_CHANNEL_OFFER_CHANNEL
+#define ChannelMessageRescindChannelOffer_TYPE  VMBUS_CHANNEL_RESCIND_OFFER
+#define ChannelMessageRequestOffers_TYPE        VMBUS_CHANNEL_MESSAGE_HEADER
+#define ChannelMessageAllOffersDelivered_TYPE   VMBUS_CHANNEL_MESSAGE_HEADER
+#define ChannelMessageOpenChannel_TYPE          VMBUS_CHANNEL_OPEN_CHANNEL
+#define ChannelMessageOpenChannelResult_TYPE    VMBUS_CHANNEL_OPEN_RESULT
+#define ChannelMessageCloseChannel_TYPE         VMBUS_CHANNEL_CLOSE_CHANNEL
+#define ChannelMessageAllGpadlsUnmapped_TYPE    VMBUS_CHANNEL_CLOSE_CHANNEL
+#define ChannelMessageGpadlHeader_TYPE          VMBUS_CHANNEL_GPADL_HEADER
+#define ChannelMessageGpadlBody_TYPE            VMBUS_CHANNEL_GPADL_BODY
+#define ChannelMessageGpadlCreated_TYPE         VMBUS_CHANNEL_GPADL_CREATED
+#define ChannelMessageGpadlTeardown_TYPE        VMBUS_CHANNEL_GPADL_TEARDOWN
+#define ChannelMessageGpadlTorndown_TYPE        VMBUS_CHANNEL_GPADL_TORNDOWN
+#define ChannelMessageViewRangeAdd_TYPE         VMBUS_CHANNEL_VIEW_RANGE_ADD
+#define ChannelMessageViewRangeRemove_TYPE      VMBUS_CHANNEL_VIEW_RANGE_REMOVE
+#define ChannelMessageRelIdReleased_TYPE        VMBUS_CHANNEL_RELID_RELEASED
+#define ChannelMessageInitiateContact_TYPE      VMBUS_CHANNEL_INITIATE_CONTACT
+#define ChannelMessageVersionResponse_TYPE      VMBUS_CHANNEL_VERSION_RESPONSE
+#define ChannelMessageUnload_TYPE               VMBUS_CHANNEL_UNLOAD
+
+//
+// Preprocessor wrapper to ChAllocateSendMessageSize() converting the return
+// value to the correct pointer and calculate the needed size.
+//
+// Argument:
+//
+//  Id - the numberic ID (type VMBUS_CHANNEL_MESSAGE_TYPE) of the message to
+//       send.
+//
+#define ChAllocateSendMessage(Id, Fn, Context)   \
+    (Id##_TYPE*)ChAllocateSendMessageSized(sizeof(Id##_TYPE), Id, Fn, Context)
+
+
+#pragma pack(pop)
+
--- /dev/null
+++ b/drivers/staging/hv/include/HvHalApi.h
@@ -0,0 +1,32 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+
+
+//
+// Time in the hypervisor is measured in 100 nanosecond units
+//
+typedef UINT64 HV_NANO100_TIME,     *PHV_NANO100_TIME;
+typedef UINT64 HV_NANO100_DURATION, *PHV_NANO100_DURATION;
--- /dev/null
+++ b/drivers/staging/hv/include/HvHcApi.h
@@ -0,0 +1,60 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+
+//
+// Declare the various hypercall operations.
+//
+typedef enum _HV_CALL_CODE
+{
+
+    HvCallPostMessage                   = 0x005c,
+    HvCallSignalEvent                   = 0x005d,
+
+} HV_CALL_CODE, *PHV_CALL_CODE;
+//
+// Definition of the HvPostMessage hypercall input structure.
+//
+
+typedef struct _HV_INPUT_POST_MESSAGE
+{
+    HV_CONNECTION_ID    ConnectionId;
+    UINT32              Reserved;
+    HV_MESSAGE_TYPE     MessageType;
+    UINT32              PayloadSize;
+    UINT64              Payload[HV_MESSAGE_PAYLOAD_QWORD_COUNT];
+} HV_INPUT_POST_MESSAGE, *PHV_INPUT_POST_MESSAGE;
+
+
+//
+// Definition of the HvSignalEvent hypercall input structure.
+//
+
+typedef struct _HV_INPUT_SIGNAL_EVENT
+{
+    HV_CONNECTION_ID ConnectionId;
+    UINT16           FlagNumber;
+    UINT16           RsvdZ;
+} HV_INPUT_SIGNAL_EVENT, *PHV_INPUT_SIGNAL_EVENT;
--- /dev/null
+++ b/drivers/staging/hv/include/HvPtApi.h
@@ -0,0 +1,86 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+
+//
+// Versioning definitions used for guests reporting themselves to the
+// hypervisor, and visa versa.
+// ==================================================================
+//
+
+//
+// Version info reported by guest OS's
+//
+typedef enum _HV_GUEST_OS_VENDOR
+{
+    HvGuestOsVendorMicrosoft        = 0x0001
+
+} HV_GUEST_OS_VENDOR, *PHV_GUEST_OS_VENDOR;
+
+typedef enum _HV_GUEST_OS_MICROSOFT_IDS
+{
+    HvGuestOsMicrosoftUndefined     = 0x00,
+    HvGuestOsMicrosoftMSDOS         = 0x01,
+    HvGuestOsMicrosoftWindows3x     = 0x02,
+    HvGuestOsMicrosoftWindows9x     = 0x03,
+    HvGuestOsMicrosoftWindowsNT     = 0x04,
+    HvGuestOsMicrosoftWindowsCE     = 0x05
+
+} HV_GUEST_OS_MICROSOFT_IDS, *PHV_GUEST_OS_MICROSOFT_IDS;
+
+//
+// Declare the MSR used to identify the guest OS.
+//
+#define HV_X64_MSR_GUEST_OS_ID 0x40000000
+
+typedef union _HV_X64_MSR_GUEST_OS_ID_CONTENTS
+{
+    UINT64 AsUINT64;
+    struct
+    {
+        UINT64 BuildNumber    : 16;
+        UINT64 ServiceVersion : 8; // Service Pack, etc.
+        UINT64 MinorVersion   : 8;
+        UINT64 MajorVersion   : 8;
+        UINT64 OsId           : 8; // HV_GUEST_OS_MICROSOFT_IDS (If Vendor=MS)
+        UINT64 VendorId       : 16; // HV_GUEST_OS_VENDOR
+    };
+} HV_X64_MSR_GUEST_OS_ID_CONTENTS, *PHV_X64_MSR_GUEST_OS_ID_CONTENTS;
+
+//
+// Declare the MSR used to setup pages used to communicate with the hypervisor.
+//
+#define HV_X64_MSR_HYPERCALL 0x40000001
+
+typedef union _HV_X64_MSR_HYPERCALL_CONTENTS
+{
+    UINT64 AsUINT64;
+    struct
+    {
+        UINT64 Enable               : 1;
+        UINT64 Reserved             : 11;
+        UINT64 GuestPhysicalAddress : 52;
+    };
+} HV_X64_MSR_HYPERCALL_CONTENTS, *PHV_X64_MSR_HYPERCALL_CONTENTS;
--- /dev/null
+++ b/drivers/staging/hv/include/HvStatus.h
@@ -0,0 +1,718 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+// begin_hvgdk
+//
+// Status codes for hypervisor operations.
+//
+typedef UINT16 HV_STATUS, *PHV_STATUS;
+
+//
+// MessageId: HV_STATUS_SUCCESS
+//
+// MessageText:
+//
+// The specified hypercall succeeded
+//
+#define HV_STATUS_SUCCESS                ((HV_STATUS)0x0000)
+
+//
+// MessageId: HV_STATUS_INVALID_HYPERCALL_CODE
+//
+// MessageText:
+//
+// The hypervisor does not support the operation because the specified hypercall code is not supported.
+//
+#define HV_STATUS_INVALID_HYPERCALL_CODE ((HV_STATUS)0x0002)
+
+//
+// MessageId: HV_STATUS_INVALID_HYPERCALL_INPUT
+//
+// MessageText:
+//
+// The hypervisor does not support the operation because the encoding for the hypercall input register is not supported.
+//
+#define HV_STATUS_INVALID_HYPERCALL_INPUT ((HV_STATUS)0x0003)
+
+//
+// MessageId: HV_STATUS_INVALID_ALIGNMENT
+//
+// MessageText:
+//
+// The hypervisor could not perform the operation beacuse a parameter has an invalid alignment.
+//
+#define HV_STATUS_INVALID_ALIGNMENT      ((HV_STATUS)0x0004)
+
+//
+// MessageId: HV_STATUS_INVALID_PARAMETER
+//
+// MessageText:
+//
+// The hypervisor could not perform the operation beacuse an invalid parameter was specified.
+//
+#define HV_STATUS_INVALID_PARAMETER      ((HV_STATUS)0x0005)
+
+//
+// MessageId: HV_STATUS_ACCESS_DENIED
+//
+// MessageText:
+//
+// Access to the specified object was denied.
+//
+#define HV_STATUS_ACCESS_DENIED          ((HV_STATUS)0x0006)
+
+//
+// MessageId: HV_STATUS_INVALID_PARTITION_STATE
+//
+// MessageText:
+//
+// The hypervisor could not perform the operation because the partition is entering or in an invalid state.
+//
+#define HV_STATUS_INVALID_PARTITION_STATE ((HV_STATUS)0x0007)
+
+//
+// MessageId: HV_STATUS_OPERATION_DENIED
+//
+// MessageText:
+//
+// The operation is not allowed in the current state.
+//
+#define HV_STATUS_OPERATION_DENIED       ((HV_STATUS)0x0008)
+
+//
+// MessageId: HV_STATUS_UNKNOWN_PROPERTY
+//
+// MessageText:
+//
+// The hypervisor does not recognize the specified partition property.
+//
+#define HV_STATUS_UNKNOWN_PROPERTY       ((HV_STATUS)0x0009)
+
+//
+// MessageId: HV_STATUS_PROPERTY_VALUE_OUT_OF_RANGE
+//
+// MessageText:
+//
+// The specified value of a partition property is out of range or violates an invariant.
+//
+#define HV_STATUS_PROPERTY_VALUE_OUT_OF_RANGE ((HV_STATUS)0x000A)
+
+//
+// MessageId: HV_STATUS_INSUFFICIENT_MEMORY
+//
+// MessageText:
+//
+// There is not enough memory in the hypervisor pool to complete the operation.
+//
+#define HV_STATUS_INSUFFICIENT_MEMORY    ((HV_STATUS)0x000B)
+
+//
+// MessageId: HV_STATUS_PARTITION_TOO_DEEP
+//
+// MessageText:
+//
+// The maximum partition depth has been exceeded for the partition hierarchy.
+//
+#define HV_STATUS_PARTITION_TOO_DEEP     ((HV_STATUS)0x000C)
+
+//
+// MessageId: HV_STATUS_INVALID_PARTITION_ID
+//
+// MessageText:
+//
+// A partition with the specified partition Id does not exist.
+//
+#define HV_STATUS_INVALID_PARTITION_ID   ((HV_STATUS)0x000D)
+
+//
+// MessageId: HV_STATUS_INVALID_VP_INDEX
+//
+// MessageText:
+//
+// The hypervisor could not perform the operation because the specified VP index is invalid.
+//
+#define HV_STATUS_INVALID_VP_INDEX       ((HV_STATUS)0x000E)
+
+//
+// MessageId: HV_STATUS_NOT_FOUND
+//
+// MessageText:
+//
+// The iteration is complete; no addition items in the iteration could be found.
+//
+#define HV_STATUS_NOT_FOUND              ((HV_STATUS)0x0010)
+
+//
+// MessageId: HV_STATUS_INVALID_PORT_ID
+//
+// MessageText:
+//
+// The hypervisor could not perform the operation because the specified port identifier is invalid.
+//
+#define HV_STATUS_INVALID_PORT_ID        ((HV_STATUS)0x0011)
+
+//
+// MessageId: HV_STATUS_INVALID_CONNECTION_ID
+//
+// MessageText:
+//
+// The hypervisor could not perform the operation because the specified connection identifier is invalid.
+//
+#define HV_STATUS_INVALID_CONNECTION_ID  ((HV_STATUS)0x0012)
+
+//
+// MessageId: HV_STATUS_INSUFFICIENT_BUFFERS
+//
+// MessageText:
+//
+// You did not supply enough message buffers to send a message.
+//
+#define HV_STATUS_INSUFFICIENT_BUFFERS   ((HV_STATUS)0x0013)
+
+//
+// MessageId: HV_STATUS_NOT_ACKNOWLEDGED
+//
+// MessageText:
+//
+// The previous virtual interrupt has not been acknowledged.
+//
+#define HV_STATUS_NOT_ACKNOWLEDGED       ((HV_STATUS)0x0014)
+
+//
+// MessageId: HV_STATUS_INVALID_VP_STATE
+//
+// MessageText:
+//
+// A virtual processor is not in the correct state for the performance of the indicated operation.
+//
+#define HV_STATUS_INVALID_VP_STATE       ((HV_STATUS)0x0015)
+
+//
+// MessageId: HV_STATUS_ACKNOWLEDGED
+//
+// MessageText:
+//
+// The previous virtual interrupt has already been acknowledged.
+//
+#define HV_STATUS_ACKNOWLEDGED           ((HV_STATUS)0x0016)
+
+//
+// MessageId: HV_STATUS_INVALID_SAVE_RESTORE_STATE
+//
+// MessageText:
+//
+// The indicated partition is not in a valid state for saving or restoring.
+//
+#define HV_STATUS_INVALID_SAVE_RESTORE_STATE ((HV_STATUS)0x0017)
+
+//
+// MessageId: HV_STATUS_INVALID_SYNIC_STATE
+//
+// MessageText:
+//
+// The hypervisor could not complete the operation because a required feature of the synthetic interrupt controller (SynIC) was disabled.
+//
+#define HV_STATUS_INVALID_SYNIC_STATE    ((HV_STATUS)0x0018)
+
+//
+// MessageId: HV_STATUS_OBJECT_IN_USE
+//
+// MessageText:
+//
+// The hypervisor could not perform the operation because the object or value was either already in use or being used for a purpose that would not permit completing the operation.
+//
+#define HV_STATUS_OBJECT_IN_USE          ((HV_STATUS)0x0019)
+
+//
+// MessageId: HV_STATUS_INVALID_PROXIMITY_DOMAIN_INFO
+//
+// MessageText:
+//
+// The proximity domain information is invalid.
+//
+#define HV_STATUS_INVALID_PROXIMITY_DOMAIN_INFO ((HV_STATUS)0x001A)
+
+//
+// MessageId: HV_STATUS_NO_DATA
+//
+// MessageText:
+//
+// An attempt to retrieve debugging data failed because none was available.
+//
+#define HV_STATUS_NO_DATA                ((HV_STATUS)0x001B)
+
+//
+// MessageId: HV_STATUS_INACTIVE
+//
+// MessageText:
+//
+// The physical connection being used for debuggging has not recorded any receive activity since the last operation.
+//
+#define HV_STATUS_INACTIVE               ((HV_STATUS)0x001C)
+
+//
+// MessageId: HV_STATUS_NO_RESOURCES
+//
+// MessageText:
+//
+// There are not enough resources to complete the operation.
+//
+#define HV_STATUS_NO_RESOURCES           ((HV_STATUS)0x001D)
+
+//
+// MessageId: HV_STATUS_FEATURE_UNAVAILABLE
+//
+// MessageText:
+//
+// A hypervisor feature is not available to the user.
+//
+#define HV_STATUS_FEATURE_UNAVAILABLE    ((HV_STATUS)0x001E)
+
+// end_hvgdk
+
+//
+// MessageId: HV_STATUS_UNSUCCESSFUL
+//
+// MessageText:
+//
+// {Operation Failed}
+// The requested operation was unsuccessful.
+//
+#define HV_STATUS_UNSUCCESSFUL           ((HV_STATUS)0x1001)
+
+//
+// MessageId: HV_STATUS_INSUFFICIENT_BUFFER
+//
+// MessageText:
+//
+// The specified buffer was too small to contain all of the requested data.
+//
+#define HV_STATUS_INSUFFICIENT_BUFFER    ((HV_STATUS)0x1002)
+
+//
+// MessageId: HV_STATUS_GPA_NOT_PRESENT
+//
+// MessageText:
+//
+// The guest physical address is not currently associated with a system physical address.
+//
+#define HV_STATUS_GPA_NOT_PRESENT        ((HV_STATUS)0x1003)
+
+//
+// MessageId: HV_STATUS_GUEST_PAGE_FAULT
+//
+// MessageText:
+//
+// The operation would have resulted in a page fault in the guest.
+//
+#define HV_STATUS_GUEST_PAGE_FAULT       ((HV_STATUS)0x1004)
+
+//
+// MessageId: HV_STATUS_RUNDOWN_DISABLED
+//
+// MessageText:
+//
+// The operation cannot proceed as the rundown object was marked disabled.
+//
+#define HV_STATUS_RUNDOWN_DISABLED       ((HV_STATUS)0x1005)
+
+//
+// MessageId: HV_STATUS_KEY_ALREADY_EXISTS
+//
+// MessageText:
+//
+// The entry cannot be added as another entry with the same key already exists.
+//
+#define HV_STATUS_KEY_ALREADY_EXISTS     ((HV_STATUS)0x1006)
+
+//
+// MessageId: HV_STATUS_GPA_INTERCEPT
+//
+// MessageText:
+//
+// The operation resulted an intercept on a region of guest physical memory.
+//
+#define HV_STATUS_GPA_INTERCEPT          ((HV_STATUS)0x1007)
+
+//
+// MessageId: HV_STATUS_GUEST_GENERAL_PROTECTION_FAULT
+//
+// MessageText:
+//
+// The operation would have resulted in a general protection fault in the guest.
+//
+#define HV_STATUS_GUEST_GENERAL_PROTECTION_FAULT ((HV_STATUS)0x1008)
+
+//
+// MessageId: HV_STATUS_GUEST_STACK_FAULT
+//
+// MessageText:
+//
+// The operation would have resulted in a stack fault in the guest.
+//
+#define HV_STATUS_GUEST_STACK_FAULT      ((HV_STATUS)0x1009)
+
+//
+// MessageId: HV_STATUS_GUEST_INVALID_OPCODE_FAULT
+//
+// MessageText:
+//
+// The operation would have resulted in an invalid opcode fault in the guest.
+//
+#define HV_STATUS_GUEST_INVALID_OPCODE_FAULT ((HV_STATUS)0x100A)
+
+//
+// MessageId: HV_STATUS_FINALIZE_INCOMPLETE
+//
+// MessageText:
+//
+// The partition is not completely finalized.
+//
+#define HV_STATUS_FINALIZE_INCOMPLETE    ((HV_STATUS)0x100B)
+
+//
+// MessageId: HV_STATUS_GUEST_MACHINE_CHECK_ABORT
+//
+// MessageText:
+//
+// The operation would have resulted in an machine check abort in the guest.
+//
+#define HV_STATUS_GUEST_MACHINE_CHECK_ABORT ((HV_STATUS)0x100C)
+
+//
+// MessageId: HV_STATUS_ILLEGAL_OVERLAY_ACCESS
+//
+// MessageText:
+//
+// An illegal access was attempted to an overlay page.
+//
+#define HV_STATUS_ILLEGAL_OVERLAY_ACCESS ((HV_STATUS)0x100D)
+
+//
+// MessageId: HV_STATUS_INSUFFICIENT_SYSTEM_VA
+//
+// MessageText:
+//
+// There is not enough system VA space available to satisfy the request,
+//
+#define HV_STATUS_INSUFFICIENT_SYSTEM_VA ((HV_STATUS)0x100E)
+
+//
+// MessageId: HV_STATUS_VIRTUAL_ADDRESS_NOT_MAPPED
+//
+// MessageText:
+//
+// The passed virtual address was not mapped in the hypervisor address space.
+//
+#define HV_STATUS_VIRTUAL_ADDRESS_NOT_MAPPED ((HV_STATUS)0x100F)
+
+//
+// MessageId: HV_STATUS_NOT_IMPLEMENTED
+//
+// MessageText:
+//
+// The requested operation is not implemented in this version of the hypervisor.
+//
+#define HV_STATUS_NOT_IMPLEMENTED        ((HV_STATUS)0x1010)
+
+//
+// MessageId: HV_STATUS_VMX_INSTRUCTION_FAILED
+//
+// MessageText:
+//
+// The requested VMX instruction failed to complete succesfully.
+//
+#define HV_STATUS_VMX_INSTRUCTION_FAILED ((HV_STATUS)0x1011)
+
+//
+// MessageId: HV_STATUS_VMX_INSTRUCTION_FAILED_WITH_STATUS
+//
+// MessageText:
+//
+// The requested VMX instruction failed to complete succesfully indicating status.
+//
+#define HV_STATUS_VMX_INSTRUCTION_FAILED_WITH_STATUS ((HV_STATUS)0x1012)
+
+//
+// MessageId: HV_STATUS_MSR_ACCESS_FAILED
+//
+// MessageText:
+//
+// The requested access to the model specific register failed.
+//
+#define HV_STATUS_MSR_ACCESS_FAILED      ((HV_STATUS)0x1013)
+
+//
+// MessageId: HV_STATUS_CR_ACCESS_FAILED
+//
+// MessageText:
+//
+// The requested access to the control register failed.
+//
+#define HV_STATUS_CR_ACCESS_FAILED       ((HV_STATUS)0x1014)
+
+//
+// MessageId: HV_STATUS_TIMEOUT
+//
+// MessageText:
+//
+// The specified timeout expired before the operation completed.
+//
+#define HV_STATUS_TIMEOUT                ((HV_STATUS)0x1016)
+
+//
+// MessageId: HV_STATUS_MSR_INTERCEPT
+//
+// MessageText:
+//
+// The requested access to the model specific register generated an intercept.
+//
+#define HV_STATUS_MSR_INTERCEPT          ((HV_STATUS)0x1017)
+
+//
+// MessageId: HV_STATUS_CPUID_INTERCEPT
+//
+// MessageText:
+//
+// The CPUID instruction generated an intercept.
+//
+#define HV_STATUS_CPUID_INTERCEPT        ((HV_STATUS)0x1018)
+
+//
+// MessageId: HV_STATUS_REPEAT_INSTRUCTION
+//
+// MessageText:
+//
+// The current instruction should be repeated and the instruction pointer not advanced.
+//
+#define HV_STATUS_REPEAT_INSTRUCTION     ((HV_STATUS)0x1019)
+
+//
+// MessageId: HV_STATUS_PAGE_PROTECTION_VIOLATION
+//
+// MessageText:
+//
+// The current instruction should be repeated and the instruction pointer not advanced.
+//
+#define HV_STATUS_PAGE_PROTECTION_VIOLATION ((HV_STATUS)0x101A)
+
+//
+// MessageId: HV_STATUS_PAGE_TABLE_INVALID
+//
+// MessageText:
+//
+// The current instruction should be repeated and the instruction pointer not advanced.
+//
+#define HV_STATUS_PAGE_TABLE_INVALID     ((HV_STATUS)0x101B)
+
+//
+// MessageId: HV_STATUS_PAGE_NOT_PRESENT
+//
+// MessageText:
+//
+// The current instruction should be repeated and the instruction pointer not advanced.
+//
+#define HV_STATUS_PAGE_NOT_PRESENT       ((HV_STATUS)0x101C)
+
+//
+// MessageId: HV_STATUS_IO_INTERCEPT
+//
+// MessageText:
+//
+// The requested access to the I/O port generated an intercept.
+//
+#define HV_STATUS_IO_INTERCEPT           ((HV_STATUS)0x101D)
+
+//
+// MessageId: HV_STATUS_NOTHING_TO_DO
+//
+// MessageText:
+//
+// There is nothing to do.
+//
+#define HV_STATUS_NOTHING_TO_DO          ((HV_STATUS)0x101E)
+
+//
+// MessageId: HV_STATUS_THREAD_TERMINATING
+//
+// MessageText:
+//
+// The requested thread is terminating.
+//
+#define HV_STATUS_THREAD_TERMINATING     ((HV_STATUS)0x101F)
+
+//
+// MessageId: HV_STATUS_SECTION_ALREADY_CONSTRUCTED
+//
+// MessageText:
+//
+// The specified section was already constructed.
+//
+#define HV_STATUS_SECTION_ALREADY_CONSTRUCTED ((HV_STATUS)0x1020)
+
+//
+// MessageId: HV_STATUS_SECTION_NOT_ALREADY_CONSTRUCTED
+//
+// MessageText:
+//
+// The specified section was not already constructed.
+//
+#define HV_STATUS_SECTION_NOT_ALREADY_CONSTRUCTED ((HV_STATUS)0x1021)
+
+//
+// MessageId: HV_STATUS_PAGE_ALREADY_COMMITTED
+//
+// MessageText:
+//
+// The specified virtual address was already backed by physical memory.
+//
+#define HV_STATUS_PAGE_ALREADY_COMMITTED ((HV_STATUS)0x1022)
+
+//
+// MessageId: HV_STATUS_PAGE_NOT_ALREADY_COMMITTED
+//
+// MessageText:
+//
+// The specified virtual address was not already backed by physical memory.
+//
+#define HV_STATUS_PAGE_NOT_ALREADY_COMMITTED ((HV_STATUS)0x1023)
+
+//
+// MessageId: HV_STATUS_COMMITTED_PAGES_REMAIN
+//
+// MessageText:
+//
+// Committed pages remain in the section.
+//
+#define HV_STATUS_COMMITTED_PAGES_REMAIN ((HV_STATUS)0x1024)
+
+//
+// MessageId: HV_STATUS_NO_REMAINING_COMMITTED_PAGES
+//
+// MessageText:
+//
+// No additional committed pages beyond the specified page exist in the section.
+//
+#define HV_STATUS_NO_REMAINING_COMMITTED_PAGES ((HV_STATUS)0x1025)
+
+//
+// MessageId: HV_STATUS_INSUFFICIENT_COMPARTMENT_VA
+//
+// MessageText:
+//
+// The VA space of the compartment is exhausted.
+//
+#define HV_STATUS_INSUFFICIENT_COMPARTMENT_VA ((HV_STATUS)0x1026)
+
+//
+// MessageId: HV_STATUS_DEREF_SPA_LIST_FULL
+//
+// MessageText:
+//
+// The SPA dereference list is full, and there are additional entries
+// to be added to it.
+//
+#define HV_STATUS_DEREF_SPA_LIST_FULL ((HV_STATUS)0x1027)
+
+//
+// MessageId: HV_STATUS_GPA_OUT_OF_RANGE
+//
+// MessageText:
+//
+// The supplied GPA is out of range.
+//
+#define HV_STATUS_GPA_OUT_OF_RANGE ((HV_STATUS)0x1027)
+
+//
+// MessageId: HV_STATUS_NONVOLATILE_XMM_STALE
+//
+// MessageText:
+//
+// The XMM register that was being accessed is stale.
+//
+#define HV_STATUS_NONVOLATILE_XMM_STALE ((HV_STATUS)0x1028)
+
+//
+// MessageId: HV_STATUS_UNSUPPORTED_PROCESSOR
+//
+// MessageText:
+//
+// The hypervisor does not support the processors in this system.
+//
+#define HV_STATUS_UNSUPPORTED_PROCESSOR ((HV_STATUS)0x1029)
+
+//
+// MessageId: HV_STATUS_INSUFFICIENT_CROM_SPACE
+//
+// MessageText:
+//
+// Insufficient space existed for copying over the CROM contents.
+//
+#define HV_STATUS_INSUFFICIENT_CROM_SPACE ((HV_STATUS)0x2000)
+
+//
+// MessageId: HV_STATUS_BAD_CROM_FORMAT
+//
+// MessageText:
+//
+// The contents of the CROM failed validation attempts.
+//
+#define HV_STATUS_BAD_CROM_FORMAT        ((HV_STATUS)0x2001)
+
+//
+// MessageId: HV_STATUS_UNSUPPORTED_CROM_FORMAT
+//
+// MessageText:
+//
+// The contents of the CROM contain contents the parser doesn't support.
+//
+#define HV_STATUS_UNSUPPORTED_CROM_FORMAT ((HV_STATUS)0x2002)
+
+//
+// MessageId: HV_STATUS_UNSUPPORTED_CONTROLLER
+//
+// MessageText:
+//
+// The register format of the OHCI controller specified for debugging is not supported.
+//
+#define HV_STATUS_UNSUPPORTED_CONTROLLER ((HV_STATUS)0x2003)
+
+//
+// MessageId: HV_STATUS_CROM_TOO_LARGE
+//
+// MessageText:
+//
+// The CROM contents were to large to copy over.
+//
+#define HV_STATUS_CROM_TOO_LARGE         ((HV_STATUS)0x2004)
+
+//
+// MessageId: HV_STATUS_CONTROLLER_IN_USE
+//
+// MessageText:
+//
+// The OHCI controller specified for debugging cannot be used as it is already in use.
+//
+#define HV_STATUS_CONTROLLER_IN_USE      ((HV_STATUS)0x2005)
+
--- /dev/null
+++ b/drivers/staging/hv/include/HvSynicApi.h
@@ -0,0 +1,490 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+#pragma once
+
+//
+// Define the virtual APIC registers
+//
+#define HV_X64_MSR_EOI                  (0x40000070)
+#define HV_X64_MSR_ICR                  (0x40000071)
+#define HV_X64_MSR_TPR                  (0x40000072)
+#define HV_X64_MSR_APIC_ASSIST_PAGE     (0x40000073)
+
+//
+// Define version of the synthetic interrupt controller.
+//
+
+#define HV_SYNIC_VERSION        (1)
+
+
+//
+// Define synthetic interrupt controller model specific registers.
+//
+
+#define HV_X64_MSR_SCONTROL   (0x40000080)
+#define HV_X64_MSR_SVERSION   (0x40000081)
+#define HV_X64_MSR_SIEFP      (0x40000082)
+#define HV_X64_MSR_SIMP       (0x40000083)
+#define HV_X64_MSR_EOM        (0x40000084)
+#define HV_X64_MSR_SINT0      (0x40000090)
+#define HV_X64_MSR_SINT1      (0x40000091)
+#define HV_X64_MSR_SINT2      (0x40000092)
+#define HV_X64_MSR_SINT3      (0x40000093)
+#define HV_X64_MSR_SINT4      (0x40000094)
+#define HV_X64_MSR_SINT5      (0x40000095)
+#define HV_X64_MSR_SINT6      (0x40000096)
+#define HV_X64_MSR_SINT7      (0x40000097)
+#define HV_X64_MSR_SINT8      (0x40000098)
+#define HV_X64_MSR_SINT9      (0x40000099)
+#define HV_X64_MSR_SINT10     (0x4000009A)
+#define HV_X64_MSR_SINT11     (0x4000009B)
+#define HV_X64_MSR_SINT12     (0x4000009C)
+#define HV_X64_MSR_SINT13     (0x4000009D)
+#define HV_X64_MSR_SINT14     (0x4000009E)
+#define HV_X64_MSR_SINT15     (0x4000009F)
+
+//
+// Define the expected SynIC version.
+//
+#define HV_SYNIC_VERSION_1 (0x1)
+
+//
+// Define synthetic interrupt controller message constants.
+//
+
+#define HV_MESSAGE_SIZE                 (256)
+#define HV_MESSAGE_PAYLOAD_BYTE_COUNT   (240)
+#define HV_MESSAGE_PAYLOAD_QWORD_COUNT  (30)
+#define HV_ANY_VP                       (0xFFFFFFFF)
+
+//
+// Define synthetic interrupt controller flag constants.
+//
+
+#define HV_EVENT_FLAGS_COUNT        (256 * 8)
+#define HV_EVENT_FLAGS_BYTE_COUNT   (256)
+#define HV_EVENT_FLAGS_DWORD_COUNT  (256 / sizeof(UINT32))
+
+//
+// Define hypervisor message types.
+//
+typedef enum _HV_MESSAGE_TYPE
+{
+    HvMessageTypeNone = 0x00000000,
+
+    //
+    // Memory access messages.
+    //
+    HvMessageTypeUnmappedGpa = 0x80000000,
+    HvMessageTypeGpaIntercept = 0x80000001,
+
+    //
+    // Timer notification messages.
+    //
+    HvMessageTimerExpired = 0x80000010,
+
+    //
+    // Error messages.
+    //
+    HvMessageTypeInvalidVpRegisterValue = 0x80000020,
+    HvMessageTypeUnrecoverableException = 0x80000021,
+    HvMessageTypeUnsupportedFeature = 0x80000022,
+
+    //
+    // Trace buffer complete messages.
+    //
+    HvMessageTypeEventLogBufferComplete = 0x80000040,
+
+    //
+    // Platform-specific processor intercept messages.
+    //
+    HvMessageTypeX64IoPortIntercept = 0x80010000,
+    HvMessageTypeX64MsrIntercept = 0x80010001,
+    HvMessageTypeX64CpuidIntercept = 0x80010002,
+    HvMessageTypeX64ExceptionIntercept = 0x80010003,
+    HvMessageTypeX64ApicEoi = 0x80010004,
+    HvMessageTypeX64LegacyFpError = 0x80010005
+
+} HV_MESSAGE_TYPE, *PHV_MESSAGE_TYPE;
+
+//
+// Define the number of synthetic interrupt sources.
+//
+
+#define HV_SYNIC_SINT_COUNT (16)
+#define HV_SYNIC_STIMER_COUNT (4)
+
+//
+// Define the synthetic interrupt source index type.
+//
+
+typedef UINT32 HV_SYNIC_SINT_INDEX, *PHV_SYNIC_SINT_INDEX;
+
+//
+// Define partition identifier type.
+//
+
+typedef UINT64 HV_PARTITION_ID, *PHV_PARTITION_ID;
+
+//
+// Define invalid partition identifier.
+//
+#define HV_PARTITION_ID_INVALID ((HV_PARTITION_ID) 0x0)
+
+//
+// Define connection identifier type.
+//
+
+typedef union _HV_CONNECTION_ID
+{
+    UINT32 AsUINT32;
+
+    struct
+    {
+        UINT32 Id:24;
+        UINT32 Reserved:8;
+    } u;
+
+} HV_CONNECTION_ID, *PHV_CONNECTION_ID;
+
+//
+// Define port identifier type.
+//
+
+typedef union _HV_PORT_ID
+{
+    UINT32 AsUINT32;
+
+    struct
+    {
+        UINT32 Id:24;
+        UINT32 Reserved:8;
+    } u ;
+
+} HV_PORT_ID, *PHV_PORT_ID;
+
+//
+// Define port type.
+//
+
+typedef enum _HV_PORT_TYPE
+{
+    HvPortTypeMessage   = 1,
+    HvPortTypeEvent     = 2,
+    HvPortTypeMonitor   = 3
+} HV_PORT_TYPE, *PHV_PORT_TYPE;
+
+//
+// Define port information structure.
+//
+
+typedef struct _HV_PORT_INFO
+{
+    HV_PORT_TYPE PortType;
+    UINT32 Padding;
+
+    union
+    {
+        struct
+        {
+            HV_SYNIC_SINT_INDEX TargetSint;
+            HV_VP_INDEX TargetVp;
+            UINT64 RsvdZ;
+        } MessagePortInfo;
+
+        struct
+        {
+            HV_SYNIC_SINT_INDEX TargetSint;
+            HV_VP_INDEX TargetVp;
+            UINT16 BaseFlagNumber;
+            UINT16 FlagCount;
+            UINT32 RsvdZ;
+        } EventPortInfo;
+
+        struct
+        {
+            HV_GPA MonitorAddress;
+            UINT64 RsvdZ;
+        } MonitorPortInfo;
+    };
+} HV_PORT_INFO, *PHV_PORT_INFO;
+
+typedef const HV_PORT_INFO *PCHV_PORT_INFO;
+
+typedef struct _HV_CONNECTION_INFO
+{
+    HV_PORT_TYPE PortType;
+    UINT32 Padding;
+
+    union
+    {
+        struct
+        {
+            UINT64 RsvdZ;
+        } MessageConnectionInfo;
+
+        struct
+        {
+            UINT64 RsvdZ;
+        } EventConnectionInfo;
+
+        struct
+        {
+            HV_GPA MonitorAddress;
+        } MonitorConnectionInfo;
+    };
+} HV_CONNECTION_INFO, *PHV_CONNECTION_INFO;
+
+typedef const HV_CONNECTION_INFO *PCHV_CONNECTION_INFO;
+
+//
+// Define synthetic interrupt controller message flags.
+//
+
+typedef union _HV_MESSAGE_FLAGS
+{
+    UINT8 AsUINT8;
+    struct
+    {
+        UINT8 MessagePending:1;
+        UINT8 Reserved:7;
+    };
+} HV_MESSAGE_FLAGS, *PHV_MESSAGE_FLAGS;
+
+
+//
+// Define synthetic interrupt controller message header.
+//
+
+typedef struct _HV_MESSAGE_HEADER
+{
+    HV_MESSAGE_TYPE     MessageType;
+    UINT8               PayloadSize;
+    HV_MESSAGE_FLAGS    MessageFlags;
+    UINT8               Reserved[2];
+    union
+    {
+        HV_PARTITION_ID Sender;
+        HV_PORT_ID      Port;
+    };
+
+} HV_MESSAGE_HEADER, *PHV_MESSAGE_HEADER;
+
+//
+// Define timer message payload structure.
+//
+typedef struct _HV_TIMER_MESSAGE_PAYLOAD
+{
+    UINT32          TimerIndex;
+    UINT32          Reserved;
+    HV_NANO100_TIME ExpirationTime;     // When the timer expired
+    HV_NANO100_TIME DeliveryTime;       // When the message was delivered
+} HV_TIMER_MESSAGE_PAYLOAD, *PHV_TIMER_MESSAGE_PAYLOAD;
+
+//
+// Define synthetic interrupt controller message format.
+//
+
+typedef struct _HV_MESSAGE
+{
+    HV_MESSAGE_HEADER Header;
+    union
+    {
+        UINT64 Payload[HV_MESSAGE_PAYLOAD_QWORD_COUNT];
+    } u ;
+} HV_MESSAGE, *PHV_MESSAGE;
+
+//
+// Define the number of message buffers associated with each port.
+//
+
+#define HV_PORT_MESSAGE_BUFFER_COUNT (16)
+
+//
+// Define the synthetic interrupt message page layout.
+//
+
+typedef struct _HV_MESSAGE_PAGE
+{
+    volatile HV_MESSAGE SintMessage[HV_SYNIC_SINT_COUNT];
+} HV_MESSAGE_PAGE, *PHV_MESSAGE_PAGE;
+
+
+//
+// Define the synthetic interrupt controller event flags format.
+//
+
+typedef union _HV_SYNIC_EVENT_FLAGS
+{
+    UINT8 Flags8[HV_EVENT_FLAGS_BYTE_COUNT];
+    UINT32 Flags32[HV_EVENT_FLAGS_DWORD_COUNT];
+} HV_SYNIC_EVENT_FLAGS, *PHV_SYNIC_EVENT_FLAGS;
+
+
+//
+// Define the synthetic interrupt flags page layout.
+//
+
+typedef struct _HV_SYNIC_EVENT_FLAGS_PAGE
+{
+    volatile HV_SYNIC_EVENT_FLAGS SintEventFlags[HV_SYNIC_SINT_COUNT];
+} HV_SYNIC_EVENT_FLAGS_PAGE, *PHV_SYNIC_EVENT_FLAGS_PAGE;
+
+
+//
+// Define SynIC control register.
+//
+typedef union _HV_SYNIC_SCONTROL
+{
+    UINT64 AsUINT64;
+    struct
+    {
+        UINT64 Enable:1;
+        UINT64 Reserved:63;
+    };
+} HV_SYNIC_SCONTROL, *PHV_SYNIC_SCONTROL;
+
+//
+// Define synthetic interrupt source.
+//
+
+typedef union _HV_SYNIC_SINT
+{
+    UINT64 AsUINT64;
+    struct
+    {
+        UINT64 Vector    :8;
+        UINT64 Reserved1 :8;
+        UINT64 Masked    :1;
+        UINT64 AutoEoi   :1;
+        UINT64 Reserved2 :46;
+    };
+} HV_SYNIC_SINT, *PHV_SYNIC_SINT;
+
+//
+// Define the format of the SIMP register
+//
+
+typedef union _HV_SYNIC_SIMP
+{
+    UINT64 AsUINT64;
+    struct
+    {
+        UINT64 SimpEnabled : 1;
+        UINT64 Preserved   : 11;
+        UINT64 BaseSimpGpa : 52;
+    };
+} HV_SYNIC_SIMP, *PHV_SYNIC_SIMP;
+
+//
+// Define the format of the SIEFP register
+//
+
+typedef union _HV_SYNIC_SIEFP
+{
+    UINT64 AsUINT64;
+    struct
+    {
+        UINT64 SiefpEnabled : 1;
+        UINT64 Preserved   : 11;
+        UINT64 BaseSiefpGpa : 52;
+    };
+} HV_SYNIC_SIEFP, *PHV_SYNIC_SIEFP;
+
+//
+// Definitions for the monitored notification facility
+//
+
+typedef union _HV_MONITOR_TRIGGER_GROUP
+{
+    UINT64 AsUINT64;
+
+    struct
+    {
+        UINT32 Pending;
+        UINT32 Armed;
+    };
+
+} HV_MONITOR_TRIGGER_GROUP, *PHV_MONITOR_TRIGGER_GROUP;
+
+typedef struct _HV_MONITOR_PARAMETER
+{
+    HV_CONNECTION_ID    ConnectionId;
+    UINT16              FlagNumber;
+    UINT16              RsvdZ;
+} HV_MONITOR_PARAMETER, *PHV_MONITOR_PARAMETER;
+
+typedef union _HV_MONITOR_TRIGGER_STATE
+{
+    UINT32 AsUINT32;
+
+    struct
+    {
+        UINT32 GroupEnable : 4;
+        UINT32 RsvdZ       : 28;
+    };
+
+} HV_MONITOR_TRIGGER_STATE, *PHV_MONITOR_TRIGGER_STATE;
+
+//
+// HV_MONITOR_PAGE Layout
+// ------------------------------------------------------
+// | 0   | TriggerState (4 bytes) | Rsvd1 (4 bytes)     |
+// | 8   | TriggerGroup[0]                              |
+// | 10  | TriggerGroup[1]                              |
+// | 18  | TriggerGroup[2]                              |
+// | 20  | TriggerGroup[3]                              |
+// | 28  | Rsvd2[0]                                     |
+// | 30  | Rsvd2[1]                                     |
+// | 38  | Rsvd2[2]                                     |
+// | 40  | NextCheckTime[0][0]    | NextCheckTime[0][1] |
+// | ...                                                |
+// | 240 | Latency[0][0..3]                             |
+// | 340 | Rsvz3[0]                                     |
+// | 440 | Parameter[0][0]                              |
+// | 448 | Parameter[0][1]                              |
+// | ...                                                |
+// | 840 | Rsvd4[0]                                     |
+// ------------------------------------------------------
+
+typedef struct _HV_MONITOR_PAGE
+{
+    HV_MONITOR_TRIGGER_STATE TriggerState;
+    UINT32                   RsvdZ1;
+
+    HV_MONITOR_TRIGGER_GROUP TriggerGroup[4];
+    UINT64                   RsvdZ2[3];
+
+    INT32                    NextCheckTime[4][32];
+
+    UINT16                   Latency[4][32];
+    UINT64                   RsvdZ3[32];
+
+    HV_MONITOR_PARAMETER     Parameter[4][32];
+
+    UINT8                    RsvdZ4[1984];
+
+} HV_MONITOR_PAGE, *PHV_MONITOR_PAGE;
+
+typedef volatile HV_MONITOR_PAGE* PVHV_MONITOR_PAGE;
--- /dev/null
+++ b/drivers/staging/hv/include/HvTypes.h
@@ -0,0 +1,31 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+
+typedef UINT64 HV_GPA, *PHV_GPA;
+
+#define HV_X64_PAGE_SIZE (4096)
+#define HV_PAGE_SIZE HV_X64_PAGE_SIZE
+
--- /dev/null
+++ b/drivers/staging/hv/include/HvVpApi.h
@@ -0,0 +1,51 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+//
+// Virtual Processor Indices
+//
+typedef UINT32 HV_VP_INDEX, *PHV_VP_INDEX;
+
+//
+// The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
+// is set by CPUID(HvCpuIdFunctionVersionAndFeatures).
+// ==========================================================================
+//
+
+typedef enum _HV_CPUID_FUNCTION
+{
+    HvCpuIdFunctionVersionAndFeatures           = 0x00000001,
+    HvCpuIdFunctionHvVendorAndMaxFunction       = 0x40000000,
+    HvCpuIdFunctionHvInterface                  = 0x40000001,
+
+    //
+    // The remaining functions depend on the value of HvCpuIdFunctionInterface
+    //
+    HvCpuIdFunctionMsHvVersion                  = 0x40000002,
+    HvCpuIdFunctionMsHvFeatures                 = 0x40000003,
+    HvCpuIdFunctionMsHvEnlightenmentInformation = 0x40000004,
+    HvCpuIdFunctionMsHvImplementationLimits     = 0x40000005
+
+} HV_CPUID_FUNCTION, *PHV_CPUID_FUNCTION;
--- /dev/null
+++ b/drivers/staging/hv/include/List.h
@@ -0,0 +1,269 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#ifndef _LIST_H_
+#define _LIST_H_
+
+#include "osd.h"
+/*
+ *
+ *  Doubly-linked list manipulation routines.  Implemented as macros
+ *  but logically these are procedures.
+ *
+ */
+
+typedef DLIST_ENTRY LIST_ENTRY;
+typedef DLIST_ENTRY *PLIST_ENTRY;
+
+//typedef struct LIST_ENTRY {
+//   struct LIST_ENTRY * volatile Flink;
+//   struct LIST_ENTRY * volatile Blink;
+//} LIST_ENTRY, *PLIST_ENTRY;
+
+
+
+/*
+ *  VOID
+ *  InitializeListHead(
+ *      PLIST_ENTRY ListHead
+ *      );
+ */
+#define INITIALIZE_LIST_HEAD	InitializeListHead
+
+#define InitializeListHead(ListHead) (\
+    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
+
+
+/*
+ *  BOOLEAN
+ *  IsListEmpty(
+ *      PLIST_ENTRY ListHead
+ *      );
+ */
+#define IS_LIST_EMPTY			IsListEmpty
+
+#define IsListEmpty(ListHead) \
+    ((ListHead)->Flink == (ListHead))
+
+
+/*
+ *  PLIST_ENTRY
+ *  NextListEntry(
+ *      PLIST_ENTRY Entry
+ *      );
+ */
+#define	NEXT_LIST_ENTRY			NextListEntry
+
+#define NextListEntry(Entry) \
+    (Entry)->Flink
+
+
+/*
+ *  PLIST_ENTRY
+ *  PrevListEntry(
+ *      PLIST_ENTRY Entry
+ *      );
+ */
+#define	PREV_LIST_ENTRY			PrevListEntry
+
+#define PrevListEntry(Entry) \
+    (Entry)->Blink
+
+
+/*
+ *  PLIST_ENTRY
+ *  TopListEntry(
+ *      PLIST_ENTRY ListHead
+ *      );
+ */
+#define	TOP_LIST_ENTRY			TopListEntry
+
+#define TopListEntry(ListHead) \
+    (ListHead)->Flink
+
+
+
+/*
+ *  PLIST_ENTRY
+ *  RemoveHeadList(
+ *      PLIST_ENTRY ListHead
+ *      );
+ */
+
+#define	REMOVE_HEAD_LIST		RemoveHeadList
+
+#define RemoveHeadList(ListHead) \
+    (ListHead)->Flink;\
+    {RemoveEntryList((ListHead)->Flink)}
+
+
+/*
+ *  PLIST_ENTRY
+ *  RemoveTailList(
+ *      PLIST_ENTRY ListHead
+ *      );
+ */
+#define	REMOVE_TAIL_LIST		RemoveTailList
+
+#define RemoveTailList(ListHead) \
+    (ListHead)->Blink;\
+    {RemoveEntryList((ListHead)->Blink)}
+
+
+/*
+ *  VOID
+ *  RemoveEntryList(
+ *      PLIST_ENTRY Entry
+ *      );
+ */
+#define	REMOVE_ENTRY_LIST		RemoveEntryList
+
+#define RemoveEntryList(Entry) {\
+    PLIST_ENTRY _EX_Flink = (Entry)->Flink;\
+    PLIST_ENTRY _EX_Blink = (Entry)->Blink;\
+    _EX_Blink->Flink = _EX_Flink;\
+    _EX_Flink->Blink = _EX_Blink;\
+	}
+
+
+/*
+ *  VOID
+ *  AttachList(
+ *      PLIST_ENTRY ListHead,
+ *      PLIST_ENTRY ListEntry
+ *      );
+ */
+#define	ATTACH_LIST		AttachList
+
+#define AttachList(ListHead,ListEntry) {\
+    PLIST_ENTRY _EX_ListHead = (ListHead);\
+    PLIST_ENTRY _EX_Blink = (ListHead)->Blink;\
+    (ListEntry)->Blink->Flink = _EX_ListHead;\
+    _EX_Blink->Flink = (ListEntry);\
+    _EX_ListHead->Blink = (ListEntry)->Blink;\
+    (ListEntry)->Blink = _EX_Blink;\
+    }
+
+
+
+/*
+ *  VOID
+ *  InsertTailList(
+ *      PLIST_ENTRY ListHead,
+ *      PLIST_ENTRY Entry
+ *      );
+ */
+
+#define	INSERT_TAIL_LIST		InsertTailList
+
+#define InsertTailList(ListHead,Entry) {\
+    PLIST_ENTRY _EX_ListHead = (ListHead);\
+    PLIST_ENTRY _EX_Blink = (ListHead)->Blink;\
+    (Entry)->Flink = _EX_ListHead;\
+    (Entry)->Blink = _EX_Blink;\
+    _EX_Blink->Flink = (Entry);\
+    _EX_ListHead->Blink = (Entry);\
+    }
+
+
+/*
+ *  VOID
+ *  InsertHeadList(
+ *      PLIST_ENTRY ListHead,
+ *      PLIST_ENTRY Entry
+ *      );
+ */
+#define	INSERT_HEAD_LIST		InsertHeadList
+
+#define InsertHeadList(ListHead,Entry) {\
+    PLIST_ENTRY _EX_ListHead = (ListHead);\
+    PLIST_ENTRY _EX_Flink = (ListHead)->Flink;\
+    (Entry)->Flink = _EX_Flink;\
+    (Entry)->Blink = _EX_ListHead;\
+    _EX_Flink->Blink = (Entry);\
+    _EX_ListHead->Flink = (Entry);\
+    }
+
+
+/*
+ *  VOID
+ *  IterateListEntries(
+ *      PLIST_ENTRY anchor,
+ *      PLIST_ENTRY index,
+ *		PLIST_ENTRY listp
+ *      );
+ */
+
+#define	ITERATE_LIST_ENTRIES	IterateListEntries
+
+#define IterateListEntries(anchor, index, listp) \
+	(anchor) = (LIST_ENTRY *)(listp); \
+	for((index) = (anchor)->Flink; (index) != (anchor); (index) = (index)->Flink)
+
+
+
+/*
+ *  PSINGLE_LIST_ENTRY
+ *  PopEntryList(
+ *      PSINGLE_LIST_ENTRY ListHead
+ *      );
+ */
+
+#define	POP_ENTRY_LIST		PopEntryList
+
+#define PopEntryList(ListHead) \
+    (ListHead)->Next;\
+    {\
+        PSINGLE_LIST_ENTRY FirstEntry;\
+        FirstEntry = (ListHead)->Next;\
+        if (FirstEntry != NULL) {     \
+            (ListHead)->Next = FirstEntry->Next;\
+        }                             \
+    }
+
+
+
+/*
+ *  VOID
+ *  PushEntryList(
+ *      PSINGLE_LIST_ENTRY ListHead,
+ *		PSINGLE_LIST_ENTRY Entry
+ *      );
+ */
+
+#define	PUSH_ENTRY_LIST			PushEntryList
+
+#define PushEntryList(ListHead,Entry) \
+    (Entry)->Next = (ListHead)->Next; \
+    (ListHead)->Next = (Entry)
+
+#ifndef CONTAINING_RECORD
+#define CONTAINING_RECORD(address, type, field) ((type *)( \
+                                                  (PCHAR)(address) - \
+                                                  (PCHAR)(&((type *)0)->field)))
+#endif /* CONTAINING_RECORD */
+
+#endif /* _LIST_H_ */
+
+/* EOF */
--- /dev/null
+++ b/drivers/staging/hv/include/nvspprotocol.h
@@ -0,0 +1,306 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+
+#include <VmbusChannelInterface.h>
+
+#define NVSP_INVALID_PROTOCOL_VERSION           ((UINT32)0xFFFFFFFF)
+
+#define NVSP_PROTOCOL_VERSION_1                 2
+#define NVSP_MIN_PROTOCOL_VERSION               NVSP_PROTOCOL_VERSION_1
+#define NVSP_MAX_PROTOCOL_VERSION               NVSP_PROTOCOL_VERSION_1
+
+typedef enum _NVSP_MESSAGE_TYPE
+{
+    NvspMessageTypeNone = 0,
+
+    //
+    // Init Messages
+    //
+    NvspMessageTypeInit                         = 1,
+    NvspMessageTypeInitComplete                 = 2,
+
+    NvspVersionMessageStart                     = 100,
+
+    //
+    // Version 1 Messages
+    //
+    NvspMessage1TypeSendNdisVersion             = NvspVersionMessageStart,
+
+    NvspMessage1TypeSendReceiveBuffer,
+    NvspMessage1TypeSendReceiveBufferComplete,
+    NvspMessage1TypeRevokeReceiveBuffer,
+
+    NvspMessage1TypeSendSendBuffer,
+    NvspMessage1TypeSendSendBufferComplete,
+    NvspMessage1TypeRevokeSendBuffer,
+
+    NvspMessage1TypeSendRNDISPacket,
+    NvspMessage1TypeSendRNDISPacketComplete,
+
+    //
+    // This should be set to the number of messages for the version
+    // with the maximum number of messages.
+    //
+    NvspNumMessagePerVersion                    = 9,
+
+} NVSP_MESSAGE_TYPE, *PNVSP_MESSAGE_TYPE;
+
+typedef enum _NVSP_STATUS
+{
+    NvspStatusNone = 0,
+    NvspStatusSuccess,
+    NvspStatusFailure,
+    NvspStatusProtocolVersionRangeTooNew,
+    NvspStatusProtocolVersionRangeTooOld,
+    NvspStatusInvalidRndisPacket,
+    NvspStatusBusy,
+    NvspStatusMax,
+} NVSP_STATUS, *PNVSP_STATUS;
+
+#pragma pack(push, 1)
+
+typedef struct _NVSP_MESSAGE_HEADER
+{
+    UINT32                                  MessageType;
+} NVSP_MESSAGE_HEADER, *PNVSP_MESSAGE_HEADER;
+
+//
+// Init Messages
+//
+
+//
+// This message is used by the VSC to initialize the channel
+// after the channels has been opened. This message should
+// never include anything other then versioning (i.e. this
+// message will be the same for ever).
+//
+typedef struct _NVSP_MESSAGE_INIT
+{
+    UINT32                                  MinProtocolVersion;
+    UINT32                                  MaxProtocolVersion;
+} NVSP_MESSAGE_INIT, *PNVSP_MESSAGE_INIT;
+
+//
+// This message is used by the VSP to complete the initialization
+// of the channel. This message should never include anything other
+// then versioning (i.e. this message will be the same for ever).
+//
+typedef struct _NVSP_MESSAGE_INIT_COMPLETE
+{
+    UINT32                                  NegotiatedProtocolVersion;
+    UINT32                                  MaximumMdlChainLength;
+    UINT32                                  Status;
+} NVSP_MESSAGE_INIT_COMPLETE, *PNVSP_MESSAGE_INIT_COMPLETE;
+
+typedef union _NVSP_MESSAGE_INIT_UBER
+{
+    NVSP_MESSAGE_INIT                       Init;
+    NVSP_MESSAGE_INIT_COMPLETE              InitComplete;
+} NVSP_MESSAGE_INIT_UBER;
+
+//
+// Version 1 Messages
+//
+
+//
+// This message is used by the VSC to send the NDIS version
+// to the VSP. The VSP can use this information when handling
+// OIDs sent by the VSC.
+//
+typedef struct _NVSP_1_MESSAGE_SEND_NDIS_VERSION
+{
+    UINT32                                  NdisMajorVersion;
+    UINT32                                  NdisMinorVersion;
+} NVSP_1_MESSAGE_SEND_NDIS_VERSION, *PNVSP_1_MESSAGE_SEND_NDIS_VERSION;
+
+//
+// This message is used by the VSC to send a receive buffer
+// to the VSP. The VSP can then use the receive buffer to
+// send data to the VSC.
+//
+typedef struct _NVSP_1_MESSAGE_SEND_RECEIVE_BUFFER
+{
+    GPADL_HANDLE                            GpadlHandle;
+    UINT16                                  Id;
+} NVSP_1_MESSAGE_SEND_RECEIVE_BUFFER, *PNVSP_1_MESSAGE_SEND_RECEIVE_BUFFER;
+
+typedef struct _NVSP_1_RECEIVE_BUFFER_SECTION
+{
+    UINT32                                  Offset;
+    UINT32                                  SubAllocationSize;
+    UINT32                                  NumSubAllocations;
+    UINT32                                  EndOffset;
+} NVSP_1_RECEIVE_BUFFER_SECTION, *PNVSP_1_RECEIVE_BUFFER_SECTION;
+
+//
+// This message is used by the VSP to acknowledge a receive
+// buffer send by the VSC. This message must be sent by the
+// VSP before the VSP uses the receive buffer.
+//
+typedef struct _NVSP_1_MESSAGE_SEND_RECEIVE_BUFFER_COMPLETE
+{
+    UINT32                                  Status;
+    UINT32                                  NumSections;
+
+    //
+    // The receive buffer is split into two parts, a large
+    // suballocation section and a small suballocation
+    // section. These sections are then suballocated by a
+    // certain size.
+    //
+    // For example, the following break up of the receive
+    // buffer has 6 large suballocations and 10 small
+    // suballocations.
+    //
+    // |            Large Section          |  |   Small Section   |
+    // ------------------------------------------------------------
+    // |     |     |     |     |     |     |  | | | | | | | | | | |
+    // |                                      |
+    // LargeOffset                            SmallOffset
+    //
+    NVSP_1_RECEIVE_BUFFER_SECTION           Sections[1];
+
+} NVSP_1_MESSAGE_SEND_RECEIVE_BUFFER_COMPLETE, *PNVSP_1_MESSAGE_SEND_RECEIVE_BUFFER_COMPLETE;
+
+//
+// This message is sent by the VSC to revoke the receive buffer.
+// After the VSP completes this transaction, the vsp should never
+// use the receive buffer again.
+//
+typedef struct _NVSP_1_MESSAGE_REVOKE_RECEIVE_BUFFER
+{
+    UINT16                                  Id;
+} NVSP_1_MESSAGE_REVOKE_RECEIVE_BUFFER, *PNVSP_1_MESSAGE_REVOKE_RECEIVE_BUFFER;
+
+//
+// This message is used by the VSC to send a send buffer
+// to the VSP. The VSC can then use the send buffer to
+// send data to the VSP.
+//
+typedef struct _NVSP_1_MESSAGE_SEND_SEND_BUFFER
+{
+    GPADL_HANDLE                            GpadlHandle;
+    UINT16                                  Id;
+} NVSP_1_MESSAGE_SEND_SEND_BUFFER, *PNVSP_1_MESSAGE_SEND_SEND_BUFFER;
+
+//
+// This message is used by the VSP to acknowledge a send
+// buffer sent by the VSC. This message must be sent by the
+// VSP before the VSP uses the sent buffer.
+//
+typedef struct _NVSP_1_MESSAGE_SEND_SEND_BUFFER_COMPLETE
+{
+    UINT32                                  Status;
+
+    //
+    // The VSC gets to choose the size of the send buffer and
+    // the VSP gets to choose the sections size of the buffer.
+    // This was done to enable dynamic reconfigurations when
+    // the cost of GPA-direct buffers decreases.
+    //
+    UINT32                                  SectionSize;
+} NVSP_1_MESSAGE_SEND_SEND_BUFFER_COMPLETE, *PNVSP_1_MESSAGE_SEND_SEND_BUFFER_COMPLETE;
+
+//
+// This message is sent by the VSC to revoke the send buffer.
+// After the VSP completes this transaction, the vsp should never
+// use the send buffer again.
+//
+typedef struct _NVSP_1_MESSAGE_REVOKE_SEND_BUFFER
+{
+    UINT16                                  Id;
+} NVSP_1_MESSAGE_REVOKE_SEND_BUFFER, *PNVSP_1_MESSAGE_REVOKE_SEND_BUFFER;
+
+//
+// This message is used by both the VSP and the VSC to send
+// a RNDIS message to the opposite channel endpoint.
+//
+typedef struct _NVSP_1_MESSAGE_SEND_RNDIS_PACKET
+{
+    //
+    // This field is specified by RNIDS. They assume there's
+    // two different channels of communication. However,
+    // the Network VSP only has one. Therefore, the channel
+    // travels with the RNDIS packet.
+    //
+    UINT32                                  ChannelType;
+
+    //
+    // This field is used to send part or all of the data
+    // through a send buffer. This values specifies an
+    // index into the send buffer. If the index is
+    // 0xFFFFFFFF, then the send buffer is not being used
+    // and all of the data was sent through other VMBus
+    // mechanisms.
+    //
+    UINT32                                  SendBufferSectionIndex;
+    UINT32                                  SendBufferSectionSize;
+} NVSP_1_MESSAGE_SEND_RNDIS_PACKET, *PNVSP_1_MESSAGE_SEND_RNDIS_PACKET;
+
+//
+// This message is used by both the VSP and the VSC to complete
+// a RNDIS message to the opposite channel endpoint. At this
+// point, the initiator of this message cannot use any resources
+// associated with the original RNDIS packet.
+//
+typedef struct _NVSP_1_MESSAGE_SEND_RNDIS_PACKET_COMPLETE
+{
+    UINT32                                  Status;
+} NVSP_1_MESSAGE_SEND_RNDIS_PACKET_COMPLETE, *PNVSP_1_MESSAGE_SEND_RNDIS_PACKET_COMPLETE;
+
+typedef union _NVSP_MESSAGE_1_UBER
+{
+    NVSP_1_MESSAGE_SEND_NDIS_VERSION            SendNdisVersion;
+
+    NVSP_1_MESSAGE_SEND_RECEIVE_BUFFER          SendReceiveBuffer;
+    NVSP_1_MESSAGE_SEND_RECEIVE_BUFFER_COMPLETE SendReceiveBufferComplete;
+    NVSP_1_MESSAGE_REVOKE_RECEIVE_BUFFER        RevokeReceiveBuffer;
+
+    NVSP_1_MESSAGE_SEND_SEND_BUFFER             SendSendBuffer;
+    NVSP_1_MESSAGE_SEND_SEND_BUFFER_COMPLETE    SendSendBufferComplete;
+    NVSP_1_MESSAGE_REVOKE_SEND_BUFFER           RevokeSendBuffer;
+
+    NVSP_1_MESSAGE_SEND_RNDIS_PACKET            SendRNDISPacket;
+    NVSP_1_MESSAGE_SEND_RNDIS_PACKET_COMPLETE   SendRNDISPacketComplete;
+} NVSP_1_MESSAGE_UBER;
+
+typedef union _NVSP_ALL_MESSAGES
+{
+    NVSP_MESSAGE_INIT_UBER                  InitMessages;
+    NVSP_1_MESSAGE_UBER                     Version1Messages;
+
+} NVSP_ALL_MESSAGES;
+
+//
+// ALL Messages
+//
+typedef struct _NVSP_MESSAGE
+{
+    NVSP_MESSAGE_HEADER                     Header;
+    NVSP_ALL_MESSAGES                       Messages;
+} NVSP_MESSAGE, *PNVSP_MESSAGE;
+
+#pragma pack(pop)
--- /dev/null
+++ b/drivers/staging/hv/include/rndis.h
@@ -0,0 +1,836 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#ifndef _RNDIS_H_
+#define _RNDIS_H_
+
+//
+//  Basic types
+//
+typedef UINT32                                  RNDIS_REQUEST_ID;
+typedef UINT32                                  RNDIS_HANDLE;
+typedef UINT32                                  RNDIS_STATUS;
+typedef UINT32                                  RNDIS_REQUEST_TYPE;
+typedef UINT32                                  RNDIS_OID;
+typedef UINT32                                  RNDIS_CLASS_ID;
+typedef UINT32                                  RNDIS_MEDIUM;
+typedef UINT32                                  *PRNDIS_REQUEST_ID;
+typedef UINT32                                  *PRNDIS_HANDLE;
+typedef UINT32                                  *PRNDIS_STATUS;
+typedef UINT32                                  *PRNDIS_REQUEST_TYPE;
+typedef UINT32                                  *PRNDIS_OID;
+typedef UINT32                                  *PRNDIS_CLASS_ID;
+typedef UINT32                                  *PRNDIS_MEDIUM;
+typedef UINT32                                  RNDIS_AF;
+
+//
+//  Status codes
+//
+
+#ifndef STATUS_SUCCESS
+#define STATUS_SUCCESS                          (0x00000000L)
+#endif
+
+#ifndef STATUS_UNSUCCESSFUL
+#define STATUS_UNSUCCESSFUL                     (0xC0000001L)
+#endif
+
+#ifndef STATUS_PENDING
+#define STATUS_PENDING                          (0x00000103L)
+#endif
+
+#ifndef STATUS_INSUFFICIENT_RESOURCES
+#define STATUS_INSUFFICIENT_RESOURCES           (0xC000009AL)
+#endif
+
+#ifndef STATUS_BUFFER_OVERFLOW
+#define STATUS_BUFFER_OVERFLOW                  (0x80000005L)
+#endif
+
+#ifndef STATUS_NOT_SUPPORTED
+#define STATUS_NOT_SUPPORTED                    (0xC00000BBL)
+#endif
+
+#define RNDIS_STATUS_SUCCESS                    ((RNDIS_STATUS)STATUS_SUCCESS)
+#define RNDIS_STATUS_PENDING                    ((RNDIS_STATUS)STATUS_PENDING)
+#define RNDIS_STATUS_NOT_RECOGNIZED             ((RNDIS_STATUS)0x00010001L)
+#define RNDIS_STATUS_NOT_COPIED                 ((RNDIS_STATUS)0x00010002L)
+#define RNDIS_STATUS_NOT_ACCEPTED               ((RNDIS_STATUS)0x00010003L)
+#define RNDIS_STATUS_CALL_ACTIVE                ((RNDIS_STATUS)0x00010007L)
+
+#define RNDIS_STATUS_ONLINE                     ((RNDIS_STATUS)0x40010003L)
+#define RNDIS_STATUS_RESET_START                ((RNDIS_STATUS)0x40010004L)
+#define RNDIS_STATUS_RESET_END                  ((RNDIS_STATUS)0x40010005L)
+#define RNDIS_STATUS_RING_STATUS                ((RNDIS_STATUS)0x40010006L)
+#define RNDIS_STATUS_CLOSED                     ((RNDIS_STATUS)0x40010007L)
+#define RNDIS_STATUS_WAN_LINE_UP                ((RNDIS_STATUS)0x40010008L)
+#define RNDIS_STATUS_WAN_LINE_DOWN              ((RNDIS_STATUS)0x40010009L)
+#define RNDIS_STATUS_WAN_FRAGMENT               ((RNDIS_STATUS)0x4001000AL)
+#define RNDIS_STATUS_MEDIA_CONNECT              ((RNDIS_STATUS)0x4001000BL)
+#define RNDIS_STATUS_MEDIA_DISCONNECT           ((RNDIS_STATUS)0x4001000CL)
+#define RNDIS_STATUS_HARDWARE_LINE_UP           ((RNDIS_STATUS)0x4001000DL)
+#define RNDIS_STATUS_HARDWARE_LINE_DOWN         ((RNDIS_STATUS)0x4001000EL)
+#define RNDIS_STATUS_INTERFACE_UP               ((RNDIS_STATUS)0x4001000FL)
+#define RNDIS_STATUS_INTERFACE_DOWN             ((RNDIS_STATUS)0x40010010L)
+#define RNDIS_STATUS_MEDIA_BUSY                 ((RNDIS_STATUS)0x40010011L)
+#define RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION  ((RNDIS_STATUS)0x40010012L)
+#define RNDIS_STATUS_WW_INDICATION              RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION
+#define RNDIS_STATUS_LINK_SPEED_CHANGE          ((RNDIS_STATUS)0x40010013L)
+
+#define RNDIS_STATUS_NOT_RESETTABLE             ((RNDIS_STATUS)0x80010001L)
+#define RNDIS_STATUS_SOFT_ERRORS                ((RNDIS_STATUS)0x80010003L)
+#define RNDIS_STATUS_HARD_ERRORS                ((RNDIS_STATUS)0x80010004L)
+#define RNDIS_STATUS_BUFFER_OVERFLOW            ((RNDIS_STATUS)STATUS_BUFFER_OVERFLOW)
+
+#define RNDIS_STATUS_FAILURE                    ((RNDIS_STATUS)STATUS_UNSUCCESSFUL)
+#define RNDIS_STATUS_RESOURCES                  ((RNDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
+#define RNDIS_STATUS_CLOSING                    ((RNDIS_STATUS)0xC0010002L)
+#define RNDIS_STATUS_BAD_VERSION                ((RNDIS_STATUS)0xC0010004L)
+#define RNDIS_STATUS_BAD_CHARACTERISTICS        ((RNDIS_STATUS)0xC0010005L)
+#define RNDIS_STATUS_ADAPTER_NOT_FOUND          ((RNDIS_STATUS)0xC0010006L)
+#define RNDIS_STATUS_OPEN_FAILED                ((RNDIS_STATUS)0xC0010007L)
+#define RNDIS_STATUS_DEVICE_FAILED              ((RNDIS_STATUS)0xC0010008L)
+#define RNDIS_STATUS_MULTICAST_FULL             ((RNDIS_STATUS)0xC0010009L)
+#define RNDIS_STATUS_MULTICAST_EXISTS           ((RNDIS_STATUS)0xC001000AL)
+#define RNDIS_STATUS_MULTICAST_NOT_FOUND        ((RNDIS_STATUS)0xC001000BL)
+#define RNDIS_STATUS_REQUEST_ABORTED            ((RNDIS_STATUS)0xC001000CL)
+#define RNDIS_STATUS_RESET_IN_PROGRESS          ((RNDIS_STATUS)0xC001000DL)
+#define RNDIS_STATUS_CLOSING_INDICATING         ((RNDIS_STATUS)0xC001000EL)
+#define RNDIS_STATUS_NOT_SUPPORTED              ((RNDIS_STATUS)STATUS_NOT_SUPPORTED)
+#define RNDIS_STATUS_INVALID_PACKET             ((RNDIS_STATUS)0xC001000FL)
+#define RNDIS_STATUS_OPEN_LIST_FULL             ((RNDIS_STATUS)0xC0010010L)
+#define RNDIS_STATUS_ADAPTER_NOT_READY          ((RNDIS_STATUS)0xC0010011L)
+#define RNDIS_STATUS_ADAPTER_NOT_OPEN           ((RNDIS_STATUS)0xC0010012L)
+#define RNDIS_STATUS_NOT_INDICATING             ((RNDIS_STATUS)0xC0010013L)
+#define RNDIS_STATUS_INVALID_LENGTH             ((RNDIS_STATUS)0xC0010014L)
+#define RNDIS_STATUS_INVALID_DATA               ((RNDIS_STATUS)0xC0010015L)
+#define RNDIS_STATUS_BUFFER_TOO_SHORT           ((RNDIS_STATUS)0xC0010016L)
+#define RNDIS_STATUS_INVALID_OID                ((RNDIS_STATUS)0xC0010017L)
+#define RNDIS_STATUS_ADAPTER_REMOVED            ((RNDIS_STATUS)0xC0010018L)
+#define RNDIS_STATUS_UNSUPPORTED_MEDIA          ((RNDIS_STATUS)0xC0010019L)
+#define RNDIS_STATUS_GROUP_ADDRESS_IN_USE       ((RNDIS_STATUS)0xC001001AL)
+#define RNDIS_STATUS_FILE_NOT_FOUND             ((RNDIS_STATUS)0xC001001BL)
+#define RNDIS_STATUS_ERROR_READING_FILE         ((RNDIS_STATUS)0xC001001CL)
+#define RNDIS_STATUS_ALREADY_MAPPED             ((RNDIS_STATUS)0xC001001DL)
+#define RNDIS_STATUS_RESOURCE_CONFLICT          ((RNDIS_STATUS)0xC001001EL)
+#define RNDIS_STATUS_NO_CABLE                   ((RNDIS_STATUS)0xC001001FL)
+
+#define RNDIS_STATUS_INVALID_SAP                ((RNDIS_STATUS)0xC0010020L)
+#define RNDIS_STATUS_SAP_IN_USE                 ((RNDIS_STATUS)0xC0010021L)
+#define RNDIS_STATUS_INVALID_ADDRESS            ((RNDIS_STATUS)0xC0010022L)
+#define RNDIS_STATUS_VC_NOT_ACTIVATED           ((RNDIS_STATUS)0xC0010023L)
+#define RNDIS_STATUS_DEST_OUT_OF_ORDER          ((RNDIS_STATUS)0xC0010024L)
+#define RNDIS_STATUS_VC_NOT_AVAILABLE           ((RNDIS_STATUS)0xC0010025L)
+#define RNDIS_STATUS_CELLRATE_NOT_AVAILABLE     ((RNDIS_STATUS)0xC0010026L)
+#define RNDIS_STATUS_INCOMPATABLE_QOS           ((RNDIS_STATUS)0xC0010027L)
+#define RNDIS_STATUS_AAL_PARAMS_UNSUPPORTED     ((RNDIS_STATUS)0xC0010028L)
+#define RNDIS_STATUS_NO_ROUTE_TO_DESTINATION    ((RNDIS_STATUS)0xC0010029L)
+
+#define RNDIS_STATUS_TOKEN_RING_OPEN_ERROR      ((RNDIS_STATUS)0xC0011000L)
+
+
+//
+// Object Identifiers used by NdisRequest Query/Set Information
+//
+
+//
+// General Objects
+//
+
+#define RNDIS_OID_GEN_SUPPORTED_LIST                    0x00010101
+#define RNDIS_OID_GEN_HARDWARE_STATUS                   0x00010102
+#define RNDIS_OID_GEN_MEDIA_SUPPORTED                   0x00010103
+#define RNDIS_OID_GEN_MEDIA_IN_USE                      0x00010104
+#define RNDIS_OID_GEN_MAXIMUM_LOOKAHEAD                 0x00010105
+#define RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE                0x00010106
+#define RNDIS_OID_GEN_LINK_SPEED                        0x00010107
+#define RNDIS_OID_GEN_TRANSMIT_BUFFER_SPACE             0x00010108
+#define RNDIS_OID_GEN_RECEIVE_BUFFER_SPACE              0x00010109
+#define RNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE               0x0001010A
+#define RNDIS_OID_GEN_RECEIVE_BLOCK_SIZE                0x0001010B
+#define RNDIS_OID_GEN_VENDOR_ID                         0x0001010C
+#define RNDIS_OID_GEN_VENDOR_DESCRIPTION                0x0001010D
+#define RNDIS_OID_GEN_CURRENT_PACKET_FILTER             0x0001010E
+#define RNDIS_OID_GEN_CURRENT_LOOKAHEAD                 0x0001010F
+#define RNDIS_OID_GEN_DRIVER_VERSION                    0x00010110
+#define RNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE                0x00010111
+#define RNDIS_OID_GEN_PROTOCOL_OPTIONS                  0x00010112
+#define RNDIS_OID_GEN_MAC_OPTIONS                       0x00010113
+#define RNDIS_OID_GEN_MEDIA_CONNECT_STATUS              0x00010114
+#define RNDIS_OID_GEN_MAXIMUM_SEND_PACKETS              0x00010115
+#define RNDIS_OID_GEN_VENDOR_DRIVER_VERSION             0x00010116
+#define RNDIS_OID_GEN_NETWORK_LAYER_ADDRESSES           0x00010118
+#define RNDIS_OID_GEN_TRANSPORT_HEADER_OFFSET           0x00010119
+#define RNDIS_OID_GEN_MACHINE_NAME                      0x0001021A
+#define RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER            0x0001021B
+
+#define RNDIS_OID_GEN_XMIT_OK                           0x00020101
+#define RNDIS_OID_GEN_RCV_OK                            0x00020102
+#define RNDIS_OID_GEN_XMIT_ERROR                        0x00020103
+#define RNDIS_OID_GEN_RCV_ERROR                         0x00020104
+#define RNDIS_OID_GEN_RCV_NO_BUFFER                     0x00020105
+
+#define RNDIS_OID_GEN_DIRECTED_BYTES_XMIT               0x00020201
+#define RNDIS_OID_GEN_DIRECTED_FRAMES_XMIT              0x00020202
+#define RNDIS_OID_GEN_MULTICAST_BYTES_XMIT              0x00020203
+#define RNDIS_OID_GEN_MULTICAST_FRAMES_XMIT             0x00020204
+#define RNDIS_OID_GEN_BROADCAST_BYTES_XMIT              0x00020205
+#define RNDIS_OID_GEN_BROADCAST_FRAMES_XMIT             0x00020206
+#define RNDIS_OID_GEN_DIRECTED_BYTES_RCV                0x00020207
+#define RNDIS_OID_GEN_DIRECTED_FRAMES_RCV               0x00020208
+#define RNDIS_OID_GEN_MULTICAST_BYTES_RCV               0x00020209
+#define RNDIS_OID_GEN_MULTICAST_FRAMES_RCV              0x0002020A
+#define RNDIS_OID_GEN_BROADCAST_BYTES_RCV               0x0002020B
+#define RNDIS_OID_GEN_BROADCAST_FRAMES_RCV              0x0002020C
+
+#define RNDIS_OID_GEN_RCV_CRC_ERROR                     0x0002020D
+#define RNDIS_OID_GEN_TRANSMIT_QUEUE_LENGTH             0x0002020E
+
+#define RNDIS_OID_GEN_GET_TIME_CAPS                     0x0002020F
+#define RNDIS_OID_GEN_GET_NETCARD_TIME                  0x00020210
+
+//
+// These are connection-oriented general OIDs.
+// These replace the above OIDs for connection-oriented media.
+//
+#define RNDIS_OID_GEN_CO_SUPPORTED_LIST                 0x00010101
+#define RNDIS_OID_GEN_CO_HARDWARE_STATUS                0x00010102
+#define RNDIS_OID_GEN_CO_MEDIA_SUPPORTED                0x00010103
+#define RNDIS_OID_GEN_CO_MEDIA_IN_USE                   0x00010104
+#define RNDIS_OID_GEN_CO_LINK_SPEED                     0x00010105
+#define RNDIS_OID_GEN_CO_VENDOR_ID                      0x00010106
+#define RNDIS_OID_GEN_CO_VENDOR_DESCRIPTION             0x00010107
+#define RNDIS_OID_GEN_CO_DRIVER_VERSION                 0x00010108
+#define RNDIS_OID_GEN_CO_PROTOCOL_OPTIONS               0x00010109
+#define RNDIS_OID_GEN_CO_MAC_OPTIONS                    0x0001010A
+#define RNDIS_OID_GEN_CO_MEDIA_CONNECT_STATUS           0x0001010B
+#define RNDIS_OID_GEN_CO_VENDOR_DRIVER_VERSION          0x0001010C
+#define RNDIS_OID_GEN_CO_MINIMUM_LINK_SPEED             0x0001010D
+
+#define RNDIS_OID_GEN_CO_GET_TIME_CAPS                  0x00010201
+#define RNDIS_OID_GEN_CO_GET_NETCARD_TIME               0x00010202
+
+//
+// These are connection-oriented statistics OIDs.
+//
+#define RNDIS_OID_GEN_CO_XMIT_PDUS_OK                   0x00020101
+#define RNDIS_OID_GEN_CO_RCV_PDUS_OK                    0x00020102
+#define RNDIS_OID_GEN_CO_XMIT_PDUS_ERROR                0x00020103
+#define RNDIS_OID_GEN_CO_RCV_PDUS_ERROR                 0x00020104
+#define RNDIS_OID_GEN_CO_RCV_PDUS_NO_BUFFER             0x00020105
+
+
+#define RNDIS_OID_GEN_CO_RCV_CRC_ERROR                  0x00020201
+#define RNDIS_OID_GEN_CO_TRANSMIT_QUEUE_LENGTH          0x00020202
+#define RNDIS_OID_GEN_CO_BYTES_XMIT                     0x00020203
+#define RNDIS_OID_GEN_CO_BYTES_RCV                      0x00020204
+#define RNDIS_OID_GEN_CO_BYTES_XMIT_OUTSTANDING         0x00020205
+#define RNDIS_OID_GEN_CO_NETCARD_LOAD                   0x00020206
+
+//
+// These are objects for Connection-oriented media call-managers.
+//
+#define RNDIS_OID_CO_ADD_PVC                            0xFF000001
+#define RNDIS_OID_CO_DELETE_PVC                         0xFF000002
+#define RNDIS_OID_CO_GET_CALL_INFORMATION               0xFF000003
+#define RNDIS_OID_CO_ADD_ADDRESS                        0xFF000004
+#define RNDIS_OID_CO_DELETE_ADDRESS                     0xFF000005
+#define RNDIS_OID_CO_GET_ADDRESSES                      0xFF000006
+#define RNDIS_OID_CO_ADDRESS_CHANGE                     0xFF000007
+#define RNDIS_OID_CO_SIGNALING_ENABLED                  0xFF000008
+#define RNDIS_OID_CO_SIGNALING_DISABLED                 0xFF000009
+
+
+//
+// 802.3 Objects (Ethernet)
+//
+
+#define RNDIS_OID_802_3_PERMANENT_ADDRESS               0x01010101
+#define RNDIS_OID_802_3_CURRENT_ADDRESS                 0x01010102
+#define RNDIS_OID_802_3_MULTICAST_LIST                  0x01010103
+#define RNDIS_OID_802_3_MAXIMUM_LIST_SIZE               0x01010104
+#define RNDIS_OID_802_3_MAC_OPTIONS                     0x01010105
+
+//
+//
+#define NDIS_802_3_MAC_OPTION_PRIORITY                  0x00000001
+
+#define RNDIS_OID_802_3_RCV_ERROR_ALIGNMENT             0x01020101
+#define RNDIS_OID_802_3_XMIT_ONE_COLLISION              0x01020102
+#define RNDIS_OID_802_3_XMIT_MORE_COLLISIONS            0x01020103
+
+#define RNDIS_OID_802_3_XMIT_DEFERRED                   0x01020201
+#define RNDIS_OID_802_3_XMIT_MAX_COLLISIONS             0x01020202
+#define RNDIS_OID_802_3_RCV_OVERRUN                     0x01020203
+#define RNDIS_OID_802_3_XMIT_UNDERRUN                   0x01020204
+#define RNDIS_OID_802_3_XMIT_HEARTBEAT_FAILURE          0x01020205
+#define RNDIS_OID_802_3_XMIT_TIMES_CRS_LOST             0x01020206
+#define RNDIS_OID_802_3_XMIT_LATE_COLLISIONS            0x01020207
+
+
+//
+// Remote NDIS message types
+//
+#define REMOTE_NDIS_PACKET_MSG                  0x00000001
+#define REMOTE_NDIS_INITIALIZE_MSG              0x00000002
+#define REMOTE_NDIS_HALT_MSG                    0x00000003
+#define REMOTE_NDIS_QUERY_MSG                   0x00000004
+#define REMOTE_NDIS_SET_MSG                     0x00000005
+#define REMOTE_NDIS_RESET_MSG                   0x00000006
+#define REMOTE_NDIS_INDICATE_STATUS_MSG         0x00000007
+#define REMOTE_NDIS_KEEPALIVE_MSG               0x00000008
+
+#define REMOTE_CONDIS_MP_CREATE_VC_MSG          0x00008001
+#define REMOTE_CONDIS_MP_DELETE_VC_MSG          0x00008002
+#define REMOTE_CONDIS_MP_ACTIVATE_VC_MSG        0x00008005
+#define REMOTE_CONDIS_MP_DEACTIVATE_VC_MSG      0x00008006
+#define REMOTE_CONDIS_INDICATE_STATUS_MSG       0x00008007
+
+
+// Remote NDIS message completion types
+#define REMOTE_NDIS_INITIALIZE_CMPLT            0x80000002
+#define REMOTE_NDIS_QUERY_CMPLT                 0x80000004
+#define REMOTE_NDIS_SET_CMPLT                   0x80000005
+#define REMOTE_NDIS_RESET_CMPLT                 0x80000006
+#define REMOTE_NDIS_KEEPALIVE_CMPLT             0x80000008
+
+#define REMOTE_CONDIS_MP_CREATE_VC_CMPLT        0x80008001
+#define REMOTE_CONDIS_MP_DELETE_VC_CMPLT        0x80008002
+#define REMOTE_CONDIS_MP_ACTIVATE_VC_CMPLT      0x80008005
+#define REMOTE_CONDIS_MP_DEACTIVATE_VC_CMPLT    0x80008006
+
+//
+// Reserved message type for private communication between lower-layer
+// host driver and remote device, if necessary.
+//
+#define REMOTE_NDIS_BUS_MSG                     0xff000001
+
+
+
+//
+//  Defines for DeviceFlags in RNDIS_INITIALIZE_COMPLETE
+//
+#define RNDIS_DF_CONNECTIONLESS             0x00000001
+#define RNDIS_DF_CONNECTION_ORIENTED        0x00000002
+#define RNDIS_DF_RAW_DATA                   0x00000004
+
+//
+//  Remote NDIS medium types.
+//
+#define RNdisMedium802_3                    0x00000000
+#define RNdisMedium802_5                    0x00000001
+#define RNdisMediumFddi                     0x00000002
+#define RNdisMediumWan                      0x00000003
+#define RNdisMediumLocalTalk                0x00000004
+#define RNdisMediumArcnetRaw                0x00000006
+#define RNdisMediumArcnet878_2              0x00000007
+#define RNdisMediumAtm                      0x00000008
+#define RNdisMediumWirelessWan              0x00000009
+#define RNdisMediumIrda                     0x0000000a
+#define RNdisMediumCoWan                    0x0000000b
+#define RNdisMediumMax                      0x0000000d     // Not a real medium, defined as an upper-bound
+
+//
+// Remote NDIS medium connection states.
+//
+#define RNdisMediaStateConnected            0x00000000
+#define RNdisMediaStateDisconnected         0x00000001
+
+//
+//  Remote NDIS version numbers
+//
+#define RNDIS_MAJOR_VERSION                 0x00000001
+#define RNDIS_MINOR_VERSION                 0x00000000
+
+//
+//  NdisInitialize message
+//
+typedef struct _RNDIS_INITIALIZE_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    UINT32                                  MajorVersion;
+    UINT32                                  MinorVersion;
+    UINT32                                  MaxTransferSize;
+} RNDIS_INITIALIZE_REQUEST, *PRNDIS_INITIALIZE_REQUEST;
+
+
+//
+//  Response to NdisInitialize
+//
+typedef struct _RNDIS_INITIALIZE_COMPLETE
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_STATUS                            Status;
+    UINT32                                  MajorVersion;
+    UINT32                                  MinorVersion;
+    UINT32                                  DeviceFlags;
+    RNDIS_MEDIUM                            Medium;
+    UINT32                                  MaxPacketsPerMessage;
+    UINT32                                  MaxTransferSize;
+    UINT32                                  PacketAlignmentFactor;
+    UINT32                                  AFListOffset;
+    UINT32                                  AFListSize;
+} RNDIS_INITIALIZE_COMPLETE, *PRNDIS_INITIALIZE_COMPLETE;
+
+
+//
+//  Call manager devices only: Information about an address family
+//  supported by the device is appended to the response to NdisInitialize.
+//
+typedef struct _RNDIS_CO_ADDRESS_FAMILY
+{
+    RNDIS_AF                                AddressFamily;
+    UINT32                                  MajorVersion;
+    UINT32                                  MinorVersion;
+} RNDIS_CO_ADDRESS_FAMILY, *PRNDIS_CO_ADDRESS_FAMILY;
+
+
+//
+//  NdisHalt message
+//
+typedef struct _RNDIS_HALT_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+} RNDIS_HALT_REQUEST, *PRNDIS_HALT_REQUEST;
+
+
+//
+// NdisQueryRequest message
+//
+typedef struct _RNDIS_QUERY_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_OID                               Oid;
+    UINT32                                  InformationBufferLength;
+    UINT32                                  InformationBufferOffset;
+    RNDIS_HANDLE                            DeviceVcHandle;
+} RNDIS_QUERY_REQUEST, *PRNDIS_QUERY_REQUEST;
+
+
+//
+//  Response to NdisQueryRequest
+//
+typedef struct _RNDIS_QUERY_COMPLETE
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_STATUS                            Status;
+    UINT32                                  InformationBufferLength;
+    UINT32                                  InformationBufferOffset;
+} RNDIS_QUERY_COMPLETE, *PRNDIS_QUERY_COMPLETE;
+
+
+//
+//  NdisSetRequest message
+//
+typedef struct _RNDIS_SET_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_OID                               Oid;
+    UINT32                                  InformationBufferLength;
+    UINT32                                  InformationBufferOffset;
+    RNDIS_HANDLE                            DeviceVcHandle;
+} RNDIS_SET_REQUEST, *PRNDIS_SET_REQUEST;
+
+
+//
+//  Response to NdisSetRequest
+//
+typedef struct _RNDIS_SET_COMPLETE
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_STATUS                            Status;
+} RNDIS_SET_COMPLETE, *PRNDIS_SET_COMPLETE;
+
+
+//
+//  NdisReset message
+//
+typedef struct _RNDIS_RESET_REQUEST
+{
+    UINT32                                  Reserved;
+} RNDIS_RESET_REQUEST, *PRNDIS_RESET_REQUEST;
+
+//
+//  Response to NdisReset
+//
+typedef struct _RNDIS_RESET_COMPLETE
+{
+    RNDIS_STATUS                            Status;
+    UINT32                                  AddressingReset;
+} RNDIS_RESET_COMPLETE, *PRNDIS_RESET_COMPLETE;
+
+
+//
+//  NdisMIndicateStatus message
+//
+typedef struct _RNDIS_INDICATE_STATUS
+{
+    RNDIS_STATUS                            Status;
+    UINT32                                  StatusBufferLength;
+    UINT32                                  StatusBufferOffset;
+} RNDIS_INDICATE_STATUS, *PRNDIS_INDICATE_STATUS;
+
+
+//
+//  Diagnostic information passed as the status buffer in
+//  RNDIS_INDICATE_STATUS messages signifying error conditions.
+//
+typedef struct _RNDIS_DIAGNOSTIC_INFO
+{
+    RNDIS_STATUS                            DiagStatus;
+    UINT32                                  ErrorOffset;
+} RNDIS_DIAGNOSTIC_INFO, *PRNDIS_DIAGNOSTIC_INFO;
+
+
+
+//
+//  NdisKeepAlive message
+//
+typedef struct _RNDIS_KEEPALIVE_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+} RNDIS_KEEPALIVE_REQUEST, *PRNDIS_KEEPALIVE_REQUEST;
+
+
+//
+// Response to NdisKeepAlive
+//
+typedef struct _RNDIS_KEEPALIVE_COMPLETE
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_STATUS                            Status;
+} RNDIS_KEEPALIVE_COMPLETE, *PRNDIS_KEEPALIVE_COMPLETE;
+
+
+//
+//  Data message. All Offset fields contain byte offsets from the beginning
+//  of the RNDIS_PACKET structure. All Length fields are in bytes.
+//  VcHandle is set to 0 for connectionless data, otherwise it
+//  contains the VC handle.
+//
+typedef struct _RNDIS_PACKET
+{
+    UINT32                                  DataOffset;
+    UINT32                                  DataLength;
+    UINT32                                  OOBDataOffset;
+    UINT32                                  OOBDataLength;
+    UINT32                                  NumOOBDataElements;
+    UINT32                                  PerPacketInfoOffset;
+    UINT32                                  PerPacketInfoLength;
+    RNDIS_HANDLE                            VcHandle;
+    UINT32                                  Reserved;
+} RNDIS_PACKET, *PRNDIS_PACKET;
+
+//
+//  Optional Out of Band data associated with a Data message.
+//
+typedef struct _RNDIS_OOBD
+{
+    UINT32                                  Size;
+    RNDIS_CLASS_ID                          Type;
+    UINT32                                  ClassInformationOffset;
+} RNDIS_OOBD, *PRNDIS_OOBD;
+
+//
+//  Packet extension field contents associated with a Data message.
+//
+typedef struct _RNDIS_PER_PACKET_INFO
+{
+    UINT32                                  Size;
+    UINT32                                  Type;
+    UINT32                                  PerPacketInformationOffset;
+} RNDIS_PER_PACKET_INFO, *PRNDIS_PER_PACKET_INFO;
+
+
+//
+//  Format of Information buffer passed in a SetRequest for the OID
+//  OID_GEN_RNDIS_CONFIG_PARAMETER.
+//
+typedef struct _RNDIS_CONFIG_PARAMETER_INFO
+{
+    UINT32                                  ParameterNameOffset;
+    UINT32                                  ParameterNameLength;
+    UINT32                                  ParameterType;
+    UINT32                                  ParameterValueOffset;
+    UINT32                                  ParameterValueLength;
+} RNDIS_CONFIG_PARAMETER_INFO, *PRNDIS_CONFIG_PARAMETER_INFO;
+
+//
+//  Values for ParameterType in RNDIS_CONFIG_PARAMETER_INFO
+//
+#define RNDIS_CONFIG_PARAM_TYPE_INTEGER     0
+#define RNDIS_CONFIG_PARAM_TYPE_STRING      2
+
+
+//
+//  CONDIS Miniport messages for connection oriented devices
+//  that do not implement a call manager.
+//
+
+//
+//  CoNdisMiniportCreateVc message
+//
+typedef struct _RCONDIS_MP_CREATE_VC
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_HANDLE                            NdisVcHandle;
+} RCONDIS_MP_CREATE_VC, *PRCONDIS_MP_CREATE_VC;
+
+//
+//  Response to CoNdisMiniportCreateVc
+//
+typedef struct _RCONDIS_MP_CREATE_VC_COMPLETE
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_HANDLE                            DeviceVcHandle;
+    RNDIS_STATUS                            Status;
+} RCONDIS_MP_CREATE_VC_COMPLETE, *PRCONDIS_MP_CREATE_VC_COMPLETE;
+
+
+//
+//  CoNdisMiniportDeleteVc message
+//
+typedef struct _RCONDIS_MP_DELETE_VC
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_HANDLE                            DeviceVcHandle;
+} RCONDIS_MP_DELETE_VC, *PRCONDIS_MP_DELETE_VC;
+
+//
+//  Response to CoNdisMiniportDeleteVc
+//
+typedef struct _RCONDIS_MP_DELETE_VC_COMPLETE
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_STATUS                            Status;
+} RCONDIS_MP_DELETE_VC_COMPLETE, *PRCONDIS_MP_DELETE_VC_COMPLETE;
+
+
+//
+//  CoNdisMiniportQueryRequest message
+//
+typedef struct _RCONDIS_MP_QUERY_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_REQUEST_TYPE                      RequestType;
+    RNDIS_OID                               Oid;
+    RNDIS_HANDLE                            DeviceVcHandle;
+    UINT32                                  InformationBufferLength;
+    UINT32                                  InformationBufferOffset;
+} RCONDIS_MP_QUERY_REQUEST, *PRCONDIS_MP_QUERY_REQUEST;
+
+
+//
+//  CoNdisMiniportSetRequest message
+//
+typedef struct _RCONDIS_MP_SET_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_REQUEST_TYPE                      RequestType;
+    RNDIS_OID                               Oid;
+    RNDIS_HANDLE                            DeviceVcHandle;
+    UINT32                                  InformationBufferLength;
+    UINT32                                  InformationBufferOffset;
+} RCONDIS_MP_SET_REQUEST, *PRCONDIS_MP_SET_REQUEST;
+
+
+//
+//  CoNdisIndicateStatus message
+//
+typedef struct _RCONDIS_INDICATE_STATUS
+{
+    RNDIS_HANDLE                            NdisVcHandle;
+    RNDIS_STATUS                            Status;
+    UINT32                                  StatusBufferLength;
+    UINT32                                  StatusBufferOffset;
+} RCONDIS_INDICATE_STATUS, *PRCONDIS_INDICATE_STATUS;
+
+
+//
+//  CONDIS Call/VC parameters
+//
+
+typedef struct _RCONDIS_SPECIFIC_PARAMETERS
+{
+    UINT32                                  ParameterType;
+    UINT32                                  ParameterLength;
+    UINT32                                  ParameterOffset;
+} RCONDIS_SPECIFIC_PARAMETERS, *PRCONDIS_SPECIFIC_PARAMETERS;
+
+typedef struct _RCONDIS_MEDIA_PARAMETERS
+{
+    UINT32                                  Flags;
+    UINT32                                  Reserved1;
+    UINT32                                  Reserved2;
+    RCONDIS_SPECIFIC_PARAMETERS             MediaSpecific;
+} RCONDIS_MEDIA_PARAMETERS, *PRCONDIS_MEDIA_PARAMETERS;
+
+
+typedef struct _RNDIS_FLOWSPEC
+{
+    UINT32                                  TokenRate;
+    UINT32                                  TokenBucketSize;
+    UINT32                                  PeakBandwidth;
+    UINT32                                  Latency;
+    UINT32                                  DelayVariation;
+    UINT32                                  ServiceType;
+    UINT32                                  MaxSduSize;
+    UINT32                                  MinimumPolicedSize;
+} RNDIS_FLOWSPEC, *PRNDIS_FLOWSPEC;
+
+typedef struct _RCONDIS_CALL_MANAGER_PARAMETERS
+{
+    RNDIS_FLOWSPEC                          Transmit;
+    RNDIS_FLOWSPEC                          Receive;
+    RCONDIS_SPECIFIC_PARAMETERS             CallMgrSpecific;
+} RCONDIS_CALL_MANAGER_PARAMETERS, *PRCONDIS_CALL_MANAGER_PARAMETERS;
+
+//
+//  CoNdisMiniportActivateVc message
+//
+typedef struct _RCONDIS_MP_ACTIVATE_VC_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    UINT32                                  Flags;
+    RNDIS_HANDLE                            DeviceVcHandle;
+    UINT32                                  MediaParamsOffset;
+    UINT32                                  MediaParamsLength;
+    UINT32                                  CallMgrParamsOffset;
+    UINT32                                  CallMgrParamsLength;
+} RCONDIS_MP_ACTIVATE_VC_REQUEST, *PRCONDIS_MP_ACTIVATE_VC_REQUEST;
+
+//
+//  Response to CoNdisMiniportActivateVc
+//
+typedef struct _RCONDIS_MP_ACTIVATE_VC_COMPLETE
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_STATUS                            Status;
+} RCONDIS_MP_ACTIVATE_VC_COMPLETE, *PRCONDIS_MP_ACTIVATE_VC_COMPLETE;
+
+
+//
+//  CoNdisMiniportDeactivateVc message
+//
+typedef struct _RCONDIS_MP_DEACTIVATE_VC_REQUEST
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    UINT32                                  Flags;
+    RNDIS_HANDLE                            DeviceVcHandle;
+} RCONDIS_MP_DEACTIVATE_VC_REQUEST, *PRCONDIS_MP_DEACTIVATE_VC_REQUEST;
+
+//
+//  Response to CoNdisMiniportDeactivateVc
+//
+typedef struct _RCONDIS_MP_DEACTIVATE_VC_COMPLETE
+{
+    RNDIS_REQUEST_ID                        RequestId;
+    RNDIS_STATUS                            Status;
+} RCONDIS_MP_DEACTIVATE_VC_COMPLETE, *PRCONDIS_MP_DEACTIVATE_VC_COMPLETE;
+
+
+//
+// union with all of the RNDIS messages
+//
+typedef union _RNDIS_MESSAGE_CONTAINER
+{
+    RNDIS_PACKET                        Packet;
+    RNDIS_INITIALIZE_REQUEST            InitializeRequest;
+    RNDIS_HALT_REQUEST                  HaltRequest;
+    RNDIS_QUERY_REQUEST                 QueryRequest;
+    RNDIS_SET_REQUEST                   SetRequest;
+    RNDIS_RESET_REQUEST                 ResetRequest;
+    RNDIS_KEEPALIVE_REQUEST             KeepaliveRequest;
+    RNDIS_INDICATE_STATUS               IndicateStatus;
+    RNDIS_INITIALIZE_COMPLETE           InitializeComplete;
+    RNDIS_QUERY_COMPLETE                QueryComplete;
+    RNDIS_SET_COMPLETE                  SetComplete;
+    RNDIS_RESET_COMPLETE                ResetComplete;
+    RNDIS_KEEPALIVE_COMPLETE            KeepaliveComplete;
+    RCONDIS_MP_CREATE_VC                CoMiniportCreateVc;
+    RCONDIS_MP_DELETE_VC                CoMiniportDeleteVc;
+    RCONDIS_INDICATE_STATUS             CoIndicateStatus;
+    RCONDIS_MP_ACTIVATE_VC_REQUEST      CoMiniportActivateVc;
+    RCONDIS_MP_DEACTIVATE_VC_REQUEST    CoMiniportDeactivateVc;
+    RCONDIS_MP_CREATE_VC_COMPLETE       CoMiniportCreateVcComplete;
+    RCONDIS_MP_DELETE_VC_COMPLETE       CoMiniportDeleteVcComplete;
+    RCONDIS_MP_ACTIVATE_VC_COMPLETE     CoMiniportActivateVcComplete;
+    RCONDIS_MP_DEACTIVATE_VC_COMPLETE   CoMiniportDeactivateVcComplete;
+
+
+} RNDIS_MESSAGE_CONTAINER, *PRNDIS_MESSAGE_CONTAINER;
+
+//
+// Remote NDIS message format
+//
+typedef __struct_bcount(MessageLength) struct _RNDIS_MESSAGE
+{
+    UINT32                                  NdisMessageType;
+
+    //
+    // Total length of this message, from the beginning
+    // of the RNDIS_MESSAGE struct, in bytes.
+    //
+    UINT32                                  MessageLength;
+
+    // Actual message
+    RNDIS_MESSAGE_CONTAINER                 Message;
+
+} RNDIS_MESSAGE, *PRNDIS_MESSAGE;
+
+
+
+//
+// Handy macros
+
+// get the size of an RNDIS message. Pass in the message type,
+// RNDIS_SET_REQUEST, RNDIS_PACKET for example
+#define RNDIS_MESSAGE_SIZE(Message)                             \
+    (sizeof(Message) + (sizeof(RNDIS_MESSAGE) - sizeof(RNDIS_MESSAGE_CONTAINER)))
+
+// get pointer to info buffer with message pointer
+#define MESSAGE_TO_INFO_BUFFER(Message)                         \
+    (((PUCHAR)(Message)) + Message->InformationBufferOffset)
+
+// get pointer to status buffer with message pointer
+#define MESSAGE_TO_STATUS_BUFFER(Message)                       \
+    (((PUCHAR)(Message)) + Message->StatusBufferOffset)
+
+// get pointer to OOBD buffer with message pointer
+#define MESSAGE_TO_OOBD_BUFFER(Message)                         \
+    (((PUCHAR)(Message)) + Message->OOBDataOffset)
+
+// get pointer to data buffer with message pointer
+#define MESSAGE_TO_DATA_BUFFER(Message)                         \
+    (((PUCHAR)(Message)) + Message->PerPacketInfoOffset)
+
+// get pointer to contained message from NDIS_MESSAGE pointer
+#define RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(RndisMessage)          \
+    ((PVOID) &RndisMessage->Message)
+
+// get pointer to contained message from NDIS_MESSAGE pointer
+#define RNDIS_MESSAGE_RAW_PTR_TO_MESSAGE_PTR(RndisMessage)      \
+    ((PVOID) RndisMessage)
+
+#endif // _RNDIS_H_
--- /dev/null
+++ b/drivers/staging/hv/include/VmbusChannelInterface.h
@@ -0,0 +1,131 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+// allow nameless unions
+//#pragma warning(disable : 4201)
+
+//
+// A revision number of vmbus that is used for ensuring both ends on a
+// partition are using compatible versions.
+//
+#define VMBUS_REVISION_NUMBER       13
+
+//
+// Make maximum size of pipe payload of 16K
+//
+#define MAX_PIPE_DATA_PAYLOAD 		(sizeof(BYTE) * 16384)
+
+//
+// Define PipeMode values.
+//
+#define VMBUS_PIPE_TYPE_BYTE                    0x00000000
+#define VMBUS_PIPE_TYPE_MESSAGE                 0x00000004
+
+//
+// The size of the user defined data buffer for non-pipe offers.
+//
+#define MAX_USER_DEFINED_BYTES                  120
+
+//
+// The size of the user defined data buffer for pipe offers.
+//
+#define MAX_PIPE_USER_DEFINED_BYTES             116
+
+
+//
+// At the center of the Channel Management library is
+// the Channel Offer. This struct contains the
+// fundamental information about an offer.
+//
+#pragma pack(push,1)
+
+typedef struct
+{
+
+    GUID    InterfaceType;
+    GUID    InterfaceInstance;
+    UINT64  InterruptLatencyIn100nsUnits;
+    UINT32  InterfaceRevision;
+    UINT32  ServerContextAreaSize;  // in bytes
+    UINT16  ChannelFlags;
+    UINT16  MmioMegabytes;          // in bytes * 1024 * 1024
+
+    union
+    {
+        //
+        // Non-pipes: The user has MAX_USER_DEFINED_BYTES bytes.
+        //
+        struct
+        {
+            UCHAR   UserDefined[MAX_USER_DEFINED_BYTES];
+        } Standard;
+
+        //
+        // Pipes: The following sructure is an integrated pipe protocol, which
+        //        is implemented on top of standard user-defined data. Pipe clients
+        //        have MAX_PIPE_USER_DEFINED_BYTES left for their own use.
+        //
+        struct
+        {
+            UINT32  PipeMode;
+            UCHAR   UserDefined[MAX_PIPE_USER_DEFINED_BYTES];
+        } Pipe;
+    } u;
+	UINT32	Padding;
+} VMBUS_CHANNEL_OFFER, *PVMBUS_CHANNEL_OFFER;
+#pragma pack(pop)
+
+
+//
+// Verify the MAX_PIPE_USER_DEFINED_BYTES value.
+//
+//C_ASSERT(MAX_PIPE_USER_DEFINED_BYTES ==
+//         MAX_USER_DEFINED_BYTES -
+//         (FIELD_OFFSET(VMBUS_CHANNEL_OFFER, u.Pipe.UserDefined) -
+//          FIELD_OFFSET(VMBUS_CHANNEL_OFFER, u.Standard.UserDefined)));
+//
+
+typedef UINT32 GPADL_HANDLE;
+
+//
+// Server Flags
+//
+
+#define VMBUS_CHANNEL_ENUMERATE_DEVICE_INTERFACE           1
+#define VMBUS_CHANNEL_SERVER_SUPPORTS_TRANSFER_PAGES       2
+#define VMBUS_CHANNEL_SERVER_SUPPORTS_GPADLS               4
+#define VMBUS_CHANNEL_NAMED_PIPE_MODE                   0x10
+#define VMBUS_CHANNEL_LOOPBACK_OFFER                   0x100
+#define VMBUS_CHANNEL_PARENT_OFFER                     0x200
+#define VMBUS_CHANNEL_REQUEST_MONITORED_NOTIFICATION   0x400
+
+//
+// TEMPTEMP -- move this next define to devioctl.h some day
+//
+
+#ifndef FILE_DEVICE_VMBUS
+#define FILE_DEVICE_VMBUS   0x0000003E
+#endif
+
--- /dev/null
+++ b/drivers/staging/hv/include/VmbusPacketFormat.h
@@ -0,0 +1,322 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+
+//#ifndef PAGE_SIZE
+//#if defined(_IA64_)
+//#error This does not work for IA64
+//#else
+//#define PAGE_SIZE 0x1000
+//#endif
+//#endif
+
+// allow nameless unions
+//#pragma warning(disable : 4201)
+
+typedef struct
+{
+    union
+    {
+        struct
+        {
+            volatile UINT32  In;        // Offset in bytes from the ring base
+            volatile UINT32  Out;       // Offset in bytes from the ring base
+        };
+        volatile LONGLONG    InOut;
+    };
+
+    //
+    // If the receiving endpoint sets this to some non-zero value, the sending
+    // endpoint should not send any interrupts.
+    //
+
+    volatile UINT32 InterruptMask;
+
+} VMRCB, *PVMRCB;
+
+typedef struct
+{
+    union
+    {
+        struct
+        {
+            VMRCB Control;
+        };
+
+        UINT8 Reserved[PAGE_SIZE];
+    };
+
+    //
+    // Beginning of the ring data.  Note: It must be guaranteed that
+    // this data does not share a page with the control structure.
+    //
+    UINT8 Data[1];
+} VMRING, *PVMRING;
+
+#pragma pack(push, 1)
+
+typedef struct
+{
+    UINT16 Type;
+    UINT16 DataOffset8;
+    UINT16 Length8;
+    UINT16 Flags;
+    UINT64 TransactionId;
+} VMPACKET_DESCRIPTOR, *PVMPACKET_DESCRIPTOR;
+
+typedef UINT32 PREVIOUS_PACKET_OFFSET, *PPREVIOUS_PACKET_OFFSET;
+
+typedef struct
+{
+    PREVIOUS_PACKET_OFFSET  PreviousPacketStartOffset;
+    VMPACKET_DESCRIPTOR     Descriptor;
+} VMPACKET_HEADER, *PVMPACKET_HEADER;
+
+typedef struct
+{
+    UINT32  ByteCount;
+    UINT32  ByteOffset;
+} VMTRANSFER_PAGE_RANGE, *PVMTRANSFER_PAGE_RANGE;
+
+#ifdef __cplusplus
+
+typedef struct _VMTRANSFER_PAGE_PACKET_HEADER : VMPACKET_DESCRIPTOR {
+
+#else
+
+typedef struct VMTRANSFER_PAGE_PACKET_HEADER {
+
+    VMPACKET_DESCRIPTOR d;
+
+#endif
+
+    UINT16                  TransferPageSetId;
+    BOOLEAN                 SenderOwnsSet;
+    UINT8                   Reserved;
+    UINT32                  RangeCount;
+    VMTRANSFER_PAGE_RANGE   Ranges[1];
+
+} VMTRANSFER_PAGE_PACKET_HEADER, *PVMTRANSFER_PAGE_PACKET_HEADER;
+
+
+#ifdef __cplusplus
+
+typedef struct _VMGPADL_PACKET_HEADER : VMPACKET_DESCRIPTOR {
+
+#else
+
+typedef struct _VMGPADL_PACKET_HEADER {
+
+    VMPACKET_DESCRIPTOR d;
+
+#endif
+
+
+    UINT32  Gpadl;
+    UINT32  Reserved;
+
+} VMGPADL_PACKET_HEADER, *PVMGPADL_PACKET_HEADER;
+
+#ifdef __cplusplus
+
+typedef struct _VMADD_REMOVE_TRANSFER_PAGE_SET : VMPACKET_DESCRIPTOR {
+
+#else
+
+typedef struct _VMADD_REMOVE_TRANSFER_PAGE_SET {
+
+    VMPACKET_DESCRIPTOR d;
+
+#endif
+
+    UINT32  Gpadl;
+    UINT16  TransferPageSetId;
+    UINT16  Reserved;
+
+} VMADD_REMOVE_TRANSFER_PAGE_SET, *PVMADD_REMOVE_TRANSFER_PAGE_SET;
+
+#pragma pack(pop)
+
+//
+// This structure defines a range in guest physical space that can be made
+// to look virtually contiguous.
+//
+
+typedef struct _GPA_RANGE {
+
+    UINT32  ByteCount;
+    UINT32  ByteOffset;
+    UINT64  PfnArray[0];
+
+} GPA_RANGE, *PGPA_RANGE;
+
+
+
+#pragma pack(push, 1)
+
+//
+// This is the format for an Establish Gpadl packet, which contains a handle
+// by which this GPADL will be known and a set of GPA ranges associated with
+// it.  This can be converted to a MDL by the guest OS.  If there are multiple
+// GPA ranges, then the resulting MDL will be "chained," representing multiple
+// VA ranges.
+//
+
+#ifdef __cplusplus
+
+typedef struct _VMESTABLISH_GPADL : VMPACKET_DESCRIPTOR {
+
+#else
+
+typedef struct _VMESTABLISH_GPADL {
+
+    VMPACKET_DESCRIPTOR d;
+
+#endif
+
+    UINT32      Gpadl;
+    UINT32      RangeCount;
+    GPA_RANGE   Range[1];
+
+} VMESTABLISH_GPADL, *PVMESTABLISH_GPADL;
+
+
+//
+// This is the format for a Teardown Gpadl packet, which indicates that the
+// GPADL handle in the Establish Gpadl packet will never be referenced again.
+//
+
+#ifdef __cplusplus
+
+typedef struct _VMTEARDOWN_GPADL : VMPACKET_DESCRIPTOR {
+
+#else
+
+typedef struct _VMTEARDOWN_GPADL {
+
+    VMPACKET_DESCRIPTOR d;
+
+#endif
+
+    UINT32  Gpadl;
+    UINT32  Reserved; // for alignment to a 8-byte boundary
+} VMTEARDOWN_GPADL, *PVMTEARDOWN_GPADL;
+
+
+//
+// This is the format for a GPA-Direct packet, which contains a set of GPA
+// ranges, in addition to commands and/or data.
+//
+
+#ifdef __cplusplus
+
+typedef struct _VMDATA_GPA_DIRECT : VMPACKET_DESCRIPTOR {
+
+#else
+
+typedef struct _VMDATA_GPA_DIRECT {
+
+    VMPACKET_DESCRIPTOR d;
+
+#endif
+
+    UINT32      Reserved;
+    UINT32      RangeCount;
+    GPA_RANGE   Range[1];
+
+} VMDATA_GPA_DIRECT, *PVMDATA_GPA_DIRECT;
+
+
+
+//
+// This is the format for a Additional Data Packet.
+//
+
+#ifdef __cplusplus
+
+typedef struct _VMADDITIONAL_DATA : VMPACKET_DESCRIPTOR {
+
+#else
+
+typedef struct _VMADDITIONAL_DATA {
+
+    VMPACKET_DESCRIPTOR d;
+
+#endif
+
+    UINT64  TotalBytes;
+    UINT32  ByteOffset;
+    UINT32  ByteCount;
+    UCHAR   Data[1];
+
+} VMADDITIONAL_DATA, *PVMADDITIONAL_DATA;
+
+
+#pragma pack(pop)
+
+typedef union {
+    VMPACKET_DESCRIPTOR             SimpleHeader;
+    VMTRANSFER_PAGE_PACKET_HEADER   TransferPageHeader;
+    VMGPADL_PACKET_HEADER           GpadlHeader;
+    VMADD_REMOVE_TRANSFER_PAGE_SET  AddRemoveTransferPageHeader;
+    VMESTABLISH_GPADL               EstablishGpadlHeader;
+    VMTEARDOWN_GPADL                TeardownGpadlHeader;
+    VMDATA_GPA_DIRECT               DataGpaDirectHeader;
+} VMPACKET_LARGEST_POSSIBLE_HEADER, *PVMPACKET_LARGEST_POSSIBLE_HEADER;
+
+#define VMPACKET_DATA_START_ADDRESS(__packet)                           \
+    (PVOID)(((PUCHAR)__packet) + ((PVMPACKET_DESCRIPTOR)__packet)->DataOffset8 * 8)
+
+#define VMPACKET_DATA_LENGTH(__packet)                                  \
+    ((((PVMPACKET_DESCRIPTOR)__packet)->Length8 - ((PVMPACKET_DESCRIPTOR)__packet)->DataOffset8) * 8)
+
+#define VMPACKET_TRANSFER_MODE(__packet) ((PVMPACKET_DESCRIPTOR)__packet)->Type
+
+typedef enum {
+    VmbusServerEndpoint = 0,
+    VmbusClientEndpoint,
+    VmbusEndpointMaximum
+} ENDPOINT_TYPE, *PENDPOINT_TYPE;
+
+typedef enum {
+    VmbusPacketTypeInvalid                      = 0x0,
+    VmbusPacketTypeSynch                        = 0x1,
+    VmbusPacketTypeAddTransferPageSet           = 0x2,
+    VmbusPacketTypeRemoveTransferPageSet        = 0x3,
+    VmbusPacketTypeEstablishGpadl               = 0x4,
+    VmbusPacketTypeTearDownGpadl                = 0x5,
+    VmbusPacketTypeDataInBand                   = 0x6,
+    VmbusPacketTypeDataUsingTransferPages       = 0x7,
+    VmbusPacketTypeDataUsingGpadl               = 0x8,
+    VmbusPacketTypeDataUsingGpaDirect           = 0x9,
+    VmbusPacketTypeCancelRequest                = 0xa,
+    VmbusPacketTypeCompletion                   = 0xb,
+    VmbusPacketTypeDataUsingAdditionalPackets   = 0xc,
+    VmbusPacketTypeAdditionalData               = 0xd
+} VMBUS_PACKET_TYPE, *PVMBUS_PACKET_TYPE;
+
+#define VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED    1
+
+
--- /dev/null
+++ b/drivers/staging/hv/include/vstorage.h
@@ -0,0 +1,309 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+
+
+#pragma once
+
+//#include <vmbuspacketformat.h>
+//#include <ntddscsi.h>
+
+#define C_ASSERT(x)
+//
+//  public interface to the server
+//
+
+//
+//  Storvsp device interface guid
+//
+
+
+//
+//  Protocol versions.
+//
+
+//
+// vstorage.w revision number.  This is used in the case of a version match,
+// to alert the user that structure sizes may be mismatched even though the
+// protocol versions match.
+//
+
+#define REVISION_STRING(REVISION_) #REVISION_
+#define FILL_VMSTOR_REVISION(RESULT_LVALUE_)                     \
+{                                                                \
+    char *revisionString = REVISION_STRING($Revision: 6 $) + 11; \
+    RESULT_LVALUE_ = 0;                                          \
+    while (*revisionString >= '0' && *revisionString <= '9')     \
+    {                                                            \
+        RESULT_LVALUE_ *= 10;                                    \
+        RESULT_LVALUE_ += *revisionString - '0';                 \
+        revisionString++;                                        \
+    }                                                            \
+}
+
+//
+// Major/minor macros.  Minor version is in LSB, meaning that earlier flat
+// version numbers will be interpreted as "0.x" (i.e., 1 becomes 0.1).
+//
+
+#define VMSTOR_PROTOCOL_MAJOR(VERSION_)         (((VERSION_) >> 8) & 0xff)
+#define VMSTOR_PROTOCOL_MINOR(VERSION_)         (((VERSION_)     ) & 0xff)
+#define VMSTOR_PROTOCOL_VERSION(MAJOR_, MINOR_) ((((MAJOR_) & 0xff) << 8) | \
+                                                 (((MINOR_) & 0xff)     ))
+
+//
+// Invalid version.
+//
+
+#define VMSTOR_INVALID_PROTOCOL_VERSION  -1
+
+//
+// Version history:
+// V1 Beta                    0.1
+// V1 RC < 2008/1/31          1.0
+// V1 RC > 2008/1/31          2.0
+//
+#define VMSTOR_PROTOCOL_VERSION_CURRENT VMSTOR_PROTOCOL_VERSION(2, 0)
+
+
+//
+//  This will get replaced with the max transfer length that is possible on
+//  the host adapter.
+//  The max transfer length will be published when we offer a vmbus channel.
+//
+
+#define MAX_TRANSFER_LENGTH 0x40000
+#define DEFAULT_PACKET_SIZE (sizeof(VMDATA_GPA_DIRECT) +                            \
+                             sizeof(VSTOR_PACKET) +                                 \
+                             (sizeof(UINT64) * (MAX_TRANSFER_LENGTH / PAGE_SIZE)))
+
+
+
+//
+//  Packet structure describing virtual storage requests.
+//
+
+typedef enum
+{
+    VStorOperationCompleteIo            = 1,
+    VStorOperationRemoveDevice          = 2,
+    VStorOperationExecuteSRB            = 3,
+    VStorOperationResetLun              = 4,
+    VStorOperationResetAdapter          = 5,
+    VStorOperationResetBus              = 6,
+    VStorOperationBeginInitialization   = 7,
+    VStorOperationEndInitialization     = 8,
+    VStorOperationQueryProtocolVersion  = 9,
+    VStorOperationQueryProperties       = 10,
+    VStorOperationMaximum               = 10
+
+} VSTOR_PACKET_OPERATION;
+
+
+//
+//  Platform neutral description of a scsi request -
+//  this remains the same across the write regardless of 32/64 bit
+//  note: it's patterned off the SCSI_PASS_THROUGH structure
+//
+
+
+#pragma pack(push,1)
+
+
+#define CDB16GENERIC_LENGTH 0x10
+
+#ifndef SENSE_BUFFER_SIZE
+#define SENSE_BUFFER_SIZE 0x12
+#endif
+C_ASSERT(SENSE_BUFFER_SIZE == 0x12);
+
+#define MAX_DATA_BUFFER_LENGTH_WITH_PADDING 0x14
+
+
+typedef struct
+{
+    USHORT Length;
+    UCHAR SrbStatus;
+    UCHAR ScsiStatus;
+
+    UCHAR PortNumber;
+    UCHAR PathId;
+    UCHAR TargetId;
+    UCHAR Lun;
+
+    UCHAR CdbLength;
+    UCHAR SenseInfoLength;
+    UCHAR DataIn;
+    UCHAR Reserved;
+
+    ULONG DataTransferLength;
+
+    union
+    {
+        UCHAR Cdb[CDB16GENERIC_LENGTH];
+
+        UCHAR SenseData[SENSE_BUFFER_SIZE];
+
+        UCHAR ReservedArray[MAX_DATA_BUFFER_LENGTH_WITH_PADDING];
+    };
+
+} VMSCSI_REQUEST, *PVMSCSI_REQUEST;
+
+C_ASSERT((sizeof(VMSCSI_REQUEST) % 4) == 0);
+
+
+//
+//  This structure is sent during the intialization phase to get the different
+//  properties of the channel.
+//
+
+typedef struct
+{
+    USHORT ProtocolVersion;
+    UCHAR  PathId;
+    UCHAR  TargetId;
+
+    //
+    // Note: port number is only really known on the client side
+    //
+    ULONG  PortNumber;
+
+    ULONG  Flags;
+
+    ULONG  MaxTransferBytes;
+
+    //
+    //  This id is unique for each channel and will correspond with
+    //  vendor specific data in the inquirydata
+    //
+
+    ULONGLONG UniqueId;
+
+} VMSTORAGE_CHANNEL_PROPERTIES, *PVMSTORAGE_CHANNEL_PROPERTIES;
+
+C_ASSERT((sizeof(VMSTORAGE_CHANNEL_PROPERTIES) % 4) == 0);
+
+
+//
+//  This structure is sent during the storage protocol negotiations.
+//
+
+typedef struct
+{
+    //
+    // Major (MSW) and minor (LSW) version numbers.
+    //
+
+    USHORT MajorMinor;
+
+
+    //
+    // Revision number is auto-incremented whenever this file is changed
+    // (See FILL_VMSTOR_REVISION macro above).  Mismatch does not definitely
+    // indicate incompatibility--but it does indicate mismatched builds.
+    //
+
+    USHORT Revision;
+
+} VMSTORAGE_PROTOCOL_VERSION, *PVMSTORAGE_PROTOCOL_VERSION;
+
+C_ASSERT((sizeof(VMSTORAGE_PROTOCOL_VERSION) % 4) == 0);
+
+
+//
+// Channel Property Flags
+//
+
+#define STORAGE_CHANNEL_REMOVABLE_FLAG                  0x1
+#define STORAGE_CHANNEL_EMULATED_IDE_FLAG               0x2
+
+
+typedef struct _VSTOR_PACKET
+{
+    //
+    // Requested operation type
+    //
+
+    VSTOR_PACKET_OPERATION Operation;
+
+    //
+    //  Flags - see below for values
+    //
+
+    ULONG     Flags;
+
+    //
+    // Status of the request returned from the server side.
+    //
+
+    ULONG     Status;
+
+    //
+    // Data payload area
+    //
+
+    union
+    {
+        //
+        //  Structure used to forward SCSI commands from the client to the server.
+        //
+
+        VMSCSI_REQUEST VmSrb;
+
+        //
+        // Structure used to query channel properties.
+        //
+
+        VMSTORAGE_CHANNEL_PROPERTIES StorageChannelProperties;
+
+        //
+        // Used during version negotiations.
+        //
+
+        VMSTORAGE_PROTOCOL_VERSION Version;
+    };
+
+} VSTOR_PACKET, *PVSTOR_PACKET;
+
+C_ASSERT((sizeof(VSTOR_PACKET) % 4) == 0);
+
+//
+//  Packet flags
+//
+
+//
+//  This flag indicates that the server should send back a completion for this
+//  packet.
+//
+
+#define REQUEST_COMPLETION_FLAG 0x1
+
+//
+//  This is the set of flags that the vsc can set in any packets it sends
+//
+
+#define VSC_LEGAL_FLAGS (REQUEST_COMPLETION_FLAG)
+
+
+#pragma pack(pop)
+
+
