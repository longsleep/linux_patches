From alan@linux.intel.com  Thu Aug 27 14:30:06 2009
From: Alan Cox <alan@linux.intel.com>
Date: Thu, 27 Aug 2009 11:02:12 +0100
Subject: Staging: et131x: kill the interrupt magic define and types
To: greg@kroah.com
Message-ID: <20090827100210.23892.2381.stgit@localhost.localdomain>


Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_address_map.h |   96 +++++++---------------------
 drivers/staging/et131x/et1310_jagcore.c     |   31 ++++++---
 drivers/staging/et131x/et131x_adapter.h     |    4 -
 drivers/staging/et131x/et131x_isr.c         |   55 +++++++---------
 4 files changed, 79 insertions(+), 107 deletions(-)


--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -89,72 +89,30 @@
 #define ET_PMCSR_INIT			0x38
 
 /*
- * structure for interrupt status reg in global address map
- * located at address 0x0018
+ * Interrupt status reg at address 0x0018
  */
-typedef union _INTERRUPT_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 unused5:11;			/* bits 21-31 */
-		u32 slv_timeout:1;			/* bit 20 */
-		u32 mac_stat_interrupt:1;		/* bit 19 */
-		u32 rxmac_interrupt:1;		/* bit 18 */
-		u32 txmac_interrupt:1;		/* bit 17 */
-		u32 phy_interrupt:1;		/* bit 16 */
-		u32 wake_on_lan:1;			/* bit 15 */
-		u32 watchdog_interrupt:1;		/* bit 14 */
-		u32 unused4:4;			/* bits 10-13 */
-		u32 rxdma_err:1;			/* bit 9 */
-		u32 rxdma_pkt_stat_ring_low:1;	/* bit 8 */
-		u32 rxdma_fb_ring1_low:1;		/* bit 7 */
-		u32 rxdma_fb_ring0_low:1;		/* bit 6 */
-		u32 rxdma_xfr_done:1;		/* bit 5 */
-		u32 txdma_err:1;			/* bit 4 */
-		u32 txdma_isr:1;			/* bit 3 */
-		u32 unused3:1;			/* bit 2 */
-		u32 unused2:1;			/* bit 1 */
-		u32 unused1:1;			/* bit 0 */
-#else
-		u32 unused1:1;			/* bit 0 */
-		u32 unused2:1;			/* bit 1 */
-		u32 unused3:1;			/* bit 2 */
-		u32 txdma_isr:1;			/* bit 3 */
-		u32 txdma_err:1;			/* bit 4 */
-		u32 rxdma_xfr_done:1;		/* bit 5 */
-		u32 rxdma_fb_ring0_low:1;		/* bit 6 */
-		u32 rxdma_fb_ring1_low:1;		/* bit 7 */
-		u32 rxdma_pkt_stat_ring_low:1;	/* bit 8 */
-		u32 rxdma_err:1;			/* bit 9 */
-		u32 unused4:4;			/* bits 10-13 */
-		u32 watchdog_interrupt:1;		/* bit 14 */
-		u32 wake_on_lan:1;			/* bit 15 */
-		u32 phy_interrupt:1;		/* bit 16 */
-		u32 txmac_interrupt:1;		/* bit 17 */
-		u32 rxmac_interrupt:1;		/* bit 18 */
-		u32 mac_stat_interrupt:1;		/* bit 19 */
-		u32 slv_timeout:1;			/* bit 20 */
-		u32 unused5:11;			/* bits 21-31 */
-#endif
-	} bits;
-} INTERRUPT_t, *PINTERRUPT_t;
-
-/*
- * structure for interrupt mask reg in global address map
- * located at address 0x001C
- * Defined earlier (INTERRUPT_t), but 'watchdog_interrupt' is not used.
- */
-
-/*
- * structure for interrupt alias clear mask reg in global address map
- * located at address 0x0020
- * Defined earlier (INTERRUPT_t)
- */
-
-/*
- * structure for interrupt status alias reg in global address map
- * located at address 0x0024
- * Defined earlier (INTERRUPT_t)
+
+#define	ET_INTR_TXDMA_ISR	0x00000008
+#define ET_INTR_TXDMA_ERR	0x00000010
+#define ET_INTR_RXDMA_XFR_DONE	0x00000020
+#define ET_INTR_RXDMA_FB_R0_LOW	0x00000040
+#define ET_INTR_RXDMA_FB_R1_LOW	0x00000080
+#define ET_INTR_RXDMA_STAT_LOW	0x00000100
+#define ET_INTR_RXDMA_ERR	0x00000200
+#define ET_INTR_WATCHDOG	0x00004000
+#define ET_INTR_WOL		0x00008000
+#define ET_INTR_PHY		0x00010000
+#define ET_INTR_TXMAC		0x00020000
+#define ET_INTR_RXMAC		0x00040000
+#define ET_INTR_MAC_STAT	0x00080000
+#define ET_INTR_SLV_TIMEOUT	0x00100000
+
+/*
+ * Interrupt mask register at address 0x001C
+ * Interrupt alias clear mask reg at address 0x0020
+ * Interrupt status alias reg at address 0x0024
+ *
+ * Same masks as above
  */
 
 /*
@@ -256,10 +214,10 @@ typedef struct _GLOBAL_t {			/* Location
 	u32 rxq_end_addr;			/*  0x000C */
 	u32 pm_csr;				/*  0x0010 */
 	u32 unused;				/*  0x0014 */
-	INTERRUPT_t int_status;			/*  0x0018 */
-	INTERRUPT_t int_mask;			/*  0x001C */
-	INTERRUPT_t int_alias_clr_en;		/*  0x0020 */
-	INTERRUPT_t int_status_alias;		/*  0x0024 */
+	u32 int_status;				/*  0x0018 */
+	u32 int_mask;				/*  0x001C */
+	u32 int_alias_clr_en;			/*  0x0020 */
+	u32 int_status_alias;			/*  0x0024 */
 	SW_RESET_t sw_reset;			/*  0x0028 */
 	SLV_TIMER_t slv_timer;			/*  0x002C */
 	MSI_CONFIG_t msi_config;		/*  0x0030 */
--- a/drivers/staging/et131x/et1310_jagcore.c
+++ b/drivers/staging/et131x/et1310_jagcore.c
@@ -174,26 +174,41 @@ void ConfigMMCRegs(struct et131x_adapter
 	DBG_LEAVE(et131x_dbginfo);
 }
 
+/**
+ *	et131x_enable_interrupts	-	enable interrupt
+ *	@adapter: et131x device
+ *
+ *	Enable the appropriate interrupts on the ET131x according to our
+ *	configuration
+ */
+
 void et131x_enable_interrupts(struct et131x_adapter *adapter)
 {
-	uint32_t MaskValue;
+	u32 mask;
 
 	/* Enable all global interrupts */
 	if (adapter->FlowControl == TxOnly || adapter->FlowControl == Both)
-		MaskValue = INT_MASK_ENABLE;
+		mask = INT_MASK_ENABLE;
 	else
-		MaskValue = INT_MASK_ENABLE_NO_FLOW;
+		mask = INT_MASK_ENABLE_NO_FLOW;
 
 	if (adapter->DriverNoPhyAccess)
-		MaskValue |= 0x10000;
+		mask |= ET_INTR_PHY;
 
-	adapter->CachedMaskValue.value = MaskValue;
-	writel(MaskValue, &adapter->regs->global.int_mask.value);
+	adapter->CachedMaskValue = mask;
+	writel(mask, &adapter->regs->global.int_mask);
 }
 
+/**
+ *	et131x_disable_interrupts	-	interrupt disable
+ *	@adapter: et131x device
+ *
+ *	Block all interrupts from the et131x device at the device itself
+ */
+
 void et131x_disable_interrupts(struct et131x_adapter *adapter)
 {
 	/* Disable all global interrupts */
-	adapter->CachedMaskValue.value = INT_MASK_DISABLE;
-	writel(INT_MASK_DISABLE, &adapter->regs->global.int_mask.value);
+	adapter->CachedMaskValue = INT_MASK_DISABLE;
+	writel(INT_MASK_DISABLE, &adapter->regs->global.int_mask);
 }
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -184,7 +184,7 @@ typedef struct _ce_stats_t {
 #endif	/* CONFIG_ET131X_DEBUG */
 
 	u32 SynchrounousIterations;
-	INTERRUPT_t InterruptStatus;
+	u32 InterruptStatus;
 } CE_STATS_t, *PCE_STATS_t;
 
 /* The private adapter structure */
@@ -260,7 +260,7 @@ struct et131x_adapter {
 	/* Minimize init-time */
 	struct timer_list ErrorTimer;
 	MP_POWER_MGMT PoMgmt;
-	INTERRUPT_t CachedMaskValue;
+	u32 CachedMaskValue;
 
 	/* Xcvr status at last poll */
 	MI_BMSR_t Bmsr;
--- a/drivers/staging/et131x/et131x_isr.c
+++ b/drivers/staging/et131x/et131x_isr.c
@@ -108,7 +108,7 @@ irqreturn_t et131x_isr(int irq, void *de
 	bool handled = true;
 	struct net_device *netdev = (struct net_device *)dev_id;
 	struct et131x_adapter *adapter = NULL;
-	INTERRUPT_t status;
+	u32 status;
 
 	if (netdev == NULL || !netif_device_present(netdev)) {
 		DBG_WARNING(et131x_dbginfo,
@@ -129,17 +129,17 @@ irqreturn_t et131x_isr(int irq, void *de
 	/* Get a copy of the value in the interrupt status register
 	 * so we can process the interrupting section
 	 */
-	status.value = readl(&adapter->regs->global.int_status.value);
+	status = readl(&adapter->regs->global.int_status);
 
 	if (adapter->FlowControl == TxOnly ||
 	    adapter->FlowControl == Both) {
-		status.value &= ~INT_MASK_ENABLE;
+		status &= ~INT_MASK_ENABLE;
 	} else {
-		status.value &= ~INT_MASK_ENABLE_NO_FLOW;
+		status &= ~INT_MASK_ENABLE_NO_FLOW;
 	}
 
 	/* Make sure this is our interrupt */
-	if (!status.value) {
+	if (!status) {
 #ifdef CONFIG_ET131X_DEBUG
 		adapter->Stats.UnhandledInterruptsPerSec++;
 #endif
@@ -151,32 +151,32 @@ irqreturn_t et131x_isr(int irq, void *de
 
 	/* This is our interrupt, so process accordingly */
 #ifdef CONFIG_ET131X_DEBUG
-	if (status.bits.rxdma_xfr_done)
+	if (status & ET_INTR_RXDMA_XFR_DONE)
 		adapter->Stats.RxDmaInterruptsPerSec++;
 
-	if (status.bits.txdma_isr)
+	if (status & ET_INTR_TXDMA_ISR)
 		adapter->Stats.TxDmaInterruptsPerSec++;
 #endif
 
-	if (status.bits.watchdog_interrupt) {
+	if (status & ET_INTR_WATCHDOG) {
 		PMP_TCB pMpTcb = adapter->TxRing.CurrSendHead;
 
 		if (pMpTcb)
 			if (++pMpTcb->PacketStaleCount > 1)
-				status.bits.txdma_isr = 1;
+				status |= ET_INTR_TXDMA_ISR;
 
 		if (adapter->RxRing.UnfinishedReceives)
-			status.bits.rxdma_xfr_done = 1;
+			status |= ET_INTR_RXDMA_XFR_DONE;
 		else if (pMpTcb == NULL)
 			writel(0, &adapter->regs->global.watchdog_timer);
 
-		status.bits.watchdog_interrupt = 0;
+		status &= ~ET_INTR_WATCHDOG;
 #ifdef CONFIG_ET131X_DEBUG
 		adapter->Stats.WatchDogInterruptsPerSec++;
 #endif
 	}
 
-	if (status.value == 0) {
+	if (status == 0) {
 		/* This interrupt has in some way been "handled" by
 		 * the ISR. Either it was a spurious Rx interrupt, or
 		 * it was a Tx interrupt that has been filtered by
@@ -213,7 +213,7 @@ void et131x_isr_handler(struct work_stru
 {
 	struct et131x_adapter *etdev =
 		container_of(work, struct et131x_adapter, task);
-	INTERRUPT_t GlobStatus = etdev->Stats.InterruptStatus;
+	u32 status = etdev->Stats.InterruptStatus;
 	ADDRESS_MAP_t __iomem *iomem = etdev->regs;
 
 	/*
@@ -222,22 +222,22 @@ void et131x_isr_handler(struct work_stru
 	 * exit.
 	 */
 	/* Handle all the completed Transmit interrupts */
-	if (GlobStatus.bits.txdma_isr) {
+	if (status & ET_INTR_TXDMA_ISR) {
 		DBG_TX(et131x_dbginfo, "TXDMA_ISR interrupt\n");
 		et131x_handle_send_interrupt(etdev);
 	}
 
 	/* Handle all the completed Receives interrupts */
-	if (GlobStatus.bits.rxdma_xfr_done) {
+	if (status & ET_INTR_RXDMA_XFR_DONE) {
 		DBG_RX(et131x_dbginfo, "RXDMA_XFR_DONE interrupt\n");
 		et131x_handle_recv_interrupt(etdev);
 	}
 
-	GlobStatus.value &= 0xffffffd7;
+	status &= 0xffffffd7;
 
-	if (GlobStatus.value) {
+	if (status) {
 		/* Handle the TXDMA Error interrupt */
-		if (GlobStatus.bits.txdma_err) {
+		if (status & ET_INTR_TXDMA_ERR) {
 			TXDMA_ERROR_t TxDmaErr;
 
 			/* Following read also clears the register (COR) */
@@ -249,8 +249,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Handle Free Buffer Ring 0 and 1 Low interrupt */
-		if (GlobStatus.bits.rxdma_fb_ring0_low ||
-		    GlobStatus.bits.rxdma_fb_ring1_low) {
+		if (status & (ET_INTR_RXDMA_FB_R0_LOW | ET_INTR_RXDMA_FB_R1_LOW)) {
 			/*
 			 * This indicates the number of unused buffers in
 			 * RXDMA free buffer ring 0 is <= the limit you
@@ -292,7 +291,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Handle Packet Status Ring Low Interrupt */
-		if (GlobStatus.bits.rxdma_pkt_stat_ring_low) {
+		if (status & ET_INTR_RXDMA_STAT_LOW) {
 			DBG_WARNING(et131x_dbginfo,
 				    "RXDMA_PKT_STAT_RING_LOW interrupt\n");
 
@@ -308,7 +307,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Handle RXDMA Error Interrupt */
-		if (GlobStatus.bits.rxdma_err) {
+		if (status & ET_INTR_RXDMA_ERR) {
 			/*
 			 * The rxdma_error interrupt is sent when a time-out
 			 * on a request issued by the JAGCore has occurred or
@@ -337,7 +336,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Handle the Wake on LAN Event */
-		if (GlobStatus.bits.wake_on_lan) {
+		if (status & ET_INTR_WOL) {
 			/*
 			 * This is a secondary interrupt for wake on LAN.
 			 * The driver should never see this, if it does,
@@ -349,7 +348,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Handle the PHY interrupt */
-		if (GlobStatus.bits.phy_interrupt) {
+		if (status & ET_INTR_PHY) {
 			u32 pm_csr;
 			MI_BMSR_t BmsrInts, BmsrData;
 			MI_ISR_t myIsr;
@@ -398,7 +397,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Let's move on to the TxMac */
-		if (GlobStatus.bits.txmac_interrupt) {
+		if (status & ET_INTR_TXMAC) {
 			etdev->TxRing.TxMacErr.value =
 				readl(&iomem->txmac.err.value);
 
@@ -424,7 +423,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Handle RXMAC Interrupt */
-		if (GlobStatus.bits.rxmac_interrupt) {
+		if (status & ET_INTR_RXMAC) {
 			/*
 			 * These interrupts are catastrophic to the device,
 			 * what we need to do is disable the interrupts and
@@ -452,7 +451,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Handle MAC_STAT Interrupt */
-		if (GlobStatus.bits.mac_stat_interrupt) {
+		if (status & ET_INTR_MAC_STAT) {
 			/*
 			 * This means at least one of the un-masked counters
 			 * in the MAC_STAT block has rolled over.  Use this
@@ -464,7 +463,7 @@ void et131x_isr_handler(struct work_stru
 		}
 
 		/* Handle SLV Timeout Interrupt */
-		if (GlobStatus.bits.slv_timeout) {
+		if (status & ET_INTR_SLV_TIMEOUT) {
 			/*
 			 * This means a timeout has occured on a read or
 			 * write request to one of the JAGCore registers. The
