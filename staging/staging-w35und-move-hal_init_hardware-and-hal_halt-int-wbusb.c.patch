From penberg@cs.helsinki.fi  Tue Apr 21 15:22:30 2009
From: Pekka Enberg <penberg@cs.helsinki.fi>
Date: Wed,  8 Apr 2009 11:13:57 +0300
Subject: Staging: w35und: move hal_init_hardware() and hal_halt() int wbusb.c
To: greg@kroah.com
Cc: Pavel Machek <pavel@ucw.cz>
Message-ID: <1239178446-12893-2-git-send-email-penberg@cs.helsinki.fi>


Impact: cleanup

The hal_init_hardware() and hal_halt() functions are only used in
wbusb.c so move them there.

Acked-by: Pavel Machek <pavel@ucw.cz>
Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/winbond/wbhal.c   |  346 --------------------------------------
 drivers/staging/winbond/wbhal_f.h |    2 
 drivers/staging/winbond/wbusb.c   |  345 +++++++++++++++++++++++++++++++++++++
 3 files changed, 345 insertions(+), 348 deletions(-)

--- a/drivers/staging/winbond/wbhal.c
+++ b/drivers/staging/winbond/wbhal.c
@@ -23,352 +23,6 @@ void hal_get_permanent_address( struct h
 	memcpy( pethernet_address, pHwData->PermanentMacAddress, 6 );
 }
 
-static void hal_led_control(unsigned long data)
-{
-	struct wbsoft_priv *adapter = (struct wbsoft_priv *) data;
-	struct hw_data * pHwData = &adapter->sHwData;
-	struct wb35_reg *reg = &pHwData->reg;
-	u32	LEDSet = (pHwData->SoftwareSet & HAL_LED_SET_MASK) >> HAL_LED_SET_SHIFT;
-	u8	LEDgray[20] = { 0,3,4,6,8,10,11,12,13,14,15,14,13,12,11,10,8,6,4,2 };
-	u8	LEDgray2[30] = { 7,8,9,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,13,12,11,10,9,8 };
-	u32	TimeInterval = 500, ltmp, ltmp2;
-        ltmp=0;
-
-	if( pHwData->SurpriseRemove ) return;
-
-	if( pHwData->LED_control ) {
-		ltmp2 = pHwData->LED_control & 0xff;
-		if( ltmp2 == 5 ) // 5 is WPS mode
-		{
-			TimeInterval = 100;
-			ltmp2 = (pHwData->LED_control>>8) & 0xff;
-			switch( ltmp2 )
-			{
-				case 1: // [0.2 On][0.1 Off]...
-					pHwData->LED_Blinking %= 3;
-					ltmp = 0x1010; // Led 1 & 0 Green and Red
-					if( pHwData->LED_Blinking == 2 ) // Turn off
-						ltmp = 0;
-					break;
-				case 2: // [0.1 On][0.1 Off]...
-					pHwData->LED_Blinking %= 2;
-					ltmp = 0x0010; // Led 0 red color
-					if( pHwData->LED_Blinking ) // Turn off
-						ltmp = 0;
-					break;
-				case 3: // [0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.5 Off]...
-					pHwData->LED_Blinking %= 15;
-					ltmp = 0x0010; // Led 0 red color
-					if( (pHwData->LED_Blinking >= 9) || (pHwData->LED_Blinking%2) ) // Turn off 0.6 sec
-						ltmp = 0;
-					break;
-				case 4: // [300 On][ off ]
-					ltmp = 0x1000; // Led 1 Green color
-					if( pHwData->LED_Blinking >= 3000 )
-						ltmp = 0; // led maybe on after 300sec * 32bit counter overlap.
-					break;
-			}
-			pHwData->LED_Blinking++;
-
-			reg->U1BC_LEDConfigure = ltmp;
-			if( LEDSet != 7 ) // Only 111 mode has 2 LEDs on PCB.
-			{
-				reg->U1BC_LEDConfigure |= (ltmp &0xff)<<8; // Copy LED result to each LED control register
-				reg->U1BC_LEDConfigure |= (ltmp &0xff00)>>8;
-			}
-			Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-		}
-	}
-	else if( pHwData->CurrentRadioSw || pHwData->CurrentRadioHw ) // If radio off
-	{
-		if( reg->U1BC_LEDConfigure & 0x1010 )
-		{
-			reg->U1BC_LEDConfigure &= ~0x1010;
-			Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-		}
-	}
-	else
-	{
-		switch( LEDSet )
-		{
-			case 4: // [100] Only 1 Led be placed on PCB and use pin 21 of IC. Use LED_0 for showing
-				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
-				{
-					// Blinking if scanning is on progress
-					if( pHwData->LED_Scanning )
-					{
-						if( pHwData->LED_Blinking == 0 )
-						{
-							reg->U1BC_LEDConfigure |= 0x10;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 On
-							pHwData->LED_Blinking = 1;
-							TimeInterval = 300;
-						}
-						else
-						{
-							reg->U1BC_LEDConfigure &= ~0x10;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-							pHwData->LED_Blinking = 0;
-							TimeInterval = 300;
-						}
-					}
-					else
-					{
-						//Turn Off LED_0
-						if( reg->U1BC_LEDConfigure & 0x10 )
-						{
-							reg->U1BC_LEDConfigure &= ~0x10;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-						}
-					}
-				}
-				else
-				{
-					// Turn On LED_0
-					if( (reg->U1BC_LEDConfigure & 0x10) == 0 )
-					{
-						reg->U1BC_LEDConfigure |= 0x10;
-						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-					}
-				}
-				break;
-
-			case 6: // [110] Only 1 Led be placed on PCB and use pin 21 of IC. Use LED_0 for showing
-				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
-				{
-					// Blinking if scanning is on progress
-					if( pHwData->LED_Scanning )
-					{
-						if( pHwData->LED_Blinking == 0 )
-						{
-							reg->U1BC_LEDConfigure &= ~0xf;
-							reg->U1BC_LEDConfigure |= 0x10;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 On
-							pHwData->LED_Blinking = 1;
-							TimeInterval = 300;
-						}
-						else
-						{
-							reg->U1BC_LEDConfigure &= ~0x1f;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-							pHwData->LED_Blinking = 0;
-							TimeInterval = 300;
-						}
-					}
-					else
-					{
-						// 20060901 Gray blinking if in disconnect state and not scanning
-						ltmp = reg->U1BC_LEDConfigure;
-						reg->U1BC_LEDConfigure &= ~0x1f;
-						if( LEDgray2[(pHwData->LED_Blinking%30)] )
-						{
-							reg->U1BC_LEDConfigure |= 0x10;
-							reg->U1BC_LEDConfigure |= LEDgray2[ (pHwData->LED_Blinking%30) ];
-						}
-						pHwData->LED_Blinking++;
-						if( reg->U1BC_LEDConfigure != ltmp )
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-						TimeInterval = 100;
-					}
-				}
-				else
-				{
-					// Turn On LED_0
-					if( (reg->U1BC_LEDConfigure & 0x10) == 0 )
-					{
-						reg->U1BC_LEDConfigure |= 0x10;
-						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-					}
-				}
-				break;
-
-			case 5: // [101] Only 1 Led be placed on PCB and use LED_1 for showing
-				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
-				{
-					// Blinking if scanning is on progress
-					if( pHwData->LED_Scanning )
-					{
-						if( pHwData->LED_Blinking == 0 )
-						{
-							reg->U1BC_LEDConfigure |= 0x1000;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
-							pHwData->LED_Blinking = 1;
-							TimeInterval = 300;
-						}
-						else
-						{
-							reg->U1BC_LEDConfigure &= ~0x1000;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 Off
-							pHwData->LED_Blinking = 0;
-							TimeInterval = 300;
-						}
-					}
-					else
-					{
-						//Turn Off LED_1
-						if( reg->U1BC_LEDConfigure & 0x1000 )
-						{
-							reg->U1BC_LEDConfigure &= ~0x1000;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 Off
-						}
-					}
-				}
-				else
-				{
-					// Is transmitting/receiving ??
-					if( (adapter->RxByteCount != pHwData->RxByteCountLast ) ||
-						(adapter->TxByteCount != pHwData->TxByteCountLast ) )
-					{
-						if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
-						{
-							reg->U1BC_LEDConfigure |= 0x3000;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
-						}
-
-						// Update variable
-						pHwData->RxByteCountLast = adapter->RxByteCount;
-						pHwData->TxByteCountLast = adapter->TxByteCount;
-						TimeInterval = 200;
-					}
-					else
-					{
-						// Turn On LED_1 and blinking if transmitting/receiving
-						 if( (reg->U1BC_LEDConfigure & 0x3000) != 0x1000 )
-						 {
-							 reg->U1BC_LEDConfigure &= ~0x3000;
-							 reg->U1BC_LEDConfigure |= 0x1000;
-							 Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
-						 }
-					}
-				}
-				break;
-
-			default: // Default setting. 2 LED be placed on PCB. LED_0: Link On LED_1 Active
-				if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
-				{
-					reg->U1BC_LEDConfigure |= 0x3000;// LED_1 is always on and event enable
-					Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-				}
-
-				if( pHwData->LED_Blinking )
-				{
-					// Gray blinking
-					reg->U1BC_LEDConfigure &= ~0x0f;
-					reg->U1BC_LEDConfigure |= 0x10;
-					reg->U1BC_LEDConfigure |= LEDgray[ (pHwData->LED_Blinking-1)%20 ];
-					Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-
-					pHwData->LED_Blinking += 2;
-					if( pHwData->LED_Blinking < 40 )
-						TimeInterval = 100;
-					else
-					{
-						pHwData->LED_Blinking = 0; // Stop blinking
-						reg->U1BC_LEDConfigure &= ~0x0f;
-						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-					}
-					break;
-				}
-
-				if( pHwData->LED_LinkOn )
-				{
-					if( !(reg->U1BC_LEDConfigure & 0x10) ) // Check the LED_0
-					{
-						//Try to turn ON LED_0 after gray blinking
-						reg->U1BC_LEDConfigure |= 0x10;
-						pHwData->LED_Blinking = 1; //Start blinking
-						TimeInterval = 50;
-					}
-				}
-				else
-				{
-					if( reg->U1BC_LEDConfigure & 0x10 ) // Check the LED_0
-					{
-						reg->U1BC_LEDConfigure &= ~0x10;
-						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-					}
-				}
-				break;
-		}
-
-		//20060828.1 Active send null packet to avoid AP disconnect
-		if( pHwData->LED_LinkOn )
-		{
-			pHwData->NullPacketCount += TimeInterval;
-			if( pHwData->NullPacketCount >= DEFAULT_NULL_PACKET_COUNT )
-			{
-				pHwData->NullPacketCount = 0;
-			}
-		}
-	}
-
-	pHwData->time_count += TimeInterval;
-	Wb35Tx_CurrentTime(adapter, pHwData->time_count); // 20060928 add
-	pHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(TimeInterval);
-	add_timer(&pHwData->LEDTimer);
-}
-
-u8 hal_init_hardware(struct ieee80211_hw *hw)
-{
-	struct wbsoft_priv *priv = hw->priv;
-	struct hw_data * pHwData = &priv->sHwData;
-	u16 SoftwareSet;
-
-	// Initial the variable
-	pHwData->MaxReceiveLifeTime = DEFAULT_MSDU_LIFE_TIME; // Setting Rx maximum MSDU life time
-	pHwData->FragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD; // Setting default fragment threshold
-
-	pHwData->InitialResource = 1;
-	if( Wb35Reg_initial(pHwData)) {
-		pHwData->InitialResource = 2;
-		if (Wb35Tx_initial(pHwData)) {
-			pHwData->InitialResource = 3;
-			if (Wb35Rx_initial(pHwData)) {
-				pHwData->InitialResource = 4;
-				init_timer(&pHwData->LEDTimer);
-				pHwData->LEDTimer.function = hal_led_control;
-				pHwData->LEDTimer.data = (unsigned long) priv;
-				pHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(1000);
-				add_timer(&pHwData->LEDTimer);
-
-				//
-				// For restrict to vendor's hardware
-				//
-				SoftwareSet = hal_software_set( pHwData );
-
-				#ifdef Vendor2
-				// Try to make sure the EEPROM contain
-				SoftwareSet >>= 8;
-				if( SoftwareSet != 0x82 )
-					return false;
-				#endif
-
-				Wb35Rx_start(hw);
-				Wb35Tx_EP2VM_start(priv);
-
-				return true;
-			}
-		}
-	}
-
-	pHwData->SurpriseRemove = 1;
-	return false;
-}
-
-
-void hal_halt(struct hw_data * pHwData, void *ppa_data)
-{
-	switch( pHwData->InitialResource )
-	{
-		case 4:
-		case 3: del_timer_sync(&pHwData->LEDTimer);
-			msleep(100); // Wait for Timer DPC exit 940623.2
-			Wb35Rx_destroy( pHwData ); // Release the Rx
-		case 2: Wb35Tx_destroy( pHwData ); // Release the Tx
-		case 1: Wb35Reg_destroy( pHwData ); // Release the Wb35 Regisster resources
-	}
-}
-
 //---------------------------------------------------------------------------------------------------
 void hal_set_beacon_period(  struct hw_data * pHwData,  u16 beacon_period )
 {
--- a/drivers/staging/winbond/wbhal_f.h
+++ b/drivers/staging/winbond/wbhal_f.h
@@ -21,7 +21,6 @@ void hal_clear_all_key(  struct hw_data 
 void hal_get_ethernet_address(  struct hw_data * pHwData,  u8 *current_address );
 void hal_set_ethernet_address(  struct hw_data * pHwData,  u8 *current_address );
 void hal_get_permanent_address(  struct hw_data * pHwData,  u8 *pethernet_address );
-u8 hal_init_hardware(struct ieee80211_hw *hw);
 void hal_set_power_save_mode(  struct hw_data * pHwData,  unsigned char power_save,  unsigned char wakeup,  unsigned char dtim );
 void hal_get_power_save_mode(  struct hw_data * pHwData,   u8 *pin_pwr_save );
 void hal_set_slot_time(  struct hw_data * pHwData,  u8 type );
@@ -42,7 +41,6 @@ void hal_set_accept_broadcast(  struct h
 void hal_set_accept_multicast(  struct hw_data * pHwData,  u8 enable );
 void hal_set_accept_beacon(  struct hw_data * pHwData,  u8 enable );
 void hal_stop(  struct hw_data * pHwData );
-void hal_halt(  struct hw_data * pHwData, void *ppa_data );
 void hal_start_tx0(  struct hw_data * pHwData );
 void hal_set_phy_type(  struct hw_data * pHwData,  u8 PhyType );
 #define hal_get_cwmin( _A ) ( (_A)->cwmin )
--- a/drivers/staging/winbond/wbusb.c
+++ b/drivers/staging/winbond/wbusb.c
@@ -178,6 +178,351 @@ static const struct ieee80211_ops wbsoft
 // conf_tx: hal_set_cwmin()/hal_set_cwmax;
 };
 
+static void hal_halt(struct hw_data *pHwData, void *ppa_data)
+{
+	switch( pHwData->InitialResource )
+	{
+		case 4:
+		case 3: del_timer_sync(&pHwData->LEDTimer);
+			msleep(100); // Wait for Timer DPC exit 940623.2
+			Wb35Rx_destroy( pHwData ); // Release the Rx
+		case 2: Wb35Tx_destroy( pHwData ); // Release the Tx
+		case 1: Wb35Reg_destroy( pHwData ); // Release the Wb35 Regisster resources
+	}
+}
+
+static void hal_led_control(unsigned long data)
+{
+	struct wbsoft_priv *adapter = (struct wbsoft_priv *) data;
+	struct hw_data * pHwData = &adapter->sHwData;
+	struct wb35_reg *reg = &pHwData->reg;
+	u32	LEDSet = (pHwData->SoftwareSet & HAL_LED_SET_MASK) >> HAL_LED_SET_SHIFT;
+	u8	LEDgray[20] = { 0,3,4,6,8,10,11,12,13,14,15,14,13,12,11,10,8,6,4,2 };
+	u8	LEDgray2[30] = { 7,8,9,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,13,12,11,10,9,8 };
+	u32	TimeInterval = 500, ltmp, ltmp2;
+        ltmp=0;
+
+	if( pHwData->SurpriseRemove ) return;
+
+	if( pHwData->LED_control ) {
+		ltmp2 = pHwData->LED_control & 0xff;
+		if( ltmp2 == 5 ) // 5 is WPS mode
+		{
+			TimeInterval = 100;
+			ltmp2 = (pHwData->LED_control>>8) & 0xff;
+			switch( ltmp2 )
+			{
+				case 1: // [0.2 On][0.1 Off]...
+					pHwData->LED_Blinking %= 3;
+					ltmp = 0x1010; // Led 1 & 0 Green and Red
+					if( pHwData->LED_Blinking == 2 ) // Turn off
+						ltmp = 0;
+					break;
+				case 2: // [0.1 On][0.1 Off]...
+					pHwData->LED_Blinking %= 2;
+					ltmp = 0x0010; // Led 0 red color
+					if( pHwData->LED_Blinking ) // Turn off
+						ltmp = 0;
+					break;
+				case 3: // [0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.5 Off]...
+					pHwData->LED_Blinking %= 15;
+					ltmp = 0x0010; // Led 0 red color
+					if( (pHwData->LED_Blinking >= 9) || (pHwData->LED_Blinking%2) ) // Turn off 0.6 sec
+						ltmp = 0;
+					break;
+				case 4: // [300 On][ off ]
+					ltmp = 0x1000; // Led 1 Green color
+					if( pHwData->LED_Blinking >= 3000 )
+						ltmp = 0; // led maybe on after 300sec * 32bit counter overlap.
+					break;
+			}
+			pHwData->LED_Blinking++;
+
+			reg->U1BC_LEDConfigure = ltmp;
+			if( LEDSet != 7 ) // Only 111 mode has 2 LEDs on PCB.
+			{
+				reg->U1BC_LEDConfigure |= (ltmp &0xff)<<8; // Copy LED result to each LED control register
+				reg->U1BC_LEDConfigure |= (ltmp &0xff00)>>8;
+			}
+			Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+		}
+	}
+	else if( pHwData->CurrentRadioSw || pHwData->CurrentRadioHw ) // If radio off
+	{
+		if( reg->U1BC_LEDConfigure & 0x1010 )
+		{
+			reg->U1BC_LEDConfigure &= ~0x1010;
+			Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+		}
+	}
+	else
+	{
+		switch( LEDSet )
+		{
+			case 4: // [100] Only 1 Led be placed on PCB and use pin 21 of IC. Use LED_0 for showing
+				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
+				{
+					// Blinking if scanning is on progress
+					if( pHwData->LED_Scanning )
+					{
+						if( pHwData->LED_Blinking == 0 )
+						{
+							reg->U1BC_LEDConfigure |= 0x10;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 On
+							pHwData->LED_Blinking = 1;
+							TimeInterval = 300;
+						}
+						else
+						{
+							reg->U1BC_LEDConfigure &= ~0x10;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+							pHwData->LED_Blinking = 0;
+							TimeInterval = 300;
+						}
+					}
+					else
+					{
+						//Turn Off LED_0
+						if( reg->U1BC_LEDConfigure & 0x10 )
+						{
+							reg->U1BC_LEDConfigure &= ~0x10;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+						}
+					}
+				}
+				else
+				{
+					// Turn On LED_0
+					if( (reg->U1BC_LEDConfigure & 0x10) == 0 )
+					{
+						reg->U1BC_LEDConfigure |= 0x10;
+						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+					}
+				}
+				break;
+
+			case 6: // [110] Only 1 Led be placed on PCB and use pin 21 of IC. Use LED_0 for showing
+				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
+				{
+					// Blinking if scanning is on progress
+					if( pHwData->LED_Scanning )
+					{
+						if( pHwData->LED_Blinking == 0 )
+						{
+							reg->U1BC_LEDConfigure &= ~0xf;
+							reg->U1BC_LEDConfigure |= 0x10;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 On
+							pHwData->LED_Blinking = 1;
+							TimeInterval = 300;
+						}
+						else
+						{
+							reg->U1BC_LEDConfigure &= ~0x1f;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+							pHwData->LED_Blinking = 0;
+							TimeInterval = 300;
+						}
+					}
+					else
+					{
+						// 20060901 Gray blinking if in disconnect state and not scanning
+						ltmp = reg->U1BC_LEDConfigure;
+						reg->U1BC_LEDConfigure &= ~0x1f;
+						if( LEDgray2[(pHwData->LED_Blinking%30)] )
+						{
+							reg->U1BC_LEDConfigure |= 0x10;
+							reg->U1BC_LEDConfigure |= LEDgray2[ (pHwData->LED_Blinking%30) ];
+						}
+						pHwData->LED_Blinking++;
+						if( reg->U1BC_LEDConfigure != ltmp )
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+						TimeInterval = 100;
+					}
+				}
+				else
+				{
+					// Turn On LED_0
+					if( (reg->U1BC_LEDConfigure & 0x10) == 0 )
+					{
+						reg->U1BC_LEDConfigure |= 0x10;
+						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+					}
+				}
+				break;
+
+			case 5: // [101] Only 1 Led be placed on PCB and use LED_1 for showing
+				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
+				{
+					// Blinking if scanning is on progress
+					if( pHwData->LED_Scanning )
+					{
+						if( pHwData->LED_Blinking == 0 )
+						{
+							reg->U1BC_LEDConfigure |= 0x1000;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
+							pHwData->LED_Blinking = 1;
+							TimeInterval = 300;
+						}
+						else
+						{
+							reg->U1BC_LEDConfigure &= ~0x1000;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 Off
+							pHwData->LED_Blinking = 0;
+							TimeInterval = 300;
+						}
+					}
+					else
+					{
+						//Turn Off LED_1
+						if( reg->U1BC_LEDConfigure & 0x1000 )
+						{
+							reg->U1BC_LEDConfigure &= ~0x1000;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 Off
+						}
+					}
+				}
+				else
+				{
+					// Is transmitting/receiving ??
+					if( (adapter->RxByteCount != pHwData->RxByteCountLast ) ||
+						(adapter->TxByteCount != pHwData->TxByteCountLast ) )
+					{
+						if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
+						{
+							reg->U1BC_LEDConfigure |= 0x3000;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
+						}
+
+						// Update variable
+						pHwData->RxByteCountLast = adapter->RxByteCount;
+						pHwData->TxByteCountLast = adapter->TxByteCount;
+						TimeInterval = 200;
+					}
+					else
+					{
+						// Turn On LED_1 and blinking if transmitting/receiving
+						 if( (reg->U1BC_LEDConfigure & 0x3000) != 0x1000 )
+						 {
+							 reg->U1BC_LEDConfigure &= ~0x3000;
+							 reg->U1BC_LEDConfigure |= 0x1000;
+							 Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
+						 }
+					}
+				}
+				break;
+
+			default: // Default setting. 2 LED be placed on PCB. LED_0: Link On LED_1 Active
+				if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
+				{
+					reg->U1BC_LEDConfigure |= 0x3000;// LED_1 is always on and event enable
+					Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+				}
+
+				if( pHwData->LED_Blinking )
+				{
+					// Gray blinking
+					reg->U1BC_LEDConfigure &= ~0x0f;
+					reg->U1BC_LEDConfigure |= 0x10;
+					reg->U1BC_LEDConfigure |= LEDgray[ (pHwData->LED_Blinking-1)%20 ];
+					Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+
+					pHwData->LED_Blinking += 2;
+					if( pHwData->LED_Blinking < 40 )
+						TimeInterval = 100;
+					else
+					{
+						pHwData->LED_Blinking = 0; // Stop blinking
+						reg->U1BC_LEDConfigure &= ~0x0f;
+						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+					}
+					break;
+				}
+
+				if( pHwData->LED_LinkOn )
+				{
+					if( !(reg->U1BC_LEDConfigure & 0x10) ) // Check the LED_0
+					{
+						//Try to turn ON LED_0 after gray blinking
+						reg->U1BC_LEDConfigure |= 0x10;
+						pHwData->LED_Blinking = 1; //Start blinking
+						TimeInterval = 50;
+					}
+				}
+				else
+				{
+					if( reg->U1BC_LEDConfigure & 0x10 ) // Check the LED_0
+					{
+						reg->U1BC_LEDConfigure &= ~0x10;
+						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+					}
+				}
+				break;
+		}
+
+		//20060828.1 Active send null packet to avoid AP disconnect
+		if( pHwData->LED_LinkOn )
+		{
+			pHwData->NullPacketCount += TimeInterval;
+			if( pHwData->NullPacketCount >= DEFAULT_NULL_PACKET_COUNT )
+			{
+				pHwData->NullPacketCount = 0;
+			}
+		}
+	}
+
+	pHwData->time_count += TimeInterval;
+	Wb35Tx_CurrentTime(adapter, pHwData->time_count); // 20060928 add
+	pHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(TimeInterval);
+	add_timer(&pHwData->LEDTimer);
+}
+
+static u8 hal_init_hardware(struct ieee80211_hw *hw)
+{
+	struct wbsoft_priv *priv = hw->priv;
+	struct hw_data * pHwData = &priv->sHwData;
+	u16 SoftwareSet;
+
+	// Initial the variable
+	pHwData->MaxReceiveLifeTime = DEFAULT_MSDU_LIFE_TIME; // Setting Rx maximum MSDU life time
+	pHwData->FragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD; // Setting default fragment threshold
+
+	pHwData->InitialResource = 1;
+	if( Wb35Reg_initial(pHwData)) {
+		pHwData->InitialResource = 2;
+		if (Wb35Tx_initial(pHwData)) {
+			pHwData->InitialResource = 3;
+			if (Wb35Rx_initial(pHwData)) {
+				pHwData->InitialResource = 4;
+				init_timer(&pHwData->LEDTimer);
+				pHwData->LEDTimer.function = hal_led_control;
+				pHwData->LEDTimer.data = (unsigned long) priv;
+				pHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(1000);
+				add_timer(&pHwData->LEDTimer);
+
+				//
+				// For restrict to vendor's hardware
+				//
+				SoftwareSet = hal_software_set( pHwData );
+
+				#ifdef Vendor2
+				// Try to make sure the EEPROM contain
+				SoftwareSet >>= 8;
+				if( SoftwareSet != 0x82 )
+					return false;
+				#endif
+
+				Wb35Rx_start(hw);
+				Wb35Tx_EP2VM_start(priv);
+
+				return true;
+			}
+		}
+	}
+
+	pHwData->SurpriseRemove = 1;
+	return false;
+}
+
 static int wb35_hw_init(struct ieee80211_hw *hw)
 {
 	struct wbsoft_priv *priv = hw->priv;
