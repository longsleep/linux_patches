From bzolnier@gmail.com  Tue Aug 25 22:24:57 2009
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Sun, 23 Aug 2009 15:32:06 +0200
Subject: Staging: rtxx70: merge rt3070 with rt2870
To: "Greg Kroah-Hartman" <gregkh@suse.de>
Cc: devel@driverdev.osuosl.org, Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>, Marcin Slusarz <marcin.slusarz@gmail.com>, Mike Galbraith <efault@gmx.de>, linux-kernel@vger.kernel.org
Message-ID: <20090823133206.17784.9987.sendpatchset@localhost.localdomain>


From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

* remove RT30xx ifdefs
* add -DRT3070 to rt2870's EXTRA_CFLAGS
* because of changes in the way that hardware is initialized/accessed
  rt3070 driver's firmware should be now also used by rt2870 driver
  (this is also done by newer out-of-tree vendor driver versions, i.e.
  2.1.0.0, historically in-kernel driver was based on 1.4.0.0 version)
* change RT28xx_CHIP_NAME to RTxx70
* update rt2870's help entry text
* add MODULE_ALIAS("rt3070sta") to rt2870
* update rt3070's dependencies

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2860/common/cmm_info.c      |   11 ---
 drivers/staging/rt2860/common/mlme.c          |   30 ++-------
 drivers/staging/rt2860/common/rtmp_init.c     |   81 +++++---------------------
 drivers/staging/rt2860/rt_main_dev.c          |    2 
 drivers/staging/rt2860/rtmp.h                 |    4 -
 drivers/staging/rt2870/2870_main_dev.c        |   23 -------
 drivers/staging/rt2870/Kconfig                |    5 -
 drivers/staging/rt2870/Makefile               |    2 
 drivers/staging/rt2870/common/cmm_data_2870.c |   30 ---------
 drivers/staging/rt2870/common/rtusb_io.c      |    2 
 drivers/staging/rt2870/rt2870.h               |    9 --
 drivers/staging/rt3070/Kconfig                |    2 
 12 files changed, 33 insertions(+), 168 deletions(-)

--- a/drivers/staging/rt2860/common/cmm_info.c
+++ b/drivers/staging/rt2860/common/cmm_info.c
@@ -1419,17 +1419,6 @@ VOID	RTMPSetHT(
 		pAd->CommonCfg.DesiredHtPhy.RxSTBC = 0;
 	}
 
-#ifndef RT30xx
-#ifdef RT2870
-	/* Frank recommend ,If not, Tx maybe block in high power. Rx has no problem*/
-	if(IS_RT3070(pAd) && ((pAd->RfIcType == RFIC_3020) || (pAd->RfIcType == RFIC_2020)))
-	{
-		pAd->CommonCfg.HtCapability.HtCapInfo.TxSTBC = 0;
-		pAd->CommonCfg.DesiredHtPhy.TxSTBC = 0;
-	}
-#endif // RT2870 //
-#endif
-
 	if(pHTPhyMode->SHORTGI == GI_400)
 	{
 		pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor20 = 1;
--- a/drivers/staging/rt2860/common/mlme.c
+++ b/drivers/staging/rt2860/common/mlme.c
@@ -5565,8 +5565,7 @@ VOID 	AsicUpdateProtect(
 	}
 }
 
-#ifdef RT30xx
-// add by johnli, RF power sequence setup
+#ifdef RT2870
 /*
 	==========================================================================
 	Description:
@@ -5721,8 +5720,7 @@ VOID RT30xxReverseRFSleepModeSetup(
 		RTMP_IO_WRITE32(pAd, LDO_CFG0, MACValue);
 	}
 }
-// end johnli
-#endif // RT30xx //
+#endif
 
 /*
 	==========================================================================
@@ -5764,9 +5762,7 @@ VOID AsicSwitchChannel(
 #ifdef RT2870
 	// The RF programming sequence is difference between 3xxx and 2xxx
 	if ((IS_RT3070(pAd) || IS_RT3090(pAd)) && (
-#ifdef RT30xx
 	     (pAd->RfIcType == RFIC_3022) || (pAd->RfIcType == RFIC_3021) ||
-#endif
 	     (pAd->RfIcType == RFIC_3020) || (pAd->RfIcType == RFIC_2020)))
 	{
 		/* modify by WY for Read RF Reg. error */
@@ -5789,7 +5785,6 @@ VOID AsicSwitchChannel(
 				RFValue = (RFValue & 0xE0) | TxPwer;
 				RT30xxWriteRFRegister(pAd, RF_R12, RFValue);
 
-#ifdef RT30xx
 				// Set Tx1 Power
 				RT30xxReadRFRegister(pAd, RF_R13, &RFValue);
 				RFValue = (RFValue & 0xE0) | TxPwer2;
@@ -5809,7 +5804,6 @@ VOID AsicSwitchChannel(
 				else if (pAd->Antenna.field.RxPath == 2)
 					RFValue |= 0x40;
 				RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
-#endif
 
 				// Set RF offset
 				RT30xxReadRFRegister(pAd, RF_R23, &RFValue);
@@ -5827,9 +5821,8 @@ VOID AsicSwitchChannel(
 					RFValue = pAd->Mlme.CaliBW20RfR24;
 				}
 				RT30xxWriteRFRegister(pAd, RF_R24, RFValue);
-#ifdef RT30xx
 				RT30xxWriteRFRegister(pAd, RF_R31, RFValue);
-#endif
+
 				// Enable RF tuning
 				RT30xxReadRFRegister(pAd, RF_R07, &RFValue);
 				RFValue = RFValue | 0x1;
@@ -5838,7 +5831,6 @@ VOID AsicSwitchChannel(
 				// latch channel for future usage.
 				pAd->LatchRfRegs.Channel = Channel;
 
-#ifdef RT30xx
 				DBGPRINT(RT_DEBUG_TRACE, ("SwitchChannel#%d(RF=%d, Pwr0=%d, Pwr1=%d, %dT), N=0x%02X, K=0x%02X, R=0x%02X\n",
 					Channel,
 					pAd->RfIcType,
@@ -5848,8 +5840,6 @@ VOID AsicSwitchChannel(
 					FreqItems3020[index].N,
 					FreqItems3020[index].K,
 					FreqItems3020[index].R));
-#endif
-
 				break;
 			}
 		}
@@ -6828,13 +6818,13 @@ VOID AsicSetEdcaParm(
 				Ac2Cfg.field.AcTxop = 5;
 			}
 
-#ifdef RT30xx
+#ifdef RT2870
 			if (pAd->RfIcType == RFIC_3020 || pAd->RfIcType == RFIC_2020)
 			{
 				// Tuning for WiFi WMM S3-T07: connexant legacy sta ==> broadcom 11n sta.
 				Ac2Cfg.field.Aifsn = 5;
 			}
-#endif // RT30xx //
+#endif
 		}
 
 		Ac3Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_VO];
@@ -6915,11 +6905,10 @@ VOID AsicSetEdcaParm(
 		}
 
 		AifsnCsr.field.Aifsn3 = Ac3Cfg.field.Aifsn - 1; //pEdcaParm->Aifsn[QID_AC_VO]; //for TGn wifi test
-#ifdef RT30xx
+#ifdef RT2870
 		if (pAd->RfIcType == RFIC_3020 || pAd->RfIcType == RFIC_2020)
 			AifsnCsr.field.Aifsn2 = 0x2; //pEdcaParm->Aifsn[QID_AC_VI]; //for WiFi WMM S4-T04.
-#endif // RT30xx //
-
+#endif
 		RTMP_IO_WRITE32(pAd, WMM_AIFSN_CFG, AifsnCsr.word);
 
 		NdisMoveMemory(&pAd->CommonCfg.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
@@ -8493,12 +8482,7 @@ VOID AsicStaBbpTuning(
 #ifdef RT2870
 			// RT3070 is a no LNA solution, it should have different control regarding to AGC gain control
 			// Otherwise, it will have some throughput side effect when low RSSI
-#ifndef RT30xx
-			if (IS_RT3070(pAd))
-#endif
-#ifdef RT30xx
 			if (IS_RT30xx(pAd))
-#endif
 			{
 				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)
 				{
--- a/drivers/staging/rt2860/common/rtmp_init.c
+++ b/drivers/staging/rt2860/common/rtmp_init.c
@@ -38,16 +38,12 @@
     Jan Lee  2006-09-15    RT2860. Change for 802.11n , EEPROM, Led, BA, HT.
 */
 #include "../rt_config.h"
-#ifndef RT30xx
 #ifdef RT2860
 #include "firmware.h"
 #include <linux/bitrev.h>
 #endif
 #ifdef RT2870
-#include "../../rt2870/common/firmware.h"
-#endif
-#endif
-#ifdef RT30xx
+/* New firmware handles both RT2870 and RT3070. */
 #include "../../rt3070/firmware.h"
 #endif
 
@@ -147,12 +143,7 @@ REG_PAIR   RT30xx_RFRegTable[] = {
         {RF_R06,          0x02},
         {RF_R07,          0x70},
         {RF_R09,          0x0F},
-#ifndef RT30xx
-        {RF_R10,          0x71},
-#endif
-#ifdef RT30xx
         {RF_R10,          0x41},
-#endif
         {RF_R11,          0x21},
         {RF_R12,          0x7B},
         {RF_R14,          0x90},
@@ -165,9 +156,6 @@ REG_PAIR   RT30xx_RFRegTable[] = {
         {RF_R21,          0xDB},
         {RF_R24,          0x16},
         {RF_R25,          0x01},
-#ifndef RT30xx
-        {RF_R27,          0x03},
-#endif
         {RF_R29,          0x1F},
 };
 #define	NUM_RF_REG_PARMS	(sizeof(RT30xx_RFRegTable) / sizeof(REG_PAIR))
@@ -1107,7 +1095,7 @@ VOID RTMPFilterCalibration(
 	UCHAR	RF_R24_Value = 0;
 
 	// Give bbp filter initial value
-#ifndef RT30xx
+#ifndef RT2870
 	pAd->Mlme.CaliBW20RfR24 = 0x16;
 	pAd->Mlme.CaliBW40RfR24 = 0x36;  //Bit[5] must be 1 for BW 40
 #else
@@ -1131,7 +1119,7 @@ VOID RTMPFilterCalibration(
 			BBPValue&= (~0x18);
 			BBPValue|= (0x10);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-#ifdef RT30xx
+#ifdef RT2870
 			// set to BW40
 			RT30xxReadRFRegister(pAd, RF_R31, &value);
 			value |= 0x20;
@@ -1147,7 +1135,7 @@ VOID RTMPFilterCalibration(
 				FilterTarget = 0x13;
 			else
 				FilterTarget = 0x16;
-#ifdef RT30xx
+#ifdef RT2870
 			// set to BW20
 			RT30xxReadRFRegister(pAd, RF_R31, &value);
 			value &= (~0x20);
@@ -1263,20 +1251,13 @@ VOID NICInitRT30xxRFRegisters(IN PRTMP_A
 	INT i;
 	// Driver must read EEPROM to get RfIcType before initial RF registers
 	// Initialize RF register to default value
-	if (IS_RT3070(pAd)
-#ifdef RT30xx
-	    || IS_RT3071(pAd)
-#else
-	    && (pAd->RfIcType == RFIC_3020 || pAd->RfIcType == RFIC_2020)
-#endif
-	   )
+	if (IS_RT3070(pAd) || IS_RT3071(pAd))
 	{
 		// Init RF calibration
 		// Driver should toggle RF R30 bit7 before init RF registers
 		UINT32 RfReg = 0;
-#ifdef RT30xx
 		UINT32 data;
-#endif
+
 		RT30xxReadRFRegister(pAd, RF_R30, (PUCHAR)&RfReg);
 		RfReg |= 0x80;
 		RT30xxWriteRFRegister(pAd, RF_R30, (UCHAR)RfReg);
@@ -1290,7 +1271,6 @@ VOID NICInitRT30xxRFRegisters(IN PRTMP_A
 			RT30xxWriteRFRegister(pAd, RT30xx_RFRegTable[i].Register, RT30xx_RFRegTable[i].Value);
 		}
 
-#ifdef RT30xx
 		if (IS_RT3070(pAd))
 		{
 			//  Update MAC 0x05D4 from 01xxxxxx to 0Dxxxxxx (voltage 1.2V to 1.35V) for RT3070 to improve yield rate
@@ -1328,10 +1308,10 @@ VOID NICInitRT30xxRFRegisters(IN PRTMP_A
 			data &= ~(0x20);
 			RTUSBWriteMACRegister(pAd, GPIO_SWITCH, data);
 		}
-#endif
+
 		//For RF filter Calibration
 		RTMPFilterCalibration(pAd);
-#ifdef RT30xx
+
 		// Initialize RF R27 register, set RF R27 must be behind RTMPFilterCalibration()
 		if ((pAd->MACVersion & 0xffff) < 0x0211)
 			RT30xxWriteRFRegister(pAd, RF_R27, 0x3);
@@ -1346,7 +1326,6 @@ VOID NICInitRT30xxRFRegisters(IN PRTMP_A
 			// add by johnli, RF power sequence setup, load RF normal operation-mode setup
 			RT30xxLoadRFNormalModeSetup(pAd);
 		}
-#endif
 	}
 }
 #endif // RT2870 //
@@ -1567,9 +1546,6 @@ VOID	NICReadEEPROMParameters(
 	NicConfig2.word = pAd->EEPROMDefaultValue[1];
 
 	{
-#ifndef RT30xx
-		NicConfig2.word = 0;
-#endif
 		if ((NicConfig2.word & 0x00ff) == 0xff)
 		{
 			NicConfig2.word &= 0xff00;
@@ -1806,10 +1782,9 @@ VOID	NICInitAsicFromEEPROM(
 		}
 	}
 
-#ifndef RT30xx
+#ifndef RT2870
 	Antenna.word = pAd->Antenna.word;
-#endif
-#ifdef RT30xx
+#else
 	Antenna.word = pAd->EEPROMDefaultValue[0];
 	if (Antenna.word == 0xFFFF)
 	{
@@ -1820,7 +1795,7 @@ VOID	NICInitAsicFromEEPROM(
 	pAd->Mlme.RealRxPath = (UCHAR) Antenna.field.RxPath;
 	pAd->RfIcType = (UCHAR) Antenna.field.RfIcType;
 
-#ifdef RT30xx
+#ifdef RT2870
 	DBGPRINT(RT_DEBUG_WARN, ("pAd->RfIcType = %d, RealRxPath=%d, TxPath = %d\n", pAd->RfIcType, pAd->Mlme.RealRxPath,Antenna.field.TxPath));
 
 	// Save the antenna for future use
@@ -1828,7 +1803,7 @@ VOID	NICInitAsicFromEEPROM(
 #endif
 	NicConfig2.word = pAd->EEPROMDefaultValue[1];
 
-#ifdef RT30xx
+#ifdef RT2870
 	{
 		if ((NicConfig2.word & 0x00ff) == 0xff)
 		{
@@ -1844,7 +1819,7 @@ VOID	NICInitAsicFromEEPROM(
 	// Save the antenna for future use
 	pAd->NicConfig2.word = NicConfig2.word;
 
-#ifdef RT30xx
+#ifdef RT2870
 	// set default antenna as main
 	if (pAd->RfIcType == RFIC_3020)
 		AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt);
@@ -2251,21 +2226,8 @@ NDIS_STATUS	NICInitializeAsic(
 #endif // RT3070 //
 		RTMP_IO_WRITE32(pAd, (USHORT)MACRegTable[Index].Register, MACRegTable[Index].Value);
 	}
-
-#ifndef RT30xx
-	if(IS_RT3070(pAd))
-	{
-		// According to Frank Hsu (from Gary Tsao)
-		RTMP_IO_WRITE32(pAd, (USHORT)TX_SW_CFG0, 0x00000400);
-
-		// Initialize RT3070 serial MAC registers which is different from RT2870 serial
-		RTUSBWriteMACRegister(pAd, TX_SW_CFG1, 0);
-		RTUSBWriteMACRegister(pAd, TX_SW_CFG2, 0);
-	}
-#endif
 #endif // RT2870 //
 
-
 	{
 		for (Index = 0; Index < NUM_STA_MAC_REG_PARMS; Index++)
 		{
@@ -2300,7 +2262,7 @@ NDIS_STATUS	NICInitializeAsic(
 			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x0);
 		}
 	}
-#ifdef RT30xx
+#ifdef RT2870
 	else if (IS_RT3070(pAd))
 	{
 		RTMP_IO_WRITE32(pAd, TX_SW_CFG1, 0);
@@ -2347,22 +2309,11 @@ NDIS_STATUS	NICInitializeAsic(
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBPRegTable[Index].Register, BBPRegTable[Index].Value);
 	}
 
-#ifndef RT30xx
+#ifndef RT2870
 	// for rt2860E and after, init BBP_R84 with 0x19. This is for extension channel overlapping IOT.
 	if ((pAd->MACVersion&0xffff) != 0x0101)
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R84, 0x19);
-
-#ifdef RT2870
-	//write RT3070 BBP wchich different with 2870 after write RT2870 BBP
-	if (IS_RT3070(pAd))
-	{
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R70, 0x0a);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R84, 0x99);
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R105, 0x05);
-	}
-#endif // RT2870 //
-#endif
-#ifdef RT30xx
+#else
 	// for rt2860E and after, init BBP_R84 with 0x19. This is for extension channel overlapping IOT.
 	// RT3090 should not program BBP R84 to 0x19, otherwise TX will block.
 	if (((pAd->MACVersion&0xffff) != 0x0101) && (!IS_RT30xx(pAd)))
--- a/drivers/staging/rt2860/rt_main_dev.c
+++ b/drivers/staging/rt2860/rt_main_dev.c
@@ -522,7 +522,7 @@ static int rt28xx_init(IN struct net_dev
 	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
 	AsicLockChannel(pAd, pAd->CommonCfg.Channel);
 
-#ifndef RT30xx
+#ifndef RT2870
 	// 8051 firmware require the signal during booting time.
 	AsicSendCommandToMcu(pAd, 0x72, 0xFF, 0x00, 0x00);
 #endif
--- a/drivers/staging/rt2860/rtmp.h
+++ b/drivers/staging/rt2860/rtmp.h
@@ -391,14 +391,14 @@ typedef struct  _QUEUE_HEADER   {
     (_idx) = (_idx+1) % (_RingSize);       \
 }
 
-#ifdef RT30xx
+#ifdef RT2870
 // We will have a cost down version which mac version is 0x3090xxxx
 #define IS_RT3090(_pAd)				((((_pAd)->MACVersion & 0xffff0000) == 0x30710000) || (((_pAd)->MACVersion & 0xffff0000) == 0x30900000))
 #else
 #define IS_RT3090(_pAd)				0
 #endif
 #define IS_RT3070(_pAd)				(((_pAd)->MACVersion & 0xffff0000) == 0x30700000)
-#ifdef RT30xx
+#ifdef RT2870
 #define IS_RT3071(_pAd)				(((_pAd)->MACVersion & 0xffff0000) == 0x30710000)
 #define IS_RT30xx(_pAd)				(((_pAd)->MACVersion & 0xfff00000) == 0x30700000)
 #endif
--- a/drivers/staging/rt2870/2870_main_dev.c
+++ b/drivers/staging/rt2870/2870_main_dev.c
@@ -50,6 +50,7 @@ MODULE_LICENSE("GPL");
 #ifdef MODULE_VERSION
 MODULE_VERSION(STA_DRIVER_VERSION);
 #endif
+MODULE_ALIAS("rt3070sta");
 
 /* Kernel thread and vars, which handles packets that are completed. Only
  * packets that have a "complete" function are sent here. This way, the
@@ -65,19 +66,15 @@ struct usb_device_id rtusb_usb_id[] = {
 	{ USB_DEVICE(0x1737, 0x0070) }, /* Linksys */
 	{ USB_DEVICE(0x148F, 0x2870) }, /* Ralink */
 	{ USB_DEVICE(0x148F, 0x3070) }, /* Ralink 3070 */
-#ifdef RT30xx
 	{ USB_DEVICE(0x148F, 0x3071) }, /* Ralink 3071 */
 	{ USB_DEVICE(0x148F, 0x3072) }, /* Ralink 3072 */
-#endif
 	{ USB_DEVICE(0x0B05, 0x1731) }, /* Asus */
 	{ USB_DEVICE(0x0B05, 0x1732) }, /* Asus */
 	{ USB_DEVICE(0x0B05, 0x1742) }, /* Asus */
 	{ USB_DEVICE(0x0DF6, 0x0017) }, /* Sitecom */
 	{ USB_DEVICE(0x0DF6, 0x002B) }, /* Sitecom */
 	{ USB_DEVICE(0x0DF6, 0x002C) }, /* Sitecom */
-#ifdef RT30xx
 	{ USB_DEVICE(0x0DF6, 0x003E) }, /* Sitecom 3070 */
-#endif
 	{ USB_DEVICE(0x0DF6, 0x002D) }, /* Sitecom */
 	{ USB_DEVICE(0x0DF6, 0x0039) }, /* Sitecom 2770 */
 	{ USB_DEVICE(0x0DF6, 0x003F) }, /* Sitecom WL-608 */
@@ -88,10 +85,8 @@ struct usb_device_id rtusb_usb_id[] = {
 	{ USB_DEVICE(0x2019, 0xAB25) }, /* Planex Communications, Inc. RT3070 */
 	{ USB_DEVICE(0x07D1, 0x3C09) }, /* D-Link */
 	{ USB_DEVICE(0x07D1, 0x3C11) }, /* D-Link */
-#ifdef RT30xx
 	{ USB_DEVICE(0x2001, 0x3C09) }, /* D-Link */
 	{ USB_DEVICE(0x2001, 0x3C0A) }, /* D-Link 3072*/
-#endif
 	{ USB_DEVICE(0x14B2, 0x3C07) }, /* AL */
 	{ USB_DEVICE(0x14B2, 0x3C12) }, /* AL 3070 */
 	{ USB_DEVICE(0x050D, 0x8053) }, /* Belkin */
@@ -104,34 +99,24 @@ struct usb_device_id rtusb_usb_id[] = {
 	{ USB_DEVICE(0x07AA, 0x003F) }, /* Corega */
 	{ USB_DEVICE(0x18C5, 0x0012) }, /* Corega 3070 */
 	{ USB_DEVICE(0x1044, 0x800B) }, /* Gigabyte */
-#ifdef RT30xx
 	{ USB_DEVICE(0x1044, 0x800D) }, /* Gigabyte GN-WB32L 3070 */
-#endif
 	{ USB_DEVICE(0x15A9, 0x0006) }, /* Sparklan */
 	{ USB_DEVICE(0x083A, 0xB522) }, /* SMC */
 	{ USB_DEVICE(0x083A, 0xA618) }, /* SMC */
-#ifdef RT30xx
 	{ USB_DEVICE(0x083A, 0x8522) }, /* Arcadyan */
 	{ USB_DEVICE(0x083A, 0x7512) }, /* Arcadyan 2770 */
-#endif
 	{ USB_DEVICE(0x083A, 0x7522) }, /* Arcadyan */
-#ifdef RT30xx
 	{ USB_DEVICE(0x083A, 0x7511) }, /* Arcadyan 3070 */
-#endif
 	{ USB_DEVICE(0x0CDE, 0x0022) }, /* ZCOM */
 	{ USB_DEVICE(0x0586, 0x3416) }, /* Zyxel */
 	{ USB_DEVICE(0x0CDE, 0x0025) }, /* Zyxel */
 	{ USB_DEVICE(0x1740, 0x9701) }, /* EnGenius */
 	{ USB_DEVICE(0x1740, 0x9702) }, /* EnGenius */
-#ifdef RT30xx
 	{ USB_DEVICE(0x1740, 0x9703) }, /* EnGenius 3070 */
-#endif
 	{ USB_DEVICE(0x0471, 0x200f) }, /* Philips */
 	{ USB_DEVICE(0x14B2, 0x3C25) }, /* Draytek */
 	{ USB_DEVICE(0x13D3, 0x3247) }, /* AzureWave */
-#ifdef RT30xx
 	{ USB_DEVICE(0x13D3, 0x3273) }, /* AzureWave 3070*/
-#endif
 	{ USB_DEVICE(0x083A, 0x6618) }, /* Accton */
 	{ USB_DEVICE(0x15c5, 0x0008) }, /* Amit */
 	{ USB_DEVICE(0x0E66, 0x0001) }, /* Hawking */
@@ -146,23 +131,17 @@ struct usb_device_id rtusb_usb_id[] = {
 	{ USB_DEVICE(0x07B8, 0x3071) }, /* AboCom 3071 */
 	{ USB_DEVICE(0x07B8, 0x2870) }, /* AboCom */
 	{ USB_DEVICE(0x07B8, 0x2770) }, /* AboCom */
-#ifdef RT30xx
 	{ USB_DEVICE(0x07B8, 0x3072) }, /* Abocom 3072 */
-#endif
 	{ USB_DEVICE(0x7392, 0x7711) }, /* Edimax 3070 */
 	{ USB_DEVICE(0x5A57, 0x0280) }, /* Zinwell */
 	{ USB_DEVICE(0x5A57, 0x0282) }, /* Zinwell */
-#ifdef RT30xx
 	{ USB_DEVICE(0x1A32, 0x0304) }, /* Quanta 3070 */
-#endif
 	{ USB_DEVICE(0x0789, 0x0162) }, /* Logitec 2870 */
 	{ USB_DEVICE(0x0789, 0x0163) }, /* Logitec 2870 */
 	{ USB_DEVICE(0x0789, 0x0164) }, /* Logitec 2870 */
 	{ USB_DEVICE(0x7392, 0x7717) }, /* Edimax */
-#ifdef RT30xx
 	{ USB_DEVICE(0x1EDA, 0x2310) }, /* AirTies 3070 */
 	{ USB_DEVICE(0x1737, 0x0077) }, /* Linksys WUSB54GC-EU v3 */
-#endif
 	{ } /* Terminating entry */
 };
 
--- a/drivers/staging/rt2870/common/cmm_data_2870.c
+++ b/drivers/staging/rt2870/common/cmm_data_2870.c
@@ -810,12 +810,7 @@ VOID RT28xxUsbStaAsicForceWakeup(
 	AutoWakeupCfg.word = 0;
 	RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
 
-#ifndef RT30xx
-	AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x00);
-#endif
-#ifdef RT30xx
 	AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
-#endif
 
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
 }
@@ -852,12 +847,7 @@ VOID RT28xxUsbMlmeRadioOn(
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
 		return;
 
-#ifndef RT30xx
-    	AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x00);
-#endif
-#ifdef RT30xx
     	AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
-#endif
 		RTMPusecDelay(10000);
 
 	NICResetFromError(pAd);
@@ -908,22 +898,6 @@ VOID RT28xxUsbMlmeRadioOFF(
 		BssTableInit(&pAd->ScanTab);
 	}
 
-#ifndef RT30xx
-	// Disable MAC Tx/Rx
-	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
-	Value &= (0xfffffff3);
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
-
-	// MAC_SYS_CTRL => value = 0x0 => 40mA
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0);
-
-	// PWR_PIN_CFG => value = 0x0 => 40mA
-	RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0);
-
-	// TX_PIN_CFG => value = 0x0 => 20mA
-	RTMP_IO_WRITE32(pAd, TX_PIN_CFG, 0);
-#endif
-
 	if (pAd->CommonCfg.BBPCurrentBW == BW_40)
 	{
 		// Must using 40MHz.
@@ -935,13 +909,11 @@ VOID RT28xxUsbMlmeRadioOFF(
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.Channel);
 	}
 
-#ifdef RT30xx
 	// Disable Tx/Rx DMA
 	RTUSBReadMACRegister(pAd, WPDMA_GLO_CFG, &GloCfg.word);	   // disable DMA
 	GloCfg.field.EnableTxDMA = 0;
 	GloCfg.field.EnableRxDMA = 0;
 	RTUSBWriteMACRegister(pAd, WPDMA_GLO_CFG, GloCfg.word);	   // abort all TX rings
-#endif
 
 	// Waiting for DMA idle
 	i = 0;
@@ -954,12 +926,10 @@ VOID RT28xxUsbMlmeRadioOFF(
 		RTMPusecDelay(1000);
 	}while (i++ < 100);
 
-#ifdef RT30xx
 	// Disable MAC Tx/Rx
 	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
 	Value &= (0xfffffff3);
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
-#endif
 
 	AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);
 }
--- a/drivers/staging/rt2870/common/rtusb_io.c
+++ b/drivers/staging/rt2870/common/rtusb_io.c
@@ -110,11 +110,9 @@ NTSTATUS RTUSBFirmwareWrite(
 	Status = RTUSBWriteMACRegister(pAd, 0x701c, 0xffffffff);
 	Status = RTUSBFirmwareRun(pAd);
 
-#ifdef RT30xx
 	RTMPusecDelay(10000);
 	RTUSBWriteMACRegister(pAd,H2M_MAILBOX_CSR,0);
 	AsicSendCommandToMcu(pAd, 0x72, 0x00, 0x00, 0x00);//reset rf by MCU supported by new firmware
-#endif
 
 	return Status;
 }
--- a/drivers/staging/rt2870/Kconfig
+++ b/drivers/staging/rt2870/Kconfig
@@ -1,6 +1,5 @@
 config RT2870
-	tristate "Ralink 2870 wireless support"
+	tristate "Ralink 2870/3070 wireless support"
 	depends on USB && X86 && WLAN_80211
 	---help---
-	  This is an experimental driver for the Ralink 2870 wireless chip.
-
+	  This is an experimental driver for the Ralink xx70 wireless chips.
--- a/drivers/staging/rt2870/Makefile
+++ b/drivers/staging/rt2870/Makefile
@@ -2,7 +2,7 @@ obj-$(CONFIG_RT2870)	+= rt2870sta.o
 
 # TODO: all of these should be removed
 EXTRA_CFLAGS += -DLINUX -DAGGREGATION_SUPPORT -DPIGGYBACK_SUPPORT -DWMM_SUPPORT
-EXTRA_CFLAGS += -DRT2870
+EXTRA_CFLAGS += -DRT2870 -DRT3070
 EXTRA_CFLAGS += -DDBG
 
 rt2870sta-objs :=		\
--- a/drivers/staging/rt2870/rt2870.h
+++ b/drivers/staging/rt2870/rt2870.h
@@ -349,11 +349,8 @@ extern UCHAR EpToQueue[6];
 	{	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_PSPOLL);	\
 		RTUSBKickBulkOut(pAd); }
 
-#ifdef RT30xx
-#define RT28xx_CHIP_NAME            "RT3070"
-#else
-#define RT28xx_CHIP_NAME            "RT2870"
-#endif
+#define RT28xx_CHIP_NAME            "RTxx70"
+
 #define USB_CYC_CFG                 0x02a4
 #define STATUS_SUCCESS				0x00
 #define STATUS_UNSUCCESSFUL 		0x01
@@ -462,9 +459,7 @@ typedef struct   _RT_SET_ASIC_WCID {
 	ULONG WCID;          // mechanism for rekeying: 0:disable, 1: time-based, 2: packet-based
 	ULONG SetTid;        // time-based: seconds, packet-based: kilo-packets
 	ULONG DeleteTid;        // time-based: seconds, packet-based: kilo-packets
-#ifndef RT30xx
 	UCHAR Addr[MAC_ADDR_LEN];	// avoid in interrupt when write key
-#endif
 } RT_SET_ASIC_WCID,*PRT_SET_ASIC_WCID;
 
 typedef struct   _RT_SET_ASIC_WCID_ATTRI {
--- a/drivers/staging/rt3070/Kconfig
+++ b/drivers/staging/rt3070/Kconfig
@@ -1,6 +1,6 @@
 config RT3070
 	tristate "Ralink 3070 wireless support"
-	depends on USB && X86 && WLAN_80211
+	depends on USB && X86 && WLAN_80211 && !RT2870
 	---help---
 	  This is an experimental driver for the Ralink 3070 wireless chip.
 
