From foo@baz Wed Aug 12 16:37:26 PDT 2009
Date: Wed, 12 Aug 2009 16:37:26 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Staging: rtl8192e: remove kernel version checks

This removes a lot of code that is never built in to the driver.

The size of the built code after this patch is identical to before it.

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/rtl8192e/ieee80211.h       |  117 --------------
 drivers/staging/rtl8192e/r8192E.h          |   38 ----
 drivers/staging/rtl8192e/r8192E_core.c     |  228 -----------------------------
 drivers/staging/rtl8192e/r8192E_dm.c       |   68 --------
 drivers/staging/rtl8192e/r8192E_dm.h       |    8 -
 drivers/staging/rtl8192e/r8192E_wx.c       |   20 --
 drivers/staging/rtl8192e/r8192_pm.c        |   14 -
 drivers/staging/rtl8192e/r819xE_firmware.c |   10 -
 8 files changed, 1 insertion(+), 502 deletions(-)

--- a/drivers/staging/rtl8192e/ieee80211.h
+++ b/drivers/staging/rtl8192e/ieee80211.h
@@ -27,12 +27,7 @@
 #include <linux/kernel.h>   /* ARRAY_SIZE */
 #include <linux/version.h>
 #include <linux/module.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 #include <linux/jiffies.h>
-#else
-#include <linux/jffs.h>
-#include <linux/tqueue.h>
-#endif
 #include <linux/timer.h>
 #include <linux/sched.h>
 
@@ -43,12 +38,6 @@
 #include "ieee80211/rtl819x_BA.h"
 #include "ieee80211/rtl819x_TS.h"
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
-#ifndef bool
-typedef enum{false = 0, true} bool;
-#endif
-#endif
-
 #ifndef IW_MODE_MONITOR
 #define IW_MODE_MONITOR 6
 #endif
@@ -57,25 +46,6 @@ typedef enum{false = 0, true} bool;
 #define IWEVCUSTOM 0x8c02
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-#ifndef __bitwise
-#define __bitwise __attribute__((bitwise))
-#endif
-typedef __u16  __le16;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27))
-struct iw_spy_data{
-	/* --- Standard spy support --- */
-	int 			spy_number;
-	u_char 			spy_address[IW_MAX_SPY][ETH_ALEN];
-	struct iw_quality	spy_stat[IW_MAX_SPY];
-	/* --- Enhanced spy support (event) */
-	struct iw_quality	spy_thr_low; /* Low threshold */
-	struct iw_quality	spy_thr_high; /* High threshold */
-	u_char			spy_thr_under[IW_MAX_SPY];
-};
-#endif
-#endif
-
 #ifndef container_of
 /**
  * container_of - cast a member of a structure out to the containing structure
@@ -425,46 +395,8 @@ typedef struct ieee_param {
 #define IW_QUAL_NOISE_UPDATED  0x4
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-static inline void tq_init(struct tq_struct * task, void(*func)(void *), void *data)
-{
-	task->routine = func;
-	task->data 	= data;
-	//task->next = NULL;
-	INIT_LIST_HEAD(&task->list);
-	task->sync = 0;
-}
-#endif
-
-// linux under 2.6.9 release may not support it, so modify it for common use
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9))
-//#define MSECS(t)	(1000 * ((t) / HZ) + 1000 * ((t) % HZ) / HZ)
-#define MSECS(t)	(HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
-static inline unsigned long msleep_interruptible_rsl(unsigned int msecs)
-{
-         unsigned long timeout = MSECS(msecs) + 1;
-
-         while (timeout) {
-                 set_current_state(TASK_INTERRUPTIBLE);
-                 timeout = schedule_timeout(timeout);
-         }
-         return timeout;
-}
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,31))
-static inline void msleep(unsigned int msecs)
-{
-         unsigned long timeout = MSECS(msecs) + 1;
-
-         while (timeout) {
-                 set_current_state(TASK_UNINTERRUPTIBLE);
-                 timeout = schedule_timeout(timeout);
-         }
-}
-#endif
-#else
 #define MSECS(t) msecs_to_jiffies(t)
 #define msleep_interruptible_rsl  msleep_interruptible
-#endif
 
 #define IEEE80211_DATA_LEN		2304
 /* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
@@ -1736,21 +1668,6 @@ enum ieee80211_state {
 #define IEEE80211_52GHZ_CHANNELS (IEEE80211_52GHZ_MAX_CHANNEL - \
                                   IEEE80211_52GHZ_MIN_CHANNEL + 1)
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11))
-extern inline int is_multicast_ether_addr(const u8 *addr)
-{
-        return ((addr[0] != 0xff) && (0x01 & addr[0]));
-}
-#endif
-
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13))
-extern inline int is_broadcast_ether_addr(const u8 *addr)
-{
-	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
-		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
-}
-#endif
-
 typedef struct tx_pending_t{
 	int frag;
 	struct ieee80211_txb *txb;
@@ -1827,11 +1744,7 @@ typedef struct _RT_POWER_SAVE_CONTROL
 	bool				bIPSModeBackup;
 	bool				bSwRfProcessing;
 	RT_RF_POWER_STATE	eInactivePowerState;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct work_struct 	InactivePsWorkItem;
-#else
-	struct tq_struct	InactivePsWorkItem;
-#endif
 	struct timer_list	InactivePsTimer;
 
 	// Return point for join action
@@ -2198,36 +2111,16 @@ struct ieee80211_device {
 
 	/* used if IEEE_SOFTMAC_BEACONS is set */
 	struct timer_list beacon_timer;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+
         struct work_struct associate_complete_wq;
         struct work_struct associate_procedure_wq;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
         struct delayed_work softmac_scan_wq;
         struct delayed_work associate_retry_wq;
 	 struct delayed_work start_ibss_wq;
 	 struct delayed_work hw_wakeup_wq;
 	struct delayed_work hw_sleep_wq;
-#else
-        struct work_struct softmac_scan_wq;
-        struct work_struct associate_retry_wq;
-	struct work_struct start_ibss_wq;
-	struct work_struct hw_wakeup_wq;
-	struct work_struct hw_sleep_wq;
-#endif
         struct work_struct wx_sync_scan_wq;
         struct workqueue_struct *wq;
-#else
-	/* used for periodly scan */
-	struct timer_list scan_timer;
-
-	struct tq_struct associate_complete_wq;
-	struct tq_struct associate_retry_wq;
-	struct tq_struct start_ibss_wq;
-	struct tq_struct associate_procedure_wq;
-	struct tq_struct softmac_scan_wq;
-	struct tq_struct wx_sync_scan_wq;
-
-#endif
         // Qos related. Added by Annie, 2005-11-01.
         //STA_QOS  StaQos;
 
@@ -2413,11 +2306,7 @@ struct ieee80211_device {
 
 static inline void *ieee80211_priv(struct net_device *dev)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	return ((struct ieee80211_device *)netdev_priv(dev))->priv;
-#else
-	return ((struct ieee80211_device *)dev->priv)->priv;
-#endif
 }
 
 extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
@@ -2670,11 +2559,7 @@ extern int ieee80211_wx_get_freq(struct 
 			     union iwreq_data *wrqu, char *b);
 
 //extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern void ieee80211_wx_sync_scan_wq(struct work_struct *work);
-#else
- extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
-#endif
 
 
 extern int ieee80211_wx_set_rawtx(struct ieee80211_device *ieee,
--- a/drivers/staging/rtl8192e/r8192E_core.c
+++ b/drivers/staging/rtl8192e/r8192E_core.c
@@ -119,25 +119,16 @@ static int hwwep = 1; //default use hw. 
 static int channels = 0x3fff;
 
 MODULE_LICENSE("GPL");
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 MODULE_VERSION("V 1.1");
-#endif
 MODULE_DEVICE_TABLE(pci, rtl8192_pci_id_tbl);
 //MODULE_AUTHOR("Andrea Merello <andreamrl@tiscali.it>");
 MODULE_DESCRIPTION("Linux driver for Realtek RTL819x WiFi cards");
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
 module_param(ifname, charp, S_IRUGO|S_IWUSR );
 //module_param(hwseqnum,int, S_IRUGO|S_IWUSR);
 module_param(hwwep,int, S_IRUGO|S_IWUSR);
 module_param(channels,int, S_IRUGO|S_IWUSR);
-#else
-MODULE_PARM(ifname, "s");
-//MODULE_PARM(hwseqnum,"i");
-MODULE_PARM(hwwep,"i");
-MODULE_PARM(channels,"i");
-#endif
 
 MODULE_PARM_DESC(ifname," Net interface name, wlan%d=default");
 //MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
@@ -153,7 +144,6 @@ static struct pci_driver rtl8192_pci_dri
 	.id_table	= rtl8192_pci_id_tbl,	          /* PCI_ID table  */
 	.probe		= rtl8192_pci_probe,	          /* probe fn      */
 	.remove		= __devexit_p(rtl8192_pci_disconnect),	  /* remove fn     */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
 #ifdef CONFIG_PM_RTL
 	.suspend	= rtl8192E_suspend,	          /* PM suspend fn */
 	.resume		= rtl8192E_resume,                 /* PM resume fn  */
@@ -161,7 +151,6 @@ static struct pci_driver rtl8192_pci_dri
 	.suspend	= NULL,			          /* PM suspend fn */
 	.resume      	= NULL,			          /* PM resume fn  */
 #endif
-#endif
 };
 
 #ifdef ENABLE_DOT11D
@@ -367,25 +356,12 @@ inline void force_pci_posting(struct net
 
 
 //warning message WB
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-void rtl8192_interrupt(int irq, void *netdev, struct pt_regs *regs);
-#else
-irqreturn_t rtl8192_interrupt(int irq, void *netdev, struct pt_regs *regs);
-#endif
-#else
 irqreturn_t rtl8192_interrupt(int irq, void *netdev);
-#endif
 //static struct net_device_stats *rtl8192_stats(struct net_device *dev);
 void rtl8192_commit(struct net_device *dev);
 //void rtl8192_restart(struct net_device *dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8192_restart(struct work_struct *work);
 //void rtl8192_rq_tx_ack(struct work_struct *work);
-#else
- void rtl8192_restart(struct net_device *dev);
-// //void rtl8192_rq_tx_ack(struct net_device *dev);
- #endif
 
 void watch_dog_timer_callback(unsigned long data);
 #ifdef ENABLE_IPS
@@ -608,21 +584,13 @@ static int proc_get_stats_rx(char *page,
 static void rtl8192_proc_module_init(void)
 {
 	RT_TRACE(COMP_INIT, "Initializing proc filesystem");
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-	rtl8192_proc=create_proc_entry(RTL819xE_MODULE_NAME, S_IFDIR, proc_net);
-#else
 	rtl8192_proc=create_proc_entry(RTL819xE_MODULE_NAME, S_IFDIR, init_net.proc_net);
-#endif
 }
 
 
 static void rtl8192_proc_module_remove(void)
 {
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-	remove_proc_entry(RTL819xE_MODULE_NAME, proc_net);
-#else
 	remove_proc_entry(RTL819xE_MODULE_NAME, init_net.proc_net);
-#endif
 }
 
 
@@ -720,11 +688,7 @@ static void tx_timeout(struct net_device
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	//rtl8192_commit(dev);
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 	schedule_work(&priv->reset_wq);
-#else
-	schedule_task(&priv->reset_wq);
-#endif
 	printk("TXTIMEOUT");
 }
 
@@ -1773,16 +1737,10 @@ static struct ieee80211_qos_parameters d
         {0,0,0,0} /* tx_op_limit */
 };
 
-#if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
 static void rtl8192_update_beacon(struct work_struct * work)
 {
         struct r8192_priv *priv = container_of(work, struct r8192_priv, update_beacon_wq.work);
         struct net_device *dev = priv->ieee80211->dev;
-#else
-void rtl8192_update_beacon(struct net_device *dev)
-{
-        struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
  	struct ieee80211_device* ieee = priv->ieee80211;
 	struct ieee80211_network* net = &ieee->current_network;
 
@@ -1795,16 +1753,10 @@ void rtl8192_update_beacon(struct net_de
 * background support to run QoS activate functionality
 */
 static int WDCAPARA_ADD[] = {EDCAPARA_BE,EDCAPARA_BK,EDCAPARA_VI,EDCAPARA_VO};
-#if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
 static void rtl8192_qos_activate(struct work_struct * work)
 {
         struct r8192_priv *priv = container_of(work, struct r8192_priv, qos_activate);
         struct net_device *dev = priv->ieee80211->dev;
-#else
-void rtl8192_qos_activate(struct net_device *dev)
-{
-        struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
         struct ieee80211_qos_parameters *qos_parameters = &priv->ieee80211->current_network.qos_data.parameters;
         u8 mode = priv->ieee80211->current_network.mode;
 //        u32 size = sizeof(struct ieee80211_qos_parameters);
@@ -1814,11 +1766,7 @@ void rtl8192_qos_activate(struct net_dev
         if (priv == NULL)
                 return;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-	down(&priv->mutex);
-#else
         mutex_lock(&priv->mutex);
-#endif
         if(priv->ieee80211->state != IEEE80211_LINKED)
 		goto success;
 	RT_TRACE(COMP_QOS,"qos active process with associate response received\n");
@@ -1838,11 +1786,7 @@ void rtl8192_qos_activate(struct net_dev
 	}
 
 success:
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-	up(&priv->mutex);
-#else
         mutex_unlock(&priv->mutex);
-#endif
 }
 
 static int rtl8192_qos_handle_probe_response(struct r8192_priv *priv,
@@ -1869,11 +1813,7 @@ static int rtl8192_qos_handle_probe_resp
 				 network->qos_data.param_count)) {
 			network->qos_data.old_param_count =
 				network->qos_data.param_count;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			queue_work(priv->priv_wq, &priv->qos_activate);
-#else
-			schedule_task(&priv->qos_activate);
-#endif
 			RT_TRACE (COMP_QOS, "QoS parameters change call "
 					"qos_activate\n");
 		}
@@ -1882,11 +1822,7 @@ static int rtl8192_qos_handle_probe_resp
 		       &def_qos_parameters, size);
 
 		if ((network->qos_data.active == 1) && (active_network == 1)) {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			queue_work(priv->priv_wq, &priv->qos_activate);
-#else
-			schedule_task(&priv->qos_activate);
-#endif
 			RT_TRACE(COMP_QOS, "QoS was disabled call qos_activate \n");
 		}
 		network->qos_data.active = 0;
@@ -1905,15 +1841,7 @@ static int rtl8192_handle_beacon(struct 
 
 	rtl8192_qos_handle_probe_response(priv,1,network);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	queue_delayed_work(priv->priv_wq, &priv->update_beacon_wq, 0);
-#else
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	schedule_task(&priv->update_beacon_wq);
-#else
-	queue_work(priv->priv_wq, &priv->update_beacon_wq);
-#endif
-#endif
 	return 0;
 
 }
@@ -1970,12 +1898,7 @@ static int rtl8192_qos_association_resp(
 
 	RT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n",__FUNCTION__,network->flags ,priv->ieee80211->current_network.qos_data.active);
 	if (set_qos_param == 1)
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		queue_work(priv->priv_wq, &priv->qos_activate);
-#else
-		schedule_task(&priv->qos_activate);
-#endif
-
 
         return ret;
 }
@@ -2208,7 +2131,6 @@ static void rtl8192_hw_sleep_down(struct
 	RT_TRACE(COMP_POWER, "%s()============>come to sleep down\n", __FUNCTION__);
 	MgntActSet_RF_State(dev, eRfSleep, RF_CHANGE_BY_PS);
 }
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 static void rtl8192_hw_sleep_wq (struct work_struct *work)
 {
 //      struct r8180_priv *priv = container_of(work, struct r8180_priv, watch_dog_wq);
@@ -2217,10 +2139,6 @@ static void rtl8192_hw_sleep_wq (struct 
         struct delayed_work *dwork = container_of(work,struct delayed_work,work);
         struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_sleep_wq);
         struct net_device *dev = ieee->dev;
-#else
-void rtl8192_hw_sleep_wq(struct net_device* dev)
-{
-#endif
 	//printk("=========>%s()\n", __FUNCTION__);
         rtl8192_hw_sleep_down(dev);
 }
@@ -2236,7 +2154,6 @@ static void rtl8192_hw_wakeup(struct net
 	//FIXME: will we send package stored while nic is sleep?
 //	spin_unlock_irqrestore(&priv->ps_lock,flags);
 }
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8192_hw_wakeup_wq (struct work_struct *work)
 {
 //	struct r8180_priv *priv = container_of(work, struct r8180_priv, watch_dog_wq);
@@ -2245,10 +2162,6 @@ void rtl8192_hw_wakeup_wq (struct work_s
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
 	struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_wakeup_wq);
 	struct net_device *dev = ieee->dev;
-#else
-void rtl8192_hw_wakeup_wq(struct net_device* dev)
-{
-#endif
 	rtl8192_hw_wakeup(dev);
 
 }
@@ -2468,18 +2381,10 @@ static void rtl8192_init_priv_lock(struc
 	//spin_lock_init(&priv->rf_lock);
 	sema_init(&priv->wx_sem,1);
 	sema_init(&priv->rf_sem,1);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-	sema_init(&priv->mutex, 1);
-#else
 	mutex_init(&priv->mutex);
-#endif
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern  void    rtl819x_watchdog_wqcallback(struct work_struct *work);
-#else
-extern  void    rtl819x_watchdog_wqcallback(struct net_device *dev);
-#endif
 
 void rtl8192_irq_rx_tasklet(struct r8192_priv *priv);
 void rtl8192_irq_tx_tasklet(struct r8192_priv *priv);
@@ -2490,15 +2395,12 @@ static void rtl8192_init_priv_task(struc
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 #ifdef PF_SYNCTHREAD
 	priv->priv_wq = create_workqueue(DRV_NAME,0);
 #else
 	priv->priv_wq = create_workqueue(DRV_NAME);
 #endif
-#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 //	INIT_WORK(&priv->reset_wq, (void(*)(void*)) rtl8192_restart);
 	INIT_WORK(&priv->reset_wq,  rtl8192_restart);
 //	INIT_DELAYED_WORK(&priv->watch_dog_wq, hal_dm_watchdog);
@@ -2512,34 +2414,6 @@ static void rtl8192_init_priv_task(struc
 	INIT_DELAYED_WORK(&priv->ieee80211->hw_wakeup_wq,(void*) rtl8192_hw_wakeup_wq);
 	INIT_DELAYED_WORK(&priv->ieee80211->hw_sleep_wq,(void*) rtl8192_hw_sleep_wq);
 
-#else
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-	tq_init(&priv->reset_wq, (void*)rtl8192_restart, dev);
-	tq_init(&priv->watch_dog_wq, (void*)rtl819x_watchdog_wqcallback, dev);
-	tq_init(&priv->txpower_tracking_wq, (void*)dm_txpower_trackingcallback, dev);
-	tq_init(&priv->rfpath_check_wq, (void*)dm_rf_pathcheck_workitemcallback, dev);
-	tq_init(&priv->update_beacon_wq, (void*)rtl8192_update_beacon, dev);
-	//tq_init(&priv->SwChnlWorkItem, (void*) rtl8192_SwChnl_WorkItem, dev);
-	//tq_init(&priv->SetBWModeWorkItem, (void*)rtl8192_SetBWModeWorkItem, dev);
-	tq_init(&priv->qos_activate, (void *)rtl8192_qos_activate, dev);
-	tq_init(&priv->ieee80211->hw_wakeup_wq,(void*) rtl8192_hw_wakeup_wq, dev);
-	tq_init(&priv->ieee80211->hw_sleep_wq,(void*) rtl8192_hw_sleep_wq, dev);
-
-#else
-	INIT_WORK(&priv->reset_wq,(void(*)(void*)) rtl8192_restart,dev);
-//	INIT_WORK(&priv->watch_dog_wq, (void(*)(void*)) hal_dm_watchdog,dev);
-	INIT_WORK(&priv->watch_dog_wq, (void(*)(void*)) rtl819x_watchdog_wqcallback,dev);
-	INIT_WORK(&priv->txpower_tracking_wq, (void(*)(void*)) dm_txpower_trackingcallback,dev);
-	INIT_WORK(&priv->rfpath_check_wq, (void(*)(void*)) dm_rf_pathcheck_workitemcallback,dev);
-	INIT_WORK(&priv->update_beacon_wq, (void(*)(void*))rtl8192_update_beacon,dev);
-	//INIT_WORK(&priv->SwChnlWorkItem, (void(*)(void*)) rtl8192_SwChnl_WorkItem, dev);
-	//INIT_WORK(&priv->SetBWModeWorkItem, (void(*)(void*)) rtl8192_SetBWModeWorkItem, dev);
-	INIT_WORK(&priv->qos_activate, (void(*)(void *))rtl8192_qos_activate, dev);
-	INIT_WORK(&priv->ieee80211->hw_wakeup_wq,(void*) rtl8192_hw_wakeup_wq, dev);
-	INIT_WORK(&priv->ieee80211->hw_sleep_wq,(void*) rtl8192_hw_sleep_wq, dev);
-#endif
-#endif
-
 	tasklet_init(&priv->irq_rx_tasklet,
 	     (void(*)(unsigned long))rtl8192_irq_rx_tasklet,
 	     (unsigned long)priv);
@@ -4171,9 +4045,7 @@ RESET_START:
 			printk("ieee->state is IEEE80211_LINKED\n");
 			ieee80211_stop_send_beacons(priv->ieee80211);
 			del_timer_sync(&ieee->associate_timer);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
                         cancel_delayed_work(&ieee->associate_retry_wq);
-#endif
 			ieee80211_stop_scan(ieee);
 			netif_carrier_off(dev);
 			up(&ieee->wx_sem);
@@ -4211,11 +4083,7 @@ RESET_START:
 			ieee->set_chan(ieee->dev, ieee->current_network.channel);
 
 #if 1
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			queue_work(ieee->wq, &ieee->associate_complete_wq);
-#else
-			schedule_task(&ieee->associate_complete_wq);
-#endif
 #endif
 
 		}
@@ -4366,17 +4234,11 @@ static void rtl819x_update_rxcounts(
 }
 
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl819x_watchdog_wqcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,watch_dog_wq);
        struct net_device *dev = priv->ieee80211->dev;
-#else
-extern	void	rtl819x_watchdog_wqcallback(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 	struct ieee80211_device* ieee = priv->ieee80211;
 	RESET_TYPE	ResetType = RESET_TYPE_NORESET;
       	static u8	check_reset_cnt=0;
@@ -4434,11 +4296,7 @@ extern	void	rtl819x_watchdog_wqcallback(
 				ieee->is_roaming = true;
 				ieee->is_set_key = false;
                              ieee->link_change(dev);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
                                 queue_work(ieee->wq, &ieee->associate_procedure_wq);
-#else
-                                schedule_task(&ieee->associate_procedure_wq);
-#endif
 			}
 		}
 	      ieee->LinkDetectInfo.NumRecvBcnInPeriod=0;
@@ -4480,15 +4338,7 @@ extern	void	rtl819x_watchdog_wqcallback(
 void watch_dog_timer_callback(unsigned long data)
 {
 	struct r8192_priv *priv = ieee80211_priv((struct net_device *) data);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	queue_delayed_work(priv->priv_wq,&priv->watch_dog_wq,0);
-#else
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	schedule_task(&priv->watch_dog_wq);
-#else
-	queue_work(priv->priv_wq,&priv->watch_dog_wq);
-#endif
-#endif
 	mod_timer(&priv->watch_dog_timer, jiffies + MSECS(IEEE80211_WATCH_DOG_TIME));
 
 }
@@ -4637,17 +4487,10 @@ void rtl8192_commit(struct net_device *d
 	_rtl8192_up(dev);
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8192_restart(struct work_struct *work)
 {
         struct r8192_priv *priv = container_of(work, struct r8192_priv, reset_wq);
         struct net_device *dev = priv->ieee80211->dev;
-#else
-void rtl8192_restart(struct net_device *dev)
-{
-
-        struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 
 	down(&priv->wx_sem);
 
@@ -4688,11 +4531,7 @@ static int r8192_set_mac_adr(struct net_
 
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 	schedule_work(&priv->reset_wq);
-#else
-	schedule_task(&priv->reset_wq);
-#endif
 	up(&priv->wx_sem);
 
 	return 0;
@@ -5899,11 +5738,7 @@ static void rtl8192_rx(struct net_device
                 stats.RxBufShift = ((pdesc->Shift)&0x03);
                 stats.Decrypted = !pdesc->SWDec;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
                 pci_dma_sync_single_for_cpu(priv->pdev,
-#else
-                    pci_unmap_single(priv->pdev,
-#endif
                      *((dma_addr_t *)skb->cb),
                      priv->rxbuffersize,
                      PCI_DMA_FROMDEVICE);
@@ -6034,33 +5869,19 @@ static int __devinit rtl8192_pci_probe(s
 	pci_set_master(pdev);
 	//pci_set_wmi(pdev);
 	pci_set_dma_mask(pdev, 0xffffff00ULL);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	pci_set_consistent_dma_mask(pdev,0xffffff00ULL);
-#endif
 	dev = alloc_ieee80211(sizeof(struct r8192_priv));
 	if (!dev)
 		return -ENOMEM;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-	SET_MODULE_OWNER(dev);
-#endif
-
 	pci_set_drvdata(pdev, dev);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	SET_NETDEV_DEV(dev, &pdev->dev);
-#endif
 	priv = ieee80211_priv(dev);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	priv->ieee80211 = netdev_priv(dev);
-#else
-	priv->ieee80211 = (struct ieee80211_device *)dev->priv;
-#endif
 	priv->pdev=pdev;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	if((pdev->subsystem_vendor == PCI_VENDOR_ID_DLINK)&&(pdev->subsystem_device == 0x3304)){
 		priv->ieee80211->bSupportRemoteWakeUp = 1;
 	} else
-#endif
 	{
 		priv->ieee80211->bSupportRemoteWakeUp = 0;
 	}
@@ -6171,11 +5992,7 @@ static int __devinit rtl8192_pci_probe(s
 
 
 	RT_TRACE(COMP_INIT, "Driver probe completed\n");
-//#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-//	return dev;
-//#else
 	return 0;
-//#endif
 
 fail1:
 
@@ -6222,7 +6039,6 @@ void rtl8192_cancel_deferred_work(struct
          * Otherwise call cancel_delayed_work is enough.
          * FIXME (2.6.20 shoud 2.6.22, work_struct shoud not cancel)
          * */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	cancel_delayed_work(&priv->watch_dog_wq);
 	cancel_delayed_work(&priv->update_beacon_wq);
 	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
@@ -6230,20 +6046,10 @@ void rtl8192_cancel_deferred_work(struct
 #ifdef RTL8192E
 	cancel_delayed_work(&priv->gpio_change_rf_wq);
 #endif
-#endif
-#if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,22)
 	cancel_work_sync(&priv->reset_wq);
 	cancel_work_sync(&priv->qos_activate);
 	//cancel_work_sync(&priv->SetBWModeWorkItem);
 	//cancel_work_sync(&priv->SwChnlWorkItem);
-#else
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-	cancel_delayed_work(&priv->reset_wq);
-	cancel_delayed_work(&priv->qos_activate);
-	//cancel_delayed_work(&priv->SetBWModeWorkItem);
-	//cancel_delayed_work(&priv->SwChnlWorkItem);
-#endif
-#endif
 
 }
 
@@ -6269,9 +6075,7 @@ static void __devexit rtl8192_pci_discon
 		}
 	//	priv->rf_close(dev);
 	//	rtl8192_usb_deleteendpoints(dev);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		destroy_workqueue(priv->priv_wq);
-#endif
                 /* redundant with rtl8192_down */
                // rtl8192_irq_disable(dev);
                // rtl8192_reset(dev);
@@ -6334,11 +6138,7 @@ static int __init rtl8192_pci_module_ini
 	RT_TRACE(COMP_INIT, "Initializing module");
 	RT_TRACE(COMP_INIT, "Wireless extensions version %d", WIRELESS_EXT);
 	rtl8192_proc_module_init();
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
-      if(0!=pci_module_init(&rtl8192_pci_driver))
-#else
       if(0!=pci_register_driver(&rtl8192_pci_driver))
-#endif
 	{
 		DMESG("No device found");
 		/*pci_unregister_driver (&rtl8192_pci_driver);*/
@@ -6358,15 +6158,7 @@ static void __exit rtl8192_pci_module_ex
 }
 
 //warning message WB
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-void rtl8192_interrupt(int irq, void *netdev, struct pt_regs *regs)
-#else
-irqreturn_t rtl8192_interrupt(int irq, void *netdev, struct pt_regs *regs)
-#endif
-#else
 irqreturn_t rtl8192_interrupt(int irq, void *netdev)
-#endif
 {
     struct net_device *dev = (struct net_device *) netdev;
     struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
@@ -6374,11 +6166,7 @@ irqreturn_t rtl8192_interrupt(int irq, v
     u32 inta;
     /* We should return IRQ_NONE, but for now let me keep this */
     if(priv->irq_enabled == 0){
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-        return;
-#else
         return IRQ_HANDLED;
-#endif
     }
 
     spin_lock_irqsave(&priv->irq_th_lock,flags);
@@ -6392,11 +6180,7 @@ irqreturn_t rtl8192_interrupt(int irq, v
     //DMESG("Enter interrupt, ISR value = 0x%08x", inta);
     if(!inta){
         spin_unlock_irqrestore(&priv->irq_th_lock,flags);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-        return;
-#else
         return IRQ_HANDLED;
-#endif
         /*
            most probably we can safely return IRQ_NONE,
            but for now is better to avoid problems
@@ -6406,11 +6190,7 @@ irqreturn_t rtl8192_interrupt(int irq, v
     if(inta == 0xffff){
         /* HW disappared */
         spin_unlock_irqrestore(&priv->irq_th_lock,flags);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-        return;
-#else
         return IRQ_HANDLED;
-#endif
     }
 
     priv->stats.ints++;
@@ -6422,11 +6202,7 @@ irqreturn_t rtl8192_interrupt(int irq, v
 
     if(!netif_running(dev)) {
         spin_unlock_irqrestore(&priv->irq_th_lock,flags);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-        return;
-#else
         return IRQ_HANDLED;
-#endif
     }
 
     if(inta & IMR_TIMEOUT0){
@@ -6523,11 +6299,7 @@ irqreturn_t rtl8192_interrupt(int irq, v
     force_pci_posting(dev);
     spin_unlock_irqrestore(&priv->irq_th_lock,flags);
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-    return;
-#else
     return IRQ_HANDLED;
-#endif
 }
 
 void rtl8192_try_wake_queue(struct net_device *dev, int pri)
--- a/drivers/staging/rtl8192e/r8192E_dm.c
+++ b/drivers/staging/rtl8192e/r8192E_dm.c
@@ -69,11 +69,7 @@ extern void hal_dm_watchdog(struct net_d
 
 
 extern	void	init_rate_adaptive(struct net_device *dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern	void	dm_txpower_trackingcallback(struct work_struct *work);
-#else
-extern	void	dm_txpower_trackingcallback(struct net_device *dev);
-#endif
 
 extern	void	dm_cck_txpower_adjust(struct net_device *dev,bool  binch14);
 extern	void	dm_restore_dynamic_mechanism_state(struct net_device *dev);
@@ -89,22 +85,14 @@ extern	void dm_force_tx_fw_info(struct n
 										u32		force_value);
 extern	void	dm_init_edca_turbo(struct net_device *dev);
 extern	void	dm_rf_operation_test_callback(unsigned long data);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern	void	dm_rf_pathcheck_workitemcallback(struct work_struct *work);
-#else
-extern	void	dm_rf_pathcheck_workitemcallback(struct net_device *dev);
-#endif
 extern	void dm_fsync_timer_callback(unsigned long data);
 extern	void dm_check_fsync(struct net_device *dev);
 extern	void	dm_shadow_init(struct net_device *dev);
 extern	void dm_initialize_txpower_tracking(struct net_device *dev);
 
 #ifdef RTL8192E
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern  void    dm_gpio_change_rf_callback(struct work_struct *work);
-#else
-extern  void    dm_gpio_change_rf_callback(struct net_device *dev);
-#endif
 #endif
 
 
@@ -217,11 +205,7 @@ void init_hal_dm(struct net_device *dev)
 	dm_init_rxpath_selection(dev);
 	dm_init_ctstoself(dev);
 #ifdef RTL8192E
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 	INIT_DELAYED_WORK(&priv->gpio_change_rf_wq,  dm_gpio_change_rf_callback);
-#else
-	INIT_WORK(&priv->gpio_change_rf_wq, (void(*)(void*)) dm_gpio_change_rf_callback,dev);
-#endif
 #endif
 
 }	// InitHalDm
@@ -1021,19 +1005,11 @@ static void dm_TXPowerTrackingCallback_T
 	priv->txpower_count = 0;
 }
 #endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void dm_txpower_trackingcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,txpower_tracking_wq);
        struct net_device *dev = priv->ieee80211->dev;
-#else
-extern	void	dm_txpower_trackingcallback(struct net_device *dev)
-{
-#ifndef RTL8190P
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
-#endif
 
 #ifdef RTL8190P
 	dm_TXPowerTrackingCallback_TSSI(dev);
@@ -1599,15 +1575,7 @@ static void dm_CheckTXPowerTracking_TSSI
 
 	 if(tx_power_track_counter > 90)
 	 	{
-	 		#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 				queue_delayed_work(priv->priv_wq,&priv->txpower_tracking_wq,0);
-			#else
-				#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-				schedule_task(&priv->txpower_tracking_wq);
-				#else
-				queue_work(priv->priv_wq,&priv->txpower_tracking_wq);
-				#endif
-			#endif
 		tx_power_track_counter =0;
 	 	}
 
@@ -1646,15 +1614,7 @@ static void dm_CheckTXPowerTracking_Ther
 	else
 		{
 		//DbgPrint("Schedule TxPowerTrackingWorkItem\n");
-			#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 			queue_delayed_work(priv->priv_wq,&priv->txpower_tracking_wq,0);
-			#else
-				#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-				schedule_task(&priv->txpower_tracking_wq);
-				#else
-				queue_work(priv->priv_wq,&priv->txpower_tracking_wq);
-				#endif
-			#endif
 		TM_Trigger = 0;
 		}
 }
@@ -2880,15 +2840,7 @@ static void dm_check_rfctrl_gpio(struct 
 	return;
 #endif
 #ifdef RTL8192E
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 		queue_delayed_work(priv->priv_wq,&priv->gpio_change_rf_wq,0);
-        #else
-                #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			schedule_task(&priv->gpio_change_rf_wq);
-                #else
-		        queue_work(priv->priv_wq,&priv->gpio_change_rf_wq);
-                #endif
-	#endif
 #endif
 
 }	/* dm_CheckRfCtrlGPIO */
@@ -2949,17 +2901,11 @@ static	void	dm_check_pbc_gpio(struct net
  *	02/21/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void dm_gpio_change_rf_callback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,gpio_change_rf_wq);
        struct net_device *dev = priv->ieee80211->dev;
-#else
-extern	void	dm_gpio_change_rf_callback(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 	u8 tmp1byte;
 	RT_RF_POWER_STATE	eRfPowerStateToSet;
 	bool bActuallySet = false;
@@ -3025,17 +2971,11 @@ extern	void	dm_gpio_change_rf_callback(s
  *	01/30/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void dm_rf_pathcheck_workitemcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,rfpath_check_wq);
        struct net_device *dev =priv->ieee80211->dev;
-#else
-extern	void	dm_rf_pathcheck_workitemcallback(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 	//bool bactually_set = false;
 	u8 rfpath = 0, i;
 
@@ -3360,15 +3300,7 @@ static void dm_rxpath_sel_byrssi(struct 
 static	void	dm_check_rx_path_selection(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	queue_delayed_work(priv->priv_wq,&priv->rfpath_check_wq,0);
-#else
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	schedule_task(&priv->rfpath_check_wq);
-#else
-	queue_work(priv->priv_wq,&priv->rfpath_check_wq);
-#endif
-#endif
 }	/* dm_CheckRxRFPath */
 
 
--- a/drivers/staging/rtl8192e/r8192E_dm.h
+++ b/drivers/staging/rtl8192e/r8192E_dm.h
@@ -280,11 +280,7 @@ extern void hal_dm_watchdog(struct net_d
 
 
 extern  void    init_rate_adaptive(struct net_device *dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern  void    dm_txpower_trackingcallback(struct work_struct *work);
-#else
-extern  void    dm_txpower_trackingcallback(struct net_device *dev);
-#endif
 
 extern  void    dm_cck_txpower_adjust(struct net_device *dev,bool  binch14);
 extern  void    dm_restore_dynamic_mechanism_state(struct net_device *dev);
@@ -300,11 +296,7 @@ extern  void dm_force_tx_fw_info(struct 
                                                                                 u32             force_value);
 extern  void    dm_init_edca_turbo(struct net_device *dev);
 extern  void    dm_rf_operation_test_callback(unsigned long data);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern  void    dm_rf_pathcheck_workitemcallback(struct work_struct *work);
-#else
-extern  void    dm_rf_pathcheck_workitemcallback(struct net_device *dev);
-#endif
 extern  void dm_fsync_timer_callback(unsigned long data);
 #if 0
 extern  bool    dm_check_lbus_status(struct net_device *dev);
--- a/drivers/staging/rtl8192e/r8192E.h
+++ b/drivers/staging/rtl8192e/r8192E.h
@@ -39,9 +39,6 @@
 #include <linux/random.h>
 #include <linux/version.h>
 #include <asm/io.h>
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
-#include <asm/semaphore.h>
-#endif
 #include "ieee80211.h"
 
 
@@ -1020,11 +1017,7 @@ typedef struct r8192_priv
 	spinlock_t irq_th_lock;
 	spinlock_t tx_lock;
 	spinlock_t rf_ps_lock;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-	struct semaphore mutex;
-#else
         struct mutex mutex;
-#endif
 	spinlock_t rf_lock; //used to lock rf write operation added by wb
 	spinlock_t ps_lock;
 
@@ -1163,11 +1156,7 @@ typedef struct r8192_priv
 /* modified by davad for Rx process */
        struct sk_buff_head rx_queue;
        struct sk_buff_head skb_queue;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-	struct tq_struct qos_activate;
-#else
        struct work_struct qos_activate;
-#endif
 	short  tx_urb_index;
 	atomic_t tx_pending[0x10];//UART_PRIORITY+1
 
@@ -1196,11 +1185,7 @@ typedef struct r8192_priv
 
 	struct 	ChnlAccessSetting  ChannelAccessSetting;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct work_struct reset_wq;
-#else
-	struct tq_struct reset_wq;
-#endif
 
 /**********************************************************/
 //for rtl819xPci
@@ -1379,32 +1364,13 @@ typedef struct r8192_priv
 	u8		InitialGainOperateType;
 
 	//define work item by amy 080526
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	struct delayed_work update_beacon_wq;
 	struct delayed_work watch_dog_wq;
 	struct delayed_work txpower_tracking_wq;
 	struct delayed_work rfpath_check_wq;
 	struct delayed_work gpio_change_rf_wq;
 	struct delayed_work initialgain_operate_wq;
-#else
-	struct work_struct update_beacon_wq;
-	struct work_struct watch_dog_wq;
-	struct work_struct txpower_tracking_wq;
-	struct work_struct rfpath_check_wq;
-	struct work_struct gpio_change_rf_wq;
-	struct work_struct initialgain_operate_wq;
-#endif
 	struct workqueue_struct *priv_wq;
-#else
-	struct tq_struct update_beacon_wq;
-	/* used for periodly scan */
-	struct tq_struct txpower_tracking_wq;
-	struct tq_struct rfpath_check_wq;
-	struct tq_struct watch_dog_wq;
-	struct tq_struct gpio_change_rf_wq;
-	struct tq_struct initialgain_operate_wq;
-#endif
 }r8192_priv;
 
 // for rtl8187
@@ -1540,11 +1506,7 @@ void CamPrintDbgReg(struct net_device* d
 extern	void	dm_cck_txpower_adjust(struct net_device *dev,bool  binch14);
 extern void firmware_init_param(struct net_device *dev);
 extern RT_STATUS cmpk_message_handle_tx(struct net_device *dev, u8* codevirtualaddress, u32 packettype, u32 buffer_len);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8192_hw_wakeup_wq (struct work_struct *work);
-#else
-void rtl8192_hw_wakeup_wq(struct net_device *dev);
-#endif
 
 short rtl8192_is_tx_queue_empty(struct net_device *dev);
 #ifdef ENABLE_IPS
--- a/drivers/staging/rtl8192e/r8192E_wx.c
+++ b/drivers/staging/rtl8192e/r8192E_wx.c
@@ -1008,7 +1008,6 @@ static int r8192_wx_set_enc_ext(struct n
                                         union iwreq_data *wrqu, char *extra)
 {
 	int ret=0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device* ieee = priv->ieee80211;
 
@@ -1093,7 +1092,6 @@ static int r8192_wx_set_enc_ext(struct n
 
 end_hw_sec:
 	up(&priv->wx_sem);
-#endif
 	return ret;
 
 }
@@ -1102,13 +1100,11 @@ static int r8192_wx_set_auth(struct net_
                                         union iwreq_data *data, char *extra)
 {
 	int ret=0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	//printk("====>%s()\n", __FUNCTION__);
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
 	ret = ieee80211_wx_set_auth(priv->ieee80211, info, &(data->param), extra);
 	up(&priv->wx_sem);
-#endif
 	return ret;
 }
 
@@ -1119,12 +1115,10 @@ static int r8192_wx_set_mlme(struct net_
 	//printk("====>%s()\n", __FUNCTION__);
 
 	int ret=0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
 	ret = ieee80211_wx_set_mlme(priv->ieee80211, info, wrqu, extra);
 	up(&priv->wx_sem);
-#endif
 	return ret;
 }
 #endif
@@ -1134,18 +1128,12 @@ static int r8192_wx_set_gen_ie(struct ne
 {
 	   //printk("====>%s(), len:%d\n", __FUNCTION__, data->length);
 	int ret=0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
         struct r8192_priv *priv = ieee80211_priv(dev);
         down(&priv->wx_sem);
-#if 1
         ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
-#endif
         up(&priv->wx_sem);
 	//printk("<======%s(), ret:%d\n", __FUNCTION__, ret);
-#endif
         return ret;
-
-
 }
 
 static int dummy(struct net_device *dev, struct iw_request_info *a,
@@ -1325,11 +1313,7 @@ struct iw_statistics *r8192_get_wireless
 		wstats->qual.qual = 0;
 		wstats->qual.level = 0;
 		wstats->qual.noise = 0;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
 		wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
-#else
-		wstats->qual.updated = 0x0f;
-#endif
 		return wstats;
 	}
 
@@ -1341,11 +1325,7 @@ struct iw_statistics *r8192_get_wireless
 	wstats->qual.level = tmp_level;
 	wstats->qual.qual = tmp_qual;
 	wstats->qual.noise = tmp_noise;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
 	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
-#else
-	wstats->qual.updated = 0x0f;
-#endif
 	return wstats;
 }
 //#endif
--- a/drivers/staging/rtl8192e/r8192_pm.c
+++ b/drivers/staging/rtl8192e/r8192_pm.c
@@ -55,26 +55,12 @@ int rtl8192E_suspend (struct pci_dev *pd
         write_nic_dword(dev,ISR,read_nic_dword(dev, ISR));
 
 	/* need to  free DM related functions */
-#if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
 	cancel_work_sync(&priv->reset_wq);
-#else
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-	cancel_delayed_work(&priv->reset_wq);
-#endif
-#endif
 	del_timer_sync(&priv->fsync_timer);
 	del_timer_sync(&priv->watch_dog_timer);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	cancel_delayed_work(&priv->watch_dog_wq);
 	cancel_delayed_work(&priv->update_beacon_wq);
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	cancel_work_sync(&priv->qos_activate);
-#else
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-	cancel_delayed_work(&priv->qos_activate);
-#endif
-#endif
 
 	/* TODO
 #if ((DEV_BUS_TYPE == PCI_INTERFACE) && (HAL_CODE_BASE == RTL8192))
--- a/drivers/staging/rtl8192e/r819xE_firmware.c
+++ b/drivers/staging/rtl8192e/r819xE_firmware.c
@@ -20,9 +20,7 @@
 #include "r819xE_firmware_img.h"
 #endif
 #include "r819xE_firmware.h"
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 #include <linux/firmware.h>
-#endif
 
 void firmware_init_param(struct net_device *dev)
 {
@@ -254,11 +252,7 @@ bool init_firmware(struct net_device *de
 	 * Download boot, main, and data image for System reset.
 	 * Download data image for firmware reseta
 	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	priv->firmware_source = FW_SOURCE_HEADER_FILE;
-#else
 	priv->firmware_source = FW_SOURCE_IMG_FILE;
-#endif
 	for(init_step = starting_state; init_step <= FW_INIT_STEP2_DATA; init_step++) {
 		/*
 		 * Open Image file, and map file to contineous memory if open file success.
@@ -268,7 +262,6 @@ bool init_firmware(struct net_device *de
 			switch(priv->firmware_source) {
 				case FW_SOURCE_IMG_FILE:
 				{
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 					if(pfirmware->firmware_buf_size[init_step] == 0) {
 						rc = request_firmware(&fw_entry, fw_name[init_step],&priv->pdev->dev);
 						if(rc < 0 ) {
@@ -300,15 +293,12 @@ bool init_firmware(struct net_device *de
 						}
 						//pfirmware->firmware_buf_size = file_length;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 						if(rst_opt == OPT_SYSTEM_RESET) {
 							release_firmware(fw_entry);
 						}
-#endif
 					}
 					mapped_file = pfirmware->firmware_buf[init_step];
 					file_length = pfirmware->firmware_buf_size[init_step];
-#endif
 					break;
 				}
 				case FW_SOURCE_HEADER_FILE:
