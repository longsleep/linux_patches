From bgmerrell@novell.com  Mon Jul 27 08:46:39 2009
From: "Brian G. Merrell" <bgmerrell@novell.com>
Date: Tue, 21 Jul 2009 00:46:13 -0600
Subject: Staging: USB-IP code cleanup
To: Greg KH <gregkh@suse.de>
Message-ID: <20090721064611.GA8597@novell.com>


From: Brian G. Merrell <bgmerrell@novell.com>

This includes fixes for all of the legit checkpatch.pl errors and
warnings.  I have also included several of the suggestions from the
linux-kernel mailing list when the USB-IP code was first added.

Signed-off-by: Brian G. Merrell <bgmerrell@novell.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/usbip/Kconfig        |    2 
 drivers/staging/usbip/stub_dev.c     |   16 +-
 drivers/staging/usbip/stub_main.c    |    8 -
 drivers/staging/usbip/stub_rx.c      |   49 ++++---
 drivers/staging/usbip/stub_tx.c      |   26 ++-
 drivers/staging/usbip/usbip_common.c |  228 ++++++++++++++++-------------------
 drivers/staging/usbip/usbip_common.h |   96 +++++++-------
 drivers/staging/usbip/usbip_event.c  |   37 +++--
 drivers/staging/usbip/vhci_hcd.c     |  152 ++++++++++++-----------
 drivers/staging/usbip/vhci_rx.c      |   41 +++---
 drivers/staging/usbip/vhci_sysfs.c   |   22 +--
 drivers/staging/usbip/vhci_tx.c      |   22 +--
 12 files changed, 361 insertions(+), 338 deletions(-)

--- a/drivers/staging/usbip/Kconfig
+++ b/drivers/staging/usbip/Kconfig
@@ -6,7 +6,7 @@ config USB_IP_COMMON
 	  This enables pushing USB packets over IP to allow remote
 	  machines access to USB devices directly.  For more details,
 	  and links to the userspace utility programs to let this work
-	  properly, see http://usbip.naist.jp/
+	  properly, see http://usbip.sourceforge.net/.
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called usbip_common_mod.
--- a/drivers/staging/usbip/stub_dev.c
+++ b/drivers/staging/usbip/stub_dev.c
@@ -211,7 +211,7 @@ static void stub_shutdown_connection(str
 	 * step 1?
 	 */
 	if (ud->tcp_socket) {
-		udbg("shutdown tcp_socket %p\n", ud->tcp_socket);
+		usbip_udbg("shutdown tcp_socket %p\n", ud->tcp_socket);
 		kernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);
 	}
 
@@ -259,7 +259,7 @@ static void stub_device_reset(struct usb
 	struct usb_device *udev = interface_to_usbdev(sdev->interface);
 	int ret;
 
-	udbg("device reset");
+	usbip_udbg("device reset");
 	ret = usb_lock_device_for_reset(udev, sdev->interface);
 	if (ret < 0) {
 		dev_err(&udev->dev, "lock for reset\n");
@@ -356,7 +356,7 @@ static struct stub_device *stub_device_a
 
 	usbip_start_eh(&sdev->ud);
 
-	udbg("register new interface\n");
+	usbip_udbg("register new interface\n");
 	return sdev;
 }
 
@@ -366,7 +366,7 @@ static int stub_device_free(struct stub_
 		return -EINVAL;
 
 	kfree(sdev);
-	udbg("kfree udev ok\n");
+	usbip_udbg("kfree udev ok\n");
 
 	return 0;
 }
@@ -409,13 +409,13 @@ static int stub_probe(struct usb_interfa
 	}
 
 	if (udev->descriptor.bDeviceClass ==  USB_CLASS_HUB) {
-		udbg("this device %s is a usb hub device. skip!\n",
+		usbip_udbg("this device %s is a usb hub device. skip!\n",
 								udev_busid);
 		return -ENODEV;
 	}
 
 	if (!strcmp(udev->bus->bus_name, "vhci_hcd")) {
-		udbg("this device %s is attached on vhci_hcd. skip!\n",
+		usbip_udbg("this device %s is attached on vhci_hcd. skip!\n",
 								udev_busid);
 		return -ENODEV;
 	}
@@ -451,7 +451,7 @@ static void stub_disconnect(struct usb_i
 {
 	struct stub_device *sdev = usb_get_intfdata(interface);
 
-	udbg("Enter\n");
+	usbip_udbg("Enter\n");
 
 	/* get stub_device */
 	if (!sdev) {
@@ -479,5 +479,5 @@ static void stub_disconnect(struct usb_i
 	stub_device_free(sdev);
 
 
-	udbg("bye\n");
+	usbip_udbg("bye\n");
 }
--- a/drivers/staging/usbip/stub_main.c
+++ b/drivers/staging/usbip/stub_main.c
@@ -145,14 +145,14 @@ static ssize_t store_match_busid(struct 
 		if (add_match_busid(busid) < 0)
 			return -ENOMEM;
 		else {
-			udbg("add busid %s\n", busid);
+			usbip_udbg("add busid %s\n", busid);
 			return count;
 		}
 	} else if (!strncmp(buf, "del ", 4)) {
 		if (del_match_busid(busid) < 0)
 			return -ENODEV;
 		else {
-			udbg("del busid %s\n", busid);
+			usbip_udbg("del busid %s\n", busid);
 			return count;
 		}
 	} else
@@ -213,12 +213,12 @@ void stub_device_cleanup_urbs(struct stu
 {
 	struct stub_priv *priv;
 
-	udbg("free sdev %p\n", sdev);
+	usbip_udbg("free sdev %p\n", sdev);
 
 	while ((priv = stub_priv_pop(sdev))) {
 		struct urb *urb = priv->urb;
 
-		udbg("   free urb %p\n", urb);
+		usbip_udbg("   free urb %p\n", urb);
 		usb_kill_urb(urb);
 
 		kmem_cache_free(stub_priv_cache, priv);
--- a/drivers/staging/usbip/stub_rx.c
+++ b/drivers/staging/usbip/stub_rx.c
@@ -65,8 +65,8 @@ static int is_reset_device_cmd(struct ur
 
 	if ((req->bRequest == USB_REQ_SET_FEATURE) &&
 			(req->bRequestType == USB_RT_PORT) &&
-			(value = USB_PORT_FEAT_RESET)) {
-		dbg_stub_rx("reset_device_cmd, port %u\n", index);
+			(value == USB_PORT_FEAT_RESET)) {
+		usbip_dbg_stub_rx("reset_device_cmd, port %u\n", index);
 		return 1;
 	} else
 		return 0;
@@ -99,11 +99,11 @@ static int tweak_clear_halt_cmd(struct u
 
 	ret = usb_clear_halt(urb->dev, target_pipe);
 	if (ret < 0)
-		uinfo("clear_halt error: devnum %d endp %d, %d\n",
-				urb->dev->devnum, target_endp, ret);
+		usbip_uinfo("clear_halt error: devnum %d endp %d, %d\n",
+					urb->dev->devnum, target_endp, ret);
 	else
-		uinfo("clear_halt done: devnum %d endp %d\n",
-				urb->dev->devnum, target_endp);
+		usbip_uinfo("clear_halt done: devnum %d endp %d\n",
+					urb->dev->devnum, target_endp);
 
 	return ret;
 }
@@ -119,14 +119,15 @@ static int tweak_set_interface_cmd(struc
 	alternate = le16_to_cpu(req->wValue);
 	interface = le16_to_cpu(req->wIndex);
 
-	dbg_stub_rx("set_interface: inf %u alt %u\n", interface, alternate);
+	usbip_dbg_stub_rx("set_interface: inf %u alt %u\n", interface,
+								alternate);
 
 	ret = usb_set_interface(urb->dev, interface, alternate);
 	if (ret < 0)
-		uinfo("set_interface error: inf %u alt %u, %d\n",
-				interface, alternate, ret);
+		usbip_uinfo("set_interface error: inf %u alt %u, %d\n",
+					interface, alternate, ret);
 	else
-		uinfo("set_interface done: inf %u alt %u\n",
+		usbip_uinfo("set_interface done: inf %u alt %u\n",
 							interface,
 							alternate);
 
@@ -157,8 +158,9 @@ static int tweak_set_configuration_cmd(s
 	 * A user may need to set a special configuration value before
 	 * exporting the device.
 	 */
-	uinfo("set_configuration (%d) to %s\n", config, dev_name(&urb->dev->dev));
-	uinfo("but, skip!\n");
+	usbip_uinfo("set_configuration (%d) to %s\n", config,
+						dev_name(&urb->dev->dev));
+	usbip_uinfo("but, skip!\n");
 
 	return 0;
 	/* return usb_driver_set_configuration(urb->dev, config); */
@@ -175,7 +177,8 @@ static int tweak_reset_device_cmd(struct
 	value = le16_to_cpu(req->wValue);
 	index = le16_to_cpu(req->wIndex);
 
-	uinfo("reset_device (port %d) to %s\n", index, dev_name(&urb->dev->dev));
+	usbip_uinfo("reset_device (port %d) to %s\n", index,
+						dev_name(&urb->dev->dev));
 
 	/* all interfaces should be owned by usbip driver, so just reset it.  */
 	ret = usb_lock_device_for_reset(urb->dev, NULL);
@@ -220,7 +223,7 @@ static void tweak_special_requests(struc
 	else if (is_reset_device_cmd(urb))
 		tweak_reset_device_cmd(urb);
 	else
-		dbg_stub_rx("no need to tweak\n");
+		usbip_dbg_stub_rx("no need to tweak\n");
 }
 
 /*
@@ -292,7 +295,8 @@ static int stub_recv_cmd_unlink(struct s
 		}
 	}
 
-	dbg_stub_rx("seqnum %d is not pending\n", pdu->u.cmd_unlink.seqnum);
+	usbip_dbg_stub_rx("seqnum %d is not pending\n",
+						pdu->u.cmd_unlink.seqnum);
 
 	/*
 	 * The urb of the unlink target is not found in priv_init queue. It was
@@ -383,7 +387,7 @@ static struct usb_host_endpoint *get_ep_
 			epnum = (ep->desc.bEndpointAddress & 0x7f);
 
 			if (epnum == epnum0) {
-				/* uinfo("found epnum %d\n", epnum0); */
+				/* usbip_uinfo("found epnum %d\n", epnum0);*/
 				found = 1;
 				break;
 			}
@@ -526,7 +530,8 @@ static void stub_recv_cmd_submit(struct 
 	ret = usb_submit_urb(priv->urb, GFP_KERNEL);
 
 	if (ret == 0)
-		dbg_stub_rx("submit urb ok, seqnum %u\n", pdu->base.seqnum);
+		usbip_dbg_stub_rx("submit urb ok, seqnum %u\n",
+							pdu->base.seqnum);
 	else {
 		dev_err(&sdev->interface->dev, "submit_urb error, %d\n", ret);
 		usbip_dump_header(pdu);
@@ -539,7 +544,7 @@ static void stub_recv_cmd_submit(struct 
 		usbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT);
 	}
 
-	dbg_stub_rx("Leave\n");
+	usbip_dbg_stub_rx("Leave\n");
 	return;
 }
 
@@ -551,7 +556,7 @@ static void stub_rx_pdu(struct usbip_dev
 	struct stub_device *sdev = container_of(ud, struct stub_device, ud);
 	struct device *dev = &sdev->interface->dev;
 
-	dbg_stub_rx("Enter\n");
+	usbip_dbg_stub_rx("Enter\n");
 
 	memset(&pdu, 0, sizeof(pdu));
 
@@ -565,7 +570,7 @@ static void stub_rx_pdu(struct usbip_dev
 
 	usbip_header_correct_endian(&pdu, 0);
 
-	if (dbg_flag_stub_rx)
+	if (usbip_dbg_flag_stub_rx)
 		usbip_dump_header(&pdu);
 
 	if (!valid_request(sdev, &pdu)) {
@@ -598,11 +603,11 @@ void stub_rx_loop(struct usbip_task *ut)
 
 	while (1) {
 		if (signal_pending(current)) {
-			dbg_stub_rx("signal caught!\n");
+			usbip_dbg_stub_rx("signal caught!\n");
 			break;
 		}
 
-		if (usbip_event_happend(ud))
+		if (usbip_event_happened(ud))
 			break;
 
 		stub_rx_pdu(ud);
--- a/drivers/staging/usbip/stub_tx.c
+++ b/drivers/staging/usbip/stub_tx.c
@@ -66,7 +66,7 @@ void stub_complete(struct urb *urb)
 	struct stub_device *sdev = priv->sdev;
 	unsigned long flags;
 
-	dbg_stub_tx("complete! status %d\n", urb->status);
+	usbip_dbg_stub_tx("complete! status %d\n", urb->status);
 
 
 	switch (urb->status) {
@@ -74,20 +74,22 @@ void stub_complete(struct urb *urb)
 		/* OK */
 		break;
 	case -ENOENT:
-		uinfo("stopped by a call of usb_kill_urb() because of"
+		usbip_uinfo("stopped by a call of usb_kill_urb() because of"
 					"cleaning up a virtual connection\n");
 		return;
 	case -ECONNRESET:
-		uinfo("unlinked by a call of usb_unlink_urb()\n");
+		usbip_uinfo("unlinked by a call of usb_unlink_urb()\n");
 		break;
 	case -EPIPE:
-		uinfo("endpoint %d is stalled\n", usb_pipeendpoint(urb->pipe));
+		usbip_uinfo("endpoint %d is stalled\n",
+						usb_pipeendpoint(urb->pipe));
 		break;
 	case -ESHUTDOWN:
-		uinfo("device removed?\n");
+		usbip_uinfo("device removed?\n");
 		break;
 	default:
-		uinfo("urb completion with non-zero status %d\n", urb->status);
+		usbip_uinfo("urb completion with non-zero status %d\n",
+							urb->status);
 	}
 
 	/* link a urb to the queue of tx. */
@@ -181,7 +183,7 @@ static int stub_send_ret_submit(struct s
 		memset(&msg, 0, sizeof(msg));
 		memset(&iov, 0, sizeof(iov));
 
-		dbg_stub_tx("setup txdata urb %p\n", urb);
+		usbip_dbg_stub_tx("setup txdata urb %p\n", urb);
 
 
 		/* 1. setup usbip_header */
@@ -227,7 +229,7 @@ static int stub_send_ret_submit(struct s
 		}
 
 		kfree(iso_buffer);
-		dbg_stub_tx("send txdata\n");
+		usbip_dbg_stub_tx("send txdata\n");
 
 		total_size += txsize;
 	}
@@ -287,7 +289,7 @@ static int stub_send_ret_unlink(struct s
 		memset(&msg, 0, sizeof(msg));
 		memset(&iov, 0, sizeof(iov));
 
-		dbg_stub_tx("setup ret unlink %lu\n", unlink->seqnum);
+		usbip_dbg_stub_tx("setup ret unlink %lu\n", unlink->seqnum);
 
 		/* 1. setup usbip_header */
 		setup_ret_unlink_pdu(&pdu_header, unlink);
@@ -308,7 +310,7 @@ static int stub_send_ret_unlink(struct s
 		}
 
 
-		dbg_stub_tx("send txdata\n");
+		usbip_dbg_stub_tx("send txdata\n");
 
 		total_size += txsize;
 	}
@@ -336,11 +338,11 @@ void stub_tx_loop(struct usbip_task *ut)
 
 	while (1) {
 		if (signal_pending(current)) {
-			dbg_stub_tx("signal catched\n");
+			usbip_dbg_stub_tx("signal catched\n");
 			break;
 		}
 
-		if (usbip_event_happend(ud))
+		if (usbip_event_happened(ud))
 			break;
 
 		/*
--- a/drivers/staging/usbip/usbip_common.c
+++ b/drivers/staging/usbip/usbip_common.c
@@ -22,6 +22,7 @@
 #include <linux/file.h>
 #include <linux/tcp.h>
 #include <linux/in.h>
+#include <linux/kthread.h>
 #include "usbip_common.h"
 
 /* version information */
@@ -70,27 +71,27 @@ static void usbip_dump_buffer(char *buff
 	if (bufflen > 128) {
 		for (i = 0; i < 128; i++) {
 			if (i%24 == 0)
-				printk("   ");
-			printk("%02x ", (unsigned char) buff[i]);
+				printk(KERN_DEBUG "   ");
+			printk(KERN_DEBUG "%02x ", (unsigned char) buff[i]);
 			if (i%4 == 3)
-				printk("| ");
+				printk(KERN_DEBUG "| ");
 			if (i%24 == 23)
-				printk("\n");
+				printk(KERN_DEBUG "\n");
 		}
-		printk("... (%d byte)\n", bufflen);
+		printk(KERN_DEBUG "... (%d byte)\n", bufflen);
 		return;
 	}
 
 	for (i = 0; i < bufflen; i++) {
 		if (i%24 == 0)
-			printk("   ");
-		printk("%02x ", (unsigned char) buff[i]);
+			printk(KERN_DEBUG "   ");
+		printk(KERN_DEBUG "%02x ", (unsigned char) buff[i]);
 		if (i%4 == 3)
-			printk("| ");
+			printk(KERN_DEBUG "| ");
 		if (i%24 == 23)
-			printk("\n");
+			printk(KERN_DEBUG "\n");
 	}
-	printk("\n");
+	printk(KERN_DEBUG "\n");
 
 }
 
@@ -101,28 +102,28 @@ static void usbip_dump_pipe(unsigned int
 	unsigned char dev = usb_pipedevice(p);
 	unsigned char dir = usb_pipein(p);
 
-	printk("dev(%d) ", dev);
-	printk("ep(%d) ",  ep);
-	printk("%s ", dir ? "IN" : "OUT");
+	printk(KERN_DEBUG "dev(%d) ", dev);
+	printk(KERN_DEBUG "ep(%d) ",  ep);
+	printk(KERN_DEBUG "%s ", dir ? "IN" : "OUT");
 
 	switch (type) {
 	case PIPE_ISOCHRONOUS:
-		printk("%s ", "ISO");
+		printk(KERN_DEBUG "%s ", "ISO");
 		break;
 	case PIPE_INTERRUPT:
-		printk("%s ", "INT");
+		printk(KERN_DEBUG "%s ", "INT");
 		break;
 	case PIPE_CONTROL:
-		printk("%s ", "CTL");
+		printk(KERN_DEBUG "%s ", "CTL");
 		break;
 	case PIPE_BULK:
-		printk("%s ", "BLK");
+		printk(KERN_DEBUG "%s ", "BLK");
 		break;
 	default:
-		printk("ERR");
+		printk(KERN_DEBUG "ERR");
 	}
 
-	printk("\n");
+	printk(KERN_DEBUG "\n");
 
 }
 
@@ -136,55 +137,55 @@ static void usbip_dump_usb_device(struct
 
 	switch (udev->speed) {
 	case USB_SPEED_HIGH:
-		printk(" SPD_HIGH");
+		printk(KERN_DEBUG " SPD_HIGH");
 		break;
 	case USB_SPEED_FULL:
-		printk(" SPD_FULL");
+		printk(KERN_DEBUG " SPD_FULL");
 		break;
 	case USB_SPEED_LOW:
-		printk(" SPD_LOW");
+		printk(KERN_DEBUG " SPD_LOW");
 		break;
 	case USB_SPEED_UNKNOWN:
-		printk(" SPD_UNKNOWN");
+		printk(KERN_DEBUG " SPD_UNKNOWN");
 		break;
 	default:
-		printk(" SPD_ERROR");
+		printk(KERN_DEBUG " SPD_ERROR");
 	}
 
-	printk(" tt %p, ttport %d", udev->tt, udev->ttport);
-	printk("\n");
+	printk(KERN_DEBUG " tt %p, ttport %d", udev->tt, udev->ttport);
+	printk(KERN_DEBUG "\n");
 
 	dev_dbg(dev, "                    ");
 	for (i = 0; i < 16; i++)
-		printk(" %2u", i);
-	printk("\n");
+		printk(KERN_DEBUG " %2u", i);
+	printk(KERN_DEBUG "\n");
 
 	dev_dbg(dev, "       toggle0(IN) :");
 	for (i = 0; i < 16; i++)
-		printk(" %2u", (udev->toggle[0] & (1 << i)) ? 1 : 0);
-	printk("\n");
+		printk(KERN_DEBUG " %2u", (udev->toggle[0] & (1 << i)) ? 1 : 0);
+	printk(KERN_DEBUG "\n");
 
 	dev_dbg(dev, "       toggle1(OUT):");
 	for (i = 0; i < 16; i++)
-		printk(" %2u", (udev->toggle[1] & (1 << i)) ? 1 : 0);
-	printk("\n");
+		printk(KERN_DEBUG " %2u", (udev->toggle[1] & (1 << i)) ? 1 : 0);
+	printk(KERN_DEBUG "\n");
 
 
 	dev_dbg(dev, "       epmaxp_in   :");
 	for (i = 0; i < 16; i++) {
 		if (udev->ep_in[i])
-			printk(" %2u",
+			printk(KERN_DEBUG " %2u",
 			     le16_to_cpu(udev->ep_in[i]->desc.wMaxPacketSize));
 	}
-	printk("\n");
+	printk(KERN_DEBUG "\n");
 
 	dev_dbg(dev, "       epmaxp_out  :");
 	for (i = 0; i < 16; i++) {
 		if (udev->ep_out[i])
-			printk(" %2u",
+			printk(KERN_DEBUG " %2u",
 			     le16_to_cpu(udev->ep_out[i]->desc.wMaxPacketSize));
 	}
-	printk("\n");
+	printk(KERN_DEBUG "\n");
 
 	dev_dbg(dev, "parent %p, bus %p\n", udev->parent, udev->bus);
 
@@ -203,91 +204,91 @@ static void usbip_dump_request_type(__u8
 {
 	switch (rt & USB_RECIP_MASK) {
 	case USB_RECIP_DEVICE:
-		printk("DEVICE");
+		printk(KERN_DEBUG "DEVICE");
 		break;
 	case USB_RECIP_INTERFACE:
-		printk("INTERF");
+		printk(KERN_DEBUG "INTERF");
 		break;
 	case USB_RECIP_ENDPOINT:
-		printk("ENDPOI");
+		printk(KERN_DEBUG "ENDPOI");
 		break;
 	case USB_RECIP_OTHER:
-		printk("OTHER ");
+		printk(KERN_DEBUG "OTHER ");
 		break;
 	default:
-		printk("------");
+		printk(KERN_DEBUG "------");
 	}
 }
 
 static void usbip_dump_usb_ctrlrequest(struct usb_ctrlrequest *cmd)
 {
 	if (!cmd) {
-		printk("      %s : null pointer\n", __func__);
+		printk(KERN_DEBUG "      %s : null pointer\n", __func__);
 		return;
 	}
 
-	printk("       ");
-	printk("bRequestType(%02X) ", cmd->bRequestType);
-	printk("bRequest(%02X) " , cmd->bRequest);
-	printk("wValue(%04X) ", cmd->wValue);
-	printk("wIndex(%04X) ", cmd->wIndex);
-	printk("wLength(%04X) ", cmd->wLength);
+	printk(KERN_DEBUG "       ");
+	printk(KERN_DEBUG "bRequestType(%02X) ", cmd->bRequestType);
+	printk(KERN_DEBUG "bRequest(%02X) " , cmd->bRequest);
+	printk(KERN_DEBUG "wValue(%04X) ", cmd->wValue);
+	printk(KERN_DEBUG "wIndex(%04X) ", cmd->wIndex);
+	printk(KERN_DEBUG "wLength(%04X) ", cmd->wLength);
 
-	printk("\n       ");
+	printk(KERN_DEBUG "\n       ");
 
 	if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
-		printk("STANDARD ");
+		printk(KERN_DEBUG "STANDARD ");
 		switch (cmd->bRequest) {
 		case USB_REQ_GET_STATUS:
-			printk("GET_STATUS");
+			printk(KERN_DEBUG "GET_STATUS");
 			break;
 		case USB_REQ_CLEAR_FEATURE:
-			printk("CLEAR_FEAT");
+			printk(KERN_DEBUG "CLEAR_FEAT");
 			break;
 		case USB_REQ_SET_FEATURE:
-			printk("SET_FEAT  ");
+			printk(KERN_DEBUG "SET_FEAT  ");
 			break;
 		case USB_REQ_SET_ADDRESS:
-			printk("SET_ADDRRS");
+			printk(KERN_DEBUG "SET_ADDRRS");
 			break;
 		case USB_REQ_GET_DESCRIPTOR:
-			printk("GET_DESCRI");
+			printk(KERN_DEBUG "GET_DESCRI");
 			break;
 		case USB_REQ_SET_DESCRIPTOR:
-			printk("SET_DESCRI");
+			printk(KERN_DEBUG "SET_DESCRI");
 			break;
 		case USB_REQ_GET_CONFIGURATION:
-			printk("GET_CONFIG");
+			printk(KERN_DEBUG "GET_CONFIG");
 			break;
 		case USB_REQ_SET_CONFIGURATION:
-			printk("SET_CONFIG");
+			printk(KERN_DEBUG "SET_CONFIG");
 			break;
 		case USB_REQ_GET_INTERFACE:
-			printk("GET_INTERF");
+			printk(KERN_DEBUG "GET_INTERF");
 			break;
 		case USB_REQ_SET_INTERFACE:
-			printk("SET_INTERF");
+			printk(KERN_DEBUG "SET_INTERF");
 			break;
 		case USB_REQ_SYNCH_FRAME:
-			printk("SYNC_FRAME");
+			printk(KERN_DEBUG "SYNC_FRAME");
 			break;
 		default:
-			printk("REQ(%02X) ", cmd->bRequest);
+			printk(KERN_DEBUG "REQ(%02X) ", cmd->bRequest);
 		}
 
-		printk(" ");
+		printk(KERN_DEBUG " ");
 		usbip_dump_request_type(cmd->bRequestType);
 
 	} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS)
-		printk("CLASS   ");
+		printk(KERN_DEBUG "CLASS   ");
 
 	else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR)
-		printk("VENDOR  ");
+		printk(KERN_DEBUG "VENDOR  ");
 
 	else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_RESERVED)
-		printk("RESERVED");
+		printk(KERN_DEBUG "RESERVED");
 
-	printk("\n");
+	printk(KERN_DEBUG "\n");
 }
 
 void usbip_dump_urb(struct urb *urb)
@@ -319,7 +320,8 @@ void usbip_dump_urb(struct urb *urb)
 	dev_dbg(dev, "   status                :%d\n", urb->status);
 	dev_dbg(dev, "   transfer_flags        :%08X\n", urb->transfer_flags);
 	dev_dbg(dev, "   transfer_buffer       :%p\n", urb->transfer_buffer);
-	dev_dbg(dev, "   transfer_buffer_length:%d\n", urb->transfer_buffer_length);
+	dev_dbg(dev, "   transfer_buffer_length:%d\n",
+						urb->transfer_buffer_length);
 	dev_dbg(dev, "   actual_length         :%d\n", urb->actual_length);
 	dev_dbg(dev, "   setup_packet          :%p\n", urb->setup_packet);
 
@@ -338,7 +340,7 @@ EXPORT_SYMBOL_GPL(usbip_dump_urb);
 
 void usbip_dump_header(struct usbip_header *pdu)
 {
-	udbg("BASE: cmd %u seq %u devid %u dir %u ep %u\n",
+	usbip_udbg("BASE: cmd %u seq %u devid %u dir %u ep %u\n",
 			pdu->base.command,
 			pdu->base.seqnum,
 			pdu->base.devid,
@@ -347,7 +349,8 @@ void usbip_dump_header(struct usbip_head
 
 	switch (pdu->base.command) {
 	case USBIP_CMD_SUBMIT:
-		udbg("CMD_SUBMIT: x_flags %u x_len %u sf %u #p %u iv %u\n",
+		usbip_udbg("CMD_SUBMIT: "
+				"x_flags %u x_len %u sf %u #p %u iv %u\n",
 				pdu->u.cmd_submit.transfer_flags,
 				pdu->u.cmd_submit.transfer_buffer_length,
 				pdu->u.cmd_submit.start_frame,
@@ -355,20 +358,20 @@ void usbip_dump_header(struct usbip_head
 				pdu->u.cmd_submit.interval);
 				break;
 	case USBIP_CMD_UNLINK:
-		udbg("CMD_UNLINK: seq %u\n", pdu->u.cmd_unlink.seqnum);
+		usbip_udbg("CMD_UNLINK: seq %u\n", pdu->u.cmd_unlink.seqnum);
 		break;
 	case USBIP_RET_SUBMIT:
-		udbg("RET_SUBMIT: st %d al %u sf %d ec %d\n",
+		usbip_udbg("RET_SUBMIT: st %d al %u sf %d ec %d\n",
 				pdu->u.ret_submit.status,
 				pdu->u.ret_submit.actual_length,
 				pdu->u.ret_submit.start_frame,
 				pdu->u.ret_submit.error_count);
 	case USBIP_RET_UNLINK:
-		udbg("RET_UNLINK: status %d\n", pdu->u.ret_unlink.status);
+		usbip_udbg("RET_UNLINK: status %d\n", pdu->u.ret_unlink.status);
 		break;
 	default:
 		/* NOT REACHED */
-		udbg("UNKNOWN\n");
+		usbip_udbg("UNKNOWN\n");
 	}
 }
 EXPORT_SYMBOL_GPL(usbip_dump_header);
@@ -402,29 +405,30 @@ int usbip_thread(void *param)
 	complete_and_exit(&ut->thread_done, 0);
 }
 
-void usbip_start_threads(struct usbip_device *ud)
+int usbip_start_threads(struct usbip_device *ud)
 {
 	/*
 	 * threads are invoked per one device (per one connection).
 	 */
-	int retval;
+	struct task_struct *th;
 
-	retval = kernel_thread(usbip_thread, (void *)&ud->tcp_rx, 0);
-	if (retval < 0) {
-		printk(KERN_ERR "Creating tcp_rx thread for ud %p failed.\n",
-				ud);
-		return;
-	}
-	retval = kernel_thread(usbip_thread, (void *)&ud->tcp_tx, 0);
-	if (retval < 0) {
-		printk(KERN_ERR "Creating tcp_tx thread for ud %p failed.\n",
-				ud);
-		return;
+	th = kthread_run(usbip_thread, (void *)&ud->tcp_rx, "usbip");
+	if (IS_ERR(th)) {
+		printk(KERN_WARNING
+			"Unable to start control thread\n");
+		return PTR_ERR(th);
+	}
+	th = kthread_run(usbip_thread, (void *)&ud->tcp_tx, "usbip");
+	if (IS_ERR(th)) {
+		printk(KERN_WARNING
+			"Unable to start control thread\n");
+		return PTR_ERR(th);
 	}
 
 	/* confirm threads are starting */
 	wait_for_completion(&ud->tcp_rx.thread_done);
 	wait_for_completion(&ud->tcp_tx.thread_done);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(usbip_start_threads);
 
@@ -434,13 +438,13 @@ void usbip_stop_threads(struct usbip_dev
 	if (ud->tcp_rx.thread != NULL) {
 		send_sig(SIGKILL, ud->tcp_rx.thread, 1);
 		wait_for_completion(&ud->tcp_rx.thread_done);
-		udbg("rx_thread for ud %p has finished\n", ud);
+		usbip_udbg("rx_thread for ud %p has finished\n", ud);
 	}
 
 	if (ud->tcp_tx.thread != NULL) {
 		send_sig(SIGKILL, ud->tcp_tx.thread, 1);
 		wait_for_completion(&ud->tcp_tx.thread_done);
-		udbg("tx_thread for ud %p has finished\n", ud);
+		usbip_udbg("tx_thread for ud %p has finished\n", ud);
 	}
 }
 EXPORT_SYMBOL_GPL(usbip_stop_threads);
@@ -468,11 +472,11 @@ int usbip_xmit(int send, struct socket *
 	struct kvec iov;
 	int total = 0;
 
-	/* for blocks of if (dbg_flag_xmit) */
+	/* for blocks of if (usbip_dbg_flag_xmit) */
 	char *bp = buf;
 	int osize = size;
 
-	dbg_xmit("enter\n");
+	usbip_dbg_xmit("enter\n");
 
 	if (!sock || !buf || !size) {
 		printk(KERN_ERR "%s: invalid arg, sock %p buff %p size %d\n",
@@ -481,14 +485,14 @@ int usbip_xmit(int send, struct socket *
 	}
 
 
-	if (dbg_flag_xmit) {
+	if (usbip_dbg_flag_xmit) {
 		if (send) {
 			if (!in_interrupt())
 				printk(KERN_DEBUG "%-10s:", current->comm);
 			else
-				printk(KERN_DEBUG "interupt  :");
+				printk(KERN_DEBUG "interrupt  :");
 
-			printk("%s: sending... , sock %p, buf %p, "
+			printk(KERN_DEBUG "%s: sending... , sock %p, buf %p, "
 			       "size %d, msg_flags %d\n", __func__,
 			       sock, buf, size, msg_flags);
 			usbip_dump_buffer(buf, size);
@@ -514,8 +518,8 @@ int usbip_xmit(int send, struct socket *
 								MSG_WAITALL);
 
 		if (result <= 0) {
-			udbg("usbip_xmit: %s sock %p buf %p size %u ret %d"
-					" total %d\n",
+			usbip_udbg("usbip_xmit: %s sock %p buf %p size %u ret "
+					"%d total %d\n",
 					send ? "send" : "receive", sock, buf,
 					size, result, total);
 			goto err;
@@ -528,22 +532,23 @@ int usbip_xmit(int send, struct socket *
 	} while (size > 0);
 
 
-	if (dbg_flag_xmit) {
+	if (usbip_dbg_flag_xmit) {
 		if (!send) {
 			if (!in_interrupt())
 				printk(KERN_DEBUG "%-10s:", current->comm);
 			else
-				printk(KERN_DEBUG "interupt  :");
+				printk(KERN_DEBUG "interrupt  :");
 
-			printk("usbip_xmit: receiving....\n");
+			printk(KERN_DEBUG "usbip_xmit: receiving....\n");
 			usbip_dump_buffer(bp, osize);
-			printk("usbip_xmit: received, osize %d ret %d size %d "
-					"total %d\n", osize, result, size,
-					total);
+			printk(KERN_DEBUG "usbip_xmit: received, osize %d ret "
+					"%d size %d total %d\n", osize, result,
+					size, total);
 		}
 
 		if (send)
-			printk("usbip_xmit: send, total %d\n", total);
+			printk(KERN_DEBUG "usbip_xmit: send, total %d\n",
+									total);
 	}
 
 	return total;
@@ -638,19 +643,7 @@ EXPORT_SYMBOL_GPL(sockfd_to_socket);
 /* there may be more cases to tweak the flags. */
 static unsigned int tweak_transfer_flags(unsigned int flags)
 {
-
-	if (flags & URB_NO_TRANSFER_DMA_MAP)
-		/*
-		 * vhci_hcd does not provide DMA-mapped I/O. The upper
-		 * driver does not need to set this flag. The remote
-		 * usbip.ko does not still perform DMA-mapped I/O for
-		 * DMA-caplable host controllers. So, clear this flag.
-		 */
-		flags &= ~URB_NO_TRANSFER_DMA_MAP;
-
-	if (flags & URB_NO_SETUP_DMA_MAP)
-		flags &= ~URB_NO_SETUP_DMA_MAP;
-
+	flags &= ~(URB_NO_TRANSFER_DMA_MAP|URB_NO_SETUP_DMA_MAP);
 	return flags;
 }
 
@@ -904,7 +897,7 @@ int usbip_recv_iso(struct usbip_device *
 
 	/* my Bluetooth dongle gets ISO URBs which are np = 0 */
 	if (np == 0) {
-		/* uinfo("iso np == 0\n"); */
+		/* usbip_uinfo("iso np == 0\n"); */
 		/* usbip_dump_urb(urb); */
 		return 0;
 	}
@@ -934,7 +927,6 @@ int usbip_recv_iso(struct usbip_device *
 		usbip_pack_iso(iso, &urb->iso_frame_desc[i], 0);
 	}
 
-
 	kfree(buff);
 
 	return ret;
--- a/drivers/staging/usbip/usbip_common.h
+++ b/drivers/staging/usbip/usbip_common.h
@@ -33,23 +33,23 @@
  */
 
 /**
- * udbg - print debug messages if CONFIG_USB_DEBUG is defined
+ * usbip_udbg - print debug messages if CONFIG_USB_DEBUG is defined
  * @fmt:
  * @args:
  */
 
 #ifdef CONFIG_USB_DEBUG
 
-#define udbg(fmt, args...)						\
+#define usbip_udbg(fmt, args...)					\
 	do {								\
 		printk(KERN_DEBUG "%-10s:(%s,%d) %s: " fmt,		\
 			(in_interrupt() ? "interrupt" : (current)->comm),\
-			__FILE__, __LINE__, __func__, ##args);	\
+			__FILE__, __LINE__, __func__, ##args);		\
 	} while (0)
 
 #else  /* CONFIG_USB_DEBUG */
 
-#define udbg(fmt, args...)		do { } while (0)
+#define usbip_udbg(fmt, args...)		do { } while (0)
 
 #endif /* CONFIG_USB_DEBUG */
 
@@ -72,58 +72,58 @@ enum {
 	usbip_debug_vhci_sysfs  = (1 << 12)
 };
 
-#define dbg_flag_xmit		(usbip_debug_flag & usbip_debug_xmit)
-#define dbg_flag_vhci_rh	(usbip_debug_flag & usbip_debug_vhci_rh)
-#define dbg_flag_vhci_hc	(usbip_debug_flag & usbip_debug_vhci_hc)
-#define dbg_flag_vhci_rx	(usbip_debug_flag & usbip_debug_vhci_rx)
-#define dbg_flag_vhci_tx	(usbip_debug_flag & usbip_debug_vhci_tx)
-#define dbg_flag_vhci_sysfs	(usbip_debug_flag & usbip_debug_vhci_sysfs)
-#define dbg_flag_stub_rx	(usbip_debug_flag & usbip_debug_stub_rx)
-#define dbg_flag_stub_tx	(usbip_debug_flag & usbip_debug_stub_tx)
+#define usbip_dbg_flag_xmit	(usbip_debug_flag & usbip_debug_xmit)
+#define usbip_dbg_flag_vhci_rh	(usbip_debug_flag & usbip_debug_vhci_rh)
+#define usbip_dbg_flag_vhci_hc	(usbip_debug_flag & usbip_debug_vhci_hc)
+#define usbip_dbg_flag_vhci_rx	(usbip_debug_flag & usbip_debug_vhci_rx)
+#define usbip_dbg_flag_vhci_tx	(usbip_debug_flag & usbip_debug_vhci_tx)
+#define usbip_dbg_flag_stub_rx	(usbip_debug_flag & usbip_debug_stub_rx)
+#define usbip_dbg_flag_stub_tx	(usbip_debug_flag & usbip_debug_stub_tx)
+#define usbip_dbg_flag_vhci_sysfs   (usbip_debug_flag & usbip_debug_vhci_sysfs)
 
 extern unsigned long usbip_debug_flag;
 extern struct device_attribute dev_attr_usbip_debug;
 
-#define dbg_with_flag(flag, fmt, args...)		\
+#define usbip_dbg_with_flag(flag, fmt, args...)		\
 	do {						\
 		if (flag & usbip_debug_flag)		\
-			udbg(fmt , ##args);		\
+			usbip_udbg(fmt , ##args);		\
 	} while (0)
 
-#define dbg_sysfs(fmt, args...)		\
-	dbg_with_flag(usbip_debug_sysfs, fmt , ##args)
-#define dbg_xmit(fmt, args...)		\
-	dbg_with_flag(usbip_debug_xmit, fmt , ##args)
-#define dbg_urb(fmt, args...)		\
-	dbg_with_flag(usbip_debug_urb, fmt , ##args)
-#define dbg_eh(fmt, args...)		\
-	dbg_with_flag(usbip_debug_eh, fmt , ##args)
-
-#define dbg_vhci_rh(fmt, args...)	\
-	dbg_with_flag(usbip_debug_vhci_rh, fmt , ##args)
-#define dbg_vhci_hc(fmt, args...)	\
-	dbg_with_flag(usbip_debug_vhci_hc, fmt , ##args)
-#define dbg_vhci_rx(fmt, args...)	\
-	dbg_with_flag(usbip_debug_vhci_rx, fmt , ##args)
-#define dbg_vhci_tx(fmt, args...)	\
-	dbg_with_flag(usbip_debug_vhci_tx, fmt , ##args)
-#define dbg_vhci_sysfs(fmt, args...)	\
-	dbg_with_flag(usbip_debug_vhci_sysfs, fmt , ##args)
-
-#define dbg_stub_cmp(fmt, args...)	\
-	dbg_with_flag(usbip_debug_stub_cmp, fmt , ##args)
-#define dbg_stub_rx(fmt, args...)	\
-	dbg_with_flag(usbip_debug_stub_rx, fmt , ##args)
-#define dbg_stub_tx(fmt, args...)	\
-	dbg_with_flag(usbip_debug_stub_tx, fmt , ##args)
+#define usbip_dbg_sysfs(fmt, args...)		\
+	usbip_dbg_with_flag(usbip_debug_sysfs, fmt , ##args)
+#define usbip_dbg_xmit(fmt, args...)		\
+	usbip_dbg_with_flag(usbip_debug_xmit, fmt , ##args)
+#define usbip_dbg_urb(fmt, args...)		\
+	usbip_dbg_with_flag(usbip_debug_urb, fmt , ##args)
+#define usbip_dbg_eh(fmt, args...)		\
+	usbip_dbg_with_flag(usbip_debug_eh, fmt , ##args)
+
+#define usbip_dbg_vhci_rh(fmt, args...)	\
+	usbip_dbg_with_flag(usbip_debug_vhci_rh, fmt , ##args)
+#define usbip_dbg_vhci_hc(fmt, args...)	\
+	usbip_dbg_with_flag(usbip_debug_vhci_hc, fmt , ##args)
+#define usbip_dbg_vhci_rx(fmt, args...)	\
+	usbip_dbg_with_flag(usbip_debug_vhci_rx, fmt , ##args)
+#define usbip_dbg_vhci_tx(fmt, args...)	\
+	usbip_dbg_with_flag(usbip_debug_vhci_tx, fmt , ##args)
+#define usbip_dbg_vhci_sysfs(fmt, args...)	\
+	usbip_dbg_with_flag(usbip_debug_vhci_sysfs, fmt , ##args)
+
+#define usbip_dbg_stub_cmp(fmt, args...)	\
+	usbip_dbg_with_flag(usbip_debug_stub_cmp, fmt , ##args)
+#define usbip_dbg_stub_rx(fmt, args...)	\
+	usbip_dbg_with_flag(usbip_debug_stub_rx, fmt , ##args)
+#define usbip_dbg_stub_tx(fmt, args...)	\
+	usbip_dbg_with_flag(usbip_debug_stub_tx, fmt , ##args)
 
 
 /**
- * uerr - print error messages
+ * usbip_uerr - print error messages
  * @fmt:
  * @args:
  */
-#define uerr(fmt, args...)						\
+#define usbip_uerr(fmt, args...)					\
 	do {								\
 		printk(KERN_ERR "%-10s: ***ERROR*** (%s,%d) %s: " fmt,	\
 			(in_interrupt() ? "interrupt" : (current)->comm),\
@@ -131,11 +131,11 @@ extern struct device_attribute dev_attr_
 	} while (0)
 
 /**
- * uinfo - print information messages
+ * usbip_uinfo - print information messages
  * @fmt:
  * @args:
  */
-#define uinfo(fmt, args...)					\
+#define usbip_uinfo(fmt, args...)				\
 	do {							\
 		printk(KERN_INFO "usbip: " fmt , ## args);	\
 	} while (0)
@@ -355,7 +355,7 @@ struct usbip_device {
 #define USBIP_EH_RESET		(1 << 2)
 #define USBIP_EH_UNUSABLE	(1 << 3)
 
-#define SDEV_EVENT_REMOVED	(USBIP_EH_SHUTDOWN | USBIP_EH_RESET | USBIP_EH_BYE)
+#define SDEV_EVENT_REMOVED   (USBIP_EH_SHUTDOWN | USBIP_EH_RESET | USBIP_EH_BYE)
 #define	SDEV_EVENT_DOWN		(USBIP_EH_SHUTDOWN | USBIP_EH_RESET)
 #define	SDEV_EVENT_ERROR_TCP	(USBIP_EH_SHUTDOWN | USBIP_EH_RESET)
 #define	SDEV_EVENT_ERROR_SUBMIT	(USBIP_EH_SHUTDOWN | USBIP_EH_RESET)
@@ -381,7 +381,7 @@ struct usbip_device {
 void usbip_task_init(struct usbip_task *ut, char *,
 				void (*loop_ops)(struct usbip_task *));
 
-void usbip_start_threads(struct usbip_device *ud);
+int usbip_start_threads(struct usbip_device *ud);
 void usbip_stop_threads(struct usbip_device *ud);
 int usbip_thread(void *param);
 
@@ -397,10 +397,10 @@ void *usbip_alloc_iso_desc_pdu(struct ur
 
 
 /* usbip_event.c */
-void usbip_start_eh(struct usbip_device *ud);
+int usbip_start_eh(struct usbip_device *ud);
 void usbip_stop_eh(struct usbip_device *ud);
 void usbip_event_add(struct usbip_device *ud, unsigned long event);
-int usbip_event_happend(struct usbip_device *ud);
+int usbip_event_happened(struct usbip_device *ud);
 
 
 #endif
--- a/drivers/staging/usbip/usbip_event.c
+++ b/drivers/staging/usbip/usbip_event.c
@@ -18,16 +18,17 @@
  */
 
 #include "usbip_common.h"
+#include <linux/kthread.h>
 
 static int event_handler(struct usbip_device *ud)
 {
-	dbg_eh("enter\n");
+	usbip_dbg_eh("enter\n");
 
 	/*
 	 * Events are handled by only this thread.
 	 */
-	while (usbip_event_happend(ud)) {
-		dbg_eh("pending event %lx\n", ud->event);
+	while (usbip_event_happened(ud)) {
+		usbip_dbg_eh("pending event %lx\n", ud->event);
 
 		/*
 		 * NOTE: shutdown must come first.
@@ -77,30 +78,38 @@ static void event_handler_loop(struct us
 
 	while (1) {
 		if (signal_pending(current)) {
-			dbg_eh("signal catched!\n");
+			usbip_dbg_eh("signal catched!\n");
 			break;
 		}
 
 		if (event_handler(ud) < 0)
 			break;
 
-		wait_event_interruptible(ud->eh_waitq, usbip_event_happend(ud));
-		dbg_eh("wakeup\n");
+		wait_event_interruptible(ud->eh_waitq,
+					usbip_event_happened(ud));
+		usbip_dbg_eh("wakeup\n");
 	}
 }
 
-void usbip_start_eh(struct usbip_device *ud)
+int usbip_start_eh(struct usbip_device *ud)
 {
 	struct usbip_task *eh = &ud->eh;
+	struct task_struct *th;
 
 	init_waitqueue_head(&ud->eh_waitq);
 	ud->event = 0;
 
 	usbip_task_init(eh, "usbip_eh", event_handler_loop);
 
-	kernel_thread(usbip_thread, (void *)eh, 0);
+	th = kthread_run(usbip_thread, (void *)eh, "usbip");
+	if (IS_ERR(th)) {
+		printk(KERN_WARNING
+			"Unable to start control thread\n");
+		return PTR_ERR(th);
+	}
 
 	wait_for_completion(&eh->thread_done);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(usbip_start_eh);
 
@@ -109,7 +118,7 @@ void usbip_stop_eh(struct usbip_device *
 	struct usbip_task *eh = &ud->eh;
 
 	wait_for_completion(&eh->thread_done);
-	dbg_eh("usbip_eh has finished\n");
+	usbip_dbg_eh("usbip_eh has finished\n");
 }
 EXPORT_SYMBOL_GPL(usbip_stop_eh);
 
@@ -125,17 +134,17 @@ void usbip_event_add(struct usbip_device
 }
 EXPORT_SYMBOL_GPL(usbip_event_add);
 
-int usbip_event_happend(struct usbip_device *ud)
+int usbip_event_happened(struct usbip_device *ud)
 {
-	int happend = 0;
+	int happened = 0;
 
 	spin_lock(&ud->lock);
 
 	if (ud->event != 0)
-		happend = 1;
+		happened = 1;
 
 	spin_unlock(&ud->lock);
 
-	return happend;
+	return happened;
 }
-EXPORT_SYMBOL_GPL(usbip_event_happend);
+EXPORT_SYMBOL_GPL(usbip_event_happened);
--- a/drivers/staging/usbip/vhci_hcd.c
+++ b/drivers/staging/usbip/vhci_hcd.c
@@ -115,7 +115,7 @@ void rh_port_connect(int rhport, enum us
 {
 	unsigned long	flags;
 
-	dbg_vhci_rh("rh_port_connect %d\n", rhport);
+	usbip_dbg_vhci_rh("rh_port_connect %d\n", rhport);
 
 	spin_lock_irqsave(&the_controller->lock, flags);
 
@@ -148,7 +148,7 @@ void rh_port_disconnect(int rhport)
 {
 	unsigned long flags;
 
-	dbg_vhci_rh("rh_port_disconnect %d\n", rhport);
+	usbip_dbg_vhci_rh("rh_port_disconnect %d\n", rhport);
 
 	spin_lock_irqsave(&the_controller->lock, flags);
 	/* stop_activity(dum, driver); */
@@ -215,7 +215,7 @@ static int vhci_hub_status(struct usb_hc
 
 	spin_lock_irqsave(&vhci->lock, flags);
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
-		dbg_vhci_rh("hw accessible flag in on?\n");
+		usbip_dbg_vhci_rh("hw accessible flag in on?\n");
 		goto done;
 	}
 
@@ -223,14 +223,14 @@ static int vhci_hub_status(struct usb_hc
 	for (rhport = 0; rhport < VHCI_NPORTS; rhport++) {
 		if ((vhci->port_status[rhport] & PORT_C_MASK)) {
 			/* The status of a port has been changed, */
-			dbg_vhci_rh("port %d is changed\n", rhport);
+			usbip_dbg_vhci_rh("port %d is changed\n", rhport);
 
 			*event_bits |= 1 << (rhport + 1);
 			changed = 1;
 		}
 	}
 
-	uinfo("changed %d\n", changed);
+	usbip_uinfo("changed %d\n", changed);
 
 	if (hcd->state == HC_STATE_SUSPENDED)
 		usb_hcd_resume_root_hub(hcd);
@@ -275,10 +275,11 @@ static int vhci_hub_control(struct usb_h
 	 * NOTE:
 	 * wIndex shows the port number and begins from 1.
 	 */
-	dbg_vhci_rh("typeReq %x wValue %x wIndex %x\n", typeReq, wValue,
+	usbip_dbg_vhci_rh("typeReq %x wValue %x wIndex %x\n", typeReq, wValue,
 								wIndex);
 	if (wIndex > VHCI_NPORTS)
-		printk(KERN_ERR "%s: invalid port number %d\n", __func__, wIndex);
+		printk(KERN_ERR "%s: invalid port number %d\n", __func__,
+								wIndex);
 	rhport = ((__u8)(wIndex & 0x00ff)) - 1;
 
 	dum = hcd_to_vhci(hcd);
@@ -286,7 +287,7 @@ static int vhci_hub_control(struct usb_h
 	spin_lock_irqsave(&dum->lock, flags);
 
 	/* store old status and compare now and old later */
-	if (dbg_flag_vhci_rh) {
+	if (usbip_dbg_flag_vhci_rh) {
 		int i = 0;
 		for (i = 0; i < VHCI_NPORTS; i++)
 			prev_port_status[i] = dum->port_status[i];
@@ -294,7 +295,7 @@ static int vhci_hub_control(struct usb_h
 
 	switch (typeReq) {
 	case ClearHubFeature:
-		dbg_vhci_rh(" ClearHubFeature\n");
+		usbip_dbg_vhci_rh(" ClearHubFeature\n");
 		break;
 	case ClearPortFeature:
 		switch (wValue) {
@@ -307,15 +308,16 @@ static int vhci_hub_control(struct usb_h
 			}
 			break;
 		case USB_PORT_FEAT_POWER:
-			dbg_vhci_rh(" ClearPortFeature: USB_PORT_FEAT_POWER\n");
+			usbip_dbg_vhci_rh(" ClearPortFeature: "
+						"USB_PORT_FEAT_POWER\n");
 			dum->port_status[rhport] = 0;
 			/* dum->address = 0; */
 			/* dum->hdev = 0; */
 			dum->resuming = 0;
 			break;
 		case USB_PORT_FEAT_C_RESET:
-			dbg_vhci_rh(" ClearPortFeature: "
-					"USB_PORT_FEAT_C_RESET\n");
+			usbip_dbg_vhci_rh(" ClearPortFeature: "
+						"USB_PORT_FEAT_C_RESET\n");
 			switch (dum->vdev[rhport].speed) {
 			case USB_SPEED_HIGH:
 				dum->port_status[rhport] |=
@@ -329,20 +331,21 @@ static int vhci_hub_control(struct usb_h
 				break;
 			}
 		default:
-			dbg_vhci_rh(" ClearPortFeature: default %x\n", wValue);
+			usbip_dbg_vhci_rh(" ClearPortFeature: default %x\n",
+								wValue);
 			dum->port_status[rhport] &= ~(1 << wValue);
 		}
 		break;
 	case GetHubDescriptor:
-		dbg_vhci_rh(" GetHubDescriptor\n");
+		usbip_dbg_vhci_rh(" GetHubDescriptor\n");
 		hub_descriptor((struct usb_hub_descriptor *) buf);
 		break;
 	case GetHubStatus:
-		dbg_vhci_rh(" GetHubStatus\n");
+		usbip_dbg_vhci_rh(" GetHubStatus\n");
 		*(__le32 *) buf = __constant_cpu_to_le32(0);
 		break;
 	case GetPortStatus:
-		dbg_vhci_rh(" GetPortStatus port %x\n", wIndex);
+		usbip_dbg_vhci_rh(" GetPortStatus port %x\n", wIndex);
 		if (wIndex > VHCI_NPORTS || wIndex < 1) {
 			printk(KERN_ERR "%s: invalid port number %d\n",
 			       __func__, wIndex);
@@ -379,7 +382,8 @@ static int vhci_hub_control(struct usb_h
 
 			if (dum->vdev[rhport].ud.status ==
 							VDEV_ST_NOTASSIGNED) {
-				dbg_vhci_rh(" enable rhport %d (status %u)\n",
+				usbip_dbg_vhci_rh(" enable rhport %d "
+						"(status %u)\n",
 						rhport,
 						dum->vdev[rhport].ud.status);
 				dum->port_status[rhport] |=
@@ -415,17 +419,17 @@ static int vhci_hub_control(struct usb_h
 		((u16 *) buf)[1] =
 				cpu_to_le16(dum->port_status[rhport] >> 16);
 
-		dbg_vhci_rh(" GetPortStatus bye %x %x\n", ((u16 *)buf)[0],
+		usbip_dbg_vhci_rh(" GetPortStatus bye %x %x\n", ((u16 *)buf)[0],
 							((u16 *)buf)[1]);
 		break;
 	case SetHubFeature:
-		dbg_vhci_rh(" SetHubFeature\n");
+		usbip_dbg_vhci_rh(" SetHubFeature\n");
 		retval = -EPIPE;
 		break;
 	case SetPortFeature:
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			dbg_vhci_rh(" SetPortFeature: "
+			usbip_dbg_vhci_rh(" SetPortFeature: "
 					"USB_PORT_FEAT_SUSPEND\n");
 			printk(KERN_ERR "%s: not yet\n", __func__);
 #if 0
@@ -439,7 +443,8 @@ static int vhci_hub_control(struct usb_h
 #endif
 			break;
 		case USB_PORT_FEAT_RESET:
-			dbg_vhci_rh(" SetPortFeature: USB_PORT_FEAT_RESET\n");
+			usbip_dbg_vhci_rh(" SetPortFeature: "
+						"USB_PORT_FEAT_RESET\n");
 			/* if it's already running, disconnect first */
 			if (dum->port_status[rhport] & USB_PORT_STAT_ENABLE) {
 				dum->port_status[rhport] &=
@@ -460,7 +465,8 @@ static int vhci_hub_control(struct usb_h
 
 			/* FALLTHROUGH */
 		default:
-			dbg_vhci_rh(" SetPortFeature: default %d\n", wValue);
+			usbip_dbg_vhci_rh(" SetPortFeature: default %d\n",
+								wValue);
 			dum->port_status[rhport] |= (1 << wValue);
 		}
 		break;
@@ -475,12 +481,12 @@ static int vhci_hub_control(struct usb_h
 		retval = -EPIPE;
 	}
 
-	if (dbg_flag_vhci_rh) {
+	if (usbip_dbg_flag_vhci_rh) {
 		printk(KERN_DEBUG "port %d\n", rhport);
 		dump_port_status(prev_port_status[rhport]);
 		dump_port_status(dum->port_status[rhport]);
 	}
-	dbg_vhci_rh(" bye\n");
+	usbip_dbg_vhci_rh(" bye\n");
 
 	spin_unlock_irqrestore(&dum->lock, flags);
 
@@ -517,9 +523,10 @@ static void vhci_tx_urb(struct urb *urb)
 		return;
 	}
 
+	priv = kzalloc(sizeof(struct vhci_priv), GFP_ATOMIC);
+
 	spin_lock_irqsave(&vdev->priv_lock, flag);
 
-	priv = kzalloc(sizeof(struct vhci_priv), GFP_ATOMIC);
 	if (!priv) {
 		dev_err(&urb->dev->dev, "malloc vhci_priv\n");
 		spin_unlock_irqrestore(&vdev->priv_lock, flag);
@@ -529,7 +536,7 @@ static void vhci_tx_urb(struct urb *urb)
 
 	priv->seqnum = atomic_inc_return(&the_controller->seqnum);
 	if (priv->seqnum == 0xffff)
-		uinfo("seqnum max\n");
+		usbip_uinfo("seqnum max\n");
 
 	priv->vdev = vdev;
 	priv->urb = urb;
@@ -550,7 +557,7 @@ static int vhci_urb_enqueue(struct usb_h
 	int ret = 0;
 	unsigned long flags;
 
-	dbg_vhci_hc("enter, usb_hcd %p urb %p mem_flags %d\n",
+	usbip_dbg_vhci_hc("enter, usb_hcd %p urb %p mem_flags %d\n",
 		    hcd, urb, mem_flags);
 
 	/* patch to usb_sg_init() is in 2.5.60 */
@@ -558,13 +565,6 @@ static int vhci_urb_enqueue(struct usb_h
 
 	spin_lock_irqsave(&the_controller->lock, flags);
 
-	/* check HC is active or not */
-	if (!HC_IS_RUNNING(hcd->state)) {
-		dev_err(dev, "HC is not running\n");
-		spin_unlock_irqrestore(&the_controller->lock, flags);
-		return -ENODEV;
-	}
-
 	if (urb->status != -EINPROGRESS) {
 		dev_err(dev, "URB already unlinked!, status %d\n", urb->status);
 		spin_unlock_irqrestore(&the_controller->lock, flags);
@@ -576,7 +576,7 @@ static int vhci_urb_enqueue(struct usb_h
 		goto no_need_unlink;
 
 	/*
-	 * The enumelation process is as follows;
+	 * The enumeration process is as follows;
 	 *
 	 *  1. Get_Descriptor request to DevAddrs(0) EndPoint(0)
 	 *     to get max packet length of default pipe
@@ -620,7 +620,7 @@ static int vhci_urb_enqueue(struct usb_h
 
 		case USB_REQ_GET_DESCRIPTOR:
 			if (ctrlreq->wValue == (USB_DT_DEVICE << 8))
-				dbg_vhci_hc("Not yet?: "
+				usbip_dbg_vhci_hc("Not yet?: "
 						"Get_Descriptor to device 0 "
 						"(get max pipe size)\n");
 
@@ -708,7 +708,7 @@ static int vhci_urb_dequeue(struct usb_h
 	struct vhci_priv *priv;
 	struct vhci_device *vdev;
 
-	uinfo("vhci_hcd: dequeue a urb %p\n", urb);
+	usbip_uinfo("vhci_hcd: dequeue a urb %p\n", urb);
 
 
 	spin_lock_irqsave(&the_controller->lock, flags);
@@ -726,7 +726,7 @@ static int vhci_urb_dequeue(struct usb_h
 		ret = usb_hcd_check_unlink_urb(hcd, urb, status);
 		if (ret) {
 			spin_unlock_irqrestore(&the_controller->lock, flags);
-			return 0;
+			return ret;
 		}
 	}
 
@@ -739,13 +739,29 @@ static int vhci_urb_dequeue(struct usb_h
 
 		spin_lock_irqsave(&vdev->priv_lock, flags2);
 
-		uinfo("vhci_hcd: device %p seems to be disconnected\n", vdev);
+		usbip_uinfo("vhci_hcd: device %p seems to be disconnected\n",
+									vdev);
 		list_del(&priv->list);
 		kfree(priv);
 		urb->hcpriv = NULL;
 
 		spin_unlock_irqrestore(&vdev->priv_lock, flags2);
 
+		/*
+		 * If tcp connection is alive, we have sent CMD_UNLINK.
+		 * vhci_rx will receive RET_UNLINK and give back the URB.
+		 * Otherwise, we give back it here.
+		 */
+		usbip_uinfo("vhci_hcd: vhci_urb_dequeue() gives back urb %p\n",
+									urb);
+
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+
+		spin_unlock_irqrestore(&the_controller->lock, flags);
+		usb_hcd_giveback_urb(vhci_to_hcd(the_controller), urb,
+								urb->status);
+		spin_lock_irqsave(&the_controller->lock, flags);
+
 	} else {
 		/* tcp connection is alive */
 		unsigned long flags2;
@@ -756,7 +772,7 @@ static int vhci_urb_dequeue(struct usb_h
 		/* setup CMD_UNLINK pdu */
 		unlink = kzalloc(sizeof(struct vhci_unlink), GFP_ATOMIC);
 		if (!unlink) {
-			uerr("malloc vhci_unlink\n");
+			usbip_uerr("malloc vhci_unlink\n");
 			spin_unlock_irqrestore(&vdev->priv_lock, flags2);
 			spin_unlock_irqrestore(&the_controller->lock, flags);
 			usbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_MALLOC);
@@ -765,11 +781,11 @@ static int vhci_urb_dequeue(struct usb_h
 
 		unlink->seqnum = atomic_inc_return(&the_controller->seqnum);
 		if (unlink->seqnum == 0xffff)
-			uinfo("seqnum max\n");
+			usbip_uinfo("seqnum max\n");
 
 		unlink->unlink_seqnum = priv->seqnum;
 
-		uinfo("vhci_hcd: device %p seems to be still connected\n",
+		usbip_uinfo("vhci_hcd: device %p seems to be still connected\n",
 									vdev);
 
 		/* send cmd_unlink and try to cancel the pending URB in the
@@ -781,14 +797,10 @@ static int vhci_urb_dequeue(struct usb_h
 	}
 
 
-	/*
-	 * If tcp connection is alive, we have sent CMD_UNLINK.
-	 * vhci_rx will receive RET_UNLINK and give back the URB.
-	 * Otherwise, we give back it here.
-	 */
 	if (!vdev->ud.tcp_socket) {
 		/* tcp connection is closed */
-		uinfo("vhci_hcd: vhci_urb_dequeue() gives back urb %p\n", urb);
+		usbip_uinfo("vhci_hcd: vhci_urb_dequeue() gives back urb %p\n",
+									urb);
 
 		usb_hcd_unlink_urb_from_ep(hcd, urb);
 
@@ -800,7 +812,7 @@ static int vhci_urb_dequeue(struct usb_h
 
 	spin_unlock_irqrestore(&the_controller->lock, flags);
 
-	dbg_vhci_hc("leave\n");
+	usbip_dbg_vhci_hc("leave\n");
 	return 0;
 }
 
@@ -835,19 +847,19 @@ static void vhci_shutdown_connection(str
 
 	/* need this? see stub_dev.c */
 	if (ud->tcp_socket) {
-		udbg("shutdown tcp_socket %p\n", ud->tcp_socket);
+		usbip_udbg("shutdown tcp_socket %p\n", ud->tcp_socket);
 		kernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);
 	}
 
 	usbip_stop_threads(&vdev->ud);
-	uinfo("stop threads\n");
+	usbip_uinfo("stop threads\n");
 
 	/* active connection is closed */
 	if (vdev->ud.tcp_socket != NULL) {
 		sock_release(vdev->ud.tcp_socket);
 		vdev->ud.tcp_socket = NULL;
 	}
-	uinfo("release socket\n");
+	usbip_uinfo("release socket\n");
 
 	vhci_device_unlink_cleanup(vdev);
 
@@ -873,7 +885,7 @@ static void vhci_shutdown_connection(str
 	 */
 	rh_port_disconnect(vdev->rhport);
 
-	uinfo("disconnect device\n");
+	usbip_uinfo("disconnect device\n");
 }
 
 
@@ -939,7 +951,7 @@ static int vhci_start(struct usb_hcd *hc
 	int rhport;
 	int err = 0;
 
-	dbg_vhci_hc("enter vhci_start\n");
+	usbip_dbg_vhci_hc("enter vhci_start\n");
 
 
 	/* initialize private data of usb_hcd */
@@ -963,7 +975,7 @@ static int vhci_start(struct usb_hcd *hc
 	/* vhci_hcd is now ready to be controlled through sysfs */
 	err = sysfs_create_group(&vhci_dev(vhci)->kobj, &dev_attr_group);
 	if (err) {
-		uerr("create sysfs files\n");
+		usbip_uerr("create sysfs files\n");
 		return err;
 	}
 
@@ -975,7 +987,7 @@ static void vhci_stop(struct usb_hcd *hc
 	struct vhci_hcd *vhci = hcd_to_vhci(hcd);
 	int rhport = 0;
 
-	dbg_vhci_hc("stop VHCI controller\n");
+	usbip_dbg_vhci_hc("stop VHCI controller\n");
 
 
 	/* 1. remove the userland interface of vhci_hcd */
@@ -990,14 +1002,14 @@ static void vhci_stop(struct usb_hcd *hc
 	}
 
 
-	uinfo("vhci_stop done\n");
+	usbip_uinfo("vhci_stop done\n");
 }
 
 /*----------------------------------------------------------------------*/
 
 static int vhci_get_frame_number(struct usb_hcd *hcd)
 {
-	uerr("Not yet implemented\n");
+	usbip_uerr("Not yet implemented\n");
 	return 0;
 }
 
@@ -1077,9 +1089,9 @@ static int vhci_hcd_probe(struct platfor
 	struct usb_hcd		*hcd;
 	int			ret;
 
-	uinfo("proving...\n");
+	usbip_uinfo("proving...\n");
 
-	dbg_vhci_hc("name %s id %d\n", pdev->name, pdev->id);
+	usbip_dbg_vhci_hc("name %s id %d\n", pdev->name, pdev->id);
 
 	/* will be removed */
 	if (pdev->dev.dma_mask) {
@@ -1093,7 +1105,7 @@ static int vhci_hcd_probe(struct platfor
 	 */
 	hcd = usb_create_hcd(&vhci_hc_driver, &pdev->dev, dev_name(&pdev->dev));
 	if (!hcd) {
-		uerr("create hcd failed\n");
+		usbip_uerr("create hcd failed\n");
 		return -ENOMEM;
 	}
 
@@ -1107,14 +1119,14 @@ static int vhci_hcd_probe(struct platfor
 	 */
 	ret = usb_add_hcd(hcd, 0, 0);
 	if (ret != 0) {
-		uerr("usb_add_hcd failed %d\n", ret);
+		usbip_uerr("usb_add_hcd failed %d\n", ret);
 		usb_put_hcd(hcd);
 		the_controller = NULL;
 		return ret;
 	}
 
 
-	dbg_vhci_hc("bye\n");
+	usbip_dbg_vhci_hc("bye\n");
 	return 0;
 }
 
@@ -1166,11 +1178,11 @@ static int vhci_hcd_suspend(struct platf
 	spin_unlock(&the_controller->lock);
 
 	if (connected > 0) {
-		uinfo("We have %d active connection%s. Do not suspend.\n",
+		usbip_uinfo("We have %d active connection%s. Do not suspend.\n",
 				connected, (connected == 1 ? "" : "s"));
 		ret =  -EBUSY;
 	} else {
-		uinfo("suspend vhci_hcd");
+		usbip_uinfo("suspend vhci_hcd");
 		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 	}
 
@@ -1235,7 +1247,7 @@ static int __init vhci_init(void)
 {
 	int ret;
 
-	dbg_vhci_hc("enter\n");
+	usbip_dbg_vhci_hc("enter\n");
 	if (usb_disabled())
 		return -ENODEV;
 
@@ -1250,7 +1262,7 @@ static int __init vhci_init(void)
 	if (ret < 0)
 		goto err_platform_device_register;
 
-	dbg_vhci_hc("bye\n");
+	usbip_dbg_vhci_hc("bye\n");
 	return ret;
 
 	/* error occurred */
@@ -1258,18 +1270,18 @@ err_platform_device_register:
 	platform_driver_unregister(&vhci_driver);
 
 err_driver_register:
-	dbg_vhci_hc("bye\n");
+	usbip_dbg_vhci_hc("bye\n");
 	return ret;
 }
 module_init(vhci_init);
 
 static void __exit vhci_cleanup(void)
 {
-	dbg_vhci_hc("enter\n");
+	usbip_dbg_vhci_hc("enter\n");
 
 	platform_device_unregister(&the_pdev);
 	platform_driver_unregister(&vhci_driver);
 
-	dbg_vhci_hc("bye\n");
+	usbip_dbg_vhci_hc("bye\n");
 }
 module_exit(vhci_cleanup);
--- a/drivers/staging/usbip/vhci_rx.c
+++ b/drivers/staging/usbip/vhci_rx.c
@@ -36,7 +36,7 @@ static struct urb *pickup_urb_and_free_p
 			urb = priv->urb;
 			status = urb->status;
 
-			dbg_vhci_rx("find urb %p vurb %p seqnum %u\n",
+			usbip_dbg_vhci_rx("find urb %p vurb %p seqnum %u\n",
 				    urb, priv, seqnum);
 
 			/* TODO: fix logic here to improve indent situtation */
@@ -77,8 +77,10 @@ static void vhci_recv_ret_submit(struct 
 
 
 	if (!urb) {
-		uerr("cannot find a urb of seqnum %u\n", pdu->base.seqnum);
-		uinfo("max seqnum %d\n", atomic_read(&the_controller->seqnum));
+		usbip_uerr("cannot find a urb of seqnum %u\n",
+							pdu->base.seqnum);
+		usbip_uinfo("max seqnum %d\n",
+					atomic_read(&the_controller->seqnum));
 		usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
 		return;
 	}
@@ -98,11 +100,11 @@ static void vhci_recv_ret_submit(struct 
 		return;
 
 
-	if (dbg_flag_vhci_rx)
+	if (usbip_dbg_flag_vhci_rx)
 		usbip_dump_urb(urb);
 
 
-	dbg_vhci_rx("now giveback urb %p\n", urb);
+	usbip_dbg_vhci_rx("now giveback urb %p\n", urb);
 
 	spin_lock(&the_controller->lock);
 	usb_hcd_unlink_urb_from_ep(vhci_to_hcd(the_controller), urb);
@@ -111,7 +113,7 @@ static void vhci_recv_ret_submit(struct 
 	usb_hcd_giveback_urb(vhci_to_hcd(the_controller), urb, urb->status);
 
 
-	dbg_vhci_rx("Leave\n");
+	usbip_dbg_vhci_rx("Leave\n");
 
 	return;
 }
@@ -125,9 +127,9 @@ static struct vhci_unlink *dequeue_pendi
 	spin_lock(&vdev->priv_lock);
 
 	list_for_each_entry_safe(unlink, tmp, &vdev->unlink_rx, list) {
-		uinfo("unlink->seqnum %lu\n", unlink->seqnum);
+		usbip_uinfo("unlink->seqnum %lu\n", unlink->seqnum);
 		if (unlink->seqnum == pdu->base.seqnum) {
-			dbg_vhci_rx("found pending unlink, %lu\n",
+			usbip_dbg_vhci_rx("found pending unlink, %lu\n",
 							unlink->seqnum);
 			list_del(&unlink->list);
 
@@ -152,7 +154,8 @@ static void vhci_recv_ret_unlink(struct 
 
 	unlink = dequeue_pending_unlink(vdev, pdu);
 	if (!unlink) {
-		uinfo("cannot find the pending unlink %u\n", pdu->base.seqnum);
+		usbip_uinfo("cannot find the pending unlink %u\n",
+							pdu->base.seqnum);
 		return;
 	}
 
@@ -163,14 +166,14 @@ static void vhci_recv_ret_unlink(struct 
 		 * already received the result of its submit result and gave
 		 * back the URB.
 		 */
-		uinfo("the urb (seqnum %d) was already given backed\n",
+		usbip_uinfo("the urb (seqnum %d) was already given backed\n",
 							pdu->base.seqnum);
 	} else {
-		dbg_vhci_rx("now giveback urb %p\n", urb);
+		usbip_dbg_vhci_rx("now giveback urb %p\n", urb);
 
 		/* If unlink is succeed, status is -ECONNRESET */
 		urb->status = pdu->u.ret_unlink.status;
-		uinfo("%d\n", urb->status);
+		usbip_uinfo("%d\n", urb->status);
 
 		spin_lock(&the_controller->lock);
 		usb_hcd_unlink_urb_from_ep(vhci_to_hcd(the_controller), urb);
@@ -193,7 +196,7 @@ static void vhci_rx_pdu(struct usbip_dev
 	struct vhci_device *vdev = container_of(ud, struct vhci_device, ud);
 
 
-	dbg_vhci_rx("Enter\n");
+	usbip_dbg_vhci_rx("Enter\n");
 
 	memset(&pdu, 0, sizeof(pdu));
 
@@ -201,15 +204,15 @@ static void vhci_rx_pdu(struct usbip_dev
 	/* 1. receive a pdu header */
 	ret = usbip_xmit(0, ud->tcp_socket, (char *) &pdu, sizeof(pdu), 0);
 	if (ret != sizeof(pdu)) {
-		uerr("receiving pdu failed! size is %d, should be %d\n",
-				ret, (unsigned int)sizeof(pdu));
+		usbip_uerr("receiving pdu failed! size is %d, should be %d\n",
+					ret, (unsigned int)sizeof(pdu));
 		usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
 		return;
 	}
 
 	usbip_header_correct_endian(&pdu, 0);
 
-	if (dbg_flag_vhci_rx)
+	if (usbip_dbg_flag_vhci_rx)
 		usbip_dump_header(&pdu);
 
 	switch (pdu.base.command) {
@@ -221,7 +224,7 @@ static void vhci_rx_pdu(struct usbip_dev
 		break;
 	default:
 		/* NOTREACHED */
-		uerr("unknown pdu %u\n", pdu.base.command);
+		usbip_uerr("unknown pdu %u\n", pdu.base.command);
 		usbip_dump_header(&pdu);
 		usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
 	}
@@ -237,12 +240,12 @@ void vhci_rx_loop(struct usbip_task *ut)
 
 	while (1) {
 		if (signal_pending(current)) {
-			dbg_vhci_rx("signal catched!\n");
+			usbip_dbg_vhci_rx("signal catched!\n");
 			break;
 		}
 
 
-		if (usbip_event_happend(ud))
+		if (usbip_event_happened(ud))
 			break;
 
 		vhci_rx_pdu(ud);
--- a/drivers/staging/usbip/vhci_sysfs.c
+++ b/drivers/staging/usbip/vhci_sysfs.c
@@ -80,7 +80,7 @@ static int vhci_port_disconnect(__u32 rh
 {
 	struct vhci_device *vdev;
 
-	dbg_vhci_sysfs("enter\n");
+	usbip_dbg_vhci_sysfs("enter\n");
 
 	/* lock */
 	spin_lock(&the_controller->lock);
@@ -89,7 +89,7 @@ static int vhci_port_disconnect(__u32 rh
 
 	spin_lock(&vdev->ud.lock);
 	if (vdev->ud.status == VDEV_ST_NULL) {
-		uerr("not connected %d\n", vdev->ud.status);
+		usbip_uerr("not connected %d\n", vdev->ud.status);
 
 		/* unlock */
 		spin_unlock(&vdev->ud.lock);
@@ -117,7 +117,7 @@ static ssize_t store_detach(struct devic
 
 	/* check rhport */
 	if (rhport >= VHCI_NPORTS) {
-		uerr("invalid port %u\n", rhport);
+		usbip_uerr("invalid port %u\n", rhport);
 		return -EINVAL;
 	}
 
@@ -125,7 +125,7 @@ static ssize_t store_detach(struct devic
 	if (err < 0)
 		return -EINVAL;
 
-	dbg_vhci_sysfs("Leave\n");
+	usbip_dbg_vhci_sysfs("Leave\n");
 	return count;
 }
 static DEVICE_ATTR(detach, S_IWUSR, NULL, store_detach);
@@ -135,7 +135,7 @@ static int valid_args(__u32 rhport, enum
 {
 	/* check rhport */
 	if ((rhport < 0) || (rhport >= VHCI_NPORTS)) {
-		uerr("port %u\n", rhport);
+		usbip_uerr("port %u\n", rhport);
 		return -EINVAL;
 	}
 
@@ -147,7 +147,7 @@ static int valid_args(__u32 rhport, enum
 	case USB_SPEED_VARIABLE:
 		break;
 	default:
-		uerr("speed %d\n", speed);
+		usbip_uerr("speed %d\n", speed);
 		return -EINVAL;
 	}
 
@@ -181,8 +181,8 @@ static ssize_t store_attach(struct devic
 	 */
 	sscanf(buf, "%u %u %u %u", &rhport, &sockfd, &devid, &speed);
 
-	dbg_vhci_sysfs("rhport(%u) sockfd(%u) devid(%u) speed(%u)\n",
-			rhport, sockfd, devid, speed);
+	usbip_dbg_vhci_sysfs("rhport(%u) sockfd(%u) devid(%u) speed(%u)\n",
+				rhport, sockfd, devid, speed);
 
 
 	/* check received parameters */
@@ -208,12 +208,12 @@ static ssize_t store_attach(struct devic
 		spin_unlock(&vdev->ud.lock);
 		spin_unlock(&the_controller->lock);
 
-		uerr("port %d already used\n", rhport);
+		usbip_uerr("port %d already used\n", rhport);
 		return -EINVAL;
 	}
 
-	uinfo("rhport(%u) sockfd(%d) devid(%u) speed(%u)\n",
-			rhport, sockfd, devid, speed);
+	usbip_uinfo("rhport(%u) sockfd(%d) devid(%u) speed(%u)\n",
+				rhport, sockfd, devid, speed);
 
 	vdev->devid         = devid;
 	vdev->speed         = speed;
--- a/drivers/staging/usbip/vhci_tx.c
+++ b/drivers/staging/usbip/vhci_tx.c
@@ -26,7 +26,7 @@ static void setup_cmd_submit_pdu(struct 
 	struct vhci_priv *priv = ((struct vhci_priv *)urb->hcpriv);
 	struct vhci_device *vdev = priv->vdev;
 
-	dbg_vhci_tx("URB, local devnum %u, remote devid %u\n",
+	usbip_dbg_vhci_tx("URB, local devnum %u, remote devid %u\n",
 				usb_pipedevice(urb->pipe), vdev->devid);
 
 	pdup->base.command = USBIP_CMD_SUBMIT;
@@ -85,7 +85,7 @@ static int vhci_send_cmd_submit(struct v
 		memset(&msg, 0, sizeof(msg));
 		memset(&iov, 0, sizeof(iov));
 
-		dbg_vhci_tx("setup txdata urb %p\n", urb);
+		usbip_dbg_vhci_tx("setup txdata urb %p\n", urb);
 
 
 		/* 1. setup usbip_header */
@@ -121,15 +121,15 @@ static int vhci_send_cmd_submit(struct v
 
 		ret = kernel_sendmsg(vdev->ud.tcp_socket, &msg, iov, 3, txsize);
 		if (ret != txsize) {
-			uerr("sendmsg failed!, retval %d for %zd\n", ret,
-								txsize);
+			usbip_uerr("sendmsg failed!, retval %d for %zd\n", ret,
+									txsize);
 			kfree(iso_buffer);
 			usbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_TCP);
 			return -1;
 		}
 
 		kfree(iso_buffer);
-		dbg_vhci_tx("send txdata\n");
+		usbip_dbg_vhci_tx("send txdata\n");
 
 		total_size += txsize;
 	}
@@ -177,7 +177,7 @@ static int vhci_send_cmd_unlink(struct v
 		memset(&msg, 0, sizeof(msg));
 		memset(&iov, 0, sizeof(iov));
 
-		dbg_vhci_tx("setup cmd unlink, %lu \n", unlink->seqnum);
+		usbip_dbg_vhci_tx("setup cmd unlink, %lu \n", unlink->seqnum);
 
 
 		/* 1. setup usbip_header */
@@ -195,14 +195,14 @@ static int vhci_send_cmd_unlink(struct v
 
 		ret = kernel_sendmsg(vdev->ud.tcp_socket, &msg, iov, 1, txsize);
 		if (ret != txsize) {
-			uerr("sendmsg failed!, retval %d for %zd\n", ret,
-								txsize);
+			usbip_uerr("sendmsg failed!, retval %d for %zd\n", ret,
+									txsize);
 			usbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_TCP);
 			return -1;
 		}
 
 
-		dbg_vhci_tx("send txdata\n");
+		usbip_dbg_vhci_tx("send txdata\n");
 
 		total_size += txsize;
 	}
@@ -220,7 +220,7 @@ void vhci_tx_loop(struct usbip_task *ut)
 
 	while (1) {
 		if (signal_pending(current)) {
-			uinfo("vhci_tx signal catched\n");
+			usbip_uinfo("vhci_tx signal catched\n");
 			break;
 		}
 
@@ -234,6 +234,6 @@ void vhci_tx_loop(struct usbip_task *ut)
 				(!list_empty(&vdev->priv_tx) ||
 				 !list_empty(&vdev->unlink_tx)));
 
-		dbg_vhci_tx("pending urbs ?, now wake up\n");
+		usbip_dbg_vhci_tx("pending urbs ?, now wake up\n");
 	}
 }
