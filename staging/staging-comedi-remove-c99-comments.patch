From wfp5p@virginia.edu Fri Mar 27 08:29:38 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Fri, 27 Mar 2009 11:29:34 -0400
Subject: Staging: comedi: Remove C99 comments
To: greg@kroah.com
Cc: abbotti@mev.co.uk, fmhess@users.sourceforge.net, ds@schleef.org
Message-ID: <20090327152934.7154.78400.stgit@viridian.itc.Virginia.EDU>


Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/comedi/drivers/addi-data/APCI1710_Chrono.c  |   62 +--
 drivers/staging/comedi/drivers/addi-data/APCI1710_Dig_io.c  |  179 +++++-----
 drivers/staging/comedi/drivers/addi-data/APCI1710_INCCPT.c  |   70 ++--
 drivers/staging/comedi/drivers/addi-data/APCI1710_Inp_cpt.c |    6 
 drivers/staging/comedi/drivers/addi-data/APCI1710_Ssi.c     |   14 
 drivers/staging/comedi/drivers/addi-data/APCI1710_Tor.c     |   92 ++---
 drivers/staging/comedi/drivers/addi-data/APCI1710_Ttl.c     |   12 
 drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c  |   36 +-
 drivers/staging/comedi/drivers/addi-data/addi_common.c      |   64 +--
 drivers/staging/comedi/drivers/addi-data/addi_common.h      |  120 +++----
 drivers/staging/comedi/drivers/addi-data/addi_eeprom.c      |   78 ++--
 drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h    |   26 -
 drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.c   |   88 ++---
 drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.h   |    2 
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci035.c    |   44 +-
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci1032.c   |   48 +-
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci1032.h   |   21 -
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.h   |    4 
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci1516.c   |   88 ++---
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci1516.h   |   19 -
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.h   |   38 +-
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci2016.c   |   78 ++--
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci2016.h   |   24 -
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.c   |  100 ++---
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.h   |   26 -
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci2200.c   |   82 ++--
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci2200.h   |   16 
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.h   |  124 +++----
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.h   |   52 +--
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci3501.c   |  127 +++----
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci3501.h   |   32 +
 drivers/staging/comedi/drivers/addi_apci_035.c              |    2 
 drivers/staging/comedi/drivers/adl_pci7296.c                |    6 
 drivers/staging/comedi/drivers/adl_pci8164.c                |    8 
 drivers/staging/comedi/drivers/adv_pci1710.c                |  198 +++++------
 drivers/staging/comedi/drivers/aio_aio12_8.c                |   12 
 drivers/staging/comedi/drivers/amcc_s5933.h                 |   10 
 drivers/staging/comedi/drivers/cb_das16_cs.c                |    4 
 drivers/staging/comedi/drivers/cb_pcidda.c                  |  205 ++++++------
 drivers/staging/comedi/drivers/cb_pcidio.c                  |   33 +
 drivers/staging/comedi/drivers/cb_pcimdda.c                 |    8 
 drivers/staging/comedi/drivers/comedi_rt_timer.c            |   78 ++--
 drivers/staging/comedi/drivers/daqboard2000.c               |  132 +++----
 drivers/staging/comedi/drivers/das08.c                      |   98 ++---
 drivers/staging/comedi/drivers/das08.h                      |   20 -
 drivers/staging/comedi/drivers/das08_cs.c                   |    6 
 drivers/staging/comedi/drivers/das16.c                      |  170 ++++-----
 drivers/staging/comedi/drivers/das16m1.c                    |   50 +-
 drivers/staging/comedi/drivers/das6402.c                    |    2 
 drivers/staging/comedi/drivers/das800.c                     |   26 -
 drivers/staging/comedi/drivers/dmm32at.c                    |   14 
 drivers/staging/comedi/drivers/dt2801.c                     |   15 
 drivers/staging/comedi/drivers/dt2811.c                     |    9 
 drivers/staging/comedi/drivers/dt3000.c                     |    4 
 drivers/staging/comedi/drivers/jr3_pci.c                    |   78 ++--
 drivers/staging/comedi/drivers/ke_counter.c                 |    4 
 drivers/staging/comedi/drivers/ni_6527.c                    |    2 
 drivers/staging/comedi/drivers/ni_65xx.c                    |    8 
 drivers/staging/comedi/drivers/ni_660x.c                    |   24 -
 drivers/staging/comedi/drivers/ni_670x.c                    |    2 
 drivers/staging/comedi/drivers/ni_at_ao.c                   |    4 
 drivers/staging/comedi/drivers/ni_atmio16d.c                |    6 
 drivers/staging/comedi/drivers/ni_daq_700.c                 |   20 -
 drivers/staging/comedi/drivers/ni_daq_dio24.c               |   20 -
 drivers/staging/comedi/drivers/ni_labpc.h                   |   38 +-
 drivers/staging/comedi/drivers/ni_labpc_cs.c                |    6 
 drivers/staging/comedi/drivers/ni_mio_common.c              |  202 ++++++-----
 drivers/staging/comedi/drivers/ni_mio_cs.c                  |    8 
 drivers/staging/comedi/drivers/ni_pcimio.c                  |   28 -
 drivers/staging/comedi/drivers/ni_stc.h                     |  112 +++---
 drivers/staging/comedi/drivers/ni_tio.c                     |    2 
 drivers/staging/comedi/drivers/ni_tio.h                     |    2 
 drivers/staging/comedi/drivers/ni_tio_internal.h            |    6 
 drivers/staging/comedi/drivers/ni_tiocmd.c                  |    2 
 drivers/staging/comedi/drivers/pcl726.c                     |   18 -
 drivers/staging/comedi/drivers/pcl730.c                     |    4 
 drivers/staging/comedi/drivers/pcl812.c                     |  156 ++++-----
 drivers/staging/comedi/drivers/pcm3724.c                    |   28 -
 drivers/staging/comedi/drivers/pcm3730.c                    |    4 
 drivers/staging/comedi/drivers/poc.c                        |    4 
 drivers/staging/comedi/drivers/rti800.c                     |    2 
 drivers/staging/comedi/drivers/serial2002.c                 |   18 -
 drivers/staging/comedi/drivers/ssv_dnp.c                    |    3 
 drivers/staging/comedi/drivers/unioxx5.c                    |    4 
 drivers/staging/comedi/kcomedilib/ksyms.c                   |   49 +-
 85 files changed, 1911 insertions(+), 1835 deletions(-)

--- a/drivers/staging/comedi/drivers/addi_apci_035.c
+++ b/drivers/staging/comedi/drivers/addi_apci_035.c
@@ -1,5 +1,5 @@
 #define CONFIG_APCI_035 1
 
-#define ADDIDATA_WATCHDOG 2	// Or shold it be something else
+#define ADDIDATA_WATCHDOG 2	/*  Or shold it be something else */
 
 #include "addi-data/addi_common.c"
--- a/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
@@ -92,15 +92,15 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOf
 		while (dw_eeprom_busy == EEPROM_BUSY);
 
 		for (i_Counter = 0; i_Counter < 2; i_Counter++) {
-			b_SelectedAddressLow = (w_EepromStartAddress + i_Counter) % 256;	//Read the low 8 bit part
-			b_SelectedAddressHigh = (w_EepromStartAddress + i_Counter) / 256;	//Read the high 8 bit part
+			b_SelectedAddressLow = (w_EepromStartAddress + i_Counter) % 256;	/* Read the low 8 bit part */
+			b_SelectedAddressHigh = (w_EepromStartAddress + i_Counter) / 256;	/* Read the high 8 bit part */
 
-			//Select the load low address mode
+			/* Select the load low address mode */
 			outb(NVCMD_LOAD_LOW,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				3);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -109,12 +109,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOf
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Load the low address
+			/* Load the low address */
 			outb(b_SelectedAddressLow,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				2);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -123,12 +123,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOf
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Select the load high address mode
+			/* Select the load high address mode */
 			outb(NVCMD_LOAD_HIGH,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				3);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -137,12 +137,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOf
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Load the high address
+			/* Load the high address */
 			outb(b_SelectedAddressHigh,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				2);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -151,12 +151,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOf
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Select the READ mode
+			/* Select the READ mode */
 			outb(NVCMD_BEGIN_READ,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				3);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -165,12 +165,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOf
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Read data into the EEPROM
+			/* Read data into the EEPROM */
 			*pb_ReadByte =
 				inb(dw_PCIBoardEepromAddress +
 				AMCC_OP_REG_MCSR + 2);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -179,14 +179,14 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOf
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Select the upper address part
+			/* Select the upper address part */
 			if (i_Counter == 0) {
 				b_ReadLowByte = pb_ReadByte[0];
 			} else {
 				b_ReadHighByte = pb_ReadByte[0];
 			}
 
-			//Sleep
+			/* Sleep */
 			for (i = 0; i < 10000; i++) ;
 
 		}
@@ -196,8 +196,8 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOf
 
 		pw_DataRead[i_WordCounter] = w_ReadWord;
 
-		w_EepromStartAddress += 2;	// to read the next word
+		w_EepromStartAddress += 2;	/*  to read the next word */
 
-	}			// for (...) i_NbOfWordsToRead
+	}			/*  for (...) i_NbOfWordsToRead */
 	return (0);
 }
--- a/drivers/staging/comedi/drivers/addi-data/addi_common.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_common.c
@@ -68,25 +68,25 @@ You shoud also find the complete GPL in 
 #include "addi_common.h"
 #include "addi_amcc_s5933.h"
 
-//Update-0.7.57->0.7.68MODULE_AUTHOR("ADDI-DATA GmbH <info@addi-data.com>");
-//Update-0.7.57->0.7.68MODULE_DESCRIPTION("Comedi ADDI-DATA module");
-//Update-0.7.57->0.7.68MODULE_LICENSE("GPL");
+/* Update-0.7.57->0.7.68MODULE_AUTHOR("ADDI-DATA GmbH <info@addi-data.com>"); */
+/* Update-0.7.57->0.7.68MODULE_DESCRIPTION("Comedi ADDI-DATA module"); */
+/* Update-0.7.57->0.7.68MODULE_LICENSE("GPL"); */
 
 #define devpriv ((struct addi_private *)dev->private)
 #define this_board ((struct addi_board *)dev->board_ptr)
 
 #if defined(CONFIG_APCI_1710) || defined(CONFIG_APCI_3200) || defined(CONFIG_APCI_3300)
-//BYTE b_SaveFPUReg [94];
+/* BYTE b_SaveFPUReg [94]; */
 
 void fpu_begin(void)
 {
-	//asm ("fstenv b_SaveFPUReg");
+	/* asm ("fstenv b_SaveFPUReg"); */
 	kernel_fpu_begin();
 }
 
 void fpu_end(void)
 {
-	// asm ("frstor b_SaveFPUReg");
+	/*  asm ("frstor b_SaveFPUReg"); */
 	kernel_fpu_end();
 }
 #endif
@@ -901,7 +901,7 @@ static const struct addi_board boardtype
 		NULL},
 #endif
 #ifdef CONFIG_APCI_3300
-	//Begin JK 20.10.2004: APCI-3300 integration
+	/* Begin JK 20.10.2004: APCI-3300 integration */
 	{"apci3300",
 			APCI3200_BOARD_VENDOR_ID,
 			0x3007,
@@ -2580,10 +2580,10 @@ static int i_ADDI_Attach(struct comedi_d
 	}
 
 	if (!pci_list_builded) {
-		v_pci_card_list_init(this_board->i_VendorId, 1);	//1 for displaying the list..
+		v_pci_card_list_init(this_board->i_VendorId, 1);	/* 1 for displaying the list.. */
 		pci_list_builded = 1;
 	}
-	//rt_printk("comedi%d: addi_common: board=%s",dev->minor,this_board->pc_DriverName);
+	/* rt_printk("comedi%d: addi_common: board=%s",dev->minor,this_board->pc_DriverName); */
 
 	if ((this_board->i_Dma) && (it->options[2] == 0)) {
 		i_Dma = 1;
@@ -2617,16 +2617,16 @@ static int i_ADDI_Attach(struct comedi_d
 	   /************************************/
 
 		if (this_board->i_IorangeBase1 != 0) {
-			dev->iobase = (unsigned long)iobase_main;	// DAQ base address...
+			dev->iobase = (unsigned long)iobase_main;	/*  DAQ base address... */
 		} else {
-			dev->iobase = (unsigned long)iobase_a;	// DAQ base address...
+			dev->iobase = (unsigned long)iobase_a;	/*  DAQ base address... */
 		}
 
 		dev->board_name = this_board->pc_DriverName;
 		devpriv->amcc = card;
 		devpriv->iobase = (int) dev->iobase;
-		devpriv->i_IobaseAmcc = (int) iobase_a;	//AMCC base address...
-		devpriv->i_IobaseAddon = (int) iobase_addon;	//ADD ON base address....
+		devpriv->i_IobaseAmcc = (int) iobase_a;	/* AMCC base address... */
+		devpriv->i_IobaseAddon = (int) iobase_addon;	/* ADD ON base address.... */
 		devpriv->i_IobaseReserved = (int) iobase_reserved;
 		devpriv->ps_BoardInfo = this_board;
 	} else {
@@ -2643,7 +2643,7 @@ static int i_ADDI_Attach(struct comedi_d
 		printk("\nioremap end");
 	}
 
-	//##
+	/* ## */
 
 	if (irq > 0) {
 		if (comedi_request_irq(irq, v_ADDI_Interrupt, IRQF_SHARED,
@@ -2662,18 +2662,18 @@ static int i_ADDI_Attach(struct comedi_d
 		it->options[2]);
 	dev->irq = irq;
 
-	// Read eepeom and fill addi_board Structure
+	/*  Read eepeom and fill addi_board Structure */
 
 	if (this_board->i_PCIEeprom) {
 		printk("\nPCI Eeprom used");
 		if (!(strcmp(this_board->pc_EepromChip, "S5920"))) {
-			// Set 3 wait stait
+			/*  Set 3 wait stait */
 			if (!(strcmp(this_board->pc_DriverName, "apci035"))) {
 				outl(0x80808082, devpriv->i_IobaseAmcc + 0x60);
 			} else {
 				outl(0x83838383, devpriv->i_IobaseAmcc + 0x60);
 			}
-			// Enable the interrupt for the controler
+			/*  Enable the interrupt for the controler */
 			dw_Dummy = inl(devpriv->i_IobaseAmcc + 0x38);
 			outl(dw_Dummy | 0x2000, devpriv->i_IobaseAmcc + 0x38);
 			printk("\nEnable the interrupt for the controler");
@@ -2694,7 +2694,7 @@ static int i_ADDI_Attach(struct comedi_d
 	if (this_board->i_Dma) {
 		printk("\nDMA used");
 		if (devpriv->us_UseDma == ADDI_ENABLE) {
-			// alloc DMA buffers
+			/*  alloc DMA buffers */
 			devpriv->b_DmaDoubleBuffer = 0;
 			for (i = 0; i < 2; i++) {
 				for (pages = 4; pages >= 0; pages--) {
@@ -2739,16 +2739,16 @@ static int i_ADDI_Attach(struct comedi_d
 #ifdef CONFIG_APCI_1710
 		i_ADDI_AttachPCI1710(dev);
 
-		// save base address
+		/*  save base address */
 		devpriv->s_BoardInfos.ui_Address = io_addr[2];
 #endif
 	} else {
-		//Update-0.7.57->0.7.68dev->n_subdevices = 7;
+		/* Update-0.7.57->0.7.68dev->n_subdevices = 7; */
 		n_subdevices = 7;
 		if ((ret = alloc_subdevices(dev, n_subdevices)) < 0)
 			return ret;
 
-		// Allocate and Initialise AI Subdevice Structures
+		/*  Allocate and Initialise AI Subdevice Structures */
 		s = dev->subdevices + 0;
 		if ((this_board->i_NbrAiChannel)
 			|| (this_board->i_NbrAiChannelDiff)) {
@@ -2786,7 +2786,7 @@ static int i_ADDI_Attach(struct comedi_d
 			s->type = COMEDI_SUBD_UNUSED;
 		}
 
-		// Allocate and Initialise AO Subdevice Structures
+		/*  Allocate and Initialise AO Subdevice Structures */
 		s = dev->subdevices + 1;
 		if (this_board->i_NbrAoChannel) {
 			s->type = COMEDI_SUBD_AO;
@@ -2804,7 +2804,7 @@ static int i_ADDI_Attach(struct comedi_d
 		} else {
 			s->type = COMEDI_SUBD_UNUSED;
 		}
-		// Allocate and Initialise DI Subdevice Structures
+		/*  Allocate and Initialise DI Subdevice Structures */
 		s = dev->subdevices + 2;
 		if (this_board->i_NbrDiChannel) {
 			s->type = COMEDI_SUBD_DI;
@@ -2824,7 +2824,7 @@ static int i_ADDI_Attach(struct comedi_d
 		} else {
 			s->type = COMEDI_SUBD_UNUSED;
 		}
-		// Allocate and Initialise DO Subdevice Structures
+		/*  Allocate and Initialise DO Subdevice Structures */
 		s = dev->subdevices + 3;
 		if (this_board->i_NbrDoChannel) {
 			s->type = COMEDI_SUBD_DO;
@@ -2837,7 +2837,7 @@ static int i_ADDI_Attach(struct comedi_d
 			s->range_table = &range_digital;
 			s->io_bits = 0xf;	/* all bits output */
 
-			s->insn_config = this_board->i_hwdrv_InsnConfigDigitalOutput;	//for digital output memory..
+			s->insn_config = this_board->i_hwdrv_InsnConfigDigitalOutput;	/* for digital output memory.. */
 			s->insn_write =
 				this_board->i_hwdrv_InsnWriteDigitalOutput;
 			s->insn_bits =
@@ -2848,7 +2848,7 @@ static int i_ADDI_Attach(struct comedi_d
 			s->type = COMEDI_SUBD_UNUSED;
 		}
 
-		// Allocate and Initialise Timer Subdevice Structures
+		/*  Allocate and Initialise Timer Subdevice Structures */
 		s = dev->subdevices + 4;
 		if (this_board->i_Timer) {
 			s->type = COMEDI_SUBD_TIMER;
@@ -2868,7 +2868,7 @@ static int i_ADDI_Attach(struct comedi_d
 			s->type = COMEDI_SUBD_UNUSED;
 		}
 
-		// Allocate and Initialise TTL
+		/*  Allocate and Initialise TTL */
 		s = dev->subdevices + 5;
 		if (this_board->i_NbrTTLChannel) {
 			s->type = COMEDI_SUBD_TTLIO;
@@ -2965,7 +2965,7 @@ static int i_ADDI_Detach(struct comedi_d
 		}
 
 		if (pci_list_builded) {
-			//v_pci_card_list_cleanup(PCI_VENDOR_ID_AMCC);
+			/* v_pci_card_list_cleanup(PCI_VENDOR_ID_AMCC); */
 			v_pci_card_list_cleanup(this_board->i_VendorId);
 			pci_list_builded = 0;
 		}
@@ -2999,7 +2999,7 @@ static int i_ADDI_Reset(struct comedi_de
 	return 0;
 }
 
-// Interrupt function
+/* Interrupt function */
 /*
 +----------------------------------------------------------------------------+
 | Function name     :                                                        |
@@ -3025,7 +3025,7 @@ static irqreturn_t v_ADDI_Interrupt(int 
 	return IRQ_RETVAL(1);
 }
 
-// EEPROM Read Function
+/* EEPROM Read Function */
 /*
 +----------------------------------------------------------------------------+
 | Function name     :                                                        |
@@ -3051,12 +3051,12 @@ static int i_ADDIDATA_InsnReadEeprom(str
 {
 	unsigned short w_Data;
 	unsigned short w_Address;
-	w_Address = CR_CHAN(insn->chanspec);	// address to be read as 0,1,2,3...255
+	w_Address = CR_CHAN(insn->chanspec);	/*  address to be read as 0,1,2,3...255 */
 
 	w_Data = w_EepromReadWord(devpriv->i_IobaseAmcc,
 		this_board->pc_EepromChip, 0x100 + (2 * w_Address));
 	data[0] = w_Data;
-	//multiplied by 2 bcozinput will be like 0,1,2...255
+	/* multiplied by 2 bcozinput will be like 0,1,2...255 */
 	return insn->n;
 
 }
--- a/drivers/staging/comedi/drivers/addi-data/addi_common.h
+++ b/drivers/staging/comedi/drivers/addi-data/addi_common.h
@@ -62,36 +62,36 @@
 
 /* structure for the boardtype */
 struct addi_board {
-	const char *pc_DriverName;	// driver name
-	int i_VendorId;		//PCI vendor a device ID of card
+	const char *pc_DriverName;	/*  driver name */
+	int i_VendorId;		/* PCI vendor a device ID of card */
 	int i_DeviceId;
 	int i_IorangeBase0;
 	int i_IorangeBase1;
-	int i_IorangeBase2;	//  base 2 range
-	int i_IorangeBase3;	//  base 3 range
-	int i_PCIEeprom;	// eeprom present or not
-	char *pc_EepromChip;	// type of chip
-	int i_NbrAiChannel;	// num of A/D chans
-	int i_NbrAiChannelDiff;	// num of A/D chans in diff mode
-	int i_AiChannelList;	// len of chanlist
-	int i_NbrAoChannel;	// num of D/A chans
-	int i_AiMaxdata;	// resolution of A/D
-	int i_AoMaxdata;	// resolution of D/A
+	int i_IorangeBase2;	/*   base 2 range */
+	int i_IorangeBase3;	/*   base 3 range */
+	int i_PCIEeprom;	/*  eeprom present or not */
+	char *pc_EepromChip;	/*  type of chip */
+	int i_NbrAiChannel;	/*  num of A/D chans */
+	int i_NbrAiChannelDiff;	/*  num of A/D chans in diff mode */
+	int i_AiChannelList;	/*  len of chanlist */
+	int i_NbrAoChannel;	/*  num of D/A chans */
+	int i_AiMaxdata;	/*  resolution of A/D */
+	int i_AoMaxdata;	/*  resolution of D/A */
         const struct comedi_lrange *pr_AiRangelist;	/* rangelist for A/D */
         const struct comedi_lrange *pr_AoRangelist;	/* rangelist for D/A */
 
-	int i_NbrDiChannel;	// Number of DI channels
-	int i_NbrDoChannel;	// Number of DO channels
-	int i_DoMaxdata;	// data to set all chanels high
+	int i_NbrDiChannel;	/*  Number of DI channels */
+	int i_NbrDoChannel;	/*  Number of DO channels */
+	int i_DoMaxdata;	/*  data to set all chanels high */
 
-	int i_NbrTTLChannel;	// Number of TTL channels
+	int i_NbrTTLChannel;	/*  Number of TTL channels */
 	const struct comedi_lrange *pr_TTLRangelist;	/* rangelist for TTL */
 
-	int i_Dma;		// dma present or not
-	int i_Timer;		//   timer subdevice present or not
+	int i_Dma;		/*  dma present or not */
+	int i_Timer;		/*    timer subdevice present or not */
 	unsigned char b_AvailableConvertUnit;
-	unsigned int ui_MinAcquisitiontimeNs;	// Minimum Acquisition in Nano secs
-	unsigned int ui_MinDelaytimeNs;	// Minimum Delay in Nano secs
+	unsigned int ui_MinAcquisitiontimeNs;	/*  Minimum Acquisition in Nano secs */
+	unsigned int ui_MinDelaytimeNs;	/*  Minimum Delay in Nano secs */
 
 	/* interrupt and reset */
 	void (*v_hwdrv_Interrupt)(int irq, void *d);
@@ -348,57 +348,57 @@ union str_ModuleInfo {
 struct addi_private {
 
 	int iobase;
-	int i_IobaseAmcc;	// base+size for AMCC chip
-	int i_IobaseAddon;	//addon base address
+	int i_IobaseAmcc;	/*  base+size for AMCC chip */
+	int i_IobaseAddon;	/* addon base address */
 	int i_IobaseReserved;
 	unsigned long dw_AiBase;
-	struct pcilst_struct *amcc;	// ptr too AMCC data
-	unsigned char allocated;		// we have blocked card
-	unsigned char b_ValidDriver;	// driver is ok
-	unsigned char b_AiContinuous;	// we do unlimited AI
+	struct pcilst_struct *amcc;	/*  ptr too AMCC data */
+	unsigned char allocated;		/*  we have blocked card */
+	unsigned char b_ValidDriver;	/*  driver is ok */
+	unsigned char b_AiContinuous;	/*  we do unlimited AI */
 	unsigned char b_AiInitialisation;
-	unsigned int ui_AiActualScan;	//how many scans we finished
-	unsigned int ui_AiBufferPtr;	// data buffer ptr in samples
-	unsigned int ui_AiNbrofChannels;	// how many channels is measured
-	unsigned int ui_AiScanLength;	// Length of actual scanlist
-	unsigned int ui_AiActualScanPosition;	// position in actual scan
-	unsigned int * pui_AiChannelList;	// actual chanlist
-	unsigned int ui_AiChannelList[32];	// actual chanlist
-	unsigned char b_AiChannelConfiguration[32];	// actual chanlist
+	unsigned int ui_AiActualScan;	/* how many scans we finished */
+	unsigned int ui_AiBufferPtr;	/*  data buffer ptr in samples */
+	unsigned int ui_AiNbrofChannels;	/*  how many channels is measured */
+	unsigned int ui_AiScanLength;	/*  Length of actual scanlist */
+	unsigned int ui_AiActualScanPosition;	/*  position in actual scan */
+	unsigned int * pui_AiChannelList;	/*  actual chanlist */
+	unsigned int ui_AiChannelList[32];	/*  actual chanlist */
+	unsigned char b_AiChannelConfiguration[32];	/*  actual chanlist */
 	unsigned int ui_AiReadData[32];
 	unsigned int dw_AiInitialised;
-	unsigned int ui_AiTimer0;	//Timer Constant for Timer0
-	unsigned int ui_AiTimer1;	//Timer constant for Timer1
+	unsigned int ui_AiTimer0;	/* Timer Constant for Timer0 */
+	unsigned int ui_AiTimer1;	/* Timer constant for Timer1 */
 	unsigned int ui_AiFlags;
 	unsigned int ui_AiDataLength;
-	short *AiData;	// Pointer to sample data
-	unsigned int ui_AiNbrofScans;	// number of scans to do
-	unsigned short us_UseDma;	// To use Dma or not
-	unsigned char b_DmaDoubleBuffer;	// we can use double buffering
-	unsigned int ui_DmaActualBuffer;	// which buffer is used now
+	short *AiData;	/*  Pointer to sample data */
+	unsigned int ui_AiNbrofScans;	/*  number of scans to do */
+	unsigned short us_UseDma;	/*  To use Dma or not */
+	unsigned char b_DmaDoubleBuffer;	/*  we can use double buffering */
+	unsigned int ui_DmaActualBuffer;	/*  which buffer is used now */
 	/* UPDATE-0.7.57->0.7.68 */
 	/* unsigned int               ul_DmaBufferVirtual[2]; pointers to begin of DMA buffer */
-	short *ul_DmaBufferVirtual[2];	// pointers to begin of DMA buffer
-	unsigned int ul_DmaBufferHw[2];	// hw address of DMA buff
-	unsigned int ui_DmaBufferSize[2];	// size of dma buffer in bytes
-	unsigned int ui_DmaBufferUsesize[2];	// which size we may now used for transfer
-	unsigned int ui_DmaBufferSamples[2];	// size in samples
-	unsigned int ui_DmaBufferPages[2];	// number of pages in buffer
-	unsigned char b_DigitalOutputRegister;	// Digital Output Register
+	short *ul_DmaBufferVirtual[2];	/*  pointers to begin of DMA buffer */
+	unsigned int ul_DmaBufferHw[2];	/*  hw address of DMA buff */
+	unsigned int ui_DmaBufferSize[2];	/*  size of dma buffer in bytes */
+	unsigned int ui_DmaBufferUsesize[2];	/*  which size we may now used for transfer */
+	unsigned int ui_DmaBufferSamples[2];	/*  size in samples */
+	unsigned int ui_DmaBufferPages[2];	/*  number of pages in buffer */
+	unsigned char b_DigitalOutputRegister;	/*  Digital Output Register */
 	unsigned char b_OutputMemoryStatus;
-	unsigned char b_AnalogInputChannelNbr;	// Analog input channel Nbr
-	unsigned char b_AnalogOutputChannelNbr;	// Analog input Output  Nbr
-	unsigned char b_TimerSelectMode;	// Contain data written at iobase + 0C
-	unsigned char b_ModeSelectRegister;	// Contain data written at iobase + 0E
-	unsigned short us_OutputRegister;	// Contain data written at iobase + 0
+	unsigned char b_AnalogInputChannelNbr;	/*  Analog input channel Nbr */
+	unsigned char b_AnalogOutputChannelNbr;	/*  Analog input Output  Nbr */
+	unsigned char b_TimerSelectMode;	/*  Contain data written at iobase + 0C */
+	unsigned char b_ModeSelectRegister;	/*  Contain data written at iobase + 0E */
+	unsigned short us_OutputRegister;	/*  Contain data written at iobase + 0 */
 	unsigned char b_InterruptState;
-	unsigned char b_TimerInit;	// Specify if InitTimerWatchdog was load
-	unsigned char b_TimerStarted;	// Specify if timer 2 is running or not
-	unsigned char b_Timer2Mode;	// Specify the timer 2 mode
-	unsigned char b_Timer2Interrupt;	//Timer2  interrupt enable or disable
-	unsigned char b_AiCyclicAcquisition;	// indicate cyclic acquisition
-	unsigned char b_InterruptMode;	// eoc eos or dma
-	unsigned char b_EocEosInterrupt;	// Enable disable eoc eos interrupt
+	unsigned char b_TimerInit;	/*  Specify if InitTimerWatchdog was load */
+	unsigned char b_TimerStarted;	/*  Specify if timer 2 is running or not */
+	unsigned char b_Timer2Mode;	/*  Specify the timer 2 mode */
+	unsigned char b_Timer2Interrupt;	/* Timer2  interrupt enable or disable */
+	unsigned char b_AiCyclicAcquisition;	/*  indicate cyclic acquisition */
+	unsigned char b_InterruptMode;	/*  eoc eos or dma */
+	unsigned char b_EocEosInterrupt;	/*  Enable disable eoc eos interrupt */
 	unsigned int ui_EocEosConversionTime;
 	unsigned char b_EocEosConversionTimeBase;
 	unsigned char b_SingelDiff;
--- a/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c
@@ -45,11 +45,11 @@ You shoud also find the complete GPL in 
   +----------+-----------+------------------------------------------------+
 */
 
-#define NVCMD_BEGIN_READ 	(0x7 << 5 )	// nvRam begin read command
-#define NVCMD_LOAD_LOW   	(0x4 << 5 )	// nvRam load low command
-#define NVCMD_LOAD_HIGH  	(0x5 << 5 )	// nvRam load high command
-#define EE76_CMD_LEN    	13	// bits in instructions
-#define EE_READ         	0x0180	// 01 1000 0000 read instruction
+#define NVCMD_BEGIN_READ 	(0x7 << 5 )	/*  nvRam begin read command */
+#define NVCMD_LOAD_LOW   	(0x4 << 5 )	/*  nvRam load low command */
+#define NVCMD_LOAD_HIGH  	(0x5 << 5 )	/*  nvRam load high command */
+#define EE76_CMD_LEN    	13	/*  bits in instructions */
+#define EE_READ         	0x0180	/*  01 1000 0000 read instruction */
 
 #define EEPROM_DIGITALINPUT 			0
 #define EEPROM_DIGITALOUTPUT			1
@@ -82,13 +82,13 @@ struct str_DigitalOutputHeader {
 };
 
 
-// used for timer as well as watchdog
+/* used for timer as well as watchdog */
 
 struct str_TimerDetails {
 
 	unsigned short w_HeaderSize;
 	unsigned char b_Resolution;
-	unsigned char b_Mode;		// in case of Watchdog it is functionality
+	unsigned char b_Mode;		/*  in case of Watchdog it is functionality */
 	unsigned short w_MinTiming;
 	unsigned char b_TimeBase;
 };
@@ -97,7 +97,7 @@ struct str_TimerMainHeader {
 
 
 	unsigned short w_Ntimer;
-	struct str_TimerDetails s_TimerDetails[4];	//  supports 4 timers
+	struct str_TimerDetails s_TimerDetails[4];	/*   supports 4 timers */
 };
 
 
@@ -206,9 +206,9 @@ unsigned short w_EepromReadWord(unsigned
 		for (b_Counter = 0; b_Counter < 2; b_Counter++)
 		{
 
-			b_SelectedAddressLow = (w_EepromStartAddress + b_Counter) % 256;	//Read the low 8 bit part
+			b_SelectedAddressLow = (w_EepromStartAddress + b_Counter) % 256;	/* Read the low 8 bit part */
 
-			b_SelectedAddressHigh = (w_EepromStartAddress + b_Counter) / 256;	//Read the high 8 bit part
+			b_SelectedAddressHigh = (w_EepromStartAddress + b_Counter) / 256;	/* Read the high 8 bit part */
 
 	      /************************************/
 
@@ -319,20 +319,20 @@ unsigned short w_EepromReadWord(unsigned
 
 				b_ReadLowByte = b_ReadByte;
 
-			}	// if(b_Counter==0)
+			}	/*  if(b_Counter==0) */
 
 			else
 			{
 
 				b_ReadHighByte = b_ReadByte;
 
-			}	// if(b_Counter==0)
+			}	/*  if(b_Counter==0) */
 
-		}		// for (b_Counter=0; b_Counter<2; b_Counter++)
+		}		/*  for (b_Counter=0; b_Counter<2; b_Counter++) */
 
 		w_ReadWord = (b_ReadLowByte | (((unsigned short) b_ReadHighByte) * 256));
 
-	}			// end of if ((!strcmp(pc_PCIChipInformation, "S5920")) || (!strcmp(pc_PCIChipInformation, "S5933")))
+	}			/*  end of if ((!strcmp(pc_PCIChipInformation, "S5920")) || (!strcmp(pc_PCIChipInformation, "S5933"))) */
 
 	if (!strcmp(pc_PCIChipInformation, "93C76"))
 	{
@@ -902,15 +902,15 @@ int i_EepromReadMainHeader(unsigned shor
 			break;
 
 		case EEPROM_TIMER:
-			this_board->i_Timer = 1;	//Timer subdevice present
+			this_board->i_Timer = 1;	/* Timer subdevice present */
 			break;
 
 		case EEPROM_WATCHDOG:
-			this_board->i_Timer = 1;	//Timer subdevice present
+			this_board->i_Timer = 1;	/* Timer subdevice present */
 			break;
 
 		case EEPROM_TIMER_WATCHDOG_COUNTER:
-			this_board->i_Timer = 1;	//Timer subdevice present
+			this_board->i_Timer = 1;	/* Timer subdevice present */
 		}
 	}
 
@@ -944,17 +944,17 @@ int i_EepromReadDigitalInputHeader(unsig
 {
 	unsigned short w_Temp;
 
-	// read nbr of channels
+	/*  read nbr of channels */
 	s_Header->w_Nchannel =
 		w_EepromReadWord(w_PCIBoardEepromAddress, pc_PCIChipInformation,
 		0x100 + w_Address + 6);
 
-	// interruptible or not
+	/*  interruptible or not */
 	w_Temp = w_EepromReadWord(w_PCIBoardEepromAddress,
 		pc_PCIChipInformation, 0x100 + w_Address + 8);
 	s_Header->b_Interruptible = (unsigned char) (w_Temp >> 7) & 0x01;
 
-// How many interruptible logic
+/* How many interruptible logic */
 	s_Header->w_NinterruptLogic =
 		w_EepromReadWord(w_PCIBoardEepromAddress, pc_PCIChipInformation,
 		0x100 + w_Address + 10);
@@ -987,7 +987,7 @@ int i_EepromReadDigitalOutputHeader(unsi
 	char *pc_PCIChipInformation, unsigned short w_Address,
 	struct str_DigitalOutputHeader * s_Header)
 {
-// Read Nbr channels
+/* Read Nbr channels */
 	s_Header->w_Nchannel =
 		w_EepromReadWord(w_PCIBoardEepromAddress, pc_PCIChipInformation,
 		0x100 + w_Address + 6);
@@ -1021,11 +1021,11 @@ int i_EepromReadTimerHeader(unsigned sho
 
 	unsigned short i, w_Size = 0, w_Temp;
 
-//Read No of Timer
+/* Read No of Timer */
 	s_Header->w_Ntimer =
 		w_EepromReadWord(w_PCIBoardEepromAddress, pc_PCIChipInformation,
 		0x100 + w_Address + 6);
-//Read header size
+/* Read header size */
 
 	for (i = 0; i < s_Header->w_Ntimer; i++) {
 		s_Header->s_TimerDetails[i].w_HeaderSize =
@@ -1036,11 +1036,11 @@ int i_EepromReadTimerHeader(unsigned sho
 			pc_PCIChipInformation,
 			0x100 + w_Address + 8 + w_Size + 2);
 
-		//Read Resolution
+		/* Read Resolution */
 		s_Header->s_TimerDetails[i].b_Resolution =
 			(unsigned char) (w_Temp >> 10) & 0x3F;
 
-		//Read Mode
+		/* Read Mode */
 		s_Header->s_TimerDetails[i].b_Mode =
 			(unsigned char) (w_Temp >> 4) & 0x3F;
 
@@ -1048,10 +1048,10 @@ int i_EepromReadTimerHeader(unsigned sho
 			pc_PCIChipInformation,
 			0x100 + w_Address + 8 + w_Size + 4);
 
-		//Read MinTiming
+		/* Read MinTiming */
 		s_Header->s_TimerDetails[i].w_MinTiming = (w_Temp >> 6) & 0x3FF;
 
-		//Read Timebase
+		/* Read Timebase */
 		s_Header->s_TimerDetails[i].b_TimeBase = (unsigned char) (w_Temp) & 0x3F;
 		w_Size += s_Header->s_TimerDetails[i].w_HeaderSize;
 	}
@@ -1085,11 +1085,11 @@ int i_EepromReadAnlogOutputHeader(unsign
 	str_AnalogOutputHeader * s_Header)
 {
 	unsigned short w_Temp;
-	// No of channels for 1st hard component
+	/*  No of channels for 1st hard component */
 	w_Temp = w_EepromReadWord(w_PCIBoardEepromAddress,
 		pc_PCIChipInformation, 0x100 + w_Address + 10);
 	s_Header->w_Nchannel = (w_Temp >> 4) & 0x03FF;
-	// Resolution for 1st hard component
+	/*  Resolution for 1st hard component */
 	w_Temp = w_EepromReadWord(w_PCIBoardEepromAddress,
 		pc_PCIChipInformation, 0x100 + w_Address + 16);
 	s_Header->b_Resolution = (unsigned char) (w_Temp >> 8) & 0xFF;
@@ -1117,7 +1117,7 @@ int i_EepromReadAnlogOutputHeader(unsign
 +----------------------------------------------------------------------------+
 */
 
-// Reads only for ONE  hardware component
+/* Reads only for ONE  hardware component */
 int i_EepromReadAnlogInputHeader(unsigned short w_PCIBoardEepromAddress,
 	char *pc_PCIChipInformation, unsigned short w_Address,
 	struct str_AnalogInputHeader * s_Header)
@@ -1134,24 +1134,24 @@ int i_EepromReadAnlogInputHeader(unsigne
 		0x100 + w_Address + 30);
 	w_Temp = w_EepromReadWord(w_PCIBoardEepromAddress,
 		pc_PCIChipInformation, 0x100 + w_Address + 20);
-	s_Header->b_HasDma = (w_Temp >> 13) & 0x01;	// whether dma present or not
+	s_Header->b_HasDma = (w_Temp >> 13) & 0x01;	/*  whether dma present or not */
 
-	w_Temp = w_EepromReadWord(w_PCIBoardEepromAddress, pc_PCIChipInformation, 0x100 + w_Address + 72);	// reading Y
+	w_Temp = w_EepromReadWord(w_PCIBoardEepromAddress, pc_PCIChipInformation, 0x100 + w_Address + 72);	/*  reading Y */
 	w_Temp = w_Temp & 0x00FF;
-	if (w_Temp)		//Y>0
+	if (w_Temp)		/* Y>0 */
 	{
-		w_Offset = 74 + (2 * w_Temp) + (10 * (1 + (w_Temp / 16)));	// offset of first analog input single header
-		w_Offset = w_Offset + 2;	// resolution
-	} else			//Y=0
+		w_Offset = 74 + (2 * w_Temp) + (10 * (1 + (w_Temp / 16)));	/*  offset of first analog input single header */
+		w_Offset = w_Offset + 2;	/*  resolution */
+	} else			/* Y=0 */
 	{
 		w_Offset = 74;
-		w_Offset = w_Offset + 2;	// resolution
+		w_Offset = w_Offset + 2;	/*  resolution */
 	}
 
-// read Resolution
+/* read Resolution */
 	w_Temp = w_EepromReadWord(w_PCIBoardEepromAddress,
 		pc_PCIChipInformation, 0x100 + w_Address + w_Offset);
-	s_Header->b_Resolution = w_Temp & 0x001F;	// last 5 bits
+	s_Header->b_Resolution = w_Temp & 0x001F;	/*  last 5 bits */
 
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h
+++ b/drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h
@@ -31,15 +31,15 @@
 
 *************************/
 
-#define FIFO_ADVANCE_ON_BYTE_2     0x20000000	// written on base0
+#define FIFO_ADVANCE_ON_BYTE_2     0x20000000	/*  written on base0 */
 
-#define AMWEN_ENABLE                     0x02	// added for step 6 dma written on base2
+#define AMWEN_ENABLE                     0x02	/*  added for step 6 dma written on base2 */
 #define A2P_FIFO_WRITE_ENABLE            0x01
 
-#define AGCSTS_TC_ENABLE		   0x10000000	// Added for transfer count enable bit
+#define AGCSTS_TC_ENABLE		   0x10000000	/*  Added for transfer count enable bit */
 
-//  ADDON RELATED ADDITIONS
-// Constant
+/* ADDON RELATED ADDITIONS */
+/* Constant */
 #define     APCI3120_ENABLE_TRANSFER_ADD_ON_LOW       0x00
 #define     APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH      0x1200
 #define     APCI3120_A2P_FIFO_MANAGEMENT              0x04000400L
@@ -52,7 +52,7 @@
 #define     APCI3120_DISABLE_BUS_MASTER_ADD_ON        0x0
 #define     APCI3120_DISABLE_BUS_MASTER_PCI           0x0
 
- // ADD_ON ::: this needed since apci supports 16 bit interface to add on
+ /*  ADD_ON ::: this needed since apci supports 16 bit interface to add on */
 #define     APCI3120_ADD_ON_AGCSTS_LOW       0x3C
 #define     APCI3120_ADD_ON_AGCSTS_HIGH      APCI3120_ADD_ON_AGCSTS_LOW + 2
 #define     APCI3120_ADD_ON_MWAR_LOW         0x24
@@ -60,7 +60,7 @@
 #define     APCI3120_ADD_ON_MWTC_LOW         0x058
 #define     APCI3120_ADD_ON_MWTC_HIGH        APCI3120_ADD_ON_MWTC_LOW + 2
 
-// AMCC
+/* AMCC */
 #define     APCI3120_AMCC_OP_MCSR            0x3C
 #define     APCI3120_AMCC_OP_REG_INTCSR      0x38
 
@@ -212,7 +212,7 @@ struct pcilst_struct {
 	unsigned int irq;
 };
 
-struct pcilst_struct *amcc_devices;	// ptr to root list of all amcc devices
+struct pcilst_struct *amcc_devices;	/*  ptr to root list of all amcc devices */
 
 /****************************************************************************/
 
@@ -267,7 +267,7 @@ void v_pci_card_list_init(unsigned short
 			amcc->vendor = pcidev->vendor;
 			amcc->device = pcidev->device;
 #if 0
-			amcc->master = pcidev->master;	// how get this information under 2.4 kernels?
+			amcc->master = pcidev->master;	/*  how get this information under 2.4 kernels? */
 #endif
 			amcc->pci_bus = pcidev->bus->number;
 			amcc->pci_slot = PCI_SLOT(pcidev->devfn);
@@ -333,17 +333,17 @@ int i_find_free_pci_card_by_position(uns
 		    && (amcc->pci_slot == pci_slot)) {
 			if (!(amcc->used)) {
 				*card = amcc;
-				return 0;	// ok, card is found
+				return 0;	/*  ok, card is found */
 			} else {
 				rt_printk
 				    (" - \nCard on requested position is used b:s %d:%d!\n",
 				     pci_bus, pci_slot);
-				return 2;	// card exist but is used
+				return 2;	/*  card exist but is used */
 			}
 		}
 	}
 
-	return 1;		// no card found
+	return 1;		/*  no card found */
 }
 
 /****************************************************************************/
@@ -422,7 +422,7 @@ struct pcilst_struct *ptr_select_and_all
 {
 	struct pcilst_struct *card;
 
-	if ((pci_bus < 1) & (pci_slot < 1)) {	// use autodetection
+	if ((pci_bus < 1) & (pci_slot < 1)) {	/*  use autodetection */
 		if ((card = ptr_find_free_pci_card_by_device(vendor_id,
 							     device_id)) ==
 		    NULL) {
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Chrono.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Chrono.c
@@ -736,7 +736,7 @@ int i_APCI1710_InsnConfigInitChrono(stru
 							DPRINTK("Base timing selection is wrong\n");
 							i_ReturnValue = -7;
 						}
-					}	// if ((b_TimingUnit >= 0) && (b_TimingUnit <= 4))
+					}	/*  if ((b_TimingUnit >= 0) && (b_TimingUnit <= 4)) */
 					else {
 		       /***********************************/
 						/* Timing unity selection is wrong */
@@ -744,8 +744,8 @@ int i_APCI1710_InsnConfigInitChrono(stru
 
 						DPRINTK("Timing unity selection is wrong\n");
 						i_ReturnValue = -6;
-					}	// if ((b_TimingUnit >= 0) && (b_TimingUnit <= 4))
-				}	// if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ))
+					}	/*  if ((b_TimingUnit >= 0) && (b_TimingUnit <= 4)) */
+				}	/*  if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ)) */
 				else {
 		    /*****************************************/
 					/* The selected PCI input clock is wrong */
@@ -753,8 +753,8 @@ int i_APCI1710_InsnConfigInitChrono(stru
 
 					DPRINTK("The selected PCI input clock is wrong\n");
 					i_ReturnValue = -5;
-				}	// if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ))
-			}	// if (b_ChronoMode >= 0 && b_ChronoMode <= 7)
+				}	/*  if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ)) */
+			}	/*  if (b_ChronoMode >= 0 && b_ChronoMode <= 7) */
 			else {
 		 /***************************************/
 				/* Chronometer mode selection is wrong */
@@ -762,7 +762,7 @@ int i_APCI1710_InsnConfigInitChrono(stru
 
 				DPRINTK("Chronometer mode selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_ChronoMode >= 0 && b_ChronoMode <= 7)
+			}	/*  if (b_ChronoMode >= 0 && b_ChronoMode <= 7) */
 		} else {
 	      /******************************************/
 			/* The module is not a Chronometer module */
@@ -951,7 +951,7 @@ int i_APCI1710_InsnWriteEnableDisableChr
 									ui_Address
 									+ 32 +
 									(64 * b_ModulNbr));
-								devpriv->tsk_Current = current;	// Save the current process task structure
+								devpriv->tsk_Current = current;	/*  Save the current process task structure */
 							}
 
 			  /***********************************/
@@ -980,7 +980,7 @@ int i_APCI1710_InsnWriteEnableDisableChr
 								36 +
 								(64 * b_ModulNbr));
 
-						}	// if ((b_InterruptEnable == APCI1710_ENABLE) || (b_InterruptEnable == APCI1710_DISABLE))
+						}	/*  if ((b_InterruptEnable == APCI1710_ENABLE) || (b_InterruptEnable == APCI1710_DISABLE)) */
 						else {
 		       /********************************/
 							/* Interrupt parameter is wrong */
@@ -988,8 +988,8 @@ int i_APCI1710_InsnWriteEnableDisableChr
 
 							DPRINTK("Interrupt parameter is wrong\n");
 							i_ReturnValue = -6;
-						}	// if ((b_InterruptEnable == APCI1710_ENABLE) || (b_InterruptEnable == APCI1710_DISABLE))
-					}	// if ((b_CycleMode == APCI1710_SINGLE) || (b_CycleMode == APCI1710_CONTINUOUS))
+						}	/*  if ((b_InterruptEnable == APCI1710_ENABLE) || (b_InterruptEnable == APCI1710_DISABLE)) */
+					}	/*  if ((b_CycleMode == APCI1710_SINGLE) || (b_CycleMode == APCI1710_CONTINUOUS)) */
 					else {
 		    /***********************************************/
 						/* Chronometer acquisition mode cycle is wrong */
@@ -997,7 +997,7 @@ int i_APCI1710_InsnWriteEnableDisableChr
 
 						DPRINTK("Chronometer acquisition mode cycle is wrong\n");
 						i_ReturnValue = -5;
-					}	// if ((b_CycleMode == APCI1710_SINGLE) || (b_CycleMode == APCI1710_CONTINUOUS))
+					}	/*  if ((b_CycleMode == APCI1710_SINGLE) || (b_CycleMode == APCI1710_CONTINUOUS)) */
 					break;
 
 				case APCI1710_DISABLE:
@@ -1046,7 +1046,7 @@ int i_APCI1710_InsnWriteEnableDisableChr
 				default:
 					DPRINTK("Inputs wrong! Enable or Disable chrono\n");
 					i_ReturnValue = -8;
-				}	// switch ENABLE/DISABLE
+				}	/*  switch ENABLE/DISABLE */
 			} else {
 		 /*******************************/
 				/* Chronometer not initialised */
@@ -1233,7 +1233,7 @@ int i_APCI1710_GetChronoProgressStatus(s
 		    /******************/
 
 					*pb_ChronoStatus = 3;
-				}	// if ((dw_Status & 8) == 8)
+				}	/*  if ((dw_Status & 8) == 8) */
 				else {
 		    /*******************************/
 					/* Test if measurement stopped */
@@ -1245,7 +1245,7 @@ int i_APCI1710_GetChronoProgressStatus(s
 		       /***********************/
 
 						*pb_ChronoStatus = 2;
-					}	// if ((dw_Status & 2) == 2)
+					}	/*  if ((dw_Status & 2) == 2) */
 					else {
 		       /*******************************/
 						/* Test if measurement started */
@@ -1257,16 +1257,16 @@ int i_APCI1710_GetChronoProgressStatus(s
 			  /************************/
 
 							*pb_ChronoStatus = 1;
-						}	// if ((dw_Status & 1) == 1)
+						}	/*  if ((dw_Status & 1) == 1) */
 						else {
 			  /***************************/
 							/* Measurement not started */
 			  /***************************/
 
 							*pb_ChronoStatus = 0;
-						}	// if ((dw_Status & 1) == 1)
-					}	// if ((dw_Status & 2) == 2)
-				}	// if ((dw_Status & 8) == 8)
+						}	/*  if ((dw_Status & 1) == 1) */
+					}	/*  if ((dw_Status & 2) == 2) */
+				}	/*  if ((dw_Status & 8) == 8) */
 			} else {
 		 /*******************************/
 				/* Chronometer not initialised */
@@ -1430,7 +1430,7 @@ int i_APCI1710_ReadChronoValue(struct co
 							}
 
 							break;
-						}	// if ((dw_Status & 8) == 8)
+						}	/*  if ((dw_Status & 8) == 8) */
 						else {
 			     /*******************************/
 							/* Test if measurement stopped */
@@ -1464,7 +1464,7 @@ int i_APCI1710_ReadChronoValue(struct co
 									outl(0, devpriv->s_BoardInfos.ui_Address + 36 + (64 * b_ModulNbr));
 								}
 								break;
-							}	// if ((dw_Status & 2) == 2)
+							}	/*  if ((dw_Status & 2) == 2) */
 							else {
 				/*******************************/
 								/* Test if measurement started */
@@ -1478,7 +1478,7 @@ int i_APCI1710_ReadChronoValue(struct co
 									*pb_ChronoStatus
 										=
 										1;
-								}	// if ((dw_Status & 1) == 1)
+								}	/*  if ((dw_Status & 1) == 1) */
 								else {
 				   /***************************/
 									/* Measurement not started */
@@ -1487,9 +1487,9 @@ int i_APCI1710_ReadChronoValue(struct co
 									*pb_ChronoStatus
 										=
 										0;
-								}	// if ((dw_Status & 1) == 1)
-							}	// if ((dw_Status & 2) == 2)
-						}	// if ((dw_Status & 8) == 8)
+								}	/*  if ((dw_Status & 1) == 1) */
+							}	/*  if ((dw_Status & 2) == 2) */
+						}	/*  if ((dw_Status & 8) == 8) */
 
 						if (dw_TimeOut == ui_TimeOut) {
 			     /*****************/
@@ -1507,7 +1507,7 @@ int i_APCI1710_ReadChronoValue(struct co
 							mdelay(1000);
 
 						}
-					}	// for (;;)
+					}	/*  for (;;) */
 
 		       /*****************************/
 					/* Test if stop signal occur */
@@ -1922,7 +1922,7 @@ int i_APCI1710_InsnBitsChronoDigitalIO(s
 							ui_Address + 20 +
 							(b_OutputChannel * 4) +
 							(64 * b_ModulNbr));
-					}	// if ((b_OutputChannel >= 0) && (b_OutputChannel <= 2))
+					}	/*  if ((b_OutputChannel >= 0) && (b_OutputChannel <= 2)) */
 					else {
 		    /****************************************/
 						/* The selected digital output is wrong */
@@ -1931,7 +1931,7 @@ int i_APCI1710_InsnBitsChronoDigitalIO(s
 						DPRINTK("The selected digital output is wrong\n");
 						i_ReturnValue = -4;
 
-					}	// if ((b_OutputChannel >= 0) && (b_OutputChannel <= 2))
+					}	/*  if ((b_OutputChannel >= 0) && (b_OutputChannel <= 2)) */
 
 					break;
 
@@ -1945,7 +1945,7 @@ int i_APCI1710_InsnBitsChronoDigitalIO(s
 							ui_Address + 20 +
 							(b_OutputChannel * 4) +
 							(64 * b_ModulNbr));
-					}	// if ((b_OutputChannel >= 0) && (b_OutputChannel <= 2))
+					}	/*  if ((b_OutputChannel >= 0) && (b_OutputChannel <= 2)) */
 					else {
 		    /****************************************/
 						/* The selected digital output is wrong */
@@ -1954,7 +1954,7 @@ int i_APCI1710_InsnBitsChronoDigitalIO(s
 						DPRINTK("The selected digital output is wrong\n");
 						i_ReturnValue = -4;
 
-					}	// if ((b_OutputChannel >= 0) && (b_OutputChannel <= 2))
+					}	/*  if ((b_OutputChannel >= 0) && (b_OutputChannel <= 2)) */
 
 					break;
 
@@ -1978,7 +1978,7 @@ int i_APCI1710_InsnBitsChronoDigitalIO(s
 							(unsigned char) (((dw_Status >>
 									b_InputChannel)
 								& 1) ^ 1);
-					}	// if ((b_InputChannel >= 0) && (b_InputChannel <= 2))
+					}	/*  if ((b_InputChannel >= 0) && (b_InputChannel <= 2)) */
 					else {
 		    /***************************************/
 						/* The selected digital input is wrong */
@@ -1986,7 +1986,7 @@ int i_APCI1710_InsnBitsChronoDigitalIO(s
 
 						DPRINTK("The selected digital input is wrong\n");
 						i_ReturnValue = -4;
-					}	// if ((b_InputChannel >= 0) && (b_InputChannel <= 2))
+					}	/*  if ((b_InputChannel >= 0) && (b_InputChannel <= 2)) */
 
 					break;
 
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Dig_io.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Dig_io.c
@@ -108,10 +108,10 @@ int i_APCI1710_InsnConfigDigitalIO(struc
 	unsigned int dw_WriteConfig = 0;
 
 	b_ModulNbr = (unsigned char) CR_AREF(insn->chanspec);
-	b_ConfigType = (unsigned char) data[0];	// Memory or  Init
+	b_ConfigType = (unsigned char) data[0];	/*  Memory or  Init */
 	b_ChannelAMode = (unsigned char) data[1];
 	b_ChannelBMode = (unsigned char) data[2];
-	b_MemoryOnOff = (unsigned char) data[1];	// if memory operation
+	b_MemoryOnOff = (unsigned char) data[1];	/*  if memory operation */
 	i_ReturnValue = insn->n;
 
 		/**************************/
@@ -126,7 +126,7 @@ int i_APCI1710_InsnConfigDigitalIO(struc
 	switch (b_ConfigType) {
 	case APCI1710_DIGIO_MEMORYONOFF:
 
-		if (b_MemoryOnOff)	// If Memory ON
+		if (b_MemoryOnOff)	/*  If Memory ON */
 		{
 		 /****************************/
 			/* Set the output memory on */
@@ -140,7 +140,7 @@ int i_APCI1710_InsnConfigDigitalIO(struc
 		 /***************************/
 			devpriv->s_ModuleInfo[b_ModulNbr].
 				s_DigitalIOInfo.dw_OutputMemory = 0;
-		} else		// If memory off
+		} else		/*  If memory off */
 		{
 		 /*****************************/
 			/* Set the output memory off */
@@ -233,7 +233,7 @@ int i_APCI1710_InsnConfigDigitalIO(struc
 			DPRINTK("The module is not a digital I/O module\n");
 			i_ReturnValue = -3;
 		}
-	}			// end of Switch
+	}			/*  end of Switch */
 	printk("Return Value %d\n", i_ReturnValue);
 	return i_ReturnValue;
 }
@@ -288,11 +288,11 @@ int i_APCI1710_InsnConfigDigitalIO(struc
 +----------------------------------------------------------------------------+
 */
 
-//_INT_   i_APCI1710_ReadDigitalIOChlValue      (unsigned char_    b_BoardHandle,
-//                                             unsigned char_    b_ModulNbr,
-//                                             unsigned char_    b_InputChannel,
-//
-//                                             unsigned char *_  pb_ChannelStatus)
+/* _INT_   i_APCI1710_ReadDigitalIOChlValue      (unsigned char_    b_BoardHandle, */
+/*
+* unsigned char_ b_ModulNbr, unsigned char_ b_InputChannel,
+* unsigned char *_ pb_ChannelStatus)
+*/
 int i_APCI1710_InsnReadDigitalIOChlValue(struct comedi_device * dev,
 	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
@@ -356,7 +356,7 @@ int i_APCI1710_InsnReadDigitalIOChlValue
 								i_ReturnValue =
 									-6;
 							}
-						}	// if (b_InputChannel == 5)
+						}	/*  if (b_InputChannel == 5) */
 						else {
 			  /***************************/
 							/* Test the channel B mode */
@@ -375,8 +375,8 @@ int i_APCI1710_InsnReadDigitalIOChlValue
 								i_ReturnValue =
 									-7;
 							}
-						}	// if (b_InputChannel == 5)
-					}	// if (b_InputChannel > 4)
+						}	/*  if (b_InputChannel == 5) */
+					}	/*  if (b_InputChannel > 4) */
 
 		    /***********************/
 					/* Test if error occur */
@@ -387,11 +387,10 @@ int i_APCI1710_InsnReadDigitalIOChlValue
 						/* Read all digital input */
 		       /**************************/
 
-						//INPDW (ps_APCI1710Variable->
-						//   s_Board [b_BoardHandle].
-						//   s_BoardInfos.
-						//  ui_Address + (64 * b_ModulNbr),
-						// &dw_StatusReg);
+/*
+* INPDW (ps_APCI1710Variable-> s_Board [b_BoardHandle].
+* s_BoardInfos. ui_Address + (64 * b_ModulNbr), &dw_StatusReg);
+*/
 
 						dw_StatusReg =
 							inl(devpriv->
@@ -404,7 +403,7 @@ int i_APCI1710_InsnReadDigitalIOChlValue
 								0x1C) >>
 							b_InputChannel) & 1;
 
-					}	// if (i_ReturnValue == 0)
+					}	/*  if (i_ReturnValue == 0) */
 				} else {
 		    /*******************************/
 					/* Digital I/O not initialised */
@@ -478,9 +477,10 @@ int i_APCI1710_InsnReadDigitalIOChlValue
 +----------------------------------------------------------------------------+
 */
 
-//_INT_   i_APCI1710_SetDigitalIOChlOn    (unsigned char_ b_BoardHandle,
-//                                       unsigned char_ b_ModulNbr,
-//                                       unsigned char_ b_OutputChannel)
+/*
+* _INT_ i_APCI1710_SetDigitalIOChlOn (unsigned char_ b_BoardHandle,
+* unsigned char_ b_ModulNbr, unsigned char_ b_OutputChannel)
+*/
 int i_APCI1710_InsnWriteDigitalIOChlOnOff(struct comedi_device * dev,
 	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
@@ -602,7 +602,7 @@ int i_APCI1710_InsnWriteDigitalIOChlOnOf
 								1 <<
 								b_OutputChannel;
 						}
-					}	// set channel off
+					}	/*  set channel off */
 					else {
 						if (devpriv->
 							s_ModuleInfo
@@ -627,23 +627,24 @@ int i_APCI1710_InsnWriteDigitalIOChlOnOf
 								dw_OutputMemory
 								= dw_WriteValue;
 						} else {
-		       /*****************************/
+							/*****************************/
 							/* Digital Output Memory OFF */
-		       /*****************************/
-							// +Use previously the function "i_APCI1710_SetDigitalIOMemoryOn"
+							/*****************************/
+							/*  +Use previously the function "i_APCI1710_SetDigitalIOMemoryOn" */
 							i_ReturnValue = -8;
 						}
 
 					}
-		    /*******************/
+					/*******************/
 					/* Write the value */
-		    /*******************/
+					/*******************/
 
-					//OUTPDW (ps_APCI1710Variable->
-					//    s_Board [b_BoardHandle].
-					//   s_BoardInfos.
-					//   ui_Address + (64 * b_ModulNbr),
-					//   dw_WriteValue);
+					/* OUTPDW (ps_APCI1710Variable->
+					 * s_Board [b_BoardHandle].
+					 * s_BoardInfos. ui_Address + (64 * b_ModulNbr),
+					 * dw_WriteValue);
+					 */
+*/
 					outl(dw_WriteValue,
 						devpriv->s_BoardInfos.
 						ui_Address + (64 * b_ModulNbr));
@@ -725,9 +726,11 @@ int i_APCI1710_InsnWriteDigitalIOChlOnOf
 +----------------------------------------------------------------------------+
 */
 
-//_INT_   i_APCI1710_SetDigitalIOPortOn   (unsigned char_ b_BoardHandle,
-//                                       unsigned char_ b_ModulNbr,
-//                                       unsigned char_ b_PortValue)
+/*
+ * _INT_ i_APCI1710_SetDigitalIOPortOn (unsigned char_
+ * b_BoardHandle, unsigned char_ b_ModulNbr, unsigned char_
+ * b_PortValue)
+*/
 int i_APCI1710_InsnBitsDigitalIOPortOnOff(struct comedi_device * dev,
 	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
@@ -740,42 +743,43 @@ int i_APCI1710_InsnBitsDigitalIOPortOnOf
 	unsigned char * pb_PortValue;
 
 	b_ModulNbr = (unsigned char) CR_AREF(insn->chanspec);
-	b_PortOperation = (unsigned char) data[0];	// Input or output
-	b_PortOnOFF = (unsigned char) data[1];	// if output then On or Off
-	b_PortValue = (unsigned char) data[2];	// if out put then Value
+	b_PortOperation = (unsigned char) data[0];	/*  Input or output */
+	b_PortOnOFF = (unsigned char) data[1];	/*  if output then On or Off */
+	b_PortValue = (unsigned char) data[2];	/*  if out put then Value */
 	i_ReturnValue = insn->n;
 	pb_PortValue = (unsigned char *) & data[0];
-// if input then read value
+/* if input then read value */
 
 	switch (b_PortOperation) {
 	case APCI1710_INPUT:
-	/**************************/
+		/**************************/
 		/* Test the module number */
-	/**************************/
+		/**************************/
 
 		if (b_ModulNbr < 4) {
-	   /*******************************/
+			/*******************************/
 			/* Test if digital I/O counter */
-	   /*******************************/
+			/*******************************/
 
 			if ((devpriv->s_BoardInfos.
 					dw_MolduleConfiguration[b_ModulNbr] &
 					0xFFFF0000UL) == APCI1710_DIGITAL_IO) {
-	      /**********************************************/
+				/**********************************************/
 				/* Test if the digital I/O module initialised */
-	      /**********************************************/
+				/**********************************************/
 
 				if (devpriv->s_ModuleInfo[b_ModulNbr].
 					s_DigitalIOInfo.b_DigitalInit == 1) {
-		 /**************************/
+					/**************************/
 					/* Read all digital input */
-		 /**************************/
+					/**************************/
 
-					//INPDW (ps_APCI1710Variable->
-					//      s_Board [b_BoardHandle].
-					//      s_BoardInfos.
-					//      ui_Address + (64 * b_ModulNbr),
-					//      &dw_StatusReg);
+					/* INPDW (ps_APCI1710Variable->
+					 * s_Board [b_BoardHandle].
+					 * s_BoardInfos.
+					 * ui_Address + (64 * b_ModulNbr),
+					 * &dw_StatusReg);
+					 */
 
 					dw_StatusReg =
 						inl(devpriv->s_BoardInfos.
@@ -784,16 +788,16 @@ int i_APCI1710_InsnBitsDigitalIOPortOnOf
 						(unsigned char) (dw_StatusReg ^ 0x1C);
 
 				} else {
-		 /*******************************/
+					/*******************************/
 					/* Digital I/O not initialised */
-		 /*******************************/
+					/*******************************/
 
 					i_ReturnValue = -4;
 				}
 			} else {
-	      /******************************************/
+				/******************************************/
 				/* The module is not a digital I/O module */
-	      /******************************************/
+				/******************************************/
 
 				i_ReturnValue = -3;
 			}
@@ -853,11 +857,11 @@ int i_APCI1710_InsnBitsDigitalIOPortOnOf
 								i_ReturnValue =
 									-6;
 							}
-						}	// if ((b_PortValue & 2) == 2)
+						}	/*  if ((b_PortValue & 2) == 2) */
 
-		    /**************************/
+						/**************************/
 						/* Test if channel B used */
-		    /**************************/
+						/**************************/
 
 						if ((b_PortValue & 4) == 4) {
 							if (devpriv->
@@ -866,33 +870,33 @@ int i_APCI1710_InsnBitsDigitalIOPortOnOf
 								s_DigitalIOInfo.
 								b_ChannelBMode
 								!= 1) {
-			  /*******************************************/
+								/*******************************************/
 								/* The digital channel B is used for input */
-			  /*******************************************/
+								/*******************************************/
 
 								i_ReturnValue =
 									-7;
 							}
-						}	// if ((b_PortValue & 4) == 4)
+						}	/*  if ((b_PortValue & 4) == 4) */
 
-		    /***********************/
+						/***********************/
 						/* Test if error occur */
-		    /***********************/
+						/***********************/
 
 						if (i_ReturnValue >= 0) {
 
-							//if(data[1])
-							//{
+							/* if(data[1]) { */
+
 							switch (b_PortOnOFF) {
-			   /*********************************/
+								/*********************************/
 								/* Test if set Port ON                   */
-		       /*********************************/
+								/*********************************/
 
 							case APCI1710_ON:
 
-		       /*********************************/
+								/*********************************/
 								/* Test if output memory enabled */
-		       /*********************************/
+								/*********************************/
 
 								if (devpriv->
 									s_ModuleInfo
@@ -924,7 +928,7 @@ int i_APCI1710_InsnBitsDigitalIOPortOnOf
 								}
 								break;
 
-								// If Set PORT  OFF
+								/*  If Set PORT  OFF */
 							case APCI1710_OFF:
 
 			   /*********************************/
@@ -957,25 +961,26 @@ int i_APCI1710_InsnBitsDigitalIOPortOnOf
 										=
 										dw_WriteValue;
 								} else {
-			  /*****************************/
+									/*****************************/
 									/* Digital Output Memory OFF */
-			  /*****************************/
+									/*****************************/
 
 									i_ReturnValue
 										=
 										-8;
 								}
-							}	// switch
+							}	/*  switch */
 
-		       /*******************/
+							/*******************/
 							/* Write the value */
-		       /*******************/
+							/*******************/
+
+							/* OUTPDW (ps_APCI1710Variable->
+							 * s_Board [b_BoardHandle].
+							 * s_BoardInfos.
+							 * ui_Address + (64 * b_ModulNbr),
+							 * dw_WriteValue); */
 
-							//  OUTPDW (ps_APCI1710Variable->
-							//      s_Board [b_BoardHandle].
-							//      s_BoardInfos.
-							//      ui_Address + (64 * b_ModulNbr),
-							//      dw_WriteValue);
 							outl(dw_WriteValue,
 								devpriv->
 								s_BoardInfos.
@@ -983,16 +988,16 @@ int i_APCI1710_InsnBitsDigitalIOPortOnOf
 								(64 * b_ModulNbr));
 						}
 					} else {
-		    /**********************/
+						/**********************/
 						/* Output value wrong */
-		    /**********************/
+						/**********************/
 
 						i_ReturnValue = -4;
 					}
 				} else {
-		 /*******************************/
+					/*******************************/
 					/* Digital I/O not initialised */
-		 /*******************************/
+					/*******************************/
 
 					i_ReturnValue = -5;
 				}
@@ -1015,6 +1020,6 @@ int i_APCI1710_InsnBitsDigitalIOPortOnOf
 	default:
 		i_ReturnValue = -9;
 		DPRINTK("NO INPUT/OUTPUT specified\n");
-	}			//switch INPUT / OUTPUT
+	}			/* switch INPUT / OUTPUT */
 	return (i_ReturnValue);
 }
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_INCCPT.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_INCCPT.c
@@ -84,7 +84,7 @@ int i_APCI1710_InsnConfigINCCPT(struct c
 
 	printk("\nINC_CPT");
 
-	devpriv->tsk_Current = current;	// Save the current process task structure
+	devpriv->tsk_Current = current;	/*  Save the current process task structure */
 	switch (ui_ConfigType) {
 	case APCI1710_INCCPT_INITCOUNTER:
 		i_ReturnValue = i_APCI1710_InitCounter(dev,
@@ -902,7 +902,7 @@ int i_APCI1710_InitIndex(struct comedi_d
 									b_ModeRegister4
 									|
 									APCI1710_ENABLE_LATCH_AND_CLEAR;
-							}	// if (b_IndexOperation == APCI1710_HIGH_EDGE_LATCH_AND_CLEAR_COUNTER || b_IndexOperation == APCI1710_LOW_EDGE_LATCH_AND_CLEAR_COUNTER)
+							}	/*  if (b_IndexOperation == APCI1710_HIGH_EDGE_LATCH_AND_CLEAR_COUNTER || b_IndexOperation == APCI1710_LOW_EDGE_LATCH_AND_CLEAR_COUNTER) */
 							else {
 				/*****************************************/
 								/* Clear the latch and clear flag (DQ27) */
@@ -975,7 +975,7 @@ int i_APCI1710_InitIndex(struct comedi_d
 										&
 										(~APCI1710_INDEX_LATCH_COUNTER);
 								}
-							}	// // if (b_IndexOperation == APCI1710_HIGH_EDGE_LATCH_AND_CLEAR_COUNTER || b_IndexOperation == APCI1710_LOW_EDGE_LATCH_AND_CLEAR_COUNTER)
+							}	/*  // if (b_IndexOperation == APCI1710_HIGH_EDGE_LATCH_AND_CLEAR_COUNTER || b_IndexOperation == APCI1710_LOW_EDGE_LATCH_AND_CLEAR_COUNTER) */
 
 							if (b_AutoMode ==
 								APCI1710_DISABLE)
@@ -1335,7 +1335,7 @@ int i_APCI1710_InitExternalStrobe(struct
 					DPRINTK("External strobe level parameter is wrong\n");
 					i_ReturnValue = -5;
 				}
-			}	// if (b_ExternalStrobe == 0 || b_ExternalStrobe == 1)
+			}	/*  if (b_ExternalStrobe == 0 || b_ExternalStrobe == 1) */
 			else {
 		 /**************************************/
 				/* External strobe selection is wrong */
@@ -1343,7 +1343,7 @@ int i_APCI1710_InitExternalStrobe(struct
 
 				DPRINTK("External strobe selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_ExternalStrobe == 0 || b_ExternalStrobe == 1)
+			}	/*  if (b_ExternalStrobe == 0 || b_ExternalStrobe == 1) */
 		} else {
 	      /****************************************/
 			/* Counter not initialised see function */
@@ -1637,7 +1637,7 @@ int i_APCI1710_InitFrequencyMeasurement(
 								i_ReturnValue =
 									-7;
 							}
-						}	// if (b_PCIInputClock == APCI1710_40MHZ)
+						}	/*  if (b_PCIInputClock == APCI1710_40MHZ) */
 
 		       /***************************/
 						/* Test if not error occur */
@@ -1676,7 +1676,7 @@ int i_APCI1710_InitFrequencyMeasurement(
 										b_ModeRegister4
 										|
 										APCI1710_ENABLE_40MHZ_FREQUENCY;
-								}	// if (b_PCIInputClock == APCI1710_40MHZ)
+								}	/*  if (b_PCIInputClock == APCI1710_40MHZ) */
 								else {
 				   /**********************************/
 									/* Disable the 40MHz quarz (DQ30) */
@@ -1700,7 +1700,7 @@ int i_APCI1710_InitFrequencyMeasurement(
 										&
 										APCI1710_DISABLE_40MHZ_FREQUENCY;
 
-								}	// if (b_PCIInputClock == APCI1710_40MHZ)
+								}	/*  if (b_PCIInputClock == APCI1710_40MHZ) */
 
 			     /********************************/
 								/* Calculate the division fator */
@@ -1949,7 +1949,7 @@ int i_APCI1710_InitFrequencyMeasurement(
 								i_ReturnValue =
 									-3;
 							}
-						}	// if (i_ReturnValue == 0)
+						}	/*  if (i_ReturnValue == 0) */
 					} else {
 		       /**********************************/
 						/* Base timing selection is wrong */
@@ -1997,7 +1997,7 @@ int i_APCI1710_InitFrequencyMeasurement(
 
 /*########################################################################### */
 
-							//INSN BITS
+							/* INSN BITS */
 /*########################################################################### */
 
 /*
@@ -2021,7 +2021,7 @@ int i_APCI1710_InsnBitsINCCPT(struct com
 	unsigned int ui_BitsType;
 	int i_ReturnValue = 0;
 	ui_BitsType = CR_CHAN(insn->chanspec);
-	devpriv->tsk_Current = current;	// Save the current process task structure
+	devpriv->tsk_Current = current;	/*  Save the current process task structure */
 
 	switch (ui_BitsType) {
 	case APCI1710_INCCPT_CLEARCOUNTERVALUE:
@@ -2365,7 +2365,7 @@ int i_APCI1710_SetInputFilter(struct com
 								i_ReturnValue =
 									-6;
 							}
-						}	// if (b_PCIInputClock == APCI1710_40MHZ)
+						}	/*  if (b_PCIInputClock == APCI1710_40MHZ) */
 
 		       /***************************/
 						/* Test if error not occur */
@@ -2401,7 +2401,7 @@ int i_APCI1710_SetInputFilter(struct com
 									|
 									APCI1710_ENABLE_40MHZ_FILTER;
 
-							}	// if (b_PCIInputClock == APCI1710_40MHZ)
+							}	/*  if (b_PCIInputClock == APCI1710_40MHZ) */
 							else {
 			     /**********************************/
 								/* Disable the 40MHz quarz (DQ31) */
@@ -2425,7 +2425,7 @@ int i_APCI1710_SetInputFilter(struct com
 									&
 									APCI1710_DISABLE_40MHZ_FILTER;
 
-							}	// if (b_PCIInputClock == APCI1710_40MHZ)
+							}	/*  if (b_PCIInputClock == APCI1710_40MHZ) */
 
 			  /************************/
 							/* Set the filter value */
@@ -2486,8 +2486,8 @@ int i_APCI1710_SetInputFilter(struct com
 								ui_Address +
 								20 +
 								(64 * b_ModulNbr));
-						}	// if (i_ReturnValue == 0)
-					}	// if (b_Filter < 16)
+						}	/*  if (i_ReturnValue == 0) */
+					}	/*  if (b_Filter < 16) */
 					else {
 		       /**************************************/
 						/* The selected filter value is wrong */
@@ -2495,8 +2495,8 @@ int i_APCI1710_SetInputFilter(struct com
 
 						DPRINTK("The selected filter value is wrong\n");
 						i_ReturnValue = -5;
-					}	// if (b_Filter < 16)
-				}	// if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ) || (b_PCIInputClock == APCI1710_40MHZ))
+					}	/*  if (b_Filter < 16) */
+				}	/*  if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ) || (b_PCIInputClock == APCI1710_40MHZ)) */
 				else {
 		    /*****************************************/
 					/* The selected PCI input clock is wrong */
@@ -2504,7 +2504,7 @@ int i_APCI1710_SetInputFilter(struct com
 
 					DPRINTK("The selected PCI input clock is wrong\n");
 					i_ReturnValue = 4;
-				}	// if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ) || (b_PCIInputClock == APCI1710_40MHZ))
+				}	/*  if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ) || (b_PCIInputClock == APCI1710_40MHZ)) */
 			} else {
 		 /**************************************/
 				/* The module is not a counter module */
@@ -2735,7 +2735,7 @@ int i_APCI1710_SetIndexAndReferenceSourc
 							b_ModeRegister4 &
 							APCI1710_DEFAULT_INDEX_RFERENCE;
 					}
-				}	// if (b_SourceSelection == APCI1710_SOURCE_0 ||b_SourceSelection == APCI1710_SOURCE_1)
+				}	/*  if (b_SourceSelection == APCI1710_SOURCE_0 ||b_SourceSelection == APCI1710_SOURCE_1) */
 				else {
 		    /*********************************/
 					/* The source selection is wrong */
@@ -2743,7 +2743,7 @@ int i_APCI1710_SetIndexAndReferenceSourc
 
 					DPRINTK("The source selection is wrong\n");
 					i_ReturnValue = -4;
-				}	// if (b_SourceSelection == APCI1710_SOURCE_0 ||b_SourceSelection == APCI1710_SOURCE_1)
+				}	/*  if (b_SourceSelection == APCI1710_SOURCE_0 ||b_SourceSelection == APCI1710_SOURCE_1) */
 			} else {
 		 /**************************************/
 				/* The module is not a counter module */
@@ -2934,7 +2934,7 @@ int i_APCI1710_SetDigitalChlOff(struct c
 
 /*########################################################################### */
 
-							// INSN WRITE
+							/*  INSN WRITE */
 /*########################################################################### */
 
 /*
@@ -2958,7 +2958,7 @@ int i_APCI1710_InsnWriteINCCPT(struct co
 	int i_ReturnValue = 0;
 
 	ui_WriteType = CR_CHAN(insn->chanspec);
-	devpriv->tsk_Current = current;	// Save the current process task structure
+	devpriv->tsk_Current = current;	/*  Save the current process task structure */
 
 	switch (ui_WriteType) {
 	case APCI1710_INCCPT_ENABLELATCHINTERRUPT:
@@ -3976,9 +3976,9 @@ int i_APCI1710_DisableFrequencyMeasureme
 					s_ByteModeRegister.
 					b_ModeRegister3 &
 					APCI1710_DISABLE_FREQUENCY
-					// Begin CG 29/06/01 CG 1100/0231 -> 0701/0232 Frequence measure IRQ must be cleared
+					/*  Begin CG 29/06/01 CG 1100/0231 -> 0701/0232 Frequence measure IRQ must be cleared */
 					& APCI1710_DISABLE_FREQUENCY_INT;
-				// End CG 29/06/01 CG 1100/0231 -> 0701/0232 Frequence measure IRQ must be cleared
+				/*  End CG 29/06/01 CG 1100/0231 -> 0701/0232 Frequence measure IRQ must be cleared */
 
 		 /***************************/
 				/* Write the configuration */
@@ -4031,7 +4031,7 @@ int i_APCI1710_DisableFrequencyMeasureme
 
 /*########################################################################### */
 
-							// INSN READ
+							/*  INSN READ */
 
 /*########################################################################### */
 
@@ -4057,7 +4057,7 @@ int i_APCI1710_InsnReadINCCPT(struct com
 
 	ui_ReadType = CR_CHAN(insn->chanspec);
 
-	devpriv->tsk_Current = current;	// Save the current process task structure
+	devpriv->tsk_Current = current;	/*  Save the current process task structure */
 	switch (ui_ReadType) {
 	case APCI1710_INCCPT_READLATCHREGISTERSTATUS:
 		i_ReturnValue = i_APCI1710_ReadLatchRegisterStatus(dev,
@@ -4899,15 +4899,15 @@ int i_APCI1710_Get16BitCBStatus(struct c
 					*pb_CBStatusCounter0 =
 						(unsigned char) ((dw_StatusReg >> 1) &
 						1);
-				}	// if ((ps_APCI1710Variable->s_Board [b_BoardHandle].s_BoardInfos.dw_MolduleConfiguration [b_ModulNbr] & 0xFFFF) >= 0x3136)
+				}	/*  if ((ps_APCI1710Variable->s_Board [b_BoardHandle].s_BoardInfos.dw_MolduleConfiguration [b_ModulNbr] & 0xFFFF) >= 0x3136) */
 				else {
 		    /****************************/
 					/* Firmware revision error  */
 		    /****************************/
 
 					i_ReturnValue = -5;
-				}	// if ((ps_APCI1710Variable->s_Board [b_BoardHandle].s_BoardInfos.dw_MolduleConfiguration [b_ModulNbr] & 0xFFFF) >= 0x3136)
-			}	// if ((ps_APCI1710Variable->s_Board [b_BoardHandle].s_ModuleInfo [b_ModulNbr].s_SiemensCounterInfo.s_ModeRegister.s_ByteModeRegister.b_ModeRegister1 & 0x10) == 0x10)
+				}	/*  if ((ps_APCI1710Variable->s_Board [b_BoardHandle].s_BoardInfos.dw_MolduleConfiguration [b_ModulNbr] & 0xFFFF) >= 0x3136) */
+			}	/*  if ((ps_APCI1710Variable->s_Board [b_BoardHandle].s_ModuleInfo [b_ModulNbr].s_SiemensCounterInfo.s_ModeRegister.s_ByteModeRegister.b_ModeRegister1 & 0x10) == 0x10) */
 			else {
 		 /********************************************/
 				/* Counter not initialised to 2*16-bit mode */
@@ -4916,8 +4916,8 @@ int i_APCI1710_Get16BitCBStatus(struct c
 
 				DPRINTK("Counter not initialised\n");
 				i_ReturnValue = -4;
-			}	// if ((ps_APCI1710Variable->s_Board [b_BoardHandle].s_ModuleInfo [b_ModulNbr].s_SiemensCounterInfo.s_ModeRegister.s_ByteModeRegister.b_ModeRegister1 & 0x10) == 0x10)
-		}		// if (ps_APCI1710Variable->s_Board [b_BoardHandle].s_ModuleInfo [b_ModulNbr].s_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1)
+			}	/*  if ((ps_APCI1710Variable->s_Board [b_BoardHandle].s_ModuleInfo [b_ModulNbr].s_SiemensCounterInfo.s_ModeRegister.s_ByteModeRegister.b_ModeRegister1 & 0x10) == 0x10) */
+		}		/*  if (ps_APCI1710Variable->s_Board [b_BoardHandle].s_ModuleInfo [b_ModulNbr].s_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) */
 		else {
 	      /****************************************/
 			/* Counter not initialised see function */
@@ -4926,8 +4926,8 @@ int i_APCI1710_Get16BitCBStatus(struct c
 
 			DPRINTK("Counter not initialised\n");
 			i_ReturnValue = -3;
-		}		// if (ps_APCI1710Variable->s_Board [b_BoardHandle].s_ModuleInfo [b_ModulNbr].s_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1)
-	}			// if (b_ModulNbr < 4)
+		}		/*  if (ps_APCI1710Variable->s_Board [b_BoardHandle].s_ModuleInfo [b_ModulNbr].s_SiemensCounterInfo.s_InitFlag.b_CounterInit == 1) */
+	}			/*  if (b_ModulNbr < 4) */
 	else {
 	   /*************************************************/
 		/* The selected module number parameter is wrong */
@@ -4935,7 +4935,7 @@ int i_APCI1710_Get16BitCBStatus(struct c
 
 		DPRINTK("The selected module number parameter is wrong\n");
 		i_ReturnValue = -2;
-	}			// if (b_ModulNbr < 4)
+	}			/*  if (b_ModulNbr < 4) */
 
 	return (i_ReturnValue);
 }
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Inp_cpt.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Inp_cpt.c
@@ -515,7 +515,7 @@ int i_APCI1710_InsnWriteEnableDisablePul
 									| (1UL
 									<<
 									b_PulseEncoderNbr);
-								devpriv->tsk_Current = current;	// Save the current process task structure
+								devpriv->tsk_Current = current;	/*  Save the current process task structure */
 
 							}
 
@@ -629,7 +629,7 @@ int i_APCI1710_InsnWriteEnableDisablePul
 						(64 * b_ModulNbr));
 
 					break;
-				}	// switch End
+				}	/*  switch End */
 
 			} else {
 		 /*********************************/
@@ -805,7 +805,7 @@ int i_APCI1710_InsnBitsReadWritePulseEnc
 						(4 * b_PulseEncoderNbr) +
 						(64 * b_ModulNbr));
 
-				}	//end of switch
+				}	/* end of switch */
 			} else {
 		 /*********************************/
 				/* Pulse encoder not initialised */
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Ssi.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Ssi.c
@@ -167,7 +167,7 @@ int i_APCI1710_InsnConfigInitSSI(struct 
 			/* Test the SSI profile length */
 	      /*******************************/
 
-			// CG 22/03/00 b_SSIProfile >= 2 anstatt b_SSIProfile > 2
+			/*  CG 22/03/00 b_SSIProfile >= 2 anstatt b_SSIProfile > 2 */
 			if (b_SSIProfile >= 2 && b_SSIProfile < 33) {
 		 /*************************************/
 				/* Test the SSI position data length */
@@ -423,11 +423,11 @@ int i_APCI1710_InsnReadSSIValue(struct c
 
 	i_ReturnValue = insn->n;
 	pul_Position1 = (unsigned int *) & data[0];
-// For Read1
+/* For Read1 */
 	pul_TurnCpt1 = (unsigned int *) & data[1];
-// For Read all
-	pul_Position = (unsigned int *) & data[0];	//0-2
-	pul_TurnCpt = (unsigned int *) & data[3];	//3-5
+/* For Read all */
+	pul_Position = (unsigned int *) & data[0];	/* 0-2 */
+	pul_TurnCpt = (unsigned int *) & data[3];	/* 3-5 */
 	b_ModulNbr = (unsigned char) CR_AREF(insn->chanspec);
 	b_SelectedSSI = (unsigned char) CR_CHAN(insn->chanspec);
 	b_ReadType = (unsigned char) CR_RANGE(insn->chanspec);
@@ -667,7 +667,7 @@ int i_APCI1710_InsnReadSSIValue(struct c
 				default:
 					printk("Read Type Inputs Wrong\n");
 
-				}	// switch  ending
+				}	/*  switch  ending */
 
 			} else {
 		 /***********************/
@@ -826,7 +826,7 @@ int i_APCI1710_InsnBitsSSIDigitalIO(stru
 			default:
 				printk("IO type wrong\n");
 
-			}	//switch end
+			}	/* switch end */
 		} else {
 	      /**********************************/
 			/* The module is not a SSI module */
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Tor.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Tor.c
@@ -641,7 +641,7 @@ int i_APCI1710_InsnConfigInitTorCounter(
 										}
 
 										fpu_end();
-									}	// if (b_PCIInputClock != APCI1710_GATE_INPUT)
+									}	/*  if (b_PCIInputClock != APCI1710_GATE_INPUT) */
 									else {
 				   /*************************************************************/
 										/* 2 Clock used for the overflow and the reload from counter */
@@ -652,7 +652,7 @@ int i_APCI1710_InsnConfigInitTorCounter(
 											ul_TimingInterval
 											-
 											2;
-									}	// if (b_PCIInputClock != APCI1710_GATE_INPUT)
+									}	/*  if (b_PCIInputClock != APCI1710_GATE_INPUT) */
 
 				/****************************/
 									/* Save the PCI input clock */
@@ -814,7 +814,7 @@ int i_APCI1710_InsnConfigInitTorCounter(
 							DPRINTK("Base timing selection is wrong\n");
 							i_ReturnValue = -7;
 						}
-					}	// if ((b_TimingUnit >= 0) && (b_TimingUnit <= 4))
+					}	/*  if ((b_TimingUnit >= 0) && (b_TimingUnit <= 4)) */
 					else {
 		       /**********************************/
 						/* Timing unit selection is wrong */
@@ -822,8 +822,8 @@ int i_APCI1710_InsnConfigInitTorCounter(
 
 						DPRINTK("Timing unit selection is wrong\n");
 						i_ReturnValue = -6;
-					}	// if ((b_TimingUnit >= 0) && (b_TimingUnit <= 4))
-				}	// if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ))
+					}	/*  if ((b_TimingUnit >= 0) && (b_TimingUnit <= 4)) */
+				}	/*  if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ)) */
 				else {
 		    /*****************************************/
 					/* The selected PCI input clock is wrong */
@@ -831,8 +831,8 @@ int i_APCI1710_InsnConfigInitTorCounter(
 
 					DPRINTK("The selected PCI input clock is wrong\n");
 					i_ReturnValue = -5;
-				}	// if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ))
-			}	// if (b_TorCounterMode >= 0 && b_TorCounterMode <= 7)
+				}	/*  if ((b_PCIInputClock == APCI1710_30MHZ) || (b_PCIInputClock == APCI1710_33MHZ)) */
+			}	/*  if (b_TorCounterMode >= 0 && b_TorCounterMode <= 7) */
 			else {
 		 /**********************************/
 				/* Tor Counter selection is wrong */
@@ -840,7 +840,7 @@ int i_APCI1710_InsnConfigInitTorCounter(
 
 				DPRINTK("Tor Counter selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_TorCounterMode >= 0 && b_TorCounterMode <= 7)
+			}	/*  if (b_TorCounterMode >= 0 && b_TorCounterMode <= 7) */
 		} else {
 	      /******************************************/
 			/* The module is not a tor counter module */
@@ -1002,14 +1002,14 @@ int i_APCI1710_InsnWriteEnableDisableTor
 	unsigned char b_InterruptEnable;
 
 	b_ModulNbr = (unsigned char) CR_AREF(insn->chanspec);
-	b_Action = (unsigned char) data[0];	// enable or disable
+	b_Action = (unsigned char) data[0];	/*  enable or disable */
 	b_TorCounter = (unsigned char) data[1];
 	b_InputMode = (unsigned char) data[2];
 	b_ExternGate = (unsigned char) data[3];
 	b_CycleMode = (unsigned char) data[4];
 	b_InterruptEnable = (unsigned char) data[5];
 	i_ReturnValue = insn->n;;
-	devpriv->tsk_Current = current;	// Save the current process task structure
+	devpriv->tsk_Current = current;	/*  Save the current process task structure */
 	/**************************/
 	/* Test the module number */
 	/**************************/
@@ -1027,7 +1027,7 @@ int i_APCI1710_InsnWriteEnableDisableTor
 	      /**********************************/
 
 			if (b_TorCounter <= 1) {
-				switch (b_Action)	// Enable or Disable
+				switch (b_Action)	/*  Enable or Disable */
 				{
 				case APCI1710_ENABLE:
 		 /***********************************/
@@ -1149,7 +1149,7 @@ int i_APCI1710_InsnWriteEnableDisableTor
 													|
 													0x780;
 
-											}	// if (b_InputMode == APCI1710_TOR_SIMPLE_MODE)
+											}	/*  if (b_InputMode == APCI1710_TOR_SIMPLE_MODE) */
 
 				      /***********************/
 											/* Test if double mode */
@@ -1166,12 +1166,12 @@ int i_APCI1710_InsnWriteEnableDisableTor
 													|
 													0x180;
 
-											}	// if (b_InputMode == APCI1710_TOR_DOUBLE_MODE)
+											}	/*  if (b_InputMode == APCI1710_TOR_DOUBLE_MODE) */
 
 											b_InputMode
 												=
 												0;
-										}	// if (b_InputMode > 1)
+										}	/*  if (b_InputMode > 1) */
 
 				   /*******************/
 										/* Set the command */
@@ -1237,7 +1237,7 @@ int i_APCI1710_InsnWriteEnableDisableTor
 
 										outl(1, devpriv->s_BoardInfos.ui_Address + 8 + (16 * b_TorCounter) + (64 * b_ModulNbr));
 
-									}	// if ((b_InterruptEnable == APCI1710_ENABLE) || (b_InterruptEnable == APCI1710_DISABLE))
+									}	/*  if ((b_InterruptEnable == APCI1710_ENABLE) || (b_InterruptEnable == APCI1710_DISABLE)) */
 									else {
 				/********************************/
 										/* Interrupt parameter is wrong */
@@ -1247,8 +1247,8 @@ int i_APCI1710_InsnWriteEnableDisableTor
 										i_ReturnValue
 											=
 											-9;
-									}	// if ((b_InterruptEnable == APCI1710_ENABLE) || (b_InterruptEnable == APCI1710_DISABLE))
-								}	// if ((b_CycleMode == APCI1710_SINGLE) || (b_CycleMode == APCI1710_CONTINUOUS))
+									}	/*  if ((b_InterruptEnable == APCI1710_ENABLE) || (b_InterruptEnable == APCI1710_DISABLE)) */
+								}	/*  if ((b_CycleMode == APCI1710_SINGLE) || (b_CycleMode == APCI1710_CONTINUOUS)) */
 								else {
 			     /***********************************************/
 									/* Tor counter acquisition mode cycle is wrong */
@@ -1258,8 +1258,8 @@ int i_APCI1710_InsnWriteEnableDisableTor
 									i_ReturnValue
 										=
 										-8;
-								}	// if ((b_CycleMode == APCI1710_SINGLE) || (b_CycleMode == APCI1710_CONTINUOUS))
-							}	// if (b_ExternGate >= 0 && b_ExternGate <= 1)
+								}	/*  if ((b_CycleMode == APCI1710_SINGLE) || (b_CycleMode == APCI1710_CONTINUOUS)) */
+							}	/*  if (b_ExternGate >= 0 && b_ExternGate <= 1) */
 							else {
 			  /***********************************/
 								/* Extern gate input mode is wrong */
@@ -1268,8 +1268,8 @@ int i_APCI1710_InsnWriteEnableDisableTor
 								DPRINTK("Extern gate input mode is wrong\n");
 								i_ReturnValue =
 									-7;
-							}	// if (b_ExternGate >= 0 && b_ExternGate <= 1)
-						}	// if (b_InputMode >= 0 && b_InputMode <= 1)
+							}	/*  if (b_ExternGate >= 0 && b_ExternGate <= 1) */
+						}	/*  if (b_InputMode >= 0 && b_InputMode <= 1) */
 						else {
 		       /***************************************/
 							/* Tor input signal selection is wrong */
@@ -1329,7 +1329,7 @@ int i_APCI1710_InsnWriteEnableDisableTor
 								s_BoardInfos.
 								ui_Address + 8 +
 								(16 * b_TorCounter) + (64 * b_ModulNbr));
-						}	// if (dw_Status & 0x1)
+						}	/*  if (dw_Status & 0x1) */
 						else {
 		       /***************************/
 							/* Tor counter not enabled */
@@ -1337,8 +1337,8 @@ int i_APCI1710_InsnWriteEnableDisableTor
 
 							DPRINTK("Tor counter not enabled \n");
 							i_ReturnValue = -6;
-						}	// if (dw_Status & 0x1)
-					}	// if (dw_Status & 0x10)
+						}	/*  if (dw_Status & 0x1) */
+					}	/*  if (dw_Status & 0x10) */
 					else {
 		    /*******************************/
 						/* Tor counter not initialised */
@@ -1346,10 +1346,10 @@ int i_APCI1710_InsnWriteEnableDisableTor
 
 						DPRINTK("Tor counter not initialised\n");
 						i_ReturnValue = -5;
-					}	// // if (dw_Status & 0x10)
+					}	/*  // if (dw_Status & 0x10) */
 
-				}	// switch
-			}	// if (b_TorCounter <= 1)
+				}	/*  switch */
+			}	/*  if (b_TorCounter <= 1) */
 			else {
 		 /**********************************/
 				/* Tor counter selection is wrong */
@@ -1357,7 +1357,7 @@ int i_APCI1710_InsnWriteEnableDisableTor
 
 				DPRINTK("Tor counter selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_TorCounter <= 1)
+			}	/*  if (b_TorCounter <= 1) */
 		} else {
 	      /******************************************/
 			/* The module is not a tor counter module */
@@ -1569,17 +1569,17 @@ int i_APCI1710_InsnReadGetTorCounterInit
 								*pb_InputMode =
 									APCI1710_TOR_QUADRUPLE_MODE;
 							}
-						}	// if (dw_Status & 0x400)
+						}	/*  if (dw_Status & 0x400) */
 						else {
 							*pb_InputMode = 1;
-						}	// // if (dw_Status & 0x400)
+						}	/*  // if (dw_Status & 0x400) */
 
 		       /************************/
 						/* Extern gate not used */
 		       /************************/
 
 						*pb_ExternGate = 0;
-					}	// if (dw_Status & 0x600)
+					}	/*  if (dw_Status & 0x600) */
 					else {
 						*pb_InputMode =
 							(unsigned char) ((dw_Status >> 6)
@@ -1587,7 +1587,7 @@ int i_APCI1710_InsnReadGetTorCounterInit
 						*pb_ExternGate =
 							(unsigned char) ((dw_Status >> 7)
 							& 1);
-					}	// if (dw_Status & 0x600)
+					}	/*  if (dw_Status & 0x600) */
 
 					*pb_TimingUnit =
 						devpriv->
@@ -1611,7 +1611,7 @@ int i_APCI1710_InsnReadGetTorCounterInit
 					i_ReturnValue = -5;
 				}
 
-			}	// if (b_TorCounter <= 1)
+			}	/*  if (b_TorCounter <= 1) */
 			else {
 		 /**********************************/
 				/* Tor counter selection is wrong */
@@ -1619,7 +1619,7 @@ int i_APCI1710_InsnReadGetTorCounterInit
 
 				DPRINTK("Tor counter selection is wrong \n");
 				i_ReturnValue = -4;
-			}	// if (b_TorCounter <= 1)
+			}	/*  if (b_TorCounter <= 1) */
 		} else {
 	      /******************************************/
 			/* The module is not a tor counter module */
@@ -1896,7 +1896,7 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 											+
 											(16 * b_TorCounter) + (64 * b_ModulNbr));
 										break;
-									}	// if ((dw_Status & 4) == 4)
+									}	/*  if ((dw_Status & 4) == 4) */
 									else {
 				/*******************************/
 										/* Test if measurement stopped */
@@ -1927,7 +1927,7 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 												(16 * b_TorCounter) + (64 * b_ModulNbr));
 
 											break;
-										}	// if ((dw_Status & 2) == 2)
+										}	/*  if ((dw_Status & 2) == 2) */
 										else {
 				   /*******************************/
 											/* Test if measurement started */
@@ -1941,7 +1941,7 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 												*pb_TorCounterStatus
 													=
 													1;
-											}	// if ((dw_Status & 1) == 1)
+											}	/*  if ((dw_Status & 1) == 1) */
 											else {
 				      /***************************/
 												/* Measurement not started */
@@ -1950,9 +1950,9 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 												*pb_TorCounterStatus
 													=
 													0;
-											}	// if ((dw_Status & 1) == 1)
-										}	// if ((dw_Status & 2) == 2)
-									}	// if ((dw_Status & 8) == 8)
+											}	/*  if ((dw_Status & 1) == 1) */
+										}	/*  if ((dw_Status & 2) == 2) */
+									}	/*  if ((dw_Status & 8) == 8) */
 
 									if (dw_TimeOut == ui_TimeOut) {
 				/*****************/
@@ -1973,7 +1973,7 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 
 										mdelay(1000);
 									}
-								}	// for (;;)
+								}	/*  for (;;) */
 
 			  /*************************/
 								/* Test if timeout occur */
@@ -2001,8 +2001,8 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 
 						default:
 							printk("Inputs wrong\n");
-						}	// switch end
-					}	// if (dw_Status & 0x1)
+						}	/*  switch end */
+					}	/*  if (dw_Status & 0x1) */
 					else {
 		       /***************************/
 						/* Tor counter not enabled */
@@ -2010,7 +2010,7 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 
 						DPRINTK("Tor counter not enabled\n");
 						i_ReturnValue = -6;
-					}	// if (dw_Status & 0x1)
+					}	/*  if (dw_Status & 0x1) */
 				} else {
 		    /*******************************/
 					/* Tor counter not initialised */
@@ -2019,7 +2019,7 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 					DPRINTK("Tor counter not initialised\n");
 					i_ReturnValue = -5;
 				}
-			}	// if (b_TorCounter <= 1)
+			}	/*  if (b_TorCounter <= 1) */
 			else {
 		 /**********************************/
 				/* Tor counter selection is wrong */
@@ -2027,7 +2027,7 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 
 				DPRINTK("Tor counter selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_TorCounter <= 1)
+			}	/*  if (b_TorCounter <= 1) */
 		} else {
 	      /******************************************/
 			/* The module is not a tor counter module */
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Ttl.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Ttl.c
@@ -322,7 +322,7 @@ int i_APCI1710_InsnConfigInitTTLIO(struc
 				DPRINTK("\n");
 			default:
 				printk("Bad Config Type\n");
-			}	// switch end
+			}	/*  switch end */
 		} else {
 	      /**********************************/
 			/* The module is not a TTL module */
@@ -610,7 +610,7 @@ int i_APCI1710_InsnBitsReadTTLIO(struct 
 			default:
 				printk("Bad ReadType\n");
 
-			}	//End Switch
+			}	/* End Switch */
 		} else {
 	      /**********************************/
 			/* The module is not a TTL module */
@@ -811,7 +811,7 @@ int i_APCI1710_InsnWriteSetTTLIOChlOnOff
 
   b_ModulNbr	   = CR_AREF(insn->chanspec);
 	b_OutputChannel= CR_CHAN(insn->chanspec);
-	ui_State	   = data[0]; // ON or OFF
+	ui_State	   = data[0]; /*  ON or OFF */
 +----------------------------------------------------------------------------+
 | Output Parameters : -                                                      |
 +----------------------------------------------------------------------------+
@@ -837,7 +837,7 @@ int i_APCI1710_InsnWriteSetTTLIOChlOnOff
 	i_ReturnValue = insn->n;
 	b_ModulNbr = CR_AREF(insn->chanspec);
 	b_OutputChannel = CR_CHAN(insn->chanspec);
-	ui_State = data[0];	// ON or OFF
+	ui_State = data[0];	/*  ON or OFF */
 
 	/**************************/
 	/* Test the module number */
@@ -953,7 +953,7 @@ int i_APCI1710_InsnWriteSetTTLIOChlOnOff
 									ui_Address
 									+
 									(64 * b_ModulNbr));
-								if (ui_State)	// ON
+								if (ui_State)	/*  ON */
 								{
 									dw_StatusReg
 										=
@@ -969,7 +969,7 @@ int i_APCI1710_InsnWriteSetTTLIOChlOnOff
 										(b_OutputChannel
 											%
 											8));
-								} else	// Off
+								} else	/*  Off */
 								{
 									dw_StatusReg
 										=
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci035.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci035.c
@@ -124,9 +124,9 @@ int i_APCI035_ConfigTimerWatchdog(struct
 	} else {
 		ui_Mode = 0;
 	}
-//ui_Command = inl(devpriv->iobase+((i_WatchdogNbr-1)*32)+12);
+/* ui_Command = inl(devpriv->iobase+((i_WatchdogNbr-1)*32)+12); */
 	ui_Command = 0;
-//ui_Command = ui_Command & 0xFFFFF9FEUL;
+/* ui_Command = ui_Command & 0xFFFFF9FEUL; */
 	outl(ui_Command, devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 12);
 	ui_Command = 0;
 	ui_Command = inl(devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 12);
@@ -153,7 +153,7 @@ int i_APCI035_ConfigTimerWatchdog(struct
 		ui_Command =
 			(ui_Command & 0xFFF719E2UL) | ui_Mode << 13UL | 0x10UL;
 
-	}			//if (data[0] == ADDIDATA_TIMER)
+	}			/* if (data[0] == ADDIDATA_TIMER) */
 	else {
 		if (data[0] == ADDIDATA_WATCHDOG) {
 
@@ -292,7 +292,7 @@ int i_APCI035_StartStopWriteTimerWatchdo
 		ui_Command = (ui_Command & 0xFFFFF9FFUL) | 0x1UL;
 		outl(ui_Command,
 			devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 12);
-	}			// if  (data[0]==1)
+	}			/*  if  (data[0]==1) */
 	if (data[0] == 2) {
 		ui_Command =
 			inl(devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 12);
@@ -304,16 +304,18 @@ int i_APCI035_StartStopWriteTimerWatchdo
 			devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 12);
 	}
 
-	if (data[0] == 0)	//Stop The Watchdog
+	if (data[0] == 0)	/* Stop The Watchdog */
 	{
-		//Stop The Watchdog
+		/* Stop The Watchdog */
 		ui_Command = 0;
-		//ui_Command = inl(devpriv->iobase+((i_WatchdogNbr-1)*32)+12);
-		//ui_Command = ui_Command & 0xFFFFF9FEUL;
+/*
+* ui_Command = inl(devpriv->iobase+((i_WatchdogNbr-1)*32)+12);
+* ui_Command = ui_Command & 0xFFFFF9FEUL;
+*/
 		outl(ui_Command,
 			devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 12);
-	}			//  if (data[1]==0)
-	if (data[0] == 3)	//stop all Watchdogs
+	}			/*   if (data[1]==0) */
+	if (data[0] == 3)	/* stop all Watchdogs */
 	{
 		ui_Command = 0;
 		for (i_Count = 1; i_Count <= 4; i_Count++) {
@@ -329,7 +331,7 @@ int i_APCI035_StartStopWriteTimerWatchdo
 		}
 
 	}
-	if (data[0] == 4)	//start all Watchdogs
+	if (data[0] == 4)	/* start all Watchdogs */
 	{
 		ui_Command = 0;
 		for (i_Count = 1; i_Count <= 4; i_Count++) {
@@ -344,7 +346,7 @@ int i_APCI035_StartStopWriteTimerWatchdo
 				0);
 		}
 	}
-	if (data[0] == 5)	//trigger all Watchdogs
+	if (data[0] == 5)	/* trigger all Watchdogs */
 	{
 		ui_Command = 0;
 		for (i_Count = 1; i_Count <= 4; i_Count++) {
@@ -394,7 +396,7 @@ int i_APCI035_StartStopWriteTimerWatchdo
 int i_APCI035_ReadTimerWatchdog(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	unsigned int ui_Status = 0;	// Status register
+	unsigned int ui_Status = 0;	/*  Status register */
 	i_WatchdogNbr = insn->unused[0];
 	      /******************/
 	/* Get the status */
@@ -419,7 +421,7 @@ int i_APCI035_ReadTimerWatchdog(struct c
 	if (devpriv->b_TimerSelectMode == ADDIDATA_TIMER) {
 		data[4] = inl(devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 0);
 
-	}			//  if  (devpriv->b_TimerSelectMode==ADDIDATA_TIMER)
+	}			/*   if  (devpriv->b_TimerSelectMode==ADDIDATA_TIMER) */
 
 	return insn->n;
 }
@@ -524,9 +526,9 @@ int i_APCI035_Reset(struct comedi_device
 	int i_Count = 0;
 	for (i_Count = 1; i_Count <= 4; i_Count++) {
 		i_WatchdogNbr = i_Count;
-		outl(0x0, devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 0);	//stop all timers
+		outl(0x0, devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 0);	/* stop all timers */
 	}
-	outl(0x0, devpriv->iobase + 128 + 12);	//Disable the warning delay
+	outl(0x0, devpriv->iobase + 128 + 12);	/* Disable the warning delay */
 
 	return 0;
 }
@@ -571,7 +573,7 @@ static void v_APCI035_Interrupt(int irq,
 	ui_StatusRegister2 =
 		inl(devpriv->iobase + ((i_WatchdogNbr - 1) * 32) + 20);
 
-	if ((((ui_StatusRegister1) & 0x8) == 0x8))	//Test if warning relay interrupt
+	if ((((ui_StatusRegister1) & 0x8) == 0x8))	/* Test if warning relay interrupt */
 	{
 	/**********************************/
 		/* Disable the temperature warning */
@@ -587,14 +589,14 @@ static void v_APCI035_Interrupt(int irq,
 		/* Read the digital temperature value */
 	/**************************************/
 		ui_DigitalTemperature = inl(devpriv->iobase + 128 + 60);
-		send_sig(SIGIO, devpriv->tsk_Current, 0);	// send signal to the sample
-	}			//if (((ui_StatusRegister1 & 0x8) == 0x8))
+		send_sig(SIGIO, devpriv->tsk_Current, 0);	/*  send signal to the sample */
+	}			/* if (((ui_StatusRegister1 & 0x8) == 0x8)) */
 
 	else {
 		if ((ui_StatusRegister2 & 0x1) == 0x1) {
-			send_sig(SIGIO, devpriv->tsk_Current, 0);	// send signal to the sample
+			send_sig(SIGIO, devpriv->tsk_Current, 0);	/*  send signal to the sample */
 		}
-	}			//else if (((ui_StatusRegister1 & 0x8) == 0x8))
+	}			/* else if (((ui_StatusRegister1 & 0x8) == 0x8)) */
 
 	return;
 }
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1032.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1032.c
@@ -53,7 +53,7 @@ You shoud also find the complete GPL in 
 */
 #include "hwdrv_apci1032.h"
 #include <linux/delay.h>
-//Global variables
+/* Global variables */
 unsigned int ui_InterruptStatus = 0;
 
 /*
@@ -107,11 +107,11 @@ int i_APCI1032_ConfigDigitalInput(struct
 			outl(0x4, devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);
 			ui_TmpValue =
 				inl(devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);
-		}		//if (data[1] == ADDIDATA_OR)
+		}		/* if (data[1] == ADDIDATA_OR) */
 		else {
 			outl(0x6, devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);
-		}		//else if(data[1] == ADDIDATA_OR)
-	}			// if( data[0] == ADDIDATA_ENABLE)
+		}		/* else if(data[1] == ADDIDATA_OR) */
+	}			/*  if( data[0] == ADDIDATA_ENABLE) */
 	else {
 		ul_Command1 = ul_Command1 & 0xFFFF0000;
 		ul_Command2 = ul_Command2 & 0xFFFF0000;
@@ -120,7 +120,7 @@ int i_APCI1032_ConfigDigitalInput(struct
 		outl(ul_Command2,
 			devpriv->iobase + APCI1032_DIGITAL_IP_INTERRUPT_MODE2);
 		outl(0x0, devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);
-	}			//else if  ( data[0] == ADDIDATA_ENABLE)
+	}			/* else if  ( data[0] == ADDIDATA_ENABLE) */
 
 	return insn->n;
 }
@@ -152,14 +152,16 @@ int i_APCI1032_Read1DigitalInput(struct 
 	ui_Channel = CR_CHAN(insn->chanspec);
 	if (ui_Channel >= 0 && ui_Channel <= 31) {
 		ui_TmpValue = (unsigned int) inl(devpriv->iobase + APCI1032_DIGITAL_IP);
-		//  since only 1 channel reqd  to bring it to last bit it is rotated
-		//  8 +(chan - 1) times then ANDed with 1 for last bit.
+/*
+* since only 1 channel reqd to bring it to last bit it is rotated 8
+* +(chan - 1) times then ANDed with 1 for last bit.
+*/
 		*data = (ui_TmpValue >> ui_Channel) & 0x1;
-	}			//if(ui_Channel >= 0 && ui_Channel <=31)
+	}			/* if(ui_Channel >= 0 && ui_Channel <=31) */
 	else {
-		//comedi_error(dev," \n chan spec wrong\n");
-		return -EINVAL;	// "sorry channel spec wrong "
-	}			//else if(ui_Channel >= 0 && ui_Channel <=31)
+		/* comedi_error(dev," \n chan spec wrong\n"); */
+		return -EINVAL;	/*  "sorry channel spec wrong " */
+	}			/* else if(ui_Channel >= 0 && ui_Channel <=31) */
 	return insn->n;
 }
 
@@ -213,16 +215,16 @@ int i_APCI1032_ReadMoreDigitalInput(stru
 		case 31:
 			break;
 		default:
-			//comedi_error(dev," \nchan spec wrong\n");
-			return -EINVAL;	// "sorry channel spec wrong "
+			/* comedi_error(dev," \nchan spec wrong\n"); */
+			return -EINVAL;	/*  "sorry channel spec wrong " */
 			break;
-		}		//switch(ui_NoOfChannels)
-	}			//if(data[1]==0)
+		}		/* switch(ui_NoOfChannels) */
+	}			/* if(data[1]==0) */
 	else {
 		if (data[1] == 1) {
 			*data = ui_InterruptStatus;
-		}		//if(data[1]==1)
-	}			//else if(data[1]==0)
+		}		/* if(data[1]==1) */
+	}			/* else if(data[1]==0) */
 	return insn->n;
 }
 
@@ -248,15 +250,15 @@ static void v_APCI1032_Interrupt(int irq
 	struct comedi_device *dev = d;
 
 	unsigned int ui_Temp;
-	//disable the interrupt
+	/* disable the interrupt */
 	ui_Temp = inl(devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);
 	outl(ui_Temp & APCI1032_DIGITAL_IP_INTERRUPT_DISABLE,
 		devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);
 	ui_InterruptStatus =
 		inl(devpriv->iobase + APCI1032_DIGITAL_IP_INTERRUPT_STATUS);
 	ui_InterruptStatus = ui_InterruptStatus & 0X0000FFFF;
-	send_sig(SIGIO, devpriv->tsk_Current, 0);	// send signal to the sample
-	outl(ui_Temp, devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);	//enable the interrupt
+	send_sig(SIGIO, devpriv->tsk_Current, 0);	/*  send signal to the sample */
+	outl(ui_Temp, devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);	/* enable the interrupt */
 	return;
 }
 
@@ -277,9 +279,9 @@ static void v_APCI1032_Interrupt(int irq
 
 int i_APCI1032_Reset(struct comedi_device * dev)
 {
-	outl(0x0, devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);	//disable the interrupts
-	inl(devpriv->iobase + APCI1032_DIGITAL_IP_INTERRUPT_STATUS);	//Reset the interrupt status register
-	outl(0x0, devpriv->iobase + APCI1032_DIGITAL_IP_INTERRUPT_MODE1);	//Disable the and/or interrupt
+	outl(0x0, devpriv->iobase + APCI1032_DIGITAL_IP_IRQ);	/* disable the interrupts */
+	inl(devpriv->iobase + APCI1032_DIGITAL_IP_INTERRUPT_STATUS);	/* Reset the interrupt status register */
+	outl(0x0, devpriv->iobase + APCI1032_DIGITAL_IP_INTERRUPT_MODE1);	/* Disable the and/or interrupt */
 	outl(0x0, devpriv->iobase + APCI1032_DIGITAL_IP_INTERRUPT_MODE2);
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1032.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1032.h
@@ -19,33 +19,34 @@
 
 #define APCI1032_BOARD_VENDOR_ID 0x15B8
 #define APCI1032_ADDRESS_RANGE  20
-//DIGITAL INPUT DEFINE
+/* DIGITAL INPUT DEFINE */
 
 #define APCI1032_DIGITAL_IP                     0
 #define APCI1032_DIGITAL_IP_INTERRUPT_MODE1     4
 #define APCI1032_DIGITAL_IP_INTERRUPT_MODE2     8
 #define APCI1032_DIGITAL_IP_IRQ                 16
 
-//Digital Input IRQ Function Selection
+/* Digital Input IRQ Function Selection */
 #define ADDIDATA_OR                  0
 #define ADDIDATA_AND                 1
 
-//Digital Input Interrupt Status
+/* Digital Input Interrupt Status */
 #define APCI1032_DIGITAL_IP_INTERRUPT_STATUS    12
 
-//Digital Input Interrupt Enable Disable.
+/* Digital Input Interrupt Enable Disable. */
 #define APCI1032_DIGITAL_IP_INTERRUPT_ENABLE    0x4
 #define APCI1032_DIGITAL_IP_INTERRUPT_DISABLE   0xFFFFFFFB
 
-//ADDIDATA Enable Disable
+/* ADDIDATA Enable Disable */
 
 #define ADDIDATA_ENABLE                            1
 #define ADDIDATA_DISABLE                           0
 
-// Hardware Layer  functions for Apci1032
+/* Hardware Layer  functions for Apci1032 */
 
-//DI
-// for di read
+/*
+* DI for di read
+*/
 
 int i_APCI1032_ConfigDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data);
@@ -56,8 +57,8 @@ int i_APCI1032_Read1DigitalInput(struct 
 int i_APCI1032_ReadMoreDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				    struct comedi_insn *insn, unsigned int *data);
 
-// Interrupt functions.....
+/* Interrupt functions..... */
 
 static void v_APCI1032_Interrupt(int irq, void *d);
-//Reset
+/* Reset */
 int i_APCI1032_Reset(struct comedi_device *dev);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.h
@@ -17,11 +17,11 @@
 
 /*********      Definitions for APCI-1500 card  *****/
 
-// Card Specific information
+/* Card Specific information */
 #define APCI1500_BOARD_VENDOR_ID           0x10e8
 #define APCI1500_ADDRESS_RANGE              4
 
-//DIGITAL INPUT-OUTPUT DEFINE
+/* DIGITAL INPUT-OUTPUT DEFINE */
 
 #define  APCI1500_DIGITAL_OP                 	2
 #define  APCI1500_DIGITAL_IP                    0
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1516.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1516.c
@@ -81,14 +81,14 @@ int i_APCI1516_Read1DigitalInput(struct 
 	ui_Channel = CR_CHAN(insn->chanspec);
 	if (ui_Channel >= 0 && ui_Channel <= 7) {
 		ui_TmpValue = (unsigned int) inw(devpriv->iobase + APCI1516_DIGITAL_IP);
-		//  since only 1 channel reqd  to bring it to last bit it is rotated
-		//  8 +(chan - 1) times then ANDed with 1 for last bit.
+		/*   since only 1 channel reqd  to bring it to last bit it is rotated */
+		/*   8 +(chan - 1) times then ANDed with 1 for last bit. */
 		*data = (ui_TmpValue >> ui_Channel) & 0x1;
-	}			//if(ui_Channel >= 0 && ui_Channel <=7)
+	}			/* if(ui_Channel >= 0 && ui_Channel <=7) */
 	else {
-		//comedi_error(dev," \n chan spec wrong\n");
-		return -EINVAL;	// "sorry channel spec wrong "
-	}			//else if(ui_Channel >= 0 && ui_Channel <=7)
+		/* comedi_error(dev," \n chan spec wrong\n"); */
+		return -EINVAL;	/*  "sorry channel spec wrong " */
+	}			/* else if(ui_Channel >= 0 && ui_Channel <=7) */
 
 	return insn->n;
 }
@@ -139,9 +139,9 @@ int i_APCI1516_ReadMoreDigitalInput(stru
 
 	default:
 		printk("\nWrong parameters\n");
-		return -EINVAL;	// "sorry channel spec wrong "
+		return -EINVAL;	/*  "sorry channel spec wrong " */
 		break;
-	}			//switch(ui_NoOfChannels)
+	}			/* switch(ui_NoOfChannels) */
 
 	return insn->n;
 }
@@ -203,17 +203,17 @@ int i_APCI1516_WriteDigitalOutput(struct
 	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int ui_Temp, ui_Temp1;
-	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	/*  get the channel */
 
 	printk("EL311003 : @=%x\n", devpriv->iobase + APCI1516_DIGITAL_OP);
 
 	if (devpriv->b_OutputMemoryStatus) {
 		ui_Temp = inw(devpriv->iobase + APCI1516_DIGITAL_OP);
 
-	}			//if(devpriv->b_OutputMemoryStatus )
+	}			/* if(devpriv->b_OutputMemoryStatus ) */
 	else {
 		ui_Temp = 0;
-	}			//if(devpriv->b_OutputMemoryStatus )
+	}			/* if(devpriv->b_OutputMemoryStatus ) */
 	if (data[3] == 0) {
 		if (data[1] == 0) {
 			data[0] = (data[0] << ui_NoOfChannel) | ui_Temp;
@@ -222,7 +222,7 @@ int i_APCI1516_WriteDigitalOutput(struct
 			printk("EL311003 : d=%d @=%x\n", data[0],
 				devpriv->iobase + APCI1516_DIGITAL_OP);
 
-		}		//if(data[1]==0)
+		}		/* if(data[1]==0) */
 		else {
 			if (data[1] == 1) {
 				switch (ui_NoOfChannel) {
@@ -245,21 +245,21 @@ int i_APCI1516_WriteDigitalOutput(struct
 
 				default:
 					comedi_error(dev, " chan spec wrong");
-					return -EINVAL;	// "sorry channel spec wrong "
+					return -EINVAL;	/*  "sorry channel spec wrong " */
 
-				}	//switch(ui_NoOfChannels)
+				}	/* switch(ui_NoOfChannels) */
 
 				outw(data[0],
 					devpriv->iobase + APCI1516_DIGITAL_OP);
 
 				printk("EL311003 : d=%d @=%x\n", data[0],
 					devpriv->iobase + APCI1516_DIGITAL_OP);
-			}	// if(data[1]==1)
+			}	/*  if(data[1]==1) */
 			else {
 				printk("\nSpecified channel not supported\n");
-			}	//else if(data[1]==1)
-		}		//elseif(data[1]==0)
-	}			//if(data[3]==0)
+			}	/* else if(data[1]==1) */
+		}		/* elseif(data[1]==0) */
+	}			/* if(data[3]==0) */
 	else {
 		if (data[3] == 1) {
 			if (data[1] == 0) {
@@ -275,7 +275,7 @@ int i_APCI1516_WriteDigitalOutput(struct
 				printk("EL311003 : d=%d @=%x\n", data[0],
 					devpriv->iobase + APCI1516_DIGITAL_OP);
 
-			}	//if(data[1]==0)
+			}	/* if(data[1]==0) */
 			else {
 				if (data[1] == 1) {
 					switch (ui_NoOfChannel) {
@@ -312,9 +312,9 @@ int i_APCI1516_WriteDigitalOutput(struct
 					default:
 						comedi_error(dev,
 							" chan spec wrong");
-						return -EINVAL;	// "sorry channel spec wrong "
+						return -EINVAL;	/*  "sorry channel spec wrong " */
 
-					}	//switch(ui_NoOfChannels)
+					}	/* switch(ui_NoOfChannels) */
 
 					outw(data[0],
 						devpriv->iobase +
@@ -324,17 +324,17 @@ int i_APCI1516_WriteDigitalOutput(struct
 						data[0],
 						devpriv->iobase +
 						APCI1516_DIGITAL_OP);
-				}	// if(data[1]==1)
+				}	/*  if(data[1]==1) */
 				else {
 					printk("\nSpecified channel not supported\n");
-				}	//else if(data[1]==1)
-			}	//elseif(data[1]==0)
-		}		//if(data[3]==1);
+				}	/* else if(data[1]==1) */
+			}	/* elseif(data[1]==0) */
+		}		/* if(data[3]==1); */
 		else {
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		//if else data[3]==1)
-	}			//if else data[3]==0)
+		}		/* if else data[3]==1) */
+	}			/* if else data[3]==0) */
 	return (insn->n);;
 }
 
@@ -364,12 +364,12 @@ int i_APCI1516_ReadDigitalOutput(struct 
 {
 
 	unsigned int ui_Temp;
-	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	/*  get the channel */
 	ui_Temp = data[0];
 	*data = inw(devpriv->iobase + APCI1516_DIGITAL_OP_RW);
 	if (ui_Temp == 0) {
 		*data = (*data >> ui_NoOfChannel) & 0x1;
-	}			//if(ui_Temp==0)
+	}			/* if(ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 			switch (ui_NoOfChannel) {
@@ -387,14 +387,14 @@ int i_APCI1516_ReadDigitalOutput(struct 
 
 			default:
 				comedi_error(dev, " chan spec wrong");
-				return -EINVAL;	// "sorry channel spec wrong "
+				return -EINVAL;	/*  "sorry channel spec wrong " */
 
-			}	//switch(ui_NoOfChannels)
-		}		//if(ui_Temp==1)
+			}	/* switch(ui_NoOfChannels) */
+		}		/* if(ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		//elseif(ui_Temp==1)
-	}			//elseif(ui_Temp==0)
+		}		/* elseif(ui_Temp==1) */
+	}			/* elseif(ui_Temp==0) */
 	return insn->n;
 }
 
@@ -423,11 +423,11 @@ int i_APCI1516_ConfigWatchdog(struct com
 	struct comedi_insn * insn, unsigned int * data)
 {
 	if (data[0] == 0) {
-		//Disable the watchdog
+		/* Disable the watchdog */
 		outw(0x0,
 			devpriv->i_IobaseAddon +
 			APCI1516_WATCHDOG_ENABLEDISABLE);
-		//Loading the Reload value
+		/* Loading the Reload value */
 		outw(data[1],
 			devpriv->i_IobaseAddon +
 			APCI1516_WATCHDOG_RELOAD_VALUE);
@@ -435,11 +435,11 @@ int i_APCI1516_ConfigWatchdog(struct com
 		outw(data[1],
 			devpriv->i_IobaseAddon +
 			APCI1516_WATCHDOG_RELOAD_VALUE + 2);
-	}			//if(data[0]==0)
+	}			/* if(data[0]==0) */
 	else {
 		printk("\nThe input parameters are wrong\n");
 		return -EINVAL;
-	}			//elseif(data[0]==0)
+	}			/* elseif(data[0]==0) */
 
 	return insn->n;
 }
@@ -469,15 +469,15 @@ int i_APCI1516_StartStopWriteWatchdog(st
 	struct comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
-	case 0:		//stop the watchdog
-		outw(0x0, devpriv->i_IobaseAddon + APCI1516_WATCHDOG_ENABLEDISABLE);	//disable the watchdog
+	case 0:		/* stop the watchdog */
+		outw(0x0, devpriv->i_IobaseAddon + APCI1516_WATCHDOG_ENABLEDISABLE);	/* disable the watchdog */
 		break;
-	case 1:		//start the watchdog
+	case 1:		/* start the watchdog */
 		outw(0x0001,
 			devpriv->i_IobaseAddon +
 			APCI1516_WATCHDOG_ENABLEDISABLE);
 		break;
-	case 2:		//Software trigger
+	case 2:		/* Software trigger */
 		outw(0x0201,
 			devpriv->i_IobaseAddon +
 			APCI1516_WATCHDOG_ENABLEDISABLE);
@@ -485,7 +485,7 @@ int i_APCI1516_StartStopWriteWatchdog(st
 	default:
 		printk("\nSpecified functionality does not exist\n");
 		return -EINVAL;
-	}			// switch(data[0])
+	}			/*  switch(data[0]) */
 	return insn->n;
 }
 
@@ -534,7 +534,7 @@ int i_APCI1516_ReadWatchdog(struct comed
 
 int i_APCI1516_Reset(struct comedi_device * dev)
 {
-	outw(0x0, devpriv->iobase + APCI1516_DIGITAL_OP);	//RESETS THE DIGITAL OUTPUTS
+	outw(0x0, devpriv->iobase + APCI1516_DIGITAL_OP);	/* RESETS THE DIGITAL OUTPUTS */
 	outw(0x0, devpriv->i_IobaseAddon + APCI1516_WATCHDOG_ENABLEDISABLE);
 	outw(0x0, devpriv->i_IobaseAddon + APCI1516_WATCHDOG_RELOAD_VALUE);
 	outw(0x0, devpriv->i_IobaseAddon + APCI1516_WATCHDOG_RELOAD_VALUE + 2);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1516.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1516.h
@@ -17,17 +17,17 @@
 
 /*********      Definitions for APCI-1516 card  *****/
 
-// Card Specific information
+/* Card Specific information */
 #define APCI1516_BOARD_VENDOR_ID                 0x15B8
 #define APCI1516_ADDRESS_RANGE                   8
 
-//DIGITAL INPUT-OUTPUT DEFINE
+/* DIGITAL INPUT-OUTPUT DEFINE */
 
 #define APCI1516_DIGITAL_OP                 	4
 #define APCI1516_DIGITAL_OP_RW                 	4
 #define APCI1516_DIGITAL_IP                     0
 
-// TIMER COUNTER WATCHDOG DEFINES
+/* TIMER COUNTER WATCHDOG DEFINES */
 
 #define ADDIDATA_WATCHDOG                          2
 #define APCI1516_DIGITAL_OP_WATCHDOG               0
@@ -35,15 +35,15 @@
 #define APCI1516_WATCHDOG_RELOAD_VALUE             4
 #define APCI1516_WATCHDOG_STATUS                   16
 
-// Hardware Layer  functions for Apci1516
+/* Hardware Layer  functions for Apci1516 */
 
-//Digital Input
+/* Digital Input */
 int i_APCI1516_ReadMoreDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				    struct comedi_insn *insn, unsigned int *data);
 int i_APCI1516_Read1DigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
 
-//Digital Output
+/* Digital Output */
 int i_APCI1516_ConfigDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data);
 int i_APCI1516_WriteDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -51,8 +51,9 @@ int i_APCI1516_WriteDigitalOutput(struct
 int i_APCI1516_ReadDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
 
-// TIMER
-// timer value is passed as u seconds
+/*
+* TIMER timer value is passed as u seconds
+*/
 int i_APCI1516_ConfigWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data);
 int i_APCI1516_StartStopWriteWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -60,5 +61,5 @@ int i_APCI1516_StartStopWriteWatchdog(st
 int i_APCI1516_ReadWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data);
 
-//reset
+/* reset */
 int i_APCI1516_Reset(struct comedi_device *dev);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.h
@@ -20,45 +20,45 @@
 #define APCI1564_BOARD_VENDOR_ID                0x15B8
 #define APCI1564_ADDRESS_RANGE                  128
 
-//DIGITAL INPUT-OUTPUT DEFINE
-// Input defines
+/* DIGITAL INPUT-OUTPUT DEFINE */
+/* Input defines */
 #define APCI1564_DIGITAL_IP                     0x04
 #define APCI1564_DIGITAL_IP_INTERRUPT_MODE1     4
 #define APCI1564_DIGITAL_IP_INTERRUPT_MODE2     8
 #define APCI1564_DIGITAL_IP_IRQ                 16
 
-// Output defines
+/* Output defines */
 #define APCI1564_DIGITAL_OP                 	0x18
 #define APCI1564_DIGITAL_OP_RW               	0
 #define APCI1564_DIGITAL_OP_INTERRUPT           4
 #define APCI1564_DIGITAL_OP_IRQ                 12
 
-//Digital Input IRQ Function Selection
+/* Digital Input IRQ Function Selection */
 #define ADDIDATA_OR                             0
 #define ADDIDATA_AND                            1
 
-//Digital Input Interrupt Status
+/* Digital Input Interrupt Status */
 #define APCI1564_DIGITAL_IP_INTERRUPT_STATUS    12
 
-//Digital Output Interrupt Status
+/* Digital Output Interrupt Status */
 #define APCI1564_DIGITAL_OP_INTERRUPT_STATUS    8
 
-//Digital Input Interrupt Enable Disable.
+/* Digital Input Interrupt Enable Disable. */
 #define APCI1564_DIGITAL_IP_INTERRUPT_ENABLE    0x4
 #define APCI1564_DIGITAL_IP_INTERRUPT_DISABLE   0xFFFFFFFB
 
-//Digital Output Interrupt Enable Disable.
+/* Digital Output Interrupt Enable Disable. */
 #define APCI1564_DIGITAL_OP_VCC_INTERRUPT_ENABLE   0x1
 #define APCI1564_DIGITAL_OP_VCC_INTERRUPT_DISABLE  0xFFFFFFFE
 #define APCI1564_DIGITAL_OP_CC_INTERRUPT_ENABLE    0x2
 #define APCI1564_DIGITAL_OP_CC_INTERRUPT_DISABLE   0xFFFFFFFD
 
-//ADDIDATA Enable Disable
+/* ADDIDATA Enable Disable */
 
 #define ADDIDATA_ENABLE                            1
 #define ADDIDATA_DISABLE                           0
 
-// TIMER COUNTER WATCHDOG DEFINES
+/* TIMER COUNTER WATCHDOG DEFINES */
 
 #define ADDIDATA_TIMER                             0
 #define ADDIDATA_COUNTER                           1
@@ -78,10 +78,11 @@
 #define APCI1564_TCW_WARN_TIMEVAL                  24
 #define APCI1564_TCW_WARN_TIMEBASE                 28
 
-// Hardware Layer  functions for Apci1564
+/* Hardware Layer  functions for Apci1564 */
 
-//DI
-// for di read
+/*
+* DI for di read
+*/
 int i_APCI1564_ConfigDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data);
 int i_APCI1564_Read1DigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -89,7 +90,7 @@ int i_APCI1564_Read1DigitalInput(struct 
 int i_APCI1564_ReadMoreDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				    struct comedi_insn *insn, unsigned int *data);
 
-//DO
+/* DO */
 int i_APCI1564_ConfigDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data);
 int i_APCI1564_WriteDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -99,8 +100,9 @@ int i_APCI1564_ReadDigitalOutput(struct 
 int i_APCI1564_ReadInterruptStatus(struct comedi_device *dev, struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data);
 
-// TIMER
-// timer value is passed as u seconds
+/*
+* TIMER timer value is passed as u seconds
+*/
 int i_APCI1564_ConfigTimerCounterWatchdog(struct comedi_device *dev,
 					  struct comedi_subdevice *s,
 					  struct comedi_insn *insn, unsigned int *data);
@@ -112,8 +114,8 @@ int i_APCI1564_ReadTimerCounterWatchdog(
 					struct comedi_subdevice *s,
 					struct comedi_insn *insn, unsigned int *data);
 
-// intERRUPT
+/* intERRUPT */
 static void v_APCI1564_Interrupt(int irq, void *d);
 
-// RESET
+/* RESET */
 int i_APCI1564_Reset(struct comedi_device *dev);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.c
@@ -62,11 +62,11 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	int ret = 0;
 	int n_subdevices = 9;
 
-	//Update-0.7.57->0.7.68dev->n_subdevices = 9;
+	/* Update-0.7.57->0.7.68dev->n_subdevices = 9; */
 	if ((ret = alloc_subdevices(dev, n_subdevices)) < 0)
 		return;
 
-	// Allocate and Initialise Timer Subdevice Structures
+	/*  Allocate and Initialise Timer Subdevice Structures */
 	s = dev->subdevices + 0;
 
 	s->type = COMEDI_SUBD_TIMER;
@@ -80,7 +80,7 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	s->insn_config = i_APCI1710_InsnConfigInitTimer;
 	s->insn_bits = i_APCI1710_InsnBitsTimer;
 
-	// Allocate and Initialise DIO Subdevice Structures
+	/*  Allocate and Initialise DIO Subdevice Structures */
 	s = dev->subdevices + 1;
 
 	s->type = COMEDI_SUBD_DIO;
@@ -95,7 +95,7 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	s->insn_bits = i_APCI1710_InsnBitsDigitalIOPortOnOff;
 	s->insn_write = i_APCI1710_InsnWriteDigitalIOChlOnOff;
 
-	// Allocate and Initialise Chrono Subdevice Structures
+	/*  Allocate and Initialise Chrono Subdevice Structures */
 	s = dev->subdevices + 2;
 
 	s->type = COMEDI_SUBD_CHRONO;
@@ -109,7 +109,7 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	s->insn_config = i_APCI1710_InsnConfigInitChrono;
 	s->insn_bits = i_APCI1710_InsnBitsChronoDigitalIO;
 
-	// Allocate and Initialise PWM Subdevice Structures
+	/*  Allocate and Initialise PWM Subdevice Structures */
 	s = dev->subdevices + 3;
 	s->type = COMEDI_SUBD_PWM;
 	s->subdev_flags =
@@ -118,13 +118,13 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	s->maxdata = 1;
 	s->len_chanlist = 3;
 	s->range_table = &range_digital;
-	s->io_bits = 0;		//all bits input
+	s->io_bits = 0;		/* all bits input */
 	s->insn_config = i_APCI1710_InsnConfigPWM;
 	s->insn_read = i_APCI1710_InsnReadGetPWMStatus;
 	s->insn_write = i_APCI1710_InsnWritePWM;
 	s->insn_bits = i_APCI1710_InsnBitsReadPWMInterrupt;
 
-	// Allocate and Initialise TTLIO Subdevice Structures
+	/*  Allocate and Initialise TTLIO Subdevice Structures */
 	s = dev->subdevices + 4;
 	s->type = COMEDI_SUBD_TTLIO;
 	s->subdev_flags =
@@ -132,13 +132,13 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	s->n_chan = 8;
 	s->maxdata = 1;
 	s->len_chanlist = 8;
-	s->range_table = &range_apci1710_ttl;	// to pass arguments in range
+	s->range_table = &range_apci1710_ttl;	/*  to pass arguments in range */
 	s->insn_config = i_APCI1710_InsnConfigInitTTLIO;
 	s->insn_bits = i_APCI1710_InsnBitsReadTTLIO;
 	s->insn_write = i_APCI1710_InsnWriteSetTTLIOChlOnOff;
 	s->insn_read = i_APCI1710_InsnReadTTLIOAllPortValue;
 
-	// Allocate and Initialise TOR Subdevice Structures
+	/*  Allocate and Initialise TOR Subdevice Structures */
 	s = dev->subdevices + 5;
 	s->type = COMEDI_SUBD_TOR;
 	s->subdev_flags =
@@ -147,13 +147,13 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	s->maxdata = 1;
 	s->len_chanlist = 8;
 	s->range_table = &range_digital;
-	s->io_bits = 0;		//all bits input
+	s->io_bits = 0;		/* all bits input */
 	s->insn_config = i_APCI1710_InsnConfigInitTorCounter;
 	s->insn_read = i_APCI1710_InsnReadGetTorCounterInitialisation;
 	s->insn_write = i_APCI1710_InsnWriteEnableDisableTorCounter;
 	s->insn_bits = i_APCI1710_InsnBitsGetTorCounterProgressStatusAndValue;
 
-	// Allocate and Initialise SSI Subdevice Structures
+	/*  Allocate and Initialise SSI Subdevice Structures */
 	s = dev->subdevices + 6;
 	s->type = COMEDI_SUBD_SSI;
 	s->subdev_flags =
@@ -166,7 +166,7 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	s->insn_read = i_APCI1710_InsnReadSSIValue;
 	s->insn_bits = i_APCI1710_InsnBitsSSIDigitalIO;
 
-	// Allocate and Initialise PULSEENCODER Subdevice Structures
+	/*  Allocate and Initialise PULSEENCODER Subdevice Structures */
 	s = dev->subdevices + 7;
 	s->type = COMEDI_SUBD_PULSEENCODER;
 	s->subdev_flags =
@@ -180,7 +180,7 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	s->insn_bits = i_APCI1710_InsnBitsReadWritePulseEncoder;
 	s->insn_read = i_APCI1710_InsnReadInterruptPulseEncoder;
 
-	// Allocate and Initialise INCREMENTALCOUNTER Subdevice Structures
+	/*  Allocate and Initialise INCREMENTALCOUNTER Subdevice Structures */
 	s = dev->subdevices + 8;
 	s->type = COMEDI_SUBD_INCREMENTALCOUNTER;
 	s->subdev_flags =
@@ -197,7 +197,7 @@ void i_ADDI_AttachPCI1710(struct comedi_
 
 int i_APCI1710_Reset(struct comedi_device * dev);
 void v_APCI1710_Interrupt(int irq, void *d);
-//for 1710
+/* for 1710 */
 
 int i_APCI1710_Reset(struct comedi_device * dev)
 {
@@ -219,12 +219,12 @@ int i_APCI1710_Reset(struct comedi_devic
 	ret = inl(devpriv->s_BoardInfos.ui_Address + 252);
 	devpriv->s_BoardInfos.dw_MolduleConfiguration[3] = ret;
 
-	// outl(0x80808082,devpriv->s_BoardInfos.ui_Address+0x60);
+	/*  outl(0x80808082,devpriv->s_BoardInfos.ui_Address+0x60); */
 	outl(0x83838383, devpriv->s_BoardInfos.ui_Address + 0x60);
 
 	devpriv->s_BoardInfos.b_BoardVersion = 1;
 
-	// Enable the interrupt for the controler
+	/*  Enable the interrupt for the controler */
 	dw_Dummy = inl(devpriv->s_BoardInfos.ui_Address + 0x38);
 	outl(dw_Dummy | 0x2000, devpriv->s_BoardInfos.ui_Address + 0x38);
 
@@ -279,7 +279,7 @@ void v_APCI1710_Interrupt(int irq, void 
 				dw_MolduleConfiguration[b_ModuleCpt] &
 				0xFFFF0000UL) == APCI1710_82X54_TIMER) {
 
-			//printk("TIMER Interrupt Occurred\n");
+			/* printk("TIMER Interrupt Occurred\n"); */
 			ul_82X54InterruptStatus = inl(devpriv->s_BoardInfos.
 				ui_Address + 12 + (64 * b_ModuleCpt));
 
@@ -332,11 +332,11 @@ void v_APCI1710_Interrupt(int irq, void 
 			     /**********************/
 				/* Call user function */
 			     /**********************/
-				//Send a signal to from kernel to user space
+				/* Send a signal to from kernel to user space */
 				send_sig(SIGIO, devpriv->tsk_Current, 0);
 
-			}	// if ((ul_82X54InterruptStatus & 0x7) != 0)
-		}		// 82X54 timer
+			}	/*  if ((ul_82X54InterruptStatus & 0x7) != 0) */
+		}		/*  82X54 timer */
 
 		 /***************************/
 		/* Test if increm. counter */
@@ -412,7 +412,7 @@ void v_APCI1710_Interrupt(int irq, void 
 				/**********************/
 					/* Call user function */
 				/**********************/
-					//Send a signal to from kernel to user space
+					/* Send a signal to from kernel to user space */
 					send_sig(SIGIO, devpriv->tsk_Current,
 						0);
 
@@ -473,7 +473,7 @@ void v_APCI1710_Interrupt(int irq, void 
 			    /**********************/
 					/* Call user function */
 				/**********************/
-					//Send a signal to from kernel to user space
+					/* Send a signal to from kernel to user space */
 					send_sig(SIGIO, devpriv->tsk_Current,
 						0);
 
@@ -562,7 +562,7 @@ void v_APCI1710_Interrupt(int irq, void 
 				/**********************/
 					/* Call user function */
 				/**********************/
-					//Send a signal to from kernel to user space
+					/* Send a signal to from kernel to user space */
 					send_sig(SIGIO, devpriv->tsk_Current,
 						0);
 
@@ -628,7 +628,7 @@ void v_APCI1710_Interrupt(int irq, void 
 				/**********************/
 					/* Call user function */
 				/**********************/
-					//Send a signal to from kernel to user space
+					/* Send a signal to from kernel to user space */
 					send_sig(SIGIO, devpriv->tsk_Current,
 						0);
 
@@ -795,11 +795,11 @@ void v_APCI1710_Interrupt(int irq, void 
 			     /**********************/
 				/* Call user function */
 			     /**********************/
-				//Send a signal to from kernel to user space
+				/* Send a signal to from kernel to user space */
 				send_sig(SIGIO, devpriv->tsk_Current, 0);
 
 			}
-		}		// Incremental counter
+		}		/*  Incremental counter */
 
 		 /***************/
 		/* Test if CDA */
@@ -870,14 +870,14 @@ void v_APCI1710_Interrupt(int irq, void 
 					/* Call user function */
 				/**********************/
 
-					//Send a signal to from kernel to user space
+					/* Send a signal to from kernel to user space */
 					send_sig(SIGIO, devpriv->tsk_Current,
 						0);
 
-				}	// if (ul_StatusRegister & 1)
+				}	/*  if (ul_StatusRegister & 1) */
 
 			}
-		}		// CDA
+		}		/*  CDA */
 
 		 /***********************/
 		/* Test if PWM counter */
@@ -950,15 +950,15 @@ void v_APCI1710_Interrupt(int irq, void 
 				   /**********************/
 						/* Call user function */
 				   /**********************/
-						//Send a signal to from kernel to user space
+						/* Send a signal to from kernel to user space */
 						send_sig(SIGIO,
 							devpriv->tsk_Current,
 							0);
 
-					}	// if (ul_StatusRegister & 0x1)
-				}	// if (APCI1710_ENABLE)
-			}	// for (b_PWMCpt == 0; b_PWMCpt < 0; b_PWMCpt ++)
-		}		// PWM counter
+					}	/*  if (ul_StatusRegister & 0x1) */
+				}	/*  if (APCI1710_ENABLE) */
+			}	/*  for (b_PWMCpt == 0; b_PWMCpt < 0; b_PWMCpt ++) */
+		}		/*  PWM counter */
 
 		 /***********************/
 		/* Test if tor counter */
@@ -1054,14 +1054,14 @@ void v_APCI1710_Interrupt(int irq, void 
 						/* Call user function */
 				   /**********************/
 
-						//Send a signal to from kernel to user space
+						/* Send a signal to from kernel to user space */
 						send_sig(SIGIO,
 							devpriv->tsk_Current,
 							0);
-					}	// if (ul_StatusRegister & 0x1)
-				}	// if (APCI1710_ENABLE)
-			}	// for (b_TorCounterCpt == 0; b_TorCounterCpt < 0; b_TorCounterCpt ++)
-		}		// Tor counter
+					}	/*  if (ul_StatusRegister & 0x1) */
+				}	/*  if (APCI1710_ENABLE) */
+			}	/*  for (b_TorCounterCpt == 0; b_TorCounterCpt < 0; b_TorCounterCpt ++) */
+		}		/*  Tor counter */
 
 		 /***********************/
 		/* Test if chronometer */
@@ -1071,7 +1071,7 @@ void v_APCI1710_Interrupt(int irq, void 
 				dw_MolduleConfiguration[b_ModuleCpt] &
 				0xFFFF0000UL) == APCI1710_CHRONOMETER) {
 
-			//printk("APCI1710 Chrono Interrupt\n");
+			/* printk("APCI1710 Chrono Interrupt\n"); */
 		    /*****************************/
 			/* Read the interrupt status */
 		    /*****************************/
@@ -1163,13 +1163,13 @@ void v_APCI1710_Interrupt(int irq, void 
 				/**********************/
 					/* Call user function */
 				/**********************/
-					//Send a signal to from kernel to user space
+					/* Send a signal to from kernel to user space */
 					send_sig(SIGIO, devpriv->tsk_Current,
 						0);
 
 				}
 			}
-		}		// Chronometer
+		}		/*  Chronometer */
 
 		 /*************************/
 		/* Test if pulse encoder */
@@ -1249,7 +1249,7 @@ void v_APCI1710_Interrupt(int irq, void 
 				   /**********************/
 						/* Call user function */
 				   /**********************/
-						//Send a signal to from kernel to user space
+						/* Send a signal to from kernel to user space */
 						send_sig(SIGIO,
 							devpriv->tsk_Current,
 							0);
@@ -1257,7 +1257,7 @@ void v_APCI1710_Interrupt(int irq, void 
 					}
 				}
 			}
-		}		//pulse encoder
+		}		/* pulse encoder */
 
 	}
 	return;
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.h
@@ -44,7 +44,7 @@
 #define APCI1710_SYNCHRONOUS_MODE	1
 #define APCI1710_ASYNCHRONOUS_MODE	0
 
-//MODULE INFO STRUCTURE
+/* MODULE INFO STRUCTURE */
 
 static const struct comedi_lrange range_apci1710_ttl = { 4, {
 						      BIP_RANGE(10),
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2016.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2016.c
@@ -82,13 +82,13 @@ int i_APCI2016_ConfigDigitalOutput(struc
 		comedi_error(dev,
 			"Not a valid Data !!! ,Data should be 1 or 0\n");
 		return -EINVAL;
-	}			// if  ((data[0]!=0) && (data[0]!=1))
+	}			/*  if  ((data[0]!=0) && (data[0]!=1)) */
 	if (data[0]) {
 		devpriv->b_OutputMemoryStatus = ADDIDATA_ENABLE;
-	}			// if  (data[0]
+	}			/*  if  (data[0] */
 	else {
 		devpriv->b_OutputMemoryStatus = ADDIDATA_DISABLE;
-	}			// else if  (data[0]
+	}			/*  else if  (data[0] */
 	return insn->n;
 }
 
@@ -121,24 +121,24 @@ int i_APCI2016_WriteDigitalOutput(struct
 		comedi_error(dev,
 			"Invalid Channel Numbers !!!, Channel Numbers must be between 0 and 15\n");
 		return -EINVAL;
-	}			// if  ((ui_NoOfChannel<0) || (ui_NoOfChannel>15))
+	}			/*  if  ((ui_NoOfChannel<0) || (ui_NoOfChannel>15)) */
 	if (devpriv->b_OutputMemoryStatus) {
 		ui_Temp = inw(devpriv->iobase + APCI2016_DIGITAL_OP);
-	}			// if  (devpriv->b_OutputMemoryStatus )
+	}			/*  if  (devpriv->b_OutputMemoryStatus ) */
 	else {
 		ui_Temp = 0;
-	}			// else if  (devpriv->b_OutputMemoryStatus )
+	}			/*  else if  (devpriv->b_OutputMemoryStatus ) */
 	if ((data[1] != 0) && (data[1] != 1)) {
 		comedi_error(dev,
 			"Invalid Data[1] value !!!, Data[1] should be 0 or 1\n");
 		return -EINVAL;
-	}			// if  ((data[1]!=0) && (data[1]!=1))
+	}			/*  if  ((data[1]!=0) && (data[1]!=1)) */
 
 	if (data[3] == 0) {
 		if (data[1] == 0) {
 			data[0] = (data[0] << ui_NoOfChannel) | ui_Temp;
 			outw(data[0], devpriv->iobase + APCI2016_DIGITAL_OP);
-		}		// if (data[1]==0)
+		}		/*  if (data[1]==0) */
 		else {
 			if (data[1] == 1) {
 				switch (ui_NoOfChannel) {
@@ -162,16 +162,16 @@ int i_APCI2016_WriteDigitalOutput(struct
 					break;
 				default:
 					comedi_error(dev, " chan spec wrong");
-					return -EINVAL;	// "sorry channel spec wrong "
-				}	//switch(ui_NoOfChannels)
+					return -EINVAL;	/*  "sorry channel spec wrong " */
+				}	/* switch(ui_NoOfChannels) */
 				outw(data[0],
 					devpriv->iobase + APCI2016_DIGITAL_OP);
-			}	// if  (data[1]==1)
+			}	/*  if  (data[1]==1) */
 			else {
 				printk("\nSpecified channel not supported\n");
-			}	// else if  (data[1]==1)
-		}		// else if (data[1]==0)
-	}			// if (data[3]==0)
+			}	/*  else if  (data[1]==1) */
+		}		/*  else if (data[1]==0) */
+	}			/*  if (data[3]==0) */
 	else {
 		if (data[3] == 1) {
 			if (data[1] == 0) {
@@ -183,7 +183,7 @@ int i_APCI2016_WriteDigitalOutput(struct
 				data[0] = data[0] & ui_Temp;
 				outw(data[0],
 					devpriv->iobase + APCI2016_DIGITAL_OP);
-			}	// if  (data[1]==0)
+			}	/*  if  (data[1]==0) */
 			else {
 				if (data[1] == 1) {
 					switch (ui_NoOfChannel) {
@@ -228,22 +228,22 @@ int i_APCI2016_WriteDigitalOutput(struct
 					default:
 						comedi_error(dev,
 							" chan spec wrong");
-						return -EINVAL;	// "sorry channel spec wrong "
-					}	//switch(ui_NoOfChannels)
+						return -EINVAL;	/*  "sorry channel spec wrong " */
+					}	/* switch(ui_NoOfChannels) */
 					outw(data[0],
 						devpriv->iobase +
 						APCI2016_DIGITAL_OP);
-				}	// if(data[1]==1)
+				}	/*  if(data[1]==1) */
 				else {
 					printk("\nSpecified channel not supported\n");
-				}	//else if(data[1]==1)
-			}	//elseif(data[1]==0)
-		}		//if(data[3]==1);
+				}	/* else if(data[1]==1) */
+			}	/* elseif(data[1]==0) */
+		}		/* if(data[3]==1); */
 		else {
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		//if else data[3]==1)
-	}			//if else data[3]==0)
+		}		/* if else data[3]==1) */
+	}			/* if else data[3]==0) */
 	return insn->n;
 }
 
@@ -276,17 +276,17 @@ int i_APCI2016_BitsDigitalOutput(struct 
 		comedi_error(dev,
 			"Invalid Channel Numbers !!!, Channel Numbers must be between 0 and 15\n");
 		return -EINVAL;
-	}			// if  ((ui_NoOfChannel<0) || (ui_NoOfChannel>15))
+	}			/*  if  ((ui_NoOfChannel<0) || (ui_NoOfChannel>15)) */
 	if ((data[0] != 0) && (data[0] != 1)) {
 		comedi_error(dev,
 			"Invalid Data[0] value !!!, Data[0] should be 0 or 1\n");
 		return -EINVAL;
-	}			// if  ((data[0]!=0) && (data[0]!=1))
+	}			/*  if  ((data[0]!=0) && (data[0]!=1)) */
 	ui_Temp = data[0];
 	*data = inw(devpriv->iobase + APCI2016_DIGITAL_OP_RW);
 	if (ui_Temp == 0) {
 		*data = (*data >> ui_NoOfChannel) & 0x1;
-	}			// if  (ui_Temp==0)
+	}			/*  if  (ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 			switch (ui_NoOfChannel) {
@@ -307,13 +307,13 @@ int i_APCI2016_BitsDigitalOutput(struct 
 
 			default:
 				comedi_error(dev, " chan spec wrong");
-				return -EINVAL;	// "sorry channel spec wrong "
-			}	//switch(ui_NoOfChannel)
-		}		// if  (ui_Temp==1)
+				return -EINVAL;	/*  "sorry channel spec wrong " */
+			}	/* switch(ui_NoOfChannel) */
+		}		/*  if  (ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		// else if  (ui_Temp==1)
-	}			// if  (ui_Temp==0)
+		}		/*  else if  (ui_Temp==1) */
+	}			/*  if  (ui_Temp==0) */
 	return insn->n;
 }
 
@@ -342,11 +342,11 @@ int i_APCI2016_ConfigWatchdog(struct com
 {
 
 	if (data[0] == 0) {
-		//Disable the watchdog
+		/* Disable the watchdog */
 		outw(0x0,
 			devpriv->i_IobaseAddon +
 			APCI2016_WATCHDOG_ENABLEDISABLE);
-		//Loading the Reload value
+		/* Loading the Reload value */
 		outw(data[1],
 			devpriv->i_IobaseAddon +
 			APCI2016_WATCHDOG_RELOAD_VALUE);
@@ -385,15 +385,15 @@ int i_APCI2016_StartStopWriteWatchdog(st
 {
 
 	switch (data[0]) {
-	case 0:		//stop the watchdog
-		outw(0x0, devpriv->i_IobaseAddon + APCI2016_WATCHDOG_ENABLEDISABLE);	//disable the watchdog
+	case 0:		/* stop the watchdog */
+		outw(0x0, devpriv->i_IobaseAddon + APCI2016_WATCHDOG_ENABLEDISABLE);	/* disable the watchdog */
 		break;
-	case 1:		//start the watchdog
+	case 1:		/* start the watchdog */
 		outw(0x0001,
 			devpriv->i_IobaseAddon +
 			APCI2016_WATCHDOG_ENABLEDISABLE);
 		break;
-	case 2:		//Software trigger
+	case 2:		/* Software trigger */
 		outw(0x0201,
 			devpriv->i_IobaseAddon +
 			APCI2016_WATCHDOG_ENABLEDISABLE);
@@ -401,7 +401,7 @@ int i_APCI2016_StartStopWriteWatchdog(st
 	default:
 		printk("\nSpecified functionality does not exist\n");
 		return -EINVAL;
-	}			// switch(data[0])
+	}			/*  switch(data[0]) */
 
 	return insn->n;
 }
@@ -452,7 +452,7 @@ int i_APCI2016_ReadWatchdog(struct comed
 
 int i_APCI2016_Reset(struct comedi_device * dev)
 {
-	outw(0x0, devpriv->iobase + APCI2016_DIGITAL_OP);	// Resets the digital output channels
+	outw(0x0, devpriv->iobase + APCI2016_DIGITAL_OP);	/*  Resets the digital output channels */
 	outw(0x0, devpriv->i_IobaseAddon + APCI2016_WATCHDOG_ENABLEDISABLE);
 	outw(0x0, devpriv->i_IobaseAddon + APCI2016_WATCHDOG_RELOAD_VALUE);
 	outw(0x0, devpriv->i_IobaseAddon + APCI2016_WATCHDOG_RELOAD_VALUE + 2);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2016.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2016.h
@@ -19,17 +19,17 @@
 #define APCI2016_BOARD_VENDOR_ID 0x15B8
 #define APCI2016_ADDRESS_RANGE   8
 
-//DIGITAL INPUT-OUTPUT DEFINE
+/* DIGITAL INPUT-OUTPUT DEFINE */
 
 #define APCI2016_DIGITAL_OP                 	0x04
 #define APCI2016_DIGITAL_OP_RW                 	4
 
-//ADDIDATA Enable Disable
+/* ADDIDATA Enable Disable */
 
 #define ADDIDATA_ENABLE                            1
 #define ADDIDATA_DISABLE                           0
 
-// TIMER COUNTER WATCHDOG DEFINES
+/* TIMER COUNTER WATCHDOG DEFINES */
 
 #define ADDIDATA_WATCHDOG                          2
 #define APCI2016_DIGITAL_OP_WATCHDOG               0
@@ -37,9 +37,9 @@
 #define APCI2016_WATCHDOG_RELOAD_VALUE             4
 #define APCI2016_WATCHDOG_STATUS                   16
 
-// Hardware Layer  functions for Apci2016
+/* Hardware Layer  functions for Apci2016 */
 
-//DO
+/* DO */
 int i_APCI2016_ConfigDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data);
 
@@ -49,8 +49,10 @@ int i_APCI2016_WriteDigitalOutput(struct
 int i_APCI2016_BitsDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
 
-// TIMER
-// timer value is passed as u seconds
+/*
+* TIMER
+* timer value is passed as u seconds
+*/
 
 int i_APCI2016_ConfigWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data);
@@ -61,10 +63,10 @@ int i_APCI2016_StartStopWriteWatchdog(st
 int i_APCI2016_ReadWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data);
 
-// Interrupt functions.....
+/* Interrupt functions..... */
 
-// void v_APCI2016_Interrupt(int irq, void *d) ;
+/* void v_APCI2016_Interrupt(int irq, void *d); */
 
- //void v_APCI2016_Interrupt(int irq, void *d);
-// RESET
+/* void v_APCI2016_Interrupt(int irq, void *d); */
+/* RESET */
 int i_APCI2016_Reset(struct comedi_device *dev);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.c
@@ -89,26 +89,26 @@ int i_APCI2032_ConfigDigitalOutput(struc
 		comedi_error(dev,
 			"Not a valid Data !!! ,Data should be 1 or 0\n");
 		return -EINVAL;
-	}			//if  ( (data[0]!=0) && (data[0]!=1) )
+	}			/* if  ( (data[0]!=0) && (data[0]!=1) ) */
 	if (data[0]) {
 		devpriv->b_OutputMemoryStatus = ADDIDATA_ENABLE;
-	}			// if  (data[0])
+	}			/*  if  (data[0]) */
 	else {
 		devpriv->b_OutputMemoryStatus = ADDIDATA_DISABLE;
-	}			//else if  (data[0])
+	}			/* else if  (data[0]) */
 
 	if (data[1] == ADDIDATA_ENABLE) {
 		ul_Command = ul_Command | 0x1;
-	}			//if  (data[1] == ADDIDATA_ENABLE)
+	}			/* if  (data[1] == ADDIDATA_ENABLE) */
 	else {
 		ul_Command = ul_Command & 0xFFFFFFFE;
-	}			//elseif  (data[1] == ADDIDATA_ENABLE)
+	}			/* elseif  (data[1] == ADDIDATA_ENABLE) */
 	if (data[2] == ADDIDATA_ENABLE) {
 		ul_Command = ul_Command | 0x2;
-	}			//if  (data[2] == ADDIDATA_ENABLE)
+	}			/* if  (data[2] == ADDIDATA_ENABLE) */
 	else {
 		ul_Command = ul_Command & 0xFFFFFFFD;
-	}			//elseif  (data[2] == ADDIDATA_ENABLE)
+	}			/* elseif  (data[2] == ADDIDATA_ENABLE) */
 	outl(ul_Command, devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
 	ui_InterruptData = inl(devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
 	return insn->n;
@@ -138,19 +138,19 @@ int i_APCI2032_WriteDigitalOutput(struct
 	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int ui_Temp, ui_Temp1;
-	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	/*  get the channel */
 	if (devpriv->b_OutputMemoryStatus) {
 		ui_Temp = inl(devpriv->iobase + APCI2032_DIGITAL_OP);
 
-	}			//if(devpriv->b_OutputMemoryStatus )
+	}			/* if(devpriv->b_OutputMemoryStatus ) */
 	else {
 		ui_Temp = 0;
-	}			//if(devpriv->b_OutputMemoryStatus )
+	}			/* if(devpriv->b_OutputMemoryStatus ) */
 	if (data[3] == 0) {
 		if (data[1] == 0) {
 			data[0] = (data[0] << ui_NoOfChannel) | ui_Temp;
 			outl(data[0], devpriv->iobase + APCI2032_DIGITAL_OP);
-		}		//if(data[1]==0)
+		}		/* if(data[1]==0) */
 		else {
 			if (data[1] == 1) {
 				switch (ui_NoOfChannel) {
@@ -184,18 +184,18 @@ int i_APCI2032_WriteDigitalOutput(struct
 
 				default:
 					comedi_error(dev, " chan spec wrong");
-					return -EINVAL;	// "sorry channel spec wrong "
+					return -EINVAL;	/*  "sorry channel spec wrong " */
 
-				}	//switch(ui_NoOfChannels)
+				}	/* switch(ui_NoOfChannels) */
 
 				outl(data[0],
 					devpriv->iobase + APCI2032_DIGITAL_OP);
-			}	// if(data[1]==1)
+			}	/*  if(data[1]==1) */
 			else {
 				printk("\nSpecified channel not supported\n");
-			}	//else if(data[1]==1)
-		}		//elseif(data[1]==0)
-	}			//if(data[3]==0)
+			}	/* else if(data[1]==1) */
+		}		/* elseif(data[1]==0) */
+	}			/* if(data[3]==0) */
 	else {
 		if (data[3] == 1) {
 			if (data[1] == 0) {
@@ -209,7 +209,7 @@ int i_APCI2032_WriteDigitalOutput(struct
 				data[0] = data[0] & ui_Temp;
 				outl(data[0],
 					devpriv->iobase + APCI2032_DIGITAL_OP);
-			}	//if(data[1]==0)
+			}	/* if(data[1]==0) */
 			else {
 				if (data[1] == 1) {
 					switch (ui_NoOfChannel) {
@@ -272,24 +272,24 @@ int i_APCI2032_WriteDigitalOutput(struct
 					default:
 						comedi_error(dev,
 							" chan spec wrong");
-						return -EINVAL;	// "sorry channel spec wrong "
+						return -EINVAL;	/*  "sorry channel spec wrong " */
 
-					}	//switch(ui_NoOfChannels)
+					}	/* switch(ui_NoOfChannels) */
 
 					outl(data[0],
 						devpriv->iobase +
 						APCI2032_DIGITAL_OP);
-				}	// if(data[1]==1)
+				}	/*  if(data[1]==1) */
 				else {
 					printk("\nSpecified channel not supported\n");
-				}	//else if(data[1]==1)
-			}	//elseif(data[1]==0)
-		}		//if(data[3]==1);
+				}	/* else if(data[1]==1) */
+			}	/* elseif(data[1]==0) */
+		}		/* if(data[3]==1); */
 		else {
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		//if else data[3]==1)
-	}			//if else data[3]==0)
+		}		/* if else data[3]==1) */
+	}			/* if else data[3]==0) */
 	return (insn->n);;
 }
 
@@ -323,7 +323,7 @@ int i_APCI2032_ReadDigitalOutput(struct 
 	*data = inl(devpriv->iobase + APCI2032_DIGITAL_OP_RW);
 	if (ui_Temp == 0) {
 		*data = (*data >> ui_NoOfChannel) & 0x1;
-	}			//if  (ui_Temp==0)
+	}			/* if  (ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 			switch (ui_NoOfChannel) {
@@ -349,13 +349,13 @@ int i_APCI2032_ReadDigitalOutput(struct 
 
 			default:
 				comedi_error(dev, " chan spec wrong");
-				return -EINVAL;	// "sorry channel spec wrong "
+				return -EINVAL;	/*  "sorry channel spec wrong " */
 
-			}	//switch(ui_NoOfChannels)
-		}		//if  (ui_Temp==1)
+			}	/* switch(ui_NoOfChannels) */
+		}		/* if  (ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		//elseif  (ui_Temp==1)
+		}		/* elseif  (ui_Temp==1) */
 	}
 	return insn->n;
 }
@@ -384,11 +384,11 @@ int i_APCI2032_ConfigWatchdog(struct com
 	struct comedi_insn * insn, unsigned int * data)
 {
 	if (data[0] == 0) {
-		//Disable the watchdog
+		/* Disable the watchdog */
 		outl(0x0,
 			devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
 			APCI2032_TCW_PROG);
-		//Loading the Reload value
+		/* Loading the Reload value */
 		outl(data[1],
 			devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
 			APCI2032_TCW_RELOAD_VALUE);
@@ -425,15 +425,15 @@ int i_APCI2032_StartStopWriteWatchdog(st
 	struct comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
-	case 0:		//stop the watchdog
-		outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);	//disable the watchdog
+	case 0:		/* stop the watchdog */
+		outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);	/* disable the watchdog */
 		break;
-	case 1:		//start the watchdog
+	case 1:		/* start the watchdog */
 		outl(0x0001,
 			devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
 			APCI2032_TCW_PROG);
 		break;
-	case 2:		//Software trigger
+	case 2:		/* Software trigger */
 		outl(0x0201,
 			devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
 			APCI2032_TCW_PROG);
@@ -498,13 +498,13 @@ void v_APCI2032_Interrupt(int irq, void 
 	struct comedi_device *dev = d;
 	unsigned int ui_DO;
 
-	ui_DO = inl(devpriv->iobase + APCI2032_DIGITAL_OP_IRQ) & 0x1;	//Check if VCC OR CC interrupt has occured.
+	ui_DO = inl(devpriv->iobase + APCI2032_DIGITAL_OP_IRQ) & 0x1;	/* Check if VCC OR CC interrupt has occured. */
 
 	if (ui_DO == 0) {
 		printk("\nInterrupt from unKnown source\n");
-	}			// if(ui_DO==0)
+	}			/*  if(ui_DO==0) */
 	if (ui_DO) {
-		// Check for Digital Output interrupt Type - 1: Vcc interrupt 2: CC interrupt.
+		/*  Check for Digital Output interrupt Type - 1: Vcc interrupt 2: CC interrupt. */
 		ui_Type =
 			inl(devpriv->iobase +
 			APCI2032_DIGITAL_OP_INTERRUPT_STATUS) & 0x3;
@@ -512,16 +512,16 @@ void v_APCI2032_Interrupt(int irq, void 
 			devpriv->iobase + APCI2032_DIGITAL_OP +
 			APCI2032_DIGITAL_OP_INTERRUPT);
 		if (ui_Type == 1) {
-			//Sends signal to user space
+			/* Sends signal to user space */
 			send_sig(SIGIO, devpriv->tsk_Current, 0);
-		}		// if (ui_Type==1)
+		}		/*  if (ui_Type==1) */
 		else {
 			if (ui_Type == 2) {
-				// Sends signal to user space
+				/*  Sends signal to user space */
 				send_sig(SIGIO, devpriv->tsk_Current, 0);
-			}	//if (ui_Type==2)
-		}		//else if (ui_Type==1)
-	}			//if(ui_DO)
+			}	/* if (ui_Type==2) */
+		}		/* else if (ui_Type==1) */
+	}			/* if(ui_DO) */
 
 	return;
 
@@ -571,9 +571,9 @@ int i_APCI2032_Reset(struct comedi_devic
 {
 	devpriv->b_DigitalOutputRegister = 0;
 	ui_Type = 0;
-	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP);	//Resets the output channels
-	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);	//Disables the interrupt.
-	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);	//disable the watchdog
-	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_RELOAD_VALUE);	//reload=0
+	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP);	/* Resets the output channels */
+	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);	/* Disables the interrupt. */
+	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);	/* disable the watchdog */
+	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_RELOAD_VALUE);	/* reload=0 */
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.h
@@ -17,32 +17,32 @@
 
 /*********      Definitions for APCI-2032 card  *****/
 
-// Card Specific information
+/* Card Specific information */
 #define APCI2032_BOARD_VENDOR_ID                 0x15B8
 #define APCI2032_ADDRESS_RANGE                   63
 
-//DIGITAL INPUT-OUTPUT DEFINE
+/* DIGITAL INPUT-OUTPUT DEFINE */
 
 #define APCI2032_DIGITAL_OP                 	0
 #define APCI2032_DIGITAL_OP_RW                 	0
 #define APCI2032_DIGITAL_OP_INTERRUPT           4
 #define APCI2032_DIGITAL_OP_IRQ                 12
 
-//Digital Output Interrupt Status
+/* Digital Output Interrupt Status */
 #define APCI2032_DIGITAL_OP_INTERRUPT_STATUS    8
 
-//Digital Output Interrupt Enable Disable.
+/* Digital Output Interrupt Enable Disable. */
 #define APCI2032_DIGITAL_OP_VCC_INTERRUPT_ENABLE   0x1
 #define APCI2032_DIGITAL_OP_VCC_INTERRUPT_DISABLE  0xFFFFFFFE
 #define APCI2032_DIGITAL_OP_CC_INTERRUPT_ENABLE    0x2
 #define APCI2032_DIGITAL_OP_CC_INTERRUPT_DISABLE   0xFFFFFFFD
 
-//ADDIDATA Enable Disable
+/* ADDIDATA Enable Disable */
 
 #define ADDIDATA_ENABLE                            1
 #define ADDIDATA_DISABLE                           0
 
-// TIMER COUNTER WATCHDOG DEFINES
+/* TIMER COUNTER WATCHDOG DEFINES */
 
 #define ADDIDATA_WATCHDOG                          2
 #define APCI2032_DIGITAL_OP_WATCHDOG               16
@@ -52,9 +52,9 @@
 #define APCI2032_TCW_TRIG_STATUS                   16
 #define APCI2032_TCW_IRQ                           20
 
-// Hardware Layer  functions for Apci2032
+/* Hardware Layer  functions for Apci2032 */
 
-//DO
+/* DO */
 int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data);
 int i_APCI2032_WriteDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -64,8 +64,10 @@ int i_APCI2032_ReadDigitalOutput(struct 
 int i_APCI2032_ReadInterruptStatus(struct comedi_device *dev, struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data);
 
-// TIMER
-// timer value is passed as u seconds
+/* TIMER
+ * timer value is passed as u seconds
+*/
+
 int i_APCI2032_ConfigWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data);
 int i_APCI2032_StartStopWriteWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -73,9 +75,9 @@ int i_APCI2032_StartStopWriteWatchdog(st
 int i_APCI2032_ReadWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data);
 
-// Interrupt functions.....
+/* Interrupt functions..... */
 
 void v_APCI2032_Interrupt(int irq, void *d);
 
-//Reset functions
+/* Reset functions */
 int i_APCI2032_Reset(struct comedi_device *dev);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2200.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2200.c
@@ -82,11 +82,11 @@ int i_APCI2200_Read1DigitalInput(struct 
 	if (ui_Channel >= 0 && ui_Channel <= 7) {
 		ui_TmpValue = (unsigned int) inw(devpriv->iobase + APCI2200_DIGITAL_IP);
 		*data = (ui_TmpValue >> ui_Channel) & 0x1;
-	}			//if(ui_Channel >= 0 && ui_Channel <=7)
+	}			/* if(ui_Channel >= 0 && ui_Channel <=7) */
 	else {
 		printk("\nThe specified channel does not exist\n");
-		return -EINVAL;	// "sorry channel spec wrong "
-	}			//else if(ui_Channel >= 0 && ui_Channel <=7)
+		return -EINVAL;	/*  "sorry channel spec wrong " */
+	}			/* else if(ui_Channel >= 0 && ui_Channel <=7) */
 
 	return insn->n;
 }
@@ -137,9 +137,9 @@ int i_APCI2200_ReadMoreDigitalInput(stru
 
 	default:
 		printk("\nWrong parameters\n");
-		return -EINVAL;	// "sorry channel spec wrong "
+		return -EINVAL;	/*  "sorry channel spec wrong " */
 		break;
-	}			//switch(ui_NoOfChannels)
+	}			/* switch(ui_NoOfChannels) */
 
 	return insn->n;
 }
@@ -201,19 +201,19 @@ int i_APCI2200_WriteDigitalOutput(struct
 	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int ui_Temp, ui_Temp1;
-	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	/*  get the channel */
 	if (devpriv->b_OutputMemoryStatus) {
 		ui_Temp = inw(devpriv->iobase + APCI2200_DIGITAL_OP);
 
-	}			//if(devpriv->b_OutputMemoryStatus )
+	}			/* if(devpriv->b_OutputMemoryStatus ) */
 	else {
 		ui_Temp = 0;
-	}			//if(devpriv->b_OutputMemoryStatus )
+	}			/* if(devpriv->b_OutputMemoryStatus ) */
 	if (data[3] == 0) {
 		if (data[1] == 0) {
 			data[0] = (data[0] << ui_NoOfChannel) | ui_Temp;
 			outw(data[0], devpriv->iobase + APCI2200_DIGITAL_OP);
-		}		//if(data[1]==0)
+		}		/* if(data[1]==0) */
 		else {
 			if (data[1] == 1) {
 				switch (ui_NoOfChannel) {
@@ -240,18 +240,18 @@ int i_APCI2200_WriteDigitalOutput(struct
 					break;
 				default:
 					comedi_error(dev, " chan spec wrong");
-					return -EINVAL;	// "sorry channel spec wrong "
+					return -EINVAL;	/*  "sorry channel spec wrong " */
 
-				}	//switch(ui_NoOfChannels)
+				}	/* switch(ui_NoOfChannels) */
 
 				outw(data[0],
 					devpriv->iobase + APCI2200_DIGITAL_OP);
-			}	// if(data[1]==1)
+			}	/*  if(data[1]==1) */
 			else {
 				printk("\nSpecified channel not supported\n");
-			}	//else if(data[1]==1)
-		}		//elseif(data[1]==0)
-	}			//if(data[3]==0)
+			}	/* else if(data[1]==1) */
+		}		/* elseif(data[1]==0) */
+	}			/* if(data[3]==0) */
 	else {
 		if (data[3] == 1) {
 			if (data[1] == 0) {
@@ -263,7 +263,7 @@ int i_APCI2200_WriteDigitalOutput(struct
 				data[0] = data[0] & ui_Temp;
 				outw(data[0],
 					devpriv->iobase + APCI2200_DIGITAL_OP);
-			}	//if(data[1]==0)
+			}	/* if(data[1]==0) */
 			else {
 				if (data[1] == 1) {
 					switch (ui_NoOfChannel) {
@@ -312,24 +312,24 @@ int i_APCI2200_WriteDigitalOutput(struct
 					default:
 						comedi_error(dev,
 							" chan spec wrong");
-						return -EINVAL;	// "sorry channel spec wrong "
+						return -EINVAL;	/*  "sorry channel spec wrong " */
 
-					}	//switch(ui_NoOfChannels)
+					}	/* switch(ui_NoOfChannels) */
 
 					outw(data[0],
 						devpriv->iobase +
 						APCI2200_DIGITAL_OP);
-				}	// if(data[1]==1)
+				}	/*  if(data[1]==1) */
 				else {
 					printk("\nSpecified channel not supported\n");
-				}	//else if(data[1]==1)
-			}	//elseif(data[1]==0)
-		}		//if(data[3]==1);
+				}	/* else if(data[1]==1) */
+			}	/* elseif(data[1]==0) */
+		}		/* if(data[3]==1); */
 		else {
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		//if else data[3]==1)
-	}			//if else data[3]==0)
+		}		/* if else data[3]==1) */
+	}			/* if else data[3]==0) */
 	return (insn->n);;
 }
 
@@ -359,12 +359,12 @@ int i_APCI2200_ReadDigitalOutput(struct 
 {
 
 	unsigned int ui_Temp;
-	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	/*  get the channel */
 	ui_Temp = data[0];
 	*data = inw(devpriv->iobase + APCI2200_DIGITAL_OP);
 	if (ui_Temp == 0) {
 		*data = (*data >> ui_NoOfChannel) & 0x1;
-	}			//if(ui_Temp==0)
+	}			/* if(ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 			switch (ui_NoOfChannel) {
@@ -386,14 +386,14 @@ int i_APCI2200_ReadDigitalOutput(struct 
 
 			default:
 				comedi_error(dev, " chan spec wrong");
-				return -EINVAL;	// "sorry channel spec wrong "
+				return -EINVAL;	/*  "sorry channel spec wrong " */
 
-			}	//switch(ui_NoOfChannels)
-		}		//if(ui_Temp==1)
+			}	/* switch(ui_NoOfChannels) */
+		}		/* if(ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		//elseif(ui_Temp==1)
-	}			//elseif(ui_Temp==0)
+		}		/* elseif(ui_Temp==1) */
+	}			/* elseif(ui_Temp==0) */
 	return insn->n;
 }
 
@@ -422,11 +422,11 @@ int i_APCI2200_ConfigWatchdog(struct com
 	struct comedi_insn * insn, unsigned int * data)
 {
 	if (data[0] == 0) {
-		//Disable the watchdog
+		/* Disable the watchdog */
 		outw(0x0,
 			devpriv->iobase + APCI2200_WATCHDOG +
 			APCI2200_WATCHDOG_ENABLEDISABLE);
-		//Loading the Reload value
+		/* Loading the Reload value */
 		outw(data[1],
 			devpriv->iobase + APCI2200_WATCHDOG +
 			APCI2200_WATCHDOG_RELOAD_VALUE);
@@ -434,11 +434,11 @@ int i_APCI2200_ConfigWatchdog(struct com
 		outw(data[1],
 			devpriv->iobase + APCI2200_WATCHDOG +
 			APCI2200_WATCHDOG_RELOAD_VALUE + 2);
-	}			//if(data[0]==0)
+	}			/* if(data[0]==0) */
 	else {
 		printk("\nThe input parameters are wrong\n");
 		return -EINVAL;
-	}			//elseif(data[0]==0)
+	}			/* elseif(data[0]==0) */
 
 	return insn->n;
 }
@@ -468,15 +468,15 @@ int i_APCI2200_StartStopWriteWatchdog(st
 	struct comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
-	case 0:		//stop the watchdog
-		outw(0x0, devpriv->iobase + APCI2200_WATCHDOG + APCI2200_WATCHDOG_ENABLEDISABLE);	//disable the watchdog
+	case 0:		/* stop the watchdog */
+		outw(0x0, devpriv->iobase + APCI2200_WATCHDOG + APCI2200_WATCHDOG_ENABLEDISABLE);	/* disable the watchdog */
 		break;
-	case 1:		//start the watchdog
+	case 1:		/* start the watchdog */
 		outw(0x0001,
 			devpriv->iobase + APCI2200_WATCHDOG +
 			APCI2200_WATCHDOG_ENABLEDISABLE);
 		break;
-	case 2:		//Software trigger
+	case 2:		/* Software trigger */
 		outw(0x0201,
 			devpriv->iobase + APCI2200_WATCHDOG +
 			APCI2200_WATCHDOG_ENABLEDISABLE);
@@ -484,7 +484,7 @@ int i_APCI2200_StartStopWriteWatchdog(st
 	default:
 		printk("\nSpecified functionality does not exist\n");
 		return -EINVAL;
-	}			// switch(data[0])
+	}			/*  switch(data[0]) */
 	return insn->n;
 }
 
@@ -535,7 +535,7 @@ int i_APCI2200_ReadWatchdog(struct comed
 
 int i_APCI2200_Reset(struct comedi_device * dev)
 {
-	outw(0x0, devpriv->iobase + APCI2200_DIGITAL_OP);	//RESETS THE DIGITAL OUTPUTS
+	outw(0x0, devpriv->iobase + APCI2200_DIGITAL_OP);	/* RESETS THE DIGITAL OUTPUTS */
 	outw(0x0,
 		devpriv->iobase + APCI2200_WATCHDOG +
 		APCI2200_WATCHDOG_ENABLEDISABLE);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2200.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2200.h
@@ -17,31 +17,31 @@
 
 /*********      Definitions for APCI-2200 card  *****/
 
-// Card Specific information
+/* Card Specific information */
 #define APCI2200_BOARD_VENDOR_ID                 0x15b8
 #define APCI2200_ADDRESS_RANGE                   64
 
-//DIGITAL INPUT-OUTPUT DEFINE
+/* DIGITAL INPUT-OUTPUT DEFINE */
 
 #define APCI2200_DIGITAL_OP                 	4
 #define APCI2200_DIGITAL_IP                     0
 
-// TIMER COUNTER WATCHDOG DEFINES
+/* TIMER COUNTER WATCHDOG DEFINES */
 
 #define APCI2200_WATCHDOG                          0x08
 #define APCI2200_WATCHDOG_ENABLEDISABLE            12
 #define APCI2200_WATCHDOG_RELOAD_VALUE             4
 #define APCI2200_WATCHDOG_STATUS                   16
 
-// Hardware Layer  functions for Apci2200
+/* Hardware Layer  functions for Apci2200 */
 
-//Digital Input
+/* Digital Input */
 int i_APCI2200_ReadMoreDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				    struct comedi_insn *insn, unsigned int *data);
 int i_APCI2200_Read1DigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
 
-//Digital Output
+/* Digital Output */
 int i_APCI2200_ConfigDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data);
 int i_APCI2200_WriteDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -49,7 +49,7 @@ int i_APCI2200_WriteDigitalOutput(struct
 int i_APCI2200_ReadDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
 
-// TIMER
+/* TIMER */
 int i_APCI2200_ConfigWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data);
 int i_APCI2200_StartStopWriteWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -57,5 +57,5 @@ int i_APCI2200_StartStopWriteWatchdog(st
 int i_APCI2200_ReadWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data);
 
-//reset
+/* reset */
 int i_APCI2200_Reset(struct comedi_device *dev);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.h
@@ -1,5 +1,5 @@
 
-// hwdrv_apci3120.h
+/* hwdrv_apci3120.h */
 
 /*
  * Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
@@ -18,9 +18,9 @@
  * any later version.
  */
 
-// comedi related defines
+/* comedi related defines */
 
-//ANALOG INPUT RANGE
+/* ANALOG INPUT RANGE */
 static const struct comedi_lrange range_apci3120_ai = { 8, {
 						     BIP_RANGE(10),
 						     BIP_RANGE(5),
@@ -33,14 +33,14 @@ static const struct comedi_lrange range_
 						     }
 };
 
-// ANALOG OUTPUT RANGE
+/* ANALOG OUTPUT RANGE */
 static const struct comedi_lrange range_apci3120_ao = { 2, {
 						     BIP_RANGE(10),
 						     UNI_RANGE(10)
 						     }
 };
 
-#define APCI3120_BIPOLAR_RANGES	4	// used for test on mixture of BIP/UNI ranges
+#define APCI3120_BIPOLAR_RANGES	4	/*  used for test on mixture of BIP/UNI ranges */
 
 #define APCI3120_BOARD_VENDOR_ID                 0x10E8
 #define APCI3120_ADDRESS_RANGE            			16
@@ -55,17 +55,17 @@ static const struct comedi_lrange range_
 #define     APCI3120_EOS_MODE         2
 #define     APCI3120_DMA_MODE         3
 
-//DIGITAL INPUT-OUTPUT DEFINE
+/* DIGITAL INPUT-OUTPUT DEFINE */
 
 #define APCI3120_DIGITAL_OUTPUT                  	0x0D
 #define APCI3120_RD_STATUS                       	0x02
 #define APCI3120_RD_FIFO                     		0x00
 
-// digital output insn_write ON /OFF selection
+/* digital output insn_write ON /OFF selection */
 #define	APCI3120_SET4DIGITALOUTPUTON				1
 #define APCI3120_SET4DIGITALOUTPUTOFF				0
 
-// analog output SELECT BIT
+/* analog output SELECT BIT */
 #define APCI3120_ANALOG_OP_CHANNEL_1   0x0000
 #define APCI3120_ANALOG_OP_CHANNEL_2   0x4000
 #define APCI3120_ANALOG_OP_CHANNEL_3   0x8000
@@ -75,32 +75,32 @@ static const struct comedi_lrange range_
 #define APCI3120_ANALOG_OP_CHANNEL_7   0x8000
 #define APCI3120_ANALOG_OP_CHANNEL_8   0xC000
 
-// Enable external trigger bit in nWrAddress
+/* Enable external trigger bit in nWrAddress */
 #define APCI3120_ENABLE_EXT_TRIGGER    0x8000
 
-//ANALOG OUTPUT AND INPUT DEFINE
-#define APCI3120_UNIPOLAR 0x80	//$$ RAM sequence polarity BIT
-#define APCI3120_BIPOLAR  0x00	//$$ RAM sequence polarity BIT
-#define APCI3120_ANALOG_OUTPUT_1 0x08	// (ADDRESS )
-#define APCI3120_ANALOG_OUTPUT_2 0x0A	// (ADDRESS )
-#define APCI3120_1_GAIN              0x00	//$$ RAM sequence Gain Bits for gain 1
-#define APCI3120_2_GAIN              0x10	//$$ RAM sequence Gain Bits for gain 2
-#define APCI3120_5_GAIN              0x20	//$$ RAM sequence Gain Bits for gain 5
-#define APCI3120_10_GAIN             0x30	//$$ RAM sequence Gain Bits for gain 10
-#define APCI3120_SEQ_RAM_ADDRESS        0x06	//$$ EARLIER NAMED APCI3120_FIFO_ADDRESS
-#define APCI3120_RESET_FIFO          0x0C	//(ADDRESS)
-#define APCI3120_TIMER_0_MODE_2      0x01	//$$ Bits for timer mode
+/* ANALOG OUTPUT AND INPUT DEFINE */
+#define APCI3120_UNIPOLAR 0x80	/* $$ RAM sequence polarity BIT */
+#define APCI3120_BIPOLAR  0x00	/* $$ RAM sequence polarity BIT */
+#define APCI3120_ANALOG_OUTPUT_1 0x08	/*  (ADDRESS ) */
+#define APCI3120_ANALOG_OUTPUT_2 0x0A	/*  (ADDRESS ) */
+#define APCI3120_1_GAIN              0x00	/* $$ RAM sequence Gain Bits for gain 1 */
+#define APCI3120_2_GAIN              0x10	/* $$ RAM sequence Gain Bits for gain 2 */
+#define APCI3120_5_GAIN              0x20	/* $$ RAM sequence Gain Bits for gain 5 */
+#define APCI3120_10_GAIN             0x30	/* $$ RAM sequence Gain Bits for gain 10 */
+#define APCI3120_SEQ_RAM_ADDRESS        0x06	/* $$ EARLIER NAMED APCI3120_FIFO_ADDRESS */
+#define APCI3120_RESET_FIFO          0x0C	/* (ADDRESS) */
+#define APCI3120_TIMER_0_MODE_2      0x01	/* $$ Bits for timer mode */
 #define APCI3120_TIMER_0_MODE_4       0x2
 #define APCI3120_SELECT_TIMER_0_WORD 0x00
-#define APCI3120_ENABLE_TIMER0     0x1000	//$$Gatebit 0 in nWrAddress
+#define APCI3120_ENABLE_TIMER0     0x1000	/* $$Gatebit 0 in nWrAddress */
 #define APCI3120_CLEAR_PR          0xF0FF
 #define APCI3120_CLEAR_PA          0xFFF0
 #define APCI3120_CLEAR_PA_PR       (APCI3120_CLEAR_PR & APCI3120_CLEAR_PA)
 
-// nWrMode_Select
-#define APCI3120_ENABLE_SCAN          0x8	//$$ bit in nWrMode_Select
+/* nWrMode_Select */
+#define APCI3120_ENABLE_SCAN          0x8	/* $$ bit in nWrMode_Select */
 #define APCI3120_DISABLE_SCAN      (~APCI3120_ENABLE_SCAN)
-#define APCI3120_ENABLE_EOS_INT       0x2	//$$ bit in nWrMode_Select
+#define APCI3120_ENABLE_EOS_INT       0x2	/* $$ bit in nWrMode_Select */
 
 #define APCI3120_DISABLE_EOS_INT   (~APCI3120_ENABLE_EOS_INT)
 #define APCI3120_ENABLE_EOC_INT       0x1
@@ -108,50 +108,50 @@ static const struct comedi_lrange range_
 #define APCI3120_DISABLE_ALL_INTERRUPT_WITHOUT_TIMER   (APCI3120_DISABLE_EOS_INT & APCI3120_DISABLE_EOC_INT)
 #define APCI3120_DISABLE_ALL_INTERRUPT   (APCI3120_DISABLE_TIMER_INT & APCI3120_DISABLE_EOS_INT & APCI3120_DISABLE_EOC_INT)
 
-//status register bits
+/* status register bits */
 #define APCI3120_EOC                     0x8000
 #define APCI3120_EOS                     0x2000
 
-// software trigger dummy register
-#define APCI3120_START_CONVERSION        0x02	//(ADDRESS)
+/* software trigger dummy register */
+#define APCI3120_START_CONVERSION        0x02	/* (ADDRESS) */
 
-//TIMER DEFINE
+/* TIMER DEFINE */
 #define APCI3120_QUARTZ_A				  70
 #define APCI3120_QUARTZ_B				  50
 #define APCI3120_TIMER                            1
 #define APCI3120_WATCHDOG                         2
 #define APCI3120_TIMER_DISABLE                    0
 #define APCI3120_TIMER_ENABLE                     1
-#define APCI3120_ENABLE_TIMER2                    0x4000	//$$ gatebit 2 in nWrAddress
+#define APCI3120_ENABLE_TIMER2                    0x4000	/* $$ gatebit 2 in nWrAddress */
 #define APCI3120_DISABLE_TIMER2                   (~APCI3120_ENABLE_TIMER2)
-#define APCI3120_ENABLE_TIMER_INT                 0x04	//$$ ENAIRQ_FC_Bit in nWrModeSelect
+#define APCI3120_ENABLE_TIMER_INT                 0x04	/* $$ ENAIRQ_FC_Bit in nWrModeSelect */
 #define APCI3120_DISABLE_TIMER_INT                (~APCI3120_ENABLE_TIMER_INT)
-#define APCI3120_WRITE_MODE_SELECT                0x0E	// (ADDRESS)
+#define APCI3120_WRITE_MODE_SELECT                0x0E	/*  (ADDRESS) */
 #define APCI3120_SELECT_TIMER_0_WORD  0x00
 #define APCI3120_SELECT_TIMER_1_WORD  0x01
 #define APCI3120_TIMER_1_MODE_2       0x4
 
-//$$ BIT FOR MODE IN nCsTimerCtr1
+/* $$ BIT FOR MODE IN nCsTimerCtr1 */
 #define APCI3120_TIMER_2_MODE_0                   0x0
 #define APCI3120_TIMER_2_MODE_2                   0x10
 #define APCI3120_TIMER_2_MODE_5                   0x30
 
-//$$ BIT FOR MODE IN nCsTimerCtr0
+/* $$ BIT FOR MODE IN nCsTimerCtr0 */
 #define APCI3120_SELECT_TIMER_2_LOW_WORD          0x02
 #define APCI3120_SELECT_TIMER_2_HIGH_WORD         0x03
 
-#define APCI3120_TIMER_CRT0                       0x0D	//(ADDRESS for cCsTimerCtr0)
-#define APCI3120_TIMER_CRT1                       0x0C	//(ADDRESS for cCsTimerCtr1)
+#define APCI3120_TIMER_CRT0                       0x0D	/* (ADDRESS for cCsTimerCtr0) */
+#define APCI3120_TIMER_CRT1                       0x0C	/* (ADDRESS for cCsTimerCtr1) */
 
-#define APCI3120_TIMER_VALUE                      0x04	//ADDRESS for nCsTimerWert
-#define APCI3120_TIMER_STATUS_REGISTER            0x0D	//ADDRESS for delete timer 2 interrupt
-#define APCI3120_RD_STATUS                        0x02	//ADDRESS
-#define APCI3120_WR_ADDRESS                       0x00	//ADDRESS
-#define APCI3120_ENABLE_WATCHDOG                  0x20	//$$BIT in nWrMode_Select
+#define APCI3120_TIMER_VALUE                      0x04	/* ADDRESS for nCsTimerWert */
+#define APCI3120_TIMER_STATUS_REGISTER            0x0D	/* ADDRESS for delete timer 2 interrupt */
+#define APCI3120_RD_STATUS                        0x02	/* ADDRESS */
+#define APCI3120_WR_ADDRESS                       0x00	/* ADDRESS */
+#define APCI3120_ENABLE_WATCHDOG                  0x20	/* $$BIT in nWrMode_Select */
 #define APCI3120_DISABLE_WATCHDOG                 (~APCI3120_ENABLE_WATCHDOG)
-#define APCI3120_ENABLE_TIMER_COUNTER    		  0x10	//$$BIT in nWrMode_Select
+#define APCI3120_ENABLE_TIMER_COUNTER    		  0x10	/* $$BIT in nWrMode_Select */
 #define APCI3120_DISABLE_TIMER_COUNTER            (~APCI3120_ENABLE_TIMER_COUNTER)
-#define APCI3120_FC_TIMER                         0x1000	//bit in  status register
+#define APCI3120_FC_TIMER                         0x1000	/* bit in  status register */
 #define APCI3120_ENABLE_TIMER0                    0x1000
 #define APCI3120_ENABLE_TIMER1                    0x2000
 #define APCI3120_ENABLE_TIMER2                    0x4000
@@ -159,9 +159,9 @@ static const struct comedi_lrange range_
 #define APCI3120_DISABLE_TIMER1		              (~APCI3120_ENABLE_TIMER1)
 #define APCI3120_DISABLE_TIMER2	                  (~APCI3120_ENABLE_TIMER2)
 
-#define APCI3120_TIMER2_SELECT_EOS                0xC0	// ADDED on 20-6
-#define APCI3120_COUNTER                          3	// on 20-6
-#define APCI3120_DISABLE_ALL_TIMER                ( APCI3120_DISABLE_TIMER0 & APCI3120_DISABLE_TIMER1 & APCI3120_DISABLE_TIMER2 )	// on 20-6
+#define APCI3120_TIMER2_SELECT_EOS                0xC0	/*  ADDED on 20-6 */
+#define APCI3120_COUNTER                          3	/*  on 20-6 */
+#define APCI3120_DISABLE_ALL_TIMER                ( APCI3120_DISABLE_TIMER0 & APCI3120_DISABLE_TIMER1 & APCI3120_DISABLE_TIMER2 )	/*  on 20-6 */
 
 #define MAX_ANALOGINPUT_CHANNELS    32
 
@@ -177,9 +177,9 @@ struct str_AnalogReadInformation {
 };
 
 
-// Function Declaration For APCI-3120
+/* Function Declaration For APCI-3120 */
 
-// Internal functions
+/* Internal functions */
 int i_APCI3120_SetupChannelList(struct comedi_device *dev, struct comedi_subdevice *s,
 				int n_chan, unsigned int *chanlist, char check);
 int i_APCI3120_ExttrigEnable(struct comedi_device *dev);
@@ -188,9 +188,9 @@ int i_APCI3120_StopCyclicAcquisition(str
 int i_APCI3120_Reset(struct comedi_device *dev);
 int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device *dev,
 				 struct comedi_subdevice *s);
-// Interrupt functions
+/* Interrupt functions */
 void v_APCI3120_Interrupt(int irq, void *d);
-//UPDATE-0.7.57->0.7.68 void v_APCI3120_InterruptDmaMoveBlock16bit(struct comedi_device *dev,struct comedi_subdevice *s,short *dma,short *data,int n);
+/* UPDATE-0.7.57->0.7.68 void v_APCI3120_InterruptDmaMoveBlock16bit(struct comedi_device *dev,struct comedi_subdevice *s,short *dma,short *data,int n); */
 void v_APCI3120_InterruptDmaMoveBlock16bit(struct comedi_device *dev,
 					   struct comedi_subdevice *s,
 					   short *dma_buffer,
@@ -198,7 +198,7 @@ void v_APCI3120_InterruptDmaMoveBlock16b
 int i_APCI3120_InterruptHandleEos(struct comedi_device *dev);
 void v_APCI3120_InterruptDma(int irq, void *d);
 
-// TIMER
+/* TIMER */
 
 int i_APCI3120_InsnConfigTimer(struct comedi_device *dev, struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data);
@@ -207,16 +207,19 @@ int i_APCI3120_InsnWriteTimer(struct com
 int i_APCI3120_InsnReadTimer(struct comedi_device *dev, struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data);
 
-//DI
-// for di read
+/*
+* DI for di read
+*/
 
 int i_APCI3120_InsnBitsDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				    struct comedi_insn *insn, unsigned int *data);
 int i_APCI3120_InsnReadDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				    struct comedi_insn *insn, unsigned int *data);
 
-//DO
-//int i_APCI3120_WriteDigitalOutput(struct comedi_device *dev, unsigned char data);
+/* DO */
+/* int i_APCI3120_WriteDigitalOutput(struct comedi_device *dev,
+ * unsigned char data);
+ */
 int i_APCI3120_InsnConfigDigitalOutput(struct comedi_device *dev,
 				       struct comedi_subdevice *s, struct comedi_insn *insn,
 				       unsigned int *data);
@@ -225,12 +228,15 @@ int i_APCI3120_InsnBitsDigitalOutput(str
 int i_APCI3120_InsnWriteDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				      struct comedi_insn *insn, unsigned int *data);
 
-//AO
-//int i_APCI3120_Write1AnalogValue(struct comedi_device *dev,UINT ui_Range,UINT ui_Channel,UINT data );
+/* AO */
+/* int i_APCI3120_Write1AnalogValue(struct comedi_device *dev,UINT ui_Range,
+ * UINT ui_Channel,UINT data );
+ */
+
 int i_APCI3120_InsnWriteAnalogOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				     struct comedi_insn *insn, unsigned int *data);
 
-//AI HArdware layer
+/* AI HArdware layer */
 
 int i_APCI3120_InsnConfigAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				     struct comedi_insn *insn, unsigned int *data);
@@ -239,5 +245,5 @@ int i_APCI3120_InsnReadAnalogInput(struc
 int i_APCI3120_CommandTestAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				      struct comedi_cmd *cmd);
 int i_APCI3120_CommandAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s);
-//int i_APCI3120_CancelAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s);
+/* int i_APCI3120_CancelAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s); */
 int i_APCI3120_StopCyclicAcquisition(struct comedi_device *dev, struct comedi_subdevice *s);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.h
@@ -15,9 +15,9 @@
  * any later version.
  */
 
-// Card Specific information
+/* Card Specific information */
 #define APCI3200_BOARD_VENDOR_ID                 0x15B8
-//#define APCI3200_ADDRESS_RANGE                   264
+/* #define APCI3200_ADDRESS_RANGE                   264 */
 
 int MODULE_NO;
 struct {
@@ -34,7 +34,7 @@ struct {
 } Config_Parameters_Module1, Config_Parameters_Module2,
     Config_Parameters_Module3, Config_Parameters_Module4;
 
-//ANALOG INPUT RANGE
+/* ANALOG INPUT RANGE */
 static const struct comedi_lrange range_apci3200_ai = { 8, {
 						     BIP_RANGE(10),
 						     BIP_RANGE(5),
@@ -55,7 +55,7 @@ static const struct comedi_lrange range_
 						     }
 };
 
-//Analog Input related Defines
+/* Analog Input related Defines */
 #define APCI3200_AI_OFFSET_GAIN                  0
 #define APCI3200_AI_SC_TEST                      4
 #define APCI3200_AI_IRQ                          8
@@ -89,9 +89,9 @@ static const struct comedi_lrange range_
 #define ADDIDATA_UNIPOLAR                        1
 #define ADDIDATA_BIPOLAR                         2
 
-//BEGIN JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+/* BEGIN JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 #define MAX_MODULE				4
-//END JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+/* END JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
 struct str_ADDIDATA_RTDStruct {
 	unsigned int ul_NumberOfValue;
@@ -99,23 +99,23 @@ struct str_ADDIDATA_RTDStruct {
 	unsigned int *pul_TemperatureValue;
 };
 
-//BEGIN JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+/* BEGIN JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 struct str_Module {
 
-	// Begin JK 05/08/2003 change for Linux
+	/*  Begin JK 05/08/2003 change for Linux */
 	unsigned long ul_CurrentSourceCJC;
 	unsigned long ul_CurrentSource[5];
-	// End JK 05/08/2003 change for Linux
+	/*  End JK 05/08/2003 change for Linux */
 
-	// Begin CG 15/02/02 Rev 1.0 -> Rev 1.1 : Add Header Type 1
-	unsigned long ul_GainFactor[8];	// Gain Factor
+	/*  Begin CG 15/02/02 Rev 1.0 -> Rev 1.1 : Add Header Type 1 */
+	unsigned long ul_GainFactor[8];	/*  Gain Factor */
 	unsigned int w_GainValue[10];
-	// End CG 15/02/02 Rev 1.0 -> Rev 1.1 : Add Header Type 1
+	/*  End CG 15/02/02 Rev 1.0 -> Rev 1.1 : Add Header Type 1 */
 };
 
-//END JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+/* END JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
-//BEGIN JK 06.07.04: Management of sevrals boards
+/* BEGIN JK 06.07.04: Management of sevrals boards */
 struct str_BoardInfos {
 
 	int i_CJCAvailable;
@@ -138,25 +138,25 @@ struct str_BoardInfos {
 	unsigned int ui_Channel_num;
 	int i_Count;
 	int i_Initialised;
-	//UINT ui_InterruptChannelValue[96]; //Buffer
-	unsigned int ui_InterruptChannelValue[144];	//Buffer
+	/* UINT ui_InterruptChannelValue[96]; //Buffer */
+	unsigned int ui_InterruptChannelValue[144];	/* Buffer */
 	unsigned char b_StructInitialized;
-	//Begin JK 19.10.2004: APCI-3200 Driver update 0.7.57 -> 0.7.68
-	unsigned int ui_ScanValueArray[7 + 12];	// 7 is the maximal number of channels
-	//End JK 19.10.2004: APCI-3200 Driver update 0.7.57 -> 0.7.68
+	/* Begin JK 19.10.2004: APCI-3200 Driver update 0.7.57 -> 0.7.68 */
+	unsigned int ui_ScanValueArray[7 + 12];	/*  7 is the maximal number of channels */
+	/* End JK 19.10.2004: APCI-3200 Driver update 0.7.57 -> 0.7.68 */
 
-	//Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+	/* Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 	int i_ConnectionType;
 	int i_NbrOfModule;
 	struct str_Module s_Module[MAX_MODULE];
-	//End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+	/* End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 };
 
-//END JK 06.07.04: Management of sevrals boards
+/* END JK 06.07.04: Management of sevrals boards */
 
-// Hardware Layer  functions for Apci3200
+/* Hardware Layer  functions for Apci3200 */
 
-//AI
+/* AI */
 
 int i_APCI3200_ConfigAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
@@ -175,10 +175,10 @@ int i_APCI3200_CommandTestAnalogInput(st
 int i_APCI3200_CommandAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s);
 int i_APCI3200_ReadDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data);
-//Interrupt
+/* Interrupt */
 void v_APCI3200_Interrupt(int irq, void *d);
 int i_APCI3200_InterruptHandleEos(struct comedi_device *dev);
-//Reset functions
+/* Reset functions */
 int i_APCI3200_Reset(struct comedi_device *dev);
 
 int i_APCI3200_ReadCJCCalOffset(struct comedi_device *dev, unsigned int *data);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3501.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3501.c
@@ -83,16 +83,16 @@ int i_APCI3501_ReadDigitalInput(struct c
 	*data = inl(devpriv->iobase + APCI3501_DIGITAL_IP);
 	if (ui_Temp == 0) {
 		*data = (*data >> ui_NoOfChannel) & 0x1;
-	}			//if  (ui_Temp==0)
+	}			/* if  (ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 
 			*data = *data & 0x3;
-		}		//if  (ui_Temp==1)
+		}		/* if  (ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		//elseif  (ui_Temp==1)
-	}			//elseif  (ui_Temp==0)
+		}		/* elseif  (ui_Temp==1) */
+	}			/* elseif  (ui_Temp==0) */
 	return insn->n;
 }
 
@@ -129,13 +129,13 @@ int i_APCI3501_ConfigDigitalOutput(struc
 		comedi_error(dev,
 			"Not a valid Data !!! ,Data should be 1 or 0\n");
 		return -EINVAL;
-	}			//if  ( (data[0]!=0) && (data[0]!=1) )
+	}			/* if  ( (data[0]!=0) && (data[0]!=1) ) */
 	if (data[0]) {
 		devpriv->b_OutputMemoryStatus = ADDIDATA_ENABLE;
-	}			// if  (data[0])
+	}			/*  if  (data[0]) */
 	else {
 		devpriv->b_OutputMemoryStatus = ADDIDATA_DISABLE;
-	}			//else if  (data[0])
+	}			/* else if  (data[0]) */
 	return insn->n;
 }
 
@@ -165,29 +165,29 @@ int i_APCI3501_WriteDigitalOutput(struct
 	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int ui_Temp, ui_Temp1;
-	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);	/*  get the channel */
 	if (devpriv->b_OutputMemoryStatus) {
 		ui_Temp = inl(devpriv->iobase + APCI3501_DIGITAL_OP);
-	}			//if(devpriv->b_OutputMemoryStatus )
+	}			/* if(devpriv->b_OutputMemoryStatus ) */
 	else {
 		ui_Temp = 0;
-	}			//if(devpriv->b_OutputMemoryStatus )
+	}			/* if(devpriv->b_OutputMemoryStatus ) */
 	if (data[3] == 0) {
 		if (data[1] == 0) {
 			data[0] = (data[0] << ui_NoOfChannel) | ui_Temp;
 			outl(data[0], devpriv->iobase + APCI3501_DIGITAL_OP);
-		}		//if(data[1]==0)
+		}		/* if(data[1]==0) */
 		else {
 			if (data[1] == 1) {
 				data[0] = (data[0] << (2 * data[2])) | ui_Temp;
 				outl(data[0],
 					devpriv->iobase + APCI3501_DIGITAL_OP);
-			}	// if(data[1]==1)
+			}	/*  if(data[1]==1) */
 			else {
 				printk("\nSpecified channel not supported\n");
-			}	//else if(data[1]==1)
-		}		//elseif(data[1]==0)
-	}			//if(data[3]==0)
+			}	/* else if(data[1]==1) */
+		}		/* elseif(data[1]==0) */
+	}			/* if(data[3]==0) */
 	else {
 		if (data[3] == 1) {
 			if (data[1] == 0) {
@@ -201,7 +201,7 @@ int i_APCI3501_WriteDigitalOutput(struct
 				data[0] = data[0] & ui_Temp;
 				outl(data[0],
 					devpriv->iobase + APCI3501_DIGITAL_OP);
-			}	//if(data[1]==0)
+			}	/* if(data[1]==0) */
 			else {
 				if (data[1] == 1) {
 					data[0] = ~data[0] & 0x3;
@@ -215,17 +215,17 @@ int i_APCI3501_WriteDigitalOutput(struct
 					outl(data[0],
 						devpriv->iobase +
 						APCI3501_DIGITAL_OP);
-				}	// if(data[1]==1)
+				}	/*  if(data[1]==1) */
 				else {
 					printk("\nSpecified channel not supported\n");
-				}	//else if(data[1]==1)
-			}	//elseif(data[1]==0)
-		}		//if(data[3]==1);
+				}	/* else if(data[1]==1) */
+			}	/* elseif(data[1]==0) */
+		}		/* if(data[3]==1); */
 		else {
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		//if else data[3]==1)
-	}			//if else data[3]==0)
+		}		/* if else data[3]==1) */
+	}			/* if else data[3]==0) */
 	return insn->n;
 }
 
@@ -259,16 +259,16 @@ int i_APCI3501_ReadDigitalOutput(struct 
 	*data = inl(devpriv->iobase + APCI3501_DIGITAL_OP);
 	if (ui_Temp == 0) {
 		*data = (*data >> ui_NoOfChannel) & 0x1;
-	}			// if  (ui_Temp==0)
+	}			/*  if  (ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 			*data = *data & 0x3;
 
-		}		// if  (ui_Temp==1)
+		}		/*  if  (ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		// else if (ui_Temp==1)
-	}			// else if  (ui_Temp==0)
+		}		/*  else if (ui_Temp==1) */
+	}			/*  else if  (ui_Temp==0) */
 	return insn->n;
 }
 
@@ -349,18 +349,18 @@ int i_APCI3501_WriteAnalogOutput(struct 
 			printk("\nIn WriteAnalogOutput :: Not Valid Data\n");
 		}
 
-	}			// end if(devpriv->b_InterruptMode==MODE1)
+	}			/*  end if(devpriv->b_InterruptMode==MODE1) */
 	else {
 		ul_Polarity = 0;
 		if ((*data < 0) || (*data > 8192)) {
 			printk("\nIn WriteAnalogOutput :: Not Valid Data\n");
 		}
 
-	}			// end else
+	}			/*  end else */
 
 	if ((ul_Channel_no < 0) || (ul_Channel_no > 7)) {
 		printk("\nIn WriteAnalogOutput :: Not Valid Channel\n");
-	}			// end if((ul_Channel_no<0)||(ul_Channel_no>7))
+	}			/*  end if((ul_Channel_no<0)||(ul_Channel_no>7)) */
 
 	ul_DAC_Ready = inl(devpriv->iobase + APCI3501_ANALOG_OUTPUT);
 
@@ -370,7 +370,7 @@ int i_APCI3501_WriteAnalogOutput(struct 
 	}
 
 	if (ul_DAC_Ready) {
-// Output the Value on the output channels.
+/* Output the Value on the output channels. */
 		ul_Command1 =
 			(unsigned int) ((unsigned int) (ul_Channel_no & 0xFF) |
 			(unsigned int) ((*data << 0x8) & 0x7FFFFF00L) |
@@ -418,70 +418,70 @@ int i_APCI3501_ConfigTimerCounterWatchdo
 	if (data[0] == ADDIDATA_WATCHDOG) {
 
 		devpriv->b_TimerSelectMode = ADDIDATA_WATCHDOG;
-		//Disable the watchdog
-		outl(0x0, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	//disable Wa
+		/* Disable the watchdog */
+		outl(0x0, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	/* disable Wa */
 
 		if (data[1] == 1) {
-			//Enable TIMER int & DISABLE ALL THE OTHER int SOURCES
+			/* Enable TIMER int & DISABLE ALL THE OTHER int SOURCES */
 			outl(0x02,
 				devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
 		} else {
-			outl(0x0, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	//disable Timer interrupt
+			outl(0x0, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	/* disable Timer interrupt */
 		}
 
-		//Loading the Timebase value
+		/* Loading the Timebase value */
 		outl(data[2],
 			devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_TIMEBASE);
 
-		//Loading the Reload value
+		/* Loading the Reload value */
 		outl(data[3],
 			devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_RELOAD_VALUE);
-		//Set the mode
-		ul_Command1 = inl(devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG) | 0xFFF819E0UL;	//e2->e0
+		/* Set the mode */
+		ul_Command1 = inl(devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG) | 0xFFF819E0UL;	/* e2->e0 */
 		outl(ul_Command1,
 			devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_PROG);
-	}			//end if(data[0]==ADDIDATA_WATCHDOG)
+	}			/* end if(data[0]==ADDIDATA_WATCHDOG) */
 
 	else if (data[0] == ADDIDATA_TIMER) {
-		//First Stop The Timer
+		/* First Stop The Timer */
 		ul_Command1 =
 			inl(devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_PROG);
 		ul_Command1 = ul_Command1 & 0xFFFFF9FEUL;
-		outl(ul_Command1, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	//Stop The Timer
+		outl(ul_Command1, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	/* Stop The Timer */
 		devpriv->b_TimerSelectMode = ADDIDATA_TIMER;
 		if (data[1] == 1) {
-			//Enable TIMER int & DISABLE ALL THE OTHER int SOURCES
+			/* Enable TIMER int & DISABLE ALL THE OTHER int SOURCES */
 			outl(0x02,
 				devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
 		} else {
-			outl(0x0, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	//disable Timer interrupt
+			outl(0x0, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	/* disable Timer interrupt */
 		}
 
-		// Loading Timebase
+		/*  Loading Timebase */
 		outl(data[2],
 			devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_TIMEBASE);
 
-		//Loading the Reload value
+		/* Loading the Reload value */
 		outl(data[3],
 			devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_RELOAD_VALUE);
 
-		// printk ("\nTimer Address :: %x\n", (devpriv->iobase+APCI3501_WATCHDOG));
+		/*  printk ("\nTimer Address :: %x\n", (devpriv->iobase+APCI3501_WATCHDOG)); */
 		ul_Command1 =
 			inl(devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_PROG);
 		ul_Command1 =
 			(ul_Command1 & 0xFFF719E2UL) | 2UL << 13UL | 0x10UL;
-		outl(ul_Command1, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	//mode 2
+		outl(ul_Command1, devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);	/* mode 2 */
 
-	}			//end if(data[0]==ADDIDATA_TIMER)
+	}			/* end if(data[0]==ADDIDATA_TIMER) */
 
 	return insn->n;
 }
@@ -523,15 +523,15 @@ int i_APCI3501_StartStopWriteTimerCounte
 				inl(devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
 			ul_Command1 = (ul_Command1 & 0xFFFFF9FFUL) | 0x1UL;
-			//Enable the Watchdog
+			/* Enable the Watchdog */
 			outl(ul_Command1,
 				devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
 		}
 
-		else if (data[1] == 0)	//Stop The Watchdog
+		else if (data[1] == 0)	/* Stop The Watchdog */
 		{
-			//Stop The Watchdog
+			/* Stop The Watchdog */
 			ul_Command1 =
 				inl(devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
@@ -547,8 +547,8 @@ int i_APCI3501_StartStopWriteTimerCounte
 			outl(ul_Command1,
 				devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
-		}		//if(data[1]==2)
-	}			// end if (devpriv->b_TimerSelectMode==ADDIDATA_WATCHDOG)
+		}		/* if(data[1]==2) */
+	}			/*  end if (devpriv->b_TimerSelectMode==ADDIDATA_WATCHDOG) */
 
 	if (devpriv->b_TimerSelectMode == ADDIDATA_TIMER) {
 		if (data[1] == 1) {
@@ -557,12 +557,12 @@ int i_APCI3501_StartStopWriteTimerCounte
 				inl(devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
 			ul_Command1 = (ul_Command1 & 0xFFFFF9FFUL) | 0x1UL;
-			//Enable the Timer
+			/* Enable the Timer */
 			outl(ul_Command1,
 				devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
 		} else if (data[1] == 0) {
-			//Stop The Timer
+			/* Stop The Timer */
 			ul_Command1 =
 				inl(devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
@@ -573,7 +573,7 @@ int i_APCI3501_StartStopWriteTimerCounte
 		}
 
 		else if (data[1] == 2) {
-			//Trigger the Timer
+			/* Trigger the Timer */
 			ul_Command1 =
 				inl(devpriv->iobase + APCI3501_WATCHDOG +
 				APCI3501_TCW_PROG);
@@ -583,7 +583,7 @@ int i_APCI3501_StartStopWriteTimerCounte
 				APCI3501_TCW_PROG);
 		}
 
-	}			// end if (devpriv->b_TimerSelectMode==ADDIDATA_TIMER)
+	}			/*  end if (devpriv->b_TimerSelectMode==ADDIDATA_TIMER) */
 	i_Temp = inl(devpriv->iobase + APCI3501_WATCHDOG +
 		APCI3501_TCW_TRIG_STATUS) & 0x1;
 	return insn->n;
@@ -622,14 +622,14 @@ int i_APCI3501_ReadTimerCounterWatchdog(
 			inl(devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_TRIG_STATUS) & 0x1;
 		data[1] = inl(devpriv->iobase + APCI3501_WATCHDOG);
-	}			// end if  (devpriv->b_TimerSelectMode==ADDIDATA_WATCHDOG)
+	}			/*  end if  (devpriv->b_TimerSelectMode==ADDIDATA_WATCHDOG) */
 
 	else if (devpriv->b_TimerSelectMode == ADDIDATA_TIMER) {
 		data[0] =
 			inl(devpriv->iobase + APCI3501_WATCHDOG +
 			APCI3501_TCW_TRIG_STATUS) & 0x1;
 		data[1] = inl(devpriv->iobase + APCI3501_WATCHDOG);
-	}			// end if  (devpriv->b_TimerSelectMode==ADDIDATA_TIMER)
+	}			/*  end if  (devpriv->b_TimerSelectMode==ADDIDATA_TIMER) */
 
 	else if ((devpriv->b_TimerSelectMode != ADDIDATA_TIMER)
 		&& (devpriv->b_TimerSelectMode != ADDIDATA_WATCHDOG)) {
@@ -674,7 +674,7 @@ int i_APCI3501_Reset(struct comedi_devic
 		}
 
 		if (ul_DAC_Ready) {
-			// Output the Value on the output channels.
+			/*  Output the Value on the output channels. */
 			ul_Command1 =
 				(unsigned int) ((unsigned int) (i_Count & 0xFF) |
 				(unsigned int) ((i_temp << 0x8) & 0x7FFFFF00L) |
@@ -711,7 +711,7 @@ void v_APCI3501_Interrupt(int irq, void 
 	struct comedi_device *dev = d;
 	unsigned int ui_Timer_AOWatchdog;
 	unsigned long ul_Command1;
-	// Disable Interrupt
+	/*  Disable Interrupt */
 	ul_Command1 =
 		inl(devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);
 
@@ -728,8 +728,9 @@ void v_APCI3501_Interrupt(int irq, void 
 		return;
 	}
 
-	// Enable Interrupt
-	//Send a signal to from kernel to user space
+/*
+* Enable Interrupt Send a signal to from kernel to user space
+*/
 	send_sig(SIGIO, devpriv->tsk_Current, 0);
 	ul_Command1 =
 		inl(devpriv->iobase + APCI3501_WATCHDOG + APCI3501_TCW_PROG);
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3501.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3501.h
@@ -15,7 +15,7 @@
  * any later version.
  */
 
-// Card Specific information
+/* Card Specific information */
 #define APCI3501_BOARD_VENDOR_ID                 0x15B8
 #define APCI3501_ADDRESS_RANGE                   255
 
@@ -23,7 +23,7 @@
 #define APCI3501_DIGITAL_OP                       0x40
 #define APCI3501_ANALOG_OUTPUT                    0x00
 
-//Analog Output related Defines
+/* Analog Output related Defines */
 #define APCI3501_AO_VOLT_MODE                     0
 #define APCI3501_AO_PROG                          4
 #define APCI3501_AO_TRIG_SCS                      8
@@ -31,14 +31,14 @@
 #define BIPOLAR                                   1
 #define MODE0                                     0
 #define MODE1                                     1
-// ANALOG OUTPUT RANGE
+/* ANALOG OUTPUT RANGE */
 struct comedi_lrange range_apci3501_ao = { 2, {
 					BIP_RANGE(10),
 					UNI_RANGE(10)
 					}
 };
 
-//Watchdog Related Defines
+/* Watchdog Related Defines */
 
 #define APCI3501_WATCHDOG                         0x20
 #define APCI3501_TCW_SYNC_ENABLEDISABLE           0
@@ -52,22 +52,24 @@ struct comedi_lrange range_apci3501_ao =
 #define ADDIDATA_TIMER                            0
 #define ADDIDATA_WATCHDOG                         2
 
-// Hardware Layer  functions for Apci3501
+/* Hardware Layer  functions for Apci3501 */
 
-//AO
+/* AO */
 int i_APCI3501_ConfigAnalogOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data);
 int i_APCI3501_WriteAnalogOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
 
-//DI
-// for di read
-//INT i_APCI3501_ReadDigitalInput(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data);
+/*
+* DI for di read INT i_APCI3501_ReadDigitalInput(struct
+* comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn
+* *insn,unsigned int *data);
+*/
 
 int i_APCI3501_ReadDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data);
 
-//DO
+/* DO */
 int i_APCI3501_ConfigDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data);
 int i_APCI3501_WriteDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -75,8 +77,10 @@ int i_APCI3501_WriteDigitalOutput(struct
 int i_APCI3501_ReadDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data);
 
-// TIMER
-// timer value is passed as u seconds
+/* TIMER
+ * timer value is passed as u seconds
+ */
+
 int i_APCI3501_ConfigTimerCounterWatchdog(struct comedi_device *dev,
 					  struct comedi_subdevice *s,
 					  struct comedi_insn *insn, unsigned int *data);
@@ -87,8 +91,8 @@ int i_APCI3501_StartStopWriteTimerCounte
 int i_APCI3501_ReadTimerCounterWatchdog(struct comedi_device *dev,
 					struct comedi_subdevice *s,
 					struct comedi_insn *insn, unsigned int *data);
-//Interrupt
+/* Interrupt */
 void v_APCI3501_Interrupt(int irq, void *d);
 
-//Reset functions
+/* Reset functions */
 int i_APCI3501_Reset(struct comedi_device *dev);
--- a/drivers/staging/comedi/drivers/adl_pci7296.c
+++ b/drivers/staging/comedi/drivers/adl_pci7296.c
@@ -39,7 +39,7 @@ Configuration Options:
 
 #include "comedi_pci.h"
 #include "8255.h"
-// #include "8253.h"
+/* #include "8253.h" */
 
 #define PORT1A 0
 #define PORT2A 4
@@ -115,7 +115,7 @@ static int adl_pci7296_attach(struct com
 			dev->iobase = pci_resource_start(pcidev, 2);
 			printk("comedi: base addr %4lx\n", dev->iobase);
 
-			// four 8255 digital io subdevices
+			/*  four 8255 digital io subdevices */
 			s = dev->subdevices + 0;
 			subdev_8255_init(dev, s, NULL,
 				(unsigned long)(dev->iobase));
@@ -159,7 +159,7 @@ static int adl_pci7296_detach(struct com
 		}
 		pci_dev_put(devpriv->pci_dev);
 	}
-	// detach four 8255 digital io subdevices
+	/*  detach four 8255 digital io subdevices */
 	if (dev->subdevices) {
 		subdev_8255_cleanup(dev, dev->subdevices + 0);
 		subdev_8255_cleanup(dev, dev->subdevices + 1);
--- a/drivers/staging/comedi/drivers/adl_pci8164.c
+++ b/drivers/staging/comedi/drivers/adl_pci8164.c
@@ -149,7 +149,7 @@ static int adl_pci8164_attach(struct com
 			s->n_chan = 4;
 			s->maxdata = 0xffff;
 			s->len_chanlist = 4;
-			//s->range_table = &range_axis;
+			/* s->range_table = &range_axis; */
 			s->insn_read = adl_pci8164_insn_read_msts;
 			s->insn_write = adl_pci8164_insn_write_cmd;
 
@@ -159,7 +159,7 @@ static int adl_pci8164_attach(struct com
 			s->n_chan = 4;
 			s->maxdata = 0xffff;
 			s->len_chanlist = 4;
-			//s->range_table = &range_axis;
+			/* s->range_table = &range_axis; */
 			s->insn_read = adl_pci8164_insn_read_ssts;
 			s->insn_write = adl_pci8164_insn_write_otp;
 
@@ -169,7 +169,7 @@ static int adl_pci8164_attach(struct com
 			s->n_chan = 4;
 			s->maxdata = 0xffff;
 			s->len_chanlist = 4;
-			//s->range_table = &range_axis;
+			/* s->range_table = &range_axis; */
 			s->insn_read = adl_pci8164_insn_read_buf0;
 			s->insn_write = adl_pci8164_insn_write_buf0;
 
@@ -179,7 +179,7 @@ static int adl_pci8164_attach(struct com
 			s->n_chan = 4;
 			s->maxdata = 0xffff;
 			s->len_chanlist = 4;
-			//s->range_table = &range_axis;
+			/* s->range_table = &range_axis; */
 			s->insn_read = adl_pci8164_insn_read_buf1;
 			s->insn_write = adl_pci8164_insn_write_buf1;
 
--- a/drivers/staging/comedi/drivers/adv_pci1710.c
+++ b/drivers/staging/comedi/drivers/adv_pci1710.c
@@ -63,7 +63,7 @@ Configuration options:
 #define DPRINTK(fmt, args...)
 #endif
 
-// hardware types of the cards
+/* hardware types of the cards */
 #define TYPE_PCI171X	0
 #define TYPE_PCI1713	2
 #define TYPE_PCI1720	3
@@ -89,12 +89,12 @@ Configuration options:
 #define PCI171x_CNT2	28	/* R/W: 8254 couter 2 */
 #define PCI171x_CNTCTRL	30	/* W:   8254 counter control */
 
-// upper bits from status register (PCI171x_STATUS) (lower is same woth control reg)
+/* upper bits from status register (PCI171x_STATUS) (lower is same woth control reg) */
 #define	Status_FE	0x0100	/* 1=FIFO is empty */
 #define Status_FH	0x0200	/* 1=FIFO is half full */
 #define Status_FF	0x0400	/* 1=FIFO is full, fatal error */
 #define Status_IRQ	0x0800	/* 1=IRQ occured */
-// bits from control register (PCI171x_CONTROL)
+/* bits from control register (PCI171x_CONTROL) */
 #define Control_CNT0	0x0040	/* 1=CNT0 have external source, 0=have internal 100kHz source */
 #define Control_ONEFH	0x0020	/* 1=IRQ on FIFO is half full, 0=every sample */
 #define Control_IRQEN	0x0010	/* 1=enable IRQ */
@@ -102,7 +102,7 @@ Configuration options:
 #define Control_EXT	0x0004	/* 1=external trigger source */
 #define Control_PACER	0x0002	/* 1=enable internal 8254 trigger source */
 #define Control_SW	0x0001	/* 1=enable software trigger source */
-// bits from counter control register (PCI171x_CNTCTRL)
+/* bits from counter control register (PCI171x_CNTCTRL) */
 #define Counter_BCD     0x0001	/* 0 = binary counter, 1 = BCD counter */
 #define Counter_M0      0x0002	/* M0-M2 select modes 0-5 */
 #define Counter_M1      0x0004	/* 000 = mode 0, 010 = mode 2 ... */
@@ -120,7 +120,7 @@ Configuration options:
 #define PCI1720_SYNCOUT	 9	/* W:   D/A synchronized output register */
 #define PCI1720_SYNCONT	15	/* R/W: D/A synchronized control */
 
-// D/A synchronized control (PCI1720_SYNCONT)
+/* D/A synchronized control (PCI1720_SYNCONT) */
 #define Syncont_SC0	 1	/* set synchronous output mode */
 
 static const struct comedi_lrange range_pci1710_3 = { 9, {
@@ -188,24 +188,24 @@ static int pci1710_attach(struct comedi_
 static int pci1710_detach(struct comedi_device * dev);
 
 struct boardtype {
-	const char *name;	// board name
+	const char *name;	/*  board name */
 	int device_id;
-	int iorange;		// I/O range len
-	char have_irq;		// 1=card support IRQ
-	char cardtype;		// 0=1710& co. 2=1713, ...
-	int n_aichan;		// num of A/D chans
-	int n_aichand;		// num of A/D chans in diff mode
-	int n_aochan;		// num of D/A chans
-	int n_dichan;		// num of DI chans
-	int n_dochan;		// num of DO chans
-	int n_counter;		// num of counters
-	int ai_maxdata;		// resolution of A/D
-	int ao_maxdata;		// resolution of D/A
-	const struct comedi_lrange *rangelist_ai;	// rangelist for A/D
-	const char *rangecode_ai;	// range codes for programming
-	const struct comedi_lrange *rangelist_ao;	// rangelist for D/A
-	unsigned int ai_ns_min;	// max sample speed of card v ns
-	unsigned int fifo_half_size;	// size of FIFO/2
+	int iorange;		/*  I/O range len */
+	char have_irq;		/*  1=card support IRQ */
+	char cardtype;		/*  0=1710& co. 2=1713, ... */
+	int n_aichan;		/*  num of A/D chans */
+	int n_aichand;		/*  num of A/D chans in diff mode */
+	int n_aochan;		/*  num of D/A chans */
+	int n_dichan;		/*  num of DI chans */
+	int n_dochan;		/*  num of DO chans */
+	int n_counter;		/*  num of counters */
+	int ai_maxdata;		/*  resolution of A/D */
+	int ao_maxdata;		/*  resolution of D/A */
+	const struct comedi_lrange *rangelist_ai;	/*  rangelist for A/D */
+	const char *rangecode_ai;	/*  range codes for programming */
+	const struct comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
+	unsigned int ai_ns_min;	/*  max sample speed of card v ns */
+	unsigned int fifo_half_size;	/*  size of FIFO/2 */
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci1710_pci_table) = {
@@ -252,7 +252,7 @@ static const struct boardtype boardtypes
 		16, 0, 0, 16, 16, 0, 0x0fff, 0x0000,
 		&range_pci17x1, range_codes_pci17x1, NULL,
 		10000, 512},
-	// dummy entry corresponding to driver name
+	/*  dummy entry corresponding to driver name */
 	{.name = DRV_NAME},
 };
 
@@ -269,34 +269,34 @@ static struct comedi_driver driver_pci17
 };
 
 struct pci1710_private {
-	struct pci_dev *pcidev;	// ptr to PCI device
-	char valid;		// card is usable
-	char neverending_ai;	// we do unlimited AI
-	unsigned int CntrlReg;	// Control register
-	unsigned int i8254_osc_base;	// frequence of onboard oscilator
-	unsigned int ai_do;	// what do AI? 0=nothing, 1 to 4 mode
-	unsigned int ai_act_scan;	// how many scans we finished
-	unsigned int ai_act_chan;	// actual position in actual scan
-	unsigned int ai_buf_ptr;	// data buffer ptr in samples
-	unsigned char ai_eos;	// 1=EOS wake up
+	struct pci_dev *pcidev;	/*  ptr to PCI device */
+	char valid;		/*  card is usable */
+	char neverending_ai;	/*  we do unlimited AI */
+	unsigned int CntrlReg;	/*  Control register */
+	unsigned int i8254_osc_base;	/*  frequence of onboard oscilator */
+	unsigned int ai_do;	/*  what do AI? 0=nothing, 1 to 4 mode */
+	unsigned int ai_act_scan;	/*  how many scans we finished */
+	unsigned int ai_act_chan;	/*  actual position in actual scan */
+	unsigned int ai_buf_ptr;	/*  data buffer ptr in samples */
+	unsigned char ai_eos;	/*  1=EOS wake up */
 	unsigned char ai_et;
 	unsigned int ai_et_CntrlReg;
 	unsigned int ai_et_MuxVal;
 	unsigned int ai_et_div1, ai_et_div2;
-	unsigned int act_chanlist[32];	// list of scaned channel
-	unsigned char act_chanlist_len;	// len of scanlist
-	unsigned char act_chanlist_pos;	// actual position in MUX list
-	unsigned char da_ranges;	// copy of D/A outpit range register
-	unsigned int ai_scans;	// len of scanlist
-	unsigned int ai_n_chan;	// how many channels is measured
-	unsigned int *ai_chanlist;	// actaul chanlist
-	unsigned int ai_flags;	// flaglist
-	unsigned int ai_data_len;	// len of data buffer
-	short *ai_data;	// data buffer
-	unsigned int ai_timer1;	// timers
+	unsigned int act_chanlist[32];	/*  list of scaned channel */
+	unsigned char act_chanlist_len;	/*  len of scanlist */
+	unsigned char act_chanlist_pos;	/*  actual position in MUX list */
+	unsigned char da_ranges;	/*  copy of D/A outpit range register */
+	unsigned int ai_scans;	/*  len of scanlist */
+	unsigned int ai_n_chan;	/*  how many channels is measured */
+	unsigned int *ai_chanlist;	/*  actaul chanlist */
+	unsigned int ai_flags;	/*  flaglist */
+	unsigned int ai_data_len;	/*  len of data buffer */
+	short *ai_data;	/*  data buffer */
+	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
-	short ao_data[4];	// data output buffer
-	unsigned int cnt0_write_wait;	// after a write, wait for update of the internal state
+	short ao_data[4];	/*  data output buffer */
+	unsigned int cnt0_write_wait;	/*  after a write, wait for update of the internal state */
 };
 
 #define devpriv ((struct pci1710_private *)dev->private)
@@ -315,7 +315,7 @@ static void start_pacer(struct comedi_de
 static int pci1710_reset(struct comedi_device * dev);
 static int pci171x_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 
-static const unsigned int muxonechan[] = { 0x0000, 0x0101, 0x0202, 0x0303, 0x0404, 0x0505, 0x0606, 0x0707,	// used for gain list programming
+static const unsigned int muxonechan[] = { 0x0000, 0x0101, 0x0202, 0x0303, 0x0404, 0x0505, 0x0606, 0x0707,	/*  used for gain list programming */
 	0x0808, 0x0909, 0x0a0a, 0x0b0b, 0x0c0c, 0x0d0d, 0x0e0e, 0x0f0f,
 	0x1010, 0x1111, 0x1212, 0x1313, 0x1414, 0x1515, 0x1616, 0x1717,
 	0x1818, 0x1919, 0x1a1a, 0x1b1b, 0x1c1c, 0x1d1d, 0x1e1e, 0x1f1f
@@ -334,7 +334,7 @@ static int pci171x_insn_read_ai(struct c
 
 	DPRINTK("adv_pci1710 EDBG: BGN: pci171x_insn_read_ai(...)\n");
 	devpriv->CntrlReg &= Control_CNT0;
-	devpriv->CntrlReg |= Control_SW;	// set software trigger
+	devpriv->CntrlReg |= Control_SW;	/*  set software trigger */
 	outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);
 	outb(0, dev->iobase + PCI171x_CLRFIFO);
 	outb(0, dev->iobase + PCI171x_CLRINT);
@@ -348,7 +348,7 @@ static int pci171x_insn_read_ai(struct c
 		outw(0, dev->iobase + PCI171x_SOFTTRG);	/* start conversion */
 		DPRINTK("adv_pci1710 B n=%d ST=%4x\n", n,
 			inw(dev->iobase + PCI171x_STATUS));
-		//comedi_udelay(1);
+		/* comedi_udelay(1); */
 		DPRINTK("adv_pci1710 C n=%d ST=%4x\n", n,
 			inw(dev->iobase + PCI171x_STATUS));
 		timeout = 100;
@@ -565,7 +565,7 @@ static int pci1720_insn_write_ao(struct 
 
 	for (n = 0; n < insn->n; n++) {
 		outw(data[n], dev->iobase + PCI1720_DA0 + (chan << 1));
-		outb(0, dev->iobase + PCI1720_SYNCOUT);	// update outputs
+		outb(0, dev->iobase + PCI1720_SYNCOUT);	/*  update outputs */
 	}
 
 	devpriv->ao_data[chan] = data[n];
@@ -604,7 +604,7 @@ static void interrupt_pci1710_every_samp
 		return;
 	}
 
-	outb(0, dev->iobase + PCI171x_CLRINT);	// clear our INT request
+	outb(0, dev->iobase + PCI171x_CLRINT);	/*  clear our INT request */
 
 	DPRINTK("FOR ");
 	for (; !(inw(dev->iobase + PCI171x_STATUS) & Status_FE);) {
@@ -639,11 +639,11 @@ static void interrupt_pci1710_every_samp
 			s->async->cur_chan = 0;
 		}
 
-		if (s->async->cur_chan == 0) {	// one scan done
+		if (s->async->cur_chan == 0) {	/*  one scan done */
 			devpriv->ai_act_scan++;
 			DPRINTK("adv_pci1710 EDBG: EOS1 bic %d bip %d buc %d bup %d\n", s->async->buf_int_count, s->async->buf_int_ptr, s->async->buf_user_count, s->async->buf_user_ptr);
 			DPRINTK("adv_pci1710 EDBG: EOS2\n");
-			if ((!devpriv->neverending_ai) && (devpriv->ai_act_scan >= devpriv->ai_scans)) {	// all data sampled
+			if ((!devpriv->neverending_ai) && (devpriv->ai_act_scan >= devpriv->ai_scans)) {	/*  all data sampled */
 				pci171x_ai_cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
@@ -652,7 +652,7 @@ static void interrupt_pci1710_every_samp
 		}
 	}
 
-	outb(0, dev->iobase + PCI171x_CLRINT);	// clear our INT request
+	outb(0, dev->iobase + PCI171x_CLRINT);	/*  clear our INT request */
 	DPRINTK("adv_pci1710 EDBG: END: interrupt_pci1710_every_sample(...)\n");
 
 	comedi_event(dev, s);
@@ -753,7 +753,7 @@ static void interrupt_pci1710_half_fifo(
 			comedi_event(dev, s);
 			return;
 		}
-	outb(0, dev->iobase + PCI171x_CLRINT);	// clear our INT request
+	outb(0, dev->iobase + PCI171x_CLRINT);	/*  clear our INT request */
 	DPRINTK("adv_pci1710 EDBG: END: interrupt_pci1710_half_fifo(...)\n");
 
 	comedi_event(dev, s);
@@ -768,30 +768,30 @@ static irqreturn_t interrupt_service_pci
 
 	DPRINTK("adv_pci1710 EDBG: BGN: interrupt_service_pci1710(%d,...)\n",
 		irq);
-	if (!dev->attached)	// is device attached?
-		return IRQ_NONE;	// no, exit
+	if (!dev->attached)	/*  is device attached? */
+		return IRQ_NONE;	/*  no, exit */
 
-	if (!(inw(dev->iobase + PCI171x_STATUS) & Status_IRQ))	// is this interrupt from our board?
-		return IRQ_NONE;	// no, exit
+	if (!(inw(dev->iobase + PCI171x_STATUS) & Status_IRQ))	/*  is this interrupt from our board? */
+		return IRQ_NONE;	/*  no, exit */
 
 	DPRINTK("adv_pci1710 EDBG: interrupt_service_pci1710() ST: %4x\n",
 		inw(dev->iobase + PCI171x_STATUS));
 
-	if (devpriv->ai_et) {	// Switch from initial TRIG_EXT to TRIG_xxx.
+	if (devpriv->ai_et) {	/*  Switch from initial TRIG_EXT to TRIG_xxx. */
 		devpriv->ai_et = 0;
 		devpriv->CntrlReg &= Control_CNT0;
-		devpriv->CntrlReg |= Control_SW;	// set software trigger
+		devpriv->CntrlReg |= Control_SW;	/*  set software trigger */
 		outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);
 		devpriv->CntrlReg = devpriv->ai_et_CntrlReg;
 		outb(0, dev->iobase + PCI171x_CLRFIFO);
 		outb(0, dev->iobase + PCI171x_CLRINT);
 		outw(devpriv->ai_et_MuxVal, dev->iobase + PCI171x_MUX);
 		outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);
-		// start pacer
+		/*  start pacer */
 		start_pacer(dev, 1, devpriv->ai_et_div1, devpriv->ai_et_div2);
 		return IRQ_HANDLED;
 	}
-	if (devpriv->ai_eos) {	// We use FIFO half full INT or not?
+	if (devpriv->ai_eos) {	/*  We use FIFO half full INT or not? */
 		interrupt_pci1710_every_sample(d);
 	} else {
 		interrupt_pci1710_half_fifo(d);
@@ -811,7 +811,7 @@ static int pci171x_ai_docmd_and_mode(int
 
 	DPRINTK("adv_pci1710 EDBG: BGN: pci171x_ai_docmd_and_mode(%d,...)\n",
 		mode);
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	seglen = check_channel_list(dev, s, devpriv->ai_chanlist,
 		devpriv->ai_n_chan);
@@ -831,7 +831,7 @@ static int pci171x_ai_docmd_and_mode(int
 	devpriv->neverending_ai = 0;
 
 	devpriv->CntrlReg &= Control_CNT0;
-	if ((devpriv->ai_flags & TRIG_WAKE_EOS)) {	// don't we want wake up every scan?            devpriv->ai_eos=1;
+	if ((devpriv->ai_flags & TRIG_WAKE_EOS)) {	/*  don't we want wake up every scan?            devpriv->ai_eos=1; */
 		devpriv->ai_eos = 1;
 	} else {
 		devpriv->CntrlReg |= Control_ONEFH;
@@ -840,7 +840,7 @@ static int pci171x_ai_docmd_and_mode(int
 
 	if ((devpriv->ai_scans == 0) || (devpriv->ai_scans == -1)) {
 		devpriv->neverending_ai = 1;
-	}			//well, user want neverending
+	}			/* well, user want neverending */
 	else {
 		devpriv->neverending_ai = 0;
 	}
@@ -865,7 +865,7 @@ static int pci171x_ai_docmd_and_mode(int
 		DPRINTK("adv_pci1710 EDBG: OSC base=%u div1=%u div2=%u timer=%u\n", devpriv->i8254_osc_base, divisor1, divisor2, devpriv->ai_timer1);
 		outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);
 		if (mode != 2) {
-			// start pacer
+			/*  start pacer */
 			start_pacer(dev, mode, divisor1, divisor2);
 		} else {
 			devpriv->ai_et_div1 = divisor1;
@@ -1057,7 +1057,7 @@ static int pci171x_ai_cmdtest(struct com
 	if (cmd->chanlist) {
 		if (!check_channel_list(dev, s, cmd->chanlist,
 				cmd->chanlist_len))
-			return 5;	// incorrect channels list
+			return 5;	/*  incorrect channels list */
 	}
 
 	DPRINTK("adv_pci1710 EDBG: BGN: pci171x_ai_cmdtest(...) ret=0\n");
@@ -1086,13 +1086,13 @@ static int pci171x_ai_cmd(struct comedi_
 		devpriv->ai_scans = 0;
 	}
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {	// mode 1, 2, 3
-		if (cmd->convert_src == TRIG_TIMER) {	// mode 1 and 2
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {	/*  mode 1, 2, 3 */
+		if (cmd->convert_src == TRIG_TIMER) {	/*  mode 1 and 2 */
 			devpriv->ai_timer1 = cmd->convert_arg;
 			return pci171x_ai_docmd_and_mode(cmd->start_src ==
 				TRIG_EXT ? 2 : 1, dev, s);
 		}
-		if (cmd->convert_src == TRIG_EXT) {	// mode 3
+		if (cmd->convert_src == TRIG_EXT) {	/*  mode 3 */
 			return pci171x_ai_docmd_and_mode(3, dev, s);
 		}
 	}
@@ -1120,12 +1120,12 @@ static int check_channel_list(struct com
 	}
 
 	if (n_chan > 1) {
-		chansegment[0] = chanlist[0];	// first channel is everytime ok
-		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {	// build part of chanlist
-			// rt_printk("%d. %d %d\n",i,CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i]));
+		chansegment[0] = chanlist[0];	/*  first channel is everytime ok */
+		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {	/*  build part of chanlist */
+			/*  rt_printk("%d. %d %d\n",i,CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i])); */
 			if (chanlist[0] == chanlist[i])
-				break;	// we detect loop, this must by finish
-			if (CR_CHAN(chanlist[i]) & 1)	// odd channel cann't by differencial
+				break;	/*  we detect loop, this must by finish */
+			if (CR_CHAN(chanlist[i]) & 1)	/*  odd channel cann't by differencial */
 				if (CR_AREF(chanlist[i]) == AREF_DIFF) {
 					comedi_error(dev,
 						"Odd channel can't be differential input!\n");
@@ -1135,18 +1135,18 @@ static int check_channel_list(struct com
 				(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
 			if (CR_AREF(chansegment[i - 1]) == AREF_DIFF)
 				nowmustbechan = (nowmustbechan + 1) % s->n_chan;
-			if (nowmustbechan != CR_CHAN(chanlist[i])) {	// channel list isn't continous :-(
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
 				rt_printk
 					("channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					i, CR_CHAN(chanlist[i]), nowmustbechan,
 					CR_CHAN(chanlist[0]));
 				return 0;
 			}
-			chansegment[i] = chanlist[i];	// well, this is next correct channel in list
+			chansegment[i] = chanlist[i];	/*  well, this is next correct channel in list */
 		}
 
-		for (i = 0, segpos = 0; i < n_chan; i++) {	// check whole chanlist
-			//rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i]));
+		for (i = 0, segpos = 0; i < n_chan; i++) {	/*  check whole chanlist */
+			/* rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
 				rt_printk
 					("bad channel, reference or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
@@ -1156,7 +1156,7 @@ static int check_channel_list(struct com
 					CR_CHAN(chanlist[i % seglen]),
 					CR_RANGE(chanlist[i % seglen]),
 					CR_AREF(chansegment[i % seglen]));
-				return 0;	// chan/gain list is strange
+				return 0;	/*  chan/gain list is strange */
 			}
 		}
 	} else {
@@ -1176,7 +1176,7 @@ static void setup_channel_list(struct co
 	devpriv->act_chanlist_pos = 0;
 
 	DPRINTK("SegLen: %d\n", seglen);
-	for (i = 0; i < seglen; i++) {	// store range list to card
+	for (i = 0; i < seglen; i++) {	/*  store range list to card */
 		chanprog = muxonechan[CR_CHAN(chanlist[i])];
 		outw(chanprog, dev->iobase + PCI171x_MUX);	/* select channel */
 		range = this_board->rangecode_ai[CR_RANGE(chanlist[i])];
@@ -1231,7 +1231,7 @@ static int pci171x_ai_cancel(struct come
 		devpriv->CntrlReg &= Control_CNT0;
 		devpriv->CntrlReg |= Control_SW;
 
-		outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);	// reset any operations
+		outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);	/*  reset any operations */
 		start_pacer(dev, -1, 0, 0);
 		outb(0, dev->iobase + PCI171x_CLRFIFO);
 		outb(0, dev->iobase + PCI171x_CLRINT);
@@ -1255,24 +1255,24 @@ static int pci171x_reset(struct comedi_d
 {
 	DPRINTK("adv_pci1710 EDBG: BGN: pci171x_reset(...)\n");
 	outw(0x30, dev->iobase + PCI171x_CNTCTRL);
-	devpriv->CntrlReg = Control_SW | Control_CNT0;	// Software trigger, CNT0=external
-	outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);	// reset any operations
-	outb(0, dev->iobase + PCI171x_CLRFIFO);	// clear FIFO
-	outb(0, dev->iobase + PCI171x_CLRINT);	// clear INT request
-	start_pacer(dev, -1, 0, 0);	// stop 8254
+	devpriv->CntrlReg = Control_SW | Control_CNT0;	/*  Software trigger, CNT0=external */
+	outw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);	/*  reset any operations */
+	outb(0, dev->iobase + PCI171x_CLRFIFO);	/*  clear FIFO */
+	outb(0, dev->iobase + PCI171x_CLRINT);	/*  clear INT request */
+	start_pacer(dev, -1, 0, 0);	/*  stop 8254 */
 	devpriv->da_ranges = 0;
 	if (this_board->n_aochan) {
-		outb(devpriv->da_ranges, dev->iobase + PCI171x_DAREF);	// set DACs to 0..5V
-		outw(0, dev->iobase + PCI171x_DA1);	// set DA outputs to 0V
+		outb(devpriv->da_ranges, dev->iobase + PCI171x_DAREF);	/*  set DACs to 0..5V */
+		outw(0, dev->iobase + PCI171x_DA1);	/*  set DA outputs to 0V */
 		devpriv->ao_data[0] = 0x0000;
 		if (this_board->n_aochan > 1) {
 			outw(0, dev->iobase + PCI171x_DA2);
 			devpriv->ao_data[1] = 0x0000;
 		}
 	}
-	outw(0, dev->iobase + PCI171x_DO);	// digital outputs to 0
-	outb(0, dev->iobase + PCI171x_CLRFIFO);	// clear FIFO
-	outb(0, dev->iobase + PCI171x_CLRINT);	// clear INT request
+	outw(0, dev->iobase + PCI171x_DO);	/*  digital outputs to 0 */
+	outb(0, dev->iobase + PCI171x_CLRFIFO);	/*  clear FIFO */
+	outb(0, dev->iobase + PCI171x_CLRINT);	/*  clear INT request */
 
 	DPRINTK("adv_pci1710 EDBG: END: pci171x_reset(...)\n");
 	return 0;
@@ -1284,14 +1284,14 @@ static int pci171x_reset(struct comedi_d
 static int pci1720_reset(struct comedi_device * dev)
 {
 	DPRINTK("adv_pci1710 EDBG: BGN: pci1720_reset(...)\n");
-	outb(Syncont_SC0, dev->iobase + PCI1720_SYNCONT);	// set synchronous output mode
+	outb(Syncont_SC0, dev->iobase + PCI1720_SYNCONT);	/*  set synchronous output mode */
 	devpriv->da_ranges = 0xAA;
-	outb(devpriv->da_ranges, dev->iobase + PCI1720_RANGE);	// set all ranges to +/-5V
-	outw(0x0800, dev->iobase + PCI1720_DA0);	// set outputs to 0V
+	outb(devpriv->da_ranges, dev->iobase + PCI1720_RANGE);	/*  set all ranges to +/-5V */
+	outw(0x0800, dev->iobase + PCI1720_DA0);	/*  set outputs to 0V */
 	outw(0x0800, dev->iobase + PCI1720_DA1);
 	outw(0x0800, dev->iobase + PCI1720_DA2);
 	outw(0x0800, dev->iobase + PCI1720_DA3);
-	outb(0, dev->iobase + PCI1720_SYNCOUT);	// update outputs
+	outb(0, dev->iobase + PCI1720_SYNCOUT);	/*  update outputs */
 	devpriv->ao_data[0] = 0x0800;
 	devpriv->ao_data[1] = 0x0800;
 	devpriv->ao_data[2] = 0x0800;
@@ -1378,7 +1378,7 @@ static int pci1710_attach(struct comedi_
 			errstr = "failed to enable PCI device and request regions!";
 			continue;
 		}
-		// fixup board_ptr in case we were using the dummy entry with the driver name
+		/*  fixup board_ptr in case we were using the dummy entry with the driver name */
 		dev->board_ptr = &boardtypes[board_index];
 		break;
 	}
@@ -1469,7 +1469,7 @@ static int pci1710_attach(struct comedi_
 			s->do_cmdtest = pci171x_ai_cmdtest;
 			s->do_cmd = pci171x_ai_cmd;
 		}
-		devpriv->i8254_osc_base = 100;	// 100ns=10MHz
+		devpriv->i8254_osc_base = 100;	/*  100ns=10MHz */
 		subdev++;
 	}
 
--- a/drivers/staging/comedi/drivers/aio_aio12_8.c
+++ b/drivers/staging/comedi/drivers/aio_aio12_8.c
@@ -96,16 +96,16 @@ static int aio_aio12_8_ai_read(struct co
 		ADC_MODE_NORMAL |
 		(CR_RANGE(insn->chanspec) << 3) | CR_CHAN(insn->chanspec);
 
-	//read status to clear EOC latch
+	/* read status to clear EOC latch */
 	inb(dev->iobase + AIO12_8_STATUS);
 
 	for (n = 0; n < insn->n; n++) {
 		int timeout = 5;
 
-		// Setup and start conversion
+		/*  Setup and start conversion */
 		outb(control, dev->iobase + AIO12_8_ADC);
 
-		// Wait for conversion to complete
+		/*  Wait for conversion to complete */
 		while (timeout &&
 			!(inb(dev->iobase + AIO12_8_STATUS) & STATUS_ADC_EOC)) {
 			timeout--;
@@ -140,12 +140,12 @@ static int aio_aio12_8_ao_write(struct c
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned long port = dev->iobase + AIO12_8_DAC_0 + (2 * chan);
 
-	//enable DACs
+	/* enable DACs */
 	outb(0x01, dev->iobase + DAC_ENABLE);
 
 	for (i = 0; i < insn->n; i++) {
-		outb(data[i] & 0xFF, port);	// LSB
-		outb((data[i] >> 8) & 0x0F, port + 1);	// MSB
+		outb(data[i] & 0xFF, port);	/*  LSB */
+		outb((data[i] >> 8) & 0x0F, port + 1);	/*  MSB */
 		devpriv->ao_readback[chan] = data[i];
 	}
 	return insn->n;
--- a/drivers/staging/comedi/drivers/amcc_s5933.h
+++ b/drivers/staging/comedi/drivers/amcc_s5933.h
@@ -48,12 +48,12 @@
 /****************************************************************************/
 #define INTCSR_OUTBOX_BYTE(x)	((x) & 0x3)
 #define INTCSR_OUTBOX_SELECT(x)	(((x) & 0x3) << 2)
-#define INTCSR_OUTBOX_EMPTY_INT	0x10	// enable outbox empty interrupt
+#define INTCSR_OUTBOX_EMPTY_INT	0x10	/*  enable outbox empty interrupt */
 #define INTCSR_INBOX_BYTE(x)	(((x) & 0x3) << 8)
 #define INTCSR_INBOX_SELECT(x)	(((x) & 0x3) << 10)
-#define INTCSR_INBOX_FULL_INT	0x1000	// enable inbox full interrupt
-#define INTCSR_INBOX_INTR_STATUS	0x20000	// read, or write clear inbox full interrupt
-#define INTCSR_INTR_ASSERTED	0x800000	// read only, interrupt asserted
+#define INTCSR_INBOX_FULL_INT	0x1000	/*  enable inbox full interrupt */
+#define INTCSR_INBOX_INTR_STATUS	0x20000	/*  read, or write clear inbox full interrupt */
+#define INTCSR_INTR_ASSERTED	0x800000	/*  read only, interrupt asserted */
 
 /****************************************************************************/
 /* AMCC - PCI non-volatile ram command register (byte 3 of master control/status register) */
@@ -153,7 +153,7 @@
 #define AINT_IMB_SELECT 	0x0000000c
 #define AINT_IMB_BYTE		0x00000003
 
-// these are bits from various different registers, needs cleanup XXX
+/* these are bits from various different registers, needs cleanup XXX */
 /* Enable Bus Mastering */
 #define EN_A2P_TRANSFERS	0x00000400
 /* FIFO Flag Reset */
--- a/drivers/staging/comedi/drivers/cb_das16_cs.c
+++ b/drivers/staging/comedi/drivers/cb_das16_cs.c
@@ -278,7 +278,7 @@ static int das16cs_detach(struct comedi_
 
 static irqreturn_t das16cs_interrupt(int irq, void *d)
 {
-	//struct comedi_device *dev = d;
+	/* struct comedi_device *dev = d; */
 	return IRQ_HANDLED;
 }
 
@@ -973,4 +973,4 @@ void __exit cleanup_module(void)
 
 #else
 COMEDI_INITCLEANUP(driver_das16cs);
-#endif //CONFIG_PCMCIA
+#endif /* CONFIG_PCMCIA */
--- a/drivers/staging/comedi/drivers/cb_pcidda.c
+++ b/drivers/staging/comedi/drivers/cb_pcidda.c
@@ -51,66 +51,66 @@ Please report success/failure with other
 #include "comedi_pci.h"
 #include "8255.h"
 
-#define PCI_VENDOR_ID_CB	0x1307	// PCI vendor number of ComputerBoards
-#define N_BOARDS	10	// Number of boards in cb_pcidda_boards
-#define EEPROM_SIZE	128	// number of entries in eeprom
-#define MAX_AO_CHANNELS 8	// maximum number of ao channels for supported boards
+#define PCI_VENDOR_ID_CB	0x1307	/*  PCI vendor number of ComputerBoards */
+#define N_BOARDS	10	/*  Number of boards in cb_pcidda_boards */
+#define EEPROM_SIZE	128	/*  number of entries in eeprom */
+#define MAX_AO_CHANNELS 8	/*  maximum number of ao channels for supported boards */
 
 /* PCI-DDA base addresses */
 #define DIGITALIO_BADRINDEX	2
-	// DIGITAL I/O is pci_dev->resource[2]
+	/*  DIGITAL I/O is pci_dev->resource[2] */
 #define DIGITALIO_SIZE 8
-	// DIGITAL I/O uses 8 I/O port addresses
+	/*  DIGITAL I/O uses 8 I/O port addresses */
 #define DAC_BADRINDEX	3
-	// DAC is pci_dev->resource[3]
+	/*  DAC is pci_dev->resource[3] */
 
 /* Digital I/O registers */
-#define PORT1A 0		// PORT 1A DATA
+#define PORT1A 0		/*  PORT 1A DATA */
 
-#define PORT1B 1		// PORT 1B DATA
+#define PORT1B 1		/*  PORT 1B DATA */
 
-#define PORT1C 2		// PORT 1C DATA
+#define PORT1C 2		/*  PORT 1C DATA */
 
-#define CONTROL1 3		// CONTROL REGISTER 1
+#define CONTROL1 3		/*  CONTROL REGISTER 1 */
 
-#define PORT2A 4		// PORT 2A DATA
+#define PORT2A 4		/*  PORT 2A DATA */
 
-#define PORT2B 5		// PORT 2B DATA
+#define PORT2B 5		/*  PORT 2B DATA */
 
-#define PORT2C 6		// PORT 2C DATA
+#define PORT2C 6		/*  PORT 2C DATA */
 
-#define CONTROL2 7		// CONTROL REGISTER 2
+#define CONTROL2 7		/*  CONTROL REGISTER 2 */
 
 /* DAC registers */
-#define DACONTROL	0	// D/A CONTROL REGISTER
-#define	SU	0000001		// Simultaneous update enabled
-#define NOSU	0000000		// Simultaneous update disabled
-#define	ENABLEDAC	0000002	// Enable specified DAC
-#define	DISABLEDAC	0000000	// Disable specified DAC
-#define RANGE2V5	0000000	// 2.5V
-#define RANGE5V	0000200		// 5V
-#define RANGE10V	0000300	// 10V
-#define UNIP	0000400		// Unipolar outputs
-#define BIP	0000000		// Bipolar outputs
-
-#define DACALIBRATION1	4	// D/A CALIBRATION REGISTER 1
-//write bits
-#define	SERIAL_IN_BIT	0x1	// serial data input for eeprom, caldacs, reference dac
+#define DACONTROL	0	/*  D/A CONTROL REGISTER */
+#define	SU	0000001		/*  Simultaneous update enabled */
+#define NOSU	0000000		/*  Simultaneous update disabled */
+#define	ENABLEDAC	0000002	/*  Enable specified DAC */
+#define	DISABLEDAC	0000000	/*  Disable specified DAC */
+#define RANGE2V5	0000000	/*  2.5V */
+#define RANGE5V	0000200		/*  5V */
+#define RANGE10V	0000300	/*  10V */
+#define UNIP	0000400		/*  Unipolar outputs */
+#define BIP	0000000		/*  Bipolar outputs */
+
+#define DACALIBRATION1	4	/*  D/A CALIBRATION REGISTER 1 */
+/* write bits */
+#define	SERIAL_IN_BIT	0x1	/*  serial data input for eeprom, caldacs, reference dac */
 #define	CAL_CHANNEL_MASK	(0x7 << 1)
 #define	CAL_CHANNEL_BITS(channel)	(((channel) << 1) & CAL_CHANNEL_MASK)
-//read bits
+/* read bits */
 #define	CAL_COUNTER_MASK	0x1f
-#define	CAL_COUNTER_OVERFLOW_BIT	0x20	// calibration counter overflow status bit
-#define	AO_BELOW_REF_BIT	0x40	// analog output is less than reference dac voltage
-#define	SERIAL_OUT_BIT	0x80	// serial data out, for reading from eeprom
-
-#define DACALIBRATION2	6	// D/A CALIBRATION REGISTER 2
-#define	SELECT_EEPROM_BIT	0x1	// send serial data in to eeprom
-#define	DESELECT_REF_DAC_BIT	0x2	// don't send serial data to MAX542 reference dac
-#define	DESELECT_CALDAC_BIT(n)	(0x4 << (n))	// don't send serial data to caldac n
-#define	DUMMY_BIT	0x40	// manual says to set this bit with no explanation
+#define	CAL_COUNTER_OVERFLOW_BIT	0x20	/*  calibration counter overflow status bit */
+#define	AO_BELOW_REF_BIT	0x40	/*  analog output is less than reference dac voltage */
+#define	SERIAL_OUT_BIT	0x80	/*  serial data out, for reading from eeprom */
+
+#define DACALIBRATION2	6	/*  D/A CALIBRATION REGISTER 2 */
+#define	SELECT_EEPROM_BIT	0x1	/*  send serial data in to eeprom */
+#define	DESELECT_REF_DAC_BIT	0x2	/*  don't send serial data to MAX542 reference dac */
+#define	DESELECT_CALDAC_BIT(n)	(0x4 << (n))	/*  don't send serial data to caldac n */
+#define	DUMMY_BIT	0x40	/*  manual says to set this bit with no explanation */
 
-#define DADATA	8		// FIRST D/A DATA REGISTER (0)
+#define DADATA	8		/*  FIRST D/A DATA REGISTER (0) */
 
 static const struct comedi_lrange cb_pcidda_ranges = {
 	6,
@@ -131,15 +131,20 @@ static const struct comedi_lrange cb_pci
  */
 struct cb_pcidda_board {
 	const char *name;
-	char status;		// Driver status:
-	// 0 - tested
-	// 1 - manual read, not tested
-	// 2 - manual not read
+	char status;		/*  Driver status: */
+
+	/*
+	 * 0 - tested
+	 * 1 - manual read, not tested
+	 * 2 - manual not read
+	 */
+
 	unsigned short device_id;
 	int ao_chans;
 	int ao_bits;
 	const struct comedi_lrange *ranges;
 };
+
 static const struct cb_pcidda_board cb_pcidda_boards[] = {
 	{
 	      name:	"pci-dda02/12",
@@ -219,11 +224,13 @@ struct cb_pcidda_private {
 
 	unsigned long digitalio;
 	unsigned long dac;
-	//unsigned long control_status;
-	//unsigned long adc_fifo;
-	unsigned int dac_cal1_bits;	// bits last written to da calibration register 1
-	unsigned int ao_range[MAX_AO_CHANNELS];	// current range settings for output channels
-	u16 eeprom_data[EEPROM_SIZE];	// software copy of board's eeprom
+
+	/* unsigned long control_status; */
+	/* unsigned long adc_fifo; */
+
+	unsigned int dac_cal1_bits;	/*  bits last written to da calibration register 1 */
+	unsigned int ao_range[MAX_AO_CHANNELS];	/*  current range settings for output channels */
+	u16 eeprom_data[EEPROM_SIZE];	/*  software copy of board's eeprom */
 };
 
 /*
@@ -234,12 +241,14 @@ struct cb_pcidda_private {
 
 static int cb_pcidda_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int cb_pcidda_detach(struct comedi_device * dev);
-//static int cb_pcidda_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data);
+/* static int cb_pcidda_ai_rinsn(struct comedi_device *dev,struct comedi_subdevice *s,struct comedi_insn *insn,unsigned int *data); */
 static int cb_pcidda_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data);
-//static int cb_pcidda_ai_cmd(struct comedi_device *dev,struct comedi_subdevice *s);
-//static int cb_pcidda_ai_cmdtest(struct comedi_device *dev,struct comedi_subdevice *s, struct comedi_cmd *cmd);
-//static int cb_pcidda_ns_to_timer(unsigned int *ns,int round);
+
+/* static int cb_pcidda_ai_cmd(struct comedi_device *dev, struct *comedi_subdevice *s);*/
+/* static int cb_pcidda_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd); */
+/* static int cb_pcidda_ns_to_timer(unsigned int *ns,int *round); */
+
 static unsigned int cb_pcidda_serial_in(struct comedi_device * dev);
 static void cb_pcidda_serial_out(struct comedi_device * dev, unsigned int value,
 	unsigned int num_bits);
@@ -310,7 +319,7 @@ static int cb_pcidda_attach(struct comed
       found:
 	devpriv->pci_dev = pcidev;
 	dev->board_ptr = cb_pcidda_boards + index;
-	// "thisboard" macro can be used from here.
+	/*  "thisboard" macro can be used from here. */
 	printk("Found %s at requested position\n", thisboard->name);
 
 	/*
@@ -353,11 +362,12 @@ static int cb_pcidda_attach(struct comed
 	s->maxdata = (1 << thisboard->ao_bits) - 1;
 	s->range_table = thisboard->ranges;
 	s->insn_write = cb_pcidda_ao_winsn;
-//      s->subdev_flags |= SDF_CMD_READ;
-//      s->do_cmd = cb_pcidda_ai_cmd;
-//      s->do_cmdtest = cb_pcidda_ai_cmdtest;
 
-	// two 8255 digital io subdevices
+	/* s->subdev_flags |= SDF_CMD_READ; */
+	/* s->do_cmd = cb_pcidda_ai_cmd; */
+	/* s->do_cmdtest = cb_pcidda_ai_cmdtest; */
+
+	/*  two 8255 digital io subdevices */
 	s = dev->subdevices + 1;
 	subdev_8255_init(dev, s, NULL, devpriv->digitalio);
 	s = dev->subdevices + 2;
@@ -370,7 +380,7 @@ static int cb_pcidda_attach(struct comed
 	}
 	printk("\n");
 
-	// set calibrations dacs
+	/*  set calibrations dacs */
 	for (index = 0; index < thisboard->ao_chans; index++)
 		cb_pcidda_calibrate(dev, index, devpriv->ao_range[index]);
 
@@ -398,7 +408,7 @@ static int cb_pcidda_detach(struct comed
 			pci_dev_put(devpriv->pci_dev);
 		}
 	}
-	// cleanup 8255
+	/*  cleanup 8255 */
 	if (dev->subdevices) {
 		subdev_8255_cleanup(dev, dev->subdevices + 1);
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
@@ -607,7 +617,7 @@ static int cb_pcidda_ao_winsn(struct com
 	channel = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 
-	// adjust calibration dacs if range has changed
+	/*  adjust calibration dacs if range has changed */
 	if (range != devpriv->ao_range[channel])
 		cb_pcidda_calibrate(dev, channel, range);
 
@@ -647,15 +657,15 @@ static int cb_pcidda_ao_winsn(struct com
 	return 1;
 }
 
-// lowlevel read from eeprom
+/* lowlevel read from eeprom */
 static unsigned int cb_pcidda_serial_in(struct comedi_device * dev)
 {
 	unsigned int value = 0;
 	int i;
-	const int value_width = 16;	// number of bits wide values are
+	const int value_width = 16;	/*  number of bits wide values are */
 
 	for (i = 1; i <= value_width; i++) {
-		// read bits most significant bit first
+		/*  read bits most significant bit first */
 		if (inw_p(devpriv->dac + DACALIBRATION1) & SERIAL_OUT_BIT) {
 			value |= 1 << (value_width - i);
 		}
@@ -664,14 +674,14 @@ static unsigned int cb_pcidda_serial_in(
 	return value;
 }
 
-// lowlevel write to eeprom/dac
+/* lowlevel write to eeprom/dac */
 static void cb_pcidda_serial_out(struct comedi_device * dev, unsigned int value,
 	unsigned int num_bits)
 {
 	int i;
 
 	for (i = 1; i <= num_bits; i++) {
-		// send bits most significant bit first
+		/*  send bits most significant bit first */
 		if (value & (1 << (num_bits - i)))
 			devpriv->dac_cal1_bits |= SERIAL_IN_BIT;
 		else
@@ -680,136 +690,137 @@ static void cb_pcidda_serial_out(struct 
 	}
 }
 
-// reads a 16 bit value from board's eeprom
+/* reads a 16 bit value from board's eeprom */
 static unsigned int cb_pcidda_read_eeprom(struct comedi_device * dev,
 	unsigned int address)
 {
 	unsigned int i;
 	unsigned int cal2_bits;
 	unsigned int value;
-	const int max_num_caldacs = 4;	// one caldac for every two dac channels
-	const int read_instruction = 0x6;	// bits to send to tell eeprom we want to read
+	const int max_num_caldacs = 4;	/*  one caldac for every two dac channels */
+	const int read_instruction = 0x6;	/*  bits to send to tell eeprom we want to read */
 	const int instruction_length = 3;
 	const int address_length = 8;
 
-	// send serial output stream to eeprom
+	/*  send serial output stream to eeprom */
 	cal2_bits = SELECT_EEPROM_BIT | DESELECT_REF_DAC_BIT | DUMMY_BIT;
-	// deactivate caldacs (one caldac for every two channels)
+	/*  deactivate caldacs (one caldac for every two channels) */
 	for (i = 0; i < max_num_caldacs; i++) {
 		cal2_bits |= DESELECT_CALDAC_BIT(i);
 	}
 	outw_p(cal2_bits, devpriv->dac + DACALIBRATION2);
 
-	// tell eeprom we want to read
+	/*  tell eeprom we want to read */
 	cb_pcidda_serial_out(dev, read_instruction, instruction_length);
-	// send address we want to read from
+	/*  send address we want to read from */
 	cb_pcidda_serial_out(dev, address, address_length);
 
 	value = cb_pcidda_serial_in(dev);
 
-	// deactivate eeprom
+	/*  deactivate eeprom */
 	cal2_bits &= ~SELECT_EEPROM_BIT;
 	outw_p(cal2_bits, devpriv->dac + DACALIBRATION2);
 
 	return value;
 }
 
-// writes to 8 bit calibration dacs
+/* writes to 8 bit calibration dacs */
 static void cb_pcidda_write_caldac(struct comedi_device * dev, unsigned int caldac,
 	unsigned int channel, unsigned int value)
 {
 	unsigned int cal2_bits;
 	unsigned int i;
-	const int num_channel_bits = 3;	// caldacs use 3 bit channel specification
-	const int num_caldac_bits = 8;	// 8 bit calibration dacs
-	const int max_num_caldacs = 4;	// one caldac for every two dac channels
+	const int num_channel_bits = 3;	/*  caldacs use 3 bit channel specification */
+	const int num_caldac_bits = 8;	/*  8 bit calibration dacs */
+	const int max_num_caldacs = 4;	/*  one caldac for every two dac channels */
 
 	/* write 3 bit channel */
 	cb_pcidda_serial_out(dev, channel, num_channel_bits);
-	// write 8 bit caldac value
+	/*  write 8 bit caldac value */
 	cb_pcidda_serial_out(dev, value, num_caldac_bits);
 
-	// latch stream into appropriate caldac
-	// deselect reference dac
+/*
+* latch stream into appropriate caldac deselect reference dac
+*/
 	cal2_bits = DESELECT_REF_DAC_BIT | DUMMY_BIT;
-	// deactivate caldacs (one caldac for every two channels)
+	/*  deactivate caldacs (one caldac for every two channels) */
 	for (i = 0; i < max_num_caldacs; i++) {
 		cal2_bits |= DESELECT_CALDAC_BIT(i);
 	}
-	// activate the caldac we want
+	/*  activate the caldac we want */
 	cal2_bits &= ~DESELECT_CALDAC_BIT(caldac);
 	outw_p(cal2_bits, devpriv->dac + DACALIBRATION2);
-	// deactivate caldac
+	/*  deactivate caldac */
 	cal2_bits |= DESELECT_CALDAC_BIT(caldac);
 	outw_p(cal2_bits, devpriv->dac + DACALIBRATION2);
 }
 
-// returns caldac that calibrates given analog out channel
+/* returns caldac that calibrates given analog out channel */
 static unsigned int caldac_number(unsigned int channel)
 {
 	return channel / 2;
 }
 
-// returns caldac channel that provides fine gain for given ao channel
+/* returns caldac channel that provides fine gain for given ao channel */
 static unsigned int fine_gain_channel(unsigned int ao_channel)
 {
 	return 4 * (ao_channel % 2);
 }
 
-// returns caldac channel that provides coarse gain for given ao channel
+/* returns caldac channel that provides coarse gain for given ao channel */
 static unsigned int coarse_gain_channel(unsigned int ao_channel)
 {
 	return 1 + 4 * (ao_channel % 2);
 }
 
-// returns caldac channel that provides coarse offset for given ao channel
+/* returns caldac channel that provides coarse offset for given ao channel */
 static unsigned int coarse_offset_channel(unsigned int ao_channel)
 {
 	return 2 + 4 * (ao_channel % 2);
 }
 
-// returns caldac channel that provides fine offset for given ao channel
+/* returns caldac channel that provides fine offset for given ao channel */
 static unsigned int fine_offset_channel(unsigned int ao_channel)
 {
 	return 3 + 4 * (ao_channel % 2);
 }
 
-// returns eeprom address that provides offset for given ao channel and range
+/* returns eeprom address that provides offset for given ao channel and range */
 static unsigned int offset_eeprom_address(unsigned int ao_channel,
 	unsigned int range)
 {
 	return 0x7 + 2 * range + 12 * ao_channel;
 }
 
-// returns eeprom address that provides gain calibration for given ao channel and range
+/* returns eeprom address that provides gain calibration for given ao channel and range */
 static unsigned int gain_eeprom_address(unsigned int ao_channel,
 	unsigned int range)
 {
 	return 0x8 + 2 * range + 12 * ao_channel;
 }
 
-// returns upper byte of eeprom entry, which gives the coarse adjustment values
+/* returns upper byte of eeprom entry, which gives the coarse adjustment values */
 static unsigned int eeprom_coarse_byte(unsigned int word)
 {
 	return (word >> 8) & 0xff;
 }
 
-// returns lower byte of eeprom entry, which gives the fine adjustment values
+/* returns lower byte of eeprom entry, which gives the fine adjustment values */
 static unsigned int eeprom_fine_byte(unsigned int word)
 {
 	return word & 0xff;
 }
 
-// set caldacs to eeprom values for given channel and range
+/* set caldacs to eeprom values for given channel and range */
 static void cb_pcidda_calibrate(struct comedi_device * dev, unsigned int channel,
 	unsigned int range)
 {
 	unsigned int coarse_offset, fine_offset, coarse_gain, fine_gain;
 
-	// remember range so we can tell when we need to readjust calibration
+	/*  remember range so we can tell when we need to readjust calibration */
 	devpriv->ao_range[channel] = range;
 
-	// get values from eeprom data
+	/*  get values from eeprom data */
 	coarse_offset =
 		eeprom_coarse_byte(devpriv->
 		eeprom_data[offset_eeprom_address(channel, range)]);
@@ -823,7 +834,7 @@ static void cb_pcidda_calibrate(struct c
 		eeprom_fine_byte(devpriv->
 		eeprom_data[gain_eeprom_address(channel, range)]);
 
-	// set caldacs
+	/*  set caldacs */
 	cb_pcidda_write_caldac(dev, caldac_number(channel),
 		coarse_offset_channel(channel), coarse_offset);
 	cb_pcidda_write_caldac(dev, caldac_number(channel),
--- a/drivers/staging/comedi/drivers/cb_pcidio.c
+++ b/drivers/staging/comedi/drivers/cb_pcidio.c
@@ -53,10 +53,10 @@ Passing a zero for an option is the same
  * Some drivers use arrays such as this, other do not.
  */
 struct pcidio_board {
-	const char *name;	// anme of the board
-	int n_8255;		// number of 8255 chips on board
+	const char *name;	/*  anme of the board */
+	int n_8255;		/*  number of 8255 chips on board */
 
-	// indices of base address regions
+	/*  indices of base address regions */
 	int pcicontroler_badrindex;
 	int dioregs_badrindex;
 };
@@ -104,7 +104,7 @@ MODULE_DEVICE_TABLE(pci, pcidio_pci_tabl
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
 struct pcidio_private {
-	int data;		// curently unused
+	int data;		/*  curently unused */
 
 	/* would be useful for a PCI device */
 	struct pci_dev *pci_dev;
@@ -112,7 +112,7 @@ struct pcidio_private {
 	/* used for DO readback, curently unused */
 	unsigned int do_readback[4];	/* up to 4 unsigned int suffice to hold 96 bits for PCI-DIO96 */
 
-	unsigned long dio_reg_base;	// address of port A of the first 8255 chip on board
+	unsigned long dio_reg_base;	/*  address of port A of the first 8255 chip on board */
 };
 
 /*
@@ -134,8 +134,10 @@ static struct comedi_driver driver_cb_pc
       module:THIS_MODULE,
       attach:pcidio_attach,
       detach:pcidio_detach,
+
 /* It is not necessary to implement the following members if you are
  * writing a driver for a ISA PnP or PCI card */
+
 	/* Most drivers will support multiple types of boards by
 	 * having an array of board structures.  These were defined
 	 * in pcidio_boards[] above.  Note that the element 'name'
@@ -152,10 +154,15 @@ static struct comedi_driver driver_cb_pc
 	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
 	 * devices are such boards.
 	 */
-// The following fields should NOT be initialized if you are dealing with PCI devices
-//      board_name:     pcidio_boards,
-//      offset:         sizeof(struct pcidio_board),
-//      num_names:      sizeof(pcidio_boards) / sizeof(struct pcidio_board),
+
+/* The following fields should NOT be initialized if you are dealing
+ * with PCI devices
+ *
+ *         board_name:	pcidio_boards,
+ *         offset:	sizeof(struct pcidio_board),
+ *         num_names: 	sizeof(pcidio_boards) / sizeof(structpcidio_board),
+ */
+
 };
 
 /*------------------------------- FUNCTIONS -----------------------------------*/
@@ -192,19 +199,19 @@ static int pcidio_attach(struct comedi_d
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
-		// is it not a computer boards card?
+		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;
-		// loop through cards supported by this driver
+		/*  loop through cards supported by this driver */
 		for (index = 0;
 			index < sizeof pcidio_boards / sizeof(struct pcidio_board);
 			index++) {
 			if (pcidio_pci_table[index].device != pcidev->device)
 				continue;
 
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
 					PCI_SLOT(pcidev->devfn) !=
 					it->options[1]) {
--- a/drivers/staging/comedi/drivers/cb_pcimdda.c
+++ b/drivers/staging/comedi/drivers/cb_pcimdda.c
@@ -434,16 +434,16 @@ static int probe(struct comedi_device * 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
-		// is it not a computer boards card?
+		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
-		// loop through cards supported by this driver
+		/*  loop through cards supported by this driver */
 		for (index = 0; index < N_BOARDS; index++) {
 			if (boards[index].device_id != pcidev->device)
 				continue;
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
 					PCI_SLOT(pcidev->devfn) !=
 					it->options[1]) {
--- a/drivers/staging/comedi/drivers/comedi_rt_timer.c
+++ b/drivers/staging/comedi/drivers/comedi_rt_timer.c
@@ -73,9 +73,9 @@ TODO:
 #define RTLINUX_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
 #endif
 
-// begin hack to workaround broken HRT_TO_8254() function on rtlinux
+/* begin hack to workaround broken HRT_TO_8254() function on rtlinux */
 #if RTLINUX_VERSION_CODE <= RTLINUX_VERSION(3,0,100)
-// this function sole purpose is to divide a long long by 838
+/* this function sole purpose is to divide a long long by 838 */
 static inline RTIME nano2count(long long ns)
 {
 	do_div(ns, 838);
@@ -91,9 +91,9 @@ static inline RTIME nano2count(long long
 
 #define nano2count(x) HRT_TO_8254(x)
 #endif
-// end hack
+/* end hack */
 
-// rtl-rtai compatibility
+/* rtl-rtai compatibility */
 #define rt_task_wait_period() rt_task_wait()
 #define rt_pend_linux_srq(irq) rtl_global_pend_irq(irq)
 #define rt_free_srq(irq) rtl_free_soft_irq(irq)
@@ -133,31 +133,33 @@ static struct comedi_driver driver_timer
       driver_name:"comedi_rt_timer",
       attach:timer_attach,
       detach:timer_detach,
-//      open:           timer_open,
+/* open:           timer_open, */
 };
 
 COMEDI_INITCLEANUP(driver_timer);
 
 struct timer_private {
-	comedi_t *device;	// device we are emulating commands for
-	int subd;		// subdevice we are emulating commands for
-	RT_TASK *rt_task;	// rt task that starts scans
-	RT_TASK *scan_task;	// rt task that controls conversion timing in a scan
+	comedi_t *device;	/*  device we are emulating commands for */
+	int subd;		/*  subdevice we are emulating commands for */
+	RT_TASK *rt_task;	/*  rt task that starts scans */
+	RT_TASK *scan_task;	/*  rt task that controls conversion timing in a scan */
 	/* io_function can point to either an input or output function
 	 * depending on what kind of subdevice we are emulating for */
 	int (*io_function) (struct comedi_device * dev, struct comedi_cmd * cmd,
 		unsigned int index);
-	// RTIME has units of 1 = 838 nanoseconds
-	// time at which first scan started, used to check scan timing
+/*
+* RTIME has units of 1 = 838 nanoseconds time at which first scan
+* started, used to check scan timing
+*/
 	RTIME start;
-	// time between scans
+	/*  time between scans */
 	RTIME scan_period;
-	// time between conversions in a scan
+	/*  time between conversions in a scan */
 	RTIME convert_period;
-	// flags
-	volatile int stop;	// indicates we should stop
-	volatile int rt_task_active;	// indicates rt_task is servicing a struct comedi_cmd
-	volatile int scan_task_active;	// indicates scan_task is servicing a struct comedi_cmd
+	/*  flags */
+	volatile int stop;	/*  indicates we should stop */
+	volatile int rt_task_active;	/*  indicates rt_task is servicing a struct comedi_cmd */
+	volatile int scan_task_active;	/*  indicates scan_task is servicing a struct comedi_cmd */
 	unsigned timer_running:1;
 };
 #define devpriv ((struct timer_private *)dev->private)
@@ -169,7 +171,7 @@ static int timer_cancel(struct comedi_de
 	return 0;
 }
 
-// checks for scan timing error
+/* checks for scan timing error */
 inline static int check_scan_timing(struct comedi_device * dev,
 	unsigned long long scan)
 {
@@ -186,7 +188,7 @@ inline static int check_scan_timing(stru
 	return 0;
 }
 
-// checks for conversion timing error
+/* checks for conversion timing error */
 inline static int check_conversion_timing(struct comedi_device * dev,
 	RTIME scan_start, unsigned int conversion)
 {
@@ -205,7 +207,7 @@ inline static int check_conversion_timin
 	return 0;
 }
 
-// devpriv->io_function for an input subdevice
+/* devpriv->io_function for an input subdevice */
 static int timer_data_read(struct comedi_device * dev, struct comedi_cmd * cmd,
 	unsigned int index)
 {
@@ -230,7 +232,7 @@ static int timer_data_read(struct comedi
 	return 0;
 }
 
-// devpriv->io_function for an output subdevice
+/* devpriv->io_function for an output subdevice */
 static int timer_data_write(struct comedi_device * dev, struct comedi_cmd * cmd,
 	unsigned int index)
 {
@@ -265,7 +267,7 @@ static int timer_data_write(struct comed
 	return 0;
 }
 
-// devpriv->io_function for DIO subdevices
+/* devpriv->io_function for DIO subdevices */
 static int timer_dio_read(struct comedi_device * dev, struct comedi_cmd * cmd,
 	unsigned int index)
 {
@@ -287,7 +289,7 @@ static int timer_dio_read(struct comedi_
 	return 0;
 }
 
-// performs scans
+/* performs scans */
 static void scan_task_func(comedi_rt_task_context_t d)
 {
 	struct comedi_device *dev = (struct comedi_device *) d;
@@ -298,14 +300,14 @@ static void scan_task_func(comedi_rt_tas
 	unsigned long long n;
 	RTIME scan_start;
 
-	// every struct comedi_cmd causes one execution of while loop
+	/*  every struct comedi_cmd causes one execution of while loop */
 	while (1) {
 		devpriv->scan_task_active = 1;
-		// each for loop completes one scan
+		/*  each for loop completes one scan */
 		for (n = 0; n < cmd->stop_arg || cmd->stop_src == TRIG_NONE;
 			n++) {
 			if (n) {
-				// suspend task until next scan
+				/*  suspend task until next scan */
 				ret = rt_task_suspend(devpriv->scan_task);
 				if (ret < 0) {
 					comedi_error(dev,
@@ -314,7 +316,7 @@ static void scan_task_func(comedi_rt_tas
 					goto cleanup;
 				}
 			}
-			// check if stop flag was set (by timer_cancel())
+			/*  check if stop flag was set (by timer_cancel()) */
 			if (devpriv->stop)
 				goto cleanup;
 			ret = check_scan_timing(dev, n);
@@ -324,7 +326,7 @@ static void scan_task_func(comedi_rt_tas
 			}
 			scan_start = rt_get_time();
 			for (i = 0; i < cmd->scan_end_arg; i++) {
-				// conversion timing
+				/*  conversion timing */
 				if (cmd->convert_src == TRIG_TIMER && i) {
 					rt_task_wait_period();
 					ret = check_conversion_timing(dev,
@@ -353,7 +355,7 @@ static void scan_task_func(comedi_rt_tas
 		comedi_event(dev, s);
 		async->events = 0;
 		devpriv->scan_task_active = 0;
-		// suspend task until next struct comedi_cmd
+		/*  suspend task until next struct comedi_cmd */
 		rt_task_suspend(devpriv->scan_task);
 	}
 }
@@ -366,7 +368,7 @@ static void timer_task_func(comedi_rt_ta
 	int ret;
 	unsigned long long n;
 
-	// every struct comedi_cmd causes one execution of while loop
+	/*  every struct comedi_cmd causes one execution of while loop */
 	while (1) {
 		devpriv->rt_task_active = 1;
 		devpriv->scan_task_active = 1;
@@ -374,7 +376,7 @@ static void timer_task_func(comedi_rt_ta
 
 		for (n = 0; n < cmd->stop_arg || cmd->stop_src == TRIG_NONE;
 			n++) {
-			// scan timing
+			/*  scan timing */
 			if (n)
 				rt_task_wait_period();
 			if (devpriv->scan_task_active == 0) {
@@ -391,7 +393,7 @@ static void timer_task_func(comedi_rt_ta
 	      cleanup:
 
 		devpriv->rt_task_active = 0;
-		// suspend until next struct comedi_cmd
+		/*  suspend until next struct comedi_cmd */
 		rt_task_suspend(devpriv->rt_task);
 	}
 }
@@ -485,7 +487,7 @@ static int timer_cmdtest(struct comedi_d
 		return 2;
 
 	/* step 3: make sure arguments are trivially compatible */
-	// limit frequency, this is fairly arbitrary
+	/*  limit frequency, this is fairly arbitrary */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg < SPEED_LIMIT) {
 			cmd->scan_begin_arg = SPEED_LIMIT;
@@ -498,7 +500,7 @@ static int timer_cmdtest(struct comedi_d
 			err++;
 		}
 	}
-	// make sure conversion and scan frequencies are compatible
+	/*  make sure conversion and scan frequencies are compatible */
 	if (cmd->convert_src == TRIG_TIMER && cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->convert_arg * cmd->scan_end_arg > cmd->scan_begin_arg) {
 			cmd->scan_begin_arg =
@@ -524,7 +526,7 @@ static int timer_cmd(struct comedi_devic
 	/* hack attack: drivers are not supposed to do this: */
 	dev->rt = 1;
 
-	// make sure tasks have finished cleanup of last struct comedi_cmd
+	/*  make sure tasks have finished cleanup of last struct comedi_cmd */
 	if (devpriv->rt_task_active || devpriv->scan_task_active)
 		return -EBUSY;
 
@@ -636,7 +638,7 @@ static int timer_attach(struct comedi_de
 	emul_dev = devpriv->device;
 	emul_s = emul_dev->subdevices + devpriv->subd;
 
-	// input or output subdevice
+	/*  input or output subdevice */
 	s = dev->subdevices + 0;
 	s->type = emul_s->type;
 	s->subdev_flags = emul_s->subdev_flags;	/* SDF_GROUND (to fool check_driver) */
@@ -681,7 +683,7 @@ static int timer_attach(struct comedi_de
 
 	devpriv->rt_task = kzalloc(sizeof(RT_TASK), GFP_KERNEL);
 
-	// initialize real-time tasks
+	/*  initialize real-time tasks */
 	ret = rt_task_init(devpriv->rt_task, timer_task_func,
 		(comedi_rt_task_context_t) dev, 3000, timer_priority, 0, 0);
 	if (ret < 0) {
@@ -705,7 +707,7 @@ static int timer_attach(struct comedi_de
 	return 1;
 }
 
-// free allocated resources
+/* free allocated resources */
 static int timer_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: timer: remove\n", dev->minor);
--- a/drivers/staging/comedi/drivers/daqboard2000.c
+++ b/drivers/staging/comedi/drivers/daqboard2000.c
@@ -129,7 +129,7 @@ Configuration options:
 #define DAQBOARD2000_DAQ_SIZE 		0x1002
 #define DAQBOARD2000_PLX_SIZE 		0x100
 
-// Initialization bits for the Serial EEPROM Control Register
+/* Initialization bits for the Serial EEPROM Control Register */
 #define DAQBOARD2000_SECRProgPinHi      0x8001767e
 #define DAQBOARD2000_SECRProgPinLo      0x8000767e
 #define DAQBOARD2000_SECRLocalBusHi     0xc000767e
@@ -137,14 +137,14 @@ Configuration options:
 #define DAQBOARD2000_SECRReloadHi       0xa000767e
 #define DAQBOARD2000_SECRReloadLo       0x8000767e
 
-// SECR status bits
+/* SECR status bits */
 #define DAQBOARD2000_EEPROM_PRESENT     0x10000000
 
-// CPLD status bits
+/* CPLD status bits */
 #define DAQBOARD2000_CPLD_INIT 		0x0002
 #define DAQBOARD2000_CPLD_DONE 		0x0004
 
-// Available ranges
+/* Available ranges */
 static const struct comedi_lrange range_daqboard2000_ai = { 13, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
@@ -168,65 +168,65 @@ static const struct comedi_lrange range_
 };
 
 struct daqboard2000_hw {
-	volatile u16 acqControl;	// 0x00
-	volatile u16 acqScanListFIFO;	// 0x02
-	volatile u32 acqPacerClockDivLow;	// 0x04
-
-	volatile u16 acqScanCounter;	// 0x08
-	volatile u16 acqPacerClockDivHigh;	// 0x0a
-	volatile u16 acqTriggerCount;	// 0x0c
-	volatile u16 fill2;	// 0x0e
-	volatile u16 acqResultsFIFO;	// 0x10
-	volatile u16 fill3;	// 0x12
-	volatile u16 acqResultsShadow;	// 0x14
-	volatile u16 fill4;	// 0x16
-	volatile u16 acqAdcResult;	// 0x18
-	volatile u16 fill5;	// 0x1a
-	volatile u16 dacScanCounter;	// 0x1c
-	volatile u16 fill6;	// 0x1e
-
-	volatile u16 dacControl;	// 0x20
-	volatile u16 fill7;	// 0x22
-	volatile s16 dacFIFO;	// 0x24
-	volatile u16 fill8[2];	// 0x26
-	volatile u16 dacPacerClockDiv;	// 0x2a
-	volatile u16 refDacs;	// 0x2c
-	volatile u16 fill9;	// 0x2e
-
-	volatile u16 dioControl;	// 0x30
-	volatile s16 dioP3hsioData;	// 0x32
-	volatile u16 dioP3Control;	// 0x34
-	volatile u16 calEepromControl;	// 0x36
-	volatile s16 dacSetting[4];	// 0x38
-	volatile s16 dioP2ExpansionIO8Bit[32];	// 0x40
-
-	volatile u16 ctrTmrControl;	// 0x80
-	volatile u16 fill10[3];	// 0x82
-	volatile s16 ctrInput[4];	// 0x88
-	volatile u16 fill11[8];	// 0x90
-	volatile u16 timerDivisor[2];	// 0xa0
-	volatile u16 fill12[6];	// 0xa4
-
-	volatile u16 dmaControl;	// 0xb0
-	volatile u16 trigControl;	// 0xb2
-	volatile u16 fill13[2];	// 0xb4
-	volatile u16 calEeprom;	// 0xb8
-	volatile u16 acqDigitalMark;	// 0xba
-	volatile u16 trigDacs;	// 0xbc
-	volatile u16 fill14;	// 0xbe
-	volatile s16 dioP2ExpansionIO16Bit[32];	// 0xc0
+	volatile u16 acqControl;	/*  0x00 */
+	volatile u16 acqScanListFIFO;	/*  0x02 */
+	volatile u32 acqPacerClockDivLow;	/*  0x04 */
+
+	volatile u16 acqScanCounter;	/*  0x08 */
+	volatile u16 acqPacerClockDivHigh;	/*  0x0a */
+	volatile u16 acqTriggerCount;	/*  0x0c */
+	volatile u16 fill2;	/*  0x0e */
+	volatile u16 acqResultsFIFO;	/*  0x10 */
+	volatile u16 fill3;	/*  0x12 */
+	volatile u16 acqResultsShadow;	/*  0x14 */
+	volatile u16 fill4;	/*  0x16 */
+	volatile u16 acqAdcResult;	/*  0x18 */
+	volatile u16 fill5;	/*  0x1a */
+	volatile u16 dacScanCounter;	/*  0x1c */
+	volatile u16 fill6;	/*  0x1e */
+
+	volatile u16 dacControl;	/*  0x20 */
+	volatile u16 fill7;	/*  0x22 */
+	volatile s16 dacFIFO;	/*  0x24 */
+	volatile u16 fill8[2];	/*  0x26 */
+	volatile u16 dacPacerClockDiv;	/*  0x2a */
+	volatile u16 refDacs;	/*  0x2c */
+	volatile u16 fill9;	/*  0x2e */
+
+	volatile u16 dioControl;	/*  0x30 */
+	volatile s16 dioP3hsioData;	/*  0x32 */
+	volatile u16 dioP3Control;	/*  0x34 */
+	volatile u16 calEepromControl;	/*  0x36 */
+	volatile s16 dacSetting[4];	/*  0x38 */
+	volatile s16 dioP2ExpansionIO8Bit[32];	/*  0x40 */
+
+	volatile u16 ctrTmrControl;	/*  0x80 */
+	volatile u16 fill10[3];	/*  0x82 */
+	volatile s16 ctrInput[4];	/*  0x88 */
+	volatile u16 fill11[8];	/*  0x90 */
+	volatile u16 timerDivisor[2];	/*  0xa0 */
+	volatile u16 fill12[6];	/*  0xa4 */
+
+	volatile u16 dmaControl;	/*  0xb0 */
+	volatile u16 trigControl;	/*  0xb2 */
+	volatile u16 fill13[2];	/*  0xb4 */
+	volatile u16 calEeprom;	/*  0xb8 */
+	volatile u16 acqDigitalMark;	/*  0xba */
+	volatile u16 trigDacs;	/*  0xbc */
+	volatile u16 fill14;	/*  0xbe */
+	volatile s16 dioP2ExpansionIO16Bit[32];	/*  0xc0 */
 };
 
 /* Scan Sequencer programming */
 #define DAQBOARD2000_SeqStartScanList            0x0011
 #define DAQBOARD2000_SeqStopScanList             0x0010
 
-// Prepare for acquisition
+/* Prepare for acquisition */
 #define DAQBOARD2000_AcqResetScanListFifo        0x0004
 #define DAQBOARD2000_AcqResetResultsFifo         0x0002
 #define DAQBOARD2000_AcqResetConfigPipe          0x0001
 
-// Acqusition status bits
+/* Acqusition status bits */
 #define DAQBOARD2000_AcqResultsFIFOMore1Sample   0x0001
 #define DAQBOARD2000_AcqResultsFIFOHasValidData  0x0002
 #define DAQBOARD2000_AcqResultsFIFOOverrun       0x0004
@@ -239,7 +239,7 @@ struct daqboard2000_hw {
 #define DAQBOARD2000_DacPacerOverrun             0x0200
 #define DAQBOARD2000_AcqHardwareError            0x01c0
 
-// Scan Sequencer programming
+/* Scan Sequencer programming */
 #define DAQBOARD2000_SeqStartScanList            0x0011
 #define DAQBOARD2000_SeqStopScanList             0x0010
 
@@ -254,7 +254,7 @@ struct daqboard2000_hw {
 #define DAQBOARD2000_AdcPacerInternalOutEnable   0x0008
 #define DAQBOARD2000_AdcPacerExternalRising      0x0100
 
-// DAC status
+/* DAC status */
 #define DAQBOARD2000_DacFull                     0x0001
 #define DAQBOARD2000_RefBusy                     0x0002
 #define DAQBOARD2000_TrgBusy                     0x0004
@@ -264,7 +264,7 @@ struct daqboard2000_hw {
 #define DAQBOARD2000_Dac2Busy                    0x0040
 #define DAQBOARD2000_Dac3Busy                    0x0080
 
-// DAC control
+/* DAC control */
 #define DAQBOARD2000_Dac0Enable                  0x0021
 #define DAQBOARD2000_Dac1Enable                  0x0031
 #define DAQBOARD2000_Dac2Enable                  0x0041
@@ -292,7 +292,7 @@ struct daqboard2000_hw {
 #define DAQBOARD2000_TrigEnable                  0x0001
 #define DAQBOARD2000_TrigDisable                 0x0000
 
-// Reference Dac Selection
+/* Reference Dac Selection */
 #define DAQBOARD2000_PosRefDacSelect             0x0100
 #define DAQBOARD2000_NegRefDacSelect             0x0000
 
@@ -342,9 +342,9 @@ static void writeAcqScanListEntry(struct
 {
 	struct daqboard2000_hw *fpga = devpriv->daq;
 
-//  comedi_udelay(4);
+/* comedi_udelay(4); */
 	fpga->acqScanListFIFO = entry & 0x00ff;
-//  comedi_udelay(4);
+/* comedi_udelay(4); */
 	fpga->acqScanListFIFO = (entry >> 8) & 0x00ff;
 }
 
@@ -425,14 +425,14 @@ static int daqboard2000_ai_insn_read(str
 			if (fpga->acqControl & DAQBOARD2000_AcqConfigPipeFull) {
 				break;
 			}
-			//comedi_udelay(2);
+			/* comedi_udelay(2); */
 		}
 		fpga->acqControl = DAQBOARD2000_AdcPacerEnable;
 		for (timeout = 0; timeout < 20; timeout++) {
 			if (fpga->acqControl & DAQBOARD2000_AcqLogicScanning) {
 				break;
 			}
-			//comedi_udelay(2);
+			/* comedi_udelay(2); */
 		}
 		for (timeout = 0; timeout < 20; timeout++) {
 			if (fpga->
@@ -440,7 +440,7 @@ static int daqboard2000_ai_insn_read(str
 				DAQBOARD2000_AcqResultsFIFOHasValidData) {
 				break;
 			}
-			//comedi_udelay(2);
+			/* comedi_udelay(2); */
 		}
 		data[i] = fpga->acqResultsFIFO;
 		fpga->acqControl = DAQBOARD2000_AdcPacerDisable;
@@ -476,13 +476,13 @@ static int daqboard2000_ao_insn_write(st
 		 * OK, since it works OK without enabling the DAC's, let's keep
 		 * it as simple as possible...
 		 */
-		//fpga->dacControl = (chan + 2) * 0x0010 | 0x0001; comedi_udelay(1000);
+		/* fpga->dacControl = (chan + 2) * 0x0010 | 0x0001; comedi_udelay(1000); */
 		fpga->dacSetting[chan] = data[i];
 		for (timeout = 0; timeout < 20; timeout++) {
 			if ((fpga->dacControl & ((chan + 1) * 0x0010)) == 0) {
 				break;
 			}
-			//comedi_udelay(2);
+			/* comedi_udelay(2); */
 		}
 		devpriv->ao_readback[chan] = data[i];
 		/*
@@ -645,7 +645,7 @@ static void daqboard2000_activateReferen
 	struct daqboard2000_hw *fpga = devpriv->daq;
 	int timeout;
 
-	// Set the + reference dac value in the FPGA
+	/*  Set the + reference dac value in the FPGA */
 	fpga->refDacs = 0x80 | DAQBOARD2000_PosRefDacSelect;
 	for (timeout = 0; timeout < 20; timeout++) {
 		if ((fpga->dacControl & DAQBOARD2000_RefBusy) == 0) {
@@ -655,7 +655,7 @@ static void daqboard2000_activateReferen
 	}
 /*  printk("DAQBOARD2000_PosRefDacSelect %d\n", timeout);*/
 
-	// Set the - reference dac value in the FPGA
+	/*  Set the - reference dac value in the FPGA */
 	fpga->refDacs = 0x80 | DAQBOARD2000_NegRefDacSelect;
 	for (timeout = 0; timeout < 20; timeout++) {
 		if ((fpga->dacControl & DAQBOARD2000_RefBusy) == 0) {
--- a/drivers/staging/comedi/drivers/das08.c
+++ b/drivers/staging/comedi/drivers/das08.c
@@ -65,12 +65,12 @@ driver.
 #define PCI_DEVICE_ID_PCIDAS08 0x29
 #define PCIDAS08_SIZE 0x54
 
-// pci configuration registers
+/* pci configuration registers */
 #define INTCSR               0x4c
 #define   INTR1_ENABLE         0x1
 #define   INTR1_HIGH_POLARITY  0x2
 #define   PCI_INTR_ENABLE      0x40
-#define   INTR1_EDGE_TRIG      0x100	// requires high polarity
+#define   INTR1_EDGE_TRIG      0x100	/*  requires high polarity */
 #define CNTRL                0x50
 #define   CNTRL_DIR            0x2
 #define   CNTRL_INTR           0x4
@@ -248,7 +248,7 @@ static const int *const das08_gainlists[
 
 static const struct das08_board_struct das08_boards[] = {
 	{
-	      name:	"isa-das08",	// cio-das08.pdf
+	      name:	"isa-das08",	/*  cio-das08.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
@@ -261,10 +261,10 @@ static const struct das08_board_struct d
 	      do_nchan:4,
 	      i8255_offset:8,
 	      i8254_offset:4,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 	{
-	      name:	"das08-pgm",	// cio-das08pgx.pdf
+	      name:	"das08-pgm",	/*  cio-das08pgx.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
@@ -276,10 +276,10 @@ static const struct das08_board_struct d
 	      do_nchan:4,
 	      i8255_offset:0,
 	      i8254_offset:0x04,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 	{
-	      name:	"das08-pgh",	// cio-das08pgx.pdf
+	      name:	"das08-pgh",	/*  cio-das08pgx.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
@@ -291,10 +291,10 @@ static const struct das08_board_struct d
 	      do_nchan:4,
 	      i8255_offset:0,
 	      i8254_offset:0x04,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 	{
-	      name:	"das08-pgl",	// cio-das08pgx.pdf
+	      name:	"das08-pgl",	/*  cio-das08pgx.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
@@ -306,58 +306,58 @@ static const struct das08_board_struct d
 	      do_nchan:4,
 	      i8255_offset:0,
 	      i8254_offset:0x04,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 	{
-	      name:	"das08-aoh",	// cio-das08_aox.pdf
+	      name:	"das08-aoh",	/*  cio-das08_aox.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
 	      ai_pg:	das08_pgh,
 	      ai_encoding:das08_encode12,
-	      ao:	das08ao_ao_winsn,	// 8
+	      ao:	das08ao_ao_winsn,	/*  8 */
 	      ao_nbits:12,
 	      di:	das08_di_rbits,
 	      do_:	das08_do_wbits,
 	      do_nchan:4,
 	      i8255_offset:0x0c,
 	      i8254_offset:0x04,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 	{
-	      name:	"das08-aol",	// cio-das08_aox.pdf
+	      name:	"das08-aol",	/*  cio-das08_aox.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
 	      ai_pg:	das08_pgl,
 	      ai_encoding:das08_encode12,
-	      ao:	das08ao_ao_winsn,	// 8
+	      ao:	das08ao_ao_winsn,	/*  8 */
 	      ao_nbits:12,
 	      di:	das08_di_rbits,
 	      do_:	das08_do_wbits,
 	      do_nchan:4,
 	      i8255_offset:0x0c,
 	      i8254_offset:0x04,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 	{
-	      name:	"das08-aom",	// cio-das08_aox.pdf
+	      name:	"das08-aom",	/*  cio-das08_aox.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
 	      ai_pg:	das08_pgm,
 	      ai_encoding:das08_encode12,
-	      ao:	das08ao_ao_winsn,	// 8
+	      ao:	das08ao_ao_winsn,	/*  8 */
 	      ao_nbits:12,
 	      di:	das08_di_rbits,
 	      do_:	das08_do_wbits,
 	      do_nchan:4,
 	      i8255_offset:0x0c,
 	      i8254_offset:0x04,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 	{
-	      name:	"das08/jr-ao",	// cio-das08-jr-ao.pdf
+	      name:	"das08/jr-ao",	/*  cio-das08-jr-ao.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
@@ -370,10 +370,10 @@ static const struct das08_board_struct d
 	      do_nchan:8,
 	      i8255_offset:0,
 	      i8254_offset:0,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 	{
-	      name:	"das08jr-16-ao",	// cio-das08jr-16-ao.pdf
+	      name:	"das08jr-16-ao",	/*  cio-das08jr-16-ao.pdf */
 	      bustype:	isa,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:16,
@@ -386,11 +386,11 @@ static const struct das08_board_struct d
 	      do_nchan:8,
 	      i8255_offset:0,
 	      i8254_offset:0x04,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 #ifdef CONFIG_COMEDI_PCI
 	{
-	      name:	"das08",	// pci-das08
+	      name:	"das08",	/*  pci-das08 */
 	      id:	PCI_DEVICE_ID_PCIDAS08,
 	      bustype:	pci,
 	      ai:	das08_ai_rinsn,
@@ -421,7 +421,7 @@ static const struct das08_board_struct d
 	      do_nchan:4,
 	      i8255_offset:0,
 	      i8254_offset:4,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 #if 0
 	{
@@ -445,14 +445,14 @@ static const struct das08_board_struct d
 	      do_nchan:8,
 	      i8255_offset:0,
 	      i8254_offset:0,
-	      iosize:	16,	// unchecked
+	      iosize:	16,	/*  unchecked */
 		},
 #if 0
 	{
-	      name:	"das48-pga",	// cio-das48-pga.pdf
+	      name:	"das48-pga",	/*  cio-das48-pga.pdf */
 		},
 	{
-	      name:	"das08-pga-g2",	// a KM board
+	      name:	"das08-pga-g2",	/*  a KM board */
 		},
 #endif
 };
@@ -461,7 +461,7 @@ static const struct das08_board_struct d
 struct das08_board_struct das08_cs_boards[NUM_DAS08_CS_BOARDS] = {
 	{
 	      name:	"pcm-das08",
-	      id:	0x0,	// XXX
+	      id:	0x0,	/*  XXX */
 	      bustype:	pcmcia,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
@@ -476,10 +476,10 @@ struct das08_board_struct das08_cs_board
 	      i8254_offset:0,
 	      iosize:	16,
 		},
-	// duplicate so driver name can be used also
+	/*  duplicate so driver name can be used also */
 	{
 	      name:	"das08_cs",
-	      id:	0x0,	// XXX
+	      id:	0x0,	/*  XXX */
 	      bustype:	pcmcia,
 	      ai:	das08_ai_rinsn,
 	      ai_nbits:12,
@@ -528,7 +528,7 @@ static int das08_ai_rinsn(struct comedi_
 	inb(dev->iobase + DAS08_MSB);
 
 	/* set multiplexer */
-	spin_lock(&dev->spinlock);	// lock to prevent race with digital output
+	spin_lock(&dev->spinlock);	/*  lock to prevent race with digital output */
 	devpriv->do_mux_bits &= ~DAS08_MUX_MASK;
 	devpriv->do_mux_bits |= DAS08_MUX(chan);
 	outb(devpriv->do_mux_bits, dev->iobase + DAS08_CONTROL);
@@ -593,14 +593,14 @@ static int das08_do_wbits(struct comedi_
 {
 	int wbits;
 
-	// get current settings of digital output lines
+	/*  get current settings of digital output lines */
 	wbits = (devpriv->do_mux_bits >> 4) & 0xf;
-	// null bits we are going to set
+	/*  null bits we are going to set */
 	wbits &= ~data[0];
-	// set new bit values
+	/*  set new bit values */
 	wbits |= data[0] & data[1];
-	// remember digital output bits
-	spin_lock(&dev->spinlock);	// prevent race with setting of analog input mux
+	/*  remember digital output bits */
+	spin_lock(&dev->spinlock);	/*  prevent race with setting of analog input mux */
 	devpriv->do_mux_bits &= ~DAS08_DO_MASK;
 	devpriv->do_mux_bits |= DAS08_OP(wbits);
 	outb(devpriv->do_mux_bits, dev->iobase + DAS08_CONTROL);
@@ -623,9 +623,9 @@ static int das08jr_di_rbits(struct comed
 static int das08jr_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	// null bits we are going to set
+	/*  null bits we are going to set */
 	devpriv->do_bits &= ~data[0];
-	// set new bit values
+	/*  set new bit values */
 	devpriv->do_bits |= data[0] & data[1];
 	outb(devpriv->do_bits, dev->iobase + DAS08JR_DIO);
 
@@ -787,9 +787,9 @@ static int das08_counter_read(struct com
 {
 	int chan = insn->chanspec;
 
-	//printk("Reading counter channel %d ",chan);
+	/* printk("Reading counter channel %d ",chan); */
 	data[0] = i8254_read_channel(&devpriv->i8254, chan);
-	//printk("=> 0x%08X\n",data[0]);
+	/* printk("=> 0x%08X\n",data[0]); */
 
 	return 1;
 }
@@ -799,7 +799,7 @@ static int das08_counter_write(struct co
 {
 	int chan = insn->chanspec;
 
-	//printk("Writing counter channel %d with 0x%04X\n",chan,data[0]);
+	/* printk("Writing counter channel %d with 0x%04X\n",chan,data[0]); */
 	i8254_write_channel(&devpriv->i8254, chan, data[0]);
 
 	return 1;
@@ -845,7 +845,7 @@ int das08_common_attach(struct comedi_de
 	struct comedi_subdevice *s;
 	int ret;
 
-	// allocate ioports for non-pcmcia, non-pci boards
+	/*  allocate ioports for non-pcmcia, non-pci boards */
 	if ((thisboard->bustype != pcmcia) && (thisboard->bustype != pci)) {
 		printk(" iobase 0x%lx\n", iobase);
 		if (!request_region(iobase, thisboard->iosize, DRV_NAME)) {
@@ -880,7 +880,7 @@ int das08_common_attach(struct comedi_de
 	/* ao */
 	if (thisboard->ao) {
 		s->type = COMEDI_SUBD_AO;
-// XXX lacks read-back insn
+/* XXX lacks read-back insn */
 		s->subdev_flags = SDF_WRITABLE;
 		s->n_chan = 2;
 		s->maxdata = (1 << thisboard->ao_nbits) - 1;
@@ -965,7 +965,7 @@ static int das08_attach(struct comedi_de
 		return ret;
 
 	printk("comedi%d: das08: ", dev->minor);
-	// deal with a pci board
+	/*  deal with a pci board */
 	if (thisboard->bustype == pci) {
 #ifdef CONFIG_COMEDI_PCI
 		if (it->options[0] || it->options[1]) {
@@ -973,7 +973,7 @@ static int das08_attach(struct comedi_de
 				it->options[0], it->options[1]);
 		}
 		printk("\n");
-		// find card
+		/*  find card */
 		for (pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 			pdev != NULL;
 			pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) {
@@ -995,12 +995,12 @@ static int das08_attach(struct comedi_de
 			return -EIO;
 		}
 		devpriv->pdev = pdev;
-		// enable PCI device and reserve I/O spaces
+		/*  enable PCI device and reserve I/O spaces */
 		if (comedi_pci_enable(pdev, DRV_NAME)) {
 			printk(" Error enabling PCI device and requesting regions\n");
 			return -EIO;
 		}
-		// read base addresses
+		/*  read base addresses */
 		pci_iobase = pci_resource_start(pdev, 1);
 		iobase = pci_resource_start(pdev, 2);
 		printk("pcibase 0x%lx  iobase 0x%lx\n", pci_iobase, iobase);
@@ -1035,7 +1035,7 @@ int das08_common_detach(struct comedi_de
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 4);
 
-	// deallocate ioports for non-pcmcia, non-pci boards
+	/*  deallocate ioports for non-pcmcia, non-pci boards */
 	if ((thisboard->bustype != pcmcia) && (thisboard->bustype != pci)) {
 		if (dev->iobase)
 			release_region(dev->iobase, thisboard->iosize);
--- a/drivers/staging/comedi/drivers/das08_cs.c
+++ b/drivers/staging/comedi/drivers/das08_cs.c
@@ -46,7 +46,7 @@ Command support does not exist, but coul
 
 #include "das08.h"
 
-// pcmcia includes
+/* pcmcia includes */
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
@@ -73,13 +73,13 @@ static int das08_cs_attach(struct comedi
 {
 	int ret;
 	unsigned long iobase;
-	struct pcmcia_device *link = cur_dev;	// XXX hack
+	struct pcmcia_device *link = cur_dev;	/*  XXX hack */
 
 	if ((ret = alloc_private(dev, sizeof(struct das08_private_struct))) < 0)
 		return ret;
 
 	printk("comedi%d: das08_cs: ", dev->minor);
-	// deal with a pci board
+	/*  deal with a pci board */
 
 	if (thisboard->bustype == pcmcia) {
 		if (link == NULL) {
--- a/drivers/staging/comedi/drivers/das08.h
+++ b/drivers/staging/comedi/drivers/das08.h
@@ -25,14 +25,14 @@
 #define _DAS08_H
 
 enum das08_bustype { isa, pci, pcmcia, pc104 };
-// different ways ai data is encoded in first two registers
+/* different ways ai data is encoded in first two registers */
 enum das08_ai_encoding { das08_encode12, das08_encode16, das08_pcm_encode12 };
 enum das08_lrange { das08_pg_none, das08_bipolar5, das08_pgh, das08_pgl,
 		das08_pgm };
 
 struct das08_board_struct {
 	const char *name;
-	unsigned int id;	// id for pci/pcmcia boards
+	unsigned int id;	/*  id for pci/pcmcia boards */
 	enum das08_bustype bustype;
 	void *ai;
 	unsigned int ai_nbits;
@@ -45,13 +45,13 @@ struct das08_board_struct {
 	unsigned int do_nchan;
 	unsigned int i8255_offset;
 	unsigned int i8254_offset;
-	unsigned int iosize;	// number of ioports used
+	unsigned int iosize;	/*  number of ioports used */
 };
 
 struct i8254_struct {
-	int channels;		// available channels. Some could be used internally.
-	int logic2phys[3];	// to know which physical channel is.
-	int mode[3];		// the index is the real counter.
+	int channels;		/*  available channels. Some could be used internally. */
+	int logic2phys[3];	/*  to know which physical channel is. */
+	int mode[3];		/*  the index is the real counter. */
 	unsigned int iobase;
 };
 
@@ -61,11 +61,11 @@ struct i8254_struct {
 #define I8254_CTRL 3
 
 struct das08_private_struct {
-	unsigned int do_mux_bits;	// bits for do/mux register on boards without seperate do register
-	unsigned int do_bits;	// bits for do register on boards with register dedicated to digital out only
+	unsigned int do_mux_bits;	/*  bits for do/mux register on boards without seperate do register */
+	unsigned int do_bits;	/*  bits for do register on boards with register dedicated to digital out only */
 	const unsigned int *pg_gainlist;
-	struct pci_dev *pdev;	// struct for pci-das08
-	unsigned int pci_iobase;	// additional base address for pci-das08
+	struct pci_dev *pdev;	/*  struct for pci-das08 */
+	unsigned int pci_iobase;	/*  additional base address for pci-das08 */
 	struct i8254_struct i8254;
 };
 
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -87,7 +87,7 @@ Computer boards manuals also available f
 #include "comedi_fc.h"
 
 #undef DEBUG
-//#define DEBUG
+/* #define DEBUG */
 
 #ifdef DEBUG
 #define DEBUG_PRINT(format, args...) rt_printk("das16: " format, ## args)
@@ -95,8 +95,8 @@ Computer boards manuals also available f
 #define DEBUG_PRINT(format, args...)
 #endif
 
-#define DAS16_SIZE 20		// number of ioports
-#define DAS16_DMA_SIZE 0xff00	// size in bytes of allocated dma buffer
+#define DAS16_SIZE 20		/*  number of ioports */
+#define DAS16_DMA_SIZE 0xff00	/*  size in bytes of allocated dma buffer */
 
 /*
     cio-das16.pdf
@@ -184,7 +184,7 @@ Computer boards manuals also available f
 
 */
 
-static const int sample_size = 2;	// size in bytes of a sample from board
+static const int sample_size = 2;	/*  size in bytes of a sample from board */
 
 #define DAS16_TRIG		0
 #define DAS16_AI_LSB		0
@@ -265,7 +265,7 @@ static const struct comedi_lrange range_
 	}
 };
 static const struct comedi_lrange range_das16jr = { 9, {
-			// also used by 16/330
+			/*  also used by 16/330 */
 			BIP_RANGE(10),
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
@@ -359,7 +359,7 @@ struct das16_board {
 	const char *name;
 	void *ai;
 	unsigned int ai_nbits;
-	unsigned int ai_speed;	// max conversion speed in nanosec
+	unsigned int ai_speed;	/*  max conversion speed in nanosec */
 	unsigned int ai_pg;
 	void *ao;
 	unsigned int ao_nbits;
@@ -420,7 +420,7 @@ static const struct das16_board das16_bo
 	      id:	0x00,
 		},
 	{
-	      name:	"cio-das16",	// cio-das16.pdf
+	      name:	"cio-das16",	/*  cio-das16.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:20000,
@@ -435,7 +435,7 @@ static const struct das16_board das16_bo
 	      id:	0x80,
 		},
 	{
-	      name:	"cio-das16/f",	// das16.pdf
+	      name:	"cio-das16/f",	/*  das16.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -450,7 +450,7 @@ static const struct das16_board das16_bo
 	      id:	0x80,
 		},
 	{
-	      name:	"cio-das16/jr",	// cio-das16jr.pdf
+	      name:	"cio-das16/jr",	/*  cio-das16jr.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:7692,
@@ -464,7 +464,7 @@ static const struct das16_board das16_bo
 	      id:	0x00,
 		},
 	{
-	      name:	"pc104-das16jr",	// pc104-das16jr_xx.pdf
+	      name:	"pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:3300,
@@ -478,7 +478,7 @@ static const struct das16_board das16_bo
 	      id:	0x00,
 		},
 	{
-	      name:	"cio-das16jr/16",	// cio-das16jr_16.pdf
+	      name:	"cio-das16jr/16",	/*  cio-das16jr_16.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:16,
 	      ai_speed:10000,
@@ -492,7 +492,7 @@ static const struct das16_board das16_bo
 	      id:	0x00,
 		},
 	{
-	      name:	"pc104-das16jr/16",	// pc104-das16jr_xx.pdf
+	      name:	"pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:16,
 	      ai_speed:10000,
@@ -506,7 +506,7 @@ static const struct das16_board das16_bo
 	      id:	0x00,
 		},
 	{
-	      name:	"das-1201",	// 4924.pdf (keithley user's manual)
+	      name:	"das-1201",	/*  4924.pdf (keithley user's manual) */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:20000,
@@ -520,7 +520,7 @@ static const struct das16_board das16_bo
 	      id:	0x20,
 		},
 	{
-	      name:	"das-1202",	// 4924.pdf (keithley user's manual)
+	      name:	"das-1202",	/*  4924.pdf (keithley user's manual) */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -534,7 +534,7 @@ static const struct das16_board das16_bo
 	      id:	0x20,
 		},
 	{
-	      name:	"das-1401",	// 4919.pdf and 4922.pdf (keithley user's manual)
+	      name:	"das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -545,10 +545,10 @@ static const struct das16_board das16_bo
 	      i8255_offset:0x0,
 	      i8254_offset:0x0c,
 	      size:	0x408,
-	      id:	0xc0	// 4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0
+	      id:	0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
 		},
 	{
-	      name:	"das-1402",	// 4919.pdf and 4922.pdf (keithley user's manual)
+	      name:	"das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -559,10 +559,10 @@ static const struct das16_board das16_bo
 	      i8255_offset:0x0,
 	      i8254_offset:0x0c,
 	      size:	0x408,
-	      id:	0xc0	// 4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0
+	      id:	0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
 		},
 	{
-	      name:	"das-1601",	// 4919.pdf
+	      name:	"das-1601",	/*  4919.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -576,7 +576,7 @@ static const struct das16_board das16_bo
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"das-1602",	// 4919.pdf
+	      name:	"das-1602",	/*  4919.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -590,7 +590,7 @@ static const struct das16_board das16_bo
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1401/12",	// cio-das1400_series.pdf
+	      name:	"cio-das1401/12",	/*  cio-das1400_series.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:6250,
@@ -603,7 +603,7 @@ static const struct das16_board das16_bo
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1402/12",	// cio-das1400_series.pdf
+	      name:	"cio-das1402/12",	/*  cio-das1400_series.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:6250,
@@ -616,7 +616,7 @@ static const struct das16_board das16_bo
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1402/16",	// cio-das1400_series.pdf
+	      name:	"cio-das1402/16",	/*  cio-das1400_series.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:16,
 	      ai_speed:10000,
@@ -629,7 +629,7 @@ static const struct das16_board das16_bo
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1601/12",	// cio-das160x-1x.pdf
+	      name:	"cio-das1601/12",	/*  cio-das160x-1x.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:6250,
@@ -643,7 +643,7 @@ static const struct das16_board das16_bo
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1602/12",	// cio-das160x-1x.pdf
+	      name:	"cio-das1602/12",	/*  cio-das160x-1x.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -657,7 +657,7 @@ static const struct das16_board das16_bo
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1602/16",	// cio-das160x-1x.pdf
+	      name:	"cio-das1602/16",	/*  cio-das160x-1x.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:16,
 	      ai_speed:10000,
@@ -671,7 +671,7 @@ static const struct das16_board das16_bo
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das16/330",	// ?
+	      name:	"cio-das16/330",	/*  ? */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:3030,
@@ -685,13 +685,13 @@ static const struct das16_board das16_bo
       id:	0xf0},
 #if 0
 	{
-	      name:	"das16/330i",	// ?
+	      name:	"das16/330i",	/*  ? */
 		},
 	{
-	      name:	"das16/jr/ctr5",	// ?
+	      name:	"das16/jr/ctr5",	/*  ? */
 		},
 	{
-	      name:	"cio-das16/m1/16",	// cio-das16_m1_16.pdf, this board is a bit quirky, no dma
+	      name:	"cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
 		},
 #endif
 };
@@ -719,25 +719,25 @@ static inline int timer_period(void)
 	return HZ / 20;
 }
 struct das16_private_struct {
-	unsigned int ai_unipolar;	// unipolar flag
-	unsigned int ai_singleended;	// single ended flag
-	unsigned int clockbase;	// master clock speed in ns
-	volatile unsigned int control_state;	// dma, interrupt and trigger control bits
-	volatile unsigned long adc_byte_count;	// number of bytes remaining
-	unsigned int divisor1;	// divisor dividing master clock to get conversion frequency
-	unsigned int divisor2;	// divisor dividing master clock to get conversion frequency
-	unsigned int dma_chan;	// dma channel
+	unsigned int ai_unipolar;	/*  unipolar flag */
+	unsigned int ai_singleended;	/*  single ended flag */
+	unsigned int clockbase;	/*  master clock speed in ns */
+	volatile unsigned int control_state;	/*  dma, interrupt and trigger control bits */
+	volatile unsigned long adc_byte_count;	/*  number of bytes remaining */
+	unsigned int divisor1;	/*  divisor dividing master clock to get conversion frequency */
+	unsigned int divisor2;	/*  divisor dividing master clock to get conversion frequency */
+	unsigned int dma_chan;	/*  dma channel */
 	uint16_t *dma_buffer[2];
 	dma_addr_t dma_buffer_addr[2];
 	unsigned int current_buffer;
-	volatile unsigned int dma_transfer_size;	// target number of bytes to transfer per dma shot
-	// user-defined analog input and output ranges defined from config options
+	volatile unsigned int dma_transfer_size;	/*  target number of bytes to transfer per dma shot */
+	/*  user-defined analog input and output ranges defined from config options */
 	struct comedi_lrange *user_ai_range_table;
 	struct comedi_lrange *user_ao_range_table;
 
-	struct timer_list timer;	// for timed interrupt
+	struct timer_list timer;	/*  for timed interrupt */
 	volatile short timer_running;
-	volatile short timer_mode;	// true if using timer mode
+	volatile short timer_mode;	/*  true if using timer mode */
 };
 #define devpriv ((struct das16_private_struct *)(dev->private))
 #define thisboard ((struct das16_board *)(dev->board_ptr))
@@ -757,7 +757,7 @@ static int das16_cmd_test(struct comedi_
 
 	tmp = cmd->scan_begin_src;
 	mask = TRIG_FOLLOW;
-	// if board supports burst mode
+	/*  if board supports burst mode */
 	if (thisboard->size > 0x400)
 		mask |= TRIG_TIMER | TRIG_EXT;
 	cmd->scan_begin_src &= mask;
@@ -766,7 +766,7 @@ static int das16_cmd_test(struct comedi_
 
 	tmp = cmd->convert_src;
 	mask = TRIG_TIMER | TRIG_EXT;
-	// if board supports burst mode
+	/*  if board supports burst mode */
 	if (thisboard->size > 0x400)
 		mask |= TRIG_NOW;
 	cmd->convert_src &= mask;
@@ -797,7 +797,7 @@ static int das16_cmd_test(struct comedi_
 	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
 		err++;
 
-	// make sure scan_begin_src and convert_src dont conflict
+	/*  make sure scan_begin_src and convert_src dont conflict */
 	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
@@ -824,7 +824,7 @@ static int das16_cmd_test(struct comedi_
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
 	}
-	// check against maximum frequency
+	/*  check against maximum frequency */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg <
 			thisboard->ai_speed * cmd->chanlist_len) {
@@ -849,10 +849,10 @@ static int das16_cmd_test(struct comedi_
 	if (err)
 		return 3;
 
-	// step 4: fix up arguments
+	/*  step 4: fix up arguments */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->scan_begin_arg;
-		// set divisors, correct timing arguments
+		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
 			&(devpriv->divisor1), &(devpriv->divisor2),
 			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
@@ -860,7 +860,7 @@ static int das16_cmd_test(struct comedi_
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->convert_arg;
-		// set divisors, correct timing arguments
+		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
 			&(devpriv->divisor1), &(devpriv->divisor2),
 			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
@@ -869,7 +869,7 @@ static int das16_cmd_test(struct comedi_
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist) {
 		gain = CR_RANGE(cmd->chanlist[0]);
 		start_chan = CR_CHAN(cmd->chanlist[0]);
@@ -916,11 +916,11 @@ static int das16_cmd_exec(struct comedi_
 	devpriv->adc_byte_count =
 		cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
 
-	// disable conversions for das1600 mode
+	/*  disable conversions for das1600 mode */
 	if (thisboard->size > 0x400) {
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV);
 	}
-	// set scan limits
+	/*  set scan limits */
 	byte = CR_CHAN(cmd->chanlist[0]);
 	byte |= CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]) << 4;
 	outb(byte, dev->iobase + DAS16_MUX);
@@ -945,7 +945,7 @@ static int das16_cmd_exec(struct comedi_
 	if (thisboard->size > 0x400) {
 		if (cmd->convert_src == TRIG_NOW) {
 			outb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST);
-			// set burst length
+			/*  set burst length */
 			byte |= BURST_LEN_BITS(cmd->chanlist_len - 1);
 		} else {
 			outb(0, dev->iobase + DAS1600_BURST);
@@ -953,7 +953,7 @@ static int das16_cmd_exec(struct comedi_
 	}
 	outb(byte, dev->iobase + DAS16_PACER);
 
-	// set up dma transfer
+	/*  set up dma transfer */
 	flags = claim_dma_lock();
 	disable_dma(devpriv->dma_chan);
 	/* clear flip-flop to make sure 2-byte registers for
@@ -962,13 +962,13 @@ static int das16_cmd_exec(struct comedi_
 	devpriv->current_buffer = 0;
 	set_dma_addr(devpriv->dma_chan,
 		devpriv->dma_buffer_addr[devpriv->current_buffer]);
-	// set appropriate size of transfer
+	/*  set appropriate size of transfer */
 	devpriv->dma_transfer_size = das16_suggest_transfer_size(dev, *cmd);
 	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma_chan);
 	release_dma_lock(flags);
 
-	// set up interrupt
+	/*  set up interrupt */
 	if (devpriv->timer_mode) {
 		devpriv->timer_running = 1;
 		devpriv->timer.expires = jiffies + timer_period();
@@ -1007,7 +1007,7 @@ static int das16_cancel(struct comedi_de
 	if (devpriv->dma_chan)
 		disable_dma(devpriv->dma_chan);
 
-	// disable SW timer
+	/*  disable SW timer */
 	if (devpriv->timer_mode && devpriv->timer_running) {
 		devpriv->timer_running = 0;
 		del_timer(&devpriv->timer);
@@ -1039,7 +1039,7 @@ static int das16_ai_rinsn(struct comedi_
 	int chan;
 	int msb, lsb;
 
-	// disable interrupts and pacing
+	/*  disable interrupts and pacing */
 	devpriv->control_state &= ~DAS16_INTE & ~DMA_ENABLE & ~PACING_MASK;
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
@@ -1096,12 +1096,12 @@ static int das16_do_wbits(struct comedi_
 {
 	unsigned int wbits;
 
-	// only set bits that have been masked
+	/*  only set bits that have been masked */
 	data[0] &= 0xf;
 	wbits = s->state;
-	// zero bits that have been masked
+	/*  zero bits that have been masked */
 	wbits &= ~data[0];
-	// set masked bits
+	/*  set masked bits */
 	wbits |= data[0] & data[1];
 	s->state = wbits;
 	data[1] = wbits;
@@ -1210,7 +1210,7 @@ static void das16_interrupt(struct comed
 		comedi_error(dev, "premature interrupt");
 		return;
 	}
-	// initialize async here to make sure it is not NULL
+	/*  initialize async here to make sure it is not NULL */
 	async = s->async;
 	cmd = &async->cmd;
 
@@ -1230,7 +1230,7 @@ static void das16_interrupt(struct comed
 	clear_dma_ff(devpriv->dma_chan);
 	residue = disable_dma_on_even(dev);
 
-	// figure out how many points to read
+	/*  figure out how many points to read */
 	if (residue > devpriv->dma_transfer_size) {
 		comedi_error(dev, "residue > transfer size!\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
@@ -1247,12 +1247,12 @@ static void das16_interrupt(struct comed
 	devpriv->current_buffer = (devpriv->current_buffer + 1) % 2;
 	devpriv->adc_byte_count -= num_bytes;
 
-	// figure out how many bytes for next transfer
+	/*  figure out how many bytes for next transfer */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->timer_mode == 0 &&
 		devpriv->dma_transfer_size > devpriv->adc_byte_count)
 		devpriv->dma_transfer_size = devpriv->adc_byte_count;
 
-	// re-enable  dma
+	/*  re-enable  dma */
 	if ((async->events & COMEDI_CB_EOA) == 0) {
 		set_dma_addr(devpriv->dma_chan,
 			devpriv->dma_buffer_addr[devpriv->current_buffer]);
@@ -1391,7 +1391,7 @@ static int das16_attach(struct comedi_de
 
 	printk("comedi%d: das16:", dev->minor);
 
-	// check that clock setting is valid
+	/*  check that clock setting is valid */
 	if (it->options[3]) {
 		if (it->options[3] != 0 &&
 			it->options[3] != 1 && it->options[3] != 10) {
@@ -1431,19 +1431,19 @@ static int das16_attach(struct comedi_de
 
 	dev->iobase = iobase;
 
-	// probe id bits to make sure they are consistent
+	/*  probe id bits to make sure they are consistent */
 	if (das16_probe(dev, it)) {
 		printk(" id bits do not match selected board, aborting\n");
 		return -EINVAL;
 	}
 	dev->board_name = thisboard->name;
 
-	// get master clock speed
+	/*  get master clock speed */
 	if (thisboard->size < 0x400) {
 		if (it->options[3])
 			devpriv->clockbase = 1000 / it->options[3];
 		else
-			devpriv->clockbase = 1000;	// 1 MHz default
+			devpriv->clockbase = 1000;	/*  1 MHz default */
 	} else {
 		das1600_mode_detect(dev);
 	}
@@ -1462,10 +1462,10 @@ static int das16_attach(struct comedi_de
 		return -EINVAL;
 	}
 
-	// initialize dma
+	/*  initialize dma */
 	dma_chan = it->options[2];
 	if (dma_chan == 1 || dma_chan == 3) {
-		// allocate dma buffers
+		/*  allocate dma buffers */
 		int i;
 		for (i = 0; i < 2; i++) {
 			devpriv->dma_buffer[i] = pci_alloc_consistent(NULL,
@@ -1491,27 +1491,27 @@ static int das16_attach(struct comedi_de
 		return -EINVAL;
 	}
 
-	// get any user-defined input range
+	/*  get any user-defined input range */
 	if (thisboard->ai_pg == das16_pg_none &&
 		(it->options[4] || it->options[5])) {
-		// allocate single-range range table
+		/*  allocate single-range range table */
 		devpriv->user_ai_range_table =
 			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
 			GFP_KERNEL);
-		// initialize ai range
+		/*  initialize ai range */
 		devpriv->user_ai_range_table->length = 1;
 		user_ai_range = devpriv->user_ai_range_table->range;
 		user_ai_range->min = it->options[4];
 		user_ai_range->max = it->options[5];
 		user_ai_range->flags = UNIT_volt;
 	}
-	// get any user-defined output range
+	/*  get any user-defined output range */
 	if (it->options[6] || it->options[7]) {
-		// allocate single-range range table
+		/*  allocate single-range range table */
 		devpriv->user_ao_range_table =
 			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
 			GFP_KERNEL);
-		// initialize ao range
+		/*  initialize ao range */
 		devpriv->user_ao_range_table->length = 1;
 		user_ao_range = devpriv->user_ao_range_table->range;
 		user_ao_range->min = it->options[6];
@@ -1545,7 +1545,7 @@ static int das16_attach(struct comedi_de
 			s->subdev_flags |= SDF_DIFF;
 		}
 		s->maxdata = (1 << thisboard->ai_nbits) - 1;
-		if (devpriv->user_ai_range_table) {	// user defined ai range
+		if (devpriv->user_ai_range_table) {	/*  user defined ai range */
 			s->range_table = devpriv->user_ai_range_table;
 		} else if (devpriv->ai_unipolar) {
 			s->range_table = das16_ai_uni_lranges[thisboard->ai_pg];
@@ -1568,7 +1568,7 @@ static int das16_attach(struct comedi_de
 		s->subdev_flags = SDF_WRITABLE;
 		s->n_chan = 2;
 		s->maxdata = (1 << thisboard->ao_nbits) - 1;
-		if (devpriv->user_ao_range_table) {	// user defined ao range
+		if (devpriv->user_ao_range_table) {	/*  user defined ao range */
 			s->range_table = devpriv->user_ao_range_table;
 		} else {
 			s->range_table = &range_unknown;
@@ -1600,7 +1600,7 @@ static int das16_attach(struct comedi_de
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->insn_bits = thisboard->do_;
-		// initialize digital output lines
+		/*  initialize digital output lines */
 		outb(s->state, dev->iobase + DAS16_DIO);
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
@@ -1620,7 +1620,7 @@ static int das16_attach(struct comedi_de
 	devpriv->control_state = DAS16_IRQ(dev->irq);
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
-	// turn on das1600 mode if available
+	/*  turn on das1600 mode if available */
 	if (thisboard->size > 0x400) {
 		outb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE);
 		outb(0, dev->iobase + DAS1600_CONV);
@@ -1673,7 +1673,7 @@ static int das16_detach(struct comedi_de
 
 COMEDI_INITCLEANUP(driver_das16);
 
-// utility function that suggests a dma transfer size in bytes
+/* utility function that suggests a dma transfer size in bytes */
 static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
 	struct comedi_cmd cmd)
 {
@@ -1692,18 +1692,18 @@ static unsigned int das16_suggest_transf
 		freq = 1000000000 / cmd.convert_arg;
 	else if (cmd.scan_begin_src == TRIG_TIMER)
 		freq = (1000000000 / cmd.scan_begin_arg) * cmd.chanlist_len;
-	// return some default value
+	/*  return some default value */
 	else
 		freq = 0xffffffff;
 
 	if (cmd.flags & TRIG_WAKE_EOS) {
 		size = sample_size * cmd.chanlist_len;
 	} else {
-		// make buffer fill in no more than 1/3 second
+		/*  make buffer fill in no more than 1/3 second */
 		size = (freq / 3) * sample_size;
 	}
 
-	// set a minimum and maximum size allowed
+	/*  set a minimum and maximum size allowed */
 	if (size > DAS16_DMA_SIZE)
 		size = DAS16_DMA_SIZE - DAS16_DMA_SIZE % sample_size;
 	else if (size < sample_size)
--- a/drivers/staging/comedi/drivers/das16m1.c
+++ b/drivers/staging/comedi/drivers/das16m1.c
@@ -68,9 +68,9 @@ irq can be omitted, although the cmd int
 #define DAS16M1_SIZE 16
 #define DAS16M1_SIZE2 8
 
-#define DAS16M1_XTAL 100	//10 MHz master clock
+#define DAS16M1_XTAL 100	/* 10 MHz master clock */
 
-#define FIFO_SIZE 1024		// 1024 sample fifo
+#define FIFO_SIZE 1024		/*  1024 sample fifo */
 
 /*
     CIO-DAS16_M1.pdf
@@ -92,7 +92,7 @@ irq can be omitted, although the cmd int
 
 */
 
-#define DAS16M1_AI             0	// 16-bit wide register
+#define DAS16M1_AI             0	/*  16-bit wide register */
 #define   AI_CHAN(x)             ((x) & 0xf)
 #define DAS16M1_CS             2
 #define   EXT_TRIG_BIT           0x1
@@ -159,8 +159,8 @@ struct das16m1_board {
 
 static const struct das16m1_board das16m1_boards[] = {
 	{
-	      name:	"cio-das16/m1",	// CIO-DAS16_M1.pdf
-	      ai_speed:1000,	// 1MHz max speed
+	      name:	"cio-das16/m1",	/*  CIO-DAS16_M1.pdf */
+	      ai_speed:1000,	/*  1MHz max speed */
 		},
 };
 
@@ -180,15 +180,15 @@ static struct comedi_driver driver_das16
 
 struct das16m1_private_struct {
 	unsigned int control_state;
-	volatile unsigned int adc_count;	// number of samples completed
+	volatile unsigned int adc_count;	/*  number of samples completed */
 	/* initial value in lower half of hardware conversion counter,
 	 * needed to keep track of whether new count has been loaded into
 	 * counter yet (loaded by first sample conversion) */
 	u16 initial_hw_count;
 	short ai_buffer[FIFO_SIZE];
-	unsigned int do_bits;	// saves status of digital output bits
-	unsigned int divisor1;	// divides master clock to obtain conversion speed
-	unsigned int divisor2;	// divides master clock to obtain conversion speed
+	unsigned int do_bits;	/*  saves status of digital output bits */
+	unsigned int divisor1;	/*  divides master clock to obtain conversion speed */
+	unsigned int divisor2;	/*  divides master clock to obtain conversion speed */
 };
 #define devpriv ((struct das16m1_private_struct *)(dev->private))
 #define thisboard ((const struct das16m1_board *)(dev->board_ptr))
@@ -299,10 +299,10 @@ static int das16m1_cmd_test(struct comed
 	if (err)
 		return 4;
 
-	// check chanlist against board's peculiarities
+	/*  check chanlist against board's peculiarities */
 	if (cmd->chanlist && cmd->chanlist_len > 1) {
 		for (i = 0; i < cmd->chanlist_len; i++) {
-			// even/odd channels must go into even/odd queue addresses
+			/*  even/odd channels must go into even/odd queue addresses */
 			if ((i % 2) != (CR_CHAN(cmd->chanlist[i]) % 2)) {
 				comedi_error(dev, "bad chanlist:\n"
 					" even/odd channels must go have even/odd chanlist indices");
@@ -337,7 +337,7 @@ static int das16m1_cmd_exec(struct comed
 	devpriv->control_state &= ~INTE & ~PACER_MASK;
 	outb(devpriv->control_state, dev->iobase + DAS16M1_INTR_CONTROL);
 
-	// set software count
+	/*  set software count */
 	devpriv->adc_count = 0;
 	/* Initialize lower half of hardware counter, used to determine how
 	 * many samples are in fifo.  Value doesn't actually load into counter
@@ -361,7 +361,7 @@ static int das16m1_cmd_exec(struct comed
 		das16m1_set_pacer(dev, cmd->convert_arg,
 		cmd->flags & TRIG_ROUND_MASK);
 
-	// set control & status register
+	/*  set control & status register */
 	byte = 0;
 	/* if we are using external start trigger (also board dislikes having
 	 * both start and conversion triggers external simultaneously) */
@@ -447,12 +447,12 @@ static int das16m1_do_wbits(struct comed
 {
 	unsigned int wbits;
 
-	// only set bits that have been masked
+	/*  only set bits that have been masked */
 	data[0] &= 0xf;
 	wbits = devpriv->do_bits;
-	// zero bits that have been masked
+	/*  zero bits that have been masked */
 	wbits &= ~data[0];
-	// set masked bits
+	/*  set masked bits */
 	wbits |= data[0] & data[1];
 	devpriv->do_bits = wbits;
 	data[1] = wbits;
@@ -467,7 +467,7 @@ static int das16m1_poll(struct comedi_de
 	unsigned long flags;
 	unsigned int status;
 
-	// prevent race with interrupt handler
+	/*  prevent race with interrupt handler */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	status = inb(dev->iobase + DAS16M1_CS);
 	das16m1_handler(dev, status);
@@ -485,7 +485,7 @@ static irqreturn_t das16m1_interrupt(int
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
-	// prevent race with comedi_poll()
+	/*  prevent race with comedi_poll() */
 	spin_lock(&dev->spinlock);
 
 	status = inb(dev->iobase + DAS16M1_CS);
@@ -527,7 +527,7 @@ static void das16m1_handler(struct comed
 	async->events = 0;
 	cmd = &async->cmd;
 
-	// figure out how many samples are in fifo
+	/*  figure out how many samples are in fifo */
 	hw_counter = i8254_read(dev->iobase + DAS16M1_8254_FIRST, 0, 1);
 	/* make sure hardware counter reading is not bogus due to initial value
 	 * not having been loaded yet */
@@ -542,12 +542,12 @@ static void das16m1_handler(struct comed
 		 * hardware counter.  Work it out, and this is what you get. */
 		num_samples = -hw_counter - devpriv->adc_count;
 	}
-	// check if we only need some of the points
+	/*  check if we only need some of the points */
 	if (cmd->stop_src == TRIG_COUNT) {
 		if (num_samples > cmd->stop_arg * cmd->chanlist_len)
 			num_samples = cmd->stop_arg * cmd->chanlist_len;
 	}
-	// make sure we dont try to get too many points if fifo has overrun
+	/*  make sure we dont try to get too many points if fifo has overrun */
 	if (num_samples > FIFO_SIZE)
 		num_samples = FIFO_SIZE;
 	insw(dev->iobase, devpriv->ai_buffer, num_samples);
@@ -669,7 +669,7 @@ static int das16m1_attach(struct comedi_
 
 	/* now for the irq */
 	irq = it->options[1];
-	// make sure it is valid
+	/*  make sure it is valid */
 	if (das16m1_irq_bits(irq) >= 0) {
 		ret = comedi_request_irq(irq, das16m1_interrupt, 0,
 			driver_das16m1.driver_name, dev);
@@ -728,10 +728,10 @@ static int das16m1_attach(struct comedi_
 	/* 8255 */
 	subdev_8255_init(dev, s, NULL, dev->iobase + DAS16M1_82C55);
 
-	// disable upper half of hardware conversion counter so it doesn't mess with us
+	/*  disable upper half of hardware conversion counter so it doesn't mess with us */
 	outb(TOTAL_CLEAR, dev->iobase + DAS16M1_8254_FIRST_CNTRL);
 
-	// initialize digital output lines
+	/*  initialize digital output lines */
 	outb(devpriv->do_bits, dev->iobase + DAS16M1_DIO);
 
 	/* set the interrupt level */
@@ -748,7 +748,7 @@ static int das16m1_detach(struct comedi_
 {
 	printk("comedi%d: das16m1: remove\n", dev->minor);
 
-//      das16m1_reset(dev);
+/* das16m1_reset(dev); */
 
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 3);
--- a/drivers/staging/comedi/drivers/das6402.c
+++ b/drivers/staging/comedi/drivers/das6402.c
@@ -342,7 +342,7 @@ static int das6402_attach(struct comedi_
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND;
 	s->n_chan = 8;
-	//s->trig[2]=das6402_ai_mode2;
+	/* s->trig[2]=das6402_ai_mode2; */
 	s->cancel = das6402_ai_cancel;
 	s->maxdata = (1 << 12) - 1;
 	s->len_chanlist = 16;	/* ? */
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -72,7 +72,7 @@ cmd triggers supported:
 
 #define DAS800_SIZE           8
 #define TIMER_BASE            1000
-#define N_CHAN_AI             8	// number of analog input channels
+#define N_CHAN_AI             8	/*  number of analog input channels */
 
 /* Registers for the das800 */
 
@@ -94,8 +94,8 @@ cmd triggers supported:
 #define   IRQ                   0x8
 #define   BUSY                  0x80
 #define DAS800_GAIN           3
-#define   CIO_FFOV              0x8	// fifo overflow for cio-das802/16
-#define   CIO_ENHF              0x90	// interrupt fifo half full for cio-das802/16
+#define   CIO_FFOV              0x8	/*  fifo overflow for cio-das802/16 */
+#define   CIO_ENHF              0x90	/*  interrupt fifo half full for cio-das802/16 */
 #define   CONTROL1              0x80
 #define   CONV_CONTROL          0xa0
 #define   SCAN_LIMITS           0xc0
@@ -113,7 +113,7 @@ struct das800_board {
 	int resolution;
 };
 
-//analog input ranges
+/* analog input ranges */
 static const struct comedi_lrange range_das800_ai = {
 	1,
 	{
@@ -278,7 +278,7 @@ static int das800_probe(struct comedi_de
 	unsigned long irq_flags;
 	int board;
 
-	// 'comedi spin lock irqsave' disables even rt interrupts, we use them to protect indirect addressing
+	/*  'comedi spin lock irqsave' disables even rt interrupts, we use them to protect indirect addressing */
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(ID, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be ID register */
 	id_bits = inb(dev->iobase + DAS800_ID) & 0x3;	/* get id bits */
@@ -352,8 +352,8 @@ static irqreturn_t das800_interrupt(int 
 	struct comedi_async *async;
 	int status;
 	unsigned long irq_flags;
-	static const int max_loops = 128;	// half-fifo size for cio-das802/16
-	// flags
+	static const int max_loops = 128;	/*  half-fifo size for cio-das802/16 */
+	/*  flags */
 	int fifo_empty = 0;
 	int fifo_overflow = 0;
 
@@ -369,7 +369,7 @@ static irqreturn_t das800_interrupt(int 
 	 */
 	async = s->async;
 
-	// if hardware conversions are not enabled, then quit
+	/*  if hardware conversions are not enabled, then quit */
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
 	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
@@ -390,7 +390,7 @@ static irqreturn_t das800_interrupt(int 
 			if (fifo_overflow)
 				break;
 		} else {
-			fifo_empty = 0;	// cio-das802/16 has no fifo empty status bit
+			fifo_empty = 0;	/*  cio-das802/16 has no fifo empty status bit */
 		}
 		if (fifo_empty) {
 			break;
@@ -410,7 +410,7 @@ static irqreturn_t das800_interrupt(int 
 	/* check for fifo overflow */
 	if (thisboard->resolution == 12) {
 		fifo_overflow = dataPoint & FIFO_OVF;
-		// else cio-das802/16
+		/*  else cio-das802/16 */
 	} else {
 		fifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;
 	}
@@ -564,7 +564,7 @@ static void enable_das800(struct comedi_
 {
 	unsigned long irq_flags;
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
-	// enable fifo-half full interrupts for cio-das802/16
+	/*  enable fifo-half full interrupts for cio-das802/16 */
 	if (thisboard->resolution == 16)
 		outb(CIO_ENHF, dev->iobase + DAS800_GAIN);
 	outb(CONV_CONTROL, dev->iobase + DAS800_GAIN);	/* select dev->iobase + 2 to be conversion control register */
@@ -684,7 +684,7 @@ static int das800_ai_do_cmdtest(struct c
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist) {
 		gain = CR_RANGE(cmd->chanlist[0]);
 		startChan = CR_CHAN(cmd->chanlist[0]);
@@ -861,7 +861,7 @@ static int das800_do_wbits(struct comedi
 	int wbits;
 	unsigned long irq_flags;
 
-	// only set bits that have been masked
+	/*  only set bits that have been masked */
 	data[0] &= 0xf;
 	wbits = devpriv->do_bits >> 4;
 	wbits &= ~data[0];
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -394,7 +394,7 @@ static int dmm32at_attach(struct comedi_
  * it is, this is the place to do it.  Otherwise, dev->board_ptr
  * should already be initialized.
  */
-	//dev->board_ptr = dmm32at_probe(dev);
+	/* dev->board_ptr = dmm32at_probe(dev); */
 
 /*
  * Initialize dev->board_name.  Note that we can use the "thisboard"
@@ -512,7 +512,7 @@ static int dmm32at_ai_rinsn(struct comed
 	chan = CR_CHAN(insn->chanspec) & (s->n_chan - 1);
 	range = CR_RANGE(insn->chanspec);
 
-	//printk("channel=0x%02x, range=%d\n",chan,range);
+	/* printk("channel=0x%02x, range=%d\n",chan,range); */
 
 	/* zero scan and fifo control and reset fifo */
 	dmm_outb(dev, DMM32AT_FIFOCNTRL, DMM32AT_FIFORESET);
@@ -575,7 +575,7 @@ static int dmm32at_ai_cmdtest(struct com
 	int tmp;
 	int start_chan, gain, i;
 
-	//printk("dmmat32 in command test\n");
+	/* printk("dmmat32 in command test\n"); */
 
 	/* cmdtest tests a particular command to see if it is valid.
 	 * Using the cmdtest ioctl, a user can create a valid cmd
@@ -910,7 +910,7 @@ static int dmm32at_ao_winsn(struct comed
 		lo = data[i] & 0x00ff;
 		/* high byte also contains channel number */
 		hi = (data[i] >> 8) + chan * (1 << 6);
-		//printk("writing 0x%02x  0x%02x\n",hi,lo);
+		/* printk("writing 0x%02x  0x%02x\n",hi,lo); */
 		/* write the low and high values to the board */
 		dmm_outb(dev, DMM32AT_DACLSB, lo);
 		dmm_outb(dev, DMM32AT_DACMSB, hi);
@@ -967,7 +967,7 @@ static int dmm32at_dio_insn_bits(struct 
 		s->state &= ~data[0];
 		s->state |= data[0] & data[1];
 		/* Write out the new digital output lines */
-		//outw(s->state,dev->iobase + DMM32AT_DIO);
+		/* outw(s->state,dev->iobase + DMM32AT_DIO); */
 	}
 
 	/* get access to the DIO regs */
@@ -998,10 +998,10 @@ static int dmm32at_dio_insn_bits(struct 
 
 	/* on return, data[1] contains the value of the digital
 	 * input and output lines. */
-	//data[1]=inw(dev->iobase + DMM32AT_DIO);
+	/* data[1]=inw(dev->iobase + DMM32AT_DIO); */
 	/* or we could just return the software copy of the output values if
 	 * it was a purely digital output subdevice */
-	//data[1]=s->state;
+	/* data[1]=s->state; */
 
 	return 2;
 }
--- a/drivers/staging/comedi/drivers/dt2801.c
+++ b/drivers/staging/comedi/drivers/dt2801.c
@@ -100,7 +100,7 @@ static struct comedi_driver driver_dt280
 COMEDI_INITCLEANUP(driver_dt2801);
 
 #if 0
-// ignore 'defined but not used' warning
+/* ignore 'defined but not used' warning */
 static const struct comedi_lrange range_dt2801_ai_pgh_bipolar = { 4, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
@@ -118,7 +118,7 @@ static const struct comedi_lrange range_
 };
 
 #if 0
-// ignore 'defined but not used' warning
+/* ignore 'defined but not used' warning */
 static const struct comedi_lrange range_dt2801_ai_pgh_unipolar = { 4, {
 			RANGE(0, 10),
 			RANGE(0, 5),
@@ -381,10 +381,10 @@ static int dt2801_reset(struct comedi_de
 	inb_p(dev->iobase + DT2801_DATA);
 
 	DPRINTK("dt2801: stop\n");
-	//dt2801_writecmd(dev,DT_C_STOP);
+	/* dt2801_writecmd(dev,DT_C_STOP); */
 	outb_p(DT_C_STOP, dev->iobase + DT2801_CMD);
 
-	//dt2801_wait_for_ready(dev);
+	/* dt2801_wait_for_ready(dev); */
 	comedi_udelay(100);
 	timeout = 10000;
 	do {
@@ -395,12 +395,13 @@ static int dt2801_reset(struct comedi_de
 	if (!timeout) {
 		printk("dt2801: timeout 1 status=0x%02x\n", stat);
 	}
-	//printk("dt2801: reading dummy\n");
-	//dt2801_readdata(dev,&board_code);
+
+	/* printk("dt2801: reading dummy\n"); */
+	/* dt2801_readdata(dev,&board_code); */
 
 	DPRINTK("dt2801: reset\n");
 	outb_p(DT_C_RESET, dev->iobase + DT2801_CMD);
-	//dt2801_writecmd(dev,DT_C_RESET);
+	/* dt2801_writecmd(dev,DT_C_RESET); */
 
 	comedi_udelay(100);
 	timeout = 10000;
--- a/drivers/staging/comedi/drivers/dt2811.c
+++ b/drivers/staging/comedi/drivers/dt2811.c
@@ -313,9 +313,10 @@ static irqreturn_t dt2811_interrupt(int 
 
 static int dt2811_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
-	//int i, irq;
-	//unsigned long irqs;
-	//long flags;
+	/* int i, irq; */
+	/* unsigned long irqs; */
+	/* long flags; */
+
 	int ret;
 	struct comedi_subdevice *s;
 	unsigned long iobase;
@@ -531,7 +532,7 @@ int dt2811_adtrig(kdev_t minor, comedi_a
 	case COMEDI_MDEMAND:
 		dev->ntrig = adtrig->n - 1;
 		/*printk("dt2811: AD soft trigger\n"); */
-		/*outb(DT2811_CLRERROR|DT2811_INTENB,dev->iobase+DT2811_ADCSR); *//* not neccessary */
+		/*outb(DT2811_CLRERROR|DT2811_INTENB,dev->iobase+DT2811_ADCSR); */ /* not neccessary */
 		outb(dev->curadchan, dev->iobase + DT2811_ADGCR);
 		do_gettimeofday(&trigtime);
 		break;
--- a/drivers/staging/comedi/drivers/dt3000.c
+++ b/drivers/staging/comedi/drivers/dt3000.c
@@ -345,8 +345,8 @@ static void dt3k_writesingle(struct come
 
 static int debug_n_ints = 0;
 
-// FIXME! Assumes shared interrupt is for this card.
-// What's this debug_n_ints stuff? Obviously needs some work...
+/* FIXME! Assumes shared interrupt is for this card. */
+/* What's this debug_n_ints stuff? Obviously needs some work... */
 static irqreturn_t dt3k_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
--- a/drivers/staging/comedi/drivers/jr3_pci.c
+++ b/drivers/staging/comedi/drivers/jr3_pci.c
@@ -194,7 +194,7 @@ static void set_transforms(volatile stru
 {
 	int i;
 
-	num &= 0x000f;		// Make sure that 0 <= num <= 15
+	num &= 0x000f;		/*  Make sure that 0 <= num <= 15 */
 	for (i = 0; i < 8; i++) {
 
 		set_u16(&channel->transforms[num].link[i].link_type,
@@ -410,10 +410,10 @@ int read_idm_word(const u8 * data, size_
 {
 	int result = 0;
 	if (pos != 0 && val != 0) {
-		// Skip over non hex
+		/*  Skip over non hex */
 		for (; *pos < size && !isxdigit(data[*pos]); (*pos)++) {
 		}
-		// Collect value
+		/*  Collect value */
 		*val = 0;
 		for (; *pos < size && isxdigit(data[*pos]); (*pos)++) {
 			char ch = tolower(data[*pos]);
@@ -485,17 +485,17 @@ static int jr3_download_firmware(struct 
 					count, addr);
 				while (more && count > 0) {
 					if (addr & 0x4000) {
-						// 16 bit data, never seen in real life!!
+						/*  16 bit data, never seen in real life!! */
 						unsigned int data1;
 
 						more = more
 							&& read_idm_word(data,
 							size, &pos, &data1);
 						count--;
-						// printk("jr3_data, not tested\n");
-						//        jr3[addr + 0x20000 * pnum] = data1;
+						/* printk("jr3_data, not tested\n"); */
+						/* jr3[addr + 0x20000 * pnum] = data1; */
 					} else {
-						//  Download 24 bit program
+						/*   Download 24 bit program */
 						unsigned int data1, data2;
 
 						more = more
@@ -541,7 +541,7 @@ static struct poll_delay_t jr3_pci_poll_
 			p->errors = errors;
 		}
 		if (errors & (watch_dog | watch_dog2 | sensor_change)) {
-			// Sensor communication lost, force poll mode
+			/*  Sensor communication lost, force poll mode */
 			p->state = state_jr3_poll;
 
 		}
@@ -551,9 +551,10 @@ static struct poll_delay_t jr3_pci_poll_
 				u16 serial_no = get_u16(&channel->serial_no);
 				if ((errors & (watch_dog | watch_dog2)) ||
 					model_no == 0 || serial_no == 0) {
-					// Still no sensor, keep on polling. Since it takes up to
-					// 10 seconds for offsets to stabilize, polling each
-					// second should suffice.
+/*
+ * Still no sensor, keep on polling. Since it takes up to 10 seconds
+ * for offsets to stabilize, polling each second should suffice.
+ */
 					result = poll_delay_min_max(1000, 2000);
 				} else {
 					p->retries = 0;
@@ -566,7 +567,7 @@ static struct poll_delay_t jr3_pci_poll_
 		case state_jr3_init_wait_for_offset:{
 				p->retries++;
 				if (p->retries < 10) {
-					// Wait for offeset to stabilize (< 10 s according to manual)
+					/*  Wait for offeset to stabilize (< 10 s according to manual) */
 					result = poll_delay_min_max(1000, 2000);
 				} else {
 					struct transform_t transf;
@@ -582,7 +583,7 @@ static struct poll_delay_t jr3_pci_poll_
 					printk("Sensor Serial    = %i\n",
 						p->serial_no);
 
-					// Transformation all zeros
+					/*  Transformation all zeros */
 					transf.link[0].link_type =
 						(enum link_types)0;
 					transf.link[0].link_amount = 0;
@@ -600,7 +601,7 @@ static struct poll_delay_t jr3_pci_poll_
 					use_transform(channel, 0);
 					p->state =
 						state_jr3_init_transform_complete;
-					result = poll_delay_min_max(20, 100);	// Allow 20 ms for completion
+					result = poll_delay_min_max(20, 100);	/*  Allow 20 ms for completion */
 				}
 			} break;
 		case state_jr3_init_transform_complete:{
@@ -608,7 +609,7 @@ static struct poll_delay_t jr3_pci_poll_
 					printk("state_jr3_init_transform_complete complete = %d\n", is_complete(channel));
 					result = poll_delay_min_max(20, 100);
 				} else {
-					// Set full scale
+					/*  Set full scale */
 					struct six_axis_t min_full_scale;
 					struct six_axis_t max_full_scale;
 
@@ -639,7 +640,7 @@ static struct poll_delay_t jr3_pci_poll_
 
 					p->state =
 						state_jr3_init_set_full_scale_complete;
-					result = poll_delay_min_max(20, 100);	// Allow 20 ms for completion
+					result = poll_delay_min_max(20, 100);	/*  Allow 20 ms for completion */
 				}
 			}
 			break;
@@ -650,7 +651,7 @@ static struct poll_delay_t jr3_pci_poll_
 				} else {
 					volatile struct force_array *full_scale;
 
-					// Use ranges in kN or we will overflow arount 2000N!
+					/*  Use ranges in kN or we will overflow arount 2000N! */
 					full_scale = &channel->full_scale;
 					p->range[0].range.min =
 						-get_s16(&full_scale->fx) *
@@ -679,10 +680,10 @@ static struct poll_delay_t jr3_pci_poll_
 						-get_s16(&full_scale->mz) * 100;
 					p->range[5].range.max =
 						get_s16(&full_scale->mz) * 100;
-					p->range[6].range.min = -get_s16(&full_scale->v1) * 100;	// ??
-					p->range[6].range.max = get_s16(&full_scale->v1) * 100;	// ??
-					p->range[7].range.min = -get_s16(&full_scale->v2) * 100;	// ??
-					p->range[7].range.max = get_s16(&full_scale->v2) * 100;	// ??
+					p->range[6].range.min = -get_s16(&full_scale->v1) * 100;	/*  ?? */
+					p->range[6].range.max = get_s16(&full_scale->v1) * 100;	/*  ?? */
+					p->range[7].range.min = -get_s16(&full_scale->v2) * 100;	/*  ?? */
+					p->range[7].range.max = get_s16(&full_scale->v2) * 100;	/*  ?? */
 					p->range[8].range.min = 0;
 					p->range[8].range.max = 65535;
 
@@ -701,7 +702,7 @@ static struct poll_delay_t jr3_pci_poll_
 					use_offset(channel, 0);
 					p->state =
 						state_jr3_init_use_offset_complete;
-					result = poll_delay_min_max(40, 100);	// Allow 40 ms for completion
+					result = poll_delay_min_max(40, 100);	/*  Allow 40 ms for completion */
 				}
 			}
 			break;
@@ -750,7 +751,7 @@ static void jr3_pci_poll_dev(unsigned lo
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	delay = 1000;
 	now = jiffies;
-	// Poll all channels that are ready to be polled
+	/*  Poll all channels that are ready to be polled */
 	for (i = 0; i < devpriv->n_channels; i++) {
 		struct jr3_pci_subdev_private *subdevpriv = dev->subdevices[i].private;
 		if (now > subdevpriv->next_time_min) {
@@ -762,8 +763,10 @@ static void jr3_pci_poll_dev(unsigned lo
 			subdevpriv->next_time_max =
 				jiffies + msecs_to_jiffies(sub_delay.max);
 			if (sub_delay.max && sub_delay.max < delay) {
-				// Wake up as late as possible -> poll as many channels as
-				// possible at once
+/*
+* Wake up as late as possible -> poll as many channels as possible
+* at once
+*/
 				delay = sub_delay.max;
 			}
 		}
@@ -895,7 +898,7 @@ static int jr3_pci_attach(struct comedi_
 				(struct comedi_lrange *) & p->range[8];
 			p->maxdata_list[56] = 0xffff;
 			p->maxdata_list[57] = 0xffff;
-			// Channel specific range and maxdata
+			/*  Channel specific range and maxdata */
 			dev->subdevices[i].range_table = 0;
 			dev->subdevices[i].range_table_list =
 				p->range_table_list;
@@ -904,7 +907,7 @@ static int jr3_pci_attach(struct comedi_
 		}
 	}
 
-	// Reset DSP card
+	/*  Reset DSP card */
 	devpriv->iobase->channel[0].reset = 0;
 
 	result = comedi_load_firmware(dev, "jr3pci.idm", jr3_download_firmware);
@@ -913,13 +916,18 @@ static int jr3_pci_attach(struct comedi_
 	if (result < 0) {
 		goto out;
 	}
-	// TODO: use firmware to load preferred offset tables. Suggested format:
-	// model serial Fx Fy Fz Mx My Mz\n
-	//
-	// comedi_load_firmware(dev, "jr3_offsets_table", jr3_download_firmware);
-
-	// It takes a few milliseconds for software to settle
-	// as much as we can read firmware version
+/*
+ * TODO: use firmware to load preferred offset tables. Suggested
+ * format:
+ *     model serial Fx Fy Fz Mx My Mz\n
+ *
+ *     comedi_load_firmware(dev, "jr3_offsets_table", jr3_download_firmware);
+ */
+
+/*
+ * It takes a few milliseconds for software to settle as much as we
+ * can read firmware version
+ */
 	msleep_interruptible(25);
 	for (i = 0; i < 0x18; i++) {
 		printk("%c",
@@ -927,7 +935,7 @@ static int jr3_pci_attach(struct comedi_
 				copyright[i]) >> 8);
 	}
 
-	// Start card timer
+	/*  Start card timer */
 	for (i = 0; i < devpriv->n_channels; i++) {
 		struct jr3_pci_subdev_private *p = dev->subdevices[i].private;
 
--- a/drivers/staging/comedi/drivers/ke_counter.c
+++ b/drivers/staging/comedi/drivers/ke_counter.c
@@ -227,10 +227,10 @@ static int cnt_attach(struct comedi_devi
 	subdevice->insn_read = cnt_rinsn;
 	subdevice->insn_write = cnt_winsn;
 
-	// select 20MHz clock
+	/*  select 20MHz clock */
 	outb(3, dev->iobase + 248);
 
-	// reset all counters
+	/*  reset all counters */
 	outb(0, dev->iobase);
 	outb(0, dev->iobase + 0x20);
 	outb(0, dev->iobase + 0x40);
--- a/drivers/staging/comedi/drivers/ni_6527.c
+++ b/drivers/staging/comedi/drivers/ni_6527.c
@@ -311,7 +311,7 @@ static int ni6527_intr_cmdtest(struct co
 
 static int ni6527_intr_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	//struct comedi_cmd *cmd = &s->async->cmd;
+	/* struct comedi_cmd *cmd = &s->async->cmd; */
 
 	writeb(ClrEdge | ClrOverflow,
 		devpriv->mite->daq_io_addr + Clear_Register);
--- a/drivers/staging/comedi/drivers/ni_65xx.c
+++ b/drivers/staging/comedi/drivers/ni_65xx.c
@@ -437,12 +437,12 @@ static int ni_65xx_dio_insn_bits(struct 
 			writeb(bits,
 				private(dev)->mite->daq_io_addr +
 				Port_Data(port));
-//                      rt_printk("wrote 0x%x to port %i\n", bits, port);
+/* rt_printk("wrote 0x%x to port %i\n", bits, port); */
 		}
 		port_read_bits =
 			readb(private(dev)->mite->daq_io_addr +
 			Port_Data(port));
-//              rt_printk("read 0x%x from port %i\n", port_read_bits, port);
+/* rt_printk("read 0x%x from port %i\n", port_read_bits, port); */
 		if (bitshift > 0) {
 			port_read_bits <<= bitshift;
 		} else {
@@ -553,7 +553,7 @@ static int ni_65xx_intr_cmdtest(struct c
 
 static int ni_65xx_intr_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	//struct comedi_cmd *cmd = &s->async->cmd;
+	/* struct comedi_cmd *cmd = &s->async->cmd; */
 
 	writeb(ClrEdge | ClrOverflow,
 		private(dev)->mite->daq_io_addr + Clear_Register);
@@ -700,7 +700,7 @@ static int ni_65xx_attach(struct comedi_
 			return -ENOMEM;
 		sprivate(s)->base_port = 0;
 		for (i = 0; i < board(dev)->num_dio_ports; ++i) {
-			// configure all ports for input
+			/*  configure all ports for input */
 			writeb(0x1,
 				private(dev)->mite->daq_io_addr +
 				Port_Select(i));
--- a/drivers/staging/comedi/drivers/ni_660x.c
+++ b/drivers/staging/comedi/drivers/ni_660x.c
@@ -51,7 +51,7 @@ enum ni_660x_constants {
 };
 
 #define NUM_PFI_CHANNELS 40
-// really there are only up to 3 dma channels, but the register layout allows for 4
+/* really there are only up to 3 dma channels, but the register layout allows for 4 */
 #define MAX_DMA_CHANNEL 4
 
 /* See Register-Level Programmer Manual page 3.1 */
@@ -194,10 +194,10 @@ static inline unsigned NI_660X_GPCT_SUBD
 
 struct NI_660xRegisterData {
 
-	const char *name;	// Register Name
-	int offset;		// Offset from base address from GPCT chip
+	const char *name;	/*  Register Name */
+	int offset;		/*  Offset from base address from GPCT chip */
 	enum ni_660x_register_direction direction;
-	enum ni_660x_register_width size;	// 1 byte, 2 bytes, or 4 bytes
+	enum ni_660x_register_width size;	/*  1 byte, 2 bytes, or 4 bytes */
 };
 
 
@@ -302,12 +302,12 @@ static const struct NI_660xRegisterData 
 	{"IO Config Register 38-39", 0x7A2, NI_660x_READ_WRITE, DATA_2B}
 };
 
-// kind of ENABLE for the second counter
+/* kind of ENABLE for the second counter */
 enum clock_config_register_bits {
 	CounterSwap = 0x1 << 21
 };
 
-// ioconfigreg
+/* ioconfigreg */
 static inline unsigned ioconfig_bitshift(unsigned pfi_channel)
 {
 	if (pfi_channel % 2)
@@ -334,7 +334,7 @@ static inline unsigned pfi_input_select_
 	return (input_select & 0x7) << (4 + ioconfig_bitshift(pfi_channel));
 }
 
-// dma configuration register bits
+/* dma configuration register bits */
 static inline unsigned dma_select_mask(unsigned dma_channel)
 {
 	BUG_ON(dma_channel >= MAX_DMA_CHANNEL);
@@ -374,7 +374,7 @@ enum global_interrupt_config_register_bi
 	Global_Int_Enable_Bit = 0x80000000
 };
 
-// Offset of the GPCT chips from the base-adress of the card
+/* Offset of the GPCT chips from the base-adress of the card */
 static const unsigned GPCT_OFFSET[2] = { 0x0, 0x800 };	/* First chip is at base-address +
 							   0x00, etc. */
 
@@ -850,7 +850,7 @@ static int ni_660x_cmd(struct comedi_dev
 	int retval;
 
 	struct ni_gpct *counter = subdev_to_counter(s);
-//      const struct comedi_cmd *cmd = &s->async->cmd;
+/* const struct comedi_cmd *cmd = &s->async->cmd; */
 
 	retval = ni_660x_request_mite_channel(dev, counter, COMEDI_INPUT);
 	if (retval) {
@@ -1031,7 +1031,7 @@ static int ni_660x_attach(struct comedi_
 	s->insn_bits = ni_660x_dio_insn_bits;
 	s->insn_config = ni_660x_dio_insn_config;
 	s->io_bits = 0;		/* all bits default to input */
-	// we use the ioconfig registers to control dio direction, so zero output enables in stc dio control reg
+	/*  we use the ioconfig registers to control dio direction, so zero output enables in stc dio control reg */
 	ni_660x_write_register(dev, 0, 0, STCDIOControl);
 
 	private(dev)->counter_dev = ni_gpct_device_construct(dev,
@@ -1132,7 +1132,7 @@ static void init_tio_chip(struct comedi_
 {
 	unsigned i;
 
-	// init dma configuration register
+	/*  init dma configuration register */
 	private(dev)->dma_configuration_soft_copies[chipset] = 0;
 	for (i = 0; i < MAX_DMA_CHANNEL; ++i) {
 		private(dev)->dma_configuration_soft_copies[chipset] |=
@@ -1193,7 +1193,7 @@ static int ni_660x_dio_insn_bits(struct 
 {
 	unsigned base_bitfield_channel = CR_CHAN(insn->chanspec);
 
-	// Check if we have to write some bits
+	/*  Check if we have to write some bits */
 	if (data[0]) {
 		s->state &= ~(data[0] << base_bitfield_channel);
 		s->state |= (data[0] & data[1]) << base_bitfield_channel;
--- a/drivers/staging/comedi/drivers/ni_670x.c
+++ b/drivers/staging/comedi/drivers/ni_670x.c
@@ -91,7 +91,7 @@ static const struct ni_670x_board ni_670
 static DEFINE_PCI_DEVICE_TABLE(ni_670x_pci_table) = {
 	{PCI_VENDOR_ID_NATINST, 0x2c90, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_NATINST, 0x1920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	//{ PCI_VENDOR_ID_NATINST, 0x0000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	/* { PCI_VENDOR_ID_NATINST, 0x0000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
 	{0}
 };
 
--- a/drivers/staging/comedi/drivers/ni_at_ao.c
+++ b/drivers/staging/comedi/drivers/ni_at_ao.c
@@ -229,7 +229,7 @@ static int atao_attach(struct comedi_dev
 	}
 	dev->iobase = iobase;
 
-	//dev->board_ptr = atao_probe(dev);
+	/* dev->board_ptr = atao_probe(dev); */
 
 	dev->board_name = thisboard->name;
 
@@ -273,7 +273,7 @@ static int atao_attach(struct comedi_dev
 
 	s = dev->subdevices + 3;
 	/* eeprom subdevice */
-	//s->type=COMEDI_SUBD_EEPROM;
+	/* s->type=COMEDI_SUBD_EEPROM; */
 	s->type = COMEDI_SUBD_UNUSED;
 
 	atao_reset(dev);
--- a/drivers/staging/comedi/drivers/ni_atmio16d.c
+++ b/drivers/staging/comedi/drivers/ni_atmio16d.c
@@ -262,7 +262,7 @@ static irqreturn_t atmio16d_interrupt(in
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->subdevices + 0;
 
-//      printk("atmio16d_interrupt!\n");
+/* printk("atmio16d_interrupt!\n"); */
 
 	comedi_buf_put(s->async, inw(dev->iobase + AD_FIFO_REG));
 
@@ -542,9 +542,9 @@ static int atmio16d_ai_insn_read(struct 
 	gain = CR_RANGE(insn->chanspec);
 
 	/* reset the Analog input circuitry */
-	//outw( 0, dev->iobase+AD_CLEAR_REG );
+	/* outw( 0, dev->iobase+AD_CLEAR_REG ); */
 	/* reset the Analog Input MUX Counter to 0 */
-	//outw( 0, dev->iobase+MUX_CNTR_REG );
+	/* outw( 0, dev->iobase+MUX_CNTR_REG ); */
 
 	/* set the Input MUX gain */
 	outw(chan | (gain << 6), dev->iobase + MUX_GAIN_REG);
--- a/drivers/staging/comedi/drivers/ni_daq_700.c
+++ b/drivers/staging/comedi/drivers/ni_daq_700.c
@@ -53,7 +53,7 @@ IRQ is assigned but not used.
 
 static struct pcmcia_device *pcmcia_cur_dev = NULL;
 
-#define DIO700_SIZE 8		// size of io region used by board
+#define DIO700_SIZE 8		/*  size of io region used by board */
 
 static int dio700_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int dio700_detach(struct comedi_device * dev);
@@ -62,11 +62,11 @@ enum dio700_bustype { pcmcia_bustype };
 
 struct dio700_board {
 	const char *name;
-	int device_id;		// device id for pcmcia board
-	enum dio700_bustype bustype;	// PCMCIA
-	int have_dio;		// have daqcard-700 dio
-	// function pointers so we can use inb/outb or readb/writeb
-	// as appropriate
+	int device_id;		/*  device id for pcmcia board */
+	enum dio700_bustype bustype;	/*  PCMCIA */
+	int have_dio;		/*  have daqcard-700 dio */
+	/*  function pointers so we can use inb/outb or readb/writeb */
+	/*  as appropriate */
 	unsigned int (*read_byte) (unsigned int address);
 	void (*write_byte) (unsigned int byte, unsigned int address);
 };
@@ -74,13 +74,13 @@ struct dio700_board {
 static const struct dio700_board dio700_boards[] = {
 	{
 	      name:	"daqcard-700",
-	      device_id:0x4743,// 0x10b is manufacturer id, 0x4743 is device id
+	      device_id:0x4743,/*  0x10b is manufacturer id, 0x4743 is device id */
 	      bustype:	pcmcia_bustype,
 	      have_dio:1,
 		},
 	{
 	      name:	"ni_daq_700",
-	      device_id:0x4743,// 0x10b is manufacturer id, 0x4743 is device id
+	      device_id:0x4743,/*  0x10b is manufacturer id, 0x4743 is device id */
 	      bustype:	pcmcia_bustype,
 	      have_dio:1,
 		},
@@ -365,7 +365,7 @@ static int dio700_attach(struct comedi_d
 	if (alloc_private(dev, sizeof(struct dio700_private)) < 0)
 		return -ENOMEM;
 
-	// get base address, irq etc. based on bustype
+	/*  get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
 	case pcmcia_bustype:
 		link = pcmcia_cur_dev;	/* XXX hack */
@@ -430,7 +430,7 @@ static int dio700_detach(struct comedi_d
 	return 0;
 };
 
-// PCMCIA crap
+/* PCMCIA crap */
 
 /*
    All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If
--- a/drivers/staging/comedi/drivers/ni_daq_dio24.c
+++ b/drivers/staging/comedi/drivers/ni_daq_dio24.c
@@ -37,7 +37,7 @@ This is just a wrapper around the 8255.o
 the PCMCIA interface.
 */
 
-//#define LABPC_DEBUG   // enable debugging messages
+/* #define LABPC_DEBUG   /*  enable debugging messages */ */
 #undef LABPC_DEBUG
 
 #include "../comedidev.h"
@@ -54,7 +54,7 @@ the PCMCIA interface.
 
 static struct pcmcia_device *pcmcia_cur_dev = NULL;
 
-#define DIO24_SIZE 4		// size of io region used by board
+#define DIO24_SIZE 4		/*  size of io region used by board */
 
 static int dio24_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int dio24_detach(struct comedi_device * dev);
@@ -63,10 +63,10 @@ enum dio24_bustype { pcmcia_bustype };
 
 struct dio24_board_struct {
 	const char *name;
-	int device_id;		// device id for pcmcia board
-	enum dio24_bustype bustype;	// PCMCIA
-	int have_dio;		// have 8255 chip
-	// function pointers so we can use inb/outb or readb/writeb as appropriate
+	int device_id;		/*  device id for pcmcia board */
+	enum dio24_bustype bustype;	/*  PCMCIA */
+	int have_dio;		/*  have 8255 chip */
+	/*  function pointers so we can use inb/outb or readb/writeb as appropriate */
 	unsigned int (*read_byte) (unsigned int address);
 	void (*write_byte) (unsigned int byte, unsigned int address);
 };
@@ -74,13 +74,13 @@ struct dio24_board_struct {
 static const struct dio24_board_struct dio24_boards[] = {
 	{
 	      name:	"daqcard-dio24",
-	      device_id:0x475c,// 0x10b is manufacturer id, 0x475c is device id
+	      device_id:0x475c,/*  0x10b is manufacturer id, 0x475c is device id */
 	      bustype:	pcmcia_bustype,
 	      have_dio:1,
 		},
 	{
 	      name:	"ni_daq_dio24",
-	      device_id:0x475c,// 0x10b is manufacturer id, 0x475c is device id
+	      device_id:0x475c,/*  0x10b is manufacturer id, 0x475c is device id */
 	      bustype:	pcmcia_bustype,
 	      have_dio:1,
 		},
@@ -122,7 +122,7 @@ static int dio24_attach(struct comedi_de
 	if (alloc_private(dev, sizeof(struct dio24_private)) < 0)
 		return -ENOMEM;
 
-	// get base address, irq etc. based on bustype
+	/*  get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
 	case pcmcia_bustype:
 		link = pcmcia_cur_dev;	/* XXX hack */
@@ -187,7 +187,7 @@ static int dio24_detach(struct comedi_de
 	return 0;
 };
 
-// PCMCIA crap
+/* PCMCIA crap */
 
 /*
    All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If
--- a/drivers/staging/comedi/drivers/ni_labpc_cs.c
+++ b/drivers/staging/comedi/drivers/ni_labpc_cs.c
@@ -60,7 +60,7 @@ NI manuals:
 */
 
 #undef LABPC_DEBUG
-//#define LABPC_DEBUG   // enable debugging messages
+/* #define LABPC_DEBUG   /*  enable debugging messages */ */
 
 #include "../comedidev.h"
 
@@ -84,7 +84,7 @@ static int labpc_attach(struct comedi_de
 static const struct labpc_board_struct labpc_cs_boards[] = {
 	{
 	      name:	"daqcard-1200",
-	      device_id:0x103,	// 0x10b is manufacturer id, 0x103 is device id
+	      device_id:0x103,	/*  0x10b is manufacturer id, 0x103 is device id */
 	      ai_speed:10000,
 	      bustype:	pcmcia_bustype,
 	      register_layout:labpc_1200_layout,
@@ -136,7 +136,7 @@ static int labpc_attach(struct comedi_de
 	if (alloc_private(dev, sizeof(struct labpc_private)) < 0)
 		return -ENOMEM;
 
-	// get base address, irq etc. based on bustype
+	/*  get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
 	case pcmcia_bustype:
 		link = pcmcia_cur_dev;	/* XXX hack */
--- a/drivers/staging/comedi/drivers/ni_labpc.h
+++ b/drivers/staging/comedi/drivers/ni_labpc.h
@@ -24,8 +24,8 @@
 #ifndef _NI_LABPC_H
 #define _NI_LABPC_H
 
-#define EEPROM_SIZE	256	// 256 byte eeprom
-#define NUM_AO_CHAN	2	// boards have two analog output channels
+#define EEPROM_SIZE	256	/*  256 byte eeprom */
+#define NUM_AO_CHAN	2	/*  boards have two analog output channels */
 
 enum labpc_bustype { isa_bustype, pci_bustype, pcmcia_bustype };
 enum labpc_register_layout { labpc_plus_layout, labpc_1200_layout };
@@ -34,42 +34,42 @@ enum transfer_type { fifo_not_empty_tran
 
 struct labpc_board_struct {
 	const char *name;
-	int device_id;		// device id for pci and pcmcia boards
-	int ai_speed;		// maximum input speed in nanoseconds
-	enum labpc_bustype bustype;	// ISA/PCI/etc.
-	enum labpc_register_layout register_layout;	// 1200 has extra registers compared to pc+
-	int has_ao;		// has analog output true/false
+	int device_id;		/*  device id for pci and pcmcia boards */
+	int ai_speed;		/*  maximum input speed in nanoseconds */
+	enum labpc_bustype bustype;	/*  ISA/PCI/etc. */
+	enum labpc_register_layout register_layout;	/*  1200 has extra registers compared to pc+ */
+	int has_ao;		/*  has analog output true/false */
 	const struct comedi_lrange *ai_range_table;
 	const int *ai_range_code;
 	const int *ai_range_is_unipolar;
-	unsigned ai_scan_up:1;	// board can auto scan up in ai channels, not just down
+	unsigned ai_scan_up:1;	/*  board can auto scan up in ai channels, not just down */
 	unsigned memory_mapped_io:1;	/* uses memory mapped io instead of ioports */
 };
 
 struct labpc_private {
-	struct mite_struct *mite;	// for mite chip on pci-1200
+	struct mite_struct *mite;	/*  for mite chip on pci-1200 */
 	volatile unsigned long long count;	/* number of data points left to be taken */
-	unsigned int ao_value[NUM_AO_CHAN];	// software copy of analog output values
-	// software copys of bits written to command registers
+	unsigned int ao_value[NUM_AO_CHAN];	/*  software copy of analog output values */
+	/*  software copys of bits written to command registers */
 	volatile unsigned int command1_bits;
 	volatile unsigned int command2_bits;
 	volatile unsigned int command3_bits;
 	volatile unsigned int command4_bits;
 	volatile unsigned int command5_bits;
 	volatile unsigned int command6_bits;
-	// store last read of board status registers
+	/*  store last read of board status registers */
 	volatile unsigned int status1_bits;
 	volatile unsigned int status2_bits;
 	unsigned int divisor_a0;	/* value to load into board's counter a0 (conversion pacing) for timed conversions */
 	unsigned int divisor_b0;	/* value to load into board's counter b0 (master) for timed conversions */
 	unsigned int divisor_b1;	/* value to load into board's counter b1 (scan pacing) for timed conversions */
-	unsigned int dma_chan;	// dma channel to use
-	u16 *dma_buffer;	// buffer ai will dma into
-	unsigned int dma_transfer_size;	// transfer size in bytes for current transfer
-	enum transfer_type current_transfer;	// we are using dma/fifo-half-full/etc.
-	unsigned int eeprom_data[EEPROM_SIZE];	// stores contents of board's eeprom
-	unsigned int caldac[16];	// stores settings of calibration dacs
-	// function pointers so we can use inb/outb or readb/writeb as appropriate
+	unsigned int dma_chan;	/*  dma channel to use */
+	u16 *dma_buffer;	/*  buffer ai will dma into */
+	unsigned int dma_transfer_size;	/*  transfer size in bytes for current transfer */
+	enum transfer_type current_transfer;	/*  we are using dma/fifo-half-full/etc. */
+	unsigned int eeprom_data[EEPROM_SIZE];	/*  stores contents of board's eeprom */
+	unsigned int caldac[16];	/*  stores settings of calibration dacs */
+	/*  function pointers so we can use inb/outb or readb/writeb as appropriate */
 	unsigned int (*read_byte) (unsigned long address);
 	void (*write_byte) (unsigned int byte, unsigned long address);
 };
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -57,9 +57,9 @@
 		fully tested as yet. Terry Barnaby, BEAM Ltd.
 */
 
-//#define DEBUG_INTERRUPT
-//#define DEBUG_STATUS_A
-//#define DEBUG_STATUS_B
+/* #define DEBUG_INTERRUPT */
+/* #define DEBUG_STATUS_A */
+/* #define DEBUG_STATUS_B */
 
 #include "8255.h"
 #include "mite.h"
@@ -410,7 +410,7 @@ static int ni_ai_drain_dma(struct comedi
 
 /* DMA channel setup */
 
-// negative channel means no channel
+/* negative channel means no channel */
 static inline void ni_set_ai_dma_channel(struct comedi_device * dev, int channel)
 {
 	unsigned bitfield;
@@ -425,7 +425,7 @@ static inline void ni_set_ai_dma_channel
 	ni_set_bitfield(dev, AI_AO_Select, AI_DMA_Select_Mask, bitfield);
 }
 
-// negative channel means no channel
+/* negative channel means no channel */
 static inline void ni_set_ao_dma_channel(struct comedi_device * dev, int channel)
 {
 	unsigned bitfield;
@@ -440,7 +440,7 @@ static inline void ni_set_ao_dma_channel
 	ni_set_bitfield(dev, AI_AO_Select, AO_DMA_Select_Mask, bitfield);
 }
 
-// negative mite_channel means no channel
+/* negative mite_channel means no channel */
 static inline void ni_set_gpct_dma_channel(struct comedi_device * dev,
 	unsigned gpct_index, int mite_channel)
 {
@@ -455,7 +455,7 @@ static inline void ni_set_gpct_dma_chann
 		bitfield);
 }
 
-// negative mite_channel means no channel
+/* negative mite_channel means no channel */
 static inline void ni_set_cdo_dma_channel(struct comedi_device * dev, int mite_channel)
 {
 	unsigned long flags;
@@ -544,7 +544,7 @@ static int ni_request_gpct_mite_channel(
 	return 0;
 }
 
-#endif // PCIDMA
+#endif /*  PCIDMA */
 
 static int ni_request_cdo_mite_channel(struct comedi_device * dev)
 {
@@ -565,7 +565,7 @@ static int ni_request_cdo_mite_channel(s
 	devpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;
 	ni_set_cdo_dma_channel(dev, devpriv->cdo_mite_chan->channel);
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 	return 0;
 }
 
@@ -581,7 +581,7 @@ static void ni_release_ai_mite_channel(s
 		devpriv->ai_mite_chan = NULL;
 	}
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 }
 
 static void ni_release_ao_mite_channel(struct comedi_device * dev)
@@ -596,7 +596,7 @@ static void ni_release_ao_mite_channel(s
 		devpriv->ao_mite_chan = NULL;
 	}
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 }
 
 void ni_release_gpct_mite_channel(struct comedi_device * dev, unsigned gpct_index)
@@ -616,7 +616,7 @@ void ni_release_gpct_mite_channel(struct
 		mite_release_channel(mite_chan);
 	}
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 }
 
 static void ni_release_cdo_mite_channel(struct comedi_device * dev)
@@ -631,10 +631,10 @@ static void ni_release_cdo_mite_channel(
 		devpriv->cdo_mite_chan = NULL;
 	}
 	comedi_spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);
-#endif // PCIDMA
+#endif /*  PCIDMA */
 }
 
-// e-series boards use the second irq signals to generate dma requests for their counters
+/* e-series boards use the second irq signals to generate dma requests for their counters */
 #ifdef PCIDMA
 static void ni_e_series_enable_second_irq(struct comedi_device * dev,
 	unsigned gpct_index, short enable)
@@ -665,15 +665,15 @@ static void ni_e_series_enable_second_ir
 		break;
 	}
 }
-#endif // PCIDMA
+#endif /*  PCIDMA */
 
 static void ni_clear_ai_fifo(struct comedi_device * dev)
 {
 	if (boardtype.reg_type == ni_reg_6143) {
-		// Flush the 6143 data FIFO
-		ni_writel(0x10, AIFIFO_Control_6143);	// Flush fifo
-		ni_writel(0x00, AIFIFO_Control_6143);	// Flush fifo
-		while (ni_readl(AIFIFO_Status_6143) & 0x10) ;	// Wait for complete
+		/*  Flush the 6143 data FIFO */
+		ni_writel(0x10, AIFIFO_Control_6143);	/*  Flush fifo */
+		ni_writel(0x00, AIFIFO_Control_6143);	/*  Flush fifo */
+		while (ni_readl(AIFIFO_Status_6143) & 0x10) ;	/*  Wait for complete */
 	} else {
 		devpriv->stc_writew(dev, 1, ADC_FIFO_Clear);
 		if (boardtype.reg_type == ni_reg_625x) {
@@ -776,9 +776,9 @@ static irqreturn_t ni_E_interrupt(int ir
 
 	if (dev->attached == 0)
 		return IRQ_NONE;
-	smp_mb();		// make sure dev->attached is checked before handler does anything else.
+	smp_mb();		/*  make sure dev->attached is checked before handler does anything else. */
 
-	// lock to avoid race with comedi_poll
+	/*  lock to avoid race with comedi_poll */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	a_status = devpriv->stc_readw(dev, AI_Status_1_Register);
 	b_status = devpriv->stc_readw(dev, AO_Status_1_Register);
@@ -867,7 +867,7 @@ static int ni_ao_wait_for_dma_load(struc
 	return 0;
 }
 
-#endif //PCIDMA
+#endif /* PCIDMA */
 static void ni_handle_eos(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (devpriv->aimode == AIMODE_SCAN) {
@@ -971,7 +971,7 @@ static void handle_a_interrupt(struct co
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;
 
-	//67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt
+	/* 67xx boards don't have ai subdevice, but their gpct0 might generate an a interrupt */
 	if (s->type == COMEDI_SUBD_UNUSED)
 		return;
 
@@ -992,9 +992,9 @@ static void handle_a_interrupt(struct co
 		rt_printk
 			("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",
 			ai_mite_status);
-		//mite_print_chsr(ai_mite_status);
+		/* mite_print_chsr(ai_mite_status); */
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		//disable_irq(dev->irq);
+		/* disable_irq(dev->irq); */
 	}
 #endif
 
@@ -1052,7 +1052,7 @@ static void handle_a_interrupt(struct co
 				break;
 		}
 	}
-#endif // !PCIDMA
+#endif /*  !PCIDMA */
 
 	if ((status & AI_STOP_St)) {
 		ni_handle_eos(dev, s);
@@ -1102,7 +1102,7 @@ static void handle_b_interrupt(struct co
 	unsigned ao_mite_status)
 {
 	struct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;
-	//unsigned short ack=0;
+	/* unsigned short ack=0; */
 #ifdef DEBUG_INTERRUPT
 	rt_printk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",
 		b_status, ao_mite_status);
@@ -1121,7 +1121,7 @@ static void handle_b_interrupt(struct co
 		rt_printk
 			("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",
 			ao_mite_status);
-		//mite_print_chsr(ao_mite_status);
+		/* mite_print_chsr(ao_mite_status); */
 		s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 #endif
@@ -1333,7 +1333,7 @@ static void ni_ai_fifo_read(struct comed
 		short data[2];
 		u32 dl;
 
-		// This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed
+		/*  This just reads the FIFO assuming the data is present, no checks on the FIFO status are performed */
 		for (i = 0; i < n / 2; i++) {
 			dl = ni_readl(AIFIFO_Data_6143);
 
@@ -1343,7 +1343,7 @@ static void ni_ai_fifo_read(struct comed
 		}
 		if (n % 2) {
 			/* Assume there is a single sample stuck in the FIFO */
-			ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
 			dl = ni_readl(AIFIFO_Data_6143);
 			data[0] = (dl >> 16) & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
@@ -1444,9 +1444,9 @@ static void ni_handle_fifo_dregs(struct 
 			cfc_write_array_to_buffer(s, data, sizeof(data));
 			i += 2;
 		}
-		// Check if stranded sample is present
+		/*  Check if stranded sample is present */
 		if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-			ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+			ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
 			dl = ni_readl(AIFIFO_Data_6143);
 			data[0] = (dl >> 16) & 0xffff;
 			cfc_write_to_buffer(s, data[0]);
@@ -1504,7 +1504,7 @@ static void get_last_sample_6143(struct 
 
 	/* Check if there's a single sample stuck in the FIFO */
 	if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-		ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+		ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
 		dl = ni_readl(AIFIFO_Data_6143);
 
 		/* This may get the hi/lo data in the wrong order */
@@ -1548,7 +1548,7 @@ static int ni_ai_setup_MITE_dma(struct c
 	retval = ni_request_ai_mite_channel(dev);
 	if (retval)
 		return retval;
-//      rt_printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel);
+/* rt_printk("comedi_debug: using mite channel %i for ai.\n", devpriv->ai_mite_chan->channel); */
 
 	/* write alloc the entire buffer */
 	comedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);
@@ -1609,7 +1609,7 @@ static int ni_ao_setup_MITE_dma(struct c
 	return retval;
 }
 
-#endif // PCIDMA
+#endif /*  PCIDMA */
 
 /*
    used for both cancel ioctl and board initialization
@@ -1703,7 +1703,7 @@ static int ni_ai_poll(struct comedi_devi
 	unsigned long flags = 0;
 	int count;
 
-	// lock to avoid race with interrupt handler
+	/*  lock to avoid race with interrupt handler */
 	if (in_interrupt() == 0)
 		comedi_spin_lock_irqsave(&dev->spinlock, flags);
 #ifndef PCIDMA
@@ -1774,7 +1774,7 @@ static int ni_ai_insn_read(struct comedi
 			dl = 0;
 			for (i = 0; i < NI_TIMEOUT; i++) {
 				if (ni_readl(AIFIFO_Status_6143) & 0x01) {
-					ni_writel(0x01, AIFIFO_Control_6143);	// Get stranded sample into FIFO
+					ni_writel(0x01, AIFIFO_Control_6143);	/*  Get stranded sample into FIFO */
 					dl = ni_readl(AIFIFO_Data_6143);
 					break;
 				}
@@ -1841,7 +1841,7 @@ static void ni_m_series_load_channelgain
 
 	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
 
-//      offset = 1 << (boardtype.adbits - 1);
+/* offset = 1 << (boardtype.adbits - 1); */
 	if ((list[0] & CR_ALT_SOURCE)) {
 		unsigned bypass_bits;
 		chan = CR_CHAN(list[0]);
@@ -1859,7 +1859,7 @@ static void ni_m_series_load_channelgain
 		bypass_bits |= MSeries_AI_Bypass_Gain_Bits(range_code);
 		if (dither)
 			bypass_bits |= MSeries_AI_Bypass_Dither_Bit;
-		// don't use 2's complement encoding
+		/*  don't use 2's complement encoding */
 		bypass_bits |= MSeries_AI_Bypass_Polarity_Bit;
 		ni_writel(bypass_bits, M_Offset_AI_Config_FIFO_Bypass);
 	} else {
@@ -1899,7 +1899,7 @@ static void ni_m_series_load_channelgain
 			config_bits |= MSeries_AI_Config_Last_Channel_Bit;
 		if (dither)
 			config_bits |= MSeries_AI_Config_Dither_Bit;
-		// don't use 2's complement encoding
+		/*  don't use 2's complement encoding */
 		config_bits |= MSeries_AI_Config_Polarity_Bit;
 		ni_writew(config_bits, M_Offset_AI_Config_FIFO_Data);
 	}
@@ -1952,7 +1952,7 @@ static void ni_load_channelgain_list(str
 		&& (boardtype.reg_type != ni_reg_6143)) {
 		if (devpriv->changain_state
 			&& devpriv->changain_spec == list[0]) {
-			// ready to go.
+			/*  ready to go. */
 			return;
 		}
 		devpriv->changain_state = 1;
@@ -1963,11 +1963,11 @@ static void ni_load_channelgain_list(str
 
 	devpriv->stc_writew(dev, 1, Configuration_Memory_Clear);
 
-	// Set up Calibration mode if required
+	/*  Set up Calibration mode if required */
 	if (boardtype.reg_type == ni_reg_6143) {
 		if ((list[0] & CR_ALT_SOURCE)
 			&& !devpriv->ai_calib_source_enabled) {
-			// Strobe Relay enable bit
+			/*  Strobe Relay enable bit */
 			ni_writew(devpriv->
 				ai_calib_source |
 				Calibration_Channel_6143_RelayOn,
@@ -1975,10 +1975,10 @@ static void ni_load_channelgain_list(str
 			ni_writew(devpriv->ai_calib_source,
 				Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 1;
-			msleep_interruptible(100);	// Allow relays to change
+			msleep_interruptible(100);	/*  Allow relays to change */
 		} else if (!(list[0] & CR_ALT_SOURCE)
 			&& devpriv->ai_calib_source_enabled) {
-			// Strobe Relay disable bit
+			/*  Strobe Relay disable bit */
 			ni_writew(devpriv->
 				ai_calib_source |
 				Calibration_Channel_6143_RelayOff,
@@ -1986,7 +1986,7 @@ static void ni_load_channelgain_list(str
 			ni_writew(devpriv->ai_calib_source,
 				Calibration_Channel_6143);
 			devpriv->ai_calib_source_enabled = 0;
-			msleep_interruptible(100);	// Allow relays to change
+			msleep_interruptible(100);	/*  Allow relays to change */
 		}
 	}
 
@@ -2085,11 +2085,11 @@ static unsigned ni_min_ai_scan_period_ns
 	switch (boardtype.reg_type) {
 	case ni_reg_611x:
 	case ni_reg_6143:
-		// simultaneously-sampled inputs
+		/*  simultaneously-sampled inputs */
 		return boardtype.ai_speed;
 		break;
 	default:
-		// multiplexed inputs
+		/*  multiplexed inputs */
 		break;
 	};
 	return boardtype.ai_speed * num_channels;
@@ -2367,10 +2367,10 @@ static int ni_ai_cmd(struct comedi_devic
 	if (cmd->chanlist_len == 1 || (boardtype.reg_type == ni_reg_611x)
 		|| (boardtype.reg_type == ni_reg_6143)) {
 		start_stop_select |= AI_STOP_Polarity;
-		start_stop_select |= AI_STOP_Select(31);	// logic low
+		start_stop_select |= AI_STOP_Select(31);	/*  logic low */
 		start_stop_select |= AI_STOP_Sync;
 	} else {
-		start_stop_select |= AI_STOP_Select(19);	// ai configuration memory
+		start_stop_select |= AI_STOP_Select(19);	/*  ai configuration memory */
 	}
 	devpriv->stc_writew(dev, start_stop_select,
 		AI_START_STOP_Select_Register);
@@ -2381,7 +2381,7 @@ static int ni_ai_cmd(struct comedi_devic
 		stop_count = cmd->stop_arg - 1;
 
 		if (boardtype.reg_type == ni_reg_611x) {
-			// have to take 3 stage adc pipeline into account
+			/*  have to take 3 stage adc pipeline into account */
 			stop_count += num_adc_stages_611x;
 		}
 		/* stage number of scans */
@@ -2396,7 +2396,7 @@ static int ni_ai_cmd(struct comedi_devic
 		if (stop_count == 0) {
 			devpriv->ai_cmd2 |= AI_End_On_End_Of_Scan;
 			interrupt_a_enable |= AI_STOP_Interrupt_Enable;
-			// this is required to get the last sample for chanlist_len > 1, not sure why
+			/*  this is required to get the last sample for chanlist_len > 1, not sure why */
 			if (cmd->chanlist_len > 1)
 				start_stop_select |=
 					AI_STOP_Polarity | AI_STOP_Edge;
@@ -2440,7 +2440,7 @@ static int ni_ai_cmd(struct comedi_devic
 		mode2 |= AI_SI_Reload_Mode(0);
 		/* AI_SI_Initial_Load_Source=A */
 		mode2 &= ~AI_SI_Initial_Load_Source;
-		//mode2 |= AI_SC_Reload_Mode;
+		/* mode2 |= AI_SC_Reload_Mode; */
 		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
 
 		/* load SI */
@@ -2486,8 +2486,8 @@ static int ni_ai_cmd(struct comedi_devic
 		/* AI_SI2_Load */
 		devpriv->stc_writew(dev, AI_SI2_Load, AI_Command_1_Register);
 
-		mode2 |= AI_SI2_Reload_Mode;	// alternate
-		mode2 |= AI_SI2_Initial_Load_Source;	// B
+		mode2 |= AI_SI2_Reload_Mode;	/*  alternate */
+		mode2 |= AI_SI2_Initial_Load_Source;	/*  B */
 
 		devpriv->stc_writew(dev, mode2, AI_Mode_2_Register);
 		break;
@@ -2589,7 +2589,7 @@ static int ni_ai_cmd(struct comedi_devic
 		if (retval)
 			return retval;
 	}
-	//mite_dump_regs(devpriv->mite);
+	/* mite_dump_regs(devpriv->mite); */
 #endif
 
 	switch (cmd->start_src) {
@@ -3044,7 +3044,7 @@ static int ni_ao_inttrig(struct comedi_d
 			"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");
 		return -EIO;
 	}
-	// stc manual says we are need to clear error interrupt after AO_TMRDACWRs_In_Progress_St clears
+	/*  stc manual says we are need to clear error interrupt after AO_TMRDACWRs_In_Progress_St clears */
 	devpriv->stc_writew(dev, AO_Error_Interrupt_Ack,
 		Interrupt_B_Ack_Register);
 
@@ -3114,9 +3114,9 @@ static int ni_ao_cmd(struct comedi_devic
 	case TRIG_EXT:
                 devpriv->ao_trigger_select = AO_START1_Select(CR_CHAN(cmd->start_arg)+1);
 		if (cmd->start_arg & CR_INVERT)
-			devpriv->ao_trigger_select |= AO_START1_Polarity;  // 0=active high, 1=active low. see daq-stc 3-24 (p186)
+			devpriv->ao_trigger_select |= AO_START1_Polarity;  /*  0=active high, 1=active low. see daq-stc 3-24 (p186) */
 		if (cmd->start_arg & CR_EDGE)
-			devpriv->ao_trigger_select |= AO_START1_Edge;      // 0=edge detection disabled, 1=enabled
+			devpriv->ao_trigger_select |= AO_START1_Edge;      /*  0=edge detection disabled, 1=enabled */
 		devpriv->stc_writew(dev, devpriv->ao_trigger_select, AO_Trigger_Select_Register);
 		break;
 	default:
@@ -3141,7 +3141,7 @@ static int ni_ao_cmd(struct comedi_devic
 	case TRIG_COUNT:
 		if(boardtype.reg_type & ni_reg_m_series_mask)
 		{
-			// this is how the NI example code does it for m-series boards, verified correct with 6259
+			/*  this is how the NI example code does it for m-series boards, verified correct with 6259 */
 			devpriv->stc_writel(dev, cmd->stop_arg - 1, AO_UC_Load_A_Register);
 			devpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);
 		}else
@@ -3244,7 +3244,7 @@ static int ni_ao_cmd(struct comedi_devic
 		bits |= AO_Number_Of_DAC_Packages;
 #endif
 	devpriv->stc_writew(dev, bits, AO_Personal_Register);
-	// enable sending of ao dma requests
+	/*  enable sending of ao dma requests */
 	devpriv->stc_writew(dev, AO_AOFREQ_Enable, AO_Start_Select_Register);
 
 	devpriv->stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);
@@ -3386,11 +3386,11 @@ static int ni_ao_cmdtest(struct comedi_d
 
 static int ni_ao_reset(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	//devpriv->ao0p=0x0000;
-	//ni_writew(devpriv->ao0p,AO_Configuration);
+	/* devpriv->ao0p=0x0000; */
+	/* ni_writew(devpriv->ao0p,AO_Configuration); */
 
-	//devpriv->ao1p=AO_Channel(1);
-	//ni_writew(devpriv->ao1p,AO_Configuration);
+	/* devpriv->ao1p=AO_Channel(1); */
+	/* ni_writew(devpriv->ao1p,AO_Configuration); */
 
 	ni_release_ao_mite_channel(dev);
 
@@ -3434,7 +3434,7 @@ static int ni_ao_reset(struct comedi_dev
 	return 0;
 }
 
-// digital io
+/* digital io */
 
 static int ni_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
@@ -3718,9 +3718,11 @@ static int ni_cdo_inttrig(struct comedi_
 	if (retval < 0)
 		return retval;
 #endif
-// XXX not sure what interrupt C group does
-//      ni_writeb(Interrupt_Group_C_Enable_Bit, M_Offset_Interrupt_C_Enable);
-	//wait for dma to fill output fifo
+/*
+* XXX not sure what interrupt C group does
+* ni_writeb(Interrupt_Group_C_Enable_Bit,
+* M_Offset_Interrupt_C_Enable); wait for dma to fill output fifo
+*/
 	for (i = 0; i < timeout; ++i) {
 		if (ni_readl(M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)
 			break;
@@ -3742,8 +3744,10 @@ static int ni_cdio_cancel(struct comedi_
 		CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |
 		CDO_FIFO_Request_Interrupt_Enable_Clear_Bit,
 		M_Offset_CDIO_Command);
-// XXX not sure what interrupt C group does
-//      ni_writeb(0, M_Offset_Interrupt_C_Enable);
+/*
+* XXX not sure what interrupt C group does ni_writeb(0,
+* M_Offset_Interrupt_C_Enable);
+*/
 	ni_writel(0, M_Offset_CDO_Mask_Enable);
 	ni_release_cdo_mite_channel(dev);
 	return 0;
@@ -3777,15 +3781,15 @@ static void handle_cdio_interrupt(struct
 
 	cdio_status = ni_readl(M_Offset_CDIO_Status);
 	if (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {
-//              rt_printk("cdio error: statux=0x%x\n", cdio_status);
-		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	// XXX just guessing this is needed and does something useful
+/* rt_printk("cdio error: statux=0x%x\n", cdio_status); */
+		ni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);	/*  XXX just guessing this is needed and does something useful */
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (cdio_status & CDO_FIFO_Empty_Bit) {
-//              rt_printk("cdio fifo empty\n");
+/* rt_printk("cdio fifo empty\n"); */
 		ni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,
 			M_Offset_CDIO_Command);
-//              s->async->events |= COMEDI_CB_EOA;
+/* s->async->events |= COMEDI_CB_EOA; */
 	}
 	ni_event(dev, s);
 }
@@ -4419,14 +4423,14 @@ static int ni_E_init(struct comedi_devic
 	s = dev->subdevices + NI_CALIBRATION_SUBDEV;
 	s->type = COMEDI_SUBD_CALIB;
 	if (boardtype.reg_type & ni_reg_m_series_mask) {
-		// internal PWM analog output used for AI nonlinearity calibration
+		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
 		s->insn_config = &ni_m_series_pwm_config;
 		s->n_chan = 1;
 		s->maxdata = 0;
 		ni_writel(0x0, M_Offset_Cal_PWM);
 	} else if (boardtype.reg_type == ni_reg_6143) {
-		// internal PWM analog output used for AI nonlinearity calibration
+		/*  internal PWM analog output used for AI nonlinearity calibration */
 		s->subdev_flags = SDF_INTERNAL;
 		s->insn_config = &ni_6143_pwm_config;
 		s->n_chan = 1;
@@ -4478,7 +4482,7 @@ static int ni_E_init(struct comedi_devic
 	if (boardtype.reg_type & ni_reg_67xx_mask) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;
-		// one channel for each analog output channel
+		/*  one channel for each analog output channel */
 		s->n_chan = boardtype.n_aochan;
 		s->maxdata = (1 << 16) - 1;
 		s->range_table = &range_unknown;	/* XXX */
@@ -4557,7 +4561,7 @@ static int ni_E_init(struct comedi_devic
 	/* ai configuration */
 	ni_ai_reset(dev, dev->subdevices + NI_AI_SUBDEV);
 	if ((boardtype.reg_type & ni_reg_6xxx_mask) == 0) {
-		// BEAM is this needed for PCI-6143 ??
+		/*  BEAM is this needed for PCI-6143 ?? */
 		devpriv->clock_and_fout =
 			Slow_Internal_Time_Divide_By_2 |
 			Slow_Internal_Timebase |
@@ -4904,7 +4908,7 @@ static void ni_write_caldac(struct comed
 	int i;
 	int type;
 
-	//printk("ni_write_caldac: chan=%d val=%d\n",addr,val);
+	/* printk("ni_write_caldac: chan=%d val=%d\n",addr,val); */
 	if (devpriv->caldacs[addr] == val)
 		return;
 	devpriv->caldacs[addr] = val;
@@ -4916,7 +4920,7 @@ static void ni_write_caldac(struct comed
 		if (addr < caldacs[type].n_chans) {
 			bits = caldacs[type].packbits(addr, val, &bitstring);
 			loadbit = SerDacLd(i);
-			//printk("caldac: using i=%d addr=%d %x\n",i,addr,bitstring);
+			/* printk("caldac: using i=%d addr=%d %x\n",i,addr,bitstring); */
 			break;
 		}
 		addr -= caldacs[type].n_chans;
@@ -5012,7 +5016,7 @@ static void GPCT_Reset(struct comedi_dev
 {
 	int temp_ack_reg = 0;
 
-	//printk("GPCT_Reset...");
+	/* printk("GPCT_Reset..."); */
 	devpriv->gpct_cur_operation[chan] = GPCT_RESET;
 
 	switch (chan) {
@@ -5029,7 +5033,7 @@ static void GPCT_Reset(struct comedi_dev
 		devpriv->stc_writew(dev, temp_ack_reg,
 			Interrupt_A_Ack_Register);
 
-		//problem...this interferes with the other ctr...
+		/* problem...this interferes with the other ctr... */
 		devpriv->an_trig_etc_reg |= GPFO_0_Output_Enable;
 		devpriv->stc_writew(dev, devpriv->an_trig_etc_reg,
 			Analog_Trigger_Etc_Register);
@@ -5065,7 +5069,7 @@ static void GPCT_Reset(struct comedi_dev
 		G_Input_Select_Register(chan));
 	devpriv->stc_writew(dev, 0, G_Autoincrement_Register(chan));
 
-	//printk("exit GPCT_Reset\n");
+	/* printk("exit GPCT_Reset\n"); */
 }
 
 #endif
@@ -5096,7 +5100,7 @@ static int ni_gpct_cmd(struct comedi_dev
 	int retval;
 #ifdef PCIDMA
 	struct ni_gpct *counter = s->private;
-//      const struct comedi_cmd *cmd = &s->async->cmd;
+/* const struct comedi_cmd *cmd = &s->async->cmd; */
 
 	retval = ni_request_gpct_mite_channel(dev, counter->counter_index,
 		COMEDI_INPUT);
@@ -5168,7 +5172,7 @@ static int ni_m_series_set_pfi_routing(s
 static int ni_old_set_pfi_routing(struct comedi_device * dev, unsigned chan,
 	unsigned source)
 {
-	// pre-m-series boards have fixed signals on pfi pins
+	/*  pre-m-series boards have fixed signals on pfi pins */
 	if (source != ni_old_get_pfi_routing(dev, chan))
 		return -EINVAL;
 	return 2;
@@ -5192,7 +5196,7 @@ static unsigned ni_m_series_get_pfi_rout
 
 static unsigned ni_old_get_pfi_routing(struct comedi_device * dev, unsigned chan)
 {
-	// pre-m-series boards have fixed signals on pfi pins
+	/*  pre-m-series boards have fixed signals on pfi pins */
 	switch (chan) {
 	case 0:
 		return NI_PFI_OUTPUT_AI_START1;
@@ -5314,14 +5318,14 @@ static int ni_pfi_insn_config(struct com
  */
 static void ni_rtsi_init(struct comedi_device * dev)
 {
-	// Initialises the RTSI bus signal switch to a default state
+	/*  Initialises the RTSI bus signal switch to a default state */
 
-	// Set clock mode to internal
+	/*  Set clock mode to internal */
 	devpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;
 	if (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0) {
 		rt_printk("ni_set_master_clock failed, bug?");
 	}
-	// default internal lines routing to RTSI bus lines
+	/*  default internal lines routing to RTSI bus lines */
 	devpriv->rtsi_trig_a_output_reg =
 		RTSI_Trig_Output_Bits(0,
 		NI_RTSI_OUTPUT_ADR_START1) | RTSI_Trig_Output_Bits(1,
@@ -5341,8 +5345,10 @@ static void ni_rtsi_init(struct comedi_d
 	devpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,
 		RTSI_Trig_B_Output_Register);
 
-	// Sets the source and direction of the 4 on board lines
-//      devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
+/*
+* Sets the source and direction of the 4 on board lines
+* devpriv->stc_writew(dev, 0x0000, RTSI_Board_Register);
+*/
 }
 
 static int ni_rtsi_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
@@ -5422,7 +5428,7 @@ static int ni_mseries_set_pll_master_clo
 	int retval;
 	if (source == NI_MIO_PLL_PXI10_CLOCK)
 		period_ns = 100;
-	// these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that
+	/*  these limits are somewhat arbitrary, but NI advertises 1 to 20MHz range so we'll use that */
 	if (period_ns < min_period_ns || period_ns > max_period_ns) {
 		rt_printk
 			("%s: you must specify an input clock frequency between %i and %i nanosec "
@@ -5484,8 +5490,10 @@ static int ni_mseries_set_pll_master_clo
 	pll_control_bits |=
 		MSeries_PLL_Divisor_Bits(freq_divider) |
 		MSeries_PLL_Multiplier_Bits(freq_multiplier);
-//      rt_printk("using divider=%i, multiplier=%i for PLL.  pll_control_bits = 0x%x\n", freq_divider, freq_multiplier, pll_control_bits);
-//      rt_printk("clock_ns=%d\n", devpriv->clock_ns);
+
+	/* rt_printk("using divider=%i, multiplier=%i for PLL. pll_control_bits = 0x%x\n",
+	 * freq_divider, freq_multiplier, pll_control_bits); */
+	/* rt_printk("clock_ns=%d\n", devpriv->clock_ns); */
 	ni_writew(pll_control_bits, M_Offset_PLL_Control);
 	devpriv->clock_source = source;
 	/* it seems to typically take a few hundred microseconds for PLL to lock */
@@ -5714,7 +5722,7 @@ static int cs5529_wait_for_idle(struct c
 			return -EIO;
 		}
 	}
-//printk("looped %i times waiting for idle\n", i);
+/* printk("looped %i times waiting for idle\n", i); */
 	if (i == timeout) {
 		rt_printk("%s: %s: timeout\n", __FILE__, __FUNCTION__);
 		return -ETIME;
@@ -5737,7 +5745,7 @@ static void cs5529_command(struct comedi
 			break;
 		comedi_udelay(1);
 	}
-//printk("looped %i times writing command to cs5529\n", i);
+/* printk("looped %i times writing command to cs5529\n", i); */
 	if (i == timeout) {
 		comedi_error(dev, "possible problem - never saw adc go busy?");
 	}
--- a/drivers/staging/comedi/drivers/ni_mio_cs.c
+++ b/drivers/staging/comedi/drivers/ni_mio_cs.c
@@ -344,7 +344,7 @@ static void mio_cs_config(struct pcmcia_
 		manfid = le16_to_cpu(buf[0]);
 		prodid = le16_to_cpu(buf[1]);
 	}
-	//printk("manfid = 0x%04x, 0x%04x\n",manfid,prodid);
+	/* printk("manfid = 0x%04x, 0x%04x\n",manfid,prodid); */
 
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	tuple.Attributes = 0;
@@ -381,7 +381,7 @@ static void mio_cs_config(struct pcmcia_
 		for (base = 0x000; base < 0x400; base += 0x20) {
 			link->io.BasePort1 = base;
 			ret = pcmcia_request_io(link, &link->io);
-			//printk("RequestIO 0x%02x\n",ret);
+			/* printk("RequestIO 0x%02x\n",ret); */
 			if (!ret)
 				break;
 		}
@@ -393,12 +393,12 @@ static void mio_cs_config(struct pcmcia_
 	if (ret) {
 		printk("pcmcia_request_irq() returned error: %i\n", ret);
 	}
-	//printk("RequestIRQ 0x%02x\n",ret);
+	/* printk("RequestIRQ 0x%02x\n",ret); */
 
 	link->conf.ConfigIndex = 1;
 
 	ret = pcmcia_request_configuration(link, &link->conf);
-	//printk("RequestConfiguration %d\n",ret);
+	/* printk("RequestConfiguration %d\n",ret); */
 
 	link->dev_node = &dev_node;
 }
--- a/drivers/staging/comedi/drivers/ni_pcimio.c
+++ b/drivers/staging/comedi/drivers/ni_pcimio.c
@@ -117,7 +117,7 @@ Bugs:
 #include "ni_stc.h"
 #include "mite.h"
 
-//#define PCI_DEBUG
+/* #define PCI_DEBUG */
 
 #define PCIDMA
 
@@ -218,7 +218,7 @@ static const struct comedi_lrange range_
 
 static const struct ni_board_struct ni_boards[] = {
 	{
-			.device_id = 0x0162,	// NI also says 0x1620.  typo?
+			.device_id = 0x0162,	/*  NI also says 0x1620.  typo? */
 			.name = "pci-mio-16xe-50",
 			.n_adchan = 16,
 			.adbits = 16,
@@ -238,7 +238,7 @@ static const struct ni_board_struct ni_b
 		},
 	{
 			.device_id = 0x1170,
-			.name = "pci-mio-16xe-10",	// aka pci-6030E
+			.name = "pci-mio-16xe-10",	/*  aka pci-6030E */
 			.n_adchan = 16,
 			.adbits = 16,
 			.ai_fifo_depth = 512,
@@ -330,7 +330,7 @@ static const struct ni_board_struct ni_b
 			.ao_unipolar = 1,
 			.ao_speed = 1000,
 			.num_p0_dio_channels = 8,
-			.caldac = {ad8804_debug},	// doc says mb88341
+			.caldac = {ad8804_debug},	/*  doc says mb88341 */
 			.has_8255 = 0,
 		},
 	{
@@ -846,7 +846,7 @@ static const struct ni_board_struct ni_b
 			.n_adchan = 16,
 			.adbits = 16,
 			.ai_fifo_depth = 512,
-			//FIXME:  guess
+			/* FIXME:  guess */
 			.gainlkup = ai_gain_622x,
 			.ai_speed = 4000,
 			.n_aochan = 0,
@@ -1295,12 +1295,12 @@ static void m_series_stc_writew(struct c
 		offset = M_Offset_AI_Personal;
 		break;
 	case AI_SI2_Load_A_Register:
-		// this is actually a 32 bit register on m series boards
+		/*  this is actually a 32 bit register on m series boards */
 		ni_writel(data, M_Offset_AI_SI2_Load_A);
 		return;
 		break;
 	case AI_SI2_Load_B_Register:
-		// this is actually a 32 bit register on m series boards
+		/*  this is actually a 32 bit register on m series boards */
 		ni_writel(data, M_Offset_AI_SI2_Load_B);
 		return;
 		break;
@@ -1581,17 +1581,17 @@ static void m_series_init_eeprom_buffer(
 
 static void init_6143(struct comedi_device * dev)
 {
-	// Disable interrupts
+	/*  Disable interrupts */
 	devpriv->stc_writew(dev, 0, Interrupt_Control_Register);
 
-	// Initialise 6143 AI specific bits
-	ni_writeb(0x00, Magic_6143);	// Set G0,G1 DMA mode to E series version
-	ni_writeb(0x80, PipelineDelay_6143);	// Set EOCMode, ADCMode and pipelinedelay
-	ni_writeb(0x00, EOC_Set_6143);	// Set EOC Delay
+	/*  Initialise 6143 AI specific bits */
+	ni_writeb(0x00, Magic_6143);	/*  Set G0,G1 DMA mode to E series version */
+	ni_writeb(0x80, PipelineDelay_6143);	/*  Set EOCMode, ADCMode and pipelinedelay */
+	ni_writeb(0x00, EOC_Set_6143);	/*  Set EOC Delay */
 
-	ni_writel(boardtype.ai_fifo_depth / 2, AIFIFO_Flag_6143);	// Set the FIFO half full level
+	ni_writel(boardtype.ai_fifo_depth / 2, AIFIFO_Flag_6143);	/*  Set the FIFO half full level */
 
-	// Strobe Relay disable bit
+	/*  Strobe Relay disable bit */
 	devpriv->ai_calib_source_enabled = 0;
 	ni_writew(devpriv->ai_calib_source | Calibration_Channel_6143_RelayOff,
 		Calibration_Channel_6143);
--- a/drivers/staging/comedi/drivers/ni_stc.h
+++ b/drivers/staging/comedi/drivers/ni_stc.h
@@ -521,13 +521,13 @@ enum AO_Personal_Bits {
 	AO_FIFO_Flags_Polarity = 1 << 11,	/* M Series: reserved */
 	AO_TMRDACWR_Pulse_Width = 1 << 12,
 	AO_Fast_CPU = 1 << 13,	/* M Series: reserved */
-	AO_Number_Of_DAC_Packages = 1 << 14,	// 1 for "single" mode, 0 for "dual"
-	AO_Multiple_DACS_Per_Package = 1 << 15	// m-series only
+	AO_Number_Of_DAC_Packages = 1 << 14,	/*  1 for "single" mode, 0 for "dual" */
+	AO_Multiple_DACS_Per_Package = 1 << 15	/*  m-series only */
 };
 #define	RTSI_Trig_A_Output_Register	79
 #define	RTSI_Trig_B_Output_Register	80
 enum RTSI_Trig_B_Output_Bits {
-	RTSI_Sub_Selection_1_Bit = 0x8000	// not for m-series
+	RTSI_Sub_Selection_1_Bit = 0x8000	/*  not for m-series */
 };
 static inline unsigned RTSI_Trig_Output_Bits(unsigned rtsi_channel,
 	unsigned source)
@@ -539,7 +539,7 @@ static inline unsigned RTSI_Trig_Output_
 	return 0xf << ((rtsi_channel % 4) * 4);
 };
 
-// inverse to RTSI_Trig_Output_Bits()
+/* inverse to RTSI_Trig_Output_Bits() */
 static inline unsigned RTSI_Trig_Output_Source(unsigned rtsi_channel,
 	unsigned bits)
 {
@@ -920,42 +920,42 @@ enum ni_reg_type {
 static const struct comedi_lrange range_ni_E_ao_ext;
 
 enum m_series_register_offsets {
-	M_Offset_CDIO_DMA_Select = 0x7,	// write
-	M_Offset_SCXI_Status = 0x7,	// read
-	M_Offset_AI_AO_Select = 0x9,	// write, same offset as e-series
-	M_Offset_SCXI_Serial_Data_In = 0x9,	// read
-	M_Offset_G0_G1_Select = 0xb,	// write, same offset as e-series
+	M_Offset_CDIO_DMA_Select = 0x7,	/*  write */
+	M_Offset_SCXI_Status = 0x7,	/*  read */
+	M_Offset_AI_AO_Select = 0x9,	/*  write, same offset as e-series */
+	M_Offset_SCXI_Serial_Data_In = 0x9,	/*  read */
+	M_Offset_G0_G1_Select = 0xb,	/*  write, same offset as e-series */
 	M_Offset_Misc_Command = 0xf,
 	M_Offset_SCXI_Serial_Data_Out = 0x11,
 	M_Offset_SCXI_Control = 0x13,
 	M_Offset_SCXI_Output_Enable = 0x15,
 	M_Offset_AI_FIFO_Data = 0x1c,
-	M_Offset_Static_Digital_Output = 0x24,	// write
-	M_Offset_Static_Digital_Input = 0x24,	// read
+	M_Offset_Static_Digital_Output = 0x24,	/*  write */
+	M_Offset_Static_Digital_Input = 0x24,	/*  read */
 	M_Offset_DIO_Direction = 0x28,
 	M_Offset_Cal_PWM = 0x40,
 	M_Offset_AI_Config_FIFO_Data = 0x5e,
-	M_Offset_Interrupt_C_Enable = 0x88,	// write
-	M_Offset_Interrupt_C_Status = 0x88,	// read
+	M_Offset_Interrupt_C_Enable = 0x88,	/*  write */
+	M_Offset_Interrupt_C_Status = 0x88,	/*  read */
 	M_Offset_Analog_Trigger_Control = 0x8c,
 	M_Offset_AO_Serial_Interrupt_Enable = 0xa0,
-	M_Offset_AO_Serial_Interrupt_Ack = 0xa1,	// write
-	M_Offset_AO_Serial_Interrupt_Status = 0xa1,	// read
+	M_Offset_AO_Serial_Interrupt_Ack = 0xa1,	/*  write */
+	M_Offset_AO_Serial_Interrupt_Status = 0xa1,	/*  read */
 	M_Offset_AO_Calibration = 0xa3,
 	M_Offset_AO_FIFO_Data = 0xa4,
 	M_Offset_PFI_Filter = 0xb0,
 	M_Offset_RTSI_Filter = 0xb4,
 	M_Offset_SCXI_Legacy_Compatibility = 0xbc,
-	M_Offset_Interrupt_A_Ack = 0x104,	// write
-	M_Offset_AI_Status_1 = 0x104,	// read
-	M_Offset_Interrupt_B_Ack = 0x106,	// write
-	M_Offset_AO_Status_1 = 0x106,	// read
-	M_Offset_AI_Command_2 = 0x108,	// write
-	M_Offset_G01_Status = 0x108,	// read
+	M_Offset_Interrupt_A_Ack = 0x104,	/*  write */
+	M_Offset_AI_Status_1 = 0x104,	/*  read */
+	M_Offset_Interrupt_B_Ack = 0x106,	/*  write */
+	M_Offset_AO_Status_1 = 0x106,	/*  read */
+	M_Offset_AI_Command_2 = 0x108,	/*  write */
+	M_Offset_G01_Status = 0x108,	/*  read */
 	M_Offset_AO_Command_2 = 0x10a,
-	M_Offset_AO_Status_2 = 0x10c,	// read
-	M_Offset_G0_Command = 0x10c,	// write
-	M_Offset_G1_Command = 0x10e,	// write
+	M_Offset_AO_Status_2 = 0x10c,	/*  read */
+	M_Offset_G0_Command = 0x10c,	/*  write */
+	M_Offset_G1_Command = 0x10e,	/*  write */
 	M_Offset_G0_HW_Save = 0x110,
 	M_Offset_G0_HW_Save_High = 0x110,
 	M_Offset_AI_Command_1 = 0x110,
@@ -973,17 +973,17 @@ enum m_series_register_offsets {
 	M_Offset_G1_Save = 0x11c,
 	M_Offset_G1_Save_High = 0x11c,
 	M_Offset_G1_Save_Low = 0x11e,
-	M_Offset_AI_SI_Load_B = 0x120,	// write
-	M_Offset_AO_UI_Save = 0x120,	// read
-	M_Offset_AI_SC_Load_A = 0x124,	// write
-	M_Offset_AO_BC_Save = 0x124,	// read
-	M_Offset_AI_SC_Load_B = 0x128,	// write
-	M_Offset_AO_UC_Save = 0x128,	//read
+	M_Offset_AI_SI_Load_B = 0x120,	/*  write */
+	M_Offset_AO_UI_Save = 0x120,	/*  read */
+	M_Offset_AI_SC_Load_A = 0x124,	/*  write */
+	M_Offset_AO_BC_Save = 0x124,	/*  read */
+	M_Offset_AI_SC_Load_B = 0x128,	/*  write */
+	M_Offset_AO_UC_Save = 0x128,	/* read */
 	M_Offset_AI_SI2_Load_A = 0x12c,
 	M_Offset_AI_SI2_Load_B = 0x130,
 	M_Offset_G0_Mode = 0x134,
-	M_Offset_G1_Mode = 0x136,	// write
-	M_Offset_Joint_Status_1 = 0x136,	// read
+	M_Offset_G1_Mode = 0x136,	/*  write */
+	M_Offset_Joint_Status_1 = 0x136,	/*  read */
 	M_Offset_G0_Load_A = 0x138,
 	M_Offset_Joint_Status_2 = 0x13a,
 	M_Offset_G0_Load_B = 0x13c,
@@ -1007,10 +1007,10 @@ enum m_series_register_offsets {
 	M_Offset_Analog_Trigger_Etc = 0x17a,
 	M_Offset_AI_START_STOP_Select = 0x17c,
 	M_Offset_AI_Trigger_Select = 0x17e,
-	M_Offset_AI_SI_Save = 0x180,	// read
-	M_Offset_AI_DIV_Load_A = 0x180,	// write
-	M_Offset_AI_SC_Save = 0x184,	// read
-	M_Offset_AO_Start_Select = 0x184,	// write
+	M_Offset_AI_SI_Save = 0x180,	/*  read */
+	M_Offset_AI_DIV_Load_A = 0x180,	/*  write */
+	M_Offset_AI_SC_Save = 0x184,	/*  read */
+	M_Offset_AO_Start_Select = 0x184,	/*  write */
 	M_Offset_AO_Trigger_Select = 0x186,
 	M_Offset_AO_Mode_3 = 0x18c,
 	M_Offset_G0_Autoincrement = 0x188,
@@ -1032,10 +1032,10 @@ enum m_series_register_offsets {
 	M_Offset_G1_Counting_Mode = 0x1b2,
 	M_Offset_G0_Second_Gate = 0x1b4,
 	M_Offset_G1_Second_Gate = 0x1b6,
-	M_Offset_G0_DMA_Config = 0x1b8,	// write
-	M_Offset_G0_DMA_Status = 0x1b8,	// read
-	M_Offset_G1_DMA_Config = 0x1ba,	// write
-	M_Offset_G1_DMA_Status = 0x1ba,	// read
+	M_Offset_G0_DMA_Config = 0x1b8,	/*  write */
+	M_Offset_G0_DMA_Status = 0x1b8,	/*  read */
+	M_Offset_G1_DMA_Config = 0x1ba,	/*  write */
+	M_Offset_G1_DMA_Status = 0x1ba,	/*  read */
 	M_Offset_G0_MSeries_ABZ = 0x1c0,
 	M_Offset_G1_MSeries_ABZ = 0x1c2,
 	M_Offset_Clock_and_Fout2 = 0x1c4,
@@ -1051,10 +1051,10 @@ enum m_series_register_offsets {
 	M_Offset_PFI_DO = 0x1de,
 	M_Offset_AI_Config_FIFO_Bypass = 0x218,
 	M_Offset_SCXI_DIO_Enable = 0x21c,
-	M_Offset_CDI_FIFO_Data = 0x220,	// read
-	M_Offset_CDO_FIFO_Data = 0x220,	// write
-	M_Offset_CDIO_Status = 0x224,	// read
-	M_Offset_CDIO_Command = 0x224,	// write
+	M_Offset_CDI_FIFO_Data = 0x220,	/*  read */
+	M_Offset_CDO_FIFO_Data = 0x220,	/*  write */
+	M_Offset_CDIO_Status = 0x224,	/*  read */
+	M_Offset_CDIO_Command = 0x224,	/*  write */
 	M_Offset_CDI_Mode = 0x228,
 	M_Offset_CDO_Mode = 0x22c,
 	M_Offset_CDI_Mask_Enable = 0x230,
@@ -1122,7 +1122,7 @@ enum MSeries_AI_Config_FIFO_Data_Bits {
 	MSeries_AI_Config_Channel_Type_Ground_Ref_Bits = 0x3 << 6,
 	MSeries_AI_Config_Channel_Type_Aux_Bits = 0x5 << 6,
 	MSeries_AI_Config_Channel_Type_Ghost_Bits = 0x7 << 6,
-	MSeries_AI_Config_Polarity_Bit = 0x1000,	// 0 for 2's complement encoding
+	MSeries_AI_Config_Polarity_Bit = 0x1000,	/*  0 for 2's complement encoding */
 	MSeries_AI_Config_Dither_Bit = 0x2000,
 	MSeries_AI_Config_Last_Channel_Bit = 0x4000,
 };
@@ -1151,8 +1151,8 @@ enum MSeries_Clock_and_Fout2_Bits {
 	MSeries_PLL_In_Source_Select_RTSI7_Bits = 0x1b,
 	MSeries_PLL_In_Source_Select_PXI_Clock10 = 0x1d,
 	MSeries_PLL_In_Source_Select_Mask = 0x1f,
-	MSeries_Timebase1_Select_Bit = 0x20,	// use PLL for timebase 1
-	MSeries_Timebase3_Select_Bit = 0x40,	// use PLL for timebase 3
+	MSeries_Timebase1_Select_Bit = 0x20,	/*  use PLL for timebase 1 */
+	MSeries_Timebase3_Select_Bit = 0x40,	/*  use PLL for timebase 3 */
 	/* use 10MHz instead of 20MHz for RTSI clock frequency.  Appears
 	   to have no effect, at least on pxi-6281, which always uses
 	   20MHz rtsi clock frequency */
@@ -1213,7 +1213,7 @@ enum MSeries_AI_Config_FIFO_Bypass_Bits 
 	MSeries_AO_Bypass_AO_Cal_Sel_Mask = 0x38000,
 	MSeries_AI_Bypass_Gain_Mask = 0x1c0000,
 	MSeries_AI_Bypass_Dither_Bit = 0x200000,
-	MSeries_AI_Bypass_Polarity_Bit = 0x400000,	// 0 for 2's complement encoding
+	MSeries_AI_Bypass_Polarity_Bit = 0x400000,	/*  0 for 2's complement encoding */
 	MSeries_AI_Bypass_Config_FIFO_Bit = 0x80000000
 };
 static inline unsigned MSeries_AI_Bypass_Cal_Sel_Pos_Bits(int
@@ -1239,7 +1239,7 @@ enum MSeries_AO_Config_Bank_Bits {
 	MSeries_AO_DAC_Reference_10V_Internal_Bits = 0x0,
 	MSeries_AO_DAC_Reference_5V_Internal_Bits = 0x8,
 	MSeries_AO_Update_Timed_Bit = 0x40,
-	MSeries_AO_Bipolar_Bit = 0x80	// turns on 2's complement encoding
+	MSeries_AO_Bipolar_Bit = 0x80	/*  turns on 2's complement encoding */
 };
 
 enum MSeries_AO_Reference_Attenuation_Bits {
@@ -1266,7 +1266,7 @@ static inline unsigned MSeries_PFI_Outpu
 	return (source & 0x1f) << ((channel % 3) * 5);
 };
 
-// inverse to MSeries_PFI_Output_Select_Bits
+/* inverse to MSeries_PFI_Output_Select_Bits */
 static inline unsigned MSeries_PFI_Output_Select_Source(unsigned channel,
 	unsigned bits)
 {
@@ -1338,9 +1338,9 @@ enum CDIO_Command_Bits {
 enum CDI_Mode_Bits {
 	CDI_Sample_Source_Select_Mask = 0x3f,
 	CDI_Halt_On_Error_Bit = 0x200,
-	CDI_Polarity_Bit = 0x400,	// sample clock on falling edge
-	CDI_FIFO_Mode_Bit = 0x800,	// set for half full mode, clear for not empty mode
-	CDI_Data_Lane_Mask = 0x3000,	// data lanes specify which dio channels map to byte or word accesses to the dio fifos
+	CDI_Polarity_Bit = 0x400,	/*  sample clock on falling edge */
+	CDI_FIFO_Mode_Bit = 0x800,	/*  set for half full mode, clear for not empty mode */
+	CDI_Data_Lane_Mask = 0x3000,	/*  data lanes specify which dio channels map to byte or word accesses to the dio fifos */
 	CDI_Data_Lane_0_15_Bits = 0x0,
 	CDI_Data_Lane_16_31_Bits = 0x1000,
 	CDI_Data_Lane_0_7_Bits = 0x0,
@@ -1353,9 +1353,9 @@ enum CDO_Mode_Bits {
 	CDO_Sample_Source_Select_Mask = 0x3f,
 	CDO_Retransmit_Bit = 0x100,
 	CDO_Halt_On_Error_Bit = 0x200,
-	CDO_Polarity_Bit = 0x400,	// sample clock on falling edge
-	CDO_FIFO_Mode_Bit = 0x800,	// set for half full mode, clear for not full mode
-	CDO_Data_Lane_Mask = 0x3000,	// data lanes specify which dio channels map to byte or word accesses to the dio fifos
+	CDO_Polarity_Bit = 0x400,	/*  sample clock on falling edge */
+	CDO_FIFO_Mode_Bit = 0x800,	/*  set for half full mode, clear for not full mode */
+	CDO_Data_Lane_Mask = 0x3000,	/*  data lanes specify which dio channels map to byte or word accesses to the dio fifos */
 	CDO_Data_Lane_0_15_Bits = 0x0,
 	CDO_Data_Lane_16_31_Bits = 0x1000,
 	CDO_Data_Lane_0_7_Bits = 0x0,
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1273,7 +1273,7 @@ static int ni_tio_set_other_src(struct n
 		counter_dev->regs[abz_reg] &= ~mask;
 		counter_dev->regs[abz_reg] |= (source << shift) & mask;
 		write_register(counter, counter_dev->regs[abz_reg], abz_reg);
-//              rt_printk("%s %x %d %d\n", __FUNCTION__, counter_dev->regs[abz_reg], index, source);
+/* rt_printk("%s %x %d %d\n", __FUNCTION__, counter_dev->regs[abz_reg], index, source); */
 		return 0;
 	}
 	return -EINVAL;
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -365,7 +365,7 @@ static int should_ack_gate(struct ni_gpc
 
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_m_series:
-	case ni_gpct_variant_660x:	// not sure if 660x really supports gate interrupts (the bits are not listed in register-level manual)
+	case ni_gpct_variant_660x:	/*  not sure if 660x really supports gate interrupts (the bits are not listed in register-level manual) */
 		return 1;
 		break;
 	case ni_gpct_variant_e_series:
--- a/drivers/staging/comedi/drivers/ni_tio.h
+++ b/drivers/staging/comedi/drivers/ni_tio.h
@@ -25,7 +25,7 @@
 
 #include "../comedidev.h"
 
-// forward declarations
+/* forward declarations */
 struct mite_struct;
 struct ni_gpct_device;
 
--- a/drivers/staging/comedi/drivers/ni_tio_internal.h
+++ b/drivers/staging/comedi/drivers/ni_tio_internal.h
@@ -487,8 +487,8 @@ enum Gi_Counting_Mode_Reg_Bits {
 #define Gi_Source_Select_Shift 2
 #define Gi_Gate_Select_Shift 7
 enum Gi_Input_Select_Bits {
-	Gi_Read_Acknowledges_Irq = 0x1,	// not present on 660x
-	Gi_Write_Acknowledges_Irq = 0x2,	// not present on 660x
+	Gi_Read_Acknowledges_Irq = 0x1,	/*  not present on 660x */
+	Gi_Write_Acknowledges_Irq = 0x2,	/*  not present on 660x */
 	Gi_Source_Select_Mask = 0x7c,
 	Gi_Gate_Select_Mask = 0x1f << Gi_Gate_Select_Shift,
 	Gi_Gate_Select_Load_Source_Bit = 0x1000,
@@ -656,7 +656,7 @@ static inline unsigned Gi_TC_Error_Confi
 	return G0_TC_Error_Confirm_Bit;
 }
 
-// bits that are the same in G0/G2 and G1/G3 interrupt acknowledge registers
+/* bits that are the same in G0/G2 and G1/G3 interrupt acknowledge registers */
 enum Gxx_Interrupt_Acknowledge_Bits {
 	Gi_TC_Interrupt_Ack_Bit = 0x4000,
 	Gi_Gate_Interrupt_Ack_Bit = 0x8000
--- a/drivers/staging/comedi/drivers/pcl726.c
+++ b/drivers/staging/comedi/drivers/pcl726.c
@@ -116,17 +116,17 @@ static int pcl726_detach(struct comedi_d
 
 struct pcl726_board {
 
-	const char *name;	// driver name
-	int n_aochan;		// num of D/A chans
-	int num_of_ranges;	// num of ranges
-	unsigned int IRQbits;	// allowed interrupts
-	unsigned int io_range;	// len of IO space
-	char have_dio;		// 1=card have DI/DO ports
-	int di_hi;		// ports for DI/DO operations
+	const char *name;	/*  driver name */
+	int n_aochan;		/*  num of D/A chans */
+	int num_of_ranges;	/*  num of ranges */
+	unsigned int IRQbits;	/*  allowed interrupts */
+	unsigned int io_range;	/*  len of IO space */
+	char have_dio;		/*  1=card have DI/DO ports */
+	int di_hi;		/*  ports for DI/DO operations */
 	int di_lo;
 	int do_hi;
 	int do_lo;
-	const struct comedi_lrange *const *range_type_list;	// list of supported ranges
+	const struct comedi_lrange *const *range_type_list;	/*  list of supported ranges */
 };
 
 
@@ -362,7 +362,7 @@ static int pcl726_attach(struct comedi_d
 
 static int pcl726_detach(struct comedi_device * dev)
 {
-//      printk("comedi%d: pcl726: remove\n",dev->minor);
+/* printk("comedi%d: pcl726: remove\n",dev->minor); */
 
 #ifdef ACL6126_IRQ
 	if (dev->irq) {
--- a/drivers/staging/comedi/drivers/pcl730.c
+++ b/drivers/staging/comedi/drivers/pcl730.c
@@ -31,8 +31,8 @@ static int pcl730_detach(struct comedi_d
 
 struct pcl730_board {
 
-	const char *name;	// board name
-	unsigned int io_range;	// len of I/O space
+	const char *name;	/*  board name */
+	unsigned int io_range;	/*  len of I/O space */
 };
 
 
--- a/drivers/staging/comedi/drivers/pcl812.c
+++ b/drivers/staging/comedi/drivers/pcl812.c
@@ -117,7 +117,7 @@ Options for ACL-8113, ISO-813:
 
 #undef PCL812_EXTDEBUG		/* if this is defined then a lot of messages is printed */
 
-// hardware types of the cards
+/* hardware types of the cards */
 #define boardPCL812PG 		 0	/* and ACL-8112PG */
 #define boardPCL813B 		 1
 #define boardPCL812		 2
@@ -297,22 +297,22 @@ static int pcl812_detach(struct comedi_d
 
 struct pcl812_board {
 
-	const char *name;	// board name
-	int board_type;		// type of this board
-	int n_aichan;		// num of AI chans in S.E.
-	int n_aichan_diff;	// DIFF num of chans
-	int n_aochan;		// num of DA chans
-	int n_dichan;		// DI and DO chans
+	const char *name;	/*  board name */
+	int board_type;		/*  type of this board */
+	int n_aichan;		/*  num of AI chans in S.E. */
+	int n_aichan_diff;	/*  DIFF num of chans */
+	int n_aochan;		/*  num of DA chans */
+	int n_dichan;		/*  DI and DO chans */
 	int n_dochan;
-	int ai_maxdata;		// AI resolution
-	unsigned int ai_ns_min;	// max sample speed of card v ns
-	unsigned int i8254_osc_base;	// clock base
-	const struct comedi_lrange *rangelist_ai;	// rangelist for A/D
-	const struct comedi_lrange *rangelist_ao;	// rangelist for D/A
-	unsigned int IRQbits;	// allowed IRQ
-	unsigned char DMAbits;	// allowed DMA chans
-	unsigned char io_range;	// iorange for this board
-	unsigned char haveMPC508;	// 1=board use MPC508A multiplexor
+	int ai_maxdata;		/*  AI resolution */
+	unsigned int ai_ns_min;	/*  max sample speed of card v ns */
+	unsigned int i8254_osc_base;	/*  clock base */
+	const struct comedi_lrange *rangelist_ai;	/*  rangelist for A/D */
+	const struct comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
+	unsigned int IRQbits;	/*  allowed IRQ */
+	unsigned char DMAbits;	/*  allowed DMA chans */
+	unsigned char io_range;	/*  iorange for this board */
+	unsigned char haveMPC508;	/*  1=board use MPC508A multiplexor */
 };
 
 
@@ -390,37 +390,37 @@ COMEDI_INITCLEANUP(driver_pcl812);
 
 struct pcl812_private {
 
-	unsigned char valid;	// =1 device is OK
-	unsigned char dma;	// >0 use dma ( usedDMA channel)
-	unsigned char use_diff;	// =1 diff inputs
-	unsigned char use_MPC;	// 1=board uses MPC508A multiplexor
-	unsigned char use_ext_trg;	// 1=board uses external trigger
-	unsigned char range_correction;	// =1 we must add 1 to range number
-	unsigned char old_chan_reg;	// lastly used chan/gain pair
+	unsigned char valid;	/*  =1 device is OK */
+	unsigned char dma;	/*  >0 use dma ( usedDMA channel) */
+	unsigned char use_diff;	/*  =1 diff inputs */
+	unsigned char use_MPC;	/*  1=board uses MPC508A multiplexor */
+	unsigned char use_ext_trg;	/*  1=board uses external trigger */
+	unsigned char range_correction;	/*  =1 we must add 1 to range number */
+	unsigned char old_chan_reg;	/*  lastly used chan/gain pair */
 	unsigned char old_gain_reg;
-	unsigned char mode_reg_int;	// there is stored INT number for some card
-	unsigned char ai_neverending;	// =1 we do unlimited AI
-	unsigned char ai_eos;	// 1=EOS wake up
-	unsigned char ai_dma;	// =1 we use DMA
-	unsigned int ai_poll_ptr;	// how many sampes transfer poll
-	unsigned int ai_scans;	// len of scanlist
-	unsigned int ai_act_scan;	// how many scans we finished
-	unsigned int ai_chanlist[MAX_CHANLIST_LEN];	// our copy of channel/range list
-	unsigned int ai_n_chan;	// how many channels is measured
-	unsigned int ai_flags;	// flaglist
-	unsigned int ai_data_len;	// len of data buffer
-	short *ai_data;	// data buffer
-	unsigned int ai_is16b;	// =1 we have 16 bit card
-	unsigned long dmabuf[2];	// PTR to DMA buf
-	unsigned int dmapages[2];	// how many pages we have allocated
-	unsigned int hwdmaptr[2];	// HW PTR to DMA buf
-	unsigned int hwdmasize[2];	// DMA buf size in bytes
-	unsigned int dmabytestomove[2];	// how many bytes DMA transfer
-	int next_dma_buf;	// which buffer is next to use
-	unsigned int dma_runs_to_end;	// how many times we must switch DMA buffers
-	unsigned int last_dma_run;	// how many bytes to transfer on last DMA buffer
-	unsigned int max_812_ai_mode0_rangewait;	// setling time for gain
-	unsigned int ao_readback[2];	// data for AO readback
+	unsigned char mode_reg_int;	/*  there is stored INT number for some card */
+	unsigned char ai_neverending;	/*  =1 we do unlimited AI */
+	unsigned char ai_eos;	/*  1=EOS wake up */
+	unsigned char ai_dma;	/*  =1 we use DMA */
+	unsigned int ai_poll_ptr;	/*  how many sampes transfer poll */
+	unsigned int ai_scans;	/*  len of scanlist */
+	unsigned int ai_act_scan;	/*  how many scans we finished */
+	unsigned int ai_chanlist[MAX_CHANLIST_LEN];	/*  our copy of channel/range list */
+	unsigned int ai_n_chan;	/*  how many channels is measured */
+	unsigned int ai_flags;	/*  flaglist */
+	unsigned int ai_data_len;	/*  len of data buffer */
+	short *ai_data;	/*  data buffer */
+	unsigned int ai_is16b;	/*  =1 we have 16 bit card */
+	unsigned long dmabuf[2];	/*  PTR to DMA buf */
+	unsigned int dmapages[2];	/*  how many pages we have allocated */
+	unsigned int hwdmaptr[2];	/*  HW PTR to DMA buf */
+	unsigned int hwdmasize[2];	/*  DMA buf size in bytes */
+	unsigned int dmabytestomove[2];	/*  how many bytes DMA transfer */
+	int next_dma_buf;	/*  which buffer is next to use */
+	unsigned int dma_runs_to_end;	/*  how many times we must switch DMA buffers */
+	unsigned int last_dma_run;	/*  how many bytes to transfer on last DMA buffer */
+	unsigned int max_812_ai_mode0_rangewait;	/*  setling time for gain */
+	unsigned int ao_readback[2];	/*  data for AO readback */
 };
 
 
@@ -444,7 +444,7 @@ static int pcl812_ai_insn_read(struct co
 	int timeout, hi;
 
 	outb(devpriv->mode_reg_int | 1, dev->iobase + PCL812_MODE);	/* select software trigger */
-	setup_range_channel(dev, s, insn->chanspec, 1);	// select channel and renge
+	setup_range_channel(dev, s, insn->chanspec, 1);	/*  select channel and renge */
 	for (n = 0; n < insn->n; n++) {
 		outb(255, dev->iobase + PCL812_SOFTTRIG);	/* start conversion */
 		comedi_udelay(5);
@@ -478,7 +478,7 @@ static int acl8216_ai_insn_read(struct c
 	int timeout;
 
 	outb(1, dev->iobase + PCL812_MODE);	/* select software trigger */
-	setup_range_channel(dev, s, insn->chanspec, 1);	// select channel and renge
+	setup_range_channel(dev, s, insn->chanspec, 1);	/*  select channel and renge */
 	for (n = 0; n < insn->n; n++) {
 		outb(255, dev->iobase + PCL812_SOFTTRIG);	/* start conversion */
 		comedi_udelay(5);
@@ -809,18 +809,18 @@ static int pcl812_ai_cmd(struct comedi_d
 			cmd->flags & TRIG_ROUND_MASK);
 	}
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	devpriv->ai_n_chan = cmd->chanlist_len;
 	memcpy(devpriv->ai_chanlist, cmd->chanlist,
 		sizeof(unsigned int) * cmd->scan_end_arg);
-	setup_range_channel(dev, s, devpriv->ai_chanlist[0], 1);	// select first channel and range
+	setup_range_channel(dev, s, devpriv->ai_chanlist[0], 1);	/*  select first channel and range */
 
-	if (devpriv->dma) {	// check if we can use DMA transfer
+	if (devpriv->dma) {	/*  check if we can use DMA transfer */
 		devpriv->ai_dma = 1;
 		for (i = 1; i < devpriv->ai_n_chan; i++)
 			if (devpriv->ai_chanlist[0] != devpriv->ai_chanlist[i]) {
-				devpriv->ai_dma = 0;	// we cann't use DMA :-(
+				devpriv->ai_dma = 0;	/*  we cann't use DMA :-( */
 				break;
 			}
 	} else
@@ -841,14 +841,14 @@ static int pcl812_ai_cmd(struct comedi_d
 	devpriv->ai_poll_ptr = 0;
 	s->async->cur_chan = 0;
 
-	if ((devpriv->ai_flags & TRIG_WAKE_EOS)) {	// don't we want wake up every scan?
+	if ((devpriv->ai_flags & TRIG_WAKE_EOS)) {	/*  don't we want wake up every scan? */
 		devpriv->ai_eos = 1;
 		if (devpriv->ai_n_chan == 1)
-			devpriv->ai_dma = 0;	// DMA is useless for this situation
+			devpriv->ai_dma = 0;	/*  DMA is useless for this situation */
 	}
 
 	if (devpriv->ai_dma) {
-		if (devpriv->ai_eos) {	// we use EOS, so adapt DMA buffer to one scan
+		if (devpriv->ai_eos) {	/*  we use EOS, so adapt DMA buffer to one scan */
 			devpriv->dmabytestomove[0] =
 				devpriv->ai_n_chan * sizeof(short);
 			devpriv->dmabytestomove[1] =
@@ -866,9 +866,9 @@ static int pcl812_ai_cmd(struct comedi_d
 			if (devpriv->ai_neverending) {
 				devpriv->dma_runs_to_end = 1;
 			} else {
-				bytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(short);	// how many samples we must transfer?
-				devpriv->dma_runs_to_end = bytes / devpriv->dmabytestomove[0];	// how many DMA pages we must fill
-				devpriv->last_dma_run = bytes % devpriv->dmabytestomove[0];	//on last dma transfer must be moved
+				bytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(short);	/*  how many samples we must transfer? */
+				devpriv->dma_runs_to_end = bytes / devpriv->dmabytestomove[0];	/*  how many DMA pages we must fill */
+				devpriv->last_dma_run = bytes % devpriv->dmabytestomove[0];	/* on last dma transfer must be moved */
 				if (devpriv->dma_runs_to_end == 0)
 					devpriv->dmabytestomove[0] =
 						devpriv->last_dma_run;
@@ -907,9 +907,9 @@ static int pcl812_ai_cmd(struct comedi_d
 	}
 
 	if (devpriv->ai_dma) {
-		outb(devpriv->mode_reg_int | 2, dev->iobase + PCL812_MODE);	// let's go!
+		outb(devpriv->mode_reg_int | 2, dev->iobase + PCL812_MODE);	/*  let's go! */
 	} else {
-		outb(devpriv->mode_reg_int | 6, dev->iobase + PCL812_MODE);	// let's go!
+		outb(devpriv->mode_reg_int | 6, dev->iobase + PCL812_MODE);	/*  let's go! */
 	}
 
 #ifdef PCL812_EXTDEBUG
@@ -991,7 +991,7 @@ static void transfer_from_dma_buf(struct
 
 	s->async->events = 0;
 	for (i = len; i; i--) {
-		comedi_buf_put(s->async, ptr[bufptr++]);	// get one sample
+		comedi_buf_put(s->async, ptr[bufptr++]);	/*  get one sample */
 
 		if (s->async->cur_chan == 0) {
 			devpriv->ai_act_scan++;
@@ -1085,12 +1085,12 @@ static int pcl812_ai_poll(struct comedi_
 	unsigned int top1, top2, i;
 
 	if (!devpriv->ai_dma)
-		return 0;	// poll is valid only for DMA transfer
+		return 0;	/*  poll is valid only for DMA transfer */
 
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 
 	for (i = 0; i < 10; i++) {
-		top1 = get_dma_residue(devpriv->ai_dma);	// where is now DMA
+		top1 = get_dma_residue(devpriv->ai_dma);	/*  where is now DMA */
 		top2 = get_dma_residue(devpriv->ai_dma);
 		if (top1 == top2)
 			break;
@@ -1101,10 +1101,10 @@ static int pcl812_ai_poll(struct comedi_
 		return 0;
 	}
 
-	top1 = devpriv->dmabytestomove[1 - devpriv->next_dma_buf] - top1;	// where is now DMA in buffer
-	top1 >>= 1;		// sample position
+	top1 = devpriv->dmabytestomove[1 - devpriv->next_dma_buf] - top1;	/*  where is now DMA in buffer */
+	top1 >>= 1;		/*  sample position */
 	top2 = top1 - devpriv->ai_poll_ptr;
-	if (top2 < 1) {		// no new samples
+	if (top2 < 1) {		/*  no new samples */
 		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 		return 0;
 	}
@@ -1113,7 +1113,7 @@ static int pcl812_ai_poll(struct comedi_
 		(void *)devpriv->dmabuf[1 - devpriv->next_dma_buf],
 		devpriv->ai_poll_ptr, top2);
 
-	devpriv->ai_poll_ptr = top1;	// new buffer position
+	devpriv->ai_poll_ptr = top1;	/*  new buffer position */
 
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -1126,24 +1126,24 @@ static int pcl812_ai_poll(struct comedi_
 static void setup_range_channel(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int rangechan, char wait)
 {
-	unsigned char chan_reg = CR_CHAN(rangechan);	// normal board
-	unsigned char gain_reg = CR_RANGE(rangechan) + devpriv->range_correction;	// gain index
+	unsigned char chan_reg = CR_CHAN(rangechan);	/*  normal board */
+	unsigned char gain_reg = CR_RANGE(rangechan) + devpriv->range_correction;	/*  gain index */
 
 	if ((chan_reg == devpriv->old_chan_reg)
 		&& (gain_reg == devpriv->old_gain_reg))
-		return;		// we can return, no change
+		return;		/*  we can return, no change */
 
 	devpriv->old_chan_reg = chan_reg;
 	devpriv->old_gain_reg = gain_reg;
 
 	if (devpriv->use_MPC) {
 		if (devpriv->use_diff) {
-			chan_reg = chan_reg | 0x30;	// DIFF inputs
+			chan_reg = chan_reg | 0x30;	/*  DIFF inputs */
 		} else {
 			if (chan_reg & 0x80) {
-				chan_reg = chan_reg | 0x20;	// SE inputs 8-15
+				chan_reg = chan_reg | 0x20;	/*  SE inputs 8-15 */
 			} else {
-				chan_reg = chan_reg | 0x10;	// SE inputs 0-7
+				chan_reg = chan_reg | 0x10;	/*  SE inputs 0-7 */
 			}
 		}
 	}
@@ -1152,7 +1152,7 @@ static void setup_range_channel(struct c
 	outb(gain_reg, dev->iobase + PCL812_GAIN);	/* select gain */
 
 	if (wait) {
-		comedi_udelay(devpriv->max_812_ai_mode0_rangewait);	// XXX this depends on selected range and can be very long for some high gain ranges!
+		comedi_udelay(devpriv->max_812_ai_mode0_rangewait);	/*  XXX this depends on selected range and can be very long for some high gain ranges! */
 	}
 }
 
@@ -1213,7 +1213,7 @@ static int pcl812_ai_cancel(struct comed
 		disable_dma(devpriv->dma);
 	outb(0, dev->iobase + PCL812_CLRINT);	/* clear INT request */
 	outb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);	/* Stop A/D */
-	start_pacer(dev, -1, 0, 0);	// stop 8254
+	start_pacer(dev, -1, 0, 0);	/*  stop 8254 */
 	outb(0, dev->iobase + PCL812_CLRINT);	/* clear INT request */
 #ifdef PCL812_EXTDEBUG
 	rt_printk("pcl812 EDBG: END: pcl812_ai_cancel(...)\n");
@@ -1231,7 +1231,7 @@ static void pcl812_reset(struct comedi_d
 #endif
 	outb(0, dev->iobase + PCL812_MUX);
 	outb(0 + devpriv->range_correction, dev->iobase + PCL812_GAIN);
-	devpriv->old_chan_reg = -1;	// invalidate chain/gain memory
+	devpriv->old_chan_reg = -1;	/*  invalidate chain/gain memory */
 	devpriv->old_gain_reg = -1;
 
 	switch (this_board->board_type) {
@@ -1244,7 +1244,7 @@ static void pcl812_reset(struct comedi_d
 	case boardA821:
 		outb(0, dev->iobase + PCL812_DA1_LO);
 		outb(0, dev->iobase + PCL812_DA1_HI);
-		start_pacer(dev, -1, 0, 0);	// stop 8254
+		start_pacer(dev, -1, 0, 0);	/*  stop 8254 */
 		outb(0, dev->iobase + PCL812_DO_HI);
 		outb(0, dev->iobase + PCL812_DO_LO);
 		outb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);
@@ -1570,7 +1570,7 @@ static int pcl812_attach(struct comedi_d
 	case boardACL8112:
 		devpriv->max_812_ai_mode0_rangewait = 1;
 		if (it->options[3] > 0)
-			devpriv->use_ext_trg = 1;	// we use external trigger
+			devpriv->use_ext_trg = 1;	/*  we use external trigger */
 	case boardA821:
 		devpriv->max_812_ai_mode0_rangewait = 1;
 		devpriv->mode_reg_int = (irq << 4) & 0xf0;
--- a/drivers/staging/comedi/drivers/pcm3724.c
+++ b/drivers/staging/comedi/drivers/pcm3724.c
@@ -66,14 +66,14 @@ static int pcm3724_attach(struct comedi_
 static int pcm3724_detach(struct comedi_device * dev);
 
 struct pcm3724_board {
-	const char *name;	// driver name
-	int dio;		// num of DIO
-	int numofports;		// num of 8255 subdevices
-	unsigned int IRQbits;	// allowed interrupts
-	unsigned int io_range;	// len of IO space
+	const char *name;	/*  driver name */
+	int dio;		/*  num of DIO */
+	int numofports;		/*  num of 8255 subdevices */
+	unsigned int IRQbits;	/*  allowed interrupts */
+	unsigned int io_range;	/*  len of IO space */
 };
 
-//used to track configured dios
+/* used to track configured dios */
 struct priv_pcm3724 {
 	int dio_1;
 	int dio_2;
@@ -98,20 +98,20 @@ static struct comedi_driver driver_pcm37
 
 COMEDI_INITCLEANUP(driver_pcm3724);
 
-//          (setq c-basic-offset 8)
+/* (setq c-basic-offset 8) */
 
 static int subdev_8255_cb(int dir, int port, int data, unsigned long arg)
 {
 	unsigned long iobase = arg;
 	unsigned char inbres;
-	//printk("8255cb %d %d %d %lx\n", dir,port,data,arg);
+	/* printk("8255cb %d %d %d %lx\n", dir,port,data,arg); */
 	if (dir) {
-		//printk("8255 cb   outb(%x, %lx)\n", data, iobase+port);
+		/* printk("8255 cb   outb(%x, %lx)\n", data, iobase+port); */
 		outb(data, iobase + port);
 		return 0;
 	} else {
 		inbres = inb(iobase + port);
-		//printk("8255 cb   inb(%lx) = %x\n", iobase+port, inbres);
+		/* printk("8255 cb   inb(%lx) = %x\n", iobase+port, inbres); */
 		return inbres;
 	}
 }
@@ -173,7 +173,7 @@ static void do_3724_config(struct comedi
 		port_8255_cfg = dev->iobase + SIZE_8255 + _8255_CR;
 	}
 	outb(buffer_config, dev->iobase + 8);	/* update buffer register */
-	//printk("pcm3724 buffer_config (%lx) %d, %x\n", dev->iobase + _8255_CR, chanspec, buffer_config);
+	/* printk("pcm3724 buffer_config (%lx) %d, %x\n", dev->iobase + _8255_CR, chanspec, buffer_config); */
 	outb(config, port_8255_cfg);
 }
 
@@ -187,9 +187,9 @@ static void enable_chan(struct comedi_de
 	priv = (struct priv_pcm3724 *) (dev->private);
 
 	mask = 1 << CR_CHAN(chanspec);
-	if (s == dev->subdevices) {	// subdev 0
+	if (s == dev->subdevices) {	/*  subdev 0 */
 		priv->dio_1 |= mask;
-	} else {		//subdev 1
+	} else {		/* subdev 1 */
 		priv->dio_2 |= mask;
 	}
 	if (priv->dio_1 & 0xff0000) {
@@ -210,7 +210,7 @@ static void enable_chan(struct comedi_de
 	if (priv->dio_2 & 0xff) {
 		gatecfg |= GATE_A1;
 	}
-	//      printk("gate control %x\n", gatecfg);
+	/*       printk("gate control %x\n", gatecfg); */
 	outb(gatecfg, dev->iobase + 9);
 }
 
--- a/drivers/staging/comedi/drivers/pcm3730.c
+++ b/drivers/staging/comedi/drivers/pcm3730.c
@@ -19,9 +19,9 @@ Configuration options:
 
 #include <linux/ioport.h>
 
-#define PCM3730_SIZE 4		// consecutive io port addresses
+#define PCM3730_SIZE 4		/*  consecutive io port addresses */
 
-#define PCM3730_DOA 0		// offsets for each port
+#define PCM3730_DOA 0		/*  offsets for each port */
 #define PCM3730_DOB 2
 #define PCM3730_DOC 3
 #define PCM3730_DIA 0
--- a/drivers/staging/comedi/drivers/poc.c
+++ b/drivers/staging/comedi/drivers/poc.c
@@ -72,7 +72,7 @@ static const struct boarddef_struct boar
 	{
 	      name:	"dac02",
 	      iosize:	8,
-			//setup:                dac02_setup,
+			/* setup:                dac02_setup, */
 	      type:	COMEDI_SUBD_AO,
 	      n_chan:	2,
 	      n_bits:	12,
@@ -196,7 +196,7 @@ static int dac02_ao_winsn(struct comedi_
 	((unsigned int *) dev->private)[chan] = data[0];
 	output = data[0];
 #ifdef wrong
-	// convert to complementary binary if range is bipolar
+	/*  convert to complementary binary if range is bipolar */
 	if ((CR_RANGE(insn->chanspec) & 0x2) == 0)
 		output = ~output;
 #endif
--- a/drivers/staging/comedi/drivers/rti800.c
+++ b/drivers/staging/comedi/drivers/rti800.c
@@ -177,7 +177,7 @@ static irqreturn_t rti800_interrupt(int 
 	return IRQ_HANDLED;
 }
 
-// settling delay times in usec for different gains
+/* settling delay times in usec for different gains */
 static const int gaindelay[] = { 10, 20, 40, 80 };
 
 static int rti800_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
--- a/drivers/staging/comedi/drivers/serial2002.c
+++ b/drivers/staging/comedi/drivers/serial2002.c
@@ -62,7 +62,7 @@ static const struct serial2002_board ser
 
 struct serial2002_range_table_t {
 
-	// HACK...
+	/*  HACK... */
 	int length;
 	struct comedi_krange range;
 };
@@ -70,8 +70,8 @@ struct serial2002_range_table_t {
 
 struct serial2002_private {
 
-	int port;		// /dev/ttyS<port>
-	int speed;		// baudrate
+	int port;		/*  /dev/ttyS<port> */
+	int speed;		/*  baudrate */
 	struct file *tty;
 	unsigned int ao_readback[32];
 	unsigned char digital_in_mapping[32];
@@ -238,11 +238,11 @@ static void tty_setspeed(struct file *f,
 	oldfs = get_fs();
 	set_fs(KERNEL_DS);
 	{
-		// Set speed
+		/*  Set speed */
 		struct termios settings;
 
 		tty_ioctl(f, TCGETS, (unsigned long)&settings);
-//    printk("Speed: %d\n", settings.c_cflag & (CBAUD | CBAUDEX));
+/* printk("Speed: %d\n", settings.c_cflag & (CBAUD | CBAUDEX)); */
 		settings.c_iflag = 0;
 		settings.c_oflag = 0;
 		settings.c_lflag = 0;
@@ -284,10 +284,10 @@ static void tty_setspeed(struct file *f,
 			break;
 		}
 		tty_ioctl(f, TCSETS, (unsigned long)&settings);
-//    printk("Speed: %d\n", settings.c_cflag & (CBAUD | CBAUDEX));
+/* printk("Speed: %d\n", settings.c_cflag & (CBAUD | CBAUDEX)); */
 	}
 	{
-		// Set low latency
+		/*  Set low latency */
 		struct serial_struct settings;
 
 		tty_ioctl(f, TIOCGSERIAL, (unsigned long)&settings);
@@ -437,7 +437,7 @@ static void serial_2002_open(struct come
 		}
 
 		tty_setspeed(devpriv->tty, devpriv->speed);
-		poll_channel(devpriv->tty, 31);	// Start reading configuration
+		poll_channel(devpriv->tty, 31);	/*  Start reading configuration */
 		while (1) {
 			struct serial_data data;
 
@@ -557,7 +557,7 @@ static void serial_2002_open(struct come
 			}
 		}
 		for (i = 0; i <= 4; i++) {
-			// Fill in subdev data
+			/*  Fill in subdev data */
 			struct config_t *c;
 			unsigned char *mapping = 0;
 			struct serial2002_range_table_t *range = 0;
--- a/drivers/staging/comedi/drivers/ssv_dnp.c
+++ b/drivers/staging/comedi/drivers/ssv_dnp.c
@@ -74,7 +74,6 @@ static const struct dnp_board dnp_boards
 /* This structure is for data unique to the DNP driver --------------------- */
 struct dnp_private_data {
 
-	//
 };
 
 
@@ -126,7 +125,7 @@ static int dnp_attach(struct comedi_devi
 
 	/* Autoprobing: this should find out which board we have. Currently only   */
 	/* the 1486 board is supported and autoprobing is not implemented :-)      */
-	//dev->board_ptr = dnp_probe(dev);
+	/* dev->board_ptr = dnp_probe(dev); */
 
 	/* Initialize the name of the board. We can use the "thisboard" macro now. */
 	dev->board_name = thisboard->name;
--- a/drivers/staging/comedi/drivers/unioxx5.c
+++ b/drivers/staging/comedi/drivers/unioxx5.c
@@ -94,7 +94,7 @@ static int __unioxx5_digital_write(struc
 	int channel, int minor);
 static int __unioxx5_digital_read(struct unioxx5_subd_priv * usp, unsigned int * data,
 	int channel, int minor);
-//static void __unioxx5_digital_config(struct unioxx5_subd_priv* usp, int mode);
+/* static void __unioxx5_digital_config(struct unioxx5_subd_priv* usp, int mode); */
 static int __unioxx5_analog_write(struct unioxx5_subd_priv * usp, unsigned int * data,
 	int channel, int minor);
 static int __unioxx5_analog_read(struct unioxx5_subd_priv * usp, unsigned int * data,
@@ -418,7 +418,7 @@ static int __unioxx5_analog_write(struct
 	/* saving major byte */
 	usp->usp_extra_data[module][i] = (unsigned char)((*data & 0xFF00) >> 8);
 
-	//while(!((inb(usp->usp_iobase + 0)) & TxBE));
+	/* while(!((inb(usp->usp_iobase + 0)) & TxBE)); */
 	outb(module + 1, usp->usp_iobase + 5);	/* sending module number to card(1 .. 12) */
 	outb('W', usp->usp_iobase + 6);	/* sends (W)rite command to module */
 
--- a/drivers/staging/comedi/kcomedilib/ksyms.c
+++ b/drivers/staging/comedi/kcomedilib/ksyms.c
@@ -59,7 +59,7 @@ EXPORT_SYMBOL(comedi_close);
 EXPORT_SYMBOL(comedi_loglevel);
 EXPORT_SYMBOL(comedi_perror);
 EXPORT_SYMBOL(comedi_strerror);
-//EXPORT_SYMBOL(comedi_errno);
+/* EXPORT_SYMBOL(comedi_errno); */
 EXPORT_SYMBOL(comedi_fileno);
 
 /* device queries */
@@ -73,8 +73,10 @@ EXPORT_SYMBOL(comedi_get_subdevice_type)
 EXPORT_SYMBOL(comedi_find_subdevice_by_type);
 EXPORT_SYMBOL(comedi_get_subdevice_flags);
 EXPORT_SYMBOL(comedi_get_n_channels);
-//EXPORT_SYMBOL(comedi_range_is_chan_specific);
-//EXPORT_SYMBOL(comedi_maxdata_is_chan_specific);
+/*
+* EXPORT_SYMBOL(comedi_range_is_chan_specific);
+* EXPORT_SYMBOL(comedi_maxdata_is_chan_specific);
+*/
 
 /* channel queries */
 EXPORT_SYMBOL(comedi_get_maxdata);
@@ -82,25 +84,29 @@ EXPORT_SYMBOL(comedi_get_maxdata);
 EXPORT_SYMBOL(comedi_get_rangetype);
 #endif
 EXPORT_SYMBOL(comedi_get_n_ranges);
-//EXPORT_SYMBOL(comedi_find_range);
+/* EXPORT_SYMBOL(comedi_find_range); */
 
 /* buffer queries */
 EXPORT_SYMBOL(comedi_get_buffer_size);
-//EXPORT_SYMBOL(comedi_get_max_buffer_size);
-//EXPORT_SYMBOL(comedi_set_buffer_size);
+/*
+* EXPORT_SYMBOL(comedi_get_max_buffer_size);
+* EXPORT_SYMBOL(comedi_set_buffer_size);
+*/
 EXPORT_SYMBOL(comedi_get_buffer_contents);
 EXPORT_SYMBOL(comedi_get_buffer_offset);
 
 /* low-level stuff */
-//EXPORT_SYMBOL(comedi_trigger);
-//EXPORT_SYMBOL(comedi_do_insnlist);
+/*
+* EXPORT_SYMBOL(comedi_trigger); EXPORT_SYMBOL(comedi_do_insnlist);
+*/
 EXPORT_SYMBOL(comedi_do_insn);
 EXPORT_SYMBOL(comedi_lock);
 EXPORT_SYMBOL(comedi_unlock);
 
 /* physical units */
-//EXPORT_SYMBOL(comedi_to_phys);
-//EXPORT_SYMBOL(comedi_from_phys);
+/*
+* EXPORT_SYMBOL(comedi_to_phys); EXPORT_SYMBOL(comedi_from_phys);
+*/
 
 /* synchronous stuff */
 EXPORT_SYMBOL(comedi_data_read);
@@ -113,13 +119,16 @@ EXPORT_SYMBOL(comedi_dio_write);
 EXPORT_SYMBOL(comedi_dio_bitfield);
 
 /* slowly varying stuff */
-//EXPORT_SYMBOL(comedi_sv_init);
-//EXPORT_SYMBOL(comedi_sv_update);
-//EXPORT_SYMBOL(comedi_sv_measure);
+/*
+* EXPORT_SYMBOL(comedi_sv_init); EXPORT_SYMBOL(comedi_sv_update);
+* EXPORT_SYMBOL(comedi_sv_measure);
+*/
 
 /* commands */
-//EXPORT_SYMBOL(comedi_get_cmd_src_mask);
-//EXPORT_SYMBOL(comedi_get_cmd_generic_timed);
+/*
+* EXPORT_SYMBOL(comedi_get_cmd_src_mask);
+* EXPORT_SYMBOL(comedi_get_cmd_generic_timed);
+*/
 EXPORT_SYMBOL(comedi_cancel);
 EXPORT_SYMBOL(comedi_command);
 EXPORT_SYMBOL(comedi_command_test);
@@ -129,12 +138,14 @@ EXPORT_SYMBOL(comedi_poll);
 EXPORT_SYMBOL(comedi_mark_buffer_read);
 EXPORT_SYMBOL(comedi_mark_buffer_written);
 
-//EXPORT_SYMBOL(comedi_get_range);
+/* EXPORT_SYMBOL(comedi_get_range); */
 EXPORT_SYMBOL(comedi_get_len_chanlist);
 
 /* deprecated */
-//EXPORT_SYMBOL(comedi_get_timer);
-//EXPORT_SYMBOL(comedi_timed_1chan);
+/*
+* EXPORT_SYMBOL(comedi_get_timer);
+* EXPORT_SYMBOL(comedi_timed_1chan);
+*/
 
 /* alpha */
-//EXPORT_SYMBOL(comedi_set_global_oor_behavior);
+/* EXPORT_SYMBOL(comedi_set_global_oor_behavior); */
