From wfp5p@virginia.edu Fri Mar 27 08:31:09 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Fri, 27 Mar 2009 11:31:06 -0400
Subject: Staging: comedi: remove C99 comments in ni_at_a2150.c
To: greg@kroah.com
Cc: abbotti@mev.co.uk, fmhess@users.sourceforge.net, ds@schleef.org
Message-ID: <20090327153105.7154.83289.stgit@viridian.itc.Virginia.EDU>


Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/comedi/drivers/ni_at_a2150.c |  182 +++++++++++++--------------
 1 file changed, 91 insertions(+), 91 deletions(-)

--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -73,10 +73,10 @@ TRIG_WAKE_EOS
 #include "comedi_fc.h"
 
 #define A2150_SIZE           28
-#define A2150_DMA_BUFFER_SIZE	0xff00	// size in bytes of dma buffer
+#define A2150_DMA_BUFFER_SIZE	0xff00	/*  size in bytes of dma buffer */
 
-//#define A2150_DEBUG   // enable debugging code
-#undef A2150_DEBUG		// disable debugging code
+/* #define A2150_DEBUG     enable debugging code */
+#undef A2150_DEBUG		/*  disable debugging code */
 
 /* Registers and bits */
 #define CONFIG_REG		0x0
@@ -85,48 +85,48 @@ TRIG_WAKE_EOS
 #define   CLOCK_SELECT_BITS(x)		(((x) & 0x3) << 3)
 #define   CLOCK_DIVISOR_BITS(x)		(((x) & 0x3) << 5)
 #define   CLOCK_MASK		(0xf << 3)
-#define   ENABLE0_BIT		0x80	// enable (don't internally ground) channels 0 and 1
-#define   ENABLE1_BIT		0x100	// enable (don't internally ground) channels 2 and 3
-#define   AC0_BIT		0x200	// ac couple channels 0,1
-#define   AC1_BIT		0x400	// ac couple channels 2,3
-#define   APD_BIT		0x800	// analog power down
-#define   DPD_BIT		0x1000	// digital power down
-#define TRIGGER_REG		0x2	// trigger config register
+#define   ENABLE0_BIT		0x80	/*  enable (don't internally ground) channels 0 and 1 */
+#define   ENABLE1_BIT		0x100	/*  enable (don't internally ground) channels 2 and 3 */
+#define   AC0_BIT		0x200	/*  ac couple channels 0,1 */
+#define   AC1_BIT		0x400	/*  ac couple channels 2,3 */
+#define   APD_BIT		0x800	/*  analog power down */
+#define   DPD_BIT		0x1000	/*  digital power down */
+#define TRIGGER_REG		0x2	/*  trigger config register */
 #define   POST_TRIGGER_BITS		0x2
 #define   DELAY_TRIGGER_BITS		0x3
-#define   HW_TRIG_EN		0x10	// enable hardware trigger
-#define FIFO_START_REG		0x6	// software start aquistion trigger
-#define FIFO_RESET_REG		0x8	// clears fifo + fifo flags
-#define FIFO_DATA_REG		0xa	// read data
-#define DMA_TC_CLEAR_REG		0xe	// clear dma terminal count interrupt
-#define STATUS_REG		0x12	// read only
-#define   FNE_BIT		0x1	// fifo not empty
-#define   OVFL_BIT		0x8	// fifo overflow
-#define   EDAQ_BIT		0x10	// end of aquisition interrupt
-#define   DCAL_BIT		0x20	// offset calibration in progress
-#define   INTR_BIT		0x40	// interrupt has occured
-#define   DMA_TC_BIT		0x80	// dma terminal count interrupt has occured
+#define   HW_TRIG_EN		0x10	/*  enable hardware trigger */
+#define FIFO_START_REG		0x6	/*  software start aquistion trigger */
+#define FIFO_RESET_REG		0x8	/*  clears fifo + fifo flags */
+#define FIFO_DATA_REG		0xa	/*  read data */
+#define DMA_TC_CLEAR_REG		0xe	/*  clear dma terminal count interrupt */
+#define STATUS_REG		0x12	/*  read only */
+#define   FNE_BIT		0x1	/*  fifo not empty */
+#define   OVFL_BIT		0x8	/*  fifo overflow */
+#define   EDAQ_BIT		0x10	/*  end of aquisition interrupt */
+#define   DCAL_BIT		0x20	/*  offset calibration in progress */
+#define   INTR_BIT		0x40	/*  interrupt has occured */
+#define   DMA_TC_BIT		0x80	/*  dma terminal count interrupt has occured */
 #define   ID_BITS(x)	(((x) >> 8) & 0x3)
-#define IRQ_DMA_CNTRL_REG		0x12	// write only
-#define   DMA_CHAN_BITS(x)		((x) & 0x7)	// sets dma channel
-#define   DMA_EN_BIT		0x8	// enables dma
-#define   IRQ_LVL_BITS(x)		(((x) & 0xf) << 4)	// sets irq level
-#define   FIFO_INTR_EN_BIT		0x100	// enable fifo interrupts
-#define   FIFO_INTR_FHF_BIT		0x200	// interrupt fifo half full
-#define   DMA_INTR_EN_BIT 		0x800	// enable interrupt on dma terminal count
-#define   DMA_DEM_EN_BIT	0x1000	// enables demand mode dma
+#define IRQ_DMA_CNTRL_REG		0x12	/*  write only */
+#define   DMA_CHAN_BITS(x)		((x) & 0x7)	/*  sets dma channel */
+#define   DMA_EN_BIT		0x8	/*  enables dma */
+#define   IRQ_LVL_BITS(x)		(((x) & 0xf) << 4)	/*  sets irq level */
+#define   FIFO_INTR_EN_BIT		0x100	/*  enable fifo interrupts */
+#define   FIFO_INTR_FHF_BIT		0x200	/*  interrupt fifo half full */
+#define   DMA_INTR_EN_BIT 		0x800	/*  enable interrupt on dma terminal count */
+#define   DMA_DEM_EN_BIT	0x1000	/*  enables demand mode dma */
 #define I8253_BASE_REG		0x14
 #define I8253_MODE_REG		0x17
-#define   HW_COUNT_DISABLE		0x30	// disable hardware counting of conversions
+#define   HW_COUNT_DISABLE		0x30	/*  disable hardware counting of conversions */
 
 struct a2150_board {
 	const char *name;
-	int clock[4];		// master clock periods, in nanoseconds
-	int num_clocks;		// number of available master clock speeds
-	int ai_speed;		// maximum conversion rate in nanoseconds
+	int clock[4];		/*  master clock periods, in nanoseconds */
+	int num_clocks;		/*  number of available master clock speeds */
+	int ai_speed;		/*  maximum conversion rate in nanoseconds */
 };
 
-//analog input range
+/* analog input range */
 static const struct comedi_lrange range_a2150 = {
 	1,
 	{
@@ -134,7 +134,7 @@ static const struct comedi_lrange range_
 		}
 };
 
-// enum must match board indices
+/* enum must match board indices */
 enum { a2150_c, a2150_s };
 static const struct a2150_board a2150_boards[] = {
 	{
@@ -159,11 +159,11 @@ static const struct a2150_board a2150_bo
 struct a2150_private {
 
 	volatile unsigned int count;	/* number of data points left to be taken */
-	unsigned int dma;	// dma channel
-	s16 *dma_buffer;	// dma buffer
-	unsigned int dma_transfer_size;	// size in bytes of dma transfers
-	int irq_dma_bits;	// irq/dma register bits
-	int config_bits;	// config register bits
+	unsigned int dma;	/*  dma channel */
+	s16 *dma_buffer;	/*  dma buffer */
+	unsigned int dma_transfer_size;	/*  size in bytes of dma transfers */
+	int irq_dma_bits;	/*  irq/dma register bits */
+	int config_bits;	/*  config register bits */
 };
 
 
@@ -226,7 +226,7 @@ static irqreturn_t a2150_interrupt(int i
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
-	// initialize async here to make sure s is not NULL
+	/*  initialize async here to make sure s is not NULL */
 	async = s->async;
 	async->events = 0;
 	cmd = &async->cmd;
@@ -258,7 +258,7 @@ static irqreturn_t a2150_interrupt(int i
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv->dma);
 
-	// figure out how many points to read
+	/*  figure out how many points to read */
 	max_points = devpriv->dma_transfer_size / sample_size;
 	/* residue is the number of points left to be done on the dma
 	 * transfer.  It should always be zero at this point unless
@@ -269,7 +269,7 @@ static irqreturn_t a2150_interrupt(int i
 	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
 
-	// figure out how many points will be stored next time
+	/*  figure out how many points will be stored next time */
 	leftover = 0;
 	if (cmd->stop_src == TRIG_NONE) {
 		leftover = devpriv->dma_transfer_size / sample_size;
@@ -288,7 +288,7 @@ static irqreturn_t a2150_interrupt(int i
 	for (i = 0; i < num_points; i++) {
 		/* write data point to comedi buffer */
 		dpnt = devpriv->dma_buffer[i];
-		// convert from 2's complement to unsigned coding
+		/*  convert from 2's complement to unsigned coding */
 		dpnt ^= 0x8000;
 		cfc_write_to_buffer(s, dpnt);
 		if (cmd->stop_src == TRIG_COUNT) {
@@ -299,7 +299,7 @@ static irqreturn_t a2150_interrupt(int i
 			}
 		}
 	}
-	// re-enable  dma
+	/*  re-enable  dma */
 	if (leftover) {
 		set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
 		set_dma_count(devpriv->dma, leftover * sample_size);
@@ -317,7 +317,7 @@ static irqreturn_t a2150_interrupt(int i
 	return IRQ_HANDLED;
 }
 
-// probes board type, returns offset
+/* probes board type, returns offset */
 static int a2150_probe(struct comedi_device * dev)
 {
 	int status = inw(dev->iobase + STATUS_REG);
@@ -365,7 +365,7 @@ static int a2150_attach(struct comedi_de
 
 	/* grab our IRQ */
 	if (irq) {
-		// check that irq is supported
+		/*  check that irq is supported */
 		if (irq < 3 || irq == 8 || irq == 13 || irq > 15) {
 			printk(" invalid irq line %u\n", irq);
 			return -EINVAL;
@@ -378,7 +378,7 @@ static int a2150_attach(struct comedi_de
 		devpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);
 		dev->irq = irq;
 	}
-	// initialize dma
+	/*  initialize dma */
 	if (dma) {
 		if (dma == 4 || dma > 7) {
 			printk(" invalid dma channel %u\n", dma);
@@ -424,16 +424,16 @@ static int a2150_attach(struct comedi_de
 	 * prevent hardware count from stopping aquisition */
 	outw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);
 
-	// set card's irq and dma levels
+	/*  set card's irq and dma levels */
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	// reset and sync adc clock circuitry
+	/*  reset and sync adc clock circuitry */
 	outw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);
 	outw_p(DPD_BIT, dev->iobase + CONFIG_REG);
-	// initialize configuration register
+	/*  initialize configuration register */
 	devpriv->config_bits = 0;
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
-	// wait until offset calibration is done, then enable analog inputs
+	/*  wait until offset calibration is done, then enable analog inputs */
 	for (i = 0; i < timeout; i++) {
 		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
 			break;
@@ -455,7 +455,7 @@ static int a2150_detach(struct comedi_de
 
 	/* only free stuff if it has been allocated by _attach */
 	if (dev->iobase) {
-		// put board in power-down mode
+		/*  put board in power-down mode */
 		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
 		release_region(dev->iobase, A2150_SIZE);
 	}
@@ -474,14 +474,14 @@ static int a2150_detach(struct comedi_de
 
 static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	// disable dma on card
+	/*  disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	// disable computer's dma
+	/*  disable computer's dma */
 	disable_dma(devpriv->dma);
 
-	// clear fifo and reset triggering circuitry
+	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	return 0;
@@ -582,7 +582,7 @@ static int a2150_ai_cmdtest(struct comed
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist) {
 		startChan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
@@ -635,7 +635,7 @@ static int a2150_ai_cmd(struct comedi_de
 			" dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
 		return -1;
 	}
-	// clear fifo and reset triggering circuitry
+	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	/* setup chanlist */
@@ -643,7 +643,7 @@ static int a2150_ai_cmd(struct comedi_de
 			cmd->chanlist_len) < 0)
 		return -1;
 
-	// setup ac/dc coupling
+	/*  setup ac/dc coupling */
 	if (CR_AREF(cmd->chanlist[0]) == AREF_OTHER)
 		devpriv->config_bits |= AC0_BIT;
 	else
@@ -653,23 +653,23 @@ static int a2150_ai_cmd(struct comedi_de
 	else
 		devpriv->config_bits &= ~AC1_BIT;
 
-	// setup timing
+	/*  setup timing */
 	a2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);
 
-	// send timing, channel, config bits
+	/*  send timing, channel, config bits */
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
 
-	// initialize number of samples remaining
+	/*  initialize number of samples remaining */
 	devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 
-	// enable computer's dma
+	/*  enable computer's dma */
 	lock_flags = claim_dma_lock();
 	disable_dma(devpriv->dma);
 	/* clear flip-flop to make sure 2-byte registers for
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv->dma);
 	set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
-	// set size of transfer to fill in 1/3 second
+	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
 	devpriv->dma_transfer_size =
 		sizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *
@@ -688,36 +688,36 @@ static int a2150_ai_cmd(struct comedi_de
 	 * one spurious interrupt that has been happening */
 	outw(0x00, dev->iobase + DMA_TC_CLEAR_REG);
 
-	// enable dma on card
+	/*  enable dma on card */
 	devpriv->irq_dma_bits |= DMA_INTR_EN_BIT | DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	// may need to wait 72 sampling periods if timing was changed
+	/*  may need to wait 72 sampling periods if timing was changed */
 	i8254_load(dev->iobase + I8253_BASE_REG, 0, 2, 72, 0);
 
-	// setup start triggering
+	/*  setup start triggering */
 	trigger_bits = 0;
-	// decide if we need to wait 72 periods for valid data
+	/*  decide if we need to wait 72 periods for valid data */
 	if (cmd->start_src == TRIG_NOW &&
 		(old_config_bits & CLOCK_MASK) !=
 		(devpriv->config_bits & CLOCK_MASK)) {
-		// set trigger source to delay trigger
+		/*  set trigger source to delay trigger */
 		trigger_bits |= DELAY_TRIGGER_BITS;
 	} else {
-		// otherwise no delay
+		/*  otherwise no delay */
 		trigger_bits |= POST_TRIGGER_BITS;
 	}
-	// enable external hardware trigger
+	/*  enable external hardware trigger */
 	if (cmd->start_src == TRIG_EXT) {
 		trigger_bits |= HW_TRIG_EN;
 	} else if (cmd->start_src == TRIG_OTHER) {
-		// XXX add support for level/slope start trigger using TRIG_OTHER
+		/*  XXX add support for level/slope start trigger using TRIG_OTHER */
 		comedi_error(dev, "you shouldn't see this?");
 	}
-	// send trigger config bits
+	/*  send trigger config bits */
 	outw(trigger_bits, dev->iobase + TRIGGER_REG);
 
-	// start aquisition for soft trigger
+	/*  start aquisition for soft trigger */
 	if (cmd->start_src == TRIG_NOW) {
 		outw(0, dev->iobase + FIFO_START_REG);
 	}
@@ -735,28 +735,28 @@ static int a2150_ai_rinsn(struct comedi_
 	static const int timeout = 100000;
 	static const int filter_delay = 36;
 
-	// clear fifo and reset triggering circuitry
+	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	/* setup chanlist */
 	if (a2150_set_chanlist(dev, CR_CHAN(insn->chanspec), 1) < 0)
 		return -1;
 
-	// set dc coupling
+	/*  set dc coupling */
 	devpriv->config_bits &= ~AC0_BIT;
 	devpriv->config_bits &= ~AC1_BIT;
 
-	// send timing, channel, config bits
+	/*  send timing, channel, config bits */
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
 
-	// disable dma on card
+	/*  disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	// setup start triggering
+	/*  setup start triggering */
 	outw(0, dev->iobase + TRIGGER_REG);
 
-	// start aquisition for soft trigger
+	/*  start aquisition for soft trigger */
 	outw(0, dev->iobase + FIFO_START_REG);
 
 	/* there is a 35.6 sample delay for data to get through the antialias filter */
@@ -773,7 +773,7 @@ static int a2150_ai_rinsn(struct comedi_
 		inw(dev->iobase + FIFO_DATA_REG);
 	}
 
-	// read data
+	/*  read data */
 	for (n = 0; n < insn->n; n++) {
 		for (i = 0; i < timeout; i++) {
 			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
@@ -794,7 +794,7 @@ static int a2150_ai_rinsn(struct comedi_
 		data[n] ^= 0x8000;
 	}
 
-	// clear fifo and reset triggering circuitry
+	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	return n;
@@ -809,7 +809,7 @@ static int a2150_get_timing(struct comed
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
 	int i, j;
 
-	// initialize greatest lower and least upper bounds
+	/*  initialize greatest lower and least upper bounds */
 	lub_divisor_shift = 3;
 	lub_index = 0;
 	lub = thisboard->clock[lub_index] * (1 << lub_divisor_shift);
@@ -817,19 +817,19 @@ static int a2150_get_timing(struct comed
 	glb_index = thisboard->num_clocks - 1;
 	glb = thisboard->clock[glb_index] * (1 << glb_divisor_shift);
 
-	// make sure period is in available range
+	/*  make sure period is in available range */
 	if (*period < glb)
 		*period = glb;
 	if (*period > lub)
 		*period = lub;
 
-	// we can multiply period by 1, 2, 4, or 8, using (1 << i)
+	/*  we can multiply period by 1, 2, 4, or 8, using (1 << i) */
 	for (i = 0; i < 4; i++) {
-		// there are a maximum of 4 master clocks
+		/*  there are a maximum of 4 master clocks */
 		for (j = 0; j < thisboard->num_clocks; j++) {
-			// temp is the period in nanosec we are evaluating
+			/*  temp is the period in nanosec we are evaluating */
 			temp = thisboard->clock[j] * (1 << i);
-			// if it is the best match yet
+			/*  if it is the best match yet */
 			if (temp < lub && temp >= *period) {
 				lub_divisor_shift = i;
 				lub_index = j;
@@ -846,7 +846,7 @@ static int a2150_get_timing(struct comed
 	switch (flags) {
 	case TRIG_ROUND_NEAREST:
 	default:
-		// if least upper bound is better approximation
+		/*  if least upper bound is better approximation */
 		if (lub - *period < *period - glb) {
 			*period = lub;
 		} else {
@@ -861,7 +861,7 @@ static int a2150_get_timing(struct comed
 		break;
 	}
 
-	// set clock bits for config register appropriately
+	/*  set clock bits for config register appropriately */
 	devpriv->config_bits &= ~CLOCK_MASK;
 	if (*period == lub) {
 		devpriv->config_bits |=
