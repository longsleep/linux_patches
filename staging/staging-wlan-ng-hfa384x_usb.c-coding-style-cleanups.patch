From jmm@debian.org  Sun Feb  8 13:42:05 2009
From: Moritz Muehlenhoff <jmm@debian.org>
Date: Sun,  8 Feb 2009 02:21:00 +0100
Subject: Staging: wlan-ng: hfa384x_usb.c: Coding style cleanups
To: greg@kroah.com
Cc: Moritz Muehlenhoff <jmm@debian.org>
Message-ID: <1234056065-25818-16-git-send-email-jmm@debian.org>


Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/wlan-ng/hfa384x_usb.c | 1839 +++++++++++++++-------------------
 1 file changed, 817 insertions(+), 1022 deletions(-)

--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -110,9 +110,6 @@
 * --------------------------------------------------------------------
 */
 
-/*================================================================*/
-/* System Includes */
-
 #include <linux/version.h>
 
 #include <linux/module.h>
@@ -150,13 +147,9 @@
 #include "hfa384x.h"
 #include "prism2mgmt.h"
 
-/*================================================================*/
-/* Local Constants */
-
-enum cmd_mode
-{
-  DOWAIT = 0,
-  DOASYNC
+enum cmd_mode {
+	DOWAIT = 0,
+	DOASYNC
 };
 typedef enum cmd_mode CMD_MODE;
 
@@ -164,50 +157,33 @@ typedef enum cmd_mode CMD_MODE;
 #define URB_ASYNC_UNLINK 0
 #define USB_QUEUE_BULK 0
 
-/*================================================================*/
-/* Local Macros */
-
 #define ROUNDUP64(a) (((a)+63)&~63)
 
-/*================================================================*/
-/* Local Function Declarations */
-
 #ifdef DEBUG_USB
-static void
-dbprint_urb(struct urb* urb);
+static void dbprint_urb(struct urb *urb);
 #endif
 
 static void
-hfa384x_int_rxmonitor(
-	wlandevice_t *wlandev,
-	hfa384x_usb_rxfrm_t *rxfrm);
+hfa384x_int_rxmonitor(wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm);
 
-static void
-hfa384x_usb_defer(struct work_struct *data);
+static void hfa384x_usb_defer(struct work_struct *data);
 
-static int
-submit_rx_urb(hfa384x_t *hw, gfp_t flags);
+static int submit_rx_urb(hfa384x_t *hw, gfp_t flags);
 
-static int
-submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
+static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
 
 /*---------------------------------------------------*/
 /* Callbacks */
-static void
-hfa384x_usbout_callback(struct urb *urb);
-static void
-hfa384x_ctlxout_callback(struct urb *urb);
-static void
-hfa384x_usbin_callback(struct urb *urb);
+static void hfa384x_usbout_callback(struct urb *urb);
+static void hfa384x_ctlxout_callback(struct urb *urb);
+static void hfa384x_usbin_callback(struct urb *urb);
 
 static void
 hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
 
-static void
-hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
+static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
 
-static void
-hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
 
 static void
 hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
@@ -218,123 +194,94 @@ static void hfa384x_usbin_ctlx(hfa384x_t
 /*---------------------------------------------------*/
 /* Functions to support the prism2 usb command queue */
 
-static void
-hfa384x_usbctlxq_run(hfa384x_t *hw);
+static void hfa384x_usbctlxq_run(hfa384x_t *hw);
 
-static void
-hfa384x_usbctlx_reqtimerfn(unsigned long data);
+static void hfa384x_usbctlx_reqtimerfn(unsigned long data);
 
-static void
-hfa384x_usbctlx_resptimerfn(unsigned long data);
+static void hfa384x_usbctlx_resptimerfn(unsigned long data);
 
-static void
-hfa384x_usb_throttlefn(unsigned long data);
+static void hfa384x_usb_throttlefn(unsigned long data);
 
-static void
-hfa384x_usbctlx_completion_task(unsigned long data);
+static void hfa384x_usbctlx_completion_task(unsigned long data);
 
-static void
-hfa384x_usbctlx_reaper_task(unsigned long data);
+static void hfa384x_usbctlx_reaper_task(unsigned long data);
 
-static int
-hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
-static void
-unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
-struct usbctlx_completor
-{
-	int (*complete)(struct usbctlx_completor*);
+struct usbctlx_completor {
+	int (*complete) (struct usbctlx_completor *);
 };
 typedef struct usbctlx_completor usbctlx_completor_t;
 
 static int
 hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
-                              hfa384x_usbctlx_t *ctlx,
-                              usbctlx_completor_t *completor);
+			      hfa384x_usbctlx_t *ctlx,
+			      usbctlx_completor_t *completor);
 
 static int
 unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
-static void
-hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
-static void
-hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
 static int
 usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
-                   hfa384x_cmdresult_t *result);
+		   hfa384x_cmdresult_t *result);
 
 static void
 usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
-                       hfa384x_rridresult_t *result);
+		       hfa384x_rridresult_t *result);
 
 /*---------------------------------------------------*/
 /* Low level req/resp CTLX formatters and submitters */
 static int
-hfa384x_docmd(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	hfa384x_metacmd_t *cmd,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_docmd(hfa384x_t *hw,
+	      CMD_MODE mode,
+	      hfa384x_metacmd_t *cmd,
+	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dorrid(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	rid,
-	void	*riddata,
-	unsigned int	riddatalen,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_dorrid(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 rid,
+	       void *riddata,
+	       unsigned int riddatalen,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowrid(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	rid,
-	void	*riddata,
-	unsigned int	riddatalen,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_dowrid(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 rid,
+	       void *riddata,
+	       unsigned int riddatalen,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dormem(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	page,
-	u16	offset,
-	void	*data,
-	unsigned int	len,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_dormem(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 page,
+	       u16 offset,
+	       void *data,
+	       unsigned int len,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowmem(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	page,
-	u16	offset,
-	void	*data,
-	unsigned int	len,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_dowmem(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 page,
+	       u16 offset,
+	       void *data,
+	       unsigned int len,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
-static int
-hfa384x_isgood_pdrcode(u16 pdrcode);
+static int hfa384x_isgood_pdrcode(u16 pdrcode);
 
-/*================================================================*/
-/* Function Definitions */
-static inline const char* ctlxstr(CTLX_STATE s)
+static inline const char *ctlxstr(CTLX_STATE s)
 {
-	static const char* ctlx_str[] = {
+	static const char *ctlx_str[] = {
 		"Initial state",
 		"Complete",
 		"Request failed",
@@ -347,36 +294,36 @@ static inline const char* ctlxstr(CTLX_S
 	return ctlx_str[s];
 };
 
-
-static inline hfa384x_usbctlx_t*
-get_active_ctlx(hfa384x_t *hw)
+static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t *hw)
 {
 	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
 }
 
-
 #ifdef DEBUG_USB
-void
-dbprint_urb(struct urb* urb)
+void dbprint_urb(struct urb *urb)
 {
 	pr_debug("urb->pipe=0x%08x\n", urb->pipe);
 	pr_debug("urb->status=0x%08x\n", urb->status);
 	pr_debug("urb->transfer_flags=0x%08x\n", urb->transfer_flags);
-	pr_debug("urb->transfer_buffer=0x%08x\n", (unsigned int)urb->transfer_buffer);
-	pr_debug("urb->transfer_buffer_length=0x%08x\n", urb->transfer_buffer_length);
+	pr_debug("urb->transfer_buffer=0x%08x\n",
+	       (unsigned int)urb->transfer_buffer);
+	pr_debug("urb->transfer_buffer_length=0x%08x\n",
+	       urb->transfer_buffer_length);
 	pr_debug("urb->actual_length=0x%08x\n", urb->actual_length);
 	pr_debug("urb->bandwidth=0x%08x\n", urb->bandwidth);
-	pr_debug("urb->setup_packet(ctl)=0x%08x\n", (unsigned int)urb->setup_packet);
-	pr_debug("urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
+	pr_debug("urb->setup_packet(ctl)=0x%08x\n",
+	       (unsigned int)urb->setup_packet);
+	pr_debug("urb->start_frame(iso/irq)=0x%08x\n",
+	       urb->start_frame);
 	pr_debug("urb->interval(irq)=0x%08x\n", urb->interval);
 	pr_debug("urb->error_count(iso)=0x%08x\n", urb->error_count);
 	pr_debug("urb->timeout=0x%08x\n", urb->timeout);
 	pr_debug("urb->context=0x%08x\n", (unsigned int)urb->context);
-	pr_debug("urb->complete=0x%08x\n", (unsigned int)urb->complete);
+	pr_debug("urb->complete=0x%08x\n",
+	       (unsigned int)urb->complete);
 }
 #endif
 
-
 /*----------------------------------------------------------------
 * submit_rx_urb
 *
@@ -393,8 +340,7 @@ dbprint_urb(struct urb* urb)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int
-submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
+static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 {
 	struct sk_buff *skb;
 	int result;
@@ -407,21 +353,22 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memfl
 
 	/* Post the IN urb */
 	usb_fill_bulk_urb(&hw->rx_urb, hw->usb,
-	              hw->endp_in,
-	              skb->data, sizeof(hfa384x_usbin_t),
-	              hfa384x_usbin_callback, hw->wlandev);
+			  hw->endp_in,
+			  skb->data, sizeof(hfa384x_usbin_t),
+			  hfa384x_usbin_callback, hw->wlandev);
 
 	hw->rx_urb_skb = skb;
 
 	result = -ENOLINK;
-	if ( !hw->wlandev->hwremoved && !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
+	if (!hw->wlandev->hwremoved && !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
 		result = SUBMIT_URB(&hw->rx_urb, memflags);
 
 		/* Check whether we need to reset the RX pipe */
 		if (result == -EPIPE) {
-			printk(KERN_WARNING "%s rx pipe stalled: requesting reset\n",
-			                 hw->wlandev->netdev->name);
-			if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
+			printk(KERN_WARNING
+			       "%s rx pipe stalled: requesting reset\n",
+			       hw->wlandev->netdev->name);
+			if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
 				schedule_work(&hw->usb_work);
 		}
 	}
@@ -432,7 +379,7 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memfl
 		hw->rx_urb_skb = NULL;
 	}
 
- done:
+done:
 	return result;
 }
 
@@ -454,22 +401,23 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memfl
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int
-submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
+static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 {
 	struct net_device *netdev = hw->wlandev->netdev;
 	int result;
 
 	result = -ENOLINK;
-	if ( netif_running(netdev) ) {
+	if (netif_running(netdev)) {
 
-		if ( !hw->wlandev->hwremoved && !test_bit(WORK_TX_HALT, &hw->usb_flags) ) {
+		if (!hw->wlandev->hwremoved
+		    && !test_bit(WORK_TX_HALT, &hw->usb_flags)) {
 			result = SUBMIT_URB(tx_urb, memflags);
 
 			/* Test whether we need to reset the TX pipe */
 			if (result == -EPIPE) {
-				printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
-				                 netdev->name);
+				printk(KERN_WARNING
+				       "%s tx pipe stalled: requesting reset\n",
+				       netdev->name);
 				set_bit(WORK_TX_HALT, &hw->usb_flags);
 				schedule_work(&hw->usb_work);
 			} else if (result == 0) {
@@ -497,8 +445,7 @@ submit_tx_urb(hfa384x_t *hw, struct urb 
 * Call context:
 *	process (by design)
 ----------------------------------------------------------------*/
-static void
-hfa384x_usb_defer(struct work_struct *data)
+static void hfa384x_usb_defer(struct work_struct *data)
 {
 	hfa384x_t *hw = container_of(data, struct hfa384x, usb_work);
 	struct net_device *netdev = hw->wlandev->netdev;
@@ -506,15 +453,14 @@ hfa384x_usb_defer(struct work_struct *da
 	/* Don't bother trying to reset anything if the plug
 	 * has been pulled ...
 	 */
-	if ( hw->wlandev->hwremoved ) {
+	if (hw->wlandev->hwremoved)
 		return;
-	}
 
 	/* Reception has stopped: try to reset the input pipe */
 	if (test_bit(WORK_RX_HALT, &hw->usb_flags)) {
 		int ret;
 
-		usb_kill_urb(&hw->rx_urb);  /* Cannot be holding spinlock! */
+		usb_kill_urb(&hw->rx_urb);	/* Cannot be holding spinlock! */
 
 		ret = usb_clear_halt(hw->usb, hw->endp_in);
 		if (ret != 0) {
@@ -523,14 +469,14 @@ hfa384x_usb_defer(struct work_struct *da
 			       netdev->name, ret);
 		} else {
 			printk(KERN_INFO "%s rx pipe reset complete.\n",
-			                 netdev->name);
+			       netdev->name);
 			clear_bit(WORK_RX_HALT, &hw->usb_flags);
 			set_bit(WORK_RX_RESUME, &hw->usb_flags);
 		}
 	}
 
 	/* Resume receiving data back from the device. */
-	if ( test_bit(WORK_RX_RESUME, &hw->usb_flags) ) {
+	if (test_bit(WORK_RX_RESUME, &hw->usb_flags)) {
 		int ret;
 
 		ret = submit_rx_urb(hw, GFP_KERNEL);
@@ -554,7 +500,7 @@ hfa384x_usb_defer(struct work_struct *da
 			       netdev->name, ret);
 		} else {
 			printk(KERN_INFO "%s tx pipe reset complete.\n",
-			                 netdev->name);
+			       netdev->name);
 			clear_bit(WORK_TX_HALT, &hw->usb_flags);
 			set_bit(WORK_TX_RESUME, &hw->usb_flags);
 
@@ -567,12 +513,10 @@ hfa384x_usb_defer(struct work_struct *da
 	}
 
 	/* Resume transmitting. */
-	if ( test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags) ) {
+	if (test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags))
 		netif_wake_queue(hw->wlandev->netdev);
-	}
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_create
 *
@@ -594,8 +538,7 @@ hfa384x_usb_defer(struct work_struct *da
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void
-hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
+void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
 {
 	memset(hw, 0, sizeof(hfa384x_t));
 	hw->usb = usb;
@@ -618,11 +561,9 @@ hfa384x_create( hfa384x_t *hw, struct us
 	skb_queue_head_init(&hw->authq);
 
 	tasklet_init(&hw->reaper_bh,
-	             hfa384x_usbctlx_reaper_task,
-	             (unsigned long)hw);
+		     hfa384x_usbctlx_reaper_task, (unsigned long)hw);
 	tasklet_init(&hw->completion_bh,
-	             hfa384x_usbctlx_completion_task,
-	             (unsigned long)hw);
+		     hfa384x_usbctlx_completion_task, (unsigned long)hw);
 	INIT_WORK(&hw->link_bh, prism2sta_processing_defer);
 	INIT_WORK(&hw->usb_work, hfa384x_usb_defer);
 
@@ -645,13 +586,12 @@ hfa384x_create( hfa384x_t *hw, struct us
 	hw->link_status = HFA384x_LINK_NOTCONNECTED;
 	hw->state = HFA384x_STATE_INIT;
 
-        INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
+	INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
 	init_timer(&hw->commsqual_timer);
-	hw->commsqual_timer.data = (unsigned long) hw;
+	hw->commsqual_timer.data = (unsigned long)hw;
 	hw->commsqual_timer.function = prism2sta_commsqual_timer;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_destroy
 *
@@ -674,14 +614,12 @@ hfa384x_create( hfa384x_t *hw, struct us
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void
-hfa384x_destroy( hfa384x_t *hw)
+void hfa384x_destroy(hfa384x_t *hw)
 {
 	struct sk_buff *skb;
 
-	if ( hw->state == HFA384x_STATE_RUNNING ) {
+	if (hw->state == HFA384x_STATE_RUNNING)
 		hfa384x_drvr_stop(hw);
-	}
 	hw->state = HFA384x_STATE_PREINIT;
 
 	if (hw->scanresults) {
@@ -690,21 +628,16 @@ hfa384x_destroy( hfa384x_t *hw)
 	}
 
 	/* Now to clean out the auth queue */
-        while ( (skb = skb_dequeue(&hw->authq)) ) {
-                dev_kfree_skb(skb);
-        }
+	while ((skb = skb_dequeue(&hw->authq)))
+		dev_kfree_skb(skb);
 }
 
-
-/*----------------------------------------------------------------
- */
-static hfa384x_usbctlx_t* usbctlx_alloc(void)
+static hfa384x_usbctlx_t *usbctlx_alloc(void)
 {
 	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
-	if (ctlx != NULL)
-	{
+	if (ctlx != NULL) {
 		memset(ctlx, 0, sizeof(*ctlx));
 		init_completion(&ctlx->done);
 	}
@@ -712,13 +645,9 @@ static hfa384x_usbctlx_t* usbctlx_alloc(
 	return ctlx;
 }
 
-
-/*----------------------------------------------------------------
- *
-----------------------------------------------------------------*/
 static int
 usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
-                   hfa384x_cmdresult_t *result)
+		   hfa384x_cmdresult_t *result)
 {
 	result->status = hfa384x2host_16(cmdresp->status);
 	result->resp0 = hfa384x2host_16(cmdresp->resp0);
@@ -726,18 +655,15 @@ usbctlx_get_status(const hfa384x_usb_cmd
 	result->resp2 = hfa384x2host_16(cmdresp->resp2);
 
 	pr_debug("cmdresult:status=0x%04x "
-	                  "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
-	                result->status,
-	                result->resp0,
-	                result->resp1,
-	                result->resp2);
+	       "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
+	       result->status, result->resp0, result->resp1, result->resp2);
 
-	return (result->status & HFA384x_STATUS_RESULT);
+	return result->status & HFA384x_STATUS_RESULT;
 }
 
 static void
 usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
-                       hfa384x_rridresult_t *result)
+		       hfa384x_rridresult_t *result)
 {
 	result->rid = hfa384x2host_16(rridresp->rid);
 	result->riddata = rridresp->data;
@@ -745,31 +671,32 @@ usbctlx_get_rridresult(const hfa384x_usb
 
 }
 
-
 /*----------------------------------------------------------------
 * Completor object:
 * This completor must be passed to hfa384x_usbctlx_complete_sync()
 * when processing a CTLX that returns a hfa384x_cmdresult_t structure.
 ----------------------------------------------------------------*/
-struct usbctlx_cmd_completor
-{
-	usbctlx_completor_t	head;
+struct usbctlx_cmd_completor {
+	usbctlx_completor_t head;
 
-	const hfa384x_usb_cmdresp_t	*cmdresp;
-	hfa384x_cmdresult_t	*result;
+	const hfa384x_usb_cmdresp_t *cmdresp;
+	hfa384x_cmdresult_t *result;
 };
 typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
 
 static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
 {
-	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t*)head;
+	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t *) head;
 	return usbctlx_get_status(complete->cmdresp, complete->result);
 }
 
-static inline usbctlx_completor_t*
-init_cmd_completor(usbctlx_cmd_completor_t *completor,
-                   const hfa384x_usb_cmdresp_t *cmdresp,
-                   hfa384x_cmdresult_t *result)
+static inline usbctlx_completor_t *init_cmd_completor(usbctlx_cmd_completor_t *
+						      completor,
+						      const
+						      hfa384x_usb_cmdresp_t *
+						      cmdresp,
+						      hfa384x_cmdresult_t *
+						      result)
 {
 	completor->head.complete = usbctlx_cmd_completor_fn;
 	completor->cmdresp = cmdresp;
@@ -782,44 +709,41 @@ init_cmd_completor(usbctlx_cmd_completor
 * This completor must be passed to hfa384x_usbctlx_complete_sync()
 * when processing a CTLX that reads a RID.
 ----------------------------------------------------------------*/
-struct usbctlx_rrid_completor
-{
-	usbctlx_completor_t	head;
+struct usbctlx_rrid_completor {
+	usbctlx_completor_t head;
 
-	const hfa384x_usb_rridresp_t	*rridresp;
-	void			*riddata;
-	unsigned int			riddatalen;
+	const hfa384x_usb_rridresp_t *rridresp;
+	void *riddata;
+	unsigned int riddatalen;
 };
 typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
 
 static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
 {
-	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t*)head;
+	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t *) head;
 	hfa384x_rridresult_t rridresult;
 
 	usbctlx_get_rridresult(complete->rridresp, &rridresult);
 
 	/* Validate the length, note body len calculation in bytes */
-	if ( rridresult.riddata_len != complete->riddatalen ) {
+	if (rridresult.riddata_len != complete->riddatalen) {
 		printk(KERN_WARNING
-			"RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
-		        rridresult.rid,
-		        complete->riddatalen,
-		        rridresult.riddata_len);
+		       "RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
+		       rridresult.rid,
+		       complete->riddatalen, rridresult.riddata_len);
 		return -ENODATA;
 	}
 
-	memcpy(complete->riddata,
-	       rridresult.riddata,
-	       complete->riddatalen);
+	memcpy(complete->riddata, rridresult.riddata, complete->riddatalen);
 	return 0;
 }
 
-static inline usbctlx_completor_t*
-init_rrid_completor(usbctlx_rrid_completor_t *completor,
-                    const hfa384x_usb_rridresp_t *rridresp,
-                    void *riddata,
-                    unsigned int riddatalen)
+static inline usbctlx_completor_t *init_rrid_completor(usbctlx_rrid_completor_t
+						       *completor,
+						       const
+						       hfa384x_usb_rridresp_t *
+						       rridresp, void *riddata,
+						       unsigned int riddatalen)
 {
 	completor->head.complete = usbctlx_rrid_completor_fn;
 	completor->rridresp = rridresp;
@@ -846,30 +770,29 @@ typedef usbctlx_cmd_completor_t usbctlx_
 * Completor object:
 * Interprets the results of a synchronous memory-read
 ----------------------------------------------------------------*/
-struct usbctlx_rmem_completor
-{
-        usbctlx_completor_t           head;
+struct usbctlx_rmem_completor {
+	usbctlx_completor_t head;
 
-        const hfa384x_usb_rmemresp_t  *rmemresp;
-        void                          *data;
-        unsigned int                          len;
+	const hfa384x_usb_rmemresp_t *rmemresp;
+	void *data;
+	unsigned int len;
 };
 typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
 
 static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
 {
-	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t*)head;
+	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t *) head;
 
 	pr_debug("rmemresp:len=%d\n", complete->rmemresp->frmlen);
 	memcpy(complete->data, complete->rmemresp->data, complete->len);
 	return 0;
 }
 
-static inline usbctlx_completor_t*
-init_rmem_completor(usbctlx_rmem_completor_t *completor,
-                    hfa384x_usb_rmemresp_t *rmemresp,
-                    void *data,
-                    unsigned int len)
+static inline usbctlx_completor_t *init_rmem_completor(usbctlx_rmem_completor_t
+						       *completor,
+						       hfa384x_usb_rmemresp_t
+                                                       *rmemresp, void *data,
+						       unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
 	completor->rmemresp = rmemresp;
@@ -899,15 +822,15 @@ init_rmem_completor(usbctlx_rmem_complet
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
-	if ( ctlx->usercb != NULL ) {
+	if (ctlx->usercb != NULL) {
 		hfa384x_cmdresult_t cmdresult;
 
 		if (ctlx->state != CTLX_COMPLETE) {
 			memset(&cmdresult, 0, sizeof(cmdresult));
-			cmdresult.status = HFA384x_STATUS_RESULT_SET(HFA384x_CMD_ERR);
+			cmdresult.status =
+			    HFA384x_STATUS_RESULT_SET(HFA384x_CMD_ERR);
 		} else {
 			usbctlx_get_status(&ctlx->inbuf.cmdresp, &cmdresult);
 		}
@@ -916,7 +839,6 @@ hfa384x_cb_status(hfa384x_t *hw, const h
 	}
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_cb_rrid
 *
@@ -937,128 +859,114 @@ hfa384x_cb_status(hfa384x_t *hw, const h
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
-	if ( ctlx->usercb != NULL ) {
+	if (ctlx->usercb != NULL) {
 		hfa384x_rridresult_t rridresult;
 
 		if (ctlx->state != CTLX_COMPLETE) {
 			memset(&rridresult, 0, sizeof(rridresult));
-			rridresult.rid = hfa384x2host_16(ctlx->outbuf.rridreq.rid);
+			rridresult.rid =
+			    hfa384x2host_16(ctlx->outbuf.rridreq.rid);
 		} else {
-			usbctlx_get_rridresult(&ctlx->inbuf.rridresp, &rridresult);
+			usbctlx_get_rridresult(&ctlx->inbuf.rridresp,
+					       &rridresult);
 		}
 
 		ctlx->usercb(hw, &rridresult, ctlx->usercb_data);
 	}
 }
 
-static inline int
-hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+static inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_docmd_async(hfa384x_t *hw,
-                    hfa384x_metacmd_t *cmd,
-                    ctlx_cmdcb_t cmdcb,
-                    ctlx_usercb_t usercb,
-                    void *usercb_data)
+		    hfa384x_metacmd_t *cmd,
+		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	return hfa384x_docmd(hw, DOASYNC, cmd,
-	                        cmdcb, usercb, usercb_data);
+	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata, unsigned int riddatalen)
+hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+		    unsigned int riddatalen)
 {
 	return hfa384x_dorrid(hw, DOWAIT,
-	                      rid, riddata, riddatalen,
-	                      NULL, NULL, NULL);
+			      rid, riddata, riddatalen, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_dorrid_async(hfa384x_t *hw,
-                     u16 rid, void *riddata, unsigned int riddatalen,
-                     ctlx_cmdcb_t cmdcb,
-                     ctlx_usercb_t usercb,
-                     void *usercb_data)
+		     u16 rid, void *riddata, unsigned int riddatalen,
+		     ctlx_cmdcb_t cmdcb,
+		     ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dorrid(hw, DOASYNC,
-	                      rid, riddata, riddatalen,
-	                      cmdcb, usercb, usercb_data);
+			      rid, riddata, riddatalen,
+			      cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata, unsigned int riddatalen)
+hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+		    unsigned int riddatalen)
 {
 	return hfa384x_dowrid(hw, DOWAIT,
-	                      rid, riddata, riddatalen,
-	                      NULL, NULL, NULL);
+			      rid, riddata, riddatalen, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_dowrid_async(hfa384x_t *hw,
-                     u16 rid, void *riddata, unsigned int riddatalen,
-                     ctlx_cmdcb_t cmdcb,
-                     ctlx_usercb_t usercb,
-                     void *usercb_data)
+		     u16 rid, void *riddata, unsigned int riddatalen,
+		     ctlx_cmdcb_t cmdcb,
+		     ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dowrid(hw, DOASYNC,
-	                      rid, riddata, riddatalen,
-	                      cmdcb, usercb, usercb_data);
+			      rid, riddata, riddatalen,
+			      cmdcb, usercb, usercb_data);
 }
 
 static inline int
 hfa384x_dormem_wait(hfa384x_t *hw,
-                    u16 page, u16 offset, void *data, unsigned int len)
+		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dormem(hw, DOWAIT,
-	                      page, offset, data, len,
-	                      NULL, NULL, NULL);
+			      page, offset, data, len, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_dormem_async(hfa384x_t *hw,
-                     u16 page, u16 offset, void *data, unsigned int len,
-                     ctlx_cmdcb_t cmdcb,
-                     ctlx_usercb_t usercb,
-                     void *usercb_data)
+		     u16 page, u16 offset, void *data, unsigned int len,
+		     ctlx_cmdcb_t cmdcb,
+		     ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dormem(hw, DOASYNC,
-	                      page, offset, data, len,
-	                      cmdcb, usercb, usercb_data);
+			      page, offset, data, len,
+			      cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dowmem_wait(
-        hfa384x_t *hw,
-        u16  page,
-        u16  offset,
-        void    *data,
-        unsigned int    len)
+hfa384x_dowmem_wait(hfa384x_t *hw,
+		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dowmem(hw, DOWAIT,
-                                  page, offset, data, len,
-	                          NULL, NULL, NULL);
+			      page, offset, data, len, NULL, NULL, NULL);
 }
 
 static inline int
-hfa384x_dowmem_async(
-        hfa384x_t *hw,
-        u16  page,
-        u16  offset,
-        void    *data,
-        unsigned int    len,
-        ctlx_cmdcb_t cmdcb,
-        ctlx_usercb_t usercb,
-        void    *usercb_data)
+hfa384x_dowmem_async(hfa384x_t *hw,
+		     u16 page,
+		     u16 offset,
+		     void *data,
+		     unsigned int len,
+		     ctlx_cmdcb_t cmdcb,
+		     ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dowmem(hw, DOASYNC,
-                                  page, offset, data, len,
-	                          cmdcb, usercb, usercb_data);
+			      page, offset, data, len,
+			      cmdcb, usercb, usercb_data);
 }
 
 /*----------------------------------------------------------------
@@ -1080,11 +988,10 @@ hfa384x_dowmem_async(
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_cmd_initialize(hfa384x_t *hw)
+int hfa384x_cmd_initialize(hfa384x_t *hw)
 {
-	int	result = 0;
-	int	i;
+	int result = 0;
+	int i;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMDCODE_INIT;
@@ -1094,26 +1001,21 @@ hfa384x_cmd_initialize(hfa384x_t *hw)
 
 	result = hfa384x_docmd_wait(hw, &cmd);
 
-
 	pr_debug("cmdresp.init: "
-		"status=0x%04x, resp0=0x%04x, "
-		"resp1=0x%04x, resp2=0x%04x\n",
-		cmd.result.status,
-		cmd.result.resp0,
-		cmd.result.resp1,
-		cmd.result.resp2);
-	if ( result == 0 ) {
-		for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+	       "status=0x%04x, resp0=0x%04x, "
+	       "resp1=0x%04x, resp2=0x%04x\n",
+	       cmd.result.status,
+	       cmd.result.resp0, cmd.result.resp1, cmd.result.resp2);
+	if (result == 0) {
+		for (i = 0; i < HFA384x_NUMPORTS_MAX; i++)
 			hw->port_enabled[i] = 0;
-		}
 	}
 
-        hw->link_status = HFA384x_LINK_NOTCONNECTED;
+	hw->link_status = HFA384x_LINK_NOTCONNECTED;
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_cmd_disable
 *
@@ -1136,11 +1038,11 @@ hfa384x_cmd_initialize(hfa384x_t *hw)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 {
-	int	result = 0;
+	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |
-		  HFA384x_CMD_MACPORT_SET(macport);
+	    HFA384x_CMD_MACPORT_SET(macport);
 	cmd.parm0 = 0;
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
@@ -1150,7 +1052,6 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_cmd_enable
 *
@@ -1173,11 +1074,11 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u
 ----------------------------------------------------------------*/
 int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 {
-	int	result = 0;
+	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |
-		  HFA384x_CMD_MACPORT_SET(macport);
+	    HFA384x_CMD_MACPORT_SET(macport);
 	cmd.parm0 = 0;
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
@@ -1218,11 +1119,11 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u1
 ----------------------------------------------------------------*/
 int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 {
-	int	result = 0;
+	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |
-		HFA384x_CMD_AINFO_SET(enable);
+	    HFA384x_CMD_AINFO_SET(enable);
 	cmd.parm0 = 0;
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
@@ -1232,7 +1133,6 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_cmd_download
 *
@@ -1272,14 +1172,14 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u
 *	process
 ----------------------------------------------------------------*/
 int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
-				u16 highaddr, u16 codelen)
+			 u16 highaddr, u16 codelen)
 {
-	int	result = 0;
+	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	printk(KERN_DEBUG
-		"mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
-		mode, lowaddr, highaddr, codelen);
+	       "mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
+	       mode, lowaddr, highaddr, codelen);
 
 	cmd.cmd = (HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |
 		   HFA384x_CMD_PROGMODE_SET(mode));
@@ -1293,7 +1193,6 @@ int hfa384x_cmd_download(hfa384x_t *hw, 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_copy_from_aux
 *
@@ -1319,13 +1218,12 @@ int hfa384x_cmd_download(hfa384x_t *hw, 
 *	interrupt
 ----------------------------------------------------------------*/
 void
-hfa384x_copy_from_aux(
-	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
+hfa384x_copy_from_aux(hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf,
+		      unsigned int len)
 {
 	printk(KERN_ERR "not used in USB.\n");
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_copy_to_aux
 *
@@ -1351,13 +1249,12 @@ hfa384x_copy_from_aux(
 *	interrupt
 ----------------------------------------------------------------*/
 void
-hfa384x_copy_to_aux(
-	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
+hfa384x_copy_to_aux(hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf,
+		    unsigned int len)
 {
 	printk(KERN_ERR "not used in USB.\n");
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_corereset
 *
@@ -1383,17 +1280,17 @@ hfa384x_copy_to_aux(
 ----------------------------------------------------------------*/
 int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 {
-	int 			result = 0;
+	int result = 0;
 
-	result=usb_reset_device(hw->usb);
-	if(result<0) {
-		printk(KERN_ERR "usb_reset_device() failed, result=%d.\n",result);
+	result = usb_reset_device(hw->usb);
+	if (result < 0) {
+		printk(KERN_ERR "usb_reset_device() failed, result=%d.\n",
+		       result);
 	}
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbctlx_complete_sync
 *
@@ -1433,14 +1330,11 @@ static int hfa384x_usbctlx_complete_sync
 	 * We can only handle the CTLX if the USB disconnect
 	 * function has not run yet ...
 	 */
-	cleanup:
-	if ( hw->wlandev->hwremoved )
-	{
+cleanup:
+	if (hw->wlandev->hwremoved) {
 		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 		result = -ENODEV;
-	}
-	else if ( result != 0 )
-	{
+	} else if (result != 0) {
 		int runqueue = 0;
 
 		/*
@@ -1452,8 +1346,7 @@ static int hfa384x_usbctlx_complete_sync
 		 * NOTE: We can only delete the timers and
 		 *       the URB if this CTLX is active.
 		 */
-		if (ctlx == get_active_ctlx(hw))
-		{
+		if (ctlx == get_active_ctlx(hw)) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 
 			del_singleshot_timer_sync(&hw->reqtimer);
@@ -1470,7 +1363,7 @@ static int hfa384x_usbctlx_complete_sync
 			 * This scenario is so unlikely that I'm
 			 * happy with a grubby "goto" solution ...
 			 */
-			if ( hw->wlandev->hwremoved )
+			if (hw->wlandev->hwremoved)
 				goto cleanup;
 		}
 
@@ -1492,8 +1385,8 @@ static int hfa384x_usbctlx_complete_sync
 			result = completor->complete(completor);
 		} else {
 			printk(KERN_WARNING "CTLX[%d] error: state(%s)\n",
-			                 hfa384x2host_16(ctlx->outbuf.type),
-			                 ctlxstr(ctlx->state));
+			       hfa384x2host_16(ctlx->outbuf.type),
+			       ctlxstr(ctlx->state));
 			result = -EIO;
 		}
 
@@ -1538,38 +1431,32 @@ static int hfa384x_usbctlx_complete_sync
 *	process
 ----------------------------------------------------------------*/
 static int
-hfa384x_docmd(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	hfa384x_metacmd_t *cmd,
-	ctlx_cmdcb_t	cmdcb,
-	ctlx_usercb_t	usercb,
-	void	*usercb_data)
+hfa384x_docmd(hfa384x_t *hw,
+	      CMD_MODE mode,
+	      hfa384x_metacmd_t *cmd,
+	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.cmdreq.type = 	host2hfa384x_16(HFA384x_USB_CMDREQ);
-	ctlx->outbuf.cmdreq.cmd =	host2hfa384x_16(cmd->cmd);
-	ctlx->outbuf.cmdreq.parm0 =	host2hfa384x_16(cmd->parm0);
-	ctlx->outbuf.cmdreq.parm1 =	host2hfa384x_16(cmd->parm1);
-	ctlx->outbuf.cmdreq.parm2 =	host2hfa384x_16(cmd->parm2);
+	ctlx->outbuf.cmdreq.type = host2hfa384x_16(HFA384x_USB_CMDREQ);
+	ctlx->outbuf.cmdreq.cmd = host2hfa384x_16(cmd->cmd);
+	ctlx->outbuf.cmdreq.parm0 = host2hfa384x_16(cmd->parm0);
+	ctlx->outbuf.cmdreq.parm1 = host2hfa384x_16(cmd->parm1);
+	ctlx->outbuf.cmdreq.parm2 = host2hfa384x_16(cmd->parm2);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
 
 	pr_debug("cmdreq: cmd=0x%04x "
-		"parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
-		cmd->cmd,
-		cmd->parm0,
-		cmd->parm1,
-		cmd->parm2);
+	       "parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
+	       cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1582,17 +1469,20 @@ hfa384x_docmd(
 	} else if (mode == DOWAIT) {
 		usbctlx_cmd_completor_t completor;
 
-		result = hfa384x_usbctlx_complete_sync(
-		             hw, ctlx, init_cmd_completor(&completor,
-		                                          &ctlx->inbuf.cmdresp,
-		                                          &cmd->result) );
+		result =
+		    hfa384x_usbctlx_complete_sync(hw, ctlx,
+						  init_cmd_completor(&completor,
+								     &ctlx->
+								     inbuf.
+								     cmdresp,
+								     &cmd->
+								     result));
 	}
 
 done:
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_dorrid
 *
@@ -1630,30 +1520,27 @@ done:
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dorrid(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	rid,
-	void	*riddata,
-	unsigned int	riddatalen,
-        ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data)
+hfa384x_dorrid(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 rid,
+	       void *riddata,
+	       unsigned int riddatalen,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.rridreq.type =   host2hfa384x_16(HFA384x_USB_RRIDREQ);
+	ctlx->outbuf.rridreq.type = host2hfa384x_16(HFA384x_USB_RRIDREQ);
 	ctlx->outbuf.rridreq.frmlen =
-		host2hfa384x_16(sizeof(ctlx->outbuf.rridreq.rid));
-	ctlx->outbuf.rridreq.rid =    host2hfa384x_16(rid);
+	    host2hfa384x_16(sizeof(ctlx->outbuf.rridreq.rid));
+	ctlx->outbuf.rridreq.rid = host2hfa384x_16(rid);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rridreq);
 
@@ -1669,18 +1556,18 @@ hfa384x_dorrid(
 	} else if (mode == DOWAIT) {
 		usbctlx_rrid_completor_t completor;
 
-		result = hfa384x_usbctlx_complete_sync(
-		           hw, ctlx, init_rrid_completor(&completor,
-		                                         &ctlx->inbuf.rridresp,
-		                                         riddata,
-		                                         riddatalen) );
+		result =
+		    hfa384x_usbctlx_complete_sync(hw, ctlx,
+						  init_rrid_completor
+						  (&completor,
+						   &ctlx->inbuf.rridresp,
+						   riddata, riddatalen));
 	}
 
 done:
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_dowrid
 *
@@ -1714,37 +1601,34 @@ done:
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowrid(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	rid,
-	void	*riddata,
-	unsigned int	riddatalen,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data)
+hfa384x_dowrid(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 rid,
+	       void *riddata,
+	       unsigned int riddatalen,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.wridreq.type =   host2hfa384x_16(HFA384x_USB_WRIDREQ);
-	ctlx->outbuf.wridreq.frmlen = host2hfa384x_16(
-					(sizeof(ctlx->outbuf.wridreq.rid) +
-					riddatalen + 1) / 2);
-	ctlx->outbuf.wridreq.rid =    host2hfa384x_16(rid);
+	ctlx->outbuf.wridreq.type = host2hfa384x_16(HFA384x_USB_WRIDREQ);
+	ctlx->outbuf.wridreq.frmlen = host2hfa384x_16((sizeof
+						       (ctlx->outbuf.wridreq.
+							rid) + riddatalen +
+						       1) / 2);
+	ctlx->outbuf.wridreq.rid = host2hfa384x_16(rid);
 	memcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.wridreq.type) +
-	                   sizeof(ctlx->outbuf.wridreq.frmlen) +
-	                   sizeof(ctlx->outbuf.wridreq.rid) +
-	                   riddatalen;
+	    sizeof(ctlx->outbuf.wridreq.frmlen) +
+	    sizeof(ctlx->outbuf.wridreq.rid) + riddatalen;
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1759,12 +1643,12 @@ hfa384x_dowrid(
 		usbctlx_wrid_completor_t completor;
 		hfa384x_cmdresult_t wridresult;
 
-		result = hfa384x_usbctlx_complete_sync(
-		               hw,
-		               ctlx,
-		               init_wrid_completor(&completor,
-		                                   &ctlx->inbuf.wridresp,
-		                                   &wridresult) );
+		result = hfa384x_usbctlx_complete_sync(hw,
+						       ctlx,
+						       init_wrid_completor
+						       (&completor,
+							&ctlx->inbuf.wridresp,
+							&wridresult));
 	}
 
 done:
@@ -1805,46 +1689,41 @@ done:
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dormem(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	page,
-	u16	offset,
-	void	*data,
-	unsigned int	len,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data)
+hfa384x_dormem(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 page,
+	       u16 offset,
+	       void *data,
+	       unsigned int len,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.rmemreq.type =    host2hfa384x_16(HFA384x_USB_RMEMREQ);
-	ctlx->outbuf.rmemreq.frmlen =  host2hfa384x_16(
-					sizeof(ctlx->outbuf.rmemreq.offset) +
-					sizeof(ctlx->outbuf.rmemreq.page) +
-					len);
-	ctlx->outbuf.rmemreq.offset =	host2hfa384x_16(offset);
-	ctlx->outbuf.rmemreq.page =	host2hfa384x_16(page);
+	ctlx->outbuf.rmemreq.type = host2hfa384x_16(HFA384x_USB_RMEMREQ);
+	ctlx->outbuf.rmemreq.frmlen =
+	    host2hfa384x_16(sizeof(ctlx->outbuf.rmemreq.offset) +
+			    sizeof(ctlx->outbuf.rmemreq.page) + len);
+	ctlx->outbuf.rmemreq.offset = host2hfa384x_16(offset);
+	ctlx->outbuf.rmemreq.page = host2hfa384x_16(page);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
 
-	pr_debug(
-		"type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
-		ctlx->outbuf.rmemreq.type,
-		ctlx->outbuf.rmemreq.frmlen,
-		ctlx->outbuf.rmemreq.offset,
-		ctlx->outbuf.rmemreq.page);
+	printk(KERN_DEBUG
+	       "type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
+	       ctlx->outbuf.rmemreq.type,
+	       ctlx->outbuf.rmemreq.frmlen,
+	       ctlx->outbuf.rmemreq.offset, ctlx->outbuf.rmemreq.page);
 
 	pr_debug("pktsize=%zd\n",
-		ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
+	       ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1854,22 +1733,21 @@ hfa384x_dormem(
 	result = hfa384x_usbctlx_submit(hw, ctlx);
 	if (result != 0) {
 		kfree(ctlx);
-	} else if ( mode == DOWAIT ) {
-                usbctlx_rmem_completor_t completor;
+	} else if (mode == DOWAIT) {
+		usbctlx_rmem_completor_t completor;
 
-                result = hfa384x_usbctlx_complete_sync(
-                           hw, ctlx, init_rmem_completor(&completor,
-                                                         &ctlx->inbuf.rmemresp,
-                                                         data,
-                                                         len) );
+		result =
+		    hfa384x_usbctlx_complete_sync(hw, ctlx,
+						  init_rmem_completor
+						  (&completor,
+						   &ctlx->inbuf.rmemresp, data,
+						   len));
 	}
 
 done:
 	return result;
 }
 
-
-
 /*----------------------------------------------------------------
 * hfa384x_dowmem
 *
@@ -1904,44 +1782,39 @@ done:
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowmem(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	page,
-	u16	offset,
-	void	*data,
-	unsigned int	len,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data)
+hfa384x_dowmem(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 page,
+	       u16 offset,
+	       void *data,
+	       unsigned int len,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	pr_debug("page=0x%04x offset=0x%04x len=%d\n",
-		page,offset,len);
+	       page, offset, len);
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.wmemreq.type =   host2hfa384x_16(HFA384x_USB_WMEMREQ);
-	ctlx->outbuf.wmemreq.frmlen = host2hfa384x_16(
-					sizeof(ctlx->outbuf.wmemreq.offset) +
-					sizeof(ctlx->outbuf.wmemreq.page) +
-					len);
+	ctlx->outbuf.wmemreq.type = host2hfa384x_16(HFA384x_USB_WMEMREQ);
+	ctlx->outbuf.wmemreq.frmlen =
+	    host2hfa384x_16(sizeof(ctlx->outbuf.wmemreq.offset) +
+			    sizeof(ctlx->outbuf.wmemreq.page) + len);
 	ctlx->outbuf.wmemreq.offset = host2hfa384x_16(offset);
-	ctlx->outbuf.wmemreq.page =   host2hfa384x_16(page);
+	ctlx->outbuf.wmemreq.page = host2hfa384x_16(page);
 	memcpy(ctlx->outbuf.wmemreq.data, data, len);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.wmemreq.type) +
-	                   sizeof(ctlx->outbuf.wmemreq.frmlen) +
-	                   sizeof(ctlx->outbuf.wmemreq.offset) +
-	                   sizeof(ctlx->outbuf.wmemreq.page) +
-	                   len;
+	    sizeof(ctlx->outbuf.wmemreq.frmlen) +
+	    sizeof(ctlx->outbuf.wmemreq.offset) +
+	    sizeof(ctlx->outbuf.wmemreq.page) + len;
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1951,23 +1824,22 @@ hfa384x_dowmem(
 	result = hfa384x_usbctlx_submit(hw, ctlx);
 	if (result != 0) {
 		kfree(ctlx);
-	} else if ( mode == DOWAIT ) {
-                usbctlx_wmem_completor_t completor;
-                hfa384x_cmdresult_t wmemresult;
-
-                result = hfa384x_usbctlx_complete_sync(
-                               hw,
-                               ctlx,
-                               init_wmem_completor(&completor,
-                                                   &ctlx->inbuf.wmemresp,
-                                                   &wmemresult) );
+	} else if (mode == DOWAIT) {
+		usbctlx_wmem_completor_t completor;
+		hfa384x_cmdresult_t wmemresult;
+
+		result = hfa384x_usbctlx_complete_sync(hw,
+						       ctlx,
+						       init_wmem_completor
+						       (&completor,
+							&ctlx->inbuf.wmemresp,
+							&wmemresult));
 	}
 
 done:
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_commtallies
 *
@@ -1985,7 +1857,7 @@ done:
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_commtallies( hfa384x_t *hw )
+int hfa384x_drvr_commtallies(hfa384x_t *hw)
 {
 	hfa384x_metacmd_t cmd;
 
@@ -1999,7 +1871,6 @@ int hfa384x_drvr_commtallies( hfa384x_t 
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_disable
 *
@@ -2024,22 +1895,20 @@ int hfa384x_drvr_commtallies( hfa384x_t 
 ----------------------------------------------------------------*/
 int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 {
-	int	result = 0;
+	int result = 0;
 
 	if ((!hw->isap && macport != 0) ||
 	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
-	    !(hw->port_enabled[macport]) ){
+	    !(hw->port_enabled[macport])) {
 		result = -EINVAL;
 	} else {
 		result = hfa384x_cmd_disable(hw, macport);
-		if ( result == 0 ) {
+		if (result == 0)
 			hw->port_enabled[macport] = 0;
-		}
 	}
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_enable
 *
@@ -2064,22 +1933,20 @@ int hfa384x_drvr_disable(hfa384x_t *hw, 
 ----------------------------------------------------------------*/
 int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 {
-	int	result = 0;
+	int result = 0;
 
 	if ((!hw->isap && macport != 0) ||
 	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
-	    (hw->port_enabled[macport]) ){
+	    (hw->port_enabled[macport])) {
 		result = -EINVAL;
 	} else {
 		result = hfa384x_cmd_enable(hw, macport);
-		if ( result == 0 ) {
+		if (result == 0)
 			hw->port_enabled[macport] = 1;
-		}
 	}
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_flashdl_enable
 *
@@ -2103,32 +1970,32 @@ int hfa384x_drvr_enable(hfa384x_t *hw, u
 ----------------------------------------------------------------*/
 int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 {
-	int		result = 0;
-	int		i;
+	int result = 0;
+	int i;
 
 	/* Check that a port isn't active */
-	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
-		if ( hw->port_enabled[i] ) {
+	for (i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if (hw->port_enabled[i]) {
 			pr_debug("called when port enabled.\n");
 			return -EINVAL;
 		}
 	}
 
 	/* Check that we're not already in a download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_DISABLED)
 		return -EINVAL;
-	}
 
 	/* Retrieve the buffer loc&size and timeout */
-	if ( (result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
-				&(hw->bufinfo), sizeof(hw->bufinfo))) ) {
+	if ((result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
+					     &(hw->bufinfo),
+					     sizeof(hw->bufinfo)))) {
 		return result;
 	}
 	hw->bufinfo.page = hfa384x2host_16(hw->bufinfo.page);
 	hw->bufinfo.offset = hfa384x2host_16(hw->bufinfo.offset);
 	hw->bufinfo.len = hfa384x2host_16(hw->bufinfo.len);
-	if ( (result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
-				&(hw->dltimeout))) ) {
+	if ((result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
+					       &(hw->dltimeout)))) {
 		return result;
 	}
 	hw->dltimeout = hfa384x2host_16(hw->dltimeout);
@@ -2140,7 +2007,6 @@ int hfa384x_drvr_flashdl_enable(hfa384x_
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_flashdl_disable
 *
@@ -2163,21 +2029,19 @@ int hfa384x_drvr_flashdl_enable(hfa384x_
 int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 {
 	/* Check that we're already in the download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
 		return -EINVAL;
-	}
 
 	pr_debug("flashdl_enable\n");
 
 	/* There isn't much we can do at this point, so I don't */
 	/*  bother  w/ the return value */
-	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0, 0);
 	hw->dlstate = HFA384x_DLSTATE_DISABLED;
 
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_flashdl_write
 *
@@ -2207,47 +2071,42 @@ int hfa384x_drvr_flashdl_disable(hfa384x
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_flashdl_write(
-	hfa384x_t	*hw,
-	u32		daddr,
-	void		*buf,
-	u32		len)
-{
-	int		result = 0;
-	u32		dlbufaddr;
-	int		nburns;
-	u32		burnlen;
-	u32		burndaddr;
-	u16		burnlo;
-	u16		burnhi;
-	int		nwrites;
-	u8		*writebuf;
-	u16		writepage;
-	u16		writeoffset;
-	u32		writelen;
-	int		i;
-	int		j;
+int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
+{
+	int result = 0;
+	u32 dlbufaddr;
+	int nburns;
+	u32 burnlen;
+	u32 burndaddr;
+	u16 burnlo;
+	u16 burnhi;
+	int nwrites;
+	u8 *writebuf;
+	u16 writepage;
+	u16 writeoffset;
+	u32 writelen;
+	int i;
+	int j;
 
 	pr_debug("daddr=0x%08x len=%d\n", daddr, len);
 
 	/* Check that we're in the flash download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
 		return -EINVAL;
-	}
 
 	printk(KERN_INFO "Download %d bytes to flash @0x%06x\n", len, daddr);
 
 	/* Convert to flat address for arithmetic */
 	/* NOTE: dlbuffer RID stores the address in AUX format */
-	dlbufaddr = HFA384x_ADDR_AUX_MKFLAT(
-			hw->bufinfo.page, hw->bufinfo.offset);
-	pr_debug(
-		"dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
-		hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
+	dlbufaddr =
+	    HFA384x_ADDR_AUX_MKFLAT(hw->bufinfo.page, hw->bufinfo.offset);
+	printk(KERN_DEBUG
+	       "dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
+	       hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
 #if 0
-printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw->dltimeout);
+	printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
+	       hw->bufinfo.len, hw->dltimeout);
 #endif
 	/* Calculations to determine how many fills of the dlbuffer to do
 	 * and how many USB wmemreq's to do for each fill.  At this point
@@ -2265,62 +2124,60 @@ printk(KERN_WARNING "dlbuf@0x%06lx len=%
 	nwrites += (hw->bufinfo.len % HFA384x_USB_RWMEM_MAXLEN) ? 1 : 0;
 
 	/* For each burn */
-	for ( i = 0; i < nburns; i++) {
+	for (i = 0; i < nburns; i++) {
 		/* Get the dest address and len */
 		burnlen = (len - (hw->bufinfo.len * i)) > hw->bufinfo.len ?
-				hw->bufinfo.len :
-				(len - (hw->bufinfo.len * i));
+		    hw->bufinfo.len : (len - (hw->bufinfo.len * i));
 		burndaddr = daddr + (hw->bufinfo.len * i);
 		burnlo = HFA384x_ADDR_CMD_MKOFF(burndaddr);
 		burnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);
 
 		printk(KERN_INFO "Writing %d bytes to flash @0x%06x\n",
-			burnlen, burndaddr);
+		       burnlen, burndaddr);
 
 		/* Set the download mode */
 		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,
-				burnlo, burnhi, burnlen);
-		if ( result ) {
+					      burnlo, burnhi, burnlen);
+		if (result) {
 			printk(KERN_ERR "download(NV,lo=%x,hi=%x,len=%x) "
-				"cmd failed, result=%d. Aborting d/l\n",
-				burnlo, burnhi, burnlen, result);
+			       "cmd failed, result=%d. Aborting d/l\n",
+			       burnlo, burnhi, burnlen, result);
 			goto exit_proc;
 		}
 
 		/* copy the data to the flash download buffer */
-		for ( j=0; j < nwrites; j++) {
+		for (j = 0; j < nwrites; j++) {
 			writebuf = buf +
-				(i*hw->bufinfo.len) +
-				(j*HFA384x_USB_RWMEM_MAXLEN);
+			    (i * hw->bufinfo.len) +
+			    (j * HFA384x_USB_RWMEM_MAXLEN);
 
-			writepage = HFA384x_ADDR_CMD_MKPAGE(
-					dlbufaddr +
-					(j*HFA384x_USB_RWMEM_MAXLEN));
-			writeoffset = HFA384x_ADDR_CMD_MKOFF(
-					dlbufaddr +
-					(j*HFA384x_USB_RWMEM_MAXLEN));
-
-			writelen = burnlen-(j*HFA384x_USB_RWMEM_MAXLEN);
-			writelen = writelen  > HFA384x_USB_RWMEM_MAXLEN ?
-					HFA384x_USB_RWMEM_MAXLEN :
-					writelen;
-
-			result = hfa384x_dowmem_wait( hw,
-					writepage,
-					writeoffset,
-					writebuf,
-					writelen );
+			writepage = HFA384x_ADDR_CMD_MKPAGE(dlbufaddr +
+							    (j *
+							     HFA384x_USB_RWMEM_MAXLEN));
+			writeoffset =
+			    HFA384x_ADDR_CMD_MKOFF(dlbufaddr +
+						   (j *
+						    HFA384x_USB_RWMEM_MAXLEN));
+
+			writelen = burnlen - (j * HFA384x_USB_RWMEM_MAXLEN);
+			writelen = writelen > HFA384x_USB_RWMEM_MAXLEN ?
+			    HFA384x_USB_RWMEM_MAXLEN : writelen;
+
+			result = hfa384x_dowmem_wait(hw,
+						     writepage,
+						     writeoffset,
+						     writebuf, writelen);
 		}
 
 		/* set the download 'write flash' mode */
 		result = hfa384x_cmd_download(hw,
-				HFA384x_PROGMODE_NVWRITE,
-				0,0,0);
-		if ( result ) {
+					      HFA384x_PROGMODE_NVWRITE,
+					      0, 0, 0);
+		if (result) {
 			printk(KERN_ERR
-				"download(NVWRITE,lo=%x,hi=%x,len=%x) "
-				"cmd failed, result=%d. Aborting d/l\n",
-				burnlo, burnhi, burnlen, result);
+			       "download(NVWRITE,lo=%x,hi=%x,len=%x) "
+			       "cmd failed, result=%d. Aborting d/l\n",
+			       burnlo, burnhi, burnlen, result);
 			goto exit_proc;
 		}
 
@@ -2336,7 +2193,6 @@ exit_proc:
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_getconfig
 *
@@ -2364,7 +2220,7 @@ exit_proc:
 ----------------------------------------------------------------*/
 int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 {
-	int 			result;
+	int result;
 
 	result = hfa384x_dorrid_wait(hw, rid, buf, len);
 
@@ -2399,14 +2255,11 @@ int hfa384x_drvr_getconfig(hfa384x_t *hw
  *       Any
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_getconfig_async(
-         hfa384x_t               *hw,
-         u16                  rid,
-         ctlx_usercb_t           usercb,
-         void                    *usercb_data)
+hfa384x_drvr_getconfig_async(hfa384x_t *hw,
+			     u16 rid, ctlx_usercb_t usercb, void *usercb_data)
 {
-         return hfa384x_dorrid_async(hw, rid, NULL, 0,
-				     hfa384x_cb_rrid, usercb, usercb_data);
+	return hfa384x_dorrid_async(hw, rid, NULL, 0,
+				    hfa384x_cb_rrid, usercb, usercb_data);
 }
 
 /*----------------------------------------------------------------
@@ -2433,13 +2286,10 @@ hfa384x_drvr_getconfig_async(
  *       process
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_setconfig_async(
-         hfa384x_t       *hw,
-         u16          rid,
-         void            *buf,
-         u16          len,
-         ctlx_usercb_t   usercb,
-         void            *usercb_data)
+hfa384x_drvr_setconfig_async(hfa384x_t *hw,
+			     u16 rid,
+			     void *buf,
+			     u16 len, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dowrid_async(hw, rid, buf, len,
 				    hfa384x_cb_status, usercb, usercb_data);
@@ -2464,7 +2314,7 @@ hfa384x_drvr_setconfig_async(
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_handover( hfa384x_t *hw, u8 *addr)
+int hfa384x_drvr_handover(hfa384x_t *hw, u8 *addr)
 {
 	printk(KERN_ERR "Not currently supported in USB!\n");
 	return -EIO;
@@ -2488,25 +2338,22 @@ int hfa384x_drvr_handover( hfa384x_t *hw
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
+int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 {
 	/* Check that we're already in the download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
 		return -EINVAL;
-	}
 
 	pr_debug("ramdl_disable()\n");
 
 	/* There isn't much we can do at this point, so I don't */
 	/*  bother  w/ the return value */
-	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0, 0);
 	hw->dlstate = HFA384x_DLSTATE_DISABLED;
 
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_ramdl_enable
 *
@@ -2531,27 +2378,25 @@ hfa384x_drvr_ramdl_disable(hfa384x_t *hw
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
+int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 {
-	int		result = 0;
-	u16		lowaddr;
-	u16		hiaddr;
-	int		i;
+	int result = 0;
+	u16 lowaddr;
+	u16 hiaddr;
+	int i;
 
 	/* Check that a port isn't active */
-	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
-		if ( hw->port_enabled[i] ) {
+	for (i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if (hw->port_enabled[i]) {
 			printk(KERN_ERR
-				"Can't download with a macport enabled.\n");
+			       "Can't download with a macport enabled.\n");
 			return -EINVAL;
 		}
 	}
 
 	/* Check that we're not already in a download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
-		printk(KERN_ERR
-			"Download state not disabled.\n");
+	if (hw->dlstate != HFA384x_DLSTATE_DISABLED) {
+		printk(KERN_ERR "Download state not disabled.\n");
 		return -EINVAL;
 	}
 
@@ -2559,26 +2404,23 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw,
 
 	/* Call the download(1,addr) function */
 	lowaddr = HFA384x_ADDR_CMD_MKOFF(exeaddr);
-	hiaddr =  HFA384x_ADDR_CMD_MKPAGE(exeaddr);
+	hiaddr = HFA384x_ADDR_CMD_MKPAGE(exeaddr);
 
 	result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_RAM,
-			lowaddr, hiaddr, 0);
+				      lowaddr, hiaddr, 0);
 
-	if ( result == 0) {
+	if (result == 0) {
 		/* Set the download state */
 		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
 	} else {
-		pr_debug(
-			"cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
-			lowaddr,
-			hiaddr,
-			result);
+		printk(KERN_DEBUG
+		       "cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
+		       lowaddr, hiaddr, result);
 	}
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_ramdl_write
 *
@@ -2605,22 +2447,20 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
+int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 {
-	int		result = 0;
-	int		nwrites;
-	u8		*data = buf;
-	int		i;
-	u32		curraddr;
-	u16		currpage;
-	u16		curroffset;
-	u16		currlen;
+	int result = 0;
+	int nwrites;
+	u8 *data = buf;
+	int i;
+	u32 curraddr;
+	u16 currpage;
+	u16 curroffset;
+	u16 currlen;
 
 	/* Check that we're in the ram download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
 		return -EINVAL;
-	}
 
 	printk(KERN_INFO "Writing %d bytes to ram @0x%06x\n", len, daddr);
 
@@ -2629,24 +2469,25 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, 
 	nwrites += len % HFA384x_USB_RWMEM_MAXLEN ? 1 : 0;
 
 	/* Do blocking wmem's */
-	for(i=0; i < nwrites; i++) {
+	for (i = 0; i < nwrites; i++) {
 		/* make address args */
 		curraddr = daddr + (i * HFA384x_USB_RWMEM_MAXLEN);
 		currpage = HFA384x_ADDR_CMD_MKPAGE(curraddr);
 		curroffset = HFA384x_ADDR_CMD_MKOFF(curraddr);
 		currlen = len - (i * HFA384x_USB_RWMEM_MAXLEN);
-		if ( currlen > HFA384x_USB_RWMEM_MAXLEN) {
+		if (currlen > HFA384x_USB_RWMEM_MAXLEN)
 			currlen = HFA384x_USB_RWMEM_MAXLEN;
-		}
 
-	 	/* Do blocking ctlx */
-		result = hfa384x_dowmem_wait( hw,
-				currpage,
-				curroffset,
-				data + (i*HFA384x_USB_RWMEM_MAXLEN),
-				currlen );
+		/* Do blocking ctlx */
+		result = hfa384x_dowmem_wait(hw,
+					     currpage,
+					     curroffset,
+					     data +
+					     (i * HFA384x_USB_RWMEM_MAXLEN),
+					     currlen);
 
-		if (result) break;
+		if (result)
+			break;
 
 		/* TODO: We really should have a readback. */
 	}
@@ -2654,7 +2495,6 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_readpda
 *
@@ -2688,98 +2528,89 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, 
 ----------------------------------------------------------------*/
 int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 {
-	int		result = 0;
-	u16		*pda = buf;
-	int		pdaok = 0;
-	int		morepdrs = 1;
-	int		currpdr = 0;	/* word offset of the current pdr */
-	size_t		i;
-	u16		pdrlen;		/* pdr length in bytes, host order */
-	u16		pdrcode;	/* pdr code, host order */
-	u16		currpage;
-	u16		curroffset;
+	int result = 0;
+	u16 *pda = buf;
+	int pdaok = 0;
+	int morepdrs = 1;
+	int currpdr = 0;	/* word offset of the current pdr */
+	size_t i;
+	u16 pdrlen;		/* pdr length in bytes, host order */
+	u16 pdrcode;		/* pdr code, host order */
+	u16 currpage;
+	u16 curroffset;
 	struct pdaloc {
-		u32	cardaddr;
-		u16	auxctl;
-	} pdaloc[] =
-	{
-		{ HFA3842_PDA_BASE,		0},
-		{ HFA3841_PDA_BASE,		0},
-		{ HFA3841_PDA_BOGUS_BASE,	0}
+		u32 cardaddr;
+		u16 auxctl;
+	} pdaloc[] = {
+		{
+		HFA3842_PDA_BASE, 0}, {
+		HFA3841_PDA_BASE, 0}, {
+		HFA3841_PDA_BOGUS_BASE, 0}
 	};
 
 	/* Read the pda from each known address.  */
-	for ( i = 0; i < ARRAY_SIZE(pdaloc); i++) {
+	for (i = 0; i < ARRAY_SIZE(pdaloc); i++) {
 		/* Make address */
 		currpage = HFA384x_ADDR_CMD_MKPAGE(pdaloc[i].cardaddr);
 		curroffset = HFA384x_ADDR_CMD_MKOFF(pdaloc[i].cardaddr);
 
-		result = hfa384x_dormem_wait(hw,
-			currpage,
-			curroffset,
-			buf,
-			len);		/* units of bytes */
+		result = hfa384x_dormem_wait(hw, currpage, curroffset, buf, len);	/* units of bytes */
 
 		if (result) {
 			printk(KERN_WARNING
-					  "Read from index %zd failed, continuing\n",
-				i );
+			       "Read from index %zd failed, continuing\n", i);
 			continue;
 		}
 
 		/* Test for garbage */
 		pdaok = 1;	/* initially assume good */
 		morepdrs = 1;
-		while ( pdaok && morepdrs ) {
+		while (pdaok && morepdrs) {
 			pdrlen = hfa384x2host_16(pda[currpdr]) * 2;
-			pdrcode = hfa384x2host_16(pda[currpdr+1]);
+			pdrcode = hfa384x2host_16(pda[currpdr + 1]);
 			/* Test the record length */
-			if ( pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
-				printk(KERN_ERR "pdrlen invalid=%d\n",
-					pdrlen);
+			if (pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
+				printk(KERN_ERR "pdrlen invalid=%d\n", pdrlen);
 				pdaok = 0;
 				break;
 			}
 			/* Test the code */
-			if ( !hfa384x_isgood_pdrcode(pdrcode) ) {
+			if (!hfa384x_isgood_pdrcode(pdrcode)) {
 				printk(KERN_ERR "pdrcode invalid=%d\n",
-					pdrcode);
+				       pdrcode);
 				pdaok = 0;
 				break;
 			}
 			/* Test for completion */
-			if ( pdrcode == HFA384x_PDR_END_OF_PDA) {
+			if (pdrcode == HFA384x_PDR_END_OF_PDA)
 				morepdrs = 0;
-			}
 
 			/* Move to the next pdr (if necessary) */
-			if ( morepdrs ) {
+			if (morepdrs) {
 				/* note the access to pda[], need words here */
 				currpdr += hfa384x2host_16(pda[currpdr]) + 1;
 			}
 		}
-		if ( pdaok ) {
+		if (pdaok) {
 			printk(KERN_INFO
-				"PDA Read from 0x%08x in %s space.\n",
-				pdaloc[i].cardaddr,
-				pdaloc[i].auxctl == 0 ? "EXTDS" :
-				pdaloc[i].auxctl == 1 ? "NV" :
-				pdaloc[i].auxctl == 2 ? "PHY" :
-				pdaloc[i].auxctl == 3 ? "ICSRAM" :
-				"<bogus auxctl>");
+			       "PDA Read from 0x%08x in %s space.\n",
+			       pdaloc[i].cardaddr,
+			       pdaloc[i].auxctl == 0 ? "EXTDS" :
+			       pdaloc[i].auxctl == 1 ? "NV" :
+			       pdaloc[i].auxctl == 2 ? "PHY" :
+			       pdaloc[i].auxctl == 3 ? "ICSRAM" :
+			       "<bogus auxctl>");
 			break;
 		}
 	}
 	result = pdaok ? 0 : -ENODATA;
 
-	if ( result ) {
+	if (result)
 		pr_debug("Failure: pda is not okay\n");
-	}
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_setconfig
 *
@@ -2828,8 +2659,8 @@ int hfa384x_drvr_setconfig(hfa384x_t *hw
 
 int hfa384x_drvr_start(hfa384x_t *hw)
 {
-	int		result, result1, result2;
-	u16		status;
+	int result, result1, result2;
+	u16 status;
 
 	might_sleep();
 
@@ -2838,27 +2669,23 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	 * badly if a clear_halt is called when the endpoint is already
 	 * ok
 	 */
-	result = usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
+	result =
+	    usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
 	if (result < 0) {
-		printk(KERN_ERR
-			"Cannot get bulk in endpoint status.\n");
+		printk(KERN_ERR "Cannot get bulk in endpoint status.\n");
 		goto done;
 	}
-	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in)) {
-		printk(KERN_ERR
-			"Failed to reset bulk in endpoint.\n");
-	}
+	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in))
+		printk(KERN_ERR "Failed to reset bulk in endpoint.\n");
 
-	result = usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
+	result =
+	    usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
 	if (result < 0) {
-		printk(KERN_ERR
-			"Cannot get bulk out endpoint status.\n");
+		printk(KERN_ERR "Cannot get bulk out endpoint status.\n");
 		goto done;
 	}
-	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out)) {
-		printk(KERN_ERR
-			"Failed to reset bulk out endpoint.\n");
-	}
+	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out))
+		printk(KERN_ERR "Failed to reset bulk out endpoint.\n");
 
 	/* Synchronous unlink, in case we're trying to restart the driver */
 	usb_kill_urb(&hw->rx_urb);
@@ -2867,8 +2694,7 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	result = submit_rx_urb(hw, GFP_KERNEL);
 	if (result != 0) {
 		printk(KERN_ERR
-			"Fatal, failed to submit RX URB, result=%d\n",
-			result);
+		       "Fatal, failed to submit RX URB, result=%d\n", result);
 		goto done;
 	}
 
@@ -2888,21 +2714,24 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	if (result1 != 0) {
 		if (result2 != 0) {
 			printk(KERN_ERR
-				"cmd_initialize() failed on two attempts, results %d and %d\n",
-				result1, result2);
+			       "cmd_initialize() failed on two attempts, results %d and %d\n",
+			       result1, result2);
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
-			pr_debug("First cmd_initialize() failed (result %d),\n",
-				result1);
-			pr_debug("but second attempt succeeded. All should be ok\n");
+			printk(KERN_DEBUG
+			       "First cmd_initialize() failed (result %d),\n",
+			       result1);
+			printk(KERN_DEBUG
+			       "but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
 		printk(KERN_WARNING
-			"First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
-			result2);
-		printk(KERN_WARNING "Most likely the card will be functional\n");
-			goto done;
+		       "First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
+		       result2);
+		printk(KERN_WARNING
+		       "Most likely the card will be functional\n");
+		goto done;
 	}
 
 	hw->state = HFA384x_STATE_RUNNING;
@@ -2911,7 +2740,6 @@ done:
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_stop
 *
@@ -2931,18 +2759,17 @@ done:
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_stop(hfa384x_t *hw)
+int hfa384x_drvr_stop(hfa384x_t *hw)
 {
-	int	result = 0;
-	int	i;
+	int result = 0;
+	int i;
 
 	might_sleep();
 
 	/* There's no need for spinlocks here. The USB "disconnect"
 	 * function sets this "removed" flag and then calls us.
 	 */
-	if ( !hw->wlandev->hwremoved ) {
+	if (!hw->wlandev->hwremoved) {
 		/* Call initialize to leave the MAC in its 'reset' state */
 		hfa384x_cmd_initialize(hw);
 
@@ -2956,9 +2783,8 @@ hfa384x_drvr_stop(hfa384x_t *hw)
 	del_timer_sync(&hw->commsqual_timer);
 
 	/* Clear all the port status */
-	for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+	for (i = 0; i < HFA384x_NUMPORTS_MAX; i++)
 		hw->port_enabled[i] = 0;
-	}
 
 	return result;
 }
@@ -2984,13 +2810,14 @@ hfa384x_drvr_stop(hfa384x_t *hw)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
-
+int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
+			 p80211_hdr_t *p80211_hdr,
+			 p80211_metawep_t *p80211_wep)
 {
-	int		usbpktlen = sizeof(hfa384x_tx_frame_t);
-	int		result;
-	int		ret;
-	char		*ptr;
+	int usbpktlen = sizeof(hfa384x_tx_frame_t);
+	int result;
+	int ret;
+	char *ptr;
 
 	if (hw->tx_urb.status == -EINPROGRESS) {
 		printk(KERN_WARNING "TX URB already in use\n");
@@ -3011,30 +2838,31 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, 
 /* Tx complete and Tx exception disable per dleach.  Might be causing
  * buf depletion
  */
-//#define DOEXC  SLP -- doboth breaks horribly under load, doexc less so.
+/* #define DOEXC  SLP -- doboth breaks horribly under load, doexc less so. */
 #if defined(DOBOTH)
 	hw->txbuff.txfrm.desc.tx_control =
-		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
-		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);
+	    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+	    HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);
 #elif defined(DOEXC)
 	hw->txbuff.txfrm.desc.tx_control =
-		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
-		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);
+	    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+	    HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);
 #else
 	hw->txbuff.txfrm.desc.tx_control =
-		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
-		HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);
+	    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+	    HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);
 #endif
 	hw->txbuff.txfrm.desc.tx_control =
-		host2hfa384x_16(hw->txbuff.txfrm.desc.tx_control);
+	    host2hfa384x_16(hw->txbuff.txfrm.desc.tx_control);
 
 	/* copy the header over to the txdesc */
-	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr, sizeof(p80211_hdr_t));
+	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr,
+	       sizeof(p80211_hdr_t));
 
 	/* if we're using host WEP, increase size by IV+ICV */
 	if (p80211_wep->data) {
-		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len+8);
-		usbpktlen+=8;
+		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len + 8);
+		usbpktlen += 8;
 	} else {
 		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len);
 	}
@@ -3045,50 +2873,47 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, 
 	ptr = hw->txbuff.txfrm.data;
 	if (p80211_wep->data) {
 		memcpy(ptr, p80211_wep->iv, sizeof(p80211_wep->iv));
-		ptr+= sizeof(p80211_wep->iv);
+		ptr += sizeof(p80211_wep->iv);
 		memcpy(ptr, p80211_wep->data, skb->len);
 	} else {
 		memcpy(ptr, skb->data, skb->len);
 	}
 	/* copy over the packet data */
-	ptr+= skb->len;
+	ptr += skb->len;
 
 	/* copy over the WEP ICV if we are using host WEP */
-	if (p80211_wep->data) {
+	if (p80211_wep->data)
 		memcpy(ptr, p80211_wep->icv, sizeof(p80211_wep->icv));
-	}
 
 	/* Send the USB packet */
-	usb_fill_bulk_urb( &(hw->tx_urb), hw->usb,
-	               hw->endp_out,
-	               &(hw->txbuff), ROUNDUP64(usbpktlen),
-	               hfa384x_usbout_callback, hw->wlandev );
+	usb_fill_bulk_urb(&(hw->tx_urb), hw->usb,
+			  hw->endp_out,
+			  &(hw->txbuff), ROUNDUP64(usbpktlen),
+			  hfa384x_usbout_callback, hw->wlandev);
 	hw->tx_urb.transfer_flags |= USB_QUEUE_BULK;
 
 	result = 1;
 	ret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);
-	if ( ret != 0 ) {
-		printk(KERN_ERR
-			"submit_tx_urb() failed, error=%d\n", ret);
+	if (ret != 0) {
+		printk(KERN_ERR "submit_tx_urb() failed, error=%d\n", ret);
 		result = 3;
 	}
 
- exit:
+exit:
 	return result;
 }
 
 void hfa384x_tx_timeout(wlandevice_t *wlandev)
 {
-	hfa384x_t	*hw = wlandev->priv;
+	hfa384x_t *hw = wlandev->priv;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
-	if ( !hw->wlandev->hwremoved &&
-	     /* Note the bitwise OR, not the logical OR. */
-	     ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) |
-	       !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) ) )
-	{
+	if (!hw->wlandev->hwremoved &&
+	    /* Note the bitwise OR, not the logical OR. */
+	    (!test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) |
+	     !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))) {
 		schedule_work(&hw->usb_work);
 	}
 
@@ -3110,10 +2935,10 @@ void hfa384x_tx_timeout(wlandevice_t *wl
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_reaper_task(unsigned long data)
 {
-	hfa384x_t	*hw = (hfa384x_t*)data;
+	hfa384x_t *hw = (hfa384x_t *) data;
 	struct list_head *entry;
 	struct list_head *temp;
-	unsigned long	flags;
+	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -3121,7 +2946,7 @@ static void hfa384x_usbctlx_reaper_task(
 	 * has unplugged the adapter.
 	 */
 	list_for_each_safe(entry, temp, &hw->ctlxq.reapable) {
-		hfa384x_usbctlx_t	*ctlx;
+		hfa384x_usbctlx_t *ctlx;
 
 		ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
 		list_del(&ctlx->list);
@@ -3148,7 +2973,7 @@ static void hfa384x_usbctlx_reaper_task(
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_completion_task(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t*)data;
+	hfa384x_t *hw = (hfa384x_t *) data;
 	struct list_head *entry;
 	struct list_head *temp;
 	unsigned long flags;
@@ -3168,7 +2993,7 @@ static void hfa384x_usbctlx_completion_t
 		/* Call the completion function that this
 		 * command was assigned, assuming it has one.
 		 */
-		if ( ctlx->cmdcb != NULL ) {
+		if (ctlx->cmdcb != NULL) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			ctlx->cmdcb(hw, ctlx);
 			spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3181,8 +3006,7 @@ static void hfa384x_usbctlx_completion_t
 			/* Did someone yank the adapter out
 			 * while our list was (briefly) unlocked?
 			 */
-			if ( hw->wlandev->hwremoved )
-			{
+			if (hw->wlandev->hwremoved) {
 				reap = 0;
 				break;
 			}
@@ -3193,7 +3017,7 @@ static void hfa384x_usbctlx_completion_t
 		 * threads waiting for them to die. Hence they must
 		 * be delivered to The Reaper!
 		 */
-		if ( ctlx->reapable ) {
+		if (ctlx->reapable) {
 			/* Move the CTLX off the "completing" list (hopefully)
 			 * on to the "reapable" list where the reaper task
 			 * can find it. And "reapable" means that this CTLX
@@ -3228,7 +3052,8 @@ static void hfa384x_usbctlx_completion_t
 * Call context:
 *	Either process or interrupt, but presumably interrupt
 ----------------------------------------------------------------*/
-static int unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
+					 hfa384x_usbctlx_t *ctlx)
 {
 	int ret;
 
@@ -3294,10 +3119,10 @@ static void unlocked_usbctlx_complete(hf
 
 	default:
 		printk(KERN_ERR "CTLX[%d] not in a terminating state(%s)\n",
-		               hfa384x2host_16(ctlx->outbuf.type),
-		               ctlxstr(ctlx->state));
+		       hfa384x2host_16(ctlx->outbuf.type),
+		       ctlxstr(ctlx->state));
 		break;
-	} /* switch */
+	}			/* switch */
 }
 
 /*----------------------------------------------------------------
@@ -3316,10 +3141,9 @@ static void unlocked_usbctlx_complete(hf
 * Call context:
 *	any
 ----------------------------------------------------------------*/
-static void
-hfa384x_usbctlxq_run(hfa384x_t	*hw)
+static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 {
-	unsigned long		flags;
+	unsigned long flags;
 
 	/* acquire lock */
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3331,28 +3155,26 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 	 * Don't touch any of these CTLXs if the hardware
 	 * has been removed or the USB subsystem is stalled.
 	 */
-	if ( !list_empty(&hw->ctlxq.active) ||
-	     test_bit(WORK_TX_HALT, &hw->usb_flags) ||
-	     hw->wlandev->hwremoved )
+	if (!list_empty(&hw->ctlxq.active) ||
+	    test_bit(WORK_TX_HALT, &hw->usb_flags) || hw->wlandev->hwremoved)
 		goto unlock;
 
-	while ( !list_empty(&hw->ctlxq.pending) ) {
-		hfa384x_usbctlx_t	*head;
-		int			result;
+	while (!list_empty(&hw->ctlxq.pending)) {
+		hfa384x_usbctlx_t *head;
+		int result;
 
 		/* This is the first pending command */
 		head = list_entry(hw->ctlxq.pending.next,
-		                  hfa384x_usbctlx_t,
-		                  list);
+				  hfa384x_usbctlx_t, list);
 
 		/* We need to split this off to avoid a race condition */
 		list_move_tail(&head->list, &hw->ctlxq.active);
 
 		/* Fill the out packet */
-		usb_fill_bulk_urb( &(hw->ctlx_urb), hw->usb,
-		                   hw->endp_out,
-		                   &(head->outbuf), ROUNDUP64(head->outbufsize),
-		                   hfa384x_ctlxout_callback, hw);
+		usb_fill_bulk_urb(&(hw->ctlx_urb), hw->usb,
+				  hw->endp_out,
+				  &(head->outbuf), ROUNDUP64(head->outbufsize),
+				  hfa384x_ctlxout_callback, hw);
 		hw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;
 
 		/* Now submit the URB and update the CTLX's state
@@ -3368,7 +3190,7 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 
 			/* Start the IN wait timer */
 			hw->resp_timer_done = 0;
-			hw->resptimer.expires = jiffies + 2*HZ;
+			hw->resptimer.expires = jiffies + 2 * HZ;
 			add_timer(&hw->resptimer);
 
 			break;
@@ -3379,8 +3201,9 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 			 * this CTLX back in the "pending" queue
 			 * and schedule a reset ...
 			 */
-			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
-			                 hw->wlandev->netdev->name);
+			printk(KERN_WARNING
+			       "%s tx pipe stalled: requesting reset\n",
+			       hw->wlandev->netdev->name);
 			list_move(&head->list, &hw->ctlxq.pending);
 			set_bit(WORK_TX_HALT, &hw->usb_flags);
 			schedule_work(&hw->usb_work);
@@ -3389,20 +3212,19 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 
 		if (result == -ESHUTDOWN) {
 			printk(KERN_WARNING "%s urb shutdown!\n",
-					 hw->wlandev->netdev->name);
+			       hw->wlandev->netdev->name);
 			break;
 		}
 
 		printk(KERN_ERR "Failed to submit CTLX[%d]: error=%d\n",
-		               hfa384x2host_16(head->outbuf.type), result);
+		       hfa384x2host_16(head->outbuf.type), result);
 		unlocked_usbctlx_complete(hw, head);
-	} /* while */
+	}			/* while */
 
-	unlock:
+unlock:
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_callback
 *
@@ -3421,13 +3243,13 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_callback(struct urb *urb)
 {
-	wlandevice_t		*wlandev = urb->context;
-	hfa384x_t		*hw;
-	hfa384x_usbin_t		*usbin = (hfa384x_usbin_t *) urb->transfer_buffer;
-	struct sk_buff          *skb = NULL;
-	int			result;
-	int                     urb_status;
-	u16			type;
+	wlandevice_t *wlandev = urb->context;
+	hfa384x_t *hw;
+	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) urb->transfer_buffer;
+	struct sk_buff *skb = NULL;
+	int result;
+	int urb_status;
+	u16 type;
 
 	enum USBIN_ACTION {
 		HANDLE,
@@ -3435,9 +3257,7 @@ static void hfa384x_usbin_callback(struc
 		ABORT
 	} action;
 
-	if ( !wlandev ||
-	     !wlandev->netdev ||
-	     wlandev->hwremoved )
+	if (!wlandev || !wlandev->netdev || wlandev->hwremoved)
 		goto exit;
 
 	hw = wlandev->priv;
@@ -3445,9 +3265,9 @@ static void hfa384x_usbin_callback(struc
 		goto exit;
 
 	skb = hw->rx_urb_skb;
-	if (!skb || (skb->data != urb->transfer_buffer)) {
+	if (!skb || (skb->data != urb->transfer_buffer))
 		BUG();
-	}
+
 	hw->rx_urb_skb = NULL;
 
 	/* Check for error conditions within the URB */
@@ -3456,7 +3276,7 @@ static void hfa384x_usbin_callback(struc
 		action = HANDLE;
 
 		/* Check for short packet */
-		if ( urb->actual_length == 0 ) {
+		if (urb->actual_length == 0) {
 			++(wlandev->linux_stats.rx_errors);
 			++(wlandev->linux_stats.rx_length_errors);
 			action = RESUBMIT;
@@ -3465,8 +3285,8 @@ static void hfa384x_usbin_callback(struc
 
 	case -EPIPE:
 		printk(KERN_WARNING "%s rx pipe stalled: requesting reset\n",
-		                 wlandev->netdev->name);
-		if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
+		       wlandev->netdev->name);
+		if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
 			schedule_work(&hw->usb_work);
 		++(wlandev->linux_stats.rx_errors);
 		action = ABORT;
@@ -3475,8 +3295,8 @@ static void hfa384x_usbin_callback(struc
 	case -EILSEQ:
 	case -ETIMEDOUT:
 	case -EPROTO:
-		if ( !test_and_set_bit(THROTTLE_RX, &hw->usb_flags) &&
-		     !timer_pending(&hw->throttle) ) {
+		if (!test_and_set_bit(THROTTLE_RX, &hw->usb_flags) &&
+		    !timer_pending(&hw->throttle)) {
 			mod_timer(&hw->throttle, jiffies + THROTTLE_JIFFIES);
 		}
 		++(wlandev->linux_stats.rx_errors);
@@ -3496,13 +3316,14 @@ static void hfa384x_usbin_callback(struc
 
 	case -ENOENT:
 	case -ECONNRESET:
-		pr_debug("status=%d, urb explicitly unlinked.\n", urb->status);
+		pr_debug("status=%d, urb explicitly unlinked.\n",
+		       urb->status);
 		action = ABORT;
 		break;
 
 	default:
 		pr_debug("urb status=%d, transfer flags=0x%x\n",
-		                 urb->status, urb->transfer_flags);
+		       urb->status, urb->transfer_flags);
 		++(wlandev->linux_stats.rx_errors);
 		action = RESUBMIT;
 		break;
@@ -3516,8 +3337,8 @@ static void hfa384x_usbin_callback(struc
 
 		if (result != 0) {
 			printk(KERN_ERR
-				"Fatal, failed to resubmit rx_urb. error=%d\n",
-				result);
+			       "Fatal, failed to resubmit rx_urb. error=%d\n",
+			       result);
 		}
 	}
 
@@ -3562,19 +3383,20 @@ static void hfa384x_usbin_callback(struc
 
 	case HFA384x_USB_BUFAVAIL:
 		pr_debug("Received BUFAVAIL packet, frmlen=%d\n",
-			usbin->bufavail.frmlen);
+		       usbin->bufavail.frmlen);
 		break;
 
 	case HFA384x_USB_ERROR:
 		pr_debug("Received USB_ERROR packet, errortype=%d\n",
-			usbin->usberror.errortype);
+		       usbin->usberror.errortype);
 		break;
 
 	default:
-		pr_debug("Unrecognized USBIN packet, type=%x, status=%d\n",
-			usbin->type, urb_status);
+		printk(KERN_DEBUG
+		       "Unrecognized USBIN packet, type=%x, status=%d\n",
+		       usbin->type, urb_status);
 		break;
-	} /* switch */
+	}			/* switch */
 
 exit:
 
@@ -3582,7 +3404,6 @@ exit:
 		dev_kfree_skb(skb);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_ctlx
 *
@@ -3606,9 +3427,9 @@ exit:
 static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			       int urb_status)
 {
-	hfa384x_usbctlx_t	*ctlx;
-	int			run_queue = 0;
-	unsigned long		flags;
+	hfa384x_usbctlx_t *ctlx;
+	int run_queue = 0;
+	unsigned long flags;
 
 retry:
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3617,9 +3438,8 @@ retry:
 	 * at any one time, and this is the CTLX that the
 	 * timers are waiting for.
 	 */
-	if ( list_empty(&hw->ctlxq.active) ) {
+	if (list_empty(&hw->ctlxq.active))
 		goto unlock;
-	}
 
 	/* Remove the "response timeout". It's possible that
 	 * we are already too late, and that the timeout is
@@ -3632,8 +3452,7 @@ retry:
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			goto retry;
 		}
-	}
-	else {
+	} else {
 		hw->resp_timer_done = 1;
 	}
 
@@ -3648,15 +3467,16 @@ retry:
 		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 			run_queue = 1;
 	} else {
-		const u16 intype = (usbin->type&~host2hfa384x_16(0x8000));
+		const u16 intype = (usbin->type & ~host2hfa384x_16(0x8000));
 
 		/*
 		 * Check that our message is what we're expecting ...
 		 */
 		if (ctlx->outbuf.type != intype) {
-			printk(KERN_WARNING "Expected IN[%d], received IN[%d] - ignored.\n",
-			                 hfa384x2host_16(ctlx->outbuf.type),
-			                 hfa384x2host_16(intype));
+			printk(KERN_WARNING
+			       "Expected IN[%d], received IN[%d] - ignored.\n",
+			       hfa384x2host_16(ctlx->outbuf.type),
+			       hfa384x2host_16(intype));
 			goto unlock;
 		}
 
@@ -3670,7 +3490,8 @@ retry:
 			 * our request has been acknowledged. Odd,
 			 * but our OUT URB is still alive...
 			 */
-			pr_debug("Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
+			printk(KERN_DEBUG
+			       "Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
 			ctlx->state = CTLX_RESP_COMPLETE;
 			break;
 
@@ -3689,14 +3510,15 @@ retry:
 			/*
 			 * Throw this CTLX away ...
 			 */
-			printk(KERN_ERR "Matched IN URB, CTLX[%d] in invalid state(%s)."
-			               " Discarded.\n",
-			               hfa384x2host_16(ctlx->outbuf.type),
-			               ctlxstr(ctlx->state));
+			printk(KERN_ERR
+			       "Matched IN URB, CTLX[%d] in invalid state(%s)."
+			       " Discarded.\n",
+			       hfa384x2host_16(ctlx->outbuf.type),
+			       ctlxstr(ctlx->state));
 			if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 				run_queue = 1;
 			break;
-		} /* switch */
+		}		/* switch */
 	}
 
 unlock:
@@ -3706,7 +3528,6 @@ unlock:
 		hfa384x_usbctlxq_run(hw);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_txcompl
 *
@@ -3724,22 +3545,20 @@ unlock:
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
+				  hfa384x_usbin_t *usbin)
 {
-	u16			status;
+	u16 status;
 
-	status = hfa384x2host_16(usbin->type); /* yeah I know it says type...*/
+	status = hfa384x2host_16(usbin->type);	/* yeah I know it says type... */
 
 	/* Was there an error? */
-	if (HFA384x_TXSTATUS_ISERROR(status)) {
+	if (HFA384x_TXSTATUS_ISERROR(status))
 		prism2sta_ev_txexc(wlandev, status);
-	} else {
+	else
 		prism2sta_ev_tx(wlandev, status);
-	}
-	// prism2sta_ev_alloc(wlandev);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_rx
 *
@@ -3759,28 +3578,25 @@ static void hfa384x_usbin_txcompl(wlande
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 {
-	hfa384x_usbin_t         *usbin = (hfa384x_usbin_t *) skb->data;
-	hfa384x_t               *hw = wlandev->priv;
-	int                     hdrlen;
-	p80211_rxmeta_t         *rxmeta;
-	u16                  data_len;
-	u16                  fc;
+	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) skb->data;
+	hfa384x_t *hw = wlandev->priv;
+	int hdrlen;
+	p80211_rxmeta_t *rxmeta;
+	u16 data_len;
+	u16 fc;
 
 	/* Byte order convert once up front. */
-	usbin->rxfrm.desc.status =
-		hfa384x2host_16(usbin->rxfrm.desc.status);
-	usbin->rxfrm.desc.time =
-		hfa384x2host_32(usbin->rxfrm.desc.time);
+	usbin->rxfrm.desc.status = hfa384x2host_16(usbin->rxfrm.desc.status);
+	usbin->rxfrm.desc.time = hfa384x2host_32(usbin->rxfrm.desc.time);
 
 	/* Now handle frame based on port# */
-	switch( HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) )
-	{
+	switch (HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status)) {
 	case 0:
 		fc = le16_to_cpu(usbin->rxfrm.desc.frame_control);
 
 		/* If exclude and we receive an unencrypted, drop it */
-		if ( (wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&
-		     !WLAN_GET_FC_ISWEP(fc)){
+		if ((wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&
+		    !WLAN_GET_FC_ISWEP(fc)) {
 			goto done;
 		}
 
@@ -3796,8 +3612,7 @@ static void hfa384x_usbin_rx(wlandevice_
 		 * with an "overlapping" copy
 		 */
 		memmove(skb_push(skb, hdrlen),
-		        &usbin->rxfrm.desc.frame_control,
-		        hdrlen);
+			&usbin->rxfrm.desc.frame_control, hdrlen);
 
 		skb->dev = wlandev->netdev;
 		skb->dev->last_rx = jiffies;
@@ -3823,18 +3638,19 @@ static void hfa384x_usbin_rx(wlandevice_
 		break;
 
 	case 7:
-		if ( ! HFA384x_RXSTATUS_ISFCSERR(usbin->rxfrm.desc.status) ) {
+		if (!HFA384x_RXSTATUS_ISFCSERR(usbin->rxfrm.desc.status)) {
 			/* Copy to wlansnif skb */
-			hfa384x_int_rxmonitor( wlandev, &usbin->rxfrm);
+			hfa384x_int_rxmonitor(wlandev, &usbin->rxfrm);
 			dev_kfree_skb(skb);
 		} else {
-			pr_debug("Received monitor frame: FCSerr set\n");
+			printk(KERN_DEBUG
+			       "Received monitor frame: FCSerr set\n");
 		}
 		break;
 
 	default:
 		printk(KERN_WARNING "Received frame on unsupported port=%d\n",
-			HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) );
+		       HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status));
 		goto done;
 		break;
 	}
@@ -3864,16 +3680,17 @@ done:
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm)
+static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
+				  hfa384x_usb_rxfrm_t *rxfrm)
 {
-	hfa384x_rx_frame_t              *rxdesc = &(rxfrm->desc);
-	unsigned int				hdrlen = 0;
-	unsigned int				datalen = 0;
-	unsigned int				skblen = 0;
-	u8				*datap;
-	u16				fc;
-	struct sk_buff			*skb;
-	hfa384x_t		        *hw = wlandev->priv;
+	hfa384x_rx_frame_t *rxdesc = &(rxfrm->desc);
+	unsigned int hdrlen = 0;
+	unsigned int datalen = 0;
+	unsigned int skblen = 0;
+	u8 *datap;
+	u16 fc;
+	struct sk_buff *skb;
+	hfa384x_t *hw = wlandev->priv;
 
 	/* Don't forget the status, time, and data_len fields are in host order */
 	/* Figure out how big the frame is */
@@ -3882,66 +3699,66 @@ static void hfa384x_int_rxmonitor( wland
 	datalen = hfa384x2host_16(rxdesc->data_len);
 
 	/* Allocate an ind message+framesize skb */
-	skblen = sizeof(p80211_caphdr_t) +
-		hdrlen + datalen + WLAN_CRC_LEN;
+	skblen = sizeof(p80211_caphdr_t) + hdrlen + datalen + WLAN_CRC_LEN;
 
 	/* sanity check the length */
-	if ( skblen >
-	     (sizeof(p80211_caphdr_t) +
-	      WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
+	if (skblen >
+	    (sizeof(p80211_caphdr_t) +
+	     WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN)) {
 		pr_debug("overlen frm: len=%zd\n",
-			       skblen - sizeof(p80211_caphdr_t));
+		       skblen - sizeof(p80211_caphdr_t));
 	}
 
-	if ( (skb = dev_alloc_skb(skblen)) == NULL ) {
-		printk(KERN_ERR "alloc_skb failed trying to allocate %d bytes\n", skblen);
+	if ((skb = dev_alloc_skb(skblen)) == NULL) {
+		printk(KERN_ERR
+		       "alloc_skb failed trying to allocate %d bytes\n",
+		       skblen);
 		return;
 	}
 
 	/* only prepend the prism header if in the right mode */
 	if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
 	    (hw->sniffhdr != 0)) {
-		p80211_caphdr_t		*caphdr;
+		p80211_caphdr_t *caphdr;
 		/* The NEW header format! */
 		datap = skb_put(skb, sizeof(p80211_caphdr_t));
-		caphdr = (p80211_caphdr_t*) datap;
+		caphdr = (p80211_caphdr_t *) datap;
 
-		caphdr->version =	htonl(P80211CAPTURE_VERSION);
-		caphdr->length =	htonl(sizeof(p80211_caphdr_t));
-		caphdr->mactime =	__cpu_to_be64(rxdesc->time) * 1000;
-		caphdr->hosttime =	__cpu_to_be64(jiffies);
-		caphdr->phytype =	htonl(4); /* dss_dot11_b */
-		caphdr->channel =	htonl(hw->sniff_channel);
-		caphdr->datarate =	htonl(rxdesc->rate);
-		caphdr->antenna =	htonl(0); /* unknown */
-		caphdr->priority =	htonl(0); /* unknown */
-		caphdr->ssi_type =	htonl(3); /* rssi_raw */
-		caphdr->ssi_signal =	htonl(rxdesc->signal);
-		caphdr->ssi_noise =	htonl(rxdesc->silence);
-		caphdr->preamble =	htonl(0); /* unknown */
-		caphdr->encoding =	htonl(1); /* cck */
+		caphdr->version = htonl(P80211CAPTURE_VERSION);
+		caphdr->length = htonl(sizeof(p80211_caphdr_t));
+		caphdr->mactime = __cpu_to_be64(rxdesc->time) * 1000;
+		caphdr->hosttime = __cpu_to_be64(jiffies);
+		caphdr->phytype = htonl(4);	/* dss_dot11_b */
+		caphdr->channel = htonl(hw->sniff_channel);
+		caphdr->datarate = htonl(rxdesc->rate);
+		caphdr->antenna = htonl(0);	/* unknown */
+		caphdr->priority = htonl(0);	/* unknown */
+		caphdr->ssi_type = htonl(3);	/* rssi_raw */
+		caphdr->ssi_signal = htonl(rxdesc->signal);
+		caphdr->ssi_noise = htonl(rxdesc->silence);
+		caphdr->preamble = htonl(0);	/* unknown */
+		caphdr->encoding = htonl(1);	/* cck */
 	}
 
 	/* Copy the 802.11 header to the skb (ctl frames may be less than a full header) */
 	datap = skb_put(skb, hdrlen);
-	memcpy( datap, &(rxdesc->frame_control), hdrlen);
+	memcpy(datap, &(rxdesc->frame_control), hdrlen);
 
 	/* If any, copy the data from the card to the skb */
-	if ( datalen > 0 )
-	{
+	if (datalen > 0) {
 		datap = skb_put(skb, datalen);
 		memcpy(datap, rxfrm->data, datalen);
 
 		/* check for unencrypted stuff if WEP bit set. */
-		if (*(datap - hdrlen + 1) & 0x40) // wep set
-		  if ((*(datap) == 0xaa) && (*(datap+1) == 0xaa))
-		    *(datap - hdrlen + 1) &= 0xbf; // clear wep; it's the 802.2 header!
+		if (*(datap - hdrlen + 1) & 0x40)	/* wep set */
+			if ((*(datap) == 0xaa) && (*(datap + 1) == 0xaa))
+				*(datap - hdrlen + 1) &= 0xbf;	// clear wep; it's the 802.2 header!
 	}
 
 	if (hw->sniff_fcs) {
 		/* Set the FCS */
 		datap = skb_put(skb, WLAN_CRC_LEN);
-		memset( datap, 0xff, WLAN_CRC_LEN);
+		memset(datap, 0xff, WLAN_CRC_LEN);
 	}
 
 	/* pass it back up */
@@ -3950,8 +3767,6 @@ static void hfa384x_int_rxmonitor( wland
 	return;
 }
 
-
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_info
 *
@@ -3969,14 +3784,13 @@ static void hfa384x_int_rxmonitor( wland
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+static void hfa384x_usbin_info(wlandevice_t * wlandev, hfa384x_usbin_t * usbin)
 {
-	usbin->infofrm.info.framelen = hfa384x2host_16(usbin->infofrm.info.framelen);
+	usbin->infofrm.info.framelen =
+	    hfa384x2host_16(usbin->infofrm.info.framelen);
 	prism2sta_ev_info(wlandev, &usbin->infofrm.info);
 }
 
-
-
 /*----------------------------------------------------------------
 * hfa384x_usbout_callback
 *
@@ -3995,47 +3809,49 @@ static void hfa384x_usbin_info(wlandevic
 ----------------------------------------------------------------*/
 static void hfa384x_usbout_callback(struct urb *urb)
 {
-	wlandevice_t		*wlandev = urb->context;
-	hfa384x_usbout_t	*usbout = urb->transfer_buffer;
+	wlandevice_t *wlandev = urb->context;
+	hfa384x_usbout_t *usbout = urb->transfer_buffer;
 
 #ifdef DEBUG_USB
 	dbprint_urb(urb);
 #endif
 
-	if ( wlandev &&
-	     wlandev->netdev ) {
+	if (wlandev && wlandev->netdev) {
 
-		switch(urb->status) {
+		switch (urb->status) {
 		case 0:
 			hfa384x_usbout_tx(wlandev, usbout);
 			break;
 
 		case -EPIPE:
-		{
-			hfa384x_t *hw = wlandev->priv;
-			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
-			                 wlandev->netdev->name);
-			if ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) )
-				schedule_work(&hw->usb_work);
-			++(wlandev->linux_stats.tx_errors);
-			break;
-		}
+			{
+				hfa384x_t *hw = wlandev->priv;
+				printk(KERN_WARNING
+				       "%s tx pipe stalled: requesting reset\n",
+				       wlandev->netdev->name);
+				if (!test_and_set_bit
+				    (WORK_TX_HALT, &hw->usb_flags))
+					schedule_work(&hw->usb_work);
+				++(wlandev->linux_stats.tx_errors);
+				break;
+			}
 
 		case -EPROTO:
 		case -ETIMEDOUT:
 		case -EILSEQ:
-		{
-			hfa384x_t *hw = wlandev->priv;
+			{
+				hfa384x_t *hw = wlandev->priv;
 
-			if ( !test_and_set_bit(THROTTLE_TX, &hw->usb_flags)
-			     && !timer_pending(&hw->throttle) ) {
-				mod_timer(&hw->throttle,
-				          jiffies + THROTTLE_JIFFIES);
+				if (!test_and_set_bit
+				    (THROTTLE_TX, &hw->usb_flags)
+				    && !timer_pending(&hw->throttle)) {
+					mod_timer(&hw->throttle,
+						  jiffies + THROTTLE_JIFFIES);
+				}
+				++(wlandev->linux_stats.tx_errors);
+				netif_stop_queue(wlandev->netdev);
+				break;
 			}
-			++(wlandev->linux_stats.tx_errors);
-			netif_stop_queue(wlandev->netdev);
-			break;
-		}
 
 		case -ENOENT:
 		case -ESHUTDOWN:
@@ -4043,14 +3859,14 @@ static void hfa384x_usbout_callback(stru
 			break;
 
 		default:
-			printk(KERN_INFO "unknown urb->status=%d\n", urb->status);
+			printk(KERN_INFO "unknown urb->status=%d\n",
+			       urb->status);
 			++(wlandev->linux_stats.tx_errors);
 			break;
-		} /* switch */
+		}		/* switch */
 	}
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_ctlxout_callback
 *
@@ -4069,20 +3885,19 @@ static void hfa384x_usbout_callback(stru
 ----------------------------------------------------------------*/
 static void hfa384x_ctlxout_callback(struct urb *urb)
 {
-	hfa384x_t	*hw = urb->context;
-	int             delete_resptimer = 0;
-	int             timer_ok = 1;
-	int		run_queue = 0;
-	hfa384x_usbctlx_t	*ctlx;
-	unsigned long	flags;
+	hfa384x_t *hw = urb->context;
+	int delete_resptimer = 0;
+	int timer_ok = 1;
+	int run_queue = 0;
+	hfa384x_usbctlx_t *ctlx;
+	unsigned long flags;
 
 	pr_debug("urb->status=%d\n", urb->status);
 #ifdef DEBUG_USB
 	dbprint_urb(urb);
 #endif
-	if ( (urb->status == -ESHUTDOWN) ||
-	     (urb->status == -ENODEV) ||
-	     (hw == NULL) )
+	if ((urb->status == -ESHUTDOWN) ||
+	    (urb->status == -ENODEV) || (hw == NULL))
 		goto done;
 
 retry:
@@ -4094,7 +3909,7 @@ retry:
 	 * rely on the disconnect function to clean everything
 	 * up if someone unplugged the adapter.
 	 */
-	if ( list_empty(&hw->ctlxq.active) ) {
+	if (list_empty(&hw->ctlxq.active)) {
 		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 		goto done;
 	}
@@ -4113,16 +3928,15 @@ retry:
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			goto retry;
 		}
-	}
-	else {
+	} else {
 		hw->req_timer_done = 1;
 	}
 
 	ctlx = get_active_ctlx(hw);
 
-	if ( urb->status == 0 ) {
+	if (urb->status == 0) {
 		/* Request portion of a CTLX is successful */
-		switch ( ctlx->state ) {
+		switch (ctlx->state) {
 		case CTLX_REQ_SUBMITTED:
 			/* This OUT-ACK received before IN */
 			ctlx->state = CTLX_REQ_COMPLETE;
@@ -4140,17 +3954,18 @@ retry:
 		default:
 			/* This is NOT a valid CTLX "success" state! */
 			printk(KERN_ERR
-			    "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
-			    hfa384x2host_16(ctlx->outbuf.type),
-			    ctlxstr(ctlx->state), urb->status);
+			       "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
+			       hfa384x2host_16(ctlx->outbuf.type),
+			       ctlxstr(ctlx->state), urb->status);
 			break;
-		} /* switch */
+		}		/* switch */
 	} else {
 		/* If the pipe has stalled then we need to reset it */
-		if ( (urb->status == -EPIPE) &&
-		      !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) ) {
-			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
-			                 hw->wlandev->netdev->name);
+		if ((urb->status == -EPIPE) &&
+		    !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags)) {
+			printk(KERN_WARNING
+			       "%s tx pipe stalled: requesting reset\n",
+			       hw->wlandev->netdev->name);
 			schedule_work(&hw->usb_work);
 		}
 
@@ -4163,7 +3978,7 @@ retry:
 		run_queue = 1;
 	}
 
- delresp:
+delresp:
 	if (delete_resptimer) {
 		if ((timer_ok = del_timer(&hw->resptimer)) != 0) {
 			hw->resp_timer_done = 1;
@@ -4172,7 +3987,7 @@ retry:
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 
-	if ( !timer_ok && (hw->resp_timer_done == 0) ) {
+	if (!timer_ok && (hw->resp_timer_done == 0)) {
 		spin_lock_irqsave(&hw->ctlxq.lock, flags);
 		goto delresp;
 	}
@@ -4180,11 +3995,10 @@ retry:
 	if (run_queue)
 		hfa384x_usbctlxq_run(hw);
 
- done:
-        ;
+done:
+	;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbctlx_reqtimerfn
 *
@@ -4203,11 +4017,10 @@ retry:
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_usbctlx_reqtimerfn(unsigned long data)
+static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 {
-	hfa384x_t	*hw = (hfa384x_t*)data;
-	unsigned long   flags;
+	hfa384x_t *hw = (hfa384x_t *) data;
+	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -4216,15 +4029,13 @@ hfa384x_usbctlx_reqtimerfn(unsigned long
 	/* Removing the hardware automatically empties
 	 * the active list ...
 	 */
-	if ( !list_empty(&hw->ctlxq.active) )
-	{
+	if (!list_empty(&hw->ctlxq.active)) {
 		/*
 		 * We must ensure that our URB is removed from
 		 * the system, if it hasn't already expired.
 		 */
 		hw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;
-		if (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS)
-		{
+		if (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS) {
 			hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
 
 			ctlx->state = CTLX_REQ_FAILED;
@@ -4246,7 +4057,6 @@ hfa384x_usbctlx_reqtimerfn(unsigned long
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbctlx_resptimerfn
 *
@@ -4265,11 +4075,10 @@ hfa384x_usbctlx_reqtimerfn(unsigned long
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_usbctlx_resptimerfn(unsigned long data)
+static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t*)data;
-	unsigned long   flags;
+	hfa384x_t *hw = (hfa384x_t *) data;
+	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -4278,12 +4087,10 @@ hfa384x_usbctlx_resptimerfn(unsigned lon
 	/* The active list will be empty if the
 	 * adapter has been unplugged ...
 	 */
-	if ( !list_empty(&hw->ctlxq.active) )
-	{
+	if (!list_empty(&hw->ctlxq.active)) {
 		hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
 
-		if ( unlocked_usbctlx_cancel_async(hw, ctlx) == 0 )
-		{
+		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			hfa384x_usbctlxq_run(hw);
 			goto done;
@@ -4292,8 +4099,8 @@ hfa384x_usbctlx_resptimerfn(unsigned lon
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 
- done:
-        ;
+done:
+	;
 
 }
 
@@ -4312,11 +4119,10 @@ hfa384x_usbctlx_resptimerfn(unsigned lon
 * Call context:
 *	Interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_usb_throttlefn(unsigned long data)
+static void hfa384x_usb_throttlefn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t*)data;
-	unsigned long   flags;
+	hfa384x_t *hw = (hfa384x_t *) data;
+	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -4325,22 +4131,19 @@ hfa384x_usb_throttlefn(unsigned long dat
 	 * so we use the bitwise OR instead of the logical OR.
 	 */
 	pr_debug("flags=0x%lx\n", hw->usb_flags);
-	if ( !hw->wlandev->hwremoved &&
-	     (
-	       (test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&
-	       !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags))
-	       |
-	       (test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&
-	        !test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags))
-	     ) )
-	{
+	if (!hw->wlandev->hwremoved &&
+	    ((test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&
+	      !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags))
+	     |
+	     (test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&
+	      !test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags))
+	    )) {
 		schedule_work(&hw->usb_work);
 	}
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbctlx_submit
 *
@@ -4359,10 +4162,7 @@ hfa384x_usb_throttlefn(unsigned long dat
 * Call context:
 *	process or interrupt
 ----------------------------------------------------------------*/
-static int
-hfa384x_usbctlx_submit(
-	hfa384x_t		*hw,
-	hfa384x_usbctlx_t	*ctlx)
+static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 {
 	unsigned long flags;
 	int ret;
@@ -4384,7 +4184,6 @@ hfa384x_usbctlx_submit(
 	return ret;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbout_tx
 *
@@ -4425,10 +4224,9 @@ static void hfa384x_usbout_tx(wlandevice
 *
 * Call context:
 ----------------------------------------------------------------*/
-static int
-hfa384x_isgood_pdrcode(u16 pdrcode)
+static int hfa384x_isgood_pdrcode(u16 pdrcode)
 {
-	switch(pdrcode) {
+	switch (pdrcode) {
 	case HFA384x_PDR_END_OF_PDA:
 	case HFA384x_PDR_PCB_PARTNUM:
 	case HFA384x_PDR_PDAVER:
@@ -4462,23 +4260,20 @@ hfa384x_isgood_pdrcode(u16 pdrcode)
 		return 1;
 		break;
 	default:
-		if ( pdrcode < 0x1000 ) {
+		if (pdrcode < 0x1000) {
 			/* code is OK, but we don't know exactly what it is */
-			pr_debug(
-				"Encountered unknown PDR#=0x%04x, "
-				"assuming it's ok.\n",
-				pdrcode);
+			printk(KERN_DEBUG
+			       "Encountered unknown PDR#=0x%04x, "
+			       "assuming it's ok.\n", pdrcode);
 			return 1;
 		} else {
 			/* bad code */
-			pr_debug(
-				"Encountered unknown PDR#=0x%04x, "
-				"(>=0x1000), assuming it's bad.\n",
-				pdrcode);
+			printk(KERN_DEBUG
+			       "Encountered unknown PDR#=0x%04x, "
+			       "(>=0x1000), assuming it's bad.\n", pdrcode);
 			return 0;
 		}
 		break;
 	}
-	return 0; /* avoid compiler warnings */
+	return 0;		/* avoid compiler warnings */
 }
-
