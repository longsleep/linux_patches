From cb144816e009e3dde776d25380b294d18bf7f257 Mon Sep 17 00:00:00 2001
From: David Schleef <ds@schleef.org>
Date: Thu, 12 Feb 2009 16:09:00 -0800
Subject: Staging: comedi: add das08 drivers

From: David Schleef <ds@schleef.org>

Supports [Keithley Metrabyte] DAS08 (isa-das08), [ComputerBoards] DAS08
(isa-das08), DAS08-PGM (das08-pgm), DAS08-PGH (das08-pgh), DAS08-PGL
(das08-pgl), DAS08-AOH (das08-aoh), DAS08-AOL (das08-aol), DAS08-AOM
(das08-aom), DAS08/JR-AO (das08/jr-ao), DAS08/JR-16-AO (das08jr-16-ao),
PCI-DAS08 (das08), PC104-DAS08 (pc104-das08), DAS08/JR/16 (das08jr/16)
[ComputerBoards] PCM-DAS08 (pcm-das08)

From: David Schleef <ds@schleef.org>
Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
Cc: Ian Abbott <abbotti@mev.co.uk>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/comedi/drivers/das08.c    | 1068 ++++++++++++++++++++++++++++++
 drivers/staging/comedi/drivers/das08.h    |   78 ++
 drivers/staging/comedi/drivers/das08_cs.c |  489 +++++++++++++
 3 files changed, 1635 insertions(+)
 create mode 100644 drivers/staging/comedi/drivers/das08.c
 create mode 100644 drivers/staging/comedi/drivers/das08.h
 create mode 100644 drivers/staging/comedi/drivers/das08_cs.c

--- /dev/null
+++ b/drivers/staging/comedi/drivers/das08.c
@@ -0,0 +1,1068 @@
+/*
+    comedi/drivers/das08.c
+    DAS08 driver
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+    Copyright (C) 2001,2002,2003 Frank Mori Hess <fmhess@users.sourceforge.net>
+    Copyright (C) 2004 Salvador E. Tropea <set@users.sf.net> <set@ieee.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*****************************************************************
+
+*/
+/*
+Driver: das08
+Description: DAS-08 compatible boards
+Author: Warren Jasper, ds, Frank Hess
+Devices: [Keithley Metrabyte] DAS08 (isa-das08), [ComputerBoards] DAS08 (isa-das08),
+  DAS08-PGM (das08-pgm),
+  DAS08-PGH (das08-pgh), DAS08-PGL (das08-pgl), DAS08-AOH (das08-aoh),
+  DAS08-AOL (das08-aol), DAS08-AOM (das08-aom), DAS08/JR-AO (das08/jr-ao),
+  DAS08/JR-16-AO (das08jr-16-ao), PCI-DAS08 (das08),
+  PC104-DAS08 (pc104-das08), DAS08/JR/16 (das08jr/16)
+Status: works
+
+This is a rewrite of the das08 and das08jr drivers.
+
+Options (for ISA cards):
+        [0] - base io address
+
+Options (for pci-das08):
+        [0] - bus  (optional)
+        [1] = slot (optional)
+
+The das08 driver doesn't support asynchronous commands, since
+the cheap das08 hardware doesn't really support them.  The
+comedi_rt_timer driver can be used to emulate commands for this
+driver.
+*/
+
+#include "../comedidev.h"
+
+#include <linux/delay.h>
+
+#include "comedi_pci.h"
+#include "8255.h"
+#include "das08.h"
+
+#define DRV_NAME "das08"
+
+#define PCI_VENDOR_ID_COMPUTERBOARDS 0x1307
+#define PCI_DEVICE_ID_PCIDAS08 0x29
+#define PCIDAS08_SIZE 0x54
+
+// pci configuration registers
+#define INTCSR               0x4c
+#define   INTR1_ENABLE         0x1
+#define   INTR1_HIGH_POLARITY  0x2
+#define   PCI_INTR_ENABLE      0x40
+#define   INTR1_EDGE_TRIG      0x100	// requires high polarity
+#define CNTRL                0x50
+#define   CNTRL_DIR            0x2
+#define   CNTRL_INTR           0x4
+
+/*
+    cio-das08.pdf
+
+  "isa-das08"
+
+  0	a/d bits 0-3		start 8 bit
+  1	a/d bits 4-11		start 12 bit
+  2	eoc, ip1-3, irq, mux	op1-4, inte, mux
+  3	unused			unused
+  4567	8254
+  89ab	8255
+
+  requires hard-wiring for async ai
+
+*/
+
+#define DAS08_LSB		0
+#define DAS08_MSB		1
+#define DAS08_TRIG_12BIT	1
+#define DAS08_STATUS		2
+#define   DAS08_EOC			(1<<7)
+#define   DAS08_IRQ			(1<<3)
+#define   DAS08_IP(x)			(((x)>>4)&0x7)
+#define DAS08_CONTROL		2
+#define   DAS08_MUX_MASK	0x7
+#define   DAS08_MUX(x)		((x) & DAS08_MUX_MASK)
+#define   DAS08_INTE			(1<<3)
+#define   DAS08_DO_MASK		0xf0
+#define   DAS08_OP(x)		(((x) << 4) & DAS08_DO_MASK)
+
+/*
+    cio-das08jr.pdf
+
+  "das08/jr-ao"
+
+  0	a/d bits 0-3		unused
+  1	a/d bits 4-11		start 12 bit
+  2	eoc, mux		mux
+  3	di			do
+  4	unused			ao0_lsb
+  5	unused			ao0_msb
+  6	unused			ao1_lsb
+  7	unused			ao1_msb
+
+*/
+
+#define DAS08JR_DIO		3
+#define DAS08JR_AO_LSB(x)	((x)?6:4)
+#define DAS08JR_AO_MSB(x)	((x)?7:5)
+
+/*
+    cio-das08_aox.pdf
+
+  "das08-aoh"
+  "das08-aol"
+  "das08-aom"
+
+  0	a/d bits 0-3		start 8 bit
+  1	a/d bits 4-11		start 12 bit
+  2	eoc, ip1-3, irq, mux	op1-4, inte, mux
+  3	mux, gain status	gain control
+  4567	8254
+  8	unused			ao0_lsb
+  9	unused			ao0_msb
+  a	unused			ao1_lsb
+  b	unused			ao1_msb
+  89ab
+  cdef	8255
+*/
+
+#define DAS08AO_GAIN_CONTROL	3
+#define DAS08AO_GAIN_STATUS	3
+
+#define DAS08AO_AO_LSB(x)	((x)?0xa:8)
+#define DAS08AO_AO_MSB(x)	((x)?0xb:9)
+#define DAS08AO_AO_UPDATE	8
+
+/* gainlist same as _pgx_ below */
+
+static int das08_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das08_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das08_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das08jr_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das08jr_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das08jr_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das08ao_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static void i8254_set_mode_low(unsigned int base, int channel,
+	unsigned int mode);
+
+static const comedi_lrange range_das08_pgl = { 9, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			BIP_RANGE(0.625),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25)
+	}
+};
+static const comedi_lrange range_das08_pgh = { 12, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(1),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.1),
+			BIP_RANGE(0.05),
+			BIP_RANGE(0.01),
+			BIP_RANGE(0.005),
+			UNI_RANGE(10),
+			UNI_RANGE(1),
+			UNI_RANGE(0.1),
+			UNI_RANGE(0.01),
+	}
+};
+static const comedi_lrange range_das08_pgm = { 9, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.05),
+			BIP_RANGE(0.01),
+			UNI_RANGE(10),
+			UNI_RANGE(1),
+			UNI_RANGE(0.1),
+			UNI_RANGE(0.01)
+	}
+};				/*
+				   cio-das08jr.pdf
+
+				   "das08/jr-ao"
+
+				   0 a/d bits 0-3            unused
+				   1 a/d bits 4-11           start 12 bit
+				   2 eoc, mux                mux
+				   3 di                      do
+				   4 unused                  ao0_lsb
+				   5 unused                  ao0_msb
+				   6 unused                  ao1_lsb
+				   7 unused                  ao1_msb
+
+				 */
+
+static const comedi_lrange *const das08_ai_lranges[] = {
+	&range_unknown,
+	&range_bipolar5,
+	&range_das08_pgh,
+	&range_das08_pgl,
+	&range_das08_pgm,
+};
+
+static const int das08_pgh_gainlist[] =
+	{ 8, 0, 10, 2, 12, 4, 14, 6, 1, 3, 5, 7 };
+static const int das08_pgl_gainlist[] = { 8, 0, 2, 4, 6, 1, 3, 5, 7 };
+static const int das08_pgm_gainlist[] = { 8, 0, 10, 12, 14, 9, 11, 13, 15 };
+
+static const int *const das08_gainlists[] = {
+	NULL,
+	NULL,
+	das08_pgh_gainlist,
+	das08_pgl_gainlist,
+	das08_pgm_gainlist,
+};
+
+static const struct das08_board_struct das08_boards[] = {
+	{
+	      name:	"isa-das08",	// cio-das08.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pg_none,
+	      ai_encoding:das08_encode12,
+	      ao:	NULL,
+	      ao_nbits:12,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:8,
+	      i8254_offset:4,
+	      iosize:	16,	// unchecked
+		},
+	{
+	      name:	"das08-pgm",	// cio-das08pgx.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pgm,
+	      ai_encoding:das08_encode12,
+	      ao:	NULL,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:0,
+	      i8254_offset:0x04,
+	      iosize:	16,	// unchecked
+		},
+	{
+	      name:	"das08-pgh",	// cio-das08pgx.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pgh,
+	      ai_encoding:das08_encode12,
+	      ao:	NULL,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:0,
+	      i8254_offset:0x04,
+	      iosize:	16,	// unchecked
+		},
+	{
+	      name:	"das08-pgl",	// cio-das08pgx.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pgl,
+	      ai_encoding:das08_encode12,
+	      ao:	NULL,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:0,
+	      i8254_offset:0x04,
+	      iosize:	16,	// unchecked
+		},
+	{
+	      name:	"das08-aoh",	// cio-das08_aox.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pgh,
+	      ai_encoding:das08_encode12,
+	      ao:	das08ao_ao_winsn,	// 8
+	      ao_nbits:12,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:0x0c,
+	      i8254_offset:0x04,
+	      iosize:	16,	// unchecked
+		},
+	{
+	      name:	"das08-aol",	// cio-das08_aox.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pgl,
+	      ai_encoding:das08_encode12,
+	      ao:	das08ao_ao_winsn,	// 8
+	      ao_nbits:12,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:0x0c,
+	      i8254_offset:0x04,
+	      iosize:	16,	// unchecked
+		},
+	{
+	      name:	"das08-aom",	// cio-das08_aox.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pgm,
+	      ai_encoding:das08_encode12,
+	      ao:	das08ao_ao_winsn,	// 8
+	      ao_nbits:12,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:0x0c,
+	      i8254_offset:0x04,
+	      iosize:	16,	// unchecked
+		},
+	{
+	      name:	"das08/jr-ao",	// cio-das08-jr-ao.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pg_none,
+	      ai_encoding:das08_encode12,
+	      ao:	das08jr_ao_winsn,
+	      ao_nbits:12,
+	      di:	das08jr_di_rbits,
+	      do_:	das08jr_do_wbits,
+	      do_nchan:8,
+	      i8255_offset:0,
+	      i8254_offset:0,
+	      iosize:	16,	// unchecked
+		},
+	{
+	      name:	"das08jr-16-ao",	// cio-das08jr-16-ao.pdf
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:16,
+	      ai_pg:	das08_pg_none,
+	      ai_encoding:das08_encode12,
+	      ao:	das08jr_ao_winsn,
+	      ao_nbits:16,
+	      di:	das08jr_di_rbits,
+	      do_:	das08jr_do_wbits,
+	      do_nchan:8,
+	      i8255_offset:0,
+	      i8254_offset:0x04,
+	      iosize:	16,	// unchecked
+		},
+#ifdef CONFIG_COMEDI_PCI
+	{
+	      name:	"das08",	// pci-das08
+	      id:	PCI_DEVICE_ID_PCIDAS08,
+	      bustype:	pci,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_bipolar5,
+	      ai_encoding:das08_encode12,
+	      ao:	NULL,
+	      ao_nbits:0,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:0,
+	      i8254_offset:4,
+	      iosize:	8,
+		},
+#endif
+	{
+	      name:	"pc104-das08",
+	      bustype:	pc104,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_pg_none,
+	      ai_encoding:das08_encode12,
+	      ao:	NULL,
+	      ao_nbits:0,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:4,
+	      i8255_offset:0,
+	      i8254_offset:4,
+	      iosize:	16,	// unchecked
+		},
+#if 0
+	{
+	      name:	"das08/f",
+		},
+	{
+	      name:	"das08jr",
+		},
+#endif
+	{
+	      name:	"das08jr/16",
+	      bustype:	isa,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:16,
+	      ai_pg:	das08_pg_none,
+	      ai_encoding:das08_encode16,
+	      ao:	NULL,
+	      ao_nbits:0,
+	      di:	das08jr_di_rbits,
+	      do_:	das08jr_do_wbits,
+	      do_nchan:8,
+	      i8255_offset:0,
+	      i8254_offset:0,
+	      iosize:	16,	// unchecked
+		},
+#if 0
+	{
+	      name:	"das48-pga",	// cio-das48-pga.pdf
+		},
+	{
+	      name:	"das08-pga-g2",	// a KM board
+		},
+#endif
+};
+
+#ifdef CONFIG_COMEDI_PCMCIA
+struct das08_board_struct das08_cs_boards[NUM_DAS08_CS_BOARDS] = {
+	{
+	      name:	"pcm-das08",
+	      id:	0x0,	// XXX
+	      bustype:	pcmcia,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_bipolar5,
+	      ai_encoding:das08_pcm_encode12,
+	      ao:	NULL,
+	      ao_nbits:0,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:3,
+	      i8255_offset:0,
+	      i8254_offset:0,
+	      iosize:	16,
+		},
+	// duplicate so driver name can be used also
+	{
+	      name:	"das08_cs",
+	      id:	0x0,	// XXX
+	      bustype:	pcmcia,
+	      ai:	das08_ai_rinsn,
+	      ai_nbits:12,
+	      ai_pg:	das08_bipolar5,
+	      ai_encoding:das08_pcm_encode12,
+	      ao:	NULL,
+	      ao_nbits:0,
+	      di:	das08_di_rbits,
+	      do_:	das08_do_wbits,
+	      do_nchan:3,
+	      i8255_offset:0,
+	      i8254_offset:0,
+	      iosize:	16,
+		},
+};
+#endif
+
+#ifdef CONFIG_COMEDI_PCI
+static DEFINE_PCI_DEVICE_TABLE(das08_pci_table) = {
+	{PCI_VENDOR_ID_COMPUTERBOARDS, PCI_DEVICE_ID_PCIDAS08, PCI_ANY_ID,
+		PCI_ANY_ID, 0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, das08_pci_table);
+#endif
+
+#define devpriv ((struct das08_private_struct *)dev->private)
+#define thisboard ((const struct das08_board_struct *)dev->board_ptr)
+
+#define TIMEOUT 100000
+
+static int das08_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i, n;
+	int chan;
+	int range;
+	int lsb, msb;
+
+	chan = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+
+	/* clear crap */
+	inb(dev->iobase + DAS08_LSB);
+	inb(dev->iobase + DAS08_MSB);
+
+	/* set multiplexer */
+	spin_lock(&dev->spinlock);	// lock to prevent race with digital output
+	devpriv->do_mux_bits &= ~DAS08_MUX_MASK;
+	devpriv->do_mux_bits |= DAS08_MUX(chan);
+	outb(devpriv->do_mux_bits, dev->iobase + DAS08_CONTROL);
+	spin_unlock(&dev->spinlock);
+
+	if (s->range_table->length > 1) {
+		/* set gain/range */
+		range = CR_RANGE(insn->chanspec);
+		outb(devpriv->pg_gainlist[range],
+			dev->iobase + DAS08AO_GAIN_CONTROL);
+	}
+
+	for (n = 0; n < insn->n; n++) {
+		/* clear over-range bits for 16-bit boards */
+		if (thisboard->ai_nbits == 16)
+			if (inb(dev->iobase + DAS08_MSB) & 0x80)
+				rt_printk("das08: over-range\n");
+
+		/* trigger conversion */
+		outb_p(0, dev->iobase + DAS08_TRIG_12BIT);
+
+		for (i = 0; i < TIMEOUT; i++) {
+			if (!(inb(dev->iobase + DAS08_STATUS) & DAS08_EOC))
+				break;
+		}
+		if (i == TIMEOUT) {
+			rt_printk("das08: timeout\n");
+			return -ETIME;
+		}
+		msb = inb(dev->iobase + DAS08_MSB);
+		lsb = inb(dev->iobase + DAS08_LSB);
+		if (thisboard->ai_encoding == das08_encode12) {
+			data[n] = (lsb >> 4) | (msb << 4);
+		} else if (thisboard->ai_encoding == das08_pcm_encode12) {
+			data[n] = (msb << 8) + lsb;
+		} else if (thisboard->ai_encoding == das08_encode16) {
+			/* FPOS 16-bit boards are sign-magnitude */
+			if (msb & 0x80)
+				data[n] = (1 << 15) | lsb | ((msb & 0x7f) << 8);
+			else
+				data[n] = (1 << 15) - (lsb | (msb & 0x7f) << 8);
+		} else {
+			comedi_error(dev, "bug! unknown ai encoding");
+			return -1;
+		}
+	}
+
+	return n;
+}
+
+static int das08_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = 0;
+	data[1] = DAS08_IP(inb(dev->iobase + DAS08_STATUS));
+
+	return 2;
+}
+
+static int das08_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int wbits;
+
+	// get current settings of digital output lines
+	wbits = (devpriv->do_mux_bits >> 4) & 0xf;
+	// null bits we are going to set
+	wbits &= ~data[0];
+	// set new bit values
+	wbits |= data[0] & data[1];
+	// remember digital output bits
+	spin_lock(&dev->spinlock);	// prevent race with setting of analog input mux
+	devpriv->do_mux_bits &= ~DAS08_DO_MASK;
+	devpriv->do_mux_bits |= DAS08_OP(wbits);
+	outb(devpriv->do_mux_bits, dev->iobase + DAS08_CONTROL);
+	spin_unlock(&dev->spinlock);
+
+	data[1] = wbits;
+
+	return 2;
+}
+
+static int das08jr_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = 0;
+	data[1] = inb(dev->iobase + DAS08JR_DIO);
+
+	return 2;
+}
+
+static int das08jr_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	// null bits we are going to set
+	devpriv->do_bits &= ~data[0];
+	// set new bit values
+	devpriv->do_bits |= data[0] & data[1];
+	outb(devpriv->do_bits, dev->iobase + DAS08JR_DIO);
+
+	data[1] = devpriv->do_bits;
+
+	return 2;
+}
+
+static int das08jr_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	int lsb, msb;
+	int chan;
+
+	lsb = data[0] & 0xff;
+	msb = (data[0] >> 8) & 0xf;
+
+	chan = CR_CHAN(insn->chanspec);
+
+	for (n = 0; n < insn->n; n++) {
+#if 0
+		outb(lsb, dev->iobase + devpriv->ao_offset_lsb[chan]);
+		outb(msb, dev->iobase + devpriv->ao_offset_msb[chan]);
+#else
+		outb(lsb, dev->iobase + DAS08JR_AO_LSB(chan));
+		outb(msb, dev->iobase + DAS08JR_AO_MSB(chan));
+#endif
+
+		/* load DACs */
+		inb(dev->iobase + DAS08JR_DIO);
+	}
+
+	return n;
+}
+
+/*
+ *
+ * The -aox boards have the DACs at a different offset and use
+ * a different method to force an update.
+ *
+ */
+static int das08ao_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	int lsb, msb;
+	int chan;
+
+	lsb = data[0] & 0xff;
+	msb = (data[0] >> 8) & 0xf;
+
+	chan = CR_CHAN(insn->chanspec);
+
+	for (n = 0; n < insn->n; n++) {
+#if 0
+		outb(lsb, dev->iobase + devpriv->ao_offset_lsb[chan]);
+		outb(msb, dev->iobase + devpriv->ao_offset_msb[chan]);
+#else
+		outb(lsb, dev->iobase + DAS08AO_AO_LSB(chan));
+		outb(msb, dev->iobase + DAS08AO_AO_MSB(chan));
+#endif
+
+		/* load DACs */
+		inb(dev->iobase + DAS08AO_AO_UPDATE);
+	}
+
+	return n;
+}
+
+static unsigned int i8254_read_channel_low(unsigned int base, int chan)
+{
+	unsigned int msb, lsb;
+
+	/* The following instructions must be in order.
+	   We must avoid other process reading the counter's value in the
+	   middle.
+	   The spin_lock isn't needed since ioctl calls grab the big kernel
+	   lock automatically */
+	/*spin_lock(sp); */
+	outb(chan << 6, base + I8254_CTRL);
+	base += chan;
+	lsb = inb(base);
+	msb = inb(base);
+	/*spin_unlock(sp); */
+
+	return lsb | (msb << 8);
+}
+
+static void i8254_write_channel_low(unsigned int base, int chan,
+	unsigned int value)
+{
+	unsigned int msb, lsb;
+
+	lsb = value & 0xFF;
+	msb = value >> 8;
+
+	/* write lsb, then msb */
+	base += chan;
+	/* See comments in i8254_read_channel_low */
+	/*spin_lock(sp); */
+	outb(lsb, base);
+	outb(msb, base);
+	/*spin_unlock(sp); */
+}
+
+static unsigned int i8254_read_channel(struct i8254_struct *st, int channel)
+{
+	int chan = st->logic2phys[channel];
+
+	return i8254_read_channel_low(st->iobase, chan);
+}
+
+static void i8254_write_channel(struct i8254_struct *st, int channel,
+	unsigned int value)
+{
+	int chan = st->logic2phys[channel];
+
+	i8254_write_channel_low(st->iobase, chan, value);
+}
+
+static void i8254_initialize(struct i8254_struct *st)
+{
+	int i;
+	for (i = 0; i < 3; ++i)
+		i8254_set_mode_low(st->iobase, i, st->mode[i]);
+}
+
+static void i8254_set_mode_low(unsigned int base, int channel,
+	unsigned int mode)
+{
+	outb((channel << 6) | 0x30 | (mode & 0x0F), base + I8254_CTRL);
+}
+
+static void i8254_set_mode(struct i8254_struct *st, int channel,
+	unsigned int mode)
+{
+	int chan = st->logic2phys[channel];
+
+	st->mode[chan] = mode;
+	return i8254_set_mode_low(st->iobase, chan, mode);
+}
+
+static unsigned int i8254_read_status_low(unsigned int base, int channel)
+{
+	outb(0xE0 | (2 << channel), base + I8254_CTRL);
+	return inb(base + channel);
+}
+
+static unsigned int i8254_read_status(struct i8254_struct *st, int channel)
+{
+	int chan = st->logic2phys[channel];
+
+	return i8254_read_status_low(st->iobase, chan);
+}
+
+static int das08_counter_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int chan = insn->chanspec;
+
+	//printk("Reading counter channel %d ",chan);
+	data[0] = i8254_read_channel(&devpriv->i8254, chan);
+	//printk("=> 0x%08X\n",data[0]);
+
+	return 1;
+}
+
+static int das08_counter_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int chan = insn->chanspec;
+
+	//printk("Writing counter channel %d with 0x%04X\n",chan,data[0]);
+	i8254_write_channel(&devpriv->i8254, chan, data[0]);
+
+	return 1;
+}
+
+static int das08_counter_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int chan = insn->chanspec;
+
+	if (insn->n != 2)
+		return -EINVAL;
+
+	switch (data[0]) {
+	case INSN_CONFIG_SET_COUNTER_MODE:
+		i8254_set_mode(&devpriv->i8254, chan, data[1]);
+		break;
+	case INSN_CONFIG_8254_READ_STATUS:
+		data[1] = i8254_read_status(&devpriv->i8254, chan);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 2;
+}
+
+static int das08_attach(comedi_device * dev, comedi_devconfig * it);
+
+static comedi_driver driver_das08 = {
+      driver_name: DRV_NAME,
+      module:THIS_MODULE,
+      attach:das08_attach,
+      detach:das08_common_detach,
+      board_name:&das08_boards[0].name,
+      num_names:sizeof(das08_boards) /
+		sizeof(struct das08_board_struct),
+      offset:sizeof(struct das08_board_struct),
+};
+
+int das08_common_attach(comedi_device * dev, unsigned long iobase)
+{
+	comedi_subdevice *s;
+	int ret;
+
+	// allocate ioports for non-pcmcia, non-pci boards
+	if ((thisboard->bustype != pcmcia) && (thisboard->bustype != pci)) {
+		printk(" iobase 0x%lx\n", iobase);
+		if (!request_region(iobase, thisboard->iosize, DRV_NAME)) {
+			printk(" I/O port conflict\n");
+			return -EIO;
+		}
+	}
+	dev->iobase = iobase;
+
+	dev->board_name = thisboard->name;
+
+	if ((ret = alloc_subdevices(dev, 6)) < 0)
+		return ret;
+
+	s = dev->subdevices + 0;
+	/* ai */
+	if (thisboard->ai) {
+		s->type = COMEDI_SUBD_AI;
+		/* XXX some boards actually have differential inputs instead of single ended.
+		 *  The driver does nothing with arefs though, so it's no big deal. */
+		s->subdev_flags = SDF_READABLE | SDF_GROUND;
+		s->n_chan = 8;
+		s->maxdata = (1 << thisboard->ai_nbits) - 1;
+		s->range_table = das08_ai_lranges[thisboard->ai_pg];
+		s->insn_read = thisboard->ai;
+		devpriv->pg_gainlist = das08_gainlists[thisboard->ai_pg];
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 1;
+	/* ao */
+	if (thisboard->ao) {
+		s->type = COMEDI_SUBD_AO;
+// XXX lacks read-back insn
+		s->subdev_flags = SDF_WRITABLE;
+		s->n_chan = 2;
+		s->maxdata = (1 << thisboard->ao_nbits) - 1;
+		s->range_table = &range_bipolar5;
+		s->insn_write = thisboard->ao;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 2;
+	/* di */
+	if (thisboard->di) {
+		s->type = COMEDI_SUBD_DI;
+		s->subdev_flags = SDF_READABLE;
+		s->n_chan = (thisboard->di == das08_di_rbits) ? 3 : 8;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = thisboard->di;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 3;
+	/* do */
+	if (thisboard->do_) {
+		s->type = COMEDI_SUBD_DO;
+		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+		s->n_chan = thisboard->do_nchan;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = thisboard->do_;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 4;
+	/* 8255 */
+	if (thisboard->i8255_offset != 0) {
+		subdev_8255_init(dev, s, NULL, (unsigned long)(dev->iobase +
+				thisboard->i8255_offset));
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 5;
+	/* 8254 */
+	if (thisboard->i8254_offset != 0) {
+		s->type = COMEDI_SUBD_COUNTER;
+		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+		s->n_chan = 3;
+		s->maxdata = 0xFFFF;
+		s->insn_read = das08_counter_read;
+		s->insn_write = das08_counter_write;
+		s->insn_config = das08_counter_config;
+		/* Set-up the 8254 structure */
+		devpriv->i8254.channels = 3;
+		devpriv->i8254.logic2phys[0] = 0;
+		devpriv->i8254.logic2phys[1] = 1;
+		devpriv->i8254.logic2phys[2] = 2;
+		devpriv->i8254.iobase = iobase + thisboard->i8254_offset;
+		devpriv->i8254.mode[0] =
+			devpriv->i8254.mode[1] =
+			devpriv->i8254.mode[2] = I8254_MODE0 | I8254_BINARY;
+		i8254_initialize(&devpriv->i8254);
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	return 0;
+}
+
+static int das08_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int ret;
+	unsigned long iobase;
+#ifdef CONFIG_COMEDI_PCI
+	unsigned long pci_iobase = 0;
+	struct pci_dev *pdev;
+#endif
+
+	if ((ret = alloc_private(dev, sizeof(struct das08_private_struct))) < 0)
+		return ret;
+
+	printk("comedi%d: das08: ", dev->minor);
+	// deal with a pci board
+	if (thisboard->bustype == pci) {
+#ifdef CONFIG_COMEDI_PCI
+		if (it->options[0] || it->options[1]) {
+			printk("bus %i slot %i ",
+				it->options[0], it->options[1]);
+		}
+		printk("\n");
+		// find card
+		for (pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
+			pdev != NULL;
+			pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) {
+			if (pdev->vendor == PCI_VENDOR_ID_COMPUTERBOARDS
+				&& pdev->device == PCI_DEVICE_ID_PCIDAS08) {
+				if (it->options[0] || it->options[1]) {
+					if (pdev->bus->number == it->options[0]
+						&& PCI_SLOT(pdev->devfn) ==
+						it->options[1]) {
+						break;
+					}
+				} else {
+					break;
+				}
+			}
+		}
+		if (!pdev) {
+			printk("No pci das08 cards found\n");
+			return -EIO;
+		}
+		devpriv->pdev = pdev;
+		// enable PCI device and reserve I/O spaces
+		if (comedi_pci_enable(pdev, DRV_NAME)) {
+			printk(" Error enabling PCI device and requesting regions\n");
+			return -EIO;
+		}
+		// read base addresses
+		pci_iobase = pci_resource_start(pdev, 1);
+		iobase = pci_resource_start(pdev, 2);
+		printk("pcibase 0x%lx  iobase 0x%lx\n", pci_iobase, iobase);
+		devpriv->pci_iobase = pci_iobase;
+#if 0
+/* We could enable to pci-das08's interrupt here to make it possible
+ * to do timed input in this driver, but there is little point since
+ * conversions would have to be started by the interrupt handler
+ * so you might as well use comedi_rt_timer to emulate commands
+ */
+		/* set source of interrupt trigger to counter2 output */
+		outb(CNTRL_INTR | CNTRL_DIR, pci_iobase + CNTRL);
+		/* Enable local interrupt 1 and pci interrupt */
+		outw(INTR1_ENABLE | PCI_INTR_ENABLE, pci_iobase + INTCSR);
+#endif
+#else	/* CONFIG_COMEDI_PCI */
+		printk("this driver has not been built with PCI support.\n");
+		return -EINVAL;
+#endif	/* CONFIG_COMEDI_PCI */
+	} else {
+		iobase = it->options[0];
+	}
+	printk("\n");
+
+	return das08_common_attach(dev, iobase);
+}
+
+int das08_common_detach(comedi_device * dev)
+{
+	printk(KERN_INFO "comedi%d: das08: remove\n", dev->minor);
+
+	if (dev->subdevices)
+		subdev_8255_cleanup(dev, dev->subdevices + 4);
+
+	// deallocate ioports for non-pcmcia, non-pci boards
+	if ((thisboard->bustype != pcmcia) && (thisboard->bustype != pci)) {
+		if (dev->iobase)
+			release_region(dev->iobase, thisboard->iosize);
+	}
+
+#ifdef CONFIG_COMEDI_PCI
+	if (devpriv) {
+		if (devpriv->pdev) {
+			if (devpriv->pci_iobase) {
+				comedi_pci_disable(devpriv->pdev);
+			}
+			pci_dev_put(devpriv->pdev);
+		}
+	}
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_COMEDI_PCI
+COMEDI_PCI_INITCLEANUP(driver_das08, das08_pci_table);
+#else
+COMEDI_INITCLEANUP(driver_das08);
+#endif
+
+EXPORT_SYMBOL_GPL(das08_common_attach);
+EXPORT_SYMBOL_GPL(das08_common_detach);
+#ifdef CONFIG_COMEDI_PCMCIA
+EXPORT_SYMBOL_GPL(das08_cs_boards);
+#endif
--- /dev/null
+++ b/drivers/staging/comedi/drivers/das08_cs.c
@@ -0,0 +1,489 @@
+/*
+    comedi/drivers/das08_cs.c
+    DAS08 driver
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+    Copyright (C) 2001,2002,2003 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*****************************************************************
+
+*/
+/*
+Driver: das08_cs
+Description: DAS-08 PCMCIA boards
+Author: Warren Jasper, ds, Frank Hess
+Devices: [ComputerBoards] PCM-DAS08 (pcm-das08)
+Status: works
+
+This is the PCMCIA-specific support split off from the
+das08 driver.
+
+Options (for pcm-das08):
+        NONE
+
+Command support does not exist, but could be added for this board.
+*/
+
+#include "../comedidev.h"
+
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/version.h>
+
+#include "das08.h"
+
+// pcmcia includes
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+
+static struct pcmcia_device *cur_dev = NULL;
+
+#define thisboard ((const struct das08_board_struct *)dev->board_ptr)
+
+static int das08_cs_attach(comedi_device * dev, comedi_devconfig * it);
+
+static comedi_driver driver_das08_cs = {
+      driver_name:"das08_cs",
+      module:THIS_MODULE,
+      attach:das08_cs_attach,
+      detach:das08_common_detach,
+      board_name:&das08_cs_boards[0].name,
+      num_names:sizeof(das08_cs_boards) /
+		sizeof(struct das08_board_struct),
+      offset:sizeof(struct das08_board_struct),
+};
+
+static int das08_cs_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int ret;
+	unsigned long iobase;
+	struct pcmcia_device *link = cur_dev;	// XXX hack
+
+	if ((ret = alloc_private(dev, sizeof(struct das08_private_struct))) < 0)
+		return ret;
+
+	printk("comedi%d: das08_cs: ", dev->minor);
+	// deal with a pci board
+
+	if (thisboard->bustype == pcmcia) {
+		if (link == NULL) {
+			printk(" no pcmcia cards found\n");
+			return -EIO;
+		}
+		iobase = link->io.BasePort1;
+	} else {
+		printk(" bug! board does not have PCMCIA bustype\n");
+		return -EINVAL;
+	}
+
+	printk("\n");
+
+	return das08_common_attach(dev, iobase);
+}
+
+/*======================================================================
+
+    The following pcmcia code for the pcm-das08 is adapted from the
+    dummy_cs.c driver of the Linux PCMCIA Card Services package.
+
+    The initial developer of the original code is David A. Hinds
+    <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
+    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
+
+======================================================================*/
+
+/*
+   All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If
+   you do not define PCMCIA_DEBUG at all, all the debug code will be
+   left out.  If you compile with PCMCIA_DEBUG=0, the debug code will
+   be present but disabled -- but it can then be enabled for specific
+   modules at load time with a 'pc_debug=#' option to insmod.
+*/
+
+#ifdef PCMCIA_DEBUG
+static int pc_debug = PCMCIA_DEBUG;
+module_param(pc_debug, int, 0644);
+#define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args)
+static const char *version =
+	"das08.c pcmcia code (Frank Hess), modified from dummy_cs.c 1.31 2001/08/24 12:13:13 (David Hinds)";
+#else
+#define DEBUG(n, args...)
+#endif
+
+/*====================================================================*/
+static void das08_pcmcia_config(struct pcmcia_device *link);
+static void das08_pcmcia_release(struct pcmcia_device *link);
+static int das08_pcmcia_suspend(struct pcmcia_device *p_dev);
+static int das08_pcmcia_resume(struct pcmcia_device *p_dev);
+
+/*
+   The attach() and detach() entry points are used to create and destroy
+   "instances" of the driver, where each instance represents everything
+   needed to manage one actual PCMCIA card.
+*/
+
+static int das08_pcmcia_attach(struct pcmcia_device *);
+static void das08_pcmcia_detach(struct pcmcia_device *);
+
+/*
+   You'll also need to prototype all the functions that will actually
+   be used to talk to your device.  See 'memory_cs' for a good example
+   of a fully self-sufficient driver; the other drivers rely more or
+   less on other parts of the kernel.
+*/
+
+/*
+   The dev_info variable is the "key" that is used to match up this
+   device driver with appropriate cards, through the card configuration
+   database.
+*/
+
+static const dev_info_t dev_info = "pcm-das08";
+
+typedef struct local_info_t {
+	struct pcmcia_device *link;
+	dev_node_t node;
+	int stop;
+	struct bus_operations *bus;
+} local_info_t;
+
+/*======================================================================
+
+    das08_pcmcia_attach() creates an "instance" of the driver, allocating
+    local data structures for one device.  The device is registered
+    with Card Services.
+
+    The dev_link structure is initialized, but we don't actually
+    configure the card at this point -- we wait until we receive a
+    card insertion event.
+
+======================================================================*/
+
+static int das08_pcmcia_attach(struct pcmcia_device *link)
+{
+	local_info_t *local;
+
+	DEBUG(0, "das08_pcmcia_attach()\n");
+
+	/* Allocate space for private device-specific data */
+	local = kzalloc(sizeof(local_info_t), GFP_KERNEL);
+	if (!local)
+		return -ENOMEM;
+	local->link = link;
+	link->priv = local;
+
+	/* Interrupt setup */
+	link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
+	link->irq.IRQInfo1 = IRQ_LEVEL_ID;
+	link->irq.Handler = NULL;
+
+	/*
+	   General socket configuration defaults can go here.  In this
+	   client, we assume very little, and rely on the CIS for almost
+	   everything.  In most clients, many details (i.e., number, sizes,
+	   and attributes of IO windows) are fixed by the nature of the
+	   device, and can be hard-wired here.
+	 */
+	link->conf.Attributes = 0;
+	link->conf.IntType = INT_MEMORY_AND_IO;
+
+	cur_dev = link;
+
+	das08_pcmcia_config(link);
+
+	return 0;
+}				/* das08_pcmcia_attach */
+
+/*======================================================================
+
+    This deletes a driver "instance".  The device is de-registered
+    with Card Services.  If it has been released, all local data
+    structures are freed.  Otherwise, the structures will be freed
+    when the device is released.
+
+======================================================================*/
+
+static void das08_pcmcia_detach(struct pcmcia_device *link)
+{
+
+	DEBUG(0, "das08_pcmcia_detach(0x%p)\n", link);
+
+	if (link->dev_node) {
+		((local_info_t *) link->priv)->stop = 1;
+		das08_pcmcia_release(link);
+	}
+
+	/* This points to the parent local_info_t struct */
+	if (link->priv)
+		kfree(link->priv);
+
+}				/* das08_pcmcia_detach */
+
+/*======================================================================
+
+    das08_pcmcia_config() is scheduled to run after a CARD_INSERTION event
+    is received, to configure the PCMCIA socket, and to make the
+    device available to the system.
+
+======================================================================*/
+
+static void das08_pcmcia_config(struct pcmcia_device *link)
+{
+	local_info_t *dev = link->priv;
+	tuple_t tuple;
+	cisparse_t parse;
+	int last_fn, last_ret;
+	u_char buf[64];
+	cistpl_cftable_entry_t dflt = { 0 };
+
+	DEBUG(0, "das08_pcmcia_config(0x%p)\n", link);
+
+	/*
+	   This reads the card's CONFIG tuple to find its configuration
+	   registers.
+	 */
+	tuple.DesiredTuple = CISTPL_CONFIG;
+	tuple.Attributes = 0;
+	tuple.TupleData = buf;
+	tuple.TupleDataMax = sizeof(buf);
+	tuple.TupleOffset = 0;
+	last_fn = GetFirstTuple;
+	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0)
+		goto cs_failed;
+	last_fn = GetTupleData;
+	if ((last_ret = pcmcia_get_tuple_data(link, &tuple)) != 0)
+		goto cs_failed;
+	last_fn = ParseTuple;
+	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+		goto cs_failed;
+	link->conf.ConfigBase = parse.config.base;
+	link->conf.Present = parse.config.rmask[0];
+
+	/*
+	   In this loop, we scan the CIS for configuration table entries,
+	   each of which describes a valid card configuration, including
+	   voltage, IO window, memory window, and interrupt settings.
+
+	   We make no assumptions about the card to be configured: we use
+	   just the information available in the CIS.  In an ideal world,
+	   this would work for any PCMCIA card, but it requires a complete
+	   and accurate CIS.  In practice, a driver usually "knows" most of
+	   these things without consulting the CIS, and most client drivers
+	   will only use the CIS to fill in implementation-defined details.
+	 */
+	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
+	last_fn = GetFirstTuple;
+	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0)
+		goto cs_failed;
+	while (1) {
+		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
+		if ((last_ret = pcmcia_get_tuple_data(link, &tuple)) != 0)
+			goto next_entry;
+		if ((last_ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+			goto next_entry;
+
+		if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
+			dflt = *cfg;
+		if (cfg->index == 0)
+			goto next_entry;
+		link->conf.ConfigIndex = cfg->index;
+
+		/* Does this card need audio output? */
+/*	if (cfg->flags & CISTPL_CFTABLE_AUDIO) {
+		link->conf.Attributes |= CONF_ENABLE_SPKR;
+		link->conf.Status = CCSR_AUDIO_ENA;
+	}
+*/
+		/* Do we need to allocate an interrupt? */
+		if (cfg->irq.IRQInfo1 || dflt.irq.IRQInfo1)
+			link->conf.Attributes |= CONF_ENABLE_IRQ;
+
+		/* IO window settings */
+		link->io.NumPorts1 = link->io.NumPorts2 = 0;
+		if ((cfg->io.nwin > 0) || (dflt.io.nwin > 0)) {
+			cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt.io;
+			link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+			if (!(io->flags & CISTPL_IO_8BIT))
+				link->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+			if (!(io->flags & CISTPL_IO_16BIT))
+				link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+			link->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
+			link->io.BasePort1 = io->win[0].base;
+			link->io.NumPorts1 = io->win[0].len;
+			if (io->nwin > 1) {
+				link->io.Attributes2 = link->io.Attributes1;
+				link->io.BasePort2 = io->win[1].base;
+				link->io.NumPorts2 = io->win[1].len;
+			}
+			/* This reserves IO space but doesn't actually enable it */
+			if (pcmcia_request_io(link, &link->io) != 0)
+				goto next_entry;
+		}
+
+		/* If we got this far, we're cool! */
+		break;
+
+	      next_entry:
+		last_fn = GetNextTuple;
+		if ((last_ret = pcmcia_get_next_tuple(link, &tuple)) != 0)
+			goto cs_failed;
+	}
+
+	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
+		last_fn = RequestIRQ;
+		if ((last_ret = pcmcia_request_irq(link, &link->irq)) != 0)
+			goto cs_failed;
+	}
+
+	/*
+	   This actually configures the PCMCIA socket -- setting up
+	   the I/O windows and the interrupt mapping, and putting the
+	   card and host interface into "Memory and IO" mode.
+	 */
+	last_fn = RequestConfiguration;
+	if ((last_ret = pcmcia_request_configuration(link, &link->conf)) != 0)
+		goto cs_failed;
+
+	/*
+	   At this point, the dev_node_t structure(s) need to be
+	   initialized and arranged in a linked list at link->dev.
+	 */
+	sprintf(dev->node.dev_name, "pcm-das08");
+	dev->node.major = dev->node.minor = 0;
+	link->dev_node = &dev->node;
+
+	/* Finally, report what we've done */
+	printk(KERN_INFO "%s: index 0x%02x",
+		dev->node.dev_name, link->conf.ConfigIndex);
+	if (link->conf.Attributes & CONF_ENABLE_IRQ)
+		printk(", irq %u", link->irq.AssignedIRQ);
+	if (link->io.NumPorts1)
+		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
+			link->io.BasePort1 + link->io.NumPorts1 - 1);
+	if (link->io.NumPorts2)
+		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
+			link->io.BasePort2 + link->io.NumPorts2 - 1);
+	printk("\n");
+
+	return;
+
+      cs_failed:
+	cs_error(link, last_fn, last_ret);
+	das08_pcmcia_release(link);
+
+}				/* das08_pcmcia_config */
+
+/*======================================================================
+
+    After a card is removed, das08_pcmcia_release() will unregister the
+    device, and release the PCMCIA configuration.  If the device is
+    still open, this will be postponed until it is closed.
+
+======================================================================*/
+
+static void das08_pcmcia_release(struct pcmcia_device *link)
+{
+	DEBUG(0, "das08_pcmcia_release(0x%p)\n", link);
+	pcmcia_disable_device(link);
+}				/* das08_pcmcia_release */
+
+/*======================================================================
+
+    The card status event handler.  Mostly, this schedules other
+    stuff to run after an event is received.
+
+    When a CARD_REMOVAL event is received, we immediately set a
+    private flag to block future accesses to this device.  All the
+    functions that actually access the device should check this flag
+    to make sure the card is still present.
+
+======================================================================*/
+
+static int das08_pcmcia_suspend(struct pcmcia_device *link)
+{
+	local_info_t *local = link->priv;
+	/* Mark the device as stopped, to block IO until later */
+	local->stop = 1;
+
+	return 0;
+}				/* das08_pcmcia_suspend */
+
+static int das08_pcmcia_resume(struct pcmcia_device *link)
+{
+	local_info_t *local = link->priv;
+
+	local->stop = 0;
+	return 0;
+}				/* das08_pcmcia_resume */
+
+/*====================================================================*/
+
+static struct pcmcia_device_id das08_cs_id_table[] = {
+	PCMCIA_DEVICE_MANF_CARD(0x01c5, 0x4001),
+	PCMCIA_DEVICE_NULL
+};
+
+MODULE_DEVICE_TABLE(pcmcia, das08_cs_id_table);
+
+struct pcmcia_driver das08_cs_driver = {
+	.probe = das08_pcmcia_attach,
+	.remove = das08_pcmcia_detach,
+	.suspend = das08_pcmcia_suspend,
+	.resume = das08_pcmcia_resume,
+	.id_table = das08_cs_id_table,
+	.owner = THIS_MODULE,
+	.drv = {
+			.name = dev_info,
+		},
+};
+
+static int __init init_das08_pcmcia_cs(void)
+{
+	DEBUG(0, "%s\n", version);
+	pcmcia_register_driver(&das08_cs_driver);
+	return 0;
+}
+
+static void __exit exit_das08_pcmcia_cs(void)
+{
+	DEBUG(0, "das08_pcmcia_cs: unloading\n");
+	pcmcia_unregister_driver(&das08_cs_driver);
+}
+
+static int __init das08_cs_init_module(void)
+{
+	int ret;
+
+	ret = init_das08_pcmcia_cs();
+	if (ret < 0)
+		return ret;
+
+	return comedi_driver_register(&driver_das08_cs);
+}
+
+static void __exit das08_cs_exit_module(void)
+{
+	exit_das08_pcmcia_cs();
+	comedi_driver_unregister(&driver_das08_cs);
+}
+
+MODULE_LICENSE("GPL");
+module_init(das08_cs_init_module);
+module_exit(das08_cs_exit_module);
--- /dev/null
+++ b/drivers/staging/comedi/drivers/das08.h
@@ -0,0 +1,78 @@
+/*
+    das08.h
+
+    Header for das08.c and das08_cs.c
+
+    Copyright (C) 2003 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#ifndef _DAS08_H
+#define _DAS08_H
+
+enum das08_bustype { isa, pci, pcmcia, pc104 };
+// different ways ai data is encoded in first two registers
+enum das08_ai_encoding { das08_encode12, das08_encode16, das08_pcm_encode12 };
+enum das08_lrange { das08_pg_none, das08_bipolar5, das08_pgh, das08_pgl,
+		das08_pgm };
+
+typedef struct das08_board_struct {
+	const char *name;
+	unsigned int id;	// id for pci/pcmcia boards
+	enum das08_bustype bustype;
+	void *ai;
+	unsigned int ai_nbits;
+	enum das08_lrange ai_pg;
+	enum das08_ai_encoding ai_encoding;
+	void *ao;
+	unsigned int ao_nbits;
+	void *di;
+	void *do_;
+	unsigned int do_nchan;
+	unsigned int i8255_offset;
+	unsigned int i8254_offset;
+	unsigned int iosize;	// number of ioports used
+} das08_board;
+
+struct i8254_struct {
+	int channels;		// available channels. Some could be used internally.
+	int logic2phys[3];	// to know which physical channel is.
+	int mode[3];		// the index is the real counter.
+	unsigned int iobase;
+};
+
+#define I8254_CNT0 0
+#define I8254_CNT1 1
+#define I8254_CNT2 2
+#define I8254_CTRL 3
+
+struct das08_private_struct {
+	unsigned int do_mux_bits;	// bits for do/mux register on boards without seperate do register
+	unsigned int do_bits;	// bits for do register on boards with register dedicated to digital out only
+	const unsigned int *pg_gainlist;
+	struct pci_dev *pdev;	// struct for pci-das08
+	unsigned int pci_iobase;	// additional base address for pci-das08
+	struct i8254_struct i8254;
+};
+
+#define NUM_DAS08_CS_BOARDS 2
+extern struct das08_board_struct das08_cs_boards[NUM_DAS08_CS_BOARDS];
+
+int das08_common_attach(comedi_device * dev, unsigned long iobase);
+int das08_common_detach(comedi_device * dev);
+
+#endif /* _DAS08_H */
