From bzolnier@gmail.com  Thu Jul  2 12:29:06 2009
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Sat, 13 Jun 2009 18:31:54 +0200
Subject: Staging: rtl8187se/ieee80211: remove dead _RTL8187_EXT_PATCH_ code
To: Greg KH <gregkh@suse.de>
Cc: linux-kernel@vger.kernel.org
Message-ID: <200906131831.55186.bzolnier@gmail.com>
Content-Disposition: inline


Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rtl8187se/ieee80211/ieee80211_rx.c      |  157 ----
 drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c |  540 ----------------
 drivers/staging/rtl8187se/ieee80211/ieee80211_tx.c      |  229 ------
 3 files changed, 926 deletions(-)

--- a/drivers/staging/rtl8187se/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8187se/ieee80211/ieee80211_rx.c
@@ -109,13 +109,6 @@ ieee80211_frag_cache_get(struct ieee8021
 	struct ieee80211_hdr_QOS *hdr_4addr_QoS;
 	u8 tid;
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(ieee->iw_mode == ieee->iw_ext_mode)
-	{
-		tid = (hdr->addr2[ETH_ALEN-2] ^ hdr->addr2[ETH_ALEN-1]) & IEEE80211_QOS_TID;
-	}
-	else
-#endif
 	if (((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {
 	  hdr_4addr_QoS = (struct ieee80211_hdr_QOS *)hdr;
 	  tid = le16_to_cpu(hdr_4addr_QoS->QOS_ctl) & IEEE80211_QOS_TID;
@@ -183,13 +176,6 @@ static int ieee80211_frag_cache_invalida
 	struct ieee80211_hdr_QOS *hdr_4addr_QoS;
 	u8 tid;
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(ieee->iw_mode == ieee->iw_ext_mode)
-	{
-		tid = (hdr->addr2[ETH_ALEN-2] ^ hdr->addr2[ETH_ALEN-1]) & IEEE80211_QOS_TID;
-	}
-	else
-#endif
 	if(((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {
 	  hdr_4addr_QoS = (struct ieee80211_hdr_QOS *)hdr;
 	  tid = le16_to_cpu(hdr_4addr_QoS->QOS_ctl) & IEEE80211_QOS_TID;
@@ -364,13 +350,6 @@ ieee80211_rx_frame_decrypt(struct ieee80
 		return 0;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && (ieee->ext_patch_ieee80211_rx_frame_get_hdrlen))
-	{
-		hdrlen = ieee->ext_patch_ieee80211_rx_frame_get_hdrlen(ieee, skb);
-	}
-	else
-#endif
 	hdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
 
 #ifdef CONFIG_IEEE80211_CRYPT_TKIP
@@ -416,13 +395,6 @@ ieee80211_rx_frame_decrypt_msdu(struct i
 		return 0;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && (ieee->ext_patch_ieee80211_rx_frame_get_hdrlen))
-	{
-		hdrlen = ieee->ext_patch_ieee80211_rx_frame_get_hdrlen(ieee, skb);
-	}
-	else
-#endif
 	hdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
 
 	atomic_inc(&crypt->refcnt);
@@ -454,13 +426,6 @@ static int is_duplicate_packet(struct ie
 	struct ieee80211_hdr_QOS *hdr_4addr_QoS;
 	u8 tid;
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(ieee->iw_mode == ieee->iw_ext_mode)
-	{
-		tid = (header->addr2[ETH_ALEN-2] ^ header->addr2[ETH_ALEN-1]) & IEEE80211_QOS_TID;
-	}
-	else
-#endif
 	//TO2DS and QoS
 	if(((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {
 	  hdr_4addr_QoS = (struct ieee80211_hdr_QOS *)header;
@@ -515,16 +480,6 @@ static int is_duplicate_packet(struct ie
 
 		break;
 	default:
-#ifdef _RTL8187_EXT_PATCH_
-		if(ieee->iw_mode == ieee->iw_ext_mode)
-		{
-			last_seq = &ieee->last_rxseq_num[tid];
-			last_frag = &ieee->last_rxfrag_num[tid];
-			last_time = &ieee->last_packet_time[tid];
-			break;
-		}
-		else
-#endif
 		return 0;
 	}
 
@@ -589,11 +544,6 @@ int ieee80211_rx(struct ieee80211_device
 	struct ieee80211_crypt_data *crypt = NULL;
 	int keyidx = 0;
 
-	//Added for mesh by Lawrence.
-#ifdef _RTL8187_EXT_PATCH_
-	u8 status;
-	u32 flags;
-#endif
 	// cheat the the hdr type
 	hdr = (struct ieee80211_hdr *)skb->data;
 	stats = &ieee->stats;
@@ -628,15 +578,6 @@ int ieee80211_rx(struct ieee80211_device
 	}
 //YJ,add,080828,for keep alive,end
 
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && (ieee->ext_patch_ieee80211_rx_frame_get_hdrlen))
-	{
-		hdrlen = ieee->ext_patch_ieee80211_rx_frame_get_hdrlen(ieee, skb);
-		if(skb->len < hdrlen)
-			goto rx_dropped;
-	}
-	else
-#endif
 	hdrlen = ieee80211_get_hdrlen(fc);
 
 #ifdef NOT_YET
@@ -705,11 +646,6 @@ int ieee80211_rx(struct ieee80211_device
 	if (skb->len < IEEE80211_DATA_HDR3_LEN)
 		goto rx_dropped;
 
-#ifdef _RTL8187_EXT_PATCH_
-	if( ieee->iw_mode == ieee->iw_ext_mode && ieee->ext_patch_ieee80211_rx_mgt_update_expire )
-		ieee->ext_patch_ieee80211_rx_mgt_update_expire( ieee, skb );
-#endif
-
 	// if QoS enabled, should check the sequence for each of the AC
 	if (is_duplicate_packet(ieee, hdr))
 		goto rx_dropped;
@@ -737,15 +673,6 @@ int ieee80211_rx(struct ieee80211_device
 		else
 			goto rx_exit;
 	}
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_rx_on_rx)
-	{
-		if(ieee->ext_patch_ieee80211_rx_on_rx(ieee, skb, rx_stats, type, stype)==0)
-		{
-			goto rx_exit;
-		}
-	}
-#endif
 
 	/* Data frame - extract src/dst addresses */
 	switch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {
@@ -814,14 +741,6 @@ int ieee80211_rx(struct ieee80211_device
 	}
 #endif
 
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_rx_is_valid_framectl)
-	{
-		if(ieee->ext_patch_ieee80211_rx_is_valid_framectl(ieee, fc, type, stype)==0)
-			goto rx_dropped;
-	}
-	else
-#endif
 	/* Nullfunc frames may have PS-bit set, so they must be passed to
 	 * hostap_handle_sta_rx() before being dropped here. */
 	if (stype != IEEE80211_STYPE_DATA &&
@@ -989,22 +908,6 @@ int ieee80211_rx(struct ieee80211_device
 	}
 #endif
 
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_rx_process_dataframe)
-	{
-	//Added for mesh rx interrupt.
-		//spin_lock_irqsave(&ieee->lock,flags);
-		status = ieee->ext_patch_ieee80211_rx_process_dataframe(ieee, skb, rx_stats);
-		//spin_unlock_irqrestore(&ieee->lock,flags);
-
-		if(status)
-//	if(ieee->ext_patch_ieee80211_rx_process_dataframe(ieee, skb, rx_stats))
-			goto rx_exit;
-		else
-			goto rx_dropped;
-	}
-#endif
-
 	/* convert hdr + possible LLC headers into Ethernet header */
 	if (skb->len - hdrlen >= 8 &&
 	    ((memcmp(payload, rfc1042_header, SNAP_SIZE) == 0 &&
@@ -1095,41 +998,6 @@ int ieee80211_rx(struct ieee80211_device
 	return 0;
 }
 
-#ifdef _RTL8187_EXT_PATCH_
-int ieee_ext_skb_p80211_to_ether(struct sk_buff *skb, int hdrlen, u8 *dst, u8 *src)
-{
-	u8 *payload;
-	u16 ethertype;
-
-	/* skb: hdr + (possible reassembled) full plaintext payload */
-	payload = skb->data + hdrlen;
-	ethertype = (payload[6] << 8) | payload[7];
-
-	/* convert hdr + possible LLC headers into Ethernet header */
-	if (skb->len - hdrlen >= 8 &&
-	    ((memcmp(payload, rfc1042_header, SNAP_SIZE) == 0 &&
-	      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
-	     memcmp(payload, bridge_tunnel_header, SNAP_SIZE) == 0)) {
-		/* remove RFC1042 or Bridge-Tunnel encapsulation and
-		 * replace EtherType */
-		skb_pull(skb, hdrlen + SNAP_SIZE);
-		memcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);
-		memcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);
-	} else {
-		u16 len;
-		/* Leave Ethernet header part of hdr and full payload */
-		skb_pull(skb, hdrlen);
-		len = htons(skb->len);
-		memcpy(skb_push(skb, 2), &len, 2);
-		memcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);
-		memcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);
-	}
-
-	return 1;
-}
-#endif // _RTL8187_EXT_PATCH_
-
-
 #define MGMT_FRAME_FIXED_PART_LENGTH		0x24
 
 static inline int ieee80211_is_ofdm_rate(u8 rate)
@@ -1708,13 +1576,6 @@ inline void ieee80211_process_probe_resp
 	u8 is_beacon = (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) == IEEE80211_STYPE_BEACON)? 1:0;  //YJ,add,080819,for hidden ap
 
 	memset(&network, 0, sizeof(struct ieee80211_network));
-//rz
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_process_probe_response_1) {
-		ieee->ext_patch_ieee80211_process_probe_response_1(ieee, beacon, stats);
-		return;
-	}
-#endif
 
 	IEEE80211_DEBUG_SCAN(
 		"'%s' (" MAC_FMT "): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",
@@ -1879,9 +1740,6 @@ inline void ieee80211_process_probe_resp
 				     "PROBE RESPONSE" : "BEACON");
 #endif
 
-#ifdef _RTL8187_EXT_PATCH_
-	network.ext_entry = target->ext_entry;
-#endif
 		memcpy(target, &network, sizeof(*target));
 		list_add_tail(&target->list, &ieee->network_list);
 		if(ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)
@@ -1939,18 +1797,6 @@ void ieee80211_rx_mgt(struct ieee80211_d
 		ieee80211_process_probe_response(
 			ieee, (struct ieee80211_probe_response *)header, stats);
 		break;
-//rz
-#ifdef _RTL8187_EXT_PATCH_
-	case IEEE80211_STYPE_PROBE_REQ:
-		IEEE80211_DEBUG_MGMT("received PROBE REQUEST (%d)\n",
-				     WLAN_FC_GET_STYPE(header->frame_ctl));
-		IEEE80211_DEBUG_SCAN("Probe request\n");
-		///
-		if( ieee->iw_mode == ieee->iw_ext_mode && ieee->ext_patch_ieee80211_rx_mgt_on_probe_req )
-			ieee->ext_patch_ieee80211_rx_mgt_on_probe_req( ieee, (struct ieee80211_probe_request *)header, stats);
-		break;
-#endif // _RTL8187_EXT_PATCH_
-
 	}
 }
 
@@ -1958,7 +1804,4 @@ void ieee80211_rx_mgt(struct ieee80211_d
 EXPORT_SYMBOL(ieee80211_rx_mgt);
 EXPORT_SYMBOL(ieee80211_rx);
 EXPORT_SYMBOL(ieee80211_network_init);
-#ifdef _RTL8187_EXT_PATCH_
-EXPORT_SYMBOL(ieee_ext_skb_p80211_to_ether);
-#endif
 #endif
--- a/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c
@@ -325,27 +325,12 @@ inline struct sk_buff *ieee80211_probe_r
 	struct sk_buff *skb;
 	struct ieee80211_probe_request *req;
 
-#ifdef _RTL8187_EXT_PATCH_
-	short extMore = 0;
-	if(ieee->ext_patch_ieee80211_probe_req_1)
-		extMore = ieee->ext_patch_ieee80211_probe_req_1(ieee);
-#endif
-
 	len = ieee->current_network.ssid_len;
 
 	rate_len = ieee80211_MFIE_rate_len(ieee);
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(!extMore)
-#endif
 	skb = dev_alloc_skb(sizeof(struct ieee80211_probe_request) +
 			    2 + len + rate_len);
-#ifdef _RTL8187_EXT_PATCH_
-	else
-		skb = dev_alloc_skb(sizeof(struct ieee80211_probe_request) +
-			    2 + len + rate_len+128); // MESHID + CAP
-#endif
-
 	if (!skb)
 		return NULL;
 
@@ -366,10 +351,6 @@ inline struct sk_buff *ieee80211_probe_r
 	ieee80211_MFIE_Brate(ieee,&tag);
 	ieee80211_MFIE_Grate(ieee,&tag);
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(extMore)
-		ieee->ext_patch_ieee80211_probe_req_2(ieee, skb, tag);
-#endif
 	return skb;
 }
 
@@ -436,79 +417,10 @@ void ieee80211_send_beacon_cb(unsigned l
 	spin_unlock_irqrestore(&ieee->beacon_lock, flags);
 }
 
-#ifdef _RTL8187_EXT_PATCH_
-
-inline struct sk_buff *ieee80211_probe_req_with_SSID(struct ieee80211_device *ieee, char *ssid, int len_ssid)
-{
-	unsigned int len,rate_len;
-	u8 *tag;
-	struct sk_buff *skb;
-	struct ieee80211_probe_request *req;
-
-#ifdef _RTL8187_EXT_PATCH_
-	short extMore = 0;
-	if(ieee->ext_patch_ieee80211_probe_req_1)
-		extMore = ieee->ext_patch_ieee80211_probe_req_1(ieee);
-#endif
-
-	len = len_ssid;
-
-	rate_len = ieee80211_MFIE_rate_len(ieee);
-
-#ifdef _RTL8187_EXT_PATCH_
-	if(!extMore)
-#endif
-	skb = dev_alloc_skb(sizeof(struct ieee80211_probe_request) +
-			    2 + len + rate_len);
-#ifdef _RTL8187_EXT_PATCH_
-	else
-		skb = dev_alloc_skb(sizeof(struct ieee80211_probe_request) +
-			    2 + len + rate_len+128); // MESHID + CAP
-#endif
-
-	if (!skb)
-		return NULL;
-
-	req = (struct ieee80211_probe_request *) skb_put(skb,sizeof(struct ieee80211_probe_request));
-	req->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);
-	req->header.duration_id = 0; //FIXME: is this OK ?
-
-	memset(req->header.addr1, 0xff, ETH_ALEN);
-	memcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memset(req->header.addr3, 0xff, ETH_ALEN);
-
-	tag = (u8 *) skb_put(skb,len+2+rate_len);
-
-	*tag++ = MFIE_TYPE_SSID;
-	*tag++ = len;
-	if(len)
-	{
-		memcpy(tag, ssid, len);
-		tag += len;
-	}
-
-	ieee80211_MFIE_Brate(ieee,&tag);
-	ieee80211_MFIE_Grate(ieee,&tag);
-
-#ifdef _RTL8187_EXT_PATCH_
-	if(extMore)
-		ieee->ext_patch_ieee80211_probe_req_2(ieee, skb, tag);
-#endif
-	return skb;
-}
-
-#endif // _RTL8187_EXT_PATCH_
-
-
 void ieee80211_send_probe(struct ieee80211_device *ieee)
 {
 	struct sk_buff *skb;
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(ieee->iw_mode == ieee->iw_ext_mode)
-		skb = ieee80211_probe_req_with_SSID(ieee, NULL, 0);
-	else
-#endif
 	skb = ieee80211_probe_req(ieee);
 	if (skb){
 		softmac_mgmt_xmit(skb, ieee);
@@ -1080,132 +992,6 @@ static struct sk_buff* ieee80211_probe_r
 	skb->dev = ieee->dev;
 	return skb;
 }
-#ifdef _RTL8187_EXT_PATCH_
-struct sk_buff* ieee80211_ext_probe_resp_by_net(struct ieee80211_device *ieee, u8 *dest, struct ieee80211_network *net)
-{
-	u8 *tag;
-	int beacon_size;
-	struct ieee80211_probe_response *beacon_buf;
-	struct sk_buff *skb;
-	int encrypt;
-	int atim_len,erp_len;
-	struct ieee80211_crypt_data* crypt;
-	u8 broadcast_addr[] = {0xff,0xff,0xff,0xff,0xff,0xff};
-	int wpa_ie_len = ieee->wpa_ie_len;
-	char *ssid = net->ssid;
-	int ssid_len = net->ssid_len;
-
-	int rate_len = ieee->current_network.rates_len+2;
-	int rate_ex_len = ieee->current_network.rates_ex_len;
-	if(rate_ex_len > 0) rate_ex_len+=2;
-
-	if( ieee->meshScanMode&4)
-		ieee->current_network.channel = ieee->ext_patch_ieee80211_ext_stop_scan_wq_set_channel(ieee);
-	if( ieee->meshScanMode&6)
-		queue_work(ieee->wq, &ieee->ext_stop_scan_wq);
-
-	if(ieee->current_network.capability & WLAN_CAPABILITY_IBSS) // use current_network here
-		atim_len = 4;
-	else
-		atim_len = 0;
-
-	if(ieee80211_is_54g(*net))
-		erp_len = 3;
-	else
-		erp_len = 0;
-
-	beacon_size = sizeof(struct ieee80211_probe_response)+
-		ssid_len
-		+3 //channel
-		+rate_len
-		+rate_ex_len
-		+atim_len
-		+erp_len;
-//b
-	skb = dev_alloc_skb(beacon_size+196);
-
-	if (!skb)
- 		return NULL;
-
-	beacon_buf = (struct ieee80211_probe_response*) skb_put(skb, beacon_size);
-
-	memcpy (beacon_buf->header.addr1, dest,ETH_ALEN);
-	memcpy (beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy (beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);
-
-	beacon_buf->header.duration_id = 0; //FIXME
-
-	beacon_buf->beacon_interval =
-		cpu_to_le16(ieee->current_network.beacon_interval);  // use current_network here
-	beacon_buf->capability =
-		cpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_IBSS);
-
-	if(ieee->short_slot && (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_SLOT))
-		cpu_to_le16((beacon_buf->capability |= WLAN_CAPABILITY_SHORT_SLOT));
-
-	crypt = ieee->crypt[ieee->tx_keyidx];
-
-	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
-		((0 == strcmp(crypt->ops->name, "WEP"))||wpa_ie_len);
-
-	if (encrypt)
-		beacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
-
-
-	beacon_buf->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_RESP);
-
-	beacon_buf->info_element.id = MFIE_TYPE_SSID;
-	beacon_buf->info_element.len = ssid_len;
-
-	tag = (u8*) beacon_buf->info_element.data;
-
-	// brocad cast / probe rsp
-	if(memcmp(dest, broadcast_addr, ETH_ALEN ))
-		memcpy(tag, ssid, ssid_len);
-	else
-		ssid_len=0;
-
-	tag += ssid_len;
-
-//get_bssrate_set(priv, _SUPPORTEDRATES_IE_, &pbssrate, &bssrate_len);
-//pbuf = set_ie(pbuf, _SUPPORTEDRATES_IE_, bssrate_len, pbssrate, &frlen);
-
-	*(tag++) = MFIE_TYPE_RATES;
-	*(tag++) = rate_len-2;
-	memcpy(tag,ieee->current_network.rates,rate_len-2);
-	tag+=rate_len-2;
-
-	*(tag++) = MFIE_TYPE_DS_SET;
-	*(tag++) = 1;
-	*(tag++) = ieee->current_network.channel;  // use current_network here
-
-
-	if(atim_len){
-		*(tag++) = MFIE_TYPE_IBSS_SET;
-		*(tag++) = 2;
-		*((u16*)(tag)) = cpu_to_le16(ieee->current_network.atim_window); // use current_network here
-		tag+=2;
-	}
-
-	if(erp_len){
-		*(tag++) = MFIE_TYPE_ERP;
-		*(tag++) = 1;
-		*(tag++) = 0;
-	}
-
-	if(rate_ex_len){
-		*(tag++) = MFIE_TYPE_RATES_EX;
-		*(tag++) = rate_ex_len-2;
-		memcpy(tag,ieee->current_network.rates_ex,rate_ex_len-2);
-		tag+=rate_ex_len-2;
-	}
-	if (wpa_ie_len)
-		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
-
-	skb->dev = ieee->dev;
-	return skb;
-}
-#endif // _RTL8187_EXT_PATCH_
 
 struct sk_buff* ieee80211_assoc_resp(struct ieee80211_device *ieee, u8 *dest)
 {
@@ -1278,12 +1064,7 @@ struct sk_buff* ieee80211_auth_resp(stru
 	auth->transaction = cpu_to_le16(2);
 	auth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(ieee->iw_mode == ieee->iw_ext_mode)
-		memcpy(auth->header.addr3, dest, ETH_ALEN);
-#else
 	memcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
-#endif
 	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(auth->header.addr1, dest, ETH_ALEN);
 	auth->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_AUTH);
@@ -1413,11 +1194,6 @@ inline struct sk_buff *ieee80211_associa
 		+ wmm_info_len;
 #endif
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(ieee->iw_mode == ieee->iw_ext_mode)
-		skb = dev_alloc_skb(len+256); // stanley
-	else
-#endif
 	skb = dev_alloc_skb(len);
 
 	if (!skb)
@@ -1443,11 +1219,6 @@ inline struct sk_buff *ieee80211_associa
 	if(ieee->short_slot)
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);
 
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_association_req_1)
-		ieee->ext_patch_ieee80211_association_req_1(hdr);
-#endif
-
 	hdr->listen_interval = 0xa; //FIXME
 
 	hdr->info_element.id = MFIE_TYPE_SSID;
@@ -1674,11 +1445,6 @@ inline struct sk_buff *ieee80211_associa
         }
 #endif
 
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_association_req_2)
-		ieee->ext_patch_ieee80211_association_req_2(ieee, beacon, skb);
-#endif
-
 	return skb;
 }
 
@@ -1725,13 +1491,6 @@ void ieee80211_associate_step1(struct ie
 	IEEE80211_DEBUG_MGMT("Stopping scan\n");
 	ieee->softmac_stats.tx_auth_rq++;
 	skb=ieee80211_authentication_req(beacon, ieee, 0);
-#ifdef _RTL8187_EXT_PATCH_
-	if(ieee->iw_mode == ieee->iw_ext_mode )	{
-		if(skb)
-			softmac_mgmt_xmit(skb, ieee);
-		return;
-	}else
-#endif
 	if (!skb){
 
 		ieee80211_associate_abort(ieee);
@@ -1788,105 +1547,6 @@ void ieee80211_auth_challenge(struct iee
 	kfree(challenge);
 }
 
-#ifdef _RTL8187_EXT_PATCH_
-
-// based on ieee80211_assoc_resp
-struct sk_buff* ieee80211_assoc_resp_by_net(struct ieee80211_device *ieee, u8 *dest, unsigned short status, struct ieee80211_network *pstat, int pkt_type)
-{
-	struct sk_buff *skb;
-	u8* tag;
-
-	struct ieee80211_crypt_data* crypt;
-	struct ieee80211_assoc_response_frame *assoc;
-	short encrypt;
-
-	unsigned int rate_len = ieee80211_MFIE_rate_len(ieee);
-	int len = sizeof(struct ieee80211_assoc_response_frame) + rate_len;
-
-	if(ieee->iw_mode == ieee->iw_ext_mode)
-		skb = dev_alloc_skb(len+256); // stanley
-	else
-		skb = dev_alloc_skb(len);
-
-	if (!skb)
-		return NULL;
-
-	assoc = (struct ieee80211_assoc_response_frame *)
-		skb_put(skb,sizeof(struct ieee80211_assoc_response_frame));
-
-	assoc->header.frame_ctl = cpu_to_le16(pkt_type);
-
-	memcpy(assoc->header.addr1, dest,ETH_ALEN);
-	memcpy(assoc->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
-	memcpy(assoc->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	assoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?
-		WLAN_CAPABILITY_BSS : WLAN_CAPABILITY_IBSS);
-
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_assoc_resp_by_net_1)
-		ieee->ext_patch_ieee80211_assoc_resp_by_net_1(assoc);
-
-	if(ieee->short_slot)
-		assoc->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);
-
-	if (ieee->host_encrypt)
-		crypt = ieee->crypt[ieee->tx_keyidx];
-	else crypt = NULL;
-
-	encrypt = ( crypt && crypt->ops);
-
-	if (encrypt)
-		assoc->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
-
-	assoc->status = 0;
-	assoc->aid = cpu_to_le16(ieee->assoc_id);
-	if (ieee->assoc_id == 0x2007) ieee->assoc_id=0;
-	else ieee->assoc_id++;
-
-	assoc->info_element.id = 230; // Stanley, an unused id (just a hot fix)
-	assoc->info_element.len = 0;
-
-	tag = (u8*) skb_put(skb, rate_len);
-
-	ieee80211_MFIE_Brate(ieee, &tag);
-	ieee80211_MFIE_Grate(ieee, &tag);
-
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_assoc_resp_by_net_2)
-		ieee->ext_patch_ieee80211_assoc_resp_by_net_2(ieee, pstat, pkt_type, skb);
-
-	return skb;
-}
-
-// based on ieee80211_resp_to_assoc_rq
-void ieee80211_ext_issue_assoc_rsp(struct ieee80211_device *ieee, u8 *dest, unsigned short status, struct ieee80211_network *pstat, int pkt_type)
-{
-	struct sk_buff *buf = ieee80211_assoc_resp_by_net(ieee, dest, status, pstat, pkt_type);
-
-	if (buf)
-		softmac_mgmt_xmit(buf, ieee);
-}
-
-// based on ieee80211_associate_step2
-void ieee80211_ext_issue_assoc_req(struct ieee80211_device *ieee, struct ieee80211_network *pstat)
-{
-
-	struct sk_buff* skb;
-
-	// printk("@@@@@ ieee80211_ext_issue_assoc_req on channel: %d\n", ieee->current_network.channel);
-
-	ieee->softmac_stats.tx_ass_rq++;
-	skb=ieee80211_association_req(pstat, ieee);
-	if (skb)
-		softmac_mgmt_xmit(skb, ieee);
-}
-
-void ieee80211_ext_issue_disassoc(struct ieee80211_device *ieee, struct ieee80211_network *pstat, int reason, unsigned char extReason)
-{
-	// do nothing
-	// printk("@@@@@ ieee80211_ext_issue_disassoc\n");
-	return;
-}
-#endif // _RTL8187_EXT_PATCH_
-
 void ieee80211_associate_step2(struct ieee80211_device *ieee)
 {
 	struct sk_buff* skb;
@@ -1962,45 +1622,6 @@ void ieee80211_associate_procedure_wq(st
 
 	up(&ieee->wx_sem);
 }
-#ifdef _RTL8187_EXT_PATCH_
-// based on ieee80211_associate_procedure_wq
-
-void ieee80211_ext_stop_scan_wq(struct work_struct *work)
-{
-	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, ext_stop_scan_wq);
-
-	if (ieee->scanning == 0) {
-		if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_ext_stop_scan_wq_set_channel
-				&& ( ieee->current_network.channel == ieee->ext_patch_ieee80211_ext_stop_scan_wq_set_channel(ieee) ) )
-		return;
-	}
-
-	ieee->sync_scan_hurryup = 1;
-
-	down(&ieee->wx_sem);
-
-	// printk("@@@@@@@@@@ ieee80211_ext_stop_scan_wq\n");
-	if (ieee->data_hard_stop)
-		ieee->data_hard_stop(ieee->dev);
-
-	ieee80211_stop_scan(ieee);
-
-	// set channel
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_ext_stop_scan_wq_set_channel)
-		ieee->set_chan(ieee->dev, ieee->ext_patch_ieee80211_ext_stop_scan_wq_set_channel(ieee));
-	else
-		ieee->set_chan(ieee->dev, ieee->current_network.channel);
-	//
-	up(&ieee->wx_sem);
-}
-
-
-void ieee80211_ext_send_11s_beacon(struct ieee80211_device *ieee)
-{
-	queue_work(ieee->wq, &ieee->ext_send_beacon_wq);
-}
-
-#endif // _RTL8187_EXT_PATCH_
 
 inline void ieee80211_softmac_new_net(struct ieee80211_device *ieee, struct ieee80211_network *net)
 {
@@ -2584,12 +2205,6 @@ associate_complete:
 					ieee80211_associate_abort(ieee);
 				}
 			}
-#ifdef _RTL8187_EXT_PATCH_
-			else if ((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_rx_frame_softmac_on_assoc_rsp)
-			{
-					ieee->ext_patch_ieee80211_rx_frame_softmac_on_assoc_rsp(ieee, skb);
-			}
-#endif
 			break;
 
 		case IEEE80211_STYPE_ASSOC_REQ:
@@ -2599,21 +2214,10 @@ associate_complete:
 				ieee->iw_mode == IW_MODE_MASTER)
 
 				ieee80211_rx_assoc_rq(ieee, skb);
-#ifdef _RTL8187_EXT_PATCH_
-			else if ((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_rx_frame_softmac_on_assoc_req)
-			{
-					ieee->ext_patch_ieee80211_rx_frame_softmac_on_assoc_req(ieee, skb);
-			}
-#endif
 			break;
 
 		case IEEE80211_STYPE_AUTH:
 
-#ifdef _RTL8187_EXT_PATCH_
-printk("IEEE80211_STYPE_AUTH\n");
-			if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_rx_frame_softmac_on_auth)
-			if( ieee->ext_patch_ieee80211_rx_frame_softmac_on_auth(ieee, skb, rx_stats) );
-#endif
 			if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE){
 				if (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING &&
 				ieee->iw_mode == IW_MODE_INFRA){
@@ -2653,11 +2257,6 @@ printk("IEEE80211_STYPE_AUTH\n");
 
 		case IEEE80211_STYPE_DISASSOC:
 		case IEEE80211_STYPE_DEAUTH:
-#ifdef _RTL8187_EXT_PATCH_
-printk("IEEE80211_STYPE_DEAUTH\n");
-		if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_rx_frame_softmac_on_deauth)
-		if( ieee->ext_patch_ieee80211_rx_frame_softmac_on_deauth(ieee, skb, rx_stats) )	;
-#endif
 			/* FIXME for now repeat all the association procedure
 			* both for disassociation and deauthentication
 			*/
@@ -2710,9 +2309,6 @@ void ieee80211_softmac_xmit(struct ieee8
 
 	unsigned long flags;
 	int  i;
-#ifdef _RTL8187_EXT_PATCH_
-	int rate = ieee->rate;
-#endif
 
 	spin_lock_irqsave(&ieee->lock,flags);
 	#if 0
@@ -2739,12 +2335,6 @@ void ieee80211_softmac_xmit(struct ieee8
 	}
 	#endif
 
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_ieee80211_softmac_xmit_get_rate && txb->nr_frags)
-	{
-		rate = ieee->ext_patch_ieee80211_softmac_xmit_get_rate(ieee, txb->fragments[0]);
-	}
-#endif
 	/* called with 2nd parm 0, no tx mgmt lock required */
 	ieee80211_sta_wakeup(ieee,0);
 
@@ -2757,11 +2347,7 @@ void ieee80211_softmac_xmit(struct ieee8
 		}else{
 			ieee->softmac_data_hard_start_xmit(
 				txb->fragments[i],
-#ifdef _RTL8187_EXT_PATCH_
-				ieee->dev, rate);
-#else
 				ieee->dev,ieee->rate);
-#endif
 				//(i+1)<txb->nr_frags);
 			ieee->stats.tx_packets++;
 			ieee->stats.tx_bytes += txb->fragments[i]->len;
@@ -3154,16 +2740,7 @@ struct sk_buff *ieee80211_get_beacon_(st
 	struct sk_buff *skb = NULL;
 	struct ieee80211_probe_response *b;
 
-//rz
-#ifdef _RTL8187_EXT_PATCH_
-	if((ieee->iw_mode == ieee->iw_ext_mode) && ieee->ext_patch_get_beacon_get_probersp )
-		skb = ieee->ext_patch_get_beacon_get_probersp(ieee, broadcast_addr, &(ieee->current_network));
-	else
-		skb = ieee80211_probe_resp(ieee, broadcast_addr);
-#else
 	skb = ieee80211_probe_resp(ieee, broadcast_addr);
-#endif
-//
 	if (!skb)
 		return NULL;
 
@@ -3210,15 +2787,6 @@ void ieee80211_stop_protocol(struct ieee
 
 	ieee->proto_started = 0;
 
-#ifdef _RTL8187_EXT_PATCH_
-	if(ieee->ext_patch_ieee80211_stop_protocol)
-		ieee->ext_patch_ieee80211_stop_protocol(ieee);
-//if call queue_delayed_work,can call this,or do nothing..
-//edit by lawrence,20071118
-//	cancel_delayed_work(&ieee->ext_stop_scan_wq);
-//	cancel_delayed_work(&ieee->ext_send_beacon_wq);
-#endif // _RTL8187_EXT_PATCH_
-
 	ieee80211_stop_send_beacons(ieee);
 	if((ieee->iw_mode == IW_MODE_INFRA)&&(ieee->state == IEEE80211_LINKED)) {
 		SendDisassociation(ieee,NULL,WLAN_REASON_DISASSOC_STA_HAS_LEFT);
@@ -3303,91 +2871,8 @@ void ieee80211_start_protocol(struct iee
 			break;
 
 		default:
-#ifdef _RTL8187_EXT_PATCH_
-			if((ieee->iw_mode == ieee->iw_ext_mode) &&\
-			    ieee->ext_patch_ieee80211_start_protocol &&\
-                            ieee->ext_patch_ieee80211_start_protocol(ieee)) {
-				queue_work(ieee->wq, &ieee->ext_stop_scan_wq);
-
-				// By default, WMM function will be disabled in
-				// EXTENSION mode
-				ieee->current_network.QoS_Enable = 0;
-
-				if(ieee->modulation & IEEE80211_CCK_MODULATION){
-					ieee->current_network.rates_len = 4;
-					ieee->current_network.rates[0] = \
-                                              IEEE80211_BASIC_RATE_MASK | \
-					      IEEE80211_CCK_RATE_1MB;
-					ieee->current_network.rates[1] = \
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_CCK_RATE_2MB;
-					ieee->current_network.rates[2] = \
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_CCK_RATE_5MB;
-					ieee->current_network.rates[3] = \
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_CCK_RATE_11MB;
-				}else
-					ieee->current_network.rates_len = 0;
-
-				if(ieee->modulation & IEEE80211_OFDM_MODULATION){
-					ieee->current_network.rates_ex_len = 8;
-					ieee->current_network.rates_ex[0] = \
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_OFDM_RATE_6MB;
-					ieee->current_network.rates_ex[1] = \
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_OFDM_RATE_9MB;
-					ieee->current_network.rates_ex[2] = \
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_OFDM_RATE_12MB;
-					ieee->current_network.rates_ex[3] = \
-                                              IEEE80211_BASIC_RATE_MASK | \
-                                              IEEE80211_OFDM_RATE_18MB;
-					ieee->current_network.rates_ex[4] =\
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_OFDM_RATE_24MB;
-					ieee->current_network.rates_ex[5] =\
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_OFDM_RATE_36MB;
-					ieee->current_network.rates_ex[6] = \
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_OFDM_RATE_48MB;
-					ieee->current_network.rates_ex[7] =\
-                                              IEEE80211_BASIC_RATE_MASK |\
-                                              IEEE80211_OFDM_RATE_54MB;
-					ieee->rate = 540;
-				}else{
-					ieee->current_network.rates_ex_len = 0;
-					ieee->rate = 110;
-				}
-
-				/*
-				   spin_lock_irqsave(&ieee->lock, flags);
-				   if (ieee->state == IEEE80211_NOLINK)
-				   ieee80211_start_scan(ieee);
-				// ieee->set_chan(ieee->dev, 8);
-
-				spin_unlock_irqrestore(&ieee->lock, flags);
-				*/
-				memcpy(ieee->current_network.bssid, ieee->dev->dev_addr,\
-				      	 ETH_ALEN);
-				ieee->link_change(ieee->dev);
-				notify_wx_assoc_event(ieee);
-
-				if (ieee->data_hard_resume)
-					ieee->data_hard_resume(ieee->dev);
-
-				netif_carrier_on(ieee->dev);
-			} else {
-				ieee->iw_mode = IW_MODE_INFRA;
-				ieee80211_start_bss(ieee);
-			}
-#else
 			ieee->iw_mode = IW_MODE_INFRA;
 			ieee80211_start_bss(ieee);
-
-#endif
 			break;
 	}
 }
@@ -3431,9 +2916,6 @@ void ieee80211_softmac_init(struct ieee8
 	ieee->beinretry = false;
 	ieee->bHwRadioOff = false;
 //by amy
-#ifdef _RTL8187_EXT_PATCH_
-	ieee->iw_ext_mode = 999;
-#endif
 
 	init_mgmt_queue(ieee);
 #if 0
@@ -3463,12 +2945,6 @@ void ieee80211_softmac_init(struct ieee8
 	INIT_DELAYED_WORK(&ieee->associate_retry_wq,(void*) ieee80211_associate_retry_wq);
 	INIT_WORK(&ieee->wx_sync_scan_wq,(void*) ieee80211_wx_sync_scan_wq);
 //	INIT_WORK(&ieee->watch_dog_wq,(void*) ieee80211_watch_dog_wq);
-//added by lawrence,20071118
-#ifdef _RTL8187_EXT_PATCH_
-	INIT_WORK(&ieee->ext_stop_scan_wq,(void*) ieee80211_ext_stop_scan_wq);
-	//INIT_WORK(&ieee->ext_send_beacon_wq,(void*) ieee80211_beacons_start,ieee);
-	INIT_WORK(&ieee->ext_send_beacon_wq,(void*) ext_ieee80211_send_beacon_wq);
-#endif //_RTL8187_EXT_PATCH_
 
 	sema_init(&ieee->wx_sem, 1);
 	sema_init(&ieee->scan_sem, 1);
@@ -3495,10 +2971,6 @@ void ieee80211_softmac_free(struct ieee8
 	//add for RF power on power of by lizhaoming 080512
 	cancel_delayed_work(&ieee->GPIOChangeRFWorkItem);
 
-#ifdef _RTL8187_EXT_PATCH_
-	cancel_delayed_work(&ieee->ext_stop_scan_wq);
-	cancel_delayed_work(&ieee->ext_send_beacon_wq);
-#endif
 	destroy_workqueue(ieee->wq);
 #ifdef ENABLE_DOT11D
 	if(NULL != ieee->pDot11dInfo)
@@ -3933,17 +3405,5 @@ EXPORT_SYMBOL(SendDisassociation);
 EXPORT_SYMBOL(ieee80211_disassociate);
 EXPORT_SYMBOL(ieee80211_start_scan);
 EXPORT_SYMBOL(ieee80211_softmac_ips_scan_syncro);
-#ifdef _RTL8187_EXT_PATCH_
-EXPORT_SYMBOL(ieee80211_ext_issue_assoc_req);
-EXPORT_SYMBOL(ieee80211_ext_issue_disassoc);
-EXPORT_SYMBOL(ieee80211_ext_issue_assoc_rsp);
-EXPORT_SYMBOL(softmac_mgmt_xmit);
-EXPORT_SYMBOL(ieee80211_ext_probe_resp_by_net);
-EXPORT_SYMBOL(ieee80211_start_scan);
-EXPORT_SYMBOL(ieee80211_stop_scan);
-EXPORT_SYMBOL(ieee80211_ext_send_11s_beacon);
-EXPORT_SYMBOL(ieee80211_rx_auth_rq);
-EXPORT_SYMBOL(ieee80211_associate_step1);
-#endif // _RTL8187_EXT_PATCH_
 EXPORT_SYMBOL(ieee80211_sta_ps_send_null_frame);
 #endif
--- a/drivers/staging/rtl8187se/ieee80211/ieee80211_tx.c
+++ b/drivers/staging/rtl8187se/ieee80211/ieee80211_tx.c
@@ -304,216 +304,6 @@ ieee80211_classify(struct sk_buff *skb, 
   return(wme_UP);
 }
 
-#ifdef _RTL8187_EXT_PATCH_
-// based on part of ieee80211_xmit. Mainly allocate txb. ieee->lock is held
-struct ieee80211_txb *ieee80211_ext_alloc_txb(struct sk_buff *skb, struct net_device *dev, struct ieee80211_hdr_3addr *header, int hdr_len, u8 isQoS, u16 *pQOS_ctl, int isEncrypt, struct ieee80211_crypt_data* crypt)
-{
-	struct ieee80211_device *ieee = netdev_priv(dev);
-	struct ieee80211_txb *txb = NULL;
-	struct ieee80211_hdr_3addr *frag_hdr;
-	int i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;
-	int ether_type;
-	int bytes, QOS_ctl;
-	struct sk_buff *skb_frag;
-
-	ether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);
-
-	/* Advance the SKB to the start of the payload */
-	skb_pull(skb, sizeof(struct ethhdr));
-
-	/* Determine total amount of storage required for TXB packets */
-	bytes = skb->len + SNAP_SIZE + sizeof(u16);
-
-	/* Determine fragmentation size based on destination (multicast
-	 * and broadcast are not fragmented) */
-	// if (is_multicast_ether_addr(dest) ||
-	// is_broadcast_ether_addr(dest)) {
-	if (is_multicast_ether_addr(header->addr1) ||
-			is_broadcast_ether_addr(header->addr1)) {
-		frag_size = MAX_FRAG_THRESHOLD;
-		QOS_ctl = QOS_CTL_NOTCONTAIN_ACK;
-	}
-	else {
-		//printk(KERN_WARNING "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&frag_size = %d\n", frag_size);
-		frag_size = ieee->fts;//default:392
-		QOS_ctl = 0;
-	}
-
-	if(isQoS) {
-		QOS_ctl |= skb->priority; //set in the ieee80211_classify
-		*pQOS_ctl = cpu_to_le16(QOS_ctl);
-	}
-	//printk(KERN_WARNING "header size = %d, QOS_ctl = %x\n", hdr_len,QOS_ctl);
-	/* Determine amount of payload per fragment.  Regardless of if
-	 * this stack is providing the full 802.11 header, one will
-	 * eventually be affixed to this fragment -- so we must account for
-	 * it when determining the amount of payload space. */
-	//bytes_per_frag = frag_size - (IEEE80211_3ADDR_LEN + (ieee->current_network->QoS_Enable ? 2:0));
-	bytes_per_frag = frag_size - hdr_len;
-	if (ieee->config &
-			(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
-		bytes_per_frag -= IEEE80211_FCS_LEN;
-
-	/* Each fragment may need to have room for encryptiong pre/postfix */
-	if (isEncrypt)
-		bytes_per_frag -= crypt->ops->extra_prefix_len +
-			crypt->ops->extra_postfix_len;
-
-	/* Number of fragments is the total bytes_per_frag /
-	 * payload_per_fragment */
-	nr_frags = bytes / bytes_per_frag;
-	bytes_last_frag = bytes % bytes_per_frag;
-	if (bytes_last_frag)
-		nr_frags++;
-	else
-		bytes_last_frag = bytes_per_frag;
-
-	/* When we allocate the TXB we allocate enough space for the reserve
-	 * and full fragment bytes (bytes_per_frag doesn't include prefix,
-	 * postfix, header, FCS, etc.) */
-	txb = ieee80211_alloc_txb(nr_frags, frag_size, GFP_ATOMIC);
-	if (unlikely(!txb)) {
-		printk(KERN_WARNING "%s: Could not allocate TXB\n",
-			ieee->dev->name);
-		return NULL;
-	}
-	txb->encrypted = isEncrypt;
-	txb->payload_size = bytes;
-
-	for (i = 0; i < nr_frags; i++) {
-		skb_frag = txb->fragments[i];
-		skb_frag->priority = UP2AC(skb->priority);
-		if (isEncrypt)
-			skb_reserve(skb_frag, crypt->ops->extra_prefix_len);
-
-		frag_hdr = (struct ieee80211_hdr_3addr *)skb_put(skb_frag, hdr_len);
-		memcpy(frag_hdr, (void *)header, hdr_len);
-
-		/* If this is not the last fragment, then add the MOREFRAGS
-		 * bit to the frame control */
-		if (i != nr_frags - 1) {
-			frag_hdr->frame_ctl = cpu_to_le16(
-					header->frame_ctl | IEEE80211_FCTL_MOREFRAGS);
-			bytes = bytes_per_frag;
-
-		} else {
-			/* The last fragment takes the remaining length */
-			bytes = bytes_last_frag;
-		}
-
-		frag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4 | i);
-		//frag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl<<4 | i);
-		//
-
-		/* Put a SNAP header on the first fragment */
-		if (i == 0) {
-			ieee80211_put_snap(
-				skb_put(skb_frag, SNAP_SIZE + sizeof(u16)), ether_type);
-			bytes -= SNAP_SIZE + sizeof(u16);
-		}
-
-		memcpy(skb_put(skb_frag, bytes), skb->data, bytes);
-
-		/* Advance the SKB... */
-		skb_pull(skb, bytes);
-
-		/* Encryption routine will move the header forward in order
-		 * to insert the IV between the header and the payload */
-		if (isEncrypt)
-			ieee80211_encrypt_fragment(ieee, skb_frag, hdr_len);
-		if (ieee->config &
-				(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
-			skb_put(skb_frag, 4);
-	}
-	// Advance sequence number in data frame.
-	//printk(KERN_WARNING "QoS Enalbed? %s\n", ieee->current_network.QoS_Enable?"Y":"N");
-	if (ieee->seq_ctrl[0] == 0xFFF)
-		ieee->seq_ctrl[0] = 0;
-	else
-		ieee->seq_ctrl[0]++;
-	// stanley, just for debug
-/*
-{
-	int j=0;
-	for(j=0;j<nr_frags;j++)
-	{
-			int i;
-		struct sk_buff *skb = txb->fragments[j];
-			printk("send(%d): ", j);
-			for (i=0;i<skb->len;i++)
-				printk("%02X ", skb->data[i]&0xff);
-			printk("\n");
-	}
-}
-*/
-
-	return txb;
-}
-
-
-// based on part of ieee80211_xmit. Mainly allocate txb. ieee->lock is held
-// Assume no encryption, no FCS computing
-struct ieee80211_txb *ieee80211_ext_reuse_txb(struct sk_buff *skb, struct net_device *dev, struct ieee80211_hdr_3addr *header, int hdr_len, u8 isQoS, u16 *pQOS_ctl, int isEncrypt, struct ieee80211_crypt_data* crypt)
-{
-	struct ieee80211_device *ieee = netdev_priv(dev);
-	struct ieee80211_txb *txb = NULL;
-	struct ieee80211_hdr_3addr *frag_hdr;
-	int ether_type;
-	int bytes, QOS_ctl;
-
-	ether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);
-
-	/* Advance the SKB to the start of the payload */
-	skb_pull(skb, sizeof(struct ethhdr));
-
-	/* Determine total amount of storage required for TXB packets */
-	bytes = skb->len + SNAP_SIZE + sizeof(u16);
-
-	if (is_multicast_ether_addr(header->addr1) ||
-			is_broadcast_ether_addr(header->addr1)) {
-		QOS_ctl = QOS_CTL_NOTCONTAIN_ACK;
-	}
-	else {
-		QOS_ctl = 0;
-	}
-
-	if(isQoS) {
-		QOS_ctl |= skb->priority; //set in the ieee80211_classify
-		*pQOS_ctl = cpu_to_le16(QOS_ctl);
-	}
-
-	txb = kmalloc( sizeof(struct ieee80211_txb) + sizeof(u8*), GFP_ATOMIC );
-	if (unlikely(!txb)) {
-		printk(KERN_WARNING "%s: Could not allocate TXB\n",
-			ieee->dev->name);
-		return NULL;
-	}
-
-	txb->nr_frags = 1;
-	txb->frag_size = bytes;
-	txb->encrypted = isEncrypt;
-	txb->payload_size = bytes;
-
-	txb->fragments[0] = skb;
-	ieee80211_put_snap(
-			skb_push(skb, SNAP_SIZE + sizeof(u16)), ether_type);
-	frag_hdr = (struct ieee80211_hdr_3addr *)skb_push(skb, hdr_len);
-	memcpy(frag_hdr, (void *)header, hdr_len);
-	frag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4 | 0);
-	skb->priority = UP2AC(skb->priority);
-
-	// Advance sequence number in data frame.
-	//printk(KERN_WARNING "QoS Enalbed? %s\n", ieee->current_network.QoS_Enable?"Y":"N");
-	if (ieee->seq_ctrl[0] == 0xFFF)
-		ieee->seq_ctrl[0] = 0;
-	else
-		ieee->seq_ctrl[0]++;
-
-	return txb;
-}
-
-#endif // _RTL8187_EXT_PATCH_
-
 /* SKBs are added to the ieee->tx_queue. */
 int ieee80211_xmit(struct sk_buff *skb,
 		   struct net_device *dev)
@@ -561,16 +351,6 @@ int ieee80211_xmit(struct sk_buff *skb,
 			goto success;
 		}
 
-
-#ifdef _RTL8187_EXT_PATCH_
-		// note, skb->priority which was set by ieee80211_classify, and used by physical tx
-		if((ieee->iw_mode == ieee->iw_ext_mode) && (ieee->ext_patch_ieee80211_xmit))
-		{
-			txb = ieee->ext_patch_ieee80211_xmit(skb, dev);
-			goto success;
-		}
-#endif
-
 		ether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);
 
 		crypt = ieee->crypt[ieee->tx_keyidx];
@@ -782,10 +562,6 @@ int ieee80211_xmit(struct sk_buff *skb,
 
  success:
 	spin_unlock_irqrestore(&ieee->lock, flags);
-#ifdef _RTL8187_EXT_PATCH_
-	// Sometimes, extension mode can reuse skb (by txb->fragments[0])
-	if( ! ((ieee->iw_mode == ieee->iw_ext_mode) && txb && (txb->fragments[0] == skb)) )
-#endif
 		dev_kfree_skb_any(skb);
 	if (txb) {
 		if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE){
@@ -812,9 +588,4 @@ int ieee80211_xmit(struct sk_buff *skb,
 
 #if 0
 EXPORT_SYMBOL(ieee80211_txb_free);
-#ifdef _RTL8187_EXT_PATCH_
-EXPORT_SYMBOL(ieee80211_alloc_txb);
-EXPORT_SYMBOL(ieee80211_ext_alloc_txb);
-EXPORT_SYMBOL(ieee80211_ext_reuse_txb);
-#endif // _RTL8187_EXT_PATCH_
 #endif
