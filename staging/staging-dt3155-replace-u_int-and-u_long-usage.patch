From foo@baz Tue Feb  9 12:41:38 PST 2010
Date: Tue, 09 Feb 2010 12:41:38 -0800
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Staging: dt3155: replace u_int and u_long usage

Use u32 and u64 instead, that's the proper thing to do.

Cc: Scott Smedley <ss@aao.gov.au>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/dt3155/allocator.c  |    4 
 drivers/staging/dt3155/allocator.h  |    2 
 drivers/staging/dt3155/dt3155.h     |   36 +++----
 drivers/staging/dt3155/dt3155_drv.c |   51 +++++-----
 drivers/staging/dt3155/dt3155_drv.h |    2 
 drivers/staging/dt3155/dt3155_io.c  |   16 +--
 drivers/staging/dt3155/dt3155_io.h  |  174 ++++++++++++++++++------------------
 drivers/staging/dt3155/dt3155_isr.c |   52 +++++-----
 drivers/staging/dt3155/dt3155_isr.h |    2 
 9 files changed, 169 insertions(+), 170 deletions(-)

--- a/drivers/staging/dt3155/allocator.c
+++ b/drivers/staging/dt3155/allocator.c
@@ -27,7 +27,7 @@
   -------------------------------------------------------------------
   02-Aug-2002 NJC         allocator now steps in 1MB increments, rather
 			  than doubling its size each time.
-			  Also, allocator_init(u_int *) now returns
+			  Also, allocator_init(u32 *) now returns
 			  (in the first arg) the size of the free
 			  space.  This is no longer consistent with
 			  using the allocator as a module, and some changes
@@ -195,7 +195,7 @@ int allocator_free_dma(unsigned long add
  * On cleanup everything is released. If the list is not empty, that a
  * problem of our clients
  */
-int allocator_init(u_long *allocator_max)
+int allocator_init(u64 *allocator_max)
 {
 	/* check how much free memory is there */
 	void *remapped;
--- a/drivers/staging/dt3155/allocator.h
+++ b/drivers/staging/dt3155/allocator.h
@@ -24,5 +24,5 @@
 
 void allocator_free_dma(unsigned long address);
 unsigned long allocator_allocate_dma(unsigned long kilobytes, int priority);
-int allocator_init(u_long *);
+int allocator_init(u64 *);
 void allocator_cleanup(void);
--- a/drivers/staging/dt3155/dt3155.h
+++ b/drivers/staging/dt3155/dt3155.h
@@ -35,7 +35,7 @@ MA 02111-1307 USA
 #define _DT3155_INC
 
 #ifdef __KERNEL__
-#include <linux/types.h>	/* u_int etc. */
+#include <linux/types.h>
 #include <linux/time.h>		/* struct timeval */
 #else
 #include <sys/ioctl.h>
@@ -71,16 +71,16 @@ MA 02111-1307 USA
 
 /* Configuration structure */
 struct dt3155_config_s {
-	u_int acq_mode;
-	u_int cols, rows;
-	u_int continuous;
+	u32 acq_mode;
+	u32 cols, rows;
+	u32 continuous;
 };
 
 
 /* hold data for each frame */
 typedef struct {
-	u_long addr;		/* address of the buffer with the frame */
-	u_long tag;		/* unique number for the frame */
+	u64 addr;		/* address of the buffer with the frame */
+	u64 tag;		/* unique number for the frame */
 	struct timeval time;	/* time that capture took place */
 } frame_info_t;
 
@@ -101,14 +101,14 @@ struct dt3155_fbuffer_s {
 	int locked_buf;			/* Buffers used by user */
 
 	int ready_que[BOARD_MAX_BUFFS];
-	u_long ready_head;	/* The most recent buffer located here */
-	u_long ready_len;	/* The number of ready buffers */
+	u64 ready_head;	/* The most recent buffer located here */
+	u64 ready_len;	/* The number of ready buffers */
 
 	int even_happened;
 	int even_stopped;
 
 	int stop_acquire;	/* Flag to stop interrupts */
-	u_long frame_count;	/* Counter for frames acquired by this card */
+	u64 frame_count;	/* Counter for frames acquired by this card */
 };
 
 
@@ -122,14 +122,14 @@ struct dt3155_fbuffer_s {
 /* There is one status structure for each card. */
 typedef struct dt3155_status_s {
 	int fixed_mode;		/* if 1, we are in fixed frame mode */
-	u_long reg_addr;	/* Register address for a single card */
-	u_long mem_addr;	/* Buffer start addr for this card */
-	u_long mem_size;	/* This is the amount of mem available  */
-	u_int irq;		/* this card's irq */
+	u64 reg_addr;	/* Register address for a single card */
+	u64 mem_addr;	/* Buffer start addr for this card */
+	u64 mem_size;	/* This is the amount of mem available  */
+	u32 irq;		/* this card's irq */
 	struct dt3155_config_s config;		/* configuration struct */
 	struct dt3155_fbuffer_s fbuffer;	/* frame buffer state struct */
-	u_long state;		/* this card's state */
-	u_int device_installed;	/* Flag if installed. 1=installed */
+	u64 state;		/* this card's state */
+	u32 device_installed;	/* Flag if installed. 1=installed */
 } dt3155_status_t;
 
 /* Reference to global status structure */
@@ -161,9 +161,9 @@ extern struct dt3155_status_s dt3155_sta
 
 /* User code will probably want to declare one of these for each card */
 typedef struct dt3155_read_s {
-	u_long offset;
-	u_long frame_seq;
-	u_long state;
+	u64 offset;
+	u64 frame_seq;
+	u64 state;
 
 	frame_info_t frame_info;
 } dt3155_read_t;
--- a/drivers/staging/dt3155/dt3155_drv.c
+++ b/drivers/staging/dt3155/dt3155_drv.c
@@ -130,14 +130,14 @@ u8 *dt3155_lbase[ MAXBOARDS ] = { NULL
 /* DT3155 registers              */
 u8 *dt3155_bbase = NULL;		  /* kernel logical address of the *
 					   * buffer region                 */
-u_int  dt3155_dev_open[ MAXBOARDS ] = {0
+u32  dt3155_dev_open[ MAXBOARDS ] = {0
 #if MAXBOARDS == 2
 				       , 0
 #endif
 };
 
-u_int  ndevices = 0;
-u_long unique_tag = 0;;
+u32  ndevices = 0;
+u64 unique_tag = 0;;
 
 
 /*
@@ -180,7 +180,7 @@ static inline void dt3155_isr( int irq,
   int    minor = -1;
   int    index;
   unsigned long flags;
-  u_long buffer_addr;
+  u64 buffer_addr;
 
   /* find out who issued the interrupt */
   for ( index = 0; index < ndevices; index++ ) {
@@ -249,7 +249,7 @@ static inline void dt3155_isr( int irq,
 	{
 	  /* GCS (Aug 2, 2002) -- In field mode, dma the odd field
 	     into the lower half of the buffer */
-	  const u_long stride =  dt3155_status[ minor ].config.cols;
+	  const u64 stride =  dt3155_status[ minor ].config.cols;
 	  buffer_addr = dt3155_fbuffer[ minor ]->
 	    frame_info[ dt3155_fbuffer[ minor ]->active_buf ].addr
 	    + (DT3155_MAX_ROWS / 2) * stride;
@@ -311,8 +311,8 @@ static inline void dt3155_isr( int irq,
 	      dt3155_fbuffer[ minor ]->stop_acquire = 0;
 	      dt3155_fbuffer[ minor ]->even_stopped = 0;
 
-	      printk(KERN_DEBUG "dt3155:  state is now %lx\n",
-		     dt3155_status[minor].state);
+	      printk(KERN_DEBUG "dt3155:  state is now %x\n",
+		     (u32)dt3155_status[minor].state);
 	    }
 	  else
 	    {
@@ -428,7 +428,7 @@ static inline void dt3155_isr( int irq,
  *****************************************************/
 static void dt3155_init_isr(int minor)
 {
-  const u_long stride =  dt3155_status[ minor ].config.cols;
+  const u64 stride =  dt3155_status[ minor ].config.cols;
 
   switch (dt3155_status[ minor ].state & DT3155_STATE_MODE)
     {
@@ -522,11 +522,10 @@ static void dt3155_init_isr(int minor)
  * ioctl()
  *
  *****************************************************/
-static int dt3155_ioctl (
-			 struct inode	*inode,
-			 struct file		*file,
-			 u_int			cmd,
-			 u_long			arg)
+static int dt3155_ioctl(struct inode *inode,
+			struct file *file,
+			unsigned int cmd,
+			unsigned long arg)
 {
   int minor = MINOR(inode->i_rdev); /* What device are we ioctl()'ing? */
 
@@ -706,8 +705,8 @@ static int dt3155_open( struct inode* in
     }
 
   if (dt3155_status[ minor ].state != DT3155_STATE_IDLE) {
-    printk ("DT3155:  Not in idle state (state = %lx)\n",
-	    dt3155_status[ minor ].state);
+    printk ("DT3155:  Not in idle state (state = %x)\n",
+	    (u32)dt3155_status[ minor ].state);
     return -EBUSY;
   }
 
@@ -763,7 +762,7 @@ static ssize_t dt3155_read(struct file *
 {
   /* which device are we reading from? */
   int		minor = MINOR(filep->f_dentry->d_inode->i_rdev);
-  u_long		offset;
+  u64		offset;
   int		frame_index;
   frame_info_t	*frame_info_p;
 
@@ -821,11 +820,11 @@ static ssize_t dt3155_read(struct file *
   offset = frame_info_p->addr - dt3155_status[minor].mem_addr;
 
   put_user(offset, (unsigned int *) buf);
-  buf += sizeof(u_long);
+  buf += sizeof(u64);
   put_user( dt3155_status[minor].fbuffer.frame_count, (unsigned int *) buf);
-  buf += sizeof(u_long);
+  buf += sizeof(u64);
   put_user(dt3155_status[minor].state, (unsigned int *) buf);
-  buf += sizeof(u_long);
+  buf += sizeof(u64);
   if (copy_to_user(buf, frame_info_p, sizeof(frame_info_t)))
       return -EFAULT;
 
@@ -899,7 +898,7 @@ static int find_PCI (void)
       /* Now, just go out and make sure that this/these device(s) is/are
 	 actually mapped into the kernel address space */
       if ((error = pci_read_config_dword( pci_dev, PCI_BASE_ADDRESS_0,
-					  (u_int *) &base)))
+					  (u32 *) &base)))
 	{
 	  printk("DT3155: Was not able to find device \n");
 	  goto err;
@@ -932,7 +931,7 @@ static int find_PCI (void)
       dt3155_status[ pci_index-1 ].device_installed = 1;
       printk("DT3155: Installing device %d w/irq %d and address %p\n",
 	     pci_index,
-	     (u_int)dt3155_status[pci_index-1].irq,
+	     (u32)dt3155_status[pci_index-1].irq,
 	     dt3155_lbase[pci_index-1]);
 
     }
@@ -945,7 +944,7 @@ err:
   return DT_3155_FAILURE;
 }
 
-u_long allocatorAddr = 0;
+u64 allocatorAddr = 0;
 
 /*****************************************************
  * init_module()
@@ -1024,10 +1023,10 @@ int init_module(void)
 	     dt3155_status[ index ].config.cols,
 	     dt3155_status[ index ].config.rows);
       printk("DT3155: m_addr = 0x%x; m_size = %ld; "
-	     "state = %ld; device_installed = %d\n",
-	     (u_int)dt3155_status[ index ].mem_addr,
-	     dt3155_status[ index ].mem_size,
-	     dt3155_status[ index ].state,
+	     "state = %d; device_installed = %d\n",
+	     (u32)dt3155_status[ index ].mem_addr,
+	     (long int)dt3155_status[ index ].mem_size,
+	     (u32)dt3155_status[ index ].state,
 	     dt3155_status[ index ].device_installed);
     }
 
--- a/drivers/staging/dt3155/dt3155_drv.h
+++ b/drivers/staging/dt3155/dt3155_drv.h
@@ -38,7 +38,7 @@ extern wait_queue_head_t dt3155_read_wai
 #endif
 
 /* number of devices */
-extern u_int ndevices;
+extern u32 ndevices;
 
 extern int dt3155_errno;
 
--- a/drivers/staging/dt3155/dt3155_io.c
+++ b/drivers/staging/dt3155/dt3155_io.c
@@ -55,12 +55,12 @@ MA 02111-1307 USA
 
 
 /****** local copies of board's 32 bit registers ******/
-u_long            even_dma_start_r;     /*  bit 0 should always be 0 */
-u_long            odd_dma_start_r;      /*               .. */
-u_long            even_dma_stride_r;    /*  bits 0&1 should always be 0 */
-u_long            odd_dma_stride_r;     /*               .. */
-u_long            even_pixel_fmt_r;
-u_long            odd_pixel_fmt_r;
+u64            even_dma_start_r;     /*  bit 0 should always be 0 */
+u64            odd_dma_start_r;      /*               .. */
+u64            even_dma_stride_r;    /*  bits 0&1 should always be 0 */
+u64            odd_dma_stride_r;     /*               .. */
+u64            even_pixel_fmt_r;
+u64            odd_pixel_fmt_r;
 
 FIFO_TRIGGER_R      fifo_trigger_r;
 XFER_MODE_R         xfer_mode_r;
@@ -68,8 +68,8 @@ CSR1_R              csr1_r;
 RETRY_WAIT_CNT_R    retry_wait_cnt_r;
 INT_CSR_R           int_csr_r;
 
-u_long              even_fld_mask_r;
-u_long              odd_fld_mask_r;
+u64              even_fld_mask_r;
+u64              odd_fld_mask_r;
 
 MASK_LENGTH_R       mask_length_r;
 FIFO_FLAG_CNT_R     fifo_flag_cnt_r;
--- a/drivers/staging/dt3155/dt3155_io.h
+++ b/drivers/staging/dt3155/dt3155_io.h
@@ -36,8 +36,8 @@ MA 02111-1307 USA
 
 /* macros to access registers */
 
-#define WriteMReg(Address, Data)	(*((u_long *)(Address)) = Data)
-#define ReadMReg(Address, Data)		(Data = *((u_long *)(Address)))
+#define WriteMReg(Address, Data)	(*((u64 *)(Address)) = Data)
+#define ReadMReg(Address, Data)		(Data = *((u64 *)(Address)))
 
 /***************** 32 bit register globals  **************/
 
@@ -71,114 +71,114 @@ MA 02111-1307 USA
 /******** Assignments and Typedefs for 32 bit Memory Mapped Registers ********/
 
 typedef union fifo_trigger_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long PACKED:6;
-		u_long       :9;
-		u_long PLANER:7;
-		u_long       :9;
+		u64 PACKED:6;
+		u64       :9;
+		u64 PLANER:7;
+		u64       :9;
 	} fld;
 } FIFO_TRIGGER_R;
 
 typedef union xfer_mode_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long             :2;
-		u_long FIELD_TOGGLE:1;
-		u_long             :5;
-		u_long             :2;
-		u_long             :22;
+		u64             :2;
+		u64 FIELD_TOGGLE:1;
+		u64             :5;
+		u64             :2;
+		u64             :22;
 	} fld;
 } XFER_MODE_R;
 
 typedef union csr1_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long CAP_CONT_EVE:1;
-		u_long CAP_CONT_ODD:1;
-		u_long CAP_SNGL_EVE:1;
-		u_long CAP_SNGL_ODD:1;
-		u_long FLD_DN_EVE  :1;
-		u_long FLD_DN_ODD  :1;
-		u_long SRST        :1;
-		u_long FIFO_EN     :1;
-		u_long FLD_CRPT_EVE:1;
-		u_long FLD_CRPT_ODD:1;
-		u_long ADDR_ERR_EVE:1;
-		u_long ADDR_ERR_ODD:1;
-		u_long CRPT_DIS    :1;
-		u_long RANGE_EN    :1;
-		u_long             :16;
+		u64 CAP_CONT_EVE:1;
+		u64 CAP_CONT_ODD:1;
+		u64 CAP_SNGL_EVE:1;
+		u64 CAP_SNGL_ODD:1;
+		u64 FLD_DN_EVE  :1;
+		u64 FLD_DN_ODD  :1;
+		u64 SRST        :1;
+		u64 FIFO_EN     :1;
+		u64 FLD_CRPT_EVE:1;
+		u64 FLD_CRPT_ODD:1;
+		u64 ADDR_ERR_EVE:1;
+		u64 ADDR_ERR_ODD:1;
+		u64 CRPT_DIS    :1;
+		u64 RANGE_EN    :1;
+		u64             :16;
 	} fld;
 } CSR1_R;
 
 typedef union retry_wait_cnt_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long RTRY_WAIT_CNT:8;
-		u_long              :24;
+		u64 RTRY_WAIT_CNT:8;
+		u64              :24;
 	} fld;
 } RETRY_WAIT_CNT_R;
 
 typedef union int_csr_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long FLD_END_EVE   :1;
-		u_long FLD_END_ODD   :1;
-		u_long FLD_START     :1;
-		u_long               :5;
-		u_long FLD_END_EVE_EN:1;
-		u_long FLD_END_ODD_EN:1;
-		u_long FLD_START_EN  :1;
-		u_long               :21;
+		u64 FLD_END_EVE   :1;
+		u64 FLD_END_ODD   :1;
+		u64 FLD_START     :1;
+		u64               :5;
+		u64 FLD_END_EVE_EN:1;
+		u64 FLD_END_ODD_EN:1;
+		u64 FLD_START_EN  :1;
+		u64               :21;
 	} fld;
 } INT_CSR_R;
 
 typedef union mask_length_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long MASK_LEN_EVE:5;
-		u_long             :11;
-		u_long MASK_LEN_ODD:5;
-		u_long             :11;
+		u64 MASK_LEN_EVE:5;
+		u64             :11;
+		u64 MASK_LEN_ODD:5;
+		u64             :11;
 	} fld;
 } MASK_LENGTH_R;
 
 typedef union fifo_flag_cnt_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long AF_COUNT:7;
-		u_long         :9;
-		u_long AE_COUNT:7;
-		u_long         :9;
+		u64 AF_COUNT:7;
+		u64         :9;
+		u64 AE_COUNT:7;
+		u64         :9;
 	} fld;
 } FIFO_FLAG_CNT_R;
 
 typedef union iic_clk_dur {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long PHASE_1:8;
-		u_long PHASE_2:8;
-		u_long PHASE_3:8;
-		u_long PHASE_4:8;
+		u64 PHASE_1:8;
+		u64 PHASE_2:8;
+		u64 PHASE_3:8;
+		u64 PHASE_4:8;
 	} fld;
 } IIC_CLK_DUR_R;
 
 typedef union iic_csr1_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long AUTO_EN     :1;
-		u_long BYPASS      :1;
-		u_long SDA_OUT     :1;
-		u_long SCL_OUT     :1;
-		u_long             :4;
-		u_long AUTO_ABORT  :1;
-		u_long DIRECT_ABORT:1;
-		u_long SDA_IN      :1;
-		u_long SCL_IN      :1;
-		u_long             :4;
-		u_long AUTO_ADDR   :8;
-		u_long RD_DATA     :8;
+		u64 AUTO_EN     :1;
+		u64 BYPASS      :1;
+		u64 SDA_OUT     :1;
+		u64 SCL_OUT     :1;
+		u64             :4;
+		u64 AUTO_ABORT  :1;
+		u64 DIRECT_ABORT:1;
+		u64 SDA_IN      :1;
+		u64 SCL_IN      :1;
+		u64             :4;
+		u64 AUTO_ADDR   :8;
+		u64 RD_DATA     :8;
 	} fld;
 } IIC_CSR1_R;
 
@@ -186,14 +186,14 @@ typedef union iic_csr1_tag {
  * iic_csr2_tag
  */
 typedef union iic_csr2_tag {
-	u_long   reg;
+	u64   reg;
 	struct {
-		u_long DIR_WR_DATA :8;
-		u_long DIR_SUB_ADDR:8;
-		u_long DIR_RD      :1;
-		u_long DIR_ADDR    :7;
-		u_long NEW_CYCLE   :1;
-		u_long             :7;
+		u64 DIR_WR_DATA :8;
+		u64 DIR_SUB_ADDR:8;
+		u64 DIR_RD      :1;
+		u64 DIR_ADDR    :7;
+		u64 NEW_CYCLE   :1;
+		u64             :7;
 	} fld;
 }  IIC_CSR2_R;
 
@@ -203,10 +203,10 @@ typedef union iic_csr2_tag {
  * dma_upper_lmt_tag
  */
 typedef union dma_upper_lmt_tag   {
-	u_long reg;
+	u64 reg;
 	struct {
-		u_long DMA_UPPER_LMT_VAL:24;
-		u_long                  :8;
+		u64 DMA_UPPER_LMT_VAL:24;
+		u64                  :8;
 	} fld;
 } DMA_UPPER_LMT_R;
 
@@ -214,12 +214,12 @@ typedef union dma_upper_lmt_tag   {
 /*
  * Global declarations of local copies of boards' 32 bit registers
  */
-extern u_long even_dma_start_r;		/*  bit 0 should always be 0 */
-extern u_long odd_dma_start_r;		/*               ..          */
-extern u_long even_dma_stride_r;	/*  bits 0&1 should always be 0 */
-extern u_long odd_dma_stride_r;		/*               ..             */
-extern u_long even_pixel_fmt_r;
-extern u_long odd_pixel_fmt_r;
+extern u64 even_dma_start_r;		/*  bit 0 should always be 0 */
+extern u64 odd_dma_start_r;		/*               ..          */
+extern u64 even_dma_stride_r;	/*  bits 0&1 should always be 0 */
+extern u64 odd_dma_stride_r;		/*               ..             */
+extern u64 even_pixel_fmt_r;
+extern u64 odd_pixel_fmt_r;
 
 extern FIFO_TRIGGER_R		fifo_trigger_r;
 extern XFER_MODE_R		xfer_mode_r;
@@ -227,8 +227,8 @@ extern CSR1_R			csr1_r;
 extern RETRY_WAIT_CNT_R		retry_wait_cnt_r;
 extern INT_CSR_R		int_csr_r;
 
-extern u_long even_fld_mask_r;
-extern u_long odd_fld_mask_r;
+extern u64 even_fld_mask_r;
+extern u64 odd_fld_mask_r;
 
 extern MASK_LENGTH_R		mask_length_r;
 extern FIFO_FLAG_CNT_R		fifo_flag_cnt_r;
--- a/drivers/staging/dt3155/dt3155_isr.c
+++ b/drivers/staging/dt3155/dt3155_isr.c
@@ -220,7 +220,7 @@ inline void printques( int m )
  *  the start address up to the beginning of the
  *  next 4MB chunk (assuming bufsize < 4MB).
  *****************************************************/
-u_long adjust_4MB (u_long buf_addr, u_long bufsize) {
+u64 adjust_4MB (u64 buf_addr, u64 bufsize) {
   if (((buf_addr+bufsize) & UPPER_10_BITS) != (buf_addr & UPPER_10_BITS))
     return (buf_addr+bufsize) & UPPER_10_BITS;
   else
@@ -235,26 +235,26 @@ u_long adjust_4MB (u_long buf_addr, u_lo
  *  buffers.  If there is not enough free space
  *  try for less memory.
  *****************************************************/
-void allocate_buffers (u_long *buf_addr, u_long* total_size_kbs,
-		       u_long bufsize)
+void allocate_buffers (u64 *buf_addr, u64* total_size_kbs,
+		       u64 bufsize)
 {
   /* Compute the minimum amount of memory guaranteed to hold all
      MAXBUFFERS such that no buffer crosses the 4MB boundary.
      Store this value in the variable "full_size" */
 
-  u_long allocator_max;
-  u_long bufs_per_chunk = (FOUR_MB / bufsize);
-  u_long filled_chunks = (MAXBUFFERS-1) / bufs_per_chunk;
-  u_long leftover_bufs = MAXBUFFERS - filled_chunks * bufs_per_chunk;
+  u64 allocator_max;
+  u64 bufs_per_chunk = (FOUR_MB / bufsize);
+  u64 filled_chunks = (MAXBUFFERS-1) / bufs_per_chunk;
+  u64 leftover_bufs = MAXBUFFERS - filled_chunks * bufs_per_chunk;
 
-  u_long full_size = bufsize      /* possibly unusable part of 1st chunk */
+  u64 full_size = bufsize      /* possibly unusable part of 1st chunk */
     + filled_chunks * FOUR_MB   /* max # of completely filled 4mb chunks */
     + leftover_bufs * bufsize;  /* these buffs will be in a partly filled
 				   chunk at beginning or end */
 
-  u_long full_size_kbs = 1 + (full_size-1) / 1024;
-  u_long min_size_kbs = 2*ndevices*bufsize / 1024;
-  u_long size_kbs;
+  u64 full_size_kbs = 1 + (full_size-1) / 1024;
+  u64 min_size_kbs = 2*ndevices*bufsize / 1024;
+  u64 size_kbs;
 
   /* Now, try to allocate full_size.  If this fails, keep trying for
      less & less memory until it succeeds. */
@@ -264,13 +264,13 @@ void allocate_buffers (u_long *buf_addr,
 #endif
   size_kbs = full_size_kbs;
   *buf_addr = 0;
-  printk ("DT3155: We would like to get: %d KB\n", (u_int)(full_size_kbs));
-  printk ("DT3155: ...but need at least: %d KB\n", (u_int)(min_size_kbs));
-  printk ("DT3155: ...the allocator has: %d KB\n", (u_int)(allocator_max));
+  printk ("DT3155: We would like to get: %d KB\n", (u32)(full_size_kbs));
+  printk ("DT3155: ...but need at least: %d KB\n", (u32)(min_size_kbs));
+  printk ("DT3155: ...the allocator has: %d KB\n", (u32)(allocator_max));
   size_kbs = (full_size_kbs <= allocator_max ? full_size_kbs : allocator_max);
   if (size_kbs > min_size_kbs) {
     if ((*buf_addr = allocator_allocate_dma (size_kbs, GFP_KERNEL)) != 0) {
-      printk ("DT3155:  Managed to allocate: %d KB\n", (u_int)size_kbs);
+      printk ("DT3155:  Managed to allocate: %d KB\n", (u32)size_kbs);
       *total_size_kbs = size_kbs;
       return;
     }
@@ -298,17 +298,17 @@ void allocate_buffers (u_long *buf_addr,
  * 4MB boundary.  Also, add error checking.  This
  * function will return -ENOMEM when not enough memory.
  *****************************************************/
-u_long dt3155_setup_buffers(u_long *allocatorAddr)
+u64 dt3155_setup_buffers(u64 *allocatorAddr)
 
 {
-  u_long index;
-  u_long rambuff_addr; /* start of allocation */
-  u_long rambuff_size; /* total size allocated to driver */
-  u_long rambuff_acm;  /* accumlator, keep track of how much
+  u64 index;
+  u64 rambuff_addr; /* start of allocation */
+  u64 rambuff_size; /* total size allocated to driver */
+  u64 rambuff_acm;  /* accumlator, keep track of how much
 			  is left after being split up*/
-  u_long rambuff_end;  /* end of rambuff */
-  u_long numbufs;      /* number of useful buffers allocated (per device) */
-  u_long bufsize      = DT3155_MAX_ROWS * DT3155_MAX_COLS;
+  u64 rambuff_end;  /* end of rambuff */
+  u64 numbufs;      /* number of useful buffers allocated (per device) */
+  u64 bufsize      = DT3155_MAX_ROWS * DT3155_MAX_COLS;
   int m;               /* minor # of device, looped for all devs */
 
   /* zero the fbuffer status and address structure */
@@ -327,8 +327,8 @@ u_long dt3155_setup_buffers(u_long *allo
   /* allocate a large contiguous chunk of RAM */
   allocate_buffers (&rambuff_addr, &rambuff_size, bufsize);
   printk( "DT3155: mem info\n" );
-  printk( "  - rambuf_addr = 0x%x \n", (u_int)rambuff_addr );
-  printk( "  - length (kb) = %u \n",  (u_int)rambuff_size );
+  printk( "  - rambuf_addr = 0x%x \n", (u32)rambuff_addr );
+  printk( "  - length (kb) = %u \n",  (u32)rambuff_size );
   if( rambuff_addr == 0 )
     {
       printk( KERN_INFO
@@ -350,7 +350,7 @@ u_long dt3155_setup_buffers(u_long *allo
   /* Following line is OK, will waste buffers if index
    * not evenly divisible by ndevices -NJC*/
   numbufs = index / ndevices;
-  printk ("  - numbufs = %u\n", (u_int) numbufs);
+  printk ("  - numbufs = %u\n", (u32) numbufs);
   if (numbufs < 2) {
     printk( KERN_INFO
 	    "DT3155: Error setup_buffers() couldn't allocate 2 bufs/board\n" );
--- a/drivers/staging/dt3155/dt3155_isr.h
+++ b/drivers/staging/dt3155/dt3155_isr.h
@@ -42,7 +42,7 @@ extern struct dt3155_fbuffer_s *dt3155_f
 /* Initialize the buffering system.  This should */
 /* be called prior to enabling interrupts */
 
-u_long dt3155_setup_buffers(u_long *allocatorAddr);
+u64 dt3155_setup_buffers(u64 *allocatorAddr);
 
 /* Get the next frame of data if it is ready.  Returns */
 /* zero if no data is ready.  If there is data but */
