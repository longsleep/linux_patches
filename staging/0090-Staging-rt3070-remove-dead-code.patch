From 77600a0905de1fa334e42c95987c73703f7584dc Mon Sep 17 00:00:00 2001
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Sun, 26 Apr 2009 16:06:16 +0200
Subject: [PATCH 090/102] Staging: rt3070: remove dead code

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt3070/2870_main_dev.c        |    7 --
 drivers/staging/rt3070/ap.h                   |   12 ---
 drivers/staging/rt3070/common/action.c        |   11 ---
 drivers/staging/rt3070/common/ba_action.c     |    6 -
 drivers/staging/rt3070/common/cmm_data.c      |   42 -------------
 drivers/staging/rt3070/common/cmm_data_2870.c |    9 --
 drivers/staging/rt3070/common/cmm_info.c      |    5 -
 drivers/staging/rt3070/common/cmm_sanity.c    |   31 ---------
 drivers/staging/rt3070/common/mlme.c          |   83 --------------------------
 drivers/staging/rt3070/common/rtmp_init.c     |   45 --------------
 drivers/staging/rt3070/common/rtmp_tkip.c     |    3 
 drivers/staging/rt3070/common/rtmp_wep.c      |    9 --
 drivers/staging/rt3070/mlme.h                 |   18 -----
 drivers/staging/rt3070/oid.h                  |   33 ----------
 drivers/staging/rt3070/rt28xx.h               |   17 -----
 drivers/staging/rt3070/rt_linux.c             |    4 -
 drivers/staging/rt3070/rt_linux.h             |    9 --
 drivers/staging/rt3070/rt_main_dev.c          |   56 -----------------
 drivers/staging/rt3070/rt_profile.c           |   47 --------------
 drivers/staging/rt3070/rtmp.h                 |   60 ------------------
 drivers/staging/rt3070/rtmp_def.h             |   22 ------
 drivers/staging/rt3070/sta/connect.c          |   11 ---
 drivers/staging/rt3070/sta/rtmp_data.c        |    4 -
 drivers/staging/rt3070/sta/sync.c             |    2 
 drivers/staging/rt3070/sta/wpa.c              |   13 ----
 drivers/staging/rt3070/sta_ioctl.c            |   19 -----
 26 files changed, 3 insertions(+), 575 deletions(-)

--- a/drivers/staging/rt3070/2870_main_dev.c
+++ b/drivers/staging/rt3070/2870_main_dev.c
@@ -55,12 +55,6 @@ MODULE_VERSION(STA_DRIVER_VERSION);
  * packets that have a "complete" function are sent here. This way, the
  * completion is run out of kernel context, and doesn't block the rest of
  * the stack. */
-//static int mlme_kill = 0;		// Mlme kernel thread
-//static int RTUSBCmd_kill = 0;	// Command kernel thread
-//static int TimerFunc_kill = 0;	// TimerQ kernel thread
-
-//static wait_queue_head_t 	timerWaitQ;
-//static wait_queue_t 		waitQ;
 
 extern INT __devinit rt28xx_probe(IN void *_dev_p, IN void *_dev_id_p,
 									IN UINT argc, OUT PRTMP_ADAPTER *ppAd);
@@ -1224,7 +1218,6 @@ VOID RT28xx_UpdateBeaconToAsic(
 	UINT  			i, padding;
 	BEACON_SYNC_STRUCT	*pBeaconSync = pAd->CommonCfg.pBeaconSync;
 	UINT32			longValue;
-//	USHORT			shortValue;
 	BOOLEAN			bBcnReq = FALSE;
 	UCHAR			bcn_idx = 0;
 
--- a/drivers/staging/rt3070/ap.h
+++ b/drivers/staging/rt3070/ap.h
@@ -163,18 +163,6 @@ USHORT APBuildAssociation(
 	IN UCHAR		 HtCapabilityLen,
     OUT USHORT *pAid);
 
-/*
-VOID	RTMPAddClientSec(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR	BssIdx,
-	IN UCHAR		 KeyIdx,
-	IN UCHAR		 CipherAlg,
-	IN PUCHAR		 pKey,
-	IN PUCHAR		 pTxMic,
-	IN PUCHAR		 pRxMic,
-	IN MAC_TABLE_ENTRY *pEntry);
-*/
-
 // ap_auth.c
 
 void APAuthStateMachineInit(
--- a/drivers/staging/rt3070/common/action.c
+++ b/drivers/staging/rt3070/common/action.c
@@ -152,7 +152,6 @@ VOID MlmeADDBAAction(
 		              sizeof(FRAME_ADDBA_REQ), &Frame,
 		              END_OF_ARGS);
 		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-		//MiniportDataMMRequest(pAd, MapUserPriorityToAccessCategory[pInfo->TID], pOutBuffer, FrameLen);
 		MlmeFreeMemory(pAd, pOutBuffer);
 
 		DBGPRINT(RT_DEBUG_TRACE, ("BA - Send ADDBA request. StartSeq = %x,  FrameLen = %ld. BufSize = %d\n", Frame.BaStartSeq.field.StartSeq, FrameLen, Frame.BaParm.BufSize));
@@ -468,11 +467,6 @@ VOID ORIBATimerTimeout(
 {
 	MAC_TABLE_ENTRY	*pEntry;
 	INT			i, total;
-//	FRAME_BAR			FrameBar;
-//	ULONG			FrameLen;
-//	NDIS_STATUS 	NStatus;
-//	PUCHAR			pOutBuffer = NULL;
-//	USHORT			Sequence;
 	UCHAR			TID;
 
 	total = pAd->MacTab.Size * NUM_OF_TID;
@@ -537,12 +531,9 @@ VOID SendRefreshBAR(
 			MakeOutgoingFrame(pOutBuffer,				&FrameLen,
 							  sizeof(FRAME_BAR),	  &FrameBar,
 							  END_OF_ARGS);
-			//if (!(CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET)))
 			if (1)	// Now we always send BAR.
 			{
-				//MiniportMMRequestUnlock(pAd, 0, pOutBuffer, FrameLen);
 				MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
-				//MiniportDataMMRequest(pAd, MapUserPriorityToAccessCategory[TID], pOutBuffer, FrameLen);
 			}
 			MlmeFreeMemory(pAd, pOutBuffer);
 		}
@@ -571,8 +562,6 @@ VOID BarHeaderInit(
 	IN PUCHAR pDA,
 	IN PUCHAR pSA)
 {
-//	USHORT	Duration;
-
 	NdisZeroMemory(pCntlBar, sizeof(FRAME_BAR));
 	pCntlBar->FC.Type = BTYPE_CNTL;
 	pCntlBar->FC.SubType = SUBTYPE_BLOCK_ACK_REQ;
--- a/drivers/staging/rt3070/common/ba_action.c
+++ b/drivers/staging/rt3070/common/ba_action.c
@@ -445,9 +445,6 @@ void ba_flush_reordering_timeout_mpdus(
 		&& (pBAEntry->list.qlen > 0)
 	   )
 		{
-//		printk("timeout[%d] (%lx-%lx = %d > %d): %x, ", pBAEntry->list.qlen, Now32, (pBAEntry->LastIndSeqAtTimer),
-//			   (int)((long) Now32 - (long)(pBAEntry->LastIndSeqAtTimer)), REORDERING_PACKET_TIMEOUT,
-//			   pBAEntry->LastIndSeq);
     		//
 		// force LastIndSeq to shift to LastIndSeq+1
     		//
@@ -464,8 +461,6 @@ void ba_flush_reordering_timeout_mpdus(
     			pBAEntry->LastIndSeq = Sequence;
     		}
 
-		//printk("%x, flush one!\n", pBAEntry->LastIndSeq);
-
 	}
 }
 
@@ -1082,7 +1077,6 @@ VOID BAOriSessionSetupTimeout(
 		AddbaReq.Token = pBAEntry->Token;
 		MlmeEnqueue(pAd, ACTION_STATE_MACHINE, MT2_MLME_ADD_BA_CATE, sizeof(MLME_ADDBA_REQ_STRUCT), (PVOID)&AddbaReq);
 		RT28XX_MLME_HANDLER(pAd);
-		//DBGPRINT(RT_DEBUG_TRACE,("BA Ori Session Timeout(%d) : Send ADD BA again\n", pBAEntry->Token));
 
 		DBGPRINT(RT_DEBUG_TRACE,("BA Ori Session Timeout(%d) to %02x:%02x:%02x:%02x:%02x:%02x Tid:%d Wcid:%d\n"
 		,pBAEntry->Token
--- a/drivers/staging/rt3070/common/cmm_data_2870.c
+++ b/drivers/staging/rt3070/common/cmm_data_2870.c
@@ -931,15 +931,6 @@ VOID RT28xxUsbMlmeRadioOFF(
 	Value &= (0xfffffff3);
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
 
-	// MAC_SYS_CTRL => value = 0x0 => 40mA
-	//RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0);
-
-	// PWR_PIN_CFG => value = 0x0 => 40mA
-	//RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0);
-
-	// TX_PIN_CFG => value = 0x0 => 20mA
-	//RTMP_IO_WRITE32(pAd, TX_PIN_CFG, 0);
-
 	AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);
 }
 
--- a/drivers/staging/rt3070/common/cmm_data.c
+++ b/drivers/staging/rt3070/common/cmm_data.c
@@ -67,7 +67,6 @@ UCHAR	 RxwiMCSToOfdmRate[12] = {
 char*   MCSToMbps[] = {"1Mbps","2Mbps","5.5Mbps","11Mbps","06Mbps","09Mbps","12Mbps","18Mbps","24Mbps","36Mbps","48Mbps","54Mbps","MM-0","MM-1","MM-2","MM-3","MM-4","MM-5","MM-6","MM-7","MM-8","MM-9","MM-10","MM-11","MM-12","MM-13","MM-14","MM-15","MM-32","ee1","ee2","ee3"};
 
 UCHAR default_cwmin[]={CW_MIN_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1, CW_MIN_IN_BITS-2};
-//UCHAR default_cwmax[]={CW_MAX_IN_BITS, CW_MAX_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1};
 UCHAR default_sta_aifsn[]={3,7,2,2};
 
 UCHAR MapUserPriorityToAccessCategory[8] = {QID_AC_BE, QID_AC_BK, QID_AC_BK, QID_AC_BE, QID_AC_VI, QID_AC_VI, QID_AC_VO, QID_AC_VO};
@@ -362,17 +361,11 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
-	// Make sure MGMT ring resource won't be used by other threads
-// sample, for IRQ LOCK -> SEM LOCK
-//	IrqState = pAd->irq_disabled;
-//	if (!IrqState)
 		RTMP_SEM_LOCK(&pAd->MgmtRingLock);
 
 
 	if (pSrcBufVA == NULL)
 	{
-		// The buffer shouldn't be NULL
-//		if (!IrqState)
 			RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 		return NDIS_STATUS_FAILURE;
 	}
@@ -447,9 +440,6 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	}
 	else // BTYPE_MGMT or BTYPE_DATA(must be NULL frame)
 	{
-		//pAd->Sequence++;
-		//pHeader_802_11->Sequence = pAd->Sequence;
-
 		if (pHeader_802_11->Addr1[0] & 0x01) // MULTICAST, BROADCAST
 		{
 			bAckRequired = FALSE;
@@ -477,7 +467,6 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 		&& (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE))
 	{
 		DBGPRINT(RT_DEBUG_ERROR,("MlmeHardTransmit --> radar detect not in normal mode !!!\n"));
-//		if (!IrqState)
 			RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 		return (NDIS_STATUS_FAILURE);
 	}
@@ -491,7 +480,6 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	// Initialize TX Descriptor
 	// For inter-frame gap, the number is for this frame and next frame
 	// For MLME rate, we will fix as 2Mb to match other vendor's implement
-//	pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
 
 // management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not.
 	if (pMacEntry == NULL)
@@ -513,7 +501,6 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(
 	HAL_KickOutMgmtTx(pAd, QueIdx, pPacket, pSrcBufVA, SrcBufLen);
 
 	// Make sure to release MGMT ring resource
-//	if (!IrqState)
 		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 	return NDIS_STATUS_SUCCESS;
 }
@@ -712,9 +699,6 @@ BOOLEAN RTMP_FillTxBlkInfo(
 			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) &&
 				CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE))
 				TX_BLK_SET_FLAG(pTxBlk, fTX_bWMM);
-
-//			if (pAd->StaCfg.bAutoTxRateSwitch)
-//				TX_BLK_SET_FLAG(pTxBlk, fTX_AutoRateSwitch);
 		}
 
 		if (pTxBlk->TxFrameType == TX_LEGACY_FRAME)
@@ -905,7 +889,6 @@ VOID RTMPDeQueuePacket(
 
 			pTxBlk = &TxBlk;
 			NdisZeroMemory((PUCHAR)pTxBlk, sizeof(TX_BLK));
-			//InitializeQueueHeader(&pTxBlk->TxPacketList);		// Didn't need it because we already memzero it.
 			pTxBlk->QueIdx = QueIdx;
 
 			pPacket = QUEUE_ENTRY_TO_PKT(pEntry);
@@ -1266,7 +1249,7 @@ VOID RTMPWriteTxWI_Cache(
 	IN	OUT PTXWI_STRUC		pTxWI,
 	IN	TX_BLK				*pTxBlk)
 {
-	PHTTRANSMIT_SETTING	/*pTxHTPhyMode,*/ pTransmit;
+	PHTTRANSMIT_SETTING	pTransmit;
 	PMAC_TABLE_ENTRY	pMacEntry;
 
 	//
@@ -1275,9 +1258,6 @@ VOID RTMPWriteTxWI_Cache(
 	pMacEntry = pTxBlk->pMacEntry;
 	pTransmit = pTxBlk->pTransmit;
 
-	//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
-	//if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pMacEntry))
-	//if (TX_BLK_TEST_FLAG(pTxBlk, fTX_AutoRateSwitch))
 	if (pMacEntry->bAutoTxRateSwitch)
 	{
 		pTxWI->txop = IFS_HTTXOP;
@@ -1471,9 +1451,6 @@ PQUEUE_HEADER	RTMPCheckTxSwQueue(
 {
 
 	ULONG	Number;
-	// 2004-11-15 to be removed. test aggregation only
-//	if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)) && (*pNumber < 2))
-//		 return NULL;
 
 	Number = pAd->TxSwQueue[QID_AC_BK].Number
 			 + pAd->TxSwQueue[QID_AC_BE].Number
@@ -1573,8 +1550,6 @@ VOID	RTMPSuspendMsduTransmission(
 VOID RTMPResumeMsduTransmission(
 	IN	PRTMP_ADAPTER	pAd)
 {
-//    UCHAR			IrqState;
-
 	DBGPRINT(RT_DEBUG_TRACE,("SCAN done, resume MSDU transmission ...\n"));
 
 
@@ -1588,11 +1563,6 @@ VOID RTMPResumeMsduTransmission(
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, pAd->BbpTuning.R66CurrentValue);
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-// sample, for IRQ LOCK to SEM LOCK
-//    IrqState = pAd->irq_disabled;
-//	if (IrqState)
-//		RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-//    else
 	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
 }
 
@@ -1621,9 +1591,7 @@ UINT deaggregate_AMSDU_announce(
 
 		nMSDU++;
 
-		//hex_dump("subheader", pData, 64);
 		pAMSDUsubheader = (PHEADER_802_3)pData;
-		//pData += LENGTH_802_3;
 		PayloadSize = pAMSDUsubheader->Octet[1] + (pAMSDUsubheader->Octet[0]<<8);
 		SubFrameSize = PayloadSize + LENGTH_802_3;
 
@@ -1633,8 +1601,6 @@ UINT deaggregate_AMSDU_announce(
 			break;
 		}
 
-		//printk("%d subframe: Size = %d\n",  nMSDU, PayloadSize);
-
 		pPayload = pData + LENGTH_802_3;
 		pDA = pData;
 		pSA = pData + MAC_ADDR_LEN;
@@ -1754,8 +1720,6 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(
 	UCHAR HashIdx;
 	int i, FirstWcid;
 	MAC_TABLE_ENTRY *pEntry = NULL, *pCurrEntry;
-//	USHORT	offset;
-//	ULONG	addr;
 
 	// if FULL, return
 	if (pAd->MacTab.Size >= MAX_LEN_OF_MAC_TABLE)
@@ -1885,8 +1849,6 @@ BOOLEAN MacTableDeleteEntry(
 	USHORT HashIdx;
 	MAC_TABLE_ENTRY *pEntry, *pPrevEntry, *pProbeEntry;
 	BOOLEAN Cancelled;
-	//USHORT	offset;	// unused variable
-	//UCHAR	j;			// unused variable
 
 	if (wcid >= MAX_LEN_OF_MAC_TABLE)
 		return FALSE;
@@ -1894,7 +1856,6 @@ BOOLEAN MacTableDeleteEntry(
 	NdisAcquireSpinLock(&pAd->MacTabLock);
 
 	HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
-	//pEntry = pAd->MacTab.Hash[HashIdx];
 	pEntry = &pAd->MacTab.Content[wcid];
 
 	if (pEntry && (pEntry->ValidAsCLI || pEntry->ValidAsApCli || pEntry->ValidAsWDS || pEntry->ValidAsMesh
@@ -1962,7 +1923,6 @@ BOOLEAN MacTableDeleteEntry(
 	if (pAd->MacTab.Size == 0)
 	{
 		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 0;
-		//AsicUpdateProtect(pAd, 0 /*pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode*/, (ALLN_SETPROTECT), TRUE, 0 /*pAd->MacTab.fAnyStationNonGF*/);
 		RT28XX_UPDATE_PROTECT(pAd);  // edit by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet
 	}
 
--- a/drivers/staging/rt3070/common/cmm_info.c
+++ b/drivers/staging/rt3070/common/cmm_info.c
@@ -783,9 +783,6 @@ INT	Set_ResetStatCounter_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PUCHAR			arg)
 {
-	//UCHAR           i;
-	//MAC_TABLE_ENTRY *pEntry;
-
 	DBGPRINT(RT_DEBUG_TRACE, ("==>Set_ResetStatCounter_Proc\n"));
 
 	// add the most up-to-date h/w raw counters into software counters
@@ -1950,7 +1947,6 @@ INT	Set_BASetup_Proc(
 		=>The six 2 digit hex-decimal number previous are the Mac address,
 		=>The seventh decimal number is the tid value.
 */
-	//printk("\n%s\n", arg);
 
 	if(strlen(arg) < 19)  //Mac address acceptable format 01:02:03:04:05:06 length 17 plus the "-" and tid value in decimal format.
 		return FALSE;
@@ -2024,7 +2020,6 @@ INT	Set_BAOriTearDown_Proc(
 	INT i;
     MAC_TABLE_ENTRY *pEntry;
 
-    //printk("\n%s\n", arg);
 /*
 	The BAOriTearDown inupt string format should be xx:xx:xx:xx:xx:xx-d,
 		=>The six 2 digit hex-decimal number previous are the Mac address,
--- a/drivers/staging/rt3070/common/cmm_sanity.c
+++ b/drivers/staging/rt3070/common/cmm_sanity.c
@@ -81,14 +81,6 @@ BOOLEAN MlmeAddBAReqSanity(
         return FALSE;
     }
 
-	/*
-    if ((pInfo->BaBufSize > MAX_RX_REORDERBUF) || (pInfo->BaBufSize < 2))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("MlmeAddBAReqSanity fail - Rx Reordering buffer too big or too small\n"));
-        return FALSE;
-    }
-	*/
-
     if ((pInfo->pAddr[0]&0x01) == 0x01)
     {
         DBGPRINT(RT_DEBUG_TRACE, ("MlmeAddBAReqSanity fail - broadcast address not support BA\n"));
@@ -185,7 +177,6 @@ BOOLEAN PeerAddBARspActionSanity(
     IN VOID *pMsg,
     IN ULONG MsgLen)
 {
-	//PFRAME_802_11 pFrame = (PFRAME_802_11)pMsg;
 	PFRAME_ADDBA_RSP pAddFrame;
 
 	pAddFrame = (PFRAME_ADDBA_RSP)(pMsg);
@@ -341,8 +332,6 @@ BOOLEAN PeerBeaconAndProbeRspSanity(
     COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
     COPY_MAC_ADDR(pBssid, pFrame->Hdr.Addr3);
 
-//	hex_dump("Beacon", Msg, MsgLen);
-
     Ptr = pFrame->Octet;
     Length += LENGTH_802_11;
 
@@ -556,26 +545,6 @@ BOOLEAN PeerBeaconAndProbeRspSanity(
             // Wifi WMM use the same IE vale, need to parse that too
             // case IE_WPA:
             case IE_VENDOR_SPECIFIC:
-                // Check Broadcom/Atheros 802.11n OUI version, for HT Capability IE.
-                // This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
-                /*if (NdisEqualMemory(pEid->Octet, BROADCOM_OUI, 3) && (pEid->Len >= 4))
-                {
-                	if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 30))
-            		{
-				{
-					NdisMoveMemory(pHtCapability, &pEid->Octet[4], sizeof(HT_CAPABILITY_IE));
-					*pHtCapabilityLen = SIZE_HT_CAP_IE;	// Nnow we only support 26 bytes.
-				}
-         		}
-                	if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 26))
-            		{
-				{
-					NdisMoveMemory(AddHtInfo, &pEid->Octet[4], sizeof(ADD_HT_INFO_IE));
-					*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;	// Nnow we only support 26 bytes.
-				}
-         		}
-                }
-				*/
                 // Check the OUI version, filter out non-standard usage
                 if (NdisEqualMemory(pEid->Octet, RALINK_OUI, 3) && (pEid->Len == 7))
                 {
--- a/drivers/staging/rt3070/common/mlme.c
+++ b/drivers/staging/rt3070/common/mlme.c
@@ -243,19 +243,11 @@ UCHAR RateSwitchTable11BGN3S[] = { // 3*
     0x02, 0x21,  2, 20, 50,
     0x03, 0x21,  3, 20, 50,
     0x04, 0x21,  4, 15, 50,
-#if 1
     0x05, 0x20, 20, 15, 30,
     0x06, 0x20, 21,  8, 20,
     0x07, 0x20, 22,  8, 20,
     0x08, 0x20, 23,  8, 25,
     0x09, 0x22, 23,  8, 25,
-#else // for RT2860 2*3 test
-    0x05, 0x20, 12, 15, 30,
-    0x06, 0x20, 13,  8, 20,
-    0x07, 0x20, 14,  8, 20,
-    0x08, 0x20, 15,  8, 25,
-    0x09, 0x22, 15,  8, 25,
-#endif
 };
 
 UCHAR RateSwitchTable11BGN2SForABand[] = {
@@ -839,8 +831,6 @@ VOID MlmePeriodicExec(
 			rx_Total = 0;
 		}
 
-		//ORIBATimerTimeout(pAd);
-
 		// Media status changed, report to NDIS
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE))
 		{
@@ -990,8 +980,6 @@ VOID STAMlmePeriodicExec(
 			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - No BEACON. restore R66 to the low bound(%d) \n", (0x2E + GET_LNA_GAIN(pAd))));
 		}
 
-        //if ((pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
-        //    (pAd->RalinkCounters.OneSecTxRetryOkCount == 0))
         {
     		if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable)
     		{
@@ -1027,7 +1015,6 @@ VOID STAMlmePeriodicExec(
                 wireless_send_event(pAd->net_dev, SIOCGIWAP, &wrqu, NULL);
             }
 
-			// RTMPPatchMacBbpBug(pAd);
 			MlmeAutoReconnectLastSSID(pAd);
 		}
 		else if (CQI_IS_BAD(pAd->Mlme.ChannelQuality))
@@ -1307,8 +1294,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-		//if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
-		//	((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
 		if ((pEntry->RateLen == 12) && (pEntry->HTCapability.MCSSet[0] == 0xff) &&
 			((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1)))
 		{// 11BGN 1S AP
@@ -1319,8 +1304,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
-		//	(pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
 		if ((pEntry->RateLen == 12) && (pEntry->HTCapability.MCSSet[0] == 0xff) &&
 			(pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2))
 		{// 11BGN 2S AP
@@ -1341,7 +1324,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-		//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
 		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1)))
 		{// 11N 1S AP
 			*ppTable = RateSwitchTable11N1S;
@@ -1351,7 +1333,6 @@ VOID MlmeSelectTxRateTable(
 			break;
 		}
 
-		//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
 		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2))
 		{// 11N 2S AP
 			if (pAd->LatchRfRegs.Channel <= 14)
@@ -2086,7 +2067,6 @@ VOID MlmeDynamicTxRateSwitching(
 			else
 				TxRateIdx = MCS0;
 		}
-//		else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand) || (pTable == RateSwitchTable))
 		else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand)) // 3*3
 			{// N mode with 2 stream
 				if (MCS15 && (Rssi >= (-70+RssiOffset)))
@@ -2149,7 +2129,6 @@ VOID MlmeDynamicTxRateSwitching(
 					TxRateIdx = MCS0;
 			}
 
-	//		if (TxRateIdx != pAd->CommonCfg.TxRateIndex)
 			{
 				pEntry->CurrTxRateIndex = TxRateIdx;
 				pNextTxRate = (PRTMP_TX_RATE_SWITCH) &pTable[(pEntry->CurrTxRateIndex+1)*5];
@@ -2753,28 +2732,20 @@ VOID MlmeUpdateTxRates(
 	// specified; otherwise disabled
 	if (num <= 1)
 	{
-		//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= FALSE;
 		*auto_rate_cur_p = FALSE;
 	}
 	else
 	{
-		//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= TRUE;
 		*auto_rate_cur_p = TRUE;
 	}
 
 #if 1
 	if (HtMcs != MCS_AUTO)
 	{
-		//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= FALSE;
 		*auto_rate_cur_p = FALSE;
 	}
 	else
 	{
-		//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch	= TRUE;
 		*auto_rate_cur_p = TRUE;
 	}
 #endif
@@ -2860,14 +2831,6 @@ VOID MlmeUpdateTxRates(
 		pAd->CommonCfg.MaxTxRate = MaxDesire;
 
 	pAd->CommonCfg.MinTxRate = MinSupport;
-	// 2003-07-31 john - 2500 doesn't have good sensitivity at high OFDM rates. to increase the success
-	// ratio of initial DHCP packet exchange, TX rate starts from a lower rate depending
-	// on average RSSI
-	//	 1. RSSI >= -70db, start at 54 Mbps (short distance)
-	//	 2. -70 > RSSI >= -75, start at 24 Mbps (mid distance)
-	//	 3. -75 > RSSI, start at 11 Mbps (long distance)
-	//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)/* &&
-	//	OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)*/)
 	if (*auto_rate_cur_p)
 	{
 		short dbm = 0;
@@ -2936,11 +2899,7 @@ VOID MlmeUpdateTxRates(
 				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
 				pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
 
-//#ifdef	WIFI_TEST
 				pAd->CommonCfg.RtsRate = RATE_11;
-//#else
-//				pAd->CommonCfg.RtsRate = RATE_1;
-//#endif
 				break;
 			case PHY_11G:
 			case PHY_11A:
@@ -4289,8 +4248,6 @@ VOID MgtMacHeaderInit(
 
 	pHdr80211->FC.Type = BTYPE_MGMT;
 	pHdr80211->FC.SubType = SubType;
-//	if (SubType == SUBTYPE_ACK)	// sample, no use, it will conflict with ACTION frame sub type
-//		pHdr80211->FC.Type = BTYPE_CNTL;
 	pHdr80211->FC.ToDs = ToDs;
 	COPY_MAC_ADDR(pHdr80211->Addr1, pDA);
 
@@ -6193,10 +6150,7 @@ VOID AsicAdjustTxPower(
 						break;
 				}
 				// The index is the step we should decrease, idx = 0 means there is nothing to compensate
-//				if (R3 > (ULONG) (TxAgcStep * (idx-1)))
 					*pTxAgcCompensate = -(TxAgcStep * (idx-1));
-//				else
-//					*pTxAgcCompensate = -((UCHAR)R3);
 
 				DeltaPwr += (*pTxAgcCompensate);
 				DBGPRINT(RT_DEBUG_TRACE, ("-- Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = -%d\n",
@@ -6479,11 +6433,6 @@ VOID AsicDisableRDG(
 	RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
 
 	Data  &= 0xFFFFFF00;
-	//Data  |= 0x20;
-#ifndef WIFI_TEST
-	//if ( pAd->CommonCfg.bEnableTxBurst )
-	//	Data |= 0x60; // for performance issue not set the TXOP to 0
-#endif
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_DYNAMIC_BE_TXOP_ACTIVE)
 		&& (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
 	)
@@ -6540,7 +6489,6 @@ VOID AsicEnableBssSync(
 	DBGPRINT(RT_DEBUG_TRACE, ("--->AsicEnableBssSync(INFRA mode)\n"));
 
 	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-//	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, 0x00000000);
 
 	{
 		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
@@ -6586,8 +6534,6 @@ VOID AsicEnableIbssSync(
 	ptr = (PUCHAR)&pAd->BeaconTxWI;
 	for (i=0; i<TXWI_SIZE; i+=2)  // 16-byte TXWI field
 	{
-		//UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
-		//RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + i, longptr);
 		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + i, ptr, 2);
 		ptr += 2;
 	}
@@ -6596,19 +6542,11 @@ VOID AsicEnableIbssSync(
 	ptr = pAd->BeaconBuf;
 	for (i=0; i< pAd->BeaconTxWI.MPDUtotalByteCount; i+=2)
 	{
-		//UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
-		//RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr);
 		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, ptr, 2);
 		ptr +=2;
 	}
 #endif // RT2870 //
 
-	//
-	// For Wi-Fi faily generated beacons between participating stations.
-	// Set TBTT phase adaptive adjustment step to 8us (default 16us)
-	// don't change settings 2006-5- by Jerry
-	//RTMP_IO_WRITE32(pAd, TBTT_SYNC_CFG, 0x00001010);
-
 	// start sending BEACON
 	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; // ASIC register in units of 1/16 TU
 	csr9.field.bTsfTicking = 1;
@@ -6656,7 +6594,6 @@ VOID AsicSetEdcaParm(
 		//========================================================
 		//      MAC Register has a copy .
 		//========================================================
-//#ifndef WIFI_TEST
 		if( pAd->CommonCfg.bEnableTxBurst )
 		{
 			// For CWC test, change txop from 0x30 to 0x20 in TxBurst mode
@@ -6664,9 +6601,6 @@ VOID AsicSetEdcaParm(
 		}
 		else
 			Ac0Cfg.field.AcTxop = 0;	// QID_AC_BE
-//#else
-//		Ac0Cfg.field.AcTxop = 0;	// QID_AC_BE
-//#endif
 		Ac0Cfg.field.Cwmin = CW_MIN_IN_BITS;
 		Ac0Cfg.field.Cwmax = CW_MAX_IN_BITS;
 		Ac0Cfg.field.Aifsn = 2;
@@ -7175,18 +7109,14 @@ VOID AsicAddKeyEntry(
 	IN BOOLEAN		bTxKey)
 {
 	ULONG	offset;
-//	ULONG   WCIDAttri = 0;
 	UCHAR	IV4 = 0;
 	PUCHAR		pKey = pCipherKey->Key;
-//	ULONG		KeyLen = pCipherKey->KeyLen;
 	PUCHAR		pTxMic = pCipherKey->TxMic;
 	PUCHAR		pRxMic = pCipherKey->RxMic;
 	PUCHAR		pTxtsc = pCipherKey->TxTsc;
 	UCHAR		CipherAlg = pCipherKey->CipherAlg;
 	SHAREDKEY_MODE_STRUC csr1;
 
-//	ASSERT(KeyLen <= MAX_LEN_OF_PEER_KEY);
-
 	DBGPRINT(RT_DEBUG_TRACE, ("==> AsicAddKeyEntry\n"));
 	//
 	// 1.) decide key table offset
@@ -8054,19 +7984,6 @@ VOID APSDPeriodicExec(
 		return;
 
 	pAd->CommonCfg.TriggerTimerCount++;
-
-// Driver should not send trigger frame, it should be send by application layer
-/*
-	if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable
-		&& (pAd->CommonCfg.bNeedSendTriggerFrame ||
-		(((pAd->CommonCfg.TriggerTimerCount%20) == 19) && (!pAd->CommonCfg.bAPSDAC_BE || !pAd->CommonCfg.bAPSDAC_BK || !pAd->CommonCfg.bAPSDAC_VI || !pAd->CommonCfg.bAPSDAC_VO))))
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("Sending trigger frame and enter service period when support APSD\n"));
-		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
-		pAd->CommonCfg.bNeedSendTriggerFrame = FALSE;
-		pAd->CommonCfg.TriggerTimerCount = 0;
-		pAd->CommonCfg.bInServicePeriod = TRUE;
-	}*/
 }
 
 /*
--- a/drivers/staging/rt3070/common/rtmp_init.c
+++ b/drivers/staging/rt3070/common/rtmp_init.c
@@ -172,18 +172,13 @@ RTMP_REG_PAIR	MACRegTable[] =	{
 	{MAC_SYS_CTRL,		0x00}, // 0x1004, , default Disable RX
 	{RX_FILTR_CFG,		0x17f97}, //0x1400  , RX filter control,
 	{BKOFF_SLOT_CFG,	0x209}, // default set short slot time, CC_DELAY_TIME should be 2
-	//{TX_SW_CFG0,		0x40a06}, // Gary,2006-08-23
 	{TX_SW_CFG0,		0x0}, 		// Gary,2008-05-21 for CWC test
 	{TX_SW_CFG1,		0x80606}, // Gary,2006-08-23
 	{TX_LINK_CFG,		0x1020},		// Gary,2006-08-23
 	{TX_TIMEOUT_CFG,	0x000a2090},
 	{MAX_LEN_CFG,		MAX_AGGREGATION_SIZE | 0x00001000},	// 0x3018, MAX frame length. Max PSDU = 16kbytes.
 	{LED_CFG,		0x7f031e46}, // Gary, 2006-08-23
-//	{WMM_AIFSN_CFG,		0x00002273},
-//	{WMM_CWMIN_CFG,		0x00002344},
-//	{WMM_CWMAX_CFG,		0x000034aa},
 	{PBF_MAX_PCNT,			0x1F3FBF9F}, 	//0x1F3f7f9f},		//Jan, 2006/04/20
-	//{TX_RTY_CFG,			0x6bb80408},	// Jan, 2006/11/16
 	{TX_RTY_CFG,			0x47d01f0f},	// Jan, 2006/11/16, Set TxWI->ACK =0 in Probe Rsp Modify for 2860E ,2007-08-03
 	{AUTO_RSP_CFG,			0x00000013},	// Initial Auto_Responder, because QA will turn off Auto-Responder
 	{CCK_PROT_CFG,			0x05740003 /*0x01740003*/},	// Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled.
@@ -199,11 +194,7 @@ RTMP_REG_PAIR	MACRegTable[] =	{
 	{MM20_PROT_CFG,			0x01744004},
 	{TXOP_CTRL_CFG,			0x0000583f, /*0x0000243f*/ /*0x000024bf*/},	//Extension channel backoff.
 	{TX_RTS_CFG,			0x00092b20},
-//#ifdef WIFI_TEST
 	{EXP_ACK_TIME,			0x002400ca},	// default value
-//#else
-//	{EXP_ACK_TIME,			0x005400ca},	// suggested by Gray @ 20070323 for 11n intel-sta throughput
-//#endif // end - WIFI_TEST //
 	{TXOP_HLDR_ET, 			0x00000002},
 
 	/* Jerry comments 2008/01/16: we use SIFS = 10us in CCK defaultly, but it seems that 10us
@@ -880,8 +871,6 @@ VOID	RTMPReadChannelPwr(
 	// 0. 11b/g, ch1 - ch 14
 	for (i = 0; i < 7; i++)
 	{
-//		Power.word = RTMP_EEPROM_READ16(pAd, EEPROM_G_TX_PWR_OFFSET + i * 2);
-//		Power2.word = RTMP_EEPROM_READ16(pAd, EEPROM_G_TX2_PWR_OFFSET + i * 2);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX_PWR_OFFSET + i * 2, Power.word);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX2_PWR_OFFSET + i * 2, Power2.word);
 		pAd->TxPower[i * 2].Channel = i * 2 + 1;
@@ -929,8 +918,6 @@ VOID	RTMPReadChannelPwr(
 	// 1.2 Fill up power
 	for (i = 0; i < 6; i++)
 	{
-//		Power.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + i * 2);
-//		Power2.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + i * 2);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + i * 2, Power.word);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + i * 2, Power2.word);
 
@@ -971,8 +958,6 @@ VOID	RTMPReadChannelPwr(
 	// 2.2 Fill up power
 	for (i = 0; i < 8; i++)
 	{
-//		Power.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2);
-//		Power2.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2, Power.word);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2, Power2.word);
 
@@ -1013,8 +998,6 @@ VOID	RTMPReadChannelPwr(
 	// 3.2 Fill up power
 	for (i = 0; i < 4; i++)
 	{
-//		Power.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2);
-//		Power2.word = RTMP_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + (choffset - 14) + i * 2, Power.word);
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX2_PWR_OFFSET + (choffset - 14) + i * 2, Power2.word);
 
@@ -1860,7 +1843,6 @@ VOID	NICInitAsicFromEEPROM(
 			{
 				pAd->StaCfg.bHwRadio = FALSE;
 				pAd->StaCfg.bRadio = FALSE;
-//				RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818);
 				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 			}
 		}
@@ -1880,7 +1862,6 @@ VOID	NICInitAsicFromEEPROM(
 	// Turn off patching for cardbus controller
 	if (NicConfig2.field.CardbusAcceleration == 1)
 	{
-//		pAd->bTest1 = TRUE;
 	}
 
 	if (NicConfig2.field.DynamicTxAgcControl == 1)
@@ -1949,7 +1930,6 @@ NDIS_STATUS	NICInitializeAdapter(
 {
 	NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
 	WPDMA_GLO_CFG_STRUC	GloCfg;
-//	INT_MASK_CSR_STRUC		IntMask;
 	ULONG	i =0, j=0;
 	AC_TXOP_CSR0_STRUC	csr0;
 
@@ -2303,9 +2283,6 @@ NDIS_STATUS	NICInitializeAsic(
 	}
 	}
 
-	// assert HOST ready bit
-//  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x0); // 2004-09-14 asked by Mark
-//  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x4);
 
 	// It isn't necessary to clear this space when not hard reset.
 	if (bHardReset == TRUE)
@@ -2382,9 +2359,6 @@ VOID	NICIssueReset(
 	UINT32	Value = 0;
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICIssueReset\n"));
 
-	// Abort Tx, prevent ASIC from writing to Host memory
-	//RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x001f0000);
-
 	// Disable Rx, register value supposed will remain after reset
 	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
 	Value &= (0xfffffff3);
@@ -2566,9 +2540,7 @@ VOID NICUpdateFifoStaCounters(
 VOID NICUpdateRawCounters(
 	IN PRTMP_ADAPTER pAd)
 {
-	UINT32	OldValue;//, Value2;
-	//ULONG	PageSum, OneSecTransmitCount;
-	//ULONG	TxErrorRatio, Retry, Fail;
+	UINT32	OldValue;
 	RX_STA_CNT0_STRUC	 RxStaCnt0;
 	RX_STA_CNT1_STRUC   RxStaCnt1;
 	RX_STA_CNT2_STRUC   RxStaCnt2;
@@ -2615,7 +2587,6 @@ VOID NICUpdateRawCounters(
 	// Update RX Overflow counter
 	pAd->Counters8023.RxNoBuffer += (RxStaCnt2.field.RxFifoOverflowCount);
 
-	//pAd->RalinkCounters.RxCount = 0;
 #ifdef RT2870
 	if (pAd->RalinkCounters.RxCount != pAd->watchDogRxCnt)
 	{
@@ -2632,8 +2603,6 @@ VOID NICUpdateRawCounters(
 #endif // RT2870 //
 
 
-	//if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) ||
-	//	(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) && (pAd->MacTab.Size != 1)))
 	if (!pAd->bUpdateBcnCntDone)
 	{
 	// Update BEACON sent count
@@ -2649,7 +2618,6 @@ VOID NICUpdateRawCounters(
 	pAd->WlanCounters.FailedCount.u.LowPart += TxStaCnt0.field.TxFailCount;
 	}
 
-	//if (pAd->bStaFifoTest == TRUE)
 	{
 		RTMP_IO_READ32(pAd, TX_AGG_CNT, &TxAggCnt.word);
 		RTMP_IO_READ32(pAd, TX_AGG_CNT0, &TxAggCnt0.word);
@@ -2763,7 +2731,6 @@ VOID NICUpdateRawCounters(
 			pDiag->TxFailCnt[ArrayCurIdx] = 0;
 			pDiag->RxDataCnt[ArrayCurIdx] = 0;
 			pDiag->RxCrcErrCnt[ArrayCurIdx]  = 0;
-//			for (i = 9; i < 16; i++)
 			for (i = 9; i < 24; i++) // 3*3
 			{
 				pDiag->TxDescCnt[ArrayCurIdx][i] = 0;
@@ -3158,7 +3125,6 @@ VOID	RTMPMoveMemory(
 VOID	UserCfgInit(
 	IN	PRTMP_ADAPTER pAd)
 {
-//	EDCA_PARM DefaultEdcaParm;
     UINT key_index, bss_index;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> UserCfgInit\n"));
@@ -3404,17 +3370,11 @@ VOID	UserCfgInit(
 	pAd->Bbp94 = BBPR94_DEFAULT;
 	pAd->BbpForCCK = FALSE;
 
-	// Default is FALSE for test bit 1
-	//pAd->bTest1 = FALSE;
-
 	// initialize MAC table and allocate spin lock
 	NdisZeroMemory(&pAd->MacTab, sizeof(MAC_TABLE));
 	InitializeQueueHeader(&pAd->MacTab.McastPsQueue);
 	NdisAllocateSpinLock(&pAd->MacTabLock);
 
-	//RTMPInitTimer(pAd, &pAd->RECBATimer, RECBATimerTimeout, pAd, TRUE);
-	//RTMPSetTimer(&pAd->RECBATimer, REORDER_EXEC_INTV);
-
 	pAd->CommonCfg.bWiFiTest = FALSE;
 
 
@@ -3830,9 +3790,6 @@ VOID RTMPSetSignalLED(
 VOID RTMPEnableRxTx(
 	IN PRTMP_ADAPTER	pAd)
 {
-//	WPDMA_GLO_CFG_STRUC	GloCfg;
-//	ULONG	i = 0;
-
 	DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPEnableRxTx\n"));
 
 	// Enable Rx DMA.
--- a/drivers/staging/rt3070/common/rtmp_tkip.c
+++ b/drivers/staging/rt3070/common/rtmp_tkip.c
@@ -464,7 +464,6 @@ VOID	RTMPInitTkipEngine(
 	tkipIv.IV16.field.rc2 = *pTSC;
 	tkipIv.IV16.field.CONTROL.field.ExtIV = 1;  // 0: non-extended IV, 1: an extended IV
 	tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
-//	tkipIv.IV32 = *(PULONG)(pTSC + 2);
 	NdisMoveMemory(&tkipIv.IV32, (pTSC + 2), 4);   // Copy IV
 
 	*pIV16 = tkipIv.IV16.word;
@@ -1211,11 +1210,9 @@ BOOLEAN RTMPSoftDecryptTKIP(
 	if (!NdisEqualMemory(MIC, TrailMIC, 8))
 	{
 		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptTKIP, WEP Data MIC Error !\n"));	 //MIC error.
-		//RTMPReportMicError(pAd, &pWpaKey[KeyID]);	// marked by AlbertY @ 20060630
 		return (FALSE);
 	}
 
-	//DBGPRINT(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP Decript done!!\n");
 	return TRUE;
 }
 
--- a/drivers/staging/rt3070/common/rtmp_wep.c
+++ b/drivers/staging/rt3070/common/rtmp_wep.c
@@ -106,15 +106,6 @@ UINT FCSTAB_32[256] =
 };
 
 /*
-UCHAR   WEPKEY[] = {
-		//IV
-		0x00, 0x11, 0x22,
-		//WEP KEY
-		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC
-	};
- */
-
-/*
 	========================================================================
 
 	Routine	Description:
--- a/drivers/staging/rt3070/mlme.h
+++ b/drivers/staging/rt3070/mlme.h
@@ -39,8 +39,6 @@
 #ifndef __MLME_H__
 #define __MLME_H__
 
-//extern UCHAR BROADCAST_ADDR[];
-
 // maximum supported capability information -
 // ESS, IBSS, Privacy, Short Preamble, Spectrum mgmt, Short Slot
 #define SUPPORTED_CAPABILITY_INFO   0x0533
@@ -51,7 +49,6 @@
 #define LEAD_TIME                   5
 #define MLME_TASK_EXEC_MULTIPLE       10  /*5*/       // MLME_TASK_EXEC_MULTIPLE * MLME_TASK_EXEC_INTV = 1 sec
 #define REORDER_EXEC_INTV         	100       // 0.1 sec
-//#define TBTT_PRELOAD_TIME         384        // usec. LomgPreamble + 24-byte at 1Mbps
 
 // The definition of Radar detection duration region
 #define CE		0
@@ -106,13 +103,6 @@
 #define TX_WEIGHTING                     30
 #define RX_WEIGHTING                     20
 
-//#define PEER_KEY_NOT_USED                0
-//#define PEER_KEY_64_BIT                  64
-//#define PEER_KEY_128_BIT                 128
-
-//#define PEER_KEY_64BIT_LEN               8
-//#define PEER_KEY_128BIT_LEN              16
-
 #define BSS_NOT_FOUND                    0xFFFFFFFF
 
 #define MAX_LEN_OF_MLME_QUEUE            40 //10
@@ -125,7 +115,6 @@
 #define	SCAN_CISCO_CHANNEL_LOAD			 23		// Single channel passive scan for channel load collection
 #define FAST_SCAN_ACTIVE                 24		// scan with probe request, and wait beacon and probe response
 
-//#define BSS_TABLE_EMPTY(x)             ((x).BssNr == 0)
 #define MAC_ADDR_IS_GROUP(Addr)       (((Addr[0]) & 0x01))
 #define MAC_ADDR_HASH(Addr)            (Addr[0] ^ Addr[1] ^ Addr[2] ^ Addr[3] ^ Addr[4] ^ Addr[5])
 #define MAC_ADDR_HASH_INDEX(Addr)      (MAC_ADDR_HASH(Addr) % HASH_TABLE_SIZE)
@@ -157,8 +146,6 @@
 
 #define CAP_GENERATE(ess,ibss,priv,s_pre,s_slot,spectrum)  (((ess) ? 0x0001 : 0x0000) | ((ibss) ? 0x0002 : 0x0000) | ((priv) ? 0x0010 : 0x0000) | ((s_pre) ? 0x0020 : 0x0000) | ((s_slot) ? 0x0400 : 0x0000) | ((spectrum) ? 0x0100 : 0x0000))
 
-//#define STA_QOS_CAPABILITY               0 // 1-byte. see 802.11e d9.0 for bit definition
-
 #define ERP_IS_NON_ERP_PRESENT(x)        (((x) & 0x01) != 0)    // 802.11g
 #define ERP_IS_USE_PROTECTION(x)         (((x) & 0x02) != 0)    // 802.11g
 #define ERP_IS_USE_BARKER_PREAMBLE(x)    (((x) & 0x04) != 0)    // 802.11g
@@ -1093,11 +1080,6 @@ typedef struct PACKED _RTMP_TX_RATE_SWIT
 #define TBTT_PRELOAD_TIME       384        // usec. LomgPreamble + 24-byte at 1Mbps
 #define DEFAULT_DTIM_PERIOD     1
 
-// weighting factor to calculate Channel quality, total should be 100%
-//#define RSSI_WEIGHTING                   0
-//#define TX_WEIGHTING                     40
-//#define RX_WEIGHTING                     60
-
 #define MAC_TABLE_AGEOUT_TIME			300			// unit: sec
 #define MAC_TABLE_ASSOC_TIMEOUT			5			// unit: sec
 #define MAC_TABLE_FULL(Tab)				((Tab).size == MAX_LEN_OF_MAC_TABLE)
--- a/drivers/staging/rt3070/oid.h
+++ b/drivers/staging/rt3070/oid.h
@@ -37,9 +37,6 @@
 #ifndef _OID_H_
 #define _OID_H_
 
-//#include <linux/wireless.h>
-
-
 #define TRUE				1
 #define FALSE				0
 //
@@ -588,19 +585,6 @@ typedef struct _NDIS_802_11_AUTHENTICATI
     NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
 } NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
 
-/*
-typedef struct _NDIS_802_11_TEST
-{
-    ULONG Length;
-    ULONG Type;
-    union
-    {
-        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
-        NDIS_802_11_RSSI RssiTrigger;
-    };
-} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
- */
-
 // 802.11 Media stream constraints, associated with OID_802_11_MEDIA_STREAM_MODE
 typedef enum _NDIS_802_11_MEDIA_STREAM_MODE
 {
@@ -683,8 +667,6 @@ enum {
 #define OID_802_11_GET_COUNTRY_CODE				0x0716
 #define OID_802_11_GET_CHANNEL_GEOGRAPHY		0x0717
 
-//#define RT_OID_802_11_STATISTICS              (OID_GET_SET_TOGGLE | OID_802_11_STATISTICS)
-
 #define RT_OID_WSC_SET_PASSPHRASE                   0x0740 // passphrase for wpa(2)-psk
 #define RT_OID_WSC_DRIVER_AUTO_CONNECT              0x0741
 #define RT_OID_WSC_QUERY_DEFAULT_PROFILE            0x0742
@@ -714,10 +696,6 @@ enum {
 #define RT_OID_GET_PHY_MODE                         0x761
 #endif // LLTD_SUPPORT //
 
-//Add Paul Chen for Accton
-//#define RT_OID_TX_POWER_LEVEL                 0xFF020010
-//#define RT_OID_SET_TX_POWER_LEVEL	          (OID_GET_SET_TOGGLE | RT_OID_TX_POWER_LEVEL)
-
 // New for MeetingHouse Api support
 #define OID_MH_802_1X_SUPPORTED               0xFFEDC100
 
@@ -728,7 +706,6 @@ typedef union  _HTTRANSMIT_SETTING {
 	USHORT		BW:1;	//channel bandwidth 20MHz or 40 MHz
 	USHORT		ShortGI:1;
 	USHORT		STBC:2;	//SPACE
-//	USHORT		rsv:3;
 	USHORT		rsv:2;
 	USHORT		TxBF:1;
 	USHORT		MODE:2;	// Use definition MODE_xxx.
@@ -743,7 +720,6 @@ typedef enum _RT_802_11_PREAMBLE {
 } RT_802_11_PREAMBLE, *PRT_802_11_PREAMBLE;
 
 // Only for STA, need to sync with AP
-// 2005-03-08 match current RaConfig.
 typedef enum _RT_802_11_PHY_MODE {
 	PHY_11BG_MIXED = 0,
 	PHY_11B,
@@ -817,15 +793,6 @@ typedef struct _RT_802_11_HARDWARE_REGIS
     ULONG   Data;               // R/W data buffer
 } RT_802_11_HARDWARE_REGISTER, *PRT_802_11_HARDWARE_REGISTER;
 
-// structure to tune BBP R17 "RX AGC VGC init"
-//typedef struct _RT_802_11_RX_AGC_VGC_TUNING {
-//    UCHAR   FalseCcaLowerThreshold;  // 0-255, def 10
-//    UCHAR   FalseCcaUpperThreshold;  // 0-255, def 100
-//    UCHAR   VgcDelta;                // R17 +-= VgcDelta whenever flase CCA over UpprThreshold
-//                                     // or lower than LowerThresholdupper threshold
-//    UCHAR   VgcUpperBound;           // max value of R17
-//} RT_802_11_RX_AGC_VGC_TUNING, *PRT_802_11_RX_AGC_VGC_TUNING;
-
 typedef struct _RT_802_11_AP_CONFIG {
     ULONG   EnableTxBurst;      // 0-disable, 1-enable
     ULONG   EnableTurboRate;    // 0-disable, 1-enable 72/100mbps turbo rate
--- a/drivers/staging/rt3070/rt28xx.h
+++ b/drivers/staging/rt3070/rt28xx.h
@@ -1049,11 +1049,6 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 #define MAX_FIRMWARE_IMAGE_SIZE 0x1000    // 4kbyte
 #endif // RT2870 //
 
-// TODO: ????? old RT2560 registers. to keep them or remove them?
-//#define MCAST0                  0x0178  // multicast filter register 0
-//#define MCAST1                  0x017c  // multicast filter register 1
-
-
 // ================================================================
 // Tx /	Rx / Mgmt ring descriptor definition
 // ================================================================
@@ -1181,11 +1176,6 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 
 #define BBPR94_DEFAULT              0x06 // Add 1 value will gain 1db
 
-//#define PHY_TR_SWITCH_TIME          5  // usec
-
-//#define BBP_R17_LOW_SENSIBILITY     0x50
-//#define BBP_R17_MID_SENSIBILITY     0x41
-//#define BBP_R17_DYNAMIC_UP_BOUND    0x40
 #define RSSI_FOR_VERY_LOW_SENSIBILITY -35
 #define RSSI_FOR_LOW_SENSIBILITY      -58
 #define RSSI_FOR_MID_LOW_SENSIBILITY  -80
@@ -1225,12 +1215,6 @@ typedef struct _HW_WCID_ENTRY {  // 8-by
 #define EEPROM_TXPOWER_BYRATE_40MHZ_5G		0x10a	// 40MHZ 5G tx power.
 #define EEPROM_A_TX_PWR_OFFSET      0x78
 #define EEPROM_A_TX2_PWR_OFFSET      0xa6
-//#define EEPROM_Japan_TX_PWR_OFFSET      0x90 // 802.11j
-//#define EEPROM_Japan_TX2_PWR_OFFSET      0xbe
-//#define EEPROM_TSSI_REF_OFFSET	0x54
-//#define EEPROM_TSSI_DELTA_OFFSET	0x24
-//#define EEPROM_CCK_TX_PWR_OFFSET  0x62
-//#define EEPROM_CALIBRATE_OFFSET	0x7c
 #define EEPROM_VERSION_OFFSET       0x02
 #define	EEPROM_FREQ_OFFSET			0x3a
 #define EEPROM_TXPOWER_BYRATE 	0xde	// 20MHZ power.
@@ -1334,7 +1318,6 @@ typedef	struct	PACKED _TXWI_STRUC {
 	UINT32		ShortGI:1;
 	UINT32		STBC:2;	// 1: STBC support MCS =0-7,   2,3 : RESERVE
 	UINT32		Ifs:1;	//
-//	UINT32		rsv2:2;	//channel bandwidth 20MHz or 40 MHz
 	UINT32		rsv2:1;
 	UINT32		TxBF:1;	// 3*3
 	UINT32		PHYMODE:2;
--- a/drivers/staging/rt3070/rt_linux.c
+++ b/drivers/staging/rt3070/rt_linux.c
@@ -30,7 +30,6 @@
 ULONG	RTDebugLevel = RT_DEBUG_ERROR;
 
 BUILD_TIMER_FUNCTION(MlmePeriodicExec);
-//BUILD_TIMER_FUNCTION(MlmeRssiReportExec);
 BUILD_TIMER_FUNCTION(AsicRxAntEvalTimeout);
 BUILD_TIMER_FUNCTION(APSDPeriodicExec);
 BUILD_TIMER_FUNCTION(AsicRfTuningExec);
@@ -668,9 +667,6 @@ void announce_802_3_packet(
 #else
 	pRxPkt->protocol = eth_type_trans(pRxPkt, pRxPkt->dev);
 
-//#ifdef CONFIG_5VT_ENHANCE
-//	*(int*)(pRxPkt->cb) = BRIDGE_TAG;
-//#endif
 	netif_rx(pRxPkt);
 #endif // IKANOS_VX_1X0 //
 }
--- a/drivers/staging/rt3070/rt_linux.h
+++ b/drivers/staging/rt3070/rt_linux.h
@@ -193,9 +193,6 @@ typedef char				NDIS_PACKET;
 typedef PNDIS_PACKET		* PPNDIS_PACKET;
 typedef	dma_addr_t			NDIS_PHYSICAL_ADDRESS;
 typedef	dma_addr_t			* PNDIS_PHYSICAL_ADDRESS;
-//typedef struct timer_list	RALINK_TIMER_STRUCT;
-//typedef struct timer_list	* PRALINK_TIMER_STRUCT;
-//typedef struct os_lock		NDIS_SPIN_LOCK;
 typedef spinlock_t			NDIS_SPIN_LOCK;
 typedef struct timer_list	NDIS_MINIPORT_TIMER;
 typedef void				* NDIS_HANDLE;
@@ -293,8 +290,6 @@ typedef struct _RT2870_TIMER_ENTRY_
 typedef struct _RT2870_TIMER_QUEUE_
 {
 	unsigned int		status;
-	//wait_queue_head_t 	timerWaitQ;
-	//atomic_t			count;
 	UCHAR				*pTimerQPoll;
 	RT2870_TIMER_ENTRY	*pQPollFreeList;
 	RT2870_TIMER_ENTRY 	*pQHead;
@@ -456,7 +451,6 @@ do { \
 		wait_event_interruptible_timeout(_wait, 0, ONE_TICK); }
 
 
-/* Modified by Wu Xi-Kun 4/21/2006 */
 typedef void (*TIMER_FUNCTION)(unsigned long);
 
 #define COPY_MAC_ADDR(Addr1, Addr2)             memcpy((Addr1), (Addr2), MAC_ADDR_LEN)
@@ -574,7 +568,6 @@ void RTMP_GetCurrentSystemTime(LARGE_INT
 //   check DDK NDIS_PACKET data structure and find out only MiniportReservedEx[0..7] can be used by our driver without
 //   ambiguity. Fields after pPacket->MiniportReservedEx[8] may be used by other wrapper layer thus crashes the driver
 //
-//#define RTMP_GET_PACKET_MR(_p)			(RTPKT_TO_OSPKT(_p))
 
 // User Priority
 #define RTMP_SET_PACKET_UP(_p, _prio)			(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+0] = _prio)
@@ -616,8 +609,6 @@ void RTMP_GetCurrentSystemTime(LARGE_INT
 #define RTMP_SET_PACKET_MOREDATA(_p, _morebit)		(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+7] = _morebit)
 #define RTMP_GET_PACKET_MOREDATA(_p)				(RTPKT_TO_OSPKT(_p)->cb[CB_OFF+7])
 
-//#define RTMP_SET_PACKET_NET_DEVICE_MBSSID(_p, _bss)	(RTPKT_TO_OSPKT(_p)->cb[8] = _bss)
-//#define RTMP_GET_PACKET_NET_DEVICE_MBSSID(_p)		(RTPKT_TO_OSPKT(_p)->cb[8])
 
 //
 //	Sepcific Pakcet Type definition
--- a/drivers/staging/rt3070/rt_main_dev.c
+++ b/drivers/staging/rt3070/rt_main_dev.c
@@ -46,7 +46,7 @@
 //static RALINK_TIMER_STRUCT     PeriodicTimer;
 
 char *mac = "";		   // default 00:00:00:00:00:00
-char *hostname = "";		   // default CMPC
+char *hostname = "";
 module_param (mac, charp, 0);
 MODULE_PARM_DESC (mac, "rt28xx: wireless mac addr");
 
@@ -68,7 +68,6 @@ static int rt28xx_init(IN struct net_dev
 INT rt28xx_send_packets(IN struct sk_buff *skb_p, IN struct net_device *net_dev);
 
 static void CfgInitHook(PRTMP_ADAPTER pAd);
-//static BOOLEAN RT28XXAvailRANameAssign(IN CHAR *name_p);
 
 extern	const struct iw_handler_def rt28xx_iw_handler_def;
 
@@ -288,9 +287,6 @@ int rt28xx_close(IN PNET_DEV dev)
 	remove_wait_queue (&unlink_wakeup, &wait);
 #endif // RT2870 //
 
-	//RTUSBCleanUpMLMEWaitQueue(pAd);	/*not used in RT28xx*/
-
-
 #ifdef RT2870
 	// We need clear timerQ related structure before exits of the timer thread.
 	RT2870_TimerQ_Exit(pAd);
@@ -331,10 +327,7 @@ static int rt28xx_init(IN struct net_dev
 	PRTMP_ADAPTER 			pAd = net_dev->ml_priv;
 	UINT					index;
 	UCHAR					TmpPhy;
-//	ULONG					Value=0;
 	NDIS_STATUS				Status;
-//    OID_SET_HT_PHYMODE		SetHT;
-//	WPDMA_GLO_CFG_STRUC     GloCfg;
 	UINT32 		MacCsr0 = 0;
 
 	// Allocate BA Reordering memory
@@ -405,9 +398,6 @@ static int rt28xx_init(IN struct net_dev
 	if (Status != NDIS_STATUS_SUCCESS)
 		goto err1;
 
-//	COPY_MAC_ADDR(pAd->ApCfg.MBSSID[apidx].Bssid, netif->hwaddr);
-//	pAd->bForcePrintTX = TRUE;
-
 	CfgInitHook(pAd);
 
 	NdisAllocateSpinLock(&pAd->MacTabLock);
@@ -457,13 +447,6 @@ static int rt28xx_init(IN struct net_dev
 	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
 	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
 
-	// after reading Registry, we now know if in AP mode or STA mode
-
-	// Load 8051 firmware; crash when FW image not existent
-	// Status = NICLoadFirmware(pAd);
-	// if (Status != NDIS_STATUS_SUCCESS)
-	//    break;
-
 	printk("2. Phy Mode = %d\n", pAd->CommonCfg.PhyMode);
 
 	// We should read EEPROM for all cases.  rt2860b
@@ -495,8 +478,6 @@ static int rt28xx_init(IN struct net_dev
 	NICInitRT30xxRFRegisters(pAd);
 #endif // RT30xx //
 
-//		APInitialize(pAd);
-
 #ifdef IKANOS_VX_1X0
 	VR_IKANOS_FP_Init(pAd->ApCfg.BssidNum, pAd->PermanentAddress);
 #endif // IKANOS_VX_1X0 //
@@ -514,16 +495,13 @@ static int rt28xx_init(IN struct net_dev
 		//
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE))
 		{
-//			NdisMDeregisterInterrupt(&pAd->Interrupt);
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
 		}
-//		RTMPFreeAdapter(pAd); // we will free it in disconnect()
 	}
 	else if (pAd)
 	{
 		// Microsoft HCT require driver send a disconnect event after driver initialization.
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-//		pAd->IndicateMediaState = NdisMediaStateDisconnected;
 		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);
 
 		DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_DISCONNECT Event B!\n"));
@@ -556,7 +534,6 @@ err3:
 	MlmeHalt(pAd);
 err2:
 	RTMPFreeTxRxRingMemory(pAd);
-//	RTMPFreeAdapter(pAd);
 err1:
 	os_free_mem(pAd, pAd->mpdu_blk_pool.mem); // free BA pool
 	RT28XX_IRQ_RELEASE(net_dev);
@@ -644,19 +621,6 @@ int rt28xx_open(IN PNET_DEV dev)
 	printk("0x1300 = %08x\n", reg);
 	}
 
-	{
-//	u32 reg;
-//	u8  byte;
-//	u16 tmp;
-
-//	RTMP_IO_READ32(pAd, XIFS_TIME_CFG, &reg);
-
-//	tmp = 0x0805;
-//	reg  = (reg & 0xffff0000) | tmp;
-//	RTMP_IO_WRITE32(pAd, XIFS_TIME_CFG, reg);
-
-	}
-
 	return (retval);
 
 err:
@@ -686,10 +650,6 @@ static NDIS_STATUS rt_ieee80211_if_setup
 	CHAR    slot_name[IFNAMSIZ];
 	struct net_device   *device;
 
-
-	//ether_setup(dev);
-//	dev->set_multicast_list = ieee80211_set_multicast_list;
-//	dev->change_mtu = ieee80211_change_mtu;
 #if WIRELESS_EXT >= 12
 	if (pAd->OpMode == OPMODE_STA)
 	{
@@ -700,8 +660,6 @@ static NDIS_STATUS rt_ieee80211_if_setup
 #if WIRELESS_EXT < 21
 		dev->get_wireless_stats = rt28xx_get_wireless_stats;
 #endif
-//	dev->uninit = ieee80211_if_reinit;
-//	dev->destructor = ieee80211_if_free;
 	dev->priv_flags = INT_MAIN;
 	dev->netdev_ops = &rt3070_netdev_ops;
 	// find available device name
@@ -768,10 +726,6 @@ INT __devinit   rt28xx_probe(
 
     DBGPRINT(RT_DEBUG_TRACE, ("STA Driver version-%s\n", STA_DRIVER_VERSION));
 
-	// Check chipset vendor/product ID
-//	if (RT28XXChipsetCheck(_dev_p) == FALSE)
-//		goto err_out;
-
     net_dev = alloc_etherdev(sizeof(PRTMP_ADAPTER));
     if (net_dev == NULL)
     {
@@ -780,10 +734,6 @@ INT __devinit   rt28xx_probe(
         goto err_out;
     }
 
-// sample
-//	if (rt_ieee80211_if_setup(net_dev) != NDIS_STATUS_SUCCESS)
-//		goto err_out;
-
 	netif_stop_queue(net_dev);
 
 /* for supporting Network Manager */
@@ -807,9 +757,6 @@ INT __devinit   rt28xx_probe(
 
     pAd->StaCfg.OriDevType = net_dev->type;
 
-	// Find and assign a free interface name, raxx
-//	RT28XXAvailRANameAssign(net_dev->name);
-
 	// Post config
 	if (RT28XXProbePostConfig(_dev_p, pAd, 0) == FALSE)
 		goto err_out_unmap;
@@ -892,7 +839,6 @@ int rt28xx_packet_xmit(struct sk_buff *s
 	}
 
 	RTMP_SET_PACKET_5VT(pPacket, 0);
-//	MiniportMMRequest(pAd, pkt->data, pkt->len);
 #ifdef CONFIG_5VT_ENHANCE
     if (*(int*)(skb->cb) == BRIDGE_TAG) {
 		RTMP_SET_PACKET_5VT(pPacket, 1);
--- a/drivers/staging/rt3070/rtmp_def.h
+++ b/drivers/staging/rt3070/rtmp_def.h
@@ -54,8 +54,6 @@
 #define NIC_TAG             ((ULONG)'0682')
 #define NIC_DBG_STRING      ("**RT28xx**")
 
-//#define PACKED
-
 #define RALINK_2883_VERSION		((UINT32)0x28830300)
 #define RALINK_2880E_VERSION	((UINT32)0x28720200)
 #define RALINK_3070_VERSION		((UINT32)0x30700200)
@@ -182,16 +180,6 @@
 #define fRTMP_ADAPTER_MEDIA_STATE_CHANGE    0x20000000
 #define fRTMP_ADAPTER_IDLE_RADIO_OFF        0x40000000
 
-// Lock bit for accessing different ring buffers
-//#define fRTMP_ADAPTER_TX_RING_BUSY        0x80000000
-//#define fRTMP_ADAPTER_MGMT_RING_BUSY      0x40000000
-//#define fRTMP_ADAPTER_ATIM_RING_BUSY      0x20000000
-//#define fRTMP_ADAPTER_RX_RING_BUSY        0x10000000
-
-// Lock bit for accessing different queue
-//#define   fRTMP_ADAPTER_TX_QUEUE_BUSY     0x08000000
-//#define   fRTMP_ADAPTER_MGMT_QUEUE_BUSY   0x04000000
-
 //
 //  STA operation status flags
 //
@@ -201,7 +189,6 @@
 #define fOP_STATUS_SHORT_SLOT_INUSED        0x00000008
 #define fOP_STATUS_SHORT_PREAMBLE_INUSED    0x00000010
 #define fOP_STATUS_RECEIVE_DTIM             0x00000020
-//#define fOP_STATUS_TX_RATE_SWITCH_ENABLED   0x00000040
 #define fOP_STATUS_MEDIA_STATE_CONNECTED    0x00000080
 #define fOP_STATUS_WMM_INUSED               0x00000100
 #define fOP_STATUS_AGGREGATION_INUSED       0x00000200
@@ -241,7 +228,6 @@
 //
 //  STA configuration flags
 //
-//#define fSTA_CFG_ENABLE_TX_BURST          0x00000001
 
 // 802.11n Operating Mode Definition. 0-3 also used in ASICUPdateProtect switch case
 #define HT_NO_PROTECT	0
@@ -440,14 +426,10 @@
 #define PWR_ACTIVE                      0
 #define PWR_SAVE                        1
 #define PWR_MMPS                        2			//MIMO power save
-//#define PWR_UNKNOWN                   2
 
 // Auth and Assoc mode related definitions
 #define AUTH_MODE_OPEN                  0x00
 #define AUTH_MODE_KEY                   0x01
-//#define AUTH_MODE_AUTO_SWITCH         0x03
-//#define AUTH_MODE_DEAUTH              0x04
-//#define AUTH_MODE_UPLAYER             0x05 // reserved for 802.11i use
 
 // BSS Type definitions
 #define BSS_ADHOC                       0  // = Ndis802_11IBSS
@@ -855,10 +837,6 @@
 #define	AIRONET_FUNC_SIZE				(MAX_AIRONET_STATE * MAX_AIRONET_MSG)
 
 //
-// WSC State machine: states, events, total function #
-//
-
-//
 // AP's CONTROL/CONNECT state machine: states, events, total function #
 //
 #define AP_CNTL_FUNC_SIZE               1
--- a/drivers/staging/rt3070/rtmp.h
+++ b/drivers/staging/rt3070/rtmp.h
@@ -142,7 +142,6 @@ typedef struct _RX_CONTEXT
 	PURB				pUrb;
 	//These 2 Boolean shouldn't both be 1 at the same time.
 	ULONG				BulkInOffset;	// number of packets waiting for reordering .
-//	BOOLEAN				ReorderInUse;	// At least one packet in this buffer are in reordering buffer and wait for receive indication
 	BOOLEAN				bRxHandling;	// Notify this packet is being process now.
 	BOOLEAN				InUse;			// USB Hardware Occupied. Wait for USB HW to put packet.
 	BOOLEAN				Readable;		// Receive Complete back. OK for driver to indicate receiving packet.
@@ -458,20 +457,6 @@ typedef struct  _QUEUE_HEADER   {
 }
 
 //
-// MACRO for 32-bit PCI register read / write
-//
-// Usage : RTMP_IO_READ32(
-//              PRTMP_ADAPTER pAd,
-//              ULONG Register_Offset,
-//              PULONG  pValue)
-//
-//         RTMP_IO_WRITE32(
-//              PRTMP_ADAPTER pAd,
-//              ULONG Register_Offset,
-//              ULONG Value)
-//
-
-//
 // BBP & RF are using indirect access. Before write any value into it.
 // We have to make sure there is no outstanding command pending via checking busy bit.
 //
@@ -607,8 +592,6 @@ typedef struct  _QUEUE_HEADER   {
 //
 // Common fragment list structure -  Identical to the scatter gather frag list structure
 //
-//#define RTMP_SCATTER_GATHER_ELEMENT         SCATTER_GATHER_ELEMENT
-//#define PRTMP_SCATTER_GATHER_ELEMENT        PSCATTER_GATHER_ELEMENT
 #define NIC_MAX_PHYS_BUF_COUNT              8
 
 typedef struct _RTMP_SCATTER_GATHER_ELEMENT {
@@ -1303,7 +1286,6 @@ typedef struct _MLME_STRUCT {
 
 // structure for radar detection and channel switch
 typedef struct _RADAR_DETECT_STRUCT {
-    //BOOLEAN		IEEE80211H;			// 0: disable, 1: enable IEEE802.11h
 	UCHAR		CSCount;			//Channel switch counter
 	UCHAR		CSPeriod;			//Channel switch period (beacon count)
 	UCHAR		RDCount;			//Radar detection counter
@@ -1355,21 +1337,14 @@ typedef struct _BA_REC_ENTRY {
 	UCHAR   Wcid;
 	UCHAR   TID;
 	UCHAR   BAWinSize;	// 7.3.1.14. each buffer is capable of holding a max AMSDU or MSDU.
-	//UCHAR	NumOfRxPkt;
-	//UCHAR    Curindidx; // the head in the RX reordering buffer
 	USHORT		LastIndSeq;
-//	USHORT		LastIndSeqAtTimer;
 	USHORT		TimeOutValue;
 	RALINK_TIMER_STRUCT RECBATimer;
 	ULONG		LastIndSeqAtTimer;
 	ULONG		nDropPacket;
 	ULONG		rcvSeq;
 	REC_BLOCKACK_STATUS  REC_BA_Status;
-//	UCHAR	RxBufIdxUsed;
-	// corresponding virtual address for RX reordering packet storage.
-	//RTMP_REORDERDMABUF MAP_RXBuf[MAX_RX_REORDERBUF];
 	NDIS_SPIN_LOCK          RxReRingLock;                 // Rx Ring spinlock
-//	struct _BA_REC_ENTRY *pNext;
 	PVOID	pAdapter;
 	struct reordering_list	list;
 } BA_REC_ENTRY, *PBA_REC_ENTRY;
@@ -1447,8 +1422,6 @@ typedef	struct	_IOT_STRUC	{
 // This is the registry setting for 802.11n transmit setting.  Used in advanced page.
 typedef union _REG_TRANSMIT_SETTING {
  struct {
-         //UINT32  PhyMode:4;
-         //UINT32  MCS:7;                 // MCS
 		 UINT32  rsv0:10;
 		 UINT32  TxBF:1;
          UINT32  BW:1; //channel bandwidth 20MHz or 40 MHz
@@ -1546,7 +1519,6 @@ typedef struct _MULTISSID_STRUCT {
 	DESIRED_TRANSMIT_SETTING        	DesiredTransmitSetting; // Desired transmit setting. this is for reading registry setting only. not useful.
 	BOOLEAN								bAutoTxRateSwitch;
 
-	//CIPHER_KEY                          SharedKey[SHARE_KEY_NUM]; // ref pAd->SharedKey[BSS][4]
 	UCHAR                               DefaultKeyId;
 
 	UCHAR								TxRate;       // RATE_1, RATE_2, RATE_5_5, RATE_11, ...
@@ -1554,8 +1526,6 @@ typedef struct _MULTISSID_STRUCT {
 	UCHAR								DesiredRatesIndex;
 	UCHAR     							MaxTxRate;            // RATE_1, RATE_2, RATE_5_5, RATE_11
 
-//	ULONG           					TimBitmap;      // bit0 for broadcast, 1 for AID1, 2 for AID2, ...so on
-//    ULONG           					TimBitmap2;     // b0 for AID32, b1 for AID33, ... and so on
 	UCHAR								TimBitmaps[WLAN_MAX_NUM_OF_TIM];
 
     // WPA
@@ -1673,15 +1643,11 @@ typedef struct _COMMON_CONFIG {
 	ULONG		TriggerTimerCount;
 	UCHAR		MaxSPLength;
 	UCHAR		BBPCurrentBW;	// BW_10, 	BW_20, BW_40
-	// move to MULTISSID_STRUCT for MBSS
-	//HTTRANSMIT_SETTING	HTPhyMode, MaxHTPhyMode, MinHTPhyMode;// For transmit phy setting in TXWI.
 	REG_TRANSMIT_SETTING        RegTransmitSetting; //registry transmit setting. this is for reading registry setting only. not useful.
-	//UCHAR       FixedTxMode;              // Fixed Tx Mode (CCK, OFDM), for HT fixed tx mode (GF, MIX) , refer to RegTransmitSetting.field.HTMode
 	UCHAR       TxRate;                 // Same value to fill in TXD. TxRate is 6-bit
 	UCHAR       MaxTxRate;              // RATE_1, RATE_2, RATE_5_5, RATE_11
 	UCHAR       TxRateIndex;            // Tx rate index in RateSwitchTable
 	UCHAR       TxRateTableSize;        // Valid Tx rate table size in RateSwitchTable
-	//BOOLEAN		bAutoTxRateSwitch;
 	UCHAR       MinTxRate;              // RATE_1, RATE_2, RATE_5_5, RATE_11
 	UCHAR       RtsRate;                // RATE_xxx
 	HTTRANSMIT_SETTING	MlmeTransmit;   // MGMT frame PHY rate setting when operatin at Ht rate.
@@ -1883,9 +1849,6 @@ typedef struct _STA_ADMIN_CONFIG {
 	BOOLEAN     bHardwareRadio;     // Hardware controlled Radio enabled
 	BOOLEAN     bShowHiddenSSID;    // Show all known SSID in SSID list get operation
 
-    //BOOLEAN		AdhocBOnlyJoined;	// Indicate Adhoc B Join.
-    //BOOLEAN		AdhocBGJoined;		// Indicate Adhoc B/G Join.
-    //BOOLEAN		Adhoc20NJoined;		// Indicate Adhoc 20MHz N Join.
 
 	// New for WPA, windows want us to to keep association information and
 	// Fixed IEs from last association response
@@ -2117,7 +2080,6 @@ typedef struct _MAC_TABLE_ENTRY {
 	UCHAR           CurrTxRateIndex;
 	// to record the each TX rate's quality. 0 is best, the bigger the worse.
 	USHORT          TxQuality[MAX_STEP_OF_TX_RATE_SWITCH];
-//	USHORT          OneSecTxOkCount;
 	UINT32			OneSecTxNoRetryOkCount;
 	UINT32          OneSecTxRetryOkCount;
 	UINT32          OneSecTxFailCount;
@@ -2286,29 +2248,20 @@ typedef struct _APCLI_STRUCT {
 	UCHAR		PSK[100];				// reserve PSK key material
 	UCHAR       PSKLen;
 	UCHAR       PMK[32];                // WPA PSK mode PMK
-	//UCHAR       PTK[64];                // WPA PSK mode PTK
 	UCHAR		GTK[32];				// GTK from authenticator
 
-	//CIPHER_KEY		PairwiseKey;
 	CIPHER_KEY      SharedKey[SHARE_KEY_NUM];
 	UCHAR           DefaultKeyId;
 
-	// WPA 802.1x port control, WPA_802_1X_PORT_SECURED, WPA_802_1X_PORT_NOT_SECURED
-	//UCHAR       PortSecured;
-
 	// store RSN_IE built by driver
 	UCHAR		RSN_IE[MAX_LEN_OF_RSNIE];  // The content saved here should be convert to little-endian format.
 	UCHAR		RSNIE_Len;
 
 	// For WPA countermeasures
 	ULONG       LastMicErrorTime;   // record last MIC error time
-	//ULONG       MicErrCnt;          // Should be 0, 1, 2, then reset to zero (after disassoiciation).
 	BOOLEAN                 bBlockAssoc; // Block associate attempt for 60 seconds after counter measure occurred.
 
 	// For WPA-PSK supplicant state
-	//WPA_STATE   	WpaState;           // Default is SS_NOTUSE
-	//UCHAR       	ReplayCounter[8];
-	//UCHAR       	ANonce[32];         // ANonce for WPA-PSK from authenticator
 	UCHAR       	SNonce[32];         // SNonce for WPA-PSK
 	UCHAR			GNonce[32];			// GNonce for WPA-PSK from authenticator
 
@@ -2362,15 +2315,12 @@ typedef struct _RtmpDiagStrcut_
 	// Tx Related Count
 	USHORT			TxDataCnt[DIAGNOSE_TIME];
 	USHORT			TxFailCnt[DIAGNOSE_TIME];
-//	USHORT			TxDescCnt[DIAGNOSE_TIME][16];		// TxDesc queue length in scale of 0~14, >=15
 	USHORT			TxDescCnt[DIAGNOSE_TIME][24]; // 3*3	// TxDesc queue length in scale of 0~14, >=15
-//	USHORT			TxMcsCnt[DIAGNOSE_TIME][16];			// TxDate MCS Count in range from 0 to 15, step in 1.
 	USHORT			TxMcsCnt[DIAGNOSE_TIME][24]; // 3*3
 	USHORT			TxSWQueCnt[DIAGNOSE_TIME][9];		// TxSwQueue length in scale of 0, 1, 2, 3, 4, 5, 6, 7, >=8
 
 	USHORT			TxAggCnt[DIAGNOSE_TIME];
 	USHORT			TxNonAggCnt[DIAGNOSE_TIME];
-//	USHORT			TxAMPDUCnt[DIAGNOSE_TIME][16];		// 10 sec, TxDMA APMDU Aggregation count in range from 0 to 15, in setp of 1.
 	USHORT			TxAMPDUCnt[DIAGNOSE_TIME][24]; // 3*3 // 10 sec, TxDMA APMDU Aggregation count in range from 0 to 15, in setp of 1.
 	USHORT			TxRalinkCnt[DIAGNOSE_TIME];			// TxRalink Aggregation Count in 1 sec scale.
 	USHORT			TxAMSDUCnt[DIAGNOSE_TIME];			// TxAMSUD Aggregation Count in 1 sec scale.
@@ -2378,7 +2328,6 @@ typedef struct _RtmpDiagStrcut_
 	// Rx Related Count
 	USHORT			RxDataCnt[DIAGNOSE_TIME];			// Rx Total Data count.
 	USHORT			RxCrcErrCnt[DIAGNOSE_TIME];
-//	USHORT			RxMcsCnt[DIAGNOSE_TIME][16];		// Rx MCS Count in range from 0 to 15, step in 1.
 	USHORT			RxMcsCnt[DIAGNOSE_TIME][24]; // 3*3
 }RtmpDiagStruct;
 #endif // DBG_DIAGNOSE //
@@ -2630,8 +2579,6 @@ typedef struct _RTMP_ADAPTER
 	NDIS_MEDIA_STATE        IndicateMediaState;			// Base on Indication state, default is NdisMediaStateDisConnected
 
 
-	// MAT related parameters
-
 	// configuration: read from Registry & E2PROM
 	BOOLEAN                 bLocalAdminMAC;             // Use user changed MAC
 	UCHAR                   PermanentAddress[MAC_ADDR_LEN];    // Factory default MAC address
@@ -2717,7 +2664,6 @@ typedef struct _RTMP_ADAPTER
 	// ----------------------------
 	// DEBUG paramerts
 	// ----------------------------
-	//ULONG		DebugSetting[4];
 	BOOLEAN		bBanAllBaSetup;
 	BOOLEAN		bPromiscuous;
 
@@ -2833,7 +2779,6 @@ typedef struct  _CISCO_IAPP_CONTENT_
 
 typedef struct _RX_BLK_
 {
-//	RXD_STRUC		RxD; // sample
 	RT28XX_RXD_STRUC	RxD;
 	PRXWI_STRUC			pRxWI;
 	PHEADER_802_11		pHeader;
@@ -2921,7 +2866,6 @@ typedef struct _TX_BLK_
 #define fTX_bAckRequired       	0x0002	// the packet need ack response
 #define fTX_bPiggyBack     		0x0004	// Legacy device use Piggback or not
 #define fTX_bHTRate         	0x0008	// allow to use HT rate
-//#define fTX_bForceLowRate       0x0010	// force to use Low Rate
 #define fTX_bForceNonQoS       	0x0010	// force to transmit frame without WMM-QoS in HT mode
 #define fTX_bAllowFrag       	0x0020	// allow to fragment the packet, A-MPDU, A-MSDU, A-Ralink is not allowed to fragment
 #define fTX_bMoreData			0x0040	// there are more data packets in PowerSave Queue
@@ -5331,10 +5275,6 @@ VOID RTMPFilterCalibration(
 	IN PRTMP_ADAPTER pAd);
 #endif // RT30xx //
 
-
-//typedef void (*TIMER_FUNCTION)(unsigned long);
-
-
 /* timeout -- ms */
 VOID RTMP_SetPeriodicTimer(
 	IN	NDIS_MINIPORT_TIMER *pTimer,
--- a/drivers/staging/rt3070/rt_profile.c
+++ b/drivers/staging/rt3070/rt_profile.c
@@ -886,11 +886,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 
 	// Save uid and gid used for filesystem access.
 	// Set user and group to 0 (root)
-#if 0
-	orgfsuid = current->fsuid;
-	orgfsgid = current->fsgid;
-	current->fsuid=current->fsgid = 0;
-#endif
     orgfs = get_fs();
     set_fs(KERNEL_DS);
 
@@ -1121,14 +1116,10 @@ NDIS_STATUS	RTMPReadParametersHook(
 					//TxBurst
 					if(RTMPGetKeyParameter("TxBurst", tmpbuf, 10, buffer))
 					{
-//#ifdef WIFI_TEST
-//						pAd->CommonCfg.bEnableTxBurst = FALSE;
-//#else
 						if(simple_strtol(tmpbuf, 0, 10) != 0)  //Enable
 							pAd->CommonCfg.bEnableTxBurst = TRUE;
 						else //Disable
 							pAd->CommonCfg.bEnableTxBurst = FALSE;
-//#endif
 						DBGPRINT(RT_DEBUG_TRACE, ("TxBurst=%d\n", pAd->CommonCfg.bEnableTxBurst));
 					}
 
@@ -1296,7 +1287,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 							pAd->StaCfg.OrigWepStatus 	= pAd->StaCfg.WepStatus;
 							pAd->StaCfg.bMixCipher 		= FALSE;
 
-							//RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
 							DBGPRINT(RT_DEBUG_TRACE, ("%s::(EncrypType=%d)\n", __func__, pAd->StaCfg.WepStatus));
 						}
 					}
@@ -1342,21 +1332,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 								}
 								else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
 								{
-	/*
-									NdisZeroMemory(&pAd->SharedKey[BSS0][0], sizeof(CIPHER_KEY));
-									pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
-									NdisMoveMemory(pAd->SharedKey[BSS0][0].Key, pAd->StaCfg.PMK, LEN_TKIP_EK);
-									NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic, &pAd->StaCfg.PMK[16], LEN_TKIP_RXMICK);
-									NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic, &pAd->StaCfg.PMK[16], LEN_TKIP_TXMICK);
-
-									// Decide its ChiperAlg
-									if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
-										pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
-									else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
-										pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
-									else
-										pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_NONE;
-	*/
 									pAd->StaCfg.WpaState = SS_NOTUSE;
 								}
 
@@ -1368,23 +1343,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 					//DefaultKeyID, KeyType, KeyStr
 					rtmp_read_key_parms_from_file(pAd, tmpbuf, buffer);
 
-
-					//HSCounter
-					/*if(RTMPGetKeyParameter("HSCounter", tmpbuf, 10, buffer))
-					{
-						switch (simple_strtol(tmpbuf, 0, 10))
-						{
-							case 1: //Enable
-								pAd->CommonCfg.bEnableHSCounter = TRUE;
-								break;
-							case 0: //Disable
-							default:
-								pAd->CommonCfg.bEnableHSCounter = FALSE;
-								break;
-						}
-						DBGPRINT(RT_DEBUG_TRACE, "HSCounter=%d\n", pAd->CommonCfg.bEnableHSCounter);
-					}*/
-
 					HTParametersHook(pAd, tmpbuf, buffer);
 
 					{
@@ -1506,10 +1464,6 @@ NDIS_STATUS	RTMPReadParametersHook(
 	}
 
 	set_fs(orgfs);
-#if 0
-	current->fsuid = orgfsuid;
-	current->fsgid = orgfsgid;
-#endif
 
 	kfree(buffer);
 	kfree(tmpbuf);
@@ -1836,7 +1790,6 @@ static void	HTParametersHook(
 		{
 			Value = simple_strtol(pValueStr, 0, 10);
 
-//			if ((Value >= 0 && Value <= 15) || (Value == 32))
 			if ((Value >= 0 && Value <= 23) || (Value == 32)) // 3*3
 		{
 				pAd->StaCfg.DesiredTransmitSetting.field.MCS  = Value;
--- a/drivers/staging/rt3070/sta/connect.c
+++ b/drivers/staging/rt3070/sta/connect.c
@@ -535,13 +535,6 @@ VOID CntlOidRTBssidProc(
 	pAd->MlmeAux.SsidBssTab.BssNr = 1;
 	NdisMoveMemory(&pAd->MlmeAux.SsidBssTab.BssEntry[0], &pAd->ScanTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
 
-	//pAd->MlmeAux.AutoReconnectSsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
-	//NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->ScanTab.BssEntry[BssIdx].Ssid, pAd->ScanTab.BssEntry[BssIdx].SsidLen);
-
-	// Add SSID into MlmeAux for site surey joining hidden SSID
-	//pAd->MlmeAux.SsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
-	//NdisMoveMemory(pAd->MlmeAux.Ssid, pAd->ScanTab.BssEntry[BssIdx].Ssid, pAd->MlmeAux.SsidLen);
-
 	// 2002-11-26 skip the following checking. i.e. if user wants to re-connect to same AP
 	//   we just follow normal procedure. The reason of user doing this may because he/she changed
 	//   AP to another channel, but we still received BEACON from it thus don't claim Link Down.
@@ -1659,7 +1652,6 @@ VOID LinkUp(
 	// Txop can only be modified when RDG is off, WMM is disable and TxBurst is enable
 	//
 	// if 1. Legacy AP WMM on,  or 2. 11n AP, AMPDU disable.  Force turn off burst no matter what bEnableTxBurst is.
-//	if ((!IS_RT30xx(pAd)) &&
 	if (!((pAd->CommonCfg.RxStream == 1)&&(pAd->CommonCfg.TxStream == 1)) &&
 		(((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
 		|| ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE) && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE))))
@@ -1934,9 +1926,6 @@ VOID LinkDown(
 	// Update extra information to link is up
 	pAd->ExtraInfo = GENERAL_LINK_DOWN;
 
-    //pAd->StaCfg.AdhocBOnlyJoined = FALSE;
-	//pAd->StaCfg.AdhocBGJoined = FALSE;
-	//pAd->StaCfg.Adhoc20NJoined = FALSE;
     pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
 
 	// Reset the Current AP's IP address
--- a/drivers/staging/rt3070/sta_ioctl.c
+++ b/drivers/staging/rt3070/sta_ioctl.c
@@ -346,7 +346,6 @@ VOID RTMPAddKey(
             if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
             {
                 // set 802.1x port control
-	            //pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAd);
 
                 // Indicate Connected for GUI
@@ -396,7 +395,6 @@ VOID RTMPAddKey(
         							  NULL);
 
             // set 802.1x port control
-	        //pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 			STA_PORT_SECURED(pAd);
 
             // Indicate Connected for GUI
@@ -1563,7 +1561,6 @@ int rt_ioctl_siwencode(struct net_device
 	}
 	else if (erq->flags & IW_ENCODE_RESTRICTED || erq->flags & IW_ENCODE_OPEN)
 	{
-	    //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 		STA_PORT_SECURED(pAdapter);
 		pAdapter->StaCfg.PairCipher = Ndis802_11WEPEnabled;
 		pAdapter->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
@@ -2171,7 +2168,6 @@ int rt_ioctl_siwauth(struct net_device *
             }
             else if (param->value == 0)
             {
-                //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAdapter);
             }
             DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_KEY_MGMT - param->value = %d!\n", __func__, param->value));
@@ -2179,14 +2175,6 @@ int rt_ioctl_siwauth(struct net_device *
     	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
             break;
     	case IW_AUTH_PRIVACY_INVOKED:
-            /*if (param->value == 0)
-			{
-                pAdapter->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
-                pAdapter->StaCfg.WepStatus = Ndis802_11WEPDisabled;
-                pAdapter->StaCfg.OrigWepStatus = pAdapter->StaCfg.WepStatus;
-                pAdapter->StaCfg.PairCipher = Ndis802_11WEPDisabled;
-        	    pAdapter->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
-            }*/
             DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_PRIVACY_INVOKED - param->value = %d!\n", __func__, param->value));
     		break;
     	case IW_AUTH_DROP_UNENCRYPTED:
@@ -2194,7 +2182,6 @@ int rt_ioctl_siwauth(struct net_device *
                 pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
 			else
 			{
-                //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAdapter);
 			}
             DBGPRINT(RT_DEBUG_TRACE, ("%s::IW_AUTH_WPA_VERSION - param->value = %d!\n", __func__, param->value));
@@ -2367,7 +2354,6 @@ int rt_ioctl_siwencodeext(struct net_dev
                         fnSetCipherKey(pAdapter, keyIdx, CIPHER_TKIP, FALSE, ext);
                         if (pAdapter->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
                         {
-                            //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
                             STA_PORT_SECURED(pAdapter);
                         }
 		}
@@ -2376,7 +2362,6 @@ int rt_ioctl_siwencodeext(struct net_dev
                         fnSetCipherKey(pAdapter, keyIdx, CIPHER_TKIP, TRUE, ext);
 
                         // set 802.1x port control
-            	        //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
             	        STA_PORT_SECURED(pAdapter);
                     }
                 }
@@ -2388,7 +2373,6 @@ int rt_ioctl_siwencodeext(struct net_dev
 		{
                     fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES, FALSE, ext);
                     if (pAdapter->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
-                    	//pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
                     	STA_PORT_SECURED(pAdapter);
                 }
                 else if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
@@ -2396,7 +2380,6 @@ int rt_ioctl_siwencodeext(struct net_dev
                     fnSetCipherKey(pAdapter, keyIdx, CIPHER_AES, TRUE, ext);
 
                     // set 802.1x port control
-        	        //pAdapter->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
         	        STA_PORT_SECURED(pAdapter);
                 }
                 break;
@@ -2645,7 +2628,6 @@ rt_private_ioctl_bbp(struct net_device *
 	CHAR				*this_char;
 	CHAR				*value = NULL;
 	UCHAR				regBBP = 0;
-//	CHAR				arg[255]={0};
 	UINT32				bbpId;
 	UINT32				bbpValue;
 	BOOLEAN				bIsPrintAllBBP = FALSE;
@@ -2858,7 +2840,6 @@ int rt_ioctl_giwrate(struct net_device *
 
     if (ht_setting.field.MODE >= MODE_HTMIX)
     {
-//    	rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS);
     	rate_index = 12 + ((UCHAR)ht_setting.field.BW *24) + ((UCHAR)ht_setting.field.ShortGI *48) + ((UCHAR)ht_setting.field.MCS);
     }
     else
--- a/drivers/staging/rt3070/sta/rtmp_data.c
+++ b/drivers/staging/rt3070/sta/rtmp_data.c
@@ -65,7 +65,6 @@ VOID STARxEAPOLFrameIndicate(
 				int     idx = 0;
 
 				DBGPRINT_RAW(RT_DEBUG_TRACE, ("Receive EAP-SUCCESS Packet\n"));
-				//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAd);
 
                 if (pAd->StaCfg.IEEE8021x_required_keys == FALSE)
@@ -881,7 +880,6 @@ NDIS_STATUS STASendPacket(
 	UINT			SrcBufLen;
 	UINT			AllowFragSize;
 	UCHAR			NumberOfFrag;
-//	UCHAR			RTSRequired;
 	UCHAR			QueIdx, UserPriority;
 	MAC_TABLE_ENTRY *pEntry = NULL;
 	unsigned int 	IrqFlags;
@@ -1095,7 +1093,6 @@ NDIS_STATUS STASendPacket(
     if ((pAd->CommonCfg.BACapability.field.AutoBA == TRUE)&&
         IS_HT_STA(pEntry))
 	{
-	    //PMAC_TABLE_ENTRY pMacEntry = &pAd->MacTab.Content[BSSID_WCID];
 		if (((pEntry->TXBAbitmap & (1<<UserPriority)) == 0) &&
             ((pEntry->BADeclineBitmap & (1<<UserPriority)) == 0) &&
             (pEntry->PortSecured == WPA_802_1X_PORT_SECURED)
@@ -1150,7 +1147,6 @@ NDIS_STATUS RTMPFreeTXDRequest(
 	IN		UCHAR			NumberRequired,
 	IN		PUCHAR			FreeNumberIs)
 {
-	//ULONG		FreeNumber = 0;
 	NDIS_STATUS 	Status = NDIS_STATUS_FAILURE;
 	unsigned long   IrqFlags;
 	HT_TX_CONTEXT	*pHTTXContext;
--- a/drivers/staging/rt3070/sta/sync.c
+++ b/drivers/staging/rt3070/sta/sync.c
@@ -545,8 +545,6 @@ VOID PeerBeaconAtScanAction(
 	UCHAR			AddHtInfoLen;
 	UCHAR			NewExtChannelOffset = 0xff;
 
-
-	// NdisFillMemory(Ssid, MAX_LEN_OF_SSID, 0x00);
 	pFrame = (PFRAME_802_11) Elem->Msg;
 	// Init Variable IE structure
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
--- a/drivers/staging/rt3070/sta/wpa.c
+++ b/drivers/staging/rt3070/sta/wpa.c
@@ -1214,7 +1214,6 @@ VOID    Wpa2PairMsg3Action(
 	RTMPToWirelessSta(pAd, Header802_3, LENGTH_802_3, (PUCHAR)&Packet, Packet.Body_Len[1] + 4, TRUE);
 
 	// set 802.1x port control
-	//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 	STA_PORT_SECURED(pAd);
 
     // Indicate Connected for GUI
@@ -1406,7 +1405,6 @@ VOID	WpaGroupMsg1Action(
 							  NULL);
 
 	// set 802.1x port control
-	//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 	STA_PORT_SECURED(pAd);
 
     // Indicate Connected for GUI
@@ -1889,17 +1887,6 @@ VOID	RTMPReportMicError(
 			pAd->StaCfg.LastMicErrorTime = Now;
 			// Violate MIC error counts, MIC countermeasures kicks in
 			pAd->StaCfg.MicErrCnt++;
-			// We shall block all reception
-			// We shall clean all Tx ring and disassoicate from AP after next EAPOL frame
-			//
-			// No necessary to clean all Tx ring, on RTMPHardTransmit will stop sending non-802.1X EAPOL packets
-			// if pAd->StaCfg.MicErrCnt greater than 2.
-			//
-			// RTMPRingCleanUp(pAd, QID_AC_BK);
-			// RTMPRingCleanUp(pAd, QID_AC_BE);
-			// RTMPRingCleanUp(pAd, QID_AC_VI);
-			// RTMPRingCleanUp(pAd, QID_AC_VO);
-			// RTMPRingCleanUp(pAd, QID_HCCA);
 		}
 	}
 	else
