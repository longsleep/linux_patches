From wfp5p@virginia.edu Mon Mar 16 17:18:12 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Mon, 16 Mar 2009 22:03:24 -0400
Subject: Staging: comedi: Convert C99 style comments to traditional style comments
To: greg@kroah.com
Message-ID: <20090317020323.14467.4977.stgit@viridian.itc.Virginia.EDU>


Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/comedi/comedi_ksyms.c      |   10 
 drivers/staging/comedi/drivers.c           |   20 
 drivers/staging/comedi/drivers/icp_multi.c |  214 +--
 drivers/staging/comedi/drivers/icp_multi.h |   11 
 drivers/staging/comedi/drivers/me4000.c    |   38 
 drivers/staging/comedi/drivers/me4000.h    |  222 +--
 drivers/staging/comedi/drivers/mite.c      |   24 
 drivers/staging/comedi/drivers/mite.h      |   56 
 drivers/staging/comedi/drivers/plx9080.h   |   76 -
 drivers/staging/comedi/drivers/rtd520.c    |   18 
 drivers/staging/comedi/drivers/rtd520.h    |  674 +++++-----
 drivers/staging/comedi/drivers/s626.c      | 1803 ++++++++++++++---------------
 drivers/staging/comedi/drivers/s626.h      | 1098 ++++++++---------
 drivers/staging/comedi/pci_ids.h           |    2 
 drivers/staging/comedi/proc.c              |    2 
 drivers/staging/comedi/range.c             |    2 
 drivers/staging/comedi/rt.c                |    8 
 drivers/staging/comedi/rt_pend_tq.c        |    6 
 18 files changed, 2112 insertions(+), 2172 deletions(-)

--- a/drivers/staging/comedi/comedi_ksyms.c
+++ b/drivers/staging/comedi/comedi_ksyms.c
@@ -31,12 +31,12 @@
 /* for drivers */
 EXPORT_SYMBOL(comedi_driver_register);
 EXPORT_SYMBOL(comedi_driver_unregister);
-//EXPORT_SYMBOL(comedi_bufcheck);
-//EXPORT_SYMBOL(comedi_done);
-//EXPORT_SYMBOL(comedi_error_done);
+/* EXPORT_SYMBOL(comedi_bufcheck); */
+/* EXPORT_SYMBOL(comedi_done); */
+/* EXPORT_SYMBOL(comedi_error_done); */
 EXPORT_SYMBOL(comedi_error);
-//EXPORT_SYMBOL(comedi_eobuf);
-//EXPORT_SYMBOL(comedi_eos);
+/* EXPORT_SYMBOL(comedi_eobuf); */
+/* EXPORT_SYMBOL(comedi_eos); */
 EXPORT_SYMBOL(comedi_event);
 EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 EXPORT_SYMBOL(comedi_set_subdevice_runflags);
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -140,7 +140,7 @@ int comedi_device_attach(comedi_device *
 				continue;
 			}
 		}
-		//initialize dev->driver here so comedi_error() can be called from attach
+		/* initialize dev->driver here so comedi_error() can be called from attach */
 		dev->driver = driv;
 		ret = driv->attach(dev, it);
 		if (ret < 0) {
@@ -151,8 +151,8 @@ int comedi_device_attach(comedi_device *
 		goto attached;
 	}
 
-	// recognize has failed if we get here
-	// report valid board names before returning error
+	/*  recognize has failed if we get here */
+	/*  report valid board names before returning error */
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk("comedi: failed to increment module count\n");
@@ -299,7 +299,7 @@ static int postconfig(comedi_device * de
 	return 0;
 }
 
-// generic recognize function for drivers that register their supported board names
+/*  generic recognize function for drivers that register their supported board names */
 void *comedi_recognize(comedi_driver * driv, const char *name)
 {
 	unsigned i;
@@ -426,7 +426,7 @@ int comedi_buf_alloc(comedi_device * dev
 	if (async->prealloc_buf && async->prealloc_bufsz == new_size) {
 		return 0;
 	}
-	// deallocate old buffer
+	/*  deallocate old buffer */
 	if (async->prealloc_buf) {
 		vunmap(async->prealloc_buf);
 		async->prealloc_buf = NULL;
@@ -455,7 +455,7 @@ int comedi_buf_alloc(comedi_device * dev
 		async->buf_page_list = NULL;
 		async->n_buf_pages = 0;
 	}
-	// allocate new buffer
+	/*  allocate new buffer */
 	if (new_size) {
 		unsigned i = 0;
 		unsigned n_pages = new_size >> PAGE_SHIFT;
@@ -568,7 +568,7 @@ unsigned int comedi_buf_munge(comedi_asy
 		s->munge(s->device, s, async->prealloc_buf + async->munge_ptr,
 			block_size, async->munge_chan);
 
-		smp_wmb();	//barrier insures data is munged in buffer before munge_count is incremented
+		smp_wmb();	/* barrier insures data is munged in buffer before munge_count is incremented */
 
 		async->munge_chan += block_size / num_sample_bytes;
 		async->munge_chan %= async->cmd.chanlist_len;
@@ -667,7 +667,7 @@ unsigned comedi_buf_read_alloc(comedi_as
 /* transfers control of a chunk from reader to free buffer space */
 unsigned comedi_buf_read_free(comedi_async * async, unsigned int nbytes)
 {
-	// barrier insures data has been read out of buffer before read count is incremented
+	/*  barrier insures data has been read out of buffer before read count is incremented */
 	smp_mb();
 	if ((int)(async->buf_read_count + nbytes -
 			async->buf_read_alloc_count) > 0) {
@@ -852,9 +852,9 @@ int comedi_pci_auto_config(struct pci_de
 {
 	int options[2];
 
-	// pci bus
+	/*  pci bus */
 	options[0] = pcidev->bus->number;
-	// pci slot
+	/*  pci slot */
 	options[1] = PCI_SLOT(pcidev->devfn);
 
 	return comedi_auto_config(&pcidev->dev, board_name, options, sizeof(options) / sizeof(options[0]));
--- a/drivers/staging/comedi/drivers/icp_multi.c
+++ b/drivers/staging/comedi/drivers/icp_multi.c
@@ -61,7 +61,7 @@ Options:
 
 #define ICP_MULTI_EXTDEBUG
 
-// Hardware types of the cards
+/*  Hardware types of the cards */
 #define TYPE_ICP_MULTI	0
 
 #define IORANGE_ICP_MULTI 	32
@@ -81,20 +81,20 @@ Options:
 
 #define ICP_MULTI_SIZE		0x20	/* 32 bytes */
 
-// Define bits from ADC command/status register
+/*  Define bits from ADC command/status register */
 #define	ADC_ST		0x0001	/* Start ADC */
 #define	ADC_BSY		0x0001	/* ADC busy */
 #define ADC_BI		0x0010	/* Bipolar input range 1 = bipolar */
 #define ADC_RA		0x0020	/* Input range 0 = 5V, 1 = 10V */
 #define	ADC_DI		0x0040	/* Differential input mode 1 = differential */
 
-// Define bits from DAC command/status register
+/*  Define bits from DAC command/status register */
 #define	DAC_ST		0x0001	/* Start DAC */
 #define DAC_BSY		0x0001	/* DAC busy */
 #define	DAC_BI		0x0010	/* Bipolar input range 1 = bipolar */
 #define	DAC_RA		0x0020	/* Input range 0 = 5V, 1 = 10V */
 
-// Define bits from interrupt enable/status registers
+/*  Define bits from interrupt enable/status registers */
 #define	ADC_READY	0x0001	/* A/d conversion ready interrupt */
 #define	DAC_READY	0x0002	/* D/a conversion ready interrupt */
 #define	DOUT_ERROR	0x0004	/* Digital output error interrupt */
@@ -104,10 +104,10 @@ Options:
 #define	CIE2		0x0040	/* Counter 2 overrun interrupt */
 #define	CIE3		0x0080	/* Counter 3 overrun interrupt */
 
-// Useful definitions
-#define	Status_IRQ	0x00ff	// All interrupts
+/*  Useful definitions */
+#define	Status_IRQ	0x00ff	/*  All interrupts */
 
-// Define analogue range
+/*  Define analogue range */
 static const comedi_lrange range_analog = { 4, {
 			UNI_RANGE(5),
 			UNI_RANGE(10),
@@ -134,41 +134,41 @@ static int icp_multi_detach(comedi_devic
 static unsigned short pci_list_builded = 0;	/*>0 list of card is known */
 
 typedef struct {
-	const char *name;	// driver name
+	const char *name;	/*  driver name */
 	int device_id;
-	int iorange;		// I/O range len
-	char have_irq;		// 1=card support IRQ
-	char cardtype;		// 0=ICP Multi
-	int n_aichan;		// num of A/D chans
-	int n_aichand;		// num of A/D chans in diff mode
-	int n_aochan;		// num of D/A chans
-	int n_dichan;		// num of DI chans
-	int n_dochan;		// num of DO chans
-	int n_ctrs;		// num of counters
-	int ai_maxdata;		// resolution of A/D
-	int ao_maxdata;		// resolution of D/A
-	const comedi_lrange *rangelist_ai;	// rangelist for A/D
-	const char *rangecode;	// range codes for programming
-	const comedi_lrange *rangelist_ao;	// rangelist for D/A
+	int iorange;		/*  I/O range len */
+	char have_irq;		/*  1=card support IRQ */
+	char cardtype;		/*  0=ICP Multi */
+	int n_aichan;		/*  num of A/D chans */
+	int n_aichand;		/*  num of A/D chans in diff mode */
+	int n_aochan;		/*  num of D/A chans */
+	int n_dichan;		/*  num of DI chans */
+	int n_dochan;		/*  num of DO chans */
+	int n_ctrs;		/*  num of counters */
+	int ai_maxdata;		/*  resolution of A/D */
+	int ao_maxdata;		/*  resolution of D/A */
+	const comedi_lrange *rangelist_ai;	/*  rangelist for A/D */
+	const char *rangecode;	/*  range codes for programming */
+	const comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
 } boardtype;
 
 static const boardtype boardtypes[] = {
-	{"icp_multi",		// Driver name
-			DEVICE_ID,	// PCI device ID
-			IORANGE_ICP_MULTI,	// I/O range length
-			1,	// 1=Card supports interrupts
-			TYPE_ICP_MULTI,	// Card type = ICP MULTI
-			16,	// Num of A/D channels
-			8,	// Num of A/D channels in diff mode
-			4,	// Num of D/A channels
-			16,	// Num of digital inputs
-			8,	// Num of digital outputs
-			4,	// Num of counters
-			0x0fff,	// Resolution of A/D
-			0x0fff,	// Resolution of D/A
-			&range_analog,	// Rangelist for A/D
-			range_codes_analog,	// Range codes for programming
-		&range_analog},	// Rangelist for D/A
+	{"icp_multi",		/*  Driver name */
+			DEVICE_ID,	/*  PCI device ID */
+			IORANGE_ICP_MULTI,	/*  I/O range length */
+			1,	/*  1=Card supports interrupts */
+			TYPE_ICP_MULTI,	/*  Card type = ICP MULTI */
+			16,	/*  Num of A/D channels */
+			8,	/*  Num of A/D channels in diff mode */
+			4,	/*  Num of D/A channels */
+			16,	/*  Num of digital inputs */
+			8,	/*  Num of digital outputs */
+			4,	/*  Num of counters */
+			0x0fff,	/*  Resolution of A/D */
+			0x0fff,	/*  Resolution of D/A */
+			&range_analog,	/*  Rangelist for A/D */
+			range_codes_analog,	/*  Range codes for programming */
+		&range_analog},	/*  Rangelist for D/A */
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
@@ -186,22 +186,22 @@ static comedi_driver driver_icp_multi = 
 COMEDI_INITCLEANUP(driver_icp_multi);
 
 typedef struct {
-	struct pcilst_struct *card;	// pointer to card
-	char valid;		// card is usable
-	void *io_addr;		// Pointer to mapped io address
-	resource_size_t phys_iobase;	// Physical io address
-	unsigned int AdcCmdStatus;	// ADC Command/Status register
-	unsigned int DacCmdStatus;	// DAC Command/Status register
-	unsigned int IntEnable;	// Interrupt Enable register
-	unsigned int IntStatus;	// Interrupt Status register
-	unsigned int act_chanlist[32];	// list of scaned channel
-	unsigned char act_chanlist_len;	// len of scanlist
-	unsigned char act_chanlist_pos;	// actual position in MUX list
-	unsigned int *ai_chanlist;	// actaul chanlist
-	sampl_t *ai_data;	// data buffer
-	sampl_t ao_data[4];	// data output buffer
-	sampl_t di_data;	// Digital input data
-	unsigned int do_data;	// Remember digital output data
+	struct pcilst_struct *card;	/*  pointer to card */
+	char valid;		/*  card is usable */
+	void *io_addr;		/*  Pointer to mapped io address */
+	resource_size_t phys_iobase;	/*  Physical io address */
+	unsigned int AdcCmdStatus;	/*  ADC Command/Status register */
+	unsigned int DacCmdStatus;	/*  DAC Command/Status register */
+	unsigned int IntEnable;	/*  Interrupt Enable register */
+	unsigned int IntStatus;	/*  Interrupt Status register */
+	unsigned int act_chanlist[32];	/*  list of scaned channel */
+	unsigned char act_chanlist_len;	/*  len of scanlist */
+	unsigned char act_chanlist_pos;	/*  actual position in MUX list */
+	unsigned int *ai_chanlist;	/*  actaul chanlist */
+	sampl_t *ai_data;	/*  data buffer */
+	sampl_t ao_data[4];	/*  data output buffer */
+	sampl_t di_data;	/*  Digital input data */
+	unsigned int do_data;	/*  Remember digital output data */
 } icp_multi_private;
 
 #define devpriv ((icp_multi_private *)dev->private)
@@ -253,15 +253,15 @@ static int icp_multi_insn_read_ai(comedi
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG: BGN: icp_multi_insn_read_ai(...)\n");
 #endif
-	// Disable A/D conversion ready interrupt
+	/*  Disable A/D conversion ready interrupt */
 	devpriv->IntEnable &= ~ADC_READY;
 	writew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);
 
-	// Clear interrupt status
+	/*  Clear interrupt status */
 	devpriv->IntStatus |= ADC_READY;
 	writew(devpriv->IntStatus, devpriv->io_addr + ICP_MULTI_INT_STAT);
 
-	// Set up appropriate channel, mode and range data, for specified channel
+	/*  Set up appropriate channel, mode and range data, for specified channel */
 	setup_channel_list(dev, s, &insn->chanspec, 1);
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -271,7 +271,7 @@ static int icp_multi_insn_read_ai(comedi
 #endif
 
 	for (n = 0; n < insn->n; n++) {
-		// Set start ADC bit
+		/*  Set start ADC bit */
 		devpriv->AdcCmdStatus |= ADC_ST;
 		writew(devpriv->AdcCmdStatus,
 			devpriv->io_addr + ICP_MULTI_ADC_CSR);
@@ -289,7 +289,7 @@ static int icp_multi_insn_read_ai(comedi
 			readw(devpriv->io_addr + ICP_MULTI_ADC_CSR));
 #endif
 
-		// Wait for conversion to complete, or get fed up waiting
+		/*  Wait for conversion to complete, or get fed up waiting */
 		timeout = 100;
 		while (timeout--) {
 			if (!(readw(devpriv->io_addr +
@@ -307,19 +307,19 @@ static int icp_multi_insn_read_ai(comedi
 			comedi_udelay(1);
 		}
 
-		// If we reach here, a timeout has occurred
+		/*  If we reach here, a timeout has occurred */
 		comedi_error(dev, "A/D insn timeout");
 
-		// Disable interrupt
+		/*  Disable interrupt */
 		devpriv->IntEnable &= ~ADC_READY;
 		writew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);
 
-		// Clear interrupt status
+		/*  Clear interrupt status */
 		devpriv->IntStatus |= ADC_READY;
 		writew(devpriv->IntStatus,
 			devpriv->io_addr + ICP_MULTI_INT_STAT);
 
-		// Clear data received
+		/*  Clear data received */
 		data[n] = 0;
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -332,11 +332,11 @@ static int icp_multi_insn_read_ai(comedi
 			(readw(devpriv->io_addr + ICP_MULTI_AI) >> 4) & 0x0fff;
 	}
 
-	// Disable interrupt
+	/*  Disable interrupt */
 	devpriv->IntEnable &= ~ADC_READY;
 	writew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);
 
-	// Clear interrupt status
+	/*  Clear interrupt status */
 	devpriv->IntStatus |= ADC_READY;
 	writew(devpriv->IntStatus, devpriv->io_addr + ICP_MULTI_INT_STAT);
 
@@ -372,23 +372,23 @@ static int icp_multi_insn_write_ao(comed
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG: BGN: icp_multi_insn_write_ao(...)\n");
 #endif
-	// Disable D/A conversion ready interrupt
+	/*  Disable D/A conversion ready interrupt */
 	devpriv->IntEnable &= ~DAC_READY;
 	writew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);
 
-	// Clear interrupt status
+	/*  Clear interrupt status */
 	devpriv->IntStatus |= DAC_READY;
 	writew(devpriv->IntStatus, devpriv->io_addr + ICP_MULTI_INT_STAT);
 
-	// Get channel number and range
+	/*  Get channel number and range */
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 
-	// Set up range and channel data
-	// Bit 4 = 1 : Bipolar
-	// Bit 5 = 0 : 5V
-	// Bit 5 = 1 : 10V
-	// Bits 8-9 : Channel number
+	/*  Set up range and channel data */
+	/*  Bit 4 = 1 : Bipolar */
+	/*  Bit 5 = 0 : 5V */
+	/*  Bit 5 = 1 : 10V */
+	/*  Bits 8-9 : Channel number */
 	devpriv->DacCmdStatus &= 0xfccf;
 	devpriv->DacCmdStatus |= this_board->rangecode[range];
 	devpriv->DacCmdStatus |= (chan << 8);
@@ -396,7 +396,7 @@ static int icp_multi_insn_write_ao(comed
 	writew(devpriv->DacCmdStatus, devpriv->io_addr + ICP_MULTI_DAC_CSR);
 
 	for (n = 0; n < insn->n; n++) {
-		// Wait for analogue output data register to be ready for new data, or get fed up waiting
+		/*  Wait for analogue output data register to be ready for new data, or get fed up waiting */
 		timeout = 100;
 		while (timeout--) {
 			if (!(readw(devpriv->io_addr +
@@ -414,19 +414,19 @@ static int icp_multi_insn_write_ao(comed
 			comedi_udelay(1);
 		}
 
-		// If we reach here, a timeout has occurred
+		/*  If we reach here, a timeout has occurred */
 		comedi_error(dev, "D/A insn timeout");
 
-		// Disable interrupt
+		/*  Disable interrupt */
 		devpriv->IntEnable &= ~DAC_READY;
 		writew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);
 
-		// Clear interrupt status
+		/*  Clear interrupt status */
 		devpriv->IntStatus |= DAC_READY;
 		writew(devpriv->IntStatus,
 			devpriv->io_addr + ICP_MULTI_INT_STAT);
 
-		// Clear data received
+		/*  Clear data received */
 		devpriv->ao_data[chan] = 0;
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -435,16 +435,16 @@ static int icp_multi_insn_write_ao(comed
 		return -ETIME;
 
 	      dac_ready:
-		// Write data to analogue output data register
+		/*  Write data to analogue output data register */
 		writew(data[n], devpriv->io_addr + ICP_MULTI_AO);
 
-		// Set DAC_ST bit to write the data to selected channel
+		/*  Set DAC_ST bit to write the data to selected channel */
 		devpriv->DacCmdStatus |= DAC_ST;
 		writew(devpriv->DacCmdStatus,
 			devpriv->io_addr + ICP_MULTI_DAC_CSR);
 		devpriv->DacCmdStatus &= ~DAC_ST;
 
-		// Save analogue output data
+		/*  Save analogue output data */
 		devpriv->ao_data[chan] = data[n];
 	}
 
@@ -477,10 +477,10 @@ static int icp_multi_insn_read_ao(comedi
 {
 	int n, chan;
 
-	// Get channel number
+	/*  Get channel number */
 	chan = CR_CHAN(insn->chanspec);
 
-	// Read analogue outputs
+	/*  Read analogue outputs */
 	for (n = 0; n < insn->n; n++)
 		data[n] = devpriv->ao_data[chan];
 
@@ -628,10 +628,10 @@ static irqreturn_t interrupt_service_icp
 		irq);
 #endif
 
-	// Is this interrupt from our board?
+	/*  Is this interrupt from our board? */
 	int_no = readw(devpriv->io_addr + ICP_MULTI_INT_STAT) & Status_IRQ;
 	if (!int_no)
-		// No, exit
+		/*  No, exit */
 		return IRQ_NONE;
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -639,7 +639,7 @@ static irqreturn_t interrupt_service_icp
 		readw(devpriv->io_addr + ICP_MULTI_INT_STAT));
 #endif
 
-	// Determine which interrupt is active & handle it
+	/*  Determine which interrupt is active & handle it */
 	switch (int_no) {
 	case ADC_READY:
 		break;
@@ -697,14 +697,14 @@ static int check_channel_list(comedi_dev
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG:  check_channel_list(...,%d)\n", n_chan);
 #endif
-	// Check that we at least have one channel to check
+	/*  Check that we at least have one channel to check */
 	if (n_chan < 1) {
 		comedi_error(dev, "range/channel list is empty!");
 		return 0;
 	}
-	// Check all channels
+	/*  Check all channels */
 	for (i = 0; i < n_chan; i++) {
-		// Check that channel number is < maximum
+		/*  Check that channel number is < maximum */
 		if (CR_AREF(chanlist[i]) == AREF_DIFF) {
 			if (CR_CHAN(chanlist[i]) > this_board->n_aichand) {
 				comedi_error(dev,
@@ -756,10 +756,10 @@ static void setup_channel_list(comedi_de
 	devpriv->act_chanlist_pos = 0;
 
 	for (i = 0; i < n_chan; i++) {
-		// Get channel
+		/*  Get channel */
 		chanprog = CR_CHAN(chanlist[i]);
 
-		// Determine if it is a differential channel (Bit 15  = 1)
+		/*  Determine if it is a differential channel (Bit 15  = 1) */
 		if (CR_AREF(chanlist[i]) == AREF_DIFF) {
 			diff = 1;
 			chanprog &= 0x0007;
@@ -768,21 +768,21 @@ static void setup_channel_list(comedi_de
 			chanprog &= 0x000f;
 		}
 
-		// Clear channel, range and input mode bits in A/D command/status register
+		/*  Clear channel, range and input mode bits in A/D command/status register */
 		devpriv->AdcCmdStatus &= 0xf00f;
 
-		// Set channel number and differential mode status bit
+		/*  Set channel number and differential mode status bit */
 		if (diff) {
-			// Set channel number, bits 9-11 & mode, bit 6
+			/*  Set channel number, bits 9-11 & mode, bit 6 */
 			devpriv->AdcCmdStatus |= (chanprog << 9);
 			devpriv->AdcCmdStatus |= ADC_DI;
 		} else
-			// Set channel number, bits 8-11
+			/*  Set channel number, bits 8-11 */
 			devpriv->AdcCmdStatus |= (chanprog << 8);
 
-		// Get range for current channel
+		/*  Get range for current channel */
 		range = this_board->rangecode[CR_RANGE(chanlist[i])];
-		// Set range. bits 4-5
+		/*  Set range. bits 4-5 */
 		devpriv->AdcCmdStatus |= range;
 
 		/* Output channel, range, mode to ICP Multi */
@@ -819,32 +819,32 @@ static int icp_multi_reset(comedi_device
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp_multi EDBG: BGN: icp_multi_reset(...)\n");
 #endif
-	// Clear INT enables and requests
+	/*  Clear INT enables and requests */
 	writew(0, devpriv->io_addr + ICP_MULTI_INT_EN);
 	writew(0x00ff, devpriv->io_addr + ICP_MULTI_INT_STAT);
 
 	if (this_board->n_aochan)
-		// Set DACs to 0..5V range and 0V output
+		/*  Set DACs to 0..5V range and 0V output */
 		for (i = 0; i < this_board->n_aochan; i++) {
 			devpriv->DacCmdStatus &= 0xfcce;
 
-			// Set channel number
+			/*  Set channel number */
 			devpriv->DacCmdStatus |= (i << 8);
 
-			// Output 0V
+			/*  Output 0V */
 			writew(0, devpriv->io_addr + ICP_MULTI_AO);
 
-			// Set start conversion bit
+			/*  Set start conversion bit */
 			devpriv->DacCmdStatus |= DAC_ST;
 
-			// Output to command / status register
+			/*  Output to command / status register */
 			writew(devpriv->DacCmdStatus,
 				devpriv->io_addr + ICP_MULTI_DAC_CSR);
 
-			// Delay to allow DAC time to recover
+			/*  Delay to allow DAC time to recover */
 			comedi_udelay(1);
 		}
-	// Digital outputs to 0
+	/*  Digital outputs to 0 */
 	writew(0, devpriv->io_addr + ICP_MULTI_DO);
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -881,11 +881,11 @@ static int icp_multi_attach(comedi_devic
 
 	printk("icp_multi EDBG: BGN: icp_multi_attach(...)\n");
 
-	// Alocate private data storage space
+	/*  Alocate private data storage space */
 	if ((ret = alloc_private(dev, sizeof(icp_multi_private))) < 0)
 		return ret;
 
-	// Initialise list of PCI cards in system, if not already done so
+	/*  Initialise list of PCI cards in system, if not already done so */
 	if (pci_list_builded++ == 0) {
 		pci_card_list_init(PCI_VENDOR_ID_ICP,
 #ifdef ICP_MULTI_EXTDEBUG
--- a/drivers/staging/comedi/drivers/icp_multi.h
+++ b/drivers/staging/comedi/drivers/icp_multi.h
@@ -28,7 +28,8 @@ struct pcilst_struct {
 	unsigned int irq;
 };
 
-struct pcilst_struct *inova_devices;	// ptr to root list of all Inova devices
+struct pcilst_struct *inova_devices;
+/* ptr to root list of all Inova devices */
 
 /****************************************************************************/
 
@@ -150,14 +151,14 @@ static int find_free_pci_card_by_positio
 			&& (inova->pci_slot == pci_slot)) {
 			if (!(inova->used)) {
 				*card = inova;
-				return 0;	// ok, card is found
+				return 0;	/* ok, card is found */
 			} else {
-				return 2;	// card exist but is used
+				return 2;	/* card exist but is used */
 			}
 		}
 	}
 
-	return 1;		// no card found
+	return 1;		/* no card found */
 }
 
 /****************************************************************************/
@@ -243,7 +244,7 @@ static struct pcilst_struct *select_and_
 	struct pcilst_struct *card;
 	int err;
 
-	if ((pci_bus < 1) & (pci_slot < 1)) {	// use autodetection
+	if ((pci_bus < 1) & (pci_slot < 1)) {	/* use autodetection */
 		if ((card = find_free_pci_card_by_device(vendor_id,
 					device_id)) == NULL) {
 			rt_printk(" - Unused card not found in system!\n");
--- a/drivers/staging/comedi/drivers/me4000.c
+++ b/drivers/staging/comedi/drivers/me4000.c
@@ -277,7 +277,7 @@ static int me4000_attach(comedi_device *
 		s->subdev_flags =
 			SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
 		s->n_chan = thisboard->ai.count;
-		s->maxdata = 0xFFFF;	// 16 bit ADC
+		s->maxdata = 0xFFFF;	/*  16 bit ADC */
 		s->len_chanlist = ME4000_AI_CHANNEL_LIST_COUNT;
 		s->range_table = &me4000_ai_range;
 		s->insn_read = me4000_ai_insn_read;
@@ -312,7 +312,7 @@ static int me4000_attach(comedi_device *
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITEABLE | SDF_COMMON | SDF_GROUND;
 		s->n_chan = thisboard->ao.count;
-		s->maxdata = 0xFFFF;	// 16 bit DAC
+		s->maxdata = 0xFFFF;	/*  16 bit DAC */
 		s->range_table = &me4000_ao_range;
 		s->insn_write = me4000_ao_insn_write;
 		s->insn_read = me4000_ao_insn_read;
@@ -358,7 +358,7 @@ static int me4000_attach(comedi_device *
 		s->type = COMEDI_SUBD_COUNTER;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 		s->n_chan = thisboard->cnt.count;
-		s->maxdata = 0xFFFF;	// 16 bit counters
+		s->maxdata = 0xFFFF;	/*  16 bit counters */
 		s->insn_read = me4000_cnt_insn_read;
 		s->insn_write = me4000_cnt_insn_write;
 		s->insn_config = me4000_cnt_insn_config;
@@ -571,8 +571,8 @@ static int init_board_info(comedi_device
 	CALL_PDEBUG("In init_board_info()\n");
 
 	/* Init spin locks */
-	//spin_lock_init(&info->preload_lock);
-	//spin_lock_init(&info->ai_ctrl_lock);
+	/* spin_lock_init(&info->preload_lock); */
+	/* spin_lock_init(&info->ai_ctrl_lock); */
 
 	/* Get the serial number */
 	result = pci_read_config_dword(pci_dev_p, 0x2C, &info->serial_no);
@@ -605,7 +605,7 @@ static int init_ao_context(comedi_device
 	CALL_PDEBUG("In init_ao_context()\n");
 
 	for (i = 0; i < thisboard->ao.count; i++) {
-		//spin_lock_init(&info->ao_context[i].use_lock);
+		/* spin_lock_init(&info->ao_context[i].use_lock); */
 		info->ao_context[i].irq = info->irq;
 
 		switch (i) {
@@ -1604,21 +1604,21 @@ static int me4000_ai_do_cmd_test(comedi_
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev->minor);
-			cmd->start_arg = 2000;	// 66 ticks at least
+			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev->minor);
-			cmd->convert_arg = 2000;	// 66 ticks at least
+			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (scan_ticks <= cmd->chanlist_len * chan_ticks) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
 				dev->minor);
-			cmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;	// At least one tick more
+			cmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;	/*  At least one tick more */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_NOW &&
@@ -1630,14 +1630,14 @@ static int me4000_ai_do_cmd_test(comedi_
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev->minor);
-			cmd->start_arg = 2000;	// 66 ticks at least
+			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev->minor);
-			cmd->convert_arg = 2000;	// 66 ticks at least
+			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_EXT &&
@@ -1649,21 +1649,21 @@ static int me4000_ai_do_cmd_test(comedi_
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev->minor);
-			cmd->start_arg = 2000;	// 66 ticks at least
+			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev->minor);
-			cmd->convert_arg = 2000;	// 66 ticks at least
+			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (scan_ticks <= cmd->chanlist_len * chan_ticks) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
 				dev->minor);
-			cmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;	// At least one tick more
+			cmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;	/*  At least one tick more */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_EXT &&
@@ -1675,14 +1675,14 @@ static int me4000_ai_do_cmd_test(comedi_
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev->minor);
-			cmd->start_arg = 2000;	// 66 ticks at least
+			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev->minor);
-			cmd->convert_arg = 2000;	// 66 ticks at least
+			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_EXT &&
@@ -1694,14 +1694,14 @@ static int me4000_ai_do_cmd_test(comedi_
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev->minor);
-			cmd->start_arg = 2000;	// 66 ticks at least
+			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks < ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev->minor);
-			cmd->convert_arg = 2000;	// 66 ticks at least
+			cmd->convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd->start_src == TRIG_EXT &&
@@ -1713,7 +1713,7 @@ static int me4000_ai_do_cmd_test(comedi_
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev->minor);
-			cmd->start_arg = 2000;	// 66 ticks at least
+			cmd->start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	}
--- a/drivers/staging/comedi/drivers/me4000.h
+++ b/drivers/staging/comedi/drivers/me4000.h
@@ -28,37 +28,37 @@
   Debug section
   ===========================================================================*/
 
-#undef ME4000_CALL_DEBUG	// Debug function entry and exit
-#undef ME4000_PORT_DEBUG	// Debug port access
-#undef ME4000_ISR_DEBUG		// Debug the interrupt service routine
-#undef ME4000_DEBUG		// General purpose debug masseges
+#undef ME4000_CALL_DEBUG	/*  Debug function entry and exit */
+#undef ME4000_PORT_DEBUG	/*  Debug port access */
+#undef ME4000_ISR_DEBUG		/*  Debug the interrupt service routine */
+#undef ME4000_DEBUG		/*  General purpose debug masseges */
 
 #ifdef ME4000_CALL_DEBUG
 #undef CALL_PDEBUG
 #define CALL_PDEBUG(fmt, args...) printk(KERN_DEBUG"comedi%d: me4000: " fmt, dev->minor, ##args)
 #else
-# define CALL_PDEBUG(fmt, args...)	// no debugging, do nothing
+# define CALL_PDEBUG(fmt, args...)	/*  no debugging, do nothing */
 #endif
 
 #ifdef ME4000_PORT_DEBUG
 #undef PORT_PDEBUG
 #define PORT_PDEBUG(fmt, args...) printk(KERN_DEBUG"comedi%d: me4000: " fmt, dev->minor,  ##args)
 #else
-#define PORT_PDEBUG(fmt, args...)	// no debugging, do nothing
+#define PORT_PDEBUG(fmt, args...)	/*  no debugging, do nothing */
 #endif
 
 #ifdef ME4000_ISR_DEBUG
 #undef ISR_PDEBUG
 #define ISR_PDEBUG(fmt, args...) printk(KERN_DEBUG"comedi%d: me4000: " fmt, dev->minor,  ##args)
 #else
-#define ISR_PDEBUG(fmt, args...)	// no debugging, do nothing
+#define ISR_PDEBUG(fmt, args...)	/*  no debugging, do nothing */
 #endif
 
 #ifdef ME4000_DEBUG
 #undef PDEBUG
 #define PDEBUG(fmt, args...) printk(KERN_DEBUG"comedi%d: me4000: " fmt, dev->minor,  ##args)
 #else
-#define PDEBUG(fmt, args...)	// no debugging, do nothing
+#define PDEBUG(fmt, args...)	/*  no debugging, do nothing */
 #endif
 
 /*=============================================================================
@@ -67,78 +67,78 @@
 
 #define PCI_VENDOR_ID_MEILHAUS 0x1402
 
-#define PCI_DEVICE_ID_MEILHAUS_ME4650	0x4650	// Low Cost version
+#define PCI_DEVICE_ID_MEILHAUS_ME4650	0x4650	/*  Low Cost version */
 
-#define PCI_DEVICE_ID_MEILHAUS_ME4660	0x4660	// Standard version
-#define PCI_DEVICE_ID_MEILHAUS_ME4660I	0x4661	// Isolated version
-#define PCI_DEVICE_ID_MEILHAUS_ME4660S	0x4662	// Standard version with Sample and Hold
-#define PCI_DEVICE_ID_MEILHAUS_ME4660IS	0x4663	// Isolated version with Sample and Hold
-
-#define PCI_DEVICE_ID_MEILHAUS_ME4670	0x4670	// Standard version
-#define PCI_DEVICE_ID_MEILHAUS_ME4670I	0x4671	// Isolated version
-#define PCI_DEVICE_ID_MEILHAUS_ME4670S	0x4672	// Standard version with Sample and Hold
-#define PCI_DEVICE_ID_MEILHAUS_ME4670IS	0x4673	// Isolated version with Sample and Hold
-
-#define PCI_DEVICE_ID_MEILHAUS_ME4680	0x4680	// Standard version
-#define PCI_DEVICE_ID_MEILHAUS_ME4680I	0x4681	// Isolated version
-#define PCI_DEVICE_ID_MEILHAUS_ME4680S	0x4682	// Standard version with Sample and Hold
-#define PCI_DEVICE_ID_MEILHAUS_ME4680IS	0x4683	// Isolated version with Sample and Hold
+#define PCI_DEVICE_ID_MEILHAUS_ME4660	0x4660	/*  Standard version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4660I	0x4661	/*  Isolated version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4660S	0x4662	/*  Standard version with Sample and Hold */
+#define PCI_DEVICE_ID_MEILHAUS_ME4660IS	0x4663	/*  Isolated version with Sample and Hold */
+
+#define PCI_DEVICE_ID_MEILHAUS_ME4670	0x4670	/*  Standard version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4670I	0x4671	/*  Isolated version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4670S	0x4672	/*  Standard version with Sample and Hold */
+#define PCI_DEVICE_ID_MEILHAUS_ME4670IS	0x4673	/*  Isolated version with Sample and Hold */
+
+#define PCI_DEVICE_ID_MEILHAUS_ME4680	0x4680	/*  Standard version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4680I	0x4681	/*  Isolated version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4680S	0x4682	/*  Standard version with Sample and Hold */
+#define PCI_DEVICE_ID_MEILHAUS_ME4680IS	0x4683	/*  Isolated version with Sample and Hold */
 
 /*=============================================================================
   ME-4000 base register offsets
   ===========================================================================*/
 
-#define ME4000_AO_00_CTRL_REG			0x00	// R/W
-#define ME4000_AO_00_STATUS_REG			0x04	// R/_
-#define ME4000_AO_00_FIFO_REG			0x08	// _/W
-#define ME4000_AO_00_SINGLE_REG			0x0C	// R/W
-#define ME4000_AO_00_TIMER_REG			0x10	// _/W
-
-#define ME4000_AO_01_CTRL_REG			0x18	// R/W
-#define ME4000_AO_01_STATUS_REG			0x1C	// R/_
-#define ME4000_AO_01_FIFO_REG			0x20	// _/W
-#define ME4000_AO_01_SINGLE_REG			0x24	// R/W
-#define ME4000_AO_01_TIMER_REG			0x28	// _/W
-
-#define ME4000_AO_02_CTRL_REG			0x30	// R/W
-#define ME4000_AO_02_STATUS_REG			0x34	// R/_
-#define ME4000_AO_02_FIFO_REG			0x38	// _/W
-#define ME4000_AO_02_SINGLE_REG			0x3C	// R/W
-#define ME4000_AO_02_TIMER_REG			0x40	// _/W
-
-#define ME4000_AO_03_CTRL_REG			0x48	// R/W
-#define ME4000_AO_03_STATUS_REG			0x4C	// R/_
-#define ME4000_AO_03_FIFO_REG			0x50	// _/W
-#define ME4000_AO_03_SINGLE_REG			0x54	// R/W
-#define ME4000_AO_03_TIMER_REG			0x58	// _/W
-
-#define ME4000_AI_CTRL_REG			0x74	// _/W
-#define ME4000_AI_STATUS_REG			0x74	// R/_
-#define ME4000_AI_CHANNEL_LIST_REG		0x78	// _/W
-#define ME4000_AI_DATA_REG			0x7C	// R/_
-#define ME4000_AI_CHAN_TIMER_REG		0x80	// _/W
-#define ME4000_AI_CHAN_PRE_TIMER_REG		0x84	// _/W
-#define ME4000_AI_SCAN_TIMER_LOW_REG		0x88	// _/W
-#define ME4000_AI_SCAN_TIMER_HIGH_REG		0x8C	// _/W
-#define ME4000_AI_SCAN_PRE_TIMER_LOW_REG	0x90	// _/W
-#define ME4000_AI_SCAN_PRE_TIMER_HIGH_REG	0x94	// _/W
-#define ME4000_AI_START_REG			0x98	// R/_
-
-#define ME4000_IRQ_STATUS_REG			0x9C	// R/_
-
-#define ME4000_DIO_PORT_0_REG			0xA0	// R/W
-#define ME4000_DIO_PORT_1_REG			0xA4	// R/W
-#define ME4000_DIO_PORT_2_REG			0xA8	// R/W
-#define ME4000_DIO_PORT_3_REG			0xAC	// R/W
-#define ME4000_DIO_DIR_REG			0xB0	// R/W
+#define ME4000_AO_00_CTRL_REG			0x00	/*  R/W */
+#define ME4000_AO_00_STATUS_REG			0x04	/*  R/_ */
+#define ME4000_AO_00_FIFO_REG			0x08	/*  _/W */
+#define ME4000_AO_00_SINGLE_REG			0x0C	/*  R/W */
+#define ME4000_AO_00_TIMER_REG			0x10	/*  _/W */
+
+#define ME4000_AO_01_CTRL_REG			0x18	/*  R/W */
+#define ME4000_AO_01_STATUS_REG			0x1C	/*  R/_ */
+#define ME4000_AO_01_FIFO_REG			0x20	/*  _/W */
+#define ME4000_AO_01_SINGLE_REG			0x24	/*  R/W */
+#define ME4000_AO_01_TIMER_REG			0x28	/*  _/W */
+
+#define ME4000_AO_02_CTRL_REG			0x30	/*  R/W */
+#define ME4000_AO_02_STATUS_REG			0x34	/*  R/_ */
+#define ME4000_AO_02_FIFO_REG			0x38	/*  _/W */
+#define ME4000_AO_02_SINGLE_REG			0x3C	/*  R/W */
+#define ME4000_AO_02_TIMER_REG			0x40	/*  _/W */
+
+#define ME4000_AO_03_CTRL_REG			0x48	/*  R/W */
+#define ME4000_AO_03_STATUS_REG			0x4C	/*  R/_ */
+#define ME4000_AO_03_FIFO_REG			0x50	/*  _/W */
+#define ME4000_AO_03_SINGLE_REG			0x54	/*  R/W */
+#define ME4000_AO_03_TIMER_REG			0x58	/*  _/W */
+
+#define ME4000_AI_CTRL_REG			0x74	/*  _/W */
+#define ME4000_AI_STATUS_REG			0x74	/*  R/_ */
+#define ME4000_AI_CHANNEL_LIST_REG		0x78	/*  _/W */
+#define ME4000_AI_DATA_REG			0x7C	/*  R/_ */
+#define ME4000_AI_CHAN_TIMER_REG		0x80	/*  _/W */
+#define ME4000_AI_CHAN_PRE_TIMER_REG		0x84	/*  _/W */
+#define ME4000_AI_SCAN_TIMER_LOW_REG		0x88	/*  _/W */
+#define ME4000_AI_SCAN_TIMER_HIGH_REG		0x8C	/*  _/W */
+#define ME4000_AI_SCAN_PRE_TIMER_LOW_REG	0x90	/*  _/W */
+#define ME4000_AI_SCAN_PRE_TIMER_HIGH_REG	0x94	/*  _/W */
+#define ME4000_AI_START_REG			0x98	/*  R/_ */
+
+#define ME4000_IRQ_STATUS_REG			0x9C	/*  R/_ */
+
+#define ME4000_DIO_PORT_0_REG			0xA0	/*  R/W */
+#define ME4000_DIO_PORT_1_REG			0xA4	/*  R/W */
+#define ME4000_DIO_PORT_2_REG			0xA8	/*  R/W */
+#define ME4000_DIO_PORT_3_REG			0xAC	/*  R/W */
+#define ME4000_DIO_DIR_REG			0xB0	/*  R/W */
 
-#define ME4000_AO_LOADSETREG_XX			0xB4	// R/W
+#define ME4000_AO_LOADSETREG_XX			0xB4	/*  R/W */
 
-#define ME4000_DIO_CTRL_REG			0xB8	// R/W
+#define ME4000_DIO_CTRL_REG			0xB8	/*  R/W */
 
-#define ME4000_AO_DEMUX_ADJUST_REG		0xBC	// -/W
+#define ME4000_AO_DEMUX_ADJUST_REG		0xBC	/*  -/W */
 
-#define ME4000_AI_SAMPLE_COUNTER_REG		0xC0	// _/W
+#define ME4000_AI_SAMPLE_COUNTER_REG		0xC0	/*  _/W */
 
 /*=============================================================================
   Value to adjust Demux
@@ -159,21 +159,21 @@
   PLX base register offsets
   ===========================================================================*/
 
-#define PLX_INTCSR	0x4C	// Interrupt control and status register
-#define PLX_ICR		0x50	// Initialization control register
+#define PLX_INTCSR	0x4C	/*  Interrupt control and status register */
+#define PLX_ICR		0x50	/*  Initialization control register */
 
 /*=============================================================================
   Bits for the PLX_ICSR register
   ===========================================================================*/
 
-#define PLX_INTCSR_LOCAL_INT1_EN             0x01	// If set, local interrupt 1 is enabled (r/w)
-#define PLX_INTCSR_LOCAL_INT1_POL            0x02	// If set, local interrupt 1 polarity is active high (r/w)
-#define PLX_INTCSR_LOCAL_INT1_STATE          0x04	// If set, local interrupt 1 is active (r/_)
-#define PLX_INTCSR_LOCAL_INT2_EN             0x08	// If set, local interrupt 2 is enabled (r/w)
-#define PLX_INTCSR_LOCAL_INT2_POL            0x10	// If set, local interrupt 2 polarity is active high (r/w)
-#define PLX_INTCSR_LOCAL_INT2_STATE          0x20	// If set, local interrupt 2 is active  (r/_)
-#define PLX_INTCSR_PCI_INT_EN                0x40	// If set, PCI interrupt is enabled (r/w)
-#define PLX_INTCSR_SOFT_INT                  0x80	// If set, a software interrupt is generated (r/w)
+#define PLX_INTCSR_LOCAL_INT1_EN             0x01	/*  If set, local interrupt 1 is enabled (r/w) */
+#define PLX_INTCSR_LOCAL_INT1_POL            0x02	/*  If set, local interrupt 1 polarity is active high (r/w) */
+#define PLX_INTCSR_LOCAL_INT1_STATE          0x04	/*  If set, local interrupt 1 is active (r/_) */
+#define PLX_INTCSR_LOCAL_INT2_EN             0x08	/*  If set, local interrupt 2 is enabled (r/w) */
+#define PLX_INTCSR_LOCAL_INT2_POL            0x10	/*  If set, local interrupt 2 polarity is active high (r/w) */
+#define PLX_INTCSR_LOCAL_INT2_STATE          0x20	/*  If set, local interrupt 2 is active  (r/_) */
+#define PLX_INTCSR_PCI_INT_EN                0x40	/*  If set, PCI interrupt is enabled (r/w) */
+#define PLX_INTCSR_SOFT_INT                  0x80	/*  If set, a software interrupt is generated (r/w) */
 
 /*=============================================================================
   Bits for the PLX_ICR register
@@ -331,7 +331,7 @@ typedef struct me4000_board {
 typedef struct me4000_ao_context {
 	int irq;
 
-	unsigned long mirror;	// Store the last written value
+	unsigned long mirror;	/*  Store the last written value */
 
 	unsigned long ctrl_reg;
 	unsigned long status_reg;
@@ -377,29 +377,29 @@ typedef struct me4000_cnt_context {
 } me4000_cnt_context_t;
 
 typedef struct me4000_info {
-	unsigned long plx_regbase;	// PLX configuration space base address
-	unsigned long me4000_regbase;	// Base address of the ME4000
-	unsigned long timer_regbase;	// Base address of the timer circuit
-	unsigned long program_regbase;	// Base address to set the program pin for the xilinx
-
-	unsigned long plx_regbase_size;	// PLX register set space
-	unsigned long me4000_regbase_size;	// ME4000 register set space
-	unsigned long timer_regbase_size;	// Timer circuit register set space
-	unsigned long program_regbase_size;	// Size of program base address of the ME4000
-
-	unsigned int serial_no;	// Serial number of the board
-	unsigned char hw_revision;	// Hardware revision of the board
-	unsigned short vendor_id;	// Meilhaus vendor id
-	unsigned short device_id;	// Device id
-
-	struct pci_dev *pci_dev_p;	// General PCI information
-
-	unsigned int irq;	// IRQ assigned from the PCI BIOS
-
-	struct me4000_ai_context ai_context;	// Analog input  specific context
-	struct me4000_ao_context ao_context[4];	// Vector with analog output specific context
-	struct me4000_dio_context dio_context;	// Digital I/O specific context
-	struct me4000_cnt_context cnt_context;	// Counter specific context
+	unsigned long plx_regbase;	/*  PLX configuration space base address */
+	unsigned long me4000_regbase;	/*  Base address of the ME4000 */
+	unsigned long timer_regbase;	/*  Base address of the timer circuit */
+	unsigned long program_regbase;	/*  Base address to set the program pin for the xilinx */
+
+	unsigned long plx_regbase_size;	/*  PLX register set space */
+	unsigned long me4000_regbase_size;	/*  ME4000 register set space */
+	unsigned long timer_regbase_size;	/*  Timer circuit register set space */
+	unsigned long program_regbase_size;	/*  Size of program base address of the ME4000 */
+
+	unsigned int serial_no;	/*  Serial number of the board */
+	unsigned char hw_revision;	/*  Hardware revision of the board */
+	unsigned short vendor_id;	/*  Meilhaus vendor id */
+	unsigned short device_id;	/*  Device id */
+
+	struct pci_dev *pci_dev_p;	/*  General PCI information */
+
+	unsigned int irq;	/*  IRQ assigned from the PCI BIOS */
+
+	struct me4000_ai_context ai_context;	/*  Analog input  specific context */
+	struct me4000_ao_context ao_context[4];	/*  Vector with analog output specific context */
+	struct me4000_dio_context dio_context;	/*  Digital I/O specific context */
+	struct me4000_cnt_context cnt_context;	/*  Counter specific context */
 } me4000_info_t;
 
 #define info	((me4000_info_t *)dev->private)
@@ -412,7 +412,7 @@ typedef struct me4000_info {
 #define ME4000_AI_FIFO_COUNT			2048
 
 #define ME4000_AI_MIN_TICKS			66
-#define ME4000_AI_MIN_SAMPLE_TIME		2000	// Minimum sample time [ns]
+#define ME4000_AI_MIN_SAMPLE_TIME		2000	/*  Minimum sample time [ns] */
 #define ME4000_AI_BASE_FREQUENCY		(unsigned int) 33E6
 
 /* Channel list defines and masks */
@@ -436,11 +436,11 @@ typedef struct me4000_info {
 #define ME4000_CNT_COUNTER_1  0x40
 #define ME4000_CNT_COUNTER_2  0x80
 
-#define ME4000_CNT_MODE_0     0x00	// Change state if zero crossing
-#define ME4000_CNT_MODE_1     0x02	// Retriggerable One-Shot
-#define ME4000_CNT_MODE_2     0x04	// Asymmetrical divider
-#define ME4000_CNT_MODE_3     0x06	// Symmetrical divider
-#define ME4000_CNT_MODE_4     0x08	// Counter start by software trigger
-#define ME4000_CNT_MODE_5     0x0A	// Counter start by hardware trigger
+#define ME4000_CNT_MODE_0     0x00	/*  Change state if zero crossing */
+#define ME4000_CNT_MODE_1     0x02	/*  Retriggerable One-Shot */
+#define ME4000_CNT_MODE_2     0x04	/*  Asymmetrical divider */
+#define ME4000_CNT_MODE_3     0x06	/*  Symmetrical divider */
+#define ME4000_CNT_MODE_4     0x08	/*  Counter start by software trigger */
+#define ME4000_CNT_MODE_5     0x0A	/*  Counter start by hardware trigger */
 
 #endif
--- a/drivers/staging/comedi/drivers/mite.c
+++ b/drivers/staging/comedi/drivers/mite.c
@@ -47,7 +47,7 @@
 
 */
 
-//#define USE_KMALLOC
+/* #define USE_KMALLOC */
 
 #include "mite.h"
 
@@ -139,7 +139,7 @@ int mite_setup2(struct mite_struct *mite
 	addr = pci_resource_start(mite->pcidev, 1);
 	mite->daq_phys_addr = addr;
 	length = pci_resource_len(mite->pcidev, 1);
-	// In case of a 660x board, DAQ size is 8k instead of 4k (see as shown by lspci output)
+	/*  In case of a 660x board, DAQ size is 8k instead of 4k (see as shown by lspci output) */
 	mite->daq_io_addr = ioremap(mite->daq_phys_addr, length);
 	if (!mite->daq_io_addr) {
 		printk("failed to remap daq io memory address\n");
@@ -212,7 +212,7 @@ void mite_cleanup(void)
 
 void mite_unsetup(struct mite_struct *mite)
 {
-	//unsigned long offset, start, length;
+	/* unsigned long offset, start, length; */
 
 	if (!mite)
 		return;
@@ -257,7 +257,7 @@ struct mite_channel *mite_request_channe
 	unsigned long flags;
 	struct mite_channel *channel = NULL;
 
-	// spin lock so mite_release_channel can be called safely from interrupts
+	/*  spin lock so mite_release_channel can be called safely from interrupts */
 	comedi_spin_lock_irqsave(&mite->lock, flags);
 	for (i = min_channel; i <= max_channel; ++i) {
 		if (mite->channel_allocated[i] == 0) {
@@ -276,7 +276,7 @@ void mite_release_channel(struct mite_ch
 	struct mite_struct *mite = mite_chan->mite;
 	unsigned long flags;
 
-	// spin lock to prevent races with mite_request_channel
+	/*  spin lock to prevent races with mite_request_channel */
 	comedi_spin_lock_irqsave(&mite->lock, flags);
 	if (mite->channel_allocated[mite_chan->channel]) {
 		mite_dma_disarm(mite_chan);
@@ -312,7 +312,7 @@ void mite_dma_arm(struct mite_channel *m
 	writel(chor, mite->mite_io_addr + MITE_CHOR(mite_chan->channel));
 	mmiowb();
 	comedi_spin_unlock_irqrestore(&mite->lock, flags);
-//      mite_dma_tcr(mite, channel);
+/*       mite_dma_tcr(mite, channel); */
 }
 
 /**************************************/
@@ -466,7 +466,7 @@ u32 mite_bytes_in_transit(struct mite_ch
 		MITE_FCR(mite_chan->channel)) & 0x000000FF;
 }
 
-// returns lower bound for number of bytes transferred from device to memory
+/*  returns lower bound for number of bytes transferred from device to memory */
 u32 mite_bytes_written_to_memory_lb(struct mite_channel * mite_chan)
 {
 	u32 device_byte_count;
@@ -475,7 +475,7 @@ u32 mite_bytes_written_to_memory_lb(stru
 	return device_byte_count - mite_bytes_in_transit(mite_chan);
 }
 
-// returns upper bound for number of bytes transferred from device to memory
+/*  returns upper bound for number of bytes transferred from device to memory */
 u32 mite_bytes_written_to_memory_ub(struct mite_channel * mite_chan)
 {
 	u32 in_transit_count;
@@ -484,7 +484,7 @@ u32 mite_bytes_written_to_memory_ub(stru
 	return mite_device_bytes_transferred(mite_chan) - in_transit_count;
 }
 
-// returns lower bound for number of bytes read from memory for transfer to device
+/*  returns lower bound for number of bytes read from memory for transfer to device */
 u32 mite_bytes_read_from_memory_lb(struct mite_channel * mite_chan)
 {
 	u32 device_byte_count;
@@ -493,7 +493,7 @@ u32 mite_bytes_read_from_memory_lb(struc
 	return device_byte_count + mite_bytes_in_transit(mite_chan);
 }
 
-// returns upper bound for number of bytes read from memory for transfer to device
+/*  returns upper bound for number of bytes read from memory for transfer to device */
 u32 mite_bytes_read_from_memory_ub(struct mite_channel * mite_chan)
 {
 	u32 in_transit_count;
@@ -533,7 +533,7 @@ int mite_sync_input_dma(struct mite_chan
 	const unsigned bytes_per_scan = cfc_bytes_per_scan(async->subdevice);
 
 	old_alloc_count = async->buf_write_alloc_count;
-	// write alloc as much as we can
+	/*  write alloc as much as we can */
 	comedi_buf_write_alloc(async, async->prealloc_bufsz);
 
 	nbytes = mite_bytes_written_to_memory_lb(mite_chan);
@@ -570,7 +570,7 @@ int mite_sync_output_dma(struct mite_cha
 		async->cmd.stop_arg * cfc_bytes_per_scan(async->subdevice);
 
 	old_alloc_count = async->buf_read_alloc_count;
-	// read alloc as much as we can
+	/*  read alloc as much as we can */
 	comedi_buf_read_alloc(async, async->prealloc_bufsz);
 	nbytes_lb = mite_bytes_read_from_memory_lb(mite_chan);
 	if (async->cmd.stop_src == TRIG_COUNT &&
--- a/drivers/staging/comedi/drivers/mite.h
+++ b/drivers/staging/comedi/drivers/mite.h
@@ -29,7 +29,7 @@
 
 #define PCI_VENDOR_ID_NATINST		0x1093
 
-// #define DEBUG_MITE
+/*  #define DEBUG_MITE */
 #define PCIMIO_COMPAT
 
 #ifdef DEBUG_MITE
@@ -179,83 +179,83 @@ enum mite_registers {
 	   written and read back.  The bits 0x1f always read as 1.
 	   The rest always read as zero. */
 	MITE_UNKNOWN_DMA_BURST_REG = 0x28,
-	MITE_IODWBSR = 0xc0,	//IO Device Window Base Size Register
-	MITE_IODWBSR_1 = 0xc4,	// IO Device Window Base Size Register 1
+	MITE_IODWBSR = 0xc0,	/* IO Device Window Base Size Register */
+	MITE_IODWBSR_1 = 0xc4,	/*  IO Device Window Base Size Register 1 */
 	MITE_IODWCR_1 = 0xf4,
 	MITE_PCI_CONFIG_OFFSET = 0x300,
-	MITE_CSIGR = 0x460	//chip signature
+	MITE_CSIGR = 0x460	/* chip signature */
 };
-static inline int MITE_CHOR(int channel)	// channel operation
+static inline int MITE_CHOR(int channel)	/*  channel operation */
 {
 	return CHAN_OFFSET(channel) + 0x0;
 };
-static inline int MITE_CHCR(int channel)	// channel control
+static inline int MITE_CHCR(int channel)	/*  channel control */
 {
 	return CHAN_OFFSET(channel) + 0x4;
 };
-static inline int MITE_TCR(int channel)	// transfer count
+static inline int MITE_TCR(int channel)	/*  transfer count */
 {
 	return CHAN_OFFSET(channel) + 0x8;
 };
-static inline int MITE_MCR(int channel)	// memory configuration
+static inline int MITE_MCR(int channel)	/*  memory configuration */
 {
 	return CHAN_OFFSET(channel) + 0xc;
 };
-static inline int MITE_MAR(int channel)	// memory address
+static inline int MITE_MAR(int channel)	/*  memory address */
 {
 	return CHAN_OFFSET(channel) + 0x10;
 };
-static inline int MITE_DCR(int channel)	// device configuration
+static inline int MITE_DCR(int channel)	/*  device configuration */
 {
 	return CHAN_OFFSET(channel) + 0x14;
 };
-static inline int MITE_DAR(int channel)	// device address
+static inline int MITE_DAR(int channel)	/*  device address */
 {
 	return CHAN_OFFSET(channel) + 0x18;
 };
-static inline int MITE_LKCR(int channel)	// link configuration
+static inline int MITE_LKCR(int channel)	/*  link configuration */
 {
 	return CHAN_OFFSET(channel) + 0x1c;
 };
-static inline int MITE_LKAR(int channel)	// link address
+static inline int MITE_LKAR(int channel)	/*  link address */
 {
 	return CHAN_OFFSET(channel) + 0x20;
 };
-static inline int MITE_LLKAR(int channel)	// see mite section of tnt5002 manual
+static inline int MITE_LLKAR(int channel)	/*  see mite section of tnt5002 manual */
 {
 	return CHAN_OFFSET(channel) + 0x24;
 };
-static inline int MITE_BAR(int channel)	// base address
+static inline int MITE_BAR(int channel)	/*  base address */
 {
 	return CHAN_OFFSET(channel) + 0x28;
 };
-static inline int MITE_BCR(int channel)	// base count
+static inline int MITE_BCR(int channel)	/*  base count */
 {
 	return CHAN_OFFSET(channel) + 0x2c;
 };
-static inline int MITE_SAR(int channel)	// ? address
+static inline int MITE_SAR(int channel)	/*  ? address */
 {
 	return CHAN_OFFSET(channel) + 0x30;
 };
-static inline int MITE_WSCR(int channel)	// ?
+static inline int MITE_WSCR(int channel)	/*  ? */
 {
 	return CHAN_OFFSET(channel) + 0x34;
 };
-static inline int MITE_WSER(int channel)	// ?
+static inline int MITE_WSER(int channel)	/*  ? */
 {
 	return CHAN_OFFSET(channel) + 0x38;
 };
-static inline int MITE_CHSR(int channel)	// channel status
+static inline int MITE_CHSR(int channel)	/*  channel status */
 {
 	return CHAN_OFFSET(channel) + 0x3c;
 };
-static inline int MITE_FCR(int channel)	// fifo count
+static inline int MITE_FCR(int channel)	/*  fifo count */
 {
 	return CHAN_OFFSET(channel) + 0x40;
 };
 
 enum MITE_IODWBSR_bits {
-	WENAB = 0x80,		// window enable
+	WENAB = 0x80,		/*  window enable */
 };
 
 static inline unsigned MITE_IODWBSR_1_WSIZE_bits(unsigned size)
@@ -276,23 +276,23 @@ static inline int mite_csigr_version(u32
 	return csigr_bits & 0xf;
 };
 static inline int mite_csigr_type(u32 csigr_bits)
-{				// original mite = 0, minimite = 1
+{				/*  original mite = 0, minimite = 1 */
 	return (csigr_bits >> 4) & 0xf;
 };
 static inline int mite_csigr_mmode(u32 csigr_bits)
-{				// mite mode, minimite = 1
+{				/*  mite mode, minimite = 1 */
 	return (csigr_bits >> 8) & 0x3;
 };
 static inline int mite_csigr_imode(u32 csigr_bits)
-{				// cpu port interface mode, pci = 0x3
+{				/*  cpu port interface mode, pci = 0x3 */
 	return (csigr_bits >> 12) & 0x3;
 };
 static inline int mite_csigr_dmac(u32 csigr_bits)
-{				// number of dma channels
+{				/*  number of dma channels */
 	return (csigr_bits >> 16) & 0xf;
 };
 static inline int mite_csigr_wpdep(u32 csigr_bits)
-{				// write post fifo depth
+{				/*  write post fifo depth */
 	unsigned int wpdep_bits = (csigr_bits >> 20) & 0x7;
 	if (wpdep_bits == 0)
 		return 0;
@@ -304,7 +304,7 @@ static inline int mite_csigr_wins(u32 cs
 	return (csigr_bits >> 24) & 0x1f;
 };
 static inline int mite_csigr_iowins(u32 csigr_bits)
-{				// number of io windows
+{				/*  number of io windows */
 	return (csigr_bits >> 29) & 0x7;
 };
 
--- a/drivers/staging/comedi/drivers/plx9080.h
+++ b/drivers/staging/comedi/drivers/plx9080.h
@@ -27,7 +27,7 @@
 #ifndef __COMEDI_PLX9080_H
 #define __COMEDI_PLX9080_H
 
-// descriptor block used for chained dma transfers
+/*  descriptor block used for chained dma transfers */
 struct plx_dma_desc {
 	volatile uint32_t pci_start_addr;
 	volatile uint32_t local_start_addr;
@@ -52,14 +52,14 @@ struct plx_dma_desc {
 #define  LRNG_ANY32        0x00000000	/* Locate anywhere in 32 bit */
 #define  LRNG_LT1MB        0x00000002	/* Locate in 1st meg */
 #define  LRNG_ANY64        0x00000004	/* Locate anywhere in 64 bit */
-#define  LRNG_MEM_MASK     0xfffffff0	// bits that specify range for memory io
-#define  LRNG_IO_MASK     0xfffffffa	// bits that specify range for normal io
+#define  LRNG_MEM_MASK     0xfffffff0	/*  bits that specify range for memory io */
+#define  LRNG_IO_MASK     0xfffffffa	/*  bits that specify range for normal io */
 
 #define PLX_LAS0MAP_REG         0x0004	/* L, Local Addr Space 0 Remap Register */
 #define PLX_LAS1MAP_REG         0x00f4	/* L, Local Addr Space 1 Remap Register */
 #define  LMAP_EN           0x00000001	/* Enable slave decode */
-#define  LMAP_MEM_MASK     0xfffffff0	// bits that specify decode for memory io
-#define  LMAP_IO_MASK     0xfffffffa	// bits that specify decode bits for normal io
+#define  LMAP_MEM_MASK     0xfffffff0	/*  bits that specify decode for memory io */
+#define  LMAP_IO_MASK     0xfffffffa	/*  bits that specify decode bits for normal io */
 
 /* Mode/Arbitration Register.
 */
@@ -169,7 +169,7 @@ enum bigend_bits {
 #define  ICS_AERR          0x00000001	/* Assert LSERR on ABORT */
 #define  ICS_PERR          0x00000002	/* Assert LSERR on Parity Error */
 #define  ICS_SERR          0x00000004	/* Generate PCI SERR# */
-#define  ICS_MBIE          0x00000008	// mailbox interrupt enable
+#define  ICS_MBIE          0x00000008	/*  mailbox interrupt enable */
 #define  ICS_PIE           0x00000100	/* PCI Interrupt Enable */
 #define  ICS_PDIE          0x00000200	/* PCI Doorbell Interrupt Enable */
 #define  ICS_PAIE          0x00000400	/* PCI Abort Interrupt Enable */
@@ -190,7 +190,7 @@ enum bigend_bits {
 #define  ICS_TA_DMA0       0x02000000	/* Target Abort - DMA #0 */
 #define  ICS_TA_DMA1       0x04000000	/* Target Abort - DMA #1 */
 #define  ICS_TA_RA         0x08000000	/* Target Abort - Retry Timeout */
-#define  ICS_MBIA(x)       (0x10000000 << ((x) & 0x3))	// mailbox x is active
+#define  ICS_MBIA(x)       (0x10000000 << ((x) & 0x3))	/*  mailbox x is active */
 
 #define PLX_CONTROL_REG        0x006C	/* L, EEPROM Cntl & PCI Cmd Codes */
 #define  CTL_RDMA          0x0000000E	/* DMA Read Command */
@@ -208,51 +208,51 @@ enum bigend_bits {
 #define  CTL_RESET         0x40000000	/* !! Adapter Reset !! */
 #define  CTL_READY         0x80000000	/* Local Init Done */
 
-#define PLX_ID_REG	0x70	// hard-coded plx vendor and device ids
+#define PLX_ID_REG	0x70	/*  hard-coded plx vendor and device ids */
 
-#define PLX_REVISION_REG	0x74	// silicon revision
+#define PLX_REVISION_REG	0x74	/*  silicon revision */
 
-#define PLX_DMA0_MODE_REG	0x80	// dma channel 0 mode register
-#define PLX_DMA1_MODE_REG	0x94	// dma channel 0 mode register
+#define PLX_DMA0_MODE_REG	0x80	/*  dma channel 0 mode register */
+#define PLX_DMA1_MODE_REG	0x94	/*  dma channel 0 mode register */
 #define  PLX_LOCAL_BUS_16_WIDE_BITS	0x1
 #define  PLX_LOCAL_BUS_32_WIDE_BITS	0x3
 #define  PLX_LOCAL_BUS_WIDTH_MASK	0x3
-#define  PLX_DMA_EN_READYIN_BIT	0x40	// enable ready in input
-#define  PLX_EN_BTERM_BIT	0x80	// enable BTERM# input
-#define  PLX_DMA_LOCAL_BURST_EN_BIT	0x100	// enable local burst mode
-#define  PLX_EN_CHAIN_BIT	0x200	// enables chaining
-#define  PLX_EN_DMA_DONE_INTR_BIT	0x400	// enables interrupt on dma done
-#define  PLX_LOCAL_ADDR_CONST_BIT	0x800	// hold local address constant (don't increment)
-#define  PLX_DEMAND_MODE_BIT	0x1000	// enables demand-mode for dma transfer
+#define  PLX_DMA_EN_READYIN_BIT	0x40	/*  enable ready in input */
+#define  PLX_EN_BTERM_BIT	0x80	/*  enable BTERM# input */
+#define  PLX_DMA_LOCAL_BURST_EN_BIT	0x100	/*  enable local burst mode */
+#define  PLX_EN_CHAIN_BIT	0x200	/*  enables chaining */
+#define  PLX_EN_DMA_DONE_INTR_BIT	0x400	/*  enables interrupt on dma done */
+#define  PLX_LOCAL_ADDR_CONST_BIT	0x800	/*  hold local address constant (don't increment) */
+#define  PLX_DEMAND_MODE_BIT	0x1000	/*  enables demand-mode for dma transfer */
 #define  PLX_EOT_ENABLE_BIT	0x4000
 #define  PLX_STOP_MODE_BIT 0x8000
-#define  PLX_DMA_INTR_PCI_BIT	0x20000	// routes dma interrupt to pci bus (instead of local bus)
+#define  PLX_DMA_INTR_PCI_BIT	0x20000	/*  routes dma interrupt to pci bus (instead of local bus) */
 
-#define PLX_DMA0_PCI_ADDRESS_REG	0x84	// pci address that dma transfers start at
+#define PLX_DMA0_PCI_ADDRESS_REG	0x84	/*  pci address that dma transfers start at */
 #define PLX_DMA1_PCI_ADDRESS_REG	0x98
 
-#define PLX_DMA0_LOCAL_ADDRESS_REG	0x88	// local address that dma transfers start at
+#define PLX_DMA0_LOCAL_ADDRESS_REG	0x88	/*  local address that dma transfers start at */
 #define PLX_DMA1_LOCAL_ADDRESS_REG	0x9c
 
-#define PLX_DMA0_TRANSFER_SIZE_REG	0x8c	// number of bytes to transfer (first 23 bits)
+#define PLX_DMA0_TRANSFER_SIZE_REG	0x8c	/*  number of bytes to transfer (first 23 bits) */
 #define PLX_DMA1_TRANSFER_SIZE_REG	0xa0
 
-#define PLX_DMA0_DESCRIPTOR_REG	0x90	// descriptor pointer register
+#define PLX_DMA0_DESCRIPTOR_REG	0x90	/*  descriptor pointer register */
 #define PLX_DMA1_DESCRIPTOR_REG	0xa4
-#define  PLX_DESC_IN_PCI_BIT	0x1	// descriptor is located in pci space (not local space)
-#define  PLX_END_OF_CHAIN_BIT	0x2	// end of chain bit
-#define  PLX_INTR_TERM_COUNT	0x4	// interrupt when this descriptor's transfer is finished
-#define  PLX_XFER_LOCAL_TO_PCI 0x8	// transfer from local to pci bus (not pci to local)
+#define  PLX_DESC_IN_PCI_BIT	0x1	/*  descriptor is located in pci space (not local space) */
+#define  PLX_END_OF_CHAIN_BIT	0x2	/*  end of chain bit */
+#define  PLX_INTR_TERM_COUNT	0x4	/*  interrupt when this descriptor's transfer is finished */
+#define  PLX_XFER_LOCAL_TO_PCI 0x8	/*  transfer from local to pci bus (not pci to local) */
 
-#define PLX_DMA0_CS_REG	0xa8	// command status register
+#define PLX_DMA0_CS_REG	0xa8	/*  command status register */
 #define PLX_DMA1_CS_REG	0xa9
-#define  PLX_DMA_EN_BIT	0x1	// enable dma channel
-#define  PLX_DMA_START_BIT	0x2	// start dma transfer
-#define  PLX_DMA_ABORT_BIT	0x4	// abort dma transfer
-#define  PLX_CLEAR_DMA_INTR_BIT	0x8	// clear dma interrupt
-#define  PLX_DMA_DONE_BIT	0x10	// transfer done status bit
+#define  PLX_DMA_EN_BIT	0x1	/*  enable dma channel */
+#define  PLX_DMA_START_BIT	0x2	/*  start dma transfer */
+#define  PLX_DMA_ABORT_BIT	0x4	/*  abort dma transfer */
+#define  PLX_CLEAR_DMA_INTR_BIT	0x8	/*  clear dma interrupt */
+#define  PLX_DMA_DONE_BIT	0x10	/*  transfer done status bit */
 
-#define PLX_DMA0_THRESHOLD_REG	0xb0	// command status register
+#define PLX_DMA0_THRESHOLD_REG	0xb0	/*  command status register */
 
 /*
  * Accesses near the end of memory can cause the PLX chip
@@ -392,12 +392,12 @@ static inline int plx9080_abort_dma(void
 	else
 		dma_cs_addr = iobase + PLX_DMA0_CS_REG;
 
-	// abort dma transfer if necessary
+	/*  abort dma transfer if necessary */
 	dma_status = readb(dma_cs_addr);
 	if ((dma_status & PLX_DMA_EN_BIT) == 0) {
 		return 0;
 	}
-	// wait to make sure done bit is zero
+	/*  wait to make sure done bit is zero */
 	for (i = 0; (dma_status & PLX_DMA_DONE_BIT) && i < timeout; i++) {
 		comedi_udelay(1);
 		dma_status = readb(dma_cs_addr);
@@ -408,9 +408,9 @@ static inline int plx9080_abort_dma(void
 			channel);
 		return -ETIMEDOUT;
 	}
-	// disable and abort channel
+	/*  disable and abort channel */
 	writeb(PLX_DMA_ABORT_BIT, dma_cs_addr);
-	// wait for dma done bit
+	/*  wait for dma done bit */
 	dma_status = readb(dma_cs_addr);
 	for (i = 0; (dma_status & PLX_DMA_DONE_BIT) == 0 && i < timeout; i++) {
 		comedi_udelay(1);
--- a/drivers/staging/comedi/drivers/rtd520.c
+++ b/drivers/staging/comedi/drivers/rtd520.c
@@ -704,7 +704,7 @@ static int rtd_ai_cmdtest(comedi_device 
 	comedi_cmd * cmd);
 static int rtd_ai_cmd(comedi_device * dev, comedi_subdevice * s);
 static int rtd_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-//static int rtd_ai_poll (comedi_device *dev,comedi_subdevice *s);
+/* static int rtd_ai_poll (comedi_device *dev,comedi_subdevice *s); */
 static int rtd_ns_to_timer(unsigned int *ns, int roundMode);
 static irqreturn_t rtd_interrupt(int irq, void *d PT_REGS_ARG);
 static int rtd520_probe_fifo_depth(comedi_device *dev);
@@ -866,7 +866,7 @@ static int rtd_attach(comedi_device * de
 	s->do_cmd = rtd_ai_cmd;
 	s->do_cmdtest = rtd_ai_cmdtest;
 	s->cancel = rtd_ai_cancel;
-	/*s->poll = rtd_ai_poll; *//* not ready yet */
+	/* s->poll = rtd_ai_poll; */ /* not ready yet */
 
 	s = dev->subdevices + 1;
 	/* analog output subdevice */
@@ -1005,7 +1005,7 @@ static int rtd_attach(comedi_device * de
 
 #if 0
 	/* hit an error, clean up memory and return ret */
-//rtd_attach_die_error:
+/* rtd_attach_die_error: */
 #ifdef USE_DMA
 	for (index = 0; index < DMA_CHAIN_COUNT; index++) {
 		if (NULL != devpriv->dma0Buff[index]) {	/* free buffer memory */
@@ -1377,15 +1377,15 @@ void abort_dma(comedi_device * dev, unsi
 	unsigned long dma_cs_addr;	/* the control/status register */
 	uint8_t status;
 	unsigned int ii;
-	//unsigned long flags;
+	/* unsigned long flags; */
 
 	dma_cs_addr = (unsigned long)devpriv->lcfg
 		+ ((channel == 0) ? LCFG_DMACSR0 : LCFG_DMACSR1);
 
-	// spinlock for plx dma control/status reg
-	//comedi_spin_lock_irqsave( &dev->spinlock, flags );
+	/*  spinlock for plx dma control/status reg */
+	/* comedi_spin_lock_irqsave( &dev->spinlock, flags ); */
 
-	// abort dma transfer if necessary
+	/*  abort dma transfer if necessary */
 	status = readb(dma_cs_addr);
 	if ((status & PLX_DMA_EN_BIT) == 0) {	/* not enabled (Error?) */
 		DPRINTK("rtd520: AbortDma on non-active channel %d (0x%x)\n",
@@ -1410,7 +1410,7 @@ void abort_dma(comedi_device * dev, unsi
 	/* set abort bit for channel */
 	writeb(PLX_DMA_ABORT_BIT, dma_cs_addr);
 
-	// wait for dma done bit to be set
+	/*  wait for dma done bit to be set */
 	status = readb(dma_cs_addr);
 	for (ii = 0;
 		(status & PLX_DMA_DONE_BIT) == 0 && ii < RTD_DMA_TIMEOUT;
@@ -1424,7 +1424,7 @@ void abort_dma(comedi_device * dev, unsi
 	}
 
       abortDmaExit:
-	//comedi_spin_unlock_irqrestore( &dev->spinlock, flags );
+	/* comedi_spin_unlock_irqrestore( &dev->spinlock, flags ); */
 }
 
 /*
--- a/drivers/staging/comedi/drivers/rtd520.h
+++ b/drivers/staging/comedi/drivers/rtd520.h
@@ -29,366 +29,366 @@
   LAS0 Runtime Area
   Local Address Space 0 Offset		Read Function	Write Function
 */
-#define LAS0_SPARE_00    0x0000	// -                               -
-#define LAS0_SPARE_04    0x0004	// -                               -
-#define LAS0_USER_IO     0x0008	// Read User Inputs                Write User Outputs
-#define LAS0_SPARE_0C    0x000C	// -                               -
-#define LAS0_ADC         0x0010	// Read FIFO Status                Software A/D Start
-#define LAS0_DAC1        0x0014	// -                               Software D/A1 Update
-#define LAS0_DAC2        0x0018	// -                               Software D/A2 Update
-#define LAS0_SPARE_1C    0x001C	// -                               -
-#define LAS0_SPARE_20    0x0020	// -                               -
-#define LAS0_DAC         0x0024	// -                               Software Simultaneous D/A1 and D/A2 Update
-#define LAS0_PACER       0x0028	// Software Pacer Start            Software Pacer Stop
-#define LAS0_TIMER       0x002C	// Read Timer Counters Status      HDIN Software Trigger
-#define LAS0_IT          0x0030	// Read Interrupt Status           Write Interrupt Enable Mask Register
-#define LAS0_CLEAR       0x0034	// Clear ITs set by Clear Mask     Set Interrupt Clear Mask
-#define LAS0_OVERRUN     0x0038	// Read pending interrupts         Clear Overrun Register
-#define LAS0_SPARE_3C    0x003C	// -                               -
+#define LAS0_SPARE_00    0x0000	/*  -                               - */
+#define LAS0_SPARE_04    0x0004	/*  -                               - */
+#define LAS0_USER_IO     0x0008	/*  Read User Inputs                Write User Outputs */
+#define LAS0_SPARE_0C    0x000C	/*  -                               - */
+#define LAS0_ADC         0x0010	/*  Read FIFO Status                Software A/D Start */
+#define LAS0_DAC1        0x0014	/*  -                               Software D/A1 Update */
+#define LAS0_DAC2        0x0018	/*  -                               Software D/A2 Update */
+#define LAS0_SPARE_1C    0x001C	/*  -                               - */
+#define LAS0_SPARE_20    0x0020	/*  -                               - */
+#define LAS0_DAC         0x0024	/*  -                               Software Simultaneous D/A1 and D/A2 Update */
+#define LAS0_PACER       0x0028	/*  Software Pacer Start            Software Pacer Stop */
+#define LAS0_TIMER       0x002C	/*  Read Timer Counters Status      HDIN Software Trigger */
+#define LAS0_IT          0x0030	/*  Read Interrupt Status           Write Interrupt Enable Mask Register */
+#define LAS0_CLEAR       0x0034	/*  Clear ITs set by Clear Mask     Set Interrupt Clear Mask */
+#define LAS0_OVERRUN     0x0038	/*  Read pending interrupts         Clear Overrun Register */
+#define LAS0_SPARE_3C    0x003C	/*  -                               - */
 
 /*
   LAS0 Runtime Area Timer/Counter,Dig.IO
   Name			Local Address			Function
 */
-#define LAS0_PCLK        0x0040	// Pacer Clock value (24bit)             Pacer Clock load (24bit)
-#define LAS0_BCLK        0x0044	// Burst Clock value (10bit)             Burst Clock load (10bit)
-#define LAS0_ADC_SCNT    0x0048	// A/D Sample counter value (10bit)      A/D Sample counter load (10bit)
-#define LAS0_DAC1_UCNT   0x004C	// D/A1 Update counter value (10 bit)    D/A1 Update counter load (10bit)
-#define LAS0_DAC2_UCNT   0x0050	// D/A2 Update counter value (10 bit)    D/A2 Update counter load (10bit)
-#define LAS0_DCNT        0x0054	// Delay counter value (16 bit)          Delay counter load (16bit)
-#define LAS0_ACNT        0x0058	// About counter value (16 bit)          About counter load (16bit)
-#define LAS0_DAC_CLK     0x005C	// DAC clock value (16bit)               DAC clock load (16bit)
-#define LAS0_UTC0        0x0060	// 8254 TC Counter 0 User TC 0 value     Load count in TC Counter 0
-#define LAS0_UTC1        0x0064	// 8254 TC Counter 1 User TC 1 value     Load count in TC Counter 1
-#define LAS0_UTC2        0x0068	// 8254 TC Counter 2 User TC 2 value     Load count in TC Counter 2
-#define LAS0_UTC_CTRL    0x006C	// 8254 TC Control Word                  Program counter mode for TC
-#define LAS0_DIO0        0x0070	// Digital I/O Port 0 Read Port          Digital I/O Port 0 Write Port
-#define LAS0_DIO1        0x0074	// Digital I/O Port 1 Read Port          Digital I/O Port 1 Write Port
-#define LAS0_DIO0_CTRL   0x0078	// Clear digital IRQ status flag/read    Clear digital chip/program Port 0
-#define LAS0_DIO_STATUS  0x007C	// Read Digital I/O Status word          Program digital control register &
+#define LAS0_PCLK        0x0040	/*  Pacer Clock value (24bit)             Pacer Clock load (24bit) */
+#define LAS0_BCLK        0x0044	/*  Burst Clock value (10bit)             Burst Clock load (10bit) */
+#define LAS0_ADC_SCNT    0x0048	/*  A/D Sample counter value (10bit)      A/D Sample counter load (10bit) */
+#define LAS0_DAC1_UCNT   0x004C	/*  D/A1 Update counter value (10 bit)    D/A1 Update counter load (10bit) */
+#define LAS0_DAC2_UCNT   0x0050	/*  D/A2 Update counter value (10 bit)    D/A2 Update counter load (10bit) */
+#define LAS0_DCNT        0x0054	/*  Delay counter value (16 bit)          Delay counter load (16bit) */
+#define LAS0_ACNT        0x0058	/*  About counter value (16 bit)          About counter load (16bit) */
+#define LAS0_DAC_CLK     0x005C	/*  DAC clock value (16bit)               DAC clock load (16bit) */
+#define LAS0_UTC0        0x0060	/*  8254 TC Counter 0 User TC 0 value     Load count in TC Counter 0 */
+#define LAS0_UTC1        0x0064	/*  8254 TC Counter 1 User TC 1 value     Load count in TC Counter 1 */
+#define LAS0_UTC2        0x0068	/*  8254 TC Counter 2 User TC 2 value     Load count in TC Counter 2 */
+#define LAS0_UTC_CTRL    0x006C	/*  8254 TC Control Word                  Program counter mode for TC */
+#define LAS0_DIO0        0x0070	/*  Digital I/O Port 0 Read Port          Digital I/O Port 0 Write Port */
+#define LAS0_DIO1        0x0074	/*  Digital I/O Port 1 Read Port          Digital I/O Port 1 Write Port */
+#define LAS0_DIO0_CTRL   0x0078	/*  Clear digital IRQ status flag/read    Clear digital chip/program Port 0 */
+#define LAS0_DIO_STATUS  0x007C	/*  Read Digital I/O Status word          Program digital control register & */
 
 /*
   LAS0 Setup Area
   Name			Local Address			Function
 */
-#define LAS0_BOARD_RESET        0x0100	// Board reset
-#define LAS0_DMA0_SRC           0x0104	// DMA 0 Sources select
-#define LAS0_DMA1_SRC           0x0108	// DMA 1 Sources select
-#define LAS0_ADC_CONVERSION     0x010C	// A/D Conversion Signal select
-#define LAS0_BURST_START        0x0110	// Burst Clock Start Trigger select
-#define LAS0_PACER_START        0x0114	// Pacer Clock Start Trigger select
-#define LAS0_PACER_STOP         0x0118	// Pacer Clock Stop Trigger select
-#define LAS0_ACNT_STOP_ENABLE   0x011C	// About Counter Stop Enable
-#define LAS0_PACER_REPEAT       0x0120	// Pacer Start Trigger Mode select
-#define LAS0_DIN_START          0x0124	// High Speed Digital Input Sampling Signal select
-#define LAS0_DIN_FIFO_CLEAR     0x0128	// Digital Input FIFO Clear
-#define LAS0_ADC_FIFO_CLEAR     0x012C	// A/D FIFO Clear
-#define LAS0_CGT_WRITE          0x0130	// Channel Gain Table Write
-#define LAS0_CGL_WRITE          0x0134	// Channel Gain Latch Write
-#define LAS0_CG_DATA            0x0138	// Digital Table Write
-#define LAS0_CGT_ENABLE		0x013C	// Channel Gain Table Enable
-#define LAS0_CG_ENABLE          0x0140	// Digital Table Enable
-#define LAS0_CGT_PAUSE          0x0144	// Table Pause Enable
-#define LAS0_CGT_RESET          0x0148	// Reset Channel Gain Table
-#define LAS0_CGT_CLEAR          0x014C	// Clear Channel Gain Table
-#define LAS0_DAC1_CTRL          0x0150	// D/A1 output type/range
-#define LAS0_DAC1_SRC           0x0154	// D/A1 update source
-#define LAS0_DAC1_CYCLE         0x0158	// D/A1 cycle mode
-#define LAS0_DAC1_RESET         0x015C	// D/A1 FIFO reset
-#define LAS0_DAC1_FIFO_CLEAR    0x0160	// D/A1 FIFO clear
-#define LAS0_DAC2_CTRL          0x0164	// D/A2 output type/range
-#define LAS0_DAC2_SRC           0x0168	// D/A2 update source
-#define LAS0_DAC2_CYCLE         0x016C	// D/A2 cycle mode
-#define LAS0_DAC2_RESET         0x0170	// D/A2 FIFO reset
-#define LAS0_DAC2_FIFO_CLEAR    0x0174	// D/A2 FIFO clear
-#define LAS0_ADC_SCNT_SRC       0x0178	// A/D Sample Counter Source select
-#define LAS0_PACER_SELECT       0x0180	// Pacer Clock select
-#define LAS0_SBUS0_SRC          0x0184	// SyncBus 0 Source select
-#define LAS0_SBUS0_ENABLE       0x0188	// SyncBus 0 enable
-#define LAS0_SBUS1_SRC          0x018C	// SyncBus 1 Source select
-#define LAS0_SBUS1_ENABLE       0x0190	// SyncBus 1 enable
-#define LAS0_SBUS2_SRC          0x0198	// SyncBus 2 Source select
-#define LAS0_SBUS2_ENABLE       0x019C	// SyncBus 2 enable
-#define LAS0_ETRG_POLARITY      0x01A4	// External Trigger polarity select
-#define LAS0_EINT_POLARITY      0x01A8	// External Interrupt polarity select
-#define LAS0_UTC0_CLOCK         0x01AC	// UTC0 Clock select
-#define LAS0_UTC0_GATE          0x01B0	// UTC0 Gate select
-#define LAS0_UTC1_CLOCK         0x01B4	// UTC1 Clock select
-#define LAS0_UTC1_GATE          0x01B8	// UTC1 Gate select
-#define LAS0_UTC2_CLOCK         0x01BC	// UTC2 Clock select
-#define LAS0_UTC2_GATE          0x01C0	// UTC2 Gate select
-#define LAS0_UOUT0_SELECT       0x01C4	// User Output 0 source select
-#define LAS0_UOUT1_SELECT       0x01C8	// User Output 1 source select
-#define LAS0_DMA0_RESET         0x01CC	// DMA0 Request state machine reset
-#define LAS0_DMA1_RESET         0x01D0	// DMA1 Request state machine reset
+#define LAS0_BOARD_RESET        0x0100	/*  Board reset */
+#define LAS0_DMA0_SRC           0x0104	/*  DMA 0 Sources select */
+#define LAS0_DMA1_SRC           0x0108	/*  DMA 1 Sources select */
+#define LAS0_ADC_CONVERSION     0x010C	/*  A/D Conversion Signal select */
+#define LAS0_BURST_START        0x0110	/*  Burst Clock Start Trigger select */
+#define LAS0_PACER_START        0x0114	/*  Pacer Clock Start Trigger select */
+#define LAS0_PACER_STOP         0x0118	/*  Pacer Clock Stop Trigger select */
+#define LAS0_ACNT_STOP_ENABLE   0x011C	/*  About Counter Stop Enable */
+#define LAS0_PACER_REPEAT       0x0120	/*  Pacer Start Trigger Mode select */
+#define LAS0_DIN_START          0x0124	/*  High Speed Digital Input Sampling Signal select */
+#define LAS0_DIN_FIFO_CLEAR     0x0128	/*  Digital Input FIFO Clear */
+#define LAS0_ADC_FIFO_CLEAR     0x012C	/*  A/D FIFO Clear */
+#define LAS0_CGT_WRITE          0x0130	/*  Channel Gain Table Write */
+#define LAS0_CGL_WRITE          0x0134	/*  Channel Gain Latch Write */
+#define LAS0_CG_DATA            0x0138	/*  Digital Table Write */
+#define LAS0_CGT_ENABLE		0x013C	/*  Channel Gain Table Enable */
+#define LAS0_CG_ENABLE          0x0140	/*  Digital Table Enable */
+#define LAS0_CGT_PAUSE          0x0144	/*  Table Pause Enable */
+#define LAS0_CGT_RESET          0x0148	/*  Reset Channel Gain Table */
+#define LAS0_CGT_CLEAR          0x014C	/*  Clear Channel Gain Table */
+#define LAS0_DAC1_CTRL          0x0150	/*  D/A1 output type/range */
+#define LAS0_DAC1_SRC           0x0154	/*  D/A1 update source */
+#define LAS0_DAC1_CYCLE         0x0158	/*  D/A1 cycle mode */
+#define LAS0_DAC1_RESET         0x015C	/*  D/A1 FIFO reset */
+#define LAS0_DAC1_FIFO_CLEAR    0x0160	/*  D/A1 FIFO clear */
+#define LAS0_DAC2_CTRL          0x0164	/*  D/A2 output type/range */
+#define LAS0_DAC2_SRC           0x0168	/*  D/A2 update source */
+#define LAS0_DAC2_CYCLE         0x016C	/*  D/A2 cycle mode */
+#define LAS0_DAC2_RESET         0x0170	/*  D/A2 FIFO reset */
+#define LAS0_DAC2_FIFO_CLEAR    0x0174	/*  D/A2 FIFO clear */
+#define LAS0_ADC_SCNT_SRC       0x0178	/*  A/D Sample Counter Source select */
+#define LAS0_PACER_SELECT       0x0180	/*  Pacer Clock select */
+#define LAS0_SBUS0_SRC          0x0184	/*  SyncBus 0 Source select */
+#define LAS0_SBUS0_ENABLE       0x0188	/*  SyncBus 0 enable */
+#define LAS0_SBUS1_SRC          0x018C	/*  SyncBus 1 Source select */
+#define LAS0_SBUS1_ENABLE       0x0190	/*  SyncBus 1 enable */
+#define LAS0_SBUS2_SRC          0x0198	/*  SyncBus 2 Source select */
+#define LAS0_SBUS2_ENABLE       0x019C	/*  SyncBus 2 enable */
+#define LAS0_ETRG_POLARITY      0x01A4	/*  External Trigger polarity select */
+#define LAS0_EINT_POLARITY      0x01A8	/*  External Interrupt polarity select */
+#define LAS0_UTC0_CLOCK         0x01AC	/*  UTC0 Clock select */
+#define LAS0_UTC0_GATE          0x01B0	/*  UTC0 Gate select */
+#define LAS0_UTC1_CLOCK         0x01B4	/*  UTC1 Clock select */
+#define LAS0_UTC1_GATE          0x01B8	/*  UTC1 Gate select */
+#define LAS0_UTC2_CLOCK         0x01BC	/*  UTC2 Clock select */
+#define LAS0_UTC2_GATE          0x01C0	/*  UTC2 Gate select */
+#define LAS0_UOUT0_SELECT       0x01C4	/*  User Output 0 source select */
+#define LAS0_UOUT1_SELECT       0x01C8	/*  User Output 1 source select */
+#define LAS0_DMA0_RESET         0x01CC	/*  DMA0 Request state machine reset */
+#define LAS0_DMA1_RESET         0x01D0	/*  DMA1 Request state machine reset */
 
 /*
   LAS1
   Name			Local Address			Function
 */
-#define LAS1_ADC_FIFO            0x0000	// Read A/D FIFO (16bit) -
-#define LAS1_HDIO_FIFO           0x0004	// Read High Speed Digital Input FIFO (16bit) -
-#define LAS1_DAC1_FIFO           0x0008	// - Write D/A1 FIFO (16bit)
-#define LAS1_DAC2_FIFO           0x000C	// - Write D/A2 FIFO (16bit)
+#define LAS1_ADC_FIFO            0x0000	/*  Read A/D FIFO (16bit) - */
+#define LAS1_HDIO_FIFO           0x0004	/*  Read High Speed Digital Input FIFO (16bit) - */
+#define LAS1_DAC1_FIFO           0x0008	/*  - Write D/A1 FIFO (16bit) */
+#define LAS1_DAC2_FIFO           0x000C	/*  - Write D/A2 FIFO (16bit) */
 
 /*
   LCFG: PLX 9080 local config & runtime registers
   Name			Local Address			Function
 */
-#define LCFG_ITCSR              0x0068	// INTCSR, Interrupt Control/Status Register
-#define LCFG_DMAMODE0           0x0080	// DMA Channel 0 Mode Register
-#define LCFG_DMAPADR0           0x0084	// DMA Channel 0 PCI Address Register
-#define LCFG_DMALADR0           0x0088	// DMA Channel 0 Local Address Reg
-#define LCFG_DMASIZ0            0x008C	// DMA Channel 0 Transfer Size (Bytes) Register
-#define LCFG_DMADPR0            0x0090	// DMA Channel 0 Descriptor Pointer Register
-#define LCFG_DMAMODE1           0x0094	// DMA Channel 1 Mode Register
-#define LCFG_DMAPADR1           0x0098	// DMA Channel 1 PCI Address Register
-#define LCFG_DMALADR1           0x009C	// DMA Channel 1 Local Address Register
-#define LCFG_DMASIZ1            0x00A0	// DMA Channel 1 Transfer Size (Bytes) Register
-#define LCFG_DMADPR1            0x00A4	// DMA Channel 1 Descriptor Pointer Register
-#define LCFG_DMACSR0            0x00A8	// DMA Channel 0 Command/Status Register
-#define LCFG_DMACSR1            0x00A9	// DMA Channel 0 Command/Status Register
-#define LCFG_DMAARB             0x00AC	// DMA Arbitration Register
-#define LCFG_DMATHR             0x00B0	// DMA Threshold Register
+#define LCFG_ITCSR              0x0068	/*  INTCSR, Interrupt Control/Status Register */
+#define LCFG_DMAMODE0           0x0080	/*  DMA Channel 0 Mode Register */
+#define LCFG_DMAPADR0           0x0084	/*  DMA Channel 0 PCI Address Register */
+#define LCFG_DMALADR0           0x0088	/*  DMA Channel 0 Local Address Reg */
+#define LCFG_DMASIZ0            0x008C	/*  DMA Channel 0 Transfer Size (Bytes) Register */
+#define LCFG_DMADPR0            0x0090	/*  DMA Channel 0 Descriptor Pointer Register */
+#define LCFG_DMAMODE1           0x0094	/*  DMA Channel 1 Mode Register */
+#define LCFG_DMAPADR1           0x0098	/*  DMA Channel 1 PCI Address Register */
+#define LCFG_DMALADR1           0x009C	/*  DMA Channel 1 Local Address Register */
+#define LCFG_DMASIZ1            0x00A0	/*  DMA Channel 1 Transfer Size (Bytes) Register */
+#define LCFG_DMADPR1            0x00A4	/*  DMA Channel 1 Descriptor Pointer Register */
+#define LCFG_DMACSR0            0x00A8	/*  DMA Channel 0 Command/Status Register */
+#define LCFG_DMACSR1            0x00A9	/*  DMA Channel 0 Command/Status Register */
+#define LCFG_DMAARB             0x00AC	/*  DMA Arbitration Register */
+#define LCFG_DMATHR             0x00B0	/*  DMA Threshold Register */
 
 /*======================================================================
   Resister bit definitions
 ======================================================================*/
 
-// FIFO Status Word Bits (RtdFifoStatus)
-#define FS_DAC1_NOT_EMPTY    0x0001	// D0  - DAC1 FIFO not empty
-#define FS_DAC1_HEMPTY   0x0002	// D1  - DAC1 FIFO half empty
-#define FS_DAC1_NOT_FULL     0x0004	// D2  - DAC1 FIFO not full
-#define FS_DAC2_NOT_EMPTY    0x0010	// D4  - DAC2 FIFO not empty
-#define FS_DAC2_HEMPTY   0x0020	// D5  - DAC2 FIFO half empty
-#define FS_DAC2_NOT_FULL     0x0040	// D6  - DAC2 FIFO not full
-#define FS_ADC_NOT_EMPTY     0x0100	// D8  - ADC FIFO not empty
-#define FS_ADC_HEMPTY    0x0200	// D9  - ADC FIFO half empty
-#define FS_ADC_NOT_FULL      0x0400	// D10 - ADC FIFO not full
-#define FS_DIN_NOT_EMPTY     0x1000	// D12 - DIN FIFO not empty
-#define FS_DIN_HEMPTY    0x2000	// D13 - DIN FIFO half empty
-#define FS_DIN_NOT_FULL      0x4000	// D14 - DIN FIFO not full
+/*  FIFO Status Word Bits (RtdFifoStatus) */
+#define FS_DAC1_NOT_EMPTY    0x0001	/*  D0  - DAC1 FIFO not empty */
+#define FS_DAC1_HEMPTY   0x0002	/*  D1  - DAC1 FIFO half empty */
+#define FS_DAC1_NOT_FULL     0x0004	/*  D2  - DAC1 FIFO not full */
+#define FS_DAC2_NOT_EMPTY    0x0010	/*  D4  - DAC2 FIFO not empty */
+#define FS_DAC2_HEMPTY   0x0020	/*  D5  - DAC2 FIFO half empty */
+#define FS_DAC2_NOT_FULL     0x0040	/*  D6  - DAC2 FIFO not full */
+#define FS_ADC_NOT_EMPTY     0x0100	/*  D8  - ADC FIFO not empty */
+#define FS_ADC_HEMPTY    0x0200	/*  D9  - ADC FIFO half empty */
+#define FS_ADC_NOT_FULL      0x0400	/*  D10 - ADC FIFO not full */
+#define FS_DIN_NOT_EMPTY     0x1000	/*  D12 - DIN FIFO not empty */
+#define FS_DIN_HEMPTY    0x2000	/*  D13 - DIN FIFO half empty */
+#define FS_DIN_NOT_FULL      0x4000	/*  D14 - DIN FIFO not full */
 
-// Timer Status Word Bits (GetTimerStatus)
+/*  Timer Status Word Bits (GetTimerStatus) */
 #define TS_PCLK_GATE   0x0001
-// D0 - Pacer Clock Gate [0 - gated, 1 - enabled]
+/*  D0 - Pacer Clock Gate [0 - gated, 1 - enabled] */
 #define TS_BCLK_GATE   0x0002
-// D1 - Burst Clock Gate [0 - disabled, 1 - running]
+/*  D1 - Burst Clock Gate [0 - disabled, 1 - running] */
 #define TS_DCNT_GATE   0x0004
-// D2 - Pacer Clock Delayed Start Trigger [0 - delay over, 1 - delay in
-// progress]
+/*  D2 - Pacer Clock Delayed Start Trigger [0 - delay over, 1 - delay in */
+/*  progress] */
 #define TS_ACNT_GATE   0x0008
-// D3 - Pacer Clock About Trigger [0 - completed, 1 - in progress]
+/*  D3 - Pacer Clock About Trigger [0 - completed, 1 - in progress] */
 #define TS_PCLK_RUN    0x0010
-// D4 - Pacer Clock Shutdown Flag [0 - Pacer Clock cannot be start
-// triggered only by Software Pacer Start Command, 1 - Pacer Clock can
-// be start triggered]
-
-// External Trigger polarity select
-// External Interrupt polarity select
-#define POL_POSITIVE         0x0	// positive edge
-#define POL_NEGATIVE         0x1	// negative edge
-
-// User Output Signal select (SetUout0Source, SetUout1Source)
-#define UOUT_ADC                0x0	// A/D Conversion Signal
-#define UOUT_DAC1               0x1	// D/A1 Update
-#define UOUT_DAC2               0x2	// D/A2 Update
-#define UOUT_SOFTWARE           0x3	// Software Programmable
-
-// Pacer clock select (SetPacerSource)
-#define PCLK_INTERNAL           1	// Internal Pacer Clock
-#define PCLK_EXTERNAL           0	// External Pacer Clock
+/*  D4 - Pacer Clock Shutdown Flag [0 - Pacer Clock cannot be start */
+/*  triggered only by Software Pacer Start Command, 1 - Pacer Clock can */
+/*  be start triggered] */
+
+/*  External Trigger polarity select */
+/*  External Interrupt polarity select */
+#define POL_POSITIVE         0x0	/*  positive edge */
+#define POL_NEGATIVE         0x1	/*  negative edge */
+
+/*  User Output Signal select (SetUout0Source, SetUout1Source) */
+#define UOUT_ADC                0x0	/*  A/D Conversion Signal */
+#define UOUT_DAC1               0x1	/*  D/A1 Update */
+#define UOUT_DAC2               0x2	/*  D/A2 Update */
+#define UOUT_SOFTWARE           0x3	/*  Software Programmable */
+
+/*  Pacer clock select (SetPacerSource) */
+#define PCLK_INTERNAL           1	/*  Internal Pacer Clock */
+#define PCLK_EXTERNAL           0	/*  External Pacer Clock */
 
-// A/D Sample Counter Sources (SetAdcntSource, SetupSampleCounter)
-#define ADC_SCNT_CGT_RESET         0x0	// needs restart with StartPacer
+/*  A/D Sample Counter Sources (SetAdcntSource, SetupSampleCounter) */
+#define ADC_SCNT_CGT_RESET         0x0	/*  needs restart with StartPacer */
 #define ADC_SCNT_FIFO_WRITE        0x1
 
-// A/D Conversion Signal Select (for SetConversionSelect)
-#define ADC_START_SOFTWARE         0x0	// Software A/D Start
-#define ADC_START_PCLK             0x1	// Pacer Clock (Ext. Int. see Func.509)
-#define ADC_START_BCLK             0x2	// Burst Clock
-#define ADC_START_DIGITAL_IT       0x3	// Digital Interrupt
-#define ADC_START_DAC1_MARKER1     0x4	// D/A 1 Data Marker 1
-#define ADC_START_DAC2_MARKER1     0x5	// D/A 2 Data Marker 1
-#define ADC_START_SBUS0            0x6	// SyncBus 0
-#define ADC_START_SBUS1            0x7	// SyncBus 1
-#define ADC_START_SBUS2            0x8	// SyncBus 2
-
-// Burst Clock start trigger select (SetBurstStart)
-#define BCLK_START_SOFTWARE        0x0	// Software A/D Start (StartBurst)
-#define BCLK_START_PCLK            0x1	// Pacer Clock
-#define BCLK_START_ETRIG           0x2	// External Trigger
-#define BCLK_START_DIGITAL_IT      0x3	// Digital Interrupt
-#define BCLK_START_SBUS0           0x4	// SyncBus 0
-#define BCLK_START_SBUS1           0x5	// SyncBus 1
-#define BCLK_START_SBUS2           0x6	// SyncBus 2
-
-// Pacer Clock start trigger select (SetPacerStart)
-#define PCLK_START_SOFTWARE        0x0	// Software Pacer Start (StartPacer)
-#define PCLK_START_ETRIG           0x1	// External trigger
-#define PCLK_START_DIGITAL_IT      0x2	// Digital interrupt
-#define PCLK_START_UTC2            0x3	// User TC 2 out
-#define PCLK_START_SBUS0           0x4	// SyncBus 0
-#define PCLK_START_SBUS1           0x5	// SyncBus 1
-#define PCLK_START_SBUS2           0x6	// SyncBus 2
-#define PCLK_START_D_SOFTWARE      0x8	// Delayed Software Pacer Start
-#define PCLK_START_D_ETRIG         0x9	// Delayed external trigger
-#define PCLK_START_D_DIGITAL_IT    0xA	// Delayed digital interrupt
-#define PCLK_START_D_UTC2          0xB	// Delayed User TC 2 out
-#define PCLK_START_D_SBUS0         0xC	// Delayed SyncBus 0
-#define PCLK_START_D_SBUS1         0xD	// Delayed SyncBus 1
-#define PCLK_START_D_SBUS2         0xE	// Delayed SyncBus 2
-#define PCLK_START_ETRIG_GATED     0xF	// External Trigger Gated controlled mode
-
-// Pacer Clock Stop Trigger select (SetPacerStop)
-#define PCLK_STOP_SOFTWARE         0x0	// Software Pacer Stop (StopPacer)
-#define PCLK_STOP_ETRIG            0x1	// External Trigger
-#define PCLK_STOP_DIGITAL_IT       0x2	// Digital Interrupt
-#define PCLK_STOP_ACNT             0x3	// About Counter
-#define PCLK_STOP_UTC2             0x4	// User TC2 out
-#define PCLK_STOP_SBUS0            0x5	// SyncBus 0
-#define PCLK_STOP_SBUS1            0x6	// SyncBus 1
-#define PCLK_STOP_SBUS2            0x7	// SyncBus 2
-#define PCLK_STOP_A_SOFTWARE       0x8	// About Software Pacer Stop
-#define PCLK_STOP_A_ETRIG          0x9	// About External Trigger
-#define PCLK_STOP_A_DIGITAL_IT     0xA	// About Digital Interrupt
-#define PCLK_STOP_A_UTC2           0xC	// About User TC2 out
-#define PCLK_STOP_A_SBUS0          0xD	// About SyncBus 0
-#define PCLK_STOP_A_SBUS1          0xE	// About SyncBus 1
-#define PCLK_STOP_A_SBUS2          0xF	// About SyncBus 2
-
-// About Counter Stop Enable
-#define ACNT_STOP                  0x0	// stop enable
-#define ACNT_NO_STOP               0x1	// stop disabled
-
-// DAC update source (SetDAC1Start & SetDAC2Start)
-#define DAC_START_SOFTWARE         0x0	// Software Update
-#define DAC_START_CGT              0x1	// CGT controlled Update
-#define DAC_START_DAC_CLK          0x2	// D/A Clock
-#define DAC_START_EPCLK            0x3	// External Pacer Clock
-#define DAC_START_SBUS0            0x4	// SyncBus 0
-#define DAC_START_SBUS1            0x5	// SyncBus 1
-#define DAC_START_SBUS2            0x6	// SyncBus 2
-
-// DAC Cycle Mode (SetDAC1Cycle, SetDAC2Cycle, SetupDAC)
-#define DAC_CYCLE_SINGLE           0x0	// not cycle
-#define DAC_CYCLE_MULTI            0x1	// cycle
-
-// 8254 Operation Modes (Set8254Mode, SetupTimerCounter)
-#define M8254_EVENT_COUNTER        0	// Event Counter
-#define M8254_HW_ONE_SHOT          1	// Hardware-Retriggerable One-Shot
-#define M8254_RATE_GENERATOR       2	// Rate Generator
-#define M8254_SQUARE_WAVE          3	// Square Wave Mode
-#define M8254_SW_STROBE            4	// Software Triggered Strobe
-#define M8254_HW_STROBE            5	// Hardware Triggered Strobe (Retriggerable)
-
-// User Timer/Counter 0 Clock Select (SetUtc0Clock)
-#define CUTC0_8MHZ                 0x0	// 8MHz
-#define CUTC0_EXT_TC_CLOCK1        0x1	// Ext. TC Clock 1
-#define CUTC0_EXT_TC_CLOCK2        0x2	// Ext. TC Clock 2
-#define CUTC0_EXT_PCLK             0x3	// Ext. Pacer Clock
-
-// User Timer/Counter 1 Clock Select (SetUtc1Clock)
-#define CUTC1_8MHZ                 0x0	// 8MHz
-#define CUTC1_EXT_TC_CLOCK1        0x1	// Ext. TC Clock 1
-#define CUTC1_EXT_TC_CLOCK2        0x2	// Ext. TC Clock 2
-#define CUTC1_EXT_PCLK             0x3	// Ext. Pacer Clock
-#define CUTC1_UTC0_OUT             0x4	// User Timer/Counter 0 out
-#define CUTC1_DIN_SIGNAL           0x5	// High-Speed Digital Input   Sampling signal
-
-// User Timer/Counter 2 Clock Select (SetUtc2Clock)
-#define CUTC2_8MHZ                 0x0	// 8MHz
-#define CUTC2_EXT_TC_CLOCK1        0x1	// Ext. TC Clock 1
-#define CUTC2_EXT_TC_CLOCK2        0x2	// Ext. TC Clock 2
-#define CUTC2_EXT_PCLK             0x3	// Ext. Pacer Clock
-#define CUTC2_UTC1_OUT             0x4	// User Timer/Counter 1 out
-
-// User Timer/Counter 0 Gate Select (SetUtc0Gate)
-#define GUTC0_NOT_GATED            0x0	// Not gated
-#define GUTC0_GATED                0x1	// Gated
-#define GUTC0_EXT_TC_GATE1         0x2	// Ext. TC Gate 1
-#define GUTC0_EXT_TC_GATE2         0x3	// Ext. TC Gate 2
-
-// User Timer/Counter 1 Gate Select (SetUtc1Gate)
-#define GUTC1_NOT_GATED            0x0	// Not gated
-#define GUTC1_GATED                0x1	// Gated
-#define GUTC1_EXT_TC_GATE1         0x2	// Ext. TC Gate 1
-#define GUTC1_EXT_TC_GATE2         0x3	// Ext. TC Gate 2
-#define GUTC1_UTC0_OUT             0x4	// User Timer/Counter 0 out
-
-// User Timer/Counter 2 Gate Select (SetUtc2Gate)
-#define GUTC2_NOT_GATED            0x0	// Not gated
-#define GUTC2_GATED                0x1	// Gated
-#define GUTC2_EXT_TC_GATE1         0x2	// Ext. TC Gate 1
-#define GUTC2_EXT_TC_GATE2         0x3	// Ext. TC Gate 2
-#define GUTC2_UTC1_OUT             0x4	// User Timer/Counter 1 out
-
-// Interrupt Source Masks (SetITMask, ClearITMask, GetITStatus)
-#define IRQM_ADC_FIFO_WRITE        0x0001	// ADC FIFO Write
-#define IRQM_CGT_RESET             0x0002	// Reset CGT
-#define IRQM_CGT_PAUSE             0x0008	// Pause CGT
-#define IRQM_ADC_ABOUT_CNT         0x0010	// About Counter out
-#define IRQM_ADC_DELAY_CNT         0x0020	// Delay Counter out
-#define IRQM_ADC_SAMPLE_CNT	   0x0040	// ADC Sample Counter
-#define IRQM_DAC1_UCNT             0x0080	// DAC1 Update Counter
-#define IRQM_DAC2_UCNT             0x0100	// DAC2 Update Counter
-#define IRQM_UTC1                  0x0200	// User TC1 out
-#define IRQM_UTC1_INV              0x0400	// User TC1 out, inverted
-#define IRQM_UTC2                  0x0800	// User TC2 out
-#define IRQM_DIGITAL_IT            0x1000	// Digital Interrupt
-#define IRQM_EXTERNAL_IT           0x2000	// External Interrupt
-#define IRQM_ETRIG_RISING          0x4000	// External Trigger rising-edge
-#define IRQM_ETRIG_FALLING         0x8000	// External Trigger falling-edge
-
-// DMA Request Sources (LAS0)
-#define DMAS_DISABLED              0x0	// DMA Disabled
-#define DMAS_ADC_SCNT              0x1	// ADC Sample Counter
-#define DMAS_DAC1_UCNT             0x2	// D/A1 Update Counter
-#define DMAS_DAC2_UCNT             0x3	// D/A2 Update Counter
-#define DMAS_UTC1                  0x4	// User TC1 out
-#define DMAS_ADFIFO_HALF_FULL      0x8	// A/D FIFO half full
-#define DMAS_DAC1_FIFO_HALF_EMPTY  0x9	// D/A1 FIFO half empty
-#define DMAS_DAC2_FIFO_HALF_EMPTY  0xA	// D/A2 FIFO half empty
-
-// DMA Local Addresses   (0x40000000+LAS1 offset)
-#define DMALADDR_ADC       0x40000000	// A/D FIFO
-#define DMALADDR_HDIN      0x40000004	// High Speed Digital Input FIFO
-#define DMALADDR_DAC1      0x40000008	// D/A1 FIFO
-#define DMALADDR_DAC2      0x4000000C	// D/A2 FIFO
-
-// Port 0 compare modes (SetDIO0CompareMode)
-#define DIO_MODE_EVENT     0	// Event Mode
-#define DIO_MODE_MATCH     1	// Match Mode
-
-// Digital Table Enable (Port 1 disable)
-#define DTBL_DISABLE       0	// Enable Digital Table
-#define DTBL_ENABLE        1	// Disable Digital Table
-
-// Sampling Signal for High Speed Digital Input (SetHdinStart)
-#define HDIN_SOFTWARE      0x0	// Software Trigger
-#define HDIN_ADC           0x1	// A/D Conversion Signal
-#define HDIN_UTC0          0x2	// User TC out 0
-#define HDIN_UTC1          0x3	// User TC out 1
-#define HDIN_UTC2          0x4	// User TC out 2
-#define HDIN_EPCLK         0x5	// External Pacer Clock
-#define HDIN_ETRG          0x6	// External Trigger
-
-// Channel Gain Table / Channel Gain Latch
-#define CSC_LATCH          0	// Channel Gain Latch mode
-#define CSC_CGT            1	// Channel Gain Table mode
-
-// Channel Gain Table Pause Enable
-#define CGT_PAUSE_DISABLE  0	// Channel Gain Table Pause Disable
-#define CGT_PAUSE_ENABLE   1	// Channel Gain Table Pause Enable
-
-// DAC output type/range (p63)
-#define AOUT_UNIP5         0	// 0..+5 Volt
-#define AOUT_UNIP10        1	// 0..+10 Volt
-#define AOUT_BIP5          2	// -5..+5 Volt
-#define AOUT_BIP10         3	// -10..+10 Volt
+/*  A/D Conversion Signal Select (for SetConversionSelect) */
+#define ADC_START_SOFTWARE         0x0	/*  Software A/D Start */
+#define ADC_START_PCLK             0x1	/*  Pacer Clock (Ext. Int. see Func.509) */
+#define ADC_START_BCLK             0x2	/*  Burst Clock */
+#define ADC_START_DIGITAL_IT       0x3	/*  Digital Interrupt */
+#define ADC_START_DAC1_MARKER1     0x4	/*  D/A 1 Data Marker 1 */
+#define ADC_START_DAC2_MARKER1     0x5	/*  D/A 2 Data Marker 1 */
+#define ADC_START_SBUS0            0x6	/*  SyncBus 0 */
+#define ADC_START_SBUS1            0x7	/*  SyncBus 1 */
+#define ADC_START_SBUS2            0x8	/*  SyncBus 2 */
+
+/*  Burst Clock start trigger select (SetBurstStart) */
+#define BCLK_START_SOFTWARE        0x0	/*  Software A/D Start (StartBurst) */
+#define BCLK_START_PCLK            0x1	/*  Pacer Clock */
+#define BCLK_START_ETRIG           0x2	/*  External Trigger */
+#define BCLK_START_DIGITAL_IT      0x3	/*  Digital Interrupt */
+#define BCLK_START_SBUS0           0x4	/*  SyncBus 0 */
+#define BCLK_START_SBUS1           0x5	/*  SyncBus 1 */
+#define BCLK_START_SBUS2           0x6	/*  SyncBus 2 */
+
+/*  Pacer Clock start trigger select (SetPacerStart) */
+#define PCLK_START_SOFTWARE        0x0	/*  Software Pacer Start (StartPacer) */
+#define PCLK_START_ETRIG           0x1	/*  External trigger */
+#define PCLK_START_DIGITAL_IT      0x2	/*  Digital interrupt */
+#define PCLK_START_UTC2            0x3	/*  User TC 2 out */
+#define PCLK_START_SBUS0           0x4	/*  SyncBus 0 */
+#define PCLK_START_SBUS1           0x5	/*  SyncBus 1 */
+#define PCLK_START_SBUS2           0x6	/*  SyncBus 2 */
+#define PCLK_START_D_SOFTWARE      0x8	/*  Delayed Software Pacer Start */
+#define PCLK_START_D_ETRIG         0x9	/*  Delayed external trigger */
+#define PCLK_START_D_DIGITAL_IT    0xA	/*  Delayed digital interrupt */
+#define PCLK_START_D_UTC2          0xB	/*  Delayed User TC 2 out */
+#define PCLK_START_D_SBUS0         0xC	/*  Delayed SyncBus 0 */
+#define PCLK_START_D_SBUS1         0xD	/*  Delayed SyncBus 1 */
+#define PCLK_START_D_SBUS2         0xE	/*  Delayed SyncBus 2 */
+#define PCLK_START_ETRIG_GATED     0xF	/*  External Trigger Gated controlled mode */
+
+/*  Pacer Clock Stop Trigger select (SetPacerStop) */
+#define PCLK_STOP_SOFTWARE         0x0	/*  Software Pacer Stop (StopPacer) */
+#define PCLK_STOP_ETRIG            0x1	/*  External Trigger */
+#define PCLK_STOP_DIGITAL_IT       0x2	/*  Digital Interrupt */
+#define PCLK_STOP_ACNT             0x3	/*  About Counter */
+#define PCLK_STOP_UTC2             0x4	/*  User TC2 out */
+#define PCLK_STOP_SBUS0            0x5	/*  SyncBus 0 */
+#define PCLK_STOP_SBUS1            0x6	/*  SyncBus 1 */
+#define PCLK_STOP_SBUS2            0x7	/*  SyncBus 2 */
+#define PCLK_STOP_A_SOFTWARE       0x8	/*  About Software Pacer Stop */
+#define PCLK_STOP_A_ETRIG          0x9	/*  About External Trigger */
+#define PCLK_STOP_A_DIGITAL_IT     0xA	/*  About Digital Interrupt */
+#define PCLK_STOP_A_UTC2           0xC	/*  About User TC2 out */
+#define PCLK_STOP_A_SBUS0          0xD	/*  About SyncBus 0 */
+#define PCLK_STOP_A_SBUS1          0xE	/*  About SyncBus 1 */
+#define PCLK_STOP_A_SBUS2          0xF	/*  About SyncBus 2 */
+
+/*  About Counter Stop Enable */
+#define ACNT_STOP                  0x0	/*  stop enable */
+#define ACNT_NO_STOP               0x1	/*  stop disabled */
+
+/*  DAC update source (SetDAC1Start & SetDAC2Start) */
+#define DAC_START_SOFTWARE         0x0	/*  Software Update */
+#define DAC_START_CGT              0x1	/*  CGT controlled Update */
+#define DAC_START_DAC_CLK          0x2	/*  D/A Clock */
+#define DAC_START_EPCLK            0x3	/*  External Pacer Clock */
+#define DAC_START_SBUS0            0x4	/*  SyncBus 0 */
+#define DAC_START_SBUS1            0x5	/*  SyncBus 1 */
+#define DAC_START_SBUS2            0x6	/*  SyncBus 2 */
+
+/*  DAC Cycle Mode (SetDAC1Cycle, SetDAC2Cycle, SetupDAC) */
+#define DAC_CYCLE_SINGLE           0x0	/*  not cycle */
+#define DAC_CYCLE_MULTI            0x1	/*  cycle */
+
+/*  8254 Operation Modes (Set8254Mode, SetupTimerCounter) */
+#define M8254_EVENT_COUNTER        0	/*  Event Counter */
+#define M8254_HW_ONE_SHOT          1	/*  Hardware-Retriggerable One-Shot */
+#define M8254_RATE_GENERATOR       2	/*  Rate Generator */
+#define M8254_SQUARE_WAVE          3	/*  Square Wave Mode */
+#define M8254_SW_STROBE            4	/*  Software Triggered Strobe */
+#define M8254_HW_STROBE            5	/*  Hardware Triggered Strobe (Retriggerable) */
+
+/*  User Timer/Counter 0 Clock Select (SetUtc0Clock) */
+#define CUTC0_8MHZ                 0x0	/*  8MHz */
+#define CUTC0_EXT_TC_CLOCK1        0x1	/*  Ext. TC Clock 1 */
+#define CUTC0_EXT_TC_CLOCK2        0x2	/*  Ext. TC Clock 2 */
+#define CUTC0_EXT_PCLK             0x3	/*  Ext. Pacer Clock */
+
+/*  User Timer/Counter 1 Clock Select (SetUtc1Clock) */
+#define CUTC1_8MHZ                 0x0	/*  8MHz */
+#define CUTC1_EXT_TC_CLOCK1        0x1	/*  Ext. TC Clock 1 */
+#define CUTC1_EXT_TC_CLOCK2        0x2	/*  Ext. TC Clock 2 */
+#define CUTC1_EXT_PCLK             0x3	/*  Ext. Pacer Clock */
+#define CUTC1_UTC0_OUT             0x4	/*  User Timer/Counter 0 out */
+#define CUTC1_DIN_SIGNAL           0x5	/*  High-Speed Digital Input   Sampling signal */
+
+/*  User Timer/Counter 2 Clock Select (SetUtc2Clock) */
+#define CUTC2_8MHZ                 0x0	/*  8MHz */
+#define CUTC2_EXT_TC_CLOCK1        0x1	/*  Ext. TC Clock 1 */
+#define CUTC2_EXT_TC_CLOCK2        0x2	/*  Ext. TC Clock 2 */
+#define CUTC2_EXT_PCLK             0x3	/*  Ext. Pacer Clock */
+#define CUTC2_UTC1_OUT             0x4	/*  User Timer/Counter 1 out */
+
+/*  User Timer/Counter 0 Gate Select (SetUtc0Gate) */
+#define GUTC0_NOT_GATED            0x0	/*  Not gated */
+#define GUTC0_GATED                0x1	/*  Gated */
+#define GUTC0_EXT_TC_GATE1         0x2	/*  Ext. TC Gate 1 */
+#define GUTC0_EXT_TC_GATE2         0x3	/*  Ext. TC Gate 2 */
+
+/*  User Timer/Counter 1 Gate Select (SetUtc1Gate) */
+#define GUTC1_NOT_GATED            0x0	/*  Not gated */
+#define GUTC1_GATED                0x1	/*  Gated */
+#define GUTC1_EXT_TC_GATE1         0x2	/*  Ext. TC Gate 1 */
+#define GUTC1_EXT_TC_GATE2         0x3	/*  Ext. TC Gate 2 */
+#define GUTC1_UTC0_OUT             0x4	/*  User Timer/Counter 0 out */
+
+/*  User Timer/Counter 2 Gate Select (SetUtc2Gate) */
+#define GUTC2_NOT_GATED            0x0	/*  Not gated */
+#define GUTC2_GATED                0x1	/*  Gated */
+#define GUTC2_EXT_TC_GATE1         0x2	/*  Ext. TC Gate 1 */
+#define GUTC2_EXT_TC_GATE2         0x3	/*  Ext. TC Gate 2 */
+#define GUTC2_UTC1_OUT             0x4	/*  User Timer/Counter 1 out */
+
+/*  Interrupt Source Masks (SetITMask, ClearITMask, GetITStatus) */
+#define IRQM_ADC_FIFO_WRITE        0x0001	/*  ADC FIFO Write */
+#define IRQM_CGT_RESET             0x0002	/*  Reset CGT */
+#define IRQM_CGT_PAUSE             0x0008	/*  Pause CGT */
+#define IRQM_ADC_ABOUT_CNT         0x0010	/*  About Counter out */
+#define IRQM_ADC_DELAY_CNT         0x0020	/*  Delay Counter out */
+#define IRQM_ADC_SAMPLE_CNT	   0x0040	/*  ADC Sample Counter */
+#define IRQM_DAC1_UCNT             0x0080	/*  DAC1 Update Counter */
+#define IRQM_DAC2_UCNT             0x0100	/*  DAC2 Update Counter */
+#define IRQM_UTC1                  0x0200	/*  User TC1 out */
+#define IRQM_UTC1_INV              0x0400	/*  User TC1 out, inverted */
+#define IRQM_UTC2                  0x0800	/*  User TC2 out */
+#define IRQM_DIGITAL_IT            0x1000	/*  Digital Interrupt */
+#define IRQM_EXTERNAL_IT           0x2000	/*  External Interrupt */
+#define IRQM_ETRIG_RISING          0x4000	/*  External Trigger rising-edge */
+#define IRQM_ETRIG_FALLING         0x8000	/*  External Trigger falling-edge */
+
+/*  DMA Request Sources (LAS0) */
+#define DMAS_DISABLED              0x0	/*  DMA Disabled */
+#define DMAS_ADC_SCNT              0x1	/*  ADC Sample Counter */
+#define DMAS_DAC1_UCNT             0x2	/*  D/A1 Update Counter */
+#define DMAS_DAC2_UCNT             0x3	/*  D/A2 Update Counter */
+#define DMAS_UTC1                  0x4	/*  User TC1 out */
+#define DMAS_ADFIFO_HALF_FULL      0x8	/*  A/D FIFO half full */
+#define DMAS_DAC1_FIFO_HALF_EMPTY  0x9	/*  D/A1 FIFO half empty */
+#define DMAS_DAC2_FIFO_HALF_EMPTY  0xA	/*  D/A2 FIFO half empty */
+
+/*  DMA Local Addresses   (0x40000000+LAS1 offset) */
+#define DMALADDR_ADC       0x40000000	/*  A/D FIFO */
+#define DMALADDR_HDIN      0x40000004	/*  High Speed Digital Input FIFO */
+#define DMALADDR_DAC1      0x40000008	/*  D/A1 FIFO */
+#define DMALADDR_DAC2      0x4000000C	/*  D/A2 FIFO */
+
+/*  Port 0 compare modes (SetDIO0CompareMode) */
+#define DIO_MODE_EVENT     0	/*  Event Mode */
+#define DIO_MODE_MATCH     1	/*  Match Mode */
+
+/*  Digital Table Enable (Port 1 disable) */
+#define DTBL_DISABLE       0	/*  Enable Digital Table */
+#define DTBL_ENABLE        1	/*  Disable Digital Table */
+
+/*  Sampling Signal for High Speed Digital Input (SetHdinStart) */
+#define HDIN_SOFTWARE      0x0	/*  Software Trigger */
+#define HDIN_ADC           0x1	/*  A/D Conversion Signal */
+#define HDIN_UTC0          0x2	/*  User TC out 0 */
+#define HDIN_UTC1          0x3	/*  User TC out 1 */
+#define HDIN_UTC2          0x4	/*  User TC out 2 */
+#define HDIN_EPCLK         0x5	/*  External Pacer Clock */
+#define HDIN_ETRG          0x6	/*  External Trigger */
+
+/*  Channel Gain Table / Channel Gain Latch */
+#define CSC_LATCH          0	/*  Channel Gain Latch mode */
+#define CSC_CGT            1	/*  Channel Gain Table mode */
+
+/*  Channel Gain Table Pause Enable */
+#define CGT_PAUSE_DISABLE  0	/*  Channel Gain Table Pause Disable */
+#define CGT_PAUSE_ENABLE   1	/*  Channel Gain Table Pause Enable */
+
+/*  DAC output type/range (p63) */
+#define AOUT_UNIP5         0	/*  0..+5 Volt */
+#define AOUT_UNIP10        1	/*  0..+10 Volt */
+#define AOUT_BIP5          2	/*  -5..+5 Volt */
+#define AOUT_BIP10         3	/*  -10..+10 Volt */
 
-// Ghannel Gain Table field definitions (p61)
-// Gain
+/*  Ghannel Gain Table field definitions (p61) */
+/*  Gain */
 #define GAIN1              0
 #define GAIN2              1
 #define GAIN4              2
@@ -398,15 +398,15 @@
 #define GAIN64             6
 #define GAIN128            7
 
-// Input range/polarity
-#define AIN_BIP5           0	// -5..+5 Volt
-#define AIN_BIP10          1	// -10..+10 Volt
-#define AIN_UNIP10         2	// 0..+10 Volt
-
-// non referenced single ended select bit
-#define NRSE_AGND          0	// AGND referenced SE input
-#define NRSE_AINS          1	// AIN SENSE referenced SE input
-
-// single ended vs differential
-#define GND_SE		0	// Single-Ended
-#define GND_DIFF	1	// Differential
+/*  Input range/polarity */
+#define AIN_BIP5           0	/*  -5..+5 Volt */
+#define AIN_BIP10          1	/*  -10..+10 Volt */
+#define AIN_UNIP10         2	/*  0..+10 Volt */
+
+/*  non referenced single ended select bit */
+#define NRSE_AGND          0	/*  AGND referenced SE input */
+#define NRSE_AINS          1	/*  AIN SENSE referenced SE input */
+
+/*  single ended vs differential */
+#define GND_SE		0	/*  Single-Ended */
+#define GND_DIFF	1	/*  Differential */
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -133,38 +133,30 @@ typedef struct {
 	void *base_addr;
 	int got_regions;
 	short allocatedBuf;
-	uint8_t ai_cmd_running;	// ai_cmd is running
-	uint8_t ai_continous;	// continous aquisition
-	int ai_sample_count;	// number of samples to aquire
-	unsigned int ai_sample_timer;	// time between samples in
-	// units of the timer
-	int ai_convert_count;	// conversion counter
-	unsigned int ai_convert_timer;	// time between conversion in
-	// units of the timer
-	uint16_t CounterIntEnabs;	//Counter interrupt enable
-	//mask for MISC2 register.
-	uint8_t AdcItems;	//Number of items in ADC poll
-	//list.
-	DMABUF RPSBuf;		//DMA buffer used to hold ADC
-	//(RPS1) program.
-	DMABUF ANABuf;		//DMA buffer used to receive
-	//ADC data and hold DAC data.
-	uint32_t *pDacWBuf;	//Pointer to logical adrs of
-	//DMA buffer used to hold DAC
-	//data.
-	uint16_t Dacpol;	//Image of DAC polarity
-	//register.
-	uint8_t TrimSetpoint[12];	//Images of TrimDAC setpoints.
-	//registers.
-	uint16_t ChargeEnabled;	//Image of MISC2 Battery
-	//Charge Enabled (0 or
-	//WRMISC2_CHARGE_ENABLE).
-	uint16_t WDInterval;	//Image of MISC2 watchdog
-	//interval control bits.
-	uint32_t I2CAdrs;	//I2C device address for
-	//onboard EEPROM (board rev
-	//dependent).
-	//  short         I2Cards;
+	uint8_t ai_cmd_running;	/*  ai_cmd is running */
+	uint8_t ai_continous;	/*  continous aquisition */
+	int ai_sample_count;	/*  number of samples to aquire */
+	unsigned int ai_sample_timer;
+	/*  time between samples in  units of the timer */
+	int ai_convert_count;	/*  conversion counter */
+	unsigned int ai_convert_timer;
+	/*  time between conversion in  units of the timer */
+	uint16_t CounterIntEnabs;
+	/* Counter interrupt enable  mask for MISC2 register. */
+	uint8_t AdcItems;	/* Number of items in ADC poll  list. */
+	DMABUF RPSBuf;		/* DMA buffer used to hold ADC (RPS1) program. */
+	DMABUF ANABuf;
+	/* DMA buffer used to receive ADC data and hold DAC data. */
+	uint32_t *pDacWBuf;
+	/* Pointer to logical adrs of DMA buffer used to hold DAC  data. */
+	uint16_t Dacpol;	/* Image of DAC polarity register. */
+	uint8_t TrimSetpoint[12];	/* Images of TrimDAC setpoints */
+	uint16_t ChargeEnabled;	/* Image of MISC2 Battery */
+	/* Charge Enabled (0 or WRMISC2_CHARGE_ENABLE). */
+	uint16_t WDInterval;	/* Image of MISC2 watchdog interval control bits. */
+	uint32_t I2CAdrs;
+	/* I2C device address for onboard EEPROM (board rev dependent). */
+	/*   short         I2Cards; */
 	lsampl_t ao_readback[S626_DAC_CHANNELS];
 } s626_private;
 
@@ -229,7 +221,7 @@ static dio_private *dio_private_word[]={
 
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
-//ioctl routines
+/* ioctl routines */
 static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, lsampl_t * data);
 /* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data); */
@@ -265,9 +257,9 @@ static irqreturn_t s626_irq_handler(int 
 static lsampl_t s626_ai_reg_to_uint(int data);
 /* static lsampl_t s626_uint_to_reg(comedi_subdevice *s, int data); */
 
-//end ioctl routines
+/* end ioctl routines */
 
-//internal routines
+/* internal routines */
 static void s626_dio_init(comedi_device * dev);
 static void ResetADC(comedi_device * dev, uint8_t * ppl);
 static void LoadTrimDACs(comedi_device * dev);
@@ -285,30 +277,30 @@ static void DEBIreplace(comedi_device * 
 	uint16_t wdata);
 static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize);
 
-// COUNTER OBJECT ------------------------------------------------
+/*  COUNTER OBJECT ------------------------------------------------ */
 typedef struct enc_private_struct {
-	// Pointers to functions that differ for A and B counters:
-	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	//Return clock enable.
-	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	//Return interrupt source.
-	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	//Return preload trigger source.
-	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	//Return standardized operating mode.
-	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	//Generate soft index strobe.
-	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	//Program clock enable.
-	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	//Program interrupt source.
-	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	//Program preload trigger source.
-	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	//Program standardized operating mode.
-	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	//Reset event capture flags.
-
-	uint16_t MyCRA;		//   Address of CRA register.
-	uint16_t MyCRB;		//   Address of CRB register.
-	uint16_t MyLatchLsw;	//   Address of Latch least-significant-word
-	//   register.
-	uint16_t MyEventBits[4];	//   Bit translations for IntSrc -->RDMISC2.
-} enc_private;			//counter object
+	/*  Pointers to functions that differ for A and B counters: */
+	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	/* Generate soft index strobe. */
+	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	/* Reset event capture flags. */
+
+	uint16_t MyCRA;		/*    Address of CRA register. */
+	uint16_t MyCRB;		/*    Address of CRB register. */
+	uint16_t MyLatchLsw;	/*    Address of Latch least-significant-word */
+	/*    register. */
+	uint16_t MyEventBits[4];	/*    Bit translations for IntSrc -->RDMISC2. */
+} enc_private;			/* counter object */
 
 #define encpriv ((enc_private *)(dev->subdevices+5)->private)
 
-//counters routines
+/* counters routines */
 static void s626_timer_load(comedi_device * dev, enc_private * k, int tick);
 static uint32_t ReadLatch(comedi_device * dev, enc_private * k);
 static void ResetCapFlags_A(comedi_device * dev, enc_private * k);
@@ -348,19 +340,17 @@ static void PulseIndex_A(comedi_device *
 static void PulseIndex_B(comedi_device * dev, enc_private * k);
 static void Preload(comedi_device * dev, enc_private * k, uint32_t value);
 static void CountersInit(comedi_device * dev);
-//end internal routines
+/* end internal routines */
 
-/////////////////////////////////////////////////////////////////////////
-// Counter objects constructor.
+/*  Counter objects constructor. */
 
-// Counter overflow/index event flag masks for RDMISC2.
+/*  Counter overflow/index event flag masks for RDMISC2. */
 #define INDXMASK(C)		( 1 << ( ( (C) > 2 ) ? ( (C) * 2 - 1 ) : ( (C) * 2 +  4 ) ) )
 #define OVERMASK(C)		( 1 << ( ( (C) > 2 ) ? ( (C) * 2 + 5 ) : ( (C) * 2 + 10 ) ) )
 #define EVBITS(C)		{ 0, OVERMASK(C), INDXMASK(C), OVERMASK(C) | INDXMASK(C) }
 
-// Translation table to map IntSrc into equivalent RDMISC2 event flag
-// bits.
-//static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) };
+/*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
+/* static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) }; */
 
 /* enc_private; */
 static enc_private enc_private_data[] = {
@@ -462,8 +452,8 @@ static enc_private enc_private_data[] = 
 		},
 };
 
-// enab/disable a function or test status bit(s) that are accessed
-// through Main Control Registers 1 or 2.
+/*  enab/disable a function or test status bit(s) that are accessed */
+/*  through Main Control Registers 1 or 2. */
 #define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) << 16 ) | (uint32_t)( CTRLWORD ),devpriv->base_addr+( REGADRS ) )
 
 #define MC_DISABLE( REGADRS, CTRLWORD )	writel(  (uint32_t)( CTRLWORD ) << 16 , devpriv->base_addr+( REGADRS ) )
@@ -480,11 +470,11 @@ static enc_private enc_private_data[] = 
 
 #define BUGFIX_STREG(REGADRS)   ( REGADRS - 4 )
 
-// Write a time slot control record to TSL2.
+/*  Write a time slot control record to TSL2. */
 #define VECTPORT( VECTNUM )		(P_TSL2 + ( (VECTNUM) << 2 ))
 #define SETVECT( VECTNUM, VECTVAL )	WR7146(VECTPORT( VECTNUM ), (VECTVAL))
 
-// Code macros used for constructing I2C command bytes.
+/*  Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR,VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
 #define I2C_B1(ATTR,VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
 #define I2C_B0(ATTR,VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
@@ -550,16 +540,16 @@ static int s626_attach(comedi_device * d
 	}
 
 	if (devpriv->base_addr) {
-		//disable master interrupt
+		/* disable master interrupt */
 		writel(0, devpriv->base_addr + P_IER);
 
-		//soft reset
+		/* soft reset */
 		writel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);
 
-		//DMA FIXME DMA//
+		/* DMA FIXME DMA// */
 		DEBUG("s626_attach: DMA ALLOCATION\n");
 
-		//adc buffer allocation
+		/* adc buffer allocation */
 		devpriv->allocatedBuf = 0;
 
 		if ((devpriv->ANABuf.LogicalBase =
@@ -599,7 +589,7 @@ static int s626_attach(comedi_device * d
 	dev->iobase = (unsigned long)devpriv->base_addr;
 	dev->irq = devpriv->pdev->irq;
 
-	//set up interrupt handler
+	/* set up interrupt handler */
 	if (dev->irq == 0) {
 		printk(" unknown irq (bad)\n");
 	} else {
@@ -689,119 +679,119 @@ static int s626_attach(comedi_device * d
 	s->maxdata = 0xffffff;
 	s->range_table = &range_unknown;
 
-	//stop ai_command
+	/* stop ai_command */
 	devpriv->ai_cmd_running = 0;
 
 	if (devpriv->base_addr && (devpriv->allocatedBuf == 2)) {
 		dma_addr_t pPhysBuf;
 		uint16_t chan;
 
-		// enab DEBI and audio pins, enable I2C interface.
+		/*  enab DEBI and audio pins, enable I2C interface. */
 		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
-		// Configure DEBI operating mode.
-		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	// Local bus is 16
-			// bits wide.
-			| (DEBI_TOUT << DEBI_CFG_TOUT_BIT)	// Declare DEBI
-			// transfer timeout
-			// interval.
-			| DEBI_SWAP	// Set up byte lane
-			// steering.
-			| DEBI_CFG_INTEL);	// Intel-compatible
-		// local bus (DEBI
-		// never times out).
+		/*  Configure DEBI operating mode. */
+		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
+			/*  bits wide. */
+			| (DEBI_TOUT << DEBI_CFG_TOUT_BIT)	/*  Declare DEBI */
+			/*  transfer timeout */
+			/*  interval. */
+			| DEBI_SWAP	/*  Set up byte lane */
+			/*  steering. */
+			| DEBI_CFG_INTEL);	/*  Intel-compatible */
+		/*  local bus (DEBI */
+		/*  never times out). */
 		DEBUG("s626_attach: %d debi init -- %d\n",
 			DEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |
 			DEBI_SWAP | DEBI_CFG_INTEL,
 			DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
 			DEBI_CFG_16Q);
 
-		//DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ
-		//| DEBI_CFG_INCQ| DEBI_CFG_16Q); //end
+		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
+		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
 
-		// Paging is disabled.
-		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	// Disable MMU paging.
+		/*  Paging is disabled. */
+		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	/*  Disable MMU paging. */
 
-		// Init GPIO so that ADC Start* is negated.
+		/*  Init GPIO so that ADC Start* is negated. */
 		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
 
-		//IsBoardRevA is a boolean that indicates whether the board is
-		//RevA.
+    /* IsBoardRevA is a boolean that indicates whether the board is RevA.
+     *
+     * VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
+     * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
+     * is used to access the onboard serial EEPROM.  The EEPROM's I2C
+     * DeviceAddress is hardwired to a value that is dependent on the
+     * 626 board revision.  On all board revisions, the EEPROM stores
+     * TrimDAC calibration constants for analog I/O.  On RevB and
+     * higher boards, the DeviceAddress is hardwired to 0 to enable
+     * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
+     * this is the address at which the SAA7146 expects a
+     * configuration EEPROM to reside.  On RevA boards, the EEPROM
+     * device address, which is hardwired to 4, prevents the SAA7146
+     * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
+     * default values, instead.
+     */
+
+		/*     devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
+		/*  DeviceType (0xA0) */
+		/*  and DeviceAddress<<1. */
+
+		devpriv->I2CAdrs = 0xA0;	/*  I2C device address for onboard */
+		/*  eeprom(revb) */
+
+		/*  Issue an I2C ABORT command to halt any I2C operation in */
+		/* progress and reset BUSY flag. */
+		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
+		/*  Write I2C control: abort any I2C activity. */
+		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+		/*  Invoke command  upload */
+		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0);
+		/*  and wait for upload to complete. */
 
-		// VERSION 2.01 CHANGE: REV A & B BOARDS NOW SUPPORTED BY DYNAMIC
-		// EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
-		// is used to access the onboard serial EEPROM.  The EEPROM's I2C
-		// DeviceAddress is hardwired to a value that is dependent on the
-		// 626 board revision.  On all board revisions, the EEPROM stores
-		// TrimDAC calibration constants for analog I/O.  On RevB and
-		// higher boards, the DeviceAddress is hardwired to 0 to enable
-		// the EEPROM to also store the PCI SubVendorID and SubDeviceID;
-		// this is the address at which the SAA7146 expects a
-		// configuration EEPROM to reside.  On RevA boards, the EEPROM
-		// device address, which is hardwired to 4, prevents the SAA7146
-		// from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
-		// default values, instead.
-
-		//    devpriv->I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM
-		// DeviceType (0xA0)
-		// and DeviceAddress<<1.
-
-		devpriv->I2CAdrs = 0xA0;	// I2C device address for onboard
-		// eeprom(revb)
-
-		// Issue an I2C ABORT command to halt any I2C operation in
-		//progress and reset BUSY flag.
-		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);	// Write I2C control:
-		// abort any I2C
-		// activity.
-		MC_ENABLE(P_MC2, MC2_UPLD_IIC);	// Invoke command
-		// upload
-		while ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0) ;	// and wait for
-		// upload to
-		// complete.
-
-		// Per SAA7146 data sheet, write to STATUS reg twice to reset all
-		// I2C error flags.
+		/* Per SAA7146 data sheet, write to STATUS reg twice to
+		 * reset all  I2C error flags. */
 		for (i = 0; i < 2; i++) {
-			WR7146(P_I2CSTAT, I2C_CLKSEL);	// Write I2C control: reset
-			// error flags.
-			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	// Invoke command upload
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;	//   and wait for
-			//   upload to
-			//   complete.
+			WR7146(P_I2CSTAT, I2C_CLKSEL);
+			/*  Write I2C control: reset  error flags. */
+			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC));
+			/* and wait for upload to complete. */
 		}
 
-		// Init audio interface functional attributes: set DAC/ADC serial
-		// clock rates, invert DAC serial clock so that DAC data setup
-		// times are satisfied, enable DAC serial clock out.
+		/* Init audio interface functional attributes: set DAC/ADC
+		 * serial clock rates, invert DAC serial clock so that
+		 * DAC data setup times are satisfied, enable DAC serial
+		 * clock out.
+		 */
+
 		WR7146(P_ACON2, ACON2_INIT);
 
-		// Set up TSL1 slot list, which is used to control the
-		// accumulation of ADC data: RSD1 = shift data in on SD1.  SIB_A1
-		// = store data uint8_t at next available location in FB BUFFER1
-		// register.
-		WR7146(P_TSL1, RSD1 | SIB_A1);	// Fetch ADC high data
-		// uint8_t.
-		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);	// Fetch ADC low data
-		// uint8_t; end of
-		// TSL1.
+		/* Set up TSL1 slot list, which is used to control the
+		 * accumulation of ADC data: RSD1 = shift data in on SD1.
+		 * SIB_A1  = store data uint8_t at next available location in
+		 * FB BUFFER1  register. */
+		WR7146(P_TSL1, RSD1 | SIB_A1);
+		/*  Fetch ADC high data uint8_t. */
+		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
+		/*  Fetch ADC low data uint8_t; end of TSL1. */
 
-		// enab TSL1 slot list so that it executes all the time.
+		/*  enab TSL1 slot list so that it executes all the time. */
 		WR7146(P_ACON1, ACON1_ADCSTART);
 
-		// Initialize RPS registers used for ADC.
+		/*  Initialize RPS registers used for ADC. */
 
-		//Physical start of RPS program.
+		/* Physical start of RPS program. */
 		WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
-		WR7146(P_RPSPAGE1, 0);	// RPS program performs no
-		// explicit mem writes.
-		WR7146(P_RPS1_TOUT, 0);	// Disable RPS timeouts.
-
-		// SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface to a
-		// known state by invoking ADCs until FB BUFFER 1 register shows
-		// that it is correctly receiving ADC data.  This is necessary
-		// because the SAA7146 ADC interface does not start up in a
-		// defined state after a PCI reset.
+		WR7146(P_RPSPAGE1, 0);
+		/*  RPS program performs no explicit mem writes. */
+		WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
+
+		/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface
+		 * to a known state by invoking ADCs until FB BUFFER 1
+		 * register shows that it is correctly receiving ADC data.
+		 * This is necessary because the SAA7146 ADC interface does
+		 * not start up in a defined state after a PCI reset.
+		 */
 
 /*     PollList = EOPL;			// Create a simple polling */
 /* 					// list for analog input */
@@ -829,115 +819,123 @@ static int s626_attach(comedi_device * d
 /* 	  break; */
 /*       } */
 
-		// end initADC
+		/*  end initADC */
 
-		// init the DAC interface
+		/*  init the DAC interface */
 
-		// Init Audio2's output DMAC attributes: burst length = 1 DWORD,
-		// threshold = 1 DWORD.
+		/* Init Audio2's output DMAC attributes: burst length = 1
+		 * DWORD,  threshold = 1 DWORD.
+		 */
 		WR7146(P_PCI_BT_A, 0);
 
-		// Init Audio2's output DMA physical addresses.  The protection
-		// address is set to 1 DWORD past the base address so that a
-		// single DWORD will be transferred each time a DMA transfer is
-		// enabled.
+		/* Init Audio2's output DMA physical addresses.  The protection
+		 * address is set to 1 DWORD past the base address so that a
+		 * single DWORD will be transferred each time a DMA transfer is
+		 * enabled. */
 
 		pPhysBuf =
 			devpriv->ANABuf.PhysicalBase +
 			(DAC_WDMABUF_OS * sizeof(uint32_t));
 
-		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	// Buffer base adrs.
-		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	// Protection address.
+		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
+		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
 
-		// Cache Audio2's output DMA buffer logical address.  This is
-		// where DAC data is buffered for A2 output DMA transfers.
+		/* Cache Audio2's output DMA buffer logical address.  This is
+		 * where DAC data is buffered for A2 output DMA transfers. */
 		devpriv->pDacWBuf =
 			(uint32_t *) devpriv->ANABuf.LogicalBase +
 			DAC_WDMABUF_OS;
 
-		// Audio2's output channels does not use paging.  The protection
-		// violation handling bit is set so that the DMAC will
-		// automatically halt and its PCI address pointer will be reset
-		// when the protection address is reached.
+		/* Audio2's output channels does not use paging.  The protection
+		 * violation handling bit is set so that the DMAC will
+		 * automatically halt and its PCI address pointer will be reset
+		 * when the protection address is reached. */
+
 		WR7146(P_PAGEA2_OUT, 8);
 
-		// Initialize time slot list 2 (TSL2), which is used to control
-		// the clock generation for and serialization of data to be sent
-		// to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
-		// execution; this permits other slots to be safely modified
-		// without first turning off the TSL sequencer (which is
-		// apparently impossible to do).  Also, SD3 (which is driven by a
-		// pull-up resistor) is shifted in and stored to the MSB of
-		// FB_BUFFER2 to be used as evidence that the slot sequence has
-		// not yet finished executing.
-		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);	// Slot 0: Trap TSL
-		// execution, shift 0xFF
-		// into FB_BUFFER2.
-
-		// Initialize slot 1, which is constant.  Slot 1 causes a DWORD to
-		// be transferred from audio channel 2's output FIFO to the FIFO's
-		// output buffer so that it can be serialized and sent to the DAC
-		// during subsequent slots.  All remaining slots are dynamically
-		// populated as required by the target DAC device.
-		SETVECT(1, LF_A2);	// Slot 1: Fetch DWORD from Audio2's
-		// output FIFO.
+		/* Initialize time slot list 2 (TSL2), which is used to control
+		 * the clock generation for and serialization of data to be sent
+		 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
+		 * execution; this permits other slots to be safely modified
+		 * without first turning off the TSL sequencer (which is
+		 * apparently impossible to do).  Also, SD3 (which is driven by a
+		 * pull-up resistor) is shifted in and stored to the MSB of
+		 * FB_BUFFER2 to be used as evidence that the slot sequence has
+		 * not yet finished executing.
+		 */
+
+		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
+		/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */
+
+		/* Initialize slot 1, which is constant.  Slot 1 causes a
+		 * DWORD to be transferred from audio channel 2's output FIFO
+		 * to the FIFO's output buffer so that it can be serialized
+		 * and sent to the DAC during subsequent slots.  All remaining
+		 * slots are dynamically populated as required by the target
+		 * DAC device.
+		 */
+		SETVECT(1, LF_A2);
+		/*  Slot 1: Fetch DWORD from Audio2's output FIFO. */
 
-		// Start DAC's audio interface (TSL2) running.
+		/*  Start DAC's audio interface (TSL2) running. */
 		WR7146(P_ACON1, ACON1_DACSTART);
 
-		////////////////////////////////////////////////////////
-
-		// end init DAC interface
+		/* end init DAC interface */
 
-		// Init Trim DACs to calibrated values.  Do it twice because the
-		// SAA7146 audio channel does not always reset properly and
-		// sometimes causes the first few TrimDAC writes to malfunction.
+		/* Init Trim DACs to calibrated values.  Do it twice because the
+		 * SAA7146 audio channel does not always reset properly and
+		 * sometimes causes the first few TrimDAC writes to malfunction.
+		 */
 
 		LoadTrimDACs(dev);
-		LoadTrimDACs(dev);	// Insurance.
+		LoadTrimDACs(dev);	/*  Insurance. */
 
-		//////////////////////////////////////////////////////////////////
-		// Manually init all gate array hardware in case this is a soft
-		// reset (we have no way of determining whether this is a warm or
-		// cold start).  This is necessary because the gate array will
-		// reset only in response to a PCI hard reset; there is no soft
-		// reset function.
-
-		// Init all DAC outputs to 0V and init all DAC setpoint and
-		// polarity images.
+		/* Manually init all gate array hardware in case this is a soft
+		 * reset (we have no way of determining whether this is a warm
+		 * or cold start).  This is necessary because the gate array will
+		 * reset only in response to a PCI hard reset; there is no soft
+		 * reset function. */
+
+		/* Init all DAC outputs to 0V and init all DAC setpoint and
+		 * polarity images.
+		 */
 		for (chan = 0; chan < S626_DAC_CHANNELS; chan++)
 			SetDAC(dev, chan, 0);
 
-		// Init image of WRMISC2 Battery Charger Enabled control bit.
-		// This image is used when the state of the charger control bit,
-		// which has no direct hardware readback mechanism, is queried.
+		/* Init image of WRMISC2 Battery Charger Enabled control bit.
+		 * This image is used when the state of the charger control bit,
+		 * which has no direct hardware readback mechanism, is queried.
+		 */
 		devpriv->ChargeEnabled = 0;
 
-		// Init image of watchdog timer interval in WRMISC2.  This image
-		// maintains the value of the control bits of MISC2 are
-		// continuously reset to zero as long as the WD timer is disabled.
+		/* Init image of watchdog timer interval in WRMISC2.  This image
+		 * maintains the value of the control bits of MISC2 are
+		 * continuously reset to zero as long as the WD timer is disabled.
+		 */
 		devpriv->WDInterval = 0;
 
-		// Init Counter Interrupt enab mask for RDMISC2.  This mask is
-		// applied against MISC2 when testing to determine which timer
-		// events are requesting interrupt service.
+		/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
+		 * applied against MISC2 when testing to determine which timer
+		 * events are requesting interrupt service.
+		 */
 		devpriv->CounterIntEnabs = 0;
 
-		// Init counters.
+		/*  Init counters. */
 		CountersInit(dev);
 
-		// Without modifying the state of the Battery Backup enab, disable
-		// the watchdog timer, set DIO channels 0-5 to operate in the
-		// standard DIO (vs. counter overflow) mode, disable the battery
-		// charger, and reset the watchdog interval selector to zero.
+		/* Without modifying the state of the Battery Backup enab, disable
+		 * the watchdog timer, set DIO channels 0-5 to operate in the
+		 * standard DIO (vs. counter overflow) mode, disable the battery
+		 * charger, and reset the watchdog interval selector to zero.
+		 */
 		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
 					LP_RDMISC2) & MISC2_BATT_ENABLE));
 
-		// Initialize the digital I/O subsystem.
+		/*  Initialize the digital I/O subsystem. */
 		s626_dio_init(dev);
 
-		//enable interrupt test
-		// writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER);
+		/* enable interrupt test */
+		/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv->base_addr+P_IER); */
 	}
 
 	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,
@@ -981,47 +979,48 @@ static irqreturn_t s626_irq_handler(int 
 
 	if (dev->attached == 0)
 		return IRQ_NONE;
-	// lock to avoid race with comedi_poll
+	/*  lock to avoid race with comedi_poll */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 
-	//save interrupt enable register state
+	/* save interrupt enable register state */
 	irqstatus = readl(devpriv->base_addr + P_IER);
 
-	//read interrupt type
+	/* read interrupt type */
 	irqtype = readl(devpriv->base_addr + P_ISR);
 
-	//disable master interrupt
+	/* disable master interrupt */
 	writel(0, devpriv->base_addr + P_IER);
 
-	//clear interrupt
+	/* clear interrupt */
 	writel(irqtype, devpriv->base_addr + P_ISR);
 
-	//do somethings
+	/* do somethings */
 	DEBUG("s626_irq_handler: interrupt type %d\n", irqtype);
 
 	switch (irqtype) {
-	case IRQ_RPS1:		// end_of_scan occurs
+	case IRQ_RPS1:		/*  end_of_scan occurs */
 
 		DEBUG("s626_irq_handler: RPS1 irq detected\n");
 
-		// manage ai subdevice
+		/*  manage ai subdevice */
 		s = dev->subdevices;
 		cmd = &(s->async->cmd);
 
-		// Init ptr to DMA buffer that holds new ADC data.  We skip the
-		// first uint16_t in the buffer because it contains junk data from
-		// the final ADC of the previous poll list scan.
+		/* Init ptr to DMA buffer that holds new ADC data.  We skip the
+		 * first uint16_t in the buffer because it contains junk data from
+		 * the final ADC of the previous poll list scan.
+		 */
 		readaddr = (int32_t *) devpriv->ANABuf.LogicalBase + 1;
 
-		// get the data and hand it over to comedi
+		/*  get the data and hand it over to comedi */
 		for (i = 0; i < (s->async->cmd.chanlist_len); i++) {
-			// Convert ADC data to 16-bit integer values and copy to application
-			// buffer.
+			/*  Convert ADC data to 16-bit integer values and copy to application */
+			/*  buffer. */
 			tempdata = s626_ai_reg_to_uint((int)*readaddr);
 			readaddr++;
 
-			//put data into read buffer
-			// comedi_buf_put(s->async, tempdata);
+			/* put data into read buffer */
+			/*  comedi_buf_put(s->async, tempdata); */
 			if (cfc_write_to_buffer(s, tempdata) == 0)
 				printk("s626_irq_handler: cfc_write_to_buffer error!\n");
 
@@ -1029,7 +1028,7 @@ static irqreturn_t s626_irq_handler(int 
 				i, tempdata);
 		}
 
-		//end of scan occurs
+		/* end of scan occurs */
 		s->async->events |= COMEDI_CB_EOS;
 
 		if (!(devpriv->ai_continous))
@@ -1037,13 +1036,13 @@ static irqreturn_t s626_irq_handler(int 
 		if (devpriv->ai_sample_count <= 0) {
 			devpriv->ai_cmd_running = 0;
 
-			// Stop RPS program.
+			/*  Stop RPS program. */
 			MC_DISABLE(P_MC1, MC1_ERPS1);
 
-			//send end of acquisition
+			/* send end of acquisition */
 			s->async->events |= COMEDI_CB_EOA;
 
-			//disable master interrupt
+			/* disable master interrupt */
 			irqstatus = 0;
 		}
 
@@ -1054,40 +1053,40 @@ static irqreturn_t s626_irq_handler(int 
 
 			DEBUG("s626_irq_handler: External trigger is set!!!\n");
 		}
-		// tell comedi that data is there
+		/*  tell comedi that data is there */
 		DEBUG("s626_irq_handler: events %d\n", s->async->events);
 		comedi_event(dev, s);
 		break;
-	case IRQ_GPIO3:	//check dio and conter interrupt
+	case IRQ_GPIO3:	/* check dio and conter interrupt */
 
 		DEBUG("s626_irq_handler: GPIO3 irq detected\n");
 
-		// manage ai subdevice
+		/*  manage ai subdevice */
 		s = dev->subdevices;
 		cmd = &(s->async->cmd);
 
-		//s626_dio_clear_irq(dev);
+		/* s626_dio_clear_irq(dev); */
 
 		for (group = 0; group < S626_DIO_BANKS; group++) {
 			irqbit = 0;
-			//read interrupt type
+			/* read interrupt type */
 			irqbit = DEBIread(dev,
 				((dio_private *) (dev->subdevices + 2 +
 						group)->private)->RDCapFlg);
 
-			//check if interrupt is generated from dio channels
+			/* check if interrupt is generated from dio channels */
 			if (irqbit) {
 				s626_dio_reset_irq(dev, group, irqbit);
 				DEBUG("s626_irq_handler: check interrupt on dio group %d %d\n", group, i);
 				if (devpriv->ai_cmd_running) {
-					//check if interrupt is an ai acquisition start trigger
+					/* check if interrupt is an ai acquisition start trigger */
 					if ((irqbit >> (cmd->start_arg -
 								(16 * group)))
 						== 1
 						&& cmd->start_src == TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->start_arg);
 
-						// Start executing the RPS program.
+						/*  Start executing the RPS program. */
 						MC_ENABLE(P_MC1, MC1_ERPS1);
 
 						DEBUG("s626_irq_handler: aquisition start triggered!!!\n");
@@ -1110,7 +1109,7 @@ static irqreturn_t s626_irq_handler(int 
 						TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->scan_begin_arg);
 
-						// Trigger ADC scan loop start by setting RPS Signal 0.
+						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
 						DEBUG("s626_irq_handler: scan triggered!!! %d\n", devpriv->ai_sample_count);
@@ -1151,7 +1150,7 @@ static irqreturn_t s626_irq_handler(int 
 						TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd->convert_arg);
 
-						// Trigger ADC scan loop start by setting RPS Signal 0.
+						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
 						DEBUG("s626_irq_handler: adc convert triggered!!!\n");
@@ -1175,10 +1174,10 @@ static irqreturn_t s626_irq_handler(int 
 			}
 		}
 
-		//read interrupt type
+		/* read interrupt type */
 		irqbit = DEBIread(dev, LP_RDMISC2);
 
-		//check interrupt on counters
+		/* check interrupt on counters */
 		DEBUG("s626_irq_handler: check counters interrupt %d\n",
 			irqbit);
 
@@ -1186,35 +1185,35 @@ static irqreturn_t s626_irq_handler(int 
 			DEBUG("s626_irq_handler: interrupt on counter 1A overflow\n");
 			k = &encpriv[0];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2A) {
 			DEBUG("s626_irq_handler: interrupt on counter 2A overflow\n");
 			k = &encpriv[1];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT3A) {
 			DEBUG("s626_irq_handler: interrupt on counter 3A overflow\n");
 			k = &encpriv[2];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT1B) {
 			DEBUG("s626_irq_handler: interrupt on counter 1B overflow\n");
 			k = &encpriv[3];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 		}
 		if (irqbit & IRQ_COINT2B) {
 			DEBUG("s626_irq_handler: interrupt on counter 2B overflow\n");
 			k = &encpriv[4];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 
 			if (devpriv->ai_convert_count > 0) {
@@ -1225,7 +1224,7 @@ static irqreturn_t s626_irq_handler(int 
 				if (cmd->convert_src == TRIG_TIMER) {
 					DEBUG("s626_irq_handler: conver timer trigger!!! %d\n", devpriv->ai_convert_count);
 
-					// Trigger ADC scan loop start by setting RPS Signal 0.
+					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 					MC_ENABLE(P_MC2, MC2_ADC_RPS);
 				}
 			}
@@ -1234,13 +1233,13 @@ static irqreturn_t s626_irq_handler(int 
 			DEBUG("s626_irq_handler: interrupt on counter 3B overflow\n");
 			k = &encpriv[5];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k->ResetCapFlags(dev, k);
 
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				DEBUG("s626_irq_handler: scan timer trigger!!!\n");
 
-				// Trigger ADC scan loop start by setting RPS Signal 0.
+				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 				MC_ENABLE(P_MC2, MC2_ADC_RPS);
 			}
 
@@ -1253,7 +1252,7 @@ static irqreturn_t s626_irq_handler(int 
 		}
 	}
 
-	//enable interrupt
+	/* enable interrupt */
 	writel(irqstatus, devpriv->base_addr + P_IER);
 
 	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
@@ -1265,18 +1264,18 @@ static irqreturn_t s626_irq_handler(int 
 static int s626_detach(comedi_device * dev)
 {
 	if (devpriv) {
-		//stop ai_command
+		/* stop ai_command */
 		devpriv->ai_cmd_running = 0;
 
 		if (devpriv->base_addr) {
-			//interrupt mask
-			WR7146(P_IER, 0);	// Disable master interrupt.
-			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	// Clear board's IRQ status flag.
+			/* interrupt mask */
+			WR7146(P_IER, 0);	/*  Disable master interrupt. */
+			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	/*  Clear board's IRQ status flag. */
 
-			// Disable the watchdog timer and battery charger.
+			/*  Disable the watchdog timer and battery charger. */
 			WriteMISC2(dev, 0);
 
-			// Close all interfaces on 7146 device.
+			/*  Close all interfaces on 7146 device. */
 			WR7146(P_MC1, MC1_SHUTDOWN);
 			WR7146(P_ACON1, ACON1_BASE);
 
@@ -1317,174 +1316,186 @@ void ResetADC(comedi_device * dev, uint8
 	uint32_t LocalPPL;
 	comedi_cmd *cmd = &(dev->subdevices->async->cmd);
 
-	// Stop RPS program in case it is currently running.
+	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
 
-	// Set starting logical address to write RPS commands.
+	/*  Set starting logical address to write RPS commands. */
 	pRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;
 
-	// Initialize RPS instruction pointer.
+	/*  Initialize RPS instruction pointer. */
 	WR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);
 
-	// Construct RPS program in RPSBuf DMA buffer
+	/*  Construct RPS program in RPSBuf DMA buffer */
 
 	if (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {
 		DEBUG("ResetADC: scan_begin pause inserted\n");
-		// Wait for Start trigger.
+		/*  Wait for Start trigger. */
 		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
 	}
-	// SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
-	// because the first RPS DEBI Write following a non-RPS DEBI write
-	// seems to always fail.  If we don't do this dummy write, the ADC
-	// gain might not be set to the value required for the first slot in
-	// the poll list; the ADC gain would instead remain unchanged from
-	// the previously programmed value.
-	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI Write command
-	// and address to shadow RAM.
+
+	/* SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
+	 * because the first RPS DEBI Write following a non-RPS DEBI write
+	 * seems to always fail.  If we don't do this dummy write, the ADC
+	 * gain might not be set to the value required for the first slot in
+	 * the poll list; the ADC gain would instead remain unchanged from
+	 * the previously programmed value.
+	 */
+	*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
+	/* Write DEBI Write command and address to shadow RAM. */
+
 	*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI immediate data
-	// to shadow RAM:
-	*pRPS++ = GSEL_BIPOLAR5V;	// arbitrary immediate data
-	// value.
-	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM
-	// uploaded" flag.
-	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-	*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to finish.
-
-	// Digitize all slots in the poll list. This is implemented as a
-	// for loop to limit the slot count to 16 in case the application
-	// forgot to set the EOPL flag in the final slot.
+	*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
+	/*  Write DEBI immediate data  to shadow RAM: */
+
+	*pRPS++ = GSEL_BIPOLAR5V;
+	/*  arbitrary immediate data  value. */
+
+	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+	/*  Reset "shadow RAM  uploaded" flag. */
+	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
+	*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to finish. */
+
+	/* Digitize all slots in the poll list. This is implemented as a
+	 * for loop to limit the slot count to 16 in case the application
+	 * forgot to set the EOPL flag in the final slot.
+	 */
 	for (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {
-		// Convert application's poll list item to private board class
-		// format.  Each app poll list item is an uint8_t with form
-		// (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
-		// +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+	 /* Convert application's poll list item to private board class
+	  * format.  Each app poll list item is an uint8_t with form
+	  * (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
+	  * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+	  */
 		LocalPPL =
 			(*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :
 			GSEL_BIPOLAR10V);
 
-		// Switch ADC analog gain.
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI command
-		// and address to
-		// shadow RAM.
+		/*  Switch ADC analog gain. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	/*  Write DEBI command */
+		/*  and address to */
+		/*  shadow RAM. */
 		*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI
-		// immediate data to
-		// shadow RAM.
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	/*  Write DEBI */
+		/*  immediate data to */
+		/*  shadow RAM. */
 		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM uploaded"
-		// flag.
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to
-		// finish.
-
-		// Select ADC analog input channel.
-		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);	// Write DEBI command
-		// and address to
-		// shadow RAM.
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	/*  Reset "shadow RAM uploaded" */
+		/*  flag. */
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to */
+		/*  finish. */
+
+		/*  Select ADC analog input channel. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);
+		/*  Write DEBI command and address to  shadow RAM. */
 		*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);	// Write DEBI
-		// immediate data to
-		// shadow RAM.
+		*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);
+		/*  Write DEBI immediate data to shadow RAM. */
 		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM uploaded"
-		// flag.
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to
-		// finish.
-
-		// Delay at least 10 microseconds for analog input settling.
-		// Instead of padding with NOPs, we use RPS_JUMP instructions
-		// here; this allows us to produce a longer delay than is
-		// possible with NOPs because each RPS_JUMP flushes the RPS'
-		// instruction prefetch pipeline.
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+		/*  Reset "shadow RAM uploaded"  flag. */
+
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
+		/*  Invoke shadow RAM upload. */
+
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;
+		/*  Wait for shadow upload to finish. */
+
+		/* Delay at least 10 microseconds for analog input settling.
+		 * Instead of padding with NOPs, we use RPS_JUMP instructions
+		 * here; this allows us to produce a longer delay than is
+		 * possible with NOPs because each RPS_JUMP flushes the RPS'
+		 * instruction prefetch pipeline.
+		 */
 		JmpAdrs =
 			(uint32_t) devpriv->RPSBuf.PhysicalBase +
 			(uint32_t) ((unsigned long)pRPS -
 			(unsigned long)devpriv->RPSBuf.LogicalBase);
 		for (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {
-			JmpAdrs += 8;	// Repeat to implement time delay:
-			*pRPS++ = RPS_JUMP;	// Jump to next RPS instruction.
+			JmpAdrs += 8;	/*  Repeat to implement time delay: */
+			*pRPS++ = RPS_JUMP;	/*  Jump to next RPS instruction. */
 			*pRPS++ = JmpAdrs;
 		}
 
 		if (cmd != NULL && cmd->convert_src != TRIG_NOW) {
 			DEBUG("ResetADC: convert pause inserted\n");
-			// Wait for Start trigger.
+			/*  Wait for Start trigger. */
 			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
 		}
-		// Start ADC by pulsing GPIO1.
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// Begin ADC Start pulse.
+		/*  Start ADC by pulsing GPIO1. */
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
 		*pRPS++ = GPIO_BASE | GPIO1_LO;
 		*pRPS++ = RPS_NOP;
-		// VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE.
-		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// End ADC Start pulse.
+		/*  VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+		*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
 		*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-		// Wait for ADC to complete (GPIO2 is asserted high when ADC not
-		// busy) and for data from previous conversion to shift into FB
-		// BUFFER 1 register.
-		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	// Wait for ADC done.
+		/* Wait for ADC to complete (GPIO2 is asserted high when ADC not
+		 * busy) and for data from previous conversion to shift into FB
+		 * BUFFER 1 register.
+		 */
+		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
 
-		// Transfer ADC data from FB BUFFER 1 register to DMA buffer.
+		/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);
 		*pRPS++ =
 			(uint32_t) devpriv->ANABuf.PhysicalBase +
 			(devpriv->AdcItems << 2);
 
-		// If this slot's EndOfPollList flag is set, all channels have
-		// now been processed.
+		/*  If this slot's EndOfPollList flag is set, all channels have */
+		/*  now been processed. */
 		if (*ppl++ & EOPL) {
-			devpriv->AdcItems++;	// Adjust poll list item count.
-			break;	// Exit poll list processing loop.
+			devpriv->AdcItems++;	/*  Adjust poll list item count. */
+			break;	/*  Exit poll list processing loop. */
 		}
 	}
 	DEBUG("ResetADC: ADC items %d \n", devpriv->AdcItems);
 
-	// VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
-	// ADC to stabilize for 2 microseconds before starting the final
-	// (dummy) conversion.  This delay is necessary to allow sufficient
-	// time between last conversion finished and the start of the dummy
-	// conversion.  Without this delay, the last conversion's data value
-	// is sometimes set to the previous conversion's data value.
+	/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
+	 * ADC to stabilize for 2 microseconds before starting the final
+	 * (dummy) conversion.  This delay is necessary to allow sufficient
+	 * time between last conversion finished and the start of the dummy
+	 * conversion.  Without this delay, the last conversion's data value
+	 * is sometimes set to the previous conversion's data value.
+	 */
 	for (n = 0; n < (2 * RPSCLK_PER_US); n++)
 		*pRPS++ = RPS_NOP;
 
-	// Start a dummy conversion to cause the data from the last
-	// conversion of interest to be shifted in.
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// Begin ADC Start pulse.
+	/* Start a dummy conversion to cause the data from the last
+	 * conversion of interest to be shifted in.
+	 */
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  Begin ADC Start pulse. */
 	*pRPS++ = GPIO_BASE | GPIO1_LO;
 	*pRPS++ = RPS_NOP;
-	// VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE.
-	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	// End ADC Start pulse.
+	/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+	*pRPS++ = RPS_LDREG | (P_GPIO >> 2);	/*  End ADC Start pulse. */
 	*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-	// Wait for the data from the last conversion of interest to arrive
-	// in FB BUFFER 1 register.
-	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	// Wait for ADC done.
+	/* Wait for the data from the last conversion of interest to arrive
+	 * in FB BUFFER 1 register.
+	 */
+	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
 
-	// Transfer final ADC data from FB BUFFER 1 register to DMA buffer.
-	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	//
+	/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
+	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);	/*  */
 	*pRPS++ =
 		(uint32_t) devpriv->ANABuf.PhysicalBase +
 		(devpriv->AdcItems << 2);
 
-	// Indicate ADC scan loop is finished.
-	// *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done.
+	/*  Indicate ADC scan loop is finished. */
+	/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */
 
-	//invoke interrupt
+	/* invoke interrupt */
 	if (devpriv->ai_cmd_running == 1) {
 		DEBUG("ResetADC: insert irq in ADC RPS task\n");
 		*pRPS++ = RPS_IRQ;
 	}
-	// Restart RPS program at its beginning.
-	*pRPS++ = RPS_JUMP;	// Branch to start of RPS program.
+	/*  Restart RPS program at its beginning. */
+	*pRPS++ = RPS_JUMP;	/*  Branch to start of RPS program. */
 	*pRPS++ = (uint32_t) devpriv->RPSBuf.PhysicalBase;
 
-	// End of RPS program build
-	// ------------------------------------------------------------
+	/*  End of RPS program build */
 }
 
 /* TO COMPLETE, IF NECESSARY */
@@ -1502,19 +1513,19 @@ static int s626_ai_insn_config(comedi_de
 
 /*   DEBUG("as626_ai_rinsn: ai_rinsn enter \n");  */
 
-/*   // Trigger ADC scan loop start by setting RPS Signal 0. */
+/*   Trigger ADC scan loop start by setting RPS Signal 0. */
 /*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
-/*   // Wait until ADC scan loop is finished (RPS Signal 0 reset). */
+/*   Wait until ADC scan loop is finished (RPS Signal 0 reset). */
 /*   while ( MC_TEST( P_MC2, MC2_ADC_RPS ) ); */
 
-/*   // Init ptr to DMA buffer that holds new ADC data.  We skip the */
-/*   // first uint16_t in the buffer because it contains junk data from */
-/*   // the final ADC of the previous poll list scan. */
+/* Init ptr to DMA buffer that holds new ADC data.  We skip the
+ * first uint16_t in the buffer because it contains junk data from
+ * the final ADC of the previous poll list scan.
+ */
 /*   readaddr = (uint32_t *)devpriv->ANABuf.LogicalBase + 1; */
 
-/*   // Convert ADC data to 16-bit integer values and copy to application */
-/*   // buffer.	 */
+/*  Convert ADC data to 16-bit integer values and copy to application buffer. */
 /*   for ( i = 0; i < devpriv->AdcItems; i++ ) { */
 /*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
 /*     DEBUG("s626_ai_rinsn: data %d \n",*data); */
@@ -1534,86 +1545,85 @@ static int s626_ai_insn_read(comedi_devi
 	uint32_t GpioImage;
 	int n;
 
-/*   //interrupt call test  */
-/*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); //Writing a logical 1 */
-/* 					     //into any of the RPS_PSR */
-/* 					     //bits causes the */
-/* 					     //corresponding interrupt */
-/* 					     //to be generated if */
-/* 					     //enabled */
+ /* interrupt call test  */
+/*   writel(IRQ_GPIO3,devpriv->base_addr+P_PSR); */
+	/* Writing a logical 1 into any of the RPS_PSR bits causes the
+	 * corresponding interrupt to be generated if enabled
+	 */
 
 	DEBUG("s626_ai_insn_read: entering\n");
 
-	// Convert application's ADC specification into form
-	// appropriate for register programming.
+	/* Convert application's ADC specification into form
+	 *  appropriate for register programming.
+	 */
 	if (range == 0)
 		AdcSpec = (chan << 8) | (GSEL_BIPOLAR5V);
 	else
 		AdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);
 
-	// Switch ADC analog gain.
-	DEBIwrite(dev, LP_GSEL, AdcSpec);	// Set gain.
+	/*  Switch ADC analog gain. */
+	DEBIwrite(dev, LP_GSEL, AdcSpec);	/*  Set gain. */
 
-	// Select ADC analog input channel.
-	DEBIwrite(dev, LP_ISEL, AdcSpec);	// Select channel.
+	/*  Select ADC analog input channel. */
+	DEBIwrite(dev, LP_ISEL, AdcSpec);	/*  Select channel. */
 
 	for (n = 0; n < insn->n; n++) {
 
-		// Delay 10 microseconds for analog input settling.
+		/*  Delay 10 microseconds for analog input settling. */
 		comedi_udelay(10);
 
-		// Start ADC by pulsing GPIO1 low.
+		/*  Start ADC by pulsing GPIO1 low. */
 		GpioImage = RR7146(P_GPIO);
-		// Assert ADC Start command
+		/*  Assert ADC Start command */
 		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		//   and stretch it out.
+		/*    and stretch it out. */
 		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
 		WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-		// Negate ADC Start command.
+		/*  Negate ADC Start command. */
 		WR7146(P_GPIO, GpioImage | GPIO1_HI);
 
-		// Wait for ADC to complete (GPIO2 is asserted high when
-		// ADC not busy) and for data from previous conversion to
-		// shift into FB BUFFER 1 register.
+		/*  Wait for ADC to complete (GPIO2 is asserted high when */
+		/*  ADC not busy) and for data from previous conversion to */
+		/*  shift into FB BUFFER 1 register. */
 
-		// Wait for ADC done.
+		/*  Wait for ADC done. */
 		while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
 
-		// Fetch ADC data.
+		/*  Fetch ADC data. */
 		if (n != 0)
 			data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
-		// Allow the ADC to stabilize for 4 microseconds before
-		// starting the next (final) conversion.  This delay is
-		// necessary to allow sufficient time between last
-		// conversion finished and the start of the next
-		// conversion.  Without this delay, the last conversion's
-		// data value is sometimes set to the previous
-		// conversion's data value.
+		/* Allow the ADC to stabilize for 4 microseconds before
+		 * starting the next (final) conversion.  This delay is
+		 * necessary to allow sufficient time between last
+		 * conversion finished and the start of the next
+		 * conversion.  Without this delay, the last conversion's
+		 * data value is sometimes set to the previous
+		 * conversion's data value.
+		 */
 		comedi_udelay(4);
 	}
 
-	// Start a dummy conversion to cause the data from the
-	// previous conversion to be shifted in.
+	/* Start a dummy conversion to cause the data from the
+	 * previous conversion to be shifted in. */
 	GpioImage = RR7146(P_GPIO);
 
-	//Assert ADC Start command
+	/* Assert ADC Start command */
 	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	//   and stretch it out.
+	/*    and stretch it out. */
 	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
 	WR7146(P_GPIO, GpioImage & ~GPIO1_HI);
-	// Negate ADC Start command.
+	/*  Negate ADC Start command. */
 	WR7146(P_GPIO, GpioImage | GPIO1_HI);
 
-	// Wait for the data to arrive in FB BUFFER 1 register.
+	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
-	// Wait for ADC done.
+	/*  Wait for ADC done. */
 	while (!(RR7146(P_PSR) & PSR_GPIO2)) ;
 
-	// Fetch ADC data from audio interface's input shift
-	// register.
+	/*  Fetch ADC data from audio interface's input shift register. */
 
-	// Fetch ADC data.
+	/*  Fetch ADC data. */
 	if (n != 0)
 		data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
@@ -1646,7 +1656,7 @@ static int s626_ai_inttrig(comedi_device
 
 	DEBUG("s626_ai_inttrig: trigger adc start...");
 
-	// Start executing the RPS program.
+	/*  Start executing the RPS program. */
 	MC_ENABLE(P_MC1, MC1_ERPS1);
 
 	s->async->inttrig = NULL;
@@ -1672,20 +1682,20 @@ static int s626_ai_cmd(comedi_device * d
 			dev->minor);
 		return -EBUSY;
 	}
-	//disable interrupt
+	/* disable interrupt */
 	writel(0, devpriv->base_addr + P_IER);
 
-	//clear interrupt request
+	/* clear interrupt request */
 	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv->base_addr + P_ISR);
 
-	//clear any pending interrupt
+	/* clear any pending interrupt */
 	s626_dio_clear_irq(dev);
-	//  s626_enc_clear_irq(dev);
+	/*   s626_enc_clear_irq(dev); */
 
-	//reset ai_cmd_running flag
+	/* reset ai_cmd_running flag */
 	devpriv->ai_cmd_running = 0;
 
-	// test if cmd is valid
+	/*  test if cmd is valid */
 	if (cmd == NULL) {
 		DEBUG("s626_ai_cmd: NULL command\n");
 		return -EINVAL;
@@ -1707,12 +1717,12 @@ static int s626_ai_cmd(comedi_device * d
 	case TRIG_FOLLOW:
 		break;
 	case TRIG_TIMER:
-		// set a conter to generate adc trigger at scan_begin_arg interval
+		/*  set a conter to generate adc trigger at scan_begin_arg interval */
 		k = &encpriv[5];
 		tick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,
 			cmd->flags & TRIG_ROUND_MASK);
 
-		//load timer value and enable interrupt
+		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_ALWAYS);
 
@@ -1721,7 +1731,7 @@ static int s626_ai_cmd(comedi_device * d
 
 		break;
 	case TRIG_EXT:
-		// set the digital line and interrupt for scan trigger
+		/*  set the digital line and interrupt for scan trigger */
 		if (cmd->start_src != TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->scan_begin_arg);
 
@@ -1734,19 +1744,19 @@ static int s626_ai_cmd(comedi_device * d
 	case TRIG_NOW:
 		break;
 	case TRIG_TIMER:
-		// set a conter to generate adc trigger at convert_arg interval
+		/*  set a conter to generate adc trigger at convert_arg interval */
 		k = &encpriv[4];
 		tick = s626_ns_to_timer((int *)&cmd->convert_arg,
 			cmd->flags & TRIG_ROUND_MASK);
 
-		//load timer value and enable interrupt
+		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k->SetEnable(dev, k, CLKENAB_INDEX);
 
 		DEBUG("s626_ai_cmd: convert trigger timer is set with value %d\n", tick);
 		break;
 	case TRIG_EXT:
-		// set the digital line and interrupt for convert trigger
+		/*  set the digital line and interrupt for convert trigger */
 		if (cmd->scan_begin_src != TRIG_EXT
 			&& cmd->start_src == TRIG_EXT)
 			s626_dio_set_irq(dev, cmd->convert_arg);
@@ -1758,12 +1768,12 @@ static int s626_ai_cmd(comedi_device * d
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		// data arrives as one packet
+		/*  data arrives as one packet */
 		devpriv->ai_sample_count = cmd->stop_arg;
 		devpriv->ai_continous = 0;
 		break;
 	case TRIG_NONE:
-		// continous aquisition
+		/*  continous aquisition */
 		devpriv->ai_continous = 1;
 		devpriv->ai_sample_count = 0;
 		break;
@@ -1773,17 +1783,17 @@ static int s626_ai_cmd(comedi_device * d
 
 	switch (cmd->start_src) {
 	case TRIG_NOW:
-		// Trigger ADC scan loop start by setting RPS Signal 0.
-		// MC_ENABLE( P_MC2, MC2_ADC_RPS );
+		/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+		/*  MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
-		// Start executing the RPS program.
+		/*  Start executing the RPS program. */
 		MC_ENABLE(P_MC1, MC1_ERPS1);
 
 		DEBUG("s626_ai_cmd: ADC triggered\n");
 		s->async->inttrig = NULL;
 		break;
 	case TRIG_EXT:
-		//configure DIO channel for acquisition trigger
+		/* configure DIO channel for acquisition trigger */
 		s626_dio_set_irq(dev, cmd->start_arg);
 
 		DEBUG("s626_ai_cmd: External start trigger is set!!!\n");
@@ -1795,7 +1805,7 @@ static int s626_ai_cmd(comedi_device * d
 		break;
 	}
 
-	//enable interrupt
+	/* enable interrupt */
 	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER);
 
 	DEBUG("s626_ai_cmd: command function terminated\n");
@@ -1990,10 +2000,10 @@ static int s626_ai_cmdtest(comedi_device
 
 static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 {
-	// Stop RPS program in case it is currently running.
+	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
 
-	//disable master interrupt
+	/* disable master interrupt */
 	writel(0, devpriv->base_addr + P_IER);
 
 	devpriv->ai_cmd_running = 0;
@@ -2010,7 +2020,7 @@ static int s626_ns_to_timer(int *nanosec
 {
 	int divider, base;
 
-	base = 500;		//2MHz internal clock
+	base = 500;		/* 2MHz internal clock */
 
 	switch (round_mode) {
 	case TRIG_ROUND_NEAREST:
@@ -2060,33 +2070,31 @@ static int s626_ao_rinsn(comedi_device *
 	return i;
 }
 
-/////////////////////////////////////////////////////////////////////
-///////////////  DIGITAL I/O FUNCTIONS  /////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// All DIO functions address a group of DIO channels by means of
-// "group" argument.  group may be 0, 1 or 2, which correspond to DIO
-// ports A, B and C, respectively.
-/////////////////////////////////////////////////////////////////////
+/* *************** DIGITAL I/O FUNCTIONS ***************
+ * All DIO functions address a group of DIO channels by means of
+ * "group" argument.  group may be 0, 1 or 2, which correspond to DIO
+ * ports A, B and C, respectively.
+ */
 
 static void s626_dio_init(comedi_device * dev)
 {
 	uint16_t group;
 	comedi_subdevice *s;
 
-	// Prepare to treat writes to WRCapSel as capture disables.
+	/*  Prepare to treat writes to WRCapSel as capture disables. */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	// For each group of sixteen channels ...
+	/*  For each group of sixteen channels ... */
 	for (group = 0; group < S626_DIO_BANKS; group++) {
 		s = dev->subdevices + 2 + group;
-		DEBIwrite(dev, diopriv->WRIntSel, 0);	// Disable all interrupts.
-		DEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);	// Disable all event
-		// captures.
-		DEBIwrite(dev, diopriv->WREdgSel, 0);	// Init all DIOs to
-		// default edge
-		// polarity.
-		DEBIwrite(dev, diopriv->WRDOut, 0);	// Program all outputs
-		// to inactive state.
+		DEBIwrite(dev, diopriv->WRIntSel, 0);	/*  Disable all interrupts. */
+		DEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);	/*  Disable all event */
+		/*  captures. */
+		DEBIwrite(dev, diopriv->WREdgSel, 0);	/*  Init all DIOs to */
+		/*  default edge */
+		/*  polarity. */
+		DEBIwrite(dev, diopriv->WRDOut, 0);	/*  Program all outputs */
+		/*  to inactive state. */
 	}
 	DEBUG("s626_dio_init: DIO initialized \n");
 }
@@ -2166,13 +2174,13 @@ static int s626_dio_set_irq(comedi_devic
 	unsigned int bitmask;
 	unsigned int status;
 
-	//select dio bank
+	/* select dio bank */
 	group = chan / 16;
 	bitmask = 1 << (chan - (16 * group));
 	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
 		chan - (16 * group), group);
 
-	//set channel to capture positive edge
+	/* set channel to capture positive edge */
 	status = DEBIread(dev,
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDEdgSel);
@@ -2180,7 +2188,7 @@ static int s626_dio_set_irq(comedi_devic
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->WREdgSel, bitmask | status);
 
-	//enable interrupt on selected channel
+	/* enable interrupt on selected channel */
 	status = DEBIread(dev,
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDIntSel);
@@ -2188,10 +2196,10 @@ static int s626_dio_set_irq(comedi_devic
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->WRIntSel, bitmask | status);
 
-	//enable edge capture write command
+	/* enable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
 
-	//enable edge capture on selected channel
+	/* enable edge capture on selected channel */
 	status = DEBIread(dev,
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->RDCapSel);
@@ -2207,10 +2215,10 @@ static int s626_dio_reset_irq(comedi_dev
 {
 	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
 
-	//disable edge capture write command
+	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	//enable edge capture on selected channel
+	/* enable edge capture on selected channel */
 	DEBIwrite(dev,
 		((dio_private *) (dev->subdevices + 2 +
 				group)->private)->WRCapSel, mask);
@@ -2222,11 +2230,11 @@ static int s626_dio_clear_irq(comedi_dev
 {
 	unsigned int group;
 
-	//disable edge capture write command
+	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	for (group = 0; group < S626_DIO_BANKS; group++) {
-		//clear pending events and interrupt
+		/* clear pending events and interrupt */
 		DEBIwrite(dev,
 			((dio_private *) (dev->subdevices + 2 +
 					group)->private)->WRCapSel, 0xffff);
@@ -2241,23 +2249,23 @@ static int s626_dio_clear_irq(comedi_dev
 static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, lsampl_t * data)
 {
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_COUNTER << BF_CLKSRC) |	// Operating mode is Counter.
-		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
-		//( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down.
-		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is Counter. */
+		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+		/* ( CNTDIR_UP << BF_CLKPOL ) |      // Count direction is Down. */
+		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
 		(CLKENAB_INDEX << BF_CLKENAB);
 	/*   uint16_t DisableIntSrc=TRUE; */
-	// uint32_t Preloadvalue;              //Counter initial value
+	/*  uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t valueSrclatch = LATCHSRC_AB_READ;
 	uint16_t enab = CLKENAB_ALWAYS;
 	enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];
 
 	DEBUG("s626_enc_insn_config: encoder config\n");
 
-	//  (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]);
+	/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
 	k->SetMode(dev, k, Setup, TRUE);
 	Preload(dev, k, *(insn->data));
@@ -2295,11 +2303,11 @@ static int s626_enc_insn_write(comedi_de
 	DEBUG("s626_enc_insn_write: encoder write channel %d \n",
 		CR_CHAN(insn->chanspec));
 
-	// Set the preload register
+	/*  Set the preload register */
 	Preload(dev, k, data[0]);
 
-	// Software index pulse forces the preload register to load
-	// into the counter
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
 	k->SetLoadTrig(dev, k, 0);
 	k->PulseIndex(dev, k);
 	k->SetLoadTrig(dev, k, 2);
@@ -2311,50 +2319,47 @@ static int s626_enc_insn_write(comedi_de
 
 static void s626_timer_load(comedi_device * dev, enc_private * k, int tick)
 {
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_TIMER << BF_CLKSRC) |	// Operating mode is Timer.
-		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
-		(CNTDIR_DOWN << BF_CLKPOL) |	// Count direction is Down.
-		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_TIMER << BF_CLKSRC) |	/*  Operating mode is Timer. */
+		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+		(CNTDIR_DOWN << BF_CLKPOL) |	/*  Count direction is Down. */
+		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
 		(CLKENAB_INDEX << BF_CLKENAB);
 	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
-	//  uint16_t enab=CLKENAB_ALWAYS;
+	/*   uint16_t enab=CLKENAB_ALWAYS; */
 
 	k->SetMode(dev, k, Setup, FALSE);
 
-	// Set the preload register
+	/*  Set the preload register */
 	Preload(dev, k, tick);
 
-	// Software index pulse forces the preload register to load
-	// into the counter
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
 	k->SetLoadTrig(dev, k, 0);
 	k->PulseIndex(dev, k);
 
-	//set reload on counter overflow
+	/* set reload on counter overflow */
 	k->SetLoadTrig(dev, k, 1);
 
-	//set interrupt on overflow
+	/* set interrupt on overflow */
 	k->SetIntSrc(dev, k, INTSRC_OVER);
 
 	SetLatchSource(dev, k, valueSrclatch);
-	//  k->SetEnable(dev,k,(uint16_t)(enab != 0));
+	/*   k->SetEnable(dev,k,(uint16_t)(enab != 0)); */
 }
 
-///////////////////////////////////////////////////////////////////////
-/////////////////////  DAC FUNCTIONS /////////////////////////////////
-///////////////////////////////////////////////////////////////////////
+/* ***********  DAC FUNCTIONS *********** */
 
-// Slot 0 base settings.
-#define VECT0	( XSD2 | RSD3 | SIB_A2 )	// Slot 0 always shifts in
-					 // 0xFF and store it to
-					 // FB_BUFFER2.
+/*  Slot 0 base settings. */
+#define VECT0	( XSD2 | RSD3 | SIB_A2 )
+/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
-// TrimDac LogicalChan-to-PhysicalChan mapping table.
+/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
 static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
-// TrimDac LogicalChan-to-EepromAdrs mapping table.
+/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
 static uint8_t trimadrs[] =
 	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
@@ -2362,7 +2367,7 @@ static void LoadTrimDACs(comedi_device *
 {
 	register uint8_t i;
 
-	// Copy TrimDac setpoint values from EEPROM to TrimDacs.
+	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
 	for (i = 0; i < (sizeof(trimchan) / sizeof(trimchan[0])); i++)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
@@ -2372,112 +2377,105 @@ static void WriteTrimDAC(comedi_device *
 {
 	uint32_t chan;
 
-	// Save the new setpoint in case the application needs to read it back later.
+	/*  Save the new setpoint in case the application needs to read it back later. */
 	devpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;
 
-	// Map logical channel number to physical channel number.
+	/*  Map logical channel number to physical channel number. */
 	chan = (uint32_t) trimchan[LogicalChan];
 
-	// Set up TSL2 records for TrimDac write operation.  All slots shift
-	// 0xFF in from pulled-up SD3 so that the end of the slot sequence
-	// can be detected.
-	SETVECT(2, XSD2 | XFIFO_1 | WS3);	// Slot 2: Send high uint8_t
-	// to target TrimDac.
-	SETVECT(3, XSD2 | XFIFO_0 | WS3);	// Slot 3: Send low uint8_t to
-	// target TrimDac.
-	SETVECT(4, XSD2 | XFIFO_3 | WS1);	// Slot 4: Send NOP high
-	// uint8_t to DAC0 to keep
-	// clock running.
-	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);	// Slot 5: Send NOP low
-	// uint8_t to DAC0.
-
-	// Construct and transmit target DAC's serial packet: ( 0000 AAAA
-	// ),( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the DAC
-	// channel's address, and D<7:0> is the DAC setpoint.  Append a WORD
-	// value (that writes a channel 0 NOP command to a non-existent main
-	// DAC channel) that serves to keep the clock running after the
-	// packet has been sent to the target DAC.
-
-	SendDAC(dev, ((uint32_t) chan << 8)	// Address the DAC channel
-		// within the trimdac device.
-		| (uint32_t) DacData);	// Include DAC setpoint data.
-}
-
-/////////////////////////////////////////////////////////////////////////
-////////////////  EEPROM ACCESS FUNCTIONS  //////////////////////////////
-/////////////////////////////////////////////////////////////////////////
+	/* Set up TSL2 records for TrimDac write operation.  All slots shift
+	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence
+	 * can be detected.
+	 */
 
-///////////////////////////////////////////
-// Read uint8_t from EEPROM.
+	SETVECT(2, XSD2 | XFIFO_1 | WS3);
+	/* Slot 2: Send high uint8_t to target TrimDac. */
+	SETVECT(3, XSD2 | XFIFO_0 | WS3);
+	/* Slot 3: Send low uint8_t to target TrimDac. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS1);
+	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */
+	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);
+	/* Slot 5: Send NOP low  uint8_t to DAC0. */
+
+	/* Construct and transmit target DAC's serial packet:
+	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A<3:0> is the
+	 * DAC channel's address, and D<7:0> is the DAC setpoint.  Append a
+	 * WORD value (that writes a channel 0 NOP command to a non-existent
+	 * main DAC channel) that serves to keep the clock running after the
+	 * packet has been sent to the target DAC.
+	 */
+
+	/*  Address the DAC channel within the trimdac device. */
+	SendDAC(dev, ((uint32_t) chan << 8)
+		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
+}
+
+/* **************  EEPROM ACCESS FUNCTIONS  ************** */
+/*  Read uint8_t from EEPROM. */
 
 static uint8_t I2Cread(comedi_device * dev, uint8_t addr)
 {
 	uint8_t rtnval;
 
-	// Send EEPROM target address.
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)	// Byte2 = I2C
-			// command:
-			// write to
-			// I2C EEPROM
-			// device.
-			| I2C_B1(I2C_ATTRSTOP, addr)	// Byte1 = EEPROM
-			// internal target
-			// address.
-			| I2C_B0(I2C_ATTRNOP, 0)))	// Byte0 = Not
-		// sent.
+	/*  Send EEPROM target address. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
+			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
+			| I2C_B1(I2C_ATTRSTOP, addr)
+			 /* Byte1 = EEPROM internal target address. */
+			| I2C_B0(I2C_ATTRNOP, 0)))	/*  Byte0 = Not sent. */
 	{
-		// Abort function and declare error if handshake failed.
+		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread  a\n");
 		return 0;
 	}
-	// Execute EEPROM read.
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	// Byte2 = I2C
-			// command: read
-			// from I2C EEPROM
-			// device.
-			| I2C_B1(I2C_ATTRSTOP, 0)	// Byte1 receives
-			// uint8_t from
-			// EEPROM.
-			| I2C_B0(I2C_ATTRNOP, 0)))	// Byte0 = Not
-		// sent.
+	/*  Execute EEPROM read. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	/*  Byte2 = I2C */
+			/*  command: read */
+			/*  from I2C EEPROM */
+			/*  device. */
+			| I2C_B1(I2C_ATTRSTOP, 0)	/*  Byte1 receives */
+			/*  uint8_t from */
+			/*  EEPROM. */
+			| I2C_B0(I2C_ATTRNOP, 0)))	/*  Byte0 = Not */
+		/*  sent. */
 	{
-		// Abort function and declare error if handshake failed.
+		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread b\n");
 		return 0;
 	}
-	// Return copy of EEPROM value.
+	/*  Return copy of EEPROM value. */
 	rtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);
 	return rtnval;
 }
 
 static uint32_t I2Chandshake(comedi_device * dev, uint32_t val)
 {
-	// Write I2C command to I2C Transfer Control shadow register.
+	/*  Write I2C command to I2C Transfer Control shadow register. */
 	WR7146(P_I2CCTRL, val);
 
-	// Upload I2C shadow registers into working registers and wait for
-	// upload confirmation.
+	/*  Upload I2C shadow registers into working registers and wait for */
+	/*  upload confirmation. */
 
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 	while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
 
-	// Wait until I2C bus transfer is finished or an error occurs.
+	/*  Wait until I2C bus transfer is finished or an error occurs. */
 	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY) ;
 
-	// Return non-zero if I2C error occured.
+	/*  Return non-zero if I2C error occured. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
 
 }
 
-// Private helper function: Write setpoint to an application DAC channel.
+/*  Private helper function: Write setpoint to an application DAC channel. */
 
 static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
 {
 	register uint16_t signmask;
 	register uint32_t WSImage;
 
-	// Adjust DAC data polarity and set up Polarity Control Register
-	// image.
+	/*  Adjust DAC data polarity and set up Polarity Control Register */
+	/*  image. */
 	signmask = 1 << chan;
 	if (dacdata < 0) {
 		dacdata = -dacdata;
@@ -2485,234 +2483,243 @@ static void SetDAC(comedi_device * dev, 
 	} else
 		devpriv->Dacpol &= ~signmask;
 
-	// Limit DAC setpoint value to valid range.
+	/*  Limit DAC setpoint value to valid range. */
 	if ((uint16_t) dacdata > 0x1FFF)
 		dacdata = 0x1FFF;
 
-	// Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
-	// and V3 transmit the setpoint to the target DAC.  V4 and V5 send
-	// data to a non-existent TrimDac channel just to keep the clock
-	// running after sending data to the target DAC.  This is necessary
-	// to eliminate the clock glitch that would otherwise occur at the
-	// end of the target DAC's serial data stream.  When the sequence
-	// restarts at V0 (after executing V5), the gate array automatically
-	// disables gating for the DAC clock and all DAC chip selects.
-	WSImage = (chan & 2) ? WS1 : WS2;	// Choose DAC chip select to
-	// be asserted.
-	SETVECT(2, XSD2 | XFIFO_1 | WSImage);	// Slot 2: Transmit high
-	// data byte to target DAC.
-	SETVECT(3, XSD2 | XFIFO_0 | WSImage);	// Slot 3: Transmit low data
-	// byte to target DAC.
-	SETVECT(4, XSD2 | XFIFO_3 | WS3);	// Slot 4: Transmit to
-	// non-existent TrimDac
-	// channel to keep clock
-	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);	// Slot 5: running after
-	// writing target DAC's
-	// low data byte.
-
-	// Construct and transmit target DAC's serial packet: ( A10D DDDD
-	// ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>, and D<12:0>
-	// is the DAC setpoint.  Append a WORD value (that writes to a
-	// non-existent TrimDac channel) that serves to keep the clock
-	// running after the packet has been sent to the target DAC.
-	SendDAC(dev, 0x0F000000	//Continue clock after target DAC
-		//data (write to non-existent
-		//trimdac).
-		| 0x00004000	// Address the two main dual-DAC
-		// devices (TSL's chip select enables
-		// target device).
-		| ((uint32_t) (chan & 1) << 15)	// Address the DAC
-		// channel within the
-		// device.
-		| (uint32_t) dacdata);	// Include DAC setpoint data.
+	/* Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
+	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send
+	 * data to a non-existent TrimDac channel just to keep the clock
+	 * running after sending data to the target DAC.  This is necessary
+	 * to eliminate the clock glitch that would otherwise occur at the
+	 * end of the target DAC's serial data stream.  When the sequence
+	 * restarts at V0 (after executing V5), the gate array automatically
+	 * disables gating for the DAC clock and all DAC chip selects.
+	 */
+
+	WSImage = (chan & 2) ? WS1 : WS2;
+	/* Choose DAC chip select to be asserted. */
+	SETVECT(2, XSD2 | XFIFO_1 | WSImage);
+	/* Slot 2: Transmit high data byte to target DAC. */
+	SETVECT(3, XSD2 | XFIFO_0 | WSImage);
+	/* Slot 3: Transmit low data byte to target DAC. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS3);
+	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
+	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);
+	/* Slot 5: running after writing target DAC's low data byte. */
+
+	/*  Construct and transmit target DAC's serial packet:
+	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan<0>,
+	 * and D<12:0> is the DAC setpoint.  Append a WORD value (that writes
+	 * to a  non-existent TrimDac channel) that serves to keep the clock
+	 * running after the packet has been sent to the target DAC.
+	 */
+	SendDAC(dev, 0x0F000000
+		/* Continue clock after target DAC data (write to non-existent trimdac). */
+		| 0x00004000
+		/* Address the two main dual-DAC devices (TSL's chip select enables
+		 * target device). */
+		| ((uint32_t) (chan & 1) << 15)
+		/*  Address the DAC channel within the  device. */
+		| (uint32_t) dacdata);	/*  Include DAC setpoint data. */
 
 }
 
-////////////////////////////////////////////////////////
-// Private helper function: Transmit serial data to DAC via Audio
-// channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
-// Dacpol contains valid target image.
+/* Private helper function: Transmit serial data to DAC via Audio
+ * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
+ * Dacpol contains valid target image.
+ */
 
 static void SendDAC(comedi_device * dev, uint32_t val)
 {
 
-	// START THE SERIAL CLOCK RUNNING -------------
+	/* START THE SERIAL CLOCK RUNNING ------------- */
 
-	// Assert DAC polarity control and enable gating of DAC serial clock
-	// and audio bit stream signals.  At this point in time we must be
-	// assured of being in time slot 0.  If we are not in slot 0, the
-	// serial clock and audio stream signals will be disabled; this is
-	// because the following DEBIwrite statement (which enables signals
-	// to be passed through the gate array) would execute before the
-	// trailing edge of WS1/WS3 (which turns off the signals), thus
-	// causing the signals to be inactive during the DAC write.
+	/* Assert DAC polarity control and enable gating of DAC serial clock
+	 * and audio bit stream signals.  At this point in time we must be
+	 * assured of being in time slot 0.  If we are not in slot 0, the
+	 * serial clock and audio stream signals will be disabled; this is
+	 * because the following DEBIwrite statement (which enables signals
+	 * to be passed through the gate array) would execute before the
+	 * trailing edge of WS1/WS3 (which turns off the signals), thus
+	 * causing the signals to be inactive during the DAC write.
+	 */
 	DEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);
 
-	// TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ----------------
+	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
-	// Copy DAC setpoint value to DAC's output DMA buffer.
+	/* Copy DAC setpoint value to DAC's output DMA buffer. */
 
-	//WR7146( (uint32_t)devpriv->pDacWBuf, val );
+	/* WR7146( (uint32_t)devpriv->pDacWBuf, val ); */
 	*devpriv->pDacWBuf = val;
 
-	// enab the output DMA transfer.  This will cause the DMAC to copy
-	// the DAC's data value to A2's output FIFO.  The DMA transfer will
-	// then immediately terminate because the protection address is
-	// reached upon transfer of the first DWORD value.
+	/* enab the output DMA transfer.  This will cause the DMAC to copy
+	 * the DAC's data value to A2's output FIFO.  The DMA transfer will
+	 * then immediately terminate because the protection address is
+	 * reached upon transfer of the first DWORD value.
+	 */
 	MC_ENABLE(P_MC1, MC1_A2OUT);
 
-	// While the DMA transfer is executing ...
+	/*  While the DMA transfer is executing ... */
 
-	// Reset Audio2 output FIFO's underflow flag (along with any other
-	// FIFO underflow/overflow flags).  When set, this flag will
-	// indicate that we have emerged from slot 0.
+	/* Reset Audio2 output FIFO's underflow flag (along with any other
+	 * FIFO underflow/overflow flags).  When set, this flag will
+	 * indicate that we have emerged from slot 0.
+	 */
 	WR7146(P_ISR, ISR_AFOU);
 
-	// Wait for the DMA transfer to finish so that there will be data
-	// available in the FIFO when time slot 1 tries to transfer a DWORD
-	// from the FIFO to the output buffer register.  We test for DMA
-	// Done by polling the DMAC enable flag; this flag is automatically
-	// cleared when the transfer has finished.
+	/* Wait for the DMA transfer to finish so that there will be data
+	 * available in the FIFO when time slot 1 tries to transfer a DWORD
+	 * from the FIFO to the output buffer register.  We test for DMA
+	 * Done by polling the DMAC enable flag; this flag is automatically
+	 * cleared when the transfer has finished.
+	 */
 	while ((RR7146(P_MC1) & MC1_A2OUT) != 0) ;
 
-	// START THE OUTPUT STREAM TO THE TARGET DAC --------------------
+	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
-	// FIFO data is now available, so we enable execution of time slots
-	// 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
-	// will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
-	// detection.
+	/* FIFO data is now available, so we enable execution of time slots
+	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
+	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
+	 * detection.
+	 */
 	SETVECT(0, XSD2 | RSD3 | SIB_A2);
 
-	// Wait for slot 1 to execute to ensure that the Packet will be
-	// transmitted.  This is detected by polling the Audio2 output FIFO
-	// underflow flag, which will be set when slot 1 execution has
-	// finished transferring the DAC's data DWORD from the output FIFO
-	// to the output buffer register.
+	/* Wait for slot 1 to execute to ensure that the Packet will be
+	 * transmitted.  This is detected by polling the Audio2 output FIFO
+	 * underflow flag, which will be set when slot 1 execution has
+	 * finished transferring the DAC's data DWORD from the output FIFO
+	 * to the output buffer register.
+	 */
 	while ((RR7146(P_SSR) & SSR_AF2_OUT) == 0) ;
 
-	// Set up to trap execution at slot 0 when the TSL sequencer cycles
-	// back to slot 0 after executing the EOS in slot 5.  Also,
-	// simultaneously shift out and in the 0x00 that is ALWAYS the value
-	// stored in the last byte to be shifted out of the FIFO's DWORD
-	// buffer register.
+	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
+	 * back to slot 0 after executing the EOS in slot 5.  Also,
+	 * simultaneously shift out and in the 0x00 that is ALWAYS the value
+	 * stored in the last byte to be shifted out of the FIFO's DWORD
+	 * buffer register.
+	 */
 	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
 
-	// WAIT FOR THE TRANSACTION TO FINISH -----------------------
+	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
 
-	// Wait for the TSL to finish executing all time slots before
-	// exiting this function.  We must do this so that the next DAC
-	// write doesn't start, thereby enabling clock/chip select signals:
-	// 1. Before the TSL sequence cycles back to slot 0, which disables
-	// the clock/cs signal gating and traps slot // list execution.  If
-	// we have not yet finished slot 5 then the clock/cs signals are
-	// still gated and we have // not finished transmitting the stream.
-	// 2. While slots 2-5 are executing due to a late slot 0 trap.  In
-	// this case, the slot sequence is currently // repeating, but with
-	// clock/cs signals disabled.  We must wait for slot 0 to trap
-	// execution before setting // up the next DAC setpoint DMA transfer
-	// and enabling the clock/cs signals.  To detect the end of slot 5,
-	// we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
-	// the TSL has not yet finished executing slot 5 ...
+	/* Wait for the TSL to finish executing all time slots before
+	 * exiting this function.  We must do this so that the next DAC
+	 * write doesn't start, thereby enabling clock/chip select signals:
+	 *
+	 * 1. Before the TSL sequence cycles back to slot 0, which disables
+	 *    the clock/cs signal gating and traps slot // list execution.
+	 *    we have not yet finished slot 5 then the clock/cs signals are
+	 *    still gated and we have not finished transmitting the stream.
+	 *
+	 * 2. While slots 2-5 are executing due to a late slot 0 trap.  In
+	 *    this case, the slot sequence is currently repeating, but with
+	 *    clock/cs signals disabled.  We must wait for slot 0 to trap
+	 *    execution before setting up the next DAC setpoint DMA transfer
+	 *    and enabling the clock/cs signals.  To detect the end of slot 5,
+	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
+	 *    the TSL has not yet finished executing slot 5 ...
+	 */
 	if ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {
-		// The trap was set on time and we are still executing somewhere
-		// in slots 2-5, so we now wait for slot 0 to execute and trap
-		// TSL execution.  This is detected when FB_BUFFER2 MSB changes
-		// from 0xFF to 0x00, which slot 0 causes to happen by shifting
-		// out/in on SD2 the 0x00 that is always referenced by slot 5.
-		while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
-	}
-	// Either (1) we were too late setting the slot 0 trap; the TSL
-	// sequencer restarted slot 0 before we could set the EOS trap flag,
-	// or (2) we were not late and execution is now trapped at slot 0.
-	// In either case, we must now change slot 0 so that it will store
-	// value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
-	// In order to do this, we reprogram slot 0 so that it will shift in
-	// SD3, which is driven only by a pull-up resistor.
+		/* The trap was set on time and we are still executing somewhere
+		 * in slots 2-5, so we now wait for slot 0 to execute and trap
+		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
+		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
+		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
+		 */
+		 while ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) ;
+	}
+	/* Either (1) we were too late setting the slot 0 trap; the TSL
+	 * sequencer restarted slot 0 before we could set the EOS trap flag,
+	 * or (2) we were not late and execution is now trapped at slot 0.
+	 * In either case, we must now change slot 0 so that it will store
+	 * value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
+	 * In order to do this, we reprogram slot 0 so that it will shift in
+	 * SD3, which is driven only by a pull-up resistor.
+	 */
 	SETVECT(0, RSD3 | SIB_A2 | EOS);
 
-	// Wait for slot 0 to execute, at which time the TSL is setup for
-	// the next DAC write.  This is detected when FB_BUFFER2 MSB changes
-	// from 0x00 to 0xFF.
+	/* Wait for slot 0 to execute, at which time the TSL is setup for
+	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
+	 * from 0x00 to 0xFF.
+	 */
 	while ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0) ;
 }
 
 static void WriteMISC2(comedi_device * dev, uint16_t NewImage)
 {
-	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	// enab writes to
-	// MISC2 register.
-	DEBIwrite(dev, LP_WRMISC2, NewImage);	// Write new image to MISC2.
-	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	// Disable writes to MISC2.
+	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
+	/*  MISC2 register. */
+	DEBIwrite(dev, LP_WRMISC2, NewImage);	/*  Write new image to MISC2. */
+	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	/*  Disable writes to MISC2. */
 }
 
-/////////////////////////////////////////////////////////////////////
-// Initialize the DEBI interface for all transfers.
+/*  Initialize the DEBI interface for all transfers. */
 
 static uint16_t DEBIread(comedi_device * dev, uint16_t addr)
 {
 	uint16_t retval;
 
-	// Set up DEBI control register value in shadow RAM.
+	/*  Set up DEBI control register value in shadow RAM. */
 	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
 
-	// Execute the DEBI transfer.
+	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
 
-	// Fetch target register value.
+	/*  Fetch target register value. */
 	retval = (uint16_t) RR7146(P_DEBIAD);
 
-	// Return register value.
+	/*  Return register value. */
 	return retval;
 }
 
-// Execute a DEBI transfer.  This must be called from within a
-// critical section.
+/*  Execute a DEBI transfer.  This must be called from within a */
+/*  critical section. */
 static void DEBItransfer(comedi_device * dev)
 {
-	// Initiate upload of shadow RAM to DEBI control register.
+	/*  Initiate upload of shadow RAM to DEBI control register. */
 	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
 
-	// Wait for completion of upload from shadow RAM to DEBI control
-	// register.
+	/*  Wait for completion of upload from shadow RAM to DEBI control */
+	/*  register. */
 	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI)) ;
 
-	// Wait until DEBI transfer is done.
+	/*  Wait until DEBI transfer is done. */
 	while (RR7146(P_PSR) & PSR_DEBI_S) ;
 }
 
-// Write a value to a gate array register.
+/*  Write a value to a gate array register. */
 static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata)
 {
 
-	// Set up DEBI control register value in shadow RAM.
+	/*  Set up DEBI control register value in shadow RAM. */
 	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
 	WR7146(P_DEBIAD, wdata);
 
-	// Execute the DEBI transfer.
+	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
 }
 
-/////////////////////////////////////////////////////////////////////////////
-// Replace the specified bits in a gate array register.  Imports: mask
-// specifies bits that are to be preserved, wdata is new value to be
-// or'd with the masked original.
+/* Replace the specified bits in a gate array register.  Imports: mask
+ * specifies bits that are to be preserved, wdata is new value to be
+ * or'd with the masked original.
+ */
 static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata)
 {
 
-	// Copy target gate array register into P_DEBIAD register.
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);	// Set up DEBI control
-	// reg value in shadow
-	// RAM.
-	DEBItransfer(dev);	// Execute the DEBI
-	// Read transfer.
-
-	// Write back the modified image.
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);	// Set up DEBI control
-	// reg value in shadow
-	// RAM.
+	/*  Copy target gate array register into P_DEBIAD register. */
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+	/* Set up DEBI control reg value in shadow RAM. */
+	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
 
-	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));	// Modify the register image.
-	DEBItransfer(dev);	// Execute the DEBI Write transfer.
+	/*  Write back the modified image. */
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
+	/* Set up DEBI control reg value in shadow  RAM. */
+
+	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));
+	/* Modify the register image. */
+	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
 static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
@@ -2723,7 +2730,7 @@ static void CloseDMAB(comedi_device * de
 	DEBUG("CloseDMAB: Entering S626DRV_CloseDMAB():\n");
 	if (pdma == NULL)
 		return;
-	//find the matching allocation from the board struct
+	/* find the matching allocation from the board struct */
 
 	vbptr = pdma->LogicalBase;
 	vpptr = pdma->PhysicalBase;
@@ -2737,44 +2744,37 @@ static void CloseDMAB(comedi_device * de
 	}
 }
 
-////////////////////////////////////////////////////////////////////////
-/////////////////  COUNTER FUNCTIONS  //////////////////////////////////
-////////////////////////////////////////////////////////////////////////
-// All counter functions address a specific counter by means of the
-// "Counter" argument, which is a logical counter number.  The Counter
-// argument may have any of the following legal values: 0=0A, 1=1A,
-// 2=2A, 3=0B, 4=1B, 5=2B.
-////////////////////////////////////////////////////////////////////////
-
-// Forward declarations for functions that are common to both A and B
-// counters:
-
-/////////////////////////////////////////////////////////////////////
-//////////////////// PRIVATE COUNTER FUNCTIONS  /////////////////////
-/////////////////////////////////////////////////////////////////////
+/* ******  COUNTER FUNCTIONS  ******* */
+/* All counter functions address a specific counter by means of the
+ * "Counter" argument, which is a logical counter number.  The Counter
+ * argument may have any of the following legal values: 0=0A, 1=1A,
+ * 2=2A, 3=0B, 4=1B, 5=2B.
+ */
+
+/* Forward declarations for functions that are common to both A and B counters: */
+
+/* ******  PRIVATE COUNTER FUNCTIONS ****** */
 
-/////////////////////////////////////////////////////////////////
-// Read a counter's output latch.
+/*  Read a counter's output latch. */
 
 static uint32_t ReadLatch(comedi_device * dev, enc_private * k)
 {
 	register uint32_t value;
-	//DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n");
+	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
 
-	// Latch counts and fetch LSW of latched counts value.
+	/*  Latch counts and fetch LSW of latched counts value. */
 	value = (uint32_t) DEBIread(dev, k->MyLatchLsw);
 
-	// Fetch MSW of latched counts and combine with LSW.
+	/*  Fetch MSW of latched counts and combine with LSW. */
 	value |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);
 
-	// DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n");
+	/*  DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n"); */
 
-	// Return latched counts.
+	/*  Return latched counts. */
 	return value;
 }
 
-///////////////////////////////////////////////////////////////////
-// Reset a counter's index and overflow event capture flags.
+/*  Reset a counter's index and overflow event capture flags. */
 
 static void ResetCapFlags_A(comedi_device * dev, enc_private * k)
 {
@@ -2788,9 +2788,8 @@ static void ResetCapFlags_B(comedi_devic
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
-/////////////////////////////////////////////////////////////////////////
-// Return counter setup in a format (COUNTER_SETUP) that is consistent
-// for both A and B counters.
+/*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
+/*  for both A and B counters. */
 
 static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
 {
@@ -2798,35 +2797,35 @@ static uint16_t GetMode_A(comedi_device 
 	register uint16_t crb;
 	register uint16_t setup;
 
-	// Fetch CRA and CRB register images.
+	/*  Fetch CRA and CRB register images. */
 	cra = DEBIread(dev, k->MyCRA);
 	crb = DEBIread(dev, k->MyCRB);
 
-	// Populate the standardized counter setup bit fields.  Note:
-	// IndexSrc is restricted to ENC_X or IndxPol.
-	setup = ((cra & STDMSK_LOADSRC)	// LoadSrc  = LoadSrcA.
-		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	// LatchSrc = LatchSrcA.
-		| ((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	// IntSrc   = IntSrcA.
-		| ((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	// IndxSrc  = IndxSrcA<1>.
-		| ((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	// IndxPol  = IndxPolA.
-		| ((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	// ClkEnab  = ClkEnabA.
-
-	// Adjust mode-dependent parameters.
-	if (cra & (2 << CRABIT_CLKSRC_A))	// If Timer mode (ClkSrcA<1> == 1):
-		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| ((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	//   Set ClkPol to indicate count direction (ClkSrcA<0>).
-			| (MULT_X1 << STDBIT_CLKMULT));	//   ClkMult must be 1x in Timer mode.
-
-	else			// If Counter mode (ClkSrcA<1> == 0):
-		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	//   Indicate Counter mode.
-			| ((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	//   Pass through ClkPol.
-			| (((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	//   Force ClkMult to 1x if not legal, else pass through.
+	/*  Populate the standardized counter setup bit fields.  Note: */
+	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	setup = ((cra & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcA. */
+		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
+		| ((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
+		| ((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA<1>. */
+		| ((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
+		| ((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
+
+	/*  Adjust mode-dependent parameters. */
+	if (cra & (2 << CRABIT_CLKSRC_A))	/*  If Timer mode (ClkSrcA<1> == 1): */
+		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| ((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA<0>). */
+			| (MULT_X1 << STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
+
+	else			/*  If Counter mode (ClkSrcA<1> == 0): */
+		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Counter mode. */
+			| ((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)	/*    Pass through ClkPol. */
+			| (((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
 				(MULT_X1 << STDBIT_CLKMULT) :
 				((cra >> (CRABIT_CLKMULT_A -
 							STDBIT_CLKMULT)) &
 					STDMSK_CLKMULT)));
 
-	// Return adjusted counter setup.
+	/*  Return adjusted counter setup. */
 	return setup;
 }
 
@@ -2836,98 +2835,99 @@ static uint16_t GetMode_B(comedi_device 
 	register uint16_t crb;
 	register uint16_t setup;
 
-	// Fetch CRA and CRB register images.
+	/*  Fetch CRA and CRB register images. */
 	cra = DEBIread(dev, k->MyCRA);
 	crb = DEBIread(dev, k->MyCRB);
 
-	// Populate the standardized counter setup bit fields.  Note:
-	// IndexSrc is restricted to ENC_X or IndxPol.
-	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	// IntSrc   = IntSrcB.
-		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	// LatchSrc = LatchSrcB.
-		| ((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	// LoadSrc  = LoadSrcB.
-		| ((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	// IndxPol  = IndxPolB.
-		| ((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	// ClkEnab  = ClkEnabB.
-		| ((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	// IndxSrc  = IndxSrcB<1>.
-
-	// Adjust mode-dependent parameters.
-	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	// If Extender mode (ClkMultB == MULT_X0):
-		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	//   Indicate Extender mode.
-			| (MULT_X1 << STDBIT_CLKMULT)	//   Indicate multiplier is 1x.
-			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	//   Set ClkPol equal to Timer count direction (ClkSrcB<0>).
-
-	else if (cra & (2 << CRABIT_CLKSRC_B))	// If Timer mode (ClkSrcB<1> == 1):
-		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| (MULT_X1 << STDBIT_CLKMULT)	//   Indicate multiplier is 1x.
-			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	//   Set ClkPol equal to Timer count direction (ClkSrcB<0>).
-
-	else			// If Counter mode (ClkSrcB<1> == 0):
-		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| ((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	//   Clock multiplier is passed through.
-			| ((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	//   Clock polarity is passed through.
+	/*  Populate the standardized counter setup bit fields.  Note: */
+	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	setup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)	/*  IntSrc   = IntSrcB. */
+		| ((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
+		| ((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
+		| ((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
+		| ((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
+		| ((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB<1>. */
+
+	/*  Adjust mode-dependent parameters. */
+	if ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))	/*  If Extender mode (ClkMultB == MULT_X0): */
+		setup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)	/*    Indicate Extender mode. */
+			| (MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+
+	else if (cra & (2 << CRABIT_CLKSRC_B))	/*  If Timer mode (ClkSrcB<1> == 1): */
+		setup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| (MULT_X1 << STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			| ((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB<0>). */
+
+	else			/*  If Counter mode (ClkSrcB<1> == 0): */
+		setup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| ((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
+			| ((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
 
-	// Return adjusted counter setup.
+	/*  Return adjusted counter setup. */
 	return setup;
 }
 
-/////////////////////////////////////////////////////////////////////////////////////////////
-// Set the operating mode for the specified counter.  The setup
-// parameter is treated as a COUNTER_SETUP data type.  The following
-// parameters are programmable (all other parms are ignored): ClkMult,
-// ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+/*
+ * Set the operating mode for the specified counter.  The setup
+ * parameter is treated as a COUNTER_SETUP data type.  The following
+ * parameters are programmable (all other parms are ignored): ClkMult,
+ * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+ */
 
 static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
 	register uint16_t crb;
-	register uint16_t setup = Setup;	// Cache the Standard Setup.
+	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-	// Initialize CRA and CRB images.
-	cra = ((setup & CRAMSK_LOADSRC_A)	// Preload trigger is passed through.
-		| ((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	// IndexSrc is restricted to ENC_X or IndxPol.
+	/*  Initialize CRA and CRB images. */
+	cra = ((setup & CRAMSK_LOADSRC_A)	/*  Preload trigger is passed through. */
+		| ((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	// Reset any pending CounterA event captures.
-		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	// Clock enable is passed through.
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	/*  Reset any pending CounterA event captures. */
+		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
 
-	// Force IntSrc to Disabled if DisableIntSrc is asserted.
+	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		cra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
 				CRABIT_INTSRC_A));
 
-	// Populate all mode-dependent attributes of CRA & CRB images.
+	/*  Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_EXTENDER:	// Extender Mode: Force to Timer mode
-		// (Extender valid only for B counters).
+	case CLKSRC_EXTENDER:	/*  Extender Mode: Force to Timer mode */
+		/*  (Extender valid only for B counters). */
 
-	case CLKSRC_TIMER:	// Timer Mode:
-		cra |= ((2 << CRABIT_CLKSRC_A)	//   ClkSrcA<1> selects system clock
-			| ((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	//     with count direction (ClkSrcA<0>) obtained from ClkPol.
-			| (1 << CRABIT_CLKPOL_A)	//   ClkPolA behaves as always-on clock enable.
-			| (MULT_X1 << CRABIT_CLKMULT_A));	//   ClkMult must be 1x.
+	case CLKSRC_TIMER:	/*  Timer Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_A)	/*    ClkSrcA<1> selects system clock */
+			| ((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA<0>) obtained from ClkPol. */
+			| (1 << CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
+			| (MULT_X1 << CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
 		break;
 
-	default:		// Counter Mode:
-		cra |= (CLKSRC_COUNTER	//   Select ENC_C and ENC_D as clock/direction inputs.
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	//   Clock polarity is passed through.
-			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	//   Force multiplier to x1 if not legal, otherwise pass through.
+	default:		/*  Counter Mode: */
+		cra |= (CLKSRC_COUNTER	/*    Select ENC_C and ENC_D as clock/direction inputs. */
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	/*    Clock polarity is passed through. */
+			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
 				(MULT_X1 << CRABIT_CLKMULT_A) :
 				((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -
 						STDBIT_CLKMULT))));
 	}
 
-	// Force positive index polarity if IndxSrc is software-driven only,
-	// otherwise pass it through.
+	/*  Force positive index polarity if IndxSrc is software-driven only, */
+	/*  otherwise pass it through. */
 	if (~setup & STDMSK_INDXSRC)
 		cra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -
 				STDBIT_INDXPOL));
 
-	// If IntSrc has been forced to Disabled, update the MISC2 interrupt
-	// enable mask to indicate the counter interrupt is disabled.
+	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
+	/*  enable mask to indicate the counter interrupt is disabled. */
 	if (DisableIntSrc)
 		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
 
-	// While retaining CounterB and LatchSrc configurations, program the
-	// new counter operating mode.
+	/*  While retaining CounterB and LatchSrc configurations, program the */
+	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
 	DEBIreplace(dev, k->MyCRB,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
@@ -2938,65 +2938,64 @@ static void SetMode_B(comedi_device * de
 {
 	register uint16_t cra;
 	register uint16_t crb;
-	register uint16_t setup = Setup;	// Cache the Standard Setup.
+	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-	// Initialize CRA and CRB images.
-	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	// IndexSrc field is restricted to ENC_X or IndxPol.
+	/*  Initialize CRA and CRB images. */
+	cra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	/*  IndexSrc field is restricted to ENC_X or IndxPol. */
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	// Reset event captures and disable interrupts.
-		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	// Clock enable is passed through.
-		| ((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	// Preload trigger source is passed through.
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	/*  Reset event captures and disable interrupts. */
+		| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
+		| ((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
 
-	// Force IntSrc to Disabled if DisableIntSrc is asserted.
+	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		crb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -
 				CRBBIT_INTSRC_B));
 
-	// Populate all mode-dependent attributes of CRA & CRB images.
+	/*  Populate all mode-dependent attributes of CRA & CRB images. */
 	switch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {
-	case CLKSRC_TIMER:	// Timer Mode:
-		cra |= ((2 << CRABIT_CLKSRC_B)	//   ClkSrcB<1> selects system clock
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	//     with direction (ClkSrcB<0>) obtained from ClkPol.
-		crb |= ((1 << CRBBIT_CLKPOL_B)	//   ClkPolB behaves as always-on clock enable.
-			| (MULT_X1 << CRBBIT_CLKMULT_B));	//   ClkMultB must be 1x.
-		break;
-
-	case CLKSRC_EXTENDER:	// Extender Mode:
-		cra |= ((2 << CRABIT_CLKSRC_B)	//   ClkSrcB source is OverflowA (same as "timer")
-			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	//     with direction obtained from ClkPol.
-		crb |= ((1 << CRBBIT_CLKPOL_B)	//   ClkPolB controls IndexB -- always set to active.
-			| (MULT_X0 << CRBBIT_CLKMULT_B));	//   ClkMultB selects OverflowA as the clock source.
-		break;
-
-	default:		// Counter Mode:
-		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	//   Select ENC_C and ENC_D as clock/direction inputs.
-		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	//   ClkPol is passed through.
-			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	//   Force ClkMult to x1 if not legal, otherwise pass through.
+	case CLKSRC_TIMER:	/*  Timer Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB<1> selects system clock */
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB<0>) obtained from ClkPol. */
+		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB behaves as always-on clock enable. */
+			| (MULT_X1 << CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
+		break;
+
+	case CLKSRC_EXTENDER:	/*  Extender Mode: */
+		cra |= ((2 << CRABIT_CLKSRC_B)	/*    ClkSrcB source is OverflowA (same as "timer") */
+			| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
+		crb |= ((1 << CRBBIT_CLKPOL_B)	/*    ClkPolB controls IndexB -- always set to active. */
+			| (MULT_X0 << CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
+		break;
+
+	default:		/*  Counter Mode: */
+		cra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);	/*    Select ENC_C and ENC_D as clock/direction inputs. */
+		crb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	/*    ClkPol is passed through. */
+			| (((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
 				(MULT_X1 << CRBBIT_CLKMULT_B) :
 				((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -
 						STDBIT_CLKMULT))));
 	}
 
-	// Force positive index polarity if IndxSrc is software-driven only,
-	// otherwise pass it through.
+	/*  Force positive index polarity if IndxSrc is software-driven only, */
+	/*  otherwise pass it through. */
 	if (~setup & STDMSK_INDXSRC)
 		crb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -
 				CRBBIT_INDXPOL_B));
 
-	// If IntSrc has been forced to Disabled, update the MISC2 interrupt
-	// enable mask to indicate the counter interrupt is disabled.
+	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
+	/*  enable mask to indicate the counter interrupt is disabled. */
 	if (DisableIntSrc)
 		devpriv->CounterIntEnabs &= ~k->MyEventBits[3];
 
-	// While retaining CounterA and LatchSrc configurations, program the
-	// new counter operating mode.
+	/*  While retaining CounterA and LatchSrc configurations, program the */
+	/*  new counter operating mode. */
 	DEBIreplace(dev, k->MyCRA,
 		(uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
 	DEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
-////////////////////////////////////////////////////////////////////////
-// Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
+/*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
 static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab)
 {
@@ -3023,10 +3022,10 @@ static uint16_t GetEnable_B(comedi_devic
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
 }
 
-////////////////////////////////////////////////////////////////////////
-// Return/set a counter pair's latch trigger source.  0: On read
-// access, 1: A index latches A, 2: B index latches B, 3: A overflow
-// latches B.
+/* Return/set a counter pair's latch trigger source.  0: On read
+ * access, 1: A index latches A, 2: B index latches B, 3: A overflow
+ * latches B.
+ */
 
 static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
 {
@@ -3038,15 +3037,18 @@ static void SetLatchSource(comedi_device
 	DEBUG("SetLatchSource: SetLatchSource exit \n");
 }
 
-/* static uint16_t GetLatchSource(comedi_device *dev, enc_private *k ) */
-/* { */
-/*   return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3; */
-/* } */
+/*
+ * static uint16_t GetLatchSource(comedi_device *dev, enc_private *k )
+ * {
+ * 	return ( DEBIread( dev, k->MyCRB) >> CRBBIT_LATCHSRC ) & 3;
+ * }
+ */
 
-/////////////////////////////////////////////////////////////////////////
-// Return/set the event that will trigger transfer of the preload
-// register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
-// 2=OverflowA (B counters only), 3=disabled.
+/*
+ * Return/set the event that will trigger transfer of the preload
+ * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
+ * 2=OverflowA (B counters only), 3=disabled.
+ */
 
 static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig)
 {
@@ -3071,23 +3073,23 @@ static uint16_t GetLoadTrig_B(comedi_dev
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
 }
 
-////////////////////
-// Return/set counter interrupt source and clear any captured
-// index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
-// 2=IndexOnly, 3=IndexAndOverflow.
+/* Return/set counter interrupt source and clear any captured
+ * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
+ * 2=IndexOnly, 3=IndexAndOverflow.
+ */
 
 static void SetIntSrc_A(comedi_device * dev, enc_private * k,
 	uint16_t IntSource)
 {
-	// Reset any pending counter overflow or index captures.
+	/*  Reset any pending counter overflow or index captures. */
 	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
-	// Program counter interrupt source.
+	/*  Program counter interrupt source. */
 	DEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,
 		(uint16_t) (IntSource << CRABIT_INTSRC_A));
 
-	// Update MISC2 interrupt enable mask.
+	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
 		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
 		MyEventBits[IntSource];
@@ -3098,19 +3100,19 @@ static void SetIntSrc_B(comedi_device * 
 {
 	uint16_t crb;
 
-	// Cache writeable CRB register image.
+	/*  Cache writeable CRB register image. */
 	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;
 
-	// Reset any pending counter overflow or index captures.
+	/*  Reset any pending counter overflow or index captures. */
 	DEBIwrite(dev, k->MyCRB,
 		(uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
-	// Program counter interrupt source.
+	/*  Program counter interrupt source. */
 	DEBIwrite(dev, k->MyCRB,
 		(uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<
 				CRBBIT_INTSRC_B)));
 
-	// Update MISC2 interrupt enable mask.
+	/*  Update MISC2 interrupt enable mask. */
 	devpriv->CounterIntEnabs =
 		(devpriv->CounterIntEnabs & ~k->MyEventBits[3]) | k->
 		MyEventBits[IntSource];
@@ -3126,8 +3128,7 @@ static uint16_t GetIntSrc_B(comedi_devic
 	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
 }
 
-/////////////////////////////////////////////////////////////////////////
-// Return/set the clock multiplier.
+/*  Return/set the clock multiplier. */
 
 /* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3139,8 +3140,7 @@ static uint16_t GetIntSrc_B(comedi_devic
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKMULT ) & 3; */
 /* } */
 
-/* ////////////////////////////////////////////////////////////////////////// */
-/* // Return/set the clock polarity. */
+/* Return/set the clock polarity. */
 
 /* static void SetClkPol( comedi_device *dev,enc_private *k, uint16_t value )  */
 /* { */
@@ -3152,8 +3152,7 @@ static uint16_t GetIntSrc_B(comedi_devic
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKPOL ) & 1; */
 /* } */
 
-/* /////////////////////////////////////////////////////////////////////// */
-/* // Return/set the clock source. */
+/* Return/set the clock source.  */
 
 /* static void SetClkSrc( comedi_device *dev,enc_private *k, uint16_t value )  */
 /* { */
@@ -3165,8 +3164,7 @@ static uint16_t GetIntSrc_B(comedi_devic
 /*   return ( k->GetMode(dev, k ) >> STDBIT_CLKSRC ) & 3; */
 /* } */
 
-/* //////////////////////////////////////////////////////////////////////// */
-/* // Return/set the index polarity. */
+/* Return/set the index polarity. */
 
 /* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3178,8 +3176,7 @@ static uint16_t GetIntSrc_B(comedi_devic
 /*   return ( k->GetMode(dev, k ) >> STDBIT_INDXPOL ) & 1; */
 /* } */
 
-/* //////////////////////////////////////////////////////////////////////// */
-/* // Return/set the index source. */
+/*  Return/set the index source. */
 
 /* static void SetIndexSrc(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3192,8 +3189,7 @@ static uint16_t GetIntSrc_B(comedi_devic
 /*   return ( k->GetMode(dev, k ) >> STDBIT_INDXSRC ) & 1; */
 /* } */
 
-///////////////////////////////////////////////////////////////////
-// Generate an index pulse.
+/*  Generate an index pulse. */
 
 static void PulseIndex_A(comedi_device * dev, enc_private * k)
 {
@@ -3201,7 +3197,7 @@ static void PulseIndex_A(comedi_device *
 
 	DEBUG("PulseIndex_A: pulse index enter\n");
 
-	cra = DEBIread(dev, k->MyCRA);	// Pulse index.
+	cra = DEBIread(dev, k->MyCRA);	/*  Pulse index. */
 	DEBIwrite(dev, k->MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));
 	DEBUG("PulseIndex_A: pulse index step1\n");
 	DEBIwrite(dev, k->MyCRA, cra);
@@ -3211,18 +3207,17 @@ static void PulseIndex_B(comedi_device *
 {
 	register uint16_t crb;
 
-	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;	// Pulse index.
+	crb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;	/*  Pulse index. */
 	DEBIwrite(dev, k->MyCRB, (uint16_t) (crb ^ CRBMSK_INDXPOL_B));
 	DEBIwrite(dev, k->MyCRB, crb);
 }
 
-/////////////////////////////////////////////////////////
-// Write value into counter preload register.
+/*  Write value into counter preload register. */
 
 static void Preload(comedi_device * dev, enc_private * k, uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
-	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	// Write value to preload register.
+	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
 	DEBUG("Preload: preload step 1\n");
 	DEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),
 		(uint16_t) (value >> 16));
@@ -3232,16 +3227,16 @@ static void CountersInit(comedi_device *
 {
 	int chan;
 	enc_private *k;
-	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT << BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_COUNTER << BF_CLKSRC) |	// Operating mode is counter.
-		(CLKPOL_POS << BF_CLKPOL) |	// Active high clock.
-		(CNTDIR_UP << BF_CLKPOL) |	// Count direction is up.
-		(CLKMULT_1X << BF_CLKMULT) |	// Clock multiplier is 1x.
-		(CLKENAB_INDEX << BF_CLKENAB);	// Enabled by index
+	uint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT << BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_COUNTER << BF_CLKSRC) |	/*  Operating mode is counter. */
+		(CLKPOL_POS << BF_CLKPOL) |	/*  Active high clock. */
+		(CNTDIR_UP << BF_CLKPOL) |	/*  Count direction is up. */
+		(CLKMULT_1X << BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+		(CLKENAB_INDEX << BF_CLKENAB);	/*  Enabled by index */
 
-	// Disable all counter interrupts and clear any captured counter events.
+	/*  Disable all counter interrupts and clear any captured counter events. */
 	for (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {
 		k = &encpriv[chan];
 		k->SetMode(dev, k, Setup, TRUE);
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -51,15 +51,15 @@
 
    Example code
 
-   insn.insn=INSN_CONFIG;   //configuration instruction
-   insn.n=1;                //number of operation (must be 1)
-   insn.data=&initialvalue; //initial value loaded into encoder
-                            //during configuration
-   insn.subdev=5;           //encoder subdevice
-   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel
-                                                        //to configure
+   insn.insn=INSN_CONFIG;   // configuration instruction
+   insn.n=1;                // number of operation (must be 1)
+   insn.data=&initialvalue; // initial value loaded into encoder
+                            // during configuration
+   insn.subdev=5;           // encoder subdevice
+   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); // encoder_channel
+                                                        // to configure
 
-   comedi_do_insn(cf,&insn); //executing configuration
+   comedi_do_insn(cf,&insn); // executing configuration
 */
 
 #ifdef _DEBUG_
@@ -88,147 +88,136 @@
 #define INLINE static __inline
 #endif
 
-/////////////////////////////////////////////////////
 #include<linux/slab.h>
 
 #define S626_SIZE 0x0200
 #define SIZEOF_ADDRESS_SPACE		0x0200
-#define DMABUF_SIZE			4096	// 4k pages
+#define DMABUF_SIZE			4096	/*  4k pages */
 
 #define S626_ADC_CHANNELS       16
 #define S626_DAC_CHANNELS       4
 #define S626_ENCODER_CHANNELS   6
 #define S626_DIO_CHANNELS       48
-#define S626_DIO_BANKS		3	// Number of DIO groups.
-#define S626_DIO_EXTCHANS	40	// Number of
-					// extended-capability
-					// DIO channels.
+#define S626_DIO_BANKS		3	/*  Number of DIO groups. */
+#define S626_DIO_EXTCHANS	40	/*  Number of */
+					/*  extended-capability */
+					/*  DIO channels. */
 
-#define NUM_TRIMDACS	12	// Number of valid TrimDAC channels.
+#define NUM_TRIMDACS	12	/*  Number of valid TrimDAC channels. */
 
-// PCI bus interface types.
-#define INTEL				1	// Intel bus type.
-#define MOTOROLA			2	// Motorola bus type.
+/*  PCI bus interface types. */
+#define INTEL				1	/*  Intel bus type. */
+#define MOTOROLA			2	/*  Motorola bus type. */
 
-//////////////////////////////////////////////////////////
+#define PLATFORM		INTEL	/*  *** SELECT PLATFORM TYPE *** */
 
-//////////////////////////////////////////////////////////
-#define PLATFORM		INTEL	// *** SELECT PLATFORM TYPE ***
-//////////////////////////////////////////////////////////
+#define RANGE_5V                0x10	/*  +/-5V range */
+#define RANGE_10V               0x00	/*  +/-10V range */
 
-#define RANGE_5V                0x10	// +/-5V range
-#define RANGE_10V               0x00	// +/-10V range
+#define EOPL			0x80	/*  End of ADC poll list marker. */
+#define GSEL_BIPOLAR5V		0x00F0	/*  LP_GSEL setting for 5V bipolar range. */
+#define GSEL_BIPOLAR10V		0x00A0	/*  LP_GSEL setting for 10V bipolar range. */
 
-#define EOPL			0x80	// End of ADC poll list marker.
-#define GSEL_BIPOLAR5V		0x00F0	// LP_GSEL setting for 5V bipolar range.
-#define GSEL_BIPOLAR10V		0x00A0	// LP_GSEL setting for 10V bipolar range.
+/*  Error codes that must be visible to this base class. */
+#define ERR_ILLEGAL_PARM	0x00010000	/*  Illegal function parameter value was specified. */
+#define ERR_I2C			0x00020000	/*  I2C error. */
+#define ERR_COUNTERSETUP	0x00200000	/*  Illegal setup specified for counter channel. */
+#define ERR_DEBI_TIMEOUT	0x00400000	/*  DEBI transfer timed out. */
 
-// Error codes that must be visible to this base class.
-#define ERR_ILLEGAL_PARM	0x00010000	// Illegal function parameter value was specified.
-#define ERR_I2C			0x00020000	// I2C error.
-#define ERR_COUNTERSETUP	0x00200000	// Illegal setup specified for counter channel.
-#define ERR_DEBI_TIMEOUT	0x00400000	// DEBI transfer timed out.
+/*  Organization (physical order) and size (in DWORDs) of logical DMA buffers contained by ANA_DMABUF. */
+#define ADC_DMABUF_DWORDS	40	/*  ADC DMA buffer must hold 16 samples, plus pre/post garbage samples. */
+#define DAC_WDMABUF_DWORDS	1	/*  DAC output DMA buffer holds a single sample. */
 
-// Organization (physical order) and size (in DWORDs) of logical DMA buffers contained by ANA_DMABUF.
-#define ADC_DMABUF_DWORDS	40	// ADC DMA buffer must hold 16 samples, plus pre/post garbage samples.
-#define DAC_WDMABUF_DWORDS	1	// DAC output DMA buffer holds a single sample.
+/*  All remaining space in 4KB DMA buffer is available for the RPS1 program. */
 
-// All remaining space in 4KB DMA buffer is available for the RPS1 program.
-
-// Address offsets, in DWORDS, from base of DMA buffer.
+/*  Address offsets, in DWORDS, from base of DMA buffer. */
 #define DAC_WDMABUF_OS		ADC_DMABUF_DWORDS
 
-// Interrupt enab bit in ISR and IER.
-#define IRQ_GPIO3		0x00000040	// IRQ enable for GPIO3.
+/*  Interrupt enab bit in ISR and IER. */
+#define IRQ_GPIO3		0x00000040  /*  IRQ enable for GPIO3. */
 #define IRQ_RPS1                0x10000000
-#define ISR_AFOU		0x00000800	// Audio fifo
-						// under/overflow
-						// detected.
-#define IRQ_COINT1A             0x0400	// conter 1A overflow
-						// interrupt mask
-#define IRQ_COINT1B             0x0800	// conter 1B overflow
-						// interrupt mask
-#define IRQ_COINT2A             0x1000	// conter 2A overflow
-						// interrupt mask
-#define IRQ_COINT2B             0x2000	// conter 2B overflow
-						// interrupt mask
-#define IRQ_COINT3A             0x4000	// conter 3A overflow
-						// interrupt mask
-#define IRQ_COINT3B             0x8000	// conter 3B overflow
-						// interrupt mask
-
-// RPS command codes.
-#define RPS_CLRSIGNAL		0x00000000	// CLEAR SIGNAL
-#define RPS_SETSIGNAL		0x10000000	// SET SIGNAL
-#define RPS_NOP			0x00000000	// NOP
-#define RPS_PAUSE		0x20000000	// PAUSE
-#define RPS_UPLOAD		0x40000000	// UPLOAD
-#define RPS_JUMP		0x80000000	// JUMP
-#define RPS_LDREG		0x90000100	// LDREG (1 uint32_t only)
-#define RPS_STREG		0xA0000100	// STREG (1 uint32_t only)
-#define RPS_STOP		0x50000000	// STOP
-#define RPS_IRQ                 0x60000000	// IRQ
-
-#define RPS_LOGICAL_OR		0x08000000	// Logical OR conditionals.
-#define RPS_INVERT		0x04000000	// Test for negated semaphores.
-#define RPS_DEBI		0x00000002	// DEBI done
-
-#define RPS_SIG0		0x00200000	// RPS semaphore 0 (used by ADC).
-#define RPS_SIG1		0x00400000	// RPS semaphore 1 (used by DAC).
-#define RPS_SIG2		0x00800000	// RPS semaphore 2 (not used).
-#define RPS_GPIO2		0x00080000	// RPS GPIO2
-#define RPS_GPIO3		0x00100000	// RPS GPIO3
-
-#define RPS_SIGADC		RPS_SIG0	// Trigger/status for ADC's RPS program.
-#define RPS_SIGDAC		RPS_SIG1	// Trigger/status for DAC's RPS program.
-
-// RPS clock parameters.
-#define RPSCLK_SCALAR		8	// This is apparent ratio of PCI/RPS clks (undocumented!!).
-#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	// Number of RPS clocks in one microsecond.
-
-// Event counter source addresses.
-#define SBA_RPS_A0		0x27	// Time of RPS0 busy, in PCI clocks.
-
-// GPIO constants.
-#define GPIO_BASE		0x10004000	// GPIO 0,2,3 = inputs, GPIO3 = IRQ; GPIO1 = out.
-#define GPIO1_LO		0x00000000	// GPIO1 set to LOW.
-#define GPIO1_HI		0x00001000	// GPIO1 set to HIGH.
-
-// Primary Status Register (PSR) constants.
-#define PSR_DEBI_E		0x00040000	// DEBI event flag.
-#define PSR_DEBI_S		0x00080000	// DEBI status flag.
-#define PSR_A2_IN		0x00008000	// Audio output DMA2 protection address reached.
-#define PSR_AFOU		0x00000800	// Audio FIFO under/overflow detected.
-#define PSR_GPIO2		0x00000020	// GPIO2 input pin: 0=AdcBusy, 1=AdcIdle.
-#define PSR_EC0S		0x00000001	// Event counter 0 threshold reached.
-
-// Secondary Status Register (SSR) constants.
-#define SSR_AF2_OUT		0x00000200	// Audio 2 output FIFO under/overflow detected.
-
-// Master Control Register 1 (MC1) constants.
-#define MC1_SOFT_RESET		0x80000000	// Invoke 7146 soft reset.
-#define MC1_SHUTDOWN		0x3FFF0000	// Shut down all MC1-controlled enables.
-
-#define MC1_ERPS1		0x2000	// enab/disable RPS task 1.
-#define MC1_ERPS0		0x1000	// enab/disable RPS task 0.
-#define MC1_DEBI		0x0800	// enab/disable DEBI pins.
-#define MC1_AUDIO		0x0200	// enab/disable audio port pins.
-#define MC1_I2C			0x0100	// enab/disable I2C interface.
-#define MC1_A2OUT		0x0008	// enab/disable transfer on A2 out.
-#define MC1_A2IN		0x0004	// enab/disable transfer on A2 in.
-#define MC1_A1IN		0x0001	// enab/disable transfer on A1 in.
-
-// Master Control Register 2 (MC2) constants.
-#define MC2_UPLD_DEBIq		0x00020002	// Upload DEBI registers.
-#define MC2_UPLD_IICq		0x00010001	// Upload I2C registers.
-#define MC2_RPSSIG2_ONq		0x20002000	// Assert RPS_SIG2.
-#define MC2_RPSSIG1_ONq		0x10001000	// Assert RPS_SIG1.
-#define MC2_RPSSIG0_ONq		0x08000800	// Assert RPS_SIG0.
-#define MC2_UPLD_DEBI_MASKq	0x00000002	// Upload DEBI mask.
-#define MC2_UPLD_IIC_MASKq	0x00000001	// Upload I2C mask.
-#define MC2_RPSSIG2_MASKq	0x00002000	// RPS_SIG2 bit mask.
-#define MC2_RPSSIG1_MASKq	0x00001000	// RPS_SIG1 bit mask.
-#define MC2_RPSSIG0_MASKq	0x00000800	// RPS_SIG0 bit mask.
+#define ISR_AFOU		0x00000800
+/* Audio fifo under/overflow  detected. */
+
+#define IRQ_COINT1A             0x0400 /* conter 1A overflow interrupt mask */
+#define IRQ_COINT1B             0x0800 /* conter 1B overflow interrupt mask */
+#define IRQ_COINT2A             0x1000 /* conter 2A overflow interrupt mask */
+#define IRQ_COINT2B             0x2000 /* conter 2B overflow interrupt mask */
+#define IRQ_COINT3A             0x4000 /* conter 3A overflow interrupt mask */
+#define IRQ_COINT3B             0x8000 /* conter 3B overflow interrupt mask */
+
+/*  RPS command codes. */
+#define RPS_CLRSIGNAL		0x00000000	/*  CLEAR SIGNAL */
+#define RPS_SETSIGNAL		0x10000000	/*  SET SIGNAL */
+#define RPS_NOP			0x00000000	/*  NOP */
+#define RPS_PAUSE		0x20000000	/*  PAUSE */
+#define RPS_UPLOAD		0x40000000	/*  UPLOAD */
+#define RPS_JUMP		0x80000000	/*  JUMP */
+#define RPS_LDREG		0x90000100	/*  LDREG (1 uint32_t only) */
+#define RPS_STREG		0xA0000100	/*  STREG (1 uint32_t only) */
+#define RPS_STOP		0x50000000	/*  STOP */
+#define RPS_IRQ                 0x60000000	/*  IRQ */
+
+#define RPS_LOGICAL_OR		0x08000000	/*  Logical OR conditionals. */
+#define RPS_INVERT		0x04000000	/*  Test for negated semaphores. */
+#define RPS_DEBI		0x00000002	/*  DEBI done */
+
+#define RPS_SIG0		0x00200000	/*  RPS semaphore 0 (used by ADC). */
+#define RPS_SIG1		0x00400000	/*  RPS semaphore 1 (used by DAC). */
+#define RPS_SIG2		0x00800000	/*  RPS semaphore 2 (not used). */
+#define RPS_GPIO2		0x00080000	/*  RPS GPIO2 */
+#define RPS_GPIO3		0x00100000	/*  RPS GPIO3 */
+
+#define RPS_SIGADC		RPS_SIG0	/*  Trigger/status for ADC's RPS program. */
+#define RPS_SIGDAC		RPS_SIG1	/*  Trigger/status for DAC's RPS program. */
+
+/*  RPS clock parameters. */
+#define RPSCLK_SCALAR		8	/*  This is apparent ratio of PCI/RPS clks (undocumented!!). */
+#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	/*  Number of RPS clocks in one microsecond. */
+
+/*  Event counter source addresses. */
+#define SBA_RPS_A0		0x27	/*  Time of RPS0 busy, in PCI clocks. */
+
+/*  GPIO constants. */
+#define GPIO_BASE		0x10004000	/*  GPIO 0,2,3 = inputs, GPIO3 = IRQ; GPIO1 = out. */
+#define GPIO1_LO		0x00000000	/*  GPIO1 set to LOW. */
+#define GPIO1_HI		0x00001000	/*  GPIO1 set to HIGH. */
+
+/*  Primary Status Register (PSR) constants. */
+#define PSR_DEBI_E		0x00040000	/*  DEBI event flag. */
+#define PSR_DEBI_S		0x00080000	/*  DEBI status flag. */
+#define PSR_A2_IN		0x00008000	/*  Audio output DMA2 protection address reached. */
+#define PSR_AFOU		0x00000800	/*  Audio FIFO under/overflow detected. */
+#define PSR_GPIO2		0x00000020	/*  GPIO2 input pin: 0=AdcBusy, 1=AdcIdle. */
+#define PSR_EC0S		0x00000001	/*  Event counter 0 threshold reached. */
+
+/*  Secondary Status Register (SSR) constants. */
+#define SSR_AF2_OUT		0x00000200	/*  Audio 2 output FIFO under/overflow detected. */
+
+/*  Master Control Register 1 (MC1) constants. */
+#define MC1_SOFT_RESET		0x80000000	/*  Invoke 7146 soft reset. */
+#define MC1_SHUTDOWN		0x3FFF0000	/*  Shut down all MC1-controlled enables. */
+
+#define MC1_ERPS1		0x2000	/*  enab/disable RPS task 1. */
+#define MC1_ERPS0		0x1000	/*  enab/disable RPS task 0. */
+#define MC1_DEBI		0x0800	/*  enab/disable DEBI pins. */
+#define MC1_AUDIO		0x0200	/*  enab/disable audio port pins. */
+#define MC1_I2C			0x0100	/*  enab/disable I2C interface. */
+#define MC1_A2OUT		0x0008	/*  enab/disable transfer on A2 out. */
+#define MC1_A2IN		0x0004	/*  enab/disable transfer on A2 in. */
+#define MC1_A1IN		0x0001	/*  enab/disable transfer on A1 in. */
+
+/*  Master Control Register 2 (MC2) constants. */
+#define MC2_UPLD_DEBIq		0x00020002	/*  Upload DEBI registers. */
+#define MC2_UPLD_IICq		0x00010001	/*  Upload I2C registers. */
+#define MC2_RPSSIG2_ONq		0x20002000	/*  Assert RPS_SIG2. */
+#define MC2_RPSSIG1_ONq		0x10001000	/*  Assert RPS_SIG1. */
+#define MC2_RPSSIG0_ONq		0x08000800	/*  Assert RPS_SIG0. */
+#define MC2_UPLD_DEBI_MASKq	0x00000002	/*  Upload DEBI mask. */
+#define MC2_UPLD_IIC_MASKq	0x00000001	/*  Upload I2C mask. */
+#define MC2_RPSSIG2_MASKq	0x00002000	/*  RPS_SIG2 bit mask. */
+#define MC2_RPSSIG1_MASKq	0x00001000	/*  RPS_SIG1 bit mask. */
+#define MC2_RPSSIG0_MASKq	0x00000800	/*  RPS_SIG0 bit mask. */
 
 #define MC2_DELAYTRIG_4USq	MC2_RPSSIG1_ON
 #define MC2_DELAYBUSY_4USq	MC2_RPSSIG1_MASK
@@ -236,469 +225,425 @@
 #define	MC2_DELAYTRIG_6USq	MC2_RPSSIG2_ON
 #define MC2_DELAYBUSY_6USq	MC2_RPSSIG2_MASK
 
-#define MC2_UPLD_DEBI		0x0002	// Upload DEBI.
-#define MC2_UPLD_IIC		0x0001	// Upload I2C.
-#define MC2_RPSSIG2		0x2000	// RPS signal 2 (not used).
-#define MC2_RPSSIG1		0x1000	// RPS signal 1 (DAC RPS busy).
-#define MC2_RPSSIG0		0x0800	// RPS signal 0 (ADC RPS busy).
-
-#define MC2_ADC_RPS		MC2_RPSSIG0	// ADC RPS busy.
-#define MC2_DAC_RPS		MC2_RPSSIG1	// DAC RPS busy.
-
-///////////////////oldies///////////
-#define MC2_UPLD_DEBIQ		0x00020002	// Upload DEBI registers.
-#define MC2_UPLD_IICQ		0x00010001	// Upload I2C registers.
-////////////////////////////////////////
-
-// PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS ////////////////////////
-#define P_PCI_BT_A		0x004C	// Audio DMA
-						// burst/threshold
-						// control.
-#define P_DEBICFG               0x007C	// DEBI configuration.
-#define P_DEBICMD               0x0080	// DEBI command.
-#define P_DEBIPAGE              0x0084	// DEBI page.
-#define P_DEBIAD                0x0088	// DEBI target address.
-#define P_I2CCTRL               0x008C	// I2C control.
-#define P_I2CSTAT               0x0090	// I2C status.
-#define P_BASEA2_IN		0x00AC	// Audio input 2 base
-						// physical DMAbuf
-						// address.
-#define P_PROTA2_IN		0x00B0	// Audio input 2
-						// physical DMAbuf
-						// protection address.
-#define P_PAGEA2_IN		0x00B4	// Audio input 2
-						// paging attributes.
-#define P_BASEA2_OUT		0x00B8	// Audio output 2 base
-						// physical DMAbuf
-						// address.
-#define P_PROTA2_OUT		0x00BC	// Audio output 2
-						// physical DMAbuf
-						// protection address.
-#define P_PAGEA2_OUT		0x00C0	// Audio output 2
-						// paging attributes.
-#define P_RPSPAGE0              0x00C4	// RPS0 page.
-#define P_RPSPAGE1              0x00C8	// RPS1 page.
-#define P_RPS0_TOUT		0x00D4	// RPS0 time-out.
-#define P_RPS1_TOUT		0x00D8	// RPS1 time-out.
-#define P_IER                   0x00DC	// Interrupt enable.
-#define P_GPIO                  0x00E0	// General-purpose I/O.
-#define P_EC1SSR		0x00E4	// Event counter set 1
-						// source select.
-#define P_ECT1R			0x00EC	// Event counter
-						// threshold set 1.
-#define P_ACON1                 0x00F4	// Audio control 1.
-#define P_ACON2                 0x00F8	// Audio control 2.
-#define P_MC1                   0x00FC	// Master control 1.
-#define P_MC2                   0x0100	// Master control 2.
-#define P_RPSADDR0              0x0104	// RPS0 instruction pointer.
-#define P_RPSADDR1              0x0108	// RPS1 instruction pointer.
-#define P_ISR                   0x010C	// Interrupt status.
-#define P_PSR                   0x0110	// Primary status.
-#define P_SSR                   0x0114	// Secondary status.
-#define P_EC1R			0x0118	// Event counter set 1.
-#define P_ADP4			0x0138	// Logical audio DMA
-						// pointer of audio
-						// input FIFO A2_IN.
-#define P_FB_BUFFER1            0x0144	// Audio feedback buffer 1.
-#define P_FB_BUFFER2            0x0148	// Audio feedback buffer 2.
-#define P_TSL1                  0x0180	// Audio time slot list 1.
-#define P_TSL2                  0x01C0	// Audio time slot list 2.
-
-// LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS /////////////////
-// Analog I/O registers:
-#define LP_DACPOL		0x0082	//  Write DAC polarity.
-#define LP_GSEL			0x0084	//  Write ADC gain.
-#define LP_ISEL			0x0086	//  Write ADC channel select.
-// Digital I/O (write only):
-#define LP_WRINTSELA		0x0042	//  Write A interrupt enable.
-#define LP_WREDGSELA		0x0044	//  Write A edge selection.
-#define LP_WRCAPSELA		0x0046	//  Write A capture enable.
-#define LP_WRDOUTA		0x0048	//  Write A digital output.
-#define LP_WRINTSELB		0x0052	//  Write B interrupt enable.
-#define LP_WREDGSELB		0x0054	//  Write B edge selection.
-#define LP_WRCAPSELB		0x0056	//  Write B capture enable.
-#define LP_WRDOUTB		0x0058	//  Write B digital output.
-#define LP_WRINTSELC		0x0062	//  Write C interrupt enable.
-#define LP_WREDGSELC		0x0064	//  Write C edge selection.
-#define LP_WRCAPSELC		0x0066	//  Write C capture enable.
-#define LP_WRDOUTC		0x0068	//  Write C digital output.
-
-// Digital I/O (read only):
-#define LP_RDDINA		0x0040	//  Read digital input.
-#define LP_RDCAPFLGA		0x0048	//  Read edges captured.
-#define LP_RDINTSELA		0x004A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELA		0x004C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELA		0x004E	//  Read capture
-						//  enable register.
-#define LP_RDDINB		0x0050	//  Read digital input.
-#define LP_RDCAPFLGB		0x0058	//  Read edges captured.
-#define LP_RDINTSELB		0x005A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELB		0x005C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELB		0x005E	//  Read capture
-						//  enable register.
-#define LP_RDDINC		0x0060	//  Read digital input.
-#define LP_RDCAPFLGC		0x0068	//  Read edges captured.
-#define LP_RDINTSELC		0x006A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELC		0x006C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELC		0x006E	//  Read capture
-						//  enable register.
-// Counter Registers (read/write):
-#define LP_CR0A			0x0000	//  0A setup register.
-#define LP_CR0B			0x0002	//  0B setup register.
-#define LP_CR1A			0x0004	//  1A setup register.
-#define LP_CR1B			0x0006	//  1B setup register.
-#define LP_CR2A			0x0008	//  2A setup register.
-#define LP_CR2B			0x000A	//  2B setup register.
-// Counter PreLoad (write) and Latch (read) Registers:
-#define	LP_CNTR0ALSW		0x000C	//  0A lsw.
-#define	LP_CNTR0AMSW		0x000E	//  0A msw.
-#define	LP_CNTR0BLSW		0x0010	//  0B lsw.
-#define	LP_CNTR0BMSW		0x0012	//  0B msw.
-#define	LP_CNTR1ALSW		0x0014	//  1A lsw.
-#define	LP_CNTR1AMSW		0x0016	//  1A msw.
-#define	LP_CNTR1BLSW		0x0018	//  1B lsw.
-#define	LP_CNTR1BMSW		0x001A	//  1B msw.
-#define	LP_CNTR2ALSW		0x001C	//  2A lsw.
-#define	LP_CNTR2AMSW		0x001E	//  2A msw.
-#define	LP_CNTR2BLSW		0x0020	//  2B lsw.
-#define	LP_CNTR2BMSW		0x0022	//  2B msw.
-// Miscellaneous Registers (read/write):
-#define LP_MISC1		0x0088	//  Read/write Misc1.
-#define LP_WRMISC2		0x0090	//  Write Misc2.
-#define LP_RDMISC2		0x0082	//  Read Misc2.
-
-// Bit masks for MISC1 register that are the same for reads and writes.
-#define MISC1_WENABLE		0x8000	// enab writes to
-						// MISC2 (except Clear
-						// Watchdog bit).
-#define MISC1_WDISABLE		0x0000	// Disable writes to MISC2.
-#define MISC1_EDCAP		0x1000	// enab edge capture
-						// on DIO chans
-						// specified by
-						// LP_WRCAPSELx.
-#define MISC1_NOEDCAP		0x0000	// Disable edge
-						// capture on
-						// specified DIO
-						// chans.
-
-// Bit masks for MISC1 register reads.
-#define RDMISC1_WDTIMEOUT	0x4000	// Watchdog timer timed out.
-
-// Bit masks for MISC2 register writes.
-#define WRMISC2_WDCLEAR		0x8000	// Reset watchdog
-						// timer to zero.
-#define WRMISC2_CHARGE_ENABLE	0x4000	// enab battery
-						// trickle charging.
-
-// Bit masks for MISC2 register that are the same for reads and writes.
-#define MISC2_BATT_ENABLE	0x0008	// Backup battery enable.
-#define MISC2_WDENABLE		0x0004	// Watchdog timer enable.
-#define MISC2_WDPERIOD_MASK	0x0003	// Watchdog interval
-						// select mask.
-
-// Bit masks for ACON1 register.
-#define A2_RUN			0x40000000	// Run A2 based on TSL2.
-#define A1_RUN			0x20000000	// Run A1 based on TSL1.
-#define A1_SWAP			0x00200000	// Use big-endian for A1.
-#define A2_SWAP			0x00100000	// Use big-endian for A2.
-#define WS_MODES		0x00019999	// WS0 = TSL1 trigger
-						// input, WS1-WS4 =
-						// CS* outputs.
-
-#if PLATFORM == INTEL		// Base ACON1 config:
-						// always run A1 based
-						// on TSL1.
+#define MC2_UPLD_DEBI		0x0002	/*  Upload DEBI. */
+#define MC2_UPLD_IIC		0x0001	/*  Upload I2C. */
+#define MC2_RPSSIG2		0x2000	/*  RPS signal 2 (not used). */
+#define MC2_RPSSIG1		0x1000	/*  RPS signal 1 (DAC RPS busy). */
+#define MC2_RPSSIG0		0x0800	/*  RPS signal 0 (ADC RPS busy). */
+
+#define MC2_ADC_RPS		MC2_RPSSIG0	/*  ADC RPS busy. */
+#define MC2_DAC_RPS		MC2_RPSSIG1	/*  DAC RPS busy. */
+
+/* ***** oldies ***** */
+#define MC2_UPLD_DEBIQ		0x00020002	/*  Upload DEBI registers. */
+#define MC2_UPLD_IICQ		0x00010001	/*  Upload I2C registers. */
+
+/*  PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS */
+#define P_PCI_BT_A		0x004C	/* Audio DMA burst/threshold control. */
+#define P_DEBICFG               0x007C	/* DEBI configuration. */
+#define P_DEBICMD               0x0080	/* DEBI command. */
+#define P_DEBIPAGE              0x0084	/* DEBI page. */
+#define P_DEBIAD                0x0088	/* DEBI target address. */
+#define P_I2CCTRL               0x008C	/* I2C control. */
+#define P_I2CSTAT               0x0090	/* I2C status. */
+#define P_BASEA2_IN		0x00AC	/* Audio input 2 base physical DMAbuf
+					 * address. */
+#define P_PROTA2_IN		0x00B0	/* Audio input 2 physical DMAbuf
+					 * protection address. */
+#define P_PAGEA2_IN		0x00B4	/* Audio input 2 paging attributes. */
+#define P_BASEA2_OUT		0x00B8	/* Audio output 2 base physical DMAbuf
+					 * address. */
+#define P_PROTA2_OUT		0x00BC	/* Audio output 2 physical DMAbuf
+					 * protection address. */
+#define P_PAGEA2_OUT		0x00C0	/* Audio output 2 paging attributes. */
+#define P_RPSPAGE0              0x00C4	/* RPS0 page. */
+#define P_RPSPAGE1              0x00C8	/* RPS1 page. */
+#define P_RPS0_TOUT		0x00D4	/* RPS0 time-out. */
+#define P_RPS1_TOUT		0x00D8	/* RPS1 time-out. */
+#define P_IER                   0x00DC	/* Interrupt enable. */
+#define P_GPIO                  0x00E0	/* General-purpose I/O. */
+#define P_EC1SSR		0x00E4	/* Event counter set 1 source select. */
+#define P_ECT1R			0x00EC	/* Event counter threshold set 1. */
+#define P_ACON1                 0x00F4	/* Audio control 1. */
+#define P_ACON2                 0x00F8	/* Audio control 2. */
+#define P_MC1                   0x00FC	/* Master control 1. */
+#define P_MC2                   0x0100	/* Master control 2. */
+#define P_RPSADDR0              0x0104	/* RPS0 instruction pointer. */
+#define P_RPSADDR1              0x0108	/* RPS1 instruction pointer. */
+#define P_ISR                   0x010C	/* Interrupt status. */
+#define P_PSR                   0x0110	/* Primary status. */
+#define P_SSR                   0x0114	/* Secondary status. */
+#define P_EC1R			0x0118	/* Event counter set 1. */
+#define P_ADP4			0x0138	/* Logical audio DMA pointer of audio
+					 * input FIFO A2_IN. */
+#define P_FB_BUFFER1            0x0144	/* Audio feedback buffer 1. */
+#define P_FB_BUFFER2            0x0148	/* Audio feedback buffer 2. */
+#define P_TSL1                  0x0180	/* Audio time slot list 1. */
+#define P_TSL2                  0x01C0	/* Audio time slot list 2. */
+
+/*  LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS */
+/*  Analog I/O registers: */
+#define LP_DACPOL		0x0082	/*   Write DAC polarity. */
+#define LP_GSEL			0x0084	/*   Write ADC gain. */
+#define LP_ISEL			0x0086	/*   Write ADC channel select. */
+/*  Digital I/O (write only): */
+#define LP_WRINTSELA		0x0042	/*   Write A interrupt enable. */
+#define LP_WREDGSELA		0x0044	/*   Write A edge selection. */
+#define LP_WRCAPSELA		0x0046	/*   Write A capture enable. */
+#define LP_WRDOUTA		0x0048	/*   Write A digital output. */
+#define LP_WRINTSELB		0x0052	/*   Write B interrupt enable. */
+#define LP_WREDGSELB		0x0054	/*   Write B edge selection. */
+#define LP_WRCAPSELB		0x0056	/*   Write B capture enable. */
+#define LP_WRDOUTB		0x0058	/*   Write B digital output. */
+#define LP_WRINTSELC		0x0062	/*   Write C interrupt enable. */
+#define LP_WREDGSELC		0x0064	/*   Write C edge selection. */
+#define LP_WRCAPSELC		0x0066	/*   Write C capture enable. */
+#define LP_WRDOUTC		0x0068	/*   Write C digital output. */
+
+/*  Digital I/O (read only): */
+#define LP_RDDINA		0x0040	/*   Read digital input. */
+#define LP_RDCAPFLGA		0x0048	/*   Read edges captured. */
+#define LP_RDINTSELA		0x004A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELA		0x004C	/*   Read edge selection register. */
+#define LP_RDCAPSELA		0x004E	/*   Read capture enable register. */
+#define LP_RDDINB		0x0050	/*   Read digital input. */
+#define LP_RDCAPFLGB		0x0058	/*   Read edges captured. */
+#define LP_RDINTSELB		0x005A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELB		0x005C	/*   Read edge selection register. */
+#define LP_RDCAPSELB		0x005E	/*   Read capture enable register. */
+#define LP_RDDINC		0x0060	/*   Read digital input. */
+#define LP_RDCAPFLGC		0x0068	/*   Read edges captured. */
+#define LP_RDINTSELC		0x006A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELC		0x006C	/*   Read edge selection register. */
+#define LP_RDCAPSELC		0x006E	/*   Read capture enable register. */
+
+/*  Counter Registers (read/write): */
+#define LP_CR0A			0x0000	/*   0A setup register. */
+#define LP_CR0B			0x0002	/*   0B setup register. */
+#define LP_CR1A			0x0004	/*   1A setup register. */
+#define LP_CR1B			0x0006	/*   1B setup register. */
+#define LP_CR2A			0x0008	/*   2A setup register. */
+#define LP_CR2B			0x000A	/*   2B setup register. */
+
+/*  Counter PreLoad (write) and Latch (read) Registers: */
+#define	LP_CNTR0ALSW		0x000C	/*   0A lsw. */
+#define	LP_CNTR0AMSW		0x000E	/*   0A msw. */
+#define	LP_CNTR0BLSW		0x0010	/*   0B lsw. */
+#define	LP_CNTR0BMSW		0x0012	/*   0B msw. */
+#define	LP_CNTR1ALSW		0x0014	/*   1A lsw. */
+#define	LP_CNTR1AMSW		0x0016	/*   1A msw. */
+#define	LP_CNTR1BLSW		0x0018	/*   1B lsw. */
+#define	LP_CNTR1BMSW		0x001A	/*   1B msw. */
+#define	LP_CNTR2ALSW		0x001C	/*   2A lsw. */
+#define	LP_CNTR2AMSW		0x001E	/*   2A msw. */
+#define	LP_CNTR2BLSW		0x0020	/*   2B lsw. */
+#define	LP_CNTR2BMSW		0x0022	/*   2B msw. */
+
+/*  Miscellaneous Registers (read/write): */
+#define LP_MISC1		0x0088	/*   Read/write Misc1. */
+#define LP_WRMISC2		0x0090	/*   Write Misc2. */
+#define LP_RDMISC2		0x0082	/*   Read Misc2. */
+
+/*  Bit masks for MISC1 register that are the same for reads and writes. */
+#define MISC1_WENABLE		0x8000	/* enab writes to MISC2 (except Clear
+					 * Watchdog bit). */
+#define MISC1_WDISABLE		0x0000	/* Disable writes to MISC2. */
+#define MISC1_EDCAP		0x1000	/* enab edge capture on DIO chans
+					 * specified by  LP_WRCAPSELx. */
+#define MISC1_NOEDCAP		0x0000	/* Disable edge capture on specified
+					 * DIO chans. */
+
+/*  Bit masks for MISC1 register reads. */
+#define RDMISC1_WDTIMEOUT	0x4000	/*  Watchdog timer timed out. */
+
+/*  Bit masks for MISC2 register writes. */
+#define WRMISC2_WDCLEAR		0x8000	/*  Reset watchdog timer to zero. */
+#define WRMISC2_CHARGE_ENABLE	0x4000	/*  enab battery trickle charging. */
+
+/*  Bit masks for MISC2 register that are the same for reads and writes. */
+#define MISC2_BATT_ENABLE	0x0008	/*  Backup battery enable. */
+#define MISC2_WDENABLE		0x0004	/*  Watchdog timer enable. */
+#define MISC2_WDPERIOD_MASK	0x0003	/*  Watchdog interval */
+						/*  select mask. */
+
+/*  Bit masks for ACON1 register. */
+#define A2_RUN			0x40000000	/*  Run A2 based on TSL2. */
+#define A1_RUN			0x20000000	/*  Run A1 based on TSL1. */
+#define A1_SWAP			0x00200000	/*  Use big-endian for A1. */
+#define A2_SWAP			0x00100000	/*  Use big-endian for A2. */
+#define WS_MODES		0x00019999	/*  WS0 = TSL1 trigger */
+						/*  input, WS1-WS4 = */
+						/*  CS* outputs. */
+
+#if PLATFORM == INTEL		/* Base ACON1 config: always run A1 based
+				 * on TSL1. */
 #define ACON1_BASE		( WS_MODES | A1_RUN )
 #elif PLATFORM == MOTOROLA
 #define ACON1_BASE		( WS_MODES | A1_RUN | A1_SWAP | A2_SWAP )
 #endif
 
-#define ACON1_ADCSTART		ACON1_BASE	// Start ADC: run A1
-						// based on TSL1.
-#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )	// Start
-							// transmit to
-							// DAC: run A2
-							// based on
-							// TSL2.
-#define ACON1_DACSTOP		ACON1_BASE	// Halt A2.
-
-// Bit masks for ACON2 register.
-#define A1_CLKSRC_BCLK1		0x00000000	// A1 bit rate = BCLK1 (ADC).
-#define A2_CLKSRC_X1		0x00800000	// A2 bit rate = ACLK/1 (DACs).
-#define A2_CLKSRC_X2		0x00C00000	// A2 bit rate = ACLK/2 (DACs).
-#define A2_CLKSRC_X4		0x01400000	// A2 bit rate = ACLK/4 (DACs).
-#define INVERT_BCLK2		0x00100000	// Invert BCLK2 (DACs).
-#define BCLK2_OE		0x00040000	// enab BCLK2 (DACs).
-#define ACON2_XORMASK		0x000C0000	// XOR mask for ACON2
-						// active-low bits.
+#define ACON1_ADCSTART		ACON1_BASE	/* Start ADC: run A1
+						 *  based on TSL1. */
+#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )
+/* Start transmit to DAC: run A2 based on TSL2. */
+#define ACON1_DACSTOP		ACON1_BASE	/*  Halt A2. */
+
+/*  Bit masks for ACON2 register. */
+#define A1_CLKSRC_BCLK1		0x00000000	/*  A1 bit rate = BCLK1 (ADC). */
+#define A2_CLKSRC_X1		0x00800000	/*  A2 bit rate = ACLK/1 (DACs). */
+#define A2_CLKSRC_X2		0x00C00000	/*  A2 bit rate = ACLK/2 (DACs). */
+#define A2_CLKSRC_X4		0x01400000	/*  A2 bit rate = ACLK/4 (DACs). */
+#define INVERT_BCLK2		0x00100000	/*  Invert BCLK2 (DACs). */
+#define BCLK2_OE		0x00040000	/*  enab BCLK2 (DACs). */
+#define ACON2_XORMASK		0x000C0000	/*  XOR mask for ACON2 */
+						/*  active-low bits. */
 
 #define ACON2_INIT		( ACON2_XORMASK ^ ( A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE ) )
 
-// Bit masks for timeslot records.
-#define WS1		     	0x40000000	// WS output to assert.
+/*  Bit masks for timeslot records. */
+#define WS1		     	0x40000000	/*  WS output to assert. */
 #define WS2		     	0x20000000
 #define WS3		     	0x10000000
 #define WS4		     	0x08000000
-#define RSD1			0x01000000	// Shift A1 data in on SD1.
-#define SDW_A1			0x00800000	// Store rcv'd char at
-						// next char slot of
-						// DWORD1 buffer.
-#define SIB_A1			0x00400000	// Store rcv'd char at
-						// next char slot of
-						// FB1 buffer.
-#define SF_A1			0x00200000	// Write unsigned long
-						// buffer to input
-						// FIFO.
-
-//Select parallel-to-serial converter's data source:
-#define XFIFO_0			0x00000000	//   Data fifo byte 0.
-#define XFIFO_1			0x00000010	//   Data fifo byte 1.
-#define XFIFO_2			0x00000020	//   Data fifo byte 2.
-#define XFIFO_3			0x00000030	//   Data fifo byte 3.
-#define XFB0			0x00000040	//   FB_BUFFER byte 0.
-#define XFB1			0x00000050	//   FB_BUFFER byte 1.
-#define XFB2			0x00000060	//   FB_BUFFER byte 2.
-#define XFB3			0x00000070	//   FB_BUFFER byte 3.
-#define SIB_A2			0x00000200	// Store next dword
-						// from A2's input
-						// shifter to FB2
-						// buffer.
-#define SF_A2			0x00000100	// Store next dword
-						// from A2's input
-						// shifter to its
-						// input fifo.
-#define LF_A2			0x00000080	// Load next dword
-						// from A2's output
-						// fifo into its
-						// output dword
-						// buffer.
-#define XSD2			0x00000008	// Shift data out on SD2.
-#define RSD3			0x00001800	// Shift data in on SD3.
-#define RSD2			0x00001000	// Shift data in on SD2.
-#define LOW_A2			0x00000002	// Drive last SD low
-						// for 7 clks, then
-						// tri-state.
-#define EOS		     	0x00000001	// End of superframe.
-
-//////////////////////
-
-// I2C configuration constants.
-#define I2C_CLKSEL		0x0400	// I2C bit rate =
-						// PCIclk/480 = 68.75
-						// KHz.
-#define I2C_BITRATE		68.75	// I2C bus data bit
-						// rate (determined by
-						// I2C_CLKSEL) in KHz.
-#define I2C_WRTIME		15.0	// Worst case time,in
-						// msec, for EEPROM
-						// internal write op.
+#define RSD1			0x01000000	/* Shift A1 data in on SD1. */
+#define SDW_A1			0x00800000	/* Store rcv'd char at next
+						 * char slot of DWORD1 buffer. */
+#define SIB_A1			0x00400000	/* Store rcv'd char at next
+						 * char slot of FB1 buffer. */
+#define SF_A1			0x00200000	/* Write unsigned long
+						 * buffer to input FIFO. */
+
+/* Select parallel-to-serial converter's data source: */
+#define XFIFO_0			0x00000000	/*    Data fifo byte 0. */
+#define XFIFO_1			0x00000010	/*    Data fifo byte 1. */
+#define XFIFO_2			0x00000020	/*    Data fifo byte 2. */
+#define XFIFO_3			0x00000030	/*    Data fifo byte 3. */
+#define XFB0			0x00000040	/*    FB_BUFFER byte 0. */
+#define XFB1			0x00000050	/*    FB_BUFFER byte 1. */
+#define XFB2			0x00000060	/*    FB_BUFFER byte 2. */
+#define XFB3			0x00000070	/*    FB_BUFFER byte 3. */
+#define SIB_A2			0x00000200	/* Store next dword from A2's
+						 * input shifter to FB2 buffer. */
+#define SF_A2			0x00000100	/* Store next dword from A2's
+						 * input shifter to its input
+						 * fifo. */
+#define LF_A2			0x00000080	/* Load next dword from A2's
+						 * output fifo into its
+						 * output dword buffer. */
+#define XSD2			0x00000008	/*  Shift data out on SD2. */
+#define RSD3			0x00001800	/*  Shift data in on SD3. */
+#define RSD2			0x00001000	/*  Shift data in on SD2. */
+#define LOW_A2			0x00000002	/*  Drive last SD low */
+						/*  for 7 clks, then */
+						/*  tri-state. */
+#define EOS		     	0x00000001	/*  End of superframe. */
+
+
+/*  I2C configuration constants. */
+#define I2C_CLKSEL		0x0400
+/* I2C bit rate = PCIclk/480 = 68.75 KHz. */
+
+#define I2C_BITRATE		68.75
+/* I2C bus data bit rate (determined by I2C_CLKSEL) in KHz. */
+
+#define I2C_WRTIME		15.0
+/* Worst case time, in msec, for EEPROM internal write op. */
 
-// I2C manifest constants.
+/*  I2C manifest constants. */
 
-// Max retries to wait for EEPROM write.
+/*  Max retries to wait for EEPROM write. */
 #define I2C_RETRIES		( I2C_WRTIME * I2C_BITRATE / 9.0 )
-#define I2C_ERR			0x0002	// I2C control/status
-						// flag ERROR.
-#define I2C_BUSY		0x0001	// I2C control/status
-						// flag BUSY.
-#define I2C_ABORT		0x0080	// I2C status flag ABORT.
-#define I2C_ATTRSTART		0x3	// I2C attribute START.
-#define I2C_ATTRCONT		0x2	// I2C attribute CONT.
-#define I2C_ATTRSTOP		0x1	// I2C attribute STOP.
-#define I2C_ATTRNOP		0x0	// I2C attribute NOP.
+#define I2C_ERR			0x0002	/*  I2C control/status */
+						/*  flag ERROR. */
+#define I2C_BUSY		0x0001	/*  I2C control/status */
+						/*  flag BUSY. */
+#define I2C_ABORT		0x0080	/*  I2C status flag ABORT. */
+#define I2C_ATTRSTART		0x3	/*  I2C attribute START. */
+#define I2C_ATTRCONT		0x2	/*  I2C attribute CONT. */
+#define I2C_ATTRSTOP		0x1	/*  I2C attribute STOP. */
+#define I2C_ATTRNOP		0x0	/*  I2C attribute NOP. */
 
-// I2C read command  | EEPROM address.
+/*  I2C read command  | EEPROM address. */
 #define I2CR			( devpriv->I2CAdrs | 1 )
 
-// I2C write command | EEPROM address.
+/*  I2C write command | EEPROM address. */
 #define I2CW			( devpriv->I2CAdrs )
 
-// Code macros used for constructing I2C command bytes.
+/*  Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR,VAL)	( ( (ATTR) << 6 ) | ( (VAL) << 24 ) )
 #define I2C_B1(ATTR,VAL)	( ( (ATTR) << 4 ) | ( (VAL) << 16 ) )
 #define I2C_B0(ATTR,VAL)	( ( (ATTR) << 2 ) | ( (VAL) <<  8 ) )
 
-////////////////////////////////////////////////////////
-//oldest
-#define P_DEBICFGq              0x007C	// DEBI configuration.
-#define P_DEBICMDq              0x0080	// DEBI command.
-#define P_DEBIPAGEq             0x0084	// DEBI page.
-#define P_DEBIADq               0x0088	// DEBI target address.
-
-#define DEBI_CFG_TOQ		0x03C00000	// timeout (15 PCI cycles)
-#define DEBI_CFG_FASTQ		0x10000000	// fast mode enable
-#define DEBI_CFG_16Q		0x00080000	// 16-bit access enable
-#define DEBI_CFG_INCQ		0x00040000	// enable address increment
-#define DEBI_CFG_TIMEROFFQ	0x00010000	// disable timer
-#define DEBI_CMD_RDQ		0x00050000	// read immediate 2 bytes
-#define DEBI_CMD_WRQ		0x00040000	// write immediate 2 bytes
-#define DEBI_PAGE_DISABLEQ	0x00000000	// paging disable
-
-///////////////////////////////////////////
-// DEBI command constants.
-#define DEBI_CMD_SIZE16		( 2 << 17 )	// Transfer size is
-						// always 2 bytes.
-#define DEBI_CMD_READ		0x00010000	// Read operation.
-#define DEBI_CMD_WRITE		0x00000000	// Write operation.
+/* oldest */
+#define P_DEBICFGq              0x007C	/*  DEBI configuration. */
+#define P_DEBICMDq              0x0080	/*  DEBI command. */
+#define P_DEBIPAGEq             0x0084	/*  DEBI page. */
+#define P_DEBIADq               0x0088	/*  DEBI target address. */
+
+#define DEBI_CFG_TOQ		0x03C00000	/*  timeout (15 PCI cycles) */
+#define DEBI_CFG_FASTQ		0x10000000	/*  fast mode enable */
+#define DEBI_CFG_16Q		0x00080000	/*  16-bit access enable */
+#define DEBI_CFG_INCQ		0x00040000	/*  enable address increment */
+#define DEBI_CFG_TIMEROFFQ	0x00010000	/*  disable timer */
+#define DEBI_CMD_RDQ		0x00050000	/*  read immediate 2 bytes */
+#define DEBI_CMD_WRQ		0x00040000	/*  write immediate 2 bytes */
+#define DEBI_PAGE_DISABLEQ	0x00000000	/*  paging disable */
+
+/*  DEBI command constants. */
+#define DEBI_CMD_SIZE16		( 2 << 17 )	/*  Transfer size is */
+						/*  always 2 bytes. */
+#define DEBI_CMD_READ		0x00010000	/*  Read operation. */
+#define DEBI_CMD_WRITE		0x00000000	/*  Write operation. */
 
-// Read immediate 2 bytes.
+/*  Read immediate 2 bytes. */
 #define DEBI_CMD_RDWORD		( DEBI_CMD_READ  | DEBI_CMD_SIZE16 )
 
-// Write immediate 2 bytes.
+/*  Write immediate 2 bytes. */
 #define DEBI_CMD_WRWORD		( DEBI_CMD_WRITE | DEBI_CMD_SIZE16 )
 
-// DEBI configuration constants.
-#define DEBI_CFG_XIRQ_EN	0x80000000	// enab external
-						// interrupt on GPIO3.
-#define DEBI_CFG_XRESUME	0x40000000	// Resume block
-						// transfer when XIRQ
-						// deasserted.
-#define DEBI_CFG_FAST		0x10000000	// Fast mode enable.
-
-// 4-bit field that specifies DEBI timeout value in PCI clock cycles:
-#define DEBI_CFG_TOUT_BIT	22	//   Finish DEBI cycle after
-					//   this many clocks.
-
-// 2-bit field that specifies Endian byte lane steering:
-#define DEBI_CFG_SWAP_NONE	0x00000000	//   Straight - don't
-						//   swap any bytes
-						//   (Intel).
-#define DEBI_CFG_SWAP_2		0x00100000	//   2-byte swap (Motorola).
-#define DEBI_CFG_SWAP_4		0x00200000	//   4-byte swap.
-#define DEBI_CFG_16		0x00080000	// Slave is able to
-						// serve 16-bit
-						// cycles.
-
-#define DEBI_CFG_SLAVE16	0x00080000	// Slave is able to
-						// serve 16-bit
-						// cycles.
-#define DEBI_CFG_INC		0x00040000	// enab address
-						// increment for block
-						// transfers.
-#define DEBI_CFG_INTEL		0x00020000	// Intel style local bus.
-#define DEBI_CFG_TIMEROFF	0x00010000	// Disable timer.
+/*  DEBI configuration constants. */
+#define DEBI_CFG_XIRQ_EN	0x80000000	/*  enab external */
+						/*  interrupt on GPIO3. */
+#define DEBI_CFG_XRESUME	0x40000000	/*  Resume block */
+						/*  transfer when XIRQ */
+						/*  deasserted. */
+#define DEBI_CFG_FAST		0x10000000	/*  Fast mode enable. */
+
+/*  4-bit field that specifies DEBI timeout value in PCI clock cycles: */
+#define DEBI_CFG_TOUT_BIT	22	/*    Finish DEBI cycle after */
+					/*    this many clocks. */
+
+/*  2-bit field that specifies Endian byte lane steering: */
+#define DEBI_CFG_SWAP_NONE	0x00000000	/*    Straight - don't */
+						/*    swap any bytes */
+						/*    (Intel). */
+#define DEBI_CFG_SWAP_2		0x00100000	/*    2-byte swap (Motorola). */
+#define DEBI_CFG_SWAP_4		0x00200000	/*    4-byte swap. */
+#define DEBI_CFG_16		0x00080000	/*  Slave is able to */
+						/*  serve 16-bit */
+						/*  cycles. */
+
+#define DEBI_CFG_SLAVE16	0x00080000	/*  Slave is able to */
+						/*  serve 16-bit */
+						/*  cycles. */
+#define DEBI_CFG_INC		0x00040000	/*  enab address */
+						/*  increment for block */
+						/*  transfers. */
+#define DEBI_CFG_INTEL		0x00020000	/*  Intel style local bus. */
+#define DEBI_CFG_TIMEROFF	0x00010000	/*  Disable timer. */
 
 #if PLATFORM == INTEL
 
-#define DEBI_TOUT		7	// Wait 7 PCI clocks
-						// (212 ns) before
-						// polling RDY.
+#define DEBI_TOUT		7	/*  Wait 7 PCI clocks */
+						/*  (212 ns) before */
+						/*  polling RDY. */
 
-// Intel byte lane steering (pass through all byte lanes).
+/*  Intel byte lane steering (pass through all byte lanes). */
 #define DEBI_SWAP		DEBI_CFG_SWAP_NONE
 
 #elif PLATFORM == MOTOROLA
 
-#define DEBI_TOUT		15	// Wait 15 PCI clocks (454 ns)
-					// maximum before timing out.
-#define DEBI_SWAP		DEBI_CFG_SWAP_2	// Motorola byte lane steering.
+#define DEBI_TOUT		15	/*  Wait 15 PCI clocks (454 ns) */
+					/*  maximum before timing out. */
+#define DEBI_SWAP		DEBI_CFG_SWAP_2	/*  Motorola byte lane steering. */
 
 #endif
 
-// DEBI page table constants.
-#define DEBI_PAGE_DISABLE	0x00000000	// Paging disable.
+/*  DEBI page table constants. */
+#define DEBI_PAGE_DISABLE	0x00000000	/*  Paging disable. */
 
-///////////////////EXTRA FROM OTHER SANSORAY  * .h////////
+/* ******* EXTRA FROM OTHER SANSORAY  * .h  ******* */
 
-// LoadSrc values:
-#define LOADSRC_INDX		0	// Preload core in response to
-					// Index.
-#define LOADSRC_OVER		1	// Preload core in response to
-					// Overflow.
-#define LOADSRCB_OVERA		2	// Preload B core in response
-					// to A Overflow.
-#define LOADSRC_NONE		3	// Never preload core.
-
-// IntSrc values:
-#define INTSRC_NONE 		0	// Interrupts disabled.
-#define INTSRC_OVER 		1	// Interrupt on Overflow.
-#define INTSRC_INDX 		2	// Interrupt on Index.
-#define INTSRC_BOTH 		3	// Interrupt on Index or Overflow.
-
-// LatchSrc values:
-#define LATCHSRC_AB_READ	0	// Latch on read.
-#define LATCHSRC_A_INDXA	1	// Latch A on A Index.
-#define LATCHSRC_B_INDXB	2	// Latch B on B Index.
-#define LATCHSRC_B_OVERA	3	// Latch B on A Overflow.
-
-// IndxSrc values:
-#define INDXSRC_HARD		0	// Hardware or software index.
-#define INDXSRC_SOFT		1	// Software index only.
-
-// IndxPol values:
-#define INDXPOL_POS 		0	// Index input is active high.
-#define INDXPOL_NEG 		1	// Index input is active low.
-
-// ClkSrc values:
-#define CLKSRC_COUNTER		0	// Counter mode.
-#define CLKSRC_TIMER		2	// Timer mode.
-#define CLKSRC_EXTENDER		3	// Extender mode.
-
-// ClkPol values:
-#define CLKPOL_POS		0	// Counter/Extender clock is
-					// active high.
-#define CLKPOL_NEG		1	// Counter/Extender clock is
-					// active low.
-#define CNTDIR_UP		0	// Timer counts up.
-#define CNTDIR_DOWN 		1	// Timer counts down.
-
-// ClkEnab values:
-#define CLKENAB_ALWAYS		0	// Clock always enabled.
-#define CLKENAB_INDEX		1	// Clock is enabled by index.
-
-// ClkMult values:
-#define CLKMULT_4X 		0	// 4x clock multiplier.
-#define CLKMULT_2X 		1	// 2x clock multiplier.
-#define CLKMULT_1X 		2	// 1x clock multiplier.
-
-// Bit Field positions in COUNTER_SETUP structure:
-#define BF_LOADSRC		9	// Preload trigger.
-#define BF_INDXSRC		7	// Index source.
-#define BF_INDXPOL		6	// Index polarity.
-#define BF_CLKSRC		4	// Clock source.
-#define BF_CLKPOL		3	// Clock polarity/count direction.
-#define BF_CLKMULT		1	// Clock multiplier.
-#define BF_CLKENAB		0	// Clock enable.
-
-// Enumerated counter operating modes specified by ClkSrc bit field in
-// a COUNTER_SETUP.
-
-#define CLKSRC_COUNTER		0	// Counter: ENC_C clock, ENC_D
-					// direction.
-#define CLKSRC_TIMER		2	// Timer: SYS_C clock,
-					// direction specified by
-					// ClkPol.
-#define CLKSRC_EXTENDER		3	// Extender: OVR_A clock,
-					// ENC_D direction.
-
-// Enumerated counter clock multipliers.
-
-#define MULT_X0			0x0003	// Supports no multipliers;
-					// fixed physical multiplier =
-					// 3.
-#define MULT_X1			0x0002	// Supports multiplier x1;
-					// fixed physical multiplier =
-					// 2.
-#define MULT_X2			0x0001	// Supports multipliers x1,
-					// x2; physical multipliers =
-					// 1 or 2.
-#define MULT_X4			0x0000	// Supports multipliers x1,
-					// x2, x4; physical
-					// multipliers = 0, 1 or 2.
+/*  LoadSrc values: */
+#define LOADSRC_INDX		0	/*  Preload core in response to */
+					/*  Index. */
+#define LOADSRC_OVER		1	/*  Preload core in response to */
+					/*  Overflow. */
+#define LOADSRCB_OVERA		2	/*  Preload B core in response */
+					/*  to A Overflow. */
+#define LOADSRC_NONE		3	/*  Never preload core. */
+
+/*  IntSrc values: */
+#define INTSRC_NONE 		0	/*  Interrupts disabled. */
+#define INTSRC_OVER 		1	/*  Interrupt on Overflow. */
+#define INTSRC_INDX 		2	/*  Interrupt on Index. */
+#define INTSRC_BOTH 		3	/*  Interrupt on Index or Overflow. */
+
+/*  LatchSrc values: */
+#define LATCHSRC_AB_READ	0	/*  Latch on read. */
+#define LATCHSRC_A_INDXA	1	/*  Latch A on A Index. */
+#define LATCHSRC_B_INDXB	2	/*  Latch B on B Index. */
+#define LATCHSRC_B_OVERA	3	/*  Latch B on A Overflow. */
+
+/*  IndxSrc values: */
+#define INDXSRC_HARD		0	/*  Hardware or software index. */
+#define INDXSRC_SOFT		1	/*  Software index only. */
+
+/*  IndxPol values: */
+#define INDXPOL_POS 		0	/*  Index input is active high. */
+#define INDXPOL_NEG 		1	/*  Index input is active low. */
+
+/*  ClkSrc values: */
+#define CLKSRC_COUNTER		0	/*  Counter mode. */
+#define CLKSRC_TIMER		2	/*  Timer mode. */
+#define CLKSRC_EXTENDER		3	/*  Extender mode. */
+
+/*  ClkPol values: */
+#define CLKPOL_POS		0	/*  Counter/Extender clock is */
+					/*  active high. */
+#define CLKPOL_NEG		1	/*  Counter/Extender clock is */
+					/*  active low. */
+#define CNTDIR_UP		0	/*  Timer counts up. */
+#define CNTDIR_DOWN 		1	/*  Timer counts down. */
+
+/*  ClkEnab values: */
+#define CLKENAB_ALWAYS		0	/*  Clock always enabled. */
+#define CLKENAB_INDEX		1	/*  Clock is enabled by index. */
+
+/*  ClkMult values: */
+#define CLKMULT_4X 		0	/*  4x clock multiplier. */
+#define CLKMULT_2X 		1	/*  2x clock multiplier. */
+#define CLKMULT_1X 		2	/*  1x clock multiplier. */
+
+/*  Bit Field positions in COUNTER_SETUP structure: */
+#define BF_LOADSRC		9	/*  Preload trigger. */
+#define BF_INDXSRC		7	/*  Index source. */
+#define BF_INDXPOL		6	/*  Index polarity. */
+#define BF_CLKSRC		4	/*  Clock source. */
+#define BF_CLKPOL		3	/*  Clock polarity/count direction. */
+#define BF_CLKMULT		1	/*  Clock multiplier. */
+#define BF_CLKENAB		0	/*  Clock enable. */
+
+/*  Enumerated counter operating modes specified by ClkSrc bit field in */
+/*  a COUNTER_SETUP. */
+
+#define CLKSRC_COUNTER		0	/*  Counter: ENC_C clock, ENC_D */
+					/*  direction. */
+#define CLKSRC_TIMER		2	/*  Timer: SYS_C clock, */
+					/*  direction specified by */
+					/*  ClkPol. */
+#define CLKSRC_EXTENDER		3	/*  Extender: OVR_A clock, */
+					/*  ENC_D direction. */
+
+/*  Enumerated counter clock multipliers. */
+
+#define MULT_X0			0x0003	/*  Supports no multipliers; */
+					/*  fixed physical multiplier = */
+					/*  3. */
+#define MULT_X1			0x0002	/*  Supports multiplier x1; */
+					/*  fixed physical multiplier = */
+					/*  2. */
+#define MULT_X2			0x0001	/*  Supports multipliers x1, */
+					/*  x2; physical multipliers = */
+					/*  1 or 2. */
+#define MULT_X4			0x0000	/*  Supports multipliers x1, */
+					/*  x2, x4; physical */
+					/*  multipliers = 0, 1 or 2. */
 
-// Sanity-check limits for parameters.
+/*  Sanity-check limits for parameters. */
 
-#define NUM_COUNTERS		6	// Maximum valid counter
-					// logical channel number.
+#define NUM_COUNTERS		6	/*  Maximum valid counter */
+					/*  logical channel number. */
 #define NUM_INTSOURCES		4
 #define NUM_LATCHSOURCES	4
 #define NUM_CLKMULTS		4
@@ -708,33 +653,33 @@
 #define NUM_INDEXSOURCES	2
 #define NUM_LOADTRIGS		4
 
-// Bit field positions in CRA and CRB counter control registers.
+/*  Bit field positions in CRA and CRB counter control registers. */
 
-// Bit field positions in CRA:
-#define CRABIT_INDXSRC_B	14	//   B index source.
-#define CRABIT_CLKSRC_B		12	//   B clock source.
-#define CRABIT_INDXPOL_A	11	//   A index polarity.
-#define CRABIT_LOADSRC_A	 9	//   A preload trigger.
-#define CRABIT_CLKMULT_A	 7	//   A clock multiplier.
-#define CRABIT_INTSRC_A		 5	//   A interrupt source.
-#define CRABIT_CLKPOL_A		 4	//   A clock polarity.
-#define CRABIT_INDXSRC_A	 2	//   A index source.
-#define CRABIT_CLKSRC_A		 0	//   A clock source.
-
-// Bit field positions in CRB:
-#define CRBBIT_INTRESETCMD	15	//   Interrupt reset command.
-#define CRBBIT_INTRESET_B	14	//   B interrupt reset enable.
-#define CRBBIT_INTRESET_A	13	//   A interrupt reset enable.
-#define CRBBIT_CLKENAB_A	12	//   A clock enable.
-#define CRBBIT_INTSRC_B		10	//   B interrupt source.
-#define CRBBIT_LATCHSRC		 8	//   A/B latch source.
-#define CRBBIT_LOADSRC_B	 6	//   B preload trigger.
-#define CRBBIT_CLKMULT_B	 3	//   B clock multiplier.
-#define CRBBIT_CLKENAB_B	 2	//   B clock enable.
-#define CRBBIT_INDXPOL_B	 1	//   B index polarity.
-#define CRBBIT_CLKPOL_B		 0	//   B clock polarity.
+/*  Bit field positions in CRA: */
+#define CRABIT_INDXSRC_B	14	/*    B index source. */
+#define CRABIT_CLKSRC_B		12	/*    B clock source. */
+#define CRABIT_INDXPOL_A	11	/*    A index polarity. */
+#define CRABIT_LOADSRC_A	 9	/*    A preload trigger. */
+#define CRABIT_CLKMULT_A	 7	/*    A clock multiplier. */
+#define CRABIT_INTSRC_A		 5	/*    A interrupt source. */
+#define CRABIT_CLKPOL_A		 4	/*    A clock polarity. */
+#define CRABIT_INDXSRC_A	 2	/*    A index source. */
+#define CRABIT_CLKSRC_A		 0	/*    A clock source. */
+
+/*  Bit field positions in CRB: */
+#define CRBBIT_INTRESETCMD	15	/*    Interrupt reset command. */
+#define CRBBIT_INTRESET_B	14	/*    B interrupt reset enable. */
+#define CRBBIT_INTRESET_A	13	/*    A interrupt reset enable. */
+#define CRBBIT_CLKENAB_A	12	/*    A clock enable. */
+#define CRBBIT_INTSRC_B		10	/*    B interrupt source. */
+#define CRBBIT_LATCHSRC		 8	/*    A/B latch source. */
+#define CRBBIT_LOADSRC_B	 6	/*    B preload trigger. */
+#define CRBBIT_CLKMULT_B	 3	/*    B clock multiplier. */
+#define CRBBIT_CLKENAB_B	 2	/*    B clock enable. */
+#define CRBBIT_INDXPOL_B	 1	/*    B index polarity. */
+#define CRBBIT_CLKPOL_B		 0	/*    B clock polarity. */
 
-// Bit field masks for CRA and CRB.
+/*  Bit field masks for CRA and CRB. */
 
 #define CRAMSK_INDXSRC_B	( (uint16_t)( 3 << CRABIT_INDXSRC_B) )
 #define CRAMSK_CLKSRC_B		( (uint16_t)( 3 << CRABIT_CLKSRC_B) )
@@ -758,9 +703,9 @@
 #define CRBMSK_INDXPOL_B	( (uint16_t)( 1 << CRBBIT_INDXPOL_B) )
 #define CRBMSK_CLKPOL_B		( (uint16_t)( 1 << CRBBIT_CLKPOL_B) )
 
-#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	// Interrupt reset control bits.
+#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	/*  Interrupt reset control bits. */
 
-// Bit field positions for standardized SETUP structure.
+/*  Bit field positions for standardized SETUP structure. */
 
 #define STDBIT_INTSRC		13
 #define STDBIT_LATCHSRC		11
@@ -772,7 +717,7 @@
 #define STDBIT_CLKMULT		 1
 #define STDBIT_CLKENAB		 0
 
-// Bit field masks for standardized SETUP structure.
+/*  Bit field masks for standardized SETUP structure. */
 
 #define STDMSK_INTSRC		( (uint16_t)( 3 << STDBIT_INTSRC   ) )
 #define STDMSK_LATCHSRC		( (uint16_t)( 3 << STDBIT_LATCHSRC ) )
@@ -784,7 +729,6 @@
 #define STDMSK_CLKMULT		( (uint16_t)( 3 << STDBIT_CLKMULT  ) )
 #define STDMSK_CLKENAB		( (uint16_t)( 1 << STDBIT_CLKENAB  ) )
 
-//////////////////////////////////////////////////////////
 
 /* typedef struct indexCounter */
 /* { */
--- a/drivers/staging/comedi/pci_ids.h
+++ b/drivers/staging/comedi/pci_ids.h
@@ -28,4 +28,4 @@
 #define PCI_DEVICE_ID_QUANCOM_GPIB	0x3302
 #endif
 
-#endif // __COMPAT_LINUX_PCI_IDS_H
+#endif /* __COMPAT_LINUX_PCI_IDS_H */
--- a/drivers/staging/comedi/proc.c
+++ b/drivers/staging/comedi/proc.c
@@ -31,7 +31,7 @@
 #define __NO_VERSION__
 #include "comedidev.h"
 #include <linux/proc_fs.h>
-//#include <linux/string.h>
+/* #include <linux/string.h> */
 
 int comedi_read_procmem(char *buf, char **start, off_t offset, int len,
 	int *eof, void *data);
--- a/drivers/staging/comedi/range.c
+++ b/drivers/staging/comedi/range.c
@@ -88,7 +88,7 @@ static int aref_invalid(comedi_subdevice
 {
 	unsigned int aref;
 
-	// disable reporting invalid arefs... maybe someday
+	/*  disable reporting invalid arefs... maybe someday */
 	return 0;
 
 	aref = CR_AREF(chanspec);
--- a/drivers/staging/comedi/rt.c
+++ b/drivers/staging/comedi/rt.c
@@ -78,7 +78,7 @@ int comedi_request_irq(unsigned irq, irq
 
 	ret = request_irq(irq, handler, unshared_flags, device, dev_id);
 	if (ret < 0) {
-		// we failed, so fall back on allowing shared interrupt (which we won't ever make RT)
+		/*  we failed, so fall back on allowing shared interrupt (which we won't ever make RT) */
 		if (flags & IRQF_SHARED) {
 			rt_printk
 				("comedi: cannot get unshared interrupt, will not use RT interrupts.\n");
@@ -192,7 +192,7 @@ static void handle_void_irq(int irq)
 		return;
 	}
 	it->handler(irq, it->dev_id PT_REGS_NULL);
-	rt_enable_irq(irq);	//needed by rtai-adeos, seems like it shouldn't hurt earlier versions
+	rt_enable_irq(irq);	/* needed by rtai-adeos, seems like it shouldn't hurt earlier versions */
 }
 
 DECLARE_VOID_IRQ(0);
@@ -402,11 +402,11 @@ static int comedi_rt_release_irq(struct 
 
 void comedi_rt_init(void)
 {
-	//rt_pend_tq_init();
+	/* rt_pend_tq_init(); */
 }
 
 void comedi_rt_cleanup(void)
 {
-	//rt_pend_tq_cleanup();
+	/* rt_pend_tq_cleanup(); */
 }
 #endif
--- a/drivers/staging/comedi/rt_pend_tq.c
+++ b/drivers/staging/comedi/rt_pend_tq.c
@@ -3,7 +3,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
-#include "comedidev.h"	// for rt spinlocks
+#include "comedidev.h"	/* for rt spinlocks */
 #include "rt_pend_tq.h"
 #ifdef CONFIG_COMEDI_RTAI
 #include <rtai.h>
@@ -27,7 +27,7 @@ volatile static struct rt_pend_tq *volat
 int rt_pend_tq_irq = 0;
 DEFINE_SPINLOCK(rt_pend_tq_lock);
 
-// WARNING: following code not checked against race conditions yet.
+/* WARNING: following code not checked against race conditions yet. */
 #define INC_CIRCULAR_PTR(ptr,begin,size) do {if(++(ptr)>=(begin)+(size)) (ptr)=(begin); } while(0)
 #define DEC_CIRCULAR_PTR(ptr,begin,size) do {if(--(ptr)<(begin)) (ptr)=(begin)+(size)-1; } while(0)
 
@@ -42,7 +42,7 @@ int rt_pend_call(void (*func) (int arg1,
 	comedi_spin_lock_irqsave(&rt_pend_tq_lock, flags);
 	INC_CIRCULAR_PTR(rt_pend_head, rt_pend_tq, RT_PEND_TQ_SIZE);
 	if (rt_pend_head == rt_pend_tail) {
-		// overflow, we just refuse to take this request
+		/* overflow, we just refuse to take this request */
 		DEC_CIRCULAR_PTR(rt_pend_head, rt_pend_tq, RT_PEND_TQ_SIZE);
 		comedi_spin_unlock_irqrestore(&rt_pend_tq_lock, flags);
 		return -EAGAIN;
