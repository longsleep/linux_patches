From wfp5p@virginia.edu  Wed Jul 29 14:30:58 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Wed, 29 Jul 2009 17:00:12 -0400
Subject: Staging: hv: remove wrapper functions for atomic operations
To: greg@kroah.com
Cc: hjanssen@microsoft.com
Message-ID: <1248901215-29685-5-git-send-email-wfp5p@virginia.edu>


Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Cc: Hank Janssen <hjanssen@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/hv/Channel.c      |    4 +--
 drivers/staging/hv/Connection.c   |    2 -
 drivers/staging/hv/NetVsc.c       |   34 ++++++++++++--------------------
 drivers/staging/hv/NetVsc.h       |    5 +---
 drivers/staging/hv/RndisFilter.c  |    6 ++---
 drivers/staging/hv/StorVsc.c      |   40 +++++++++++++++-----------------------
 drivers/staging/hv/VmbusPrivate.h |    2 -
 drivers/staging/hv/include/osd.h  |    4 ---
 drivers/staging/hv/osd.c          |   20 -------------------
 drivers/staging/hv/vmbus_drv.c    |    4 +--
 10 files changed, 40 insertions(+), 81 deletions(-)

--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -540,8 +540,8 @@ VmbusChannelEstablishGpadl(
 
 	DPRINT_ENTER(VMBUS);
 
-	nextGpadlHandle = gVmbusConnection.NextGpadlHandle;
-	InterlockedIncrement((int*)&gVmbusConnection.NextGpadlHandle);
+	nextGpadlHandle = atomic_read(&gVmbusConnection.NextGpadlHandle);
+	atomic_inc(&gVmbusConnection.NextGpadlHandle);
 
 	VmbusChannelCreateGpadlHeader(Kbuffer, Size, &msgInfo, &msgCount);
 	ASSERT(msgInfo != NULL);
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -31,7 +31,7 @@
 
 struct VMBUS_CONNECTION gVmbusConnection = {
 	.ConnectState		= Disconnected,
-	.NextGpadlHandle	= 0xE1E10,
+	.NextGpadlHandle	= ATOMIC_INIT(0xE1E10),
 };
 
 
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -109,10 +109,6 @@ static inline void do_cpuid(unsigned int
 
 /* Osd routines */
 
-extern int InterlockedIncrement(int *val);
-extern int InterlockedDecrement(int *val);
-extern int InterlockedCompareExchange(int *val, int new, int curr);
-
 extern void* VirtualAllocExec(unsigned int size);
 extern void VirtualFree(void* VirtAddr);
 
--- a/drivers/staging/hv/NetVsc.c
+++ b/drivers/staging/hv/NetVsc.c
@@ -122,7 +122,7 @@ static inline struct NETVSC_DEVICE *Allo
 		return NULL;
 
 	/* Set to 2 to allow both inbound and outbound traffic */
-	InterlockedCompareExchange(&netDevice->RefCount, 2, 0);
+	atomic_cmpxchg(&netDevice->RefCount, 0, 2);
 
 	netDevice->Device = Device;
 	Device->Extension = netDevice;
@@ -132,7 +132,7 @@ static inline struct NETVSC_DEVICE *Allo
 
 static inline void FreeNetDevice(struct NETVSC_DEVICE *Device)
 {
-	ASSERT(Device->RefCount == 0);
+	ASSERT(atomic_read(&Device->RefCount) == 0);
 	Device->Device->Extension = NULL;
 	kfree(Device);
 }
@@ -144,14 +144,10 @@ static inline struct NETVSC_DEVICE *GetO
 	struct NETVSC_DEVICE *netDevice;
 
 	netDevice = (struct NETVSC_DEVICE*)Device->Extension;
-	if (netDevice && netDevice->RefCount > 1)
-	{
-		InterlockedIncrement(&netDevice->RefCount);
-	}
+	if (netDevice && atomic_read(&netDevice->RefCount) > 1)
+		atomic_inc(&netDevice->RefCount);
 	else
-	{
 		netDevice = NULL;
-	}
 
 	return netDevice;
 }
@@ -162,14 +158,10 @@ static inline struct NETVSC_DEVICE *GetI
 	struct NETVSC_DEVICE *netDevice;
 
 	netDevice = (struct NETVSC_DEVICE*)Device->Extension;
-	if (netDevice && netDevice->RefCount)
-	{
-		InterlockedIncrement(&netDevice->RefCount);
-	}
+	if (netDevice && atomic_read(&netDevice->RefCount))
+		atomic_inc(&netDevice->RefCount);
 	else
-	{
 		netDevice = NULL;
-	}
 
 	return netDevice;
 }
@@ -181,7 +173,7 @@ static inline void PutNetDevice(struct h
 	netDevice = (struct NETVSC_DEVICE*)Device->Extension;
 	ASSERT(netDevice);
 
-	InterlockedDecrement(&netDevice->RefCount);
+	atomic_dec(&netDevice->RefCount);
 }
 
 static inline struct NETVSC_DEVICE *ReleaseOutboundNetDevice(struct hv_device *Device)
@@ -193,7 +185,7 @@ static inline struct NETVSC_DEVICE *Rele
 		return NULL;
 
 	/* Busy wait until the ref drop to 2, then set it to 1 */
-	while (InterlockedCompareExchange(&netDevice->RefCount, 1, 2) != 2)
+	while (atomic_cmpxchg(&netDevice->RefCount, 2, 1) != 2)
 	{
 		udelay(100);
 	}
@@ -210,7 +202,7 @@ static inline struct NETVSC_DEVICE *Rele
 		return NULL;
 
 	/* Busy wait until the ref drop to 1, then set it to 0 */
-	while (InterlockedCompareExchange(&netDevice->RefCount, 0, 1) != 1)
+	while (atomic_cmpxchg(&netDevice->RefCount, 1, 0) != 1)
 	{
 		udelay(100);
 	}
@@ -932,9 +924,9 @@ NetVscOnDeviceRemove(
 	}
 
 	/* Wait for all send completions */
-	while (netDevice->NumOutstandingSends)
+	while (atomic_read(&netDevice->NumOutstandingSends))
 	{
-		DPRINT_INFO(NETVSC, "waiting for %d requests to complete...", netDevice->NumOutstandingSends);
+		DPRINT_INFO(NETVSC, "waiting for %d requests to complete...", atomic_read(&netDevice->NumOutstandingSends));
 
 		udelay(100);
 	}
@@ -1032,7 +1024,7 @@ NetVscOnSendCompletion(
 		/* Notify the layer above us */
 		nvscPacket->Completion.Send.OnSendCompletion(nvscPacket->Completion.Send.SendCompletionContext);
 
-		InterlockedDecrement(&netDevice->NumOutstandingSends);
+		atomic_dec(&netDevice->NumOutstandingSends);
 	}
 	else
 	{
@@ -1101,7 +1093,7 @@ NetVscOnSend(
 		DPRINT_ERR(NETVSC, "Unable to send packet %p ret %d", Packet, ret);
 	}
 
-	InterlockedIncrement(&netDevice->NumOutstandingSends);
+	atomic_inc(&netDevice->NumOutstandingSends);
 	PutNetDevice(Device);
 
 	DPRINT_EXIT(NETVSC);
--- a/drivers/staging/hv/NetVsc.h
+++ b/drivers/staging/hv/NetVsc.h
@@ -57,9 +57,8 @@
 struct NETVSC_DEVICE {
 	struct hv_device *Device;
 
-	int								RefCount;
-
-	int								NumOutstandingSends;
+	atomic_t RefCount;
+	atomic_t NumOutstandingSends;
 	/* List of free preallocated hv_netvsc_packet to represent receive packet */
 	LIST_ENTRY						ReceivePacketList;
 	spinlock_t receive_packet_list_lock;
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -56,26 +56,6 @@ struct osd_callback_struct {
 	void *data;
 };
 
-int InterlockedIncrement(int *val)
-{
-	return atomic_inc_return((atomic_t*)val);
-}
-
-int InterlockedDecrement(int *val)
-{
-	return atomic_dec_return((atomic_t*)val);
-}
-
-#ifndef atomic_cmpxchg
-#define atomic_cmpxchg(v, old, new) ((int)cmpxchg(&((v)->counter), old, new))
-#endif
-int InterlockedCompareExchange(int *val, int new, int curr)
-{
-	/* return ((int)cmpxchg(((atomic_t*)val), curr, new)); */
-	return atomic_cmpxchg((atomic_t*)val, curr, new);
-
-}
-
 void* VirtualAllocExec(unsigned int size)
 {
 #ifdef __x86_64__
--- a/drivers/staging/hv/RndisFilter.c
+++ b/drivers/staging/hv/RndisFilter.c
@@ -50,7 +50,7 @@ typedef struct _RNDIS_DEVICE {
 
 	RNDIS_DEVICE_STATE		State;
 	u32					LinkStatus;
-	u32					NewRequestId;
+	atomic_t NewRequestId;
 
 	spinlock_t request_lock;
 	LIST_ENTRY				RequestList;
@@ -255,7 +255,7 @@ static inline RNDIS_REQUEST* GetRndisReq
 	/* Set the request id. This field is always after the rndis header for request/response packet types so */
 	/* we just used the SetRequest as a template */
 	set = &rndisMessage->Message.SetRequest;
-	set->RequestId = InterlockedIncrement((int*)&Device->NewRequestId);
+	set->RequestId = atomic_inc_return(&Device->NewRequestId);
 
 	/* Add to the request list */
 	spin_lock_irqsave(&Device->request_lock, flags);
@@ -863,7 +863,7 @@ RndisFilterHaltDevice(
 
 	/* Setup the rndis set */
 	halt = &request->RequestMessage.Message.HaltRequest;
-	halt->RequestId = InterlockedIncrement((int*)&Device->NewRequestId);
+	halt->RequestId = atomic_inc_return(&Device->NewRequestId);
 
 	/* Ignore return since this msg is optional. */
 	RndisFilterSendRequest(Device, request);
--- a/drivers/staging/hv/StorVsc.c
+++ b/drivers/staging/hv/StorVsc.c
@@ -57,9 +57,9 @@ typedef struct _STORVSC_REQUEST_EXTENSIO
 typedef struct _STORVSC_DEVICE{
 	struct hv_device *Device;
 
-	int							RefCount; /* 0 indicates the device is being destroyed */
+	atomic_t RefCount; /* 0 indicates the device is being destroyed */
 
-	int							NumOutstandingRequests;
+	atomic_t NumOutstandingRequests;
 
 	/*
 	 * Each unique Port/Path/Target represents 1 channel ie scsi
@@ -155,7 +155,7 @@ static inline STORVSC_DEVICE* AllocStorD
 
 	/* Set to 2 to allow both inbound and outbound traffics */
 	/* (ie GetStorDevice() and MustGetStorDevice()) to proceed. */
-	InterlockedCompareExchange(&storDevice->RefCount, 2, 0);
+	atomic_cmpxchg(&storDevice->RefCount, 0, 2);
 
 	storDevice->Device = Device;
 	Device->Extension = storDevice;
@@ -165,7 +165,7 @@ static inline STORVSC_DEVICE* AllocStorD
 
 static inline void FreeStorDevice(STORVSC_DEVICE *Device)
 {
-	ASSERT(Device->RefCount == 0);
+	ASSERT( atomic_read(&Device->RefCount) == 0);
 	kfree(Device);
 }
 
@@ -175,14 +175,10 @@ static inline STORVSC_DEVICE* GetStorDev
 	STORVSC_DEVICE *storDevice;
 
 	storDevice = (STORVSC_DEVICE*)Device->Extension;
-	if (storDevice && storDevice->RefCount > 1)
-	{
-		InterlockedIncrement(&storDevice->RefCount);
-	}
+	if (storDevice && atomic_read(&storDevice->RefCount) > 1)
+		atomic_inc(&storDevice->RefCount);
 	else
-	{
 		storDevice = NULL;
-	}
 
 	return storDevice;
 }
@@ -193,14 +189,10 @@ static inline STORVSC_DEVICE* MustGetSto
 	STORVSC_DEVICE *storDevice;
 
 	storDevice = (STORVSC_DEVICE*)Device->Extension;
-	if (storDevice && storDevice->RefCount)
-	{
-		InterlockedIncrement(&storDevice->RefCount);
-	}
+	if (storDevice && atomic_read(&storDevice->RefCount))
+		atomic_inc(&storDevice->RefCount);
 	else
-	{
 		storDevice = NULL;
-	}
 
 	return storDevice;
 }
@@ -212,8 +204,8 @@ static inline void PutStorDevice(struct 
 	storDevice = (STORVSC_DEVICE*)Device->Extension;
 	ASSERT(storDevice);
 
-	InterlockedDecrement(&storDevice->RefCount);
-	ASSERT(storDevice->RefCount);
+	atomic_dec(&storDevice->RefCount);
+	ASSERT(atomic_read(&storDevice->RefCount));
 }
 
 /* Drop ref count to 1 to effectively disable GetStorDevice() */
@@ -225,7 +217,7 @@ static inline STORVSC_DEVICE* ReleaseSto
 	ASSERT(storDevice);
 
 	/* Busy wait until the ref drop to 2, then set it to 1 */
-	while (InterlockedCompareExchange(&storDevice->RefCount, 1, 2) != 2)
+	while (atomic_cmpxchg(&storDevice->RefCount, 2, 1) != 2)
 	{
 		udelay(100);
 	}
@@ -242,7 +234,7 @@ static inline STORVSC_DEVICE* FinalRelea
 	ASSERT(storDevice);
 
 	/* Busy wait until the ref drop to 1, then set it to 0 */
-	while (InterlockedCompareExchange(&storDevice->RefCount, 0, 1) != 1)
+	while (atomic_cmpxchg(&storDevice->RefCount, 1, 0) != 1)
 	{
 		udelay(100);
 	}
@@ -591,9 +583,9 @@ StorVscOnDeviceRemove(
 	 * only allow inbound traffic (responses) to proceed so that
 	 * outstanding requests can be completed.
 	 */
-	while (storDevice->NumOutstandingRequests)
+	while (atomic_read(&storDevice->NumOutstandingRequests))
 	{
-		DPRINT_INFO(STORVSC, "waiting for %d requests to complete...", storDevice->NumOutstandingRequests);
+		DPRINT_INFO(STORVSC, "waiting for %d requests to complete...", atomic_read(&storDevice->NumOutstandingRequests));
 
 		udelay(100);
 	}
@@ -788,7 +780,7 @@ StorVscOnIORequest(
 		DPRINT_DBG(STORVSC, "Unable to send packet %p ret %d", vstorPacket, ret);
 	}
 
-	InterlockedIncrement(&storDevice->NumOutstandingRequests);
+	atomic_inc(&storDevice->NumOutstandingRequests);
 
 	PutStorDevice(Device);
 
@@ -877,7 +869,7 @@ StorVscOnIOCompletion(
 
 	request->OnIOCompletion(request);
 
-	InterlockedDecrement(&storDevice->NumOutstandingRequests);
+	atomic_dec(&storDevice->NumOutstandingRequests);
 
 	PutStorDevice(Device);
 
--- a/drivers/staging/hv/vmbus_drv.c
+++ b/drivers/staging/hv/vmbus_drv.c
@@ -606,7 +606,7 @@ static int vmbus_child_device_register(s
 	int ret=0;
 	struct device_context *root_device_ctx = to_device_context(root_device_obj);
 	struct device_context *child_device_ctx = to_device_context(child_device_obj);
-	static int device_num=0;
+	static atomic_t device_num = ATOMIC_INIT(0);
 
 	DPRINT_ENTER(VMBUS_DRV);
 
@@ -623,7 +623,7 @@ static int vmbus_child_device_register(s
 	}
 
 	/* Set the device bus id. Otherwise, device_register()will fail. */
-	dev_set_name(&child_device_ctx->device, "vmbus_0_%d", InterlockedIncrement(&device_num));
+	dev_set_name(&child_device_ctx->device, "vmbus_0_%d", atomic_inc_return(&device_num));
 
 	/* The new device belongs to this bus */
 	child_device_ctx->device.bus = &g_vmbus_drv.bus; /* device->dev.bus; */
--- a/drivers/staging/hv/VmbusPrivate.h
+++ b/drivers/staging/hv/VmbusPrivate.h
@@ -67,7 +67,7 @@ struct VMBUS_CONNECTION {
 
 	enum VMBUS_CONNECT_STATE					ConnectState;
 
-	u32								NextGpadlHandle;
+	atomic_t NextGpadlHandle;
 
 	/*
 	 * Represents channel interrupts. Each bit position represents
