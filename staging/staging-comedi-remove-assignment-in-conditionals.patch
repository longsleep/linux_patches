From wfp5p@virginia.edu  Fri Apr 24 17:00:22 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Wed, 22 Apr 2009 21:11:47 -0400
Subject: Staging: comedi: remove assignment in conditionals
To: greg@kroah.com
Cc: abbotti@mev.co.uk, fmhess@users.sourceforge.net, ds@schleef.org, Bill Pemberton <wfp5p@virginia.edu>
Message-ID: <1240449109-18760-2-git-send-email-wfp5p@virginia.edu>


Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/comedi/drivers/8255.c                     |    3 
 drivers/staging/comedi/drivers/addi-data/addi_common.c    |   28 +
 drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h  |    5 
 drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.c |    5 
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.c |  201 +++++++-------
 drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c |    4 
 drivers/staging/comedi/drivers/adl_pci9111.c              |    3 
 drivers/staging/comedi/drivers/adl_pci9118.c              |   27 +
 drivers/staging/comedi/drivers/adv_pci1710.c              |    6 
 drivers/staging/comedi/drivers/adv_pci1723.c              |    6 
 drivers/staging/comedi/drivers/adv_pci_dio.c              |   24 +
 drivers/staging/comedi/drivers/amplc_dio200.c             |   10 
 drivers/staging/comedi/drivers/amplc_pc236.c              |   16 -
 drivers/staging/comedi/drivers/amplc_pc263.c              |   12 
 drivers/staging/comedi/drivers/amplc_pci224.c             |   15 -
 drivers/staging/comedi/drivers/cb_das16_cs.c              |   29 +-
 drivers/staging/comedi/drivers/cb_pcimdda.c               |    3 
 drivers/staging/comedi/drivers/comedi_rt_timer.c          |    7 
 drivers/staging/comedi/drivers/daqboard2000.c             |    3 
 drivers/staging/comedi/drivers/das08.c                    |    6 
 drivers/staging/comedi/drivers/das08_cs.c                 |   41 ++
 drivers/staging/comedi/drivers/das16.c                    |   12 
 drivers/staging/comedi/drivers/das16m1.c                  |    7 
 drivers/staging/comedi/drivers/das6402.c                  |    6 
 drivers/staging/comedi/drivers/dt2801.c                   |    6 
 drivers/staging/comedi/drivers/dt2811.c                   |    8 
 drivers/staging/comedi/drivers/dt2814.c                   |    7 
 drivers/staging/comedi/drivers/dt2817.c                   |    3 
 drivers/staging/comedi/drivers/dt282x.c                   |   10 
 drivers/staging/comedi/drivers/dt3000.c                   |    9 
 drivers/staging/comedi/drivers/ii_pci20kc.c               |    7 
 drivers/staging/comedi/drivers/jr3_pci.c                  |    5 
 drivers/staging/comedi/drivers/ke_counter.c               |   11 
 drivers/staging/comedi/drivers/ni_6527.c                  |    6 
 drivers/staging/comedi/drivers/ni_65xx.c                  |    6 
 drivers/staging/comedi/drivers/ni_660x.c                  |   12 
 drivers/staging/comedi/drivers/ni_670x.c                  |    3 
 drivers/staging/comedi/drivers/ni_atmio.c                 |   13 
 drivers/staging/comedi/drivers/ni_atmio16d.c              |   21 -
 drivers/staging/comedi/drivers/ni_daq_700.c               |   28 +
 drivers/staging/comedi/drivers/ni_daq_dio24.c             |   29 +-
 drivers/staging/comedi/drivers/ni_labpc_cs.c              |   27 +
 drivers/staging/comedi/drivers/ni_mio_cs.c                |   14 
 drivers/staging/comedi/drivers/ni_pcimio.c                |    7 
 drivers/staging/comedi/drivers/pcl711.c                   |    7 
 drivers/staging/comedi/drivers/pcl724.c                   |    3 
 drivers/staging/comedi/drivers/pcl726.c                   |    6 
 drivers/staging/comedi/drivers/pcl812.c                   |    6 
 drivers/staging/comedi/drivers/pcl816.c                   |    7 
 drivers/staging/comedi/drivers/pcl818.c                   |    6 
 drivers/staging/comedi/drivers/pcm3724.c                  |    7 
 drivers/staging/comedi/drivers/pcmad.c                    |    7 
 drivers/staging/comedi/drivers/pcmmio.c                   |    6 
 drivers/staging/comedi/drivers/pcmuio.c                   |    6 
 drivers/staging/comedi/drivers/quatech_daqp_cs.c          |   31 +-
 drivers/staging/comedi/drivers/rti800.c                   |   12 
 drivers/staging/comedi/drivers/unioxx5.c                  |   14 
 57 files changed, 534 insertions(+), 295 deletions(-)

--- a/drivers/staging/comedi/drivers/8255.c
+++ b/drivers/staging/comedi/drivers/8255.c
@@ -394,7 +394,8 @@ static int dev_8255_attach(struct comedi
 		return -EINVAL;
 	}
 
-	if ((ret = alloc_subdevices(dev, i)) < 0)
+	ret = alloc_subdevices(dev, i);
+	if (ret < 0)
 		return ret;
 
 	for (i = 0; i < dev->n_subdevices; i++) {
--- a/drivers/staging/comedi/drivers/addi-data/addi_common.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_common.c
@@ -2575,9 +2575,9 @@ static int i_ADDI_Attach(struct comedi_d
 	sprintf(c_Identifier, "Addi-Data GmbH Comedi %s",
 		this_board->pc_DriverName);
 
-	if ((ret = alloc_private(dev, sizeof(struct addi_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct addi_private));
+	if (ret < 0)
 		return -ENOMEM;
-	}
 
 	if (!pci_list_builded) {
 		v_pci_card_list_init(this_board->i_VendorId, 1);	/* 1 for displaying the list.. */
@@ -2589,12 +2589,14 @@ static int i_ADDI_Attach(struct comedi_d
 		i_Dma = 1;
 	}
 
-	if ((card = ptr_select_and_alloc_pci_card(this_board->i_VendorId,
-				this_board->i_DeviceId,
-				it->options[0],
-				it->options[1], i_Dma)) == NULL) {
+	card = ptr_select_and_alloc_pci_card(this_board->i_VendorId,
+					     this_board->i_DeviceId,
+					     it->options[0],
+					     it->options[1], i_Dma);
+
+	if (card == NULL)
 		return -EIO;
-	}
+
 	devpriv->allocated = 1;
 
 	if ((i_pci_card_data(card, &pci_bus, &pci_slot, &pci_func, &io_addr[0],
@@ -2698,12 +2700,11 @@ static int i_ADDI_Attach(struct comedi_d
 			devpriv->b_DmaDoubleBuffer = 0;
 			for (i = 0; i < 2; i++) {
 				for (pages = 4; pages >= 0; pages--) {
-					if ((devpriv->ul_DmaBufferVirtual[i] =
-							(void *)
-							__get_free_pages
-							(GFP_KERNEL, pages))) {
+					devpriv->ul_DmaBufferVirtual[i] =
+						(void *) __get_free_pages(GFP_KERNEL, pages);
+
+					if (devpriv->ul_DmaBufferVirtual[i])
 						break;
-					}
 				}
 				if (devpriv->ul_DmaBufferVirtual[i]) {
 					devpriv->ui_DmaBufferPages[i] = pages;
@@ -2745,7 +2746,8 @@ static int i_ADDI_Attach(struct comedi_d
 	} else {
 		/* Update-0.7.57->0.7.68dev->n_subdevices = 7; */
 		n_subdevices = 7;
-		if ((ret = alloc_subdevices(dev, n_subdevices)) < 0)
+		ret = alloc_subdevices(dev, n_subdevices);
+		if (ret < 0)
 			return ret;
 
 		/*  Allocate and Initialise AI Subdevice Structures */
--- a/drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h
+++ b/drivers/staging/comedi/drivers/addi-data/amcc_s5933_58.h
@@ -423,9 +423,8 @@ struct pcilst_struct *ptr_select_and_all
 	struct pcilst_struct *card;
 
 	if ((pci_bus < 1) & (pci_slot < 1)) {	/*  use autodetection */
-		if ((card = ptr_find_free_pci_card_by_device(vendor_id,
-							     device_id)) ==
-		    NULL) {
+		card = ptr_find_free_pci_card_by_device(vendor_id, device_id);
+		if (card == NULL) {
 			rt_printk(" - Unused card not found in system!\n");
 			return NULL;
 		}
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.c
@@ -975,96 +975,117 @@ static void v_APCI1564_Interrupt(int irq
 
 	}			/*  if  (ui_DO) */
 
-	if ((ui_Timer == 1) && (devpriv->b_TimerSelectMode = ADDIDATA_TIMER)) {
-		/*  Disable Timer Interrupt */
-		ul_Command2 =
-			inl(devpriv->i_IobaseAmcc + APCI1564_TIMER +
-			APCI1564_TCW_PROG);
-		outl(0x0,
-			devpriv->i_IobaseAmcc + APCI1564_TIMER +
-			APCI1564_TCW_PROG);
-
-		/* Send a signal to from kernel to user space */
-		send_sig(SIGIO, devpriv->tsk_Current, 0);
-
-		/*  Enable Timer Interrupt */
-
-		outl(ul_Command2,
-			devpriv->i_IobaseAmcc + APCI1564_TIMER +
-			APCI1564_TCW_PROG);
-	}			/*  if  ((ui_Timer == 1) && (devpriv->b_TimerSelectMode =ADDIDATA_TIMER)) */
-
-	if ((ui_C1 == 1) && (devpriv->b_TimerSelectMode = ADDIDATA_COUNTER)) {
-		/*  Disable Counter Interrupt */
-		ul_Command2 =
-			inl(devpriv->iobase + APCI1564_COUNTER1 +
-			APCI1564_TCW_PROG);
-		outl(0x0,
-			devpriv->iobase + APCI1564_COUNTER1 +
-			APCI1564_TCW_PROG);
-
-		/* Send a signal to from kernel to user space */
-		send_sig(SIGIO, devpriv->tsk_Current, 0);
-
-		/*  Enable Counter Interrupt */
-		outl(ul_Command2,
-			devpriv->iobase + APCI1564_COUNTER1 +
-			APCI1564_TCW_PROG);
-	}			/*  if  ((ui_C1 == 1) && (devpriv->b_TimerSelectMode = ADDIDATA_COUNTER)) */
-
-	if ((ui_C2 == 1) && (devpriv->b_TimerSelectMode = ADDIDATA_COUNTER)) {
-		/*  Disable Counter Interrupt */
-		ul_Command2 =
-			inl(devpriv->iobase + APCI1564_COUNTER2 +
-			APCI1564_TCW_PROG);
-		outl(0x0,
-			devpriv->iobase + APCI1564_COUNTER2 +
-			APCI1564_TCW_PROG);
-
-		/* Send a signal to from kernel to user space */
-		send_sig(SIGIO, devpriv->tsk_Current, 0);
-
-		/*  Enable Counter Interrupt */
-		outl(ul_Command2,
-			devpriv->iobase + APCI1564_COUNTER2 +
-			APCI1564_TCW_PROG);
-	}			/*  if  ((ui_C2 == 1) && (devpriv->b_TimerSelectMode =ADDIDATA_COUNTER)) */
-
-	if ((ui_C3 == 1) && (devpriv->b_TimerSelectMode = ADDIDATA_COUNTER)) {
-		/*  Disable Counter Interrupt */
-		ul_Command2 =
-			inl(devpriv->iobase + APCI1564_COUNTER3 +
-			APCI1564_TCW_PROG);
-		outl(0x0,
-			devpriv->iobase + APCI1564_COUNTER3 +
-			APCI1564_TCW_PROG);
-
-		/* Send a signal to from kernel to user space */
-		send_sig(SIGIO, devpriv->tsk_Current, 0);
-
-		/*  Enable Counter Interrupt */
-		outl(ul_Command2,
-			devpriv->iobase + APCI1564_COUNTER3 +
-			APCI1564_TCW_PROG);
-	}			/*  if ((ui_C3 == 1) && (devpriv->b_TimerSelectMode =ADDIDATA_COUNTER)) */
-
-	if ((ui_C4 == 1) && (devpriv->b_TimerSelectMode = ADDIDATA_COUNTER)) {
-		/*  Disable Counter Interrupt */
-		ul_Command2 =
-			inl(devpriv->iobase + APCI1564_COUNTER4 +
-			APCI1564_TCW_PROG);
-		outl(0x0,
-			devpriv->iobase + APCI1564_COUNTER4 +
-			APCI1564_TCW_PROG);
-
-		/* Send a signal to from kernel to user space */
-		send_sig(SIGIO, devpriv->tsk_Current, 0);
-
-		/*  Enable Counter Interrupt */
-		outl(ul_Command2,
-			devpriv->iobase + APCI1564_COUNTER4 +
-			APCI1564_TCW_PROG);
-	}			/*  if ((ui_C4 == 1) && (devpriv->b_TimerSelectMode =ADDIDATA_COUNTER)) */
+	if (ui_Timer == 1) {
+		devpriv->b_TimerSelectMode = ADDIDATA_TIMER;
+		if (devpriv->b_TimerSelectMode) {
+
+			/*  Disable Timer Interrupt */
+			ul_Command2 =
+				inl(devpriv->i_IobaseAmcc + APCI1564_TIMER +
+				    APCI1564_TCW_PROG);
+			outl(0x0,
+			     devpriv->i_IobaseAmcc + APCI1564_TIMER +
+			     APCI1564_TCW_PROG);
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_Current, 0);
+
+			/*  Enable Timer Interrupt */
+
+			outl(ul_Command2,
+			     devpriv->i_IobaseAmcc + APCI1564_TIMER +
+			     APCI1564_TCW_PROG);
+		}
+	}/* if  (ui_Timer == 1) */
+
+
+	if (ui_C1 == 1) {
+		devpriv->b_TimerSelectMode = ADDIDATA_COUNTER;
+		if (devpriv->b_TimerSelectMode) {
+
+			/*  Disable Counter Interrupt */
+			ul_Command2 =
+				inl(devpriv->iobase + APCI1564_COUNTER1 +
+				    APCI1564_TCW_PROG);
+			outl(0x0,
+			     devpriv->iobase + APCI1564_COUNTER1 +
+			     APCI1564_TCW_PROG);
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_Current, 0);
+
+			/*  Enable Counter Interrupt */
+			outl(ul_Command2,
+			     devpriv->iobase + APCI1564_COUNTER1 +
+			     APCI1564_TCW_PROG);
+		}
+	} /* if  (ui_C1 == 1) */
+
+	if (ui_C2 == 1) {
+		devpriv->b_TimerSelectMode = ADDIDATA_COUNTER;
+		if (devpriv->b_TimerSelectMode) {
+
+			/*  Disable Counter Interrupt */
+			ul_Command2 =
+				inl(devpriv->iobase + APCI1564_COUNTER2 +
+				    APCI1564_TCW_PROG);
+			outl(0x0,
+			     devpriv->iobase + APCI1564_COUNTER2 +
+			     APCI1564_TCW_PROG);
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_Current, 0);
+
+			/*  Enable Counter Interrupt */
+			outl(ul_Command2,
+			     devpriv->iobase + APCI1564_COUNTER2 +
+			     APCI1564_TCW_PROG);
+		}
+	} /*  if  ((ui_C2 == 1) */
+
+	if (ui_C3 == 1) {
+		devpriv->b_TimerSelectMode = ADDIDATA_COUNTER;
+		if (devpriv->b_TimerSelectMode) {
+
+			/*  Disable Counter Interrupt */
+			ul_Command2 =
+				inl(devpriv->iobase + APCI1564_COUNTER3 +
+				    APCI1564_TCW_PROG);
+			outl(0x0,
+			     devpriv->iobase + APCI1564_COUNTER3 +
+			     APCI1564_TCW_PROG);
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_Current, 0);
+
+			/*  Enable Counter Interrupt */
+			outl(ul_Command2,
+			     devpriv->iobase + APCI1564_COUNTER3 +
+			     APCI1564_TCW_PROG);
+		}
+	}	/*  if ((ui_C3 == 1) */
+
+	if (ui_C4 == 1) {
+		devpriv->b_TimerSelectMode = ADDIDATA_COUNTER;
+		if (devpriv->b_TimerSelectMode) {
+
+			/*  Disable Counter Interrupt */
+			ul_Command2 =
+				inl(devpriv->iobase + APCI1564_COUNTER4 +
+				    APCI1564_TCW_PROG);
+			outl(0x0,
+			     devpriv->iobase + APCI1564_COUNTER4 +
+			     APCI1564_TCW_PROG);
+
+			/* Send a signal to from kernel to user space */
+			send_sig(SIGIO, devpriv->tsk_Current, 0);
+
+			/*  Enable Counter Interrupt */
+			outl(ul_Command2,
+			     devpriv->iobase + APCI1564_COUNTER4 +
+			     APCI1564_TCW_PROG);
+		}
+	}	/*  if (ui_C4 == 1) */
 	return;
 }
 
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_APCI1710.c
@@ -1,4 +1,4 @@
-/**
+//**
 @verbatim
 
 Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
@@ -63,7 +63,8 @@ void i_ADDI_AttachPCI1710(struct comedi_
 	int n_subdevices = 9;
 
 	/* Update-0.7.57->0.7.68dev->n_subdevices = 9; */
-	if ((ret = alloc_subdevices(dev, n_subdevices)) < 0)
+	ret = alloc_subdevices(dev, n_subdevices);
+	if (ret < 0)
 		return;
 
 	/*  Allocate and Initialise Timer Subdevice Structures */
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c
@@ -614,8 +614,8 @@ void v_APCI3XXX_Interrupt(int irq, void 
 	/* Test if interrupt occur */
 	/***************************/
 
-	if (((dw_Status = readl((void *)(devpriv->dw_AiBase + 16))) & 0x2UL) ==
-		0x2UL) {
+	dw_Status = readl((void *)(devpriv->dw_AiBase + 16));
+	if ( (dw_Status & 0x2UL) == 0x2UL) {
 	   /***********************/
 		/* Reset the interrupt */
 	   /***********************/
--- a/drivers/staging/comedi/drivers/adl_pci9111.c
+++ b/drivers/staging/comedi/drivers/adl_pci9111.c
@@ -1310,7 +1310,8 @@ static int pci9111_attach(struct comedi_
 
 	/*  TODO: Add external multiplexer setup (according to option[2]). */
 
-	if ((error = alloc_subdevices(dev, 4)) < 0)
+	error = alloc_subdevices(dev, 4);
+	if (error < 0)
 		return error;
 
 	subdevice = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1474,11 +1474,10 @@ static int pci9118_ai_cmd(struct comedi_
 	s->async->cur_chan = 0;
 	devpriv->ai_buf_ptr = 0;
 
-	if (devpriv->usedma) {
+	if (devpriv->usedma)
 		ret = pci9118_ai_docmd_dma(dev, s);
-	} else {
+	else
 		ret = pci9118_ai_docmd_sampl(dev, s);
-	}
 
 	DPRINTK("adl_pci9118 EDBG: END: pci9118_ai_cmd()\n");
 	return ret;
@@ -1860,7 +1859,8 @@ static int pci9118_attach(struct comedi_
 		master = 1;
 	}
 
-	if ((ret = alloc_private(dev, sizeof(struct pci9118_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pci9118_private));
+	if (ret < 0) {
 		rt_printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
@@ -1940,11 +1940,13 @@ static int pci9118_attach(struct comedi_
 	if (master) {		/*  alloc DMA buffers */
 		devpriv->dma_doublebuf = 0;
 		for (i = 0; i < 2; i++) {
-			for (pages = 4; pages >= 0; pages--)
-				if ((devpriv->dmabuf_virt[i] = (short *)
-						__get_free_pages(GFP_KERNEL,
-							pages)))
+			for (pages = 4; pages >= 0; pages--) {
+				devpriv->dmabuf_virt[i] =
+					(short *) __get_free_pages(GFP_KERNEL,
+								   pages);
+				if (devpriv->dmabuf_virt[i])
 					break;
+			}
 			if (devpriv->dmabuf_virt[i]) {
 				devpriv->dmabuf_pages[i] = pages;
 				devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
@@ -1965,11 +1967,11 @@ static int pci9118_attach(struct comedi_
 
 	}
 
-	if ((devpriv->master = master)) {
+	devpriv->master = master;
+	if (devpriv->master)
 		rt_printk(", bus master");
-	} else {
+	else
 		rt_printk(", no bus master");
-	}
 
 	devpriv->usemux = 0;
 	if (it->options[2] > 0) {
@@ -1998,7 +2000,8 @@ static int pci9118_attach(struct comedi_
 	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
 	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	/*  Enable parity check for parity error */
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/adv_pci1710.c
+++ b/drivers/staging/comedi/drivers/adv_pci1710.c
@@ -1336,7 +1336,8 @@ static int pci1710_attach(struct comedi_
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
 
-	if ((ret = alloc_private(dev, sizeof(struct pci1710_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pci1710_private));
+	if (ret < 0) {
 		rt_printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
@@ -1419,7 +1420,8 @@ static int pci1710_attach(struct comedi_
 	if (this_board->n_counter)
 		n_subdevices++;
 
-	if ((ret = alloc_subdevices(dev, n_subdevices)) < 0) {
+	ret = alloc_subdevices(dev, n_subdevices);
+	if (ret < 0) {
 		rt_printk(" - Allocation failed!\n");
 		return ret;
 	}
--- a/drivers/staging/comedi/drivers/adv_pci1723.c
+++ b/drivers/staging/comedi/drivers/adv_pci1723.c
@@ -310,7 +310,8 @@ static int pci1723_attach(struct comedi_
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
 
-	if ((ret = alloc_private(dev, sizeof(struct pci1723_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pci1723_private));
+	if (ret < 0) {
 		rt_printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
@@ -369,7 +370,8 @@ static int pci1723_attach(struct comedi_
 	if (this_board->n_diochan)
 		n_subdevices++;
 
-	if ((ret = alloc_subdevices(dev, n_subdevices)) < 0) {
+	ret = alloc_subdevices(dev, n_subdevices);
+	if (ret < 0) {
 		rt_printk(" - Allocation failed!\n");
 		return ret;
 	}
--- a/drivers/staging/comedi/drivers/adv_pci_dio.c
+++ b/drivers/staging/comedi/drivers/adv_pci_dio.c
@@ -443,7 +443,8 @@ static int pci1760_unchecked_mbxrequest(
 		outb(omb[2], dev->iobase + OMB2);
 		outb(omb[3], dev->iobase + OMB3);
 		for (tout = 0; tout < 251; tout++) {
-			if ((imb[2] = inb(dev->iobase + IMB2)) == omb[2]) {
+			imb[2] = inb(dev->iobase + IMB2);
+			if (imb[2] == omb[2]) {
 				imb[0] = inb(dev->iobase + IMB0);
 				imb[1] = inb(dev->iobase + IMB1);
 				imb[3] = inb(dev->iobase + IMB3);
@@ -517,7 +518,8 @@ static int pci1760_insn_bits_do(struct c
 		s->state &= ~data[0];
 		s->state |= (data[0] & data[1]);
 		omb[0] = s->state;
-		if (!(ret = pci1760_mbxrequest(dev, omb, imb)))
+		ret = pci1760_mbxrequest(dev, omb, imb);
+		if (!ret)
 			return ret;
 	}
 	data[1] = s->state;
@@ -541,7 +543,8 @@ static int pci1760_insn_cnt_read(struct 
 	unsigned char imb[4];
 
 	for (n = 0; n < insn->n; n++) {
-		if (!(ret = pci1760_mbxrequest(dev, omb, imb)))
+		ret = pci1760_mbxrequest(dev, omb, imb);
+		if (!ret)
 			return ret;
 		data[n] = (imb[1] << 8) + imb[0];
 	}
@@ -567,20 +570,23 @@ static int pci1760_insn_cnt_write(struct
 	unsigned char imb[4];
 
 	if (devpriv->CntResValue[chan] != (data[0] & 0xffff)) {	/*  Set reset value if different */
-		if (!(ret = pci1760_mbxrequest(dev, omb, imb)))
+		ret =  pci1760_mbxrequest(dev, omb, imb);
+		if (!ret)
 			return ret;
 		devpriv->CntResValue[chan] = data[0] & 0xffff;
 	}
 
 	omb[0] = bitmask;	/*  reset counter to it reset value */
 	omb[2] = CMD_ResetIDICounters;
-	if (!(ret = pci1760_mbxrequest(dev, omb, imb)))
+	ret = pci1760_mbxrequest(dev, omb, imb);
+	if (!ret)
 		return ret;
 
 	if (!(bitmask & devpriv->IDICntEnable)) {	/*  start counter if it don't run */
 		omb[0] = bitmask;
 		omb[2] = CMD_EnableIDICounters;
-		if (!(ret = pci1760_mbxrequest(dev, omb, imb)))
+		ret = pci1760_mbxrequest(dev, omb, imb);
+		if (!ret)
 			return ret;
 		devpriv->IDICntEnable |= bitmask;
 	}
@@ -892,7 +898,8 @@ static int pci_dio_attach(struct comedi_
 
 	rt_printk("comedi%d: adv_pci_dio: ", dev->minor);
 
-	if ((ret = alloc_private(dev, sizeof(struct pci_dio_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pci_dio_private));
+	if (ret < 0) {
 		rt_printk(", Error: Cann't allocate private memory!\n");
 		return -ENOMEM;
 	}
@@ -959,7 +966,8 @@ static int pci_dio_attach(struct comedi_
 			n_subdevices++;
 	}
 
-	if ((ret = alloc_subdevices(dev, n_subdevices)) < 0) {
+	ret = alloc_subdevices(dev, n_subdevices);
+	if (ret < 0) {
 		rt_printk(", Error: Cann't allocate subdevice memory!\n");
 		return ret;
 	}
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1282,7 +1282,8 @@ static int dio200_attach(struct comedi_d
 	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
 		DIO200_DRIVER_NAME);
 
-	if ((ret = alloc_private(dev, sizeof(struct dio200_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct dio200_private));
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
@@ -1301,7 +1302,8 @@ static int dio200_attach(struct comedi_d
 		slot = it->options[1];
 		share_irq = 1;
 
-		if ((ret = dio200_find_pci(dev, bus, slot, &pci_dev)) < 0)
+		ret = dio200_find_pci(dev, bus, slot, &pci_dev);
+		if (ret < 0)
 			return ret;
 		devpriv->pci_dev = pci_dev;
 		break;
@@ -1339,7 +1341,9 @@ static int dio200_attach(struct comedi_d
 	dev->iobase = iobase;
 
 	layout = thislayout;
-	if ((ret = alloc_subdevices(dev, layout->n_subdevs)) < 0) {
+
+	ret = alloc_subdevices(dev, layout->n_subdevs);
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
--- a/drivers/staging/comedi/drivers/amplc_pc236.c
+++ b/drivers/staging/comedi/drivers/amplc_pc236.c
@@ -284,7 +284,8 @@ static int pc236_attach(struct comedi_de
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
  */
-	if ((ret = alloc_private(dev, sizeof(struct pc236_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pc236_private));
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
@@ -302,7 +303,8 @@ static int pc236_attach(struct comedi_de
 		slot = it->options[1];
 		share_irq = 1;
 
-		if ((ret = pc236_find_pci(dev, bus, slot, &pci_dev)) < 0)
+		ret = pc236_find_pci(dev, bus, slot, &pci_dev);
+		if (ret < 0)
 			return ret;
 		devpriv->pci_dev = pci_dev;
 		break;
@@ -323,7 +325,9 @@ static int pc236_attach(struct comedi_de
 	/* Enable device and reserve I/O spaces. */
 #ifdef CONFIG_COMEDI_PCI
 	if (pci_dev) {
-		if ((ret = comedi_pci_enable(pci_dev, PC236_DRIVER_NAME)) < 0) {
+
+		ret = comedi_pci_enable(pci_dev, PC236_DRIVER_NAME);
+		if (ret < 0) {
 			printk(KERN_ERR
 				"comedi%d: error! cannot enable PCI device and request regions!\n",
 				dev->minor);
@@ -346,7 +350,8 @@ static int pc236_attach(struct comedi_de
  * Allocate the subdevice structures.  alloc_subdevice() is a
  * convenient macro defined in comedidev.h.
  */
-	if ((ret = alloc_subdevices(dev, 2)) < 0) {
+	ret = alloc_subdevices(dev, 2);
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
@@ -354,7 +359,8 @@ static int pc236_attach(struct comedi_de
 
 	s = dev->subdevices + 0;
 	/* digital i/o subdevice (8255) */
-	if ((ret = subdev_8255_init(dev, s, NULL, iobase)) < 0) {
+	ret = subdev_8255_init(dev, s, NULL, iobase);
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
--- a/drivers/staging/comedi/drivers/amplc_pc263.c
+++ b/drivers/staging/comedi/drivers/amplc_pc263.c
@@ -236,7 +236,8 @@ static int pc263_attach(struct comedi_de
  * convenient macro defined in comedidev.h.
  */
 #ifdef CONFIG_COMEDI_PCI
-	if ((ret = alloc_private(dev, sizeof(struct pc263_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pc263_private));
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
@@ -252,7 +253,8 @@ static int pc263_attach(struct comedi_de
 		bus = it->options[0];
 		slot = it->options[1];
 
-		if ((ret = pc263_find_pci(dev, bus, slot, &pci_dev)) < 0)
+		ret = pc263_find_pci(dev, bus, slot, &pci_dev);
+		if (ret < 0)
 			return ret;
 		devpriv->pci_dev = pci_dev;
 		break;
@@ -273,7 +275,8 @@ static int pc263_attach(struct comedi_de
 	/* Enable device and reserve I/O spaces. */
 #ifdef CONFIG_COMEDI_PCI
 	if (pci_dev) {
-		if ((ret = comedi_pci_enable(pci_dev, PC263_DRIVER_NAME)) < 0) {
+		ret = comedi_pci_enable(pci_dev, PC263_DRIVER_NAME);
+		if (ret < 0) {
 			printk(KERN_ERR
 				"comedi%d: error! cannot enable PCI device and request regions!\n",
 				dev->minor);
@@ -294,7 +297,8 @@ static int pc263_attach(struct comedi_de
  * Allocate the subdevice structures.  alloc_subdevice() is a
  * convenient macro defined in comedidev.h.
  */
-	if ((ret = alloc_subdevices(dev, 1)) < 0) {
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1338,16 +1338,20 @@ static int pci224_attach(struct comedi_d
 
 	bus = it->options[0];
 	slot = it->options[1];
-	if ((ret = alloc_private(dev, sizeof(struct pci224_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pci224_private));
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
 	}
-	if ((ret = pci224_find_pci(dev, bus, slot, &pci_dev)) < 0)
+
+	ret = pci224_find_pci(dev, bus, slot, &pci_dev);
+	if (ret < 0)
 		return ret;
-	devpriv->pci_dev = pci_dev;
 
-	if ((ret = comedi_pci_enable(pci_dev, DRIVER_NAME)) < 0) {
+	devpriv->pci_dev = pci_dev;
+	ret = comedi_pci_enable(pci_dev, DRIVER_NAME);
+	if (ret < 0) {
 		printk(KERN_ERR
 			"comedi%d: error! cannot enable PCI device "
 			"and request regions!\n", dev->minor);
@@ -1394,7 +1398,8 @@ static int pci224_attach(struct comedi_d
 		dev->iobase + PCI224_DACCON);
 
 	/* Allocate subdevices.  There is only one!  */
-	if ((ret = alloc_subdevices(dev, 1)) < 0) {
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
--- a/drivers/staging/comedi/drivers/cb_das16_cs.c
+++ b/drivers/staging/comedi/drivers/cb_das16_cs.c
@@ -766,15 +766,22 @@ static void das16cs_pcmcia_config(struct
 	tuple.TupleData = buf;
 	tuple.TupleDataMax = sizeof(buf);
 	tuple.TupleOffset = 0;
+
 	last_fn = GetFirstTuple;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0)
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret != 0)
 		goto cs_failed;
+
 	last_fn = GetTupleData;
-	if ((last_ret = pcmcia_get_tuple_data(link, &tuple)) != 0)
+	last_ret = pcmcia_get_tuple_data(link, &tuple);
+	if (last_ret != 0)
 		goto cs_failed;
+
 	last_fn = ParseTuple;
-	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+	last_ret = pcmcia_parse_tuple(&tuple, &parse);
+	if (last_ret != 0)
 		goto cs_failed;
+
 	link->conf.ConfigBase = parse.config.base;
 	link->conf.Present = parse.config.rmask[0];
 
@@ -792,8 +799,11 @@ static void das16cs_pcmcia_config(struct
 	 */
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	last_fn = GetFirstTuple;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0)
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret)
 		goto cs_failed;
+
 	while (1) {
 		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
 		if (pcmcia_get_tuple_data(link, &tuple))
@@ -844,7 +854,9 @@ static void das16cs_pcmcia_config(struct
 
 	      next_entry:
 		last_fn = GetNextTuple;
-		if ((last_ret = pcmcia_get_next_tuple(link, &tuple)) != 0)
+
+		last_ret = pcmcia_get_next_tuple(link, &tuple);
+		if (last_ret)
 			goto cs_failed;
 	}
 
@@ -855,7 +867,9 @@ static void das16cs_pcmcia_config(struct
 	 */
 	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
 		last_fn = RequestIRQ;
-		if ((last_ret = pcmcia_request_irq(link, &link->irq)) != 0)
+
+		last_ret = pcmcia_request_irq(link, &link->irq);
+		if (last_ret)
 			goto cs_failed;
 	}
 	/*
@@ -864,7 +878,8 @@ static void das16cs_pcmcia_config(struct
 	   card and host interface into "Memory and IO" mode.
 	 */
 	last_fn = RequestConfiguration;
-	if ((last_ret = pcmcia_request_configuration(link, &link->conf)) != 0)
+	last_ret = pcmcia_request_configuration(link, &link->conf);
+	if (last_ret)
 		goto cs_failed;
 
 	/*
--- a/drivers/staging/comedi/drivers/cb_pcimdda.c
+++ b/drivers/staging/comedi/drivers/cb_pcimdda.c
@@ -257,7 +257,8 @@ static int attach(struct comedi_device *
  * it is, this is the place to do it.  Otherwise, dev->board_ptr
  * should already be initialized.
  */
-	if ((err = probe(dev, it)))
+	err = probe(dev, it);
+	if (err)
 		return err;
 
 /* Output some info */
--- a/drivers/staging/comedi/drivers/comedi_rt_timer.c
+++ b/drivers/staging/comedi/drivers/comedi_rt_timer.c
@@ -646,9 +646,12 @@ static int timer_attach(struct comedi_de
 
 	dev->board_name = "timer";
 
-	if ((ret = alloc_subdevices(dev, 1)) < 0)
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0)
 		return ret;
-	if ((ret = alloc_private(dev, sizeof(struct timer_private))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct timer_private));
+	if (ret < 0)
 		return ret;
 
 	sprintf(path, "/dev/comedi%d", it->options[0]);
--- a/drivers/staging/comedi/drivers/daqboard2000.c
+++ b/drivers/staging/comedi/drivers/daqboard2000.c
@@ -772,7 +772,8 @@ static int daqboard2000_attach(struct co
 		}
 	}
 
-	if ((result = comedi_pci_enable(card, "daqboard2000")) < 0) {
+	result = comedi_pci_enable(card, "daqboard2000");
+	if (result < 0) {
 		printk(" failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
--- a/drivers/staging/comedi/drivers/das08.c
+++ b/drivers/staging/comedi/drivers/das08.c
@@ -857,7 +857,8 @@ int das08_common_attach(struct comedi_de
 
 	dev->board_name = thisboard->name;
 
-	if ((ret = alloc_subdevices(dev, 6)) < 0)
+	ret = alloc_subdevices(dev, 6);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
@@ -961,7 +962,8 @@ static int das08_attach(struct comedi_de
 	struct pci_dev *pdev;
 #endif
 
-	if ((ret = alloc_private(dev, sizeof(struct das08_private_struct))) < 0)
+	ret = alloc_private(dev, sizeof(struct das08_private_struct));
+	if (ret < 0)
 		return ret;
 
 	printk("comedi%d: das08: ", dev->minor);
--- a/drivers/staging/comedi/drivers/das08_cs.c
+++ b/drivers/staging/comedi/drivers/das08_cs.c
@@ -75,7 +75,8 @@ static int das08_cs_attach(struct comedi
 	unsigned long iobase;
 	struct pcmcia_device *link = cur_dev;	/*  XXX hack */
 
-	if ((ret = alloc_private(dev, sizeof(struct das08_private_struct))) < 0)
+	ret = alloc_private(dev, sizeof(struct das08_private_struct));
+	if (ret < 0)
 		return ret;
 
 	printk("comedi%d: das08_cs: ", dev->minor);
@@ -264,14 +265,23 @@ static void das08_pcmcia_config(struct p
 	tuple.TupleDataMax = sizeof(buf);
 	tuple.TupleOffset = 0;
 	last_fn = GetFirstTuple;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0)
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret)
 		goto cs_failed;
+
 	last_fn = GetTupleData;
-	if ((last_ret = pcmcia_get_tuple_data(link, &tuple)) != 0)
+
+	last_ret = pcmcia_get_tuple_data(link, &tuple);
+	if (last_ret)
 		goto cs_failed;
+
 	last_fn = ParseTuple;
-	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+
+	last_ret = pcmcia_parse_tuple(&tuple, &parse);
+	if (last_ret)
 		goto cs_failed;
+
 	link->conf.ConfigBase = parse.config.base;
 	link->conf.Present = parse.config.rmask[0];
 
@@ -289,13 +299,20 @@ static void das08_pcmcia_config(struct p
 	 */
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	last_fn = GetFirstTuple;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0)
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret)
 		goto cs_failed;
+
 	while (1) {
 		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
-		if ((last_ret = pcmcia_get_tuple_data(link, &tuple)) != 0)
+
+		last_ret = pcmcia_get_tuple_data(link, &tuple);
+		if (last_ret)
 			goto next_entry;
-		if ((last_ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+
+		last_ret = pcmcia_parse_tuple(&tuple, &parse);
+		if (last_ret)
 			goto next_entry;
 
 		if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
@@ -341,13 +358,16 @@ static void das08_pcmcia_config(struct p
 
 	      next_entry:
 		last_fn = GetNextTuple;
-		if ((last_ret = pcmcia_get_next_tuple(link, &tuple)) != 0)
+
+		last_ret = pcmcia_get_next_tuple(link, &tuple);
+		if (last_ret)
 			goto cs_failed;
 	}
 
 	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
 		last_fn = RequestIRQ;
-		if ((last_ret = pcmcia_request_irq(link, &link->irq)) != 0)
+		last_ret = pcmcia_request_irq(link, &link->irq);
+		if (last_ret)
 			goto cs_failed;
 	}
 
@@ -357,7 +377,8 @@ static void das08_pcmcia_config(struct p
 	   card and host interface into "Memory and IO" mode.
 	 */
 	last_fn = RequestConfiguration;
-	if ((last_ret = pcmcia_request_configuration(link, &link->conf)) != 0)
+	last_ret = pcmcia_request_configuration(link, &link->conf);
+	if (last_ret)
 		goto cs_failed;
 
 	/*
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1400,7 +1400,8 @@ static int das16_attach(struct comedi_de
 		}
 	}
 
-	if ((ret = alloc_private(dev, sizeof(struct das16_private_struct))) < 0)
+	ret = alloc_private(dev, sizeof(struct das16_private_struct));
+	if (ret < 0)
 		return ret;
 
 	if (thisboard->size < 0x400) {
@@ -1450,8 +1451,10 @@ static int das16_attach(struct comedi_de
 
 	/* now for the irq */
 	if (irq > 1 && irq < 8) {
-		if ((ret = comedi_request_irq(irq, das16_dma_interrupt, 0,
-					"das16", dev)) < 0)
+		ret = comedi_request_irq(irq, das16_dma_interrupt, 0,
+					 "das16", dev);
+
+		if (ret < 0)
 			return ret;
 		dev->irq = irq;
 		printk(" ( irq = %u )", irq);
@@ -1526,7 +1529,8 @@ static int das16_attach(struct comedi_de
 	}
 	devpriv->timer_mode = timer_mode ? 1 : 0;
 
-	if ((ret = alloc_subdevices(dev, 5)) < 0)
+	ret = alloc_subdevices(dev, 5);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/das16m1.c
+++ b/drivers/staging/comedi/drivers/das16m1.c
@@ -646,8 +646,8 @@ static int das16m1_attach(struct comedi_
 
 	printk("comedi%d: das16m1:", dev->minor);
 
-	if ((ret = alloc_private(dev,
-				sizeof(struct das16m1_private_struct))) < 0)
+	ret = alloc_private(dev, sizeof(struct das16m1_private_struct));
+	if (ret < 0)
 		return ret;
 
 	dev->board_name = thisboard->name;
@@ -687,7 +687,8 @@ static int das16m1_attach(struct comedi_
 		return -EINVAL;
 	}
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/das6402.c
+++ b/drivers/staging/comedi/drivers/das6402.c
@@ -331,10 +331,12 @@ static int das6402_attach(struct comedi_
 	}
 	dev->irq = irq;
 
-	if ((ret = alloc_private(dev, sizeof(struct das6402_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct das6402_private));
+	if (ret < 0)
 		return ret;
 
-	if ((ret = alloc_subdevices(dev, 1)) < 0)
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0)
 		return ret;
 
 	/* ai subdevice */
--- a/drivers/staging/comedi/drivers/dt2801.c
+++ b/drivers/staging/comedi/drivers/dt2801.c
@@ -521,10 +521,12 @@ static int dt2801_attach(struct comedi_d
 	n_ai_chans = probe_number_of_ai_chans(dev);
 	printk(" (ai channels = %d)", n_ai_chans);
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		goto out;
 
-	if ((ret = alloc_private(dev, sizeof(struct dt2801_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct dt2801_private));
+	if (ret < 0)
 		goto out;
 
 	dev->board_name = boardtype.name;
--- a/drivers/staging/comedi/drivers/dt2811.c
+++ b/drivers/staging/comedi/drivers/dt2811.c
@@ -379,10 +379,14 @@ static int dt2811_attach(struct comedi_d
 	}
 #endif
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
-	if ((ret = alloc_private(dev, sizeof(struct dt2811_private))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct dt2811_private));
+	if (ret < 0)
 		return ret;
+
 	switch (it->options[2]) {
 	case 0:
 		devpriv->adc_mux = adc_singleended;
--- a/drivers/staging/comedi/drivers/dt2814.c
+++ b/drivers/staging/comedi/drivers/dt2814.c
@@ -309,9 +309,12 @@ static int dt2814_attach(struct comedi_d
 #endif
 	}
 
-	if ((ret = alloc_subdevices(dev, 1)) < 0)
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0)
 		return ret;
-	if ((ret = alloc_private(dev, sizeof(struct dt2814_private))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct dt2814_private));
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/dt2817.c
+++ b/drivers/staging/comedi/drivers/dt2817.c
@@ -146,7 +146,8 @@ static int dt2817_attach(struct comedi_d
 	dev->iobase = iobase;
 	dev->board_name = "dt2817";
 
-	if ((ret = alloc_subdevices(dev, 1)) < 0)
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1326,7 +1326,8 @@ static int dt282x_attach(struct comedi_d
 #endif
 	}
 
-	if ((ret = alloc_private(dev, sizeof(struct dt282x_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct dt282x_private));
+	if (ret < 0)
 		return ret;
 
 	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
@@ -1334,7 +1335,8 @@ static int dt282x_attach(struct comedi_d
 	if (ret < 0)
 		return ret;
 
-	if ((ret = alloc_subdevices(dev, 3)) < 0)
+	ret = alloc_subdevices(dev, 3);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
@@ -1358,7 +1360,9 @@ static int dt282x_attach(struct comedi_d
 	devpriv->ad_2scomp = it->options[opt_ai_twos];
 
 	s++;
-	if ((s->n_chan = boardtype.dachan)) {
+
+	s->n_chan = boardtype.dachan;
+	if (s->n_chan) {
 		/* ao subsystem */
 		s->type = COMEDI_SUBD_AO;
 		dev->write_subdev = s;
--- a/drivers/staging/comedi/drivers/dt3000.c
+++ b/drivers/staging/comedi/drivers/dt3000.c
@@ -811,7 +811,8 @@ static int dt3000_attach(struct comedi_d
 	bus = it->options[0];
 	slot = it->options[1];
 
-	if ((ret = alloc_private(dev, sizeof(struct dt3k_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct dt3k_private));
+	if (ret < 0)
 		return ret;
 
 	ret = dt_pci_probe(dev, bus, slot);
@@ -831,7 +832,8 @@ static int dt3000_attach(struct comedi_d
 	}
 	dev->irq = devpriv->pci_dev->irq;
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices;
@@ -935,7 +937,8 @@ static int dt_pci_probe(struct comedi_de
 	if (!devpriv->pci_dev)
 		return 0;
 
-	if ((ret = setup_pci(dev)) < 0)
+	ret = setup_pci(dev);
+	if (ret < 0)
 		return ret;
 
 	return 1;
--- a/drivers/staging/comedi/drivers/ii_pci20kc.c
+++ b/drivers/staging/comedi/drivers/ii_pci20kc.c
@@ -209,9 +209,12 @@ static int pci20xxx_attach(struct comedi
 	struct comedi_subdevice *s;
 	union pci20xxx_subdev_private *sdp;
 
-	if ((ret = alloc_subdevices(dev, 1 + PCI20000_MODULES)) < 0)
+	ret = alloc_subdevices(dev, 1 + PCI20000_MODULES);
+	if (ret < 0)
 		return ret;
-	if ((ret = alloc_private(dev, sizeof(struct pci20xxx_private))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct pci20xxx_private));
+	if (ret < 0)
 		return ret;
 
 	devpriv->ioaddr = (void *)(unsigned long)it->options[0];
--- a/drivers/staging/comedi/drivers/jr3_pci.c
+++ b/drivers/staging/comedi/drivers/jr3_pci.c
@@ -834,9 +834,12 @@ static int jr3_pci_attach(struct comedi_
 		devpriv->pci_dev = card;
 		dev->board_name = "jr3_pci";
 	}
-	if ((result = comedi_pci_enable(card, "jr3_pci")) < 0) {
+
+	result = comedi_pci_enable(card, "jr3_pci");
+	if (result < 0) {
 		return -EIO;
 	}
+
 	devpriv->pci_enabled = 1;
 	devpriv->iobase = ioremap(pci_resource_start(card, 0), sizeof(struct jr3_t));
 	result = alloc_subdevices(dev, devpriv->n_channels);
--- a/drivers/staging/comedi/drivers/ke_counter.c
+++ b/drivers/staging/comedi/drivers/ke_counter.c
@@ -157,9 +157,9 @@ static int cnt_attach(struct comedi_devi
 	int error, i;
 
 	/* allocate device private structure */
-	if ((error = alloc_private(dev, sizeof(struct cnt_device_private))) < 0) {
+	error = alloc_private(dev, sizeof(struct cnt_device_private));
+	if (error < 0)
 		return error;
-	}
 
 	/* Probe the device to determine what device in the series it is. */
 	for (pci_device = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
@@ -203,7 +203,8 @@ static int cnt_attach(struct comedi_devi
 	dev->board_name = board->name;
 
 	/* enable PCI device and request regions */
-	if ((error = comedi_pci_enable(pci_device, CNT_DRIVER_NAME)) < 0) {
+	error = comedi_pci_enable(pci_device, CNT_DRIVER_NAME);
+	if (error < 0) {
 		printk("comedi%d: failed to enable PCI device and request regions!\n", dev->minor);
 		return error;
 	}
@@ -213,9 +214,9 @@ static int cnt_attach(struct comedi_devi
 	dev->iobase = io_base;
 
 	/* allocate the subdevice structures */
-	if ((error = alloc_subdevices(dev, 1)) < 0) {
+	error = alloc_subdevices(dev, 1);
+	if (error < 0)
 		return error;
-	}
 
 	subdevice = dev->subdevices + 0;
 	dev->read_subdev = subdevice;
--- a/drivers/staging/comedi/drivers/ni_6527.c
+++ b/drivers/staging/comedi/drivers/ni_6527.c
@@ -371,7 +371,8 @@ static int ni6527_attach(struct comedi_d
 
 	printk("comedi%d: ni6527:", dev->minor);
 
-	if ((ret = alloc_private(dev, sizeof(struct ni6527_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct ni6527_private));
+	if (ret < 0)
 		return ret;
 
 	ret = ni6527_find_device(dev, it->options[0], it->options[1]);
@@ -389,7 +390,8 @@ static int ni6527_attach(struct comedi_d
 
 	printk(" ID=0x%02x", readb(devpriv->mite->daq_io_addr + ID_Register));
 
-	if ((ret = alloc_subdevices(dev, 3)) < 0)
+	ret = alloc_subdevices(dev, 3);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/ni_65xx.c
+++ b/drivers/staging/comedi/drivers/ni_65xx.c
@@ -627,7 +627,8 @@ static int ni_65xx_attach(struct comedi_
 
 	printk("comedi%d: ni_65xx:", dev->minor);
 
-	if ((ret = alloc_private(dev, sizeof(struct ni_65xx_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct ni_65xx_private));
+	if (ret < 0)
 		return ret;
 
 	ret = ni_65xx_find_device(dev, it->options[0], it->options[1]);
@@ -647,7 +648,8 @@ static int ni_65xx_attach(struct comedi_
 	printk(" ID=0x%02x",
 		readb(private(dev)->mite->daq_io_addr + ID_Register));
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/ni_660x.c
+++ b/drivers/staging/comedi/drivers/ni_660x.c
@@ -960,8 +960,10 @@ static int ni_660x_allocate_private(stru
 	int retval;
 	unsigned i;
 
-	if ((retval = alloc_private(dev, sizeof(struct ni_660x_private))) < 0)
+	retval = alloc_private(dev, sizeof(struct ni_660x_private));
+	if (retval < 0)
 		return retval;
+
 	spin_lock_init(&private(dev)->mite_channel_lock);
 	spin_lock_init(&private(dev)->interrupt_lock);
 	spin_lock_init(&private(dev)->soft_reg_copy_lock);
@@ -1105,9 +1107,11 @@ static int ni_660x_attach(struct comedi_
 	for (i = 0; i < board(dev)->n_chips; ++i) {
 		set_tio_counterswap(dev, i);
 	}
-	if ((ret = comedi_request_irq(mite_irq(private(dev)->mite),
-				&ni_660x_interrupt, IRQF_SHARED, "ni_660x",
-				dev)) < 0) {
+	ret = comedi_request_irq(mite_irq(private(dev)->mite),
+				 ni_660x_interrupt, IRQF_SHARED, "ni_660x",
+				 dev);
+
+	if (ret < 0) {
 		printk(" irq not available\n");
 		return ret;
 	}
--- a/drivers/staging/comedi/drivers/ni_670x.c
+++ b/drivers/staging/comedi/drivers/ni_670x.c
@@ -144,7 +144,8 @@ static int ni_670x_attach(struct comedi_
 
 	printk("comedi%d: ni_670x: ", dev->minor);
 
-	if ((ret = alloc_private(dev, sizeof(struct ni_670x_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct ni_670x_private));
+	if (ret < 0)
 		return ret;
 
 	ret = ni_670x_find_device(dev, it->options[0], it->options[1]);
--- a/drivers/staging/comedi/drivers/ni_atmio16d.c
+++ b/drivers/staging/comedi/drivers/ni_atmio16d.c
@@ -449,11 +449,13 @@ static int atmio16d_ai_cmd(struct comedi
 		outw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);
 	} else {
 		/* Counter 4 and 5 are needed */
-		if ((tmp = sample_count & 0xFFFF)) {
+
+		tmp = sample_count & 0xFFFF;
+		if (tmp)
 			outw(tmp - 1, dev->iobase + AM9513A_DATA_REG);
-		} else {
+		else
 			outw(0xFFFF, dev->iobase + AM9513A_DATA_REG);
-		}
+
 		outw(0xFF48, dev->iobase + AM9513A_COM_REG);
 		outw(0, dev->iobase + AM9513A_DATA_REG);
 		outw(0xFF28, dev->iobase + AM9513A_COM_REG);
@@ -726,9 +728,12 @@ static int atmio16d_attach(struct comedi
 	/* board name */
 	dev->board_name = boardtype->name;
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
-	if ((ret = alloc_private(dev, sizeof(struct atmio16d_private))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct atmio16d_private));
+	if (ret < 0)
 		return ret;
 
 	/* reset the atmio16d hardware */
@@ -737,8 +742,10 @@ static int atmio16d_attach(struct comedi
 	/* check if our interrupt is available and get it */
 	irq = it->options[1];
 	if (irq) {
-		if ((ret = comedi_request_irq(irq, atmio16d_interrupt,
-					0, "atmio16d", dev)) < 0) {
+
+		ret = comedi_request_irq(irq, atmio16d_interrupt,
+					  0, "atmio16d", dev);
+		if (ret < 0) {
 			printk("failed to allocate irq %u\n", irq);
 			return ret;
 		}
--- a/drivers/staging/comedi/drivers/ni_atmio.c
+++ b/drivers/staging/comedi/drivers/ni_atmio.c
@@ -414,8 +414,10 @@ static int ni_atmio_attach(struct comedi
 	unsigned int irq;
 
 	/* allocate private area */
-	if ((ret = ni_alloc_private(dev)) < 0)
+	ret = ni_alloc_private(dev);
+	if (ret < 0)
 		return ret;
+
 	devpriv->stc_writew = &ni_atmio_win_out;
 	devpriv->stc_readw = &ni_atmio_win_in;
 	devpriv->stc_writel = &win_out2;
@@ -476,8 +478,10 @@ static int ni_atmio_attach(struct comedi
 			return -EINVAL;
 		}
 		printk(" ( irq = %u )", irq);
-		if ((ret = comedi_request_irq(irq, ni_E_interrupt,
-					NI_E_IRQ_FLAGS, "ni_atmio", dev)) < 0) {
+		ret = comedi_request_irq(irq, ni_E_interrupt,
+					  NI_E_IRQ_FLAGS, "ni_atmio", dev);
+
+		if (ret < 0) {
 			printk(" irq not available\n");
 			return -EINVAL;
 		}
@@ -486,7 +490,8 @@ static int ni_atmio_attach(struct comedi
 
 	/* generic E series stuff in ni_mio_common.c */
 
-	if ((ret = ni_E_init(dev, it)) < 0) {
+	ret = ni_E_init(dev, it);
+	if (ret < 0) {
 		return ret;
 	}
 
--- a/drivers/staging/comedi/drivers/ni_daq_700.c
+++ b/drivers/staging/comedi/drivers/ni_daq_700.c
@@ -594,15 +594,21 @@ static void dio700_config(struct pcmcia_
 	tuple.TupleData = buf;
 	tuple.TupleDataMax = sizeof(buf);
 	tuple.TupleOffset = 0;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0) {
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_get_tuple_data(link, &tuple)) != 0) {
+
+	last_ret = pcmcia_get_tuple_data(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetTupleData, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse)) != 0) {
+
+	last_ret = pcmcia_parse_tuple(&tuple, &parse);
+	 if (last_ret) {
 		cs_error(link, ParseTuple, last_ret);
 		goto cs_failed;
 	}
@@ -622,7 +628,8 @@ static void dio700_config(struct pcmcia_
 	   will only use the CIS to fill in implementation-defined details.
 	 */
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0) {
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret != 0) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
@@ -692,7 +699,9 @@ static void dio700_config(struct pcmcia_
 		break;
 
 	      next_entry:
-		if ((last_ret = pcmcia_get_next_tuple(link, &tuple)) != 0) {
+
+		last_ret = pcmcia_get_next_tuple(link, &tuple);
+		if (last_ret) {
 			cs_error(link, GetNextTuple, last_ret);
 			goto cs_failed;
 		}
@@ -703,18 +712,21 @@ static void dio700_config(struct pcmcia_
 	   handler to the interrupt, unless the 'Handler' member of the
 	   irq structure is initialized.
 	 */
-	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		if ((last_ret = pcmcia_request_irq(link, &link->irq)) != 0) {
+	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
+		last_ret = pcmcia_request_irq(link, &link->irq);
+		if (last_ret) {
 			cs_error(link, RequestIRQ, last_ret);
 			goto cs_failed;
 		}
+	}
 
 	/*
 	   This actually configures the PCMCIA socket -- setting up
 	   the I/O windows and the interrupt mapping, and putting the
 	   card and host interface into "Memory and IO" mode.
 	 */
-	if ((last_ret = pcmcia_request_configuration(link, &link->conf)) != 0) {
+	last_ret = pcmcia_request_configuration(link, &link->conf);
+	if (last_ret != 0) {
 		cs_error(link, RequestConfiguration, last_ret);
 		goto cs_failed;
 	}
--- a/drivers/staging/comedi/drivers/ni_daq_dio24.c
+++ b/drivers/staging/comedi/drivers/ni_daq_dio24.c
@@ -351,15 +351,21 @@ static void dio24_config(struct pcmcia_d
 	tuple.TupleData = buf;
 	tuple.TupleDataMax = sizeof(buf);
 	tuple.TupleOffset = 0;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0) {
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_get_tuple_data(link, &tuple)) != 0) {
+
+	last_ret = pcmcia_get_tuple_data(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetTupleData, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse)) != 0) {
+
+	last_ret = pcmcia_parse_tuple(&tuple, &parse);
+	if (last_ret) {
 		cs_error(link, ParseTuple, last_ret);
 		goto cs_failed;
 	}
@@ -379,7 +385,9 @@ static void dio24_config(struct pcmcia_d
 	   will only use the CIS to fill in implementation-defined details.
 	 */
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple)) != 0) {
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
@@ -449,7 +457,9 @@ static void dio24_config(struct pcmcia_d
 		break;
 
 	      next_entry:
-		if ((last_ret = pcmcia_get_next_tuple(link, &tuple)) != 0) {
+
+		last_ret = pcmcia_get_next_tuple(link, &tuple);
+		if (last_ret) {
 			cs_error(link, GetNextTuple, last_ret);
 			goto cs_failed;
 		}
@@ -460,18 +470,21 @@ static void dio24_config(struct pcmcia_d
 	   handler to the interrupt, unless the 'Handler' member of the
 	   irq structure is initialized.
 	 */
-	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		if ((last_ret = pcmcia_request_irq(link, &link->irq)) != 0) {
+	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
+		last_ret = pcmcia_request_irq(link, &link->irq);
+		if (last_ret) {
 			cs_error(link, RequestIRQ, last_ret);
 			goto cs_failed;
 		}
+	}
 
 	/*
 	   This actually configures the PCMCIA socket -- setting up
 	   the I/O windows and the interrupt mapping, and putting the
 	   card and host interface into "Memory and IO" mode.
 	 */
-	if ((last_ret = pcmcia_request_configuration(link, &link->conf)) != 0) {
+	last_ret = pcmcia_request_configuration(link, &link->conf);
+	if (last_ret) {
 		cs_error(link, RequestConfiguration, last_ret);
 		goto cs_failed;
 	}
--- a/drivers/staging/comedi/drivers/ni_labpc_cs.c
+++ b/drivers/staging/comedi/drivers/ni_labpc_cs.c
@@ -327,15 +327,21 @@ static void labpc_config(struct pcmcia_d
 	tuple.TupleData = buf;
 	tuple.TupleDataMax = sizeof(buf);
 	tuple.TupleOffset = 0;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple))) {
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_get_tuple_data(link, &tuple))) {
+
+	last_ret = pcmcia_get_tuple_data(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetTupleData, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse))) {
+
+	last_ret = pcmcia_parse_tuple(&tuple, &parse);
+	if (last_ret) {
 		cs_error(link, ParseTuple, last_ret);
 		goto cs_failed;
 	}
@@ -355,7 +361,8 @@ static void labpc_config(struct pcmcia_d
 	   will only use the CIS to fill in implementation-defined details.
 	 */
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple))) {
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
@@ -422,7 +429,8 @@ static void labpc_config(struct pcmcia_d
 		break;
 
 	      next_entry:
-		if ((last_ret = pcmcia_get_next_tuple(link, &tuple))) {
+		last_ret = pcmcia_get_next_tuple(link, &tuple);
+		if (last_ret) {
 			cs_error(link, GetNextTuple, last_ret);
 			goto cs_failed;
 		}
@@ -433,18 +441,21 @@ static void labpc_config(struct pcmcia_d
 	   handler to the interrupt, unless the 'Handler' member of the
 	   irq structure is initialized.
 	 */
-	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		if ((last_ret = pcmcia_request_irq(link, &link->irq))) {
+	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
+		last_ret = pcmcia_request_irq(link, &link->irq);
+		if (last_ret) {
 			cs_error(link, RequestIRQ, last_ret);
 			goto cs_failed;
 		}
+	}
 
 	/*
 	   This actually configures the PCMCIA socket -- setting up
 	   the I/O windows and the interrupt mapping, and putting the
 	   card and host interface into "Memory and IO" mode.
 	 */
-	if ((last_ret = pcmcia_request_configuration(link, &link->conf))) {
+	last_ret = pcmcia_request_configuration(link, &link->conf);
+	if (last_ret) {
 		cs_error(link, RequestConfiguration, last_ret);
 		goto cs_failed;
 	}
--- a/drivers/staging/comedi/drivers/ni_mio_cs.c
+++ b/drivers/staging/comedi/drivers/ni_mio_cs.c
@@ -446,24 +446,28 @@ static int mio_cs_attach(struct comedi_d
 	printk(" %s", boardtype.name);
 	dev->board_name = boardtype.name;
 
-	if ((ret = comedi_request_irq(irq, ni_E_interrupt, NI_E_IRQ_FLAGS,
-				"ni_mio_cs", dev)) < 0) {
+	ret = comedi_request_irq(irq, ni_E_interrupt, NI_E_IRQ_FLAGS,
+				 "ni_mio_cs", dev);
+	if (ret < 0) {
 		printk(" irq not available\n");
 		return -EINVAL;
 	}
 	dev->irq = irq;
 
 	/* allocate private area */
-	if ((ret = ni_alloc_private(dev)) < 0)
+	ret = ni_alloc_private(dev);
+	if (ret < 0)
 		return ret;
+
 	devpriv->stc_writew = &mio_cs_win_out;
 	devpriv->stc_readw = &mio_cs_win_in;
 	devpriv->stc_writel = &win_out2;
 	devpriv->stc_readl = &win_in2;
 
-	if ((ret = ni_E_init(dev, it)) < 0) {
+	ret = ni_E_init(dev, it);
+
+	if (ret < 0)
 		return ret;
-	}
 
 	return 0;
 }
--- a/drivers/staging/comedi/drivers/ni_pcimio.c
+++ b/drivers/staging/comedi/drivers/ni_pcimio.c
@@ -1679,9 +1679,10 @@ static int pcimio_attach(struct comedi_d
 		printk(" unknown irq (bad)\n");
 	} else {
 		printk(" ( irq = %u )", dev->irq);
-		if ((ret = comedi_request_irq(dev->irq, ni_E_interrupt,
-					NI_E_IRQ_FLAGS, DRV_NAME,
-					dev)) < 0) {
+		ret = comedi_request_irq(dev->irq, ni_E_interrupt,
+					 NI_E_IRQ_FLAGS, DRV_NAME,
+					 dev);
+		if (ret < 0) {
 			printk(" irq not available\n");
 			dev->irq = 0;
 		}
--- a/drivers/staging/comedi/drivers/pcl711.c
+++ b/drivers/staging/comedi/drivers/pcl711.c
@@ -550,9 +550,12 @@ static int pcl711_attach(struct comedi_d
 	}
 	dev->irq = irq;
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
-	if ((ret = alloc_private(dev, sizeof(struct pcl711_private))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct pcl711_private));
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/pcl724.c
+++ b/drivers/staging/comedi/drivers/pcl724.c
@@ -183,7 +183,8 @@ static int pcl724_attach(struct comedi_d
 			|| (it->options[1] == 96)))
 		n_subdevices = 4;	/*  PCL-724 in 96 DIO configuration */
 
-	if ((ret = alloc_subdevices(dev, n_subdevices)) < 0)
+	ret = alloc_subdevices(dev, n_subdevices);
+	if (ret < 0)
 		return ret;
 
 	for (i = 0; i < dev->n_subdevices; i++) {
--- a/drivers/staging/comedi/drivers/pcl726.c
+++ b/drivers/staging/comedi/drivers/pcl726.c
@@ -264,7 +264,8 @@ static int pcl726_attach(struct comedi_d
 
 	dev->board_name = this_board->name;
 
-	if ((ret = alloc_private(dev, sizeof(struct pcl726_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct pcl726_private));
+	if (ret < 0)
 		return -ENOMEM;
 
 	for (i = 0; i < 12; i++) {
@@ -302,7 +303,8 @@ static int pcl726_attach(struct comedi_d
 
 	printk("\n");
 
-	if ((ret = alloc_subdevices(dev, 3)) < 0)
+	ret = alloc_subdevices(dev, 3);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/pcl812.c
+++ b/drivers/staging/comedi/drivers/pcl812.c
@@ -1286,7 +1286,8 @@ static int pcl812_attach(struct comedi_d
 	}
 	dev->iobase = iobase;
 
-	if ((ret = alloc_private(dev, sizeof(struct pcl812_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pcl812_private));
+	if (ret < 0) {
 		free_resources(dev);
 		return ret;	/* Can't alloc mem */
 	}
@@ -1364,7 +1365,8 @@ static int pcl812_attach(struct comedi_d
 	if (this_board->n_dochan > 0)
 		n_subdevices++;
 
-	if ((ret = alloc_subdevices(dev, n_subdevices)) < 0) {
+	ret = alloc_subdevices(dev, n_subdevices);
+	if (ret < 0) {
 		free_resources(dev);
 		return ret;
 	}
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -1041,7 +1041,8 @@ static int pcl816_attach(struct comedi_d
 		return -EIO;
 	}
 
-	if ((ret = alloc_private(dev, sizeof(struct pcl816_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct pcl816_private));
+	if (ret < 0)
 		return ret;	/* Can't alloc mem */
 
 	/* set up some name stuff */
@@ -1177,7 +1178,9 @@ static int pcl816_attach(struct comedi_d
   if (this_board->n_dochan > 0)
     subdevs[3] = COMEDI_SUBD_DO;
 */
-	if ((ret = alloc_subdevices(dev, 1)) < 0)
+
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1703,7 +1703,8 @@ static int pcl818_attach(struct comedi_d
 	unsigned long pages;
 	struct comedi_subdevice *s;
 
-	if ((ret = alloc_private(dev, sizeof(struct pcl818_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct pcl818_private));
+	if (ret < 0)
 		return ret;	/* Can't alloc mem */
 
 	/* claim our I/O space */
@@ -1842,7 +1843,8 @@ static int pcl818_attach(struct comedi_d
 
       no_dma:
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
--- a/drivers/staging/comedi/drivers/pcm3724.c
+++ b/drivers/staging/comedi/drivers/pcm3724.c
@@ -260,7 +260,9 @@ static int pcm3724_attach(struct comedi_
 
 	iobase = it->options[0];
 	iorange = this_board->io_range;
-	if ((ret = alloc_private(dev, sizeof(struct priv_pcm3724))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct priv_pcm3724));
+	if (ret < 0)
 		return -ENOMEM;
 
 	((struct priv_pcm3724 *) (dev->private))->dio_1 = 0;
@@ -279,7 +281,8 @@ static int pcm3724_attach(struct comedi_
 
 	n_subdevices = this_board->numofports;
 
-	if ((ret = alloc_subdevices(dev, n_subdevices)) < 0)
+	ret = alloc_subdevices(dev, n_subdevices);
+	if (ret < 0)
 		return ret;
 
 	for (i = 0; i < dev->n_subdevices; i++) {
--- a/drivers/staging/comedi/drivers/pcmad.c
+++ b/drivers/staging/comedi/drivers/pcmad.c
@@ -140,9 +140,12 @@ static int pcmad_attach(struct comedi_de
 	}
 	dev->iobase = iobase;
 
-	if ((ret = alloc_subdevices(dev, 1)) < 0)
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0)
 		return ret;
-	if ((ret = alloc_private(dev, sizeof(struct pcmad_priv_struct))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct pcmad_priv_struct));
+	if (ret < 0)
 		return ret;
 
 	dev->board_name = this_board->name;
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -921,7 +921,8 @@ static void pcmmio_stop_intr(struct come
 {
 	int nports, firstport, asic, port;
 
-	if ((asic = subpriv->dio.intr.asic) < 0)
+	asic = subpriv->dio.intr.asic;
+	if (asic < 0)
 		return;		/* not an interrupt subdev */
 
 	subpriv->dio.intr.enabled_mask = 0;
@@ -948,7 +949,8 @@ static int pcmmio_start_intr(struct come
 		int nports, firstport, asic, port;
 		struct comedi_cmd *cmd = &s->async->cmd;
 
-		if ((asic = subpriv->dio.intr.asic) < 0)
+		asic = subpriv->dio.intr.asic;
+		if (asic  < 0)
 			return 1;	/* not an interrupt
 					   subdev */
 		subpriv->dio.intr.enabled_mask = 0;
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -841,7 +841,8 @@ static void pcmuio_stop_intr(struct come
 {
 	int nports, firstport, asic, port;
 
-	if ((asic = subpriv->intr.asic) < 0)
+	asic = subpriv->intr.asic;
+	if (asic < 0)
 		return;		/* not an interrupt subdev */
 
 	subpriv->intr.enabled_mask = 0;
@@ -868,7 +869,8 @@ static int pcmuio_start_intr(struct come
 		int nports, firstport, asic, port;
 		struct comedi_cmd *cmd = &s->async->cmd;
 
-		if ((asic = subpriv->intr.asic) < 0)
+		asic = subpriv->intr.asic;
+		if (asic < 0)
 			return 1;	/* not an interrupt
 					   subdev */
 		subpriv->intr.enabled_mask = 0;
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -908,7 +908,8 @@ static int daqp_attach(struct comedi_dev
 
 	dev->iobase = local->link->io.BasePort1;
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	printk("comedi%d: attaching daqp%d (io 0x%04lx)\n",
@@ -1149,15 +1150,21 @@ static void daqp_cs_config(struct pcmcia
 	tuple.TupleData = buf;
 	tuple.TupleDataMax = sizeof(buf);
 	tuple.TupleOffset = 0;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple))) {
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_get_tuple_data(link, &tuple))) {
+
+	last_ret = pcmcia_get_tuple_data(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetTupleData, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse))) {
+
+	last_ret = pcmcia_parse_tuple(&tuple, &parse);
+	if (last_ret) {
 		cs_error(link, ParseTuple, last_ret);
 		goto cs_failed;
 	}
@@ -1177,10 +1184,12 @@ static void daqp_cs_config(struct pcmcia
 	   will only use the CIS to fill in implementation-defined details.
 	 */
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple))) {
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
+
 	while (1) {
 		cistpl_cftable_entry_t dflt = { 0 };
 		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
@@ -1226,7 +1235,8 @@ static void daqp_cs_config(struct pcmcia
 		break;
 
 	      next_entry:
-		if ((last_ret = pcmcia_get_next_tuple(link, &tuple))) {
+		last_ret = pcmcia_get_next_tuple(link, &tuple);
+		if (last_ret) {
 			cs_error(link, GetNextTuple, last_ret);
 			goto cs_failed;
 		}
@@ -1237,18 +1247,21 @@ static void daqp_cs_config(struct pcmcia
 	   handler to the interrupt, unless the 'Handler' member of the
 	   irq structure is initialized.
 	 */
-	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		if ((last_ret = pcmcia_request_irq(link, &link->irq))) {
+	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
+		last_ret = pcmcia_request_irq(link, &link->irq);
+		if (last_ret) {
 			cs_error(link, RequestIRQ, last_ret);
 			goto cs_failed;
 		}
+	}
 
 	/*
 	   This actually configures the PCMCIA socket -- setting up
 	   the I/O windows and the interrupt mapping, and putting the
 	   card and host interface into "Memory and IO" mode.
 	 */
-	if ((last_ret = pcmcia_request_configuration(link, &link->conf))) {
+	last_ret = pcmcia_request_configuration(link, &link->conf);
+	if (last_ret) {
 		cs_error(link, RequestConfiguration, last_ret);
 		goto cs_failed;
 	}
--- a/drivers/staging/comedi/drivers/rti800.c
+++ b/drivers/staging/comedi/drivers/rti800.c
@@ -339,8 +339,9 @@ static int rti800_attach(struct comedi_d
 	irq = it->options[1];
 	if (irq) {
 		printk("( irq = %u )", irq);
-		if ((ret = comedi_request_irq(irq, rti800_interrupt, 0,
-					"rti800", dev)) < 0) {
+		ret = comedi_request_irq(irq, rti800_interrupt, 0,
+					 "rti800", dev);
+		if (ret < 0) {
 			printk(" Failed to allocate IRQ\n");
 			return ret;
 		}
@@ -351,9 +352,12 @@ static int rti800_attach(struct comedi_d
 
 	dev->board_name = this_board->name;
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
-	if ((ret = alloc_private(dev, sizeof(struct rti800_private))) < 0)
+
+	ret = alloc_private(dev, sizeof(struct rti800_private));
+	if (ret < 0)
 		return ret;
 
 	devpriv->adc_mux = it->options[2];
--- a/drivers/staging/comedi/drivers/unioxx5.c
+++ b/drivers/staging/comedi/drivers/unioxx5.c
@@ -213,7 +213,8 @@ static int unioxx5_insn_config(struct co
 		return -1;
 	}
 
-	if ((channel_offset = __unioxx5_define_chan_offset(channel)) < 0) {
+	channel_offset = __unioxx5_define_chan_offset(channel);
+	if (channel_offset < 0) {
 		printk(KERN_ERR
 			"comedi%d: undefined channel %d. channel range is 0 .. 23\n",
 			dev->minor, channel);
@@ -275,8 +276,9 @@ static int __unioxx5_subdev_init(struct 
 		return -EIO;
 	}
 
-	if ((usp = (struct unioxx5_subd_priv *) kzalloc(sizeof(*usp),
-				GFP_KERNEL)) == NULL) {
+	usp = (struct unioxx5_subd_priv *) kzalloc(sizeof(*usp), GFP_KERNEL);
+
+	if (usp == NULL) {
 		printk(KERN_ERR "comedi%d: erorr! --> out of memory!\n", minor);
 		return -1;
 	}
@@ -336,7 +338,8 @@ static int __unioxx5_digital_write(struc
 	int channel_offset, val;
 	int mask = 1 << (channel & 0x07);
 
-	if ((channel_offset = __unioxx5_define_chan_offset(channel)) < 0) {
+	channel_offset = __unioxx5_define_chan_offset(channel);
+	if (channel_offset < 0) {
 		printk(KERN_ERR
 			"comedi%d: undefined channel %d. channel range is 0 .. 23\n",
 			minor, channel);
@@ -362,7 +365,8 @@ static int __unioxx5_digital_read(struct
 {
 	int channel_offset, mask = 1 << (channel & 0x07);
 
-	if ((channel_offset = __unioxx5_define_chan_offset(channel)) < 0) {
+	channel_offset = __unioxx5_define_chan_offset(channel);
+	if (channel_offset < 0) {
 		printk(KERN_ERR
 			"comedi%d: undefined channel %d. channel range is 0 .. 23\n",
 			minor, channel);
