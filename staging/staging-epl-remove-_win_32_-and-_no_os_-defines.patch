From 35643fd07f44ef9d38610fce336a9e58b0aff157 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Mon, 23 Mar 2009 10:54:14 -0700
Subject: [PATCH] Staging: epl: remove _WIN_32_ and _NO_OS_ defines

They are not used.

Also remove the code that was looking for them.

Cc: Daniel Krueger <daniel.krueger@systec-electronic.com>
Cc: Ronald Sieber <Ronald.Sieber@systec-electronic.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/epl/Benchmark.h  |    5 -
 drivers/staging/epl/Debug.h      |   21 ------
 drivers/staging/epl/EplAmi.h     |   11 ---
 drivers/staging/epl/EplSdoUdpu.c |  128 ++-------------------------------------
 drivers/staging/epl/EplTarget.h  |   79 ------------------------
 drivers/staging/epl/ShbIpc.h     |   11 ---
 drivers/staging/epl/global.h     |    2 
 7 files changed, 10 insertions(+), 247 deletions(-)

--- a/drivers/staging/epl/Benchmark.h
+++ b/drivers/staging/epl/Benchmark.h
@@ -73,10 +73,7 @@
 
 #include "global.h"
 
-#if (TARGET_SYSTEM == _NO_OS_) && (DEV_SYSTEM == _DEV_GNU_CF548X_)
-#include "common.h"
-
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 
 //    #include <linux/config.h>
 #include <linux/kernel.h>
--- a/drivers/staging/epl/Debug.h
+++ b/drivers/staging/epl/Debug.h
@@ -163,25 +163,6 @@
 #endif
 
 //---------------------------------------------------------------------------
-#if (DEV_SYSTEM == _DEV_WIN32_) && defined (TRACE_MSG)
-
-    // For WIN32 the macro DEBUG_TRACE0 can be defined as function call TraceLvl()
-    // or as macro TRACE().
-    //
-    // Here the parameter 'lvl' can be used with more than one
-    // debug-level (using OR).
-    //
-    // Example: DEBUG_TRACE1(DEBUG_LVL_30 | DEBUG_LVL_02, "Hello %d", bCount);
-
-#define DEBUG_TRACE0(lvl,str)               TraceLvl((lvl),str)
-#define DEBUG_TRACE1(lvl,str,p1)            TraceLvl((lvl),str,p1)
-#define DEBUG_TRACE2(lvl,str,p1,p2)         TraceLvl((lvl),str,p1,p2)
-#define DEBUG_TRACE3(lvl,str,p1,p2,p3)      TraceLvl((lvl),str,p1,p2,p3)
-#define DEBUG_TRACE4(lvl,str,p1,p2,p3,p4)   TraceLvl((lvl),str,p1,p2,p3,p4)
-#define DEBUG_GLB_LVL()                     dwDebugLevel_g
-
-#else
-
     // At microcontrollers we do reduce the memory usage by deleting DEBUG_TRACE-lines
     // (compiler does delete the lines).
     //
@@ -643,8 +624,6 @@
 #define DEBUG_TRACE3(lvl,str,p1,p2,p3)                  lvl##_TRACE3(str,p1,p2,p3)
 #define DEBUG_TRACE4(lvl,str,p1,p2,p3,p4)               lvl##_TRACE4(str,p1,p2,p3,p4)
 
-#endif
-
 //---------------------------------------------------------------------------
 // The macro DEBUG_DUMP_DATA() can be used with the same debug-levels to dump
 // out data bytes. Function DumpData() has to be included.
--- a/drivers/staging/epl/EplAmi.h
+++ b/drivers/staging/epl/EplAmi.h
@@ -104,16 +104,7 @@
 extern "C" {
 #endif
 
-#if (TARGET_SYSTEM == _WIN32_)
-#if defined(INLINE_FUNCTION_DEF)
-#undef  INLINE_FUNCTION
-#define INLINE_FUNCTION     INLINE_FUNCTION_DEF
-#define INLINE_ENABLED      TRUE
-#define EPL_AMI_INLINED
-#include "../EplStack/amix86.c"
-#endif
-
-#elif (TARGET_SYSTEM == _LINUX_)
+#if (TARGET_SYSTEM == _LINUX_)
 #if defined(__m68k__)		// it is an big endian machine
 #if defined(INLINE_FUNCTION_DEF)
 #undef  INLINE_FUNCTION
--- a/drivers/staging/epl/EplSdoUdpu.c
+++ b/drivers/staging/epl/EplSdoUdpu.c
@@ -110,12 +110,7 @@ typedef struct {
 	tEplSequLayerReceiveCb m_fpSdoAsySeqCb;
 	SOCKET m_UdpSocket;
 
-#if (TARGET_SYSTEM == _WIN32_)
-	HANDLE m_ThreadHandle;
-	LPCRITICAL_SECTION m_pCriticalSection;
-	CRITICAL_SECTION m_CriticalSection;
-
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 	struct completion m_CompletionUdpThread;
 	int m_ThreadHandle;
 	int m_iTerminateThread;
@@ -133,10 +128,7 @@ static tEplSdoUdpInstance SdoUdpInstance
 // local function prototypes
 //---------------------------------------------------------------------------
 
-#if (TARGET_SYSTEM == _WIN32_)
-static DWORD EplSdoUdpThread(LPVOID lpParameter);
-
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 static int EplSdoUdpThread(void *pArg_p);
 #endif
 
@@ -209,12 +201,6 @@ tEplKernel EplSdoUdpuAddInstance(tEplSeq
 {
 	tEplKernel Ret;
 
-#if (TARGET_SYSTEM == _WIN32_)
-	int iError;
-	WSADATA Wsa;
-
-#endif
-
 	// set instance variables to 0
 	EPL_MEMSET(&SdoUdpInstance_g, 0x00, sizeof(SdoUdpInstance_g));
 
@@ -228,20 +214,7 @@ tEplKernel EplSdoUdpuAddInstance(tEplSeq
 		goto Exit;
 	}
 
-#if (TARGET_SYSTEM == _WIN32_)
-	// start winsock2 for win32
-	// windows specific start of socket
-	iError = WSAStartup(MAKEWORD(2, 0), &Wsa);
-	if (iError != 0) {
-		Ret = kEplSdoUdpNoSocket;
-		goto Exit;
-	}
-	// create critical section for acccess of instnace variables
-	SdoUdpInstance_g.m_pCriticalSection =
-	    &SdoUdpInstance_g.m_CriticalSection;
-	InitializeCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 	init_completion(&SdoUdpInstance_g.m_CompletionUdpThread);
 	SdoUdpInstance_g.m_iTerminateThread = 0;
 #endif
@@ -277,22 +250,11 @@ tEplKernel EplSdoUdpuDelInstance(void)
 {
 	tEplKernel Ret;
 
-#if (TARGET_SYSTEM == _WIN32_)
-	BOOL fTermError;
-#endif
-
 	Ret = kEplSuccessful;
 
 	if (SdoUdpInstance_g.m_ThreadHandle != 0) {	// listen thread was started
 		// close thread
-#if (TARGET_SYSTEM == _WIN32_)
-		fTermError =
-		    TerminateThread(SdoUdpInstance_g.m_ThreadHandle, 0);
-		if (fTermError == FALSE) {
-			Ret = kEplSdoUdpThreadError;
-			goto Exit;
-		}
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 		SdoUdpInstance_g.m_iTerminateThread = 1;
 		/* kill_proc(SdoUdpInstance_g.m_ThreadHandle, SIGTERM, 1 ); */
 		send_sig(SIGTERM, SdoUdpInstance_g.m_ThreadHandle, 1);
@@ -307,19 +269,6 @@ tEplKernel EplSdoUdpuDelInstance(void)
 		closesocket(SdoUdpInstance_g.m_UdpSocket);
 		SdoUdpInstance_g.m_UdpSocket = INVALID_SOCKET;
 	}
-#if (TARGET_SYSTEM == _WIN32_)
-	// delete critical section
-	DeleteCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-
-#if (TARGET_SYSTEM == _WIN32_)
-	// for win 32
-	WSACleanup();
-#endif
-
-#if (TARGET_SYSTEM == _WIN32_)
-      Exit:
-#endif
 	return Ret;
 }
 
@@ -346,11 +295,6 @@ tEplKernel EplSdoUdpuConfig(unsigned lon
 	struct sockaddr_in Addr;
 	int iError;
 
-#if (TARGET_SYSTEM == _WIN32_)
-	BOOL fTermError;
-	unsigned long ulThreadId;
-#endif
-
 	Ret = kEplSuccessful;
 
 	if (uiPort_p == 0) {	// set UDP port to default port number
@@ -363,14 +307,7 @@ tEplKernel EplSdoUdpuConfig(unsigned lon
 	if (SdoUdpInstance_g.m_ThreadHandle != 0) {	// listen thread was started
 
 		// close old thread
-#if (TARGET_SYSTEM == _WIN32_)
-		fTermError =
-		    TerminateThread(SdoUdpInstance_g.m_ThreadHandle, 0);
-		if (fTermError == FALSE) {
-			Ret = kEplSdoUdpThreadError;
-			goto Exit;
-		}
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 		SdoUdpInstance_g.m_iTerminateThread = 1;
 		/* kill_proc(SdoUdpInstance_g.m_ThreadHandle, SIGTERM, 1 ); */
 		send_sig(SIGTERM, SdoUdpInstance_g.m_ThreadHandle, 1);
@@ -412,20 +349,7 @@ tEplKernel EplSdoUdpuConfig(unsigned lon
 		goto Exit;
 	}
 	// create Listen-Thread
-#if (TARGET_SYSTEM == _WIN32_)
-	// for win32
-
-	// create thread
-	SdoUdpInstance_g.m_ThreadHandle = CreateThread(NULL,
-						       0,
-						       EplSdoUdpThread,
-						       &SdoUdpInstance_g,
-						       0, &ulThreadId);
-	if (SdoUdpInstance_g.m_ThreadHandle == NULL) {
-		Ret = kEplSdoUdpThreadError;
-		goto Exit;
-	}
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 
 	SdoUdpInstance_g.m_ThreadHandle =
 	    kernel_thread(EplSdoUdpThread, &SdoUdpInstance_g, CLONE_KERNEL);
@@ -552,22 +476,12 @@ tEplKernel EplSdoUdpuSendData(tEplSdoCon
 
 	// call sendto
 	Addr.sin_family = AF_INET;
-#if (TARGET_SYSTEM == _WIN32_)
-	// enter  critical section for process function
-	EnterCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-
 	Addr.sin_port =
 	    (unsigned short)SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].
 	    m_uiPort;
 	Addr.sin_addr.s_addr =
 	    SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].m_ulIpAddr;
 
-#if (TARGET_SYSTEM == _WIN32_)
-	// leave critical section for process function
-	LeaveCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-
 	iError = sendto(SdoUdpInstance_g.m_UdpSocket,	// sockethandle
 			(const char *)&pSrcData_p->m_le_bMessageType,	// data to send
 			dwDataSize_p,	// number of bytes to send
@@ -647,11 +561,7 @@ tEplKernel EplSdoUdpuDelCon(tEplSdoConHd
 // State:
 //
 //---------------------------------------------------------------------------
-#if (TARGET_SYSTEM == _WIN32_)
-static DWORD EplSdoUdpThread(LPVOID lpParameter)
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 static int EplSdoUdpThread(void *pArg_p)
-#endif
 {
 
 	tEplSdoUdpInstance *pInstance;
@@ -663,11 +573,7 @@ static int EplSdoUdpThread(void *pArg_p)
 	unsigned int uiSize;
 	tEplSdoConHdl SdoConHdl;
 
-#if (TARGET_SYSTEM == _WIN32_)
-	pInstance = (tEplSdoUdpInstance *) lpParameter;
-
-	for (;;)
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 	pInstance = (tEplSdoUdpInstance *) pArg_p;
 	daemonize("EplSdoUdpThread");
 	allow_signal(SIGTERM);
@@ -693,11 +599,6 @@ static int EplSdoUdpThread(void *pArg_p)
 			// get handle for higher layer
 			iCount = 0;
 			iFreeEntry = 0xFFFF;
-#if (TARGET_SYSTEM == _WIN32_)
-			// enter  critical section for process function
-			EnterCriticalSection(SdoUdpInstance_g.
-					     m_pCriticalSection);
-#endif
 			while (iCount < EPL_SDO_MAX_CONNECTION_UDP) {
 				// check if this connection is already known
 				if ((pInstance->m_aSdoAbsUdpConnection[iCount].
@@ -733,11 +634,6 @@ static int EplSdoUdpThread(void *pArg_p)
 					pInstance->
 					    m_aSdoAbsUdpConnection[iFreeEntry].
 					    m_uiPort = RemoteAddr.sin_port;
-#if (TARGET_SYSTEM == _WIN32_)
-					// leave critical section for process function
-					LeaveCriticalSection(SdoUdpInstance_g.
-							     m_pCriticalSection);
-#endif
 					// call callback
 					SdoConHdl = iFreeEntry;
 					SdoConHdl |= EPL_SDO_UDP_HANDLE;
@@ -751,11 +647,6 @@ static int EplSdoUdpThread(void *pArg_p)
 				} else {
 					EPL_DBGLVL_SDO_TRACE0
 					    ("Error in EplSdoUdpThread() no free handle\n");
-#if (TARGET_SYSTEM == _WIN32_)
-					// leave critical section for process function
-					LeaveCriticalSection(SdoUdpInstance_g.
-							     m_pCriticalSection);
-#endif
 				}
 
 			} else {
@@ -763,11 +654,6 @@ static int EplSdoUdpThread(void *pArg_p)
 				// call callback with correct handle
 				SdoConHdl = iCount;
 				SdoConHdl |= EPL_SDO_UDP_HANDLE;
-#if (TARGET_SYSTEM == _WIN32_)
-				// leave critical section for process function
-				LeaveCriticalSection(SdoUdpInstance_g.
-						     m_pCriticalSection);
-#endif
 				// offset 4 -> start of SDO Sequence header
 				pInstance->m_fpSdoAsySeqCb(SdoConHdl,
 							   (tEplAsySdoSeq *) &
--- a/drivers/staging/epl/EplTarget.h
+++ b/drivers/staging/epl/EplTarget.h
@@ -83,83 +83,6 @@
 // applications needs to use one common library function (e.g. memcpy()). So
 // you can set (or change) it here.
 
-#if (TARGET_SYSTEM == _WIN32_)
-
-#define _WIN32_WINDOWS 0x0401
-#define _WIN32_WINNT   0x0400
-
-#include <stdlib.h>
-#include <stdio.h>
-
-    //29.11.2004 f.j. sonst ist memcpy und memset unbekannt
-#include <string.h>
-
-#define EPL_MEMCPY(dst,src,siz)     memcpy((void*)(dst),(const void*)(src),(size_t)(siz));
-#define EPL_MEMSET(dst,val,siz)     memset((void*)(dst),(int)(val),(size_t)(siz));
-
-    // f.j.: die Funktionen für <MemAlloc> und <MemFree> sind in WinMem.c definiert
-    //definition der Prototypen
-void FAR *MemAlloc(DWORD dwMemSize_p);
-void MemFree(void FAR * pMem_p);
-
-#define EPL_MALLOC(siz)             malloc((size_t)(siz))
-#define EPL_FREE(ptr)               free((void *)ptr)
-
-#ifndef PRINTF0
-void trace(const char *fmt, ...);
-#define PRINTF                      TRACE
-#define PRINTF0(arg)                TRACE0(arg)
-#define PRINTF1(arg,p1)             TRACE1(arg,p1)
-#define PRINTF2(arg,p1,p2)          TRACE2(arg,p1,p2)
-#define PRINTF3(arg,p1,p2,p3)       TRACE3(arg,p1,p2,p3)
-#define PRINTF4(arg,p1,p2,p3,p4)    TRACE4(arg,p1,p2,p3,p4)
-	//#define PRINTF                      printf
-	//#define PRINTF0(arg)                PRINTF(arg)
-	//#define PRINTF1(arg,p1)             PRINTF(arg,p1)
-	//#define PRINTF2(arg,p1,p2)          PRINTF(arg,p1,p2)
-	//#define PRINTF3(arg,p1,p2,p3)       PRINTF(arg,p1,p2,p3)
-	//#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
-#endif
-
-#ifdef ASSERTMSG
-#undef ASSERTMSG
-#endif
-
-#define ASSERTMSG(expr,string)  if (!(expr)) { \
-                                        MessageBox (NULL, string, "Assertion failed", MB_OK | MB_ICONERROR); \
-                                        exit (-1);}
-
-#elif (TARGET_SYSTEM == _NO_OS_)
-
-#include <stdlib.h>
-#include <stdio.h>
-
-    //29.11.2004 f.j. sonst ist memcpy und memset unbekannt
-//    #include <string.h>
-
-#define EPL_MEMCPY(dst,src,siz)     memcpy((void*)(dst),(const void*)(src),(size_t)(siz));
-#define EPL_MEMSET(dst,val,siz)     memset((void*)(dst),(int)(val),(size_t)(siz));
-
-#define EPL_MALLOC(siz)             malloc((size_t)(siz))
-#define EPL_FREE(ptr)               free((void *)ptr)
-
-#ifndef PRINTF0
-#define PRINTF                      TRACE
-#define PRINTF0(arg)                TRACE0(arg)
-#define PRINTF1(arg,p1)             TRACE1(arg,p1)
-#define PRINTF2(arg,p1,p2)          TRACE2(arg,p1,p2)
-#define PRINTF3(arg,p1,p2,p3)       TRACE3(arg,p1,p2,p3)
-#define PRINTF4(arg,p1,p2,p3,p4)    TRACE4(arg,p1,p2,p3,p4)
-	//#define PRINTF                      printf
-	//#define PRINTF0(arg)                PRINTF(arg)
-	//#define PRINTF1(arg,p1)             PRINTF(arg,p1)
-	//#define PRINTF2(arg,p1,p2)          PRINTF(arg,p1,p2)
-	//#define PRINTF3(arg,p1,p2,p3)       PRINTF(arg,p1,p2,p3)
-	//#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
-#endif
-
-#elif (TARGET_SYSTEM == _LINUX_)
-
 #ifndef __KERNEL__
 #include <stdlib.h>
 #include <stdio.h>
@@ -202,8 +125,6 @@ void trace(const char *fmt, ...);
 	//#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
 #endif
 
-#endif
-
 #define EPL_TGT_INTMASK_ETH     0x0001	// ethernet interrupt
 #define EPL_TGT_INTMASK_DMA     0x0002	// DMA interrupt
 
--- a/drivers/staging/epl/global.h
+++ b/drivers/staging/epl/global.h
@@ -121,8 +121,6 @@
 //---------------------------------------------------------------------------
 //  defines for target system (TARGET_SYSTEM)
 //---------------------------------------------------------------------------
-#define _WIN32_             32
-#define _NO_OS_              0
 #define _LINUX_              1
 
 //---------------------------------------------------------------------------
--- a/drivers/staging/epl/ShbIpc.h
+++ b/drivers/staging/epl/ShbIpc.h
@@ -65,16 +65,7 @@ typedef int (*tSigHndlrNewData) (tShbIns
 typedef void (*tSigHndlrJobReady) (tShbInstance pShbInstance_p,
 				   unsigned int fTimeOut_p);
 
-#if (TARGET_SYSTEM == _WIN32_)
-#if defined(INLINE_FUNCTION_DEF)
-#undef  INLINE_FUNCTION
-#define INLINE_FUNCTION     INLINE_FUNCTION_DEF
-#define SHBIPC_INLINE_ENABLED      TRUE
-#define SHBIPC_INLINED
-#include "ShbIpc-Win32.c"
-#endif
-
-#elif (TARGET_SYSTEM == _LINUX_)
+#if (TARGET_SYSTEM == _LINUX_)
 #if defined(INLINE_FUNCTION_DEF)
 #undef  INLINE_FUNCTION
 #define INLINE_FUNCTION     INLINE_FUNCTION_DEF
