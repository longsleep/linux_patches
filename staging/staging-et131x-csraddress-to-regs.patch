From alan@linux.intel.com  Thu Aug 27 14:24:35 2009
From: Alan Cox <alan@linux.intel.com>
Date: Thu, 27 Aug 2009 10:59:30 +0100
Subject: Staging: et131x: CSRAddress to regs
To: greg@kroah.com
Message-ID: <20090827095927.23892.24455.stgit@localhost.localdomain>


Switch this to a Linux like naming as it occurs all over.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_jagcore.c |    8 ++++----
 drivers/staging/et131x/et1310_mac.c     |   32 ++++++++++++++++----------------
 drivers/staging/et131x/et1310_phy.c     |    4 ++--
 drivers/staging/et131x/et1310_pm.c      |   10 +++++-----
 drivers/staging/et131x/et1310_rx.c      |   26 +++++++++++++-------------
 drivers/staging/et131x/et1310_tx.c      |   20 ++++++++++----------
 drivers/staging/et131x/et131x_adapter.h |    2 +-
 drivers/staging/et131x/et131x_debug.c   |    8 ++++----
 drivers/staging/et131x/et131x_initpci.c |   20 ++++++++++----------
 drivers/staging/et131x/et131x_isr.c     |    6 +++---
 drivers/staging/et131x/et131x_netdev.c  |    8 ++++----
 11 files changed, 72 insertions(+), 72 deletions(-)


--- a/drivers/staging/et131x/et1310_jagcore.c
+++ b/drivers/staging/et131x/et1310_jagcore.c
@@ -101,7 +101,7 @@ extern dbg_info_t *et131x_dbginfo;
  */
 void ConfigGlobalRegs(struct et131x_adapter *etdev)
 {
-	struct _GLOBAL_t __iomem *pGbl = &etdev->CSRAddress->global;
+	struct _GLOBAL_t __iomem *pGbl = &etdev->regs->global;
 
 	DBG_ENTER(et131x_dbginfo);
 
@@ -188,7 +188,7 @@ void ConfigMMCRegs(struct et131x_adapter
 	mmc_ctrl.bits.arb_disable = 0x0;
 	mmc_ctrl.bits.mmc_enable = 0x1;
 
-	writel(mmc_ctrl.value, &etdev->CSRAddress->mmc.mmc_ctrl.value);
+	writel(mmc_ctrl.value, &etdev->regs->mmc.mmc_ctrl.value);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
@@ -207,12 +207,12 @@ void et131x_enable_interrupts(struct et1
 		MaskValue |= 0x10000;
 
 	adapter->CachedMaskValue.value = MaskValue;
-	writel(MaskValue, &adapter->CSRAddress->global.int_mask.value);
+	writel(MaskValue, &adapter->regs->global.int_mask.value);
 }
 
 void et131x_disable_interrupts(struct et131x_adapter *adapter)
 {
 	/* Disable all global interrupts */
 	adapter->CachedMaskValue.value = INT_MASK_DISABLE;
-	writel(INT_MASK_DISABLE, &adapter->CSRAddress->global.int_mask.value);
+	writel(INT_MASK_DISABLE, &adapter->regs->global.int_mask.value);
 }
--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -103,7 +103,7 @@ extern dbg_info_t *et131x_dbginfo;
  */
 void ConfigMACRegs1(struct et131x_adapter *etdev)
 {
-	struct _MAC_t __iomem *pMac = &etdev->CSRAddress->mac;
+	struct _MAC_t __iomem *pMac = &etdev->regs->mac;
 	MAC_STATION_ADDR1_t station1;
 	MAC_STATION_ADDR2_t station2;
 	MAC_IPG_t ipg;
@@ -182,7 +182,7 @@ void ConfigMACRegs1(struct et131x_adapte
 void ConfigMACRegs2(struct et131x_adapter *etdev)
 {
 	int32_t delay = 0;
-	struct _MAC_t __iomem *pMac = &etdev->CSRAddress->mac;
+	struct _MAC_t __iomem *pMac = &etdev->regs->mac;
 	MAC_CFG1_t cfg1;
 	MAC_CFG2_t cfg2;
 	MAC_IF_CTRL_t ifctrl;
@@ -190,7 +190,7 @@ void ConfigMACRegs2(struct et131x_adapte
 
 	DBG_ENTER(et131x_dbginfo);
 
-	ctl.value = readl(&etdev->CSRAddress->txmac.ctl.value);
+	ctl.value = readl(&etdev->regs->txmac.ctl.value);
 	cfg1.value = readl(&pMac->cfg1.value);
 	cfg2.value = readl(&pMac->cfg2.value);
 	ifctrl.value = readl(&pMac->if_ctrl.value);
@@ -269,7 +269,7 @@ void ConfigMACRegs2(struct et131x_adapte
 	/* Enable TXMAC */
 	ctl.bits.txmac_en = 0x1;
 	ctl.bits.fc_disable = 0x1;
-	writel(ctl.value, &etdev->CSRAddress->txmac.ctl.value);
+	writel(ctl.value, &etdev->regs->txmac.ctl.value);
 
 	/* Ready to start the RXDMA/TXDMA engine */
 	if (!MP_TEST_FLAG(etdev, fMP_ADAPTER_LOWER_POWER)) {
@@ -285,7 +285,7 @@ void ConfigMACRegs2(struct et131x_adapte
 
 void ConfigRxMacRegs(struct et131x_adapter *etdev)
 {
-	struct _RXMAC_t __iomem *pRxMac = &etdev->CSRAddress->rxmac;
+	struct _RXMAC_t __iomem *pRxMac = &etdev->regs->rxmac;
 	RXMAC_WOL_SA_LO_t sa_lo;
 	RXMAC_WOL_SA_HI_t sa_hi;
 	RXMAC_PF_CTRL_t pf_ctrl = { 0 };
@@ -427,7 +427,7 @@ void ConfigRxMacRegs(struct et131x_adapt
 
 void ConfigTxMacRegs(struct et131x_adapter *etdev)
 {
-	struct _TXMAC_t __iomem *pTxMac = &etdev->CSRAddress->txmac;
+	struct _TXMAC_t __iomem *pTxMac = &etdev->regs->txmac;
 	TXMAC_CF_PARAM_t Local;
 
 	DBG_ENTER(et131x_dbginfo);
@@ -450,7 +450,7 @@ void ConfigTxMacRegs(struct et131x_adapt
 void ConfigMacStatRegs(struct et131x_adapter *etdev)
 {
 	struct _MAC_STAT_t __iomem *pDevMacStat =
-		&etdev->CSRAddress->macStat;
+		&etdev->regs->macStat;
 
 	DBG_ENTER(et131x_dbginfo);
 
@@ -581,7 +581,7 @@ void UpdateMacStatHostCounters(struct et
 {
 	struct _ce_stats_t *stats = &etdev->Stats;
 	struct _MAC_STAT_t __iomem *pDevMacStat =
-		&etdev->CSRAddress->macStat;
+		&etdev->regs->macStat;
 
 	stats->collisions += readl(&pDevMacStat->TNcl);
 	stats->first_collision += readl(&pDevMacStat->TScl);
@@ -619,11 +619,11 @@ void HandleMacStatInterrupt(struct et131
 	/* Read the interrupt bits from the register(s).  These are Clear On
 	 * Write.
 	 */
-	Carry1.value = readl(&etdev->CSRAddress->macStat.Carry1.value);
-	Carry2.value = readl(&etdev->CSRAddress->macStat.Carry2.value);
+	Carry1.value = readl(&etdev->regs->macStat.Carry1.value);
+	Carry2.value = readl(&etdev->regs->macStat.Carry2.value);
 
-	writel(Carry1.value, &etdev->CSRAddress->macStat.Carry1.value);
-	writel(Carry2.value, &etdev->CSRAddress->macStat.Carry2.value);
+	writel(Carry1.value, &etdev->regs->macStat.Carry1.value);
+	writel(Carry2.value, &etdev->regs->macStat.Carry2.value);
 
 	/* We need to do update the host copy of all the MAC_STAT counters.
 	 * For each counter, check it's overflow bit.  If the overflow bit is
@@ -665,7 +665,7 @@ void HandleMacStatInterrupt(struct et131
 
 void SetupDeviceForMulticast(struct et131x_adapter *etdev)
 {
-	struct _RXMAC_t __iomem *rxmac = &etdev->CSRAddress->rxmac;
+	struct _RXMAC_t __iomem *rxmac = &etdev->regs->rxmac;
 	uint32_t nIndex;
 	uint32_t result;
 	uint32_t hash1 = 0;
@@ -718,7 +718,7 @@ void SetupDeviceForMulticast(struct et13
 	}
 
 	/* Write out the new hash to the device */
-	pm_csr.value = readl(&etdev->CSRAddress->global.pm_csr.value);
+	pm_csr.value = readl(&etdev->regs->global.pm_csr.value);
 	if (pm_csr.bits.pm_phy_sw_coma == 0) {
 		writel(hash1, &rxmac->multi_hash1);
 		writel(hash2, &rxmac->multi_hash2);
@@ -731,7 +731,7 @@ void SetupDeviceForMulticast(struct et13
 
 void SetupDeviceForUnicast(struct et131x_adapter *etdev)
 {
-	struct _RXMAC_t __iomem *rxmac = &etdev->CSRAddress->rxmac;
+	struct _RXMAC_t __iomem *rxmac = &etdev->regs->rxmac;
 	RXMAC_UNI_PF_ADDR1_t uni_pf1;
 	RXMAC_UNI_PF_ADDR2_t uni_pf2;
 	RXMAC_UNI_PF_ADDR3_t uni_pf3;
@@ -763,7 +763,7 @@ void SetupDeviceForUnicast(struct et131x
 	uni_pf1.bits.addr1_5 = etdev->CurrentAddress[4];
 	uni_pf1.bits.addr1_6 = etdev->CurrentAddress[5];
 
-	pm_csr.value = readl(&etdev->CSRAddress->global.pm_csr.value);
+	pm_csr.value = readl(&etdev->regs->global.pm_csr.value);
 	if (pm_csr.bits.pm_phy_sw_coma == 0) {
 		writel(uni_pf1.value, &rxmac->uni_pf_addr1.value);
 		writel(uni_pf2.value, &rxmac->uni_pf_addr2.value);
--- a/drivers/staging/et131x/et1310_phy.c
+++ b/drivers/staging/et131x/et1310_phy.c
@@ -118,7 +118,7 @@ static int et131x_xcvr_init(struct et131
 int PhyMiRead(struct et131x_adapter *adapter, uint8_t xcvrAddr,
 	      uint8_t xcvrReg, uint16_t *value)
 {
-	struct _MAC_t __iomem *mac = &adapter->CSRAddress->mac;
+	struct _MAC_t __iomem *mac = &adapter->regs->mac;
 	int status = 0;
 	uint32_t delay;
 	MII_MGMT_ADDR_t miiAddr;
@@ -202,7 +202,7 @@ int PhyMiRead(struct et131x_adapter *ada
  */
 int MiWrite(struct et131x_adapter *adapter, uint8_t xcvrReg, uint16_t value)
 {
-	struct _MAC_t __iomem *mac = &adapter->CSRAddress->mac;
+	struct _MAC_t __iomem *mac = &adapter->regs->mac;
 	int status = 0;
 	uint8_t xcvrAddr = adapter->Stats.xcvr_addr;
 	uint32_t delay;
--- a/drivers/staging/et131x/et1310_pm.c
+++ b/drivers/staging/et131x/et1310_pm.c
@@ -125,7 +125,7 @@ void EnablePhyComa(struct et131x_adapter
 
 	DBG_ENTER(et131x_dbginfo);
 
-	GlobalPmCSR.value = readl(&etdev->CSRAddress->global.pm_csr.value);
+	GlobalPmCSR.value = readl(&etdev->regs->global.pm_csr.value);
 
 	/* Save the GbE PHY speed and duplex modes. Need to restore this
 	 * when cable is plugged back in
@@ -144,11 +144,11 @@ void EnablePhyComa(struct et131x_adapter
 	GlobalPmCSR.bits.pm_sysclk_gate = 0;
 	GlobalPmCSR.bits.pm_txclk_gate = 0;
 	GlobalPmCSR.bits.pm_rxclk_gate = 0;
-	writel(GlobalPmCSR.value, &etdev->CSRAddress->global.pm_csr.value);
+	writel(GlobalPmCSR.value, &etdev->regs->global.pm_csr.value);
 
 	/* Program gigE PHY in to Coma mode */
 	GlobalPmCSR.bits.pm_phy_sw_coma = 1;
-	writel(GlobalPmCSR.value, &etdev->CSRAddress->global.pm_csr.value);
+	writel(GlobalPmCSR.value, &etdev->regs->global.pm_csr.value);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
@@ -163,14 +163,14 @@ void DisablePhyComa(struct et131x_adapte
 
 	DBG_ENTER(et131x_dbginfo);
 
-	GlobalPmCSR.value = readl(&etdev->CSRAddress->global.pm_csr.value);
+	GlobalPmCSR.value = readl(&etdev->regs->global.pm_csr.value);
 
 	/* Disable phy_sw_coma register and re-enable JAGCore clocks */
 	GlobalPmCSR.bits.pm_sysclk_gate = 1;
 	GlobalPmCSR.bits.pm_txclk_gate = 1;
 	GlobalPmCSR.bits.pm_rxclk_gate = 1;
 	GlobalPmCSR.bits.pm_phy_sw_coma = 0;
-	writel(GlobalPmCSR.value, &etdev->CSRAddress->global.pm_csr.value);
+	writel(GlobalPmCSR.value, &etdev->regs->global.pm_csr.value);
 
 	/* Restore the GbE PHY speed and duplex modes;
 	 * Reset JAGCore; re-configure and initialize JAGCore and gigE PHY
--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -680,7 +680,7 @@ void et131x_rfd_resources_free(struct et
  */
 void ConfigRxDmaRegs(struct et131x_adapter *etdev)
 {
-	struct _RXDMA_t __iomem *pRxDma = &etdev->CSRAddress->rxdma;
+	struct _RXDMA_t __iomem *pRxDma = &etdev->regs->rxdma;
 	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
 	PFBR_DESC_t pFbrEntry;
 	uint32_t iEntry;
@@ -817,8 +817,8 @@ void SetRxDmaTimer(struct et131x_adapter
 	 */
 	if ((etdev->uiLinkSpeed == TRUEPHY_SPEED_100MBPS) ||
 	    (etdev->uiLinkSpeed == TRUEPHY_SPEED_10MBPS)) {
-		writel(0, &etdev->CSRAddress->rxdma.max_pkt_time.value);
-		writel(1, &etdev->CSRAddress->rxdma.num_pkt_done.value);
+		writel(0, &etdev->regs->rxdma.max_pkt_time.value);
+		writel(1, &etdev->regs->rxdma.num_pkt_done.value);
 	}
 }
 
@@ -833,11 +833,11 @@ void et131x_rx_dma_disable(struct et131x
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Setup the receive dma configuration register */
-	writel(0x00002001, &etdev->CSRAddress->rxdma.csr.value);
-	csr.value = readl(&etdev->CSRAddress->rxdma.csr.value);
+	writel(0x00002001, &etdev->regs->rxdma.csr.value);
+	csr.value = readl(&etdev->regs->rxdma.csr.value);
 	if (csr.bits.halt_status != 1) {
 		udelay(5);
-		csr.value = readl(&etdev->CSRAddress->rxdma.csr.value);
+		csr.value = readl(&etdev->regs->rxdma.csr.value);
 		if (csr.bits.halt_status != 1)
 			DBG_ERROR(et131x_dbginfo,
 				"RX Dma failed to enter halt state. CSR 0x%08x\n",
@@ -857,7 +857,7 @@ void et131x_rx_dma_enable(struct et131x_
 
 	if (etdev->RegistryPhyLoopbk)
 		/* RxDMA is disabled for loopback operation. */
-		writel(0x1, &etdev->CSRAddress->rxdma.csr.value);
+		writel(0x1, &etdev->regs->rxdma.csr.value);
 	else {
 	/* Setup the receive dma configuration register for normal operation */
 		RXDMA_CSR_t csr = { 0 };
@@ -878,12 +878,12 @@ void et131x_rx_dma_enable(struct et131x_
 		else if (etdev->RxRing.Fbr0BufferSize == 1024)
 			csr.bits.fbr0_size = 3;
 #endif
-		writel(csr.value, &etdev->CSRAddress->rxdma.csr.value);
+		writel(csr.value, &etdev->regs->rxdma.csr.value);
 
-		csr.value = readl(&etdev->CSRAddress->rxdma.csr.value);
+		csr.value = readl(&etdev->regs->rxdma.csr.value);
 		if (csr.bits.halt_status != 0) {
 			udelay(5);
-			csr.value = readl(&etdev->CSRAddress->rxdma.csr.value);
+			csr.value = readl(&etdev->regs->rxdma.csr.value);
 			if (csr.bits.halt_status != 0) {
 				DBG_ERROR(et131x_dbginfo,
 					"RX Dma failed to exit halt state.  CSR 0x%08x\n",
@@ -978,7 +978,7 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
 	}
 
 	writel(pRxLocal->local_psr_full.value,
-	       &etdev->CSRAddress->rxdma.psr_full_offset.value);
+	       &etdev->regs->rxdma.psr_full_offset.value);
 
 #ifndef USE_FBR0
 	if (ringIndex != 1) {
@@ -1273,7 +1273,7 @@ void et131x_handle_recv_interrupt(struct
 	if ((PacketArrayCount == NUM_PACKETS_HANDLED) || TempUnfinishedRec) {
 		etdev->RxRing.UnfinishedReceives = true;
 		writel(etdev->RegistryTxTimeInterval * NANO_IN_A_MICRO,
-		       &etdev->CSRAddress->global.watchdog_timer);
+		       &etdev->regs->global.watchdog_timer);
 	} else {
 		/* Watchdog timer will disable itself if appropriate. */
 		etdev->RxRing.UnfinishedReceives = false;
@@ -1290,7 +1290,7 @@ void et131x_handle_recv_interrupt(struct
 void nic_return_rfd(struct et131x_adapter *etdev, PMP_RFD pMpRfd)
 {
 	struct _rx_ring_t *pRxLocal = &etdev->RxRing;
-	struct _RXDMA_t __iomem *pRxDma = &etdev->CSRAddress->rxdma;
+	struct _RXDMA_t __iomem *pRxDma = &etdev->regs->rxdma;
 	uint16_t bi = pMpRfd->iBufferIndex;
 	uint8_t ri = pMpRfd->iRingIndex;
 	unsigned long flags;
--- a/drivers/staging/et131x/et1310_tx.c
+++ b/drivers/staging/et131x/et1310_tx.c
@@ -249,7 +249,7 @@ void et131x_tx_dma_memory_free(struct et
  */
 void ConfigTxDmaRegs(struct et131x_adapter *etdev)
 {
-	struct _TXDMA_t __iomem *pTxDma = &etdev->CSRAddress->txdma;
+	struct _TXDMA_t __iomem *pTxDma = &etdev->regs->txdma;
 
 	DBG_ENTER(et131x_dbginfo);
 
@@ -289,7 +289,7 @@ void et131x_tx_dma_disable(struct et131x
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Setup the tramsmit dma configuration register */
-	writel(0x101, &etdev->CSRAddress->txdma.csr.value);
+	writel(0x101, &etdev->regs->txdma.csr.value);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
@@ -306,7 +306,7 @@ void et131x_tx_dma_enable(struct et131x_
 
 	if (etdev->RegistryPhyLoopbk) {
 		/* TxDMA is disabled for loopback operation. */
-		writel(0x101, &etdev->CSRAddress->txdma.csr.value);
+		writel(0x101, &etdev->regs->txdma.csr.value);
 	} else {
 		TXDMA_CSR_t csr = { 0 };
 
@@ -316,7 +316,7 @@ void et131x_tx_dma_enable(struct et131x_
 		csr.bits.sngl_epkt_mode = 1;
 		csr.bits.halt = 0;
 		csr.bits.cache_thrshld = etdev->RegistryDMACache;
-		writel(csr.value, &etdev->CSRAddress->txdma.csr.value);
+		writel(csr.value, &etdev->regs->txdma.csr.value);
 	}
 
 	DBG_LEAVE(et131x_dbginfo);
@@ -788,14 +788,14 @@ static int nic_send_packet(struct et131x
 
 	/* Write the new write pointer back to the device. */
 	writel(etdev->TxRing.txDmaReadyToSend.value,
-	       &etdev->CSRAddress->txdma.service_request.value);
+	       &etdev->regs->txdma.service_request.value);
 
 	/* For Gig only, we use Tx Interrupt coalescing.  Enable the software
 	 * timer to wake us up if this packet isn't followed by N more.
 	 */
 	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
 		writel(etdev->RegistryTxTimeInterval * NANO_IN_A_MICRO,
-		       &etdev->CSRAddress->global.watchdog_timer);
+		       &etdev->regs->global.watchdog_timer);
 	}
 
 	spin_unlock_irqrestore(&etdev->SendHWLock, flags);
@@ -837,7 +837,7 @@ static int nic_send_packet(struct et131x
 	DBG_TX_ENTER(et131x_dbginfo);
 
 	ServiceComplete.value =
-		readl(&etdev->CSRAddress->txdma.NewServiceComplete.value);
+		readl(&etdev->regs->txdma.NewServiceComplete.value);
 
 	/*
 	 * Attempt to fix TWO hardware bugs:
@@ -1202,7 +1202,7 @@ static int nic_send_packet(struct et131x
 
 	/* Write the new write pointer back to the device. */
 	writel(etdev->TxRing.txDmaReadyToSend.value,
-	       &etdev->CSRAddress->txdma.service_request.value);
+	       &etdev->regs->txdma.service_request.value);
 
 #ifdef CONFIG_ET131X_DEBUG
 	DumpDeviceBlock(DBG_TX_ON, etdev, 1);
@@ -1213,7 +1213,7 @@ static int nic_send_packet(struct et131x
 	 */
 	if (etdev->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS) {
 		writel(etdev->RegistryTxTimeInterval * NANO_IN_A_MICRO,
-		       &etdev->CSRAddress->global.watchdog_timer);
+		       &etdev->regs->global.watchdog_timer);
 	}
 
 	spin_unlock_irqrestore(&etdev->SendHWLock, flags);
@@ -1434,7 +1434,7 @@ static void et131x_update_tcb_list(struc
 	PMP_TCB pMpTcb;
 
 	ServiceComplete.value =
-	    readl(&etdev->CSRAddress->txdma.NewServiceComplete.value);
+	    readl(&etdev->regs->txdma.NewServiceComplete.value);
 
 	/* Has the ring wrapped?  Process any descriptors that do not have
 	 * the same "wrap" indicator as the current completion indicator
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -248,7 +248,7 @@ struct et131x_adapter {
 	TXMAC_TXTEST_t TxMacTest;
 
 	/* Pointer to the device's PCI register space */
-	ADDRESS_MAP_t __iomem *CSRAddress;
+	ADDRESS_MAP_t __iomem *regs;
 
 	/* Registry parameters */
 	u8 SpeedDuplex;		/* speed/duplex */
--- a/drivers/staging/et131x/et131x_debug.c
+++ b/drivers/staging/et131x/et131x_debug.c
@@ -110,7 +110,7 @@ extern dbg_info_t *et131x_dbginfo;
  */
 void DumpTxQueueContents(int dbgLvl, struct et131x_adapter *etdev)
 {
-	MMC_t __iomem *mmc = &etdev->CSRAddress->mmc;
+	MMC_t __iomem *mmc = &etdev->regs->mmc;
 	uint32_t TxQueueAddr;
 
 	if (DBG_FLAGS(et131x_dbginfo) & dbgLvl) {
@@ -134,7 +134,7 @@ void DumpTxQueueContents(int dbgLvl, str
 		}
 
 		DBG_PRINT("Shadow Pointers 0x%08x\n",
-			  readl(&etdev->CSRAddress->txmac.shadow_ptr.value));
+			  readl(&etdev->regs->txmac.shadow_ptr.value));
 	}
 }
 
@@ -151,7 +151,7 @@ void DumpDeviceBlock(int dbgLvl, struct 
 {
 	uint32_t Address1, Address2;
 	uint32_t __iomem *BigDevicePointer =
-		(uint32_t __iomem *) etdev->CSRAddress;
+		(uint32_t __iomem *) etdev->regs;
 	const char *BlockNames[NUM_BLOCKS] = {
 		"Global", "Tx DMA", "Rx DMA", "Tx MAC",
 		"Rx MAC", "MAC", "MAC Stat", "MMC"
@@ -189,7 +189,7 @@ void DumpDeviceReg(int dbgLvl, struct et
 	uint32_t Address1, Address2;
 	uint32_t Block;
 	uint32_t __iomem *BigDevicePointer =
-		(uint32_t __iomem *) etdev->CSRAddress;
+		(uint32_t __iomem *) etdev->regs;
 	uint32_t __iomem *Pointer;
 	const char *BlockNames[NUM_BLOCKS] = {
 		"Global", "Tx DMA", "Rx DMA", "Tx MAC",
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -440,7 +440,7 @@ void et131x_error_timer_handler(unsigned
 	struct et131x_adapter *etdev = (struct et131x_adapter *) data;
 	PM_CSR_t pm_csr;
 
-	pm_csr.value = readl(&etdev->CSRAddress->global.pm_csr.value);
+	pm_csr.value = readl(&etdev->regs->global.pm_csr.value);
 
 	if (pm_csr.bits.pm_phy_sw_coma == 0) {
 		if (etdev->RegistryMACStat)
@@ -615,12 +615,12 @@ void et131x_soft_reset(struct et131x_ada
 	DBG_ENTER(et131x_dbginfo);
 
 	/* Disable MAC Core */
-	writel(0xc00f0000, &adapter->CSRAddress->mac.cfg1.value);
+	writel(0xc00f0000, &adapter->regs->mac.cfg1.value);
 
 	/* Set everything to a reset value */
-	writel(0x7F, &adapter->CSRAddress->global.sw_reset.value);
-	writel(0x000f0000, &adapter->CSRAddress->mac.cfg1.value);
-	writel(0x00000000, &adapter->CSRAddress->mac.cfg1.value);
+	writel(0x7F, &adapter->regs->global.sw_reset.value);
+	writel(0x000f0000, &adapter->regs->mac.cfg1.value);
+	writel(0x00000000, &adapter->regs->mac.cfg1.value);
 
 	DBG_LEAVE(et131x_dbginfo);
 }
@@ -741,7 +741,7 @@ void __devexit et131x_pci_remove(struct 
 	/* Perform device cleanup */
 	unregister_netdev(netdev);
 	et131x_adapter_memory_free(adapter);
-	iounmap(adapter->CSRAddress);
+	iounmap(adapter->regs);
 	pci_dev_put(adapter->pdev);
 	free_netdev(netdev);
 	pci_release_regions(pdev);
@@ -915,9 +915,9 @@ int __devinit et131x_pci_setup(struct pc
 	DBG_TRACE(et131x_dbginfo,
 		  "Mapping bus-relative registers to virtual memory...\n");
 
-	adapter->CSRAddress = ioremap_nocache(pci_resource_start(pdev, 0),
+	adapter->regs = ioremap_nocache(pci_resource_start(pdev, 0),
 					      pci_resource_len(pdev, 0));
-	if (adapter->CSRAddress == NULL) {
+	if (adapter->regs == NULL) {
 		DBG_ERROR(et131x_dbginfo, "Cannot map device registers\n");
 		result = -ENOMEM;
 		goto err_free_dev;
@@ -933,7 +933,7 @@ int __devinit et131x_pci_setup(struct pc
 		GlobalPmCSR.bits.pm_txclk_gate = 1;
 		GlobalPmCSR.bits.pm_rxclk_gate = 1;
 		writel(GlobalPmCSR.value,
-		       &adapter->CSRAddress->global.pm_csr.value);
+		       &adapter->regs->global.pm_csr.value);
 	}
 
 	/* Issue a global reset to the et1310 */
@@ -1021,7 +1021,7 @@ out:
 err_mem_free:
 	et131x_adapter_memory_free(adapter);
 err_iounmap:
-	iounmap(adapter->CSRAddress);
+	iounmap(adapter->regs);
 err_free_dev:
 	pci_dev_put(pdev);
 	free_netdev(netdev);
--- a/drivers/staging/et131x/et131x_isr.c
+++ b/drivers/staging/et131x/et131x_isr.c
@@ -129,7 +129,7 @@ irqreturn_t et131x_isr(int irq, void *de
 	/* Get a copy of the value in the interrupt status register
 	 * so we can process the interrupting section
 	 */
-	status.value = readl(&adapter->CSRAddress->global.int_status.value);
+	status.value = readl(&adapter->regs->global.int_status.value);
 
 	if (adapter->FlowControl == TxOnly ||
 	    adapter->FlowControl == Both) {
@@ -168,7 +168,7 @@ irqreturn_t et131x_isr(int irq, void *de
 		if (adapter->RxRing.UnfinishedReceives)
 			status.bits.rxdma_xfr_done = 1;
 		else if (pMpTcb == NULL)
-			writel(0, &adapter->CSRAddress->global.watchdog_timer);
+			writel(0, &adapter->regs->global.watchdog_timer);
 
 		status.bits.watchdog_interrupt = 0;
 #ifdef CONFIG_ET131X_DEBUG
@@ -214,7 +214,7 @@ void et131x_isr_handler(struct work_stru
 	struct et131x_adapter *etdev =
 		container_of(work, struct et131x_adapter, task);
 	INTERRUPT_t GlobStatus = etdev->Stats.InterruptStatus;
-	ADDRESS_MAP_t __iomem *iomem = etdev->CSRAddress;
+	ADDRESS_MAP_t __iomem *iomem = etdev->regs;
 
 	/*
 	 * These first two are by far the most common.  Once handled, we clear
--- a/drivers/staging/et131x/et131x_netdev.c
+++ b/drivers/staging/et131x/et131x_netdev.c
@@ -393,8 +393,8 @@ int et131x_set_packet_filter(struct et13
 
 	DBG_ENTER(et131x_dbginfo);
 
-	ctrl.value = readl(&adapter->CSRAddress->rxmac.ctrl.value);
-	pf_ctrl.value = readl(&adapter->CSRAddress->rxmac.pf_ctrl.value);
+	ctrl.value = readl(&adapter->regs->rxmac.ctrl.value);
+	pf_ctrl.value = readl(&adapter->regs->rxmac.pf_ctrl.value);
 
 	/* Default to disabled packet filtering.  Enable it in the individual
 	 * case statements that require the device to filter something
@@ -450,8 +450,8 @@ int et131x_set_packet_filter(struct et13
 		 * in the control reg.
 		 */
 		writel(pf_ctrl.value,
-		       &adapter->CSRAddress->rxmac.pf_ctrl.value);
-		writel(ctrl.value, &adapter->CSRAddress->rxmac.ctrl.value);
+		       &adapter->regs->rxmac.pf_ctrl.value);
+		writel(ctrl.value, &adapter->regs->rxmac.ctrl.value);
 	}
 
 	DBG_LEAVE(et131x_dbginfo);
