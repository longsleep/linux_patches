From jrm8005@gmail.com  Mon Oct 20 15:52:36 2008
From: "J.R. Mauro" <jrm8005@gmail.com>
Date: Tue, 14 Oct 2008 18:00:15 -0400
Subject: Staging: Clean up sxg driver
To: Greg Kroah-Hartman <gregkh@suse.de>
Message-ID: <20081014220015.GA14877@localhost>
Content-Disposition: inline


Lindent the rest of the files in drivers/staging/sxg

Signed off by: J.R. Mauro <jrm8005@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/sxg/sxg_os.h     |   41 +--
 drivers/staging/sxg/sxghif.h     |  410 +++++++++++++++++++--------------------
 drivers/staging/sxg/sxghw.h      |  284 +++++++++++++--------------
 drivers/staging/sxg/sxgphycode.h |   12 -
 4 files changed, 368 insertions(+), 379 deletions(-)

--- a/drivers/staging/sxg/sxghif.h
+++ b/drivers/staging/sxg/sxghif.h
@@ -14,119 +14,119 @@
  *******************************************************************************/
 typedef struct _SXG_UCODE_REGS {
 	// Address 0 - 0x3F = Command codes 0-15 for TCB 0.  Excode 0
-	u32		Icr;			// Code = 0 (extended), ExCode = 0 - Int control
-	u32		RsvdReg1;		// Code = 1 - TOE -NA
-	u32		RsvdReg2;		// Code = 2 - TOE -NA
-	u32		RsvdReg3;		// Code = 3 - TOE -NA
-	u32		RsvdReg4;		// Code = 4 - TOE -NA
-	u32		RsvdReg5;		// Code = 5 - TOE -NA
-	u32		CardUp;			// Code = 6 - Microcode initialized when 1
-	u32		RsvdReg7;		// Code = 7 - TOE -NA
-	u32		CodeNotUsed[8];		// Codes 8-15 not used.  ExCode = 0
+	u32 Icr;		// Code = 0 (extended), ExCode = 0 - Int control
+	u32 RsvdReg1;		// Code = 1 - TOE -NA
+	u32 RsvdReg2;		// Code = 2 - TOE -NA
+	u32 RsvdReg3;		// Code = 3 - TOE -NA
+	u32 RsvdReg4;		// Code = 4 - TOE -NA
+	u32 RsvdReg5;		// Code = 5 - TOE -NA
+	u32 CardUp;		// Code = 6 - Microcode initialized when 1
+	u32 RsvdReg7;		// Code = 7 - TOE -NA
+	u32 CodeNotUsed[8];	// Codes 8-15 not used.  ExCode = 0
 	// This brings us to ExCode 1 at address 0x40 = Interrupt status pointer
-	u32		Isp;			// Code = 0 (extended), ExCode = 1
-	u32		PadEx1[15];		// Codes 1-15 not used with extended codes
+	u32 Isp;		// Code = 0 (extended), ExCode = 1
+	u32 PadEx1[15];		// Codes 1-15 not used with extended codes
 	// ExCode 2 = Interrupt Status Register
-	u32		Isr;			// Code = 0 (extended), ExCode = 2
-	u32		PadEx2[15];
+	u32 Isr;		// Code = 0 (extended), ExCode = 2
+	u32 PadEx2[15];
 	// ExCode 3 = Event base register.  Location of event rings
-	u32		EventBase;		// Code = 0 (extended), ExCode = 3
-	u32		PadEx3[15];
+	u32 EventBase;		// Code = 0 (extended), ExCode = 3
+	u32 PadEx3[15];
 	// ExCode 4 = Event ring size
-	u32		EventSize;		// Code = 0 (extended), ExCode = 4
-	u32		PadEx4[15];
+	u32 EventSize;		// Code = 0 (extended), ExCode = 4
+	u32 PadEx4[15];
 	// ExCode 5 = TCB Buffers base address
-	u32		TcbBase;		// Code = 0 (extended), ExCode = 5
-	u32		PadEx5[15];
+	u32 TcbBase;		// Code = 0 (extended), ExCode = 5
+	u32 PadEx5[15];
 	// ExCode 6 = TCB Composite Buffers base address
-	u32		TcbCompBase;		// Code = 0 (extended), ExCode = 6
-	u32		PadEx6[15];
+	u32 TcbCompBase;	// Code = 0 (extended), ExCode = 6
+	u32 PadEx6[15];
 	// ExCode 7 = Transmit ring base address
-	u32		XmtBase;		// Code = 0 (extended), ExCode = 7
-	u32		PadEx7[15];
+	u32 XmtBase;		// Code = 0 (extended), ExCode = 7
+	u32 PadEx7[15];
 	// ExCode 8 = Transmit ring size
-	u32		XmtSize;		// Code = 0 (extended), ExCode = 8
-	u32		PadEx8[15];
+	u32 XmtSize;		// Code = 0 (extended), ExCode = 8
+	u32 PadEx8[15];
 	// ExCode 9 = Receive ring base address
-	u32		RcvBase;		// Code = 0 (extended), ExCode = 9
-	u32		PadEx9[15];
+	u32 RcvBase;		// Code = 0 (extended), ExCode = 9
+	u32 PadEx9[15];
 	// ExCode 10 = Receive ring size
-	u32		RcvSize;		// Code = 0 (extended), ExCode = 10
-	u32		PadEx10[15];
+	u32 RcvSize;		// Code = 0 (extended), ExCode = 10
+	u32 PadEx10[15];
 	// ExCode 11 = Read EEPROM Config
-	u32		Config;			// Code = 0 (extended), ExCode = 11
-	u32		PadEx11[15];
+	u32 Config;		// Code = 0 (extended), ExCode = 11
+	u32 PadEx11[15];
 	// ExCode 12 = Multicast bits 31:0
-	u32		McastLow;		// Code = 0 (extended), ExCode = 12
-	u32		PadEx12[15];
+	u32 McastLow;		// Code = 0 (extended), ExCode = 12
+	u32 PadEx12[15];
 	// ExCode 13 = Multicast bits 63:32
-	u32		McastHigh;		// Code = 0 (extended), ExCode = 13
-	u32		PadEx13[15];
+	u32 McastHigh;		// Code = 0 (extended), ExCode = 13
+	u32 PadEx13[15];
 	// ExCode 14 = Ping
-	u32		Ping;			// Code = 0 (extended), ExCode = 14
-	u32		PadEx14[15];
+	u32 Ping;		// Code = 0 (extended), ExCode = 14
+	u32 PadEx14[15];
 	// ExCode 15 = Link MTU
-	u32		LinkMtu;		// Code = 0 (extended), ExCode = 15
-	u32		PadEx15[15];
+	u32 LinkMtu;		// Code = 0 (extended), ExCode = 15
+	u32 PadEx15[15];
 	// ExCode 16 = Download synchronization
-	u32		LoadSync;		// Code = 0 (extended), ExCode = 16
-	u32		PadEx16[15];
+	u32 LoadSync;		// Code = 0 (extended), ExCode = 16
+	u32 PadEx16[15];
 	// ExCode 17 = Upper DRAM address bits on 32-bit systems
-	u32		Upper;			// Code = 0 (extended), ExCode = 17
-	u32		PadEx17[15];
+	u32 Upper;		// Code = 0 (extended), ExCode = 17
+	u32 PadEx17[15];
 	// ExCode 18 = Slowpath Send Index Address
-	u32		SPSendIndex;		// Code = 0 (extended), ExCode = 18
-	u32		PadEx18[15];
-	u32		RsvdXF;			// Code = 0 (extended), ExCode = 19
-	u32		PadEx19[15];
+	u32 SPSendIndex;	// Code = 0 (extended), ExCode = 18
+	u32 PadEx18[15];
+	u32 RsvdXF;		// Code = 0 (extended), ExCode = 19
+	u32 PadEx19[15];
 	// ExCode 20 = Aggregation
-	u32		Aggregation;		// Code = 0 (extended), ExCode = 20
-	u32		PadEx20[15];
+	u32 Aggregation;	// Code = 0 (extended), ExCode = 20
+	u32 PadEx20[15];
 	// ExCode 21 = Receive MDL push timer
-	u32		PushTicks;		// Code = 0 (extended), ExCode = 21
-	u32		PadEx21[15];
+	u32 PushTicks;		// Code = 0 (extended), ExCode = 21
+	u32 PadEx21[15];
 	// ExCode 22 = TOE NA
-	u32		AckFrequency;		// Code = 0 (extended), ExCode = 22
-	u32		PadEx22[15];
+	u32 AckFrequency;	// Code = 0 (extended), ExCode = 22
+	u32 PadEx22[15];
 	// ExCode 23 = TOE NA
-	u32		RsvdReg23;
-	u32		PadEx23[15];
+	u32 RsvdReg23;
+	u32 PadEx23[15];
 	// ExCode 24 = TOE NA
-	u32		RsvdReg24;
-	u32		PadEx24[15];
+	u32 RsvdReg24;
+	u32 PadEx24[15];
 	// ExCode 25 = TOE NA
-	u32		RsvdReg25;		// Code = 0 (extended), ExCode = 25
-	u32		PadEx25[15];
+	u32 RsvdReg25;		// Code = 0 (extended), ExCode = 25
+	u32 PadEx25[15];
 	// ExCode 26 = Receive checksum requirements
-	u32		ReceiveChecksum;	// Code = 0 (extended), ExCode = 26
-	u32		PadEx26[15];
+	u32 ReceiveChecksum;	// Code = 0 (extended), ExCode = 26
+	u32 PadEx26[15];
 	// ExCode 27 = RSS Requirements
-	u32		Rss;			// Code = 0 (extended), ExCode = 27
-	u32		PadEx27[15];
+	u32 Rss;		// Code = 0 (extended), ExCode = 27
+	u32 PadEx27[15];
 	// ExCode 28 = RSS Table
-	u32		RssTable;		// Code = 0 (extended), ExCode = 28
-	u32		PadEx28[15];
+	u32 RssTable;		// Code = 0 (extended), ExCode = 28
+	u32 PadEx28[15];
 	// ExCode 29 = Event ring release entries
-	u32		EventRelease;		// Code = 0 (extended), ExCode = 29
-	u32		PadEx29[15];
+	u32 EventRelease;	// Code = 0 (extended), ExCode = 29
+	u32 PadEx29[15];
 	// ExCode 30 = Number of receive bufferlist commands on ring 0
-	u32		RcvCmd;			// Code = 0 (extended), ExCode = 30
-	u32		PadEx30[15];
+	u32 RcvCmd;		// Code = 0 (extended), ExCode = 30
+	u32 PadEx30[15];
 	// ExCode 31 = slowpath transmit command - Data[31:0] = 1
-	u32		XmtCmd;			// Code = 0 (extended), ExCode = 31
-	u32		PadEx31[15];
+	u32 XmtCmd;		// Code = 0 (extended), ExCode = 31
+	u32 PadEx31[15];
 	// ExCode 32 = Dump command
-	u32		DumpCmd;		// Code = 0 (extended), ExCode = 32
-	u32		PadEx32[15];
+	u32 DumpCmd;		// Code = 0 (extended), ExCode = 32
+	u32 PadEx32[15];
 	// ExCode 33 = Debug command
-	u32		DebugCmd;		// Code = 0 (extended), ExCode = 33
-	u32		PadEx33[15];
+	u32 DebugCmd;		// Code = 0 (extended), ExCode = 33
+	u32 PadEx33[15];
 	// There are 128 possible extended commands - each of account for 16
 	// words (including the non-relevent base command codes 1-15).
 	// Pad for the remainder of these here to bring us to the next CPU
 	// base.  As extended codes are added, reduce the first array value in
 	// the following field
-	u32		PadToNextCpu[94][16];	// 94 = 128 - 34 (34 = Excodes 0 - 33)
+	u32 PadToNextCpu[94][16];	// 94 = 128 - 34 (34 = Excodes 0 - 33)
 } SXG_UCODE_REGS, *PSXG_UCODE_REGS;
 
 // Interrupt control register (0) values
@@ -141,7 +141,7 @@ typedef struct _SXG_UCODE_REGS {
 
 // The Microcode supports up to 16 RSS queues
 #define SXG_MAX_RSS				16
-#define SXG_MAX_RSS_TABLE_SIZE	256		// 256-byte max
+#define SXG_MAX_RSS_TABLE_SIZE	256	// 256-byte max
 
 #define SXG_RSS_TCP6				0x00000001	// RSS TCP over IPv6
 #define SXG_RSS_TCP4				0x00000002	// RSS TCP over IPv4
@@ -170,16 +170,16 @@ typedef struct _SXG_UCODE_REGS {
  * SXG_UCODE_REGS definition above
  */
 typedef struct _SXG_TCB_REGS {
-	u32		ExCode;		/* Extended codes - see SXG_UCODE_REGS */
-	u32		Xmt;		/* Code = 1 - # of Xmt descriptors added to ring */
-	u32		Rcv;		/* Code = 2 - # of Rcv descriptors added to ring */
-	u32		Rsvd1;		/* Code = 3 - TOE NA */
-	u32		Rsvd2;		/* Code = 4 - TOE NA */
-	u32		Rsvd3;		/* Code = 5 - TOE NA */
-	u32		Invalid;	/* Code = 6 - Reserved for "CardUp" see above */
-	u32		Rsvd4;		/* Code = 7 - TOE NA */
-	u32		Rsvd5;		/* Code = 8 - TOE NA */
-	u32		Pad[7];		/* Codes 8-15 - Not used. */
+	u32 ExCode;		/* Extended codes - see SXG_UCODE_REGS */
+	u32 Xmt;		/* Code = 1 - # of Xmt descriptors added to ring */
+	u32 Rcv;		/* Code = 2 - # of Rcv descriptors added to ring */
+	u32 Rsvd1;		/* Code = 3 - TOE NA */
+	u32 Rsvd2;		/* Code = 4 - TOE NA */
+	u32 Rsvd3;		/* Code = 5 - TOE NA */
+	u32 Invalid;		/* Code = 6 - Reserved for "CardUp" see above */
+	u32 Rsvd4;		/* Code = 7 - TOE NA */
+	u32 Rsvd5;		/* Code = 8 - TOE NA */
+	u32 Pad[7];		/* Codes 8-15 - Not used. */
 } SXG_TCB_REGS, *PSXG_TCB_REGS;
 
 /***************************************************************************
@@ -273,27 +273,27 @@ typedef struct _SXG_TCB_REGS {
  */
 #pragma pack(push, 1)
 typedef struct _SXG_EVENT {
-	u32			Pad[1];		// not used
-	u32			SndUna;		// SndUna value
-	u32			Resid;		// receive MDL resid
+	u32 Pad[1];		// not used
+	u32 SndUna;		// SndUna value
+	u32 Resid;		// receive MDL resid
 	union {
-		void *		HostHandle;	// Receive host handle
-		u32		Rsvd1;		// TOE NA
+		void *HostHandle;	// Receive host handle
+		u32 Rsvd1;	// TOE NA
 		struct {
-			u32	NotUsed;
-			u32	Rsvd2;		// TOE NA
+			u32 NotUsed;
+			u32 Rsvd2;	// TOE NA
 		} Flush;
 	};
-	u32			Toeplitz;	// RSS Toeplitz hash
+	u32 Toeplitz;		// RSS Toeplitz hash
 	union {
-		ushort		Rsvd3;		// TOE NA
-		ushort		HdrOffset;	// Slowpath
+		ushort Rsvd3;	// TOE NA
+		ushort HdrOffset;	// Slowpath
 	};
-	ushort			Length;		//
-	unsigned char 		Rsvd4;		// TOE NA
-	unsigned char 		Code;		// Event code
-	unsigned char		CommandIndex;	// New ring index
-	unsigned char		Status;		// Event status
+	ushort Length;		//
+	unsigned char Rsvd4;	// TOE NA
+	unsigned char Code;	// Event code
+	unsigned char CommandIndex;	// New ring index
+	unsigned char Status;	// Event status
 } SXG_EVENT, *PSXG_EVENT;
 #pragma pack(pop)
 
@@ -318,12 +318,12 @@ typedef struct _SXG_EVENT {
 // Event ring
 // Size must be power of 2, between 128 and 16k
 #define EVENT_RING_SIZE		4096	// ??
-#define EVENT_RING_BATCH	16		// Hand entries back 16 at a time.
-#define EVENT_BATCH_LIMIT	256	    // Stop processing events after 256 (16 * 16)
+#define EVENT_RING_BATCH	16	// Hand entries back 16 at a time.
+#define EVENT_BATCH_LIMIT	256	// Stop processing events after 256 (16 * 16)
 
 typedef struct _SXG_EVENT_RING {
-	SXG_EVENT	Ring[EVENT_RING_SIZE];
-}SXG_EVENT_RING, *PSXG_EVENT_RING;
+	SXG_EVENT Ring[EVENT_RING_SIZE];
+} SXG_EVENT_RING, *PSXG_EVENT_RING;
 
 /***************************************************************************
  *
@@ -341,7 +341,7 @@ typedef struct _SXG_EVENT_RING {
 #define SXG_TCB_PER_BUCKET		16
 #define SXG_TCB_BUCKET_MASK		0xFF0	// Bucket portion of TCB ID
 #define SXG_TCB_ELEMENT_MASK	0x00F	// Element within bucket
-#define SXG_TCB_BUCKETS			256		// 256 * 16 = 4k
+#define SXG_TCB_BUCKETS			256	// 256 * 16 = 4k
 
 #define SXG_TCB_BUFFER_SIZE	512	// ASSERT format is correct
 
@@ -368,7 +368,6 @@ typedef struct _SXG_EVENT_RING {
 	&(_TcpObject)->CompBuffer->Frame.HasVlan.TcpIp6.Ip				:		\
 	&(_TcpObject)->CompBuffer->Frame.NoVlan.TcpIp6.Ip
 
-
 #if DBG
 // Horrible kludge to distinguish dumb-nic, slowpath, and
 // fastpath traffic.  Decrement the HopLimit by one
@@ -396,16 +395,16 @@ typedef struct _SXG_EVENT_RING {
  * Receive and transmit rings
  ***************************************************************************/
 #define SXG_MAX_RING_SIZE	256
-#define SXG_XMT_RING_SIZE	128		// Start with 128
-#define SXG_RCV_RING_SIZE	128		// Start with 128
+#define SXG_XMT_RING_SIZE	128	// Start with 128
+#define SXG_RCV_RING_SIZE	128	// Start with 128
 #define SXG_MAX_ENTRIES     4096
 
 // Structure and macros to manage a ring
 typedef struct _SXG_RING_INFO {
-	unsigned char			Head;		// Where we add entries - Note unsigned char:RING_SIZE
-	unsigned char			Tail;		// Where we pull off completed entries
-	ushort			Size;		// Ring size - Must be multiple of 2
-	void *			Context[SXG_MAX_RING_SIZE];	// Shadow ring
+	unsigned char Head;	// Where we add entries - Note unsigned char:RING_SIZE
+	unsigned char Tail;	// Where we pull off completed entries
+	ushort Size;		// Ring size - Must be multiple of 2
+	void *Context[SXG_MAX_RING_SIZE];	// Shadow ring
 } SXG_RING_INFO, *PSXG_RING_INFO;
 
 #define SXG_INITIALIZE_RING(_ring, _size) {							\
@@ -483,40 +482,40 @@ typedef struct _SXG_RING_INFO {
  */
 #pragma pack(push, 1)
 typedef struct _SXG_CMD {
-	dma_addr_t             			Sgl;			// Physical address of SGL
+	dma_addr_t Sgl;		// Physical address of SGL
 	union {
 		struct {
-			dma64_addr_t          	FirstSgeAddress;// Address of first SGE
-			u32					FirstSgeLength;	// Length of first SGE
+			dma64_addr_t FirstSgeAddress;	// Address of first SGE
+			u32 FirstSgeLength;	// Length of first SGE
 			union {
-				u32				Rsvd1;	        // TOE NA
-				u32				SgeOffset;		// Slowpath - 2nd SGE offset
-				u32				Resid;			// MDL completion - clobbers update
+				u32 Rsvd1;	// TOE NA
+				u32 SgeOffset;	// Slowpath - 2nd SGE offset
+				u32 Resid;	// MDL completion - clobbers update
 			};
 			union {
-				u32				TotalLength;	// Total transfer length
-				u32				Mss;			// LSO MSS
+				u32 TotalLength;	// Total transfer length
+				u32 Mss;	// LSO MSS
 			};
 		} Buffer;
 	};
 	union {
 		struct {
-			unsigned char					Flags:4;		// slowpath flags
-			unsigned char					IpHl:4;			// Ip header length (>>2)
-			unsigned char					MacLen;			// Mac header len
+			unsigned char Flags:4;	// slowpath flags
+			unsigned char IpHl:4;	// Ip header length (>>2)
+			unsigned char MacLen;	// Mac header len
 		} CsumFlags;
 		struct {
-			ushort					Flags:4;		// slowpath flags
-			ushort					TcpHdrOff:7;	// TCP
-			ushort					MacLen:5;		// Mac header len
+			ushort Flags:4;	// slowpath flags
+			ushort TcpHdrOff:7;	// TCP
+			ushort MacLen:5;	// Mac header len
 		} LsoFlags;
-		ushort						Flags;			// flags
+		ushort Flags;	// flags
 	};
 	union {
-		ushort						SgEntries;		// SG entry count including first sge
+		ushort SgEntries;	// SG entry count including first sge
 		struct {
-			unsigned char					Status;		    // Copied from event status
-			unsigned char					NotUsed;
+			unsigned char Status;	// Copied from event status
+			unsigned char NotUsed;
 		} Status;
 	};
 } SXG_CMD, *PSXG_CMD;
@@ -524,8 +523,8 @@ typedef struct _SXG_CMD {
 
 #pragma pack(push, 1)
 typedef struct _VLAN_HDR {
-	ushort	VlanTci;
-	ushort	VlanTpid;
+	ushort VlanTci;
+	ushort VlanTpid;
 } VLAN_HDR, *PVLAN_HDR;
 #pragma pack(pop)
 
@@ -561,16 +560,16 @@ typedef struct _VLAN_HDR {
  *
  */
 // Slowpath CMD flags
-#define SXG_SLOWCMD_CSUM_IP			0x01		// Checksum IP
-#define SXG_SLOWCMD_CSUM_TCP		0x02		// Checksum TCP
-#define SXG_SLOWCMD_LSO				0x04		// Large segment send
+#define SXG_SLOWCMD_CSUM_IP			0x01	// Checksum IP
+#define SXG_SLOWCMD_CSUM_TCP		0x02	// Checksum TCP
+#define SXG_SLOWCMD_LSO				0x04	// Large segment send
 
 typedef struct _SXG_XMT_RING {
-	SXG_CMD		Descriptors[SXG_XMT_RING_SIZE];
+	SXG_CMD Descriptors[SXG_XMT_RING_SIZE];
 } SXG_XMT_RING, *PSXG_XMT_RING;
 
 typedef struct _SXG_RCV_RING {
-	SXG_CMD		Descriptors[SXG_RCV_RING_SIZE];
+	SXG_CMD Descriptors[SXG_RCV_RING_SIZE];
 } SXG_RCV_RING, *PSXG_RCV_RING;
 
 /***************************************************************************
@@ -578,8 +577,8 @@ typedef struct _SXG_RCV_RING {
  * shared memory allocation
  ***************************************************************************/
 typedef enum {
-	SXG_BUFFER_TYPE_RCV,		// Receive buffer
-	SXG_BUFFER_TYPE_SGL			// SGL buffer
+	SXG_BUFFER_TYPE_RCV,	// Receive buffer
+	SXG_BUFFER_TYPE_SGL	// SGL buffer
 } SXG_BUFFER_TYPE;
 
 // State for SXG buffers
@@ -668,60 +667,60 @@ typedef enum {
 #define SXG_RCV_DATA_BUFFERS			4096	// Amount to give to the card
 #define SXG_INITIAL_RCV_DATA_BUFFERS	8192	// Initial pool of buffers
 #define SXG_MIN_RCV_DATA_BUFFERS		2048	// Minimum amount and when to get more
-#define SXG_MAX_RCV_BLOCKS				128		// = 16384 receive buffers
+#define SXG_MAX_RCV_BLOCKS				128	// = 16384 receive buffers
 
 // Receive buffer header
 typedef struct _SXG_RCV_DATA_BUFFER_HDR {
-	dma_addr_t          			PhysicalAddress;	// Buffer physical address
+	dma_addr_t PhysicalAddress;	// Buffer physical address
 	// Note - DO NOT USE the VirtualAddress field to locate data.
 	// Use the sxg.h:SXG_RECEIVE_DATA_LOCATION macro instead.
-	void *VirtualAddress;		// Start of buffer
-	LIST_ENTRY						FreeList;			// Free queue of buffers
-	struct _SXG_RCV_DATA_BUFFER_HDR	*Next;				// Fastpath data buffer queue
-	u32							Size;				// Buffer size
-	u32							ByteOffset;			// See SXG_RESTORE_MDL_OFFSET
-	unsigned char							State;				// See SXG_BUFFER state above
-	unsigned char							Status;				// Event status (to log PUSH)
-	struct sk_buff                * skb;				// Double mapped (nbl and pkt)
+	void *VirtualAddress;	// Start of buffer
+	LIST_ENTRY FreeList;	// Free queue of buffers
+	struct _SXG_RCV_DATA_BUFFER_HDR *Next;	// Fastpath data buffer queue
+	u32 Size;		// Buffer size
+	u32 ByteOffset;		// See SXG_RESTORE_MDL_OFFSET
+	unsigned char State;	// See SXG_BUFFER state above
+	unsigned char Status;	// Event status (to log PUSH)
+	struct sk_buff *skb;	// Double mapped (nbl and pkt)
 } SXG_RCV_DATA_BUFFER_HDR, *PSXG_RCV_DATA_BUFFER_HDR;
 
 // SxgSlowReceive uses the PACKET (skb) contained
 // in the SXG_RCV_DATA_BUFFER_HDR when indicating dumb-nic data
 #define SxgDumbRcvPacket	        skb
 
-#define SXG_RCV_DATA_HDR_SIZE			256		// Space for SXG_RCV_DATA_BUFFER_HDR
+#define SXG_RCV_DATA_HDR_SIZE			256	// Space for SXG_RCV_DATA_BUFFER_HDR
 #define SXG_RCV_DATA_BUFFER_SIZE		2048	// Non jumbo = 2k including HDR
 #define SXG_RCV_JUMBO_BUFFER_SIZE		10240	// jumbo = 10k including HDR
 
 // Receive data descriptor
 typedef struct _SXG_RCV_DATA_DESCRIPTOR {
 	union {
-		struct sk_buff    *	VirtualAddress;			// Host handle
-		u64 			ForceTo8Bytes;			// Force x86 to 8-byte boundary
+		struct sk_buff *VirtualAddress;	// Host handle
+		u64 ForceTo8Bytes;	// Force x86 to 8-byte boundary
 	};
-	dma_addr_t             	PhysicalAddress;
+	dma_addr_t PhysicalAddress;
 } SXG_RCV_DATA_DESCRIPTOR, *PSXG_RCV_DATA_DESCRIPTOR;
 
 // Receive descriptor block
 #define SXG_RCV_DESCRIPTORS_PER_BLOCK		128
 #define SXG_RCV_DESCRIPTOR_BLOCK_SIZE		2048	// For sanity check
 typedef struct _SXG_RCV_DESCRIPTOR_BLOCK {
-	SXG_RCV_DATA_DESCRIPTOR		Descriptors[SXG_RCV_DESCRIPTORS_PER_BLOCK];
+	SXG_RCV_DATA_DESCRIPTOR Descriptors[SXG_RCV_DESCRIPTORS_PER_BLOCK];
 } SXG_RCV_DESCRIPTOR_BLOCK, *PSXG_RCV_DESCRIPTOR_BLOCK;
 
 // Receive descriptor block header
 typedef struct _SXG_RCV_DESCRIPTOR_BLOCK_HDR {
-	void *					VirtualAddress;			// Start of 2k buffer
-	dma_addr_t	            PhysicalAddress;		// ..and it's physical address
-	LIST_ENTRY				FreeList;				// Free queue of descriptor blocks
-	unsigned char					State;					// See SXG_BUFFER state above
+	void *VirtualAddress;	// Start of 2k buffer
+	dma_addr_t PhysicalAddress;	// ..and it's physical address
+	LIST_ENTRY FreeList;	// Free queue of descriptor blocks
+	unsigned char State;	// See SXG_BUFFER state above
 } SXG_RCV_DESCRIPTOR_BLOCK_HDR, *PSXG_RCV_DESCRIPTOR_BLOCK_HDR;
 
 // Receive block header
 typedef struct _SXG_RCV_BLOCK_HDR {
-	void *					VirtualAddress;			// Start of virtual memory
-	dma_addr_t	            PhysicalAddress;		// ..and it's physical address
-	LIST_ENTRY				AllList;				// Queue of all SXG_RCV_BLOCKS
+	void *VirtualAddress;	// Start of virtual memory
+	dma_addr_t PhysicalAddress;	// ..and it's physical address
+	LIST_ENTRY AllList;	// Queue of all SXG_RCV_BLOCKS
 } SXG_RCV_BLOCK_HDR, *PSXG_RCV_BLOCK_HDR;
 
 // Macros to determine data structure offsets into receive block
@@ -747,8 +746,8 @@ typedef struct _SXG_RCV_BLOCK_HDR {
 // Use the miniport reserved portion of the NBL to locate
 // our SXG_RCV_DATA_BUFFER_HDR structure.
 typedef struct _SXG_RCV_NBL_RESERVED {
-	PSXG_RCV_DATA_BUFFER_HDR	RcvDataBufferHdr;
-	void *						Available;
+	PSXG_RCV_DATA_BUFFER_HDR RcvDataBufferHdr;
+	void *Available;
 } SXG_RCV_NBL_RESERVED, *PSXG_RCV_NBL_RESERVED;
 
 #define SXG_RCV_NBL_BUFFER_HDR(_NBL) (((PSXG_RCV_NBL_RESERVED)NET_BUFFER_LIST_MINIPORT_RESERVED(_NBL))->RcvDataBufferHdr)
@@ -760,12 +759,11 @@ typedef struct _SXG_RCV_NBL_RESERVED {
 #define SXG_MIN_SGL_BUFFERS			2048	// Minimum amount and when to get more
 #define SXG_MAX_SGL_BUFFERS			16384	// Maximum to allocate (note ADAPT:ushort)
 
-
 // Self identifying structure type
 typedef enum _SXG_SGL_TYPE {
-	SXG_SGL_DUMB,				// Dumb NIC SGL
-	SXG_SGL_SLOW,				// Slowpath protocol header - see below
-	SXG_SGL_CHIMNEY				// Chimney offload SGL
+	SXG_SGL_DUMB,		// Dumb NIC SGL
+	SXG_SGL_SLOW,		// Slowpath protocol header - see below
+	SXG_SGL_CHIMNEY		// Chimney offload SGL
 } SXG_SGL_TYPE, PSXG_SGL_TYPE;
 
 // Note - the description below is Microsoft specific
@@ -774,14 +772,14 @@ typedef enum _SXG_SGL_TYPE {
 // for the SCATTER_GATHER_LIST portion of the SXG_SCATTER_GATHER data structure.
 // The following considerations apply when setting this value:
 // - First, the Sahara card is designed to read the Microsoft SGL structure
-// 	 straight out of host memory.  This means that the SGL must reside in
-//	 shared memory.  If the length here is smaller than the SGL for the
-//	 NET_BUFFER, then NDIS will allocate its own buffer.  The buffer
-//	 that NDIS allocates is not in shared memory, so when this happens,
-//	 the SGL will need to be copied to a set of SXG_SCATTER_GATHER buffers.
-//	 In other words.. we don't want this value to be too small.
+//       straight out of host memory.  This means that the SGL must reside in
+//       shared memory.  If the length here is smaller than the SGL for the
+//       NET_BUFFER, then NDIS will allocate its own buffer.  The buffer
+//       that NDIS allocates is not in shared memory, so when this happens,
+//       the SGL will need to be copied to a set of SXG_SCATTER_GATHER buffers.
+//       In other words.. we don't want this value to be too small.
 // - On the other hand.. we're allocating up to 16k of these things.  If
-//	 we make this too big, we start to consume a ton of memory..
+//       we make this too big, we start to consume a ton of memory..
 // At the moment, I'm going to limit the number of SG entries to 150.
 // If each entry maps roughly 4k, then this should cover roughly 600kB
 // NET_BUFFERs.  Furthermore, since each entry is 24 bytes, the total
@@ -801,24 +799,23 @@ typedef enum _SXG_SGL_TYPE {
 // the SGL.  The following structure defines an x64
 // formatted SGL entry
 typedef struct _SXG_X64_SGE {
-    dma64_addr_t      	Address;	// same as wdm.h
-    u32				Length;		// same as wdm.h
-	u32				CompilerPad;// The compiler pads to 8-bytes
-    u64 			Reserved;	// u32 * in wdm.h.  Force to 8 bytes
+	dma64_addr_t Address;	// same as wdm.h
+	u32 Length;		// same as wdm.h
+	u32 CompilerPad;	// The compiler pads to 8-bytes
+	u64 Reserved;		// u32 * in wdm.h.  Force to 8 bytes
 } SXG_X64_SGE, *PSXG_X64_SGE;
 
 typedef struct _SCATTER_GATHER_ELEMENT {
-    dma64_addr_t      	Address;	// same as wdm.h
-    u32				Length;		// same as wdm.h
-	u32				CompilerPad;// The compiler pads to 8-bytes
-    u64 			Reserved;	// u32 * in wdm.h.  Force to 8 bytes
+	dma64_addr_t Address;	// same as wdm.h
+	u32 Length;		// same as wdm.h
+	u32 CompilerPad;	// The compiler pads to 8-bytes
+	u64 Reserved;		// u32 * in wdm.h.  Force to 8 bytes
 } SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;
 
-
 typedef struct _SCATTER_GATHER_LIST {
-    u32					NumberOfElements;
-    u32 *				Reserved;
-    SCATTER_GATHER_ELEMENT	Elements[];
+	u32 NumberOfElements;
+	u32 *Reserved;
+	SCATTER_GATHER_ELEMENT Elements[];
 } SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
 
 // The card doesn't care about anything except elements, so
@@ -826,26 +823,26 @@ typedef struct _SCATTER_GATHER_LIST {
 // SGL structure.  But redefine from wdm.h:SCATTER_GATHER_LIST so
 // we can specify SXG_X64_SGE and define a fixed number of elements
 typedef struct _SXG_X64_SGL {
-    u32					NumberOfElements;
-    u32 *				Reserved;
-    SXG_X64_SGE				Elements[SXG_SGL_ENTRIES];
+	u32 NumberOfElements;
+	u32 *Reserved;
+	SXG_X64_SGE Elements[SXG_SGL_ENTRIES];
 } SXG_X64_SGL, *PSXG_X64_SGL;
 
 typedef struct _SXG_SCATTER_GATHER {
-	SXG_SGL_TYPE						Type;			// FIRST! Dumb-nic or offload
-	void *   							adapter;		// Back pointer to adapter
-	LIST_ENTRY							FreeList;		// Free SXG_SCATTER_GATHER blocks
-	LIST_ENTRY							AllList;		// All SXG_SCATTER_GATHER blocks
-	dma_addr_t				            PhysicalAddress;// physical address
-	unsigned char								State;			// See SXG_BUFFER state above
-	unsigned char								CmdIndex;		// Command ring index
-	struct sk_buff                    *	DumbPacket;		// Associated Packet
-	u32								Direction;		// For asynchronous completions
-	u32								CurOffset;		// Current SGL offset
-	u32								SglRef;			// SGL reference count
-	VLAN_HDR							VlanTag;		// VLAN tag to be inserted into SGL
-	PSCATTER_GATHER_LIST   				pSgl;			// SGL Addr. Possibly &Sgl
-	SXG_X64_SGL							Sgl;			// SGL handed to card
+	SXG_SGL_TYPE Type;	// FIRST! Dumb-nic or offload
+	void *adapter;		// Back pointer to adapter
+	LIST_ENTRY FreeList;	// Free SXG_SCATTER_GATHER blocks
+	LIST_ENTRY AllList;	// All SXG_SCATTER_GATHER blocks
+	dma_addr_t PhysicalAddress;	// physical address
+	unsigned char State;	// See SXG_BUFFER state above
+	unsigned char CmdIndex;	// Command ring index
+	struct sk_buff *DumbPacket;	// Associated Packet
+	u32 Direction;		// For asynchronous completions
+	u32 CurOffset;		// Current SGL offset
+	u32 SglRef;		// SGL reference count
+	VLAN_HDR VlanTag;	// VLAN tag to be inserted into SGL
+	PSCATTER_GATHER_LIST pSgl;	// SGL Addr. Possibly &Sgl
+	SXG_X64_SGL Sgl;	// SGL handed to card
 } SXG_SCATTER_GATHER, *PSXG_SCATTER_GATHER;
 
 #if defined(CONFIG_X86_64)
@@ -856,6 +853,5 @@ typedef struct _SXG_SCATTER_GATHER {
 #define SXG_SGL_BUFFER(_SxgSgl)		NULL
 #define SXG_SGL_BUF_SIZE			0
 #else
-    Stop Compilation;
+Stop Compilation;
 #endif
-
--- a/drivers/staging/sxg/sxghw.h
+++ b/drivers/staging/sxg/sxghw.h
@@ -141,7 +141,7 @@ typedef struct _SXG_HW_REGS {
 #define SXG_REGISTER_SIZE_PER_CPU	0x00002000	// Used to sanity check UCODE_REGS structure
 
 // Sahara receive sequencer status values
-#define SXG_RCV_STATUS_ATTN					0x80000000	// Attention
+#define SXG_RCV_STATUS_ATTN			0x80000000	// Attention
 #define SXG_RCV_STATUS_TRANSPORT_MASK		0x3F000000	// Transport mask
 #define SXG_RCV_STATUS_TRANSPORT_ERROR		0x20000000	// Transport error
 #define SXG_RCV_STATUS_TRANSPORT_CSUM		0x23000000	// Transport cksum error
@@ -156,9 +156,9 @@ typedef struct _SXG_HW_REGS {
 #define SXG_RCV_STATUS_TRANSPORT_FTP		0x03000000	// Transport FTP
 #define SXG_RCV_STATUS_TRANSPORT_HTTP		0x02000000	// Transport HTTP
 #define SXG_RCV_STATUS_TRANSPORT_SMB		0x01000000	// Transport SMB
-#define SXG_RCV_STATUS_NETWORK_MASK			0x00FF0000	// Network mask
+#define SXG_RCV_STATUS_NETWORK_MASK		0x00FF0000	// Network mask
 #define SXG_RCV_STATUS_NETWORK_ERROR		0x00800000	// Network error
-#define SXG_RCV_STATUS_NETWORK_CSUM			0x00830000	// Network cksum error
+#define SXG_RCV_STATUS_NETWORK_CSUM		0x00830000	// Network cksum error
 #define SXG_RCV_STATUS_NETWORK_UFLOW		0x00820000	// Network underflow error
 #define SXG_RCV_STATUS_NETWORK_HDRLEN		0x00800000	// Network header length
 #define SXG_RCV_STATUS_NETWORK_OFLOW		0x00400000	// Network overflow detected
@@ -167,67 +167,67 @@ typedef struct _SXG_HW_REGS {
 #define SXG_RCV_STATUS_NETWORK_OFFSET		0x00080000	// Network offset detected
 #define SXG_RCV_STATUS_NETWORK_FRAGMENT		0x00040000	// Network fragment detected
 #define SXG_RCV_STATUS_NETWORK_TRANS_MASK	0x00030000	// Network transport type mask
-#define SXG_RCV_STATUS_NETWORK_UDP			0x00020000	// UDP
-#define SXG_RCV_STATUS_NETWORK_TCP			0x00010000	// TCP
-#define SXG_RCV_STATUS_IPONLY				0x00008000	// IP-only not TCP
-#define SXG_RCV_STATUS_PKT_PRI				0x00006000	// Receive priority
-#define SXG_RCV_STATUS_PKT_PRI_SHFT					13	// Receive priority shift
-#define SXG_RCV_STATUS_PARITY				0x00001000	// MAC Receive RAM parity error
-#define SXG_RCV_STATUS_ADDRESS_MASK			0x00000F00	// Link address detection mask
-#define SXG_RCV_STATUS_ADDRESS_D			0x00000B00	// Link address D
-#define SXG_RCV_STATUS_ADDRESS_C			0x00000A00	// Link address C
-#define SXG_RCV_STATUS_ADDRESS_B			0x00000900	// Link address B
-#define SXG_RCV_STATUS_ADDRESS_A			0x00000800	// Link address A
+#define SXG_RCV_STATUS_NETWORK_UDP		0x00020000	// UDP
+#define SXG_RCV_STATUS_NETWORK_TCP		0x00010000	// TCP
+#define SXG_RCV_STATUS_IPONLY			0x00008000	// IP-only not TCP
+#define SXG_RCV_STATUS_PKT_PRI			0x00006000	// Receive priority
+#define SXG_RCV_STATUS_PKT_PRI_SHFT			13	// Receive priority shift
+#define SXG_RCV_STATUS_PARITY			0x00001000	// MAC Receive RAM parity error
+#define SXG_RCV_STATUS_ADDRESS_MASK		0x00000F00	// Link address detection mask
+#define SXG_RCV_STATUS_ADDRESS_D		0x00000B00	// Link address D
+#define SXG_RCV_STATUS_ADDRESS_C		0x00000A00	// Link address C
+#define SXG_RCV_STATUS_ADDRESS_B		0x00000900	// Link address B
+#define SXG_RCV_STATUS_ADDRESS_A		0x00000800	// Link address A
 #define SXG_RCV_STATUS_ADDRESS_BCAST		0x00000300	// Link address broadcast
 #define SXG_RCV_STATUS_ADDRESS_MCAST		0x00000200	// Link address multicast
 #define SXG_RCV_STATUS_ADDRESS_CMCAST		0x00000100	// Link control multicast
-#define SXG_RCV_STATUS_LINK_MASK			0x000000FF	// Link status mask
-#define SXG_RCV_STATUS_LINK_ERROR			0x00000080	// Link error
-#define SXG_RCV_STATUS_LINK_MASK			0x000000FF	// Link status mask
-#define SXG_RCV_STATUS_LINK_PARITY			0x00000087	// RcvMacQ parity error
-#define SXG_RCV_STATUS_LINK_EARLY			0x00000086	// Data early
+#define SXG_RCV_STATUS_LINK_MASK		0x000000FF	// Link status mask
+#define SXG_RCV_STATUS_LINK_ERROR		0x00000080	// Link error
+#define SXG_RCV_STATUS_LINK_MASK		0x000000FF	// Link status mask
+#define SXG_RCV_STATUS_LINK_PARITY		0x00000087	// RcvMacQ parity error
+#define SXG_RCV_STATUS_LINK_EARLY		0x00000086	// Data early
 #define SXG_RCV_STATUS_LINK_BUFOFLOW		0x00000085	// Buffer overflow
-#define SXG_RCV_STATUS_LINK_CODE			0x00000084	// Link code error
-#define SXG_RCV_STATUS_LINK_DRIBBLE			0x00000083	// Dribble nibble
-#define SXG_RCV_STATUS_LINK_CRC				0x00000082	// CRC error
-#define SXG_RCV_STATUS_LINK_OFLOW			0x00000081	// Link overflow
-#define SXG_RCV_STATUS_LINK_UFLOW			0x00000080	// Link underflow
-#define SXG_RCV_STATUS_LINK_8023			0x00000020	// 802.3
-#define SXG_RCV_STATUS_LINK_SNAP			0x00000010	// Snap
-#define SXG_RCV_STATUS_LINK_VLAN			0x00000008	// VLAN
+#define SXG_RCV_STATUS_LINK_CODE		0x00000084	// Link code error
+#define SXG_RCV_STATUS_LINK_DRIBBLE		0x00000083	// Dribble nibble
+#define SXG_RCV_STATUS_LINK_CRC			0x00000082	// CRC error
+#define SXG_RCV_STATUS_LINK_OFLOW		0x00000081	// Link overflow
+#define SXG_RCV_STATUS_LINK_UFLOW		0x00000080	// Link underflow
+#define SXG_RCV_STATUS_LINK_8023		0x00000020	// 802.3
+#define SXG_RCV_STATUS_LINK_SNAP		0x00000010	// Snap
+#define SXG_RCV_STATUS_LINK_VLAN		0x00000008	// VLAN
 #define SXG_RCV_STATUS_LINK_TYPE_MASK		0x00000007	// Network type mask
-#define SXG_RCV_STATUS_LINK_CONTROL			0x00000003	// Control packet
-#define SXG_RCV_STATUS_LINK_IPV6			0x00000002	// IPv6 packet
-#define SXG_RCV_STATUS_LINK_IPV4			0x00000001	// IPv4 packet
+#define SXG_RCV_STATUS_LINK_CONTROL		0x00000003	// Control packet
+#define SXG_RCV_STATUS_LINK_IPV6		0x00000002	// IPv6 packet
+#define SXG_RCV_STATUS_LINK_IPV4		0x00000001	// IPv4 packet
 
 /***************************************************************************
  * Sahara receive and transmit configuration registers
  ***************************************************************************/
-#define	RCV_CONFIG_RESET			0x80000000	// RcvConfig register reset
-#define	RCV_CONFIG_ENABLE			0x40000000	// Enable the receive logic
-#define	RCV_CONFIG_ENPARSE			0x20000000	// Enable the receive parser
-#define	RCV_CONFIG_SOCKET			0x10000000	// Enable the socket detector
-#define	RCV_CONFIG_RCVBAD			0x08000000	// Receive all bad frames
-#define	RCV_CONFIG_CONTROL			0x04000000	// Receive all control frames
-#define	RCV_CONFIG_RCVPAUSE			0x02000000	// Enable pause transmit when attn
-#define	RCV_CONFIG_TZIPV6			0x01000000	// Include TCP port w/ IPv6 toeplitz
-#define	RCV_CONFIG_TZIPV4			0x00800000	// Include TCP port w/ IPv4 toeplitz
-#define	RCV_CONFIG_FLUSH			0x00400000	// Flush buffers
+#define	RCV_CONFIG_RESET		0x80000000	// RcvConfig register reset
+#define	RCV_CONFIG_ENABLE		0x40000000	// Enable the receive logic
+#define	RCV_CONFIG_ENPARSE		0x20000000	// Enable the receive parser
+#define	RCV_CONFIG_SOCKET		0x10000000	// Enable the socket detector
+#define	RCV_CONFIG_RCVBAD		0x08000000	// Receive all bad frames
+#define	RCV_CONFIG_CONTROL		0x04000000	// Receive all control frames
+#define	RCV_CONFIG_RCVPAUSE		0x02000000	// Enable pause transmit when attn
+#define	RCV_CONFIG_TZIPV6		0x01000000	// Include TCP port w/ IPv6 toeplitz
+#define	RCV_CONFIG_TZIPV4		0x00800000	// Include TCP port w/ IPv4 toeplitz
+#define	RCV_CONFIG_FLUSH		0x00400000	// Flush buffers
 #define	RCV_CONFIG_PRIORITY_MASK	0x00300000	// Priority level
 #define	RCV_CONFIG_HASH_MASK		0x00030000	// Hash depth
-#define	RCV_CONFIG_HASH_8			0x00000000	// Hash depth 8
-#define	RCV_CONFIG_HASH_16			0x00010000	// Hash depth 16
-#define	RCV_CONFIG_HASH_4			0x00020000	// Hash depth 4
-#define	RCV_CONFIG_HASH_2			0x00030000	// Hash depth 2
+#define	RCV_CONFIG_HASH_8		0x00000000	// Hash depth 8
+#define	RCV_CONFIG_HASH_16		0x00010000	// Hash depth 16
+#define	RCV_CONFIG_HASH_4		0x00020000	// Hash depth 4
+#define	RCV_CONFIG_HASH_2		0x00030000	// Hash depth 2
 #define	RCV_CONFIG_BUFLEN_MASK		0x0000FFF0	// Buffer length bits 15:4. ie multiple of 16.
-#define RCV_CONFIG_SKT_DIS			0x00000008	// Disable socket detection on attn
+#define RCV_CONFIG_SKT_DIS		0x00000008	// Disable socket detection on attn
 // Macro to determine RCV_CONFIG_BUFLEN based on maximum frame size.
 // We add 18 bytes for Sahara receive status and padding, plus 4 bytes for CRC,
 // and round up to nearest 16 byte boundary
 #define RCV_CONFIG_BUFSIZE(_MaxFrame) ((((_MaxFrame) + 22) + 15) & RCV_CONFIG_BUFLEN_MASK)
 
-#define	XMT_CONFIG_RESET			0x80000000	// XmtConfig register reset
-#define	XMT_CONFIG_ENABLE			0x40000000	// Enable transmit logic
+#define	XMT_CONFIG_RESET		0x80000000	// XmtConfig register reset
+#define	XMT_CONFIG_ENABLE		0x40000000	// Enable transmit logic
 #define	XMT_CONFIG_MAC_PARITY		0x20000000	// Inhibit MAC RAM parity error
 #define	XMT_CONFIG_BUF_PARITY		0x10000000	// Inhibit D2F buffer parity error
 #define	XMT_CONFIG_MEM_PARITY		0x08000000	// Inhibit 1T SRAM parity error
@@ -249,9 +249,9 @@ typedef struct _SXG_HW_REGS {
 
 // A-XGMAC Configuration Register 1
 #define AXGMAC_CFG1_XMT_PAUSE		0x80000000		// Allow the sending of Pause frames
-#define AXGMAC_CFG1_XMT_EN			0x40000000		// Enable transmit
+#define AXGMAC_CFG1_XMT_EN		0x40000000		// Enable transmit
 #define AXGMAC_CFG1_RCV_PAUSE		0x20000000		// Allow the detection of Pause frames
-#define AXGMAC_CFG1_RCV_EN			0x10000000		// Enable receive
+#define AXGMAC_CFG1_RCV_EN		0x10000000		// Enable receive
 #define AXGMAC_CFG1_XMT_STATE		0x04000000		// Current transmit state - READ ONLY
 #define AXGMAC_CFG1_RCV_STATE		0x01000000		// Current receive state - READ ONLY
 #define AXGMAC_CFG1_XOFF_SHORT		0x00001000		// Only pause for 64 slot on XOFF
@@ -262,24 +262,24 @@ typedef struct _SXG_HW_REGS {
 #define AXGMAC_CFG1_RCV_FCS2		0x00000200		// Delay receive FCS 2 4-byte words
 #define AXGMAC_CFG1_RCV_FCS3		0x00000300		// Delay receive FCS 3 4-byte words
 #define AXGMAC_CFG1_PKT_OVERRIDE	0x00000080		// Per-packet override enable
-#define AXGMAC_CFG1_SWAP			0x00000040		// Byte swap enable
+#define AXGMAC_CFG1_SWAP		0x00000040		// Byte swap enable
 #define AXGMAC_CFG1_SHORT_ASSERT	0x00000020		// ASSERT srdrpfrm on short frame (<64)
 #define AXGMAC_CFG1_RCV_STRICT		0x00000010		// RCV only 802.3AE when CLEAR
 #define AXGMAC_CFG1_CHECK_LEN		0x00000008		// Verify frame length
-#define AXGMAC_CFG1_GEN_FCS			0x00000004		// Generate FCS
+#define AXGMAC_CFG1_GEN_FCS		0x00000004		// Generate FCS
 #define AXGMAC_CFG1_PAD_MASK		0x00000003		// Mask for pad bits
-#define AXGMAC_CFG1_PAD_64			0x00000001		// Pad frames to 64 bytes
+#define AXGMAC_CFG1_PAD_64		0x00000001		// Pad frames to 64 bytes
 #define AXGMAC_CFG1_PAD_VLAN		0x00000002		// Detect VLAN and pad to 68 bytes
-#define AXGMAC_CFG1_PAD_68			0x00000003		// Pad to 68 bytes
+#define AXGMAC_CFG1_PAD_68		0x00000003		// Pad to 68 bytes
 
 // A-XGMAC Configuration Register 2
 #define AXGMAC_CFG2_GEN_PAUSE		0x80000000		// Generate single pause frame (test)
 #define AXGMAC_CFG2_LF_MANUAL		0x08000000		// Manual link fault sequence
-#define AXGMAC_CFG2_LF_AUTO			0x04000000		// Auto link fault sequence
+#define AXGMAC_CFG2_LF_AUTO		0x04000000		// Auto link fault sequence
 #define AXGMAC_CFG2_LF_REMOTE		0x02000000		// Remote link fault (READ ONLY)
 #define AXGMAC_CFG2_LF_LOCAL		0x01000000		// Local link fault (READ ONLY)
 #define AXGMAC_CFG2_IPG_MASK		0x001F0000		// Inter packet gap
-#define AXGMAC_CFG2_IPG_SHIFT		16
+#define AXGMAC_CFG2_IPG_SHIFT			16
 #define AXGMAC_CFG2_PAUSE_XMT		0x00008000		// Pause transmit module
 #define AXGMAC_CFG2_IPG_EXTEN		0x00000020		// Enable IPG extension algorithm
 #define AXGMAC_CFG2_IPGEX_MASK		0x0000001F		// IPG extension
@@ -299,9 +299,9 @@ typedef struct _SXG_HW_REGS {
 #define AXGMAC_SARHIGH_OCTET_SIX	0x00FF0000		// Sixth octet
 
 // A-XGMAC Maximum frame length register
-#define AXGMAC_MAXFRAME_XMT			0x3FFF0000		// Maximum transmit frame length
+#define AXGMAC_MAXFRAME_XMT		0x3FFF0000		// Maximum transmit frame length
 #define AXGMAC_MAXFRAME_XMT_SHIFT	16
-#define AXGMAC_MAXFRAME_RCV			0x0000FFFF		// Maximum receive frame length
+#define AXGMAC_MAXFRAME_RCV		0x0000FFFF		// Maximum receive frame length
 // This register doesn't need to be written for standard MTU.
 // For jumbo, I'll just statically define the value here.  This
 // value sets the receive byte count to 9036 (0x234C) and the
@@ -324,34 +324,34 @@ typedef struct _SXG_HW_REGS {
 
 // A-XGMAC AMIIM Field Register
 #define AXGMAC_AMIIM_FIELD_ST		0xC0000000		// 2-bit ST field
-#define AXGMAC_AMIIM_FIELD_ST_SHIFT			30
+#define AXGMAC_AMIIM_FIELD_ST_SHIFT		30
 #define AXGMAC_AMIIM_FIELD_OP		0x30000000		// 2-bit OP field
-#define AXGMAC_AMIIM_FIELD_OP_SHIFT			28
-#define AXGMAC_AMIIM_FIELD_PORT_ADDR 0x0F800000		// Port address field (hstphyadx in spec)
+#define AXGMAC_AMIIM_FIELD_OP_SHIFT		28
+#define AXGMAC_AMIIM_FIELD_PORT_ADDR	0x0F800000		// Port address field (hstphyadx in spec)
 #define AXGMAC_AMIIM_FIELD_PORT_SHIFT		23
 #define AXGMAC_AMIIM_FIELD_DEV_ADDR	0x007C0000		// Device address field (hstregadx in spec)
 #define AXGMAC_AMIIM_FIELD_DEV_SHIFT		18
 #define AXGMAC_AMIIM_FIELD_TA		0x00030000		// 2-bit TA field
-#define AXGMAC_AMIIM_FIELD_TA_SHIFT			16
+#define AXGMAC_AMIIM_FIELD_TA_SHIFT		16
 #define AXGMAC_AMIIM_FIELD_DATA		0x0000FFFF		// Data field
 
 // Values for the AXGMAC_AMIIM_FIELD_OP field in the A-XGMAC AMIIM Field Register
-#define	MIIM_OP_ADDR						0		// MIIM Address set operation
-#define	MIIM_OP_WRITE						1		// MIIM Write register operation
-#define	MIIM_OP_READ						2		// MIIM Read register operation
+#define	MIIM_OP_ADDR				0		// MIIM Address set operation
+#define	MIIM_OP_WRITE				1		// MIIM Write register operation
+#define	MIIM_OP_READ				2		// MIIM Read register operation
 #define	MIIM_OP_ADDR_SHIFT	(MIIM_OP_ADDR << AXGMAC_AMIIM_FIELD_OP_SHIFT)
 
 // Values for the AXGMAC_AMIIM_FIELD_PORT_ADDR field in the A-XGMAC AMIIM Field Register
-#define	MIIM_PORT_NUM						1		// All Sahara MIIM modules use port 1
+#define	MIIM_PORT_NUM				1		// All Sahara MIIM modules use port 1
 
 // Values for the AXGMAC_AMIIM_FIELD_DEV_ADDR field in the A-XGMAC AMIIM Field Register
-#define	MIIM_DEV_PHY_PMA					1		// PHY PMA/PMD module MIIM device number
-#define	MIIM_DEV_PHY_PCS					3		// PHY PCS module MIIM device number
-#define	MIIM_DEV_PHY_XS						4		// PHY XS module MIIM device number
-#define	MIIM_DEV_XGXS						5		// XGXS MIIM device number
+#define	MIIM_DEV_PHY_PMA			1		// PHY PMA/PMD module MIIM device number
+#define	MIIM_DEV_PHY_PCS			3		// PHY PCS module MIIM device number
+#define	MIIM_DEV_PHY_XS				4		// PHY XS module MIIM device number
+#define	MIIM_DEV_XGXS				5		// XGXS MIIM device number
 
 // Values for the AXGMAC_AMIIM_FIELD_TA field in the A-XGMAC AMIIM Field Register
-#define	MIIM_TA_10GB						2		// set to 2 for 10 GB operation
+#define	MIIM_TA_10GB				2		// set to 2 for 10 GB operation
 
 // A-XGMAC AMIIM Configuration Register
 #define AXGMAC_AMIIM_CFG_NOPREAM	0x00000080		// Bypass preamble of mngmt frame
@@ -365,25 +365,25 @@ typedef struct _SXG_HW_REGS {
 #define AXGMAC_AMIIM_INDC_BUSY		0x00000001		// Set until cmd operation complete
 
 // Link Status and Control Register
-#define	LS_PHY_CLR_RESET			0x80000000		// Clear reset signal to PHY
+#define	LS_PHY_CLR_RESET		0x80000000		// Clear reset signal to PHY
 #define	LS_SERDES_POWER_DOWN		0x40000000		// Power down the Sahara Serdes
-#define	LS_XGXS_ENABLE				0x20000000		// Enable the XAUI XGXS logic
-#define	LS_XGXS_CTL					0x10000000		// Hold XAUI XGXS logic reset until Serdes is up
-#define	LS_SERDES_DOWN				0x08000000		// When 0, XAUI Serdes is up and initialization is complete
-#define	LS_TRACE_DOWN				0x04000000		// When 0, Trace Serdes is up and initialization is complete
-#define	LS_PHY_CLK_25MHZ			0x02000000		// Set PHY clock to 25 MHz (else 156.125 MHz)
-#define	LS_PHY_CLK_EN				0x01000000		// Enable clock to PHY
-#define	LS_XAUI_LINK_UP				0x00000010		// XAUI link is up
-#define	LS_XAUI_LINK_CHNG			0x00000008		// XAUI link status has changed
-#define	LS_LINK_ALARM				0x00000004		// Link alarm pin
-#define	LS_ATTN_CTRL_MASK			0x00000003		// Mask link attention control bits
-#define	LS_ATTN_ALARM				0x00000000		// 00 => Attn on link alarm
+#define	LS_XGXS_ENABLE			0x20000000		// Enable the XAUI XGXS logic
+#define	LS_XGXS_CTL			0x10000000		// Hold XAUI XGXS logic reset until Serdes is up
+#define	LS_SERDES_DOWN			0x08000000		// When 0, XAUI Serdes is up and initialization is complete
+#define	LS_TRACE_DOWN			0x04000000		// When 0, Trace Serdes is up and initialization is complete
+#define	LS_PHY_CLK_25MHZ		0x02000000		// Set PHY clock to 25 MHz (else 156.125 MHz)
+#define	LS_PHY_CLK_EN			0x01000000		// Enable clock to PHY
+#define	LS_XAUI_LINK_UP			0x00000010		// XAUI link is up
+#define	LS_XAUI_LINK_CHNG		0x00000008		// XAUI link status has changed
+#define	LS_LINK_ALARM			0x00000004		// Link alarm pin
+#define	LS_ATTN_CTRL_MASK		0x00000003		// Mask link attention control bits
+#define	LS_ATTN_ALARM			0x00000000		// 00 => Attn on link alarm
 #define	LS_ATTN_ALARM_OR_STAT_CHNG	0x00000001		// 01 => Attn on link alarm or status change
-#define	LS_ATTN_STAT_CHNG			0x00000002		// 10 => Attn on link status change
-#define	LS_ATTN_NONE				0x00000003		// 11 => no Attn
+#define	LS_ATTN_STAT_CHNG		0x00000002		// 10 => Attn on link status change
+#define	LS_ATTN_NONE			0x00000003		// 11 => no Attn
 
 // Link Address High Registers
-#define	LINK_ADDR_ENABLE			0x80000000		// Enable this link address
+#define	LINK_ADDR_ENABLE		0x80000000		// Enable this link address
 
 
 /***************************************************************************
@@ -396,7 +396,7 @@ typedef struct _SXG_HW_REGS {
 #define XGXS_ADDRESS_STATUS1		0x0001			// XS Status 1
 #define XGXS_ADDRESS_DEVID_LOW		0x0002			// XS Device ID (low)
 #define XGXS_ADDRESS_DEVID_HIGH		0x0003			// XS Device ID (high)
-#define XGXS_ADDRESS_SPEED			0x0004			// XS Speed ability
+#define XGXS_ADDRESS_SPEED		0x0004			// XS Speed ability
 #define XGXS_ADDRESS_DEV_LOW		0x0005			// XS Devices in package
 #define XGXS_ADDRESS_DEV_HIGH		0x0006			// XS Devices in package
 #define XGXS_ADDRESS_STATUS2		0x0008			// XS Status 2
@@ -410,27 +410,27 @@ typedef struct _SXG_HW_REGS {
 #define XGXS_ADDRESS_RESET_HI2		0x8003			// Vendor-Specific Reset Hi 2
 
 // XS Control 1 register bit definitions
-#define XGXS_CONTROL1_RESET			0x8000			// Reset - self clearing
+#define XGXS_CONTROL1_RESET		0x8000			// Reset - self clearing
 #define XGXS_CONTROL1_LOOPBACK		0x4000			// Enable loopback
 #define XGXS_CONTROL1_SPEED1		0x2000			// 0 = unspecified, 1 = 10Gb+
 #define XGXS_CONTROL1_LOWPOWER		0x0400			// 1 = Low power mode
 #define XGXS_CONTROL1_SPEED2		0x0040			// Same as SPEED1 (?)
-#define XGXS_CONTROL1_SPEED			0x003C			// Everything reserved except zero (?)
+#define XGXS_CONTROL1_SPEED		0x003C			// Everything reserved except zero (?)
 
 // XS Status 1 register bit definitions
-#define XGXS_STATUS1_FAULT			0x0080			// Fault detected
-#define XGXS_STATUS1_LINK			0x0004			// 1 = Link up
+#define XGXS_STATUS1_FAULT		0x0080			// Fault detected
+#define XGXS_STATUS1_LINK		0x0004			// 1 = Link up
 #define XGXS_STATUS1_LOWPOWER		0x0002			// 1 = Low power supported
 
 // XS Speed register bit definitions
-#define XGXS_SPEED_10G				0x0001			// 1 = 10G capable
+#define XGXS_SPEED_10G			0x0001			// 1 = 10G capable
 
 // XS Devices register bit definitions
-#define XGXS_DEVICES_DTE			0x0020			// DTE XS Present
-#define XGXS_DEVICES_PHY			0x0010			// PHY XS Present
-#define XGXS_DEVICES_PCS			0x0008			// PCS Present
-#define XGXS_DEVICES_WIS			0x0004			// WIS Present
-#define XGXS_DEVICES_PMD			0x0002			// PMD/PMA Present
+#define XGXS_DEVICES_DTE		0x0020			// DTE XS Present
+#define XGXS_DEVICES_PHY		0x0010			// PHY XS Present
+#define XGXS_DEVICES_PCS		0x0008			// PCS Present
+#define XGXS_DEVICES_WIS		0x0004			// WIS Present
+#define XGXS_DEVICES_PMD		0x0002			// PMD/PMA Present
 #define XGXS_DEVICES_CLAUSE22		0x0001			// Clause 22 registers present
 
 // XS Devices High register bit definitions
@@ -444,18 +444,18 @@ typedef struct _SXG_HW_REGS {
 #define XGXS_STATUS2_RCV_FAULT		0x0400			// Receive fault
 
 // XS Package ID High register bit definitions
-#define XGXS_PKGID_HIGH_ORG			0xFC00			// Organizationally Unique
-#define XGXS_PKGID_HIGH_MFG			0x03F0			// Manufacturer Model
-#define XGXS_PKGID_HIGH_REV			0x000F			// Revision Number
+#define XGXS_PKGID_HIGH_ORG		0xFC00			// Organizationally Unique
+#define XGXS_PKGID_HIGH_MFG		0x03F0			// Manufacturer Model
+#define XGXS_PKGID_HIGH_REV		0x000F			// Revision Number
 
 // XS Lane Status register bit definitions
-#define XGXS_LANE_PHY				0x1000			// PHY/DTE lane alignment status
-#define XGXS_LANE_PATTERN			0x0800			// Pattern testing ability
-#define XGXS_LANE_LOOPBACK			0x0400			// PHY loopback ability
-#define XGXS_LANE_SYNC3				0x0008			// Lane 3 sync
-#define XGXS_LANE_SYNC2				0x0004			// Lane 2 sync
-#define XGXS_LANE_SYNC1				0x0002			// Lane 1 sync
-#define XGXS_LANE_SYNC0				0x0001			// Lane 0 sync
+#define XGXS_LANE_PHY			0x1000			// PHY/DTE lane alignment status
+#define XGXS_LANE_PATTERN		0x0800			// Pattern testing ability
+#define XGXS_LANE_LOOPBACK		0x0400			// PHY loopback ability
+#define XGXS_LANE_SYNC3			0x0008			// Lane 3 sync
+#define XGXS_LANE_SYNC2			0x0004			// Lane 2 sync
+#define XGXS_LANE_SYNC1			0x0002			// Lane 1 sync
+#define XGXS_LANE_SYNC0			0x0001			// Lane 0 sync
 
 // XS Test Control register bit definitions
 #define XGXS_TEST_PATTERN_ENABLE	0x0004			// Test pattern enabled
@@ -473,10 +473,10 @@ typedef struct _SXG_HW_REGS {
 // LASI (Link Alarm Status Interrupt) Registers (located in MIIM_DEV_PHY_PMA device)
 #define LASI_RX_ALARM_CONTROL		0x9000			// LASI RX_ALARM Control
 #define LASI_TX_ALARM_CONTROL		0x9001			// LASI TX_ALARM Control
-#define LASI_CONTROL				0x9002			// LASI Control
+#define LASI_CONTROL			0x9002			// LASI Control
 #define LASI_RX_ALARM_STATUS		0x9003			// LASI RX_ALARM Status
 #define LASI_TX_ALARM_STATUS		0x9004			// LASI TX_ALARM Status
-#define LASI_STATUS					0x9005			// LASI Status
+#define LASI_STATUS			0x9005			// LASI Status
 
 // LASI_CONTROL bit definitions
 #define	LASI_CTL_RX_ALARM_ENABLE	0x0004			// Enable RX_ALARM interrupts
@@ -489,34 +489,34 @@ typedef struct _SXG_HW_REGS {
 #define	LASI_STATUS_LS_ALARM		0x0001			// Link Status
 
 // PHY registers - PMA/PMD (device 1)
-#define	PHY_PMA_CONTROL1			0x0000			// PMA/PMD Control 1
-#define	PHY_PMA_STATUS1				0x0001			// PMA/PMD Status 1
-#define	PHY_PMA_RCV_DET				0x000A			// PMA/PMD Receive Signal Detect
+#define	PHY_PMA_CONTROL1		0x0000			// PMA/PMD Control 1
+#define	PHY_PMA_STATUS1			0x0001			// PMA/PMD Status 1
+#define	PHY_PMA_RCV_DET			0x000A			// PMA/PMD Receive Signal Detect
 		// other PMA/PMD registers exist and can be defined as needed
 
 // PHY registers - PCS (device 3)
-#define	PHY_PCS_CONTROL1			0x0000			// PCS Control 1
-#define	PHY_PCS_STATUS1				0x0001			// PCS Status 1
-#define	PHY_PCS_10G_STATUS1			0x0020			// PCS 10GBASE-R Status 1
+#define	PHY_PCS_CONTROL1		0x0000			// PCS Control 1
+#define	PHY_PCS_STATUS1			0x0001			// PCS Status 1
+#define	PHY_PCS_10G_STATUS1		0x0020			// PCS 10GBASE-R Status 1
 		// other PCS registers exist and can be defined as needed
 
 // PHY registers - XS (device 4)
-#define	PHY_XS_CONTROL1				0x0000			// XS Control 1
-#define	PHY_XS_STATUS1				0x0001			// XS Status 1
-#define	PHY_XS_LANE_STATUS			0x0018			// XS Lane Status
+#define	PHY_XS_CONTROL1			0x0000			// XS Control 1
+#define	PHY_XS_STATUS1			0x0001			// XS Status 1
+#define	PHY_XS_LANE_STATUS		0x0018			// XS Lane Status
 		// other XS registers exist and can be defined as needed
 
 // PHY_PMA_CONTROL1 register bit definitions
-#define	PMA_CONTROL1_RESET			0x8000			// PMA/PMD reset
+#define	PMA_CONTROL1_RESET		0x8000			// PMA/PMD reset
 
 // PHY_PMA_RCV_DET register bit definitions
-#define	PMA_RCV_DETECT				0x0001			// PMA/PMD receive signal detect
+#define	PMA_RCV_DETECT			0x0001			// PMA/PMD receive signal detect
 
 // PHY_PCS_10G_STATUS1 register bit definitions
-#define	PCS_10B_BLOCK_LOCK			0x0001			// PCS 10GBASE-R locked to receive blocks
+#define	PCS_10B_BLOCK_LOCK		0x0001			// PCS 10GBASE-R locked to receive blocks
 
 // PHY_XS_LANE_STATUS register bit definitions
-#define	XS_LANE_ALIGN				0x1000			// XS transmit lanes aligned
+#define	XS_LANE_ALIGN			0x1000			// XS transmit lanes aligned
 
 // PHY Microcode download data structure
 typedef struct _PHY_UCODE {
@@ -558,8 +558,8 @@ typedef struct _XMT_DESC {
 		// command codes
 #define XMT_DESC_CMD_RAW_SEND		0		// raw send descriptor
 #define XMT_DESC_CMD_CSUM_INSERT	1		// checksum insert descriptor
-#define XMT_DESC_CMD_FORMAT			2		// format descriptor
-#define XMT_DESC_CMD_PRIME			3		// prime descriptor
+#define XMT_DESC_CMD_FORMAT		2		// format descriptor
+#define XMT_DESC_CMD_PRIME		3		// prime descriptor
 #define XMT_DESC_CMD_CODE_SHFT		6		// comand code shift (shift to bits [31:30] in word 0)
 		// shifted command codes
 #define XMT_RAW_SEND		(XMT_DESC_CMD_RAW_SEND    << XMT_DESC_CMD_CODE_SHFT)
@@ -569,22 +569,22 @@ typedef struct _XMT_DESC {
 
 // XMT_DESC Control Byte (XmtCtl) definitions
 // NOTE:  These bits do not work on Sahara (Rev A)!
-#define	XMT_CTL_PAUSE_FRAME			0x80	// current frame is a pause control frame (for statistics)
+#define	XMT_CTL_PAUSE_FRAME		0x80	// current frame is a pause control frame (for statistics)
 #define	XMT_CTL_CONTROL_FRAME		0x40	// current frame is a control frame (for statistics)
 #define	XMT_CTL_PER_PKT_QUAL		0x20	// per packet qualifier
 #define	XMT_CTL_PAD_MODE_NONE		0x00	// do not pad frame
-#define	XMT_CTL_PAD_MODE_64			0x08	// pad frame to 64 bytes
+#define	XMT_CTL_PAD_MODE_64		0x08	// pad frame to 64 bytes
 #define	XMT_CTL_PAD_MODE_VLAN_68	0x10	// pad frame to 64 bytes, and VLAN frames to 68 bytes
-#define	XMT_CTL_PAD_MODE_68			0x18	// pad frame to 68 bytes
-#define	XMT_CTL_GEN_FCS				0x04	// generate FCS (CRC) for this frame
-#define	XMT_CTL_DELAY_FCS_0			0x00	// do not delay FCS calcution
-#define	XMT_CTL_DELAY_FCS_1			0x01	// delay FCS calculation by 1 (4-byte) word
-#define	XMT_CTL_DELAY_FCS_2			0x02	// delay FCS calculation by 2 (4-byte) words
-#define	XMT_CTL_DELAY_FCS_3			0x03	// delay FCS calculation by 3 (4-byte) words
+#define	XMT_CTL_PAD_MODE_68		0x18	// pad frame to 68 bytes
+#define	XMT_CTL_GEN_FCS			0x04	// generate FCS (CRC) for this frame
+#define	XMT_CTL_DELAY_FCS_0		0x00	// do not delay FCS calcution
+#define	XMT_CTL_DELAY_FCS_1		0x01	// delay FCS calculation by 1 (4-byte) word
+#define	XMT_CTL_DELAY_FCS_2		0x02	// delay FCS calculation by 2 (4-byte) words
+#define	XMT_CTL_DELAY_FCS_3		0x03	// delay FCS calculation by 3 (4-byte) words
 
 // XMT_DESC XmtBufId definition
-#define XMT_BUF_ID_SHFT		8			// The Xmt buffer ID is formed by dividing
-										// the buffer (DRAM) address by 256 (or << 8)
+#define XMT_BUF_ID_SHFT		8	// The Xmt buffer ID is formed by dividing
+					// the buffer (DRAM) address by 256 (or << 8)
 
 /*****************************************************************************
  * Receiver Sequencer Definitions
@@ -594,8 +594,8 @@ typedef struct _XMT_DESC {
 #define	RCV_EVTQ_RBFID_MASK		0x0000FFFF	// bit mask for the Receive Buffer ID
 
 // Receive Buffer ID definition
-#define RCV_BUF_ID_SHFT		5			// The Rcv buffer ID is formed by dividing
-										// the buffer (DRAM) address by 32 (or << 5)
+#define RCV_BUF_ID_SHFT		5	// The Rcv buffer ID is formed by dividing
+					// the buffer (DRAM) address by 32 (or << 5)
 
 // Format of the 18 byte Receive Buffer returned by the
 // Receive Sequencer for received packets
@@ -723,12 +723,12 @@ typedef struct _SXG_CONFIG {
  *****************************************************************************/
 
 // Sahara (ASIC level) defines
-#define SAHARA_GRAM_SIZE			0x020000		// GRAM size - 128 KB
-#define SAHARA_DRAM_SIZE			0x200000		// DRAM size - 2 MB
-#define SAHARA_QRAM_SIZE			0x004000		// QRAM size - 16K entries (64 KB)
-#define SAHARA_WCS_SIZE				0x002000		// WCS - 8K instructions (x 108 bits)
+#define SAHARA_GRAM_SIZE		0x020000		// GRAM size - 128 KB
+#define SAHARA_DRAM_SIZE		0x200000		// DRAM size - 2 MB
+#define SAHARA_QRAM_SIZE		0x004000		// QRAM size - 16K entries (64 KB)
+#define SAHARA_WCS_SIZE			0x002000		// WCS - 8K instructions (x 108 bits)
 
 // Arabia (board level) defines
-#define	FLASH_SIZE				0x080000		// 512 KB (4 Mb)
-#define	EEPROM_SIZE_XFMR		512				// true EEPROM size (bytes), including xfmr area
-#define	EEPROM_SIZE_NO_XFMR		256				// EEPROM size excluding xfmr area
+#define	FLASH_SIZE			0x080000		// 512 KB (4 Mb)
+#define	EEPROM_SIZE_XFMR		512			// true EEPROM size (bytes), including xfmr area
+#define	EEPROM_SIZE_NO_XFMR		256			// EEPROM size excluding xfmr area
--- a/drivers/staging/sxg/sxg_os.h
+++ b/drivers/staging/sxg/sxg_os.h
@@ -44,7 +44,6 @@
 #define FALSE	(0)
 #define TRUE	(1)
 
-
 typedef struct _LIST_ENTRY {
 	struct _LIST_ENTRY *nle_flink;
 	struct _LIST_ENTRY *nle_blink;
@@ -69,35 +68,32 @@ typedef struct _LIST_ENTRY {
 
 /* These two have to be inlined since they return things. */
 
-static __inline PLIST_ENTRY
-RemoveHeadList(list_entry *l)
+static __inline PLIST_ENTRY RemoveHeadList(list_entry * l)
 {
-        list_entry              *f;
-        list_entry              *e;
+	list_entry *f;
+	list_entry *e;
 
-        e = l->nle_flink;
-        f = e->nle_flink;
-        l->nle_flink = f;
-        f->nle_blink = l;
+	e = l->nle_flink;
+	f = e->nle_flink;
+	l->nle_flink = f;
+	f->nle_blink = l;
 
-        return (e);
+	return (e);
 }
 
-static __inline PLIST_ENTRY
-RemoveTailList(list_entry *l)
+static __inline PLIST_ENTRY RemoveTailList(list_entry * l)
 {
-        list_entry              *b;
-        list_entry              *e;
+	list_entry *b;
+	list_entry *e;
 
-        e = l->nle_blink;
-        b = e->nle_blink;
-        l->nle_blink = b;
-        b->nle_flink = l;
+	e = l->nle_blink;
+	b = e->nle_blink;
+	l->nle_blink = b;
+	b->nle_flink = l;
 
-        return (e);
+	return (e);
 }
 
-
 #define InsertTailList(l, e)                    \
         do {                                    \
                 list_entry              *b;     \
@@ -120,7 +116,6 @@ RemoveTailList(list_entry *l)
                 (l)->nle_flink = (e);           \
         } while (0)
 
-
 #define ATK_DEBUG  1
 
 #if ATK_DEBUG
@@ -133,7 +128,6 @@ RemoveTailList(list_entry *l)
 #define SLIC_TIMESTAMP(value)
 #endif
 
-
 /******************  SXG DEFINES  *****************************************/
 
 #ifdef  ATKDBG
@@ -150,5 +144,4 @@ RemoveTailList(list_entry *l)
 #define WRITE_REG64(a,reg,value,cpu)                sxg_reg64_write((a),(&reg),(value),(cpu))
 #define READ_REG(reg,value)   (value) = readl((void __iomem *)(&reg))
 
-#endif  /* _SLIC_OS_SPECIFIC_H_  */
-
+#endif /* _SLIC_OS_SPECIFIC_H_  */
--- a/drivers/staging/sxg/sxgphycode.h
+++ b/drivers/staging/sxg/sxgphycode.h
@@ -34,7 +34,7 @@ static PHY_UCODE PhyUcode[] = {
 	 */
 	/* Addr, Data */
 	{0xc017, 0xfeb0},	/* flip RX_LOS polarity (mandatory */
-				/*  patch for SFP+ applications) */
+	/*  patch for SFP+ applications) */
 	{0xC001, 0x0428},	/* flip RX serial polarity */
 
 	{0xc013, 0xf341},	/* invert lxmit clock (mandatory patch) */
@@ -43,7 +43,7 @@ static PHY_UCODE PhyUcode[] = {
 	{0xc210, 0x8000},	/* reset datapath (mandatory patch) */
 	{0xc210, 0x0000},	/* reset datapath (mandatory patch) */
 	{0x0000, 0x0032},	/* wait for 50ms for datapath reset to */
-				/* complete. (mandatory patch) */
+	/* complete. (mandatory patch) */
 
 	/* Configure the LED's */
 	{0xc214, 0x0099},	/* configure the LED drivers */
@@ -52,15 +52,15 @@ static PHY_UCODE PhyUcode[] = {
 
 	/* Transceiver-specific MDIO Patches: */
 	{0xc010, 0x448a},	/* (bit 14) mask out high BER input from the */
-				/* LOS signal in 1.000A */
-				/* (mandatory patch for SR code)*/
+	/* LOS signal in 1.000A */
+	/* (mandatory patch for SR code) */
 	{0xc003, 0x0181},	/* (bit 7) enable the CDR inc setting in */
-				/* 1.C005 (mandatory patch for SR code) */
+	/* 1.C005 (mandatory patch for SR code) */
 
 	/* Transceiver-specific Microcontroller Initialization: */
 	{0xc04a, 0x5200},	/* activate microcontroller and pause */
 	{0x0000, 0x0032},	/* wait 50ms for microcontroller before */
-				/* writing in code. */
+	/* writing in code. */
 
 	/* code block starts here: */
 	{0xcc00, 0x2009},
