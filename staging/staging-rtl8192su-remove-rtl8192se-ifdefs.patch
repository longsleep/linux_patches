From bzolnier@gmail.com  Fri Jul 10 16:02:10 2009
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Fri, 03 Jul 2009 16:08:08 +0200
Subject: Staging: rtl8192su: remove RTL8192SE ifdefs
To: "Greg Kroah-Hartman" <gregkh@suse.de>
Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>, linux-kernel@vger.kernel.org
Message-ID: <20090703140808.7303.49623.sendpatchset@localhost.localdomain>


From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rtl8192su/ieee80211/ieee80211_softmac_wx.c |    4 
 drivers/staging/rtl8192su/ieee80211/ieee80211_tx.c         |    2 
 drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c       |   16 
 drivers/staging/rtl8192su/r8192S_Efuse.c                   |   27 
 drivers/staging/rtl8192su/r8192S_firmware.c                |   28 
 drivers/staging/rtl8192su/r8192S_firmware.h                |    5 
 drivers/staging/rtl8192su/r8192S_hw.h                      |  101 ---
 drivers/staging/rtl8192su/r8192S_phy.c                     |  417 -------------
 8 files changed, 12 insertions(+), 588 deletions(-)

--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac_wx.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac_wx.c
@@ -327,9 +327,7 @@ void ieee80211_wx_sync_scan_wq(struct wo
 
 	ieee->state = IEEE80211_LINKED_SCANNING;
 	ieee->link_change(ieee->dev);
-#ifndef RTL8192SE
 	ieee->InitialGainHandler(ieee->dev,IG_Backup);
-#endif
 	if (ieee->SetFwCmdHandler)
 	{
 		ieee->SetFwCmdHandler(ieee->dev, FW_CMD_DIG_HALT);
@@ -356,9 +354,7 @@ void ieee80211_wx_sync_scan_wq(struct wo
 		ieee->set_chan(ieee->dev, chan);
 	}
 
-#ifndef RTL8192SE
 	ieee->InitialGainHandler(ieee->dev,IG_Restore);
-#endif
 	if (ieee->SetFwCmdHandler)
 	{
 		ieee->SetFwCmdHandler(ieee->dev, FW_CMD_DIG_RESUME);
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_tx.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_tx.c
@@ -495,7 +495,7 @@ void ieee80211_query_protectionmode(stru
 			{
 				tcb_desc->bCTSEnable	= true;
 				tcb_desc->rts_rate  = 	MGN_24M;
-#if defined(RTL8192SE) || defined(RTL8192SU)
+#if defined(RTL8192SU)
 				tcb_desc->bRTSEnable = false;
 #else
 				tcb_desc->bRTSEnable = true;
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
@@ -516,7 +516,7 @@ bool HTIOTActIsDisableMCSTwoSpatialStrea
 //#endif
 #endif
 #if 1
-#if (defined(RTL8192SE) || (defined(RTL8192SU)))
+#if  defined(RTL8192SU)
        PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	if(ieee->is_ap_in_wep_tkip && ieee->is_ap_in_wep_tkip(ieee->dev))
 	{
@@ -595,7 +595,7 @@ u8 HTIOTActIsForcedRTSCTS(struct ieee802
 	u8	retValue = 0;
 	printk("============>%s(), %d\n", __FUNCTION__, network->realtek_cap_exit);
 	// Force protection
-#if defined(RTL8192SE) || defined(RTL8192SU)
+#if defined(RTL8192SU)
 	if(ieee->pHTInfo->bCurrentHTSupport)
 	{
 		//if(!network->realtek_cap_exit)
@@ -621,14 +621,12 @@ HTIOTActIsForcedAMSDU8K(struct ieee80211
 u8 HTIOTActIsCCDFsync(u8* PeerMacAddr)
 {
 	u8	retValue = 0;
-#ifndef RTL8192SE
 	if(	(memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3)==0) ||
 	    	(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0) ||
 	    	(memcmp(PeerMacAddr, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) ==0))
 	{
 		retValue = 1;
 	}
-#endif
 	return retValue;
 }
 
@@ -642,7 +640,7 @@ HTIOCActRejcectADDBARequest(struct ieee8
 	//if(IS_HARDWARE_TYPE_8192SE(Adapter) ||
 	//	IS_HARDWARE_TYPE_8192SU(Adapter)
 	//)
-#if (defined RTL8192SE || defined RTL8192SU)
+#if  defined RTL8192SU
 	{
 		// Do not reject ADDBA REQ because some of the AP may
 		// keep on sending ADDBA REQ qhich cause DHCP fail or ping loss!
@@ -735,7 +733,7 @@ HTIOTActIsDisableTx40MHz(struct ieee8021
 {
 	u8	retValue = 0;
 
-#if (defined RTL8192SU || defined RTL8192SE)
+#if defined RTL8192SU
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	if(	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
 		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
@@ -756,7 +754,7 @@ HTIOTActIsTxNoAggregation(struct ieee802
 {
 	u8 retValue = 0;
 
-#if (defined RTL8192SU || defined RTL8192SE)
+#if defined RTL8192SU
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	if(	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
 		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
@@ -779,7 +777,7 @@ HTIOTActIsDisableTx2SS(struct ieee80211_
 {
 	u8	retValue = 0;
 
-#if (defined RTL8192SU || defined RTL8192SE)
+#if defined RTL8192SU
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	if(	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
 		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
@@ -799,7 +797,7 @@ HTIOTActIsDisableTx2SS(struct ieee80211_
 bool HTIOCActAllowPeerAggOnePacket(struct ieee80211_device* ieee,struct ieee80211_network *network)
 {
 	bool 	retValue = false;
-#if defined(RTL8192SE) || defined(RTL8192SU)
+#if defined(RTL8192SU)
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	{
 		if(pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)
--- a/drivers/staging/rtl8192su/r8192S_Efuse.c
+++ b/drivers/staging/rtl8192su/r8192S_Efuse.c
@@ -708,12 +708,6 @@ EFUSE_ShadowUpdate(struct net_device* de
 	for (offset = 0; offset < 16; offset++)
 	{
 		// Offset 0x18-1F are reserved now!!!
-#ifdef RTL8192SE
-		if(priv->card_8192 == NIC_8192SE){
-			if (offset == 3)
-				continue;
-		}
-#endif
 		word_en = 0x0F;
 		base = offset * 8;
 
@@ -729,12 +723,6 @@ EFUSE_ShadowUpdate(struct net_device* de
 			}
 
 			// 2008/12/11 MH HW autoload fail workaround for A/BCUT.
-#ifdef RTL8192SE
-			if (first_pg == TRUE && offset == 1 && (priv->card_8192 == NIC_8192SE))
-			{
-				continue;
-			}
-#endif
 
 			if (first_pg == TRUE)
 			{
@@ -774,21 +762,6 @@ EFUSE_ShadowUpdate(struct net_device* de
 	// 2008/12/01 MH For Efuse HW load bug workarounf method!!!!
 	// We will force write 0x10EC into address 10&11 after all Efuse content.
 	//
-#ifdef RTL8192SE
-	if (first_pg == TRUE && (priv->card_8192 == NIC_8192SE))
-	{
-		// 2008/12/11 MH Use new method to prevent HW autoload fail.
-		u8	tmpdata[8];
-
-		memcpy(tmpdata, (&priv->EfuseMap[EFUSE_MODIFY_MAP][8]), 8);
-		efuse_PgPacketWrite(dev, 1, 0x0, tmpdata);
-#if 0
-		u1Byte	tmpdata[8] = {0xFF, 0xFF, 0xEC, 0x10, 0xFF, 0xFF, 0xFF, 0xFF};
-
-		efuse_PgPacketWrite(pAdapter, 1, 0xD, tmpdata);
-#endif
-	}
-#endif
 
 
 	// For warm reboot, we must resume Efuse clock to 500K.
--- a/drivers/staging/rtl8192su/r8192S_firmware.c
+++ b/drivers/staging/rtl8192su/r8192S_firmware.c
@@ -11,7 +11,7 @@
  *        NDIS_STATUS_FAILURE - the following initialization process should be terminated
  *        NDIS_STATUS_SUCCESS - if firmware initialization process success
 **************************************************************************************************/
-#if defined(RTL8192SE)||defined(RTL8192SU)
+#if defined(RTL8192SU)
 #include "r8192U.h"
 #include "r8192S_firmware.h"
 #include <linux/unistd.h>
@@ -50,9 +50,6 @@ bool FirmwareDownloadCode(struct net_dev
 	u8                  	    bLastIniPkt = 0;
 	u16 			    ExtraDescOffset = 0;
 
-#ifdef RTL8192SE
-	fw_SetRQPN(dev);	// For 92SE only
-#endif
 
 	RT_TRACE(COMP_FIRMWARE, "--->FirmwareDownloadCode()\n" );
 
@@ -117,19 +114,6 @@ cmdsend_downloadcode_fail:
 
 }
 
-#ifdef RTL8192SE
-static void fw_SetRQPN(struct net_device *dev)
-{
-	// Only for 92SE HW bug, we have to set RAPN before every FW download
-	// We can remove the code later.
-	write_nic_dword(dev,  RQPN, 0xffffffff);
-	write_nic_dword(dev,  RQPN+4, 0xffffffff);
-	write_nic_byte(dev,  RQPN+8, 0xff);
-	write_nic_byte(dev,  RQPN+0xB, 0x80);
-	//#if ((HAL_CODE_BASE ==  RTL8192_S) && (PLATFORM != PLATFORM_WINDOWS_USB))
-
-}	/* fw_SetRQPN */
-#endif
 
 RT_STATUS
 FirmwareEnableCPU(struct net_device *dev)
@@ -141,9 +125,6 @@ FirmwareEnableCPU(struct net_device *dev
 	u32		iCheckTime = 200;
 
 	RT_TRACE(COMP_FIRMWARE, "-->FirmwareEnableCPU()\n" );
-#ifdef RTL8192SE
-	fw_SetRQPN(dev);	// For 92SE only
-#endif
 	// Enable CPU.
 	tmpU1b = read_nic_byte(dev, SYS_CLKR);
 	write_nic_byte(dev,  SYS_CLKR, (tmpU1b|SYS_CPU_CLKSEL)); //AFE source
@@ -302,10 +283,6 @@ FirmwareCheckReady(struct net_device *de
               // <Roger_Notes> USB interface will update reserved followings parameters later!!
               // 2008.08.28.
               //
-#ifdef RTL8192SE
-		//write_nic_dword(dev, RQPN, 0x10101010);
-		//write_nic_byte(dev,  0xAB, 0x80);
-#endif
 
 	       //
               // <Roger_Notes> If right here, we can set TCR/RCR to desired value
@@ -601,9 +578,6 @@ bool fw_download_code(struct net_device 
 	unsigned char	    *seg_ptr;
 	cb_desc		    *tcb_desc;
 	u8                  bLastIniPkt;
-#ifdef RTL8192SE
-	fw_SetRQPN(dev);	// For 92SE only
-#endif
 
 #ifndef RTL8192SU
 	if(buffer_len >= 64000-USB_HWDESC_HEADER_LEN)
--- a/drivers/staging/rtl8192su/r8192S_firmware.h
+++ b/drivers/staging/rtl8192su/r8192S_firmware.h
@@ -30,12 +30,7 @@
 #define	MAX_FIRMWARE_CODE_SIZE	0xFF00 // Firmware Local buffer size.
 #define 	RTL8190_CPU_START_OFFSET			0x80
 
-#ifdef RTL8192SE
-//It should be double word alignment
-#define GET_COMMAND_PACKET_FRAG_THRESHOLD(v)	4*(v/4) - 8
-#else
 #define GET_COMMAND_PACKET_FRAG_THRESHOLD(v)	(4*(v/4) - 8 - USB_HWDESC_HEADER_LEN)
-#endif
 
 //typedef enum _DESC_PACKET_TYPE{
 //	DESC_PACKET_TYPE_INIT = 0,
--- a/drivers/staging/rtl8192su/r8192S_hw.h
+++ b/drivers/staging/rtl8192su/r8192S_hw.h
@@ -1205,106 +1205,6 @@ Default: 00b.
 //       8192S EEPROM/EFUSE share register definition.
 //----------------------------------------------------------------------------
 
-#ifdef RTL8192SE
-//
-// 2008/11/05 MH Redefine EEPROM address for 8192SE
-// 92SE/SU EEPROM definition seems not the same!!!!!!
-// EEPROM MAP REgister Definition!!!! Please refer to 8192SE EEPROM V0.5 2008/10/21
-// Update to 8192SE EEPROM V0.6 2008/11/11
-//
-#define 		RTL8190_EEPROM_ID				0x8129	// 0-1
-#define 		EEPROM_HPON					0x02 // LDO settings.2-5
-#define 		EEPROM_CLK						0x06 // Clock settings.6-7
-#define 		EEPROM_TESTR					0x08 // SE Test mode.8
-
-#define 		EEPROM_VID						0x0A // SE Vendor ID.A-B
-#define 		EEPROM_DID						0x0C // SE Device ID. C-D
-#define 		EEPROM_SVID					0x0E // SE Vendor ID.E-F
-#define 		EEPROM_SMID					0x10 // SE PCI Subsystem ID. 10-11
-
-#define 		EEPROM_MAC_ADDR				0x12 // SEMAC Address. 12-17
-#define 		EEPROM_NODE_ADDRESS_BYTE_0	0x12 // MAC address.
-
-#define 		EEPROM_PwDiff					0x54 // Difference of gain index between legacy and high throughput OFDM.
-
-//
-// 0x20 - 4B EPHY parameter!!!
-//
-//
-#define 		EEPROM_TxPowerBase			0x50 // Tx Power of serving station.
-#define 		EEPROM_TxPwIndex_CCK_24G	0x5D // 0x50~0x5D Range = 0~0x24//FIXLZM
-#define 		EEPROM_TxPwIndex_OFDM_24G	0x6B // 0x5E~0x6B Range = 0~0x24//FIXLZM
-#define		EEPROM_TX_PWR_INDEX_RANGE	28		// CCK and OFDM 14 channel
-
-
-// 2009/01/21 MH Add for SD3 requirement
-#define 		EEPROM_TX_PWR_HT20_DIFF		0x62// HT20 Tx Power Index Difference
-#define 		DEFAULT_HT20_TXPWR_DIFF		2	// HT20<->40 default Tx Power Index Difference
-#define 		EEPROM_TX_PWR_OFDM_DIFF		0x65// OFDM Tx Power Index Difference
-#define 		EEPROM_TX_PWR_BAND_EDGE	0x67// TX Power offset at band-edge channel
-#define 		TX_PWR_BAND_EDGE_CHK		0x6D// Check if band-edge scheme is enabled
-
-// Oly old EEPROM format support the definition=============================
-//
-#define 		EEPROM_TxPwIndex_CCK_24G	0x5D // 0x50~0x5D Range = 0~0x24
-#define 		EEPROM_TxPwIndex_OFDM_24G	0x6B // 0x5E~0x6B Range = 0~0x24
-#define 		EEPROM_HT2T_CH1_A			0x6c //HT 2T path A channel 1 Power Index.
-#define 		EEPROM_HT2T_CH7_A			0x6d //HT 2T path A channel 7 Power Index.
-#define 		EEPROM_HT2T_CH13_A			0x6e //HT 2T path A channel 13 Power Index.
-#define 		EEPROM_HT2T_CH1_B			0x6f //HT 2T path B channel 1 Power Index.
-#define 		EEPROM_HT2T_CH7_B			0x70 //HT 2T path B channel 7 Power Index.
-#define 		EEPROM_HT2T_CH13_B			0x71 //HT 2T path B channel 13 Power Index.
-//
-#define 		EEPROM_TSSI_A					0x74 //TSSI value of path A.
-#define 		EEPROM_TSSI_B					0x75 //TSSI value of path B.
-//
-#define		EEPROM_RFInd_PowerDiff				0x76
-#define		EEPROM_Default_LegacyHTTxPowerDiff	0x3
-//
-#define 		EEPROM_ThermalMeter			0x77 // Thermal meter default value.
-#define 		EEPROM_CrystalCap				0x79 // Crystal Cap.
-#define 		EEPROM_ChannelPlan				0x7B // Map of supported channels.
-#define 		EEPROM_Version					0x7C // The EEPROM content version
-#define		EEPROM_CustomID				0x7A
-#define 		EEPROM_BoardType				0x7E
-// 0: 2x2 Green RTL8192GE miniCard (QFN68)
-// 1: 1x2            RTL8191SE miniCard (QFN64)
-// 2: 2x2            RTL8192SE miniCard (QFN68)
-// 3: 1x2            RTL8191SR minicCard(QFN64)
-
-//
-// Default Value for EEPROM or EFUSE!!!
-//
-#define		EEPROM_Default_TSSI			0x0
-#define 		EEPROM_Default_TxPowerDiff		0x0
-#define 		EEPROM_Default_CrystalCap		0x5
-#define 		EEPROM_Default_BoardType		0x02 // Default: 2X2, RTL8192SE(QFPN68)
-#define 		EEPROM_Default_TxPower		0x1010
-#define		EEPROM_Default_HT2T_TxPwr		0x10
-
-#define		EEPROM_Default_LegacyHTTxPowerDiff	0x3
-#define		EEPROM_Default_ThermalMeter		0x12
-#define		EEPROM_Default_AntTxPowerDiff		0x0
-#define		EEPROM_Default_TxPwDiff_CrystalCap	0x5
-#define		EEPROM_Default_TxPowerLevel		0x22
-
-#define		EEPROM_CHANNEL_PLAN_FCC				0x0
-#define		EEPROM_CHANNEL_PLAN_IC				0x1
-#define		EEPROM_CHANNEL_PLAN_ETSI			0x2
-#define		EEPROM_CHANNEL_PLAN_SPAIN			0x3
-#define		EEPROM_CHANNEL_PLAN_FRANCE			0x4
-#define		EEPROM_CHANNEL_PLAN_MKK				0x5
-#define		EEPROM_CHANNEL_PLAN_MKK1			0x6
-#define		EEPROM_CHANNEL_PLAN_ISRAEL			0x7
-#define		EEPROM_CHANNEL_PLAN_TELEC			0x8
-#define		EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN	0x9
-#define		EEPROM_CHANNEL_PLAN_WORLD_WIDE_13	0xA
-#define		EEPROM_CHANNEL_PLAN_BY_HW_MASK	0x80
-
-
-#define 		EEPROM_CID_DEFAULT					0x0
-#define 		EEPROM_CID_TOSHIBA			0x4
-#else
 //----------------------------------------------------------------------------
 //       8192S EEROM and Compatible E-Fuse definition. Added by Roger, 2008.10.21.
 //----------------------------------------------------------------------------
@@ -1382,7 +1282,6 @@ Default: 00b.
 //#define EEPROM_CID_TOSHIBA						0x4
 //#define EEPROM_CID_NetCore						0x5
 #define 		EEPROM_CID_WHQL 				0xFE // added by chiyoko for dtm, 20090108
-#endif
 
 //-----------------------------------------------------------------
 // 0x2c0 FW Command Control register definition, added by Roger, 2008.11.27.
--- a/drivers/staging/rtl8192su/r8192S_phy.c
+++ b/drivers/staging/rtl8192su/r8192S_phy.c
@@ -109,12 +109,6 @@ phy_SwChnlStepByStep(
 	);
 static RT_STATUS
 phy_ConfigBBWithPgHeaderFile(struct net_device* dev,u8 ConfigType);
-#ifdef RTL8192SE
-static  u32 phy_FwRFSerialRead( struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset);
-static u32 phy_RFSerialRead(struct net_device* dev,RF90_RADIO_PATH_E eRFPath,u32 Offset);
-static	void phy_FwRFSerialWrite( struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data);
-static void phy_RFSerialWrite( struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data);
-#endif
 static long phy_TxPwrIdxToDbm( struct net_device* dev, WIRELESS_MODE   WirelessMode, u8 TxPwrIdx);
 static u8 phy_DbmToTxPwrIdx( struct net_device* dev, WIRELESS_MODE WirelessMode, long PowerInDbm);
 void phy_SetFwCmdIOCallback(struct net_device* dev);
@@ -705,406 +699,6 @@ void rtl8192_phy_SetRFReg(struct net_dev
 
 }
 
-#ifdef RTL8192SE
-/*-----------------------------------------------------------------------------
- * Function:	phy_FwRFSerialRead()
- *
- * Overview:	We support firmware to execute RF-R/W.
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *	01/21/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-//use in phy only
-static	u32
-phy_FwRFSerialRead(
-	struct net_device* dev,
-	RF90_RADIO_PATH_E	eRFPath,
-	u32				Offset	)
-{
-	u32		retValue = 0;
-	//u32		Data = 0;
-	//u8		time = 0;
-#if 0
-	//DbgPrint("FW RF CTRL\n\r");
-	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
-	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
-	   much time. This is only for site survey. */
-	// 1. Read operation need not insert data. bit 0-11
-	//Data &= bMask12Bits;
-	// 2. Write RF register address. Bit 12-19
-	Data |= ((Offset&0xFF)<<12);
-	// 3. Write RF path.  bit 20-21
-	Data |= ((eRFPath&0x3)<<20);
-	// 4. Set RF read indicator. bit 22=0
-	//Data |= 0x00000;
-	// 5. Trigger Fw to operate the command. bit 31
-	Data |= 0x80000000;
-	// 6. We can not execute read operation if bit 31 is 1.
-	while (PlatformIORead4Byte(dev, QPNR)&0x80000000)
-	{
-		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
-		if (time++ < 100)
-		{
-			//DbgPrint("FW not finish RF-R Time=%d\n\r", time);
-			delay_us(10);
-		}
-		else
-			break;
-	}
-	// 7. Execute read operation.
-	PlatformIOWrite4Byte(dev, QPNR, Data);
-	// 8. Check if firmawre send back RF content.
-	while (PlatformIORead4Byte(dev, QPNR)&0x80000000)
-	{
-		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
-		if (time++ < 100)
-		{
-			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
-			delay_us(10);
-		}
-		else
-			return	(0);
-	}
-	retValue = PlatformIORead4Byte(dev, RF_DATA);
-#endif
-	return	(retValue);
-
-}	/* phy_FwRFSerialRead */
-
-/*-----------------------------------------------------------------------------
- * Function:	phy_FwRFSerialWrite()
- *
- * Overview:	We support firmware to execute RF-R/W.
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *	01/21/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-//use in phy only
-static	void
-phy_FwRFSerialWrite(
-	struct net_device* dev,
-	RF90_RADIO_PATH_E	eRFPath,
-	u32				Offset,
-	u32				Data	)
-{
-#if 0
-	u8	time = 0;
-	DbgPrint("N FW RF CTRL RF-%d OF%02x DATA=%03x\n\r", eRFPath, Offset, Data);
-	/* 2007/11/02 MH Firmware RF Write control. By Francis' suggestion, we can
-	   not execute the scheme in the initial step. Otherwise, RF-R/W will waste
-	   much time. This is only for site survey. */
-
-	// 1. Set driver write bit and 12 bit data. bit 0-11
-	//Data &= bMask12Bits;	// Done by uper layer.
-	// 2. Write RF register address. bit 12-19
-	Data |= ((Offset&0xFF)<<12);
-	// 3. Write RF path.  bit 20-21
-	Data |= ((eRFPath&0x3)<<20);
-	// 4. Set RF write indicator. bit 22=1
-	Data |= 0x400000;
-	// 5. Trigger Fw to operate the command. bit 31=1
-	Data |= 0x80000000;
-
-	// 6. Write operation. We can not write if bit 31 is 1.
-	while (PlatformIORead4Byte(dev, QPNR)&0x80000000)
-	{
-		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
-		if (time++ < 100)
-		{
-			//DbgPrint("FW not finish RF-W Time=%d\n\r", time);
-			delay_us(10);
-		}
-		else
-			break;
-	}
-	// 7. No matter check bit. We always force the write. Because FW will
-	//    not accept the command.
-	PlatformIOWrite4Byte(dev, QPNR, Data);
-	/* 2007/11/02 MH Acoording to test, we must delay 20us to wait firmware
-	   to finish RF write operation. */
-	/* 2008/01/17 MH We support delay in firmware side now. */
-	//delay_us(20);
-#endif
-}	/* phy_FwRFSerialWrite */
-
-/**
-* Function:	phy_RFSerialRead
-*
-* OverView:	Read regster from RF chips
-*
-* Input:
-*			PADAPTER		Adapter,
-*			RF90_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
-*			u32			Offset,		//The target address to be read
-*
-* Output:	None
-* Return:		u32			reback value
-* Note:		Threre are three types of serial operations:
-*			1. Software serial write
-*			2. Hardware LSSI-Low Speed Serial Interface
-*			3. Hardware HSSI-High speed
-*			serial write. Driver need to implement (1) and (2).
-*			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
-*/
-//use in phy only
-static u32 phy_RFSerialRead(struct net_device* dev,RF90_RADIO_PATH_E eRFPath,u32 Offset)
-{
-
-	u32						retValue = 0;
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	BB_REGISTER_DEFINITION_T	*pPhyReg = &priv->PHYRegDef[eRFPath];
-	u32						NewOffset;
-	u8						RfPiEnable=0;
-
-
-	//
-	// Make sure RF register offset is correct
-	//
-	Offset &= 0x3f;
-
-	//
-	// Switch page for 8256 RF IC
-	//
-	if(	priv->rf_chip == RF_8256 ||
-		priv->rf_chip == RF_8225 ||
-		priv->rf_chip == RF_6052)
-	{
-		//analog to digital off, for protection
-		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);// 0x88c[11:8]
-
-		if(Offset>=31)
-		{
-			priv->RFReadPageCnt[2]++;//cosa add for debug
-			priv->RfReg0Value[eRFPath] |= 0x140;
-
-			// Switch to Reg_Mode2 for Reg31~45
-			rtl8192_setBBreg(dev,
-				pPhyReg->rf3wireOffset,
-				bMaskDWord,
-				(priv->RfReg0Value[eRFPath] << 16)	);
-
-			// Modified Offset
-			NewOffset = Offset - 30;
-
-		}else if(Offset>=16)
-		{
-			priv->RFReadPageCnt[1]++;//cosa add for debug
-			priv->RfReg0Value[eRFPath] |= 0x100;
-			priv->RfReg0Value[eRFPath] &= (~0x40);
-
-			// Switch to Reg_Mode1 for Reg16~30
-			rtl8192_setBBreg(dev,
-				pPhyReg->rf3wireOffset,
-				bMaskDWord,
-				(priv->RfReg0Value[eRFPath] << 16)	);
-
-			// Modified Offset
-			NewOffset = Offset - 15;
-		}
-		else
-		{
-			priv->RFReadPageCnt[0]++;//cosa add for debug
-			NewOffset = Offset;
-	}
-	}
-	else
-		NewOffset = Offset;
-
-	//
-	// Put desired read address to LSSI control register
-	//
-	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress, NewOffset);
-
-	//
-	// Issue a posedge trigger
-	//
-	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x0);
-	rtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,  bLSSIReadEdge, 0x1);
-
-	// TODO: we should not delay such a  long time. Ask help from SD3
-	mdelay(1);
-
-	retValue = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);
-
-	// Switch back to Reg_Mode0;
-	if(	priv->rf_chip == RF_8256 ||
-		priv->rf_chip == RF_8225 ||
-		priv->rf_chip == RF_0222D)
-	{
-		if (Offset >= 0x10)
-		{
-			priv->RfReg0Value[eRFPath] &= 0xebf;
-
-			rtl8192_setBBreg(
-				dev,
-				pPhyReg->rf3wireOffset,
-				bMaskDWord,
-				(priv->RfReg0Value[eRFPath] << 16)	);
-		}
-
-		//analog to digital on
-		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0xf);// 0x88c[11:8]
-	}
-
-	return retValue;
-}
-
-
-
-/**
-* Function:	phy_RFSerialWrite
-*
-* OverView:	Write data to RF register (page 8~)
-*
-* Input:
-*			PADAPTER		Adapter,
-*			RF90_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
-*			u32			Offset,		//The target address to be read
-*			u32			Data			//The new register Data in the target bit position
-*										//of the target to be read
-*
-* Output:	None
-* Return:		None
-* Note:		Threre are three types of serial operations:
-*			1. Software serial write
-*			2. Hardware LSSI-Low Speed Serial Interface
-*			3. Hardware HSSI-High speed
-*			serial write. Driver need to implement (1) and (2).
-*			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
- *
- * Note: 		  For RF8256 only
- *			 The total count of RTL8256(Zebra4) register is around 36 bit it only employs
- *			 4-bit RF address. RTL8256 uses "register mode control bit" (Reg00[12], Reg00[10])
- *			 to access register address bigger than 0xf. See "Appendix-4 in PHY Configuration
- *			 programming guide" for more details.
- *			 Thus, we define a sub-finction for RTL8526 register address conversion
- *		       ===========================================================
- *			 Register Mode		RegCTL[1]		RegCTL[0]		Note
- *								(Reg00[12])		(Reg00[10])
- *		       ===========================================================
- *			 Reg_Mode0				0				x			Reg 0 ~15(0x0 ~ 0xf)
- *		       ------------------------------------------------------------------
- *			 Reg_Mode1				1				0			Reg 16 ~30(0x1 ~ 0xf)
- *		       ------------------------------------------------------------------
- *			 Reg_Mode2				1				1			Reg 31 ~ 45(0x1 ~ 0xf)
- *		       ------------------------------------------------------------------
-*/
-////use in phy only
-static void
-phy_RFSerialWrite(
-	struct net_device* dev,
-	RF90_RADIO_PATH_E	eRFPath,
-	u32				Offset,
-	u32				Data
-	)
-{
-	u32					DataAndAddr = 0;
-	struct r8192_priv 			*priv = ieee80211_priv(dev);
-	BB_REGISTER_DEFINITION_T	*pPhyReg = &priv->PHYRegDef[eRFPath];
-	u32					NewOffset;
-
-	Offset &= 0x3f;
-
-	// Shadow Update
-	PHY_RFShadowWrite(dev, eRFPath, Offset, Data);
-
-
-	// Switch page for 8256 RF IC
-	if( 	priv->rf_chip == RF_8256 ||
-		priv->rf_chip == RF_8225 ||
-		priv->rf_chip == RF_0222D)
-	{
-		//analog to digital off, for protection
-		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);// 0x88c[11:8]
-
-		if(Offset>=31)
-		{
-			priv->RFWritePageCnt[2]++;//cosa add for debug
-			priv->RfReg0Value[eRFPath] |= 0x140;
-
-			rtl8192_setBBreg(dev,
-				pPhyReg->rf3wireOffset,
-				bMaskDWord,
-				(priv->RfReg0Value[eRFPath] << 16)	);
-
-			NewOffset = Offset - 30;
-
-		}else if(Offset>=16)
-		{
-			priv->RFWritePageCnt[1]++;//cosa add for debug
-			priv->RfReg0Value[eRFPath] |= 0x100;
-			priv->RfReg0Value[eRFPath] &= (~0x40);
-
-
-			rtl8192_setBBreg(dev,
-				pPhyReg->rf3wireOffset,
-				bMaskDWord,
-				(priv->RfReg0Value[eRFPath] << 16)	);
-
-			NewOffset = Offset - 15;
-		}
-		else
-		{
-			priv->RFWritePageCnt[0]++;//cosa add for debug
-			NewOffset = Offset;
-	}
-	}
-	else
-		NewOffset = Offset;
-
-	//
-	// Put write addr in [5:0]  and write data in [31:16]
-	//
-	DataAndAddr = (Data<<16) | (NewOffset&0x3f);
-
-	//
-	// Write Operation
-	//
-	rtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);
-
-
-	if(Offset==0x0)
-		priv->RfReg0Value[eRFPath] = Data;
-
-	// Switch back to Reg_Mode0;
- 	if(	priv->rf_chip == RF_8256 ||
-		priv->rf_chip == RF_8225 ||
-		priv->rf_chip == RF_0222D)
-	{
-		if (Offset >= 0x10)
-		{
-			if(Offset != 0)
-			{
-				priv->RfReg0Value[eRFPath] &= 0xebf;
-				rtl8192_setBBreg(
-				dev,
-				pPhyReg->rf3wireOffset,
-				bMaskDWord,
-				(priv->RfReg0Value[eRFPath] << 16)	);
-			}
-		}
-		//analog to digital on
-		rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0xf);// 0x88c[11:8]
-	}
-
-}
-#else
 /**
 * Function:	phy_RFSerialRead
 *
@@ -1276,7 +870,6 @@ phy_RFSerialWrite(struct net_device* dev
 
 }
 #endif
-#endif
 
 /**
 * Function:	phy_CalculateBitShift
@@ -3376,9 +2969,7 @@ void rtl8192_SetBWMode(struct net_device
 #endif
 	if((priv->up) )// && !(RT_CANNOT_IO(Adapter) && Adapter->bInSetPower) )
 	{
-#ifdef RTL8192SE
-	PHY_SetBWModeCallback8192S(dev);
-#elif defined(RTL8192SU)
+#if   defined(RTL8192SU)
 	SetBWModeCallback8192SUsbWorkItem(dev);
 #endif
 	}
@@ -3495,9 +3086,7 @@ u8 rtl8192_phy_SwChnl(struct net_device*
 
 	if((priv->up))// && !(RT_CANNOT_IO(Adapter) && Adapter->bInSetPower))
 	{
-#ifdef RTL8192SE
-	PHY_SwChnlCallback8192S(dev);
-#elif defined(RTL8192SU)
+#if   defined(RTL8192SU)
 	SwChnlCallback8192SUsbWorkItem(dev);
 #endif
 #ifdef TO_DO_LIST
@@ -3750,7 +3339,7 @@ phy_SwChnlStepByStep(
 		case CmdID_RF_WriteReg:	// Only modify channel for the register now !!!!!
 			for(eRFPath = 0; eRFPath <priv->NumTotalRFPath; eRFPath++)
 			{
-#if (defined RTL8192SE ||defined RTL8192SU )
+#if defined RTL8192SU
 			// For new T65 RF 0222d register 0x18 bit 0-9 = channel number.
 				rtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, 0x1f, (CurrentCmd->Para2));
 				//printk("====>%x, %x, read_back:%x\n", CurrentCmd->Para2,CurrentCmd->Para1, rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, 0x1f));
