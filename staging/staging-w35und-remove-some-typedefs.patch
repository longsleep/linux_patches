From penberg@cs.helsinki.fi  Mon Oct 20 14:10:11 2008
From: Pekka J Enberg <penberg@cs.helsinki.fi>
Date: Tue, 21 Oct 2008 00:03:41 +0300 (EEST)
Subject: Staging: w35und: remove some typedefs
To: Greg Kroah-Hartman <greg@kroah.com>
Cc: Pavel Machek <pavel@suse.cz>, linux-kernel@vger.kernel.org
Message-ID: <Pine.LNX.4.64.0810210002370.24148@melkki.cs.Helsinki.FI>


From: Pekka Enberg <penberg@cs.helsinki.fi>

This patch removes some obfuscating typedefs from the driver code.

Cc: Pavel Machek <pavel@suse.cz>
Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/winbond/bss_f.h           |    6 ++---
 drivers/staging/winbond/ds_tkip.h         |    6 ++---
 drivers/staging/winbond/linux/common.h    |   10 ---------
 drivers/staging/winbond/linux/wb35reg.c   |   26 ++++++++++++------------
 drivers/staging/winbond/linux/wb35reg_f.h |   12 +++++------
 drivers/staging/winbond/linux/wb35reg_s.h |    2 -
 drivers/staging/winbond/linux/wb35rx.c    |   16 +++++++--------
 drivers/staging/winbond/linux/wb35rx_s.h  |    2 -
 drivers/staging/winbond/linux/wb35tx.c    |    8 +++----
 drivers/staging/winbond/linux/wb35tx_f.h  |    2 -
 drivers/staging/winbond/linux/wbusb.c     |    4 +--
 drivers/staging/winbond/mds.c             |   28 ++++++++++++++------------
 drivers/staging/winbond/mds_f.h           |    6 ++---
 drivers/staging/winbond/mds_s.h           |    8 +++----
 drivers/staging/winbond/mlme_s.h          |    2 -
 drivers/staging/winbond/mlmetxrx.c        |    4 +--
 drivers/staging/winbond/mlmetxrx_f.h      |    4 +--
 drivers/staging/winbond/reg.c             |   24 +++++++++++-----------
 drivers/staging/winbond/sme_api.h         |    2 -
 drivers/staging/winbond/wbhal.c           |   32 +++++++++++++++---------------
 drivers/staging/winbond/wbhal_f.h         |   28 +++++++++++++-------------
 drivers/staging/winbond/wbhal_s.h         |    4 +--
 drivers/staging/winbond/wblinux.c         |    7 +++---
 23 files changed, 119 insertions(+), 124 deletions(-)

--- a/drivers/staging/winbond/bss_f.h
+++ b/drivers/staging/winbond/bss_f.h
@@ -24,7 +24,7 @@ void DesiredRate2InfoElement(PWB32_ADAPT
 							 u8 *pBasicRateSet, u8 BasicRateCount,
 							 u8 *pOperationRateSet, u8 OperationRateCount);
 void BSSAddIBSSdata(PWB32_ADAPTER Adapter, PWB_BSSDESCRIPTION psDesData);
-unsigned char boCmpMacAddr( PUCHAR, PUCHAR );
+unsigned char boCmpMacAddr( u8 *, u8 *);
 unsigned char boCmpSSID(struct SSID_Element *psSSID1, struct SSID_Element *psSSID2);
 u16 wBSSfindSSID(PWB32_ADAPTER Adapter, struct SSID_Element *psSsid);
 u16 wRoamingQuery(PWB32_ADAPTER Adapter);
@@ -42,11 +42,11 @@ void RateReSortForSRate(PWB32_ADAPTER Ad
 void Assemble_IE(PWB32_ADAPTER Adapter, u16 wBssIdx);
 void SetMaxTxRate(PWB32_ADAPTER Adapter);
 
-void CreateWpaIE(PWB32_ADAPTER Adapter, u16* iFildOffset, PUCHAR msg, struct  Management_Frame* msgHeader,
+void CreateWpaIE(PWB32_ADAPTER Adapter, u16* iFildOffset, u8 *msg, struct  Management_Frame* msgHeader,
 				 struct Association_Request_Frame_Body* msgBody, u16 iMSindex); //added by WS 05/14/05
 
 #ifdef _WPA2_
-void CreateRsnIE(PWB32_ADAPTER Adapter, u16* iFildOffset, PUCHAR msg, struct  Management_Frame* msgHeader,
+void CreateRsnIE(PWB32_ADAPTER Adapter, u16* iFildOffset, u8 *msg, struct  Management_Frame* msgHeader,
 				 struct Association_Request_Frame_Body* msgBody, u16 iMSindex);//added by WS 05/14/05
 
 u16 SearchPmkid(PWB32_ADAPTER Adapter, struct  Management_Frame* msgHeader,
--- a/drivers/staging/winbond/ds_tkip.h
+++ b/drivers/staging/winbond/ds_tkip.h
@@ -25,9 +25,9 @@ typedef struct tkip
 	s32		bytes_in_M;	// # bytes in M
 } tkip_t;
 
-//void _append_data( PUCHAR pData, u16 size, tkip_t *p );
-void Mds_MicGet(  void* Adapter,  void* pRxLayer1,  PUCHAR pKey,  PUCHAR pMic );
-void Mds_MicFill(  void* Adapter,  void* pDes,  PUCHAR XmitBufAddress );
+//void _append_data( u8 *pData, u16 size, tkip_t *p );
+void Mds_MicGet(  void* Adapter,  void* pRxLayer1,  u8 *pKey,  u8 *pMic );
+void Mds_MicFill(  void* Adapter,  void* pDes,  u8 *XmitBufAddress );
 
 
 
--- a/drivers/staging/winbond/linux/common.h
+++ b/drivers/staging/winbond/linux/common.h
@@ -39,14 +39,6 @@
 // Common type definition
 //===============================================================
 
-typedef u8*            PUCHAR;
-typedef s8*            PCHAR;
-typedef u8*            PBOOLEAN;
-typedef u16*           PUSHORT;
-typedef u32*           PULONG;
-typedef s16*   PSHORT;
-
-
 //===========================================
 #define IGNORE      2
 #define	SUCCESS     1
@@ -110,7 +102,7 @@ typedef struct urb * PURB;
 #define OS_ATOMIC_READ( _A, _V )	_V
 #define OS_ATOMIC_INC( _A, _V )		EncapAtomicInc( _A, (void*)_V )
 #define OS_ATOMIC_DEC( _A, _V )		EncapAtomicDec( _A, (void*)_V )
-#define OS_MEMORY_CLEAR( _A, _S )	memset( (PUCHAR)_A,0,_S)
+#define OS_MEMORY_CLEAR( _A, _S )	memset( (u8 *)_A,0,_S)
 #define OS_MEMORY_COMPARE( _A, _B, _S )	(memcmp(_A,_B,_S)? 0 : 1) // Definition is reverse with Ndis 1: the same 0: different
 
 
--- a/drivers/staging/winbond/linux/wb35reg.c
+++ b/drivers/staging/winbond/linux/wb35reg.c
@@ -10,7 +10,7 @@ extern void phy_calibration_winbond(hw_d
 // Flag : AUTO_INCREMENT - RegisterNo will auto increment 4
 //		  NO_INCREMENT - Function will write data into the same register
 unsigned char
-Wb35Reg_BurstWrite(phw_data_t pHwData, u16 RegisterNo, PULONG pRegisterData, u8 NumberOfData, u8 Flag)
+Wb35Reg_BurstWrite(phw_data_t pHwData, u16 RegisterNo, u32 * pRegisterData, u8 NumberOfData, u8 Flag)
 {
 	PWB35REG pWb35Reg = &pHwData->Wb35Reg;
 	PURB		pUrb = NULL;
@@ -30,13 +30,13 @@ Wb35Reg_BurstWrite(phw_data_t pHwData, u
 	if( pUrb && pRegQueue ) {
 		pRegQueue->DIRECT = 2;// burst write register
 		pRegQueue->INDEX = RegisterNo;
-		pRegQueue->pBuffer = (PULONG)((PUCHAR)pRegQueue + sizeof(REG_QUEUE));
+		pRegQueue->pBuffer = (u32 *)((u8 *)pRegQueue + sizeof(REG_QUEUE));
 		memcpy( pRegQueue->pBuffer, pRegisterData, DataSize );
 		//the function for reversing register data from little endian to big endian
 		for( i=0; i<NumberOfData ; i++ )
 			pRegQueue->pBuffer[i] = cpu_to_le32( pRegQueue->pBuffer[i] );
 
-		dr = (struct usb_ctrlrequest *)((PUCHAR)pRegQueue + sizeof(REG_QUEUE) + DataSize);
+		dr = (struct usb_ctrlrequest *)((u8 *)pRegQueue + sizeof(REG_QUEUE) + DataSize);
 		dr->bRequestType = USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE;
 		dr->bRequest = 0x04; // USB or vendor-defined request code, burst mode
 		dr->wValue = cpu_to_le16( Flag ); // 0: Register number auto-increment, 1: No auto increment
@@ -181,7 +181,7 @@ Wb35Reg_Write(  phw_data_t pHwData,  u16
 		pRegQueue->INDEX = RegisterNo;
 		pRegQueue->VALUE = cpu_to_le32(RegisterValue);
 		pRegQueue->RESERVED_VALID = FALSE;
-		dr = (struct usb_ctrlrequest *)((PUCHAR)pRegQueue + sizeof(REG_QUEUE));
+		dr = (struct usb_ctrlrequest *)((u8 *)pRegQueue + sizeof(REG_QUEUE));
 		dr->bRequestType = USB_TYPE_VENDOR|USB_DIR_OUT |USB_RECIP_DEVICE;
 		dr->bRequest = 0x03; // USB or vendor-defined request code, burst mode
 		dr->wValue = cpu_to_le16(0x0);
@@ -220,7 +220,7 @@ Wb35Reg_Write(  phw_data_t pHwData,  u16
 // FALSE : register not support
 unsigned char
 Wb35Reg_WriteWithCallbackValue( phw_data_t pHwData, u16 RegisterNo, u32 RegisterValue,
-				PCHAR pValue, s8 Len)
+				s8 *pValue, s8 Len)
 {
 	PWB35REG	pWb35Reg = &pHwData->Wb35Reg;
 	struct usb_ctrlrequest *dr;
@@ -243,7 +243,7 @@ Wb35Reg_WriteWithCallbackValue( phw_data
 		//NOTE : Users must guarantee the size of value will not exceed the buffer size.
 		memcpy(pRegQueue->RESERVED, pValue, Len);
 		pRegQueue->RESERVED_VALID = TRUE;
-		dr = (struct usb_ctrlrequest *)((PUCHAR)pRegQueue + sizeof(REG_QUEUE));
+		dr = (struct usb_ctrlrequest *)((u8 *)pRegQueue + sizeof(REG_QUEUE));
 		dr->bRequestType = USB_TYPE_VENDOR|USB_DIR_OUT |USB_RECIP_DEVICE;
 		dr->bRequest = 0x03; // USB or vendor-defined request code, burst mode
 		dr->wValue = cpu_to_le16(0x0);
@@ -278,10 +278,10 @@ Wb35Reg_WriteWithCallbackValue( phw_data
 // FALSE : register not support
 // pRegisterValue : It must be a resident buffer due to asynchronous read register.
 unsigned char
-Wb35Reg_ReadSync(  phw_data_t pHwData,  u16 RegisterNo,   PULONG pRegisterValue )
+Wb35Reg_ReadSync(  phw_data_t pHwData,  u16 RegisterNo,   u32 * pRegisterValue )
 {
 	PWB35REG pWb35Reg = &pHwData->Wb35Reg;
-	PULONG	pltmp = pRegisterValue;
+	u32 *	pltmp = pRegisterValue;
 	int ret = -1;
 
 	// Module shutdown
@@ -327,7 +327,7 @@ Wb35Reg_ReadSync(  phw_data_t pHwData,  
 // FALSE : register not support
 // pRegisterValue : It must be a resident buffer due to asynchronous read register.
 unsigned char
-Wb35Reg_Read(phw_data_t pHwData, u16 RegisterNo,  PULONG pRegisterValue )
+Wb35Reg_Read(phw_data_t pHwData, u16 RegisterNo,  u32 * pRegisterValue )
 {
 	PWB35REG	pWb35Reg = &pHwData->Wb35Reg;
 	struct usb_ctrlrequest * dr;
@@ -348,7 +348,7 @@ Wb35Reg_Read(phw_data_t pHwData, u16 Reg
 		pRegQueue->DIRECT = 0;// read register
 		pRegQueue->INDEX = RegisterNo;
 		pRegQueue->pBuffer = pRegisterValue;
-		dr = (struct usb_ctrlrequest *)((PUCHAR)pRegQueue + sizeof(REG_QUEUE));
+		dr = (struct usb_ctrlrequest *)((u8 *)pRegQueue + sizeof(REG_QUEUE));
 		dr->bRequestType = USB_TYPE_VENDOR|USB_RECIP_DEVICE|USB_DIR_IN;
 		dr->bRequest = 0x01; // USB or vendor-defined request code, burst mode
 		dr->wValue = cpu_to_le16(0x0);
@@ -399,7 +399,7 @@ Wb35Reg_EP0VM(phw_data_t pHwData )
 	PWB35REG	pWb35Reg = &pHwData->Wb35Reg;
 	PURB		pUrb;
 	struct usb_ctrlrequest *dr;
-	PULONG		pBuffer;
+	u32 *		pBuffer;
 	int			ret = -1;
 	PREG_QUEUE	pRegQueue;
 
@@ -429,7 +429,7 @@ Wb35Reg_EP0VM(phw_data_t pHwData )
 
 	usb_fill_control_urb( pUrb, pHwData->WbUsb.udev,
 			      REG_DIRECTION(pHwData->WbUsb.udev,pRegQueue),
-			      (PUCHAR)dr,pBuffer,cpu_to_le16(dr->wLength),
+			      (u8 *)dr,pBuffer,cpu_to_le16(dr->wLength),
 			      Wb35Reg_EP0VM_complete, (void*)pHwData);
 
 	pWb35Reg->EP0vm_state = VM_RUNNING;
@@ -655,7 +655,7 @@ unsigned char Wb35Reg_initial(phw_data_t
 //    version in _GENREQ.ASM of the DWB NE1000/2000 driver.
 //==================================================================================
 u32
-CardComputeCrc(PUCHAR Buffer, u32 Length)
+CardComputeCrc(u8 * Buffer, u32 Length)
 {
     u32 Crc, Carry;
     u32  i, j;
--- a/drivers/staging/winbond/linux/wb35reg_f.h
+++ b/drivers/staging/winbond/linux/wb35reg_f.h
@@ -29,16 +29,16 @@ void EEPROMTxVgaAdjust(  phw_data_t pHwD
 
 void Wb35Reg_destroy(  phw_data_t pHwData );
 
-unsigned char Wb35Reg_Read(  phw_data_t pHwData,  u16 RegisterNo,   PULONG pRegisterValue );
-unsigned char Wb35Reg_ReadSync(  phw_data_t pHwData,  u16 RegisterNo,   PULONG pRegisterValue );
+unsigned char Wb35Reg_Read(  phw_data_t pHwData,  u16 RegisterNo,   u32 * pRegisterValue );
+unsigned char Wb35Reg_ReadSync(  phw_data_t pHwData,  u16 RegisterNo,   u32 * pRegisterValue );
 unsigned char Wb35Reg_Write(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue );
 unsigned char Wb35Reg_WriteSync(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue );
 unsigned char Wb35Reg_WriteWithCallbackValue(  phw_data_t pHwData,
 								 u16 RegisterNo,
 								 u32 RegisterValue,
-								 PCHAR pValue,
-								 s8	Len);
-unsigned char Wb35Reg_BurstWrite(  phw_data_t pHwData,  u16 RegisterNo,  PULONG pRegisterData,  u8 NumberOfData,  u8 Flag );
+								 s8 *pValue,
+								 s8 Len);
+unsigned char Wb35Reg_BurstWrite(  phw_data_t pHwData,  u16 RegisterNo,  u32 * pRegisterData,  u8 NumberOfData,  u8 Flag );
 
 void Wb35Reg_EP0VM(  phw_data_t pHwData );
 void Wb35Reg_EP0VM_start(  phw_data_t pHwData );
@@ -47,7 +47,7 @@ void Wb35Reg_EP0VM_complete(  PURB pUrb 
 u32 BitReverse( u32 dwData, u32 DataLength);
 
 void CardGetMulticastBit(   u8 Address[MAC_ADDR_LENGTH],  u8 *Byte,  u8 *Value );
-u32 CardComputeCrc(  PUCHAR Buffer,  u32 Length );
+u32 CardComputeCrc(  u8 * Buffer,  u32 Length );
 
 void Wb35Reg_phy_calibration(  phw_data_t pHwData );
 void Wb35Reg_Update(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue );
--- a/drivers/staging/winbond/linux/wb35reg_s.h
+++ b/drivers/staging/winbond/linux/wb35reg_s.h
@@ -75,7 +75,7 @@ typedef struct _REG_QUEUE
 	union
 	{
 		u32	VALUE;
-		PULONG	pBuffer;
+		u32 *	pBuffer;
 	};
 	u8	RESERVED[4];// space reserved for communication
 
--- a/drivers/staging/winbond/linux/wb35rx.c
+++ b/drivers/staging/winbond/linux/wb35rx.c
@@ -27,7 +27,7 @@ void Wb35Rx_start(phw_data_t pHwData)
 void Wb35Rx(  phw_data_t pHwData )
 {
 	PWB35RX	pWb35Rx = &pHwData->Wb35Rx;
-	PUCHAR	pRxBufferAddress;
+	u8 *	pRxBufferAddress;
 	PURB	pUrb = (PURB)pWb35Rx->RxUrb;
 	int	retv;
 	u32	RxBufferId;
@@ -89,7 +89,7 @@ void Wb35Rx_Complete(PURB pUrb)
 {
 	phw_data_t	pHwData = pUrb->context;
 	PWB35RX		pWb35Rx = &pHwData->Wb35Rx;
-	PUCHAR		pRxBufferAddress;
+	u8 *		pRxBufferAddress;
 	u32		SizeCheck;
 	u16		BulkLength;
 	u32		RxBufferId;
@@ -116,7 +116,7 @@ void Wb35Rx_Complete(PURB pUrb)
 
 		// Start to process the data only in successful condition
 		pWb35Rx->RxOwner[ RxBufferId ] = 0; // Set the owner to driver
-		R00.value = le32_to_cpu(*(PULONG)pRxBufferAddress);
+		R00.value = le32_to_cpu(*(u32 *)pRxBufferAddress);
 
 		// The URB is completed, check the result
 		if (pWb35Rx->EP3VM_status != 0) {
@@ -223,7 +223,7 @@ void Wb35Rx_reset_descriptor(  phw_data_
 
 void Wb35Rx_adjust(PDESCRIPTOR pRxDes)
 {
-	PULONG	pRxBufferAddress;
+	u32 *	pRxBufferAddress;
 	u32	DecryptionMethod;
 	u32	i;
 	u16	BufferSize;
@@ -264,7 +264,7 @@ u16 Wb35Rx_indicate(phw_data_t pHwData)
 {
 	DESCRIPTOR	RxDes;
 	PWB35RX	pWb35Rx = &pHwData->Wb35Rx;
-	PUCHAR		pRxBufferAddress;
+	u8 *		pRxBufferAddress;
 	u16		PacketSize;
 	u16		stmp, BufferSize, stmp2 = 0;
 	u32		RxBufferId;
@@ -283,13 +283,13 @@ u16 Wb35Rx_indicate(phw_data_t pHwData)
 
 		// Parse the bulkin buffer
 		while (BufferSize >= 4) {
-			if ((cpu_to_le32(*(PULONG)pRxBufferAddress) & 0x0fffffff) == RX_END_TAG) //Is ending? 921002.9.a
+			if ((cpu_to_le32(*(u32 *)pRxBufferAddress) & 0x0fffffff) == RX_END_TAG) //Is ending? 921002.9.a
 				break;
 
 			// Get the R00 R01 first
-			RxDes.R00.value = le32_to_cpu(*(PULONG)pRxBufferAddress);
+			RxDes.R00.value = le32_to_cpu(*(u32 *)pRxBufferAddress);
 			PacketSize = (u16)RxDes.R00.R00_receive_byte_count;
-			RxDes.R01.value = le32_to_cpu(*((PULONG)(pRxBufferAddress+4)));
+			RxDes.R01.value = le32_to_cpu(*((u32 *)(pRxBufferAddress+4)));
 			// For new DMA 4k
 			if ((PacketSize & 0x03) > 0)
 				PacketSize -= 4;
--- a/drivers/staging/winbond/linux/wb35rx_s.h
+++ b/drivers/staging/winbond/linux/wb35rx_s.h
@@ -41,7 +41,7 @@ typedef struct _WB35RX
 	u32		Ep3ErrorCount2; // 20060625.1 Usbd for Rx DMA error count
 
 	int		EP3VM_status;
-	PUCHAR	pDRx;
+	u8 *	pDRx;
 
 } WB35RX, *PWB35RX;
 
--- a/drivers/staging/winbond/linux/wb35tx.c
+++ b/drivers/staging/winbond/linux/wb35tx.c
@@ -12,7 +12,7 @@
 
 
 unsigned char
-Wb35Tx_get_tx_buffer(phw_data_t pHwData, PUCHAR *pBuffer )
+Wb35Tx_get_tx_buffer(phw_data_t pHwData, u8 **pBuffer)
 {
 	PWB35TX pWb35Tx = &pHwData->Wb35Tx;
 
@@ -37,7 +37,7 @@ void Wb35Tx(phw_data_t pHwData)
 {
 	PWB35TX		pWb35Tx = &pHwData->Wb35Tx;
 	PADAPTER	Adapter = pHwData->Adapter;
-	PUCHAR		pTxBufferAddress;
+	u8		*pTxBufferAddress;
 	PMDS		pMds = &Adapter->Mds;
 	struct urb *	pUrb = (struct urb *)pWb35Tx->Tx4Urb;
 	int         	retv;
@@ -225,7 +225,7 @@ void Wb35Tx_EP2VM(phw_data_t pHwData)
 {
 	PWB35TX pWb35Tx = &pHwData->Wb35Tx;
 	struct urb *	pUrb = (struct urb *)pWb35Tx->Tx2Urb;
-	PULONG	pltmp = (PULONG)pWb35Tx->EP2_buf;
+	u32 *	pltmp = (u32 *)pWb35Tx->EP2_buf;
 	int		retv;
 
 	do {
@@ -266,7 +266,7 @@ void Wb35Tx_EP2VM_complete(struct urb * 
 	T02_DESCRIPTOR	T02, TSTATUS;
 	PADAPTER	Adapter = (PADAPTER)pHwData->Adapter;
 	PWB35TX		pWb35Tx = &pHwData->Wb35Tx;
-	PULONG		pltmp = (PULONG)pWb35Tx->EP2_buf;
+	u32 *		pltmp = (u32 *)pWb35Tx->EP2_buf;
 	u32		i;
 	u16		InterruptInLength;
 
--- a/drivers/staging/winbond/linux/wb35tx_f.h
+++ b/drivers/staging/winbond/linux/wb35tx_f.h
@@ -3,7 +3,7 @@
 //====================================
 unsigned char Wb35Tx_initial(	 phw_data_t pHwData );
 void Wb35Tx_destroy(  phw_data_t pHwData );
-unsigned char Wb35Tx_get_tx_buffer(  phw_data_t pHwData,  PUCHAR *pBuffer );
+unsigned char Wb35Tx_get_tx_buffer(  phw_data_t pHwData,  u8 **pBuffer );
 
 void Wb35Tx_EP2VM(  phw_data_t pHwData );
 void Wb35Tx_EP2VM_start(  phw_data_t pHwData );
--- a/drivers/staging/winbond/linux/wbusb.c
+++ b/drivers/staging/winbond/linux/wbusb.c
@@ -136,7 +136,7 @@ static int wbsoft_config(struct ieee8021
 	hal_set_current_channel(&my_adapter->sHwData, ch);
 	hal_set_beacon_period(&my_adapter->sHwData, conf->beacon_int);
 //	hal_set_cap_info(&my_adapter->sHwData, ?? );
-// hal_set_ssid(phw_data_t pHwData,  PUCHAR pssid,  u8 ssid_len); ??
+// hal_set_ssid(phw_data_t pHwData,  u8 * pssid,  u8 ssid_len); ??
 	hal_set_accept_broadcast(&my_adapter->sHwData, 1);
 	hal_set_accept_promiscuous(&my_adapter->sHwData,  1);
 	hal_set_accept_multicast(&my_adapter->sHwData,  1);
@@ -148,7 +148,7 @@ static int wbsoft_config(struct ieee8021
 
 //	hal_start_bss(&my_adapter->sHwData, WLAN_BSSTYPE_INFRASTRUCTURE);	??
 
-//void hal_set_rates(phw_data_t pHwData, PUCHAR pbss_rates,
+//void hal_set_rates(phw_data_t pHwData, u8 * pbss_rates,
 //		   u8 length, unsigned char basic_rate_set)
 
 	return 0;
--- a/drivers/staging/winbond/mds.c
+++ b/drivers/staging/winbond/mds.c
@@ -40,7 +40,7 @@ Mds_Tx(PADAPTER Adapter)
 	PMDS		pMds = &Adapter->Mds;
 	DESCRIPTOR	TxDes;
 	PDESCRIPTOR	pTxDes = &TxDes;
-	PUCHAR		XmitBufAddress;
+	u8		*XmitBufAddress;
 	u16		XmitBufSize, PacketSize, stmp, CurrentSize, FragmentThreshold;
 	u8		FillIndex, TxDesIndex, FragmentCount, FillCount;
 	unsigned char	BufferFilled = FALSE, MICAdd = 0;
@@ -90,7 +90,7 @@ Mds_Tx(PADAPTER Adapter)
 			BufferFilled = TRUE;
 
 			/* Leaves first u8 intact */
-			memset((PUCHAR)pTxDes + 1, 0, sizeof(DESCRIPTOR) - 1);
+			memset((u8 *)pTxDes + 1, 0, sizeof(DESCRIPTOR) - 1);
 
 			TxDesIndex = pMds->TxDesIndex;//Get the current ID
 			pTxDes->Descriptor_ID = TxDesIndex;
@@ -229,10 +229,10 @@ Mds_SendComplete(PADAPTER Adapter, PT02_
 }
 
 void
-Mds_HeaderCopy(PADAPTER Adapter, PDESCRIPTOR pDes, PUCHAR TargetBuffer)
+Mds_HeaderCopy(PADAPTER Adapter, PDESCRIPTOR pDes, u8 *TargetBuffer)
 {
 	PMDS	pMds = &Adapter->Mds;
-	PUCHAR	src_buffer = pDes->buffer_address[0];//931130.5.g
+	u8	*src_buffer = pDes->buffer_address[0];//931130.5.g
 	PT00_DESCRIPTOR	pT00;
 	PT01_DESCRIPTOR	pT01;
 	u16	stmp;
@@ -276,7 +276,7 @@ Mds_HeaderCopy(PADAPTER Adapter, PDESCRI
 	//
 	// Set tx rate
 	//
-	stmp = *(PUSHORT)(TargetBuffer+30); // 2n alignment address
+	stmp = *(u16 *)(TargetBuffer+30); // 2n alignment address
 
 	//Use basic rate
 	ctmp1 = ctmpf = CURRENT_TX_RATE_FOR_MNG;
@@ -326,11 +326,13 @@ Mds_HeaderCopy(PADAPTER Adapter, PDESCRI
 
 // The function return the 4n size of usb pk
 u16
-Mds_BodyCopy(PADAPTER Adapter, PDESCRIPTOR pDes, PUCHAR TargetBuffer)
+Mds_BodyCopy(PADAPTER Adapter, PDESCRIPTOR pDes, u8 *TargetBuffer)
 {
 	PT00_DESCRIPTOR	pT00;
 	PMDS	pMds = &Adapter->Mds;
-	PUCHAR	buffer, src_buffer, pctmp;
+	u8	*buffer;
+	u8	*src_buffer;
+	u8	*pctmp;
 	u16	Size = 0;
 	u16	SizeLeft, CopySize, CopyLeft, stmp;
 	u8	buf_index, FragmentCount = 0;
@@ -354,7 +356,7 @@ Mds_BodyCopy(PADAPTER Adapter, PDESCRIPT
 		SizeLeft -= CopySize;
 
 		// 1 Byte operation
-		pctmp = (PUCHAR)( buffer + 8 + DOT_11_SEQUENCE_OFFSET );
+		pctmp = (u8 *)( buffer + 8 + DOT_11_SEQUENCE_OFFSET );
 		*pctmp &= 0xf0;
 		*pctmp |= FragmentCount;//931130.5.m
 		if( !FragmentCount )
@@ -379,7 +381,7 @@ Mds_BodyCopy(PADAPTER Adapter, PDESCRIPT
 				buf_index++;
 				buf_index %= MAX_DESCRIPTOR_BUFFER_INDEX;
 			} else {
-				PUCHAR	pctmp = pDes->buffer_address[buf_index];
+				u8	*pctmp = pDes->buffer_address[buf_index];
 				pctmp += CopySize;
 				pDes->buffer_address[buf_index] = pctmp;
 				pDes->buffer_size[buf_index] -= CopySize;
@@ -419,7 +421,7 @@ Mds_BodyCopy(PADAPTER Adapter, PDESCRIPT
 
 	pT00->T00_last_mpdu = 1;
 	pT00->T00_IsLastMpdu = 1;
-	buffer = (PUCHAR)pT00 + 8; // +8 for USB hdr
+	buffer = (u8 *)pT00 + 8; // +8 for USB hdr
 	buffer[1] &= ~0x04; // Clear more frag bit of 802.11 frame control
 	pDes->FragmentCount = FragmentCount; // Update the correct fragment number
 	return Size;
@@ -427,7 +429,7 @@ Mds_BodyCopy(PADAPTER Adapter, PDESCRIPT
 
 
 void
-Mds_DurationSet(  PADAPTER Adapter,  PDESCRIPTOR pDes,  PUCHAR buffer )
+Mds_DurationSet(  PADAPTER Adapter,  PDESCRIPTOR pDes,  u8 *buffer )
 {
 	PT00_DESCRIPTOR	pT00;
 	PT01_DESCRIPTOR	pT01;
@@ -574,7 +576,7 @@ Mds_DurationSet(  PADAPTER Adapter,  PDE
 							DEFAULT_SIFSTIME*3 );
 			}
 
-			((PUSHORT)buffer)[5] = cpu_to_le16(Duration);// 4 USHOR for skip 8B USB, 2USHORT=FC + Duration
+			((u16 *)buffer)[5] = cpu_to_le16(Duration);// 4 USHOR for skip 8B USB, 2USHORT=FC + Duration
 
 			//----20061009 add by anson's endian
 			pNextT00->value = cpu_to_le32(pNextT00->value);
@@ -615,7 +617,7 @@ Mds_DurationSet(  PADAPTER Adapter,  PDE
 		}
 	}
 
-	((PUSHORT)buffer)[5] = cpu_to_le16(Duration);// 4 USHOR for skip 8B USB, 2USHORT=FC + Duration
+	((u16 *)buffer)[5] = cpu_to_le16(Duration);// 4 USHOR for skip 8B USB, 2USHORT=FC + Duration
 	pT00->value = cpu_to_le32(pT00->value);
 	pT01->value = cpu_to_le32(pT01->value);
 	//--end 20061009 add
--- a/drivers/staging/winbond/mds_f.h
+++ b/drivers/staging/winbond/mds_f.h
@@ -1,9 +1,9 @@
 unsigned char Mds_initial(  PADAPTER Adapter );
 void Mds_Destroy(  PADAPTER Adapter );
 void Mds_Tx(  PADAPTER Adapter );
-void Mds_HeaderCopy(  PADAPTER Adapter,  PDESCRIPTOR pDes,  PUCHAR TargetBuffer );
-u16 Mds_BodyCopy(  PADAPTER Adapter,  PDESCRIPTOR pDes,  PUCHAR TargetBuffer );
-void Mds_DurationSet(  PADAPTER Adapter,  PDESCRIPTOR pDes,  PUCHAR TargetBuffer );
+void Mds_HeaderCopy(  PADAPTER Adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
+u16 Mds_BodyCopy(  PADAPTER Adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
+void Mds_DurationSet(  PADAPTER Adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
 void Mds_SendComplete(  PADAPTER Adapter,  PT02_DESCRIPTOR pT02 );
 void Mds_MpduProcess(  PADAPTER Adapter,  PDESCRIPTOR pRxDes );
 void Mds_reset_descriptor(  PADAPTER Adapter );
--- a/drivers/staging/winbond/mds_s.h
+++ b/drivers/staging/winbond/mds_s.h
@@ -86,7 +86,7 @@ typedef struct _MDS
 {
 	// For Tx usage
 	u8	TxOwner[ ((MAX_USB_TX_BUFFER_NUMBER + 3) & ~0x03) ];
-	PUCHAR	pTxBuffer;
+	u8	*pTxBuffer;
 	u16	TxBufferSize[ ((MAX_USB_TX_BUFFER_NUMBER + 1) & ~0x01) ];
 	u8	TxDesFrom[ ((MAX_USB_TX_DESCRIPTOR + 3) & ~0x03) ];//931130.4.u // 1: MLME 2: NDIS control 3: NDIS data
 	u8	TxCountInBuffer[ ((MAX_USB_TX_DESCRIPTOR + 3) & ~0x03) ]; // 20060928
@@ -103,7 +103,7 @@ typedef struct _MDS
 	u16	TxResult[ ((MAX_USB_TX_DESCRIPTOR + 1) & ~0x01) ];//Collect the sending result of Mpdu
 
 	u8	MicRedundant[8]; // For tmp use
-	PUCHAR	MicWriteAddress[2]; //The start address to fill the Mic, use 2 point due to Mic maybe fragment
+	u8	*MicWriteAddress[2]; //The start address to fill the Mic, use 2 point due to Mic maybe fragment
 
 	u16	MicWriteSize[2]; //931130.4.x
 
@@ -144,7 +144,7 @@ typedef struct _MDS
 
 typedef struct _RxBuffer
 {
-    PUCHAR  pBufferAddress;     // Pointer the received data buffer.
+    u8 * pBufferAddress;     // Pointer the received data buffer.
 	u16	BufferSize;
 	u8	RESERVED;
 	u8	BufferIndex;// Only 1 byte
@@ -176,7 +176,7 @@ typedef struct _RXLAYER1
 	/////////////////////////////////////////////////////////////////////////////////////////////
 	// For brand-new Rx system
 	u8	ReservedBuffer[ 2400 ];//If Buffer ID is reserved one, it must copy the data into this area
-	PUCHAR	ReservedBufferPoint;// Point to the next availabe address of reserved buffer
+	u8	*ReservedBufferPoint;// Point to the next availabe address of reserved buffer
 
 }RXLAYER1, * PRXLAYER1;
 
--- a/drivers/staging/winbond/mlme_s.h
+++ b/drivers/staging/winbond/mlme_s.h
@@ -125,7 +125,7 @@
 typedef struct _MLME_FRAME
 {
 	//NDIS_PACKET		MLME_Packet;
-	PCHAR			pMMPDU;
+	s8 *			pMMPDU;
 	u16			len;
 	u8			DataType;
 	u8			IsInUsed;
--- a/drivers/staging/winbond/mlmetxrx.c
+++ b/drivers/staging/winbond/mlmetxrx.c
@@ -113,13 +113,13 @@ MLME_GetNextPacket(PADAPTER Adapter, PDE
 	pDes->Type = Adapter->sMlmeFrame.DataType;
 }
 
-void MLMEfreeMMPDUBuffer(PWB32_ADAPTER Adapter, PCHAR pData)
+void MLMEfreeMMPDUBuffer(PWB32_ADAPTER Adapter, s8 *pData)
 {
 	int i;
 
 	// Reclaim the data buffer
 	for (i = 0; i < MAX_NUM_TX_MMPDU; i++) {
-		if (pData == (PCHAR)&(Adapter->sMlmeFrame.TxMMPDU[i]))
+		if (pData == (s8 *)&(Adapter->sMlmeFrame.TxMMPDU[i]))
 			break;
 	}
 	if (Adapter->sMlmeFrame.TxMMPDUInUse[i])
--- a/drivers/staging/winbond/mlmetxrx_f.h
+++ b/drivers/staging/winbond/mlmetxrx_f.h
@@ -20,7 +20,7 @@ MLMEGetMMPDUBuffer(
      PWB32_ADAPTER    Adapter
    );
 
-void MLMEfreeMMPDUBuffer( PWB32_ADAPTER Adapter,  PCHAR pData);
+void MLMEfreeMMPDUBuffer( PWB32_ADAPTER Adapter,  s8 * pData);
 
 void MLME_GetNextPacket(  PADAPTER Adapter,  PDESCRIPTOR pDes );
 u8 MLMESendFrame( PWB32_ADAPTER Adapter,
@@ -42,7 +42,7 @@ MLMERcvFrame(
 void
 MLMEReturnPacket(
      PWB32_ADAPTER    Adapter,
-     PUCHAR           pRxBufer
+     u8 *          pRxBufer
    );
 #ifdef _IBSS_BEACON_SEQ_STICK_
 s8 SendBCNullData(PWB32_ADAPTER Adapter, u16 wIdx);
--- a/drivers/staging/winbond/reg.c
+++ b/drivers/staging/winbond/reg.c
@@ -922,16 +922,16 @@ Uxx_ReadEthernetAddress(  phw_data_t pHw
 	// Only unplug and plug again can make hardware read EEPROM again. 20060727
 	Wb35Reg_WriteSync( pHwData, 0x03b4, 0x08000000 ); // Start EEPROM access + Read + address(0x0d)
 	Wb35Reg_ReadSync( pHwData, 0x03b4, &ltmp );
-	*(PUSHORT)pHwData->PermanentMacAddress = cpu_to_le16((u16)ltmp); //20060926 anson's endian
+	*(u16 *)pHwData->PermanentMacAddress = cpu_to_le16((u16)ltmp); //20060926 anson's endian
 	Wb35Reg_WriteSync( pHwData, 0x03b4, 0x08010000 ); // Start EEPROM access + Read + address(0x0d)
 	Wb35Reg_ReadSync( pHwData, 0x03b4, &ltmp );
-	*(PUSHORT)(pHwData->PermanentMacAddress + 2) = cpu_to_le16((u16)ltmp); //20060926 anson's endian
+	*(u16 *)(pHwData->PermanentMacAddress + 2) = cpu_to_le16((u16)ltmp); //20060926 anson's endian
 	Wb35Reg_WriteSync( pHwData, 0x03b4, 0x08020000 ); // Start EEPROM access + Read + address(0x0d)
 	Wb35Reg_ReadSync( pHwData, 0x03b4, &ltmp );
-	*(PUSHORT)(pHwData->PermanentMacAddress + 4) = cpu_to_le16((u16)ltmp); //20060926 anson's endian
-	*(PUSHORT)(pHwData->PermanentMacAddress + 6) = 0;
-	Wb35Reg_WriteSync( pHwData, 0x03e8, cpu_to_le32(*(PULONG)pHwData->PermanentMacAddress) ); //20060926 anson's endian
-	Wb35Reg_WriteSync( pHwData, 0x03ec, cpu_to_le32(*(PULONG)(pHwData->PermanentMacAddress+4)) ); //20060926 anson's endian
+	*(u16 *)(pHwData->PermanentMacAddress + 4) = cpu_to_le16((u16)ltmp); //20060926 anson's endian
+	*(u16 *)(pHwData->PermanentMacAddress + 6) = 0;
+	Wb35Reg_WriteSync( pHwData, 0x03e8, cpu_to_le32(*(u32 *)pHwData->PermanentMacAddress) ); //20060926 anson's endian
+	Wb35Reg_WriteSync( pHwData, 0x03ec, cpu_to_le32(*(u32 *)(pHwData->PermanentMacAddress+4)) ); //20060926 anson's endian
 }
 
 
@@ -1038,7 +1038,7 @@ void
 RFSynthesizer_initial(phw_data_t pHwData)
 {
 	u32	altmp[32];
-	PULONG	pltmp = altmp;
+	u32 *	pltmp = altmp;
 	u32	ltmp;
 	u8	number=0x00; // The number of register vale
 	u8	i;
@@ -2358,11 +2358,11 @@ void Mxx_initial(  phw_data_t pHwData )
 	pltmp[2] = pWb35Reg->M2C_MacControl;
 
 	// M30 BSSID
-	pltmp[3] = *(PULONG)pHwData->bssid;
+	pltmp[3] = *(u32 *)pHwData->bssid;
 
 	// M34
 	pHwData->AID = DEFAULT_AID;
-	tmp = *(PUSHORT)(pHwData->bssid+4);
+	tmp = *(u16 *)(pHwData->bssid+4);
 	tmp |= DEFAULT_AID << 16;
 	pltmp[4] = tmp;
 
@@ -2428,7 +2428,7 @@ void GetTxVgaFromEEPROM(  phw_data_t pHw
 {
 	u32		i, j, ltmp;
 	u16		Value[MAX_TXVGA_EEPROM];
-	PUCHAR		pctmp;
+	u8		*pctmp;
 	u8		ctmp=0;
 
 	// Get the entire TxVga setting in EEPROM
@@ -2441,7 +2441,7 @@ void GetTxVgaFromEEPROM(  phw_data_t pHw
 	}
 
 	// Adjust the filed which fills with reserved value.
-	pctmp = (PUCHAR)Value;
+	pctmp = (u8 *)Value;
 	for( i=0; i<(MAX_TXVGA_EEPROM*2); i++ )
 	{
 		if( pctmp[i] != 0xff )
@@ -2480,7 +2480,7 @@ void GetTxVgaFromEEPROM(  phw_data_t pHw
 // This function will use default TxVgaSettingInEEPROM data to calculate new TxVga.
 void EEPROMTxVgaAdjust(  phw_data_t pHwData ) // 20060619.5 Add
 {
-	PUCHAR		pTxVga = pHwData->TxVgaSettingInEEPROM;
+	u8	*	pTxVga = pHwData->TxVgaSettingInEEPROM;
 	s16		i, stmp;
 
 	//-- 2.4G -- 20060704.2 Request from Tiger
--- a/drivers/staging/winbond/sme_api.h
+++ b/drivers/staging/winbond/sme_api.h
@@ -208,7 +208,7 @@ s8 sme_set_tx_antenna(void *pcore_data, 
 s8 sme_set_IBSS_chan(void *pcore_data, ChanInfo chan);
 
 //20061108 WPS
-s8 sme_set_IE_append(void *pcore_data, PUCHAR buffer, u16 buf_len);
+s8 sme_set_IE_append(void *pcore_data, u8 *buffer, u16 buf_len);
 
 
 
--- a/drivers/staging/winbond/wbhal.c
+++ b/drivers/staging/winbond/wbhal.c
@@ -1,13 +1,13 @@
 #include "os_common.h"
 
-void hal_get_ethernet_address( phw_data_t pHwData, PUCHAR current_address )
+void hal_get_ethernet_address( phw_data_t pHwData, u8 *current_address )
 {
 	if( pHwData->SurpriseRemove ) return;
 
 	memcpy( current_address, pHwData->CurrentMacAddress, ETH_LENGTH_OF_ADDRESS );
 }
 
-void hal_set_ethernet_address( phw_data_t pHwData, PUCHAR current_address )
+void hal_set_ethernet_address( phw_data_t pHwData, u8 *current_address )
 {
 	u32 ltmp[2];
 
@@ -15,13 +15,13 @@ void hal_set_ethernet_address( phw_data_
 
 	memcpy( pHwData->CurrentMacAddress, current_address, ETH_LENGTH_OF_ADDRESS );
 
-	ltmp[0]= cpu_to_le32( *(PULONG)pHwData->CurrentMacAddress );
-	ltmp[1]= cpu_to_le32( *(PULONG)(pHwData->CurrentMacAddress + 4) ) & 0xffff;
+	ltmp[0]= cpu_to_le32( *(u32 *)pHwData->CurrentMacAddress );
+	ltmp[1]= cpu_to_le32( *(u32 *)(pHwData->CurrentMacAddress + 4) ) & 0xffff;
 
 	Wb35Reg_BurstWrite( pHwData, 0x03e8, ltmp, 2, AUTO_INCREMENT );
 }
 
-void hal_get_permanent_address( phw_data_t pHwData, PUCHAR pethernet_address )
+void hal_get_permanent_address( phw_data_t pHwData, u8 *pethernet_address )
 {
 	if( pHwData->SurpriseRemove ) return;
 
@@ -89,7 +89,7 @@ void hal_halt(phw_data_t pHwData, void *
 }
 
 //---------------------------------------------------------------------------------------------------
-void hal_set_rates(phw_data_t pHwData, PUCHAR pbss_rates,
+void hal_set_rates(phw_data_t pHwData, u8 *pbss_rates,
 		   u8 length, unsigned char basic_rate_set)
 {
 	PWB35REG	pWb35Reg = &pHwData->Wb35Reg;
@@ -158,13 +158,13 @@ void hal_set_rates(phw_data_t pHwData, P
 	// Fill data into support rate until buffer full
 	//---20060926 add by anson's endian
 	for (i=0; i<4; i++)
-		*(PULONG)(SupportedRate+(i<<2)) = cpu_to_le32( *(PULONG)(SupportedRate+(i<<2)) );
+		*(u32 *)(SupportedRate+(i<<2)) = cpu_to_le32( *(u32 *)(SupportedRate+(i<<2)) );
 	//--- end 20060926 add by anson's endian
-	Wb35Reg_BurstWrite( pHwData,0x087c, (PULONG)SupportedRate, 4, AUTO_INCREMENT );
-	pWb35Reg->M7C_MacControl = ((PULONG)SupportedRate)[0];
-	pWb35Reg->M80_MacControl = ((PULONG)SupportedRate)[1];
-	pWb35Reg->M84_MacControl = ((PULONG)SupportedRate)[2];
-	pWb35Reg->M88_MacControl = ((PULONG)SupportedRate)[3];
+	Wb35Reg_BurstWrite( pHwData,0x087c, (u32 *)SupportedRate, 4, AUTO_INCREMENT );
+	pWb35Reg->M7C_MacControl = ((u32 *)SupportedRate)[0];
+	pWb35Reg->M80_MacControl = ((u32 *)SupportedRate)[1];
+	pWb35Reg->M84_MacControl = ((u32 *)SupportedRate)[2];
+	pWb35Reg->M88_MacControl = ((u32 *)SupportedRate)[3];
 
 	// Fill length
 	tmp = Count1<<28 | Count2<<24;
@@ -206,7 +206,7 @@ void hal_set_current_channel_ex(  phw_da
 	pWb35Reg->M28_MacControl &= ~0xff; // Clean channel information field
 	pWb35Reg->M28_MacControl |= channel.ChanNo;
 	Wb35Reg_WriteWithCallbackValue( pHwData, 0x0828, pWb35Reg->M28_MacControl,
-					(PCHAR)&channel, sizeof(ChanInfo));
+					(s8 *)&channel, sizeof(ChanInfo));
 }
 //---------------------------------------------------------------------------------------------------
 void hal_set_current_channel(  phw_data_t pHwData,  ChanInfo channel )
@@ -277,7 +277,7 @@ void hal_set_accept_beacon(  phw_data_t 
 	Wb35Reg_Write( pHwData, 0x0800, pWb35Reg->M00_MacControl );
 }
 //---------------------------------------------------------------------------------------------------
-void hal_set_multicast_address( phw_data_t pHwData, PUCHAR address, u8 number )
+void hal_set_multicast_address( phw_data_t pHwData, u8 *address, u8 number )
 {
 	PWB35REG	pWb35Reg = &pHwData->Wb35Reg;
 	u8		Byte, Bit;
@@ -297,7 +297,7 @@ void hal_set_multicast_address( phw_data
 	}
 
 	// Updating register
-	Wb35Reg_BurstWrite( pHwData, 0x0804, (PULONG)pWb35Reg->Multicast, 2, AUTO_INCREMENT );
+	Wb35Reg_BurstWrite( pHwData, 0x0804, (u32 *)pWb35Reg->Multicast, 2, AUTO_INCREMENT );
 }
 //---------------------------------------------------------------------------------------------------
 u8 hal_get_accept_beacon(  phw_data_t pHwData )
@@ -806,7 +806,7 @@ u8 hal_get_hw_radio_off(  phw_data_t pHw
 	}
 }
 
-unsigned char hal_get_dxx_reg(  phw_data_t pHwData,  u16 number,  PULONG pValue )
+unsigned char hal_get_dxx_reg(  phw_data_t pHwData,  u16 number,  u32 * pValue )
 {
 	if( number < 0x1000 )
 		number += 0x1000;
--- a/drivers/staging/winbond/wbhal_f.h
+++ b/drivers/staging/winbond/wbhal_f.h
@@ -16,23 +16,23 @@
 //====================================================================================
 // Function declaration
 //====================================================================================
-void hal_remove_mapping_key(  phw_data_t pHwData,  PUCHAR pmac_addr );
+void hal_remove_mapping_key(  phw_data_t pHwData,  u8 *pmac_addr );
 void hal_remove_default_key(  phw_data_t pHwData,  u32 index );
-unsigned char hal_set_mapping_key(  phw_data_t Adapter,  PUCHAR pmac_addr,  u8 null_key,  u8 wep_on,  PUCHAR ptx_tsc,  PUCHAR prx_tsc,  u8 key_type,  u8 key_len,  PUCHAR pkey_data );
-unsigned char hal_set_default_key(  phw_data_t Adapter,  u8 index,  u8 null_key,  u8 wep_on,  PUCHAR ptx_tsc,  PUCHAR prx_tsc,  u8 key_type,  u8 key_len,  PUCHAR pkey_data );
+unsigned char hal_set_mapping_key(  phw_data_t Adapter,  u8 *pmac_addr,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
+unsigned char hal_set_default_key(  phw_data_t Adapter,  u8 index,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
 void hal_clear_all_default_key(  phw_data_t pHwData );
 void hal_clear_all_group_key(  phw_data_t pHwData );
 void hal_clear_all_mapping_key(  phw_data_t pHwData );
 void hal_clear_all_key(  phw_data_t pHwData );
-void hal_get_ethernet_address(  phw_data_t pHwData,  PUCHAR current_address );
-void hal_set_ethernet_address(  phw_data_t pHwData,  PUCHAR current_address );
-void hal_get_permanent_address(  phw_data_t pHwData,  PUCHAR pethernet_address );
+void hal_get_ethernet_address(  phw_data_t pHwData,  u8 *current_address );
+void hal_set_ethernet_address(  phw_data_t pHwData,  u8 *current_address );
+void hal_get_permanent_address(  phw_data_t pHwData,  u8 *pethernet_address );
 unsigned char hal_init_hardware(  phw_data_t pHwData,  PADAPTER Adapter );
 void hal_set_power_save_mode(  phw_data_t pHwData,  unsigned char power_save,  unsigned char wakeup,  unsigned char dtim );
-void hal_get_power_save_mode(  phw_data_t pHwData,   PBOOLEAN pin_pwr_save );
+void hal_get_power_save_mode(  phw_data_t pHwData,   u8 *pin_pwr_save );
 void hal_set_slot_time(  phw_data_t pHwData,  u8 type );
 #define hal_set_atim_window( _A, _ATM )
-void hal_set_rates(  phw_data_t pHwData,  PUCHAR pbss_rates,  u8 length,  unsigned char basic_rate_set );
+void hal_set_rates(  phw_data_t pHwData,  u8 *pbss_rates,  u8 length,  unsigned char basic_rate_set );
 #define hal_set_basic_rates( _A, _R, _L ) hal_set_rates( _A, _R, _L, TRUE )
 #define hal_set_op_rates( _A, _R, _L ) hal_set_rates( _A, _R, _L, FALSE )
 void hal_start_bss(  phw_data_t pHwData,  u8 mac_op_mode );
@@ -40,19 +40,19 @@ void hal_join_request(  phw_data_t pHwDa
 void hal_stop_sync_bss(  phw_data_t pHwData );
 void hal_resume_sync_bss(  phw_data_t pHwData);
 void hal_set_aid(  phw_data_t pHwData,  u16 aid );
-void hal_set_bssid(  phw_data_t pHwData,  PUCHAR pbssid );
-void hal_get_bssid(  phw_data_t pHwData,  PUCHAR pbssid );
+void hal_set_bssid(  phw_data_t pHwData,  u8 *pbssid );
+void hal_get_bssid(  phw_data_t pHwData,  u8 *pbssid );
 void hal_set_beacon_period(  phw_data_t pHwData,  u16 beacon_period );
 void hal_set_listen_interval(  phw_data_t pHwData,  u16 listen_interval );
 void hal_set_cap_info(  phw_data_t pHwData,  u16 capability_info );
-void hal_set_ssid(  phw_data_t pHwData,  PUCHAR pssid,  u8 ssid_len );
+void hal_set_ssid(  phw_data_t pHwData,  u8 *pssid,  u8 ssid_len );
 void hal_set_current_channel(  phw_data_t pHwData,  ChanInfo channel );
 void hal_set_current_channel_ex(  phw_data_t pHwData,  ChanInfo channel );
 void hal_get_current_channel(  phw_data_t pHwData,  ChanInfo *channel );
 void hal_set_accept_broadcast(  phw_data_t pHwData,  u8 enable );
 void hal_set_accept_multicast(  phw_data_t pHwData,  u8 enable );
 void hal_set_accept_beacon(  phw_data_t pHwData,  u8 enable );
-void hal_set_multicast_address(  phw_data_t pHwData,  PUCHAR address,  u8 number );
+void hal_set_multicast_address(  phw_data_t pHwData,  u8 *address,  u8 number );
 u8 hal_get_accept_beacon(  phw_data_t pHwData );
 void hal_stop(  phw_data_t pHwData );
 void hal_halt(  phw_data_t pHwData, void *ppa_data );
@@ -97,7 +97,7 @@ void hal_surprise_remove(  phw_data_t pH
 
 
 void hal_rate_change(  phw_data_t pHwData ); // Notify the HAL rate is changing 20060613.1
-unsigned char hal_get_dxx_reg(  phw_data_t pHwData,  u16 number,  PULONG pValue );
+unsigned char hal_get_dxx_reg(  phw_data_t pHwData,  u16 number,  u32 * pValue );
 unsigned char hal_set_dxx_reg(  phw_data_t pHwData,  u16 number,  u32 value );
 #define hal_get_time_count( _P )	(_P->time_count/10)	// return 100ms count
 #define hal_detect_error( _P )		(_P->WbUsb.DetectCount)
@@ -116,7 +116,7 @@ unsigned char	hal_idle(  phw_data_t pHwD
 #define pa_stall_execution( _A )	//OS_SLEEP( 1 )
 #define hw_get_cxx_reg( _A, _B, _C )
 #define hw_set_cxx_reg( _A, _B, _C )
-#define hw_get_dxx_reg( _A, _B, _C )	hal_get_dxx_reg( _A, _B, (PULONG)_C )
+#define hw_get_dxx_reg( _A, _B, _C )	hal_get_dxx_reg( _A, _B, (u32 *)_C )
 #define hw_set_dxx_reg( _A, _B, _C )	hal_set_dxx_reg( _A, _B, (u32)_C )
 
 
--- a/drivers/staging/winbond/wbhal_s.h
+++ b/drivers/staging/winbond/wbhal_s.h
@@ -461,7 +461,7 @@ typedef struct _HW_DATA_T
 	//=====================================================================
 	// Definition for 802.11
 	//=====================================================================
-	PUCHAR	bssid_pointer; // Used by hal_get_bssid for return value
+	u8	*bssid_pointer; // Used by hal_get_bssid for return value
 	u8	bssid[8];// Only 6 byte will be used. 8 byte is required for read buffer
 	u8	ssid[32];// maximum ssid length is 32 byte
 
@@ -486,7 +486,7 @@ typedef struct _HW_DATA_T
 	u32	CurrentRadioSw; // 20060320.2 0:On 1:Off
 	u32	CurrentRadioHw; // 20060825 0:On 1:Off
 
-	PUCHAR	power_save_point;  // Used by hal_get_power_save_mode for return value
+	u8	*power_save_point;  // Used by hal_get_power_save_mode for return value
 	u8	cwmin;
 	u8	desired_power_save;
 	u8	dtim;// Is running dtim
--- a/drivers/staging/winbond/wblinux.c
+++ b/drivers/staging/winbond/wblinux.c
@@ -25,7 +25,7 @@ EncapAtomicInc(PADAPTER Adapter, void* p
 {
 	PWBLINUX pWbLinux = &Adapter->WbLinux;
 	u32	ltmp;
-	PULONG	pltmp = (PULONG)pAtomic;
+	u32 *	pltmp = (u32 *)pAtomic;
 	OS_SPIN_LOCK_ACQUIRED( &pWbLinux->AtomicSpinLock );
 	(*pltmp)++;
 	ltmp = (*pltmp);
@@ -38,7 +38,7 @@ EncapAtomicDec(PADAPTER Adapter, void* p
 {
 	PWBLINUX pWbLinux = &Adapter->WbLinux;
 	u32	ltmp;
-	PULONG	pltmp = (PULONG)pAtomic;
+	u32 *	pltmp = (u32 *)pAtomic;
 	OS_SPIN_LOCK_ACQUIRED( &pWbLinux->AtomicSpinLock );
 	(*pltmp)--;
 	ltmp = (*pltmp);
@@ -142,7 +142,8 @@ unsigned char
 WbWLanInitialize(PADAPTER Adapter)
 {
 	phw_data_t	pHwData;
-	PUCHAR		pMacAddr, pMacAddr2;
+	u8		*pMacAddr;
+	u8		*pMacAddr2;
 	u32		InitStep = 0;
 	u8		EEPROM_region;
 	u8		HwRadioOff;
