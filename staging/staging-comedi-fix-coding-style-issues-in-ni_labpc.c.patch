From 87d8f06c59da230f3aec6d809b92d6a9ea7ba9bf Mon Sep 17 00:00:00 2001
From: Stewart Robertson <stewart_r@aliencamel.com>
Date: Sun, 21 Feb 2010 10:13:21 +0000
Subject: Staging: comedi: fix coding style issues in ni_labpc.c

This is a patch to the ni_labpc.c file that fixes the brace warnings and
comments over 80 characters found by the checkpatch.pl tool. Some code
still goes over 80 characters because I didn't know what to do with it.

Signed-off-by: Stewart Robertson <stewart_r@aliencamel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/staging/comedi/drivers/ni_labpc.c |  231 ++++++++++++++++++------------
 1 file changed, 145 insertions(+), 86 deletions(-)

--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -90,8 +90,10 @@ NI manuals:
 
 #define DRV_NAME "ni_labpc"
 
-#define LABPC_SIZE           32	/*  size of io region used by board */
-#define LABPC_TIMER_BASE            500	/*  2 MHz master clock */
+/* size of io region used by board */
+#define LABPC_SIZE           32
+/* 2 MHz master clock */
+#define LABPC_TIMER_BASE            500
 
 /* Registers for the lab-pc+ */
 
@@ -99,69 +101,110 @@ NI manuals:
 #define COMMAND1_REG	0x0
 #define   ADC_GAIN_MASK	(0x7 << 4)
 #define   ADC_CHAN_BITS(x)	((x) & 0x7)
-#define   ADC_SCAN_EN_BIT	0x80	/*  enables multi channel scans */
+/* enables multi channel scans */
+#define   ADC_SCAN_EN_BIT	0x80
 #define COMMAND2_REG	0x1
-#define   PRETRIG_BIT	0x1	/*  enable pretriggering (used in conjunction with SWTRIG) */
-#define   HWTRIG_BIT	0x2	/*  enable paced conversions on external trigger */
-#define   SWTRIG_BIT	0x4	/*  enable paced conversions */
-#define   CASCADE_BIT	0x8	/*  use two cascaded counters for pacing */
+/* enable pretriggering (used in conjunction with SWTRIG) */
+#define   PRETRIG_BIT	0x1
+/* enable paced conversions on external trigger */
+#define   HWTRIG_BIT	0x2
+/* enable paced conversions */
+#define   SWTRIG_BIT	0x4
+/* use two cascaded counters for pacing */
+#define   CASCADE_BIT	0x8
 #define   DAC_PACED_BIT(channel)	(0x40 << ((channel) & 0x1))
 #define COMMAND3_REG	0x2
-#define   DMA_EN_BIT	0x1	/*  enable dma transfers */
-#define   DIO_INTR_EN_BIT	0x2	/*  enable interrupts for 8255 */
-#define   DMATC_INTR_EN_BIT	0x4	/*  enable dma terminal count interrupt */
-#define   TIMER_INTR_EN_BIT	0x8	/*  enable timer interrupt */
-#define   ERR_INTR_EN_BIT	0x10	/*  enable error interrupt */
-#define   ADC_FNE_INTR_EN_BIT	0x20	/*  enable fifo not empty interrupt */
+/* enable dma transfers */
+#define   DMA_EN_BIT	0x1
+/* enable interrupts for 8255 */
+#define   DIO_INTR_EN_BIT	0x2
+/* enable dma terminal count interrupt */
+#define   DMATC_INTR_EN_BIT	0x4
+/* enable timer interrupt */
+#define   TIMER_INTR_EN_BIT	0x8
+/* enable error interrupt */
+#define   ERR_INTR_EN_BIT	0x10
+/* enable fifo not empty interrupt */
+#define   ADC_FNE_INTR_EN_BIT	0x20
 #define ADC_CONVERT_REG	0x3
 #define DAC_LSB_REG(channel)	(0x4 + 2 * ((channel) & 0x1))
 #define DAC_MSB_REG(channel)	(0x5 + 2 * ((channel) & 0x1))
 #define ADC_CLEAR_REG	0x8
 #define DMATC_CLEAR_REG	0xa
 #define TIMER_CLEAR_REG	0xc
-#define COMMAND6_REG	0xe	/*  1200 boards only */
-#define   ADC_COMMON_BIT	0x1	/*  select ground or common-mode reference */
-#define   ADC_UNIP_BIT	0x2	/*  adc unipolar */
-#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))	/*  dac unipolar */
-#define   ADC_FHF_INTR_EN_BIT	0x20	/*  enable fifo half full interrupt */
-#define   A1_INTR_EN_BIT	0x40	/*  enable interrupt on end of hardware count */
-#define   ADC_SCAN_UP_BIT 0x80	/*  scan up from channel zero instead of down to zero */
+/* 1200 boards only */
+#define COMMAND6_REG	0xe
+/* select ground or common-mode reference */
+#define   ADC_COMMON_BIT	0x1
+/*  adc unipolar */
+#define   ADC_UNIP_BIT	0x2
+/*  dac unipolar */
+#define   DAC_UNIP_BIT(channel)	(0x4 << ((channel) & 0x1))
+/* enable fifo half full interrupt */
+#define   ADC_FHF_INTR_EN_BIT	0x20
+/* enable interrupt on end of hardware count */
+#define   A1_INTR_EN_BIT	0x40
+/* scan up from channel zero instead of down to zero */
+#define   ADC_SCAN_UP_BIT 0x80
 #define COMMAND4_REG	0xf
-#define   INTERVAL_SCAN_EN_BIT	0x1	/*  enables 'interval' scanning */
-#define   EXT_SCAN_EN_BIT	0x2	/*  enables external signal on counter b1 output to trigger scan */
-#define   EXT_CONVERT_OUT_BIT	0x4	/*  chooses direction (output or input) for EXTCONV* line */
-#define   ADC_DIFF_BIT	0x8	/*  chooses differential inputs for adc (in conjunction with board jumper) */
+/* enables 'interval' scanning */
+#define   INTERVAL_SCAN_EN_BIT	0x1
+/* enables external signal on counter b1 output to trigger scan */
+#define   EXT_SCAN_EN_BIT	0x2
+/* chooses direction (output or input) for EXTCONV* line */
+#define   EXT_CONVERT_OUT_BIT	0x4
+/* chooses differential inputs for adc (in conjunction with board jumper) */
+#define   ADC_DIFF_BIT	0x8
 #define   EXT_CONVERT_DISABLE_BIT	0x10
-#define COMMAND5_REG	0x1c	/*  1200 boards only, calibration stuff */
-#define   EEPROM_WRITE_UNPROTECT_BIT	0x4	/*  enable eeprom for write */
-#define   DITHER_EN_BIT	0x8	/*  enable dithering */
-#define   CALDAC_LOAD_BIT	0x10	/*  load calibration dac */
-#define   SCLOCK_BIT	0x20	/*  serial clock - rising edge writes, falling edge reads */
-#define   SDATA_BIT	0x40	/*  serial data bit for writing to eeprom or calibration dacs */
-#define   EEPROM_EN_BIT	0x80	/*  enable eeprom for read/write */
+/* 1200 boards only, calibration stuff */
+#define COMMAND5_REG	0x1c
+/* enable eeprom for write */
+#define   EEPROM_WRITE_UNPROTECT_BIT	0x4
+/* enable dithering */
+#define   DITHER_EN_BIT	0x8
+/* load calibration dac */
+#define   CALDAC_LOAD_BIT	0x10
+/* serial clock - rising edge writes, falling edge reads */
+#define   SCLOCK_BIT	0x20
+/* serial data bit for writing to eeprom or calibration dacs */
+#define   SDATA_BIT	0x40
+/* enable eeprom for read/write */
+#define   EEPROM_EN_BIT	0x80
 #define INTERVAL_COUNT_REG	0x1e
 #define INTERVAL_LOAD_REG	0x1f
 #define   INTERVAL_LOAD_BITS	0x1
 
 /* read-only registers */
 #define STATUS1_REG	0x0
-#define   DATA_AVAIL_BIT	0x1	/*  data is available in fifo */
-#define   OVERRUN_BIT	0x2	/*  overrun has occurred */
-#define   OVERFLOW_BIT	0x4	/*  fifo overflow */
-#define   TIMER_BIT	0x8	/*  timer interrupt has occured */
-#define   DMATC_BIT	0x10	/*  dma terminal count has occured */
-#define   EXT_TRIG_BIT	0x40	/*  external trigger has occured */
-#define STATUS2_REG	0x1d	/*  1200 boards only */
-#define   EEPROM_OUT_BIT	0x1	/*  programmable eeprom serial output */
-#define   A1_TC_BIT	0x2	/*  counter A1 terminal count */
-#define   FNHF_BIT	0x4	/*  fifo not half full */
+/* data is available in fifo */
+#define   DATA_AVAIL_BIT	0x1
+/* overrun has occurred */
+#define   OVERRUN_BIT	0x2
+/* fifo overflow */
+#define   OVERFLOW_BIT	0x4
+/* timer interrupt has occured */
+#define   TIMER_BIT	0x8
+/* dma terminal count has occured */
+#define   DMATC_BIT	0x10
+/* external trigger has occured */
+#define   EXT_TRIG_BIT	0x40
+/* 1200 boards only */
+#define STATUS2_REG	0x1d
+/* programmable eeprom serial output */
+#define   EEPROM_OUT_BIT	0x1
+/* counter A1 terminal count */
+#define   A1_TC_BIT	0x2
+/* fifo not half full */
+#define   FNHF_BIT	0x4
 #define ADC_FIFO_REG	0xa
 
 #define DIO_BASE_REG	0x10
 #define COUNTER_A_BASE_REG	0x14
 #define COUNTER_A_CONTROL_REG	(COUNTER_A_BASE_REG + 0x3)
-#define   INIT_A0_BITS	0x14	/*  check modes put conversion pacer output in harmless state (a0 mode 2) */
-#define   INIT_A1_BITS	0x70	/*  put hardware conversion counter output in harmless state (a1 mode 0) */
+/* check modes put conversion pacer output in harmless state (a0 mode 2) */
+#define   INIT_A0_BITS	0x14
+/* put hardware conversion counter output in harmless state (a1 mode 0) */
+#define   INIT_A1_BITS	0x70
 #define COUNTER_B_BASE_REG	0x18
 
 static int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it);
@@ -423,7 +466,7 @@ static const struct labpc_board_struct l
 	 .ai_scan_up = 1,
 	 .memory_mapped_io = 1,
 	 },
-	/*  dummy entry so pci board works when comedi_config is passed driver name */
+/* dummy entry so pci board works when comedi_config is passed driver name */
 	{
 	 .name = DRV_NAME,
 	 .bustype = pci_bustype,
@@ -436,8 +479,10 @@ static const struct labpc_board_struct l
  */
 #define thisboard ((struct labpc_board_struct *)dev->board_ptr)
 
-static const int dma_buffer_size = 0xff00;	/*  size in bytes of dma buffer */
-static const int sample_size = 2;	/*  2 bytes per sample */
+/* size in bytes of dma buffer */
+static const int dma_buffer_size = 0xff00;
+/* 2 bytes per sample */
+static const int sample_size = 2;
 
 #define devpriv ((struct labpc_private *)dev->private)
 
@@ -511,7 +556,7 @@ int labpc_common_attach(struct comedi_de
 		devpriv->read_byte = labpc_inb;
 		devpriv->write_byte = labpc_outb;
 	}
-	/*  initialize board's command registers */
+	/* initialize board's command registers */
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
@@ -536,12 +581,12 @@ int labpc_common_attach(struct comedi_de
 	}
 	dev->irq = irq;
 
-	/*  grab dma channel */
+	/* grab dma channel */
 	if (dma_chan > 3) {
 		printk(" invalid dma channel %u\n", dma_chan);
 		return -EINVAL;
 	} else if (dma_chan) {
-		/*  allocate dma buffer */
+		/* allocate dma buffer */
 		devpriv->dma_buffer =
 		    kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL) {
@@ -573,7 +618,7 @@ int labpc_common_attach(struct comedi_de
 	    SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;
 	s->n_chan = 8;
 	s->len_chanlist = 8;
-	s->maxdata = (1 << 12) - 1;	/*  12 bit resolution */
+	s->maxdata = (1 << 12) - 1;	/* 12 bit resolution */
 	s->range_table = thisboard->ai_range_table;
 	s->do_cmd = labpc_ai_cmd;
 	s->do_cmdtest = labpc_ai_cmdtest;
@@ -667,7 +712,7 @@ static int labpc_attach(struct comedi_de
 	if (alloc_private(dev, sizeof(struct labpc_private)) < 0)
 		return -ENOMEM;
 
-	/*  get base address, irq etc. based on bustype */
+	/* get base address, irq etc. based on bustype */
 	switch (thisboard->bustype) {
 	case isa_bustype:
 		iobase = it->options[0];
@@ -712,7 +757,7 @@ static int labpc_find_device(struct come
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
-		/*  if bus/slot are specified then make sure we have the right bus/slot */
+/* if bus/slot are specified then make sure we have the right bus/slot */
 		if (bus || slot) {
 			if (bus != mite->pcidev->bus->number
 			    || slot != PCI_SLOT(mite->pcidev->devfn))
@@ -723,7 +768,7 @@ static int labpc_find_device(struct come
 				continue;
 			if (mite_device_id(mite) == labpc_boards[i].device_id) {
 				devpriv->mite = mite;
-				/*  fixup board pointer, in case we were using the dummy "ni_labpc" entry */
+/* fixup board pointer, in case we were using the dummy "ni_labpc" entry */
 				dev->board_ptr = &labpc_boards[i];
 				return 0;
 			}
@@ -991,7 +1036,7 @@ static int labpc_ai_cmdtest(struct comed
 	    cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
-	/*  can't have external stop and start triggers at once */
+	/* can't have external stop and start triggers at once */
 	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
 		err++;
 
@@ -1019,7 +1064,7 @@ static int labpc_ai_cmdtest(struct comed
 			err++;
 		}
 	}
-	/*  make sure scan timing is not too fast */
+	/* make sure scan timing is not too fast */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->convert_src == TRIG_TIMER &&
 		    cmd->scan_begin_arg <
@@ -1035,7 +1080,7 @@ static int labpc_ai_cmdtest(struct comed
 			err++;
 		}
 	}
-	/*  stop source */
+	/* stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		if (!cmd->stop_arg) {
@@ -1092,7 +1137,7 @@ static int labpc_ai_cmd(struct comedi_de
 	range = CR_RANGE(cmd->chanlist[0]);
 	aref = CR_AREF(cmd->chanlist[0]);
 
-	/*  make sure board is disabled before setting up aquisition */
+	/* make sure board is disabled before setting up aquisition */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
@@ -1172,17 +1217,18 @@ static int labpc_ai_cmd(struct comedi_de
 		channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
 	else
 		channel = CR_CHAN(cmd->chanlist[0]);
-	/*  munge channel bits for differential / scan disabled mode */
+	/* munge channel bits for differential / scan disabled mode */
 	if (labpc_ai_scan_mode(cmd) != MODE_SINGLE_CHAN && aref == AREF_DIFF)
 		channel *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(channel);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
-	/*  manual says to set scan enable bit on second pass */
+	/* manual says to set scan enable bit on second pass */
 	if (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||
 	    labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {
 		devpriv->command1_bits |= ADC_SCAN_EN_BIT;
-		/* need a brief delay before enabling scan, or scan list will get screwed when you switch
+		/* need a brief delay before enabling scan, or scan
+		 * list will get screwed when you switch
 		 * between scan up to scan down mode - dunno why */
 		udelay(1);
 		devpriv->write_byte(devpriv->command1_bits,
@@ -1334,7 +1380,7 @@ static irqreturn_t labpc_interrupt(int i
 	cmd = &async->cmd;
 	async->events = 0;
 
-	/*  read board status */
+	/* read board status */
 	devpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);
 	if (thisboard->register_layout == labpc_1200_layout)
 		devpriv->status2_bits =
@@ -1348,7 +1394,7 @@ static irqreturn_t labpc_interrupt(int i
 	}
 
 	if (devpriv->status1_bits & OVERRUN_BIT) {
-		/*  clear error interrupt */
+		/* clear error interrupt */
 		devpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_event(dev, s);
@@ -1357,7 +1403,7 @@ static irqreturn_t labpc_interrupt(int i
 	}
 
 	if (devpriv->current_transfer == isa_dma_transfer) {
-		/*  if a dma terminal count of external stop trigger has occurred */
+	/* if a dma terminal count of external stop trigger has occurred */
 		if (devpriv->status1_bits & DMATC_BIT ||
 		    (thisboard->register_layout == labpc_1200_layout
 		     && devpriv->status2_bits & A1_TC_BIT)) {
@@ -1532,41 +1578,41 @@ static int labpc_ai_rinsn(struct comedi_
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 	devpriv->command1_bits |= thisboard->ai_range_code[range];
-	/*  munge channel bits for differential/scan disabled mode */
+	/* munge channel bits for differential/scan disabled mode */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		chan *= 2;
 	devpriv->command1_bits |= ADC_CHAN_BITS(chan);
 	devpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);
 
-	/*  setup command6 register for 1200 boards */
+	/* setup command6 register for 1200 boards */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		/*  reference inputs to ground or common? */
 		if (CR_AREF(insn->chanspec) != AREF_GROUND)
 			devpriv->command6_bits |= ADC_COMMON_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_COMMON_BIT;
-		/*  bipolar or unipolar range? */
+		/* bipolar or unipolar range? */
 		if (thisboard->ai_range_is_unipolar[range])
 			devpriv->command6_bits |= ADC_UNIP_BIT;
 		else
 			devpriv->command6_bits &= ~ADC_UNIP_BIT;
-		/*  don't interrupt on fifo half full */
+		/* don't interrupt on fifo half full */
 		devpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;
-		/*  don't enable interrupt on counter a1 terminal count? */
+		/* don't enable interrupt on counter a1 terminal count? */
 		devpriv->command6_bits &= ~A1_INTR_EN_BIT;
-		/*  write to register */
+		/* write to register */
 		devpriv->write_byte(devpriv->command6_bits,
 				    dev->iobase + COMMAND6_REG);
 	}
-	/*  setup command4 register */
+	/* setup command4 register */
 	devpriv->command4_bits = 0;
 	devpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;
-	/*  single-ended/differential */
+	/* single-ended/differential */
 	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		devpriv->command4_bits |= ADC_DIFF_BIT;
 	devpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);
 
-	/*  initialize pacer counter output to make sure it doesn't cause any problems */
+	/* initialize pacer counter output to make sure it doesn't cause any problems */
 	devpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);
 
 	labpc_clear_adc_fifo(dev);
@@ -1603,7 +1649,7 @@ static int labpc_ao_winsn(struct comedi_
 
 	channel = CR_CHAN(insn->chanspec);
 
-	/*  turn off pacing of analog output channel */
+	/* turn off pacing of analog output channel */
 	/* note: hardware bug in daqcard-1200 means pacing cannot
 	 * be independently enabled/disabled for its the two channels */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1611,7 +1657,7 @@ static int labpc_ao_winsn(struct comedi_
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  set range */
+	/* set range */
 	if (thisboard->register_layout == labpc_1200_layout) {
 		range = CR_RANGE(insn->chanspec);
 		if (range & AO_RANGE_IS_UNIPOLAR)
@@ -1622,13 +1668,13 @@ static int labpc_ao_winsn(struct comedi_
 		devpriv->write_byte(devpriv->command6_bits,
 				    dev->iobase + COMMAND6_REG);
 	}
-	/*  send data */
+	/* send data */
 	lsb = data[0] & 0xff;
 	msb = (data[0] >> 8) & 0xff;
 	devpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));
 	devpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));
 
-	/*  remember value for readback */
+	/* remember value for readback */
 	devpriv->ao_value[channel] = data[0];
 
 	return 1;
@@ -1700,14 +1746,14 @@ static unsigned int labpc_suggest_transf
 
 	if (cmd.convert_src == TRIG_TIMER)
 		freq = 1000000000 / cmd.convert_arg;
-	/*  return some default value */
+	/* return some default value */
 	else
 		freq = 0xffffffff;
 
-	/*  make buffer fill in no more than 1/3 second */
+	/* make buffer fill in no more than 1/3 second */
 	size = (freq / 3) * sample_size;
 
-	/*  set a minimum and maximum size allowed */
+	/* set a minimum and maximum size allowed */
 	if (size > dma_buffer_size)
 		size = dma_buffer_size - dma_buffer_size % sample_size;
 	else if (size < sample_size)
@@ -1719,13 +1765,21 @@ static unsigned int labpc_suggest_transf
 /* figures out what counter values to use based on command */
 static void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 {
-	const int max_counter_value = 0x10000;	/*  max value for 16 bit counter in mode 2 */
-	const int min_counter_value = 2;	/*  min value for 16 bit counter in mode 2 */
+	/* max value for 16 bit counter in mode 2 */
+	const int max_counter_value = 0x10000;
+	/* min value for 16 bit counter in mode 2 */
+	const int min_counter_value = 2;
 	unsigned int base_period;
 
-	/*  if both convert and scan triggers are TRIG_TIMER, then they both rely on counter b0 */
+	/*
+	 * if both convert and scan triggers are TRIG_TIMER, then they
+	 * both rely on counter b0
+	 */
 	if (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {
-		/*  pick the lowest b0 divisor value we can (for maximum input clock speed on convert and scan counters) */
+		/*
+		 * pick the lowest b0 divisor value we can (for maximum input
+		 * clock speed on convert and scan counters)
+		 */
 		devpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /
 		    (LABPC_TIMER_BASE * max_counter_value) + 1;
 		if (devpriv->divisor_b0 < min_counter_value)
@@ -1775,7 +1829,10 @@ static void labpc_adc_timing(struct come
 					    base_period * devpriv->divisor_a0);
 		labpc_set_ai_scan_period(cmd,
 					 base_period * devpriv->divisor_b1);
-		/*  if only one TRIG_TIMER is used, we can employ the generic cascaded timing functions */
+		/*
+		 * if only one TRIG_TIMER is used, we can employ the generic
+		 * cascaded timing functions
+		 */
 	} else if (labpc_ai_scan_period(cmd)) {
 		unsigned int scan_period;
 
@@ -1870,8 +1927,10 @@ static unsigned int labpc_eeprom_read(st
 				      unsigned int address)
 {
 	unsigned int value;
-	const int read_instruction = 0x3;	/*  bits to tell eeprom to expect a read */
-	const int write_length = 8;	/*  8 bit write lengths to eeprom */
+	/*  bits to tell eeprom to expect a read */
+	const int read_instruction = 0x3;
+	/*  8 bit write lengths to eeprom */
+	const int write_length = 8;
 
 	/*  enable read/write to eeprom */
 	devpriv->command5_bits &= ~EEPROM_EN_BIT;
