From penberg@cs.helsinki.fi  Mon Oct 27 11:56:49 2008
From: Pekka J Enberg <penberg@cs.helsinki.fi>
Date: Wed, 22 Oct 2008 11:03:19 +0300 (EEST)
Subject: Staging: w35und: padapter struct typedef removal
To: Greg Kroah-Hartman <greg@kroah.com>
Cc: Pavel Machek <pavel@suse.cz>, linux-kernel@vger.kernel.org
Message-ID: <Pine.LNX.4.64.0810221102440.13366@melkki.cs.Helsinki.FI>


From: Pekka Enberg <penberg@cs.helsinki.fi>

Remove the PADAPTER typedef and its strange variants. Also fix up variable
names that use the type while we're at it.

Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
Acked-by: Pavel Machek <pavel@suse.cz>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/winbond/adapter.h       |   10 +--
 drivers/staging/winbond/bss_f.h         |   68 ++++++++++-----------
 drivers/staging/winbond/bssdscpt.h      |    8 +-
 drivers/staging/winbond/ds_tkip.h       |    4 -
 drivers/staging/winbond/linux/wb35reg.c |    8 +-
 drivers/staging/winbond/linux/wb35rx.c  |    8 +-
 drivers/staging/winbond/linux/wb35tx.c  |   30 ++++-----
 drivers/staging/winbond/linux/wbusb.c   |   24 +++----
 drivers/staging/winbond/linux/wbusb_f.h |    2 
 drivers/staging/winbond/localpara.h     |    2 
 drivers/staging/winbond/mds.c           |   64 ++++++++++----------
 drivers/staging/winbond/mds_f.h         |   40 ++++++------
 drivers/staging/winbond/mds_s.h         |   20 +++---
 drivers/staging/winbond/mlme_mib.h      |   20 +++---
 drivers/staging/winbond/mlmetxrx.c      |   70 +++++++++++-----------
 drivers/staging/winbond/mlmetxrx_f.h    |   20 +++---
 drivers/staging/winbond/mto.c           |    8 +-
 drivers/staging/winbond/mto.h           |   22 +++----
 drivers/staging/winbond/mto_f.h         |    6 -
 drivers/staging/winbond/rxisr.c         |   18 ++---
 drivers/staging/winbond/scan_s.h        |   12 +--
 drivers/staging/winbond/sme_s.h         |    4 -
 drivers/staging/winbond/wbhal.c         |   24 +++----
 drivers/staging/winbond/wbhal_f.h       |    6 -
 drivers/staging/winbond/wbhal_s.h       |    6 -
 drivers/staging/winbond/wblinux.c       |  100 ++++++++++++++++----------------
 drivers/staging/winbond/wblinux_f.h     |   22 +++----
 drivers/staging/winbond/wblinux_s.h     |    2 
 28 files changed, 314 insertions(+), 314 deletions(-)

--- a/drivers/staging/winbond/adapter.h
+++ b/drivers/staging/winbond/adapter.h
@@ -1,11 +1,11 @@
 //
 // ADAPTER.H -
-// Windows NDIS global variable 'Adapter' typedef
+// Windows NDIS global variable 'adapter' typedef
 //
 #define MAX_ANSI_STRING		40
-typedef struct WB32_ADAPTER
-{
-	u32 AdapterIndex; // 20060703.4 Add for using pAdapterContext global Adapter point
+
+struct wb35_adapter {
+	u32 adapterIndex; // 20060703.4 Add for using padapterContext global adapter point
 
 	WB_LOCALDESCRIPT	sLocalPara;		// Myself connected parameters
 	PWB_BSSDESCRIPTION	asBSSDescriptElement;
@@ -20,4 +20,4 @@ typedef struct WB32_ADAPTER
         struct iw_statistics iw_stats;
 
 	u8	LinkName[MAX_ANSI_STRING];
-} WB32_ADAPTER, ADAPTER, *PWB32_ADAPTER, *PADAPTER;
+};
--- a/drivers/staging/winbond/bssdscpt.h
+++ b/drivers/staging/winbond/bssdscpt.h
@@ -78,7 +78,7 @@ typedef struct BSSDescriptionElement
     u16		wState;			// the current state of the system
 	u16		wIndex;			// THIS BSS element entry index
 
-	void*	psAdapter;		// pointer to THIS Adapter
+	void*	psadapter;		// pointer to THIS adapter
 	OS_TIMER	nTimer;  // MLME timer
 
     // Authentication
@@ -148,9 +148,9 @@ typedef struct BSSDescriptionElement
 
 } WB_BSSDESCRIPTION, *PWB_BSSDESCRIPTION;
 
-#define wBSSConnectedSTA(Adapter)             \
-    ((u16)(Adapter)->sLocalPara.wConnectedSTAindex)
+#define wBSSConnectedSTA(adapter)             \
+    ((u16)(adapter)->sLocalPara.wConnectedSTAindex)
 
-#define psBSS(i)			(&(Adapter->asBSSDescriptElement[(i)]))
+#define psBSS(i)			(&(adapter->asBSSDescriptElement[(i)]))
 
 
--- a/drivers/staging/winbond/bss_f.h
+++ b/drivers/staging/winbond/bss_f.h
@@ -2,54 +2,54 @@
 // BSS descriptor DataBase management global function
 //
 
-void vBSSdescriptionInit(PWB32_ADAPTER Adapter);
-void vBSSfoundList(PWB32_ADAPTER Adapter);
-u8 boChanFilter(PWB32_ADAPTER Adapter, u8 ChanNo);
-u16 wBSSallocateEntry(PWB32_ADAPTER Adapter);
-u16 wBSSGetEntry(PWB32_ADAPTER Adapter);
-void vSimpleHouseKeeping(PWB32_ADAPTER Adapter);
-u16 wBSShouseKeeping(PWB32_ADAPTER Adapter);
-void ClearBSSdescpt(PWB32_ADAPTER Adapter, u16 i);
-u16 wBSSfindBssID(PWB32_ADAPTER Adapter, u8 *pbBssid);
-u16 wBSSfindDedicateCandidate(PWB32_ADAPTER Adapter, struct SSID_Element *psSsid, u8 *pbBssid);
-u16 wBSSfindMACaddr(PWB32_ADAPTER Adapter, u8 *pbMacAddr);
-u16 wBSSsearchMACaddr(PWB32_ADAPTER Adapter, u8 *pbMacAddr, u8 band);
-u16 wBSSaddScanData(PWB32_ADAPTER, u16, psRXDATA);
-u16 wBSSUpdateScanData(PWB32_ADAPTER Adapter, u16 wBssIdx, psRXDATA psRcvData);
-u16 wBSScreateIBSSdata(PWB32_ADAPTER Adapter, PWB_BSSDESCRIPTION psDesData);
-void DesiredRate2BSSdescriptor(PWB32_ADAPTER Adapter, PWB_BSSDESCRIPTION psDesData,
+void vBSSdescriptionInit(struct wb35_adapter * adapter);
+void vBSSfoundList(struct wb35_adapter * adapter);
+u8 boChanFilter(struct wb35_adapter * adapter, u8 ChanNo);
+u16 wBSSallocateEntry(struct wb35_adapter * adapter);
+u16 wBSSGetEntry(struct wb35_adapter * adapter);
+void vSimpleHouseKeeping(struct wb35_adapter * adapter);
+u16 wBSShouseKeeping(struct wb35_adapter * adapter);
+void ClearBSSdescpt(struct wb35_adapter * adapter, u16 i);
+u16 wBSSfindBssID(struct wb35_adapter * adapter, u8 *pbBssid);
+u16 wBSSfindDedicateCandidate(struct wb35_adapter * adapter, struct SSID_Element *psSsid, u8 *pbBssid);
+u16 wBSSfindMACaddr(struct wb35_adapter * adapter, u8 *pbMacAddr);
+u16 wBSSsearchMACaddr(struct wb35_adapter * adapter, u8 *pbMacAddr, u8 band);
+u16 wBSSaddScanData(struct wb35_adapter *, u16, psRXDATA);
+u16 wBSSUpdateScanData(struct wb35_adapter * adapter, u16 wBssIdx, psRXDATA psRcvData);
+u16 wBSScreateIBSSdata(struct wb35_adapter * adapter, PWB_BSSDESCRIPTION psDesData);
+void DesiredRate2BSSdescriptor(struct wb35_adapter * adapter, PWB_BSSDESCRIPTION psDesData,
 							 u8 *pBasicRateSet, u8 BasicRateCount,
 							 u8 *pOperationRateSet, u8 OperationRateCount);
-void DesiredRate2InfoElement(PWB32_ADAPTER Adapter, u8	*addr, u16 *iFildOffset,
+void DesiredRate2InfoElement(struct wb35_adapter * adapter, u8	*addr, u16 *iFildOffset,
 							 u8 *pBasicRateSet, u8 BasicRateCount,
 							 u8 *pOperationRateSet, u8 OperationRateCount);
-void BSSAddIBSSdata(PWB32_ADAPTER Adapter, PWB_BSSDESCRIPTION psDesData);
+void BSSAddIBSSdata(struct wb35_adapter * adapter, PWB_BSSDESCRIPTION psDesData);
 unsigned char boCmpMacAddr( u8 *, u8 *);
 unsigned char boCmpSSID(struct SSID_Element *psSSID1, struct SSID_Element *psSSID2);
-u16 wBSSfindSSID(PWB32_ADAPTER Adapter, struct SSID_Element *psSsid);
-u16 wRoamingQuery(PWB32_ADAPTER Adapter);
-void vRateToBitmap(PWB32_ADAPTER Adapter, u16 index);
-u8 bRateToBitmapIndex(PWB32_ADAPTER Adapter, u8 bRate);
+u16 wBSSfindSSID(struct wb35_adapter * adapter, struct SSID_Element *psSsid);
+u16 wRoamingQuery(struct wb35_adapter * adapter);
+void vRateToBitmap(struct wb35_adapter * adapter, u16 index);
+u8 bRateToBitmapIndex(struct wb35_adapter * adapter, u8 bRate);
 u8 bBitmapToRate(u8 i);
-unsigned char boIsERPsta(PWB32_ADAPTER Adapter, u16 i);
-unsigned char boCheckConnect(PWB32_ADAPTER Adapter);
-unsigned char boCheckSignal(PWB32_ADAPTER Adapter);
-void AddIBSSIe(PWB32_ADAPTER Adapter,PWB_BSSDESCRIPTION psDesData );//added by ws for WPA_None06/01/04
-void BssScanUpToDate(PWB32_ADAPTER Adapter);
-void BssUpToDate(PWB32_ADAPTER Adapter);
+unsigned char boIsERPsta(struct wb35_adapter * adapter, u16 i);
+unsigned char boCheckConnect(struct wb35_adapter * adapter);
+unsigned char boCheckSignal(struct wb35_adapter * adapter);
+void AddIBSSIe(struct wb35_adapter * adapter,PWB_BSSDESCRIPTION psDesData );//added by ws for WPA_None06/01/04
+void BssScanUpToDate(struct wb35_adapter * adapter);
+void BssUpToDate(struct wb35_adapter * adapter);
 void RateSort(u8 *RateArray, u8 num, u8 mode);
-void RateReSortForSRate(PWB32_ADAPTER Adapter, u8 *RateArray, u8 num);
-void Assemble_IE(PWB32_ADAPTER Adapter, u16 wBssIdx);
-void SetMaxTxRate(PWB32_ADAPTER Adapter);
+void RateReSortForSRate(struct wb35_adapter * adapter, u8 *RateArray, u8 num);
+void Assemble_IE(struct wb35_adapter * adapter, u16 wBssIdx);
+void SetMaxTxRate(struct wb35_adapter * adapter);
 
-void CreateWpaIE(PWB32_ADAPTER Adapter, u16* iFildOffset, u8 *msg, struct  Management_Frame* msgHeader,
+void CreateWpaIE(struct wb35_adapter * adapter, u16* iFildOffset, u8 *msg, struct  Management_Frame* msgHeader,
 				 struct Association_Request_Frame_Body* msgBody, u16 iMSindex); //added by WS 05/14/05
 
 #ifdef _WPA2_
-void CreateRsnIE(PWB32_ADAPTER Adapter, u16* iFildOffset, u8 *msg, struct  Management_Frame* msgHeader,
+void CreateRsnIE(struct wb35_adapter * adapter, u16* iFildOffset, u8 *msg, struct  Management_Frame* msgHeader,
 				 struct Association_Request_Frame_Body* msgBody, u16 iMSindex);//added by WS 05/14/05
 
-u16 SearchPmkid(PWB32_ADAPTER Adapter, struct  Management_Frame* msgHeader,
+u16 SearchPmkid(struct wb35_adapter * adapter, struct  Management_Frame* msgHeader,
 				   struct PMKID_Information_Element * AssoReq_PMKID );
 #endif
 
--- a/drivers/staging/winbond/ds_tkip.h
+++ b/drivers/staging/winbond/ds_tkip.h
@@ -26,8 +26,8 @@ typedef struct tkip
 } tkip_t;
 
 //void _append_data( u8 *pData, u16 size, tkip_t *p );
-void Mds_MicGet(  void* Adapter,  void* pRxLayer1,  u8 *pKey,  u8 *pMic );
-void Mds_MicFill(  void* Adapter,  void* pDes,  u8 *XmitBufAddress );
+void Mds_MicGet(  void* adapter,  void* pRxLayer1,  u8 *pKey,  u8 *pMic );
+void Mds_MicFill(  void* adapter,  void* pDes,  u8 *XmitBufAddress );
 
 
 
--- a/drivers/staging/winbond/linux/wb35reg.c
+++ b/drivers/staging/winbond/linux/wb35reg.c
@@ -386,11 +386,11 @@ Wb35Reg_EP0VM_start(  phw_data_t pHwData
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
-	if (OS_ATOMIC_INC( pHwData->Adapter, &reg->RegFireCount) == 1) {
+	if (OS_ATOMIC_INC( pHwData->adapter, &reg->RegFireCount) == 1) {
 		reg->EP0vm_state = VM_RUNNING;
 		Wb35Reg_EP0VM(pHwData);
 	} else
-		OS_ATOMIC_DEC( pHwData->Adapter, &reg->RegFireCount );
+		OS_ATOMIC_DEC( pHwData->adapter, &reg->RegFireCount );
 }
 
 void
@@ -447,7 +447,7 @@ Wb35Reg_EP0VM(phw_data_t pHwData )
 
  cleanup:
 	reg->EP0vm_state = VM_STOP;
-	OS_ATOMIC_DEC( pHwData->Adapter, &reg->RegFireCount );
+	OS_ATOMIC_DEC( pHwData->adapter, &reg->RegFireCount );
 }
 
 
@@ -465,7 +465,7 @@ Wb35Reg_EP0VM_complete(struct urb *urb)
 
 	if (pHwData->SurpriseRemove) { // Let WbWlanHalt to handle surprise remove
 		reg->EP0vm_state = VM_STOP;
-		OS_ATOMIC_DEC( pHwData->Adapter, &reg->RegFireCount );
+		OS_ATOMIC_DEC( pHwData->adapter, &reg->RegFireCount );
 	} else {
 		// Complete to send, remove the URB from the first
 		spin_lock_irq( &reg->EP0VM_spin_lock );
--- a/drivers/staging/winbond/linux/wb35rx.c
+++ b/drivers/staging/winbond/linux/wb35rx.c
@@ -16,11 +16,11 @@ void Wb35Rx_start(phw_data_t pHwData)
 	PWB35RX pWb35Rx = &pHwData->Wb35Rx;
 
 	// Allow only one thread to run into the Wb35Rx() function
-	if (OS_ATOMIC_INC(pHwData->Adapter, &pWb35Rx->RxFireCounter) == 1) {
+	if (OS_ATOMIC_INC(pHwData->adapter, &pWb35Rx->RxFireCounter) == 1) {
 		pWb35Rx->EP3vm_state = VM_RUNNING;
 		Wb35Rx(pHwData);
 	} else
-		OS_ATOMIC_DEC(pHwData->Adapter, &pWb35Rx->RxFireCounter);
+		OS_ATOMIC_DEC(pHwData->adapter, &pWb35Rx->RxFireCounter);
 }
 
 // This function cannot reentrain
@@ -81,7 +81,7 @@ void Wb35Rx(  phw_data_t pHwData )
 error:
 	// VM stop
 	pWb35Rx->EP3vm_state = VM_STOP;
-	OS_ATOMIC_DEC( pHwData->Adapter, &pWb35Rx->RxFireCounter );
+	OS_ATOMIC_DEC( pHwData->adapter, &pWb35Rx->RxFireCounter );
 }
 
 void Wb35Rx_Complete(struct urb *urb)
@@ -156,7 +156,7 @@ void Wb35Rx_Complete(struct urb *urb)
 
 error:
 	pWb35Rx->RxOwner[ RxBufferId ] = 1; // Set the owner to hardware
-	OS_ATOMIC_DEC( pHwData->Adapter, &pWb35Rx->RxFireCounter );
+	OS_ATOMIC_DEC( pHwData->adapter, &pWb35Rx->RxFireCounter );
 	pWb35Rx->EP3vm_state = VM_STOP;
 }
 
--- a/drivers/staging/winbond/linux/wb35tx.c
+++ b/drivers/staging/winbond/linux/wb35tx.c
@@ -25,20 +25,20 @@ void Wb35Tx_start(phw_data_t pHwData)
 	PWB35TX pWb35Tx = &pHwData->Wb35Tx;
 
 	// Allow only one thread to run into function
-	if (OS_ATOMIC_INC(pHwData->Adapter, &pWb35Tx->TxFireCounter) == 1) {
+	if (OS_ATOMIC_INC(pHwData->adapter, &pWb35Tx->TxFireCounter) == 1) {
 		pWb35Tx->EP4vm_state = VM_RUNNING;
 		Wb35Tx(pHwData);
 	} else
-		OS_ATOMIC_DEC( pHwData->Adapter, &pWb35Tx->TxFireCounter );
+		OS_ATOMIC_DEC( pHwData->adapter, &pWb35Tx->TxFireCounter );
 }
 
 
 void Wb35Tx(phw_data_t pHwData)
 {
 	PWB35TX		pWb35Tx = &pHwData->Wb35Tx;
-	PADAPTER	Adapter = pHwData->Adapter;
+	struct wb35_adapter *adapter = pHwData->adapter;
 	u8		*pTxBufferAddress;
-	PMDS		pMds = &Adapter->Mds;
+	PMDS		pMds = &adapter->Mds;
 	struct urb *	pUrb = (struct urb *)pWb35Tx->Tx4Urb;
 	int         	retv;
 	u32		SendIndex;
@@ -81,16 +81,16 @@ void Wb35Tx(phw_data_t pHwData)
 
  cleanup:
 	pWb35Tx->EP4vm_state = VM_STOP;
-	OS_ATOMIC_DEC( pHwData->Adapter, &pWb35Tx->TxFireCounter );
+	OS_ATOMIC_DEC( pHwData->adapter, &pWb35Tx->TxFireCounter );
 }
 
 
 void Wb35Tx_complete(struct urb * pUrb)
 {
 	phw_data_t	pHwData = pUrb->context;
-	PADAPTER	Adapter = (PADAPTER)pHwData->Adapter;
+	struct wb35_adapter *adapter = pHwData->adapter;
 	PWB35TX		pWb35Tx = &pHwData->Wb35Tx;
-	PMDS		pMds = &Adapter->Mds;
+	PMDS		pMds = &adapter->Mds;
 
 	printk("wb35: tx complete\n");
 	// Variable setting
@@ -113,12 +113,12 @@ void Wb35Tx_complete(struct urb * pUrb)
 		goto error;
 	}
 
-	Mds_Tx(Adapter);
+	Mds_Tx(adapter);
 	Wb35Tx(pHwData);
 	return;
 
 error:
-	OS_ATOMIC_DEC( pHwData->Adapter, &pWb35Tx->TxFireCounter );
+	OS_ATOMIC_DEC( pHwData->adapter, &pWb35Tx->TxFireCounter );
 	pWb35Tx->EP4vm_state = VM_STOP;
 }
 
@@ -211,12 +211,12 @@ void Wb35Tx_EP2VM_start(phw_data_t pHwDa
 	PWB35TX pWb35Tx = &pHwData->Wb35Tx;
 
 	// Allow only one thread to run into function
-	if (OS_ATOMIC_INC( pHwData->Adapter, &pWb35Tx->TxResultCount ) == 1) {
+	if (OS_ATOMIC_INC( pHwData->adapter, &pWb35Tx->TxResultCount ) == 1) {
 		pWb35Tx->EP2vm_state = VM_RUNNING;
 		Wb35Tx_EP2VM( pHwData );
 	}
 	else
-		OS_ATOMIC_DEC( pHwData->Adapter, &pWb35Tx->TxResultCount );
+		OS_ATOMIC_DEC( pHwData->adapter, &pWb35Tx->TxResultCount );
 }
 
 
@@ -252,7 +252,7 @@ void Wb35Tx_EP2VM(phw_data_t pHwData)
 	return;
 error:
 	pWb35Tx->EP2vm_state = VM_STOP;
-	OS_ATOMIC_DEC( pHwData->Adapter, &pWb35Tx->TxResultCount );
+	OS_ATOMIC_DEC( pHwData->adapter, &pWb35Tx->TxResultCount );
 }
 
 
@@ -260,7 +260,7 @@ void Wb35Tx_EP2VM_complete(struct urb * 
 {
 	phw_data_t	pHwData = pUrb->context;
 	T02_DESCRIPTOR	T02, TSTATUS;
-	PADAPTER	Adapter = (PADAPTER)pHwData->Adapter;
+	struct wb35_adapter *adapter = pHwData->adapter;
 	PWB35TX		pWb35Tx = &pHwData->Wb35Tx;
 	u32 *		pltmp = (u32 *)pWb35Tx->EP2_buf;
 	u32		i;
@@ -295,13 +295,13 @@ void Wb35Tx_EP2VM_complete(struct urb * 
 		T02.value |= ((cpu_to_le32(pltmp[i]) & 0xff) << 24);
 
 		TSTATUS.value = T02.value;  //20061009 anson's endian
-		Mds_SendComplete( Adapter, &TSTATUS );
+		Mds_SendComplete( adapter, &TSTATUS );
 		T02.value = cpu_to_le32(pltmp[i]) >> 8;
 	}
 
 	return;
 error:
-	OS_ATOMIC_DEC( pHwData->Adapter, &pWb35Tx->TxResultCount );
+	OS_ATOMIC_DEC( pHwData->adapter, &pWb35Tx->TxResultCount );
 	pWb35Tx->EP2vm_state = VM_STOP;
 }
 
--- a/drivers/staging/winbond/linux/wbusb.c
+++ b/drivers/staging/winbond/linux/wbusb.c
@@ -34,7 +34,7 @@ static struct ieee80211_channel wbsoft_c
 
 int wbsoft_enabled;
 struct ieee80211_hw *my_dev;
-PADAPTER my_adapter;
+struct wb35_adapter * my_adapter;
 
 static int wbsoft_add_interface(struct ieee80211_hw *dev,
 				 struct ieee80211_if_init_conf *conf)
@@ -187,7 +187,7 @@ struct wbsoft_priv {
 
 static int wb35_probe(struct usb_interface *intf, const struct usb_device_id *id_table)
 {
-	PADAPTER	Adapter;
+	struct wb35_adapter *adapter;
 	PWBLINUX	pWbLinux;
 	PWBUSB		pWbUsb;
         struct usb_host_interface *interface;
@@ -211,11 +211,11 @@ static int wb35_probe(struct usb_interfa
 	if (ltmp)  // Is already initialized?
 		goto error;
 
-	Adapter = kzalloc(sizeof(ADAPTER), GFP_KERNEL);
+	adapter = kzalloc(sizeof(*adapter), GFP_KERNEL);
 
-	my_adapter = Adapter;
-	pWbLinux = &Adapter->WbLinux;
-	pWbUsb = &Adapter->sHwData.WbUsb;
+	my_adapter = adapter;
+	pWbLinux = &adapter->WbLinux;
+	pWbUsb = &adapter->sHwData.WbUsb;
 	pWbUsb->udev = udev;
 
         interface = intf->cur_altsetting;
@@ -226,7 +226,7 @@ static int wb35_probe(struct usb_interfa
 		pWbUsb->IsUsb20 = 1;
 	}
 
-	if (!WbWLanInitialize(Adapter)) {
+	if (!WbWLanInitialize(adapter)) {
 		printk("[w35und]WbWLanInitialize fail\n");
 		goto error;
 	}
@@ -248,7 +248,7 @@ static int wb35_probe(struct usb_interfa
 
 		SET_IEEE80211_DEV(dev, &udev->dev);
 		{
-			phw_data_t pHwData = &Adapter->sHwData;
+			phw_data_t pHwData = &adapter->sHwData;
 			unsigned char		dev_addr[MAX_ADDR_LEN];
 			hal_get_permanent_address(pHwData, dev_addr);
 			SET_IEEE80211_PERM_ADDR(dev, dev_addr);
@@ -284,7 +284,7 @@ static int wb35_probe(struct usb_interfa
 		BUG_ON(res);
 	}
 
-	usb_set_intfdata( intf, Adapter );
+	usb_set_intfdata( intf, adapter );
 
 	printk("[w35und] _probe OK\n");
 	return 0;
@@ -335,13 +335,13 @@ WbUsb_destroy(phw_data_t pHwData)
 static void wb35_disconnect(struct usb_interface *intf)
 {
 	PWBLINUX pWbLinux;
-	PADAPTER Adapter = usb_get_intfdata(intf);
+	struct wb35_adapter * adapter = usb_get_intfdata(intf);
 	usb_set_intfdata(intf, NULL);
 
-        pWbLinux = &Adapter->WbLinux;
+        pWbLinux = &adapter->WbLinux;
 
 	// Card remove
-	WbWlanHalt(Adapter);
+	WbWlanHalt(adapter);
 
 }
 
--- a/drivers/staging/winbond/linux/wbusb_f.h
+++ b/drivers/staging/winbond/linux/wbusb_f.h
@@ -13,7 +13,7 @@
 
 unsigned char WbUsb_initial(phw_data_t pHwData);
 void WbUsb_destroy(phw_data_t pHwData);
-unsigned char WbWLanInitialize(PADAPTER Adapter);
+unsigned char WbWLanInitialize(struct wb35_adapter *adapter);
 #define	WbUsb_Stop( _A )
 
 #define wb_usb_submit_urb(_A) usb_submit_urb(_A, GFP_ATOMIC)
--- a/drivers/staging/winbond/localpara.h
+++ b/drivers/staging/winbond/localpara.h
@@ -25,7 +25,7 @@
 #define LOCAL_UNKNOWN_5_CHANNEL_NUM			34	//not include 165
 
 
-#define psLOCAL			(&(Adapter->sLocalPara))
+#define psLOCAL			(&(adapter->sLocalPara))
 
 #define MODE_802_11_BG			0
 #define MODE_802_11_A			1
--- a/drivers/staging/winbond/mds.c
+++ b/drivers/staging/winbond/mds.c
@@ -1,9 +1,9 @@
 #include "os_common.h"
 
 void
-Mds_reset_descriptor(PADAPTER Adapter)
+Mds_reset_descriptor(struct wb35_adapter * adapter)
 {
-	PMDS pMds = &Adapter->Mds;
+	PMDS pMds = &adapter->Mds;
 
 	pMds->TxPause = 0;
 	pMds->TxThreadCount = 0;
@@ -14,30 +14,30 @@ Mds_reset_descriptor(PADAPTER Adapter)
 }
 
 unsigned char
-Mds_initial(PADAPTER Adapter)
+Mds_initial(struct wb35_adapter * adapter)
 {
-	PMDS pMds = &Adapter->Mds;
+	PMDS pMds = &adapter->Mds;
 
 	pMds->TxPause = FALSE;
 	pMds->TxRTSThreshold = DEFAULT_RTSThreshold;
 	pMds->TxFragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD;
 
-	vRxTimerInit(Adapter);//for WPA countermeasure
+	vRxTimerInit(adapter);//for WPA countermeasure
 
-	return hal_get_tx_buffer( &Adapter->sHwData, &pMds->pTxBuffer );
+	return hal_get_tx_buffer( &adapter->sHwData, &pMds->pTxBuffer );
 }
 
 void
-Mds_Destroy(PADAPTER Adapter)
+Mds_Destroy(struct wb35_adapter * adapter)
 {
-	vRxTimerStop(Adapter);
+	vRxTimerStop(adapter);
 }
 
 void
-Mds_Tx(PADAPTER Adapter)
+Mds_Tx(struct wb35_adapter * adapter)
 {
-	phw_data_t	pHwData = &Adapter->sHwData;
-	PMDS		pMds = &Adapter->Mds;
+	phw_data_t	pHwData = &adapter->sHwData;
+	PMDS		pMds = &adapter->Mds;
 	DESCRIPTOR	TxDes;
 	PDESCRIPTOR	pTxDes = &TxDes;
 	u8		*XmitBufAddress;
@@ -52,7 +52,7 @@ Mds_Tx(PADAPTER Adapter)
 		return;
 
 	//Only one thread can be run here
-	if (!OS_ATOMIC_INC( Adapter, &pMds->TxThreadCount) == 1)
+	if (!OS_ATOMIC_INC( adapter, &pMds->TxThreadCount) == 1)
 		goto cleanup;
 
 	// Start to fill the data
@@ -69,7 +69,7 @@ Mds_Tx(PADAPTER Adapter)
 		XmitBufSize = 0;
 		FillCount = 0;
 		do {
-			PacketSize = Adapter->sMlmeFrame.len;
+			PacketSize = adapter->sMlmeFrame.len;
 			if (!PacketSize)
 				break;
 
@@ -98,10 +98,10 @@ Mds_Tx(PADAPTER Adapter)
 			pMds->TxDesIndex++;
 			pMds->TxDesIndex %= MAX_USB_TX_DESCRIPTOR;
 
-			MLME_GetNextPacket( Adapter, pTxDes );
+			MLME_GetNextPacket( adapter, pTxDes );
 
 			// Copy header. 8byte USB + 24byte 802.11Hdr. Set TxRate, Preamble type
-			Mds_HeaderCopy( Adapter, pTxDes, XmitBufAddress );
+			Mds_HeaderCopy( adapter, pTxDes, XmitBufAddress );
 
 			// For speed up Key setting
 			if (pTxDes->EapFix) {
@@ -112,16 +112,16 @@ Mds_Tx(PADAPTER Adapter)
 			}
 
 			// Copy (fragment) frame body, and set USB, 802.11 hdr flag
-			CurrentSize = Mds_BodyCopy(Adapter, pTxDes, XmitBufAddress);
+			CurrentSize = Mds_BodyCopy(adapter, pTxDes, XmitBufAddress);
 
 			// Set RTS/CTS and Normal duration field into buffer
-			Mds_DurationSet(Adapter, pTxDes, XmitBufAddress);
+			Mds_DurationSet(adapter, pTxDes, XmitBufAddress);
 
 			//
 			// Calculation MIC from buffer which maybe fragment, then fill into temporary address 8 byte
 			// 931130.5.e
 			if (MICAdd)
-				Mds_MicFill( Adapter, pTxDes, XmitBufAddress );
+				Mds_MicFill( adapter, pTxDes, XmitBufAddress );
 
 			//Shift to the next address
 			XmitBufSize += CurrentSize;
@@ -133,7 +133,7 @@ Mds_Tx(PADAPTER Adapter)
 				pMds->TxToggle = TRUE;
 
 			// Get packet to transmit completed, 1:TESTSTA 2:MLME 3: Ndis data
-			MLME_SendComplete(Adapter, 0, TRUE);
+			MLME_SendComplete(adapter, 0, TRUE);
 
 			// Software TSC count 20060214
 			pMds->TxTsc++;
@@ -172,14 +172,14 @@ Mds_Tx(PADAPTER Adapter)
 		Wb35Tx_start(pHwData);
 
  cleanup:
-	OS_ATOMIC_DEC( Adapter, &pMds->TxThreadCount );
+	OS_ATOMIC_DEC( adapter, &pMds->TxThreadCount );
 }
 
 void
-Mds_SendComplete(PADAPTER Adapter, PT02_DESCRIPTOR pT02)
+Mds_SendComplete(struct wb35_adapter * adapter, PT02_DESCRIPTOR pT02)
 {
-	PMDS	pMds = &Adapter->Mds;
-	phw_data_t	pHwData = &Adapter->sHwData;
+	PMDS	pMds = &adapter->Mds;
+	phw_data_t	pHwData = &adapter->sHwData;
 	u8	PacketId = (u8)pT02->T02_Tx_PktID;
 	unsigned char	SendOK = TRUE;
 	u8	RetryCount, TxRate;
@@ -205,7 +205,7 @@ Mds_SendComplete(PADAPTER Adapter, PT02_
 				#ifdef _PE_STATE_DUMP_
 				WBDEBUG(("dto_tx_retry_count =%d\n", pHwData->dto_tx_retry_count));
 				#endif
-				MTO_SetTxCount(Adapter, TxRate, RetryCount);
+				MTO_SetTxCount(adapter, TxRate, RetryCount);
 			}
 			pHwData->dto_tx_frag_count += (RetryCount+1);
 
@@ -219,7 +219,7 @@ Mds_SendComplete(PADAPTER Adapter, PT02_
 		} else {
 			if (pT02->T02_effective_transmission_rate)
 				pHwData->tx_ETR_count++;
-			MTO_SetTxCount(Adapter, TxRate, RetryCount);
+			MTO_SetTxCount(adapter, TxRate, RetryCount);
 		}
 
 		// Clear send result buffer
@@ -229,9 +229,9 @@ Mds_SendComplete(PADAPTER Adapter, PT02_
 }
 
 void
-Mds_HeaderCopy(PADAPTER Adapter, PDESCRIPTOR pDes, u8 *TargetBuffer)
+Mds_HeaderCopy(struct wb35_adapter * adapter, PDESCRIPTOR pDes, u8 *TargetBuffer)
 {
-	PMDS	pMds = &Adapter->Mds;
+	PMDS	pMds = &adapter->Mds;
 	u8	*src_buffer = pDes->buffer_address[0];//931130.5.g
 	PT00_DESCRIPTOR	pT00;
 	PT01_DESCRIPTOR	pT01;
@@ -326,10 +326,10 @@ Mds_HeaderCopy(PADAPTER Adapter, PDESCRI
 
 // The function return the 4n size of usb pk
 u16
-Mds_BodyCopy(PADAPTER Adapter, PDESCRIPTOR pDes, u8 *TargetBuffer)
+Mds_BodyCopy(struct wb35_adapter * adapter, PDESCRIPTOR pDes, u8 *TargetBuffer)
 {
 	PT00_DESCRIPTOR	pT00;
-	PMDS	pMds = &Adapter->Mds;
+	PMDS	pMds = &adapter->Mds;
 	u8	*buffer;
 	u8	*src_buffer;
 	u8	*pctmp;
@@ -429,7 +429,7 @@ Mds_BodyCopy(PADAPTER Adapter, PDESCRIPT
 
 
 void
-Mds_DurationSet(  PADAPTER Adapter,  PDESCRIPTOR pDes,  u8 *buffer )
+Mds_DurationSet(  struct wb35_adapter * adapter,  PDESCRIPTOR pDes,  u8 *buffer )
 {
 	PT00_DESCRIPTOR	pT00;
 	PT01_DESCRIPTOR	pT01;
@@ -624,9 +624,9 @@ Mds_DurationSet(  PADAPTER Adapter,  PDE
 
 }
 
-void MDS_EthernetPacketReceive(  PADAPTER Adapter,  PRXLAYER1 pRxLayer1 )
+void MDS_EthernetPacketReceive(  struct wb35_adapter * adapter,  PRXLAYER1 pRxLayer1 )
 {
-		OS_RECEIVE_PACKET_INDICATE( Adapter, pRxLayer1 );
+		OS_RECEIVE_PACKET_INDICATE( adapter, pRxLayer1 );
 }
 
 
--- a/drivers/staging/winbond/mds_f.h
+++ b/drivers/staging/winbond/mds_f.h
@@ -1,33 +1,33 @@
-unsigned char Mds_initial(  PADAPTER Adapter );
-void Mds_Destroy(  PADAPTER Adapter );
-void Mds_Tx(  PADAPTER Adapter );
-void Mds_HeaderCopy(  PADAPTER Adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
-u16 Mds_BodyCopy(  PADAPTER Adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
-void Mds_DurationSet(  PADAPTER Adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
-void Mds_SendComplete(  PADAPTER Adapter,  PT02_DESCRIPTOR pT02 );
-void Mds_MpduProcess(  PADAPTER Adapter,  PDESCRIPTOR pRxDes );
-void Mds_reset_descriptor(  PADAPTER Adapter );
+unsigned char Mds_initial(  struct wb35_adapter *adapter );
+void Mds_Destroy(  struct wb35_adapter *adapter );
+void Mds_Tx(  struct wb35_adapter *adapter );
+void Mds_HeaderCopy(  struct wb35_adapter *adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
+u16 Mds_BodyCopy(  struct wb35_adapter *adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
+void Mds_DurationSet(  struct wb35_adapter *adapter,  PDESCRIPTOR pDes,  u8 *TargetBuffer );
+void Mds_SendComplete(  struct wb35_adapter *adapter,  PT02_DESCRIPTOR pT02 );
+void Mds_MpduProcess(  struct wb35_adapter *adapter,  PDESCRIPTOR pRxDes );
+void Mds_reset_descriptor(  struct wb35_adapter *adapter );
 extern void DataDmp(u8 *pdata, u32 len, u32 offset);
 
 
-void vRxTimerInit(PWB32_ADAPTER Adapter);
-void vRxTimerStart(PWB32_ADAPTER Adapter, int timeout_value);
-void RxTimerHandler_1a( PADAPTER Adapter);
-void vRxTimerStop(PWB32_ADAPTER Adapter);
+void vRxTimerInit(struct wb35_adapter *adapter);
+void vRxTimerStart(struct wb35_adapter *adapter, int timeout_value);
+void RxTimerHandler_1a( struct wb35_adapter *adapter);
+void vRxTimerStop(struct wb35_adapter *adapter);
 void RxTimerHandler( void*			SystemSpecific1,
-					   PWB32_ADAPTER 	Adapter,
+					   struct wb35_adapter * 	adapter,
 					   void*			SystemSpecific2,
 					   void*			SystemSpecific3);
 
 
 // For Asynchronous indicating. The routine collocates with USB.
-void Mds_MsduProcess(  PWB32_ADAPTER Adapter,  PRXLAYER1 pRxLayer1,  u8 SlotIndex);
+void Mds_MsduProcess(  struct wb35_adapter *adapter,  PRXLAYER1 pRxLayer1,  u8 SlotIndex);
 
 // For data frame sending 20060802
-u16 MDS_GetPacketSize(  PADAPTER Adapter );
-void MDS_GetNextPacket(  PADAPTER Adapter,  PDESCRIPTOR pDes );
-void MDS_GetNextPacketComplete(  PADAPTER Adapter,  PDESCRIPTOR pDes );
-void MDS_SendResult(  PADAPTER Adapter,  u8 PacketId,  unsigned char SendOK );
-void MDS_EthernetPacketReceive(  PADAPTER Adapter,  PRXLAYER1 pRxLayer1 );
+u16 MDS_GetPacketSize(  struct wb35_adapter *adapter );
+void MDS_GetNextPacket(  struct wb35_adapter *adapter,  PDESCRIPTOR pDes );
+void MDS_GetNextPacketComplete(  struct wb35_adapter *adapter,  PDESCRIPTOR pDes );
+void MDS_SendResult(  struct wb35_adapter *adapter,  u8 PacketId,  unsigned char SendOK );
+void MDS_EthernetPacketReceive(  struct wb35_adapter *adapter,  PRXLAYER1 pRxLayer1 );
 
 
--- a/drivers/staging/winbond/mds_s.h
+++ b/drivers/staging/winbond/mds_s.h
@@ -21,20 +21,20 @@
 #define CURRENT_PAIRWISE_KEY			psSME->tx_mic_key
 #define CURRENT_GROUP_KEY				psSME->group_tx_mic_key
 #define CURRENT_ENCRYPT_STATUS			psSME->encrypt_status
-#define CURRENT_WEP_ID					Adapter->sSmePara._dot11WEPDefaultKeyID
-#define CURRENT_CONTROL_PORT_BLOCK		( psSME->wpa_ok!=1 || (Adapter->Mds.boCounterMeasureBlock==1 && (CURRENT_ENCRYPT_STATUS==ENCRYPT_TKIP)) )
-#define CURRENT_FRAGMENT_THRESHOLD		(Adapter->Mds.TxFragmentThreshold & ~0x1)
+#define CURRENT_WEP_ID					adapter->sSmePara._dot11WEPDefaultKeyID
+#define CURRENT_CONTROL_PORT_BLOCK		( psSME->wpa_ok!=1 || (adapter->Mds.boCounterMeasureBlock==1 && (CURRENT_ENCRYPT_STATUS==ENCRYPT_TKIP)) )
+#define CURRENT_FRAGMENT_THRESHOLD		(adapter->Mds.TxFragmentThreshold & ~0x1)
 #define CURRENT_PREAMBLE_MODE			psLOCAL->boShortPreamble?WLAN_PREAMBLE_TYPE_SHORT:WLAN_PREAMBLE_TYPE_LONG
 #define CURRENT_LINK_ON					OS_LINK_STATUS
-#define CURRENT_TX_RATE					Adapter->sLocalPara.CurrentTxRate
-#define CURRENT_FALL_BACK_TX_RATE		Adapter->sLocalPara.CurrentTxFallbackRate
-#define CURRENT_TX_RATE_FOR_MNG			Adapter->sLocalPara.CurrentTxRateForMng
+#define CURRENT_TX_RATE					adapter->sLocalPara.CurrentTxRate
+#define CURRENT_FALL_BACK_TX_RATE		adapter->sLocalPara.CurrentTxFallbackRate
+#define CURRENT_TX_RATE_FOR_MNG			adapter->sLocalPara.CurrentTxRateForMng
 #define CURRENT_PROTECT_MECHANISM		psLOCAL->boProtectMechanism
-#define CURRENT_RTS_THRESHOLD			Adapter->Mds.TxRTSThreshold
+#define CURRENT_RTS_THRESHOLD			adapter->Mds.TxRTSThreshold
 
-#define MIB_GS_XMIT_OK_INC				Adapter->sLocalPara.GS_XMIT_OK++
-#define MIB_GS_RCV_OK_INC				Adapter->sLocalPara.GS_RCV_OK++
-#define MIB_GS_XMIT_ERROR_INC			Adapter->sLocalPara.GS_XMIT_ERROR
+#define MIB_GS_XMIT_OK_INC				adapter->sLocalPara.GS_XMIT_OK++
+#define MIB_GS_RCV_OK_INC				adapter->sLocalPara.GS_RCV_OK++
+#define MIB_GS_XMIT_ERROR_INC			adapter->sLocalPara.GS_XMIT_ERROR
 
 //---------- TX -----------------------------------
 #define ETHERNET_TX_DESCRIPTORS         MAX_USB_TX_BUFFER_NUMBER
--- a/drivers/staging/winbond/mlme_mib.h
+++ b/drivers/staging/winbond/mlme_mib.h
@@ -22,15 +22,15 @@
 //   Set the dot11ExcludeUnencrypted value.
 //
 // Arguments:
-//   Adapter        - The pointer to the miniport adapter context.
+//   adapter        - The pointer to the miniport adapter context.
 //   ExUnencrypted  - unsigned char type. The value to be set.
 //
 // Return values:
 //   None.
 //============================================================================
-#define MLMESetExcludeUnencrypted(Adapter, ExUnencrypted)     \
+#define MLMESetExcludeUnencrypted(adapter, ExUnencrypted)     \
 {                                                              \
-    (Adapter)->sLocalPara.ExcludeUnencrypted = ExUnencrypted;             \
+    (adapter)->sLocalPara.ExcludeUnencrypted = ExUnencrypted;             \
 }
 
 //============================================================================
@@ -40,12 +40,12 @@
 //   Get the dot11ExcludeUnencrypted value.
 //
 // Arguments:
-//   Adapter        - The pointer to the miniport adapter context.
+//   adapter        - The pointer to the miniport adapter context.
 //
 // Return values:
 //   unsigned char type. The current dot11ExcludeUnencrypted value.
 //============================================================================
-#define MLMEGetExcludeUnencrypted(Adapter) ((unsigned char) (Adapter)->sLocalPara.ExcludeUnencrypted)
+#define MLMEGetExcludeUnencrypted(adapter) ((unsigned char) (adapter)->sLocalPara.ExcludeUnencrypted)
 
 //============================================================================
 // MLMESetMaxReceiveLifeTime --
@@ -54,15 +54,15 @@
 //   Set the dot11MaxReceiveLifeTime value.
 //
 // Arguments:
-//   Adapter        - The pointer to the miniport adapter context.
+//   adapter        - The pointer to the miniport adapter context.
 //   ReceiveLifeTime- u32 type. The value to be set.
 //
 // Return values:
 //   None.
 //============================================================================
-#define MLMESetMaxReceiveLifeTime(Adapter, ReceiveLifeTime)    \
+#define MLMESetMaxReceiveLifeTime(adapter, ReceiveLifeTime)    \
 {                                                               \
-    (Adapter)->Mds.MaxReceiveTime = ReceiveLifeTime;                \
+    (adapter)->Mds.MaxReceiveTime = ReceiveLifeTime;                \
 }
 
 //============================================================================
@@ -72,12 +72,12 @@
 //   Get the dot11MaxReceiveLifeTime value.
 //
 // Arguments:
-//   Adapter        - The pointer to the miniport adapter context.
+//   adapter        - The pointer to the miniport adapter context.
 //
 // Return values:
 //   u32 type. The current dot11MaxReceiveLifeTime value.
 //============================================================================
-#define MLMEGetMaxReceiveLifeTime(Adapter) ((u32) (Adapter)->Mds.MaxReceiveTime)
+#define MLMEGetMaxReceiveLifeTime(adapter) ((u32) (adapter)->Mds.MaxReceiveTime)
 
 #endif
 
--- a/drivers/staging/winbond/mlmetxrx.c
+++ b/drivers/staging/winbond/mlmetxrx.c
@@ -17,23 +17,23 @@
 //============================================================================
 #include "os_common.h"
 
-void MLMEResetTxRx(PWB32_ADAPTER Adapter)
+void MLMEResetTxRx(struct wb35_adapter * adapter)
 {
 	s32     i;
 
 	// Reset the interface between MDS and MLME
 	for (i = 0; i < MAX_NUM_TX_MMPDU; i++)
-		Adapter->sMlmeFrame.TxMMPDUInUse[i] = FALSE;
+		adapter->sMlmeFrame.TxMMPDUInUse[i] = FALSE;
 	for (i = 0; i < MAX_NUM_RX_MMPDU; i++)
-		Adapter->sMlmeFrame.SaveRxBufSlotInUse[i] = FALSE;
+		adapter->sMlmeFrame.SaveRxBufSlotInUse[i] = FALSE;
 
-	Adapter->sMlmeFrame.wNumRxMMPDUInMLME   = 0;
-	Adapter->sMlmeFrame.wNumRxMMPDUDiscarded = 0;
-	Adapter->sMlmeFrame.wNumRxMMPDU          = 0;
-	Adapter->sMlmeFrame.wNumTxMMPDUDiscarded = 0;
-	Adapter->sMlmeFrame.wNumTxMMPDU          = 0;
-	Adapter->sLocalPara.boCCAbusy    = FALSE;
-	Adapter->sLocalPara.iPowerSaveMode     = PWR_ACTIVE;     // Power active
+	adapter->sMlmeFrame.wNumRxMMPDUInMLME   = 0;
+	adapter->sMlmeFrame.wNumRxMMPDUDiscarded = 0;
+	adapter->sMlmeFrame.wNumRxMMPDU          = 0;
+	adapter->sMlmeFrame.wNumTxMMPDUDiscarded = 0;
+	adapter->sMlmeFrame.wNumTxMMPDU          = 0;
+	adapter->sLocalPara.boCCAbusy    = FALSE;
+	adapter->sLocalPara.iPowerSaveMode     = PWR_ACTIVE;     // Power active
 }
 
 //=============================================================================
@@ -45,7 +45,7 @@ void MLMEResetTxRx(PWB32_ADAPTER Adapter
 //    the size MAX_MMPDU_SIZE for a MMPDU.
 //
 //  Arguments:
-//    Adapter   - pointer to the miniport adapter context.
+//    adapter   - pointer to the miniport adapter context.
 //
 //	Return value:
 //    NULL     : No available data buffer available
@@ -53,51 +53,51 @@ void MLMEResetTxRx(PWB32_ADAPTER Adapter
 //=============================================================================
 
 /* FIXME: Should this just be replaced with kmalloc() and kfree()? */
-u8 *MLMEGetMMPDUBuffer(PWB32_ADAPTER Adapter)
+u8 *MLMEGetMMPDUBuffer(struct wb35_adapter * adapter)
 {
 	s32 i;
 	u8 *returnVal;
 
 	for (i = 0; i< MAX_NUM_TX_MMPDU; i++) {
-		if (Adapter->sMlmeFrame.TxMMPDUInUse[i] == FALSE)
+		if (adapter->sMlmeFrame.TxMMPDUInUse[i] == FALSE)
 			break;
 	}
 	if (i >= MAX_NUM_TX_MMPDU) return NULL;
 
-	returnVal = (u8 *)&(Adapter->sMlmeFrame.TxMMPDU[i]);
-	Adapter->sMlmeFrame.TxMMPDUInUse[i] = TRUE;
+	returnVal = (u8 *)&(adapter->sMlmeFrame.TxMMPDU[i]);
+	adapter->sMlmeFrame.TxMMPDUInUse[i] = TRUE;
 
 	return returnVal;
 }
 
 //=============================================================================
-u8 MLMESendFrame(PWB32_ADAPTER Adapter, u8 *pMMPDU, u16 len, u8 DataType)
+u8 MLMESendFrame(struct wb35_adapter * adapter, u8 *pMMPDU, u16 len, u8 DataType)
 /*	DataType : FRAME_TYPE_802_11_MANAGEMENT, FRAME_TYPE_802_11_MANAGEMENT_CHALLENGE,
 				FRAME_TYPE_802_11_DATA */
 {
-	if (Adapter->sMlmeFrame.IsInUsed != PACKET_FREE_TO_USE) {
-		Adapter->sMlmeFrame.wNumTxMMPDUDiscarded++;
+	if (adapter->sMlmeFrame.IsInUsed != PACKET_FREE_TO_USE) {
+		adapter->sMlmeFrame.wNumTxMMPDUDiscarded++;
 		return FALSE;
 	}
-	Adapter->sMlmeFrame.IsInUsed = PACKET_COME_FROM_MLME;
+	adapter->sMlmeFrame.IsInUsed = PACKET_COME_FROM_MLME;
 
 	// Keep information for sending
-	Adapter->sMlmeFrame.pMMPDU = pMMPDU;
-	Adapter->sMlmeFrame.DataType = DataType;
+	adapter->sMlmeFrame.pMMPDU = pMMPDU;
+	adapter->sMlmeFrame.DataType = DataType;
 	// len must be the last setting due to QUERY_SIZE_SECOND of Mds
-	Adapter->sMlmeFrame.len = len;
-	Adapter->sMlmeFrame.wNumTxMMPDU++;
+	adapter->sMlmeFrame.len = len;
+	adapter->sMlmeFrame.wNumTxMMPDU++;
 
 	// H/W will enter power save by set the register. S/W don't send null frame
 	//with PWRMgt bit enbled to enter power save now.
 
 	// Transmit NDIS packet
-	Mds_Tx(Adapter);
+	Mds_Tx(adapter);
 	return TRUE;
 }
 
 void
-MLME_GetNextPacket(PADAPTER Adapter, PDESCRIPTOR pDes)
+MLME_GetNextPacket(struct wb35_adapter * adapter, PDESCRIPTOR pDes)
 {
 #define DESCRIPTOR_ADD_BUFFER( _D, _A, _S ) \
 {\
@@ -109,21 +109,21 @@ MLME_GetNextPacket(PADAPTER Adapter, PDE
 	_D->buffer_number++;\
 }
 
-	DESCRIPTOR_ADD_BUFFER( pDes, Adapter->sMlmeFrame.pMMPDU, Adapter->sMlmeFrame.len );
-	pDes->Type = Adapter->sMlmeFrame.DataType;
+	DESCRIPTOR_ADD_BUFFER( pDes, adapter->sMlmeFrame.pMMPDU, adapter->sMlmeFrame.len );
+	pDes->Type = adapter->sMlmeFrame.DataType;
 }
 
-void MLMEfreeMMPDUBuffer(PWB32_ADAPTER Adapter, s8 *pData)
+void MLMEfreeMMPDUBuffer(struct wb35_adapter * adapter, s8 *pData)
 {
 	int i;
 
 	// Reclaim the data buffer
 	for (i = 0; i < MAX_NUM_TX_MMPDU; i++) {
-		if (pData == (s8 *)&(Adapter->sMlmeFrame.TxMMPDU[i]))
+		if (pData == (s8 *)&(adapter->sMlmeFrame.TxMMPDU[i]))
 			break;
 	}
-	if (Adapter->sMlmeFrame.TxMMPDUInUse[i])
-		Adapter->sMlmeFrame.TxMMPDUInUse[i] = FALSE;
+	if (adapter->sMlmeFrame.TxMMPDUInUse[i])
+		adapter->sMlmeFrame.TxMMPDUInUse[i] = FALSE;
 	else  {
 		// Something wrong
 		// PD43 Add debug code here???
@@ -131,19 +131,19 @@ void MLMEfreeMMPDUBuffer(PWB32_ADAPTER A
 }
 
 void
-MLME_SendComplete(PADAPTER Adapter, u8 PacketID, unsigned char SendOK)
+MLME_SendComplete(struct wb35_adapter * adapter, u8 PacketID, unsigned char SendOK)
 {
 	MLME_TXCALLBACK	TxCallback;
 
     // Reclaim the data buffer
-	Adapter->sMlmeFrame.len = 0;
-	MLMEfreeMMPDUBuffer( Adapter, Adapter->sMlmeFrame.pMMPDU );
+	adapter->sMlmeFrame.len = 0;
+	MLMEfreeMMPDUBuffer( adapter, adapter->sMlmeFrame.pMMPDU );
 
 
 	TxCallback.bResult = MLME_SUCCESS;
 
 	// Return resource
-	Adapter->sMlmeFrame.IsInUsed = PACKET_FREE_TO_USE;
+	adapter->sMlmeFrame.IsInUsed = PACKET_FREE_TO_USE;
 }
 
 
--- a/drivers/staging/winbond/mlmetxrx_f.h
+++ b/drivers/staging/winbond/mlmetxrx_f.h
@@ -10,30 +10,30 @@
 
 void
 MLMEProcThread(
-     PWB32_ADAPTER    Adapter
+     struct wb35_adapter *    adapter
 	);
 
-void MLMEResetTxRx( PWB32_ADAPTER Adapter);
+void MLMEResetTxRx( struct wb35_adapter * adapter);
 
 u8 *
 MLMEGetMMPDUBuffer(
-     PWB32_ADAPTER    Adapter
+     struct wb35_adapter *    adapter
    );
 
-void MLMEfreeMMPDUBuffer( PWB32_ADAPTER Adapter,  s8 * pData);
+void MLMEfreeMMPDUBuffer( struct wb35_adapter * adapter,  s8 * pData);
 
-void MLME_GetNextPacket(  PADAPTER Adapter,  PDESCRIPTOR pDes );
-u8 MLMESendFrame( PWB32_ADAPTER Adapter,
+void MLME_GetNextPacket(  struct wb35_adapter * adapter,  PDESCRIPTOR pDes );
+u8 MLMESendFrame( struct wb35_adapter * adapter,
 					u8	*pMMPDU,
 					u16	len,
 					 u8	DataType);
 
 void
-MLME_SendComplete(  PWB32_ADAPTER Adapter,  u8 PacketID,  unsigned char SendOK );
+MLME_SendComplete(  struct wb35_adapter * adapter,  u8 PacketID,  unsigned char SendOK );
 
 void
 MLMERcvFrame(
-     PWB32_ADAPTER    Adapter,
+     struct wb35_adapter *    adapter,
      PRXBUFFER        pRxBufferArray,
      u8            NumOfBuffer,
      u8            ReturnSlotIndex
@@ -41,11 +41,11 @@ MLMERcvFrame(
 
 void
 MLMEReturnPacket(
-     PWB32_ADAPTER    Adapter,
+     struct wb35_adapter *    adapter,
      u8 *          pRxBufer
    );
 #ifdef _IBSS_BEACON_SEQ_STICK_
-s8 SendBCNullData(PWB32_ADAPTER Adapter, u16 wIdx);
+s8 SendBCNullData(struct wb35_adapter * adapter, u16 wIdx);
 #endif
 
 #endif
--- a/drivers/staging/winbond/mto.c
+++ b/drivers/staging/winbond/mto.c
@@ -353,7 +353,7 @@ void MTO_SetDTORateRange(MTO_FUNC_INPUT,
 //    This function should be invoked during system initialization.
 //
 //  Arguments:
-//    Adapter      - The pointer to the Miniport Adapter Context
+//    adapter      - The pointer to the Miniport adapter Context
 //
 //  Return Value:
 //    None
@@ -393,8 +393,8 @@ void MTO_Init(MTO_FUNC_INPUT)
     MTO_SQ_ANT(0)       = 0;
     MTO_SQ_ANT(1)       = 0;
     MTO_ANT_DIVERSITY() = MTO_ANTENNA_DIVERSITY_ON;
-    //CardSet_AntennaDiversity(Adapter, MTO_ANT_DIVERSITY());
-    //PLMESetAntennaDiversity( Adapter, MTO_ANT_DIVERSITY());
+    //CardSet_AntennaDiversity(adapter, MTO_ANT_DIVERSITY());
+    //PLMESetAntennaDiversity( adapter, MTO_ANT_DIVERSITY());
 
     MTO_AGING_TIMEOUT() = 0;//MTO_TMR_AGING() / MTO_TMR_PERIODIC();
 
@@ -1210,7 +1210,7 @@ u8 MTO_GetTxFallbackRate(MTO_FUNC_INPUT)
 //    to transmit a packet or when MSDULifeTime expired.
 //
 //  Arguments:
-//    Adapter      - The pointer to the Miniport Adapter Context
+//    adapter      - The pointer to the Miniport adapter Context
 //
 //  Return Value:
 //    None
--- a/drivers/staging/winbond/mto_f.h
+++ b/drivers/staging/winbond/mto_f.h
@@ -1,6 +1,6 @@
-extern void MTO_Init(PWB32_ADAPTER);
-extern void MTO_PeriodicTimerExpired(PWB32_ADAPTER);
-extern void MTO_SetDTORateRange(PWB32_ADAPTER, u8 *, u8);
+extern void MTO_Init(struct wb35_adapter *);
+extern void MTO_PeriodicTimerExpired(struct wb35_adapter *);
+extern void MTO_SetDTORateRange(struct wb35_adapter *, u8 *, u8);
 extern u8 MTO_GetTxRate(MTO_FUNC_INPUT, u32 fpdu_len);
 extern u8 MTO_GetTxFallbackRate(MTO_FUNC_INPUT);
 extern void MTO_SetTxCount(MTO_FUNC_INPUT, u8 t0, u8 index);
--- a/drivers/staging/winbond/mto.h
+++ b/drivers/staging/winbond/mto.h
@@ -129,17 +129,17 @@ typedef struct _MTO_PARAMETERS
 } MTO_PARAMETERS, *PMTO_PARAMETERS;
 
 
-#define MTO_FUNC_INPUT              PWB32_ADAPTER	Adapter
-#define MTO_FUNC_INPUT_DATA         Adapter
-#define MTO_DATA()                  (Adapter->sMtoPara)
-#define MTO_HAL()                   (&Adapter->sHwData)
+#define MTO_FUNC_INPUT              struct wb35_adapter *	adapter
+#define MTO_FUNC_INPUT_DATA         adapter
+#define MTO_DATA()                  (adapter->sMtoPara)
+#define MTO_HAL()                   (&adapter->sHwData)
 #define MTO_SET_PREAMBLE_TYPE(x)    // 20040511 Turbo mark LM_PREAMBLE_TYPE(&pcore_data->lm_data) = (x)
-#define MTO_ENABLE					(Adapter->sLocalPara.TxRateMode == RATE_AUTO)
-#define MTO_TXPOWER_FROM_EEPROM		(Adapter->sHwData.PowerIndexFromEEPROM)
-#define LOCAL_ANTENNA_NO()			(Adapter->sLocalPara.bAntennaNo)
-#define LOCAL_IS_CONNECTED()		(Adapter->sLocalPara.wConnectedSTAindex != 0)
-#define LOCAL_IS_IBSS_MODE()		(Adapter->asBSSDescriptElement[Adapter->sLocalPara.wConnectedSTAindex].bBssType == IBSS_NET)
-#define MTO_INITTXRATE_MODE			(Adapter->sHwData.SoftwareSet&0x2)	//bit 1
+#define MTO_ENABLE					(adapter->sLocalPara.TxRateMode == RATE_AUTO)
+#define MTO_TXPOWER_FROM_EEPROM		(adapter->sHwData.PowerIndexFromEEPROM)
+#define LOCAL_ANTENNA_NO()			(adapter->sLocalPara.bAntennaNo)
+#define LOCAL_IS_CONNECTED()		(adapter->sLocalPara.wConnectedSTAindex != 0)
+#define LOCAL_IS_IBSS_MODE()		(adapter->asBSSDescriptElement[adapter->sLocalPara.wConnectedSTAindex].bBssType == IBSS_NET)
+#define MTO_INITTXRATE_MODE			(adapter->sHwData.SoftwareSet&0x2)	//bit 1
 // 20040510 Turbo add
 #define MTO_TMR_CNT()               MTO_DATA().TmrCnt
 #define MTO_TOGGLE_STATE()          MTO_DATA().ToggleState
@@ -157,7 +157,7 @@ typedef struct _MTO_PARAMETERS
 #define MTO_TMR_PERIODIC()          MTO_DATA().Tmr_Periodic
 
 #define MTO_POWER_CHANGE_ENABLE()   MTO_DATA().PowerChangeEnable
-#define MTO_ANT_DIVERSITY_ENABLE()  Adapter->sLocalPara.boAntennaDiversity
+#define MTO_ANT_DIVERSITY_ENABLE()  adapter->sLocalPara.boAntennaDiversity
 #define MTO_ANT_MAC()               MTO_DATA().Ant_mac
 #define MTO_ANT_DIVERSITY()         MTO_DATA().Ant_div
 #define MTO_CCA_MODE()              MTO_DATA().CCA_Mode
--- a/drivers/staging/winbond/rxisr.c
+++ b/drivers/staging/winbond/rxisr.c
@@ -1,29 +1,29 @@
 #include "os_common.h"
 
-void vRxTimerInit(PWB32_ADAPTER Adapter)
+void vRxTimerInit(struct wb35_adapter * adapter)
 {
-	OS_TIMER_INITIAL(&(Adapter->Mds.nTimer), (void*) RxTimerHandler, (void*) Adapter);
+	OS_TIMER_INITIAL(&(adapter->Mds.nTimer), (void*) RxTimerHandler, (void*) adapter);
 }
 
-void vRxTimerStart(PWB32_ADAPTER Adapter, int timeout_value)
+void vRxTimerStart(struct wb35_adapter * adapter, int timeout_value)
 {
 	if (timeout_value<MIN_TIMEOUT_VAL)
 		timeout_value=MIN_TIMEOUT_VAL;
 
-	OS_TIMER_SET( &(Adapter->Mds.nTimer), timeout_value );
+	OS_TIMER_SET( &(adapter->Mds.nTimer), timeout_value );
 }
 
-void vRxTimerStop(PWB32_ADAPTER Adapter)
+void vRxTimerStop(struct wb35_adapter * adapter)
 {
-	OS_TIMER_CANCEL( &(Adapter->Mds.nTimer), 0 );
+	OS_TIMER_CANCEL( &(adapter->Mds.nTimer), 0 );
 }
 
-void RxTimerHandler_1a( PADAPTER Adapter)
+void RxTimerHandler_1a( struct wb35_adapter * adapter)
 {
-	RxTimerHandler(NULL, Adapter, NULL, NULL);
+	RxTimerHandler(NULL, adapter, NULL, NULL);
 }
 
-void RxTimerHandler(void* SystemSpecific1, PWB32_ADAPTER Adapter,
+void RxTimerHandler(void* SystemSpecific1, struct wb35_adapter * adapter,
 		    void* SystemSpecific2, void* SystemSpecific3)
 {
 	WARN_ON(1);
--- a/drivers/staging/winbond/scan_s.h
+++ b/drivers/staging/winbond/scan_s.h
@@ -78,9 +78,9 @@ typedef struct _SCAN_PARAMETERS
 
 } SCAN_PARAMETERS, *psSCAN_PARAMETERS;
 
-// Encapsulate 'Adapter' data structure
-#define psSCAN			(&(Adapter->sScanPara))
-#define psSCANREQ			(&(Adapter->sScanPara.sScanReq))
+// Encapsulate 'adapter' data structure
+#define psSCAN			(&(adapter->sScanPara))
+#define psSCANREQ			(&(adapter->sScanPara.sScanReq))
 
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 //	scan.h
@@ -109,7 +109,7 @@ typedef struct _SCAN_PARAMETERS
 
 // static functions
 
-//static void ScanTimerHandler(PWB32_ADAPTER Adapter);
-//static void vScanTimerStart(PWB32_ADAPTER	Adapter, int timeout_value);
-//static void vScanTimerStop(PWB32_ADAPTER Adapter);
+//static void ScanTimerHandler(struct wb35_adapter * adapter);
+//static void vScanTimerStart(struct wb35_adapter *	adapter, int timeout_value);
+//static void vScanTimerStop(struct wb35_adapter * adapter);
 
--- a/drivers/staging/winbond/sme_s.h
+++ b/drivers/staging/winbond/sme_s.h
@@ -196,9 +196,9 @@ typedef struct _SME_PARAMETERS
 
 } SME_PARAMETERS, *PSME_PARAMETERS;
 
-#define psSME			(&(Adapter->sSmePara))
+#define psSME			(&(adapter->sSmePara))
 
-#define wSMEGetCurrentSTAState(Adapter)		((u16)(Adapter)->sSmePara.wState)
+#define wSMEGetCurrentSTAState(adapter)		((u16)(adapter)->sSmePara.wState)
 
 
 
--- a/drivers/staging/winbond/wbhal.c
+++ b/drivers/staging/winbond/wbhal.c
@@ -28,10 +28,10 @@ void hal_get_permanent_address( phw_data
 	memcpy( pethernet_address, pHwData->PermanentMacAddress, 6 );
 }
 
-u8 hal_init_hardware(phw_data_t pHwData, PWB32_ADAPTER Adapter)
+u8 hal_init_hardware(phw_data_t pHwData, struct wb35_adapter * adapter)
 {
 	u16 SoftwareSet;
-	pHwData->Adapter = Adapter;
+	pHwData->adapter = adapter;
 
 	// Initial the variable
 	pHwData->MaxReceiveLifeTime = DEFAULT_MSDU_LIFE_TIME; // Setting Rx maximum MSDU life time
@@ -392,7 +392,7 @@ s32 hal_get_rssi_bss(  phw_data_t pHwDat
 	R01_DESCRIPTOR	r01;
 	s32 ltmp = 0, tmp;
 	u8	i, j;
-	PADAPTER	Adapter = pHwData->Adapter;
+	struct wb35_adapter *	adapter = pHwData->adapter;
 //	u32 *HalRssiArry = psBSS(idx)->HalRssi;
 
 	if( pHwData->SurpriseRemove ) return -200;
@@ -443,7 +443,7 @@ void hal_led_control_1a(  phw_data_t pHw
 
 void hal_led_control(  void* S1,  phw_data_t pHwData,  void* S3,  void* S4 )
 {
-	PADAPTER	Adapter = pHwData->Adapter;
+	struct wb35_adapter *	adapter = pHwData->adapter;
 	struct wb35_reg *reg = &pHwData->reg;
 	u32	LEDSet = (pHwData->SoftwareSet & HAL_LED_SET_MASK) >> HAL_LED_SET_SHIFT;
 	u8	LEDgray[20] = { 0,3,4,6,8,10,11,12,13,14,15,14,13,12,11,10,8,6,4,2 };
@@ -633,8 +633,8 @@ void hal_led_control(  void* S1,  phw_da
 				else
 				{
 					// Is transmitting/receiving ??
-					if( (OS_CURRENT_RX_BYTE( Adapter ) != pHwData->RxByteCountLast ) ||
-						(OS_CURRENT_TX_BYTE( Adapter ) != pHwData->TxByteCountLast ) )
+					if( (OS_CURRENT_RX_BYTE( adapter ) != pHwData->RxByteCountLast ) ||
+						(OS_CURRENT_TX_BYTE( adapter ) != pHwData->TxByteCountLast ) )
 					{
 						if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
 						{
@@ -643,8 +643,8 @@ void hal_led_control(  void* S1,  phw_da
 						}
 
 						// Update variable
-						pHwData->RxByteCountLast = OS_CURRENT_RX_BYTE( Adapter );
-						pHwData->TxByteCountLast = OS_CURRENT_TX_BYTE( Adapter );
+						pHwData->RxByteCountLast = OS_CURRENT_RX_BYTE( adapter );
+						pHwData->TxByteCountLast = OS_CURRENT_TX_BYTE( adapter );
 						TimeInterval = 200;
 					}
 					else
@@ -846,18 +846,18 @@ void hal_system_power_change(phw_data_t 
 
 void hal_surprise_remove(  phw_data_t pHwData )
 {
-	PADAPTER Adapter = pHwData->Adapter;
-	if (OS_ATOMIC_INC( Adapter, &pHwData->SurpriseRemoveCount ) == 1) {
+	struct wb35_adapter * adapter = pHwData->adapter;
+	if (OS_ATOMIC_INC( adapter, &pHwData->SurpriseRemoveCount ) == 1) {
 		#ifdef _PE_STATE_DUMP_
 		WBDEBUG(("Calling hal_surprise_remove\n"));
 		#endif
-		OS_STOP( Adapter );
+		OS_STOP( adapter );
 	}
 }
 
 void hal_rate_change(  phw_data_t pHwData ) // Notify the HAL rate is changing 20060613.1
 {
-	PADAPTER	Adapter = pHwData->Adapter;
+	struct wb35_adapter *	adapter = pHwData->adapter;
 	u8		rate = CURRENT_TX_RATE;
 
 	BBProcessor_RateChanging( pHwData, rate );
--- a/drivers/staging/winbond/wbhal_f.h
+++ b/drivers/staging/winbond/wbhal_f.h
@@ -18,8 +18,8 @@
 //====================================================================================
 void hal_remove_mapping_key(  phw_data_t pHwData,  u8 *pmac_addr );
 void hal_remove_default_key(  phw_data_t pHwData,  u32 index );
-unsigned char hal_set_mapping_key(  phw_data_t Adapter,  u8 *pmac_addr,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
-unsigned char hal_set_default_key(  phw_data_t Adapter,  u8 index,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
+unsigned char hal_set_mapping_key(  phw_data_t adapter,  u8 *pmac_addr,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
+unsigned char hal_set_default_key(  phw_data_t adapter,  u8 index,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
 void hal_clear_all_default_key(  phw_data_t pHwData );
 void hal_clear_all_group_key(  phw_data_t pHwData );
 void hal_clear_all_mapping_key(  phw_data_t pHwData );
@@ -27,7 +27,7 @@ void hal_clear_all_key(  phw_data_t pHwD
 void hal_get_ethernet_address(  phw_data_t pHwData,  u8 *current_address );
 void hal_set_ethernet_address(  phw_data_t pHwData,  u8 *current_address );
 void hal_get_permanent_address(  phw_data_t pHwData,  u8 *pethernet_address );
-unsigned char hal_init_hardware(  phw_data_t pHwData,  PADAPTER Adapter );
+unsigned char hal_init_hardware(  phw_data_t pHwData,  struct wb35_adapter * adapter );
 void hal_set_power_save_mode(  phw_data_t pHwData,  unsigned char power_save,  unsigned char wakeup,  unsigned char dtim );
 void hal_get_power_save_mode(  phw_data_t pHwData,   u8 *pin_pwr_save );
 void hal_set_slot_time(  phw_data_t pHwData,  u8 type );
--- a/drivers/staging/winbond/wbhal_s.h
+++ b/drivers/staging/winbond/wbhal_s.h
@@ -445,12 +445,12 @@ typedef struct _HW_DATA_T
 	//=======================================================================================
 	// For USB driver, hal need more variables. Due to
 	//	1. NDIS-WDM operation
-	//	2. The SME, MLME and OLD MDS need Adapter structure, but the driver under HAL doesn't
+	//	2. The SME, MLME and OLD MDS need adapter structure, but the driver under HAL doesn't
 	//		have that parameter when receiving and indicating packet.
-	//		The MDS must input the Adapter pointer as the second parameter of hal_init_hardware.
+	//		The MDS must input the adapter pointer as the second parameter of hal_init_hardware.
 	//		The function usage is different than PCI driver.
 	//=======================================================================================
-	void* Adapter;
+	void* adapter;
 
 	//===============================================
 	// Definition for MAC address
--- a/drivers/staging/winbond/wblinux.c
+++ b/drivers/staging/winbond/wblinux.c
@@ -21,9 +21,9 @@ WBLINUX_MemoryAlloc(void* *VirtualAddres
 }
 
 s32
-EncapAtomicInc(PADAPTER Adapter, void* pAtomic)
+EncapAtomicInc(struct wb35_adapter * adapter, void* pAtomic)
 {
-	PWBLINUX pWbLinux = &Adapter->WbLinux;
+	PWBLINUX pWbLinux = &adapter->WbLinux;
 	u32	ltmp;
 	u32 *	pltmp = (u32 *)pAtomic;
 	spin_lock_irq( &pWbLinux->AtomicSpinLock );
@@ -34,9 +34,9 @@ EncapAtomicInc(PADAPTER Adapter, void* p
 }
 
 s32
-EncapAtomicDec(PADAPTER Adapter, void* pAtomic)
+EncapAtomicDec(struct wb35_adapter * adapter, void* pAtomic)
 {
-	PWBLINUX pWbLinux = &Adapter->WbLinux;
+	PWBLINUX pWbLinux = &adapter->WbLinux;
 	u32	ltmp;
 	u32 *	pltmp = (u32 *)pAtomic;
 	spin_lock_irq( &pWbLinux->AtomicSpinLock );
@@ -47,9 +47,9 @@ EncapAtomicDec(PADAPTER Adapter, void* p
 }
 
 unsigned char
-WBLINUX_Initial(PADAPTER Adapter)
+WBLINUX_Initial(struct wb35_adapter * adapter)
 {
-	PWBLINUX pWbLinux = &Adapter->WbLinux;
+	PWBLINUX pWbLinux = &adapter->WbLinux;
 
 	spin_lock_init( &pWbLinux->SpinLock );
 	spin_lock_init( &pWbLinux->AtomicSpinLock );
@@ -57,40 +57,40 @@ WBLINUX_Initial(PADAPTER Adapter)
 }
 
 void
-WBLinux_ReceivePacket(PADAPTER Adapter, PRXLAYER1 pRxLayer1)
+WBLinux_ReceivePacket(struct wb35_adapter * adapter, PRXLAYER1 pRxLayer1)
 {
 	BUG();
 }
 
 
 void
-WBLINUX_GetNextPacket(PADAPTER Adapter,  PDESCRIPTOR pDes)
+WBLINUX_GetNextPacket(struct wb35_adapter * adapter,  PDESCRIPTOR pDes)
 {
 	BUG();
 }
 
 void
-WBLINUX_GetNextPacketCompleted(PADAPTER Adapter, PDESCRIPTOR pDes)
+WBLINUX_GetNextPacketCompleted(struct wb35_adapter * adapter, PDESCRIPTOR pDes)
 {
 	BUG();
 }
 
 void
-WBLINUX_Destroy(PADAPTER Adapter)
+WBLINUX_Destroy(struct wb35_adapter * adapter)
 {
-	WBLINUX_stop( Adapter );
+	WBLINUX_stop( adapter );
 #ifdef _PE_USB_INI_DUMP_
 	WBDEBUG(("[w35und] unregister_netdev!\n"));
 #endif
 }
 
 void
-WBLINUX_stop(  PADAPTER Adapter )
+WBLINUX_stop(  struct wb35_adapter * adapter )
 {
-	PWBLINUX	pWbLinux = &Adapter->WbLinux;
+	PWBLINUX	pWbLinux = &adapter->WbLinux;
 	struct sk_buff *pSkb;
 
-	if (OS_ATOMIC_INC( Adapter, &pWbLinux->ThreadCount ) == 1) {
+	if (OS_ATOMIC_INC( adapter, &pWbLinux->ThreadCount ) == 1) {
 		// Shutdown module immediately
 		pWbLinux->shutdown = 1;
 
@@ -112,33 +112,33 @@ WBLINUX_stop(  PADAPTER Adapter )
 #endif
 	}
 
-	OS_ATOMIC_DEC( Adapter, &pWbLinux->ThreadCount );
+	OS_ATOMIC_DEC(adapter, &pWbLinux->ThreadCount);
 }
 
 void
-WbWlanHalt(  PADAPTER Adapter )
+WbWlanHalt(struct wb35_adapter *adapter)
 {
 	//---------------------
-	Adapter->sLocalPara.ShutDowned = TRUE;
+	adapter->sLocalPara.ShutDowned = TRUE;
 
-	Mds_Destroy( Adapter );
+	Mds_Destroy(adapter);
 
 	// Turn off Rx and Tx hardware ability
-	hal_stop( &Adapter->sHwData );
+	hal_stop(&adapter->sHwData);
 #ifdef _PE_USB_INI_DUMP_
 	WBDEBUG(("[w35und] Hal_stop O.K.\n"));
 #endif
 	msleep(100);// Waiting Irp completed
 
 	// Destroy the NDIS module
-	WBLINUX_Destroy( Adapter );
+	WBLINUX_Destroy(adapter);
 
 	// Halt the HAL
-	hal_halt(&Adapter->sHwData, NULL);
+	hal_halt(&adapter->sHwData, NULL);
 }
 
 unsigned char
-WbWLanInitialize(PADAPTER Adapter)
+WbWLanInitialize(struct wb35_adapter *adapter)
 {
 	phw_data_t	pHwData;
 	u8		*pMacAddr;
@@ -150,22 +150,22 @@ WbWLanInitialize(PADAPTER Adapter)
 	//
 	// Setting default value for Linux
 	//
-	Adapter->sLocalPara.region_INF = REGION_AUTO;
-	Adapter->sLocalPara.TxRateMode = RATE_AUTO;
+	adapter->sLocalPara.region_INF = REGION_AUTO;
+	adapter->sLocalPara.TxRateMode = RATE_AUTO;
 	psLOCAL->bMacOperationMode = MODE_802_11_BG;	// B/G mode
-	Adapter->Mds.TxRTSThreshold = DEFAULT_RTSThreshold;
-	Adapter->Mds.TxFragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD;
-	hal_set_phy_type( &Adapter->sHwData, RF_WB_242_1 );
-	Adapter->sLocalPara.MTUsize = MAX_ETHERNET_PACKET_SIZE;
+	adapter->Mds.TxRTSThreshold = DEFAULT_RTSThreshold;
+	adapter->Mds.TxFragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD;
+	hal_set_phy_type( &adapter->sHwData, RF_WB_242_1 );
+	adapter->sLocalPara.MTUsize = MAX_ETHERNET_PACKET_SIZE;
 	psLOCAL->bPreambleMode = AUTO_MODE;
-	Adapter->sLocalPara.RadioOffStatus.boSwRadioOff = FALSE;
-	pHwData = &Adapter->sHwData;
+	adapter->sLocalPara.RadioOffStatus.boSwRadioOff = FALSE;
+	pHwData = &adapter->sHwData;
 	hal_set_phy_type( pHwData, RF_DECIDE_BY_INF );
 
 	//
 	// Initial each module and variable
 	//
-	if (!WBLINUX_Initial(Adapter)) {
+	if (!WBLINUX_Initial(adapter)) {
 #ifdef _PE_USB_INI_DUMP_
 		WBDEBUG(("[w35und]WBNDIS initialization failed\n"));
 #endif
@@ -173,17 +173,17 @@ WbWLanInitialize(PADAPTER Adapter)
 	}
 
 	// Initial Software variable
-	Adapter->sLocalPara.ShutDowned = FALSE;
+	adapter->sLocalPara.ShutDowned = FALSE;
 
 	//added by ws for wep key error detection
-	Adapter->sLocalPara.bWepKeyError= FALSE;
-	Adapter->sLocalPara.bToSelfPacketReceived = FALSE;
-	Adapter->sLocalPara.WepKeyDetectTimerCount= 2 * 100; /// 2 seconds
+	adapter->sLocalPara.bWepKeyError= FALSE;
+	adapter->sLocalPara.bToSelfPacketReceived = FALSE;
+	adapter->sLocalPara.WepKeyDetectTimerCount= 2 * 100; /// 2 seconds
 
 	// Initial USB hal
 	InitStep = 1;
-	pHwData = &Adapter->sHwData;
-	if (!hal_init_hardware(pHwData, Adapter))
+	pHwData = &adapter->sHwData;
+	if (!hal_init_hardware(pHwData, adapter))
 		goto error;
 
 	EEPROM_region = hal_get_region_from_EEPROM( pHwData );
@@ -197,9 +197,9 @@ WbWLanInitialize(PADAPTER Adapter)
 	}
 
 	// Get Software setting flag from hal
-	Adapter->sLocalPara.boAntennaDiversity = FALSE;
+	adapter->sLocalPara.boAntennaDiversity = FALSE;
 	if (hal_software_set(pHwData) & 0x00000001)
-		Adapter->sLocalPara.boAntennaDiversity = TRUE;
+		adapter->sLocalPara.boAntennaDiversity = TRUE;
 
 	//
 	// For TS module
@@ -208,7 +208,7 @@ WbWLanInitialize(PADAPTER Adapter)
 
 	// For MDS module
 	InitStep = 3;
-	Mds_initial(Adapter);
+	Mds_initial(adapter);
 
 	//=======================================
 	// Initialize the SME, SCAN, MLME, ROAM
@@ -218,15 +218,15 @@ WbWLanInitialize(PADAPTER Adapter)
 	InitStep = 6;
 
 	// If no user-defined address in the registry, use the addresss "burned" on the NIC instead.
-	pMacAddr = Adapter->sLocalPara.ThisMacAddress;
-	pMacAddr2 = Adapter->sLocalPara.PermanentAddress;
-	hal_get_permanent_address( pHwData, Adapter->sLocalPara.PermanentAddress );// Reading ethernet address from EEPROM
+	pMacAddr = adapter->sLocalPara.ThisMacAddress;
+	pMacAddr2 = adapter->sLocalPara.PermanentAddress;
+	hal_get_permanent_address( pHwData, adapter->sLocalPara.PermanentAddress );// Reading ethernet address from EEPROM
 	if (OS_MEMORY_COMPARE(pMacAddr, "\x00\x00\x00\x00\x00\x00", MAC_ADDR_LENGTH )) // Is equal
 	{
 		memcpy( pMacAddr, pMacAddr2, MAC_ADDR_LENGTH );
 	} else {
 		// Set the user define MAC address
-		hal_set_ethernet_address( pHwData, Adapter->sLocalPara.ThisMacAddress );
+		hal_set_ethernet_address( pHwData, adapter->sLocalPara.ThisMacAddress );
 	}
 
 	//get current antenna
@@ -240,7 +240,7 @@ WbWLanInitialize(PADAPTER Adapter)
 	while (!hal_idle(pHwData))
 		msleep(10);
 
-	MTO_Init(Adapter);
+	MTO_Init(adapter);
 
 	HwRadioOff = hal_get_hw_radio_off( pHwData );
 	psLOCAL->RadioOffStatus.boHwRadioOff = !!HwRadioOff;
@@ -249,16 +249,16 @@ WbWLanInitialize(PADAPTER Adapter)
 
 	hal_driver_init_OK(pHwData) = 1; // Notify hal that the driver is ready now.
 	//set a tx power for reference.....
-//	sme_set_tx_power_level(Adapter, 12);	FIXME?
+//	sme_set_tx_power_level(adapter, 12);	FIXME?
 	return TRUE;
 
 error:
 	switch (InitStep) {
 	case 5:
 	case 4:
-	case 3: Mds_Destroy( Adapter );
+	case 3: Mds_Destroy( adapter );
 	case 2:
-	case 1: WBLINUX_Destroy( Adapter );
+	case 1: WBLINUX_Destroy( adapter );
 		hal_halt( pHwData, NULL );
 	case 0: break;
 	}
@@ -266,9 +266,9 @@ error:
 	return FALSE;
 }
 
-void WBLINUX_ConnectStatus(PADAPTER Adapter, u32 flag)
+void WBLINUX_ConnectStatus(struct wb35_adapter * adapter, u32 flag)
 {
-	PWBLINUX	pWbLinux = &Adapter->WbLinux;
+	PWBLINUX	pWbLinux = &adapter->WbLinux;
 
 	pWbLinux->LinkStatus = flag; // OS_DISCONNECTED	or  OS_CONNECTED
 }
--- a/drivers/staging/winbond/wblinux_f.h
+++ b/drivers/staging/winbond/wblinux_f.h
@@ -4,20 +4,20 @@
 // wblinux_f.h
 //
 u32 WBLINUX_MemoryAlloc(  void* *VirtualAddress,  u32 Length );
-s32 EncapAtomicInc(  PADAPTER Adapter,  void* pAtomic );
-s32 EncapAtomicDec(  PADAPTER Adapter,  void* pAtomic );
-void WBLinux_ReceivePacket(  PADAPTER Adapter,  PRXLAYER1 pRxLayer1 );
-unsigned char WBLINUX_Initial(  PADAPTER Adapter );
+s32 EncapAtomicInc(  struct wb35_adapter *adapter,  void* pAtomic );
+s32 EncapAtomicDec(  struct wb35_adapter *adapter,  void* pAtomic );
+void WBLinux_ReceivePacket(  struct wb35_adapter *adapter,  PRXLAYER1 pRxLayer1 );
+unsigned char WBLINUX_Initial(  struct wb35_adapter *adapter );
 int wb35_start_xmit(struct sk_buff *skb, struct net_device *netdev );
-void WBLINUX_GetNextPacket(  PADAPTER Adapter,  PDESCRIPTOR pDes );
-void WBLINUX_GetNextPacketCompleted(  PADAPTER Adapter,  PDESCRIPTOR pDes );
-void WBLINUX_stop(  PADAPTER Adapter );
-void WBLINUX_Destroy(  PADAPTER Adapter );
+void WBLINUX_GetNextPacket(  struct wb35_adapter *adapter,  PDESCRIPTOR pDes );
+void WBLINUX_GetNextPacketCompleted(  struct wb35_adapter *adapter,  PDESCRIPTOR pDes );
+void WBLINUX_stop(  struct wb35_adapter *adapter );
+void WBLINUX_Destroy(  struct wb35_adapter *adapter );
 void wb35_set_multicast( struct net_device *netdev );
 struct net_device_stats * wb35_netdev_stats( struct net_device *netdev );
-void WBLINUX_stop(  PADAPTER Adapter );
-void WbWlanHalt(  PADAPTER Adapter );
-void WBLINUX_ConnectStatus(  PADAPTER Adapter,  u32 flag );
+void WBLINUX_stop(  struct wb35_adapter *adapter );
+void WbWlanHalt(  struct wb35_adapter *adapter );
+void WBLINUX_ConnectStatus(  struct wb35_adapter *adapter,  u32 flag );
 
 
 
--- a/drivers/staging/winbond/wblinux_s.h
+++ b/drivers/staging/winbond/wblinux_s.h
@@ -2,7 +2,7 @@
 // wblinux_s.h
 //
 #define OS_MEMORY_ALLOC( _V, _S )	WBLINUX_MemoryAlloc( _V, _S )
-#define OS_LINK_STATUS			(Adapter->WbLinux.LinkStatus == OS_CONNECTED)
+#define OS_LINK_STATUS			(adapter->WbLinux.LinkStatus == OS_CONNECTED)
 #define OS_SET_SHUTDOWN( _A )		_A->WbLinux.shutdown=1
 #define OS_SET_RESUME( _A )		_A->WbLinux.shutdown=0
 #define OS_CONNECT_STATUS_INDICATE( _A, _F )		WBLINUX_ConnectStatus( _A, _F )
