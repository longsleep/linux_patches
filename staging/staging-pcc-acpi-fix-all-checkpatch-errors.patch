From liodot@gmail.com  Mon Oct 20 16:04:46 2008
From: "Lior Dotan" <liodot@gmail.com>
Date: Tue, 14 Oct 2008 10:43:57 +0200
Subject: Staging: PCC-ACPI: Fix all checkpatch errors
To: "Greg KH" <greg@kroah.com>
Message-ID: <a5bf86a80810140143g510183c9ve85a379af519670@mail.gmail.com>


Fix all complaints that checkpatch had regarding this patch

Signed-off-by: Lior Dotan <liodot@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/pcc-acpi/pcc-acpi.c |  427 ++++++++++++++++++++----------------
 1 file changed, 243 insertions(+), 184 deletions(-)

--- a/drivers/staging/pcc-acpi/pcc-acpi.c
+++ b/drivers/staging/pcc-acpi/pcc-acpi.c
@@ -27,11 +27,13 @@
  * 	Nov.04, 2006	Hiroshi Miura <miura@da-cha.org>
  * 		-v0.9	remove warning about section reference.
  * 			remove acpi_os_free
- * 			add /proc/acpi/pcc/brightness interface to allow HAL to access.
+ * 			add /proc/acpi/pcc/brightness interface to
+ * 			allow HAL to access.
  * 			merge dbronaugh's enhancement
  * 			Aug.17, 2004 David Bronaugh (dbronaugh)
  *  				- Added screen brightness setting interface
- *				  Thanks to the FreeBSD crew (acpi_panasonic.c authors)
+ *				  Thanks to the FreeBSD crew
+ *				  (acpi_panasonic.c authors)
  * 				  for the ideas I needed to accomplish it
  *
  *	May.29, 2006	Hiroshi Miura <miura@da-cha.org>
@@ -41,13 +43,15 @@
  *			Hiroshi Yokota for providing solutions.
  *
  *	Oct.02, 2004	Hiroshi Miura <miura@da-cha.org>
- *		-v0.8.2	merge code of YOKOTA Hiroshi <yokota@netlab.is.tsukuba.ac.jp>.
+ *		-v0.8.2	merge code of YOKOTA Hiroshi
+ *			<yokota@netlab.is.tsukuba.ac.jp>.
  *			Add sticky key mode interface.
  *			Refactoring acpi_pcc_generete_keyinput().
  *
  *	Sep.15, 2004	Hiroshi Miura <miura@da-cha.org>
  *		-v0.8	Generate key input event on input subsystem.
- *			This is based on yet another driver written by Ryuta Nakanishi.
+ *			This is based on yet another driver
+ *			written by Ryuta Nakanishi.
  *
  *	Sep.10, 2004	Hiroshi Miura <miura@da-cha.org>
  *		-v0.7	Change proc interface functions using seq_file
@@ -57,7 +61,8 @@
  *		-v0.6.4 Fix a silly error with status checking
  *
  *	Aug.25, 2004	Hiroshi Miura <miura@da-cha.org>
- *		-v0.6.3 replace read_acpi_int by standard function acpi_evaluate_integer
+ *		-v0.6.3 replace read_acpi_int by standard
+ *			function acpi_evaluate_integer
  *			some clean up and make smart copyright notice.
  *			fix return value of pcc_acpi_get_key()
  *			fix checking return value of acpi_bus_register_driver()
@@ -96,19 +101,18 @@
 
 #define ACPI_PCC_VERSION	"0.9+hy"
 
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
-#include <asm/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
 #include <linux/ctype.h>
 #include <linux/init.h>
 #include <linux/input.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/version.h>
+#include <linux/uaccess.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
 
 
 /*************************************************************************
@@ -207,12 +211,18 @@ MODULE_LICENSE("GPL");
    ENV_STATEs: Normal temp=0x01, High temp=0x81, N/A=0x00
 */
 enum SINF_BITS { SINF_NUM_BATTERIES = 0,
-                 SINF_LCD_TYPE,      /* 1 */
-		 SINF_AC_MAX_BRIGHT, SINF_AC_MIN_BRIGHT, SINF_AC_CUR_BRIGHT,  /* 2, 3, 4 */
-		             /* 4 = R1 only handle SINF_AC_CUR_BRIGHT as SINF_CUR_BRIGHT and don't know AC state */
-		 SINF_DC_MAX_BRIGHT, SINF_DC_MIN_BRIGHT, SINF_DC_CUR_BRIGHT,  /* 5, 6, 7 */
+		 SINF_LCD_TYPE,
+		 SINF_AC_MAX_BRIGHT,
+		 SINF_AC_MIN_BRIGHT,
+		 SINF_AC_CUR_BRIGHT,
+			     /* 4 = R1 only handle SINF_AC_CUR_BRIGHT
+			      * as SINF_CUR_BRIGHT and don't know AC state */
+		 SINF_DC_MAX_BRIGHT,
+		 SINF_DC_MIN_BRIGHT,
+		 SINF_DC_CUR_BRIGHT,
 		 SINF_MUTE,
-		 SINF_RESERVED,      SINF_ENV_STATE, /* 9, 10 */
+		 SINF_RESERVED,
+		 SINF_ENV_STATE, /* 10 */
 		 SINF_STICKY_KEY = 0x80,
 };
 
@@ -227,7 +237,8 @@ MODULE_DEVICE_TABLE(acpi, pcc_device_ids
 
 
 static int __devinit acpi_pcc_hotkey_add(struct acpi_device *device);
-static int __devexit acpi_pcc_hotkey_remove(struct acpi_device *device, int type);
+static int __devexit acpi_pcc_hotkey_remove(struct acpi_device *device,
+					    int type);
 static int acpi_pcc_hotkey_resume(struct acpi_device *device);
 
 
@@ -236,11 +247,11 @@ static struct acpi_driver acpi_pcc_drive
 	.class =	ACPI_PCC_CLASS,
 	.ids =		pcc_device_ids,
 	.ops =		{
-				.add =		acpi_pcc_hotkey_add,
-				.remove =	__devexit_p(acpi_pcc_hotkey_remove),
+				.add = acpi_pcc_hotkey_add,
+				.remove = __devexit_p(acpi_pcc_hotkey_remove),
 #ifdef CONFIG_PM
-				/*.suspend =      acpi_pcc_hotkey_suspend,*/
-				.resume =       acpi_pcc_hotkey_resume,
+				/*.suspend = acpi_pcc_hotkey_suspend,*/
+				.resume = acpi_pcc_hotkey_resume,
 #endif
 			},
 };
@@ -264,7 +275,7 @@ struct pcc_keyinput {
    Hotkey driver core
    ************************************************************************* */
 /* -------------------------------------------------------------------------
-                           method access functions
+   method access functions
    ------------------------------------------------------------------------- */
 static int acpi_pcc_write_sset(struct acpi_hotkey *hotkey, int func, int val)
 {
@@ -282,7 +293,8 @@ static int acpi_pcc_write_sset(struct ac
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_write_sset");
 
-	status = acpi_evaluate_object(hotkey->handle, METHOD_HKEY_SSET, &params, NULL);
+	status = acpi_evaluate_object(hotkey->handle, METHOD_HKEY_SSET,
+								&params, NULL);
 
 	return_VALUE(status == AE_OK ? AE_OK : AE_ERROR);
 }
@@ -294,7 +306,8 @@ static inline int acpi_pcc_get_sqty(stru
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_get_sqty");
 
-	status = acpi_evaluate_integer(device->handle, METHOD_HKEY_SQTY, NULL, &s);
+	status = acpi_evaluate_integer(device->handle, METHOD_HKEY_SQTY,
+								NULL, &s);
 	if (ACPI_SUCCESS(status)) {
 		return_VALUE(s);
 	} else {
@@ -304,7 +317,7 @@ static inline int acpi_pcc_get_sqty(stru
 	}
 }
 
-static int acpi_pcc_retrieve_biosdata(struct acpi_hotkey *hotkey, u32* sinf)
+static int acpi_pcc_retrieve_biosdata(struct acpi_hotkey *hotkey, u32 *sinf)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
@@ -313,9 +326,11 @@ static int acpi_pcc_retrieve_biosdata(st
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_retrieve_biosdata");
 
-	status = acpi_evaluate_object(hotkey->handle, METHOD_HKEY_SINF, 0 , &buffer);
+	status = acpi_evaluate_object(hotkey->handle, METHOD_HKEY_SINF, 0,
+				      &buffer);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "evaluation error HKEY.SINF\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "evaluation error HKEY.SINF\n"));
 		status = AE_ERROR;
 		return_VALUE(status);
 	}
@@ -327,7 +342,8 @@ static int acpi_pcc_retrieve_biosdata(st
 	}
 
 	if (hotkey->num_sifr < hkey->package.count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "SQTY reports bad SINF length\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "SQTY reports bad SINF length\n"));
 		status = AE_ERROR;
 		goto free_buffer;
 	}
@@ -337,7 +353,8 @@ static int acpi_pcc_retrieve_biosdata(st
 		if (likely(element->type == ACPI_TYPE_INTEGER)) {
 			sinf[i] = element->integer.value;
 		} else {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid HKEY.SINF data\n"));
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+					 "Invalid HKEY.SINF data\n"));
 			status = AE_ERROR;
 			break;
 		}
@@ -356,24 +373,26 @@ static int acpi_pcc_read_sinf_field(stru
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_read_sinf_field");
 
-	if (ACPI_SUCCESS(acpi_pcc_retrieve_biosdata(hotkey, sinf))) {
+	if (ACPI_SUCCESS(acpi_pcc_retrieve_biosdata(hotkey, sinf)))
 		seq_printf(seq, "%u\n",	sinf[field]);
-	} else {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Couldn't retrieve BIOS data\n"));
-	}
+	else
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Couldn't retrieve BIOS data\n"));
 
 	return_VALUE(AE_OK);
 }
 
 /* -------------------------------------------------------------------------
-                       user interface functions
+   user interface functions
    ------------------------------------------------------------------------- */
 /* read methods */
 /* Sinf read methods */
 #define PCC_SINF_READ_F(_name_, FUNC) \
-static int _name_  (struct seq_file *seq, void *offset) \
+static int _name_(struct seq_file *seq, void *offset) \
 { \
-	return_VALUE(ACPI_SUCCESS(acpi_pcc_read_sinf_field(seq, (FUNC)))  ? 0 : -EINVAL); \
+	return_VALUE(ACPI_SUCCESS(acpi_pcc_read_sinf_field(seq,	\
+							  (FUNC))) \
+							  ? 0 : -EINVAL); \
 }
 
 PCC_SINF_READ_F(acpi_pcc_numbatteries_show,	 SINF_NUM_BATTERIES);
@@ -393,9 +412,8 @@ static int acpi_pcc_sticky_key_show(stru
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_sticky_key_show");
 
-	if (!hotkey || !hotkey->device) {
+	if (!hotkey || !hotkey->device)
 		return_VALUE(-EINVAL);
-	}
 
 	seq_printf(seq, "%d\n", hotkey->sticky_mode);
 
@@ -404,7 +422,7 @@ static int acpi_pcc_sticky_key_show(stru
 
 static int acpi_pcc_keyinput_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_hotkey 	*hotkey = (struct acpi_hotkey *) seq->private;
+	struct acpi_hotkey 	*hotkey = seq->private;
 	struct input_dev 	*hotk_input_dev = hotkey->input_dev;
 	struct pcc_keyinput 	*keyinput = input_get_drvdata(hotk_input_dev);
 
@@ -417,25 +435,25 @@ static int acpi_pcc_keyinput_show(struct
 
 static int acpi_pcc_version_show(struct seq_file *seq, void *offset)
 {
-	struct acpi_hotkey *hotkey = (struct acpi_hotkey *) seq->private;
+	struct acpi_hotkey *hotkey = seq->private;
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_version_show");
 
-	if (!hotkey || !hotkey->device) {
+	if (!hotkey || !hotkey->device)
 		return_VALUE(-EINVAL);
-	}
 
-	seq_printf(seq, "%s version %s\n", ACPI_PCC_DRIVER_NAME, ACPI_PCC_VERSION);
+	seq_printf(seq, "%s version %s\n", ACPI_PCC_DRIVER_NAME,
+		   ACPI_PCC_VERSION);
 	seq_printf(seq, "%li functions\n", hotkey->num_sifr);
 
 	return_VALUE(0);
 }
 
 /* write methods */
-static ssize_t acpi_pcc_write_single_flag (struct file *file,
-					   const char __user *buffer,
-					   size_t count,
-					   int sinf_func)
+static ssize_t acpi_pcc_write_single_flag(struct file *file,
+					  const char __user *buffer,
+					  size_t count,
+					  int sinf_func)
 {
 	struct seq_file		*seq = file->private_data;
 	struct acpi_hotkey	*hotkey = seq->private;
@@ -444,24 +462,23 @@ static ssize_t acpi_pcc_write_single_fla
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_write_single_flag");
 
-	if (!hotkey || (count > sizeof(write_string) - 1)) {
+	if (!hotkey || (count > sizeof(write_string) - 1))
 		return_VALUE(-EINVAL);
-	}
 
-	if (copy_from_user(write_string, buffer, count)) {
+	if (copy_from_user(write_string, buffer, count))
 		return_VALUE(-EFAULT);
-	}
+
 	write_string[count] = '\0';
 
 	if ((sscanf(write_string, "%3i", &val) == 1) &&
-	    (val == 0 || val == 1)) {
+	    (val == 0 || val == 1))
 		acpi_pcc_write_sset(hotkey, sinf_func, val);
-	}
 
 	return_VALUE(count);
 }
 
-static unsigned long acpi_pcc_write_brightness(struct file *file, const char __user *buffer,
+static unsigned long acpi_pcc_write_brightness(struct file *file,
+					       const char __user *buffer,
 					       size_t count,
 					       int min_index, int max_index,
 					       int cur_index)
@@ -474,33 +491,32 @@ static unsigned long acpi_pcc_write_brig
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_write_brightness");
 
-	if (!hotkey || (count > sizeof(write_string) - 1)) {
+	if (!hotkey || (count > sizeof(write_string) - 1))
 		return_VALUE(-EINVAL);
-	}
 
-	if (copy_from_user(write_string, buffer, count)) {
+	if (copy_from_user(write_string, buffer, count))
 		return_VALUE(-EFAULT);
-	}
 
 	write_string[count] = '\0';
 
 	if (ACPI_FAILURE(acpi_pcc_retrieve_biosdata(hotkey, sinf))) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Couldn't retrieve BIOS data\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Couldn't retrieve BIOS data\n"));
 		goto end;
 	}
 
 	if ((sscanf(write_string, "%4i", &bright) == 1) &&
-	    (bright >= sinf[min_index]                ) &&
-	    (bright <= sinf[max_index]                )) {
+	    (bright >= sinf[min_index]) &&
+	    (bright <= sinf[max_index]))
 		acpi_pcc_write_sset(hotkey, cur_index, bright);
-	}
 
 end:
 	return_VALUE(count);
 }
 
-static ssize_t acpi_pcc_write_ac_brightness(struct file *file, const char __user *buffer,
-					 size_t count, loff_t *ppos)
+static ssize_t acpi_pcc_write_ac_brightness(struct file *file,
+					    const char __user *buffer,
+					    size_t count, loff_t *ppos)
 {
 	return_VALUE(acpi_pcc_write_brightness(file, buffer, count,
 					       SINF_AC_MIN_BRIGHT,
@@ -508,8 +524,9 @@ static ssize_t acpi_pcc_write_ac_brightn
 					       SINF_AC_CUR_BRIGHT));
 }
 
-static ssize_t acpi_pcc_write_dc_brightness(struct file *file, const char __user *buffer,
-					 size_t count, loff_t *ppos)
+static ssize_t acpi_pcc_write_dc_brightness(struct file *file,
+					    const char __user *buffer,
+					    size_t count, loff_t *ppos)
 {
 	return_VALUE(acpi_pcc_write_brightness(file, buffer, count,
 					       SINF_DC_MIN_BRIGHT,
@@ -517,24 +534,27 @@ static ssize_t acpi_pcc_write_dc_brightn
 					       SINF_DC_CUR_BRIGHT));
 }
 
-static ssize_t acpi_pcc_write_no_brightness(struct file *file, const char __user *buffer,
-					 size_t count, loff_t *ppos)
+static ssize_t acpi_pcc_write_no_brightness(struct file *file,
+					    const char __user *buffer,
+					    size_t count, loff_t *ppos)
 {
-	return acpi_pcc_write_brightness(file, buffer, count, SINF_AC_MIN_BRIGHT,
+	return acpi_pcc_write_brightness(file, buffer, count,
+					 SINF_AC_MIN_BRIGHT,
 					 SINF_AC_MAX_BRIGHT,
 					 SINF_AC_CUR_BRIGHT);
 }
 
-static ssize_t acpi_pcc_write_mute (struct file *file,
-				    const char __user *buffer,
-				    size_t count, loff_t *ppos)
+static ssize_t acpi_pcc_write_mute(struct file *file,
+				   const char __user *buffer,
+				   size_t count, loff_t *ppos)
 {
-	return_VALUE(acpi_pcc_write_single_flag(file, buffer, count, SINF_MUTE));
+	return_VALUE(acpi_pcc_write_single_flag(file, buffer, count,
+						SINF_MUTE));
 }
 
-static ssize_t acpi_pcc_write_sticky_key (struct file *file,
-					  const char __user *buffer,
-					  size_t count, loff_t *ppos)
+static ssize_t acpi_pcc_write_sticky_key(struct file *file,
+					 const char __user *buffer,
+					 size_t count, loff_t *ppos)
 {
 	struct seq_file     *seq = (struct seq_file *)file->private_data;
 	struct acpi_hotkey  *hotkey = (struct acpi_hotkey *)seq->private;
@@ -543,13 +563,12 @@ static ssize_t acpi_pcc_write_sticky_key
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_write_sticky_key");
 
-	if (!hotkey || (count > sizeof(write_string) - 1)) {
+	if (!hotkey || (count > sizeof(write_string) - 1))
 		return_VALUE(-EINVAL);
-	}
 
-	if (copy_from_user(write_string, buffer, count)) {
+	if (copy_from_user(write_string, buffer, count))
 		return_VALUE(-EFAULT);
-	}
+
 	write_string[count] = '\0';
 
 	if ((sscanf(write_string, "%3i", &mode) == 1) &&
@@ -561,8 +580,9 @@ static ssize_t acpi_pcc_write_sticky_key
 	return_VALUE(count);
 }
 
-static ssize_t acpi_pcc_write_keyinput(struct file *file, const char __user *buffer,
-					 size_t count, loff_t *ppos)
+static ssize_t acpi_pcc_write_keyinput(struct file *file,
+				       const char __user *buffer,
+				       size_t count, loff_t *ppos)
 {
 	struct seq_file		*seq = (struct seq_file *)file->private_data;
 	struct acpi_hotkey	*hotkey = (struct acpi_hotkey *)seq->private;
@@ -572,13 +592,11 @@ static ssize_t acpi_pcc_write_keyinput(s
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_write_keyinput");
 
-	if (!hotkey || (count > (sizeof(write_string) - 1))) {
+	if (!hotkey || (count > (sizeof(write_string) - 1)))
 		return_VALUE(-EINVAL);
-	}
 
-	if (copy_from_user(write_string, buffer, count)) {
+	if (copy_from_user(write_string, buffer, count))
 		return_VALUE(-EFAULT);
-	}
 
 	write_string[count] = '\0';
 
@@ -592,7 +610,7 @@ static ssize_t acpi_pcc_write_keyinput(s
 }
 
 /* -------------------------------------------------------------------------
-                            hotkey driver
+   hotkey driver
    ------------------------------------------------------------------------- */
 static void acpi_pcc_generete_keyinput(struct acpi_hotkey *hotkey)
 {
@@ -604,7 +622,8 @@ static void acpi_pcc_generete_keyinput(s
 		/*  0 */ -1,
 		/*  1 */ KEY_BRIGHTNESSDOWN,
 		/*  2 */ KEY_BRIGHTNESSUP,
-		/*  3 */ -1, /* vga/lcd switch event is not occur on hotkey driver. */
+		/*  3 */ -1, /* vga/lcd switch event is not occur on
+				hotkey driver. */
 		/*  4 */ KEY_MUTE,
 		/*  5 */ KEY_VOLUMEDOWN,
 		/*  6 */ KEY_VOLUMEUP,
@@ -616,11 +635,12 @@ static void acpi_pcc_generete_keyinput(s
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_generete_keyinput");
 
-	if (keyinput->key_mode == 0) { return_VOID; }
+	if (keyinput->key_mode == 0)
+		return_VOID;
 
 	hkey_num = hinf & 0xf;
 
-	if ((       0 > hkey_num	   ) ||
+	if ((0 > hkey_num) ||
 	    (hkey_num > ARRAY_SIZE(key_map))) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
 				  "hotkey number out of range: %d\n",
@@ -645,12 +665,13 @@ static int acpi_pcc_hotkey_get_key(struc
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_hotkey_get_key");
 
-	status = acpi_evaluate_integer(hotkey->handle, METHOD_HKEY_QUERY, NULL, &result);
-	if (likely(ACPI_SUCCESS(status))) {
+	status = acpi_evaluate_integer(hotkey->handle, METHOD_HKEY_QUERY,
+								NULL, &result);
+	if (likely(ACPI_SUCCESS(status)))
 		hotkey->status = result;
-	} else {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "error getting hotkey status\n"));
-	}
+	else
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"error getting hotkey status\n"));
 
 	return_VALUE(status == AE_OK);
 }
@@ -661,11 +682,13 @@ void acpi_pcc_hotkey_notify(acpi_handle 
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_hotkey_notify");
 
-	switch(event) {
+	switch (event) {
 	case HKEY_NOTIFY:
 		if (acpi_pcc_hotkey_get_key(hotkey)) {
-			/* generate event like '"pcc HKEY 00000080 00000084"' when Fn+F4 pressed */
-			acpi_bus_generate_proc_event(hotkey->device, event, hotkey->status);
+			/* generate event like '"pcc HKEY 00000080 00000084"'
+			 * when Fn+F4 pressed */
+			acpi_bus_generate_proc_event(hotkey->device, event,
+								hotkey->status);
 		}
 		acpi_pcc_generete_keyinput(hotkey);
 		break;
@@ -680,75 +703,96 @@ void acpi_pcc_hotkey_notify(acpi_handle 
    FS Interface (/proc)
    ************************************************************************* */
 /* oepn proc file fs*/
-SEQ_OPEN_FS(acpi_pcc_dc_brightness_open_fs,	acpi_pcc_dc_brightness_show);
-SEQ_OPEN_FS(acpi_pcc_numbatteries_open_fs,	acpi_pcc_numbatteries_show);
-SEQ_OPEN_FS(acpi_pcc_lcdtype_open_fs,		acpi_pcc_lcdtype_show);
-SEQ_OPEN_FS(acpi_pcc_ac_brightness_max_open_fs, acpi_pcc_ac_brightness_max_show);
-SEQ_OPEN_FS(acpi_pcc_ac_brightness_min_open_fs, acpi_pcc_ac_brightness_min_show);
-SEQ_OPEN_FS(acpi_pcc_ac_brightness_open_fs,	acpi_pcc_ac_brightness_show);
-SEQ_OPEN_FS(acpi_pcc_dc_brightness_max_open_fs, acpi_pcc_dc_brightness_max_show);
-SEQ_OPEN_FS(acpi_pcc_dc_brightness_min_open_fs, acpi_pcc_dc_brightness_min_show);
-SEQ_OPEN_FS(acpi_pcc_brightness_open_fs,	acpi_pcc_brightness_show);
-SEQ_OPEN_FS(acpi_pcc_mute_open_fs,		acpi_pcc_mute_show);
-SEQ_OPEN_FS(acpi_pcc_version_open_fs,		acpi_pcc_version_show);
-SEQ_OPEN_FS(acpi_pcc_keyinput_open_fs,		acpi_pcc_keyinput_show);
-SEQ_OPEN_FS(acpi_pcc_sticky_key_open_fs,	acpi_pcc_sticky_key_show);
-
-typedef struct file_operations fops_t;
-static fops_t acpi_pcc_numbatteries_fops      = SEQ_FILEOPS_R (acpi_pcc_numbatteries_open_fs);
-static fops_t acpi_pcc_lcdtype_fops           = SEQ_FILEOPS_R (acpi_pcc_lcdtype_open_fs);
-static fops_t acpi_pcc_mute_fops              = SEQ_FILEOPS_RW(acpi_pcc_mute_open_fs, acpi_pcc_write_mute);
-static fops_t acpi_pcc_ac_brightness_fops     = SEQ_FILEOPS_RW(acpi_pcc_ac_brightness_open_fs, acpi_pcc_write_ac_brightness);
-static fops_t acpi_pcc_ac_brightness_max_fops = SEQ_FILEOPS_R (acpi_pcc_ac_brightness_max_open_fs);
-static fops_t acpi_pcc_ac_brightness_min_fops = SEQ_FILEOPS_R (acpi_pcc_ac_brightness_min_open_fs);
-static fops_t acpi_pcc_dc_brightness_fops     = SEQ_FILEOPS_RW(acpi_pcc_dc_brightness_open_fs, acpi_pcc_write_dc_brightness);
-static fops_t acpi_pcc_dc_brightness_max_fops = SEQ_FILEOPS_R (acpi_pcc_dc_brightness_max_open_fs);
-static fops_t acpi_pcc_dc_brightness_min_fops = SEQ_FILEOPS_R (acpi_pcc_dc_brightness_min_open_fs);
-static fops_t acpi_pcc_brightness_fops        = SEQ_FILEOPS_RW(acpi_pcc_brightness_open_fs, acpi_pcc_write_no_brightness);
-static fops_t acpi_pcc_sticky_key_fops        = SEQ_FILEOPS_RW(acpi_pcc_sticky_key_open_fs, acpi_pcc_write_sticky_key);
-static fops_t acpi_pcc_keyinput_fops          = SEQ_FILEOPS_RW(acpi_pcc_keyinput_open_fs, acpi_pcc_write_keyinput);
-static fops_t acpi_pcc_version_fops           = SEQ_FILEOPS_R (acpi_pcc_version_open_fs);
+SEQ_OPEN_FS(acpi_pcc_dc_brightness_open_fs, acpi_pcc_dc_brightness_show);
+SEQ_OPEN_FS(acpi_pcc_numbatteries_open_fs, acpi_pcc_numbatteries_show);
+SEQ_OPEN_FS(acpi_pcc_lcdtype_open_fs, acpi_pcc_lcdtype_show);
+SEQ_OPEN_FS(acpi_pcc_ac_brightness_max_open_fs,
+	    acpi_pcc_ac_brightness_max_show);
+SEQ_OPEN_FS(acpi_pcc_ac_brightness_min_open_fs,
+	    acpi_pcc_ac_brightness_min_show);
+SEQ_OPEN_FS(acpi_pcc_ac_brightness_open_fs, acpi_pcc_ac_brightness_show);
+SEQ_OPEN_FS(acpi_pcc_dc_brightness_max_open_fs,
+	    acpi_pcc_dc_brightness_max_show);
+SEQ_OPEN_FS(acpi_pcc_dc_brightness_min_open_fs,
+	    acpi_pcc_dc_brightness_min_show);
+SEQ_OPEN_FS(acpi_pcc_brightness_open_fs, acpi_pcc_brightness_show);
+SEQ_OPEN_FS(acpi_pcc_mute_open_fs, acpi_pcc_mute_show);
+SEQ_OPEN_FS(acpi_pcc_version_open_fs, acpi_pcc_version_show);
+SEQ_OPEN_FS(acpi_pcc_keyinput_open_fs, acpi_pcc_keyinput_show);
+SEQ_OPEN_FS(acpi_pcc_sticky_key_open_fs, acpi_pcc_sticky_key_show);
+
+static struct file_operations acpi_pcc_numbatteries_fops =
+	SEQ_FILEOPS_R(acpi_pcc_numbatteries_open_fs);
+static struct file_operations acpi_pcc_lcdtype_fops =
+	SEQ_FILEOPS_R(acpi_pcc_lcdtype_open_fs);
+static struct file_operations acpi_pcc_mute_fops =
+	SEQ_FILEOPS_RW(acpi_pcc_mute_open_fs, acpi_pcc_write_mute);
+static struct file_operations acpi_pcc_ac_brightness_fops =
+	SEQ_FILEOPS_RW(acpi_pcc_ac_brightness_open_fs,
+		       acpi_pcc_write_ac_brightness);
+static struct file_operations acpi_pcc_ac_brightness_max_fops =
+	SEQ_FILEOPS_R(acpi_pcc_ac_brightness_max_open_fs);
+static struct file_operations acpi_pcc_ac_brightness_min_fops =
+	SEQ_FILEOPS_R(acpi_pcc_ac_brightness_min_open_fs);
+static struct file_operations acpi_pcc_dc_brightness_fops =
+	SEQ_FILEOPS_RW(acpi_pcc_dc_brightness_open_fs,
+		       acpi_pcc_write_dc_brightness);
+static struct file_operations acpi_pcc_dc_brightness_max_fops =
+	SEQ_FILEOPS_R(acpi_pcc_dc_brightness_max_open_fs);
+static struct file_operations acpi_pcc_dc_brightness_min_fops =
+	SEQ_FILEOPS_R(acpi_pcc_dc_brightness_min_open_fs);
+static struct file_operations acpi_pcc_brightness_fops =
+	SEQ_FILEOPS_RW(acpi_pcc_brightness_open_fs,
+		       acpi_pcc_write_no_brightness);
+static struct file_operations acpi_pcc_sticky_key_fops =
+	SEQ_FILEOPS_RW(acpi_pcc_sticky_key_open_fs, acpi_pcc_write_sticky_key);
+static struct file_operations acpi_pcc_keyinput_fops =
+	SEQ_FILEOPS_RW(acpi_pcc_keyinput_open_fs, acpi_pcc_write_keyinput);
+static struct file_operations acpi_pcc_version_fops =
+	SEQ_FILEOPS_R(acpi_pcc_version_open_fs);
 
-typedef struct _ProcItem
-{
-	const char* name;
+struct proc_item {
+	const char *name;
 	struct file_operations *fops;
 	mode_t flag;
-} ProcItem;
+};
 
 /* Note: These functions map *exactly* to the SINF/SSET functions */
-ProcItem acpi_pcc_proc_items_sifr[] = {
-	{ "num_batteries",	&acpi_pcc_numbatteries_fops,	 S_IRUGO },
-	{ "lcd_type",		&acpi_pcc_lcdtype_fops,		 S_IRUGO },
-	{ "ac_brightness_max" , &acpi_pcc_ac_brightness_max_fops,S_IRUGO },
-	{ "ac_brightness_min" , &acpi_pcc_ac_brightness_min_fops,S_IRUGO },
-	{ "ac_brightness" ,	&acpi_pcc_ac_brightness_fops,	 S_IFREG | S_IRUGO | S_IWUSR },
-	{ "dc_brightness_max" , &acpi_pcc_dc_brightness_max_fops,S_IRUGO },
-	{ "dc_brightness_min" , &acpi_pcc_dc_brightness_min_fops,S_IRUGO },
-	{ "dc_brightness" ,	&acpi_pcc_dc_brightness_fops,	 S_IFREG | S_IRUGO | S_IWUSR },
-	{ "brightness" ,	&acpi_pcc_brightness_fops,    S_IFREG | S_IRUGO | S_IWUSR },
-	{ "mute",		&acpi_pcc_mute_fops,		 S_IFREG | S_IRUGO | S_IWUSR },
+struct proc_item acpi_pcc_proc_items_sifr[] = {
+	{ "num_batteries", &acpi_pcc_numbatteries_fops, S_IRUGO },
+	{ "lcd_type", &acpi_pcc_lcdtype_fops, S_IRUGO },
+	{ "ac_brightness_max", &acpi_pcc_ac_brightness_max_fops, S_IRUGO },
+	{ "ac_brightness_min", &acpi_pcc_ac_brightness_min_fops, S_IRUGO },
+	{ "ac_brightness", &acpi_pcc_ac_brightness_fops,
+		S_IFREG | S_IRUGO | S_IWUSR },
+	{ "dc_brightness_max", &acpi_pcc_dc_brightness_max_fops, S_IRUGO },
+	{ "dc_brightness_min", &acpi_pcc_dc_brightness_min_fops, S_IRUGO },
+	{ "dc_brightness", &acpi_pcc_dc_brightness_fops,
+		S_IFREG | S_IRUGO | S_IWUSR },
+	{ "brightness", &acpi_pcc_brightness_fops, S_IFREG | S_IRUGO | S_IWUSR},
+	{ "mute", &acpi_pcc_mute_fops, S_IFREG | S_IRUGO | S_IWUSR },
 	{ NULL, NULL, 0 },
 };
 
-ProcItem acpi_pcc_proc_items[] = {
-	{ "sticky_key",		&acpi_pcc_sticky_key_fops,	 S_IFREG | S_IRUGO | S_IWUSR },
-	{ "keyinput",		&acpi_pcc_keyinput_fops,	 S_IFREG | S_IRUGO | S_IWUSR },
-	{ "version",		&acpi_pcc_version_fops,		 S_IRUGO },
+struct proc_item acpi_pcc_proc_items[] = {
+	{ "sticky_key", &acpi_pcc_sticky_key_fops, S_IFREG | S_IRUGO | S_IWUSR},
+	{ "keyinput", &acpi_pcc_keyinput_fops, S_IFREG | S_IRUGO | S_IWUSR },
+	{ "version", &acpi_pcc_version_fops, S_IRUGO },
 	{ NULL, NULL, 0 },
 };
 
 static int __devinit acpi_pcc_add_device(struct acpi_device *device,
-					 ProcItem *proc_items,
+					 struct proc_item *proc_items,
 					 int num)
 {
-	struct acpi_hotkey *hotkey = (struct acpi_hotkey*)acpi_driver_data(device);
-	struct proc_dir_entry* proc;
-	ProcItem* item;
+	struct acpi_hotkey *hotkey = acpi_driver_data(device);
+	struct proc_dir_entry *proc;
+	struct proc_item *item;
 	int i;
 
 	for (item = proc_items, i = 0; item->name && i < num; ++item, ++i) {
-		proc = create_proc_entry(item->name, item->flag, hotkey->proc_dir_entry);
+		proc = create_proc_entry(item->name, item->flag,
+					 hotkey->proc_dir_entry);
 		if (likely(proc)) {
 			proc->proc_fops = item->fops;
 			proc->data = hotkey;
@@ -756,7 +800,8 @@ static int __devinit acpi_pcc_add_device
 		} else {
 			while (i-- > 0) {
 				item--;
-				remove_proc_entry(item->name, hotkey->proc_dir_entry);
+				remove_proc_entry(item->name,
+					hotkey->proc_dir_entry);
 			}
 			return_VALUE(-ENODEV);
 		}
@@ -767,7 +812,7 @@ static int __devinit acpi_pcc_add_device
 static int __devinit acpi_pcc_proc_init(struct acpi_device *device)
 {
 	struct proc_dir_entry *acpi_pcc_dir;
-	struct acpi_hotkey    *hotkey = (struct acpi_hotkey*)acpi_driver_data(device);
+	struct acpi_hotkey    *hotkey = acpi_driver_data(device);
 	acpi_status status;
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_proc_init");
@@ -775,15 +820,18 @@ static int __devinit acpi_pcc_proc_init(
 	acpi_pcc_dir = proc_mkdir(PROC_PCC, acpi_root_dir);
 
 	if (unlikely(!acpi_pcc_dir)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Couldn't create dir in /proc\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Couldn't create dir in /proc\n"));
 		return_VALUE(-ENODEV);
 	}
 
 	acpi_pcc_dir->owner = THIS_MODULE;
 	hotkey->proc_dir_entry = acpi_pcc_dir;
 
-	status =  acpi_pcc_add_device(device, acpi_pcc_proc_items_sifr, hotkey->num_sifr);
-	status |= acpi_pcc_add_device(device, acpi_pcc_proc_items,      ARRAY_SIZE(acpi_pcc_proc_items));
+	status =  acpi_pcc_add_device(device, acpi_pcc_proc_items_sifr,
+				      hotkey->num_sifr);
+	status |= acpi_pcc_add_device(device, acpi_pcc_proc_items,
+				      ARRAY_SIZE(acpi_pcc_proc_items));
 	if (unlikely(status)) {
 		remove_proc_entry(PROC_PCC, acpi_root_dir);
 		hotkey->proc_dir_entry = NULL;
@@ -794,14 +842,16 @@ static int __devinit acpi_pcc_proc_init(
 }
 
 static void __devexit acpi_pcc_remove_device(struct acpi_device *device,
-					     ProcItem *proc_items,
+					     struct proc_item *proc_items,
 					     int num)
 {
-	struct acpi_hotkey *hotkey = (struct acpi_hotkey*)acpi_driver_data(device);
-	ProcItem* item;
+	struct acpi_hotkey *hotkey = acpi_driver_data(device);
+	struct proc_item *item;
 	int i;
 
-	for (item = proc_items, i = 0; item->name != NULL && i < num; ++item, ++i) {
+	for (item = proc_items, i = 0;
+	     item->name != NULL && i < num;
+	     ++item, ++i) {
 		remove_proc_entry(item->name, hotkey->proc_dir_entry);
 	}
 
@@ -819,14 +869,18 @@ static int acpi_pcc_hotkey_resume(struct
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_hotkey_resume");
 
-	if (device == NULL || hotkey == NULL) { return_VALUE(-EINVAL); }
+	if (device == NULL || hotkey == NULL)
+		return_VALUE(-EINVAL);
 
 	if (hotkey->num_sifr != 0) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Sticky mode restore: %d\n", hotkey->sticky_mode));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Sticky mode restore: %d\n",
+				 hotkey->sticky_mode));
 
-		status = acpi_pcc_write_sset(hotkey, SINF_STICKY_KEY, hotkey->sticky_mode);
+		status = acpi_pcc_write_sset(hotkey, SINF_STICKY_KEY,
+					     hotkey->sticky_mode);
 	}
-	if (status != AE_OK) { return_VALUE(-EINVAL); }
+	if (status != AE_OK)
+		return_VALUE(-EINVAL);
 
 	return_VALUE(0);
 }
@@ -848,14 +902,16 @@ static int __devinit acpi_pcc_init_input
 
 	hotk_input_dev = input_allocate_device();
 	if (hotk_input_dev == NULL) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Couldn't allocate input device for hotkey"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Couldn't allocate input device for hotkey"));
 		goto err_input;
 	}
 
 	pcc_keyinput = kcalloc(1, sizeof(struct pcc_keyinput), GFP_KERNEL);
 
 	if (pcc_keyinput == NULL) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Couldn't allocate mem for private data"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Couldn't allocate mem for private data"));
 		goto err_pcc;
 	}
 
@@ -886,9 +942,8 @@ static int __devinit acpi_pcc_init_input
 
 	error = input_register_device(hotk_input_dev);
 
-	if (error) {
+	if (error)
 		goto err_pcc;
-	}
 
 	return_VALUE(0);
 
@@ -921,7 +976,7 @@ static void __devexit acpi_pcc_remove_in
 /* -------------------------------------------------------------------------
    ACPI
    ------------------------------------------------------------------------- */
-static int __devinit acpi_pcc_hotkey_add (struct acpi_device *device)
+static int __devinit acpi_pcc_hotkey_add(struct acpi_device *device)
 {
 	acpi_status		status = AE_OK;
 	struct acpi_hotkey	*hotkey = NULL;
@@ -929,9 +984,8 @@ static int __devinit acpi_pcc_hotkey_add
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_hotkey_add");
 
-	if (device == NULL) {
+	if (device == NULL)
 		return_VALUE(-EINVAL);
-	}
 
 	sifr_status = acpi_pcc_get_sqty(device);
 
@@ -949,7 +1003,8 @@ static int __devinit acpi_pcc_hotkey_add
 
 	hotkey = kcalloc(1, sizeof(struct acpi_hotkey), GFP_KERNEL);
 	if (hotkey == NULL) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Couldn't allocate mem for hotkey"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Couldn't allocate mem for hotkey"));
 		return_VALUE(-ENOMEM);
 	}
 
@@ -966,14 +1021,16 @@ static int __devinit acpi_pcc_hotkey_add
 					     hotkey);
 
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error installing notify handler\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Error installing notify handler\n"));
 		kfree(hotkey);
 		return_VALUE(-ENODEV);
 	}
 
 	result = acpi_pcc_init_input(hotkey);
 	if (result != 0) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error installing keyinput handler\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Error installing keyinput handler\n"));
 		kfree(hotkey);
 		return_VALUE(result);
 	}
@@ -981,20 +1038,22 @@ static int __devinit acpi_pcc_hotkey_add
 	return_VALUE(acpi_pcc_proc_init(device));
 }
 
-static int __devexit acpi_pcc_hotkey_remove(struct acpi_device *device, int type)
+static int __devexit acpi_pcc_hotkey_remove(struct acpi_device *device,
+					    int type)
 {
 	acpi_status		status = AE_OK;
 	struct acpi_hotkey	*hotkey = acpi_driver_data(device);
 
 	ACPI_FUNCTION_TRACE("acpi_pcc_hotkey_remove");
 
-	if (!device || !hotkey) {
+	if (!device || !hotkey)
 		return_VALUE(-EINVAL);
-	}
 
 	if (hotkey->proc_dir_entry) {
-		acpi_pcc_remove_device(device, acpi_pcc_proc_items_sifr, hotkey->num_sifr);
-		acpi_pcc_remove_device(device, acpi_pcc_proc_items,      ARRAY_SIZE(acpi_pcc_proc_items));
+		acpi_pcc_remove_device(device, acpi_pcc_proc_items_sifr,
+				       hotkey->num_sifr);
+		acpi_pcc_remove_device(device, acpi_pcc_proc_items,
+				       ARRAY_SIZE(acpi_pcc_proc_items));
 		remove_proc_entry(PROC_PCC, acpi_root_dir);
 	}
 
@@ -1002,13 +1061,12 @@ static int __devexit acpi_pcc_hotkey_rem
 		    ACPI_DEVICE_NOTIFY, acpi_pcc_hotkey_notify);
 
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error removing notify handler\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Error removing notify handler\n"));
 	}
 
 	acpi_pcc_remove_input(hotkey);
-	if (hotkey != NULL) {
-		kfree(hotkey);
-	}
+	kfree(hotkey);
 	return_VALUE(status == AE_OK);
 }
 
@@ -1030,7 +1088,8 @@ static int __init acpi_pcc_init(void)
 
 	result = acpi_bus_register_driver(&acpi_pcc_driver);
 	if (result < 0) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error registering hotkey driver\n"));
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				 "Error registering hotkey driver\n"));
 		return_VALUE(-ENODEV);
 	}
 
