From martyn.welch@ge.com  Thu Feb 25 10:11:57 2010
From: Martyn Welch <martyn.welch@ge.com>
Date: Thu, 18 Feb 2010 16:22:13 +0000
Subject: Staging: vme: Remove legacy unsupported code
To: gregkh@suse.de
Cc: devel@linuxdriverproject.org
Message-ID: <20100218162035.28122.8946.stgit@ES-J7S4D2J.amer.consind.ge.com>


Remove the code from the drivers that we are not going to implement before
submitting for review.

Signed-off-by: Martyn Welch <martyn.welch@ge.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/vme/bridges/vme_ca91cx42.c |  150 ------------
 drivers/staging/vme/bridges/vme_tsi148.c   |  351 -----------------------------
 drivers/staging/vme/vme.c                  |    4 
 drivers/staging/vme/vme_bridge.h           |   58 ----
 4 files changed, 4 insertions(+), 559 deletions(-)

--- a/drivers/staging/vme/bridges/vme_ca91cx42.c
+++ b/drivers/staging/vme/bridges/vme_ca91cx42.c
@@ -93,21 +93,6 @@ static u32 ca91cx42_IACK_irqhandler(stru
 	return CA91CX42_LINT_SW_IACK;
 }
 
-#if 0
-int ca91cx42_bus_error_chk(int clrflag)
-{
-	int tmp;
-	tmp = ioread32(bridge->base + PCI_COMMAND);
-	if (tmp & 0x08000000) {	/* S_TA is Set */
-		if (clrflag)
-			iowrite32(tmp | 0x08000000,
-			       bridge->base + PCI_COMMAND);
-		return 1;
-	}
-	return 0;
-}
-#endif
-
 static u32 ca91cx42_VERR_irqhandler(struct ca91cx42_driver *bridge)
 {
 	int val;
@@ -379,10 +364,6 @@ int ca91cx42_slave_set(struct vme_slave_
 	vme_bound = vme_base + size;
 	pci_offset = pci_base - vme_base;
 
-	/* XXX Need to check that vme_base, vme_bound and pci_offset aren't
-	 * too big for registers
-	 */
-
 	if ((i == 0) || (i == 4))
 		granularity = 0x1000;
 	else
@@ -411,18 +392,6 @@ int ca91cx42_slave_set(struct vme_slave_
 	iowrite32(vme_bound, bridge->base + CA91CX42_VSI_BD[i]);
 	iowrite32(pci_offset, bridge->base + CA91CX42_VSI_TO[i]);
 
-/* XXX Prefetch stuff currently unsupported */
-#if 0
-	if (vmeIn->wrPostEnable)
-		temp_ctl |= CA91CX42_VSI_CTL_PWEN;
-	if (vmeIn->prefetchEnable)
-		temp_ctl |= CA91CX42_VSI_CTL_PREN;
-	if (vmeIn->rmwLock)
-		temp_ctl |= CA91CX42_VSI_CTL_LLRMW;
-	if (vmeIn->data64BitCapable)
-		temp_ctl |= CA91CX42_VSI_CTL_LD64EN;
-#endif
-
 	/* Setup address space */
 	temp_ctl &= ~CA91CX42_VSI_CTL_VAS_M;
 	temp_ctl |= addr;
@@ -637,9 +606,6 @@ int ca91cx42_master_set(struct vme_maste
 
 	spin_lock(&(image->lock));
 
-	/* XXX We should do this much later, so that we can exit without
-	 *     needing to redo the mapping...
-	 */
 	/*
 	 * Let's allocate the resource here rather than further up the stack as
 	 * it avoids pushing loads of bus dependant stuff up the stack
@@ -667,12 +633,6 @@ int ca91cx42_master_set(struct vme_maste
 	temp_ctl &= ~CA91CX42_LSI_CTL_EN;
 	iowrite32(temp_ctl, bridge->base + CA91CX42_LSI_CTL[i]);
 
-/* XXX Prefetch stuff currently unsupported */
-#if 0
-	if (vmeOut->wrPostEnable)
-		temp_ctl |= 0x40000000;
-#endif
-
 	/* Setup cycle types */
 	temp_ctl &= ~CA91CX42_LSI_CTL_VCT_M;
 	if (cycle & VME_BLT)
@@ -849,12 +809,6 @@ int __ca91cx42_master_get(struct vme_mas
 		break;
 	}
 
-/* XXX Prefetch stuff currently unsupported */
-#if 0
-	if (ctl & 0x40000000)
-		vmeOut->wrPostEnable = 1;
-#endif
-
 	return 0;
 }
 
@@ -1812,9 +1766,9 @@ void ca91cx42_remove(struct pci_dev *pde
 	iowrite32(0x00F00000, bridge->base + VSI7_CTL);
 
 	vme_unregister_bridge(ca91cx42_bridge);
-#if 0
-	ca91cx42_crcsr_exit(pdev);
-#endif
+
+	ca91cx42_crcsr_exit(ca91cx42_bridge, pdev);
+
 	/* resources are stored in link list */
 	list_for_each(pos, &(ca91cx42_bridge->lm_resources)) {
 		lm = list_entry(pos, struct vme_lm_resource, list);
@@ -1868,101 +1822,3 @@ MODULE_LICENSE("GPL");
 
 module_init(ca91cx42_init);
 module_exit(ca91cx42_exit);
-
-/*----------------------------------------------------------------------------
- * STAGING
- *--------------------------------------------------------------------------*/
-
-#if 0
-
-int ca91cx42_set_arbiter(vmeArbiterCfg_t *vmeArb)
-{
-	int temp_ctl = 0;
-	int vbto = 0;
-
-	temp_ctl = ioread32(bridge->base + MISC_CTL);
-	temp_ctl &= 0x00FFFFFF;
-
-	if (vmeArb->globalTimeoutTimer == 0xFFFFFFFF) {
-		vbto = 7;
-	} else if (vmeArb->globalTimeoutTimer > 1024) {
-		return -EINVAL;
-	} else if (vmeArb->globalTimeoutTimer == 0) {
-		vbto = 0;
-	} else {
-		vbto = 1;
-		while ((16 * (1 << (vbto - 1))) < vmeArb->globalTimeoutTimer)
-			vbto += 1;
-	}
-	temp_ctl |= (vbto << 28);
-
-	if (vmeArb->arbiterMode == VME_PRIORITY_MODE)
-		temp_ctl |= 1 << 26;
-
-	if (vmeArb->arbiterTimeoutFlag)
-		temp_ctl |= 2 << 24;
-
-	iowrite32(temp_ctl, bridge->base + MISC_CTL);
-	return 0;
-}
-
-int ca91cx42_get_arbiter(vmeArbiterCfg_t *vmeArb)
-{
-	int temp_ctl = 0;
-	int vbto = 0;
-
-	temp_ctl = ioread32(bridge->base + MISC_CTL);
-
-	vbto = (temp_ctl >> 28) & 0xF;
-	if (vbto != 0)
-		vmeArb->globalTimeoutTimer = (16 * (1 << (vbto - 1)));
-
-	if (temp_ctl & (1 << 26))
-		vmeArb->arbiterMode = VME_PRIORITY_MODE;
-	else
-		vmeArb->arbiterMode = VME_R_ROBIN_MODE;
-
-	if (temp_ctl & (3 << 24))
-		vmeArb->arbiterTimeoutFlag = 1;
-
-	return 0;
-}
-
-int ca91cx42_set_requestor(vmeRequesterCfg_t *vmeReq)
-{
-	int temp_ctl = 0;
-
-	temp_ctl = ioread32(bridge->base + MAST_CTL);
-	temp_ctl &= 0xFF0FFFFF;
-
-	if (vmeReq->releaseMode == 1)
-		temp_ctl |= (1 << 20);
-
-	if (vmeReq->fairMode == 1)
-		temp_ctl |= (1 << 21);
-
-	temp_ctl |= (vmeReq->requestLevel << 22);
-
-	iowrite32(temp_ctl, bridge->base + MAST_CTL);
-	return 0;
-}
-
-int ca91cx42_get_requestor(vmeRequesterCfg_t *vmeReq)
-{
-	int temp_ctl = 0;
-
-	temp_ctl = ioread32(bridge->base + MAST_CTL);
-
-	if (temp_ctl & (1 << 20))
-		vmeReq->releaseMode = 1;
-
-	if (temp_ctl & (1 << 21))
-		vmeReq->fairMode = 1;
-
-	vmeReq->requestLevel = (temp_ctl & 0xC00000) >> 22;
-
-	return 0;
-}
-
-
-#endif
--- a/drivers/staging/vme/bridges/vme_tsi148.c
+++ b/drivers/staging/vme/bridges/vme_tsi148.c
@@ -571,16 +571,6 @@ int tsi148_slave_set(struct vme_slave_re
 
 	bridge = image->parent->driver_priv;
 
-#if 0
-        printk("Set slave image %d to:\n", image->number);
- 	printk("\tEnabled: %s\n", (enabled == 1)? "yes" : "no");
-	printk("\tVME Base:0x%llx\n", vme_base);
-	printk("\tWindow Size:0x%llx\n", size);
-	printk("\tPCI Base:0x%lx\n", (unsigned long)pci_base);
-	printk("\tAddress Space:0x%x\n", aspace);
-	printk("\tTransfer Cycle Properties:0x%x\n", cycle);
-#endif
-
 	i = image->number;
 
 	switch (aspace) {
@@ -636,11 +626,6 @@ int tsi148_slave_set(struct vme_slave_re
 		return -EINVAL;
 	}
 
-#if 0
-	printk("\tVME Bound:0x%llx\n", vme_bound);
-	printk("\tPCI Offset:0x%llx\n", pci_offset);
-#endif
-
 	/*  Disable while we are mucking around */
 	temp_ctl = ioread32be(bridge->base + TSI148_LCSR_IT[i] +
 		TSI148_LCSR_OFFSET_ITAT);
@@ -662,23 +647,6 @@ int tsi148_slave_set(struct vme_slave_re
 	iowrite32be(pci_offset_low, bridge->base + TSI148_LCSR_IT[i] +
 		TSI148_LCSR_OFFSET_ITOFL);
 
-/* XXX Prefetch stuff currently unsupported */
-#if 0
-
-	for (x = 0; x < 4; x++) {
-		if ((64 << x) >= vmeIn->prefetchSize) {
-			break;
-		}
-	}
-	if (x == 4)
-		x--;
-	temp_ctl |= (x << 16);
-
-	if (vmeIn->prefetchThreshold)
-		if (vmeIn->prefetchThreshold)
-			temp_ctl |= 0x40000;
-#endif
-
 	/* Setup 2eSST speeds */
 	temp_ctl &= ~TSI148_LCSR_ITAT_2eSSTM_M;
 	switch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {
@@ -735,8 +703,6 @@ int tsi148_slave_set(struct vme_slave_re
 
 /*
  * Get slave window configuration.
- *
- * XXX Prefetch currently unsupported.
  */
 int tsi148_slave_get(struct vme_slave_resource *image, int *enabled,
 	unsigned long long *vme_base, unsigned long long *size,
@@ -1030,20 +996,6 @@ int tsi148_master_set( struct vme_master
 	iowrite32be(temp_ctl, bridge->base + TSI148_LCSR_OT[i] +
 		TSI148_LCSR_OFFSET_OTAT);
 
-/* XXX Prefetch stuff currently unsupported */
-#if 0
-	if (vmeOut->prefetchEnable) {
-		temp_ctl |= 0x40000;
-		for (x = 0; x < 4; x++) {
-			if ((2 << x) >= vmeOut->prefetchSize)
-				break;
-		}
-		if (x == 4)
-			x = 3;
-		temp_ctl |= (x << 16);
-	}
-#endif
-
 	/* Setup 2eSST speeds */
 	temp_ctl &= ~TSI148_LCSR_OTAT_2eSSTM_M;
 	switch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {
@@ -1156,12 +1108,6 @@ int tsi148_master_set( struct vme_master
 	iowrite32be(vme_offset_low, bridge->base + TSI148_LCSR_OT[i] +
 		TSI148_LCSR_OFFSET_OTOFL);
 
-/* XXX We need to deal with OTBS */
-#if 0
-	iowrite32be(vmeOut->bcastSelect2esst, bridge->base +
-		TSI148_LCSR_OT[i] + TSI148_LCSR_OFFSET_OTBS);
-#endif
-
 	/* Write ctl reg without enable */
 	iowrite32be(temp_ctl, bridge->base + TSI148_LCSR_OT[i] +
 		TSI148_LCSR_OFFSET_OTAT);
@@ -1669,8 +1615,6 @@ static int tsi148_dma_set_vme_dest_attri
 
 /*
  * Add a link list descriptor to the list
- *
- * XXX Need to handle 2eSST Broadcast select bits
  */
 int tsi148_dma_list_add (struct vme_dma_list *list, struct vme_dma_attr *src,
 	struct vme_dma_attr *dest, size_t count)
@@ -1683,7 +1627,7 @@ int tsi148_dma_list_add (struct vme_dma_
 	dma_addr_t desc_ptr;
 	int retval = 0;
 
-	/* XXX descriptor must be aligned on 64-bit boundaries */
+	/* Descriptor must be aligned on 64-bit boundaries */
 	entry = (struct tsi148_dma_entry *)kmalloc(
 		sizeof(struct tsi148_dma_entry), GFP_KERNEL);
 	if (entry == NULL) {
@@ -1850,9 +1794,6 @@ int tsi148_dma_list_exec(struct vme_dma_
 	dma_addr_t bus_addr;
 	u32 bus_addr_high, bus_addr_low;
 	u32 val, dctlreg = 0;
-#if 0
-	int x;
-#endif
 	struct tsi148_driver *bridge;
 
 	ctrlr = list->parent;
@@ -1875,48 +1816,6 @@ int tsi148_dma_list_exec(struct vme_dma_
 	} else {
 		list_add(&(list->list), &(ctrlr->running));
 	}
-#if 0
-	/* XXX Still todo */
-	for (x = 0; x < 8; x++) {	/* vme block size */
-		if ((32 << x) >= vmeDma->maxVmeBlockSize) {
-			break;
-		}
-	}
-	if (x == 8)
-		x = 7;
-	dctlreg |= (x << 12);
-
-	for (x = 0; x < 8; x++) {	/* pci block size */
-		if ((32 << x) >= vmeDma->maxPciBlockSize) {
-			break;
-		}
-	}
-	if (x == 8)
-		x = 7;
-	dctlreg |= (x << 4);
-
-	if (vmeDma->vmeBackOffTimer) {
-		for (x = 1; x < 8; x++) {	/* vme timer */
-			if ((1 << (x - 1)) >= vmeDma->vmeBackOffTimer) {
-				break;
-			}
-		}
-		if (x == 8)
-			x = 7;
-		dctlreg |= (x << 8);
-	}
-
-	if (vmeDma->pciBackOffTimer) {
-		for (x = 1; x < 8; x++) {	/* pci timer */
-			if ((1 << (x - 1)) >= vmeDma->pciBackOffTimer) {
-				break;
-			}
-		}
-		if (x == 8)
-			x = 7;
-		dctlreg |= (x << 0);
-	}
-#endif
 
 	/* Get first bus address and write into registers */
 	entry = list_first_entry(&(list->entries), struct tsi148_dma_entry,
@@ -2738,251 +2637,3 @@ MODULE_LICENSE("GPL");
 
 module_init(tsi148_init);
 module_exit(tsi148_exit);
-
-/*----------------------------------------------------------------------------
- * STAGING
- *--------------------------------------------------------------------------*/
-
-#if 0
-/*
- * Direct Mode DMA transfer
- *
- * XXX Not looking at direct mode for now, we can always use link list mode
- *     with a single entry.
- */
-int tsi148_dma_run(struct vme_dma_resource *resource, struct vme_dma_attr src,
-	struct vme_dma_attr dest, size_t count)
-{
-	u32 dctlreg = 0;
-	unsigned int tmp;
-	int val;
-	int channel, x;
-	struct vmeDmaPacket *cur_dma;
-	struct tsi148_dma_descriptor *dmaLL;
-
-	/* direct mode */
-	dctlreg = 0x800000;
-
-	for (x = 0; x < 8; x++) {	/* vme block size */
-		if ((32 << x) >= vmeDma->maxVmeBlockSize) {
-			break;
-		}
-	}
-	if (x == 8)
-		x = 7;
-	dctlreg |= (x << 12);
-
-	for (x = 0; x < 8; x++) {	/* pci block size */
-		if ((32 << x) >= vmeDma->maxPciBlockSize) {
-			break;
-		}
-	}
-	if (x == 8)
-		x = 7;
-	dctlreg |= (x << 4);
-
-	if (vmeDma->vmeBackOffTimer) {
-		for (x = 1; x < 8; x++) {	/* vme timer */
-			if ((1 << (x - 1)) >= vmeDma->vmeBackOffTimer) {
-				break;
-			}
-		}
-		if (x == 8)
-			x = 7;
-		dctlreg |= (x << 8);
-	}
-
-	if (vmeDma->pciBackOffTimer) {
-		for (x = 1; x < 8; x++) {	/* pci timer */
-			if ((1 << (x - 1)) >= vmeDma->pciBackOffTimer) {
-				break;
-			}
-		}
-		if (x == 8)
-			x = 7;
-		dctlreg |= (x << 0);
-	}
-
-	/* Program registers for DMA transfer */
-	iowrite32be(dmaLL->dsau, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DSAU);
-	iowrite32be(dmaLL->dsal, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DSAL);
-	iowrite32be(dmaLL->ddau, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DDAU);
-	iowrite32be(dmaLL->ddal, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DDAL);
-	iowrite32be(dmaLL->dsat, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DSAT);
-	iowrite32be(dmaLL->ddat, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DDAT);
-	iowrite32be(dmaLL->dcnt, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DCNT);
-	iowrite32be(dmaLL->ddbs, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DDBS);
-
-	/* Start the operation */
-	iowrite32be(dctlreg | 0x2000000, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DCTL);
-
-	tmp = ioread32be(tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DSTA);
-	wait_event_interruptible(dma_queue[channel], (tmp & 0x1000000) == 0);
-
-	/*
-	 * Read status register, we should probably do this in some error
-	 * handler rather than here so that we can be sure we haven't kicked off
-	 * another DMA transfer.
-	 */
-	val = ioread32be(tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DSTA);
-
-	vmeDma->vmeDmaStatus = 0;
-	if (val & 0x10000000) {
-		printk(KERN_ERR
-			"DMA Error in DMA_tempe_irqhandler DSTA=%08X\n",
-			val);
-		vmeDma->vmeDmaStatus = val;
-
-	}
-	return (0);
-}
-#endif
-
-#if 0
-
-/* Global VME controller information */
-struct pci_dev *vme_pci_dev;
-
-/*
- * Set the VME bus arbiter with the requested attributes
- */
-int tempe_set_arbiter(vmeArbiterCfg_t * vmeArb)
-{
-	int temp_ctl = 0;
-	int gto = 0;
-
-	temp_ctl = ioread32be(tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_VCTRL);
-	temp_ctl &= 0xFFEFFF00;
-
-	if (vmeArb->globalTimeoutTimer == 0xFFFFFFFF) {
-		gto = 8;
-	} else if (vmeArb->globalTimeoutTimer > 2048) {
-		return (-EINVAL);
-	} else if (vmeArb->globalTimeoutTimer == 0) {
-		gto = 0;
-	} else {
-		gto = 1;
-		while ((16 * (1 << (gto - 1))) < vmeArb->globalTimeoutTimer) {
-			gto += 1;
-		}
-	}
-	temp_ctl |= gto;
-
-	if (vmeArb->arbiterMode != VME_PRIORITY_MODE) {
-		temp_ctl |= 1 << 6;
-	}
-
-	if (vmeArb->arbiterTimeoutFlag) {
-		temp_ctl |= 1 << 7;
-	}
-
-	if (vmeArb->noEarlyReleaseFlag) {
-		temp_ctl |= 1 << 20;
-	}
-	iowrite32be(temp_ctl, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_VCTRL);
-
-	return (0);
-}
-
-/*
- * Return the attributes of the VME bus arbiter.
- */
-int tempe_get_arbiter(vmeArbiterCfg_t * vmeArb)
-{
-	int temp_ctl = 0;
-	int gto = 0;
-
-
-	temp_ctl = ioread32be(tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_VCTRL);
-
-	gto = temp_ctl & 0xF;
-	if (gto != 0) {
-		vmeArb->globalTimeoutTimer = (16 * (1 << (gto - 1)));
-	}
-
-	if (temp_ctl & (1 << 6)) {
-		vmeArb->arbiterMode = VME_R_ROBIN_MODE;
-	} else {
-		vmeArb->arbiterMode = VME_PRIORITY_MODE;
-	}
-
-	if (temp_ctl & (1 << 7)) {
-		vmeArb->arbiterTimeoutFlag = 1;
-	}
-
-	if (temp_ctl & (1 << 20)) {
-		vmeArb->noEarlyReleaseFlag = 1;
-	}
-
-	return (0);
-}
-
-/*
- * Set the VME bus requestor with the requested attributes
- */
-int tempe_set_requestor(vmeRequesterCfg_t * vmeReq)
-{
-	int temp_ctl = 0;
-
-	temp_ctl = ioread32be(tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_VMCTRL);
-	temp_ctl &= 0xFFFF0000;
-
-	if (vmeReq->releaseMode == 1) {
-		temp_ctl |= (1 << 3);
-	}
-
-	if (vmeReq->fairMode == 1) {
-		temp_ctl |= (1 << 2);
-	}
-
-	temp_ctl |= (vmeReq->timeonTimeoutTimer & 7) << 8;
-	temp_ctl |= (vmeReq->timeoffTimeoutTimer & 7) << 12;
-	temp_ctl |= vmeReq->requestLevel;
-
-	iowrite32be(temp_ctl, tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_VMCTRL);
-	return (0);
-}
-
-/*
- * Return the attributes of the VME bus requestor
- */
-int tempe_get_requestor(vmeRequesterCfg_t * vmeReq)
-{
-	int temp_ctl = 0;
-
-	temp_ctl = ioread32be(tsi148_bridge->driver_priv->base +
-		TSI148_LCSR_VMCTRL);
-
-	if (temp_ctl & 0x18) {
-		vmeReq->releaseMode = 1;
-	}
-
-	if (temp_ctl & (1 << 2)) {
-		vmeReq->fairMode = 1;
-	}
-
-	vmeReq->requestLevel = temp_ctl & 3;
-	vmeReq->timeonTimeoutTimer = (temp_ctl >> 8) & 7;
-	vmeReq->timeoffTimeoutTimer = (temp_ctl >> 12) & 7;
-
-	return (0);
-}
-
-
-#endif
--- a/drivers/staging/vme/vme.c
+++ b/drivers/staging/vme/vme.c
@@ -825,8 +825,6 @@ struct vme_dma_attr *vme_dma_vme_attribu
 	struct vme_dma_attr *attributes;
 	struct vme_dma_vme *vme_attr;
 
-	/* XXX Run some sanity checks here */
-
 	attributes = kmalloc(
 		sizeof(struct vme_dma_attr), GFP_KERNEL);
 	if (attributes == NULL) {
@@ -1191,8 +1189,6 @@ int vme_lm_set(struct vme_resource *reso
 		return -EINVAL;
 	}
 
-	/* XXX Check parameters */
-
 	return bridge->lm_set(lm, lm_base, aspace, cycle);
 }
 EXPORT_SYMBOL(vme_lm_set);
--- a/drivers/staging/vme/vme_bridge.h
+++ b/drivers/staging/vme/vme_bridge.h
@@ -165,16 +165,6 @@ struct vme_bridge {
 
 	/* CR/CSR space functions */
 	int (*slot_get) (struct vme_bridge *);
-	/* Use standard master read and write functions to access CR/CSR */
-
-#if 0
-	int (*set_prefetch) (void);
-	int (*get_prefetch) (void);
-	int (*set_arbiter) (void);
-	int (*get_arbiter) (void);
-	int (*set_requestor) (void);
-	int (*get_requestor) (void);
-#endif
 };
 
 void vme_irq_handler(struct vme_bridge *, int, int);
@@ -183,51 +173,3 @@ int vme_register_bridge(struct vme_bridg
 void vme_unregister_bridge(struct vme_bridge *);
 
 #endif /* _VME_BRIDGE_H_ */
-
-#if 0
-/*
- *  VMEbus GET INFO Arg Structure
- */
-struct vmeInfoCfg {
-	int vmeSlotNum;		/*  VME slot number of interest */
-	int boardResponded;	/* Board responded */
-	char sysConFlag;	/*  System controller flag */
-	int vmeControllerID;	/*  Vendor/device ID of VME bridge */
-	int vmeControllerRev;	/*  Revision of VME bridge */
-	char osName[8];		/*  Name of OS e.g. "Linux" */
-	int vmeSharedDataValid;	/*  Validity of data struct */
-	int vmeDriverRev;	/*  Revision of VME driver */
-	unsigned int vmeAddrHi[8];	/* Address on VME bus */
-	unsigned int vmeAddrLo[8];	/* Address on VME bus */
-	unsigned int vmeSize[8];	/* Size on VME bus */
-	unsigned int vmeAm[8];	/* Address modifier on VME bus */
-	int reserved;		/* For future use */
-};
-typedef struct vmeInfoCfg vmeInfoCfg_t;
-
-/*
- *  VMEbus Requester Arg Structure
- */
-struct vmeRequesterCfg {
-	int requestLevel;	/*  Requester Bus Request Level */
-	char fairMode;		/*  Requester Fairness Mode Indicator */
-	int releaseMode;	/*  Requester Bus Release Mode */
-	int timeonTimeoutTimer;	/*  Master Time-on Time-out Timer */
-	int timeoffTimeoutTimer;	/*  Master Time-off Time-out Timer */
-	int reserved;		/* For future use */
-};
-typedef struct vmeRequesterCfg vmeRequesterCfg_t;
-
-/*
- *  VMEbus Arbiter Arg Structure
- */
-struct vmeArbiterCfg {
-	vme_arbitration_t arbiterMode;	/*  Arbitration Scheduling Algorithm */
-	char arbiterTimeoutFlag;	/*  Arbiter Time-out Timer Indicator */
-	int globalTimeoutTimer;	/*  VMEbus Global Time-out Timer */
-	char noEarlyReleaseFlag;	/*  No Early Release on BBUSY */
-	int reserved;		/* For future use */
-};
-typedef struct vmeArbiterCfg vmeArbiterCfg_t;
-
-#endif
