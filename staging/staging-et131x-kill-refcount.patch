From alan@linux.intel.com  Thu Aug 27 14:23:37 2009
From: Alan Cox <alan@linux.intel.com>
Date: Thu, 27 Aug 2009 10:58:49 +0100
Subject: Staging et131x: kill refcount
To: greg@kroah.com
Message-ID: <20090827095842.23892.6579.stgit@localhost.localdomain>


The RefCount field is accessed only by a macro and the only use of it in
the tree is to read it, so it can go

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_pm.c      |    2 --
 drivers/staging/et131x/et1310_rx.c      |    7 -------
 drivers/staging/et131x/et131x_adapter.h |    4 ----
 3 files changed, 13 deletions(-)


--- a/drivers/staging/et131x/et1310_pm.c
+++ b/drivers/staging/et131x/et1310_pm.c
@@ -139,8 +139,6 @@ void EnablePhyComa(struct et131x_adapter
 	spin_unlock_irqrestore(&etdev->SendHWLock, flags);
 
 	/* Wait for outstanding Receive packets */
-	while ((MP_GET_RCV_REF(etdev) != 0) && (LoopCounter-- > 0))
-		mdelay(2);
 
 	/* Gate off JAGCore 3 clock domains */
 	GlobalPmCSR.bits.pm_sysclk_gate = 0;
--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -1258,13 +1258,6 @@ void et131x_handle_recv_interrupt(struct
 			 * Besides, we don't really need (at this point) the
 			 * pending list anyway.
 			 */
-			/* spin_lock_irqsave( &etdev->RcvPendLock, flags );
-			 * list_add_tail( &pMpRfd->list_node, &etdev->RxRing.RecvPendingList );
-			 * spin_unlock_irqrestore( &etdev->RcvPendLock, flags );
-			 */
-
-			/* Update the number of outstanding Recvs */
-			/* MP_INC_RCV_REF( etdev ); */
 		} else {
 			RFDFreeArray[PacketFreeCount] = pMpRfd;
 			PacketFreeCount++;
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -108,8 +108,6 @@
 #define MP_TEST_FLAGS(_M, _F)       (((_M)->Flags & (_F)) == (_F))
 #define MP_IS_FLAG_CLEAR(_M, _F)    (((_M)->Flags & (_F)) == 0)
 
-#define MP_GET_RCV_REF(_A)          atomic_read(&(_A)->RcvRefCount)
-
 /* Macros specific to the private adapter structure */
 #define MP_TCB_RESOURCES_AVAILABLE(_M) ((_M)->TxRing.nBusySend < NUM_TCB)
 #define MP_TCB_RESOURCES_NOT_AVAILABLE(_M) ((_M)->TxRing.nBusySend >= NUM_TCB)
@@ -311,8 +309,6 @@ struct et131x_adapter {
 	MP_POWER_MGMT PoMgmt;
 	INTERRUPT_t CachedMaskValue;
 
-	atomic_t RcvRefCount;	/* Num packets not yet returned */
-
 	/* Xcvr status at last poll */
 	MI_BMSR_t Bmsr;
 
