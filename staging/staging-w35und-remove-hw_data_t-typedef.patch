From penberg@cs.helsinki.fi  Wed Jan 21 09:39:05 2009
From: Pekka J Enberg <penberg@cs.helsinki.fi>
Date: Mon, 12 Jan 2009 18:02:47 +0200 (EET)
Subject: Staging: w35und: remove hw_data_t typedef
To: Greg Kroah-Hartman <greg@kroah.com>
Cc: Pavel Machek <pavel@suse.cz>, linux-kernel@vger.kernel.org
Message-ID: <Pine.LNX.4.64.0901121802110.16815@melkki.cs.Helsinki.FI>


From: Pekka Enberg <penberg@cs.helsinki.fi>

As this typedef is used everywhere in the driver, remove it in a separate
patch.

Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
Acked-by: Pavel Machek <pavel@suse.cz>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/winbond/core.h            |    2 
 drivers/staging/winbond/mds.c             |    4 -
 drivers/staging/winbond/phy_calibration.c |   26 ++++----
 drivers/staging/winbond/phy_calibration.h |    2 
 drivers/staging/winbond/reg.c             |   56 ++++++++---------
 drivers/staging/winbond/wb35reg.c         |   28 ++++----
 drivers/staging/winbond/wb35reg_f.h       |   70 +++++++++++-----------
 drivers/staging/winbond/wb35rx.c          |   16 ++---
 drivers/staging/winbond/wb35rx_f.h        |    6 -
 drivers/staging/winbond/wb35tx.c          |   22 +++----
 drivers/staging/winbond/wb35tx_f.h        |    8 +-
 drivers/staging/winbond/wbhal.c           |   42 ++++++-------
 drivers/staging/winbond/wbhal_f.h         |   94 +++++++++++++++---------------
 drivers/staging/winbond/wbhal_s.h         |    5 -
 drivers/staging/winbond/wbusb.c           |   12 +--
 15 files changed, 196 insertions(+), 197 deletions(-)

--- a/drivers/staging/winbond/core.h
+++ b/drivers/staging/winbond/core.h
@@ -20,7 +20,7 @@ struct wbsoft_priv {
 	MLME_FRAME sMlmeFrame;	// connect to peerSTA parameters
 
 	MTO_PARAMETERS sMtoPara;	// MTO_struct ...
-	hw_data_t sHwData;	//For HAL
+	struct hw_data sHwData;	//For HAL
 	MDS Mds;
 
 	spinlock_t SpinLock;
--- a/drivers/staging/winbond/mds.c
+++ b/drivers/staging/winbond/mds.c
@@ -418,7 +418,7 @@ static void Mds_HeaderCopy(struct wbsoft
 void
 Mds_Tx(struct wbsoft_priv * adapter)
 {
-	phw_data_t	pHwData = &adapter->sHwData;
+	struct hw_data *	pHwData = &adapter->sHwData;
 	PMDS		pMds = &adapter->Mds;
 	DESCRIPTOR	TxDes;
 	PDESCRIPTOR	pTxDes = &TxDes;
@@ -561,7 +561,7 @@ void
 Mds_SendComplete(struct wbsoft_priv * adapter, PT02_DESCRIPTOR pT02)
 {
 	PMDS	pMds = &adapter->Mds;
-	phw_data_t	pHwData = &adapter->sHwData;
+	struct hw_data *	pHwData = &adapter->sHwData;
 	u8	PacketId = (u8)pT02->T02_Tx_PktID;
 	unsigned char	SendOK = true;
 	u8	RetryCount, TxRate;
--- a/drivers/staging/winbond/phy_calibration.c
+++ b/drivers/staging/winbond/phy_calibration.c
@@ -37,8 +37,8 @@ static const fixed Angles[]=
 };
 
 /****************** LOCAL FUNCTION DECLARATION SECTION **********************/
-//void    _phy_rf_write_delay(hw_data_t *phw_data);
-//void    phy_init_rf(hw_data_t *phw_data);
+//void    _phy_rf_write_delay(struct hw_data *phw_data);
+//void    phy_init_rf(struct hw_data *phw_data);
 
 /****************** FUNCTION DEFINITION SECTION *****************************/
 
@@ -341,7 +341,7 @@ void _sin_cos(s32 angle, s32 *sin, s32 *
 }
 
 
-void _reset_rx_cal(hw_data_t *phw_data)
+void _reset_rx_cal(struct hw_data *phw_data)
 {
 	u32     val;
 
@@ -366,7 +366,7 @@ void _reset_rx_cal(hw_data_t *phw_data)
 //
 //
 // *********************************************
-void _rxadc_dc_offset_cancellation_winbond(hw_data_t *phw_data, u32 frequency)
+void _rxadc_dc_offset_cancellation_winbond(struct hw_data *phw_data, u32 frequency)
 {
     u32     reg_agc_ctrl3;
     u32     reg_a_acq_ctrl;
@@ -465,7 +465,7 @@ void _rxadc_dc_offset_cancellation_winbo
 }
 
 ////////////////////////////////////////////////////////
-void _txidac_dc_offset_cancellation_winbond(hw_data_t *phw_data)
+void _txidac_dc_offset_cancellation_winbond(struct hw_data *phw_data)
 {
 	u32     reg_agc_ctrl3;
 	u32     reg_mode_ctrl;
@@ -600,7 +600,7 @@ void _txidac_dc_offset_cancellation_winb
 }
 
 ///////////////////////////////////////////////////////
-void _txqdac_dc_offset_cacellation_winbond(hw_data_t *phw_data)
+void _txqdac_dc_offset_cacellation_winbond(struct hw_data *phw_data)
 {
 	u32     reg_agc_ctrl3;
 	u32     reg_mode_ctrl;
@@ -726,7 +726,7 @@ void _txqdac_dc_offset_cacellation_winbo
 }
 
 //20060612.1.a 20060718.1 Modify
-u8 _tx_iq_calibration_loop_winbond(hw_data_t *phw_data,
+u8 _tx_iq_calibration_loop_winbond(struct hw_data *phw_data,
 						   s32 a_2_threshold,
 						   s32 b_2_threshold)
 {
@@ -1032,7 +1032,7 @@ u8 _tx_iq_calibration_loop_winbond(hw_da
 	return 1;
 }
 
-void _tx_iq_calibration_winbond(hw_data_t *phw_data)
+void _tx_iq_calibration_winbond(struct hw_data *phw_data)
 {
 	u32     reg_agc_ctrl3;
 #ifdef _DEBUG
@@ -1195,7 +1195,7 @@ void _tx_iq_calibration_winbond(hw_data_
 }
 
 /////////////////////////////////////////////////////////////////////////////////////////
-u8 _rx_iq_calibration_loop_winbond(hw_data_t *phw_data, u16 factor, u32 frequency)
+u8 _rx_iq_calibration_loop_winbond(struct hw_data *phw_data, u16 factor, u32 frequency)
 {
 	u32     reg_mode_ctrl;
 	s32     iqcal_tone_i;
@@ -1501,7 +1501,7 @@ u8 _rx_iq_calibration_loop_winbond(hw_da
 //////////////////////////////////////////////////////////
 
 //////////////////////////////////////////////////////////////////////////
-void _rx_iq_calibration_winbond(hw_data_t *phw_data, u32 frequency)
+void _rx_iq_calibration_winbond(struct hw_data *phw_data, u32 frequency)
 {
 // figo 20050523 marked thsi flag for can't compile for relesase
 #ifdef _DEBUG
@@ -1579,7 +1579,7 @@ void _rx_iq_calibration_winbond(hw_data_
 }
 
 ////////////////////////////////////////////////////////////////////////
-void phy_calibration_winbond(hw_data_t *phw_data, u32 frequency)
+void phy_calibration_winbond(struct hw_data *phw_data, u32 frequency)
 {
 	u32     reg_mode_ctrl;
 	u32     iq_alpha;
@@ -1618,7 +1618,7 @@ void phy_calibration_winbond(hw_data_t *
 }
 
 //===========================
-void phy_set_rf_data(  phw_data_t pHwData,  u32 index,  u32 value )
+void phy_set_rf_data(  struct hw_data * pHwData,  u32 index,  u32 value )
 {
    u32 ltmp=0;
 
@@ -1660,7 +1660,7 @@ void phy_set_rf_data(  phw_data_t pHwDat
 }
 
 // 20060717 modify as Bruce's mail
-unsigned char adjust_TXVGA_for_iq_mag(hw_data_t *phw_data)
+unsigned char adjust_TXVGA_for_iq_mag(struct hw_data *phw_data)
 {
 	int init_txvga = 0;
 	u32     reg_mode_ctrl;
--- a/drivers/staging/winbond/phy_calibration.h
+++ b/drivers/staging/winbond/phy_calibration.h
@@ -101,7 +101,7 @@
 //#define MASK_IQCAL_IMAGE_Q         0x03FFE000
 //#define SHIFT_IQCAL_IMAGE_Q(x)     ((x)>>13)
 
-void phy_set_rf_data(  phw_data_t pHwData,  u32 index,  u32 value );
+void phy_set_rf_data(  struct hw_data * pHwData,  u32 index,  u32 value );
 #define phy_init_rf( _A )	//RFSynthesizer_initial( _A )
 
 #endif
--- a/drivers/staging/winbond/reg.c
+++ b/drivers/staging/winbond/reg.c
@@ -915,7 +915,7 @@ u32 w89rf242_txvga_data[][5] =
 //    The address is stored in EthernetIDAddr.
 //=============================================================================================================
 void
-Uxx_ReadEthernetAddress(  phw_data_t pHwData )
+Uxx_ReadEthernetAddress(  struct hw_data * pHwData )
 {
 	u32	ltmp;
 
@@ -964,7 +964,7 @@ void CardGetMulticastBit( u8 Address[ETH
 	*Value = (u8) ((u8)1 << (BitNumber % 8));
 }
 
-void Uxx_power_on_procedure(  phw_data_t pHwData )
+void Uxx_power_on_procedure(  struct hw_data * pHwData )
 {
 	u32	ltmp, loop;
 
@@ -1008,7 +1008,7 @@ void Uxx_power_on_procedure(  phw_data_t
 	Wb35Reg_WriteSync( pHwData, 0x03f8, 0x7ff );
 }
 
-void Set_ChanIndep_RfData_al7230_24(  phw_data_t pHwData, u32 *pltmp ,char number)
+void Set_ChanIndep_RfData_al7230_24(  struct hw_data * pHwData, u32 *pltmp ,char number)
 {
 	u8	i;
 
@@ -1019,7 +1019,7 @@ void Set_ChanIndep_RfData_al7230_24(  ph
 	}
 }
 
-void Set_ChanIndep_RfData_al7230_50(  phw_data_t pHwData, u32 *pltmp, char number)
+void Set_ChanIndep_RfData_al7230_50(  struct hw_data * pHwData, u32 *pltmp, char number)
 {
 	u8	i;
 
@@ -1035,7 +1035,7 @@ void Set_ChanIndep_RfData_al7230_50(  ph
 // RFSynthesizer_initial --
 //=============================================================================================================
 void
-RFSynthesizer_initial(phw_data_t pHwData)
+RFSynthesizer_initial(struct hw_data * pHwData)
 {
 	u32	altmp[32];
 	u32 *	pltmp = altmp;
@@ -1413,7 +1413,7 @@ RFSynthesizer_initial(phw_data_t pHwData
 	}
 }
 
-void BBProcessor_AL7230_2400(  phw_data_t pHwData)
+void BBProcessor_AL7230_2400(  struct hw_data * pHwData)
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	u32	pltmp[12];
@@ -1455,7 +1455,7 @@ void BBProcessor_AL7230_2400(  phw_data_
 
 }
 
-void BBProcessor_AL7230_5000(  phw_data_t pHwData)
+void BBProcessor_AL7230_5000(  struct hw_data * pHwData)
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	u32	pltmp[12];
@@ -1509,7 +1509,7 @@ void BBProcessor_AL7230_5000(  phw_data_
 //    None.
 //=============================================================================================================
 void
-BBProcessor_initial(  phw_data_t pHwData )
+BBProcessor_initial(  struct hw_data * pHwData )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	u32	i, pltmp[12];
@@ -1823,12 +1823,12 @@ BBProcessor_initial(  phw_data_t pHwData
 		reg->SQ3_filter[i] = 0x2f; // half of Bit 0 ~ 6
 }
 
-void set_tx_power_per_channel_max2829(  phw_data_t pHwData,  ChanInfo Channel)
+void set_tx_power_per_channel_max2829(  struct hw_data * pHwData,  ChanInfo Channel)
 {
 	RFSynthesizer_SetPowerIndex( pHwData, 100 ); // 20060620.1 Modify
 }
 
-void set_tx_power_per_channel_al2230(  phw_data_t pHwData,  ChanInfo Channel )
+void set_tx_power_per_channel_al2230(  struct hw_data * pHwData,  ChanInfo Channel )
 {
 	u8	index = 100;
 
@@ -1838,7 +1838,7 @@ void set_tx_power_per_channel_al2230(  p
 	RFSynthesizer_SetPowerIndex( pHwData, index );
 }
 
-void set_tx_power_per_channel_al7230(  phw_data_t pHwData,  ChanInfo Channel)
+void set_tx_power_per_channel_al7230(  struct hw_data * pHwData,  ChanInfo Channel)
 {
 	u8	i, index = 100;
 
@@ -1868,7 +1868,7 @@ void set_tx_power_per_channel_al7230(  p
 	RFSynthesizer_SetPowerIndex( pHwData, index );
 }
 
-void set_tx_power_per_channel_wb242(  phw_data_t pHwData,  ChanInfo Channel)
+void set_tx_power_per_channel_wb242(  struct hw_data * pHwData,  ChanInfo Channel)
 {
 	u8	index = 100;
 
@@ -1901,7 +1901,7 @@ void set_tx_power_per_channel_wb242(  ph
 //   None.
 //=============================================================================================================
 void
-RFSynthesizer_SwitchingChannel(  phw_data_t pHwData,  ChanInfo Channel )
+RFSynthesizer_SwitchingChannel(  struct hw_data * pHwData,  ChanInfo Channel )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	u32	pltmp[16]; // The 16 is the maximum capability of hardware
@@ -2129,7 +2129,7 @@ RFSynthesizer_SwitchingChannel(  phw_dat
 }
 
 //Set the tx power directly from DUT GUI, not from the EEPROM. Return the current setting
-u8 RFSynthesizer_SetPowerIndex(  phw_data_t pHwData,  u8 PowerIndex )
+u8 RFSynthesizer_SetPowerIndex(  struct hw_data * pHwData,  u8 PowerIndex )
 {
 	u32	Band = pHwData->band;
 	u8	index=0;
@@ -2187,7 +2187,7 @@ u8 RFSynthesizer_SetPowerIndex(  phw_dat
 }
 
 //-- Sub function
-u8 RFSynthesizer_SetMaxim2828_24Power(  phw_data_t pHwData, u8 index )
+u8 RFSynthesizer_SetMaxim2828_24Power(  struct hw_data * pHwData, u8 index )
 {
 	u32		PowerData;
 	if( index > 1 ) index = 1;
@@ -2196,7 +2196,7 @@ u8 RFSynthesizer_SetMaxim2828_24Power(  
 	return index;
 }
 //--
-u8 RFSynthesizer_SetMaxim2828_50Power(  phw_data_t pHwData, u8 index )
+u8 RFSynthesizer_SetMaxim2828_50Power(  struct hw_data * pHwData, u8 index )
 {
 	u32		PowerData;
 	if( index > 1 ) index = 1;
@@ -2205,7 +2205,7 @@ u8 RFSynthesizer_SetMaxim2828_50Power(  
 	return index;
 }
 //--
-u8 RFSynthesizer_SetMaxim2827_24Power(  phw_data_t pHwData, u8 index )
+u8 RFSynthesizer_SetMaxim2827_24Power(  struct hw_data * pHwData, u8 index )
 {
 	u32		PowerData;
 	if( index > 1 ) index = 1;
@@ -2214,7 +2214,7 @@ u8 RFSynthesizer_SetMaxim2827_24Power(  
 	return index;
 }
 //--
-u8 RFSynthesizer_SetMaxim2827_50Power(  phw_data_t pHwData, u8 index )
+u8 RFSynthesizer_SetMaxim2827_50Power(  struct hw_data * pHwData, u8 index )
 {
 	u32		PowerData;
 	if( index > 1 ) index = 1;
@@ -2223,7 +2223,7 @@ u8 RFSynthesizer_SetMaxim2827_50Power(  
 	return index;
 }
 //--
-u8 RFSynthesizer_SetMaxim2825Power(  phw_data_t pHwData, u8 index )
+u8 RFSynthesizer_SetMaxim2825Power(  struct hw_data * pHwData, u8 index )
 {
 	u32		PowerData;
 	if( index > 1 ) index = 1;
@@ -2232,7 +2232,7 @@ u8 RFSynthesizer_SetMaxim2825Power(  phw
 	return index;
 }
 //--
-u8 RFSynthesizer_SetAiroha2230Power(  phw_data_t pHwData, u8 index )
+u8 RFSynthesizer_SetAiroha2230Power(  struct hw_data * pHwData, u8 index )
 {
 	u32		PowerData;
 	u8		i,count;
@@ -2251,7 +2251,7 @@ u8 RFSynthesizer_SetAiroha2230Power(  ph
 	return i;
 }
 //--
-u8 RFSynthesizer_SetAiroha7230Power(  phw_data_t pHwData, u8 index )
+u8 RFSynthesizer_SetAiroha7230Power(  struct hw_data * pHwData, u8 index )
 {
 	u32		PowerData;
 	u8		i,count;
@@ -2270,7 +2270,7 @@ u8 RFSynthesizer_SetAiroha7230Power(  ph
 	return i;
 }
 
-u8 RFSynthesizer_SetWinbond242Power(  phw_data_t pHwData, u8 index )
+u8 RFSynthesizer_SetWinbond242Power(  struct hw_data * pHwData, u8 index )
 {
 	u32		PowerData;
 	u8		i,count;
@@ -2311,7 +2311,7 @@ u8 RFSynthesizer_SetWinbond242Power(  ph
 //		Initial the hardware setting and module variable
 	//
 //===========================================================================================================
-void Dxx_initial(  phw_data_t pHwData )
+void Dxx_initial(  struct hw_data * pHwData )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -2325,7 +2325,7 @@ void Dxx_initial(  phw_data_t pHwData )
 	Wb35Reg_WriteSync( pHwData, 0x0400, reg->D00_DmaControl );
 }
 
-void Mxx_initial(  phw_data_t pHwData )
+void Mxx_initial(  struct hw_data * pHwData )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	u32		tmp;
@@ -2416,7 +2416,7 @@ void Mxx_initial(  phw_data_t pHwData )
 }
 
 
-void Uxx_power_off_procedure(  phw_data_t pHwData )
+void Uxx_power_off_procedure(  struct hw_data * pHwData )
 {
 	// SW, PMU reset and turn off clock
 	Wb35Reg_WriteSync( pHwData, 0x03b0, 3 );
@@ -2424,7 +2424,7 @@ void Uxx_power_off_procedure(  phw_data_
 }
 
 //Decide the TxVga of every channel
-void GetTxVgaFromEEPROM(  phw_data_t pHwData )
+void GetTxVgaFromEEPROM(  struct hw_data * pHwData )
 {
 	u32		i, j, ltmp;
 	u16		Value[MAX_TXVGA_EEPROM];
@@ -2478,7 +2478,7 @@ void GetTxVgaFromEEPROM(  phw_data_t pHw
 // or RFSynthesizer_SetPowerIndex be called, new TxVga will take effect.
 // TxVgaSettingInEEPROM of sHwData is an u8 array point to EEPROM contain for IS89C35
 // This function will use default TxVgaSettingInEEPROM data to calculate new TxVga.
-void EEPROMTxVgaAdjust(  phw_data_t pHwData ) // 20060619.5 Add
+void EEPROMTxVgaAdjust(  struct hw_data * pHwData ) // 20060619.5 Add
 {
 	u8	*	pTxVga = pHwData->TxVgaSettingInEEPROM;
 	s16		i, stmp;
@@ -2618,7 +2618,7 @@ void EEPROMTxVgaAdjust(  phw_data_t pHwD
 	#endif
 }
 
-void BBProcessor_RateChanging(  phw_data_t pHwData,  u8 rate ) // 20060613.1
+void BBProcessor_RateChanging(  struct hw_data * pHwData,  u8 rate ) // 20060613.1
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	unsigned char		Is11bRate;
--- a/drivers/staging/winbond/wb35reg.c
+++ b/drivers/staging/winbond/wb35reg.c
@@ -3,7 +3,7 @@
 
 #include <linux/usb.h>
 
-extern void phy_calibration_winbond(hw_data_t *phw_data, u32 frequency);
+extern void phy_calibration_winbond(struct hw_data *phw_data, u32 frequency);
 
 // true  : read command process successfully
 // false : register not support
@@ -13,7 +13,7 @@ extern void phy_calibration_winbond(hw_d
 // Flag : AUTO_INCREMENT - RegisterNo will auto increment 4
 //		  NO_INCREMENT - Function will write data into the same register
 unsigned char
-Wb35Reg_BurstWrite(phw_data_t pHwData, u16 RegisterNo, u32 * pRegisterData, u8 NumberOfData, u8 Flag)
+Wb35Reg_BurstWrite(struct hw_data * pHwData, u16 RegisterNo, u32 * pRegisterData, u8 NumberOfData, u8 Flag)
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	struct urb	*urb = NULL;
@@ -73,7 +73,7 @@ Wb35Reg_BurstWrite(phw_data_t pHwData, u
 }
 
 void
-Wb35Reg_Update(phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue)
+Wb35Reg_Update(struct hw_data * pHwData,  u16 RegisterNo,  u32 RegisterValue)
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	switch (RegisterNo) {
@@ -118,7 +118,7 @@ Wb35Reg_Update(phw_data_t pHwData,  u16 
 // true  : read command process successfully
 // false : register not support
 unsigned char
-Wb35Reg_WriteSync(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue )
+Wb35Reg_WriteSync(  struct hw_data * pHwData,  u16 RegisterNo,  u32 RegisterValue )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	int ret = -1;
@@ -162,7 +162,7 @@ Wb35Reg_WriteSync(  phw_data_t pHwData, 
 // true  : read command process successfully
 // false : register not support
 unsigned char
-Wb35Reg_Write(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue )
+Wb35Reg_Write(  struct hw_data * pHwData,  u16 RegisterNo,  u32 RegisterValue )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	struct usb_ctrlrequest *dr;
@@ -222,7 +222,7 @@ Wb35Reg_Write(  phw_data_t pHwData,  u16
 // true  : read command process successfully
 // false : register not support
 unsigned char
-Wb35Reg_WriteWithCallbackValue( phw_data_t pHwData, u16 RegisterNo, u32 RegisterValue,
+Wb35Reg_WriteWithCallbackValue( struct hw_data * pHwData, u16 RegisterNo, u32 RegisterValue,
 				s8 *pValue, s8 Len)
 {
 	struct wb35_reg *reg = &pHwData->reg;
@@ -281,7 +281,7 @@ Wb35Reg_WriteWithCallbackValue( phw_data
 // false : register not support
 // pRegisterValue : It must be a resident buffer due to asynchronous read register.
 unsigned char
-Wb35Reg_ReadSync(  phw_data_t pHwData,  u16 RegisterNo,   u32 * pRegisterValue )
+Wb35Reg_ReadSync(  struct hw_data * pHwData,  u16 RegisterNo,   u32 * pRegisterValue )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	u32 *	pltmp = pRegisterValue;
@@ -330,7 +330,7 @@ Wb35Reg_ReadSync(  phw_data_t pHwData,  
 // false : register not support
 // pRegisterValue : It must be a resident buffer due to asynchronous read register.
 unsigned char
-Wb35Reg_Read(phw_data_t pHwData, u16 RegisterNo,  u32 * pRegisterValue )
+Wb35Reg_Read(struct hw_data * pHwData, u16 RegisterNo,  u32 * pRegisterValue )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	struct usb_ctrlrequest * dr;
@@ -385,7 +385,7 @@ Wb35Reg_Read(phw_data_t pHwData, u16 Reg
 
 
 void
-Wb35Reg_EP0VM_start(  phw_data_t pHwData )
+Wb35Reg_EP0VM_start(  struct hw_data * pHwData )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -397,7 +397,7 @@ Wb35Reg_EP0VM_start(  phw_data_t pHwData
 }
 
 void
-Wb35Reg_EP0VM(phw_data_t pHwData )
+Wb35Reg_EP0VM(struct hw_data * pHwData )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	struct urb	*urb;
@@ -457,7 +457,7 @@ Wb35Reg_EP0VM(phw_data_t pHwData )
 void
 Wb35Reg_EP0VM_complete(struct urb *urb)
 {
-	phw_data_t  pHwData = (phw_data_t)urb->context;
+	struct hw_data *  pHwData = (struct hw_data *)urb->context;
 	struct wb35_reg *reg = &pHwData->reg;
 	struct wb35_reg_queue *reg_queue;
 
@@ -499,7 +499,7 @@ Wb35Reg_EP0VM_complete(struct urb *urb)
 
 
 void
-Wb35Reg_destroy(phw_data_t pHwData)
+Wb35Reg_destroy(struct hw_data * pHwData)
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	struct urb	*urb;
@@ -542,7 +542,7 @@ Wb35Reg_destroy(phw_data_t pHwData)
 //====================================================================================
 // The function can be run in passive-level only.
 //====================================================================================
-unsigned char Wb35Reg_initial(phw_data_t pHwData)
+unsigned char Wb35Reg_initial(struct hw_data * pHwData)
 {
 	struct wb35_reg *reg=&pHwData->reg;
 	u32 ltmp;
@@ -722,7 +722,7 @@ u32 BitReverse( u32 dwData, u32 DataLeng
 	return dwData;
 }
 
-void Wb35Reg_phy_calibration(  phw_data_t pHwData )
+void Wb35Reg_phy_calibration(  struct hw_data * pHwData )
 {
 	u32 BB3c, BB54;
 
--- a/drivers/staging/winbond/wb35reg_f.h
+++ b/drivers/staging/winbond/wb35reg_f.h
@@ -6,47 +6,47 @@
 //====================================
 // Interface function declare
 //====================================
-unsigned char Wb35Reg_initial(  phw_data_t pHwData );
-void Uxx_power_on_procedure(  phw_data_t pHwData );
-void Uxx_power_off_procedure(  phw_data_t pHwData );
-void Uxx_ReadEthernetAddress(  phw_data_t pHwData );
-void Dxx_initial(  phw_data_t pHwData );
-void Mxx_initial(  phw_data_t pHwData );
-void RFSynthesizer_initial(  phw_data_t pHwData );
-//void RFSynthesizer_SwitchingChannel(  phw_data_t pHwData,  s8 Channel );
-void RFSynthesizer_SwitchingChannel(  phw_data_t pHwData,  ChanInfo Channel );
-void BBProcessor_initial(  phw_data_t pHwData );
-void BBProcessor_RateChanging(  phw_data_t pHwData,  u8 rate ); // 20060613.1
-//void RF_RateChanging(  phw_data_t pHwData,  u8 rate ); // 20060626.5.c Add
-u8 RFSynthesizer_SetPowerIndex(  phw_data_t pHwData,  u8 PowerIndex );
-u8 RFSynthesizer_SetMaxim2828_24Power(  phw_data_t,  u8 index );
-u8 RFSynthesizer_SetMaxim2828_50Power(  phw_data_t,  u8 index );
-u8 RFSynthesizer_SetMaxim2827_24Power(  phw_data_t,  u8 index );
-u8 RFSynthesizer_SetMaxim2827_50Power(  phw_data_t,  u8 index );
-u8 RFSynthesizer_SetMaxim2825Power(  phw_data_t,  u8 index );
-u8 RFSynthesizer_SetAiroha2230Power(  phw_data_t,  u8 index );
-u8 RFSynthesizer_SetAiroha7230Power(  phw_data_t,  u8 index );
-u8 RFSynthesizer_SetWinbond242Power(  phw_data_t,  u8 index );
-void GetTxVgaFromEEPROM(  phw_data_t pHwData );
-void EEPROMTxVgaAdjust(  phw_data_t pHwData ); // 20060619.5 Add
+unsigned char Wb35Reg_initial(  struct hw_data * pHwData );
+void Uxx_power_on_procedure(  struct hw_data * pHwData );
+void Uxx_power_off_procedure(  struct hw_data * pHwData );
+void Uxx_ReadEthernetAddress(  struct hw_data * pHwData );
+void Dxx_initial(  struct hw_data * pHwData );
+void Mxx_initial(  struct hw_data * pHwData );
+void RFSynthesizer_initial(  struct hw_data * pHwData );
+//void RFSynthesizer_SwitchingChannel(  struct hw_data * pHwData,  s8 Channel );
+void RFSynthesizer_SwitchingChannel(  struct hw_data * pHwData,  ChanInfo Channel );
+void BBProcessor_initial(  struct hw_data * pHwData );
+void BBProcessor_RateChanging(  struct hw_data * pHwData,  u8 rate ); // 20060613.1
+//void RF_RateChanging(  struct hw_data * pHwData,  u8 rate ); // 20060626.5.c Add
+u8 RFSynthesizer_SetPowerIndex(  struct hw_data * pHwData,  u8 PowerIndex );
+u8 RFSynthesizer_SetMaxim2828_24Power(  struct hw_data *,  u8 index );
+u8 RFSynthesizer_SetMaxim2828_50Power(  struct hw_data *,  u8 index );
+u8 RFSynthesizer_SetMaxim2827_24Power(  struct hw_data *,  u8 index );
+u8 RFSynthesizer_SetMaxim2827_50Power(  struct hw_data *,  u8 index );
+u8 RFSynthesizer_SetMaxim2825Power(  struct hw_data *,  u8 index );
+u8 RFSynthesizer_SetAiroha2230Power(  struct hw_data *,  u8 index );
+u8 RFSynthesizer_SetAiroha7230Power(  struct hw_data *,  u8 index );
+u8 RFSynthesizer_SetWinbond242Power(  struct hw_data *,  u8 index );
+void GetTxVgaFromEEPROM(  struct hw_data * pHwData );
+void EEPROMTxVgaAdjust(  struct hw_data * pHwData ); // 20060619.5 Add
 
 #define RFWriteControlData( _A, _V ) Wb35Reg_Write( _A, 0x0864, _V )
 
-void Wb35Reg_destroy(  phw_data_t pHwData );
+void Wb35Reg_destroy(  struct hw_data * pHwData );
 
-unsigned char Wb35Reg_Read(  phw_data_t pHwData,  u16 RegisterNo,   u32 * pRegisterValue );
-unsigned char Wb35Reg_ReadSync(  phw_data_t pHwData,  u16 RegisterNo,   u32 * pRegisterValue );
-unsigned char Wb35Reg_Write(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue );
-unsigned char Wb35Reg_WriteSync(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue );
-unsigned char Wb35Reg_WriteWithCallbackValue(  phw_data_t pHwData,
+unsigned char Wb35Reg_Read(  struct hw_data * pHwData,  u16 RegisterNo,   u32 * pRegisterValue );
+unsigned char Wb35Reg_ReadSync(  struct hw_data * pHwData,  u16 RegisterNo,   u32 * pRegisterValue );
+unsigned char Wb35Reg_Write(  struct hw_data * pHwData,  u16 RegisterNo,  u32 RegisterValue );
+unsigned char Wb35Reg_WriteSync(  struct hw_data * pHwData,  u16 RegisterNo,  u32 RegisterValue );
+unsigned char Wb35Reg_WriteWithCallbackValue(  struct hw_data * pHwData,
 								 u16 RegisterNo,
 								 u32 RegisterValue,
 								 s8 *pValue,
 								 s8 Len);
-unsigned char Wb35Reg_BurstWrite(  phw_data_t pHwData,  u16 RegisterNo,  u32 * pRegisterData,  u8 NumberOfData,  u8 Flag );
+unsigned char Wb35Reg_BurstWrite(  struct hw_data * pHwData,  u16 RegisterNo,  u32 * pRegisterData,  u8 NumberOfData,  u8 Flag );
 
-void Wb35Reg_EP0VM(  phw_data_t pHwData );
-void Wb35Reg_EP0VM_start(  phw_data_t pHwData );
+void Wb35Reg_EP0VM(  struct hw_data * pHwData );
+void Wb35Reg_EP0VM_start(  struct hw_data * pHwData );
 void Wb35Reg_EP0VM_complete(struct urb *urb);
 
 u32 BitReverse( u32 dwData, u32 DataLength);
@@ -54,8 +54,8 @@ u32 BitReverse( u32 dwData, u32 DataLeng
 void CardGetMulticastBit(   u8 Address[MAC_ADDR_LENGTH],  u8 *Byte,  u8 *Value );
 u32 CardComputeCrc(  u8 * Buffer,  u32 Length );
 
-void Wb35Reg_phy_calibration(  phw_data_t pHwData );
-void Wb35Reg_Update(  phw_data_t pHwData,  u16 RegisterNo,  u32 RegisterValue );
-unsigned char adjust_TXVGA_for_iq_mag(  phw_data_t pHwData );
+void Wb35Reg_phy_calibration(  struct hw_data * pHwData );
+void Wb35Reg_Update(  struct hw_data * pHwData,  u16 RegisterNo,  u32 RegisterValue );
+unsigned char adjust_TXVGA_for_iq_mag(  struct hw_data * pHwData );
 
 #endif
--- a/drivers/staging/winbond/wb35rx.c
+++ b/drivers/staging/winbond/wb35rx.c
@@ -82,7 +82,7 @@ static void Wb35Rx_adjust(PDESCRIPTOR pR
 static u16 Wb35Rx_indicate(struct ieee80211_hw *hw)
 {
 	struct wbsoft_priv *priv = hw->priv;
-	phw_data_t pHwData = &priv->sHwData;
+	struct hw_data * pHwData = &priv->sHwData;
 	DESCRIPTOR	RxDes;
 	struct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;
 	u8 *		pRxBufferAddress;
@@ -161,7 +161,7 @@ static void Wb35Rx_Complete(struct urb *
 {
 	struct ieee80211_hw *hw = urb->context;
 	struct wbsoft_priv *priv = hw->priv;
-	phw_data_t pHwData = &priv->sHwData;
+	struct hw_data * pHwData = &priv->sHwData;
 	struct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;
 	u8 *		pRxBufferAddress;
 	u32		SizeCheck;
@@ -238,7 +238,7 @@ error:
 static void Wb35Rx(struct ieee80211_hw *hw)
 {
 	struct wbsoft_priv *priv = hw->priv;
-	phw_data_t pHwData = &priv->sHwData;
+	struct hw_data * pHwData = &priv->sHwData;
 	struct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;
 	u8 *	pRxBufferAddress;
 	struct urb *urb = pWb35Rx->RxUrb;
@@ -301,7 +301,7 @@ error:
 void Wb35Rx_start(struct ieee80211_hw *hw)
 {
 	struct wbsoft_priv *priv = hw->priv;
-	phw_data_t pHwData = &priv->sHwData;
+	struct hw_data * pHwData = &priv->sHwData;
 	struct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;
 
 	// Allow only one thread to run into the Wb35Rx() function
@@ -313,7 +313,7 @@ void Wb35Rx_start(struct ieee80211_hw *h
 }
 
 //=====================================================================================
-static void Wb35Rx_reset_descriptor(  phw_data_t pHwData )
+static void Wb35Rx_reset_descriptor(  struct hw_data * pHwData )
 {
 	struct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;
 	u32	i;
@@ -329,7 +329,7 @@ static void Wb35Rx_reset_descriptor(  ph
 		pWb35Rx->RxOwner[i] = 1;
 }
 
-unsigned char Wb35Rx_initial(phw_data_t pHwData)
+unsigned char Wb35Rx_initial(struct hw_data * pHwData)
 {
 	struct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;
 
@@ -340,7 +340,7 @@ unsigned char Wb35Rx_initial(phw_data_t 
 	return (!!pWb35Rx->RxUrb);
 }
 
-void Wb35Rx_stop(phw_data_t pHwData)
+void Wb35Rx_stop(struct hw_data * pHwData)
 {
 	struct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;
 
@@ -354,7 +354,7 @@ void Wb35Rx_stop(phw_data_t pHwData)
 }
 
 // Needs process context
-void Wb35Rx_destroy(phw_data_t pHwData)
+void Wb35Rx_destroy(struct hw_data * pHwData)
 {
 	struct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;
 
--- a/drivers/staging/winbond/wb35rx_f.h
+++ b/drivers/staging/winbond/wb35rx_f.h
@@ -7,9 +7,9 @@
 //====================================
 // Interface function declare
 //====================================
-unsigned char		Wb35Rx_initial(  phw_data_t pHwData );
-void		Wb35Rx_destroy(  phw_data_t pHwData );
-void		Wb35Rx_stop(  phw_data_t pHwData );
+unsigned char		Wb35Rx_initial(  struct hw_data * pHwData );
+void		Wb35Rx_destroy(  struct hw_data * pHwData );
+void		Wb35Rx_stop(  struct hw_data * pHwData );
 void		Wb35Rx_start(struct ieee80211_hw *hw);
 
 #endif
--- a/drivers/staging/winbond/wb35tx.c
+++ b/drivers/staging/winbond/wb35tx.c
@@ -15,7 +15,7 @@
 #include "sysdef.h"
 
 unsigned char
-Wb35Tx_get_tx_buffer(phw_data_t pHwData, u8 **pBuffer)
+Wb35Tx_get_tx_buffer(struct hw_data * pHwData, u8 **pBuffer)
 {
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 
@@ -28,7 +28,7 @@ static void Wb35Tx(struct wbsoft_priv *a
 static void Wb35Tx_complete(struct urb * pUrb)
 {
 	struct wbsoft_priv *adapter = pUrb->context;
-	phw_data_t	pHwData = &adapter->sHwData;
+	struct hw_data *	pHwData = &adapter->sHwData;
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 	PMDS		pMds = &adapter->Mds;
 
@@ -64,7 +64,7 @@ error:
 
 static void Wb35Tx(struct wbsoft_priv *adapter)
 {
-	phw_data_t	pHwData = &adapter->sHwData;
+	struct hw_data *	pHwData = &adapter->sHwData;
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 	u8		*pTxBufferAddress;
 	PMDS		pMds = &adapter->Mds;
@@ -115,7 +115,7 @@ static void Wb35Tx(struct wbsoft_priv *a
 
 void Wb35Tx_start(struct wbsoft_priv *adapter)
 {
-	phw_data_t pHwData = &adapter->sHwData;
+	struct hw_data * pHwData = &adapter->sHwData;
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 
 	// Allow only one thread to run into function
@@ -126,7 +126,7 @@ void Wb35Tx_start(struct wbsoft_priv *ad
 		atomic_dec(&pWb35Tx->TxFireCounter);
 }
 
-unsigned char Wb35Tx_initial(phw_data_t pHwData)
+unsigned char Wb35Tx_initial(struct hw_data * pHwData)
 {
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 
@@ -145,7 +145,7 @@ unsigned char Wb35Tx_initial(phw_data_t 
 }
 
 //======================================================
-void Wb35Tx_stop(phw_data_t pHwData)
+void Wb35Tx_stop(struct hw_data * pHwData)
 {
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 
@@ -165,7 +165,7 @@ void Wb35Tx_stop(phw_data_t pHwData)
 }
 
 //======================================================
-void Wb35Tx_destroy(phw_data_t pHwData)
+void Wb35Tx_destroy(struct hw_data * pHwData)
 {
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 
@@ -188,7 +188,7 @@ void Wb35Tx_destroy(phw_data_t pHwData)
 
 void Wb35Tx_CurrentTime(struct wbsoft_priv *adapter, u32 TimeCount)
 {
-	phw_data_t pHwData = &adapter->sHwData;
+	struct hw_data * pHwData = &adapter->sHwData;
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 	unsigned char Trigger = false;
 
@@ -208,7 +208,7 @@ static void Wb35Tx_EP2VM(struct wbsoft_p
 static void Wb35Tx_EP2VM_complete(struct urb * pUrb)
 {
 	struct wbsoft_priv *adapter = pUrb->context;
-	phw_data_t	pHwData = &adapter->sHwData;
+	struct hw_data *	pHwData = &adapter->sHwData;
 	T02_DESCRIPTOR	T02, TSTATUS;
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 	u32 *		pltmp = (u32 *)pWb35Tx->EP2_buf;
@@ -256,7 +256,7 @@ error:
 
 static void Wb35Tx_EP2VM(struct wbsoft_priv *adapter)
 {
-	phw_data_t	pHwData = &adapter->sHwData;
+	struct hw_data *	pHwData = &adapter->sHwData;
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 	struct urb *	pUrb = (struct urb *)pWb35Tx->Tx2Urb;
 	u32 *	pltmp = (u32 *)pWb35Tx->EP2_buf;
@@ -292,7 +292,7 @@ error:
 
 void Wb35Tx_EP2VM_start(struct wbsoft_priv *adapter)
 {
-	phw_data_t pHwData = &adapter->sHwData;
+	struct hw_data * pHwData = &adapter->sHwData;
 	struct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;
 
 	// Allow only one thread to run into function
--- a/drivers/staging/winbond/wb35tx_f.h
+++ b/drivers/staging/winbond/wb35tx_f.h
@@ -7,14 +7,14 @@
 //====================================
 // Interface function declare
 //====================================
-unsigned char Wb35Tx_initial(	 phw_data_t pHwData );
-void Wb35Tx_destroy(  phw_data_t pHwData );
-unsigned char Wb35Tx_get_tx_buffer(  phw_data_t pHwData,  u8 **pBuffer );
+unsigned char Wb35Tx_initial(	 struct hw_data * pHwData );
+void Wb35Tx_destroy(  struct hw_data * pHwData );
+unsigned char Wb35Tx_get_tx_buffer(  struct hw_data * pHwData,  u8 **pBuffer );
 
 void Wb35Tx_EP2VM_start(struct wbsoft_priv *adapter);
 
 void Wb35Tx_start(struct wbsoft_priv *adapter);
-void Wb35Tx_stop(  phw_data_t pHwData );
+void Wb35Tx_stop(  struct hw_data * pHwData );
 
 void Wb35Tx_CurrentTime(struct wbsoft_priv *adapter,  u32 TimeCount);
 
--- a/drivers/staging/winbond/wbhal.c
+++ b/drivers/staging/winbond/wbhal.c
@@ -2,7 +2,7 @@
 #include "wbhal_f.h"
 #include "wblinux_f.h"
 
-void hal_set_ethernet_address( phw_data_t pHwData, u8 *current_address )
+void hal_set_ethernet_address( struct hw_data * pHwData, u8 *current_address )
 {
 	u32 ltmp[2];
 
@@ -16,7 +16,7 @@ void hal_set_ethernet_address( phw_data_
 	Wb35Reg_BurstWrite( pHwData, 0x03e8, ltmp, 2, AUTO_INCREMENT );
 }
 
-void hal_get_permanent_address( phw_data_t pHwData, u8 *pethernet_address )
+void hal_get_permanent_address( struct hw_data * pHwData, u8 *pethernet_address )
 {
 	if( pHwData->SurpriseRemove ) return;
 
@@ -26,7 +26,7 @@ void hal_get_permanent_address( phw_data
 static void hal_led_control(unsigned long data)
 {
 	struct wbsoft_priv *adapter = (struct wbsoft_priv *) data;
-	phw_data_t pHwData = &adapter->sHwData;
+	struct hw_data * pHwData = &adapter->sHwData;
 	struct wb35_reg *reg = &pHwData->reg;
 	u32	LEDSet = (pHwData->SoftwareSet & HAL_LED_SET_MASK) >> HAL_LED_SET_SHIFT;
 	u8	LEDgray[20] = { 0,3,4,6,8,10,11,12,13,14,15,14,13,12,11,10,8,6,4,2 };
@@ -311,7 +311,7 @@ static void hal_led_control(unsigned lon
 u8 hal_init_hardware(struct ieee80211_hw *hw)
 {
 	struct wbsoft_priv *priv = hw->priv;
-	phw_data_t pHwData = &priv->sHwData;
+	struct hw_data * pHwData = &priv->sHwData;
 	u16 SoftwareSet;
 
 	// Initial the variable
@@ -356,7 +356,7 @@ u8 hal_init_hardware(struct ieee80211_hw
 }
 
 
-void hal_halt(phw_data_t pHwData, void *ppa_data)
+void hal_halt(struct hw_data * pHwData, void *ppa_data)
 {
 	switch( pHwData->InitialResource )
 	{
@@ -370,7 +370,7 @@ void hal_halt(phw_data_t pHwData, void *
 }
 
 //---------------------------------------------------------------------------------------------------
-void hal_set_beacon_period(  phw_data_t pHwData,  u16 beacon_period )
+void hal_set_beacon_period(  struct hw_data * pHwData,  u16 beacon_period )
 {
 	u32	tmp;
 
@@ -383,7 +383,7 @@ void hal_set_beacon_period(  phw_data_t 
 }
 
 
-static void hal_set_current_channel_ex(  phw_data_t pHwData,  ChanInfo channel )
+static void hal_set_current_channel_ex(  struct hw_data * pHwData,  ChanInfo channel )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -404,12 +404,12 @@ static void hal_set_current_channel_ex( 
 					(s8 *)&channel, sizeof(ChanInfo));
 }
 //---------------------------------------------------------------------------------------------------
-void hal_set_current_channel(  phw_data_t pHwData,  ChanInfo channel )
+void hal_set_current_channel(  struct hw_data * pHwData,  ChanInfo channel )
 {
 	hal_set_current_channel_ex( pHwData, channel );
 }
 //---------------------------------------------------------------------------------------------------
-void hal_set_accept_broadcast(  phw_data_t pHwData,  u8 enable )
+void hal_set_accept_broadcast(  struct hw_data * pHwData,  u8 enable )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -424,7 +424,7 @@ void hal_set_accept_broadcast(  phw_data
 }
 
 //for wep key error detection, we need to accept broadcast packets to be received temporary.
-void hal_set_accept_promiscuous( phw_data_t pHwData,  u8 enable)
+void hal_set_accept_promiscuous( struct hw_data * pHwData,  u8 enable)
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -438,7 +438,7 @@ void hal_set_accept_promiscuous( phw_dat
 	}
 }
 
-void hal_set_accept_multicast(  phw_data_t pHwData,  u8 enable )
+void hal_set_accept_multicast(  struct hw_data * pHwData,  u8 enable )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -449,7 +449,7 @@ void hal_set_accept_multicast(  phw_data
 	Wb35Reg_Write( pHwData, 0x0800, reg->M00_MacControl );
 }
 
-void hal_set_accept_beacon(  phw_data_t pHwData,  u8 enable )
+void hal_set_accept_beacon(  struct hw_data * pHwData,  u8 enable )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -467,7 +467,7 @@ void hal_set_accept_beacon(  phw_data_t 
 }
 //---------------------------------------------------------------------------------------------------
 
-void hal_stop(  phw_data_t pHwData )
+void hal_stop(  struct hw_data * pHwData )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -481,7 +481,7 @@ void hal_stop(  phw_data_t pHwData )
 	Wb35Reg_Write( pHwData, 0x0400, reg->D00_DmaControl );
 }
 
-unsigned char hal_idle(phw_data_t pHwData)
+unsigned char hal_idle(struct hw_data * pHwData)
 {
 	struct wb35_reg *reg = &pHwData->reg;
 	struct wb_usb *pWbUsb = &pHwData->WbUsb;
@@ -492,12 +492,12 @@ unsigned char hal_idle(phw_data_t pHwDat
 	return true;
 }
 //---------------------------------------------------------------------------------------------------
-void hal_set_phy_type(  phw_data_t pHwData,  u8 PhyType )
+void hal_set_phy_type(  struct hw_data * pHwData,  u8 PhyType )
 {
 	pHwData->phy_type = PhyType;
 }
 
-void hal_set_radio_mode( phw_data_t pHwData,  unsigned char radio_off)
+void hal_set_radio_mode( struct hw_data * pHwData,  unsigned char radio_off)
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -516,7 +516,7 @@ void hal_set_radio_mode( phw_data_t pHwD
 	Wb35Reg_Write( pHwData, 0x0824, reg->M24_MacControl );
 }
 
-u8 hal_get_antenna_number(  phw_data_t pHwData )
+u8 hal_get_antenna_number(  struct hw_data * pHwData )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -528,7 +528,7 @@ u8 hal_get_antenna_number(  phw_data_t p
 
 //----------------------------------------------------------------------------------------------------
 //0 : radio on; 1: radio off
-u8 hal_get_hw_radio_off(  phw_data_t pHwData )
+u8 hal_get_hw_radio_off(  struct hw_data * pHwData )
 {
 	struct wb35_reg *reg = &pHwData->reg;
 
@@ -545,14 +545,14 @@ u8 hal_get_hw_radio_off(  phw_data_t pHw
 	}
 }
 
-unsigned char hal_get_dxx_reg(  phw_data_t pHwData,  u16 number,  u32 * pValue )
+unsigned char hal_get_dxx_reg(  struct hw_data * pHwData,  u16 number,  u32 * pValue )
 {
 	if( number < 0x1000 )
 		number += 0x1000;
 	return Wb35Reg_ReadSync( pHwData, number, pValue );
 }
 
-unsigned char hal_set_dxx_reg(  phw_data_t pHwData,  u16 number,  u32 value )
+unsigned char hal_set_dxx_reg(  struct hw_data * pHwData,  u16 number,  u32 value )
 {
 	unsigned char	ret;
 
@@ -562,7 +562,7 @@ unsigned char hal_set_dxx_reg(  phw_data
 	return ret;
 }
 
-void hal_set_rf_power(phw_data_t pHwData, u8 PowerIndex)
+void hal_set_rf_power(struct hw_data * pHwData, u8 PowerIndex)
 {
 	RFSynthesizer_SetPowerIndex( pHwData, PowerIndex );
 }
--- a/drivers/staging/winbond/wbhal_f.h
+++ b/drivers/staging/winbond/wbhal_f.h
@@ -10,56 +10,56 @@
 //====================================================================================
 // Function declaration
 //====================================================================================
-void hal_remove_mapping_key(  phw_data_t pHwData,  u8 *pmac_addr );
-void hal_remove_default_key(  phw_data_t pHwData,  u32 index );
-unsigned char hal_set_mapping_key(  phw_data_t adapter,  u8 *pmac_addr,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
-unsigned char hal_set_default_key(  phw_data_t adapter,  u8 index,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
-void hal_clear_all_default_key(  phw_data_t pHwData );
-void hal_clear_all_group_key(  phw_data_t pHwData );
-void hal_clear_all_mapping_key(  phw_data_t pHwData );
-void hal_clear_all_key(  phw_data_t pHwData );
-void hal_get_ethernet_address(  phw_data_t pHwData,  u8 *current_address );
-void hal_set_ethernet_address(  phw_data_t pHwData,  u8 *current_address );
-void hal_get_permanent_address(  phw_data_t pHwData,  u8 *pethernet_address );
+void hal_remove_mapping_key(  struct hw_data * pHwData,  u8 *pmac_addr );
+void hal_remove_default_key(  struct hw_data * pHwData,  u32 index );
+unsigned char hal_set_mapping_key(  struct hw_data * adapter,  u8 *pmac_addr,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
+unsigned char hal_set_default_key(  struct hw_data * adapter,  u8 index,  u8 null_key,  u8 wep_on,  u8 *ptx_tsc,  u8 *prx_tsc,  u8 key_type,  u8 key_len,  u8 *pkey_data );
+void hal_clear_all_default_key(  struct hw_data * pHwData );
+void hal_clear_all_group_key(  struct hw_data * pHwData );
+void hal_clear_all_mapping_key(  struct hw_data * pHwData );
+void hal_clear_all_key(  struct hw_data * pHwData );
+void hal_get_ethernet_address(  struct hw_data * pHwData,  u8 *current_address );
+void hal_set_ethernet_address(  struct hw_data * pHwData,  u8 *current_address );
+void hal_get_permanent_address(  struct hw_data * pHwData,  u8 *pethernet_address );
 u8 hal_init_hardware(struct ieee80211_hw *hw);
-void hal_set_power_save_mode(  phw_data_t pHwData,  unsigned char power_save,  unsigned char wakeup,  unsigned char dtim );
-void hal_get_power_save_mode(  phw_data_t pHwData,   u8 *pin_pwr_save );
-void hal_set_slot_time(  phw_data_t pHwData,  u8 type );
+void hal_set_power_save_mode(  struct hw_data * pHwData,  unsigned char power_save,  unsigned char wakeup,  unsigned char dtim );
+void hal_get_power_save_mode(  struct hw_data * pHwData,   u8 *pin_pwr_save );
+void hal_set_slot_time(  struct hw_data * pHwData,  u8 type );
 #define hal_set_atim_window( _A, _ATM )
-void hal_start_bss(  phw_data_t pHwData,  u8 mac_op_mode );
-void hal_join_request(  phw_data_t pHwData,  u8 bss_type ); // 0:BSS STA 1:IBSS STA//
-void hal_stop_sync_bss(  phw_data_t pHwData );
-void hal_resume_sync_bss(  phw_data_t pHwData);
-void hal_set_aid(  phw_data_t pHwData,  u16 aid );
-void hal_set_bssid(  phw_data_t pHwData,  u8 *pbssid );
-void hal_get_bssid(  phw_data_t pHwData,  u8 *pbssid );
-void hal_set_beacon_period(  phw_data_t pHwData,  u16 beacon_period );
-void hal_set_listen_interval(  phw_data_t pHwData,  u16 listen_interval );
-void hal_set_cap_info(  phw_data_t pHwData,  u16 capability_info );
-void hal_set_ssid(  phw_data_t pHwData,  u8 *pssid,  u8 ssid_len );
-void hal_set_current_channel(  phw_data_t pHwData,  ChanInfo channel );
-void hal_set_accept_broadcast(  phw_data_t pHwData,  u8 enable );
-void hal_set_accept_multicast(  phw_data_t pHwData,  u8 enable );
-void hal_set_accept_beacon(  phw_data_t pHwData,  u8 enable );
-void hal_stop(  phw_data_t pHwData );
-void hal_halt(  phw_data_t pHwData, void *ppa_data );
-void hal_start_tx0(  phw_data_t pHwData );
-void hal_set_phy_type(  phw_data_t pHwData,  u8 PhyType );
+void hal_start_bss(  struct hw_data * pHwData,  u8 mac_op_mode );
+void hal_join_request(  struct hw_data * pHwData,  u8 bss_type ); // 0:BSS STA 1:IBSS STA//
+void hal_stop_sync_bss(  struct hw_data * pHwData );
+void hal_resume_sync_bss(  struct hw_data * pHwData);
+void hal_set_aid(  struct hw_data * pHwData,  u16 aid );
+void hal_set_bssid(  struct hw_data * pHwData,  u8 *pbssid );
+void hal_get_bssid(  struct hw_data * pHwData,  u8 *pbssid );
+void hal_set_beacon_period(  struct hw_data * pHwData,  u16 beacon_period );
+void hal_set_listen_interval(  struct hw_data * pHwData,  u16 listen_interval );
+void hal_set_cap_info(  struct hw_data * pHwData,  u16 capability_info );
+void hal_set_ssid(  struct hw_data * pHwData,  u8 *pssid,  u8 ssid_len );
+void hal_set_current_channel(  struct hw_data * pHwData,  ChanInfo channel );
+void hal_set_accept_broadcast(  struct hw_data * pHwData,  u8 enable );
+void hal_set_accept_multicast(  struct hw_data * pHwData,  u8 enable );
+void hal_set_accept_beacon(  struct hw_data * pHwData,  u8 enable );
+void hal_stop(  struct hw_data * pHwData );
+void hal_halt(  struct hw_data * pHwData, void *ppa_data );
+void hal_start_tx0(  struct hw_data * pHwData );
+void hal_set_phy_type(  struct hw_data * pHwData,  u8 PhyType );
 #define hal_get_cwmin( _A ) ( (_A)->cwmin )
-void hal_set_cwmax(  phw_data_t pHwData,  u16 cwin_max );
+void hal_set_cwmax(  struct hw_data * pHwData,  u16 cwin_max );
 #define hal_get_cwmax( _A ) ( (_A)->cwmax )
-void hal_set_rsn_wpa(  phw_data_t pHwData,  u32 * RSN_IE_Bitmap , u32 * RSN_OUI_type , unsigned char bDesiredAuthMode);
-void hal_set_connect_info(  phw_data_t pHwData,  unsigned char boConnect );
-u8 hal_get_est_sq3(  phw_data_t pHwData,  u8 Count );
-void hal_set_rf_power(  phw_data_t pHwData,  u8 PowerIndex ); // 20060621 Modify
-void hal_set_radio_mode(  phw_data_t pHwData,  unsigned char boValue);
-void hal_descriptor_indicate(  phw_data_t pHwData,  PDESCRIPTOR pDes );
-u8 hal_get_antenna_number(  phw_data_t pHwData );
-u32 hal_get_bss_pk_cnt(  phw_data_t pHwData );
+void hal_set_rsn_wpa(  struct hw_data * pHwData,  u32 * RSN_IE_Bitmap , u32 * RSN_OUI_type , unsigned char bDesiredAuthMode);
+void hal_set_connect_info(  struct hw_data * pHwData,  unsigned char boConnect );
+u8 hal_get_est_sq3(  struct hw_data * pHwData,  u8 Count );
+void hal_set_rf_power(  struct hw_data * pHwData,  u8 PowerIndex ); // 20060621 Modify
+void hal_set_radio_mode(  struct hw_data * pHwData,  unsigned char boValue);
+void hal_descriptor_indicate(  struct hw_data * pHwData,  PDESCRIPTOR pDes );
+u8 hal_get_antenna_number(  struct hw_data * pHwData );
+u32 hal_get_bss_pk_cnt(  struct hw_data * pHwData );
 #define hal_get_region_from_EEPROM( _A ) ( (_A)->reg.EEPROMRegion )
-void hal_set_accept_promiscuous		(  phw_data_t pHwData,  u8 enable);
+void hal_set_accept_promiscuous		(  struct hw_data * pHwData,  u8 enable);
 #define hal_get_tx_buffer( _A, _B ) Wb35Tx_get_tx_buffer( _A, _B )
-u8 hal_get_hw_radio_off			(  phw_data_t pHwData );
+u8 hal_get_hw_radio_off			(  struct hw_data * pHwData );
 #define hal_software_set( _A )		(_A->SoftwareSet)
 #define hal_driver_init_OK( _A )	(_A->IsInitOK)
 #define hal_rssi_boundary_high( _A ) (_A->RSSI_high)
@@ -68,8 +68,8 @@ u8 hal_get_hw_radio_off			(  phw_data_t 
 
 #define PHY_DEBUG( msg, args... )
 
-unsigned char hal_get_dxx_reg(  phw_data_t pHwData,  u16 number,  u32 * pValue );
-unsigned char hal_set_dxx_reg(  phw_data_t pHwData,  u16 number,  u32 value );
+unsigned char hal_get_dxx_reg(  struct hw_data * pHwData,  u16 number,  u32 * pValue );
+unsigned char hal_set_dxx_reg(  struct hw_data * pHwData,  u16 number,  u32 value );
 #define hal_get_time_count( _P )	(_P->time_count/10)	// return 100ms count
 #define hal_detect_error( _P )		(_P->WbUsb.DetectCount)
 
@@ -82,7 +82,7 @@ unsigned char hal_set_dxx_reg(  phw_data
 #define hal_get_clear_interrupt(_A)
 #define hal_ibss_disconnect(_A) hal_stop_sync_bss(_A)
 #define hal_join_request_stop(_A)
-unsigned char	hal_idle(  phw_data_t pHwData );
+unsigned char	hal_idle(  struct hw_data * pHwData );
 #define hw_get_cxx_reg( _A, _B, _C )
 #define hw_set_cxx_reg( _A, _B, _C )
 #define hw_get_dxx_reg( _A, _B, _C )	hal_get_dxx_reg( _A, _B, (u32 *)_C )
--- a/drivers/staging/winbond/wbhal_s.h
+++ b/drivers/staging/winbond/wbhal_s.h
@@ -392,8 +392,7 @@ typedef struct _TXVGA_FOR_50 {
 #include "wb35rx_s.h"
 
 // For Hal using ==================================================================
-typedef struct _HW_DATA_T
-{
+struct hw_data {
 	// For compatible with 33
 	u32	revision;
 	u32	BB3c_cal; // The value for Tx calibration comes from EEPROM
@@ -541,6 +540,6 @@ typedef struct _HW_DATA_T
 	// 20060828.1 for avoid AP disconnect
 	u32		NullPacketCount;
 
-} hw_data_t, *phw_data_t;
+};
 
 #endif
--- a/drivers/staging/winbond/wbusb.c
+++ b/drivers/staging/winbond/wbusb.c
@@ -149,19 +149,19 @@ static int wbsoft_config(struct ieee8021
 	hal_set_current_channel(&priv->sHwData, ch);
 	hal_set_beacon_period(&priv->sHwData, conf->beacon_int);
 //	hal_set_cap_info(&priv->sHwData, ?? );
-// hal_set_ssid(phw_data_t pHwData,  u8 * pssid,  u8 ssid_len); ??
+// hal_set_ssid(struct hw_data * pHwData,  u8 * pssid,  u8 ssid_len); ??
 	hal_set_accept_broadcast(&priv->sHwData, 1);
 	hal_set_accept_promiscuous(&priv->sHwData,  1);
 	hal_set_accept_multicast(&priv->sHwData,  1);
 	hal_set_accept_beacon(&priv->sHwData,  1);
 	hal_set_radio_mode(&priv->sHwData,  0);
-	//hal_set_antenna_number(  phw_data_t pHwData, u8 number )
-	//hal_set_rf_power(phw_data_t pHwData, u8 PowerIndex)
+	//hal_set_antenna_number(  struct hw_data * pHwData, u8 number )
+	//hal_set_rf_power(struct hw_data * pHwData, u8 PowerIndex)
 
 
 //	hal_start_bss(&priv->sHwData, WLAN_BSSTYPE_INFRASTRUCTURE);	??
 
-//void hal_set_rates(phw_data_t pHwData, u8 * pbss_rates,
+//void hal_set_rates(struct hw_data * pHwData, u8 * pbss_rates,
 //		   u8 length, unsigned char basic_rate_set)
 
 	return 0;
@@ -199,7 +199,7 @@ static const struct ieee80211_ops wbsoft
 static unsigned char wb35_hw_init(struct ieee80211_hw *hw)
 {
 	struct wbsoft_priv *priv = hw->priv;
-	phw_data_t	pHwData;
+	struct hw_data *	pHwData;
 	u8		*pMacAddr;
 	u8		*pMacAddr2;
 	u32		InitStep = 0;
@@ -366,7 +366,7 @@ static int wb35_probe(struct usb_interfa
 
 	SET_IEEE80211_DEV(dev, &udev->dev);
 	{
-		phw_data_t pHwData = &priv->sHwData;
+		struct hw_data * pHwData = &priv->sHwData;
 		unsigned char		dev_addr[MAX_ADDR_LEN];
 		hal_get_permanent_address(pHwData, dev_addr);
 		SET_IEEE80211_PERM_ADDR(dev, dev_addr);
