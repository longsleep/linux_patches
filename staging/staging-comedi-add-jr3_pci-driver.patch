From bbc4b294bc6b34874a5048959f5ed91440ec982a Mon Sep 17 00:00:00 2001
From: Anders Blomdell <anders.blomdell@control.lth.se>
Date: Thu, 12 Feb 2009 16:07:16 -0800
Subject: Staging: comedi: add jr3_pci driver

From: Anders Blomdell <anders.blomdell@control.lth.se>

hardware driver for JR3/PCI force sensor board

From: Anders Blomdell <anders.blomdell@control.lth.se>
Cc: David Schleef <ds@schleef.org>
Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
Cc: Ian Abbott <abbotti@mev.co.uk>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/comedi/drivers/jr3_pci.c |  972 +++++++++++++++++++++++++++++++
 drivers/staging/comedi/drivers/jr3_pci.h |  634 ++++++++++++++++++++
 2 files changed, 1606 insertions(+)
 create mode 100644 drivers/staging/comedi/drivers/jr3_pci.c
 create mode 100644 drivers/staging/comedi/drivers/jr3_pci.h

--- /dev/null
+++ b/drivers/staging/comedi/drivers/jr3_pci.c
@@ -0,0 +1,972 @@
+/*
+  comedi/drivers/jr3_pci.c
+  hardware driver for JR3/PCI force sensor board
+
+  COMEDI - Linux Control and Measurement Device Interface
+  Copyright (C) 2007 Anders Blomdell <anders.blomdell@control.lth.se>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+/*
+Driver: jr3_pci
+Description: JR3/PCI force sensor board
+Author: Anders Blomdell <anders.blomdell@control.lth.se>
+Status: works
+Devices: [JR3] PCI force sensor board (jr3_pci)
+
+  The DSP on the board requires initialization code, which can
+  be loaded by placing it in /lib/firmware/comedi.
+  The initialization code should be somewhere on the media you got
+  with your card. One version is available from http://www.comedi.org
+  in the comedi_nonfree_firmware tarball.
+
+  Configuration options:
+  [0] - PCI bus number - if bus number and slot number are 0,
+                         then driver search for first unused card
+  [1] - PCI slot number
+
+*/
+
+#include "../comedidev.h"
+
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/firmware.h>
+#include "comedi_pci.h"
+#include "jr3_pci.h"
+
+/* Hotplug firmware loading stuff */
+
+static void comedi_fw_release(struct device *dev)
+{
+	printk(KERN_DEBUG "firmware_sample_driver: ghost_release\n");
+}
+
+static struct device comedi_fw_device = {
+	.bus_id = "comedi",
+	.release = comedi_fw_release
+};
+
+typedef int comedi_firmware_callback(comedi_device * dev,
+	const u8 * data, size_t size);
+
+static int comedi_load_firmware(comedi_device * dev,
+	char *name, comedi_firmware_callback cb)
+{
+	int result = 0;
+	const struct firmware *fw;
+	char *firmware_path;
+	static const char *prefix = "comedi/";
+
+	firmware_path = kmalloc(strlen(prefix) + strlen(name) + 1, GFP_KERNEL);
+	if (!firmware_path) {
+		result = -ENOMEM;
+	} else {
+		firmware_path[0] = '\0';
+		strcat(firmware_path, prefix);
+		strcat(firmware_path, name);
+		result = device_register(&comedi_fw_device);
+		if (result == 0) {
+			result = request_firmware(&fw, firmware_path,
+				&comedi_fw_device);
+			if (result == 0) {
+				if (!cb) {
+					result = -EINVAL;
+				} else {
+					result = cb(dev, fw->data, fw->size);
+				}
+				release_firmware(fw);
+			}
+			device_unregister(&comedi_fw_device);
+		}
+		kfree(firmware_path);
+	}
+	return result;
+}
+
+#define PCI_VENDOR_ID_JR3 0x1762
+#define PCI_DEVICE_ID_JR3_1_CHANNEL 0x3111
+#define PCI_DEVICE_ID_JR3_2_CHANNEL 0x3112
+#define PCI_DEVICE_ID_JR3_3_CHANNEL 0x3113
+#define PCI_DEVICE_ID_JR3_4_CHANNEL 0x3114
+
+static int jr3_pci_attach(comedi_device * dev, comedi_devconfig * it);
+static int jr3_pci_detach(comedi_device * dev);
+
+static comedi_driver driver_jr3_pci = {
+      driver_name:"jr3_pci",
+      module:THIS_MODULE,
+      attach:jr3_pci_attach,
+      detach:jr3_pci_detach,
+};
+
+static DEFINE_PCI_DEVICE_TABLE(jr3_pci_pci_table) = {
+	{PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_1_CHANNEL,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_2_CHANNEL,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_3_CHANNEL,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_JR3, PCI_DEVICE_ID_JR3_4_CHANNEL,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, jr3_pci_pci_table);
+
+typedef struct {
+	struct pci_dev *pci_dev;
+	int pci_enabled;
+	volatile jr3_t *iobase;
+	int n_channels;
+	struct timer_list timer;
+} jr3_pci_dev_private;
+
+typedef struct {
+	int min;
+	int max;
+} poll_delay_t;
+
+typedef struct {
+	volatile jr3_channel_t *channel;
+	unsigned long next_time_min;
+	unsigned long next_time_max;
+	enum { state_jr3_poll,
+		state_jr3_init_wait_for_offset,
+		state_jr3_init_transform_complete,
+		state_jr3_init_set_full_scale_complete,
+		state_jr3_init_use_offset_complete,
+		state_jr3_done
+	} state;
+	int channel_no;
+	int serial_no;
+	int model_no;
+	struct {
+		int length;
+		comedi_krange range;
+	} range[9];
+	const comedi_lrange *range_table_list[8 * 7 + 2];
+	lsampl_t maxdata_list[8 * 7 + 2];
+	u16 errors;
+	int retries;
+} jr3_pci_subdev_private;
+
+static poll_delay_t poll_delay_min_max(int min, int max)
+{
+	poll_delay_t result;
+
+	result.min = min;
+	result.max = max;
+	return result;
+}
+
+static int is_complete(volatile jr3_channel_t * channel)
+{
+	return get_s16(&channel->command_word0) == 0;
+}
+
+typedef struct {
+	struct {
+		u16 link_type;
+		s16 link_amount;
+	} link[8];
+} transform_t;
+
+static void set_transforms(volatile jr3_channel_t * channel,
+	transform_t transf, short num)
+{
+	int i;
+
+	num &= 0x000f;		// Make sure that 0 <= num <= 15
+	for (i = 0; i < 8; i++) {
+
+		set_u16(&channel->transforms[num].link[i].link_type,
+			transf.link[i].link_type);
+		comedi_udelay(1);
+		set_s16(&channel->transforms[num].link[i].link_amount,
+			transf.link[i].link_amount);
+		comedi_udelay(1);
+		if (transf.link[i].link_type == end_x_form) {
+			break;
+		}
+	}
+}
+
+static void use_transform(volatile jr3_channel_t * channel, short transf_num)
+{
+	set_s16(&channel->command_word0, 0x0500 + (transf_num & 0x000f));
+}
+
+static void use_offset(volatile jr3_channel_t * channel, short offset_num)
+{
+	set_s16(&channel->command_word0, 0x0600 + (offset_num & 0x000f));
+}
+
+static void set_offset(volatile jr3_channel_t * channel)
+{
+	set_s16(&channel->command_word0, 0x0700);
+}
+
+typedef struct {
+	s16 fx;
+	s16 fy;
+	s16 fz;
+	s16 mx;
+	s16 my;
+	s16 mz;
+} six_axis_t;
+
+static void set_full_scales(volatile jr3_channel_t * channel,
+	six_axis_t full_scale)
+{
+	printk("%d %d %d %d %d %d\n",
+		full_scale.fx,
+		full_scale.fy,
+		full_scale.fz, full_scale.mx, full_scale.my, full_scale.mz);
+	set_s16(&channel->full_scale.fx, full_scale.fx);
+	set_s16(&channel->full_scale.fy, full_scale.fy);
+	set_s16(&channel->full_scale.fz, full_scale.fz);
+	set_s16(&channel->full_scale.mx, full_scale.mx);
+	set_s16(&channel->full_scale.my, full_scale.my);
+	set_s16(&channel->full_scale.mz, full_scale.mz);
+	set_s16(&channel->command_word0, 0x0a00);
+}
+
+static six_axis_t get_min_full_scales(volatile jr3_channel_t * channel)
+{
+	six_axis_t result;
+	result.fx = get_s16(&channel->min_full_scale.fx);
+	result.fy = get_s16(&channel->min_full_scale.fy);
+	result.fz = get_s16(&channel->min_full_scale.fz);
+	result.mx = get_s16(&channel->min_full_scale.mx);
+	result.my = get_s16(&channel->min_full_scale.my);
+	result.mz = get_s16(&channel->min_full_scale.mz);
+	return result;
+}
+
+static six_axis_t get_max_full_scales(volatile jr3_channel_t * channel)
+{
+	six_axis_t result;
+	result.fx = get_s16(&channel->max_full_scale.fx);
+	result.fy = get_s16(&channel->max_full_scale.fy);
+	result.fz = get_s16(&channel->max_full_scale.fz);
+	result.mx = get_s16(&channel->max_full_scale.mx);
+	result.my = get_s16(&channel->max_full_scale.my);
+	result.mz = get_s16(&channel->max_full_scale.mz);
+	return result;
+}
+
+static int jr3_pci_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int result;
+	jr3_pci_subdev_private *p;
+	int channel;
+
+	p = s->private;
+	channel = CR_CHAN(insn->chanspec);
+	if (p == NULL || channel > 57) {
+		result = -EINVAL;
+	} else {
+		int i;
+
+		result = insn->n;
+		if (p->state != state_jr3_done ||
+			(get_u16(&p->channel->
+					errors) & (watch_dog | watch_dog2 |
+					sensor_change))) {
+			/* No sensor or sensor changed */
+			if (p->state == state_jr3_done) {
+				/* Restart polling */
+				p->state = state_jr3_poll;
+			}
+			result = -EAGAIN;
+		}
+		for (i = 0; i < insn->n; i++) {
+			if (channel < 56) {
+				int axis, filter;
+
+				axis = channel % 8;
+				filter = channel / 8;
+				if (p->state != state_jr3_done) {
+					data[i] = 0;
+				} else {
+					int F = 0;
+					switch (axis) {
+					case 0:{
+							F = get_s16(&p->
+								channel->
+								filter[filter].
+								fx);
+						}
+						break;
+					case 1:{
+							F = get_s16(&p->
+								channel->
+								filter[filter].
+								fy);
+						}
+						break;
+					case 2:{
+							F = get_s16(&p->
+								channel->
+								filter[filter].
+								fz);
+						}
+						break;
+					case 3:{
+							F = get_s16(&p->
+								channel->
+								filter[filter].
+								mx);
+						}
+						break;
+					case 4:{
+							F = get_s16(&p->
+								channel->
+								filter[filter].
+								my);
+						}
+						break;
+					case 5:{
+							F = get_s16(&p->
+								channel->
+								filter[filter].
+								mz);
+						}
+						break;
+					case 6:{
+							F = get_s16(&p->
+								channel->
+								filter[filter].
+								v1);
+						}
+						break;
+					case 7:{
+							F = get_s16(&p->
+								channel->
+								filter[filter].
+								v2);
+						}
+						break;
+					}
+					data[i] = F + 0x4000;
+				}
+			} else if (channel == 56) {
+				if (p->state != state_jr3_done) {
+					data[i] = 0;
+				} else {
+					data[i] =
+						get_u16(&p->channel->model_no);
+				}
+			} else if (channel == 57) {
+				if (p->state != state_jr3_done) {
+					data[i] = 0;
+				} else {
+					data[i] =
+						get_u16(&p->channel->serial_no);
+				}
+			}
+		}
+	}
+	return result;
+}
+
+static void jr3_pci_open(comedi_device * dev)
+{
+	int i;
+	jr3_pci_dev_private *devpriv = dev->private;
+
+	printk("jr3_pci_open\n");
+	for (i = 0; i < devpriv->n_channels; i++) {
+		jr3_pci_subdev_private *p;
+
+		p = dev->subdevices[i].private;
+		if (p) {
+			printk("serial: %p %d (%d)\n", p, p->serial_no,
+				p->channel_no);
+		}
+	}
+}
+
+int read_idm_word(const u8 * data, size_t size, int *pos, unsigned int *val)
+{
+	int result = 0;
+	if (pos != 0 && val != 0) {
+		// Skip over non hex
+		for (; *pos < size && !isxdigit(data[*pos]); (*pos)++) {
+		}
+		// Collect value
+		*val = 0;
+		for (; *pos < size && isxdigit(data[*pos]); (*pos)++) {
+			char ch = tolower(data[*pos]);
+			result = 1;
+			if ('0' <= ch && ch <= '9') {
+				*val = (*val << 4) + (ch - '0');
+			} else if ('a' <= ch && ch <= 'f') {
+				*val = (*val << 4) + (ch - 'a' + 10);
+			}
+		}
+	}
+	return result;
+}
+
+static int jr3_download_firmware(comedi_device * dev, const u8 * data,
+	size_t size)
+{
+	/*
+	 * IDM file format is:
+	 *   { count, address, data <count> } *
+	 *   ffff
+	 */
+	int result, more, pos, OK;
+
+	result = 0;
+	more = 1;
+	pos = 0;
+	OK = 0;
+	while (more) {
+		unsigned int count, addr;
+
+		more = more && read_idm_word(data, size, &pos, &count);
+		if (more && count == 0xffff) {
+			OK = 1;
+			break;
+		}
+		more = more && read_idm_word(data, size, &pos, &addr);
+		while (more && count > 0) {
+			unsigned int dummy;
+			more = more && read_idm_word(data, size, &pos, &dummy);
+			count--;
+		}
+	}
+
+	if (!OK) {
+		result = -ENODATA;
+	} else {
+		int i;
+		jr3_pci_dev_private *p = dev->private;
+
+		for (i = 0; i < p->n_channels; i++) {
+			jr3_pci_subdev_private *sp;
+
+			sp = dev->subdevices[i].private;
+			more = 1;
+			pos = 0;
+			while (more) {
+				unsigned int count, addr;
+				more = more
+					&& read_idm_word(data, size, &pos,
+					&count);
+				if (more && count == 0xffff) {
+					break;
+				}
+				more = more
+					&& read_idm_word(data, size, &pos,
+					&addr);
+				printk("Loading#%d %4.4x bytes at %4.4x\n", i,
+					count, addr);
+				while (more && count > 0) {
+					if (addr & 0x4000) {
+						// 16 bit data, never seen in real life!!
+						unsigned int data1;
+
+						more = more
+							&& read_idm_word(data,
+							size, &pos, &data1);
+						count--;
+						// printk("jr3_data, not tested\n");
+						//        jr3[addr + 0x20000 * pnum] = data1;
+					} else {
+						//  Download 24 bit program
+						unsigned int data1, data2;
+
+						more = more
+							&& read_idm_word(data,
+							size, &pos, &data1);
+						more = more
+							&& read_idm_word(data,
+							size, &pos, &data2);
+						count -= 2;
+						if (more) {
+							set_u16(&p->iobase->
+								channel[i].
+								program_low
+								[addr], data1);
+							comedi_udelay(1);
+							set_u16(&p->iobase->
+								channel[i].
+								program_high
+								[addr], data2);
+							comedi_udelay(1);
+
+						}
+					}
+					addr++;
+				}
+			}
+		}
+	}
+	return result;
+}
+
+static poll_delay_t jr3_pci_poll_subdevice(comedi_subdevice * s)
+{
+	poll_delay_t result = poll_delay_min_max(1000, 2000);
+	jr3_pci_subdev_private *p = s->private;
+
+	if (p) {
+		volatile jr3_channel_t *channel = p->channel;
+		int errors = get_u16(&channel->errors);
+
+		if (errors != p->errors) {
+			printk("Errors: %x -> %x\n", p->errors, errors);
+			p->errors = errors;
+		}
+		if (errors & (watch_dog | watch_dog2 | sensor_change)) {
+			// Sensor communication lost, force poll mode
+			p->state = state_jr3_poll;
+
+		}
+		switch (p->state) {
+		case state_jr3_poll:{
+				u16 model_no = get_u16(&channel->model_no);
+				u16 serial_no = get_u16(&channel->serial_no);
+				if ((errors & (watch_dog | watch_dog2)) ||
+					model_no == 0 || serial_no == 0) {
+					// Still no sensor, keep on polling. Since it takes up to
+					// 10 seconds for offsets to stabilize, polling each
+					// second should suffice.
+					result = poll_delay_min_max(1000, 2000);
+				} else {
+					p->retries = 0;
+					p->state =
+						state_jr3_init_wait_for_offset;
+					result = poll_delay_min_max(1000, 2000);
+				}
+			}
+			break;
+		case state_jr3_init_wait_for_offset:{
+				p->retries++;
+				if (p->retries < 10) {
+					// Wait for offeset to stabilize (< 10 s according to manual)
+					result = poll_delay_min_max(1000, 2000);
+				} else {
+					transform_t transf;
+
+					p->model_no =
+						get_u16(&channel->model_no);
+					p->serial_no =
+						get_u16(&channel->serial_no);
+
+					printk("Setting transform for channel %d\n", p->channel_no);
+					printk("Sensor Model     = %i\n",
+						p->model_no);
+					printk("Sensor Serial    = %i\n",
+						p->serial_no);
+
+					// Transformation all zeros
+					transf.link[0].link_type =
+						(enum link_types)0;
+					transf.link[0].link_amount = 0;
+					transf.link[1].link_type =
+						(enum link_types)0;
+					transf.link[1].link_amount = 0;
+					transf.link[2].link_type =
+						(enum link_types)0;
+					transf.link[2].link_amount = 0;
+					transf.link[3].link_type =
+						(enum link_types)0;
+					transf.link[3].link_amount = 0;
+
+					set_transforms(channel, transf, 0);
+					use_transform(channel, 0);
+					p->state =
+						state_jr3_init_transform_complete;
+					result = poll_delay_min_max(20, 100);	// Allow 20 ms for completion
+				}
+			} break;
+		case state_jr3_init_transform_complete:{
+				if (!is_complete(channel)) {
+					printk("state_jr3_init_transform_complete complete = %d\n", is_complete(channel));
+					result = poll_delay_min_max(20, 100);
+				} else {
+					// Set full scale
+					six_axis_t min_full_scale;
+					six_axis_t max_full_scale;
+
+					min_full_scale =
+						get_min_full_scales(channel);
+					printk("Obtained Min. Full Scales:\n");
+					printk("%i   ", (min_full_scale).fx);
+					printk("%i   ", (min_full_scale).fy);
+					printk("%i   ", (min_full_scale).fz);
+					printk("%i   ", (min_full_scale).mx);
+					printk("%i   ", (min_full_scale).my);
+					printk("%i   ", (min_full_scale).mz);
+					printk("\n");
+
+					max_full_scale =
+						get_max_full_scales(channel);
+					printk("Obtained Max. Full Scales:\n");
+					printk("%i   ", (max_full_scale).fx);
+					printk("%i   ", (max_full_scale).fy);
+					printk("%i   ", (max_full_scale).fz);
+					printk("%i   ", (max_full_scale).mx);
+					printk("%i   ", (max_full_scale).my);
+					printk("%i   ", (max_full_scale).mz);
+					printk("\n");
+
+					set_full_scales(channel,
+						max_full_scale);
+
+					p->state =
+						state_jr3_init_set_full_scale_complete;
+					result = poll_delay_min_max(20, 100);	// Allow 20 ms for completion
+				}
+			}
+			break;
+		case state_jr3_init_set_full_scale_complete:{
+				if (!is_complete(channel)) {
+					printk("state_jr3_init_set_full_scale_complete complete = %d\n", is_complete(channel));
+					result = poll_delay_min_max(20, 100);
+				} else {
+					volatile force_array_t *full_scale;
+
+					// Use ranges in kN or we will overflow arount 2000N!
+					full_scale = &channel->full_scale;
+					p->range[0].range.min =
+						-get_s16(&full_scale->fx) *
+						1000;
+					p->range[0].range.max =
+						get_s16(&full_scale->fx) * 1000;
+					p->range[1].range.min =
+						-get_s16(&full_scale->fy) *
+						1000;
+					p->range[1].range.max =
+						get_s16(&full_scale->fy) * 1000;
+					p->range[2].range.min =
+						-get_s16(&full_scale->fz) *
+						1000;
+					p->range[2].range.max =
+						get_s16(&full_scale->fz) * 1000;
+					p->range[3].range.min =
+						-get_s16(&full_scale->mx) * 100;
+					p->range[3].range.max =
+						get_s16(&full_scale->mx) * 100;
+					p->range[4].range.min =
+						-get_s16(&full_scale->my) * 100;
+					p->range[4].range.max =
+						get_s16(&full_scale->my) * 100;
+					p->range[5].range.min =
+						-get_s16(&full_scale->mz) * 100;
+					p->range[5].range.max =
+						get_s16(&full_scale->mz) * 100;
+					p->range[6].range.min = -get_s16(&full_scale->v1) * 100;	// ??
+					p->range[6].range.max = get_s16(&full_scale->v1) * 100;	// ??
+					p->range[7].range.min = -get_s16(&full_scale->v2) * 100;	// ??
+					p->range[7].range.max = get_s16(&full_scale->v2) * 100;	// ??
+					p->range[8].range.min = 0;
+					p->range[8].range.max = 65535;
+
+					{
+						int i;
+						for (i = 0; i < 9; i++) {
+							printk("%d %d - %d\n",
+								i,
+								p->range[i].
+								range.min,
+								p->range[i].
+								range.max);
+						}
+					}
+
+					use_offset(channel, 0);
+					p->state =
+						state_jr3_init_use_offset_complete;
+					result = poll_delay_min_max(40, 100);	// Allow 40 ms for completion
+				}
+			}
+			break;
+		case state_jr3_init_use_offset_complete:{
+				if (!is_complete(channel)) {
+					printk("state_jr3_init_use_offset_complete complete = %d\n", is_complete(channel));
+					result = poll_delay_min_max(20, 100);
+				} else {
+					printk("Default offsets %d %d %d %d %d %d\n", get_s16(&channel->offsets.fx), get_s16(&channel->offsets.fy), get_s16(&channel->offsets.fz), get_s16(&channel->offsets.mx), get_s16(&channel->offsets.my), get_s16(&channel->offsets.mz));
+
+					set_s16(&channel->offsets.fx, 0);
+					set_s16(&channel->offsets.fy, 0);
+					set_s16(&channel->offsets.fz, 0);
+					set_s16(&channel->offsets.mx, 0);
+					set_s16(&channel->offsets.my, 0);
+					set_s16(&channel->offsets.mz, 0);
+
+					set_offset(channel);
+
+					p->state = state_jr3_done;
+				}
+			}
+			break;
+		case state_jr3_done:{
+				poll_delay_min_max(10000, 20000);
+			}
+			break;
+		default:{
+				poll_delay_min_max(1000, 2000);
+			}
+			break;
+		}
+	}
+	return result;
+}
+
+static void jr3_pci_poll_dev(unsigned long data)
+{
+	unsigned long flags;
+	comedi_device *dev = (comedi_device *) data;
+	jr3_pci_dev_private *devpriv = dev->private;
+	unsigned long now;
+	int delay;
+	int i;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	delay = 1000;
+	now = jiffies;
+	// Poll all channels that are ready to be polled
+	for (i = 0; i < devpriv->n_channels; i++) {
+		jr3_pci_subdev_private *subdevpriv = dev->subdevices[i].private;
+		if (now > subdevpriv->next_time_min) {
+			poll_delay_t sub_delay;
+
+			sub_delay = jr3_pci_poll_subdevice(&dev->subdevices[i]);
+			subdevpriv->next_time_min =
+				jiffies + msecs_to_jiffies(sub_delay.min);
+			subdevpriv->next_time_max =
+				jiffies + msecs_to_jiffies(sub_delay.max);
+			if (sub_delay.max && sub_delay.max < delay) {
+				// Wake up as late as possible -> poll as many channels as
+				// possible at once
+				delay = sub_delay.max;
+			}
+		}
+	}
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	devpriv->timer.expires = jiffies + msecs_to_jiffies(delay);
+	add_timer(&devpriv->timer);
+}
+
+static int jr3_pci_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int result = 0;
+	struct pci_dev *card = NULL;
+	int opt_bus, opt_slot, i;
+	jr3_pci_dev_private *devpriv;
+
+	printk("comedi%d: jr3_pci\n", dev->minor);
+
+	opt_bus = it->options[0];
+	opt_slot = it->options[1];
+
+	if (sizeof(jr3_channel_t) != 0xc00) {
+		printk("sizeof(jr3_channel_t) = %x [expected %x]\n",
+			(unsigned)sizeof(jr3_channel_t), 0xc00);
+		return -EINVAL;
+	}
+
+	result = alloc_private(dev, sizeof(jr3_pci_dev_private));
+	if (result < 0) {
+		return -ENOMEM;
+	}
+	card = NULL;
+	devpriv = dev->private;
+	init_timer(&devpriv->timer);
+	while (1) {
+		card = pci_get_device(PCI_VENDOR_ID_JR3, PCI_ANY_ID, card);
+		if (card == NULL) {
+			/* No card found */
+			break;
+		} else {
+			switch (card->device) {
+			case PCI_DEVICE_ID_JR3_1_CHANNEL:{
+					devpriv->n_channels = 1;
+				}
+				break;
+			case PCI_DEVICE_ID_JR3_2_CHANNEL:{
+					devpriv->n_channels = 2;
+				}
+				break;
+			case PCI_DEVICE_ID_JR3_3_CHANNEL:{
+					devpriv->n_channels = 3;
+				}
+				break;
+			case PCI_DEVICE_ID_JR3_4_CHANNEL:{
+					devpriv->n_channels = 4;
+				}
+				break;
+			default:{
+					devpriv->n_channels = 0;
+				}
+			}
+			if (devpriv->n_channels >= 1) {
+				if (opt_bus == 0 && opt_slot == 0) {
+					/* Take first available card */
+					break;
+				} else if (opt_bus == card->bus->number &&
+					opt_slot == PCI_SLOT(card->devfn)) {
+					/* Take requested card */
+					break;
+				}
+			}
+		}
+	}
+	if (!card) {
+		printk(" no jr3_pci found\n");
+		return -EIO;
+	} else {
+		devpriv->pci_dev = card;
+		dev->board_name = "jr3_pci";
+	}
+	if ((result = comedi_pci_enable(card, "jr3_pci")) < 0) {
+		return -EIO;
+	}
+	devpriv->pci_enabled = 1;
+	devpriv->iobase = ioremap(pci_resource_start(card, 0), sizeof(jr3_t));
+	result = alloc_subdevices(dev, devpriv->n_channels);
+	if (result < 0)
+		goto out;
+
+	dev->open = jr3_pci_open;
+	for (i = 0; i < devpriv->n_channels; i++) {
+		dev->subdevices[i].type = COMEDI_SUBD_AI;
+		dev->subdevices[i].subdev_flags = SDF_READABLE | SDF_GROUND;
+		dev->subdevices[i].n_chan = 8 * 7 + 2;
+		dev->subdevices[i].insn_read = jr3_pci_ai_insn_read;
+		dev->subdevices[i].private =
+			kzalloc(sizeof(jr3_pci_subdev_private), GFP_KERNEL);
+		if (dev->subdevices[i].private) {
+			jr3_pci_subdev_private *p;
+			int j;
+
+			p = dev->subdevices[i].private;
+			p->channel = &devpriv->iobase->channel[i].data;
+			printk("p->channel %p %p (%tx)\n",
+				p->channel, devpriv->iobase,
+				((char *)(p->channel) -
+					(char *)(devpriv->iobase)));
+			p->channel_no = i;
+			for (j = 0; j < 8; j++) {
+				int k;
+
+				p->range[j].length = 1;
+				p->range[j].range.min = -1000000;
+				p->range[j].range.max = 1000000;
+				for (k = 0; k < 7; k++) {
+					p->range_table_list[j + k * 8] =
+						(comedi_lrange *) & p->range[j];
+					p->maxdata_list[j + k * 8] = 0x7fff;
+				}
+			}
+			p->range[8].length = 1;
+			p->range[8].range.min = 0;
+			p->range[8].range.max = 65536;
+
+			p->range_table_list[56] =
+				(comedi_lrange *) & p->range[8];
+			p->range_table_list[57] =
+				(comedi_lrange *) & p->range[8];
+			p->maxdata_list[56] = 0xffff;
+			p->maxdata_list[57] = 0xffff;
+			// Channel specific range and maxdata
+			dev->subdevices[i].range_table = 0;
+			dev->subdevices[i].range_table_list =
+				p->range_table_list;
+			dev->subdevices[i].maxdata = 0;
+			dev->subdevices[i].maxdata_list = p->maxdata_list;
+		}
+	}
+
+	// Reset DSP card
+	devpriv->iobase->channel[0].reset = 0;
+
+	result = comedi_load_firmware(dev, "jr3pci.idm", jr3_download_firmware);
+	printk("Firmare load %d\n", result);
+
+	if (result < 0) {
+		goto out;
+	}
+	// TODO: use firmware to load preferred offset tables. Suggested format:
+	// model serial Fx Fy Fz Mx My Mz\n
+	//
+	// comedi_load_firmware(dev, "jr3_offsets_table", jr3_download_firmware);
+
+	// It takes a few milliseconds for software to settle
+	// as much as we can read firmware version
+	msleep_interruptible(25);
+	for (i = 0; i < 0x18; i++) {
+		printk("%c",
+			get_u16(&devpriv->iobase->channel[0].data.
+				copyright[i]) >> 8);
+	}
+
+	// Start card timer
+	for (i = 0; i < devpriv->n_channels; i++) {
+		jr3_pci_subdev_private *p = dev->subdevices[i].private;
+
+		p->next_time_min = jiffies + msecs_to_jiffies(500);
+		p->next_time_max = jiffies + msecs_to_jiffies(2000);
+	}
+
+	devpriv->timer.data = (unsigned long)dev;
+	devpriv->timer.function = jr3_pci_poll_dev;
+	devpriv->timer.expires = jiffies + msecs_to_jiffies(1000);
+	add_timer(&devpriv->timer);
+
+      out:
+	return result;
+}
+
+static int jr3_pci_detach(comedi_device * dev)
+{
+	int i;
+	jr3_pci_dev_private *devpriv = dev->private;
+
+	printk("comedi%d: jr3_pci: remove\n", dev->minor);
+	if (devpriv) {
+		del_timer_sync(&devpriv->timer);
+
+		if (dev->subdevices) {
+			for (i = 0; i < devpriv->n_channels; i++) {
+				kfree(dev->subdevices[i].private);
+			}
+		}
+
+		if (devpriv->iobase) {
+			iounmap((void *)devpriv->iobase);
+		}
+		if (devpriv->pci_enabled) {
+			comedi_pci_disable(devpriv->pci_dev);
+		}
+
+		if (devpriv->pci_dev) {
+			pci_dev_put(devpriv->pci_dev);
+		}
+	}
+	return 0;
+}
+
+COMEDI_PCI_INITCLEANUP(driver_jr3_pci, jr3_pci_pci_table);
--- /dev/null
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -0,0 +1,634 @@
+// Helper types to take care of the fact that the DSP card memory
+//   is 16 bits, but aligned on a 32 bit PCI boundary
+typedef u32 u_val_t;
+
+typedef s32 s_val_t;
+
+static inline u16 get_u16(volatile const u_val_t * p)
+{
+	return (u16) readl(p);
+}
+
+static inline void set_u16(volatile u_val_t * p, u16 val)
+{
+	writel(val, p);
+}
+
+static inline s16 get_s16(volatile const s_val_t * p)
+{
+	return (s16) readl(p);
+}
+
+static inline void set_s16(volatile s_val_t * p, s16 val)
+{
+	writel(val, p);
+}
+
+// The raw data is stored in a format which facilitates rapid
+// processing by the JR3 DSP chip. The raw_channel structure shows the
+// format for a single channel of data. Each channel takes four,
+// two-byte words.
+//
+// Raw_time is an unsigned integer which shows the value of the JR3
+// DSP's internal clock at the time the sample was received. The clock
+// runs at 1/10 the JR3 DSP cycle time. JR3's slowest DSP runs at 10
+// Mhz. At 10 Mhz raw_time would therefore clock at 1 Mhz.
+//
+// Raw_data is the raw data received directly from the sensor. The
+// sensor data stream is capable of representing 16 different
+// channels. Channel 0 shows the excitation voltage at the sensor. It
+// is used to regulate the voltage over various cable lengths.
+// Channels 1-6 contain the coupled force data Fx through Mz. Channel
+// 7 contains the sensor's calibration data. The use of channels 8-15
+// varies with different sensors.
+typedef struct raw_channel {
+	u_val_t raw_time;
+	s_val_t raw_data;
+	s_val_t reserved[2];
+} raw_channel_t;
+
+// The force_array structure shows the layout for the decoupled and
+// filtered force data.
+typedef struct force_array {
+	s_val_t fx;
+	s_val_t fy;
+	s_val_t fz;
+	s_val_t mx;
+	s_val_t my;
+	s_val_t mz;
+	s_val_t v1;
+	s_val_t v2;
+} force_array_t;
+
+// The six_axis_array structure shows the layout for the offsets and
+// the full scales.
+typedef struct six_axis_array {
+	s_val_t fx;
+	s_val_t fy;
+	s_val_t fz;
+	s_val_t mx;
+	s_val_t my;
+	s_val_t mz;
+} six_axis_array_t;
+
+// VECT_BITS
+// The vect_bits structure shows the layout for indicating
+// which axes to use in computing the vectors. Each bit signifies
+// selection of a single axis. The V1x axis bit corresponds to a hex
+// value of 0x0001 and the V2z bit corresponds to a hex value of
+// 0x0020. Example: to specify the axes V1x, V1y, V2x, and V2z the
+// pattern would be 0x002b. Vector 1 defaults to a force vector and
+// vector 2 defaults to a moment vector. It is possible to change one
+// or the other so that two force vectors or two moment vectors are
+// calculated. Setting the changeV1 bit or the changeV2 bit will
+// change that vector to be the opposite of its default. Therefore to
+// have two force vectors, set changeV1 to 1.
+
+typedef enum {
+	fx = 0x0001,
+	fy = 0x0002,
+	fz = 0x0004,
+	mx = 0x0008,
+	my = 0x0010,
+	mz = 0x0020,
+	changeV2 = 0x0040,
+	changeV1 = 0x0080
+} vect_bits_t;
+
+// WARNING_BITS
+// The warning_bits structure shows the bit pattern for the warning
+// word. The bit fields are shown from bit 0 (lsb) to bit 15 (msb).
+//
+// XX_NEAR_SET
+// The xx_near_sat bits signify that the indicated axis has reached or
+// exceeded the near saturation value.
+
+typedef enum {
+	fx_near_sat = 0x0001,
+	fy_near_sat = 0x0002,
+	fz_near_sat = 0x0004,
+	mx_near_sat = 0x0008,
+	my_near_sat = 0x0010,
+	mz_near_sat = 0x0020
+} warning_bits_t;
+
+// ERROR_BITS
+// XX_SAT
+// MEMORY_ERROR
+// SENSOR_CHANGE
+//
+// The error_bits structure shows the bit pattern for the error word.
+// The bit fields are shown from bit 0 (lsb) to bit 15 (msb). The
+// xx_sat bits signify that the indicated axis has reached or exceeded
+// the saturation value. The memory_error bit indicates that a problem
+// was detected in the on-board RAM during the power-up
+// initialization. The sensor_change bit indicates that a sensor other
+// than the one originally plugged in has passed its CRC check. This
+// bit latches, and must be reset by the user.
+//
+// SYSTEM_BUSY
+//
+// The system_busy bit indicates that the JR3 DSP is currently busy
+// and is not calculating force data. This occurs when a new
+// coordinate transformation, or new sensor full scale is set by the
+// user. A very fast system using the force data for feedback might
+// become unstable during the approximately 4 ms needed to accomplish
+// these calculations. This bit will also become active when a new
+// sensor is plugged in and the system needs to recalculate the
+// calibration CRC.
+//
+// CAL_CRC_BAD
+//
+// The cal_crc_bad bit indicates that the calibration CRC has not
+// calculated to zero. CRC is short for cyclic redundancy code. It is
+// a method for determining the integrity of messages in data
+// communication. The calibration data stored inside the sensor is
+// transmitted to the JR3 DSP along with the sensor data. The
+// calibration data has a CRC attached to the end of it, to assist in
+// determining the completeness and integrity of the calibration data
+// received from the sensor. There are two reasons the CRC may not
+// have calculated to zero. The first is that all the calibration data
+// has not yet been received, the second is that the calibration data
+// has been corrupted. A typical sensor transmits the entire contents
+// of its calibration matrix over 30 times a second. Therefore, if
+// this bit is not zero within a couple of seconds after the sensor
+// has been plugged in, there is a problem with the sensor's
+// calibration data.
+//
+// WATCH_DOG
+// WATCH_DOG2
+//
+// The watch_dog and watch_dog2 bits are sensor, not processor, watch
+// dog bits. Watch_dog indicates that the sensor data line seems to be
+// acting correctly, while watch_dog2 indicates that sensor data and
+// clock are being received. It is possible for watch_dog2 to go off
+// while watch_dog does not. This would indicate an improper clock
+// signal, while data is acting correctly. If either watch dog barks,
+// the sensor data is not being received correctly.
+
+typedef enum {
+	fx_sat = 0x0001,
+	fy_sat = 0x0002,
+	fz_sat = 0x0004,
+	mx_sat = 0x0008,
+	my_sat = 0x0010,
+	mz_sat = 0x0020,
+	memory_error = 0x0400,
+	sensor_change = 0x0800,
+	system_busy = 0x1000,
+	cal_crc_bad = 0x2000,
+	watch_dog2 = 0x4000,
+	watch_dog = 0x8000
+} error_bits_t;
+
+// THRESH_STRUCT
+// This structure shows the layout for a single threshold packet inside of a
+// load envelope. Each load envelope can contain several threshold structures.
+// 1. data_address contains the address of the data for that threshold. This
+//    includes filtered, unfiltered, raw, rate, counters, error and warning data
+// 2. threshold is the is the value at which, if data is above or below, the
+//    bits will be set ... (pag.24).
+// 3. bit_pattern contains the bits that will be set if the threshold value is
+//    met or exceeded.
+typedef struct thresh_struct {
+	s32 data_address;
+	s32 threshold;
+	s32 bit_pattern;
+} thresh_struct;
+
+// LE_STRUCT
+// Layout of a load enveloped packet. Four thresholds are showed ... for more
+// see manual (pag.25)
+// 1. latch_bits is a bit pattern that show which bits the user wants to latch.
+//    The latched bits will not be reset once the threshold which set them is
+//    no longer true. In that case the user must reset them using the reset_bit
+//    command.
+// 2. number_of_xx_thresholds specify how many GE/LE threshold there are.
+typedef struct {
+	s32 latch_bits;
+	s32 number_of_ge_thresholds;
+	s32 number_of_le_thresholds;
+	struct thresh_struct thresholds[4];
+	s32 reserved;
+} le_struct_t;
+
+// LINK_TYPES
+// Link types is an enumerated value showing the different possible transform
+// link types.
+// 0 - end transform packet
+// 1 - translate along X axis (TX)
+// 2 - translate along Y axis (TY)
+// 3 - translate along Z axis (TZ)
+// 4 - rotate about X axis (RX)
+// 5 - rotate about Y axis (RY)
+// 6 - rotate about Z axis (RZ)
+// 7 - negate all axes (NEG)
+typedef enum link_types {
+	end_x_form,
+	tx,
+	ty,
+	tz,
+	rx,
+	ry,
+	rz,
+	neg
+} link_types;
+
+// TRANSFORM
+// Structure used to describe a transform.
+typedef struct {
+	struct {
+		u_val_t link_type;
+		s_val_t link_amount;
+	} link[8];
+} intern_transform_t;
+
+// JR3 force/torque sensor data definition. For more information see sensor and
+// hardware manuals.
+
+typedef struct force_sensor_data {
+	// Raw_channels is the area used to store the raw data coming from
+	// the sensor.
+
+	raw_channel_t raw_channels[16];	/* offset 0x0000 */
+
+	// Copyright is a null terminated ASCII string containing the JR3
+	// copyright notice.
+
+	u_val_t copyright[0x0018];	/* offset 0x0040 */
+	s_val_t reserved1[0x0008];	/* offset 0x0058 */
+
+	// Shunts contains the sensor shunt readings. Some JR3 sensors have
+	//  the ability to have their gains adjusted. This allows the
+	//  hardware full scales to be adjusted to potentially allow
+	//  better resolution or dynamic range. For sensors that have
+	//  this ability, the gain of each sensor channel is measured at
+	//  the time of calibration using a shunt resistor. The shunt
+	//  resistor is placed across one arm of the resistor bridge, and
+	//  the resulting change in the output of that channel is
+	//  measured. This measurement is called the shunt reading, and
+	//  is recorded here. If the user has changed the gain of the //
+	// sensor, and made new shunt measurements, those shunt
+	//  measurements can be placed here. The JR3 DSP will then scale
+	//  the calibration matrix such so that the gains are again
+	//  proper for the indicated shunt readings. If shunts is 0, then
+	//  the sensor cannot have its gain changed. For details on
+	//  changing the sensor gain, and making shunts readings, please
+	//  see the sensor manual. To make these values take effect the
+	//  user must call either command (5) use transform # (pg. 33) or
+	//  command (10) set new full scales (pg. 38).
+
+	six_axis_array_t shunts;	/* offset 0x0060 */
+	s32 reserved2[2];	/* offset 0x0066 */
+
+	// Default_FS contains the full scale that is used if the user does
+	// not set a full scale.
+
+	six_axis_array_t default_FS;	/* offset 0x0068 */
+	s_val_t reserved3;	/* offset 0x006e */
+
+	// Load_envelope_num is the load envelope number that is currently
+	// in use. This value is set by the user after one of the load
+	// envelopes has been initialized.
+
+	s_val_t load_envelope_num;	/* offset 0x006f */
+
+	// Min_full_scale is the recommend minimum full scale.
+	//
+	// These values in conjunction with max_full_scale (pg. 9) helps
+	// determine the appropriate value for setting the full scales. The
+	// software allows the user to set the sensor full scale to an
+	// arbitrary value. But setting the full scales has some hazards. If
+	// the full scale is set too low, the data will saturate
+	// prematurely, and dynamic range will be lost. If the full scale is
+	// set too high, then resolution is lost as the data is shifted to
+	// the right and the least significant bits are lost. Therefore the
+	// maximum full scale is the maximum value at which no resolution is
+	// lost, and the minimum full scale is the value at which the data
+	// will not saturate prematurely. These values are calculated
+	// whenever a new coordinate transformation is calculated. It is
+	// possible for the recommended maximum to be less than the
+	// recommended minimum. This comes about primarily when using
+	// coordinate translations. If this is the case, it means that any
+	// full scale selection will be a compromise between dynamic range
+	// and resolution. It is usually recommended to compromise in favor
+	// of resolution which means that the recommend maximum full scale
+	// should be chosen.
+	//
+	// WARNING: Be sure that the full scale is no less than 0.4% of the
+	// recommended minimum full scale. Full scales below this value will
+	// cause erroneous results.
+
+	six_axis_array_t min_full_scale;	/* offset 0x0070 */
+	s_val_t reserved4;	/* offset 0x0076 */
+
+	// Transform_num is the transform number that is currently in use.
+	// This value is set by the JR3 DSP after the user has used command
+	// (5) use transform # (pg. 33).
+
+	s_val_t transform_num;	/* offset 0x0077 */
+
+	// Max_full_scale is the recommended maximum full scale. See
+	// min_full_scale (pg. 9) for more details.
+
+	six_axis_array_t max_full_scale;	/* offset 0x0078 */
+	s_val_t reserved5;	/* offset 0x007e */
+
+	// Peak_address is the address of the data which will be monitored
+	// by the peak routine. This value is set by the user. The peak
+	// routine will monitor any 8 contiguous addresses for peak values.
+	// (ex. to watch filter3 data for peaks, set this value to 0x00a8).
+
+	s_val_t peak_address;	/* offset 0x007f */
+
+	// Full_scale is the sensor full scales which are currently in use.
+	// Decoupled and filtered data is scaled so that +/- 16384 is equal
+	// to the full scales. The engineering units used are indicated by
+	// the units value discussed on page 16. The full scales for Fx, Fy,
+	// Fz, Mx, My and Mz can be written by the user prior to calling
+	// command (10) set new full scales (pg. 38). The full scales for V1
+	// and V2 are set whenever the full scales are changed or when the
+	// axes used to calculate the vectors are changed. The full scale of
+	// V1 and V2 will always be equal to the largest full scale of the
+	// axes used for each vector respectively.
+
+	force_array_t full_scale;	/* offset 0x0080 */
+
+	// Offsets contains the sensor offsets. These values are subtracted from
+	// the sensor data to obtain the decoupled data. The offsets are set a
+	// few seconds (< 10) after the calibration data has been received.
+	// They are set so that the output data will be zero. These values
+	// can be written as well as read. The JR3 DSP will use the values
+	// written here within 2 ms of being written. To set future
+	// decoupled data to zero, add these values to the current decoupled
+	// data values and place the sum here. The JR3 DSP will change these
+	// values when a new transform is applied. So if the offsets are
+	// such that FX is 5 and all other values are zero, after rotating
+	// about Z by 90 degrees, FY would be 5 and all others would be zero.
+
+	six_axis_array_t offsets;	/* offset 0x0088 */
+
+	// Offset_num is the number of the offset currently in use. This
+	// value is set by the JR3 DSP after the user has executed the use
+	// offset # command (pg. 34). It can vary between 0 and 15.
+
+	s_val_t offset_num;	/* offset 0x008e */
+
+	// Vect_axes is a bit map showing which of the axes are being used
+	// in the vector calculations. This value is set by the JR3 DSP
+	// after the user has executed the set vector axes command (pg. 37).
+
+	u_val_t vect_axes;	/* offset 0x008f */
+
+	// Filter0 is the decoupled, unfiltered data from the JR3 sensor.
+	// This data has had the offsets removed.
+	//
+	// These force_arrays hold the filtered data. The decoupled data is
+	// passed through cascaded low pass filters. Each succeeding filter
+	// has a cutoff frequency of 1/4 of the preceding filter. The cutoff
+	// frequency of filter1 is 1/16 of the sample rate from the sensor.
+	// For a typical sensor with a sample rate of 8 kHz, the cutoff
+	// frequency of filter1 would be 500 Hz. The following filters would
+	// cutoff at 125 Hz, 31.25 Hz, 7.813 Hz, 1.953 Hz and 0.4883 Hz.
+
+	struct force_array filter[7];	/* offset 0x0090,
+					   offset 0x0098,
+					   offset 0x00a0,
+					   offset 0x00a8,
+					   offset 0x00b0,
+					   offset 0x00b8 ,
+					   offset 0x00c0 */
+
+	// Rate_data is the calculated rate data. It is a first derivative
+	// calculation. It is calculated at a frequency specified by the
+	// variable rate_divisor (pg. 12). The data on which the rate is
+	// calculated is specified by the variable rate_address (pg. 12).
+
+	force_array_t rate_data;	/* offset 0x00c8 */
+
+	// Minimum_data & maximum_data are the minimum and maximum (peak)
+	// data values. The JR3 DSP can monitor any 8 contiguous data items
+	// for minimums and maximums at full sensor bandwidth. This area is
+	// only updated at user request. This is done so that the user does
+	// not miss any peaks. To read the data, use either the read peaks
+	// command (pg. 40), or the read and reset peaks command (pg. 39).
+	// The address of the data to watch for peaks is stored in the
+	// variable peak_address (pg. 10). Peak data is lost when executing
+	// a coordinate transformation or a full scale change. Peak data is
+	// also lost when plugging in a new sensor.
+
+	force_array_t minimum_data;	/* offset 0x00d0 */
+	force_array_t maximum_data;	/* offset 0x00d8 */
+
+	// Near_sat_value & sat_value contain the value used to determine if
+	// the raw sensor is saturated. Because of decoupling and offset
+	// removal, it is difficult to tell from the processed data if the
+	// sensor is saturated. These values, in conjunction with the error
+	// and warning words (pg. 14), provide this critical information.
+	// These two values may be set by the host processor. These values
+	// are positive signed values, since the saturation logic uses the
+	// absolute values of the raw data. The near_sat_value defaults to
+	// approximately 80% of the ADC's full scale, which is 26214, while
+	// sat_value defaults to the ADC's full scale:
+	//
+	//   sat_value = 32768 - 2^(16 - ADC bits)
+
+	s_val_t near_sat_value;	/* offset 0x00e0 */
+	s_val_t sat_value;	/* offset 0x00e1 */
+
+	// Rate_address, rate_divisor & rate_count contain the data used to
+	// control the calculations of the rates. Rate_address is the
+	// address of the data used for the rate calculation. The JR3 DSP
+	// will calculate rates for any 8 contiguous values (ex. to
+	// calculate rates for filter3 data set rate_address to 0x00a8).
+	// Rate_divisor is how often the rate is calculated. If rate_divisor
+	// is 1, the rates are calculated at full sensor bandwidth. If
+	// rate_divisor is 200, rates are calculated every 200 samples.
+	// Rate_divisor can be any value between 1 and 65536. Set
+	// rate_divisor to 0 to calculate rates every 65536 samples.
+	// Rate_count starts at zero and counts until it equals
+	// rate_divisor, at which point the rates are calculated, and
+	// rate_count is reset to 0. When setting a new rate divisor, it is
+	// a good idea to set rate_count to one less than rate divisor. This
+	// will minimize the time necessary to start the rate calculations.
+
+	s_val_t rate_address;	/* offset 0x00e2 */
+	u_val_t rate_divisor;	/* offset 0x00e3 */
+	u_val_t rate_count;	/* offset 0x00e4 */
+
+	// Command_word2 through command_word0 are the locations used to
+	// send commands to the JR3 DSP. Their usage varies with the command
+	// and is detailed later in the Command Definitions section (pg.
+	// 29). In general the user places values into various memory
+	// locations, and then places the command word into command_word0.
+	// The JR3 DSP will process the command and place a 0 into
+	// command_word0 to indicate successful completion. Alternatively
+	// the JR3 DSP will place a negative number into command_word0 to
+	// indicate an error condition. Please note the command locations
+	// are numbered backwards. (I.E. command_word2 comes before
+	// command_word1).
+
+	s_val_t command_word2;	/* offset 0x00e5 */
+	s_val_t command_word1;	/* offset 0x00e6 */
+	s_val_t command_word0;	/* offset 0x00e7 */
+
+	// Count1 through count6 are unsigned counters which are incremented
+	// every time the matching filters are calculated. Filter1 is
+	// calculated at the sensor data bandwidth. So this counter would
+	// increment at 8 kHz for a typical sensor. The rest of the counters
+	// are incremented at 1/4 the interval of the counter immediately
+	// preceding it, so they would count at 2 kHz, 500 Hz, 125 Hz etc.
+	// These counters can be used to wait for data. Each time the
+	// counter changes, the corresponding data set can be sampled, and
+	// this will insure that the user gets each sample, once, and only
+	// once.
+
+	u_val_t count1;		/* offset 0x00e8 */
+	u_val_t count2;		/* offset 0x00e9 */
+	u_val_t count3;		/* offset 0x00ea */
+	u_val_t count4;		/* offset 0x00eb */
+	u_val_t count5;		/* offset 0x00ec */
+	u_val_t count6;		/* offset 0x00ed */
+
+	// Error_count is a running count of data reception errors. If this
+	// counter is changing rapidly, it probably indicates a bad sensor
+	// cable connection or other hardware problem. In most installations
+	// error_count should not change at all. But it is possible in an
+	// extremely noisy environment to experience occasional errors even
+	// without a hardware problem. If the sensor is well grounded, this
+	// is probably unavoidable in these environments. On the occasions
+	// where this counter counts a bad sample, that sample is ignored.
+
+	u_val_t error_count;	/* offset 0x00ee */
+
+	// Count_x is a counter which is incremented every time the JR3 DSP
+	// searches its job queues and finds nothing to do. It indicates the
+	// amount of idle time the JR3 DSP has available. It can also be
+	// used to determine if the JR3 DSP is alive. See the Performance
+	// Issues section on pg. 49 for more details.
+
+	u_val_t count_x;	/* offset 0x00ef */
+
+	// Warnings & errors contain the warning and error bits
+	// respectively. The format of these two words is discussed on page
+	// 21 under the headings warnings_bits and error_bits.
+
+	u_val_t warnings;	/* offset 0x00f0 */
+	u_val_t errors;		/* offset 0x00f1 */
+
+	// Threshold_bits is a word containing the bits that are set by the
+	// load envelopes. See load_envelopes (pg. 17) and thresh_struct
+	// (pg. 23) for more details.
+
+	s_val_t threshold_bits;	/* offset 0x00f2 */
+
+	// Last_crc is the value that shows the actual calculated CRC. CRC
+	// is short for cyclic redundancy code. It should be zero. See the
+	// description for cal_crc_bad (pg. 21) for more information.
+
+	s_val_t last_CRC;	/* offset 0x00f3 */
+
+	// EEProm_ver_no contains the version number of the sensor EEProm.
+	// EEProm version numbers can vary between 0 and 255.
+	// Software_ver_no contains the software version number. Version
+	// 3.02 would be stored as 302.
+
+	s_val_t eeprom_ver_no;	/* offset 0x00f4 */
+	s_val_t software_ver_no;	/* offset 0x00f5 */
+
+	// Software_day & software_year are the release date of the software
+	// the JR3 DSP is currently running. Day is the day of the year,
+	// with January 1 being 1, and December 31, being 365 for non leap
+	// years.
+
+	s_val_t software_day;	/* offset 0x00f6 */
+	s_val_t software_year;	/* offset 0x00f7 */
+
+	// Serial_no & model_no are the two values which uniquely identify a
+	// sensor. This model number does not directly correspond to the JR3
+	// model number, but it will provide a unique identifier for
+	// different sensor configurations.
+
+	u_val_t serial_no;	/* offset 0x00f8 */
+	u_val_t model_no;	/* offset 0x00f9 */
+
+	// Cal_day & cal_year are the sensor calibration date. Day is the
+	// day of the year, with January 1 being 1, and December 31, being
+	// 366 for leap years.
+
+	s_val_t cal_day;	/* offset 0x00fa */
+	s_val_t cal_year;	/* offset 0x00fb */
+
+	// Units is an enumerated read only value defining the engineering
+	// units used in the sensor full scale. The meanings of particular
+	// values are discussed in the section detailing the force_units
+	// structure on page 22. The engineering units are setto customer
+	// specifications during sensor manufacture and cannot be changed by
+	// writing to Units.
+	//
+	// Bits contains the number of bits of resolution of the ADC
+	// currently in use.
+	//
+	// Channels is a bit field showing which channels the current sensor
+	// is capable of sending. If bit 0 is active, this sensor can send
+	// channel 0, if bit 13 is active, this sensor can send channel 13,
+	// etc. This bit can be active, even if the sensor is not currently
+	// sending this channel. Some sensors are configurable as to which
+	// channels to send, and this field only contains information on the
+	// channels available to send, not on the current configuration. To
+	// find which channels are currently being sent, monitor the
+	// Raw_time fields (pg. 19) in the raw_channels array (pg. 7). If
+	// the time is changing periodically, then that channel is being
+	// received.
+
+	u_val_t units;		/* offset 0x00fc */
+	s_val_t bits;		/* offset 0x00fd */
+	s_val_t channels;	/* offset 0x00fe */
+
+	// Thickness specifies the overall thickness of the sensor from
+	// flange to flange. The engineering units for this value are
+	// contained in units (pg. 16). The sensor calibration is relative
+	// to the center of the sensor. This value allows easy coordinate
+	// transformation from the center of the sensor to either flange.
+
+	s_val_t thickness;	/* offset 0x00ff */
+
+	// Load_envelopes is a table containing the load envelope
+	// descriptions. There are 16 possible load envelope slots in the
+	// table. The slots are on 16 word boundaries and are numbered 0-15.
+	// Each load envelope needs to start at the beginning of a slot but
+	// need not be fully contained in that slot. That is to say that a
+	// single load envelope can be larger than a single slot. The
+	// software has been tested and ran satisfactorily with 50
+	// thresholds active. A single load envelope this large would take
+	// up 5 of the 16 slots. The load envelope data is laid out in an
+	// order that is most efficient for the JR3 DSP. The structure is
+	// detailed later in the section showing the definition of the
+	// le_struct structure (pg. 23).
+
+	le_struct_t load_envelopes[0x10];	/* offset 0x0100 */
+
+	// Transforms is a table containing the transform descriptions.
+	// There are 16 possible transform slots in the table. The slots are
+	// on 16 word boundaries and are numbered 0-15. Each transform needs
+	// to start at the beginning of a slot but need not be fully
+	// contained in that slot. That is to say that a single transform
+	// can be larger than a single slot. A transform is 2 * no of links
+	// + 1 words in length. So a single slot can contain a transform
+	// with 7 links. Two slots can contain a transform that is 15 links.
+	// The layout is detailed later in the section showing the
+	// definition of the transform structure (pg. 26).
+
+	intern_transform_t transforms[0x10];	/* offset 0x0200 */
+} jr3_channel_t;
+
+typedef struct {
+	struct {
+		u_val_t program_low[0x4000];	// 0x00000 - 0x10000
+		jr3_channel_t data;	// 0x10000 - 0x10c00
+		char pad2[0x30000 - 0x00c00];	// 0x10c00 - 0x40000
+		u_val_t program_high[0x8000];	// 0x40000 - 0x60000
+		u32 reset;	// 0x60000 - 0x60004
+		char pad3[0x20000 - 0x00004];	// 0x60004 - 0x80000
+	} channel[4];
+} jr3_t;
