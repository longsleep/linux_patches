From sathyap@serverengines.com  Tue Nov 25 11:19:47 2008
From: Sathya Perla <sathyap@serverengines.com>
Date: Mon, 24 Nov 2008 11:04:45 +0530
Subject: Staging: benet: patch to use offsetof() instead of AMAP_BYTE_OFFSET()
To: Greg KH <greg@kroah.com>
Cc: "J.R. Mauro" <jrm8005@gmail.com>, subbu <subbus@serverengines.com>, Greg KH <gregkh@suse.de>
Message-ID: <1227504885.544.13.camel@sperla-laptop>


Signed-off-by: Sathya Perla <sathyap@serverengines.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/benet/funcobj.c |   10 +--
 drivers/staging/benet/hwlib.h   |  103 ++++++++++++++--------------------------
 drivers/staging/benet/mpu.c     |   15 +++--
 3 files changed, 51 insertions(+), 77 deletions(-)

--- a/drivers/staging/benet/funcobj.c
+++ b/drivers/staging/benet/funcobj.c
@@ -208,7 +208,7 @@ be_function_prepare_embedded_fwcmd(struc
 
 	ASSERT(wrb);
 
-	n = AMAP_BYTE_OFFSET(MCC_WRB, payload);
+	n = offsetof(struct BE_MCC_WRB_AMAP, payload)/8;
 	AMAP_SET_BITS_PTR(MCC_WRB, embedded, wrb, 1);
 	AMAP_SET_BITS_PTR(MCC_WRB, payload_length, wrb, min(payld_len, n));
 	header = (struct FWCMD_REQUEST_HEADER *)((u8 *)wrb + n);
@@ -250,7 +250,7 @@ be_function_prepare_nonembedded_fwcmd(st
 	 */
 	AMAP_SET_BITS_PTR(MCC_WRB, sge_count, wrb, 1);
 
-	n = AMAP_BYTE_OFFSET(MCC_WRB, payload);
+	n = offsetof(struct BE_MCC_WRB_AMAP, payload)/8;
 	plp = (struct MCC_WRB_PAYLOAD_AMAP *)((u8 *)wrb + n);
 	AMAP_SET_BITS_PTR(MCC_WRB_PAYLOAD, sgl[0].length, plp, payld_len);
 	AMAP_SET_BITS_PTR(MCC_WRB_PAYLOAD, sgl[0].pa_lo, plp, (u32)fwcmd_pa);
@@ -275,7 +275,7 @@ be_function_peek_mcc_wrb(struct be_funct
 	if (pfob->mcc)
 		wrb = _be_mpu_peek_ring_wrb(pfob->mcc, false);
 	else {
-		offset = AMAP_BYTE_OFFSET(MCC_MAILBOX, wrb);
+		offset = offsetof(struct BE_MCC_MAILBOX_AMAP, wrb)/8;
 		wrb = (struct MCC_WRB_AMAP *) ((u8 *) pfob->mailbox.va +
 				offset);
 	}
@@ -299,7 +299,7 @@ void be_function_debug_print_wrb(struct 
 	embedded = AMAP_GET_BITS_PTR(MCC_WRB, embedded, wrb);
 
 	if (embedded) {
-		n = AMAP_BYTE_OFFSET(MCC_WRB, payload);
+		n = offsetof(struct BE_MCC_WRB_AMAP, payload)/8;
 		header = (struct FWCMD_REQUEST_HEADER *)((u8 *)wrb + n);
 	} else {
 		header = (struct FWCMD_REQUEST_HEADER *) optional_fwcmd_va;
@@ -381,7 +381,7 @@ be_function_post_mcc_wrb(struct be_funct
 	 * Copy the context pointer into the WRB opaque tag field.
 	 * Verify assumption of 64-bit tag with a compile time assert.
 	 */
-	p = (u64 *) ((u8 *)wrb + AMAP_BYTE_OFFSET(MCC_WRB, tag));
+	p = (u64 *) ((u8 *)wrb + offsetof(struct BE_MCC_WRB_AMAP, tag)/8);
 	*p = (u64)(size_t)wrb_context;
 
 	/* Print info about this FWCMD for debug builds. */
--- a/drivers/staging/benet/hwlib.h
+++ b/drivers/staging/benet/hwlib.h
@@ -38,37 +38,29 @@
  * Macros for reading/writing a protection domain or CSR registers
  * in BladeEngine.
  */
-#define PD_READ(_fo_, _field_)     				\
-	ioread32((_fo_)->db_va + 				\
-		AMAP_BYTE_OFFSET(PROTECTION_DOMAIN_DBMAP, _field_))
-
-#define PD_WRITE(_fo_, _field_, _value_)			\
-	iowrite32((_value_), (_fo_)->db_va + 			\
-		AMAP_BYTE_OFFSET(PROTECTION_DOMAIN_DBMAP, _field_))
-
-#define CSR_READ(_fo_, _field_)				\
-	ioread32((_fo_)->csr_va +			\
-		AMAP_BYTE_OFFSET(BLADE_ENGINE_CSRMAP, _field_))
-
-#define CSR_WRITE(_fo_, _field_, _value_)			\
-	iowrite32((_value_), (_fo_)->csr_va +			\
-		AMAP_BYTE_OFFSET(BLADE_ENGINE_CSRMAP, _field_))
-
-#define PCICFG0_READ(_fo_, _field_)				\
-	ioread32((_fo_)->pci_va +				\
-		AMAP_BYTE_OFFSET(PCICFG0_CSRMAP, _field_))
-
-#define PCICFG0_WRITE(_fo_, _field_, _value_)			\
-	iowrite32((_value_), (_fo_)->pci_va +			\
-		AMAP_BYTE_OFFSET(PCICFG0_CSRMAP, _field_))
-
-#define PCICFG1_READ(_fo_, _field_)				\
-	ioread32((_fo_)->pci_va +				\
-		AMAP_BYTE_OFFSET(PCICFG1_CSRMAP, _field_))
-
-#define PCICFG1_WRITE(_fo_, _field_, _value_)			\
-	iowrite32((_value_), (_fo_)->pci_va +			\
-		AMAP_BYTE_OFFSET(PCICFG1_CSRMAP, _field_))
+#define PD_READ(fo, field)	ioread32((fo)->db_va + \
+					offsetof(struct BE_PROTECTION_DOMAIN_DBMAP_AMAP, field)/8)
+
+#define PD_WRITE(fo, field, val) iowrite32(val, (fo)->db_va + \
+					offsetof(struct BE_PROTECTION_DOMAIN_DBMAP_AMAP, field)/8)
+
+#define CSR_READ(fo, field)		ioread32((fo)->csr_va + \
+					offsetof(struct BE_BLADE_ENGINE_CSRMAP_AMAP, field)/8)
+
+#define CSR_WRITE(fo, field, val)	iowrite32(val, (fo)->csr_va +	\
+					offsetof(struct BE_BLADE_ENGINE_CSRMAP_AMAP, field)/8)
+
+#define PCICFG0_READ(fo, field)	ioread32((fo)->pci_va + \
+					offsetof(struct BE_PCICFG0_CSRMAP_AMAP, field)/8)
+
+#define PCICFG0_WRITE(fo, field, val)	iowrite32(val, (fo)->pci_va +	\
+					offsetof(struct BE_PCICFG0_CSRMAP_AMAP, field)/8)
+
+#define PCICFG1_READ(fo, field)		ioread32((fo)->pci_va + \
+					offsetof(struct BE_PCICFG1_CSRMAP_AMAP, field)/8)
+
+#define PCICFG1_WRITE(fo, field, val)	iowrite32(val, (fo)->pci_va +	\
+					offsetof(struct BE_PCICFG1_CSRMAP_AMAP, field)/8)
 
 #ifdef BE_DEBUG
 #define ASSERT(c)       BUG_ON(!(c));
@@ -185,8 +177,8 @@ static inline u32 amap_mask(u32 bit_size
     return (bit_size == 32 ? 0xFFFFFFFF : (1 << bit_size) - 1);
 }
 
-#define AMAP_BIT_MASK(_struct_, _register_)       \
-	amap_mask(AMAP_BIT_SIZE(_struct_, _register_))
+#define AMAP_BIT_MASK(_struct_, field)       \
+	amap_mask(AMAP_BIT_SIZE(_struct_, field))
 
 /*
  * non-optimized set bits function. First clears the bits and then assigns them.
@@ -201,10 +193,9 @@ amap_set(void *ptr, u32 dw_offset, u32 m
 	*(dw + dw_offset) |= (mask & value) << offset;
 }
 
-#define AMAP_SET_BITS_PTR(_struct_, _register_, _structPtr_, _value_)	\
-	amap_set(_structPtr_, AMAP_WORD_OFFSET(_struct_, _register_),	\
-		AMAP_BIT_MASK(_struct_, _register_),			\
-		AMAP_BIT_OFFSET(_struct_, _register_), _value_)
+#define AMAP_SET_BITS_PTR(_struct_, field, _structPtr_, val)	\
+	amap_set(_structPtr_, AMAP_WORD_OFFSET(_struct_, field),	\
+		AMAP_BIT_MASK(_struct_, field),	AMAP_BIT_OFFSET(_struct_, field), val)
 
 /*
  * Non-optimized routine that gets the bits without knowing the correct DWORD.
@@ -216,39 +207,21 @@ amap_get(void *ptr, u32 dw_offset, u32 m
 	u32 *dw = (u32 *)ptr;
 	return mask & (*(dw + dw_offset) >> offset);
 }
-#define AMAP_GET_BITS_PTR(_struct_, _register_, _structPtr_)		\
-	amap_get(_structPtr_, AMAP_WORD_OFFSET(_struct_, _register_),	\
-		AMAP_BIT_MASK(_struct_, _register_),			\
-			AMAP_BIT_OFFSET(_struct_, _register_))
+#define AMAP_GET_BITS_PTR(_struct_, field, _structPtr_)		\
+	amap_get(_structPtr_, AMAP_WORD_OFFSET(_struct_, field),	\
+		AMAP_BIT_MASK(_struct_, field),	AMAP_BIT_OFFSET(_struct_, field))
 
 /* Returns 0-31 representing bit offset within a DWORD of a bitfield. */
-#define AMAP_BIT_OFFSET(_struct_, _register_)                  \
-    (((size_t)&(((struct BE_ ## _struct_ ## _AMAP*)0)->_register_))%32)
-
-/* Returns 0-n representing byte offset of bitfield with the structure. */
-#define AMAP_BYTE_OFFSET(_struct_, _register_)                  \
-	(((size_t)&(((struct BE_ ## _struct_ ## _AMAP *)0)->_register_))/8)
+#define AMAP_BIT_OFFSET(_struct_, field)                  \
+    (offsetof(struct BE_ ## _struct_ ## _AMAP, field) % 32)
 
 /* Returns 0-n representing DWORD offset of bitfield within the structure. */
-#define AMAP_WORD_OFFSET(_struct_, _register_)  \
-		  (AMAP_BYTE_OFFSET(_struct_, _register_)/4)
-
-/*
- * Gets a pointer to a field within a structure
- * The field must be byte aligned.
- */
-#define AMAP_GET_PTR(_struct_, _register_, _structPtr_)                     \
-    (void *) ((u8 *)(_structPtr_) + AMAP_BYTE_OFFSET(_struct_, _register_))
+#define AMAP_WORD_OFFSET(_struct_, field)  \
+		  (offsetof(struct BE_ ## _struct_ ## _AMAP, field)/32)
 
 /* Returns size of bitfield in bits. */
-#define AMAP_BIT_SIZE(_struct_, _register_) \
-		sizeof(((struct BE_ ## _struct_ ## _AMAP*)0)->_register_)
-
-/* Returns size of bitfield in bytes. */
-#define AMAP_BYTE_SIZE(_struct_) (sizeof(struct BE_ ## _struct_ ## _AMAP)/8)
-
-/* Returns size of bitfield in DWORDS. */
-#define AMAP_WORD_SIZE(_struct_) (AMAP_BYTE_SIZE(_struct_)/4)
+#define AMAP_BIT_SIZE(_struct_, field) \
+		sizeof(((struct BE_ ## _struct_ ## _AMAP*)0)->field)
 
 struct be_mcc_wrb_response_copy {
 	u16 length;		/* bytes in response */
@@ -475,7 +448,7 @@ struct be_queue_driver_context {
  * Common MCC WRB header that all commands require.
  */
 struct be_mcc_wrb_header {
-	u8 rsvd[AMAP_BYTE_OFFSET(MCC_WRB, payload)];
+	u8 rsvd[offsetof(struct BE_MCC_WRB_AMAP, payload)/8];
 } ;
 
 /*
--- a/drivers/staging/benet/mpu.c
+++ b/drivers/staging/benet/mpu.c
@@ -241,11 +241,11 @@ be_mcc_process_cqe(struct be_function_ob
 	 * A command completed.  Commands complete out-of-order.
 	 * Determine which command completed from the TAG.
 	 */
-	offset = AMAP_BYTE_OFFSET(MCC_CQ_ENTRY, mcc_tag);
+	offset = offsetof(struct BE_MCC_CQ_ENTRY_AMAP, mcc_tag)/8;
 	p = (u8 *) cqe + offset;
 	wrb_context = (struct be_mcc_wrb_context *)(void *)(size_t)(*(u64 *)p);
-
 	ASSERT(wrb_context);
+
 	/*
 	 * Perform a response copy if requested.
 	 * Only copy data if the FWCMD is successful.
@@ -254,7 +254,8 @@ be_mcc_process_cqe(struct be_function_ob
 	if (status == MGMT_STATUS_SUCCESS && wrb_context->copy.length > 0) {
 		ASSERT(wrb_context->wrb);
 		ASSERT(wrb_context->copy.va);
-		p = (u8 *)wrb_context->wrb + AMAP_BYTE_OFFSET(MCC_WRB, payload);
+		p = (u8 *)wrb_context->wrb +
+				offsetof(struct BE_MCC_WRB_AMAP, payload)/8;
 		memcpy(wrb_context->copy.va,
 			  (u8 *)p + wrb_context->copy.fwcmd_offset,
 			  wrb_context->copy.length);
@@ -411,7 +412,7 @@ u32 be_mcc_wrb_consumed_in_order(struct 
 	 * A command completed.  Commands complete out-of-order.
 	 * Determine which command completed from the TAG.
 	 */
-	offset = AMAP_BYTE_OFFSET(MCC_CQ_ENTRY, mcc_tag);
+	offset = offsetof(struct BE_MCC_CQ_ENTRY_AMAP, mcc_tag)/8;
 	p = (u8 *) cqe + offset;
 	wrb_context = (struct be_mcc_wrb_context *)(void *)(size_t)(*(u64 *)p);
 
@@ -941,7 +942,7 @@ be_mpu_init_mailbox(struct be_function_o
 	 */
 	{
 		u64 *endian_check = (u64 *) (pfob->mailbox.va +
-					AMAP_BYTE_OFFSET(MCC_MAILBOX, wrb));
+					offsetof(struct BE_MCC_MAILBOX_AMAP, wrb)/8);
 		*endian_check = 0xFF1234FFFF5678FFULL;
 	}
 
@@ -983,7 +984,7 @@ _be_mpu_post_wrb_mailbox(struct be_funct
 	mailbox = pfob->mailbox.va;
 	ASSERT(mailbox);
 
-	offset = AMAP_BYTE_OFFSET(MCC_MAILBOX, wrb);
+	offset = offsetof(struct BE_MCC_MAILBOX_AMAP, wrb)/8;
 	mb_wrb = (struct MCC_WRB_AMAP *) (u8 *)mailbox + offset;
 	if (mb_wrb != wrb) {
 		memset(mailbox, 0, sizeof(*mailbox));
@@ -995,7 +996,7 @@ _be_mpu_post_wrb_mailbox(struct be_funct
 	be_mcc_mailbox_notify_and_wait(pfob);
 
 	/* A command completed.  Use tag to determine which command. */
-	offset = AMAP_BYTE_OFFSET(MCC_MAILBOX, cq);
+	offset = offsetof(struct BE_MCC_MAILBOX_AMAP, cq)/8;
 	mb_cq = (struct MCC_CQ_ENTRY_AMAP *) ((u8 *)mailbox + offset);
 	be_mcc_process_cqe(pfob, mb_cq);
 
