From wfp5p@virginia.edu Fri Mar 27 08:30:25 2009
From: Bill Pemberton <wfp5p@virginia.edu>
Date: Fri, 27 Mar 2009 11:30:23 -0400
Subject: Staging: comedi: remove C99 comments in adl_pci9118.c
To: greg@kroah.com
Cc: abbotti@mev.co.uk, fmhess@users.sourceforge.net, ds@schleef.org
Message-ID: <20090327153023.7154.83788.stgit@viridian.itc.Virginia.EDU>


Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/comedi/drivers/adl_pci9118.c |  450 +++++++++++++--------------
 1 file changed, 225 insertions(+), 225 deletions(-)

--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -107,7 +107,7 @@ Configuration options:
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
 #define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
 
-// bits from A/D control register (PCI9118_ADCNTRL)
+/* bits from A/D control register (PCI9118_ADCNTRL) */
 #define AdControl_UniP	0x80	/* 1=bipolar, 0=unipolar */
 #define AdControl_Diff	0x40	/* 1=differential, 0= single end inputs */
 #define AdControl_SoftG	0x20	/* 1=8254 counter works, 0=counter stops */
@@ -117,7 +117,7 @@ Configuration options:
 #define AdControl_Int	0x02	/* 1=enable INT, 0=disable */
 #define AdControl_Dma	0x01	/* 1=enable DMA, 0=disable */
 
-// bits from A/D function register (PCI9118_ADFUNC)
+/* bits from A/D function register (PCI9118_ADFUNC) */
 #define AdFunction_PDTrg	0x80	/* 1=positive, 0=negative digital trigger (only positive is correct) */
 #define AdFunction_PETrg	0x40	/* 1=positive, 0=negative external trigger (only positive is correct) */
 #define AdFunction_BSSH		0x20	/* 1=with sample&hold, 0=without */
@@ -127,7 +127,7 @@ Configuration options:
 #define AdFunction_AM		0x02	/* 1=about trigger mode, 0=not about trigger */
 #define AdFunction_Start	0x01	/* 1=trigger start, 0=trigger stop */
 
-// bits from A/D status register (PCI9118_ADSTAT)
+/* bits from A/D status register (PCI9118_ADSTAT) */
 #define AdStatus_nFull	0x100	/* 0=FIFO full (fatal), 1=not full */
 #define AdStatus_nHfull	0x080	/* 0=FIFO half full, 1=FIFO not half full */
 #define AdStatus_nEpty	0x040	/* 0=FIFO empty, 1=FIFO not empty */
@@ -138,8 +138,8 @@ Configuration options:
 #define AdStatus_ADOR	0x002	/* 1=A/D overrun (fatal) */
 #define AdStatus_ADrdy	0x001	/* 1=A/D already ready, 0=not ready */
 
-// bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL)
-// 1=interrupt occur, enable source,  0=interrupt not occur, disable source
+/* bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL) */
+/* 1=interrupt occur, enable source,  0=interrupt not occur, disable source */
 #define Int_Timer	0x08	/* timer interrupt */
 #define Int_About	0x04	/* about trigger complete */
 #define Int_Hfull	0x02	/* A/D FIFO hlaf full */
@@ -182,23 +182,23 @@ static int pci9118_attach(struct comedi_
 static int pci9118_detach(struct comedi_device * dev);
 
 struct boardtype {
-	const char *name;	// board name
-	int vendor_id;		// PCI vendor a device ID of card
+	const char *name;	/*  board name */
+	int vendor_id;		/*  PCI vendor a device ID of card */
 	int device_id;
-	int iorange_amcc;	// iorange for own S5933 region
-	int iorange_9118;	// pass thru card region size
-	int n_aichan;		// num of A/D chans
-	int n_aichand;		// num of A/D chans in diff mode
-	int mux_aichan;		// num of A/D chans with external multiplexor
-	int n_aichanlist;	// len of chanlist
-	int n_aochan;		// num of D/A chans
-	int ai_maxdata;		// resolution of A/D
-	int ao_maxdata;		// resolution of D/A
-	const struct comedi_lrange *rangelist_ai;	// rangelist for A/D
-	const struct comedi_lrange *rangelist_ao;	// rangelist for D/A
-	unsigned int ai_ns_min;	// max sample speed of card v ns
-	unsigned int ai_pacer_min;	// minimal pacer value (c1*c2 or c1 in burst)
-	int half_fifo_size;	// size of FIFO/2
+	int iorange_amcc;	/*  iorange for own S5933 region */
+	int iorange_9118;	/*  pass thru card region size */
+	int n_aichan;		/*  num of A/D chans */
+	int n_aichand;		/*  num of A/D chans in diff mode */
+	int mux_aichan;		/*  num of A/D chans with external multiplexor */
+	int n_aichanlist;	/*  len of chanlist */
+	int n_aochan;		/*  num of D/A chans */
+	int ai_maxdata;		/*  resolution of A/D */
+	int ao_maxdata;		/*  resolution of D/A */
+	const struct comedi_lrange *rangelist_ai;	/*  rangelist for A/D */
+	const struct comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
+	unsigned int ai_ns_min;	/*  max sample speed of card v ns */
+	unsigned int ai_pacer_min;	/*  minimal pacer value (c1*c2 or c1 in burst) */
+	int half_fifo_size;	/*  size of FIFO/2 */
 
 };
 
@@ -242,63 +242,63 @@ static struct comedi_driver driver_pci91
 COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);
 
 struct pci9118_private {
-	unsigned long iobase_a;	// base+size for AMCC chip
-	unsigned int master;	// master capable
-	struct pci_dev *pcidev;	// ptr to actual pcidev
-	unsigned int usemux;	// we want to use external multiplexor!
+	unsigned long iobase_a;	/*  base+size for AMCC chip */
+	unsigned int master;	/*  master capable */
+	struct pci_dev *pcidev;	/*  ptr to actual pcidev */
+	unsigned int usemux;	/*  we want to use external multiplexor! */
 #ifdef PCI9118_PARANOIDCHECK
-	unsigned short chanlist[PCI9118_CHANLEN + 1];	// list of scaned channel
-	unsigned char chanlistlen;	// number of scanlist
+	unsigned short chanlist[PCI9118_CHANLEN + 1];	/*  list of scaned channel */
+	unsigned char chanlistlen;	/*  number of scanlist */
 #endif
-	unsigned char AdControlReg;	// A/D control register
-	unsigned char IntControlReg;	// Interrupt control register
-	unsigned char AdFunctionReg;	// A/D function register
-	char valid;		// driver is ok
-	char ai_neverending;	// we do unlimited AI
-	unsigned int i8254_osc_base;	// frequence of onboard oscilator
-	unsigned int ai_do;	// what do AI? 0=nothing, 1 to 4 mode
-	unsigned int ai_act_scan;	// how many scans we finished
-	unsigned int ai_buf_ptr;	// data buffer ptr in samples
-	unsigned int ai_n_chan;	// how many channels is measured
-	unsigned int ai_n_scanlen;	// len of actual scanlist
-	unsigned int ai_n_realscanlen;	// what we must transfer for one outgoing scan include front/back adds
-	unsigned int ai_act_dmapos;	// position in actual real stream
-	unsigned int ai_add_front;	// how many channels we must add before scan to satisfy S&H?
-	unsigned int ai_add_back;	// how many channels we must add before scan to satisfy DMA?
-	unsigned int *ai_chanlist;	// actaul chanlist
+	unsigned char AdControlReg;	/*  A/D control register */
+	unsigned char IntControlReg;	/*  Interrupt control register */
+	unsigned char AdFunctionReg;	/*  A/D function register */
+	char valid;		/*  driver is ok */
+	char ai_neverending;	/*  we do unlimited AI */
+	unsigned int i8254_osc_base;	/*  frequence of onboard oscilator */
+	unsigned int ai_do;	/*  what do AI? 0=nothing, 1 to 4 mode */
+	unsigned int ai_act_scan;	/*  how many scans we finished */
+	unsigned int ai_buf_ptr;	/*  data buffer ptr in samples */
+	unsigned int ai_n_chan;	/*  how many channels is measured */
+	unsigned int ai_n_scanlen;	/*  len of actual scanlist */
+	unsigned int ai_n_realscanlen;	/*  what we must transfer for one outgoing scan include front/back adds */
+	unsigned int ai_act_dmapos;	/*  position in actual real stream */
+	unsigned int ai_add_front;	/*  how many channels we must add before scan to satisfy S&H? */
+	unsigned int ai_add_back;	/*  how many channels we must add before scan to satisfy DMA? */
+	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_timer1;
 	unsigned int ai_timer2;
 	unsigned int ai_flags;
-	char ai12_startstop;	// measure can start/stop on external trigger
-	unsigned int ai_divisor1, ai_divisor2;	// divisors for start of measure on external start
+	char ai12_startstop;	/*  measure can start/stop on external trigger */
+	unsigned int ai_divisor1, ai_divisor2;	/*  divisors for start of measure on external start */
 	unsigned int ai_data_len;
 	short *ai_data;
-	short ao_data[2];	// data output buffer
-	unsigned int ai_scans;	// number of scans to do
-	char dma_doublebuf;	// we can use double buffring
-	unsigned int dma_actbuf;	// which buffer is used now
-	short *dmabuf_virt[2];	// pointers to begin of DMA buffer
-	unsigned long dmabuf_hw[2];	// hw address of DMA buff
-	unsigned int dmabuf_size[2];	// size of dma buffer in bytes
-	unsigned int dmabuf_use_size[2];	// which size we may now used for transfer
-	unsigned int dmabuf_used_size[2];	// which size was trully used
+	short ao_data[2];	/*  data output buffer */
+	unsigned int ai_scans;	/*  number of scans to do */
+	char dma_doublebuf;	/*  we can use double buffring */
+	unsigned int dma_actbuf;	/*  which buffer is used now */
+	short *dmabuf_virt[2];	/*  pointers to begin of DMA buffer */
+	unsigned long dmabuf_hw[2];	/*  hw address of DMA buff */
+	unsigned int dmabuf_size[2];	/*  size of dma buffer in bytes */
+	unsigned int dmabuf_use_size[2];	/*  which size we may now used for transfer */
+	unsigned int dmabuf_used_size[2];	/*  which size was trully used */
 	unsigned int dmabuf_panic_size[2];
-	unsigned int dmabuf_samples[2];	// size in samples
-	int dmabuf_pages[2];	// number of pages in buffer
-	unsigned char cnt0_users;	// bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO)
-	unsigned char exttrg_users;	// bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO)
-	unsigned int cnt0_divisor;	// actual CNT0 divisor
-	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *, unsigned short, unsigned int, unsigned short);	// ptr to actual interrupt AI function
-	unsigned char ai16bits;	// =1 16 bit card
-	unsigned char usedma;	// =1 use DMA transfer and not INT
-	unsigned char useeoshandle;	// =1 change WAKE_EOS DMA transfer to fit on every second
-	unsigned char usessh;	// =1 turn on S&H support
-	int softsshdelay;	// >0 use software S&H, numer is requested delay in ns
-	unsigned char softsshsample;	// polarity of S&H signal in sample state
-	unsigned char softsshhold;	// polarity of S&H signal in hold state
-	unsigned int ai_maskerr;	// which warning was printed
-	unsigned int ai_maskharderr;	// on which error bits stops
-	unsigned int ai_inttrig_start;	// TRIG_INT for start
+	unsigned int dmabuf_samples[2];	/*  size in samples */
+	int dmabuf_pages[2];	/*  number of pages in buffer */
+	unsigned char cnt0_users;	/*  bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO) */
+	unsigned char exttrg_users;	/*  bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO) */
+	unsigned int cnt0_divisor;	/*  actual CNT0 divisor */
+	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *, unsigned short, unsigned int, unsigned short);	/*  ptr to actual interrupt AI function */
+	unsigned char ai16bits;	/*  =1 16 bit card */
+	unsigned char usedma;	/*  =1 use DMA transfer and not INT */
+	unsigned char useeoshandle;	/*  =1 change WAKE_EOS DMA transfer to fit on every second */
+	unsigned char usessh;	/*  =1 turn on S&H support */
+	int softsshdelay;	/*  >0 use software S&H, numer is requested delay in ns */
+	unsigned char softsshsample;	/*  polarity of S&H signal in sample state */
+	unsigned char softsshhold;	/*  polarity of S&H signal in hold state */
+	unsigned int ai_maskerr;	/*  which warning was printed */
+	unsigned int ai_maskharderr;	/*  on which error bits stops */
+	unsigned int ai_inttrig_start;	/*  TRIG_INT for start */
 };
 
 #define devpriv ((struct pci9118_private *)dev->private)
@@ -335,12 +335,12 @@ static int pci9118_insn_read_ai(struct c
 
 	devpriv->AdControlReg = AdControl_Int & 0xff;
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 
 	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0, 0))
 		return -EINVAL;
 
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 
 	for (n = 0; n < insn->n; n++) {
 		outw(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
@@ -354,7 +354,7 @@ static int pci9118_insn_read_ai(struct c
 
 		comedi_error(dev, "A/D insn timeout");
 		data[n] = 0;
-		outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+		outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 		return -ETIME;
 
 	      conv_finish:
@@ -369,7 +369,7 @@ static int pci9118_insn_read_ai(struct c
 		}
 	}
 
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 	return n;
 
 }
@@ -567,7 +567,7 @@ static void interrupt_pci9118_ai_onesamp
 
 #ifdef PCI9118_PARANOIDCHECK
 	if (devpriv->ai16bits == 0) {
-		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	// data dropout!
+		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	/*  data dropout! */
 			rt_printk
 				("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
 				sampl & 0x000f,
@@ -621,14 +621,14 @@ static void interrupt_pci9118_ai_dma(str
 	}
 
 	if (int_adstat & devpriv->ai_maskerr)
-//      if (int_adstat & 0x106)
+/* if (int_adstat & 0x106) */
 		if (pci9118_decode_error_status(dev, s, int_adstat))
 			return;
 
-	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;	// number of received real samples
-//      DPRINTK("dma_actbuf=%d\n",devpriv->dma_actbuf);
+	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;	/*  number of received real samples */
+/* DPRINTK("dma_actbuf=%d\n",devpriv->dma_actbuf); */
 
-	if (devpriv->dma_doublebuf) {	// switch DMA buffers if is used double buffering
+	if (devpriv->dma_doublebuf) {	/*  switch DMA buffers if is used double buffering */
 		next_dma_buf = 1 - devpriv->dma_actbuf;
 		outl(devpriv->dmabuf_hw[next_dma_buf],
 			devpriv->iobase_a + AMCC_OP_REG_MWAR);
@@ -641,15 +641,15 @@ static void interrupt_pci9118_ai_dma(str
 	}
 
 	if (samplesinbuf) {
-		m = devpriv->ai_data_len >> 1;	// how many samples is to end of buffer
-//              DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr);
+		m = devpriv->ai_data_len >> 1;	/*  how many samples is to end of buffer */
+/* DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr); */
 		sampls = m;
 		move_block_from_dma(dev, s,
 			devpriv->dmabuf_virt[devpriv->dma_actbuf],
 			samplesinbuf);
-		m = m - sampls;	// m= how many samples was transfered
+		m = m - sampls;	/*  m= how many samples was transfered */
 	}
-//      DPRINTK("YYY\n");
+/* DPRINTK("YYY\n"); */
 
 	if (!devpriv->ai_neverending)
 		if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/* all data sampled */
@@ -657,9 +657,9 @@ static void interrupt_pci9118_ai_dma(str
 			s->async->events |= COMEDI_CB_EOA;
 		}
 
-	if (devpriv->dma_doublebuf) {	// switch dma buffers
+	if (devpriv->dma_doublebuf) {	/*  switch dma buffers */
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
-	} else {		// restart DMA if is not used double buffering
+	} else {		/*  restart DMA if is not used double buffering */
 		outl(devpriv->dmabuf_hw[0],
 			devpriv->iobase_a + AMCC_OP_REG_MWAR);
 		outl(devpriv->dmabuf_use_size[0],
@@ -680,30 +680,30 @@ static irqreturn_t interrupt_pci9118(int
 	unsigned int int_daq = 0, int_amcc, int_adstat;
 
 	if (!dev->attached)
-		return IRQ_NONE;	// not fully initialized
+		return IRQ_NONE;	/*  not fully initialized */
 
-	int_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;	// get IRQ reasons from card
-	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// get INT register from AMCC chip
+	int_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;	/*  get IRQ reasons from card */
+	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  get INT register from AMCC chip */
 
-//      DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n", int_daq, int_amcc, inl(devpriv->iobase_a+AMCC_OP_REG_MWAR), inl(devpriv->iobase_a+AMCC_OP_REG_MWTC), inw(dev->iobase+PCI9118_ADSTAT)&0x1ff,devpriv->ai_do);
+/* DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n", int_daq, int_amcc, inl(devpriv->iobase_a+AMCC_OP_REG_MWAR), inl(devpriv->iobase_a+AMCC_OP_REG_MWTC), inw(dev->iobase+PCI9118_ADSTAT)&0x1ff,devpriv->ai_do); */
 
 	if ((!int_daq) && (!(int_amcc & ANY_S593X_INT)))
-		return IRQ_NONE;	// interrupt from other source
+		return IRQ_NONE;	/*  interrupt from other source */
 
-	outl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// shutdown IRQ reasons in AMCC
+	outl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  shutdown IRQ reasons in AMCC */
 
-	int_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;	// get STATUS register
+	int_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;	/*  get STATUS register */
 
 	if (devpriv->ai_do) {
 		if (devpriv->ai12_startstop)
-			if ((int_adstat & AdStatus_DTH) && (int_daq & Int_DTrg)) {	// start stop of measure
+			if ((int_adstat & AdStatus_DTH) && (int_daq & Int_DTrg)) {	/*  start stop of measure */
 				if (devpriv->ai12_startstop & START_AI_EXT) {
 					devpriv->ai12_startstop &=
 						~START_AI_EXT;
 					if (!(devpriv->ai12_startstop &
 							STOP_AI_EXT))
-						pci9118_exttrg_del(dev, EXTTRG_AI);	// deactivate EXT trigger
-					start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1, devpriv->ai_divisor2);	// start pacer
+						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
+					start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1, devpriv->ai_divisor2);	/*  start pacer */
 					outl(devpriv->AdControlReg,
 						dev->iobase + PCI9118_ADCNTRL);
 				} else {
@@ -711,8 +711,8 @@ static irqreturn_t interrupt_pci9118(int
 						ai12_startstop & STOP_AI_EXT) {
 						devpriv->ai12_startstop &=
 							~STOP_AI_EXT;
-						pci9118_exttrg_del(dev, EXTTRG_AI);	// deactivate EXT trigger
-						devpriv->ai_neverending = 0;	//well, on next interrupt from DMA/EOC measure will stop
+						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
+						devpriv->ai_neverending = 0;	/* well, on next interrupt from DMA/EOC measure will stop */
 					}
 				}
 			}
@@ -949,11 +949,11 @@ static int pci9118_ai_cmdtest(struct com
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-//              rt_printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->scan_begin_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-//              rt_printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
 			cmd->scan_begin_arg = this_board->ai_ns_min;
 		if (tmp != cmd->scan_begin_arg)
@@ -965,7 +965,7 @@ static int pci9118_ai_cmdtest(struct com
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->convert_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-//              rt_printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -979,7 +979,7 @@ static int pci9118_ai_cmdtest(struct com
 					cmd->scan_begin_arg =
 						this_board->ai_ns_min *
 						(cmd->scan_end_arg + 2);
-//              rt_printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			} else {
@@ -988,7 +988,7 @@ static int pci9118_ai_cmdtest(struct com
 					cmd->scan_begin_arg =
 						cmd->convert_arg *
 						cmd->chanlist_len;
-//              rt_printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			}
@@ -1001,7 +1001,7 @@ static int pci9118_ai_cmdtest(struct com
 	if (cmd->chanlist)
 		if (!check_channel_list(dev, s, cmd->chanlist_len,
 				cmd->chanlist, 0, 0))
-			return 5;	// incorrect channels list
+			return 5;	/*  incorrect channels list */
 
 	return 0;
 }
@@ -1018,26 +1018,26 @@ static int Compute_and_setup_dma(struct 
 	dmalen1 = devpriv->dmabuf_size[1];
 	DPRINTK("1 dmalen0=%d dmalen1=%d ai_data_len=%d\n", dmalen0, dmalen1,
 		devpriv->ai_data_len);
-	// isn't output buff smaller that our DMA buff?
+	/*  isn't output buff smaller that our DMA buff? */
 	if (dmalen0 > (devpriv->ai_data_len)) {
-		dmalen0 = devpriv->ai_data_len & ~3L;	// allign to 32bit down
+		dmalen0 = devpriv->ai_data_len & ~3L;	/*  allign to 32bit down */
 	}
 	if (dmalen1 > (devpriv->ai_data_len)) {
-		dmalen1 = devpriv->ai_data_len & ~3L;	// allign to 32bit down
+		dmalen1 = devpriv->ai_data_len & ~3L;	/*  allign to 32bit down */
 	}
 	DPRINTK("2 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
 
-	// we want wake up every scan?
+	/*  we want wake up every scan? */
 	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
 		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
-			// uff, too short DMA buffer, disable EOS support!
+			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			rt_printk
 				("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
 				dev->minor, dmalen0,
 				devpriv->ai_n_realscanlen << 1);
 		} else {
-			// short first DMA buffer to one scan
+			/*  short first DMA buffer to one scan */
 			dmalen0 = devpriv->ai_n_realscanlen << 1;
 			DPRINTK("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen0, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
@@ -1052,14 +1052,14 @@ static int Compute_and_setup_dma(struct 
 	}
 	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
 		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
-			// uff, too short DMA buffer, disable EOS support!
+			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			rt_printk
 				("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
 				dev->minor, dmalen1,
 				devpriv->ai_n_realscanlen << 1);
 		} else {
-			// short second DMA buffer to one scan
+			/*  short second DMA buffer to one scan */
 			dmalen1 = devpriv->ai_n_realscanlen << 1;
 			DPRINTK("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen1, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
@@ -1074,26 +1074,26 @@ static int Compute_and_setup_dma(struct 
 	}
 
 	DPRINTK("3 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
-	// transfer without TRIG_WAKE_EOS
+	/*  transfer without TRIG_WAKE_EOS */
 	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
-		// if it's possible then allign DMA buffers to length of scan
+		/*  if it's possible then allign DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
 			(dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
 			(devpriv->ai_n_realscanlen << 1);
 		dmalen0 &= ~3L;
 		if (!dmalen0)
-			dmalen0 = i;	// uff. very long scan?
+			dmalen0 = i;	/*  uff. very long scan? */
 		i = dmalen1;
 		dmalen1 =
 			(dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
 			(devpriv->ai_n_realscanlen << 1);
 		dmalen1 &= ~3L;
 		if (!dmalen1)
-			dmalen1 = i;	// uff. very long scan?
-		// if measure isn't neverending then test, if it whole fits into one or two DMA buffers
+			dmalen1 = i;	/*  uff. very long scan? */
+		/*  if measure isn't neverending then test, if it whole fits into one or two DMA buffers */
 		if (!devpriv->ai_neverending) {
-			// fits whole measure into one DMA buffer?
+			/*  fits whole measure into one DMA buffer? */
 			if (dmalen0 >
 				((devpriv->ai_n_realscanlen << 1) *
 					devpriv->ai_scans)) {
@@ -1104,7 +1104,7 @@ static int Compute_and_setup_dma(struct 
 				DPRINTK("3.1 dmalen0=%d dmalen1=%d \n", dmalen0,
 					dmalen1);
 				dmalen0 &= ~3L;
-			} else {	// fits whole measure into two DMA buffer?
+			} else {	/*  fits whole measure into two DMA buffer? */
 				if (dmalen1 >
 					((devpriv->ai_n_realscanlen << 1) *
 						devpriv->ai_scans - dmalen0))
@@ -1121,7 +1121,7 @@ static int Compute_and_setup_dma(struct 
 
 	DPRINTK("4 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
 
-	// these DMA buffer size we'll be used
+	/*  these DMA buffer size we'll be used */
 	devpriv->dma_actbuf = 0;
 	devpriv->dmabuf_use_size[0] = dmalen0;
 	devpriv->dmabuf_use_size[1] = dmalen1;
@@ -1143,18 +1143,18 @@ static int Compute_and_setup_dma(struct 
 	}
 #endif
 
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
 	outl(devpriv->dmabuf_hw[0], devpriv->iobase_a + AMCC_OP_REG_MWAR);
 	outl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);
-	// init DMA transfer
+	/*  init DMA transfer */
 	outl(0x00000000 | AINT_WRITE_COMPL,
 		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-//      outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR);
+/* outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR); */
 
 	outl(inl(devpriv->iobase_a +
 			AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
 		EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow bus mastering
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow bus mastering */
 
 	DPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");
 	return 0;
@@ -1186,17 +1186,17 @@ static int pci9118_ai_docmd_sampl(struct
 		return -EIO;
 	};
 
-	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;	//transfer function
+	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;	/* transfer function */
 
 	if (devpriv->ai12_startstop)
-		pci9118_exttrg_add(dev, EXTTRG_AI);	// activate EXT trigger
+		pci9118_exttrg_add(dev, EXTTRG_AI);	/*  activate EXT trigger */
 
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
 		devpriv->IntControlReg |= Int_Timer;
 
 	devpriv->AdControlReg |= AdControl_Int;
 
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
@@ -1261,10 +1261,10 @@ static int pci9118_ai_docmd_dma(struct c
 	};
 
 	if (devpriv->ai12_startstop) {
-		pci9118_exttrg_add(dev, EXTTRG_AI);	// activate EXT trigger
+		pci9118_exttrg_add(dev, EXTTRG_AI);	/*  activate EXT trigger */
 	}
 
-	devpriv->int_ai_func = interrupt_pci9118_ai_dma;	//transfer function
+	devpriv->int_ai_func = interrupt_pci9118_ai_dma;	/* transfer function */
 
 	outl(0x02000000 | AINT_WRITE_COMPL,
 		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
@@ -1307,7 +1307,7 @@ static int pci9118_ai_cmd(struct comedi_
 	devpriv->ai_add_back = 0;
 	devpriv->ai_maskerr = 0x10e;
 
-	// prepare for start/stop conditions
+	/*  prepare for start/stop conditions */
 	if (cmd->start_src == TRIG_EXT)
 		devpriv->ai12_startstop |= START_AI_EXT;
 	if (cmd->stop_src == TRIG_EXT) {
@@ -1334,19 +1334,19 @@ static int pci9118_ai_cmd(struct comedi_
 		devpriv->ai_scans = 0;
 	}
 
-	// use sample&hold signal?
+	/*  use sample&hold signal? */
 	if (cmd->convert_src == TRIG_NOW) {
 		devpriv->usessh = 1;
-	}			// yes
+	}			/*  yes */
 	else {
 		devpriv->usessh = 0;
-	}			// no
+	}			/*  no */
 
 	DPRINTK("1 neverending=%d scans=%u usessh=%d ai_startstop=0x%2x\n",
 		devpriv->ai_neverending, devpriv->ai_scans, devpriv->usessh,
 		devpriv->ai12_startstop);
 
-	// use additional sample at end of every scan to satisty DMA 32 bit transfer?
+	/*  use additional sample at end of every scan to satisty DMA 32 bit transfer? */
 	devpriv->ai_add_front = 0;
 	devpriv->ai_add_back = 0;
 	devpriv->useeoshandle = 0;
@@ -1358,27 +1358,27 @@ static int pci9118_ai_cmd(struct comedi_
 				devpriv->ai_add_back = 1;
 			}
 			if (cmd->convert_src == TRIG_TIMER) {
-				devpriv->usedma = 0;	// use INT transfer if scanlist have only one channel
+				devpriv->usedma = 0;	/*  use INT transfer if scanlist have only one channel */
 			}
 		}
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
 			(devpriv->ai_n_scanlen & 1) &&
 			(devpriv->ai_n_scanlen > 1)) {
 			if (cmd->scan_begin_src == TRIG_FOLLOW) {
-				//vpriv->useeoshandle=1; // change DMA transfer block to fit EOS on every second call
-				devpriv->usedma = 0;	// XXX maybe can be corrected to use 16 bit DMA
-			} else {	// well, we must insert one sample to end of EOS to meet 32 bit transfer
+				/* vpriv->useeoshandle=1; // change DMA transfer block to fit EOS on every second call */
+				devpriv->usedma = 0;	/*  XXX maybe can be corrected to use 16 bit DMA */
+			} else {	/*  well, we must insert one sample to end of EOS to meet 32 bit transfer */
 				devpriv->ai_add_back = 1;
 			}
 		}
-	} else {		// interrupt transfer don't need any correction
+	} else {		/*  interrupt transfer don't need any correction */
 		devpriv->usedma = 0;
 	}
 
-	// we need software S&H signal? It add  two samples before every scan as minimum
+	/*  we need software S&H signal? It add  two samples before every scan as minimum */
 	if (devpriv->usessh && devpriv->softsshdelay) {
 		devpriv->ai_add_front = 2;
-		if ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {	// move it to front
+		if ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {	/*  move it to front */
 			devpriv->ai_add_front++;
 			devpriv->ai_add_back = 0;
 		}
@@ -1387,17 +1387,17 @@ static int pci9118_ai_cmd(struct comedi_
 		addchans = devpriv->softsshdelay / cmd->convert_arg;
 		if (devpriv->softsshdelay % cmd->convert_arg)
 			addchans++;
-		if (addchans > (devpriv->ai_add_front - 1)) {	// uff, still short :-(
+		if (addchans > (devpriv->ai_add_front - 1)) {	/*  uff, still short :-( */
 			devpriv->ai_add_front = addchans + 1;
 			if (devpriv->usedma == 1)
 				if ((devpriv->ai_add_front +
 						devpriv->ai_n_chan +
 						devpriv->ai_add_back) & 1)
-					devpriv->ai_add_front++;	// round up to 32 bit
+					devpriv->ai_add_front++;	/*  round up to 32 bit */
 		}
-	}			// well, we now know what must be all added
+	}			/*  well, we now know what must be all added */
 
-	devpriv->ai_n_realscanlen =	// what we must take from card in real to have ai_n_scanlen on output?
+	devpriv->ai_n_realscanlen =	/*  what we must take from card in real to have ai_n_scanlen on output? */
 		(devpriv->ai_add_front + devpriv->ai_n_chan +
 		devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
 		devpriv->ai_n_chan);
@@ -1408,7 +1408,7 @@ static int pci9118_ai_cmd(struct comedi_
 		devpriv->ai_n_chan, devpriv->ai_add_back,
 		devpriv->ai_n_scanlen);
 
-	// check and setup channel list
+	/*  check and setup channel list */
 	if (!check_channel_list(dev, s, devpriv->ai_n_chan,
 			devpriv->ai_chanlist, devpriv->ai_add_front,
 			devpriv->ai_add_back))
@@ -1419,9 +1419,9 @@ static int pci9118_ai_cmd(struct comedi_
 			devpriv->useeoshandle))
 		return -EINVAL;
 
-	// compute timers settings
-	// simplest way, fr=4Mhz/(tim1*tim2), channel manipulation without timers effect
-	if (((cmd->scan_begin_src == TRIG_FOLLOW) || (cmd->scan_begin_src == TRIG_EXT) || (cmd->scan_begin_src == TRIG_INT)) && (cmd->convert_src == TRIG_TIMER)) {	// both timer is used for one time
+	/*  compute timers settings */
+	/*  simplest way, fr=4Mhz/(tim1*tim2), channel manipulation without timers effect */
+	if (((cmd->scan_begin_src == TRIG_FOLLOW) || (cmd->scan_begin_src == TRIG_EXT) || (cmd->scan_begin_src == TRIG_INT)) && (cmd->convert_src == TRIG_TIMER)) {	/*  both timer is used for one time */
 		if (cmd->scan_begin_src == TRIG_EXT) {
 			devpriv->ai_do = 4;
 		} else {
@@ -1435,7 +1435,7 @@ static int pci9118_ai_cmd(struct comedi_
 		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
-	if ((cmd->scan_begin_src == TRIG_TIMER) && ((cmd->convert_src == TRIG_TIMER) || (cmd->convert_src == TRIG_NOW))) {	// double timed action
+	if ((cmd->scan_begin_src == TRIG_TIMER) && ((cmd->convert_src == TRIG_TIMER) || (cmd->convert_src == TRIG_NOW))) {	/*  double timed action */
 		if (!devpriv->usedma) {
 			comedi_error(dev,
 				"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!");
@@ -1457,15 +1457,15 @@ static int pci9118_ai_cmd(struct comedi_
 		devpriv->ai_do = 3;
 	}
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
-	devpriv->AdControlReg = 0;	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable DMA
+	devpriv->AdControlReg = 0;	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable DMA */
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
-	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	comedi_udelay(1);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
-	inl(dev->iobase + PCI9118_ADSTAT);	// flush A/D and INT status register
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	inl(dev->iobase + PCI9118_ADSTAT);	/*  flush A/D and INT status register */
 	inl(dev->iobase + PCI9118_INTSRC);
 
 	devpriv->ai_act_scan = 0;
@@ -1505,11 +1505,11 @@ static int check_channel_list(struct com
 	}
 
 	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	// all input must be diff
+		differencial = 1;	/*  all input must be diff */
 	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	// all input must be bipolar
+		bipolar = 1;	/*  all input must be bipolar */
 	if (n_chan > 1)
-		for (i = 1; i < n_chan; i++) {	// check S.E/diff
+		for (i = 1; i < n_chan; i++) {	/*  check S.E/diff */
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
 				(differencial)) {
 				comedi_error(dev,
@@ -1552,27 +1552,27 @@ static int setup_channel_list(struct com
 	}
 
 	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	// all input must be diff
+		differencial = 1;	/*  all input must be diff */
 	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	// all input must be bipolar
+		bipolar = 1;	/*  all input must be bipolar */
 
-	// All is ok, so we can setup channel/range list
+	/*  All is ok, so we can setup channel/range list */
 
 	if (!bipolar) {
-		devpriv->AdControlReg |= AdControl_UniP;	// set unibipolar
+		devpriv->AdControlReg |= AdControl_UniP;	/*  set unibipolar */
 	} else {
-		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);	// enable bipolar
+		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);	/*  enable bipolar */
 	}
 
 	if (differencial) {
-		devpriv->AdControlReg |= AdControl_Diff;	// enable diff inputs
+		devpriv->AdControlReg |= AdControl_Diff;	/*  enable diff inputs */
 	} else {
-		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);	// set single ended inputs
+		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);	/*  set single ended inputs */
 	}
 
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// setup mode
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  setup mode */
 
-	outl(2, dev->iobase + PCI9118_SCANMOD);	// gods know why this sequence!
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  gods know why this sequence! */
 	outl(0, dev->iobase + PCI9118_SCANMOD);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
 
@@ -1582,12 +1582,12 @@ static int setup_channel_list(struct com
 		devpriv->chanlist[i] = 0x55aa;
 #endif
 
-	if (frontadd) {		// insert channels for S&H
+	if (frontadd) {		/*  insert channels for S&H */
 		ssh = devpriv->softsshsample;
 		DPRINTK("FA: %04x: ", ssh);
-		for (i = 0; i < frontadd; i++) {	// store range list to card
-			scanquad = CR_CHAN(chanlist[0]);	// get channel number;
-			gain = CR_RANGE(chanlist[0]);	// get gain number
+		for (i = 0; i < frontadd; i++) {	/*  store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);	/*  get channel number; */
+			gain = CR_RANGE(chanlist[0]);	/*  get gain number */
 			scanquad |= ((gain & 0x03) << 8);
 			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 			DPRINTK("%02x ", scanquad | ssh);
@@ -1597,23 +1597,23 @@ static int setup_channel_list(struct com
 	}
 
 	DPRINTK("SL: ", ssh);
-	for (i = 0; i < n_chan; i++) {	// store range list to card
-		scanquad = CR_CHAN(chanlist[i]);	// get channel number;
+	for (i = 0; i < n_chan; i++) {	/*  store range list to card */
+		scanquad = CR_CHAN(chanlist[i]);	/*  get channel number; */
 #ifdef PCI9118_PARANOIDCHECK
 		devpriv->chanlist[i ^ usedma] = (scanquad & 0xf) << rot;
 #endif
-		gain = CR_RANGE(chanlist[i]);	// get gain number
+		gain = CR_RANGE(chanlist[i]);	/*  get gain number */
 		scanquad |= ((gain & 0x03) << 8);
 		outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 		DPRINTK("%02x ", scanquad | ssh);
 	}
 	DPRINTK("\n ");
 
-	if (backadd) {		// insert channels for fit onto 32bit DMA
+	if (backadd) {		/*  insert channels for fit onto 32bit DMA */
 		DPRINTK("BA: %04x: ", ssh);
-		for (i = 0; i < backadd; i++) {	// store range list to card
-			scanquad = CR_CHAN(chanlist[0]);	// get channel number;
-			gain = CR_RANGE(chanlist[0]);	// get gain number
+		for (i = 0; i < backadd; i++) {	/*  store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);	/*  get channel number; */
+			gain = CR_RANGE(chanlist[0]);	/*  get gain number */
 			scanquad |= ((gain & 0x03) << 8);
 			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 			DPRINTK("%02x ", scanquad | ssh);
@@ -1621,13 +1621,13 @@ static int setup_channel_list(struct com
 		DPRINTK("\n ");
 	}
 #ifdef PCI9118_PARANOIDCHECK
-	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];	// for 32bit oerations
+	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];	/*  for 32bit oerations */
 	if (useeos) {
-		for (i = 1; i < n_chan; i++) {	// store range list to card
+		for (i = 1; i < n_chan; i++) {	/*  store range list to card */
 			devpriv->chanlist[(n_chan + i) ^ usedma] =
 				(CR_CHAN(chanlist[i]) & 0xf) << rot;
 		}
-		devpriv->chanlist[(2 * n_chan) ^ usedma] = devpriv->chanlist[0 ^ usedma];	// for 32bit oerations
+		devpriv->chanlist[(2 * n_chan) ^ usedma] = devpriv->chanlist[0 ^ usedma];	/*  for 32bit oerations */
 		useeos = 2;
 	} else {
 		useeos = 1;
@@ -1640,11 +1640,11 @@ static int setup_channel_list(struct com
 	DPRINTK("\n ");
 #endif
 #endif
-	outl(0, dev->iobase + PCI9118_SCANMOD);	// close scan queue
-//      comedi_udelay(100);                             // important delay, or first sample will be cripled
+	outl(0, dev->iobase + PCI9118_SCANMOD);	/*  close scan queue */
+/* comedi_udelay(100);                               important delay, or first sample will be cripled */
 
 	DPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");
-	return 1;		// we can serve this with scan logic
+	return 1;		/*  we can serve this with scan logic */
 }
 
 /*
@@ -1672,17 +1672,17 @@ static void pci9118_calc_divisors(char m
 			*tim2 = this_board->ai_ns_min;
 		DPRINTK("1 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div1 = *tim2 / devpriv->i8254_osc_base;	// convert timer (burst)
+		*div1 = *tim2 / devpriv->i8254_osc_base;	/*  convert timer (burst) */
 		DPRINTK("2 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 		if (*div1 < this_board->ai_pacer_min)
 			*div1 = this_board->ai_pacer_min;
 		DPRINTK("3 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div2 = *tim1 / devpriv->i8254_osc_base;	// scan timer
+		*div2 = *tim1 / devpriv->i8254_osc_base;	/*  scan timer */
 		DPRINTK("4 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div2 = *div2 / *div1;	// major timer is c1*c2
+		*div2 = *div2 / *div1;	/*  major timer is c1*c2 */
 		DPRINTK("5 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 		if (*div2 < chans)
@@ -1690,9 +1690,9 @@ static void pci9118_calc_divisors(char m
 		DPRINTK("6 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 
-		*tim2 = *div1 * devpriv->i8254_osc_base;	// real convert timer
+		*tim2 = *div1 * devpriv->i8254_osc_base;	/*  real convert timer */
 
-		if (usessh & (chnsshfront == 0))	// use BSSH signal
+		if (usessh & (chnsshfront == 0))	/*  use BSSH signal */
 			if (*div2 < (chans + 2))
 				*div2 = chans + 2;
 
@@ -1715,7 +1715,7 @@ static void start_pacer(struct comedi_de
 {
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
-//      outl(0x30, dev->iobase + PCI9118_CNTCTRL);
+/* outl(0x30, dev->iobase + PCI9118_CNTCTRL); */
 	comedi_udelay(1);
 
 	if ((mode == 1) || (mode == 2) || (mode == 4)) {
@@ -1732,11 +1732,11 @@ static void start_pacer(struct comedi_de
 static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source)
 {
 	if (source > 3)
-		return -1;	// incorrect source
+		return -1;	/*  incorrect source */
 	devpriv->exttrg_users |= (1 << source);
 	devpriv->IntControlReg |= Int_DTrg;
 	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 	return 0;
 }
 
@@ -1746,12 +1746,12 @@ static int pci9118_exttrg_add(struct com
 static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
 {
 	if (source > 3)
-		return -1;	// incorrect source
+		return -1;	/*  incorrect source */
 	devpriv->exttrg_users &= ~(1 << source);
-	if (!devpriv->exttrg_users) {	// shutdown ext trg intterrupts
+	if (!devpriv->exttrg_users) {	/*  shutdown ext trg intterrupts */
 		devpriv->IntControlReg &= ~Int_DTrg;
-		if (!devpriv->IntControlReg)	// all IRQ disabled
-			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) & (~0x00001f00), devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// disable int in AMCC
+		if (!devpriv->IntControlReg)	/*  all IRQ disabled */
+			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) & (~0x00001f00), devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  disable int in AMCC */
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 	}
 	return 0;
@@ -1763,17 +1763,17 @@ static int pci9118_exttrg_del(struct com
 static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (devpriv->usedma)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
 	pci9118_exttrg_del(dev, EXTTRG_AI);
-	start_pacer(dev, 0, 0, 0);	// stop 8254 counters
+	start_pacer(dev, 0, 0, 0);	/*  stop 8254 counters */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 	devpriv->AdControlReg = 0x00;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 	outl(0, dev->iobase + PCI9118_BURST);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	// reset scan queue
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  reset scan queue */
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 
 	devpriv->ai_do = 0;
 	devpriv->usedma = 0;
@@ -1787,7 +1787,7 @@ static int pci9118_ai_cancel(struct come
 	devpriv->dma_actbuf = 0;
 
 	if (!devpriv->IntControlReg)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 
 	return 0;
 }
@@ -1800,31 +1800,31 @@ static int pci9118_reset(struct comedi_d
 	devpriv->IntControlReg = 0;
 	devpriv->exttrg_users = 0;
 	inl(dev->iobase + PCI9118_INTCTRL);
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);	// disable interrupts source
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);	/*  disable interrupts source */
 	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
-//        outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
-	start_pacer(dev, 0, 0, 0);	// stop 8254 counters
+/* outl(0xb4, dev->iobase + PCI9118_CNTCTRL); */
+	start_pacer(dev, 0, 0, 0);	/*  stop 8254 counters */
 	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 	outl(0, dev->iobase + PCI9118_BURST);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	// reset scan queue
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  reset scan queue */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 
 	devpriv->ao_data[0] = 2047;
 	devpriv->ao_data[1] = 2047;
-	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);	// reset A/D outs to 0V
+	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);	/*  reset A/D outs to 0V */
 	outl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);
-	outl(0, dev->iobase + PCI9118_DO);	// reset digi outs to L
+	outl(0, dev->iobase + PCI9118_DO);	/*  reset digi outs to L */
 	comedi_udelay(10);
 	inl(dev->iobase + PCI9118_AD_DATA);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
-	outl(0, dev->iobase + PCI9118_INTSRC);	// remove INT requests
-	inl(dev->iobase + PCI9118_ADSTAT);	// flush A/D status register
-	inl(dev->iobase + PCI9118_INTSRC);	// flush INT requests
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	outl(0, dev->iobase + PCI9118_INTSRC);	/*  remove INT requests */
+	inl(dev->iobase + PCI9118_ADSTAT);	/*  flush A/D status register */
+	inl(dev->iobase + PCI9118_INTSRC);	/*  flush INT requests */
 	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 
 	devpriv->cnt0_users = 0;
 	devpriv->exttrg_users = 0;
@@ -1854,7 +1854,7 @@ static int pci9118_attach(struct comedi_
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
 	if (it->options[3] & 1) {
-		master = 0;	// user don't want use bus master
+		master = 0;	/*  user don't want use bus master */
 	} else {
 		master = 1;
 	}
@@ -1920,7 +1920,7 @@ static int pci9118_attach(struct comedi_
 	pci9118_reset(dev);
 
 	if (it->options[3] & 2)
-		irq = 0;	// user don't want use IRQ
+		irq = 0;	/*  user don't want use IRQ */
 	if (irq > 0) {
 		if (comedi_request_irq(irq, interrupt_pci9118, IRQF_SHARED,
 				"ADLink PCI-9118", dev)) {
@@ -1936,7 +1936,7 @@ static int pci9118_attach(struct comedi_
 
 	dev->irq = irq;
 
-	if (master) {		// alloc DMA buffers
+	if (master) {		/*  alloc DMA buffers */
 		devpriv->dma_doublebuf = 0;
 		for (i = 0; i < 2; i++) {
 			for (pages = 4; pages >= 0; pages--)
@@ -1974,16 +1974,16 @@ static int pci9118_attach(struct comedi_
 	if (it->options[2] > 0) {
 		devpriv->usemux = it->options[2];
 		if (devpriv->usemux > 256)
-			devpriv->usemux = 256;	// max 256 channels!
+			devpriv->usemux = 256;	/*  max 256 channels! */
 		if (it->options[4] > 0)
 			if (devpriv->usemux > 128) {
-				devpriv->usemux = 128;	// max 128 channels with softare S&H!
+				devpriv->usemux = 128;	/*  max 128 channels with softare S&H! */
 			}
 		rt_printk(", ext. mux %d channels", devpriv->usemux);
 	}
 
 	devpriv->softsshdelay = it->options[4];
-	if (devpriv->softsshdelay < 0) {	// select sample&hold signal polarity
+	if (devpriv->softsshdelay < 0) {	/*  select sample&hold signal polarity */
 		devpriv->softsshdelay = -devpriv->softsshdelay;
 		devpriv->softsshsample = 0x80;
 		devpriv->softsshhold = 0x00;
@@ -1995,7 +1995,7 @@ static int pci9118_attach(struct comedi_
 	rt_printk(".\n");
 
 	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
-	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	// Enable parity check for parity error
+	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	/*  Enable parity check for parity error */
 
 	if ((ret = alloc_subdevices(dev, 4)) < 0)
 		return ret;
@@ -2052,9 +2052,9 @@ static int pci9118_attach(struct comedi_
 	s->insn_bits = pci9118_insn_bits_do;
 
 	devpriv->valid = 1;
-	devpriv->i8254_osc_base = 250;	// 250ns=4MHz
-	devpriv->ai_maskharderr = 0x10a;	// default measure crash condition
-	if (it->options[5])	// disable some requested
+	devpriv->i8254_osc_base = 250;	/*  250ns=4MHz */
+	devpriv->ai_maskharderr = 0x10a;	/*  default measure crash condition */
+	if (it->options[5])	/*  disable some requested */
 		devpriv->ai_maskharderr &= ~it->options[5];
 
 	switch (this_board->ai_maxdata) {
