From kevin.granade@gmail.com  Fri Sep 11 14:51:22 2009
From: kevin.granade@gmail.com
Date: Sat, 5 Sep 2009 01:03:39 -0500 (CDT)
Subject: Staging: asus_oled: Cleaned up checkpatch issues.
To: Greg Kroah-Hartman <greg@kroah.com>
Cc: Belisko Marek <marek.belisko@gmail.com>,  Jakub Schmidtke <sjakub@gmail.com>
Message-ID: <alpine.DEB.2.00.0909050051110.19210@pc9406>


From: Kevin A. Granade <kevin.granade@gmail.com>


Signed-off-by: Kevin A. Granade <kevin.granade@gmail.com>
Cc: Belisko Marek <marek.belisko@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/asus_oled/asus_oled.c |  404 ++++++++++++++++++----------------
 1 file changed, 221 insertions(+), 183 deletions(-)

--- a/drivers/staging/asus_oled/asus_oled.c
+++ b/drivers/staging/asus_oled/asus_oled.c
@@ -63,26 +63,31 @@ static uint start_off;
 
 module_param(start_off, uint, 0644);
 
-MODULE_PARM_DESC(start_off, "Set to 1 to switch off OLED display after it is attached");
+MODULE_PARM_DESC(start_off,
+		 "Set to 1 to switch off OLED display after it is attached");
 
-typedef enum {
+enum oled_pack_mode{
 	PACK_MODE_G1,
 	PACK_MODE_G50,
 	PACK_MODE_LAST
-} oled_pack_mode_t;
+};
 
 struct oled_dev_desc_str {
 	uint16_t		idVendor;
 	uint16_t		idProduct;
-	uint16_t		devWidth; // width of display
-	oled_pack_mode_t	packMode; // formula to be used while packing the picture
+	/* width of display */
+	uint16_t		devWidth;
+	/* formula to be used while packing the picture */
+	enum oled_pack_mode	packMode;
 	const char		*devDesc;
 };
 
 /* table of devices that work with this driver */
 static struct usb_device_id id_table[] = {
-	{ USB_DEVICE(0x0b05, 0x1726) }, // Asus G1/G2 (and variants)
-	{ USB_DEVICE(0x0b05, 0x175b) }, // Asus G50V (and possibly others - G70? G71?)
+	/* Asus G1/G2 (and variants)*/
+	{ USB_DEVICE(0x0b05, 0x1726) },
+	/* Asus G50V (and possibly others - G70? G71?)*/
+	{ USB_DEVICE(0x0b05, 0x175b) },
 	{ },
 };
 
@@ -95,20 +100,6 @@ static struct oled_dev_desc_str oled_dev
 
 MODULE_DEVICE_TABLE(usb, id_table);
 
-#define SETUP_PACKET_HEADER(packet, val1, val2, val3, val4, val5, val6, val7) \
-	do {					\
-		memset(packet, 0, sizeof(struct asus_oled_header));		\
-		packet->header.magic1 = 0x55;		\
-		packet->header.magic2 = 0xaa;		\
-		packet->header.flags = val1;		\
-		packet->header.value3 = val2;		\
-		packet->header.buffer1 = val3;		\
-		packet->header.buffer2 = val4;		\
-		packet->header.value6 = val5;		\
-		packet->header.value7 = val6;		\
-		packet->header.value8 = val7;		\
-	} while (0);
-
 struct asus_oled_header {
 	uint8_t		magic1;
 	uint8_t		magic2;
@@ -128,10 +119,10 @@ struct asus_oled_packet {
 } __attribute((packed));
 
 struct asus_oled_dev {
-	struct usb_device *	udev;
+	struct usb_device       *udev;
 	uint8_t			pic_mode;
 	uint16_t		dev_width;
-	oled_pack_mode_t	pack_mode;
+	enum oled_pack_mode	pack_mode;
 	size_t			height;
 	size_t			width;
 	size_t			x_shift;
@@ -144,12 +135,28 @@ struct asus_oled_dev {
 	struct device		*dev;
 };
 
+static void setup_packet_header(struct asus_oled_packet *packet, char flags,
+			 char value3, char buffer1, char buffer2, char value6,
+			 char value7, char value8)
+{
+	memset(packet, 0, sizeof(struct asus_oled_header));
+	packet->header.magic1 = 0x55;
+	packet->header.magic2 = 0xaa;
+	packet->header.flags = flags;
+	packet->header.value3 = value3;
+	packet->header.buffer1 = buffer1;
+	packet->header.buffer2 = buffer2;
+	packet->header.value6 = value6;
+	packet->header.value7 = value7;
+	packet->header.value8 = value8;
+}
+
 static void enable_oled(struct asus_oled_dev *odev, uint8_t enabl)
 {
 	int a;
 	int retval;
 	int act_len;
-	struct asus_oled_packet * packet;
+	struct asus_oled_packet *packet;
 
 	packet = kzalloc(sizeof(struct asus_oled_packet), GFP_KERNEL);
 
@@ -158,7 +165,7 @@ static void enable_oled(struct asus_oled
 		return;
 	}
 
-	SETUP_PACKET_HEADER(packet, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00);
+	setup_packet_header(packet, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00);
 
 	if (enabl)
 		packet->bitmap[0] = 0xaf;
@@ -182,29 +189,34 @@ static void enable_oled(struct asus_oled
 	kfree(packet);
 }
 
-static ssize_t set_enabled(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t set_enabled(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	struct usb_interface *intf = to_usb_interface(dev);
 	struct asus_oled_dev *odev = usb_get_intfdata(intf);
-	int temp = simple_strtoul(buf, NULL, 10);
+	int temp = strict_strtoul(buf, 10, NULL);
 
 	enable_oled(odev, temp);
 
 	return count;
 }
 
-static ssize_t class_set_enabled(struct device *device, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t class_set_enabled(struct device *device,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
 {
-	struct asus_oled_dev *odev = (struct asus_oled_dev *) dev_get_drvdata(device);
+	struct asus_oled_dev *odev =
+		(struct asus_oled_dev *) dev_get_drvdata(device);
 
-	int temp = simple_strtoul(buf, NULL, 10);
+	int temp = strict_strtoul(buf, 10, NULL);
 
 	enable_oled(odev, temp);
 
 	return count;
 }
 
-static ssize_t get_enabled(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t get_enabled(struct device *dev, struct device_attribute *attr,
+			   char *buf)
 {
 	struct usb_interface *intf = to_usb_interface(dev);
 	struct asus_oled_dev *odev = usb_get_intfdata(intf);
@@ -212,15 +224,18 @@ static ssize_t get_enabled(struct device
 	return sprintf(buf, "%d\n", odev->enabled);
 }
 
-static ssize_t class_get_enabled(struct device *device, struct device_attribute *attr, char *buf)
+static ssize_t class_get_enabled(struct device *device,
+				 struct device_attribute *attr, char *buf)
 {
-	struct asus_oled_dev *odev = (struct asus_oled_dev *) dev_get_drvdata(device);
+	struct asus_oled_dev *odev =
+		(struct asus_oled_dev *) dev_get_drvdata(device);
 
 	return sprintf(buf, "%d\n", odev->enabled);
 }
 
-static void send_packets(struct usb_device *udev, struct asus_oled_packet *packet,
-	char *buf, uint8_t p_type, size_t p_num)
+static void send_packets(struct usb_device *udev,
+			 struct asus_oled_packet *packet,
+			 char *buf, uint8_t p_type, size_t p_num)
 {
 	size_t i;
 	int act_len;
@@ -229,65 +244,76 @@ static void send_packets(struct usb_devi
 		int retval;
 
 		switch (p_type) {
-			case ASUS_OLED_ROLL:
-				SETUP_PACKET_HEADER(packet, 0x40, 0x80, p_num, i + 1, 0x00, 0x01, 0xff);
+		case ASUS_OLED_ROLL:
+			setup_packet_header(packet, 0x40, 0x80, p_num,
+					    i + 1, 0x00, 0x01, 0xff);
 			break;
-			case ASUS_OLED_STATIC:
-				SETUP_PACKET_HEADER(packet, 0x10 + i, 0x80, 0x01, 0x01, 0x00, 0x01, 0x00);
+		case ASUS_OLED_STATIC:
+			setup_packet_header(packet, 0x10 + i, 0x80, 0x01,
+					    0x01, 0x00, 0x01, 0x00);
 			break;
-			case ASUS_OLED_FLASH:
-				SETUP_PACKET_HEADER(packet, 0x10 + i, 0x80, 0x01, 0x01, 0x00, 0x00, 0xff);
+		case ASUS_OLED_FLASH:
+			setup_packet_header(packet, 0x10 + i, 0x80, 0x01,
+					    0x01, 0x00, 0x00, 0xff);
 			break;
 		}
 
-		memcpy(packet->bitmap, buf + (ASUS_OLED_PACKET_BUF_SIZE*i), ASUS_OLED_PACKET_BUF_SIZE);
+		memcpy(packet->bitmap, buf + (ASUS_OLED_PACKET_BUF_SIZE*i),
+		       ASUS_OLED_PACKET_BUF_SIZE);
 
-		retval = usb_bulk_msg(udev,
-			usb_sndctrlpipe(udev, 2),
-			packet,
-			sizeof(struct asus_oled_packet),
-			&act_len,
-			-1);
+		retval = usb_bulk_msg(udev, usb_sndctrlpipe(udev, 2),
+				      packet, sizeof(struct asus_oled_packet),
+				      &act_len, -1);
 
 		if (retval)
 			dev_dbg(&udev->dev, "retval = %d\n", retval);
 	}
 }
 
-static void send_packet(struct usb_device *udev, struct asus_oled_packet *packet, size_t offset, size_t len, char *buf, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5, uint8_t b6) {
+static void send_packet(struct usb_device *udev,
+			struct asus_oled_packet *packet,
+			size_t offset, size_t len, char *buf, uint8_t b1,
+			uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5,
+			uint8_t b6) {
 	int retval;
 	int act_len;
 
-	SETUP_PACKET_HEADER(packet, b1, b2, b3, b4, b5, b6, 0x00);
+	setup_packet_header(packet, b1, b2, b3, b4, b5, b6, 0x00);
 	memcpy(packet->bitmap, buf + offset, len);
 
 	retval = usb_bulk_msg(udev,
-			usb_sndctrlpipe(udev, 2),
-			packet,
-			sizeof(struct asus_oled_packet),
-			&act_len,
-			-1);
+			      usb_sndctrlpipe(udev, 2),
+			      packet,
+			      sizeof(struct asus_oled_packet),
+			      &act_len,
+			      -1);
 
 	if (retval)
 		dev_dbg(&udev->dev, "retval = %d\n", retval);
 }
 
 
-static void send_packets_g50(struct usb_device *udev, struct asus_oled_packet *packet, char *buf)
+static void send_packets_g50(struct usb_device *udev,
+			     struct asus_oled_packet *packet, char *buf)
 {
-	send_packet(udev, packet,     0, 0x100, buf, 0x10, 0x00, 0x02, 0x01, 0x00, 0x01);
-	send_packet(udev, packet, 0x100, 0x080, buf, 0x10, 0x00, 0x02, 0x02, 0x80, 0x00);
-
-	send_packet(udev, packet, 0x180, 0x100, buf, 0x11, 0x00, 0x03, 0x01, 0x00, 0x01);
-	send_packet(udev, packet, 0x280, 0x100, buf, 0x11, 0x00, 0x03, 0x02, 0x00, 0x01);
-	send_packet(udev, packet, 0x380, 0x080, buf, 0x11, 0x00, 0x03, 0x03, 0x80, 0x00);
+	send_packet(udev, packet,     0, 0x100, buf,
+		    0x10, 0x00, 0x02, 0x01, 0x00, 0x01);
+	send_packet(udev, packet, 0x100, 0x080, buf,
+		    0x10, 0x00, 0x02, 0x02, 0x80, 0x00);
+
+	send_packet(udev, packet, 0x180, 0x100, buf,
+		    0x11, 0x00, 0x03, 0x01, 0x00, 0x01);
+	send_packet(udev, packet, 0x280, 0x100, buf,
+		    0x11, 0x00, 0x03, 0x02, 0x00, 0x01);
+	send_packet(udev, packet, 0x380, 0x080, buf,
+		    0x11, 0x00, 0x03, 0x03, 0x80, 0x00);
 }
 
 
 static void send_data(struct asus_oled_dev *odev)
 {
 	size_t packet_num = odev->buf_size / ASUS_OLED_PACKET_BUF_SIZE;
-	struct asus_oled_packet * packet;
+	struct asus_oled_packet *packet;
 
 	packet = kzalloc(sizeof(struct asus_oled_packet), GFP_KERNEL);
 
@@ -297,20 +323,20 @@ static void send_data(struct asus_oled_d
 	}
 
 	if (odev->pack_mode == PACK_MODE_G1) {
-		// When sending roll-mode data the display updated only first packet.
-		// I have no idea why, but when static picture is send just before
-		// rolling picture - everything works fine.
+		/* When sending roll-mode data the display updated only
+		   first packet.  I have no idea why, but when static picture
+		   is sent just before rolling picture everything works fine. */
 		if (odev->pic_mode == ASUS_OLED_ROLL)
-			send_packets(odev->udev, packet, odev->buf, ASUS_OLED_STATIC, 2);
+			send_packets(odev->udev, packet, odev->buf,
+				     ASUS_OLED_STATIC, 2);
 
-		// Only ROLL mode can use more than 2 packets.
+		/* Only ROLL mode can use more than 2 packets.*/
 		if (odev->pic_mode != ASUS_OLED_ROLL && packet_num > 2)
 			packet_num = 2;
 
-		send_packets(odev->udev, packet, odev->buf, odev->pic_mode, packet_num);
-	}
-	else
-	if (odev->pack_mode == PACK_MODE_G50) {
+		send_packets(odev->udev, packet, odev->buf,
+			     odev->pic_mode, packet_num);
+	} else if (odev->pack_mode == PACK_MODE_G50) {
 		send_packets_g50(odev->udev, packet, odev->buf);
 	}
 
@@ -319,53 +345,55 @@ static void send_data(struct asus_oled_d
 
 static int append_values(struct asus_oled_dev *odev, uint8_t val, size_t count)
 {
-	while (count-- > 0) {
-		if (val) {
-			size_t x = odev->buf_offs % odev->width;
-			size_t y = odev->buf_offs / odev->width;
-			size_t i;
-
-			x += odev->x_shift;
-			y += odev->y_shift;
-
-			switch (odev->pack_mode)
-			{
-				case PACK_MODE_G1:
-					// i = (x/128)*640 + 127 - x + (y/8)*128;
-					// This one for 128 is the same, but might be better for different widths?
-					i = (x/odev->dev_width)*640 + odev->dev_width - 1 - x + (y/8)*odev->dev_width;
-				break;
+	while (count-- > 0 && val) {
+		size_t x = odev->buf_offs % odev->width;
+		size_t y = odev->buf_offs / odev->width;
+		size_t i;
 
-				case PACK_MODE_G50:
-					i =  (odev->dev_width - 1 - x)/8 + y*odev->dev_width/8;
-				break;
+		x += odev->x_shift;
+		y += odev->y_shift;
 
-				default:
-					i = 0;
-					printk(ASUS_OLED_ERROR "Unknown OLED Pack Mode: %d!\n", odev->pack_mode);
-				break;
-			}
+		switch (odev->pack_mode) {
+		case PACK_MODE_G1:
+			/* i = (x/128)*640 + 127 - x + (y/8)*128;
+			   This one for 128 is the same, but might be better
+			   for different widths? */
+			i = (x/odev->dev_width)*640 +
+				odev->dev_width - 1 - x +
+				(y/8)*odev->dev_width;
+			break;
 
-			if (i >= odev->buf_size) {
-				printk(ASUS_OLED_ERROR "Buffer overflow! Report a bug in the driver: offs: %d >= %d i: %d (x: %d y: %d)\n",
-					(int) odev->buf_offs, (int) odev->buf_size, (int) i, (int) x, (int) y);
-				return -EIO;
-			}
+		case PACK_MODE_G50:
+			i =  (odev->dev_width - 1 - x)/8 + y*odev->dev_width/8;
+			break;
 
-			switch (odev->pack_mode)
-			{
-				case PACK_MODE_G1:
-					odev->buf[i] &= ~(1<<(y%8));
-				break;
+		default:
+			i = 0;
+			printk(ASUS_OLED_ERROR "Unknown OLED Pack Mode: %d!\n",
+			       odev->pack_mode);
+			break;
+		}
 
-				case PACK_MODE_G50:
-					odev->buf[i] &= ~(1<<(x%8));
-				break;
+		if (i >= odev->buf_size) {
+			printk(ASUS_OLED_ERROR "Buffer overflow! Report a bug:"
+			       "offs: %d >= %d i: %d (x: %d y: %d)\n",
+			       (int) odev->buf_offs, (int) odev->buf_size,
+			       (int) i, (int) x, (int) y);
+			return -EIO;
+		}
 
-				default:
-					// cannot get here; stops gcc complaining
-				;
-			}
+		switch (odev->pack_mode) {
+		case PACK_MODE_G1:
+			odev->buf[i] &= ~(1<<(y%8));
+			break;
+
+		case PACK_MODE_G50:
+			odev->buf[i] &= ~(1<<(x%8));
+			break;
+
+		default:
+			/* cannot get here; stops gcc complaining*/
+			;
 		}
 
 		odev->last_val = val;
@@ -375,7 +403,8 @@ static int append_values(struct asus_ole
 	return 0;
 }
 
-static ssize_t odev_set_picture(struct asus_oled_dev *odev, const char *buf, size_t count)
+static ssize_t odev_set_picture(struct asus_oled_dev *odev,
+				const char *buf, size_t count)
 {
 	size_t offs = 0, max_offs;
 
@@ -383,32 +412,31 @@ static ssize_t odev_set_picture(struct a
 		return 0;
 
 	if (tolower(buf[0]) == 'b') {
-	    // binary mode, set the entire memory
+		/* binary mode, set the entire memory*/
 
-	    size_t i;
+		size_t i;
 
-	    odev->buf_size = (odev->dev_width * ASUS_OLED_DISP_HEIGHT) / 8;
+		odev->buf_size = (odev->dev_width * ASUS_OLED_DISP_HEIGHT) / 8;
 
-	    if (odev->buf)
-		    kfree(odev->buf);
-	    odev->buf = kmalloc(odev->buf_size, GFP_KERNEL);
+		kfree(odev->buf);
+		odev->buf = kmalloc(odev->buf_size, GFP_KERNEL);
 
-	    memset(odev->buf, 0xff, odev->buf_size);
+		memset(odev->buf, 0xff, odev->buf_size);
 
-	    for (i = 1; i < count && i <= 32 * 32; i++) {
-		odev->buf[i-1] = buf[i];
-		odev->buf_offs = i-1;
-	    }
+		for (i = 1; i < count && i <= 32 * 32; i++) {
+			odev->buf[i-1] = buf[i];
+			odev->buf_offs = i-1;
+		}
 
-	    odev->width = odev->dev_width / 8;
-	    odev->height = ASUS_OLED_DISP_HEIGHT;
-	    odev->x_shift = 0;
-	    odev->y_shift = 0;
-	    odev->last_val =  0;
+		odev->width = odev->dev_width / 8;
+		odev->height = ASUS_OLED_DISP_HEIGHT;
+		odev->x_shift = 0;
+		odev->y_shift = 0;
+		odev->last_val =  0;
 
-	    send_data(odev);
+		send_data(odev);
 
-	    return count;
+		return count;
 	}
 
 	if (buf[0] == '<') {
@@ -416,20 +444,21 @@ static ssize_t odev_set_picture(struct a
 		size_t w = 0, h = 0;
 		size_t w_mem, h_mem;
 
-		if (count < 10 || buf[2] != ':') {
+		if (count < 10 || buf[2] != ':')
 			goto error_header;
-		}
+
 
 		switch (tolower(buf[1])) {
-			case ASUS_OLED_STATIC:
-			case ASUS_OLED_ROLL:
-			case ASUS_OLED_FLASH:
-				odev->pic_mode = buf[1];
-				break;
-			default:
-				printk(ASUS_OLED_ERROR "Wrong picture mode: '%c'.\n", buf[1]);
-				return -EIO;
-				break;
+		case ASUS_OLED_STATIC:
+		case ASUS_OLED_ROLL:
+		case ASUS_OLED_FLASH:
+			odev->pic_mode = buf[1];
+			break;
+		default:
+			printk(ASUS_OLED_ERROR "Wrong picture mode: '%c'.\n",
+			       buf[1]);
+			return -EIO;
+			break;
 		}
 
 		for (i = 3; i < count; ++i) {
@@ -438,11 +467,11 @@ static ssize_t odev_set_picture(struct a
 
 				if (w > ASUS_OLED_MAX_WIDTH)
 					goto error_width;
-			}
-			else if (tolower(buf[i]) == 'x')
+			} else if (tolower(buf[i]) == 'x') {
 				break;
-			else
+			} else {
 				goto error_width;
+			}
 		}
 
 		for (++i; i < count; ++i) {
@@ -451,11 +480,11 @@ static ssize_t odev_set_picture(struct a
 
 				if (h > ASUS_OLED_DISP_HEIGHT)
 					goto error_height;
-			}
-			else if (tolower(buf[i]) == '>')
+			} else if (tolower(buf[i]) == '>') {
 				break;
-			else
+			} else {
 				goto error_height;
+			}
 		}
 
 		if (w < 1 || w > ASUS_OLED_MAX_WIDTH)
@@ -481,8 +510,7 @@ static ssize_t odev_set_picture(struct a
 
 		odev->buf_size = w_mem * h_mem / 8;
 
-		if (odev->buf)
-			kfree(odev->buf);
+		kfree(odev->buf);
 		odev->buf = kmalloc(odev->buf_size, GFP_KERNEL);
 
 		if (odev->buf == NULL) {
@@ -503,8 +531,7 @@ static ssize_t odev_set_picture(struct a
 		if (odev->pic_mode == ASUS_OLED_FLASH) {
 			if (h < ASUS_OLED_DISP_HEIGHT/2)
 				odev->y_shift = (ASUS_OLED_DISP_HEIGHT/2 - h)/2;
-		}
-		else {
+		} else {
 			if (h < ASUS_OLED_DISP_HEIGHT)
 				odev->y_shift = (ASUS_OLED_DISP_HEIGHT - h)/2;
 		}
@@ -522,20 +549,21 @@ static ssize_t odev_set_picture(struct a
 			ret = append_values(odev, 1, 1);
 			if (ret < 0)
 				return ret;
-		}
-		else if (buf[offs] == '0' || buf[offs] == ' ') {
+		} else if (buf[offs] == '0' || buf[offs] == ' ') {
 			ret = append_values(odev, 0, 1);
 			if (ret < 0)
 				return ret;
-		}
-		else if (buf[offs] == '\n') {
-			// New line detected. Lets assume, that all characters till the end of the
-			// line were equal to the last character in this line.
+		} else if (buf[offs] == '\n') {
+			/* New line detected. Lets assume, that all characters
+			   till the end of the line were equal to the last
+			   character in this line.*/
 			if (odev->buf_offs % odev->width != 0)
 				ret = append_values(odev, odev->last_val,
-				      odev->width - (odev->buf_offs % odev->width));
-				if (ret < 0)
-					return ret;
+						    odev->width -
+						    (odev->buf_offs %
+						     odev->width));
+			if (ret < 0)
+				return ret;
 		}
 
 		offs++;
@@ -559,47 +587,52 @@ error_header:
 	return -EIO;
 }
 
-static ssize_t set_picture(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t set_picture(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	struct usb_interface *intf = to_usb_interface(dev);
 
 	return odev_set_picture(usb_get_intfdata(intf), buf, count);
 }
 
-static ssize_t class_set_picture(struct device *device, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t class_set_picture(struct device *device,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
 {
-	return odev_set_picture((struct asus_oled_dev *) dev_get_drvdata(device), buf, count);
+	return odev_set_picture((struct asus_oled_dev *)
+				dev_get_drvdata(device), buf, count);
 }
 
 #define ASUS_OLED_DEVICE_ATTR(_file)		dev_attr_asus_oled_##_file
 
-static DEVICE_ATTR(asus_oled_enabled, S_IWUGO | S_IRUGO, get_enabled, set_enabled);
+static DEVICE_ATTR(asus_oled_enabled, S_IWUGO | S_IRUGO,
+		   get_enabled, set_enabled);
 static DEVICE_ATTR(asus_oled_picture, S_IWUGO , NULL, set_picture);
 
-static DEVICE_ATTR(enabled, S_IWUGO | S_IRUGO, class_get_enabled, class_set_enabled);
+static DEVICE_ATTR(enabled, S_IWUGO | S_IRUGO,
+		   class_get_enabled, class_set_enabled);
 static DEVICE_ATTR(picture, S_IWUGO, NULL, class_set_picture);
 
-static int asus_oled_probe(struct usb_interface *interface, const struct usb_device_id *id)
+static int asus_oled_probe(struct usb_interface *interface,
+			   const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(interface);
 	struct asus_oled_dev *odev = NULL;
 	int retval = -ENOMEM;
 	uint16_t dev_width = 0;
-	oled_pack_mode_t pack_mode = PACK_MODE_LAST;
-	const struct oled_dev_desc_str * dev_desc = oled_dev_desc_table;
+	enum oled_pack_mode pack_mode = PACK_MODE_LAST;
+	const struct oled_dev_desc_str *dev_desc = oled_dev_desc_table;
 	const char *desc = NULL;
 
 	if (!id) {
-		// Even possible? Just to make sure...
+		/* Even possible? Just to make sure...*/
 		dev_err(&interface->dev, "No usb_device_id provided!\n");
 		return -ENODEV;
 	}
 
-	for (; dev_desc->idVendor; dev_desc++)
-	{
+	for (; dev_desc->idVendor; dev_desc++) {
 		if (dev_desc->idVendor == id->idVendor
-			&& dev_desc->idProduct == id->idProduct)
-		{
+		    && dev_desc->idProduct == id->idProduct) {
 			dev_width = dev_desc->devWidth;
 			desc = dev_desc->devDesc;
 			pack_mode = dev_desc->packMode;
@@ -608,7 +641,8 @@ static int asus_oled_probe(struct usb_in
 	}
 
 	if (!desc || dev_width < 1 || pack_mode == PACK_MODE_LAST) {
-		dev_err(&interface->dev, "Missing or incomplete device description!\n");
+		dev_err(&interface->dev,
+			"Missing or incomplete device description!\n");
 		return -ENODEV;
 	}
 
@@ -636,16 +670,18 @@ static int asus_oled_probe(struct usb_in
 
 	usb_set_intfdata(interface, odev);
 
-	retval = device_create_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(enabled));
+	retval = device_create_file(&interface->dev,
+				    &ASUS_OLED_DEVICE_ATTR(enabled));
 	if (retval)
 		goto err_files;
 
-	retval = device_create_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(picture));
+	retval = device_create_file(&interface->dev,
+				    &ASUS_OLED_DEVICE_ATTR(picture));
 	if (retval)
 		goto err_files;
 
 	odev->dev = device_create(oled_class, &interface->dev, MKDEV(0, 0),
-				NULL, "oled_%d", ++oled_num);
+				  NULL, "oled_%d", ++oled_num);
 
 	if (IS_ERR(odev->dev)) {
 		retval = PTR_ERR(odev->dev);
@@ -662,7 +698,9 @@ static int asus_oled_probe(struct usb_in
 	if (retval)
 		goto err_class_picture;
 
-	dev_info(&interface->dev, "Attached Asus OLED device: %s [width %u, pack_mode %d]\n", desc, odev->dev_width, odev->pack_mode);
+	dev_info(&interface->dev,
+		 "Attached Asus OLED device: %s [width %u, pack_mode %d]\n",
+		 desc, odev->dev_width, odev->pack_mode);
 
 	if (start_off)
 		enable_oled(odev, 0);
@@ -703,8 +741,7 @@ static void asus_oled_disconnect(struct 
 
 	usb_put_dev(odev->udev);
 
-	if (odev->buf)
-		kfree(odev->buf);
+	kfree(odev->buf);
 
 	kfree(odev);
 
@@ -720,7 +757,8 @@ static struct usb_driver oled_driver = {
 
 static ssize_t version_show(struct class *dev, char *buf)
 {
-	return sprintf(buf, ASUS_OLED_UNDERSCORE_NAME " %s\n", ASUS_OLED_VERSION);
+	return sprintf(buf, ASUS_OLED_UNDERSCORE_NAME " %s\n",
+		       ASUS_OLED_VERSION);
 }
 
 static CLASS_ATTR(version, S_IRUGO, version_show, NULL);
