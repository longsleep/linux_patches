From penberg@cs.helsinki.fi  Wed Nov 12 13:40:35 2008
From: Pekka J Enberg <penberg@cs.helsinki.fi>
Date: Wed, 29 Oct 2008 20:10:10 +0200 (EET)
Subject: Staging: w35und: remove timer wrappers
To: Greg Kroah-Hartman <greg@kroah.com>
Cc: Pavel Machek <pavel@suse.cz>, linux-kernel@vger.kernel.org
Message-ID: <Pine.LNX.4.64.0810292009370.16596@melkki.cs.Helsinki.FI>


From: Pekka Enberg <penberg@cs.helsinki.fi>

This patch removes the OS_TIMER and related wrappers from driver code. The
patch also changes the code to use msecs_to_jiffies() for setting up
timer->expires.

Acked-by: Pavel Machek <pavel@suse.cz>
Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/winbond/bssdscpt.h     |    2 
 drivers/staging/winbond/linux/common.h |   19 
 drivers/staging/winbond/mds_f.h        |    6 
 drivers/staging/winbond/mds_s.h        |    3 
 drivers/staging/winbond/rxisr.c        |   29 -
 drivers/staging/winbond/scan_s.h       |    3 
 drivers/staging/winbond/sme_s.h        |    3 
 drivers/staging/winbond/wbhal.c        |  778 ++++++++++++++++-----------------
 drivers/staging/winbond/wbhal_f.h      |    2 
 drivers/staging/winbond/wbhal_s.h      |    2 
 10 files changed, 408 insertions(+), 439 deletions(-)

--- a/drivers/staging/winbond/bssdscpt.h
+++ b/drivers/staging/winbond/bssdscpt.h
@@ -79,7 +79,7 @@ typedef struct BSSDescriptionElement
 	u16		wIndex;			// THIS BSS element entry index
 
 	void*	psadapter;		// pointer to THIS adapter
-	OS_TIMER	nTimer;  // MLME timer
+	struct timer_list timer;  // MLME timer
 
     // Authentication
     u16		wAuthAlgo;      // peer MAC MLME use Auth algorithm, default OPEN_AUTH
--- a/drivers/staging/winbond/linux/common.h
+++ b/drivers/staging/winbond/linux/common.h
@@ -84,24 +84,5 @@
 #define OS_MEMORY_CLEAR( _A, _S )	memset( (u8 *)_A,0,_S)
 #define OS_MEMORY_COMPARE( _A, _B, _S )	(memcmp(_A,_B,_S)? 0 : 1) // Definition is reverse with Ndis 1: the same 0: different
 
-#define OS_TIMER	struct timer_list
-#define OS_TIMER_INITIAL( _T, _F, _P )			\
-{							\
-	init_timer( _T );				\
-	(_T)->function = (void *)_F##_1a;		\
-	(_T)->data = (unsigned long)_P;			\
-}
-
-// _S : Millisecond
-// 20060420 At least 1 large than jiffies
-#define OS_TIMER_SET( _T, _S )					\
-{								\
-	(_T)->expires = jiffies + ((_S*HZ+999)/1000);\
-	add_timer( _T );					\
-}
-#define OS_TIMER_CANCEL( _T, _B )		del_timer_sync( _T )
-#define OS_TIMER_GET_SYS_TIME( _T )		(*_T=jiffies)
-
-
 #endif // COMMON_DEF
 
--- a/drivers/staging/winbond/mds_f.h
+++ b/drivers/staging/winbond/mds_f.h
@@ -12,13 +12,7 @@ extern void DataDmp(u8 *pdata, u32 len, 
 
 void vRxTimerInit(struct wb35_adapter *adapter);
 void vRxTimerStart(struct wb35_adapter *adapter, int timeout_value);
-void RxTimerHandler_1a( struct wb35_adapter *adapter);
 void vRxTimerStop(struct wb35_adapter *adapter);
-void RxTimerHandler( void*			SystemSpecific1,
-					   struct wb35_adapter * 	adapter,
-					   void*			SystemSpecific2,
-					   void*			SystemSpecific3);
-
 
 // For Asynchronous indicating. The routine collocates with USB.
 void Mds_MsduProcess(  struct wb35_adapter *adapter,  PRXLAYER1 pRxLayer1,  u8 SlotIndex);
--- a/drivers/staging/winbond/mds_s.h
+++ b/drivers/staging/winbond/mds_s.h
@@ -133,8 +133,7 @@ typedef struct _MDS
 	u8		boCounterMeasureBlock;
 	u8		reserved_4[2];
 
-	//NDIS_MINIPORT_TIMER	nTimer;
-	OS_TIMER	nTimer;
+	struct timer_list timer;
 
 	u32	TxTsc; // 20060214
 	u32	TxTsc_2; // 20060214
--- a/drivers/staging/winbond/rxisr.c
+++ b/drivers/staging/winbond/rxisr.c
@@ -1,30 +1,27 @@
 #include "os_common.h"
 
-void vRxTimerInit(struct wb35_adapter * adapter)
+static void RxTimerHandler(unsigned long data)
 {
-	OS_TIMER_INITIAL(&(adapter->Mds.nTimer), (void*) RxTimerHandler, (void*) adapter);
+	WARN_ON(1);
 }
 
-void vRxTimerStart(struct wb35_adapter * adapter, int timeout_value)
+void vRxTimerInit(struct wb35_adapter *adapter)
 {
-	if (timeout_value<MIN_TIMEOUT_VAL)
-		timeout_value=MIN_TIMEOUT_VAL;
-
-	OS_TIMER_SET( &(adapter->Mds.nTimer), timeout_value );
+	init_timer(&adapter->Mds.timer);
+	adapter->Mds.timer.function = RxTimerHandler;
+	adapter->Mds.timer.data = (unsigned long) adapter;
 }
 
-void vRxTimerStop(struct wb35_adapter * adapter)
+void vRxTimerStart(struct wb35_adapter *adapter, int timeout_value)
 {
-	OS_TIMER_CANCEL( &(adapter->Mds.nTimer), 0 );
-}
+	if (timeout_value < MIN_TIMEOUT_VAL)
+		timeout_value = MIN_TIMEOUT_VAL;
 
-void RxTimerHandler_1a( struct wb35_adapter * adapter)
-{
-	RxTimerHandler(NULL, adapter, NULL, NULL);
+	adapter->Mds.timer.expires = jiffies + msecs_to_jiffies(timeout_value);
+	add_timer(&adapter->Mds.timer);
 }
 
-void RxTimerHandler(void* SystemSpecific1, struct wb35_adapter * adapter,
-		    void* SystemSpecific2, void* SystemSpecific3)
+void vRxTimerStop(struct wb35_adapter *adapter)
 {
-	WARN_ON(1);
+	del_timer_sync(&adapter->Mds.timer);
 }
--- a/drivers/staging/winbond/scan_s.h
+++ b/drivers/staging/winbond/scan_s.h
@@ -62,8 +62,7 @@ typedef struct _SCAN_PARAMETERS
 	u8				boCCAbusy;					// Wb: HWMAC CCA busy status
 	u8				reserved_2;
 
-	//NDIS_MINIPORT_TIMER	nTimer;
-	OS_TIMER			nTimer;
+	struct timer_list timer;
 
 	u32				ScanTimeStamp;			//Increase 1 per background scan(1 minute)
 	u32				BssTimeStamp;			//Increase 1 per connect status check
--- a/drivers/staging/winbond/sme_s.h
+++ b/drivers/staging/winbond/sme_s.h
@@ -106,8 +106,7 @@ typedef struct _SME_PARAMETERS
 	u8				bDesiredPowerSave;
 
 	// SME timer and timeout value
-	//NDIS_MINIPORT_TIMER	nTimer;
-	OS_TIMER			nTimer;
+	struct timer_list timer;
 
 	u8				boInTimerHandler;
 	u8 				boAuthRetryActive;
--- a/drivers/staging/winbond/wbhal.c
+++ b/drivers/staging/winbond/wbhal.c
@@ -28,6 +28,292 @@ void hal_get_permanent_address( phw_data
 	memcpy( pethernet_address, pHwData->PermanentMacAddress, 6 );
 }
 
+static void hal_led_control(unsigned long data)
+{
+	phw_data_t pHwData = (phw_data_t) data;
+	struct wb35_adapter *	adapter = pHwData->adapter;
+	struct wb35_reg *reg = &pHwData->reg;
+	u32	LEDSet = (pHwData->SoftwareSet & HAL_LED_SET_MASK) >> HAL_LED_SET_SHIFT;
+	u8	LEDgray[20] = { 0,3,4,6,8,10,11,12,13,14,15,14,13,12,11,10,8,6,4,2 };
+	u8	LEDgray2[30] = { 7,8,9,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,13,12,11,10,9,8 };
+	u32	TimeInterval = 500, ltmp, ltmp2;
+        ltmp=0;
+
+	if( pHwData->SurpriseRemove ) return;
+
+	if( pHwData->LED_control ) {
+		ltmp2 = pHwData->LED_control & 0xff;
+		if( ltmp2 == 5 ) // 5 is WPS mode
+		{
+			TimeInterval = 100;
+			ltmp2 = (pHwData->LED_control>>8) & 0xff;
+			switch( ltmp2 )
+			{
+				case 1: // [0.2 On][0.1 Off]...
+					pHwData->LED_Blinking %= 3;
+					ltmp = 0x1010; // Led 1 & 0 Green and Red
+					if( pHwData->LED_Blinking == 2 ) // Turn off
+						ltmp = 0;
+					break;
+				case 2: // [0.1 On][0.1 Off]...
+					pHwData->LED_Blinking %= 2;
+					ltmp = 0x0010; // Led 0 red color
+					if( pHwData->LED_Blinking ) // Turn off
+						ltmp = 0;
+					break;
+				case 3: // [0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.5 Off]...
+					pHwData->LED_Blinking %= 15;
+					ltmp = 0x0010; // Led 0 red color
+					if( (pHwData->LED_Blinking >= 9) || (pHwData->LED_Blinking%2) ) // Turn off 0.6 sec
+						ltmp = 0;
+					break;
+				case 4: // [300 On][ off ]
+					ltmp = 0x1000; // Led 1 Green color
+					if( pHwData->LED_Blinking >= 3000 )
+						ltmp = 0; // led maybe on after 300sec * 32bit counter overlap.
+					break;
+			}
+			pHwData->LED_Blinking++;
+
+			reg->U1BC_LEDConfigure = ltmp;
+			if( LEDSet != 7 ) // Only 111 mode has 2 LEDs on PCB.
+			{
+				reg->U1BC_LEDConfigure |= (ltmp &0xff)<<8; // Copy LED result to each LED control register
+				reg->U1BC_LEDConfigure |= (ltmp &0xff00)>>8;
+			}
+			Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+		}
+	}
+	else if( pHwData->CurrentRadioSw || pHwData->CurrentRadioHw ) // If radio off
+	{
+		if( reg->U1BC_LEDConfigure & 0x1010 )
+		{
+			reg->U1BC_LEDConfigure &= ~0x1010;
+			Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+		}
+	}
+	else
+	{
+		switch( LEDSet )
+		{
+			case 4: // [100] Only 1 Led be placed on PCB and use pin 21 of IC. Use LED_0 for showing
+				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
+				{
+					// Blinking if scanning is on progress
+					if( pHwData->LED_Scanning )
+					{
+						if( pHwData->LED_Blinking == 0 )
+						{
+							reg->U1BC_LEDConfigure |= 0x10;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 On
+							pHwData->LED_Blinking = 1;
+							TimeInterval = 300;
+						}
+						else
+						{
+							reg->U1BC_LEDConfigure &= ~0x10;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+							pHwData->LED_Blinking = 0;
+							TimeInterval = 300;
+						}
+					}
+					else
+					{
+						//Turn Off LED_0
+						if( reg->U1BC_LEDConfigure & 0x10 )
+						{
+							reg->U1BC_LEDConfigure &= ~0x10;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+						}
+					}
+				}
+				else
+				{
+					// Turn On LED_0
+					if( (reg->U1BC_LEDConfigure & 0x10) == 0 )
+					{
+						reg->U1BC_LEDConfigure |= 0x10;
+						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+					}
+				}
+				break;
+
+			case 6: // [110] Only 1 Led be placed on PCB and use pin 21 of IC. Use LED_0 for showing
+				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
+				{
+					// Blinking if scanning is on progress
+					if( pHwData->LED_Scanning )
+					{
+						if( pHwData->LED_Blinking == 0 )
+						{
+							reg->U1BC_LEDConfigure &= ~0xf;
+							reg->U1BC_LEDConfigure |= 0x10;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 On
+							pHwData->LED_Blinking = 1;
+							TimeInterval = 300;
+						}
+						else
+						{
+							reg->U1BC_LEDConfigure &= ~0x1f;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+							pHwData->LED_Blinking = 0;
+							TimeInterval = 300;
+						}
+					}
+					else
+					{
+						// 20060901 Gray blinking if in disconnect state and not scanning
+						ltmp = reg->U1BC_LEDConfigure;
+						reg->U1BC_LEDConfigure &= ~0x1f;
+						if( LEDgray2[(pHwData->LED_Blinking%30)] )
+						{
+							reg->U1BC_LEDConfigure |= 0x10;
+							reg->U1BC_LEDConfigure |= LEDgray2[ (pHwData->LED_Blinking%30) ];
+						}
+						pHwData->LED_Blinking++;
+						if( reg->U1BC_LEDConfigure != ltmp )
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+						TimeInterval = 100;
+					}
+				}
+				else
+				{
+					// Turn On LED_0
+					if( (reg->U1BC_LEDConfigure & 0x10) == 0 )
+					{
+						reg->U1BC_LEDConfigure |= 0x10;
+						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
+					}
+				}
+				break;
+
+			case 5: // [101] Only 1 Led be placed on PCB and use LED_1 for showing
+				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
+				{
+					// Blinking if scanning is on progress
+					if( pHwData->LED_Scanning )
+					{
+						if( pHwData->LED_Blinking == 0 )
+						{
+							reg->U1BC_LEDConfigure |= 0x1000;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
+							pHwData->LED_Blinking = 1;
+							TimeInterval = 300;
+						}
+						else
+						{
+							reg->U1BC_LEDConfigure &= ~0x1000;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 Off
+							pHwData->LED_Blinking = 0;
+							TimeInterval = 300;
+						}
+					}
+					else
+					{
+						//Turn Off LED_1
+						if( reg->U1BC_LEDConfigure & 0x1000 )
+						{
+							reg->U1BC_LEDConfigure &= ~0x1000;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 Off
+						}
+					}
+				}
+				else
+				{
+					// Is transmitting/receiving ??
+					if( (OS_CURRENT_RX_BYTE( adapter ) != pHwData->RxByteCountLast ) ||
+						(OS_CURRENT_TX_BYTE( adapter ) != pHwData->TxByteCountLast ) )
+					{
+						if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
+						{
+							reg->U1BC_LEDConfigure |= 0x3000;
+							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
+						}
+
+						// Update variable
+						pHwData->RxByteCountLast = OS_CURRENT_RX_BYTE( adapter );
+						pHwData->TxByteCountLast = OS_CURRENT_TX_BYTE( adapter );
+						TimeInterval = 200;
+					}
+					else
+					{
+						// Turn On LED_1 and blinking if transmitting/receiving
+						 if( (reg->U1BC_LEDConfigure & 0x3000) != 0x1000 )
+						 {
+							 reg->U1BC_LEDConfigure &= ~0x3000;
+							 reg->U1BC_LEDConfigure |= 0x1000;
+							 Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
+						 }
+					}
+				}
+				break;
+
+			default: // Default setting. 2 LED be placed on PCB. LED_0: Link On LED_1 Active
+				if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
+				{
+					reg->U1BC_LEDConfigure |= 0x3000;// LED_1 is always on and event enable
+					Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+				}
+
+				if( pHwData->LED_Blinking )
+				{
+					// Gray blinking
+					reg->U1BC_LEDConfigure &= ~0x0f;
+					reg->U1BC_LEDConfigure |= 0x10;
+					reg->U1BC_LEDConfigure |= LEDgray[ (pHwData->LED_Blinking-1)%20 ];
+					Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+
+					pHwData->LED_Blinking += 2;
+					if( pHwData->LED_Blinking < 40 )
+						TimeInterval = 100;
+					else
+					{
+						pHwData->LED_Blinking = 0; // Stop blinking
+						reg->U1BC_LEDConfigure &= ~0x0f;
+						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+					}
+					break;
+				}
+
+				if( pHwData->LED_LinkOn )
+				{
+					if( !(reg->U1BC_LEDConfigure & 0x10) ) // Check the LED_0
+					{
+						//Try to turn ON LED_0 after gray blinking
+						reg->U1BC_LEDConfigure |= 0x10;
+						pHwData->LED_Blinking = 1; //Start blinking
+						TimeInterval = 50;
+					}
+				}
+				else
+				{
+					if( reg->U1BC_LEDConfigure & 0x10 ) // Check the LED_0
+					{
+						reg->U1BC_LEDConfigure &= ~0x10;
+						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+					}
+				}
+				break;
+		}
+
+		//20060828.1 Active send null packet to avoid AP disconnect
+		if( pHwData->LED_LinkOn )
+		{
+			pHwData->NullPacketCount += TimeInterval;
+			if( pHwData->NullPacketCount >= DEFAULT_NULL_PACKET_COUNT )
+			{
+				pHwData->NullPacketCount = 0;
+			}
+		}
+	}
+
+	pHwData->time_count += TimeInterval;
+	Wb35Tx_CurrentTime( pHwData, pHwData->time_count ); // 20060928 add
+	pHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(TimeInterval);
+	add_timer(&pHwData->LEDTimer);
+}
+
+
 u8 hal_init_hardware(phw_data_t pHwData, struct wb35_adapter * adapter)
 {
 	u16 SoftwareSet;
@@ -44,8 +330,11 @@ u8 hal_init_hardware(phw_data_t pHwData,
 			pHwData->InitialResource = 3;
 			if (Wb35Rx_initial(pHwData)) {
 				pHwData->InitialResource = 4;
-				OS_TIMER_INITIAL( &pHwData->LEDTimer, hal_led_control, pHwData );
-				OS_TIMER_SET( &pHwData->LEDTimer, 1000 ); // 20060623
+				init_timer(&pHwData->LEDTimer);
+				pHwData->LEDTimer.function = hal_led_control;
+				pHwData->LEDTimer.data = (unsigned long) pHwData;
+				pHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(1000);
+				add_timer(&pHwData->LEDTimer);
 
 				//
 				// For restrict to vendor's hardware
@@ -77,7 +366,7 @@ void hal_halt(phw_data_t pHwData, void *
 	switch( pHwData->InitialResource )
 	{
 		case 4:
-		case 3: OS_TIMER_CANCEL( &pHwData->LEDTimer, &cancel );
+		case 3: del_timer_sync(&pHwData->LEDTimer);
 			msleep(100); // Wait for Timer DPC exit 940623.2
 			Wb35Rx_destroy( pHwData ); // Release the Rx
 		case 2: Wb35Tx_destroy( pHwData ); // Release the Tx
@@ -322,403 +611,115 @@ void hal_stop(  phw_data_t pHwData )
 	pHwData->Wb35Rx.rx_halt = 1;
 	Wb35Rx_stop( pHwData );
 
-	pHwData->Wb35Tx.tx_halt = 1;
-	Wb35Tx_stop( pHwData );
-
-	reg->D00_DmaControl &= ~0xc0000000;//Tx Off, Rx Off
-	Wb35Reg_Write( pHwData, 0x0400, reg->D00_DmaControl );
-}
-
-unsigned char hal_idle(phw_data_t pHwData)
-{
-	struct wb35_reg *reg = &pHwData->reg;
-	PWBUSB	pWbUsb = &pHwData->WbUsb;
-
-	if( !pHwData->SurpriseRemove && ( pWbUsb->DetectCount || reg->EP0vm_state!=VM_STOP ) )
-		return false;
-
-	return true;
-}
-//---------------------------------------------------------------------------------------------------
-void hal_set_cwmin(  phw_data_t pHwData,  u8	cwin_min )
-{
-	struct wb35_reg *reg = &pHwData->reg;
-
-	if( pHwData->SurpriseRemove ) return;
-
-	pHwData->cwmin = cwin_min;
-	reg->M2C_MacControl &= ~0x7c00;	//bit 10 ~ 14
-	reg->M2C_MacControl |= (pHwData->cwmin<<10);
-	Wb35Reg_Write( pHwData, 0x082c, reg->M2C_MacControl );
-}
-
-s32 hal_get_rssi(  phw_data_t pHwData,  u32 *HalRssiArry,  u8 Count )
-{
-	struct wb35_reg *reg = &pHwData->reg;
-	R01_DESCRIPTOR	r01;
-	s32 ltmp = 0, tmp;
-	u8	i;
-
-	if( pHwData->SurpriseRemove ) return -200;
-	if( Count > MAX_ACC_RSSI_COUNT ) // Because the TS may use this funtion
-		Count = MAX_ACC_RSSI_COUNT;
-
-	// RSSI = C1 + C2 * (agc_state[7:0] + offset_map(lna_state[1:0]))
-	// C1 = -195, C2 = 0.66 = 85/128
-	for (i=0; i<Count; i++)
-	{
-		r01.value = HalRssiArry[i];
-		tmp = ((( r01.R01_AGC_state + reg->LNAValue[r01.R01_LNA_state]) * 85 ) >>7 ) - 195;
-		ltmp += tmp;
-	}
-	ltmp /= Count;
-	if( pHwData->phy_type == RF_AIROHA_2230 ) ltmp -= 5; // 10;
-	if( pHwData->phy_type == RF_AIROHA_2230S ) ltmp -= 5; // 10; 20060420 Add this
-
-	//if( ltmp < -200 ) ltmp = -200;
-	if( ltmp < -110 ) ltmp = -110;// 1.0.24.0 For NJRC
-
-	return ltmp;
-}
-//----------------------------------------------------------------------------------------------------
-s32 hal_get_rssi_bss(  phw_data_t pHwData,  u16 idx,  u8 Count )
-{
-	struct wb35_reg *reg = &pHwData->reg;
-	R01_DESCRIPTOR	r01;
-	s32 ltmp = 0, tmp;
-	u8	i, j;
-	struct wb35_adapter *	adapter = pHwData->adapter;
-//	u32 *HalRssiArry = psBSS(idx)->HalRssi;
-
-	if( pHwData->SurpriseRemove ) return -200;
-	if( Count > MAX_ACC_RSSI_COUNT ) // Because the TS may use this funtion
-		Count = MAX_ACC_RSSI_COUNT;
-
-	// RSSI = C1 + C2 * (agc_state[7:0] + offset_map(lna_state[1:0]))
-	// C1 = -195, C2 = 0.66 = 85/128
-#if 0
-	for (i=0; i<Count; i++)
-	{
-		r01.value = HalRssiArry[i];
-		tmp = ((( r01.R01_AGC_state + reg->LNAValue[r01.R01_LNA_state]) * 85 ) >>7 ) - 195;
-		ltmp += tmp;
-	}
-#else
-	if (psBSS(idx)->HalRssiIndex == 0)
-		psBSS(idx)->HalRssiIndex = MAX_ACC_RSSI_COUNT;
-	j = (u8)psBSS(idx)->HalRssiIndex-1;
-
-	for (i=0; i<Count; i++)
-	{
-		r01.value = psBSS(idx)->HalRssi[j];
-		tmp = ((( r01.R01_AGC_state + reg->LNAValue[r01.R01_LNA_state]) * 85 ) >>7 ) - 195;
-		ltmp += tmp;
-		if (j == 0)
-		{
-			j = MAX_ACC_RSSI_COUNT;
-		}
-		j--;
-	}
-#endif
-	ltmp /= Count;
-	if( pHwData->phy_type == RF_AIROHA_2230 ) ltmp -= 5; // 10;
-	if( pHwData->phy_type == RF_AIROHA_2230S ) ltmp -= 5; // 10; 20060420 Add this
-
-	//if( ltmp < -200 ) ltmp = -200;
-	if( ltmp < -110 ) ltmp = -110;// 1.0.24.0 For NJRC
-
-	return ltmp;
-}
-
-//---------------------------------------------------------------------------
-void hal_led_control_1a(  phw_data_t pHwData )
-{
-	hal_led_control( NULL, pHwData, NULL, NULL );
-}
-
-void hal_led_control(  void* S1,  phw_data_t pHwData,  void* S3,  void* S4 )
-{
-	struct wb35_adapter *	adapter = pHwData->adapter;
-	struct wb35_reg *reg = &pHwData->reg;
-	u32	LEDSet = (pHwData->SoftwareSet & HAL_LED_SET_MASK) >> HAL_LED_SET_SHIFT;
-	u8	LEDgray[20] = { 0,3,4,6,8,10,11,12,13,14,15,14,13,12,11,10,8,6,4,2 };
-	u8	LEDgray2[30] = { 7,8,9,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,13,12,11,10,9,8 };
-	u32	TimeInterval = 500, ltmp, ltmp2;
-        ltmp=0;
-
-	if( pHwData->SurpriseRemove ) return;
-
-	if( pHwData->LED_control ) {
-		ltmp2 = pHwData->LED_control & 0xff;
-		if( ltmp2 == 5 ) // 5 is WPS mode
-		{
-			TimeInterval = 100;
-			ltmp2 = (pHwData->LED_control>>8) & 0xff;
-			switch( ltmp2 )
-			{
-				case 1: // [0.2 On][0.1 Off]...
-					pHwData->LED_Blinking %= 3;
-					ltmp = 0x1010; // Led 1 & 0 Green and Red
-					if( pHwData->LED_Blinking == 2 ) // Turn off
-						ltmp = 0;
-					break;
-				case 2: // [0.1 On][0.1 Off]...
-					pHwData->LED_Blinking %= 2;
-					ltmp = 0x0010; // Led 0 red color
-					if( pHwData->LED_Blinking ) // Turn off
-						ltmp = 0;
-					break;
-				case 3: // [0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.1 On][0.1 Off][0.5 Off]...
-					pHwData->LED_Blinking %= 15;
-					ltmp = 0x0010; // Led 0 red color
-					if( (pHwData->LED_Blinking >= 9) || (pHwData->LED_Blinking%2) ) // Turn off 0.6 sec
-						ltmp = 0;
-					break;
-				case 4: // [300 On][ off ]
-					ltmp = 0x1000; // Led 1 Green color
-					if( pHwData->LED_Blinking >= 3000 )
-						ltmp = 0; // led maybe on after 300sec * 32bit counter overlap.
-					break;
-			}
-			pHwData->LED_Blinking++;
-
-			reg->U1BC_LEDConfigure = ltmp;
-			if( LEDSet != 7 ) // Only 111 mode has 2 LEDs on PCB.
-			{
-				reg->U1BC_LEDConfigure |= (ltmp &0xff)<<8; // Copy LED result to each LED control register
-				reg->U1BC_LEDConfigure |= (ltmp &0xff00)>>8;
-			}
-			Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-		}
-	}
-	else if( pHwData->CurrentRadioSw || pHwData->CurrentRadioHw ) // If radio off
-	{
-		if( reg->U1BC_LEDConfigure & 0x1010 )
-		{
-			reg->U1BC_LEDConfigure &= ~0x1010;
-			Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-		}
-	}
-	else
-	{
-		switch( LEDSet )
-		{
-			case 4: // [100] Only 1 Led be placed on PCB and use pin 21 of IC. Use LED_0 for showing
-				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
-				{
-					// Blinking if scanning is on progress
-					if( pHwData->LED_Scanning )
-					{
-						if( pHwData->LED_Blinking == 0 )
-						{
-							reg->U1BC_LEDConfigure |= 0x10;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 On
-							pHwData->LED_Blinking = 1;
-							TimeInterval = 300;
-						}
-						else
-						{
-							reg->U1BC_LEDConfigure &= ~0x10;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-							pHwData->LED_Blinking = 0;
-							TimeInterval = 300;
-						}
-					}
-					else
-					{
-						//Turn Off LED_0
-						if( reg->U1BC_LEDConfigure & 0x10 )
-						{
-							reg->U1BC_LEDConfigure &= ~0x10;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-						}
-					}
-				}
-				else
-				{
-					// Turn On LED_0
-					if( (reg->U1BC_LEDConfigure & 0x10) == 0 )
-					{
-						reg->U1BC_LEDConfigure |= 0x10;
-						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-					}
-				}
-				break;
-
-			case 6: // [110] Only 1 Led be placed on PCB and use pin 21 of IC. Use LED_0 for showing
-				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
-				{
-					// Blinking if scanning is on progress
-					if( pHwData->LED_Scanning )
-					{
-						if( pHwData->LED_Blinking == 0 )
-						{
-							reg->U1BC_LEDConfigure &= ~0xf;
-							reg->U1BC_LEDConfigure |= 0x10;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 On
-							pHwData->LED_Blinking = 1;
-							TimeInterval = 300;
-						}
-						else
-						{
-							reg->U1BC_LEDConfigure &= ~0x1f;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-							pHwData->LED_Blinking = 0;
-							TimeInterval = 300;
-						}
-					}
-					else
-					{
-						// 20060901 Gray blinking if in disconnect state and not scanning
-						ltmp = reg->U1BC_LEDConfigure;
-						reg->U1BC_LEDConfigure &= ~0x1f;
-						if( LEDgray2[(pHwData->LED_Blinking%30)] )
-						{
-							reg->U1BC_LEDConfigure |= 0x10;
-							reg->U1BC_LEDConfigure |= LEDgray2[ (pHwData->LED_Blinking%30) ];
-						}
-						pHwData->LED_Blinking++;
-						if( reg->U1BC_LEDConfigure != ltmp )
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-						TimeInterval = 100;
-					}
-				}
-				else
-				{
-					// Turn On LED_0
-					if( (reg->U1BC_LEDConfigure & 0x10) == 0 )
-					{
-						reg->U1BC_LEDConfigure |= 0x10;
-						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_0 Off
-					}
-				}
-				break;
+	pHwData->Wb35Tx.tx_halt = 1;
+	Wb35Tx_stop( pHwData );
 
-			case 5: // [101] Only 1 Led be placed on PCB and use LED_1 for showing
-				if( !pHwData->LED_LinkOn ) // Blink only if not Link On
-				{
-					// Blinking if scanning is on progress
-					if( pHwData->LED_Scanning )
-					{
-						if( pHwData->LED_Blinking == 0 )
-						{
-							reg->U1BC_LEDConfigure |= 0x1000;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
-							pHwData->LED_Blinking = 1;
-							TimeInterval = 300;
-						}
-						else
-						{
-							reg->U1BC_LEDConfigure &= ~0x1000;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 Off
-							pHwData->LED_Blinking = 0;
-							TimeInterval = 300;
-						}
-					}
-					else
-					{
-						//Turn Off LED_1
-						if( reg->U1BC_LEDConfigure & 0x1000 )
-						{
-							reg->U1BC_LEDConfigure &= ~0x1000;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 Off
-						}
-					}
-				}
-				else
-				{
-					// Is transmitting/receiving ??
-					if( (OS_CURRENT_RX_BYTE( adapter ) != pHwData->RxByteCountLast ) ||
-						(OS_CURRENT_TX_BYTE( adapter ) != pHwData->TxByteCountLast ) )
-					{
-						if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
-						{
-							reg->U1BC_LEDConfigure |= 0x3000;
-							Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
-						}
+	reg->D00_DmaControl &= ~0xc0000000;//Tx Off, Rx Off
+	Wb35Reg_Write( pHwData, 0x0400, reg->D00_DmaControl );
+}
 
-						// Update variable
-						pHwData->RxByteCountLast = OS_CURRENT_RX_BYTE( adapter );
-						pHwData->TxByteCountLast = OS_CURRENT_TX_BYTE( adapter );
-						TimeInterval = 200;
-					}
-					else
-					{
-						// Turn On LED_1 and blinking if transmitting/receiving
-						 if( (reg->U1BC_LEDConfigure & 0x3000) != 0x1000 )
-						 {
-							 reg->U1BC_LEDConfigure &= ~0x3000;
-							 reg->U1BC_LEDConfigure |= 0x1000;
-							 Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure ); // LED_1 On
-						 }
-					}
-				}
-				break;
+unsigned char hal_idle(phw_data_t pHwData)
+{
+	struct wb35_reg *reg = &pHwData->reg;
+	PWBUSB	pWbUsb = &pHwData->WbUsb;
 
-			default: // Default setting. 2 LED be placed on PCB. LED_0: Link On LED_1 Active
-				if( (reg->U1BC_LEDConfigure & 0x3000) != 0x3000 )
-				{
-					reg->U1BC_LEDConfigure |= 0x3000;// LED_1 is always on and event enable
-					Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-				}
+	if( !pHwData->SurpriseRemove && ( pWbUsb->DetectCount || reg->EP0vm_state!=VM_STOP ) )
+		return false;
 
-				if( pHwData->LED_Blinking )
-				{
-					// Gray blinking
-					reg->U1BC_LEDConfigure &= ~0x0f;
-					reg->U1BC_LEDConfigure |= 0x10;
-					reg->U1BC_LEDConfigure |= LEDgray[ (pHwData->LED_Blinking-1)%20 ];
-					Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
+	return true;
+}
+//---------------------------------------------------------------------------------------------------
+void hal_set_cwmin(  phw_data_t pHwData,  u8	cwin_min )
+{
+	struct wb35_reg *reg = &pHwData->reg;
 
-					pHwData->LED_Blinking += 2;
-					if( pHwData->LED_Blinking < 40 )
-						TimeInterval = 100;
-					else
-					{
-						pHwData->LED_Blinking = 0; // Stop blinking
-						reg->U1BC_LEDConfigure &= ~0x0f;
-						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-					}
-					break;
-				}
+	if( pHwData->SurpriseRemove ) return;
 
-				if( pHwData->LED_LinkOn )
-				{
-					if( !(reg->U1BC_LEDConfigure & 0x10) ) // Check the LED_0
-					{
-						//Try to turn ON LED_0 after gray blinking
-						reg->U1BC_LEDConfigure |= 0x10;
-						pHwData->LED_Blinking = 1; //Start blinking
-						TimeInterval = 50;
-					}
-				}
-				else
-				{
-					if( reg->U1BC_LEDConfigure & 0x10 ) // Check the LED_0
-					{
-						reg->U1BC_LEDConfigure &= ~0x10;
-						Wb35Reg_Write( pHwData, 0x03bc, reg->U1BC_LEDConfigure );
-					}
-				}
-				break;
-		}
+	pHwData->cwmin = cwin_min;
+	reg->M2C_MacControl &= ~0x7c00;	//bit 10 ~ 14
+	reg->M2C_MacControl |= (pHwData->cwmin<<10);
+	Wb35Reg_Write( pHwData, 0x082c, reg->M2C_MacControl );
+}
 
-		//20060828.1 Active send null packet to avoid AP disconnect
-		if( pHwData->LED_LinkOn )
+s32 hal_get_rssi(  phw_data_t pHwData,  u32 *HalRssiArry,  u8 Count )
+{
+	struct wb35_reg *reg = &pHwData->reg;
+	R01_DESCRIPTOR	r01;
+	s32 ltmp = 0, tmp;
+	u8	i;
+
+	if( pHwData->SurpriseRemove ) return -200;
+	if( Count > MAX_ACC_RSSI_COUNT ) // Because the TS may use this funtion
+		Count = MAX_ACC_RSSI_COUNT;
+
+	// RSSI = C1 + C2 * (agc_state[7:0] + offset_map(lna_state[1:0]))
+	// C1 = -195, C2 = 0.66 = 85/128
+	for (i=0; i<Count; i++)
+	{
+		r01.value = HalRssiArry[i];
+		tmp = ((( r01.R01_AGC_state + reg->LNAValue[r01.R01_LNA_state]) * 85 ) >>7 ) - 195;
+		ltmp += tmp;
+	}
+	ltmp /= Count;
+	if( pHwData->phy_type == RF_AIROHA_2230 ) ltmp -= 5; // 10;
+	if( pHwData->phy_type == RF_AIROHA_2230S ) ltmp -= 5; // 10; 20060420 Add this
+
+	//if( ltmp < -200 ) ltmp = -200;
+	if( ltmp < -110 ) ltmp = -110;// 1.0.24.0 For NJRC
+
+	return ltmp;
+}
+//----------------------------------------------------------------------------------------------------
+s32 hal_get_rssi_bss(  phw_data_t pHwData,  u16 idx,  u8 Count )
+{
+	struct wb35_reg *reg = &pHwData->reg;
+	R01_DESCRIPTOR	r01;
+	s32 ltmp = 0, tmp;
+	u8	i, j;
+	struct wb35_adapter *	adapter = pHwData->adapter;
+//	u32 *HalRssiArry = psBSS(idx)->HalRssi;
+
+	if( pHwData->SurpriseRemove ) return -200;
+	if( Count > MAX_ACC_RSSI_COUNT ) // Because the TS may use this funtion
+		Count = MAX_ACC_RSSI_COUNT;
+
+	// RSSI = C1 + C2 * (agc_state[7:0] + offset_map(lna_state[1:0]))
+	// C1 = -195, C2 = 0.66 = 85/128
+#if 0
+	for (i=0; i<Count; i++)
+	{
+		r01.value = HalRssiArry[i];
+		tmp = ((( r01.R01_AGC_state + reg->LNAValue[r01.R01_LNA_state]) * 85 ) >>7 ) - 195;
+		ltmp += tmp;
+	}
+#else
+	if (psBSS(idx)->HalRssiIndex == 0)
+		psBSS(idx)->HalRssiIndex = MAX_ACC_RSSI_COUNT;
+	j = (u8)psBSS(idx)->HalRssiIndex-1;
+
+	for (i=0; i<Count; i++)
+	{
+		r01.value = psBSS(idx)->HalRssi[j];
+		tmp = ((( r01.R01_AGC_state + reg->LNAValue[r01.R01_LNA_state]) * 85 ) >>7 ) - 195;
+		ltmp += tmp;
+		if (j == 0)
 		{
-			pHwData->NullPacketCount += TimeInterval;
-			if( pHwData->NullPacketCount >= DEFAULT_NULL_PACKET_COUNT )
-			{
-				pHwData->NullPacketCount = 0;
-			}
+			j = MAX_ACC_RSSI_COUNT;
 		}
+		j--;
 	}
+#endif
+	ltmp /= Count;
+	if( pHwData->phy_type == RF_AIROHA_2230 ) ltmp -= 5; // 10;
+	if( pHwData->phy_type == RF_AIROHA_2230S ) ltmp -= 5; // 10; 20060420 Add this
 
-	pHwData->time_count += TimeInterval;
-	Wb35Tx_CurrentTime( pHwData, pHwData->time_count ); // 20060928 add
-	OS_TIMER_SET( &pHwData->LEDTimer, TimeInterval ); // 20060623.1
+	//if( ltmp < -200 ) ltmp = -200;
+	if( ltmp < -110 ) ltmp = -110;// 1.0.24.0 For NJRC
+
+	return ltmp;
 }
 
+//---------------------------------------------------------------------------
 
 void hal_set_phy_type(  phw_data_t pHwData,  u8 PhyType )
 {
@@ -867,7 +868,8 @@ unsigned char hal_set_LED(phw_data_t pHw
 {
 	pHwData->LED_Blinking = 0;
 	pHwData->LED_control = Mode;
-	OS_TIMER_SET( &pHwData->LEDTimer, 10 ); // 20060623
+	pHwData->LEDTimer.expires = jiffies + msecs_to_jiffies(10);
+	add_timer(&pHwData->LEDTimer);
 	return true;
 }
 
--- a/drivers/staging/winbond/wbhal_f.h
+++ b/drivers/staging/winbond/wbhal_f.h
@@ -68,8 +68,6 @@ s32 hal_get_rssi(  phw_data_t pHwData,  
 s32 hal_get_rssi_bss(  phw_data_t pHwData,  u16 idx,  u8 Count );
 void hal_set_connect_info(  phw_data_t pHwData,  unsigned char boConnect );
 u8 hal_get_est_sq3(  phw_data_t pHwData,  u8 Count );
-void hal_led_control_1a(  phw_data_t pHwData );
-void hal_led_control(  void* S1,  phw_data_t pHwData,  void* S3,  void* S4 );
 void hal_set_rf_power(  phw_data_t pHwData,  u8 PowerIndex ); // 20060621 Modify
 void hal_reset_counter(  phw_data_t pHwData );
 void hal_set_radio_mode(  phw_data_t pHwData,  unsigned char boValue);
--- a/drivers/staging/winbond/wbhal_s.h
+++ b/drivers/staging/winbond/wbhal_s.h
@@ -510,7 +510,7 @@ typedef struct _HW_DATA_T
 	WB35TX		Wb35Tx; // Need Wb35Tx.h
 	WB35RX		Wb35Rx; // Need Wb35Rx.h
 
-	OS_TIMER	LEDTimer;// For LED
+	struct timer_list	LEDTimer;// For LED
 
 	u32		LEDpoint;// For LED
 
