From foo@baz Mon Aug 10 16:34:22 PDT 2009
Date: Mon, 10 Aug 2009 16:34:22 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Staging: rtl8192e: fix lots of sparse warnings

This removes a number of static and extern warnings that sparse
complains about.

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/rtl8192e/r8180_93cx6.c         |   10 -
 drivers/staging/rtl8192e/r8190_rtl8256.c       |   14 +-
 drivers/staging/rtl8192e/r8192E_core.c         |  168 ++++++++++++-------------
 drivers/staging/rtl8192e/r8192E_dm.c           |   55 ++------
 drivers/staging/rtl8192e/r8192E_wx.c           |    3 
 drivers/staging/rtl8192e/r819xE_cmdpkt.c       |   12 -
 drivers/staging/rtl8192e/r819xE_firmware.c     |   10 -
 drivers/staging/rtl8192e/r819xE_firmware_img.h |    6 
 drivers/staging/rtl8192e/r819xE_phy.c          |   38 ++---
 9 files changed, 145 insertions(+), 171 deletions(-)

--- a/drivers/staging/rtl8192e/r8180_93cx6.c
+++ b/drivers/staging/rtl8192e/r8180_93cx6.c
@@ -20,7 +20,7 @@
 
 #include "r8180_93cx6.h"
 
-void eprom_cs(struct net_device *dev, short bit)
+static void eprom_cs(struct net_device *dev, short bit)
 {
 	if(bit)
 		write_nic_byte(dev, EPROM_CMD,
@@ -35,7 +35,7 @@ void eprom_cs(struct net_device *dev, sh
 }
 
 
-void eprom_ck_cycle(struct net_device *dev)
+static void eprom_ck_cycle(struct net_device *dev)
 {
 	write_nic_byte(dev, EPROM_CMD,
 		       (1<<EPROM_CK_SHIFT) | read_nic_byte(dev,EPROM_CMD));
@@ -48,7 +48,7 @@ void eprom_ck_cycle(struct net_device *d
 }
 
 
-void eprom_w(struct net_device *dev,short bit)
+static void eprom_w(struct net_device *dev,short bit)
 {
 	if(bit)
 		write_nic_byte(dev, EPROM_CMD, (1<<EPROM_W_SHIFT) | \
@@ -62,7 +62,7 @@ void eprom_w(struct net_device *dev,shor
 }
 
 
-short eprom_r(struct net_device *dev)
+static short eprom_r(struct net_device *dev)
 {
 	short bit;
 
@@ -74,7 +74,7 @@ short eprom_r(struct net_device *dev)
 }
 
 
-void eprom_send_bits_string(struct net_device *dev, short b[], int len)
+static void eprom_send_bits_string(struct net_device *dev, short b[], int len)
 {
 	int i;
 
--- a/drivers/staging/rtl8192e/r8190_rtl8256.c
+++ b/drivers/staging/rtl8192e/r8190_rtl8256.c
@@ -418,7 +418,7 @@ void PHY_SetRF8256OFDMTxPower(struct net
 }
 
 #define MAX_DOZE_WAITING_TIMES_9x 64
-bool
+static bool
 SetRFPowerState8190(
 	struct net_device* dev,
 	RT_RF_POWER_STATE	eRFPowerState
@@ -717,7 +717,7 @@ SetRFPowerState8190(
 //
 //	050823, by rcnjko.
 //
-bool
+static bool
 SetRFPowerState(
 	struct net_device* dev,
 	RT_RF_POWER_STATE	eRFPowerState
@@ -745,7 +745,7 @@ SetRFPowerState(
 	return bResult;
 }
 
-void
+static void
 MgntDisconnectIBSS(
 	struct net_device* dev
 )
@@ -823,7 +823,7 @@ MgntDisconnectIBSS(
 
 }
 
-void
+static void
 MlmeDisassociateRequest(
 	struct net_device* dev,
 	u8* 		asSta,
@@ -837,7 +837,7 @@ MlmeDisassociateRequest(
 
 	SendDisassociation( priv->ieee80211, asSta, asRsn );
 
-	if(memcpy(priv->ieee80211->current_network.bssid,asSta,6) == 0)
+	if(memcpy(priv->ieee80211->current_network.bssid,asSta,6) == NULL)
 	{
 		//ShuChen TODO: change media status.
 		//ShuChen TODO: What to do when disassociate.
@@ -891,7 +891,7 @@ MlmeDisassociateRequest(
 }
 
 
-void
+static void
 MgntDisconnectAP(
 	struct net_device* dev,
 	u8 asRsn
@@ -945,7 +945,7 @@ MgntDisconnectAP(
 }
 
 
-bool
+static bool
 MgntDisconnect(
 	struct net_device* dev,
 	u8 asRsn
--- a/drivers/staging/rtl8192e/r8192E_core.c
+++ b/drivers/staging/rtl8192e/r8192E_core.c
@@ -269,7 +269,7 @@ static void rtl819x_set_channel_map(u8 c
 
 #define eqMacAddr(a,b) ( ((a)[0]==(b)[0] && (a)[1]==(b)[1] && (a)[2]==(b)[2] && (a)[3]==(b)[3] && (a)[4]==(b)[4] && (a)[5]==(b)[5]) ? 1:0 )
 /* 2007/07/25 MH Defien temp tx fw info. */
-TX_FWINFO_T 	Tmp_TxFwInfo;
+static TX_FWINFO_T Tmp_TxFwInfo;
 
 
 #define 	rx_hal_is_cck_rate(_pdrvinfo)\
@@ -723,7 +723,7 @@ static int proc_get_stats_rx(char *page,
 	return len;
 }
 
-void rtl8192_proc_module_init(void)
+static void rtl8192_proc_module_init(void)
 {
 	RT_TRACE(COMP_INIT, "Initializing proc filesystem");
 #if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
@@ -734,7 +734,7 @@ void rtl8192_proc_module_init(void)
 }
 
 
-void rtl8192_proc_module_remove(void)
+static void rtl8192_proc_module_remove(void)
 {
 #if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	remove_proc_entry(RTL819xE_MODULE_NAME, proc_net);
@@ -744,7 +744,7 @@ void rtl8192_proc_module_remove(void)
 }
 
 
-void rtl8192_proc_remove_one(struct net_device *dev)
+static void rtl8192_proc_remove_one(struct net_device *dev)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 
@@ -766,7 +766,7 @@ void rtl8192_proc_remove_one(struct net_
 }
 
 
-void rtl8192_proc_init_one(struct net_device *dev)
+static void rtl8192_proc_init_one(struct net_device *dev)
 {
 	struct proc_dir_entry *e;
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
@@ -857,7 +857,7 @@ void rtl8192_proc_init_one(struct net_de
 *****************************************************************************/
 
 /* this is only for debugging */
-void print_buffer(u32 *buffer, int len)
+static void print_buffer(u32 *buffer, int len)
 {
 	int i;
 	u8 *buf =(u8*)buffer;
@@ -890,7 +890,7 @@ short check_nic_enough_desc(struct net_d
     }
 }
 
-void tx_timeout(struct net_device *dev)
+static void tx_timeout(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	//rtl8192_commit(dev);
@@ -905,7 +905,7 @@ void tx_timeout(struct net_device *dev)
 
 
 /* this is only for debug */
-void dump_eprom(struct net_device *dev)
+static void dump_eprom(struct net_device *dev)
 {
 	int i;
 	for(i=0; i<0xff; i++)
@@ -913,7 +913,7 @@ void dump_eprom(struct net_device *dev)
 }
 
 /* this is only for debug */
-void rtl8192_dump_reg(struct net_device *dev)
+static void rtl8192_dump_reg(struct net_device *dev)
 {
 	int i;
 	int n;
@@ -935,7 +935,7 @@ void rtl8192_dump_reg(struct net_device 
 *****************************************************************************/
 
 
-void rtl8192_irq_enable(struct net_device *dev)
+static void rtl8192_irq_enable(struct net_device *dev)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 	priv->irq_enabled = 1;
@@ -943,7 +943,7 @@ void rtl8192_irq_enable(struct net_devic
 }
 
 
-void rtl8192_irq_disable(struct net_device *dev)
+static void rtl8192_irq_disable(struct net_device *dev)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 
@@ -953,7 +953,7 @@ void rtl8192_irq_disable(struct net_devi
 }
 
 
-void rtl8192_set_mode(struct net_device *dev,int mode)
+static void rtl8192_set_mode(struct net_device *dev,int mode)
 {
 	u8 ecmd;
 	ecmd=read_nic_byte(dev, EPROM_CMD);
@@ -1044,7 +1044,7 @@ void rtl8192_rx_enable(struct net_device
  *  HIGH_QUEUE     ===>                        7
  *  BEACON_QUEUE   ===>                        8
  *  */
-u32 TX_DESC_BASE[] = {BKQDA, BEQDA, VIQDA, VOQDA, HCCAQDA, CQDA, MQDA, HQDA, BQDA};
+static u32 TX_DESC_BASE[] = {BKQDA, BEQDA, VIQDA, VOQDA, HCCAQDA, CQDA, MQDA, HQDA, BQDA};
 void rtl8192_tx_enable(struct net_device *dev)
 {
     struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
@@ -1111,7 +1111,7 @@ static void rtl8192_free_tx_ring(struct 
 }
 
 
-void rtl8192_beacon_disable(struct net_device *dev)
+static void rtl8192_beacon_disable(struct net_device *dev)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 	u32 reg;
@@ -1149,7 +1149,7 @@ void rtl8192_rtx_disable(struct net_devi
 	return;
 }
 
-void rtl8192_reset(struct net_device *dev)
+static void rtl8192_reset(struct net_device *dev)
 {
     rtl8192_irq_disable(dev);
     printk("This is RTL819xP Reset procedure\n");
@@ -1164,11 +1164,7 @@ inline u16 rtl8192_rate2rate(short rate)
 
 
 
-u32
-rtl819xusb_rx_command_packet(
-	struct net_device *dev,
-	struct ieee80211_rx_stats *pstats
-	)
+static u32 rtl819xusb_rx_command_packet(struct net_device *dev, struct ieee80211_rx_stats *pstats)
 {
 	u32	status;
 
@@ -1204,7 +1200,7 @@ void rtl8192_tx_queues_stop(struct net_d
 }
 #endif
 
-void rtl8192_data_hard_stop(struct net_device *dev)
+static void rtl8192_data_hard_stop(struct net_device *dev)
 {
 	//FIXME !!
 	#if 0
@@ -1217,7 +1213,7 @@ void rtl8192_data_hard_stop(struct net_d
 }
 
 
-void rtl8192_data_hard_resume(struct net_device *dev)
+static void rtl8192_data_hard_resume(struct net_device *dev)
 {
 	// FIXME !!
 	#if 0
@@ -1232,7 +1228,7 @@ void rtl8192_data_hard_resume(struct net
 /* this function TX data frames when the ieee80211 stack requires this.
  * It checks also if we need to stop the ieee tx queue, eventually do it
  */
-void rtl8192_hard_data_xmit(struct sk_buff *skb, struct net_device *dev, int rate)
+static void rtl8192_hard_data_xmit(struct sk_buff *skb, struct net_device *dev, int rate)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 	int ret;
@@ -1274,7 +1270,7 @@ void rtl8192_hard_data_xmit(struct sk_bu
  * If the ring is full packet are dropped (for data frame the queue
  * is stopped before this can happen).
  */
-int rtl8192_hard_start_xmit(struct sk_buff *skb,struct net_device *dev)
+static int rtl8192_hard_start_xmit(struct sk_buff *skb,struct net_device *dev)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 
@@ -1319,7 +1315,7 @@ int rtl8192_hard_start_xmit(struct sk_bu
 
 void rtl8192_try_wake_queue(struct net_device *dev, int pri);
 
-void rtl8192_tx_isr(struct net_device *dev, int prio)
+static void rtl8192_tx_isr(struct net_device *dev, int prio)
 {
     struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 
@@ -1360,12 +1356,12 @@ void rtl8192_tx_isr(struct net_device *d
 
 }
 
-void rtl8192_stop_beacon(struct net_device *dev)
+static void rtl8192_stop_beacon(struct net_device *dev)
 {
 	//rtl8192_beacon_disable(dev);
 }
 
-void rtl8192_config_rate(struct net_device* dev, u16* rate_config)
+static void rtl8192_config_rate(struct net_device* dev, u16* rate_config)
 {
 	 struct r8192_priv *priv = ieee80211_priv(dev);
 	 struct ieee80211_network *net;
@@ -1416,7 +1412,7 @@ void rtl8192_config_rate(struct net_devi
 #define SHORT_SLOT_TIME 9
 #define NON_SHORT_SLOT_TIME 20
 
-void rtl8192_update_cap(struct net_device* dev, u16 cap)
+static void rtl8192_update_cap(struct net_device* dev, u16 cap)
 {
 	u32 tmp = 0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1441,7 +1437,8 @@ void rtl8192_update_cap(struct net_devic
 	}
 
 }
-void rtl8192_net_update(struct net_device *dev)
+
+static void rtl8192_net_update(struct net_device *dev)
 {
 
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1495,7 +1492,7 @@ inline u8 rtl8192_IsWirelessBMode(u16 ra
 
 u16 N_DBPSOfRate(u16 DataRate);
 
-u16 ComputeTxTime(
+static u16 ComputeTxTime(
 	u16		FrameLength,
 	u16		DataRate,
 	u8		bManagementFrame,
@@ -1572,7 +1569,8 @@ u16 N_DBPSOfRate(u16 DataRate)
 	 return N_DBPS;
 }
 
-unsigned int txqueue2outpipe(unsigned int tx_queue) {
+static unsigned int txqueue2outpipe(unsigned int tx_queue)
+{
 	unsigned int outpipe = 0x04;
 
 	switch (tx_queue) {
@@ -1681,7 +1679,7 @@ void rtl819xE_tx_cmd(struct net_device *
  *
  * \param QUEUEID       Software Queue
 */
-u8 MapHwQueueToFirmwareQueue(u8 QueueID)
+static u8 MapHwQueueToFirmwareQueue(u8 QueueID)
 {
 	u8 QueueSelect = 0x0;       //defualt set to
 
@@ -1727,7 +1725,7 @@ u8 MapHwQueueToFirmwareQueue(u8 QueueID)
 	return QueueSelect;
 }
 
-u8 MRateToHwRate8190Pci(u8 rate)
+static u8 MRateToHwRate8190Pci(u8 rate)
 {
 	u8  ret = DESC90_RATE1M;
 
@@ -1770,7 +1768,7 @@ u8 MRateToHwRate8190Pci(u8 rate)
 }
 
 
-u8 QueryIsShort(u8 TxHT, u8 TxRate, cb_desc *tcb_desc)
+static u8 QueryIsShort(u8 TxHT, u8 TxRate, cb_desc *tcb_desc)
 {
 	u8   tmp_Short;
 
@@ -1971,7 +1969,7 @@ short rtl8192_tx(struct net_device *dev,
     return 0;
 }
 
-short rtl8192_alloc_rx_desc_ring(struct net_device *dev)
+static short rtl8192_alloc_rx_desc_ring(struct net_device *dev)
 {
     struct r8192_priv *priv = ieee80211_priv(dev);
     rx_desc_819x_pci *entry = NULL;
@@ -2038,7 +2036,7 @@ static int rtl8192_alloc_tx_desc_ring(st
 }
 
 
-short rtl8192_pci_initdescring(struct net_device *dev)
+static short rtl8192_pci_initdescring(struct net_device *dev)
 {
     u32 ret;
     int i;
@@ -2072,7 +2070,7 @@ err_free_rings:
     return 1;
 }
 
-void rtl8192_pci_resetdescring(struct net_device *dev)
+static void rtl8192_pci_resetdescring(struct net_device *dev)
 {
     struct r8192_priv *priv = ieee80211_priv(dev);
     int i;
@@ -2109,7 +2107,7 @@ void rtl8192_pci_resetdescring(struct ne
 
 #if 1
 extern void rtl8192_update_ratr_table(struct net_device* dev);
-void rtl8192_link_change(struct net_device *dev)
+static void rtl8192_link_change(struct net_device *dev)
 {
 //	int i;
 
@@ -2160,7 +2158,7 @@ static struct ieee80211_qos_parameters d
 };
 
 #if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
-void rtl8192_update_beacon(struct work_struct * work)
+static void rtl8192_update_beacon(struct work_struct * work)
 {
         struct r8192_priv *priv = container_of(work, struct r8192_priv, update_beacon_wq.work);
         struct net_device *dev = priv->ieee80211->dev;
@@ -2180,9 +2178,9 @@ void rtl8192_update_beacon(struct net_de
 /*
 * background support to run QoS activate functionality
 */
-int WDCAPARA_ADD[] = {EDCAPARA_BE,EDCAPARA_BK,EDCAPARA_VI,EDCAPARA_VO};
+static int WDCAPARA_ADD[] = {EDCAPARA_BE,EDCAPARA_BK,EDCAPARA_VI,EDCAPARA_VO};
 #if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
-void rtl8192_qos_activate(struct work_struct * work)
+static void rtl8192_qos_activate(struct work_struct * work)
 {
         struct r8192_priv *priv = container_of(work, struct r8192_priv, qos_activate);
         struct net_device *dev = priv->ieee80211->dev;
@@ -2430,7 +2428,7 @@ void rtl8192_update_ratr_table(struct ne
 
 static u8 ccmp_ie[4] = {0x00,0x50,0xf2,0x04};
 static u8 ccmp_rsn_ie[4] = {0x00, 0x0f, 0xac, 0x04};
-bool GetNmodeSupportBySecCfg8190Pci(struct net_device*dev)
+static bool GetNmodeSupportBySecCfg8190Pci(struct net_device*dev)
 {
 #if 1
 	struct r8192_priv* priv = ieee80211_priv(dev);
@@ -2475,7 +2473,7 @@ bool GetNmodeSupportBySecCfg8190Pci(stru
 #endif
 }
 
-void rtl8192_refresh_supportrate(struct r8192_priv* priv)
+static void rtl8192_refresh_supportrate(struct r8192_priv* priv)
 {
 	struct ieee80211_device* ieee = priv->ieee80211;
 	//we donot consider set support rate for ABG mode, only HT MCS rate is set here.
@@ -2490,7 +2488,7 @@ void rtl8192_refresh_supportrate(struct 
 	return;
 }
 
-u8 rtl8192_getSupportedWireleeMode(struct net_device*dev)
+static u8 rtl8192_getSupportedWireleeMode(struct net_device*dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 ret = 0;
@@ -2510,7 +2508,8 @@ u8 rtl8192_getSupportedWireleeMode(struc
 	}
 	return ret;
 }
-void rtl8192_SetWirelessMode(struct net_device* dev, u8 wireless_mode)
+
+static void rtl8192_SetWirelessMode(struct net_device* dev, u8 wireless_mode)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 bSupportMode = rtl8192_getSupportedWireleeMode(dev);
@@ -2559,7 +2558,7 @@ void rtl8192_SetWirelessMode(struct net_
 }
 //init priv variables here
 
-bool GetHalfNmodeSupportByAPs819xPci(struct net_device* dev)
+static bool GetHalfNmodeSupportByAPs819xPci(struct net_device* dev)
 {
 	bool			Reval;
 	struct r8192_priv* priv = ieee80211_priv(dev);
@@ -2595,13 +2594,13 @@ void rtl8192_rq_tx_ack(struct net_device
 	priv->ieee80211->ack_tx_to_ieee = 1;
 }
 #endif
-void rtl8192_hw_sleep_down(struct net_device *dev)
+static void rtl8192_hw_sleep_down(struct net_device *dev)
 {
 	RT_TRACE(COMP_POWER, "%s()============>come to sleep down\n", __FUNCTION__);
 	MgntActSet_RF_State(dev, eRfSleep, RF_CHANGE_BY_PS);
 }
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
-void rtl8192_hw_sleep_wq (struct work_struct *work)
+static void rtl8192_hw_sleep_wq (struct work_struct *work)
 {
 //      struct r8180_priv *priv = container_of(work, struct r8180_priv, watch_dog_wq);
 //      struct ieee80211_device * ieee = (struct ieee80211_device*)
@@ -2618,7 +2617,7 @@ void rtl8192_hw_sleep_wq(struct net_devi
 }
 //	printk("dev is %d\n",dev);
 //	printk("&*&(^*(&(&=========>%s()\n", __FUNCTION__);
-void rtl8192_hw_wakeup(struct net_device* dev)
+static void rtl8192_hw_wakeup(struct net_device* dev)
 {
 //	u32 flags = 0;
 
@@ -2647,7 +2646,7 @@ void rtl8192_hw_wakeup_wq(struct net_dev
 
 #define MIN_SLEEP_TIME 50
 #define MAX_SLEEP_TIME 10000
-void rtl8192_hw_to_sleep(struct net_device *dev, u32 th, u32 tl)
+static void rtl8192_hw_to_sleep(struct net_device *dev, u32 th, u32 tl)
 {
 
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -3468,7 +3467,7 @@ static void rtl8192_read_eeprom_info(str
 }
 
 
-short rtl8192_get_channel_map(struct net_device * dev)
+static short rtl8192_get_channel_map(struct net_device * dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 #ifdef ENABLE_DOT11D
@@ -3496,7 +3495,8 @@ short rtl8192_get_channel_map(struct net
 #endif
 	return 0;
 }
-short rtl8192_init(struct net_device *dev)
+
+static short rtl8192_init(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	memset(&(priv->stats),0,sizeof(struct Stats));
@@ -3543,7 +3543,7 @@ short rtl8192_init(struct net_device *de
  *  return:  none
  *  notice:  This part need to modified according to the rate set we filtered
  * ****************************************************************************/
-void rtl8192_hwconfig(struct net_device* dev)
+static void rtl8192_hwconfig(struct net_device* dev)
 {
 	u32 regRATR = 0, regRRSR = 0;
 	u8 regBwOpMode = 0, regTmp = 0;
@@ -3616,7 +3616,7 @@ void rtl8192_hwconfig(struct net_device*
 }
 
 
-RT_STATUS rtl8192_adapter_start(struct net_device *dev)
+static RT_STATUS rtl8192_adapter_start(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 //	struct ieee80211_device *ieee = priv->ieee80211;
@@ -3833,11 +3833,8 @@ RT_STATUS rtl8192_adapter_start(struct n
 	//3Beacon related
 	write_nic_word(dev, ATIMWND, 2);
 	write_nic_word(dev, BCN_INTERVAL, 100);
-	{
-		int i;
-		for (i=0; i<QOS_QUEUE_NUM; i++)
+	for (i=0; i<QOS_QUEUE_NUM; i++)
 		write_nic_dword(dev, WDCAPARA_ADD[i], 0x005e4332);
-	}
 	//
 	// Switching regulator controller: This is set temporarily.
 	// It's not sure if this can be removed in the future.
@@ -4185,7 +4182,7 @@ static struct net_device_stats *rtl8192_
 
 
 
-bool HalTxCheckStuck8190Pci(struct net_device *dev)
+static bool HalTxCheckStuck8190Pci(struct net_device *dev)
 {
 	u16 				RegTxCounter = read_nic_word(dev, 0x128);
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -4203,7 +4200,7 @@ bool HalTxCheckStuck8190Pci(struct net_d
 *	<Assumption: RT_TX_SPINLOCK is acquired.>
 *	First added: 2006.11.19 by emily
 */
-RESET_TYPE
+static RESET_TYPE
 TxCheckStuck(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -4307,7 +4304,7 @@ TxCheckStuck(struct net_device *dev)
 }
 
 
-bool HalRxCheckStuck8190Pci(struct net_device *dev)
+static bool HalRxCheckStuck8190Pci(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u16 				RegRxCounter = read_nic_word(dev, 0x130);
@@ -4377,7 +4374,7 @@ bool HalRxCheckStuck8190Pci(struct net_d
 	return bStuck;
 }
 
-RESET_TYPE RxCheckStuck(struct net_device *dev)
+static RESET_TYPE RxCheckStuck(struct net_device *dev)
 {
 
 	if(HalRxCheckStuck8190Pci(dev))
@@ -4389,7 +4386,7 @@ RESET_TYPE RxCheckStuck(struct net_devic
 	return RESET_TYPE_NORESET;
 }
 
-RESET_TYPE
+static RESET_TYPE
 rtl819x_ifcheck_resetornot(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -4428,7 +4425,7 @@ rtl819x_ifcheck_resetornot(struct net_de
 }
 
 
-void CamRestoreAllEntry(	struct net_device *dev)
+static void CamRestoreAllEntry(struct net_device *dev)
 {
 	u8 EntryId = 0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -4571,7 +4568,7 @@ int _rtl8192_up(struct net_device *dev);
  * The method checking Tx/Rx stuck of this function is supported by FW,
  * which reports Tx and Rx counter to register 0x128 and 0x130.
  * */
-void rtl819x_ifsilentreset(struct net_device *dev)
+static void rtl819x_ifsilentreset(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8	reset_times = 0;
@@ -4793,7 +4790,7 @@ IPSLeave(struct net_device *dev)
 	}
 }
 #endif
-void CAM_read_entry(
+static void CAM_read_entry(
 	struct net_device *dev,
 	u32	 		iIndex
 )
@@ -4834,7 +4831,7 @@ void CAM_read_entry(
 	printk("\n");
 }
 
-void rtl819x_update_rxcounts(
+static void rtl819x_update_rxcounts(
 	struct r8192_priv *priv,
 	u32* TotalRxBcnNum,
 	u32* TotalRxDataNum
@@ -4857,7 +4854,7 @@ void rtl819x_update_rxcounts(
 
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
-extern	void	rtl819x_watchdog_wqcallback(struct work_struct *work)
+void rtl819x_watchdog_wqcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,watch_dog_wq);
@@ -5016,7 +5013,7 @@ int _rtl8192_up(struct net_device *dev)
 }
 
 
-int rtl8192_open(struct net_device *dev)
+static int rtl8192_open(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	int ret;
@@ -5039,7 +5036,7 @@ int rtl8192_up(struct net_device *dev)
 }
 
 
-int rtl8192_close(struct net_device *dev)
+static int rtl8192_close(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	int ret;
@@ -5175,7 +5172,7 @@ static void r8192_set_multicast(struct n
 }
 
 
-int r8192_set_mac_adr(struct net_device *dev, void *mac)
+static int r8192_set_mac_adr(struct net_device *dev, void *mac)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	struct sockaddr *addr = mac;
@@ -5195,7 +5192,7 @@ int r8192_set_mac_adr(struct net_device 
 }
 
 /* based on ipw2200 driver */
-int rtl8192_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+static int rtl8192_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 	struct iwreq *wrq = (struct iwreq *)rq;
@@ -5317,7 +5314,7 @@ out:
 	return ret;
 }
 
-u8 HwRateToMRate90(bool bIsHT, u8 rate)
+static u8 HwRateToMRate90(bool bIsHT, u8 rate)
 {
 	u8  ret_rate = 0x02;
 
@@ -5385,7 +5382,7 @@ u8 HwRateToMRate90(bool bIsHT, u8 rate)
  * Return:
  *               None
  */
-void UpdateRxPktTimeStamp8190 (struct net_device *dev, struct ieee80211_rx_stats *stats)
+static void UpdateRxPktTimeStamp8190 (struct net_device *dev, struct ieee80211_rx_stats *stats)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 
@@ -5398,7 +5395,7 @@ void UpdateRxPktTimeStamp8190 (struct ne
 	}
 }
 
-long rtl819x_translate_todbm(u8 signal_strength_index	)// 0-100 index.
+static long rtl819x_translate_todbm(u8 signal_strength_index)// 0-100 index.
 {
 	long	signal_power; // in dBm.
 
@@ -5419,7 +5416,7 @@ long rtl819x_translate_todbm(u8 signal_s
 //		In normal operation, user only care about the information of the BSS
 //		and we shall invoke this function if the packet received is from the BSS.
 //
-void
+static void
 rtl819x_update_rxsignalstatistics8190pci(
 	struct r8192_priv * priv,
 	struct ieee80211_rx_stats * pprevious_stats
@@ -5446,7 +5443,7 @@ rtl819x_update_rxsignalstatistics8190pci
 	priv->stats.recv_signal_power = (priv->stats.recv_signal_power * 5 + pprevious_stats->RecvSignalPower + weighting) / 6;
 }
 
-void
+static void
 rtl8190_process_cck_rxpathsel(
 	struct r8192_priv * priv,
 	struct ieee80211_rx_stats * pprevious_stats
@@ -5511,7 +5508,7 @@ rtl8190_process_cck_rxpathsel(
 	be a local static. Otherwise, it may increase when we return from S3/S4. The
 	value will be kept in memory or disk. We must delcare the value in adapter
 	and it will be reinitialized when return from S3/S4. */
-void rtl8192_process_phyinfo(struct r8192_priv * priv, u8* buffer,struct ieee80211_rx_stats * pprevious_stats, struct ieee80211_rx_stats * pcurrent_stats)
+static void rtl8192_process_phyinfo(struct r8192_priv * priv, u8* buffer,struct ieee80211_rx_stats * pprevious_stats, struct ieee80211_rx_stats * pcurrent_stats)
 {
 	bool bcheck = false;
 	u8	rfpath;
@@ -5820,10 +5817,7 @@ rtl819x_evm_dbtopercentage(
 //	We want good-looking for signal strength/quality
 //	2007/7/19 01:09, by cosa.
 //
-long
-rtl819x_signal_scale_mapping(
-	long currsig
-	)
+static long rtl819x_signal_scale_mapping(long currsig)
 {
 	long retsig;
 
@@ -6150,7 +6144,7 @@ static void rtl8192_query_rxphystatus(
 	}
 }	/* QueryRxPhyStatus8190Pci */
 
-void
+static void
 rtl8192_record_rxdesc_forlateruse(
 	struct ieee80211_rx_stats * psrc_stats,
 	struct ieee80211_rx_stats * ptarget_stats
@@ -6163,7 +6157,7 @@ rtl8192_record_rxdesc_forlateruse(
 
 
 
-void TranslateRxSignalStuff819xpci(struct net_device *dev,
+static void TranslateRxSignalStuff819xpci(struct net_device *dev,
         struct sk_buff *skb,
         struct ieee80211_rx_stats * pstats,
         prx_desc_819x_pci pdesc,
@@ -6229,7 +6223,7 @@ void TranslateRxSignalStuff819xpci(struc
 }
 
 
-void rtl8192_tx_resume(struct net_device *dev)
+static void rtl8192_tx_resume(struct net_device *dev)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 	struct ieee80211_device *ieee = priv->ieee80211;
@@ -6272,7 +6266,7 @@ void rtl8192_irq_tx_tasklet(struct r8192
 * Return:
 *		None
 */
-void UpdateReceivedRateHistogramStatistics8190(
+static void UpdateReceivedRateHistogramStatistics8190(
 	struct net_device *dev,
 	struct ieee80211_rx_stats* pstats
 	)
@@ -6343,7 +6337,7 @@ void UpdateReceivedRateHistogramStatisti
 	priv->stats.received_rate_histogram[rcvType][rateIndex]++;
 }
 
-void rtl8192_rx(struct net_device *dev)
+static void rtl8192_rx(struct net_device *dev)
 {
     struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
     struct ieee80211_hdr_1addr *ieee80211_hdr = NULL;
--- a/drivers/staging/rtl8192e/r8192E_dm.c
+++ b/drivers/staging/rtl8192e/r8192E_dm.c
@@ -202,8 +202,7 @@ static	void	dm_ctstoself(struct net_devi
 //		This function is only invoked at driver intialization once.
 //
 //
-extern	void
-init_hal_dm(struct net_device *dev)
+void init_hal_dm(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -230,7 +229,7 @@ init_hal_dm(struct net_device *dev)
 
 }	// InitHalDm
 
-extern void deinit_hal_dm(struct net_device *dev)
+void deinit_hal_dm(struct net_device *dev)
 {
 
 	dm_deInit_fsync(dev);
@@ -296,7 +295,7 @@ void dm_CheckRxAggregation(struct net_de
 
 
 
-extern  void    hal_dm_watchdog(struct net_device *dev)
+void hal_dm_watchdog(struct net_device *dev)
 {
         //struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -334,7 +333,7 @@ extern  void    hal_dm_watchdog(struct n
   *	01/16/2008	MHC		RF_Type is assigned in ReadAdapterInfo(). We must call
   *						the function after making sure RF_Type.
   */
-extern void init_rate_adaptive(struct net_device * dev)
+void init_rate_adaptive(struct net_device * dev)
 {
 
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1053,7 +1052,7 @@ static void dm_TXPowerTrackingCallback_T
 }
 #endif
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
-extern	void	dm_txpower_trackingcallback(struct work_struct *work)
+void dm_txpower_trackingcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,txpower_tracking_wq);
@@ -1837,10 +1836,7 @@ static void dm_CCKTxPowerAdjust_ThermalM
 #endif
 
 
-extern void dm_cck_txpower_adjust(
-	struct net_device *dev,
-	bool  binch14
-)
+void dm_cck_txpower_adjust(struct net_device *dev, bool binch14)
 {	// dm_CCKTxPowerAdjust
 #ifndef RTL8190P
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1879,7 +1875,7 @@ static void dm_txpower_reset_recovery(
 
 }	// dm_TXPowerResetRecovery
 
-extern void dm_restore_dynamic_mechanism_state(struct net_device *dev)
+void dm_restore_dynamic_mechanism_state(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 	reg_ratr = priv->rate_adaptive.last_ratr;
@@ -1963,7 +1959,7 @@ static void dm_bb_initialgain_restore(st
 }	// dm_BBInitialGainRestore
 
 
-extern void dm_backup_dynamic_mechanism_state(struct net_device *dev)
+void dm_backup_dynamic_mechanism_state(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -2018,9 +2014,7 @@ static void dm_bb_initialgain_backup(str
  *	05/29/2008	amy		Create Version 0 porting from windows code.
  *
  *---------------------------------------------------------------------------*/
-extern void dm_change_dynamic_initgain_thresh(struct net_device *dev,
-								u32		dm_type,
-								u32		dm_value)
+void dm_change_dynamic_initgain_thresh(struct net_device *dev, u32 dm_type, u32	dm_value)
 {
 	if (dm_type == DIG_TYPE_THRESH_HIGH)
 	{
@@ -2087,11 +2081,8 @@ extern void dm_change_dynamic_initgain_t
 		dm_digtable.rx_gain_range_max = (u8)dm_value;
 	}
 }	/* DM_ChangeDynamicInitGainThresh */
-extern	void
-dm_change_fsync_setting(
-	struct net_device *dev,
-	s32		DM_Type,
-	s32		DM_Value)
+
+static void dm_change_fsync_setting(struct net_device *dev, s32 DM_Type, s32 DM_Value)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -2104,11 +2095,7 @@ dm_change_fsync_setting(
 	}
 }
 
-extern void
-dm_change_rxpath_selection_setting(
-	struct net_device *dev,
-	s32		DM_Type,
-	s32		DM_Value)
+static void dm_change_rxpath_selection_setting(struct net_device *dev, s32 DM_Type, s32 DM_Value)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	prate_adaptive 	pRA = (prate_adaptive)&(priv->rate_adaptive);
@@ -2183,9 +2170,7 @@ dm_change_rxpath_selection_setting(
 }
 
 #if 0
-extern void dm_force_tx_fw_info(struct net_device *dev,
-										u32		force_type,
-										u32		force_value)
+void dm_force_tx_fw_info(struct net_device *dev, u32 force_type, u32 force_value)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -2832,7 +2817,7 @@ static	void dm_cs_ratio(
 	}
 }
 
-extern void dm_init_edca_turbo(struct net_device * dev)
+void dm_init_edca_turbo(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -2956,7 +2941,7 @@ dm_CheckEdcaTurbo_EXIT:
 }	// dm_CheckEdcaTurbo
 #endif
 
-extern void DM_CTSToSelfSetting(struct net_device * dev,u32 DM_Type, u32 DM_Value)
+static void DM_CTSToSelfSetting(struct net_device *dev, u32 DM_Type, u32 DM_Value)
 {
 	struct r8192_priv *priv = ieee80211_priv((struct net_device *)dev);
 
@@ -3054,7 +3039,7 @@ static void dm_ctstoself(struct net_devi
  *	05/29/2008	amy		Create Version 0 porting from windows code.
  *
  *---------------------------------------------------------------------------*/
-extern void dm_rf_operation_test_callback(unsigned long dev)
+void dm_rf_operation_test_callback(unsigned long dev)
 {
 //	struct r8192_priv *priv = ieee80211_priv((struct net_device *)dev);
 	u8 erfpath;
@@ -3215,7 +3200,7 @@ static	void	dm_check_pbc_gpio(struct net
  *
  *---------------------------------------------------------------------------*/
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
-extern	void	dm_gpio_change_rf_callback(struct work_struct *work)
+void dm_gpio_change_rf_callback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,gpio_change_rf_wq);
@@ -3291,7 +3276,7 @@ extern	void	dm_gpio_change_rf_callback(s
  *
  *---------------------------------------------------------------------------*/
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
-extern	void	dm_rf_pathcheck_workitemcallback(struct work_struct *work)
+void dm_rf_pathcheck_workitemcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,rfpath_check_wq);
@@ -3667,7 +3652,7 @@ static void dm_deInit_fsync(struct net_d
 	del_timer_sync(&priv->fsync_timer);
 }
 
-extern void dm_fsync_timer_callback(unsigned long data)
+void dm_fsync_timer_callback(unsigned long data)
 {
 	struct net_device *dev = (struct net_device *)data;
 	struct r8192_priv *priv = ieee80211_priv((struct net_device *)data);
@@ -4092,7 +4077,7 @@ extern	s1Byte	DM_CheckLBusStatus(IN	PADA
  *	05/29/2008	amy		Create Version 0 porting from windows code.
  *
  *---------------------------------------------------------------------------*/
-extern void dm_shadow_init(struct net_device *dev)
+void dm_shadow_init(struct net_device *dev)
 {
 	u8	page;
 	u16	offset;
--- a/drivers/staging/rtl8192e/r8192E_wx.c
+++ b/drivers/staging/rtl8192e/r8192E_wx.c
@@ -20,12 +20,13 @@
 #include <linux/string.h>
 #include "r8192E.h"
 #include "r8192E_hw.h"
+#include "r8192E_wx.h"
 #ifdef ENABLE_DOT11D
 #include "dot11d.h"
 #endif
 
 #define RATE_COUNT 12
-u32 rtl8180_rates[] = {1000000,2000000,5500000,11000000,
+static u32 rtl8180_rates[] = {1000000,2000000,5500000,11000000,
 	6000000,9000000,12000000,18000000,24000000,36000000,48000000,54000000};
 
 
--- a/drivers/staging/rtl8192e/r819xE_cmdpkt.c
+++ b/drivers/staging/rtl8192e/r819xE_cmdpkt.c
@@ -59,7 +59,7 @@
  *	05/06/2008	amy		porting from windows code.
  *
  *---------------------------------------------------------------------------*/
- extern	RT_STATUS cmpk_message_handle_tx(
+RT_STATUS cmpk_message_handle_tx(
 	struct net_device *dev,
 	u8*	code_virtual_address,
 	u32	packettype,
@@ -352,10 +352,7 @@ cmpk_handle_tx_feedback(
 
 }	/* cmpk_Handle_Tx_Feedback */
 
-void
-cmdpkt_beacontimerinterrupt_819xusb(
-	struct net_device *dev
-)
+static void cmdpkt_beacontimerinterrupt_819xusb(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u16 tx_rate;
@@ -713,10 +710,7 @@ cmpk_handle_tx_rate_history(
  *  05/06/2008	amy		Create Version 0 porting from windows code.
  *
  *---------------------------------------------------------------------------*/
-extern	u32
-cmpk_message_handle_rx(
-	struct net_device *dev,
-	struct ieee80211_rx_stats *pstats)
+u32 cmpk_message_handle_rx(struct net_device *dev, struct ieee80211_rx_stats *pstats)
 {
 //	u32			debug_level = DBG_LOUD;
 	struct r8192_priv *priv = ieee80211_priv(dev);
--- a/drivers/staging/rtl8192e/r819xE_firmware.c
+++ b/drivers/staging/rtl8192e/r819xE_firmware.c
@@ -24,7 +24,7 @@
 #include <linux/firmware.h>
 #endif
 
-extern void firmware_init_param(struct net_device *dev)
+void firmware_init_param(struct net_device *dev)
 {
 	struct r8192_priv 	*priv = ieee80211_priv(dev);
 	rt_firmware		*pfirmware = priv->pFirmware;
@@ -36,7 +36,7 @@ extern void firmware_init_param(struct n
  * segment the img and use the ptr and length to remember info on each segment
  *
  */
-bool fw_download_code(struct net_device *dev, u8 *code_virtual_address, u32 buffer_len)
+static bool fw_download_code(struct net_device *dev, u8 *code_virtual_address, u32 buffer_len)
 {
 	struct r8192_priv   *priv = ieee80211_priv(dev);
 	bool 		    rt_status = true;
@@ -107,7 +107,7 @@ cmdsend_downloadcode_fail:
 #endif
 }
 
-bool
+static bool
 fwSendNullPacket(
 	struct net_device *dev,
 	u32			Length
@@ -159,7 +159,7 @@ fwSendNullPacket(
 //        NDIS_STATUS_FAILURE - the following initialization process should be terminated
 //        NDIS_STATUS_SUCCESS - if firmware initialization process success
 //-----------------------------------------------------------------------------
-bool CPUcheck_maincodeok_turnonCPU(struct net_device *dev)
+static bool CPUcheck_maincodeok_turnonCPU(struct net_device *dev)
 {
 	bool		rt_status = true;
 	int		check_putcodeOK_time = 200000, check_bootOk_time = 200000;
@@ -208,7 +208,7 @@ CPUCheckMainCodeOKAndTurnOnCPU_Fail:
 	return rt_status;
 }
 
-bool CPUcheck_firmware_ready(struct net_device *dev)
+static bool CPUcheck_firmware_ready(struct net_device *dev)
 {
 
 	bool		rt_status = true;
--- a/drivers/staging/rtl8192e/r819xE_firmware_img.h
+++ b/drivers/staging/rtl8192e/r819xE_firmware_img.h
@@ -4,7 +4,7 @@
 /*Created on  2008/ 8/28, 11:46*/
 #include <linux/types.h>
 
-u8 rtl8192e_fwboot_array[] = {
+static u8 rtl8192e_fwboot_array[] = {
 0x10,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x3c,0x08,0xbf,0xc0,0x25,0x08,0x00,0x08,
 0x3c,0x09,0xb0,0x03,0xad,0x28,0x00,0x20,0x40,0x80,0x68,0x00,0x00,0x00,0x00,0x00,
 0x3c,0x0a,0xd0,0x00,0x40,0x8a,0x60,0x00,0x00,0x00,0x00,0x00,0x3c,0x08,0x80,0x01,
@@ -28,7 +28,7 @@ u8 rtl8192e_fwboot_array[] = {
 0xad,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x08,0x80,0x00,0x25,0x08,0x4b,0x94,
 0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x00,};
 
-u8 rtl8192e_fwmain_array[] = {
+static u8 rtl8192e_fwmain_array[] = {
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
@@ -2719,7 +2719,7 @@ u8 rtl8192e_fwmain_array[] = {
 0xa3,0xa3,0x00,0x00,0xa0,0x40,0x00,0x00,0x90,0x43,0x00,0x00,0x03,0xe0,0x00,0x08,
 0x27,0xbd,0x00,0x08,};
 
-u8 rtl8192e_fwdata_array[] = {
+static u8 rtl8192e_fwdata_array[] = {
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x10,0x00,0x08,0x00,
 0x02,0xe9,0x01,0x74,0x02,0xab,0x01,0xc7,0x01,0x55,0x00,0xe4,0x00,0xab,0x00,0x72,
 0x00,0x55,0x00,0x4c,0x00,0x4c,0x00,0x4c,0x00,0x4c,0x00,0x4c,0x02,0x76,0x01,0x3b,
--- a/drivers/staging/rtl8192e/r819xE_phy.c
+++ b/drivers/staging/rtl8192e/r819xE_phy.c
@@ -857,7 +857,7 @@ u32 Rtl8190PciRadioD_Array[RadioD_ArrayL
 };
 #endif
 #ifdef RTL8192E
-u32 Rtl8192PciEMACPHY_Array[] = {
+static u32 Rtl8192PciEMACPHY_Array[] = {
 0x03c,0xffff0000,0x00000f0f,
 0x340,0xffffffff,0x161a1a1a,
 0x344,0xffffffff,0x12121416,
@@ -865,7 +865,7 @@ u32 Rtl8192PciEMACPHY_Array[] = {
 0x12c,0xffffffff,0x04000802,
 0x318,0x00000fff,0x00000100,
 };
-u32 Rtl8192PciEMACPHY_Array_PG[] = {
+static u32 Rtl8192PciEMACPHY_Array_PG[] = {
 0x03c,0xffff0000,0x00000f0f,
 0xe00,0xffffffff,0x06090909,
 0xe04,0xffffffff,0x00030306,
@@ -877,7 +877,7 @@ u32 Rtl8192PciEMACPHY_Array_PG[] = {
 0x12c,0xffffffff,0x04000802,
 0x318,0x00000fff,0x00000800,
 };
-u32 Rtl8192PciEAGCTAB_Array[AGCTAB_ArrayLength] = {
+static u32 Rtl8192PciEAGCTAB_Array[AGCTAB_ArrayLength] = {
 0xc78,0x7d000001,
 0xc78,0x7d010001,
 0xc78,0x7d020001,
@@ -1071,9 +1071,9 @@ u32 Rtl8192PciEAGCTAB_Array[AGCTAB_Array
 0xc78,0x693e001e,
 0xc78,0x6a3f001e,
 };
-u32 Rtl8192PciEPHY_REGArray[PHY_REGArrayLength] = {
+static u32 Rtl8192PciEPHY_REGArray[PHY_REGArrayLength] = {
 0x0, };
-u32 Rtl8192PciEPHY_REG_1T2RArray[PHY_REG_1T2RArrayLength] = {
+static u32 Rtl8192PciEPHY_REG_1T2RArray[PHY_REG_1T2RArrayLength] = {
 0x800,0x00000000,
 0x804,0x00000001,
 0x808,0x0000fc00,
@@ -1223,7 +1223,7 @@ u32 Rtl8192PciEPHY_REG_1T2RArray[PHY_REG
 0xe18,0x161a1a1a,
 0xe1c,0x12121416,
 };
-u32 Rtl8192PciERadioA_Array[RadioA_ArrayLength] = {
+static u32 Rtl8192PciERadioA_Array[RadioA_ArrayLength] = {
 0x019,0x00000003,
 0x000,0x000000bf,
 0x001,0x00000ee0,
@@ -1348,7 +1348,7 @@ u32 Rtl8192PciERadioA_Array[RadioA_Array
 0x004,0x00000975,
 0x007,0x00000700,
 };
-u32 Rtl8192PciERadioB_Array[RadioB_ArrayLength] = {
+static u32 Rtl8192PciERadioB_Array[RadioB_ArrayLength] = {
 0x019,0x00000003,
 0x000,0x000000bf,
 0x001,0x000006e0,
@@ -1389,9 +1389,9 @@ u32 Rtl8192PciERadioB_Array[RadioB_Array
 0x004,0x00000975,
 0x007,0x00000700,
 };
-u32 Rtl8192PciERadioC_Array[RadioC_ArrayLength] = {
+static u32 Rtl8192PciERadioC_Array[RadioC_ArrayLength] = {
 0x0,  };
-u32 Rtl8192PciERadioD_Array[RadioD_ArrayLength] = {
+static u32 Rtl8192PciERadioD_Array[RadioD_ArrayLength] = {
 0x0, };
 #endif
 
@@ -1407,7 +1407,7 @@ static void phy_FwRFSerialWrite(struct n
  *  output:  none
  *  return:  u32	return the shift bit bit position of the mask
  * ****************************************************************************/
-u32 rtl8192_CalculateBitShift(u32 dwBitMask)
+static u32 rtl8192_CalculateBitShift(u32 dwBitMask)
 {
 	u32 i;
 	for (i=0; i<=31; i++)
@@ -1507,7 +1507,7 @@ u32 rtl8192_QueryBBReg(struct net_device
  *  return:  u32 	readback value
  *  notice:  There are three types of serial operations:(1) Software serial write.(2)Hardware LSSI-Low Speed Serial Interface.(3)Hardware HSSI-High speed serial write. Driver here need to implement (1) and (2)---need more spec for this information.
  * ****************************************************************************/
-u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset)
+static u32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 ret = 0;
@@ -1623,7 +1623,7 @@ u32 rtl8192_phy_RFSerialRead(struct net_
  * Reg_Mode2	1		1			Reg 31 ~ 45(0x1 ~ 0xf)
  *------------------------------------------------------------------
  * ****************************************************************************/
-void rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
+static void rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32 DataAndAddr = 0, NewOffset = 0;
@@ -2051,7 +2051,7 @@ void rtl8192_phyConfigBB(struct net_devi
  *  return:  none
  *  notice:  Initialization value here is constant and it should never be changed
  * ***************************************************************************/
-void rtl8192_InitBBRFRegDef(struct net_device* dev)
+static void rtl8192_InitBBRFRegDef(struct net_device* dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 // RF Interface Sowrtware Control
@@ -2236,7 +2236,7 @@ RT_STATUS rtl8192_phy_checkBBAndRF(struc
  *  notice:  Initialization value may change all the time, so please make
  *           sure it has been synced with the newest.
  * ***************************************************************************/
-RT_STATUS rtl8192_BB_Config_ParaFile(struct net_device* dev)
+static RT_STATUS rtl8192_BB_Config_ParaFile(struct net_device* dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	RT_STATUS rtStatus = RT_STATUS_SUCCESS;
@@ -2627,7 +2627,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(st
  *  return:  none
  *    Note:
  * ***************************************************************************/
-void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
+static void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8	powerlevel = priv->TxPowerLevelCCK[channel-1];
@@ -2668,7 +2668,7 @@ void rtl8192_SetTxPowerLevel(struct net_
  *  return:  true if finished, false otherwise
  *    Note:
  * ************************************************************************************/
-u8 rtl8192_phy_SetSwChnlCmdArray(
+static u8 rtl8192_phy_SetSwChnlCmdArray(
 	SwChnlCmd*		CmdTable,
 	u32			CmdTableIdx,
 	u32			CmdTableSz,
@@ -2711,7 +2711,7 @@ u8 rtl8192_phy_SetSwChnlCmdArray(
  *  return:  true if finished, false otherwise
  *    Note:  Wait for simpler function to replace it //wb
  * ***************************************************************************/
-u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8* stage, u8* step, u32* delay)
+static u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8* stage, u8* step, u32* delay)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 //	PCHANNEL_ACCESS_SETTING	pChnlAccessSetting;
@@ -2863,7 +2863,7 @@ u8 rtl8192_phy_SwChnlStepByStep(struct n
  *  return:  noin
  *    Note:  We should not call this function directly
  * ***************************************************************************/
-void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
+static void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u32	delay = 0;
@@ -3279,7 +3279,7 @@ void rtl8192_SetBWMode(struct net_device
 }
 
 
-extern void InitialGain819xPci(struct net_device *dev, u8 Operation)
+void InitialGain819xPci(struct net_device *dev, u8 Operation)
 {
 #define SCAN_RX_INITIAL_GAIN	0x17
 #define POWER_DETECTION_TH	0x08
