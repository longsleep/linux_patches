From foo@baz Wed Jul 29 15:40:57 PDT 2009
Date: Wed, 29 Jul 2009 15:40:57 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: Staging: hv: remove timer wrapper functions

From: Greg Kroah-Hartman <gregkh@suse.de>

Use a real timer (there's only one in the code), no wrapper is needed,
it just increases the complexity for no reason.

Cc: Bill Pemberton <wfp5p@virginia.edu>
Cc: Hank Janssen <hjanssen@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/hv/Channel.c     |   17 +++++++--------
 drivers/staging/hv/Channel.h     |    5 ----
 drivers/staging/hv/ChannelMgmt.c |   12 +++-------
 drivers/staging/hv/ChannelMgmt.h |    2 -
 drivers/staging/hv/include/osd.h |   15 -------------
 drivers/staging/hv/osd.c         |   43 ---------------------------------------
 6 files changed, 14 insertions(+), 80 deletions(-)

--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -696,7 +696,7 @@ VmbusChannelClose(
 
 	/* Stop callback and cancel the timer asap */
 	Channel->OnChannelCallback = NULL;
-	osd_TimerStop(Channel->PollTimer);
+	del_timer(&Channel->poll_timer);
 
 	/* Send a closing message */
 	info = kmalloc(sizeof(VMBUS_CHANNEL_MSGINFO) + sizeof(VMBUS_CHANNEL_CLOSE_CHANNEL), GFP_KERNEL);
@@ -1154,9 +1154,10 @@ VmbusChannelOnChannelEvent(
 	DumpVmbusChannel(Channel);
 	ASSERT(Channel->OnChannelCallback);
 #ifdef ENABLE_POLLING
-	osd_TimerStop(Channel->PollTimer);
+	del_timer(&Channel->poll_timer);
 	Channel->OnChannelCallback(Channel->ChannelCallbackContext);
-	osd_TimerStart(Channel->PollTimer, 100 /* 100us */);
+	channel->poll_timer.expires(jiffies + usecs_to_jiffies(100);
+	add_timer(&channel->poll_timer);
 #else
 	Channel->OnChannelCallback(Channel->ChannelCallbackContext);
 #endif
@@ -1171,18 +1172,16 @@ Description:
 	Timer event callback
 
 --*/
-static void
-VmbusChannelOnTimer(
-	void		*Context
-	)
+static void VmbusChannelOnTimer(unsigned long data)
 {
-	VMBUS_CHANNEL *channel = (VMBUS_CHANNEL*)Context;
+	VMBUS_CHANNEL *channel = (VMBUS_CHANNEL*)data;
 
 	if (channel->OnChannelCallback)
 	{
 		channel->OnChannelCallback(channel->ChannelCallbackContext);
 #ifdef ENABLE_POLLING
-		osd_TimerStart(channel->PollTimer, 100 /* 100us */);
+		channel->poll_timer.expires(jiffies + usecs_to_jiffies(100);
+		add_timer(&channel->poll_timer);
 #endif
 	}
 }
--- a/drivers/staging/hv/Channel.h
+++ b/drivers/staging/hv/Channel.h
@@ -150,8 +150,5 @@ VmbusChannelGetDebugInfo(
 	VMBUS_CHANNEL_DEBUG_INFO	*DebugInfo
 	);
 
-static void
-VmbusChannelOnTimer(
-	void		*Context
-	);
+static void VmbusChannelOnTimer(unsigned long data);
 #endif /* _CHANNEL_H_ */
--- a/drivers/staging/hv/ChannelMgmt.c
+++ b/drivers/staging/hv/ChannelMgmt.c
@@ -141,18 +141,14 @@ static VMBUS_CHANNEL* AllocVmbusChannel(
 
 	spin_lock_init(&channel->inbound_lock);
 
-	channel->PollTimer = osd_TimerCreate(VmbusChannelOnTimer, channel);
-	if (!channel->PollTimer)
-	{
-		kfree(channel);
-		return NULL;
-	}
+	init_timer(&channel->poll_timer);
+	channel->poll_timer.data = (unsigned long)channel;
+	channel->poll_timer.function = VmbusChannelOnTimer;
 
 	/* channel->dataWorkQueue = WorkQueueCreate("data"); */
 	channel->ControlWQ = create_workqueue("hv_vmbus_ctl");
 	if (!channel->ControlWQ)
 	{
-		osd_TimerClose(channel->PollTimer);
 		kfree(channel);
 		return NULL;
 	}
@@ -195,7 +191,7 @@ Description:
 --*/
 static void FreeVmbusChannel(VMBUS_CHANNEL* Channel)
 {
-	osd_TimerClose(Channel->PollTimer);
+	del_timer(&Channel->poll_timer);
 
 	/* We have to release the channel's workqueue/thread in the vmbus's workqueue/thread context */
 	/* ie we can't destroy ourselves. */
--- a/drivers/staging/hv/ChannelMgmt.h
+++ b/drivers/staging/hv/ChannelMgmt.h
@@ -47,7 +47,7 @@ typedef struct _VMBUS_CHANNEL {
 
 	struct hv_device *DeviceObject;
 
-	struct osd_timer *PollTimer; /* SA-111 workaround */
+	struct timer_list poll_timer; /* SA-111 workaround */
 
 	VMBUS_CHANNEL_STATE			State;
 
--- a/drivers/staging/hv/include/osd.h
+++ b/drivers/staging/hv/include/osd.h
@@ -47,9 +47,6 @@ typedef struct _DLIST_ENTRY {
 
 /* typedef unsigned char		GUID[16]; */
 
-typedef void (*PFN_TIMER_CALLBACK)(void* context);
-
-
 typedef struct {
 	unsigned char	Data[16];
 } GUID;
@@ -59,13 +56,6 @@ struct osd_waitevent {
 	wait_queue_head_t event;
 };
 
-struct osd_timer {
-	struct timer_list timer;
-	PFN_TIMER_CALLBACK callback;
-	void* context;
-};
-
-
 /* Osd routines */
 
 extern void *osd_VirtualAllocExec(unsigned int size);
@@ -73,11 +63,6 @@ extern void *osd_VirtualAllocExec(unsign
 extern void *osd_PageAlloc(unsigned int count);
 extern void osd_PageFree(void* page, unsigned int count);
 
-extern struct osd_timer *osd_TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context);
-extern void osd_TimerClose(struct osd_timer *t);
-extern int osd_TimerStop(struct osd_timer *t);
-extern void osd_TimerStart(struct osd_timer *t, u32 expirationInUs);
-
 extern struct osd_waitevent *osd_WaitEventCreate(void);
 extern void osd_WaitEventSet(struct osd_waitevent *waitEvent);
 extern int osd_WaitEventWait(struct osd_waitevent *waitEvent);
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -34,7 +34,6 @@
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
 #include <linux/kernel.h>
-#include <linux/timer.h>
 #include <linux/jiffies.h>
 #include <linux/delay.h>
 #include <linux/time.h>
@@ -88,48 +87,6 @@ void osd_PageFree(void* page, unsigned i
 	__free_page(p);*/
 }
 
-static void TimerCallback(unsigned long data)
-{
-	struct osd_timer *t = (struct osd_timer *) data;
-
-	t->callback(t->context);
-}
-
-struct osd_timer *osd_TimerCreate(PFN_TIMER_CALLBACK pfnTimerCB, void* context)
-{
-	struct osd_timer *t = kmalloc(sizeof(struct osd_timer), GFP_KERNEL);
-	if (!t)
-	{
-		return NULL;
-	}
-
-	t->callback = pfnTimerCB;
-	t->context = context;
-
-	init_timer(&t->timer);
-	t->timer.data = (unsigned long)t;
-	t->timer.function = TimerCallback;
-
-	return t;
-}
-
-void osd_TimerStart(struct osd_timer *t, u32 expirationInUs)
-{
-	t->timer.expires = jiffies + usecs_to_jiffies(expirationInUs);
-	add_timer(&t->timer);
-}
-
-int osd_TimerStop(struct osd_timer *t)
-{
-	return del_timer(&t->timer);
-}
-
-void osd_TimerClose(struct osd_timer *t)
-{
-	del_timer(&t->timer);
-	kfree(t);
-}
-
 struct osd_waitevent *osd_WaitEventCreate(void)
 {
 	struct osd_waitevent *wait = kmalloc(sizeof(struct osd_waitevent), GFP_KERNEL);
