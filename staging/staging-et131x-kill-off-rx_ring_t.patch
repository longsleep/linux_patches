From alan@linux.intel.com  Wed Jan 27 15:43:53 2010
From: Alan Cox <alan@linux.intel.com>
Date: Mon, 18 Jan 2010 15:34:07 +0000
Subject: Staging: et131x: Kill off RX_RING_t
To: greg@kroah.com
Message-ID: <20100118153407.6884.50296.stgit@localhost.localdomain>


This completes the typedef clean up of the rx specific structures, although
there is plenty do on field names and the like

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/et131x/et1310_rx.c      |   54 ++++++++++++++++----------------
 drivers/staging/et131x/et1310_rx.h      |    8 ++--
 drivers/staging/et131x/et131x_adapter.h |    2 -
 drivers/staging/et131x/et131x_isr.c     |    2 -
 4 files changed, 33 insertions(+), 33 deletions(-)

--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -109,10 +109,10 @@ int et131x_rx_dma_memory_alloc(struct et
 	u32 i, j;
 	u32 bufsize;
 	u32 pktStatRingSize, FBRChunkSize;
-	RX_RING_t *rx_ring;
+	struct rx_ring *rx_ring;
 
 	/* Setup some convenience pointers */
-	rx_ring = (RX_RING_t *) &adapter->RxRing;
+	rx_ring = &adapter->rx_ring;
 
 	/* Alloc memory for the lookup table */
 #ifdef USE_FBR0
@@ -162,10 +162,10 @@ int et131x_rx_dma_memory_alloc(struct et
 	}
 
 #ifdef USE_FBR0
-	adapter->RxRing.PsrNumEntries = adapter->RxRing.Fbr0NumEntries +
-	    adapter->RxRing.Fbr1NumEntries;
+	adapter->rx_ring.PsrNumEntries = adapter->rx_ring.Fbr0NumEntries +
+	    adapter->rx_ring.Fbr1NumEntries;
 #else
-	adapter->RxRing.PsrNumEntries = adapter->RxRing.Fbr1NumEntries;
+	adapter->rx_ring.PsrNumEntries = adapter->rx_ring.Fbr1NumEntries;
 #endif
 
 	/* Allocate an area of memory for Free Buffer Ring 1 */
@@ -338,7 +338,7 @@ int et131x_rx_dma_memory_alloc(struct et
 
 	/* Allocate an area of memory for FIFO of Packet Status ring entries */
 	pktStatRingSize =
-	    sizeof(struct pkt_stat_desc) * adapter->RxRing.PsrNumEntries;
+	    sizeof(struct pkt_stat_desc) * adapter->rx_ring.PsrNumEntries;
 
 	rx_ring->pPSRingVa = pci_alloc_consistent(adapter->pdev,
 						  pktStatRingSize,
@@ -402,10 +402,10 @@ void et131x_rx_dma_memory_free(struct et
 	u32 bufsize;
 	u32 pktStatRingSize;
 	PMP_RFD rfd;
-	RX_RING_t *rx_ring;
+	struct rx_ring *rx_ring;
 
 	/* Setup some convenience pointers */
-	rx_ring = (RX_RING_t *) &adapter->RxRing;
+	rx_ring = &adapter->rx_ring;
 
 	/* Free RFDs and associated packet descriptors */
 	WARN_ON(rx_ring->nReadyRecv != rx_ring->NumRfd);
@@ -416,7 +416,7 @@ void et131x_rx_dma_memory_free(struct et
 
 		list_del(&rfd->list_node);
 		rfd->Packet = NULL;
-		kmem_cache_free(adapter->RxRing.RecvLookaside, rfd);
+		kmem_cache_free(adapter->rx_ring.RecvLookaside, rfd);
 	}
 
 	/* Free Free Buffer Ring 1 */
@@ -496,7 +496,7 @@ void et131x_rx_dma_memory_free(struct et
 	/* Free Packet Status Ring */
 	if (rx_ring->pPSRingVa) {
 		pktStatRingSize =
-		    sizeof(struct pkt_stat_desc) * adapter->RxRing.PsrNumEntries;
+		    sizeof(struct pkt_stat_desc) * adapter->rx_ring.PsrNumEntries;
 
 		pci_free_consistent(adapter->pdev, pktStatRingSize,
 				    rx_ring->pPSRingVa, rx_ring->pPSRingPa);
@@ -545,10 +545,10 @@ int et131x_init_recv(struct et131x_adapt
 	PMP_RFD rfd = NULL;
 	u32 rfdct;
 	u32 numrfd = 0;
-	RX_RING_t *rx_ring = NULL;
+	struct rx_ring *rx_ring;
 
 	/* Setup some convenience pointers */
-	rx_ring = (RX_RING_t *) &adapter->RxRing;
+	rx_ring = &adapter->rx_ring;
 
 	/* Setup each RFD */
 	for (rfdct = 0; rfdct < rx_ring->NumRfd; rfdct++) {
@@ -592,7 +592,7 @@ int et131x_init_recv(struct et131x_adapt
 void ConfigRxDmaRegs(struct et131x_adapter *etdev)
 {
 	struct rxdma_regs __iomem *rx_dma = &etdev->regs->rxdma;
-	struct _rx_ring_t *rx_local = &etdev->RxRing;
+	struct rx_ring *rx_local = &etdev->rx_ring;
 	struct fbr_desc *fbr_entry;
 	u32 entry;
 	u32 psr_num_des;
@@ -741,19 +741,19 @@ void et131x_rx_dma_enable(struct et131x_
 	/* Setup the receive dma configuration register for normal operation */
 	u32 csr =  0x2000;	/* FBR1 enable */
 
-	if (etdev->RxRing.Fbr1BufferSize == 4096)
+	if (etdev->rx_ring.Fbr1BufferSize == 4096)
 		csr |= 0x0800;
-	else if (etdev->RxRing.Fbr1BufferSize == 8192)
+	else if (etdev->rx_ring.Fbr1BufferSize == 8192)
 		csr |= 0x1000;
-	else if (etdev->RxRing.Fbr1BufferSize == 16384)
+	else if (etdev->rx_ring.Fbr1BufferSize == 16384)
 		csr |= 0x1800;
 #ifdef USE_FBR0
         csr |= 0x0400;		/* FBR0 enable */
-	if (etdev->RxRing.Fbr0BufferSize == 256)
+	if (etdev->rx_ring.Fbr0BufferSize == 256)
 	        csr |= 0x0100;
-	else if (etdev->RxRing.Fbr0BufferSize == 512)
+	else if (etdev->rx_ring.Fbr0BufferSize == 512)
 		csr |= 0x0200;
-	else if (etdev->RxRing.Fbr0BufferSize == 1024)
+	else if (etdev->rx_ring.Fbr0BufferSize == 1024)
 		csr |= 0x0300;
 #endif
 	writel(csr, &etdev->regs->rxdma.csr);
@@ -783,7 +783,7 @@ void et131x_rx_dma_enable(struct et131x_
  */
 PMP_RFD nic_rx_pkts(struct et131x_adapter *etdev)
 {
-	struct _rx_ring_t *rx_local = &etdev->RxRing;
+	struct rx_ring *rx_local = &etdev->rx_ring;
 	struct rx_status_block *status;
 	struct pkt_stat_desc *psr;
 	PMP_RFD rfd;
@@ -1006,7 +1006,7 @@ PMP_RFD nic_rx_pkts(struct et131x_adapte
  */
 void et131x_reset_recv(struct et131x_adapter *etdev)
 {
-	WARN_ON(list_empty(&etdev->RxRing.RecvList));
+	WARN_ON(list_empty(&etdev->rx_ring.RecvList));
 
 }
 
@@ -1024,8 +1024,8 @@ void et131x_handle_recv_interrupt(struct
 
 	/* Process up to available RFD's */
 	while (count < NUM_PACKETS_HANDLED) {
-		if (list_empty(&etdev->RxRing.RecvList)) {
-			WARN_ON(etdev->RxRing.nReadyRecv != 0);
+		if (list_empty(&etdev->rx_ring.RecvList)) {
+			WARN_ON(etdev->rx_ring.nReadyRecv != 0);
 			done = false;
 			break;
 		}
@@ -1050,7 +1050,7 @@ void et131x_handle_recv_interrupt(struct
 		etdev->Stats.ipackets++;
 
 		/* Set the status on the packet, either resources or success */
-		if (etdev->RxRing.nReadyRecv < RFD_LOW_WATER_MARK) {
+		if (etdev->rx_ring.nReadyRecv < RFD_LOW_WATER_MARK) {
 			dev_warn(&etdev->pdev->dev,
 				    "RFD's are running out\n");
 		}
@@ -1058,12 +1058,12 @@ void et131x_handle_recv_interrupt(struct
 	}
 
 	if (count == NUM_PACKETS_HANDLED || !done) {
-		etdev->RxRing.UnfinishedReceives = true;
+		etdev->rx_ring.UnfinishedReceives = true;
 		writel(PARM_TX_TIME_INT_DEF * NANO_IN_A_MICRO,
 		       &etdev->regs->global.watchdog_timer);
 	} else
 		/* Watchdog timer will disable itself if appropriate. */
-		etdev->RxRing.UnfinishedReceives = false;
+		etdev->rx_ring.UnfinishedReceives = false;
 }
 
 static inline u32 bump_fbr(u32 *fbr, u32 limit)
@@ -1091,7 +1091,7 @@ static inline u32 bump_fbr(u32 *fbr, u32
  */
 void nic_return_rfd(struct et131x_adapter *etdev, PMP_RFD rfd)
 {
-	struct _rx_ring_t *rx_local = &etdev->RxRing;
+	struct rx_ring *rx_local = &etdev->rx_ring;
 	struct rxdma_regs __iomem *rx_dma = &etdev->regs->rxdma;
 	u16 bi = rfd->bufferindex;
 	u8 ri = rfd->ringindex;
--- a/drivers/staging/et131x/et1310_rx.h
+++ b/drivers/staging/et131x/et1310_rx.h
@@ -191,10 +191,10 @@ struct fbr_lookup {
 };
 
 /*
- * RX_RING_t is sructure representing the adaptor's local reference(s) to the
- * rings
+ * struct rx_ring is the ssructure representing the adaptor's local
+ * reference(s) to the rings
  */
-typedef struct _rx_ring_t {
+struct rx_ring {
 #ifdef USE_FBR0
 	void *pFbr0RingVa;
 	dma_addr_t pFbr0RingPa;
@@ -239,7 +239,7 @@ typedef struct _rx_ring_t {
 
 	/* lookaside lists */
 	struct kmem_cache *RecvLookaside;
-} RX_RING_t, *PRX_RING_t;
+};
 
 /* Forward reference of RFD */
 struct _MP_RFD;
--- a/drivers/staging/et131x/et131x_adapter.h
+++ b/drivers/staging/et131x/et131x_adapter.h
@@ -248,7 +248,7 @@ struct et131x_adapter {
 	struct tx_ring tx_ring;
 
 	/* Rx Memory Variables */
-	RX_RING_t RxRing;
+	struct rx_ring rx_ring;
 
 	/* Loopback specifics */
 	u8 ReplicaPhyLoopbk;	/* Replica Enable */
--- a/drivers/staging/et131x/et131x_isr.c
+++ b/drivers/staging/et131x/et131x_isr.c
@@ -185,7 +185,7 @@ irqreturn_t et131x_isr(int irq, void *de
 			if (++tcb->stale > 1)
 				status |= ET_INTR_TXDMA_ISR;
 
-		if (adapter->RxRing.UnfinishedReceives)
+		if (adapter->rx_ring.UnfinishedReceives)
 			status |= ET_INTR_RXDMA_XFR_DONE;
 		else if (tcb == NULL)
 			writel(0, &adapter->regs->global.watchdog_timer);
