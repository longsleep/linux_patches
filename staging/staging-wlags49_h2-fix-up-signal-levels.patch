From henk.de.groot@hetnet.nl  Mon Dec  7 16:22:10 2009
From: Henk de Groot <henk.de.groot@hetnet.nl>
Date: Sun, 06 Dec 2009 21:29:31 +0100
Subject: Staging: wlags49_h2: fix up signal levels
To: Greg KH <greg@kroah.com>
Cc: Greg KH <gregkh@suse.de>,  Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>, Andrew Morton <akpm@linux-foundation.org>,  Randy Dunlap <randy.dunlap@oracle.com>
Message-ID: <4B1C142B.4040905@hetnet.nl>


Adjusts the signal levels reported by the wlags49_h2 and wlags49_h25 staging
drivers. With the constants supplied by Agere the signal levels are always
poor, even in close proximity to the AP. The signals are now measured with
a real device. 100% for close proximity to the AP, 0% for the noice floor.
Now the levels shown by the NetworkManager gauge make sense.

Some magic numbers in the related code are replaced by the correct constants
from the wireless extension interface (wireless.h). Also the flag IW_QUAL_DBM
is now set, as specified in the wireless.h header file.

Signed-off-by: Henk de Groot <pe1dnn@amsat.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/staging/wlags49_h2/wl_if.h   |   31 +++++++++++++++++++++++++------
 drivers/staging/wlags49_h2/wl_wext.c |   19 ++++++++++++++-----
 2 files changed, 39 insertions(+), 11 deletions(-)

--- a/drivers/staging/wlags49_h2/wl_if.h
+++ b/drivers/staging/wlags49_h2/wl_if.h
@@ -80,13 +80,32 @@
 #define TX_TIMEOUT                  ((800 * HZ) / 1000)
 
 
+//#define HCF_MIN_COMM_QUALITY        0
+//#define HCF_MAX_COMM_QUALITY        92
+//#define HCF_MIN_SIGNAL_LEVEL        47
+//#define HCF_MAX_SIGNAL_LEVEL        138
+//#define HCF_MIN_NOISE_LEVEL         47
+//#define HCF_MAX_NOISE_LEVEL         138
+//#define HCF_0DBM_OFFSET             149
+
+// PE1DNN
+// Better data from the real world. Not scientific but empirical data gathered
+// from a Thomson Speedtouch 110 which is identified as:
+// PCMCIA Info: "Agere Systems" "Wireless PC Card Model 0110"
+//              Manufacture ID: 0156,0003
+// Lowest measurment for noise floor seen is value 54
+// Highest signal strength in close proximity to the AP seen is value 118
+// Very good must be arround 100 (otherwise its never "full scale"
+// All other constants are derrived from these. This makes the signal gauge
+// work for me...
+#define HCF_MIN_SIGNAL_LEVEL        54
+#define HCF_MAX_SIGNAL_LEVEL        100
+#define HCF_MIN_NOISE_LEVEL         HCF_MIN_SIGNAL_LEVEL
+#define HCF_MAX_NOISE_LEVEL         HCF_MAX_SIGNAL_LEVEL
+#define HCF_0DBM_OFFSET             (HCF_MAX_SIGNAL_LEVEL + 1)
 #define HCF_MIN_COMM_QUALITY        0
-#define HCF_MAX_COMM_QUALITY        92
-#define HCF_MIN_SIGNAL_LEVEL        47
-#define HCF_MAX_SIGNAL_LEVEL        138
-#define HCF_MIN_NOISE_LEVEL         47
-#define HCF_MAX_NOISE_LEVEL         138
-#define HCF_0DBM_OFFSET             149
+#define HCF_MAX_COMM_QUALITY        (HCF_MAX_SIGNAL_LEVEL - HCF_MIN_NOISE_LEVEL + 1)
+
 
 /* For encryption (WEP) */
 #define MIN_KEY_SIZE                5       // 40 bits RC4 - WEP
--- a/drivers/staging/wlags49_h2/wl_wext.c
+++ b/drivers/staging/wlags49_h2/wl_wext.c
@@ -2770,7 +2770,7 @@ static int wireless_get_scan(struct net_
 		iwe.u.qual.level    = dbm(probe_resp->signal);
 		iwe.u.qual.noise    = dbm(probe_resp->silence);
 		iwe.u.qual.qual     = iwe.u.qual.level - iwe.u.qual.noise;
-		iwe.u.qual.updated  = lp->probe_results.scan_complete;
+		iwe.u.qual.updated  = lp->probe_results.scan_complete | IW_QUAL_DBM;
 		iwe.len             = IW_EV_QUAL_LEN;
 
 		buf = IWE_STREAM_ADD_EVENT(info, buf, buf_end, &iwe, IW_EV_QUAL_LEN);
@@ -3317,7 +3317,6 @@ struct iw_statistics * wl_wireless_stats
 		/* Get the current link quality information */
 		lp->ltvRecord.len = 1 + ( sizeof( *pQual ) / sizeof( hcf_16 ));
 		lp->ltvRecord.typ = CFG_COMMS_QUALITY;
-
 		status = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));
 
 		if( status == HCF_SUCCESS ) {
@@ -3327,6 +3326,11 @@ struct iw_statistics * wl_wireless_stats
 			pStats->qual.qual  = (u_char) CNV_LITTLE_TO_INT( pQual->coms_qual );
 			pStats->qual.level = (u_char) dbm( CNV_LITTLE_TO_INT( pQual->signal_lvl ));
 			pStats->qual.noise = (u_char) dbm( CNV_LITTLE_TO_INT( pQual->noise_lvl ));
+
+			pStats->qual.updated |= (IW_QUAL_QUAL_UPDATED  |
+                                                 IW_QUAL_LEVEL_UPDATED |
+                                                 IW_QUAL_NOISE_UPDATED |
+                                                 IW_QUAL_DBM);
 #else
 			pStats->qual.qual = percent( CNV_LITTLE_TO_INT( pQual->coms_qual ),
 						     HCF_MIN_COMM_QUALITY,
@@ -3339,9 +3343,11 @@ struct iw_statistics * wl_wireless_stats
 			pStats->qual.noise = percent( CNV_LITTLE_TO_INT( pQual->noise_lvl ),
 						      HCF_MIN_NOISE_LEVEL,
 						      HCF_MAX_NOISE_LEVEL );
-#endif /* USE_DBM */
 
-			pStats->qual.updated |= 0x07;
+			pStats->qual.updated |= (IW_QUAL_QUAL_UPDATED  |
+                                                 IW_QUAL_LEVEL_UPDATED |
+                                                 IW_QUAL_NOISE_UPDATED);
+#endif /* USE_DBM */
 		} else {
 			memset( &( pStats->qual ), 0, sizeof( pStats->qual ));
 		}
@@ -3478,7 +3484,10 @@ inline void wl_spy_gather( struct net_de
 		wstats.noise = (u_char) dbm(stats[0]);
 		wstats.qual  = wstats.level > wstats.noise ? wstats.level - wstats.noise : 0;
 
-		wstats.updated = 7;
+		wstats.updated = (IW_QUAL_QUAL_UPDATED  |
+				  IW_QUAL_LEVEL_UPDATED |
+				  IW_QUAL_NOISE_UPDATED |
+				  IW_QUAL_DBM);
 
 		wireless_spy_update( dev, mac, &wstats );
 	}
