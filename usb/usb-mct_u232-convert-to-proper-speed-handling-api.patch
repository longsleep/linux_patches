From alan@lxorguk.ukuu.org.uk Thu Jul 26 10:54:16 2007
From: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date: Thu, 26 Jul 2007 19:01:10 +0100
Subject: USB: mct_u232: Convert to proper speed handling API
To: akpm@osdl.org, greg@kroah.com, linux-usb-devel@lists.sourceforge.net
Message-ID: <20070726190110.263b45e3@the-village.bc.nu>


Signed-off-by: Alan Cox <alan@redhat.com>
Acked-by: Pete Zaitcev <zaitcev@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/serial/mct_u232.c |   54 +++++++++++++++++++++---------------------
 drivers/usb/serial/mct_u232.h |    2 -
 2 files changed, 28 insertions(+), 28 deletions(-)

--- a/drivers/usb/serial/mct_u232.c
+++ b/drivers/usb/serial/mct_u232.c
@@ -184,21 +184,21 @@ struct mct_u232_private {
  * we do not know how to support. We ignore them for the moment.
  * XXX Rate-limit the error message, it's user triggerable.
  */
-static int mct_u232_calculate_baud_rate(struct usb_serial *serial, int value)
+static int mct_u232_calculate_baud_rate(struct usb_serial *serial, speed_t value)
 {
 	if (le16_to_cpu(serial->dev->descriptor.idProduct) == MCT_U232_SITECOM_PID
 	  || le16_to_cpu(serial->dev->descriptor.idProduct) == MCT_U232_BELKIN_F5U109_PID) {
 		switch (value) {
-		case    B300: return 0x01;
-		case    B600: return 0x02; /* this one not tested */
-		case   B1200: return 0x03;
-		case   B2400: return 0x04;
-		case   B4800: return 0x06;
-		case   B9600: return 0x08;
-		case  B19200: return 0x09;
-		case  B38400: return 0x0a;
-		case  B57600: return 0x0b;
-		case B115200: return 0x0c;
+		case    300: return 0x01;
+		case    600: return 0x02; /* this one not tested */
+		case   1200: return 0x03;
+		case   2400: return 0x04;
+		case   4800: return 0x06;
+		case   9600: return 0x08;
+		case  19200: return 0x09;
+		case  38400: return 0x0a;
+		case  57600: return 0x0b;
+		case 115200: return 0x0c;
 		default:
 			err("MCT USB-RS232: unsupported baudrate request 0x%x,"
 			    " using default of B9600", value);
@@ -206,27 +206,27 @@ static int mct_u232_calculate_baud_rate(
 		}
 	} else {
 		switch (value) {
-		case    B300: value =     300; break;
-		case    B600: value =     600; break;
-		case   B1200: value =    1200; break;
-		case   B2400: value =    2400; break;
-		case   B4800: value =    4800; break;
-		case   B9600: value =    9600; break;
-		case  B19200: value =   19200; break;
-		case  B38400: value =   38400; break;
-		case  B57600: value =   57600; break;
-		case B115200: value =  115200; break;
-		default:
-			err("MCT USB-RS232: unsupported baudrate request 0x%x,"
-			    " using default of B9600", value);
-			value = 9600;
+			case 300: break;
+			case 600: break;
+			case 1200: break;
+			case 2400: break;
+			case 4800: break;
+			case 9600: break;
+			case 19200: break;
+			case 38400: break;
+			case 57600: break;
+			case 115200: break;
+			default:
+				err("MCT USB-RS232: unsupported baudrate request 0x%x,"
+				    " using default of B9600", value);
+				value = 9600;
 		}
 		return 115200/value;
 	}
 }
 
 static int mct_u232_set_baud_rate(struct usb_serial *serial, struct usb_serial_port *port,
-				  int value)
+				  speed_t value)
 {
 	__le32 divisor;
         int rc;
@@ -634,7 +634,7 @@ static void mct_u232_set_termios (struct
 		mct_u232_set_modem_ctrl(serial, control_state);
 	}
 
-	mct_u232_set_baud_rate(serial, port, cflag & CBAUD);
+	mct_u232_set_baud_rate(serial, port, tty_get_baud_rate(port->tty));
 
 	if ((cflag & CBAUD) == B0 ) {
 		dbg("%s: baud is B0", __FUNCTION__);
--- a/drivers/usb/serial/mct_u232.h
+++ b/drivers/usb/serial/mct_u232.h
@@ -79,7 +79,7 @@
  * and "Intel solution". They are the regular MCT and "Sitecom" for us.
  * This is pointless to document in the header, see the code for the bits.
  */
-static int mct_u232_calculate_baud_rate(struct usb_serial *serial, int value);
+static int mct_u232_calculate_baud_rate(struct usb_serial *serial, speed_t value);
 
 /*
  * Line Control Register (LCR)
