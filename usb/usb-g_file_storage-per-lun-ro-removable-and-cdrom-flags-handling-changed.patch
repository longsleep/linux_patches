From m.nazarewicz@samsung.com  Fri Nov  6 14:41:51 2009
From: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date: Wed, 28 Oct 2009 16:57:16 +0100
Subject: USB: g_file_storage: per-LUN ro, removable and cdrom flags handling changed
To: Greg KH <greg@kroah.com>
Cc: Michal Nazarewicz <m.nazarewicz@samsung.com>
Message-ID: <574b69a65f0c5aae640ab5fe28e57b0a0a3e1676.1256745228.git.m.nazarewicz@samsung.com>


removable and cdrom flag has been added to the fsg_lun structure
removing any references to mod_data object from storage_common.c.

As of read-only flag, previously it was set if a read-only
backing file was specified (which is good) and remained set
even after the file has been closed (which may be considered an
issue).  Currently, the initial read-only flag is preserved so
if it was unset each time file is opened code will try to open
it read-write even if previous file was opened read-only.

Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
Cc: David Brownell <dbrownell@users.sourceforge.net>
Cc: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/file_storage.c   |   12 ++++++++----
 drivers/usb/gadget/storage_common.c |    7 +++++--
 2 files changed, 13 insertions(+), 6 deletions(-)

--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -3138,7 +3138,9 @@ static ssize_t show_ro(struct device *de
 {
 	struct fsg_lun	*curlun = fsg_lun_from_dev(dev);
 
-	return sprintf(buf, "%d\n", curlun->ro);
+	return sprintf(buf, "%d\n", fsg_lun_is_open(curlun)
+				  ? curlun->ro
+				  : curlun->initially_ro);
 }
 
 static ssize_t show_file(struct device *dev, struct device_attribute *attr,
@@ -3188,6 +3190,7 @@ static ssize_t store_ro(struct device *d
 		rc = -EBUSY;
 	} else {
 		curlun->ro = !!i;
+		curlun->initially_ro = !!i;
 		LDBG(curlun, "read-only status set to %d\n", curlun->ro);
 	}
 	up_read(&fsg->filesem);
@@ -3433,9 +3436,10 @@ static int __init fsg_bind(struct usb_ga
 
 	for (i = 0; i < fsg->nluns; ++i) {
 		curlun = &fsg->luns[i];
-		curlun->ro = mod_data.ro[i];
-		if (mod_data.cdrom)
-			curlun->ro = 1;
+		curlun->cdrom = !!mod_data.cdrom;
+		curlun->ro = mod_data.cdrom || mod_data.ro[i];
+		curlun->initially_ro = curlun->ro;
+		curlun->removable = mod_data.removable;
 		curlun->dev.release = lun_release;
 		curlun->dev.parent = &gadget->dev;
 		curlun->dev.driver = &fsg_driver.driver;
--- a/drivers/usb/gadget/storage_common.c
+++ b/drivers/usb/gadget/storage_common.c
@@ -225,7 +225,10 @@ struct fsg_lun {
 	loff_t		file_length;
 	loff_t		num_sectors;
 
+	unsigned int	initially_ro : 1;
 	unsigned int	ro : 1;
+	unsigned int	removable : 1;
+	unsigned int	cdrom : 1;
 	unsigned int	prevent_medium_removal : 1;
 	unsigned int	registered : 1;
 	unsigned int	info_valid : 1;
@@ -478,7 +481,7 @@ static int fsg_lun_open(struct fsg_lun *
 	loff_t				min_sectors;
 
 	/* R/W if we can, R/O if we must */
-	ro = curlun->ro;
+	ro = curlun->initially_ro;
 	if (!ro) {
 		filp = filp_open(filename, O_RDWR | O_LARGEFILE, 0);
 		if (-EROFS == PTR_ERR(filp))
@@ -521,7 +524,7 @@ static int fsg_lun_open(struct fsg_lun *
 	}
 	num_sectors = size >> 9;	// File size in 512-byte blocks
 	min_sectors = 1;
-	if (mod_data.cdrom) {
+	if (curlun->cdrom) {
 		num_sectors &= ~3;	// Reduce to a multiple of 2048
 		min_sectors = 300*4;	// Smallest track is 300 frames
 		if (num_sectors >= 256*60*75*4) {
