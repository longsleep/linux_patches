From stern@rowland.harvard.edu  Thu Jul  3 16:17:46 2008
From: Alan Stern <stern@rowland.harvard.edu>
Date: Mon, 30 Jun 2008 11:14:43 -0400 (EDT)
Subject: USB: use reset_resume when normal resume fails
To: Greg KH <greg@kroah.com>
Cc: Oliver Neukum <oliver@neukum.org>, <astrid-spammenot@syonax.net>, USB list <linux-usb@vger.kernel.org>
Message-ID: <Pine.LNX.4.44L0.0806301113510.2708-100000@iolanthe.rowland.org>


This patch (as1109b) makes USB-Persist more resilient to errors.  With
the current code, if a normal resume fails, it's an unrecoverable
error.  With the patch, if a normal resume fails (and if the device is
enabled for USB-Persist) then a reset-resume is tried.

This fixes the problem reported in Bugzilla #10977.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 Documentation/usb/persist.txt |    7 +++++--
 drivers/usb/core/hub.c        |   20 +++++++++++++++++---
 2 files changed, 22 insertions(+), 5 deletions(-)

--- a/Documentation/usb/persist.txt
+++ b/Documentation/usb/persist.txt
@@ -81,8 +81,11 @@ re-enumeration shows that the device now
 same descriptors as before, including the Vendor and Product IDs, then
 the kernel continues to use the same device structure.  In effect, the
 kernel treats the device as though it had merely been reset instead of
-unplugged.  The same thing happens if the host controller is in the
-expected state but a USB device was unplugged and then replugged.
+unplugged.
+
+The same thing happens if the host controller is in the expected state
+but a USB device was unplugged and then replugged, or if a USB device
+fails to carry out a normal resume.
 
 If no device is now attached to the port, or if the descriptors are
 different from what the kernel remembers, then the treatment is what
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1822,9 +1822,15 @@ static int check_port_resume_type(struct
 			status = -ENODEV;
 	}
 
-	/* Can't do a normal resume if the port isn't enabled */
-	else if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume)
-		status = -ENODEV;
+	/* Can't do a normal resume if the port isn't enabled,
+	 * so try a reset-resume instead.
+	 */
+	else if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {
+		if (udev->persist_enabled)
+			udev->reset_resume = 1;
+		else
+			status = -ENODEV;
+	}
 
 	if (status) {
 		dev_dbg(hub->intfdev,
@@ -1973,6 +1979,7 @@ static int finish_port_resume(struct usb
 	 * resumed.
 	 */
 	if (udev->reset_resume)
+ retry_reset_resume:
 		status = usb_reset_and_verify_device(udev);
 
  	/* 10.5.4.5 says be sure devices in the tree are still there.
@@ -1984,6 +1991,13 @@ static int finish_port_resume(struct usb
 		status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstatus);
 		if (status >= 0)
 			status = (status > 0 ? 0 : -ENODEV);
+
+		/* If a normal resume failed, try doing a reset-resume */
+		if (status && !udev->reset_resume && udev->persist_enabled) {
+			dev_dbg(&udev->dev, "retry with reset-resume\n");
+			udev->reset_resume = 1;
+			goto retry_reset_resume;
+		}
 	}
 
 	if (status) {
