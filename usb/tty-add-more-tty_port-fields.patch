From linux-kernel-owner+greg=40kroah.com-S1762597AbYFTUXq@vger.kernel.org Fri Jun 20 13:32:18 2008
From: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date: Fri, 20 Jun 2008 21:00:58 +0100
Subject: tty: add more tty_port fields
To: linux-kernel@vger.kernel.org
Message-ID: <20080620200057.1479.2974.stgit@localhost.localdomain>


From: Alan Cox <alan@redhat.com>

Move more bits into the tty_port structure

Signed-off-by: Alan Cox <alan@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/char/cyclades.c      |   28 +++----
 drivers/char/isicom.c        |   28 +++----
 drivers/char/moxa.c          |    8 --
 drivers/char/mxser.c         |   29 +++-----
 drivers/char/riscom8.c       |   24 +++---
 drivers/char/riscom8.h       |    2 
 drivers/char/rocket.c        |   23 +++---
 drivers/char/rocket.h        |    4 -
 drivers/char/rocket_int.h    |    2 
 drivers/char/specialix.c     |  153 ++++++++++++++++++++-----------------------
 drivers/char/specialix_io8.h |    8 --
 drivers/char/sx.c            |    2 
 drivers/char/synclink.c      |   16 +---
 drivers/char/synclink_gt.c   |   16 +---
 drivers/char/synclinkmp.c    |   14 +--
 drivers/char/tty_io.c        |    2 
 include/linux/cyclades.h     |    6 -
 include/linux/tty.h          |    2 
 18 files changed, 169 insertions(+), 198 deletions(-)

--- a/drivers/char/cyclades.c
+++ b/drivers/char/cyclades.c
@@ -2677,8 +2677,8 @@ static void cy_close(struct tty_struct *
 	 */
 	tty->closing = 1;
 	spin_unlock_irqrestore(&card->card_lock, flags);
-	if (info->closing_wait != CY_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, info->closing_wait);
+	if (info->port.closing_wait != CY_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->port.closing_wait);
 
 	spin_lock_irqsave(&card->card_lock, flags);
 
@@ -2734,9 +2734,9 @@ static void cy_close(struct tty_struct *
 	info->port.tty = NULL;
 	if (info->port.blocked_open) {
 		spin_unlock_irqrestore(&card->card_lock, flags);
-		if (info->close_delay) {
+		if (info->port.close_delay) {
 			msleep_interruptible(jiffies_to_msecs
-						(info->close_delay));
+						(info->port.close_delay));
 		}
 		wake_up_interruptible(&info->port.open_wait);
 		spin_lock_irqsave(&card->card_lock, flags);
@@ -3382,8 +3382,8 @@ get_serial_info(struct cyclades_port *in
 		cinfo->first_line;
 	tmp.irq = cinfo->irq;
 	tmp.flags = info->port.flags;
-	tmp.close_delay = info->close_delay;
-	tmp.closing_wait = info->closing_wait;
+	tmp.close_delay = info->port.close_delay;
+	tmp.closing_wait = info->port.closing_wait;
 	tmp.baud_base = info->baud;
 	tmp.custom_divisor = info->custom_divisor;
 	tmp.hub6 = 0;		/*!!! */
@@ -3402,7 +3402,7 @@ set_serial_info(struct cyclades_port *in
 	old_info = *info;
 
 	if (!capable(CAP_SYS_ADMIN)) {
-		if (new_serial.close_delay != info->close_delay ||
+		if (new_serial.close_delay != info->port.close_delay ||
 				new_serial.baud_base != info->baud ||
 				(new_serial.flags & ASYNC_FLAGS &
 					~ASYNC_USR_MASK) !=
@@ -3424,8 +3424,8 @@ set_serial_info(struct cyclades_port *in
 	info->custom_divisor = new_serial.custom_divisor;
 	info->port.flags = (info->port.flags & ~ASYNC_FLAGS) |
 			(new_serial.flags & ASYNC_FLAGS);
-	info->close_delay = new_serial.close_delay * HZ / 100;
-	info->closing_wait = new_serial.closing_wait * HZ / 100;
+	info->port.close_delay = new_serial.close_delay * HZ / 100;
+	info->port.closing_wait = new_serial.closing_wait * HZ / 100;
 
 check_and_exit:
 	if (info->port.flags & ASYNC_INITIALIZED) {
@@ -3971,11 +3971,11 @@ cy_ioctl(struct tty_struct *tty, struct 
 		break;
 #endif				/* CONFIG_CYZ_INTR */
 	case CYSETWAIT:
-		info->closing_wait = (unsigned short)arg * HZ / 100;
+		info->port.closing_wait = (unsigned short)arg * HZ / 100;
 		ret_val = 0;
 		break;
 	case CYGETWAIT:
-		ret_val = info->closing_wait / (HZ / 100);
+		ret_val = info->port.closing_wait / (HZ / 100);
 		break;
 	case TIOCGSERIAL:
 		ret_val = get_serial_info(info, argp);
@@ -4376,13 +4376,13 @@ static int __devinit cy_init_card(struct
 	for (port = cinfo->first_line; port < cinfo->first_line + nports;
 			port++) {
 		info = &cinfo->ports[port - cinfo->first_line];
+		tty_port_init(&info->port);
 		info->magic = CYCLADES_MAGIC;
 		info->card = cinfo;
 		info->line = port;
-		info->closing_wait = CLOSING_WAIT_DELAY;
-		info->close_delay = 5 * HZ / 10;
 
-		tty_port_init(&info->port);
+		info->port.closing_wait = CLOSING_WAIT_DELAY;
+		info->port.close_delay = 5 * HZ / 10;
 		info->port.flags = STD_COM_FLAGS;
 		init_completion(&info->shutdown_wait);
 		init_waitqueue_head(&info->delta_msr_wait);
--- a/drivers/char/isicom.c
+++ b/drivers/char/isicom.c
@@ -199,10 +199,8 @@ struct	isi_board {
 struct	isi_port {
 	unsigned short		magic;
 	struct tty_port		port;
-	int			close_delay;
 	u16			channel;
 	u16			status;
-	u16			closing_wait;
 	struct isi_board	*card;
 	unsigned char		*xmit_buf;
 	int			xmit_head;
@@ -1051,8 +1049,8 @@ static void isicom_close(struct tty_stru
 	tty->closing = 1;
 	spin_unlock_irqrestore(&card->card_lock, flags);
 
-	if (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, port->closing_wait);
+	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, port->port.closing_wait);
 	/* indicate to the card that no more data can be received
 	   on this port */
 	spin_lock_irqsave(&card->card_lock, flags);
@@ -1071,10 +1069,10 @@ static void isicom_close(struct tty_stru
 
 	if (port->port.blocked_open) {
 		spin_unlock_irqrestore(&card->card_lock, flags);
-		if (port->close_delay) {
+		if (port->port.close_delay) {
 			pr_dbg("scheduling until time out.\n");
 			msleep_interruptible(
-				jiffies_to_msecs(port->close_delay));
+				jiffies_to_msecs(port->port.close_delay));
 		}
 		spin_lock_irqsave(&card->card_lock, flags);
 		wake_up_interruptible(&port->port.open_wait);
@@ -1256,8 +1254,8 @@ static int isicom_set_serial_info(struct
 		(newinfo.flags & ASYNC_SPD_MASK));
 
 	if (!capable(CAP_SYS_ADMIN)) {
-		if ((newinfo.close_delay != port->close_delay) ||
-				(newinfo.closing_wait != port->closing_wait) ||
+		if ((newinfo.close_delay != port->port.close_delay) ||
+				(newinfo.closing_wait != port->port.closing_wait) ||
 				((newinfo.flags & ~ASYNC_USR_MASK) !=
 				(port->port.flags & ~ASYNC_USR_MASK))) {
 			unlock_kernel();
@@ -1266,8 +1264,8 @@ static int isicom_set_serial_info(struct
 		port->port.flags = ((port->port.flags & ~ASYNC_USR_MASK) |
 				(newinfo.flags & ASYNC_USR_MASK));
 	} else {
-		port->close_delay = newinfo.close_delay;
-		port->closing_wait = newinfo.closing_wait;
+		port->port.close_delay = newinfo.close_delay;
+		port->port.closing_wait = newinfo.closing_wait;
 		port->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |
 				(newinfo.flags & ASYNC_FLAGS));
 	}
@@ -1294,8 +1292,8 @@ static int isicom_get_serial_info(struct
 	out_info.irq = port->card->irq;
 	out_info.flags = port->port.flags;
 /*	out_info.baud_base = ? */
-	out_info.close_delay = port->close_delay;
-	out_info.closing_wait = port->closing_wait;
+	out_info.close_delay = port->port.close_delay;
+	out_info.closing_wait = port->port.closing_wait;
 	unlock_kernel();
 	if (copy_to_user(info, &out_info, sizeof(out_info)))
 		return -EFAULT;
@@ -1796,13 +1794,13 @@ static int __init isicom_init(void)
 		isi_card[idx].ports = port;
 		spin_lock_init(&isi_card[idx].card_lock);
 		for (channel = 0; channel < 16; channel++, port++) {
+			tty_port_init(&port->port);
 			port->magic = ISICOM_MAGIC;
 			port->card = &isi_card[idx];
 			port->channel = channel;
-			port->close_delay = 50 * HZ/100;
-			port->closing_wait = 3000 * HZ/100;
+			port->port.close_delay = 50 * HZ/100;
+			port->port.closing_wait = 3000 * HZ/100;
 			port->status = 0;
-			tty_port_init(&port->port);
 			/*  . . .  */
 		}
 		isi_card[idx].base = 0;
--- a/drivers/char/moxa.c
+++ b/drivers/char/moxa.c
@@ -135,7 +135,6 @@ struct moxa_port {
 	void __iomem *tableAddr;
 
 	int type;
-	int close_delay;
 	int cflag;
 	unsigned long statusflags;
 
@@ -822,10 +821,9 @@ static int moxa_init_board(struct moxa_b
 	}
 
 	for (i = 0, p = brd->ports; i < MAX_PORTS_PER_BOARD; i++, p++) {
+		tty_port_init(&p->port);
 		p->type = PORT_16550A;
-		p->close_delay = 5 * HZ / 10;
 		p->cflag = B9600 | CS8 | CREAD | CLOCAL | HUPCL;
-		tty_port_init(&p->port);
 	}
 
 	switch (brd->boardType) {
@@ -2124,7 +2122,7 @@ static int moxa_get_serial_info(struct m
 		.line = info->port.tty->index,
 		.flags = info->port.flags,
 		.baud_base = 921600,
-		.close_delay = info->close_delay
+		.close_delay = info->port.close_delay
 	};
 	return copy_to_user(retinfo, &tmp, sizeof(*retinfo)) ? -EFAULT : 0;
 }
@@ -2148,7 +2146,7 @@ static int moxa_set_serial_info(struct m
 		     (info->port.flags & ~ASYNC_USR_MASK)))
 			return -EPERM;
 	} else
-		info->close_delay = new_serial.close_delay * HZ / 100;
+		info->port.close_delay = new_serial.close_delay * HZ / 100;
 
 	new_serial.flags = (new_serial.flags & ~ASYNC_FLAGS);
 	new_serial.flags |= (info->port.flags & ASYNC_FLAGS);
--- a/drivers/char/mxser.c
+++ b/drivers/char/mxser.c
@@ -243,10 +243,7 @@ struct mxser_port {
 	unsigned char ldisc_stop_rx;
 
 	int custom_divisor;
-	int close_delay;
-	unsigned short closing_wait;
 	unsigned char err_shadow;
-	unsigned long event;
 
 	struct async_icount icount; /* kernel counters for 4 input interrupts */
 	int timeout;
@@ -1199,8 +1196,8 @@ static void mxser_close(struct tty_struc
 	 * the line discipline to only process XON/XOFF characters.
 	 */
 	tty->closing = 1;
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, info->closing_wait);
+	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->port.closing_wait);
 	/*
 	 * At this point we stop accepting input.  To do this, we
 	 * disable the receive line status interrupts, and tell the
@@ -1231,11 +1228,10 @@ static void mxser_close(struct tty_struc
 	tty_ldisc_flush(tty);
 
 	tty->closing = 0;
-	info->event = 0;
 	info->port.tty = NULL;
 	if (info->port.blocked_open) {
-		if (info->close_delay)
-			schedule_timeout_interruptible(info->close_delay);
+		if (info->port.close_delay)
+			schedule_timeout_interruptible(info->port.close_delay);
 		wake_up_interruptible(&info->port.open_wait);
 	}
 
@@ -1370,8 +1366,8 @@ static int mxser_get_serial_info(struct 
 		.irq = info->board->irq,
 		.flags = info->port.flags,
 		.baud_base = info->baud_base,
-		.close_delay = info->close_delay,
-		.closing_wait = info->closing_wait,
+		.close_delay = info->port.close_delay,
+		.closing_wait = info->port.closing_wait,
 		.custom_divisor = info->custom_divisor,
 		.hub6 = 0
 	};
@@ -1402,7 +1398,7 @@ static int mxser_set_serial_info(struct 
 
 	if (!capable(CAP_SYS_ADMIN)) {
 		if ((new_serial.baud_base != info->baud_base) ||
-				(new_serial.close_delay != info->close_delay) ||
+				(new_serial.close_delay != info->port.close_delay) ||
 				((new_serial.flags & ~ASYNC_USR_MASK) != (info->port.flags & ~ASYNC_USR_MASK)))
 			return -EPERM;
 		info->port.flags = ((info->port.flags & ~ASYNC_USR_MASK) |
@@ -1414,8 +1410,8 @@ static int mxser_set_serial_info(struct 
 		 */
 		info->port.flags = ((info->port.flags & ~ASYNC_FLAGS) |
 				(new_serial.flags & ASYNC_FLAGS));
-		info->close_delay = new_serial.close_delay * HZ / 100;
-		info->closing_wait = new_serial.closing_wait * HZ / 100;
+		info->port.close_delay = new_serial.close_delay * HZ / 100;
+		info->port.closing_wait = new_serial.closing_wait * HZ / 100;
 		info->port.tty->low_latency =
 				(info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;
 		info->port.tty->low_latency = 0;
@@ -2214,7 +2210,6 @@ static void mxser_hangup(struct tty_stru
 
 	mxser_flush_buffer(tty);
 	mxser_shutdown(info);
-	info->event = 0;
 	info->port.count = 0;
 	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
 	info->port.tty = NULL;
@@ -2545,6 +2540,7 @@ static int __devinit mxser_initbrd(struc
 
 	for (i = 0; i < brd->info->nports; i++) {
 		info = &brd->ports[i];
+		tty_port_init(&info->port);
 		info->board = brd;
 		info->stop_rx = 0;
 		info->ldisc_stop_rx = 0;
@@ -2559,10 +2555,9 @@ static int __devinit mxser_initbrd(struc
 		process_txrx_fifo(info);
 
 		info->custom_divisor = info->baud_base * 16;
-		info->close_delay = 5 * HZ / 10;
-		info->closing_wait = 30 * HZ;
+		info->port.close_delay = 5 * HZ / 10;
+		info->port.closing_wait = 30 * HZ;
 		info->normal_termios = mxvar_sdriver->init_termios;
-		tty_port_init(&info->port);
 		init_waitqueue_head(&info->delta_msr_wait);
 		memset(&info->mon_data, 0, sizeof(struct mxser_mon));
 		info->err_shadow = 0;
--- a/drivers/char/riscom8.c
+++ b/drivers/char/riscom8.c
@@ -1032,8 +1032,8 @@ static void rc_close(struct tty_struct *
 	 * the line discipline to only process XON/XOFF characters.
 	 */
 	tty->closing = 1;
-	if (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, port->closing_wait);
+	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, port->port.closing_wait);
 	/*
 	 * At this point we stop accepting input.  To do this, we
 	 * disable the receive line status interrupts, and tell the
@@ -1065,8 +1065,8 @@ static void rc_close(struct tty_struct *
 	tty->closing = 0;
 	port->port.tty = NULL;
 	if (port->port.blocked_open) {
-		if (port->close_delay)
-			msleep_interruptible(jiffies_to_msecs(port->close_delay));
+		if (port->port.close_delay)
+			msleep_interruptible(jiffies_to_msecs(port->port.close_delay));
 		wake_up_interruptible(&port->port.open_wait);
 	}
 	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
@@ -1295,8 +1295,8 @@ static int rc_set_serial_info(struct ris
 			(tmp.flags & ASYNC_SPD_MASK));
 
 	if (!capable(CAP_SYS_ADMIN)) {
-		if ((tmp.close_delay != port->close_delay) ||
-		    (tmp.closing_wait != port->closing_wait) ||
+		if ((tmp.close_delay != port->port.close_delay) ||
+		    (tmp.closing_wait != port->port.closing_wait) ||
 		    ((tmp.flags & ~ASYNC_USR_MASK) !=
 		     (port->port.flags & ~ASYNC_USR_MASK)))
 			return -EPERM;
@@ -1305,8 +1305,8 @@ static int rc_set_serial_info(struct ris
 	} else  {
 		port->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |
 			       (tmp.flags & ASYNC_FLAGS));
-		port->close_delay = tmp.close_delay;
-		port->closing_wait = tmp.closing_wait;
+		port->port.close_delay = tmp.close_delay;
+		port->port.closing_wait = tmp.closing_wait;
 	}
 	if (change_speed)  {
 		unsigned long flags;
@@ -1331,8 +1331,8 @@ static int rc_get_serial_info(struct ris
 	tmp.irq  = bp->irq;
 	tmp.flags = port->port.flags;
 	tmp.baud_base = (RC_OSCFREQ + CD180_TPC/2) / CD180_TPC;
-	tmp.close_delay = port->close_delay * HZ/100;
-	tmp.closing_wait = port->closing_wait * HZ/100;
+	tmp.close_delay = port->port.close_delay * HZ/100;
+	tmp.closing_wait = port->port.closing_wait * HZ/100;
 	tmp.xmit_fifo_size = CD180_NFIFO;
 	return copy_to_user(retinfo, &tmp, sizeof(tmp)) ? -EFAULT : 0;
 }
@@ -1549,10 +1549,8 @@ static int __init rc_init_drivers(void)
 	}
 	memset(rc_port, 0, sizeof(rc_port));
 	for (i = 0; i < RC_NPORT * RC_NBOARD; i++)  {
-		rc_port[i].magic = RISCOM8_MAGIC;
-		rc_port[i].close_delay = 50 * HZ / 100;
-		rc_port[i].closing_wait = 3000 * HZ / 100;
 		tty_port_init(&rc_port[i].port);
+		rc_port[i].magic = RISCOM8_MAGIC;
 	}
 	return 0;
 }
--- a/drivers/char/riscom8.h
+++ b/drivers/char/riscom8.h
@@ -69,14 +69,12 @@ struct riscom_port {
 	struct			tty_port port;
 	int			baud_base;
 	int			timeout;
-	int			close_delay;
 	int			custom_divisor;
 	int			xmit_head;
 	int			xmit_tail;
 	int			xmit_cnt;
 	short			wakeup_chars;
 	short			break_length;
-	unsigned short		closing_wait;
 	unsigned char		mark_mask;
 	unsigned char		IER;
 	unsigned char		MSVR;
--- a/drivers/char/rocket.c
+++ b/drivers/char/rocket.c
@@ -72,6 +72,7 @@
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
+#include <linux/serial.h>
 #include <linux/string.h>
 #include <linux/fcntl.h>
 #include <linux/ptrace.h>
@@ -81,7 +82,7 @@
 #include <linux/completion.h>
 #include <linux/wait.h>
 #include <linux/pci.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/atomic.h>
 #include <asm/unaligned.h>
 #include <linux/bitops.h>
@@ -648,8 +649,8 @@ static void init_r_port(int board, int a
 	info->board = board;
 	info->aiop = aiop;
 	info->chan = chan;
-	info->closing_wait = 3000;
-	info->close_delay = 50;
+	info->port.closing_wait = 3000;
+	info->port.close_delay = 50;
 	init_waitqueue_head(&info->port.open_wait);
 	init_completion(&info->close_wait);
 	info->flags &= ~ROCKET_MODE_MASK;
@@ -1137,8 +1138,8 @@ static void rp_close(struct tty_struct *
 	/*
 	 * Wait for the transmit buffer to clear
 	 */
-	if (info->closing_wait != ROCKET_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, info->closing_wait);
+	if (info->port.closing_wait != ROCKET_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->port.closing_wait);
 	/*
 	 * Before we drop DTR, make sure the UART transmitter
 	 * has completely drained; this is especially
@@ -1168,8 +1169,8 @@ static void rp_close(struct tty_struct *
 	clear_bit((info->aiop * 8) + info->chan, (void *) &xmit_flags[info->board]);
 
 	if (info->port.blocked_open) {
-		if (info->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->close_delay));
+		if (info->port.close_delay) {
+			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
 		}
 		wake_up_interruptible(&info->port.open_wait);
 	} else {
@@ -1327,8 +1328,8 @@ static int get_config(struct r_port *inf
 	memset(&tmp, 0, sizeof (tmp));
 	tmp.line = info->line;
 	tmp.flags = info->flags;
-	tmp.close_delay = info->close_delay;
-	tmp.closing_wait = info->closing_wait;
+	tmp.close_delay = info->port.close_delay;
+	tmp.closing_wait = info->port.closing_wait;
 	tmp.port = rcktpt_io_addr[(info->line >> 5) & 3];
 
 	if (copy_to_user(retinfo, &tmp, sizeof (*retinfo)))
@@ -1353,8 +1354,8 @@ static int set_config(struct r_port *inf
 	}
 
 	info->flags = ((info->flags & ~ROCKET_FLAGS) | (new_serial.flags & ROCKET_FLAGS));
-	info->close_delay = new_serial.close_delay;
-	info->closing_wait = new_serial.closing_wait;
+	info->port.close_delay = new_serial.close_delay;
+	info->port.closing_wait = new_serial.closing_wait;
 
 	if ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_HI)
 		info->port.tty->alt_speed = 57600;
--- a/drivers/char/rocket.h
+++ b/drivers/char/rocket.h
@@ -64,8 +64,8 @@ struct rocket_version {
 /*
  * For closing_wait and closing_wait2
  */
-#define ROCKET_CLOSING_WAIT_NONE	65535
-#define ROCKET_CLOSING_WAIT_INF		0
+#define ROCKET_CLOSING_WAIT_NONE	ASYNC_CLOSING_WAIT_NONE
+#define ROCKET_CLOSING_WAIT_INF		ASYNC_CLOSING_WAIT_INF
 
 /*
  * Rocketport ioctls -- "RP"
--- a/drivers/char/rocket_int.h
+++ b/drivers/char/rocket_int.h
@@ -1133,8 +1133,6 @@ struct r_port {
 	unsigned int chan:3;
 	CONTROLLER_t *ctlp;
 	CHANNEL_t channel;
-	int closing_wait;
-	int close_delay;
 	int intmask;
 	int xmit_fifo_room;	/* room in xmit fifo */
 	unsigned char *xmit_buf;
--- a/drivers/char/specialix.c
+++ b/drivers/char/specialix.c
@@ -608,9 +608,9 @@ static inline struct specialix_port * sx
 	dprintk (SX_DEBUG_CHAN, "channel: %d\n", channel);
 	if (channel < CD186x_NCH) {
 		port = &sx_port[board_No(bp) * SX_NPORT + channel];
-		dprintk (SX_DEBUG_CHAN, "port: %d %p flags: 0x%x\n",board_No(bp) * SX_NPORT + channel,  port, port->flags & ASYNC_INITIALIZED);
+		dprintk (SX_DEBUG_CHAN, "port: %d %p flags: 0x%lx\n",board_No(bp) * SX_NPORT + channel,  port, port->port.flags & ASYNC_INITIALIZED);
 
-		if (port->flags & ASYNC_INITIALIZED) {
+		if (port->port.flags & ASYNC_INITIALIZED) {
 			dprintk (SX_DEBUG_CHAN, "port: %d %p\n", channel, port);
 			func_exit();
 			return port;
@@ -637,7 +637,7 @@ static inline void sx_receive_exc(struct
 		func_exit();
 		return;
 	}
-	tty = port->tty;
+	tty = port->port.tty;
 
 	status = sx_in(bp, CD186x_RCSR);
 
@@ -673,7 +673,7 @@ static inline void sx_receive_exc(struct
 		dprintk(SX_DEBUG_RX, "sx%d: port %d: Handling break...\n",
 		       board_No(bp), port_No(port));
 		flag = TTY_BREAK;
-		if (port->flags & ASYNC_SAK)
+		if (port->port.flags & ASYNC_SAK)
 			do_SAK(tty);
 
 	} else if (status & RCSR_PE)
@@ -707,7 +707,7 @@ static inline void sx_receive(struct spe
 		func_exit();
 		return;
 	}
-	tty = port->tty;
+	tty = port->port.tty;
 
 	count = sx_in(bp, CD186x_RDCR);
 	dprintk (SX_DEBUG_RX, "port: %p: count: %d\n", port, count);
@@ -734,7 +734,7 @@ static inline void sx_transmit(struct sp
 		return;
 	}
 	dprintk (SX_DEBUG_TX, "port: %p\n", port);
-	tty = port->tty;
+	tty = port->port.tty;
 
 	if (port->IER & IER_TXEMPTY) {
 		/* FIFO drained */
@@ -811,7 +811,7 @@ static inline void sx_check_modem(struct
 	if (!(port = sx_get_port(bp, "Modem")))
 		return;
 
-	tty = port->tty;
+	tty = port->port.tty;
 
 	mcr = sx_in(bp, CD186x_MCR);
 	printk ("mcr = %02x.\n", mcr);
@@ -821,7 +821,7 @@ static inline void sx_check_modem(struct
 		msvr_cd = sx_in(bp, CD186x_MSVR) & MSVR_CD;
 		if (msvr_cd) {
 			dprintk (SX_DEBUG_SIGNALS, "Waking up guys in open.\n");
-			wake_up_interruptible(&port->open_wait);
+			wake_up_interruptible(&port->port.open_wait);
 		} else {
 			dprintk (SX_DEBUG_SIGNALS, "Sending HUP.\n");
 			tty_hangup(tty);
@@ -1030,7 +1030,7 @@ static void sx_change_speed(struct speci
 
 	func_enter();
 
-	if (!(tty = port->tty) || !tty->termios) {
+	if (!(tty = port->port.tty) || !tty->termios) {
 		func_exit();
 		return;
 	}
@@ -1052,9 +1052,9 @@ static void sx_change_speed(struct speci
 	baud = tty_get_baud_rate(tty);
 
 	if (baud == 38400) {
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
 			baud = 57600;
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
 			baud = 115200;
 	}
 
@@ -1244,7 +1244,7 @@ static int sx_setup_port(struct speciali
 
 	func_enter();
 
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->port.flags & ASYNC_INITIALIZED) {
 		func_exit();
 		return 0;
 	}
@@ -1268,12 +1268,12 @@ static int sx_setup_port(struct speciali
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	if (port->tty)
-		clear_bit(TTY_IO_ERROR, &port->tty->flags);
+	if (port->port.tty)
+		clear_bit(TTY_IO_ERROR, &port->port.tty->flags);
 
 	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
 	sx_change_speed(bp, port);
-	port->flags |= ASYNC_INITIALIZED;
+	port->port.flags |= ASYNC_INITIALIZED;
 
 	spin_unlock_irqrestore(&port->lock, flags);
 
@@ -1292,7 +1292,7 @@ static void sx_shutdown_port(struct spec
 
 	func_enter();
 
-	if (!(port->flags & ASYNC_INITIALIZED)) {
+	if (!(port->port.flags & ASYNC_INITIALIZED)) {
 		func_exit();
 		return;
 	}
@@ -1315,7 +1315,7 @@ static void sx_shutdown_port(struct spec
 	spin_lock_irqsave(&bp->lock, flags);
 	sx_out(bp, CD186x_CAR, port_No(port));
 
-	if (!(tty = port->tty) || C_HUPCL(tty)) {
+	if (!(tty = port->port.tty) || C_HUPCL(tty)) {
 		/* Drop DTR */
 		sx_out(bp, CD186x_MSVDTR, 0);
 	}
@@ -1330,7 +1330,7 @@ static void sx_shutdown_port(struct spec
 	spin_unlock_irqrestore(&bp->lock, flags);
 	if (tty)
 		set_bit(TTY_IO_ERROR, &tty->flags);
-	port->flags &= ~ASYNC_INITIALIZED;
+	port->port.flags &= ~ASYNC_INITIALIZED;
 
 	if (!bp->count)
 		sx_shutdown_board(bp);
@@ -1354,9 +1354,9 @@ static int block_til_ready(struct tty_st
 	 * If the device is in the middle of being closed, then block
 	 * until it's done, and then try again.
 	 */
-	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {
-		interruptible_sleep_on(&port->close_wait);
-		if (port->flags & ASYNC_HUP_NOTIFY) {
+	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
+		interruptible_sleep_on(&port->port.close_wait);
+		if (port->port.flags & ASYNC_HUP_NOTIFY) {
 			func_exit();
 			return -EAGAIN;
 		} else {
@@ -1371,7 +1371,7 @@ static int block_til_ready(struct tty_st
 	 */
 	if ((filp->f_flags & O_NONBLOCK) ||
 	    (tty->flags & (1 << TTY_IO_ERROR))) {
-		port->flags |= ASYNC_NORMAL_ACTIVE;
+		port->port.flags |= ASYNC_NORMAL_ACTIVE;
 		func_exit();
 		return 0;
 	}
@@ -1387,13 +1387,13 @@ static int block_til_ready(struct tty_st
 	 * exit, either normal or abnormal.
 	 */
 	retval = 0;
-	add_wait_queue(&port->open_wait, &wait);
+	add_wait_queue(&port->port.open_wait, &wait);
 	spin_lock_irqsave(&port->lock, flags);
 	if (!tty_hung_up_p(filp)) {
-		port->count--;
+		port->port.count--;
 	}
 	spin_unlock_irqrestore(&port->lock, flags);
-	port->blocked_open++;
+	port->port.blocked_open++;
 	while (1) {
 		spin_lock_irqsave(&bp->lock, flags);
 		sx_out(bp, CD186x_CAR, port_No(port));
@@ -1410,14 +1410,14 @@ static int block_til_ready(struct tty_st
 		spin_unlock_irqrestore(&bp->lock, flags);
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (tty_hung_up_p(filp) ||
-		    !(port->flags & ASYNC_INITIALIZED)) {
-			if (port->flags & ASYNC_HUP_NOTIFY)
+		    !(port->port.flags & ASYNC_INITIALIZED)) {
+			if (port->port.flags & ASYNC_HUP_NOTIFY)
 				retval = -EAGAIN;
 			else
 				retval = -ERESTARTSYS;
 			break;
 		}
-		if (!(port->flags & ASYNC_CLOSING) &&
+		if (!(port->port.flags & ASYNC_CLOSING) &&
 		    (do_clocal || CD))
 			break;
 		if (signal_pending(current)) {
@@ -1428,19 +1428,19 @@ static int block_til_ready(struct tty_st
 	}
 
 	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&port->open_wait, &wait);
+	remove_wait_queue(&port->port.open_wait, &wait);
 	spin_lock_irqsave(&port->lock, flags);
 	if (!tty_hung_up_p(filp)) {
-		port->count++;
+		port->port.count++;
 	}
-	port->blocked_open--;
+	port->port.blocked_open--;
 	spin_unlock_irqrestore(&port->lock, flags);
 	if (retval) {
 		func_exit();
 		return retval;
 	}
 
-	port->flags |= ASYNC_NORMAL_ACTIVE;
+	port->port.flags |= ASYNC_NORMAL_ACTIVE;
 	func_exit();
 	return 0;
 }
@@ -1484,10 +1484,10 @@ static int sx_open(struct tty_struct * t
 	}
 
 	spin_lock_irqsave(&bp->lock, flags);
-	port->count++;
+	port->port.count++;
 	bp->count++;
 	tty->driver_data = port;
-	port->tty = tty;
+	port->port.tty = tty;
 	spin_unlock_irqrestore(&bp->lock, flags);
 
 	if ((error = sx_setup_port(bp, port))) {
@@ -1547,15 +1547,15 @@ static void sx_close(struct tty_struct *
 	}
 
 	bp = port_Board(port);
-	if ((tty->count == 1) && (port->count != 1)) {
+	if ((tty->count == 1) && (port->port.count != 1)) {
 		printk(KERN_ERR "sx%d: sx_close: bad port count;"
 		       " tty->count is 1, port count is %d\n",
-		       board_No(bp), port->count);
-		port->count = 1;
+		       board_No(bp), port->port.count);
+		port->port.count = 1;
 	}
 
-	if (port->count > 1) {
-		port->count--;
+	if (port->port.count > 1) {
+		port->port.count--;
 		bp->count--;
 
 		spin_unlock_irqrestore(&port->lock, flags);
@@ -1563,7 +1563,7 @@ static void sx_close(struct tty_struct *
 		func_exit();
 		return;
 	}
-	port->flags |= ASYNC_CLOSING;
+	port->port.flags |= ASYNC_CLOSING;
 	/*
 	 * Now we wait for the transmit buffer to clear; and we notify
 	 * the line discipline to only process XON/XOFF characters.
@@ -1571,8 +1571,8 @@ static void sx_close(struct tty_struct *
 	tty->closing = 1;
 	spin_unlock_irqrestore(&port->lock, flags);
 	dprintk (SX_DEBUG_OPEN, "Closing\n");
-	if (port->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
-		tty_wait_until_sent(tty, port->closing_wait);
+	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
+		tty_wait_until_sent(tty, port->port.closing_wait);
 	}
 	/*
 	 * At this point we stop accepting input.  To do this, we
@@ -1582,7 +1582,7 @@ static void sx_close(struct tty_struct *
 	 */
 	dprintk (SX_DEBUG_OPEN, "Closed\n");
 	port->IER &= ~IER_RXD;
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->port.flags & ASYNC_INITIALIZED) {
 		port->IER &= ~IER_TXRDY;
 		port->IER |= IER_TXEMPTY;
 		spin_lock_irqsave(&bp->lock, flags);
@@ -1611,10 +1611,10 @@ static void sx_close(struct tty_struct *
 		       board_No(bp), bp->count, tty->index);
 		bp->count = 0;
 	}
-	if (--port->count < 0) {
+	if (--port->port.count < 0) {
 		printk(KERN_ERR "sx%d: sx_close: bad port count for tty%d: %d\n",
-		       board_No(bp), port_No(port), port->count);
-		port->count = 0;
+		       board_No(bp), port_No(port), port->port.count);
+		port->port.count = 0;
 	}
 
 	sx_shutdown_port(bp, port);
@@ -1622,16 +1622,16 @@ static void sx_close(struct tty_struct *
 	tty_ldisc_flush(tty);
 	spin_lock_irqsave(&port->lock, flags);
 	tty->closing = 0;
-	port->tty = NULL;
+	port->port.tty = NULL;
 	spin_unlock_irqrestore(&port->lock, flags);
-	if (port->blocked_open) {
-		if (port->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(port->close_delay));
+	if (port->port.blocked_open) {
+		if (port->port.close_delay) {
+			msleep_interruptible(jiffies_to_msecs(port->port.close_delay));
 		}
-		wake_up_interruptible(&port->open_wait);
+		wake_up_interruptible(&port->port.open_wait);
 	}
-	port->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-	wake_up_interruptible(&port->close_wait);
+	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	wake_up_interruptible(&port->port.close_wait);
 
 	func_exit();
 }
@@ -1815,7 +1815,7 @@ static int sx_tiocmget(struct tty_struct
 	dprintk (SX_DEBUG_INIT, "Got msvr[%d] = %02x, car = %d.\n",
 		port_No(port), status, sx_in (bp, CD186x_CAR));
 	dprintk (SX_DEBUG_INIT, "sx_port = %p, port = %p\n", sx_port, port);
-	if (SX_CRTSCTS(port->tty)) {
+	if (SX_CRTSCTS(port->port.tty)) {
 		result  = /*   (status & MSVR_RTS) ? */ TIOCM_DTR /* : 0) */
 		          |   ((status & MSVR_DTR) ? TIOCM_RTS : 0)
 		          |   ((status & MSVR_CD)  ? TIOCM_CAR : 0)
@@ -1857,7 +1857,7 @@ static int sx_tiocmset(struct tty_struct
    /*   if (set & TIOCM_DTR)
 		port->MSVR |= MSVR_DTR; */
 
-	if (SX_CRTSCTS(port->tty)) {
+	if (SX_CRTSCTS(port->port.tty)) {
 		if (set & TIOCM_RTS)
 			port->MSVR |= MSVR_DTR;
 	} else {
@@ -1869,7 +1869,7 @@ static int sx_tiocmset(struct tty_struct
 		port->MSVR &= ~MSVR_RTS; */
   /*    if (clear & TIOCM_DTR)
 		port->MSVR &= ~MSVR_DTR; */
-	if (SX_CRTSCTS(port->tty)) {
+	if (SX_CRTSCTS(port->port.tty)) {
 		if (clear & TIOCM_RTS)
 			port->MSVR &= ~MSVR_DTR;
 	} else {
@@ -1929,27 +1929,27 @@ static inline int sx_set_serial_info(str
 
 	lock_kernel();
 
-	change_speed = ((port->flags & ASYNC_SPD_MASK) !=
+	change_speed = ((port->port.flags & ASYNC_SPD_MASK) !=
 			(tmp.flags & ASYNC_SPD_MASK));
 	change_speed |= (tmp.custom_divisor != port->custom_divisor);
 
 	if (!capable(CAP_SYS_ADMIN)) {
-		if ((tmp.close_delay != port->close_delay) ||
-		    (tmp.closing_wait != port->closing_wait) ||
+		if ((tmp.close_delay != port->port.close_delay) ||
+		    (tmp.closing_wait != port->port.closing_wait) ||
 		    ((tmp.flags & ~ASYNC_USR_MASK) !=
-		     (port->flags & ~ASYNC_USR_MASK))) {
+		     (port->port.flags & ~ASYNC_USR_MASK))) {
 			func_exit();
 			unlock_kernel();
 			return -EPERM;
 		}
-		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
+		port->port.flags = ((port->port.flags & ~ASYNC_USR_MASK) |
 		                  (tmp.flags & ASYNC_USR_MASK));
 		port->custom_divisor = tmp.custom_divisor;
 	} else {
-		port->flags = ((port->flags & ~ASYNC_FLAGS) |
+		port->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |
 		                  (tmp.flags & ASYNC_FLAGS));
-		port->close_delay = tmp.close_delay;
-		port->closing_wait = tmp.closing_wait;
+		port->port.close_delay = tmp.close_delay;
+		port->port.closing_wait = tmp.closing_wait;
 		port->custom_divisor = tmp.custom_divisor;
 	}
 	if (change_speed) {
@@ -1975,10 +1975,10 @@ static inline int sx_get_serial_info(str
 	tmp.line = port - sx_port;
 	tmp.port = bp->base;
 	tmp.irq  = bp->irq;
-	tmp.flags = port->flags;
+	tmp.flags = port->port.flags;
 	tmp.baud_base = (SX_OSCFREQ + CD186x_TPC/2) / CD186x_TPC;
-	tmp.close_delay = port->close_delay * HZ/100;
-	tmp.closing_wait = port->closing_wait * HZ/100;
+	tmp.close_delay = port->port.close_delay * HZ/100;
+	tmp.closing_wait = port->port.closing_wait * HZ/100;
 	tmp.custom_divisor =  port->custom_divisor;
 	tmp.xmit_fifo_size = CD186x_NFIFO;
 	unlock_kernel();
@@ -2199,17 +2199,17 @@ static void sx_hangup(struct tty_struct 
 
 	sx_shutdown_port(bp, port);
 	spin_lock_irqsave(&port->lock, flags);
-	bp->count -= port->count;
+	bp->count -= port->port.count;
 	if (bp->count < 0) {
 		printk(KERN_ERR "sx%d: sx_hangup: bad board count: %d port: %d\n",
 			board_No(bp), bp->count, tty->index);
 		bp->count = 0;
 	}
-	port->count = 0;
-	port->flags &= ~ASYNC_NORMAL_ACTIVE;
-	port->tty = NULL;
+	port->port.count = 0;
+	port->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	port->port.tty = NULL;
 	spin_unlock_irqrestore(&port->lock, flags);
-	wake_up_interruptible(&port->open_wait);
+	wake_up_interruptible(&port->port.open_wait);
 
 	func_exit();
 }
@@ -2224,10 +2224,6 @@ static void sx_set_termios(struct tty_st
 	if (sx_paranoia_check(port, tty->name, "sx_set_termios"))
 		return;
 
-	if (tty->termios->c_cflag == old_termios->c_cflag &&
-	    tty->termios->c_iflag == old_termios->c_iflag)
-		return;
-
 	bp = port_Board(port);
 	spin_lock_irqsave(&port->lock, flags);
 	sx_change_speed(port_Board(port), port);
@@ -2297,10 +2293,7 @@ static int sx_init_drivers(void)
 	memset(sx_port, 0, sizeof(sx_port));
 	for (i = 0; i < SX_NPORT * SX_NBOARD; i++) {
 		sx_port[i].magic = SPECIALIX_MAGIC;
-		sx_port[i].close_delay = 50 * HZ/100;
-		sx_port[i].closing_wait = 3000 * HZ/100;
-		init_waitqueue_head(&sx_port[i].open_wait);
-		init_waitqueue_head(&sx_port[i].close_wait);
+		tty_port_init(&sx_port[i].port);
 		spin_lock_init(&sx_port[i].lock);
 	}
 
--- a/drivers/char/specialix_io8.h
+++ b/drivers/char/specialix_io8.h
@@ -107,23 +107,17 @@ struct specialix_board {
 
 struct specialix_port {
 	int			magic;
+	struct tty_port		port;
 	int			baud_base;
 	int			flags;
-	struct tty_struct 	* tty;
-	int			count;
-	int			blocked_open;
 	int			timeout;
-	int			close_delay;
 	unsigned char 		* xmit_buf;
 	int			custom_divisor;
 	int			xmit_head;
 	int			xmit_tail;
 	int			xmit_cnt;
-	wait_queue_head_t	open_wait;
-	wait_queue_head_t	close_wait;
 	short			wakeup_chars;
 	short			break_length;
-	unsigned short		closing_wait;
 	unsigned char		mark_mask;
 	unsigned char		IER;
 	unsigned char		MSVR;
--- a/drivers/char/sx.c
+++ b/drivers/char/sx.c
@@ -2395,6 +2395,7 @@ static int sx_init_portstructs(int nboar
 		board->ports = port;
 		for (j = 0; j < boards[i].nports; j++) {
 			sx_dprintk(SX_DEBUG_INIT, "initing port %d\n", j);
+			tty_port_init(&port->gs.port);
 			port->gs.magic = SX_MAGIC;
 			port->gs.close_delay = HZ / 2;
 			port->gs.closing_wait = 30 * HZ;
@@ -2407,7 +2408,6 @@ static int sx_init_portstructs(int nboar
 			/*
 			 * Initializing wait queue
 			 */
-			tty_port_init(&port->gs.port);
 			port++;
 		}
 	}
--- a/drivers/char/synclink.c
+++ b/drivers/char/synclink.c
@@ -183,8 +183,6 @@ struct mgsl_struct {
 	struct tty_port		port;
 	int			line;
 	int                     hw_version;
-	unsigned short		close_delay;
-	unsigned short		closing_wait;	/* time to wait before closing */
 	
 	struct mgsl_icount	icount;
 	
@@ -3142,11 +3140,11 @@ static void mgsl_close(struct tty_struct
 	
 	/* wait for transmit data to clear all layers */
 	
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
+	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
 		if (debug_level >= DEBUG_LEVEL_INFO)
 			printk("%s(%d):mgsl_close(%s) calling tty_wait_until_sent\n",
 				 __FILE__,__LINE__, info->device_name );
-		tty_wait_until_sent(tty, info->closing_wait);
+		tty_wait_until_sent(tty, info->port.closing_wait);
 	}
 		
  	if (info->port.flags & ASYNC_INITIALIZED)
@@ -3162,8 +3160,8 @@ static void mgsl_close(struct tty_struct
 	info->port.tty = NULL;
 	
 	if (info->port.blocked_open) {
-		if (info->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->close_delay));
+		if (info->port.close_delay) {
+			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
 		}
 		wake_up_interruptible(&info->port.open_wait);
 	}
@@ -4326,12 +4324,12 @@ static struct mgsl_struct* mgsl_allocate
 	if (!info) {
 		printk("Error can't allocate device instance data\n");
 	} else {
+		tty_port_init(&info->port);
 		info->magic = MGSL_MAGIC;
 		INIT_WORK(&info->task, mgsl_bh_handler);
 		info->max_frame_size = 4096;
-		info->close_delay = 5*HZ/10;
-		info->closing_wait = 30*HZ;
-		tty_port_init(&info->port);
+		info->port.close_delay = 5*HZ/10;
+		info->port.closing_wait = 30*HZ;
 		init_waitqueue_head(&info->status_event_wait_q);
 		init_waitqueue_head(&info->event_wait_q);
 		spin_lock_init(&info->irq_spinlock);
--- a/drivers/char/synclink_gt.c
+++ b/drivers/char/synclink_gt.c
@@ -261,8 +261,6 @@ struct slgt_info {
 	struct slgt_info *port_array[SLGT_MAX_PORTS];
 
 	int			line;		/* tty line instance number */
-	unsigned short		close_delay;
-	unsigned short		closing_wait;	/* time to wait before closing */
 
 	struct mgsl_icount	icount;
 
@@ -758,9 +756,9 @@ static void close(struct tty_struct *tty
 
 	/* wait for transmit data to clear all layers */
 
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
+	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
 		DBGINFO(("%s call tty_wait_until_sent\n", info->device_name));
-		tty_wait_until_sent(tty, info->closing_wait);
+		tty_wait_until_sent(tty, info->port.closing_wait);
 	}
 
  	if (info->port.flags & ASYNC_INITIALIZED)
@@ -774,8 +772,8 @@ static void close(struct tty_struct *tty
 	info->port.tty = NULL;
 
 	if (info->port.blocked_open) {
-		if (info->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->close_delay));
+		if (info->port.close_delay) {
+			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
 		}
 		wake_up_interruptible(&info->port.open_wait);
 	}
@@ -3448,13 +3446,13 @@ static struct slgt_info *alloc_dev(int a
 		DBGERR(("%s device alloc failed adapter=%d port=%d\n",
 			driver_name, adapter_num, port_num));
 	} else {
+		tty_port_init(&info->port);
 		info->magic = MGSL_MAGIC;
 		INIT_WORK(&info->task, bh_handler);
 		info->max_frame_size = 4096;
 		info->raw_rx_size = DMABUFSIZE;
-		info->close_delay = 5*HZ/10;
-		info->closing_wait = 30*HZ;
-		tty_port_init(&info->port);
+		info->port.close_delay = 5*HZ/10;
+		info->port.closing_wait = 30*HZ;
 		init_waitqueue_head(&info->status_event_wait_q);
 		init_waitqueue_head(&info->event_wait_q);
 		spin_lock_init(&info->netlock);
--- a/drivers/char/synclinkmp.c
+++ b/drivers/char/synclinkmp.c
@@ -846,11 +846,11 @@ static void close(struct tty_struct *tty
 
 	/* wait for transmit data to clear all layers */
 
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
+	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
 		if (debug_level >= DEBUG_LEVEL_INFO)
 			printk("%s(%d):%s close() calling tty_wait_until_sent\n",
 				 __FILE__,__LINE__, info->device_name );
-		tty_wait_until_sent(tty, info->closing_wait);
+		tty_wait_until_sent(tty, info->port.closing_wait);
 	}
 
  	if (info->port.flags & ASYNC_INITIALIZED)
@@ -866,8 +866,8 @@ static void close(struct tty_struct *tty
 	info->port.tty = NULL;
 
 	if (info->port.blocked_open) {
-		if (info->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->close_delay));
+		if (info->port.close_delay) {
+			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
 		}
 		wake_up_interruptible(&info->port.open_wait);
 	}
@@ -3802,12 +3802,12 @@ static SLMP_INFO *alloc_dev(int adapter_
 		printk("%s(%d) Error can't allocate device instance data for adapter %d, port %d\n",
 			__FILE__,__LINE__, adapter_num, port_num);
 	} else {
+		tty_port_init(&info->port);
 		info->magic = MGSL_MAGIC;
 		INIT_WORK(&info->task, bh_handler);
 		info->max_frame_size = 4096;
-		info->close_delay = 5*HZ/10;
-		info->closing_wait = 30*HZ;
-		tty_port_init(&info->port);
+		info->port.close_delay = 5*HZ/10;
+		info->port.closing_wait = 30*HZ;
 		init_waitqueue_head(&info->status_event_wait_q);
 		init_waitqueue_head(&info->event_wait_q);
 		spin_lock_init(&info->netlock);
--- a/drivers/char/tty_io.c
+++ b/drivers/char/tty_io.c
@@ -2094,6 +2094,8 @@ void tty_port_init(struct tty_port *port
 	init_waitqueue_head(&port->open_wait);
 	init_waitqueue_head(&port->close_wait);
 	mutex_init(&port->mutex);
+	port->close_delay = (50 * HZ) / 100;
+	port->closing_wait = (3000 * HZ) / 100;
 }
 EXPORT_SYMBOL(tty_port_init);
 
--- a/include/linux/cyclades.h
+++ b/include/linux/cyclades.h
@@ -567,8 +567,6 @@ struct cyclades_port {
 	int			chip_rev;
 	int			custom_divisor;
 	u8			x_char; /* to be pushed out ASAP */
-	int			close_delay;
-	unsigned short		closing_wait;
 	int                     breakon;
 	int                     breakoff;
 	int			xmit_head;
@@ -586,8 +584,8 @@ struct cyclades_port {
 };
 
 #define	CLOSING_WAIT_DELAY	30*HZ
-#define CY_CLOSING_WAIT_NONE	65535
-#define CY_CLOSING_WAIT_INF	0
+#define CY_CLOSING_WAIT_NONE	ASYNC_CLOSING_WAIT_NONE
+#define CY_CLOSING_WAIT_INF	ASYNC_CLOSING_WAIT_INF
 
 
 #define CyMAX_CHIPS_PER_CARD	8
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -188,6 +188,8 @@ struct tty_port {
 	unsigned long		flags;		/* TTY flags ASY_*/
 	struct mutex		mutex;		/* Locking */
 	unsigned char		*xmit_buf;	/* Optional buffer */
+	int			close_delay;	/* Close port delay */
+	int			closing_wait;	/* Delay for output */
 };
 
 /*
