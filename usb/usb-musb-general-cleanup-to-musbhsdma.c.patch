From felipe.balbi@nokia.com  Tue Sep 23 16:06:11 2008
From: Felipe Balbi <felipe.balbi@nokia.com>
Date: Thu, 11 Sep 2008 11:53:24 +0300
Subject: usb: musb: general cleanup to musbhsdma.c
To: linux-usb@vger.kernel.org
Cc: Greg Kroah-Hartman <gregkh@suse.de>, Felipe Balbi <felipe.balbi@nokia.com>
Message-ID: <1221123205-11984-7-git-send-email-felipe.balbi@nokia.com>


Basically getting rid of CaMeLcAsE, but also adding
missing lines and spaces.

Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/musb/musbhsdma.c |  308 +++++++++++++++++++++----------------------
 1 file changed, 156 insertions(+), 152 deletions(-)

--- a/drivers/usb/musb/musbhsdma.c
+++ b/drivers/usb/musb/musbhsdma.c
@@ -45,8 +45,8 @@
 #define MUSB_HSDMA_ADDRESS		0x8
 #define MUSB_HSDMA_COUNT		0xc
 
-#define MUSB_HSDMA_CHANNEL_OFFSET(_bChannel, _offset)		\
-		(MUSB_HSDMA_BASE + (_bChannel << 4) + _offset)
+#define MUSB_HSDMA_CHANNEL_OFFSET(_bchannel, _offset)		\
+		(MUSB_HSDMA_BASE + (_bchannel << 4) + _offset)
 
 /* control register (16-bit): */
 #define MUSB_HSDMA_ENABLE_SHIFT		0
@@ -67,23 +67,23 @@
 struct musb_dma_controller;
 
 struct musb_dma_channel {
-	struct dma_channel		Channel;
+	struct dma_channel		channel;
 	struct musb_dma_controller	*controller;
-	u32				dwStartAddress;
+	u32				start_addr;
 	u32				len;
-	u16				wMaxPacketSize;
-	u8				bIndex;
+	u16				max_packet_sz;
+	u8				idx;
 	u8				epnum;
 	u8				transmit;
 };
 
 struct musb_dma_controller {
-	struct dma_controller		Controller;
-	struct musb_dma_channel		aChannel[MUSB_HSDMA_CHANNELS];
-	void				*pDmaPrivate;
-	void __iomem			*pCoreBase;
-	u8				bChannelCount;
-	u8				bmUsedChannels;
+	struct dma_controller		controller;
+	struct musb_dma_channel		channel[MUSB_HSDMA_CHANNELS];
+	void				*private_data;
+	void __iomem			*base;
+	u8				channel_count;
+	u8				used_channels;
 	u8				irq;
 };
 
@@ -93,91 +93,91 @@ static int dma_controller_start(struct d
 	return 0;
 }
 
-static void dma_channel_release(struct dma_channel *pChannel);
+static void dma_channel_release(struct dma_channel *channel);
 
 static int dma_controller_stop(struct dma_controller *c)
 {
-	struct musb_dma_controller *controller =
-		container_of(c, struct musb_dma_controller, Controller);
-	struct musb *musb = (struct musb *) controller->pDmaPrivate;
-	struct dma_channel *pChannel;
-	u8 bBit;
+	struct musb_dma_controller *controller = container_of(c,
+			struct musb_dma_controller, controller);
+	struct musb *musb = controller->private_data;
+	struct dma_channel *channel;
+	u8 bit;
 
-	if (controller->bmUsedChannels != 0) {
+	if (controller->used_channels != 0) {
 		dev_err(musb->controller,
 			"Stopping DMA controller while channel active\n");
 
-		for (bBit = 0; bBit < MUSB_HSDMA_CHANNELS; bBit++) {
-			if (controller->bmUsedChannels & (1 << bBit)) {
-				pChannel = &controller->aChannel[bBit].Channel;
-				dma_channel_release(pChannel);
+		for (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {
+			if (controller->used_channels & (1 << bit)) {
+				channel = &controller->channel[bit].channel;
+				dma_channel_release(channel);
 
-				if (!controller->bmUsedChannels)
+				if (!controller->used_channels)
 					break;
 			}
 		}
 	}
+
 	return 0;
 }
 
 static struct dma_channel *dma_channel_allocate(struct dma_controller *c,
 				struct musb_hw_ep *hw_ep, u8 transmit)
 {
-	u8 bBit;
-	struct dma_channel *pChannel = NULL;
-	struct musb_dma_channel *pImplChannel = NULL;
-	struct musb_dma_controller *controller =
-			container_of(c, struct musb_dma_controller, Controller);
-
-	for (bBit = 0; bBit < MUSB_HSDMA_CHANNELS; bBit++) {
-		if (!(controller->bmUsedChannels & (1 << bBit))) {
-			controller->bmUsedChannels |= (1 << bBit);
-			pImplChannel = &(controller->aChannel[bBit]);
-			pImplChannel->controller = controller;
-			pImplChannel->bIndex = bBit;
-			pImplChannel->epnum = hw_ep->epnum;
-			pImplChannel->transmit = transmit;
-			pChannel = &(pImplChannel->Channel);
-			pChannel->private_data = pImplChannel;
-			pChannel->status = MUSB_DMA_STATUS_FREE;
-			pChannel->max_len = 0x10000;
+	struct musb_dma_controller *controller = container_of(c,
+			struct musb_dma_controller, controller);
+	struct musb_dma_channel *musb_channel = NULL;
+	struct dma_channel *channel = NULL;
+	u8 bit;
+
+	for (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {
+		if (!(controller->used_channels & (1 << bit))) {
+			controller->used_channels |= (1 << bit);
+			musb_channel = &(controller->channel[bit]);
+			musb_channel->controller = controller;
+			musb_channel->idx = bit;
+			musb_channel->epnum = hw_ep->epnum;
+			musb_channel->transmit = transmit;
+			channel = &(musb_channel->channel);
+			channel->private_data = musb_channel;
+			channel->status = MUSB_DMA_STATUS_FREE;
+			channel->max_len = 0x10000;
 			/* Tx => mode 1; Rx => mode 0 */
-			pChannel->desired_mode = transmit;
-			pChannel->actual_len = 0;
+			channel->desired_mode = transmit;
+			channel->actual_len = 0;
 			break;
 		}
 	}
-	return pChannel;
+
+	return channel;
 }
 
-static void dma_channel_release(struct dma_channel *pChannel)
+static void dma_channel_release(struct dma_channel *channel)
 {
-	struct musb_dma_channel *pImplChannel =
-		(struct musb_dma_channel *) pChannel->private_data;
+	struct musb_dma_channel *musb_channel = channel->private_data;
 
-	pChannel->actual_len = 0;
-	pImplChannel->dwStartAddress = 0;
-	pImplChannel->len = 0;
+	channel->actual_len = 0;
+	musb_channel->start_addr = 0;
+	musb_channel->len = 0;
 
-	pImplChannel->controller->bmUsedChannels &=
-		~(1 << pImplChannel->bIndex);
+	musb_channel->controller->used_channels &=
+		~(1 << musb_channel->idx);
 
-	pChannel->status = MUSB_DMA_STATUS_UNKNOWN;
+	channel->status = MUSB_DMA_STATUS_UNKNOWN;
 }
 
-static void configure_channel(struct dma_channel *pChannel,
+static void configure_channel(struct dma_channel *channel,
 				u16 packet_sz, u8 mode,
 				dma_addr_t dma_addr, u32 len)
 {
-	struct musb_dma_channel *pImplChannel =
-		(struct musb_dma_channel *) pChannel->private_data;
-	struct musb_dma_controller *controller = pImplChannel->controller;
-	void __iomem *mbase = controller->pCoreBase;
-	u8 bChannel = pImplChannel->bIndex;
+	struct musb_dma_channel *musb_channel = channel->private_data;
+	struct musb_dma_controller *controller = musb_channel->controller;
+	void __iomem *mbase = controller->base;
+	u8 bchannel = musb_channel->idx;
 	u16 csr = 0;
 
 	DBG(4, "%p, pkt_sz %d, addr 0x%x, len %d, mode %d\n",
-			pChannel, packet_sz, dma_addr, len, mode);
+			channel, packet_sz, dma_addr, len, mode);
 
 	if (mode) {
 		csr |= 1 << MUSB_HSDMA_MODE1_SHIFT;
@@ -195,180 +195,183 @@ static void configure_channel(struct dma
 		}
 	}
 
-	csr |= (pImplChannel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)
+	csr |= (musb_channel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)
 		| (1 << MUSB_HSDMA_ENABLE_SHIFT)
 		| (1 << MUSB_HSDMA_IRQENABLE_SHIFT)
-		| (pImplChannel->transmit
+		| (musb_channel->transmit
 				? (1 << MUSB_HSDMA_TRANSMIT_SHIFT)
 				: 0);
 
 	/* address/count */
 	musb_writel(mbase,
-		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
+		MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_ADDRESS),
 		dma_addr);
 	musb_writel(mbase,
-		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
+		MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_COUNT),
 		len);
 
 	/* control (this should start things) */
 	musb_writew(mbase,
-		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
+		MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_CONTROL),
 		csr);
 }
 
-static int dma_channel_program(struct dma_channel *pChannel,
+static int dma_channel_program(struct dma_channel *channel,
 				u16 packet_sz, u8 mode,
 				dma_addr_t dma_addr, u32 len)
 {
-	struct musb_dma_channel *pImplChannel =
-			(struct musb_dma_channel *) pChannel->private_data;
+	struct musb_dma_channel *musb_channel = channel->private_data;
 
 	DBG(2, "ep%d-%s pkt_sz %d, dma_addr 0x%x length %d, mode %d\n",
-		pImplChannel->epnum,
-		pImplChannel->transmit ? "Tx" : "Rx",
+		musb_channel->epnum,
+		musb_channel->transmit ? "Tx" : "Rx",
 		packet_sz, dma_addr, len, mode);
 
-	BUG_ON(pChannel->status == MUSB_DMA_STATUS_UNKNOWN ||
-		pChannel->status == MUSB_DMA_STATUS_BUSY);
+	BUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||
+		channel->status == MUSB_DMA_STATUS_BUSY);
 
-	pChannel->actual_len = 0;
-	pImplChannel->dwStartAddress = dma_addr;
-	pImplChannel->len = len;
-	pImplChannel->wMaxPacketSize = packet_sz;
-	pChannel->status = MUSB_DMA_STATUS_BUSY;
+	channel->actual_len = 0;
+	musb_channel->start_addr = dma_addr;
+	musb_channel->len = len;
+	musb_channel->max_packet_sz = packet_sz;
+	channel->status = MUSB_DMA_STATUS_BUSY;
 
 	if ((mode == 1) && (len >= packet_sz))
-		configure_channel(pChannel, packet_sz, 1, dma_addr, len);
+		configure_channel(channel, packet_sz, 1, dma_addr, len);
 	else
-		configure_channel(pChannel, packet_sz, 0, dma_addr, len);
+		configure_channel(channel, packet_sz, 0, dma_addr, len);
 
 	return true;
 }
 
-static int dma_channel_abort(struct dma_channel *pChannel)
+static int dma_channel_abort(struct dma_channel *channel)
 {
-	struct musb_dma_channel *pImplChannel =
-		(struct musb_dma_channel *) pChannel->private_data;
-	u8 bChannel = pImplChannel->bIndex;
-	void __iomem *mbase = pImplChannel->controller->pCoreBase;
+	struct musb_dma_channel *musb_channel = channel->private_data;
+	void __iomem *mbase = musb_channel->controller->base;
+
+	u8 bchannel = musb_channel->idx;
 	u16 csr;
 
-	if (pChannel->status == MUSB_DMA_STATUS_BUSY) {
-		if (pImplChannel->transmit) {
+	if (channel->status == MUSB_DMA_STATUS_BUSY) {
+		if (musb_channel->transmit) {
 
 			csr = musb_readw(mbase,
-				MUSB_EP_OFFSET(pImplChannel->epnum,
+				MUSB_EP_OFFSET(musb_channel->epnum,
 						MUSB_TXCSR));
 			csr &= ~(MUSB_TXCSR_AUTOSET |
 				 MUSB_TXCSR_DMAENAB |
 				 MUSB_TXCSR_DMAMODE);
 			musb_writew(mbase,
-				MUSB_EP_OFFSET(pImplChannel->epnum,
-						MUSB_TXCSR),
+				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_TXCSR),
 				csr);
 		} else {
 			csr = musb_readw(mbase,
-				MUSB_EP_OFFSET(pImplChannel->epnum,
+				MUSB_EP_OFFSET(musb_channel->epnum,
 						MUSB_RXCSR));
 			csr &= ~(MUSB_RXCSR_AUTOCLEAR |
 				 MUSB_RXCSR_DMAENAB |
 				 MUSB_RXCSR_DMAMODE);
 			musb_writew(mbase,
-				MUSB_EP_OFFSET(pImplChannel->epnum,
-						MUSB_RXCSR),
+				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_RXCSR),
 				csr);
 		}
 
 		musb_writew(mbase,
-			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
+			MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_CONTROL),
 			0);
 		musb_writel(mbase,
-			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
+			MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_ADDRESS),
 			0);
 		musb_writel(mbase,
-			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
+			MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_COUNT),
 			0);
 
-		pChannel->status = MUSB_DMA_STATUS_FREE;
+		channel->status = MUSB_DMA_STATUS_FREE;
 	}
+
 	return 0;
 }
 
 static irqreturn_t dma_controller_irq(int irq, void *private_data)
 {
-	struct musb_dma_controller *controller =
-		(struct musb_dma_controller *)private_data;
-	struct musb_dma_channel *pImplChannel;
-	struct musb *musb = controller->pDmaPrivate;
-	void __iomem *mbase = controller->pCoreBase;
-	struct dma_channel *pChannel;
-	u8 bChannel;
-	u16 csr;
-	u32 dwAddress;
-	u8 int_hsdma;
+	struct musb_dma_controller *controller = private_data;
+	struct musb *musb = controller->private_data;
+	struct musb_dma_channel *musb_channel;
+	struct dma_channel *channel;
+
+	void __iomem *mbase = controller->base;
+
 	irqreturn_t retval = IRQ_NONE;
+
 	unsigned long flags;
 
+	u8 bchannel;
+	u8 int_hsdma;
+
+	u32 addr;
+	u16 csr;
+
 	spin_lock_irqsave(&musb->lock, flags);
 
 	int_hsdma = musb_readb(mbase, MUSB_HSDMA_INTR);
 	if (!int_hsdma)
 		goto done;
 
-	for (bChannel = 0; bChannel < MUSB_HSDMA_CHANNELS; bChannel++) {
-		if (int_hsdma & (1 << bChannel)) {
-			pImplChannel = (struct musb_dma_channel *)
-					&(controller->aChannel[bChannel]);
-			pChannel = &pImplChannel->Channel;
+	for (bchannel = 0; bchannel < MUSB_HSDMA_CHANNELS; bchannel++) {
+		if (int_hsdma & (1 << bchannel)) {
+			musb_channel = (struct musb_dma_channel *)
+					&(controller->channel[bchannel]);
+			channel = &musb_channel->channel;
 
 			csr = musb_readw(mbase,
-					MUSB_HSDMA_CHANNEL_OFFSET(bChannel,
+					MUSB_HSDMA_CHANNEL_OFFSET(bchannel,
 							MUSB_HSDMA_CONTROL));
 
-			if (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT))
-				pImplChannel->Channel.status =
+			if (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT)) {
+				musb_channel->channel.status =
 					MUSB_DMA_STATUS_BUS_ABORT;
-			else {
+			} else {
 				u8 devctl;
 
-				dwAddress = musb_readl(mbase,
+				addr = musb_readl(mbase,
 						MUSB_HSDMA_CHANNEL_OFFSET(
-							bChannel,
+							bchannel,
 							MUSB_HSDMA_ADDRESS));
-				pChannel->actual_len = dwAddress
-					- pImplChannel->dwStartAddress;
+				channel->actual_len = addr
+					- musb_channel->start_addr;
 
 				DBG(2, "ch %p, 0x%x -> 0x%x (%d / %d) %s\n",
-					pChannel, pImplChannel->dwStartAddress,
-					dwAddress, pChannel->actual_len,
-					pImplChannel->len,
-					(pChannel->actual_len
-						< pImplChannel->len) ?
+					channel, musb_channel->start_addr,
+					addr, channel->actual_len,
+					musb_channel->len,
+					(channel->actual_len
+						< musb_channel->len) ?
 					"=> reconfig 0" : "=> complete");
 
 				devctl = musb_readb(mbase, MUSB_DEVCTL);
 
-				pChannel->status = MUSB_DMA_STATUS_FREE;
+				channel->status = MUSB_DMA_STATUS_FREE;
 
 				/* completed */
 				if ((devctl & MUSB_DEVCTL_HM)
-					&& (pImplChannel->transmit)
-					&& ((pChannel->desired_mode == 0)
-					    || (pChannel->actual_len &
-					    (pImplChannel->wMaxPacketSize - 1)))
+					&& (musb_channel->transmit)
+					&& ((channel->desired_mode == 0)
+					    || (channel->actual_len &
+					    (musb_channel->max_packet_sz - 1)))
 					 ) {
 					/* Send out the packet */
 					musb_ep_select(mbase,
-						pImplChannel->epnum);
+						musb_channel->epnum);
 					musb_writew(mbase, MUSB_EP_OFFSET(
-							pImplChannel->epnum,
+							musb_channel->epnum,
 							MUSB_TXCSR),
 						MUSB_TXCSR_TXPKTRDY);
-				} else
+				} else {
 					musb_dma_completion(
 						musb,
-						pImplChannel->epnum,
-						pImplChannel->transmit);
+						musb_channel->epnum,
+						musb_channel->transmit);
+				}
 			}
 		}
 	}
@@ -380,9 +383,9 @@ done:
 
 void dma_controller_destroy(struct dma_controller *c)
 {
-	struct musb_dma_controller *controller;
+	struct musb_dma_controller *controller = container_of(c,
+			struct musb_dma_controller, controller);
 
-	controller = container_of(c, struct musb_dma_controller, Controller);
 	if (!controller)
 		return;
 
@@ -393,7 +396,7 @@ void dma_controller_destroy(struct dma_c
 }
 
 struct dma_controller *__init
-dma_controller_create(struct musb *musb, void __iomem *pCoreBase)
+dma_controller_create(struct musb *musb, void __iomem *base)
 {
 	struct musb_dma_controller *controller;
 	struct device *dev = musb->controller;
@@ -405,29 +408,30 @@ dma_controller_create(struct musb *musb,
 		return NULL;
 	}
 
-	controller = kzalloc(sizeof(struct musb_dma_controller), GFP_KERNEL);
+	controller = kzalloc(sizeof(*controller), GFP_KERNEL);
 	if (!controller)
 		return NULL;
 
-	controller->bChannelCount = MUSB_HSDMA_CHANNELS;
-	controller->pDmaPrivate = musb;
-	controller->pCoreBase = pCoreBase;
-
-	controller->Controller.start = dma_controller_start;
-	controller->Controller.stop = dma_controller_stop;
-	controller->Controller.channel_alloc = dma_channel_allocate;
-	controller->Controller.channel_release = dma_channel_release;
-	controller->Controller.channel_program = dma_channel_program;
-	controller->Controller.channel_abort = dma_channel_abort;
+	controller->channel_count = MUSB_HSDMA_CHANNELS;
+	controller->private_data = musb;
+	controller->base = base;
+
+	controller->controller.start = dma_controller_start;
+	controller->controller.stop = dma_controller_stop;
+	controller->controller.channel_alloc = dma_channel_allocate;
+	controller->controller.channel_release = dma_channel_release;
+	controller->controller.channel_program = dma_channel_program;
+	controller->controller.channel_abort = dma_channel_abort;
 
 	if (request_irq(irq, dma_controller_irq, IRQF_DISABLED,
-			musb->controller->bus_id, &controller->Controller)) {
+			musb->controller->bus_id, &controller->controller)) {
 		dev_err(dev, "request_irq %d failed!\n", irq);
-		dma_controller_destroy(&controller->Controller);
+		dma_controller_destroy(&controller->controller);
+
 		return NULL;
 	}
 
 	controller->irq = irq;
 
-	return &controller->Controller;
+	return &controller->controller;
 }
