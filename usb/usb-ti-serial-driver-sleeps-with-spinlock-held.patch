From oneukum@suse.de Sun May  6 23:33:32 2007
From: Oliver Neukum <oneukum@suse.de>
Date: Mon, 7 May 2007 08:33:18 +0200
Subject: USB: ti serial driver sleeps with spinlock held
To: <pberger@brimson.com>, <alborchers@steinerpoint.com>, "Greg Kroah-Hartman" <gregkh@suse.de>, linux-usb-devel@lists.sourceforge.net
Message-ID: <200705070833.19149.oneukum@suse.de>
Content-Disposition: inline


you are submitting an URB with GFP_KERNEL holding a spinlock.
In this case the spinlock can be dropped earlier.

Signed-off-by: Oliver Neukum <oneukum@suse.de>
Cc: Al Borchers <alborchers@steinerpoint.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/usb/serial/ti_usb_3410_5052.c |    8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

--- a/drivers/usb/serial/ti_usb_3410_5052.c
+++ b/drivers/usb/serial/ti_usb_3410_5052.c
@@ -1555,15 +1555,17 @@ static int ti_restart_read(struct ti_por
 	spin_lock_irqsave(&tport->tp_lock, flags);
 
 	if (tport->tp_read_urb_state == TI_READ_URB_STOPPED) {
+		tport->tp_read_urb_state = TI_READ_URB_RUNNING;
 		urb = tport->tp_port->read_urb;
+		spin_unlock_irqrestore(&tport->tp_lock, flags);
 		urb->complete = ti_bulk_in_callback;
 		urb->context = tport;
 		urb->dev = tport->tp_port->serial->dev;
 		status = usb_submit_urb(urb, GFP_KERNEL);
+	} else  {
+		tport->tp_read_urb_state = TI_READ_URB_RUNNING;
+		spin_unlock_irqrestore(&tport->tp_lock, flags);
 	}
-	tport->tp_read_urb_state = TI_READ_URB_RUNNING;
-
-	spin_unlock_irqrestore(&tport->tp_lock, flags);
 
 	return status;
 }
