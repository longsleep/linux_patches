From m.nazarewicz@samsung.com  Tue Sep 28 18:56:38 2010
From: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date: Tue, 28 Sep 2010 12:55:32 +0200
Subject: USB: gadget: file_storage: reuse definitions from a header file
To: Matthew Wilcox <willy@linux.intel.com>, greg@kroah.com
Cc: sarah.a.sharp@linux.intel.com, Michal Nazarewicz <mina86@mina86.com>, Alan Stern <stern@rowland.harvard.edu>
Message-ID: <5d4c116b32f9e6c45bb09eb6f28d5ef2e1b26c1f.1285670575.git.mina86@mina86.com>


From: Michal Nazarewicz <mina86@mina86.com>

This commit changes storage_common.c and file_storage.c to
reuse definitions from linux/usb/storage.h header file.

Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
Cc: Alan Stern <stern@rowland.harvard.edu>
Cc: Matthew Wilcox <willy@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/file_storage.c   |   50 ++++++++++++++++++------------------
 drivers/usb/gadget/storage_common.c |   18 ++----------
 2 files changed, 28 insertions(+), 40 deletions(-)

--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -400,9 +400,9 @@ MODULE_PARM_DESC(buflen, "I/O buffer siz
 
 #ifdef CONFIG_USB_FILE_STORAGE_TEST
 
-#define transport_is_bbb()	(mod_data.transport_type == USB_PR_BULK)
-#define transport_is_cbi()	(mod_data.transport_type == USB_PR_CBI)
-#define protocol_is_scsi()	(mod_data.protocol_type == USB_SC_SCSI)
+#define transport_is_bbb()	(mod_data.transport_type == US_PR_BULK)
+#define transport_is_cbi()	(mod_data.transport_type == US_PR_CBI)
+#define protocol_is_scsi()	(mod_data.protocol_type == US_SC_SCSI)
 
 #else
 
@@ -2183,18 +2183,18 @@ static int send_status(struct fsg_dev *f
 		start_transfer(fsg, fsg->bulk_in, bh->inreq,
 				&bh->inreq_busy, &bh->state);
 
-	} else if (mod_data.transport_type == USB_PR_CB) {
+	} else if (mod_data.transport_type == US_PR_CB) {
 
 		/* Control-Bulk transport has no status phase! */
 		return 0;
 
-	} else {			// USB_PR_CBI
+	} else {			// US_PR_CBI
 		struct interrupt_data	*buf = bh->buf;
 
 		/* Store and send the Interrupt data.  UFI sends the ASC
 		 * and ASCQ bytes.  Everything else sends a Type (which
 		 * is always 0) and the status Value. */
-		if (mod_data.protocol_type == USB_SC_UFI) {
+		if (mod_data.protocol_type == US_SC_UFI) {
 			buf->bType = ASC(sd);
 			buf->bValue = ASCQ(sd);
 		} else {
@@ -2236,7 +2236,7 @@ static int check_command(struct fsg_dev
 
 	/* There's some disagreement as to whether RBC pads commands or not.
 	 * We'll play it safe and accept either form. */
-	else if (mod_data.protocol_type == USB_SC_RBC) {
+	else if (mod_data.protocol_type == US_SC_RBC) {
 		if (fsg->cmnd_size == 12)
 			cmnd_size = 12;
 
@@ -2707,7 +2707,7 @@ static int get_next_command(struct fsg_d
 		rc = received_cbw(fsg, bh);
 		bh->state = BUF_STATE_EMPTY;
 
-	} else {		// USB_PR_CB or USB_PR_CBI
+	} else {		// US_PR_CB or US_PR_CBI
 
 		/* Wait for the next command to arrive */
 		while (fsg->cbbuf_cmnd_size == 0) {
@@ -3213,9 +3213,9 @@ static int __init check_parameters(struc
 	int	gcnum;
 
 	/* Store the default values */
-	mod_data.transport_type = USB_PR_BULK;
+	mod_data.transport_type = US_PR_BULK;
 	mod_data.transport_name = "Bulk-only";
-	mod_data.protocol_type = USB_SC_SCSI;
+	mod_data.protocol_type = US_SC_SCSI;
 	mod_data.protocol_name = "Transparent SCSI";
 
 	/* Some peripheral controllers are known not to be able to
@@ -3242,10 +3242,10 @@ static int __init check_parameters(struc
 	if (strnicmp(mod_data.transport_parm, "BBB", 10) == 0) {
 		;		// Use default setting
 	} else if (strnicmp(mod_data.transport_parm, "CB", 10) == 0) {
-		mod_data.transport_type = USB_PR_CB;
+		mod_data.transport_type = US_PR_CB;
 		mod_data.transport_name = "Control-Bulk";
 	} else if (strnicmp(mod_data.transport_parm, "CBI", 10) == 0) {
-		mod_data.transport_type = USB_PR_CBI;
+		mod_data.transport_type = US_PR_CBI;
 		mod_data.transport_name = "Control-Bulk-Interrupt";
 	} else {
 		ERROR(fsg, "invalid transport: %s\n", mod_data.transport_parm);
@@ -3253,28 +3253,28 @@ static int __init check_parameters(struc
 	}
 
 	if (strnicmp(mod_data.protocol_parm, "SCSI", 10) == 0 ||
-			prot == USB_SC_SCSI) {
+			prot == US_SC_SCSI) {
 		;		// Use default setting
 	} else if (strnicmp(mod_data.protocol_parm, "RBC", 10) == 0 ||
-			prot == USB_SC_RBC) {
-		mod_data.protocol_type = USB_SC_RBC;
+			prot == US_SC_RBC) {
+		mod_data.protocol_type = US_SC_RBC;
 		mod_data.protocol_name = "RBC";
 	} else if (strnicmp(mod_data.protocol_parm, "8020", 4) == 0 ||
 			strnicmp(mod_data.protocol_parm, "ATAPI", 10) == 0 ||
-			prot == USB_SC_8020) {
-		mod_data.protocol_type = USB_SC_8020;
+			prot == US_SC_8020) {
+		mod_data.protocol_type = US_SC_8020;
 		mod_data.protocol_name = "8020i (ATAPI)";
 	} else if (strnicmp(mod_data.protocol_parm, "QIC", 3) == 0 ||
-			prot == USB_SC_QIC) {
-		mod_data.protocol_type = USB_SC_QIC;
+			prot == US_SC_QIC) {
+		mod_data.protocol_type = US_SC_QIC;
 		mod_data.protocol_name = "QIC-157";
 	} else if (strnicmp(mod_data.protocol_parm, "UFI", 10) == 0 ||
-			prot == USB_SC_UFI) {
-		mod_data.protocol_type = USB_SC_UFI;
+			prot == US_SC_UFI) {
+		mod_data.protocol_type = US_SC_UFI;
 		mod_data.protocol_name = "UFI";
 	} else if (strnicmp(mod_data.protocol_parm, "8070", 4) == 0 ||
-			prot == USB_SC_8070) {
-		mod_data.protocol_type = USB_SC_8070;
+			prot == US_SC_8070) {
+		mod_data.protocol_type = US_SC_8070;
 		mod_data.protocol_name = "8070i";
 	} else {
 		ERROR(fsg, "invalid protocol: %s\n", mod_data.protocol_parm);
@@ -3312,8 +3312,8 @@ static int __init check_parameters(struc
 			}
 		}
 		if (len > 126 ||
-		    (mod_data.transport_type == USB_PR_BULK && len < 12) ||
-		    (mod_data.transport_type != USB_PR_BULK && len > 12)) {
+		    (mod_data.transport_type == US_PR_BULK && len < 12) ||
+		    (mod_data.transport_type != US_PR_BULK && len > 12)) {
 			WARNING(fsg, "Invalid serial string length!\n");
 			goto no_serial;
 		}
--- a/drivers/usb/gadget/storage_common.c
+++ b/drivers/usb/gadget/storage_common.c
@@ -54,6 +54,7 @@
 
 
 #include <asm/unaligned.h>
+#include <linux/usb/storage.h>
 
 
 /*
@@ -156,19 +157,6 @@
 #define TYPE_DISK	0x00
 #define TYPE_CDROM	0x05
 
-/* USB protocol value = the transport method */
-#define USB_PR_CBI	0x00		/* Control/Bulk/Interrupt */
-#define USB_PR_CB	0x01		/* Control/Bulk w/o interrupt */
-#define USB_PR_BULK	0x50		/* Bulk-only */
-
-/* USB subclass value = the protocol encapsulation */
-#define USB_SC_RBC	0x01		/* Reduced Block Commands (flash) */
-#define USB_SC_8020	0x02		/* SFF-8020i, MMC-2, ATAPI (CD-ROM) */
-#define USB_SC_QIC	0x03		/* QIC-157 (tape) */
-#define USB_SC_UFI	0x04		/* UFI (floppy) */
-#define USB_SC_8070	0x05		/* SFF-8070i (removable) */
-#define USB_SC_SCSI	0x06		/* Transparent SCSI */
-
 /* Bulk-only data structures */
 
 /* Command Block Wrapper */
@@ -407,8 +395,8 @@ fsg_intf_desc = {
 
 	.bNumEndpoints =	2,		/* Adjusted during fsg_bind() */
 	.bInterfaceClass =	USB_CLASS_MASS_STORAGE,
-	.bInterfaceSubClass =	USB_SC_SCSI,	/* Adjusted during fsg_bind() */
-	.bInterfaceProtocol =	USB_PR_BULK,	/* Adjusted during fsg_bind() */
+	.bInterfaceSubClass =	US_SC_SCSI,	/* Adjusted during fsg_bind() */
+	.bInterfaceProtocol =	US_PR_BULK,	/* Adjusted during fsg_bind() */
 	.iInterface =		FSG_STRING_INTERFACE,
 };
 
