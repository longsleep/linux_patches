From alek.du@intel.com  Thu Jul 16 16:15:33 2009
From: Alek Du <alek.du@intel.com>
Date: Mon, 13 Jul 2009 17:30:41 +0800
Subject: USB: EHCI: add need_io_watchdog flag to ehci_hcd
To: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Cc: Greg KH <greg@kroah.com>, David Brownell <david-b@pacbell.net>, "Alan Stern" <stern@rowland.harvard.edu>
Message-ID: <20090713173041.6c2c3d1e@dxy.sh.intel.com>


From: Alek Du <alek.du@intel.com>

Basically the io watchdog is only useful for those quirk HCDs. For most
good ones, it only brings unnecessary wakeups.  At least, I know the
Intel EHCI HCDs should turn off the flag.

Signed-off-by: Alek Du <alek.du@intel.com>
Cc: David Brownell <dbrownell@users.sourceforge.net>
Cc: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/ehci-hcd.c |    6 ++++++
 drivers/usb/host/ehci-pci.c |    3 +++
 drivers/usb/host/ehci.h     |    1 +
 3 files changed, 10 insertions(+)

--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -126,6 +126,7 @@ struct ehci_hcd {			/* one per controlle
 	unsigned		big_endian_mmio:1;
 	unsigned		big_endian_desc:1;
 	unsigned		has_amcc_usb23:1;
+	unsigned		need_io_watchdog:1;
 
 	/* required for usb32 quirk */
 	#define OHCI_CTRL_HCFS          (3 << 6)
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -127,6 +127,8 @@ timer_action(struct ehci_hcd *ehci, enum
 
 		switch (action) {
 		case TIMER_IO_WATCHDOG:
+			if (!ehci->need_io_watchdog)
+				return;
 			t = EHCI_IO_JIFFIES;
 			break;
 		case TIMER_ASYNC_OFF:
@@ -508,6 +510,10 @@ static int ehci_init(struct usb_hcd *hcd
 
 	spin_lock_init(&ehci->lock);
 
+	/*
+	 * keep io watchdog by default, those good HCDs could turn off it later
+	 */
+	ehci->need_io_watchdog = 1;
 	init_timer(&ehci->watchdog);
 	ehci->watchdog.function = ehci_watchdog;
 	ehci->watchdog.data = (unsigned long) ehci;
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -129,6 +129,9 @@ static int ehci_pci_setup(struct usb_hcd
 		return retval;
 
 	switch (pdev->vendor) {
+	case PCI_VENDOR_ID_INTEL:
+		ehci->need_io_watchdog = 0;
+		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
 			hcd->has_tt = 1;
