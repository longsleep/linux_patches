From stern@rowland.harvard.edu Thu Jul 12 14:06:25 2007
From: Alan Stern <stern@rowland.harvard.edu>
Date: Thu, 12 Jul 2007 17:06:23 -0400 (EDT)
Subject: [PATCH] USB: add "descriptors" binary sysfs attribute
To: Greg KH <greg@kroah.com>
Cc: Dave Mielke <dave@mielke.cc>,  USB development list <linux-usb-devel@lists.sourceforge.net>
Message-ID: <Pine.LNX.4.44L0.0707121703020.2567-100000@iolanthe.rowland.org>


This patch (as934) adds a new readonly binary sysfs attribute file
called "descriptors" for each USB device.  The attribute contains the
device descriptor followed by the raw descriptor entry (config plug
subsidiary descriptors) for the current configuration.

Having this information available in fixed-format binary makes life a
lot easier for user programs by avoiding the need to open, read, and
parse multiple sysfs text files.

The information in this attribute file is much like that in usbfs's
device file, but there are some significant differences:

	The 2-byte fields in the device descriptor are left in
	little-endian byte order, as they appear on the bus and
	in the kernel.

	Only one raw descriptor set is presented, that of the
	current configuration.

	Opening this file will not cause a suspended device to be
	autoresumed.

The last item in particular should be a big selling point for libusb,
which currently forces all USB devices to be resumed as it scans the
device tree.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Dave Mielke <dave@mielke.cc>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/usb/core/sysfs.c |   53 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 53 insertions(+)

--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -441,6 +441,54 @@ static struct attribute_group dev_attr_g
 	.attrs = dev_attrs,
 };
 
+/* Binary descriptors */
+
+static ssize_t
+read_descriptors(struct kobject *kobj, struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct usb_device *udev = to_usb_device(
+			container_of(kobj, struct device, kobj));
+	size_t nleft = count;
+	size_t srclen, n;
+
+	usb_lock_device(udev);
+
+	/* The binary attribute begins with the device descriptor */
+	srclen = sizeof(struct usb_device_descriptor);
+	if (off < srclen) {
+		n = min_t(size_t, nleft, srclen - off);
+		memcpy(buf, off + (char *) &udev->descriptor, n);
+		nleft -= n;
+		buf += n;
+		off = 0;
+	} else {
+		off -= srclen;
+	}
+
+	/* Then follows the raw descriptor entry for the current
+	 * configuration (config plus subsidiary descriptors).
+	 */
+	if (udev->actconfig) {
+		int cfgno = udev->actconfig - udev->config;
+
+		srclen = __le16_to_cpu(udev->actconfig->desc.wTotalLength);
+		if (off < srclen) {
+			n = min_t(size_t, nleft, srclen - off);
+			memcpy(buf, off + udev->rawdescriptors[cfgno], n);
+			nleft -= n;
+		}
+	}
+	usb_unlock_device(udev);
+	return count - nleft;
+}
+
+static struct bin_attribute dev_bin_attr_descriptors = {
+	.attr = {.name = "descriptors", .mode = 0444},
+	.read = read_descriptors,
+	.size = 18 + 65535,	/* dev descr + max-size raw descriptor */
+};
+
 int usb_create_sysfs_dev_files(struct usb_device *udev)
 {
 	struct device *dev = &udev->dev;
@@ -450,6 +498,10 @@ int usb_create_sysfs_dev_files(struct us
 	if (retval)
 		return retval;
 
+	retval = device_create_bin_file(dev, &dev_bin_attr_descriptors);
+	if (retval)
+		goto error;
+
 	retval = add_persist_attributes(dev);
 	if (retval)
 		goto error;
@@ -492,6 +544,7 @@ void usb_remove_sysfs_dev_files(struct u
 	device_remove_file(dev, &dev_attr_serial);
 	remove_power_attributes(dev);
 	remove_persist_attributes(dev);
+	device_remove_bin_file(dev, &dev_bin_attr_descriptors);
 	sysfs_remove_group(&dev->kobj, &dev_attr_grp);
 }
 
