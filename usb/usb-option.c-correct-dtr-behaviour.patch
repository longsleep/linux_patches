From smurf@smurf.noris.de Thu Apr 10 03:07:30 2008
From: Chris Collins <chris@ursys.com.au>
Date: Thu, 10 Apr 2008 10:15:53 +0200
Subject: USB: option.c: correct DTR behaviour
To: linux-usb@vger.kernel.org, greg@kroah.com
Message-ID: <20080410081554.GB21538@kiste.smurf.noris.de>
Content-Disposition: inline


From: Chris Collins <chris@ursys.com.au>

Setting DTR et al. should work for all interfaces
if you actually pass the interface number. :-P
 
This should help with devices that have important pseudo-serial ports
that aren't on the first interface in the device.

Signed-off-by: Chris Collins <chris@ursys.com.au>
Signed-off-by: Matthias Urlichs <matthias@urlichs.de>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/serial/option.c |   15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -28,7 +28,7 @@
   device features.
 */
 
-#define DRIVER_VERSION "v0.7.1"
+#define DRIVER_VERSION "v0.7.2"
 #define DRIVER_AUTHOR "Matthias Urlichs <smurf@smurf.noris.de>"
 #define DRIVER_DESC "USB Driver for GSM modems"
 
@@ -824,16 +824,19 @@ static void option_setup_urbs(struct usb
 	}
 }
 
+
+/** send RTS/DTR state to the port.
+ *
+ * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
+ * CDC.
+*/
 static int option_send_setup(struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port->serial;
 	struct option_port_private *portdata;
-
+	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
 	dbg("%s", __FUNCTION__);
 
-	if (port->number != 0)
-		return 0;
-
 	portdata = usb_get_serial_port_data(port);
 
 	if (port->tty) {
@@ -845,7 +848,7 @@ static int option_send_setup(struct usb_
 
 		return usb_control_msg(serial->dev,
 				usb_rcvctrlpipe(serial->dev, 0),
-				0x22,0x21,val,0,NULL,0,USB_CTRL_SET_TIMEOUT);
+				0x22,0x21,val,ifNum,NULL,0,USB_CTRL_SET_TIMEOUT);
 	}
 
 	return 0;
