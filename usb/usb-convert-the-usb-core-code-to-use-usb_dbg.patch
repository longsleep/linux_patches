Date: Fri, 08 Aug 2008 14:38:31 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: USB: convert the USB core code to use usb_dbg()

It's a plug-in replacement for dev_dbg() and it lets you turn it on or
off based on the usbcore debug parameter.

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/config.c  |    6 -
 drivers/usb/core/devio.c   |    2 
 drivers/usb/core/driver.c  |   25 ++++---
 drivers/usb/core/hcd-pci.c |   24 +++---
 drivers/usb/core/hcd.c     |   34 +++++----
 drivers/usb/core/hub.c     |  160 ++++++++++++++++++++++-----------------------
 drivers/usb/core/message.c |   18 ++---
 drivers/usb/core/quirks.c  |    2 
 drivers/usb/core/urb.c     |    3 
 9 files changed, 142 insertions(+), 132 deletions(-)

--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -169,7 +169,7 @@ static int usb_parse_endpoint(struct dev
 	    USB_DT_INTERFACE, &n);
 	endpoint->extralen = i;
 	if (n > 0)
-		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
+		usb_dbg(ddev, "skipped %d descriptor%s after %s\n",
 		    n, plural(n), "endpoint");
 	return buffer - buffer0 + i;
 
@@ -248,7 +248,7 @@ static int usb_parse_interface(struct de
 	    USB_DT_INTERFACE, &n);
 	alt->extralen = i;
 	if (n > 0)
-		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
+		usb_dbg(ddev, "skipped %d descriptor%s after %s\n",
 		    n, plural(n), "interface");
 	buffer += i;
 	size -= i;
@@ -459,7 +459,7 @@ static int usb_parse_configuration(struc
 	    USB_DT_INTERFACE, &n);
 	config->extralen = i;
 	if (n > 0)
-		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
+		usb_dbg(ddev, "skipped %d descriptor%s after %s\n",
 		    n, plural(n), "configuration");
 	buffer += i;
 	size -= i;
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1462,7 +1462,7 @@ static int proc_ioctl(struct dev_state *
 	case USBDEVFS_DISCONNECT:
 		if (intf->dev.driver) {
 			driver = to_usb_driver(intf->dev.driver);
-			dev_dbg(&intf->dev, "disconnect by usbfs\n");
+			usb_dbg(&intf->dev, "disconnect by usbfs\n");
 			usb_driver_release_interface(driver, intf);
 		} else
 			retval = -ENODATA;
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -157,7 +157,7 @@ static int usb_probe_device(struct devic
 	struct usb_device *udev;
 	int error = -ENODEV;
 
-	dev_dbg(dev, "%s\n", __func__);
+	usb_dbg(dev, "%s\n", __func__);
 
 	if (!is_usb_device(dev))	/* Sanity check */
 		return error;
@@ -194,7 +194,7 @@ static int usb_probe_interface(struct de
 	const struct usb_device_id *id;
 	int error = -ENODEV;
 
-	dev_dbg(dev, "%s\n", __func__);
+	usb_dbg(dev, "%s\n", __func__);
 
 	if (is_usb_device(dev))		/* Sanity check */
 		return error;
@@ -212,7 +212,7 @@ static int usb_probe_interface(struct de
 	if (!id)
 		id = usb_match_dynamic_id(intf, driver);
 	if (id) {
-		dev_dbg(dev, "%s - got id\n", __func__);
+		usb_dbg(dev, "%s - got id\n", __func__);
 
 		error = usb_autoresume_device(udev);
 		if (error)
@@ -588,8 +588,9 @@ static int usb_uevent(struct device *dev
 {
 	struct usb_device *usb_dev;
 
-	/* driver is often null here; dev_dbg() would oops */
-	pr_debug("usb %s: uevent\n", dev_name(dev));
+	/* driver is often null here; usb_dbg() would oops */
+	if (usb_debug)
+		printk(KERN_DEBUG "usb %s: uevent\n", dev_name(dev));
 
 	if (is_usb_device(dev))
 		usb_dev = to_usb_device(dev);
@@ -599,11 +600,15 @@ static int usb_uevent(struct device *dev
 	}
 
 	if (usb_dev->devnum < 0) {
-		pr_debug("usb %s: already deleted?\n", dev_name(dev));
+		if (usb_debug)
+			printk(KERN_DEBUG "usb %s: already deleted?\n",
+			       dev_name(dev));
 		return -ENODEV;
 	}
 	if (!usb_dev->bus) {
-		pr_debug("usb %s: bus removed?\n", dev_name(dev));
+		if (usb_debug)
+			printk(KERN_DEBUG "usb %s: bus removed?\n",
+			       dev_name(dev));
 		return -ENODEV;
 	}
 
@@ -785,7 +790,7 @@ void usb_forced_unbind_intf(struct usb_i
 {
 	struct usb_driver *driver = to_usb_driver(intf->dev.driver);
 
-	dev_dbg(&intf->dev, "forced unbind\n");
+	usb_dbg(&intf->dev, "forced unbind\n");
 	usb_driver_release_interface(driver, intf);
 
 	/* Mark the interface for later rebinding */
@@ -809,7 +814,7 @@ void usb_rebind_intf(struct usb_interfac
 		struct usb_driver *driver =
 				to_usb_driver(intf->dev.driver);
 
-		dev_dbg(&intf->dev, "forced unbind\n");
+		usb_dbg(&intf->dev, "forced unbind\n");
 		usb_driver_release_interface(driver, intf);
 	}
 
@@ -1044,7 +1049,7 @@ static int autosuspend_check(struct usb_
 				return -EBUSY;
 			if (intf->needs_remote_wakeup &&
 					!udev->do_remote_wakeup) {
-				dev_dbg(&udev->dev, "remote wakeup needed "
+				usb_dbg(&udev->dev, "remote wakeup needed "
 						"for autosuspend\n");
 				return -EOPNOTSUPP;
 			}
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -466,7 +466,7 @@ static int rh_call_control (struct usb_h
 		break;
 	case DeviceOutRequest | USB_REQ_SET_ADDRESS:
 		// wValue == urb->dev->devaddr
-		dev_dbg (hcd->self.controller, "root hub device address %d\n",
+		usb_dbg (hcd->self.controller, "root hub device address %d\n",
 			wValue);
 		break;
 
@@ -482,7 +482,7 @@ static int rh_call_control (struct usb_h
 			/* FALLTHROUGH */
 	case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:
 	case EndpointOutRequest | USB_REQ_SET_FEATURE:
-		dev_dbg (hcd->self.controller, "no endpoint features yet\n");
+		usb_dbg (hcd->self.controller, "no endpoint features yet\n");
 		break;
 
 	/* CLASS REQUESTS (and errors) */
@@ -510,7 +510,7 @@ error:
 	if (status) {
 		len = 0;
 		if (status != -EPIPE) {
-			dev_dbg (hcd->self.controller,
+			usb_dbg (hcd->self.controller,
 				"CTRL: TypeReq=0x%x val=0x%x "
 				"idx=0x%x len=%d ==> %d\n",
 				typeReq, wValue, wIndex,
@@ -626,7 +626,7 @@ static int rh_queue_status (struct usb_h
 
 	spin_lock_irqsave (&hcd_root_hub_lock, flags);
 	if (hcd->status_urb || urb->transfer_buffer_length < len) {
-		dev_dbg (hcd->self.controller, "not queuing rh status urb\n");
+		usb_dbg (hcd->self.controller, "not queuing rh status urb\n");
 		retval = -EINVAL;
 		goto done;
 	}
@@ -898,7 +898,7 @@ static int register_root_hub(struct usb_
 	retval = usb_get_device_descriptor(usb_dev, USB_DT_DEVICE_SIZE);
 	if (retval != sizeof usb_dev->descriptor) {
 		mutex_unlock(&usb_bus_list_lock);
-		dev_dbg (parent_dev, "can't read %s device descriptor %d\n",
+		usb_dbg (parent_dev, "can't read %s device descriptor %d\n",
 				dev_name(&usb_dev->dev), retval);
 		return (retval < 0) ? retval : -EMSGSIZE;
 	}
@@ -975,7 +975,9 @@ long usb_calc_bus_time (int speed, int i
 			tmp = HS_NSECS (bytecount);
 		return tmp;
 	default:
-		pr_debug ("%s: bogus device speed!\n", usbcore_name);
+		if (usb_debug)
+			printk(KERN_DEBUG "%s: bogus device speed!\n",
+			       usbcore_name);
 		return -1;
 	}
 }
@@ -1389,7 +1391,7 @@ int usb_hcd_unlink_urb (struct urb *urb,
 	if (retval == 0)
 		retval = -EINPROGRESS;
 	else if (retval != -EIDRM && retval != -EBUSY)
-		dev_dbg(&urb->dev->dev, "hcd_unlink_urb %p fail %d\n",
+		usb_dbg(&urb->dev->dev, "hcd_unlink_urb %p fail %d\n",
 				urb, retval);
 	return retval;
 }
@@ -1468,7 +1470,7 @@ rescan:
 
 		/* kick hcd */
 		unlink1(hcd, urb, -ESHUTDOWN);
-		dev_dbg (hcd->self.controller,
+		usb_dbg (hcd->self.controller,
 			"shutdown urb %p ep%d%s%s\n",
 			urb, usb_endpoint_num(&ep->desc),
 			is_in ? "in" : "out",
@@ -1555,7 +1557,7 @@ int hcd_bus_suspend(struct usb_device *r
 	int		status;
 	int		old_state = hcd->state;
 
-	dev_dbg(&rhdev->dev, "bus %s%s\n",
+	usb_dbg(&rhdev->dev, "bus %s%s\n",
 			rhdev->auto_pm ? "auto-" : "", "suspend");
 	if (!hcd->driver->bus_suspend) {
 		status = -ENOENT;
@@ -1568,7 +1570,7 @@ int hcd_bus_suspend(struct usb_device *r
 		hcd->state = HC_STATE_SUSPENDED;
 	} else {
 		hcd->state = old_state;
-		dev_dbg(&rhdev->dev, "bus %s fail, err %d\n",
+		usb_dbg(&rhdev->dev, "bus %s fail, err %d\n",
 				"suspend", status);
 	}
 	return status;
@@ -1580,7 +1582,7 @@ int hcd_bus_resume(struct usb_device *rh
 	int		status;
 	int		old_state = hcd->state;
 
-	dev_dbg(&rhdev->dev, "usb %s%s\n",
+	usb_dbg(&rhdev->dev, "usb %s%s\n",
 			rhdev->auto_pm ? "auto-" : "", "resume");
 	if (!hcd->driver->bus_resume)
 		return -ENOENT;
@@ -1598,7 +1600,7 @@ int hcd_bus_resume(struct usb_device *rh
 		hcd->state = HC_STATE_RUNNING;
 	} else {
 		hcd->state = old_state;
-		dev_dbg(&rhdev->dev, "bus %s fail, err %d\n",
+		usb_dbg(&rhdev->dev, "bus %s fail, err %d\n",
 				"resume", status);
 		if (status != -ESHUTDOWN)
 			usb_hc_died(hcd);
@@ -1769,7 +1771,7 @@ struct usb_hcd *usb_create_hcd (const st
 
 	hcd = kzalloc(sizeof(*hcd) + driver->hcd_priv_size, GFP_KERNEL);
 	if (!hcd) {
-		dev_dbg (dev, "hcd alloc failed\n");
+		usb_dbg (dev, "hcd alloc failed\n");
 		return NULL;
 	}
 	dev_set_drvdata(dev, hcd);
@@ -1842,7 +1844,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	 * starts talking to them.  (Note, bus id is assigned early too.)
 	 */
 	if ((retval = hcd_buffer_create(hcd)) != 0) {
-		dev_dbg(hcd->self.controller, "pool alloc failed\n");
+		usb_dbg(hcd->self.controller, "pool alloc failed\n");
 		return retval;
 	}
 
@@ -1875,7 +1877,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	/* NOTE: root hub and controller capabilities may not be the same */
 	if (device_can_wakeup(hcd->self.controller)
 			&& device_can_wakeup(&hcd->self.root_hub->dev))
-		dev_dbg(hcd->self.controller, "supports USB remote wakeup\n");
+		usb_dbg(hcd->self.controller, "supports USB remote wakeup\n");
 
 	/* enable irqs just before we start the controller */
 	if (hcd->driver->irq) {
@@ -1964,7 +1966,7 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	if (HC_IS_RUNNING (hcd->state))
 		hcd->state = HC_STATE_QUIESCING;
 
-	dev_dbg(hcd->self.controller, "roothub graceful disconnect\n");
+	usb_dbg(hcd->self.controller, "roothub graceful disconnect\n");
 	spin_lock_irq (&hcd_root_hub_lock);
 	hcd->rh_registered = 0;
 	spin_unlock_irq (&hcd_root_hub_lock);
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -94,13 +94,13 @@ int usb_hcd_pci_probe(struct pci_dev *de
 		hcd->rsrc_len = pci_resource_len(dev, 0);
 		if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
 				driver->description)) {
-			dev_dbg(&dev->dev, "controller already in use\n");
+			usb_dbg(&dev->dev, "controller already in use\n");
 			retval = -EBUSY;
 			goto err2;
 		}
 		hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
 		if (hcd->regs == NULL) {
-			dev_dbg(&dev->dev, "error mapping memory\n");
+			usb_dbg(&dev->dev, "error mapping memory\n");
 			retval = -EFAULT;
 			goto err3;
 		}
@@ -121,7 +121,7 @@ int usb_hcd_pci_probe(struct pci_dev *de
 				break;
 		}
 		if (region == PCI_ROM_RESOURCE) {
-			dev_dbg(&dev->dev, "no i/o regions available\n");
+			usb_dbg(&dev->dev, "no i/o regions available\n");
 			retval = -EBUSY;
 			goto err1;
 		}
@@ -256,12 +256,12 @@ int usb_hcd_pci_suspend(struct pci_dev *
 
 		if (message.event == PM_EVENT_FREEZE ||
 				message.event == PM_EVENT_PRETHAW) {
-			dev_dbg(hcd->self.controller, "--> no state change\n");
+			usb_dbg(hcd->self.controller, "--> no state change\n");
 			goto done;
 		}
 
 		if (!has_pci_pm) {
-			dev_dbg(hcd->self.controller, "--> PCI D0/legacy\n");
+			usb_dbg(hcd->self.controller, "--> PCI D0/legacy\n");
 			goto done;
 		}
 
@@ -277,7 +277,7 @@ int usb_hcd_pci_suspend(struct pci_dev *
 
 			wake = wake && device_may_wakeup(hcd->self.controller);
 
-			dev_dbg(hcd->self.controller, "--> PCI D3%s\n",
+			usb_dbg(hcd->self.controller, "--> PCI D3%s\n",
 					wake ? "/wakeup" : "");
 
 			/* Ignore these return values.  We rely on pci code to
@@ -287,13 +287,13 @@ int usb_hcd_pci_suspend(struct pci_dev *
 			(void) pci_enable_wake(dev, PCI_D3hot, wake);
 			(void) pci_enable_wake(dev, PCI_D3cold, wake);
 		} else {
-			dev_dbg(&dev->dev, "PCI D3 suspend fail, %d\n",
+			usb_dbg(&dev->dev, "PCI D3 suspend fail, %d\n",
 					retval);
 			(void) usb_hcd_pci_resume(dev);
 		}
 
 	} else if (hcd->state != HC_STATE_HALT) {
-		dev_dbg(hcd->self.controller, "hcd state %d; not suspended\n",
+		usb_dbg(hcd->self.controller, "hcd state %d; not suspended\n",
 			hcd->state);
 		WARN_ON(1);
 		retval = -EINVAL;
@@ -331,7 +331,7 @@ int usb_hcd_pci_resume(struct pci_dev *d
 
 	hcd = pci_get_drvdata(dev);
 	if (hcd->state != HC_STATE_SUSPENDED) {
-		dev_dbg(hcd->self.controller,
+		usb_dbg(hcd->self.controller,
 				"can't resume, not suspended!\n");
 		return 0;
 	}
@@ -364,7 +364,7 @@ int usb_hcd_pci_resume(struct pci_dev *d
 			/* Clean case:  power to USB and to HC registers was
 			 * maintained; remote wakeup is easy.
 			 */
-			dev_dbg(hcd->self.controller, "resume from PCI D%d\n",
+			usb_dbg(hcd->self.controller, "resume from PCI D%d\n",
 					pmcr);
 		} else {
 			/* Clean:  HC lost Vcc power, D0 uninitialized
@@ -376,7 +376,7 @@ int usb_hcd_pci_resume(struct pci_dev *d
 			 *   + after BIOS init
 			 *   + after Linux init (HCD statically linked)
 			 */
-			dev_dbg(hcd->self.controller,
+			usb_dbg(hcd->self.controller,
 				"PCI D0, from previous PCI D%d\n",
 				dev->current_state);
 		}
@@ -386,7 +386,7 @@ int usb_hcd_pci_resume(struct pci_dev *d
 		(void) pci_enable_wake(dev, PCI_D3cold, 0);
 	} else {
 		/* Same basic cases: clean (powered/not), dirty */
-		dev_dbg(hcd->self.controller, "PCI legacy resume\n");
+		usb_dbg(hcd->self.controller, "PCI legacy resume\n");
 	}
 
 	/* NOTE:  the PCI API itself is asymmetric here.  We don't need to
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -211,7 +211,7 @@ static void set_port_led(
 	int status = set_port_feature(hub->hdev, (selector << 8) | port1,
 			USB_PORT_FEAT_INDICATOR);
 	if (status < 0)
-		dev_dbg (hub->intfdev,
+		usb_dbg (hub->intfdev,
 			"port %d indicator %s status %d\n",
 			port1,
 			({ char *s; switch (selector) {
@@ -391,7 +391,7 @@ static void hub_irq(struct urb *urb)
 
 	default:		/* presumably an error */
 		/* Cause a hub reset after 10 consecutive errors */
-		dev_dbg (hub->intfdev, "transfer --> %d\n", status);
+		usb_dbg (hub->intfdev, "transfer --> %d\n", status);
 		if ((++hub->nerrors < 10) || hub->error)
 			goto resubmit;
 		hub->error = status;
@@ -529,9 +529,9 @@ static void hub_power_on(struct usb_hub 
 	 * unless we send these messages to the hub.
 	 */
 	if ((wHubCharacteristics & HUB_CHAR_LPSM) < 2)
-		dev_dbg(hub->intfdev, "enabling power on all ports\n");
+		usb_dbg(hub->intfdev, "enabling power on all ports\n");
 	else
-		dev_dbg(hub->intfdev, "trying to enable port power on "
+		usb_dbg(hub->intfdev, "trying to enable port power on "
 				"non-switchable hub\n");
 	for (port1 = 1; port1 <= hub->descriptor->bNbrPorts; port1++)
 		set_port_feature(hub->hdev, port1, USB_PORT_FEAT_POWER);
@@ -582,7 +582,7 @@ static int hub_port_disable(struct usb_h
  */
 static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
 {
-	dev_dbg(hub->intfdev, "logical disconnect on port %d\n", port1);
+	usb_dbg(hub->intfdev, "logical disconnect on port %d\n", port1);
 	hub_port_disable(hub, port1, 1);
 
 	/* FIXME let caller ask to power down the port:
@@ -625,7 +625,7 @@ static void hub_activate(struct usb_hub 
 		portstatus = portchange = 0;
 		status = hub_port_status(hub, port1, &portstatus, &portchange);
 		if (udev || (portstatus & USB_PORT_STAT_CONNECTION))
-			dev_dbg(hub->intfdev,
+			usb_dbg(hub->intfdev,
 					"port %d: status %04x change %04x\n",
 					port1, portstatus, portchange);
 
@@ -817,33 +817,33 @@ static int hub_configure(struct usb_hub 
 				    [((i + 1) / 8)] & (1 << ((i + 1) % 8))
 				? 'F' : 'R';
 		portstr[hdev->maxchild] = 0;
-		dev_dbg(hub_dev, "compound device; port removable status: %s\n", portstr);
+		usb_dbg(hub_dev, "compound device; port removable status: %s\n", portstr);
 	} else
-		dev_dbg(hub_dev, "standalone hub\n");
+		usb_dbg(hub_dev, "standalone hub\n");
 
 	switch (wHubCharacteristics & HUB_CHAR_LPSM) {
 		case 0x00:
-			dev_dbg(hub_dev, "ganged power switching\n");
+			usb_dbg(hub_dev, "ganged power switching\n");
 			break;
 		case 0x01:
-			dev_dbg(hub_dev, "individual port power switching\n");
+			usb_dbg(hub_dev, "individual port power switching\n");
 			break;
 		case 0x02:
 		case 0x03:
-			dev_dbg(hub_dev, "no power switching (usb 1.0)\n");
+			usb_dbg(hub_dev, "no power switching (usb 1.0)\n");
 			break;
 	}
 
 	switch (wHubCharacteristics & HUB_CHAR_OCPM) {
 		case 0x00:
-			dev_dbg(hub_dev, "global over-current protection\n");
+			usb_dbg(hub_dev, "global over-current protection\n");
 			break;
 		case 0x08:
-			dev_dbg(hub_dev, "individual port over-current protection\n");
+			usb_dbg(hub_dev, "individual port over-current protection\n");
 			break;
 		case 0x10:
 		case 0x18:
-			dev_dbg(hub_dev, "no over-current protection\n");
+			usb_dbg(hub_dev, "no over-current protection\n");
                         break;
 	}
 
@@ -854,13 +854,13 @@ static int hub_configure(struct usb_hub 
 		case 0:
 			break;
 		case 1:
-			dev_dbg(hub_dev, "Single TT\n");
+			usb_dbg(hub_dev, "Single TT\n");
 			hub->tt.hub = hdev;
 			break;
 		case 2:
 			ret = usb_set_interface(hdev, 0, 1);
 			if (ret == 0) {
-				dev_dbg(hub_dev, "TT per port\n");
+				usb_dbg(hub_dev, "TT per port\n");
 				hub->tt.multi = 1;
 			} else
 				dev_err(hub_dev, "Using single TT (err %d)\n",
@@ -868,7 +868,7 @@ static int hub_configure(struct usb_hub 
 			hub->tt.hub = hdev;
 			break;
 		default:
-			dev_dbg(hub_dev, "Unrecognized hub protocol %d\n",
+			usb_dbg(hub_dev, "Unrecognized hub protocol %d\n",
 				hdev->descriptor.bDeviceProtocol);
 			break;
 	}
@@ -878,26 +878,26 @@ static int hub_configure(struct usb_hub 
 		case HUB_TTTT_8_BITS:
 			if (hdev->descriptor.bDeviceProtocol != 0) {
 				hub->tt.think_time = 666;
-				dev_dbg(hub_dev, "TT requires at most %d "
+				usb_dbg(hub_dev, "TT requires at most %d "
 						"FS bit times (%d ns)\n",
 					8, hub->tt.think_time);
 			}
 			break;
 		case HUB_TTTT_16_BITS:
 			hub->tt.think_time = 666 * 2;
-			dev_dbg(hub_dev, "TT requires at most %d "
+			usb_dbg(hub_dev, "TT requires at most %d "
 					"FS bit times (%d ns)\n",
 				16, hub->tt.think_time);
 			break;
 		case HUB_TTTT_24_BITS:
 			hub->tt.think_time = 666 * 3;
-			dev_dbg(hub_dev, "TT requires at most %d "
+			usb_dbg(hub_dev, "TT requires at most %d "
 					"FS bit times (%d ns)\n",
 				24, hub->tt.think_time);
 			break;
 		case HUB_TTTT_32_BITS:
 			hub->tt.think_time = 666 * 4;
-			dev_dbg(hub_dev, "TT requires at most %d "
+			usb_dbg(hub_dev, "TT requires at most %d "
 					"FS bit times (%d ns)\n",
 				32, hub->tt.think_time);
 			break;
@@ -906,10 +906,10 @@ static int hub_configure(struct usb_hub 
 	/* probe() zeroes hub->indicator[] */
 	if (wHubCharacteristics & HUB_CHAR_PORTIND) {
 		hub->has_indicators = 1;
-		dev_dbg(hub_dev, "Port indicators are supported\n");
+		usb_dbg(hub_dev, "Port indicators are supported\n");
 	}
 
-	dev_dbg(hub_dev, "power on to power good time: %dms\n",
+	usb_dbg(hub_dev, "power on to power good time: %dms\n",
 		hub->descriptor->bPwrOn2PwrGood * 2);
 
 	/* power budgeting mostly matters with bus-powered hubs,
@@ -929,7 +929,7 @@ static int hub_configure(struct usb_hub 
 			hub->limited_power = 1;
 		}
 	} else if ((hubstatus & (1 << USB_DEVICE_SELF_POWERED)) == 0) {
-		dev_dbg(hub_dev, "hub controller current requirement: %dmA\n",
+		usb_dbg(hub_dev, "hub controller current requirement: %dmA\n",
 			hub->descriptor->bHubContrCurrent);
 		hub->limited_power = 1;
 		if (hdev->maxchild > 0) {
@@ -948,7 +948,7 @@ static int hub_configure(struct usb_hub 
 		hub->mA_per_port = 500;
 	}
 	if (hub->mA_per_port < 500)
-		dev_dbg(hub_dev, "%umA bus power budget for each child\n",
+		usb_dbg(hub_dev, "%umA bus power budget for each child\n",
 				hub->mA_per_port);
 
 	ret = hub_hub_status(hub, &hubstatus, &hubchange);
@@ -959,12 +959,12 @@ static int hub_configure(struct usb_hub 
 
 	/* local power status reports aren't always correct */
 	if (hdev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_SELFPOWER)
-		dev_dbg(hub_dev, "local power source is %s\n",
+		usb_dbg(hub_dev, "local power source is %s\n",
 			(hubstatus & HUB_STATUS_LOCAL_POWER)
 			? "lost (inactive)" : "good");
 
 	if ((wHubCharacteristics & HUB_CHAR_OCPM) == 0)
-		dev_dbg(hub_dev, "%sover-current condition exists\n",
+		usb_dbg(hub_dev, "%sover-current condition exists\n",
 			(hubstatus & HUB_STATUS_OVERCURRENT) ? "" : "no ");
 
 	/* set up the interrupt endpoint
@@ -1090,7 +1090,7 @@ descriptor_error:
 
 	hub = kzalloc(sizeof(*hub), GFP_KERNEL);
 	if (!hub) {
-		dev_dbg (&intf->dev, "couldn't kmalloc hub struct\n");
+		usb_dbg (&intf->dev, "couldn't kmalloc hub struct\n");
 		return -ENOMEM;
 	}
 
@@ -1324,7 +1324,8 @@ void usb_disconnect(struct usb_device **
 	int			i;
 
 	if (!udev) {
-		pr_debug ("%s nodev\n", __func__);
+		if (usb_debug)
+			printk(KERN_DEBUG "%s nodev\n", __func__);
 		return;
 	}
 
@@ -1347,7 +1348,7 @@ void usb_disconnect(struct usb_device **
 	 * cleaning up all state associated with the current configuration
 	 * so that the hardware is now fully quiesced.
 	 */
-	dev_dbg (&udev->dev, "unregistering device\n");
+	usb_dbg (&udev->dev, "unregistering device\n");
 	usb_disable_device(udev, 0);
 
 	usb_unlock_device(udev);
@@ -1384,7 +1385,7 @@ static void show_string(struct usb_devic
 {
 	if (!string)
 		return;
-	dev_printk(KERN_INFO, &udev->dev, "%s: %s\n", id, string);
+	dev_info(&udev->dev, "%s: %s\n", id, string);
 }
 
 static void announce_device(struct usb_device *udev)
@@ -1474,7 +1475,7 @@ static int usb_configure_device_otg(stru
 		if (udev->bus->b_hnp_enable || udev->bus->is_b_host) {
 			err = usb_port_suspend(udev);
 			if (err < 0)
-				dev_dbg(&udev->dev, "HNP fail, %d\n", err);
+				usb_dbg(&udev->dev, "HNP fail, %d\n", err);
 		}
 		err = -ENOTSUPP;
 		goto fail;
@@ -1736,7 +1737,7 @@ static int hub_port_wait_reset(struct us
 		if (delay_time >= 2 * HUB_SHORT_RESET_TIME)
 			delay = HUB_LONG_RESET_TIME;
 
-		dev_dbg (hub->intfdev,
+		usb_dbg (hub->intfdev,
 			"port %d not reset yet, waiting %dms\n",
 			port1, delay);
 	}
@@ -1765,7 +1766,7 @@ static int hub_port_reset(struct usb_hub
 		else {
 			status = hub_port_wait_reset(hub, port1, udev, delay);
 			if (status && status != -ENOTCONN)
-				dev_dbg(hub->intfdev,
+				usb_dbg(hub->intfdev,
 						"port_wait_reset: err = %d\n",
 						status);
 		}
@@ -1788,7 +1789,7 @@ static int hub_port_reset(struct usb_hub
 			goto done;
 		}
 
-		dev_dbg (hub->intfdev,
+		usb_dbg (hub->intfdev,
 			"port %d not enabled, trying reset again...\n",
 			port1);
 		delay = HUB_LONG_RESET_TIME;
@@ -1833,7 +1834,7 @@ static int check_port_resume_type(struct
 	}
 
 	if (status) {
-		dev_dbg(hub->intfdev,
+		usb_dbg(hub->intfdev,
 				"port %d status %04x.%04x after resume, %d\n",
 				port1, portchange, portstatus, status);
 	} else if (udev->reset_resume) {
@@ -1904,7 +1905,7 @@ int usb_port_suspend(struct usb_device *
 	int		port1 = udev->portnum;
 	int		status;
 
-	// dev_dbg(hub->intfdev, "suspend port %d\n", port1);
+	// usb_dbg(hub->intfdev, "suspend port %d\n", port1);
 
 	/* enable remote wakeup when appropriate; this lets the device
 	 * wake up the upstream hub (including maybe the root hub).
@@ -1919,14 +1920,14 @@ int usb_port_suspend(struct usb_device *
 				NULL, 0,
 				USB_CTRL_SET_TIMEOUT);
 		if (status)
-			dev_dbg(&udev->dev, "won't remote wakeup, status %d\n",
+			usb_dbg(&udev->dev, "won't remote wakeup, status %d\n",
 					status);
 	}
 
 	/* see 7.1.7.6 */
 	status = set_port_feature(hub->hdev, port1, USB_PORT_FEAT_SUSPEND);
 	if (status) {
-		dev_dbg(hub->intfdev, "can't suspend port %d, status %d\n",
+		usb_dbg(hub->intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
 		/* paranoia:  "should not happen" */
 		(void) usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
@@ -1936,7 +1937,7 @@ int usb_port_suspend(struct usb_device *
 				USB_CTRL_SET_TIMEOUT);
 	} else {
 		/* device has up to 10 msec to fully suspend */
-		dev_dbg(&udev->dev, "usb %ssuspend\n",
+		usb_dbg(&udev->dev, "usb %ssuspend\n",
 				udev->auto_pm ? "auto-" : "");
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 		msleep(10);
@@ -1961,7 +1962,7 @@ static int finish_port_resume(struct usb
 	u16	devstatus;
 
 	/* caller owns the udev device lock */
-	dev_dbg(&udev->dev, "finish %sresume\n",
+	usb_dbg(&udev->dev, "finish %sresume\n",
 			udev->reset_resume ? "reset-" : "");
 
 	/* usb ch9 identifies four variants of SUSPENDED, based on what
@@ -1994,14 +1995,14 @@ static int finish_port_resume(struct usb
 
 		/* If a normal resume failed, try doing a reset-resume */
 		if (status && !udev->reset_resume && udev->persist_enabled) {
-			dev_dbg(&udev->dev, "retry with reset-resume\n");
+			usb_dbg(&udev->dev, "retry with reset-resume\n");
 			udev->reset_resume = 1;
 			goto retry_reset_resume;
 		}
 	}
 
 	if (status) {
-		dev_dbg(&udev->dev, "gone after usb resume? status %d\n",
+		usb_dbg(&udev->dev, "gone after usb resume? status %d\n",
 				status);
 	} else if (udev->actconfig) {
 		le16_to_cpus(&devstatus);
@@ -2014,7 +2015,7 @@ static int finish_port_resume(struct usb
 					NULL, 0,
 					USB_CTRL_SET_TIMEOUT);
 			if (status)
-				dev_dbg(&udev->dev, "disable remote "
+				usb_dbg(&udev->dev, "disable remote "
 					"wakeup, status %d\n", status);
 		}
 		status = 0;
@@ -2068,7 +2069,7 @@ int usb_port_resume(struct usb_device *u
 	if (status == 0 && !(portstatus & USB_PORT_STAT_SUSPEND))
 		goto SuspendCleared;
 
-	// dev_dbg(hub->intfdev, "resume port %d\n", port1);
+	// usb_dbg(hub->intfdev, "resume port %d\n", port1);
 
 	set_bit(port1, hub->busy_bits);
 
@@ -2076,11 +2077,11 @@ int usb_port_resume(struct usb_device *u
 	status = clear_port_feature(hub->hdev,
 			port1, USB_PORT_FEAT_SUSPEND);
 	if (status) {
-		dev_dbg(hub->intfdev, "can't resume port %d, status %d\n",
+		usb_dbg(hub->intfdev, "can't resume port %d, status %d\n",
 				port1, status);
 	} else {
 		/* drive resume for at least 20 msec */
-		dev_dbg(&udev->dev, "usb %sresume\n",
+		usb_dbg(&udev->dev, "usb %sresume\n",
 				udev->auto_pm ? "auto-" : "");
 		msleep(25);
 
@@ -2110,7 +2111,7 @@ int usb_port_resume(struct usb_device *u
 	if (status == 0)
 		status = finish_port_resume(udev);
 	if (status < 0) {
-		dev_dbg(&udev->dev, "can't resume, status %d\n", status);
+		usb_dbg(&udev->dev, "can't resume, status %d\n", status);
 		hub_port_logical_disconnect(hub, port1);
 	}
 	return status;
@@ -2122,7 +2123,7 @@ static int remote_wakeup(struct usb_devi
 	int	status = 0;
 
 	if (udev->state == USB_STATE_SUSPENDED) {
-		dev_dbg(&udev->dev, "usb %sresume\n", "wakeup-");
+		usb_dbg(&udev->dev, "usb %sresume\n", "wakeup-");
 		usb_mark_last_busy(udev);
 		status = usb_external_resume_device(udev);
 	}
@@ -2152,10 +2153,10 @@ int usb_port_resume(struct usb_device *u
 			hub, port1, status, portchange, portstatus);
 
 	if (status) {
-		dev_dbg(&udev->dev, "can't resume, status %d\n", status);
+		usb_dbg(&udev->dev, "can't resume, status %d\n", status);
 		hub_port_logical_disconnect(hub, port1);
 	} else if (udev->reset_resume) {
-		dev_dbg(&udev->dev, "reset-resume\n");
+		usb_dbg(&udev->dev, "reset-resume\n");
 		status = usb_reset_and_verify_device(udev);
 	}
 	return status;
@@ -2181,13 +2182,13 @@ static int hub_suspend(struct usb_interf
 		udev = hdev->children [port1-1];
 		if (udev && udev->can_submit) {
 			if (!hdev->auto_pm)
-				dev_dbg(&intf->dev, "port %d nyet suspended\n",
+				usb_dbg(&intf->dev, "port %d nyet suspended\n",
 						port1);
 			return -EBUSY;
 		}
 	}
 
-	dev_dbg(&intf->dev, "%s\n", __func__);
+	usb_dbg(&intf->dev, "%s\n", __func__);
 
 	/* stop khubd and related activity */
 	hub_quiesce(hub, HUB_SUSPEND);
@@ -2198,7 +2199,7 @@ static int hub_resume(struct usb_interfa
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	dev_dbg(&intf->dev, "%s\n", __func__);
+	usb_dbg(&intf->dev, "%s\n", __func__);
 	hub_activate(hub, HUB_RESUME);
 	return 0;
 }
@@ -2207,7 +2208,7 @@ static int hub_reset_resume(struct usb_i
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	dev_dbg(&intf->dev, "%s\n", __func__);
+	usb_dbg(&intf->dev, "%s\n", __func__);
 	hub_activate(hub, HUB_RESET_RESUME);
 	return 0;
 }
@@ -2290,7 +2291,7 @@ static int hub_port_debounce(struct usb_
 		msleep(HUB_DEBOUNCE_STEP);
 	}
 
-	dev_dbg (hub->intfdev,
+	usb_dbg (hub->intfdev,
 		"debounce: port %d: total %dms stable %dms status 0x%x\n",
 		port1, total_time, stable_time, portstatus);
 
@@ -2378,7 +2379,7 @@ hub_port_init (struct usb_hub *hub, stru
 	retval = -ENODEV;
 
 	if (oldspeed != USB_SPEED_UNKNOWN && oldspeed != udev->speed) {
-		dev_dbg(&udev->dev, "device reset changed speed!\n");
+		usb_dbg(&udev->dev, "device reset changed speed!\n");
 		goto fail;
 	}
 	oldspeed = udev->speed;
@@ -2494,7 +2495,7 @@ hub_port_init (struct usb_hub *hub, stru
 			if (retval < 0)		/* error or disconnect */
 				goto fail;
 			if (oldspeed != udev->speed) {
-				dev_dbg(&udev->dev,
+				usb_dbg(&udev->dev,
 					"device reset changed speed!\n");
 				retval = -ENODEV;
 				goto fail;
@@ -2561,7 +2562,7 @@ hub_port_init (struct usb_hub *hub, stru
 			retval = -EMSGSIZE;
 			goto fail;
 		}
-		dev_dbg(&udev->dev, "ep0 maxpacket = %d\n", i);
+		usb_dbg(&udev->dev, "ep0 maxpacket = %d\n", i);
 		udev->ep0.desc.wMaxPacketSize = cpu_to_le16(i);
 		usb_ep0_reinit(udev);
 	}
@@ -2669,7 +2670,7 @@ static void hub_port_connect_change(stru
 	struct usb_device *udev;
 	int status, i;
 
-	dev_dbg (hub_dev,
+	usb_dbg (hub_dev,
 		"port %d, status %04x, change %04x, %s\n",
 		port1, portstatus, portchange, portspeed (portstatus));
 
@@ -2800,7 +2801,7 @@ static void hub_port_connect_change(stru
 			status = usb_get_status(udev, USB_RECIP_DEVICE, 0,
 					&devstat);
 			if (status < 2) {
-				dev_dbg(&udev->dev, "get status %d ?\n", status);
+				usb_dbg(&udev->dev, "get status %d ?\n", status);
 				goto loop_disable;
 			}
 			le16_to_cpus(&devstat);
@@ -2856,7 +2857,7 @@ static void hub_port_connect_change(stru
 
 		status = hub_power_remaining(hub);
 		if (status)
-			dev_dbg(hub_dev, "%dmA power budget left\n", status);
+			usb_dbg(hub_dev, "%dmA power budget left\n", status);
 
 		return;
 
@@ -2920,7 +2921,7 @@ static void hub_events(void)
 		hdev = hub->hdev;
 		hub_dev = hub->intfdev;
 		intf = to_usb_interface(hub_dev);
-		dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",
+		usb_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",
 				hdev->state, hub->descriptor
 					? hub->descriptor->bNbrPorts
 					: 0,
@@ -2944,7 +2945,7 @@ static void hub_events(void)
 		/* Autoresume */
 		ret = usb_autopm_get_interface(intf);
 		if (ret) {
-			dev_dbg(hub_dev, "Can't autoresume: %d\n", ret);
+			usb_dbg(hub_dev, "Can't autoresume: %d\n", ret);
 			goto loop;
 		}
 
@@ -2953,12 +2954,12 @@ static void hub_events(void)
 			goto loop_autopm;
 
 		if (hub->error) {
-			dev_dbg (hub_dev, "resetting for error %d\n",
+			usb_dbg (hub_dev, "resetting for error %d\n",
 				hub->error);
 
 			ret = usb_reset_device(hdev);
 			if (ret) {
-				dev_dbg (hub_dev,
+				usb_dbg (hub_dev,
 					"error resetting hub: %d\n", ret);
 				goto loop_autopm;
 			}
@@ -2989,7 +2990,7 @@ static void hub_events(void)
 
 			if (portchange & USB_PORT_STAT_C_ENABLE) {
 				if (!connect_change)
-					dev_dbg (hub_dev,
+					usb_dbg (hub_dev,
 						"port %d enable change, "
 						"status %08x\n",
 						i, portstatus);
@@ -3031,7 +3032,7 @@ static void hub_events(void)
 					ret = -ENODEV;
 					hub_port_disable(hub, i, 1);
 				}
-				dev_dbg (hub_dev,
+				usb_dbg (hub_dev,
 					"resume on port %d, status %d\n",
 					i, ret);
 			}
@@ -3046,7 +3047,7 @@ static void hub_events(void)
 			}
 
 			if (portchange & USB_PORT_STAT_C_RESET) {
-				dev_dbg (hub_dev,
+				usb_dbg (hub_dev,
 					"reset change on port %d\n",
 					i);
 				clear_port_feature(hdev, i,
@@ -3065,7 +3066,7 @@ static void hub_events(void)
 			dev_err (hub_dev, "get_hub_status failed\n");
 		else {
 			if (hubchange & HUB_CHANGE_LOCAL_POWER) {
-				dev_dbg (hub_dev, "power change\n");
+				usb_dbg (hub_dev, "power change\n");
 				clear_hub_feature(hdev, C_HUB_LOCAL_POWER);
 				if (hubstatus & HUB_STATUS_LOCAL_POWER)
 					/* FIXME: Is this always true? */
@@ -3074,7 +3075,7 @@ static void hub_events(void)
 					hub->limited_power = 0;
 			}
 			if (hubchange & HUB_CHANGE_OVERCURRENT) {
-				dev_dbg (hub_dev, "overcurrent change\n");
+				usb_dbg (hub_dev, "overcurrent change\n");
 				msleep(500);	/* Cool down */
 				clear_hub_feature(hdev, C_HUB_OVER_CURRENT);
                         	hub_power_on(hub);
@@ -3113,7 +3114,8 @@ static int hub_thread(void *__unused)
 				kthread_should_stop());
 	} while (!kthread_should_stop() || !list_empty(&hub_event_list));
 
-	pr_debug("%s: khubd exiting\n", usbcore_name);
+	if (usb_debug)
+		printk(KERN_DEBUG "%s: khubd exiting\n", usbcore_name);
 	return 0;
 }
 
@@ -3215,14 +3217,14 @@ static int descriptors_changed(struct us
 		length = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,
 				old_length);
 		if (length != old_length) {
-			dev_dbg(&udev->dev, "config index %d, error %d\n",
+			usb_dbg(&udev->dev, "config index %d, error %d\n",
 					index, length);
 			changed = 1;
 			break;
 		}
 		if (memcmp (buf, udev->rawdescriptors[index], old_length)
 				!= 0) {
-			dev_dbg(&udev->dev, "config index %d changed (#%d)\n",
+			usb_dbg(&udev->dev, "config index %d changed (#%d)\n",
 				index,
 				((struct usb_config_descriptor *) buf)->
 					bConfigurationValue);
@@ -3235,11 +3237,11 @@ static int descriptors_changed(struct us
 		length = usb_string(udev, udev->descriptor.iSerialNumber,
 				buf, serial_len);
 		if (length + 1 != serial_len) {
-			dev_dbg(&udev->dev, "serial string error %d\n",
+			usb_dbg(&udev->dev, "serial string error %d\n",
 					length);
 			changed = 1;
 		} else if (memcmp(buf, udev->serial, length) != 0) {
-			dev_dbg(&udev->dev, "serial string changed\n");
+			usb_dbg(&udev->dev, "serial string changed\n");
 			changed = 1;
 		}
 	}
@@ -3288,14 +3290,14 @@ static int usb_reset_and_verify_device(s
 
 	if (udev->state == USB_STATE_NOTATTACHED ||
 			udev->state == USB_STATE_SUSPENDED) {
-		dev_dbg(&udev->dev, "device reset not allowed in state %d\n",
+		usb_dbg(&udev->dev, "device reset not allowed in state %d\n",
 				udev->state);
 		return -EINVAL;
 	}
 
 	if (!parent_hdev) {
 		/* this requires hcd-specific logic; see OHCI hc_restart() */
-		dev_dbg(&udev->dev, "%s for root hub!\n", __func__);
+		usb_dbg(&udev->dev, "%s for root hub!\n", __func__);
 		return -EISDIR;
 	}
 	parent_hub = hdev_to_hub(parent_hdev);
@@ -3395,7 +3397,7 @@ int usb_reset_device(struct usb_device *
 
 	if (udev->state == USB_STATE_NOTATTACHED ||
 			udev->state == USB_STATE_SUSPENDED) {
-		dev_dbg(&udev->dev, "device reset not allowed in state %d\n",
+		usb_dbg(&udev->dev, "device reset not allowed in state %d\n",
 				udev->state);
 		return -EINVAL;
 	}
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -56,7 +56,7 @@ static int usb_start_wait_urb(struct urb
 		usb_kill_urb(urb);
 		retval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);
 
-		dev_dbg(&urb->dev->dev,
+		usb_dbg(&urb->dev->dev,
 			"%s timed out on ep%d%s len=%d/%d\n",
 			current->comm,
 			usb_endpoint_num(&urb->ep->desc),
@@ -551,7 +551,7 @@ void usb_sg_wait(struct usb_sg_request *
 		default:
 			io->urbs[i]->dev = NULL;
 			io->urbs[i]->status = retval;
-			dev_dbg(&io->dev->dev, "%s, submit --> %d\n",
+			usb_dbg(&io->dev->dev, "%s, submit --> %d\n",
 				__func__, retval);
 			usb_sg_cancel(io);
 		}
@@ -806,7 +806,7 @@ int usb_string(struct usb_device *dev, i
 			dev->have_langid = 1;
 			dev->string_langid = tbuf[2] | (tbuf[3] << 8);
 			/* always use the first langid listed */
-			dev_dbg(&dev->dev, "default language 0x%04x\n",
+			usb_dbg(&dev->dev, "default language 0x%04x\n",
 				dev->string_langid);
 		}
 	}
@@ -828,7 +828,7 @@ int usb_string(struct usb_device *dev, i
 	err = idx;
 
 	if (tbuf[1] != USB_DT_STRING)
-		dev_dbg(&dev->dev,
+		usb_dbg(&dev->dev,
 			"wrong descriptor type %02x for string %d (\"%s\")\n",
 			tbuf[1], index, buf);
 
@@ -1070,7 +1070,7 @@ void usb_disable_device(struct usb_devic
 {
 	int i;
 
-	dev_dbg(&dev->dev, "%s nuking %s URBs\n", __func__,
+	usb_dbg(&dev->dev, "%s nuking %s URBs\n", __func__,
 		skip_ep0 ? "non-ep0" : "all");
 	for (i = skip_ep0; i < 16; ++i) {
 		usb_disable_endpoint(dev, i);
@@ -1089,7 +1089,7 @@ void usb_disable_device(struct usb_devic
 			interface = dev->actconfig->interface[i];
 			if (!device_is_registered(&interface->dev))
 				continue;
-			dev_dbg(&dev->dev, "unregistering interface %s\n",
+			usb_dbg(&dev->dev, "unregistering interface %s\n",
 				dev_name(&interface->dev));
 			usb_remove_sysfs_intf_files(interface);
 			device_del(&interface->dev);
@@ -1197,7 +1197,7 @@ int usb_set_interface(struct usb_device 
 
 	iface = usb_ifnum_to_if(dev, interface);
 	if (!iface) {
-		dev_dbg(&dev->dev, "selecting invalid interface %d\n",
+		usb_dbg(&dev->dev, "selecting invalid interface %d\n",
 			interface);
 		return -EINVAL;
 	}
@@ -1219,7 +1219,7 @@ int usb_set_interface(struct usb_device 
 	 * request if the interface only has one alternate setting.
 	 */
 	if (ret == -EPIPE && iface->num_altsetting == 1) {
-		dev_dbg(&dev->dev,
+		usb_dbg(&dev->dev,
 			"manual set_interface for iface %d, alt %d\n",
 			interface, alternate);
 		manual = 1;
@@ -1629,7 +1629,7 @@ free_interfaces:
 	for (i = 0; i < nintf; ++i) {
 		struct usb_interface *intf = cp->interface[i];
 
-		dev_dbg(&dev->dev,
+		usb_dbg(&dev->dev,
 			"adding %s (config #%d, interface %d)\n",
 			dev_name(&intf->dev), configuration,
 			intf->cur_altsetting->desc.bInterfaceNumber);
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -96,7 +96,7 @@ void usb_detect_quirks(struct usb_device
 	if (id)
 		udev->quirks = (u32)(id->driver_info);
 	if (udev->quirks)
-		dev_dbg(&udev->dev, "USB quirks for this device: %x\n",
+		usb_dbg(&udev->dev, "USB quirks for this device: %x\n",
 				udev->quirks);
 
 	/* By default, disable autosuspend for all non-hubs */
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -6,6 +6,7 @@
 #include <linux/log2.h>
 #include <linux/usb.h>
 #include <linux/wait.h>
+#include "usb.h"
 #include "hcd.h"
 
 #define to_urb(d) container_of(d, struct urb, kref)
@@ -340,7 +341,7 @@ int usb_submit_urb(struct urb *urb, gfp_
 
 	max = le16_to_cpu(ep->desc.wMaxPacketSize);
 	if (max <= 0) {
-		dev_dbg(&dev->dev,
+		usb_dbg(&dev->dev,
 			"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",
 			usb_endpoint_num(&ep->desc), is_out ? "out" : "in",
 			__func__, max);
