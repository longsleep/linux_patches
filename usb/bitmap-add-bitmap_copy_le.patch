From David Vrabel <david.vrabel@csr.com> Tue May 13 10:33:17 2008
From: David Vrabel <david.vrabel@csr.com>
Date: Tue, 13 May 2008 10:32:27 +0100
Subject: bitmap: add bitmap_copy_le()
To: linux-uwb@bughost.org
Cc: linux-usb@vger.kernel.org, David Vrabel <david.vrabel@csr.com>, Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>, Greg Kroah-Hartman <gregkh@suse.de>
Message-ID: <20080513093317.141829868@csr.com>>
Content-Disposition: inline; filename=bitmap-add-bitmap_copy_le.patch


From: David Vrabel <david.vrabel@csr.com>

bitmap_copy_le() copies a bitmap, putting the bits into little-endian
order (i.e., each unsigned long word in the bitmap is put into
little-endian order).

The UWB stack used bitmaps to manage Medium Access Slot availability,
and these bitmaps need to be written to the hardware in LE order.

Signed-off-by: David Vrabel <david.vrabel@csr.com>
Cc: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>

---
 include/linux/bitmap.h |    1 +
 lib/bitmap.c           |   22 ++++++++++++++++++++++
 2 files changed, 23 insertions(+)

--- a/include/linux/bitmap.h
+++ b/include/linux/bitmap.h
@@ -129,6 +129,7 @@ extern void bitmap_fold(unsigned long *d
 extern int bitmap_find_free_region(unsigned long *bitmap, int bits, int order);
 extern void bitmap_release_region(unsigned long *bitmap, int pos, int order);
 extern int bitmap_allocate_region(unsigned long *bitmap, int pos, int order);
+extern void bitmap_copy_le(void *dst, const unsigned long *src, int nbits);
 
 #define BITMAP_LAST_WORD_MASK(nbits)					\
 (									\
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -996,3 +996,25 @@ int bitmap_allocate_region(unsigned long
 	return 0;
 }
 EXPORT_SYMBOL(bitmap_allocate_region);
+
+/**
+ * bitmap_copy_le - copy a bitmap, putting the bits into little-endian order.
+ * @dst:   destination buffer
+ * @src:   bitmap to copy
+ * @nbits: number of bits in the bitmap
+ *
+ * Require nbits % BITS_PER_LONG == 0.
+ */
+void bitmap_copy_le(void *dst, const unsigned long *src, int nbits)
+{
+	unsigned long *d = dst;
+	int i;
+
+	for (i = 0; i < nbits/BITS_PER_LONG; i++) {
+		if (BITS_PER_LONG == 64)
+			d[i] = cpu_to_le64(src[i]);
+		else
+			d[i] = cpu_to_le32(src[i]);
+	}
+}
+EXPORT_SYMBOL(bitmap_copy_le);
