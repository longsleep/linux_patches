From stern@rowland.harvard.edu Wed May 30 13:51:32 2007
From: Alan Stern <stern@rowland.harvard.edu>
Date: Wed, 30 May 2007 16:51:28 -0400 (EDT)
Subject: USB: remove __usb_port_suspend
To: Greg KH <greg@kroah.com>
Cc: David Brownell <david-b@pacbell.net>
Message-ID: <Pine.LNX.4.44L0.0705301647500.2614-100000@iolanthe.rowland.org>


This patch (as915b) combines the public routine usb_port_suspend() and
the private routine __usb_port_suspend() into a single function.

By removing the explicit mention of otg_port in the call to
__usb_port_suspend(), we prevent a possible error in which the system
tries to perform HNP on the wrong port when a non-targeted device is
plugged into a non-OTG port.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/hub.c |   57 +++++++++++++++++++------------------------------
 drivers/usb/core/usb.h |   12 ++++++++--
 2 files changed, 33 insertions(+), 36 deletions(-)

--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1333,7 +1333,6 @@ static inline void show_string(struct us
 
 #ifdef	CONFIG_USB_OTG
 #include "otg_whitelist.h"
-static int __usb_port_suspend(struct usb_device *, int port1);
 #endif
 
 /**
@@ -1439,7 +1438,7 @@ int usb_new_device(struct usb_device *ud
 		 * (Includes HNP test device.)
 		 */
 		if (udev->bus->b_hnp_enable || udev->bus->is_b_host) {
-			err = __usb_port_suspend(udev, udev->bus->otg_port);
+			err = usb_port_suspend(udev);
 			if (err < 0)
 				dev_dbg(&udev->dev, "HNP fail, %d\n", err);
 		}
@@ -1683,6 +1682,23 @@ static int hub_port_suspend(struct usb_h
 }
 
 /*
+ * usb_port_suspend - suspend a usb device's upstream port
+ * @udev: device that's no longer in active use
+ * Context: must be able to sleep; device not locked; pm locks held
+ *
+ * Suspends a USB device that isn't in active use, conserving power.
+ * Devices may wake out of a suspend, if anything important happens,
+ * using the remote wakeup mechanism.  They may also be taken out of
+ * suspend by the host, using usb_port_resume().  It's also routine
+ * to disconnect devices while they are suspended.
+ *
+ * This only affects the USB hardware for a device; its interfaces
+ * (and, for hubs, child devices) must already have been suspended.
+ *
+ * Suspending OTG devices may trigger HNP, if that's been enabled
+ * between a pair of dual-role devices.  That will change roles, such
+ * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
+ *
  * Devices on USB hub ports have only one "suspend" state, corresponding
  * to ACPI D2, "may cause the device to lose some context".
  * State transitions include:
@@ -1699,21 +1715,19 @@ static int hub_port_suspend(struct usb_h
  * If CONFIG_USB_SUSPEND isn't enabled, devices only really suspend when
  * the root hub for their bus goes into global suspend ... so we don't
  * (falsely) update the device power state to say it suspended.
+ *
+ * Returns 0 on success, else negative errno.
  */
-static int __usb_port_suspend (struct usb_device *udev, int port1)
+int usb_port_suspend(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* caller owns the udev device lock */
-	if (port1 < 0)
-		return port1;
-
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
 	if (udev->parent)
-		status = hub_port_suspend(hdev_to_hub(udev->parent), port1,
-				udev);
+		status = hub_port_suspend(hdev_to_hub(udev->parent),
+				udev->portnum, udev);
 	else {
 		dev_dbg(&udev->dev, "usb %ssuspend\n",
 				udev->auto_pm ? "auto-" : "");
@@ -1723,31 +1737,6 @@ static int __usb_port_suspend (struct us
 }
 
 /*
- * usb_port_suspend - suspend a usb device's upstream port
- * @udev: device that's no longer in active use
- * Context: must be able to sleep; device not locked; pm locks held
- *
- * Suspends a USB device that isn't in active use, conserving power.
- * Devices may wake out of a suspend, if anything important happens,
- * using the remote wakeup mechanism.  They may also be taken out of
- * suspend by the host, using usb_port_resume().  It's also routine
- * to disconnect devices while they are suspended.
- *
- * This only affects the USB hardware for a device; its interfaces
- * (and, for hubs, child devices) must already have been suspended.
- *
- * Suspending OTG devices may trigger HNP, if that's been enabled
- * between a pair of dual-role devices.  That will change roles, such
- * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_port_suspend(struct usb_device *udev)
-{
-	return __usb_port_suspend(udev, udev->portnum);
-}
-
-/*
  * If the USB "suspend" state is in use (rather than "global suspend"),
  * many devices will be individually taken out of suspend state using
  * special" resume" signaling.  These routines kick in shortly after
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -53,8 +53,16 @@ static inline void usb_pm_unlock(struct 
 
 #else
 
-#define usb_port_suspend(dev)		0
-#define usb_port_resume(dev)		0
+static inline int usb_port_suspend(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int usb_port_resume(struct usb_device *udev)
+{
+	return 0;
+}
+
 static inline void usb_pm_lock(struct usb_device *udev) {}
 static inline void usb_pm_unlock(struct usb_device *udev) {}
 
