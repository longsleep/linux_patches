From david-b@pacbell.net Thu Mar 20 00:58:21 2008
From: Rene Herman <rene.herman@gmail.com>
Date: Thu, 20 Mar 2008 00:58:16 -0700
Subject: USB: ehci: stop vt6212 bus hogging
To: Greg KH <greg@kroah.com>
Cc: linux-usb@vger.kernel.org, "Rene Herman" <rene.herman@keyaccess.nl>, "Lev A. Melnikovsky" <melnikovsky@mail.ru>, "Alessandro Suardi" <alessandro.suardi@gmail.com>
Message-ID: <200803200058.16497.david-b@pacbell.net>
Content-Disposition: inline


From: Rene Herman <rene.herman@gmail.com>

The VIA VT6212 defaults to only waiting 1us between passes over EHCI's
async ring, which hammers PCI badly ... and by preventing other devices
from accessing the bus, causes problems like drops in IDE throughput,
a problem that's been bugging users of those chips for several years.

A (partial) datasheet for this chip eventually turned up, letting us
see how to make it use a VIA-specific register to switch over to the
the normal 10us value instead, as suggested by the EHCI specification
Solution noted by Lev A. Melnikovsky.

It's not clear whether this register exists on other VIA chips; we
know that it's ineffective on the vt8235.  So this patch only applies
to chips that seem to be incarnations of the (discrete) vt6212.

Signed-off-by: Rene Herman <rene.herman@gmail.com>
Tested-by: Lev A. Melnikovsky <melnikovsky@mail.ru>
Tested-by: Alessandro Suardi <alessandro.suardi@gmail.com>
Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/ehci-pci.c |   14 ++++++++++++++
 1 file changed, 14 insertions(+)

--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -152,6 +152,20 @@ static int ehci_pci_setup(struct usb_hcd
 			break;
 		}
 		break;
+	case PCI_VENDOR_ID_VIA:
+		if (pdev->device == 0x3104 && (pdev->revision & 0xf0) == 0x60) {
+			u8 tmp;
+
+			/* The VT6212 defaults to a 1 usec EHCI sleep time which
+			 * hogs the PCI bus *badly*. Setting bit 5 of 0x4B makes
+			 * that sleep time use the conventional 10 usec.
+			 */
+			pci_read_config_byte(pdev, 0x4b, &tmp);
+			if (tmp & 0x20)
+				break;
+			pci_write_config_byte(pdev, 0x4b, tmp | 0x20);
+		}
+		break;
 	}
 
 	ehci_reset(ehci);
