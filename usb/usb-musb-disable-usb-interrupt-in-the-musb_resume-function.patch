From chammoru@gmail.com  Wed Feb  4 15:25:17 2009
From: Kim Kyuwon <chammoru@gmail.com>
Date: Wed, 4 Feb 2009 09:01:43 +0900
Subject: USB: musb: Disable USB interrupt in the musb_resume() function
To: linux-usb@vger.kernel.org
Cc: linux-omap@vger.kernel.org, David Brownell <david-b@pacbell.net>, me@felipebalbi.com, 김규원 <q1.kim@samsung.com>
Message-ID: <4d34a0a70902031601r5c8c3424l4cd399193142e612@mail.gmail.com>


USB should be suspended with interrupt disabled[1]. If USB is suspended with
interrupt enabled and connected to host PC, a kernel panic would occur When
it wakes up. Because, after the arch_suspend_enable_irqs() function is called
in the suspend_enter() function, USB Interrupt handler is called, even though
USB controller is still not resumed! All devices are resumed after the
device_resume() is called.

[1] /Documentation/power/devices.txt: 412 line

Signed-off-by: Kim Kyuwon <chammoru@gmail.com>
Cc: Felipe Balbi <felipe.balbi@nokia.com>
Cc: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/musb/musb_core.c |    4 ++++
 1 file changed, 4 insertions(+)

--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -2151,6 +2151,8 @@ static int musb_suspend(struct platform_
 
 	spin_lock_irqsave(&musb->lock, flags);
 
+	disable_irq(musb->nIrq);
+
 	if (is_peripheral_active(musb)) {
 		/* FIXME force disconnect unless we know USB will wake
 		 * the system up quickly enough to respond ...
@@ -2184,6 +2186,8 @@ static int musb_resume(struct platform_d
 	else
 		clk_enable(musb->clock);
 
+	enable_irq(musb->nIrq);
+
 	/* for static cmos like DaVinci, register values were preserved
 	 * unless for some reason the whole soc powered down and we're
 	 * not treating that as a whole-system restart (e.g. swsusp)
