From augulis.darius@gmail.com  Sun Jan 25 15:23:01 2009
From: Darius <augulis.darius@gmail.com>
Date: Wed, 21 Jan 2009 15:17:25 +0200
Subject: USB: imx_udc: Fix IMX UDC gadget bugs
To: linux-usb@vger.kernel.org
Message-ID: <gl77dh$fum$2@ger.gmane.org>


From: Darius Augulis <augulis.darius@gmail.com>

Fix small bugs and add some omptimization in IMX UDC Gadget.

Signed-off-by: Darius Augulis <augulis.darius@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/imx_udc.c |   33 +++++++++++++++++++--------------
 drivers/usb/gadget/imx_udc.h |    2 +-
 2 files changed, 20 insertions(+), 15 deletions(-)

--- a/drivers/usb/gadget/imx_udc.c
+++ b/drivers/usb/gadget/imx_udc.c
@@ -283,7 +283,7 @@ void imx_ep_stall(struct imx_ep_struct *
 	imx_flush(imx_ep);
 
 	/* Special care for ep0 */
-	if (EP_NO(imx_ep)) {
+	if (!EP_NO(imx_ep)) {
 		temp = __raw_readl(imx_usb->base + USB_CTRL);
 		__raw_writel(temp | CTRL_CMDOVER | CTRL_CMDERROR, imx_usb->base + USB_CTRL);
 		do { } while (__raw_readl(imx_usb->base + USB_CTRL) & CTRL_CMDOVER);
@@ -301,7 +301,7 @@ void imx_ep_stall(struct imx_ep_struct *
 	 			break;
 	 		udelay(20);
 	 	}
-		if (i == 50)
+		if (i == 100)
 			D_ERR(imx_usb->dev, "<%s> Non finished stall on %s\n",
 				__func__, imx_ep->ep.name);
 	}
@@ -539,8 +539,7 @@ static int handle_ep0(struct imx_ep_stru
 	struct imx_request *req = NULL;
 	int ret = 0;
 
-	if (!list_empty(&imx_ep->queue))
-		req = list_entry(imx_ep->queue.next, struct imx_request, queue);
+	req = list_entry(imx_ep->queue.next, struct imx_request, queue);
 
 	if (req) {
 		switch (imx_ep->imx_usb->ep0state) {
@@ -561,6 +560,10 @@ static int handle_ep0(struct imx_ep_stru
 		}
 	}
 
+	else
+		D_ERR(imx_ep->imx_usb->dev, "<%s> no request on %s\n",
+						__func__, imx_ep->ep.name);
+
 	return ret;
 }
 
@@ -759,7 +762,7 @@ static int imx_ep_queue
 	*/
 	if (imx_usb->set_config && !EP_NO(imx_ep)) {
 		imx_usb->set_config = 0;
-		D_EPX(imx_usb->dev,
+		D_ERR(imx_usb->dev,
 			"<%s> gadget reply set config\n", __func__);
 		return 0;
 	}
@@ -779,8 +782,6 @@ static int imx_ep_queue
 		return -ESHUTDOWN;
 	}
 
-	local_irq_save(flags);
-
 	/* Debug */
 	D_REQ(imx_usb->dev, "<%s> ep%d %s request for [%d] bytes\n",
 		__func__, EP_NO(imx_ep),
@@ -790,17 +791,18 @@ static int imx_ep_queue
 
 	if (imx_ep->stopped) {
 		usb_req->status = -ESHUTDOWN;
-		ret = -ESHUTDOWN;
-		goto out;
+		return -ESHUTDOWN;
 	}
 
 	if (req->in_use) {
 		D_ERR(imx_usb->dev,
 			"<%s> refusing to queue req %p (already queued)\n",
 			__func__, req);
-		goto out;
+		return 0;
 	}
 
+	local_irq_save(flags);
+
 	usb_req->status = -EINPROGRESS;
 	usb_req->actual = 0;
 
@@ -810,7 +812,7 @@ static int imx_ep_queue
 		ret = handle_ep0(imx_ep);
 	else
 		ret = handle_ep(imx_ep);
-out:
+
 	local_irq_restore(flags);
 	return ret;
 }
@@ -1010,10 +1012,8 @@ static irqreturn_t imx_udc_irq(int irq, 
 				dump_usb_stat(__func__, imx_usb);
 	}
 
-	if (!imx_usb->driver) {
-		/*imx_udc_disable(imx_usb);*/
+	if (!imx_usb->driver)
 		goto end_irq;
-	}
 
 	if (intr & INTR_WAKEUP) {
 		if (imx_usb->gadget.speed == USB_SPEED_UNKNOWN
@@ -1095,6 +1095,11 @@ static irqreturn_t imx_udc_irq(int irq, 
 	}
 
 	if (intr & INTR_SOF) {
+		/* Copy from Motorola BSP.
+		   We must enable SOF intr and set CMDOVER.
+		   Datasheet don't specifiy this action, but it
+		   is done in Motorola BSP, so just copy it.
+		*/
 		if (imx_usb->ep0state == EP0_IDLE) {
 			temp = __raw_readl(imx_usb->base + USB_CTRL);
 			__raw_writel(temp | CTRL_CMDOVER, imx_usb->base + USB_CTRL);
--- a/drivers/usb/gadget/imx_udc.h
+++ b/drivers/usb/gadget/imx_udc.h
@@ -170,7 +170,7 @@ struct imx_udc_struct {
 /* #define DEBUG_IRQ */
 /* #define DEBUG_EPIRQ */
 /* #define DEBUG_DUMP */
-#define DEBUG_ERR
+/* #define DEBUG_ERR */
 
 #ifdef DEBUG_REQ
 	#define D_REQ(dev, args...)	dev_dbg(dev, ## args)
