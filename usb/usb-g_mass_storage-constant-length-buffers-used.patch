From m.nazarewicz@samsung.com  Fri Nov  6 14:43:08 2009
From: Michal Nazarewicz <m.nazarewicz@samsung.com>
Date: Wed, 28 Oct 2009 16:57:21 +0100
Subject: USB: g_mass_storage: constant length buffers used
To: Greg KH <greg@kroah.com>
Cc: Michal Nazarewicz <m.nazarewicz@samsung.com>
Message-ID: <9684085ca293823f2789d23e50eff8b03bec6c43.1256745228.git.m.nazarewicz@samsung.com>


Using version of fsg_buffhd structure with buf field being an
array of characters with predefined size.  Since mass storage
function does not define changing buffer size on run-time it is
not required for the field to be a pointer to void and allocating
space dynamically.

Signed-off-by: Michal Nazarewicz <m.nazarewicz@samsung.com>
Cc: David Brownell <dbrownell@users.sourceforge.net>
Cc: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/usb/gadget/f_mass_storage.c |   31 +++++++++++--------------------
 drivers/usb/gadget/storage_common.c |   10 ++++++++++
 2 files changed, 21 insertions(+), 20 deletions(-)

--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -258,6 +258,7 @@ static const char fsg_string_interface[]
 
 
 #define FSG_NO_INTR_EP 1
+#define FSG_BUFFHD_STATIC_BUFFER 1
 
 #include "storage_common.c"
 
@@ -1894,9 +1895,8 @@ static int send_status(struct fsg_dev *f
 				SK(sd), ASC(sd), ASCQ(sd), sdinfo);
 	}
 
-
 	/* Store and send the Bulk-only CSW */
-	csw = bh->buf;
+	csw = (void*)bh->buf;
 
 	csw->Signature = cpu_to_le32(USB_BULK_CS_SIG);
 	csw->Tag = fsg->tag;
@@ -2808,10 +2808,6 @@ static void /* __init_or_exit */ fsg_unb
 		complete(&fsg->thread_notifier);
 	}
 
-	/* Free the data buffers */
-	for (i = 0; i < FSG_NUM_BUFFERS; ++i)
-		kfree(fsg->common->buffhds[i].buf);
-
 	/* Free the request and buffer for endpoint 0 */
 	if (req) {
 		kfree(req->buf);
@@ -2978,20 +2974,6 @@ static int __init fsg_bind(struct usb_ga
 		goto out;
 	req->complete = ep0_complete;
 
-	/* Allocate the data buffers */
-	for (i = 0; i < FSG_NUM_BUFFERS; ++i) {
-		struct fsg_buffhd	*bh = &fsg->common->buffhds[i];
-
-		/* Allocate for the bulk-in endpoint.  We assume that
-		 * the buffer will also work with the bulk-out (and
-		 * interrupt-in) endpoint. */
-		bh->buf = kmalloc(FSG_BUFLEN, GFP_KERNEL);
-		if (!bh->buf)
-			goto out;
-		bh->next = bh + 1;
-	}
-	fsg->common->buffhds[FSG_NUM_BUFFERS - 1].next = &fsg->common->buffhds[0];
-
 	/* This should reflect the actual gadget power source */
 	usb_gadget_set_selfpowered(gadget);
 
@@ -3087,6 +3069,8 @@ static struct usb_gadget_driver		fsg_dri
 static int __init fsg_alloc(void)
 {
 	struct fsg_dev		*fsg;
+	struct fsg_buffhd	*bh;
+	unsigned		i;
 
 	fsg = kzalloc(sizeof *fsg, GFP_KERNEL);
 	if (!fsg)
@@ -3098,6 +3082,13 @@ static int __init fsg_alloc(void)
 		return -ENOMEM;
 	}
 
+	bh = fsg->common->buffhds;
+	i = FSG_NUM_BUFFERS - 1;
+	do {
+		bh->next = bh + 1;
+	} while (++bh, --i);
+	bh->next = fsg->common->buffhds;
+
 	spin_lock_init(&fsg->lock);
 	init_rwsem(&fsg->common->filesem);
 	init_completion(&fsg->thread_notifier);
--- a/drivers/usb/gadget/storage_common.c
+++ b/drivers/usb/gadget/storage_common.c
@@ -47,6 +47,12 @@
  * When FSG_NO_OTG is defined fsg_otg_desc won't be defined.
  */
 
+/*
+ * When FSG_BUFFHD_STATIC_BUFFER is defined when this file is included
+ * the fsg_buffhd structure's buf field will be an array of FSG_BUFLEN
+ * characters rather then a pointer to void.
+ */
+
 
 #include <asm/unaligned.h>
 
@@ -290,7 +296,11 @@ enum fsg_buffer_state {
 };
 
 struct fsg_buffhd {
+#ifdef FSG_BUFFHD_STATIC_BUFFER
+	char				buf[FSG_BUFLEN];
+#else
 	void				*buf;
+#endif
 	enum fsg_buffer_state		state;
 	struct fsg_buffhd		*next;
 
