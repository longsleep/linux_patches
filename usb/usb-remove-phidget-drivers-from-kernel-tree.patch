From foo@baz Wed Mar  4 16:23:31 PST 2009
Date: Wed, 04 Mar 2009 16:23:31 -0800
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: USB: remove phidget drivers from kernel tree.

From: Greg Kroah-Hartman <gregkh@suse.de>

These devices are better controlled with the LGPL userspace library
found at:
	http://www.phidgets.com/downloads.php?os_id=3
and full documentation at:
	http://www.phidgets.com/documentation/web/cdoc/index.html

Cc: Chester Fitchett <fitchett@phidgets.com>
Acked-by: Sean Young <sean@mess.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/misc/Kconfig               |   39 -
 drivers/usb/misc/Makefile              |    4 
 drivers/usb/misc/phidget.c             |   43 -
 drivers/usb/misc/phidget.h             |   12 
 drivers/usb/misc/phidgetkit.c          |  740 ---------------------------------
 drivers/usb/misc/phidgetmotorcontrol.c |  465 --------------------
 drivers/usb/misc/phidgetservo.c        |  375 ----------------
 7 files changed, 1678 deletions(-)

--- a/drivers/usb/misc/Kconfig
+++ b/drivers/usb/misc/Kconfig
@@ -135,45 +135,6 @@ config USB_CYTHERM
 	  To compile this driver as a module, choose M here: the
 	  module will be called cytherm.
 
-config USB_PHIDGET
-	tristate "USB Phidgets drivers"
-	depends on USB
-	help
-	  Say Y here to enable the various drivers for devices from
-	  Phidgets inc.
-
-config USB_PHIDGETKIT
-	tristate "USB PhidgetInterfaceKit support"
-	depends on USB_PHIDGET
-	help
-	  Say Y here if you want to connect a PhidgetInterfaceKit USB device
-	  from Phidgets Inc.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called phidgetkit.
-
-config USB_PHIDGETMOTORCONTROL
-	tristate "USB PhidgetMotorControl support"
-	depends on USB_PHIDGET
-	help
-	  Say Y here if you want to connect a PhidgetMotorControl USB device
-	  from Phidgets Inc.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called phidgetmotorcontrol.
-
-config USB_PHIDGETSERVO
-	tristate "USB PhidgetServo support"
-	depends on USB_PHIDGET
-	help
-	  Say Y here if you want to connect an 1 or 4 Motor PhidgetServo 
-	  servo controller version 2.0 or 3.0.
-
-	  Phidgets Inc. has a web page at <http://www.phidgets.com/>.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called phidgetservo.
-
 config USB_IDMOUSE
 	tristate "Siemens ID USB Mouse Fingerprint sensor support"
 	depends on USB
--- a/drivers/usb/misc/Makefile
+++ b/drivers/usb/misc/Makefile
@@ -18,10 +18,6 @@ obj-$(CONFIG_USB_LCD)		+= usblcd.o
 obj-$(CONFIG_USB_LD)		+= ldusb.o
 obj-$(CONFIG_USB_LED)		+= usbled.o
 obj-$(CONFIG_USB_LEGOTOWER)	+= legousbtower.o
-obj-$(CONFIG_USB_PHIDGET)	+= phidget.o
-obj-$(CONFIG_USB_PHIDGETKIT)	+= phidgetkit.o
-obj-$(CONFIG_USB_PHIDGETMOTORCONTROL)	+= phidgetmotorcontrol.o
-obj-$(CONFIG_USB_PHIDGETSERVO)	+= phidgetservo.o
 obj-$(CONFIG_USB_RIO500)	+= rio500.o
 obj-$(CONFIG_USB_TEST)		+= usbtest.o
 obj-$(CONFIG_USB_TRANCEVIBRATOR)	+= trancevibrator.o
--- a/drivers/usb/misc/phidget.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * USB Phidgets class
- *
- * Copyright (C) 2006  Sean Young <sean@mess.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/err.h>
-#include <linux/device.h>
-
-struct class *phidget_class;
-
-static int __init init_phidget(void)
-{
-	phidget_class = class_create(THIS_MODULE, "phidget");
-
-	if (IS_ERR(phidget_class))
-		return PTR_ERR(phidget_class);
-
-	return 0;
-}
-
-static void __exit cleanup_phidget(void)
-{
-	class_destroy(phidget_class);
-}
-
-EXPORT_SYMBOL_GPL(phidget_class);
-
-module_init(init_phidget);
-module_exit(cleanup_phidget);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Sean Young <sean@mess.org>");
-MODULE_DESCRIPTION("Container module for phidget class");
-
--- a/drivers/usb/misc/phidget.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/*
- * USB Phidgets class
- *
- * Copyright (C) 2006  Sean Young <sean@mess.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-extern struct class *phidget_class;
--- a/drivers/usb/misc/phidgetkit.c
+++ /dev/null
@@ -1,740 +0,0 @@
-/*
- * USB PhidgetInterfaceKit driver 1.0
- *
- * Copyright (C) 2004, 2006 Sean Young <sean@mess.org>
- * Copyright (C) 2005 Daniel Saakes <daniel@saakes.net>
- * Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This is a driver for the USB PhidgetInterfaceKit.
- */
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/usb.h>
-
-#include "phidget.h"
-
-#define DRIVER_AUTHOR "Sean Young <sean@mess.org>"
-#define DRIVER_DESC "USB PhidgetInterfaceKit Driver"
-
-#define USB_VENDOR_ID_GLAB		0x06c2
-#define USB_DEVICE_ID_INTERFACEKIT004	0x0040
-#define USB_DEVICE_ID_INTERFACEKIT01616	0x0044
-#define USB_DEVICE_ID_INTERFACEKIT888	0x0045
-#define USB_DEVICE_ID_INTERFACEKIT047	0x0051
-#define USB_DEVICE_ID_INTERFACEKIT088	0x0053
-
-#define USB_VENDOR_ID_WISEGROUP		0x0925
-#define USB_DEVICE_ID_INTERFACEKIT884	0x8201
-
-#define MAX_INTERFACES			16
-
-#define URB_INT_SIZE			8
-
-struct driver_interfacekit {
-	int sensors;
-	int inputs;
-	int outputs;
-	int has_lcd;
-	int amnesiac;
-};
-
-#define ifkit(_sensors, _inputs, _outputs, _lcd, _amnesiac)		\
-{									\
-	.sensors	= _sensors,					\
-	.inputs		= _inputs,					\
-	.outputs	= _outputs,					\
-	.has_lcd	= _lcd,						\
-	.amnesiac	= _amnesiac					\
-};
-
-static const struct driver_interfacekit ph_004 = ifkit(0, 0, 4, 0, 0);
-static const struct driver_interfacekit ph_888n = ifkit(8, 8, 8, 0, 1);
-static const struct driver_interfacekit ph_888o = ifkit(8, 8, 8, 0, 0);
-static const struct driver_interfacekit ph_047 = ifkit(0, 4, 7, 1, 0);
-static const struct driver_interfacekit ph_884 = ifkit(8, 8, 4, 0, 0);
-static const struct driver_interfacekit ph_088 = ifkit(0, 8, 8, 1, 0);
-static const struct driver_interfacekit ph_01616 = ifkit(0, 16, 16, 0, 0);
-
-static unsigned long device_no;
-
-struct interfacekit {
-	struct usb_device *udev;
-	struct usb_interface *intf;
-	struct driver_interfacekit *ifkit;
-	struct device *dev;
-	unsigned long outputs;
-	int dev_no;
-	u8 inputs[MAX_INTERFACES];
-	u16 sensors[MAX_INTERFACES];
-	u8 lcd_files_on;
-
-	struct urb *irq;
-	unsigned char *data;
-	dma_addr_t data_dma;
-
-	struct delayed_work do_notify;
-	struct delayed_work do_resubmit;
-	unsigned long input_events;
-	unsigned long sensor_events;
-};
-
-static struct usb_device_id id_table[] = {
-	{USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT004),
-		.driver_info = (kernel_ulong_t)&ph_004},
-	{USB_DEVICE_VER(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT888, 0, 0x814),
-		.driver_info = (kernel_ulong_t)&ph_888o},
-	{USB_DEVICE_VER(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT888, 0x0815, 0xffff),
-		.driver_info = (kernel_ulong_t)&ph_888n},
-	{USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT047),
-		.driver_info = (kernel_ulong_t)&ph_047},
-	{USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT088),
-		.driver_info = (kernel_ulong_t)&ph_088},
-	{USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_INTERFACEKIT01616),
-		.driver_info = (kernel_ulong_t)&ph_01616},
-	{USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_INTERFACEKIT884),
-		.driver_info = (kernel_ulong_t)&ph_884},
-	{}
-};
-MODULE_DEVICE_TABLE(usb, id_table);
-
-static int set_outputs(struct interfacekit *kit)
-{
-	u8 *buffer;
-	int retval;
-
-	buffer = kzalloc(4, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&kit->udev->dev, "%s - out of memory\n", __func__);
-		return -ENOMEM;
-	}
-	buffer[0] = (u8)kit->outputs;
-	buffer[1] = (u8)(kit->outputs >> 8);
-
-	dev_dbg(&kit->udev->dev, "sending data: 0x%04x\n", (u16)kit->outputs);
-
-	retval = usb_control_msg(kit->udev,
-			 usb_sndctrlpipe(kit->udev, 0),
-			 0x09, 0x21, 0x0200, 0x0000, buffer, 4, 2000);
-
-	if (retval != 4)
-		dev_err(&kit->udev->dev, "usb_control_msg returned %d\n", 
-				retval);
-	kfree(buffer);
-
-	if (kit->ifkit->amnesiac)
-		schedule_delayed_work(&kit->do_resubmit, HZ / 2);
-
-	return retval < 0 ? retval : 0;
-}
-
-static int change_string(struct interfacekit *kit, const char *display, unsigned char row)
-{
-	unsigned char *buffer;
-	unsigned char *form_buffer;
-	int retval = -ENOMEM;
-	int i,j, len, buf_ptr;
-	
-	buffer = kmalloc(8, GFP_KERNEL);
-	form_buffer = kmalloc(30, GFP_KERNEL);
-	if ((!buffer) || (!form_buffer)) {
-		dev_err(&kit->udev->dev, "%s - out of memory\n", __func__);
-		goto exit;
-	}
-
-	len = strlen(display);
-	if (len > 20)
-		len = 20;
-
-	dev_dbg(&kit->udev->dev, "Setting LCD line %d to %s\n", row, display);
-
-	form_buffer[0] = row * 0x40 + 0x80;
-	form_buffer[1] = 0x02;
-	buf_ptr = 2;
-	for (i = 0; i<len; i++)
-		form_buffer[buf_ptr++] = display[i];
-
-	for (i = 0; i < (20 - len); i++)
-		form_buffer[buf_ptr++] = 0x20;
-	form_buffer[buf_ptr++] = 0x01;
-	form_buffer[buf_ptr++] = row * 0x40 + 0x80 + strlen(display);
-
-	for (i = 0; i < buf_ptr; i += 7) {
-		if ((buf_ptr - i) > 7)
-			len = 7;
-		else
-			len = (buf_ptr - i);
-		for (j = 0; j < len; j++)
-			buffer[j] = form_buffer[i + j];
-		buffer[7] = len;
-
-		retval = usb_control_msg(kit->udev,
-				 usb_sndctrlpipe(kit->udev, 0),
-				 0x09, 0x21, 0x0200, 0x0000, buffer, 8, 2000);
-		if (retval < 0)
-			goto exit;
-	}
-
-	retval = 0;
-exit:
-	kfree(buffer);
-	kfree(form_buffer);
-
-	return retval;
-}
-
-#define set_lcd_line(number)	\
-static ssize_t lcd_line_##number(struct device *dev,			\
-					struct device_attribute *attr,	\
-					const char *buf, size_t count)	\
-{									\
-	struct interfacekit *kit = dev_get_drvdata(dev);		\
-	change_string(kit, buf, number - 1);				\
-	return count;							\
-}
-
-#define lcd_line_attr(number)						\
-	__ATTR(lcd_line_##number, S_IWUGO, NULL, lcd_line_##number)
-
-set_lcd_line(1);
-set_lcd_line(2);
-
-static ssize_t set_backlight(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct interfacekit *kit = dev_get_drvdata(dev);
-	int enabled;
-	unsigned char *buffer;
-	int retval = -ENOMEM;
-	
-	buffer = kzalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&kit->udev->dev, "%s - out of memory\n", __func__);
-		goto exit;
-	}
-
-	if (sscanf(buf, "%d", &enabled) < 1) {
-		retval = -EINVAL;
-		goto exit;
-	}
-	if (enabled)
-		buffer[0] = 0x01;
-	buffer[7] = 0x11;
-
-	dev_dbg(&kit->udev->dev, "Setting backlight to %s\n", enabled ? "on" : "off");
-	
-	retval = usb_control_msg(kit->udev,
-			 usb_sndctrlpipe(kit->udev, 0),
-			 0x09, 0x21, 0x0200, 0x0000, buffer, 8, 2000);
-	if (retval < 0)
-		goto exit;
-
-	retval = count;
-exit:
-	kfree(buffer);
-	return retval;
-}
-
-static struct device_attribute dev_lcd_line_attrs[] = {
-	lcd_line_attr(1),
-	lcd_line_attr(2),
-	__ATTR(backlight, S_IWUGO, NULL, set_backlight)
-};
-
-static void remove_lcd_files(struct interfacekit *kit)
-{
-	int i;
-
-	if (kit->lcd_files_on) {
-		dev_dbg(&kit->udev->dev, "Removing lcd files\n");
-
-		for (i=0; i<ARRAY_SIZE(dev_lcd_line_attrs); i++)
-			device_remove_file(kit->dev, &dev_lcd_line_attrs[i]);
-	}
-}
-
-static ssize_t enable_lcd_files(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct interfacekit *kit = dev_get_drvdata(dev);
-	int enable;
-	int i, rc;
-	
-	if (kit->ifkit->has_lcd == 0)
-		return -ENODEV;
-
-	if (sscanf(buf, "%d", &enable) < 1)
-		return -EINVAL;
-
-	if (enable) {
-		if (!kit->lcd_files_on) {
-			dev_dbg(&kit->udev->dev, "Adding lcd files\n");
-			for (i=0; i<ARRAY_SIZE(dev_lcd_line_attrs); i++) {
-				rc = device_create_file(kit->dev,
-					&dev_lcd_line_attrs[i]);
-				if (rc)
-					goto out;
-			}
-			kit->lcd_files_on = 1;
-		}
-	} else {
-		if (kit->lcd_files_on) {
-			remove_lcd_files(kit);
-			kit->lcd_files_on = 0;
-		}
-	}
-	
-	return count;
-out:
-	while (i-- > 0)
-		device_remove_file(kit->dev, &dev_lcd_line_attrs[i]);
-
-	return rc;
-}
-
-static DEVICE_ATTR(lcd, S_IWUGO, NULL, enable_lcd_files);
-
-static void interfacekit_irq(struct urb *urb)
-{
-	struct interfacekit *kit = urb->context;
-	unsigned char *buffer = kit->data;
-	int i, level, sensor;
-	int retval;
-	int status = urb->status;
-
-	switch (status) {
-	case 0:			/* success */
-		break;
-	case -ECONNRESET:	/* unlink */
-	case -ENOENT:
-	case -ESHUTDOWN:
-		return;
-	/* -EPIPE:  should clear the halt */
-	default:		/* error */
-		goto resubmit;
-	}
-
-	/* digital inputs */
-	if (kit->ifkit->inputs == 16) {
-		for (i=0; i < 8; i++) {
-			level = (buffer[0] >> i) & 1;
-			if (kit->inputs[i] != level) {
-				kit->inputs[i] = level;
-				set_bit(i, &kit->input_events);
-			}
-			level = (buffer[1] >> i) & 1;
-			if (kit->inputs[8 + i] != level) {
-				kit->inputs[8 + i] = level;
-				set_bit(8 + i, &kit->input_events);
-			}
-		}
-	}
-	else if (kit->ifkit->inputs == 8) {
-		for (i=0; i < 8; i++) {
-			level = (buffer[1] >> i) & 1;
-			if (kit->inputs[i] != level) {
-				kit->inputs[i] = level;
-				set_bit(i, &kit->input_events);
-			}
-		}
-	}
-
-	/* analog inputs */
-	if (kit->ifkit->sensors) {
-		sensor = (buffer[0] & 1) ? 4 : 0;
-
-		level = buffer[2] + (buffer[3] & 0x0f) * 256;
-		if (level != kit->sensors[sensor]) {
-			kit->sensors[sensor] = level;
-			set_bit(sensor, &kit->sensor_events);
-		}
-		sensor++;
-		level = buffer[4] + (buffer[3] & 0xf0) * 16;
-		if (level != kit->sensors[sensor]) {
-			kit->sensors[sensor] = level;
-			set_bit(sensor, &kit->sensor_events);
-		}
-		sensor++;
-		level = buffer[5] + (buffer[6] & 0x0f) * 256;
-		if (level != kit->sensors[sensor]) {
-			kit->sensors[sensor] = level;
-			set_bit(sensor, &kit->sensor_events);
-		}
-		sensor++;
-		level = buffer[7] + (buffer[6] & 0xf0) * 16;
-		if (level != kit->sensors[sensor]) {
-			kit->sensors[sensor] = level;
-			set_bit(sensor, &kit->sensor_events);
-		}
-	}
-
-	if (kit->input_events || kit->sensor_events)
-		schedule_delayed_work(&kit->do_notify, 0);
-
-resubmit:
-	retval = usb_submit_urb(urb, GFP_ATOMIC);
-	if (retval)
-		err("can't resubmit intr, %s-%s/interfacekit0, retval %d",
-			kit->udev->bus->bus_name,
-			kit->udev->devpath, retval);
-}
-
-static void do_notify(struct work_struct *work)
-{
-	struct interfacekit *kit =
-		container_of(work, struct interfacekit, do_notify.work);
-	int i;
-	char sysfs_file[8];
-
-	for (i=0; i<kit->ifkit->inputs; i++) {
-		if (test_and_clear_bit(i, &kit->input_events)) {
-			sprintf(sysfs_file, "input%d", i + 1);
-			sysfs_notify(&kit->dev->kobj, NULL, sysfs_file);
-		}
-	}
-
-	for (i=0; i<kit->ifkit->sensors; i++) {
-		if (test_and_clear_bit(i, &kit->sensor_events)) {
-			sprintf(sysfs_file, "sensor%d", i + 1);
-			sysfs_notify(&kit->dev->kobj, NULL, sysfs_file);
-		}
-	}
-}
-
-static void do_resubmit(struct work_struct *work)
-{
-	struct interfacekit *kit =
-		container_of(work, struct interfacekit, do_resubmit.work);
-	set_outputs(kit);
-}
-
-#define show_set_output(value)		\
-static ssize_t set_output##value(struct device *dev,			\
-					struct device_attribute *attr,	\
-					const char *buf, size_t count)	\
-{									\
-	struct interfacekit *kit = dev_get_drvdata(dev);		\
-	int enable;							\
-	int retval;							\
-									\
-	if (sscanf(buf, "%d", &enable) < 1)				\
-		return -EINVAL;						\
-									\
-	if (enable)							\
-		set_bit(value - 1, &kit->outputs);			\
-	else								\
-		clear_bit(value - 1, &kit->outputs); 			\
-									\
-	retval = set_outputs(kit);					\
-									\
-	return retval ? retval : count;					\
-}									\
-									\
-static ssize_t show_output##value(struct device *dev, 			\
-					struct device_attribute *attr,	\
-					char *buf)			\
-{									\
-	struct interfacekit *kit = dev_get_drvdata(dev);		\
-									\
-	return sprintf(buf, "%d\n", !!test_bit(value - 1, &kit->outputs));\
-}
-
-#define output_attr(value)						\
-	__ATTR(output##value, S_IWUGO | S_IRUGO,			\
-		show_output##value, set_output##value)
-
-show_set_output(1);
-show_set_output(2);
-show_set_output(3);
-show_set_output(4);
-show_set_output(5);
-show_set_output(6);
-show_set_output(7);
-show_set_output(8);
-show_set_output(9);
-show_set_output(10);
-show_set_output(11);
-show_set_output(12);
-show_set_output(13);
-show_set_output(14);
-show_set_output(15);
-show_set_output(16);
-
-static struct device_attribute dev_output_attrs[] = {
-	output_attr(1), output_attr(2), output_attr(3), output_attr(4),
-	output_attr(5), output_attr(6), output_attr(7), output_attr(8),
-	output_attr(9), output_attr(10), output_attr(11), output_attr(12),
-	output_attr(13), output_attr(14), output_attr(15), output_attr(16)
-};
-
-#define show_input(value)	\
-static ssize_t show_input##value(struct device *dev, 			\
-			struct device_attribute *attr, char *buf)	\
-{									\
-	struct interfacekit *kit = dev_get_drvdata(dev);		\
-									\
-	return sprintf(buf, "%d\n", (int)kit->inputs[value - 1]);	\
-}
-
-#define input_attr(value)						\
-	__ATTR(input##value, S_IRUGO, show_input##value, NULL)
-
-show_input(1);
-show_input(2);
-show_input(3);
-show_input(4);
-show_input(5);
-show_input(6);
-show_input(7);
-show_input(8);
-show_input(9);
-show_input(10);
-show_input(11);
-show_input(12);
-show_input(13);
-show_input(14);
-show_input(15);
-show_input(16);
-
-static struct device_attribute dev_input_attrs[] = {
-	input_attr(1), input_attr(2), input_attr(3), input_attr(4),
-	input_attr(5), input_attr(6), input_attr(7), input_attr(8),
-	input_attr(9), input_attr(10), input_attr(11), input_attr(12),
-	input_attr(13), input_attr(14), input_attr(15), input_attr(16)
-};
-
-#define show_sensor(value)	\
-static ssize_t show_sensor##value(struct device *dev,			\
-					struct device_attribute *attr,	\
-					char *buf)			\
-{									\
-	struct interfacekit *kit = dev_get_drvdata(dev);		\
-									\
-	return sprintf(buf, "%d\n", (int)kit->sensors[value - 1]);	\
-}
-
-#define sensor_attr(value)						\
-	__ATTR(sensor##value, S_IRUGO, show_sensor##value, NULL)
-
-show_sensor(1);
-show_sensor(2);
-show_sensor(3);
-show_sensor(4);
-show_sensor(5);
-show_sensor(6);
-show_sensor(7);
-show_sensor(8);
-
-static struct device_attribute dev_sensor_attrs[] = {
-	sensor_attr(1), sensor_attr(2), sensor_attr(3), sensor_attr(4),
-	sensor_attr(5), sensor_attr(6), sensor_attr(7), sensor_attr(8)
-};
-
-static int interfacekit_probe(struct usb_interface *intf, const struct usb_device_id *id)
-{
-	struct usb_device *dev = interface_to_usbdev(intf);
-	struct usb_host_interface *interface;
-	struct usb_endpoint_descriptor *endpoint;
-	struct interfacekit *kit;
-	struct driver_interfacekit *ifkit;
-	int pipe, maxp, rc = -ENOMEM;
-	int bit, value, i;
-
-	ifkit = (struct driver_interfacekit *)id->driver_info;
-	if (!ifkit)
-		return -ENODEV;
-
-	interface = intf->cur_altsetting;
-	if (interface->desc.bNumEndpoints != 1)
-		return -ENODEV;
-
-	endpoint = &interface->endpoint[0].desc;
-	if (!usb_endpoint_dir_in(endpoint))
-		return -ENODEV;
-	/*
-	 * bmAttributes
-	 */
-	pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
-	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
-	
-	kit = kzalloc(sizeof(*kit), GFP_KERNEL);
-	if (!kit)
-		goto out;
-
-	kit->dev_no = -1;
-	kit->ifkit = ifkit;
-	kit->data = usb_buffer_alloc(dev, URB_INT_SIZE, GFP_ATOMIC, &kit->data_dma);
-	if (!kit->data)
-		goto out;
-
-	kit->irq = usb_alloc_urb(0, GFP_KERNEL);
-	if (!kit->irq)
-		goto out;
-
-	kit->udev = usb_get_dev(dev);
-	kit->intf = intf;
-	INIT_DELAYED_WORK(&kit->do_notify, do_notify);
-	INIT_DELAYED_WORK(&kit->do_resubmit, do_resubmit);
-	usb_fill_int_urb(kit->irq, kit->udev, pipe, kit->data,
-			maxp > URB_INT_SIZE ? URB_INT_SIZE : maxp,
-			interfacekit_irq, kit, endpoint->bInterval);
-	kit->irq->transfer_dma = kit->data_dma;
-	kit->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-
-	usb_set_intfdata(intf, kit);
-
-        do {
-                bit = find_first_zero_bit(&device_no, sizeof(device_no));
-                value = test_and_set_bit(bit, &device_no);
-        } while(value);
-        kit->dev_no = bit;
-
-	kit->dev = device_create(phidget_class, &kit->udev->dev, MKDEV(0, 0),
-				 kit, "interfacekit%d", kit->dev_no);
-        if (IS_ERR(kit->dev)) {
-                rc = PTR_ERR(kit->dev);
-                kit->dev = NULL;
-                goto out;
-        }
-
-	if (usb_submit_urb(kit->irq, GFP_KERNEL)) {
-		rc = -EIO;
-		goto out;
-	}
-
-	for (i=0; i<ifkit->outputs; i++ ) {
-		rc = device_create_file(kit->dev, &dev_output_attrs[i]);
-		if (rc)
-			goto out2;
-	}
-
-	for (i=0; i<ifkit->inputs; i++ ) {
-		rc = device_create_file(kit->dev, &dev_input_attrs[i]);
-		if (rc)
-			goto out3;
-	}
-
-	for (i=0; i<ifkit->sensors; i++ ) {
-		rc = device_create_file(kit->dev, &dev_sensor_attrs[i]);
-		if (rc)
-			goto out4;
-	}
-
-	if (ifkit->has_lcd) {
-		rc = device_create_file(kit->dev, &dev_attr_lcd);
-		if (rc)
-			goto out4;
-
-	}
-
-	dev_info(&intf->dev, "USB PhidgetInterfaceKit %d/%d/%d attached\n",
-			ifkit->sensors, ifkit->inputs, ifkit->outputs);
-
-	return 0;
-
-out4:
-	while (i-- > 0)
-		device_remove_file(kit->dev, &dev_sensor_attrs[i]);
-
-	i = ifkit->inputs;
-out3:
-	while (i-- > 0)
-		device_remove_file(kit->dev, &dev_input_attrs[i]);
-
-	i = ifkit->outputs;
-out2:
-	while (i-- > 0)
-		device_remove_file(kit->dev, &dev_output_attrs[i]);
-out:
-	if (kit) {
-		usb_free_urb(kit->irq);
-		if (kit->data)
-			usb_buffer_free(dev, URB_INT_SIZE, kit->data, kit->data_dma);
-		if (kit->dev)
-			device_unregister(kit->dev);
-		if (kit->dev_no >= 0)
-			clear_bit(kit->dev_no, &device_no);
-
-		kfree(kit);
-	}
-
-	return rc;
-}
-
-static void interfacekit_disconnect(struct usb_interface *interface)
-{
-	struct interfacekit *kit;
-	int i;
-
-	kit = usb_get_intfdata(interface);
-	usb_set_intfdata(interface, NULL);
-	if (!kit)
-		return;
-
-	usb_kill_urb(kit->irq);
-	usb_free_urb(kit->irq);
-	usb_buffer_free(kit->udev, URB_INT_SIZE, kit->data, kit->data_dma);
-
-	cancel_delayed_work(&kit->do_notify);
-	cancel_delayed_work(&kit->do_resubmit);
-
-	for (i=0; i<kit->ifkit->outputs; i++)
-		device_remove_file(kit->dev, &dev_output_attrs[i]);
-
-	for (i=0; i<kit->ifkit->inputs; i++)
-		device_remove_file(kit->dev, &dev_input_attrs[i]);
-
-	for (i=0; i<kit->ifkit->sensors; i++)
-		device_remove_file(kit->dev, &dev_sensor_attrs[i]);
-
-	if (kit->ifkit->has_lcd) {
-		device_remove_file(kit->dev, &dev_attr_lcd);
-		remove_lcd_files(kit);
-	}
-
-	device_unregister(kit->dev);
-
-	dev_info(&interface->dev, "USB PhidgetInterfaceKit %d/%d/%d detached\n",
-		kit->ifkit->sensors, kit->ifkit->inputs, kit->ifkit->outputs);
-
-	usb_put_dev(kit->udev);
-	clear_bit(kit->dev_no, &device_no);
-
-	kfree(kit);
-}
-
-static struct usb_driver interfacekit_driver = {
-	.name = "phidgetkit",
-	.probe = interfacekit_probe,
-	.disconnect = interfacekit_disconnect,
-	.id_table = id_table
-};
-
-static int __init interfacekit_init(void)
-{
-	int retval = 0;
-
-	retval = usb_register(&interfacekit_driver);
-	if (retval)
-		err("usb_register failed. Error number %d", retval);
-
-	return retval;
-}
-
-static void __exit interfacekit_exit(void)
-{
-	usb_deregister(&interfacekit_driver);
-}
-
-module_init(interfacekit_init);
-module_exit(interfacekit_exit);
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
--- a/drivers/usb/misc/phidgetmotorcontrol.c
+++ /dev/null
@@ -1,465 +0,0 @@
-/*
- * USB Phidget MotorControl driver
- *
- * Copyright (C) 2006  Sean Young <sean@mess.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/usb.h>
-
-#include "phidget.h"
-
-#define DRIVER_AUTHOR "Sean Young <sean@mess.org>"
-#define DRIVER_DESC "USB PhidgetMotorControl Driver"
-
-#define USB_VENDOR_ID_GLAB		0x06c2
-#define USB_DEVICE_ID_MOTORCONTROL	0x0058
-
-#define URB_INT_SIZE			8
-
-static unsigned long device_no;
-
-struct motorcontrol {
-	struct usb_device *udev;
-	struct usb_interface *intf;
-	struct device *dev;
-	int dev_no;
-	u8 inputs[4];
-	s8 desired_speed[2];
-	s8 speed[2];
-	s16 _current[2];
-	s8 acceleration[2];
-	struct urb *irq;
-	unsigned char *data;
-	dma_addr_t data_dma;
-
-	struct delayed_work do_notify;
-	unsigned long input_events;
-	unsigned long speed_events;
-	unsigned long exceed_events;
-};
-
-static struct usb_device_id id_table[] = {
-	{ USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_MOTORCONTROL) },
-	{}
-};
-MODULE_DEVICE_TABLE(usb, id_table);
-
-static int set_motor(struct motorcontrol *mc, int motor)
-{
-	u8 *buffer;
-	int speed, speed2, acceleration;
-	int retval;
-
-	buffer = kzalloc(8, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&mc->intf->dev, "%s - out of memory\n", __func__);
-		return -ENOMEM;
-	}
-
-	acceleration = mc->acceleration[motor] * 10;
-	/* -127 <= speed <= 127 */
-	speed = (mc->desired_speed[motor] * 127) / 100;
-	/* -0x7300 <= speed2 <= 0x7300 */
-	speed2 = (mc->desired_speed[motor] * 230 * 128) / 100;
-
-	buffer[0] = motor;
-	buffer[1] = speed;
-	buffer[2] = acceleration >> 8;
-	buffer[3] = acceleration;
-	buffer[4] = speed2 >> 8;
-	buffer[5] = speed2;
-
-	retval = usb_control_msg(mc->udev,
-			 usb_sndctrlpipe(mc->udev, 0),
-			 0x09, 0x21, 0x0200, 0x0000, buffer, 8, 2000);
-
-	if (retval != 8)
-		dev_err(&mc->intf->dev, "usb_control_msg returned %d\n",
-				retval);
-	kfree(buffer);
-
-	return retval < 0 ? retval : 0;
-}
-
-static void motorcontrol_irq(struct urb *urb)
-{
-	struct motorcontrol *mc = urb->context;
-	unsigned char *buffer = mc->data;
-	int i, level;
-	int retval;
-	int status = urb->status;;
-
-	switch (status) {
-	case 0:			/* success */
-		break;
-	case -ECONNRESET:	/* unlink */
-	case -ENOENT:
-	case -ESHUTDOWN:
-		return;
-	/* -EPIPE:  should clear the halt */
-	default:		/* error */
-		goto resubmit;
-	}
-
-	/* digital inputs */
-	for (i=0; i<4; i++) {
-		level = (buffer[0] >> i) & 1;
-		if (mc->inputs[i] != level) {
-			mc->inputs[i] = level;
-			set_bit(i, &mc->input_events);
-		}
-	}
-
-	/* motor speed */
-	if (buffer[2] == 0) {
-		for (i=0; i<2; i++) {
-		level = ((s8)buffer[4+i]) * 100 / 127;
-			if (mc->speed[i] != level) {
-				mc->speed[i] = level;
-				set_bit(i, &mc->speed_events);
-			}
-		}
-	} else {
-		int index = buffer[3] & 1;
-
-		level = ((s8)buffer[4] << 8) | buffer[5];
-		level = level * 100 / 29440;
-		if (mc->speed[index] != level) {
-			mc->speed[index] = level;
-			set_bit(index, &mc->speed_events);
-		}
-
-		level = ((s8)buffer[6] << 8) | buffer[7];
-		mc->_current[index] = level * 100 / 1572;
-	}
-
-	if (buffer[1] & 1)
-		set_bit(0, &mc->exceed_events);
-
-	if (buffer[1] & 2)
-		set_bit(1, &mc->exceed_events);
-
-	if (mc->input_events || mc->exceed_events || mc->speed_events)
-		schedule_delayed_work(&mc->do_notify, 0);
-
-resubmit:
-	retval = usb_submit_urb(urb, GFP_ATOMIC);
-	if (retval)
-		dev_err(&mc->intf->dev,
-			"can't resubmit intr, %s-%s/motorcontrol0, retval %d\n",
-			mc->udev->bus->bus_name,
-			mc->udev->devpath, retval);
-}
-
-static void do_notify(struct work_struct *work)
-{
-	struct motorcontrol *mc =
-		container_of(work, struct motorcontrol, do_notify.work);
-	int i;
-	char sysfs_file[8];
-
-	for (i=0; i<4; i++) {
-		if (test_and_clear_bit(i, &mc->input_events)) {
-			sprintf(sysfs_file, "input%d", i);
-			sysfs_notify(&mc->dev->kobj, NULL, sysfs_file);
-		}
-	}
-
-	for (i=0; i<2; i++) {
-		if (test_and_clear_bit(i, &mc->speed_events)) {
-			sprintf(sysfs_file, "speed%d", i);
-			sysfs_notify(&mc->dev->kobj, NULL, sysfs_file);
-		}
-	}
-
-	for (i=0; i<2; i++) {
-		if (test_and_clear_bit(i, &mc->exceed_events))
-			dev_warn(&mc->intf->dev,
-				"motor #%d exceeds 1.5 Amp current limit\n", i);
-	}
-}
-
-#define show_set_speed(value)		\
-static ssize_t set_speed##value(struct device *dev,			\
-					struct device_attribute *attr,	\
-					const char *buf, size_t count)	\
-{									\
-	struct motorcontrol *mc = dev_get_drvdata(dev);			\
-	int speed;							\
-	int retval;							\
-									\
-	if (sscanf(buf, "%d", &speed) < 1)				\
-		return -EINVAL;						\
-									\
-	if (speed < -100 || speed > 100)				\
-		return -EINVAL;						\
-									\
-	mc->desired_speed[value] = speed;				\
-									\
-	retval = set_motor(mc, value);					\
-									\
-	return retval ? retval : count;					\
-}									\
-									\
-static ssize_t show_speed##value(struct device *dev,			\
-					struct device_attribute *attr,	\
-					char *buf)			\
-{									\
-	struct motorcontrol *mc = dev_get_drvdata(dev);			\
-									\
-	return sprintf(buf, "%d\n", mc->speed[value]);			\
-}
-
-#define speed_attr(value) 						\
-	__ATTR(speed##value, S_IWUGO | S_IRUGO, 			\
-		show_speed##value, set_speed##value)
-
-show_set_speed(0);
-show_set_speed(1);
-
-#define show_set_acceleration(value)		\
-static ssize_t set_acceleration##value(struct device *dev, 		\
-					struct device_attribute *attr,	\
-					const char *buf, size_t count)	\
-{									\
-	struct motorcontrol *mc = dev_get_drvdata(dev);			\
-	int acceleration;						\
-	int retval;							\
-									\
-	if (sscanf(buf, "%d", &acceleration) < 1)			\
-		return -EINVAL;						\
-									\
-	if (acceleration < 0 || acceleration > 100)			\
-		return -EINVAL;						\
-									\
-	mc->acceleration[value] = acceleration;				\
-									\
-	retval = set_motor(mc, value);					\
-									\
-	return retval ? retval : count;					\
-}									\
-									\
-static ssize_t show_acceleration##value(struct device *dev,	 	\
-					struct device_attribute *attr,	\
-							char *buf)	\
-{									\
-	struct motorcontrol *mc = dev_get_drvdata(dev);			\
-									\
-	return sprintf(buf, "%d\n", mc->acceleration[value]);		\
-}
-
-#define acceleration_attr(value)	\
-	__ATTR(acceleration##value, S_IWUGO | S_IRUGO,			\
-		show_acceleration##value, set_acceleration##value)
-
-show_set_acceleration(0);
-show_set_acceleration(1);
-
-#define show_current(value)	\
-static ssize_t show_current##value(struct device *dev,			\
-					struct device_attribute *attr,	\
-					char *buf)			\
-{									\
-	struct motorcontrol *mc = dev_get_drvdata(dev);			\
-									\
-	return sprintf(buf, "%dmA\n", (int)mc->_current[value]);	\
-}
-
-#define current_attr(value)	\
-	__ATTR(current##value, S_IRUGO, show_current##value, NULL)
-
-show_current(0);
-show_current(1);
-
-#define show_input(value)	\
-static ssize_t show_input##value(struct device *dev,			\
-					struct device_attribute *attr,	\
-					char *buf)			\
-{									\
-	struct motorcontrol *mc = dev_get_drvdata(dev);			\
-									\
-	return sprintf(buf, "%d\n", (int)mc->inputs[value]);		\
-}
-
-#define input_attr(value)	\
-	__ATTR(input##value, S_IRUGO, show_input##value, NULL)
-
-show_input(0);
-show_input(1);
-show_input(2);
-show_input(3);
-
-static struct device_attribute dev_attrs[] = {
-	input_attr(0),
-	input_attr(1),
-	input_attr(2),
-	input_attr(3),
-	speed_attr(0),
-	speed_attr(1),
-	acceleration_attr(0),
-	acceleration_attr(1),
-	current_attr(0),
-	current_attr(1)
-};
-
-static int motorcontrol_probe(struct usb_interface *intf, const struct usb_device_id *id)
-{
-	struct usb_device *dev = interface_to_usbdev(intf);
-	struct usb_host_interface *interface;
-	struct usb_endpoint_descriptor *endpoint;
-	struct motorcontrol *mc;
-	int pipe, maxp, rc = -ENOMEM;
-	int bit, value, i;
-
-	interface = intf->cur_altsetting;
-	if (interface->desc.bNumEndpoints != 1)
-		return -ENODEV;
-
-	endpoint = &interface->endpoint[0].desc;
-	if (!usb_endpoint_dir_in(endpoint))
-		return -ENODEV;
-
-	/*
-	 * bmAttributes
-	 */
-	pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
-	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
-
-	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
-	if (!mc)
-		goto out;
-
-	mc->dev_no = -1;
-	mc->data = usb_buffer_alloc(dev, URB_INT_SIZE, GFP_ATOMIC, &mc->data_dma);
-	if (!mc->data)
-		goto out;
-
-	mc->irq = usb_alloc_urb(0, GFP_KERNEL);
-	if (!mc->irq)
-		goto out;
-
-	mc->udev = usb_get_dev(dev);
-	mc->intf = intf;
-	mc->acceleration[0] = mc->acceleration[1] = 10;
-	INIT_DELAYED_WORK(&mc->do_notify, do_notify);
-	usb_fill_int_urb(mc->irq, mc->udev, pipe, mc->data,
-			maxp > URB_INT_SIZE ? URB_INT_SIZE : maxp,
-			motorcontrol_irq, mc, endpoint->bInterval);
-	mc->irq->transfer_dma = mc->data_dma;
-	mc->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-
-	usb_set_intfdata(intf, mc);
-
-	do {
-		bit = find_first_zero_bit(&device_no, sizeof(device_no));
-		value = test_and_set_bit(bit, &device_no);
-	} while(value);
-	mc->dev_no = bit;
-
-	mc->dev = device_create(phidget_class, &mc->udev->dev, MKDEV(0, 0), mc,
-				"motorcontrol%d", mc->dev_no);
-	if (IS_ERR(mc->dev)) {
-		rc = PTR_ERR(mc->dev);
-		mc->dev = NULL;
-		goto out;
-	}
-
-	if (usb_submit_urb(mc->irq, GFP_KERNEL)) {
-		rc = -EIO;
-		goto out;
-	}
-
-	for (i=0; i<ARRAY_SIZE(dev_attrs); i++) {
-		rc = device_create_file(mc->dev, &dev_attrs[i]);
-		if (rc)
-			goto out2;
-	}
-
-	dev_info(&intf->dev, "USB PhidgetMotorControl attached\n");
-
-	return 0;
-out2:
-	while (i-- > 0)
-		device_remove_file(mc->dev, &dev_attrs[i]);
-out:
-	if (mc) {
-		usb_free_urb(mc->irq);
-		if (mc->data)
-			usb_buffer_free(dev, URB_INT_SIZE, mc->data, mc->data_dma);
-		if (mc->dev)
-			device_unregister(mc->dev);
-		if (mc->dev_no >= 0)
-			clear_bit(mc->dev_no, &device_no);
-
-		kfree(mc);
-	}
-
-	return rc;
-}
-
-static void motorcontrol_disconnect(struct usb_interface *interface)
-{
-	struct motorcontrol *mc;
-	int i;
-
-	mc = usb_get_intfdata(interface);
-	usb_set_intfdata(interface, NULL);
-	if (!mc)
-		return;
-
-	usb_kill_urb(mc->irq);
-	usb_free_urb(mc->irq);
-	usb_buffer_free(mc->udev, URB_INT_SIZE, mc->data, mc->data_dma);
-
-	cancel_delayed_work(&mc->do_notify);
-
-	for (i=0; i<ARRAY_SIZE(dev_attrs); i++)
-		device_remove_file(mc->dev, &dev_attrs[i]);
-
-	device_unregister(mc->dev);
-
-	usb_put_dev(mc->udev);
-	clear_bit(mc->dev_no, &device_no);
-	kfree(mc);
-
-	dev_info(&interface->dev, "USB PhidgetMotorControl detached\n");
-}
-
-static struct usb_driver motorcontrol_driver = {
-	.name = "phidgetmotorcontrol",
-	.probe = motorcontrol_probe,
-	.disconnect = motorcontrol_disconnect,
-	.id_table = id_table
-};
-
-static int __init motorcontrol_init(void)
-{
-	int retval = 0;
-
-	retval = usb_register(&motorcontrol_driver);
-	if (retval)
-		err("usb_register failed. Error number %d", retval);
-
-	return retval;
-}
-
-static void __exit motorcontrol_exit(void)
-{
-	usb_deregister(&motorcontrol_driver);
-}
-
-module_init(motorcontrol_init);
-module_exit(motorcontrol_exit);
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
--- a/drivers/usb/misc/phidgetservo.c
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * USB PhidgetServo driver 1.0
- *
- * Copyright (C) 2004, 2006 Sean Young <sean@mess.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This is a driver for the USB PhidgetServo version 2.0 and 3.0 servo 
- * controllers available at: http://www.phidgets.com/ 
- *
- * Note that the driver takes input as: degrees.minutes
- *
- * CAUTION: Generally you should use 0 < degrees < 180 as anything else
- * is probably beyond the range of your servo and may damage it.
- */
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/usb.h>
-
-#include "phidget.h"
-
-#define DRIVER_AUTHOR "Sean Young <sean@mess.org>"
-#define DRIVER_DESC "USB PhidgetServo Driver"
-
-#define VENDOR_ID_GLAB				0x06c2
-#define DEVICE_ID_GLAB_PHIDGETSERVO_QUAD	0x0038
-#define DEVICE_ID_GLAB_PHIDGETSERVO_UNI		0x0039
-
-#define VENDOR_ID_WISEGROUP			0x0925
-#define VENDOR_ID_WISEGROUP_PHIDGETSERVO_QUAD	0x8101
-#define VENDOR_ID_WISEGROUP_PHIDGETSERVO_UNI	0x8104
-
-#define SERVO_VERSION_30			0x01
-#define SERVO_COUNT_QUAD			0x02
-
-static struct usb_device_id id_table[] = {
-	{
-		USB_DEVICE(VENDOR_ID_GLAB, DEVICE_ID_GLAB_PHIDGETSERVO_QUAD), 
-		.driver_info = SERVO_VERSION_30 | SERVO_COUNT_QUAD 
-	},
-	{
-		USB_DEVICE(VENDOR_ID_GLAB, DEVICE_ID_GLAB_PHIDGETSERVO_UNI),
-		.driver_info = SERVO_VERSION_30 
-	},
-	{
-		USB_DEVICE(VENDOR_ID_WISEGROUP, 
-				VENDOR_ID_WISEGROUP_PHIDGETSERVO_QUAD),
-		.driver_info = SERVO_COUNT_QUAD 
-	},
-	{
-		USB_DEVICE(VENDOR_ID_WISEGROUP, 
-				VENDOR_ID_WISEGROUP_PHIDGETSERVO_UNI),
-		.driver_info = 0
-	},
-	{}
-};
-
-MODULE_DEVICE_TABLE(usb, id_table);
-
-static int unsigned long device_no;
-
-struct phidget_servo {
-	struct usb_device *udev;
-	struct device *dev;
-	int dev_no;
-	ulong type;
-	int pulse[4];
-	int degrees[4];
-	int minutes[4];
-};
-
-static int
-change_position_v30(struct phidget_servo *servo, int servo_no, int degrees, 
-								int minutes)
-{
-	int retval;
-	unsigned char *buffer;
-
-	if (degrees < -23 || degrees > 362)
-		return -EINVAL;
-
-	buffer = kmalloc(6, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&servo->udev->dev, "%s - out of memory\n",
-			__func__);
-		return -ENOMEM;
-	}
-
-	/*
-	 * pulse = 0 - 4095
-	 * angle = 0 - 180 degrees
-	 *
-	 * pulse = angle * 10.6 + 243.8	
-	 */
-	servo->pulse[servo_no] = ((degrees*60 + minutes)*106 + 2438*60)/600;	
-	servo->degrees[servo_no]= degrees;
-	servo->minutes[servo_no]= minutes;	
-
-	/* 
-	 * The PhidgetServo v3.0 is controlled by sending 6 bytes,
-	 * 4 * 12 bits for each servo.
-	 *
-	 * low = lower 8 bits pulse
-	 * high = higher 4 bits pulse
-	 *
-	 * offset     bits
-	 * +---+-----------------+
-	 * | 0 |      low 0      |
-	 * +---+--------+--------+
-	 * | 1 | high 1 | high 0 |
-	 * +---+--------+--------+
-	 * | 2 |      low 1      |
-	 * +---+-----------------+
-	 * | 3 |      low 2      |
-	 * +---+--------+--------+
-	 * | 4 | high 3 | high 2 |
-	 * +---+--------+--------+
-	 * | 5 |      low 3      |
-	 * +---+-----------------+
-	 */
-
-	buffer[0] = servo->pulse[0] & 0xff;
-	buffer[1] = (servo->pulse[0] >> 8 & 0x0f)
-	    | (servo->pulse[1] >> 4 & 0xf0);
-	buffer[2] = servo->pulse[1] & 0xff;
-	buffer[3] = servo->pulse[2] & 0xff;
-	buffer[4] = (servo->pulse[2] >> 8 & 0x0f)
-	    | (servo->pulse[3] >> 4 & 0xf0);
-	buffer[5] = servo->pulse[3] & 0xff;
-
-	dev_dbg(&servo->udev->dev,
-		"data: %02x %02x %02x %02x %02x %02x\n",
-		buffer[0], buffer[1], buffer[2],
-		buffer[3], buffer[4], buffer[5]);
-
-	retval = usb_control_msg(servo->udev,
-				 usb_sndctrlpipe(servo->udev, 0),
-				 0x09, 0x21, 0x0200, 0x0000, buffer, 6, 2000);
-
-	kfree(buffer);
-
-	return retval;
-}
-
-static int
-change_position_v20(struct phidget_servo *servo, int servo_no, int degrees,
-								int minutes)
-{
-	int retval;
-	unsigned char *buffer;
-
-	if (degrees < -23 || degrees > 278)
-		return -EINVAL;
-
-	buffer = kmalloc(2, GFP_KERNEL);
-	if (!buffer) {
-		dev_err(&servo->udev->dev, "%s - out of memory\n",
-			__func__);
-		return -ENOMEM;
-	}
-
-	/*
-	 * angle = 0 - 180 degrees
-	 * pulse = angle + 23
-	 */
-	servo->pulse[servo_no]= degrees + 23;
-	servo->degrees[servo_no]= degrees;
-	servo->minutes[servo_no]= 0;
-
-	/*
-	 * The PhidgetServo v2.0 is controlled by sending two bytes. The
-	 * first byte is the servo number xor'ed with 2:
-	 *
-	 * servo 0 = 2
-	 * servo 1 = 3
-	 * servo 2 = 0
-	 * servo 3 = 1
-	 *
-	 * The second byte is the position.
-	 */
-
-	buffer[0] = servo_no ^ 2;
-	buffer[1] = servo->pulse[servo_no];
-
-	dev_dbg(&servo->udev->dev, "data: %02x %02x\n", buffer[0], buffer[1]);
-
-	retval = usb_control_msg(servo->udev,
-				 usb_sndctrlpipe(servo->udev, 0),
-				 0x09, 0x21, 0x0200, 0x0000, buffer, 2, 2000);
-
-	kfree(buffer);
-
-	return retval;
-}
-
-#define show_set(value)	\
-static ssize_t set_servo##value (struct device *dev, 			\
-					struct device_attribute *attr,	\
-					const char *buf, size_t count)	\
-{									\
-	int degrees, minutes, retval;					\
-	struct phidget_servo *servo = dev_get_drvdata(dev);		\
-									\
-	minutes = 0;							\
-	/* must at least convert degrees */				\
-	if (sscanf(buf, "%d.%d", &degrees, &minutes) < 1) {		\
-		return -EINVAL;						\
-	}								\
-									\
-	if (minutes < 0 || minutes > 59) 				\
-		return -EINVAL;						\
-									\
-	if (servo->type & SERVO_VERSION_30)				\
-		retval = change_position_v30(servo, value, degrees, 	\
-							minutes);	\
-	else 								\
-		retval = change_position_v20(servo, value, degrees, 	\
-							minutes);	\
-									\
-	return retval < 0 ? retval : count;				\
-}									\
-									\
-static ssize_t show_servo##value (struct device *dev,			\
-					struct device_attribute *attr,	\
-					char *buf) 			\
-{									\
-	struct phidget_servo *servo = dev_get_drvdata(dev);		\
-									\
-	return sprintf(buf, "%d.%02d\n", servo->degrees[value],		\
-				servo->minutes[value]);			\
-}
-
-#define servo_attr(value)						\
-	__ATTR(servo##value, S_IWUGO | S_IRUGO,				\
-		show_servo##value, set_servo##value)
-show_set(0);
-show_set(1);
-show_set(2);
-show_set(3);
-
-static struct device_attribute dev_attrs[] = {
-	servo_attr(0), servo_attr(1), servo_attr(2), servo_attr(3)
-};
-
-static int
-servo_probe(struct usb_interface *interface, const struct usb_device_id *id)
-{
-	struct usb_device *udev = interface_to_usbdev(interface);
-	struct phidget_servo *dev;
-	int bit, value, rc;
-	int servo_count, i;
-
-	dev = kzalloc(sizeof (struct phidget_servo), GFP_KERNEL);
-	if (dev == NULL) {
-		dev_err(&interface->dev, "%s - out of memory\n", __func__);
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	dev->udev = usb_get_dev(udev);
-	dev->type = id->driver_info;
-	dev->dev_no = -1;
-	usb_set_intfdata(interface, dev);
-
-        do {
-                bit = find_first_zero_bit(&device_no, sizeof(device_no));
-                value = test_and_set_bit(bit, &device_no);
-        } while (value);
-	dev->dev_no = bit;
-
-	dev->dev = device_create(phidget_class, &dev->udev->dev, MKDEV(0, 0),
-				 dev, "servo%d", dev->dev_no);
-	if (IS_ERR(dev->dev)) {
-		rc = PTR_ERR(dev->dev);
-		dev->dev = NULL;
-		goto out;
-	}
-
-	servo_count = dev->type & SERVO_COUNT_QUAD ? 4 : 1;
-
-	for (i=0; i<servo_count; i++) {
-		rc = device_create_file(dev->dev, &dev_attrs[i]);
-		if (rc)
-			goto out2;
-	}
-
-	dev_info(&interface->dev, "USB %d-Motor PhidgetServo v%d.0 attached\n",
-		servo_count, dev->type & SERVO_VERSION_30 ? 3 : 2);
-
-	if (!(dev->type & SERVO_VERSION_30))
-		dev_info(&interface->dev,
-			 "WARNING: v2.0 not tested! Please report if it works.\n");
-
-	return 0;
-out2:
-	while (i-- > 0)
-		device_remove_file(dev->dev, &dev_attrs[i]);
-out:
-	if (dev) {
-		if (dev->dev)
-			device_unregister(dev->dev);
-		if (dev->dev_no >= 0)
-			clear_bit(dev->dev_no, &device_no);
-
-		kfree(dev);
-	}
-
-	return rc;
-}
-
-static void
-servo_disconnect(struct usb_interface *interface)
-{
-	struct phidget_servo *dev;
-	int servo_count, i;
-
-	dev = usb_get_intfdata(interface);
-	usb_set_intfdata(interface, NULL);
-
-	if (!dev)
-		return;
-
-	servo_count = dev->type & SERVO_COUNT_QUAD ? 4 : 1;
-
-	for (i=0; i<servo_count; i++)
-		device_remove_file(dev->dev, &dev_attrs[i]);
-
-	device_unregister(dev->dev);
-	usb_put_dev(dev->udev);
-
-	dev_info(&interface->dev, "USB %d-Motor PhidgetServo v%d.0 detached\n",
-		servo_count, dev->type & SERVO_VERSION_30 ? 3 : 2);
-
-	clear_bit(dev->dev_no, &device_no);
-	kfree(dev);
-}
-
-static struct usb_driver servo_driver = {
-	.name = "phidgetservo",
-	.probe = servo_probe,
-	.disconnect = servo_disconnect,
-	.id_table = id_table
-};
-
-static int __init
-phidget_servo_init(void)
-{
-	int retval;
-
-	retval = usb_register(&servo_driver);
-	if (retval)
-		err("usb_register failed. Error number %d", retval);
-
-	return retval;
-}
-
-static void __exit
-phidget_servo_exit(void)
-{
-	usb_deregister(&servo_driver);
-}
-
-module_init(phidget_servo_init);
-module_exit(phidget_servo_exit);
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
