From zaitcev@redhat.com Sat Apr 19 14:43:06 2008
From: Pete Zaitcev <zaitcev@redhat.com>
Date: Sat, 19 Apr 2008 14:42:49 -0700
Subject: ub: Ignore bad residue
To: greg@kroah.com
Cc: zaitcev@redhat.com, linux-usb@vger.kernel.org
Message-ID: <20080419144249.290f5689.zaitcev@redhat.com>


I hoped to continue to ignore this problem or use libusual, but these
days it's simpler to work around than to deal with it. Let's attempt to
use bad residue devices and hope that upper level integrity checks catch
any problems (e.g. please use sha1sum on your backups).

Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/block/ub.c |   22 ++++++++++++++--------
 1 file changed, 14 insertions(+), 8 deletions(-)

--- a/drivers/block/ub.c
+++ b/drivers/block/ub.c
@@ -319,6 +319,7 @@ struct ub_dev {
 	int openc;			/* protected by ub_lock! */
 					/* kref is too implicit for our taste */
 	int reset;			/* Reset is running */
+	int bad_resid;
 	unsigned int tagcnt;
 	char name[12];
 	struct usb_device *dev;
@@ -1265,14 +1266,19 @@ static void ub_scsi_urb_compl(struct ub_
 			return;
 		}
 
-		len = le32_to_cpu(bcs->Residue);
-		if (len != cmd->len - cmd->act_len) {
-			/*
-			 * It is all right to transfer less, the caller has
-			 * to check. But it's not all right if the device
-			 * counts disagree with our counts.
-			 */
-			goto Bad_End;
+		if (!sc->bad_resid) {
+			len = le32_to_cpu(bcs->Residue);
+			if (len != cmd->len - cmd->act_len) {
+				/*
+				 * Only start ignoring if this cmd ended well.
+				 */
+				if (cmd->len == cmd->act_len) {
+					printk(KERN_NOTICE "%s: "
+					    "bad residual %d of %d, ignoring\n",
+					    sc->name, len, cmd->len);
+					sc->bad_resid = 1;
+				}
+			}
 		}
 
 		switch (bcs->Status) {
