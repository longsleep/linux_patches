From mano@roarinelk.homelinux.net  Fri Jun 27 15:16:24 2008
From: Manuel Lauss <mano@roarinelk.homelinux.net>
Date: Mon, 23 Jun 2008 09:08:29 +0200
Subject: USB: Au1xxx-usb: clean up ohci/ehci bus glue sources.
To: linux-usb@vger.kernel.org
Message-ID: <20080623070829.GA20861@roarinelk.homelinux.net>
Content-Disposition: inline


From: Manuel Lauss <mano@roarinelk.homelinux.net>

- Fold multiple probe/remove callbacks into one function;
- minor style fixes, no functional changes.

Tested on Au1200.

Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
Cc: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/ehci-au1xxx.c |  276 ++++++++++++++++-------------------------
 drivers/usb/host/ohci-au1xxx.c |  268 ++++++++++++++-------------------------
 2 files changed, 210 insertions(+), 334 deletions(-)

--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -19,236 +19,179 @@
 #define USB_MCFG_RDCOMB   (1<<30)
 #define USB_MCFG_SSDEN    (1<<23)
 #define USB_MCFG_PHYPLLEN (1<<19)
+#define USB_MCFG_UCECLKEN (1<<18)
 #define USB_MCFG_EHCCLKEN (1<<17)
+#ifdef CONFIG_DMA_COHERENT
 #define USB_MCFG_UCAM     (1<<7)
+#else
+#define USB_MCFG_UCAM     (0)
+#endif
 #define USB_MCFG_EBMEN    (1<<3)
 #define USB_MCFG_EMEMEN   (1<<2)
 
-#define USBH_ENABLE_CE    (USB_MCFG_PHYPLLEN | USB_MCFG_EHCCLKEN)
+#define USBH_ENABLE_CE	(USB_MCFG_PHYPLLEN | USB_MCFG_EHCCLKEN)
+#define USBH_ENABLE_INIT (USB_MCFG_PFEN  | USB_MCFG_RDCOMB |	\
+			  USBH_ENABLE_CE | USB_MCFG_SSDEN  |	\
+			  USB_MCFG_UCAM  | USB_MCFG_EBMEN  |	\
+			  USB_MCFG_EMEMEN)
 
-#ifdef CONFIG_DMA_COHERENT
-#define USBH_ENABLE_INIT  (USBH_ENABLE_CE \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN | USB_MCFG_UCAM \
-                         | USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
-#else
-#define USBH_ENABLE_INIT  (USBH_ENABLE_CE \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN \
-                         | USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
-#endif
 #define USBH_DISABLE      (USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
 
 extern int usb_disabled(void);
 
-/*-------------------------------------------------------------------------*/
-
-static void au1xxx_start_ehc(struct platform_device *dev)
+static void au1xxx_start_ehc(void)
 {
-	pr_debug(__FILE__ ": starting Au1xxx EHCI USB Controller\n");
-
-	/* write HW defaults again in case Yamon cleared them */
-	if (au_readl(USB_HOST_CONFIG) == 0) {
-		au_writel(0x00d02000, USB_HOST_CONFIG);
-		au_readl(USB_HOST_CONFIG);
-		udelay(1000);
-	}
-	/* enable host controller */
-	au_writel(USBH_ENABLE_CE | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-	udelay(1000);
-	au_writel(USBH_ENABLE_INIT | au_readl(USB_HOST_CONFIG),
-		  USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
+	/* enable clock to EHCI block and HS PHY PLL*/
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_CE, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
 
-	pr_debug(__FILE__ ": Clock to USB host has been enabled\n");
+	/* enable EHCI mmio */
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_INIT, USB_HOST_CONFIG);
+	au_sync();
+	udelay(1000);
 }
 
-static void au1xxx_stop_ehc(struct platform_device *dev)
+static void au1xxx_stop_ehc(void)
 {
-	pr_debug(__FILE__ ": stopping Au1xxx EHCI USB Controller\n");
+	unsigned long c;
 
 	/* Disable mem */
-	au_writel(~USBH_DISABLE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
+	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_DISABLE, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
-	/* Disable clock */
-	au_writel(~USB_MCFG_EHCCLKEN & au_readl(USB_HOST_CONFIG),
-		  USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
+
+	/* Disable EHC clock. If the HS PHY is unused disable it too. */
+	c = au_readl(USB_HOST_CONFIG) & ~USB_MCFG_EHCCLKEN;
+	if (!(c & USB_MCFG_UCECLKEN))		/* UDC disabled? */
+		c &= ~USB_MCFG_PHYPLLEN;	/* yes: disable HS PHY PLL */
+	au_writel(c, USB_HOST_CONFIG);
+	au_sync();
 }
 
-/*-------------------------------------------------------------------------*/
+static const struct hc_driver ehci_au1xxx_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "Au1xxx EHCI",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
 
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
+	/*
+	 * basic lifecycle operations
+	 *
+	 * FIXME -- ehci_init() doesn't do enough here.
+	 * See ehci-ppc-soc for a complete implementation.
+	 */
+	.reset			= ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
 
-/**
- * usb_ehci_au1xxx_probe - initialize Au1xxx-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_ehci_au1xxx_probe(const struct hc_driver *driver,
-			  struct usb_hcd **hcd_out, struct platform_device *dev)
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+};
+
+static int ehci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
 {
-	int retval;
 	struct usb_hcd *hcd;
 	struct ehci_hcd *ehci;
+	int ret;
 
-#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
+	if (usb_disabled())
+		return -ENODEV;
 
+#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
 	/* Au1200 AB USB does not support coherent memory */
 	if (!(read_c0_prid() & 0xff)) {
-		pr_info("%s: this is chip revision AB!\n", dev->name);
-		pr_info("%s: update your board or re-configure the kernel\n",
-			dev->name);
+		printk(KERN_INFO "%s: this is chip revision AB!\n", pdev->name);
+		printk(KERN_INFO "%s: update your board or re-configure"
+				 " the kernel\n", pdev->name);
 		return -ENODEV;
 	}
 #endif
 
-	au1xxx_start_ehc(dev);
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
+	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
 		pr_debug("resource[1] is not IORESOURCE_IRQ");
-		retval = -ENOMEM;
+		return -ENOMEM;
 	}
-	hcd = usb_create_hcd(driver, &dev->dev, "Au1xxx");
+	hcd = usb_create_hcd(&ehci_au1xxx_hc_driver, &pdev->dev, "Au1xxx");
 	if (!hcd)
 		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
 
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
 		pr_debug("request_mem_region failed");
-		retval = -EBUSY;
+		ret = -EBUSY;
 		goto err1;
 	}
 
 	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
 	if (!hcd->regs) {
 		pr_debug("ioremap failed");
-		retval = -ENOMEM;
+		ret = -ENOMEM;
 		goto err2;
 	}
 
+	au1xxx_start_ehc();
+
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = hcd->regs;
 	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = readl(&ehci->caps->hcs_params);
 
-	/* ehci_hcd_init(hcd_to_ehci(hcd)); */
-
-	retval =
-	    usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED | IRQF_SHARED);
-	if (retval == 0)
-		return retval;
+	ret = usb_add_hcd(hcd, pdev->resource[1].start,
+			  IRQF_DISABLED | IRQF_SHARED);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, hcd);
+		return ret;
+	}
 
-	au1xxx_stop_ehc(dev);
+	au1xxx_stop_ehc();
 	iounmap(hcd->regs);
 err2:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 err1:
 	usb_put_hcd(hcd);
-	return retval;
+	return ret;
 }
 
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_ehci_hcd_au1xxx_remove - shutdown processing for Au1xxx-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_ehci_hcd_au1xxx_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_ehci_au1xxx_remove(struct usb_hcd *hcd, struct platform_device *dev)
+static int ehci_hcd_au1xxx_drv_remove(struct platform_device *pdev)
 {
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
 	usb_remove_hcd(hcd);
 	iounmap(hcd->regs);
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 	usb_put_hcd(hcd);
-	au1xxx_stop_ehc(dev);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ehci_au1xxx_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "Au1xxx EHCI",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 *
-	 * FIXME -- ehci_init() doesn't do enough here.
-	 * See ehci-ppc-soc for a complete implementation.
-	 */
-	.reset = ehci_init,
-	.start = ehci_run,
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
+	au1xxx_stop_ehc();
+	platform_set_drvdata(pdev, NULL);
 
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-	.bus_suspend = ehci_bus_suspend,
-	.bus_resume = ehci_bus_resume,
-	.relinquish_port = ehci_relinquish_port,
-	.port_handed_over = ehci_port_handed_over,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ehci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = NULL;
-	int ret;
-
-	pr_debug("In ehci_hcd_au1xxx_drv_probe\n");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	/* FIXME we only want one one probe() not two */
-	ret = usb_ehci_au1xxx_probe(&ehci_au1xxx_hc_driver, &hcd, pdev);
-	return ret;
-}
-
-static int ehci_hcd_au1xxx_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	/* FIXME we only want one one remove() not two */
-	usb_ehci_au1xxx_remove(hcd, pdev);
 	return 0;
 }
 
@@ -268,14 +211,17 @@ static int ehci_hcd_au1xxx_drv_resume(st
 	return 0;
 }
 */
-MODULE_ALIAS("platform:au1xxx-ehci");
+
 static struct platform_driver ehci_hcd_au1xxx_driver = {
-	.probe = ehci_hcd_au1xxx_drv_probe,
-	.remove = ehci_hcd_au1xxx_drv_remove,
-	.shutdown = usb_hcd_platform_shutdown,
+	.probe		= ehci_hcd_au1xxx_drv_probe,
+	.remove		= ehci_hcd_au1xxx_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
 	/*.suspend      = ehci_hcd_au1xxx_drv_suspend, */
 	/*.resume       = ehci_hcd_au1xxx_drv_resume, */
 	.driver = {
-		.name = "au1xxx-ehci",
+		.name	= "au1xxx-ehci",
+		.owner	= THIS_MODULE,
 	}
 };
+
+MODULE_ALIAS("platform:au1xxx-ehci");
--- a/drivers/usb/host/ohci-au1xxx.c
+++ b/drivers/usb/host/ohci-au1xxx.c
@@ -34,7 +34,8 @@
 #ifdef __LITTLE_ENDIAN
 #define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C)
 #elif __BIG_ENDIAN
-#define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C | USBH_ENABLE_BE)
+#define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C | \
+			  USBH_ENABLE_BE)
 #else
 #error not byte order defined
 #endif
@@ -46,213 +47,87 @@
 #define USB_MCFG_RDCOMB   (1<<30)
 #define USB_MCFG_SSDEN    (1<<23)
 #define USB_MCFG_OHCCLKEN (1<<16)
+#ifdef CONFIG_DMA_COHERENT
 #define USB_MCFG_UCAM     (1<<7)
+#else
+#define USB_MCFG_UCAM     (0)
+#endif
 #define USB_MCFG_OBMEN    (1<<1)
 #define USB_MCFG_OMEMEN   (1<<0)
 
 #define USBH_ENABLE_CE    USB_MCFG_OHCCLKEN
-#ifdef CONFIG_DMA_COHERENT
-#define USBH_ENABLE_INIT  (USB_MCFG_OHCCLKEN \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN | USB_MCFG_UCAM \
-                         | USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
-#else
-#define USBH_ENABLE_INIT  (USB_MCFG_OHCCLKEN \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN \
-                         | USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
-#endif
+
+#define USBH_ENABLE_INIT  (USB_MCFG_PFEN  | USB_MCFG_RDCOMB 	|	\
+			   USBH_ENABLE_CE | USB_MCFG_SSDEN	|	\
+			   USB_MCFG_UCAM  |				\
+			   USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
+
 #define USBH_DISABLE      (USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
 
 #endif  /* Au1200 */
 
 extern int usb_disabled(void);
 
-/*-------------------------------------------------------------------------*/
-
-static void au1xxx_start_ohc(struct platform_device *dev)
+static void au1xxx_start_ohc(void)
 {
-	printk(KERN_DEBUG __FILE__
-		": starting Au1xxx OHCI USB Controller\n");
-
 	/* enable host controller */
-
 #ifndef CONFIG_SOC_AU1200
-
 	au_writel(USBH_ENABLE_CE, USB_HOST_CONFIG);
-	udelay(1000);
-	au_writel(USBH_ENABLE_INIT, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
 
-#else   /* Au1200 */
-
-	/* write HW defaults again in case Yamon cleared them */
-	if (au_readl(USB_HOST_CONFIG) == 0) {
-		au_writel(0x00d02000, USB_HOST_CONFIG);
-		au_readl(USB_HOST_CONFIG);
-		udelay(1000);
-	}
-	au_writel(USBH_ENABLE_CE | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_INIT, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
-	au_writel(USBH_ENABLE_INIT | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-	udelay(1000);
-
-#endif  /* Au1200 */
 
-#ifndef CONFIG_SOC_AU1200
 	/* wait for reset complete (read register twice; see au1500 errata) */
 	while (au_readl(USB_HOST_CONFIG),
 		!(au_readl(USB_HOST_CONFIG) & USBH_ENABLE_RD))
-#endif
 		udelay(1000);
 
-	printk(KERN_DEBUG __FILE__
-	": Clock to USB host has been enabled \n");
-}
-
-static void au1xxx_stop_ohc(struct platform_device *dev)
-{
-	printk(KERN_DEBUG __FILE__
-	       ": stopping Au1xxx OHCI USB Controller\n");
-
-#ifndef CONFIG_SOC_AU1200
-
-	/* Disable clock */
-	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_ENABLE_CE, USB_HOST_CONFIG);
-
 #else   /* Au1200 */
-
-	/* Disable mem */
-	au_writel(~USBH_DISABLE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_CE, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
-	/* Disable clock */
-	au_writel(~USBH_ENABLE_CE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
+
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_INIT, USB_HOST_CONFIG);
+	au_sync();
+	udelay(2000);
 #endif  /* Au1200 */
 }
 
-
-/*-------------------------------------------------------------------------*/
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_ohci_au1xxx_probe - initialize Au1xxx-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-static int usb_ohci_au1xxx_probe(const struct hc_driver *driver,
-			  struct platform_device *dev)
+static void au1xxx_stop_ohc(void)
 {
-	int retval;
-	struct usb_hcd *hcd;
-
-#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
-	/* Au1200 AB USB does not support coherent memory */
-	if (!(read_c0_prid() & 0xff)) {
-		pr_info("%s: this is chip revision AB !!\n",
-			dev->name);
-		pr_info("%s: update your board or re-configure the kernel\n",
-			dev->name);
-		return -ENODEV;
-	}
+#ifdef CONFIG_SOC_AU1200
+	/* Disable mem */
+	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_DISABLE, USB_HOST_CONFIG);
+	au_sync();
+	udelay(1000);
 #endif
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug("resource[1] is not IORESOURCE_IRQ\n");
-		return -ENOMEM;
-	}
-
-	hcd = usb_create_hcd(driver, &dev->dev, "au1xxx");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed\n");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed\n");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	au1xxx_start_ohc(dev);
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED | IRQF_SHARED);
-	if (retval == 0)
-		return retval;
-
-	au1xxx_stop_ohc(dev);
-	iounmap(hcd->regs);
- err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_au1xxx_remove - shutdown processing for Au1xxx-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_au1xxx_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-static void usb_ohci_au1xxx_remove(struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	au1xxx_stop_ohc(dev);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
+	/* Disable clock */
+	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_ENABLE_CE, USB_HOST_CONFIG);
+	au_sync();
 }
 
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_au1xxx_start (struct usb_hcd *hcd)
+static int __devinit ohci_au1xxx_start(struct usb_hcd *hcd)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int ret;
 
-	ohci_dbg (ohci, "ohci_au1xxx_start, ohci:%p", ohci);
+	ohci_dbg(ohci, "ohci_au1xxx_start, ohci:%p", ohci);
 
-	if ((ret = ohci_init (ohci)) < 0)
+	if ((ret = ohci_init(ohci)) < 0)
 		return ret;
 
-	if ((ret = ohci_run (ohci)) < 0) {
+	if ((ret = ohci_run(ohci)) < 0) {
 		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
+		ohci_stop(hcd);
 		return ret;
 	}
 
 	return 0;
 }
 
-/*-------------------------------------------------------------------------*/
-
 static const struct hc_driver ohci_au1xxx_hc_driver = {
 	.description =		hcd_name,
 	.product_desc =		"Au1xxx OHCI",
@@ -295,18 +170,66 @@ static const struct hc_driver ohci_au1xx
 	.start_port_reset =	ohci_start_port_reset,
 };
 
-/*-------------------------------------------------------------------------*/
-
 static int ohci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
 {
 	int ret;
-
-	pr_debug ("In ohci_hcd_au1xxx_drv_probe");
+	struct usb_hcd *hcd;
 
 	if (usb_disabled())
 		return -ENODEV;
 
-	ret = usb_ohci_au1xxx_probe(&ohci_au1xxx_hc_driver, pdev);
+#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
+	/* Au1200 AB USB does not support coherent memory */
+	if (!(read_c0_prid() & 0xff)) {
+		printk(KERN_INFO "%s: this is chip revision AB !!\n",
+			pdev->name);
+		printk(KERN_INFO "%s: update your board or re-configure "
+				 "the kernel\n", pdev->name);
+		return -ENODEV;
+	}
+#endif
+
+	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
+		pr_debug("resource[1] is not IORESOURCE_IRQ\n");
+		return -ENOMEM;
+	}
+
+	hcd = usb_create_hcd(&ohci_au1xxx_hc_driver, &pdev->dev, "au1xxx");
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	au1xxx_start_ohc();
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	ret = usb_add_hcd(hcd, pdev->resource[1].start,
+			  IRQF_DISABLED | IRQF_SHARED);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, hcd);
+		return ret;
+	}
+
+	au1xxx_stop_ohc();
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
 	return ret;
 }
 
@@ -314,9 +237,16 @@ static int ohci_hcd_au1xxx_drv_remove(st
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
-	usb_ohci_au1xxx_remove(hcd, pdev);
+	usb_remove_hcd(hcd);
+	au1xxx_stop_ohc();
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	platform_set_drvdata(pdev, NULL);
+
 	return 0;
 }
+
 	/*TBD*/
 /*static int ohci_hcd_au1xxx_drv_suspend(struct platform_device *dev)
 {
