From foo@baz Mon May 17 10:33:41 PDT 2010
Date: Mon, 17 May 2010 10:33:41 -0700
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: USB: io_edgeport: checkpatch cleanups

Minor whitespace cleanups to make checkpatch happy.

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/usb/serial/io_edgeport.h |   16 +++---
 drivers/usb/serial/io_ionsp.h    |   97 +++++++++++++++++++--------------------
 drivers/usb/serial/io_ti.h       |   92 +++++++++++++++++++-----------------
 drivers/usb/serial/io_usbvend.h  |   87 +++++++++++++++-------------------
 4 files changed, 144 insertions(+), 148 deletions(-)

--- a/drivers/usb/serial/io_edgeport.h
+++ b/drivers/usb/serial/io_edgeport.h
@@ -34,15 +34,15 @@
 
 
 
-/* The following table is used to map the USBx port number to 
+/* The following table is used to map the USBx port number to
  * the device serial number (or physical USB path), */
 #define MAX_EDGEPORTS	64
 
 struct comMapper {
 	char	SerialNumber[MAX_SERIALNUMBER_LEN+1];	/* Serial number/usb path */
-	int	numPorts;			       	/* Number of ports */
-	int	Original[MAX_RS232_PORTS];	       	/* Port numbers set by IOCTL */
-	int	Port[MAX_RS232_PORTS];		       	/* Actual used port numbers */
+	int	numPorts;				/* Number of ports */
+	int	Original[MAX_RS232_PORTS];		/* Port numbers set by IOCTL */
+	int	Port[MAX_RS232_PORTS];			/* Actual used port numbers */
 };
 
 
@@ -51,7 +51,7 @@ struct comMapper {
 /* /proc/edgeport Interface
  * This interface uses read/write/lseek interface to talk to the edgeport driver
  * the following read functions are supported: */
-#define PROC_GET_MAPPING_TO_PATH 	1
+#define PROC_GET_MAPPING_TO_PATH	1
 #define PROC_GET_COM_ENTRY		2
 #define PROC_GET_EDGE_MANUF_DESCRIPTOR	3
 #define PROC_GET_BOOT_DESCRIPTOR	4
@@ -64,7 +64,7 @@ struct comMapper {
 
 
 /* the following write functions are supported: */
-#define PROC_SET_COM_MAPPING 		1
+#define PROC_SET_COM_MAPPING		1
 #define PROC_SET_COM_ENTRY		2
 
 
@@ -97,8 +97,8 @@ struct edgeport_product_info {
 	__u8	BoardRev;			/* PCB revision level (chg only if s/w visible) */
 
 	__u8	BootMajorVersion;		/* Boot Firmware version: xx. */
-	__u8	BootMinorVersion;		/*	   		  yy. */
-	__le16	BootBuildNumber;		/*		      	  zzzz (LE format) */
+	__u8	BootMinorVersion;		/*			  yy. */
+	__le16	BootBuildNumber;		/*			  zzzz (LE format) */
 
 	__u8	FirmwareMajorVersion;		/* Operational Firmware version:xx. */
 	__u8	FirmwareMinorVersion;		/*				yy. */
--- a/drivers/usb/serial/io_ionsp.h
+++ b/drivers/usb/serial/io_ionsp.h
@@ -89,10 +89,10 @@ All 16-bit fields are sent in little-end
 //
 
 struct int_status_pkt {
-	__u16      RxBytesAvail;		    // Additional bytes available to
-						    // be read from Bulk IN pipe
-	__u16      TxCredits[ MAX_RS232_PORTS ];   // Additional space available in
-						    // given port's TxBuffer
+	__u16 RxBytesAvail;			// Additional bytes available to
+						// be read from Bulk IN pipe
+	__u16 TxCredits[MAX_RS232_PORTS];	// Additional space available in
+						// given port's TxBuffer
 };
 
 
@@ -115,24 +115,24 @@ struct int_status_pkt {
 #define	IOSP_CMD_STAT_BIT		0x80		// If set, this is command/status header
 
 #define IS_CMD_STAT_HDR(Byte1)		((Byte1) & IOSP_CMD_STAT_BIT)
-#define IS_DATA_HDR(Byte1)		(! IS_CMD_STAT_HDR(Byte1))
+#define IS_DATA_HDR(Byte1)		(!IS_CMD_STAT_HDR(Byte1))
 
 #define	IOSP_GET_HDR_PORT(Byte1)		((__u8) ((Byte1) & IOSP_PORT_MASK))
-#define	IOSP_GET_HDR_DATA_LEN(Byte1, Byte2)	((__u16) ( ((__u16)((Byte1) & 0x78)) << 5) | (Byte2))
+#define	IOSP_GET_HDR_DATA_LEN(Byte1, Byte2)	((__u16) (((__u16)((Byte1) & 0x78)) << 5) | (Byte2))
 #define	IOSP_GET_STATUS_CODE(Byte1)		((__u8) (((Byte1) &  0x78) >> 3))
 
 
 //
 // These macros build the 1st and 2nd bytes for a data header
 //
-#define	IOSP_BUILD_DATA_HDR1(Port, Len)		((__u8) (((Port) | ((__u8) (((__u16) (Len)) >> 5) & 0x78 ))))
+#define	IOSP_BUILD_DATA_HDR1(Port, Len)		((__u8) (((Port) | ((__u8) (((__u16) (Len)) >> 5) & 0x78))))
 #define	IOSP_BUILD_DATA_HDR2(Port, Len)		((__u8) (Len))
 
 
 //
 // These macros build the 1st and 2nd bytes for a command header
 //
-#define	IOSP_BUILD_CMD_HDR1(Port, Cmd)		((__u8) ( IOSP_CMD_STAT_BIT | (Port) |	((__u8) ((Cmd) << 3)) ))
+#define	IOSP_BUILD_CMD_HDR1(Port, Cmd)		((__u8) (IOSP_CMD_STAT_BIT | (Port) | ((__u8) ((Cmd) << 3))))
 
 
 //--------------------------------------------------------------
@@ -194,24 +194,25 @@ struct int_status_pkt {
 // Define macros to simplify building of IOSP cmds
 //
 
-#define	MAKE_CMD_WRITE_REG(ppBuf, pLen, Port, Reg, Val)						\
-	do {											\
-		(*(ppBuf))[0] = IOSP_BUILD_CMD_HDR1( (Port), IOSP_WRITE_UART_REG(Reg) );	\
-		(*(ppBuf))[1] = (Val);								\
-												\
-		*ppBuf += 2;									\
-		*pLen  += 2;									\
-	} while (0)
-
-#define	MAKE_CMD_EXT_CMD(ppBuf, pLen, Port, ExtCmd, Param)					\
-	do {											\
-		(*(ppBuf))[0] = IOSP_BUILD_CMD_HDR1( (Port), IOSP_EXT_CMD );			\
-		(*(ppBuf))[1] = (ExtCmd);							\
-		(*(ppBuf))[2] = (Param);							\
-												\
-		*ppBuf += 3;									\
-		*pLen  += 3;									\
-	} while (0)
+#define MAKE_CMD_WRITE_REG(ppBuf, pLen, Port, Reg, Val)			\
+do {									\
+	(*(ppBuf))[0] = IOSP_BUILD_CMD_HDR1((Port),			\
+					    IOSP_WRITE_UART_REG(Reg));	\
+	(*(ppBuf))[1] = (Val);						\
+									\
+	*ppBuf += 2;							\
+	*pLen  += 2;							\
+} while (0)
+
+#define MAKE_CMD_EXT_CMD(ppBuf, pLen, Port, ExtCmd, Param)		\
+do {									\
+	(*(ppBuf))[0] = IOSP_BUILD_CMD_HDR1((Port), IOSP_EXT_CMD);	\
+	(*(ppBuf))[1] = (ExtCmd);					\
+	(*(ppBuf))[2] = (Param);					\
+									\
+	*ppBuf += 3;							\
+	*pLen  += 3;							\
+} while (0)
 
 
 
@@ -310,16 +311,16 @@ struct int_status_pkt {
 //
 //	IOSP_CMD_RX_CHECK_REQ
 //
-//  This command is used to assist in the implementation of the 
-//  IOCTL_SERIAL_PURGE Windows IOCTL.  
-//  This IOSP command tries to place a marker at the end of the RX 
-//  queue in the Edgeport. If the Edgeport RX queue is full then 
-//  the Check will be discarded.  
-//  It is up to the device driver to timeout waiting for the 
-//  RX_CHECK_RSP.  If a RX_CHECK_RSP is received, the driver is 
-//	sure that all data has been received from the edgeport and 
+//  This command is used to assist in the implementation of the
+//  IOCTL_SERIAL_PURGE Windows IOCTL.
+//  This IOSP command tries to place a marker at the end of the RX
+//  queue in the Edgeport. If the Edgeport RX queue is full then
+//  the Check will be discarded.
+//  It is up to the device driver to timeout waiting for the
+//  RX_CHECK_RSP.  If a RX_CHECK_RSP is received, the driver is
+//	sure that all data has been received from the edgeport and
 //	may now purge any internal RX buffers.
-//  Note tat the sequence numbers may be used to detect lost 
+//  Note tat the sequence numbers may be used to detect lost
 //  CHECK_REQs.
 
 //  Example for Port 0
@@ -341,7 +342,7 @@ struct int_status_pkt {
 //
 //	1ssssPPP P1P1P1P1 [ P2P2P2P2P2 ]...
 //
-// 	ssss:	00-07	2-byte status.	ssss identifies which UART register
+//	ssss:	00-07	2-byte status.	ssss identifies which UART register
 //					has changed value, and the new value is in P1.
 //					Note that the ssss values do not correspond to the
 //					16554 register numbers given in 16554.H. Instead,
@@ -383,14 +384,14 @@ struct int_status_pkt {
 // returns this in order to report
 // changes in modem status lines
 // (CTS, DSR, RI, CD)
-// 
+//
 
 //					0x02	// Available for future expansion
-//					0x03	// 
-//					0x04	// 
-//					0x05	// 
-//					0x06	// 
-//					0x07	// 
+//					0x03	//
+//					0x04	//
+//					0x05	//
+//					0x06	//
+//					0x07	//
 
 
 /****************************************************
@@ -400,7 +401,7 @@ struct int_status_pkt {
 #define	IOSP_STATUS_LSR_DATA		0x08	// P1 is new value of LSR register (same as STATUS_LSR)
 
 // P2 is errored character read from
-//    RxFIFO after LSR reported an error.													
+//    RxFIFO after LSR reported an error.
 
 #define	IOSP_EXT_STATUS			0x09	// P1 is status/response code, param in P2.
 
@@ -408,7 +409,7 @@ struct int_status_pkt {
 // Response Codes (P1 values) for 3-byte status messages
 
 #define	IOSP_EXT_STATUS_CHASE_RSP	0	// Reply to CHASE_PORT cmd. P2 is outcome:
-#define	IOSP_EXT_STATUS_CHASE_PASS	0	// 	P2 = 0: All Tx data drained successfully
+#define	IOSP_EXT_STATUS_CHASE_PASS	0	//	P2 = 0: All Tx data drained successfully
 #define	IOSP_EXT_STATUS_CHASE_FAIL	1	//	P2 = 1: Timed out (stuck due to flow
 
 //			control from remote device).
@@ -446,9 +447,9 @@ struct int_status_pkt {
 // Macros to parse status messages
 //
 
-#define	IOSP_GET_STATUS_LEN(code)	( (code) < 8 ? 2 : ((code) < 0x0A ? 3 : 4) )
+#define	IOSP_GET_STATUS_LEN(code)	((code) < 8 ? 2 : ((code) < 0x0A ? 3 : 4))
 
-#define	IOSP_STATUS_IS_2BYTE(code)	( (code) < 0x08 )
-#define	IOSP_STATUS_IS_3BYTE(code)	( ((code) >= 0x08) && ((code) <= 0x0B) )
-#define	IOSP_STATUS_IS_4BYTE(code)	( ((code) >= 0x0C) && ((code) <= 0x0D) )
+#define	IOSP_STATUS_IS_2BYTE(code)	((code) < 0x08)
+#define	IOSP_STATUS_IS_3BYTE(code)	(((code) >= 0x08) && ((code) <= 0x0B))
+#define	IOSP_STATUS_IS_4BYTE(code)	(((code) >= 0x0C) && ((code) <= 0x0D))
 
--- a/drivers/usb/serial/io_ti.h
+++ b/drivers/usb/serial/io_ti.h
@@ -1,4 +1,4 @@
-/*****************************************************************************  
+/*****************************************************************************
  *
  *	Copyright (C) 1997-2002 Inside Out Networks, Inc.
  *
@@ -22,10 +22,10 @@
 #define DTK_ADDR_SPACE_I2C_TYPE_II	0x82	/* Addr is placed in I2C area */
 #define DTK_ADDR_SPACE_I2C_TYPE_III	0x83	/* Addr is placed in I2C area */
 
-// UART Defines
-#define UMPMEM_BASE_UART1		0xFFA0  /* UMP UART1 base address          */
-#define UMPMEM_BASE_UART2		0xFFB0  /* UMP UART2 base address          */
-#define UMPMEM_OFFS_UART_LSR		0x05    /* UMP UART LSR register offset    */
+/* UART Defines */
+#define UMPMEM_BASE_UART1		0xFFA0	/* UMP UART1 base address */
+#define UMPMEM_BASE_UART2		0xFFB0	/* UMP UART2 base address */
+#define UMPMEM_OFFS_UART_LSR		0x05	/* UMP UART LSR register offset */
 
 /* Bits per character */
 #define UMP_UART_CHAR5BITS		0x00
@@ -54,7 +54,7 @@
 #define UMP_UART_LSR_RX_MASK		0x10
 #define UMP_UART_LSR_TX_MASK		0x20
 
-#define UMP_UART_LSR_DATA_MASK		( LSR_PAR_ERR | LSR_FRM_ERR | LSR_BREAK )
+#define UMP_UART_LSR_DATA_MASK		(LSR_PAR_ERR | LSR_FRM_ERR | LSR_BREAK)
 
 /* Port Settings Constants) */
 #define UMP_MASK_UART_FLAGS_RTS_FLOW		0x0001
@@ -79,50 +79,57 @@
 #define UMP_PORT_DIR_OUT			0x01
 #define UMP_PORT_DIR_IN				0x02
 
-// Address of Port 0
-#define UMPM_UART1_PORT  			0x03
+/* Address of Port 0 */
+#define UMPM_UART1_PORT				0x03
 
-// Commands
-#define	UMPC_SET_CONFIG 		0x05
-#define	UMPC_OPEN_PORT  		0x06
-#define	UMPC_CLOSE_PORT 		0x07
-#define	UMPC_START_PORT 		0x08
-#define	UMPC_STOP_PORT  		0x09
-#define	UMPC_TEST_PORT  		0x0A
-#define	UMPC_PURGE_PORT 		0x0B
-
-#define	UMPC_COMPLETE_READ		0x80	// Force the Firmware to complete the current Read
-#define	UMPC_HARDWARE_RESET		0x81	// Force UMP back into BOOT Mode
-#define	UMPC_COPY_DNLD_TO_I2C		0x82	// Copy current download image to type 0xf2 record in 16k I2C
-						// firmware will change 0xff record to type 2 record when complete
-
-	// Special function register commands
-	// wIndex is register address
-	// wValue is MSB/LSB mask/data
-#define	UMPC_WRITE_SFR	  		0x83	// Write SFR Register
+/* Commands */
+#define	UMPC_SET_CONFIG			0x05
+#define	UMPC_OPEN_PORT			0x06
+#define	UMPC_CLOSE_PORT			0x07
+#define	UMPC_START_PORT			0x08
+#define	UMPC_STOP_PORT			0x09
+#define	UMPC_TEST_PORT			0x0A
+#define	UMPC_PURGE_PORT			0x0B
+
+/* Force the Firmware to complete the current Read */
+#define	UMPC_COMPLETE_READ		0x80
+/* Force UMP back into BOOT Mode */
+#define	UMPC_HARDWARE_RESET		0x81
+/*
+ * Copy current download image to type 0xf2 record in 16k I2C
+ * firmware will change 0xff record to type 2 record when complete
+ */
+#define	UMPC_COPY_DNLD_TO_I2C		0x82
+
+/*
+ * Special function register commands
+ * wIndex is register address
+ * wValue is MSB/LSB mask/data
+ */
+#define	UMPC_WRITE_SFR			0x83	/* Write SFR Register */
 
-	// wIndex is register address
-#define	UMPC_READ_SFR	  		0x84	// Read SRF Register
+/* wIndex is register address */
+#define	UMPC_READ_SFR			0x84	/* Read SRF Register */
 
-	// Set or Clear DTR (wValue bit 0 Set/Clear)		wIndex ModuleID (port)
+/* Set or Clear DTR (wValue bit 0 Set/Clear)	wIndex ModuleID (port) */
 #define	UMPC_SET_CLR_DTR		0x85
 
-	// Set or Clear RTS (wValue bit 0 Set/Clear)		wIndex ModuleID (port)
+/* Set or Clear RTS (wValue bit 0 Set/Clear)	wIndex ModuleID (port) */
 #define	UMPC_SET_CLR_RTS		0x86
 
-	// Set or Clear LOOPBACK (wValue bit 0 Set/Clear)	wIndex ModuleID (port)
+/* Set or Clear LOOPBACK (wValue bit 0 Set/Clear) wIndex ModuleID (port) */
 #define	UMPC_SET_CLR_LOOPBACK		0x87
 
-	// Set or Clear BREAK (wValue bit 0 Set/Clear)		wIndex ModuleID (port)
+/* Set or Clear BREAK (wValue bit 0 Set/Clear)	wIndex ModuleID (port) */
 #define	UMPC_SET_CLR_BREAK		0x88
 
-	// Read MSR wIndex ModuleID (port)
+/* Read MSR wIndex ModuleID (port) */
 #define	UMPC_READ_MSR			0x89
 
-	/* Toolkit commands */
-	/* Read-write group */
-#define	UMPC_MEMORY_READ   		0x92
-#define	UMPC_MEMORY_WRITE  		0x93
+/* Toolkit commands */
+/* Read-write group */
+#define	UMPC_MEMORY_READ		0x92
+#define	UMPC_MEMORY_WRITE		0x93
 
 /*
  *	UMP DMA Definitions
@@ -130,8 +137,7 @@
 #define UMPD_OEDB1_ADDRESS		0xFF08
 #define UMPD_OEDB2_ADDRESS		0xFF10
 
-struct out_endpoint_desc_block
-{
+struct out_endpoint_desc_block {
 	__u8 Configuration;
 	__u8 XBufAddr;
 	__u8 XByteCount;
@@ -147,8 +153,8 @@ struct out_endpoint_desc_block
  * TYPE DEFINITIONS
  * Structures for Firmware commands
  */
-struct ump_uart_config		/* UART settings                    */
-{
+/* UART settings */
+struct ump_uart_config {
 	__u16 wBaudRate;	/* Baud rate                        */
 	__u16 wFlags;		/* Bitmap mask of flags             */
 	__u8 bDataBits;		/* 5..8 - data bits per character   */
@@ -165,8 +171,8 @@ struct ump_uart_config		/* UART settings
  * TYPE DEFINITIONS
  * Structures for USB interrupts
  */
-struct ump_interrupt			/* Interrupt packet structure       */
-{
+/* Interrupt packet structure */
+struct ump_interrupt {
 	__u8 bICode;			/* Interrupt code (interrupt num)   */
 	__u8 bIInfo;			/* Interrupt information            */
 }  __attribute__((packed));
--- a/drivers/usb/serial/io_usbvend.h
+++ b/drivers/usb/serial/io_usbvend.h
@@ -26,7 +26,7 @@
 
 //
 // Definitions of USB product IDs
-// 
+//
 
 #define	USB_VENDOR_ID_ION	0x1608		// Our VID
 #define	USB_VENDOR_ID_TI	0x0451		// TI VID
@@ -54,7 +54,7 @@
 // Product IDs - assigned to match middle digit of serial number (No longer true)
 
 #define ION_DEVICE_ID_80251_NETCHIP	0x020	// This bit is set in the PID if this edgeport hardware$
-						// is based on the 80251+Netchip.  
+						// is based on the 80251+Netchip.
 
 #define ION_DEVICE_ID_GENERATION_1	0x00	// Value for 930 based edgeports
 #define ION_DEVICE_ID_GENERATION_2	0x01	// Value for 80251+Netchip.
@@ -134,7 +134,7 @@
 #define ION_DEVICE_ID_TI_EDGEPORT_416		0x0212  // Edgeport/416
 #define ION_DEVICE_ID_TI_EDGEPORT_1		0x0215	// Edgeport/1 RS232
 #define ION_DEVICE_ID_TI_EDGEPORT_42		0x0217	// Edgeport/42 4 hub 2 RS232
-#define ION_DEVICE_ID_TI_EDGEPORT_22I  		0x021A	// Edgeport/22I is an Edgeport/4 with ports 1&2 RS422 and ports 3&4 RS232
+#define ION_DEVICE_ID_TI_EDGEPORT_22I		0x021A	// Edgeport/22I is an Edgeport/4 with ports 1&2 RS422 and ports 3&4 RS232
 #define ION_DEVICE_ID_TI_EDGEPORT_2C		0x021B	// Edgeport/2c RS232
 #define ION_DEVICE_ID_TI_EDGEPORT_221C		0x021C	// Edgeport/221c is a TI based Edgeport/2 with lucent chip and
 							// 2 external hub ports - Large I2C
@@ -142,7 +142,7 @@
 							// 2 external hub ports - Large I2C
 #define ION_DEVICE_ID_TI_EDGEPORT_21C		0x021E	// Edgeport/21c is a TI based Edgeport/2 with lucent chip
 
-// Generation 3 devices -- 3410 based edgport/1 (256 byte I2C) 
+// Generation 3 devices -- 3410 based edgport/1 (256 byte I2C)
 #define ION_DEVICE_ID_TI_TI3410_EDGEPORT_1	0x0240	// Edgeport/1 RS232
 #define ION_DEVICE_ID_TI_TI3410_EDGEPORT_1I	0x0241	// Edgeport/1i- RS422 model
 
@@ -176,7 +176,7 @@
 							// Default to /P function
 
 #define ION_DEVICE_ID_PLUS_PWR_HP4CD		0x30C	// 5052 Plus Power HubPort/4CD+ (for Dell)
-#define ION_DEVICE_ID_PLUS_PWR_HP4C		0x30D	// 5052 Plus Power HubPort/4C+ 
+#define ION_DEVICE_ID_PLUS_PWR_HP4C		0x30D	// 5052 Plus Power HubPort/4C+
 #define ION_DEVICE_ID_PLUS_PWR_PCI		0x30E	// 3410 Plus Power PCI Host Controller 4 port
 
 
@@ -217,17 +217,17 @@
 #define ION_DEVICE_ID_MT4X56USB			0x1403	// OEM device
 
 
-#define	GENERATION_ID_FROM_USB_PRODUCT_ID( ProductId )				\
-			( (__u16) ((ProductId >> 8) & (ION_GENERATION_MASK)) )
+#define	GENERATION_ID_FROM_USB_PRODUCT_ID(ProductId)				\
+			((__u16) ((ProductId >> 8) & (ION_GENERATION_MASK)))
 
-#define	MAKE_USB_PRODUCT_ID( OemId, DeviceId )					\
-			( (__u16) (((OemId) << 10) || (DeviceId)) )
+#define	MAKE_USB_PRODUCT_ID(OemId, DeviceId)					\
+			((__u16) (((OemId) << 10) || (DeviceId)))
 
-#define	DEVICE_ID_FROM_USB_PRODUCT_ID( ProductId )				\
-			( (__u16) ((ProductId) & (EDGEPORT_DEVICE_ID_MASK)) )
+#define	DEVICE_ID_FROM_USB_PRODUCT_ID(ProductId)				\
+			((__u16) ((ProductId) & (EDGEPORT_DEVICE_ID_MASK)))
 
-#define	OEM_ID_FROM_USB_PRODUCT_ID( ProductId )					\
-			( (__u16) (((ProductId) >> 10) & 0x3F) )
+#define	OEM_ID_FROM_USB_PRODUCT_ID(ProductId)					\
+			((__u16) (((ProductId) >> 10) & 0x3F))
 
 //
 // Definitions of parameters for download code. Note that these are
@@ -237,7 +237,7 @@
 
 // TxCredits value below which driver won't bother sending (to prevent too many small writes).
 // Send only if above 25%
-#define EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(InitialCredit, MaxPacketSize) (max( ((InitialCredit) / 4), (MaxPacketSize) ))
+#define EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(InitialCredit, MaxPacketSize) (max(((InitialCredit) / 4), (MaxPacketSize)))
 
 #define	EDGE_FW_BULK_MAX_PACKET_SIZE		64	// Max Packet Size for Bulk In Endpoint (EP1)
 #define EDGE_FW_BULK_READ_BUFFER_SIZE		1024	// Size to use for Bulk reads
@@ -263,7 +263,7 @@
 //		wValue = 16-bit address
 //		wIndex = unused (though we could put segment 00: or FF: here)
 //		wLength = # bytes to read/write (max 64)
-//							
+//
 
 #define USB_REQUEST_ION_RESET_DEVICE	0	// Warm reboot Edgeport, retaining USB address
 #define USB_REQUEST_ION_GET_EPIC_DESC	1	// Get Edgeport Compatibility Descriptor
@@ -278,7 +278,7 @@
 #define USB_REQUEST_ION_ENABLE_SUSPEND	9	// Enable/Disable suspend feature
 						// (wValue != 0: Enable; wValue = 0: Disable)
 
-#define USB_REQUEST_ION_SEND_IOSP	10	// Send an IOSP command to the edgeport over the control pipe	
+#define USB_REQUEST_ION_SEND_IOSP	10	// Send an IOSP command to the edgeport over the control pipe
 #define USB_REQUEST_ION_RECV_IOSP	11	// Receive an IOSP command from the edgeport over the control pipe
 
 
@@ -301,8 +301,7 @@
 // this is a "real" Edgeport.
 //
 
-struct edge_compatibility_bits
-{
+struct edge_compatibility_bits {
 	// This __u32 defines which Vendor-specific commands/functionality
 	// the device supports on the default EP0 pipe.
 
@@ -334,24 +333,22 @@ struct edge_compatibility_bits
 	__u32	TrueEdgeport		:  1;	// 0001	Set if device is a 'real' Edgeport
 											// (Used only by driver, NEVER set by an EPiC device)
 	__u32	GenUnused		: 31;	// Available for future expansion, must be 0
-
 };
 
 #define EDGE_COMPATIBILITY_MASK0	0x0001
 #define EDGE_COMPATIBILITY_MASK1	0x3FFF
 #define EDGE_COMPATIBILITY_MASK2	0x0001
 
-struct edge_compatibility_descriptor
-{
+struct edge_compatibility_descriptor {
 	__u8	Length;				// Descriptor Length (per USB spec)
 	__u8	DescType;			// Descriptor Type (per USB spec, =DEVICE type)
 	__u8	EpicVer;			// Version of EPiC spec supported
-											// (Currently must be 1)
+						// (Currently must be 1)
 	__u8	NumPorts;			// Number of serial ports supported
 	__u8	iDownloadFile;			// Index of string containing download code filename
-											// 0=no download, FF=download compiled into driver.
-	__u8	Unused[ 3 ];			// Available for future expansion, must be 0
-											// (Currently must be 0).
+						// 0=no download, FF=download compiled into driver.
+	__u8	Unused[3];			// Available for future expansion, must be 0
+						// (Currently must be 0).
 	__u8	MajorVersion;			// Firmware version: xx.
 	__u8	MinorVersion;			//  yy.
 	__le16	BuildNumber;			//  zzzz (LE format)
@@ -359,9 +356,7 @@ struct edge_compatibility_descriptor
 	// The following structure contains __u32s, with each bit
 	// specifying whether the EPiC device supports the given
 	// command or functionality.
-
 	struct edge_compatibility_bits	Supports;
-
 };
 
 // Values for iDownloadFile
@@ -391,8 +386,8 @@ struct edge_compatibility_descriptor
 
 // Define the max block size that may be read or written
 // in a read/write RAM/ROM command.
-#define	MAX_SIZE_REQ_ION_READ_MEM	( (__u16) 64 )
-#define	MAX_SIZE_REQ_ION_WRITE_MEM	( (__u16) 64 )
+#define	MAX_SIZE_REQ_ION_READ_MEM	((__u16)64)
+#define	MAX_SIZE_REQ_ION_WRITE_MEM	((__u16)64)
 
 
 //
@@ -545,7 +540,7 @@ struct edge_boot_descriptor {
 	__u8		MajorVersion;		// C6 Firmware version: xx.
 	__u8		MinorVersion;		// C7			yy.
 	__le16		BuildNumber;		// C8			zzzz (LE format)
-	
+
 	__u16		EnumRootDescTable;	// CA Root of ROM-based descriptor table
 	__u8		NumDescTypes;		// CC Number of supported descriptor types
 
@@ -597,41 +592,36 @@ struct edge_boot_descriptor {
 #define I2C_DESC_TYPE_ION		0	// Not defined by TI
 
 
-struct ti_i2c_desc
-{
+struct ti_i2c_desc {
 	__u8	Type;			// Type of descriptor
 	__u16	Size;			// Size of data only not including header
 	__u8	CheckSum;		// Checksum (8 bit sum of data only)
 	__u8	Data[0];		// Data starts here
-}__attribute__((packed));
+} __attribute__((packed));
 
 // for 5152 devices only (type 2 record)
 // for 3410 the version is stored in the WATCHPORT_FIRMWARE_VERSION descriptor
-struct ti_i2c_firmware_rec
-{
+struct ti_i2c_firmware_rec {
 	__u8	Ver_Major;		// Firmware Major version number
 	__u8	Ver_Minor;		// Firmware Minor version number
 	__u8	Data[0];		// Download starts here
-}__attribute__((packed));
+} __attribute__((packed));
 
 
-struct watchport_firmware_version
-{
+struct watchport_firmware_version {
 // Added 2 bytes for version number
 	__u8	Version_Major;		//  Download Version (for Watchport)
 	__u8	Version_Minor;
-}__attribute__((packed));
+} __attribute__((packed));
 
 
 // Structure of header of download image in fw_down.h
-struct ti_i2c_image_header
-{
+struct ti_i2c_image_header {
 	__le16	Length;
 	__u8	CheckSum;
-}__attribute__((packed));
+} __attribute__((packed));
 
-struct ti_basic_descriptor
-{
+struct ti_basic_descriptor {
 	__u8	Power;		// Self powered
 				// bit 7: 1 - power switching supported
 				//        0 - power switching not supported
@@ -663,9 +653,9 @@ struct ti_basic_descriptor
 #define TI_I2C_SIZE_MASK		0x1f  // 5 bits
 #define TI_GET_I2C_SIZE(x)		((((x) & TI_I2C_SIZE_MASK)+1)*256)
 
-#define TI_MAX_I2C_SIZE			( 16 * 1024 )
+#define TI_MAX_I2C_SIZE			(16 * 1024)
 
-#define TI_MANUF_VERSION_0		0	
+#define TI_MANUF_VERSION_0		0
 
 // IonConig2 flags
 #define TI_CONFIG2_RS232		0x01
@@ -676,8 +666,7 @@ struct ti_basic_descriptor
 #define TI_CONFIG2_WATCHPORT		0x10
 
 
-struct edge_ti_manuf_descriptor
-{
+struct edge_ti_manuf_descriptor {
 	__u8 IonConfig;		//  Config byte for ION manufacturing use
 	__u8 IonConfig2;	//  Expansion
 	__u8 Version;		//  Version
@@ -688,7 +677,7 @@ struct edge_ti_manuf_descriptor
 	__u8 HubConfig2;	//  Used to configure the Hub
 	__u8 TotalPorts;	//  Total Number of Com Ports for the entire device (All UMPs)
 	__u8 Reserved;		//  Reserved
-}__attribute__((packed));
+} __attribute__((packed));
 
 
 #endif		// if !defined(_USBVEND_H)
