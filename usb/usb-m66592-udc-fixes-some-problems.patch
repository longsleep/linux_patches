From shimoda.yoshihiro@renesas.com  Wed Jul 18 11:02:15 2007
From: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date: Tue, 17 Jul 2007 21:01:17 +0900
Subject: USB: m66592-udc: fixes some problems
To: greg@kroah.com
Cc: David Brownell <david-b@pacbell.net>, USB development list <linux-usb-devel@lists.sourceforge.net>
Message-ID: <469CAF8D.7030401@renesas.com>


This patch incorporates some updates from the review of the
Renesas m66592-udc driver.  Updates include:

 - Fix some locking bugs; and add a few sparse annotations
 - Don't #define __iomem !
 - Lots of whitespace fixes (most of the patch by volume)
 - Some #include file trimmage
 - Other checkpatch.pl and sparse updates
 - Alphabetized and slightly-more-informative Kconfig
 - Don't use the ID which was assigned to the amd5536udc driver.
 - Remove pointless suspend/resume methods updating obsolete field.
 - Some section fixups
 - Fix some leak bugs
 - Fix byteswapping

Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/Kconfig        |   36 +-
 drivers/usb/gadget/gadget_chips.h |    2 
 drivers/usb/gadget/m66592-udc.c   |  255 +++++++--------
 drivers/usb/gadget/m66592-udc.h   |  610 ++++++++++++++++++--------------------
 4 files changed, 450 insertions(+), 453 deletions(-)

--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -177,6 +177,24 @@ config USB_PXA2XX_SMALL
 	default y if USB_ETH
 	default y if USB_G_SERIAL
 
+config USB_GADGET_M66592
+	boolean "Renesas M66592 USB Peripheral Controller"
+	select USB_GADGET_DUALSPEED
+	help
+	   M66592 is a discrete USB peripheral controller chip that
+	   supports both full and high speed USB 2.0 data transfers.
+	   It has seven configurable endpoints, and endpoint zero.
+
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "m66592_udc" and force all
+	   gadget drivers to also be dynamically linked.
+
+config USB_M66592
+	tristate
+	depends on USB_GADGET_M66592
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
 config USB_GADGET_GOKU
 	boolean "Toshiba TC86C001 'Goku-S'"
 	depends on PCI
@@ -282,24 +300,6 @@ config USB_AT91
 	depends on USB_GADGET_AT91
 	default USB_GADGET
 
-config USB_GADGET_M66592
-	boolean "M66592 driver"
-	select USB_GADGET_DUALSPEED
-	help
-	   M66592 is a USB 2.0 peripheral controller.
-
-	   It has seven configurable endpoints, and endpoint zero.
-
-	   Say "y" to link the driver statically, or "m" to build a
-	   dynamically linked module called "m66592_udc" and force all
-	   gadget drivers to also be dynamically linked.
-
-config USB_M66592
-	tristate
-	depends on USB_GADGET_M66592
-	default USB_GADGET
-	select USB_GADGET_SELECTED
-
 config USB_GADGET_DUMMY_HCD
 	boolean "Dummy HCD (DEVELOPMENT)"
 	depends on (USB=y || (USB=m && USB_GADGET=m)) && EXPERIMENTAL
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -211,6 +211,6 @@ static inline int usb_gadget_controller_
 	else if (gadget_is_amd5536udc(gadget))
 		return 0x20;
 	else if (gadget_is_m66592(gadget))
-		return 0x20;
+		return 0x21;
 	return -ENOENT;
 }
--- a/drivers/usb/gadget/m66592-udc.c
+++ b/drivers/usb/gadget/m66592-udc.c
@@ -21,26 +21,18 @@
  */
 
 #include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/smp_lock.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/delay.h>
-#include <linux/list.h>
 #include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/io.h>
 #include <linux/platform_device.h>
+
 #include <linux/usb/ch9.h>
 #include <linux/usb_gadget.h>
 
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-
 #include "m66592-udc.h"
 
-MODULE_DESCRIPTION("M66592 USB gadget driiver");
+
+MODULE_DESCRIPTION("M66592 USB gadget driver");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Yoshihiro Shimoda");
 
@@ -49,16 +41,21 @@ MODULE_AUTHOR("Yoshihiro Shimoda");
 /* module parameters */
 static unsigned short clock = M66592_XTAL24;
 module_param(clock, ushort, 0644);
-MODULE_PARM_DESC(clock, "input clock: 48MHz=32768, 24MHz=16384, 12MHz=0(default=16384)");
+MODULE_PARM_DESC(clock, "input clock: 48MHz=32768, 24MHz=16384, 12MHz=0 "
+		"(default=16384)");
+
 static unsigned short vif = M66592_LDRV;
 module_param(vif, ushort, 0644);
-MODULE_PARM_DESC(vif, "input VIF: 3.3V=32768, 1.5V=0(default=32768)");
-static unsigned short endian = 0;
+MODULE_PARM_DESC(vif, "input VIF: 3.3V=32768, 1.5V=0 (default=32768)");
+
+static unsigned short endian;
 module_param(endian, ushort, 0644);
-MODULE_PARM_DESC(endian, "data endian: big=256, little=0(default=0)");
+MODULE_PARM_DESC(endian, "data endian: big=256, little=0 (default=0)");
+
 static unsigned short irq_sense = M66592_INTL;
 module_param(irq_sense, ushort, 0644);
-MODULE_PARM_DESC(irq_sense, "IRQ sense: low level=2, falling edge=0(default=2)");
+MODULE_PARM_DESC(irq_sense, "IRQ sense: low level=2, falling edge=0 "
+		"(default=2)");
 
 static const char udc_name[] = "m66592_udc";
 static const char *m66592_ep_name[] = {
@@ -72,8 +69,8 @@ static int m66592_queue(struct usb_ep *_
 			gfp_t gfp_flags);
 
 static void transfer_complete(struct m66592_ep *ep,
-			      struct m66592_request *req,
-			      int status);
+		struct m66592_request *req, int status);
+
 /*-------------------------------------------------------------------------*/
 static inline u16 get_usb_speed(struct m66592 *m66592)
 {
@@ -81,25 +78,25 @@ static inline u16 get_usb_speed(struct m
 }
 
 static void enable_pipe_irq(struct m66592 *m66592, u16 pipenum,
-			    unsigned long reg)
+		unsigned long reg)
 {
 	u16 tmp;
 
 	tmp = m66592_read(m66592, M66592_INTENB0);
 	m66592_bclr(m66592, M66592_BEMPE | M66592_NRDYE | M66592_BRDYE,
-		    M66592_INTENB0);
+			M66592_INTENB0);
 	m66592_bset(m66592, (1 << pipenum), reg);
 	m66592_write(m66592, tmp, M66592_INTENB0);
 }
 
 static void disable_pipe_irq(struct m66592 *m66592, u16 pipenum,
-			     unsigned long reg)
+		unsigned long reg)
 {
 	u16 tmp;
 
 	tmp = m66592_read(m66592, M66592_INTENB0);
 	m66592_bclr(m66592, M66592_BEMPE | M66592_NRDYE | M66592_BRDYE,
-		    M66592_INTENB0);
+			M66592_INTENB0);
 	m66592_bclr(m66592, (1 << pipenum), reg);
 	m66592_write(m66592, tmp, M66592_INTENB0);
 }
@@ -108,17 +105,19 @@ static void m66592_usb_connect(struct m6
 {
 	m66592_bset(m66592, M66592_CTRE, M66592_INTENB0);
 	m66592_bset(m66592, M66592_WDST | M66592_RDST | M66592_CMPL,
-		    M66592_INTENB0);
+			M66592_INTENB0);
 	m66592_bset(m66592, M66592_BEMPE | M66592_BRDYE, M66592_INTENB0);
 
 	m66592_bset(m66592, M66592_DPRPU, M66592_SYSCFG);
 }
 
 static void m66592_usb_disconnect(struct m66592 *m66592)
+__releases(m66592->lock)
+__acquires(m66592->lock)
 {
 	m66592_bclr(m66592, M66592_CTRE, M66592_INTENB0);
 	m66592_bclr(m66592, M66592_WDST | M66592_RDST | M66592_CMPL,
-		    M66592_INTENB0);
+			M66592_INTENB0);
 	m66592_bclr(m66592, M66592_BEMPE | M66592_BRDYE, M66592_INTENB0);
 	m66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);
 
@@ -148,7 +147,7 @@ static inline u16 control_reg_get_pid(st
 }
 
 static inline void control_reg_set_pid(struct m66592 *m66592, u16 pipenum,
-				       u16 pid)
+		u16 pid)
 {
 	unsigned long offset;
 
@@ -250,7 +249,7 @@ static inline void pipe_change(struct m6
 }
 
 static int pipe_buffer_setting(struct m66592 *m66592,
-			       struct m66592_pipe_info *info)
+		struct m66592_pipe_info *info)
 {
 	u16 bufnum = 0, buf_bsize = 0;
 	u16 pipecfg = 0;
@@ -287,7 +286,7 @@ static int pipe_buffer_setting(struct m6
 	}
 	if (m66592->bi_bufnum > M66592_MAX_BUFNUM) {
 		printk(KERN_ERR "m66592 pipe memory is insufficient(%d)\n",
-		       m66592->bi_bufnum);
+				m66592->bi_bufnum);
 		return -ENOMEM;
 	}
 
@@ -328,7 +327,7 @@ static void pipe_buffer_release(struct m
 			m66592->bulk--;
 	} else
 		printk(KERN_ERR "ep_release: unexpect pipenum (%d)\n",
-		       info->pipe);
+				info->pipe);
 }
 
 static void pipe_initialize(struct m66592_ep *ep)
@@ -350,8 +349,8 @@ static void pipe_initialize(struct m6659
 }
 
 static void m66592_ep_setting(struct m66592 *m66592, struct m66592_ep *ep,
-			      const struct usb_endpoint_descriptor *desc,
-			      u16 pipenum, int dma)
+		const struct usb_endpoint_descriptor *desc,
+		u16 pipenum, int dma)
 {
 	if ((pipenum != 0) && dma) {
 		if (m66592->num_dma == 0) {
@@ -385,7 +384,7 @@ static void m66592_ep_setting(struct m66
 
 	ep->pipectr = get_pipectr_addr(pipenum);
 	ep->pipenum = pipenum;
-	ep->ep.maxpacket = desc->wMaxPacketSize;
+	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
 	m66592->pipenum2ep[pipenum] = ep;
 	m66592->epaddr2ep[desc->bEndpointAddress&USB_ENDPOINT_NUMBER_MASK] = ep;
 	INIT_LIST_HEAD(&ep->queue);
@@ -407,7 +406,7 @@ static void m66592_ep_release(struct m66
 }
 
 static int alloc_pipe_config(struct m66592_ep *ep,
-			     const struct usb_endpoint_descriptor *desc)
+		const struct usb_endpoint_descriptor *desc)
 {
 	struct m66592 *m66592 = ep->m66592;
 	struct m66592_pipe_info info;
@@ -419,15 +418,15 @@ static int alloc_pipe_config(struct m665
 
 	BUG_ON(ep->pipenum);
 
-	switch(desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+	switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
 	case USB_ENDPOINT_XFER_BULK:
 		if (m66592->bulk >= M66592_MAX_NUM_BULK) {
 			if (m66592->isochronous >= M66592_MAX_NUM_ISOC) {
 				printk(KERN_ERR "bulk pipe is insufficient\n");
 				return -ENODEV;
 			} else {
-				info.pipe = M66592_BASE_PIPENUM_ISOC +
-					    m66592->isochronous;
+				info.pipe = M66592_BASE_PIPENUM_ISOC
+						+ m66592->isochronous;
 				counter = &m66592->isochronous;
 			}
 		} else {
@@ -462,7 +461,7 @@ static int alloc_pipe_config(struct m665
 	ep->type = info.type;
 
 	info.epnum = desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
-	info.maxpacket = desc->wMaxPacketSize;
+	info.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
 	info.interval = desc->bInterval;
 	if (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
 		info.dir_in = 1;
@@ -525,8 +524,8 @@ static void start_ep0_write(struct m6659
 
 	pipe_change(m66592, ep->pipenum);
 	m66592_mdfy(m66592, M66592_ISEL | M66592_PIPE0,
-		    (M66592_ISEL | M66592_CURPIPE),
-		    M66592_CFIFOSEL);
+			(M66592_ISEL | M66592_CURPIPE),
+			M66592_CFIFOSEL);
 	m66592_write(m66592, M66592_BCLR, ep->fifoctr);
 	if (req->req.length == 0) {
 		m66592_bset(m66592, M66592_BVAL, ep->fifoctr);
@@ -561,8 +560,8 @@ static void start_packet_read(struct m66
 
 	if (ep->pipenum == 0) {
 		m66592_mdfy(m66592, M66592_PIPE0,
-			    (M66592_ISEL | M66592_CURPIPE),
-			    M66592_CFIFOSEL);
+				(M66592_ISEL | M66592_CURPIPE),
+				M66592_CFIFOSEL);
 		m66592_write(m66592, M66592_BCLR, ep->fifoctr);
 		pipe_start(m66592, pipenum);
 		pipe_irq_enable(m66592, pipenum);
@@ -572,8 +571,9 @@ static void start_packet_read(struct m66
 			pipe_change(m66592, pipenum);
 			m66592_bset(m66592, M66592_TRENB, ep->fifosel);
 			m66592_write(m66592,
-				     (req->req.length + ep->ep.maxpacket - 1) /
-				     ep->ep.maxpacket, ep->fifotrn);
+				(req->req.length + ep->ep.maxpacket - 1)
+					/ ep->ep.maxpacket,
+				ep->fifotrn);
 		}
 		pipe_start(m66592, pipenum);	/* trigger once */
 		pipe_irq_enable(m66592, pipenum);
@@ -614,7 +614,7 @@ static void start_ep0(struct m66592_ep *
 static void init_controller(struct m66592 *m66592)
 {
 	m66592_bset(m66592, (vif & M66592_LDRV) | (endian & M66592_BIGEND),
-		    M66592_PINCFG);
+			M66592_PINCFG);
 	m66592_bset(m66592, M66592_HSE, M66592_SYSCFG);		/* High spd */
 	m66592_mdfy(m66592, clock & M66592_XTAL, M66592_XTAL, M66592_SYSCFG);
 
@@ -634,7 +634,7 @@ static void init_controller(struct m6659
 
 	m66592_bset(m66592, irq_sense & M66592_INTL, M66592_INTENB1);
 	m66592_write(m66592, M66592_BURST | M66592_CPU_ADR_RD_WR,
-		     M66592_DMA0CFG);
+			M66592_DMA0CFG);
 }
 
 static void disable_controller(struct m66592 *m66592)
@@ -659,8 +659,9 @@ static void m66592_start_xclock(struct m
 
 /*-------------------------------------------------------------------------*/
 static void transfer_complete(struct m66592_ep *ep,
-			      struct m66592_request *req,
-			      int status)
+		struct m66592_request *req, int status)
+__releases(m66592->lock)
+__acquires(m66592->lock)
 {
 	int restart = 0;
 
@@ -680,8 +681,9 @@ static void transfer_complete(struct m66
 	if (!list_empty(&ep->queue))
 		restart = 1;
 
-	if (likely(req->req.complete))
-		req->req.complete(&ep->ep, &req->req);
+	spin_unlock(&ep->m66592->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->m66592->lock);
 
 	if (restart) {
 		req = list_entry(ep->queue.next, struct m66592_request, queue);
@@ -693,7 +695,7 @@ static void transfer_complete(struct m66
 static void irq_ep0_write(struct m66592_ep *ep, struct m66592_request *req)
 {
 	int i;
-	volatile u16 tmp;
+	u16 tmp;
 	unsigned bufsize;
 	size_t size;
 	void *buf;
@@ -731,8 +733,9 @@ static void irq_ep0_write(struct m66592_
 	req->req.actual += size;
 
 	/* check transfer finish */
-	if ((!req->req.zero && (req->req.actual == req->req.length)) ||
-	    (size % ep->ep.maxpacket) || (size == 0)) {
+	if ((!req->req.zero && (req->req.actual == req->req.length))
+			|| (size % ep->ep.maxpacket)
+			|| (size == 0)) {
 		disable_irq_ready(m66592, pipenum);
 		disable_irq_empty(m66592, pipenum);
 	} else {
@@ -768,16 +771,19 @@ static void irq_packet_write(struct m665
 	/* write fifo */
 	if (req->req.buf) {
 		m66592_write_fifo(m66592, ep->fifoaddr, buf, size);
-		if ((size == 0) || ((size % ep->ep.maxpacket) != 0) ||
-		    ((bufsize != ep->ep.maxpacket) && (bufsize > size)))
+		if ((size == 0)
+				|| ((size % ep->ep.maxpacket) != 0)
+				|| ((bufsize != ep->ep.maxpacket)
+					&& (bufsize > size)))
 			m66592_bset(m66592, M66592_BVAL, ep->fifoctr);
 	}
 
 	/* update parameters */
 	req->req.actual += size;
 	/* check transfer finish */
-	if ((!req->req.zero && (req->req.actual == req->req.length)) ||
-	    (size % ep->ep.maxpacket) || (size == 0)) {
+	if ((!req->req.zero && (req->req.actual == req->req.length))
+			|| (size % ep->ep.maxpacket)
+			|| (size == 0)) {
 		disable_irq_ready(m66592, pipenum);
 		enable_irq_empty(m66592, pipenum);
 	} else {
@@ -821,8 +827,9 @@ static void irq_packet_read(struct m6659
 	req->req.actual += size;
 
 	/* check transfer finish */
-	if ((!req->req.zero && (req->req.actual == req->req.length)) ||
-	    (size % ep->ep.maxpacket) || (size == 0)) {
+	if ((!req->req.zero && (req->req.actual == req->req.length))
+			|| (size % ep->ep.maxpacket)
+			|| (size == 0)) {
 		pipe_stop(m66592, pipenum);
 		pipe_irq_disable(m66592, pipenum);
 		finish = 1;
@@ -850,7 +857,7 @@ static void irq_pipe_ready(struct m66592
 	if ((status & M66592_BRDY0) && (enb & M66592_BRDY0)) {
 		m66592_write(m66592, ~M66592_BRDY0, M66592_BRDYSTS);
 		m66592_mdfy(m66592, M66592_PIPE0, M66592_CURPIPE,
-			    M66592_CFIFOSEL);
+				M66592_CFIFOSEL);
 
 		ep = &m66592->ep[0];
 		req = list_entry(ep->queue.next, struct m66592_request, queue);
@@ -909,23 +916,26 @@ static void irq_pipe_empty(struct m66592
 }
 
 static void get_status(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)
+__releases(m66592->lock)
+__acquires(m66592->lock)
 {
 	struct m66592_ep *ep;
 	u16 pid;
 	u16 status = 0;
+	u16 w_index = le16_to_cpu(ctrl->wIndex);
 
 	switch (ctrl->bRequestType & USB_RECIP_MASK) {
 	case USB_RECIP_DEVICE:
-		status = 1;	/* selfpower */
+		status = 1 << USB_DEVICE_SELF_POWERED;
 		break;
 	case USB_RECIP_INTERFACE:
 		status = 0;
 		break;
 	case USB_RECIP_ENDPOINT:
-		ep = m66592->epaddr2ep[ctrl->wIndex&USB_ENDPOINT_NUMBER_MASK];
+		ep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];
 		pid = control_reg_get_pid(m66592, ep->pipenum);
 		if (pid == M66592_PID_STALL)
-			status = 1;
+			status = 1 << USB_ENDPOINT_HALT;
 		else
 			status = 0;
 		break;
@@ -934,11 +944,13 @@ static void get_status(struct m66592 *m6
 		return;		/* exit */
 	}
 
-	*m66592->ep0_buf = status;
-	m66592->ep0_req->buf = m66592->ep0_buf;
+	m66592->ep0_data = cpu_to_le16(status);
+	m66592->ep0_req->buf = &m66592->ep0_data;
 	m66592->ep0_req->length = 2;
 	/* AV: what happens if we get called again before that gets through? */
+	spin_unlock(&m66592->lock);
 	m66592_queue(m66592->gadget.ep0, m66592->ep0_req, GFP_KERNEL);
+	spin_lock(&m66592->lock);
 }
 
 static void clear_feature(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)
@@ -953,8 +965,9 @@ static void clear_feature(struct m66592 
 	case USB_RECIP_ENDPOINT: {
 		struct m66592_ep *ep;
 		struct m66592_request *req;
+		u16 w_index = le16_to_cpu(ctrl->wIndex);
 
-		ep = m66592->epaddr2ep[ctrl->wIndex&USB_ENDPOINT_NUMBER_MASK];
+		ep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];
 		pipe_stop(m66592, ep->pipenum);
 		control_reg_sqclr(m66592, ep->pipenum);
 
@@ -989,8 +1002,9 @@ static void set_feature(struct m66592 *m
 		break;
 	case USB_RECIP_ENDPOINT: {
 		struct m66592_ep *ep;
+		u16 w_index = le16_to_cpu(ctrl->wIndex);
 
-		ep = m66592->epaddr2ep[ctrl->wIndex&USB_ENDPOINT_NUMBER_MASK];
+		ep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];
 		pipe_stall(m66592, ep->pipenum);
 
 		control_end(m66592, 1);
@@ -1066,14 +1080,16 @@ static void irq_device_state(struct m665
 	}
 	if (m66592->old_dvsq == M66592_DS_CNFG && dvsq != M66592_DS_CNFG)
 		m66592_update_usb_speed(m66592);
-	if ((dvsq == M66592_DS_CNFG || dvsq == M66592_DS_ADDS) &&
-	    m66592->gadget.speed == USB_SPEED_UNKNOWN)
+	if ((dvsq == M66592_DS_CNFG || dvsq == M66592_DS_ADDS)
+			&& m66592->gadget.speed == USB_SPEED_UNKNOWN)
 		m66592_update_usb_speed(m66592);
 
 	m66592->old_dvsq = dvsq;
 }
 
 static void irq_control_stage(struct m66592 *m66592)
+__releases(m66592->lock)
+__acquires(m66592->lock)
 {
 	struct usb_ctrlrequest ctrl;
 	u16 ctsq;
@@ -1095,8 +1111,10 @@ static void irq_control_stage(struct m66
 	case M66592_CS_WRDS:
 	case M66592_CS_WRND:
 		if (setup_packet(m66592, &ctrl)) {
+			spin_unlock(&m66592->lock);
 			if (m66592->driver->setup(&m66592->gadget, &ctrl) < 0)
 				pipe_stall(m66592, 0);
+			spin_lock(&m66592->lock);
 		}
 		break;
 	case M66592_CS_RDSS:
@@ -1119,6 +1137,8 @@ static irqreturn_t m66592_irq(int irq, v
 	u16 savepipe;
 	u16 mask0;
 
+	spin_lock(&m66592->lock);
+
 	intsts0 = m66592_read(m66592, M66592_INTSTS0);
 	intenb0 = m66592_read(m66592, M66592_INTENB0);
 
@@ -1134,27 +1154,27 @@ static irqreturn_t m66592_irq(int irq, v
 		bempenb = m66592_read(m66592, M66592_BEMPENB);
 
 		if (mask0 & M66592_VBINT) {
-			m66592_write(m66592, (u16)~M66592_VBINT,
-				     M66592_INTSTS0);
+			m66592_write(m66592,  0xffff & ~M66592_VBINT,
+					M66592_INTSTS0);
 			m66592_start_xclock(m66592);
 
 			/* start vbus sampling */
 			m66592->old_vbus = m66592_read(m66592, M66592_INTSTS0)
-					   & M66592_VBSTS;
+					& M66592_VBSTS;
 			m66592->scount = M66592_MAX_SAMPLING;
 
 			mod_timer(&m66592->timer,
-				  jiffies + msecs_to_jiffies(50));
+					jiffies + msecs_to_jiffies(50));
 		}
 		if (intsts0 & M66592_DVSQ)
 			irq_device_state(m66592);
 
-		if ((intsts0 & M66592_BRDY) && (intenb0 & M66592_BRDYE) &&
-		    (brdysts & brdyenb)) {
+		if ((intsts0 & M66592_BRDY) && (intenb0 & M66592_BRDYE)
+				&& (brdysts & brdyenb)) {
 			irq_pipe_ready(m66592, brdysts, brdyenb);
 		}
-		if ((intsts0 & M66592_BEMP) && (intenb0 & M66592_BEMPE) &&
-		    (bempsts & bempenb)) {
+		if ((intsts0 & M66592_BEMP) && (intenb0 & M66592_BEMPE)
+				&& (bempsts & bempenb)) {
 			irq_pipe_empty(m66592, bempsts, bempenb);
 		}
 
@@ -1164,6 +1184,7 @@ static irqreturn_t m66592_irq(int irq, v
 
 	m66592_write(m66592, savepipe, M66592_CFIFOSEL);
 
+	spin_unlock(&m66592->lock);
 	return IRQ_HANDLED;
 }
 
@@ -1191,13 +1212,13 @@ static void m66592_timer(unsigned long _
 					m66592_usb_disconnect(m66592);
 			} else {
 				mod_timer(&m66592->timer,
-					  jiffies + msecs_to_jiffies(50));
+					jiffies + msecs_to_jiffies(50));
 			}
 		} else {
 			m66592->scount = M66592_MAX_SAMPLING;
 			m66592->old_vbus = tmp;
 			mod_timer(&m66592->timer,
-				  jiffies + msecs_to_jiffies(50));
+					jiffies + msecs_to_jiffies(50));
 		}
 	}
 	spin_unlock_irqrestore(&m66592->lock, flags);
@@ -1335,11 +1356,6 @@ out:
 	return ret;
 }
 
-static int m66592_fifo_status(struct usb_ep *_ep)
-{
-	return -EOPNOTSUPP;
-}
-
 static void m66592_fifo_flush(struct usb_ep *_ep)
 {
 	struct m66592_ep *ep;
@@ -1365,7 +1381,6 @@ static struct usb_ep_ops m66592_ep_ops =
 	.dequeue	= m66592_dequeue,
 
 	.set_halt	= m66592_set_halt,
-	.fifo_status	= m66592_fifo_status,
 	.fifo_flush	= m66592_fifo_flush,
 };
 
@@ -1377,11 +1392,10 @@ int usb_gadget_register_driver(struct us
 	struct m66592 *m66592 = the_controller;
 	int retval;
 
-	if (!driver ||
-	    driver->speed != USB_SPEED_HIGH ||
-	    !driver->bind ||
-	    !driver->unbind ||
-	    !driver->setup)
+	if (!driver
+			|| driver->speed != USB_SPEED_HIGH
+			|| !driver->bind
+			|| !driver->setup)
 		return -EINVAL;
 	if (!m66592)
 		return -ENODEV;
@@ -1413,8 +1427,7 @@ int usb_gadget_register_driver(struct us
 		m66592->old_vbus = m66592_read(m66592,
 					 M66592_INTSTS0) & M66592_VBSTS;
 		m66592->scount = M66592_MAX_SAMPLING;
-		mod_timer(&m66592->timer,
-			  jiffies + msecs_to_jiffies(50));
+		mod_timer(&m66592->timer, jiffies + msecs_to_jiffies(50));
 	}
 
 	return 0;
@@ -1432,6 +1445,9 @@ int usb_gadget_unregister_driver(struct 
 	struct m66592 *m66592 = the_controller;
 	unsigned long flags;
 
+	if (driver != m66592->driver || !driver->unbind)
+		return -EINVAL;
+
 	spin_lock_irqsave(&m66592->lock, flags);
 	if (m66592->gadget.speed != USB_SPEED_UNKNOWN)
 		m66592_usb_disconnect(m66592);
@@ -1461,46 +1477,35 @@ static struct usb_gadget_ops m66592_gadg
 	.get_frame		= m66592_get_frame,
 };
 
-#if defined(CONFIG_PM)
-static int m66592_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	pdev->dev.power.power_state = state;
-	return 0;
-}
-
-static int m66592_resume(struct platform_device *pdev)
-{
-	pdev->dev.power.power_state = PMSG_ON;
-	return 0;
-}
-#else	/* if defined(CONFIG_PM) */
-#define m66592_suspend		NULL
-#define m66592_resume		NULL
-#endif
-
-static int __init_or_module m66592_remove(struct platform_device *pdev)
+static int __exit m66592_remove(struct platform_device *pdev)
 {
 	struct m66592		*m66592 = dev_get_drvdata(&pdev->dev);
 
 	del_timer_sync(&m66592->timer);
 	iounmap(m66592->reg);
 	free_irq(platform_get_irq(pdev, 0), m66592);
+	m66592_free_request(&m66592->ep[0].ep, m66592->ep0_req);
 	kfree(m66592);
 	return 0;
 }
 
+static void nop_completion(struct usb_ep *ep, struct usb_request *r)
+{
+}
+
 #define resource_len(r) (((r)->end - (r)->start) + 1)
+
 static int __init m66592_probe(struct platform_device *pdev)
 {
-	struct resource *res = NULL;
-	int irq = -1;
+	struct resource *res;
+	int irq;
 	void __iomem *reg = NULL;
 	struct m66592 *m66592 = NULL;
 	int ret = 0;
 	int i;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-					   (char *)udc_name);
+			(char *)udc_name);
 	if (!res) {
 		ret = -ENODEV;
 		printk(KERN_ERR "platform_get_resource_byname error.\n");
@@ -1548,7 +1553,7 @@ static int __init m66592_probe(struct pl
 	m66592->bi_bufnum = M66592_BASE_BUFNUM;
 
 	ret = request_irq(irq, m66592_irq, IRQF_DISABLED | IRQF_SHARED,
-			  udc_name, m66592);
+			udc_name, m66592);
 	if (ret < 0) {
 		printk(KERN_ERR "request_irq error (%d)\n", ret);
 		goto clean_up;
@@ -1563,7 +1568,7 @@ static int __init m66592_probe(struct pl
 		if (i != 0) {
 			INIT_LIST_HEAD(&m66592->ep[i].ep.ep_list);
 			list_add_tail(&m66592->ep[i].ep.ep_list,
-				      &m66592->gadget.ep_list);
+					&m66592->gadget.ep_list);
 		}
 		ep->m66592 = m66592;
 		INIT_LIST_HEAD(&ep->queue);
@@ -1583,20 +1588,18 @@ static int __init m66592_probe(struct pl
 
 	the_controller = m66592;
 
-	/* AV: leaks */
 	m66592->ep0_req = m66592_alloc_request(&m66592->ep[0].ep, GFP_KERNEL);
 	if (m66592->ep0_req == NULL)
-		goto clean_up;
-	/* AV: leaks, and do we really need it separately allocated? */
-	m66592->ep0_buf = kzalloc(2, GFP_KERNEL);
-	if (m66592->ep0_buf == NULL)
-		goto clean_up;
+		goto clean_up2;
+	m66592->ep0_req->complete = nop_completion;
 
 	init_controller(m66592);
 
-	printk("driver %s, %s\n", udc_name, DRIVER_VERSION);
+	dev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);
 	return 0;
 
+clean_up2:
+	free_irq(irq, m66592);
 clean_up:
 	if (m66592) {
 		if (m66592->ep0_req)
@@ -1611,10 +1614,7 @@ clean_up:
 
 /*-------------------------------------------------------------------------*/
 static struct platform_driver m66592_driver = {
-	.probe =	m66592_probe,
-	.remove =	m66592_remove,
-	.suspend =	m66592_suspend,
-	.resume =	m66592_resume,
+	.remove =	__exit_p(m66592_remove),
 	.driver		= {
 		.name =	(char *) udc_name,
 	},
@@ -1622,7 +1622,7 @@ static struct platform_driver m66592_dri
 
 static int __init m66592_udc_init(void)
 {
-	return platform_driver_register(&m66592_driver);
+	return platform_driver_probe(&m66592_driver, m66592_probe);
 }
 module_init(m66592_udc_init);
 
@@ -1631,4 +1631,3 @@ static void __exit m66592_udc_cleanup(vo
 	platform_driver_unregister(&m66592_driver);
 }
 module_exit(m66592_udc_cleanup);
-
--- a/drivers/usb/gadget/m66592-udc.h
+++ b/drivers/usb/gadget/m66592-udc.h
@@ -24,73 +24,73 @@
 #define __M66592_UDC_H__
 
 #define M66592_SYSCFG		0x00
-#define	M66592_XTAL		0xC000	/* b15-14: Crystal selection */
-#define	  M66592_XTAL48		 0x8000		  /* 48MHz */
-#define   M66592_XTAL24		 0x4000		  /* 24MHz */
-#define	  M66592_XTAL12		 0x0000		  /* 12MHz */
-#define	M66592_XCKE		0x2000	/* b13: External clock enable */
-#define	M66592_RCKE		0x1000	/* b12: Register clock enable */
-#define	M66592_PLLC		0x0800	/* b11: PLL control */
-#define	M66592_SCKE		0x0400	/* b10: USB clock enable */
-#define	M66592_ATCKM		0x0100	/* b8: Automatic supply functional enable */
-#define	M66592_HSE		0x0080	/* b7: Hi-speed enable */
-#define	M66592_DCFM		0x0040	/* b6: Controller function select  */
-#define	M66592_DMRPD		0x0020	/* b5: D- pull down control */
-#define	M66592_DPRPU		0x0010	/* b4: D+ pull up control */
-#define	M66592_FSRPC		0x0004	/* b2: Full-speed receiver enable */
-#define	M66592_PCUT		0x0002	/* b1: Low power sleep enable */
-#define	M66592_USBE		0x0001	/* b0: USB module operation enable */
+#define M66592_XTAL		0xC000	/* b15-14: Crystal selection */
+#define   M66592_XTAL48		 0x8000		/* 48MHz */
+#define   M66592_XTAL24		 0x4000		/* 24MHz */
+#define   M66592_XTAL12		 0x0000		/* 12MHz */
+#define M66592_XCKE		0x2000	/* b13: External clock enable */
+#define M66592_RCKE		0x1000	/* b12: Register clock enable */
+#define M66592_PLLC		0x0800	/* b11: PLL control */
+#define M66592_SCKE		0x0400	/* b10: USB clock enable */
+#define M66592_ATCKM		0x0100	/* b8: Automatic clock supply */
+#define M66592_HSE		0x0080	/* b7: Hi-speed enable */
+#define M66592_DCFM		0x0040	/* b6: Controller function select  */
+#define M66592_DMRPD		0x0020	/* b5: D- pull down control */
+#define M66592_DPRPU		0x0010	/* b4: D+ pull up control */
+#define M66592_FSRPC		0x0004	/* b2: Full-speed receiver enable */
+#define M66592_PCUT		0x0002	/* b1: Low power sleep enable */
+#define M66592_USBE		0x0001	/* b0: USB module operation enable */
 
 #define M66592_SYSSTS		0x02
-#define	M66592_LNST		0x0003	/* b1-0: D+, D- line status */
-#define	  M66592_SE1		 0x0003		  /* SE1 */
-#define	  M66592_KSTS		 0x0002		  /* K State */
-#define	  M66592_JSTS		 0x0001		  /* J State */
-#define	  M66592_SE0		 0x0000		  /* SE0 */
+#define M66592_LNST		0x0003	/* b1-0: D+, D- line status */
+#define   M66592_SE1		 0x0003		/* SE1 */
+#define   M66592_KSTS		 0x0002		/* K State */
+#define   M66592_JSTS		 0x0001		/* J State */
+#define   M66592_SE0		 0x0000		/* SE0 */
 
 #define M66592_DVSTCTR		0x04
-#define	M66592_WKUP		0x0100	/* b8: Remote wakeup */
-#define	M66592_RWUPE		0x0080	/* b7: Remote wakeup sense */
-#define	M66592_USBRST		0x0040	/* b6: USB reset enable */
-#define	M66592_RESUME		0x0020	/* b5: Resume enable */
-#define	M66592_UACT		0x0010	/* b4: USB bus enable */
-#define	M66592_RHST		0x0003	/* b1-0: Reset handshake status */
-#define	  M66592_HSMODE		 0x0003		  /* Hi-Speed mode */
-#define	  M66592_FSMODE		 0x0002		  /* Full-Speed mode */
-#define	  M66592_HSPROC		 0x0001		  /* HS handshake is processing */
+#define M66592_WKUP		0x0100	/* b8: Remote wakeup */
+#define M66592_RWUPE		0x0080	/* b7: Remote wakeup sense */
+#define M66592_USBRST		0x0040	/* b6: USB reset enable */
+#define M66592_RESUME		0x0020	/* b5: Resume enable */
+#define M66592_UACT		0x0010	/* b4: USB bus enable */
+#define M66592_RHST		0x0003	/* b1-0: Reset handshake status */
+#define   M66592_HSMODE		 0x0003		/* Hi-Speed mode */
+#define   M66592_FSMODE		 0x0002		/* Full-Speed mode */
+#define   M66592_HSPROC		 0x0001		/* HS handshake is processing */
 
 #define M66592_TESTMODE		0x06
-#define	M66592_UTST		0x000F	/* b4-0: Test select */
-#define	  M66592_H_TST_PACKET	 0x000C		  /* HOST TEST Packet */
-#define	  M66592_H_TST_SE0_NAK	 0x000B		  /* HOST TEST SE0 NAK */
-#define	  M66592_H_TST_K	 0x000A		  /* HOST TEST K */
-#define	  M66592_H_TST_J	 0x0009		  /* HOST TEST J */
-#define	  M66592_H_TST_NORMAL	 0x0000		  /* HOST Normal Mode */
-#define	  M66592_P_TST_PACKET	 0x0004		  /* PERI TEST Packet */
-#define	  M66592_P_TST_SE0_NAK	 0x0003		  /* PERI TEST SE0 NAK */
-#define	  M66592_P_TST_K	 0x0002		  /* PERI TEST K */
-#define	  M66592_P_TST_J	 0x0001		  /* PERI TEST J */
-#define	  M66592_P_TST_NORMAL	 0x0000		  /* PERI Normal Mode */
+#define M66592_UTST		0x000F	/* b4-0: Test select */
+#define   M66592_H_TST_PACKET	 0x000C		/* HOST TEST Packet */
+#define   M66592_H_TST_SE0_NAK	 0x000B		/* HOST TEST SE0 NAK */
+#define   M66592_H_TST_K	 0x000A		/* HOST TEST K */
+#define   M66592_H_TST_J	 0x0009		/* HOST TEST J */
+#define   M66592_H_TST_NORMAL	 0x0000		/* HOST Normal Mode */
+#define   M66592_P_TST_PACKET	 0x0004		/* PERI TEST Packet */
+#define   M66592_P_TST_SE0_NAK	 0x0003		/* PERI TEST SE0 NAK */
+#define   M66592_P_TST_K	 0x0002		/* PERI TEST K */
+#define   M66592_P_TST_J	 0x0001		/* PERI TEST J */
+#define   M66592_P_TST_NORMAL	 0x0000		/* PERI Normal Mode */
 
 #define M66592_PINCFG		0x0A
-#define	M66592_LDRV		0x8000	/* b15: Drive Current Adjust */
-#define	M66592_BIGEND		0x0100	/* b8: Big endian mode */
+#define M66592_LDRV		0x8000	/* b15: Drive Current Adjust */
+#define M66592_BIGEND		0x0100	/* b8: Big endian mode */
 
 #define M66592_DMA0CFG		0x0C
 #define M66592_DMA1CFG		0x0E
-#define	M66592_DREQA		0x4000	/* b14: Dreq active select */
-#define	M66592_BURST		0x2000	/* b13: Burst mode */
-#define	M66592_DACKA		0x0400	/* b10: Dack active select */
-#define	M66592_DFORM		0x0380	/* b9-7: DMA mode select */
-#define	  M66592_CPU_ADR_RD_WR	 0x0000		  /* Address + RD/WR mode (CPU bus) */
-#define	  M66592_CPU_DACK_RD_WR	 0x0100		  /* DACK + RD/WR mode (CPU bus) */
-#define	  M66592_CPU_DACK_ONLY	 0x0180		  /* DACK only mode (CPU bus) */
-#define	  M66592_SPLIT_DACK_ONLY	 0x0200		  /* DACK only mode (SPLIT bus) */
-#define	  M66592_SPLIT_DACK_DSTB	 0x0300		  /* DACK + DSTB0 mode (SPLIT bus) */
-#define	M66592_DENDA		0x0040	/* b6: Dend active select */
-#define	M66592_PKTM		0x0020	/* b5: Packet mode */
-#define	M66592_DENDE		0x0010	/* b4: Dend enable */
-#define	M66592_OBUS		0x0004	/* b2: OUTbus mode */
+#define M66592_DREQA		0x4000	/* b14: Dreq active select */
+#define M66592_BURST		0x2000	/* b13: Burst mode */
+#define M66592_DACKA		0x0400	/* b10: Dack active select */
+#define M66592_DFORM		0x0380	/* b9-7: DMA mode select */
+#define   M66592_CPU_ADR_RD_WR	 0x0000   /* Address + RD/WR mode (CPU bus) */
+#define   M66592_CPU_DACK_RD_WR	 0x0100   /* DACK + RD/WR mode (CPU bus) */
+#define   M66592_CPU_DACK_ONLY	 0x0180   /* DACK only mode (CPU bus) */
+#define   M66592_SPLIT_DACK_ONLY 0x0200   /* DACK only mode (SPLIT bus) */
+#define   M66592_SPLIT_DACK_DSTB 0x0300   /* DACK + DSTB0 mode (SPLIT bus) */
+#define M66592_DENDA		0x0040	/* b6: Dend active select */
+#define M66592_PKTM		0x0020	/* b5: Packet mode */
+#define M66592_DENDE		0x0010	/* b4: Dend enable */
+#define M66592_OBUS		0x0004	/* b2: OUTbus mode */
 
 #define M66592_CFIFO		0x10
 #define M66592_D0FIFO		0x14
@@ -99,300 +99,300 @@
 #define M66592_CFIFOSEL		0x1E
 #define M66592_D0FIFOSEL	0x24
 #define M66592_D1FIFOSEL	0x2A
-#define	M66592_RCNT		0x8000	/* b15: Read count mode */
-#define	M66592_REW		0x4000	/* b14: Buffer rewind */
-#define	M66592_DCLRM		0x2000	/* b13: DMA buffer clear mode */
-#define	M66592_DREQE		0x1000	/* b12: DREQ output enable */
-#define	M66592_MBW		0x0400	/* b10: Maximum bit width for FIFO access */
-#define	  M66592_MBW_8		 0x0000	  /*  8bit */
-#define	  M66592_MBW_16		 0x0400		  /* 16bit */
-#define	M66592_TRENB		0x0200	/* b9: Transaction counter enable */
-#define	M66592_TRCLR		0x0100	/* b8: Transaction counter clear */
-#define	M66592_DEZPM		0x0080	/* b7: Zero-length packet additional mode */
-#define	M66592_ISEL		0x0020	/* b5: DCP FIFO port direction select */
-#define	M66592_CURPIPE		0x0007	/* b2-0: PIPE select */
+#define M66592_RCNT		0x8000	/* b15: Read count mode */
+#define M66592_REW		0x4000	/* b14: Buffer rewind */
+#define M66592_DCLRM		0x2000	/* b13: DMA buffer clear mode */
+#define M66592_DREQE		0x1000	/* b12: DREQ output enable */
+#define M66592_MBW		0x0400	/* b10: Maximum bit width for FIFO */
+#define   M66592_MBW_8		 0x0000   /*  8bit */
+#define   M66592_MBW_16		 0x0400   /* 16bit */
+#define M66592_TRENB		0x0200	/* b9: Transaction counter enable */
+#define M66592_TRCLR		0x0100	/* b8: Transaction counter clear */
+#define M66592_DEZPM		0x0080	/* b7: Zero-length packet mode */
+#define M66592_ISEL		0x0020	/* b5: DCP FIFO port direction select */
+#define M66592_CURPIPE		0x0007	/* b2-0: PIPE select */
 
 #define M66592_CFIFOCTR		0x20
 #define M66592_D0FIFOCTR	0x26
 #define M66592_D1FIFOCTR	0x2c
-#define	M66592_BVAL		0x8000	/* b15: Buffer valid flag */
-#define	M66592_BCLR		0x4000	/* b14: Buffer clear */
-#define	M66592_FRDY		0x2000	/* b13: FIFO ready */
-#define	M66592_DTLN		0x0FFF	/* b11-0: FIFO received data length */
+#define M66592_BVAL		0x8000	/* b15: Buffer valid flag */
+#define M66592_BCLR		0x4000	/* b14: Buffer clear */
+#define M66592_FRDY		0x2000	/* b13: FIFO ready */
+#define M66592_DTLN		0x0FFF	/* b11-0: FIFO received data length */
 
 #define M66592_CFIFOSIE		0x22
-#define	M66592_TGL		0x8000	/* b15: Buffer toggle */
-#define	M66592_SCLR		0x4000	/* b14: Buffer clear */
-#define	M66592_SBUSY		0x2000	/* b13: SIE_FIFO busy */
+#define M66592_TGL		0x8000	/* b15: Buffer toggle */
+#define M66592_SCLR		0x4000	/* b14: Buffer clear */
+#define M66592_SBUSY		0x2000	/* b13: SIE_FIFO busy */
 
 #define M66592_D0FIFOTRN	0x28
 #define M66592_D1FIFOTRN	0x2E
-#define	M66592_TRNCNT		0xFFFF	/* b15-0: Transaction counter */
+#define M66592_TRNCNT		0xFFFF	/* b15-0: Transaction counter */
 
 #define M66592_INTENB0	0x30
-#define	M66592_VBSE	0x8000	/* b15: VBUS interrupt */
-#define	M66592_RSME	0x4000	/* b14: Resume interrupt */
-#define	M66592_SOFE	0x2000	/* b13: Frame update interrupt */
-#define	M66592_DVSE	0x1000	/* b12: Device state transition interrupt */
-#define	M66592_CTRE	0x0800	/* b11: Control transfer stage transition interrupt */
-#define	M66592_BEMPE	0x0400	/* b10: Buffer empty interrupt */
-#define	M66592_NRDYE	0x0200	/* b9: Buffer not ready interrupt */
-#define	M66592_BRDYE	0x0100	/* b8: Buffer ready interrupt */
-#define	M66592_URST	0x0080	/* b7: USB reset detected interrupt */
-#define	M66592_SADR	0x0040	/* b6: Set address executed interrupt */
-#define	M66592_SCFG	0x0020	/* b5: Set configuration executed interrupt */
-#define	M66592_SUSP	0x0010	/* b4: Suspend detected interrupt */
-#define	M66592_WDST	0x0008	/* b3: Control write data stage completed interrupt */
-#define	M66592_RDST	0x0004	/* b2: Control read data stage completed interrupt */
-#define	M66592_CMPL	0x0002	/* b1: Control transfer complete interrupt */
-#define	M66592_SERR	0x0001	/* b0: Sequence error interrupt */
+#define M66592_VBSE	0x8000	/* b15: VBUS interrupt */
+#define M66592_RSME	0x4000	/* b14: Resume interrupt */
+#define M66592_SOFE	0x2000	/* b13: Frame update interrupt */
+#define M66592_DVSE	0x1000	/* b12: Device state transition interrupt */
+#define M66592_CTRE	0x0800	/* b11: Control transfer stage transition irq */
+#define M66592_BEMPE	0x0400	/* b10: Buffer empty interrupt */
+#define M66592_NRDYE	0x0200	/* b9: Buffer not ready interrupt */
+#define M66592_BRDYE	0x0100	/* b8: Buffer ready interrupt */
+#define M66592_URST	0x0080	/* b7: USB reset detected interrupt */
+#define M66592_SADR	0x0040	/* b6: Set address executed interrupt */
+#define M66592_SCFG	0x0020	/* b5: Set configuration executed interrupt */
+#define M66592_SUSP	0x0010	/* b4: Suspend detected interrupt */
+#define M66592_WDST	0x0008	/* b3: Control write data stage completed irq */
+#define M66592_RDST	0x0004	/* b2: Control read data stage completed irq */
+#define M66592_CMPL	0x0002	/* b1: Control transfer complete interrupt */
+#define M66592_SERR	0x0001	/* b0: Sequence error interrupt */
 
 #define M66592_INTENB1	0x32
-#define	M66592_BCHGE	0x4000	/* b14: USB us chenge interrupt */
-#define	M66592_DTCHE	0x1000	/* b12: Detach sense interrupt */
-#define	M66592_SIGNE	0x0020	/* b5: SETUP IGNORE interrupt */
-#define	M66592_SACKE	0x0010	/* b4: SETUP ACK interrupt */
-#define	M66592_BRDYM	0x0004	/* b2: BRDY clear timing */
-#define	M66592_INTL	0x0002	/* b1: Interrupt sense select */
-#define	M66592_PCSE	0x0001	/* b0: PCUT enable by CS assert */
+#define M66592_BCHGE	0x4000	/* b14: USB us chenge interrupt */
+#define M66592_DTCHE	0x1000	/* b12: Detach sense interrupt */
+#define M66592_SIGNE	0x0020	/* b5: SETUP IGNORE interrupt */
+#define M66592_SACKE	0x0010	/* b4: SETUP ACK interrupt */
+#define M66592_BRDYM	0x0004	/* b2: BRDY clear timing */
+#define M66592_INTL	0x0002	/* b1: Interrupt sense select */
+#define M66592_PCSE	0x0001	/* b0: PCUT enable by CS assert */
 
 #define M66592_BRDYENB		0x36
 #define M66592_BRDYSTS		0x46
-#define	M66592_BRDY7		0x0080	/* b7: PIPE7 */
-#define	M66592_BRDY6		0x0040	/* b6: PIPE6 */
-#define	M66592_BRDY5		0x0020	/* b5: PIPE5 */
-#define	M66592_BRDY4		0x0010	/* b4: PIPE4 */
-#define	M66592_BRDY3		0x0008	/* b3: PIPE3 */
-#define	M66592_BRDY2		0x0004	/* b2: PIPE2 */
-#define	M66592_BRDY1		0x0002	/* b1: PIPE1 */
-#define	M66592_BRDY0		0x0001	/* b1: PIPE0 */
+#define M66592_BRDY7		0x0080	/* b7: PIPE7 */
+#define M66592_BRDY6		0x0040	/* b6: PIPE6 */
+#define M66592_BRDY5		0x0020	/* b5: PIPE5 */
+#define M66592_BRDY4		0x0010	/* b4: PIPE4 */
+#define M66592_BRDY3		0x0008	/* b3: PIPE3 */
+#define M66592_BRDY2		0x0004	/* b2: PIPE2 */
+#define M66592_BRDY1		0x0002	/* b1: PIPE1 */
+#define M66592_BRDY0		0x0001	/* b1: PIPE0 */
 
 #define M66592_NRDYENB		0x38
 #define M66592_NRDYSTS		0x48
-#define	M66592_NRDY7		0x0080	/* b7: PIPE7 */
-#define	M66592_NRDY6		0x0040	/* b6: PIPE6 */
-#define	M66592_NRDY5		0x0020	/* b5: PIPE5 */
-#define	M66592_NRDY4		0x0010	/* b4: PIPE4 */
-#define	M66592_NRDY3		0x0008	/* b3: PIPE3 */
-#define	M66592_NRDY2		0x0004	/* b2: PIPE2 */
-#define	M66592_NRDY1		0x0002	/* b1: PIPE1 */
-#define	M66592_NRDY0		0x0001	/* b1: PIPE0 */
+#define M66592_NRDY7		0x0080	/* b7: PIPE7 */
+#define M66592_NRDY6		0x0040	/* b6: PIPE6 */
+#define M66592_NRDY5		0x0020	/* b5: PIPE5 */
+#define M66592_NRDY4		0x0010	/* b4: PIPE4 */
+#define M66592_NRDY3		0x0008	/* b3: PIPE3 */
+#define M66592_NRDY2		0x0004	/* b2: PIPE2 */
+#define M66592_NRDY1		0x0002	/* b1: PIPE1 */
+#define M66592_NRDY0		0x0001	/* b1: PIPE0 */
 
 #define M66592_BEMPENB		0x3A
 #define M66592_BEMPSTS		0x4A
-#define	M66592_BEMP7		0x0080	/* b7: PIPE7 */
-#define	M66592_BEMP6		0x0040	/* b6: PIPE6 */
-#define	M66592_BEMP5		0x0020	/* b5: PIPE5 */
-#define	M66592_BEMP4		0x0010	/* b4: PIPE4 */
-#define	M66592_BEMP3		0x0008	/* b3: PIPE3 */
-#define	M66592_BEMP2		0x0004	/* b2: PIPE2 */
-#define	M66592_BEMP1		0x0002	/* b1: PIPE1 */
-#define	M66592_BEMP0		0x0001	/* b0: PIPE0 */
+#define M66592_BEMP7		0x0080	/* b7: PIPE7 */
+#define M66592_BEMP6		0x0040	/* b6: PIPE6 */
+#define M66592_BEMP5		0x0020	/* b5: PIPE5 */
+#define M66592_BEMP4		0x0010	/* b4: PIPE4 */
+#define M66592_BEMP3		0x0008	/* b3: PIPE3 */
+#define M66592_BEMP2		0x0004	/* b2: PIPE2 */
+#define M66592_BEMP1		0x0002	/* b1: PIPE1 */
+#define M66592_BEMP0		0x0001	/* b0: PIPE0 */
 
 #define M66592_SOFCFG		0x3C
-#define	M66592_SOFM		0x000C	/* b3-2: SOF palse mode */
-#define	  M66592_SOF_125US	 0x0008		  /* SOF OUT 125us uFrame Signal */
-#define	  M66592_SOF_1MS	 0x0004		  /* SOF OUT 1ms Frame Signal */
-#define	  M66592_SOF_DISABLE	 0x0000		  /* SOF OUT Disable */
+#define M66592_SOFM		0x000C	/* b3-2: SOF palse mode */
+#define   M66592_SOF_125US	 0x0008   /* SOF OUT 125us uFrame Signal */
+#define   M66592_SOF_1MS	 0x0004   /* SOF OUT 1ms Frame Signal */
+#define   M66592_SOF_DISABLE	 0x0000   /* SOF OUT Disable */
 
 #define M66592_INTSTS0		0x40
-#define	M66592_VBINT		0x8000	/* b15: VBUS interrupt */
-#define	M66592_RESM		0x4000	/* b14: Resume interrupt */
-#define	M66592_SOFR		0x2000	/* b13: SOF frame update interrupt */
-#define	M66592_DVST		0x1000	/* b12: Device state transition interrupt */
-#define	M66592_CTRT		0x0800	/* b11: Control transfer stage transition interrupt */
-#define	M66592_BEMP		0x0400	/* b10: Buffer empty interrupt */
-#define	M66592_NRDY		0x0200	/* b9: Buffer not ready interrupt */
-#define	M66592_BRDY		0x0100	/* b8: Buffer ready interrupt */
-#define	M66592_VBSTS		0x0080	/* b7: VBUS input port */
-#define	M66592_DVSQ		0x0070	/* b6-4: Device state */
-#define	  M66592_DS_SPD_CNFG	 0x0070		  /* Suspend Configured */
-#define	  M66592_DS_SPD_ADDR	 0x0060		  /* Suspend Address */
-#define	  M66592_DS_SPD_DFLT	 0x0050		  /* Suspend Default */
-#define	  M66592_DS_SPD_POWR	 0x0040		  /* Suspend Powered */
-#define	  M66592_DS_SUSP	 0x0040		  /* Suspend */
-#define	  M66592_DS_CNFG	 0x0030		  /* Configured */
-#define	  M66592_DS_ADDS	 0x0020		  /* Address */
-#define	  M66592_DS_DFLT	 0x0010		  /* Default */
-#define	  M66592_DS_POWR	 0x0000		  /* Powered */
-#define	M66592_DVSQS		0x0030	/* b5-4: Device state */
-#define	M66592_VALID		0x0008	/* b3: Setup packet detected flag */
-#define	M66592_CTSQ		0x0007	/* b2-0: Control transfer stage */
-#define	  M66592_CS_SQER	 0x0006		  /* Sequence error */
-#define	  M66592_CS_WRND	 0x0005		  /* Control write nodata status stage */
-#define	  M66592_CS_WRSS	 0x0004		  /* Control write status stage */
-#define	  M66592_CS_WRDS	 0x0003		  /* Control write data stage */
-#define	  M66592_CS_RDSS	 0x0002		  /* Control read status stage */
-#define	  M66592_CS_RDDS	 0x0001		  /* Control read data stage */
-#define	  M66592_CS_IDST	 0x0000		  /* Idle or setup stage */
+#define M66592_VBINT		0x8000	/* b15: VBUS interrupt */
+#define M66592_RESM		0x4000	/* b14: Resume interrupt */
+#define M66592_SOFR		0x2000	/* b13: SOF frame update interrupt */
+#define M66592_DVST		0x1000	/* b12: Device state transition */
+#define M66592_CTRT		0x0800	/* b11: Control stage transition */
+#define M66592_BEMP		0x0400	/* b10: Buffer empty interrupt */
+#define M66592_NRDY		0x0200	/* b9: Buffer not ready interrupt */
+#define M66592_BRDY		0x0100	/* b8: Buffer ready interrupt */
+#define M66592_VBSTS		0x0080	/* b7: VBUS input port */
+#define M66592_DVSQ		0x0070	/* b6-4: Device state */
+#define   M66592_DS_SPD_CNFG	 0x0070	   /* Suspend Configured */
+#define   M66592_DS_SPD_ADDR	 0x0060	   /* Suspend Address */
+#define   M66592_DS_SPD_DFLT	 0x0050	   /* Suspend Default */
+#define   M66592_DS_SPD_POWR	 0x0040	   /* Suspend Powered */
+#define   M66592_DS_SUSP	 0x0040	   /* Suspend */
+#define   M66592_DS_CNFG	 0x0030	   /* Configured */
+#define   M66592_DS_ADDS	 0x0020	   /* Address */
+#define   M66592_DS_DFLT	 0x0010	   /* Default */
+#define   M66592_DS_POWR	 0x0000	   /* Powered */
+#define M66592_DVSQS		0x0030	/* b5-4: Device state */
+#define M66592_VALID		0x0008	/* b3: Setup packet detected flag */
+#define M66592_CTSQ		0x0007	/* b2-0: Control transfer stage */
+#define   M66592_CS_SQER	 0x0006	  /* Sequence error */
+#define   M66592_CS_WRND	 0x0005	  /* Control write nodata status */
+#define   M66592_CS_WRSS	 0x0004	  /* Control write status stage */
+#define   M66592_CS_WRDS	 0x0003	  /* Control write data stage */
+#define   M66592_CS_RDSS	 0x0002	  /* Control read status stage */
+#define   M66592_CS_RDDS	 0x0001	  /* Control read data stage */
+#define   M66592_CS_IDST	 0x0000	  /* Idle or setup stage */
 
 #define M66592_INTSTS1		0x42
-#define	M66592_BCHG		0x4000	/* b14: USB bus chenge interrupt */
-#define	M66592_DTCH		0x1000	/* b12: Detach sense interrupt */
-#define	M66592_SIGN		0x0020	/* b5: SETUP IGNORE interrupt */
-#define	M66592_SACK		0x0010	/* b4: SETUP ACK interrupt */
+#define M66592_BCHG		0x4000	/* b14: USB bus chenge interrupt */
+#define M66592_DTCH		0x1000	/* b12: Detach sense interrupt */
+#define M66592_SIGN		0x0020	/* b5: SETUP IGNORE interrupt */
+#define M66592_SACK		0x0010	/* b4: SETUP ACK interrupt */
 
 #define M66592_FRMNUM		0x4C
-#define	M66592_OVRN		0x8000	/* b15: Overrun error */
-#define	M66592_CRCE		0x4000	/* b14: Received data error */
-#define	M66592_SOFRM		0x0800	/* b11: SOF output mode */
-#define	M66592_FRNM		0x07FF	/* b10-0: Frame number */
+#define M66592_OVRN		0x8000	/* b15: Overrun error */
+#define M66592_CRCE		0x4000	/* b14: Received data error */
+#define M66592_SOFRM		0x0800	/* b11: SOF output mode */
+#define M66592_FRNM		0x07FF	/* b10-0: Frame number */
 
 #define M66592_UFRMNUM		0x4E
-#define	M66592_UFRNM		0x0007	/* b2-0: Micro frame number */
+#define M66592_UFRNM		0x0007	/* b2-0: Micro frame number */
 
 #define M66592_RECOVER		0x50
-#define	M66592_STSRECOV		0x0700	/* Status recovery */
-#define	  M66592_STSR_HI	 0x0400		  /* FULL(0) or HI(1) Speed */
-#define	  M66592_STSR_DEFAULT	 0x0100		  /* Default state */
-#define	  M66592_STSR_ADDRESS	 0x0200		  /* Address state */
-#define	  M66592_STSR_CONFIG	 0x0300		  /* Configured state */
-#define	M66592_USBADDR		0x007F	/* b6-0: USB address */
+#define M66592_STSRECOV		0x0700	/* Status recovery */
+#define   M66592_STSR_HI	 0x0400		  /* FULL(0) or HI(1) Speed */
+#define   M66592_STSR_DEFAULT	 0x0100		  /* Default state */
+#define   M66592_STSR_ADDRESS	 0x0200		  /* Address state */
+#define   M66592_STSR_CONFIG	 0x0300		  /* Configured state */
+#define M66592_USBADDR		0x007F	/* b6-0: USB address */
 
 #define M66592_USBREQ			0x54
-#define	M66592_bRequest			0xFF00	/* b15-8: bRequest */
-#define	  M66592_GET_STATUS		 0x0000
-#define	  M66592_CLEAR_FEATURE		 0x0100
-#define	  M66592_ReqRESERVED		 0x0200
-#define	  M66592_SET_FEATURE		 0x0300
-#define	  M66592_ReqRESERVED1		 0x0400
-#define	  M66592_SET_ADDRESS		 0x0500
-#define	  M66592_GET_DESCRIPTOR		 0x0600
-#define	  M66592_SET_DESCRIPTOR		 0x0700
-#define	  M66592_GET_CONFIGURATION	 0x0800
-#define	  M66592_SET_CONFIGURATION	 0x0900
-#define	  M66592_GET_INTERFACE		 0x0A00
-#define	  M66592_SET_INTERFACE		 0x0B00
-#define	  M66592_SYNCH_FRAME		 0x0C00
-#define	M66592_bmRequestType		0x00FF	/* b7-0: bmRequestType */
-#define	M66592_bmRequestTypeDir		0x0080	/* b7  : Data transfer direction */
-#define	  M66592_HOST_TO_DEVICE		 0x0000
-#define	  M66592_DEVICE_TO_HOST		 0x0080
-#define	M66592_bmRequestTypeType	0x0060	/* b6-5: Type */
-#define	  M66592_STANDARD		 0x0000
-#define	  M66592_CLASS			 0x0020
-#define	  M66592_VENDOR			 0x0040
-#define	M66592_bmRequestTypeRecip	0x001F	/* b4-0: Recipient */
-#define	  M66592_DEVICE			 0x0000
-#define	  M66592_INTERFACE		 0x0001
-#define	  M66592_ENDPOINT		 0x0002
+#define M66592_bRequest			0xFF00	/* b15-8: bRequest */
+#define   M66592_GET_STATUS		 0x0000
+#define   M66592_CLEAR_FEATURE		 0x0100
+#define   M66592_ReqRESERVED		 0x0200
+#define   M66592_SET_FEATURE		 0x0300
+#define   M66592_ReqRESERVED1		 0x0400
+#define   M66592_SET_ADDRESS		 0x0500
+#define   M66592_GET_DESCRIPTOR		 0x0600
+#define   M66592_SET_DESCRIPTOR		 0x0700
+#define   M66592_GET_CONFIGURATION	 0x0800
+#define   M66592_SET_CONFIGURATION	 0x0900
+#define   M66592_GET_INTERFACE		 0x0A00
+#define   M66592_SET_INTERFACE		 0x0B00
+#define   M66592_SYNCH_FRAME		 0x0C00
+#define M66592_bmRequestType		0x00FF	/* b7-0: bmRequestType */
+#define M66592_bmRequestTypeDir		0x0080	/* b7  : Data direction */
+#define   M66592_HOST_TO_DEVICE		 0x0000
+#define   M66592_DEVICE_TO_HOST		 0x0080
+#define M66592_bmRequestTypeType	0x0060	/* b6-5: Type */
+#define   M66592_STANDARD		 0x0000
+#define   M66592_CLASS			 0x0020
+#define   M66592_VENDOR			 0x0040
+#define M66592_bmRequestTypeRecip	0x001F	/* b4-0: Recipient */
+#define   M66592_DEVICE			 0x0000
+#define   M66592_INTERFACE		 0x0001
+#define   M66592_ENDPOINT		 0x0002
 
 #define M66592_USBVAL				0x56
-#define	M66592_wValue				0xFFFF	/* b15-0: wValue */
+#define M66592_wValue				0xFFFF	/* b15-0: wValue */
 /* Standard Feature Selector */
-#define	  M66592_ENDPOINT_HALT			0x0000
-#define	  M66592_DEVICE_REMOTE_WAKEUP		0x0001
-#define	  M66592_TEST_MODE			0x0002
+#define   M66592_ENDPOINT_HALT			0x0000
+#define   M66592_DEVICE_REMOTE_WAKEUP		0x0001
+#define   M66592_TEST_MODE			0x0002
 /* Descriptor Types */
-#define	M66592_DT_TYPE				0xFF00
-#define	M66592_GET_DT_TYPE(v)			(((v) & DT_TYPE) >> 8)
-#define	  M66592_DT_DEVICE			0x01
-#define	  M66592_DT_CONFIGURATION		0x02
-#define	  M66592_DT_STRING			0x03
-#define	  M66592_DT_INTERFACE			0x04
-#define	  M66592_DT_ENDPOINT			0x05
-#define	  M66592_DT_DEVICE_QUALIFIER		0x06
-#define	  M66592_DT_OTHER_SPEED_CONFIGURATION	0x07
-#define	  M66592_DT_INTERFACE_POWER		0x08
-#define	M66592_DT_INDEX				0x00FF
-#define	M66592_CONF_NUM				0x00FF
-#define	M66592_ALT_SET				0x00FF
+#define M66592_DT_TYPE				0xFF00
+#define M66592_GET_DT_TYPE(v)			(((v) & DT_TYPE) >> 8)
+#define   M66592_DT_DEVICE			0x01
+#define   M66592_DT_CONFIGURATION		0x02
+#define   M66592_DT_STRING			0x03
+#define   M66592_DT_INTERFACE			0x04
+#define   M66592_DT_ENDPOINT			0x05
+#define   M66592_DT_DEVICE_QUALIFIER		0x06
+#define   M66592_DT_OTHER_SPEED_CONFIGURATION	0x07
+#define   M66592_DT_INTERFACE_POWER		0x08
+#define M66592_DT_INDEX				0x00FF
+#define M66592_CONF_NUM				0x00FF
+#define M66592_ALT_SET				0x00FF
 
 #define M66592_USBINDEX			0x58
-#define	M66592_wIndex			0xFFFF	/* b15-0: wIndex */
-#define	M66592_TEST_SELECT		0xFF00	/* b15-b8: Test Mode Selectors */
-#define	  M66592_TEST_J			 0x0100		  /* Test_J */
-#define	  M66592_TEST_K			 0x0200		  /* Test_K */
-#define	  M66592_TEST_SE0_NAK		 0x0300		  /* Test_SE0_NAK */
-#define	  M66592_TEST_PACKET		 0x0400		  /* Test_Packet */
-#define	  M66592_TEST_FORCE_ENABLE	 0x0500		  /* Test_Force_Enable */
-#define	  M66592_TEST_STSelectors	 0x0600		  /* Standard test selectors */
-#define	  M66592_TEST_Reserved		 0x4000		  /* Reserved */
-#define	  M66592_TEST_VSTModes		 0xC000		  /* Vendor-specific test modes */
-#define	M66592_EP_DIR			0x0080	/* b7: Endpoint Direction */
-#define	  M66592_EP_DIR_IN		 0x0080
-#define	  M66592_EP_DIR_OUT		 0x0000
+#define M66592_wIndex			0xFFFF	/* b15-0: wIndex */
+#define M66592_TEST_SELECT		0xFF00	/* b15-b8: Test Mode */
+#define   M66592_TEST_J			 0x0100	  /* Test_J */
+#define   M66592_TEST_K			 0x0200	  /* Test_K */
+#define   M66592_TEST_SE0_NAK		 0x0300	  /* Test_SE0_NAK */
+#define   M66592_TEST_PACKET		 0x0400	  /* Test_Packet */
+#define   M66592_TEST_FORCE_ENABLE	 0x0500	  /* Test_Force_Enable */
+#define   M66592_TEST_STSelectors	 0x0600	  /* Standard test selectors */
+#define   M66592_TEST_Reserved		 0x4000	  /* Reserved */
+#define   M66592_TEST_VSTModes		 0xC000	  /* Vendor-specific tests */
+#define M66592_EP_DIR			0x0080	/* b7: Endpoint Direction */
+#define   M66592_EP_DIR_IN		 0x0080
+#define   M66592_EP_DIR_OUT		 0x0000
 
 #define M66592_USBLENG		0x5A
-#define	M66592_wLength		0xFFFF	/* b15-0: wLength */
+#define M66592_wLength		0xFFFF	/* b15-0: wLength */
 
 #define M66592_DCPCFG		0x5C
-#define	M66592_CNTMD		0x0100	/* b8: Continuous transfer mode select */
-#define	M66592_DIR		0x0010	/* b4: Control transfer DIR select */
+#define M66592_CNTMD		0x0100	/* b8: Continuous transfer mode */
+#define M66592_DIR		0x0010	/* b4: Control transfer DIR select */
 
 #define M66592_DCPMAXP		0x5E
-#define	M66592_DEVSEL		0xC000	/* b15-14: Device address select */
-#define	  M66592_DEVICE_0	 0x0000		  /* Device address 0 */
-#define	  M66592_DEVICE_1	 0x4000		  /* Device address 1 */
-#define	  M66592_DEVICE_2	 0x8000		  /* Device address 2 */
-#define	  M66592_DEVICE_3	 0xC000		  /* Device address 3 */
-#define	M66592_MAXP		0x007F	/* b6-0: Maxpacket size of default control pipe */
+#define M66592_DEVSEL		0xC000	/* b15-14: Device address select */
+#define   M66592_DEVICE_0	 0x0000		  /* Device address 0 */
+#define   M66592_DEVICE_1	 0x4000		  /* Device address 1 */
+#define   M66592_DEVICE_2	 0x8000		  /* Device address 2 */
+#define   M66592_DEVICE_3	 0xC000		  /* Device address 3 */
+#define M66592_MAXP		0x007F	/* b6-0: Maxpacket size of ep0 */
 
 #define M66592_DCPCTR		0x60
-#define	M66592_BSTS		0x8000	/* b15: Buffer status */
-#define	M66592_SUREQ		0x4000	/* b14: Send USB request  */
-#define	M66592_SQCLR		0x0100	/* b8: Sequence toggle bit clear */
-#define	M66592_SQSET		0x0080	/* b7: Sequence toggle bit set */
-#define	M66592_SQMON		0x0040	/* b6: Sequence toggle bit monitor */
-#define	M66592_CCPL		0x0004	/* b2: Enable control transfer complete */
-#define	M66592_PID		0x0003	/* b1-0: Response PID */
-#define	  M66592_PID_STALL	 0x0002		  /* STALL */
-#define	  M66592_PID_BUF	 0x0001		  /* BUF */
-#define	  M66592_PID_NAK	 0x0000		  /* NAK */
+#define M66592_BSTS		0x8000	/* b15: Buffer status */
+#define M66592_SUREQ		0x4000	/* b14: Send USB request  */
+#define M66592_SQCLR		0x0100	/* b8: Sequence toggle bit clear */
+#define M66592_SQSET		0x0080	/* b7: Sequence toggle bit set */
+#define M66592_SQMON		0x0040	/* b6: Sequence toggle bit monitor */
+#define M66592_CCPL		0x0004	/* b2: control transfer complete */
+#define M66592_PID		0x0003	/* b1-0: Response PID */
+#define   M66592_PID_STALL	 0x0002		  /* STALL */
+#define   M66592_PID_BUF	 0x0001		  /* BUF */
+#define   M66592_PID_NAK	 0x0000		  /* NAK */
 
 #define M66592_PIPESEL		0x64
-#define	M66592_PIPENM		0x0007	/* b2-0: Pipe select */
-#define	  M66592_PIPE0		 0x0000		  /* PIPE 0 */
-#define	  M66592_PIPE1		 0x0001		  /* PIPE 1 */
-#define	  M66592_PIPE2		 0x0002		  /* PIPE 2 */
-#define	  M66592_PIPE3		 0x0003		  /* PIPE 3 */
-#define	  M66592_PIPE4		 0x0004		  /* PIPE 4 */
-#define	  M66592_PIPE5		 0x0005		  /* PIPE 5 */
-#define	  M66592_PIPE6		 0x0006		  /* PIPE 6 */
-#define	  M66592_PIPE7		 0x0007		  /* PIPE 7 */
+#define M66592_PIPENM		0x0007	/* b2-0: Pipe select */
+#define   M66592_PIPE0		 0x0000		  /* PIPE 0 */
+#define   M66592_PIPE1		 0x0001		  /* PIPE 1 */
+#define   M66592_PIPE2		 0x0002		  /* PIPE 2 */
+#define   M66592_PIPE3		 0x0003		  /* PIPE 3 */
+#define   M66592_PIPE4		 0x0004		  /* PIPE 4 */
+#define   M66592_PIPE5		 0x0005		  /* PIPE 5 */
+#define   M66592_PIPE6		 0x0006		  /* PIPE 6 */
+#define   M66592_PIPE7		 0x0007		  /* PIPE 7 */
 
 #define M66592_PIPECFG		0x66
-#define	M66592_TYP		0xC000	/* b15-14: Transfer type */
-#define	  M66592_ISO		 0xC000		  /* Isochronous */
-#define	  M66592_INT		 0x8000		  /* Interrupt */
-#define	  M66592_BULK		 0x4000		  /* Bulk */
-#define	M66592_BFRE		0x0400	/* b10: Buffer ready interrupt mode select */
-#define	M66592_DBLB		0x0200	/* b9: Double buffer mode select */
-#define	M66592_CNTMD		0x0100	/* b8: Continuous transfer mode select */
-#define	M66592_SHTNAK		0x0080	/* b7: Transfer end NAK */
-#define	M66592_DIR		0x0010	/* b4: Transfer direction select */
-#define	  M66592_DIR_H_OUT	 0x0010		  /* HOST OUT */
-#define	  M66592_DIR_P_IN	 0x0010		  /* PERI IN */
-#define	  M66592_DIR_H_IN	 0x0000		  /* HOST IN */
-#define	  M66592_DIR_P_OUT	 0x0000		  /* PERI OUT */
-#define	M66592_EPNUM		0x000F	/* b3-0: Eendpoint number select */
-#define	  M66592_EP1		 0x0001
-#define	  M66592_EP2		 0x0002
-#define	  M66592_EP3		 0x0003
-#define	  M66592_EP4		 0x0004
-#define	  M66592_EP5		 0x0005
-#define	  M66592_EP6		 0x0006
-#define	  M66592_EP7		 0x0007
-#define	  M66592_EP8		 0x0008
-#define	  M66592_EP9		 0x0009
-#define	  M66592_EP10		 0x000A
-#define	  M66592_EP11		 0x000B
-#define	  M66592_EP12		 0x000C
-#define	  M66592_EP13		 0x000D
-#define	  M66592_EP14		 0x000E
-#define	  M66592_EP15		 0x000F
+#define M66592_TYP		0xC000	/* b15-14: Transfer type */
+#define   M66592_ISO		 0xC000		  /* Isochronous */
+#define   M66592_INT		 0x8000		  /* Interrupt */
+#define   M66592_BULK		 0x4000		  /* Bulk */
+#define M66592_BFRE		0x0400	/* b10: Buffer ready interrupt mode */
+#define M66592_DBLB		0x0200	/* b9: Double buffer mode select */
+#define M66592_CNTMD		0x0100	/* b8: Continuous transfer mode */
+#define M66592_SHTNAK		0x0080	/* b7: Transfer end NAK */
+#define M66592_DIR		0x0010	/* b4: Transfer direction select */
+#define   M66592_DIR_H_OUT	 0x0010		  /* HOST OUT */
+#define   M66592_DIR_P_IN	 0x0010		  /* PERI IN */
+#define   M66592_DIR_H_IN	 0x0000		  /* HOST IN */
+#define   M66592_DIR_P_OUT	 0x0000		  /* PERI OUT */
+#define M66592_EPNUM		0x000F	/* b3-0: Eendpoint number select */
+#define   M66592_EP1		 0x0001
+#define   M66592_EP2		 0x0002
+#define   M66592_EP3		 0x0003
+#define   M66592_EP4		 0x0004
+#define   M66592_EP5		 0x0005
+#define   M66592_EP6		 0x0006
+#define   M66592_EP7		 0x0007
+#define   M66592_EP8		 0x0008
+#define   M66592_EP9		 0x0009
+#define   M66592_EP10		 0x000A
+#define   M66592_EP11		 0x000B
+#define   M66592_EP12		 0x000C
+#define   M66592_EP13		 0x000D
+#define   M66592_EP14		 0x000E
+#define   M66592_EP15		 0x000F
 
 #define M66592_PIPEBUF		0x68
-#define	M66592_BUFSIZE		0x7C00	/* b14-10: Pipe buffer size */
-#define	M66592_BUF_SIZE(x)	((((x) / 64) - 1) << 10)
-#define	M66592_BUFNMB		0x00FF	/* b7-0: Pipe buffer number */
+#define M66592_BUFSIZE		0x7C00	/* b14-10: Pipe buffer size */
+#define M66592_BUF_SIZE(x)	((((x) / 64) - 1) << 10)
+#define M66592_BUFNMB		0x00FF	/* b7-0: Pipe buffer number */
 
 #define M66592_PIPEMAXP		0x6A
-#define	M66592_MXPS		0x07FF	/* b10-0: Maxpacket size */
+#define M66592_MXPS		0x07FF	/* b10-0: Maxpacket size */
 
 #define M66592_PIPEPERI		0x6C
-#define	M66592_IFIS		0x1000	/* b12: Isochronous in-buffer flush mode select */
-#define	M66592_IITV		0x0007	/* b2-0: Isochronous interval */
+#define M66592_IFIS		0x1000	/* b12: ISO in-buffer flush mode */
+#define M66592_IITV		0x0007	/* b2-0: ISO interval */
 
 #define M66592_PIPE1CTR		0x70
 #define M66592_PIPE2CTR		0x72
@@ -401,19 +401,17 @@
 #define M66592_PIPE5CTR		0x78
 #define M66592_PIPE6CTR		0x7A
 #define M66592_PIPE7CTR		0x7C
-#define	M66592_BSTS		0x8000	/* b15: Buffer status */
-#define	M66592_INBUFM		0x4000	/* b14: IN buffer monitor (Only for PIPE1 to 5) */
-#define	M66592_ACLRM		0x0200	/* b9: Out buffer auto clear mode */
-#define	M66592_SQCLR		0x0100	/* b8: Sequence toggle bit clear */
-#define	M66592_SQSET		0x0080	/* b7: Sequence toggle bit set */
-#define	M66592_SQMON		0x0040	/* b6: Sequence toggle bit monitor */
-#define	M66592_PID		0x0003	/* b1-0: Response PID */
+#define M66592_BSTS		0x8000	/* b15: Buffer status */
+#define M66592_INBUFM		0x4000	/* b14: IN buffer monitor (PIPE 1-5) */
+#define M66592_ACLRM		0x0200	/* b9: Out buffer auto clear mode */
+#define M66592_SQCLR		0x0100	/* b8: Sequence toggle bit clear */
+#define M66592_SQSET		0x0080	/* b7: Sequence toggle bit set */
+#define M66592_SQMON		0x0040	/* b6: Sequence toggle bit monitor */
+#define M66592_PID		0x0003	/* b1-0: Response PID */
 
 #define M66592_INVALID_REG	0x7E
 
 
-#define __iomem
-
 #define get_pipectr_addr(pipenum)	(M66592_PIPE1CTR + (pipenum - 1) * 2)
 
 #define M66592_MAX_SAMPLING	10
@@ -449,7 +447,7 @@ struct m66592_ep {
 	struct m66592		*m66592;
 
 	struct list_head	queue;
-	unsigned 		busy:1;
+	unsigned		busy:1;
 	unsigned		internal_ccpl:1;	/* use only control */
 
 	/* this member can able to after m66592_enable */
@@ -477,7 +475,7 @@ struct m66592 {
 	struct m66592_ep	*epaddr2ep[16];
 
 	struct usb_request	*ep0_req;	/* for internal request */
-	u16			*ep0_buf;	/* for internal request */
+	u16			ep0_data;	/* for internal request */
 
 	struct timer_list	timer;
 
@@ -527,8 +525,8 @@ static inline u16 m66592_read(struct m66
 }
 
 static inline void m66592_read_fifo(struct m66592 *m66592,
-				    unsigned long offset,
-				    void *buf, unsigned long len)
+		unsigned long offset,
+		void *buf, unsigned long len)
 {
 	unsigned long fifoaddr = (unsigned long)m66592->reg + offset;
 
@@ -543,8 +541,8 @@ static inline void m66592_write(struct m
 }
 
 static inline void m66592_write_fifo(struct m66592 *m66592,
-				     unsigned long offset,
-				     void *buf, unsigned long len)
+		unsigned long offset,
+		void *buf, unsigned long len)
 {
 	unsigned long fifoaddr = (unsigned long)m66592->reg + offset;
 	unsigned long odd = len & 0x0001;
@@ -558,7 +556,7 @@ static inline void m66592_write_fifo(str
 }
 
 static inline void m66592_mdfy(struct m66592 *m66592, u16 val, u16 pat,
-			       unsigned long offset)
+		unsigned long offset)
 {
 	u16 tmp;
 	tmp = m66592_read(m66592, offset);
