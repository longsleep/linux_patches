From stf_xl@wp.pl Mon Aug 20 14:31:42 2007
From: Stanislaw Gruszka <stf_xl@wp.pl>
Date: Mon, 20 Aug 2007 23:21:06 +0200
Subject: UEAGLE: Allow user to choose input interface alternate setting
To: Greg KH <greg@kroah.com>
Cc: linux-usb-devel@lists.sourceforge.net, usbatm@lists.infradead.org, ueagleatm-dev@gna.org, linux-kernel@vger.kernel.org
Message-ID: <200708202321.06653.stf_xl@wp.pl>
Content-Disposition: inline



Let's user control how much USB bus bandwidth will be reserved by
ueagle-atm device. This make possible to share bus with other devices
when ueagle-atm driver works in isochronous mode.

Signed-off-by: Stanislaw Gruszka <stf_xl@wp.pl>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/atm/ueagle-atm.c |   28 ++++++++++++----------------
 1 file changed, 12 insertions(+), 16 deletions(-)

--- a/drivers/usb/atm/ueagle-atm.c
+++ b/drivers/usb/atm/ueagle-atm.c
@@ -538,15 +538,16 @@ static const char *chip_name[] = {"ADI93
 
 static int modem_index;
 static unsigned int debug;
-static int use_iso[NB_MODEM] = {[0 ... (NB_MODEM - 1)] = 1};
+static unsigned int altsetting[NB_MODEM] = {[0 ... (NB_MODEM - 1)] = FASTEST_ISO_INTF};
 static int sync_wait[NB_MODEM];
 static char *cmv_file[NB_MODEM];
 static int annex[NB_MODEM];
 
 module_param(debug, uint, 0644);
 MODULE_PARM_DESC(debug, "module debug level (0=off,1=on,2=verbose)");
-module_param_array(use_iso, bool, NULL, 0644);
-MODULE_PARM_DESC(use_iso, "use isochronous usb pipe for incoming traffic");
+module_param_array(altsetting, uint, NULL, 0644);
+MODULE_PARM_DESC(altsetting, "alternate setting for incoming traffic: 0=bulk, "
+			     "1=isoc slowest, ... , 8=isoc fastest (default)");
 module_param_array(sync_wait, bool, NULL, 0644);
 MODULE_PARM_DESC(sync_wait, "wait the synchronisation before starting ATM");
 module_param_array(cmv_file, charp, NULL, 0644);
@@ -1254,7 +1255,7 @@ static void uea_set_bulk_timeout(struct 
 	 */
 
 	if (UEA_CHIP_VERSION(sc) == ADI930 ||
-	    use_iso[sc->modem_index] > 0 ||
+	    altsetting[sc->modem_index] > 0 ||
 	    sc->stats.phy.dsrate == dsrate)
 		return;
 
@@ -2459,6 +2460,7 @@ static int uea_bind(struct usbatm_data *
 	struct usb_device *usb = interface_to_usbdev(intf);
 	struct uea_softc *sc;
 	int ret, ifnum = intf->altsetting->desc.bInterfaceNumber;
+	unsigned int alt;
 
 	uea_enters(usb);
 
@@ -2506,22 +2508,16 @@ static int uea_bind(struct usbatm_data *
 	else
 		sc->annex = (le16_to_cpu(sc->usb_dev->descriptor.bcdDevice) & 0x80)?ANNEXB:ANNEXA;
 
+	alt = altsetting[sc->modem_index];
 	/* ADI930 don't support iso */
-	if (UEA_CHIP_VERSION(id) != ADI930 && use_iso[sc->modem_index]) {
-		int i;
-
-		/* try set fastest alternate for inbound traffic interface */
-		for (i = FASTEST_ISO_INTF; i > 0; i--)
-			if (usb_set_interface(usb, UEA_DS_IFACE_NO, i) == 0)
-				break;
-
-		if (i > 0) {
-			uea_dbg(usb, "set alternate %d for 2 interface\n", i);
+	if (UEA_CHIP_VERSION(id) != ADI930 && alt > 0) {
+		if (alt <= 8 && usb_set_interface(usb, UEA_DS_IFACE_NO, alt) == 0) {
+			uea_dbg(usb, "set alternate %u for 2 interface\n", alt);
 			uea_info(usb, "using iso mode\n");
 			usbatm->flags |= UDSL_USE_ISOC | UDSL_IGNORE_EILSEQ;
 		} else {
-			uea_err(usb, "setting any alternate failed for "
-					"2 interface, using bulk mode\n");
+			uea_err(usb, "setting alternate %u failed for "
+					"2 interface, using bulk mode\n", alt);
 		}
 	}
 
