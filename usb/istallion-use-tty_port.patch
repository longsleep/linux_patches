From linux-kernel-owner+greg=40kroah.com-S1761333AbYFTUUP@vger.kernel.org Fri Jun 20 13:32:15 2008
From: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date: Fri, 20 Jun 2008 20:59:43 +0100
Subject: istallion: use tty_port
To: linux-kernel@vger.kernel.org
Message-ID: <20080620195941.1479.27.stgit@localhost.localdomain>


From: Alan Cox <alan@redhat.com>

Switch istallion to use the new tty_port structure

Signed-off-by: Alan Cox <alan@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/char/istallion.c  |  116 +++++++++++++++++++++++-----------------------
 include/linux/istallion.h |    6 --
 2 files changed, 59 insertions(+), 63 deletions(-)

--- a/drivers/char/istallion.c
+++ b/drivers/char/istallion.c
@@ -735,8 +735,8 @@ static void stli_cleanup_ports(struct st
 	for (j = 0; j < STL_MAXPORTS; j++) {
 		portp = brdp->ports[j];
 		if (portp != NULL) {
-			if (portp->tty != NULL)
-				tty_hangup(portp->tty);
+			if (portp->port.tty != NULL)
+				tty_hangup(portp->port.tty);
 			kfree(portp);
 		}
 	}
@@ -811,9 +811,9 @@ static int stli_open(struct tty_struct *
  *	The sleep here does not need interrupt protection since the wakeup
  *	for it is done with the same context.
  */
-	if (portp->flags & ASYNC_CLOSING) {
-		interruptible_sleep_on(&portp->close_wait);
-		if (portp->flags & ASYNC_HUP_NOTIFY)
+	if (portp->port.flags & ASYNC_CLOSING) {
+		interruptible_sleep_on(&portp->port.close_wait);
+		if (portp->port.flags & ASYNC_HUP_NOTIFY)
 			return -EAGAIN;
 		return -ERESTARTSYS;
 	}
@@ -824,7 +824,7 @@ static int stli_open(struct tty_struct *
  *	requires several commands to the board we will need to wait for any
  *	other open that is already initializing the port.
  */
-	portp->tty = tty;
+	portp->port.tty = tty;
 	tty->driver_data = portp;
 	portp->refcount++;
 
@@ -833,10 +833,10 @@ static int stli_open(struct tty_struct *
 	if (signal_pending(current))
 		return -ERESTARTSYS;
 
-	if ((portp->flags & ASYNC_INITIALIZED) == 0) {
+	if ((portp->port.flags & ASYNC_INITIALIZED) == 0) {
 		set_bit(ST_INITIALIZING, &portp->state);
 		if ((rc = stli_initopen(brdp, portp)) >= 0) {
-			portp->flags |= ASYNC_INITIALIZED;
+			portp->port.flags |= ASYNC_INITIALIZED;
 			clear_bit(TTY_IO_ERROR, &tty->flags);
 		}
 		clear_bit(ST_INITIALIZING, &portp->state);
@@ -851,9 +851,9 @@ static int stli_open(struct tty_struct *
  *	The sleep here does not need interrupt protection since the wakeup
  *	for it is done with the same context.
  */
-	if (portp->flags & ASYNC_CLOSING) {
-		interruptible_sleep_on(&portp->close_wait);
-		if (portp->flags & ASYNC_HUP_NOTIFY)
+	if (portp->port.flags & ASYNC_CLOSING) {
+		interruptible_sleep_on(&portp->port.close_wait);
+		if (portp->port.flags & ASYNC_HUP_NOTIFY)
 			return -EAGAIN;
 		return -ERESTARTSYS;
 	}
@@ -867,7 +867,7 @@ static int stli_open(struct tty_struct *
 		if ((rc = stli_waitcarrier(brdp, portp, filp)) != 0)
 			return rc;
 	}
-	portp->flags |= ASYNC_NORMAL_ACTIVE;
+	portp->port.flags |= ASYNC_NORMAL_ACTIVE;
 	return 0;
 }
 
@@ -895,7 +895,7 @@ static void stli_close(struct tty_struct
 		return;
 	}
 
-	portp->flags |= ASYNC_CLOSING;
+	portp->port.flags |= ASYNC_CLOSING;
 
 /*
  *	May want to wait for data to drain before closing. The BUSY flag
@@ -911,7 +911,7 @@ static void stli_close(struct tty_struct
 	if (portp->closing_wait != ASYNC_CLOSING_WAIT_NONE)
 		tty_wait_until_sent(tty, portp->closing_wait);
 
-	portp->flags &= ~ASYNC_INITIALIZED;
+	portp->port.flags &= ~ASYNC_INITIALIZED;
 	brdp = stli_brds[portp->brdnr];
 	stli_rawclose(brdp, portp, 0, 0);
 	if (tty->termios->c_cflag & HUPCL) {
@@ -931,16 +931,16 @@ static void stli_close(struct tty_struct
 	stli_flushbuffer(tty);
 
 	tty->closing = 0;
-	portp->tty = NULL;
+	portp->port.tty = NULL;
 
 	if (portp->openwaitcnt) {
 		if (portp->close_delay)
 			msleep_interruptible(jiffies_to_msecs(portp->close_delay));
-		wake_up_interruptible(&portp->open_wait);
+		wake_up_interruptible(&portp->port.open_wait);
 	}
 
-	portp->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-	wake_up_interruptible(&portp->close_wait);
+	portp->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	wake_up_interruptible(&portp->port.close_wait);
 }
 
 /*****************************************************************************/
@@ -970,7 +970,7 @@ static int stli_initopen(struct stlibrd 
 	    sizeof(asynotify_t), 0)) < 0)
 		return rc;
 
-	tty = portp->tty;
+	tty = portp->port.tty;
 	if (tty == NULL)
 		return -ENODEV;
 	stli_mkasyport(portp, &aport, tty->termios);
@@ -1169,7 +1169,7 @@ static int stli_setport(struct stliport 
 
 	if (portp == NULL)
 		return -ENODEV;
-	if (portp->tty == NULL)
+	if (portp->port.tty == NULL)
 		return -ENODEV;
 	if (portp->brdnr >= stli_nrbrds)
 		return -ENODEV;
@@ -1177,7 +1177,7 @@ static int stli_setport(struct stliport 
 	if (brdp == NULL)
 		return -ENODEV;
 
-	stli_mkasyport(portp, &aport, portp->tty->termios);
+	stli_mkasyport(portp, &aport, portp->port.tty->termios);
 	return(stli_cmdwait(brdp, portp, A_SETPORT, &aport, sizeof(asyport_t), 0));
 }
 
@@ -1196,7 +1196,7 @@ static int stli_waitcarrier(struct stlib
 	rc = 0;
 	doclocal = 0;
 
-	if (portp->tty->termios->c_cflag & CLOCAL)
+	if (portp->port.tty->termios->c_cflag & CLOCAL)
 		doclocal++;
 
 	spin_lock_irqsave(&stli_lock, flags);
@@ -1211,14 +1211,14 @@ static int stli_waitcarrier(struct stlib
 		    &portp->asig, sizeof(asysigs_t), 0)) < 0)
 			break;
 		if (tty_hung_up_p(filp) ||
-		    ((portp->flags & ASYNC_INITIALIZED) == 0)) {
-			if (portp->flags & ASYNC_HUP_NOTIFY)
+		    ((portp->port.flags & ASYNC_INITIALIZED) == 0)) {
+			if (portp->port.flags & ASYNC_HUP_NOTIFY)
 				rc = -EBUSY;
 			else
 				rc = -ERESTARTSYS;
 			break;
 		}
-		if (((portp->flags & ASYNC_CLOSING) == 0) &&
+		if (((portp->port.flags & ASYNC_CLOSING) == 0) &&
 		    (doclocal || (portp->sigs & TIOCM_CD))) {
 			break;
 		}
@@ -1226,7 +1226,7 @@ static int stli_waitcarrier(struct stlib
 			rc = -ERESTARTSYS;
 			break;
 		}
-		interruptible_sleep_on(&portp->open_wait);
+		interruptible_sleep_on(&portp->port.open_wait);
 	}
 
 	spin_lock_irqsave(&stli_lock, flags);
@@ -1548,7 +1548,7 @@ static int stli_getserial(struct stlipor
 	sio.type = PORT_UNKNOWN;
 	sio.line = portp->portnr;
 	sio.irq = 0;
-	sio.flags = portp->flags;
+	sio.flags = portp->port.flags;
 	sio.baud_base = portp->baud_base;
 	sio.close_delay = portp->close_delay;
 	sio.closing_wait = portp->closing_wait;
@@ -1583,11 +1583,11 @@ static int stli_setserial(struct stlipor
 		if ((sio.baud_base != portp->baud_base) ||
 		    (sio.close_delay != portp->close_delay) ||
 		    ((sio.flags & ~ASYNC_USR_MASK) !=
-		    (portp->flags & ~ASYNC_USR_MASK)))
+		    (portp->port.flags & ~ASYNC_USR_MASK)))
 			return -EPERM;
 	} 
 
-	portp->flags = (portp->flags & ~ASYNC_USR_MASK) |
+	portp->port.flags = (portp->port.flags & ~ASYNC_USR_MASK) |
 		(sio.flags & ASYNC_USR_MASK);
 	portp->baud_base = sio.baud_base;
 	portp->close_delay = sio.close_delay;
@@ -1751,7 +1751,7 @@ static void stli_settermios(struct tty_s
 	if ((old->c_cflag & CRTSCTS) && ((tiosp->c_cflag & CRTSCTS) == 0))
 		tty->hw_stopped = 0;
 	if (((old->c_cflag & CLOCAL) == 0) && (tiosp->c_cflag & CLOCAL))
-		wake_up_interruptible(&portp->open_wait);
+		wake_up_interruptible(&portp->port.open_wait);
 }
 
 /*****************************************************************************/
@@ -1834,7 +1834,7 @@ static void stli_hangup(struct tty_struc
 	if (brdp == NULL)
 		return;
 
-	portp->flags &= ~ASYNC_INITIALIZED;
+	portp->port.flags &= ~ASYNC_INITIALIZED;
 
 	if (!test_bit(ST_CLOSING, &portp->state))
 		stli_rawclose(brdp, portp, 0, 0);
@@ -1855,12 +1855,12 @@ static void stli_hangup(struct tty_struc
 	clear_bit(ST_TXBUSY, &portp->state);
 	clear_bit(ST_RXSTOP, &portp->state);
 	set_bit(TTY_IO_ERROR, &tty->flags);
-	portp->tty = NULL;
-	portp->flags &= ~ASYNC_NORMAL_ACTIVE;
+	portp->port.tty = NULL;
+	portp->port.flags &= ~ASYNC_NORMAL_ACTIVE;
 	portp->refcount = 0;
 	spin_unlock_irqrestore(&stli_lock, flags);
 
-	wake_up_interruptible(&portp->open_wait);
+	wake_up_interruptible(&portp->port.open_wait);
 }
 
 /*****************************************************************************/
@@ -2188,7 +2188,7 @@ static void stli_read(struct stlibrd *br
 
 	if (test_bit(ST_RXSTOP, &portp->state))
 		return;
-	tty = portp->tty;
+	tty = portp->port.tty;
 	if (tty == NULL)
 		return;
 
@@ -2362,7 +2362,7 @@ static int stli_hostcmd(struct stlibrd *
 	if (ap->notify) {
 		nt = ap->changed;
 		ap->notify = 0;
-		tty = portp->tty;
+		tty = portp->port.tty;
 
 		if (nt.signal & SG_DCD) {
 			oldsigs = portp->sigs;
@@ -2370,10 +2370,10 @@ static int stli_hostcmd(struct stlibrd *
 			clear_bit(ST_GETSIGS, &portp->state);
 			if ((portp->sigs & TIOCM_CD) &&
 			    ((oldsigs & TIOCM_CD) == 0))
-				wake_up_interruptible(&portp->open_wait);
+				wake_up_interruptible(&portp->port.open_wait);
 			if ((oldsigs & TIOCM_CD) &&
 			    ((portp->sigs & TIOCM_CD) == 0)) {
-				if (portp->flags & ASYNC_CHECK_CD) {
+				if (portp->port.flags & ASYNC_CHECK_CD) {
 					if (tty)
 						tty_hangup(tty);
 				}
@@ -2392,7 +2392,7 @@ static int stli_hostcmd(struct stlibrd *
 		if ((nt.data & DT_RXBREAK) && (portp->rxmarkmsk & BRKINT)) {
 			if (tty != NULL) {
 				tty_insert_flip_char(tty, 0, TTY_BREAK);
-				if (portp->flags & ASYNC_SAK) {
+				if (portp->port.flags & ASYNC_SAK) {
 					do_SAK(tty);
 					EBRDENABLE(brdp);
 				}
@@ -2542,17 +2542,17 @@ static void stli_mkasyport(struct stlipo
 /*
  *	Start of by setting the baud, char size, parity and stop bit info.
  */
-	pp->baudout = tty_get_baud_rate(portp->tty);
+	pp->baudout = tty_get_baud_rate(portp->port.tty);
 	if ((tiosp->c_cflag & CBAUD) == B38400) {
-		if ((portp->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+		if ((portp->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
 			pp->baudout = 57600;
-		else if ((portp->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+		else if ((portp->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
 			pp->baudout = 115200;
-		else if ((portp->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+		else if ((portp->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
 			pp->baudout = 230400;
-		else if ((portp->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+		else if ((portp->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
 			pp->baudout = 460800;
-		else if ((portp->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)
+		else if ((portp->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)
 			pp->baudout = (portp->baud_base / portp->custom_divisor);
 	}
 	if (pp->baudout > STL_MAXBAUD)
@@ -2625,9 +2625,9 @@ static void stli_mkasyport(struct stlipo
  *	Set up clocal processing as required.
  */
 	if (tiosp->c_cflag & CLOCAL)
-		portp->flags &= ~ASYNC_CHECK_CD;
+		portp->port.flags &= ~ASYNC_CHECK_CD;
 	else
-		portp->flags |= ASYNC_CHECK_CD;
+		portp->port.flags |= ASYNC_CHECK_CD;
 
 /*
  *	Transfer any persistent flags into the asyport structure.
@@ -2703,8 +2703,8 @@ static int stli_initports(struct stlibrd
 		portp->baud_base = STL_BAUDBASE;
 		portp->close_delay = STL_CLOSEDELAY;
 		portp->closing_wait = 30 * HZ;
-		init_waitqueue_head(&portp->open_wait);
-		init_waitqueue_head(&portp->close_wait);
+		init_waitqueue_head(&portp->port.open_wait);
+		init_waitqueue_head(&portp->port.close_wait);
 		init_waitqueue_head(&portp->raw_wait);
 		panelport++;
 		if (panelport >= brdp->panels[panelnr]) {
@@ -4246,18 +4246,18 @@ static int stli_portcmdstats(struct stli
 	stli_comstats.panel = portp->panelnr;
 	stli_comstats.port = portp->portnr;
 	stli_comstats.state = portp->state;
-	stli_comstats.flags = portp->flags;
+	stli_comstats.flags = portp->port.flag;
 
 	spin_lock_irqsave(&brd_lock, flags);
-	if (portp->tty != NULL) {
-		if (portp->tty->driver_data == portp) {
-			stli_comstats.ttystate = portp->tty->flags;
+	if (portp->port.tty != NULL) {
+		if (portp->port.tty->driver_data == portp) {
+			stli_comstats.ttystate = portp->port.tty->flags;
 			stli_comstats.rxbuffered = -1;
-			if (portp->tty->termios != NULL) {
-				stli_comstats.cflags = portp->tty->termios->c_cflag;
-				stli_comstats.iflags = portp->tty->termios->c_iflag;
-				stli_comstats.oflags = portp->tty->termios->c_oflag;
-				stli_comstats.lflags = portp->tty->termios->c_lflag;
+			if (portp->port.tty->termios != NULL) {
+				stli_comstats.cflags = portp->port.tty->termios->c_cflag;
+				stli_comstats.iflags = portp->port.tty->termios->c_iflag;
+				stli_comstats.oflags = portp->port.tty->termios->c_oflag;
+				stli_comstats.lflags = portp->port.tty->termios->c_lflag;
 			}
 		}
 	}
--- a/include/linux/istallion.h
+++ b/include/linux/istallion.h
@@ -51,25 +51,21 @@
  */
 struct stliport {
 	unsigned long		magic;
+	struct tty_port		port;
 	unsigned int		portnr;
 	unsigned int		panelnr;
 	unsigned int		brdnr;
 	unsigned long		state;
 	unsigned int		devnr;
-	int			flags;
 	int			baud_base;
 	int			custom_divisor;
 	int			close_delay;
 	int			closing_wait;
-	int			refcount;
 	int			openwaitcnt;
 	int			rc;
 	int			argsize;
 	void			*argp;
 	unsigned int		rxmarkmsk;
-	struct tty_struct	*tty;
-	wait_queue_head_t	open_wait;
-	wait_queue_head_t	close_wait;
 	wait_queue_head_t	raw_wait;
 	struct asysigs		asig;
 	unsigned long		addr;
