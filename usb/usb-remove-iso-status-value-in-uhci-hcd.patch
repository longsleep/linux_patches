From stern@rowland.harvard.edu Tue Aug 21 12:37:56 2007
From: Alan Stern <stern@rowland.harvard.edu>
Date: Tue, 21 Aug 2007 15:37:50 -0400 (EDT)
Subject: USB: remove Iso status value in uhci-hcd
To: Greg KH <greg@kroah.com>
Message-ID: <Pine.LNX.4.44L0.0708211536520.2609-100000@iolanthe.rowland.org>


This patch (968) changes the way uhci-hcd reports status for
Isochronous URBs.  Until now urb->status has been set to the last
detected error code.  But other HCDs don't do this; they leave the
status set to 0 and report errors only in the individual iso packet
descriptors.  So this patch removes the extra computation and makes
uhci-hcd behave like the others.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/uhci-hcd.h |    1 -
 drivers/usb/host/uhci-q.c   |   11 +++--------
 2 files changed, 3 insertions(+), 9 deletions(-)

--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -146,7 +146,6 @@ struct uhci_qh {
 	short phase;			/* Between 0 and period-1 */
 	short load;			/* Periodic time requirement, in us */
 	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
-	int iso_status;			/* Status for Isochronous URBs */
 
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1324,7 +1324,6 @@ static int uhci_submit_isochronous(struc
 	if (list_empty(&qh->queue)) {
 		qh->iso_packet_desc = &urb->iso_frame_desc[0];
 		qh->iso_frame = urb->start_frame;
-		qh->iso_status = 0;
 	}
 
 	qh->skel = SKEL_ISO;
@@ -1361,18 +1360,15 @@ static int uhci_result_isochronous(struc
 			qh->iso_packet_desc->actual_length = actlength;
 			qh->iso_packet_desc->status = status;
 		}
-
-		if (status) {
+		if (status)
 			urb->error_count++;
-			qh->iso_status = status;
-		}
 
 		uhci_remove_td_from_urbp(td);
 		uhci_free_td(uhci, td);
 		qh->iso_frame += qh->period;
 		++qh->iso_packet_desc;
 	}
-	return qh->iso_status;
+	return 0;
 }
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
@@ -1517,7 +1513,6 @@ __acquires(uhci->lock)
 
 		qh->iso_packet_desc = &nurb->iso_frame_desc[0];
 		qh->iso_frame = nurb->start_frame;
-		qh->iso_status = 0;
 	}
 
 	/* Take the URB off the QH's queue.  If the queue is now empty,
@@ -1586,7 +1581,7 @@ static void uhci_scan_qh(struct uhci_hcd
 		}
 
 		uhci_giveback_urb(uhci, qh, urb);
-		if (status < 0 && qh->type != USB_ENDPOINT_XFER_ISOC)
+		if (status < 0)
 			break;
 	}
 
