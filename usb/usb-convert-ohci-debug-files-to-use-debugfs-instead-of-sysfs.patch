From foo@baz Tue Apr  9 12:12:43 2002
Date: Tue, 11 Sep 2007 14:07:31 -0700
From: Tony Jones <tonyj@suse.de>
To: Greg KH <greg@kroah.com>
Subject: USB: convert ohci debug files to use debugfs instead of sysfs

We should not have multiple line files in sysfs, this moves the data to
debugfs instead, like the UHCI driver.

Signed-off-by: Tony Jones <tonyj@suse.de>
Cc: Kay Sievers <kay.sievers@vrfy.org>
Cc: David Brownell <david-b@pacbell.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/ohci-dbg.c |  217 ++++++++++++++++++++++++++++++++++++++------
 drivers/usb/host/ohci-hcd.c |   21 ++++
 drivers/usb/host/ohci.h     |    7 +
 3 files changed, 216 insertions(+), 29 deletions(-)

--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -401,6 +401,42 @@ static inline void remove_debug_files (s
 
 #else
 
+static int debug_async_open(struct inode *, struct file *);
+static int debug_periodic_open(struct inode *, struct file *);
+static int debug_registers_open(struct inode *, struct file *);
+static int debug_async_open(struct inode *, struct file *);
+static ssize_t debug_output(struct file*, char __user*, size_t, loff_t*);
+static int debug_close(struct inode *, struct file *);
+
+static const struct file_operations debug_async_fops = {
+	.owner		= THIS_MODULE,
+        .open           = debug_async_open,
+        .read           = debug_output,
+        .release        = debug_close,
+};
+static const struct file_operations debug_periodic_fops = {
+	.owner		= THIS_MODULE,
+        .open           = debug_periodic_open,
+        .read           = debug_output,
+        .release        = debug_close,
+};
+static const struct file_operations debug_registers_fops = {
+	.owner		= THIS_MODULE,
+        .open		= debug_registers_open,
+        .read           = debug_output,
+        .release        = debug_close,
+};
+
+static struct dentry	*ohci_debug_root = NULL;
+
+struct debug_buffer {
+	ssize_t (*fill_func)(struct debug_buffer*);	/* fill method */
+	struct device *dev;
+	struct mutex mutex;	/* protect filling of buffer */
+	size_t count;		/* number of characters filled into buffer */
+	char *page;
+};
+
 static ssize_t
 show_list (struct ohci_hcd *ohci, char *buf, size_t count, struct ed *ed)
 {
@@ -467,8 +503,7 @@ show_list (struct ohci_hcd *ohci, char *
 	return count - size;
 }
 
-static ssize_t
-show_async(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t fill_async_buffer(struct debug_buffer *buf)
 {
 	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
@@ -476,25 +511,23 @@ show_async(struct device *dev, struct de
 	size_t			temp;
 	unsigned long		flags;
 
-	bus = dev_get_drvdata(dev);
+	bus = (struct usb_bus *)dev_get_drvdata(buf->dev);
 	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 
 	/* display control and bulk lists together, for simplicity */
 	spin_lock_irqsave (&ohci->lock, flags);
-	temp = show_list (ohci, buf, PAGE_SIZE, ohci->ed_controltail);
-	temp += show_list (ohci, buf + temp, PAGE_SIZE - temp, ohci->ed_bulktail);
+	temp = show_list (ohci, buf->page, buf->count, ohci->ed_controltail);
+	temp += show_list (ohci, buf->page + temp, buf->count - temp,
+			   ohci->ed_bulktail);
 	spin_unlock_irqrestore (&ohci->lock, flags);
 
 	return temp;
 }
-static DEVICE_ATTR(async, S_IRUGO, show_async, NULL);
-
 
 #define DBG_SCHED_LIMIT 64
 
-static ssize_t
-show_periodic(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 {
 	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
@@ -509,10 +542,10 @@ show_periodic(struct device *dev, struct
 		return 0;
 	seen_count = 0;
 
-	bus = dev_get_drvdata(dev);
+	bus = (struct usb_bus *)dev_get_drvdata(buf->dev);
 	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
-	next = buf;
+	next = buf->page;
 	size = PAGE_SIZE;
 
 	temp = scnprintf (next, size, "size = %d\n", NUM_INTS);
@@ -589,13 +622,9 @@ show_periodic(struct device *dev, struct
 
 	return PAGE_SIZE - size;
 }
-static DEVICE_ATTR(periodic, S_IRUGO, show_periodic, NULL);
-
-
 #undef DBG_SCHED_LIMIT
 
-static ssize_t
-show_registers(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 {
 	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
@@ -606,11 +635,11 @@ show_registers(struct device *dev, struc
 	char			*next;
 	u32			rdata;
 
-	bus = dev_get_drvdata(dev);
+	bus = (struct usb_bus *)dev_get_drvdata(buf->dev);
 	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 	regs = ohci->regs;
-	next = buf;
+	next = buf->page;
 	size = PAGE_SIZE;
 
 	spin_lock_irqsave (&ohci->lock, flags);
@@ -677,29 +706,159 @@ show_registers(struct device *dev, struc
 
 done:
 	spin_unlock_irqrestore (&ohci->lock, flags);
+
 	return PAGE_SIZE - size;
 }
-static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
 
+static struct debug_buffer*
+alloc_buffer(struct device *dev, ssize_t (*fill_func)(struct debug_buffer*))
+{
+	struct debug_buffer *buf;
+
+	buf = kzalloc(sizeof (struct debug_buffer), GFP_KERNEL);
+
+	if (buf) {
+		buf->dev = dev;
+		buf->fill_func=fill_func;
+		mutex_init(&buf->mutex);
+	}
+
+	return buf;
+}
+
+static int fill_buffer(struct debug_buffer *buf)
+{
+	int ret=0;
+
+	if (!buf->page)
+		buf->page = (char *)get_zeroed_page(GFP_KERNEL);
+
+	if (!buf->page) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = buf->fill_func(buf);
+
+	if (ret >= 0) {
+		buf->count = ret;
+		ret = 0;
+	}
+
+out:
+	return ret;
+}
+
+static ssize_t debug_output(struct file *file, char __user *user_buf,
+			size_t len, loff_t *offset)
+{
+	struct debug_buffer *buf = file->private_data;
+	int ret = 0;
 
+	mutex_lock(&buf->mutex);
+	if (buf->count == 0) {
+		ret = fill_buffer(buf);
+		if (ret != 0) {
+			mutex_unlock(&buf->mutex);
+			goto out;
+		}
+	}
+	mutex_unlock(&buf->mutex);
+
+	ret = simple_read_from_buffer(user_buf, len, offset,
+				      buf->page, buf->count);
+
+out:
+	return ret;
+
+}
+
+static int debug_close(struct inode *inode, struct file *file)
+{
+	struct debug_buffer *buf = file->private_data;
+
+	if (buf) {
+		if (buf->page)
+			free_page((unsigned long)buf->page);
+		kfree(buf);
+	}
+
+	return 0;
+}
+static int debug_async_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private, fill_async_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
+
+static int debug_periodic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private,
+					  fill_periodic_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
+
+static int debug_registers_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private,
+					  fill_registers_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
 static inline void create_debug_files (struct ohci_hcd *ohci)
 {
-	struct device *dev = ohci_to_hcd(ohci)->self.dev;
-	int retval;
+	struct usb_bus *bus = &ohci_to_hcd(ohci)->self;
+	struct device *dev = bus->dev;
+
+	ohci->debug_dir=debugfs_create_dir(bus->bus_name, ohci_debug_root);
+	if (!ohci->debug_dir || IS_ERR(ohci->debug_dir)) {
+		ohci->debug_dir = NULL;
+	        goto done;
+	}
+
+	ohci->debug_async =
+		debugfs_create_file("async", S_IRUGO, ohci->debug_dir,
+				    dev, &debug_async_fops);
+	if (!ohci->debug_async || IS_ERR(ohci->debug_async))
+	        goto async_error;
+
+	ohci->debug_periodic =
+		debugfs_create_file("periodic", S_IRUGO, ohci->debug_dir,
+				    dev, &debug_periodic_fops);
+
+	if (!ohci->debug_periodic || IS_ERR(ohci->debug_periodic))
+	        goto periodic_error;
+
+	ohci->debug_registers =
+		debugfs_create_file("registers", S_IRUGO, ohci->debug_dir,
+				    dev, &debug_registers_fops);
+
+	if (!ohci->debug_registers || IS_ERR(ohci->debug_registers))
+	        goto registers_error;
+
+	goto done;
+
+registers_error:
+	debugfs_remove(ohci->debug_periodic); ohci->debug_periodic = NULL;
+periodic_error:
+	debugfs_remove(ohci->debug_async); ohci->debug_async = NULL;
+async_error:
+	debugfs_remove(ohci->debug_dir); ohci->debug_dir = NULL;
+
+done:
+	return;
 
-	retval = device_create_file(dev, &dev_attr_async);
-	retval = device_create_file(dev, &dev_attr_periodic);
-	retval = device_create_file(dev, &dev_attr_registers);
 	ohci_dbg (ohci, "created debug files\n");
 }
 
 static inline void remove_debug_files (struct ohci_hcd *ohci)
 {
-	struct device *dev = ohci_to_hcd(ohci)->self.dev;
-
-	device_remove_file(dev, &dev_attr_async);
-	device_remove_file(dev, &dev_attr_periodic);
-	device_remove_file(dev, &dev_attr_registers);
+	debugfs_remove(ohci->debug_registers);
+	debugfs_remove(ohci->debug_periodic);
+	debugfs_remove(ohci->debug_async);
+	debugfs_remove(ohci->debug_dir);
 }
 
 #endif
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -36,6 +36,7 @@
 #include <linux/dmapool.h>
 #include <linux/reboot.h>
 #include <linux/workqueue.h>
+#include <linux/debugfs.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -1065,6 +1066,18 @@ static int __init ohci_hcd_mod_init(void
 	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
 		sizeof (struct ed), sizeof (struct td));
 
+#ifdef DEBUG
+       ohci_debug_root=debugfs_create_dir("ohci", NULL);
+       if (!ohci_debug_root || IS_ERR(ohci_debug_root)) {
+	       if (!ohci_debug_root)
+		       retval = -ENOENT;
+	       else
+		       retval = PTR_ERR(ohci_debug_root);
+
+	       goto error_debug;
+	}
+#endif
+
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	retval = ps3_ohci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
 	if (retval < 0)
@@ -1127,6 +1140,11 @@ static int __init ohci_hcd_mod_init(void
 	ps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
  error_ps3:
 #endif
+#ifdef DEBUG
+	debugfs_remove(ohci_debug_root); ohci_debug_root = NULL;
+ error_debug:
+#endif
+
 	return retval;
 }
 module_init(ohci_hcd_mod_init);
@@ -1151,6 +1169,9 @@ static void __exit ohci_hcd_mod_exit(voi
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
+#ifdef DEBUG
+	debugfs_remove(ohci_debug_root);
+#endif
 }
 module_exit(ohci_hcd_mod_exit);
 
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -408,6 +408,13 @@ struct ohci_hcd {
 	unsigned		eds_scheduled;
 	struct ed		*ed_to_check;
 	unsigned		zf_delay;
+
+#ifdef DEBUG
+	struct dentry		*debug_dir;
+	struct dentry		*debug_async;
+	struct dentry		*debug_periodic;
+	struct dentry		*debug_registers;
+#endif
 };
 
 #ifdef CONFIG_PCI
