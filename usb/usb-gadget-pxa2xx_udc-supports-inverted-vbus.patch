From david-b@pacbell.net Thu Dec  6 18:19:12 2007
From: David Brownell <david-b@pacbell.net>
Date: Thu, 6 Dec 2007 18:18:03 -0800
Subject: USB: gadget: pxa2xx_udc supports inverted vbus
To: Greg KH <greg@kroah.com>
Cc: Dmitry Baryshkov <dbaryshkov@gmail.com>
Message-ID: <200712061818.03994.david-b@pacbell.net>
Content-Disposition: inline


From: Dmitry Baryshkov <dbaryshkov@gmail.com>

Some boards (like e.g. Tosa) invert the VBUS-detection signal:
it's low when a host is supplying VBUS, and high otherwise.
Allow specifying whether gpio_vbus value is inverted.

Signed-off-by: Dmitry Baryshkov <dbaryshkov@gmail.com>
Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/pxa2xx_udc.c   |    9 +++++++--
 include/asm-arm/mach/udc_pxa2xx.h |    2 ++
 2 files changed, 9 insertions(+), 2 deletions(-)

--- a/drivers/usb/gadget/pxa2xx_udc.c
+++ b/drivers/usb/gadget/pxa2xx_udc.c
@@ -127,8 +127,10 @@ static int is_vbus_present(void)
 {
 	struct pxa2xx_udc_mach_info		*mach = the_controller->mach;
 
-	if (mach->gpio_vbus)
-		return gpio_get_value(mach->gpio_vbus);
+	if (mach->gpio_vbus) {
+		int value = gpio_get_value(mach->gpio_vbus);
+		return mach->gpio_vbus_inverted ? !value : value;
+	}
 	if (mach->udc_is_connected)
 		return mach->udc_is_connected();
 	return 1;
@@ -1398,6 +1400,9 @@ static irqreturn_t udc_vbus_irq(int irq,
 	struct pxa2xx_udc	*dev = _dev;
 	int			vbus = gpio_get_value(dev->mach->gpio_vbus);
 
+	if (dev->mach->gpio_vbus_inverted)
+		vbus = !vbus;
+
 	pxa2xx_udc_vbus_session(&dev->gadget, vbus);
 	return IRQ_HANDLED;
 }
--- a/include/asm-arm/mach/udc_pxa2xx.h
+++ b/include/asm-arm/mach/udc_pxa2xx.h
@@ -19,7 +19,9 @@ struct pxa2xx_udc_mach_info {
 	 * with on-chip GPIOs not Lubbock's wierd hardware, can have a sane
 	 * VBUS IRQ and omit the methods above.  Store the GPIO number
 	 * here; for GPIO 0, also mask in one of the pxa_gpio_mode() bits.
+	 * Note that sometimes the signals go through inverters...
 	 */
+	bool	gpio_vbus_inverted;
 	u16	gpio_vbus;			/* high == vbus present */
 	u16	gpio_pullup;			/* high == pullup activated */
 };
