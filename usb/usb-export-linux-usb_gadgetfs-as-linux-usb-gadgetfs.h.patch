From david-b@pacbell.net Mon May 14 19:37:00 2007
From: David Brownell <david-b@pacbell.net>
Date: Mon, 14 May 2007 19:36:41 -0700
Subject: USB: export <linux/usb_gadgetfs> as <linux/usb/gadgetfs.h>
To: Greg KH <greg@kroah.com>
Cc: linux-usb-devel@lists.sourceforge.net
Message-ID: <200705141936.41508.david-b@pacbell.net>
Content-Disposition: inline


Make sure gadgetfs userspace interface is properly exported:

 - Move <linux/usb_gadgetfs.h> to <linux/usb/gadgetfs.h>;
 - Export it using Kbuild;
 - Add an #include guard;
 - Correct some internal documentation;
 - Update struct layout so it's the same on 32/64 bit kernels.

Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/usb/gadget/inode.c   |    2 -
 include/linux/usb/Kbuild     |    1 
 include/linux/usb/gadgetfs.h |   81 +++++++++++++++++++++++++++++++++++++++++++
 include/linux/usb_gadgetfs.h |   75 ---------------------------------------
 4 files changed, 83 insertions(+), 76 deletions(-)

--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -37,7 +37,7 @@
 #include <linux/device.h>
 #include <linux/moduleparam.h>
 
-#include <linux/usb_gadgetfs.h>
+#include <linux/usb/gadgetfs.h>
 #include <linux/usb_gadget.h>
 
 
--- a/include/linux/usb/Kbuild
+++ b/include/linux/usb/Kbuild
@@ -1,5 +1,6 @@
 unifdef-y += audio.h
 unifdef-y += cdc.h
 unifdef-y += ch9.h
+unifdef-y += gadgetfs.h
 unifdef-y += midi.h
 
--- /dev/null
+++ b/include/linux/usb/gadgetfs.h
@@ -0,0 +1,81 @@
+#ifndef __LINUX_USB_GADGETFS_H
+#define __LINUX_USB_GADGETFS_H
+
+#include <asm/types.h>
+#include <asm/ioctl.h>
+
+#include <linux/usb/ch9.h>
+
+/*
+ * Filesystem based user-mode API to USB Gadget controller hardware
+ *
+ * Other than ep0 operations, most things are done by read() and write()
+ * on endpoint files found in one directory.  They are configured by
+ * writing descriptors, and then may be used for normal stream style
+ * i/o requests.  When ep0 is configured, the device can enumerate;
+ * when it's closed, the device disconnects from usb.  Operations on
+ * ep0 require ioctl() operations.
+ *
+ * Configuration and device descriptors get written to /dev/gadget/$CHIP,
+ * which may then be used to read usb_gadgetfs_event structs.  The driver
+ * may activate endpoints as it handles SET_CONFIGURATION setup events,
+ * or earlier; writing endpoint descriptors to /dev/gadget/$ENDPOINT
+ * then performing data transfers by reading or writing.
+ */
+
+/*
+ * Events are delivered on the ep0 file descriptor, when the user mode driver
+ * reads from this file descriptor after writing the descriptors.  Don't
+ * stop polling this descriptor.
+ */
+
+enum usb_gadgetfs_event_type {
+	GADGETFS_NOP = 0,
+
+	GADGETFS_CONNECT,
+	GADGETFS_DISCONNECT,
+	GADGETFS_SETUP,
+	GADGETFS_SUSPEND,
+	// and likely more !
+};
+
+/* NOTE:  this structure must stay the same size and layout on
+ * both 32-bit and 64-bit kernels.
+ */
+struct usb_gadgetfs_event {
+	union {
+		// NOP, DISCONNECT, SUSPEND: nothing
+		// ... some hardware can't report disconnection
+
+		// CONNECT: just the speed
+		enum usb_device_speed	speed;
+
+		// SETUP: packet; DATA phase i/o precedes next event
+		// (setup.bmRequestType & USB_DIR_IN) flags direction
+		// ... includes SET_CONFIGURATION, SET_INTERFACE
+		struct usb_ctrlrequest	setup;
+	} u;
+	enum usb_gadgetfs_event_type	type;
+};
+
+
+/* endpoint ioctls */
+
+/* IN transfers may be reported to the gadget driver as complete
+ *	when the fifo is loaded, before the host reads the data;
+ * OUT transfers may be reported to the host's "client" driver as
+ *	complete when they're sitting in the FIFO unread.
+ * THIS returns how many bytes are "unclaimed" in the endpoint fifo
+ * (needed for precise fault handling, when the hardware allows it)
+ */
+#define	GADGETFS_FIFO_STATUS	_IO('g',1)
+
+/* discards any unclaimed data in the fifo. */
+#define	GADGETFS_FIFO_FLUSH	_IO('g',2)
+
+/* resets endpoint halt+toggle; used to implement set_interface.
+ * some hardware (like pxa2xx) can't support this.
+ */
+#define	GADGETFS_CLEAR_HALT	_IO('g',3)
+
+#endif /* __LINUX_USB_GADGETFS_H */
--- a/include/linux/usb_gadgetfs.h
+++ /dev/null
@@ -1,75 +0,0 @@
-
-#include <asm/types.h>
-#include <asm/ioctl.h>
-
-#include <linux/usb/ch9.h>
-
-/*
- * Filesystem based user-mode API to USB Gadget controller hardware
- *
- * Almost everything can be done with only read and write operations,
- * on endpoint files found in one directory.  They are configured by
- * writing descriptors, and then may be used for normal stream style
- * i/o requests.  When ep0 is configured, the device can enumerate;
- * when it's closed, the device disconnects from usb.
- *
- * Configuration and device descriptors get written to /dev/gadget/$CHIP,
- * which may then be used to read usb_gadgetfs_event structs.  The driver
- * may activate endpoints as it handles SET_CONFIGURATION setup events,
- * or earlier; writing endpoint descriptors to /dev/gadget/$ENDPOINT
- * then performing data transfers by reading or writing.
- */
-
-/*
- * Events are delivered on the ep0 file descriptor, if the user mode driver
- * reads from this file descriptor after writing the descriptors.  Don't
- * stop polling this descriptor, if you write that kind of driver.
- */
-
-enum usb_gadgetfs_event_type {
-	GADGETFS_NOP = 0,
-
-	GADGETFS_CONNECT,
-	GADGETFS_DISCONNECT,
-	GADGETFS_SETUP,
-	GADGETFS_SUSPEND,
-	// and likely more !
-};
-
-struct usb_gadgetfs_event {
-	enum usb_gadgetfs_event_type	type;
-	union {
-		// NOP, DISCONNECT, SUSPEND: nothing
-		// ... some hardware can't report disconnection
-
-		// CONNECT: just the speed
-		enum usb_device_speed	speed;
-
-		// SETUP: packet; DATA phase i/o precedes next event
-		// (setup.bmRequestType & USB_DIR_IN) flags direction 
-		// ... includes SET_CONFIGURATION, SET_INTERFACE
-		struct usb_ctrlrequest	setup;
-	} u;
-};
-
-
-/* endpoint ioctls */
-
-/* IN transfers may be reported to the gadget driver as complete
- * 	when the fifo is loaded, before the host reads the data;
- * OUT transfers may be reported to the host's "client" driver as
- * 	complete when they're sitting in the FIFO unread.
- * THIS returns how many bytes are "unclaimed" in the endpoint fifo
- * (needed for precise fault handling, when the hardware allows it)
- */
-#define	GADGETFS_FIFO_STATUS	_IO('g',1)
-
-/* discards any unclaimed data in the fifo. */
-#define	GADGETFS_FIFO_FLUSH	_IO('g',2)
-
-/* resets endpoint halt+toggle; used to implement set_interface.
- * some hardware (like pxa2xx) can't support this.
- */
-#define	GADGETFS_CLEAR_HALT	_IO('g',3)
-
-
