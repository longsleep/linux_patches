From foo@baz Tue Apr  9 12:12:43 2002
Date: Tue, 11 Sep 2007 14:07:31 -0700
From: Tony Jones <tonyj@suse.de>
To: Greg KH <greg@kroah.com>
Subject: USB: convert ehci debug files to use debugfs instead of sysfs

We should not have multiple line files in sysfs, this moves the data to
debugfs instead, like the UHCI driver.

Signed-off-by: Tony Jones <tonyj@suse.de>
Cc: Kay Sievers <kay.sievers@vrfy.org>
Cc: David Brownell <david-b@pacbell.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/ehci-dbg.c |  227 ++++++++++++++++++++++++++++++++++++--------
 drivers/usb/host/ehci-hcd.c |   28 +++++
 drivers/usb/host/ehci.h     |    8 +
 3 files changed, 223 insertions(+), 40 deletions(-)

--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -323,7 +323,43 @@ static inline void remove_debug_files (s
 
 #else
 
-/* troubleshooting help: expose state in sysfs */
+/* troubleshooting help: expose state in debugfs */
+
+static int debug_async_open(struct inode *, struct file *);
+static int debug_periodic_open(struct inode *, struct file *);
+static int debug_registers_open(struct inode *, struct file *);
+static int debug_async_open(struct inode *, struct file *);
+static ssize_t debug_output(struct file*, char __user*, size_t, loff_t*);
+static int debug_close(struct inode *, struct file *);
+
+static const struct file_operations debug_async_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_async_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+static const struct file_operations debug_periodic_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_periodic_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+static const struct file_operations debug_registers_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_registers_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+
+static struct dentry	*ehci_debug_root = NULL;
+
+struct debug_buffer {
+	ssize_t (*fill_func)(struct debug_buffer*);	/* fill method */
+	struct usb_bus *bus;
+	struct mutex mutex;	/* protect filling of buffer */
+	size_t count;		/* number of characters filled into buffer */
+	char *page;
+};
 
 #define speed_char(info1) ({ char tmp; \
 		switch (info1 & (3 << 12)) { \
@@ -441,10 +477,8 @@ done:
 	*nextp = next;
 }
 
-static ssize_t
-show_async(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t fill_async_buffer(struct debug_buffer *buf)
 {
-	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
 	struct ehci_hcd		*ehci;
 	unsigned long		flags;
@@ -452,14 +486,13 @@ show_async(struct device *dev, struct de
 	char			*next;
 	struct ehci_qh		*qh;
 
-	*buf = 0;
-
-	bus = dev_get_drvdata(dev);
-	hcd = bus_to_hcd(bus);
+	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf;
+	next = buf->page;
 	size = PAGE_SIZE;
 
+	*next = 0;
+
 	/* dumps a snapshot of the async schedule.
 	 * usually empty except for long-term bulk reads, or head.
 	 * one QH per line, and TDs we know about
@@ -477,16 +510,12 @@ show_async(struct device *dev, struct de
 	}
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
-	return strlen (buf);
+	return strlen(buf->page);
 }
-static DEVICE_ATTR(async, S_IRUGO, show_async, NULL);
 
 #define DBG_SCHED_LIMIT 64
-
-static ssize_t
-show_periodic(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 {
-	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
 	struct ehci_hcd		*ehci;
 	unsigned long		flags;
@@ -500,10 +529,9 @@ show_periodic(struct device *dev, struct
 		return 0;
 	seen_count = 0;
 
-	bus = dev_get_drvdata(dev);
-	hcd = bus_to_hcd(bus);
+	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf;
+	next = buf->page;
 	size = PAGE_SIZE;
 
 	temp = scnprintf (next, size, "size = %d\n", ehci->periodic_size);
@@ -623,14 +651,10 @@ show_periodic(struct device *dev, struct
 
 	return PAGE_SIZE - size;
 }
-static DEVICE_ATTR(periodic, S_IRUGO, show_periodic, NULL);
-
 #undef DBG_SCHED_LIMIT
 
-static ssize_t
-show_registers(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 {
-	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
 	struct ehci_hcd		*ehci;
 	unsigned long		flags;
@@ -639,15 +663,14 @@ show_registers(struct device *dev, struc
 	static char		fmt [] = "%*s\n";
 	static char		label [] = "";
 
-	bus = dev_get_drvdata(dev);
-	hcd = bus_to_hcd(bus);
+	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf;
+	next = buf->page;
 	size = PAGE_SIZE;
 
 	spin_lock_irqsave (&ehci->lock, flags);
 
-	if (bus->controller->power.power_state.event) {
+	if (buf->bus->controller->power.power_state.event) {
 		size = scnprintf (next, size,
 			"bus %s, device %s (driver " DRIVER_VERSION ")\n"
 			"%s\n"
@@ -789,26 +812,152 @@ done:
 
 	return PAGE_SIZE - size;
 }
-static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
+
+static struct debug_buffer*
+alloc_buffer(struct usb_bus *bus, ssize_t (*fill_func)(struct debug_buffer*))
+{
+	struct debug_buffer *buf;
+
+	buf = kzalloc(sizeof (struct debug_buffer), GFP_KERNEL);
+
+	if (buf) {
+		buf->bus = bus;
+		buf->fill_func=fill_func;
+		mutex_init(&buf->mutex);
+	}
+
+	return buf;
+}
+
+static int fill_buffer(struct debug_buffer *buf)
+{
+	int ret=0;
+
+	if (!buf->page)
+		buf->page = (char *)get_zeroed_page(GFP_KERNEL);
+
+	if (!buf->page) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = buf->fill_func(buf);
+
+	if (ret >= 0) {
+		buf->count = ret;
+		ret = 0;
+	}
+
+out:
+	return ret;
+}
+
+static ssize_t debug_output(struct file *file, char __user *user_buf,
+			    size_t len, loff_t *offset)
+{
+	struct debug_buffer *buf = file->private_data;
+	int ret = 0;
+
+	mutex_lock(&buf->mutex);
+	if (buf->count == 0) {
+		ret = fill_buffer(buf);
+		if (ret != 0) {
+			mutex_unlock(&buf->mutex);
+			goto out;
+		}
+	}
+	mutex_unlock(&buf->mutex);
+
+	ret = simple_read_from_buffer(user_buf, len, offset,
+				      buf->page, buf->count);
+
+out:
+	return ret;
+
+}
+
+static int debug_close(struct inode *inode, struct file *file)
+{
+	struct debug_buffer *buf = file->private_data;
+
+	if (buf) {
+		if (buf->page)
+			free_page((unsigned long)buf->page);
+		kfree(buf);
+	}
+
+	return 0;
+}
+static int debug_async_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private, fill_async_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
+
+static int debug_periodic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private,
+					  fill_periodic_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
+
+static int debug_registers_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private,
+					  fill_registers_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
 
 static inline void create_debug_files (struct ehci_hcd *ehci)
 {
-	struct device *dev = ehci_to_hcd(ehci)->self.dev;
-	int retval;
+	struct usb_bus *bus = &ehci_to_hcd(ehci)->self;
 
-	retval = device_create_file(dev, &dev_attr_async);
-	retval = device_create_file(dev, &dev_attr_periodic);
-	retval = device_create_file(dev, &dev_attr_registers);
+	ehci->debug_dir=debugfs_create_dir(bus->bus_name, ehci_debug_root);
+	if (!ehci->debug_dir || IS_ERR(ehci->debug_dir)) {
+		ehci->debug_dir = NULL;
+		goto done;
+	}
+
+	ehci->debug_async =
+		debugfs_create_file("async", S_IRUGO, ehci->debug_dir,
+				    bus, &debug_async_fops);
+	if (!ehci->debug_async || IS_ERR(ehci->debug_async))
+		goto async_error;
+
+	ehci->debug_periodic =
+		debugfs_create_file("periodic", S_IRUGO, ehci->debug_dir,
+				    bus, &debug_periodic_fops);
+	if (!ehci->debug_periodic || IS_ERR(ehci->debug_periodic))
+		goto periodic_error;
+
+	ehci->debug_registers =
+		debugfs_create_file("registers", S_IRUGO, ehci->debug_dir,
+				    bus, &debug_registers_fops);
+	if (!ehci->debug_registers || IS_ERR(ehci->debug_registers))
+		goto registers_error;
+
+	goto done;
+
+registers_error:
+	debugfs_remove(ehci->debug_periodic); ehci->debug_periodic = NULL;
+periodic_error:
+	debugfs_remove(ehci->debug_async); ehci->debug_async = NULL;
+async_error:
+	debugfs_remove(ehci->debug_dir); ehci->debug_dir = NULL;
+
+done:
+	return;
 }
 
 static inline void remove_debug_files (struct ehci_hcd *ehci)
 {
-	struct device *dev = ehci_to_hcd(ehci)->self.dev;
-
-	device_remove_file(dev, &dev_attr_async);
-	device_remove_file(dev, &dev_attr_periodic);
-	device_remove_file(dev, &dev_attr_registers);
+	debugfs_remove(ehci->debug_registers);
+	debugfs_remove(ehci->debug_periodic);
+	debugfs_remove(ehci->debug_async);
+	debugfs_remove(ehci->debug_dir);
 }
 
 #endif /* STUB_DEBUG_FILES */
-
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -33,6 +33,7 @@
 #include <linux/usb.h>
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
 
 #include "../core/hcd.h"
 
@@ -978,15 +979,34 @@ static int __init ehci_hcd_init(void)
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
+#ifdef DEBUG
+	ehci_debug_root=debugfs_create_dir("ehci", NULL);
+	if (!ehci_debug_root || IS_ERR(ehci_debug_root)) {
+		if (!ehci_debug_root)
+			retval = -ENOENT;
+		else
+			retval = PTR_ERR(ehci_debug_root);
+
+		return retval;
+	}
+#endif
+
 #ifdef PLATFORM_DRIVER
 	retval = platform_driver_register(&PLATFORM_DRIVER);
-	if (retval < 0)
+	if (retval < 0) {
+#ifdef DEBUG
+		debugfs_remove(ehci_debug_root); ehci_debug_root=NULL;
+#endif
 		return retval;
+	}
 #endif
 
 #ifdef PCI_DRIVER
 	retval = pci_register_driver(&PCI_DRIVER);
 	if (retval < 0) {
+#ifdef DEBUG
+		debugfs_remove(ehci_debug_root); ehci_debug_root=NULL;
+#endif
 #ifdef PLATFORM_DRIVER
 		platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
@@ -997,6 +1017,9 @@ static int __init ehci_hcd_init(void)
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
 	if (retval < 0) {
+#ifdef DEBUG
+		debugfs_remove(ehci_debug_root); ehci_debug_root=NULL;
+#endif
 #ifdef PLATFORM_DRIVER
 		platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
@@ -1022,6 +1045,9 @@ static void __exit ehci_hcd_cleanup(void
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
+#ifdef DEBUG
+	debugfs_remove(ehci_debug_root);
+#endif
 }
 module_exit(ehci_hcd_cleanup);
 
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -127,6 +127,14 @@ struct ehci_hcd {			/* one per controlle
 #else
 #	define COUNT(x) do {} while (0)
 #endif
+
+	/* debug files */
+#ifdef DEBUG
+	struct dentry		*debug_dir;
+	struct dentry		*debug_async;
+	struct dentry		*debug_periodic;
+	struct dentry		*debug_registers;
+#endif
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
