From zaitcev@redhat.com Tue Jul 10 20:08:47 2007
From: Pete Zaitcev <zaitcev@redhat.com>
Date: Tue, 10 Jul 2007 20:09:58 -0700
Subject: USB: usblp: "Big cleanup" breaks O_NONBLOCK
To: greg@kroah.com
Cc: linux-usb-devel@lists.sourceforge.net, zaitcev@redhat.com
Message-ID: <20070710200958.1a6a86ae.zaitcev@redhat.com>


I found the first regresson in the rewritten ("all dynamic" and "no races")
driver. If application uses O_NONBLOCK, I return -EAGAIN despite the URB
being submitted successfuly. This causes the application to resubmit the
same data erroneously.

The fix is to pretend that the transfer has succeeded even if URB was
merely queued. It is the same behaviour as with the old version.

Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/class/usblp.c |    9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

--- a/drivers/usb/class/usblp.c
+++ b/drivers/usb/class/usblp.c
@@ -741,10 +741,11 @@ static ssize_t usblp_write(struct file *
 		 */
 		rv = usblp_wwait(usblp, !!(file->f_flags&O_NONBLOCK));
 		if (rv < 0) {
-			/*
-			 * If interrupted, we simply leave the URB to dangle,
-			 * so the ->release will call usb_kill_urb().
-			 */
+			if (rv == -EAGAIN) {
+				/* Presume that it's going to complete well. */
+				writecount += transfer_length;
+			}
+			/* Leave URB dangling, to be cleaned on close. */
 			goto collect_error;
 		}
 
