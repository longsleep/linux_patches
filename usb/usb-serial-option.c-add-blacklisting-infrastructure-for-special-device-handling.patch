From gernot@hillier.de  Fri Jan 15 14:46:01 2010
From: Gernot Hillier <gernot@hillier.de>
Date: Mon, 11 Jan 2010 09:30:00 +0100
Subject: USB: serial: option.c: Add blacklisting infrastructure for special device handling
To: Matthias Urlichs <smurf@smurf.noris.de>, Greg Kroah-Hartman <gregkh@suse.de>, Oliver Neukum <oliver@neukum.org>
Message-ID: <4B4AE188.5010004@hillier.de>


From: Gernot Hillier <gernot@hillier.de>

As suggested by Matthias Urlichs, this patch adds a somehow generic
mechanism for special handling of devices which don't support all bits
expected by this driver.

The blacklisting code is heavily stolen from sierra.c, but extended to
support different special cases.

For now, one case is implemented (OPTION_BLACKLIST_SENDSETUP), targeted
at the 4G W14 device: devices which don't understand the setting of
RTS/DTR in option_send_setup() causing a USB timeout of 5 s in any
userspace open() which leads to errors in most userspace applications.

In addition, I prepared another case for devices with interfaces which
shall not be accessed by this driver (targeted at the D-Link DWM 652).

However, OPTION_BLACKLIST_RESERVED_IF is not fully implemented yet as I
have no device to test this. Anyone volunteering to help here?  If not,
I'll contact the guys who added D-Link DWM 652 support soon.

Signed-off-by: Gernot Hillier <gernot@hillier.de>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/serial/option.c |   40 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -346,6 +346,19 @@ static int  option_resume(struct usb_ser
 #define HAIER_VENDOR_ID				0x201e
 #define HAIER_PRODUCT_CE100			0x2009
 
+/* some devices interfaces need special handling due to a number of reasons */
+enum option_blacklist_reason {
+		OPTION_BLACKLIST_NONE = 0,
+		OPTION_BLACKLIST_SENDSETUP = 1,
+		OPTION_BLACKLIST_RESERVED_IF = 2
+};
+
+struct option_blacklist_info {
+	const u32 infolen;	/* number of interface numbers on blacklist */
+	const u8  *ifaceinfo;	/* pointer to the array holding the numbers */
+	enum option_blacklist_reason reason;
+};
+
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
@@ -711,6 +724,7 @@ struct option_intf_private {
 	spinlock_t susp_lock;
 	unsigned int suspended:1;
 	int in_flight;
+	struct option_blacklist_info *blacklist_info;
 };
 
 struct option_port_private {
@@ -780,9 +794,27 @@ static int option_probe(struct usb_seria
 	if (!data)
 		return -ENOMEM;
 	spin_lock_init(&data->susp_lock);
+	data->blacklist_info = (struct option_blacklist_info*) id->driver_info;
 	return 0;
 }
 
+static enum option_blacklist_reason is_blacklisted(const u8 ifnum,
+				const struct option_blacklist_info *blacklist)
+{
+	const u8  *info;
+	int i;
+
+	if (blacklist) {
+		info = blacklist->ifaceinfo;
+
+		for (i = 0; i < blacklist->infolen; i++) {
+			if (info[i] == ifnum)
+				return blacklist->reason;
+		}
+	}
+	return OPTION_BLACKLIST_NONE;
+}
+
 static void option_set_termios(struct tty_struct *tty,
 		struct usb_serial_port *port, struct ktermios *old_termios)
 {
@@ -1213,11 +1245,19 @@ static void option_setup_urbs(struct usb
 static int option_send_setup(struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port->serial;
+	struct option_intf_private *intfdata =
+		(struct option_intf_private *) serial->private;
 	struct option_port_private *portdata;
 	int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
 	int val = 0;
 	dbg("%s", __func__);
 
+	if (is_blacklisted(ifNum, intfdata->blacklist_info) ==
+						OPTION_BLACKLIST_SENDSETUP) {
+		dbg("No send_setup on blacklisted interface #%d\n", ifNum);
+		return -EIO;
+	}
+
 	portdata = usb_get_serial_port_data(port);
 
 	if (portdata->dtr_state)
