From stern@rowland.harvard.edu Fri May 11 07:19:08 2007
Date: Fri, 11 May 2007 10:19:04 -0400 (EDT)
From: Alan Stern <stern@rowland.harvard.edu>
To: Greg KH <greg@kroah.com>
cc: mrb74@gmx.at, USB development list <linux-usb-devel@lists.sourceforge.net>
Subject: USB: remove short initial timeout for device descriptor fetch
Message-ID: <Pine.LNX.4.44L0.0705111017300.2825-100000@iolanthe.rowland.org>

This patch (as905) removes a micro-optimization from the hub port
initialization code.  Previously we had been using a short timeout on
the first attempt the read the device descriptor; now we will use the
standard timeout length.

It's not clear that the short timeout ever provided any benefit.  And
now we know of one case where it actually hurts: The device can't meet
the short timeout and then it gets terminally confused.

This fixes Bugzilla #8444.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/hub.c |   13 ++++---------
 1 file changed, 4 insertions(+), 9 deletions(-)

--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2201,14 +2201,9 @@ hub_port_init (struct usb_hub *hub, stru
 				continue;
 			}
 
-			/* Use a short timeout the first time through,
-			 * so that recalcitrant full-speed devices with
-			 * 8- or 16-byte ep0-maxpackets won't slow things
-			 * down tremendously by NAKing the unexpectedly
-			 * early status stage.  Also, retry on all errors;
-			 * some devices are flakey.
-			 * 255 is for WUSB devices, we actually need to use 512.
-			 * WUSB1.0[4.8.1].
+			/* Retry on all errors; some devices are flakey.
+			 * 255 is for WUSB devices, we actually need to use
+			 * 512 (WUSB1.0[4.8.1]).
 			 */
 			for (j = 0; j < 3; ++j) {
 				buf->bMaxPacketSize0 = 0;
@@ -2216,7 +2211,7 @@ hub_port_init (struct usb_hub *hub, stru
 					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
 					USB_DT_DEVICE << 8, 0,
 					buf, GET_DESCRIPTOR_BUFSIZE,
-					(i ? USB_CTRL_GET_TIMEOUT : 1000));
+					USB_CTRL_GET_TIMEOUT);
 				switch (buf->bMaxPacketSize0) {
 				case 8: case 16: case 32: case 64: case 255:
 					if (buf->bDescriptorType ==
