From linux-kernel-owner+greg=40kroah.com-S1760641AbYFTUSd@vger.kernel.org Fri Jun 20 13:32:15 2008
From: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date: Fri, 20 Jun 2008 20:59:23 +0100
Subject: riscom8: use tty_port
To: linux-kernel@vger.kernel.org
Message-ID: <20080620195921.1479.59989.stgit@localhost.localdomain>


From: Alan Cox <alan@redhat.com>

Switch riscom8 to use the new tty_port structure

Signed-off-by: Alan Cox <alan@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/char/riscom8.c |  145 ++++++++++++++++++++++---------------------------
 drivers/char/riscom8.h |    8 --
 2 files changed, 68 insertions(+), 85 deletions(-)

--- a/drivers/char/riscom8.c
+++ b/drivers/char/riscom8.c
@@ -322,7 +322,7 @@ static struct riscom_port *rc_get_port(s
 	channel = rc_in(bp, CD180_GICR) >> GICR_CHAN_OFF;
 	if (channel < CD180_NCH)  {
 		port = &rc_port[board_No(bp) * RC_NPORT + channel];
-		if (port->flags & ASYNC_INITIALIZED)
+		if (port->port.flags & ASYNC_INITIALIZED)
 			return port;
 	}
 	printk(KERN_ERR "rc%d: %s interrupt from invalid port %d\n",
@@ -341,7 +341,7 @@ static void rc_receive_exc(struct riscom
 	if (port == NULL)
 		return;
 
-	tty = port->tty;
+	tty = port->port.tty;
 
 #ifdef RC_REPORT_OVERRUN
 	status = rc_in(bp, CD180_RCSR);
@@ -364,7 +364,7 @@ static void rc_receive_exc(struct riscom
 		printk(KERN_INFO "rc%d: port %d: Handling break...\n",
 		       board_No(bp), port_No(port));
 		flag = TTY_BREAK;
-		if (port->flags & ASYNC_SAK)
+		if (port->port.flags & ASYNC_SAK)
 			do_SAK(tty);
 
 	} else if (status & RCSR_PE)
@@ -392,7 +392,7 @@ static void rc_receive(struct riscom_boa
 	if (port == NULL)
 		return;
 
-	tty = port->tty;
+	tty = port->port.tty;
 
 	count = rc_in(bp, CD180_RDCR);
 
@@ -422,7 +422,7 @@ static void rc_transmit(struct riscom_bo
 	if (port == NULL)
 		return;
 
-	tty = port->tty;
+	tty = port->port.tty;
 
 	if (port->IER & IER_TXEMPTY) {
 		/* FIFO drained */
@@ -467,7 +467,7 @@ static void rc_transmit(struct riscom_bo
 
 	count = CD180_NFIFO;
 	do {
-		rc_out(bp, CD180_TDR, port->xmit_buf[port->xmit_tail++]);
+		rc_out(bp, CD180_TDR, port->port.xmit_buf[port->xmit_tail++]);
 		port->xmit_tail = port->xmit_tail & (SERIAL_XMIT_SIZE-1);
 		if (--port->xmit_cnt <= 0)
 			break;
@@ -492,12 +492,12 @@ static void rc_check_modem(struct riscom
 	if (port == NULL)
 		return;
 
-	tty = port->tty;
+	tty = port->port.tty;
 
 	mcr = rc_in(bp, CD180_MCR);
 	if (mcr & MCR_CDCHG) {
 		if (rc_in(bp, CD180_MSVR) & MSVR_CD)
-			wake_up_interruptible(&port->open_wait);
+			wake_up_interruptible(&port->port.open_wait);
 		else
 			tty_hangup(tty);
 	}
@@ -632,7 +632,7 @@ static void rc_shutdown_board(struct ris
  */
 static void rc_change_speed(struct riscom_board *bp, struct riscom_port *port)
 {
-	struct tty_struct *tty = port->tty;
+	struct tty_struct *tty = port->port.tty;
 	unsigned long baud;
 	long tmp;
 	unsigned char cor1 = 0, cor3 = 0;
@@ -786,28 +786,21 @@ static int rc_setup_port(struct riscom_b
 {
 	unsigned long flags;
 
-	if (port->flags & ASYNC_INITIALIZED)
+	if (port->port.flags & ASYNC_INITIALIZED)
 		return 0;
 
-	if (!port->xmit_buf) {
-		/* We may sleep in get_zeroed_page() */
-		unsigned long tmp = get_zeroed_page(GFP_KERNEL);
-		if (tmp == 0)
-			return -ENOMEM;
-		if (port->xmit_buf)
-			free_page(tmp);
-		else
-			port->xmit_buf = (unsigned char *) tmp;
-	}
+	if (tty_port_alloc_xmit_buf(&port->port) < 0)
+		return -ENOMEM;
+
 	spin_lock_irqsave(&riscom_lock, flags);
 
-	if (port->tty)
-		clear_bit(TTY_IO_ERROR, &port->tty->flags);
-	if (port->count == 1)
+	if (port->port.tty)
+		clear_bit(TTY_IO_ERROR, &port->port.tty->flags);
+	if (port->port.count == 1)
 		bp->count++;
 	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
 	rc_change_speed(bp, port);
-	port->flags |= ASYNC_INITIALIZED;
+	port->port.flags |= ASYNC_INITIALIZED;
 
 	spin_unlock_irqrestore(&riscom_lock, flags);
 	return 0;
@@ -818,7 +811,7 @@ static void rc_shutdown_port(struct risc
 {
 	struct tty_struct *tty;
 
-	if (!(port->flags & ASYNC_INITIALIZED))
+	if (!(port->port.flags & ASYNC_INITIALIZED))
 		return;
 
 #ifdef RC_REPORT_OVERRUN
@@ -836,12 +829,9 @@ static void rc_shutdown_port(struct risc
 		printk("].\n");
 	}
 #endif
-	if (port->xmit_buf)  {
-		free_page((unsigned long) port->xmit_buf);
-		port->xmit_buf = NULL;
-	}
+	tty_port_free_xmit_buf(&port->port);
 
-	tty = port->tty;
+	tty = port->port.tty;
 
 	if (tty == NULL || C_HUPCL(tty)) {
 		/* Drop DTR */
@@ -860,7 +850,7 @@ static void rc_shutdown_port(struct risc
 
 	if (tty)
 		set_bit(TTY_IO_ERROR, &tty->flags);
-	port->flags &= ~ASYNC_INITIALIZED;
+	port->port.flags &= ~ASYNC_INITIALIZED;
 
 	if (--bp->count < 0)  {
 		printk(KERN_INFO "rc%d: rc_shutdown_port: "
@@ -890,9 +880,9 @@ static int block_til_ready(struct tty_st
 	 * If the device is in the middle of being closed, then block
 	 * until it's done, and then try again.
 	 */
-	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {
-		interruptible_sleep_on(&port->close_wait);
-		if (port->flags & ASYNC_HUP_NOTIFY)
+	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
+		interruptible_sleep_on(&port->port.close_wait);
+		if (port->port.flags & ASYNC_HUP_NOTIFY)
 			return -EAGAIN;
 		else
 			return -ERESTARTSYS;
@@ -904,7 +894,7 @@ static int block_til_ready(struct tty_st
 	 */
 	if ((filp->f_flags & O_NONBLOCK) ||
 	    (tty->flags & (1 << TTY_IO_ERROR))) {
-		port->flags |= ASYNC_NORMAL_ACTIVE;
+		port->port.flags |= ASYNC_NORMAL_ACTIVE;
 		return 0;
 	}
 
@@ -919,16 +909,16 @@ static int block_til_ready(struct tty_st
 	 * exit, either normal or abnormal.
 	 */
 	retval = 0;
-	add_wait_queue(&port->open_wait, &wait);
+	add_wait_queue(&port->port.open_wait, &wait);
 
 	spin_lock_irqsave(&riscom_lock, flags);
 
 	if (!tty_hung_up_p(filp))
-		port->count--;
+		port->port.count--;
 
 	spin_unlock_irqrestore(&riscom_lock, flags);
 
-	port->blocked_open++;
+	port->port.blocked_open++;
 	while (1) {
 		spin_lock_irqsave(&riscom_lock, flags);
 
@@ -942,14 +932,14 @@ static int block_til_ready(struct tty_st
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (tty_hung_up_p(filp) ||
-		    !(port->flags & ASYNC_INITIALIZED)) {
-			if (port->flags & ASYNC_HUP_NOTIFY)
+		    !(port->port.flags & ASYNC_INITIALIZED)) {
+			if (port->port.flags & ASYNC_HUP_NOTIFY)
 				retval = -EAGAIN;
 			else
 				retval = -ERESTARTSYS;
 			break;
 		}
-		if (!(port->flags & ASYNC_CLOSING) &&
+		if (!(port->port.flags & ASYNC_CLOSING) &&
 		    (do_clocal || CD))
 			break;
 		if (signal_pending(current)) {
@@ -959,14 +949,14 @@ static int block_til_ready(struct tty_st
 		schedule();
 	}
 	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&port->open_wait, &wait);
+	remove_wait_queue(&port->port.open_wait, &wait);
 	if (!tty_hung_up_p(filp))
-		port->count++;
-	port->blocked_open--;
+		port->port.count++;
+	port->port.blocked_open--;
 	if (retval)
 		return retval;
 
-	port->flags |= ASYNC_NORMAL_ACTIVE;
+	port->port.flags |= ASYNC_NORMAL_ACTIVE;
 	return 0;
 }
 
@@ -990,9 +980,9 @@ static int rc_open(struct tty_struct *tt
 	if (error)
 		return error;
 
-	port->count++;
+	port->port.count++;
 	tty->driver_data = port;
-	port->tty = tty;
+	port->port.tty = tty;
 
 	error = rc_setup_port(bp, port);
 	if (error == 0)
@@ -1031,21 +1021,21 @@ static void rc_close(struct tty_struct *
 		goto out;
 
 	bp = port_Board(port);
-	if ((tty->count == 1) && (port->count != 1))  {
+	if ((tty->count == 1) && (port->port.count != 1))  {
 		printk(KERN_INFO "rc%d: rc_close: bad port count;"
 		       " tty->count is 1, port count is %d\n",
-		       board_No(bp), port->count);
-		port->count = 1;
+		       board_No(bp), port->port.count);
+		port->port.count = 1;
 	}
-	if (--port->count < 0)  {
+	if (--port->port.count < 0)  {
 		printk(KERN_INFO "rc%d: rc_close: bad port count "
 				 "for tty%d: %d\n",
-		       board_No(bp), port_No(port), port->count);
-		port->count = 0;
+		       board_No(bp), port_No(port), port->port.count);
+		port->port.count = 0;
 	}
-	if (port->count)
+	if (port->port.count)
 		goto out;
-	port->flags |= ASYNC_CLOSING;
+	port->port.flags |= ASYNC_CLOSING;
 	/*
 	 * Now we wait for the transmit buffer to clear; and we notify
 	 * the line discipline to only process XON/XOFF characters.
@@ -1060,7 +1050,7 @@ static void rc_close(struct tty_struct *
 	 * line status register.
 	 */
 	port->IER &= ~IER_RXD;
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->port.flags & ASYNC_INITIALIZED) {
 		port->IER &= ~IER_TXRDY;
 		port->IER |= IER_TXEMPTY;
 		rc_out(bp, CD180_CAR, port_No(port));
@@ -1082,14 +1072,14 @@ static void rc_close(struct tty_struct *
 	tty_ldisc_flush(tty);
 
 	tty->closing = 0;
-	port->tty = NULL;
-	if (port->blocked_open) {
+	port->port.tty = NULL;
+	if (port->port.blocked_open) {
 		if (port->close_delay)
 			msleep_interruptible(jiffies_to_msecs(port->close_delay));
-		wake_up_interruptible(&port->open_wait);
+		wake_up_interruptible(&port->port.open_wait);
 	}
-	port->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-	wake_up_interruptible(&port->close_wait);
+	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	wake_up_interruptible(&port->port.close_wait);
 
 out:
 	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1108,7 +1098,7 @@ static int rc_write(struct tty_struct *t
 
 	bp = port_Board(port);
 
-	if (!tty || !port->xmit_buf)
+	if (!tty || !port->port.xmit_buf)
 		return 0;
 
 	while (1) {
@@ -1119,7 +1109,7 @@ static int rc_write(struct tty_struct *t
 		if (c <= 0)
 			break;	/* lock continues to be held */
 
-		memcpy(port->xmit_buf + port->xmit_head, buf, c);
+		memcpy(port->port.xmit_buf + port->xmit_head, buf, c);
 		port->xmit_head = (port->xmit_head + c) & (SERIAL_XMIT_SIZE-1);
 		port->xmit_cnt += c;
 
@@ -1151,7 +1141,7 @@ static int rc_put_char(struct tty_struct
 	if (rc_paranoia_check(port, tty->name, "rc_put_char"))
 		return 0;
 
-	if (!tty || !port->xmit_buf)
+	if (!tty || !port->port.xmit_buf)
 		return 0;
 
 	spin_lock_irqsave(&riscom_lock, flags);
@@ -1159,7 +1149,7 @@ static int rc_put_char(struct tty_struct
 	if (port->xmit_cnt >= SERIAL_XMIT_SIZE - 1)
 		goto out;
 
-	port->xmit_buf[port->xmit_head++] = ch;
+	port->port.xmit_buf[port->xmit_head++] = ch;
 	port->xmit_head &= SERIAL_XMIT_SIZE - 1;
 	port->xmit_cnt++;
 	ret = 1;
@@ -1178,7 +1168,7 @@ static void rc_flush_chars(struct tty_st
 		return;
 
 	if (port->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
-	    !port->xmit_buf)
+	    !port->port.xmit_buf)
 		return;
 
 	spin_lock_irqsave(&riscom_lock, flags);
@@ -1317,19 +1307,19 @@ static int rc_set_serial_info(struct ris
 		return -EINVAL;
 #endif
 
-	change_speed = ((port->flags & ASYNC_SPD_MASK) !=
+	change_speed = ((port->port.flags & ASYNC_SPD_MASK) !=
 			(tmp.flags & ASYNC_SPD_MASK));
 
 	if (!capable(CAP_SYS_ADMIN)) {
 		if ((tmp.close_delay != port->close_delay) ||
 		    (tmp.closing_wait != port->closing_wait) ||
 		    ((tmp.flags & ~ASYNC_USR_MASK) !=
-		     (port->flags & ~ASYNC_USR_MASK)))
+		     (port->port.flags & ~ASYNC_USR_MASK)))
 			return -EPERM;
-		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
+		port->port.flags = ((port->port.flags & ~ASYNC_USR_MASK) |
 			       (tmp.flags & ASYNC_USR_MASK));
 	} else  {
-		port->flags = ((port->flags & ~ASYNC_FLAGS) |
+		port->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |
 			       (tmp.flags & ASYNC_FLAGS));
 		port->close_delay = tmp.close_delay;
 		port->closing_wait = tmp.closing_wait;
@@ -1355,7 +1345,7 @@ static int rc_get_serial_info(struct ris
 	tmp.line = port - rc_port;
 	tmp.port = bp->base;
 	tmp.irq  = bp->irq;
-	tmp.flags = port->flags;
+	tmp.flags = port->port.flags;
 	tmp.baud_base = (RC_OSCFREQ + CD180_TPC/2) / CD180_TPC;
 	tmp.close_delay = port->close_delay * HZ/100;
 	tmp.closing_wait = port->closing_wait * HZ/100;
@@ -1480,7 +1470,7 @@ static void rc_start(struct tty_struct *
 
 	spin_lock_irqsave(&riscom_lock, flags);
 
-	if (port->xmit_cnt && port->xmit_buf && !(port->IER & IER_TXRDY)) {
+	if (port->xmit_cnt && port->port.xmit_buf && !(port->IER & IER_TXRDY)) {
 		port->IER |= IER_TXRDY;
 		rc_out(bp, CD180_CAR, port_No(port));
 		rc_out(bp, CD180_IER, port->IER);
@@ -1499,10 +1489,10 @@ static void rc_hangup(struct tty_struct 
 	bp = port_Board(port);
 
 	rc_shutdown_port(bp, port);
-	port->count = 0;
-	port->flags &= ~ASYNC_NORMAL_ACTIVE;
-	port->tty = NULL;
-	wake_up_interruptible(&port->open_wait);
+	port->port.count = 0;
+	port->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	port->port.tty = NULL;
+	wake_up_interruptible(&port->port.open_wait);
 }
 
 static void rc_set_termios(struct tty_struct *tty,
@@ -1578,8 +1568,7 @@ static int __init rc_init_drivers(void)
 		rc_port[i].magic = RISCOM8_MAGIC;
 		rc_port[i].close_delay = 50 * HZ / 100;
 		rc_port[i].closing_wait = 3000 * HZ / 100;
-		init_waitqueue_head(&rc_port[i].open_wait);
-		init_waitqueue_head(&rc_port[i].close_wait);
+		tty_port_init(&rc_port[i].port);
 	}
 	return 0;
 }
--- a/drivers/char/riscom8.h
+++ b/drivers/char/riscom8.h
@@ -66,20 +66,14 @@ struct riscom_board {
 	
 struct riscom_port {
 	int			magic;
+	struct			tty_port port;
 	int			baud_base;
-	int			flags;
-	struct tty_struct 	* tty;
-	int			count;
-	int			blocked_open;
 	int			timeout;
 	int			close_delay;
-	unsigned char 		* xmit_buf;
 	int			custom_divisor;
 	int			xmit_head;
 	int			xmit_tail;
 	int			xmit_cnt;
-	wait_queue_head_t	open_wait;
-	wait_queue_head_t	close_wait;
 	short			wakeup_chars;
 	short			break_length;
 	unsigned short		closing_wait;
