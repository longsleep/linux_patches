From akpm@linux-foundation.org Thu May 10 23:05:06 2007
Message-Id: <200705110604.l4B64DJ8008269@shell0.pdx.osdl.net>
From: Simon Arlott <simon@fire.lp0.eu>
Subject: USB: cxacru: ignore error trying to start ADSL in atm_start
To: greg@kroah.com
Cc: akpm@linux-foundation.org, simon@fire.lp0.eu, duncan.sands@math.u-psud.fr
Date: Thu, 10 May 2007 23:04:13 -0700

From: Simon Arlott <simon@fire.lp0.eu>

The sysfs adsl_status attribute ignores (aside from returning -EIO to the
user) any error sending a START/STOP command to the device and there is at
least one firmware which never sends a response but appears to work
regardless.  Therefore atm_start should also continue if an error is received
so that such firmware is usable.

The official Conexant driver doesn't expect a reply either but this is for
another device (E2 router) and a commonly used firmware does respond.

Also, there is no point in changing -ECONNRESET to -ETIMEDOUT since nothing
ever checks for either of these values.

Signed-off-by: Simon Arlott <simon@fire.lp0.eu>
Cc: Duncan Sands <duncan.sands@math.u-psud.fr>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/atm/cxacru.c |    7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

--- a/drivers/usb/atm/cxacru.c
+++ b/drivers/usb/atm/cxacru.c
@@ -476,8 +476,6 @@ static int cxacru_start_wait_urb(struct 
 	add_timer(&timer);
 	wait_for_completion(done);
 	status = urb->status;
-	if (status == -ECONNRESET)
-		status = -ETIMEDOUT;
 	del_timer_sync(&timer);
 
 	if (actual_length)
@@ -671,11 +669,8 @@ static int cxacru_atm_start(struct usbat
 	/* start ADSL */
 	mutex_lock(&instance->adsl_state_serialize);
 	ret = cxacru_cm(instance, CM_REQUEST_CHIP_ADSL_LINE_START, NULL, 0, NULL, 0);
-	if (ret < 0) {
+	if (ret < 0)
 		atm_err(usbatm_instance, "cxacru_atm_start: CHIP_ADSL_LINE_START returned %d\n", ret);
-		mutex_unlock(&instance->adsl_state_serialize);
-		return ret;
-	}
 
 	/* Start status polling */
 	mutex_lock(&instance->poll_state_serialize);
