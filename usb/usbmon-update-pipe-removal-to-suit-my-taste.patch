From zaitcev@redhat.com  Tue Aug 14 22:15:33 2007
From: Pete Zaitcev <zaitcev@redhat.com>
Date: Tue, 14 Aug 2007 00:33:40 -0700
Subject: usbmon: Update pipe removal to suit my taste
To: greg@kroah.com
Cc: linux-usb-devel@lists.sourceforge.net, zaitcev@redhat.com, Alan Stern <stern@rowland.harvard.edu>
Message-ID: <20070814003340.3729aaed.zaitcev@redhat.com>


This is a set of small updates to Alan's work to make the code more to
my liking. Mostly premature optimizations, but also direction of control
transfers in the binary interface was always out.

Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
Cc: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/mon/mon_bin.c  |   44 ++++++++++++++------------------------------
 drivers/usb/mon/mon_text.c |    8 ++++----
 2 files changed, 18 insertions(+), 34 deletions(-)

--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -172,6 +172,10 @@ static inline struct mon_bin_hdr *MON_OF
 
 #define MON_RING_EMPTY(rp)	((rp)->b_cnt == 0)
 
+static unsigned char xfer_to_pipe[4] = {
+	PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
+};
+
 static struct class *mon_bin_class;
 static dev_t mon_bin_dev0;
 static struct cdev mon_bin_cdev;
@@ -388,11 +392,13 @@ static char mon_bin_get_data(const struc
 static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
     char ev_type)
 {
+	const struct usb_endpoint_descriptor *epd = &urb->ep->desc;
 	unsigned long flags;
 	struct timeval ts;
 	unsigned int urb_length;
 	unsigned int offset;
 	unsigned int length;
+	unsigned char dir;
 	struct mon_bin_hdr *ep;
 	char data_tag = 0;
 
@@ -415,11 +421,14 @@ static void mon_bin_event(struct mon_rea
 			length = 0;
 			data_tag = '<';
 		}
+		/* Cannot rely on endpoint number in case of control ep.0 */
+		dir = USB_DIR_IN;
 	} else {
 		if (ev_type == 'C') {
 			length = 0;
 			data_tag = '>';
 		}
+		dir = 0;
 	}
 
 	if (rp->mmap_active)
@@ -440,21 +449,8 @@ static void mon_bin_event(struct mon_rea
 	 */
 	memset(ep, 0, PKT_SIZE);
 	ep->type = ev_type;
-	switch (usb_endpoint_type(&urb->ep->desc)) {
-	case USB_ENDPOINT_XFER_CONTROL:
-		ep->xfer_type = PIPE_CONTROL;
-		break;
-	case USB_ENDPOINT_XFER_BULK:
-		ep->xfer_type = PIPE_BULK;
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		ep->xfer_type = PIPE_INTERRUPT;
-		break;
-	default:
-		ep->xfer_type = PIPE_ISOCHRONOUS;
-		break;
-	}
-	ep->epnum = urb->ep->desc.bEndpointAddress;
+	ep->xfer_type = xfer_to_pipe[usb_endpoint_type(epd)];
+	ep->epnum = dir | usb_endpoint_num(epd);
 	ep->devnum = urb->dev->devnum;
 	ep->busnum = urb->dev->bus->busnum;
 	ep->id = (unsigned long) urb;
@@ -512,21 +508,9 @@ static void mon_bin_error(void *data, st
 
 	memset(ep, 0, PKT_SIZE);
 	ep->type = 'E';
-	switch (usb_endpoint_type(&urb->ep->desc)) {
-	case USB_ENDPOINT_XFER_CONTROL:
-		ep->xfer_type = PIPE_CONTROL;
-		break;
-	case USB_ENDPOINT_XFER_BULK:
-		ep->xfer_type = PIPE_BULK;
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		ep->xfer_type = PIPE_INTERRUPT;
-		break;
-	default:
-		ep->xfer_type = PIPE_ISOCHRONOUS;
-		break;
-	}
-	ep->epnum = urb->ep->desc.bEndpointAddress;
+	ep->xfer_type = xfer_to_pipe[usb_endpoint_type(&urb->ep->desc)];
+	ep->epnum = usb_urb_dir_in(urb) ? USB_DIR_IN : 0;
+	ep->epnum |= usb_endpoint_num(&urb->ep->desc);
 	ep->devnum = urb->dev->devnum;
 	ep->busnum = urb->dev->bus->busnum;
 	ep->id = (unsigned long) urb;
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -52,10 +52,11 @@ struct mon_event_text {
 	int type;		/* submit, complete, etc. */
 	unsigned long id;	/* From pointer, most of the time */
 	unsigned int tstamp;
-	int xfertype;
 	int busnum;
-	int devnum;
-	int epnum;
+	char devnum;
+	char epnum;
+	char is_in;
+	char xfertype;
 	int length;		/* Depends on type: xfer length or act length */
 	int status;
 	int interval;
@@ -63,7 +64,6 @@ struct mon_event_text {
 	int error_count;
 	char setup_flag;
 	char data_flag;
-	char is_in;
 	int numdesc;		/* Full number */
 	struct mon_iso_desc isodesc[ISODESC_MAX];
 	unsigned char setup[SETUP_MAX];
