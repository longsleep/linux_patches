From sarah.a.sharp@linux.intel.com  Wed Oct  8 14:20:40 2008
From: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date: Mon, 6 Oct 2008 14:45:46 -0700
Subject: USB: Export if an interface driver supports autosuspend.
To: Greg KH <greg@kroah.com>
Cc: linux-usb@vger.kernel.org
Message-ID: <20081006214546.GA8342@localdomain>
Content-Disposition: inline


Create a new sysfs file per interface named supports_autosuspend.  This
file returns true if an interface driver's .supports_autosuspend flag is
set.  It also returns true if the interface is unclaimed (since the USB
core will autosuspend a device if an interface is not claimed).

This new sysfs file will be useful for user space scripts to test whether
a USB device correctly auto-suspends.

Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Cc: Oliver Neukum <oliver@neukum.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 Documentation/ABI/testing/sysfs-bus-usb |   16 ++++++++++++++++
 drivers/usb/core/sysfs.c                |   24 ++++++++++++++++++++++++
 2 files changed, 40 insertions(+)

--- a/Documentation/ABI/testing/sysfs-bus-usb
+++ b/Documentation/ABI/testing/sysfs-bus-usb
@@ -85,3 +85,19 @@ Description:
 Users:
 		PowerTOP <power@bughost.org>
 		http://www.lesswatts.org/projects/powertop/
+
+What:		/sys/bus/usb/device/<busnum>-<devnum>...:<config num>-<interface num>/supports_autosuspend
+Date:		January 2008
+KernelVersion:	2.6.27
+Contact:	Sarah Sharp <sarah.a.sharp@intel.com>
+Description:
+		When read, this file returns 1 if the interface driver
+		for this interface supports autosuspend.  It also
+		returns 1 if no driver has claimed this interface, as an
+		unclaimed interface will not stop the device from being
+		autosuspended if all other interface drivers are idle.
+		The file returns 0 if autosuspend support has not been
+		added to the driver.
+Users:
+		USB PM tool
+		git://git.moblin.org/users/sarah/usb-pm-tool/
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -743,6 +743,29 @@ static ssize_t show_modalias(struct devi
 }
 static DEVICE_ATTR(modalias, S_IRUGO, show_modalias, NULL);
 
+static ssize_t show_supports_autosuspend(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct usb_interface *intf;
+	struct usb_device *udev;
+	int ret;
+
+	intf = to_usb_interface(dev);
+	udev = interface_to_usbdev(intf);
+
+	usb_lock_device(udev);
+	/* Devices will be autosuspended even when an interface isn't claimed */
+	if (!intf->dev.driver ||
+			to_usb_driver(intf->dev.driver)->supports_autosuspend)
+		ret = sprintf(buf, "%u\n", 1);
+	else
+		ret = sprintf(buf, "%u\n", 0);
+	usb_unlock_device(udev);
+
+	return ret;
+}
+static DEVICE_ATTR(supports_autosuspend, S_IRUGO, show_supports_autosuspend, NULL);
+
 static struct attribute *intf_attrs[] = {
 	&dev_attr_bInterfaceNumber.attr,
 	&dev_attr_bAlternateSetting.attr,
@@ -751,6 +774,7 @@ static struct attribute *intf_attrs[] = 
 	&dev_attr_bInterfaceSubClass.attr,
 	&dev_attr_bInterfaceProtocol.attr,
 	&dev_attr_modalias.attr,
+	&dev_attr_supports_autosuspend.attr,
 	NULL,
 };
 static struct attribute_group intf_attr_grp = {
