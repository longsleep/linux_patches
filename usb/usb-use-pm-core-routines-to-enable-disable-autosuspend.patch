From stern@rowland.harvard.edu  Thu Apr 29 12:51:52 2010
From: Alan Stern <stern@rowland.harvard.edu>
Date: Fri, 2 Apr 2010 13:22:09 -0400 (EDT)
Subject: USB: use PM core routines to enable/disable autosuspend
To: Greg KH <greg@kroah.com>
Message-ID: <Pine.LNX.4.44L0.1004021312150.1324-100000@iolanthe.rowland.org>


This patch (as1366) replaces the private routines
usb_enable_autosuspend() and usb_disable_autosuspend() with calls to
the standard pm_runtime_allow() and pm_runtime_forbid() functions in
the runtime PM framework.  They do the same thing.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/driver.c |   21 +++++----------------
 drivers/usb/core/sysfs.c  |   10 +++++-----
 include/linux/usb.h       |    6 ++----
 3 files changed, 12 insertions(+), 25 deletions(-)

--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1355,13 +1355,9 @@ int usb_resume(struct device *dev, pm_me
  *
  * The caller must hold @udev's device lock.
  */
-int usb_enable_autosuspend(struct usb_device *udev)
+void usb_enable_autosuspend(struct usb_device *udev)
 {
-	if (udev->autosuspend_disabled) {
-		udev->autosuspend_disabled = 0;
-		usb_autosuspend_device(udev);
-	}
-	return 0;
+	pm_runtime_allow(&udev->dev);
 }
 EXPORT_SYMBOL_GPL(usb_enable_autosuspend);
 
@@ -1374,16 +1370,9 @@ EXPORT_SYMBOL_GPL(usb_enable_autosuspend
  *
  * The caller must hold @udev's device lock.
  */
-int usb_disable_autosuspend(struct usb_device *udev)
+void usb_disable_autosuspend(struct usb_device *udev)
 {
-	int rc = 0;
-
-	if (!udev->autosuspend_disabled) {
-		rc = usb_autoresume_device(udev);
-		if (rc == 0)
-			udev->autosuspend_disabled = 1;
-	}
-	return rc;
+	pm_runtime_forbid(&udev->dev);
 }
 EXPORT_SYMBOL_GPL(usb_disable_autosuspend);
 
@@ -1527,7 +1516,7 @@ void usb_autopm_put_interface_async(stru
 	atomic_dec(&intf->pm_usage_cnt);
 	pm_runtime_put_noidle(&intf->dev);
 
-	if (!udev->autosuspend_disabled) {
+	if (udev->dev.power.runtime_auto) {
 		/* Optimization: Don't schedule a delayed autosuspend if
 		 * the timer is already running and the expiration time
 		 * wouldn't change.
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -389,7 +389,7 @@ show_level(struct device *dev, struct de
 	struct usb_device *udev = to_usb_device(dev);
 	const char *p = auto_string;
 
-	if (udev->state != USB_STATE_SUSPENDED && udev->autosuspend_disabled)
+	if (udev->state != USB_STATE_SUSPENDED && !udev->dev.power.runtime_auto)
 		p = on_string;
 	return sprintf(buf, "%s\n", p);
 }
@@ -401,7 +401,7 @@ set_level(struct device *dev, struct dev
 	struct usb_device *udev = to_usb_device(dev);
 	int len = count;
 	char *cp;
-	int rc;
+	int rc = count;
 
 	cp = memchr(buf, '\n', count);
 	if (cp)
@@ -411,17 +411,17 @@ set_level(struct device *dev, struct dev
 
 	if (len == sizeof on_string - 1 &&
 			strncmp(buf, on_string, len) == 0)
-		rc = usb_disable_autosuspend(udev);
+		usb_disable_autosuspend(udev);
 
 	else if (len == sizeof auto_string - 1 &&
 			strncmp(buf, auto_string, len) == 0)
-		rc = usb_enable_autosuspend(udev);
+		usb_enable_autosuspend(udev);
 
 	else
 		rc = -EINVAL;
 
 	usb_unlock_device(udev);
-	return (rc < 0 ? rc : count);
+	return rc;
 }
 
 static DEVICE_ATTR(level, S_IRUGO | S_IWUSR, show_level, set_level);
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -425,7 +425,6 @@ struct usb_tt;
  * @connect_time: time device was first connected
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
- * @autosuspend_disabled: autosuspend disabled by the user
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
@@ -501,7 +500,6 @@ struct usb_device {
 
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
-	unsigned autosuspend_disabled:1;
 #endif
 	struct wusb_dev *wusb_dev;
 	int slot_id;
@@ -526,8 +524,8 @@ extern struct usb_device *usb_find_devic
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
-extern int usb_enable_autosuspend(struct usb_device *udev);
-extern int usb_disable_autosuspend(struct usb_device *udev);
+extern void usb_enable_autosuspend(struct usb_device *udev);
+extern void usb_disable_autosuspend(struct usb_device *udev);
 
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
