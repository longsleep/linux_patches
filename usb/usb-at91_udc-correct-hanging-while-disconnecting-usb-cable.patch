From akpm@linux-foundation.org Thu Dec 13 15:53:12 2007
From: Nicolas Ferre <nicolas.ferre@atmel.com>
Date: Thu, 13 Dec 2007 15:52:58 -0800
Subject: USB: at91_udc: correct hanging while disconnecting usb cable
To: greg@kroah.com
Cc: akpm@linux-foundation.org, nicolas.ferre@atmel.com, david-b@pacbell.net, nicolas.ferre@rfo.atmel.com
Message-ID: <200712132352.lBDNqxCf024783@imap1.linux-foundation.org>


From: Nicolas Ferre <nicolas.ferre@atmel.com>

Correct hanging while disconnecting the USB device cable.  Prevent a race
between vbus and UDP interrupts.  This bug was tracked on at91sam9260ek
boards.

A usb resume interrupt was firing after the vbus interrupt : the IP was
then already stoped and not able to deal with it (no more clock).  A simple
interrupt disabling is ok as the "end of bus reset" irq is non maskable and
ok to resume the USB device IP.

Signed-off-by: Nicolas Ferre <nicolas.ferre@rfo.atmel.com>
Acked-by: David Brownell <david-b@pacbell.net>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/at91_udc.c |    2 ++
 1 file changed, 2 insertions(+)

--- a/drivers/usb/gadget/at91_udc.c
+++ b/drivers/usb/gadget/at91_udc.c
@@ -887,6 +887,7 @@ static void pullup(struct at91_udc *udc,
 
 	if (is_on) {
 		clk_on(udc);
+		at91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_RXRSM);
 		at91_udp_write(udc, AT91_UDP_TXVC, 0);
 		if (cpu_is_at91rm9200())
 			at91_set_gpio_value(udc->board.pullup_pin, 1);
@@ -904,6 +905,7 @@ static void pullup(struct at91_udc *udc,
 		}
 	} else {
 		stop_activity(udc);
+		at91_udp_write(udc, AT91_UDP_IDR, AT91_UDP_RXRSM);
 		at91_udp_write(udc, AT91_UDP_TXVC, AT91_UDP_TXVC_TXVDIS);
 		if (cpu_is_at91rm9200())
 			at91_set_gpio_value(udc->board.pullup_pin, 0);
