From tom.leiming@gmail.com  Fri May 14 12:03:50 2010
From: tom.leiming@gmail.com
Date: Wed, 12 May 2010 23:38:46 +0800
Subject: USB: remove usb_find_device
To: greg@kroah.com, stern@rowland.harvard.edu
Cc: linux-usb@vger.kernel.org, Ming Lei <tom.leiming@gmail.com>
Message-ID: <1273678726-19664-1-git-send-email-tom.leiming@gmail.com>


From: Ming Lei <tom.leiming@gmail.com>

Now on one uses this function and it seems useless,
so remove usb_find_device.

[tom@tom linux-2.6-next]$ grep -r -n -I usb_find_device ./
drivers/media/dvb/dvb-usb/dvb-usb-init.c:160:static struct
dvb_usb_device_description * dvb_usb_find_device(struct usb_device
*udev,struct dvb_usb_device_properties *props, int *cold)

drivers/media/dvb/dvb-usb/dvb-usb-init.c:230:   if ((desc =
dvb_usb_find_device(udev,props,&cold)) == NULL) {

drivers/usb/core/usb.c:630: * usb_find_device - find a specific usb device in the system
drivers/usb/core/usb.c:642:struct usb_device *usb_find_device(u16 vendor_id, u16 product_id)

Signed-off-by: Ming Lei <tom.leiming@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/usb.c |   37 -------------------------------------
 include/linux/usb.h    |    1 -
 2 files changed, 38 deletions(-)

--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -627,43 +627,6 @@ exit:
 }
 
 /**
- * usb_find_device - find a specific usb device in the system
- * @vendor_id: the vendor id of the device to find
- * @product_id: the product id of the device to find
- *
- * Returns a pointer to a struct usb_device if such a specified usb
- * device is present in the system currently.  The usage count of the
- * device will be incremented if a device is found.  Make sure to call
- * usb_put_dev() when the caller is finished with the device.
- *
- * If a device with the specified vendor and product id is not found,
- * NULL is returned.
- */
-struct usb_device *usb_find_device(u16 vendor_id, u16 product_id)
-{
-	struct list_head *buslist;
-	struct usb_bus *bus;
-	struct usb_device *dev = NULL;
-
-	mutex_lock(&usb_bus_list_lock);
-	for (buslist = usb_bus_list.next;
-	     buslist != &usb_bus_list;
-	     buslist = buslist->next) {
-		bus = container_of(buslist, struct usb_bus, bus_list);
-		if (!bus->root_hub)
-			continue;
-		usb_lock_device(bus->root_hub);
-		dev = match_device(bus->root_hub, vendor_id, product_id);
-		usb_unlock_device(bus->root_hub);
-		if (dev)
-			goto exit;
-	}
-exit:
-	mutex_unlock(&usb_bus_list_lock);
-	return dev;
-}
-
-/**
  * usb_get_current_frame_number - return current bus frame number
  * @dev: the device whose bus is being queried
  *
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -510,7 +510,6 @@ extern int usb_lock_device_for_reset(str
 extern int usb_reset_device(struct usb_device *dev);
 extern void usb_queue_reset_device(struct usb_interface *dev);
 
-extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
