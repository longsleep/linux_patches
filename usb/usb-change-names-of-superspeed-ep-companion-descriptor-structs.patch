From sarah.a.sharp@linux.intel.com  Fri May  1 15:03:24 2009
From: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date: Wed, 29 Apr 2009 19:06:20 -0700
Subject: USB: Change names of SuperSpeed ep companion descriptor structs.
To: Greg KH <greg@kroah.com>
Cc: linux-usb@vger.kernel.org
Message-ID: <20090430020620.GA31228@gamba.jf.intel.com>


Differentiate between SuperSpeed endpoint companion descriptor and the
wireless USB endpoint companion descriptor.  Make all structure names for
this descriptor have "ss" (SuperSpeed) in them.  David Vrabel asked for
this change in http://marc.info/?l=linux-usb&m=124091465109367&w=2

Reported-by: David Vrabel <david.vrabel@csr.com>
Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/config.c   |   36 +++++++++++++++++++-----------------
 drivers/usb/host/xhci-mem.c |    2 +-
 include/linux/usb.h         |   14 +++++++-------
 include/linux/usb/ch9.h     |    4 ++--
 4 files changed, 29 insertions(+), 27 deletions(-)

--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -69,30 +69,31 @@ static int find_next_descriptor(unsigned
 	return buffer - buffer0;
 }
 
-static int usb_parse_endpoint_companion(struct device *ddev, int cfgno,
+static int usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 		int inum, int asnum, struct usb_host_endpoint *ep,
 		int num_ep, unsigned char *buffer, int size)
 {
 	unsigned char *buffer_start = buffer;
-	struct usb_ep_comp_descriptor	*desc;
+	struct usb_ss_ep_comp_descriptor	*desc;
 	int retval;
 	int num_skipped;
 	int max_tx;
 	int i;
 
-	/* Allocate space for the companion descriptor */
-	ep->ep_comp = kzalloc(sizeof(struct usb_host_ep_comp), GFP_KERNEL);
-	if (!ep->ep_comp)
+	/* Allocate space for the SS endpoint companion descriptor */
+	ep->ss_ep_comp = kzalloc(sizeof(struct usb_host_ss_ep_comp),
+			GFP_KERNEL);
+	if (!ep->ss_ep_comp)
 		return -ENOMEM;
-	desc = (struct usb_ep_comp_descriptor *) buffer;
+	desc = (struct usb_ss_ep_comp_descriptor *) buffer;
 	if (desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP) {
 		dev_warn(ddev, "No SuperSpeed endpoint companion for config %d "
 				" interface %d altsetting %d ep %d: "
 				"using minimum values\n",
 				cfgno, inum, asnum, ep->desc.bEndpointAddress);
-		ep->ep_comp->desc.bLength = USB_DT_EP_COMP_SIZE;
-		ep->ep_comp->desc.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;
-		ep->ep_comp->desc.bMaxBurst = 0;
+		ep->ss_ep_comp->desc.bLength = USB_DT_SS_EP_COMP_SIZE;
+		ep->ss_ep_comp->desc.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;
+		ep->ss_ep_comp->desc.bMaxBurst = 0;
 		/*
 		 * Leave bmAttributes as zero, which will mean no streams for
 		 * bulk, and isoc won't support multiple bursts of packets.
@@ -102,7 +103,7 @@ static int usb_parse_endpoint_companion(
 		 */
 		if (usb_endpoint_xfer_isoc(&ep->desc) ||
 				usb_endpoint_xfer_int(&ep->desc))
-			ep->ep_comp->desc.wBytesPerInterval =
+			ep->ss_ep_comp->desc.wBytesPerInterval =
 				ep->desc.wMaxPacketSize;
 		/*
 		 * The next descriptor is for an Endpoint or Interface,
@@ -112,16 +113,16 @@ static int usb_parse_endpoint_companion(
 		retval = 0;
 		goto valid;
 	}
-	memcpy(&ep->ep_comp->desc, desc, USB_DT_EP_COMP_SIZE);
-	desc = &ep->ep_comp->desc;
+	memcpy(&ep->ss_ep_comp->desc, desc, USB_DT_SS_EP_COMP_SIZE);
+	desc = &ep->ss_ep_comp->desc;
 	buffer += desc->bLength;
 	size -= desc->bLength;
 
 	/* Eat up the other descriptors we don't care about */
-	ep->ep_comp->extra = buffer;
+	ep->ss_ep_comp->extra = buffer;
 	i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
 			USB_DT_INTERFACE, &num_skipped);
-	ep->ep_comp->extralen = i;
+	ep->ss_ep_comp->extralen = i;
 	buffer += i;
 	size -= i;
 	retval = buffer - buffer_start + i;
@@ -310,7 +311,7 @@ static int usb_parse_endpoint(struct dev
 				cfgno, inum, asnum, d->bEndpointAddress,
 				maxp);
 	}
-	/* Allocate room for and parse any endpoint companion descriptors */
+	/* Allocate room for and parse any SS endpoint companion descriptors */
 	if (to_usb_device(ddev)->speed == USB_SPEED_SUPER) {
 		endpoint->extra = buffer;
 		i = find_next_descriptor_more(buffer, size, USB_DT_SS_ENDPOINT_COMP,
@@ -320,8 +321,9 @@ static int usb_parse_endpoint(struct dev
 		size -= i;
 
 		if (size > 0) {
-			retval = usb_parse_endpoint_companion(ddev, cfgno, inum, asnum,
-					endpoint, num_ep, buffer, size);
+			retval = usb_parse_ss_endpoint_companion(ddev, cfgno,
+					inum, asnum, endpoint, num_ep, buffer,
+					size);
 			if (retval >= 0) {
 				buffer += retval;
 				retval = buffer - buffer0;
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -496,7 +496,7 @@ int xhci_endpoint_init(struct xhci_hcd *
 		max_packet = ep->desc.wMaxPacketSize;
 		ep_ctx->ep_info2 |= MAX_PACKET(max_packet);
 		/* dig out max burst from ep companion desc */
-		max_packet = ep->ep_comp->desc.bMaxBurst;
+		max_packet = ep->ss_ep_comp->desc.bMaxBurst;
 		ep_ctx->ep_info2 |= MAX_BURST(max_packet);
 		break;
 	case USB_SPEED_HIGH:
--- a/include/linux/usb/ch9.h
+++ b/include/linux/usb/ch9.h
@@ -538,7 +538,7 @@ static inline int usb_endpoint_is_isoc_o
 /*-------------------------------------------------------------------------*/
 
 /* USB_DT_SS_ENDPOINT_COMP: SuperSpeed Endpoint Companion descriptor */
-struct usb_ep_comp_descriptor {
+struct usb_ss_ep_comp_descriptor {
 	__u8  bLength;
 	__u8  bDescriptorType;
 
@@ -547,7 +547,7 @@ struct usb_ep_comp_descriptor {
 	__u16 wBytesPerInterval;
 } __attribute__ ((packed));
 
-#define USB_DT_EP_COMP_SIZE		6
+#define USB_DT_SS_EP_COMP_SIZE		6
 
 /*-------------------------------------------------------------------------*/
 
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -47,15 +47,15 @@ struct ep_device;
 
 /* For SS devices */
 /**
- * struct usb_host_ep_comp - Valid for SuperSpeed devices only
+ * struct usb_host_ss_ep_comp - Valid for SuperSpeed devices only
  * @desc: endpoint companion descriptor, wMaxPacketSize in native byteorder
  * @extra: descriptors following this endpoint companion descriptor
  * @extralen: how many bytes of "extra" are valid
  */
-struct usb_host_ep_comp {
-	struct usb_ep_comp_descriptor	desc;
-	unsigned char			*extra;   /* Extra descriptors */
-	int				extralen;
+struct usb_host_ss_ep_comp {
+	struct usb_ss_ep_comp_descriptor	desc;
+	unsigned char				*extra;   /* Extra descriptors */
+	int					extralen;
 };
 
 /**
@@ -65,7 +65,7 @@ struct usb_host_ep_comp {
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
  * @ep_dev: ep_device for sysfs info
- * @ep_comp: companion descriptor information for this endpoint
+ * @ss_ep_comp: companion descriptor information for this endpoint
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  * @enabled: URBs may be submitted to this endpoint
@@ -78,7 +78,7 @@ struct usb_host_endpoint {
 	struct list_head		urb_list;
 	void				*hcpriv;
 	struct ep_device 		*ep_dev;	/* For sysfs info */
-	struct usb_host_ep_comp		*ep_comp;	/* For SS devices */
+	struct usb_host_ss_ep_comp	*ss_ep_comp;	/* For SS devices */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;
