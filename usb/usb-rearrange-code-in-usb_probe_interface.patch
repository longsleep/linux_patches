From stern@rowland.harvard.edu  Fri Jan 15 13:38:17 2010
From: Alan Stern <stern@rowland.harvard.edu>
Date: Fri, 8 Jan 2010 12:56:04 -0500 (EST)
Subject: USB: rearrange code in usb_probe_interface
To: Greg KH <greg@kroah.com>
Message-ID: <Pine.LNX.4.44L0.1001081246210.4862-100000@iolanthe.rowland.org>


This patch (as1322) reverses the two outcomes of an "if" statement in
usb_probe_interface(), to avoid an unnecessary level of indentation.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/core/driver.c |   63 ++++++++++++++++++++++------------------------
 1 file changed, 31 insertions(+), 32 deletions(-)

--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -274,56 +274,55 @@ static int usb_probe_interface(struct de
 	intf->needs_binding = 0;
 
 	if (usb_device_is_owned(udev))
-		return -ENODEV;
+		return error;
 
 	if (udev->authorized == 0) {
 		dev_err(&intf->dev, "Device is not authorized for usage\n");
-		return -ENODEV;
+		return error;
 	}
 
 	id = usb_match_id(intf, driver->id_table);
 	if (!id)
 		id = usb_match_dynamic_id(intf, driver);
-	if (id) {
-		dev_dbg(dev, "%s - got id\n", __func__);
+	if (!id)
+		return error;
 
-		error = usb_autoresume_device(udev);
-		if (error)
-			return error;
-
-		/* Interface "power state" doesn't correspond to any hardware
-		 * state whatsoever.  We use it to record when it's bound to
-		 * a driver that may start I/0:  it's not frozen/quiesced.
-		 */
-		mark_active(intf);
-		intf->condition = USB_INTERFACE_BINDING;
+	dev_dbg(dev, "%s - got id\n", __func__);
 
-		/* The interface should always appear to be in use
-		 * unless the driver suports autosuspend.
-		 */
-		atomic_set(&intf->pm_usage_cnt, !driver->supports_autosuspend);
+	error = usb_autoresume_device(udev);
+	if (error)
+		return error;
 
-		/* Carry out a deferred switch to altsetting 0 */
-		if (intf->needs_altsetting0) {
-			error = usb_set_interface(udev, intf->altsetting[0].
-					desc.bInterfaceNumber, 0);
-			if (error < 0)
-				goto err;
+	/* Interface "power state" doesn't correspond to any hardware
+	 * state whatsoever.  We use it to record when it's bound to
+	 * a driver that may start I/0:  it's not frozen/quiesced.
+	 */
+	mark_active(intf);
+	intf->condition = USB_INTERFACE_BINDING;
 
-			intf->needs_altsetting0 = 0;
-		}
+	/* The interface should always appear to be in use
+	 * unless the driver suports autosuspend.
+	 */
+	atomic_set(&intf->pm_usage_cnt, !driver->supports_autosuspend);
 
-		error = driver->probe(intf, id);
-		if (error)
+	/* Carry out a deferred switch to altsetting 0 */
+	if (intf->needs_altsetting0) {
+		error = usb_set_interface(udev, intf->altsetting[0].
+				desc.bInterfaceNumber, 0);
+		if (error < 0)
 			goto err;
-
-		intf->condition = USB_INTERFACE_BOUND;
-		usb_autosuspend_device(udev);
+		intf->needs_altsetting0 = 0;
 	}
 
+	error = driver->probe(intf, id);
+	if (error)
+		goto err;
+
+	intf->condition = USB_INTERFACE_BOUND;
+	usb_autosuspend_device(udev);
 	return error;
 
-err:
+ err:
 	mark_quiesced(intf);
 	intf->needs_remote_wakeup = 0;
 	intf->condition = USB_INTERFACE_UNBOUND;
