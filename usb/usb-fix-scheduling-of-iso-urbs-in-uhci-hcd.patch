From stern@rowland.harvard.edu Tue Oct 16 08:55:40 2007
From: Alan Stern <stern@rowland.harvard.edu>
Date: Tue, 16 Oct 2007 11:55:30 -0400 (EDT)
Subject: USB: fix scheduling of Iso URBs in uhci-hcd
To: Greg KH <greg@kroah.com>
Cc: Martin Bachem <m.bachem@gmx.de>
Message-ID: <Pine.LNX.4.44L0.0710161154150.6186-100000@iolanthe.rowland.org>


This patch (as1003) changes uhci-hcd to treat the URB_ISO_ASAP flag
the same as other host controller drivers, namely, to schedule an Iso
URB for the first available time slot that hasn't already expired.
URBs in which the flag isn't set will be scheduled for the first slot
following the last URB, even if it has expired.

This fixes a problem reported by Martin Bachem.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/uhci-q.c |   19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1271,7 +1271,8 @@ static int uhci_submit_isochronous(struc
 	} else if (qh->period != urb->interval) {
 		return -EINVAL;		/* Can't change the period */
 
-	} else {	/* Pick up where the last URB leaves off */
+	} else {
+		/* Find the next unused frame */
 		if (list_empty(&qh->queue)) {
 			frame = qh->iso_frame;
 		} else {
@@ -1283,10 +1284,18 @@ static int uhci_submit_isochronous(struc
 					lurb->number_of_packets *
 					lurb->interval;
 		}
-		if (urb->transfer_flags & URB_ISO_ASAP)
-			urb->start_frame = frame;
-		else if (urb->start_frame != frame)
-			return -EINVAL;
+		if (urb->transfer_flags & URB_ISO_ASAP) {
+			/* Skip some frames if necessary to insure
+			 * the start frame is in the future.
+			 */
+			uhci_get_current_frame_number(uhci);
+			if (uhci_frame_before_eq(frame, uhci->frame_number)) {
+				frame = uhci->frame_number + 1;
+				frame += ((qh->phase - frame) &
+					(qh->period - 1));
+			}
+		}	/* Otherwise pick up where the last URB leaves off */
+		urb->start_frame = frame;
 	}
 
 	/* Make sure we won't have to go too far into the future */
