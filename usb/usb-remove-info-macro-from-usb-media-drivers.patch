From foo@baz Tue Apr  9 12:12:43 2002
Date: Mon, 18 Aug 2008 13:21:04 -0700 (PDT)
To: Greg KH <greg@kroah.com>
From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: USB: remove info() macro from usb media drivers

USB should not be having it's own printk macros, so remove info() and
use the system-wide standard of dev_info() wherever possible.

Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/media/radio/dsbr100.c                     |    3 
 drivers/media/video/dabusb.c                      |    3 
 drivers/media/video/ov511.c                       |  105 +++++++-------
 drivers/media/video/ov511.h                       |    3 
 drivers/media/video/pvrusb2/pvrusb2-main.c        |    8 -
 drivers/media/video/se401.c                       |   37 ++--
 drivers/media/video/stv680.c                      |    6 
 drivers/media/video/usbvideo/ibmcam.c             |   78 ++++++----
 drivers/media/video/usbvideo/konicawc.c           |   17 +-
 drivers/media/video/usbvideo/quickcam_messenger.c |    3 
 drivers/media/video/usbvideo/ultracam.c           |   29 ++-
 drivers/media/video/usbvideo/usbvideo.c           |  163 ++++++++++++++--------
 drivers/media/video/usbvision/usbvision-core.c    |    3 
 drivers/media/video/usbvision/usbvision-i2c.c     |    3 
 drivers/media/video/usbvision/usbvision-video.c   |    3 
 drivers/media/video/zr364xx.c                     |   50 +++---
 16 files changed, 312 insertions(+), 202 deletions(-)

--- a/drivers/media/radio/dsbr100.c
+++ b/drivers/media/radio/dsbr100.c
@@ -510,7 +510,8 @@ static int usb_dsbr100_probe(struct usb_
 static int __init dsbr100_init(void)
 {
 	int retval = usb_register(&usb_dsbr100_driver);
-	info(DRIVER_VERSION ":" DRIVER_DESC);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 	return retval;
 }
 
--- a/drivers/media/video/dabusb.c
+++ b/drivers/media/video/dabusb.c
@@ -866,7 +866,8 @@ static int __init dabusb_init (void)
 
 	dbg("dabusb_init: driver registered");
 
-	info(DRIVER_VERSION ":" DRIVER_DESC);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 
 out:
 	return retval;
--- a/drivers/media/video/ov511.c
+++ b/drivers/media/video/ov511.c
@@ -974,14 +974,14 @@ dump_i2c_range(struct usb_ov511 *ov, int
 
 	for (i = reg1; i <= regn; i++) {
 		rc = i2c_r(ov, i);
-		info("Sensor[0x%02X] = 0x%02X", i, rc);
+		dev_info(&ov->dev->dev, "Sensor[0x%02X] = 0x%02X\n", i, rc);
 	}
 }
 
 static void
 dump_i2c_regs(struct usb_ov511 *ov)
 {
-	info("I2C REGS");
+	dev_info(&ov->dev->dev, "I2C REGS\n");
 	dump_i2c_range(ov, 0x00, 0x7C);
 }
 
@@ -992,28 +992,28 @@ dump_reg_range(struct usb_ov511 *ov, int
 
 	for (i = reg1; i <= regn; i++) {
 		rc = reg_r(ov, i);
-		info("OV511[0x%02X] = 0x%02X", i, rc);
+		dev_info(&ov->dev->dev, "OV511[0x%02X] = 0x%02X\n", i, rc);
 	}
 }
 
 static void
 ov511_dump_regs(struct usb_ov511 *ov)
 {
-	info("CAMERA INTERFACE REGS");
+	dev_info(&ov->dev->dev, "CAMERA INTERFACE REGS\n");
 	dump_reg_range(ov, 0x10, 0x1f);
-	info("DRAM INTERFACE REGS");
+	dev_info(&ov->dev->dev, "DRAM INTERFACE REGS\n");
 	dump_reg_range(ov, 0x20, 0x23);
-	info("ISO FIFO REGS");
+	dev_info(&ov->dev->dev, "ISO FIFO REGS\n");
 	dump_reg_range(ov, 0x30, 0x31);
-	info("PIO REGS");
+	dev_info(&ov->dev->dev, "PIO REGS\n");
 	dump_reg_range(ov, 0x38, 0x39);
 	dump_reg_range(ov, 0x3e, 0x3e);
-	info("I2C REGS");
+	dev_info(&ov->dev->dev, "I2C REGS\n");
 	dump_reg_range(ov, 0x40, 0x49);
-	info("SYSTEM CONTROL REGS");
+	dev_info(&ov->dev->dev, "SYSTEM CONTROL REGS\n");
 	dump_reg_range(ov, 0x50, 0x55);
 	dump_reg_range(ov, 0x5e, 0x5f);
-	info("OmniCE REGS");
+	dev_info(&ov->dev->dev, "OmniCE REGS\n");
 	dump_reg_range(ov, 0x70, 0x79);
 	/* NOTE: Quantization tables are not readable. You will get the value
 	 * in reg. 0x79 for every table register */
@@ -1025,25 +1025,25 @@ ov511_dump_regs(struct usb_ov511 *ov)
 static void
 ov518_dump_regs(struct usb_ov511 *ov)
 {
-	info("VIDEO MODE REGS");
+	dev_info(&ov->dev->dev, "VIDEO MODE REGS\n");
 	dump_reg_range(ov, 0x20, 0x2f);
-	info("DATA PUMP AND SNAPSHOT REGS");
+	dev_info(&ov->dev->dev, "DATA PUMP AND SNAPSHOT REGS\n");
 	dump_reg_range(ov, 0x30, 0x3f);
-	info("I2C REGS");
+	dev_info(&ov->dev->dev, "I2C REGS\n");
 	dump_reg_range(ov, 0x40, 0x4f);
-	info("SYSTEM CONTROL AND VENDOR REGS");
+	dev_info(&ov->dev->dev, "SYSTEM CONTROL AND VENDOR REGS\n");
 	dump_reg_range(ov, 0x50, 0x5f);
-	info("60 - 6F");
+	dev_info(&ov->dev->dev, "60 - 6F\n");
 	dump_reg_range(ov, 0x60, 0x6f);
-	info("70 - 7F");
+	dev_info(&ov->dev->dev, "70 - 7F\n");
 	dump_reg_range(ov, 0x70, 0x7f);
-	info("Y QUANTIZATION TABLE");
+	dev_info(&ov->dev->dev, "Y QUANTIZATION TABLE\n");
 	dump_reg_range(ov, 0x80, 0x8f);
-	info("UV QUANTIZATION TABLE");
+	dev_info(&ov->dev->dev, "UV QUANTIZATION TABLE\n");
 	dump_reg_range(ov, 0x90, 0x9f);
-	info("A0 - BF");
+	dev_info(&ov->dev->dev, "A0 - BF\n");
 	dump_reg_range(ov, 0xa0, 0xbf);
-	info("CBR");
+	dev_info(&ov->dev->dev, "CBR\n");
 	dump_reg_range(ov, 0xc0, 0xcf);
 }
 #endif
@@ -3208,9 +3208,10 @@ ov511_move_data(struct usb_ov511 *ov, un
 	 */
 
 	if (printph) {
-		info("ph(%3d): %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
-		     pnum, in[0], in[1], in[2], in[3], in[4], in[5], in[6],
-		     in[7], in[8], in[9], in[10], in[11]);
+		dev_info(&ov->dev->dev,
+			 "ph(%3d): %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x\n",
+			 pnum, in[0], in[1], in[2], in[3], in[4], in[5], in[6],
+			 in[7], in[8], in[9], in[10], in[11]);
 	}
 
 	/* Check for SOF/EOF packet */
@@ -3369,8 +3370,10 @@ ov518_move_data(struct usb_ov511 *ov, un
 	 * the definitive SOF/EOF format */
 	if ((!(in[0] | in[1] | in[2] | in[3] | in[5])) && in[6]) {
 		if (printph) {
-			info("ph: %2x %2x %2x %2x %2x %2x %2x %2x", in[0],
-			     in[1], in[2], in[3], in[4], in[5], in[6], in[7]);
+			dev_info(&ov->dev->dev,
+				 "ph: %2x %2x %2x %2x %2x %2x %2x %2x\n",
+				 in[0], in[1], in[2], in[3], in[4], in[5],
+				 in[6], in[7]);
 		}
 
 		if (frame->scanstate == STATE_LINES) {
@@ -3649,14 +3652,16 @@ ov51x_init_isoc(struct usb_ov511 *ov)
 		if (packetsize == -1) {
 			ov518_set_packet_size(ov, 640);
 		} else {
-			info("Forcing packet size to %d", packetsize);
+			dev_info(&ov->dev->dev, "Forcing packet size to %d\n",
+				 packetsize);
 			ov518_set_packet_size(ov, packetsize);
 		}
 	} else {
 		if (packetsize == -1) {
 			ov511_set_packet_size(ov, size);
 		} else {
-			info("Forcing packet size to %d", packetsize);
+			dev_info(&ov->dev->dev, "Forcing packet size to %d\n",
+				 packetsize);
 			ov511_set_packet_size(ov, packetsize);
 		}
 	}
@@ -4124,7 +4129,7 @@ ov51x_v4l1_ioctl_internal(struct inode *
 			return -EIO;
 
 		if (force_palette && p->palette != force_palette) {
-			info("Palette rejected (%s)",
+			dev_info(&ov->dev->dev, "Palette rejected (%s)\n",
 			     symbolic(v4l1_plist, p->palette));
 			return -EINVAL;
 		}
@@ -4852,26 +4857,27 @@ ov7xx0_configure(struct usb_ov511 *ov)
 		err("Error detecting sensor type");
 		return -1;
 	} else if ((rc & 3) == 3) {
-		info("Sensor is an OV7610");
+		dev_info(&ov->dev->dev, "Sensor is an OV7610\n");
 		ov->sensor = SEN_OV7610;
 	} else if ((rc & 3) == 1) {
 		/* I don't know what's different about the 76BE yet. */
 		if (i2c_r(ov, 0x15) & 1)
-			info("Sensor is an OV7620AE");
+			dev_info(&ov->dev->dev, "Sensor is an OV7620AE\n");
 		else
-			info("Sensor is an OV76BE");
+			dev_info(&ov->dev->dev, "Sensor is an OV76BE\n");
 
 		/* OV511+ will return all zero isoc data unless we
 		 * configure the sensor as a 7620. Someone needs to
 		 * find the exact reg. setting that causes this. */
 		if (ov->bridge == BRG_OV511PLUS) {
-			info("Enabling 511+/7620AE workaround");
+			dev_info(&ov->dev->dev,
+				 "Enabling 511+/7620AE workaround\n");
 			ov->sensor = SEN_OV7620;
 		} else {
 			ov->sensor = SEN_OV76BE;
 		}
 	} else if ((rc & 3) == 0) {
-		info("Sensor is an OV7620");
+		dev_info(&ov->dev->dev, "Sensor is an OV7620\n");
 		ov->sensor = SEN_OV7620;
 	} else {
 		err("Unknown image sensor version: %d", rc & 3);
@@ -5027,16 +5033,16 @@ ov6xx0_configure(struct usb_ov511 *ov)
 
 	if ((rc & 3) == 0) {
 		ov->sensor = SEN_OV6630;
-		info("Sensor is an OV6630");
+		dev_info(&ov->dev->dev, "Sensor is an OV6630\n");
 	} else if ((rc & 3) == 1) {
 		ov->sensor = SEN_OV6620;
-		info("Sensor is an OV6620");
+		dev_info(&ov->dev->dev, "Sensor is an OV6620\n");
 	} else if ((rc & 3) == 2) {
 		ov->sensor = SEN_OV6630;
-		info("Sensor is an OV6630AE");
+		dev_info(&ov->dev->dev, "Sensor is an OV6630AE\n");
 	} else if ((rc & 3) == 3) {
 		ov->sensor = SEN_OV6630;
-		info("Sensor is an OV6630AF");
+		dev_info(&ov->dev->dev, "Sensor is an OV6630AF\n");
 	}
 
 	/* Set sensor-specific vars */
@@ -5091,10 +5097,10 @@ ks0127_configure(struct usb_ov511 *ov)
 			err("Error detecting sensor type");
 			return -1;
 		} else if ((rc & 0x0f) == 0) {
-			info("Sensor is a KS0127");
+			dev_info(&ov->dev->dev, "Sensor is a KS0127\n");
 			ov->sensor = SEN_KS0127;
 		} else if ((rc & 0x0f) == 9) {
-			info("Sensor is a KS0127B Rev. A");
+			dev_info(&ov->dev->dev, "Sensor is a KS0127B Rev. A\n");
 			ov->sensor = SEN_KS0127B;
 		}
 	} else {
@@ -5203,7 +5209,8 @@ saa7111a_configure(struct usb_ov511 *ov)
 		err("Error detecting sensor version");
 		return -1;
 	} else {
-		info("Sensor is an SAA7111A (version 0x%x)", rc);
+		dev_info(&ov->dev->dev,
+			 "Sensor is an SAA7111A (version 0x%x)\n", rc);
 		ov->sensor = SEN_SAA7111A;
 	}
 
@@ -5266,7 +5273,7 @@ ov511_configure(struct usb_ov511 *ov)
 
 	PDEBUG (1, "CustomID = %d", ov->customid);
 	ov->desc = symbolic(camlist, ov->customid);
-	info("model: %s", ov->desc);
+	dev_info(&ov->dev->dev, "model: %s\n", ov->desc);
 
 	if (0 == strcmp(ov->desc, NOT_DEFINED_STR)) {
 		err("Camera type (%d) not recognized", ov->customid);
@@ -5430,7 +5437,8 @@ ov518_configure(struct usb_ov511 *ov)
 	PDEBUG(4, "");
 
 	/* First 5 bits of custom ID reg are a revision ID on OV518 */
-	info("Device revision %d", 0x1F & reg_r(ov, R511_SYS_CUST_ID));
+	dev_info(&ov->dev->dev, "Device revision %d\n",
+		 0x1F & reg_r(ov, R511_SYS_CUST_ID));
 
 	/* Give it the default description */
 	ov->desc = symbolic(camlist, 0);
@@ -5778,7 +5786,8 @@ ov51x_probe(struct usb_interface *intf, 
 		goto error;
 	}
 
-	info("USB %s video device found", symbolic(brglist, ov->bridge));
+	dev_info(&intf->dev, "USB %s video device found\n",
+		 symbolic(brglist, ov->bridge));
 
 	init_waitqueue_head(&ov->wq);
 
@@ -5859,8 +5868,8 @@ ov51x_probe(struct usb_interface *intf, 
 		goto error;
 	}
 
-	info("Device at %s registered to minor %d", ov->usb_path,
-	     ov->vdev->minor);
+	dev_info(&intf->dev, "Device at %s registered to minor %d\n",
+		 ov->usb_path, ov->vdev->minor);
 
 	usb_set_intfdata(intf, ov);
 	if (ov_create_sysfs(ov->vdev)) {
@@ -5963,7 +5972,8 @@ usb_ov511_init(void)
 	if (retval)
 		goto out;
 
-	info(DRIVER_VERSION " : " DRIVER_DESC);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 
 out:
 	return retval;
@@ -5973,8 +5983,7 @@ static void __exit
 usb_ov511_exit(void)
 {
 	usb_deregister(&ov511_driver);
-	info("driver deregistered");
-
+	printk(KERN_INFO KBUILD_MODNAME ": driver deregistered\n");
 }
 
 module_init(usb_ov511_init);
--- a/drivers/media/video/ov511.h
+++ b/drivers/media/video/ov511.h
@@ -12,7 +12,8 @@
 
 #ifdef OV511_DEBUG
 	#define PDEBUG(level, fmt, args...) \
-		if (debug >= (level)) info("[%s:%d] " fmt, \
+		if (debug >= (level))	\
+			printk(KERN_INFO KBUILD_MODNAME "[%s:%d] \n" fmt, \
 		__func__, __LINE__ , ## args)
 #else
 	#define PDEBUG(level, fmt, args...) do {} while(0)
--- a/drivers/media/video/pvrusb2/pvrusb2-main.c
+++ b/drivers/media/video/pvrusb2/pvrusb2-main.c
@@ -137,9 +137,11 @@ static int __init pvr_init(void)
 	ret = usb_register(&pvr_driver);
 
 	if (ret == 0)
-		info(DRIVER_DESC " : " DRIVER_VERSION);
-	if (pvrusb2_debug) info("Debug mask is %d (0x%x)",
-				pvrusb2_debug,pvrusb2_debug);
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+		       DRIVER_DESC "\n");
+	if (pvrusb2_debug)
+		printk(KERN_INFO KBUILD_MODNAME ": Debug mask is %d (0x%x)\n",
+		       pvrusb2_debug,pvrusb2_debug);
 
 	pvr2_trace(PVR2_TRACE_INIT,"pvr_init complete");
 
--- a/drivers/media/video/se401.c
+++ b/drivers/media/video/se401.c
@@ -288,7 +288,7 @@ static void se401_button_irq(struct urb 
 	int status;
 
 	if (!se401->dev) {
-		info("ohoh: device vapourished");
+		dev_info(&urb->dev->dev, "device vapourished\n");
 		return;
 	}
 
@@ -328,7 +328,7 @@ static void se401_video_irq(struct urb *
 		return;
 
 	if (!se401->dev) {
-		info ("ohoh: device vapourished");
+		dev_info(&urb->dev->dev, "device vapourished\n");
 		return;
 	}
 
@@ -375,7 +375,7 @@ static void se401_video_irq(struct urb *
 	urb->status=0;
 	urb->dev=se401->dev;
 	if(usb_submit_urb(urb, GFP_KERNEL))
-		info("urb burned down");
+		dev_info(&urb->dev->dev, "urb burned down\n");
 	return;
 }
 
@@ -860,7 +860,8 @@ static int se401_newframe(struct usb_se4
 		);
 		if (se401->nullpackets > SE401_MAX_NULLPACKETS) {
 			se401->nullpackets=0;
-			info("to many null length packets, restarting capture");
+			dev_info(&se401->dev->dev,
+				 "too many null length packets, restarting capture\n");
 			se401_stop_stream(se401);
 			se401_start_stream(se401);
 		} else {
@@ -880,7 +881,8 @@ static int se401_newframe(struct usb_se4
 				se401->scratch_use=0;
 			if (errors > SE401_MAX_ERRORS) {
 				errors=0;
-				info("to much errors, restarting capture");
+				dev_info(&se401->dev->dev,
+					 "too many errors, restarting capture\n");
 				se401_stop_stream(se401);
 				se401_start_stream(se401);
 			}
@@ -913,7 +915,7 @@ static void usb_se401_remove_disconnecte
 		usb_kill_urb(se401->inturb);
 		usb_free_urb(se401->inturb);
 	}
-	info("%s disconnected", se401->camera_name);
+	dev_info(&se401->dev->dev, "%s disconnected", se401->camera_name);
 
 	/* Free the memory */
 	kfree(se401->width);
@@ -956,8 +958,8 @@ static int se401_close(struct inode *ino
 
 	rvfree(se401->fbuf, se401->maxframesize * SE401_NUMFRAMES);
 	if (se401->removed) {
+		dev_info(&se401->dev->dev, "device unregistered\n");
 		usb_se401_remove_disconnected(se401);
-		info("device unregistered");
 	} else {
 		for (i=0; i<SE401_NUMFRAMES; i++)
 			se401->frame[i].grabstate=FRAME_UNUSED;
@@ -1271,7 +1273,7 @@ static int se401_init(struct usb_se401 *
 	for (i=0; i<se401->sizes; i++) {
 		sprintf(temp, "%s %dx%d", temp, se401->width[i], se401->height[i]);
 	}
-	info("%s", temp);
+	dev_info(&se401->dev->dev, "%s\n", temp);
 	se401->maxframesize=se401->width[se401->sizes-1]*se401->height[se401->sizes-1]*3;
 
 	rc=se401_sndctrl(0, se401, SE401_REQ_GET_WIDTH, 0, cp, sizeof(cp));
@@ -1305,7 +1307,8 @@ static int se401_init(struct usb_se401 *
 	if (button) {
 		se401->inturb=usb_alloc_urb(0, GFP_KERNEL);
 		if (!se401->inturb) {
-			info("Allocation of inturb failed");
+			dev_info(&se401->dev->dev,
+				 "Allocation of inturb failed\n");
 			return 1;
 		}
 		usb_fill_int_urb(se401->inturb, se401->dev,
@@ -1316,7 +1319,7 @@ static int se401_init(struct usb_se401 *
 		    8
 		);
 		if (usb_submit_urb(se401->inturb, GFP_KERNEL)) {
-			info("int urb burned down");
+			dev_info(&se401->dev->dev, "int urb burned down\n");
 			return 1;
 		}
 	} else
@@ -1373,7 +1376,7 @@ static int se401_probe(struct usb_interf
 		return -ENODEV;
 
 	/* We found one */
-	info("SE401 camera found: %s", camera_name);
+	dev_info(&intf->dev, "SE401 camera found: %s\n", camera_name);
 
 	if ((se401 = kzalloc(sizeof(*se401), GFP_KERNEL)) == NULL) {
 		err("couldn't kmalloc se401 struct");
@@ -1384,7 +1387,8 @@ static int se401_probe(struct usb_interf
 	se401->iface = interface->bInterfaceNumber;
 	se401->camera_name = camera_name;
 
-	info("firmware version: %02x", le16_to_cpu(dev->descriptor.bcdDevice) & 255);
+	dev_info(&intf->dev, "firmware version: %02x\n",
+		 le16_to_cpu(dev->descriptor.bcdDevice) & 255);
 
 	if (se401_init(se401, button)) {
 		kfree(se401);
@@ -1402,7 +1406,8 @@ static int se401_probe(struct usb_interf
 		err("video_register_device failed");
 		return -EIO;
 	}
-	info("registered new video device: video%d", se401->vdev.minor);
+	dev_info(&intf->dev, "registered new video device: video%d\n",
+		 se401->vdev.minor);
 
 	usb_set_intfdata (intf, se401);
 	return 0;
@@ -1446,10 +1451,10 @@ static struct usb_driver se401_driver = 
 
 static int __init usb_se401_init(void)
 {
-	info("SE401 usb camera driver version %s registering", version);
+	printk(KERN_INFO "SE401 usb camera driver version %s registering\n", version);
 	if (flickerless)
 		if (flickerless!=50 && flickerless!=60) {
-			info("Invallid flickerless value, use 0, 50 or 60.");
+			printk(KERN_ERR "Invallid flickerless value, use 0, 50 or 60.\n");
 			return -1;
 	}
 	return usb_register(&se401_driver);
@@ -1458,7 +1463,7 @@ static int __init usb_se401_init(void)
 static void __exit usb_se401_exit(void)
 {
 	usb_deregister(&se401_driver);
-	info("SE401 driver deregistered");
+	printk(KERN_INFO "SE401 driver deregistered\frame");
 }
 
 module_init(usb_se401_init);
--- a/drivers/media/video/stv680.c
+++ b/drivers/media/video/stv680.c
@@ -84,7 +84,8 @@ static unsigned int debug;
 #define PDEBUG(level, fmt, args...) \
 	do { \
 	if (debug >= level)	\
-		info("[%s:%d] " fmt, __func__, __LINE__ , ## args);	\
+		printk(KERN_INFO KBUILD_MODNAME " [%s:%d] \n" fmt,	\
+			__func__, __LINE__ , ## args);	\
 	} while (0)
 
 
@@ -1550,7 +1551,8 @@ static int __init usb_stv680_init (void)
 	}
 	PDEBUG (0, "STV(i): usb camera driver version %s registering", DRIVER_VERSION);
 
-	info(DRIVER_DESC " " DRIVER_VERSION);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 	return 0;
 }
 
--- a/drivers/media/video/usbvideo/ibmcam.c
+++ b/drivers/media/video/usbvideo/ibmcam.c
@@ -258,7 +258,9 @@ static enum ParseState ibmcam_find_heade
 			    (RING_QUEUE_PEEK(&uvd->dp, 2) == 0x00))
 			{
 #if 0				/* This code helps to detect new frame markers */
-				info("Header sig: 00 FF 00 %02X", RING_QUEUE_PEEK(&uvd->dp, 3));
+				dev_info(&uvd->dev->dev,
+					 "Header sig: 00 FF 00 %02X\n",
+					 RING_QUEUE_PEEK(&uvd->dp, 3));
 #endif
 				frame->header = RING_QUEUE_PEEK(&uvd->dp, 3);
 				if ((frame->header == HDRSIG_MODEL1_128x96) ||
@@ -266,7 +268,8 @@ static enum ParseState ibmcam_find_heade
 				    (frame->header == HDRSIG_MODEL1_352x288))
 				{
 #if 0
-					info("Header found.");
+					dev_info(&uvd->dev->dev,
+						 "Header found.\n");
 #endif
 					RING_QUEUE_DEQUEUE_BYTES(&uvd->dp, marker_len);
 					icam->has_hdr = 1;
@@ -295,7 +298,7 @@ case IBMCAM_MODEL_4:
 			    (RING_QUEUE_PEEK(&uvd->dp, 1) == 0xFF))
 			{
 #if 0
-				info("Header found.");
+				dev_info(&uvd->dev->dev, "Header found.\n");
 #endif
 				RING_QUEUE_DEQUEUE_BYTES(&uvd->dp, marker_len);
 				icam->has_hdr = 1;
@@ -338,7 +341,7 @@ case IBMCAM_MODEL_4:
 				byte4 = RING_QUEUE_PEEK(&uvd->dp, 3);
 				frame->header = (byte3 << 8) | byte4;
 #if 0
-				info("Header found.");
+				dev_info(&uvd->dev->dev, "Header found.\n");
 #endif
 				RING_QUEUE_DEQUEUE_BYTES(&uvd->dp, marker_len);
 				icam->has_hdr = 1;
@@ -354,7 +357,8 @@ case IBMCAM_MODEL_4:
 	}
 	if (!icam->has_hdr) {
 		if (uvd->debug > 2)
-			info("Skipping frame, no header");
+			dev_info(&uvd->dev->dev,
+				 "Skipping frame, no header\n");
 		return scan_EndParse;
 	}
 
@@ -881,7 +885,9 @@ static enum ParseState ibmcam_model3_par
 	 */
 	if ((frame->curline + 1) >= data_h) {
 		if (uvd->debug >= 3)
-			info("Reached line %d. (frame is done)", frame->curline);
+			dev_info(&uvd->dev->dev,
+				 "Reached line %d. (frame is done)\n",
+				 frame->curline);
 		return scan_NextFrame;
 	}
 
@@ -954,8 +960,9 @@ static enum ParseState ibmcam_model3_par
 
 	if (frame->curline >= VIDEOSIZE_Y(frame->request)) {
 		if (uvd->debug >= 3) {
-			info("All requested lines (%ld.) done.",
-			     VIDEOSIZE_Y(frame->request));
+			dev_info(&uvd->dev->dev,
+				 "All requested lines (%ld.) done.\n",
+				 VIDEOSIZE_Y(frame->request));
 		}
 		return scan_NextFrame;
 	} else
@@ -1000,7 +1007,9 @@ static enum ParseState ibmcam_model4_128
 	 */
 	if ((frame->curline + 1) >= data_h) {
 		if (uvd->debug >= 3)
-			info("Reached line %d. (frame is done)", frame->curline);
+			dev_info(&uvd->dev->dev,
+				 "Reached line %d. (frame is done)\n",
+				 frame->curline);
 		return scan_NextFrame;
 	}
 
@@ -1049,8 +1058,9 @@ static enum ParseState ibmcam_model4_128
 
 	if (frame->curline >= VIDEOSIZE_Y(frame->request)) {
 		if (uvd->debug >= 3) {
-			info("All requested lines (%ld.) done.",
-			     VIDEOSIZE_Y(frame->request));
+			dev_info(&uvd->dev->dev,
+				 "All requested lines (%ld.) done.\n",
+				 VIDEOSIZE_Y(frame->request));
 		}
 		return scan_NextFrame;
 	} else
@@ -1171,10 +1181,11 @@ static int ibmcam_veio(
 			sizeof(cp),
 			1000);
 #if 0
-		info("USB => %02x%02x%02x%02x%02x%02x%02x%02x "
-		       "(req=$%02x val=$%04x ind=$%04x)",
-		       cp[0],cp[1],cp[2],cp[3],cp[4],cp[5],cp[6],cp[7],
-		       req, value, index);
+		dev_info(&uvd->dev->dev,
+			 "USB => %02x%02x%02x%02x%02x%02x%02x%02x "
+			 "(req=$%02x val=$%04x ind=$%04x)\n",
+			 cp[0],cp[1],cp[2],cp[3],cp[4],cp[5],cp[6],cp[7],
+			 req, value, index);
 #endif
 	} else {
 		i = usb_control_msg(
@@ -1449,10 +1460,9 @@ static void ibmcam_adjust_contrast(struc
  */
 static void ibmcam_change_lighting_conditions(struct uvd *uvd)
 {
-	static const char proc[] = "ibmcam_change_lighting_conditions";
-
 	if (debug > 0)
-		info("%s: Set lighting to %hu.", proc, lighting);
+		dev_info(&uvd->dev->dev,
+			 "%s: Set lighting to %hu.\n", __func__, lighting);
 
 	switch (IBMCAM_T(uvd)->camera_model) {
 	case IBMCAM_MODEL_1:
@@ -1495,8 +1505,6 @@ static void ibmcam_change_lighting_condi
  */
 static void ibmcam_set_sharpness(struct uvd *uvd)
 {
-	static const char proc[] = "ibmcam_set_sharpness";
-
 	switch (IBMCAM_T(uvd)->camera_model) {
 	case IBMCAM_MODEL_1:
 	{
@@ -1505,7 +1513,8 @@ static void ibmcam_set_sharpness(struct 
 
 		RESTRICT_TO_RANGE(sharpness, SHARPNESS_MIN, SHARPNESS_MAX);
 		if (debug > 0)
-			info("%s: Set sharpness to %hu.", proc, sharpness);
+			dev_info(&uvd->dev->dev, "%s: Set sharpness to %hu.\n",
+				 __func__, sharpness);
 
 		sv = sa[sharpness - SHARPNESS_MIN];
 		for (i=0; i < 2; i++) {
@@ -1564,11 +1573,11 @@ static void ibmcam_set_sharpness(struct 
  */
 static void ibmcam_set_brightness(struct uvd *uvd)
 {
-	static const char proc[] = "ibmcam_set_brightness";
 	static const unsigned short n = 1;
 
 	if (debug > 0)
-		info("%s: Set brightness to %hu.", proc, uvd->vpic.brightness);
+		dev_info(&uvd->dev->dev, "%s: Set brightness to %hu.\n",
+			 __func__, uvd->vpic.brightness);
 
 	switch (IBMCAM_T(uvd)->camera_model) {
 	case IBMCAM_MODEL_1:
@@ -2115,7 +2124,8 @@ static void ibmcam_model2_setup_after_vi
 			break;
 		}
 		if (uvd->debug > 0)
-			info("Framerate (hardware): %hd.", hw_fps);
+			dev_info(&uvd->dev->dev, "Framerate (hardware): %hd.\n",
+				 hw_fps);
 		RESTRICT_TO_RANGE(hw_fps, 0, 31);
 		ibmcam_model2_Packet1(uvd, mod2_set_framerate, hw_fps);
 	}
@@ -3487,7 +3497,7 @@ static void ibmcam_model3_setup_after_vi
 	/* 01.01.08 - Added for RCA video in support -LO */
 	if(init_model3_input) {
 		if (debug > 0)
-			info("Setting input to RCA.");
+			dev_info(&uvd->dev->dev, "Setting input to RCA.\n");
 		for (i=0; i < ARRAY_SIZE(initData); i++) {
 			ibmcam_veio(uvd, initData[i].req, initData[i].value, initData[i].index);
 		}
@@ -3685,7 +3695,7 @@ static int ibmcam_probe(struct usb_inter
 	unsigned char video_ep = 0;
 
 	if (debug >= 1)
-		info("ibmcam_probe(%p,%u.)", intf, ifnum);
+		dev_info(&uvd->dev->dev, "ibmcam_probe(%p,%u.)\n", intf, ifnum);
 
 	/* We don't handle multi-config cameras */
 	if (dev->descriptor.bNumConfigurations != 1)
@@ -3736,14 +3746,16 @@ static int ibmcam_probe(struct usb_inter
 			brand = "IBM PC Camera"; /* a.k.a. Xirlink C-It */
 			break;
 		}
-		info("%s USB camera found (model %d, rev. 0x%04x)",
-		     brand, model, le16_to_cpu(dev->descriptor.bcdDevice));
+		dev_info(&uvd->dev->dev,
+			 "%s USB camera found (model %d, rev. 0x%04x)\n",
+			 brand, model, le16_to_cpu(dev->descriptor.bcdDevice));
 	} while (0);
 
 	/* Validate found interface: must have one ISO endpoint */
 	nas = intf->num_altsetting;
 	if (debug > 0)
-		info("Number of alternate settings=%d.", nas);
+		dev_info(&uvd->dev->dev, "Number of alternate settings=%d.\n",
+			 nas);
 	if (nas < 2) {
 		err("Too few alternate settings for this camera!");
 		return -ENODEV;
@@ -3787,7 +3799,9 @@ static int ibmcam_probe(struct usb_inter
 				actInterface = i;
 				maxPS = le16_to_cpu(endpoint->wMaxPacketSize);
 				if (debug > 0)
-					info("Active setting=%d. maxPS=%d.", i, maxPS);
+					dev_info(&uvd->dev->dev,
+						 "Active setting=%d. "
+						 "maxPS=%d.\n", i, maxPS);
 			} else
 				err("More than one active alt. setting! Ignoring #%d.", i);
 		}
@@ -3826,7 +3840,7 @@ static int ibmcam_probe(struct usb_inter
 			RESTRICT_TO_RANGE(framerate, 0, 5);
 			break;
 		default:
-			info("IBM camera: using 320x240");
+			dev_info(&uvd->dev->dev, "IBM camera: using 320x240\n");
 			size = SIZE_320x240;
 			/* No break here */
 		case SIZE_320x240:
@@ -3855,7 +3869,7 @@ static int ibmcam_probe(struct usb_inter
 			canvasY = 120;
 			break;
 		default:
-			info("IBM NetCamera: using 176x144");
+			dev_info(&uvd->dev->dev, "IBM NetCamera: using 176x144\n");
 			size = SIZE_176x144;
 			/* No break here */
 		case SIZE_176x144:
--- a/drivers/media/video/usbvideo/konicawc.c
+++ b/drivers/media/video/usbvideo/konicawc.c
@@ -339,7 +339,8 @@ static int konicawc_compress_iso(struct 
 		}
 
 		if((sts > 0x01) && (sts < 0x80)) {
-			info("unknown status %2.2x", sts);
+			dev_info(&uvd->dev->dev, "unknown status %2.2x\n",
+				 sts);
 			bad++;
 			continue;
 		}
@@ -570,8 +571,12 @@ static void konicawc_process_isoc(struct
 					fdrops = (0x80 + curframe - cam->lastframe) & 0x7F;
 					fdrops--;
 					if(fdrops) {
-						info("Dropped %d frames (%d -> %d)", fdrops,
-						     cam->lastframe, curframe);
+						dev_info(&uvd->dev->dev,
+							 "Dropped %d frames "
+							 "(%d -> %d)\n",
+							 fdrops,
+							 cam->lastframe,
+							 curframe);
 					}
 				}
 				cam->lastframe = curframe;
@@ -786,7 +791,8 @@ static int konicawc_probe(struct usb_int
 	if (dev->descriptor.bNumConfigurations != 1)
 		return -ENODEV;
 
-	info("Konica Webcam (rev. 0x%04x)", le16_to_cpu(dev->descriptor.bcdDevice));
+	dev_info(&intf->dev, "Konica Webcam (rev. 0x%04x)\n",
+		 le16_to_cpu(dev->descriptor.bcdDevice));
 	RESTRICT_TO_RANGE(speed, 0, MAX_SPEED);
 
 	/* Validate found interface: must have one ISO endpoint */
@@ -927,7 +933,8 @@ static struct usb_device_id id_table[] =
 static int __init konicawc_init(void)
 {
 	struct usbvideo_cb cbTbl;
-	info(DRIVER_DESC " " DRIVER_VERSION);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 	memset(&cbTbl, 0, sizeof(cbTbl));
 	cbTbl.probe = konicawc_probe;
 	cbTbl.setupOnOpen = konicawc_setup_on_open;
--- a/drivers/media/video/usbvideo/quickcam_messenger.c
+++ b/drivers/media/video/usbvideo/quickcam_messenger.c
@@ -1082,7 +1082,8 @@ static struct usbvideo_cb qcm_driver = {
 
 static int __init qcm_init(void)
 {
-	info(DRIVER_DESC " " DRIVER_VERSION);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 
 	return usbvideo_register(
 		&cams,
--- a/drivers/media/video/usbvideo/ultracam.c
+++ b/drivers/media/video/usbvideo/ultracam.c
@@ -156,10 +156,11 @@ static int ultracam_veio(
 			sizeof(cp),
 			1000);
 #if 1
-		info("USB => %02x%02x%02x%02x%02x%02x%02x%02x "
-		       "(req=$%02x val=$%04x ind=$%04x)",
-		       cp[0],cp[1],cp[2],cp[3],cp[4],cp[5],cp[6],cp[7],
-		       req, value, index);
+		dev_info(&uvd->dev->dev,
+			 "USB => %02x%02x%02x%02x%02x%02x%02x%02x "
+			 "(req=$%02x val=$%04x ind=$%04x)\n",
+			 cp[0],cp[1],cp[2],cp[3],cp[4],cp[5],cp[6],cp[7],
+			 req, value, index);
 #endif
 	} else {
 		i = usb_control_msg(
@@ -517,19 +518,20 @@ static int ultracam_probe(struct usb_int
 	unsigned char video_ep = 0;
 
 	if (debug >= 1)
-		info("ultracam_probe(%p)", intf);
+		dev_info(&intf->dev, "ultracam_probe\n");
 
 	/* We don't handle multi-config cameras */
 	if (dev->descriptor.bNumConfigurations != 1)
 		return -ENODEV;
 
-	info("IBM Ultra camera found (rev. 0x%04x)",
-		le16_to_cpu(dev->descriptor.bcdDevice));
+	dev_info(&intf->dev, "IBM Ultra camera found (rev. 0x%04x)\n",
+		 le16_to_cpu(dev->descriptor.bcdDevice));
 
 	/* Validate found interface: must have one ISO endpoint */
 	nas = intf->num_altsetting;
 	if (debug > 0)
-		info("Number of alternate settings=%d.", nas);
+		dev_info(&intf->dev, "Number of alternate settings=%d.\n",
+			 nas);
 	if (nas < 8) {
 		err("Too few alternate settings for this camera!");
 		return -ENODEV;
@@ -576,7 +578,9 @@ static int ultracam_probe(struct usb_int
 				actInterface = i;
 				maxPS = le16_to_cpu(endpoint->wMaxPacketSize);
 				if (debug > 0)
-					info("Active setting=%d. maxPS=%d.", i, maxPS);
+					dev_info(&intf->dev,
+						 "Active setting=%d. "
+						 "maxPS=%d.\n", i, maxPS);
 			} else {
 				/* Got another active alt. setting */
 				if (maxPS < le16_to_cpu(endpoint->wMaxPacketSize)) {
@@ -584,8 +588,11 @@ static int ultracam_probe(struct usb_int
 					actInterface = i;
 					maxPS = le16_to_cpu(endpoint->wMaxPacketSize);
 					if (debug > 0) {
-						info("Even better ctive setting=%d. maxPS=%d.",
-						     i, maxPS);
+						dev_info(&intf->dev,
+							 "Even better ctive "
+							 "setting=%d. "
+							 "maxPS=%d.\n",
+							 i, maxPS);
 					}
 				}
 			}
--- a/drivers/media/video/usbvideo/usbvideo.c
+++ b/drivers/media/video/usbvideo/usbvideo.c
@@ -468,8 +468,9 @@ static void usbvideo_ReportStatistics(co
 			percent = (100 * goodPackets) / allPackets;
 		else
 			percent = goodPackets / (allPackets / 100);
-		info("Packet Statistics: Total=%lu. Empty=%lu. Usage=%lu%%",
-		     allPackets, badPackets, percent);
+		dev_info(&uvd->dev->dev,
+			 "Packet Statistics: Total=%lu. Empty=%lu. Usage=%lu%%\n",
+			 allPackets, badPackets, percent);
 		if (uvd->iso_packet_len > 0) {
 			unsigned long allBytes, xferBytes;
 			char multiplier = ' ';
@@ -497,8 +498,9 @@ static void usbvideo_ReportStatistics(co
 					}
 				}
 			}
-			info("Transfer Statistics: Transferred=%lu%cB Usage=%lu%%",
-			     xferBytes, multiplier, percent);
+			dev_info(&uvd->dev->dev,
+				 "Transfer Statistics: Transferred=%lu%cB Usage=%lu%%\n",
+				 xferBytes, multiplier, percent);
 		}
 	}
 }
@@ -545,7 +547,7 @@ void usbvideo_TestPattern(struct uvd *uv
 	{	/* For debugging purposes only */
 		char tmp[20];
 		usbvideo_VideosizeToString(tmp, sizeof(tmp), frame->request);
-		info("testpattern: frame=%s", tmp);
+		dev_info(&uvd->dev->dev, "testpattern: frame=%s\n", tmp);
 	}
 #endif
 	/* Form every scan line */
@@ -854,7 +856,7 @@ static void usbvideo_Disconnect(struct u
 
 	usbvideo_ClientIncModCount(uvd);
 	if (uvd->debug > 0)
-		info("%s(%p.)", __func__, intf);
+		dev_info(&intf->dev, "%s(%p.)\n", __func__, intf);
 
 	mutex_lock(&uvd->lock);
 	uvd->remove_pending = 1; /* Now all ISO data will be ignored */
@@ -870,14 +872,15 @@ static void usbvideo_Disconnect(struct u
 
 	video_unregister_device(&uvd->vdev);
 	if (uvd->debug > 0)
-		info("%s: Video unregistered.", __func__);
+		dev_info(&intf->dev, "%s: Video unregistered.\n", __func__);
 
 	if (uvd->user)
-		info("%s: In use, disconnect pending.", __func__);
+		dev_info(&intf->dev, "%s: In use, disconnect pending.\n",
+			 __func__);
 	else
 		usbvideo_CameraRelease(uvd);
 	mutex_unlock(&uvd->lock);
-	info("USB camera disconnected.");
+	dev_info(&intf->dev, "USB camera disconnected.\n");
 
 	usbvideo_ClientDecModCount(uvd);
 }
@@ -1015,14 +1018,17 @@ int usbvideo_RegisterVideoDevice(struct 
 		return -EINVAL;
 	}
 	if (uvd->video_endp == 0) {
-		info("%s: No video endpoint specified; data pump disabled.", __func__);
+		dev_info(&uvd->dev->dev,
+			 "%s: No video endpoint specified; data pump disabled.\n",
+			 __func__);
 	}
 	if (uvd->paletteBits == 0) {
 		err("%s: No palettes specified!", __func__);
 		return -EINVAL;
 	}
 	if (uvd->defaultPalette == 0) {
-		info("%s: No default palette!", __func__);
+		dev_info(&uvd->dev->dev, "%s: No default palette!\n",
+			 __func__);
 	}
 
 	uvd->max_frame_size = VIDEOSIZE_X(uvd->canvas) *
@@ -1031,8 +1037,10 @@ int usbvideo_RegisterVideoDevice(struct 
 	usbvideo_VideosizeToString(tmp2, sizeof(tmp2), uvd->canvas);
 
 	if (uvd->debug > 0) {
-		info("%s: iface=%d. endpoint=$%02x paletteBits=$%08lx",
-		     __func__, uvd->iface, uvd->video_endp, uvd->paletteBits);
+		dev_info(&uvd->dev->dev,
+			 "%s: iface=%d. endpoint=$%02x paletteBits=$%08lx\n",
+			 __func__, uvd->iface, uvd->video_endp,
+			 uvd->paletteBits);
 	}
 	if (uvd->dev == NULL) {
 		err("%s: uvd->dev == NULL", __func__);
@@ -1044,12 +1052,13 @@ int usbvideo_RegisterVideoDevice(struct 
 		return -EPIPE;
 	}
 	if (uvd->debug > 1) {
-		info("%s: video_register_device() successful", __func__);
+		dev_info(&uvd->dev->dev,
+			 "%s: video_register_device() successful\n", __func__);
 	}
 
-	info("%s on /dev/video%d: canvas=%s videosize=%s",
-	     (uvd->handle != NULL) ? uvd->handle->drvName : "???",
-	     uvd->vdev.minor, tmp2, tmp1);
+	dev_info(&uvd->dev->dev, "%s on /dev/video%d: canvas=%s videosize=%s\n",
+		 (uvd->handle != NULL) ? uvd->handle->drvName : "???",
+		 uvd->vdev.minor, tmp2, tmp1);
 
 	usb_get_dev(uvd->dev);
 	return 0;
@@ -1111,7 +1120,7 @@ static int usbvideo_v4l_open(struct inod
 	int i, errCode = 0;
 
 	if (uvd->debug > 1)
-		info("%s($%p)", __func__, dev);
+		dev_info(&uvd->dev->dev, "%s($%p)\n", __func__, dev);
 
 	if (0 < usbvideo_ClientIncModCount(uvd))
 		return -ENODEV;
@@ -1178,19 +1187,25 @@ static int usbvideo_v4l_open(struct inod
 		if (errCode == 0) {
 			if (VALID_CALLBACK(uvd, setupOnOpen)) {
 				if (uvd->debug > 1)
-					info("%s: setupOnOpen callback", __func__);
+					dev_info(&uvd->dev->dev,
+						 "%s: setupOnOpen callback\n",
+						 __func__);
 				errCode = GET_CALLBACK(uvd, setupOnOpen)(uvd);
 				if (errCode < 0) {
 					err("%s: setupOnOpen callback failed (%d.).",
 					    __func__, errCode);
 				} else if (uvd->debug > 1) {
-					info("%s: setupOnOpen callback successful", __func__);
+					dev_info(&uvd->dev->dev,
+						 "%s: setupOnOpen callback successful\n",
+						 __func__);
 				}
 			}
 			if (errCode == 0) {
 				uvd->settingsAdjusted = 0;
 				if (uvd->debug > 1)
-					info("%s: Open succeeded.", __func__);
+					dev_info(&uvd->dev->dev,
+						 "%s: Open succeeded.\n",
+						 __func__);
 				uvd->user++;
 				file->private_data = uvd;
 			}
@@ -1200,7 +1215,8 @@ static int usbvideo_v4l_open(struct inod
 	if (errCode != 0)
 		usbvideo_ClientDecModCount(uvd);
 	if (uvd->debug > 0)
-		info("%s: Returning %d.", __func__, errCode);
+		dev_info(&uvd->dev->dev, "%s: Returning %d.\n", __func__,
+			 errCode);
 	return errCode;
 }
 
@@ -1223,7 +1239,7 @@ static int usbvideo_v4l_close(struct ino
 	int i;
 
 	if (uvd->debug > 1)
-		info("%s($%p)", __func__, dev);
+		dev_info(&uvd->dev->dev, "%s($%p)\n", __func__, dev);
 
 	mutex_lock(&uvd->lock);
 	GET_CALLBACK(uvd, stopDataPump)(uvd);
@@ -1243,14 +1259,15 @@ static int usbvideo_v4l_close(struct ino
 	uvd->user--;
 	if (uvd->remove_pending) {
 		if (uvd->debug > 0)
-			info("usbvideo_v4l_close: Final disconnect.");
+			dev_info(&uvd->dev->dev, "%s: Final disconnect.\n",
+				 __func__);
 		usbvideo_CameraRelease(uvd);
 	}
 	mutex_unlock(&uvd->lock);
 	usbvideo_ClientDecModCount(uvd);
 
 	if (uvd->debug > 1)
-		info("%s: Completed.", __func__);
+		dev_info(&uvd->dev->dev, "%s: Completed.\n", __func__);
 	file->private_data = NULL;
 	return 0;
 }
@@ -1364,8 +1381,9 @@ static int usbvideo_v4l_do_ioctl(struct 
 			struct video_mmap *vm = arg;
 
 			if (uvd->debug >= 1) {
-				info("VIDIOCMCAPTURE: frame=%d. size=%dx%d, format=%d.",
-				     vm->frame, vm->width, vm->height, vm->format);
+				dev_info(&uvd->dev->dev,
+					 "VIDIOCMCAPTURE: frame=%d. size=%dx%d, format=%d.\n",
+					 vm->frame, vm->width, vm->height, vm->format);
 			}
 			/*
 			 * Check if the requested size is supported. If the requestor
@@ -1383,18 +1401,24 @@ static int usbvideo_v4l_do_ioctl(struct 
 			if ((vm->width > VIDEOSIZE_X(uvd->canvas)) ||
 			    (vm->height > VIDEOSIZE_Y(uvd->canvas))) {
 				if (uvd->debug > 0) {
-					info("VIDIOCMCAPTURE: Size=%dx%d too large; "
-					     "allowed only up to %ldx%ld", vm->width, vm->height,
-					     VIDEOSIZE_X(uvd->canvas), VIDEOSIZE_Y(uvd->canvas));
+					dev_info(&uvd->dev->dev,
+						 "VIDIOCMCAPTURE: Size=%dx%d "
+						 "too large; allowed only up "
+						 "to %ldx%ld\n", vm->width,
+						 vm->height,
+						 VIDEOSIZE_X(uvd->canvas),
+						 VIDEOSIZE_Y(uvd->canvas));
 				}
 				return -EINVAL;
 			}
 			/* Check if the palette is supported */
 			if (((1L << vm->format) & uvd->paletteBits) == 0) {
 				if (uvd->debug > 0) {
-					info("VIDIOCMCAPTURE: format=%d. not supported"
-					     " (paletteBits=$%08lx)",
-					     vm->format, uvd->paletteBits);
+					dev_info(&uvd->dev->dev,
+						 "VIDIOCMCAPTURE: format=%d. "
+						 "not supported "
+						 "(paletteBits=$%08lx)\n",
+						 vm->format, uvd->paletteBits);
 				}
 				return -EINVAL;
 			}
@@ -1422,7 +1446,9 @@ static int usbvideo_v4l_do_ioctl(struct 
 				return -EINVAL;
 
 			if (uvd->debug >= 1)
-				info("VIDIOCSYNC: syncing to frame %d.", *frameNum);
+				dev_info(&uvd->dev->dev,
+					 "VIDIOCSYNC: syncing to frame %d.\n",
+					 *frameNum);
 			if (uvd->flags & FLAGS_NO_DECODING)
 				ret = usbvideo_GetFrame(uvd, *frameNum);
 			else if (VALID_CALLBACK(uvd, getFrame)) {
@@ -1504,7 +1530,9 @@ static ssize_t usbvideo_v4l_read(struct 
 		return -EFAULT;
 
 	if (uvd->debug >= 1)
-		info("%s: %Zd. bytes, noblock=%d.", __func__, count, noblock);
+		dev_info(&uvd->dev->dev,
+			 "%s: %Zd. bytes, noblock=%d.\n",
+			 __func__, count, noblock);
 
 	mutex_lock(&uvd->lock);
 
@@ -1685,18 +1713,21 @@ static void usbvideo_IsocIrq(struct urb 
 		return;
 #if 0
 	if (urb->actual_length > 0) {
-		info("urb=$%p status=%d. errcount=%d. length=%d.",
-		     urb, urb->status, urb->error_count, urb->actual_length);
+		dev_info(&uvd->dev->dev,
+			 "urb=$%p status=%d. errcount=%d. length=%d.\n",
+			 urb, urb->status, urb->error_count,
+			 urb->actual_length);
 	} else {
 		static int c = 0;
 		if (c++ % 100 == 0)
-			info("No Isoc data");
+			dev_info(&uvd->dev->dev, "No Isoc data\n");
 	}
 #endif
 
 	if (!uvd->streaming) {
 		if (uvd->debug >= 1)
-			info("Not streaming, but interrupt!");
+			dev_info(&uvd->dev->dev,
+				 "Not streaming, but interrupt!\n");
 		return;
 	}
 
@@ -1741,7 +1772,7 @@ static int usbvideo_StartDataPump(struct
 	int i, errFlag;
 
 	if (uvd->debug > 1)
-		info("%s($%p)", __func__, uvd);
+		dev_info(&uvd->dev->dev, "%s($%p)\n", __func__, uvd);
 
 	if (!CAMERA_IS_OPERATIONAL(uvd)) {
 		err("%s: Camera is not operational", __func__);
@@ -1789,7 +1820,9 @@ static int usbvideo_StartDataPump(struct
 
 	uvd->streaming = 1;
 	if (uvd->debug > 1)
-		info("%s: streaming=1 video_endp=$%02x", __func__, uvd->video_endp);
+		dev_info(&uvd->dev->dev,
+			 "%s: streaming=1 video_endp=$%02x\n", __func__,
+			 uvd->video_endp);
 	return 0;
 }
 
@@ -1811,14 +1844,14 @@ static void usbvideo_StopDataPump(struct
 		return;
 
 	if (uvd->debug > 1)
-		info("%s($%p)", __func__, uvd);
+		dev_info(&uvd->dev->dev, "%s($%p)\n", __func__, uvd);
 
 	/* Unschedule all of the iso td's */
 	for (i=0; i < USBVIDEO_NUMSBUF; i++) {
 		usb_kill_urb(uvd->sbuf[i].urb);
 	}
 	if (uvd->debug > 1)
-		info("%s: streaming=0", __func__);
+		dev_info(&uvd->dev->dev, "%s: streaming=0\n", __func__);
 	uvd->streaming = 0;
 
 	if (!uvd->remove_pending) {
@@ -1850,7 +1883,8 @@ static int usbvideo_NewFrame(struct uvd 
 	int n;
 
 	if (uvd->debug > 1)
-		info("usbvideo_NewFrame($%p,%d.)", uvd, framenum);
+		dev_info(&uvd->dev->dev, "usbvideo_NewFrame($%p,%d.)\n", uvd,
+			 framenum);
 
 	/* If we're not grabbing a frame right now and the other frame is */
 	/*  ready to be grabbed into, then use it instead */
@@ -1955,12 +1989,14 @@ static int usbvideo_GetFrame(struct uvd 
 	struct usbvideo_frame *frame = &uvd->frame[frameNum];
 
 	if (uvd->debug >= 2)
-		info("%s($%p,%d.)", __func__, uvd, frameNum);
+		dev_info(&uvd->dev->dev, "%s($%p,%d.)\n", __func__, uvd,
+			 frameNum);
 
 	switch (frame->frameState) {
 	case FrameState_Unused:
 		if (uvd->debug >= 2)
-			info("%s: FrameState_Unused", __func__);
+			dev_info(&uvd->dev->dev, "%s: FrameState_Unused\n",
+				 __func__);
 		return -EINVAL;
 	case FrameState_Ready:
 	case FrameState_Grabbing:
@@ -1970,7 +2006,9 @@ static int usbvideo_GetFrame(struct uvd 
 	redo:
 		if (!CAMERA_IS_OPERATIONAL(uvd)) {
 			if (uvd->debug >= 2)
-				info("%s: Camera is not operational (1)", __func__);
+				dev_info(&uvd->dev->dev,
+					 "%s: Camera is not operational (1)\n",
+					 __func__);
 			return -EIO;
 		}
 		ntries = 0;
@@ -1979,24 +2017,33 @@ static int usbvideo_GetFrame(struct uvd 
 			signalPending = signal_pending(current);
 			if (!CAMERA_IS_OPERATIONAL(uvd)) {
 				if (uvd->debug >= 2)
-					info("%s: Camera is not operational (2)", __func__);
+					dev_info(&uvd->dev->dev,
+						 "%s: Camera is not "
+						 "operational (2)\n", __func__);
 				return -EIO;
 			}
 			assert(uvd->fbuf != NULL);
 			if (signalPending) {
 				if (uvd->debug >= 2)
-					info("%s: Signal=$%08x", __func__, signalPending);
+					dev_info(&uvd->dev->dev,
+					"%s: Signal=$%08x\n", __func__,
+					signalPending);
 				if (uvd->flags & FLAGS_RETRY_VIDIOCSYNC) {
 					usbvideo_TestPattern(uvd, 1, 0);
 					uvd->curframe = -1;
 					uvd->stats.frame_num++;
 					if (uvd->debug >= 2)
-						info("%s: Forced test pattern screen", __func__);
+						dev_info(&uvd->dev->dev,
+							 "%s: Forced test "
+							 "pattern screen\n",
+							 __func__);
 					return 0;
 				} else {
 					/* Standard answer: Interrupted! */
 					if (uvd->debug >= 2)
-						info("%s: Interrupted!", __func__);
+						dev_info(&uvd->dev->dev,
+							 "%s: Interrupted!\n",
+							 __func__);
 					return -EINTR;
 				}
 			} else {
@@ -2010,8 +2057,10 @@ static int usbvideo_GetFrame(struct uvd 
 			}
 		} while (frame->frameState == FrameState_Grabbing);
 		if (uvd->debug >= 2) {
-			info("%s: Grabbing done; state=%d. (%lu. bytes)",
-			     __func__, frame->frameState, frame->seqRead_Length);
+			dev_info(&uvd->dev->dev,
+				 "%s: Grabbing done; state=%d. (%lu. bytes)\n",
+				 __func__, frame->frameState,
+				 frame->seqRead_Length);
 		}
 		if (frame->frameState == FrameState_Error) {
 			int ret = usbvideo_NewFrame(uvd, frameNum);
@@ -2048,7 +2097,9 @@ static int usbvideo_GetFrame(struct uvd 
 		}
 		frame->frameState = FrameState_Done_Hold;
 		if (uvd->debug >= 2)
-			info("%s: Entered FrameState_Done_Hold state.", __func__);
+			dev_info(&uvd->dev->dev,
+				 "%s: Entered FrameState_Done_Hold state.\n",
+				 __func__);
 		return 0;
 
 	case FrameState_Done_Hold:
@@ -2059,7 +2110,9 @@ static int usbvideo_GetFrame(struct uvd 
 		 * it will be released back into the wild to roam freely.
 		 */
 		if (uvd->debug >= 2)
-			info("%s: FrameState_Done_Hold state.", __func__);
+			dev_info(&uvd->dev->dev,
+				 "%s: FrameState_Done_Hold state.\n",
+				 __func__);
 		return 0;
 	}
 
--- a/drivers/media/video/usbvision/usbvision-core.c
+++ b/drivers/media/video/usbvision/usbvision-core.c
@@ -84,7 +84,8 @@ MODULE_PARM_DESC(adjust_Y_Offset, "adjus
 #ifdef USBVISION_DEBUG
 	#define PDEBUG(level, fmt, args...) { \
 		if (core_debug & (level)) \
-			info("[%s:%d] " fmt, __func__, __LINE__ , ## args); \
+			printk(KERN_INFO KBUILD_MODNAME ":[%s:%d] " fmt, \
+				__func__, __LINE__ , ## args); \
 	}
 #else
 	#define PDEBUG(level, fmt, args...) do {} while(0)
--- a/drivers/media/video/usbvision/usbvision-i2c.c
+++ b/drivers/media/video/usbvision/usbvision-i2c.c
@@ -47,7 +47,8 @@ MODULE_PARM_DESC(i2c_debug, "enable debu
 
 #define PDEBUG(level, fmt, args...) { \
 		if (i2c_debug & (level)) \
-			info("[%s:%d] " fmt, __func__, __LINE__ , ## args); \
+			printk(KERN_INFO KBUILD_MODNAME ":[%s:%d] " fmt, \
+				__func__, __LINE__ , ## args); \
 	}
 
 static int usbvision_i2c_write(struct usb_usbvision *usbvision, unsigned char addr, char *buf,
--- a/drivers/media/video/usbvision/usbvision-video.c
+++ b/drivers/media/video/usbvision/usbvision-video.c
@@ -98,7 +98,8 @@ USBVISION_DRIVER_VERSION_PATCHLEVEL)
 #ifdef USBVISION_DEBUG
 	#define PDEBUG(level, fmt, args...) { \
 		if (video_debug & (level)) \
-			info("[%s:%d] " fmt, __func__, __LINE__ , ## args); \
+			printk(KERN_INFO KBUILD_MODNAME ":[%s:%d] " fmt, \
+				__func__, __LINE__ , ## args); \
 	}
 #else
 	#define PDEBUG(level, fmt, args...) do {} while(0)
--- a/drivers/media/video/zr364xx.c
+++ b/drivers/media/video/zr364xx.c
@@ -52,7 +52,7 @@
 
 
 /* Debug macro */
-#define DBG(x...) if (debug) info(x)
+#define DBG(x...) if (debug) printk(KERN_INFO KBUILD_MODNAME x)
 
 
 /* Init methods, need to find nicer names for these
@@ -127,7 +127,7 @@ static int send_control_msg(struct usb_d
 
 	unsigned char *transfer_buffer = kmalloc(size, GFP_KERNEL);
 	if (!transfer_buffer) {
-		info("kmalloc(%d) failed", size);
+		dev_err(&udev->dev, "kmalloc(%d) failed\n", size);
 		return -ENOMEM;
 	}
 
@@ -143,7 +143,8 @@ static int send_control_msg(struct usb_d
 	kfree(transfer_buffer);
 
 	if (status < 0)
-		info("Failed sending control message, error %d.", status);
+		dev_err(&udev->dev,
+			"Failed sending control message, error %d.\n", status);
 
 	return status;
 }
@@ -303,11 +304,11 @@ static int read_frame(struct zr364xx_cam
 		DBG("buffer : %d %d", cam->buffer[0], cam->buffer[1]);
 		DBG("bulk : n=%d size=%d", n, actual_length);
 		if (n < 0) {
-			info("error reading bulk msg");
+			dev_err(&cam->udev->dev, "error reading bulk msg\n");
 			return 0;
 		}
 		if (actual_length < 0 || actual_length > BUFFER_SIZE) {
-			info("wrong number of bytes");
+			dev_err(&cam->udev->dev, "wrong number of bytes\n");
 			return 0;
 		}
 
@@ -650,7 +651,7 @@ static int zr364xx_open(struct inode *in
 	if (!cam->framebuf) {
 		cam->framebuf = vmalloc_32(MAX_FRAME_SIZE * FRAMES);
 		if (!cam->framebuf) {
-			info("vmalloc_32 failed!");
+			dev_err(&cam->udev->dev, "vmalloc_32 failed!\n");
 			return -ENOMEM;
 		}
 	}
@@ -662,7 +663,8 @@ static int zr364xx_open(struct inode *in
 				     0, init[cam->method][i].bytes,
 				     init[cam->method][i].size);
 		if (err < 0) {
-			info("error during open sequence: %d", i);
+			dev_err(&cam->udev->dev,
+				"error during open sequence: %d\n", i);
 			mutex_unlock(&cam->lock);
 			return err;
 		}
@@ -703,7 +705,7 @@ static int zr364xx_release(struct inode 
 				     0, init[i][cam->method].bytes,
 				     init[cam->method][i].size);
 		if (err < 0) {
-			info("error during release sequence");
+			dev_err(&udev->dev, "error during release sequence\n");
 			mutex_unlock(&cam->lock);
 			return err;
 		}
@@ -801,13 +803,14 @@ static int zr364xx_probe(struct usb_inte
 
 	DBG("probing...");
 
-	info(DRIVER_DESC " compatible webcam plugged");
-	info("model %04x:%04x detected", udev->descriptor.idVendor,
-	     udev->descriptor.idProduct);
+	dev_info(&intf->dev, DRIVER_DESC " compatible webcam plugged\n");
+	dev_info(&intf->dev, "model %04x:%04x detected\n",
+		 le16_to_cpu(udev->descriptor.idVendor),
+		 le16_to_cpu(udev->descriptor.idProduct));
 
 	cam = kzalloc(sizeof(struct zr364xx_camera), GFP_KERNEL);
 	if (cam == NULL) {
-		info("cam: out of memory !");
+		dev_err(&udev->dev, "cam: out of memory !\n");
 		return -ENOMEM;
 	}
 	/* save the init method used by this camera */
@@ -815,7 +818,7 @@ static int zr364xx_probe(struct usb_inte
 
 	cam->vdev = video_device_alloc();
 	if (cam->vdev == NULL) {
-		info("cam->vdev: out of memory !");
+		dev_err(&udev->dev, "cam->vdev: out of memory !\n");
 		kfree(cam);
 		return -ENOMEM;
 	}
@@ -827,7 +830,7 @@ static int zr364xx_probe(struct usb_inte
 	cam->udev = udev;
 
 	if ((cam->buffer = kmalloc(BUFFER_SIZE, GFP_KERNEL)) == NULL) {
-		info("cam->buffer: out of memory !");
+		dev_info(&udev->dev, "cam->buffer: out of memory !\n");
 		video_device_release(cam->vdev);
 		kfree(cam);
 		return -ENODEV;
@@ -835,17 +838,17 @@ static int zr364xx_probe(struct usb_inte
 
 	switch (mode) {
 	case 1:
-		info("160x120 mode selected");
+		dev_info(&udev->dev, "160x120 mode selected\n");
 		cam->width = 160;
 		cam->height = 120;
 		break;
 	case 2:
-		info("640x480 mode selected");
+		dev_info(&udev->dev, "640x480 mode selected\n");
 		cam->width = 640;
 		cam->height = 480;
 		break;
 	default:
-		info("320x240 mode selected");
+		dev_info(&udev->dev, "320x240 mode selected\n");
 		cam->width = 320;
 		cam->height = 240;
 		break;
@@ -865,7 +868,7 @@ static int zr364xx_probe(struct usb_inte
 
 	err = video_register_device(cam->vdev, VFL_TYPE_GRABBER, -1);
 	if (err) {
-		info("video_register_device failed");
+		dev_err(&udev->dev, "video_register_device failed\n");
 		video_device_release(cam->vdev);
 		kfree(cam->buffer);
 		kfree(cam);
@@ -874,7 +877,8 @@ static int zr364xx_probe(struct usb_inte
 
 	usb_set_intfdata(intf, cam);
 
-	info(DRIVER_DESC " controlling video device %d", cam->vdev->minor);
+	dev_info(&udev->dev, DRIVER_DESC " controlling video device %d\n",
+		 cam->vdev->minor);
 	return 0;
 }
 
@@ -884,7 +888,7 @@ static void zr364xx_disconnect(struct us
 	struct zr364xx_camera *cam = usb_get_intfdata(intf);
 	usb_set_intfdata(intf, NULL);
 	dev_set_drvdata(&intf->dev, NULL);
-	info(DRIVER_DESC " webcam unplugged");
+	dev_info(&intf->dev, DRIVER_DESC " webcam unplugged\n");
 	if (cam->vdev)
 		video_unregister_device(cam->vdev);
 	cam->vdev = NULL;
@@ -913,16 +917,16 @@ static int __init zr364xx_init(void)
 	int retval;
 	retval = usb_register(&zr364xx_driver);
 	if (retval)
-		info("usb_register failed!");
+		printk(KERN_ERR KBUILD_MODNAME ": usb_register failed!\n");
 	else
-		info(DRIVER_DESC " module loaded");
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
 	return retval;
 }
 
 
 static void __exit zr364xx_exit(void)
 {
-	info(DRIVER_DESC " module unloaded");
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC " module unloaded\n");
 	usb_deregister(&zr364xx_driver);
 }
 
